# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR The FreeBSD Project
# This file is distributed under the same license as the FreeBSD Documentation package.
# Kyung-tak, Yoo <stonegaze@me.com>, 2023.
# "Kyung-tak, Yoo" <stonegaze@me.com>, 2023.
msgid ""
msgstr ""
"Project-Id-Version: FreeBSD Documentation VERSION\n"
"POT-Creation-Date: 2023-04-20 20:56-0300\n"
"PO-Revision-Date: 2023-04-27 22:35+0000\n"
"Last-Translator: \"Kyung-tak, Yoo\" <stonegaze@me.com>\n"
"Language-Team: Korean <https://translate-dev.freebsd.org/projects/"
"documentation/bookshandbookgeom_index/ko/>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 4.17\n"

#. type: YAML Front Matter: description
#: documentation/content/en/books/handbook/geom/_index.adoc:1
#, no-wrap
msgid "In FreeBSD, the GEOM framework permits access and control to classes, such as Master Boot Records and BSD labels, through the use of providers, or the disk devices in /dev."
msgstr ""
"FreeBSD에서 GEOM 프레임워크는 공급자 또는 /dev의 디스크 장치를 사용하여 "
"마스터 부트 레코드 및 BSD 레이블과 같은 클래스에 대한 액세스 및 제어를 "
"허용합니다."

#. type: YAML Front Matter: part
#: documentation/content/en/books/handbook/geom/_index.adoc:1
#, no-wrap
msgid "Part III. System Administration"
msgstr "파트 III. 시스템 관리"

#. type: YAML Front Matter: title
#: documentation/content/en/books/handbook/geom/_index.adoc:1
#, no-wrap
msgid "Chapter 20. GEOM: Modular Disk Transformation Framework"
msgstr "20장. GEOM: 모듈식 디스크 변환 프레임워크"

#. type: Title =
#: documentation/content/en/books/handbook/geom/_index.adoc:14
#, no-wrap
msgid "GEOM: Modular Disk Transformation Framework"
msgstr "GEOM: 모듈식 디스크 변환 프레임워크"

#. type: Title ==
#: documentation/content/en/books/handbook/geom/_index.adoc:52
#, no-wrap
msgid "Synopsis"
msgstr "요약"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:56
msgid ""
"In FreeBSD, the GEOM framework permits access and control to classes, such "
"as Master Boot Records and BSD labels, through the use of providers, or the "
"disk devices in [.filename]#/dev#.  By supporting various software RAID "
"configurations, GEOM transparently provides access to the operating system "
"and operating system utilities."
msgstr ""
"FreeBSD에서 GEOM 프레임워크는 공급자 또는 [.filename]#/dev#의 디스크 장치를 "
"사용하여 마스터 부트 레코드 및 BSD 레이블과 같은 클래스에 대한 액세스 및 "
"제어를 허용합니다. 다양한 소프트웨어 RAID 구성을 지원함으로써 GEOM은 운영 "
"체제 및 운영 체제 유틸리티에 대한 액세스를 투명하게 제공합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:60
msgid ""
"This chapter covers the use of disks under the GEOM framework in FreeBSD.  "
"This includes the major RAID control utilities which use the framework for "
"configuration.  This chapter is not a definitive guide to RAID "
"configurations and only GEOM-supported RAID classifications are discussed."
msgstr ""
"이 장에서는 FreeBSD의 GEOM 프레임워크에서 디스크를 사용하는 방법을 다룹니다. "
"여기에는 구성을 위해 프레임워크를 사용하는 주요 RAID 제어 유틸리티가 "
"포함됩니다. 이 장은 RAID 구성에 대한 결정적인 가이드가 아니며 GEOM 지원 RAID "
"분류에 대해서만 설명합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:62
msgid "After reading this chapter, you will know:"
msgstr "이 챕터를 읽고 나면, 여러분은:"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:64
msgid "What type of RAID support is available through GEOM."
msgstr "GEOM을 통해 사용할 수 있는 RAID 지원 유형."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:65
msgid ""
"How to use the base utilities to configure, maintain, and manipulate the "
"various RAID levels."
msgstr "기본 유틸리티를 사용하여 다양한 RAID 레벨을 구성, 유지 및 조작하는 방법."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:66
msgid ""
"How to mirror, stripe, encrypt, and remotely connect disk devices through "
"GEOM."
msgstr "GEOM을 통해 디스크 장치를 미러링, 스트라이프, 암호화 및 원격으로 연결하는 "
"방법."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:67
msgid "How to troubleshoot disks attached to the GEOM framework."
msgstr "GEOM 프레임워크에 연결된 디스크 문제를 해결하는 방법."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:69
msgid "Before reading this chapter, you should:"
msgstr "이 챕터를 읽기 전에 여러분은:"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:71
msgid ""
"Understand how FreeBSD treats disk devices (crossref:disks[disks,Storage])."
msgstr "FreeBSD가 디스크 장치를 처리하는 방식을 "
"이해합니다(crossref:disks[disks,Storage])."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:72
msgid ""
"Know how to configure and install a new kernel (crossref:"
"kernelconfig[kernelconfig,Configuring the FreeBSD Kernel])."
msgstr ""
"새 커널을 구성하고 설치하는 방법을 알고 있습니다(crossref:kernelconfig["
"kernelconfig,FreeBSD 커널 구성])."

#. type: Title ==
#: documentation/content/en/books/handbook/geom/_index.adoc:74
#, no-wrap
msgid "RAID0 - Striping"
msgstr "RAID0 - Striping"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:79
msgid ""
"Striping combines several disk drives into a single volume.  Striping can be "
"performed through the use of hardware RAID controllers.  The GEOM disk "
"subsystem provides software support for disk striping, also known as RAID0, "
"without the need for a RAID disk controller."
msgstr ""
"스트라이핑은 여러 디스크 드라이브를 단일 볼륨으로 결합합니다. 스트라이핑은 "
"하드웨어 RAID 컨트롤러를 사용하여 수행할 수 있습니다. GEOM 디스크 하위 "
"시스템은 RAID 디스크 컨트롤러 없이 RAID0이라고도 하는 디스크 스트라이핑에 "
"대한 소프트웨어 지원을 제공합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:83
msgid ""
"In RAID0, data is split into blocks that are written across all the drives "
"in the array.  As seen in the following illustration, instead of having to "
"wait on the system to write 256k to one disk, RAID0 can simultaneously write "
"64k to each of the four disks in the array, offering superior I/O "
"performance.  This performance can be enhanced further by using multiple "
"disk controllers."
msgstr ""
"RAID0에서 데이터는 어레이의 모든 드라이브에 기록되는 블록으로 분할됩니다. "
"다음 그림에서 볼 수 있듯이 RAID0은 하나의 디스크에 256k를 쓰기 위해 시스템을 "
"기다릴 필요 없이 어레이에 있는 4개의 디스크 각각에 동시에 64k를 쓸 수 있어 "
"뛰어난 I/O 성능을 제공합니다. 이 성능은 여러 디스크 컨트롤러를 사용하여 더욱 "
"향상될 수 있습니다."

#. type: Positional ($1) AttributeList argument for macro 'image'
#: documentation/content/en/books/handbook/geom/_index.adoc:84
#, no-wrap
msgid "Disk Striping Illustration"
msgstr "디스크 스트라이핑 그림"

#. type: Target for macro image
#: documentation/content/en/books/handbook/geom/_index.adoc:84
#, no-wrap
msgid "striping.png"
msgstr "striping.png"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:87
msgid ""
"Each disk in a RAID0 stripe must be of the same size, since I/O requests are "
"interleaved to read or write to multiple disks in parallel."
msgstr "I/O 요청이 여러 디스크를 병렬로 읽거나 쓰기 위해 인터리브되므로 RAID0 "
"스트라이프의 각 디스크는 크기가 같아야 합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/geom/_index.adoc:93
msgid ""
"RAID0 does _not_ provide any redundancy.  This means that if one disk in the "
"array fails, all of the data on the disks is lost.  If the data is "
"important, implement a backup strategy that regularly saves backups to a "
"remote system or device."
msgstr ""
"RAID0은 _중복성을 제공하지 않습니다_. 즉, 어레이의 디스크 하나에 오류가 "
"발생하면 디스크의 모든 데이터가 손실됩니다. 데이터가 중요한 경우 원격 "
"시스템이나 장치에 정기적으로 백업을 저장하는 백업 전략을 구현하십시오."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:97
msgid ""
"The process for creating a software, GEOM-based RAID0 on a FreeBSD system "
"using commodity disks is as follows.  Once the stripe is created, refer to "
"man:gstripe[8] for more information on how to control an existing stripe."
msgstr ""
"상용 디스크를 사용하여 FreeBSD 시스템에서 소프트웨어, GEOM 기반 RAID0을 "
"생성하는 프로세스는 다음과 같습니다. 스트라이프가 생성되면 기존 스트라이프를 "
"제어하는 방법에 대한 자세한 내용은 man:gstripe[8]를 참조하십시오."

#. type: delimited block * 4
#: documentation/content/en/books/handbook/geom/_index.adoc:101
#, no-wrap
msgid "*Procedure: Creating a Stripe of Unformatted ATA Disks*\n"
msgstr "*절차: 포맷되지 않은 ATA 디스크 스트라이프 만들기*\n"

#. type: delimited block * 4
#: documentation/content/en/books/handbook/geom/_index.adoc:103
msgid "Load the [.filename]#geom_stripe.ko# module:"
msgstr "[.filename]#geom_stripe.ko# module을 로드합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:107
#, no-wrap
msgid "# kldload geom_stripe\n"
msgstr "# kldload geom_stripe\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:110
msgid ""
"Ensure that a suitable mount point exists. If this volume will become a root "
"partition, then temporarily use another mount point such as [.filename]#/"
"mnt#."
msgstr ""
"적합한 마운트 지점이 있는지 확인하십시오. 이 볼륨이 루트 파티션이 될 경우 "
"임시로 [.filename]#/mnt#와 같은 다른 마운트 지점을 사용하십시오."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:111
msgid ""
"Determine the device names for the disks which will be striped, and create "
"the new stripe device. For example, to stripe two unused and unpartitioned "
"ATA disks with device names of [.filename]#/dev/ad2# and [.filename]#/dev/"
"ad3#:"
msgstr ""
"스트라이핑할 디스크의 장치 이름을 결정하고 새 스트라이프 장치를 만듭니다. "
"예를 들어, 사용하지 않고 파티션 되지 않은 두 개의 ATA 디스크를 [.filename]#/"
"dev/ad2# 및 [.filename]#/dev/ad3#의 장치 이름으로 스트라이핑합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:118
#, no-wrap
msgid ""
"# gstripe label -v st0 /dev/ad2 /dev/ad3\n"
"Metadata value stored on /dev/ad2.\n"
"Metadata value stored on /dev/ad3.\n"
"Done.\n"
msgstr ""
"# gstripe label -v st0 /dev/ad2 /dev/ad3\n"
"Metadata value stored on /dev/ad2.\n"
"Metadata value stored on /dev/ad3.\n"
"Done.\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:121
msgid ""
"Write a standard label, also known as a partition table, on the new volume "
"and install the default bootstrap code:"
msgstr "새 볼륨에 표준 레이블(파티션 테이블이라고도 함)을 작성하고 기본 부트스트랩 "
"코드를 설치합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:125
#, no-wrap
msgid "# bsdlabel -wB /dev/stripe/st0\n"
msgstr "# bsdlabel -wB /dev/stripe/st0\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:128
msgid ""
"This process should create two other devices in [.filename]#/dev/stripe# in "
"addition to [.filename]#st0#. Those include [.filename]#st0a# and [."
"filename]#st0c#. At this point, a UFS file system can be created on [."
"filename]#st0a# using `newfs`:"
msgstr ""
"이 프로세스는 [.filename]#/dev/stripe#에 [.filename]#st0# 외에 두 개의 다른 "
"장치를 생성해야 합니다. 여기에는 [.filename]#st0a# 및 [.filename]#st0c#가 "
"포함됩니다. 이 시점에서 `newfs`를 사용하여 [.filename]#st0a#에 UFS 파일 "
"시스템을 생성할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:132
#, no-wrap
msgid "# newfs -U /dev/stripe/st0a\n"
msgstr "# newfs -U /dev/stripe/st0a\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:136
msgid ""
"Many numbers will glide across the screen, and after a few seconds, the "
"process will be complete.  The volume has been created and is ready to be "
"mounted."
msgstr ""
"많은 숫자가 화면을 가로지르며 미끄러지듯 지나가고 몇 초 후 프로세스가 "
"완료됩니다.  볼륨이 생성되었으며 마운트할 준비가 되었습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:137
msgid "To manually mount the created disk stripe:"
msgstr "생성된 디스크 스트라이프를 수동으로 마운트하려면:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:141
#, no-wrap
msgid "# mount /dev/stripe/st0a /mnt\n"
msgstr "# mount /dev/stripe/st0a /mnt\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:144
msgid ""
"To mount this striped file system automatically during the boot process, "
"place the volume information in [.filename]#/etc/fstab#. In this example, a "
"permanent mount point, named [.filename]#stripe#, is created:"
msgstr ""
"부팅 프로세스 중에 이 스트라이프 파일 시스템을 자동으로 마운트하려면 볼륨 "
"정보를 [.filename]#/etc/fstab#에 작성합니다. 이 예제에서는 [."
"filename]#stripe#라는 이름의 영구 마운트 지점이 생성됩니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:150
#, no-wrap
msgid ""
"# mkdir /stripe\n"
"# echo \"/dev/stripe/st0a /stripe ufs rw 2 2\" \\\n"
">> /etc/fstab\n"
msgstr ""
"# mkdir /stripe\n"
"# echo \"/dev/stripe/st0a /stripe ufs rw 2 2\" \\\n"
">> /etc/fstab\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:153
msgid ""
"The [.filename]#geom_stripe.ko# module must also be automatically loaded "
"during system initialization, by adding a line to [.filename]#/boot/loader."
"conf#:"
msgstr ""
"또한 시스템 초기화 중에 [.filename]#/boot/loader.conf#에 한 줄을 추가하여 [."
"filename]#geom_stripe.ko# 모듈을 자동으로 로드해야 합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:157
#, no-wrap
msgid "# echo 'geom_stripe_load=\"YES\"' >> /boot/loader.conf\n"
msgstr "# echo 'geom_stripe_load=\"YES\"' >> /boot/loader.conf\n"

#. type: Title ==
#: documentation/content/en/books/handbook/geom/_index.adoc:161
#, no-wrap
msgid "RAID1 - Mirroring"
msgstr "RAID1 - 미러링"

#. type: delimited block * 4
#: documentation/content/en/books/handbook/geom/_index.adoc:168
msgid ""
"RAID1, or _mirroring_, is the technique of writing the same data to more "
"than one disk drive.  Mirrors are usually used to guard against data loss "
"due to drive failure.  Each drive in a mirror contains an identical copy of "
"the data.  When an individual drive fails, the mirror continues to work, "
"providing data from the drives that are still functioning.  The computer "
"keeps running, and the administrator has time to replace the failed drive "
"without user interruption."
msgstr ""
"RAID1 또는 _미러링_은 둘 이상의 디스크 드라이브에 동일한 데이터를 쓰는 "
"기술입니다.  미러는 일반적으로 드라이브 장애로 인한 데이터 손실을 방지하는 "
"데 사용됩니다.  미러의 각 드라이브에는 동일한 데이터 사본이 들어 있습니다.  "
"개별 드라이브에 장애가 발생해도 미러는 계속 작동하며 정상 작동 중인 "
"드라이브에서 데이터를 제공할 수 있습니다.  컴퓨터는 계속 실행되고 관리자는 "
"시스템의 중단 없이 장애가 발생한 드라이브를 교체할 수 있는 시간을 확보할 수 "
"있습니다."

#. type: delimited block * 4
#: documentation/content/en/books/handbook/geom/_index.adoc:173
msgid ""
"Two common situations are illustrated in these examples.  The first creates "
"a mirror out of two new drives and uses it as a replacement for an existing "
"single drive.  The second example creates a mirror on a single new drive, "
"copies the old drive's data to it, then inserts the old drive into the "
"mirror.  While this procedure is slightly more complicated, it only requires "
"one new drive."
msgstr ""
"이 예에서는 두 가지 일반적인 상황을 설명합니다.  첫 번째는 두 개의 새 "
"드라이브에서 미러를 생성하여 기존 단일 드라이브를 대체하는 데 사용합니다.  "
"두 번째 예는 새 드라이브 하나에 미러를 생성하고 이전 드라이브의 데이터를 "
"미러에 복사한 다음 이전 드라이브를 미러에 삽입하는 것입니다.  이 절차는 약간 "
"더 복잡하지만 새 드라이브가 하나만 필요합니다."

#. type: delimited block * 4
#: documentation/content/en/books/handbook/geom/_index.adoc:178
msgid ""
"Traditionally, the two drives in a mirror are identical in model and "
"capacity, but man:gmirror[8] does not require that.  Mirrors created with "
"dissimilar drives will have a capacity equal to that of the smallest drive "
"in the mirror.  Extra space on larger drives will be unused.  Drives "
"inserted into the mirror later must have at least as much capacity as the "
"smallest drive already in the mirror."
msgstr ""
"일반적으로 미러의 두 드라이브는 모델과 용량이 동일해야 하지만, man:gmirror[8]"
"는 그럴 필요가 없습니다.  서로 다른 드라이브로 미러를 만들면 미러에서 가장 "
"작은 드라이브의 용량과 동일한 용량을 갖게 됩니다.  더 큰 드라이브의 추가 "
"공간은 사용되지 않습니다.  나중에 미러에 추가되는 드라이브는 미러에 이미 "
"있는 가장 작은 드라이브만큼의 용량을 가져야 합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/geom/_index.adoc:182
msgid ""
"The mirroring procedures shown here are non-destructive, but as with any "
"major disk operation, make a full backup first."
msgstr "여기에 표시된 미러링 절차는 비파괴적이지만 모든 주요 디스크 작업과 "
"마찬가지로 먼저 전체 백업을 만드세요."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/geom/_index.adoc:188
msgid ""
"While man:dump[8] is used in these procedures to copy file systems, it does "
"not work on file systems with soft updates journaling.  See man:tunefs[8] "
"for information on detecting and disabling soft updates journaling."
msgstr ""
"이 절차에서 man:dump[8]는 파일 시스템을 복사하는 데 사용되지만, 소프트 "
"업데이트 저널링이 있는 파일 시스템에서는 작동하지 않습니다.  소프트 업데이트 "
"저널링을 감지하고 비활성화하는 방법에 대한 자세한 내용은 man:tunefs[8]을 "
"참조하십시오."

#. type: Title ===
#: documentation/content/en/books/handbook/geom/_index.adoc:191
#, no-wrap
msgid "Metadata Issues"
msgstr "메타데이터 문제"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:196
msgid ""
"Many disk systems store metadata at the end of each disk.  Old metadata "
"should be erased before reusing the disk for a mirror.  Most problems are "
"caused by two particular types of leftover metadata: GPT partition tables "
"and old metadata from a previous mirror."
msgstr ""
"대부분의 디스크 시스템은 각 디스크의 끝에 메타데이터를 저장합니다.  "
"미러용으로 디스크를 재사용하기 전에 오래된 메타데이터를 지워야 합니다.  "
"대부분의 문제는 두 가지 특정 유형의 남은 메타데이터로 인해 발생합니다: GPT "
"파티션 테이블과 이전 미러의 오래된 메타데이터입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:199
msgid ""
"GPT metadata can be erased with man:gpart[8].  This example erases both "
"primary and backup GPT partition tables from disk [.filename]#ada8#:"
msgstr ""
"GPT 메타데이터는 man:gpart[8]로 지울 수 있습니다.  이 예는 디스크 [."
"filename]#ada8#에서 기본 및 백업 GPT 파티션 테이블을 모두 지웁니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:203
#, no-wrap
msgid "# gpart destroy -F ada8\n"
msgstr "# gpart destroy -F ada8\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:207
msgid ""
"A disk can be removed from an active mirror and the metadata erased in one "
"step using man:gmirror[8].  Here, the example disk [.filename]#ada8# is "
"removed from the active mirror [.filename]#gm4#:"
msgstr ""
"man:gmirror[8]를 사용하여 활성 미러에서 디스크를 제거하고 메타데이터를 한 "
"번에 지울 수 있습니다.  여기서는 예제 디스크 [.filename]#ada8#이 활성 미러 [."
"filename]#gm4#에서 제거됩니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:211
#, no-wrap
msgid "# gmirror remove gm4 ada8\n"
msgstr "# gmirror remove gm4 ada8\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:214
msgid ""
"If the mirror is not running, but old mirror metadata is still on the disk, "
"use `gmirror clear` to remove it:"
msgstr ""
"미러가 실행되고 있지 않지만 이전 미러 메타데이터가 여전히 디스크에 남아 있는 "
"경우, `gmirror clear`를 사용하여 제거합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:218
#, no-wrap
msgid "# gmirror clear ada8\n"
msgstr "# gmirror clear ada8\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:223
msgid ""
"man:gmirror[8] stores one block of metadata at the end of the disk.  As GPT "
"partition schemes also store metadata at the end of the disk, mirroring "
"entire GPT disks with man:gmirror[8] is not recommended.  MBR partitioning "
"is used here because it only stores a partition table at the start of the "
"disk and does not conflict with the mirror metadata."
msgstr ""
"man:gmirror[8]은 디스크 끝에 하나의 메타데이터 블록을 저장합니다.  GPT "
"파티션 스키마도 디스크 끝에 메타데이터를 저장하므로 man:gmirror[8]로 전체 "
"GPT 디스크를 미러링하는 것은 권장되지 않습니다.  MBR 파티션은 디스크 시작 "
"부분에만 파티션 테이블을 저장하고 미러 메타데이터와 충돌하지 않기 때문에 "
"여기에 사용됩니다."

#. type: Title ===
#: documentation/content/en/books/handbook/geom/_index.adoc:225
#, no-wrap
msgid "Creating a Mirror with Two New Disks"
msgstr "두 개의 새 디스크로 미러 만들기"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:230
msgid ""
"In this example, FreeBSD has already been installed on a single disk, [."
"filename]#ada0#.  Two new disks, [.filename]#ada1# and [.filename]#ada2#, "
"have been connected to the system.  A new mirror will be created on these "
"two disks and used to replace the old single disk."
msgstr ""
"이 예제에서는 FreeBSD가 이미 단일 디스크인 [.filename]#ada0#에 설치되어 "
"있습니다.  두 개의 새 디스크인 [.filename]#ada1# 및 [.filename]#ada2#가 "
"시스템에 연결되었습니다.  이 두 디스크에 새 미러가 생성되어 이전 단일 "
"디스크를 대체하는 데 사용됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:233
msgid ""
"The [.filename]#geom_mirror.ko# kernel module must either be built into the "
"kernel or loaded at boot- or run-time.  Manually load the kernel module now:"
msgstr ""
"[.filename]#geom_mirror.ko# 커널 모듈은 커널에 빌드되거나 부팅 또는 런타임에 "
"로드되어야 합니다.  지금 커널 모듈을 수동으로 로드하세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:237
#: documentation/content/en/books/handbook/geom/_index.adoc:359
#, no-wrap
msgid "# gmirror load\n"
msgstr "# gmirror load\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:240
msgid "Create the mirror with the two new drives:"
msgstr "두 개의 새 드라이브로 미러를 만듭니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:244
#, no-wrap
msgid "# gmirror label -v gm0 /dev/ada1 /dev/ada2\n"
msgstr "# gmirror label -v gm0 /dev/ada1 /dev/ada2\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:248
msgid ""
"[.filename]#gm0# is a user-chosen device name assigned to the new mirror.  "
"After the mirror has been started, this device name appears in [.filename]#/"
"dev/mirror/#."
msgstr ""
"[.filename]#gm0#은 새 미러에 할당된 사용자가 선택한 장치 이름입니다.  미러가 "
"시작되면 이 장치 이름은 [.filename]#/dev/mirror/#에 표시됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:252
msgid ""
"MBR and bsdlabel partition tables can now be created on the mirror with man:"
"gpart[8].  This example uses a traditional file system layout, with "
"partitions for [.filename]#/#, swap, [.filename]#/var#, [.filename]#/tmp#, "
"and [.filename]#/usr#.  A single [.filename]#/# and a swap partition will "
"also work."
msgstr ""
"이제 man:gpart[8]를 사용하여 미러에 MBR 및 bsdlabel 파티션 테이블을 생성할 "
"수 있습니다.  이 예제에서는 [.filename]#/#, 스왑, [.filename]#/var#, [."
"filename]#/tmp#, [.filename]#/usr#에 대한 파티션이 있는 기존 파일 시스템 "
"레이아웃을 사용합니다.  단일 [.filename]#/# 및 스왑 파티션도 작동합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:254
msgid ""
"Partitions on the mirror do not have to be the same size as those on the "
"existing disk, but they must be large enough to hold all the data already "
"present on [.filename]#ada0#."
msgstr ""
"미러의 파티션은 기존 디스크의 파티션과 크기가 같을 필요는 없지만 [."
"filename]#ada0#에 이미 있는 모든 데이터를 저장할 수 있을 만큼 충분히 커야 "
"합니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:264
#, no-wrap
msgid ""
"# gpart create -s MBR mirror/gm0\n"
"# gpart add -t freebsd -a 4k mirror/gm0\n"
"# gpart show mirror/gm0\n"
"=>       63  156301423  mirror/gm0  MBR  (74G)\n"
"         63         63                    - free -  (31k)\n"
"        126  156301299                 1  freebsd  (74G)\n"
"  156301425         61                    - free -  (30k)\n"
msgstr ""
"# gpart create -s MBR mirror/gm0\n"
"# gpart add -t freebsd -a 4k mirror/gm0\n"
"# gpart show mirror/gm0\n"
"=>       63  156301423  mirror/gm0  MBR  (74G)\n"
"         63         63                    - free -  (31k)\n"
"        126  156301299                 1  freebsd  (74G)\n"
"  156301425         61                    - free -  (30k)\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:283
#, no-wrap
msgid ""
"# gpart create -s BSD mirror/gm0s1\n"
"# gpart add -t freebsd-ufs  -a 4k -s 2g mirror/gm0s1\n"
"# gpart add -t freebsd-swap -a 4k -s 4g mirror/gm0s1\n"
"# gpart add -t freebsd-ufs  -a 4k -s 2g mirror/gm0s1\n"
"# gpart add -t freebsd-ufs  -a 4k -s 1g mirror/gm0s1\n"
"# gpart add -t freebsd-ufs  -a 4k mirror/gm0s1\n"
"# gpart show mirror/gm0s1\n"
"=>        0  156301299  mirror/gm0s1  BSD  (74G)\n"
"          0          2                      - free -  (1.0k)\n"
"          2    4194304                   1  freebsd-ufs  (2.0G)\n"
"    4194306    8388608                   2  freebsd-swap (4.0G)\n"
"   12582914    4194304                   4  freebsd-ufs  (2.0G)\n"
"   16777218    2097152                   5  freebsd-ufs  (1.0G)\n"
"   18874370  137426928                   6  freebsd-ufs  (65G)\n"
"  156301298          1                      - free -  (512B)\n"
msgstr ""
"# gpart create -s BSD mirror/gm0s1\n"
"# gpart add -t freebsd-ufs  -a 4k -s 2g mirror/gm0s1\n"
"# gpart add -t freebsd-swap -a 4k -s 4g mirror/gm0s1\n"
"# gpart add -t freebsd-ufs  -a 4k -s 2g mirror/gm0s1\n"
"# gpart add -t freebsd-ufs  -a 4k -s 1g mirror/gm0s1\n"
"# gpart add -t freebsd-ufs  -a 4k mirror/gm0s1\n"
"# gpart show mirror/gm0s1\n"
"=>        0  156301299  mirror/gm0s1  BSD  (74G)\n"
"          0          2                      - free -  (1.0k)\n"
"          2    4194304                   1  freebsd-ufs  (2.0G)\n"
"    4194306    8388608                   2  freebsd-swap (4.0G)\n"
"   12582914    4194304                   4  freebsd-ufs  (2.0G)\n"
"   16777218    2097152                   5  freebsd-ufs  (1.0G)\n"
"   18874370  137426928                   6  freebsd-ufs  (65G)\n"
"  156301298          1                      - free -  (512B)\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:286
#: documentation/content/en/books/handbook/geom/_index.adoc:504
msgid ""
"Make the mirror bootable by installing bootcode in the MBR and bsdlabel and "
"setting the active slice:"
msgstr "미러를 부팅할 수 있게 하려면 부트코드를 MBR과 bsdlabel에 설치하고 활성 "
"슬라이스를 설정합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:292
#: documentation/content/en/books/handbook/geom/_index.adoc:510
#, no-wrap
msgid ""
"# gpart bootcode -b /boot/mbr mirror/gm0\n"
"# gpart set -a active -i 1 mirror/gm0\n"
"# gpart bootcode -b /boot/boot mirror/gm0s1\n"
msgstr ""
"# gpart bootcode -b /boot/mbr mirror/gm0\n"
"# gpart set -a active -i 1 mirror/gm0\n"
"# gpart bootcode -b /boot/boot mirror/gm0s1\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:295
msgid "Format the file systems on the new mirror, enabling soft-updates."
msgstr "새 미러에서 파일 시스템을 포맷하여 소프트 업데이트를 활성화합니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:302
#, no-wrap
msgid ""
"# newfs -U /dev/mirror/gm0s1a\n"
"# newfs -U /dev/mirror/gm0s1d\n"
"# newfs -U /dev/mirror/gm0s1e\n"
"# newfs -U /dev/mirror/gm0s1f\n"
msgstr ""
"# newfs -U /dev/mirror/gm0s1a\n"
"# newfs -U /dev/mirror/gm0s1d\n"
"# newfs -U /dev/mirror/gm0s1e\n"
"# newfs -U /dev/mirror/gm0s1f\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:305
msgid ""
"File systems from the original [.filename]#ada0# disk can now be copied onto "
"the mirror with man:dump[8] and man:restore[8]."
msgstr ""
"이제 man:dump[8] 및 man:restore[8]을 사용하여 원본 [.filename]#ada0# "
"디스크의 파일 시스템을 미러에 복사할 수 있습니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:316
#, no-wrap
msgid ""
"# mount /dev/mirror/gm0s1a /mnt\n"
"# dump -C16 -b64 -0aL -f - / | (cd /mnt && restore -rf -)\n"
"# mount /dev/mirror/gm0s1d /mnt/var\n"
"# mount /dev/mirror/gm0s1e /mnt/tmp\n"
"# mount /dev/mirror/gm0s1f /mnt/usr\n"
"# dump -C16 -b64 -0aL -f - /var | (cd /mnt/var && restore -rf -)\n"
"# dump -C16 -b64 -0aL -f - /tmp | (cd /mnt/tmp && restore -rf -)\n"
"# dump -C16 -b64 -0aL -f - /usr | (cd /mnt/usr && restore -rf -)\n"
msgstr ""
"# mount /dev/mirror/gm0s1a /mnt\n"
"# dump -C16 -b64 -0aL -f - / | (cd /mnt && restore -rf -)\n"
"# mount /dev/mirror/gm0s1d /mnt/var\n"
"# mount /dev/mirror/gm0s1e /mnt/tmp\n"
"# mount /dev/mirror/gm0s1f /mnt/usr\n"
"# dump -C16 -b64 -0aL -f - /var | (cd /mnt/var && restore -rf -)\n"
"# dump -C16 -b64 -0aL -f - /tmp | (cd /mnt/tmp && restore -rf -)\n"
"# dump -C16 -b64 -0aL -f - /usr | (cd /mnt/usr && restore -rf -)\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:319
msgid ""
"Edit [.filename]#/mnt/etc/fstab# to point to the new mirror file systems:"
msgstr "새 미러 파일 시스템을 가리키도록 [.filename]#/mnt/etc/fstab#을 편집합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:328
#, no-wrap
msgid ""
"# Device\t\tMountpoint\tFStype\tOptions\tDump\tPass#\n"
"/dev/mirror/gm0s1a\t/\t\tufs\trw\t1\t1\n"
"/dev/mirror/gm0s1b\tnone\t\tswap\tsw\t0\t0\n"
"/dev/mirror/gm0s1d\t/var\t\tufs\trw\t2\t2\n"
"/dev/mirror/gm0s1e\t/tmp\t\tufs\trw\t2\t2\n"
"/dev/mirror/gm0s1f\t/usr\t\tufs\trw\t2\t2\n"
msgstr ""
"# Device\t\tMountpoint\tFStype\tOptions\tDump\tPass#\n"
"/dev/mirror/gm0s1a\t/\t\tufs\trw\t1\t1\n"
"/dev/mirror/gm0s1b\tnone\t\tswap\tsw\t0\t0\n"
"/dev/mirror/gm0s1d\t/var\t\tufs\trw\t2\t2\n"
"/dev/mirror/gm0s1e\t/tmp\t\tufs\trw\t2\t2\n"
"/dev/mirror/gm0s1f\t/usr\t\tufs\trw\t2\t2\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:331
msgid ""
"If the [.filename]#geom_mirror.ko# kernel module has not been built into the "
"kernel, [.filename]#/mnt/boot/loader.conf# is edited to load the module at "
"boot:"
msgstr ""
"커널 모듈이 커널에 빌드되지 않은 경우 [.filename]#geom_mirror.ko# 커널 "
"모듈이 부팅 시 모듈을 로드하도록 [.filename]#/mnt/boot/loader.conf#를 "
"편집합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:335
#: documentation/content/en/books/handbook/geom/_index.adoc:538
#: documentation/content/en/books/handbook/geom/_index.adoc:651
#, no-wrap
msgid "geom_mirror_load=\"YES\"\n"
msgstr "geom_mirror_load=\"YES\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:340
msgid ""
"Reboot the system to test the new mirror and verify that all data has been "
"copied.  The BIOS will see the mirror as two individual drives rather than a "
"mirror.  Since the drives are identical, it does not matter which is "
"selected to boot."
msgstr ""
"시스템을 재부팅하여 새 미러를 테스트하고 모든 데이터가 복사되었는지 "
"확인합니다.  BIOS는 미러를 하나의 드라이브가 아닌 두 개의 개별 드라이브로 "
"인식합니다.  드라이브가 동일하므로 어떤 드라이브를 부팅하도록 선택하든 "
"상관없습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:343
msgid ""
"See <<gmirror-troubleshooting>> if there are problems booting.  Powering "
"down and disconnecting the original [.filename]#ada0# disk will allow it to "
"be kept as an offline backup."
msgstr ""
"부팅에 문제가 있는 경우 <<gmirror-troubleshooting>>을 참조하세요.  원본 [."
"filename]#ada0# 디스크의 전원을 끄고 연결을 해제하면 오프라인 백업으로 "
"보관할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:345
msgid "In use, the mirror will behave just like the original single drive."
msgstr "사용 중 미러는 기존의 단일 드라이브와 똑같이 작동합니다."

#. type: Title ===
#: documentation/content/en/books/handbook/geom/_index.adoc:347
#, no-wrap
msgid "Creating a Mirror with an Existing Drive"
msgstr "기존 드라이브로 미러 만들기"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:353
msgid ""
"In this example, FreeBSD has already been installed on a single disk, [."
"filename]#ada0#.  A new disk, [.filename]#ada1#, has been connected to the "
"system.  A one-disk mirror will be created on the new disk, the existing "
"system copied onto it, and then the old disk will be inserted into the "
"mirror.  This slightly complex procedure is required because `gmirror` needs "
"to put a 512-byte block of metadata at the end of each disk, and the "
"existing [.filename]#ada0# has usually had all of its space already "
"allocated."
msgstr ""
"이 예제에서는 FreeBSD가 이미 단일 디스크인 [.filename]#ada0#에 설치되어 "
"있습니다.  새 디스크인 [.filename]#ada1#이 시스템에 연결되었습니다.  새 "
"디스크에 하나의 디스크 미러가 생성되고 기존 시스템이 이 디스크에 복사된 다음 "
"이전 디스크가 미러에 삽입됩니다.  이 약간 복잡한 절차가 필요한 이유는 "
"`gmirror`가 각 디스크 끝에 512바이트의 메타데이터 블록을 넣어야 하고, 기존 [."
"filename]#ada0#에는 일반적으로 이미 모든 공간이 할당되어 있기 때문입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:355
msgid "Load the [.filename]#geom_mirror.ko# kernel module:"
msgstr "[.filename]#geom_mirror.ko# 커널 모듈을 로드합니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:362
msgid "Check the media size of the original disk with `diskinfo`:"
msgstr "`diskinfo`로 원본 디스크의 미디어 크기를 확인합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:369
#, no-wrap
msgid ""
"# diskinfo -v ada0 | head -n3\n"
"/dev/ada0\n"
"        512             # sectorsize\n"
"        1000204821504   # mediasize in bytes (931G)\n"
msgstr ""
"# diskinfo -v ada0 | head -n3\n"
"/dev/ada0\n"
"        512             # sectorsize\n"
"        1000204821504   # mediasize in bytes (931G)\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:376
msgid ""
"Create a mirror on the new disk.  To make certain that the mirror capacity "
"is not any larger than the original [.filename]#ada0# drive, man:gnop[8] is "
"used to create a fake drive of the exact same size.  This drive does not "
"store any data, but is used only to limit the size of the mirror.  When man:"
"gmirror[8] creates the mirror, it will restrict the capacity to the size of "
"[.filename]#gzero.nop#, even if the new [.filename]#ada1# drive has more "
"space.  Note that the _1000204821504_ in the second line is equal to [."
"filename]#ada0#'s media size as shown by `diskinfo` above."
msgstr ""
"새 디스크에 미러를 만듭니다.  미러 용량이 원래 [.filename]#ada0# "
"드라이브보다 크지 않도록 하기 위해 man:gnop[8]을 사용하여 정확히 같은 크기의 "
"가짜 드라이브를 만듭니다.  이 드라이브는 데이터를 저장하지 않고 미러의 "
"크기를 한정하는 데만 사용됩니다.  man:gmirror[8]가 미러를 생성하면 새 [."
"filename]#ada1# 드라이브에 더 많은 공간이 있더라도 용량을 [.filename]#gzero."
"nop#의 크기로 제한합니다.  두 번째 줄의 _1000204821504_는 위의 `diskinfo`에 "
"표시된 대로 [.filename]#ada0#의 미디어 크기와 동일하다는 점에 유의하세요."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:383
#, no-wrap
msgid ""
"# geom zero load\n"
"# gnop create -s 1000204821504 gzero\n"
"# gmirror label -v gm0 gzero.nop ada1\n"
"# gmirror forget gm0\n"
msgstr ""
"# geom zero load\n"
"# gnop create -s 1000204821504 gzero\n"
"# gmirror label -v gm0 gzero.nop ada1\n"
"# gmirror forget gm0\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:388
msgid ""
"Since [.filename]#gzero.nop# does not store any data, the mirror does not "
"see it as connected.  The mirror is told to \"forget\" unconnected "
"components, removing references to [.filename]#gzero.nop#.  The result is a "
"mirror device containing only a single disk, [.filename]#ada1#."
msgstr ""
"[.filename]#gzero.nop#는 데이터를 저장하지 않으므로 미러는 연결된 것으로 "
"인식하지 않습니다.  미러는 연결되지 않은 구성 요소를 \"잊어버리도록\" "
"지시하여 [.filename]#gzero.nop#에 대한 참조를 제거합니다.  그 결과 미러 "
"장치에는 [.filename]#ada1#이라는 단일 디스크만 포함됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:392
msgid ""
"After creating [.filename]#gm0#, view the partition table on [."
"filename]#ada0#.  This output is from a 1 TB drive.  If there is some "
"unallocated space at the end of the drive, the contents may be copied "
"directly from [.filename]#ada0# to the new mirror."
msgstr ""
"[.filename]#gm0#을 만든 후 [.filename]#ada0#에서 파티션 테이블을 "
"확인합니다.  이 출력은 1TB 드라이브에서 가져온 것입니다.  드라이브 끝에 "
"할당되지 않은 공간이 있는 경우 [.filename]#ada0#에서 새 미러로 콘텐츠를 직접 "
"복사할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:394
msgid ""
"However, if the output shows that all of the space on the disk is allocated, "
"as in the following listing, there is no space available for the 512-byte "
"mirror metadata at the end of the disk."
msgstr ""
"그러나 다음 목록과 같이 출력에 디스크의 모든 공간이 할당된 것으로 표시되면 "
"디스크 끝에 512바이트의 미러 메타데이터에 사용할 수 있는 공간이 없는 "
"것입니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:400
#, no-wrap
msgid ""
"# gpart show ada0\n"
"=>        63  1953525105        ada0  MBR  (931G)\n"
"          63  1953525105           1  freebsd  [active]  (931G)\n"
msgstr ""
"# gpart show ada0\n"
"=>        63  1953525105        ada0  MBR  (931G)\n"
"          63  1953525105           1  freebsd  [active]  (931G)\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:404
msgid ""
"In this case, the partition table must be edited to reduce the capacity by "
"one sector on [.filename]#mirror/gm0#.  The procedure will be explained "
"later."
msgstr ""
"이 경우 파티션 테이블을 편집하여 [.filename]#mirror/gm0#의 용량을 한 섹터씩 "
"줄여야 합니다.  절차는 나중에 설명하겠습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:406
msgid ""
"In either case, partition tables on the primary disk should be first copied "
"using `gpart backup` and `gpart restore`."
msgstr ""
"두 경우 모두 기본 디스크의 파티션 테이블은 먼저 `gpart backup` 및 `gpart "
"restore`을 사용하여 복사해야 합니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:411
#, no-wrap
msgid ""
"# gpart backup ada0 > table.ada0\n"
"# gpart backup ada0s1 > table.ada0s1\n"
msgstr ""
"# gpart backup ada0 > table.ada0\n"
"# gpart backup ada0s1 > table.ada0s1\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:415
msgid ""
"These commands create two files, [.filename]#table.ada0# and [."
"filename]#table.ada0s1#.  This example is from a 1 TB drive:"
msgstr ""
"이 명령은 [.filename]#table.ada0# 및 [.filename]#table.ada0s1#이라는 두 개의 "
"파일을 생성합니다.  이 예는 1TB 드라이브에서 가져온 것입니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:421
#, no-wrap
msgid ""
"# cat table.ada0\n"
"MBR 4\n"
"1 freebsd         63 1953525105   [active]\n"
msgstr ""
"# cat table.ada0\n"
"MBR 4\n"
"1 freebsd         63 1953525105   [active]\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:433
#, no-wrap
msgid ""
"# cat table.ada0s1\n"
"BSD 8\n"
"1  freebsd-ufs          0    4194304\n"
"2 freebsd-swap    4194304   33554432\n"
"4  freebsd-ufs   37748736   50331648\n"
"5  freebsd-ufs   88080384   41943040\n"
"6  freebsd-ufs  130023424  838860800\n"
"7  freebsd-ufs  968884224  984640881\n"
msgstr ""
"# cat table.ada0s1\n"
"BSD 8\n"
"1  freebsd-ufs          0    4194304\n"
"2 freebsd-swap    4194304   33554432\n"
"4  freebsd-ufs   37748736   50331648\n"
"5  freebsd-ufs   88080384   41943040\n"
"6  freebsd-ufs  130023424  838860800\n"
"7  freebsd-ufs  968884224  984640881\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:438
msgid ""
"If no free space is shown at the end of the disk, the size of both the slice "
"and the last partition must be reduced by one sector.  Edit the two files, "
"reducing the size of both the slice and last partition by one.  These are "
"the last numbers in each listing."
msgstr ""
"디스크 끝에 여유 공간이 표시되지 않으면 슬라이스와 마지막 파티션의 크기를 "
"모두 한 섹터씩 줄여야 합니다.  두 파일을 편집하여 슬라이스와 마지막 파티션의 "
"크기를 모두 하나씩 줄입니다.  이것이 각 목록의 마지막 숫자입니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:444
#, no-wrap
msgid ""
"# cat table.ada0\n"
"MBR 4\n"
"1 freebsd         63 1953525104   [active]\n"
msgstr ""
"# cat table.ada0\n"
"MBR 4\n"
"1 freebsd         63 1953525104   [active]\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:456
#, no-wrap
msgid ""
"# cat table.ada0s1\n"
"BSD 8\n"
"1  freebsd-ufs          0    4194304\n"
"2 freebsd-swap    4194304   33554432\n"
"4  freebsd-ufs   37748736   50331648\n"
"5  freebsd-ufs   88080384   41943040\n"
"6  freebsd-ufs  130023424  838860800\n"
"7  freebsd-ufs  968884224  984640880\n"
msgstr ""
"# cat table.ada0s1\n"
"BSD 8\n"
"1  freebsd-ufs          0    4194304\n"
"2 freebsd-swap    4194304   33554432\n"
"4  freebsd-ufs   37748736   50331648\n"
"5  freebsd-ufs   88080384   41943040\n"
"6  freebsd-ufs  130023424  838860800\n"
"7  freebsd-ufs  968884224  984640880\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:459
msgid ""
"If at least one sector was unallocated at the end of the disk, these two "
"files can be used without modification."
msgstr "디스크 끝에 하나 이상의 섹터가 할당되지 않은 경우, 이 두 파일은 수정 없이 "
"사용할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:461
msgid "Now restore the partition table into [.filename]#mirror/gm0#:"
msgstr "이제 파티션 테이블을 [.filename]#mirror/gm0#로 복원합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:466
#, no-wrap
msgid ""
"# gpart restore mirror/gm0 < table.ada0\n"
"# gpart restore mirror/gm0s1 < table.ada0s1\n"
msgstr ""
"# gpart restore mirror/gm0 < table.ada0\n"
"# gpart restore mirror/gm0s1 < table.ada0s1\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:470
msgid ""
"Check the partition table with `gpart show`.  This example has [."
"filename]#gm0s1a# for [.filename]#/#, [.filename]#gm0s1d# for [.filename]#/"
"var#, [.filename]#gm0s1e# for [.filename]#/usr#, [.filename]#gm0s1f# for [."
"filename]#/data1#, and [.filename]#gm0s1g# for [.filename]#/data2#."
msgstr ""
"`gpart show`로 파티션 테이블을 확인합니다.  이 예제에서는 [.filename]#/#가 [."
"filename]#gm0s1a#에, [.filename]#/var#는 [.filename]#gm0s1d#에, [."
"filename]#/usr#는 [.filename]#gm0s1e#에, [.filename]#/data1#는 [."
"filename]#gm0s1f#에, [.filename]#/data2#는 [.filename]#gm0s1g#에 위치합니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:477
#, no-wrap
msgid ""
"# gpart show mirror/gm0\n"
"=>        63  1953525104  mirror/gm0  MBR  (931G)\n"
"          63  1953525042           1  freebsd  [active]  (931G)\n"
"  1953525105          62              - free -  (31k)\n"
msgstr ""
"# gpart show mirror/gm0\n"
"=>        63  1953525104  mirror/gm0  MBR  (931G)\n"
"          63  1953525042           1  freebsd  [active]  (931G)\n"
"  1953525105          62              - free -  (31k)\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:487
#, no-wrap
msgid ""
"# gpart show mirror/gm0s1\n"
"=>         0  1953525042  mirror/gm0s1  BSD  (931G)\n"
"           0     2097152             1  freebsd-ufs  (1.0G)\n"
"     2097152    16777216             2  freebsd-swap  (8.0G)\n"
"    18874368    41943040             4  freebsd-ufs  (20G)\n"
"    60817408    20971520             5  freebsd-ufs  (10G)\n"
"    81788928   629145600             6  freebsd-ufs  (300G)\n"
"   710934528  1242590514             7  freebsd-ufs  (592G)\n"
"  1953525042          63                - free -  (31k)\n"
msgstr ""
"# gpart show mirror/gm0s1\n"
"=>         0  1953525042  mirror/gm0s1  BSD  (931G)\n"
"           0     2097152             1  freebsd-ufs  (1.0G)\n"
"     2097152    16777216             2  freebsd-swap  (8.0G)\n"
"    18874368    41943040             4  freebsd-ufs  (20G)\n"
"    60817408    20971520             5  freebsd-ufs  (10G)\n"
"    81788928   629145600             6  freebsd-ufs  (300G)\n"
"   710934528  1242590514             7  freebsd-ufs  (592G)\n"
"  1953525042          63                - free -  (31k)\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:490
msgid ""
"Both the slice and the last partition must have at least one free block at "
"the end of the disk."
msgstr "슬라이스와 마지막 파티션 모두 디스크 끝에 하나 이상의 여유블록이 있어야 "
"합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:493
msgid ""
"Create file systems on these new partitions.  The number of partitions will "
"vary to match the original disk, [.filename]#ada0#."
msgstr "이 새 파티션에 파일 시스템을 만듭니다.  파티션 수는 원본 디스크인 [."
"filename]#ada0#와 일치하도록 변경됩니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:501
#, no-wrap
msgid ""
"# newfs -U /dev/mirror/gm0s1a\n"
"# newfs -U /dev/mirror/gm0s1d\n"
"# newfs -U /dev/mirror/gm0s1e\n"
"# newfs -U /dev/mirror/gm0s1f\n"
"# newfs -U /dev/mirror/gm0s1g\n"
msgstr ""
"# newfs -U /dev/mirror/gm0s1a\n"
"# newfs -U /dev/mirror/gm0s1d\n"
"# newfs -U /dev/mirror/gm0s1e\n"
"# newfs -U /dev/mirror/gm0s1f\n"
"# newfs -U /dev/mirror/gm0s1g\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:514
msgid ""
"Adjust [.filename]#/etc/fstab# to use the new partitions on the mirror.  "
"Back up this file first by copying it to [.filename]#/etc/fstab.orig#."
msgstr ""
"미러에서 새 파티션을 사용하도록 [.filename]#/etc/fstab#을 변경합니다.  먼저 "
"이 파일을 [.filename]#/etc/fstab.orig#에 복사하여 백업합니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:518
#, no-wrap
msgid "# cp /etc/fstab /etc/fstab.orig\n"
msgstr "# cp /etc/fstab /etc/fstab.orig\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:521
msgid ""
"Edit [.filename]#/etc/fstab#, replacing [.filename]#/dev/ada0# with [."
"filename]#mirror/gm0#."
msgstr ""
"[.filename]#/etc/fstab#을 편집하여 [.filename]#/dev/ada0#을 [.filename]#"
"mirror/gm0#로 바꿉니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:531
#, no-wrap
msgid ""
"# Device\t\tMountpoint\tFStype\tOptions\tDump\tPass#\n"
"/dev/mirror/gm0s1a\t/\t\tufs\trw\t1\t1\n"
"/dev/mirror/gm0s1b\tnone\t\tswap\tsw\t0\t0\n"
"/dev/mirror/gm0s1d\t/var\t\tufs\trw\t2\t2\n"
"/dev/mirror/gm0s1e\t/usr\t\tufs\trw\t2\t2\n"
"/dev/mirror/gm0s1f\t/data1\t\tufs\trw\t2\t2\n"
"/dev/mirror/gm0s1g\t/data2\t\tufs\trw\t2\t2\n"
msgstr ""
"# Device\t\tMountpoint\tFStype\tOptions\tDump\tPass#\n"
"/dev/mirror/gm0s1a\t/\t\tufs\trw\t1\t1\n"
"/dev/mirror/gm0s1b\tnone\t\tswap\tsw\t0\t0\n"
"/dev/mirror/gm0s1d\t/var\t\tufs\trw\t2\t2\n"
"/dev/mirror/gm0s1e\t/usr\t\tufs\trw\t2\t2\n"
"/dev/mirror/gm0s1f\t/data1\t\tufs\trw\t2\t2\n"
"/dev/mirror/gm0s1g\t/data2\t\tufs\trw\t2\t2\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:534
msgid ""
"If the [.filename]#geom_mirror.ko# kernel module has not been built into the "
"kernel, edit [.filename]#/boot/loader.conf# to load it at boot:"
msgstr ""
"커널 모듈이 커널에 빌드되지 않은 경우 [.filename]#geom_mirror.ko# 커널 "
"모듈이 부팅 시 로드되도록 [.filename]#/boot/loader.conf#를 편집합니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:542
msgid ""
"File systems from the original disk can now be copied onto the mirror with "
"man:dump[8] and man:restore[8].  Each file system dumped with `dump -L` will "
"create a snapshot first, which can take some time."
msgstr ""
"이제 man:dump[8] 및 man:restore[8]를 사용하여 원본 디스크의 파일 시스템을 "
"미러에 복사할 수 있습니다.  `dump -L`로 덤프된 각 파일 시스템은 먼저 "
"스냅샷을 생성하므로 시간이 다소 걸릴 수 있습니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:555
#, no-wrap
msgid ""
"# mount /dev/mirror/gm0s1a /mnt\n"
"# dump -C16 -b64 -0aL -f - /    | (cd /mnt && restore -rf -)\n"
"# mount /dev/mirror/gm0s1d /mnt/var\n"
"# mount /dev/mirror/gm0s1e /mnt/usr\n"
"# mount /dev/mirror/gm0s1f /mnt/data1\n"
"# mount /dev/mirror/gm0s1g /mnt/data2\n"
"# dump -C16 -b64 -0aL -f - /usr | (cd /mnt/usr && restore -rf -)\n"
"# dump -C16 -b64 -0aL -f - /var | (cd /mnt/var && restore -rf -)\n"
"# dump -C16 -b64 -0aL -f - /data1 | (cd /mnt/data1 && restore -rf -)\n"
"# dump -C16 -b64 -0aL -f - /data2 | (cd /mnt/data2 && restore -rf -)\n"
msgstr ""
"# mount /dev/mirror/gm0s1a /mnt\n"
"# dump -C16 -b64 -0aL -f - /    | (cd /mnt && restore -rf -)\n"
"# mount /dev/mirror/gm0s1d /mnt/var\n"
"# mount /dev/mirror/gm0s1e /mnt/usr\n"
"# mount /dev/mirror/gm0s1f /mnt/data1\n"
"# mount /dev/mirror/gm0s1g /mnt/data2\n"
"# dump -C16 -b64 -0aL -f - /usr | (cd /mnt/usr && restore -rf -)\n"
"# dump -C16 -b64 -0aL -f - /var | (cd /mnt/var && restore -rf -)\n"
"# dump -C16 -b64 -0aL -f - /data1 | (cd /mnt/data1 && restore -rf -)\n"
"# dump -C16 -b64 -0aL -f - /data2 | (cd /mnt/data2 && restore -rf -)\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:560
msgid ""
"Restart the system, booting from [.filename]#ada1#.  If everything is "
"working, the system will boot from [.filename]#mirror/gm0#, which now "
"contains the same data as [.filename]#ada0# had previously.  See <<gmirror-"
"troubleshooting>> if there are problems booting."
msgstr ""
"시스템을 재시작하여 [.filename]#ada1#에서 부팅합니다.  모든 것이 정상적으로 "
"작동하면 시스템이 [.filename]#mirror/gm0#에서 부팅되며, 이제 [."
"filename]#ada0#에 이전에 있던 것과 동일한 데이터가 포함됩니다.  부팅에 "
"문제가 있는 경우 <<gmirror-troubleshooting>>을 참조하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:562
msgid ""
"At this point, the mirror still consists of only the single [."
"filename]#ada1# disk."
msgstr "이 시점에 미러는 여전히 단일 [.filename]#ada1# 디스크로만 구성됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:564
msgid ""
"After booting from [.filename]#mirror/gm0# successfully, the final step is "
"inserting [.filename]#ada0# into the mirror."
msgstr ""
"[.filename]#mirror/gm0#에서 성공적으로 부팅된 후 마지막 단계는 [."
"filename]#ada0#를 미러에 삽입하는 것입니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/geom/_index.adoc:570
msgid ""
"When [.filename]#ada0# is inserted into the mirror, its former contents will "
"be overwritten by data from the mirror.  Make certain that [."
"filename]#mirror/gm0# has the same contents as [.filename]#ada0# before "
"adding [.filename]#ada0# to the mirror.  If the contents previously copied "
"by man:dump[8] and man:restore[8] are not identical to what was on [."
"filename]#ada0#, revert [.filename]#/etc/fstab# to mount the file systems on "
"[.filename]#ada0#, reboot, and start the whole procedure again."
msgstr ""
"[.filename]#ada0#를 미러에 삽입하면 이전 내용이 미러의 데이터로 "
"덮어씌워집니다.  미러에 [.filename]#ada0#을 추가하기 전에 [.filename]#mirror/"
"gm0#이 [.filename]#ada0#와 동일한 내용을 가지고 있는지 확인하세요.  "
"man:dump[8] 및 man:restore[8]로 이전에 복사한 내용이 [.filename]#ada0#에 "
"있는 내용과 동일하지 않으면 [.filename]#/etc/fstab#을 되돌리고 [."
"filename]#ada0#에 파일 시스템을 마운트한 후 재부팅하여 전체 절차를 다시 "
"시작하세요."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:576
#, no-wrap
msgid ""
"# gmirror insert gm0 ada0\n"
"GEOM_MIRROR: Device gm0: rebuilding provider ada0\n"
msgstr ""
"# gmirror insert gm0 ada0\n"
"GEOM_MIRROR: Device gm0: rebuilding provider ada0\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:580
msgid ""
"Synchronization between the two disks will start immediately.  Use `gmirror "
"status` to view the progress."
msgstr "두 디스크 간의 동기화가 즉시 시작됩니다.  진행 상황을 보려면 `gmirror status`"
"를 사용하세요."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:587
#, no-wrap
msgid ""
"# gmirror status\n"
"      Name    Status  Components\n"
"mirror/gm0  DEGRADED  ada1 (ACTIVE)\n"
"                      ada0 (SYNCHRONIZING, 64%)\n"
msgstr ""
"# gmirror status\n"
"      Name    Status  Components\n"
"mirror/gm0  DEGRADED  ada1 (ACTIVE)\n"
"                      ada0 (SYNCHRONIZING, 64%)\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:590
msgid "After a while, synchronization will finish."
msgstr "잠시 후 동기화가 완료됩니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:598
#, no-wrap
msgid ""
"GEOM_MIRROR: Device gm0: rebuilding provider ada0 finished.\n"
"# gmirror status\n"
"      Name    Status  Components\n"
"mirror/gm0  COMPLETE  ada1 (ACTIVE)\n"
"                      ada0 (ACTIVE)\n"
msgstr ""
"GEOM_MIRROR: Device gm0: rebuilding provider ada0 finished.\n"
"# gmirror status\n"
"      Name    Status  Components\n"
"mirror/gm0  COMPLETE  ada1 (ACTIVE)\n"
"                      ada0 (ACTIVE)\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:602
msgid ""
"[.filename]#mirror/gm0# now consists of the two disks [.filename]#ada0# and "
"[.filename]#ada1#, and the contents are automatically synchronized with each "
"other.  In use, [.filename]#mirror/gm0# will behave just like the original "
"single drive."
msgstr ""
"이제 [.filename]#mirror/gm0#는 두 개의 디스크 [.filename]#ada0#과 [."
"filename]#ada1#으로 구성되며, 콘텐츠는 서로 자동으로 동기화됩니다.  사용 시 ["
".filename]#mirror/gm0#은 기존의 단일 드라이브처럼 작동합니다."

#. type: Title ===
#: documentation/content/en/books/handbook/geom/_index.adoc:604
#, no-wrap
msgid "Troubleshooting"
msgstr "문제 해결"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:608
msgid ""
"If the system no longer boots, BIOS settings may have to be changed to boot "
"from one of the new mirrored drives.  Either mirror drive can be used for "
"booting, as they contain identical data."
msgstr ""
"시스템이 더 이상 부팅되지 않으면 새 미러 드라이브 중 하나에서 부팅하도록 "
"BIOS 설정을 변경해야 할 수 있습니다.  두 미러 드라이브 모두 동일한 데이터가 "
"포함되어 있으므로 부팅에 사용할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:610
msgid ""
"If the boot stops with this message, something is wrong with the mirror "
"device:"
msgstr "이 메시지와 함께 부팅이 중지되면 미러 장치에 문제가 있는 것입니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:614
#, no-wrap
msgid "Mounting from ufs:/dev/mirror/gm0s1a failed with error 19.\n"
msgstr "Mounting from ufs:/dev/mirror/gm0s1a failed with error 19.\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:618
#, no-wrap
msgid ""
"Loader variables:\n"
"  vfs.root.mountfrom=ufs:/dev/mirror/gm0s1a\n"
"  vfs.root.mountfrom.options=rw\n"
msgstr ""
"Loader variables:\n"
"  vfs.root.mountfrom=ufs:/dev/mirror/gm0s1a\n"
"  vfs.root.mountfrom.options=rw\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:623
#, no-wrap
msgid ""
"Manual root filesystem specification:\n"
"  <fstype>:<device> [options]\n"
"      Mount <device> using filesystem <fstype>\n"
"      and with the specified (optional) option list.\n"
msgstr ""
"Manual root filesystem specification:\n"
"  <fstype>:<device> [options]\n"
"      Mount <device> using filesystem <fstype>\n"
"      and with the specified (optional) option list.\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:628
#, no-wrap
msgid ""
"    e.g. ufs:/dev/da0s1a\n"
"        zfs:tank\n"
"        cd9660:/dev/acd0 ro\n"
"          (which is equivalent to: mount -t cd9660 -o ro /dev/acd0 /)\n"
msgstr ""
"    e.g. ufs:/dev/da0s1a\n"
"        zfs:tank\n"
"        cd9660:/dev/acd0 ro\n"
"          (which is equivalent to: mount -t cd9660 -o ro /dev/acd0 /)\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:632
#, no-wrap
msgid ""
"  ?               List valid disk boot devices\n"
"  .               Yield 1 second (for background tasks)\n"
"  <empty line>    Abort manual input\n"
msgstr ""
"  ?               List valid disk boot devices\n"
"  .               Yield 1 second (for background tasks)\n"
"  <empty line>    Abort manual input\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:634
#, no-wrap
msgid "mountroot>\n"
msgstr "mountroot>\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:639
msgid ""
"Forgetting to load the [.filename]#geom_mirror.ko# module in [.filename]#/"
"boot/loader.conf# can cause this problem.  To fix it, boot from a FreeBSD "
"installation media and choose `Shell` at the first prompt.  Then load the "
"mirror module and mount the mirror device:"
msgstr ""
"[.filename]#/boot/loader.conf#에 [.filename]#geom_mirror.ko# 모듈을 로드하는 "
"것을 잊어버리면 이런 문제가 발생할 수 있습니다.  이 문제를 해결하려면 "
"FreeBSD 설치 미디어에서 부팅하고 첫 번째 프롬프트에서 `Shell`을 선택합니다.  "
"그런 다음 미러 모듈을 로드하고 미러 장치를 마운트합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:644
#, no-wrap
msgid ""
"# gmirror load\n"
"# mount /dev/mirror/gm0s1a /mnt\n"
msgstr ""
"# gmirror load\n"
"# mount /dev/mirror/gm0s1a /mnt\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:647
msgid ""
"Edit [.filename]#/mnt/boot/loader.conf#, adding a line to load the mirror "
"module:"
msgstr "[.filename]#/mnt/boot/loader.conf#를 편집하여 미러 모듈을 로드하도록 내용을 "
"추가합니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:654
msgid "Save the file and reboot."
msgstr "파일을 저장하고 재부팅합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:660
msgid ""
"Other problems that cause `error 19` require more effort to fix.  Although "
"the system should boot from [.filename]#ada0#, another prompt to select a "
"shell will appear if [.filename]#/etc/fstab# is incorrect.  Enter `ufs:/dev/"
"ada0s1a` at the boot loader prompt and press kbd:[Enter].  Undo the edits in "
"[.filename]#/etc/fstab# then mount the file systems from the original disk "
"([.filename]#ada0#) instead of the mirror.  Reboot the system and try the "
"procedure again."
msgstr ""
"`error 19`를 유발하는 다른 문제는 수정하는 데 더 많은 노력이 필요합니다.  "
"시스템이 [.filename]#ada0#에서 부팅되어야 하는데 [.filename]#/etc/fstab#이 "
"올바르지 않은 경우 셸을 선택하라는 다른 프롬프트가 나타납니다.  부트로더 "
"프롬프트에 `ufs:/dev/ada0s1a`를 입력하고 kbd:[Enter]를 누릅니다.  [."
"filename]#/etc/fstab#의 편집한 내용을 취소한 다음, 미러가 아닌 원본 디스크([."
"filename]#ada0#)에서 파일 시스템을 마운트합니다.  시스템을 재부팅하고 절차를 "
"다시 시도합니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:666
#, no-wrap
msgid ""
"Enter full pathname of shell or RETURN for /bin/sh:\n"
"# cp /etc/fstab.orig /etc/fstab\n"
"# reboot\n"
msgstr ""
"Enter full pathname of shell or RETURN for /bin/sh:\n"
"# cp /etc/fstab.orig /etc/fstab\n"
"# reboot\n"

#. type: Title ===
#: documentation/content/en/books/handbook/geom/_index.adoc:668
#, no-wrap
msgid "Recovering from Disk Failure"
msgstr "디스크 장애에서 복구하기"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:672
msgid ""
"The benefit of disk mirroring is that an individual disk can fail without "
"causing the mirror to lose any data.  In the above example, if [."
"filename]#ada0# fails, the mirror will continue to work, providing data from "
"the remaining working drive, [.filename]#ada1#."
msgstr ""
"디스크 미러링의 장점은 개별 디스크에 장애가 발생해도 미러 자체의 데이터는 "
"손실되지 않는다는 것입니다.  위의 예에서 [.filename]#ada0#에 장애가 발생해도 "
"미러는 계속 동작하며 나머지 정상 드라이브인 [.filename]#ada1#에서 데이터를 "
"제공합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:676
msgid ""
"To replace the failed drive, shut down the system and physically replace the "
"failed drive with a new drive of equal or greater capacity.  Manufacturers "
"use somewhat arbitrary values when rating drives in gigabytes, and the only "
"way to really be sure is to compare the total count of sectors shown by "
"`diskinfo -v`.  A drive with larger capacity than the mirror will work, "
"although the extra space on the new drive will not be used."
msgstr ""
"고장난 드라이브를 교체하려면 시스템을 종료하고 고장난 드라이브를 동일하거나 "
"더 큰 용량의 새 드라이브로 물리적으로 교체합니다.  제조업체는 드라이브를 "
"기가바이트 단위로 평가할 때 다소 자의적인 기준을 사용하므로 실제로 확인하는 "
"유일한 방법은 `diskinfo -v`에 표시된 총 섹터 수를 비교하는 것입니다.  "
"미러보다 용량이 큰 드라이브는 작동하지만 새 드라이브의 남는 공간은 사용되지 "
"않습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:679
msgid ""
"After the computer is powered back up, the mirror will be running in a "
"\"degraded\" mode with only one drive.  The mirror is told to forget drives "
"that are not currently connected:"
msgstr ""
"컴퓨터의 전원이 다시 켜지면 미러는 하나의 드라이브만 있는 '성능 저하' 모드로 "
"실행됩니다.  미러는 현재 연결되지 않은 드라이브를 무시하도록 지시받습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:683
#, no-wrap
msgid "# gmirror forget gm0\n"
msgstr "# gmirror forget gm0\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:687
msgid ""
"Any old metadata should be cleared from the replacement disk using the "
"instructions in <<geom-mirror-metadata>>.  Then the replacement disk, [."
"filename]#ada4# for this example, is inserted into the mirror:"
msgstr ""
"<<geom-mirror-metadata>>의 지침에 따라 교체 디스크에서 이전 메타데이터를 "
"모두 지워야 합니다.  그런 다음 대체 디스크(이 예에서는 [.filename]#ada4#)를 "
"미러에 삽입합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:691
#, no-wrap
msgid "# gmirror insert gm0 /dev/ada4\n"
msgstr "# gmirror insert gm0 /dev/ada4\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:696
msgid ""
"Resynchronization begins when the new drive is inserted into the mirror.  "
"This process of copying mirror data to a new drive can take a while.  "
"Performance of the mirror will be greatly reduced during the copy, so "
"inserting new drives is best done when there is low demand on the computer."
msgstr ""
"새 드라이브를 미러에 삽입하면 재동기화가 시작됩니다.  미러 데이터를 새 "
"드라이브에 복사하는 이 과정은 시간이 오래 걸릴 수 있습니다.  복사하는 동안 "
"미러의 성능이 크게 저하되므로 새 드라이브를 삽입하는 것은 컴퓨터의 부하가 "
"적을 때 하는 것이 가장 좋습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:699
msgid ""
"Progress can be monitored with `gmirror status`, which shows drives that are "
"being synchronized and the percentage of completion.  During "
"resynchronization, the status will be `DEGRADED`, changing to `COMPLETE` "
"when the process is finished."
msgstr ""
"동기화 중인 드라이브와 완료 비율을 표시하는 `gmirror status`로 진행 상황을 "
"모니터링할 수 있습니다.  재동기화 중에 상태는 `DEGRADED`으로 표시되며, "
"프로세스가 완료되면 `COMPLETE`로 변경됩니다."

#. type: Title ==
#: documentation/content/en/books/handbook/geom/_index.adoc:701
#, no-wrap
msgid "RAID3 - Byte-level Striping with Dedicated Parity"
msgstr "RAID3 - 전용 패리티를 사용한 바이트 레벨 스트라이핑"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:709
msgid ""
"RAID3 is a method used to combine several disk drives into a single volume "
"with a dedicated parity disk.  In a RAID3 system, data is split up into a "
"number of bytes that are written across all the drives in the array except "
"for one disk which acts as a dedicated parity disk.  This means that disk "
"reads from a RAID3 implementation access all disks in the array.  "
"Performance can be enhanced by using multiple disk controllers.  The RAID3 "
"array provides a fault tolerance of 1 drive, while providing a capacity of 1 "
"- 1/n times the total capacity of all drives in the array, where n is the "
"number of hard drives in the array.  Such a configuration is mostly suitable "
"for storing data of larger sizes such as multimedia files."
msgstr ""
"RAID3는 여러 디스크 드라이브를 전용 패리티 디스크와 함께 단일 볼륨으로 "
"결합하는 데 사용하는 방법입니다.  RAID3 시스템에서 데이터는 전용 패리티 "
"디스크 역할을 하는 하나의 디스크를 제외한 어레이의 모든 드라이브에 기록되는 "
"여러 바이트 단위로 분할됩니다.  즉, RAID3 구현에서 디스크를 읽으면 어레이의 "
"모든 디스크에 액세스합니다.  여러 디스크 컨트롤러를 사용하면 성능을 향상시킬 "
"수 있습니다.  RAID3 어레이는 1개의 드라이브에 대해 내결함성을 제공하는 "
"동시에 어레이에 있는 모든 드라이브의 총 용량의 1 - 1/n배의 용량을 제공합니다("
"여기서 n은 어레이에 있는 하드 드라이브의 수입니다).  이러한 구성은 주로 "
"멀티미디어 파일과 같이 크기가 큰 데이터를 저장하는 데 적합합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:713
msgid ""
"At least 3 physical hard drives are required to build a RAID3 array.  Each "
"disk must be of the same size, since I/O requests are interleaved to read or "
"write to multiple disks in parallel.  Also, due to the nature of RAID3, the "
"number of drives must be equal to 3, 5, 9, 17, and so on, or 2^n + 1."
msgstr ""
"RAID3 어레이를 구축하려면 최소 3개의 물리적 하드 드라이브가 필요합니다.  "
"여러 디스크를 병렬로 읽거나 쓰기 위해 I/O 요청이 인터리빙되므로 각 디스크의 "
"크기는 동일해야 합니다.  또한 RAID3의 특성상 드라이브의 수는 3, 5, 9, 17 등 "
"또는 2^n + 1과 같아야 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:715
msgid ""
"This section demonstrates how to create a software RAID3 on a FreeBSD system."
msgstr "이 섹션에서는 FreeBSD 시스템에서 소프트웨어 RAID3를 생성하는 방법을 "
"설명합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/geom/_index.adoc:719
msgid ""
"While it is theoretically possible to boot from a RAID3 array on FreeBSD, "
"that configuration is uncommon and is not advised."
msgstr "이론적으로는 FreeBSD의 RAID3 어레이에서 부팅할 수 있지만, 이 구성은 "
"일반적이지 않으며 권장하지 않습니다."

#. type: Title ===
#: documentation/content/en/books/handbook/geom/_index.adoc:721
#, no-wrap
msgid "Creating a Dedicated RAID3 Array"
msgstr "전용 RAID3 어레이 만들기"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:725
msgid ""
"In FreeBSD, support for RAID3 is implemented by the man:graid3[8] GEOM "
"class.  Creating a dedicated RAID3 array on FreeBSD requires the following "
"steps."
msgstr ""
"FreeBSD에서 RAID3에 대한 지원은 man:graid3[8] GEOM 클래스에 의해 "
"구현됩니다.  FreeBSD에서 전용 RAID3 어레이를 만들려면 다음 단계가 필요합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:728
msgid ""
"First, load the [.filename]#geom_raid3.ko# kernel module by issuing one of "
"the following commands:"
msgstr "먼저 다음 명령 중 하나를 실행하여 [.filename]#geom_raid3.ko# 커널 모듈을 "
"로드합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:732
#, no-wrap
msgid "# graid3 load\n"
msgstr "# graid3 load\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:735
msgid "or:"
msgstr "또는:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:739
#, no-wrap
msgid "# kldload geom_raid3\n"
msgstr "# kldload geom_raid3\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:742
msgid ""
"Ensure that a suitable mount point exists. This command creates a new "
"directory to use as the mount point:"
msgstr "적절한 마운트 지점이 있는지 확인합니다. 이 명령은 마운트 지점으로 사용할 새 "
"디렉터리를 만듭니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:746
#, no-wrap
msgid "# mkdir /multimedia\n"
msgstr "# mkdir /multimedia\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:749
msgid ""
"Determine the device names for the disks which will be added to the array, "
"and create the new RAID3 device. The final device listed will act as the "
"dedicated parity disk. This example uses three unpartitioned ATA drives: [."
"filename]#ada1# and [.filename]#ada2# for data, and [.filename]#ada3# for "
"parity."
msgstr ""
"어레이에 추가할 디스크의 장치 이름을 결정하고 새 RAID3 장치를 생성합니다. "
"마지막으로 나열된 장치가 전용 패리티 디스크로 작동합니다. 이 예에서는 "
"파티션되지 않은 ATA 드라이브 3개를 사용합니다: 데이터용은 [.filename]#ada1#"
"과 [.filename]#ada2#, 패리티용은 [.filename]#ada3#입니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:757
#, no-wrap
msgid ""
"# graid3 label -v gr0 /dev/ada1 /dev/ada2 /dev/ada3\n"
"Metadata value stored on /dev/ada1.\n"
"Metadata value stored on /dev/ada2.\n"
"Metadata value stored on /dev/ada3.\n"
"Done.\n"
msgstr ""
"# graid3 label -v gr0 /dev/ada1 /dev/ada2 /dev/ada3\n"
"Metadata value stored on /dev/ada1.\n"
"Metadata value stored on /dev/ada2.\n"
"Metadata value stored on /dev/ada3.\n"
"Done.\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:760
msgid ""
"Partition the newly created [.filename]#gr0# device and put a UFS file "
"system on it:"
msgstr "새로 생성한 [.filename]#gr0# 장치를 파티션하고 그 위에 UFS 파일 시스템을 "
"설치합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:766
#, no-wrap
msgid ""
"# gpart create -s GPT /dev/raid3/gr0\n"
"# gpart add -t freebsd-ufs /dev/raid3/gr0\n"
"# newfs -j /dev/raid3/gr0p1\n"
msgstr ""
"# gpart create -s GPT /dev/raid3/gr0\n"
"# gpart add -t freebsd-ufs /dev/raid3/gr0\n"
"# newfs -j /dev/raid3/gr0p1\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:770
msgid ""
"Many numbers will glide across the screen, and after a bit of time, the "
"process will be complete.  The volume has been created and is ready to be "
"mounted:"
msgstr ""
"많은 숫자가 화면을 가로질러 미끄러지듯 움직이고 잠시 후 프로세스가 "
"완료됩니다.  볼륨이 생성되었으며 마운트할 준비가 되었습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:774
#, no-wrap
msgid "# mount /dev/raid3/gr0p1 /multimedia/\n"
msgstr "# mount /dev/raid3/gr0p1 /multimedia/\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:777
msgid "The RAID3 array is now ready to use."
msgstr "이제 RAID3 어레이를 사용할 준비가 되었습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:779
msgid ""
"Additional configuration is needed to retain this setup across system "
"reboots."
msgstr "시스템 재부팅 시에도 이 설정을 유지하려면 추가 구성이 필요합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:782
msgid ""
"The [.filename]#geom_raid3.ko# module must be loaded before the array can be "
"mounted. To automatically load the kernel module during system "
"initialization, add the following line to [.filename]#/boot/loader.conf#:"
msgstr ""
"어레이를 마운트하기 전에 [.filename]#geom_raid3.ko# 모듈을 로드해야 합니다. "
"시스템 초기화 중에 커널 모듈을 자동으로 로드하려면 [.filename]#/boot/loader."
"conf#에 다음 줄을 추가합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:786
#, no-wrap
msgid "geom_raid3_load=\"YES\"\n"
msgstr "geom_raid3_load=\"YES\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:789
msgid ""
"The following volume information must be added to [.filename]#/etc/fstab# in "
"order to automatically mount the array's file system during the system boot "
"process:"
msgstr ""
"시스템 부팅 프로세스 중에 어레이의 파일 시스템을 자동으로 마운트하려면 [."
"filename]#/etc/fstab#에 다음 볼륨 정보를 추가해야 합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:793
#, no-wrap
msgid "/dev/raid3/gr0p1\t/multimedia\tufs\trw\t2\t2\n"
msgstr "/dev/raid3/gr0p1\t/multimedia\tufs\trw\t2\t2\n"

#. type: Title ==
#: documentation/content/en/books/handbook/geom/_index.adoc:796
#, no-wrap
msgid "Software RAID Devices"
msgstr "소프트웨어 RAID 장치"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:801
msgid ""
"Some motherboards and expansion cards add some simple hardware, usually just "
"a ROM, that allows the computer to boot from a RAID array.  After booting, "
"access to the RAID array is handled by software running on the computer's "
"main processor.  This \"hardware-assisted software RAID\" gives RAID arrays "
"that are not dependent on any particular operating system, and which are "
"functional even before an operating system is loaded."
msgstr ""
"일부 마더보드와 확장 카드는 컴퓨터가 RAID 어레이에서 부팅할 수 있도록 간단한 "
"하드웨어(일반적으로 ROM 뿐인)를 추가합니다.  부팅 후에는 컴퓨터의 메인 "
"프로세서에서 실행되는 소프트웨어에 의해 RAID 어레이에 대한 액세스가 "
"처리됩니다.  이 \"하드웨어 지원 소프트웨어 RAID\"는 특정 운영 체제에 "
"종속되지 않고 운영 체제가 로드되기 전에도 동작하는 RAID 어레이를 제공합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:804
msgid ""
"Several levels of RAID are supported, depending on the hardware in use.  See "
"man:graid[8] for a complete list."
msgstr "사용 중인 하드웨어에 따라 여러 수준의 RAID가 지원됩니다.  전체 목록은 "
"man:graid[8]를 참조하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:807
msgid ""
"man:graid[8] requires the [.filename]#geom_raid.ko# kernel module, which is "
"included in the [.filename]#GENERIC# kernel starting with FreeBSD 9.1.  If "
"needed, it can be loaded manually with `graid load`."
msgstr ""
"man:graid[8]를 사용하려면 [.filename]#geom_raid.ko# 커널 모듈이 필요하며, 이 "
"모듈은 FreeBSD 9.1부터 [.filename]#GENERIC# 커널에 포함되어 있습니다.  "
"필요한 경우 `graid load`로 수동 로드할 수 있습니다."

#. type: Title ===
#: documentation/content/en/books/handbook/geom/_index.adoc:809
#, no-wrap
msgid "Creating an Array"
msgstr "어레이 만들기"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:814
msgid ""
"Software RAID devices often have a menu that can be entered by pressing "
"special keys when the computer is booting.  The menu can be used to create "
"and delete RAID arrays.  man:graid[8] can also create arrays directly from "
"the command line."
msgstr ""
"소프트웨어 RAID 장치에는 컴퓨터가 부팅될 때 특수 키를 눌러 들어갈 수 있는 "
"메뉴가 있는 경우가 많습니다.  이 메뉴는 RAID 어레이를 생성하고 삭제하는 데 "
"사용할 수 있습니다. man:graid[8]는 명령줄에서 직접 어레이를 생성할 수도 "
"있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:818
msgid ""
"`graid label` is used to create a new array.  The motherboard used for this "
"example has an Intel software RAID chipset, so the Intel metadata format is "
"specified.  The new array is given a label of [.filename]#gm0#, it is a "
"mirror (RAID1), and uses drives [.filename]#ada0# and [.filename]#ada1#."
msgstr ""
"`graid label`은 새 어레이를 생성하는 데 사용됩니다.  이 예제에 사용된 "
"마더보드에는 인텔 소프트웨어 RAID 칩셋이 있으므로 인텔 메타데이터 형식이 "
"지정됩니다.  새 어레이에는 [.filename]#gm0# 레이블이 지정되며, 미러(RAID1)"
"이며 [.filename]#ada0#와 [.filename]#ada1# 드라이브를 사용합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/geom/_index.adoc:823
msgid ""
"Some space on the drives will be overwritten when they are made into a new "
"array.  Back up existing data first!"
msgstr "드라이브의 일부 공간은 새 배열로 만들 때 덮어쓰기됩니다.  기존 데이터를 먼저 "
"백업하세요!"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:837
#, no-wrap
msgid ""
"# graid label Intel gm0 RAID1 ada0 ada1\n"
"GEOM_RAID: Intel-a29ea104: Array Intel-a29ea104 created.\n"
"GEOM_RAID: Intel-a29ea104: Disk ada0 state changed from NONE to ACTIVE.\n"
"GEOM_RAID: Intel-a29ea104: Subdisk gm0:0-ada0 state changed from NONE to ACTIVE.\n"
"GEOM_RAID: Intel-a29ea104: Disk ada1 state changed from NONE to ACTIVE.\n"
"GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 state changed from NONE to ACTIVE.\n"
"GEOM_RAID: Intel-a29ea104: Array started.\n"
"GEOM_RAID: Intel-a29ea104: Volume gm0 state changed from STARTING to OPTIMAL.\n"
"Intel-a29ea104 created\n"
"GEOM_RAID: Intel-a29ea104: Provider raid/r0 for volume gm0 created.\n"
msgstr ""
"# graid label Intel gm0 RAID1 ada0 ada1\n"
"GEOM_RAID: Intel-a29ea104: Array Intel-a29ea104 created.\n"
"GEOM_RAID: Intel-a29ea104: Disk ada0 state changed from NONE to ACTIVE.\n"
"GEOM_RAID: Intel-a29ea104: Subdisk gm0:0-ada0 state changed from NONE to "
"ACTIVE.\n"
"GEOM_RAID: Intel-a29ea104: Disk ada1 state changed from NONE to ACTIVE.\n"
"GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 state changed from NONE to "
"ACTIVE.\n"
"GEOM_RAID: Intel-a29ea104: Array started.\n"
"GEOM_RAID: Intel-a29ea104: Volume gm0 state changed from STARTING to OPTIMAL."
"\n"
"Intel-a29ea104 created\n"
"GEOM_RAID: Intel-a29ea104: Provider raid/r0 for volume gm0 created.\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:840
msgid "A status check shows the new mirror is ready for use:"
msgstr "상태 확인을 통해 새 미러를 사용할 준비가 되었음을 알 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:847
#: documentation/content/en/books/handbook/geom/_index.adoc:1023
#, no-wrap
msgid ""
"# graid status\n"
"   Name   Status  Components\n"
"raid/r0  OPTIMAL  ada0 (ACTIVE (ACTIVE))\n"
"                  ada1 (ACTIVE (ACTIVE))\n"
msgstr ""
"# graid status\n"
"   Name   Status  Components\n"
"raid/r0  OPTIMAL  ada0 (ACTIVE (ACTIVE))\n"
"                  ada1 (ACTIVE (ACTIVE))\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:852
msgid ""
"The array device appears in [.filename]#/dev/raid/#.  The first array is "
"called [.filename]#r0#.  Additional arrays, if present, will be [."
"filename]#r1#, [.filename]#r2#, and so on."
msgstr ""
"어레이 장치는 [.filename]#/dev/raid/#에 나타납니다.  첫 번째 어레이는 [."
"filename]#r0#이라고 합니다.  추가 어레이가 있는 경우 [.filename]#r1#, [."
"filename]#r2# 등의 어레이로 명명됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:856
msgid ""
"The BIOS menu on some of these devices can create arrays with special "
"characters in their names.  To avoid problems with those special characters, "
"arrays are given simple numbered names like [.filename]#r0#.  To show the "
"actual labels, like [.filename]#gm0# in the example above, use man:sysctl[8]:"
msgstr ""
"이러한 장치 중 일부의 BIOS 메뉴에서는 이름에 특수 문자가 포함된 어레이를 "
"만들 수 있습니다.  이러한 특수 문자로 인한 문제를 방지하기 위해 어레이에는 [."
"filename]#r0#과 같은 간단한 번호가 매겨진 이름이 지정됩니다.  위 예제에서 [."
"filename]#gm0#과 같은 실제 레이블을 표시하려면 man:sysctl[8]을 사용합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:860
#, no-wrap
msgid "# sysctl kern.geom.raid.name_format=1\n"
msgstr "# sysctl kern.geom.raid.name_format=1\n"

#. type: Title ===
#: documentation/content/en/books/handbook/geom/_index.adoc:863
#, no-wrap
msgid "Multiple Volumes"
msgstr "다중 볼륨"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:869
msgid ""
"Some software RAID devices support more than one _volume_ on an array.  "
"Volumes work like partitions, allowing space on the physical drives to be "
"split and used in different ways.  For example, Intel software RAID devices "
"support two volumes.  This example creates a 40 G mirror for safely storing "
"the operating system, followed by a 20 G RAID0 (stripe) volume for fast "
"temporary storage:"
msgstr ""
"일부 소프트웨어 RAID 장치는 하나의 어레이에 둘 이상의 _볼륨_을 지원합니다.  "
"볼륨은 파티션처럼 작동하여 물리적 드라이브의 공간을 분할하여 다른 방식으로 "
"사용할 수 있습니다.  예를 들어, 인텔 소프트웨어 RAID 장치는 두 개의 볼륨을 "
"지원합니다.  이 예에서는 운영 체제를 안전하게 저장하기 위해 40G 미러를 "
"생성하고, 빠른 임시 저장공간을 위해 20G RAID0(스트라이프) 볼륨을 생성합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:874
#, no-wrap
msgid ""
"# graid label -S 40G Intel gm0 RAID1 ada0 ada1\n"
"# graid add -S 20G gm0 RAID0\n"
msgstr ""
"# graid label -S 40G Intel gm0 RAID1 ada0 ada1\n"
"# graid add -S 20G gm0 RAID0\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:878
msgid ""
"Volumes appear as additional [.filename]#rX# entries in [.filename]#/dev/"
"raid/#.  An array with two volumes will show [.filename]#r0# and [."
"filename]#r1#."
msgstr ""
"볼륨은 [.filename]#/dev/raid/#에 추가되어 [.filename]#rX#로 표시됩니다.  "
"볼륨이 2개인 어레이는 [.filename]#r0# 및 [.filename]#r1#으로 표시됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:880
msgid ""
"See man:graid[8] for the number of volumes supported by different software "
"RAID devices."
msgstr "다른 소프트웨어 RAID 장치에서 지원하는 볼륨 수는 man:graid[8]를 참조하세요."

#. type: Title ===
#: documentation/content/en/books/handbook/geom/_index.adoc:882
#, no-wrap
msgid "Converting a Single Drive to a Mirror"
msgstr "단일 드라이브를 미러로 변환하기"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:886
msgid ""
"Under certain specific conditions, it is possible to convert an existing "
"single drive to a man:graid[8] array without reformatting.  To avoid data "
"loss during the conversion, the existing drive must meet these minimum "
"requirements:"
msgstr ""
"특정 조건에서는 기존 단일 드라이브를 다시 포맷하지 않고도 man:graid[8] "
"어레이로 변환할 수 있습니다.  변환하는 동안 데이터 손실을 방지하려면 기존 "
"드라이브가 다음의 최소 요구 사항을 충족해야 합니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:888
msgid ""
"The drive must be partitioned with the MBR partitioning scheme. GPT or other "
"partitioning schemes with metadata at the end of the drive will be "
"overwritten and corrupted by the man:graid[8] metadata."
msgstr ""
"드라이브는 MBR 파티션 체계로 파티셔닝해야 합니다. 드라이브 끝에 메타데이터가 "
"있는 GPT 또는 기타 파티셔닝 체계는 man:graid[8] 메타데이터로 덮어 씌여지며 "
"손상됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:889
msgid ""
"There must be enough unpartitioned and unused space at the end of the drive "
"to hold the man:graid[8] metadata. This metadata varies in size, but the "
"largest occupies 64 M, so at least that much free space is recommended."
msgstr ""
"드라이브 끝에 man:graid[8] 메타데이터를 저장할 수 있는 파티션되지 않고 "
"사용되지 않은 충분한 공간이 있어야 합니다. 이 메타데이터의 크기는 다양하지만 "
"가장 큰 메타데이터는 64M를 차지하므로 최소한 그 정도의 여유 공간을 확보하는 "
"것이 좋습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:892
msgid ""
"If the drive meets these requirements, start by making a full backup.  Then "
"create a single-drive mirror with that drive:"
msgstr ""
"드라이브가 이러한 요구 사항을 충족하는 경우, 먼저 전체 백업을 만드세요.  "
"그런 다음 해당 드라이브로 단일 드라이브 미러를 만듭니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:896
#, no-wrap
msgid "# graid label Intel gm0 RAID1 ada0 NONE\n"
msgstr "# graid label Intel gm0 RAID1 ada0 NONE\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:900
msgid ""
"man:graid[8] metadata was written to the end of the drive in the unused "
"space.  A second drive can now be inserted into the mirror:"
msgstr ""
"man:graid[8] 메타데이터가 드라이브 끝의 사용되지 않는 공간에 기록됩니다.  "
"이제 미러에 두 번째 드라이브를 삽입할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:904
#, no-wrap
msgid "# graid insert raid/r0 ada1\n"
msgstr "# graid insert raid/r0 ada1\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:908
msgid ""
"Data from the original drive will immediately begin to be copied to the "
"second drive.  The mirror will operate in degraded status until the copy is "
"complete."
msgstr ""
"원본 드라이브의 데이터가 즉시 두 번째 드라이브에 복사되기 시작합니다.  "
"미러는 복사가 완료될 때까지 성능이 저하된 상태로 작동합니다."

#. type: Title ===
#: documentation/content/en/books/handbook/geom/_index.adoc:910
#, no-wrap
msgid "Inserting New Drives into the Array"
msgstr "어레이에 새 드라이브 추가하기"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:915
msgid ""
"Drives can be inserted into an array as replacements for drives that have "
"failed or are missing.  If there are no failed or missing drives, the new "
"drive becomes a spare.  For example, inserting a new drive into a working "
"two-drive mirror results in a two-drive mirror with one spare drive, not a "
"three-drive mirror."
msgstr ""
"장애가 발생했거나 누락된 드라이브의 대체하기 위해 드라이브를 어레이에 추가할 "
"수 있습니다.  실패하거나 누락된 드라이브가 없는 경우 새 드라이브가 예비 "
"드라이브(스페어 드라이브)가 됩니다.  예를 들어, 작동 중인 2-드라이브 미러에 "
"새 드라이브를 삽입하면 3-드라이브 미러가 아니라 예비 드라이브가 하나 있는 2-"
"드라이브 미러가 됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:918
msgid ""
"In the example mirror array, data immediately begins to be copied to the "
"newly-inserted drive.  Any existing information on the new drive will be "
"overwritten."
msgstr ""
"예제에선, 미러 어레이에 새로 삽입된 드라이브로 즉시 데이터를 복사하기 "
"시작합니다.  새 드라이브에 있는 기존 정보는 모두 덮어쓰기됩니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:926
#, no-wrap
msgid ""
"# graid insert raid/r0 ada1\n"
"GEOM_RAID: Intel-a29ea104: Disk ada1 state changed from NONE to ACTIVE.\n"
"GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 state changed from NONE to NEW.\n"
"GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 state changed from NEW to REBUILD.\n"
"GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 rebuild start at 0.\n"
msgstr ""
"# graid insert raid/r0 ada1\n"
"GEOM_RAID: Intel-a29ea104: Disk ada1 state changed from NONE to ACTIVE.\n"
"GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 state changed from NONE to NEW."
"\n"
"GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 state changed from NEW to "
"REBUILD.\n"
"GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 rebuild start at 0.\n"

#. type: Title ===
#: documentation/content/en/books/handbook/geom/_index.adoc:929
#, no-wrap
msgid "Removing Drives from the Array"
msgstr "어레이에서 드라이브 제거하기"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:932
msgid ""
"Individual drives can be permanently removed from a from an array and their "
"metadata erased:"
msgstr "개별 드라이브는 어레이에서 영구적으로 제거하고 해당 메타데이터를 삭제할 수 "
"있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:939
#, no-wrap
msgid ""
"# graid remove raid/r0 ada1\n"
"GEOM_RAID: Intel-a29ea104: Disk ada1 state changed from ACTIVE to OFFLINE.\n"
"GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-[unknown] state changed from ACTIVE to NONE.\n"
"GEOM_RAID: Intel-a29ea104: Volume gm0 state changed from OPTIMAL to DEGRADED.\n"
msgstr ""
"# graid remove raid/r0 ada1\n"
"GEOM_RAID: Intel-a29ea104: Disk ada1 state changed from ACTIVE to OFFLINE.\n"
"GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-[unknown] state changed from ACTIVE "
"to NONE.\n"
"GEOM_RAID: Intel-a29ea104: Volume gm0 state changed from OPTIMAL to DEGRADED."
"\n"

#. type: Title ===
#: documentation/content/en/books/handbook/geom/_index.adoc:942
#, no-wrap
msgid "Stopping the Array"
msgstr "어레이 중지하기"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:946
msgid ""
"An array can be stopped without removing metadata from the drives.  The "
"array will be restarted when the system is booted."
msgstr "드라이브에서 메타데이터를 제거하지 않고도 어레이를 중지할 수 있습니다.  "
"시스템이 부팅되면 어레이가 다시 시작됩니다."

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:950
#, no-wrap
msgid "# graid stop raid/r0\n"
msgstr "# graid stop raid/r0\n"

#. type: Title ===
#: documentation/content/en/books/handbook/geom/_index.adoc:953
#, no-wrap
msgid "Checking Array Status"
msgstr "어레이 상태 확인하기"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:957
msgid ""
"Array status can be checked at any time.  After a drive was added to the "
"mirror in the example above, data is being copied from the original drive to "
"the new drive:"
msgstr ""
"어레이 상태는 언제든지 확인할 수 있습니다.  위의 예에서 미러에 드라이브를 "
"추가한 후 원본 드라이브에서 새 드라이브로 데이터가 복사되고 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:964
#, no-wrap
msgid ""
"# graid status\n"
"   Name    Status  Components\n"
"raid/r0  DEGRADED  ada0 (ACTIVE (ACTIVE))\n"
"                   ada1 (ACTIVE (REBUILD 28%))\n"
msgstr ""
"# graid status\n"
"   Name    Status  Components\n"
"raid/r0  DEGRADED  ada0 (ACTIVE (ACTIVE))\n"
"                   ada1 (ACTIVE (REBUILD 28%))\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:968
msgid ""
"Some types of arrays, like `RAID0` or `CONCAT`, may not be shown in the "
"status report if disks have failed.  To see these partially-failed arrays, "
"add `-ga`:"
msgstr ""
"`RAID0` 또는 `CONCAT`과 같은 일부 유형의 어레이는 디스크가 실패한 경우 상태 "
"보고서에 표시되지 않을 수 있습니다.  이러한 부분적으로 실패한 어레이를 "
"보려면 `-ga`를 추가합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:974
#, no-wrap
msgid ""
"# graid status -ga\n"
"          Name  Status  Components\n"
"Intel-e2d07d9a  BROKEN  ada6 (ACTIVE (ACTIVE))\n"
msgstr ""
"# graid status -ga\n"
"          Name  Status  Components\n"
"Intel-e2d07d9a  BROKEN  ada6 (ACTIVE (ACTIVE))\n"

#. type: Title ===
#: documentation/content/en/books/handbook/geom/_index.adoc:977
#, no-wrap
msgid "Deleting Arrays"
msgstr "어레이 삭제하기"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:981
msgid ""
"Arrays are destroyed by deleting all of the volumes from them.  When the "
"last volume present is deleted, the array is stopped and metadata is removed "
"from the drives:"
msgstr ""
"어레이는 어레이에서 모든 볼륨을 삭제하여 파괴됩니다.  마지막으로 존재하는 "
"볼륨이 삭제되면 어레이가 중지되고 메타데이터가 드라이브에서 제거됩니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:985
#: documentation/content/en/books/handbook/geom/_index.adoc:1030
#, no-wrap
msgid "# graid delete raid/r0\n"
msgstr "# graid delete raid/r0\n"

#. type: Title ===
#: documentation/content/en/books/handbook/geom/_index.adoc:988
#, no-wrap
msgid "Deleting Unexpected Arrays"
msgstr "예기치 않은 어레이 삭제하기"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:993
msgid ""
"Drives may unexpectedly contain man:graid[8] metadata, either from previous "
"use or manufacturer testing.  man:graid[8] will detect these drives and "
"create an array, interfering with access to the individual drive.  To remove "
"the unwanted metadata:"
msgstr ""
"드라이브에 이전에 사용했거나 제조업체 테스트에서 사용된 man:graid[8] "
"메타데이터가 포함되어 있을 수 있습니다. man:graid[8]는 이러한 드라이브를 "
"감지하고 어레이를 생성하여 개별 드라이브에 대한 액세스를 방해합니다.  원치 "
"않는 메타데이터를 제거하려면:"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:996
msgid ""
"Boot the system. At the boot menu, select `2` for the loader prompt. Enter:"
msgstr "시스템을 부팅합니다. 부팅 메뉴에서 로더 프롬프트에서 `2`를 선택합니다. "
"엔터를 칩니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:1001
#, no-wrap
msgid ""
"OK set kern.geom.raid.enable=0\n"
"OK boot\n"
msgstr ""
"OK set kern.geom.raid.enable=0\n"
"OK boot\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:1004
msgid "The system will boot with man:graid[8] disabled."
msgstr "시스템이 man:graid[8]를 비활성화한 상태로 부팅됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:1005
msgid "Back up all data on the affected drive."
msgstr "영향을 받은 드라이브의 모든 데이터를 백업하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:1006
msgid "As a workaround, man:graid[8] array detection can be disabled by adding"
msgstr "해결 방법으로 다음을 추가하여 man:graid[8] 어레이 감지를 비활성화할 수 "
"있습니다"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:1010
#, no-wrap
msgid "kern.geom.raid.enable=0\n"
msgstr "kern.geom.raid.enable=0\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:1013
msgid "to [.filename]#/boot/loader.conf#."
msgstr "[.filename]#/boot/loader.conf#에서."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:1016
msgid ""
"To permanently remove the man:graid[8] metadata from the affected drive, "
"boot a FreeBSD installation CD-ROM or memory stick, and select `Shell`.  Use "
"`status` to find the name of the array, typically `raid/r0`:"
msgstr ""
"영향을 받은 드라이브에서 man:graid[8] 메타데이터를 영구적으로 제거하려면, "
"FreeBSD 설치 CD-ROM 또는 메모리 스틱으로 부팅하고 `Shell`을 선택합니다.  "
"`status`를 사용하여 어레이의 이름(일반적으로 `raid/r0`)을 찾습니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:1026
msgid "Delete the volume by name:"
msgstr "이름을 이용해 볼륨을 삭제합니다:"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:1034
msgid ""
"If there is more than one volume shown, repeat the process for each volume.  "
"After the last array has been deleted, the volume will be destroyed."
msgstr "표시된 볼륨이 두 개 이상인 경우 각 볼륨에 대해 이 과정을 반복합니다.  마지막 "
"어레이가 삭제되면 볼륨이 삭제됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:1037
msgid ""
"Reboot and verify data, restoring from backup if necessary.  After the "
"metadata has been removed, the `kern.geom.raid.enable=0` entry in [."
"filename]#/boot/loader.conf# can also be removed."
msgstr ""
"재부팅하고 데이터를 확인하며 필요한 경우 백업에서 복원합니다.  메타데이터를 "
"제거한 후 [.filename]#/boot/loader.conf#의 `kern.geom.raid.enable=0` 항목도 "
"제거할 수 있습니다."

#. type: Title ==
#: documentation/content/en/books/handbook/geom/_index.adoc:1039
#, no-wrap
msgid "GEOM Gate Network"
msgstr "GEOM 게이트 네트워크"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:1044
msgid ""
"GEOM provides a simple mechanism for providing remote access to devices such "
"as disks, CDs, and file systems through the use of the GEOM Gate network "
"daemon, ggated.  The system with the device runs the server daemon which "
"handles requests made by clients using ggatec.  The devices should not "
"contain any sensitive data as the connection between the client and the "
"server is not encrypted."
msgstr ""
"GEOM은 디스크, CD, 파일 시스템과 같은 장치에 원격 액세스를 제공하기 위한 "
"간단한 메커니즘을 제공하는데, 이 메커니즘은 GEOM 게이트 네트워크 데몬인 "
"ggated를 사용합니다.  장치가 있는 시스템은 서버 데몬을 실행하며, 이 서버 "
"데몬은 ggatec를 사용하여 클라이언트의 요청을 처리합니다.  클라이언트와 서버 "
"간의 연결이 암호화되지 않으므로 장치에 민감한 데이터가 포함되어서는 안 "
"됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:1048
msgid ""
"Similar to NFS, which is discussed in crossref:network-servers[network-nfs,"
"\"Network File System (NFS)\"], ggated is configured using an exports file.  "
"This file specifies which systems are permitted to access the exported "
"resources and what level of access they are offered.  For example, to give "
"the client `192.168.1.5` read and write access to the fourth slice on the "
"first SCSI disk, create [.filename]#/etc/gg.exports# with this line:"
msgstr ""
"Crossref:network-servers[network-nfs,\"네트워크 파일 시스템(NFS)\"]에서 "
"설명하는 NFS와 유사하게, ggated는 내보내기 파일을 사용하여 구성됩니다.  이 "
"파일은 내보낸 리소스에 액세스할 수 있는 시스템과 제공되는 액세스 수준을 "
"지정합니다.  예를 들어 클라이언트 `192.168.1.5`에 첫 번째 SCSI 디스크의 네 "
"번째 슬라이스에 대한 읽기 및 쓰기 액세스 권한을 부여하려면 다음 줄을 "
"사용하여 [.filename]#/etc/gg.exports#를 만듭니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:1052
#, no-wrap
msgid "192.168.1.5 RW /dev/da0s4d\n"
msgstr "192.168.1.5 RW /dev/da0s4d\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:1056
msgid ""
"Before exporting the device, ensure it is not currently mounted.  Then, "
"start ggated:"
msgstr "장치를 내보내기 전에 장치가 현재 마운트되어 있지 않은지 확인하세요.  그런 "
"다음 ggated를 시작합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:1060
#, no-wrap
msgid "# ggated\n"
msgstr "# ggated\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:1064
msgid ""
"Several options are available for specifying an alternate listening port or "
"changing the default location of the exports file.  Refer to man:ggated[8] "
"for details."
msgstr ""
"대체 수신 포트를 지정하거나 내보내기 파일의 기본 위치를 변경하는 데 몇 가지 "
"옵션을 사용할 수 있습니다.  자세한 내용은 man:ggated[8]을 참조하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:1069
msgid ""
"To access the exported device on the client machine, first use `ggatec` to "
"specify the IP address of the server and the device name of the exported "
"device.  If successful, this command will display a `ggate` device name to "
"mount.  Mount that specified device name on a free mount point.  This "
"example connects to the [.filename]#/dev/da0s4d# partition on `192.168.1.1`, "
"then mounts [.filename]#/dev/ggate0# on [.filename]#/mnt#:"
msgstr ""
"클라이언트 시스템에서 내보낸 장치에 액세스하려면 먼저 `ggatec`을 사용하여 "
"서버의 IP 주소와 내보낸 장치의 장치 이름을 지정합니다.  성공하면 이 명령은 "
"마운트할 `ggate` 장치 이름을 표시합니다.  지정한 장치 이름을 사용 가능한 "
"마운트 지점에 마운트합니다.  이 예는 `192.168.1.1`의 [.filename]#/dev/da0s4d#"
" 파티션에 연결한 다음 [.filename]#/mnt#에 [.filename]#/dev/ggate0#을 "
"마운트합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:1075
#, no-wrap
msgid ""
"# ggatec create -o rw 192.168.1.1 /dev/da0s4d\n"
"ggate0\n"
"# mount /dev/ggate0 /mnt\n"
msgstr ""
"# ggatec create -o rw 192.168.1.1 /dev/da0s4d\n"
"ggate0\n"
"# mount /dev/ggate0 /mnt\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:1079
msgid ""
"The device on the server may now be accessed through [.filename]#/mnt# on "
"the client.  For more details about `ggatec` and a few usage examples, refer "
"to man:ggatec[8]."
msgstr ""
"이제 클라이언트에서 [.filename]#/mnt#를 통해 서버의 장치에 액세스할 수 "
"있습니다.  `ggatec`에 대한 자세한 내용과 몇 가지 사용 예는 man:ggatec[8]를 "
"참조하세요."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/geom/_index.adoc:1084
msgid ""
"The mount will fail if the device is currently mounted on either the server "
"or any other client on the network.  If simultaneous access is needed to "
"network resources, use NFS instead."
msgstr ""
"장치가 현재 서버 또는 네트워크의 다른 클라이언트에 마운트되어 있으면 "
"마운트가 실패합니다.  네트워크 리소스에 동시에 액세스해야 하는 경우 대신 "
"NFS를 사용하세요."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:1087
msgid ""
"When the device is no longer needed, unmount it with `umount` so that the "
"resource is available to other clients."
msgstr "장치가 더 이상 필요하지 않으면 다른 클라이언트에서 리소스를 사용할 수 있도록 "
"`umount`로 장치를 마운트 해제합니다."

#. type: Title ==
#: documentation/content/en/books/handbook/geom/_index.adoc:1089
#, no-wrap
msgid "Labeling Disk Devices"
msgstr "디스크 장치에 라벨 지정"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:1095
msgid ""
"During system initialization, the FreeBSD kernel creates device nodes as "
"devices are found.  This method of probing for devices raises some issues.  "
"For instance, what if a new disk device is added via USB? It is likely that "
"a flash device may be handed the device name of [.filename]#da0# and the "
"original [.filename]#da0# shifted to [.filename]#da1#.  This will cause "
"issues mounting file systems if they are listed in [.filename]#/etc/fstab# "
"which may also prevent the system from booting."
msgstr ""
"시스템 초기화 중에 FreeBSD 커널은 디바이스가 발견되면 디바이스 노드를 "
"생성합니다.  이 장치 검색 방법에는 몇 가지 문제가 있습니다.  예를 들어, "
"USB를 통해 새 디스크 장치가 추가되면 어떻게 될까요? 플래시 장치에 [."
"filename]#da0#의 장치 이름이 전달되고 원래 [.filename]#da0#이 [."
"filename]#da1#으로 바뀔 수 있습니다.  이로 인해 파일 시스템이 [.filename]#/"
"etc/fstab#에 나열되어 있는 파일 시스템을 마운트하는 데 문제가 발생하여 "
"시스템이 부팅되지 않을 수도 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:1100
msgid ""
"One solution is to chain SCSI devices in order so a new device added to the "
"SCSI card will be issued unused device numbers.  But what about USB devices "
"which may replace the primary SCSI disk? This happens because USB devices "
"are usually probed before the SCSI card.  One solution is to only insert "
"these devices after the system has been booted.  Another method is to use "
"only a single ATA drive and never list the SCSI devices in [.filename]#/etc/"
"fstab#."
msgstr ""
"한 가지 해결책은 SCSI 장치를 순서대로 연결하여 SCSI 카드에 추가된 새 장치에 "
"사용하지 않는 장치 번호가 발급되도록 하는 것입니다.  하지만 기본 SCSI "
"디스크를 대체할 수 있는 USB 장치는 어떻게 해야 할까요? USB 장치는 일반적으로 "
"SCSI 카드보다 먼저 프로빙되기 때문에 이런 문제가 발생합니다.  한 가지 "
"해결책은 시스템이 부팅된 후에만 이러한 장치를 삽입하는 것입니다.  또 다른 "
"방법은 단일 ATA 드라이브만 사용하고 [.filename]#/etc/fstab#에 SCSI 장치를 "
"나열하지 않는 것입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:1104
msgid ""
"A better solution is to use `glabel` to label the disk devices and use the "
"labels in [.filename]#/etc/fstab#.  Since `glabel` stores the label in the "
"last sector of a given provider, the label will remain persistent across "
"reboots.  By using this label as a device, the file-system may always be "
"mounted regardless of what device node it is accessed through."
msgstr ""
"더 나은 해결책은 `glabel`을 사용하여 디스크 장치에 레이블을 지정하고 [."
"filename]#/etc/fstab#에 레이블을 사용하는 것입니다.  `glabel`은 주어진 "
"공급자의 마지막 섹터에 레이블을 저장하므로 재부팅 시에도 레이블이 영구적으로 "
"유지됩니다.  이 레이블을 장치로 사용하면 어떤 장치 노드를 통해 "
"액세스하는지에 관계없이 파일 시스템을 항상 마운트할 수 있습니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/geom/_index.adoc:1109
msgid ""
"`glabel` can create both transient and permanent labels. Only permanent "
"labels are consistent across reboots.  Refer to man:glabel[8] for more "
"information on the differences between labels."
msgstr ""
"`glabel`은 일시적 레이블과 영구 레이블을 모두 생성할 수 있습니다. 재부팅할 "
"때마다 영구 레이블만 일관되게 유지됩니다.  레이블 간의 차이점에 대한 자세한 "
"내용은 man:glabel[8]을 참조하세요."

#. type: Title ===
#: documentation/content/en/books/handbook/geom/_index.adoc:1111
#, no-wrap
msgid "Label Types and Examples"
msgstr "레이블 유형 및 예제"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:1119
msgid ""
"Permanent labels can be a generic or a file system label.  Permanent file "
"system labels can be created with man:tunefs[8] or man:newfs[8].  These "
"types of labels are created in a sub-directory of [.filename]#/dev#, and "
"will be named according to the file system type.  For example, UFS2 file "
"system labels will be created in [.filename]#/dev/ufs#.  Generic permanent "
"labels can be created with `glabel label`.  These are not file system "
"specific and will be created in [.filename]#/dev/label#."
msgstr ""
"영구 레이블은 일반 또는 파일 시스템 레이블이 될 수 있습니다.  영구 파일 "
"시스템 레이블은 man:tunefs[8] 또는 man:newfs[8]로 만들 수 있습니다.  이러한 "
"유형의 레이블은 [.filename]#/dev#의 하위 디렉터리에 생성되며 파일 시스템 "
"유형에 따라 이름이 지정됩니다.  예를 들어, UFS2 파일 시스템 레이블은 [."
"filename]#/dev/ufs#에 생성됩니다.  일반 영구 레이블은 `glabel label`로 "
"생성할 수 있습니다.  이러한 레이블은 파일 시스템별로 다르지 않으며 [."
"filename]#/dev/label#에 생성됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:1123
msgid ""
"Temporary labels are destroyed at the next reboot.  These labels are created "
"in [.filename]#/dev/label# and are suited to experimentation.  A temporary "
"label can be created using `glabel create`."
msgstr ""
"임시 레이블은 다음 재부팅 시 삭제됩니다.  이러한 레이블은 [.filename]#/dev/"
"label#에 생성되며 테스트를 할 때 적합합니다.  임시 레이블은 `glabel create`"
"를 사용하여 만들 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:1125
msgid ""
"To create a permanent label for a UFS2 file system without destroying any "
"data, issue the following command:"
msgstr "데이터를 파괴하지 않고 UFS2 파일 시스템에 대한 영구 레이블을 만들려면 다음 "
"명령을 실행합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:1129
#, no-wrap
msgid "# tunefs -L home /dev/da3\n"
msgstr "# tunefs -L home /dev/da3\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:1132
msgid ""
"A label should now exist in [.filename]#/dev/ufs# which may be added to [."
"filename]#/etc/fstab#:"
msgstr ""
"이제 레이블이 [.filename]#/dev/ufs#에 존재해야 하며, [.filename]#/etc/fstab#"
"에 추가할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:1136
#, no-wrap
msgid "/dev/ufs/home\t\t/home            ufs     rw              2      2\n"
msgstr "/dev/ufs/home\t\t/home            ufs     rw              2      2\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/geom/_index.adoc:1141
msgid "The file system must not be mounted while attempting to run `tunefs`."
msgstr "`tunefs`를 실행하는 동안 파일 시스템을 마운트해서는 안됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:1144
msgid "Now the file system may be mounted:"
msgstr "이제 파일 시스템을 마운트할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:1148
#, no-wrap
msgid "# mount /home\n"
msgstr "# mount /home\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:1151
msgid ""
"From this point on, so long as the [.filename]#geom_label.ko# kernel module "
"is loaded at boot with [.filename]#/boot/loader.conf# or the `GEOM_LABEL` "
"kernel option is present, the device node may change without any ill effect "
"on the system."
msgstr ""
"이 시점부터는 부팅 시 [.filename]#/boot/loader.conf#로 [.filename]#geom_label"
".ko# 커널 모듈이 로드되거나 `GEOM_LABEL` 커널 옵션이 있는 한 시스템에 "
"악영향을 미치지 않고 장치 노드를 변경할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:1154
msgid ""
"File systems may also be created with a default label by using the `-L` flag "
"with `newfs`.  Refer to man:newfs[8] for more information."
msgstr ""
"파일 시스템은 `newfs`와 함께 `-L` 플래그를 사용하여 기본 레이블로 만들 수도 "
"있습니다.  자세한 내용은 man:newfs[8]을 참조하십시오."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:1156
msgid "The following command can be used to destroy the label:"
msgstr "다음 명령을 사용하여 레이블을 삭제할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:1160
#, no-wrap
msgid "# glabel destroy home\n"
msgstr "# glabel destroy home\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:1163
msgid "The following example shows how to label the partitions of a boot disk."
msgstr "다음 예는 부팅 디스크의 파티션에 레이블을 지정하는 방법을 보여줍니다."

#. type: Block title
#: documentation/content/en/books/handbook/geom/_index.adoc:1164
#, no-wrap
msgid "Labeling Partitions on the Boot Disk"
msgstr "부팅 디스크의 파티션에 레이블 지정하기"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/geom/_index.adoc:1170
msgid ""
"By permanently labeling the partitions on the boot disk, the system should "
"be able to continue to boot normally, even if the disk is moved to another "
"controller or transferred to a different system.  For this example, it is "
"assumed that a single ATA disk is used, which is currently recognized by the "
"system as [.filename]#ad0#.  It is also assumed that the standard FreeBSD "
"partition scheme is used, with [.filename]#/#, [.filename]#/var#, [."
"filename]#/usr# and [.filename]#/tmp#, as well as a swap partition."
msgstr ""
"부팅 디스크의 파티션에 영구적으로 레이블을 지정하면 디스크가 다른 컨트롤러로 "
"이동하거나 다른 시스템으로 전송되더라도 시스템이 정상적으로 부팅할 수 "
"있습니다.  이 예에서는 현재 시스템에서 [.filename]#ad0#으로 인식되는 단일 "
"ATA 디스크가 사용된다고 가정합니다.  또한 [.filename]#/#, [.filename]#/var#, "
"[.filename]#/usr# 및 [.filename]#/tmp#와 스왑 파티션이 있는 표준 FreeBSD "
"파티션 체계가 사용된다고 가정합니다."

#. type: delimited block = 4
#: documentation/content/en/books/handbook/geom/_index.adoc:1173
msgid ""
"Reboot the system, and at the man:loader[8] prompt, press kbd:[4] to boot "
"into single user mode.  Then enter the following commands:"
msgstr ""
"시스템을 재부팅하고 man:loader[8] 프롬프트에서 kbd:[4]를 눌러 단일 사용자 "
"모드로 부팅합니다.  그런 다음, 다음 명령을 입력합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:1187
#, no-wrap
msgid ""
"# glabel label rootfs /dev/ad0s1a\n"
"GEOM_LABEL: Label for provider /dev/ad0s1a is label/rootfs\n"
"# glabel label var /dev/ad0s1d\n"
"GEOM_LABEL: Label for provider /dev/ad0s1d is label/var\n"
"# glabel label usr /dev/ad0s1f\n"
"GEOM_LABEL: Label for provider /dev/ad0s1f is label/usr\n"
"# glabel label tmp /dev/ad0s1e\n"
"GEOM_LABEL: Label for provider /dev/ad0s1e is label/tmp\n"
"# glabel label swap /dev/ad0s1b\n"
"GEOM_LABEL: Label for provider /dev/ad0s1b is label/swap\n"
"# exit\n"
msgstr ""
"# glabel label rootfs /dev/ad0s1a\n"
"GEOM_LABEL: Label for provider /dev/ad0s1a is label/rootfs\n"
"# glabel label var /dev/ad0s1d\n"
"GEOM_LABEL: Label for provider /dev/ad0s1d is label/var\n"
"# glabel label usr /dev/ad0s1f\n"
"GEOM_LABEL: Label for provider /dev/ad0s1f is label/usr\n"
"# glabel label tmp /dev/ad0s1e\n"
"GEOM_LABEL: Label for provider /dev/ad0s1e is label/tmp\n"
"# glabel label swap /dev/ad0s1b\n"
"GEOM_LABEL: Label for provider /dev/ad0s1b is label/swap\n"
"# exit\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:1192
msgid ""
"The system will continue with multi-user boot.  After the boot completes, "
"edit [.filename]#/etc/fstab# and replace the conventional device names, with "
"their respective labels.  The final [.filename]#/etc/fstab# will look like "
"this:"
msgstr ""
"시스템이 다중 사용자 부팅을 계속 진행합니다.  부팅이 완료되면 [.filename]#/"
"etc/fstab#을 편집하고 기존 장치 이름을 해당 레이블로 바꿉니다.  최종 [."
"filename]#/etc/fstab#은 다음과 같이 표시됩니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:1201
#, no-wrap
msgid ""
"# Device                Mountpoint      FStype  Options         Dump    Pass#\n"
"/dev/label/swap         none            swap    sw              0       0\n"
"/dev/label/rootfs       /               ufs     rw              1       1\n"
"/dev/label/tmp          /tmp            ufs     rw              2       2\n"
"/dev/label/usr          /usr            ufs     rw              2       2\n"
"/dev/label/var          /var            ufs     rw              2       2\n"
msgstr ""
"# Device                Mountpoint      FStype  Options         Dump    Pass#"
"\n"
"/dev/label/swap         none            swap    sw              0       0\n"
"/dev/label/rootfs       /               ufs     rw              1       1\n"
"/dev/label/tmp          /tmp            ufs     rw              2       2\n"
"/dev/label/usr          /usr            ufs     rw              2       2\n"
"/dev/label/var          /var            ufs     rw              2       2\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:1205
msgid ""
"The system can now be rebooted.  If everything went well, it will come up "
"normally and `mount` will show:"
msgstr "이제 시스템을 재부팅할 수 있습니다.  모든 것이 잘 되었다면 정상적으로 "
"나타나고 `mount` 명령은 다음과 같이 표시됩니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:1214
#, no-wrap
msgid ""
"# mount\n"
"/dev/label/rootfs on / (ufs, local)\n"
"devfs on /dev (devfs, local)\n"
"/dev/label/tmp on /tmp (ufs, local, soft-updates)\n"
"/dev/label/usr on /usr (ufs, local, soft-updates)\n"
"/dev/label/var on /var (ufs, local, soft-updates)\n"
msgstr ""
"# mount\n"
"/dev/label/rootfs on / (ufs, local)\n"
"devfs on /dev (devfs, local)\n"
"/dev/label/tmp on /tmp (ufs, local, soft-updates)\n"
"/dev/label/usr on /usr (ufs, local, soft-updates)\n"
"/dev/label/var on /var (ufs, local, soft-updates)\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/geom/_index.adoc:1222
msgid ""
"The man:glabel[8] class supports a label type for UFS file systems, based on "
"the unique file system id, `ufsid`.  These labels may be found in [."
"filename]#/dev/ufsid# and are created automatically during system startup.  "
"It is possible to use `ufsid` labels to mount partitions using [.filename]#/"
"etc/fstab#.  Use `glabel status` to receive a list of file systems and their "
"corresponding `ufsid` labels:"
msgstr ""
"man:glabel[8] 클래스는 고유한 파일 시스템 ID인 `ufsid`를 기반으로 하는 UFS "
"파일 시스템용 레이블 유형을 지원합니다.  이러한 레이블은 [.filename]#/dev/"
"ufsid#에서 찾을 수 있으며 시스템 시작 중에 자동으로 생성됩니다.  `ufsid` "
"레이블은 [.filename]#/etc/fstab#을 이용하여 파티션을 마운트할 수 있습니다.  `"
"glabel status`를 사용하여 파일 시스템과 해당 `ufsid` 레이블 목록을 받습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:1229
#, no-wrap
msgid ""
"% glabel status\n"
"                  Name  Status  Components\n"
"ufsid/486b6fc38d330916     N/A  ad4s1d\n"
"ufsid/486b6fc16926168e     N/A  ad4s1f\n"
msgstr ""
"% glabel status\n"
"                  Name  Status  Components\n"
"ufsid/486b6fc38d330916     N/A  ad4s1d\n"
"ufsid/486b6fc16926168e     N/A  ad4s1f\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:1233
msgid ""
"In the above example, [.filename]#ad4s1d# represents [.filename]#/var#, "
"while [.filename]#ad4s1f# represents [.filename]#/usr#.  Using the `ufsid` "
"values shown, these partitions may now be mounted with the following entries "
"in [.filename]#/etc/fstab#:"
msgstr ""
"위의 예에서 [.filename]#ad4s1d#는 [.filename]#/var#를 나타내고, [."
"filename]#ad4s1f#는 [.filename]#/usr#를 나타냅니다.  표시된 `ufsid` 값을 "
"사용하면 이제 이러한 파티션을 [.filename]#/etc/fstab#에 다음 항목으로 "
"마운트할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:1238
#, no-wrap
msgid ""
"/dev/ufsid/486b6fc38d330916        /var        ufs        rw        2      2\n"
"/dev/ufsid/486b6fc16926168e        /usr        ufs        rw        2      2\n"
msgstr ""
"/dev/ufsid/486b6fc38d330916        /var        ufs        rw        2      "
"2\n"
"/dev/ufsid/486b6fc16926168e        /usr        ufs        rw        2      "
"2\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:1241
msgid ""
"Any partitions with `ufsid` labels can be mounted in this way, eliminating "
"the need to manually create permanent labels, while still enjoying the "
"benefits of device name independent mounting."
msgstr ""
"'ufsid' 레이블이 있는 모든 파티션은 이러한 방식으로 마운트할 수 있으므로 "
"수동으로 영구 레이블을 생성할 필요가 없으며, 장치 이름 독립 마운트의 이점을 "
"그대로 누릴 수 있습니다."

#. type: Title ==
#: documentation/content/en/books/handbook/geom/_index.adoc:1243
#, no-wrap
msgid "UFS Journaling Through GEOM"
msgstr "GEOM을 통한 UFS 저널링"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:1249
msgid ""
"Support for journals on UFS file systems is available on FreeBSD.  The "
"implementation is provided through the GEOM subsystem and is configured "
"using `gjournal`.  Unlike other file system journaling implementations, the "
"`gjournal` method is block based and not implemented as part of the file "
"system.  It is a GEOM extension."
msgstr ""
"UFS 파일 시스템에서 저널에 대한 지원은 FreeBSD에서 사용할 수 있습니다.  이 "
"구현은 GEOM 서브시스템을 통해 제공되며 `gjournal`을 사용하여 구성됩니다.  "
"다른 파일 시스템 저널링 구현과 달리, `gjournal` 방법은 블록 기반이며 파일 "
"시스템의 일부로 구현되지 않습니다.  이것은 GEOM 확장입니다."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:1252
msgid ""
"Journaling stores a log of file system transactions, such as changes that "
"make up a complete disk write operation, before meta-data and file writes "
"are committed to the disk.  This transaction log can later be replayed to "
"redo file system transactions, preventing file system inconsistencies."
msgstr ""
"저널링은 메타데이터 및 파일 쓰기가 디스크에 커밋되기 전에, 전체 디스크 쓰기 "
"작업을 구성하는 변경 사항과 같은 파일 시스템 트랜잭션 로그를 저장합니다.  이 "
"트랜잭션 로그를 나중에 재생하여 파일 시스템 트랜잭션을 다시 실행할 수 "
"있으므로 파일 시스템 불일치를 방지할 수 있습니다."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:1257
msgid ""
"This method provides another mechanism to protect against data loss and "
"inconsistencies of the file system.  Unlike Soft Updates, which tracks and "
"enforces meta-data updates, and snapshots, which create an image of the file "
"system, a log is stored in disk space specifically for this task.  For "
"better performance, the journal may be stored on another disk.  In this "
"configuration, the journal provider or storage device should be listed after "
"the device to enable journaling on."
msgstr ""
"이 방법은 데이터 손실 및 파일 시스템의 불일치로부터 보호하는 또 다른 "
"메커니즘을 제공합니다.  메타데이터 업데이트를 추적하고 적용하는 소프트 "
"업데이트나 파일 시스템의 이미지를 생성하는 스냅샷과는 달리, 이 작업을 위해 "
"특별히 디스크 공간에 로그가 저장됩니다.  성능 향상을 위해 저널을 다른 "
"디스크에 저장할 수 있습니다.  이 구성에서는 저널 제공자 또는 저장 장치를 "
"장치 뒤에 나열하여 저널링을 사용하도록 설정해야 합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:1260
msgid ""
"The [.filename]#GENERIC# kernel provides support for `gjournal`.  To "
"automatically load the [.filename]#geom_journal.ko# kernel module at boot "
"time, add the following line to [.filename]#/boot/loader.conf#:"
msgstr ""
"[.filename]#GENERIC# 커널은 `gjournal`을 지원합니다.  부팅 시 [."
"filename]#geom_journal.ko# 커널 모듈을 자동으로 로드하려면 [.filename]#/boot/"
"loader.conf#에 다음 줄을 추가합니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:1264
#, no-wrap
msgid "geom_journal_load=\"YES\"\n"
msgstr "geom_journal_load=\"YES\"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:1267
msgid ""
"If a custom kernel is used, ensure the following line is in the kernel "
"configuration file:"
msgstr "사용자 정의 커널을 사용하는 경우 커널 구성 파일에 다음 내용이 있는지 "
"확인하세요:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:1271
#, no-wrap
msgid "options\tGEOM_JOURNAL\n"
msgstr "options\tGEOM_JOURNAL\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:1275
msgid ""
"Once the module is loaded, a journal can be created on a new file system "
"using the following steps.  In this example, [.filename]#da4# is a new SCSI "
"disk:"
msgstr ""
"모듈이 로드되면 다음 단계에 따라 새 파일 시스템에 저널을 만들 수 있습니다.  "
"이 예에서 [.filename]#da4#는 새 SCSI 디스크입니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:1280
#, no-wrap
msgid ""
"# gjournal load\n"
"# gjournal label /dev/da4\n"
msgstr ""
"# gjournal load\n"
"# gjournal label /dev/da4\n"

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:1283
msgid ""
"This will load the module and create a [.filename]#/dev/da4.journal# device "
"node on [.filename]#/dev/da4#."
msgstr ""
"이렇게 하면 모듈이 로드되고 [.filename]#/dev/da4#에 [.filename]#/dev/da4."
"journal# 장치 노드가 생성됩니다."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:1285
msgid ""
"A UFS file system may now be created on the journaled device, then mounted "
"on an existing mount point:"
msgstr "이제 저널링된 장치에 UFS 파일 시스템을 생성한 다음 기존 마운트 지점에 "
"마운트할 수 있습니다:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/geom/_index.adoc:1290
#, no-wrap
msgid ""
"# newfs -O 2 -J /dev/da4.journal\n"
"# mount /dev/da4.journal /mnt\n"
msgstr ""
"# newfs -O 2 -J /dev/da4.journal\n"
"# mount /dev/da4.journal /mnt\n"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/geom/_index.adoc:1296
msgid ""
"In the case of several slices, a journal will be created for each individual "
"slice.  For instance, if [.filename]#ad4s1# and [.filename]#ad4s2# are both "
"slices, then `gjournal` will create [.filename]#ad4s1.journal# and [."
"filename]#ad4s2.journal#."
msgstr ""
"여러 개의 슬라이스가 있는 경우 각 개별 슬라이스에 대해 저널이 생성됩니다.  "
"예를 들어, [.filename]#ad4s1#과 [.filename]#ad4s2#가 모두 슬라이스인 경우, "
"`gjournal`은 [.filename]#ad4s1.journal#과 [.filename]#ad4s2.journal#을 "
"생성합니다."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:1302
msgid ""
"Journaling may also be enabled on current file systems by using `tunefs`.  "
"However, _always_ make a backup before attempting to alter an existing file "
"system.  In most cases, `gjournal` will fail if it is unable to create the "
"journal, but this does not protect against data loss incurred as a result of "
"misusing `tunefs`.  Refer to man:gjournal[8] and man:tunefs[8] for more "
"information about these commands."
msgstr ""
"`tunefs`를 사용해 현재 파일 시스템에서도 저널링을 활성화할 수 있습니다.  "
"그러나 기존 파일 시스템을 변경하기 전에 항상 백업을 만드세요.  대부분의 경우 "
"`gjournal`은 저널을 만들 수 없으면 실패하지만, `tunefs`를 잘못 사용하여 "
"발생하는 데이터 손실을 방지하지는 못합니다.  이 명령에 대한 자세한 내용은 "
"man:gjournal[8] 및 man:tunefs[8]를 참조하십시오."

#. type: Plain text
#: documentation/content/en/books/handbook/geom/_index.adoc:1304
msgid ""
"It is possible to journal the boot disk of a FreeBSD system.  Refer to the "
"article extref:{gjournal-desktop}[Implementing UFS Journaling on a Desktop "
"PC] for detailed instructions."
msgstr ""
"FreeBSD 시스템의 부팅 디스크를 저널링할 수 있습니다.  자세한 지침은 extref"
":{gjournal-desktop}[데스크톱 PC에서 UFS 저널링 구현하기] 문서를 참조하세요."
