# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR The FreeBSD Project
# This file is distributed under the same license as the FreeBSD Documentation package.
# Vladlen Popolitov <vladlenpopolitov@list.ru>, 2025.
msgid ""
msgstr ""
"Project-Id-Version: FreeBSD Documentation VERSION\n"
"POT-Creation-Date: 2025-10-12 22:16+0300\n"
"PO-Revision-Date: 2025-09-05 04:45+0000\n"
"Last-Translator: Vladlen Popolitov <vladlenpopolitov@list.ru>\n"
"Language-Team: Russian <https://translate-dev.freebsd.org/projects/"
"documentation/booksdevelopers-handbooksecure_index/ru/>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2;\n"
"X-Generator: Weblate 4.17\n"

#. type: Yaml Front Matter Hash Value: description
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:1
#, no-wrap
msgid "Secure Programming in FreeBSD"
msgstr "Безопасное программирование в FreeBSD"

#. type: Yaml Front Matter Hash Value: title
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:1
#, no-wrap
msgid "Chapter 3. Secure Programming"
msgstr "Глава 3. Безопасное программирование"

#. type: Title =
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:16
#, no-wrap
msgid "Secure Programming"
msgstr "Безопасное программирование"

#. type: Title ==
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:54
#, no-wrap
msgid "Synopsis"
msgstr "Обзор"

#. type: Plain text
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:57
msgid ""
"This chapter describes some of the security issues that have plagued UNIX(R) "
"programmers for decades and some of the new tools available to help "
"programmers avoid writing exploitable code."
msgstr ""
"В этой главе описываются некоторые проблемы безопасности, которые преследуют "
"программистов UNIX(R) на протяжении десятилетий, а также новые инструменты, "
"помогающие избежать написания уязвимого кода."

#. type: Title ==
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:59
#, no-wrap
msgid "Secure Design Methodology"
msgstr "Методология безопасного проектирования"

#. type: Plain text
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:64
msgid ""
"Writing secure applications takes a very scrutinous and pessimistic outlook "
"on life.  Applications should be run with the principle of \"least "
"privilege\" so that no process is ever running with more than the bare "
"minimum access that it needs to accomplish its function.  Previously tested "
"code should be reused whenever possible to avoid common mistakes that others "
"may have already fixed."
msgstr ""
"Написание безопасных приложений требует очень внимательного и "
"пессимистичного взгляда на жизнь. Приложения должны работать по принципу "
"\"наименьших привилегий\", чтобы ни один процесс не выполнялся с доступом, "
"превышающим необходимый минимум для выполнения его функций. По возможности "
"следует повторно использовать уже проверенный код, чтобы избежать "
"распространённых ошибок, которые, возможно, уже исправили другие."

#. type: Plain text
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:68
msgid ""
"One of the pitfalls of the UNIX(R) environment is how easy it is to make "
"assumptions about the sanity of the environment.  Applications should never "
"trust user input (in all its forms), system resources, inter-process "
"communication, or the timing of events.  UNIX(R) processes do not execute "
"synchronously so logical operations are rarely atomic."
msgstr ""
"Одной из ловушек среды UNIX(R) является то, насколько легко делать "
"предположения о разумности окружения. Приложения никогда не должны доверять "
"пользовательскому вводу (во всех его формах), системным ресурсам, "
"межпроцессному взаимодействию или времени событий. Процессы UNIX(R) "
"выполняются не синхронно, поэтому логические операции редко бывают "
"атомарными."

#. type: Title ==
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:70
#, no-wrap
msgid "Buffer Overflows"
msgstr "Переполнение буфера"

#. type: Plain text
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:76
msgid ""
"Buffer Overflows have been around since the very beginnings of the von "
"Neumann crossref:bibliography[cod,1] architecture.  They first gained "
"widespread notoriety in 1988 with the Morris Internet worm.  Unfortunately, "
"the same basic attack remains effective today.  By far the most common type "
"of buffer overflow attack is based on corrupting the stack."
msgstr ""
"Переполнение буфера существовало с самых истоков архитектуры фон Неймана "
"crossref:bibliography[cod,1]. Впервые оно получило широкую известность в "
"1988 году благодаря червю Морриса. К сожалению, эта базовая атака остаётся "
"эффективной и по сей день. Наиболее распространённый тип атаки с "
"переполнением буфера основан на повреждении стека."

#. type: Plain text
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:85
msgid ""
"Most modern computer systems use a stack to pass arguments to procedures and "
"to store local variables.  A stack is a last in first out (LIFO) buffer in "
"the high memory area of a process image.  When a program invokes a function "
"a new \"stack frame\" is created.  This stack frame consists of the "
"arguments passed to the function as well as a dynamic amount of local "
"variable space.  The \"stack pointer\" is a register that holds the current "
"location of the top of the stack.  Since this value is constantly changing "
"as new values are pushed onto the top of the stack, many implementations "
"also provide a \"frame pointer\" that is located near the beginning of a "
"stack frame so that local variables can more easily be addressed relative to "
"this value.  crossref:bibliography[cod,1] The return address for function "
"calls is also stored on the stack, and this is the cause of stack-overflow "
"exploits since overflowing a local variable in a function can overwrite the "
"return address of that function, potentially allowing a malicious user to "
"execute any code he or she wants."
msgstr ""
"Большинство современных компьютерных систем используют стек для передачи "
"аргументов процедурам и хранения локальных переменных. Стек — это буфер типа "
"\"последним пришёл — первым ушёл\" (LIFO) в верхней области памяти процесса. "
"Когда программа вызывает функцию, создаётся новый \"стековый кадр\". Этот "
"стековый кадр состоит из аргументов, переданных функции, а также "
"динамического количества места для локальных переменных. \"Указатель стека\" "
"— это регистр, который содержит текущее местоположение вершины стека. "
"Поскольку это значение постоянно меняется по мере добавления новых значений "
"на вершину стека, многие реализации также предоставляют \"указатель кадра\", "
"который располагается вблизи начала стекового кадра, чтобы локальные "
"переменные могли легче адресоваться относительно этого значения. "
"crossref:bibliography[cod,1] Адрес возврата для вызовов функций также "
"хранится в стеке, и это является причиной эксплойтов переполнения стека, "
"поскольку переполнение локальной переменной в функции может перезаписать "
"адрес возврата этой функции, потенциально позволяя злоумышленнику выполнить "
"любой код по своему усмотрению."

#. type: Plain text
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:88
msgid ""
"Although stack-based attacks are by far the most common, it would also be "
"possible to overrun the stack with a heap-based (malloc/free) attack."
msgstr ""
"Хотя атаки на стек являются наиболее распространенными, также возможно "
"переполнение стека с помощью атаки на кучу (malloc/free)."

#. type: Plain text
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:91
msgid ""
"The C programming language does not perform automatic bounds checking on "
"arrays or pointers as many other languages do.  In addition, the standard C "
"library is filled with a handful of very dangerous functions."
msgstr ""
"Язык программирования C не выполняет автоматическую проверку границ массивов "
"или указателей, как это делают многие другие языки. Кроме того, стандартная "
"библиотека C содержит множество очень опасных функций."

#. type: Table
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:97
#, no-wrap
msgid "`strcpy`(char *dest, const char *src)"
msgstr "`strcpy`(char *dest, const char *src)"

#. type: Table
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:101
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:106
#, no-wrap
msgid "May overflow the dest buffer"
msgstr "Может переполнить буфер назначения"

#. type: Table
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:102
#, no-wrap
msgid "`strcat`(char *dest, const char *src)"
msgstr "`strcat`(char *dest, const char *src)"

#. type: Table
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:107
#, no-wrap
msgid "`getwd`(char *buf)"
msgstr "`getwd`(char *buf)"

#. type: Table
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:111
#, no-wrap
msgid "May overflow the buf buffer"
msgstr "Может переполнить буфер buf"

#. type: Table
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:112
#, no-wrap
msgid "`gets`(char *s)"
msgstr "`gets`(char *s)"

#. type: Table
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:116
#, no-wrap
msgid "May overflow the s buffer"
msgstr "Может переполнить буфер s"

#. type: Table
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:117
#, no-wrap
msgid "`[vf]scanf`(const char *format, ...)"
msgstr "`[vf]scanf`(const char *format, ...)"

#. type: Table
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:121
#, no-wrap
msgid "May overflow its arguments."
msgstr "Может переполнить свои аргументы."

#. type: Table
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:122
#, no-wrap
msgid "`realpath`(char *path, char resolved_path[])"
msgstr "`realpath`(char *path, char resolved_path[])"

#. type: Table
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:126
#, no-wrap
msgid "May overflow the path buffer"
msgstr "Может переполнить буфер пути"

#. type: Table
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:127
#, no-wrap
msgid "`[v]sprintf`(char *str, const char *format, ...)"
msgstr "`[v]sprintf`(char *str, const char *format, ...)"

#. type: Table
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:130
#, no-wrap
msgid "May overflow the str buffer."
msgstr "Может переполнить буфер str."

#. type: Title ===
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:132
#, no-wrap
msgid "Example Buffer Overflow"
msgstr "Пример переполнения буфера"

#. type: Plain text
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:135
msgid ""
"The following example code contains a buffer overflow designed to overwrite "
"the return address and skip the instruction immediately following the "
"function call. (Inspired by crossref:bibliography[Phrack,4])"
msgstr ""
"Следующий пример кода содержит переполнение буфера, предназначенное для "
"перезаписи адреса возврата и пропуска инструкции, следующей сразу после "
"вызова функции. (Вдохновлено crossref:bibliography[Phrack,4])"

#. type: delimited block . 4
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:139
#, no-wrap
msgid "#include <stdio.h>\n"
msgstr "#include <stdio.h>\n"

#. type: delimited block . 4
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:144
#, no-wrap
msgid ""
"void manipulate(char *buffer) {\n"
"  char newbuffer[80];\n"
"  strcpy(newbuffer,buffer);\n"
"}\n"
msgstr ""
"void manipulate(char *buffer) {\n"
"  char newbuffer[80];\n"
"  strcpy(newbuffer,buffer);\n"
"}\n"

#. type: delimited block . 4
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:148
#, no-wrap
msgid ""
"int main() {\n"
"  char ch,buffer[4096];\n"
"  int i=0;\n"
msgstr ""
"int main() {\n"
"  char ch,buffer[4096];\n"
"  int i=0;\n"

#. type: delimited block . 4
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:150
#, no-wrap
msgid "  while ((buffer[i++] = getchar()) != '\\n') {};\n"
msgstr "  while ((buffer[i++] = getchar()) != '\\n') {};\n"

#. type: delimited block . 4
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:157
#, no-wrap
msgid ""
"  i=1;\n"
"  manipulate(buffer);\n"
"  i=2;\n"
"  printf(\"The value of i is : %d\\n\",i);\n"
"  return 0;\n"
"}\n"
msgstr ""
"  i=1;\n"
"  manipulate(buffer);\n"
"  i=2;\n"
"  printf(\"The value of i is : %d\\n\",i);\n"
"  return 0;\n"
"}\n"

#. type: Plain text
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:160
msgid ""
"Let us examine what the memory image of this process would look like if we "
"were to input 160 spaces into our little program before hitting return."
msgstr ""
"Давайте рассмотрим, как будет выглядеть образ памяти этого процесса, если мы "
"введем 160 пробелов в нашу небольшую программу перед нажатием Enter."

#. type: XXX figure here!
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:164
msgid ""
"Obviously more malicious input can be devised to execute actual compiled "
"instructions (such as exec(/bin/sh))."
msgstr ""
"Очевидно, что можно разработать более вредоносные входные данные для "
"выполнения реальных скомпилированных инструкций (например, exec(/bin/sh))."

#. type: Title ===
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:165
#, no-wrap
msgid "Avoiding Buffer Overflows"
msgstr "Избегание переполнения буфера"

#. type: XXX figure here!
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:175
msgid ""
"The most straightforward solution to the problem of stack-overflows is to "
"always use length restricted memory and string copy functions.  `strncpy` "
"and `strncat` are part of the standard C library.  These functions accept a "
"length value as a parameter which should be no larger than the size of the "
"destination buffer.  These functions will then copy up to 'length' bytes "
"from the source to the destination.  However there are a number of problems "
"with these functions.  Neither function guarantees NUL termination if the "
"size of the input buffer is as large as the destination.  The length "
"parameter is also used inconsistently between strncpy and strncat so it is "
"easy for programmers to get confused as to their proper usage.  There is "
"also a significant performance loss compared to `strcpy` when copying a "
"short string into a large buffer since `strncpy` NUL fills up the size "
"specified."
msgstr ""
"Наиболее простое решение проблемы переполнения стека — всегда использовать "
"функции копирования памяти и строк с ограничением длины. `strncpy` и "
"`strncat` являются частью стандартной библиотеки C. Эти функции принимают "
"параметр длины, который не должен превышать размер целевого буфера. Затем "
"эти функции копируют до 'length' байтов из источника в назначение. Однако у "
"этих функций есть ряд проблем. Ни одна из них не гарантирует завершающий "
"NUL, если размер входного буфера равен размеру целевого. Параметр длины "
"также используется неодинаково между `strncpy` и `strncat`, что может "
"сбивать программистов с толку относительно их правильного использования. "
"Также наблюдается значительное снижение производительности по сравнению с "
"`strcpy` при копировании короткой строки в большой буфер, поскольку "
"`strncpy` заполняет оставшееся пространство до указанного размера символами "
"NUL."

#. type: XXX figure here!
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:178
msgid ""
"Another memory copy implementation exists to get around these problems.  The "
"`strlcpy` and `strlcat` functions guarantee that they will always null "
"terminate the destination string when given a non-zero length argument."
msgstr ""
"Существует другая реализация копирования памяти для решения этих проблем. "
"Функции `strlcpy` и `strlcat` гарантируют, что они всегда завершат строку "
"назначения нулевым символом при передаче аргумента ненулевой длины."

#. type: Title ====
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:179
#, no-wrap
msgid "Compiler based run-time bounds checking"
msgstr "Скомпилированная проверка границ во время выполнения"

#. type: XXX figure here!
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:183
msgid ""
"Unfortunately there is still a very large assortment of code in public use "
"which blindly copies memory around without using any of the bounded copy "
"routines we just discussed.  Fortunately, there is a way to help prevent "
"such attacks - run-time bounds checking, which is implemented by several C/C+"
"+ compilers."
msgstr ""
"К сожалению, до сих пор существует очень большое количество кода в открытом "
"доступе, который бездумно копирует память, не используя ни одну из "
"ограниченных функций копирования, которые мы только что обсудили. К счастью, "
"есть способ помочь предотвратить такие атаки — проверка границ во время "
"выполнения, которая реализована в нескольких компиляторах C/C++."

#. type: XXX figure here!
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:186
msgid ""
"ProPolice is one such compiler feature, and is integrated into man:gcc[1] "
"versions 4.1 and later.  It replaces and extends the earlier StackGuard "
"man:gcc[1] extension."
msgstr ""
"ProPolice — это одна из таких функций компилятора, интегрированная в "
"man:gcc[1] версий 4.1 и выше. Она заменяет и расширяет более раннее "
"расширение StackGuard для man:gcc[1]."

#. type: XXX figure here!
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:190
msgid ""
"ProPolice helps to protect against stack-based buffer overflows and other "
"attacks by laying pseudo-random numbers in key areas of the stack before "
"calling any function.  When a function returns, these \"canaries\" are "
"checked and if they are found to have been changed the executable is "
"immediately aborted.  Thus any attempt to modify the return address or other "
"variable stored on the stack in an attempt to get malicious code to run is "
"unlikely to succeed, as the attacker would have to also manage to leave the "
"pseudo-random canaries untouched."
msgstr ""
"ProPolice помогает защититься от переполнений буфера на стеке и других атак, "
"размещая псевдослучайные числа в ключевых областях стека перед вызовом любой "
"функции. Когда функция завершается, эти \"канарейки\" проверяются, и если "
"обнаруживается, что они были изменены, выполнение программы немедленно "
"прекращается. Таким образом, любая попытка изменить адрес возврата или "
"другие переменные, хранящиеся на стеке, с целью запуска вредоносного кода, "
"вряд ли увенчается успехом, так как злоумышленнику также необходимо оставить "
"псевдослучайные канарейки нетронутыми."

#. type: XXX figure here!
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:192
msgid ""
"Recompiling your application with ProPolice is an effective means of "
"stopping most buffer-overflow attacks, but it can still be compromised."
msgstr ""
"Перекомпиляция вашего приложения с использованием ProPolice является "
"эффективным способом предотвращения большинства атак, связанных с "
"переполнением буфера, но оно всё ещё может быть скомпрометировано."

#. type: Title ====
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:193
#, no-wrap
msgid "Library based run-time bounds checking"
msgstr "Библиотечная проверка границ во время выполнения"

#. type: XXX figure here!
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:197
msgid ""
"Compiler-based mechanisms are completely useless for binary-only software "
"for which you cannot recompile.  For these situations there are a number of "
"libraries which re-implement the unsafe functions of the C-library "
"(`strcpy`, `fscanf`, `getwd`, etc..) and ensure that these functions can "
"never write past the stack pointer."
msgstr ""
"Механизмы на основе компилятора совершенно бесполезны для проприетарного "
"программного обеспечения, которое невозможно перекомпилировать. Для таких "
"ситуаций существует ряд библиотек, которые переопределяют небезопасные "
"функции стандартной библиотеки C (`strcpy`, `fscanf`, `getwd` и т.д.) и "
"гарантируют, что эти функции никогда не смогут записать данные за указатель "
"стека."

#. type: XXX figure here!
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:199
msgid "libsafe"
msgstr "libsafe"

#. type: XXX figure here!
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:200
msgid "libverify"
msgstr "libverify"

#. type: XXX figure here!
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:201
msgid "libparanoia"
msgstr "libparanoia"

#. type: XXX figure here!
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:206
msgid ""
"Unfortunately these library-based defenses have a number of shortcomings.  "
"These libraries only protect against a very small set of security related "
"issues and they neglect to fix the actual problem.  These defenses may fail "
"if the application was compiled with -fomit-frame-pointer.  Also, the "
"LD_PRELOAD and LD_LIBRARY_PATH environment variables can be overwritten/"
"unset by the user."
msgstr ""
"К сожалению, эти защиты на основе библиотек имеют ряд недостатков. Они "
"защищают лишь от очень небольшого набора проблем, связанных с безопасностью, "
"и не устраняют основную причину. Эти защиты могут не сработать, если "
"приложение было скомпилировано с флагом -fomit-frame-pointer. Кроме того, "
"переменные окружения LD_PRELOAD и LD_LIBRARY_PATH могут быть перезаписаны "
"или сброшены пользователем."

#. type: Title ==
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:208
#, no-wrap
msgid "SetUID issues"
msgstr "Проблемы с SetUID"

#. type: XXX figure here!
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:212
msgid ""
"There are at least 6 different IDs associated with any given process, and "
"you must therefore be very careful with the access that your process has at "
"any given time.  In particular, all seteuid applications should give up "
"their privileges as soon as it is no longer required."
msgstr ""
"Существует как минимум 6 различных идентификаторов, связанных с каждым "
"процессом, поэтому необходимо очень внимательно следить за уровнем доступа "
"вашего процесса в любой момент времени. В частности, все приложения с "
"seteuid должны отказываться от своих привилегий, как только в них больше нет "
"необходимости."

#. type: XXX figure here!
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:215
msgid ""
"The real user ID can only be changed by a superuser process.  The login "
"program sets this when a user initially logs in and it is seldom changed."
msgstr ""
"Действительный идентификатор пользователя может быть изменён только "
"процессом с правами суперпользователя. Программа login устанавливает его при "
"первоначальном входе пользователя в систему, и он редко изменяется."

#. type: XXX figure here!
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:219
msgid ""
"The effective user ID is set by the `exec()` functions if a program has its "
"seteuid bit set.  An application can call `seteuid()` at any time to set the "
"effective user ID to either the real user ID or the saved set-user-ID.  When "
"the effective user ID is set by `exec()` functions, the previous value is "
"saved in the saved set-user-ID."
msgstr ""
"Эффективный идентификатор пользователя устанавливается функциями `exec()`, "
"если у программы установлен бит seteuid. Приложение может вызывать "
"`seteuid()` в любое время, чтобы установить эффективный идентификатор "
"пользователя либо в реальный идентификатор пользователя, либо в сохранённый "
"set-user-ID. Когда эффективный идентификатор пользователя устанавливается "
"функциями `exec()`, предыдущее значение сохраняется в сохранённом set-user-"
"ID."

#. type: Title ==
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:221
#, no-wrap
msgid "Limiting your program's environment"
msgstr "Ограничение окружения вашей программы"

#. type: XXX figure here!
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:229
msgid ""
"The traditional method of restricting a process is with the `chroot()` "
"system call.  This system call changes the root directory from which all "
"other paths are referenced for a process and any child processes.  For this "
"call to succeed the process must have execute (search) permission on the "
"directory being referenced.  The new environment does not actually take "
"effect until you `chdir()` into your new environment.  It should also be "
"noted that a process can easily break out of a chroot environment if it has "
"root privilege.  This could be accomplished by creating device nodes to read "
"kernel memory, attaching a debugger to a process outside of the "
"man:chroot[8] environment, or in many other creative ways."
msgstr ""
"Традиционный метод ограничения процесса — это системный вызов `chroot()`. "
"Этот системный вызов изменяет корневой каталог, от которого ссылаются все "
"остальные пути для процесса и любых дочерних процессов. Для успешного "
"выполнения этого вызова процесс должен иметь право на выполнение (поиск) в "
"указанном каталоге. Новая среда фактически не вступает в силу, пока вы не "
"выполните `chdir()` в новой среде. Также следует отметить, что процесс может "
"легко выйти из окружения chroot, если он имеет привилегии root. Это может "
"быть достигнуто путем создания узлов устройств для чтения памяти ядра, "
"подключения отладчика к процессу вне окружения man:chroot[8] или многими "
"другими творческими способами."

#. type: XXX figure here!
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:234
msgid ""
"The behavior of the `chroot()` system call can be controlled somewhat with "
"the kern.chroot_allow_open_directories `sysctl` variable.  When this value "
"is set to 0, `chroot()` will fail with EPERM if there are any directories "
"open.  If set to the default value of 1, then `chroot()` will fail with "
"EPERM if there are any directories open and the process is already subject "
"to a `chroot()` call.  For any other value, the check for open directories "
"will be bypassed completely."
msgstr ""
"Поведение системного вызова `chroot()` можно частично контролировать с "
"помощью переменной `sysctl` kern.chroot_allow_open_directories. Если этому "
"параметру присвоено значение 0, `chroot()` завершится с ошибкой EPERM, если "
"есть какие-либо открытые каталоги. Если установлено значение по умолчанию 1, "
"то `chroot()` завершится с ошибкой EPERM, если есть открытые каталоги и "
"процесс уже находится внутри вызова `chroot()`. Для любого другого значения "
"проверка на открытые каталоги будет полностью пропущена."

#. type: Title ===
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:235
#, no-wrap
msgid "FreeBSD's jail functionality"
msgstr "Функциональность клеток FreeBSD"

#. type: XXX figure here!
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:239
msgid ""
"The concept of a Jail extends upon the `chroot()` by limiting the powers of "
"the superuser to create a true `virtual server'.  Once a prison is set up "
"all network communication must take place through the specified IP address, "
"and the power of \"root privilege\" in this jail is severely constrained."
msgstr ""
"Концепция `клетки` расширяет возможности `chroot()`, ограничивая права "
"суперпользователя для создания настоящего `виртуального сервера`. После "
"настройки клетки все сетевые взаимодействия должны осуществляться через "
"указанный IP-адрес, а привилегии `root` внутри этой клетки сильно ограничены."

#. type: XXX figure here!
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:243
msgid ""
"While in a prison, any tests of superuser power within the kernel using the "
"`suser()` call will fail.  However, some calls to `suser()` have been "
"changed to a new interface `suser_xxx()`.  This function is responsible for "
"recognizing or denying access to superuser power for imprisoned processes."
msgstr ""
"Находясь в клетке, любые проверки прав суперпользователя в ядре с "
"использованием вызова `suser()` завершатся неудачей. Однако некоторые вызовы "
"`suser()` были заменены на новый интерфейс `suser_xxx()`. Эта функция "
"отвечает за распознавание или запрет доступа к правам суперпользователя для "
"процессов в клетке."

#. type: XXX figure here!
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:245
msgid "A superuser process within a jailed environment has the power to:"
msgstr "Суперпользователь в среде клетки имеет возможность:"

#. type: XXX figure here!
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:247
msgid ""
"Manipulate credential with `setuid`, `seteuid`, `setgid`, `setegid`, "
"`setgroups`, `setreuid`, `setregid`, `setlogin`"
msgstr ""
"Управлять учетными данными с помощью `setuid`, `seteuid`, `setgid`, "
"`setegid`, `setgroups`, `setreuid`, `setregid`, `setlogin`"

#. type: XXX figure here!
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:248
msgid "Set resource limits with `setrlimit`"
msgstr "Установливать ограничений ресурсов с помощью `setrlimit`"

#. type: XXX figure here!
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:249
msgid "Modify some sysctl nodes (kern.hostname)"
msgstr "Изменять некоторые узлы sysctl (kern.hostname)"

#. type: XXX figure here!
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:250
msgid "`chroot()`"
msgstr "`chroot()`"

#. type: XXX figure here!
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:251
msgid "Set flags on a vnode: `chflags`, `fchflags`"
msgstr "Устанавливать флаги на vnode: `chflags`, `fchflags`"

#. type: XXX figure here!
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:252
msgid ""
"Set attributes of a vnode such as file permission, owner, group, size, "
"access time, and modification time."
msgstr ""
"Устанавливать атрибуты vnode, такие как права доступа к файлу, владелец, "
"группа, размер, время доступа и время изменения."

#. type: XXX figure here!
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:253
msgid "Bind to privileged ports in the Internet domain (ports < 1024)"
msgstr ""
"Привязываться к привилегированным портам в домене Интернета (порты < 1024)"

#. type: XXX figure here!
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:257
msgid ""
"`Jail` is a very useful tool for running applications in a secure "
"environment but it does have some shortcomings.  Currently, the IPC "
"mechanisms have not been converted to the `suser_xxx` so applications such "
"as MySQL cannot be run within a jail.  Superuser access may have a very "
"limited meaning within a jail, but there is no way to specify exactly what "
"\"very limited\" means."
msgstr ""
"`Клетка` — это очень полезный инструмент для запуска приложений в безопасной "
"среде, но у него есть некоторые недостатки. В настоящее время механизмы IPC "
"не были преобразованы в `suser_xxx`, поэтому такие приложения, как MySQL, не "
"могут быть запущены внутри клетки. Доступ суперпользователя может иметь "
"очень ограниченное значение внутри клетки, но нет возможности точно указать, "
"что означает «очень ограниченный»."

#. type: Title ===
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:258
#, no-wrap
msgid "POSIX(R).1e Process Capabilities"
msgstr "Возможности процесса в POSIX(R).1e"

#. type: XXX figure here!
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:261
msgid ""
"POSIX(R) has released a working draft that adds event auditing, access "
"control lists, fine grained privileges, information labeling, and mandatory "
"access control."
msgstr ""
"POSIX(R) выпустил рабочий проект, который добавляет аудит событий, списки "
"контроля доступа, детализированные привилегии, маркировку информации и "
"обязательный контроль доступа."

#. type: XXX figure here!
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:264
msgid ""
"This is a work in progress and is the focus of the http://www.trustedbsd.org/"
"[TrustedBSD] project.  Some of the initial work has been committed to "
"FreeBSD-CURRENT (cap_set_proc(3))."
msgstr ""
"Это работа в процессе, и она является основным направлением проекта http://"
"www.trustedbsd.org/[TrustedBSD]. Некоторые первоначальные наработки были "
"добавлены в FreeBSD-CURRENT (cap_set_proc(3))."

#. type: Title ==
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:266
#, no-wrap
msgid "Trust"
msgstr "Доверие"

#. type: XXX figure here!
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:270
msgid ""
"An application should never assume that anything about the users environment "
"is sane.  This includes (but is certainly not limited to): user input, "
"signals, environment variables, resources, IPC, mmaps, the filesystem "
"working directory, file descriptors, the # of open files, etc."
msgstr ""
"Приложение никогда не должно предполагать, что окружение пользователя "
"является предсказуемым. Это включает (но не ограничивается): "
"пользовательский ввод, сигналы, переменные окружения, ресурсы, IPC, mmaps, "
"текущую рабочую директорию файловой системы, файловые дескрипторы, "
"количество открытых файлов и т.д."

#. type: XXX figure here!
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:275
msgid ""
"You should never assume that you can catch all forms of invalid input that a "
"user might supply.  Instead, your application should use positive filtering "
"to only allow a specific subset of inputs that you deem safe.  Improper data "
"validation has been the cause of many exploits, especially with CGI scripts "
"on the world wide web.  For filenames you need to be extra careful about "
"paths (\"../\", \"/\"), symbolic links, and shell escape characters."
msgstr ""
"Никогда не следует предполагать, что можно отловить все виды некорректных "
"входных данных, которые может предоставить пользователь. Вместо этого ваше "
"приложение должно использовать позитивную фильтрацию, разрешая только "
"определённое подмножество входных данных, которые вы считаете безопасными. "
"Некорректная проверка данных стала причиной многих уязвимостей, особенно в "
"CGI-скриптах во всемирной паутине. Для имён файлов необходимо быть особенно "
"осторожными с путями (\"../\", \"/\"), символическими ссылками и escape-"
"символами оболочки."

#. type: XXX figure here!
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:278
msgid ""
"Perl has a really cool feature called \"Taint\" mode which can be used to "
"prevent scripts from using data derived outside the program in an unsafe "
"way.  This mode will check command line arguments, environment variables, "
"locale information, the results of certain syscalls (`readdir()`, "
"`readlink()`, `getpwxxx()`), and all file input."
msgstr ""
"В Perl есть замечательная функция под названием \"Режим Taint\", которая "
"может использоваться для предотвращения небезопасного использования данных, "
"полученных извне программы. Этот режим проверяет аргументы командной строки, "
"переменные окружения, информацию о локали, результаты определённых системных "
"вызовов (`readdir()`, `readlink()`, `getpwxxx()`) и все вводимые данные из "
"файлов."

#. type: Title ==
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:280
#, no-wrap
msgid "Race Conditions"
msgstr "Состояние гонки"

#. type: XXX figure here!
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:284
msgid ""
"A race condition is anomalous behavior caused by the unexpected dependence "
"on the relative timing of events.  In other words, a programmer incorrectly "
"assumed that a particular event would always happen before another."
msgstr ""
"Состояние гонки — это аномальное поведение, вызванное непредвиденной "
"зависимостью от относительного времени событий. Другими словами, программист "
"ошибочно предположил, что определенное событие всегда произойдет раньше "
"другого."

#. type: XXX figure here!
#: documentation/content/en/books/developers-handbook/secure/_index.adoc:290
msgid ""
"Some of the common causes of race conditions are signals, access checks, and "
"file opens.  Signals are asynchronous events by nature so special care must "
"be taken in dealing with them.  Checking access with `access(2)` then "
"`open(2)` is clearly non-atomic.  Users can move files in between the two "
"calls.  Instead, privileged applications should `seteuid()` and then call "
"`open()` directly.  Along the same lines, an application should always set a "
"proper umask before `open()` to obviate the need for spurious `chmod()` "
"calls."
msgstr ""
"Некоторые из распространённых причин состояний гонки — это сигналы, проверки "
"доступа и открытие файлов. Сигналы по своей природе являются асинхронными "
"событиями, поэтому при работе с ними необходимо проявлять особую "
"осторожность. Проверка доступа с помощью `access(2)`, а затем `open(2)` явно "
"неатомарна. Пользователи могут перемещать файлы между этими двумя вызовами. "
"Вместо этого привилегированные приложения должны использовать `seteuid()`, а "
"затем вызывать `open()` напрямую. По аналогии, приложение всегда должно "
"устанавливать правильную маску (`umask`) перед вызовом `open()`, чтобы "
"избежать необходимости в лишних вызовах `chmod()`."
