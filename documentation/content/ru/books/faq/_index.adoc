---
title: Часто задаваемые вопросы по FreeBSD 11.X и 12.X
authors: 
  - author: Проект документации FreeBSD
copyright: 1995-2020 The FreeBSD Documentation Project
releaseinfo: "$FreeBSD$" 
trademarks: ["freebsd", "ibm", "ieee", "adobe", "intel", "linux", "microsoft", "opengroup", "sun", "netbsd", "general"] 
---

= Часто задаваемые вопросы по FreeBSD {rel2-relx} и {rel-relx}
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:xrefstyle: basic
:relfileprefix: ../
:outfilesuffix:
:sectnums:
:sectnumlevels: 6
:partnums:
:source-highlighter: rouge
:experimental:
:skip-front-matter:
:toc-title: Содержание
:part-signifier: Часть
:chapter-signifier: Глава
:appendix-caption: Приложение
:table-caption: Таблица
:figure-caption: Рисунок
:example-caption: Пример
:rel-numbranch: 3
:rel-head: 13-CURRENT
:rel-head-relx: 13.X
:rel-head-releng: head/
:rel-relx: 12.X
:rel-stable: 12-STABLE
:rel-releng: stable/12/
:rel-relengdate: December 2018
:rel2-relx: 11.X
:rel2-stable: 11-STABLE
:rel2-releng: stable/11/
:rel2-relengdate: October 2016

ifeval::["{backend}" == "html5"]
include::shared/mirrors.adoc[]
include::shared/authors.adoc[]
include::shared/releases.adoc[]
include::shared/ru/mailing-lists.adoc[]
include::shared/ru/teams.adoc[]
include::shared/ru/urls.adoc[]
endif::[]

ifeval::["{backend}" == "pdf"]
include::../../../../shared/mirrors.adoc[]
include::../../../../shared/authors.adoc[]
include::../../../../shared/releases.adoc[]
include::../../../../shared/ru/mailing-lists.adoc[]
include::../../../../shared/ru/teams.adoc[]
include::../../../../shared/ru/urls.adoc[]
endif::[]

ifeval::["{backend}" == "epub3"]
include::../../../../shared/mirrors.adoc[]
include::../../../../shared/authors.adoc[]
include::../../../../shared/releases.adoc[]
include::../../../../shared/ru/mailing-lists.adoc[]
include::../../../../shared/ru/teams.adoc[]
include::../../../../shared/ru/urls.adoc[]
endif::[]

[.abstract-title]
Аннотация

Этот документ является так называемым FAQ (Frequently Asked Questions), то есть списком Часто Задаваемых Вопросов по FreeBSD версий {rel3-relx}, {rel2-relx} и {rel-relx}. Мы прилагаем все усилия, чтобы сделать этот FAQ максимально информативным; если у вас есть идеи по его усовершенствованию, шлите их на адрес {freebsd-doc}.

Последняя редакция этого документа всегда доступна с link:{faq}[Web-сервера FreeBSD]. Его также можно получить в виде одного большого link:.[ HTML-файла] по HTTP или в ряде других форматов с link:ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/[FTP-сервера].

'''

toc::[]

== Вступление

=== FreeBSD - что это такое?

FreeBSD - это современная операционная система для настольных компьютеров, ноутбуков, серверов и встраиваемых систем с поддержкой большого количества http://www.FreeBSD.org/ru/platforms/[платформ].

В основе FreeBSD лежит операционная система "4.4BSD-Lite" Калифорнийского Университета (Беркли) с некоторыми усовершенствованиями из "4.4BSD-Lite2". Также она косвенно базируется на 386BSD (BSD Net/2, перенесённой на платформу i386(TM) Уильямом Джолитцем (William Jolitz)), хотя от того первоначального кода осталось очень мало.

FreeBSD используется компаниями, Интернет-провайдерами, научными работниками, профессионалами в вычислительной технике, студентами и рядовыми пользователями по всему миру для работы, образования и отдыха.

Для более детального знакомства с FreeBSD обратитесь к link:{handbook}/[Руководству по FreeBSD].

[[FreeBSD-goals]]
=== Какова цель FreeBSD?

Цель проекта FreeBSD - предоставить быструю и стабильную операционную систему общего назначения, которую можно использовать в любых целях без каких-либо ограничений.

=== Есть ли в лицензии FreeBSD какие-то ограничения?

Да. Эти ограничения не касаются аспектов использования кода, но главным образом описывают отношение к Проекту FreeBSD. Текст лицензионного соглашения доступен http://www.FreeBSD.org/ru/copyright/freebsd-license/[здесь], и вкратце он может быть изложен следующим образом:

* Не говорите, что это написано вами.
* Не судитесь с нами, если что-то не работает.
* Не удаляйте и не изменяйте лицензию.

Многие из нас вкладывают в проект значительные усилия и определённо были бы не против получения финансовой поддержки, но требовать её мы не будем. Мы надеемся, что наша основная и самая значительная "миссия" - предоставить код всем желающим, для любых целей, так чтобы он нашел самое широкое применение и принёс наибольшую пользу. Это, на наш взгляд, одна из самых фундаментальных целей Free Software, которую мы с энтузиазмом поддерживаем.

Часть исходного кода нашей системы, подпадающая под действие http://www.FreeBSD.org/copyright/COPYING[GNU General Public License (GPL)] или http://www.FreeBSD.org/copyright/COPYING.LIB[GNU Library General Public License (LGPL)], имеет несколько больше ограничений, хотя и представляет собой навязывание доступа к исходным текстам, а не наоборот, как обычно. Из-за дополнительных сложностей, которые могут возникнуть в случае коммерческого использования программного обеспечения GPL, мы стараемся, где только это возможно, заменить подобное программное обеспечение аналогичным, но подпадающим под менее строгую http://www.FreeBSD.org/copyright/freebsd-license/[ лицензию FreeBSD].

=== Может ли FreeBSD заменить операционную систему, используемую мною сейчас?

Для большинства людей, да. Но этот ответ не так уж однозначен.

Большинство пользователей на самом деле не используют операционную систему. Они работают с приложениями. Именно прикладные программы и используют операционную систему. FreeBSD разработана для того, чтобы дать надежное и полнофункциональное окружение для приложений. Она поддерживает широкий спектр Web-браузеров, офисных пакетов, программ для работы с электронной почтой, графических пакетов, программных сред, сетевых серверов и многое другое. Большинство этих приложений могут быть получено из http://www.FreeBSD.org/ports/[Коллекции Портов].

Если приложение доступно только для одной операционной системы, то нельзя всего лишь заменить эту операционную систему. Однако есть вероятность, что похожая программа существует для FreeBSD. В качестве сервера для офиса, или сервера Интернет, или надежной рабочей станции FreeBSD практически всегда справится со всем, что вам нужно. Многие пользователи по всему миру, включая как новичков, так и опытных администраторов UNIX(R), используют FreeBSD в качестве своей единственной настольной операционной системы.

Пользователи при переходе на FreeBSD с другого варианта UNIX(R) найдут для себя FreeBSD очень похожей. Пользователей Windows(R) и Mac OS(R), напротив, может заинтересовать http://www.pcbsd.org/[PC-BSD], дистрибутив на основе FreeBSD. Пользователям, которые не использовали до этого UNIX(R), понадобится затратить дополнительное время на изучение подхода UNIX(R) к работе. Этот FAQ и link:{handbook}[Руководство по FreeBSD] являются прекрасным способом начать это изучение.

=== Почему система называется именно FreeBSD?

* Она может использоваться безо всяческих выплат, даже для извлечения выгоды.
* Все исходные тексты операционной системы свободно доступны, на её использование в других разработках (как коммерческих, так и некоммерческих) и дальнейшее распространение наложены минимальные ограничения.
* Любой, у кого есть усовершенствования или исправления, может предоставить свой код и он будет (правда, с парой оговорок) добавлен в исходные тексты системы.

Следует отметить, что слово "free" используется здесь в двух смыслах: один означает "бесплатно", а другой "делать всё, что хотите". За исключением пары вещей, которые вы _не можете_ делать с FreeBSD, например, претендовать на то, что являетесь её разработчиком, на самом деле можно делать с ней всё, что вам заблагорассудится.

=== В чём заключается разница между FreeBSD и NetBSD, OpenBSD и другими операционными системами с открытыми кодами семейства BSD?

Джеймс Ховард (James Howard) создал хорошее описание истории и различий между различными проектами под названием http://www.freebsdworld.gr/freebsd/bsd-family-tree.html[Семейное древо BSD], в котором даётся подробный ответ на этот вопрос. Некоторая информация там устарела, но историческая часть остаётся точной.

Многие из проектов семейства BSD обмениваются изменениями и готовым кодом даже сегодня. Все они происходят от общего предка.

Цели проекта FreeBSD описаны выше в <<FreeBSD-goals>>. Цели других наиболее известных проектов семейства BSD можно кратко описать так:

* OpenBSD в первую очередь ориентируется на безопасность операционной системы. Команда OpenBSD написала man:ssh[1] и man:pf[4], которые затем были портированы во FreeBSD.
* NetBSD ориентируется на простое портирование на другие аппаратные платформы.
* DragonFly BSD отделилась от FreeBSD 4.8, и с тех пор в ней были разработаны многие интересные собственные функциональные возможности, включая файловую систему HAMMER и поддержку "vkernels" - запуска ядра в пользовательском режиме.

=== Какова последняя версия FreeBSD?

На любом этапе разработки FreeBSD может существовать несколько параллельных веток. Релизы {rel-relx} выполняются из ветки {rel-stable}, а релизы {rel2-relx} выполняются из {rel2-stable}.

До выпуска 9.0 линейка {rel2-relx} была известна как _-STABLE_. Однако к моменту выхода {rel-head-relx} линейка {rel2-relx} получит статус "extended support" (расширенная поддержка), и исправления будут вноситься только для серьезных проблем, к примеру исправления, связанные с безопасностью. 

Версия link:ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/i386/{rel120-current}-RELEASE/[{rel120-current}], дата выхода {rel120-current-date}, является последним релизом в ветке {rel-stable}. Версия link:ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/{rel112-current}-RELEASE/[{rel112-current}], дата выхода {rel112-current-date}, является последним релизом в ветке {rel2-stable}.

Если вкратце, то ветка _-STABLE_ предназначена поставщикам услуг Internet, корпоративным пользователям, а также всем тем, кому в первую очередь нужна надёжность и минимальное количество отличий от последнего релиза по сравнению с новыми (и, возможно, ненадёжно работающими) возможностями последнего снэпшота _-CURRENT_. Релизы можно делать из любой ветки, но _-CURRENT_ предназначен для пользователей, которые готовы к постоянным (по сравнению со _-STABLE_) изменениям в работе системы.

Релизы делаются <<release-freq,раз в несколько месяцев>>. Хотя многие стараются отслеживать актуальное состояние исходных текстов FreeBSD (обратите внимание на вопросы о <<current,FreeBSD-CURRENT>> и <<stable,FreeBSD-STABLE>>), делать это не обязательно, так как исходные тексты постоянно меняются.

Более полную информацию о релизах FreeBSD можно получить на странице http://www.FreeBSD.org/ru/releng/[Информации о подготовке релизов] и на странице Справочника man:release[7].

=== Что такое FreeBSD-CURRENT?

link:{handbook}#current[ FreeBSD-CURRENT] - это версия операционной системы, находящаяся в стадии разработки, которая должна потом стать новой веткой FreeBSD-STABLE. Таким образом, она представляет реальный интерес только для разработчиков системы и её фанатов. Обратитесь к link:{handbook}#current[соответствующему разделу] link:{handbook}[Руководства] для прояснения деталей работы с _-CURRENT_.

Пользователям, не знакомым с FreeBSD, не следует использовать FreeBSD-CURRENT. Эта ветвь зачастую меняется очень быстро и иногда из-за ошибок может быть не работоспособна. Те, кто используют FreeBSD-CURRENT, должны быть в состоянии изучить проблему, найти причину и сообщить о этом.

Из веток _-CURRENT_ и _-STABLE_ выпускаются link:https://www.FreeBSD.org/snapshots/[снэпшоты] FreeBSD. Их предназначение:

* Тестирование самой последней версии программы установки системы.
* Дать людям, которые хотят работать с _-CURRENT_ или _-STABLE_, но не имеют времени или возможности (пропускной способности) для отслеживания ежедневных изменений, простой способ её установки.
* Фиксация точки для последующих ссылок в случае, если позже мы что-нибудь очень сильно сломаем. (Хотя Subversion, как правило, не позволяет случиться ничему такому ужасному.)
* Все новые возможности, которым требуется тестирование, должны иметь как можно больше потенциальных тестеров.

Не утверждается, что всякий снэпшот _-CURRENT_ имеет качество "готового продукта". Если нужна стабильно работающая и полностью оттестированная система, то придерживайтесь использования полных релизов или используйте снэпшоты _-STABLE_.

Снэпшот-релизы доступны непосредственно link:https://www.FreeBSD.org/snapshots/[отсюда].

Официальные снэпшоты постоянно генерируются для всех активно разрабатываемых веток.

=== В чём смысл FreeBSD-STABLE?

После того, как была выпущена FreeBSD 2.0.5, разработка FreeBSD разделилась на две части. Одна ветка получила название link:{handbook}#stable[-STABLE], а другая link:{handbook}#current[-CURRENT]. _FreeBSD-STABLE_ предназначена для провайдеров услуг Интернет и других коммерческих пользователей, для которых неожиданные изменения или экспериментальные возможности весьма нежелательны. В неё вносятся только хорошо оттестированные исправления и другие небольшие последовательные усовершенствования. С другой стороны, _FreeBSD-CURRENT_ являлась единой веткой, не разрываемой с момента выхода версии 2.0 и ведущей к {rel120-current}-RELEASE и последующим релизам. Для получения более подробной информации по веткам обратитесь к разделу статьи "link:{releng}#rel-branch[ Подготовка релизов FreeBSD: Создание ветки релиза]". Статус веток и расписание предстоящих релизов можно получить на странице http://www.FreeBSD.org/releng[Информация о подготовке релизов].

Активно разрабатываемой веткой _-STABLE_ является {rel120-current}-STABLE. Последним релизом в ветке {rel120-current}-STABLE является {rel120-current}-RELEASE, выпущенный {rel120-current-date}.

Активно разрабатываемой веткой _-CURRENT_ является ветка {rel-head}, которая движется к созданию следующего поколения FreeBSD. Прочтите ответ на вопрос <<current,Что такое FreeBSD-CURRENT?>> для получения более подробной информации об этой ветке.

=== В какой момент выпускаются новые версии FreeBSD?

{re} выпускает новую старшую версию FreeBSD в среднем каждые 18 месяцев и младшие версии каждые 8 месяцев. Даты релизов обычно объявляются заранее, так что те, кто работает над системой, знают, когда их проекты должны быть закончены и протестированы. Период тестирования предшествует выходу каждого релиза, для того, чтобы удостовериться в том, что добавление новых возможностей не повлияло на стабильность работы релиза. Многие пользователи расценивают такую осторожность как одну из приятнейших черт FreeBSD, хотя необходимость дожидаться _-STABLE_ для получения всех этих новых возможностей может несколько разочаровывать.

Дополнительная информация о процессе подготовки релиза (в том числе планы выпуска последующих релизов) может быть найдена на страницах Web-сайта FreeBSD, посвящённых http://www.FreeBSD.org/releng/[выпуску релизов].

Для тех, кому нужно или хочется, еженедельно выпускаются бинарные снапшоты, как описано выше.

=== Кто разрабатывает FreeBSD?

Решения, которые касаются ключевых моментов в проекте FreeBSD, такие, как общее направление развития проекта или кто может добавлять код к дереву исходных текстов, принимаются link:https://www.FreeBSD.org/administration/#t-core[основной командой] разработчиков (Core Team), состоящей из 9 человек. Также существует многочисленная группа, состоящая из более чем 350 так называемых link:{contributors}#staff-committers[коммиттеров] (committers), которые могут вносить изменения прямо в дерево исходных текстов FreeBSD.

Однако большинство нетривиальных изменений широко обсуждается в <<mailing,списках рассылки>>, и не существует никаких ограничений на участие в подобных дискуссиях.

=== Где можно найти FreeBSD?

Все основные релизы FreeBSD доступны по FTP с link:ftp://ftp.FreeBSD.org/pub/FreeBSD/[FTP-сервера FreeBSD]:

* Последний релиз {rel-stable}, {rel120-current}-RELEASE, можно найти в link:ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/i386/{rel120-current}-RELEASE[каталоге {rel120-current}-RELEASE].
* link:https://www.FreeBSD.org/snapshots/[Снэпшот-релизы] для веток <<current,-CURRENT>> и <<stable,-STABLE>> выпускаются ежемесячно, но они нужны исключительно для разработчиков и тех, кто тестирует самые последние наработки.
* Последний релиз {rel2-stable}, {rel112-current}-RELEASE, можно найти в link:ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/{rel112-current}-RELEASE/[каталоге {rel112-current}-RELEASE].

Информация о получении/приобретении FreeBSD на CD, DVD и других носителях доступна в link:{handbook}#mirrors/[Руководстве].

=== Как можно получить доступ к базе сообщений о проблемах (Problem Report)?

База данных всех сообщений пользователей о проблемах может быть запрошена с помощью нашего https://bugs.FreeBSD.org/search/[Web-интерфейса].

Можно использовать link:https://www.FreeBSD.org/support/bugreports/[Web-интерфейс] для отсылки сообщений об ошибках через браузер.

Перед тем, как посылать сообщение об ошибке, прочтите статью link:{problem-reports}[Составление сообщений о проблеме во FreeBSD] о том, как писать хорошие сообщения об ошибках.

== Документация и поддержка

=== Есть ли хорошие книги по FreeBSD?

В рамках проекта создан широкий спектр документации, которая доступна on-line по следующей ссылке: http://www.FreeBSD.org/docs/[http://www.FreeBSD.org/docs/]. Кроме того, в <<bibliography,Библиографии>> в конце этого FAQ и в link:{handbook}#bibliography/[Руководстве] имеются ссылки на другие рекомендуемые для чтения книги.

=== Есть ли версии документации в другом формате, например, в виде обычного текста ASCII или PostScript(R)?

Да. Документация имеется в нескольких различных форматах и упакованная разными способами на FTP-сервере FreeBSD, и находится она в каталоге link:ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/[ /pub/FreeBSD/doc/].

Документация подразделяется на категории различными способами. Это включает:

* Имя документа, например, `faq` или `handbook`.
* Язык и кодировка документа. Они опираются на имена локализаций, которые находятся в каталоге [.filename]#/usr/shared/locale# в системе FreeBSD. На данный момент поддерживаются следующие языки и кодировки:
+
[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Кодировка
| Язык

|`en_US.ISO8859-1`
|Английский (США)

|`bn_BD.ISO10646-1`
|Бенгальский или Бангла (Бангладеш)

|`da_DK.ISO8859-1`
|Датский (Дания)

|`de_DE.ISO8859-1`
|Немецкий (Германия)

|`el_GR.ISO8859-7`
|Греческий (Греция)

|`es_ES.ISO8859-1`
|Испанский (Испания)

|`fr_FR.ISO8859-1`
|Французский (Франция)

|`hu_HU.ISO8859-2`
|Венгерский (Венгрия)

|`it_IT.ISO8859-15`
|Итальянский (Италия)

|`ja_JP.eucJP`
|Японский (Япония, кодировка EUC)

|`mn_MN.UTF-8`
|Монгольский (Монголия, кодировка UTF-8)

|`nl_NL.ISO8859-1`
|Голландский (Нидерланды)

|`no_NO.ISO8859-1`
|Норвежский (Норвегия)

|`pl_PL.ISO8859-2`
|Польский (Польша)

|`pt_BR.ISO8859-1`
|Португальский (Бразилия)

|`ru_RU.KOI8-R`
|Русский (Россия, кодировка KOI8-R)

|`sr_YU.ISO8859-2`
|Сербский (Сербия)

|`tr_TR.ISO8859-9`
|Турецкий (Турция)

|`zh_CN.UTF-8`
|Упрощённый китайский (Китай, кодировка UTF-8)

|`zh_TW.UTF-8`
|Традиционный китайский (Тайвань, кодировка UTF-8)
|===
+
[NOTE]
====
Некоторые документы могут иметься не на всех языках.
====

* Формат документа. Мы создаём документацию в нескольких различных форматах. У каждого из форматов имеются свои плюсы и свои минусы. Некоторые форматы лучше подходят для чтения в on-line, когда как другие предназначены для получения эстетично выглядящей на бумаге копии. Наличие документации во всех этих форматах обеспечивает возможность прочтения нашими пользователями любой её части как с экрана монитора, так и на бумаге после вывода на печать. На данный момент поддерживаются следующие форматы;
+
[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Формат
| Значение

|`html-split`
|Набор маленьких связанных друг с другом HTML-файлов.

|`html`
|Один большой HTML-файл, полностью содержащий документ.

|`pdf`
|Adobe's Portable Document Format

|`ps`
|PostScript(R)

|`rtf`
|Rich Text Format от Microsoft(R)

|`txt`
|Обычный текст
|===
+
[NOTE]
====
Номера страниц при загрузке Rich Text Format в Word автоматически не обновляются. Для обновления нумерации нажмите kbd:[Ctrl+A], kbd:[Ctrl+End], kbd:[F9] после загрузки документа.
====

* Способ сжатия и создания архива.
.. В случае формата `html-split`, файлы архивируются с помощью man:tar[1]. Получающийся файл [.filename]#.tar# затем подвергается сжатию по схемам, подробно описываемым далее.
.. Все другие форматы генерируют один файл. Например, [.filename]#article.pdf#, [.filename]#book.html#, и так далее.
+ 
Эти файлы затем сжимаются по двум схемам сжатия, `zip` или `bz2`. Для работы с этими файлами можно использовать man:tar[1].
+ 
Таким образом, сжатая в `bzip2` версия Руководства в формате PostScript(R), будет находиться в файле с именем [.filename]#book.ps.bz2# в каталоге [.filename]#handbook/#.

После выбора формата и способа компрессии, сгрузите упакованные файлы, распакуйте их, а затем скопируйте документацию в соответствующие места.

Например, версия FAQ в виде отдельных HTML-файлов, упакованная при помощи man:bzip2[1], находится в файле [.filename]#doc/ru_RU.KOI8-R/books/faq/book.html-split.tar.bz2#. Для сгрузки и распаковки этого файла наберите:

[source,bash]
....
# fetch ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/en_US.ISO8859-1/books/faq/book.html-split.tar.bz2
# tar xvf book.html-split.tar.bz2
....

Если файл сжат, tar автоматически определит подходящий формат и корректно распакует файл в набор файлов [.filename]#.html#. Главным является [.filename]#index.html#, и в нём находится оглавление, вводный материал и ссылки на остальные части документа.

=== Где найти информацию по спискам рассылки FreeBSD? Какие существуют телеконференции по FreeBSD?

Исчерпывающая информация содержится в link:{handbook}#eresources-mail[разделе] Руководства, который посвящён спискам рассылки, и в link:{handbook}#eresources-news/[разделе] Руководства, касающемся телеконференций.

=== Существуют ли каналы IRC (Internet Relay Chat) по FreeBSD?

Да, большинство сетей IRC имеют канал FreeBSD:

* Канал `#FreeBSDhelp` в сети http://www.efnet.org/index.php[EFNet] предназначен для помощи пользователям FreeBSD.
* Канал `#FreeBSD` в сети http://freenode.net/[Freenode] предназначен для помощи общего характера, на нём в любое время присутствует много посетителей. Общение в течение уже некоторого времени известно своей тенденцией сводиться к разговорам не по теме, но приоритет отдается пользователям с вопросами по FreeBSD. Другие пользователи помогут разобраться в основах, отсылая к Руководству по мере возможности и предлагая ссылки для более глубокого изучения интересующих тем. Это преимущественно англоговорящий канал, но туда приходят пользователи со всего мира. Тем, для кого английский не является родным, следует сперва задать вопрос на английском и затем перейти на подходящий канал `##freebsd-lang`.
* Канал `#FreeBSD` в сети http://www.dal.net/[DALNET] доступен на сервере `irc.dal.net` в США и на `irc.eu.dal.net` в Европе.
* Канал `#FreeBSD` в сети http://www.undernet.org/[UNDERNET] доступен на серверах `us.undernet.org` в США и `eu.undernet.org` в Европе. Так как это канал взаимопомощи, приготовьтесь к чтению документации, к которой вас отошлют.
* Канал `#FreeBSD` в сети http://www.rusnet.org.ru/[RUSNET] это канал для русскоговорящих посетителей, посвящённый помощи пользователям FreeBSD. Также это хорошее место для нетехнических дискуссий.
* Канал `#bsdchat` в сети http://freenode.net/[Freenode] это канал для посетителей, говорящих на китайском традиционном языке (кодировка UTF-8), посвящённый помощи пользователям FreeBSD. Также это хорошее место для нетехнических дискуссий.

На FreeBSD wiki имеется http://wiki.freebsd.org/IrcChannels[хороший список] каналов IRC.

Все каналы разные и не имеют отношения друг к другу. Поскольку их стили общения отличаются, попробуйте каждый, пока не найдёте подходящий вашему стилю общения.

=== Есть ли какие-нибудь web-форумы для обсуждения FreeBSD?

Официальные форумы FreeBSD расположены по адресу https://forums.FreeBSD.org/[https://forums.FreeBSD.org/].

=== Где можно пройти платные курсы по FreeBSD и получить поддержку?

http://www.ixsystems.com[iXsystems, Inc.], дочерней компанией которой является http://www.freebsdmall.com/[FreeBSD Mall], предоставляет http://www.ixsystems.com/bsdsupport[поддержку] FreeBSD и программного обеспечения PC-BSD на коммерческой основе, в дополнение к разработке FreeBSD и решениям, требующим тонкой настройки.

BSD Certification Group, Inc. предоставляет сертификацию системного администрирования DragonFly BSD, FreeBSD, NetBSD и OpenBSD. Для получения дополнительной информации посетите http://www.BSDCertification.org[их сайт].

Чтобы попасть в этот список, другие организации, осуществляющие обучение и поддержку, должны обратиться к нам в Проект.

== Установка

=== Какую архитектуру нужно загрузить? У меня есть 64-разрядный процессор Intel(R), но я вижу только amd64.

amd64 - это термин, применяемый во FreeBSD для обозначения 64-разрядной архитектуры x86 (также известна как "x86-64" или "x64"). На большинстве современных компьютеров следует использовать amd64. Для более старых подойдёт i386. При установке системы на отличную от x86 архитектуру, выберите платформу, наиболее подходящую для оборудования.

=== Какой файл нужно скачать для установки FreeBSD?

На странице http://www.freebsd.org/ru/where/[Получение FreeBSD] выберите `[iso]` с соответствующей оборудованию архитектурой.

Можно использовать любой из:

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| файл
| описание

|[.filename]#disc1.iso#
|Содержит достаточно для установки FreeBSD и минимальный набор пакетов.

|[.filename]#dvd1.iso#
|Наподобие [.filename]#disc1.iso#, но с дополнительными пакетами.

|[.filename]#memstick.img#
|Образ с автозагрузкой для записи на USB флешку.

|[.filename]#bootonly.iso#
|Минимальный образ, требующий сетевое подключение для завершения установки FreeBSD.
|===

Пользователям pc98 нужны образы дискет: [.filename]#floppies/boot.flp#, [.filename]#floppies/kern1.flp#, [.filename]#floppies/kern2.flp# и [.filename]#floppies/mfsroot1.flp#. Эти образы нужно перенести на дискеты с помощью таких утилит, как man:dd[1].

Полные инструкции по этой процедуре и об установке вообще можно найти в link:{handbook}#install/[ разделе] Руководства, посвящённом установке FreeBSD.

=== Помогите! Установочный образ не загружается!

Это может быть вызвано тем, что образ был загружен по FTP не в режиме _binary_.

В некоторых клиентских программах FTP по умолчанию используется текстовый (_ascii_) режим передачи, в котором любые последовательности символов "конец строки" заменяются на используемые в системе клиента. В таком случае образ загрузочного диска будет неизбежно испорчен. Проверьте контрольную сумму SHA-256 полученного файла: если он не _точно_ такой же как на FTP-сервере, то ошибка произошла, скорее всего, в процессе передачи.

В случае использования командной строки FTP-клиента введите команду _binary_ в командной строке FTP после подключения к серверу, но перед началом передачи файла.

=== Где инструкции по установке FreeBSD?

Инструкции по установке FreeBSD 9.0 и более поздних версий могут быть найдены в link:{handbook}#bsdinstall/[главе] Руководства, посвящённой установке FreeBSD. Также имеются инструкции по установке link:{handbook}#install/[предыдущих] версий FreeBSD.

=== Какие минимальные требования для запуска FreeBSD?

Для работы FreeBSD необходим ПК класса 486 и выше с оперативной памятью объёмом не менее 64 Мбайт и дисковым пространством не менее 1.1 Гбайт.

=== Как сделать собственный установочный диск?

Индивидуальный установочный носитель FreeBSD можно создать, запустив процедуру построения индивидуального релиза. Следуйте инструкциям в статье о link:{releng}[подготовке релизов FreeBSD].

=== Может ли Windows(R) сосуществовать с FreeBSD?

Да, если Windows(R) установлена первой. Загрузчик FreeBSD будет управлять процессом выбора загрузки Windows(R) или FreeBSD. Если Windows(R) устанавливается следом, то это приведёт к перезаписи загрузчика. Если такое случится, обратитесь к следующему разделу.

=== Другая операционная система уничтожила мой загрузчик операционной системы! Как мне его вернуть?

Способ восстановления зависит от используемого загрузчика. Меню выбора загрузки, используемое во FreeBSD, можно переустановить с помощью man:boot0cfg[8]. Пример для восстановления меню загрузки на диске _ada0_:

[source,bash]
....
# boot0cfg -B ada0
....

Неинтерактивный загрузчик MBR можно установить с помощью man:gpart[8]:

[source,bash]
....
# gpart bootcode -b /boot/mbr ada0
....

Более сложные ситуации, включая использование дисков GPT, рассматриваются в man:gpart[8].

=== Я загрузился с компакт-диска, однако программа установки сообщила, что CD-ROM не найден. Куда он подевался?

Обычной причиной возникновения такой проблемы является неправильно сконфигурированный привод CD-ROM. Теперь зачастую ПК продаются с CD-ROM, установленным как ведомое устройство на втором контроллере IDE, но без ведущего устройства на этом контроллере. Согласно спецификации ATAPI, такая конфигурация неверна, однако Windows(R) в таком случае всё же работает, и BIOS игнорирует это при загрузке. Вот почему BIOS может видеть CD-ROM при загрузке, а FreeBSD для завершения установки - нет.

Переконфигурируйте систему так, чтобы CD-ROM оказался либо основным устройством на том IDE-контроллере, на котором он установлен, либо ведомым устройством на контроллере IDE, который имеет ведущее устройство.

=== Нужно ли устанавливать исходные тексты системы?

В общем случае, нет. Для работы основной системы присутствие исходных текстов не требуется. Некоторые порты наподобие [.filename]#sysutils/lsof# не будут собираться без установленных исходных текстов системы. В частности, если порт собирает модуль ядра или напрямую обращается к структурам ядра, в этом случае исходные тексты должны быть установлены.

=== Нужно ли перекомпилировать ядро?

Обычно нет. Поставляемое ядро `GENERIC` содержит драйвера, необходимые для типичного компьютера. Инструмент man:freebsd-update[8] не может использоваться для обновления FreeBSD с собственным ядром. Поэтому по возможности стоит придерживаться использования ядра `GENERIC`. Для компьютеров с очень небольшим объёмом ОЗУ, таких как встраиваемые системы, может потребоваться собственное небольшое ядро, содержащее только необходимые драйверы.

=== Какой из паролей DES, Blowfish или MD5 я должен использовать, и как указать, какого типа пароли используются пользователями?

Во FreeBSD 9 и выше по умолчанию используется _SHA512_. Пароли DES остаются доступны для обратной совместимости с более старыми операционными системами, в которых используется менее защищённый формат паролей. FreeBSD также поддерживает пароли в форматах Blowfish и MD5. Управление выбором используемого формата для новых паролей осуществляется через параметр входа `passwd_format` в файле [.filename]#/etc/login.conf#, принимающий значения `des`, `blf` (если они есть) или `md5`. Подробная информация о параметрах входа находится на странице Справочника man:login.conf[5].

=== Какие существуют ограничения для файловой системы FFS?

Наибольший размер файловой системы FFS ограничен практически количеством памяти, которая требуется для работы man:fsck[8]. man:fsck[8] использует 1 бит на фрагмент, и для стандартного размера фрагмента 4 Кбайт это эквивалентно использованию 32 Мбайт памяти на терабайт дискового пространства. Это означает, что на архитектурах с ограничением размера пользовательского процесса в 2 Гбайт (например, i386(TM)) максимальный размер файловой системы, доступный для man:fsck[8], составляет ~60 Тбайт.

Без ограничения на память для man:fsck[8] максимальный размер файловой системы составляет 2 ^ 64 (блоков) * 32 Кбайт => 16 экса * 32 Кбайт => 512 зеттабайт.

Максимальный размер файла на FFS приблизительно равен 2 петабайт со стандартным размером блока 32 Кбайт. Каждый 32 Кбайтный блок может адресовать до 4096 блоков. С использованием тройной косвенной адресации это составляет 32 Кбайт * 12 + 32 Кбайт * 4096 + 32 Кбайт * 4096^2 + 32 Кбайт * 4096^3. Увеличение размера блока до 64 Кбайт увеличит максимальный размер файла в 16 раз.

=== Я скомпилировал новое ядро и при загрузке получил сообщение об ошибке readin failed.

Ядро и компоненты системы не синхронизированы. Такая конфигурация не поддерживается. Обязательно используйте команды `make buildworld` и `make buildkernel` для обновления ядра.

Загрузите систему, непосредственно указав ядро на втором этапе загрузки, нажав любую клавишу до запуска загрузчика при появлении символов `|`.

=== Существует ли инструмент для настройки системы после её установки?

Да, bsdconfig предоставляет замечательный интерфейс для пост-установочной настройки FreeBSD.

[[hardware]]
== Аппаратная совместимость

[[compatibility-general]]
=== Вопросы общего характера

==== Я хочу приобрести аппаратуру для моей системы FreeBSD. Какая модель/производитель/тип лучше всего?

Это постоянно обсуждается в списках рассылки FreeBSD и является ожидаемым вопросом, так как аппаратура меняется очень быстро. Обратитесь к Hardware Notes для FreeBSD link:{u-rel120-hardware}[{rel120-current}] или link:[{rel112-current}], а также http://www.FreeBSD.org/search/#mailinglists[архивам] списков рассылки перед тем, как задавать вопросы о самом последнем и лучшем оборудовании. Весьма вероятно, что обсуждение касаемо этого типа оборудования велось как раз на прошлой неделе.

Перед приобретением лэптопа посмотрите архивы link:{freebsd-mobile} и {freebsd-questions} или, по возможности, более специфичные списки рассылки по данному типу оборудования.

==== Какие существуют ограничения по памяти? Поддерживает ли FreeBSD больше 4 Гбайт памяти (ОЗУ)? Больше 16 Гбайт? Больше 48 Гбайт?

FreeBSD как операционная система в целом поддерживает столько же физической памяти (ОЗУ), сколько аппаратная платформа, на которой она работает. Имейте в виду, что различные платформы имеют различные ограничения на память; например, i386(TM) без PAE поддерживает максимум 4 Гбайт памяти (и обычно еще меньше из-за адресного пространства PCI), а i386(TM) с PAE поддерживает максимум 64 Гбайт. Для FreeBSD 10 платформы AMD64 поддерживают до 4 Тбайт физической памяти.

==== Почему FreeBSD видит меньше 4 Гбайт памяти, когда система установлена на машину i386(TM)?

Общее адресное пространство для машин i386(TM) является 32-разрядным; это означает, что адресоваться (т.е. быть получено) может не более 4 Гбайт памяти. Более того, некоторые адреса в этом диапазоне зарезервированы для различных целей аппаратным обеспечением, например, для использования и управления устройствами PCI, для доступа к видеопамяти, и так далее. Таким образом, общий объем памяти, используемой операционной системой для ядра и приложений, ограничен размером, значительно меньшим, чем 4 Гбайт. В такой конфигурации максимально доступная физическая память составляет от 3.2 Гбайт до 3.7 Гбайт.

Для преодоления ограничения в 3.2 Гбайт-3.7 Гбайт установленной памяти (т.е. для получения 4 Гбайт, но также более 4 Гбайт) должен использоваться специальный механизм, именуемый PAE. Сокращение PAE расшифровывается как Physical Address Extension (расширение физического адреса) и предоставляет для 32-разрядных x86 процессоров способ адресовать более 4 Гбайт памяти. PAE переназначает память, которая иначе была бы перекрыта адресными резервациями для аппаратных устройств выше диапазона 4 Гбайт, и использует ее как дополнительную физическую память (смотрите man:pae[4]). Использование PAE имеет свои недостатки; такая модель доступа к памяти является чуть более медленной по сравнению с обычным режимом (без PAE), и также не работают динамически загружаемые модули (смотрите man:kld[4]). Это означает, что все драйверы должны присутствовать статически в самом ядре.

Самый общий способ включить PAE - это собрать новое ядро со специальным уже подготовленным файлом конфигурации ядра, именуемым [.filename]#PAE#, который уже сконфигурирован для сборки безопасного ядра. Имейте в виду, что некоторые строки в этом файле конфигурации ядра являются слишком консервативными, и некоторые драйверы, помеченные как неготовые для использования с PAE, на самом деле являются годными. На практике, если драйвер работает на 64-разрядной архитектуре (такой как AMD64), он также работает с PAE. При создании своего собственного файла конфигурации ядра можно включить PAE, добавив следующую строку:

[.programlisting]
....
options       PAE
....

PAE не является широко используемым в настоящее время, поскольку большинство нового x86 аппаратного обеспечения также поддерживает работу в 64-разрядном режиме, также известном как AMD64 или Intel(R) 64. Этот режим имеет большее адресное пространство и не нуждается в таких трюках. FreeBSD поддерживает AMD64, и рекомендуется использование этой версии FreeBSD вместо версии i386(TM), если требуется больше 4 Гбайт памяти.

[[compatibility-processors]]
=== Аппаратные платформы и процессоры

==== Поддерживает ли FreeBSD аппаратные платформы, отличные от x86?

Да. Поддержка FreeBSD подразделяется на множество классов. Архитектуры первого класса, такие как i386 или amd64, полностью поддерживаются. Архитектуры 2 и 3 класса поддерживаются по мере возможности. Полное описание классов доступно в link:{committers-guide}#archs/[справочнике коммиттера].

Полный список поддерживаемых архитектур находится на http://www.FreeBSD.org/ru/platforms/[странице], посвящённой платформам.

==== Поддерживает ли FreeBSD многопроцессорные системы (SMP)?

FreeBSD поддерживает симметричное мультипроцессирование (SMP) на всех невстраиваемых платформах (например, i386, amd64 и так далее). SMP также поддерживается для arm и MIPS, хотя некоторые процессоры могут это не поддерживать. В реализации SMP во FreeBSD используется мелкодисперсная синхронизация, и производительность масштабируется почти линейно с ростом количества процессоров.

За подробной информацией обращайтесь к странице Справочника man:smp[4].

==== Что такое микрокод? Как установить обновления микрокода для процессоров Intel(R)?

Микрокод - это программа, реализующая набор инструкций процессора на аппаратном уровне. Она позволяет исправлять ошибки процессора без замены микросхемы.

Установите [.filename]#sysutils/devcpu-data#, а затем добавьте:

[.programlisting]
....
microcode_update_enable="YES"
....

в [.filename]#/etc/rc.conf#

[[compatibility-drives]]
=== Жёсткие диски, ленточные устройства и приводы CD и DVD

==== Какие типы винчестеров поддерживает FreeBSD?

FreeBSD работает с дисками стандартов EIDE, SATA, SCSI и SAS (с совместимыми контроллерами; смотрите следующий раздел), и всеми дисками, использующими оригинальный интерфейс "Western Digital" (MFM, RLL, ESDI и, конечно же, IDE). Некоторые контроллеры ESDI, использующие собственные интерфейсы, могут и не работать: к таким относятся WD1002/3/6/7 и их клоны.

==== Какие поддерживаются контроллеры SCSI или SAS?

Полный список приведён в Hardware Notes для FreeBSD link:{u-rel120-hardware}[{rel120-current}] или link:[{rel112-current}].

=== Какие типы стримеров поддерживаются?

FreeBSD поддерживает все стандартные интерфейсы стримеров SCSI.

==== Поддерживает ли FreeBSD роботов для смены лент?

FreeBSD поддерживает роботизированные устройства SCSI через устройство man:ch[4] и команду man:chio[1]. Подробная информация об управлении такими роботами находится на странице Справочника man:chio[1].

В то время как AMANDA и ещё ряд программных продуктов умеют работать с роботами, другие приложения могут только переносить ленты с одного места на другое. В этом случае надо отслеживать, в каком слоте находится нужная лента, и в какой слот нужно вернуть ленту, находящуюся в стримере.

==== Какие приводы CD-ROM и CD-RW поддерживаются во FreeBSD?

Поддерживаются любые SCSI-устройства чтения компакт дисков, подключенные к поддерживаемому контроллеру. Поддерживается большинство ATAPI-совместимых IDE CD-ROM.

FreeBSD поддерживает все ATAPI-совместимые IDE-приводы CD-R или CD-RW. Более полная информация находится на странице Справочника man:burncd[8].

FreeBSD поддерживает также все SCSI-приводы CD-R и CD-RW. Используйте команду `cdrecord` из пакета package:sysutils/cdrtools[].

[[compatibility-kbd-mice]]
=== Клавиатуры и мыши

[[moused]]
==== Можно ли использовать мышь вне X Window?

Стандартный драйвер консоли man:syscons[4] предоставляет возможность использования указателя мыши в текстовых консолях для выделения и переноса текста. Запустите демон мыши man:moused[8] и включите отображение указателя мыши в виртуальной консоли:

[source,bash]
....
# moused -p /dev/xxxx -t yyyy
# vidcontrol -m on
....

Здесь _xxxx_ - это имя устройства мыши, а _yyyy_ - тип протокола, используемого мышью. Даемон мыши может автоматически определять тип протокола большинства мышей, за исключением старых, работающих по последовательному интерфейсу. Для выполнения автоматического определения в качестве протокола укажите `auto`. Если автоматическое определение не работает, то обратитесь к справочным страницам по man:moused[8] для получения списка поддерживаемых типов протоколов.

Для мыши типа PS/2 добавьте строчку `moused_enable="YES"` в файл [.filename]#/etc/rc.conf# для запуска даемона мыши во время загрузки системы. Кроме того, для использования даемона мыши во всех виртуальных терминалах, а не только на консоли, добавьте `allscreens_flags="-m on"` в файле [.filename]#/etc/rc.conf#.

После запуска даемона мыши, доступ к мыши должен согласовываться между даемоном мыши и другими программами типа X Window. Обратитесь к вопросу из FAQ<<x-and-moused, Почему моя мышь не работает с X?>> для получения более полной информации по этому вопросу.

==== Как можно вырезать и копировать текст с помощью мыши в текстовой консоли?

Удалить данные с помощью мыши нельзя. Однако их можно скопировать и вставить. После запуска даемона мыши, как описано в ответе на <<moused,предыдущий вопрос>>, нажмите кнопку 1 (левую) и двигайте мышь для выделения текста. Затем нажмите кнопку 2 (среднюю) для его вставки с позиции текстового курсора. Нажатие кнопки 3 (правой) "расширит" выбранную текстовую область.

Если у вашей мыши отсутствует средняя кнопка, её можно сэмулировать либо переназначить кнопки опциями даемона мыши. Обратитесь к справочным страницам по man:moused[8] для получения полной информации.

==== У моей мыши есть дополнительные колёсико и кнопочки. Можно ли их использовать во FreeBSD?

Ответ, к сожалению, "в зависимости от обстоятельств". Эти мышки с дополнительными возможностями, как правило, требуют наличия специальных драйверов. До тех пор, пока драйвер мыши или прикладная программа не будут иметь отдельную поддержку такой мыши, она будет работать как стандартная двух- или трёхкнопочная мышь.

Возможные способы использования колёсиков мыши при работе в X Window описаны в <<x-and-wheel,другом разделе>>.

==== Как использовать клавишу delete в sh и csh?

Для Bourne Shell добавьте следующие строки в [.filename]#~/.shrc#. Смотрите man:sh[1] и man:editrc[5].

[.programlisting]
....
bind ^? ed-delete-next-char # для консоли
bind ^[[3~ ed-delete-next-char # для xterm
....

Для C Shell добавьте следующие строки в [.filename]#~/.cshrc#. Смотрите man:csh[1].

[.programlisting]
....
bindkey ^? delete-char # для консоли
bindkey ^[[3~ delete-char # для xterm
....

За дополнительной информацией обращайтесь к http://www.ibb.net/~anne/keyboard.html[этой странице].

[[compatibility-other]]
=== Другое оборудование

==== Есть ли решение проблемы отсутствия звука при использовании звуковых адаптеров man:pcm[4]?

Некоторые звуковые адаптеры при каждой загрузке сбрасывают уровень громкости в 0. Выполняйте следующую команду при каждой загрузке машины:

[source,bash]
....
# mixer pcm 100 vol 100 cd 100
....

==== Поддерживает ли FreeBSD управление энергосбережением на лэптопах?

FreeBSD поддерживает функции ACPI, реализованные в современном оборудовании. Дополнительная информация находится на странице Справочника man:acpi[4].

== Устранение некоторых проблем

=== Почему FreeBSD определяет неправильное количество памяти на аппаратуре i386(TM)?

Наиболее вероятная причина заключается в различии между адресами физической и виртуальной памяти.

Существующее соглашение для большинства оборудования ПК заключается в использовании пространства памяти, лежащей в диапазоне между 3.5 ГБ и 4 ГБ для специальных нужд (обычно для нужд PCI). Это пространство адресов используется для доступа к PCI оборудованию. Как результат, реальная физическая память не может быть получена в данном адресном пространстве.

Какие действия выполняются с памятью в данном регионе, зависит от оборудования. К сожалению, некоторое оборудование ничего не выполняет и возможность использовать эти 500 МБ ОЗУ полностью потеряна.

К счастью, большинство оборудования перераспределяет память к более верхней позиции, так что она всё ещё может использоваться. Тем не менее, это может вызвать некоторое замешательство при просмотре сообщений, выдаваемых при загрузке.

На 32-битной версии FreeBSD кажется, что эта память потерялась, поскольку она переназначится в диапазон выше 4 ГБ, который не доступен для 32 битного ядра. В данном случае, решение заключается в сборке ядра с PAE. За дополнительной информацией обращайтесь к статье об ограничениях памяти.

На 64nbsp;битной версии FreeBSD или в случае использования ядра с включённым PAE FreeBSD корректно определит и перераспределит память, так, что она станет годной к использованию. Тем не менее, во время загрузки может показаться, что FreeBSD определяет больше памяти, чем реально имеется в системе из-за описанного перераспределения. Это нормально, и информация о доступной памяти будет скорректирована по окончанию процесса загрузки.

=== Программы аварийно завершают работу с ошибкой Signal 11.

Ошибки выполнения, связанные с сигналом 11, происходят, когда процесс пытается обратиться к области памяти, доступ к которой ему не был дан операционной системой. Если что-то подобное происходит в случайные, казалось бы, промежутки времени, следует начать поиск причины.

Эти проблемы могут быть классифицированы следующим образом:

. Если проблема возникает только в определённом самостоятельно разработанном приложении, то скорее всего это ошибка в коде.
. Если это проблема в части базового комплекта системы FreeBSD, то это тоже может быть ошибка в программном коде, хотя в большинстве случаев такие проблемы обнаруживаются и ошибки исправляются задолго до того, как обычным читателям FAQ доводится использовать этот код (именно для этого предназначена версия -CURRENT).

Вероятно, это не связано с ошибкой во FreeBSD, если проблема проявляется при компиляции программы, и при этом ошибка компилятора каждый раз разная.

Например, если запуск `make buildworld` завершился неудачей при попытке компиляции [.filename]#ls.c# в [.filename]#ls.o# и при повторном запуске компиляция снова прервалась на том же месте, то это ошибка процесса построения. Обновите исходные тексты и попробуйте снова. Если же компиляция прерывается в каком-то другом месте, то причина наиболее вероятно кроется в оборудовании.

В первом случае воспользуйтесь отладчиком, к примеру, man:gdb[1], для нахождения точки программы, в которой делается попытка доступа к неверному адресу, и исправьте эту ошибку.

Во втором случае проверьте, какой компонент вашего оборудования неисправен.

Среди часто приводящих к этому причин:

. Диски могут перегреваться. Проверьте работу вентиляторов.
. Процессор перегревается. Это может произойти при разгоне процессора или при поломке процессорного вентилятора. В любом из вариантов убедитесь, что ваше оборудование работает так, как ему положено по крайней мере на момент поиска причин неисправности. В противном случае сбросьте частоту на настройки по умолчанию.
+ 
Что касается разгона, дешевле обходится медленная система, чем сгоревшая система, требующая замены! Также общественность не симпатизирует проблемам на таких системах.
. Хитроумная память. Если установлены различные микросхемы SIMM/DIMM, вытащите их все и попробуйте по одной до локализации проблемы в проблематичной микросхеме DIMM/SIMM, либо их комбинации.
. Чересчур оптимистичные настройки материнской платы. Настройки BIOS и перемычки на материнской плате предоставляют возможность задавать различные частоты и задержки. Часто бывает достаточно настроек по умолчанию, но иногда установка слишком малых периодов ожидания для ОЗУ или установка параметра "RAM Speed: Turbo" вызывает странное поведение. Возможным решением может стать установка параметров BIOS по умолчанию с предварительной записью текущих значений.
. Неустойчивое или недостаточное электропитание материнской платы. Уберите неиспользуемые адаптеры ввода/вывода, винчестеры и приводы компакт-дисков или отключите их от кабеля электропитания для проверки, что блок питания может работать с меньшей нагрузкой. Или попробуйте воспользоваться другим блоком питания, желательно большей мощности. Например, если имеющийся блок питания рассчитан на 250 Ватт, попробуйте другой мощностью 300 Ватт).

Прочитайте раздел про <<signal11,Signal 11>> для дальнейшего объяснения и обсуждения, как аппаратура или программное обеспечение для тестирования памяти могут пропускать сбойную память. Подробная информация по этому вопросу содержится в http://www.bitwizard.nl/sig11/[FAQ по проблеме SIG11].

Наконец, если ничего не помогает, то, возможно, это из-за ошибки во FreeBSD. Следуйте <<access-pr,этим инструкциям>> для отправки сообщения о проблеме.

=== Моя система аварийно завершает работу с сообщениями Fatal trap 12: page fault in kernel mode либо panic:, и выдаёт много дополнительной информации. Что мне делать?

Разработчики FreeBSD интересуются такими ошибками, но им нужно больше информации, чем просто текст ошибки. Скопируйте весь текст сообщения. Затем обратитесь к разделу FAQ об <<kernel-panic-troubleshooting,аварийных завершениях работы ядра>>, постройте отладочное ядро и получите трассу вызовов. Это может звучать трудной задачей, зато не требует навыков программирования. Просто следуйте указаниям.

=== Что означает сообщение об ошибке maxproc limit exceeded by uid %i, please see tuning(7) and login.conf(5)?

Ядро FreeBSD позволяет одновременно существовать ограниченному числу процессов. Это зависит от значения переменной man:sysctl[8] `kern.maxusers`. `kern.maxusers` также влияет на другие ограничения ядра, такие как буферы работы с сетью. Если система сильно загружена, поднимите `kern.maxusers`. Кроме максимального числа процессов это также увеличит значения других параметров, ограничивающих систему.

Для корректировки значения `kern.maxusers` обратитесь к разделу link:{handbook}#kern-maxfiles[ Ограничения файлов/процессов] Руководства. В нём говорится об открытых файлах, но те же ограничения касаются процессов.

Если система загружена слабо, но в ней запущено слишком много процессов, поправьте параметр `kern.maxproc`, определив его значение в [.filename]#/boot/loader.conf#. Изменение не вступит в силу до перезагрузки системы. За дополнительной информацией, касающейся настройки параметров, обращайтесь к странице Справочника man:loader.conf[5]. Если эти процессы запущены одним и тем же пользователем, поправьте значение `kern.maxprocperuid`, чтобы оно было на единицу меньше, чем новое значение `kern.maxproc`. Оно должно быть меньше по крайней мере на единицу, потому что системная программа man:init[8] должна работать всегда.

=== Полноэкранные приложения на удалённой машине работают неправильно!

На удалённой машине тип терминала может отличаться от `xterm`, который требуется для использования консоли FreeBSD. Либо же ядро может иметь неправильные значения ширины и высоты терминала.

Проверьте, чтобы переменная окружения `TERM` имела значение `xterm`. Если удалённая машина его не поддерживает, попробуйте `vt100`.

Запустите `stty -a`, чтобы узнать, какие размеры терминала заданы в ядре. Если значения неправильные, их можно поменять командой `stty rows _RR_ cols _CC_`.

Либо же, если на клиентской машине установлен package:x11/xterm[], запуск `resize` позволит узнать у терминала правильные размеры и применить эти значения.

=== Почему подключение через ssh или telnet к моему компьютеру занимает так долго времени?

Симптом: между моментом установления TCP-соединения и выдачей клиентским программным обеспечением запроса на ввод пароля (или, в случае использования man:telnet[1], выдачей приглашения на вход) проходит большой промежуток времени.

Проблема: скорее всего, задержка вызвана программным обеспечением на стороне сервера, которое пытается преобразовать IP-адрес клиента в имя хоста. Многие серверы, включая Telnet и SSH, поставляемые с FreeBSD, делают это для того, чтобы, кроме всего прочего, записать имя хоста в файле журнала для справки администратора.

Лечение: Если проблема возникает при подключении клиента к любому серверу, то причина в клиенте. Если проблема возникает только при чьей-либо попытке подключиться к серверу, то проблема в сервере.

Если проблема с клиентом, то единственным методом ее решения является исправление DNS, чтобы сервер смог распознать вашу машину. Если это происходит в локальной сети, то предположите, что это проблема с сервером, и продолжайте чтение. Если это происходит в сети Интернет, обратитесь к вашему провайдеру.

Если проблема с сервером в локальной сети, настройте сервер для разрешения запросов на преобразование адреса в имя хоста в диапазоне локальных адресов. Обратитесь к страницам Справочника по man:hosts[5] и man:named[8] для получения более подробной информации. Если это происходит в сети Интернет, то проблема может заключаться в некорректной работе ресолвера локального сервера. Для проверки попробуйте получить адрес другого хоста, такого как `www.yahoo.com`. Если это не работает, то в этом и состоит проблема.

Из-за свежей установки FreeBSD, также возможно, что информация о домене и сервере имён отсутствует в [.filename]#/etc/resolv.conf#. Это часто будет вызывать задержку в работе SSH, так как опция `UseDNS` по умолчанию установлена в значение `yes` в [.filename]#/etc/ssh/sshd_config#. Если именно это является причиной проблемы, то добавьте недостающую информацию в [.filename]#/etc/resolv.conf#, либо в качестве временной меры установите `UseDNS` в `no` в файле [.filename]#sshd_config#.

=== Почему в man:dmesg[8] регулярно выводятся сообщения file: table is full?

Такое сообщение об ошибке сигнализирует о том, что в системе закончились доступные файловые дескрипторы. Обратитесь к разделу link:{handbook}#kern-maxfiles[ kern.maxfiles] главы о link:{handbook}#configtuning-kernel-limits/[ Настройке ограничений ядра] Руководства для выяснения всех подробностей и устранения этой проблемы.

=== Почему часы на моем компьютере показывают неправильное время?

На компьютере установлено по меньшей мере два таймера, и FreeBSD выбрала не тот.

Запустите man:dmesg[8] и посмотрите строки, содержащие слово `Timecounter`. FreeBSD выбирает таймер с наибольшим значением качества.

[source,bash]
....
# dmesg | grep Timecounter
Timecounter "i8254" frequency 1193182 Hz quality 0
Timecounter "ACPI-fast" frequency 3579545 Hz quality 1000
Timecounter "TSC" frequency 2998570050 Hz quality 800
Timecounters tick every 1.000 msec
....

Удостоверьтесь в этом, проверив man:sysctl[3]-переменную `kern.timecounter.hardware`.

[source,bash]
....
# sysctl kern.timecounter.hardware
kern.timecounter.hardware: ACPI-fast
....

Это может быть неработающий таймер ACPI. Самым простым решением будет отключить таймер ACPI в [.filename]#/boot/loader.conf#:

[.programlisting]
....
debug.acpi.disabled="timer"
....

Либо же BIOS может изменить частоту TSC-может, для изменения скорости работы процессора при работе от батареек или переводя в режим пониженного электропитания, но FreeBSD не отслеживает это и в результате часы начинают спешить или отставать.

В этом примере имеется также и таймер `i8254`, и он может быть выбран записью его имени в man:sysctl[3]-переменную `kern.timecounter.hardware`.

[source,bash]
....
# sysctl kern.timecounter.hardware=i8254
kern.timecounter.hardware: TSC -> i8254
....

Теперь компьютер должен аккуратнее следить за временем.

Чтобы это изменение вступало в силу во время загрузки системы, добавьте в файл [.filename]#/etc/sysctl.conf# такую строчку:

[.programlisting]
....
kern.timecounter.hardware=i8254
....

=== Что означает сообщение swap_pager: indefinite wait buffer:?

Это значит, что процесс пытается сбросить страницу памяти на диск, и попытка сделать это оканчивается неудачно в течение более 20 секунд. Это может быть вызвано испорченными блоками на диске, кабелями, подключением или другим оборудованием ввода/вывода. Если диск сам по себе испорчен, вы также увидите ошибки работы с диском в [.filename]#/var/log/messages# и в выводе `dmesg`. В противном случае проверьте кабели и подключения.

=== Что означают сообщения lock order reversal?

Ядро FreeBSD использует несколько блокировок для арбитража доступа к соответствующим ресурсам. Когда несколько потоков в ядре пытаются захватить несколько блокировок подряд, всегда существует возможность появления мёртвой блокировки (deadlock), где два потока захватили по одной блокировке и заблокированы в ожидании освобождения другим потоком второй блокировки. Такой проблемы синхронизации можно избежать, если все потоки захватывают блокировки в одинаковом порядке.

Система диагностирования блокировок man:witness[4], которая по умолчанию включена во FreeBSD-CURRENT и выключена для стабильных веток и релизов, определяет возможность появления мёртвых блокировок из-за ошибок их использования, включая захват нескольких блокировок в различном порядке в разных частях ядра. Инфраструктура man:witness[4] пытается обнаруживать эту проблему по мере её появления и сообщает о ней на системную консоль в сообщении `lock order reversal` (которое также часто называют LOR).

В силу консервативности man:witness[4] возможны ложные срабатывания. При правильном срабатывании такое сообщение _не_ означает, что система находится в состоянии мёртвой блокировки; его следует рассматривать как предупреждение о том, что в этом месте могла бы произойти мёртвая блокировка.

[NOTE]
====
Плохие LOR обычно быстро исправляют, поэтому перед написанием сообщения в списки рассылки следует проверить архивы link:{freebsd-current}.
====

=== Что означают сообщения Called ... with the following non-sleepable locks held?

Это означает, что функция, которая может находиться в "спящем" состоянии была вызвана во время использования мьютекс (или другого не "засыпающего") блокирования.

Причина этого - ошибка, потому что мьютексы не предполагают находиться в удерживаемом состоянии длительные промежутки времени, а блокировать только на короткие периоды синхронизации. Это правило позволяет драйверам устройств использовать мьютексы для синхронизации с остальной частью ядра во время прерываний. Прерывания (во FreeBSD) могут находиться не в "спящем состоянии". Следовательно необходимо, чтобы не было подсистем в ядре, которые бы занимались блокировкой длительный период, используя мьютекс.

Для нахождения таких ошибок в ядро могут быть добавлены assertions, которые будут взаимодействовать с подсистемой man:witness[4] для генерирования предупреждения или фатальной ошибки (в зависимости от системной конфигурации) в случаях когда производится потенциально блокирующий вызов с удержанием мьютекса.

В общем, такие предупреждения не критичны, но тем не менее, с неудачной синхронизацией (timing) они могут вызвать нежелательные эффекты, начиная от незначительной задержки в ответной реакции системы до полной блокировки системы.

Дополнительная информация о синхронизации во FreeBSD находится на странице Справочника man:locking[9].

=== Почему процесс buildworld/installworld завершается с сообщением touch: not found?

Эта ошибка не означает, что не найдена утилита man:touch[1]. Ошибка наверняка появляется из-за того, что даты модификации файлов установлены в будущем. Если CMOS часы установлены на локальное время, отрегулируйте часовой механизм ядра, запустив команду `adjkerntz -i` в однопользовательском режиме.

== Прикладные программы

=== Где находятся все прикладные программы?

Обратитесь на link:https://www.FreeBSD.org/ports/[страницу портов], содержащую информацию о программных продуктах, перенесённых во FreeBSD. На данный момент в этом списке находится более {numports} приложений и он ежедневно увеличивается, так что почаще туда заглядывайте или подпишитесь на {freebsd-announce}, в котором публикуется информация о появлении новых приложений.

Большинство портов должно нормально работать во всех поддерживаемых версиях FreeBSD. Неработающие порты специально помечаются соответствующим образом. При выходе нового релиза FreeBSD в него в каталог [.filename]#ports/# включается актуальная на момент выхода Коллекция Портов.

FreeBSD умеет работать со сжатыми двоичными пакетами для упрощения установки и удаления портов. Используйте man:pkg[7] для управления процессом установки пакетов.

=== Как загрузить дерево Портов? Следует ли использовать SVN?

Любым из указанных способов:

* Используйте portsnap в большинстве случаев. Обратитесь к разделу link:{handbook}#ports-using/[Использование Коллекции Портов] для получения инструкций по использованию этого инструмента.
* Используйте SVN, если нужны собственные патчи для дерева портов. Обратитесь к разделу link:{handbook}#svn/[Использование Subversion] для получения дополнительной информации.
* Используйте CTM как это описано в разделе link:{handbook}#ctm/[Использование CTM] для получения изменений по почте при нестабильном соединении.

=== Поддерживает ли FreeBSD среду Java(TM)?

Да. Для получения дополнительной информации посетите страницу link:https://www.FreeBSD.org/java/[http://www.FreeBSD.org/java/].

=== Почему этот порт не компилируется на моей машине с {rel2-relx} - или {rel-relx} -STABLE?

Если установленная версия FreeBSD, значительно отстаёт от _-CURRENT_ или _-STABLE_, обновите Коллекцию Портов с использованием указаний в разделе link:{handbook}#ports-using/[Использование Коллекции Портов]. Если система в актуальном состоянии, значит кто-то мог внести изменение в порт, с которым он работает в _-CURRENT_, но не работает в _-STABLE_. https://bugs.FreeBSD.org/submit/[Пошлите] сообщение об ошибке, так как Коллекция Портов должна работать как в _-CURRENT_, так и в ветках _-STABLE_.

=== Я попытался сформировать файл INDEX командой make index, однако попытка окончилась неудачей. Почему?

Первым делом убедитесь, что Коллекция Портов находится в актуальном состоянии. Ошибки, которые отражаются на построении файла [.filename]#INDEX# из актуальной копии Коллекции Портов, бросаются в глаза и поэтому практически всегда исправляются немедленно.

В редких случаях [.filename]#INDEX# не перестраивается из-за странных комбинаций значений переменных `WITH__*_` или `WITHOUT__*_`, заданных в файле [.filename]#make.conf#. Если вы думаете, что это ваш случай, прежде чем сообщать об этом в {freebsd-ports}, попытайтесь сформировать [.filename]#INDEX# с отключенными значениями этих переменных.

=== Я обновил исходные тексты. Как теперь обновить установленные порты?

С FreeBSD не поставляется инструмент обновления портов, но есть несколько инструментов, немного облегчающих этот процесс. Кроме того, для упрощения работы с портами доступны дополнительные инструменты; смотрите раздел Руководства FreeBSD link:{handbook}#ports-using/[Использование Коллекции Портов].

=== Нужно ли мне перекомпилировать все порты каждый раз, когда я выполняю мажорное обновление (со сменой старшей версии FreeBSD)?

Да! На свежеобновленной системе программное обеспечение, скомпилированное под более старый релиз, будет по прежнему работать, но только до тех пор, пока вы не начнете устанавливать другие порты или обновлять существующие.

Когда система обновлена, различные совместно используемые библиотеки, загружаемые модули и другие части системы замещаются более новыми версиями. Приложения, скомпонованные с более старыми версиями, могут перестать запускаться либо начнут функционировать неправильно.

Для получения дополнительной информации обращайтесь к link:{handbook.en}#freebsdupdate-upgrade[разделу, посвящённому обновлениям,] руководства FreeBSD.

=== Нужно ли мне перекомпилировать все порты каждый раз, когда я выполняю минорное обновление (без изменения старшей версии FreeBSD)?

В общем случае, нет. Разработчики FreeBSD делают всё возможное для сохранения двоичной совместимости между всеми релизами в пределах одной старшей версии. Любые исключения из этого правила документируются в "Примечаниях к релизу", и там же даются советы, которых следует придерживаться.

=== Почему возможности /bin/sh так малы? Почему бы во FreeBSD не использовать bash или какой-либо другой командный процессор?

Многим требуется, чтобы разрабатываемые скрипты для командного процессора были переносимы между многими системами. Именно поэтому в POSIX(R) очень подробно описан командный процессор и набор утилит. Большинство скриптов пишутся на языке процессора Bourne shell (man:sh[1]), к тому же некоторые важные программные вызовы (man:make[1], man:system[3], man:popen[3] и их аналоги на языках скриптов высокого уровня, таких как Perl или Tcl) предполагают для интерпретации команд использование именно Bourne shell. Так как Bourne shell используется столь широко и часто, то очень важно, чтобы он стартовал очень быстро, его поведение было строго регламентировано и при этом потребности в оперативной памяти были малы.

В имеющейся реализации мы приложили максимум усилий для воплощения в жизнь всех этих требований одновременно. Для того, чтобы сохранить `/bin/sh` небольшим по размеру, мы не включили многие из обычных возможностей, которые имеются в других командных процессорах. Для этого имеются в наличии командные процессоры, обладающие гораздо большими возможностями, такие как `bash`, `scsh`, man:tcsh[1] и `zsh`. Сравните использование памяти этими оболочками, посмотрев в колонки "VSZ" и "RSS" вывода команды `ps -u`.

=== Как создать аудио-CD из файлов MIDI?

Для создания аудио-CD из MIDI-файлов сначала установите из портов программу package:audio/timidity[], затем установите набор патчей GUS от Эрика Уэлша (Eric A. Welsh), доступный по адресу http://alleg.sourceforge.net/digmid.html[http://alleg.sourceforge.net/digmid.html]. После корректной установки TiMidity++ MIDI-файлы могут быть преобразованы в WAV-файлы следующей командой:

[source,bash]
....
% timidity -Ow -s 44100 -o /tmp/juke/01.wav 01.mid
....

WAV-файлы затем могут быть преобразованы в другие форматы или записаны как аудио-CD, что описано в link:{handbook}#creating-cds/[Руководстве FreeBSD].

== Конфигурирование ядра

[[make-kernel]]
=== Я хочу изменить настройки ядра. Это сложно?

Вовсе нет! Обратитесь к link:{handbook}#kernelconfig/[соответствующему разделу] Руководства, который посвящён этому вопросу.

[NOTE]
====
Новый файл [.filename]#kernel# будет установлен в каталог [.filename]#/boot/kernel# вместе со своими модулями, а старое ядро и его модули будут сдвинуты в каталог [.filename]#/boot/kernel.old#. Если сделана ошибка в конфигурации, просто загрузите предыдущую версию ядра.
====

=== Почему моё ядро такое большое?

Конфигурация ядра `GENERIC`, которая содержится в дистрибутиве FreeBSD, компилируется в _отладочном режиме_. В таком режиме ядра содержат много символьной информации в разных файлах, которая используется для отладки и сильно увеличивает размер [.filename]#/boot/kernel/#. Заметьте, что уменьшения производительности при использовании отладочного ядра нет или оно незначительно, однако отладочное ядро полезно иметь под рукой на случай аварийного завершения работы системы.

Однако при нехватке дискового пространства существует несколько вариантов уменьшения размера [.filename]#>/boot/kernel/#.

Чтобы не устанавливать файлы с символьной информацией, убедитесь в наличии следующей строки в [.filename]#/etc/src.conf#:

[.programlisting]
....
WITHOUT_KERNEL_SYMBOLS=yes
....

Для получения дополнительной информации смотрите страницу Справочника man:src.conf[5].

Если вы не хотите компилировать отладочное ядро, убедитесь в выполнении следующих условий:

* В конфигурационном файле ядра нет такой строчки:
+
[.programlisting]
....
makeoptions DEBUG=-g
....

* Вы не запускали утилиту man:config[8] с опцией `-g`.

В любой из вышеописанных ситуаций ядро будет построено с отладочным режимом.

Чтобы скомпилировать и установить только нужные модули, укажите их в [.filename]#/etc/make.conf#:

[.programlisting]
....
MODULES_OVERRIDE= accf_http ipfw
....

Замените _accf_httpd ipfw_ на нужный список модулей. Это уменьшит размер каталога с ядром, а также время сборки. Для получения дополнительной информации почитайте [.filename]#/usr/shared/examples/etc/make.conf#. 

Для дальнейшего уменьшения размера также можно удалить ненужные устройства из ядра. Для получения дополнительной информации смотрите <<make-kernel>>.

Для вступления любого из этих действий в силу следуйте указаниям по link:{handbook}#kernelconfig-building/[сборке и установке] нового ядра.

Большинство ядер ([.filename]#/boot/kernel/kernel#), как правило, занимают от 12 до 16 Мбайт.

=== Почему мне не удаётся откомпилировать ни один вариант ядра, даже GENERIC?

Есть несколько причин, приводящих к возникновению этой проблемы:

* Дерево исходных текстов отличается от того, что использовалось для построения работающей в данный момент системы. Перед обновлением прочитайте файл [.filename]#/usr/src/UPDATING#, обращая особое внимание на раздел "COMMON ITEMS" в его конце.
* Команда `make buildkernel` не завершилась успешно. Корректное выполнение цели `make buildkernel` зависит от файлов, полученных после выполнения `make buildworld`.
* Даже при построении <<stable,FreeBSD-STABLE>> возможно, что дерево исходных текстов было загружено в тот момент, когда оно модифицировалось или было неработоспособно. Построение гарантируется только для релизов, хотя в большинстве случаев <<stable,FreeBSD-STABLE>> строится без проблем. Попробуйте сгрузить дерево исходных текстов повторно и посмотрите, разрешилась ли проблема. Если с сервером есть проблемы, попробуйте другое зеркало.

=== Какой планировщик используется в работающей системе?

Название используемого планировщика доступно напрямую в виде значения sysctl-параметра `kern.sched.name`:

[source,bash]
....
% sysctl kern.sched.name
kern.sched.name: ULE
....

=== Что такое kern.sched.quantum?

`kern.sched.quantum` определяет максимальное количество тактов, которое процесс может выполняться, не будучи прерванным.

== Диски, файловые системы и начальные загрузчики

=== Как добавить в систему новый диск?

Обратитесь к разделу link:{handbook}#disks-adding/[Добавление дисков] Руководства FreeBSD.

=== Как перенести систему на большой новый диск?

Самый лучший способ заключается в переустановке операционной системы на новый диск с последующим переносом пользовательских данных. Это настоятельно рекомендуется при отслеживании ветки _-STABLE_ в течение более одного релиза или при обновлении релиза вместо установки нового. Установите booteasy на оба диска с помощью man:boot0cfg[8] и выполняйте загрузку с любого из них, пока не будете довольны новой конфигурацией. Пропустите следующий абзац, чтобы перейти к вопросу переноса данных после этой операции.

Либо разбейте на разделы и разметьте новый диск с помощью man:sade[8] или man:gpart[8]. Если диски отформатированы в MBR, то booteasy можно установить на оба диска с помощью man:boot0cfg[8] для того, чтобы иметь возможность выполнять загрузку как старой, так и новой системы после выполнения копирования.

После подготовки диска данные нельзя просто так взять и перенести. Используйте для этого инструменты, которые учитывают файлы устройств и системные флаги, например, man:dump[8]. И хотя рекомендуется выполнять перенос данных в однопользовательском режиме, это не является обязательным условием.

Если на дисках стоит UFS, никогда не используйте ничего, кроме man:dump[8] и man:restore[8] для переноса корневой файловой системы. Эти команды также следует использовать при переносе отдельного раздела на другой пустой раздел. Последовательность шагов при использовании `dump` для переноса данных с раздела UFS на новый раздел:

[.procedure]
====
. выполните команду `newfs` над новым разделом.
. командой `mount` смонтируйте его во временный каталог.
. командой `cd` перейдите в этот каталог.
. выполните команду `dump` над старым разделом, направив вывод в новый раздел.
====

Например, чтобы перенести корневую файловую систему на устройство [.filename]#/dev/ada1s1a# с использованием каталога [.filename]#/mnt# в качестве временной точки монтирования, наберите:

[source,bash]
....
# newfs /dev/ad1as1a
# mount /dev/ad1as1a /mnt
# cd /mnt
# dump 0af - / | restore rf -
....

Переразбиение разделов с использованием `dump` требует несколько больше усилий. Для объединения раздела типа [.filename]#/var# с его вышестоящим разделом, создайте новый раздел, достаточно большой для размещения их обоих, переместите вышестоящий раздел так, как это описано выше, а затем переместите нижестоящий раздел в пустой каталог, созданный при первом перемещении:

[source,bash]
....
# newfs /dev/ada1s1a
# mount /dev/ad1as1a /mnt
# cd /mnt
# dump 0af - / | restore rf -
# cd var
# dump 0af - /var | restore rf -
....

Для отделения каталога от вышестоящего, скажем, для размещения [.filename]#/var# в собственном разделе, которого не было, создайте оба раздела, затем смонтируйте нижестоящий раздел в подходящий каталог во временную точку монтирования, а затем переместите старый единый раздел:

[source,bash]
....
# newfs /dev/ada1s1a
# newfs /dev/ada1s1d
# mount /dev/ada1s1a /mnt
# mkdir /mnt/var
# mount /dev/ada1s1d /mnt/var
# cd /mnt
# dump 0af - / | restore rf -
....

Для перемещения пользовательских данных также имеются программы man:cpio[1] и man:pax[1]. Известно, что они теряют информацию о флагах файлов, так что используйте их с осторожностью.

=== На каких разделах можно без опаски использовать механизм Soft Updates? Я слышал, что использование Soft Updates на / могут приводить к проблемам. Что насчёт журналируемых Soft Updates?

Краткий ответ: обычно Soft Updates можно использовать без опаски на всех разделах.

Подробный ответ: Soft Updates имеют две характеристики, которые могут быть нежелательны на некоторых разделах. Во-первых, раздел с Soft Updates имеет небольшой шанс потери данных по время аварийного останова системы. Раздел не будет попорчен, поскольку данные будет просто потеряны. Во-вторых, Soft Updates могут приводить к временной нехватке дискового пространства.

При использовании Soft Updates ядро может задерживать до тридцати секунд запись изменений на физический диск. При удалении большого файла он остается на диске, пока ядро не выполнит фактическое удаление. Это может привести к очень простой гонке. Предположим, удаляется один большой файл и тут же создаётся другой большой файл. Первый файл на самом деле ещё не удалён с диска, поэтому для второго файла на диске может не хватить места. Это приведёт к ошибке о том, что на разделе нет достаточного пространства, несмотря на то, что только что освободилось много места. Через пару секунд создание файла сработает, как и ожидалось.

Если система может аварийно остановиться после того, как ядро примет набор данных для записи на диск, но перед тем, как данные реально запишутся, то данные могут потеряться. Такой риск чрезвычайно мал, но в целом управляем.

Эти проблемы влияют на все разделы, использующие Soft Updates. Итак, что это означает для корневого раздела?

Жизненно важная информация на корневом разделе меняется очень редко. Если в системе произойдет сбой в период тридцатисекундного окна после выполнения такого изменения, возможно, что данные окажутся потерянными. Этот риск незначителен для большинства применений, но его нужно учитывать. Если система не может принять такой риск, не используйте Soft Updates с корневой файловой системой!

[.filename]#/# традиционно является одним из самых маленьких разделов. Если каталог [.filename]#/tmp# размещён в [.filename]#/# и у вас заполнен [.filename]#/tmp#, то могут периодически возникать проблемы с дисковым пространством. Создание символической ссылки [.filename]#/tmp#, указывающей на [.filename]#/var/tmp# решит эту проблему.

В заключение, man:dump[8] не работает в режиме реального времени (-L) с файловой системой, для которой включены журналируемые Soft Updates (SU+J).

=== Можно ли смонтировать другие файловые системы?

FreeBSD поддерживает ряд других файловых систем.

UFS::
Компакт-диски с файловой системой UFS могут быть смонтированы без всяких проблем. Монтирование файловых систем Digital UNIX или других систем, поддерживающих UFS, может быть более сложным, в зависимости от особенностей разбиения диска конкретной операционной системой.

ext2/ext3::
FreeBSD поддерживает разделы `ext2fs` и `ext3fs`. За дополнительной информацией обратитесь к странице Справочника man:ext2fs[5].

NTFS::
Поддержка NTFS через FUSE доступна через порт package:sysutils/fusefs-ntfs[]. Для получения более полной информации смотрите документацию к http://www.tuxera.com/community/ntfs-3g-manual/[ntfs-3g].

FAT::
Во FreeBSD имеется драйвер для работы с FAT в режиме чтения-записи. Для получения дополнительной информации обратитесь к странице справочника man:mount_msdosfs[8].

ZFS::
FreeBSD включает в себя портированную из Sun(TM) реализацию файловой системы ZFS. В настоящее время рекомендуется использовать её только на платформе amd64 с достаточным объемом памяти. Для получения более полной информации обратитесь к странице Справочника man:zfs[8].

FreeBSD включает сетевую файловую систему NFS. В Коллекции портов FreeBSD имеется несколько приложений FUSE для поддержки многих других файловых систем.

=== Как смонтировать вторичный раздел DOS?

Вторичные разделы DOS находятся после _всех_ первичных разделов. Например, если "E" является вторым разделом DOS на втором диске SCSI, то здесь будет файл устройства для пятого "слайса" в каталоге [.filename]#/dev#. Чтобы смонтировать:

[source,bash]
....
# mount -t msdosfs /dev/da1s5 /dos/e
....

=== Существует ли криптографическая файловая система для FreeBSD?

Да, man:gbde[8] и man:geli[8]. Смотрите раздел link:{handbook}#disks-encrypting/[Шифрование дисковых разделов] Руководства FreeBSD.

=== Как загрузить FreeBSD и Linux(R) с помощью GRUB?

Для загрузки FreeBSD с использованием GRUB добавьте следующие строки в [.filename]#/boot/grub/menu.lst# или [.filename]#/boot/grub/grub.conf#, в зависимости от используемого дистрибутива Linux(R).

[.programlisting]
....
title FreeBSD 9.1
root (hd0,a)
kernel /boot/loader
....

Где _hd0,a_ указывает на корневой раздел на первом диске. Чтобы указать номер слайса, напишите что-то вроде _(hd0,2,a)_. По умолчанию, если номер слайса не указан, GRUB ищет первый слайс c разделом `a`.

=== Как загрузить FreeBSD и Linux(R) с помощью BootEasy?

Установите LILO в начало загрузочного раздела Linux(R), а не в Master Boot Record. После этого LILO можно будет запустить LILO из BootEasy.

Это рекомендуется делать при одновременном использовании Windows(R) и Linux(R), чтобы упростить восстановление работоспособности Linux(R) в случае переустановки Windows(R).

=== Как сменить приглашение загрузчика с ??? на что-нибудь более значащее?

Этого нельзя сделать со стандартным загрузчиком, не переписав его. В категории [.filename]#sysutils# Коллекции Портов есть ряд других менеджеров загрузки.

=== Как использовать устройство для чтения сменных дисков?

Если у вас уже есть файловая система на устройстве, то используйте такую команду:

[source,bash]
....
# mount -t msdosfs /dev/da0s1 /mnt
....

Если это устройство будет использоваться только на системах FreeBSD, то разбейте его на разделы UFS или ZFS. Это обеспечит поддержку длинных имён файлов, увеличение производительности и надёжность. Если устройство будет использоваться с другими операционными системами, то лучше сделать более совместимый выбор, например, msdosfs.

[source,bash]
....
# dd if=/dev/zero of=/dev/da0 count=2
# gpart create -s GPT /dev/da0
# gpart add -t freebsd-ufs /dev/da0
....

Наконец, остаётся создать новую файловую систему:

[source,bash]
....
# newfs /dev/da0p1
....

и смонтировать её:

[source,bash]
....
# mount /dev/da0s1 /mnt
....

Хорошо ещё добавить строку в файл [.filename]#/etc/fstab# (прочтите справку по man:fstab[5]), чтобы в будущем можно было просто давать команду `mount /mnt`:

[.programlisting]
....
/dev/da0p1 /mnt ufs rw,noauto 0 0
....

=== При монтировании компакт-диска выдаётся сообщение Incorrect super block.

Необходимо указать тип монтируемого устройства. Это описано в в разделе Руководства link:{handbook}#creating-cds/#mounting-cd[Использование CD с данными].

=== При монтировании компакт-диска выдаётся сообщение Device not configured.

Обычно это означает, что в приводе нет компакт-диска либо устройство не обнаружено на шине. Обратитесь к разделу link:{handbook}#mounting-cd[Использование CD с данными] в Руководстве, где подробно обсуждается этот вопрос.

=== Когда я монтирую CD-ROM, все неанглийские символы в именах файлов выводятся как ?.

Скорее всего, на компакт-диске для хранения информации о файлах и каталогах используется расширение "Joliet". Это описано в разделе Руководства об link:{handbook}#mounting-cd[использовании CD с данными].

=== Записанный во FreeBSD CD не читается ни в какой другой операционной системой. Почему?

Это означает, что на CD был записан непосредственно необработанный файл без создания файловой системы ISO 9660. Прочтите раздел Руководства о link:{handbook}#rawdata-cd[записи данных непосредственно на компакт-диски].

=== Как создать образ CD с данными?

Это описано в разделе Руководства о link:{handbook}#imaging-cd[копировании CD с данными]. Более полную информацию о работе с компакт-дисками можно найти в разделе о link:{handbook}#creating-cds/[создании компакт-дисков] в главе Руководства об устройствах хранения данных.

=== Почему я не могу смонтировать (командой mount аудио CD?

Попытка смонтировать аудио CD приведёт к сообщению об ошибке вида: `cd9660: /dev/acd0c: Invalid argument`. Причина этого заключается в том, что команда `mount` работает только с файловыми системами. На аудио CD файловых систем нет; они содержат только данные. Используйте вместо этого программу, которая умеет читать аудио CD, например, порт package:audio/xmcd[].

=== Как выполнить mount для многосеансового CD?

По умолчанию man:mount[8] будет пытаться смонтировать последнюю дорожку (сеанс) CD с данными. Для загрузки более раннего сеанса используйте параметр командной строки `-s`. За конкретными примерами обращайтесь к странице Справочника man:mount_cd9660[8].

=== Как разрешить обычным пользователям монтировать компакт-диски, DVD, USB-диски и другие сменные носители?

Как пользователь `root`, установите системную переменную `vfs.usermount` в значение `1`.

[source,bash]
....
# sysctl vfs.usermount=1
....

Чтобы это срабатывало во время загрузки системы, добавьте строчку `vfs.usermount=1` в файл [.filename]#/etc/sysctl.conf#.

Пользователи могут монтировать только те устройства, к которым у них имеется доступ на чтение. Чтобы разрешить пользователям монтировать устройство, должны быть заданы разрешения в [.filename]#/etc/devfs.conf#.

Например, чтобы разрешить пользователям монтировать первое устройство USB, добавьте такую строчку:

[.programlisting]
....
# Allow all users to mount a USB drive.
	    own       /dev/da0       root:operator
	    perm      /dev/da0       0666
....

Теперь все пользователи могут монтировать устройства с правами доступа на чтение в собственные каталоги:

[source,bash]
....
% mkdir ~/my-mount-point
% mount -t msdosfs /dev/da0 ~/my-mount-point
....

Размонтирование устройства осуществляется просто:

[source,bash]
....
% umount ~/my-mount-point
....

Использование `vfs.usermount`, однако, имеет некоторые негативные стороны, связанные с вопросами безопасности. Более правильным способом работы с носителями в формате MS-DOS(R) является использование пакета package:emulators/mtools[] из Коллекции Портов.

[NOTE]
====
Имя устройства, использованное в предыдущих примерах, должно быть изменено в соответствии с конфигурацией.
====

=== Команды du и df показывают разный объем доступного дискового пространства. Что происходит?

Это связано с тем, как эти команды на самом деле работают. `du` проходит по дереву каталогов, замеряя, насколько большой объем занимает каждый файл, и выдает общий объем. `df` просто запрашивает файловую систему об оставшемся объеме. Это выглядит как одно и то же, однако файл без записи в каталоге затронет `df`, но не повлияет на `du`.

Когда программа использует файл и этот файл удаляется, то на самом деле он не удаляется из файловой системы, пока программа не прекратит его использовать. Однако файл тут же удаляется из списка каталога. Представим себе файл достаточно большого размера, чтобы его присутствие влияло на вывод `du` и `df`. Если файл удаляется в процессе работы с ним команды `more`, команда `more` не сообщает сразу же, что не может просматривать файл. Запись о файле просто удалена из каталога, так что другие программы или пользователи не смогут к нему обратиться. Тем не менее, `du` покажет, что файл исчез, поскольку она просматривает дерево каталогов, а файла там нет. `df` показывает, что файл всё ещё здесь, так как файловая система знает, что `more` всё ещё использует это пространство. Как только закончится работа с `more`, команды `du` и `df` придут в соответствие.

Такая ситуация часта на Web-серверах. Многие устанавливают Web-сервер на FreeBSD и забывают обновлять файлы протоколов. Журнал доступа заполняет [.filename]#/var#. Новый администратор удаляет файл, но система все еще сообщает о том, что раздел заполнен. Остановка и перезапуск программы Web-сервера освободит файл, позволяя системе освободить дисковое пространство. Для предотвращения этого настройте man:newsyslog[8].

Заметьте, что подсистема отложенных обновлений (Soft Updates) может задерживать освобождение дискового пространства, и может потребоваться до 30 секунд, чтобы изменения стали заметны.

=== Как добавить дополнительную виртуальную память?

В этом разделе link:{handbook}#adding-swap-space/[Руководства] описывается, как это сделать.

=== Почему FreeBSD считает, что размер моего диска меньше, чем заявляет его производитель?

Производители дисков считают гигабайт равным миллиарду байт, а FreeBSD приравнивает его к 1073741824 байт. Это объясняет, почему, к примеру, в сообщениях при загрузке FreeBSD указывается, что ёмкость диска, объём которого должен быть равным 80 Гбайт, составляет 76319 Мбайт.

Заметьте также, что FreeBSD будет (по умолчанию) <<disk-more-than-full,резервировать>> 8% ёмкости диска.

=== Почему возможно заполнение раздела больше чем на 100%?

Часть каждого раздела UFS (по умолчанию 8%) зарезервировано для использования операционной системой и пользователем `root`. Утилита man:df[1] не учитывает это при подсчёте значения в колонке `Capacity`, так что оно может превышать 100%. Обратите внимание, что колонка `Blocks` всегда больше, чем сумма значений в колонках `Used` и `Avail`, обычно на 8%.

Для получения более подробной информации обратитесь к описанию опции `-m` в справке по man:tunefs[8].

=== Почему загрузка FreeBSD задерживается на длительное время на системах с большим объёмом ОЗУ?

FreeBSD выполняет короткую проверку памяти на раннем этапе загрузки. Обычно эта проверка занимает всего несколько секунд, но если система имеет много десятков или сотен Гбайт памяти, это можно занять до нескольких минут. Эту проверку можно отключить, установив `hw.memtest.tests` в значение `0` в [.filename]#/boot/loader.conf#.

Для получения дополнительной информации смотрите страницу Справочника man:loader.conf[5].

== ZFS

=== Какой минимальный объём ОЗУ нужно иметь для ZFS?

Для комфортного использования требуется 4 Гбайт ОЗУ, но конкретная нагрузка может сильно различаться.

=== Что такое ZIL и когда оно используется?

ZIL ((ZFS intent log) - это журнал записи, используемый для фиксации операций записи. Обычно операции собираются в группу транзакций и при заполнении группы пишутся на диск ("Transaction Group Commit"). Однако системные вызовы типа man:fsync[2] требуют фиксацию записи данных на устройстве перед возвратом управления. ZIL нужен для подтверждения такой записи, но когда данные ещё не находятся на диске. Группа транзакций помечается временной меткой. В случае системного сбоя ищется последняя неповреждённая метка и из ZIL извлекаются недостающие данные.

=== Нужен ли мне SSD для ZIL?

По умолчанию ZFS хранит ZIL в пуле со всеми данными. Если приложение имеет большой процент записи, вынос ZIL на отдельное устройство с очень быстрой синхронной последовательной записью может улучшить общую производительность. В остальных случаях SSD вряд ли сможет что-то сильно улучшить.

=== Что такое L2ARC?

L2ARC - это кеш на чтение, хранимый на быстром устройстве, таком как SSD. Этот кеш не сохраняется между перезагрузками. Следует заметить, что ОЗУ выступает как кеш первого уровня, а L2ARC задействуется только при нехватке ОЗУ.

Для L2ARC нужно пространство в ARC для его индексации. Таким образом, рабочий набор, который идеально помещается в ARC, не будет помещаться при использовании L2ARC, потому что часть ARC будет отведена под индекс L2ARC с вытеснением части рабочего набора в L2ARC, более медленный, чем ОЗУ.

=== Целесообразно ли включение дедупликации?

В общем случае нет.

Дедупликация занимает значительный объём ОЗУ и может увеличить задержки операций ввода/вывода. Если данные не являются сильно дублированными (образы виртуальных машин или пользовательские бекапы), то, возможно, дедупликация даст больше вреда. Другое соображение касается невозможности отменить статус дедупликации. Если данные записаны при включённой дедупликации, её выключение не приведёт к обратной репликации объединённых блоков до момента следующей перезаписи.

Дедупликация также может приводить к некоторым неожиданным ситуациям. В частности, удаление файлов может сильно замедлиться.

=== Я не могу создать или удалить файлы на пуле ZFS. Как я могу это исправить?

Такое может произойти при 100% заполненности пула. ZFS требуется свободное место на диске для записи метаданных транзакций. Для восстановления работоспособного состояния пула обрежьте файл перед его удалением.

[source,bash]
....
% truncate -s 0 unimportant-file
....

Обрезание файла работает по той причине, что новая транзакция при этом не запускается; вместо этого создаются новые свободные блоки.

[NOTE]
====
На системах с дополнительной настройкой ZFS dataset, такой как дедупликация, свободное место может не быть доступно сразу.
====

=== Поддерживается ли TRIM в ZFS для твердотельных накопителей?

Поддержка ZFS TRIM была добавлена во FreeBSD 10-CURRENT в ревизии rlink:https://svnweb.freebsd.org/changeset/base/240868[r240868] и стала доступна в ветках -STABLE в rlink:https://svnweb.freebsd.org/changeset/base/252162[r252162] и rlink:https://svnweb.freebsd.org/changeset/base/251419[r251419].

ZFS TRIM включена по умолчанию и может быть отключена посредством добавления такой строки в [.filename]#/etc/sysctl.conf#:

[.programlisting]
....
vfs.zfs.trim_disable=1
....

[NOTE]
====
ZFS TRIM может не работать на всех конфигурациях, в частности для файловой системы ZFS на устройствах с использованием GELI.
====

== Системное администрирование

=== Где расположены файлы конфигурации системы?

Основным конфигурационным файлом является [.filename]#/etc/defaults/rc.conf#, который описан в man:rc.conf[5]). Этот файл подключают системные скрипты запуска, такие как [.filename]#/etc/rc# и [.filename]#/etc/rc.d#, которые описаны в man:rc[8]. _Не редактируйте этот файл!_ Вместо изменения параметра в [.filename]#/etc/defaults/rc.conf# скопируйте эту строку в [.filename]#/etc/rc.conf# и поменяйте значение там.

Пример запуска man:named[8], поставляемого с системой сервера DNS:

[source,bash]
....
# echo 'named_enable="YES"' >> /etc/rc.conf
....

Чтобы запустить местные сервисы, поместите скрипты в каталог [.filename]#/usr/local/etc/rc.d#. У этих скриптов должен быть выставлен бит выполнимости, по умолчанию используются права доступа `555`.

=== Как проще всего добавить пользователя?

Используйте команду man:adduser[8] или man:pw[8] в случае выполнения более сложных операций.

Чтобы удалить пользователя, используйте команду man:rmuser[8] или, если это будет необходимо, man:pw[8].

=== Почему после редактирования моего файла crontab я получаю сообщения вида root: not found?

Обычно это случается при редактировании системного файла crontab.

Это неправильный подход, потому что системный crontab имеет формат, отличный от пользовательских crontab. Системный crontab имеет дополнительное поле, указывающее, под каким пользователем запускать команду. man:cron[8] полагает, что имя пользователя является первым словом в команде на выполнение. Поскольку такой команды не существует, отображается это сообщение об ошибке.

Чтобы удалить лишний неправильный crontab:

[source,bash]
....
# crontab -r
....

=== Команда su выдает ошибку you are not in the correct group to su root, когда я пытаюсь сменить привилегии на root.

Это особенность работы системы защиты. Для того, чтобы сменить пользовательский идентификатор с помощью `su` на пользователя `root` или любого другого с привилегиями суперпользователя, учётная запись должна являться членом группы `wheel`. Если бы этого не было, то любой, имеющий доступ к системе и узнавший пароль пользователя `root`, смог бы получить в системе уровень доступа суперпользователя.

Чтобы разрешить кому-либо менять привилегии на `root`, включите его в группу `wheel` с помощью `pw`.

[source,bash]
....
# pw groupmod wheel -m lisa
....

В примере выше пользователь `lisa` будет добавлен в группу `wheel`.

=== Я сделал ошибку в файле rc.conf или в каком-то другом файле начальной загрузки, и теперь не могу его отредактировать из-за того, что файловая система находится в режиме только для чтения. Что мне делать?

Перезапустите систему, используя в приглашении загрузчика команду `boot -s` для входа в однопользовательский режим. При получении приглашения на ввод полного пути до командного процессора нажмите `Enter`, а затем выполните команду `mount -urw /` для повторного монтирования корневой файловой системы в режиме чтения/записи. Вам может также потребоваться выполнить команду `mount -a -t ufs` для монтирования файловой системы, в которой расположен ваш любимый текстовый редактор. Если редактор расположен на сетевой файловой системе, либо выполните сетевые настройки вручную до монтирования сетевой файловой системы, либо воспользоваться редактором, находящимся в локальной файловой системе, таким, как man:ed[1].

Чтобы использовать полноэкранный редактор, такой как man:vi[1] или man:emacs[1], выполните команду `export TERM=xterm` во FreeBSD 9.0+ или `export TERM=cons25` во FreeBSD 8.X, чтобы такие редакторы смогли корректно взять данные из базы данных man:termcap[5].

После выполнения этих шагов отредактируйте файл [.filename]#/etc/rc.conf# для исправления ошибки. Сообщение об ошибке, выводимое сразу же после сообщений при загрузке ядра, должно указать на номер строки в файле, которая содержит ошибку.

=== У меня проблемы с установкой принтера.

Обратитесь к соответствующему link:{handbook}#printing/[разделу] Руководства, посвящённому печати, за советами по разрешению проблем.

=== Раскладка клавиатуры неверна.

Обратитесь к разделу Руководства, посвящённому link:{handbook}#using-localization/[использованию локализации], а именно к части, описывающей link:{handbook}#setting-console[ настройку консоли].

=== Почему не получается заставить работать дисковые квоты?

. Возможно, что ядро не сконфигурировано должным образом для работы с квотами. В этом случае добавьте следующую строчку в конфигурационный файл ядра и пересоберите ядро:
+
[.programlisting]
....
options QUOTA
....

+ 
Прочтите link:{handbook}#quotas/[главу руководства по квотам] для полной информации.
. Не включайте квотирование на разделе [.filename]#/#.
. Помещайте файл с квотами в ту файловую систему, которую он обслуживает:
+
[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Файловая система
| Файл квот

|[.filename]#/usr#
|[.filename]#/usr/admin/quotas#

|[.filename]#/home#
|[.filename]#/home/admin/quotas#

|...
|...
|===

=== Поддерживает ли FreeBSD вызовы IPC из System V?

Да, во FreeBSD в ядро [.filename]#GENERIC# включена поддержка IPC в стиле System V, в том числе совместно используемой памяти, сообщений и семафоров. В вашем собственном ядре поддержка может быть включена посредством загрузки модулей ядра [.filename]#sysvshm.ko#, [.filename]#sysvsem.ko# и [.filename]#sysvmsg.ko# или добавлением в конфигурационный файл ядра следующих строк:

[.programlisting]
....
options    SYSVSHM	  # enable shared memory
options    SYSVSEM	  # enable for semaphores
options    SYSVMSG	  # enable for messaging
....

Перекомпилируйте и переустановите ядро.

=== Какое другое программное обеспечение для почтового сервера можно использовать вместо Sendmail?

Сервер http://www.sendmail.org/[Sendmail] является программным обеспечением для работы почтового сервера во FreeBSD, используемым по умолчанию, но его можно заменить другим MTA, установленным из Коллекции Портов. В дереве портов имеется package:mail/exim[], package:mail/postfix[] и package:mail/qmail[]. Проверьте архивы списков рассылки на предмет обсуждения достоинств и недостатков имеющихся MTA.

=== Я забыл пароль пользователя root! Что делать?

Без паники! Перезапустите систему, наберите `boot -s` в приглашении `Boot:` для входа в однопользовательский режим. На вопрос об используемой оболочке нажмите kbd:[Enter] для получения приглашения # . Введите `mount -urw /`, чтобы перемонтировать корневую файловую систему в режиме чтения/записи, после чего выполните команду `mount -a` для монтирования всех файловых систем. Запустите команду `passwd root`, чтобы сменить пароль пользователя `root`, а затем man:exit[1] для продолжения процесса загрузки.

[NOTE]
====
Если при входе в однопользовательский режим предлагается ввести пароль пользователя `root`, это означает, что консоль была помечена как `insecure` в [.filename]#/etc/ttys#. В этом случае потребуется загрузиться с установочного диска FreeBSD, выбрать [.guimenuitem]#Live CD# или [.guimenuitem]#Shell# в начале процесса установки и выполнить указанные выше команды. В этом случае смонтируйте нужный раздел и выполните туда chroot. Например, замените команду `mount -urw /` на `mount /dev/ada0p1 /mnt; chroot /mnt` для системы, расположенной на _ada0p1_.
====

[NOTE]
====
Если корневой раздел не получается смонтировать в однопользовательском режиме, то возможно, что разделы являются зашифрованными, и смонтировать их без ключей доступа не представляется возможным. За дополнительной информацией обращайтесь к разделу link:{handbook}#disks-encrypting/[Руководства], посвященному шифрованию дисков во FreeBSD.
====

=== Как запретить перезагрузку по нажатию Control Alt Delete?

При использовании стандартного драйвера консоли man:syscons[4] перегенерируйте и установите новое ядро с таким параметром в конфигурационном файле:

[.programlisting]
....
options SC_DISABLE_REBOOT
....

Этого также можно достичь установкой следующего man:sysctl[8], что не требует перезагрузки или пересборки ядра:

[source,bash]
....
# sysctl hw.syscons.kbd_reboot=0
....

[NOTE]
====
Оба этих метода являются взаимоисключающими. Данный man:sysctl[8] не существует, если ядро скомпилировано с параметром `SC_DISABLE_REBOOT`.
====

=== Как преобразовать текстовые файлы DOS в формат UNIX(R)?

Воспользуйтесь следующей командой man:perl[1]:

[source,bash]
....
% perl -i.bak -npe 's/\r\n/\n/g' file(s)
....

где _file(s)_ - это один или несколько файлов для обработки. Преобразование делается в том же самом файле, оригинальные файлы сохраняются с расширением [.filename]#.bak#.

Либо используйте man:tr[1]:

[source,bash]
....
% tr -d '\r' < dos-text-file > unix-file
....

где _dos-text-file_ - это имя файла, содержащего текст DOS, а в файл _unix-file_ будет помещён уже преобразованный текст. Этот способ может работать гораздо быстрее, чем при использовании `perl`.

Еще один способ отформатировать тестовые файлы DOS состоит в использовании package:converters/dosunix[] из Коллекции Портов. Для получения дополнительной информации ознакомьтесь с документацией порта.

=== Как перечитать содержимое /etc/rc.conf и перестартовать /etc/rc без перезагрузки системы?

Перейдите в однопользовательский режим, а затем возвратитесь обратно в многопользовательский.

[source,bash]
....
# shutdown now
# return
# exit
....

=== Я пытался обновить мою систему до последней -STABLE, а получил -BETAx, -RC или -PRERELEASE! Что происходит?

Краткий ответ: это же просто название. _RC_ означает "Release Candidate". Это значит, что вскоре произойдет выход релиза. Во FreeBSD появление _-PRERELEASE_, как правило, равнозначно прекращению внесения изменений в код системы перед появлением релиза. (Для некоторых релизом метка _-BETA_ использовалась точно так же, как и _-PRERELEASE_.)

Подробный ответ: во FreeBSD релизы выпускаются из одного из двух мест. Крупные релизы, точка-ноль, такие, как 9.0-RELEASE и 10.0-RELEASE, ответвляются от основного потока разработки, более известного как <<current,-CURRENT>>. Мелкие релизы, такие, как 6.3-RELEASE или 5.2-RELEASE, являлись снэпшотами активной ветки <<stable,-STABLE>>. Начиная с 4.3-RELEASE, каждый релиз также имеет свою ветвь, которой могут следовать те, кому необходим сверхконсервативный метод обновления (как правило, внесение только тех исправлений, которые касаются вопросов обеспечения безопасности).

Когда делается релиз, то ветвь, из которой он выпускается, подвергается некоторой подготовке. Частью этого процесса является замораживание кода. Когда инициируется замораживание кода, то имя ветки изменяется для того, чтобы отразить факт близости релиза. Например, если ветка называлась 6.2-STABLE, то её имя будет изменено на 6.3-PRERELEASE, чтобы обозначить момент прекращения внесения изменений в код системы и период дополнительного тестирования перед выходом релиза. В это время исправления ошибок могут быть внесены в код системы для того, чтобы быть включенными в релиз. Когда исходный код подготовлен к выпуску релиза, имя будет изменено на 6.3-RC для обозначения того, что релиз будет сделан, скорее всего, именно из этого кода. Когда код находится на этапе RC, в нём могут исправляться только самые критичные ошибки. Как только релиз (в нашем примере 6.3-RELEASE) и ветка релиза будут созданы, ветвь будет переименована в 6.3-STABLE.

Для получения дополнительной информации о номерах версий и различных ветках Subversion обратитесь к статье о link:{releng}[выпуске релизов].

=== Я попытался установить новое ядро, однако утилита man:chflags[1] не сработала. Как это обойти?

Краткий ответ: Режим безопасности имеет значение больше нуля. Для установки ядра перезагрузите машину и войдите в однопользовательский режим.

Подробный ответ: FreeBSD запрещает менять системные флаги при работе на уровнях безопасности, превышающих 0. Чтобы проверить текущий уровень безопасности:

[source,bash]
....
# sysctl kern.securelevel
....

Уровень безопасности нельзя понизить в многопользовательском режиме, поэтому для установки ядра загрузитесь в однопользовательский режим, или измените уровень безопасности в [.filename]#/etc/rc.conf#, а затем выполните перезагрузку. Обратитесь к странице Справочника по man:init[8] за подробной информацией о `securelevel` и посмотрите [.filename]#/etc/defaults/rc.conf# и справочную страницу по man:rc.conf[5] для выяснения подробностей о файле [.filename]#rc.conf#.

=== Не получается изменить системное время больше чем на одну секунду! Как это обойти?

Краткий ответ: Система работает на уровне безопасности со значением выше 1. Для смены даты перезагрузите машину и войдите в однопользовательский режим.

Подробный ответ: FreeBSD запрещает менять системное время больше чем на одну секунду на уровне безопасности выше 1. Чтобы определить уровень безопасности:

[source,bash]
....
# sysctl kern.securelevel
....

Уровень безопасности нельзя понизить в многопользовательском режиме. Для изменения даты перезагрузите систему в однопользовательский режим, либо измените уровень безопасности в [.filename]#/etc/rc.conf#, а затем выполните перезагрузку. Обратитесь к странице Справочника по man:init[8] за подробной информацией о `securelevel` и посмотрите [.filename]#/etc/defaults/rc.conf# и справочную страницу по man:rc.conf[5] для выяснения подробностей о файле [.filename]#rc.conf#.

=== В rpc.statd; есть ошибка работы с памятью! Он использует 256 Мбайт оперативной памяти!

Нет, там нет ошибок и он не использует 256 Мбайт памяти. Для удобства `rpc.statd` отображает неприлично большой кусок памяти в своё адресное пространство. Здесь нет ничего неправильного с технической точки зрения, это просто сбивает с толку программы вроде man:top[1] и man:ps[1]

man:rpc.statd[8] отображает свой статусный файл (находящийся на [.filename]#/var#) в свое адресное пространство. Для того, чтобы постоянно не беспокоиться о будущих переотражениях, когда файл вырастет в размерах, он просто отображает его с огромным размером заранее. Это просто заметить в исходных текстах, где как вы можете увидеть параметр длина к функции man:mmap[2] имеет значение `0x10000000`, или одна шестнадцатая адресного пространства для IA32, то есть 256 Мбайт.

=== Почему я не могу снять с файла флаг schg?

Система работает с уровнем защиты выше нуля. Понизьте уровень защиты и попробуйте еще раз. Для получения более подробной информации обратитесь к <<securelevel,разделу FAQ об уровне защиты>> и справочной странице man:init[8].

=== Что такое vnlru?

`vnlru` сбрасывает и освобождает vnode, когда система достигает ограничения по параметру `kern.maxvnodes`. Этот поток ядра в основном работает вхолостую и активируется только при наличии огромного объема ОЗУ и обращении к десяткам тысяч файлов небольшого размера.

=== Что означают различные состояния памяти, показываемые утилитой top?

* `Active`: по статистике страницы недавно использовались.
* `Inactive`: по статистике страницы недавно не использовались.
* `Cache`: (наиболее часто) страницы, которых перемещены из числа неактивных в статус, в котором они содержат данные, но которые могут часто сразу же использоваться повторно (как с их старым содержимым, так и повторно с новым). Это может быть некоторое непосредственное перемещение из состояния `active` в состояние `cache`, если известно, что страница чиста (не модифицировалась), но такое перемещение определяется политикой, зависящей от выбора алгоритма разработчиком VM-системы.
* `Free`: страницы, не содержащие данных, и которые могут быть использованы при некоторых условиях, когда страницы кэша могут не подойти. Свободные страницы могут повторно использоваться в состояниях прерывания или процессах.
* `Wired`: страницы, зафиксированные в памяти, обычно для использования ядром, а также иногда для специального использования процессами.

Страницы чаще всего записываются на диск (типа синхронизации VM), когда они находятся в неактивном состоянии, однако страницы в активном состоянии также могут сбрасываться. Это зависит от наличия и возможности отслеживания со стороны ЦП бита 'модифицированности', и в некоторых ситуациях это может быть лучше для блока синхронизируемых страниц VM, вне зависимости от их активности. В большинстве встречающихся ситуаций лучше всего представлять неактивную очередь как очередь сравнительно неиспользуемых страниц, которые могут быть, а могут и не быть в процессе записи на диск. Кэшируемые страницы уже синхронизированы, не отображаются, но доступны для непосредственного использования процессом со своей старой или новой привязкой. Свободные страницы доступны на уровне прерывания, однако кэшируемые или свободные страницы могут использоваться в процессе повторно. Кэшируемые страницы недостаточно заблокированы для того, чтобы быть доступными на уровне прерывания.

Есть ещё некоторые другие флаги (например, флаг занятости или счётчик занятости), которые могут изменить некоторые описанные правила.

=== Сколько свободной памяти доступно?

Есть несколько понятий "свободной памяти". В одном случае это объём памяти, непосредственно доступной в данный момент без страничной выгрузки чего-либо. Этот объём равен примерно размеру очереди кэша + размер очереди на высвобождение (с учётом допустимых отклонений, зависящих от настроек системы). В другом случае "свободная память" обозначает общий объём пространства VM. Он может сложно вычисляться, но зависит от объёма раздела подкачки и памяти. Другие определения "свободной памяти" также возможны, но они достаточно бесполезны, ведь в любом случае важно сохранять низкий уровень подкачки и избегать исчерпания раздела подкачки.

=== Что такое /var/empty?

[.filename]#/var/empty# представляет собой каталог, который используется в программе man:sshd[8] при выполнении разделения полномочий. Каталог [.filename]#/var/empty# пуст, его владельцем является `root`, и на нём установлен флаг `schg`. Этот каталог не должен удаляться.

=== Я поменял /etc/newsyslog.conf. Как проверить правильность изменений?

Чтобы посмотреть, что будет делать man:newsyslog[8], используйте следующую команду:

[source,bash]
....
% newsyslog -nrvv
....

=== Как поправить часовой пояс?

Используйте man:tzsetup[8].

== X Window System и виртуальные консоли

=== Что такое X Window System?

X Window System (обычно `X11`) является наиболее общедоступной оконной системой, которая может работать на UNIX(R) и UNIX(R)-подобных системах, в том числе и во FreeBSD. Разработкой стандартов на используемый http://en.wikipedia.org/wiki/X_Window_System_core_protocol[X-протокол] занимается организация http://www.x.org/wiki/[The X.Org Foundation], с текущей эталонной реализацией version 11 release 7.7, поэтому название часто сокращается до `X11`.

Для разных архитектур и операционных систем существует множество реализаций этой системы. Реализацию кода для серверной части называют `X-сервером`.

=== Я хочу запустить Xorg, как это сделать?

Для установки Xorg выполните одно из действий:

Используйте мета-порт [.filename]#x11/xorg#, который выполняет построение и установку всех компонентов Xorg.

Используйте [.filename]#x11/xorg-minimal#, который выполняет построение и установку только необходимых компонентов Xorg.

Установите Xorg из пакетов FreeBSD.

[source,bash]
....
#  pkg install xorg
....

После установки Xorg следуйте указаниям в разделе link:{handbook}#x-config/[Конфигурация X11] Руководства FreeBSD.

=== Я попытался запустить X, но получил сообщение No devices detected. после ввода команды startx. Что мне теперь делать?

Вероятно, в системе установлен повышенный уровень безопасности (`securelevel`). При повышенном уровне защиты систему X запустить невозможно, потому что X требуются права на операции записи в устройство man:io[4]. Дополнительная информация находится на странице Справочника man:init[8].

Существует два решения проблемы: установить значение `securelevel` обратно в ноль или запускать man:xdm[1] (или любой другой оконный менеджер) во время загрузки, до того как повышается значение `securelevel`.

Обратитесь к <<xdm-boot>> для получения более полной информации о запуске man:xdm[1] во время загрузки.

=== Почему моя мышь не работает с X?

При использовании стандартного драйвера консоли man:syscons[4] во FreeBSD можно включить поддержку указателя мыши во всех виртуальных экранах. Во избежание конфликтов с X, драйвер man:syscons[4] поддерживает виртуальное устройство [.filename]#/dev/sysmouse#. Все события от реального устройства мыши пишутся в устройство man:sysmouse[4] через man:moused[8]. Чтобы использовать мышь на одной и более виртуальных консолях, и при этом продолжать использовать X, посмотрите <<moused>> и настройте man:moused[8].

Затем отредактируйте [.filename]#/etc/X11/xorg.conf#, чтобы в нём были следующие строки:

[.programlisting]
....
Section "InputDevice"
   Option	  "Protocol" "SysMouse"
   Option	  "Device" "/dev/sysmouse"
.....
....

Начиная с версии Xorg 7.4 раздел `InputDevice` в файле [.filename]#xorg.conf# игнорируется, и вместо него используется механизм автоматически определяемых устройств. Чтобы восстановить прежнее поведение, добавьте в раздел `ServerLayout` или `ServerFlags` такую строку:

[.programlisting]
....
Option "AutoAddDevices" "false"
....

Некоторые предпочитают использовать в X устройство [.filename]#/dev/mouse#. Чтобы оно работало, файл устройства [.filename]#/dev/mouse# должен являться ссылкой на [.filename]#/dev/sysmouse# (посмотрите справку по man:sysmouse[4]). Это можно сделать, добавив следующую строку в [.filename]#/etc/devfs.conf# (посмотрите справку по man:devfs.conf[5]):

[.programlisting]
....
link    sysmouse    mouse
....

Ссылка может быть создана путем перезапуска man:devfs[5] с использованием следующей команды (из под пользователя `root`):

[source,bash]
....
# service devfs restart
....

=== У моей мыши есть колёсико. Могу ли я его использовать при работе в X?

Да, если X настроена для использования 5-кнопочной мыши. Для этого добавьте строчки `Buttons 5` и `ZAxisMapping 4 5` в раздел "InputDevice" файла [.filename]#/etc/X11/xorg.conf# как показано в этом примере:

[.programlisting]
....
Section "InputDevice"
   Identifier      "Mouse1"
   Driver	  "mouse"
   Option	  "Protocol" "auto"
   Option	  "Device" "/dev/sysmouse"
   Option	  "Buttons" "5"
   Option	  "ZAxisMapping" "4 5"
EndSection
....

Для использования мыши в Emacs также добавьте в [.filename]#~/.emacs# следующие строки:

[.programlisting]
....
;; wheel mouse
(global-set-key [mouse-4] 'scroll-down)
(global-set-key [mouse-5] 'scroll-up)
....

=== Как заставить работать тачпад Synaptics в X?

Для его работы понадобится настроить некоторые вещи.

Чтобы использовать драйвер synaptics из Xorg, для начала удалите строку moused_enable из [.filename]#rc.conf#.

Для включения synaptics добавьте следующую строку в [.filename]#/boot/loader.conf#:

[.programlisting]
....
hw.psm.synaptics_support="1"
....

Добавьте следующее в [.filename]#/etc/X11/xorg.conf#:

[.programlisting]
....
Section "InputDevice"
Identifier  "Touchpad0"
Driver      "synaptics"
Option      "Protocol" "psm"
Option      "Device" "/dev/psm0"
EndSection
....

И не забыть добавить следующее в раздел "ServerLayout":

[.programlisting]
....
InputDevice    "Touchpad0" "SendCoreEvents"
....

=== Как использовать удалённые X-дисплеи?

Из соображений обеспечения информационной безопасности открывать удалённые окна на машине по умолчанию запрещено.

Для включения этой возможности запустите X с аргументом `-listen_tcp`:

[source,bash]
....
% startx -listen_tcp
....

=== Что такое виртуальные консоли и как изменить их количество?

Виртуальные консоли предоставляют несколько одновременных сеансов работы с той же самой машиной без установки какой бы то ни было сети или запуска X.

При запуске системы после вывода сообщений этапа загрузки на консоль выдаётся приглашение для входа в систему. Введите своё имя и пароль, чтобы начать работу на первой виртуальной консоли.

Чтобы запустить ещё один сеанс, скажем, чтобы заглянуть в документацию по программе или для чтения электронной почты во время ожидания завершения передачи данных по FTP, нажмите kbd:[F2], удерживая kbd:[Alt]. Это отобразит приглашение на второй виртуальной консоли. Чтобы вернуться к первоначальному сеансу, нажмите kbd:[Alt+F1].

По умолчанию во FreeBSD задействованы восемь виртуальных консолей, а комбинации клавиш kbd:[Alt+F1], kbd:[Alt+F2], kbd:[Alt+F3] и далее служат для переключения между ними.

Чтобы увеличить количество виртуальных консолей, отредактируйте [.filename]#/etc/ttys# (смотрите страницу Справочника man:ttys[5]), добавив туда записи для терминалов с именами от [.filename]#ttyv8# до [.filename]#ttyvc# после комментария про "Virtual terminals":

[.programlisting]
....
# Edit the existing entry for ttyv8 in /etc/ttys and change
# "off" to "on".
ttyv8   "/usr/libexec/getty Pc"	 xterm  on secure
ttyv9   "/usr/libexec/getty Pc"	 xterm  on secure
ttyva   "/usr/libexec/getty Pc"	 xterm  on secure
ttyvb   "/usr/libexec/getty Pc"	 xterm  on secure
....

Чем больше виртуальных терминалов, тем больше ресурсов используется. Это может привести к проблемам на системах с 8 Мбайт ОЗУ или меньше. Подумайте о смене статуса консолей с `secure` на `insecure`.

[NOTE]
====
Во FreeBSD до версии 9.0 использовался тип терминала "cons25" вместо "xterm". При добавлении в [.filename]#/etc/ttys# новых записей используйте существующий формат.
====

[IMPORTANT]
====
Чтобы запустить сервер X, нужно зарезервировать под него хотя бы один виртуальный терминал со значением `off`. Это означает, что под виртуальные консоли можно отвести только одиннадцать функциональных клавиш, и ещё одна остаётся за X-сервером.
====

Например, чтобы запустить X и 11 виртуальных консолей, нужно настроить двенадцатый виртуальный терминал:

[.programlisting]
....
ttyvb   "/usr/libexec/getty Pc"	 xterm  off secure
....

Самым простым способом активировать виртуальные консоли является перезагрузка.

=== Как осуществляется доступ к виртуальным консолям из X?

Используйте комбинацию клавиш kbd:[Ctrl+Alt+Fn] для переключения обратно в виртуальную консоль. Нажмите kbd:[Ctrl+Alt+F1], чтобы вернуться на первую виртуальную консоль.

После того, как вы оказались в текстовой консоли, используйте комбинации kbd:[Alt+Fn] для переключения между ними.

Чтобы вернуться в сеанс работы X, переключитесь в виртуальную консоль, на которой запущена X Window. Если X был запущен из командной строки с использованием команды `startx`, то сеанс работы X будет привязан к следующей неиспользуемой виртуальной консоли, а не к той текстовой консоли, с которой он был запущен. В случае восьми активных виртуальных терминалов X будет работать на девятом, поэтому используйте комбинацию kbd:[Alt+F9].

[[xdm-boot]]
=== Как запустить XDM во время загрузки?

Есть две философские школы, проповедующие различные методы запуска man:xdm[1]. Последователи одного течения запускают `xdm` из [.filename]#/etc/ttys# (посмотрите man:ttys[5]), используя приводимый пример, тогда как другие вставляют запуск `xdm` в скрипт [.filename]#rc.local# (посмотрите справку по man:rc[8]) или [.filename]#X#, помещая последний в каталог [.filename]#/usr/local/etc/rc.d#. Оба метода равноправны, и один из них может работать в ситуациях, с которыми не справляется другой и наоборот. В обоих случаях результат один и тот же: X выводит графическое приглашение для входа в систему.

Плюсом метода с использованием man:ttys[5] является документирование того, на каком vty будет запущен X и то, что ответственность за перезапуск X-сервера при завершении сеанса работы лежит на процессе man:init[8]. Метод с использованием man:rc[8] позволяет просто прекратить работу xdm командой `kill xdm`, если при запуске X возникли какие-нибудь проблемы.

Из man:rc[8] `xdm` должен быть запущен без аргументов. `xdm` должен быть запущен _после_ запуска man:getty[8], иначе они будут конфликтовать, блокируя консоль. Лучше всего выдержать паузу секунд на 10 и потом запустить `xdm`.

Если `xdm` запускается из [.filename]#/etc/ttys#, остаётся вероятность конфликта между `xdm` и man:getty[8]. Одним из способов избежать этого является добавление номера `vt` в файл [.filename]#/usr/local/lib/X11/xdm/Xservers#:

[.programlisting]
....
:0 local /usr/local/bin/X vt4
....

В вышеприведённом случае X-серверу указывается работать на [.filename]#/dev/ttyv3#. Заметьте, что номера отличаются на единицу. Дело в том, что X-сервер считает vty от единицы, когда как отсчёт vty в ядре FreeBSD ведётся с нуля.

=== При запуске xconsole выдаётся сообщение Couldn't open console.

Если X запускается с помощью startx, права на устройство [.filename]#/dev/console#_не_ изменяются, поэтому такие программы как xterm -C и xconsole не будут работать.

Это зависит от прав доступа, установленных для консоли по умолчанию. В многопользовательской системе вовсе не нужно, чтобы любой пользователь мог выводить информацию на системную консоль. Для пользователей, вошедших в систему через VTY, для решения этой проблемы существует файл man:fbtab[5].

В общем, раскомментируйте строчку в файле [.filename]#/etc/fbtab# (посмотрите справку по man:fbtab[5]):

[.programlisting]
....
/dev/ttyv0 0600 /dev/console
....

Этого будет достаточно для того, чтобы всякий, кто вошёл в систему с терминала [.filename]#/dev/ttyv0#, имел доступ к консоли.

=== Моя мышь PS/2 в X работает неправильно.

Мышь и драйвер могли рассинхронизироваться. В редких случаях драйвер может ошибочно сообщать о проблемах синхронизации:

[.programlisting]
....
psmintr: out of sync (xxxx != yyyy)
....

Если это случилось, отмените проверку согласования, установив значение флага для драйвера мыши PS/2 в `0x100`. Проще всего это сделать добавлением `hint.psm.0.flags="0x100"` в [.filename]#/boot/loader.conf# с перезагрузкой.

=== Как поменять местами кнопки мыши?

Наберите `xmodmap -e "pointer = 3 2 1"`. Добавьте эту команду в [.filename]#~/.xinitrc# или [.filename]#~/.xsession# для автоматического запуска.

=== Как установить экранную заставку и где такие заставки можно найти?

Подробный ответ находится в разделе link:{handbook}#boot-blocks[Загрузочные экранные заставки] Руководства FreeBSD.

=== Можно ли в X использовать клавишу Windows?

Да. Используйте man:xmodmap[1] для привязки функций к этим клавишам.

Если все клавиатуры Windows стандартны, то эти три клавиши имеют следующие клавиатурные коды:

* 115 - клавиша kbd:[Windows] между клавишами kbd:[Ctrl] и kbd:[Alt] с левой стороны
* 116 - клавиша kbd:[Windows] справа от kbd:[AltGr]
* 117 - клавиша kbd:[Menu], слева от клавиши kbd:[Ctrl], находящейся справа

Чтобы заставить левую клавишу kbd:[Windows] набирать запятую, попробуйте выполнить такую команду:

[source,bash]
....
# xmodmap -e "keycode 115 = comma"
....

Для того, чтобы переопределения клавиш kbd:[Windows] выполнялось автоматически каждый раз при запуске X, поместите команды `xmodmap` в [.filename]#~/.xinitrc# либо, что предпочтительней, создайте файл [.filename]#~/.xmodmaprc# и включите в него параметры `xmodmap` по одному на строку, затем добавьте в [.filename]#~/.xinitrc# такую строку:

[.programlisting]
....
xmodmap $HOME/.xmodmaprc
....

Например, чтобы переопределить эти 3 клавиши так, чтобы они выполняли функции клавиш kbd:[F13], kbd:[F14] и kbd:[F15]. Это позволит легко привязать их к полезным функциям в приложениях или менеджере окон.

Чтобы сделать это, поместите такие строки в файл [.filename]#~/.xmodmaprc#:

[.programlisting]
....
keycode 115 = F13
keycode 116 = F14
keycode 117 = F15
....

При использовании оконного менеджера package:x11-wm/fvwm2[] клавиши можно переопределить так, чтобы kbd:[F13] сворачивал в иконку (и восстанавливал предыдущий размер) то окно, на которое указывает курсор, kbd:[F14] перемещал окно с курсором на передний план или, если оно уже впереди, возвращал обратно, а kbd:[F15] вызывал главное меню Workplace, даже если курсор находится не на рабочем столе, что бывает полезно, когда не видно ни одного кусочка рабочего стола.

Следующие записи в [.filename]#~/.fvwmrc# позволяют достичь описанных выше функций:

[.programlisting]
....
Key F13	FTIWS	A	Iconify
Key F14	FTIWS	A	RaiseLower
Key F15	A	A	Menu Workplace Nop
....

=== Как заставить работать аппаратное ускорение 3D-графики для OpenGL(R)?

Наличие 3D-ускорения зависит от версии сервера Xorg и типа графического адаптера. Для адаптера nVidia используйте двоичный драйвер для FreeBSD, установив один из нижеследующих портов:

Последние версии адаптеров nVidia поддерживаются портом package:x11/nvidia-driver[].

Более старые драйверы доступны как package:x11/nvidia-driver-###[].

nVidia предоставляет подробную информацию о том, какие адаптеры поддерживаются тем или иным драйвером, на своём сайте: http://www.nvidia.com/object/IO_32667.html[http://www.nvidia.com/object/IO_32667.html].

Для адаптеров Matrox G200/G400 следует попробовать порт package:x11-servers/mga_hal[].

Для ATI Rage 128 и Radeon посмотрите страницы Справочника man:ati[4], man:r128[4] и man:radeon[4].

== Работа в сети

=== Где можно найти информацию о бездисковой загрузке?

"Бездисковая загрузка" означает, что машина с FreeBSD загружается по сети и читает необходимые файлы с сервера, а не со своего диска. Подробное описание есть в link:{handbook}#network-diskless/[ соответствующей главе] Руководства.

=== Может ли машина с FreeBSD использоваться как маршрутизатор?

Да. Обратитесь к разделу Руководства, посвящённому link:{handbook}#advanced-networking/[сложным вопросам работы в сети], особенно в той части, что касается link:{handbook}#network-routing/[маршрутизации и маршрутизаторов].

=== Можно ли подключить машину с Windows(R) к Internet с помощью FreeBSD?

Как правило, те, кто задают такие вопросы, имеют дома два компьютера, один с FreeBSD, а другой с какой-то версией Windows(R). Идея состоит в использовании FreeBSD для подключения к Internet, а затем осуществлять выход в Internet из Windows(R) через FreeBSD. На самом деле это просто частный случай предыдущего вопроса, который хорошо отработан.

Для подключения к Internet с использованием коммутируемого соединения нужно указать параметр `-nat` и установить в файле [.filename]#/etc/rc.conf# переменную `gateway_enable` в значение _YES_. Для получения дополнительной информации обратитесь к страницам справочной системы по команде man:ppp[8] или link:{handbook}#userppp/[ разделу Руководства о PPP режима пользователя].

Если подключение к Internet выполняется через Ethernet, используйте man:natd[8]. Вводная информация находится в разделе Руководства link:{handbook}#network-natd/[natd].

=== Поддерживает ли FreeBSD протокол PPP?

Да. man:ppp[8] может обслуживать как входящие, так и исходящие соединения.

Более подробная информация об их использовании находится в link:{handbook}#ppp-and-slip/[разделе Руководства о протоколе PPP].

=== Поддерживает ли FreeBSD технологию NAT или Masquerading?

Да. Для получения указаний по использованию NAT через подключение PPP обратитесь к link:{handbook}#userppp/[разделу Руководства о PPP]. Чтобы использовать NAT вместе с другим типом сетевого подключения, взгляните на раздел Руководства link:{handbook}#network-natd/[natd].

=== Как настроить алиас в сети Ethernet?

Если алиас находится в той же самой сети, что и уже настроенный на интерфейсе адрес, допишите к этой команде `netmask 0xffffffff`:

[source,bash]
....
# ifconfig ed0 alias 192.0.2.2 netmask 0xffffffff
....

В противном случае укажите сетевой адрес и маску обычным образом:

[source,bash]
....
# ifconfig ed0 alias 172.16.141.5 netmask 0xffffff00
....

Дополнительная информация находится в link:{handbook}#configtuning-virtual-hosts/[Руководстве] FreeBSD.

=== Почему я не могу смонтировать диск Linux(R) по NFS?

Некоторые версии NFS для Linux(R) поддерживают запросы на монтирование только с привилегированного порта; попробуйте выполнить следующую команду:

[source,bash]
....
# mount -o -P linuxbox:/blah /mnt
....

=== Почему mountd продолжает выдавать сообщения can't change attributes и bad exports list на моём сервере NFS, работающем под управлением FreeBSD?

В большинстве случаев проблема заключается в недостаточном понимании корректного формата файла [.filename]#/etc/exports#. Просмотрите ещё раз справочную информацию по man:exports[5] и раздел об link:{handbook}#network-nfs/[NFS] в Руководстве, особенно в части link:{handbook}#configuring-nfs[настройки NFS].

=== Как включить поддержку multicast IP?

Установите пакет package:net/mrouted[] и добавьте `mrouted_enable="YES"` в [.filename]#/etc/rc.conf# для запуска этого сервиса во время загрузки.

=== Почему я должен использовать FQDN для хостов не в моей сети?

За ответом на этот вопрос обращайтесь к link:{handbook}#mail-trouble/[Руководству] FreeBSD.

=== Permission denied для любых действий, связанных с работой сети.

Если ядро скомпилировано с параметром `IPFIREWALL`, имейте в виду, что политикой по умолчанию является запрет прохождения всех пакетов, которые явно не разрешены.

Если межсетевой экран был случайно сконфигурирован неверным образом, то для восстановления работоспособности сети наберите такую команду из-под пользователя `root`:

[source,bash]
....
# ipfw add 65534 allow all from any to any
....

Рассмотрите использование `firewall_type='open'` в файле [.filename]#/etc/rc.conf#.

Дополнительная информация о настройке данного межсетевого экрана находится в link:{handbook}#firewalls-ipfw/[соответствующей главе] Руководства.

=== Почему моё правило fwd для ipfw по перенаправлению сервиса на другую машину не работает?

Возможно, потому, что вместо простого перенаправления пакетов нужна трансляция сетевых адресов (NAT). Правило "fwd" только перенаправляет пакеты и данные внутри него не меняет. Рассмотрим такое правило:

[source,bash]
....
01000 fwd 10.0.0.1 from any to foo 21
....

Когда пакет с адресом назначения _foo_ достигает машины с этим правилом, пакет перенаправляется на _10.0.0.1_, но в нём остаётся адрес назначения _foo_. Адрес назначения пакета не меняется на _10.0.0.1_. Большинство машин, скорее всего, отбросят полученный пакет, имеющий адрес назначения, им не соответствующий. Таким образом, правило "fwd" не часто работает так, как ожидает пользователь. Такое поведение является особенностью, а не ошибкой.

Обратитесь к <<service-redirect,FAQ о перенаправлении сервисов>>, руководству по man:natd[8] или одной из нескольких утилит для перенаправления из link:https://www.FreeBSD.org/ports/[Коллекции Портов] для того, чтобы сделать это правильно.

=== Как можно перенаправить запросы с одной машины на другую?

Запросы FTP и других сервисов можно перенаправить с помощью порта package:sysutils/socket[]. Замените запись для этого сервиса в [.filename]#/etc/inetd.conf# на вызов `socket`, как показано в этом примере для ftpd:

[.programlisting]
....
ftp stream tcp nowait nobody /usr/local/bin/socket socket ftp.example.com ftp
....

где _ftp.example.com_ и _ftp_ являются соответственно хостом и портом для перенаправления.

=== Где можно найти средства управления сетевым трафиком?

Для FreeBSD имеются три средства управления трафиком. man:dummynet[4] интегрирован в систему FreeBSD как составная часть man:ipfw[4]. http://www.sonycsl.co.jp/person/kjc/programs.html[ ALTQ] включен во FreeBSD как составная часть man:pf[4]. Bandwidth Manager компании http://www.etinc.com/[Emerging Technologies] является коммерческим продуктом.

=== Почему появляются сообщения /dev/bpf0: device not configured?

Для работы приложения требуется Berkeley Packet Filter (man:bpf[4]), однако это устройство удалено из вашего ядра. Постройте новое ядро с добавлением в его конфигурационный файл следующей строки:

[.programlisting]
....
device bpf	# Berkeley Packet Filter
....

=== Как смонтировать диск Windows(R)-машины в моей локальной сети, как это делает smbmount в Linux(R)?

Используйте пакет SMBFS. В него включён набор изменений в ядре и пользовательские программы. Программы и информация доступны как man:mount_smbfs[8] и входят в состав базовой системы.

=== Что значат сообщения Limiting icmp/open port/closed port response в файле журнала?

Данное сообщение ядра означает, что имеет место некоторая активность, приводящая к отправке большого количества ответных пакетов ICMP или сбросов TCP (RST). Ответы ICMP часто генерируются в результате попыток подключения к незанятым портам UDP. Сбросы TCP генерируются в результате попыток подключения к закрытым портам TCP. Помимо всего прочего, такие сообщения могут быть вызваны следующими действиями:

* Лобовая атака типа отказ в обслуживании DoS (в отличие от атак в один пакет, которые используют конкретную брешь в защите).
* Сканирование портов в попытке осуществить подключение к большому количеству портов (в отличие от проб нескольких известных портов).

Первое число в сообщении показывает количество пакетов, которое ядро посылало бы при отсутствии ограничений, а второе число указывает лимит. Этот лимит меняется при помощи `net.inet.icmp.icmplim`. В этом примере устанавливается лимит на `300` пакетов в секунду:

[source,bash]
....
# sysctl net.inet.icmp.icmplim=300
....

Для выключения подобных сообщений без отключения самого ограничения используйте `net.inet.icmp.icmplim_output`, чтобы подавить вывода:

[source,bash]
....
# sysctl net.inet.icmp.icmplim_output=0
....

И наконец, чтобы полностью выключить это ограничение, сделайте `net.inet.icmp.icmplim` равным `0`. Выключение этого лимита не приветствуется по причинам, изложенным выше.

=== Что это за сообщения arp: unknown hardware address format?

Это означает, что какое-то устройство в локальной сети Ethernet использует MAC-адрес в формате, неизвестном FreeBSD. Вероятно, это происходит из-за того, что кто-то в сети экспериментирует с сетевым адаптером. Чаще всего это происходит в сетях с кабельными модемами. Это безобидно и не должно влиять на производительность системы FreeBSD.

=== Почему я постоянно вижу сообщения вида 192.168.0.10 is on fxp1 but got reply from 00:15:17:67:cf:82 on rl0 и как мне их отключить?

Это так, потому что пакет приходит извне сети, чего не должно быть. Чтобы отключить эти сообщения, установите `net.link.ether.inet.log_arp_wrong_iface` в значение `0`.

== Безопасность

=== Что означает термин sandbox (песочница)?

"Sandbox" - это термин, используемый при обеспечении безопасности. Он имеет два значения:

* Процесс, помещённый внутрь некоторых виртуальных стен, которые предназначены для предотвращения взлома всей системы в результате взлома этого конкретного процесса.
+ 
Процесс может работать в границах этих стен. Поскольку, что бы этот процесс ни делал, он эти стены разрушить не может, особый аудит его кода не нужен для того, чтобы с уверенностью сказать, насколько его работа безопасна для системы.
+ 
Стеной может служить, например, идентификатор пользователя. Вот определение, даваемое на страницах Справочника man:security[7] и man:named[8].
+ 
Рассмотрим, например, службу `ntalk` (смотрите man:inetd[8]). Раньше эта служба запускалась с идентификатором пользователя `root`, а сейчас - `tty`. Пользователь `tty` - это та песочница, которая осложняет взлом системы через `ntalk` посредством использования этого идентификатора пользователя.
* Процесс, помещённый внутрь симулируемой машины. Это даёт больший уровень безопасности. Это означает, что некто, взломавший процесс, может думать, что может сломать и систему в целом, однако фактически может сломать только симулятор этой машины и не может модифицировать никаких реальных данных.
+ 
Самым распространённым способом достигнуть такого результата является построение имитирующего окружения в каталоге и затем запуск процессов в этом каталоге через chroot (т.е. задав этот каталог в качестве [.filename]#/# для этого процесса, а не реальный [.filename]#/# всей системы).
+ 
Другим часто используемым методом является монтирование низлежащей файловой системы в режиме "только для чтения" и затем создание уровня файловой системы поверх неё, что даёт процессу видимость доступа по записи на ту файловую систему. Процесс будет полагать, что может записывать в те файлы, но это будет единственный процесс, который увидит результат - другие процессы не будут этого делать ни в коем случае.
+ 
Попытка сделать такой тип песочницы настолько прозрачна, что пользователь (или взломщик) даже не поймёт, что он в ней находится.

В UNIX(R) реализованы два типа "песочниц". Один на уровне процесса, и один на уровне идентификаторов пользователей.

Каждый процесс в UNIX(R) полностью защищён от других процессов. Никакой процесс не может модифицировать адресное пространство другого процесса.

В UNIX(R) каждым процессом владеет некоторый идентификатор пользователя. Если этот пользователь не `root`, он ограждает процесс от других, владельцами которых являются другие пользователи. Этот идентификатор используется также для защиты данных на диске.

=== Что такое уровень защиты (securelevel)?

`securelevel` является механизмом обеспечения безопасности, который реализован в ядре. Когда уровень защиты больше нуля, ядро ограничивает выполнение некоторых операций; даже суперпользователю `root` запрещается их выполнять. Механизм уровня защиты ограничивает возможности по:

* снятию некоторых флагов с файлов, таких, как `schg` (системный флаг неизменяемости),
* записи в память ядра через устройства [.filename]#/dev/mem# и [.filename]#/dev/kmem#,
* загрузке модулей ядра и
* изменению правил сетевого экрана.

Для выяснения состояния уровня защиты в работающей системе:

[source,bash]
....
# sysctl -n kern.securelevel
....

Результат содержит текущее значение уровня защиты. Если оно больше нуля, то по крайней мере некоторые из защит этого механизма включены.

Уровень защиты работающей системы не может быть понижен, поскольку это противоречит назначению этого механизма. Если для задачи требуется неположительный уровень защиты, измените значения переменных `kern_securelevel` и `kern_securelevel_enable` в файле [.filename]#/etc/rc.conf# и перезагрузите систему.

Более подробная информация об уровнях защиты и о том, какие специфические действия выполняют все уровни, может быть найдена на справочных страницах о man:init[8].

[WARNING]
====

Уровень защиты не является панацеей; в нём есть много недостатков. Зачастую он даёт обманчивое чувство безопасности.

Одной из самых больших проблем является то, что для его эффективной работы все файлы, используемые в процессе загрузки, должны быть защищены. Если атакующий сможет заставить систему выполнять свой код до установки уровня защиты (что происходит достаточно поздно во время процесса загрузки, так как некоторые вещи, выполняемые системой в это время, не могут быть сделаны при повышенном уровне защиты), то эта защита может быть отключена. Хотя такая задача по защите всех файлов, используемых в процессе загрузки, технически вполне осуществима, если это будет сделано, то поддержка системы станет кошмаром, так как для изменения конфигурационного файла придётся останавливать систему, переводя её по крайней мере в однопользовательский режим.

Это обстоятельство, а также ряд других, часто обсуждаются в списках рассылки, в частности, во {freebsd-security}. Поищите в link:https://www.FreeBSD.org/search/[ архивах] более подробное обсуждение. Предпочтителен более гибкий механизм.
====

=== BIND (named) работает на одном из портов с большим номером. Что происходит?

Для исходящих запросов BIND использует случайно выбираемый порт с большим номером. В последних версиях при каждом запросе выбирается новый случайный порт UDP. Это может вызвать проблемы в некоторых сетевых конфигурациях, особенно если фаервол блокирует входящие UDP пакеты на определенных портах. Чтобы обеспечить прохождение пакетов через фаервол, попробуйте параметры `avoid-v4-udp-ports` и `avoid-v6-udp-ports`, чтобы предотвратить случайный выбор номеров портов, пересекающихся с блокируемым диапазоном.

[WARNING]
====

Если в [.filename]#/etc/namedb/named.conf# указан номер порта (такой как 53) в параметре `query-source` или `query-source-v6`, то случайный выбор порта использоваться не будет. Настоятельно рекомендуется, чтобы эти параметры не использовались для указания фиксированных номеров порта.
====

Кстати, поздравляем. Прекрасно, что вы читаете вывод команды man:sockstat[1] и обращаете внимание на аномалии!

=== Даемон Sendmail ждёт соединений как на стандартном порту 25, так и на порту 587! Что происходит?

Последние версии Sendmail поддерживают механизм посылки почты, который работает по порту 587. Эта возможность пока широко не используется, но её популярность растёт.

=== Что это за пользователь toor с UID 0? Я подвергся взлому?

Не волнуйтесь, `toor` является "альтернативной" учётной записью суперпользователя (toor - это root, записанный задом наперёд). Его предлагается использовать с нестандартным командным интерпретатором, так чтобы не нужно было менять используемый по умолчанию командный процессор для `root`. Это важно, так как оболочки, не являющиеся частью дистрибутива системы, устанавливаются в каталог [.filename]#/usr/local/bin#, который по умолчанию располагается в другой файловой системе. Если командный процессор для пользователя `root` располагается в [.filename]#/usr/local/bin# и файловая система, содержащая [.filename]#/usr/local/bin#, не смонтирована, то `root` не сможет войти в систему для исправления проблемы и понадобится перезагрузиться в однопользовательском режиме, чтобы указать командный процессор.

Некоторые используют `toor` для выполнения повседневных административных работ с нестандартным командным процессором, оставляя `root` со стандартной оболочкой для работы в однопользовательском режиме или выполнения аварийных работ. По умолчанию пользователь не сможет войти в систему как `toor`, потому что для него не указан пароль, поэтому войдите из-под `root` и установите пароль для `toor` до того как использовать его для входа в систему.

== PPP

=== Не могу заставить работать ppp. Что я делаю не так?

Первым делом прочтите страницу Справочника man:ppp[8] и link:{handbook}#ppp-and-slip[раздел PPP] Руководства. Для помощи с устранением неполадок включите протоколирование следующей командой:

[.programlisting]
....
set log Phase Chat Connect Carrier lcp ipcp ccp command
....

Эту команду можно набрать в командной строке man:ppp[8] или ввести в начале раздела `default` в [.filename]#/etc/ppp/ppp.conf#. Проверьте, что файл [.filename]#/etc/syslog.conf# содержит указанные ниже строки и существует файл [.filename]#/var/log/ppp.log#:

[.programlisting]
....
!ppp
*.*    /var/log/ppp.log
....

Полную информацию о происходящем можно найти в файле протокола. Не беспокойтесь, если не всё будет понятно, ведь это может быть понятно кому-то ещё.

=== Ppp просто зависает, когда я его запускаю

Обычно это происходит, когда имя хоста не может быть преобразовано в адрес. Наилучший способ исправить это - удостовериться, что файл [.filename]#/etc/hosts# читается первым. Для этого нужно проверить, что в файле [.filename]#/etc/host.conf# на первом месте стоит строчка `hosts`. Затем добавьте в файл [.filename]#/etc/hosts# запись о локальной машине. Если локальная сеть отсутствует, измените строку для `localhost`:

[.programlisting]
....
127.0.0.1	foo.example.com foo localhost
....

В противном случае добавьте для хоста ещё одну запись. Обратитесь к соответствующим страницам Справочника за подробным описанием.

В конце убедитесь, что эта команда выполняется успешно: `ping -c1 hostname`.

=== Ppp не звонит в режиме -auto

Сначала проверьте наличие маршрута по умолчанию. Команда `netstat -rn` должна показать две строки:

[.programlisting]
....
Destination	Gateway	    Flags    Refs     Use     Netif Expire
default 	10.0.0.2    UGSc	0	0      tun0
10.0.0.2	10.0.0.1    UH		0	0      tun0
....

Если нет маршрута по умолчанию, убедитесь, что строка `HISADDR` была добавлена в [.filename]#/etc/ppp/ppp.conf#.

Другая причина отсутствия строки с маршрутом по умолчанию может крыться в том, что маршрут по умолчанию был добавлен в [.filename]#/etc/rc.conf#, и эта строка отсутствует в [.filename]#/etc/ppp/ppp.conf#:

[.programlisting]
....
delete ALL
....

В таком случае обратитесь к соответствующему link:{handbook}#userppp-final[разделу] Руководства.

=== Что означает сообщение No route to host?

Обычно эта ошибка появляется из-за отсутствия в файле [.filename]#/etc/ppp/ppp.linkup# следующего раздела:

[.programlisting]
....
MYADDR:
  delete ALL
  add 0 0 HISADDR
....

Он необходим только для динамического IP адреса или когда адрес маршрутизатора не известен. При использовании интерактивного режима можно набрать следующие команды после входа в пакетный режим. Пакетный режим обозначается заглавными буквами PPP в приглашении:

[.programlisting]
....
delete ALL
add 0 0 HISADDR
....

Обратитесь к разделу link:{handbook}#userppp-dynamicip[PPP и динамические IP адреса] Руководства за подробной информацией.

=== Соединение разрывается через 3 минуты

Таймаут для PPP по умолчанию равен 3 минутам. Это может быть изменено такой строкой:

[.programlisting]
....
set timeout NNN
....

где _NNN_ - время неактивности в секундах, после которого соединение закрывается. Если _NNN_ равно нулю, соединение никогда не разрывается по таймауту. Эту команду можно поместить в файл [.filename]#ppp.conf# или набрать ее в интерактивном режиме. Изменение этого параметра также возможно при активном соединении, если подключиться к сокету ppp сервера с помощью программ man:telnet[1] или man:pppctl[8]. Обратитесь к страницам Справочника, посвящённым man:ppp[8].

=== Соединение разрывается при большой нагрузке

Если включен Link Quality Reporting (LQR), то возможно слишком много пакетов LQR теряется в канале. man:ppp[8] делает вывод, что канал плох, и разрывает соединение. LQR по умолчанию выключен. Включить LQR можно так:

[.programlisting]
....
enable lqr
....

=== Соединение разрывается в случайные промежутки времени

Иногда на шумной линии или даже на линии с включенным режимом ожидания звонка модем может вешать трубку, ошибочно полагая, что потеряна несущая.

В большинстве модемов есть параметр, определяющий чувствительность к временной потере несущей. Обратитесь к документации модема.

=== Соединение часто рвётся в случайные промежутки времени

Многие сообщают об обрывах соединений без видимой причины. Первым делом нужно выяснить, с какой стороны рвётся соединение.

При использовании внешнего модема проверьте утилитой man:ping[8], мигает ли индикатор TD при передаче данных. Если он мигает, а индикатор RD нет, проблема с той стороны. Если TD не загорается, проблема является локальной. Для внутреннего модема используйте команду `set server` в [.filename]#ppp.conf#. При обрыве связи подключитесь к man:ppp[8] с помощью man:pppctl[8]. Если сетевое подключение неожиданно восстанавливается при проявлении активности на диагностическом сокете или нет соединения, но команда `set socket` в начальный момент была выполнена успешно, то проблема имеет локальный характер. Если получается подключиться, но связи всё равно нет, включите вывод локальной отладочной информации командой `set log local async` и используйте man:ping[8] в другом окне или терминале, чтобы проверить связь. В отладочном выводе будут показаны данные, передаваемые и получаемые из канала связи. Если данные посылаются, но не принимаются обратно, то проблема с той стороны.

Теперь, после выяснения местонахождения проблемы, имеется два варианта действий:

* Если проблема на удалённой машине, то прочтите <<ppp-remote-not-responding>>.
* Если проблема с вашей стороны, прочтите <<ppp-hung>>.

[[ppp-remote-not-responding]]
=== Удалённая система не отвечает

Здесь мало что можно сделать. Большинство провайдеров отказываются помогать пользователям, которые не используют ОС от Microsoft(R). Добавьте `enable lqr` в [.filename]#/etc/ppp/ppp.conf#, чтобы позволить man:ppp[8] отследить ошибки в удалённой системе и закрыть соединение. Такое обнаружение достаточно медленно и поэтому не так уж полезно.

Первым делом попробуйте отключить любое сжатие, указав в конфигурационном файле следующее:

[.programlisting]
....
disable pred1 deflate deflate24 protocomp acfcomp shortseq vj
deny pred1 deflate deflate24 protocomp acfcomp shortseq vj
....

Теперь попробуйте установить соединение ещё раз и удостоверьтесь, что ситуация не изменилась. Если качество соединения улучшилось или проблема оказалась полностью решённой, выясните, настройка чего приводила к проблемам методом проб и ошибок. Это полезная информация для провайдера, хотя при этом может обнаружиться, что вы работаете не с продуктом Microsoft(R).

Перед тем, как звонить провайдеру, включите вывод отладочной информации и подождите, пока соединение снова не прервётся. Для этого может потребоваться некоторое дисковое пространство. Интерес могут представлять последние прочитанные из порта данные. Обычно это данные в формате ASCII и они могут даже содержать описание проблемы (`Memory fault`, `Core dumped`).

Если провайдер согласен помочь, нужно будет включить режим отладки с их стороны, и затем, когда связь прервётся в следующий раз, они смогут сказать, почему с их стороны возникли проблемы.

[[ppp-hung]]
=== Ppp зависает

В этом случае перекомпилируйте man:ppp[8] с отладочной информацией, и затем используйте man:gdb[1] для получения стека вызовов для зависшего процесса ppp. Чтобы откомпилировать программу ppp с отладочной информацией, наберите такие команды:

[source,bash]
....
# cd /usr/src/usr.sbin/ppp
# env DEBUG_FLAGS='-g' make clean
# env DEBUG_FLAGS='-g' make install
....

Затем перезапустите ppp и дождитесь следующего зависания. Когда отладочная сборка man:ppp[8] зависнет, запустите gdb для зависшего процесса:

[source,bash]
....
# gdb ppp `pgrep ppp`
....

В приглашении gdb используйте команду `bt` или `where` для получения стека вызовов. Сохраните вывод сессии gdb и "отключитесь" от работающего процесса, выполнив команду `quit` в gdb.

=== В протоколе есть сообщения о том, что magic being the same.

Иногда, сразу после установления соединения, в журнале могут возникать сообщения `Magic is the same`. Иногда эти сообщения проходят безболезненно, а иногда одна из сторон прекращает работу. Большинство реализаций PPP не может справиться с такой ситуацией, и даже когда связь выглядит установившейся, вы будeт только бесконечно повторяющиеся конфигурационные запросы и подтверждения в файле протокола до тех пор, пока man:ppp[8] окончательно не закроет соединение.

Обычно это происходит на серверах с медленными дисками, на которых порт обслуживает программа man:getty[8], а man:ppp[8] выполняется из сценария регистрации или другой программы после регистрации пользователя. Были сообщения, что такое случается постоянно при использовании slirp. Причина заключается в том, что во время, проходящее между завершением работы man:getty[8] и запуском man:ppp[8], man:ppp[8] со стороны клиента начинает посылать пакеты Line Control Protocol (LCP). Так как режим эха остаётся всё ещё включенным, man:ppp[8] клиента получает "отражения" своих запросов.

Частью процесса согласования параметров LCP является определение "магического" числа для каждой стороны соединения для обнаружения "отражений". Согласно спецификации, когда одна сторона пытается использовать совпадающее "магическое" число, должен быть послан ответ NAK и должно быть выбрано новое "магическое" число. В тот момент, когда на порту сервера включен режим эха, клиент man:ppp[8] посылает пакеты LCP, получает то же самое "магическое" число в отражённом пакете и отвечает на него NAK. Он также видит отражённый NAK (который также означает, что man:ppp[8] должен изменить своё "магическое" число). В потенциале это может вызвать появление огромного количества процессов смен "магических" чисел, и все они накапливаются в буфере терминала. Как только запустится сервер man:ppp[8], он будет перегружен запросами на смену "магических", немедленно решит, что этого много для согласования LCP и прервёт соединение. В то же самое время, клиент, который больше не видит отражений, останавливается для того, чтобы увидеть, что сервер закрыл соединение.

Этого можно избежать, позволив начинать согласование противоположной стороне следующей строкой в файле [.filename]#ppp.conf#:

[.programlisting]
....
set openmode passive
....

Это заставит man:ppp[8] ожидать начала согласования LCP. Некоторые серверы, однако, могут никогда не начать согласование. В этом случае попробуйте сделать следующее:

[.programlisting]
....
set openmode active 3
....

Это заставит man:ppp[8] пассивно ждать 3 секунды, и только затем посылать запросы LCP. Если противоположная сторона начнёт посылать в этот момент запросы, man:ppp[8] немедленно ответит, не ожидая истечения трёхсекундного интервала.

=== Согласование LCP продолжается, пока не закроется соединение

В настоящий момент одной из неприятных особенностей реализации man:ppp[8] является то, что она не связывает сообщения LCP, CCP & IPCP с запросами. Как результат, если реализация PPP с одной стороны более чем на 6 секунд медленнее, чем с другой, противоположная сторона будет посылать два дополнительных запроса на согласование параметров LCP. Это фатально.

Предположим, что у нас работают две реализации, на машинах `A` и `B`. `A` начинает посылать запросы LCP сразу же после соединения, а `B` требуется 7 секунд для запуска. Когда `B` запускается, `A` послало 3 LCP-запроса. Полагаем, что режим эха выключен, в противном случае мы столкнулись бы с проблемами "магического" числа, описанными в предыдущем разделе. `B` посылает REQ, затем ACK на первый REQ от `A`. Это приводит к тому, что `A` входит в состояние OPENED и посылает (первый) ACK обратно `B`. В то же самое время `B` посылает обратно ещё два ACK в ответ на два дополнительных REQ, посланные `A` до старта `B`. `B` затем получает первый ACK от `A` и возвращается в состояние REQ-SENT, послав ещё один (четвёртый) REQ согласно RFC. Затем он получает третий ACK и входит в состояние OPENED. В это же время `B` принимает четвёртый REQ от `A`, что возвращает его в состояние ACK-SENT и посылает ещё один (второй) REQ и (четвёртый) ACK согласно RFC. `A` получает REQ, переходит в состояние REQ-SENT и посылает ещё один REQ. Он немедленно принимает последующий ACK и входит в состояние OPENED.

Это будет продолжаться до тех пор, пока одна из сторон не обнаружит, что это ни к чему не приводит и не закроет соединение.

Лучшим способом избежать этой ситуации является конфигурация одной из сторон как `passive`, чтобы она ждала другую для начала согласования. Это можно сделать следующей командой:

[.programlisting]
....
set openmode passive
....

С этой командой нужно быть осторожным. Эту команду можно также использовать для ограничения периода ожидания, в течении которого man:ppp[8] ждёт начала согласования с противоположной стороны:

[.programlisting]
....
set stopped N
....

Как вариант, может быть использована следующая команда (где _N_ - период ожидания в секундах перед тем, как начать согласование):

[.programlisting]
....
set openmode active N
....

За дополнительной информацией обращайтесь к странице Справочника.

=== Когда я выполняю команду shell для тестирования соединения, ppp блокируется

При использовании `shell` или `!` man:ppp[8] запускает оболочку или переданные параметры. Программа ppp будет ждать окончания выполнения команды, прежде чем продолжить. При любой попытке воспользоваться связью PPP во время выполнения команды связь будет выглядеть заблокированной. Это происходит из-за того, что man:ppp[8] ждёт завершения команды.

Для выполнения подобных команд используйте вместо этого `!bg`. В этом случае нужная команда будет выполняться в фоновом режиме, а man:ppp[8] сможет продолжить обслуживание канала связи.

=== Почему программа ppp, обслуживающая нуль-модем, никогда не закрывается?

man:ppp[8] не может определить, что соединение было закрыто. Это происходит из-за метода использования сигнальных линий нуль-модемного кабеля. При использовании такого типа соединения всегда включайте LQR:

[.programlisting]
....
enable lqr
....

По умолчанию LQR включается, если это было затребовано с противоположной стороны на этапе согласования параметров соединения.

=== В режиме -auto ppp неожиданно начинает звонить

Если man:ppp[8] начинает неожиданно звонить, определите причину и настройте фильтры дозвона для предотвращения подобных звонков.

Для выяснения причины такого поведения, используйте строку:

[.programlisting]
....
set log +tcp/ip
....

Это включит протоколирование всего трафика через соединение. В следующий раз, когда неожиданно будет установлено соединение, в файл протокола будет следом занесена причина с отметкой времени.

Теперь отключите дозвон при данных условиях. Как правило, такие проблемы возникают из-за обращений к DNS. Для предотвращения обращений к DNS и установления соединения (что _не_ запретит man:ppp[8] пропускать пакеты через уже установленное соединение), используйте такую комбинацию:

[.programlisting]
....
set dfilter 1 deny udp src eq 53
set dfilter 2 deny udp dst eq 53
set dfilter 3 permit 0/0 0/0
....

Это не всегда удобно, так как закрывает возможность дозвона по запросу. Большинству программ нужно обратиться к DNS до того, как начать работать.

В случае DNS попытайтесь установить, что именно пытается определить имя хоста. В большинстве случаев виновным оказывается Sendmail. Проверьте, чтобы в конфигурационном файле программы Sendmail не было указано обращаться к DNS. Обратитесь к разделу об link:{handbook}#smtp-dialup/[использовании электронной почты при коммутируемом соединении] в Руководстве FreeBSD за подробным описанием. Вам может понадобиться добавить в файл [.filename]#.mc# строку:

[.programlisting]
....
define(`confDELIVERY_MODE', `d')dnl
....

Это заставит Sendmail добавлять все сообщения в очередь до тех пор, пока не будет запущена её обработка, как правило, каждые 30 минут, или пока не будет выполнена команда `sendmail -q`, возможно, из файла [.filename]#/etc/ppp/ppp.linkup#).

=== Что означают ошибки CCP

В файле протокола появляются такие сообщения об ошибках:

[.programlisting]
....
CCP: CcpSendConfigReq
CCP: Received Terminate Ack (1) state = Req-Sent (6)
....

Это происходит, если man:ppp[8] пытается установить сжатие Predictor1, а противоположная сторона не хочет устанавливать никакого сжатия. Эти сообщения безобидны, но их можно заглушить отключением сжатия:

[.programlisting]
....
disable pred1
....

=== Почему ppp не протоколирует скорость соединения?

Для записи полного протокола взаимодействия с модемом включите следующее:

[.programlisting]
....
set log +connect
....

Это заставит man:ppp[8] протоколировать всё, вплоть до последней прочтённой через "expect" строки.

Чтобы увидеть скорость соединения при использовании PAP или CHAP, укажите man:ppp[8] ожидать полную строку CONNECT:

[.programlisting]
....
set dial "ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 4 \
  \"\" ATZ OK-ATZ-OK ATDT\\T TIMEOUT 60 CONNECT \\c \\n"
....

Здесь мы получаем строку CONNECT, ничего не посылаем, а затем ожидаем символа перевода строки, заставляя man:ppp[8] читать целиком содержимое ответа CONNECT.

=== Ppp игнорирует символ \ в chat-скрипте

Программа ppp разбирает каждую строку в конфигурационных файлах и поэтому может правильно интерпретировать строки вида `set phone "123 456 789"` и обнаруживать, что на самом деле номер является единственным аргументом. Для того, чтобы указать символ `"`, заэкранируйте его символом обратного слэша (`\`).

Когда интерпретатор chat разбирает каждый параметр, он ещё раз просматривает аргумент на предмет каких-либо специальных последовательностей типа `\P` или `\T`. Вследствие этой двойной интерпретации не забывайте об использовании нужного количества экранирующих символов.

Чтобы передать сам символ `\`, укажите что-то типа:

[.programlisting]
....
set dial "\"\" ATZ OK-ATZ-OK AT\\\\X OK"
....

Это приведёт к такой последовательности:

[.programlisting]
....
ATZ
OK
AT\X
OK
....

Или:

[.programlisting]
....
set phone 1234567
set dial "\"\" ATZ OK ATDT\\T"
....

Это даст такую последовательность:

[.programlisting]
....
ATZ
OK
ATDT1234567
....

=== Процесс, вызвавший прозвонку в режиме -auto, никогда не получает затребованного соединения

Эта проблема проявлялась, когда man:ppp[8] в режиме `-auto` был настроен на динамическое согласование локального IP-адреса с противоположной стороной. Это было давно исправлено - поищите на странице справочника слово `iface`.

Причиной было то, что когда эта программа использует системный вызов man:connect[2], для сокета назначается IP-адрес интерфейса man:tun[4]. Ядро создаёт первый исходящий пакет и записывает его в устройство man:tun[4]. Затем man:ppp[8] читает пакет и устанавливает соединение. Если в результате согласования man:ppp[8] динамического IP-адреса адрес интерфейса изменится, сокет будет работать некорректно. Любые IP-пакеты, передаваемые через сокет, будут отброшены. Если даже этого не произойдёт, ответные данные не будут достигать отправителя, так как этот адрес больше ему не принадлежит.

Теоретически есть несколько способов решить эту проблему. Лучше всего, если противоположная сторона назначит интерфейсу тот же самый IP-адрес. Текущая версия man:ppp[8] именно так и поступает, но большинство других реализаций этого не делают.

Самым простым решением будет просто никогда не менять IP-адрес интерфейса man:tun[4], а вместо этого изменять на лету все исходящие пакеты так, чтобы IP-адрес источника менялся с IP-адреса интерфейса на соответствующий с противоположной стороны. Это, в сущности, то же самое, что делает опция `iface-alias` в самой последней версии man:ppp[8] (с помощью библиотеки man:libalias[3] и ключа `-nat` для man:ppp[8]) - она отслеживает все назначенные ранее интерфейсу адреса и замещает их на последний из назначенных.

Другой возможный (и, наверное, самый надёжный) способ - это создать системный вызов, меняющий IP-адреса всем уже связанным сокетам. man:ppp[8] использовал бы этот вызов для модификации сокетов всех работающих программ после согласования нового IP-адреса. Этот же самый системный вызов могли бы использовать клиенты DHCP, когда они осуществляют повторную привязку к сокету, вызывая для этого функцию `bind()`.

Ещё одной возможностью является разрешение интерфейсу становиться активным без IP-адреса. Исходящим пакетам будет даваться IP адрес `255.255.255.255` до первого вызова man:ioctl[2] `SIOCAIFADDR`, приводящего к полной привязке сокета. man:ppp[8] нужно будет изменять исходящий IP-адрес и контрольную сумму пакета, только если он установлен в `255.255.255.255`. Это, однако, является некоторым хаком, так как ядро будет посылать некорректные пакеты на не полностью сконфигурированный интерфейс, в предположении, что существует механизм исправления этих пакетов.

=== Что такое ошибки FCS?

FCS является сокращением от Frame Check Sequence (контроль последовательности кадров). Каждый кадр PPP имеет контрольную сумму для проверки того, что принятые данные совпадают с переданными. Если FCS принятого пакета некорректна, пакет отбрасывается и счётчик FCS для HDLC увеличивается. Значения ошибок уровня HDLC можно вывести командой `show hdlc`.

Если линия плохого качества или драйвер коммуникационного адаптера отбрасывает пакеты, будут появляться случайные ошибки FCS. Это обычно не является причиной для волнений, хотя это существенно замедляет протоколы компрессии.

Если связь замирает сразу при установлении соединения и наблюдается большое количество ошибок FCS, убедитесь, чтобы модем не использовал программное управление потоком (XON/XOFF). Если же для соединения должно использоваться программное управление потоком, то воспользуйтесь командой `set accmap 0x000a0000` для указания man:ppp[8] экранировать символы `^Q` и `^S`.

Другой причиной слишком большого количества ошибок FCS может быть прекращение противоположной стороной сеанса PPP. В этом случае включите протоколирование `async` для проверки того, не являются ли поступаемые из линии данные на самом деле приглашением login или shell. Если с противоположной стороны находится приглашение shell, завершить man:ppp[8] без обрыва связи можно командой `close lcp` и последующей командой `term`, чтобы переподключиться к приглашению shell на удалённой машине.

Если ничего в файле протокола не говорит о причине разрыва связи, спросите у администратора удалённой машины или вашего провайдера, почему сеанс был закрыт.

=== Ничего не помогает - я уже отчаялся!

Если всё уже перепробовано, и ничего не получается, пошлите подробности об ошибке, конфигурационные файлы, способ запуска man:ppp[8], соответствующие части файла протокола, и вывод команды `netstat -rn` до и после соединения в {freebsd-questions}.

== Коммуникационные адаптеры

В этом разделе освещены вопросы о работе последовательных адаптеров во FreeBSD. Протокол PPP рассматривается в разделе <<networking,Работа в сети>>.

=== Какие многопортовые последовательные адаптеры поддерживаются во FreeBSD?

Список таких устройств находится в главе Руководства link:{handbook}#serial/[Последовательные соединения].

Большинство многопортовых PCI адаптеров на базе 16550 и их клоны поддерживаются без дополнительных усилий.

Некоторые безымянные клоны таких адаптеров тоже работают нормально, особенно те, которые заявляют о своей совместимости с AST.

Прочтите страницы Справочника man:uart[4] и man:sio[4] для получения подробной информации о конфигурировании таких адаптеров.

=== Как сделать, чтобы приглашение boot: выводилось на консоль на последовательном порту?

Подробная информация находится в link:{handbook}#serialconsole-setup/[этом разделе Руководства].

=== Как узнать, обнаружила ли FreeBSD последовательные порты или внутренние модемы?

В процессе своей загрузки ядро FreeBSD будет пытаться найти последовательные порты, с поддержкой которых ядро сконфигурировано. Внимательно просмотрите сообщения загрузки либо выполните такую команду после того, как система запустилась и работает:

[source,bash]
....
% dmesg | grep -E "^sio[0-9]"
sio0: <16550A-compatible COM port> port 0x3f8-0x3ff irq 4 flags 0x10 on acpi0
sio0: type 16550A
sio1: <16550A-compatible COM port> port 0x2f8-0x2ff irq 3 on acpi0
sio1: type 16550A
....

Здесь присутствуют два последовательных порта. Первый находится на IRQ4, порт ввода/вывода `0x3f8`, и построен на микросхеме UART типа 16550A. Второй использует тот же тип микросхемы, но находится на IRQ3 и использует адрес порта ввода/вывода `0x2f8`. Внутренние модемы выглядят точно также, как последовательные порты, за исключением того, что модем к ним подключен всегда.

В ядро [.filename]#GENERIC# встроена поддержка двух последовательных портов, с теми же IRQ и адресами портов ввода/вывода, как указано в примере выше. Если эти настройки не соответствуют системе или имеется больше внутренних модемов или последовательных портов, чем описано в ядре, переконфигурируйте его, следуя инструкциям в разделе <<make-kernel,о построении ядра>>.

=== Как осуществляется доступ к последовательным портам во FreeBSD?

Третий последовательный порт, [.filename]#sio2# или [.filename]#COM3#, обозначается как [.filename]#/dev/cuad2# для устройств, выполняющих исходящие звонки, и [.filename]#/dev/ttyd2# для устройств, принимающих входящие звонки. Какая разница между этими двумя классами устройств?

При открытии [.filename]#/dev/ttydX# в блокирующем режиме процесс будет ожидать неактивности соответствующего устройства [.filename]#cuadX#, а затем появления сигнала о наличии несущей. При открытии устройства [.filename]#cuadX# он проверяет, что последовательный порт не занят устройством [.filename]#ttydX#. Если порт доступен, он похищает его у устройства [.filename]#ttydX#. Также устройство [.filename]#cuadX# не следит за наличием несущей. С такой схемой работы и модемом в режиме автоответа удалённые пользователи могут входить в систему, а локальные пользователи через тот же модем могут по прежнему осуществлять исходящие звонки, а система позаботится о возможных конфликтах.

=== Как включить поддержку многопортовых последовательных адаптеров?

Информация о конфигурировании ядра содержится в соответствующем разделе, посвящённом этому вопросу. Для многопортовых последовательных адаптеров добавьте в файл man:device.hints[5] по строке man:sio[4] на каждый порт. Но IRQ должен быть указан только у одного порта. Все порты на адаптере должны использовать одно и то же значение IRQ. Для обеспечения согласованности используйте для указания IRQ последний последовательный порт. Также укажите следующую опцию в файле конфигурации ядра:

[.programlisting]
....
COM_MULTIPORT
....

В следующем примере указано содержимое [.filename]#/boot/device.hints# для 4-портового последовательного адаптера AST на IRQ 12:

[.programlisting]
....
hint.sio.4.at="isa"
hint.sio.4.port="0x2a0"
hint.sio.4.flags="0x701"
hint.sio.5.at="isa"
hint.sio.5.port="0x2a8"
hint.sio.5.flags="0x701"
hint.sio.6.at="isa"
hint.sio.6.port="0x2b0"
hint.sio.6.flags="0x701"
hint.sio.7.at="isa"
hint.sio.7.port="0x2b8"
hint.sio.7.flags="0x701"
hint.sio.7.irq="12"
....

Флаги указывают, что управляющий порт имеет младший номер устройства `7` (`0x700`), и все порты совместно используют один и тот же номер IRQ (`0x001`).

=== Можно ли настроить для порта режим работы по умолчанию?

Смотрите раздел Руководства FreeBSD, посвящённый link:{handbook}#serial/#serial-hw-config[последовательным соединениям].

=== Как сделать вход через модем?

Ознакомьтесь с разделом Руководства FreeBSD, посвящённым link:{handbook}#dialup/[входящим соединениям].

=== Как подключить терминал к FreeBSD?

Информация по этому вопросу находится в разделе link:{handbook}#term/[Терминалы] Руководства FreeBSD.

=== Почему не удаётся запустить tip или cu?

Встроенные утилиты man:tip[1] и man:cu[1] могут получить доступ к каталогу [.filename]#/var/spool/lock# только из-под пользователя `uucp` и членов группы `dialer`. Используйте группу `dialer` для управления доступом к модему или удалённым системам посредством добавления в неё пользовательских учётных записей.

Либо же можно разрешить всем запускать man:tip[1] и man:cu[1]:

[source,bash]
....
# chmod 4511 /usr/bin/cu
# chmod 4511 /usr/bin/tip
....

== Разное

=== Почему FreeBSD использует много места в разделе подкачки даже при большом объёме свободной памяти?

FreeBSD активно перемещает неиспользуемые страницы памяти, к которым не было обращений, в раздел подкачки, чтобы увеличить объём доступной физической памяти для активного использования. Такое активное использование раздела подкачки компенсируется использованием дополнительной свободной оперативной памяти для кеширования.

Заметьте, что хотя FreeBSD предпочитает использовать раздел подкачки, страницы не перемещаются произвольно при полностью неактивной системе. По этой причине система не будет находиться целиком в разделе подкачки после ночного простаивания.

=== Почему утилита man:top[1] показывает очень маленький объём свободной памяти, даже когда запущено всего лишь несколько приложений?

Просто дело в том, что под свободной памятью подразумевается никак не используемая память. Вся память, которая программам явно не выделялась, используется ядром FreeBSD для дискового кэша. Значения, показываемые утилитой man:top[1], помеченные как `Inact`, `Cache` и `Buf` - это всё кэшированные данные разных степеней устаревания. То, что данные находятся в кэше, означает, что система не будет обращаться к медленному диску снова за теми данными, обращение к которым было недавно, повышая таким образом общую производительность. В общем случае маленькие значения в пункте `Free`, показываемые утилитой man:top[1] для свободной памяти - это хорошо, если, конечно они не _очень_ маленькие.

=== Почему командой chmod невозможно изменить права на символические ссылки?

Символические ссылки не имеют атрибутов доступа, и по умолчанию утилита man:chmod[1] следует по символической ссылке, чтобы по возможности изменить права доступа на исходный файл. Для файла [.filename]#foo# с символической ссылкой [.filename]#bar# на этот файл эта команда всегда будет выполняться успешно.

[source,bash]
....
% chmod g-w bar
....

Однако права на файл [.filename]#bar# не изменятся.

Чтобы это работало, используйте опцию `-H` или `-L` вместе с опцией `-R`. Обратитесь к страницам Справочника по команде man:chmod[1] и по man:symlink[7].

[WARNING]
====

Опция `-R` выполняет man:chmod[1] _рекурсивно_. Будьте внимательны, задавая каталоги или символические ссылки на каталоги в параметрах man:chmod[1]. Чтобы изменить права на каталог, на который указывает символическая ссылка, используйте man:chmod[1] без опций и следуйте символической ссылке с помощью лидирующего слэша ([.filename]#/#). Например, если [.filename]#foo# является символической ссылкой на каталог [.filename]#bar#, то чтобы изменить права на [.filename]#foo# (на самом деле на [.filename]#bar#), выполните такую команду:

[source,bash]
....
% chmod 555 foo/
....

Если задан ведущий слэш, то man:chmod[1] будет следовать символической ссылке [.filename]#foo#, меняя права на каталог [.filename]#bar#.
====

=== Можно ли запускать программы для DOS во FreeBSD?

Да. Программа эмуляции DOS package:emulators/doscmd[] включена в Коллекцию Портов FreeBSD.

Если doscmd не достаточно, package:emulators/pcemu[] эмулирует 8088 и набор сервисов BIOS, достаточный для запуска многих приложений текстового режима DOS. Требуется X Window System.

В Коллекции Портов FreeBSD также имеется package:emulators/dosbox[]. Программа в основном предназначена для эмуляции старых игр, написанных под DOS, для хранения файлов которых используется локальная файловая система.

=== Что мне нужно сделать, чтобы перевести документацию FreeBSD на родной язык?

Ознакомьтесь с link:{fdp-primer}#translations/[FAQ по Переводам] из FreeBSD Documentation Project Primer.

=== Почему возвращается моя электронная почта, отправленная на любой из адресов FreeBSD.org?

В почтовой системе `FreeBSD.org` в Postfix применяются некоторые проверки входящей почты, и отвергаются сообщения, которые были неправильно сформированы при пересылке либо как-то иначе похожи на спам. Некоторые из требований:

* IP-адрес клиента SMTP должен иметь обратное преобразование в символическое имя.
* Полное имя хоста, указанное на этапе EHLO/HELO в процессе обмена сообщениями SMTP, должно разрешаться в IP-адрес клиента.

Дополнительные советы по доставке письма:

* Письмо должно быть отправлено в текстовом формате. Сообщение в почтовый список рассылки, как правило, не должно иметь размер больше 200 Кбайт.
* Избегайте избыточного кросспостинга. Выберите _один_ список рассылки, который кажется наиболее подходящим.

Если у вас всё ещё остались трудности при работе с почтовой инфраструктурой `FreeBSD.org`, отправьте сообщение с подробным описанием на адрес mailto:postmaster@freebsd.org[postmaster@freebsd.org]. Укажите в нём временной интервал для проверки логов - и обратите внимание, что мы держим журнал почтовых логов всего за неделю. (Обязательно укажите часовой пояс или разницу в UTC.)

=== Где можно получить бесплатный доступ к FreeBSD?

Хотя FreeBSD не предоставляет бесплатный доступ ни к одному из своих серверов, другие компании предоставляют UNIX(R)-системы с открытым доступом. Стоимость этой услуги различна, также как и ограниченный набор услуг.

http://www.arbornet.org/[Arbornet, Inc], также известный как _M-Net_, предоставляет свободный доступ к UNIX(R)-системам с 1983 года. Начиная на платформе Altos с работающей System III, сайт перешёл на BSD/OS в 1991. В июне 2000 сайт сменил систему снова, теперь на FreeBSD. _M-Net_ может быть доступна через протоколы telnet и SSH и предоставляет доступ к полному набору программного обеспечения FreeBSD. Однако доступ к сети ограничен для членов и спонсоров, которые поддерживают систему, которая работает как неприбыльная организация. _M-Net_ предоставляет также услуги электронной доски объявлений (BBS) и интерактивного чата.

=== Как зовут этого маленького симпатичного красного парня?

У него нет определённого имени, он называется просто "даемон BSD". Если вам непременно нужно имя, называйте его "beastie". Заметьте, что "beastie" произносится как "BSD".

Больше о даемоне BSD можно узнать из его http://www.mckusick.com/beastie/index.html[домашней страницы].

=== Могу ли я использовать изображение даемона BSD?

Вполне. Права на даемона BSD имеет Marshall Kirk McKusick. Для выяснения подробностей относительно правил его использования обратитесь к странице автора http://www.mckusick.com/beastie/mainpage/copyright.html[Statement on the Use of the BSD Daemon Figure].

В общем, использовать изображение можно в высокохудожественном стиле и в личных целях, если даются соответствующие отсылки. Перед использованием знака в коммерческих целях обратитесь за разрешением к {mckusick}. Дополнительная информация находится на http://www.mckusick.com/beastie/index.html[домашней странице Даемона BSD].

=== Не найдется ли у вас изображений даемона BSD, которые можно использовать?

В каталоге [.filename]#/usr/shared/examples/BSD_daemon/# есть рисунки в форматах eps и Xfig.

=== При просмотре списков рассылки, я встретил акроним или другой термин, который мне не понятен. Где я должен посмотреть, что он значит?

Пожалуйста, обращайтесь к link:{handbook}#freebsd-glossary/[Глоссарию FreeBSD].

=== Почему я должен беспокоиться о цвете велосипедных навесов (bikeshed)?

На самом деле, очень краткий ответ на этот вопрос заключается в том, что вы этого делать не должны. Если давать более подробный ответ, то ваше умение делать навесы не должно означать, что вы должны препятствовать другим делать их просто потому, что вам не нравится цвет, в который они собираются их окрашивать. Эта метафора означает, что вам не нужно обсуждать каждую мелочь просто потому, что вы знаете о ней достаточно много. Некоторые люди отмечают, что объём шума, генерируемый при появлении некоторого изменения, находится в обратной зависимости от сложности самого изменения.

Более пространный и полный ответ заключается в том, что после очень долгого обсуждения того, должна ли утилита man:sleep[1] обрабатывать дробное число, заданное в качестве второго аргумента, {phk} опубликовал большое сообщение, озаглавленное "link:http://www.FreeBSD.org/cgi/getmsg.cgi?fetch=506636+517178+/usr/local/www/db/text/1999/freebsd-hackers/19991003.freebsd-hackers[Велосипедный навес (подставьте здесь цвет) на зелёной траве...]". Соответствующие части этого сообщения цитируются ниже.

{phk} on freebsd-hackers, October 2, 1999
"Что это за история с навесом для велосипеда?" Кто-то из вас задавал такой вопрос.

Это долгая история, или же это старая история, но на самом деле она коротка. В начале 1960-х годов Паркинсон (C. Northcote Parkinson) написал книгу "Закон Паркинсона", которая содержит много интересных взглядов на процесс управления.

_[немного выдержек из краткого содержания книги]_

В конкретном примере велосипедный навес сопоставляется с другим важным объектом - атомной электростанцией. Я полагаю, что это иллюстрирует древность книги.

Паркинсон показывает, что вы можете прийти на совещание руководителей и получить добро на строительство многомиллионной или даже многомиллиардной атомной электростанции, но если вы хотите построить навес для велосипеда, то погрязнете в бесконечных обсуждениях.

Паркинсон объясняет это тем, что атомная станция настолько большой, дорогой и сложный объект, что люди не могут его осознать и вместо того, чтобы попробовать это сделать, они полагаются на то, что кто-то уже проверил все мелочи до того, как всё зашло так далеко. В своей книге Ричард П. Фейнманн (Richard P. Feynmann) даёт несколько интересных и очень поучительных примеров, связанных с Лос Аламос.

Велосипедный навес - это противоположный случай. Любой может построить навес за один уикэнд, и у него ещё останется время посмотреть футбол по телевизору. Так что не важно, насколько хорошо вы готовились к обсуждению, насколько убедительны будут ваши аргументы, кто-нибудь воспользуется шансом показать, что он не зря ест свой хлеб, что он обращает внимание, что он _здесь_.

В Дании это называется "оставить отпечаток своего пальца". Это касается личной гордости и престижа, это похоже на возможность указать куда-то и сказать: " Вон там! Это сделал _я_." Это сильно выражено в политиках, но присутствует во многих людях, которые получают возможность сделать это. Просто вспомните об отпечатках ног во влажном цементе.

== Юмор от FreeBSD

=== Насколько греется процессор при работе FreeBSD?

В. Кто-нибудь делал замеры температуры при работе FreeBSD? Я знаю, что Linux(R) греется меньше, чем DOS, но никогда не видел упоминания FreeBSD. Наверное, он сильно греется.

О. Нет, но мы сделали различные вкусовые тесты у добровольцев с завязанными глазами, которые до этого приняли по 250 микрограмм LSD-25. 35% добровольцев заявило, что FreeBSD имеет вкус апельсина, тогда как вкус Linux(R) расценивался как фиолетовый туман. Ни одна из групп не отметила значительной разницы в температуре. Мы хотели опубликовать полные результаты этого опроса, когда обнаружили, что слишком много добровольцев покинули помещение во время тестов, что несколько смазало результаты. Думаем, что большинство из них работают сейчас в Apple над их новым GUI "чеши и нюхай". Это старый добрый бизнес!

Если серьёзно, то FreeBSD использует инструкцию HLT (halt), когда система простаивает, что уменьшает потребление энергии и, в свою очередь, выделение тепла. Вдобавок, если у вас настроен ACPI (усовершенствованный интерфейс управления конфигурацией и питанием), то FreeBSD может переводить процессор в режим пониженного энергопотребления.

=== Кто там скребётся в микросхемах памяти??

В. Делает ли FreeBSD что-нибудь "эдакое" при компиляции ядра, что вызывает поскрипывание микросхем памяти? При компиляции (и в короткий промежуток времени после обнаружения дисковода при старте системы) от микросхем памяти исходит странный царапающий звук.

О. Да! Вы, наверное, видели частое упоминание "даемонов" в документации по BSD, но не многие знают, что это настоящие нематериальные существа, которые теперь завладели вашим компьютером. Царапающий звук, издаваемый микросхемами памяти - это на самом деле высокочастотное перешёптывание между даемонами, когда они решают, как лучше справиться с различными задачами по администрированию системы.

Если шум достиг ваших ушей, команда DOS `fdisk /mbr` их спугнёт, но не удивляйтесь, если они отреагируют соответствующим образом и попытаются вас остановить. Фактически, если во время выполнения этой команды вы услышите сатанинский голос Билла Гейтса из встроенного динамика, бегите и даже не оглядывайтесь! Избавленные от противостояния с даемонами BSD, близнецы-демоны DOS и Windows(R) часто могут захватить полный контроль не только над вашей машиной и навлечь вечное проклятие на вашу душу. Теперь, когда вы это знаете, если бы у вас был выбор, думаем, что вы бы предпочли слышать царапающий звук, не так ли?

=== Сколько требуется разработчиков FreeBSD, чтобы сменить электрическую лампочку?

Необходимо иметь ровно одну тысячу сто шестьдесят девять разработчиков:

Двадцать три сообщат в -CURRENT о том, что не горит свет;

Четыре начнут утверждать, что это проблема конфигурации и такие сообщения нужно посылать в -questions;

Трое оформят PR по этому поводу, причём одно их них будет направлено в doc и будет содержать только строчку "здесь темно";

Один закоммитит неоттестированную лампочку, что сломает построение системы, а затем через пять минут вернёт всё назад;

Восемь поругаются с авторами PR по поводу включения патчей в PR;

Пять сообщат о том, что не проходит компиляция системы;

Тридцать один человек ответит, что у них всё работает и наверное, те обновились в неподходящее время;

Один пошлёт патч для новой лампочки в -hackers;

Один пожалуется, что у него имелись патчики ещё три года назад, но когда он послал их в -CURRENT, они были проигнорированы и он имел неудачный опыт работы с системой PR; кроме того предлагаемая лампочка не имеет отражателя.

Тридцать семь начнут кричать, что лампочки не относятся к базовой системе, что коммиттеры не имеют права делать такие вещи без опроса общественности и ЧТО ВООБЩЕ -CORE ДЕЛАЕТ ПО ЭТОМУ ПОВОДУ?

Две сотни напишут о цвете велосипедного навеса;

Трое скажут, что этот патч не соответствует man:style[9]

Семнадцать возразят, что предлагаемая новая лампа подпадает под лицензию GPL;

Пятьсот восемьдесят шесть раздуют флейм по поводу сравнения лицензий GPL, BSD, MIT, NPL и личных мнений о неизвестных основателей FSF;

Семеро пошлют различные части этих обсуждений в -chat и -advocacy;

Один закоммитит предлагаемую лампу, хотя она светит хуже, чем старая;

Двое откатят эти изменения с ужасной руганью в журнале коммитта о том, что лучше FreeBSD будет сидеть в темноте, чем с тусклой лампой.

Сорок шесть громко воспротивятся этому изменению и потребуют объяснений от -core;

Одиннадцать попросят уменьшить размер лампочки, чтобы она подошла к их Тамагочи на случай, если мы когда-нибудь соберёмся переносить FreeBSD на эту платформу;

Семьдесят три заявят о SNR в -hackers и -chat и в знак протеста отпишутся;

Тринадцать пошлют письма "unsubscribe", "How do I unsubscribe?" или "Please remove me from the list" с обычной подписью;

Один закоммитит работающую лампочку в то время, как все будут слишком заняты руганью, чтобы это заметить;

Тридцать один человек напишет, что новая лампочка будет светить на 0.364% ярче, если её откомпилировать с помощью TenDRA (хотя при этом она приобретёт форму куба) и что FreeBSD должна перейти на компилятор TenDRA, а не на GCC;

Один заметит, что у лампочки отсутствует цоколь;

Девять (включая авторов PR) спросят "что такое MFC?";

Спустя две недели после смены лампочки пятьдесят семь человек сообщат о том, что света всё равно нет.

_{nik} добавил:_

_Я сильно смеялся над всем этим._

_И тогда я подумал, "Постойте-ка, найдётся ли кто-нибудь, чтобы задокументировать это?"_

_И на меня снизошло озарение :-)_

_{tabthorpe}_ говорит: "Нет, _настоящие_ хакеры FreeBSD не боятся темноты!"

=== Куда направляются данные, записываемые в /dev/null?

Они отправляются в специальную сточную трубу для данных в CPU, где преобразуются в тепло, выдуваемое через охлаждающие вентиляторы. Вот почему охлаждение ЦП становится все более важным; так как люди используют все более быстрые процессоры, они все менее заботятся о данных, все большее их количество оканчивает свой путь в [.filename]#/dev/null#, перегревая ЦП. Если вы удалите [.filename]#/dev/null# (что соответственно отключит трубу данных в ЦП), то ваш процессор может охладиться, но система начнет переполняться излишними данными и начнет работать с ошибками. Если у вас быстрое сетевое подключение, вы можете охладить CPU, читая данные из [.filename]#/dev/random# и посылая их куда-нибудь; однако вы рискуете перегреть ваше сетевое соединение и [.filename]#/# или разозлить вашего провайдера, так как большинство данных преобразуется в тепло на его оборудовании, но, как правило, у него хорошее охлаждение, так что если вы не перестараетесь, все должно быть в порядке.

_Пол Робинсон (Paul Robinson) добавляет:_

Есть и другие методы. Как знает каждый хороший системный администратор, частью хорошей практики является посылка данных на экран интересным образом, чтобы феи, которые образуют картинку, были счастливы. Экранные феи (часто неправильно называемые "пикселами") различаются по цвету головных уборов, которые они носят (красные, зеленые или синие), и прячутся или появляются (показывая, таким образом, цвет своих шляп), когда получают немного пищи. Видеоадаптеры преобразуют данные в еду для фей, а затем посылают ее феям - чем дороже адаптер, тем лучше еда, тем лучше ведут себя феи. Они также нуждаются в постоянной стимуляции - вот зачем нужны хранители экранов.

Продолжив наше предположение, вы можете просто выдавать случайные данные на консоль, таким образом позволяя феям их потреблять. Это вовсе приводит к прекращению выделения тепла, феи постоянно счастливы, а данные быстро исчезают, даже если на вашем экране все выглядит несколько хаотично.

Как бывший администратор крупного провайдера, который имел много проблем при попытке поддерживать постоянную температуру в серверной комнате, я выступаю против того, чтобы люди посылали ненужные им данные в сеть. Волшебников, которые выполняют коммутацию пакетов и маршрутизацию, это также затрудняет.

== Сложные темы

=== Как можно узнать больше о внутреннем устройстве FreeBSD?

Список относящихся к делу книг можно найти в разделе Руководства link:{handbook}#bibliography-osinternals/[ Библиография по внутреннему устройству операционной системы].

Кроме того, большинство общих знаний о UNIX(R) непосредственно применимо к FreeBSD.

=== Как можно оказать помощь проекту FreeBSD?

Пожалуйста, обратитесь к соответствующей link:{contributing}[статье], в которой вы получите советы относительно того, как это сделать. Ваша помощь более чем приветствуется!

=== Что такое снапшоты и релизы?

В http://svnweb.FreeBSD.org/base/[Хранилище Subversion] сейчас находятся {rel-numbranch} активно/полуактивно развивающихся ветки FreeBSD. (Более ранние ветки изменяются очень редко, именно поэтому в разработке только {rel-numbranch} активные ветки):

* {rel3-releng}, также известная как {rel3-stable}
* {rel2-releng}, также известная как {rel2-stable}
* {rel-releng}, также известная как {rel-stable}
* {rel-head-releng}, также известная как _-CURRENT_ и {rel-head}

`HEAD` - это не настоящий тэг ветки. Это символьная константа для обозначения текущего, не ветвящегося, находящегося в разработке дерева, то есть _-CURRENT_.

На данный момент _-CURRENT_ является находящимся в разработке деревом {rel-head-relx}; ветка {rel-stable}, {rel-releng}, отделилась от _-CURRENT_ {rel-relengdate} года, а ветка {rel2-stable}, {rel2-releng}, отделилась от _-CURRENT_ {rel2-relengdate}.

=== Можно ли работать с -CURRENT при ограниченном доступе в Internet?

Да, это можно делать _без_ скачивания полного дерева исходных текстов с помощью link:{handbook}#ctx[системы CTM].

=== Я написал некоторое добавление к ядру, кому его послать?

Обратитесь к статье о том, как link:{contributing}[помочь проекту FreeBSD], чтобы выяснить, как это сделать.

И спасибо Вам за Ваши усилия!

=== Что делать при аварийном останове системы?

Вот типичная паника ядра:

[.programlisting]
....
Fatal trap 12: page fault while in kernel mode
fault virtual address   = 0x40
fault code              = supervisor read, page not present
instruction pointer     = 0x8:0xf014a7e5
stack pointer           = 0x10:0xf4ed6f24
frame pointer           = 0x10:0xf4ed6f28
code segment            = base 0x0, limit 0xfffff, type 0x1b
                        = DPL 0, pres 1, def32 1, gran 1
processor eflags        = interrupt enabled, resume, IOPL = 0
current process         = 80 (mount)
interrupt mask          =
trap number             = 12
panic: page fault
....

Этого сообщения не достаточно. Здесь важно значение указателя инструкций, но оно зависит от конфигурации, поскольку значение меняется для каждого конкретного файла ядра. Если это ядро [.filename]#GENERIC# из одного из снэпшотов, то кто-то ещё может отследить функцию, вызвавшую ошибку, но в случае со специально сконфигурированным ядром только вы можете сказать нам, где случилась ошибка.

Чтобы продолжить:

[.procedure]
====
. Запишите значение указателя инструкций. Заметьте, что часть `0x8:` в этом случае не важна: нам нужна часть `0xf0xxxxxx`.
. Когда система перезагрузится, сделайте следующее:
+
[source,bash]
....
% nm -n kernel.that.caused.the.panic | grep f0xxxxxx
....
+ 
где `f0xxxxxx` - это значение указателя инструкций. Однако неприятность заключается в том, что вы не получите точного соответствия, так как в таблице имен ядра для точек входа в функции даны адреса на начало функций, а указатель инструкций будет указывать куда-то внутрь её тела. Если вы не получили точного соответствия, опустите последнюю цифру в значении указателя инструкций и попробуйте снова:
+
[source,bash]
....
% nm -n kernel.that.caused.the.panic | grep f0xxxxx
....
+ 
Если и это не привело ни к каким результатам, отрежьте следующую цифру. Повторяйте, пока не получите хоть что-то. Результатом будет список функций, которые, возможно, привели к аварийному останову. Этот механизм обнаружения ошибочного места довольно неточен, но это всё же лучше, чем ничего.
====

Тем не менее, лучшим способом выяснить причину, вызвавшую аварийный останов, является получение аварийного дампа системы, а затем использование man:kgdb[1] для получения трассировки вызовов в этом дампе.

В любом случае, метод таков:

[.procedure]
====
. Убедитесь в том, что в файле конфигурации ядра имеется следующая строка:
+
[.programlisting]
....
makeoptions     DEBUG=-g          # Build kernel with gdb(1) debug symbols
....
+
. Перейдите в каталог [.filename]#/usr/src#:
+
[source,bash]
....
# cd /usr/src
....
+
. Скомпилируйте ядро:
+
[source,bash]
....
# make buildkernel KERNCONF=MYKERNEL
....
+
. Дождитесь завершения компиляции.
+
[source,bash]
....
# make installkernel KERNCONF=MYKERNEL
....
+
. Выполните перезагрузку.
====

[NOTE]
====
Если не указать `KERNCONF`, то будет собрано и установлено ядро [.filename]#GENERIC#.
====

В процессе выполнения команды man:make[1] будут построены два ядра, [.filename]#/usr/obj/usr/src/sys/MYKERNEL/kernel# и [.filename]#/usr/obj/usr/src/sys/MYKERNEL/kernel.debug#. [.filename]#kernel# будет установлен как [.filename]#/boot/kernel/kernel#, тогда как [.filename]#kernel.debug# может быть использован в качестве источника отладочных символов для man:kgdb[1].

Чтобы получать аварийный дамп, отредактируйте файл [.filename]#/etc/rc.conf# так, чтобы устройство `dumpdev` указывало на раздел подкачки или имело значение `AUTO`. В этом случае скрипты man:rc[8] будут вызывать команду man:dumpon[8] для создания аварийных дампов. Эту команду можно также запускать вручную. После аварийной остановки аварийный дамп может быть получен с помощью программы man:savecore[8] если значение переменной `dumpdev` было установлено в [.filename]#/etc/rc.conf#, скрипты man:rc[8] запустят man:savecore[8] автоматически и поместят аварийный дамп в каталог [.filename]#/var/crash#.

[NOTE]
====
Аварийные дампы FreeBSD обычно имеют размер, равный объёму оперативной памяти. Поэтому убедитесь в наличии достаточного места для хранения дампа в каталоге [.filename]#/var/crash#. Либо запустите вручную man:savecore[8], чтобы создать аварийный дамп в другом каталоге, где достаточно места. Размер аварийного дампа можно уменьшить, указав в конфигурации ядра `options MAXMEM=N`, где _N_ - значение в Кбайт для объёма памяти, которое будет использоваться ядром. Например, для 1 Гбайт ОЗУ установите ограничение на использование памяти ядром в 128 Мбайт, так чтобы размер аварийного дампа был равен 128 Мбайт, а не 1 Гбайт.
====

Как только аварийный дамп получен, трассировку вызовов можно получить таким образом:

[source,bash]
....
% kgdb /usr/obj/usr/src/sys/MYKERNEL/kernel.debug /var/crash/vmcore.0
(kgdb) backtrace
....

Заметьте, что это может дать несколько экранов полезной информации. Лучше всего использовать man:script[1] для перехвата всего вывода. При использовании необработанного файла ядра со всей отладочной информацией может быть найдена конкретная строка исходного текста ядра, при достижении которой случилась аварийная остановка. Для выяснения последовательности событий, приведших к аварийному останову, трассировка стека обычно читается снизу вверх. Также можно использовать man:kgdb[1] для вывода значений различных переменных или структур, чтобы выяснить состояние системы во время аварии.

[TIP]
====

Если есть второй компьютер, то можно настроить man:kgdb[1] для удалённой отладки, включая точки останова и пошаговый проход по коду ядра.
====

[NOTE]
====
Если включена поддержка `DDB` и ядро переходит в режим отладки, можно намеренно вызвать аварийный останов и создание аварийного дампа, набрав `panic` в приглашении командной строки `ddb`. Выполнение фазы аварийного останова может снова остановиться с вызовом отладчика. В этом случае наберите `continue`, и процесс будет завершён созданием аварийного дампа.
====

=== Перестала работать функция dlsym() для исполняемых файлов ELF!

По умолчанию при работе с форматом ELF символы, определённые в исполняемом файле, не доступны динамическому загрузчику. Поэтому при вызове функции `dlsym()`, которая осуществляет поиск по дескриптору, полученному после вызова `dlopen(NULL, flags)`, желаемый результат достигнут не будет.

Чтобы осуществить поиск символов в исполняемом файле процесса с помощью функции `dlsym()`, выполните компоновку исполняемого файла с параметром `--export-dynamic` компоновщика ELF (man:ld[1]).

=== Как я могу увеличить или уменьшить адресное пространство ядра в архитектуре i386?

По умолчанию размер адресного пространства ядра для i386 равен 1 Гбайт (2 Гбайт для PAE). Для работы сервера с интенсивной сетевой нагрузкой или при использовании ZFS этого может быть недостаточно.

Чтобы увеличить доступное пространство, добавьте следующую строку в файл конфигурации ядра и пересоберите ядро:

[.programlisting]
....
options KVA_PAGES=N
....

Чтобы получить нужное значение для _N_, разделите желаемый размер адресного пространства (в мегабайтах) на четыре (для 2 Гбайт это будет `512`).

== Наши благодарности

Этот небольшой скромный документ с ответами на часто задаваемые вопросы создавался, переписывался, редактировался, сокращался, растягивался, уродовался, потрошился, пристально разглядывался, полностью перетряхивался, обдумывался, отвергался, перестраивался, критиковался и снова укреплялся в течение последнего десятилетия силами сотен, если не тысяч, людей. Постоянно.

Мы хотим поблагодарить всех их и приглашаем вас link:{contributing}[присоединиться], чтобы сделать этот FAQ ещё лучше.

[bibliography]
[[bibliography]]
== Bibliographie

[biblio-unleashed] FreeBSD Unleashed. Michael Urban und Brian Tiemann. Sams. Erste Ausgabe. 992 Seiten. Oktober 2001. ISBN 0-67232-206-4.

[biblio-44sysman] 4.4BSD System Manager's Manual. Computer Systems Research Group, University of California, Berkeley. O'Reilly and Associates. Erste Ausgabe. Juni 1994. 804 Seiten. ISBN 1-56592-080-5.

[biblio-44userman] 4.4BSD User's Reference Manual. Computer Systems Research Group, University of California, Berkeley. O'Reilly and Associates. Erste Ausgabe. Juni 1994. 905 Seiten. ISBN 1-56592-075-9.

[biblio-44suppman] 4.4BSD User's Supplementary Documents. Computer Systems Research Group, University of California, Berkeley. O'Reilly and Associates. Erste Ausgabe. Juni 1994. 712 Seiten. ISBN 1-56592-076-7.

[biblio-44progman] 4.4BSD Programmer's Reference Manual. Computer Systems Research Group, University of California, Berkeley. O'Reilly and Associates. Erste Ausgabe. Juni 1994. 866 Seiten. ISBN 1-56592-078-3.

[biblio-44progsupp] 4.4BSD Programmer's Supplementary Documents. Computer Systems Research Group, University of California, Berkeley. O'Reilly and Associates. Erste Ausgabe. Juni 1994. 596 Seiten. ISBN 1-56592-079-1.

[biblio-44kernel] The Design and Implementation of the 4.4BSD Operating System. M. K. McKusick, Kirk Marshall, Keith Bostic, Michael J Karels und John Quarterman. Addison-Wesley. Reading MA . 1996. ISBN 0-201-54979-4.

[biblio-freebsdkernel] The Design and Implementation of the FreeBSD Operating System. M. K. McKusick und George V. Neville-Neil. Addison-Wesley. Boston MA . 2004. ISBN 0-201-70245-2.

[biblio-nemeth3rd] Unix System Administration Handbook. Evi Nemeth, Garth Snyder, Scott Seebass, Trent R. Hein und John Quarterman. Prentice-Hall. Dritte Ausgabe. 2000. ISBN 0-13-020601-6.

[lehey3rd] The Complete FreeBSD. Greg Lehey. Walnut Creek. Dritte Ausgabe. Juni 1999. 773 Seiten. ISBN 1-57176-246-9.

[McKusick et al, 1994] Berkeley Software Architecture Manual, 4.4BSD Edition. M. K. McKusick, M. J. Karels, S. J. Leffler, W. N. Joy und R. S. Faber. 5:1-42.

[biblio-ja-fbsdpc98] FreeBSD for PC 98'ers (in Japanisch). SHUWA System Co, LTD.. ISBN 4-87966-468-5 C3055 P2900E.

[biblio-ja-fbsd] FreeBSD (in Japanisch). CUTT. ISBN 4-906391-22-2.

[biblio-ja-compintro] Complete Introduction to FreeBSD (in Japanisch). Shoeisha Co., Ltd. ISBN 4-88135-473-6 P3600E.

[biblio-ja-unixstarterkit] Personal UNIX Starter Kit FreeBSD (in Japanisch). ASCII. ISBN 4-7561-1733-3 P3000E.

[biblio-ja-fbsdhb] FreeBSD Handbook (Japanische Übersetzung). ASCII. ISBN 4-7561-1580-2 P3800E.

[biblio-ge-fbsdmitmeth] FreeBSD mit Methode (in Deutsch). Computer und Literature Verlag/Vertrieb Hanser. 1998. ISBN 3-932311-31-0.

[biblio-ja-fbsdinstandutil] FreeBSD install and Utilization Manual (in Japanisch). Mainichi Communications Inc..

[biblio-indo-intserv] Building Internet Server with FreeBSD (in Indonesisch). Elex Media Komputindo. Onno W Purbo, Dodi Maryanto, Syahrial Hubbany und Widjil Widodo.

[biblio-fbsdcorpnetguide] The FreeBSD Corporate Networker's Guide. Addison-Wesley.

[biblio-unixnutshell] UNIX in a Nutshell. O'Reilly & Associates, Inc.. 1990. ISBN 093717520X.

[biblio-cantfindadmin] What You Need To Know When You Can't Find Your Unix System Administrator. O'Reilly & Associates, Inc.. 1995. Linda Mui. ISBN 1-56592-104-6.

[biblio-ja-fbsdusrrefman] FreeBSD User's Reference Manual (Japanische Übersetzung). Mainichi Communications Inc.. Jpman Project, Japan FreeBSD Users Group. 1998. ISBN 4-8399-0088-4 P3800E.

[biblio-newcomeunix] http://unixhelp.ed.ac.uk/[Online Guide for newcomers to the UNIX environment]“. http://www.ed.ac.uk/[Edinburgh University].

[biblio-dnsandbind] DNS and BIND. O'Reilly & Associates, Inc. ISBN 1-56592-512-2. Paul Albitz Albitz und Cricket Liu. 1998. Dritte Ausgabe.

[biblio-sendmail] Sendmail. O'Reilly & Associates, Inc. 1997. Zweite Auflage. Brian Costales. ISBN 1-56592-222-0.

[biblio-esssysadmin] Essential System Administration. Æleen Frisch. Zweite Auflage. O'Reilly & Associates. 1995. ISBN 1-56592-127-5.

[biblio-tcpipnetworkadministration] TCP/IP Network Administration. Craig Hunt. Zweite Auflage. O'Reilly & Associates, Inc. 1997. ISBN 1-56592-322-7.

[biblio-managingnfsandnis] Managing NFS and NIS. Hal Stern. O'Reilly & Associates, Inc. 1991. ISBN 0-937175-75-7.

[biblio-jpmanprojectjfug] http://www.pc.mycom.co.jp/FreeBSD/sam.html[FreeBSD System Administration's Manual]. http://www.jp.freebsd.org/[Jpman Project, Japan FreeBSD Users Group]. http://www.pc.mycom.co.jp/[Mainichi Communications Inc.]. 1998. ISBN 4-8399-0109-0 P3300E.

[biblio-xwinsystoolkit] X Window System Toolkit. Digital Press. Paul Asente. ISBN 1-55558-051-3.

[biblio-carefman] C: A Reference Manual. Prentice Hall. 1995. Vierte Auflage. Samuel P. Harbison und Guy L. Jr. Steele. ISBN 0-13-326224-3.

[biblio-thecproglang] The C Programming Language. Prentice Hall. 1998. Brian Kernighan und Dennis Ritchie. ISBN 0-13-110362-9.

[biblio-portingunixsoft] Porting UNIX Software. Greg Lehey. O'Reilly & Associates, Inc.. 1995. ISBN 1-56592-126-7.

[biblio-thestandardclibrary] The Standard C Library. Prentice Hall. 1992. P. J. Plauger. ISBN 0-13-131509-9.

[biblio-advprogintheunixenv] Advanced Programming in the UNIX Environment. Addison-Wesley. 1992. W. Richard Stevens. ISBN 0-201-56317-7.

[biblio-unixnetprog] UNIX Network Programming. W. Richard Stevens. Prentice Hall. 1998. Zweite Auflage. ISBN 0-13-490012-X.

[biblio-writeserialdriverforunix] Writing Serial Drivers for UNIX. Bill Wells. Dezember 1994. Dr. Dobb's Journal. pp68-71, pp97-99.

[biblio-unixsysarch] UNIX System Architecture. Prentice-Hall, Inc. 1990. Prabhat K. Andleigh. ISBN 0-13-949843-5.

[biblio-portingunixtothe386] Porting UNIX to the 386. William Jolitz. Dr. Dobb's Journal. Januar 1991 - Juli 1992.

[biblio-tcpipillv1theprotocols] TCP/IP Illustrated, Volume 1: The Protocols. W. Richard Stevens. Addison-Wesley. 1996. ISBN 0-201-63346-9.

[biblio-unixsysformodrnarch] Unix Systems for Modern Architectures. Addison-Wesley. Curt Schimmel. 1994. ISBN 0-201-63338-8.

[biblio-tcpipillvol3] TCP/IP Illustrated, Volume 3: TCP for Transactions, HTTP, NNTP and the UNIX Domain Protocols. Addison-Wesley. 1996. W. Richard Stevens. ISBN 0-201-63495-3.

[biblio-unixinternthenewfrontiers] UNIX Internals -- The New Frontiers. Uresh Vahalia. Prentice Hall. 1996. ISBN 0-13-101908-2.

[biblio-tcpipillvol2theimplementation] TCP/IP Illustrated, Volume 2: The Implementation. Gary R. Wright und W. Richard Stevens. 1995. Addison-Wesley. ISBN 0-201-63354-X.

[biblio-firewallsandinternetsecurity] Firewalls and Internet Security: Repelling the Wily Hacker. William R. CHeswick und Steven M. Bellovin. Addison-Wesley. 1995. ISBN 0-201-63357-4.

[biblio-practicalunixsecurity] Practical UNIX Security. Simson Garfinkel und Gene Spafford. 1996. Zweite Auflage. O'Reilly & Associates, Inc. ISBN 1-56592-148-8.

[biblio-pgpprettygoodprivacy] PGP Pretty Good Privacy. Simson Garfinkel. O'Reilly & Associates, Inc. 1995. ISBN 1-56592-098-8.

[biblio-pentiumprocarch] Pentium Processor System Architecture. Don Anderson und Tom Shanley. Addison-Wesley. 1995. Zweite Auflage. ISBN 0-201-40992-5.

[biblio-progguidetothesvgacards] Programmer's Guide to the EGA, VGA, and Super VGA Cards. Richard F. Ferraro. Dritte Ausgabe. Addison-Wesley. 1995. ISBN 0-201-62490-7.

[biblio-80486] 80486 System Architecture. Tom Shanley. Addison-Wesley. 1995. Dritte Ausgabe. ISBN 0-201-40994-1.

[biblio-isasysarch] ISA System Architecture. Tom Shanley. Addison-Wesley. Dritte Ausgabe. 1995. ISBN 0-201-40996-8.

[biblio-pcisysarch] PCI System Architecture. Tom Shanley. Addison-Wesley. 1995. Dritte Ausgabe. ISBN 0-201-40993-3.

[biblio-theundocumentedpc] The Undocumented PC. Frank Van Gilluwe. Addison-Wesley. 1994. ISBN 0-201-62277-7.

[biblio-bellsystemtechnicaljournal] Bell System Technical Journal, Unix Time-Sharing System. American Telephone & Telegraph Company. Juli - August 1978. Vol 57, No 6, Part 2. ISSN0005-8580.

[biblio-commentaryonunix] Lion's Commentary on UNIX. John Lion. ITP Media Group. 1996. Sechste Ausgabe. ISBN 1573980137.

[biblio-newhackerdict] The New Hacker's Dictionary. Eric S. Raymond. MIT Press. 1996. Dritte Ausgabe. ISBN 0-262-68092-0.

[biblio-aqtrcentofunix] A quarter century of UNIX. Peter H. Salus. Addison-Wesley. 1994. ISBN 0-201-54777-5.

[biblio-unixhatershandbook] The UNIX-HATERS Handbook. Steven Strassman, Daniel Weise und Simon Garfinkel. IDG Books Worldwide, Inc. 1994. ISBN 1-56884-203-1.

[biblio-lifewithunix] Life with UNIX - special edition. Don Libes und Sandy Ressler. Prentice-Hall. 1989. ISBN 0-13-536657-7.

[biblio-bsdfamilytree] https://svnweb.freebsd.org/base/head/shared/misc/bsd-family-tree?view=co[The BSD Family Tree]. 1997.

[absolutebsd] Absolute BSD. Michael Lucas. No Starch Press. Juni 2002. ISBN 1-886411-74-3.

[biblio-ccppusersjournal] The C/C++ Users Journal. R&D Publications Inc.. ISSN 1075-2838.

[biblio-sysadminthejournalforunixsysadmins] Sys Admin - The Journal for UNIX System Administrators. Miller Freeman, Inc. ISSN 1061-2688. 
