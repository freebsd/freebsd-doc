---
title: "Глава 18. GEOM: Модульная инфраструктура преобразования дисковых запросов"
part: Часть III. Системное администрирование
prev: books/handbook/disks
next: books/handbook/filesystems
---

[[geom]]
= GEOM: Модульная инфраструктура преобразования дисковых запросов
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:source-highlighter: rouge
:experimental:
:skip-front-matter:
:toc-title: Содержание
:table-caption: Таблица
:figure-caption: Рисунок
:example-caption: Пример
:xrefstyle: basic
:relfileprefix: ../
:outfilesuffix:
:sectnumoffset: 18

ifeval::["{backend}" == "html5"]
:imagesdir: ../../../../images/books/handbook/geom/
endif::[]

ifeval::["{backend}" == "pdf"]
:imagesdir: ../../../../static/images/books/handbook/geom/
endif::[]

ifeval::["{backend}" == "epub3"]
:imagesdir: ../../../../static/images/books/handbook/geom/
endif::[]

include::shared/authors.adoc[]
include::shared/releases.adoc[]
include::shared/ru/mailing-lists.adoc[]
include::shared/ru/teams.adoc[]
include::shared/ru/urls.adoc[]

toc::[]

[[GEOM-synopsis]]
== Краткий обзор

Эта глава описывает использование дисков, управляемых инфраструктурой GEOM во FreeBSD. Среди прочего, здесь описывается большая часть утилит управления RAID, использующих GEOM для настройки. В этой главе мы не будем вдаваться в подробности взаимодействия GEOM с подсистемой ввода/вывода или с программным кодом, эту информацию вы можете получить на странице справочника man:geom[4]. Эта глава также не является подробным руководством по настройке RAID. Мы обсудим только типы RAID, поддерживаемые GEOM.

После прочтения этой главы вы будете знать:

* Какие типы RAID поддерживает GEOM.
* Как использовать стандартные утилиты для настройки, обслуживания и управления различными уровнями RAID.
* Как с помощью GEOM создавать зеркальные, последовательные и шифрованные дисковые последовательности, а так же последовательности из дисков, присоединённых удалённо.
* Как решать проблемы с дисками, присоединёнными к инфраструктуре GEOM.

Перед чтением этой главы вы должны:

* Понимать, как FreeBSD работает с дисками (crossref:disks[disks, Устройства хранения]).
* Уметь сконфигурировать и установить новое ядро FreeBSD (crossref:kernelconfig[kernelconfig, Настройка ядра FreeBSD]).

[[GEOM-intro]]
== Введение в GEOM

GEOM позволяет классам -  MBR, BSD labels, и так далее - получить доступ к устройству и управлять им, используя поставщиков GEOM (providers) или специальные файлы устройств, расположенные в каталоге [.filename]#/dev#. GEOM поддерживает различные программные конфигурации RAID, и прозрачно предоставляет доступ к дискам системе и системным приложениям.

[[GEOM-striping]]
== RAID0 - Создание дисковой последовательности (Striping)

Создание дисковой последовательности (Striping) - метод, применяемый, чтобы скомбинировать несколько физических дисков в один логический. Во многих случаях это делается с использованием аппаратных контроллеров. Дисковая подсистема GEOM предоставляет программную поддержку RAID0, иногда называемую дисковой последовательностью (Stripe).

В RAID уровня 0 данные разбиваются на блоки, которые параллельно записываются на все диски массива. Вместо того, чтобы ждать записи 256k на один диск, RAID0 может параллельно записывать по 64k на каждый из четырёх дисков, обеспечивая более высокую производительность ввода/вывода. Производительность также может быть увеличена за счет использования большего числа дисков.

Все диски последовательности RAID0 должны быть одного размера, так как запись и считывание с дисков происходят параллельно.

image::striping.png[Иллюстрация дисковой последовательности]

[.procedure]
====
*Procedure: Создание дисковой последовательности из неформатированных ATA дисков*

. Загрузите модуль [.filename]#geom_stripe.ko#:
+
[source,bash]
....
# kldload geom_stripe
....
+
. Убедитесь, что существует подходящая точка монтирования. Если вы планируете сделать логический диск корневым разделом, используйте временную точку монтирования, например [.filename]#/mnt#:
+
[source,bash]
....
# mkdir /mnt
....
+
. Определите имена устройств, которые будут объединены в последовательность, и создайте новое устройство для последовательности. Например, чтобы создать дисковую последовательность из двух неиспользуемых и неразмеченных ATA дисков, например [.filename]#/dev/ad2# и [.filename]#/dev/ad3#:
+
[source,bash]
....
# gstripe label -v st0 /dev/ad2 /dev/ad3
Metadata value stored on /dev/ad2.
Metadata value stored on /dev/ad3.
Done.
....
+
. Запишите стандартную метку, также известную как таблица разделов, в новый том, и установите стандартный загрузчик:
+
[source,bash]
....
# bsdlabel -wB /dev/stripe/st0
....
+
. Теперь в [.filename]#/dev/stripe# кроме [.filename]#st0# появились ещё два устройства - [.filename]#st0a# и [.filename]#st0c#. Теперь создайте файловую систему на устройстве [.filename]#st0a#, используя утилиту `newfs`:
+
[source,bash]
....
# newfs -U /dev/stripe/st0a
....
+ 
На экране промелькнет множество цифр, и через несколько секунд процесс будет завершен. Логический диск создан и готов к монтированию.
====

Смонтируйте его вручную:

[source,bash]
....
# mount /dev/stripe/st0a /mnt
....

Чтобы монтировать созданную дисковую последовательность автоматически во время загрузки, добавьте информацию о ней в файл [.filename]#/etc/fstab#. Создайте постоянную точку монтирования и назовите её, к примеру, [.filename]#stripe#:

[source,bash]
....
# mkdir /stripe
# echo "/dev/stripe/st0a /stripe ufs rw 2 2" \
    >> /etc/fstab
....

Чтобы модуль [.filename]#geom_stripe.ko# автоматически загружался во время инициализации системы, добавьте строку в [.filename]#/boot/loader.conf#:

[source,bash]
....
# echo 'geom_stripe_load="YES"' >> /boot/loader.conf
....

[[GEOM-mirror]]
== RAID1 - Зеркалирование (Mirroring)

Зеркалирование (Mirroring) - технология, применяемая как в корпоративной среде, так и на домашних компьютерах. Она позволяет создавать резервные копии "на лету". Зеркалирование, по сути, означает, что диск A является копией диска B. Или, возможно, диск C+D является копией диска A+B. Вне зависимости от конфигурации, основной аспект - дублирование информации. Позже, эта информация может быть с легкостью восстановлена или сохранена как резервная копия без остановки системы, или даже физически помещена в хранилище данных.

Перед началом, убедитесь, что у вас есть два физических диска равной емкости. Далее в этом примере подразумевается, что это диски прямого доступа (direct access, man:da[4]) с интерфейсом SCSI.

=== Зеркалирование первичных дисков

В статье предполагается, что FreeBSD установлена на первый жесткий диск, определяемый системой как [.filename]#da0#. Это устройство будет целевым для утилиты man:gmirror[8].

Перед построением зеркала включите дополнительную отладочную информацию и откройте доступ к устройству. Это достигается установкой следующего значения переменной man:sysctl[8] `kern.geom.debugflags`:

[source,bash]
....
# sysctl kern.geom.debugflags=17
....

Теперь создайте зеркало. Начните процесс с сохранения метаданных на первом диске. В результате выполнения следующей команды будет создано устройство вида [.filename]#/dev/mirror/gm#:

[WARNING]
====

Создание зеркала на диске, с которого произведена загрузка, может повлечь за собой потерю данных в том случае, если данными занят последний сектор диска. Риск повреждения данных меньше, если создание зеркала немедленно следует за свежей установкой FreeBSD.
====

[source,bash]
....
# gmirror label -vb round-robin gm0 /dev/da0
....

Система должна выдать следующее сообщение:

[source,bash]
....
Metadata value stored on /dev/da0.
Done.
....

Инициализируйте GEOM, это повлечет за собой загрузку модуля ядра [.filename]#/boot/kernel/geom_mirror.ko#:

[source,bash]
....
# gmirror load
....

[NOTE]
====
После успешного завершения команды будет создано устройство [.filename]#gm0# в каталоге [.filename]#/dev/mirror#.
====

Включите автоматическую загрузку модуля [.filename]#geom_mirror.ko# во время старта операционной системы:

[source,bash]
....
# echo 'geom_mirror_load="YES"' >> /boot/loader.conf
....

Отредактируйте файл [.filename]#/etc/fstab#, заменив в нём упоминания старого имени устройства [.filename]#da0# новым именем устройства зеркала [.filename]#gm0#.

[NOTE]
====
Если man:vi[1] - ваш любимый текстовый редактор, то эта задача решается просто:

[source,bash]
....
# vi /etc/fstab
....

Сделайте резервную копию файла [.filename]#fstab#, набрав в man:vi[1] `:w /etc/fstab.bak`. Затем замените все части строк, содержащие имя устройства [.filename]#da0#, на имя [.filename]#gm0#, набрав `:%s/da/mirror\/gm/g`.
====

Независимо от аппаратного интерфейса дисков (SCSI или ATA), устройство RAID будет именоваться всегда одинаково - [.filename]#gm#. Содержимое файла [.filename]#fstab# должно выглядеть подобно следующему:

[.programlisting]
....
# Device                Mountpoint      FStype  Options         Dump    Pass#
/dev/mirror/gm0s1b      none            swap    sw              0       0
/dev/mirror/gm0s1a      /               ufs     rw              1       1
/dev/mirror/gm0s1d      /usr            ufs     rw              0       0
/dev/mirror/gm0s1f      /home           ufs     rw              2       2
#/dev/mirror/gm0s2d     /store          ufs     rw              2       2
/dev/mirror/gm0s1e      /var            ufs     rw              2       2
/dev/acd0               /cdrom          cd9660  ro,noauto       0       0
....

Перезагрузите систему:

[source,bash]
....
# shutdown -r now
....

С этого момента во время каждой загрузки система должна использовать устройство [.filename]#gm0# вместо устройства [.filename]#da0#. Удостовериться в этом можно так: дождитесь загрузки системы, наберите команду `mount` и просмотрите её вывод:

[source,bash]
....
# mount
Filesystem         1K-blocks    Used    Avail Capacity  Mounted on
/dev/mirror/gm0s1a   1012974  224604   707334    24%    /
devfs                      1       1        0   100%    /dev
/dev/mirror/gm0s1f  45970182   28596 42263972     0%    /home
/dev/mirror/gm0s1d   6090094 1348356  4254532    24%    /usr
/dev/mirror/gm0s1e   3045006 2241420   559986    80%    /var
devfs                      1       1        0   100%    /var/named/dev
....

Как и ожидалось, вывод выглядит корректно. И в заключение, чтобы начать синхронизацию данных, включите в зеркало диск [.filename]#da1# при помощи следующей команды:

[source,bash]
....
# gmirror insert gm0 /dev/da1
....

Во время построения зеркала статус процесса построения может быть проверен следующей командой:

[source,bash]
....
# gmirror status
....

Вывод вышеприведённой команды для построенного и синхронизированного зеркала выглядит подобно следующему:

[source,bash]
....
      Name    Status  Components
mirror/gm0  COMPLETE  da0
                      da1
....

Если есть какие-либо неполадки или зеркало находится в процессе построения, в выводе команды будет обозначен статус `DEGRADED` вместо статуса `COMPLETE`.

=== Решение проблем

==== Система не загружается

Если система прекращает загрузку и выдает строку:

[.programlisting]
....
ffs_mountroot: can't find rootvp
Root mount failed: 6
mountroot>
....

Перезагрузите компьютер кнопкой питания или кнопкой "Reset". В загрузочном меню выберите опцию (6). Это приведет к тому, что система выдаст приглашение man:loader[8]. Загрузите модуль ядра вручную:

[source,bash]
....
OK? load geom_mirror
OK? boot
....

Если это сработало, модуль ядра по какой-либо причине не загрузился правильно. Проверьте корректность соответствующей записи в [.filename]#/boot/loader.conf#. Если проблема осталась, добавьте строку:

[.programlisting]
....
options	GEOM_MIRROR
....

в файл конфигурации ядра, пересоберите и переустановите ядро. Это должно устранить проблему.

=== Восстановление после дисковых сбоев

Примечательной особенностью зеркалирования является то, что если диск вышел из строя, то он, пожалуй, может быть заменён вообще без ущерба для данных.

Принимая во внимание предыдущую конфигурацию RAID1, предположим, что устройство [.filename]#da1# вышло из строя, и ему требуется замена. Перед заменой определите, какой именно диск вышел из строя, а потом выключите систему. Теперь дефектный диск может быть заменён новым, после чего необходимо снова загрузить систему. После загрузки системы для замещения диска в зеркале могут быть использованы следующие команды:

[source,bash]
....
# gmirror forget gm0
....

[source,bash]
....
# gmirror insert gm0 /dev/da1
....

Для наблюдения за статусом построения используйте команду `gmirror status`. Вывод этой команды достаточно прост и понятен.

[[geom-ggate]]
== Сетевые устройства GEOM Gate

GEOM включает в себя поддержку работы с удаленными устройствами по сети, например с дисками, CD-ROM и т.д. путем использования gate утилит. Это подобно работе с NFS.

Для начала необходимо создать файл экспорта. В этом файле указывается, кому разрешен доступ к экспортируемым ресурсам и какой уровень доступа предоставляется. Например для того, чтобы экспортировать четвертый слайс первого SCSI диска, достаточно следующей записи в файле [.filename]#/etc/gg.exports#:

[.programlisting]
....
192.168.1.0/24 RW /dev/da0s4d
....

Это позволит всем компьютерам внутри частной сети получить доступ к разделу [.filename]#da0s4d#.

Чтобы экспортировать устройство, убедитесь, что оно не смонтировано, и запустите сервер man:ggated[8]:

[source,bash]
....
# ggated
....

Теперь, чтобы смонтировать устройство на клиентском компьютере выполните следующие команды:

[source,bash]
....
# ggatec create -o rw 192.168.1.1 /dev/da0s4d
ggate0
# mount /dev/ggate0 /mnt
....

С этого момента устройство доступно в точке монтирования [.filename]#/mnt#.

[NOTE]
====
Необходимо заметить, что попытка смонтировать устройство, уже смонтированное как сетевой или локальный диск, закончится неудачей.
====

Когда устройство больше не нужно, оно может быть размонтировано командой man:umount[8], как любое другое дисковое устройство.

[[geom-glabel]]
== Метки дисковых устройств

Во время загрузки системы, ядро FreeBSD создает файлы для обнаруженных устройств. Этот метод обнаружения устройств создает некоторые проблемы, например если новое дисковое устройство подключается через USB. Может получиться так, что этому диску будет присвоено имя устройства [.filename]#da0#, а устройство с прежним именем [.filename]#da0# получит следующее имя, [.filename]#da1#. Это приведет к проблемам монтирования файловых систем, записанных в [.filename]#/etc/fstab#. На самом деле, это может даже помешать загрузке системы.

Одно из решений состоит в расположении SCSI устройств в таком порядке, чтобы новые устройства, добавляемые к SCSI контроллеру, занимали свободные номера устройств. Но что делать с USB устройствами, которые могут занять место основного SCSI диска? Это случается потому, что USB устройства обычно тестируются до SCSI контроллера. Решение может состоять в подключении этих устройств после загрузки системы. Другое решение - использование ATA диска и исключение SCSI устройств из [.filename]#/etc/fstab#.

Есть и лучшее решение. С помощью утилиты `glabel`, администратор или пользователь могут пометить дисковые устройства и использовать эти метки в [.filename]#/etc/fstab#. Поскольку `glabel` сохраняет метки в последнем секторе заданного устройства, они сохраняются и после перезагрузки. Используя эти метки вместо имени устройств, можно всегда смонтировать файловую систему независимо от назначенного имени устройства.

[NOTE]
====
Очевидно, что метки должны быть постоянными. Утилита `glabel` может использоваться для создания как временных, так и постоянных меток. Только постоянные метки сохраняются после перезагрузок. Прочтите man:glabel[8] для получения более подробной информации о различии между метками.
====

=== Типы меток и примеры

Существует два типа меток, основной (generic) тип и метки файловой системы. Метки могут быть постоянными или временными. Постоянные метки создаются командой man:tunefs[8] или man:newfs[8]. В дальнейшем они будут автоматически создаваться в подкаталоге каталога [.filename]#/dev#, имя которого определяется в соответствии с типом файловой системы. Например, метки файловых систем UFS2 будут расположены в каталоге [.filename]#/dev/ufs#. Постоянные метки также можно создать при помощи команды `glabel label`. Эти метки не зависят от типа файловой системы, поэтому они будут перечисляться в каталоге [.filename]#/dev/label#.

Временные метки не сохраняются после перезагрузки. Эти метки создаются в каталоге [.filename]#/dev/label#, они хорошо подходят для экспериментов. Временную метку можно создать командой `glabel create`. За более детальной информацией обратитесь к странице справочника man:glabel[8].

Чтобы создать постоянную метку для файловой системы UFS2 не нарушая самих данных, выполните следующую команду:

[source,bash]
....
# tunefs -L home /dev/da3
....

[WARNING]
====

Если файловая система заполнена, это может привести к повреждению данных; в случае заполненной файловой системы надо или удалить ненужные файлы, или не добавлять метки.
====

Метка должна появиться в [.filename]#/dev/ufs# и может быть добавлена в [.filename]#/etc/fstab#:

[.programlisting]
....
/dev/ufs/home		/home            ufs     rw              2      2
....

[NOTE]
====
Во время запуска `tunefs` файловая система не должна быть смонтирована.
====

Теперь файловую систему можно смонтировать как обычно:

[source,bash]
....
# mount /home
....

Если модуль ядра [.filename]#geom_label.ko# указан в [.filename]#/boot/loader.conf# и загружается вместе с системой, или в ядре указана опция `GEOM_LABEL`, метку устройства можно изменять без какого-либо негативного для системы эффекта.

Файловая система может быть создана с меткой по умолчанию путем использования флага `-L` команды `newfs`. Обратитесь к странице справочника man:newfs[8] за более подробной информацией.

Для удаления метки можно использовать следующую команду:

[source,bash]
....
# glabel destroy home
....

В следующем примере показано, как устанавливаются метки на разделы загрузочного диска.

.Установка меток на разделы загрузочного диска
[example]
====
Установка и задействование постоянных меток на разделах загрузочного диска предоставит возможность операционной системе загружаться нормально в том случае, если диск был переключен на другой контроллер, или даже переставлен на другую машину. В этом примере был задействован один диск ATA, определяемый системой как [.filename]#ad0#. Также в примере подразумевается, что система использует типичную для FreeBSD схему разделения дискового пространства на слайсы и размещения на них файловых систем [.filename]#/#, [.filename]#/var#, [.filename]#/usr#, [.filename]#/tmp# и раздела подкачки.

Перезагрузите систему, дождитесь меню загрузчика. Нажатием клавиши kbd:[4] выберите однопользовательский режим. Далее, введите следующие команды:

[source,bash]
....
# glabel label rootfs /dev/ad0s1a
GEOM_LABEL: Label for provider /dev/ad0s1a is label/rootfs
# glabel label var /dev/ad0s1d
GEOM_LABEL: Label for provider /dev/ad0s1d is label/var
# glabel label usr /dev/ad0s1f
GEOM_LABEL: Label for provider /dev/ad0s1f is label/usr
# glabel label tmp /dev/ad0s1e
GEOM_LABEL: Label for provider /dev/ad0s1e is label/tmp
# glabel label swap /dev/ad0s1b
GEOM_LABEL: Label for provider /dev/ad0s1b is label/swap
# exit
....

Система продолжит загрузку в многопользовательский режим. По завершении загрузки откройте файл [.filename]#/etc/fstab# и замените в нём традиционные имена файлов устройств на соответствующие устройствам метки. Результат будет выглядеть подобно следующему:

[.programlisting]
....
# Device                Mountpoint      FStype  Options         Dump    Pass#
/dev/label/swap         none            swap    sw              0       0
/dev/label/rootfs       /               ufs     rw              1       1
/dev/label/tmp          /tmp            ufs     rw              2       2
/dev/label/usr          /usr            ufs     rw              2       2
/dev/label/var          /var            ufs     rw              2       2
....

Перезагрузите еще раз систему. Если всё прошло успешно, система загрузится как обычно, а вывод команды `mount` отобразит следующее:

[source,bash]
....
# mount
/dev/label/rootfs on / (ufs, local)
devfs on /dev (devfs, local)
/dev/label/tmp on /tmp (ufs, local, soft-updates)
/dev/label/usr on /usr (ufs, local, soft-updates)
/dev/label/var on /var (ufs, local, soft-updates)
....

====

Начиная с FreeBSD 7.2, GEOM класс man:glabel[8] поддерживает новый тип меток для файловых систем UFS. Новый тип меток базируется на уникальных идентификаторах файловых систем, называемых `ufsid`. Во время загрузки системы они автоматически создаются и помещаются в каталог [.filename]#/dev/ufsid#. Перечисление меток должным образом в файле [.filename]#/etc/fstab# делает возможным монтирование разделов по значениям `ufsid`. Чтобы получить перечень файловых систем и соответствующих им меток `ufsid`, выполните команду `glabel status`:

[source,bash]
....
% glabel status
                  Name  Status  Components
ufsid/486b6fc38d330916     N/A  ad4s1d
ufsid/486b6fc16926168e     N/A  ad4s1f
....

В данном примере [.filename]#ad4s1d# содержит файловую систему [.filename]#/var#, а [.filename]#ad4s1f# соответствует файловой системе [.filename]#/usr#. Эти файловые системы можно также монтировать, указав значения их `ufsid` в файле [.filename]#/etc/fstab#:

[.programlisting]
....
/dev/ufsid/486b6fc38d330916        /var        ufs        rw        2      2
/dev/ufsid/486b6fc16926168e        /usr        ufs        rw        2      2
....

Таким способом могут быть смонтированы любые разделы с метками `ufsid`, что исключает необходимость создания постоянных меток вручную и в то же время позволяет воспользоваться преимуществами монтирования по меткам.

[[geom-gjournal]]
== Журналирование UFS средствами GEOM

С выходом FreeBSD 7.0 был реализован долгожданный механизм ведения журналов для файловых систем. Сама реализация этого механизма осуществляется средствами системы GEOM, а конфигурирование выполняется утилитой man:gjournal[8].

Что такое журналирование? Журналирование сохраняет протокол транзакций файловой системы, то есть: изменения, составляющие логически завершенную операцию записи, сперва вносятся в журнал, а модификация метаданных и данных самого файла выполняется позже. В дальнейшем журнал может быть задействован для повторного выполнения транзакций на файловой системе с целью предотвращения нарушения целостности файловой системы.

Журналирование - это еще одним механизм предотвращения утери данных и нарушения целостности файловой системы. В отличие от механизма Soft Updates, который отслеживает и периодически сохраняет обновления метаданных, и механизма снэпшотов, который создает образ файловой системы, сам журнал хранится в специально отведенном для этой задачи пространстве диска, и, в некоторых случаях, может содержаться целиком на отдельном диске.

В отличие от других реализаций журналирования файловых систем, метод `gjournal` работает на блочном уровне, он не встроен в файловую систему; это лишь надстройка над системой GEOM.

Чтобы включить поддержку `gjournal`, в файле конфигурации ядра FreeBSD должна присутствовать следующая опция (включено по умолчанию для FreeBSD 7.0 и более поздних версий систем):

[.programlisting]
....
options	UFS_GJOURNAL
....

Журналируемым устройствам, монтируемым во время загрузки системы, также потребуется модуль ядра [.filename]#geom_journal.ko#. Внесите следующую запись в файл [.filename]#/boot/loader.conf#:

[.programlisting]
....
geom_journal_load="YES"
....

В качестве альтернативы, функции вышеупомянутого модуля можно встроить в специализированное ядро. Для этого добавьте следующую опцию в файл конфигурации ядра:

[.programlisting]
....
options	GEOM_JOURNAL
....

Для создания журнала на новой файловой системе выполните следующие шаги (здесь и далее подразумевается, что [.filename]#da4# есть новый SCSI диск):

[source,bash]
....
# gjournal load
# gjournal label /dev/da4
....

На этом этапе в каталоге [.filename]#/dev# должны присутствовать файлы устройств [.filename]#/dev/da4# и [.filename]#/dev/da4.journal#. Теперь необходимо создать файловую систему:

[source,bash]
....
# newfs -O 2 -J /dev/da4.journal
....

Предыдущая команда создаст файловую систему UFS2 на журналируемом устройстве.

Смонтируйте устройство в требуемый каталог файловой системы:

[source,bash]
....
# mount /dev/da4.journal /mnt
....

[NOTE]
====
В случае наличия нескольких слайсов, журнал создается для каждого из них. Например, если есть два слайса, и они называются [.filename]#ad4s1# и [.filename]#ad4s2#, то утилитой `gjournal` создаются файлы устройств [.filename]#ad4s1.journal# и [.filename]#ad4s2.journal#. 
====

Для увеличения производительности может потребоваться хранение журнала на отдельном диске. В таких случаях необходимо указать имя поставщика журнала или устройства хранения после имени устройства, на котором планируется включение журналирования. Журналирование также может быть активировано утилитой `tunefs` на действующих файловых системах; однако, всегда создавайте резервную копию перед попытками изменить настройки файловой системы. В большинстве случаев, выполнение команды `gjournal` завершится ошибкой, если создание журнала невозможно, в то время как некорректное использование команды `tunefs` не защитит против потери данных.

Также возможно журналирование загрузочного диска системы FreeBSD. За детальными инструкциями по этой возможности обратитесь к статье link:{gjournal-desktop}[Настройка журналирования UFS для настольного компьютера].
