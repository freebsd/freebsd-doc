---
title: Глава 22. Последовательные соединения
part: Часть IV. Сетевые коммуникации
prev: books/handbook/partiv
next: books/handbook/ppp-and-slip
showBookMenu: true
weight: 27
path: "/books/handbook/serialcomms/"
---

[[serialcomms]]
= Последовательные соединения
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 22
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/serialcomms/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[serial-synopsis]]
== Краткое описание

В UNIX(R) всегда была поддержка последовательных соединений. Фактически, самые первые UNIX(R) машины использовали последовательные линии для пользовательского ввода/вывода. Многое изменилось с тех пор, когда среднестатистический "терминал" состоял из 10-символов-в-секунду последовательного принтера и клавиатуры. Эта глава рассказывает о некоторых способах, которыми FreeBSD использует последовательные соединения.

Прочитав эту главу, вы узнаете:

* Как подсоединить терминалы к системе FreeBSD.
* Как использовать модем для дозвона на удаленные хосты.
* Как разрешить удаленным пользователям входить в вашу систему с помощью модема.
* Как загрузить систему с последовательной консоли.

Перед прочтением этой главы вам потребуется:

* Узнать как настраивать и устанавливать новое ядро (crossref:kernelconfig[kernelconfig, Настройка ядра FreeBSD]).
* Понять, что такое права доступа и процессы UNIX(R) (crossref:basics[basics, Основы UNIX]).
* Кроме этого вам потребуется техническое руководство на последовательное оборудование (модем или мультипортовую карту), которую вы хотите использовать с FreeBSD.

[[serial]]
== Введение

[[serial-terminology]]
=== Терминология

bps::
Бит в секунду (Bits per Second) - скорость передачи данных

DTE::
Терминальное оборудование (Data Terminal Equipment) - например, ваш компьютер

DCE::
Оборудование связи (Data Communications Equipment) - ваш модем

RS-232::
Стандарт EIA для аппаратных последовательных соединений

При упоминании скорости передачи данных, в этой главе не используется термин "бод" ("baud"). Бод означает количество электрических импульсов, которые могут быть переданы за период времени, а "bps" это _корректный_ термин для использования (он хотя бы не создает столько проблем как предыдущий).

[[serial-cables-ports]]
=== Кабели и порты

Для подсоединения модема или терминала к системе FreeBSD потребуется последовательный порт и подходящий кабель для последовательного устройства. Если вы уже знаете о аппаратном обеспечении и требуемых кабелях, можете пропустить этот раздел.

[[term-cables]]
==== Кабели

Есть несколько различных видов последовательных кабелей. Два наиболее часто используемых в нашей ситуации типа это нуль-модемный и стандартный ("прямой") RS-232 кабель. Документация на оборудование должна описывать тип требуемого кабеля.

[[term-cables-null]]
===== Нуль-модемные кабели

Нуль модемный кабель пропускает некоторые сигналы, такие как "Signal Ground", напрямую, а другие "заворачивает". Например, контакт "Transmitted Data" на одном конце соединяется с контактом "Received Data" на другом.

Вы можете сделать собственный кабель для использования с терминалами. Эта таблица показывает названия <<serialcomms-signal-names,сигналов RS-232C>> и номера контактов на разъеме DB-25. Заметим, что стандарт описывает соединение контактов номер 1 как сигнал _Protective Ground_, но его часто не делают. Некоторым терминалам достаточно сигналов на контактах 2, 3 и 7; другим требуется большее число сигналов, как показано на примерах ниже:

.Нуль-модемный кабель DB-25 - DB-25
[cols="1,1,1,1,1", frame="none", options="header"]
|===
<| Сигнал
<| Контакт
| 
<| Контакт
<| Сигнал

|SG
|7
|соединен с
|7
|SG

|TD
|2
|соединен с
|3
|RD

|RD
|3
|соединен с
|2
|TD

|RTS
|4
|соединен с
|5
|CTS

|CTS
|5
|соединен с
|4
|RTS

|DTR
|20
|соединен с
|6
|DSR

|DTR
|20
|соединен с
|8
|DCD

|DSR
|6
|соединен с
|20
|DTR

|DCD
|8
|соединен с
|20
|DTR
|===

Вот еще две распространенные в настоящее время схемы.

.Нуль-модемный кабель DB-9 - DB-9
[cols="1,1,1,1,1", frame="none", options="header"]
|===
<| Сигнал
<| Контакт
| 
<| Контакт
<| Сигнал

|RD
|2
|соединен с
|3
|TD

|TD
|3
|соединен с
|2
|RD

|DTR
|4
|соединен с
|6
|DSR

|DTR
|4
|соединен с
|1
|DCD

|SG
|5
|соединен с
|5
|SG

|DSR
|6
|соединен с
|4
|DTR

|DCD
|1
|соединен с
|4
|DTR

|RTS
|7
|соединен с
|8
|CTS

|CTS
|8
|соединен с
|7
|RTS
|===

.Нуль-модемный кабель DB-9 - DB-25
[cols="1,1,1,1,1", frame="none", options="header"]
|===
<| Сигнал
<| Контакт
| 
<| Контакт
<| Сигнал

|RD
|2
|соединен с
|2
|TD

|TD
|3
|соединен с
|3
|RD

|DTR
|4
|соединен с
|6
|DSR

|DTR
|4
|соединен с
|8
|DCD

|SG
|5
|соединен с
|7
|SG

|DSR
|6
|соединен с
|20
|DTR

|DCD
|1
|соединен с
|20
|DTR

|RTS
|7
|соединен с
|5
|CTS

|CTS
|8
|соединен с
|4
|RTS
|===

[NOTE]
====
Для соединения одного контакта с одной стороны с двумя контактами на другой обычно пару контактов на одной стороне соединяют коротким проводом, а затем один из них - длинным с единственным контактом на дальней стороне.
====

Приведенные диаграммы описывают наиболее популярные схемы распайки. В других вариантах (описанных в книге _RS-232 Made Easy_) SG соединяется с SG, TD соединяется с RD, RTS и CTS соединяются с DCD, DTR соединяется с DSR, и наоборот.

[[term-cables-std]]
===== Стандартные кабели RS-232C

Стандартный последовательный кабель пропускает все RS-232C сигналы напрямую. Так, "send data" на одном конце кабеля соединяется с контактом "send data" на другом конце. Этот тип кабеля предназначен для подсоединения модема, а также подходит для некоторых терминалов.

[[term-ports]]
==== Порты

Последовательные порты это устройства, через которые данные передаются между компьютером с FreeBSD и терминалом. Этот раздел описывает типы существующих портов и их адресацию в FreeBSD.

[[term-portkinds]]
===== Типы портов

Существует несколько типов последовательных портов. Перед изготовлением кабеля, вам потребуется убедиться, что он подходит к портам терминала и системы FreeBSD.

Большинство терминалов используют порты DB25. Персональные компьютеры, включая PC под управлением FreeBSD, используют порты DB25 или DB9. Если у вас есть мультипортовая последовательная карта для PC, там могут быть RJ-12 или RJ-45 порты.

Обратитесь к сопровождающей документации на оборудование за информацией об используемых портах. Можно также определить тип используемых портов по их внешнему виду.

[[term-portnames]]
===== Имена портов

В FreeBSD доступ к каждому последовательному порту может быть получен через файл в каталоге [.filename]#/dev#. Есть два различных типа файлов:

* Порты входящих соединений (dial-in) называются [.filename]#/dev/ttydN#, где _N_ это номер порта начиная с нуля. Обычно, порты входящих соединений используются для терминалов. Для корректной работы этим портам требуется, чтобы последовательный кабель передавал сигнал data carrier detect (DCD).
* Порты исходящих соединений (call-out) называются [.filename]#/dev/cuadN#. Они обычно используются не для терминалов, а только для модемов. Вы можете использовать эти порты если последовательный кабель или терминал не поддерживает сигнал DCD.
+
[NOTE]
====
Call-out порты в FreeBSD 5.X и ранее именуются [.filename]#/dev/cuaaN#. 
====

Если вы соединили терминал с первым последовательным портом ([.filename]#COM1# в MS-DOS(R)), используйте [.filename]#/dev/ttyd0# для доступа к терминалу. Если терминал соединен со вторым последовательным портом (известным также как [.filename]#COM2#), используйте [.filename]#/dev/ttyd1#, и так далее.

=== Настройка ядра

FreeBSD c настройками по умолчанию поддерживает последовательные порты. В мире MS-DOS(R) они известны как [.filename]#COM1#, [.filename]#COM2#, [.filename]#COM3#, и [.filename]#COM4#. На данный момент в FreeBSD есть поддержка как "простых" мультипортовых карт с последовательными интерфейсами, таких как BocaBoard 1008 и 2016, так и более "умных" мультипортовых карт, например карт Digiboard и Stallion Technologies. Тем не менее, ядро по умолчанию определяет только стандартные COM порты.

Чтобы увидеть, как ядро определяет последовательные порты, просмотрите сообщения, выводимые во время загрузки ядра, или используйте команду `/sbin/dmesg` для вывода сообщений ядра еще раз. В частности, обратите внимание на сообщения, начинающиеся с символов `sio`.

[TIP]
====

Для просмотра только тех сообщений, которые содержат слово `sio`, используйте команду:

[source,shell]
....
# /sbin/dmesg | grep 'sio'
....

====

Например, в системе с четырьмя последовательными портами, появятся такие специфичные для последовательных портов сообщения:

[source,shell]
....
sio0 at 0x3f8-0x3ff irq 4 on isa
sio0: type 16550A
sio1 at 0x2f8-0x2ff irq 3 on isa
sio1: type 16550A
sio2 at 0x3e8-0x3ef irq 5 on isa
sio2: type 16550A
sio3 at 0x2e8-0x2ef irq 9 on isa
sio3: type 16550A
....

Если ядро не распознает все последовательные порты, вам возможно потребуется настроить ядро FreeBSD, изменив файл [.filename]#/boot/device.hints#. Вы можете также закомментировать или вовсе удалить строки, относящиеся к отсутствующим у вас устройствам.

Обратитесь к странице справочника man:sio[4] за дополнительной информацией о настройке последовательных портов и мультипортовых карт. Будьте осторожны при использовании настроек, которые работали в предыдущих версиях FreeBSD, поскольку флаги устройств и синтаксис изменились в новых версиях.

[NOTE]
====
`port IO_COM1` это синоним для `port 0x3f8`, `IO_COM2` для `0x2f8`, `IO_COM3` для `0x3e8`, и `IO_COM4` для `0x2e8`. Это наиболее часто используемые для соответствующих последовательных портов адреса. Наиболее часто используемые прерывания 4, 3, 5, и 9. Имейте ввиду, что обычные последовательные порты _не могут_ совместно использовать прерывания на ISA PC (на мультипортовых картах есть электроника, позволяющая всем чипам 16550A на плате совместно использовать одно или два IRQ).
====

=== Специальные файлы устройств

К большинству устройств ядра можно получить доступ через "специальные файлы устройств", расположенные в каталоге [.filename]#/dev#. К устройствам [.filename]#sio# можно получить доступ через [.filename]#/dev/ttydN# (устройства входящих вызовов, dial-in) и [.filename]#/dev/cuadN# (устройства исходящих вызовов, call-out). FreeBSD предоставляет также устройства инициализации ([.filename]#/dev/ttydN.init# и [.filename]#/dev/cuadN.init# в случае FreeBSD 6.X, [.filename]#/dev/ttyidN# и [.filename]#/dev/cuaiaN# для FreeBSD 5.X), устройства блокировки ([.filename]#/dev/ttydN.lock# и [.filename]#/dev/cuadN.lock# в случае FreeBSD 6.X, [.filename]#/dev/ttyldN# и [.filename]#/dev/cualaN# для FreeBSD 5.X). Первые используются для инициализации параметров порта при каждом его открытии (таких как `crtscts` для модемов, использующих сигналы `RTS/CTS` для управления потоком). Устройства блокировки используются для установки флага блокировки на порт и предотвращения изменения определенных параметров пользователями или программами; обратитесь к страницам справочника man:termios[4], man:sio[4] и man:stty[1] соответственно за информацией о параметрах терминала, блокировании и инициализации устройств и настройке терминала.

[[serial-hw-config]]
=== Настройка последовательных портов

Устройство [.filename]#ttydN# (или [.filename]#cuadN#) это обычное устройство, которое потребуется открыть для приложений. Когда процесс открывает устройство применяются настройки ввода/вывода терминала по умолчанию. Вы можете посмотреть эти настройки с помощью команды

[source,shell]
....
# stty -a -f /dev/ttyd1
....

Если вы измените настройки устройства, они будут действовать до его закрытия. После повторного открытия, оно вернется к настройкам по умолчанию. Для изменения настроек по умолчанию, вы можете открыть и изменить установки "начального состояния" устройства. Например, для включения по умолчанию режима `CLOCAL`, 8-битного соединения и контроля передачи `XON/XOFF` для [.filename]#ttyd5#, выполните:

[source,shell]
....
# stty -f /dev/ttyd5.init clocal cs8 ixon ixoff
....

Инициализация последовательных устройств контролируется файлом [.filename]#/etc/rc.d/serial#. Этот файл определяет настройки последовательных устройств по умолчанию.

Для предотвращения изменения программами отдельных установок, настройте "состояние блокировки" устройства. Например, для установки значения скорости [.filename]#ttyd5# в 57600 bps, выполните:

[source,shell]
....
# stty -f /dev/ttyd5.lock 57600
....

Теперь приложение, открывающее [.filename]#ttyd5# и пытающееся изменить скорость порта, получит скорость 57600 bps.

И конечно, сделайте запись начальных значений и состояния блокировки устройств доступной только учетной записи `root`.

[[term]]
== Терминалы

Терминалы предоставляют удобный и дешевый способ доступа к системе FreeBSD, когда вы не сидите за консолью компьютера и не подключены к сети. Этот раздел описывает использование терминалов в FreeBSD.

[[term-uses]]
=== Пользователи и типы терминалов

В первых системах UNIX(R) не было консолей. Вместо этого, пользователи входили и запускали программы через терминалы, которые были подключены к последовательным портам компьютеров. Это очень похоже на использование модема и программного обеспечения терминала для дозвона до удаленной системы и выполнения только-текстовой работы.

Консоли современных PC поддерживают высококачественную графику, но возможность входа по последовательному порту на сегодняшний день все еще доступна почти в каждой UNIX(R) подобной операционной системе; FreeBSD не исключение. Используя терминал, подключенный к неиспользуемому последовательному порту, вы можете войти и запустить текстовую программу, которую обычно запускаете в текстовой консоли или в окне `xterm` системы X Window.

Для корпоративных пользователей, вы можете подсоединить множество терминалов к системе FreeBSD и поставить их на столы пользователей. Для домашнего пользователя, устаревший IBM PC или Macintosh(R) может быть подключен в качестве терминала к более мощному компьютеру под управлением FreeBSD. Вы можете превратить однопользовательский компьютер в мощную многопользовательскую систему.

В FreeBSD три вида терминалов:

* <<term-dumb,Простые (dumb) терминалы>>
* <<term-pcs,"PC, работающие в качестве терминалов">>
* <<term-x,X терминалы>>

В оставшейся части раздела описывается каждый вид.

[[term-dumb]]
==== Простые терминалы

Простые терминалы это специализированное оборудование, позволяющее соединять компьютеры через последовательные линии. Они называются "простыми", поскольку их вычислительных возможностей хватает только для отображения, отправки и получения текста. Вы не сможете запустить на них никаких программ. Компьютер, к которому подсоединяется терминал, предоставляет все возможности для запуска текстовых редакторов, компиляторов, почтовых программ, игр и так далее.

Есть сотни видов простых терминалов, изготовленных различными производителями, включая DEC VT-100 и Wyse WY-75. Почти любой терминал может работать с FreeBSD. Некоторые high-end терминалы даже могут отображать графику, но только отдельные программные пакеты могут получить преимущество от этих расширенных возможностей.

Простые терминалы популярны в рабочей среде, где не требуется доступ к графическим приложениям, например тем, которые предоставляет система X Window.

[[term-pcs]]
==== PC, работающие в качестве терминалов

Если <<term-dumb,простые терминалы>> могут только отображать, отправлять и получать текст, возможностей абсолютно любого персонального компьютера хватит для работы в роли простого терминала. Все, что вам потребуется, это подходящий кабель и какая-нибудь программа _эмулятора терминала_.

Это популярная домашняя конфигурация. Например, когда ваша вторая половина занята работой на системной консоли FreeBSD, вы можете одновременно выполнять только-текстовую работу с менее мощного персонального компьютера, подключенного к системе FreeBSD.

[[term-x]]
==== X терминалы

X терминалы это наиболее сложный тип существующих терминалов. Вместо подключения к последовательному порту, они обычно подключаются к сети, например Ethernet. Вместо работы только с текстовыми приложениями, они могут отображать любое X приложение.

Мы представляем X терминалы только ради полноты описания. Тем не менее, эта глава _не_ охватывает установку, настройку или использование X терминалов.

[[term-config]]
=== Настройка

Этот раздел описывает, что нужно сделать для настройки системы FreeBSD и включения входа в систему через терминал. Предполагается, что вы уже подключили терминал и настроили ядро для включения поддержки последовательного порта, к которому он подключен.

Обратитесь к главе crossref:boot[boot, Процесс загрузки FreeBSD] за информацией о процессе `init`, отвечающем за контроль над всеми процессами и за инициализацию системы во время загрузки. Одна из задач, выполняемых `init` - чтение файла [.filename]#/etc/ttys# и запуск процесса `getty` на доступных терминалах. Процесс `getty` отвечает за чтение имени пользователя и запуск программы `login`.

Таким образом, для настройки терминалов в системе FreeBSD необходимо выполнить следующие действия под `root`:

[.procedure]
====
. Добавить строку к [.filename]#/etc/ttys# для файла из каталога [.filename]#/dev#, представляющего последовательный порт, если этой строки еще нет.
. Настроить запуск команды `/usr/libexec/getty` на этом порту и указать соответствующий тип _getty_ в файле [.filename]#/etc/gettytab#.
. Указать тип терминала по умолчанию.
. Переключить порт в состояние "on" ("включен")
. Указать, должен ли порт быть "secure" ("безопасным")
. Заставить `init` перечитать файл [.filename]#/etc/ttys#.
====

Опционально, вы можете настроить свой тип _getty_ для использования на шаге 2, добавив описание в файл [.filename]#/etc/gettytab#. За описанием обратитесь к страницам справочника man:gettytab[5] и man:getty[8].

[[term-etcttys]]
==== Добавление строки в [.filename]#/etc/ttys#

В файле [.filename]#/etc/ttys# находится список всех портов системы FreeBSD, на которые возможен вход. Например, там находится первая виртуальная консоль [.filename]#ttyv0#. Вы можете войти на консоль с помощью этой записи. Файл содержит записи и для других виртуальных консолей, последовательных портов, и псевдо-терминалов. Название файла последовательного порта из каталога [.filename]#/dev# приводится без префикса [.filename]#/dev# (например, устройство [.filename]#/dev/ttyv0# будет записано как [.filename]#ttyv0#).

Установка FreeBSD по умолчанию включает файл [.filename]#/etc/ttys# с поддержкой первых четырех последовательных портов: от [.filename]#ttyd0# до [.filename]#ttyd3#. Если вы подключаете терминал к одному из этих портов, добавлять записи терминалов не потребуется.

[[ex-etc-ttys]]
.Добавление записей терминалов в [.filename]#/etc/ttys#
[example]
====
Предположим, вы хотите подключить два терминала к системе: Wyse-50 и старый 286 IBM PC с эмулятором терминала VT-100. Мы подключаем Wyse к второму последовательному порту и 286 к шестому последовательному порту (порт на мультипортовой карте). Соответствующие строки в [.filename]#/etc/ttys# будут выглядеть так:

[.programlisting]
....
ttyd1  "/usr/libexec/getty std.38400"  wy50  on  insecure
ttyd5   "/usr/libexec/getty std.19200"  vt100  on  insecure
....

* Первое поле, как правило, указывает имя специального файла терминала, в соответствии с его именем в [.filename]#/dev#.
* Второе поле - это команда, исполняемая для этого терминала, обычно man:getty[8]. `getty` инициализирует и открывает линию, устанавливает ее скорость, приглашает пользователя к вводу имени пользователя, а затем выполняет программу man:login[1].Программа `getty` принимает один (опциональный) параметр в командной строке, тип _getty_. Тип _getty_ определяет характеристики терминальной линии, такие как значение bps и четность. Программа `getty` считывает эти характеристики из файла [.filename]#/etc/gettytab#.Файл [.filename]#/etc/gettytab# содержит множество записей для терминалов, как для старых так и для новых. Почти во всех случаях запись, начинающаяся с текста `std`, предназначена для работы с аппаратными терминалами. Эти записи игнорируют четность. Запись `std` есть для каждого значения bps от 110 до 115200. Конечно, вы можете добавить собственные записи в этот файл. Страница справочника man:gettytab[5] содержит дополнительную информацию.При установке типа _getty_ в файле [.filename]#/etc/ttys# убедитесь в наличии соответствующей записи терминала.Например, Wyse-50 не использует четность и соединяется на 38400 bps. 286 PC не использует четность и соединяется на 19200 bps.
* Третье поле определяет тип терминала, обычно подключаемого к этой линии tty. Для портов входящих соединений обычно используется значение `unknown` или `dialup`, поскольку пользователь может подключить практически любой тип терминала или программу. Для аппаратных терминалов тип не меняется, поэтому вы можете поместить в это поле определенный тип терминала из базы данных man:termcap[5].Например, Wyse-50 использует реальный тип терминала, а 286 PC, работающий с Procomm, настроен на эмуляцию VT-100.
* Четвертое поле определяет должен ли порт быть включен. Размещение здесь `on` укажет процессу `init` запустить программу, указанную во втором поле, `getty`. Если вы поместите `off` в это поле, команда `getty` не будет запущена и вход на этот порт станет невозможен.
* Последнее поле используется, чтобы указать, является ли порт безопасным. Пометка порта безопасным означает, что вы доверяете ему достаточно для того, чтобы разрешить учетной записи `root` (или любой учетной записи с UID 0) входить с этого порта. Небезопасные порты не разрешат вход `root`. На небезопасном порту пользователи должны войти с через непривилегированную учетную запись, а затем использовать man:su[1] или подобный механизм для получения привилегий суперпользователя.Настоятельно рекомендуется использовать "insecure" даже для терминалов, находящихся за закрытыми дверями. Довольно легко использовать `su` после входа, если вам потребуются привилегии суперпользователя.
====

[[term-hup]]
==== Заставьте `init` перечитать [.filename]#/etc/ttys#

После выполнения необходимых изменений в файле [.filename]#/etc/ttys#, вам потребуется отправить сигнал SIGHUP (hangup) процессу `init`, чтобы заставить его перечитать его файл настройки. Например:

[source,shell]
....
# kill -HUP 1
....

[NOTE]
====
`init` это всегда первый из запущенных в в системе процессов, поэтому его PID всегда 1.
====

Если все установлено правильно, все кабели на месте и терминалы включены, процесс `getty` должен быть запущен на каждом терминале и вы увидите приглашение ко входу на каждом терминале.

[[term-debug]]
=== Решение проблем с соединением

Даже при самом внимательном отношении к деталям, при настройке терминала все же могут возникнуть проблемы. В этом разделе приведен список симптомов и предлагается несколько решений.

==== Не появляется приглашение ко входу

Убедитесь, что терминал подключен и его питание включено. Убедитесь, что эмулятор терминала запущен на соответствующем порту.

Убедитесь, что кабель хорошо подключен и к терминалу и к компьютеру с FreeBSD. Убедитесь, что правильно выбран тип кабеля.

Убедитесь, что терминал и FreeBSD имеют одинаковые установки значения bps и четности. Если у вас видео терминал, убедитесь, что контраст и яркость включены. Если это принт-терминал, убедитесь, что бумага и чернила в порядке.

Убедитесь, что процесс `getty` запущен и обслуживает терминал. Например, для получения списка запущенных процессов `getty` с помощью `ps`, выполните:

[source,shell]
....
# ps -axww|grep getty
....

Вы должны увидеть строку для соответствующего терминала. Например, если `getty` запущена на втором последовательном порту `ttyd1` и использует запись `std.38400` из файла [.filename]#/etc/gettytab#, отобразится следующее:

[source,shell]
....
22189  d1  Is+    0:00.03 /usr/libexec/getty std.38400 ttyd1
....

Если процесс `getty` не запущен, убедитесь, что вы включили порт в [.filename]#/etc/ttys#. Не забудьте также запустить `kill -HUP 1` после изменения файла [.filename]#ttys#.

Если процесс `getty` запущен, но на терминале по-прежнему не отображается приглашение ко входу, или если приглашение отображается, но войти невозможно, терминал или кабель, возможно, не поддерживают квитирование связи. Попробуйте изменить поле в [.filename]#/etc/ttys# с `std.38400` на `3wire.38400`. Запись `3wire` похожа на `std`, но игнорирует квитирование связи. Вам может потребоваться уменьшить скорость соединения или включить программный контроль передачи при использовании `3wire` для предотвращения переполнений буфера.

==== Вместо приглашения ко входу на экране появляется "мусор"

Убедитесь, что терминал и FreeBSD имеют одинаковые установки значения bps и четности. Проверьте процесс `getty`, чтобы убедиться, что используется подходящий тип _getty_. Если это не так, отредактируйте [.filename]#/etc/ttys# и запустите `kill -HUP 1`.

==== Символы появляются дважды, пароль отображается при вводе

Переключите терминал (или программу эмулятора терминала) с "half duplex" или "local echo" на "full duplex".

[[dialup]]
== Входящие соединения по модему

Настройка системы FreeBSD для поддержки входящих соединений очень похожа на подсоединение терминалов за исключением того, что вы работаете с модемами вместо терминалов.

=== Внешние и внутренние модемы

Внешние модемы более удобны для дозвона, поскольку легко могут быть настроены с помощью параметров, сохраняемых в энергонезависимой памяти. На них обычно есть индикаторы, отображающие состояние основных RS-232 сигналов. Мигающие индикаторы впечатляют, но кроме того они также очень полезны для индикации правильной работы модема.

Внутренние модемы обычно не снабжаются энергонезависимой памятью, поэтому их настройка может ограничиваться установкой DIP переключателей. Если на внутреннем модеме есть индикаторы, их обычно сложно увидеть при закрытой крышке корпуса.

==== Модемы и кабели

Если вы используете внешний модем, несомненно потребуется подходящий кабель. Стандартный RS-232C кабель должен подойти, если подключены все обычные сигналы:
[[serialcomms-signal-names]]
.Наименования сигналов
[cols="1,1,1", frame="none", options="header"]
|===
<| Сокращение
<| Наименование
<| Назначение

|RD
|Received Data
|Принимаемые данные

|TD
|Transmitted Data
|Передаваемые данные

|DTR
|Data Terminal Ready
|Готовность терминала

|DSR
|Data Set Ready
|Готовность данных

|DCD
|Data Carrier Detect
|Наличие несущей

|SG
|Signal Ground
|Сигнальная земля

|RTS
|Request to Send
|Запрос на посылку

|CTS
|Clear to Send
|Готовность к приему
|===

FreeBSD требуются сигналы RTS и CTS для контроля передачи на скоростях выше 2400 bps, сигнал CD для определения, был ли ответ на сигнал или произошло отключение линии, и сигнал DTR для сброса модема после завершения сессии. Некоторые кабели не поддерживают все необходимые сигналы, поэтому, если вы столкнулись с проблемами, например, если сессия не завершается после отсоединения линии, причиной возможно являются проблемы с кабелем.

Как и другие UNIX(R) подобные операционные системы, FreeBSD использует аппаратные сигналы для определения того, был ли ответ на звонок или линия была отключена и требуется завершить работу модема и сбросить его в начальное состояние. FreeBSD избегает отправлять команды модему или просматривать отчеты о статусе от модема. Если вы знакомы с настройкой BBS, это может показаться неудобным.

=== Рекомендации по последовательным интерфейсам

FreeBSD поддерживает интерфейсы, основанные на NS8250, NS16450, NS16550, и NS16550A EIA RS-232C (CCITT V.24). Устройства 8250 и 16450 снабжены односимвольным буфером. Устройство 16550 снабжено 16-ти символьным буфером, который повышает производительность системы. (Ошибки в 16550 делают невозможным использование 16-символьного буфера, поэтому используйте 16550A если возможно). Поскольку устройства с односимвольным буфером предъявляют большие требования к операционной системе, чем с 16-ти символьным буфером, предпочтительны устройства на 16550A. Если в системе много активных последовательных портов или нагрузка велика, устройства на 16550A лучше подходят для поддержки соединений с малым количеством ошибок.

=== Краткий обзор

Как и с терминалами, `init` запускает процесс `getty` на каждом настроенном для входящих звонков последовательном порту. Например, если модем подключен к [.filename]#/dev/ttyd0#, команда `ps ax` может вывести следующее:

[source,shell]
....
4850 ??  I      0:00.09 /usr/libexec/getty V19200 ttyd0
....

Когда пользователь дозванивается на подключенный модем, модем выдает сигнал CD (Carrier Detect). Ядро определяет, что несущая обнаружена и завершает открытие порта командой `getty`. `getty` отправляет приглашение `login:` на указанной скорости. `getty` ожидает в ответ набор символов, и, как правило, получает неправильный набор (обычно это происходит из-за того, что скорость соединения модема отличается от скорости `getty`). `getty` пробует подобрать скорость линии до тех пор, пока не получит правильный набор символов.

После того, как будет введено имя пользователя, `getty` выполняет [.filename]#/usr/bin/login#, которая завершает вход, запрашивая пароль пользователя и запуская оболочку.

=== Файлы настройки

Есть три файла настройки системы в каталоге [.filename]#/etc#, которые возможно потребуется отредактировать для включения удаленного доступа по модему в FreeBSD. Первый, [.filename]#/etc/gettytab#, содержит информацию по настройке даемона [.filename]#/usr/libexec/getty#. Второй, [.filename]#/etc/ttys#, содержит информацию, указывающую [.filename]#/sbin/init# на каких устройствах [.filename]#tty# должны быть запущены процессы `getty`. Наконец, вы можете поместить команды инициализации портов в скрипт /etc/rc.d/serial.

В UNIX(R) есть две школы настройки модемов для входящих соединений. Одна предпочитает настраивать модемы и системы так, что не важно на какой скорости подсоединяется удаленный пользователь. Локальный интерфейс RS-232 компьютер-модем работает на жестко заданной скорости. Преимущество этой настройки в том, что удаленный пользователь всегда сразу видит приглашение ко входу. Обратная сторона в том, что система не знает, какова на самом деле скорость передачи данных, поэтому полноэкранные программы, такие как Emacs, не настраивают свои методы отображения на экране для работы с медленными соединениями.

Другая школа настраивает интерфейс RS-232 для работы с различной скоростью в зависимости от скорости подсоединения удаленного пользователя. Например, соединение модемов по протоколу V.32bis (14.4 Кбит/с) установит скорость порта RS-232 равной 19.2 Кбит/с, а соединение на скорости 2400 бит/с установит скорость RS-232 равной 2400 бит/с. Поскольку `getty` не понимает сообщений модема о скорости соединения, `getty` выдает приглашение `login:` на установленной по умолчанию скорости и считывает символы, полученные в ответе. Если пользователь видит "мусор" вместо приглашения ко входу, это означает, что нужно нажимать Enter до тех пор, пока не появится приглашение ко входу. Если скорости не совпадают, `getty` получает все, что вводит пользователь, в виде "мусора", пробует переключиться на другую скорость и выдает приглашение `login:` опять. Эта процедура может продолжаться до отвращения, но обычно требуется одно или два нажатия клавиши перед появлением нормально выглядящего приглашения. Очевидно, эта последовательность входа не так хороша, как метод с фиксированной скоростью, но при низкой скорости соединения работать с полноэкранными программами станет проще.

В этом разделе делается попытка дать сбалансированную информацию для настройки, но предпочтение будет отдано установке скорости соединения с модемом в соответствие скорости подключения.

==== [.filename]#/etc/gettytab#

[.filename]#/etc/gettytab# это файл в стиле man:termcap[5], содержащей информацию по настройке man:getty[8]. Пожалуйста, обратитесь к странице справочника man:gettytab[5] за полной информацией о формате файла и за списком возможностей `getty`.

===== Настройка фиксированной скорости

Если вы зафиксировали скорость соединения модема на определенной скорости, редактировать файл [.filename]#/etc/gettytab# скорее всего не потребуется.

===== Настройка изменяемой скорости

Вам потребуется сделать запись в [.filename]#/etc/gettytab# для предоставления `getty` информации о скоростях, которые предполагается использовать для модема. Если у вас 2400 бит/с модем, возможно, подойдет существующая запись `D2400`.

[.programlisting]
....
#
# Fast dialup terminals, 2400/1200/300 rotary (can start either way)
#
D2400|d2400|Fast-Dial-2400:\
        :nx=D1200:tc=2400-baud:
3|D1200|Fast-Dial-1200:\
        :nx=D300:tc=1200-baud:
5|D300|Fast-Dial-300:\
        :nx=D2400:tc=300-baud:
....

Если у вас более скоростной модем, вам возможно потребуется добавить запись в [.filename]#/etc/gettytab#; вот запись, которую вы можете использовать для 14.4 Кбит/с модема с максимальной скоростью интерфейса 19.2 Кбит/с:

[.programlisting]
....
#
# Additions for a V.32bis Modem
#
um|V300|High Speed Modem at 300,8-bit:\
        :nx=V19200:tc=std.300:
un|V1200|High Speed Modem at 1200,8-bit:\
        :nx=V300:tc=std.1200:
uo|V2400|High Speed Modem at 2400,8-bit:\
        :nx=V1200:tc=std.2400:
up|V9600|High Speed Modem at 9600,8-bit:\
        :nx=V2400:tc=std.9600:
uq|V19200|High Speed Modem at 19200,8-bit:\
        :nx=V9600:tc=std.19200:
....

Эта настройка включает 8-битные соединения без программного контроля четности.

В примере выше скорость порта будет переключаться в цикле начиная с 19.2 Кбит/с (для соединения по V.32bis), затем 9600 бит/с (для V.32), 2400 бит/с, 1200 бит/с, 300 бит/с, и обратно на 19.2 Кбит/с. Переключение скоростей в цикле реализовано с помощью `nx=` ("next table"). Каждая из линий использует `tc=` ("table continuation") для указания "стандартных" (std) настроек на каждой скорости.

Если у вас 28.8 Кбит/с модем и/или вы хотите получить преимущество от сжатия на скорости 14.4 Кбит/с, потребуются скорости выше, чем 19.2 Кбит/с. Вот пример записи из [.filename]#gettytab# для начала соединения на скорости 57.6 Кбит/с:

[.programlisting]
....
#
# Additions for a V.32bis or V.34 Modem
# Starting at 57.6 Kbps
#
vm|VH300|Very High Speed Modem at 300,8-bit:\
        :nx=VH57600:tc=std.300:
vn|VH1200|Very High Speed Modem at 1200,8-bit:\
        :nx=VH300:tc=std.1200:
vo|VH2400|Very High Speed Modem at 2400,8-bit:\
        :nx=VH1200:tc=std.2400:
vp|VH9600|Very High Speed Modem at 9600,8-bit:\
        :nx=VH2400:tc=std.9600:
vq|VH57600|Very High Speed Modem at 57600,8-bit:\
        :nx=VH9600:tc=std.57600:
....

Если у вас медленный CPU или сильно загруженная система без последовательных портов на базе 16550A, на скорости 57.6 Кбит/с могут возникнуть ошибки `sio` "silo".

[[dialup-ttys]]
==== [.filename]#/etc/ttys#

Настройка файла [.filename]#/etc/ttys# была описана в <<ex-etc-ttys>>. Настройка модемов похожа, но потребуется передавать `getty` различные аргументы и указывать различные типы терминалов. Общий формат для фиксированной и переменной скорости такой:

[.programlisting]
....
ttyd0   "/usr/libexec/getty xxx"   dialup on
....

Первый пункт в строке выше это специальный файл устройства для этой записи - `ttyd0` означает, что `getty` будет запущена на [.filename]#/dev/ttyd0#. Второй пункт, `"/usr/libexec/getty _xxx_"` (_xxx_ будет замещено на запись из [.filename]#gettytab# для начальной скорости), это процесс, который будет запущен на данном устройстве. Третий пункт, `dialup`, это тип терминала по умолчанию. Четвертый параметр, `on`, указывает `init`, что линия включена. Может быть пятый параметр, `secure`, но он должен использоваться только для терминалов, которые физически безопасны (таких как системная консоль).

Тип терминала по умолчанию (`dialup` в примере выше) может зависеть от личных предпочтений. `dialup` это традиционный тип терминала по умолчанию на линиях для дозвона, который позволяет пользователям, зная что тип терминала `dialup`, автоматически настраивать свой тип терминала. Однако, автор находит более легким указание `vt102` в качестве типа терминала по умолчанию, поскольку пользователи работают на своих удаленных системах с эмулятором терминала VT102.

После внесения изменений в [.filename]#/etc/ttys#, вы можете отправить процессу `init` сигнал HUP перечитать файл. Используйте команду 

[source,shell]
....
# kill -HUP 1
....

для отправки сигнала. Если вы настраиваете систему в первый раз, то возможно захотите подождать, пока модем(ы) правильно настроятся и соединятся перед отправкой сигнала `init`.

===== Настройка фиксированной скорости

Для настройки соединения с фиксированной скоростью, в файле [.filename]#ttys# должна быть запись с фиксированной скоростью для `getty`. Для модема, скорость порта которого фиксирована на значении 19.2 Кбит/с, строка в [.filename]#ttys# может выглядеть так:

[.programlisting]
....
ttyd0   "/usr/libexec/getty std.19200"   dialup on
....

Если скорость модема фиксирована на другом значении, подставьте соответствующее значение в `std._speed_` вместо `std.19200`. Убедитесь, что вы используете тип, описанный в [.filename]#/etc/gettytab#.

===== Настройка переменной скорости

В настройке с переменной скоростью, запись в [.filename]#ttys# должна обращаться к соответствующей "auto-baud" (sic) записи в [.filename]#/etc/gettytab#. Например, если вы добавите предложенную выше запись для подключения модема с переменной скоростью, которая начинается с 19.2 Кбит/с (запись в [.filename]#gettytab# начинается с `V19200`), запись в [.filename]#ttys# может выглядеть так:

[.programlisting]
....
ttyd0   "/usr/libexec/getty V19200"   dialup on
....

==== [.filename]#/etc/rc.d/serial#

Для высокоскоростных модемов, таких как V.32, V.32bis и V.34, требуется использование аппаратного контроля передачи (`RTS/CTS`). Вы можете добавить команды `stty` к файлу [.filename]#/etc/rc.d/serial# для установки флага аппаратного контроля передачи в ядре FreeBSD для модемных портов.

Например, для установки флага `termios crtscts` на последовательном порту номер 1 ([.filename]#COM2#) при инициализации устройств для входящей и исходящей связи, в [.filename]##/etc/rc.d/serial##должны быть добавлены следующие строки:

[.programlisting]
....
# Serial port initial configuration
stty -f /dev/ttyd1.init crtscts
stty -f /dev/cuad1.init crtscts
....

=== Настройка модема

Если параметры вашего модема могут быть сохранены в энергонезависимой памяти, потребуется использовать терминальную программу (например, Telix под MS-DOS(R) или `tip` под FreeBSD) для установки параметров. Подсоединитесь к модему, используя ту же скорость соединения, которую использует `getty` в качестве начальной скорости, и настройте модем для соответствия следующим требованиям:

* CD включен после соединения
* DTR включен во время работы; сброс DTR отключает линию и переводит модем в начальное состояние
* CTS контроль переданных данных
* Контроль потока XON/XOFF отключен
* RTS контроль принятых данных
* "Тихий" режим (без кодов возврата)
* Эхо команд отключено

Прочтите документацию на модем для определения какие команды и/или DIP переключатели требуются чтобы установить эти настройки.

Например, для установки вышеуказанных параметров на внешнем 14,400 модеме U.S. Robotics(R) Sportster(R), требуется отправить модему следующие команды:

[.programlisting]
....
ATZ
AT&C1&D2&H1&I0&R2&W
....

Вы, возможно, захотите настроить и другие параметры модема, такие как использование сжатия V.42bis и/или MNP5.

Внешний U.S. Robotics(R) Sportster(R) 14,400 модем также снабжен некоторыми DIP переключателями, которые требуется установить; для других модемов эти настройки могут быть использованы в качестве примера:

* Переключатель 1: вверх - нормальный DTR
* Переключатель 2: N/A (визуальные коды возврата/числовые коды возврата)
* Переключатель 3: вверх - подавление кодов возврата
* Переключатель 4: вниз - без эхо, offline команды
* Переключатель 5: вверх - авто ответ
* Переключатель 6: вверх - нормальный контроль несущей
* Переключатель 7: вверх - загрузить установки по умолчанию из NVRAM
* Переключатель 8: N/A (Smart/Dumb режимы)

Коды возврата должны быть отключены/подавлены для устранения проблем, которые могут возникнуть, если `getty` ошибочно выдаст приглашение `login:` модему в командном режиме и модем вернет (echo) эту команду или код возврата. Эта последовательность может привести к дополнительному и бессмысленному обмену командами между `getty` и модемом.

==== Настройка фиксированной скорости

Для настройки фиксированной скорости вам потребуется настроить модем с поддержкой постоянной скорости обмена данными модем-компьютер независимо от скорости соединения. На внешнем модеме U.S. Robotics(R) Sportster(R) 14,400 эти команды зафиксируют скорость передачи модем-компьютер на скорости, которая установлена при выполнении команды:

[.programlisting]
....
ATZ
AT&B1&W
....

==== Настройка переменной скорости

Для настройки переменной скорости вам потребуется настроить модем с поддержкой изменения скорости передачи данных через последовательный порт в соответствии через скоростью соединения. Следующие команды зафиксируют скорость передачи данных с коррекцией ошибок внешнего модема U.S. Robotics(R) Sportster(R) 14,400 на значении, которое установлено при выполнении команды, но сделают возможным изменение скорости последовательного порта для соединений без коррекции ошибок:

[.programlisting]
....
ATZ
AT&B2&W
....

==== Проверка настроек модема

Большинство высокоскоростных модемов предоставляют команды для просмотра текущих параметров модема в виде, отчасти приспособленном для чтения. Для внешних модемов U.S. Robotics(R) Sportster(R) 14,400 команда `ATI5` отображает установки, сохраненные в энергонезависимой памяти. Для просмотра действующих параметров модема (с учетом положения DIP переключателей), используйте команду `ATZ`, а затем `ATI4`.

Если ваш модем другого производителя, проверьте руководство к модему для аккуратной проверки параметров настройки модема.

=== Решение проблем

Вот несколько шагов, которые нужно выполнить для проверки настроек.

==== Проверьте систему FreeBSD

Подсоедините модем к системе FreeBSD, загрузите систему, и, если на модеме есть индикаторы, посмотрите, загорелся ли индикатор DTR при появлении приглашения `login:` на системной консоли - если он загорелся, это означает, что FreeBSD запустила процесс `getty` на соответствующем коммуникационном порту и модем ожидает входящего звонка.

Если индикатор DTR не загорелся, войдите на консоль системы FreeBSD и выполните команду `ps ax`, чтобы увидеть, пытается ли FreeBSD запустить процесс `getty` на соответствующем порту. Вы должны увидеть строки вроде этих среди показанных процессов:

[source,shell]
....
  114 ??  I      0:00.10 /usr/libexec/getty V19200 ttyd0
  115 ??  I      0:00.10 /usr/libexec/getty V19200 ttyd1
....

Если вы видите что-то другое, вроде этого:

[source,shell]
....
  114 d0  I      0:00.10 /usr/libexec/getty V19200 ttyd0
....

и модем все еще не принимает звонок, это означает, что `getty` завершила открытие коммуникационного порта. Это может означать проблему с кабелем или неправильную настройку модема, поскольку `getty` не должна открывать коммуникационный порт, пока модем не установит CD (обнаружение несущей).

Если вы не видите процессов `getty`, ожидающих открытия соответствующего порта [.filename]#ttydN#, внимательно проверьте записи в [.filename]#/etc/ttys# и попробуйте найти ошибки, если они есть. Проверьте также лог файл [.filename]#/var/log/messages#, нет ли там сообщений от `init` или `getty`, имеющих отношение к проблеме. Если сообщения есть, проверьте еще раз файлы настройки [.filename]#/etc/ttys# и [.filename]#/etc/gettytab#, как и соответствующие специальные файлы устройств [.filename]#/dev/ttydN#, чтобы обнаружить ошибки, отсутствующие записи или отсутствующие специальные файлы устройств.

==== Попробуйте позвонить на модем

Попробуйте дозвониться до системы; убедитесь, что используете 8 бит без четности и 1 стоп бит на удаленной системе. Если вы не получите приглашение сразу, или получите случайные данные, попробуйте нажимать Enter примерно раз в секунду. Если вы все еще не видите приглашения `login:` после нескольких попыток, попробуйте отправить команду `BREAK`. Если вы используете для дозвона высокоскоростной модем, попробуйте позвонить еще раз после фиксирования скорости интерфейса дозванивающегося модема (например, с помощью команды `AT&B1` для модема U.S. Robotics(R) Sportster(R)).

Если вы все еще не можете получить приглашение `login:`, проверьте [.filename]#/etc/gettytab# еще раз и убедитесь, что

* Имя параметра `getty`, указанного в [.filename]#/etc/ttys#, совпадает с именем параметра в [.filename]#/etc/gettytab#
* Каждая запись `nx=` соответствует имени другой записи в [.filename]#gettytab#
* Каждая запись `tc=` соответствует имени другой записи в [.filename]#gettytab#

Если система FreeBSD не отвечает на звонок, убедитесь, что модем настроен для ответа на звонок при включении DTR. Если модем настроен правильно, проверьте, что DTR включается, взглянув на индикаторы модема (если они есть).

Если вы проверили все несколько раз и все еще не добились результата, сделайте перерыв и вернитесь к настройкам позже. Если опять ничего не получилось, возможно вам потребуется отправить письмо в {freebsd-questions}, описав модем и возникшую проблему, участники рассылки попробуют помочь вам.

[[dialout]]
== Исходящие соединения по модему

Текст, приведенный ниже, это советы, позволяющие настроить ваш хост для доступа к другому компьютеру через модем. Они подходят для установления терминальной сессии с удаленным хостом.

Это подходит для входа на BBS.

Этот вид соединения может очень выручить, если требуется получить файл из интернет и есть проблемы с PPP. Если вам требуется зайти куда-то по FTP, а PPP не работает, используйте терминальную сессию для получения файла по FTP. Затем используйте zmodem для сброса его на свой компьютер.

=== Мой модем Stock Hayes не поддерживается, что я могу сделать?

На самом деле, страница руководства для `tip` устарела. Встроенная поддержка generic Hayes уже есть. Используйте `at=hayes` в файле [.filename]#/etc/remote#.

Драйвер Hayes не умеет работать с некоторыми расширенными возможностями более новых модемов - сообщения вроде `BUSY`, `NO DIALTONE`, или `CONNECT 115200`. Вы должны отключить эти сообщения при использовании `tip` (с помощью `ATX0&W`).

Таймаут дозвона для `tip` составляет 60 секунд. Ваш модем должен использовать меньшее значение, или `tip` решит, что возникли проблемы со связью. Попробуйте `ATS7=45&W`.

[NOTE]
====
Оригинальная `tip` не полностью поддерживает модемы Hayes. Решить это проблему можно отредактировав файл [.filename]#tipconf.h# в каталоге [.filename]#/usr/src/usr.bin/tip/tip#. Конечно, для этого вам потребуются исходные тексты.

Замените строку `#define HAYES 0` на `#define HAYES 1`. Затем выполните `make` и `make install`. После этого все должно работать отлично.
====

[[direct-at]]
=== Как нужно выполнять команды AT?

Сделайте то, что называется "прямой" записью в файле [.filename]#/etc/remote#. Например, если модем подключен к первому последовательному порту, [.filename]#/dev/cuad0#, добавьте следующую строку:

[.programlisting]
....
cuad0:dv=/dev/cuad0:br#19200:pa=none
....

Используйте для br наибольшее значение bps, поддерживаемое модемом. Для подключения к модему выполните `tip cuad0`.

Или используйте `cu` под `root` так:

[source,shell]
....
# cu -lline -sspeed
....

_line_ это последовательный порт (например [.filename]#/dev/cuad0#), а _speed_ это скорость (например `57600`). После ввода команд AT наберите kbd:[~.] для выхода.

=== Знак `@` не работает для pn!

Знак `@` в телефонном номере указывает `tip` взять телефонный номер из [.filename]#/etc/phones#. Но знак `@` это также специальный символ в таких файлах как [.filename]#/etc/remote#. Экранируйте его с помощью обратной косой черты:

[.programlisting]
....
pn=\@
....

=== Как я могу позвонить по телефонному номеру из командной строки?

Поместите так называемую "generic" запись в файл [.filename]#/etc/remote#. Например:

[.programlisting]
....
tip115200|Dial any phone number at 115200 bps:\
        :dv=/dev/cuad0:br#115200:at=hayes:pa=none:du:
tip57600|Dial any phone number at 57600 bps:\
        :dv=/dev/cuad0:br#57600:at=hayes:pa=none:du:
....

Затем вы можете сделать следующее:

[source,shell]
....
# tip -115200 5551234
....

Если вы предпочитаете `cu` команде `tip`, используйте generic запись для `cu`:

[.programlisting]
....
cu115200|Use cu to dial any number at 115200bps:\
        :dv=/dev/cuad1:br#57600:at=hayes:pa=none:du:
....

и выполните:

[source,shell]
....
# cu 5551234 -s 115200
....

=== Должен ли я вводить значение bps каждый раз?

Создайте запись `tip1200` или `cu1200`, но используйте то значение bps, которое записано в поле br. `tip` считает, что хорошее значение по умолчанию это 1200 bps, поэтому обращается к записи `tip1200`. Тем не менее, значение bps будет другим.

=== Я получаю доступ ко множеству хостов через терминальный сервер

Вместо ожидания соединения и ввода каждый раз `CONNECT <host>`, используйте возможность `tip cm`. Вот пример записи в [.filename]#/etc/remote#:

[.programlisting]
....
pain|pain.deep13.com|Forrester's machine:\
        :cm=CONNECT pain\n:tc=deep13:
muffin|muffin.deep13.com|Frank's machine:\
        :cm=CONNECT muffin\n:tc=deep13:
deep13:Gizmonics Institute terminal server:\
        :dv=/dev/cuad2:br#38400:at=hayes:du:pa=none:pn=5551234:
....

Она позволит вам вводить `tip pain` или `tip muffin` для соединения с хостами pain или muffin, и `tip deep13` для доступа к терминальному серверу.

=== Может ли tip соединяться более через одну линию для каждого сайта?

Эта проблема часто возникает в университете, где несколько модемных линий и несколько тысяч студентов, пытающихся их использовать.

Создайте запись для университета в [.filename]#/etc/remote# и используйте `@` для `pn`:

[.programlisting]
....
big-university:\
        :pn=\@:tc=dialout
dialout:\
        :dv=/dev/cuad3:br#9600:at=courier:du:pa=none:
....

Затем, создайте список телефонов для университета в [.filename]#/etc/phones#:

[.programlisting]
....
big-university 5551111
big-university 5551112
big-university 5551113
big-university 5551114
....

`tip` попробует связаться с каждым в указанном порядке, затем прекратит попытки. Если вы хотите продолжать соединяться, запустите `tip` в цикле.

=== Почему я должен дважды нажать kbd:[Ctrl+P] для отправки kbd:[Ctrl+P] один раз?

kbd:[Ctrl+P] это "управляющий" символ по умолчанию, используемый для указания `tip` того, что далее идут символьные данные. Вы можете сделать любой другой символ управляющим с помощью экранирования `~s`, которое означает "установить переменную".

Введите `~sforce=_single-char_`, завершив ввод новой строкой. _single-char_ это любой одиночный символ. Если вы не введете _single-char_, управляющим символом станет nul, который можно получить, введя kbd:[Ctrl+2] или kbd:[Ctrl+Space]. Хорошее значение для _single-char_ это kbd:[Shift+Ctrl+6], которое используется только на некоторых терминальных серверах.

Вы можете использовать в качестве управляющего символа все, что захотите, поместив его в файл [.filename]#$HOME/.tiprc#:

[.programlisting]
....
force=<single-char>
....

=== Почему все, что я ввожу, вдруг стало отображаться в верхнем регистре??

Вы нажали kbd:[Ctrl+A], "повышающий символ" `tip`, который был специально введен для тех, у кого не работает клавиша caps-lock. Используйте `~s` как в примере выше для установки переменной `raisechar` в подходящее значение. Фактически, вы можете установить ее в то же значение, что и управляющий символ, если не собираетесь использовать ни один из них.

Вот пример .tiprc, отлично подходящий для пользователей Emacs, которым часто требуется вводить kbd:[Ctrl+2] и kbd:[Ctrl+A]:

[.programlisting]
....
force=^^
raisechar=^^
....

Символ ^^ это kbd:[Shift+Ctrl+6].

=== Могу ли я передавать файлы с помощью `tip`?

Если вы соединяетесь с другой системой UNIX(R), возможны передача и прием файлов с помощью команды `~p` (put) и `~t` (take). Эти команды запускают `cat` и `echo` в удаленной системе для приема и передачи файлов. Синтаксис следующий:

`~p` local-file [ remote-file ]

`~t` remote-file [ local-file ]

Коррекции ошибок нет, поэтому возможно лучше использовать другой протокол, например zmodem.

=== Как мне запустить zmodem с `tip`?

Для получения файла запустите отправляющую программу на удаленной стороне. Затем, наберите `~C rz` для начала локального приема файла.

Для отправки файлов запустите принимающую программу на удаленной стороне. Затем, наберите `~C sz _файлы_` для отправки их на удаленную систему.

[[serialconsole-setup]]
== Настройка последовательной консоли

[[serialconsole-intro]]
=== Введение

FreeBSD может загружаться при использовании в качестве консоли текстового терминала на последовательном порту. Такая конфигурация может быть полезна в двух случаях: для системных администраторов, устанавливающих FreeBSD на компьютеры без подключенных клавиатуры или монитора, и для разработчиков, производящих отладку ядра или драйверов устройств.

Как описано в crossref:boot[boot, Процесс загрузки FreeBSD], процесс загрузки FreeBSD состоит из трех стадий. Первые две стадии реализованы в блоке загрузки, находящемся в начале слайса FreeBSD на загрузочном диске. На третей стадии загрузочный блок запускает загрузчик ([.filename]#/boot/loader#).

Для настройки последовательной консоли вам потребуется настроить блок загрузки, загрузчик и ядро.

[[serialconsole-howto-fast]]
=== Настройка последовательной консоли, краткая версия

В этом разделе предполагается, что вы используете настройки по умолчанию и просто хотите увидеть краткий обзор настройки последовательной консоли.

[.procedure]
====
. Соедините кабелем последовательный порт COM1 и управляющий терминал.
. Для того, чтобы сообщения в процессе загрузки выводились в последовательную консоль, выполните от имени суперпользователя команду
+
[source,shell]
....
# echo 'console="comconsole"' >> /boot/loader.conf
....
+
. Отредактируйте [.filename]#/etc/ttys# и измените `off` на `on` и `dialup` на `vt100` для записи `ttyd0`. В противном случае для входа с последовательной консоли не будет требоваться пароль, что может являться проблемой с точки зрения безопасности.
. Перезагрузите систему и убедитесь, что последовательная консоль активировалась.
====

Если вам требуется иная конфигурация, обратитесь к более подробному описанию в разделе <<serialconsole-howto>>.

[[serialconsole-howto]]
=== Настройка последовательной консоли

[.procedure]
====

. Подготовьте кабель.
+ 
Вам потребуется нуль-модемный или стандартный последовательный кабель и нуль-модемный адаптер. Обратитесь к <<serial-cables-ports>>, где рассматриваются последовательные кабели.
. Отключите клавиатуру.
+ 
Большинство систем PC тестируют клавиатуру во время включения (POST) и выдают ошибку если клавиатура не обнаружена. Некоторые системы при отсутствии клавиатуры выдают звуковой сигнал и не загружаются пока клавиатура не будет подключена.
+ 
Если компьютер сообщает об ошибке, но все же загружается, вам не потребуется делать что-то еще. (Некоторые компьютеры с Phoenix BIOS просто сообщают `Keyboard failed` и продолжают загрузку).
+ 
Если компьютер не загружается без клавиатуры, вам потребуется настроить BIOS так, чтобы отсутствие клавиатуры игнорировалось (если это возможно). Обратитесь к руководству по материнской плате за деталями о том, как это сделать.
+
[TIP]
======

Установите параметр клавиатуры в настройках BIOS в значение "Not installed". При этом вы сможете продолжать использовать клавиатуру. Все, что делает этот параметр - указывает BIOS не тестировать клавиатуру во время загрузки, поэтому ее отсутствие не вызывает ошибки. Вы можете оставить клавиатуру подключенной, даже если с флагом "Not installed", и она все еще будет работать.
======
+
[NOTE]
======
Если в к системе подключена PS/2(R) мышь, отключите ее, как и клавиатуру. Мышь PS/2(R) использует часть оборудования совместно с клавиатурой, поэтому если оставить ее подключенной, тестирование клавиатуры может ошибочно выдать наличие последней. Например, система Gateway 2000 Pentium 90 MHz ведет себя именно так. К тому же, это не проблема, поскольку мышь без клавиатуры как правило не нужна.
======
+
. Подключите текстовый терминал к [.filename]#COM1# ([.filename]#sio0#).
+ 
Если у вас нет текстового терминала, используйте старый PC/XT с модемной программой, или последовательный порт на другом компьютере UNIX(R). Если порта [.filename]#COM1# ([.filename]#sio0#) нет, подключите его. На данный момент нет способа использовать другой порт вместо [.filename]#COM1# без перекомпиляции загрузочных блоков. Если вы уже используете [.filename]#COM1# для подключения другого устройства, временно удалите это устройство установите новый загрузочный блок и ядро как только FreeBSD заработает. (Предполагается, что [.filename]#COM1# будет доступен на файловом/вычислительном/терминальном сервере в любом случае; если вам действительно требуется [.filename]#COM1# для чего-то другого (и вы не можете переключить это на [.filename]#COM2# ([.filename]#sio1#)), возможно не стоит беспокоиться об этом сейчас.)
. Убедитесь, что в файле настройки ядра установлены соответствующие флаги для [.filename]#COM1# ([.filename]#sio0#).
+ 
Подходящие флаги такие:
+
`0x10`:::
Включает поддержку консоли для этого устройства. Если установлен этот флаг, другие игнорируются. На данный момент поддержка консоли может быть включена не более чем на одном устройстве; предпочтительно на первом (в соответствии с порядком в конфигурационном файле) с установкой этого флага. Эта опция сама по себе не сделает последовательный порт консолью. Установите следующий флаг или используйте опцию `-h`, описанную ниже, вместе с этим флагом.

`0x20`:::
Включает поддержку консоли на устройстве (если нет другой консоли с более высоким приоритетом), независимо от наличия описываемой ниже опции `-h`. Флаг `0x20` должен использоваться вместе с флагом `0x10`.

`0x40`:::
Резервирует это устройство (совместно с флагом `0x10`) и делает устройство недоступным для обычной работы. Вы не должны использовать этот флаг для устройства последовательного порта, которое будет использоваться в качестве последовательной консоли. Используйте этот флаг только если устройство предназначено для удаленной отладки ядра. Обратитесь к extref:{developers-handbook}[Руководству для разработчиков] за дополнительной информацией по удаленной отладке.
+ 
Пример:
+
[.programlisting]
....
device sio0 at isa? port IO_COM1 flags 0x10 irq 4
....
+ 
Обратитесь к странице справочника man:sio[4] за подробностями.
+ 
Если флаги не были установлены, вам потребуется запустить UserConfig (на другой консоли) или пересобрать ядро.
. Создайте [.filename]#boot.config# в корневом каталоге раздела `a` на загрузочном диске.
+ 
Этот файл сообщит загрузочному блоку способ загрузки системы. Для активации последовательной консоли вам потребуется одна или несколько следующих опций - несколько опций могут быть указаны на одной строке:
+
`-h`:::
Переключает внутреннюю и последовательную консоль. Вы можете использовать ее для переключения устройств консоли. Например, при загрузке с внутренней (видео) консоли, вы можете использовать `-h` для запуска загрузчика и ядра с использованием последовательного порта в качестве устройства консоли. При загрузке с последовательной консоли, вы можете использовать опцию `-h` для указания загрузчику и ядру использовать в качестве консоли видео дисплей.

`-D`:::
Переключает одно- и двухконсольную конфигурации. В одноконсольной конфигурации консоль может быть либо внутренней (видео дисплей), либо последовательным портом, в зависимости от состояния опции `-h`. В двухконсольной конфигурации и видео дисплей и последовательный порт станут консолями одновременно, независимо от состояния опции `-h`. Имейте ввиду, что конфигурация с двумя консолями работает только во время работы загрузочного блока. Как только управление переходит к загрузчику, остается только одна консоль, указанная опцией `-h`.

`-P`:::
Указывает загрузочному блоку протестировать клавиатуру. Если клавиатура не найдена, автоматически устанавливаются параметры `-D` и `-h`.
+
[NOTE]
======
По причине ограничений на размер в существующей версии загрузочного блока, опция `-P` может протестировать только расширенные клавиатуры. Клавиатуры с менее чем 101 клавишами (и без клавиш F11 и F12) могут быть не обнаружены. Клавиатуры некоторых лэптопов могут быть не найдены из-за этого ограничения. Если это случилось, вы не сможете использовать опцию `-P`. К сожалению, не существует обходного пути решения этой проблемы.
======
+ 
Используйте или опцию `-P` для автоматического выбора консоли, или опцию `-h` для активации последовательной консоли.
+ 
Вы можете включить также другие опции, описанные в man:boot[8].
+ 
Опции, за исключением `-P`, будут переданы загрузчику ([.filename]#/boot/loader#). Загрузчик определит будет ли консолью внутреннее видео устройство или последовательный порт, проверив только состояние опции `-h`. Это означает, что если вы включите в [.filename]#/boot.config# опцию `-D`, но не `-h`, то сможете использовать консоль только во время работы загрузочного блока; загрузчик будет использовать внутреннее видео устройство в качестве консоли.
. Загрузите компьютер.
+ 
Когда вы включите компьютер FreeBSD, загрузочный блок выведет содержимое [.filename]#/boot.config# на консоль. Например:
+
[source,shell]
....
/boot.config: -P
Keyboard: no
....
+ 
Вторая строка появится только если вы поместите `-P` в [.filename]#/boot.config# и отражает наличие/отсутствие клавиатуры. Эти сообщения выводятся либо на последовательную, либо на внутреннюю консоль, или на обе, в зависимости от параметров в [.filename]#/boot.config#.
+
[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
<| Опции
<| Сообщения выводятся на

|нет
|внутренняя консоль

|`-h`
|последовательная консоль

|`-D`
|последовательная и внутренняя консоли

|`-Dh`
|последовательная и внутренняя консоли

|`-P`, клавиатура присутствует
|внутренняя консоль

|`-P`, клавиатура отсутствует
|последовательная консоль
|===
+ 
После вывода вышеприведенных сообщений, происходит небольшая пауза перед тем, как запускается загрузчик и на консоли появляются следующие сообщения. В нормальной ситуации вам не потребуется прерывать загрузку в этот момент, но это можно сделать, чтобы убедиться, что все настроено правильно.
+ 
Нажмите на консоли любую клавишу кроме Enter для прерывания процесса загрузки. Загрузочный блок выдаст приглашение к дальнейшим действиям. Оно выглядит примерно так:
+
[source,shell]
....
>> FreeBSD/i386 BOOT
Default: 0:ad(0,a)/boot/loader
boot:
....
+ 
Убедитесь, что сообщение выше появилось на последовательной, внутренней консоли или на обеих, в зависимости от опций в [.filename]#/boot.config#. Если сообщение появилось там, где должно было появиться, нажмите Enter для продолжения процесса загрузки.
+ 
Если вам нужна последовательная консоль, но на терминале не видно приглашения, это означает проблемы с настройками. Введите `-h` и нажмите Enter/Return (если это возможно) для указания загрузочному блоку (а также загрузчику и ядру) выбрать последовательный порт в качестве консоли. Когда система загрузится, проверьте настройки еще раз и определите, что было сделано неправильно.
====

После запуска загрузчика и перехода в третью стадию процесса загрузки вы все еще можете переключиться между внутренней консолью и последовательной консолью путем установки соответствующих переменных окружения в загрузчике. Обращайтесь к разделу <<serialconsole-loader>>.

[[serialconsole-summary]]
=== Итоги

Здесь приведены краткие итоги по различным настройкам, рассмотренным в этом разделе и выбираемым в соответствии с ними консолям.

==== Вариант 1: вы устанавливаете для [.filename]#sio0# флаги 0x10

[.programlisting]
....
device sio0 at isa? port IO_COM1 flags 0x10 irq 4
....

[.informaltable]
[cols="1,1,1,1", frame="none", options="header"]
|===
<| Параметры в /boot.config
<| Консоль для загрузочного блока
<| Консоль для загрузчика
<| Консоль для ядра

|нет
|внутренняя
|внутренняя
|внутренняя

|`-h`
|последовательная
|последовательная
|последовательная

|`-D`
|последовательная и внутренняя
|внутренняя
|внутренняя

|`-Dh`
|последовательная и внутренняя
|последовательная
|последовательная

|`-P`, клавиатура присутствует
|внутренняя
|внутренняя
|внутренняя

|`-P`, клавиатура отсутствует
|последовательная и внутренняя
|последовательная
|последовательная
|===

==== Вариант 2: вы устанавливаете для [.filename]#sio0# флаги 0x30

[.programlisting]
....
device sio0 at isa? port IO_COM1 flags 0x30 irq 4
....

[.informaltable]
[cols="1,1,1,1", frame="none", options="header"]
|===
<| Параметры в /boot.config
<| Консоль для загрузочного блока
<| Консоль для загрузчика
<| Консоль для ядра

|нет
|внутренняя
|внутренняя
|последовательная

|`-h`
|последовательная
|последовательная
|последовательная

|`-D`
|последовательная и внутренняя
|внутренняя
|последовательная

|`-Dh`
|последовательная и внутренняя
|последовательная
|последовательная

|`-P`, клавиатура присутствует
|внутренняя
|внутренняя
|последовательная

|`-P`, клавиатура отсутствует
|последовательная и внутренняя
|последовательная
|последовательная
|===

[[serialconsole-tips]]
=== Приемы работы с последовательной консолью

==== Установка более высокой скорости порта

По умолчанию, последовательный порт настроен так: 9600 бит/с, 8 бит, без четности, 1 стоп бит. Если вам необходимо изменить скорость, потребуется перекомпиляция как минимум загрузочных блоков. Добавьте следующую строку к [.filename]#/etc/make.conf# и скомпилируйте новый загрузочный блок:

[.programlisting]
....
BOOT_COMCONSOLE_SPEED=19200
....

Обратитесь к <<serialconsole-com2>> за подробными инструкциями по сборке и установке новых загрузочных блоков.

Если последовательная консоль настраивается не путем установки параметра `-h`, или последовательная консоль, используемая ядром, отличается от той, что используется загрузочным блоком, потребуется добавить следующие опции к файлу настройки ядра и собрать новое ядро:

[.programlisting]
....
options CONSPEED=19200
....

[[serialconsole-com2]]
==== Использование для консоли другого последовательного порта вместо [.filename]#sio0#

Использование другого последовательного порта вместо [.filename]#sio0# для консоли потребует кое-какой перекомпиляции. Если вы по каким-либо причинам хотите использовать другой последовательный порт, перекомпилируйте загрузочный блок, загрузчик и ядро согласно приведенной ниже инструкции.

[.procedure]
====

. Получите исходные тексты ядра (глава crossref:cutting-edge[updating-upgrading, Обновление системы и смена версии FreeBSD])
. Отредактируйте [.filename]#/etc/make.conf# и установите `BOOT_COMCONSOLE_PORT` в соответствии с адресом порта, который вы хотите использовать (0x3F8, 0x2F8, 0x3E8 или 0x2E8). Могут быть использованы только устройства от [.filename]#sio0# до [.filename]#sio3# (от [.filename]#COM1# до [.filename]#COM4#); мультипортовые последовательные карты не будут работать. Установка прерываний не требуется.
. Создайте файл настройки ядра и добавьте соответствующие флаги для порта, который планируется использовать. Например, если вы хотите использовать для консоли [.filename]#sio1# ([.filename]#COM2#):
+
[.programlisting]
....
device sio1 at isa? port IO_COM2 flags 0x10 irq 3
....
+ 
или
+
[.programlisting]
....
device sio1 at isa? port IO_COM2 flags 0x30 irq 3
....
+ 
Флаги для других последовательных устройств не устанавливайте.
. Соберите и установите загрузочный блок и загрузчик:
+
[source,shell]
....
# cd /sys/boot
# make clean
# make
# make install
....
+
. Соберите и установите ядро.
. Запишите загрузочный блок на загрузочный диск с помощью man:bsdlabel[8] и загрузитесь с новым ядром.
====

[[serialconsole-ddb]]
==== Вход в отладчик DDB с последовательной линии

Если вы хотите войти в отладчик ядра с последовательной консоли (полезно для удаленной диагностики, но опасно если вы введете неправильный BREAK на последовательном порту!), потребуется собрать ядро со следующими параметрами:

[.programlisting]
....
options BREAK_TO_DEBUGGER
options DDB
....

==== Получение приглашения на последовательной консоли

Хотя это не обязательно, вам может потребоваться приглашение _login_ по последовательной линии, в дополнение к уже доступным загрузочным сообщениям и отладочной сессии ядра. Здесь описано как сделать это.

Откройте файл [.filename]#/etc/ttys# с помощью редактора и найдите строки:

[.programlisting]
....
ttyd0 "/usr/libexec/getty std.9600" unknown off secure
ttyd1 "/usr/libexec/getty std.9600" unknown off secure
ttyd2 "/usr/libexec/getty std.9600" unknown off secure
ttyd3 "/usr/libexec/getty std.9600" unknown off secure
....

Строки от `ttyd0` до `ttyd3` соответствуют портам от [.filename]#COM1# до [.filename]#COM4#. Измените `off` на `on` для требуемого порта. Если вы изменили скорость последовательного порта, может потребоваться изменить `std.9600` для соответствия текущим настройкам, например `std.19200`.

Возможно, вы захотите заменить тип терминала `unknown` на тип реально используемого терминала.

После редактирования файла потребуется выполнить `kill -HUP 1` для включения новых настроек.

[[serialconsole-loader]]
=== Изменение консоли из загрузчика

Предыдущий раздел описывает настройку последовательной консоли изменением параметров загрузочного блока. Этот раздел показывает, как указать консоль, вводя команды и переменные окружения для загрузчика. Поскольку загрузчик загружается после загрузочного блока, на третьей стадии загрузочного процесса, настройки загрузчика превалируют над настройками загрузочного блока.

==== Настройка последовательной консоли

Вы можете прямо указать загрузчику и ядру использовать последовательную консоль, записав одну строку в [.filename]#/boot/loader.rc#:

[.programlisting]
....
set console="comconsole"
....

Это сработает независимо от настроек загрузочного блока, рассмотренных в предыдущем разделе.

Поместите эту строку в самое начало [.filename]#/boot/loader.rc#, чтобы увидеть на последовательной консоли все загрузочные сообщения.

Вы можете также указать внутреннюю консоль:

[.programlisting]
....
set console="vidconsole"
....

Если вы не установите переменную загрузчика `console`, загрузчик, а затем и ядро будут использовать ту консоль, которая установлена параметром `-h` для загрузочного блока.

В версиях 3.2 или выше, вы можете указать консоль в [.filename]#/boot/loader.conf.local# или [.filename]#/boot/loader.conf# вместо [.filename]#/boot/loader.rc#. С этим методом [.filename]#/boot/loader.rc# должен выглядеть примерно так:

[.programlisting]
....
include /boot/loader.4th
start
....

Затем, создайте [.filename]#/boot/loader.conf.local# и поместите туда следующую строку.

[.programlisting]
....
console=comconsole
....

или

[.programlisting]
....
console=vidconsole
....

Обращайтесь к man:loader.conf[5] за дополнительной информацией.

[NOTE]
====
На данный момент у загрузчика нет параметра, эквивалентного параметру `-P` загрузочного блока и нет способа автоматического выбора внутренней и последовательной консоли в зависимости от наличия клавиатуры.
====

==== Использование для консоли отличного от [.filename]#sio0# последовательного порта

Вам потребуется перекомпилировать загрузчик для использования отличного от [.filename]#sio0# последовательного порта в качестве консоли. Следуйте процедуре, описанной в разделе <<serialconsole-com2>>.

[[serialconsole-caveats]]
=== Предостережения

Идея в том, чтобы настроить выделенный сервер, который не требует графического оборудования или подсоединенной клавиатуры. К сожалению, хотя многие системы способны загрузиться без клавиатуры, есть совсем немного систем, способных загрузиться без графического адаптера. Компьютеры с AMI BIOS могут быть настроены для загрузки без графического адаптера простой установкой параметра настройки CMOS "graphics adapter" в значение "Not installed".

Однако, многие компьютеры не поддерживают этот параметр и не смогут загрузиться без графического оборудования. Для этих компьютеров вам потребуется оставить подключенной любую графическую карту (даже если это просто старая моно карта), хотя монитор и не подключен.
