---
title: Глава 12. Настройка и оптимизация
part: Часть III. Системное администрирование
prev: books/handbook/partiii
next: books/handbook/boot
---

[[config-tuning]]
= Настройка и оптимизация
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:source-highlighter: rouge
:experimental:
:skip-front-matter:
:toc-title: Содержание
:table-caption: Таблица
:figure-caption: Рисунок
:example-caption: Пример
:xrefstyle: basic
:relfileprefix: ../
:outfilesuffix:
:sectnumoffset: 12

ifeval::["{backend}" == "html5"]
:imagesdir: ../../../images/books/handbook/config/
endif::[]

ifeval::["{backend}" == "pdf"]
:imagesdir: ../../../../static/images/books/handbook/config/
endif::[]

ifeval::["{backend}" == "epub3"]
:imagesdir: ../../../../static/images/books/handbook/config/
endif::[]

include::shared/authors.adoc[]
include::shared/releases.adoc[]
include::shared/ru/mailing-lists.adoc[]
include::shared/ru/teams.adoc[]
include::shared/ru/urls.adoc[]

toc::[]

[[config-synopsis]]
== Введение

Один из важных аспектов FreeBSD это настройка системы. Правильная настройка системы поможет избежать головной боли при последующих обновлениях. Эта глава описывает большую часть процесса настройки FreeBSD, включая некоторые параметры, которые можно установить для оптимизации системы FreeBSD.

После прочтения этой главы вы узнаете:

* Как эффективно работать с файловыми системами и разделами подкачки.
* Основы настройки [.filename]#rc.conf# и системы запуска приложений [.filename]#/usr/local/etc/rc.d#.
* Как настроить и протестировать сетевую карту.
* Как настроить виртуальные хосты на сетевых устройствах.
* Как использовать различные файлы конфигурации в [.filename]#/etc#.
* Как оптимизировать FreeBSD, используя переменные `sysctl`.
* Как увеличить скорость работы дисков и изменить ограничения, накладываемые ядром.

Перед прочтением этой главы вам следует:

* Понять основы UNIX(R) и FreeBSD (crossref:basics[basics, Основы UNIX]).
* Ознакомиться с основами конфигурации/компиляции ядра (crossref:kernelconfig[kernelconfig, Настройка ядра FreeBSD]).

[[configtuning-initial]]
== Начальное конфигурирование

=== Разделы диска

==== Основы построения разделов

Во время разметки жёсткого диска с помощью man:bsdlabel[8] или man:sysinstall[8], важно помнить, что скорость чтения и записи данных уменьшается от внешних к внутренним трекам диска. Самые маленькие и самые часто используемые файловые системы (корневая и раздел подкачки) должны быть расположены в начале диска, в то время как самые большие, такие, как [.filename]#/usr#, в конце. Самым оптимальным считается следующий порядок расположения файловых систем: root, swap, [.filename]#/var#, [.filename]#/usr#.

Размер файловой системы [.filename]#/var# определяется предназначением машины. [.filename]#/var# используется для хранения почтовых ящиков, очередей печати и лог файлов. Размер почтовых ящиков и лог файлов может расти неограниченно в зависимости от количества пользователей системы и от того, как долго хранятся лог-файлы. Большинству пользователей никогда не потребуется гигабайт, но помните, что [.filename]#/var/tmp# должен быть достаточно большим для пакетов.

В разделе [.filename]#/usr# содержит большинство файлов, необходимых для поддержки системы, порты (man:ports[7], рекомендуется) и исходные тексты (опционально). Оба эти каталога опциональны при установке. Для этого раздела рекомендуется как минимум 2 гигабайта.

При установке размера разделов, не забудьте принять во внимание рост размера требуемого системе дискового пространства. Переполнение одного раздела даже при наличии свободного места на другом может вызвать затруднения.

[NOTE]
====
Многие пользователи обнаружили, что размер разделов, предлагаемый man:sysinstall[8]'ом по умолчанию, иногда меньше подходящего для разделов [.filename]#/var# и [.filename]#/#. Тщательно планируйте размер разделов и не жалейте места.
====

[[swap-design]]
==== Раздел подкачки

Как правило, размер раздела подкачки должен быть равен удвоенному размеру оперативной памяти. Например, если на машине установлено 128 мегабайт памяти, раздел подкачки должен быть 256 мегабайт. Системы с меньшим количеством памяти могут работать лучше с большим объёмом раздела подкачки. Не рекомендуется устанавливать размер раздела подкачки меньше 256 мегабайт, необходимо также принять во внимание возможное наращивание объема установленной на машине памяти. Алгоритмы кэширования VM настроены на максимальное быстродействие, когда размер раздела подкачки равен как минимум удвоенному размеру памяти. Заниженный размер раздела подкачки может привести к неэффективной работе постраничного сканирования VM и вызвать проблемы при увеличении объёма памяти.

На больших системах с несколькими SCSI дисками (или несколькими IDE дисками, находящимися на разных контроллерах), рекомендуется создавать раздел подкачки на каждом диске (до четырёх дисков). Разделы подкачки должны быть примерно одного размера. Ядро не накладывает ограничений на размер раздела подкачки, но внутренние структуры позволяют иметь общий размер разделов подкачки, равный наибольшему, умноженному на четыре. Выделение под разделы подкачки примерно одинакового места позволить ядру оптимально расположить разделы подкачки. Установка размера подкачки больше требуемого нормальна, даже если этот объем не используется. В этих условиях может быть проще восстановиться после зависания программы перед тем, как возникнет необходимость перезагрузки.

==== Зачем нужны разделы?

Некоторые пользователи считают, что лучше использовать один большой раздел, но есть несколько причин, по которым этого лучше не делать. Во-первых, у каждого раздела свои характеристики, и отделяя их, можно выполнить соответствующие настройки. Например, корневая и файловая система и [.filename]#/usr# в основном предназначены для чтения, без большого объема записи. В то же время множество операций чтения и записи выполняется в [.filename]#/var# и [.filename]#/var/tmp#.

При правильном размещении и выборе размера разделов системы, фрагментация в более маленьких разделах, куда часто записываются данные, не перенесётся на остальные разделы. Размещение самых часто используемых разделов ближе к началу диска увеличит скорость ввода/вывода там, где она нужна больше всего. Хотя производительность важна и для больших дисков, передвижение их ближе к концу диска не повлечёт значительного уменьшения быстродействия по сравнению с перемещением ближе к концу диска [.filename]#/var#. И, наконец, разделы существуют и из соображений безопасности. Наличие маленького аккуратного корневого раздела, доступного только для чтения даёт значительные шансы на "выживание" после краха системы.

[[configtuning-core-configuration]]
== Основные настройки

Основные настройки системы располагаются в [.filename]#/etc/rc.conf#. Этот файл вмещает широкий спектр конфигурационной информации, используемой при загрузке системы. Имя этого файла прямо отражает его назначение, это файл настройки для файлов [.filename]#rc*#.

Администратор должен сделать записи в [.filename]#rc.conf#, чтобы переопределить строки по умолчанию из [.filename]#/etc/defaults/rc.conf#. Файлы по умолчанию нельзя копировать в [.filename]#/etc# - они вмещают значения по умолчанию, а не примеры значений. Все специфичные для данной системы изменения должны быть сделаны в файле [.filename]#rc.conf#.

Существует несколько методов для отделения общей конфигурации для группы систем от конкретной для данной системы в целях уменьшения объема работы администратора. Рекомендуемый метод - прописать общую конфигурацию в отдельный файл, например, в [.filename]#/etc/rc.conf.site#, и включить его название в [.filename]#/etc/rc.conf#, который вмещает только специфичную для данной системы информацию.

Поскольку [.filename]#rc.conf# читается man:sh[1], есть тривиальный способ сделать это. Например:

* rc.conf:
+
[.programlisting]
....
	. /etc/rc.conf.site
	hostname="node15.example.com"
	network_interfaces="fxp0 lo0"
	ifconfig_fxp0="inet 10.1.1.1"
....

* rc.conf.site:
+
[.programlisting]
....
	defaultrouter="10.1.1.254"
	saver="daemon"
	blanktime="100"
....

Файл [.filename]#rc.conf.site# может быть распространён на все системы, используя `rsync` или подобную ей программу, в то время, как [.filename]#rc.conf# должен остаться только на одной машине.

Обновление системы с помощью man:sysinstall[8] или `make world` не повлекут за собой перезапись [.filename]#rc.conf#. Вся информация в этом файле сохранится.

[[configtuning-appconfig]]
== Настройка приложений

Обычно, установленные приложения имеют свои конфигурационные файлы, со своим собственным синтаксисом. Важно хранить эти файлы отдельно от файлов основной системы, чтобы их можно было легко администрировать с помощью средств управления пакетами.

Обычно эти файлы устанавливаются в [.filename]#/usr/local/etc#. В случае, если приложению нужно большое количество конфигурационных файлов, для их хранения будет создан подкаталог.

Обычно, вместе с установкой портов и пакетов, устанавливаются и примеры конфигурационных файлов. Обычно они имеют расширение [.filename]#.default#. Если не существует конфигурационных файлов для этого приложения, они будут созданы путём копирования [.filename]#.default# файлов.

Например, [.filename]#/usr/local/etc/apache#:

....
-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf
-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf.default
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf.default
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic.default
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types.default
-rw-r--r--  1 root  wheel   7980 May 20  1998 srm.conf
-rw-r--r--  1 root  wheel   7933 May 20  1998 srm.conf.default
....

Размеры файлов показывают, что только файл [.filename]#srm.conf# был изменён. При следующем обновлении Apache этот файл уже не будет перезаписан.

[[configtuning-starting-services]]
== Запуск сервисов

Многие пользователи предпочитают устанавливать программы сторонних производителей в FreeBSD из набора портов. В подобных случаях может потребоваться сконфигурировать программы так, чтобы они запускались при инициализации системы. Сервисы, такие как package:mail/postfix[] или package:www/apache13[], - это лишь два примера множества программных пакетов, которые можно запускать при инициализации системы. В этом разделе описывается процедура, предназначенная для запуска программ сторонних разработчиков.

Большинство входящих в FreeBSD сервисов, таких как man:cron[8], запускается с помощью стартовых скриптов системы. Эти скрипты могут различаться в зависимости от версии FreeBSD или ее производителя; однако важнее всего учитывать, что их начальную конфигурацию можно задать с помощью простых стартовых скриптов.

До появления [.filename]#rc.d# приложения должны были помещать простой стартовый скрипт в каталог [.filename]#/usr/local/etc/rc.d#, который затем читался скриптами инициализации системы. Эти скрипты затем выполнялись в ходе последующих стадий запуска системы.

Хотя много разработчиков потратили часы на попытки внедрить старый стиль конфигурирования в новую систему, остаётся фактом, что для некоторых утилит сторонних производителей по-прежнему необходим скрипт, помещённый в указанный выше каталог. Незначительные различия в скриптах зависят от того, используется ли [.filename]#rc.d#. До версии FreeBSD 5.1 использовались скрипты в старом стиле, и почти во всех случаях скрипты в новом стиле должны подойти так же хорошо.

Хотя каждый скрипт должен соответствовать некоторым минимальным требованиям, в большинстве случаев эти требования не зависят от версии FreeBSD. Каждый скрипт должен иметь в конце расширение [.filename]#.sh# и каждый скрипт должен быть выполняемым. Последнее требование может быть выполнено путем установки командой `chmod` уникальных прав доступа `755`. Также, как минимум, должна быть опция `start` для запуска приложения и опция `stop` для его остановки.

Простейший стартовый скрипт, пожалуй, будет похож на следующий:

[.programlisting]
....
#!/bin/sh
echo -n ' utility'

case "$1" in
start)
        /usr/local/bin/utility
        ;;
stop)
        kill -9 `cat /var/run/utility.pid`
        ;;
*)
        echo "Usage: `basename $0` {start|stop}" 2
        exit 64
        ;;
esac

exit 0
....

Этот скрипт поддерживает опции `stop` и `start` для приложения, которое мы здесь называем просто - `utility`.

А можно запускать его и вручную, с помощью команды:

[source,bash]
....
# /usr/local/etc/rc.d/utility.sh start
....

Хотя и не все программы сторонних производителей требуют добавления строки в файл [.filename]#rc.conf#, практически каждый день очередной новый порт меняется так, чтобы поддерживать подобную конфигурацию. Поищите в результатах, выдаваемых после установки более детальную информацию по конкретному приложению. Некоторые программы сторонних производителей будут включать стартовые скрипты, позволяющие использовать приложение с [.filename]#rc.d#; но это мы еще обсудим в следующем разделе.

=== Расширенное конфигурирование приложения

Теперь, когда FreeBSD включает [.filename]#rc.d#, конфигурирование запуска приложений стало более оптимальным; фактически, оно стало более тщательным. С помощью ключевых слов, рассмотренных в разделе <<configtuning-rcd,rc.d>>, приложения теперь можно настроить для запуска после других заданных сервисов, например, DNS; можно разрешить передачу дополнительных флагов через [.filename]#rc.conf# вместо жесткого задания флагов в стартовых скриптах, и т.д. Простой скрипт может иметь следующий вид:

[.programlisting]
....
#!/bin/sh
#
# PROVIDE: utility
# REQUIRE: DAEMON
# KEYWORD: shutdown

. /etc/rc.subr

name=utility
rcvar=utility_pidfile

command="/usr/local/sbin/utility"

load_rc_config $name

#
# НЕ МЕНЯЙТЕ ЗДЕСЬ ЭТИ СТАНДАРТНЫЕ ЗНАЧЕНИЯ
# ЗАДАВАЙТЕ ИХ В ФАЙЛЕ /etc/rc.conf
#
utility_enable=${utility_enable-"NO"}
pidfile=${utility_pidfile-"/var/run/utility.pid"}

run_rc_command "$1"
....

Этот скрипт будет гарантировать, что указанное приложение utility будет запущено после сервиса `daemon`. Он также предоставляет метод для создания и отслеживания файла идентификатора процесса, PID.

Для этого приложения затем можно поместить следующую строку в файл [.filename]#/etc/rc.conf#:

[.programlisting]
....
utility_enable="YES"
....

Этот новый метод также позволяет легко работать с аргументами командной строки, включать стандартные функции из файла [.filename]#/etc/rc.subr#, обеспечивает совместимость с утилитой man:rcorder[8] и упрощает конфигурирование с помощью файла [.filename]#rc.conf#.

=== Использование сервисов для запуска сервисов

Другие сервисы, такие как даемоны сервера POP3, IMAP, и т.п. могут быть запущены с помощью man:inetd[8]. Для этого необходимо установить сервисную утилиту из набора портов и добавить соответствующую строчку конфигурации в файл [.filename]#/etc/inetd.conf# или раскомментировать подходящую строку конфигурации из уже имеющихся. Работа с даемоном inetd и его конфигурирование подробно описаны в разделе crossref:network-servers[network-inetd,inetd].

В некоторых случаях использование для запуска системных служб даемона man:cron[8] может оказаться более приемлемым. Этот подход имеет несколько преимуществ, поскольку даемон `cron` запускает эти процессы от имени владельца файла [.filename]#crontab#. Это позволяет обычным пользователям запускать и поддерживать некоторые приложения.

Утилита `cron` поддерживает уникальную возможность, `@reboot`, - это значение можно использовать вместо спецификации времени. В результате, задание будет выполнено при запуске man:cron[8], обычно - в ходе инициализации системы.

[[configtuning-cron]]
== Настройка утилиты `cron`

Одна из наиболее полезных утилит FreeBSD это man:cron[8]. Утилита `cron` работает в фоновом режиме и постоянно проверяет файл [.filename]#/etc/crontab#. Утилита `cron` проверяет также каталог [.filename]#/var/cron/tabs# в поиске новых файлов [.filename]#crontab#. Файлы [.filename]#crontab# содержат информацию об определенных функциях, которые `cron` выполняет в указанное время.

Утилита `cron` использует два разных типа конфигурационных файлов, системный и пользовательский. Все различие между этими двумя форматами заключается в шестом поле. В системном файле шестое поля это имя пользователя, с правами которого будет запущена команда. Это позволяет запускать команды из системного crontab от любого пользователя. В пользовательском файле шестое поле указывает запускаемую команду, и все команды запускаются от пользователя, который создал crontab; это важно для безопасности.

[NOTE]
====
Пользовательские crontab позволяют индивидуальным пользователям планировать задачи без привилегий суперпользователя (`root`). Команды из crontab пользователя запускаются с привилегиями этого пользователя.

Пользователь `root` может использовать собственный crontab, как и любой другой пользователь. Он будет отличаться от системного crontab [.filename]#/etc/crontab#. Поскольку существует системный crontab, обычно не требуется создавать пользовательский crontab для `root`.
====

Давайте заглянем в файл [.filename]#/etc/crontab# (системный crontab):

[.programlisting]
....
# /etc/crontab - root's crontab for FreeBSD
#
# $FreeBSD: src/etc/crontab,v 1.32 2002/11/22 16:13:39 tom Exp $
## <.>
#
SHELL=/bin/sh
PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin <.>
HOME=/var/log
#
#
#minute	hour	mday	month	wday	who	command <.>
#
#
*/5	*	*	*	*	root	/usr/libexec/atrun <.>
....

<.> Как и в большинстве файлов настройки FreeBSD, символы "#" означают комментарии. Комментарии нужны для напоминания о том, что означает строка и зачем она добавлена. Комментарии не могут находиться на той же строке, что и команда, или они будут восприняты как часть команды; располагайте их на новой строке. Пустые строки игнорируются.

<.> Сначала должны быть заданы переменные окружения. Знак равно (`=`) используется для задания переменных окружения, в этом примере `SHELL`, `PATH`, и `HOME`. Если переменная для оболочки не задана, `cron` использует оболочку по умолчанию, `sh`. Если не задана переменная `PATH`, значение по умолчанию не устанавливается и пути к файлам должны быть полными. Если не задана переменная `HOME`, `cron` будет использовать домашний каталог соответствующего пользователя.

<.> В строке всего семь полей. Их значения `minute`, `hour`, `mday`, `month`, `wday`, `who` (кто), и `command`. Значение полей почти очевидно. `minute` это время в минутах, когда будет запущена команда. `hour` означает то же самое для часов. `mday` означает день месяца. `month`, это то же самое, что час и минута, но для месяцев. Параметр `wday` это день недели. Все эти поля должны быть в числовом формате, время в двадцатичетырехчасовом исчислении. Поле `who` имеет специальное значение, и присутствует только в файле [.filename]#/etc/crontab#. Это поле определяет пользователя, с правами которого должна быть запущена команда. Когда пользователь устанавливает собственный файл [.filename]#crontab#, он не указывает этот параметр. Последний параметр `command`. Он указывает команду, которая должна быть запущена.

<.> Последняя строка определяет параметры, описанные выше. Здесь задано значение `\*/5`, и несколько символов `\*`. Эти символы `*` означают "первый-последний", и могут быть интерпретированы как _каждый_. Таким образом, для этой строки соответствующая команда `atrun` вызывается под пользователем `root` каждые пять минут независимо от дня или месяца. За дополнительной информацией по команде `atrun` обращайтесь к странице справочника man:atrun[8].Команды могут принимать любое количество параметров; однако команды, состоящие из нескольких строк, должны быть объединены символом "\".

Этот формат одинаков для каждого файла [.filename]#crontab#, за исключением одной детали. Шестое поле, где указано имя пользователя, присутствует только в файле [.filename]#/etc/crontab#. Это поле должно быть исключено из [.filename]#crontab# файлов пользователей.

[[configtuning-installcrontab]]
=== Установка crontab

[IMPORTANT]
====
Вы не должны использовать процедуру, описанную здесь, для установки системного crontab. Просто используйте свой любимый текстовый редактор: утилита `cron` узнает о том, что файл изменился и сразу начнет использовать обновленную версию. Обратитесь к link:{faq}#ROOT-NOT-FOUND-CRON-ERRORS[этой части FAQ] за дальнейшей информацией.
====

Для установки готового [.filename]#crontab# пользователя, сначала создайте в вашем любимом редакторе файл соответствующего формата, а затем воспользуйтесь утилитой `crontab`. Обычно она запускается так:

[source,bash]
....
% crontab crontab-file
....

В этом примере, [.filename]#crontab-file# это имя файла crontab, который только что был создан.

Существует также параметр для просмотра установленных файлов [.filename]#crontab#: задайте `crontab` параметр `-l`.

Для пользователей, составляющих crontab вручную, без временного файла, существует параметр `crontab -e`. Она вызовет редактор с пустым файлом. Когда файл будет сохранен, `crontab` автоматически установит его.

Если позднее вы захотите полностью удалить свой [.filename]#crontab#, используйте `crontab` с параметром `-r`.

[[configtuning-rcd]]
== Использование rc во FreeBSD 5.X и последующих версиях

Во FreeBSD недавно была интегрирована из NetBSD система [.filename]#rc.d#, используемая для старта системы. Многие из файлов в каталоге [.filename]#/etc/rc.d# предназначены для основных сервисов, они могут управляться параметрами `start`, `stop`, и `restart`. Например, man:sshd[8] может быть перезапущен следующей командой:

[source,bash]
....
# /etc/rc.d/sshd restart
....

Эта процедура похожа для других сервисов. Конечно, сервисы обычно запускаются автоматически при загрузке системы, как указано в man:rc.conf[5]. Например, включение даемона Network Address Translation при запуске выполняется простым добавлением следующей строки в [.filename]#/etc/rc.conf#:

[.programlisting]
....
natd_enable="YES"
....

Если `natd_enable="NO"` уже присутствует, просто измените `NO` на `YES`. Скрипты rc автоматически загрузят все другие зависимые сервисы, как описано ниже.

Поскольку система [.filename]#rc.d# в основном предназначена для запуска/отключения сервисов во время запуска/отключения системы, стандартные параметры `start`, `stop` и `restart` будут работать только если установлена соответствующая переменная в [.filename]#/etc/rc.conf#. Например, команда выше `sshd restart` будет работать только если переменная `sshd_enable` в файле [.filename]#/etc/rc.conf# установлена в `YES`. Для выполнения скриптов независимо от установок в [.filename]#/etc/rc.conf#, параметры `start`, `stop` или `restart` необходимо задавать с префиксом "force". Например, для перезапуска `sshd` независимо от установок в [.filename]#/etc/rc.conf#, выполните следующую команду:

[source,bash]
....
# /etc/rc.d/sshd forcerestart
....

Проверить состояние переменной в файле [.filename]#/etc/rc.conf# легко: запустите соответствующий скрипт из [.filename]#rc.d# с параметром `rcvar`. Проверка переменной для `sshd` выполняется следующей командой:

[source,bash]
....
# /etc/rc.d/sshd rcvar
# sshd
$sshd_enable=YES
....

[NOTE]
====
Вторая строка (`# sshd`) это вывод команды `sshd`, а не консоль `root`.
====

Чтобы определить, запущен ли сервис, существует параметр `status`. Например для проверки того, запущен ли `sshd`, выполните:

[source,bash]
....
# /etc/rc.d/sshd status
sshd is running as pid 433.
....

В некоторых случаях возможна также перегрузка (`reload`) сервиса. Скрипт, запущенный с этим параметром, попытается отправить сервису сигнал, вызывающий перезагрузку файлов настройки. В большинстве случаев это означает отправку сервису сигнала `SIGHUP`. Следует помнить, что эту функцию поддерживают не все сервисы.

Система [.filename]#rc.d# используется не только для сетевых серверов, она отвечает также за большую часть инициализации системы. Рассмотрим, к примеру, файл [.filename]#bgfsck#. Во время выполнения этот скрипт выводит следующее сообщение:

[source,bash]
....
Starting background file system checks in 60 seconds.
....

Следовательно, этот файл используется для фоновой проверки файловых систем, которая выполняется только в процессе инициализации системы.

Функционирование многих сервисов системы зависит от корректной работы других сервисов. Например, NIS и другие основанные на RPC сервисы могут не запуститься, пока не загрузится `rpcbind` (portmapper). Для разрешения этой проблемы, в начале каждого скрипта в комментарии включаются информация о зависимостях и другие метаданные. Программа man:rcorder[8] используется для разбора этих комментариев во время старта системы для определения порядка, в котором должны вызываться системные сервисы в соответствии с зависимостями. В начало каждого стартового файла должны быть включены следующие строки:

* `PROVIDE`: Задает имя сервиса, предоставляемого этим файлом.
* `REQUIRE`: Список сервисов, необходимых этому сервису. Этот файл будет запущен _после_ указанных сервисов.
* `BEFORE`: Список сервисов, зависящих от этого сервиса. Этот файл будет запущен _до_ указанных сервисов.

Используя этот метод, администратор может легко контролировать системные сервисы без использования "уровней запуска", как в некоторых других операционных системах UNIX(R).

Дополнительную информацию о системе [.filename]#rc.d# можно найти на страницах справочника man:rc[8] и man:rc.subr[8].

[[config-network-setup]]
== Настройка карт сетевых интерфейсов

В наши дни мы не представляем себе компьютера без сетевого подключения. Добавление и настройка сетевой карты это обычная задача любого администратора FreeBSD.

=== Поиск подходящего драйвера

В первую очередь определите тип используемой карты (PCI или ISA), модель карты и используемый в ней чип. FreeBSD поддерживает многие PCI и ISA карты. Обратитесь к Списку поддерживаемого оборудования вашего релиза чтобы узнать, поддерживается ли карта.

Как только вы убедились, что карта поддерживается, потребуется определить подходящий драйвер. В файлах [.filename]#/usr/src/sys/conf/NOTES# и [.filename]#/usr/src/sys/arch/conf/NOTES# находится список драйверов сетевых интерфейсов с информацией о поддерживаемых чипсетах/картах. Если вы сомневаетесь в том, какой драйвер подойдет, прочтите страницу справочника к драйверу. Страница справочника содержит больше информации о поддерживаемом оборудовании и даже о проблемах, которые могут возникнуть.

Если ваша карта широко распространена, вам скорее всего не потребуется долго искать драйвер. Драйверы для широко распространенных карт представлены в ядре [.filename]#GENERIC#, так что ваша карта должна определиться при загрузке, примерно так:

[source,bash]
....
dc0: <82c169 PNIC 10/100BaseTX> port 0xa000-0xa0ff mem 0xd3800000-0xd38
000ff irq 15 at device 11.0 on pci0
dc0: Ethernet address: 00:a0:cc:da:da:da
miibus0: <MII bus> on dc0
ukphy0: <Generic IEEE 802.3u media interface> on miibus0
ukphy0:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
dc1: <82c169 PNIC 10/100BaseTX> port 0x9800-0x98ff mem 0xd3000000-0xd30
000ff irq 11 at device 12.0 on pci0
dc1: Ethernet address: 00:a0:cc:da:da:db
miibus1: <MII bus> on dc1
ukphy1: <Generic IEEE 802.3u media interface> on miibus1
ukphy1:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
....

В этом примере две карты используют имеющийся в системе драйвер man:dc[4].

Если драйвер вашей сетевой карты отсутствует в [.filename]#GENERIC#, для ее использования потребуется загрузить подходящий драйвер. Это может быть сделано одним из двух способов:

* Простейший способ - просто загрузить модуль ядра сетевой карты с помощью man:kldload[8]. Не все драйверы доступны в виде модулей; например, модули отсутствуют для ISA карт.
* Вместо этого, вы можете статически включить поддержку карты, скомпилировав собственное ядро. Информацию о том, какие параметры нужно включать в ядро, можно получить из [.filename]#/usr/src/sys/conf/NOTES#, [.filename]#/usr/src/sys/arch/conf/NOTES# и страницы справочника драйвера сетевой карты. За более подробной информацией о сборке собственного ядра обращайтесь к crossref:kernelconfig[kernelconfig, Настройка ядра FreeBSD]. Если карта была обнаружена вашим ядром ([.filename]#GENERIC#) во время загрузки, собирать ядро не потребуется.

=== Настройка сетевой карты

Как только для сетевой карты загружен подходящий драйвер, ее потребуется настроить. Как и многое другое, сетевая карта может быть настроена во время установки с помощью sysinstall.

Для вывода информации о настройке сетевых интерфейсов системы, введите следующую команду:

[source,bash]
....
% ifconfig
dc0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500
        inet 192.168.1.3 netmask 0xffffff00 broadcast 192.168.1.255
        ether 00:a0:cc:da:da:da
        media: Ethernet autoselect (100baseTX <full-duplex>)
        status: active
dc1: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500
        inet 10.0.0.1 netmask 0xffffff00 broadcast 10.0.0.255
        ether 00:a0:cc:da:da:db
        media: Ethernet 10baseT/UTP
        status: no carrier
lp0: flags=8810<POINTOPOINT,SIMPLEX,MULTICAST> mtu 1500
lo0: flags=8049<UP,LOOPBACK,RUNNING,MULTICAST> mtu 16384
        inet 127.0.0.1 netmask 0xff000000
tun0: flags=8010<POINTOPOINT,MULTICAST> mtu 1500
....

[NOTE]
====
Старые версии FreeBSD могут потребовать запуска man:ifconfig[8] с параметром `-a`, за более подробным описанием синтаксиса man:ifconfig[8] обращайтесь к странице справочника. Учтите также, что строки, относящиеся к IPv6 (`inet6` и т.п.) убраны из этого примера.
====

В этом примере были показаны следующие устройства:

* [.filename]#dc0#: первый Ethernet интерфейс
* [.filename]#dc1#: второй Ethernet интерфейс
* [.filename]#lp0#: интерфейс параллельного порта
* [.filename]#lo0#: устройство loopback
* [.filename]#tun0#: туннельное устройство, используемое ppp

Для присвоения имени сетевой карте FreeBSD использует имя драйвера и порядковый номер, в котором карта обнаруживается при инициализации устройств. Например, [.filename]#sis2# это третья сетевая карта, использующая драйвер man:sis[4].

В этом примере, устройство [.filename]#dc0# включено и работает. Ключевые признаки таковы:

. `UP` означает, что карта настроена и готова.
. У карты есть интернет (`inet`) адрес (в данном случае `192.168.1.3`).
. Установлена маска подсети (`netmask`; `0xffffff00`, то же, что и `255.255.255.0`).
. Широковещательный адрес (в данном случае, `192.168.1.255`).
. Значение MAC адреса карты (`ether`) `00:a0:cc:da:da:da`
. Выбор физической среды передачи данных в режиме автовыбора (`media: Ethernet autoselect (100baseTX full-duplex)`). Мы видим, что [.filename]#dc1# была настроена для работы с `10baseT/UTP`. За более подробной информацией о доступных драйверу типах среды обращайтесь к странице справочника.
. Статус соединения (`status`) `active`, т.е. несущая обнаружена. Для [.filename]#dc1#, мы видим `status: no carrier`. Это нормально, когда Ethernet кабель не подключен к карте.

Если man:ifconfig[8] показывает примерно следующее:

[source,bash]
....
dc0: flags=8843<BROADCAST,SIMPLEX,MULTICAST> mtu 1500
	        ether 00:a0:cc:da:da:da
....

это означает, что карта не была настроена.

Для настройки карты вам потребуются привилегии пользователя `root`. Настройка сетевой карты может быть выполнена из командной строки с помощью man:ifconfig[8], но вам потребуется делать это после каждой перезагрузки системы. Подходящее место для настройки сетевых карт это файл [.filename]#/etc/rc.conf#.

Откройте [.filename]#/etc/rc.conf# в текстовом редакторе. Вам потребуется добавить строку для каждой сетевой карты, имеющейся в системе, например, в нашем случае, было добавлено две строки:

[.programlisting]
....
ifconfig_dc0="inet 192.168.1.3 netmask 255.255.255.0"
ifconfig_dc1="inet 10.0.0.1 netmask 255.255.255.0 media 10baseT/UTP"
....

Замените [.filename]#dc0#, [.filename]#dc1#, и так далее на соответствующие имена ваших карт, подставьте соответствующие адреса. Обратитесь к страницам справочника сетевой карты и man:ifconfig[8], за подробной информацией о доступных опциях и к странице справочника man:rc.conf[5] за дополнительной информацией о синтаксисе [.filename]#/etc/rc.conf#.

Если вы настроили сетевую карту в процессе установки системы, некоторые строки, касающиеся сетевой карты, могут уже присутствовать. Внимательно проверьте [.filename]#/etc/rc.conf# перед добавлением каких-либо строк.

Отредактируйте также файл [.filename]#/etc/hosts# для добавления имен и IP адресов различных компьютеров сети, если их еще там нет. За дополнительной информацией обращайтесь к man.hosts.5; и к [.filename]#/usr/shared/examples/etc/hosts#.

=== Тестирование и решение проблем

Как только вы внесете необходимые изменения в [.filename]#/etc/rc.conf#, перегрузите компьютер. Изменения настроек интерфейсов будут применены, кроме того будет проверена правильность настроек.

Как только система перезагрузится, проверьте сетевые интерфейсы.

==== Проверка Ethernet карты

Для проверки правильности настройки сетевой карты, попробуйте выполнить ping для самого интерфейса, а затем для другой машины в локальной сети.

Сначала проверьте локальный интерфейс:

[source,bash]
....
% ping -c5 192.168.1.3
PING 192.168.1.3 (192.168.1.3): 56 data bytes
64 bytes from 192.168.1.3: icmp_seq=0 ttl=64 time=0.082 ms
64 bytes from 192.168.1.3: icmp_seq=1 ttl=64 time=0.074 ms
64 bytes from 192.168.1.3: icmp_seq=2 ttl=64 time=0.076 ms
64 bytes from 192.168.1.3: icmp_seq=3 ttl=64 time=0.108 ms
64 bytes from 192.168.1.3: icmp_seq=4 ttl=64 time=0.076 ms

--- 192.168.1.3 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.074/0.083/0.108/0.013 ms
....

Затем проверьте другую машину в локальной сети:

[source,bash]
....
% ping -c5 192.168.1.2
PING 192.168.1.2 (192.168.1.2): 56 data bytes
64 bytes from 192.168.1.2: icmp_seq=0 ttl=64 time=0.726 ms
64 bytes from 192.168.1.2: icmp_seq=1 ttl=64 time=0.766 ms
64 bytes from 192.168.1.2: icmp_seq=2 ttl=64 time=0.700 ms
64 bytes from 192.168.1.2: icmp_seq=3 ttl=64 time=0.747 ms
64 bytes from 192.168.1.2: icmp_seq=4 ttl=64 time=0.704 ms

--- 192.168.1.2 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.700/0.729/0.766/0.025 ms
....

Вы можете также использовать имя машины вместо `192.168.1.2`, если настроен файл [.filename]#/etc/hosts#.

==== Решение проблем

Решение проблем с аппаратным и программным обеспечением всегда вызывает сложности, которые можно уменьшить, проверив сначала самые простые варианты. Подключен ли сетевой кабель? Правильно ли настроены сетевые сервисы? Правильно ли настроен брандмауэр? Поддерживается ли используемая карта в FreeBSD? Всегда проверяйте информацию об оборудовании перед отправкой сообщения об ошибке. Обновите FreeBSD до последней версии STABLE. Просмотрите архивы списков рассылки, или поищите информацию в интернет.

Если карта работает, но производительность низка, может помочь чтение страницы справочника man:tuning[7]. Проверьте также настройки сети, поскольку неправильные настройки могут стать причиной низкой скорости соединения.

Некоторые пользователи встречаются с несколькими `device timeouts`, что нормально для некоторых сетевых карт. Если это продолжается и надоедает, убедитесь, что устройство не конфликтует с другим устройством. Внимательно проверьте подключение кабеля. Возможно также, что вам просто надо установить другую карту.

Время от времени, пользователи видят несколько ошибок `watchdog timeout`. Первое, что требуется сделать, это проверить сетевой кабель. Многие карты требуют поддержки Bus Mastering слотом PCI. На некоторых старых материнских платах, только один PCI слот имеет такую поддержку (обычно слот 0). Сверьтесь с документацией на сетевую карту и материнскую плату, чтобы определить, может ли это быть проблемой.

Сообщение `No route to host` появляются, если система не в состоянии доставить пакеты к хосту назначения. Это может случиться, если не определен маршрут по умолчанию, или кабель не подключен. Проверьте вывод команды `netstat -rn` и убедитесь, что к соответствующему хосту есть работающий маршрут. Если это не так, прочтите crossref:advanced-networking[advanced-networking, Сложные вопросы работы в сети].

Сообщения `ping: sendto: Permission denied` зачастую появляются при неправильно настроенном брандмауэре. Если `ipfw` включен в ядре, но правила не определены, правило по умолчанию блокирует весь трафик, даже запросы ping! Прочтите crossref:firewalls[firewalls, Межсетевые экраны] с более подробной информацией.

Иногда скорость карты недостаточна, или ниже среднего. В этих случаях лучше всего изменить режим выбора типа подключения с `autoselect` на правильный тип. Обычно это работает для большинства оборудования, но не может решить проблему во всех случаях. Проверьте еще раз настройки сети и прочтите страницу справочника man:tuning[7].

[[configtuning-virtual-hosts]]
== Настройка виртуальных серверов

Очень часто FreeBSD используется для размещения сайтов, когда один сервер работает в сети как несколько серверов. Это достигается присвоением нескольких сетевых адресов одному интерфейсу.

У сетевого интерфейса всегда есть один "настоящий" адрес, хотя он может иметь любое количество "синонимов" (alias). Эти синонимы обычно добавляются путём помещения соответствующих записей в [.filename]#/etc/rc.conf#.

Синоним для интерфейса [.filename]#fxp0# выглядит следующим образом:

[.programlisting]
....
ifconfig_fxp0_alias0="inet xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx"
....

Заметьте, что записи синонимов должны начинаться с `alias0` и идти далее в определенном порядке (например, `_alias1`, `_alias2`, и т.д.). Конфигурационный процесс остановится на первом по порядку отсутствующем числе.

Определение маски подсети для синонима очень важно, но к счастью, так же просто. Для каждого интерфейса должен быть один адрес с истинной маской подсети. Любой другой адрес в сети должен иметь маску подсети, состоящую из всех единичек (что выражается как `255.255.255.255` или как `0xffffffff`).

Например, рассмотрим случай, когда интерфейс [.filename]#fxp0# подключён к двум сетям, к сети `10.1.1.0` с маской подсети `255.255.255.0` и к сети `202.0.75.16` с маской `255.255.255.240`. Мы хотим, чтобы система была видна по IP, начиная с `10.1.1.1` по `10.1.1.5` и с `202.0.75.17` по `202.0.75.20`. Как было сказано выше, только первый адрес в заданном диапазоне (в данном случае, `10.0.1.1` и `202.0.75.17`) должен иметь реальную маску сети; все остальные (с `10.1.1.2` по `10.1.1.5` и с `202.0.75.18` по `202.0.75.20`) должны быть сконфигурированы с маской сети `255.255.255.255`.

Для этого в файл [.filename]#/etc/rc.conf# должны быть внесены следующие записи:

[.programlisting]
....
ifconfig_fxp0="inet 10.1.1.1 netmask 255.255.255.0"
ifconfig_fxp0_alias0="inet 10.1.1.2 netmask 255.255.255.255"
ifconfig_fxp0_alias1="inet 10.1.1.3 netmask 255.255.255.255"
ifconfig_fxp0_alias2="inet 10.1.1.4 netmask 255.255.255.255"
ifconfig_fxp0_alias3="inet 10.1.1.5 netmask 255.255.255.255"
ifconfig_fxp0_alias4="inet 202.0.75.17 netmask 255.255.255.240"
ifconfig_fxp0_alias5="inet 202.0.75.18 netmask 255.255.255.255"
ifconfig_fxp0_alias6="inet 202.0.75.19 netmask 255.255.255.255"
ifconfig_fxp0_alias7="inet 202.0.75.20 netmask 255.255.255.255"
....

[[configtuning-configfiles]]
== Файлы настройки

=== Каталог [.filename]#/etc#

Во FreeBSD определён ряд каталогов, предназначенных для хранения конфигурационных файлов. Это:

[.informaltable]
[cols="1,1", frame="none"]
|===

|[.filename]#/etc#
|Основные файлы конфигурации системы. Тут размещены системно-зависимые данные.

|[.filename]#/etc/defaults#
|Версии системных конфигурационных файлов по умолчанию.

|[.filename]#/etc/mail#
|Дополнительные конфигурационные файлы man:sendmail[8], другие конфигурационные файлы MTA. 

|[.filename]#/etc/ppp#
|Настройка для user- и kernel-ppp программ. 

|[.filename]#/etc/namedb#
|Основное место расположения данных man:named[8]. Обычно [.filename]#named.conf# и файлы зон расположены здесь.

|[.filename]#/usr/local/etc#
|Конфигурационные файлы установленных приложений. Могут содержать подкаталоги приложений.

|[.filename]#/usr/local/etc/rc.d#
|Скрипты запуска/остановки установленных приложений.

|[.filename]#/var/db#
|Автоматически генерируемые системно-специфичные файлы баз данных, такие как база данных пакетов, и так далее
|===

=== Имена хостов

==== [.filename]#/etc/resolv.conf#

[.filename]#/etc/resolv.conf# определяет, как резолвер (resolver) FreeBSD получает доступ к Системе Доменных Имён (DNS).

Основные записи [.filename]#resolv.conf#: 

[.informaltable]
[cols="1,1", frame="none"]
|===

|`nameserver`
|IP адрес сервера имён. Сервера опрашиваются в порядке описания. Максимальное количество адресов - три.

|`search`
|Список доменов для поиска с помощью hostname lookup. Обычно определяется доменом, в котором находится компьютер.

|`domain`
|Домен, в котором находится компьютер.
|===

Типичный вид [.filename]#resolv.conf#:

[.programlisting]
....
search example.com
nameserver 147.11.1.11
nameserver 147.11.100.30
....

[NOTE]
====
Опции `search` и `domain` нельзя использовать совместно.
====

Если вы используете DHCP, man:dhclient[8] обычно перезаписывает [.filename]#resolv.conf# информацией, полученной от серверов DHCP.

==== [.filename]#/etc/hosts#

[.filename]#/etc/hosts# - простая текстовая база данных, напоминающая старый Интернет. Она работает совместно с DNS и NIS, сопоставляя доменные имена IP адресу. Отдельные компьютеры, соединённые с помощью локальной сети, могут быть записаны тут вместо man:named[8] сервера с целью упрощения. Кроме того, [.filename]#/etc/hosts# используется для записи IP адресов и соответствующих им доменов, избавляя от внешнего трафика, используемого для запросов к DNS серверам.

[.programlisting]
....
# $FreeBSD$
#
# Host Database
# This file should contain the addresses and aliases
# for local hosts that share this file.
# In the presence of the domain name service or NIS, this file may
# not be consulted at all; see /etc/nsswitch.conf for the resolution order.
#
#
::1                     localhost localhost.my.domain myname.my.domain
127.0.0.1               localhost localhost.my.domain myname.my.domain

#
# Imaginary network.
#10.0.0.2               myname.my.domain myname
#10.0.0.3               myfriend.my.domain myfriend
#
# According to RFC 1918, you can use the following IP networks for
# private nets which will never be connected to the Internet:
#
#       10.0.0.0        -   10.255.255.255
#       172.16.0.0      -   172.31.255.255
#       192.168.0.0     -   192.168.255.255
#
# In case you want to be able to connect to the Internet, you need
# real official assigned numbers.  PLEASE PLEASE PLEASE do not try
# to invent your own network numbers but instead get one from your
# network provider (if any) or from the Internet Registry (ftp to
# rs.internic.net, directory `/templates').
#
....

Формат [.filename]#/etc/hosts#:

[.programlisting]
....
[IP адрес в Интернете] [имя компьютера] [alias1] [alias2] ...
....

Например:

[.programlisting]
....
10.0.0.1 myRealHostname.example.com myRealHostname foobar1 foobar2
....

За дополнительной информацией обращайтесь к man:hosts[5].

=== Настройка лог файлов

==== [.filename]#syslog.conf#

[.filename]#syslog.conf# is является файлом конфигурации для man:syslogd[8]. В нём указываются, типы сообщений генерируемые `syslog`, и лог файлы, в которые они записываются.

[.programlisting]
....
# $FreeBSD$
#
#       Spaces ARE valid field separators in this file. However,
#       other *nix-like systems still insist on using tabs as field
#       separators. If you are sharing this file between systems, you
#       may want to use only tabs as field separators here.
#       Consult the syslog.conf(5) manual page.
*.err;kern.debug;auth.notice;mail.crit          /dev/console
*.notice;kern.debug;lpr.info;mail.crit;news.err /var/log/messages
security.*                                      /var/log/security
mail.info                                       /var/log/maillog
lpr.info                                        /var/log/lpd-errs
cron.*                                          /var/log/cron
*.err                                           root
*.notice;news.err                               root
*.alert                                         root
*.emerg                                         *
# uncomment this to log all writes to /dev/console to /var/log/console.log
#console.info                                   /var/log/console.log
# uncomment this to enable logging of all log messages to /var/log/all.log
#*.*                                            /var/log/all.log
# uncomment this to enable logging to a remote log host named loghost
#*.*                                            @loghost
# uncomment these if you're running inn
# news.crit                                     /var/log/news/news.crit
# news.err                                      /var/log/news/news.err
# news.notice                                   /var/log/news/news.notice
!startslip
*.*                                             /var/log/slip.log
!ppp
*.*                                             /var/log/ppp.log
....

За более полной информацией обратитесь к man:syslog.conf[5].

==== [.filename]#newsyslog.conf#

[.filename]#newsyslog.conf# - конфигурационный файл man:newsyslog[8], программы, обычно контролируемой man:cron[8]. man:newsyslog[8] определяет, когда лог-файлы нуждаются в архивировании и перегруппировке. [.filename]#logfile# перемещается в [.filename]#logfile.0#, [.filename]#logfile.0# перемещается в [.filename]#logfile.1#, и так далее. Другое именование получится при архивировании с помощью man:gzip[1]: [.filename]#logfile.0.gz#, [.filename]#logfile.1.gz#, и т.д.

[.filename]#newsyslog.conf# показывает, какие лог файлы должны быть проинспектированы, сколько их должно быть сохранено, и когда они должны быть пересмотрены. Лог файлы могут быть перегруппированы и/или заархивированы, когда они либо достигнут определённого размера, либо при достижении определённых даты/времени.

[.programlisting]
....
# configuration file for newsyslog
# $FreeBSD$
#
# filename          [owner:group]    mode count size when [ZB] [/pid_file] [sig_num]
/var/log/cron                           600  3     100  *     Z
/var/log/amd.log                        644  7     100  *     Z
/var/log/kerberos.log                   644  7     100  *     Z
/var/log/lpd-errs                       644  7     100  *     Z
/var/log/maillog                        644  7     *    @T00  Z
/var/log/sendmail.st                    644  10    *    168   B
/var/log/messages                       644  5     100  *     Z
/var/log/all.log                        600  7     *    @T00  Z
/var/log/slip.log                       600  3     100  *     Z
/var/log/ppp.log                        600  3     100  *     Z
/var/log/security                       600  10    100  *     Z
/var/log/wtmp                           644  3     *    @01T05 B
/var/log/daily.log                      640  7     *    @T00  Z
/var/log/weekly.log                     640  5     1    $W6D0 Z
/var/log/monthly.log                    640  12    *    $M1D0 Z
/var/log/console.log                    640  5     100  *     Z
....

За дополнительной информацией обращайтесь к man:newsyslog[8].

[[configtuning-sysctlconf]]
=== [.filename]#sysctl.conf#

[.filename]#sysctl.conf# очень похож на [.filename]#rc.conf#. Значения устанавливаются в виде `variable=value`. Указанные значения устанавливаются после перевода системы в многопользовательский режим. Однако не все переменные могут быть установлены в этом режиме.

Пример [.filename]#sysctl.conf#, настроенного для выключения протоколирования фатальных ошибок программ и разрешения Linux-программам определять, что они запускаются под FreeBSD:

[.programlisting]
....
kern.logsigexit=0       # Do not log fatal signal exits (e.g. sig 11)
compat.linux.osname=FreeBSD
compat.linux.osrelease=4.3-STABLE
....

[[configtuning-sysctl]]
== Настройка с помощью sysctl

man:sysctl[8] - это интерфейс, позволяющий вам вносить изменения в работающую систему FreeBSD. Эти изменения касаются многих опций стека TCP/IP и виртуальной памяти; опытный системный администратор может использовать их для существенного увеличения производительности. Более пяти тысяч системных переменных могут быть прочитаны и записаны с помощью man:sysctl[8].

По своей сути, man:sysctl[8] выполняет две функции: чтение и изменение настроек системы.

Для просмотра всех доступных для чтения переменных:

[source,bash]
....
% sysctl -a
....

Чтобы прочитать определённую переменную, например, `kern.maxproc`, введите:

[source,bash]
....
% sysctl kern.maxproc
kern.maxproc: 1044
....

Для присвоения значения переменной, используйте выражение вида _переменная_=_значение_:

[source,bash]
....
# sysctl kern.maxfiles=5000
kern.maxfiles: 2088 -> 5000
....

Изменяемые с помощью sysctl переменные обычно принимают значения либо строкового, либо целого, либо булевого типа. Переменные булевого типа могут принимать два значения (`1` (истина) и `0` (ложь)).

Если вы хотите устанавливать некоторые переменные автоматически при каждой загрузке компьютера, добавьте их в файл [.filename]#/etc/sysctl.conf#. За дополнительной информацией обращайтесь к странице справочника man:sysctl.conf[5] и к <<configtuning-sysctlconf>>.

[[sysctl-readonly]]
=== Переменные man:sysctl[8] только для чтения

В некоторых случаях желательно изменить переменные man:sysctl[8] только для чтения. Иногда другого способа решить проблему нет; при этом, результат может быть достигнут только на этапе начальной загрузки.

Например, на некоторых моделях лэптопов диапазон памяти устройства man:cardbus[4] не определяется и выдается приблизительно такая ошибка:

[source,bash]
....
cbb0: Could not map register memory
device_probe_and_attach: cbb0 attach returned 12
....

Ситуации, похожие на эту, требуют изменения некоторых значений man:sysctl[8], модификация которых запрещена. Для разрешения этой ситуации пользователь может поместить man:sysctl[8] "OID" в файл [.filename]#/boot/loader.conf#. Значения по умолчанию хранятся в файле [.filename]#/boot/defaults/loader.conf#.

Решение проблемы, приведенной выше, потребует помещения строки `hw.pci.allow_unsupported_io_range=1` в вышеупомянутый файл. Теперь man:cardbus[4] будет работать нормально.

[[configtuning-disk]]
== Оптимизация дисков

=== Переменные Sysctl

==== `vfs.vmiodirenable`

Значением переменной `vfs.vmiodirenable` может быть установлено в 0 (выключено) или 1 (включено); по умолчанию 1. Эта переменная отвечает за метод кэширования каталогов. Размер большинства каталогов невелик. Они могут поместиться в одном фрагменте (обычно 1K), и могут занимать ещё меньше места (обычно 512 байт) в кэше буфера. При отключении этой переменной (при установке значения 0) буфер прокэширует только заданное число каталогов даже если у вас много памяти. При включении (при установке значения 1) эта переменная sysctl позволит использовать страничное кэширование VM, делая доступным для кэширования каталогов весь объём памяти. Однако, минимальный объём памяти, используемой для кэширования каталогов стал равен объёму страницы (обычно 4 K) вместо 512 байт. Мы рекомендуем оставлять эту опцию включенной, если ваш компьютер исполняет программы, манипулирующие значительным количеством файлов. Примером таких программ могут быть кэширующие прокси-серверы, большие почтовые серверы и серверы новостей. Обычно включение этой опции не понижает производительности, однако лучше поэкспериментировать, чтобы узнать оптимальное значение для вашей машины.

==== `vfs.write_behind`

Переменная sysctl `vfs.write_behind` по умолчанию установлена в `1` (включено). Она указывает системе выполнять запись на носитель по кластерам, что обычно делается для больших файлов. Идея в том, чтобы избежать заполнения кэша неполными буферами, когда это не увеличивает производительность. Однако, это может заблокировать процессы и в некоторых случаях вам может понадобиться отключить этот параметр.

==== `vfs.hirunningspace`

Переменная sysctl `vfs.hirunningspace` определяет число запросов записи на диск, которые могут быть поставлены в очередь. Значение по умолчанию обычно подходит, но на компьютерах с большим количеством дисков вы можете увеличить его до четырех или пяти _мегабайт_. Учтите, что установка слишком большого значения (превышающего размер буфера записи) может привести к очень значительному падению общей производительности. Не делайте это значение произвольно большим! Большие значения могут привести к задержкам чтения, выполняемого в то же время

Есть много других переменных sysctl, относящихся к кэшированию в буфер и страничному кэшированию VM. Мы не рекомендуем изменять эти значения, поскольку система VM делает отличную работу по автоматической самонастройке.

==== `vm.swap_idle_enabled`

Переменная sysctl `vm.swap_idle_enabled` полезна в больших многопользовательских системах, где есть много пользователей, входящих и выходящих из системы, и множество ожидающих процессов. Такие системы обычно генерируют большое количество запросов на выделение памяти. Включение этой переменной и настройка задержки выгрузки (swapout hysteresis, в секундах) установкой переменных `vm.swap_idle_threshold1` и `vm.swap_idle_threshold2` позволит освобождать страницы памяти, занятые ожидающими процессами, более быстро, чем при нормальном алгоритме выгрузки. Это помогает даемону выгрузки страниц. Не включайте этот параметр, пока он на самом деле вам не понадобится, поскольку его действие в сущности заключается в более ранней выгрузке страниц из памяти; это повышает нагрузку на подкачку и диск. В малых системах эффект от включения этого параметра предсказуем, но в больших системах нагруженной на подкачкой этот параметр позволяет системе VM проще загружать и выгружать процессы из памяти.

==== `hw.ata.wc`

Во FreeBSD 4.3 кэширование записи на IDE диски было отключено. Это понижало производительность IDE дисков в тестах, но было необходимо для лучшей сохранности данных. Проблема состоит в том, что IDE диски неправильно указывают время завершения записи на диск. При включенном кэшировании IDE диски могут не только записать данные в неправильном порядке - при большой нагрузке на диск некоторые блоки могут задержаться до бесконечности. Сбой, или отключение питания могут могут стать причиной серьёзных повреждений в файловой системе. Поэтому для безопасности системы значение по умолчанию этого параметра было изменено. К сожалению, результатом этого стало столь значительная потеря производительности, что после выхода релиза значение этого параметра было возвращено в первоначальное состояние. Вам следует проверить значение переменной sysctl `hw.ata.wc` на вашей машине. Если кэширование выключено - вы можете включить его, установив значение переменной ядра, равное 1. Это должно быть сделано при помощи загрузчика при загрузке. Если вы сделаете это позже - изменения не будут иметь силы.

За более подробной информацией обращайтесь к man:ata[4].

==== `SCSI_DELAY` (`kern.cam.scsi_delay`)

Параметр настройки ядра `SCSI_DELAY` может использоваться для уменьшения времени загрузки системы. Значение по умолчанию велико и может составлять более `15` секунд в процессе загрузки. Уменьшение его до `5` секунд обычно работает (особенно с современными дисками). В новых версиях FreeBSD (5.0 и выше) должен использоваться параметр `kern.cam.scsi_delay`, настраиваемый во время загрузки. Этот параметр и параметр настройки ядра принимают значения в _миллисекундах_, а _не_ в _секундах_.

[[soft-updates]]
=== Soft Updates

Программа man:tunefs[8] используется для настройки файловой системы. Эта программа может принимать большое количество параметров, но мы рассмотрим лишь один из них - включение и выключение Soft Updates, что может быть достигнуто следующим образом:

[source,bash]
....
# tunefs -n enable /filesystem
# tunefs -n disable /filesystem
....

Нельзя изменять файловую систему с помощью man:tunefs[8] когда она смонтирована. Самое подходящее время для включения "Soft Updates" - перед монтированием разделов, в однопользовательском режиме.

Soft Updates существенно увеличивают скорость создания и удаления файлов путём использования кэширования. Мы рекомендуем использовать Soft Updates на всех ваших файловых системах. Однако у Soft Updates есть и обратные стороны: во-первых, Soft Updates гарантирует целостность файловой системы в случае сбоя, но может наблюдаться задержка в несколько секунд (или даже минуту!) перед записью на жесткий диск. Если система зависнет - вы можете потерять больше, чем, если бы вы не включили Soft Updates. Во-вторых, Soft Updates задерживает освобождение блоков файловой системы. Если ваша файловая система заполнена, выполнение значительного обновления, например, `make installworld`, может вызвать переполнение.

==== Дополнительная информация о Soft Updates

Есть два традиционных способа записи метаданных файловых систем на диск (пример метаданных: индексные дескрипторы и каталоги).

Исторически, поведение по умолчанию заключается в синхронном обновлении метаданных. Если каталог был изменен, система ждет, пока изменение не будет физически записано на диск. Содержимое файлов проходит через кэш и записывается на диск асинхронно. Преимущество этого способа в его надежности. При сбое во время обновления метаданные остаются в нормальном состоянии. Файл либо создается целиком, либо вообще не создается. Если блоки данных не были записаны в файл из буфера во время сбоя, man:fsck[8] сможет определить это и восстановить файловую систему, установив длину файла в 0. Кроме того, реализация этого способа проста и понятна. Недостаток в том, что обновление метаданных занимает много времени. Команда `rm -r`, например, последовательно удаляет все файлы в каталоге, и каждое изменение в каталоге (удаление файла) будет синхронно записано на диск. Сюда включаются обновления самого каталога, таблицы индексных дескрипторов, и возможно блоков, занятых файлом. Те же соглашения работают при распаковке больших иерархий (`tar -x`).

Другой вариант это асинхронное обновление метаданных. Это поведение по умолчанию для Linux/ext2fs и *BSD ufs с параметром `mount -o async`. Все обновления метаданных просто пропускаются через кэш буфера, как и содержимое файлов. Преимущество этой реализации в том, что нет необходимости ждать каждый раз, пока метаданные будут записаны на диск, поэтому все операции с большим объемом обновления метаданных будут происходить гораздо быстрее, чем при синхронном обновлении. Кроме того, реализация все еще проста и понятна, поэтому риск появления ошибок в коде невелик. Недостаток в том, что нет никаких гарантий исправности файловой системы. Если во время обновления большого объема метаданных произойдет сбой (например, отключение питания, или нажатие кнопки reset), файловая система останется в непредсказуемом состоянии. Нет возможности определить состояние файловой системы после такого сбоя; блоки данных файла могут быть уже записаны на диск, а обновления таблицы индексных дескрипторов нет. Невозможно реализовать `fsck`, которая могла бы исправить получившийся хаос (поскольку необходимой информации нет на диске). Если файловая система была уничтожена во время восстановления, единственный способ восстановления - запустить man:newfs[8] и воспользоваться резервной копией.

Обычное решение этой проблемы состояло в реализации _протоколировании проблемной области (dirty region logging)_, известном как _журналирование_, хотя этот термин использовался неправильно и порой также применялся к другим формам протоколирования транзакций. Обновление метаданных как и прежде происходит синхронно, но в отдельную область диска. Позже они перемещаются туда, где должны быть. Поскольку область протоколирования это небольшая, последовательная область диска, головкам жесткого диска не приходится перемещаться на большие расстояния даже во время значительных обновлений, поэтому такой способ быстрее, чем синхронные обновления. Кроме того, сложность реализации довольно ограничена, поэтому риск внесения ошибок невелик. Недостаток в том, что все обновления метаданных записываются дважды (один раз в область протоколирования и один раз окончательно), поэтому при обычной работе производительность может понизиться. С другой стороны, в случае сбоя все незаконченные действия с метаданными могут быть быстро отменены, или завершены после загрузки системы, поэтому система после сбоя загружается быстрее.

Kirk McKusick, разработчик Berkeley FFS, решил эту проблему с помощью Soft Updates: все незавершенные обновления метаданных находятся в памяти и записываются на диск в упорядоченном виде ("упорядоченное обновления метаданных"). При значительных обновлениях метаданных более поздние обновления "присоединяются" к предыдущим, если они все еще находятся в памяти и еще не записаны на диск. Поэтому все операции, скажем, над каталогом, обычно выполняются в памяти перед записью обновления на диск (блоки данных сортируются в соответствии с их положением, так что они не будут записаны на диск до метаданных. При крахе операционной системы выполняется "откат": считается, что все операции, не записанные на диск, никогда не происходили. Файловая система находится в том состоянии, в котором она была за 30-60 секунд до сбоя. Используемый алгоритм гарантирует, что все используемые ресурсы маркированы соответствующим образом в своих областях: блоки и индексные дескрипторы. После сбоя могут остаться только ошибки выделения ресурсов, они помечаются как "используемые", хотя на самом деле "свободны". man:fsck[8] разбирается в ситуации и освобождает более не используемые ресурсы. После сбоя система может быть безопасно смонтирована с опцией `mount -f`. Для освобождения ресурсов, которые могут не использоваться, в дальнейшем потребуется запустить man:fsck[8]. Эта идея лежит в основе _background (фоновая) fsck_: во время запуска системы записывается только _снимок_ файловой системы. Все системы могут быть смонтированы в "грязном" состоянии, и система загружается в многопользовательский режим. Затем, фоновые `fsck` ставятся в очередь для всех систем, где это требуется, чтобы освободить неиспользуемые ресурсы. (Файловые системы, где не используются Soft Updates, все еще требуют запуска `fsck` в обычном режиме).

Преимущество этого способа в том, что обновления метаданных происходят почти так же быстро, как при асинхронных обновлениях (т.е. быстрее, чем при _журналировании_, когда метаданные записываются дважды). Недостаток в сложности кода (подразумевающим больший риск появления ошибок в области, где вероятность потери данных пользователя особенно высока) и в более высоких требованиях к объему памяти. К тому же могут возникнуть некоторые странные на первый взгляд ситуации. После сбоя состояние файловой системы несколько более "старое". В ситуации, когда стандартный способ синхронизации оставит несколько файлов нулевой длины после выполнения `fsck`, в файловой системе с Soft Updates их не останется вовсе, поскольку ни метаданные, ни содержимое файлов не были записаны на диск. Дисковое пространство не будет освобождено пока обновления не будут записаны на диск, что может занять некоторое время после выполнения `rm`. Это может повлечь проблемы при установке большого количества файлов на файловую систему, где не хватает места для помещения всех файлов дважды.

[[configtuning-kernel-limits]]
== Изменение ограничений, накладываемых ядром

[[file-process-limits]]
=== Ограничения на Файлы/Процессы

[[kern-maxfiles]]
==== `kern.maxfiles`

Значение `kern.maxfiles` может быть увеличено или уменьшено в зависимости от потребностей вашей системы. Эта переменная определяет максимальное число дескрипторов файлов. Когда таблица дескрипторов файлов полна, в очереди системных сообщений появится сообщение `file: table is full`. Это сообщение может быть прочитано с помощью команды `dmesg`.

Каждый открытый файл, сокет или буфер использует дескриптор файла. Широкомасштабному серверу может понадобиться много тысяч дескрипторов файлов, в зависимости от количества программ, одновременно выполняемых на сервере.

Стандартное значение `kern.maxfile` определяется переменной `maxusers` в вашем файле конфигурации ядра. Значение `kern.maxfiles` увеличивается пропорционально значению `maxusers`. При компилировании ядра, нужно установить эту переменную согласно потребностям вашей системы. Исходя из значения этой переменной, ядро устанавливает значения большинства предопределённых переменных. Даже если предполагается, что к компьютеру не будут одновременно подсоединяться 256 пользователей, требуемые ресурсы могут быть такими же, как у крупномасштабного сервера.

Система автоматически настроит `maxusers`, если вы явно установите его в `0`. Если вы желаете выставить значение самостоятельно, то задайте `maxusers` по меньшей мере равным 4, особенно если вы используйте X Window System или компилируйте программное обеспечение. Причина в том, что самая значимая таблица, устанавливаемая `maxusers` - это максимальное количество процессов, которая устанавливается равным `20 + 16 * maxusers`, и поэтому, если вы установите `maxusers` в 1, то вы сможете иметь только 36 одновременных процессов, включая 18 или около того, что система запустит во время загрузки и 15 или около того, что вы создадите при запуске X Window System. Даже простая задача, как чтение страницы справочника породит 9 процессов для фильтрации, декомпрессии и её просмотра. Установка `maxusers` в 64 позволит иметь вам до 1044 одновременных процессов, чего должно быть достаточно примерно для всех использований. Если, тем не менее, вы увидите пугающую ошибку  при попытке запуска другой программы, или вы используйте сервер с большим количеством одновременных пользователей (как `ftp.FreeBSD.org`), то вы всегда можете увеличить значение и пересобрать систему.

[NOTE]
====
`maxusers` _не_ ограничивает количество пользователей, которые могут заходить на вашу машину. Оно просто устанавливает различные размеры таблиц в разумные значения, учитывая максимальное количество пользователей, вы вероятно будете иметь на вашей системе и как много процессов каждый из них сможет запускать. Ключевое слово, которое ограничивает количество одновременных удаленных входов и терминальных X окон - это crossref:kernelconfig[kernelconfig-ptys,`pseudo-device pty 16`]. С FreeBSD 5.X вам не надо беспокоиться об этом значении, так как man:pty[4] драйвер является "автоматически клонирующим"; вы просто используйте `device pty` в вашем конфигурационном файле.
====

==== `kern.ipc.somaxconn`

Переменная sysctl `kern.ipc.somaxconn` ограничивает размер очереди для приема новых TCP соединений. Значение по умолчанию `128` слишком мало для надежной обработки новых соединений для нагруженного web сервера. Для такого сервера рекомендуется увеличить это значение до `1024` или выше. Даемон сервиса может сам ограничивать очередь приема новых соединений (например, man:sendmail[8], или Apache), но обычно в файле настройки даемона есть директива для настройки длины очереди. Более длинная очередь также помогает избежать атак Denial of Service ().

[[nmbclusters]]
=== Сетевые Ограничения

Опция ядра `NMBCLUSTERS` обуславливает количество Mbuf, доступных на машине. На сервере с большим трафиком и маленьким Mbuf производительность будет пониженной. Каждый кластер представлен двумя килобайтами памяти, поэтому значение 1024 означает 2 мегабайта памяти ядра, зарезервированной для сетевых буферов. Для определения оптимального значения необходимо провести простые вычисления. Если у вас веб сервер, который может обслуживать 1000 одновременных соединений, и каждое соединение "съедает" 16 K буфера приема и 16 K буфера отправки, вам потребуется 32 MB памяти под буферы. Хорошее правило - умножение этого значения на 2, 2x32 MB / 2 KB = 64 MB / 2 kB = 32768. Мы рекомендуем значения между 4096 и 32768 для машин с большим объемом памяти. Не указывайте произвольно большое значение параметра, это может привести к падению системы при загрузке. Используйте man:netstat[1] с опцией `-m` для определения количества используемых сетевых кластеров.

Для настройки в процессе загрузки используйте в loader переменную `kern.ipc.nmbclusters`. Только в старых версиях FreeBSD потребуется пересобрать ядро (man:config[8]) с измененным параметром `NMBCLUSTERS`.

Для нагруженных серверов, интенсивно использующих системный вызов man:sendfile[2], может потребоваться увеличения буферов man:sendfile[2] с помощью параметра конфигурации ядра `NSFBUFS`, или изменения значения путем установки переменной в [.filename]#/boot/loader.conf# (обратитесь к man:loader[8] за подробностями). Общий признак того, что параметр требуется изменить - состояние процессов `sfbufa`. Переменная sysctl `kern.ipc.nsfbufs` установлена только для чтения. Этот параметр увеличивается вместе с `kern.maxusers`, хотя может потребоваться увеличить его отдельно.

[IMPORTANT]
====
Даже если сокет помечен как неблокирующий, вызов man:sendfile[2] на неблокирующем сокете может вызвать блокирование man:sendfile[2], пока не станет доступным достаточное количество `struct sf_buf`.
====

==== `net.inet.ip.portrange.*`

Переменные sysctl `net.inet.ip.portrange.*` контролируют диапазоны номеров портов, автоматически привязываемых к TCP и UDP сокетам. Есть три диапазона: нижний диапазон, диапазон по умолчанию и верхний диапазон. Большинство сетевых программ используют диапазон по умолчанию, контролируемый `net.inet.ip.portrange.first` и `net.inet.ip.portrange.last`, установленными соответственно в 1024 и 5000. Диапазоны портов привязки используются для исходящих соединений и при некоторых условиях портов может не хватить. Это чаще всего происходит на сильно загруженном прокси сервере. Диапазон портов не становится проблемой при работе серверов, которые обрабатывают в основном входящие соединения, или с небольшим количеством исходящих соединений, например mail relay. Для ситуаций, когда возможен недостаток портов, рекомендуется немного увеличить `net.inet.ip.portrange.last`. Может подойти значение `10000`, `20000`, или `30000`. Учтите также возможное влияние брандмауэра при изменении диапазона портов. Некоторые могут блокировать большие диапазоны портов (обычно с небольшими номерами) и вынуждают использовать более высокие диапазоны для исходящих соединений. По этой причине не рекомендуется уменьшать значение `net.inet.ip.portrange.first`.

==== TCP Bandwidth Delay Product

TCP Bandwidth Delay Product Limiting похоже на TCP/Vegas в NetBSD. Оно может быть включено установкой переменной sysctl `net.inet.tcp.inflight.enable` в `1`. Система попытается вычислить задержку пакетов для каждого соединения и ограничить объем данных в очереди сети до значения, требуемого для поддержания оптимальной пропускной способности.

Эта возможность полезна при передаче данных через модемы, Gigabit Ethernet, или даже через высокоскоростные WAN соединения (или любые другие соединения с большой задержкой передачи), особенно если вы также используете изменение размера окна или настроили большое окно передачи. Если вы включили этот параметр, убедитесь также, что переменная `net.inet.tcp.inflight.debug` установлена в `0` (отладка выключена), а для использования в реальных задачах может понадобиться установка переменной `net.inet.tcp.inflight.min` к значению как минимум `6144`. Но учтите, что установка большого значения этой переменной может фактически отключить ограничение в зависимости от вида соединения. Ограничение уменьшает количество данных на определенном маршруте и управляет очередью пакетов, как и уменьшает общее количество данных в очереди локального интерфейса хоста. С меньшим количеством пакетов в очереди двусторонние интерактивные соединения, особенно на медленных линиях, могут проходить быстрее. Но имейте ввиду, что эта функция работает только при передаче данных (передача данных / сторона сервера). Она не работает при получении данных (загрузке).

Изменение значения переменной `net.inet.tcp.inflight.stab` _не_ рекомендуется. Этот параметр по умолчанию равен 20, что означает добавление 2 пакетов к вычислению задержки передачи. Дополнительное окно требуется для стабилизации алгоритма и улучшения ответной реакции на изменение условий, но также приводит к большему времени ping на медленных соединениях (задержка все же гораздо меньше, чем без алгоритма inflight). Вы можете попробовать уменьшить этот параметр до 15, 10 или 5; а также уменьшить `net.inet.tcp.inflight.min` (например, до 3500) для получения желаемого эффекта. Уменьшение значений этих параметров может использоваться только как крайняя мера.

=== Виртуальная память

==== `kern.maxvnodes`

Файлы и каталоги в ядре представлены при помощи vnode (виртуальных узлов). Увеличение их числа может помочь уменьшить нагрузку на дисковую подсистему. Как правило, специальной настройки это значение не требует, однако, в некоторых случаях дисковая активность является узким местом, и система исчерпывает таблицу vnode, значение этой переменной следует увеличить. При этом необходимо оценить объем неактивной и свободной памяти.

Текущее количество использованных vnode можно посмотреть при помощи команды:

[.programlisting]
....
#  sysctl vfs.numvnodes
vfs.numvnodes: 91349
....

Максимальное количество vnode, доступных системе:

[.programlisting]
....
#  sysctl kern.maxvnodes
kern.maxvnodes: 100000
....

Если количество использованных vnode близко к максимуму, значение переменной `kern.maxvnodes` следует увеличить на 1000. Следите за динамикой изменения `vfs.numvnodes`. Если оно увеличивается, приближаясь к вновь установленному максимуму, процесс следует повторить. Изменение в распределении памяти должно быть видно в выводе утилиты man:top[1]: больше памяти перейдет в разряд активной.

[[adding-swap-space]]
== Увеличение объема подкачки

Вне зависимости от того, что вы планировали, иногда система ведет себя неожиданно. Если вам потребовался дополнительный объем подкачки, его довольно просто добавить. Есть три способа увеличения объема подкачки: добавить новый жесткий диск, включить подкачку по NFS, или создать файл подкачки на существующем разделе.

За информацией о криптовании раздела подкачки обращайтесь к crossref:disks[swap-encrypting,Шифрование области подкачки] данного Руководства.

[[new-drive-swap]]
=== Подкачка на новом жестком диске

Лучший способ добавить подкачку, конечно, использовать еще один жесткий диск. Вы можете сделать это в любой момент. Если такой способ подходит, прочтите еще раз информацию по пространству подкачки в <<configtuning-initial>> Руководства, где рассказывается о наилучшем способе организации раздела подкачки.

[[nfs-swap]]
=== Подкачка через NFS

Подкачка через NFS рекомендуется только в том случае, если в системе отсутствует жесткий диск; подкачка через NFS ограничена скоростью сетевого подключения и к тому же дополнительно нагружает NFS сервер.

[[create-swapfile]]
=== Файлы подкачки

Вы можете создать файл определенного размера и использовать его как файл подкачки. В нашем примере будет использован файл [.filename]#/usr/swap0# размером 64MB. Конечно, вы можете использовать любое имя.

.Создание файла подкачки в FreeBSD
[example]
====
. Убедитесь, что в файле настройки ядра присутствует драйвер виртуального диска (man:md[4]). Он есть в ядре [.filename]#GENERIC#.
+
[.programlisting]
....
device   md   # Memory "disks"
....

. Создайте файл подкачки ([.filename]#/usr/swap0#):
+
[source,bash]
....
# dd if=/dev/zero of=/usr/swap0 bs=1024k count=64
....

. Установите подходящие права на ([.filename]#/usr/swap0#):
+
[source,bash]
....
# chmod 0600 /usr/swap0
....

. Включите файл подкачки в [.filename]#/etc/rc.conf#:
+
[.programlisting]
....
swapfile="/usr/swap0"   # Set to name of swapfile if aux swapfile desired.
....

. Перегрузите компьютер или для включения подкачки прямо сейчас введите:
+
[source,bash]
....
# mdconfig -a -t vnode -f /usr/swap0 -u 0  swapon /dev/md0
....

====

[[acpi-overview]]
== Управление питанием и ресурсами

Очень важно использовать аппаратные ресурсы эффективно. До того, как появился ACPI, управление потреблением питания и температурными характеристиками системы было очень сложной для операционной системы задачей. Аппаратное обеспечение контролировалось одним из видов встроенного интерфейса BIOS, таким как: _Plug and Play BIOS (PNPBIOS)_, _Advanced Power Management (APM)_ и так далее. Управление питанием и ресурсами это один из ключевых компонентов современной операционной системы. Например, вам может потребоваться, чтобы операционная система следила за температурными ограничениями и возможно, предупреждала при неожиданном росте температуры.

В этом разделе Руководства FreeBSD, мы предоставим исчерпывающую информацию о ACPI. В конце раздела есть ссылки для дальнейшего чтения.

[[acpi-intro]]
=== Что такое ACPI?

Advanced Configuration and Power Interface (ACPI) это стандарт, написанный объединением поставщиков в целях предоставления стандартного интерфейса для аппаратных ресурсов и управления питанием (отсюда и название). Это ключевой элемент _Operating System-directed configuration and Power Management_, т.е.: он предоставляет операционной системе (OS) больше контроля и более универсален. Современные системы вышли за пределы ограничений существующих Plug and Play интерфейсов до появления ACPI. ACPI это прямой наследник APM (Advanced Power Management).

[[acpi-old-spec]]
=== Недостатки Advanced Power Management (APM)

Средства _Advanced Power Management (APM)_ управляют энергопотреблением системы в зависимости от нагрузки. APM BIOS предоставляется поставщиком системы и специфичен для данной аппаратной платформы. Драйвер APM в OS обеспечивает доступ к _APM Software Interface_, который позволяет управлять уровнями потребления питания.

В APM имеется четыре основных проблемы. Во-первых, управление энергопотреблением осуществляется через зависимый от поставщика BIOS, и OS ничего не знает нем. Один пример: когда пользователь устанавливает время ожидания для жесткого диска в APM BIOS, и это время истекает, BIOS останавливает жесткий диск без согласования с OS. Во-вторых, алгоритм APM встроен в BIOS, и все действия происходят вне контроля OS. Это означает, что пользователи могут решить проблемы с APM BIOS только путем перепрошивки его ROM; это очень опасная процедура, и если она завершится неудачно, система может оказаться в невосстановимом состоянии. В-третьих, реализация технологии APM зависит от поставщика, что означает дублирование усилий и если в BIOS одного из поставщиков будет найдена и исправлена ошибка, ее могли не исправить другие поставщики. Наконец, объем APM BIOS недостаточно велик для реализации сложной политики управления питанием, или такой политики, которая может хорошо адаптироваться к потребностям компьютера.

_Plug and Play BIOS (PNPBIOS)_ был неудобен во многих ситуациях. PNPBIOS это 16-битная технология, поэтому OS требовалось использовать 16-битную эмуляцию для "взаимодействия" с методами PNPBIOS.

FreeBSD драйвер APM документирован в странице справочника man:apm[4].

[[acpi-config]]
=== Настройка ACPI

man:loader[8] загружает драйвер [.filename]#acpi.ko# по умолчанию, его _не_ надо встраивать в ядро. Причина в том, что с модулями проще работать, например переключиться на другой [.filename]#acpi.ko# без пересборки ядра. Преимущество в упрощении тестирования. Другая причина в том, что запуск ACPI после старта системы не очень полезен и при некоторых условиях может приводить к краху. Если вы сомневаетесь, отключите ACPI совсем. Драйвер не должен и не может быть выгружен, поскольку системная шина используется для различных взаимодействий оборудования. ACPI может быть выключен с помощью утилиты man:acpiconf[8]. Фактически большинство взаимодействий с ACPI может быть выполнено через man:acpiconf[8]. В основном это означает, что если в выводе man:dmesg[8] есть что-то об ACPI, он скорее всего работает.

[NOTE]
====
ACPI и APM не могут сосуществовать и должны использоваться раздельно. Каждый из них прервет загрузку, если обнаружит загруженный драйвер другого.
====

В простейшей форме, ACPI может использоваться для перевода системы в спящий режим с помощью man:acpiconf[8], с флагом `-s` и параметром `1-5`. Большинству пользователей нужен только параметр `1`. Параметр `5` сделает "мягкое" завершение работы, так же как и:

[source,bash]
....
# halt -p
....

Доступны и другие параметры. Обратитесь к странице справочника man:acpiconf[8] за дополнительной информацией.

[[ACPI-debug]]
== Использование и отладка FreeBSD ACPI

ACPI это фундаментально новый способ обнаружения устройств, управления энергопотреблением и предоставления стандартизированного доступа к различному оборудованию, ранее управлявшемуся BIOS. Был достигнут определенный прогресс в приспособлении ACPI к работе со всеми системами, но все еще встречаются ошибки в байткоде _ACPI Machine Language_ (AML) некоторых материнских плат, незавершенные участки кода в подсистемах ядра FreeBSD и ошибки в интерпретаторе Intel(R) ACPI-CA.

Этот раздел предназначен для того, чтобы упростить ваше содействие разработчикам FreeBSD ACPI в определении причин наблюдаемых вами проблем, выполнении отладки и выработке решения. Спасибо за помощь и надеемся, что мы сможем помочь в решении проблем вашей системы.

[[ACPI-submitdebug]]
=== Отправка отладочной информации

[NOTE]
====
Перед отправкой сообщения об ошибке убедитесь, что у вас последняя версия BIOS, и, если доступна, последняя версия firmware встроенного контроллера.
====

Те из вас, кто желает составить сообщение о проблеме прямо сейчас, могут воспользоваться адресом link:mailto:freebsd-acpi@FreeBSD.org[ freebsd-acpi@FreeBSD.org], отправив на него следующую информацию:

* Описание неправильного поведения, включая тип системы, модель и все, что приводит к появлению ошибки. Кроме того, сообщите настолько точно, насколько возможно, когда появилась ошибка, если ранее вы ее не видели.
* Вывод man:dmesg[8] после "boot ``-v``", включая все сообщения, появившиеся при изучении ошибки.
* Вывод man:dmesg[8] после "boot ``-v``" с выключенным ACPI, если его отключение помогает решить проблему.
* Вывод `sysctl hw.acpi`. Это также хороший способ получения списка возможностей системы.
* URL где можно найти ваш _ACPI Source Language_ (ASL). _Не_ отправляйте ASL непосредственно в список рассылки, поскольку он может быть очень большим. Копия ASL может быть создана командой:
+
[source,bash]
....
# acpidump -t -d  name-system.asl
....
+ 
(Замените вашим логином [.filename]#name# и производителем/моделью [.filename]#system#. Пример: [.filename]#njl-FooCo6000.asl#)

Большинство разработчиков читают {freebsd-current}, но для уверенности, что проблему увидят, отправьте ее в {freebsd-acpi}. Будьте терпеливы, все мы заняты полный рабочий день где-то еще. Если ваше сообщение не заметили сразу, мы возможно попросим вас отправить PR (сообщение о проблеме) через man:send-pr[1]. При вводе PR, включайте ту же информацию, что запрошена выше. Это поможет нам отследить проблему и решить ее. Не отправляйте PR без предварительной отправки письма в {freebsd-acpi}, поскольку мы используем PR в качестве напоминаний о существующих проблемах, а не как механизм сообщений об ошибках. Вероятно, о вашей проблеме кто-то уже сообщал ранее.

[[ACPI-background]]
=== Общие сведения

ACPI представлен во всех современных компьютерах, соответствующих архитектурам ia32 (x86), ia64 (Itanium) и amd64 (AMD). Полный стандарт включает множество возможностей, в том числе управление производительностью CPU, уровнем питания, температурой, различными системами аккумуляторов, встроенными контроллерами и опросом шины. В большинстве систем стандарт реализован не полностью. Например, настольные системы обычно реализуют только опрос шины, а портативные компьютеры кроме того могут поддерживать управление охлаждением и энергопотреблением. Они также поддерживают приостановку и последующий запуск системы различного уровня сложности.

ACPI-совместимые системы состоят из различных компонентов. Производители BIOS и чипсетов предоставляют различные жестко заданные таблицы, (например, FADT), которые определяют функции вроде карты APIC (используется для SMP), регистры настройки и простые значения параметров. Кроме того, предоставляется таблица байткода (_Differentiated System Description Table_, DSDT), определяющая древоподобное пространство имен устройств и методов.

Драйвер ACPI должен прочесть заданные таблицы, реализовать интерпретатор для байткода, модифицировать драйвера устройств и ядро для приема информации от подсистемы ACPI. Для FreeBSD Intel(R) предоставила интерпретатор (ACPI-CA), тот же что для Linux и NetBSD. Исходный код ACPI-CA находится в каталоге [.filename]#src/sys/contrib/dev/acpica#. Код для приспособления ACPI-CA к работе в FreeBSD, находится в [.filename]#src/sys/dev/acpica/Osd#. Наконец, драйвера, реализующие различные ACPI устройства, находятся в [.filename]#src/sys/dev/acpica#.

[[ACPI-comprob]]
=== Часто встречающиеся проблемы

Для правильной работы ACPI все ее части должны работать правильно. Вот некоторые часто встречающиеся проблемы, в порядке частоты появления, и некоторые обходные пути или исправления.

==== Проблемы с мышью

В некоторых случаях при возобновлении работы после приостановки перестает работать мышь. Известным решением проблемы является добавление строки `hint.psm.0.flags="0x3000"` в файл [.filename]#/boot/loader.conf#. Если это не помогло, стоит сообщить о проблеме, как описано выше.

==== Приостановка/возобновление работы

ACPI поддерживает три состояния приостановки в RAM (STR), `S1`-`S3`, и одно состояние приостановки на диск (`STD`), называемое `S4`. `S5` это "мягкое выключение" и это нормальное состояние системы, когда она подключена к сети, но не включена. `S4` может быть реализован двумя различными путями. ``S4``BIOS это BIOS-поддерживаемая приостановка на диск. ``S4``OS реализуется полностью операционной системой.

Начните с проверки переменных `sysctl hw.acpi`, относящихся к приостановке (suspend). Вот результат для Thinkpad:

[source,bash]
....
hw.acpi.supported_sleep_state: S3 S4 S5
hw.acpi.s4bios: 0
....

Это означает, что мы можем использовать `acpiconf -s` для тестирования `S3`, ``S4``OS, и `S5`. Если `s4bios` был единицей (`1`), это означает поддержку ``S4``BIOS вместо ``S4``OS.

При тестировании приостановки/возобновления работы, начните с `S1`, если этот режим поддерживается. Это состояние скорее всего поддерживается, поскольку не требует слишком серьезной поддержки со стороны драйвера. Никто не реализовал `S2`, который похож на `S1`. Следующий режим для тестирования это `S3`. Это наиболее глубокое STR состояние, оно требует существенной поддержки со стороны драйвера, чтобы правильно реинициализировать оборудование. Если у вас возникли проблемы при выходе из этого состояния, отправьте письмо в рассылку {freebsd-acpi}, но не ждите, что проблема будет обязательно решена, поскольку существует множество драйверов/оборудования, нуждающихся в дальнейшем тестировании и разработке.

Для изоляции проблемы удалите из ядра столько драйверов, сколько возможно. Если это работает, вы можете выяснить, какой драйвер вызывает проблему путем загрузки драйверов до тех пор, пока опять не произойдет сбой. Обычно бинарные драйвера, такие как [.filename]#nvidia.ko#, драйвера дисплея X11 и USB вызывают большинство проблем, а драйвера Ethernet интерфейсов как правило работают отлично. Если вы можете нормально загрузить/выгрузить драйвера, автоматизируйте этот процесс, поместив соответствующие команды в [.filename]#/etc/rc.suspend# и [.filename]#/etc/rc.resume#. Это закомментированные примеры выгрузки и загрузки драйверов. Попробуйте установить параметр `hw.acpi.reset_video` в нуль (`0`), если ваш дисплей не включается после возобновления работы. Попробуйте установить большие или меньшие значения для `hw.acpi.sleep_delay`, чтобы проверить, поможет ли это.

Другой способ, который можно попробовать, это запуск последнего дистрибутива Linux с поддержкой ACPI и тестирование поддержки остановки/возобновления работы на том же оборудовании. Если она работает на Linux, проблема скорее всего в драйверах FreeBSD и поиск драйвера, вызывающего проблему, поможет разрешить ситуацию. Имейте ввиду, что разработчики ACPI обычно не поддерживают другие драйверы (звук, ATA, и т.п.), так что все результаты работы по поиску проблемы возможно необходимо отправить в список рассылки {freebsd-current} и человеку, поддерживающему драйвер. Если вы решитесь заняться отладкой, поместите соответствующий код (man:printf[3]) в вызывающий проблему драйвер для обнаружения места, где прерывается функция восстановления.

Наконец, попробуйте отключить ACPI и включить APM. Если приостановка/возобновление работает с APM, вам возможно лучше подойдет APM, особенно на старом оборудовании (до 2000). Включение корректной поддержки ACPI поставщиками оборудования требует времени и вероятно в старом оборудовании поддержка ACPI в BIOS была некорректна.

==== Система останавливается (временно или постоянно)

Большинство систем останавливаются в результате потери прерываний или "шторма" прерываний. В чипсетах существует много проблем, связанных с тем, как BIOS настраивает прерывания перед загрузкой, правильностью таблицы APIC (MADT), и маршрутизации _System Control Interrupt_ (SCI).

"Шторм" прерываний может быть обнаружен по потерянным прерываниям путем проверки вывода строки с `acpi0` команды `vmstat -i`. Если счетчик увеличивается более, чем несколько раз в секунду, это "шторм" прерываний. Если система останавливается, попробуйте войти в DDB (kbd:[CTRL+ALT+ESC] на консоли) и ввести `show interrupts`.

Наиболее надежный способ избавиться от проблемы с прерываниями, это отключение поддержки APIC с помощью параметра [.filename]#loader.conf#`hint.apic.0.disabled="1"`.

==== Паника

Паника, связанная с ACPI, случается довольно редко и имеет наибольший приоритет исправления. Первый шаг это изоляция действий, приводящих к панике (если это возможно) и получение отладки. Следуйте инструкции по включению `options DDB` и настройке последовательной консоли (смотрите crossref:serialcomms[serialconsole-ddb,Вход в отладчик DDB с последовательной линии]) или настройке раздела man:dump[8]. Вы можете получить отладочную информацию DDB с помощью `tr`. Если вы записываете отладку вручную, убедитесь, что переписали как минимум пять (5) строк снизу и пять (5) строк сверху.

Затем попробуйте изолировать проблему, загрузившись с выключенным ACPI. Если это работает, вы можете изолировать подсистему ACPI, используя различные параметры `debug.acpi.disable`. Обратитесь к странице справочника man:acpi[4] за примерами.

==== Система включается после приостановки или завершения работы

Во-первых, попробуйте установить в man:loader.conf[5] параметр `hw.acpi.disable_on_poweroff="0"`. Это предотвращает отключение различных событий в ACPI во время завершения работы. В некоторых системах этот параметр необходимо установить в `1` (по умолчанию) по тем же причинам. Обычно это решает проблему, если система неожиданно включается после приостановки или отключения питания.

==== Другие проблемы

Если вы наблюдаете другие проблемы с ACPI (работа с внешним оборудованием, проблемы с обнаружением устройств, и т.д.), отправьте описание проблемы в список рассылки; однако, некоторые из этих проблем могут относиться к незавершенным частям подсистемы ACPI, поэтому может потребоваться время на их реализацию. Будьте терпеливы, и подготовьтесь к тестированию исправлений, которые мы можем вам выслать.

[[ACPI-aslanddump]]
=== ASL, `acpidump`, и IASL

Наиболее часто встречается проблема, связанная с предоставлением поставщиками BIOS некорректного (или полностью ошибочного!) байткода. Это обычно проявляется появлением консольных сообщений ядра, подобных этому:

[source,bash]
....
ACPI-1287: *** Error: Method execution failed [\\_SB_.PCI0.LPC0.FIGD._STA] \\
       (Node 0xc3f6d160), AE_NOT_FOUND
....

Зачастую вы можете разрешить эти проблемы путем обновления BIOS до последней ревизии. Большинство консольных сообщений безвредны, но если существуют другие проблемы, такие как не работающий статус батареи, возможно существуют проблемы в AML. Байткод, известный как AML, компилируется из исходного текста на языке ASL. AML находится в таблице, известной как DSDT. Для получения копии ASL, используйте man:acpidump[8]. Вы можете использовать оба параметра `-t` (показывать содержимое постоянных таблиц) и `-d` (дизассемблировать AML в ASL). Обратитесь к разделу <<ACPI-submitdebug,Отправка отладочной информации>> за примером синтаксиса.

Простейшая первая проверка, которую вы можете провести, это перекомпиляция ASL для поиска ошибок. Предупреждения обычно могут быть проигнорированы, но ошибки обычно не позволяют ACPI работать правильно. Для перекомпиляции ASL, выполните следующую команду:

[source,bash]
....
# iasl your.asl
....

[[ACPI-fixasl]]
=== Исправление ASL

В дальней перспективе, наша задача состоит в том, чтобы обеспечить поддержку ACPI практически для каждой системы без вмешательства пользователя. Однако, на данный момент мы все еще разрабатываем обходные пути для ошибок, которые часто делают поставщики BIOS. Интерпретатор Microsoft(R) ([.filename]#acpi.sys# и [.filename]#acpiec.sys#) не занимается проверкой четкости соблюдения стандартов, поэтому многие поставщики BIOS, проверяющие ACPI только под Windows(R), никогда не исправляют ASL. Мы надеемся продолжать обнаружение и документацию нестандартных поведений, позволяемых интерпретатором Microsoft(R), и воспроизводить их, чтобы FreeBSD могла работать без необходимости исправления ASL пользователями. В качестве обходного пути для обнаружения неправильного поведения, вы можете исправить ASL вручную. Если исправления будут работать, пожалуйста отправьте man:diff[1] между старым и новым ASL, чтобы мы могли реализовать обходной путь для неправильного поведения ACPI-CA, чтобы исправление вручную больше не требовалось.

Вот список наиболее часто встречающихся проблем, их причин и способы исправления:

==== OS зависимости

Некоторые AML предполагают, что мир состоит из различных версий Windows(R). Вы можете настроить FreeBSD, чтобы она сообщала любое другое имя OS и посмотреть, исправит ли это имеющуюся проблему. Простой способ указания другого имени системы это установка переменной [.filename]#/boot/loader.conf#`hw.acpi.osname="Windows 2001"` или в другое подобное значение, имеющееся в ASL.

==== Отсутствие возврата значения

Некоторые методы не возвращают значение явно, как того требует стандарт. Хотя ACPI-CA не обрабатывает эту ситуацию, в FreeBSD существует обходной путь, позволяющей ей явно возвращать значение. Вы можете также добавить явные операторы Return (возврат) там, где требуется, если знаете, что значение должно быть возвращено. Для принудительного компилирования ASL командой `iasl`, используйте флаг `-f`.

==== Перезапись AML по умолчанию

После настройки [.filename]#your.asl# для компиляции запустите:

[source,bash]
....
# iasl your.asl
....

Вы можете добавить флаг `-f` для создания AML даже при наличии ошибок компиляции. Помните, что некоторые ошибки (например, отсутствующие операторы Return), автоматически обходятся интерпретатором.

Файл [.filename]#DSDT.aml# используется `iasl` по умолчанию. Вы можете загрузить его вместо ошибочной копии BIOS (которая остается в постоянной памяти) путем редактирования [.filename]#/boot/loader.conf#:

[.programlisting]
....
acpi_dsdt_load="YES"
acpi_dsdt_name="/boot/DSDT.aml"
....

Убедитесь, что скопировали [.filename]#DSDT.aml# в каталог [.filename]#/boot#.

[[ACPI-debugoutput]]
=== Получение отладочной информации ACPI

Возможности отладки драйвера ACPI очень гибкие. Они позволяют вам указывать набор подсистем, а также уровень отладки. Подсистемы, которые вы хотите отлаживать, указываются как "слои", и подразделяются на компоненты ACPI-CA (ACPI_ALL_COMPONENTS) и поддержку оборудования ACPI (ACPI_ALL_DRIVERS). Уровень отладки варьируется от ACPI_LV_ERROR (только сообщать об ошибках) до ACPI_LV_VERBOSE (все сообщения). Уровень отладки представляет собой битовую маску, поэтому возможна одновременная установка нескольких параметров, разделенных пробелами. На практике, при использовании для получения отладочной информации последовательной консоли, слишком большое количество информации может переполнить буфер консоли. Полный список отдельных слоев и уровней можно найти на странице справочника man:acpi[4].

Вывод отладочной информации по умолчанию не включен. Для его включения добавьте параметр `options ACPI_DEBUG` к файлу настройки ядра, если ACPI встроен в ядро. Вы можете добавить параметр `ACPI_DEBUG=1` в файл [.filename]#/etc/make.conf# для глобального включения этого параметра. Если вы используете модуль [.filename]#acpi.ko# , его можно пересобрать индивидуально:

[source,bash]
....
# cd /sys/modules/acpi/acpi
 make clean  make
ACPI_DEBUG=1
....

Установите [.filename]#acpi.ko# в [.filename]#/boot/kernel# и добавьте предпочитаемый уровень и слой к [.filename]#loader.conf#. Этот пример включает отладочные сообщения для всех компонентов ACPI-CA и всех драйверов оборудования ACPI (CPU, LID и т.д.). Будут выводиться только сообщения об ошибках, наименьший уровень отладки.

[.programlisting]
....
debug.acpi.layer="ACPI_ALL_COMPONENTS ACPI_ALL_DRIVERS"
debug.acpi.level="ACPI_LV_ERROR"
....

Если требуемая информация получается в результате определенного события (скажем, приостановка и восстановление), вы можете не изменять [.filename]#loader.conf# и использовать для указания слоя и уровня `sysctl` после загрузки и подготовки системы к определенному событию. Имена переменных `sysctl` те же, что и имена параметров настройки в [.filename]#loader.conf#.

[[ACPI-References]]
=== Ссылки

Дальнейшую информацию о ACPI можно найти по следующим ссылкам:

* {freebsd-acpi}
* Архивы списка рассылки ACPI http://lists.freebsd.org/pipermail/freebsd-acpi/[http://lists.freebsd.org/pipermail/freebsd-acpi/]
* Старые архивы списка рассылки ACPI http://home.jp.FreeBSD.org/mail-list/acpi-jp/[http://home.jp.FreeBSD.org/mail-list/acpi-jp/]
* Спецификация ACPI 2.0 http://acpi.info/spec.htm[http://acpi.info/spec.htm]
* Страницы справочника FreeBSD: man:acpi[4], man:acpi_thermal[4], man:acpidump[8], man:iasl[8], man:acpidb[8]
* http://www.cpqlinux.com/acpi-howto.html#fix_broken_dsdt[ Ресурс по отладке DSDT]. (Использует в качестве примера Compaq, но обычно полезен.)
