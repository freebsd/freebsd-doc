---
description: 'В этой главе описывается процесс загрузки FreeBSD и способы его настройки. Рассматриваются все этапы — от начальной загрузки до момента, когда ядро FreeBSD завершает инициализацию, определяет оборудование и запускает процесс init'
next: books/handbook/security
params:
  path: /books/handbook/boot/
part: 'Часть III. Администрирование системы'
prev: books/handbook/config
showBookMenu: 'true'
tags: ["boot", "boot process", "device hints", "x86", "amd64", "MBR", "GPT", "UEFI", "bsdlabel", "boot0", "Single-User Mode", "Multi-User Mode"]
title: 'Глава 15. Процесс загрузки FreeBSD'
weight: 19
---

[[boot]]
= Процесс загрузки FreeBSD
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 15
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/boot/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[boot-synopsis]]
== Обзор

Процесс запуска компьютера и загрузки операционной системы называется "процессом начальной загрузки" или "загрузкой". Процесс загрузки FreeBSD предоставляет большую гибкость в настройке действий при старте системы, включая возможность выбора между различными операционными системами, установленными на одном компьютере, разными версиями одной операционной системы или другим установленным ядром.

Эта глава подробно описывает доступные параметры конфигурации. В ней показано, как настроить процесс загрузки FreeBSD, включая все этапы до момента, когда ядро FreeBSD запустится, определит устройства и запустит man:init[8]. Это происходит, когда цвет текста загрузочных сообщений меняется с ярко-белого на серый.

Прочитав эту главу, вы узнаете:

* Компоненты загрузочной системы FreeBSD и их взаимодействие.
* Параметры, которые можно передать компонентам в процессе загрузки FreeBSD для управления процессом загрузки.
* Основы настройки подсказок устройств.
* Как загрузиться в однопользовательском и многопользовательском режимах и как правильно завершить работу системы FreeBSD.

[NOTE]
====
Эта глава описывает только процесс загрузки FreeBSD на системах с архитектурой x86 и amd64.
====

[[boot-introduction]]
== Процесс загрузки FreeBSD

Включение компьютера и запуск операционной системы представляет собой интересную дилемму. По определению, компьютер не умеет ничего делать до запуска операционной системы. Это включает в себя запуск программ с диска. Если компьютер не может запустить программу с диска без операционной системы, а программы операционной системы находятся на диске, то как же тогда запускается операционная система?

Эта проблема аналогична описанной в книге «Приключения барона Мюнхгаузена». Персонаж частично провалился в люк, но смог выбраться, ухватившись за шнурки своих сапог и подтянув себя вверх. В первые дни развития вычислительной техники термин **_bootstrap_** применялся к механизму загрузки операционной системы. Со временем он сократился до «**загрузки**» (англ. "booting").

На аппаратном обеспечении x86 загрузка операционной системы выполняется базовой системой ввода/вывода (BIOS). BIOS ищет на жестком диске главную загрузочную запись (MBR), которая должна находиться в определенном месте диска. BIOS обладает достаточными знаниями для загрузки и запуска MBR и предполагает, что MBR затем сможет выполнить остальные задачи по загрузке операционной системы, возможно, с помощью BIOS.

[NOTE]
====
FreeBSD поддерживает загрузку как по старому стандарту MBR, так и по новому стандарту GUID Partition Table (GPT). Разметка GPT часто встречается на компьютерах с Unified Extensible Firmware Interface (UEFI). Однако FreeBSD может загружаться с разделов GPT даже на машинах с устаревшим BIOS, используя man:gptboot[8]. Ведутся работы по обеспечению прямой загрузки через UEFI.
====

Код в MBR обычно называют _загрузчиком_, особенно если он взаимодействует с пользователем. Загрузчик обычно содержит больше кода в первом треке диска или в файловой системе. Примерами загрузчиков являются стандартный загрузчик FreeBSD boot0, также называемый Boot Easy, и GNU GRUB, который используется во многих дистрибутивах Linux(R).

[NOTE]
====
// There is extref:{faq}[a frequently asked question] about GRUB. Beyond the answer there, //
Пользователи GRUB могут обратиться к https://www.gnu.org/software/grub/grub-documentation.html[документации от GNU].
====

Если на компьютере установлена только одна операционная система, MBR ищет первый загрузочный (активный) раздел на диске, а затем запускает код в этом разделе для загрузки остальной части операционной системы. При наличии нескольких операционных систем можно установить другой загрузчик, который отобразит список операционных систем, позволяя пользователю выбрать нужную для загрузки.

Оставшаяся часть загрузочной системы FreeBSD разделена на три этапа. Первый этап знает ровно столько, чтобы перевести компьютер в определённое состояние и запустить второй этап. Второй этап может выполнить немного больше, прежде чем запустить третий этап. Третий этап завершает загрузку операционной системы. Работа разделена на три этапа, потому что MBR накладывает ограничения на размер программ, которые могут быть выполнены на первом и втором этапах. Объединение задач в цепочку позволяет FreeBSD предоставить более гибкий загрузчик.

Затем запускается ядро, которое начинает поиск и инициализацию устройств для их использования. После завершения процесса загрузки ядра управление передаётся пользовательскому процессу man:init[8], который проверяет готовность дисков к работе, запускает пользовательскую настройку ресурсов, монтирует файловые системы, настраивает сетевые карты для работы в сети и запускает процессы, запланированные для выполнения при старте системы.

Этот раздел подробно описывает эти этапы и показывает, как взаимодействовать с процессом загрузки FreeBSD.

[[boot-boot0]]
=== Загрузчик

Код загрузчика в MBR иногда называют _нулевой стадией_ процесса загрузки. По умолчанию FreeBSD использует загрузчик boot0.

MBR, записываемый установщиком FreeBSD, основан на [.filename]#/boot/boot0#. Размер и возможности boot0 ограничены 446 байтами из-за таблицы разделов и идентификатора `0x55AA` в конце MBR. Если установлены boot0 и несколько операционных систем, при загрузке будет отображаться сообщение, похожее на этот пример:

[[boot-boot0-example]]
.Экран [.filename]#boot0#
[example]
====

[source, shell]
....
F1 Win
F2 FreeBSD

Default: F2
....

====

Другие операционные системы перезапишут существующую MBR, если они установлены после FreeBSD. Если это произошло или требуется заменить существующую MBR на MBR FreeBSD, используйте следующую команду:

[source, shell]
....
# fdisk -B -b /boot/boot0 device
....

где _device_ — это загрузочный диск, например, [.filename]#ad0# для первого IDE-диска, [.filename]#ad2# для первого IDE-диска на втором IDE-контроллере или [.filename]#da0# для первого SCSI-диска. Для создания пользовательской конфигурации MBR обратитесь к man:boot0cfg[8].

[[boot-boot1]]
=== Этап первый и Этап второй

Концептуально первая и вторая стадии являются частью одной программы и расположены в одной области диска. Из-за ограничений по объёму они были разделены на две части, но всегда устанавливаются вместе. Они копируются из объединённого файла [.filename]#/boot/boot# с помощью установщика FreeBSD или `bsdlabel`.

Эти два этапа расположены за пределами файловых систем, в первом треке загрузочного раздела, начиная с первого сектора. Именно здесь boot0 или любой другой загрузчик ожидает найти программу для запуска, которая продолжит процесс загрузки.

Первая стадия, [.filename]#boot1#, очень проста, так как её размер может составлять только 512 байт. Она знает ровно столько о _bsdlabel_ FreeBSD, в котором хранится информация о слайсе, чтобы найти и выполнить [.filename]#boot2#.

Этап два, [.filename]#boot2#, немного сложнее и понимает файловую систему FreeBSD достаточно хорошо, чтобы находить файлы. Он может предоставить простой интерфейс для выбора ядра или загрузчика для запуска. Он запускает loader, который гораздо более продвинут и предоставляет файл конфигурации загрузки. Если процесс загрузки прерывается на втором этапе, отображается следующий интерактивный экран:

[[boot-boot2-example]]
.Экран [.filename]#boot2#
[example]
====

[source, shell]
....
>> FreeBSD/i386 BOOT
Default: 0:ad(0,a)/boot/loader
boot:
....

====

Для замены установленных [.filename]#boot1# и [.filename]#boot2# используйте `bsdlabel`, где _diskslice_ — это диск и раздел, с которого производится загрузка, например [.filename]#ad0s1# для первого раздела на первом IDE-диске:

[source, shell]
....
# bsdlabel -B diskslice
....

[WARNING]
====
Если указано только имя диска, например [.filename]#ad0#, `bsdlabel` создаст диск в «опасном выделенном режиме» (dangerously dedicated mode) без разделов. Вероятно, это нежелательное действие, поэтому дважды проверьте _дисковый раздел_ перед нажатием kbd:[Enter].
====

[[boot-loader]]
=== Этап три

Загрузчик является завершающим этапом трёхэтапного процесса начальной загрузки. Он располагается в файловой системе, обычно как [.filename]#/boot/loader#.

Загрузчик предназначен для интерактивной настройки с использованием встроенного набора команд, а также поддерживается более мощным интерпретатором с расширенным набором команд.

Во время инициализации загрузчик определит консоль и диски, а также выяснит, с какого диска происходит загрузка. Он установит соответствующие переменные и запустит интерпретатор, в котором пользовательские команды могут передаваться из скрипта или вводиться в интерактивном режиме.

Затем загрузчик прочитает [.filename]#/boot/loader.rc#, который по умолчанию загружает [.filename]#/boot/defaults/loader.conf#, где задаются разумные значения по умолчанию для переменных, а также читает [.filename]#/boot/loader.conf# для локальных изменений этих переменных. После этого [.filename]#loader.rc# действует в соответствии с этими переменными, загружая выбранные модули и ядро.

Наконец, по умолчанию загрузчик ожидает нажатия клавиш в течение 10 секунд и загружает ядро, если не было прерывания. Если прерывание произошло, пользователю предоставляется командная строка, поддерживающая набор команд, где можно изменить переменные, выгрузить все модули, загрузить модули и, наконец, загрузить или перезагрузить систему. crossref:boot[boot-loader-commands,Встроенные команды загрузчика] перечисляет наиболее часто используемые команды загрузчика. Для полного описания всех доступных команд обратитесь к man:loader[8].

[[boot-loader-commands]]
.Встроенные команды загрузчика
[cols="20%,80%", frame="none", options="header"]
|===
| Переменная
| Описание

|autoboot _секунды_
|Продолжает загрузку ядра, если не прервано в течение указанного времени в секундах. Отображает обратный отсчет, а время по умолчанию составляет 10 секунд.

|boot [`-options`] [`kernelname`]
|Немедленно переходит к загрузке ядра с любыми указанными параметрами или именем ядра. Указание имени ядра в командной строке применимо только после выполнения команды `unload`. В противном случае будет использовано ранее загруженное ядро. Если _kernelname_ не указан полностью, поиск будет выполнен в _/boot/kernel_ и _/boot/modules_.

|boot-conf
|Проходит ту же автоматическую настройку модулей на основе указанных переменных, чаще всего `kernel`. Имеет смысл только при использовании `unload` перед изменением некоторых переменных.

|help [`_тема_`]
|Показывает справочные сообщения, прочитанные из файла [.filename]#/boot/loader.help#. Если указана тема `index`, отображается список доступных тем.

|include `_имяфайла_` ...
|Читает указанный файл и обрабатывает его построчно. Ошибка немедленно останавливает `include`.

|load [-t ``_тип_``] `_имяфайла_`
|Загружает ядро, модуль ядра или файл указанного типа с заданным именем. Все аргументы после _имяфайла_ передаются файлу. Если _имяфайла_ не указано полностью, файл будет искаться в _/boot/kernel_ и _/boot/modules_.

|ls [-l] [``_путь_``]
|Отображает список файлов в указанном пути или в корневом каталоге, если путь не указан. Если указан параметр `-l`, также будут показаны размеры файлов.

|lsdev [`-v`]
|Перечисляет все устройства, с которых возможно загрузить модули. Если указан параметр `-v`, выводится более подробная информация.

|lsmod [`-v`]
|Отображает загруженные модули. Если указан параметр `-v`, выводится более подробная информация.

|more `_имяфайла_`
|Отображает указанные файлы с паузой после каждых `LINES` выведенных строк.

|reboot
|Немедленно перезагружает систему.

|set `_variable_`, set `_variable=value_`
|Устанавливает указанные переменные окружения.

|unload
|Удаляет все загруженные модули.
|===

Вот несколько практических примеров использования загрузчика. Чтобы загрузить обычное ядро в однопользовательском режиме:

[source, shell]
....
 boot -s
....

Чтобы выгрузить обычное ядро и модули, а затем загрузить предыдущее или другое указанное ядро:

[source, shell]
....
 unload
 load /путь/к/файлуядра
....

Используйте полный путь [.filename]#/boot/GENERIC/kernel# для ссылки на стандартное ядро, поставляемое с установкой, или [.filename]#/boot/kernel.old/kernel# для ссылки на предыдущую версию ядра до обновления системы или до настройки собственного ядра.

Используйте следующее для загрузки обычных модулей с другим ядром. Обратите внимание, что в этом случае не обязательно указывать полное имя:

[source, shell]
....
unload
set kernel="mykernel"
boot-conf
....

Для загрузки автоматизированного сценария конфигурации ядра:

[source, shell]
....
 load -t userconfig_script /boot/kernel.conf
....

[[boot-init]]
=== Последний этап

После загрузки ядра с помощью `loader` или `boot2`, который обходит `loader`, оно проверяет флаги загрузки и при необходимости корректирует свое поведение. В crossref:boot[boot-kernel,Взаимодействие ядра во время загрузки] приведены часто используемые флаги загрузки. Дополнительную информацию о других флагах загрузки можно найти в man:boot[8].

[[boot-kernel]]
.Взаимодействие с ядром во время загрузки
[cols="1,1", frame="none", options="header"]
|===
| Опция
| Описание

|`-a`
|Во время инициализации ядра запросить устройство для монтирования в качестве корневой файловой системы.

|`-C`
|Загрузка корневой файловой системы с CDROM.

|`-s`
|Загрузится в однопользовательский режим.

|`-v`
|Более подробный вывод во время загрузки ядра.
|===

После завершения загрузки ядро передает управление пользовательскому процессу man:init[8], который находится в [.filename]#/sbin/init#, или программе, указанной в переменной `init_path` в `loader`. Это последний этап процесса загрузки.

Последовательность загрузки гарантирует, что файловые системы, доступные в системе, находятся в согласованном состоянии. Если файловая система UFS не согласована и `fsck` не может исправить несоответствия, init переводит систему в однопользовательский режим, чтобы администратор системы мог устранить проблему вручную. В противном случае система загружается в многопользовательский режим.

[[boot-singleuser]]
==== Однопользовательский режим

Пользователь может указать этот режим, загрузившись с ключом `-s` или установив переменную `boot_single` в загрузчике. Также можно перейти в этот режим, выполнив команду `shutdown now` из многопользовательского режима. Однопользовательский режим начинается со следующего сообщения:

[.programlisting]
....
Enter full pathname of shell or RETURN for /bin/sh:
....

Если пользователь нажмёт kbd:[Enter], система запустит оболочку Bourne по умолчанию. Чтобы указать другую оболочку, введите полный путь к ней.

Однопользовательский режим обычно используется для восстановления системы, которая не загружается из-за несогласованности файловой системы или ошибки в конфигурационном файле загрузки. Он также может применяться для сброса пароля `root`, если он неизвестен. Эти действия возможны, поскольку приглашение однопользовательского режима предоставляет полный локальный доступ к системе и её конфигурационным файлам. В этом режиме отсутствует сетевое взаимодействие.

Хотя однопользовательский режим полезен для восстановления системы, он представляет угрозу безопасности, если система не находится в физически защищенном месте. По умолчанию любой пользователь, имеющий физический доступ к системе, получит полный контроль над ней после загрузки в однопользовательском режиме.

Если в [.filename]#/etc/ttys# параметр `console` изменён на `insecure`, система сначала запросит пароль `root` перед переходом в однопользовательский режим. Это добавляет уровень безопасности, но лишает возможности сбросить пароль `root`, если он неизвестен.

[[boot-insecure-console]]
.Настройка небезопасной консоли в [.filename]#/etc/ttys#
[example]
====
[.programlisting]
....
# name  getty                           type    status          comments
#
# If console is marked "insecure", then init will ask for the root password
# when going to single-user mode.
console none                            unknown off insecure
....

====

`insecure` консоль означает, что физическая безопасность консоли считается ненадежной, поэтому только тот, кто знает пароль `root`, может использовать однопользовательский режим.

[[boot-multiuser]]
==== Многопользовательский режим

Если `init` обнаруживает, что файловые системы в порядке, или после того, как пользователь завершит свои команды в однопользовательском режиме и введёт `exit` для выхода из этого режима, система переходит в многопользовательский режим, в котором начинается настройка ресурсов системы.

Система конфигурации ресурсов загружает настройки по умолчанию из [.filename]#/etc/defaults/rc.conf# и специфичные для системы параметры из [.filename]#/etc/rc.conf#. Затем она монтирует файловые системы, перечисленные в [.filename]#/etc/fstab#. После этого запускаются сетевые службы, различные системные демоны, а затем скрипты запуска локально установленных пакетов.

Чтобы узнать больше о системе настройки ресурсов, обратитесь к man:rc[8] и изучите скрипты в [.filename]#/etc/rc.d#.

[[device-hints]]
== Подсказки устройств

Во время начальной загрузки системы загрузчик man:loader[8] читает файл man:device.hints[5]. Этот файл хранит информацию о загрузке ядра, известную как переменные, иногда называемые "подсказками устройств" ("device hints"). Эти "подсказки устройств" используются драйверами устройств для их конфигурации.

Подсказки для устройств также могут быть указаны в строке загрузчика на Этапе 3, как показано в crossref:boot[boot-loader, Третий Этап]. Переменные можно добавить с помощью `set`, удалить с помощью `unset` и просмотреть с помощью `show`. Переменные, заданные в [.filename]#/boot/device.hints#, также могут быть переопределены. Подсказки для устройств, введённые в загрузчике, не являются постоянными и не будут применены при следующей перезагрузке.

После загрузки системы все переменные можно вывести с помощью man:kenv[1].

Синтаксис для [.filename]#/boot/device.hints# — одна переменная на строку, символ "#" используется для комментариев. Строки формируются следующим образом:

[source, shell]
....
 hint.driver.unit.keyword="value"
....

Синтаксис загрузчика Этапа 3 следующий:

[source, shell]
....
 set hint.driver.unit.keyword=value
....

где `driver` — это имя драйвера устройства, `unit` — номер устройства драйвера, а `keyword` — ключевое слово подсказки. Ключевое слово может включать следующие варианты:

* `at`: указывает шину, к которой подключено устройство.
* `port`: указывает начальный адрес ввода-вывода, который будет использоваться.
* `irq`: указывает номер запроса на прерывание, который должен использоваться.
* `drq`: указывает номер канала DMA.
* `maddr`: указывает физический адрес памяти, занятый устройством.
* `flags`: устанавливает различные биты флагов для устройства.
* `disabled`: если установлено в `1`, устройство отключено.

Поскольку драйверы устройств могут принимать или требовать дополнительные подсказки, не перечисленные здесь, рекомендуется ознакомиться с руководством по конкретному драйверу. Для получения дополнительной информации обратитесь к man:device.hints[5], man:kenv[1], man:loader.conf[5] и man:loader[8].

[[boot-shutdown]]
== Последовательность выключения

При контролируемом завершении работы с помощью man:shutdown[8], man:init[8] попытается выполнить скрипт [.filename]#/etc/rc.shutdown#, а затем отправит всем процессам сигнал `TERM`, и после этого сигнал `KILL` всем процессам, которые не завершатся своевременно.

Для выключения питания машины FreeBSD на архитектурах и системах, поддерживающих управление питанием, используйте `shutdown -p now`, чтобы немедленно отключить питание. Для перезагрузки системы FreeBSD используйте `shutdown -r now`. Для выполнения man:shutdown[8] необходимо быть `root` или членом группы `operator`. Также можно использовать man:halt[8] и man:reboot[8]. Дополнительную информацию см. на их справочных страницах и в man:shutdown[8].

Измените членство в группе, обратившись к разделу crossref:basics[users-synopsis,«Пользователи и основы управления учетными записями»].

[NOTE]
====
Управление питанием требует, чтобы модуль man:acpi[4] был загружен как модуль или статически скомпилирован в собственное ядро.
====
