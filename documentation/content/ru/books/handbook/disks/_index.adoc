---
title: Глава 17. Устройства хранения
part: Часть III. Системное администрирование
prev: books/handbook/audit
next: books/handbook/geom
---

[[disks]]
= Устройства хранения
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:source-highlighter: rouge
:experimental:
:skip-front-matter:
:toc-title: Содержание
:table-caption: Таблица
:figure-caption: Рисунок
:example-caption: Пример
:xrefstyle: basic
:relfileprefix: ../
:outfilesuffix:
:sectnumoffset: 17

ifeval::["{backend}" == "html5"]
:imagesdir: ../../../images/books/handbook/disks/
endif::[]

ifeval::["{backend}" == "pdf"]
:imagesdir: ../../../../static/images/books/handbook/disks/
endif::[]

ifeval::["{backend}" == "epub3"]
:imagesdir: ../../../../static/images/books/handbook/disks/
endif::[]

include::shared/authors.adoc[]
include::shared/releases.adoc[]
include::shared/ru/mailing-lists.adoc[]
include::shared/ru/teams.adoc[]
include::shared/ru/urls.adoc[]

toc::[]

[[disks-synopsis]]
== Краткий обзор

В этой главе описывается использование дисков во FreeBSD. К ним относятся диски в памяти, диски, подключенные по сети, обычные устройства хранения SCSI/IDE и устройства, использующие интерфейс USB.

После чтения этой главы вы будете знать:

* Терминологию, используемую во FreeBSD для описания организации данных на физическом диске (разделы и слайсы).
* Как добавить дополнительные винчестеры к вашей системе.
* Как настроить FreeBSD для использования дисковых устройств USB.
* Как настроить виртуальные файловые системы, такие, как диски в оперативной памяти.
* Как использовать квоты для ограничения использования дискового пространства.
* Как зашифровать диски, чтобы защитить их от взлома.
* Как создавать и записывать CD и DVD во FreeBSD.
* Различные варианты использования устройств хранения для резервных копий.
* Как использовать программы резервного копирования, имеющиеся для FreeBSD.
* Как выполнять резервное копирование на дискеты.
* Что такое мгновенные копии файловых систем и как их эффективно использовать

Перед прочтением этой главы вам потребуется:

* Узнать как настраивать и устанавливать новое ядро FreeBSD (crossref:kernelconfig[kernelconfig, Настройка ядра FreeBSD]).

[[disks-naming]]
== Имена устройств

Далее приводится список физических устройств хранения информации, которые поддерживаются во FreeBSD, и имена устройств, которые им соответствуют.

[[disk-naming-physical-table]]
.Соглашения по именованию физических дисков
[cols="1,1", frame="none", options="header"]
|===
| Тип диска
| Имя дискового устройства

|Винчестеры IDE
|`ad`

|Приводы IDE CDROM
|`acd`

|Винчестеры SCSI и дисковые устройства USB
|`da`

|Приводы SCSI CDROM
|`cd`

|Различные нестандартные приводы CDROM
|`mcd` для Mitsumi CD-ROM, `scd` для Sony CD-ROM 

|Дискеты
|`fd`

|Ленточные приводы SCSI
|`sa`

|Ленточные приводы IDE
|`ast`

|Флэш-диски
|`fla` для флэш-устройств DiskOnChip(R)

|Диски RAID
|`aacd` для Adaptec(R) AdvancedRAID, `mlxd` и `mlyd` для Mylex(R), `amrd` для AMI MegaRAID(R), `idad` для Compaq Smart RAID, `twed` для 3ware(R) RAID.
|===

[[disks-adding]]
== Добавление дисков

В этом разделе будет описан процесс добавления нового SCSI диска на машину, имеющую в данный момент только один диск. Сначала выключим компьютер и установим диск в компьютер согласно инструкциям к компьютеру, контроллеру и от производителя диска. Из-за большого разнообразия этих процедур их рассмотрение выходит за рамки этого документа..

Войдите в систему как пользователь `root`. После того, как вы установили диск, просмотрите файл [.filename]#/var/run/dmesg.boot#, чтобы убедиться, что новый диск был найден. Продолжая наш пример, только что добавленный диск будет называться [.filename]#da1# и мы хотим смонтировать его в каталог [.filename]#/1# (если вы добавляете диск IDE, то устройство будет называться [.filename]#ad1#).

FreeBSD работает на IBM-PC совместимых компьютерах, поэтому она должна уметь работать с разделами PC BIOS. Однако они отличаются от традиционных разделов BSD. Диск ПК может иметь до четырёх записей разделов BIOS. Если диск на самом деле будет использоваться исключительно под FreeBSD, вы можете использовать режим _dedicated_. В противном случае FreeBSD будет располагаться в одном из разделов PC BIOS. Во FreeBSD разделы PC BIOS называются _слайсами_, чтобы не путать их с традиционными разделами BSD. Вы также можете использовать слайсы и с диском, предназначенным исключительно для FreeBSD, однако используемым в компьютере, на котором имеется дополнительная операционная система. Это является хорошим способом избежать путаницы в утилите `fdisk` других операционных систем, не связанных с FreeBSD.

В случае слайсов диск будет добавлен как [.filename]#/dev/da1s1e#. Это интерпретируется следующим образом: диск SCSI, устройство номер 1 (второй диск SCSI), слайс 1 (раздел PC BIOS 1), и раздел BSD [.filename]#e#. В случае использования в выделенном режиме диск будет добавлен просто как [.filename]#/dev/da1e#.

Вследствие использования 32-разрядных целых чисел для адресации секторов, man:bsdlabel[8] ограничен 2^32-1 секторами на диск, или 2TB в большинстве случаев. Формат man:fdisk[8] позволяет наличие первого сектора со смещением не более 2^32-1 и длину не более 2^32-1, что ограничивает размер раздела до 2TB, а размер диска до 4TB в большинстве случаев. Формат man:sunlabel[8] ограничен 2^32-1 секторами на раздел и 8 разделами, что составляет 16TB. Для дисков большего раздела могут быть использованы разделы man:gpt[8].

=== Использование утилиты man:sysinstall[8]

[.procedure]
====
. Использование Sysinstall
+ 
Вы можете использовать простые меню утилиты `sysinstall` для разбиения на разделы и разметки нового диска. Войдите как пользователь `root` или воспользуйтесь командой `su`. Запустите команду `sysinstall` и войдите в меню `Configure`. Внутри `FreeBSD Configuration Menu`, пролистайте и выберите пункт `Fdisk`.
. Редактор разделов fdisk
+ 
При работе с утилитой fdisk нажатие kbd:[A] используется для выделения под FreeBSD полностью всего диска. Когда будет задан вопрос о том, хотите ли вы "сохранить совместимость с другими возможными операционными системами в будущем", ответьте `YES`. Запишите изменения на диск при помощи команды kbd:[W]. А теперь выйдите из редактора FDISK, нажав kbd:[Q]. В этот момент вам будет задан вопрос о "Master Boot Record" (главной загрузочной записи). Так как вы добавляете диск к уже работающей системе, выберите `None`.
. Редактор метки диска
+ 
Теперь вам нужно выйти из sysinstall и запустить эту утилиту снова. Следуйте указаниям выше, но на этот раз выберите пункт `Label`. Вы перейдёте к меню `Disk Label Editor`. Здесь вы создадите традиционные разделы BSD. На диске может быть до восьми разделов, имеющих метки `a-h`. Некоторые из меток разделов имеют особый смысл. Раздел `a` используется для размещения корневого раздела ([.filename]#/#). По этой причине только ваш системный диск (например, тот, с которого происходит загрузка), должен иметь раздел `a`. Раздел `b` используется под раздел подкачки, и вы можете иметь много дисков с разделами подкачки. Раздел `c` используется для доступа ко всему диску в режиме эксклюзивного использования или ко всему слайсу FreeBSD при работе в режиме с использованием слайсов. Остальные разделы имеют обычное предназначение.
+ 
Редактор метки диска программы sysinstall использует раздел `e` для некорневого раздела и не для раздела подкачки. Внутри редактора метки диска создайте отдельную файловую систему, нажав kbd:[C]. Когда будет задан вопрос о том, будет ли это раздел с файловой системой (FS) или это будет раздел подкачки, выберите `FS` и наберите точку монтирования (например, [.filename]#/mnt#). При добавлении диска после установки системы, программа sysinstall не будет автоматически создавать записи в файле [.filename]#/etc/fstab#, поэтому точка монтирования не так уж и важна.
+ 
Теперь вы готовы записать новую метку на диск и создать на нем файловую систему. Сделайте это, нажав kbd:[W]. Проигнорируйте сообщения об ошибках от sysinstall о невозможности смонтировать новый раздел. Полностью выйдите из редактора метки диска и из программы sysinstall.
. Завершение
+ 
Последний шаг заключается в редактировании файла [.filename]#/etc/fstab# и добавлении записи для вашего нового диска.
====

=== Использовании утилит командной строки

==== Работа со слайсами

Следующая настройка позволит вашему диску корректно работать с другими операционными системами, которые могут быть установлены на вашем компьютере, и не вызовет конфликта с утилитами `fdisk` других операционных систем. Этот способ рекомендуется использовать для установок новых дисков. Используйте `эксклюзивный` режим, только если у вас есть реальные причины делать это!

[source,bash]
....
# dd if=/dev/zero of=/dev/da1 bs=1k count=1
# fdisk -BI da1 # Инициализируем новый диск.
# bsdlabel -B -w da1s1 auto # Размечаем его.
# bsdlabel -e da1s1 # Редактируем только что созданную метку диска и добавляем разделы.
# mkdir -p /1
# newfs /dev/da1s1e # Повторяем этот шаг для всех созданных разделов.
# mount /dev/da1s1e /1 # Монтируем раздел(ы)
# vi /etc/fstab # Добавляем соответствующую запись/записи в файл /etc/fstab.
....

Если у вас установлен диск IDE, подставьте [.filename]#ad# вместо [.filename]#da#.

==== Эксклюзивный режим

Если вы не будете использовать новый диск совместно с другой операционной системой, то вы можете использовать режим `эксклюзивного` использования. Отметьте, что этот режим может ввести в заблуждение операционные системы от Microsoft; однако информацию они не разрушат. А вот OS/2(R) компании IBM будет "забирать себе" любой раздел, который она найдет и не сможет распознать.

[source,bash]
....
# dd if=/dev/zero of=/dev/da1 bs=1k count=1
# bsdlabel -Bw da1 auto
# bsdlabel -e da1                           # create the `e' partition
# newfs /dev/da1e
# mkdir -p /1
# vi /etc/fstab                              # add an entry for /dev/da1e
# mount /1
....

Альтернативный метод заключается в следующем:

[source,bash]
....
# dd if=/dev/zero of=/dev/da1 count=2
# bsdlabel /dev/da1 | bsdlabel -BR da1 /dev/stdin
# newfs /dev/da1e
# mkdir -p /1
# vi /etc/fstab                              # add an entry for /dev/da1e
# mount /1
....

[[raid]]
== RAID

[[raid-soft]]
=== Программный RAID

[[ccd]]
==== Конфигурация драйвера объединённого диска (CCD)

При выборе решения для организации хранилища самыми важными характеристиками являются скорость, надежность и стоимость. Редко все эти характеристики наличествуют одновременно; обычно быстрое и надёжное устройство хранения стоит дорого, а при уменьшении стоимости в жертву приносятся скорость работы или надёжность.

При проектировании описываемой далее системы в качестве самого важного фактора была выбрана её стоимость, затем быстродействие и надёжность. Скорость передачи данных для этой системы ограничивалась только пропускной способностью сети. И, хотя надёжность очень важна, CCD-диск, описываемый ниже, обслуживал работу с данными, полные копии которых уже хранились на дисках CD-R, так они могли быть с лёгкостью обновлены.

При выборе решения для массового хранения данных первым шагом является определение ваших требований к нему. Если в ваших требованиях главными являются скорость или надёжность, а не стоимость, то ваш выбор будет отличаться от описываемой в этом разделе системы.

[[ccd-installhw]]
===== Установка оборудования

Кроме системного IDE-диска, основу описываемого далее CCD-диска общим объёмом примерно в 90 Гбайт составили три IDE-диска Western Digital 30GB, 5400 RPM. В идеальном случае каждый диск IDE имеет собственный контроллер и кабель, но для минимизации стоимости дополнительные контроллеры IDE не использовались. Вместо этого диски были настроены при помощи переключателей так, что на каждом IDE-контроллере находилось по одному ведущему и одному ведомому диску.

До перезагрузки BIOS системы была настроена на автоматическое распознавание подключенных дисков. Более важно то, что при перезагрузке их распознала FreeBSD:

[.programlisting]
....
ad0: 19574MB <WDC WD205BA> [39770/16/63] at ata0-master UDMA33
ad1: 29333MB <WDC WD307AA> [59598/16/63] at ata0-slave UDMA33
ad2: 29333MB <WDC WD307AA> [59598/16/63] at ata1-master UDMA33
ad3: 29333MB <WDC WD307AA> [59598/16/63] at ata1-slave UDMA33
....

[NOTE]
====
Если FreeBSD не распознала все диски, проверьте корректность положения переключателей на них. На большинстве IDE-дисков имеется также переключатель "Cable Select". Он _не имеет_ отношения к выбору ведущего и ведомого устройств. Для получения помощи по правильному положению переключателей обратитесь к документации по устройствам.
====

[[ccd-setup]]
===== Настройка CCD

Драйвер man:ccd[4] позволяет вам взять несколько идентичных дисков и объединить их в одну логическую файловую систему. Для использования man:ccd[4] нужно ядро со встроенной поддержкой man:ccd[4]. Добавьте такую строку в файл конфигурации ядра, перестройте и установите новое ядро:

[.programlisting]
....
device   ccd
....

Поддержка man:ccd[4] также может быть обеспечена загрузкой подгружаемого модуля ядра.

Для настройки man:ccd[4] сначала вам нужно воспользоваться утилитой man:bsdlabel[8] для разметки дисков:

[.programlisting]
....
bsdlabel -w ad1 auto
bsdlabel -w ad2 auto
bsdlabel -w ad3 auto
....

При этом создаются метки для [.filename]#ad1c#, [.filename]#ad2c# и [.filename]#ad3c#, которые занимают диск полностью.

Следующим шагом является изменение типа метки диска. Для редактирования дисков можно использовать утилиту man:bsdlabel[8]:

[.programlisting]
....
bsdlabel -e ad1
bsdlabel -e ad2
bsdlabel -e ad3
....

При этом в редакторе, задаваемом переменной окружения `EDITOR` (обычно это man:vi[1]), открывается текущая метка каждого диска.

Не модифицированная метка диска будет выглядеть примерно следующим образом:

[.programlisting]
....
8 partitions:
#        size   offset    fstype   [fsize bsize bps/cpg]
  c: 60074784        0    unused        0     0     0   # (Cyl.    0 - 59597)
....

Добавьте новый раздел `e` для использования драйвером man:ccd[4]. Как правило, он может быть скопирован с раздела `c`, но поле `fstype` _должно_ иметь значение `4.2BSD`. Теперь метка диска должна выглядеть примерно так:

[.programlisting]
....
8 partitions:
#        size   offset    fstype   [fsize bsize bps/cpg]
  c: 60074784        0    unused        0     0     0   # (Cyl.    0 - 59597)
  e: 60074784        0    4.2BSD        0     0     0   # (Cyl.    0 - 59597)
....

[[ccd-buildingfs]]
===== Построение файловой системы

Теперь, когда все диски размечены, вы должны построить man:ccd[4]. Для этого используйте утилиту man:ccdconfig[8] с параметрами, подобными следующим:

[.programlisting]
....
ccdconfig ccd0 32 0 /dev/ad1e /dev/ad2e /dev/ad3e
....

Использование и значение каждого параметра описывается ниже:
* Первым аргументом является конфигурируемое устройство, в нашем случае [.filename]#/dev/ccd0c#. Часть [.filename]#/dev/# является необязательной.
* Чередование для файловой системы. Оно определяет размер единицы блока данных в количестве дисковых блоков, каждый из которых обычно имеет объём в 512 байт. Таким образом, при чередовании в 32 это будет составлять 16384 байт.
* Опции для man:ccdconfig[8]. Если вы хотите включить зеркалирование диска, то можете задать это здесь. В нашей конфигурации зеркалирование для man:ccd[4] не предусмотрено, поэтому здесь задан 0 (ноль).
* Последним параметром для man:ccdconfig[8] является список устройств для объединения в массив. Для каждого устройства нужно задавать полное имя.

После запуска man:ccdconfig[8] устройство man:ccd[4] будет отконфигурировано. Может будет построить файловую систему. Обратитесь к справке по команде man:newfs[8] для выяснения требуемых параметров, или просто запустите: 

[.programlisting]
....
newfs /dev/ccd0c
....

[[ccd-auto]]
===== Автоматическое выполнение

Вообще говоря, вам потребуется монтировать man:ccd[4] при каждой перезагрузке. Для этого сначала вы должны отконфигурировать это устройство. Запишите вашу текущую конфигурацию в файл [.filename]#/etc/ccd.conf# при помощи такой команды:

[.programlisting]
....
ccdconfig -g > /etc/ccd.conf
....

При перезагрузке скрипт `/etc/rc` запускает команду `ccdconfig -C`, если существует файл [.filename]#/etc/ccd.conf#. При этом man:ccd[4] автоматически конфигурируется так, чтобы он мог быть смонтирован.

[NOTE]
====
Если при загрузке вы входите в однопользовательский режим, то перед тем, как выполнять монтирование man:ccd[4] по команде man:mount[8], вам нужно для конфигурации массива запустить следующую команду:

[.programlisting]
....
ccdconfig -C
....

====

Для автоматического монтирования man:ccd[4] поместите запись о man:ccd[4] в файл [.filename]#/etc/fstab#, чтобы он мог быть смонтирован во время загрузки системы:

[.programlisting]
....
/dev/ccd0c              /media       ufs     rw      2       2
....

[[raid-hard]]
=== Аппаратный RAID

FreeBSD поддерживает также целый ряд аппаратных контроллеров RAID. Эти устройства самостоятельно управляют RAID-подсистемой, без необходимости иметь специфичное для FreeBSD программное обеспечения управления массивом.

При помощи встроенной в адаптер BIOS, он сам управляет большинством дисковых операций. Далее следует краткое описание установки при помощи контроллера Promise IDERAID. После установки адаптера и запуска системы, выдаётся запрос на ввод. Следуйте указаниям для входа в настройку адаптера. Отсюда вы можете объединить все подключенные диски. После этого во FreeBSD диск(и) будут выглядеть как один диск. Аналогично могут быть настроены и другие уровни RAID.

=== Перестроение массивов ATA RAID1

FreeBSD позволяет вам выполнять горячую замену вышедшего из строя диска. При этом требуется, чтобы вы заметили это до перезагрузки.

Вероятно, в файле [.filename]#/var/log/messages# или в выдаче команды man:dmesg[8] вы увидите примерно следующее:

[.programlisting]
....
ad6 on monster1 suffered a hard error.
ad6: READ command timeout tag=0 serv=0 - resetting
ad6: trying fallback to PIO mode
ata3: resetting devices .. done
ad6: hard error reading fsbn 1116119 of 0-7 (ad6 bn 1116119; cn 1107 tn 4 sn 11)\\
status=59 error=40
ar0: WARNING - mirror lost
....

При помощи man:atacontrol[8] получите дополнительную информацию:

[source,bash]
....
# atacontrol list
ATA channel 0:
        Master:      no device present
        Slave:       acd0 <HL-DT-ST CD-ROM GCR-8520B/1.00> ATA/ATAPI rev 0

ATA channel 1:
        Master:      no device present
        Slave:       no device present

ATA channel 2:
        Master:      ad4 <MAXTOR 6L080J4/A93.0500> ATA/ATAPI rev 5
        Slave:       no device present

ATA channel 3:
        Master:      ad6 <MAXTOR 6L080J4/A93.0500> ATA/ATAPI rev 5
        Slave:       no device present

# atacontrol status ar0
ar0: ATA RAID1 subdisks: ad4 ad6 status: DEGRADED
....

[.procedure]
====

. Сначала вам нужно отключить канал контроллера ATA, содержащий отказавший диск, чтобы его можно было без последствий извлечь:
+
[source,bash]
....
# atacontrol detach ata3
....
+
. Замените диск.
. Повторно подключите канал дискового контроллера:
+
[source,bash]
....
# atacontrol attach ata3
Master:  ad6 <MAXTOR 6L080J4/A93.0500> ATA/ATAPI rev 5
Slave:   no device present
....
+
. Добавьте новый диск к массиву в качестве резервного:
+
[source,bash]
....
# atacontrol addspare ar0 ad6
....
+
. Перестройте массив:
+
[source,bash]
....
# atacontrol rebuild ar0
....
+
. Проверить состояние дел можно при помощи следующей команды:
+
[source,bash]
....
# dmesg | tail -10
[выдача удалена]
ad6: removed from configuration
ad6: deleted from ar0 disk1
ad6: inserted into ar0 disk1 as spare

# atacontrol status ar0
ar0: ATA RAID1 subdisks: ad4 ad6 status: REBUILDING 0% completed
....
+
. Дождитесь завершения этой операции.
====

[[usb-disks]]
== USB устройства хранения

Множество современных устройств хранения используют Universal Serial Bus (USB): жесткие диски, брелоки USB, CD-R приводы, и т.д. FreeBSD предоставляет поддержку этих устройств.

=== Настройка

Драйвер man:umass[4] предоставляет поддержку устройств хранения USB. Если вы используете [.filename]#GENERIC# ядро, изменять что-либо в настройках не потребуется. Если вы используете настроенное ядро, убедитесь, что в файле настройки присутствуют следующие строки:

[.programlisting]
....
device scbus
device da
device pass
device uhci
device ohci
device ehci
device usb
device umass
....

Для доступа к устройствам хранения USB драйвер man:umass[4] использует подсистему SCSI, ваши устройства USB будут видны системе как SCSI устройства. В зависимости от чипсета USB на материнской плате, для включения поддержки USB 1.X вам потребуется только один из параметров `device uhci` или `device ohci`. Однако, наличие обоих этих параметров не помешает. Поддержка контроллеров USB 2.0 предоставляется драйвером man:ehci[4] (строка `device ehci`). Не забудьте скомпилировать и установить новое ядро после добавления каких-либо строк.

[NOTE]
====
Если ваше USB устройство это пишущий привод CD-R или DVD, необходимо добавить в ядро SCSI CD-ROM драйвер, man:cd[4], следующей строкой:

[.programlisting]
....
device cd
....

Поскольку устройство записи видно как SCSI диск, драйвер man:atapicam[4] не должен использоваться в файле настройки.
====

=== Тестирование конфигурации

Конфигурация готова к тестированию, подключите устройство USB, и в буфере системных сообщений (man:dmesg[8]), диск должен отобразиться примерно так:

[source,bash]
....
umass0: USB Solid state disk, rev 1.10/1.00, addr 2
GEOM: create disk da0 dp=0xc2d74850
da0 at umass-sim0 bus 0 target 0 lun 0
da0: <Generic Traveling Disk 1.11> Removable Direct Access SCSI-2 device
da0: 1.000MB/s transfers
da0: 126MB (258048 512 byte sectors: 64H 32S/T 126C)
....

Конечно, производитель, имя устройства ([.filename]#da0#) и другие детали могут отличаться в зависимости от конфигурации.

Поскольку устройство USB видится как SCSI, команда `camcontrol` может быть использована для вывода списка устройств хранения USB, подключенных к системе:

[source,bash]
....
# camcontrol devlist
<Generic Traveling Disk 1.11>      at scbus0 target 0 lun 0 (da0,pass0)
....

Если на диске есть файловая система, у вас должна быть возможность смонтировать ее. <<disks-adding>> поможет вам создать и отформатировать разделы на диске USB если потребуется.

[WARNING]
====

Ниже описанный механизм (`vfs.usermount`), допускающий монтирование случайных носителей пользователями, не являющимися доверенными, считается небезопасным. Большинство файловых систем во FreeBSD никак не ограждено от возможности _несанкционированного_ монтирования устройств.
====

Чтобы это устройство мог смонтировать обычный пользователь, необходимо выполнить определенные действия. Для начала, необходимо дать обычным пользователям доступ к устройствам, создаваемым при подключении USB устройства. Решение состоит во включении всех пользователей данных устройств в группу `operator`. Это делается утилитой man:pw[8]. Затем, когда устройства созданы, у группы `operator` должен быть доступ на чтение и запись для этих устройств. Это выполняется путем добавления следующих строк в [.filename]#/etc/devfs.rules#:

[.programlisting]
....
[localrules=5]
add path 'da*' mode 0660 group operator
....

[NOTE]
====
Если к системе подключены SCSI диски, это должно быть сделано немного иначе. Так, если в системе уже есть диски с [.filename]#da0# по [.filename]#da2#, вторая строка должна выглядеть так:

[.programlisting]
....
add path 'da[3-9]*' mode 0660 group operator
....

Это исключит уже существующие диски из группы `operator`.
====

Вам также потребуется включить набор правил man:devfs.rules[5] в файл [.filename]#/etc/rc.conf#:

[.programlisting]
....
devfs_system_ruleset="localrules"
....

Затем, ядро необходимо настроить так, чтобы оно позволяло обычным пользователям монтировать файловые системы. Простейший способ сделать это - добавить в файл [.filename]#/etc/sysctl.conf# следующую строку:

[.programlisting]
....
vfs.usermount=1
....

Этот параметр установится только после последующей перезагрузки. Для установки этой переменной можно также использовать man:sysctl[8].

Последний шаг - создание каталога, куда будет монтироваться файловая система. Каталог должен принадлежать пользователю, монтирующему файловую систему. Один из способов сделать это под пользователем `root` - создать каталог [.filename]#/mnt/username# (замените _username_ именем пользователя, а _usergroup_ - именем главной группы пользователя):

[source,bash]
....
# mkdir /mnt/username
# chown username:usergroup /mnt/username
....

Предположим, что USB брелок подключен, и появилось устройство [.filename]#/dev/da0s1#. Поскольку эти устройства обычно поставляются форматированными с файловой системой FAT, их можно смонтировать так:

[source,bash]
....
% mount -t msdosfs -o -m=644,-M=755 /dev/da0s1 /mnt/username
....

Если вы отключите устройство (диск должен быть сначала размонтирован), вы должны увидеть в буфере системных сообщений что-то подобное:

[source,bash]
....
umass0: at uhub0 port 1 (addr 2) disconnected
(da0:umass-sim0:0:0:0): lost device
(da0:umass-sim0:0:0:0): removing device entry
GEOM: destroy disk da0 dp=0xc2d74850
umass0: detached
....

=== Дополнительная информация

Помимо разделов <<disks-adding,Добавление дисков>> и crossref:basics[mount-unmount,Монтирование и размонтирование файловых систем], также может быть полезно чтение различных страниц справочника: man:umass[4], man:camcontrol[8], и man:usbconfig[8] для FreeBSD 8.X или man:usbdevs[8] для более ранних версий FreeBSD.

[[creating-cds]]
== Запись и использование оптических носителей (CD)

=== Введение

Компакт-диски (CD) имеют несколько особенностей, отличающих их от обычных дисков. Во-первых, на них невозможно производить запись. Они спроектированы с расчетом на то, что их можно читать последовательно без задержек на перемещение головки между дорожками. К тому же их гораздо проще переносить от системы к системе, чем носители близкого объема.

У CD имеются дорожки, но они представляют собой последовательность данных, читаемую последовательно, и не являются физической характеристикой диска. Для записи CD во FreeBSD вы готовите файлы данных, которые будут формировать дорожки на компакт-диске, а затем записываете дорожки на CD.

Файловая система ISO 9660 была разработана с учетом этих отличий, К сожалению, она унаследовала ограничения файловых систем, которые были тогда. К счастью, она дает механизм расширений, которые позволяют правильно записанным дискам обходить эти ограничения и при этом продолжать работать с системами, которые не поддерживают эти расширения.

Для создания файла данных, содержащего файловую систему ISO 9660, используется программа man:mkisofs[8], которая включена в порт package:sysutils/cdrtools[]. Она имеет опции, поддерживающие различные расширения, и описана ниже.

Какой инструмент использовать для записи CD, зависит от того, является ли ваше устройство для записи CD устройством ATAPI или каким-либо другим. С устройствами для записи стандарта ATAPI используется программа `burncd`, которая является частью комплекта поставки системы. С устройствами SCSI и USB нужно использовать `cdrecord` из порта package:sysutils/cdrtools[]. Утилиту `cdrecord` и другие инструменты для SCSI-приводов также можно использовать при работе с ATAPI-оборудованием через <<atapicam,модуль ATAPI/CAM>>.

Если для записи CD вам нужна программа с графическим интерфейсом пользователя, взгляните на X-CD-Roast или K3b. Они доступны в виде пакетов или из портов package:sysutils/xcdroast[] и package:sysutils/k3b[]. Программам X-CD-Roast и K3b для работы с оборудованием ATAPI требуется <<atapicam,модуль ATAPI/CAM>>.

[[mkisofs]]
=== mkisofs

Программа man:mkisofs[8], поставляемая с портом package:sysutils/cdrtools[] создаёт файловую систему ISO 9660, которая является образом дерева каталогов в пространстве имён файловой системы UNIX(R). В самом простом случае она используется так:

[source,bash]
....
# mkisofs -o imagefile.iso /path/to/tree
....

Эта команда создаст файл _imagefile.iso_, содержащий файловую систему ISO 9660, которая является копией дерева каталогов _/path/to/tree_. Во время работы она будет преобразовывать имена файлов в имена, которые удовлетворяют ограничениям файловой системы ISO 9660, и исключит файлы, которые носят имена, неподходящие для файловой системы ISO.

Для того, чтобы обойти эти ограничения, имеется несколько опций. В частности, `-R` включает использование расширений Rock Ridge, распространенных в UNIX(R)-системах, с `-J` будут применены расширения Joliet, используемые в системах от Microsoft, а `-hfs` может использоваться для создания файловых систем HFS, используемых в Mac OS(R).

Для CD, которые будут использоваться только с системами FreeBSD, может использоваться опция `-U`, отменяющая все ограничения на имена файлов. При использовании с опцией `-R` генерируется образ файловой системы, идентичный начальному дереву FreeBSD, хотя при этом стандарт ISO 9660 может нарушаться в нескольких местах.

Последней часто используемой опцией является `-b`. Она используется для указания загрузочного образа для использования при создании загрузочного CD в стандарте "El Torito". Этой опции указывается аргумент, который является маршрутом к загрузочному образу из корня дерева, записываемого на CD. По умолчанию, man:mkisofs[8] создает образ ISO в так называемом режиме "эмуляции флоппи-диска", и потому ожидает загрузочный образ размера строго 1200, 1440 или 2880 KB. Некоторые загрузчики, в том числе и тот, что используется на дистрибутивных дисках FreeBSD, не используют режим эмуляции; в этом случае должна использоваться опция `-no-emul-boot`. Так что, если [.filename]#/tmp/myboot# содержит загрузочную систему FreeBSD с загрузочным образом в [.filename]#/tmp/myboot/boot/cdboot#, вы можете создать образ файловой системы ISO 9660 в [.filename]#/tmp/bootable.iso# следующим образом:

[source,bash]
....
# mkisofs -R -no-emul-boot -b boot/cdboot -o /tmp/bootable.iso /tmp/myboot
....

Сделав это, и имея в ядре отконфигурированное устройство [.filename]#md#, вы можете смонтировать файловую систему, выполнив:

[source,bash]
....
# mdconfig -a -t vnode -f /tmp/bootable.iso -u 0
# mount -t cd9660 /dev/md0 /mnt
....

В этот момент вы можете проверить, что [.filename]#/mnt# и [.filename]#/tmp/myboot# идентичны.

Имеется много других опций, которые можно использовать с программой man:mkisofs[8] для тонкой настройки её поведения. В частности: модификации в размещении ISO 9660 и создание дисков в форматах Joliet и HFS. Обратитесь к справочным страницам по man:mkisofs[8] для получения более подробной информации.

[[burncd]]
=== burncd

Если ваше устройство для записи CD соответствует стандарту ATAPI, то для записи ISO-образа на компакт-диск вы можете воспользоваться командой `burncd`. `burncd` входит в базовый комплект операционной системы и установлена как [.filename]#/usr/sbin/burncd#. Использовать её очень просто, так как параметров у ней немного:

[source,bash]
....
# burncd -f cddevice data imagefile.iso fixate
....

По этой команде файл _imagefile.iso_ будет скопирован на _cddevice_. По умолчанию используется устройство [.filename]#/dev/acd0#. Для получения информации о параметрах, задающих скорость записи, выброс диска после записи и запись звуковых данных, обратитесь к man:burncd[8].

[[cdrecord]]
=== cdrecord

Если ваше устройство для записи CD не соответствует стандарту ATAPI, то для записи компакт-дисков вам нужно пользоваться программой `cdrecord`. `cdrecord` не входит в комплект поставки системы; вы должны установить её из порта package:sysutils/cdrtools[] или из соответствующего пакета. Изменения в системе могут приводить к тому, что откомпилированные версии этой программы работать не будут, или приводить к порче дисков. Поэтому вы должны при обновлении системы либо обновить порт, либо, если вы crossref:cutting-edge[stable,следуете -STABLE], обновить порт при появлении его новой версии.

Хотя `cdrecord` имеет много опций, в основном использовать её ещё проще, чем `burncd`. Запись образа ISO 9660 делается такой командой:

[source,bash]
....
# cdrecord dev=device imagefile.iso
....

Тонким моментом при использовании `cdrecord` является определение правильного устройства `dev`. Чтобы задать параметр правильно, воспользуйтесь флагом `-scanbus` команды `cdrecord`, в результате чего может получиться примерно такой результат:

[source,bash]
....
# cdrecord -scanbus
Cdrecord-Clone 2.01 (i386-unknown-freebsd7.0) Copyright (C) 1995-2004 J"org Schilling
Using libscg version 'schily-0.1'
scsibus0:
	0,0,0     0) 'SEAGATE ' 'ST39236LW       ' '0004' Disk
	0,1,0     1) 'SEAGATE ' 'ST39173W        ' '5958' Disk
	0,2,0     2) *
	0,3,0     3) 'iomega  ' 'jaz 1GB         ' 'J.86' Removable Disk
	0,4,0     4) 'NEC     ' 'CD-ROM DRIVE:466' '1.26' Removable CD-ROM
	0,5,0     5) *
	0,6,0     6) *
	0,7,0     7) *
scsibus1:
	1,0,0   100) *
	1,1,0   101) *
	1,2,0   102) *
	1,3,0   103) *
	1,4,0   104) *
	1,5,0   105) 'YAMAHA  ' 'CRW4260         ' '1.0q' Removable CD-ROM
	1,6,0   106) 'ARTEC   ' 'AM12S           ' '1.06' Scanner
	1,7,0   107) *
....

Здесь приведены соответствующие значения параметров `dev` для имеющихся устройств. Найдите здесь ваше устройство для записи CD, а в качестве параметров для `dev` задавайте три числа через запятые. В нашем случае CRW-устройству соответствуют числа 1,5,0, так что правильным параметром будет `dev=1,5,0`. Имеется более простой способ задать эти значения; обратитесь к справочной информации о man:cdrecord[1] для выяснения подробностей. Там же находится информация о записи звуковых дорожек, управлении скоростью и другим вещам.

[[duplicating-audiocds]]
=== Копирование аудио CD

Вы можете копировать музыкальные CD, извлекая данные аудио с CD в набор файлов, а затем записывая эти файлы на чистый CD. Процесс несколько различен в случаях использования устройств ATAPI и SCSI.

[.procedure]
====
*Procedure: Устройства SCSI*

. Используйте `cdda2wav` для извлечения данных аудио.
+
[source,bash]
....
% cdda2wav -vall -D2,0 -B -Owav
....
+
. Воспользуйтесь `cdrecord` для записи файлов [.filename]#.wav#.
+
[source,bash]
....
% cdrecord -v dev=2,0 -dao -useinfo  *.wav
....
+ 
Значение, соответствующее _2,0_, должно быть установлено правильно, как это описано в <<cdrecord>>.
====

[.procedure]
====
*Procedure: Устройства ATAPI*

[NOTE]
======
На приводах ATAPI также можно использовать утилиту `cdda2wav`. Для её функционирования потребуется <<atapicam,драйвер ATAPI/CAM>>. Следует отметить, что данная утилита предназначена для корректного извлечения и обработки аудио данных, в отличие от утилиты, приведенной в нижеследующем примере.
======

. Драйвер устройств ATAPI CD делает каждую дорожку доступной как [.filename]#/dev/acddtnn#, где _d_ является номером привода, а _nn_ соответствует номеру дорожки, который записывается двумя десятичными цифрами с нулём в начале, если это нужно. Таким образом, первая дорожка на первом диске будет носить имя [.filename]#/dev/acd0t01#, вторая будет именоваться [.filename]#/dev/acd0t02#, третья будет носить имя [.filename]#/dev/acd0t03# и так далее.
+ 
Удостоверьтесь, что соответствующий файл имеется в каталоге [.filename]#/dev#. При его отсутствии следует принудительно перечитать оглавление диска:
+
[source,bash]
....
# dd if=/dev/acd0 of=/dev/null count=1
....
+
. Извлеките каждую дорожку при помощи команды man:dd[1]. При извлечении файлов вы должны также использовать специфическое значение для размера блока.
+
[source,bash]
....
# dd if=/dev/acd0t01 of=track1.cdr bs=2352
# dd if=/dev/acd0t02 of=track2.cdr bs=2352
...
....
+
. Запишите извлечённые файлы на диск при помощи утилиты `burncd`. Вы должны указать, что это файлы с аудио, и что `burncd` должна зафиксировать диск по окончании работы.
+
[source,bash]
....
# burncd -f /dev/acd0 audio track1.cdr track2.cdr ... fixate
....
====

[[imaging-cd]]
=== Копирование компакт-дисков с данными

Вы можете скопировать CD с данными в файл образа, который функционально эквивалентен файлу образа, созданному командой man:mkisofs[8], и вы можете использовать его для копирования любого CD с данными. В приводимом здесь примере предполагается, что ваш привод CDROM называется [.filename]#acd0#. Подставьте название вашего привода CDROM.

[source,bash]
....
# dd if=/dev/acd0 of=file.iso bs=2048
....

Теперь, когда вы имеете образ, вы можете записать его на CD так, как это описано выше.

[[mounting-cd]]
=== Использование компакт-диски с данными

Теперь, после того, как вы создали стандартный CDROM с данными, вы, наверное, захотите смонтировать его и считать с него данные. По умолчанию man:mount[8] предполагает, что файловая система имеет тип `ufs`. Если вы попытаетесь выполнить что-то вроде:

[source,bash]
....
# mount /dev/cd0 /mnt
....

вы получите сообщение `Incorrect super block`, и диск не смонтируется. CDROM не является файловой системой `UFS`, поэтому попытки смонтировать его таким образом будут терпеть неудачу. Вам просто нужно указать команде man:mount[8], что файловая система имеет тип `ISO9660`, и всё должно заработать. Сделайте это, задав параметр `-t cd9660` при вызове man:mount[8]. К примеру, если вы хотите смонтировать устройство CDROM, [.filename]#/dev/cd0#, в каталог [.filename]#/mnt#, вы должны выполнить:

[source,bash]
....
# mount -t cd9660 /dev/cd0 /mnt
....

Заметьте, что имя вашего устройства ([.filename]#/dev/cd0# в этом примере) может быть другим, в зависимости от интерфейса, используемого в CDROM. Кроме того, параметр `-t cd9660` всего лишь задаёт выполнение утилиты man:mount_cd9660[8]. Пример выше может быть упрощён до:

[source,bash]
....
# mount_cd9660 /dev/cd0c /mnt
....

Таким способом, вообще говоря, вы можете использовать компакт-диски любого производителя. Диски с некоторыми расширениями ISO 9660 могут, однако, работать со странностями. К примеру диски Joliet хранят все имена файлов в виде последовательностей двухбайтовых символов Unicode. Ядро FreeBSD не может работать с Unicode, но CD9660 драйвер способен преобразовывать Unicode символы на лету. Если некоторые символы не английского алфавита выглядят, как знаки вопроса, то вам нужно указать используемую вами кодировку с помощью опции `-C`. За дополнительной информацией, обращайтесь к странице справочника man:mount_cd9660[8].

[NOTE]
====
Чтобы смочь произвести преобразование символов посредством опции `-C`, ядру понадобится загрузить модуль [.filename]#cd9660_iconv.ko#. Это может быть сделано либо добавлением ниже представленной строчки в [.filename]#loader.conf#:

[.programlisting]
....
cd9660_iconv_load="YES"
....

с последующей перезагрузкой машины, либо загрузкой модуля вручную с помощью man:kldload[8].
====

Время от времени вы можете получать сообщения `Device not configured` при попытке смонтировать CDROM. Это обычно означает, что привод CDROM полагает, что в нём нет диска, или что привод не виден на шине. Приводу CDROM может понадобиться несколько секунд, чтобы понять, что он был закрыт, так что будьте терпеливы.

Иногда SCSI CDROM может потеряться из-за того, что у него не было достаточно времени, чтобы ответить на сброс шины. Если у вас имеется SCSI CDROM, то, пожалуйста, добавьте следующий параметр в конфигурацию вашего ядра и crossref:kernelconfig[kernelconfig-building,перестройте его].

[.programlisting]
....
options SCSI_DELAY=15000
....

Это укажет вашей шине SCSI выдерживать 15-секундную паузу во время загрузки, чтобы дать вашему приводу CDROM шанс ответить на сброс шины.

[[rawdata-cd]]
=== Запись необработанных данных на компакт-диски

Вы можете предпочесть запись файла непосредственно на CD без создания файловой системы ISO 9660. Некоторые поступают так при создании резервных копий. Это выполняется гораздо быстрее. чем запись стандартного компакт-диска:

[source,bash]
....
# burncd -f /dev/acd1 -s 12 data archive.tar.gz fixate
....

Для извлечения данных, записанных так на компакт-диск, вы должны считывать данные из файла непосредственного доступа к устройству:

[source,bash]
....
# tar xzvf /dev/acd1
....

Вы не можете монтировать этот диск как обычный CDROM. Такой компакт-диск не может быть прочитан ни в какой другой операционной системе, кроме FreeBSD. Если вы хотите монтировать CD или обменяться данными с другой операционной системой, то вы должны использовать man:mkisofs[8] так, как это было описано выше.

[[atapicam]]
=== Использование драйвера ATAPI/CAM

Этот драйвер позволяет работать с ATAPI-устройствами (приводы CD-ROM, CD-RW, DVD и так далее) через подсистему SCSI, таким образом расширяя использование таких приложений, как package:sysutils/cdrdao[] или man:cdrecord[1].

Для использования этого драйвера вам необходимо добавить в файл [.filename]#/boot/loader.conf# следующую строку:

[.programlisting]
....
atapicam_load="YES"
....

с последующей перезагрузкой машины.

[NOTE]
====
Если для вас предпочтительнее статически скомпилировать поддержку man:atapicam[4] в ядро, то добавьте эту строчку в файл конфигурации ядра:

[.programlisting]
....
device atapicam
....

Кроме того, в файле конфигурации ядра должны быть следующие строки:

[.programlisting]
....
device ata
device scbus
device cd
device pass
....

которые уже должны там присутствовать. Затем пересоберите, установите новое ядро и перезагрузите компьютер.
====

В процессе загрузки ваш пишущий привод должен появиться примерно следующим образом:

[source,bash]
....
acd0: CD-RW <MATSHITA CD-RW/DVD-ROM UJDA740> at ata1-master PIO4
cd0 at ata1 bus 0 target 0 lun 0
cd0: <MATSHITA CDRW/DVD UJDA740 1.00> Removable CD-ROM SCSI-0 device
cd0: 16.000MB/s transfers
cd0: Attempt to query device size failed: NOT READY, Medium not present - tray closed
....

Теперь с ним можно работать через устройство [.filename]#/dev/cd0#, например, чтобы смонтировать CD-ROM в каталог [.filename]#/mnt#, просто наберите следующую команду:

[source,bash]
....
# mount -t cd9660 /dev/cd0 /mnt
....

Для получения SCSI-адреса пишущего привода, вы можете, работая как пользователь `root`, запустить такую команду:

[source,bash]
....
# camcontrol devlist
<MATSHITA CDRW/DVD UJDA740 1.00>   at scbus1 target 0 lun 0 (pass0,cd0)
....

Таким образом, `1,0,0` будет SCSI-адресом для использования с man:cdrecord[1] и другими приложениями для работы со SCSI.

Для получения дополнительной информации об ATAPI/CAM и системе SCSI, обратитесь к страницам справочной системы по man:atapicam[4] и man:cam[4].

[[creating-dvds]]
== Создание и использование оптических носителей (DVD)

=== Введение

DVD это следующее после CD поколение оптических носителей. DVD может вмещать больше данных чем любой CD и является современным стандартом распространения видео.

Для записываемых DVD существует пять физических форматов записи:

* DVD-R: Был первым форматом записываемых DVD. Стандарт DVD-R был создан http://www.dvdforum.com/forum.shtml[DVD Forum]. Это формат для однократной записи.
* DVD-RW: Это перезаписываемая версия стандарта DVD-R. Носители DVD-RW могут быть перезаписаны около 1000 раз.
* DVD-RAM: Это также перезаписываемый формат, поддерживаемый DVD Forum. DVD-RAM может быть виден как съемный жесткий диск. Однако, этот носитель не совместим с большинством приводов DVD-ROM и проигрывателями DVD-Video; лишь некоторые пишущие DVD поддерживают формат DVD-RAM. Более подробно о работе с DVD-RAM можно прочитать в разделе <<creating-dvd-ram>>.
* DVD+RW: Это перезаписываемый формат, созданный http://www.dvdrw.com/[DVD+RW Alliance]. Носитель DVD+RW может быть перезаписан около 1000 раз.
* DVD+R: Этот формат - однократно записываемая версия формата DVD+RW.

Однослойный записываемый DVD может хранить до 4,700,000,000 байт, что равно 4.38 Гбайт, или 4485 Мбайт (1 килобайт это 1024 байт).

[NOTE]
====
Необходимо различать физический носитель и приложение. Например, DVD-Video это определенная файловая раскладка, которая может быть помещена на записываемый DVD любого физического формата: DVD-R, DVD+R, DVD-RW и т.д. Перед выбором типа носителя вы должны убедиться, что и устройство записи и DVD-Video проигрыватель (отдельный или DVD-ROM привод компьютера) совместимы с данным носителем.
====

=== Настройка

Для записи DVD будет использоваться программа man:growisofs[1]. Эта команда входит в набор утилит dvd+rw-tools (package:sysutils/dvd+rw-tools[]), который поддерживает все типы носителей DVD.

Эти утилиты используют подсистему SCSI для доступа к устройствам, следовательно необходимо добавить в ядро <<atapicam,поддержку ATAPI/CAM>>. Если пишущий привод использует USB интерфейс, это добавление бесполезно и необходимо прочесть более подробную информацию по настройке устройств USB в <<usb-disks>>

Вам также потребуется включить DMA доступ для устройств ATAPI, это можно сделать добавив в [.filename]#/boot/loader.conf# следующую строку:

[.programlisting]
....
hw.ata.atapi_dma="1"
....

Перед использованием dvd+rw-tools вы должны свериться со http://fy.chalmers.se/~appro/linux/DVD+RW/hcn.html[списком совместимого оборудования dvd+rw-tools] с информацией по устройствам для записи DVD.

[NOTE]
====
Если вам нужен графический интерфейс пользователя, взгляните на K3b (package:sysutils/k3b[]), который предоставляет дружественный пользователю интерфейс к man:growisofs[1] и многим другим программам записи.
====

=== Запись DVD с данными

Команда man:growisofs[1] является оболочкой для <<mkisofs,mkisofs>>, она вызовет man:mkisofs[8] для создания файловой системы и запишет DVD. Это означает, что вам не потребуется создавать образ с данными перед началом процесса записи.

Для записи данных из каталога [.filename]#/path/to/data# на DVD+R или DVD-R, используйте следующую команду:

[source,bash]
....
# growisofs -dvd-compat -Z /dev/cd0 -J -R /path/to/data
....

Параметры `-J -R` передаются man:mkisofs[8] для создания файловой системы (в данном случае: файловая система ISO 9660 с расширениями Joliet и Rock Ridge), обратитесь к странице справочника man:mkisofs[8] за более подробной информацией.

Параметр `-Z` используется для первой сессии записи в любом случае: для одной или нескольких сессий. Устройство DVD, _/dev/cd0_, должно быть изменено в соответствии с имеющимися настройками. Параметр `-dvd-compat` закроет диск и дозапись станет невозможна. Это должно улучшить совместимость с приводами DVD-ROM.

Возможна также запись предварительного (pre-mastered) образа, например, для записи _imagefile.iso_ запустим:

[source,bash]
....
# growisofs -dvd-compat -Z /dev/cd0=imagefile.iso
....

Скорость записи должна быть определена и автоматически установлена в соответствии с носителем и приводом. Если вы хотите явно указать скорость записи, используйте параметр `-speed=`. За дальнейшей информацией обратитесь к странице справочника man:growisofs[1].

[NOTE]
====
Если размер файлов внутри набора превышает 4.38Гб, то необходимо будет создать гибридную файловую систему UDF/ISO-9660, для чего потребуется передать параметры `-udf -iso-level 3` в man:mkisofs[8] и в остальные соответствующие программы (например, man:growisofs[1]). Указание параметров обязательно лишь во время создания файла образа или во время непосредственной записи на диск. Созданный таким способом диск должен монтироваться утилитой man:mount_udf[8]. Диск будет доступен лишь тем операционным системам, которые поддерживают UDF; в противном случае носитель будет отображаться как поврежденный.

Для того, чтобы создать такой образ, выполните:

[source,bash]
....
% mkisofs -R -J -udf -iso-level 3 -o imagefile.iso /path/to/data
....

Для того, чтобы записать файлы прямо на диск, наберите:

[source,bash]
....
# growisofs -dvd-compat -udf -iso-level 3 -Z /dev/cd0 -J -R /path/to/data
....

Если у вас в распоряжении уже имеется образ, содержащий в себе файлы большого размера, то для записи образа на диск никаких дополнительных опций для man:growisofs[1] не потребуется.

Также удостоверьтесь, что у вас установлена последняя версия package:sysutils/cdrtools[] (man:mkisofs[8] принадлежит к этому порту), поскольку предыдущие версии утилит не поддерживают работу с большими файлами. Если с этим портом возникают проблемы, то установите package:sysutils/cdrtools-devel[] и прочитайте страницу справочника man:mkisofs[8].
====

=== Запись DVD-Video

DVD-Video это особая файловая система, базирующаяся на ISO 9660 и спецификациях micro-UDF (M-UDF). DVD-Video также представляет определенную иерархию структуры данных, поэтому для создания DVD потребуется особая программа, такая как package:multimedia/dvdauthor[].

Если у вас уже есть образ файловой системы DVD-Video, просто запишите его как любой другой образ, примеры находятся в предыдущем разделе. Если вы создали DVD и результат находится в каталоге [.filename]#/path/to/video#, для записи DVD-Video должна быть использована следующая команда:

[source,bash]
....
# growisofs -Z /dev/cd0 -dvd-video /path/to/video
....

Параметр `-dvd-video` будет передан man:mkisofs[8] и укажет создать файловую систему DVD-Video. Помимо этого, параметр `-dvd-video` подразумевает параметр man:growisofs[1] `-dvd-compat`.

=== Использование DVD+RW

В отличие от CD-RW, новый DVD+RW необходимо отформатировать перед первым использованием. Программа man:growisofs[1] позаботится об этом сама при необходимости, и это _рекомендованный_ способ. Тем не менее, для форматирования DVD+RW вы можете использовать команду `dvd+rw-format`:

[source,bash]
....
# dvd+rw-format /dev/cd0
....

Эту операцию необходимо выполнить лишь однажды, помните, что только новые носители DVD+RW необходимо форматировать. Затем запишите DVD+RW тем способом, который описан в предыдущем разделе.

Если вы хотите записать новые данные (полностью новую файловую систему, а не дописать данные) на DVD+RW, его не нужно очищать, просто запишите поверх предыдущей записи (создав новую начальную сессию) примерно так :

[source,bash]
....
# growisofs -Z /dev/cd0 -J -R /path/to/newdata
....

Формат DVD+RW делает возможным легко дописать данные к предыдущей записи. Операция состоит в присоединении предыдущей сессии к существующей, это не мультисессионная запись, man:growisofs[1] _расширит_ (grow) файловую систему ISO 9660, существующую на носителе.

Например, для дозаписи данных к предыдущей сессии на DVD+RW, используется следующая команда:

[source,bash]
....
# growisofs -M /dev/cd0 -J -R /path/to/nextdata
....

При последующих записях man:mkisofs[8] необходимо передавать те же параметры, что и при первой записи.

[NOTE]
====
Вы можете использовать параметр `-dvd-compat` для улучшения совместимости с приводами DVD-ROM. В случае DVD+RW это не помешает добавлению данных.
====

Если по какой-либо причине вам потребуется очистить носитель, используйте следующую команду:

[source,bash]
....
# growisofs -Z /dev/cd0=/dev/zero
....

=== Использование DVD-RW

Существует два формата дисков DVD-RW: последовательно дополняемый и с ограниченной перезаписью. По умолчанию формат дисков DVD-RW последовательный.

Новый DVD-RW может быть записан непосредственно без необходимости форматирования, однако DVD-RW с данными в последовательном формате необходимо очистить перед созданием новой начальной сессии.

Для очистки DVD-RW в последовательном формате, запустите:

[source,bash]
....
# dvd+rw-format -blank=full /dev/cd0
....

[NOTE]
====
Полная очистка (`-blank=full`) займет около одного часа на скорости 1x. Быструю очистку можно выполнить с параметром `-blank`, если DVD-RW будет записан в режиме Disk-At-Once (DAO). Для записи DVD-RW в режиме DAO, используйте команду:

[source,bash]
....
# growisofs -use-the-force-luke=dao -Z /dev/cd0=imagefile.iso
....

Параметр `-use-the-force-luke=dao` не должен потребоваться, поскольку man:growisofs[1] попытается определить был ли носитель быстро очищен и включить DAO запись.

Фактически, лучше использовать режим с ограниченной перезаписью с любым DVD-RW, этот формат более гибкий, чем формат по умолчанию с последовательной записью.
====

Для записи данных на последовательный DVD-RW, используйте ту же команду, что и для других форматов DVD:

[source,bash]
....
# growisofs -Z /dev/cd0 -J -R /path/to/data
....

Если вы хотите добавить данные к предыдущей записи, используйте параметр man:growisofs[1] `-M`. Однако при добавлении данных на DVD-RW в последовательном режиме, на диске будет создана новая сессия и в результате получится мультисессионный диск.

В формате DVD-RW с ограниченной перезаписью не требуется очищать носитель перед созданием новой начальной сессии, вам всего лишь нужно переписать диск с параметром `-Z`, подобно DVD+RW. Возможно также увеличение существующей файловой системы ISO 9660, записанной на диск тем же способом, как для DVD+RW с параметром `-M`. В результате получится односессионный DVD.

Для перевода DVD-RW в формат с ограниченной перезаписью, необходимо использовать следующую команду:

[source,bash]
....
# dvd+rw-format /dev/cd0
....

Для перевода обратно в последовательный формат, выполните:

[source,bash]
....
# dvd+rw-format -blank=full /dev/cd0
....

=== Мультисессия

Лишь несколько DVD-ROM и проигрывателей поддерживают мультисессионные DVD, в основном они в лучшем случае прочтут только первую сессию. DVD+R, DVD-R и DVD-RW в последовательном формате могут работать с несколькими сессиями, и это не относится к форматам DVD+RW и DVD-RW в формате ограниченной перезаписи.

Использование следующей команды после первой (не закрытой) сессии для DVD+R, DVD-R, или DVD-RW в последовательном формате, добавит на диск новую сессию:

[source,bash]
....
# growisofs -M /dev/cd0 -J -R /path/to/nextdata
....

Использование этой командной строки с DVD+RW или DVD-RW в режиме ограниченной перезаписи добавит данные, объединив новую сессию с предыдущей. В результате получится односессионный диск. Такой способ используется для добавления данных после первой записи на эти носители.

[NOTE]
====
Некоторый объем носителя используется между сессиями для завершения и начала сессии. Следовательно, для оптимизации объема хранения сессии должны быть большими. Количество сессий ограничено 154 для DVD+R, около 2000 для DVD-R и 127 для DVD+R Double Layer.
====

=== Дополнительная информация

Для получения дополнительной информации о DVD, можно запустить команду `dvd+rw-mediainfo _/dev/cd0_`, диск должен находиться в приводе.

Дополнительная информация о dvd+rw-tools может быть найдена на странице справочника man:growisofs[1], на http://fy.chalmers.se/~appro/linux/DVD+RW/[Web-сайте dvd+rw-tools] и в архивах http://lists.debian.org/cdwrite/[списка рассылки cdwrite].

[NOTE]
====
Вывод `dvd+rw-mediainfo` при записи или проблемный носитель необходимы для любого сообщения о проблеме. Без этого вывода будет совершенно невозможно помочь вам.
====

[[creating-dvd-ram]]
=== Использование DVD-RAM

==== Конфигурация

Записывающие устройства DVD-RAM поставляются с интерфейсами SCSI и ATAPI. В последнем случае вы должны убедиться, что для них включен режим DMA, добавив в файл [.filename]#/boot/loader.conf# строку

[.programlisting]
....
hw.ata.atapi_dma="1"
....

==== Подготовка носителя

Как указывалось ранее, DVD-RAM представляется съемным жестким диском. Как и другие дисковые устройства, DVD-RAM должен быть "подготовлен" к первому использованию. В нашем примере мы займём все пространство диска одной файловой системой UFS2:

[source,bash]
....
# dd if=/dev/zero of=/dev/acd0 bs=2k count=1
# bsdlabel -Bw acd0
# newfs /dev/acd0
....

Имя устройства DVD device, [.filename]#acd0#, должно соответствовать вашей конфигурации.

==== Использование носителя

После выполнения указанных выше команд, DVD-RAM может быть смонтирован как обычный жесткий диск:

[source,bash]
....
# mount /dev/acd0 /mnt
....

После этого вы можете читать и писать на DVD-RAM.

[[floppies]]
== Дискеты

Хранение данных на дискетах иногда бывает полезным, например, когда нет других съёмных носителей или когда необходимо перенести небольшой объём данных на другой компьютер.

В этом разделе будет описано, как использовать дискеты во FreeBSD. В основном речь пойдёт о форматировании и использовании дискет DOS размером 3.5 дюйма, однако общие принципы применимы и для других форматов гибких дисков.

=== Форматирование дискет

==== Устройство

Доступ к гибким дискам, как, впрочем, и к остальным устройствам, осуществляется через соответствующие файлы в каталога [.filename]#/dev#. Чтобы обратиться к дискете, просто используйте [.filename]#/dev/fdN#.

==== Форматирование

Перед тем, как дискетой можно будет воспользоваться, её необходимо отформатировать на низком уровне. Обычно это выполняется производителем, однако форматирование является хорошим способом проверить целостность носителя. Большинство гибких дисков предназначены для использования с размером 1440kB, однако возможно задать меньший или больший размер.

Для низкоуровневого форматирования дискет вам нужно использовать man:fdformat[1]. В качестве параметра этой утилите передаётся имя устройства.

Обратите внимание на появление сообщений об ошибках, так как они могут помочь определить, хорошая это дискета или плохая.

===== Форматирование гибких дисков

Для форматирования гибких дисков используйте устройства [.filename]#/dev/fdN#. Вставьте новую 3.5-дюймовую дискету в дисковод и введите команду:

[source,bash]
....
# /usr/sbin/fdformat -f 1440 /dev/fd0
....

=== Метка диска

После низкоуровневого форматирования диска вам нужно поместить на него метку диска. Эта метка будет потом разрушена, но она будет нужна системе для определения размера диска и его характеристик.

Новая метка диска будет касаться диска в целом, и будет содержать полную информацию о параметрах дискеты. Значения геометрии для метки диска перечислены в файле [.filename]#/etc/disktab#.

Теперь вы можете запустить man:bsdlabel[8] примерно так:

[source,bash]
....
# /sbin/bsdlabel -B -w /dev/fd0 fd1440
....

=== Файловая система

Теперь ваша дискета готова к высокоуровневому форматированию. При этом на неё будет помещаться новая файловая система, которая позволит FreeBSD читать и записывать информацию на диск. После создания новой файловой системы метка диска уничтожается, так что если вы захотите переформатировать диск, вам придётся создавать метку диска повторно.

Файловой системой для дискеты может служить UFS или FAT. Вообще говоря, FAT для дискет походит лучше.

Для размещения на дискете новой файловой системы, выполните:

[source,bash]
....
# /sbin/newfs_msdos /dev/fd0
....

Теперь диск готов к работе.

=== Использование дискет

Для работы с гибким диском смонтируйте его при помощи утилит man:mount_msdosfs[8]. Можно также использовать пакет package:emulators/mtools[] из коллекции портов.

[[backups-tapebackups]]
== Создание и использование архивных копий на магнитной ленте

К наиболее часто используемым носителям на магнитной ленте следует отнести ленты шириной 4мм и 8мм, а также типа QIC, мини-картриджи и DLT.

[[backups-tapebackups-4mm]]
=== 4мм (DDS: Digital Data Storage)

Ленты шириной 4мм заменяют QIC в качестве наиболее предпочтительного носителя для создания резервных копий. Эта тенденция значительно усилилась после покупки компанией Conner фирмы Archive, ведущего производителя накопителей QIC и последующего прекращения их выпуска. Накопители 4мм малы по размеру и мало шумят, но у них нет репутации носителя, обладающего надежностью приводов 8мм. Картриджи более дешевы и меньше по размеру (3 x 2 x 0.5 дюймов; 76 x 51 x 12 мм), чем 8мм-картриджи. Накопители для лент шириной 4мм, как и 8мм, имеют сравнительно малый срок службы головок, по причине использования в обоих случаях технологии спирального сканирования (helical scan).

Пропускная способность у таких накопителей начинается с цифры ~150 kB/s, пиковая достигает ~500 kB/s. Ёмкость накопителей начинается с 1.3 GB и может достигать 2.0 GB. Аппаратное сжатие, имеющееся на большинстве таких накопителей, даёт увеличение ёмкости примерно вдвое. Блоки многоприводных ленточных библиотек могут иметь до 6 накопителей в одном модуле с автоматической сменой ленты. Ёмкость библиотек может достигать 240 Гбайт.

Стандарт DDS-3 в настоящее время поддерживает ёмкости лент вплоть до 12 Гбайт (или 24 Гбайт сжатой информации).

В накопителях 4мм, как и в приводах 8мм, используется технология спирального сканирования. Все плюсы и минусы этой технологии относятся как к 4мм, так и 8мм приводам.

Не следует использовать ленты после того, как они были подвергнуты 2000 проходов, или были использованы для создания 100 полных копий.

[[backups-tapebackups-8mm]]
=== 8мм (Exabyte)

Ленты шириной 8мм являются самым распространённым типом для ленточных SCSI-накопителей; они же являются наиболее удачным выбором при выборе типа носителей для обмена лентами. Наверное, каждый сервер имеет привод Exabyte шириной 8мм и объёмом 2 Гбайт. Эти приводы удобны, они работают надёжно и тихо. Картриджи дешевы и малы по размеру (4.8 x 3.3 x 0.6 дюймов; 122 x 84 x 15 мм). Одним минусом лент шириной 8мм является сравнительно малое время службы головок и лент из-за высокой скорости движения ленты вдоль головок.

Скорость передачи данных варьируется от ~250 kB/s до ~500 kB/s. Объём хранимых данных начинается с 300 Мбайт и может достигать 7 Гбайт. Аппаратное сжатие, имеющееся практически на всех таких приводах, увеличивает емкость примерно вдвое. Эти приводы существуют как в виде отдельных модулей, так и в виде многоприводных ленточных библиотек с 6 приводами и 120 лентами в одном отсеке. Ленты сменяются автоматически модулем. Емкости библиотек достигают величин, превышающих 840 Гбайт.

Модель Exabyte "Mammoth" поддерживает ёмкость ленты в 12 Гбайт (24 Гбайт со сжатием) и стоит примерно вдвое больше, чем обычный ленточный накопитель.

Данные на ленту записываются по технологии спирального сканирования, головки позиционируются под углом к носителю (примерно в 6 градусов). Лента оборачивается на 270 градусов вокруг шпульки, которая держит головки. Во время скольжения ленты вокруг шпульки последняя вращается. В результате достигается высокая плотность записи данных с очень близко лежащими дорожками, расположенными под наклоном по всей ленте.

[[backups-tapebackups-qic]]
=== QIC

Ленты и накопители формата QIC-150, наверное, являются наиболее распространенным типом носителей. Приводы лент формата QIC являются самыми дешёвыми "серьёзными" накопителями для резервного копирования. Минусом является стоимость носителей. Ленты формата QIC по сравнению с лентами шириной 8мм или 4мм являются дорогими, превосходя их по стоимости хранения одного гигабайта в пять раз. Однако если вам будут достаточно половины ленты, QIC может оказаться правильным выбором. QIC является _самым_ распространенным типом привода. Каждый сайт имеет привод QIC какой-либо емкости. QIC имеет большое количество плотностей на физически похожих (иногда даже идентичных) лентах. Приводы QIC работают вовсе не тихо. Эти накопители громко осуществляют поиск перед тем, как начать запись данных и достаточно шумны в процессе чтения, записи или поиска. Ленты QIC имеют размеры (6 x 4 x 0.7 дюймов; 152 x 102 x 17 мм).

Скорость обмена данными лежит в границах от ~150 kB/s до ~500 kB/s. Ёмкость накопителей варьируется от 40 Мбайт до 15 Гбайт. Аппаратное сжатие присутствует во многих современных накопителях QIC. Приводы QIC устанавливаются менее часто; они вытесняются накопителями DAT.

На ленту данные записываются в виде дорожек. Дорожки располагаются в длину вдоль всей ленты. Количество дорожек, и, в свою очередь, их ширина, меняется вместе с емкостью ленты. Большинство, если не все современные накопители обеспечивают обратную совместимость по крайней мере для чтения (однако зачастую и для режима записи). Формат QIC имеет хорошую репутацию в области надежности хранения данных (механика устроена проще и более надежна, чем в случае накопителей, построенных по технологии спирального сканирования).

Ленты не следует больше использовать после создания 5,000 резервных копий.

[[backups-tapebackups-dlt]]
=== DLT

Формат DLT обладает самой высокой скоростью передачи данных среди всех перечисленных здесь накопителей. Лента шириной 1/2" (12.5мм) помещена в один картридж с катушкой (4 x 4 x 1 дюймов; 100 x 100 x 25 мм). Вдоль одной из сторон картриджа расположена сдвигающаяся крышечка. Механизм накопителя открывает эту крышку, чтобы вытащить конец ленты. На этом конце имеется овальное отверстие, которое используется для "захвата" ленты. Принимающая катушка размещена внутри накопителя. Все другие типы картриджей, перечисленные здесь (за исключением 9-дорожечных лент), имеют как подающий, так и принимающий барабаны внутри самого картриджа.

Скорость передачи данных равна примерно 1.5 MB/s, что в три раза больше скорости передачи данных для накопителей 4мм, 8мм или QIC. Ёмкость картриджей варьируется от 10 Гбайт до 20 Гбайт для одного накопителя. Приводы могут компоноваться как многоленточные роботизированные, так и многоленточные, многоприводные библиотеки лент, вмещающие от 5 до 900 лент и от 1 до 20 приводов, что даёт ёмкость хранилища от 50 Гбайт до 9 Тбайт.

Формат DLT Type IV поддерживает емкость до 70 Гбайт со сжатием.

Данные на ленту записываются в виде дорожек, параллельных направлению движения (точно также, как и для лент QIC). Одновременно записываются две дорожки. Срок жизни головок чтения/записи сравнительно велик; как только лента перестает двигаться, одновременно прекращается трение между головками и лентой.

=== AIT

AIT - это новый формат фирмы Sony, который позволяет хранить до 50 Гбайт (со сжатием) информации на одной ленте. Ленты содержат микросхемы памяти, на которых размещается каталог содержимого ленты. Этот каталог может быть быстро считан накопителем для определения расположения файлов на ленте, вместо того, чтобы тратить несколько минут на поиск, как это происходит с другими форматами. Такое программное обеспечение, как SAMS:Alexandria, может управлять сорока или большим количеством ленточных библиотек AIT, связываясь непосредственно с памятью лент для вывода их содержимого, определения того, какие файлы были скопированы на какую ленту, выбора нужной ленты, её загрузки и восстановления данных с ленты.

Библиотеки с такими функциями стоят в районе $20,000, выводя их из ниши любительского рынка.

=== Использование новой ленты первый раз

Если вы попытаетесь прочитать или записать новую, абсолютно чистую ленту, в первый раз, то вам это не удастся. Выводимые на консоль сообщения будут выглядеть примерно так:

[source,bash]
....
sa0(ncr1:4:0): NOT READY asc:4,1
sa0(ncr1:4:0):	Logical unit is in process of becoming ready
....

На ленте отсутствует идентификационный блок (блок номер 0). Со времен принятия стандарта QIC-525 все накопители формата QIC записывают на ленту идентификационный блок (Identifier Block). Здесь имеется два решения:

* По команде `mt fsf 1` ленточный накопитель записывает идентификационный блок на ленту.
* Воспользуйтесь кнопкой на передней панели для выброса ленты.
+ 
Вставьте ленту повторно и по команде `dump` сбросьте данные на ленту.
+ 
Программа `dump` выдаст `DUMP: End of tape detected`, а на консоли будет выведено: `HARDWARE FAILURE info:280 asc:80,96`.
+ 
перемотайте ленту такой командой: `mt rewind`.
+ 
Последующие операции с лентой будут успешными.

[[backups-floppybackups]]
== Создание резервных копий на дискетах

[[floppies-using]]
=== Можно ли использовать дискеты для создания резервных копий моих данных?

На самом деле дискеты не подходят для создания резервных копий, потому что:

* Носитель ненадёжен, особенно если речь идет о больших сроках хранения.
* Создание резервных копий и восстановление данных происходит очень медленно.
* Дискеты имеют весьма ограниченную емкость (дни, когда весь винчестер копировался на десяток или около того дискет, давно прошли).

Несмотря на все это, если у вас нет другого способа сделать резервную копию ваших данных, то дискеты все же лучше, чем ничего.

Если вы используете дискеты, то проверьте, что они должны быть хорошего качества. Дискеты, которые валялись по всему офису в течении нескольких лет, не подойдут. Идеально использовать новые от известного производителя.

[[floppies-creating]]
=== Итак, как же сделать резервную копию данных на дискетах?

Самым лучшим методом создания резервной копии на дискете является использование утилиты man:tar[1] с опцией `-M` (многотомные архивы), которая позволяет размещать архивы на нескольких дискетах.

Для копирования всех файлов в текущем каталоге и подкаталогах выполните следующее (работая как пользователь `root`):

[source,bash]
....
# tar Mcvf /dev/fd0 *
....

Когда первая дискета окажется полностью заполненной, программа man:tar[1] выдаст запрос на следующий том (так как работа утилиты man:tar[1] не зависит от носителя, она имеет дело с томами; здесь это означает дискету).

[source,bash]
....
Prepare volume 2 for /dev/fd0 and hit return:
....

Это сообщение будет повторяться (со все увеличивающимся номером тома) до тех пор, пока все указанные файлы не будут заархивированы.

[[floppies-compress]]
=== Можно ли резервные копии подвергнуть компрессии?

К сожалению, man:tar[1] при создании многотомных архивов не позволяет использовать опцию `-z`. Вы конечно же, можете скомпрессировать все файлы утилитой man:gzip[1], программой man:gzip[1] скопировать их на дискеты, а затем распаковать файлы снова утилитой man:gunzip[1]!

[[floppies-restoring]]
=== Как восстановить данные из моих резервных копий?

Для полного восстановления архива воспользуйтесь такой командой:

[source,bash]
....
# tar Mxvf /dev/fd0
....

Есть два подхода к восстановлению только нужных вам файлов. В первом вы можете начать с первой дискеты и выдать такую команду:

[source,bash]
....
# tar Mxvf /dev/fd0 filename
....

Программа man:tar[1] будет выдавать запрос на подачу последующих дискет до тех пор, пока не найдет требуемый файл.

Как альтернатива, если вы знаете, на какой дискете расположен файл, то вы можете просто подать ее и дать ту же самую команду, что и выше. Заметьте, что если первый файл на дискете является продолжением предыдущего, то man:tar[1] выдаст предупреждение о том, что не может его восстановить, хотя вы этого и не просили делать!

[[backup-strategies]]
== Стратегии резервного копирования

При разработке плана резервного копирования первым делом надо продумать методы защиты от следующих проблем:

* Отказ жесткого диска
* Случайное удаление файлов
* Повреждение содержимого файлов
* Полное уничтожение компьютера (например, при пожаре), при котором погибнут также резервные копии, физически находящиеся рядом.

Вполне возможно, что для ваших нужд нет единой стратегии, наилучшим образом покрывающей все описанные проблемы; более того, скорее всего, ее и не может быть (разве что для персональных систем, где ценность данных очень низка).

Вот несколько наиболее распространенных технологий, применяемых для резервного копирования:

* Архивация системы целиком с копированием на какой-либо надежный внешний носитель и размещение его вдалеке от основной системы. При этом вы защищены от всех перечисленных проблемы, однако этот метод требует много времени и неудобен в процессе восстановления. Вы можете хранить резервные копии рядом или даже смонтированными, однако все равно столкнетесь с неудобствами при восстановлении, в особенности для непривилегированных пользователей.
* Снэпшоты файловых систем. Помогают только от случайного удаления файлов, но как раз в этом случае _очень_ полезны и эффективны.
* Полные копии файловых систем или дисков (например, периодический запуск программы man:rsync[1] для машины целиком).  Для защиты от отказа жестких дисков этот способ обычно несколько уступает RAID; для восстановления случайно удаленных файлов может быть сравним по удобству со снэпшотами UFS, в зависимости от вашей ситуации.
* RAID. Минимизирует или исключает вовсе простои при отказе жестких дисков. При этом средняя частота таких отказов увеличивается (поскольку количество дисков больше), но разбираться с ними становится много спокойнее.
* Проверка отпечатков файлов (fingerprints). Для этого весьма полезна утилита man:mtree[8]. Не являясь собственно технологией резервного копирования, этот метод помогает выяснять, когда вам пока обращаться к резервным копиям. В особенности это важно для "оффлайновых" резервных копий.

Довольно легко придумать и другие стратегии резервного копирования; многие из них будут композициями уже упомянутых. Наличие специальных требований, как правило, приводит к специализированным же технологиям (например, резервное копирование базы данных, как правило, требует использования методов, специфичных для соответствующей СУБД). Главным остается знание опасностей потери данных, от которых вы хотите себя оградить, и методов защиты от них.

[[backup-basics]]
== Основы технологии резервного копирования

Тремя основными программами резервного копирования являются man:dump[8], man:tar[1] и man:cpio[1].

=== Dump и Restore

Для UNIX(R) традиционными программами резервного копирования являются `dump` и `restore`. Они работают с приводом как с набором дисковых блоков, которые расположены ниже понятий файлов, связей и каталогов, создаваемых файловыми системами. В отличие от других программ для резервного копирования, программа `dump` выполняет резервное копирование всей файловой системы, располагающейся на устройстве. Невозможно выполнить резервное копирование части файловой системы или дерева каталогов, которые располагаются более чем в одной файловой системе. Утилита `dump` не записывает на ленту файлы и каталоги, она записывает блоки данных, из которых строятся файлы и каталоги. Утилита `restore` по умолчанию настроена так, что в процессе своей работы она сохраняет временные файлы в каталог [.filename]#/tmp/#. В некоторых ситуациях доступного в [.filename]#/tmp/# места бывает недостаточно: например, если вы работаете с диска восстановления (recovery disk). В таких случаях для успешной работы утилиты необходимо указать в переменной окружения `TMPDIR` путь к каталогу на менее заполненной файловой системе.

[NOTE]
====
Если вы используете программу `dump` для работы с корневым каталогом, при этом не будет выполняться резервное копирование [.filename]#/home#, [.filename]#/usr# и многих других каталогов, так как они обычно являются точками монтирования других файловых систем или символическими ссылками на эти файловые системы.
====

В программе `dump` имеются некоторые неудобства, оставшиеся от её ранних дней в составе Version 6 операционной системы AT&T UNIX (примерно 1975). Параметры, используемые по умолчанию, подходят для 9-дорожечных лент (6250 bpi), но не для современных носителей с высокой плотностью записи информации (до 62,182 ftpi). Для использования ёмкостей нынешних накопителей на магнитной ленте эти параметры могут быть заданы в командной строке.

При помощи `rdump` и `rrestore` возможно резервное копирование данных по сети на накопитель, подключенный к другому компьютеру. Обе программы используют в работе man:rcmd[3] и man:ruserok[3] для доступа к накопителю на магнитной ленте на удалённом компьютере. Поэтому пользователь, выполняющий резервное копирование, должен быть указан в файле [.filename]#.rhosts# на удалённом компьютере. Аргументы для `rdump` и `rrestore` должны подходить для использования на другом компьютере. При выполнении копирования по команде `rdump` на компьютере с FreeBSD на накопитель Exabyte, подключенный к машине Sun по имени `komodo`, используйте такую команду:

[source,bash]
....
# /sbin/rdump 0dsbfu 54000 13000 126 komodo:/dev/nsa8 /dev/da0a 2>&1
....

Будьте осторожны: есть проблемы с обеспечением безопасности при аутентификации посредством [.filename]#.rhosts#. Внимательно рассмотрите вашу ситуацию.

Программы `dump` и `restore` можно использовать в более защищённом режиме посредством `ssh`.

.Использование `dump` через ssh
[example]
====

[source,bash]
....
# /sbin/dump -0uan -f - /usr | gzip -2 | ssh -c blowfish \
targetuser@targetmachine.example.com dd of=/mybigfiles/dump-usr-l0.gz
....

====

Либо воспользуйтесь встроенной в `dump` возможностью, задав переменную окружения `RSH`:

.Использование `dump` при работе через ssh с заданием `RSH`
[example]
====

[source,bash]
....
# RSH=/usr/bin/ssh /sbin/dump -0uan -f targetuser@targetmachine.example.com:/dev/sa0 /usr
....

====

=== `tar`

Утилита man:tar[1] также восходит корнями к Version 6 системы AT&T UNIX (около 1975). `tar` работает с файловой системой, записывая на ленту файлы и каталоги. Эта утилита поддерживает не полный набор опций, имеющихся в man:cpio[1], однако не требует необычного перенаправления в командной строке, которое используется в утилите `cpio`.

Чтобы скопировать данные на накопитель Exabyte, подключенный к машине Sun по имени `komodo`, используйте такую команду:

[source,bash]
....
# tar cf - . | rsh komodo dd of=tape-device obs=20b
....

Если вы беспокоитесь о безопасности создания резервных копий по сети, то вместо `rsh` вам нужно использовать `ssh`.

=== `cpio`

man:cpio[1] является оригинальной программой UNIX(R) для обмена файлами на магнитных носителях. В утилите `cpio` имеются опции (кроме всего прочего), позволяющие выполнять изменение порядка следования байтов, поддерживающие различные форматы архивов и выполняющие перенаправление данных другим программам. Последняя возможность делает `cpio` прекрасным выбором для целей установки. `cpio` не знает о том, как работать с каталогами, список файлов должен даваться через [.filename]#stdin#.

`cpio` не поддерживает создание резервных копий по сети. Вы можете воспользоваться перенаправлением вывода и программой `rsh` для посылки данных на удалённый накопитель.

[source,bash]
....
# for f in directory_list; do
find $f >> backup.list
done
# cpio -v -o --format=newc < backup.list | ssh user@host "cat > backup_device"
....

Где directory_list это список директорий, c которых Вы хотите создать резервные копии, _user_@_host_ это комбинация пользователь/хост которая описывает того кто занимается резервированием, и __backup_device__ это устройство куда копии должны быть записаны (например, [.filename]#/dev/nsa0#).

=== `pax`

man:pax[1] является ответом IEEE/POSIX(R) на утилиты `tar` и `cpio`. В течение многих лет различные версии программ `tar` и `cpio` получались не совсем совместимыми. Так что вместо того, чтобы попытаться полностью их стандартизировать, POSIX(R) создал новую утилиту для работы с архивами. `pax` пытается читать и писать различные форматы `cpio` и `tar`, и, кроме того, свои собственные новые форматы. Набор команд этой утилиты больше напоминает `cpio`, чем `tar`.

[[backups-programs-amanda]]
=== Amanda

Amanda (Advanced Maryland Network Disk Archiver) является целой клиент/серверной системой резервного копирования, а не отдельной программой. Сервер Amanda сможет осуществлять резервное копирование на единственный накопитель любого количества компьютеров, на которых имеется клиент Amanda и которые могут связываться по сети с сервером Amanda. Общей проблемой систем с большим количеством больших дисков является то, что время, требуемое для непосредственной записи данных на ленту, превышает лимит времени, выделенный на эту задачу. Amanda решает эту проблему. Amanda может использовать "промежуточный диск" для резервного копирования нескольких файловых систем одновременно. Amanda создаёт "наборы архивов": группа лент, используемых в некоторый период времени для создания полных копий всех файловых систем, перечисленных в конфигурационном файле системы Amanda. "Архивный набор" содержит также создаваемый каждую ночь инкрементальные (или дифференциальные) резервные копии всех файловых систем. Восстановление повреждённой файловой системы требует наличия самой последней полной копии и инкрементальных резервных копий.

Конфигурационный файл даёт прекрасный механизм для управления процессом резервного копирования и объёмом трафика, генерируемого системой Amanda. Amanda сможет использовать любую из перечисленных выше программ для записи данных на ленту. Amanda имеется в виде как порта, так и пакета, и по умолчанию она не установлена.

=== Не делать ничего

"Не делать ничего" - это не программа для компьютера, и в то же время это наиболее широко используемая стратегия резервного копирования. Здесь нет никаких первоначальных затрат. Здесь нет расписания, которому нужно следовать. Просто скажите нет. Если что-то случится с вашими данными, улыбнитесь и забудьте о них!

Если ваше время и данные практически ничего не стоят, то "не делать ничего" является самой подходящей программой для вашего компьютера. Но будьте осторожны, POSIX(R) является весьма полезным инструментом, и через полгода вы можете обнаружить, что у вас есть набор файлов, представляющих для вас определенную ценность.

"Ничего не делать" является правильным методом резервного копирования для [.filename]#/usr/obj# и других деревьев каталогов, которые могут быть в точности перегенерированы вашим компьютером. Примером являются файлы, представляющие страницы этого Руководства в форматах HTML или PostScript(R). Они генерируются из входных файлов в формате SGML. Создавать резервные копии файлов в форматах HTML и PostScript(R) не нужно. Исходные файлы в формате SGML копируются регулярно.

=== Какая программа резервного копирования самая лучшая?

man:dump[8] _Точка._ Elizabeth D. Zwicky протестировала все программы резервного копирования, обсуждаемые здесь. Беспроигрышным вариантом для сохранения всех ваших данных и особенностей файловых систем UNIX(R) является `dump`. Элизабет создала файловые системы, содержащие большое количество необычных элементов (и некоторых не так уж необычных) и тестировала каждую из программ, выполняя резервное копирование и последующее восстановление этих файловых систем. В число необычных элементов входили: файлы с дырами, файлы с дырами и блоком пустого места, файлы с необычными символами в их именах, нечитаемые и незаписываемые файлы, устройства, меняющие свой размер во время резервного копирования, файлы, создаваемые и удаляемые во время копирования и тому подобное. Она представила результаты на конференции LISA V в октябре 1991 года. Посмотрите ссылку на сайте http://www.coredumps.de/doc/dump/zwicky/testdump.doc.html[ torture-testing Backup and Archive Programs].

=== Процедура восстановления при сбое

==== До того, как случится катастрофа

Вам нужно выполнить всего лишь четыре шага для того, чтобы быть готовым к любому сбою.

Во-первых, распечатайте разметку диска для всех ваших дисков (к примеру, `bsdlabel da0 | lpr`), таблицу файловых систем ([.filename]#/etc/fstab#) и все сообщения, выводимые при загрузке, каждого по два экземпляра.

Во-вторых, запишите CD диск с "livefs". Этот диск позволяет загружаться в режим аварийного восстановления FreeBSD, давая возможность пользователю выполнять ряд утилит, среди которых man:dump[8], man:restore[8], man:fdisk[8], man:bsdlabel[8], man:newfs[8], man:mount[8] и т.д. Образ CD с "livefs" для FreeBSD/i386 {rel120-current}-RELEASE находится по адресу link:ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/ISO-IMAGES/{rel120-current}/FreeBSD-{rel120-current}-RELEASE-i386-livefs.iso[ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/ISO-IMAGES/{rel120-current}/FreeBSD-{rel120-current}-RELEASE-i386-livefs.iso].

В-третьих, регулярно создавайте резервные копии на ленте. Любые изменения, которые вы делали после последнего резервного копирования, могут быть безвозвратно потеряны. На лентах включайте защиту от записи.

В-четвертых, проверяйте работу CD диска (который вы сделали при выполнении второго шага) и лент с резервными копиями. Ведите журнал выполняемых действий. Храните эти записи вместе с загрузочным CD диском, распечатками и лентами. Вы просто обезумеете при восстановлении данных, если окажется, что записи помогли бы избежать разрушения ваших резервных копий (Каким образом? Вместо команды `tar xvf /dev/sa0` вы могли случайно набрать `tar cvf /dev/sa0` и тем самым перезаписать вашу резервную копию).

Для дополнительной страховки, каждый раз создавайте загрузочный CD диск с "livefs" и две резервные копии на ленте. Храните одну из копий в каком-то удаленном месте и НЕ в том же здании, где находится ваш офис. Достаточно большое количество компаний во Всемирном Торговом Центре изучило это на своей шкуре. Это удаленное хранилище должно быть физически отделено на большое расстояние от ваших компьютеров и дисковых устройств.

==== После сбоя

Главный вопрос: выжило ли ваше оборудование? Вы регулярно делали резервные копии, так что нет нужды беспокоиться о программном обеспечении.

Если оборудование было повреждено, должны быть заменены неисправные компоненты.

Если с оборудованием всё в порядке, вставьте CD диск с "livefs" в привод и загрузите компьютер. На экран будет выведено оригинальное меню установки. Выберите требуемую страну, потом - пункт меню [.guimenuitem]#Fixit -- Repair mode with CDROM/DVD/floppy or start a shell.#, а в нём выберите пункт [.guimenuitem]#CDROM/DVD -- Use the live filesystem CDROM/DVD#. Утилита `restore` и другие нужные вам программы находятся в каталоге [.filename]#/mnt2/rescue#.

Восстановите по отдельности каждую файловую систему.

Попробуйте выполнить команду `mount` (например, `mount /dev/da0a /mnt`) по отношению к корневому разделу вашего первого диска. Если метка диска была испорчена, то воспользуйтесь командой `bsdlabel` для переразбиения на разделы и разметки диска так, чтобы получившаяся метка совпала с той, которая вами была распечатана и сохранена. Для повторного создания файловых систем используйте утилиту `newfs`. Повторно смонтируйте корневой раздел диска в режиме чтения-записи (`mount -u -o rw /mnt`). Воспользуйтесь вашей программой резервного копирования и резервными копиями на лентах для восстановления данных для этой файловой системы (например. `restore vrf /dev/sa0`). Размонтируйте файловую систему (например, `umount /mnt`). Повторите эту процедуру для каждой файловой системы, которая была повреждена.

Как только ваша система заработает, сделайте резервную копию на новые ленты. Что бы ни вызвало сбой или потерю данных, это может случиться снова. Ещё один час, потраченный в этот момент, может спасти вас от неприятностей в будущем.

[[disks-virtual]]
== Сетевые файловые системы, файловые системы в памяти и с отображением в файл

Кроме дисков, которые вы физически устанавливаете в ваш компьютер; дискеты, компакт-диски, винчестеры и так далее, FreeBSD воспринимает и другие типы дисков - _виртуальные диски_.

Сюда могут быть отнесены сетевые файловые системы, такие, как crossref:network-servers[network-nfs,Network File System] и Coda, а также файловые системы с организацией в памяти и создаваемые в файлах.

В зависимости от версии FreeBSD, которую вы используете, для создания и работы с файловыми системами, отображаемыми в оперативную память или файлы, вам нужно будет пользоваться разными инструментами.

[NOTE]
====
Пользователи FreeBSD 4.X для создания требуемых устройств должны использовать man:MAKEDEV[8]. Во FreeBSD 5.0 и более поздних версиях для создания файлов устройств используется man:devfs[5], которая выполняет это прозрачно для пользователей.
====

[[disks-vnconfig]]
=== Файловая система в файле во FreeBSD 4.X

Утилита man:vnconfig[8] конфигурирует и позволяет использовать дисковые устройства на основе псевдо-устройств vnode. _vnode_ представляет собой файл и отвечает за работу с файлом. Это означает, что man:vnconfig[8] использует файлы для создания и работы с файловой системой. Одним из возможных способов использования является монтирование образов дискет или образов компакт-дисков, сброшенных в файлы.

Для использования man:vnconfig[8] в конфигурационном файле ядра вам нужно включить поддержку man:vn[4]:

[.programlisting]
....
pseudo-device vn
....

Чтобы смонтировать имеющийся образ файловой системы:

.Использование vnconfig для монтирования имеющегося образа файловой системы во FreeBSD 4.X
[example]
====

[source,bash]
....
# vnconfig vn0 diskimage
# mount /dev/vn0c /mnt
....

====

Для создания нового образа файловой системы с помощью man:vnconfig[8]:

.Создание нового диска в файле с помощью `vnconfig`
[example]
====

[source,bash]
....
# dd if=/dev/zero of=newimage bs=1k count=5k
5120+0 records in
5120+0 records out
# vnconfig -s labels -c vn0 newimage
# bsdlabel -r -w vn0 auto
# newfs vn0c
Warning: 2048 sector(s) in last cylinder unallocated
/dev/vn0c:	10240 sectors in 3 cylinders of 1 tracks, 4096 sectors
	5.0MB in 1 cyl groups (16 c/g, 32.00MB/g, 1280 i/g)
super-block backups (for fsck -b #) at:
 32
# mount /dev/vn0c /mnt
# df /mnt
Filesystem  1K-blocks	  Used	  Avail Capacity  Mounted on
/dev/vn0c	 4927	     1	   4532     0%	  /mnt
....

====

[[disks-mdconfig]]
=== Файловые системы, отображаемые в файлы

Во FreeBSD 5.X и более поздних для конфигурации и подключения дисков man:md[4], отображаемых в оперативную память, используется утилита man:mdconfig[8]. Для работы с man:mdconfig[8] вам нужно подгрузить модуль man:md[4] или добавить поддержку этих устройств в файл конфигурации ядра:

[.programlisting]
....
device md
....

Утилита man:mdconfig[8] поддерживает три типа виртуальных дисков, отображаемых в память: диски в памяти, которая выделяется запросами man:malloc[9] и диски в памяти, использующие в качестве устройств хранения файлы или раздел подкачки. Одним из возможных использований таких дисков является монтирование файлов с образами дискет или CD.

Для монтирования образа существующей файловой системы:

.Использование `mdconfig` для монтирования файла с образом существующей файловой системы
[example]
====

[source,bash]
....
# mdconfig -a -t vnode -f diskimage -u 0
# mount /dev/md0 /mnt
....

====

Для создания образа новой файловой системы при помощи man:mdconfig[8]:

.Создание нового диска, отображаемого в файл, при помощи `mdconfig`
[example]
====

[source,bash]
....
# dd if=/dev/zero of=newimage bs=1k count=5k
5120+0 records in
5120+0 records out
# mdconfig -a -t vnode -f newimage -u 0
# bsdlabel -w md0 auto
# newfs md0a
/dev/md0c: 5.0MB (10224 sectors) block size 16384, fragment size 2048
	using 4 cylinder groups of 1.25MB, 80 blks, 192 inodes.
super-block backups (for fsck -b #) at:
 160, 2720, 5280, 7840
# mount /dev/md0a /mnt
# df /mnt
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md0a       4710    4  4330     0%    /mnt
....

====

Если в параметре `-u` вы не задали номер устройства, то man:mdconfig[8] для выбора неиспользуемого устройства будет использовать функцию автоматическое выделения в man:md[4]. Имя выделенного устройства будет выдано на стандартное устройство выводы в виде, например, [.filename]#md4#. Для получения более полной информации о man:mdconfig[8], пожалуйста, обратитесь к соответствующей странице справочной системы.

Утилита man:mdconfig[8] весьма полезна, однако для создания файла с файловой системой требуется произвести много действий. Вместе с FreeBSD 5.0 поставляется утилита под названием man:mdmfs[8], которая создаёт диск man:md[4] при помощи man:mdconfig[8], размещает на нём файловую систему UFS при помощи man:newfs[8] и монтирует её командой man:mount[8]. Например, если вы хотите создать и смонтировать такой же образ файловой системе, как выше, просто наберите такую команду:

.Настройка и монтирование диска, отображаемого в файл, при помощи команды `mdmfs`
[example]
====

[source,bash]
....
# dd if=/dev/zero of=newimage bs=1k count=5k
5120+0 records in
5120+0 records out
# mdmfs -F newimage -s 5m md0 /mnt
# df /mnt
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md0        4718    4  4338     0%    /mnt
....

====

Если вы используете параметр `md` без номера устройства, то man:mdmfs[8] будет использовать автоматическую нумерацию man:md[4] для автоматического выбора неиспользуемого устройства. Более полную информацию о man:mdmfs[8] можно найти на страницах справочной системы.

[[disks-md-freebsd4]]
=== Файловая система в памяти во FreeBSD 4.X

Драйвер man:md[4] является простым и эффективным способом создания файловых систем в памяти во FreeBSD 4.X. Для выделения памяти используется man:malloc[9].

Просто возьмите файловую систему, которую вы приготовили при помощи, скажем, man:vnconfig[8] и:

.Диск md в памяти во FreeBSD 4.X
[example]
====

[source,bash]
....
# dd if=newimage of=/dev/md0
5120+0 records in
5120+0 records out
# mount /dev/md0c /mnt
# df /mnt
Filesystem  1K-blocks	  Used	  Avail Capacity  Mounted on
/dev/md0c	 4927	     1	   4532     0%	  /mnt
....

====

Для получения более полной информации, пожалуйста, обратитесь к страницам справочной системы по man:md[4].

[[disks-md-freebsd5]]
=== Файловые системы с отображением в память

При работе с файловыми системами, отображаемыми в файл или память, используются одни и те же утилиты: man:mdconfig[8] или man:mdmfs[8]. Обычно для отображаемых в память файловых систем следует использовать опцию "хранение на области подкачки". Это не означает, что такая файловая система будет сразу сброшена на диск: место под нее будет выделено из общего пула памяти, и при необходимости может перемещаться в область подкачки. Также, возможно выделение места под файловую систему в основной памяти (через man:malloc[9]); однако, следует помнить, что использование таких файловых систем, в особенности большого размера, может привести к панике системы от исчерпания ядерной памяти.

.Создание нового диска с отображением в память при помощи `mdconfig`
[example]
====

[source,bash]
....
# mdconfig -a -t swap -s 5m -u 1
# newfs -U md1
/dev/md1: 5.0MB (10240 sectors) block size 16384, fragment size 2048
	using 4 cylinder groups of 1.27MB, 81 blks, 192 inodes.
	with soft updates
super-block backups (for fsck -b #) at:
 160, 2752, 5344, 7936
# mount /dev/md1 /mnt
# df /mnt
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md1        4718    4  4338     0%    /mnt
....

====

.Создание нового диска с отображением в память при помощи `mdmfs`
[example]
====

[source,bash]
....
# mdmfs -s 5m md2 /mnt
# df /mnt
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md2        4846    2  4458     0%    /mnt
....

====

=== Отключение диска, отображаемого в память, от системы

Если файловые системы, отображаемые в память или файл, больше не используются, вам нужно высвободить все ресурсы для системы. Первым делом нужно размонтировать файловую систему, затем воспользоваться man:mdconfig[8] для отключения диска от системы и освободить ресурсы.

К примеру, чтобы отключить и освободить все ресурсы, используемые [.filename]#/dev/md4#:

[source,bash]
....
# mdconfig -d -u 4
....

Для выдачи информации об отконфигурированных устройствах man:md[4] используется команда `mdconfig -l`.

Во FreeBSD 4.X для отключения устройства используется команда man:vnconfig[8]. Например, для отключения и освобождения всех ресурсов, используемых [.filename]#/dev/vn4#:

[source,bash]
....
# vnconfig -u vn4
....

[[snapshots]]
== Мгновенные копии файловых систем

Во FreeBSD 5.0 вместе с технологией crossref:cutting-edge[soft-updates, Отложенных обновлений] представлена новая возможность: генерация мгновенных копий файловых систем.

Мгновенные копии позволяют пользователю создавать образы заданных файловых систем и работать с ними как с файлами. Файлы мгновенных копий должны создаваться в той файловой системе, над которой производится действие, и пользователь может создавать не более 20 мгновенных копий для каждой файловой системы. Активные копии записываются в суперблок, так что они остаются в силе между операциями монтирования и размонтирования в процессе системных перезагрузок. Если мгновенная копия больше не нужна, она может быть удалена стандартной командой man:rm[1]. Мгновенные копии могут удаляться в любом порядке, однако всё использованное пространство не может быть использовано, так как другая мгновенная копия может претендовать на некоторые блоки из освобождённых.

Неизменяемый флаг `snapshot` устанавливается на файл при помощи man:mksnap_ffs[8] после первоначального создания файла мгновенной копии. Команда man:unlink[1] делает исключение для файлов мгновенных копий, позволяя их удалять.

Мгновенные копии создаются при помощи утилиты man:mount[8]. Чтобы создать мгновенную копию [.filename]#/var# в файле [.filename]#/var/snapshot/snap#, воспользуйтесь такой командой:

[source,bash]
....
# mount -u -o snapshot /var/snapshot/snap /var
....

В качестве альтернативного средства создания мгновенных копий вы можете использовать утилиту man:mksnap_ffs[8]:

[source,bash]
....
# mksnap_ffs /var /var/snapshot/snap
....

Файлы мгновенных копий файловых систем (к примеру, [.filename]#/var#) можно найти при помощи команды man:find[1]:

[source,bash]
....
# find /var -flags snapshot
....

После создания мгновенной копии есть несколько способов её использования:

* Некоторые администраторы будут использовать файл мгновенной копии для целей создания резервной копии, так как мгновенная копия может быть перенесена на CD или магнитную ленту.
* Утилита проверка целостности файловой системы, man:fsck[8], может быть запущена над мгновенной копией. Полагая, что файловая система была в порядке, когда она была смонтирована, вы всегда должны получать нормальный (и неизменный) результат. Это именно то, что выполняет фоновый процесс man:fsck[8].
* Запустить утилиту man:dump[8] с мгновенной копией. Будет создаваться дамп, соответствующий файловой системе на момент создания мгновенной копии. Утилита man:dump[8] при использовании опции `-L` тоже может работать с мгновенными копиями, создавать их дампы, а затем удалять за один проход.
* Смонтировать командой man:mount[8] мгновенную копию как замороженный образ файловой системы. Чтобы смонтировать командой man:mount[8] мгновенную копию [.filename]#/var/snapshot/snap#, запустите:
+

[source,bash]
....
# mdconfig -a -t vnode -f /var/snapshot/snap -u 4
# mount -r /dev/md4 /mnt
....

Теперь вы можете пройтись по иерархии вашей зафиксированной файловой системы [.filename]#/var#, смонтированной в каталог [.filename]#/mnt#. Первоначально всё будет в том же самом состоянии, в каком это было во время создания мгновенной копии. Единственным исключением будет то, что любые ранее сделанные мгновенные копии будут видны как файлы нулевой длины. Когда использование мгновенной копии закончено, она может быть удалена командой:

[source,bash]
....
# umount /mnt
# mdconfig -d -u 4
....

Для получения более полной информации о `softupdates` и мгновенных копиях файловых систем, включая технической описание, вы можете посетить сайт Маршалла Кёрка МакКузика (Marshall Kirk McKusick) по адресу http://www.mckusick.com/[http://www.mckusick.com/].

[[quotas]]
== Квотирование файловых систем

Квоты - это опциональная возможность операционной системы, которая позволяет ограничивать объем дискового пространства и/или количество файлов для конкретного пользователя или членов определенной группы в рамках одной файловой системы. Чаще всего эта возможность используется в системах разделения времени, когда желательно ограничить количество ресурсов, которые может использовать один пользователь или группа пользователей. Это позволит не допустить ситуации, когда один пользователь или группа пользователей заполняют всё доступное дисковое пространство.

=== Настройка вашей системы на использование дисковых квот

Перед тем, как попытаться использовать дисковые квоты, необходимо убедиться, что квоты включены в вашем ядре. Это делается добавлением следующей строки в конфигурационный файл вашего ядра:

[.programlisting]
....
options QUOTA
....

В стандартном ядре [.filename]#GENERIC# это по умолчанию не включено, так что для использования дисковых квот вам нужно будет настроить, откомпилировать и установить собственное ядро. Пожалуйста, обратитесь к crossref:kernelconfig[kernelconfig, Настройка ядра FreeBSD] за дополнительной информацией о настройке ядра.

Затем вам потребуется включить квотирование дисков в файле [.filename]#/etc/rc.conf#. Это делается добавление такой строчки:

[.programlisting]
....
enable_quotas="YES"
....

Для более полного контроля над запуском квотирования имеется дополнительная переменная для настройки. Как правило, при загрузке целостность квот каждой файловой системы проверяется программой man:quotacheck[8]. При работе программы man:quotacheck[8] проверяется точное соответствие данных в базе данных квот данным в файловой системе. Это весьма долгий процесс, что отражается на времени загрузки системы. Если вам захочется пропустить этот шаг, то для этого предназначена специальная переменная в файле [.filename]#/etc/rc.conf#:

[.programlisting]
....
check_quotas="NO"
....

Наконец, вам потребуется отредактировать файл [.filename]#/etc/fstab# для включения дисковых квот на уровне файловых систем. Это то место, где вы можете включить квоты для пользователей, для групп или для обеих этих категорий для всех ваших файловых систем.

Для включения пользовательских квот для файловой системы, добавьте параметр `userquota` в поле параметров файловой системы, на которой вы хотите включить квотирование, в файле [.filename]#/etc/fstab#. Например:

[.programlisting]
....
/dev/da1s2g   /home    ufs rw,userquota 1 2
....

Подобным же образом для включения квотирования на уровне групп, воспользуйтесь параметром `groupquota` вместо `userquota`. Чтобы включить квотирование как для пользователей, так и для групп, измените строчку следующим образом:

[.programlisting]
....
/dev/da1s2g   /home    ufs rw,userquota,groupquota 2 2
....

По умолчанию файлы квот хранятся в корневом каталоге файловой системы в файлах с именами [.filename]#quota.user# и [.filename]#quota.group# соответственно для пользовательских и групповых квот. Для получения подробной информации обратитесь к команде man:fstab[5]. Хотя справочная страница по man:fstab[5] утверждает, что вы можете указать другое местоположение файлов с квотами, этого делать не рекомендуется, потому что различные утилиты для работы с квотами не могут нормально работать в такой ситуации.

На этом этапе вы должны перезагрузить вашу систему с новым ядром. Скрипт [.filename]#/etc/rc# автоматически запустит соответствующие команды для создания начальных файлов для всех квот, которые вы создали в файле [.filename]#/etc/fstab#, так что нет нужды вручную создавать никаких файлов квот нулевой длины.

При нормальной работе вам не потребуется вручную запускать программы man:quotacheck[8], man:quotaon[8] или man:quotaoff[8]. Однако вам нужно хотя бы прочесть страницы справочника по этим командам, просто чтобы ознакомиться с их функциями.

=== Установка квот

Как только вы настроили вашу систему на использование квот, проверьте, что они действительно были задействованы. Простым способом сделать это является запуск такой команды:

[source,bash]
....
# quota -v
....

Вы должны увидеть однострочную информацию, отражающую использование диска и текущие ограничения для каждой файловой системы, на которой включено квотирование.

Теперь вы действительно готовы задавать ограничения при помощи команды man:edquota[8].

У вас есть несколько вариантов того, как приводить в действие ограничения по объему дискового пространства, который могут занимать пользователь или группа, а также по количеству файлов, которые они могут создать. Вы можете ограничивать размещение ресурсов на основе объема дискового пространства (квотирование блоков), количества файлов (квотирование inode) или их комбинации. Каждое из этих ограничений, в свою очередь, делится на две категории: мягкие и жёсткие ограничения.

Жёсткое ограничение не может быть превышено. Как только пользователь достиг своих ограничений, ресурсы соответствующей файловой системы ему больше выделяться не будут. Например, если пользователь имеет жесткое ограничение в 500 Кбайт на файловой системе и в текущий момент использует 490 Кбайт, то пользователь может получить дополнительно ещё 10 Кбайт. Попытка занять ещё 11 Кбайт окончится неудачно.

С другой стороны, мягкие ограничения могут быть превышены в течении некоторого периода времени. Этот период времени также называют периодом отсрочки, который по умолчанию равен одной неделе. Если пользователь превышает своё мягкое ограничение в течение периода времени, превышающего отсрочку, то это мягкое ограничение становится жестким и последующее выделение ресурсов будет запрещено. Когда пользователь вернётся обратно к отметке, меньшей, чем мягкое ограничение, то период отсрочки будет сброшен.

Далее приводится пример того, что вы можете наблюдать при запуске команды man:edquota[8]. Когда вызывается команда man:edquota[8], вы оказываетесь в редакторе, заданном переменной переменной окружения `EDITOR`, или в редакторе vi, если переменная `EDITOR` не задана, и можете редактировать квоты.

[source,bash]
....
# edquota -u test
....

[.programlisting]
....
Quotas for user test:
/usr: kbytes in use: 65, limits (soft = 50, hard = 75)
	inodes in use: 7, limits (soft = 50, hard = 60)
/usr/var: kbytes in use: 0, limits (soft = 50, hard = 75)
	inodes in use: 0, limits (soft = 50, hard = 60)
....

Для каждой файловой системы, на которой включено квотирование, вы должны увидеть две строки. В одной строке приведены ограничения на блоки, а в другой на количество inode. Например, чтобы увеличить ограничения на количество блоков для пользователя с мягкого ограничения в 50 и жёсткого ограничения в 75, на мягкое ограничение в 500 и жёсткое ограничение в 600, измените:

[.programlisting]
....
/usr: kbytes in use: 65, limits (soft = 50, hard = 75)
....

на:

[.programlisting]
....
/usr: kbytes in use: 65, limits (soft = 500, hard = 600)
....

Новые ограничения вступят в силу после выхода из редактора.

Иногда желательно установить ограничения квот на некоторый диапазон UID (идентификаторов пользователей). Это можно сделать при помощи параметра `-p` в команде man:edquota[8]. Во-первых, установите желаемое ограничение для пользователя, а затем запустите команду `edquota -p protouser startuid-enduid`. Например, если пользователь `test` имеет желаемые ограничения, то для дублирования этих ограничений на пользователей с UID от 10000 до 19999 может быть использована такая команда:

[source,bash]
....
# edquota -p test 10000-19999
....

Дополнительную информацию можно получить из справочной страницы по команде man:edquota[8].

=== Проверка ограничений и использования диска

Для проверки квот и использования дисков вы можете использовать команды man:quota[1] или man:repquota[8]. Команда man:quota[1] может быть использована для проверки квот отдельных пользователей, групп, а также использования дисков. Пользователь может только проверить собственную квоту и квоту той группы, к которой он принадлежит. Только администратор системы может проверить квоты всех пользователей и групп. Команду man:repquota[8] можно использовать для получения суммарной статистики всех квот и использования дисков для файловых систем с включенными квотами.

Далее приведен пример вывода команды `quota -v` для пользователя, который имеет ограничения на двух файловых системах.

[.programlisting]
....
Disk quotas for user test (uid 1002):
     Filesystem  usage    quota   limit   grace   files   quota   limit   grace
           /usr      65*     50      75   5days       7      50      60
       /usr/var       0      50      75 	      0      50      60
....

В этом примере для файловой системы [.filename]#/usr# пользователь превысил свое мягкое ограничение в 50 Кбайт на 15 Кбайт и имеет 5 дней до истечения отсрочки. Отметьте знак звездочки `*`, который указывает на превышение пользователем своего ограничения.

Как правило, файловые системы, на которых пользователь не занимает дискового пространства, не показываются в выводе команды man:quota[1], даже если ему выделена квота на этой файловой системе. При использовании параметра `-v` эти файловые системы выводятся, как, например, файловая система [.filename]#/usr/var# в примере выше.

=== Квоты в NFS

Квоты определяются подсистемой квот на сервере NFS. Даемон man:rpc.rquotad[8] предоставляет информацию о квотах для программы man:quota[1] на клиентах NFS, позволяя пользователям на этих машинах смотреть свою статистику о квотах.

Включите `rpc.rquotad` в файле [.filename]#/etc/inetd.conf# следующим образом:

[.programlisting]
....
rquotad/1      dgram rpc/udp wait root /usr/libexec/rpc.rquotad rpc.rquotad
....

Теперь перезапустите `inetd`:

[source,bash]
....
# /etc/rc.d/inetd restart
....

[[disks-encrypting]]
== Шифрование дисковых разделов

FreeBSD предоставляет прекрасную возможность по защите от несанкционированного доступа к данным. Права на доступ к файлам и технология принудительного контроля доступа MAC (Mandatory Access Control) (смотрите see crossref:mac[mac, Принудительный контроль доступа (MAC)]) помогают предотвратить несанкционированный доступ посторонних лиц к данным, при условии работы операционной системы и компьютера. Однако права доступа, контролируемые операционной системой, не имеют значения, если нападающий получает физический доступ к компьютеру и может просто перенести жёсткий диск на другую машину для копирования и дальнейшего анализа важных данных.

Вне зависимости от того, как атакующий завладел жёстким диском или выключенным компьютером, технологии gbde (GEOM Based Disk Encryption - шифрование диска на уровне GEOM) и криптографическая подсистема `geli` FreeBSD могут защитить данные файловой системы компьютера даже против очень заинтересованной атакующей стороны с достаточными ресурсами. В отличие от громоздких систем шифрования, которые шифруют отдельные файлы, `gbde` и `geli` шифруют в прозрачном режиме файловую систему в целом, при этом данные в открытом виде на диск никогда не записываются.

=== Шифрование диска при помощи gbde

[.procedure]
====

. Получите права пользователя `root`
+ 
Настройка gbde требует права доступа администратора системы.
+
[source,bash]
....
% su -
Password:
....
+
. Включите поддержку man:gbde[4] в конфигурационный файл ядра
+ 
Добавьте следующую строку в файл конфигурации вашего ядра:
+ 
`options GEOM_BDE`
+ 
Перестройте ядро FreeBSD. Этот процесс описан в crossref:kernelconfig[kernelconfig, Настройка ядра FreeBSD].
+ 
Перезагрузитесь, запустив новое ядро.
. Альтернативой пересборке ядра является использование `kldload` для загрузки модуля man:gbde[4]:
+
[source,bash]
....
# kldload geom_bde
....
====

==== Подготовка зашифрованного жёсткого диска

В следующем примере предполагается, что в вашу систему вы добавляете новый винчестер, на котором будет располагаться единственный раздел с зашифрованными данными. Этот раздел будет монтироваться в каталог [.filename]#/private#. gbde может также использоваться для шифрования [.filename]#/home# и [.filename]#/var/mail#, но это требует более сложной последовательности действий, что выходит за рамки этого вводного материала.

[.procedure]
====

. Подключите новый жёсткий диск
+ 
Установите новый диск в систему, как это описано в <<disks-adding>>. В рамках этого примера раздел, соответствующий новому жёсткому диску, будет называться [.filename]#/dev/ad4s1c#. Устройства [.filename]#/dev/ad0s1*# представляют существующие стандартные разделы FreeBSD нашей тестовой системы.
+
[source,bash]
....
# ls /dev/ad*
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4
....
+
. Создайте каталог для размещения файлов блокировок GBDE
+
[source,bash]
....
# mkdir /etc/gbde
....
+ 
Файл блокировки gbde содержит информацию, которая нужна gbde для доступа к зашифрованному разделу. Не имея доступа к файлу блокировки, gbde не сможет расшифровать данные, хранимые в зашифрованном разделе, без значительного ручного вмешательства, что программно не поддерживается. Каждый зашифрованный раздел использует отдельный файл блокировки.
. Инициализируйте раздел gbde
+ 
Перед началом работы с разделом gbde его необходимо проинициализировать. Эта инициализация производится только один раз:
+
[source,bash]
....
# gbde init /dev/ad4s1c -i -L /etc/gbde/ad4s1c.lock
....
+ 
man:gbde[8] запустит редактор, что позволит вам задать в шаблоне различные конфигурационные параметры. При работе с файловыми системами UFS1 и UFS2 задайте значение sector_size равным 2048:
+
[.programlisting]
....
$FreeBSD: src/sbin/gbde/template.txt,v 1.1 2002/10/20 11:16:13 phk Exp $
#
# Sector size is the smallest unit of data which can be read or written.
# Making it too small decreases performance and decreases available space.
# Making it too large may prevent filesystems from working.  512 is the
# minimum and always safe.  For UFS, use the fragment size
#
sector_size     =       2048
[...]
....
+ 
man:gbde[8] дважды запросит ввод пароля, который будет использоваться для защиты данных. Пароль в обоих случаях должен вводиться одинаковый. Возможности gbde по защите ваших данных полностью зависят от качества выбранной вами ключевой фразы. 
+ 
По команде `gbde init` создаётся файл блокировок для вашего раздела gbde, который в нашем случае будет иметь имя [.filename]#/etc/gbde/ad4s1c.lock#. Для того, чтобы файлы блокировок корректно распознавались стартовым скриптом [.filename]#/etc/rc.d/gbde#, их имена должны заканчиваться на ".lock".
+
[CAUTION]
======

Резервные копии файлов блокировок gbde _должны_ храниться вместе с содержимым шифруемых разделов. Хотя удаление только блокировочного файла не сможет противостоять дешифрации атакующим раздела gbde, без этого файла даже легитимный пользователь не сможет получить доступ к данным без определённых и значительных усилий, что не поддерживается man:gbde[8] и его разработчиком.
======
+
. Подключите зашифрованный раздел к системе
+
[source,bash]
....
# gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c.lock
....
+ 
Будет выдан запрос на ввод ключевой фразы, которую вы выбирали во время инициализации зашифрованного раздела. Новое защищённое устройство будет видно в каталоге [.filename]#/dev# под названием [.filename]#/dev/device_name.bde#:
+
[source,bash]
....
# ls /dev/ad*
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4        /dev/ad4s1c.bde
....
+
. Создайте файловую систему на зашифрованном устройстве
+ 
Как только защищённое устройство будет подключено к системе, вы сможете создать на нём файловую систему. Для этого используется утилита man:newfs[8]. Так как инициализация новой файловой системы UFS2 происходит быстрее, чем инициализация файловой системы старого формата UFS1, то рекомендуется использовать man:newfs[8] с параметром `-O2`.
+
[source,bash]
....
# newfs -U -O2 /dev/ad4s1c.bde
....
+
[NOTE]
======
Запуск команды man:newfs[8] должен выполняться над подключенном разделе gbde, который идентифицируется по расширению [.filename]#*.bde# в имени устройства.
======
+
. Смонтируйте зашифрованный раздел
+ 
Создайте точку монтирования для зашифрованной файловой системы.
+
[source,bash]
....
# mkdir /private
....
+ 
Смонтируйте защищённую файловую систему.
+
[source,bash]
....
# mount /dev/ad4s1c.bde /private
....
+
. Проверьте доступность зашифрованной файловой системы
+ 
Защищённая файловая система теперь должна быть доступна утилите man:df[1] и доступной для использования.
+
[source,bash]
....
% df -H
Filesystem        Size   Used  Avail Capacity  Mounted on
/dev/ad0s1a      1037M    72M   883M     8%
/devfs            1.0K   1.0K     0B   100%    /dev
/dev/ad0s1f       8.1G    55K   7.5G     0%    /home
/dev/ad0s1e      1037M   1.1M   953M     0%    /tmp
/dev/ad0s1d       6.1G   1.9G   3.7G    35%    /usr
/dev/ad4s1c.bde   150G   4.1K   138G     0%    /private
....
====

==== Монтирование имеющихся зашифрованных файловых систем

После каждой загрузки для каждой защищённой файловой системы перед их использованием должны выполняться повторное подключение к системе, проверка на наличие ошибок и монтирование. Требуемые для этого команды должны выполняться пользователем `root`.

[.procedure]
====

. Подключение gbde-раздела к системе
+
[source,bash]
....
# gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c.lock
....
+ 
Будет выдан запрос на ввод ключевой фразы, выбранной на этапе инициализации зашифрованного раздела gbde.
. Проверка файловой системы на наличие ошибок
+ 
Так как защищаемая файловая система не может пока быть указана в файле [.filename]#/etc/fstab# для автоматического монтирования, то она должны проверяться на наличие ошибок посредством ручного запуска man:fsck[8] до её монтирования.
+
[source,bash]
....
# fsck -p -t ffs /dev/ad4s1c.bde
....
+
. Монтирование зашифрованной файловой системы
+
[source,bash]
....
# mount /dev/ad4s1c.bde /private
....
+ 
Теперь защищённая файловая система доступна для работы.
====

===== Автоматическое монтирование зашифрованных разделов

Для автоматического подключения, проверки и монтирования зашифрованного раздела можно создать скрипт, но по соображениям безопасности в этом скрипте пароля для man:gbde[8] быть не должно. Поэтому рекомендуется запускать такие скрипты вручную, а пароль задавать с консоли или сеанса man:ssh[1].

Кроме того, базовая система содержит скрипт [.filename]#rc.d# для автоматического монтирования шифрованных разделов. Его аргументы могут быть указаны в файле man:rc.conf[5]:

[.programlisting]
....
gbde_autoattach_all="YES"
gbde_devices="ad4s1c"
gbde_lockdir="/etc/gbde"
....

При этом ключевая фраза для gbde должна быть введена на этапе загрузки. После введения ключевой фразы зашифрованный раздел будет смонтирован автоматически. Такой подход может быть очень удобным для использования gbde на ноутбуках.

==== Криптографическая защита, применяемая в gbde

man:gbde[8] шифрует содержимое секторов при помощи 128-битного AES в режиме CBC. Каждый сектор диска шифруется различным ключом AES. Более полная информацию о системе шифрования gbde, включая алгоритм генерации ключей для секторов из ключевой фразы, вводимой пользователем, можно найти на страницах справочной системы о man:gbde[4].

==== Вопросы совместимости

man:sysinstall[8] несовместим с устройствами, зашифрованными gbde. Все устройства [.filename]#*.bde# перед запуском man:sysinstall[8] должны быть отключены от системы, или эта утилита аварийно завершит работу на этапе обнаружения устройств. Для отключения защищённого устройства, используемого в нашем примере, воспользуйтесь такой командой:

[source,bash]
....
# gbde detach /dev/ad4s1c
....

=== Шифрование дисков при помощи `geli`

Во FreeBSD имеется альтернативный криптографический класс GEOM - `geli`. В настоящий момент он поддерживается {pjd}. Утилита `geli` отличается от `gbde`; она предоставляет другой комплекс возможностей и использует иную схему криптования.

Наиболее значимыми особенностями man:geli[8] являются:

* Использование инфраструктуры man:crypto[9]: при наличии аппаратной криптографической поддержки, `geli` автоматически использует ее.
* Поддержка разнообразных криптоалгоритмов (в настоящее время AES, Blowfish и 3DES).
* Поддержка шифрованного корневого раздела. Для загрузки в такой ситуации потребуется ввести ключевую фразу.
* Поддержка двух независимых ключей шифрования (например, "основного ключа" и "ключа компании").
* Высокая скорость работы `geli` за счет простого криптования сектор-сектор.
* Поддержка архивирования основных ключей. При необходимости текущие ключи могут быть уничтожены, а в дальнейшем доступ к данным восстановлен при помощи архивированных ключей.
* Поддержка криптования файловых систем случайным одноразовым ключом - например, для разделов подкачки или временных файловых систем.

Другие возможности класса `geli` описаны в его странице справочника: man:geli[8].

Несколько следующих страниц будут посвящены описанию процесса конфигурации `geli` в ядре FreeBSD, а также объяснят, как создавать и использовать криптографический провайдер `geli`.

Поскольку в процессе настройки возникнет необходимость внесения изменений в конфигурацию ядра, потребуются также привилегии суперпользователя.

[.procedure]
====

. Добавление поддержки `geli` в ядро
+ 
Добавьте в конфигурационный файл ядра следующие строки:
+
[.programlisting]
....
options GEOM_ELI
device crypto
....
+ 
Перестройте ядро, как описано в разделе crossref:kernelconfig[kernelconfig, Настройка ядра FreeBSD].
+ 
Помимо этого, поддержка `geli` может быть активирована модулем ядра на этапе загрузки. Для этого добавьте в файл [.filename]#/boot/loader.conf# строку:
+
[.programlisting]
....
geom_eli_load="YES"
....
+ 
Теперь ядро должно поддерживать man:geli[8].
. Генерация главного ключа
+ 
Предлагаемый пример описывает процесс генерации ключевого файла, который послужит частью главного ключа для шифрованного провайдера, монтируемого в каталог [.filename]#/private#. При помощи содержимого ключевого файла создается набор случайных данных, которым зашифровывается главный ключ. Кроме того, он будет защищен кодовой фразой. Размер сектора провайдера будет составлять 4kB. Наконец, мы обсудим, как присоединиться к провайдеру `geli`, создать на базе его файловую систему, как ее смонтировать и работать с ней, и, в заключение, как корректно завершить работу.
+ 
Больший чем обычно размер сектора (как в нашем примере, 4 кБ) рекомендуется для увеличения производительности.
+ 
Главный ключ будет защищен кодовой фразой; данные для ключевого файла берутся из [.filename]#/dev/random#. Размер сектора создаваемого нами шифрованного провайдера [.filename]#/dev/da2.eli# - 4кБ.
+
[source,bash]
....
# dd if=/dev/random of=/root/da2.key bs=64 count=1
# geli init -s 4096 -K /root/da2.key /dev/da2
Enter new passphrase:
Reenter new passphrase:
....
+ 
Использование одновременно кодовой фразы и ключевого файла не обязательно: любой из этих методов защиты главного ключа может применяться независимо.
+ 
Если в качестве имени ключевого файла указан "-", используется стандартный ввод. Это позволяет использовать более одного ключевого файла:
+
[source,bash]
....
# cat keyfile1 keyfile2 keyfile3 | geli init -K - /dev/da2
....
+
. Свяжите сгенерированный ключ с провайдером
+
[source,bash]
....
# geli attach -k /root/da2.key /dev/da2
Enter passphrase:
....
+ 
Созданный при этом файл дискового устройства будет называться [.filename]#/dev/da2.eli#.
+
[source,bash]
....
# ls /dev/da2*
/dev/da2  /dev/da2.eli
....
+
. Создайте новую файловую систему
+
[source,bash]
....
# dd if=/dev/random of=/dev/da2.eli bs=1m
# newfs /dev/da2.eli
# mount /dev/da2.eli /private
....
+ 
Зашифрованная файловая система будет видна в выводе утилиты man:df[1] и готова к использованию:
+
[source,bash]
....
# df -H
Filesystem     Size   Used  Avail Capacity  Mounted on
/dev/ad0s1a    248M    89M   139M    38%    /
/devfs         1.0K   1.0K     0B   100%    /dev
/dev/ad0s1f    7.7G   2.3G   4.9G    32%    /usr
/dev/ad0s1d    989M   1.5M   909M     0%    /tmp
/dev/ad0s1e    3.9G   1.3G   2.3G    35%    /var
/dev/da2.eli   150G   4.1K   138G     0%    /private
....
+
. Размонтирование и деактивация провайдера
+ 
После завершения работы с шифрованным разделом, когда содержимое каталога [.filename]#/private# больше не нужно, будет разумным отключить раздел от системы.
+
[source,bash]
....
# umount /private
# geli detach da2.eli
....
====

Дополнительную информацию о man:geli[8] можно найти на соответствующей странице справочника.

==== Использование стартового скрипта [.filename]#rc.d# [.filename]#geli#

Для удобства использования подсистемы `geli` в комплект базовой системы FreeBSD входит стартовый скрипт, работой которого можно управлять из man:rc.conf[5]:

[.programlisting]
....
geli_devices="da2"
geli_da2_flags="-p -k /root/da2.key"
....

При этом дисковый раздел [.filename]#/dev/da2# будет сконфигурирован как провайдер `geli`, связан с ключевым файлом [.filename]#/root/da2.key#, а кодовая фраза не будет использоваться (отметим, что это возможно только в том случае, если при инициализации `geli init` был указан ключ `-P`). Шифрованный провайдер `geli` будет отсоединен перед выключением системы.

Дополнительную информацию о конфигурации скриптов [.filename]#rc.d# можно найти в соответствующей crossref:config[configtuning-rcd,главе] Руководства.

[[swap-encrypting]]
== Шифрование области подкачки

Шифрование области подкачки в FreeBSD достаточно легко конфигурируется. Варианты конфигурации слегка различаются в зависимости от версии системы. Для шифрования разделов подкачки можно использовать утилиты man:gbde[8] или man:geli[8];. В обоих случаях используется скрипт crossref:config[configtuning-rcd,rc.d] [.filename]#encswap#.

Предыдущий раздел, <<disks-encrypting,Шифрование дисковых разделов>>, кратко описывает различные методы криптования.

=== Зачем шифровать область подкачки?

Как и в случае дисковых разделов, шифрование области подкачки применяется для защиты важной информации. Возьмем, к примеру, приложение, которому требуется работать с паролями. До тех пор, пока пароли хранятся в физической памяти, все в порядке. Если же операционная система начинает выгружать отдельные участки памяти в область подкачки, чтобы освободить память для других приложений, пароли могут быть записаны на диск в открытом виде и тем самым оказаться легко доступными злоумышленнику (имеющему физический доступ к диску - прим. пер.). В таких ситуациях решением может стать шифрование раздела подкачки.

=== Подготовка

[NOTE]
====
В данном разделе мы будем считать, что разделом подкачки является [.filename]#ad0s1b#.
====

До настоящего момента раздел подкачки не был зашифрован. Таким образом, на нем могут содержаться пароли или какая-либо иная важная информация в открытом виде. Чтобы избавиться от этого, заполним раздел подкачки случайными данными:

[source,bash]
....
# dd if=/dev/random of=/dev/ad0s1b bs=1m
....

=== Шифрование раздела подкачки при помощи man:gbde[8]

В строку файла [.filename]#/etc/fstab#, описывающую раздел подкачки, необходимо добавить суффикс `.bde`:

[.programlisting]
....
# Device                Mountpoint      FStype  Options         Dump    Pass#
/dev/ad0s1b.bde         none            swap    sw              0       0
....

=== Шифрование раздела подкачки при помощи man:geli[8]

Процедура при использовании man:geli[8] для шифрования раздела подкачки сходна с использованием man:gbde[8]. В строку файла [.filename]#/etc/fstab#, описывающую раздел подкачки, нужно добавить суффикс `.eli`:

[.programlisting]
....
# Device                Mountpoint      FStype  Options         Dump    Pass#
/dev/ad0s1b.eli         none            swap    sw              0       0
....

По умолчанию, man:geli[8] использует алгоритм криптования AES с длиной ключа 256 бит.

При необходимости эти параметры могут быть изменены в опции `geli_swap_flags` файла конфигурации [.filename]#/etc/rc.conf#. Приведенная ниже строка указывает, что скрипт rc.d [.filename]#encswap# должен использовать для криптования алгоритм Blowfish с ключом длиной 128 бит, размером сектора 4 килобайта и включенной опцией "отсоединиться при последнем закрытии":

[.programlisting]
....
geli_swap_flags="-e blowfish -l 128 -s 4096 -d"
....

За списком возможных опций обращайтесь к описанию команды `onetime` в странице справочника man:geli[8].

=== Окончательная проверка

После перезагрузки системы правильность работы шифрованного раздела подкачки может быть проверена при помощи команды `swapinfo`.

В случае использования man:gbde[8]:

[source,bash]
....
% swapinfo
Device          1K-blocks     Used    Avail Capacity
/dev/ad0s1b.bde    542720        0   542720     0%
....

При использовании man:geli[8]:

[source,bash]
....
% swapinfo
Device          1K-blocks     Used    Avail Capacity
/dev/ad0s1b.eli    542720        0   542720     0%
....
