---
title: "Глава 5. Установка приложений: порты и пакеты"
part: Часть I. В начале
prev: books/handbook/basics
next: books/handbook/x11
showBookMenu: true
weight: 7
path: "/books/handbook/ports/"
---

[[ports]]
= Установка приложений: порты и пакеты
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 5
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/ports/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[ports-synopsis]]
== Обзор

Вместе с FreeBSD в составе базового комплекта системы поставляется богатый набор системный утилит. Однако для выполнения какой-то реальной работы очень скоро возникает необходимость в установке дополнительных приложений сторонних разработчиков. FreeBSD дает две взаимодополняющих технологии для установки программного обеспечения сторонних разработчиков: Коллекция Портов FreeBSD (для установки из исходных кодов) и пакеты (для установки из откомпилированных двоичных файлов). Любая из этих систем может быть использована для установки приложений с локальных носителей или прямо из сети.

После чтения этой главы вы будете знать:

* Как устанавливать бинарные пакеты с программным обеспечением сторонних разработчиков.
* Как собирать из исходных кодов программное обеспечение сторонних разработчиков при помощи Коллекции Портов.
* Как удалять ранее установленные пакеты или порты.
* Как переопределить значения, используемые по умолчанию в Коллекции Портов.
* Как найти необходимое программное обеспечение.
* Как обновить установленные приложения.

[[ports-overview]]
== Обзор установки программного обеспечения

Стандартная процедура установки программного обеспечения сторонних разработчиков на UNIX(R)-систему выглядит примерно так:

[.procedure]
====
. Загрузка программного обеспечения, которое может распространяться в форме исходных текстов или двоичных файлов.
. Распаковка программного обеспечения из дистрибутивного формата (обычно tar-архива, сжатого при помощи man:compress[1], man:gzip[1] или man:bzip2[1]).
. Поиск документации в файлах [.filename]#INSTALL#, [.filename]#README# или в каком-то файле из подкаталога [.filename]#doc/# и её чтение в поиске описания установки программного обеспечения.
. Если программное обеспечение распространялось в форме исходных текстов, его компиляция. Сюда может быть включено редактирования файла [.filename]#Makefile#, запуск скрипта `configure` и другие работы.
. Тестирование и установка программного обеспечения.
====

Если вы устанавливаете программный пакет, который не был специально перенесён на FreeBSD, то вам может даже потребоваться редактировать код для того, чтобы он нормально заработал.

FreeBSD предоставляет две технологии, которые выполняют эту работу за вас. На момент написания таким образом доступно более {numports} сторонних приложений.

Каждый пакет содержит уже откомпилированные копии всех команд приложения, а также все конфигурационные файлы и документацию. С файлом пакета можно работать командами управления пакетами FreeBSD, такими как man:pkg_add[1], man:pkg_delete[1], man:pkg_info[1] и так далее.

Каждый порт FreeBSD является набором файлов, предназначенных для автоматизации процесса компиляции приложения из исходного кода. Файлы, из которых состоит порт, содержат всю необходимую информацию для выполнения автоматической загрузки, извлечения, применения патчей, компиляции и установки приложения.

Также система портов может использоваться для генерации пакетов, которые в последствии становятся объектом работы для команд управления пакетами FreeBSD.

Как пакеты, так и порты принимают во внимание _зависимости_. Если при инсталляции приложения при помощи man:pkg_add[1] или Коллекции Портов будет обнаружено, что необходимая библиотека не была установлена, то первым делом будет выполнена установка библиотеки.

Несмотря на то, что обе технологии весьма похожи, и пакеты, и порты имеют свои преимущества. Выберите технологию, которая соответствует вашим требованиям к установке конкретного приложения.

.Преимущества пакетов
* Сжатый tar-архив пакета обычно меньше, чем сжатый tar-архив, содержащий исходный код приложения.
* Пакеты не требуют времени на компиляцию. Для больших приложений, таких как Mozilla, KDE или GNOME, это может быть важно, особенно при работе на медленной системе.
* Пакеты не требуют понимания процесса компиляции программного обеспечения во FreeBSD.

.Преимущества портов
* Пакеты обычно компилируются с консервативными параметрами, потому что они должны работать на максимальном количестве систем. При установке из порта становится возможным изменение опций компиляции.
* Некоторые приложения имеют опции времени компиляции, позволяющие определять необходимые функциональные возможности. К примеру, Apache может быть настроен с широким набором различных опций.
+ 
В некоторых случаях для одного и того же приложения будут иметься несколько пакетов с разными предварительными настройками. Например, Ghostscript доступен как пакет [.filename]#ghostscript# и как пакет [.filename]#ghostscript-nox11# - в зависимости от того, установлен ли сервер X11. Создание нескольких пакетов одного приложения быстро становится бессмысленным, если приложение имеет более одного-двух параметров компиляции.
* Условия лицензирования некоторого программного обеспечения запрещают распространение в двоичном виде. Оно должно распространяться в виде исходного кода и компилироваться конечным пользователем.
* Некоторые пользователи не доверяют дистрибутивам в двоичном виде или предпочитают прочесть исходный код и попытаться найти потенциальные проблемы.
* Если у вас есть собственные патчи, вам нужен исходный код для того, чтобы их применять.

Чтобы отслеживать обновления портов, подпишитесь на {freebsd-ports} и {freebsd-ports-bugs}.

[WARNING]
====

Перед установкой любого приложения необходимо зайти на http://vuxml.freebsd.org/[http://vuxml.freebsd.org/], где находится информация по вопросам безопасности приложений, или установить package:ports-mgmt/portaudit[]. После установки наберите `portaudit -F -a` для проверки всех установленных приложений на наличие известных уязвимостей.
====

В оставшейся части главы будет рассказано, как использовать пакеты и порты для установки и управления программным обеспечением сторонних разработчиков во FreeBSD.

[[ports-finding-applications]]
== Поиск программного обеспечения

Список имеющихся для FreeBSD приложений постоянно растет. Существует несколько способов найти то, что нужно:

* На сайте FreeBSD по адресу link:https://www.FreeBSD.org/ports/[http://www.FreeBSD.org/ports/] поддерживается обновляемый список всех имеющихся приложений для FreeBSD, в котором можно выполнять поиск. Поиск порта можно выполнить либо по имени приложения, либо по названию категории.
* Dan Langille поддерживает сайт http://www.FreshPorts.org/[FreshPorts], на котором есть удобный поиск, а также на нём отслеживаются изменения в приложениях из Коллекции Портов. Зарегистрированным пользователям доступна возможность создавать собственные списки наблюдаемых портов и автоматически получать оповещения об их обновлениях по электронной почте.
* Если вы не знаете названия нужного вам приложения, попытайтесь воспользоваться сайтом типа Freecode (http://www.freecode.com/[http://www.freecode.com/]) для поиска приложения, а затем возвратитесь на сайт FreeBSD, чтобы проверить, есть ли порт для этого приложения.
* Если вам необходимо определить, в какой категории находится порт, наберите `whereis _file_`, где _file_ - программа, которую вы хотите установить:
+
[source,shell]
....
# whereis lsof
lsof: /usr/ports/sysutils/lsof
....
+ 
Как вариант, можно воспользоваться man:echo[1]:
+
[source,shell]
....
# echo /usr/ports/*/*lsof*
/usr/ports/sysutils/lsof
....
+ 
Учтите, что в выводе также будут присутствовать совпадающие с шаблоном имена файлов, сохраненные в [.filename]#/usr/ports/distfiles#.
* Ещё одним способом поиска программного обеспечения является использование встроенной возможности поиска в Коллекции Портов. Чтобы ею воспользоваться, зайдите в [.filename]#/usr/ports# и выполните команду `make search name=_program-name_`, где _program-name_ - это название программы, которую вы хотите найти. Например, если вы ищете `lsof`:
+
[source,shell]
....
# cd /usr/ports
# make search name=lsof
Port:   lsof-4.56.4
Path:   /usr/ports/sysutils/lsof
Info:   Lists information about open files (similar to fstat(1))
Maint:  obrien@FreeBSD.org
Index:  sysutils
B-deps:
R-deps:
....
+
[TIP]
====

Команда `make search` выполняет поиск в файле с индексной информацией. Если получено сообщение, что требуется файл [.filename]#INDEX#, запустите `make fetchindex` для загрузки актуального индексного файла. После загрузки файла [.filename]#INDEX# команда `make search` сможет выполнить запрошенный поиск.
====
+ 
Строка "Path:" указывает, где находится порт.
+ 
Чтобы получить лаконичный вывод, задайте цель `quicksearch`:
+
[source,shell]
....
# cd /usr/ports
# make quicksearch name=lsof
Port:   lsof-4.87.a,7
Path:   /usr/ports/sysutils/lsof
Info:   Lists information about open files (similar to fstat(1))
....
+ 
Для выполнения более глубокого поиска используйте `make search key=_string_` или `make quicksearch key=_string_`, где _string_ представляет собой некоторый текст, относящийся к искомому порту. Текст ищется в комментариях, описаниях или зависимостях. Этот способ можно использовать для поиска портов, связанных с некоторой темой, когда название программы неизвестно.
+ 
В обоих случаях (`search` и `quicksearch`) строка поиска нечувствительна к регистру. Поиск "LSOF" приводит к тому же самому результату, что и поиск "lsof".

[[packages-using]]
== Использование бинарных пакетов

Во FreeBSD есть несколько утилит для управления пакетами:

* Для установки, удаления и получения перечня установленных пакетов на работающей системе может быть запущена утилита `sysinstall`. Обратитесь к crossref:install[packages,Установка пакетов (Install Packages)] за более детальной информацией.
* Утилиты командной строки для управления пакетами, которые являются темой данного раздела.

=== Установка пакета

Для установки бинарного пакета FreeBSD из локального файла или с сервера в сети используйте man:pkg_add[1].

.Загрузка пакета вручную и его локальная установка
[example]
====

[source,shell]
....
# ftp -a ftp2.FreeBSD.org
Connected to ftp2.FreeBSD.org.
220 ftp2.FreeBSD.org FTP server (Version 6.00LS) ready.
331 Guest login ok, send your email address as password.
230-
230-     This machine is in Vienna, VA, USA, hosted by Verio.
230-         Questions? E-mail freebsd@vienna.verio.net.
230-
230-
230 Guest login ok, access restrictions apply.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp> cd /pub/FreeBSD/ports/packages/sysutils/
250 CWD command successful.
ftp> get lsof-4.56.4.tgz
local: lsof-4.56.4.tgz remote: lsof-4.56.4.tgz
200 PORT command successful.
150 Opening BINARY mode data connection for 'lsof-4.56.4.tgz' (92375 bytes).
100% |**************************************************| 92375       00:00 ETA
226 Transfer complete.
92375 bytes received in 5.60 seconds (16.11 KB/s)
ftp> exit
# pkg_add lsof-4.56.4.tgz
....

====

Если у вас нет источника пакетов, например, такого как набор CD-ROM дисков с FreeBSD, то добавьте опцию `-r` для man:pkg_add[1]. Утилита автоматически определит правильный формат объектных файлов и релиз, а затем загрузит и установит пакет с сервера FTP без какого-либо дополнительного взаимодействия с пользователем.

[source,shell]
....
# pkg_add -r lsof
....

Чтобы задействовать альтернативное зеркало пакетов FreeBSD, укажите его адрес в переменной окружения `PACKAGESITE`. Для загрузки файлов утилита man:pkg_add[1] использует man:fetch[3]. Последняя учитывает значения различных переменных окружения, включая `FTP_PASSIVE_MODE`, `FTP_PROXY` и `FTP_PASSWORD`. Если вы находитесь за сетевым экраном, или для работы с FTP/HTTP вам необходимо использовать прокси, то определите соответствующие переменные. Обратитесь к справочной странице по man:fetch[3] для получения полного списка переменных. Заметьте, что в примере выше вместо `lsof-4.56.4` используется `lsof`. В случае загрузки из сети номер версии в имени пакета должен быть опущен.

[NOTE]
====
Если вы используете FreeBSD-CURRENT или FreeBSD-STABLE, то утилита man:pkg_add[1] загрузит последнюю версию устанавливаемой программы. Если же вы используете версию -RELEASE, то man:pkg_add[1] установит версию пакета, который был собран для конкретного релиза. Это поведение возможно изменить переопределив значение `PACKAGESITE`. Например, в системе FreeBSD 8.1-RELEASE man:pkg_add[1] по умолчанию попытается скачать пакеты с `ftp://ftp.freebsd.org/pub/FreeBSD/ports/i386/packages-8.1-release/Latest/`. Чтобы обязать man:pkg_add[1] загружать пакеты для FreeBSD 8-STABLE, присвойте `PACKAGESITE` значение `ftp://ftp.freebsd.org/pub/FreeBSD/ports/i386/packages-8-stable/Latest/`.
====

Файлы пакетов распространяются в форматах [.filename]#.tgz# и [.filename]#.tbz#. Пакеты находятся по адресу link:ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/packages[ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/packages] или в каталоге [.filename]#/packages# дистрибутива FreeBSD на DVD. Структура каталогов с пакетами подобна тому, как организовано дерево [.filename]#/usr/ports#. Каждая категория имеет собственный каталог, и каждый пакет помещается в каталог [.filename]#All#.

=== Управление пакетами

Для вывода перечня установленных пакетов и их описаний может быть задействована man:pkg_info[1].

[source,shell]
....
# pkg_info
colordiff-1.0.13    A tool to colorize diff output
docbook-1.2         Meta-port for the different versions of the DocBook DTD
...
....

Утилита man:pkg_version[1] выводит отчёт о версиях всех установленных пакетов и сравнивает их версии с текущими версиями соответствующих приложений, доступных из локального дерева портов.

[source,shell]
....
# pkg_version
colordiff                   =
docbook                     =
...
....

Символы во второй колонке указывают сравнительную разницу в возрасте установленной версии и версии, находящейся в локальном дереве портов.

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Символ
| Значение

|=
|Версия установленного пакета соответствует версии, находящейся в локальном дереве портов.

|<
|Версия установленного пакета старее, чем та, что имеется в локальном дереве портов.

|>
|Версия установленного пакета новее чем та, что есть в дереве портов. Скорее всего, локальное дерево портов устарело.

|?
|В индексном файле портов установленный пакет не найден. Это может случиться если установленный порт был переименован или удалён из Коллекции Портов.

|*
|Имеется несколько версий пакета.

|!
|Установленный пакет есть в индексном файле, но по какой-то причине утилите `pkg_version` не удалось сравнить номер версии установленного пакета и соответствующей записи в файле.
|===

=== Удаление пакета

Для удаления ранее установленных пакетов с программным обеспечением используйте утилиту man:pkg_delete[1].

[source,shell]
....
# pkg_delete xchat-1.7.1
....

Следует отметить, что для man:pkg_delete[1] требуется полное имя пакета и номер версии; вышеприведенная команда не сработала бы, если б ей было указано _xchat_ вместо _xchat-1.7.1_. Для нахождения версии установленного пакета задействуйте утилиту man:pkg_version[1]. Или же, напечатайте групповой символ (wildcard) вместо номера версии:

[source,shell]
....
# pkg_delete xchat\*
....

в этом случае будут удалены все пакеты, имена которых начинаются на `xchat`.

=== Разное

Вся информация о пакетах, включая перечни файлов и описания каждого установленного пакета, хранится в каталоге [.filename]#/var/db/pkg#.

[[pkgng-intro]]
== Использование pkgng для управления бинарными пакетами

pkgng - это усовершенствованный инструмент, пришедший на смену традиционным утилитам управления пакетами FreeBSD. Он обладает множеством функциональных возможностей, ускоряющих и облегчающих работу с бинарными пакетами. Первый релиз pkgng состоялся в августе 2012 года.

pkgng не является заменой для утилит управления портами, таких как package:ports-mgmt/portmaster[] или package:ports-mgmt/portupgrade[]. В то время, как package:ports-mgmt/portmaster[] и package:ports-mgmt/portupgrade[] позволяют устанавливать приложения сторонних разработчиков как из бинарных пакетов, так и из Коллекции Портов, утилита pkgng дает возможность устанавливать приложения исключительно из бинарных пакетов.

[[pkgng-initial-setup]]
=== Начало работы с pkgng

Во FreeBSD 9.1 и более поздние включена программа "самонастройки" ("bootstrap") pkgng. Она скачивает и устанавливает основную утилиту pkgng.

Для запуска самонастройки, выполните:

[source,shell]
....
# /usr/sbin/pkg
....

Для более ранних версий FreeBSD утилиту pkgng необходимо установить из Коллекции Портов или из бинарных пакетов.

Для установки pkgng из порта, запустите следующее:

[source,shell]
....
# cd /usr/ports/ports-mgmt/pkg
# make
# make install clean
....

Для установки из бинарного пакета, выполните:

[source,shell]
....
# pkg_add -r pkg
....

Действующие инсталляции FreeBSD требуют преобразования базы данных установленных пакетов утилиты pkg_install к новому формату. Для выполнения конвертирования, запустите:

[source,shell]
....
# pkg2ng
....

Вышеприведенный шаг не требуется для новых инсталляций, в которых не было установлено программ сторонних разработчиков.

[IMPORTANT]
====
Этот шаг необратим. После перевода базы данных установленных пакетов к формату pkgng утилитами pkg_install более пользоваться не следует.
====

[NOTE]
====
В процессе конвертирования базы данных установленных пакетов могут возникать сообщения об ошибках. На данном этапе их можно игнорировать, так как перечень программ сторонних разработчиков, информация о которых не была преобразована, будет перечислен по завершении работы `pkg2ng`. Над этим перечнем придется поработать вручную.
====

Чтобы убедиться, что Коллекция Портов FreeBSD регистрирует новые программы при помощи pkgng, а не pkg_install, для версий FreeBSD, предшествующих 10._X_, в файл [.filename]#/etc/make.conf# необходимо внести следующую запись:

[.programlisting]
....
WITH_PKGNG=	yes
....

[[pkgng-pkg-conf]]
=== Настройка окружения pkgng

Система управления пакетами pkgng при выполнении большинства операций обращается к пакетному репозиторию. Адрес используемого по умолчанию репозитория указан в [.filename]#/usr/local/etc/pkg.conf# или в переменной окружения `PACKAGESITE`. Последняя переопределяет адрес, указанный в конфигурационном файле.

Дополнительные опции конфигурации pkgng описаны в pkg.conf(5).

[[pkgng-basic-usage]]
=== Основные операции pkgng

Информацию по работе с pkgng можно найти на странице справочника pkg(8), или в выводе утилиты `pkg`, запущенной без аргументов.

Каждый аргумент команды pkgng описан на соответствующей странице справочника. Например, чтобы ознакомиться со страницей справочника для `pkg install`, запустите любую из двух нижеследующих команд:

[source,shell]
....
# pkg help install
....

[source,shell]
....
# man pkg-install
....

[[pkgng-pkg-info]]
==== Получение информации об установленных пакетах при помощи pkgng

Информация об установленных в системе пакетах может быть отображена при помощи команды `pkg info`. Подобно до man:pkg_info[1], в выводе перечисляются версии и описания всех установленных пакетов.

Если необходима информация о конкретном пакете, выполните:

[source,shell]
....
# pkg info packagename
....

Например, для получения версии pkgng, который установлен в системе, запустите:

[source,shell]
....
# pkg info pkg
pkg-1.0.2			New generation package manager
....

[[pkgng-installing-deinstalling]]
==== Установка и удаление пакетов при помощи pkgng

В общем, бинарные пакеты устанавливаются при помощи:

[source,shell]
....
# pkg install packagename
....

Команда `pkg install` обращается к пакетному репозиторию, это упоминалось в <<pkgng-pkg-conf>>. Команда pkg-add(8), напротив, не выполняет обращений к пакетному репозиторию, а также игнорирует переменную `PACKAGESITE`. Как следствие - зависимости не отслеживаются, и необходимые зависимые компоненты не скачиваются с удаленного источника. В этом разделе описана работа с `pkg install`. За подробностями работы с `pkg add` обратитесь к справочной странице по pkg-add(8).

Утилита `pkg install` может устанавливать дополнительные бинарные пакеты. Например, для установки curl, выполните:

[source,shell]
....
# pkg install curl
Updating repository catalogue
Repository catalogue is up-to-date, no need to fetch fresh copy
The following packages will be installed:

	Installing ca_root_nss: 3.13.5
	Installing curl: 7.24.0

The installation will require 4 MB more space

1 MB to be downloaded

Proceed with installing packages [y/N]: y
ca_root_nss-3.13.5.txz		100%	255KB 	255.1KB/s 255.1KB/s	00:00
curl-7.24.0.txz			100%	1108KB	1.1MB/s	1.1MB/s		00:00
Checking integrity... done
Installing ca_root_nss-3.13.5... done
Installing curl-7.24.0... done
....

Новый пакет, как и любые дополнительные пакеты, которые были установлены как зависимости, перечисляются в списке установленных пакетов:

[source,shell]
....
# pkg info
ca_root_nss-3.13.5	The root certificate bundle from the Mozilla Project
curl-7.24.0	Non-interactive tool to get files from FTP, GOPHER, HTTP(S) servers
pkg-1.0.2	New generation package manager
....

Пакеты, в которых более нет необходимости, могут быть удалены при помощи `pkg delete`. Например, если выяснится, что curl не нужен:

[source,shell]
....
# pkg delete curl
The following packages will be deleted:

	curl-7.24.0_1

The deletion will free 3 MB

Proceed with deleting packages [y/N]: y
Deleting curl-7.24.0_1... done
....

[[pkgng-upgrading]]
==== Обновление установленных пакетов при помощи pkgng

Пакеты, версии которых устарели, можно найти при помощи команды `pkg version`. Версии установленных пакетов сравниваются с версиями приложений из локального дерева портов, а в случае отсутствия портов pkg-version(8) обращается к удаленному репозиторию пакетов.

При помощи pkgng можно обновлять пакеты до новых версий. Предположим, вышла новая версия curl. Установленный пакет можно обновить к новой версии, выполнив:

[source,shell]
....
# pkg upgrade
Updating repository catalogue
repo.txz		100%	297KB 296.5KB/s 296.5KB/s	00:00
The following packages will be upgraded:

	Upgrading curl: 7.24.0 -> 7.24.0_1

1 MB to be downloaded

Proceed with upgrading packages [y/N]: y
curl-7.24.0_1.txz	100% 1108KB	1.1MB/s	1.1MB/s		00:00
Checking integrity... done
Upgrading curl from 7.24.0 to 7.24.0_1... done
....

[[pkgng-auditing]]
==== Аудит безопасности пакетов при помощи pkgng

Изредка в приложениях из Коллекции Портов обнаруживаются уязвимости. В pkgng встроена возможность выполнять аудит безопасности, действующая подобно приложению из package:ports-mgmt/portaudit[]. Для выполнения аудита установленных в систему программ, выполните:

[source,shell]
....
# pkg audit -F
....

[[pkgng-advanced-usage]]
=== Сложные вопросы работы с pkgng

[[pkgng-autoremove]]
==== Автоматическое удаление неиспользуемых зависимостей при помощи pkgng

После удаления пакета в системе могут остаться неиспользуемые зависимости, наподобие package:security/ca_root_nss[] из примера выше. Такие пакеты остаются установленными, несмотря на то, что они более не требуются другим пакетам. Определить и удалить неиспользуемые пакеты, которые были установлены как зависимости, можно при помощи:

[source,shell]
....
# pkg autoremove
Packages to be autoremoved:
	ca_root_nss-3.13.5

The autoremoval will free 723 kB

Proceed with autoremoval of packages [y/N]: y
Deinstalling ca_root_nss-3.13.5... done
....

[[pkgng-backup]]
==== Резервное копирование базы данных установленных пакетов pkgng

В отличие от традиционной системы управления пакетами, pkgng располагает своим собственным механизмом резервного копирования базы данных. Для ручного создания резервной копии базы данных установленных пакетов, выполните:

[source,shell]
....
# pkg backup -d pkgng.db
....

[NOTE]
====
Замените имя файла _pkgng.db_ на более подходящее.
====

В дополнение, pkgng содержит скрипт man:periodic[8], позволяющий выполнять ежедневное автоматическое копирование базы данных установленных пакетов. Для активации данной возможности задайте переменной `daily_backup_pkgng_enable` значение `YES` в файле man:periodic.conf[5].

[TIP]
====

Для предотвращения периодического запуска аналогичного скрипта системы pkg_install, также выполняющего резервное копирование базы данных установленных пакетов, задайте переменной `daily_backup_pkgdb_enable` значение `NO` в файле man:periodic.conf[5].
====

Для восстановления содержимого базы данных установленных пакетов из резервной копии, выполните:

[source,shell]
....
# pkg backup -r /path/to/pkgng.db
....

[[pkgng-clean]]
==== Удаление копий устаревших пакетов в системе pkgng

По умолчанию, pkgng сохраняет копии установленных бинарных пакетов в каталог, указанный переменной `PKG_CACHEDIR` в pkg.conf(5). При обновлении пакетов командой `pkg upgrade` старые версии обновленных пакетов автоматически не удаляются.

Для удаления устаревших версий бинарных пакетов из кеш-каталога, выполните:

[source,shell]
....
# pkg clean
....

[[pkgng-set]]
==== Изменение метаданных пакетов pkgng

Со временем программы из Коллекции Портов могут претерпевать изменения старшего (major) номера версии. В отличие от pkg_install, pkgng располагает встроенной командой для обновления информации о происхождении (origin) пакета. Например, изначально порт package:lang/php5[] был версии `5.3`. Позже этот порт был переименован в package:lang/php53[], а под именем package:lang/php5[] был создан порт версии `5.4`. Утилитам системы pkg_install для обновления информации о происхождении (origin) пакета в собственной базе данных установленных пакетов потребовалась бы помощь дополнительного программного обеспечения, такого как package:ports-mgmt/portmaster[].

В отличие от package:ports-mgmt/portmaster[] и package:ports-mgmt/portupgrade[] для портов, порядок перечисления новой и старой версий отличаются. Для pkgng необходим следующий порядок:

[source,shell]
....
# pkg set -o category/oldport:category/newport
....

Например, в вышеприведенном случае для замены информации о происхождении пакета, выполните:

[source,shell]
....
# pkg set -o lang/php5:lang/php53
....

Еще один пример: для изменения информации о происхождении пакета с package:lang/ruby18[] на package:lang/ruby19[], выполните:

[source,shell]
....
# pkg set -o lang/ruby18:lang/ruby19
....

И последний пример: для замены информации о происхождении пакета разделяемой библиотеки [.filename]#libglut# с package:graphics/libglut[] на package:graphics/freeglut[], запустите:

[source,shell]
....
# pkg set -o graphics/libglut:graphics/freeglut
....

[NOTE]
====
Выполняя замену информации о происхождении пакетов, в большинстве случаев также требуется переустановить пакеты, которые зависят от изменившегося пакета. Для принудительной переустановки зависящих пакетов, выполните:

[source,shell]
....
# pkg install -Rf graphics/freeglut
....

====

[[ports-using]]
== Использование Коллекции Портов

В этом разделе даны базовые сведения по использованию Коллекции Портов для установки или удаления программ. Детальное описание существующих целей `make` и переменных окружения находится в man:ports[7].

[WARNING]
====

В июле 2012 года проект Портов FreeBSD сменил систему контроля версий: на смену CVS пришел Subversion. Рекомендуемым способом работы с деревом портов является Portsnap. Пользователи, которым требуется локальная подгонка портов (то есть, поддержание дополнительных локальных патчей), возможно предпочтут непосредственное использование Subversion. 28 февраля 2013 года сервис CVSup был выведен из эксплуатации, и дальнейшее использование последнего не рекомендуется.
====

[[ports-tree]]
=== Получение Коллекции Портов

Коллекция Портов - это набор файлов, состоящий из [.filename]#Makefile#, патчей и файлов описаний, хранимых в [.filename]#/usr/ports#. Этот набор файлов предназначен для построения и установки приложений во FreeBSD. В нижеследующих разделах описано несколько способов получения Коллекции Портов на тот случай, если Коллекция не была установлена во время инсталляции FreeBSD.

[.procedure]
====
*Procedure: Метод Portsnap*

Portsnap это быстрый и удобный инструмент для получения Коллекции Портов, и в то же время - предпочитаемый выбор большинства пользователей.

. Скачайте сжатый снэпшот Коллекции Портов в [.filename]#/var/db/portsnap#.
+
[source,shell]
....
# portsnap fetch
....
+
. Если вы запускаете Portsnap впервые, извлеките снэпшот в [.filename]#/usr/ports#:
+
[source,shell]
....
# portsnap extract
....
+
. По завершении первого запуска Portsnap, как было показано выше, [.filename]#/usr/ports# может быть обновлен при помощи:
+
[source,shell]
....
# portsnap fetch
# portsnap update
....
====

[.procedure]
====
*Procedure: Метод Subversion*

Если необходим контроль за деревом портов (например, для поддержания локальных изменений), то для получения Коллекции Портов может быть задействован Subversion. Обратитесь к extref:{committers-guide}[Subversion Primer, subversion-primer] за детальным описанием Subversion.

. Для создания рабочей копии дерева портов необходимо иметь установленный Subversion. Если порты есть в наличии, то установите Subversion выполнив следующее:
+
[source,shell]
....
# cd /usr/ports/devel/subversion
# make install clean
....
+ 
Если портов нет, то Subversion может быть установлен при помощи системы пакетов:
+
[source,shell]
....
# pkg_add -r subversion
....
+ 
Если же для управления пакетами используется pkgng, то Subversion устанавливается при помощи следующей команды:
+
[source,shell]
....
# pkg install subversion
....
+
. Создайте рабочую копию дерева портов. Для ускорения процесса вместо _svn0.us-east.FreeBSD.org_ укажите ближайшее к вам crossref:mirrors[svn-mirrors,зеркало Subversion]. Коммиттерам необходимо сначала прочитать extref:{committers-guide}[Subversion Primer, subversion-primer], чтобы удостовериться, что выбран корректный протокол.
+
[source,shell]
....
# svn checkout https://svn0.us-east.FreeBSD.org/ports/head /usr/ports
....
+
. При наличии рабочей копии [.filename]#/usr/ports# все последующие обновления выполняются просто:
+
[source,shell]
....
# svn update /usr/ports
....
====

[.procedure]
====
*Procedure: Метод с использованием Sysinstall*

Этот метод подразумевает использование sysinstall для установки Коллекции Портов из установочного носителя. Учтите, что в итоге будет установлена старая копия Коллекции Портов, которая была актуальна на момент создания релиза. Если у вас есть подключение к Интернет, то вам необходимо пользоваться одним из вышеупомянутых методов.

. Работая как пользователь `root`, запустите `sysinstall` так, как это показано ниже:
+
[source,shell]
....
# sysinstall
....
+
. Опуститесь вниз и выберите [.guimenuitem]#Configure#, нажмите kbd:[Enter]
. Опуститесь вниз и выберите [.guimenuitem]#Distributions#, затем нажмите kbd:[Enter]
. Опуститесь вниз к пункту [.guimenuitem]#ports#, нажмите клавишу kbd:[Пробел]
. Поднимитесь вверх к [.guimenuitem]#Exit#, нажмите kbd:[Enter]
. Выберите желаемый носитель для установки, например, CDROM, FTP и так далее.
. Перейдите на пункт меню [.guimenuitem]#Exit# и нажмите kbd:[Enter].
. Нажмите kbd:[X] для выхода из sysinstall.
====

[[cvsup-migration]]
=== Миграция с CVSup/csup на portsnap

[WARNING]
====

Начиная с 28 февраля 2013 года дерево портов более не экспортируется в CVS, поэтому CVSup и csup не будут доставлять обновления для дерева портов.
====

[.procedure]
====
*Procedure: Миграция на Portsnap*

Для миграции потребуется около 1 ГБ дискового пространства в [.filename]#/usr#, в добавок, для Portsnap необходимо около 150 МБ дискового пространства в [.filename]#/var#.

. Если у вас настроено автоматическое обновление портов, например при помощи задания man:cron[8], запускающего CVSup или csup, то его необходимо будет отключить.
. Переместите существующее дерево портов во временный каталог:
+
[source,shell]
....
# mv /usr/ports /usr/ports.old
....
+
. При помощи Portsnap скачайте новое дерево портов и извлеките его в [.filename]#/usr/ports#:
+
[source,shell]
....
# portsnap fetch extract
....
+
. Переместите дистрибутивные файлы (distfiles) и сохраненные пакеты в новое дерево портов:
+
[source,shell]
....
# mv /usr/ports.old/distfiles /usr/ports
# mv /usr/ports.old/packages /usr/ports
....
+
. Удалите старое дерево портов:
+
[source,shell]
....
# rm -rf /usr/ports.old
....
+
. Если ранее использовался CVSup, то сейчас его можно удалить:
+
[source,shell]
....
# pkg_delete -r -v cvsup-without-gui-\*
....
+ 
Пользователям pkgng необходимо запустить следующую команду:
+
[source,shell]
....
# pkg delete cvsup-without-gui
....
====

[[ports-skeleton]]
=== Установка портов

Скелетом порта является набор файлов, который указывает вашей системе FreeBSD, как откомпилировать и установить программу. Скелет каждого порта включает:

* [.filename]#Makefile#: этот файл содержит различные директивы, которые определяют, как приложение должно быть откомпилировано и куда в вашей системе оно должно быть установлено.
* [.filename]#distinfo#: этот файл содержит информацию о файлах, которые должны быть загружены для сборки порта, а также их контрольные суммы (man:sha256[1]) для проверки того, что файлы не были повреждены в процессе загрузки.
* [.filename]#files#: этот каталог содержит патчи, необходимые для компиляции и установки программы в вашей системе FreeBSD. Этот каталог также может содержать другие файлы, используемые для построения порта.
* [.filename]#pkg-descr#: этот файл содержит более подробное описание программы.
* [.filename]#pkg-plist#: это список всех файлов, которые будут установлены портом. В нем также содержатся указания системе портов на удаление определенных файлов во время удаления порта.

В некоторых портах присутствуют и другие файлы, такие, как [.filename]#pkg-message#. Система портов использует эти файлы для обработки особых ситуаций. Если вы хотите узнать более подробно об этих файлах и о портах вообще, то обратитесь к extref:{porters-handbook}[Руководству по созданию портов для FreeBSD].

Порт не содержит собственно исходного кода, также известного как "дистрибутивный файл" (distfile). Способ распространения исходного кода определяется предпочтениями автора программы. Ниже описаны два способа установки порта FreeBSD.

[NOTE]
====
Для установки портов вы должны войти в систему как пользователь `root`.
====

[WARNING]
====

Перед установкой любого порта необходимо убедиться в наличии свежей Коллекции Портов и заглянуть на http://vuxml.freebsd.org/[http://vuxml.freebsd.org/], где могут освещаться вопросы безопасности, связанные с конкретным портом. Если у вас установлен package:ports-mgmt/portaudit[], то перед установкой нового порта запустите `portaudit -F` для загрузки свежей базы данных уязвимостей. Проверка безопасности и обновление базы данных будут выполняться при ежедневной проверке безопасности системы. За дальнейшей информацией обратитесь к страницам справочника man:portaudit[1] и man:periodic[8].
====

Использование Коллекции Портов предполагает наличие работающего подключения к Интернет. В противном случае вам придется раздобыть и поместить копию дистрибутивного файла в каталог [.filename]#/usr/ports/distfiles# вручную.

Первым делом переместитесь в каталог устанавливаемого порта:

[source,shell]
....
# cd /usr/ports/sysutils/lsof
....

Для компиляции (или построения - "build") порта наберите команду `make`. Вы должны увидеть вывод команды, подобный следующему:

[source,shell]
....
# make
>> lsof_4.57D.freebsd.tar.gz doesn't seem to exist in /usr/ports/distfiles/.
>> Attempting to fetch from ftp://lsof.itap.purdue.edu/pub/tools/unix/lsof/.
===>  Extracting for lsof-4.57
...
[вывод команды при распаковке опущен]
...
>> Checksum OK for lsof_4.57D.freebsd.tar.gz.
===>  Patching for lsof-4.57
===>  Applying FreeBSD patches for lsof-4.57
===>  Configuring for lsof-4.57
...
[вывод команды при конфигурации опущен]
...
===>  Building for lsof-4.57
...
[вывод команды при компиляции опущен]
...
#
....

По завершении компиляции вы снова вернетесь к приглашению командного процессора. Следующим шагом является установка порта при помощи `make install`:

[source,shell]
....
# make install
===>  Installing for lsof-4.57
...
[вывод команды при установке опущен]
...
===>   Generating temporary packing list
===>   Compressing manual pages for lsof-4.57
===>   Registering installation for lsof-4.57
===>  SECURITY NOTE:
      This port has installed the following binaries which execute with
      increased privileges.
#
....

На этом этапе, получив приглашение оболочки, вы уже можете запустить установленное приложение. Так как `lsof` является программой, которая запускается с повышенными правами, выдаётся предупреждение о безопасности. Во время построения и установки портов следует обращать внимание на любые возникающие предупреждения.

Хорошей идеей является удаление рабочего подкаталога, содержащего временные файлы, использовавшиеся во время компиляции. Такое действие помогает беречь дисковое пространство и минимизирует вероятность возникновения проблем в дальнейшем, при обновлении до более новой версии порта.

[source,shell]
....
# make clean
===>  Cleaning for lsof-4.57
#
....

[NOTE]
====
Вы можете сэкономить два лишних шага, просто выдав команду `make install clean` вместо `make`, `make install` и последующей `make clean` в трех отдельных шагах.
====

[NOTE]
====
Установка порта единственной командой `make install` чревата возможными частыми остановками процесса инсталляции из-за ожидания вмешательства пользователя: некоторым портам требуется ввод опций. Чтобы избежать траты времени, особенно для портов с многими зависимостями, запустите сначала `make config-recursive` чтобы выполнить конфигурирование всех опций за один заход. Далее, запустите `make install [clean]`.
====

[TIP]
====

Когда используется `config-recursive`, перечень подлежащих настройке портов собирается целью `all-depends-list` команды man:make[1]. Часто рекомендуется повторять запуск `make config-recursive` до тех пор, пока не будут определены все опции зависимых портов, а меню man:dialog[1] выбора опций портов появляться перестанут. При этом можно быть уверенным, что все опции были настроены как и намеревалось.
====

[NOTE]
====
Некоторые командные процессоры для ускорения поиска исполняемых файлов и команд кэшируют имена программ, доступных для вызова из каталогов, перечисленных в переменной окружения `PATH`. Если вы используете `tcsh`, то вам может потребоваться набрать `rehash`, после чего свежеустановленную программу можно будет вызывать без указания полного пути. Для командного интерпретатора `sh` выполните `hash -r`. Дополнительную информацию можно найти в документации к вашему командному процессору.
====

В некоторых имеющихся в продаже комплектах DVD от третьих лиц, таких как the FreeBSD Toolkit от http://www.freebsdmall.com/[FreeBSD Mall], содержатся дистрибутивные файлы (distfiles). Их можно использовать с Коллекцией Портов. Смонтируйте DVD в [.filename]#/cdrom#. Если вы используете иную точку монтирования, укажите её в переменной man:make[1] `CD_MOUNTPTS`. Если необходимые для построения порта дистрибутивные файлы находятся на диске, то они будут задействованы автоматически.

[NOTE]
====
Лицензии некоторых портов не позволяют помещать их на DVD. Причиной тому может служить обязательность заполнения регистрационной формы перед загрузкой, или запрет на дальнейшее распространение. Если вы хотите установить порт, которого нет на DVD, вам нужно иметь подключение к Интернет.
====

Для загрузки файлов система портов использует утилиту man:fetch[1], которая проверяет значения некоторых переменных окружения, включая `FTP_PASSIVE_MODE`, `FTP_PROXY` и `FTP_PASSWORD`. Если вы находитесь за сетевым экраном или для работы с FTP/HTTP вам необходимо использовать прокси, то определите соответствующие переменные. Обратитесь к справочной странице по man:fetch[3] для получения полного списка переменных.

Пользователям, которые не могут быть постоянно подключены к сети, поможет команда `make fetch`. Запустите эту команду в каталоге [.filename]#/usr/ports#, и требуемые файлы будут загружены. Эта команда также работает и с вложенными категориями, например: [.filename]#/usr/ports/net#. Заметьте, что если порт имеет зависимости от библиотек или других портов, то команда _не будет_ загружать дистрибутивные файлы для зависимых портов. Для загрузки всех зависимых дистрибутивных файлов задействуйте команду `make fetch-recursive`.

[NOTE]
====
Вы можете построить все порты в категории за раз, запустив команду `make` в каталоге верхнего уровня. Однако это опасно, так как некоторые порты не могут сосуществовать. В других случаях некоторые порты могут устанавливать два различных файла с одним и тем же именем.
====

В некоторых редких случаях пользователям необходимо получить tar-архивы с сайтов, отличающихся от указанных по умолчанию в `MASTER_SITES`. Вы можете переопределить значение `MASTER_SITES` посредством следующей команды:

[source,shell]
....
# cd /usr/ports/directory
# make MASTER_SITE_OVERRIDE= \
ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/distfiles/ fetch
....

В этом примере значение переменной `MASTER_SITES` изменено на `ftp.FreeBSD.org/pub/FreeBSD/ports/distfiles/`.

[NOTE]
====
Некоторые порты позволяют указывать опции, которые включают или выключают построение отдельных частей приложения, изменяют некоторые параметры безопасности, а также задают прочие настройки. Примерами таких портов могут служить: package:www/firefox[], package:security/gpgme[] и package:mail/sylpheed-claws[]. Если для порта существуют опции компиляции, то перед началом построения будет отображено меню.
====

==== Переназначение рабочего и целевого каталогов

При помощи переменных `WRKDIRPREFIX` и `PREFIX` можно переопределить назначаемые по умолчанию рабочий и целевой каталоги. Например:

[source,shell]
....
# make WRKDIRPREFIX=/usr/home/example/ports install
....

будет компилировать порт в каталоге [.filename]#/usr/home/example/ports#, а установит всё в [.filename]#/usr/local#.

[source,shell]
....
# make PREFIX=/usr/home/example/local install
....

будет компилировать порт в каталоге [.filename]#/usr/ports#, а установит в [.filename]#/usr/home/example/local#.

И, конечно же,

[source,shell]
....
# make WRKDIRPREFIX=../ports PREFIX=../local install
....

использует обе возможности.

Альтернативным способом является задание этих каталогов в переменных окружения. Обратитесь к страницам справки по вашему командному процессору для получения инструкций о том, как установить переменные окружения.

==== Повторная настройка опций портов

Некоторые порты предоставляют ncurses-меню, содержащее опции построения. Будучи однажды успешно определены, опции сохраняются, и при повторном построении порта меню не вызывается. Для изменения сохраненных опций существует несколько способов повторного вызова меню. Один из них - зайти в каталог порта и набрать `make config`. Второй способ - запустить команду `make showconfig`. Еще один способ - выполнить команду `make rmconfig`, которая удалит все ранее отмеченные опции и позволит вам начать конфигурирование сначала. Эти и другие способы детально описаны на странице man:ports[7].

[[ports-removing]]
=== Удаление установленных портов

Установленные порты и пакеты удаляются при помощи команды man:pkg_delete[1]:

[source,shell]
....
# pkg_delete lsof-4.57
....

[[ports-upgrading]]
=== Обновление портов

Прежде всего, при помощи man:pkg_version[1] просмотрите, нет ли в Коллекции Портов более новых версий установленных приложений:

[source,shell]
....
# pkg_version -v
....

[[ports-file-updating]]
==== Прочитайте [.filename]#/usr/ports/UPDATING#

После обновления Коллекции Портов, и перед тем, как обновить приложение из порта, сверьтесь с файлом [.filename]#/usr/ports/UPDATING#. В нем дана информация по различным вопросам и дополнительным шагам, которые могут быть необходимы для обновления порта, включая информацию о таких вещах как изменения форматов файлов, изменения в расположении конфигурационных файлов, или другие нестыковки с предыдущими версиями.

Если [.filename]#UPDATING# противоречит чему-либо, написанному в этом документе, то доверьтесь информации из [.filename]#UPDATING#.

[[portupgrade]]
==== Обновление Портов при помощи Portupgrade

Утилита portupgrade создана для простого обновления установленных портов. Она доступна из порта package:ports-mgmt/portupgrade[]. Установите её как и любой иной порт при помощи команды `make install clean`:

[source,shell]
....
# cd /usr/ports/ports-mgmt/portupgrade
# make install clean
....

Проверьте перечень установленных портов командой `pkgdb -F` и устраните все несоответствия, о которых сообщит утилита. Хорошей идеей является выполнение этого действия регулярно, перед каждым обновлением.

Используйте `portupgrade -a` для обновления всех устаревших портов, установленных в вашей системе. Добавьте флаг `-i` если вы желаете получать запрос на каждый обновляемый порт.

[source,shell]
....
# portupgrade -ai
....

Для обновления конкретного приложения, а не всех установленных портов, запустите `portupgrade _pkgname_`. Включите флаг `-R` при необходимости обновить все порты, требуемые данным приложением.

[source,shell]
....
# portupgrade -R firefox
....

Для использования при установке пакетов, а не портов, укажите флаг `-P`. С этим параметром portupgrade будет искать пакеты в локальных каталогах, указанных в переменной окружения `PKG_PATH`, а если не найдет их, то загрузит с удаленного сайта. Если пакеты не могут быть найдены локально или загружены удаленно, portupgrade использует порты. Чтобы запретить использование портов, укажите `-PP`.

[source,shell]
....
# portupgrade -PP gnome2
....

Для простой загрузки дистрибутивных файлов без построения или установки чего бы то ни было, задайте флаг `-F`. Дополнительную информацию можно получить на странице справки по утилите man:portupgrade[1].

[[portmaster]]
==== Обновление портов при помощи portmaster

Утилита package:ports-mgmt/portmaster[] - это еще один инструмент для обновления установленных портов. Утилита portmaster опирается на возможности "базовой" системы и не зависит от других портов. Она использует информацию из [.filename]#/var/db/pkg/# для определения портов, подлежащих обновлению. Для установки утилиты выполните следующее:

[source,shell]
....
# cd /usr/ports/ports-mgmt/portmaster
# make install clean
....

Portmaster делит порты на четыре категории:

* Корневые порты: не зависят от других портов и нет портов, зависимых от корневых;
* Стволовые порты: не зависят от других портов, но есть порты, зависящие от стволовых;
* Веточные порты: зависят от других портов и есть порты, зависящие от веточных;
* Листьевые порты: зависят от других портов, но нет портов, зависящих от листьевых.

Чтобы проверить наличие обновлений для всех установленных портов, задайте утилите флаг `-L`:

[source,shell]
....
# portmaster -L
===>>> Root ports (No dependencies, not depended on)
===>>> ispell-3.2.06_18
===>>> screen-4.0.3
        ===>>> New version available: screen-4.0.3_1
===>>> tcpflow-0.21_1
===>>> 7 root ports
...
===>>> Branch ports (Have dependencies, are depended on)
===>>> apache-2.2.3
        ===>>> New version available: apache-2.2.8
...
===>>> Leaf ports (Have dependencies, not depended on)
===>>> automake-1.9.6_2
===>>> bash-3.1.17
        ===>>> New version available: bash-3.2.33
...
===>>> 32 leaf ports

===>>> 137 total installed ports
        ===>>> 83 have new versions available
....

Все установленные порты могут быть обновлены при помощи одной команды:

[source,shell]
....
# portmaster -a
....

[NOTE]
====
По умолчанию, portmaster создаст дублирующий пакет перед удалением установленного порта. Если обновление порта прошло успешно, portmaster удалит дублирующий пакет. При помощи опции `-b` можно проинструктировать portmaster не выполнять автоматическое удаление дублирующего пакета. Указание опции `-i` запустит portmaster в интерактивном режиме, запрашивающим подтверждение пользователя перед обновлением каждого порта.
====

Если во время процесса обновления возникнут ошибки, задействуйте опцию `-f` для обновления/перестройки всех портов:

[source,shell]
....
# portmaster -af
....

Также, portmaster может быть задействован для установки новых портов в систему, автоматически обновляя другие зависимые порты перед построением и установкой нового порта:

[source,shell]
....
# portmaster shells/bash
....

За подробной информацией обратитесь к man:portmaster[8].

[[ports-disk-space]]
=== Порты и дисковое пространство

Работа с Коллекцией Портов со временем приводит к увеличению занимаемого дискового пространства. После построения и установки программы из порта удалите временный каталог [.filename]#work# при помощи команды `make clean`. Для очистки всей Коллекции Портов наберите:

[source,shell]
....
# portsclean -C
....

По прошествии некоторого времени у вас соберется множество дистрибутивных файлов в каталоге [.filename]#distfiles#. Следующая команда удалит все дистрибутивные файлы, которые более не связаны ни с какими портами:

[source,shell]
....
# portsclean -D
....

Для удаления всех дистрибутивных файлов, не связанных ни с одним установленным в вашу систему портом, наберите:

[source,shell]
....
# portsclean -DD
....

[NOTE]
====
Утилита `portsclean` является частью порта package:ports-mgmt/portupgrade[].
====

Удобная утилита для автоматизации удаления портов, в которых вы более не нуждаетесь, доступна из порта package:ports-mgmt/pkg_cutleaves[].

[[ports-nextsteps]]
== Действия после установки

После установки нового приложения вам обычно требуется прочесть любую имеющуюся документацию, отредактировать необходимые конфигурационные файлы и убедиться, что приложение запускается во время загрузки системы.

Очевидно, что шаги, в точности требуемые для конфигурации каждого приложения, отличаются. Однако, если если вы только что установили новое приложение и вам интересно, "Что же дальше?", то вам могут помочь следующие советы:

* Воспользуйтесь командой man:pkg_info[1] для определения того, куда и какие файлы были установлены. К примеру, если вы только что установили FooPackage версии 1.0.0, то по команде
+
[source,shell]
....
# pkg_info -L foopackage-1.0.0 | less
....
+ 
будет выведен список всех файлов, установленных пакетом. Обратите особое внимание на файлы, установленные в каталоги [.filename]#man/#, которые являются справочными страницами, [.filename]#etc/#, которые являются конфигурационными файлами, и [.filename]#doc/#, которые являются более полной документацией.
+ 
Чтобы определить, какая версия приложения была установлена, выполните:
+
[source,shell]
....
# pkg_info | grep -i foopackage
....
+ 
команда выведет список всех установленных пакетов, в названии которых присутствует _foopackage_. Замените _foopackage_ на искомый фрагмент текста.
* Как только вы определите, куда были установлены справочные страницы приложения, просмотрите их при помощи команды man:man[1]. Просмотрите примеры конфигурационных файлов, а также любую дополнительную документацию, если она была установлена.
* Если у приложения имеется веб-сайт, поищите там дополнительную документацию, ответы на часто задаваемые вопросы и так далее. Если вы не уверены, каков адрес веб-сайта, он может быть указан в выводе команды
+
[source,shell]
....
# pkg_info foopackage-1.0.0
....
+ 
Строка `WWW:`, если она есть, должна содержать URL Web-сайта приложения.
* Как правило, порты приложений, которые должны запускаться при загрузке системы, устанавливают стартовые скрипты в каталог [.filename]#/usr/local/etc/rc.d#. Просмотрите скрипт на предмет его корректности и, если необходимо, отредактируйте или переименуйте его. Обратитесь к разделу о crossref:config[configtuning-starting-services,Запуске сервисов] за более подробной информацией.

[[ports-broken]]
== Обработка нерабочих портов

Если вы встретили порт, который не компилируется:

. Выясните, нет ли для порта решения проблемы в link:https://www.FreeBSD.org/support/#gnats[Problem Report database]. Если оно есть, то вы можете воспользоваться предложенным решением.
. Попросите помощи у мейнтейнера порта. Чтобы найти его адрес наберите команду `make maintainer` или просмотрите [.filename]#Makefile#. Не забудьте указать имя и версию порта (скопировав строчку `$FreeBSD:` из файла [.filename]#Makefile#) и включите в письмо весь вывод, предшествующий возникновению ошибки.
+
[NOTE]
====
Некоторые порты поддерживаются группой людей из extref:{mailing-list-faq}[списка рассылки], а не отдельными людьми. В большинстве таких случаев адрес мейнтейнера выглядит подобно следующему: mailto:freebsd-listname@FreeBSD.org[freebsd-listname@FreeBSD.org]. Пожалуйста, учтите это при формулировании ваших вопросов.

В частности, если мейнтейнер порта - mailto:ports@FreeBSD.org[ports@FreeBSD.org], то такой порт вообще никем не поддерживается. Решение проблем и поддержка, если и имеют место, то приходят от общества, которое подписано на тот список рассылки. Волонтёры требуются всегда!
====
+ 
Если вы не получили ответ, то воспользуйтесь командой man:send-pr[1] для посылки сообщения о проблеме (изучите extref:{problem-reports}[составление сообщений о проблеме во FreeBSD]).
. Исправьте его! В extref:{porters-handbook}[Руководстве по созданию портов] содержится подробная информация об инфраструктуре портов, так что вы сможете исправить редкий неработающий порт или даже предложить свой собственный!
. Воспользуйтесь man:pkg_add[1] и установите пакет вместо порта.
