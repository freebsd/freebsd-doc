---
title: Глава 23. PPP и SLIP
part: Часть IV. Сетевые коммуникации
prev: books/handbook/serialcomms
next: books/handbook/mail
showBookMenu: true
weight: 28
path: "/books/handbook/ppp-and-slip/"
---

[[ppp-and-slip]]
= PPP и SLIP
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 23
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/ppp-and-slip/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[ppp-and-slip-synopsis]]
== Краткий обзор

В FreeBSD существует множество способов соединения одного компьютера с другим. Для установления соединения с отдельной сетью или интернет через обычный модем, или для открытия доступа к собственному компьютеру необходимо использование PPP или SLIP. В этой главе детально описана настройка таких модемных сервисов.

После прочтения этой главы вы будете знать:

* Как настроить PPP уровня пользователя (user PPP).
* Как настроить PPP уровня ядра (kernel PPP).
* Как настроить PPPoE (PPP over Ethernet).
* Как настроить PPPoA (PPP over ATM).
* Как настроить SLIP клиента и сервер.

Перед прочтением этой главы вам потребуется:

* Ознакомиться с основными сетевыми технологиями.
* Понимать основы и назначение модемного соединения и PPP и/или SLIP.

Вы возможно захотите узнать, в чем главное различие между PPP уровня пользователя и ядра. Ответ прост: PPP уровня пользователя обрабатывает входящие и исходящие данные в пространстве пользователя, а не в ядре. В терминах копирования данных между ядром и пространством пользователя это дорогостоящий путь, который однако позволяет значительно расширить возможности реализации PPP. PPP уровня пользователя для связи с внешним миром использует устройство [.filename]#tun#, а PPP уровня ядра - устройство [.filename]#ppp#.

[NOTE]
====
В дальнейшем в этой главе PPP уровня пользователя будет обозначаться просто как ppp, пока не потребуется различать его и любое другое программное обеспечение PPP, такое как pppd. Если не указано иначе, все команды, приведенные в этой главе, должны выполняться под `root`.
====

[[userppp]]
== PPP уровня пользователя

=== Настройка PPP уровня пользователя

==== Предположения

В этом документе предполагается, что у вас есть следующее:

* Учетная запись у провайдера интернет (Internet Service Provider, ISP), к которому вы подсоединяетесь, используя PPP.
* Модем или другое подключенное к системе и правильно настроенное устройство, позволяющее подключиться к провайдеру.
* Номер модемного пула провайдера.
* Имя пользователя (логин) и пароль (обычная UNIX(R) пара логин/пароль, или PAP/CHAP пара логин/пароль).
* IP адреса одного или нескольких серверов имен. Обычно провайдер дает для этих целей два IP адреса. Если нет ни одного, вы можете использовать команду `enable dns` в [.filename]#ppp.conf# и ppp настроит список серверов имен. Эта возможность зависит от наличия поддержки согласования DNS в реализации PPP провайдера.

Следующая информация может поставляться провайдером, но не является совершенно необходимой:

* IP адрес шлюза провайдера. Шлюз это компьютер, к которому вы подключитесь и который будет настроен в качестве _маршрута по умолчанию_ (_default route_). Если у вас нет этой информации, она может быть получена от PPP сервера после подключения.
+ 
Программой ppp этот IP адрес обозначается как `HISADDR`.
* Сетевая маска, которую вы должны использовать. Если провайдер не предоставил ее значение, вы можете использовать `255.255.255.255`.
* Если провайдер предоставил статический IP и имя хоста, используйте их. Иначе позвольте удаленной стороне назначить свободный IP адрес.

Если у вас нет всей необходимой информации, свяжитесь с провайдером.

[NOTE]
====
В этом разделе строки файлов настройки из многих примеров пронумерованы. Эти номера приведены только для обсуждения настроек, они не должны помещаться в действующую настройку. Правильные отступы с табуляцией и пробелами также важны.
====

==== Создание файлов устройств PPP

В обычной ситуации, большинству пользователей нужно только одно устройство [.filename]#tun# ([.filename]#/dev/tun0#). Ссылки на [.filename]#tun0# ниже могут быть заменены на [.filename]#tunN#, где _N_ это любой номер устройства, соответствующий вашей системе.

Для систем FreeBSD без man:devfs[5] (FreeBSD 4.X более ранние), необходимо проверить устройство [.filename]#tun0# (это не требуется, если включена man:devfs[5], поскольку файлы устройств будут создаваться автоматически).

Простейший способ убедиться, что устройство [.filename]#tun0# настроено правильно, это пересоздать устройство. Для пересоздания устройства выполните следующее:

[source,shell]
....
# cd /dev
# sh MAKEDEV tun0
....

Если вам необходимы 16 туннельных устройств, потребуется их создать. Это можно сделать, выполнив следующие команды:

[source,shell]
....
# cd /dev
# sh MAKEDEV tun15
....

==== Автоматическая настройка PPP

И `ppp` и `pppd` (реализация PPP уровня ядра) используют файлы настройки, расположенные в каталоге [.filename]#/etc/ppp#. Примеры для ppp уровня пользователя можно найти в [.filename]#/usr/shared/examples/ppp/#.

Настройка `ppp` требует редактирования нескольких файлов, в зависимости от ваших потребностей. То, что вы поместите в эти файлы, зависит в некоторой степени от того, предоставит ли провайдер статический IP адрес (т.е. вы получите один определенный IP адрес и будете использовать его постоянно) или динамический (т.е. ваш IP адрес будет изменяться при каждом подключении к провайдеру).

[[userppp-staticIP]]
===== PPP и статические IP адреса

Вам потребуется отредактировать файл настройки [.filename]#/etc/ppp/ppp.conf#. Он похож на приведенный ниже пример.

[NOTE]
====
Строки, оканчивающиеся на `:`, вводятся без отступа в начале строки, остальные строки должны быть введены с отступом, как показано в примере.
====

[.programlisting]
....
1     default:
2       set log Phase Chat LCP IPCP CCP tun command
3       ident user-ppp VERSION (built COMPILATIONDATE)
4       set device /dev/cuaa0
5       set speed 115200
6       set dial "ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 5 \
7                 \"\" AT OK-AT-OK ATE1Q0 OK \\dATDT\\T TIMEOUT 40 CONNECT"
8       set timeout 180
9       enable dns
10
11    provider:
12      set phone "(123) 456 7890"
13      set authname foo
14      set authkey bar
15      set login "TIMEOUT 10 \"\" \"\" gin:--gin: \\U word: \\P col: ppp"
16      set timeout 300
17      set ifaddr x.x.x.x y.y.y.y 255.255.255.255 0.0.0.0
18      add default HISADDR
....

Строка 1:::
Начинает настройку по умолчанию (default). Команды этой настройки выполняются автоматически при запуске ppp.

Строка 2:::
Включает параметры протоколирования. Когда настройка работает удовлетворительно, эта строка должна быть сокращена до следующей формы 
+
[.programlisting]
....
set log phase tun
....

для предотвращения появления слишком больших лог файлов.

Строка 3:::
Указывает PPP как идентифицировать себя на удаленной стороне. PPP идентифицирует себя на удаленной стороне если возникают проблемы согласования и установки соединения, предоставляя информацию, по которой администратор на удаленной стороне может воспользоваться для решения таких проблем.

Строка 4:::
Указывает устройство, к которому подключен модем. [.filename]#COM1# это [.filename]#/dev/cuaa0#, а [.filename]#COM2# это [.filename]#/dev/cuaa1#.

Строка 5:::
Устанавливает желаемую скорость подключения к модему. Если 115200 не работает (хотя должна работать для любого относительно нового модема) попробуйте 38400.

Строки 6 и 7:::
Строка дозвона. PPP уровня пользователя применяет expect-send синтаксис, похожий на синтаксис man:chat[8]. Обратитесь к странице справочника за информацией о возможностях этого языка.
+
Обратите внимание, что эта команда продолжается на следующей строке для улучшения читаемости. Любая команда в [.filename]#ppp.conf# может быть продолжена на следующей строке, если последний символ предыдущей строки "`\`".

Строка 8:::
Устанавливает предельное время ожидания для соединения. Значение 180 секунд используется по умолчанию, так что строка с этим значением чисто косметическая.

Строка 9:::
Указывает PPP запросить у удаленной стороны сервера имен. Если вы работаете с локальным сервером имен, эта строка должна быть закомментирована или удалена.

Строка 10:::
Пустая строка для улучшения читаемости. Пустые строки игнорируются PPP.

Строка 11:::
Определяет настройки для провайдера, называемого "provider". Это имя может быть изменено на имя вашего провайдера, чтобы в дальнейшем вы могли использовать `load _provider_` для начала соединения.

Строка 12:::
Определяет телефонный номер для этого провайдера. Несколько телефонных номеров могут быть указаны с помощью двоеточия (`:`) или символа канала (`|`) в качестве разделителя. Различия между двумя разделителями описаны в man:ppp[8]. Главным образом они заключаются в том, что если вы хотите перебирать номера, используйте двоеточие. Если вы хотите дозваниваться по первому номеру в первую очередь, и использовать другие номера только если дозвон по первому завершится неудачно, используйте символ канала. Всегда заключайте список номеров в кавычки, как показано в примере.
+
Вы должны включить телефонный номер в кавычки (`"`) если в нем используются пробелы. Отсутствие кавычек может вызвать простую, но трудно обнаруживаемую ошибку.

Строки 13 и 14:::
Задают имя пользователя и пароль. При использовании приглашения login в стиле UNIX(R), эти значения используются командой `set login` через переменные \U и \P. При соединении с использованием PAP или CHAP, эти значения используются во время аутентификации.

Строка 15:::
Если вы используете PAP или CHAP, приглашение на вход не появится, и эта строка должна быть закомментирована или удалена. Обратитесь к странице <<userppp-PAPnCHAP,аутентификация PAP и CHAP>> за дальнейшей информацией.
+
Строка для входа записана в том же chat-подобном синтаксисе, что и строка для дозвона. В этом примере строка работает для сервиса, сессия входа которого выглядит примерно так:
+
[source,shell]
....
J. Random Provider
login: foo
password: bar
protocol: ppp
....
+
Вам потребуется изменить эту строку для использования с другим сервисом. При первом составлении скрипта убедитесь, что вы включили "chat" протоколирование, чтобы убедиться, что соединение происходит как ожидалось.

Строка 16:::
Установка максимального времени ожидания по умолчанию для соединения. В данном случае соединение будет разорвано автоматически после 300 секунд неактивности. Если вы не хотите, чтобы соединение разрывалось, установите эту переменную в нуль, или используйте параметр командной строки `-ddial`.

Строка 17:::
Устанавливает адрес интерфейса. Строка _x.x.x.x_ должна быть заменена на IP адрес, который выделил вам провайдер. Строка _y.y.y.y_ должна быть заменена на IP адрес шлюза провайдера (компьютер, к которому вы подключаетесь). Если провайдер не сообщил адрес шлюза, используйте `10.0.0.2/0`. Если вам требуется использовать "вычисленные" адреса, убедитесь, что создана запись в [.filename]#/etc/ppp/ppp.linkup# в соответствии с инструкциями для <<userppp-dynamicIP,PPP и динамических IP адресов>>. Если эта строка опущена, `ppp` не может быть запущен в режиме `-auto`.

Строка 18:::
Добавляет маршрут по умолчанию к шлюзу провайдера. Специальное слово `HISADDR` заменяется адресом шлюза, указанном в строке 17. Важно, чтобы эта строка появилась после строки 17, до нее переменная `HISADDR` еще не инициализирована.
+
Если вы не будете запускать ppp с параметром `-auto`, эта строка должна быть перемещена в файл [.filename]#ppp.linkup#.

Нет необходимости добавлять запись в [.filename]#ppp.linkup#, если у вас статический IP адрес и ppp работает в режиме `-auto`, поскольку таблица маршрутизации настроена правильно еще до подключения. Однако, вы возможно захотите создать запись для запуска программ после соединения. Эта ситуация описана далее в примере по sendmail.

Примерные файлы настройки находятся в каталоге [.filename]#/usr/shared/examples/ppp/#.

[[userppp-dynamicIP]]
===== PPP и динамические IP адреса

Если провайдер не выделил статический IP адрес, `ppp` может быть настроен для определения локального и удаленного адреса. Это делается путем "вычисления" IP адреса и настройки его программой `ppp` с использованием IP Configuration Protocol (IPCP) после установления соединения. Файл настройки [.filename]#ppp.conf# тот же, что и в примере <<userppp-staticIP,PPP и статические IP адреса>>, со следующим изменением:

[.programlisting]
....
17      set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.255
....

Как и раньше, не включайте номер строки, он используется только для ссылки на строку в этом примере. Требуется отступ хотя бы в один пробел.

Строка 17:::
Номер после символа `/` это число бит в адресе, которые будут запрошены ppp. Вы можете использовать более подходящие вам IP адреса, но пример выше всегда будет работать.

Если вы не используете режим `-auto`, потребуется создать запись в [.filename]#/etc/ppp/ppp.linkup#. Этот файл используется после установки соединения. На этот момент `ppp` уже настроит адреса интерфейсов и станет возможным добавление записей в таблицу маршрутизации:

[.programlisting]
....
1     provider:
2      add default HISADDR
....

Строка 1:::
При установке соединения, `ppp` ищет запись в [.filename]#ppp.linkup# по следующим правилам: сначала в соответствии с меткой, используемой в [.filename]#ppp.conf#. Если это не сработает, ведется поиск записи для IP адреса шлюза. Это метка в IP записывается в виде IP адреса. Если запись все еще не найдена, используется запись `MYADDR`.

Строка 2:::
Эта строка сообщает `ppp` добавить маршрут по умолчанию, указывающий на `HISADDR`. `HISADDR` будет заменен на IP адрес шлюза, определенного IPCP.

Детальный пример находится в записи `pmdemand` файлов [.filename]#/usr/shared/examples/ppp/ppp.conf.sample# и [.filename]#/usr/shared/examples/ppp/ppp.linkup.sample#.

===== Прием входящих звонков

При настройке ppp для приема входящих звонков на компьютере, подключенном к локальной сети, вам необходимо решить, перенаправлять ли пакеты в локальную сеть. Если вы будете делать это, выделите удаленной стороне IP адрес из диапазона адресов локальной сети, и используйте команду `enable proxy` в файле [.filename]#/etc/ppp/ppp.conf#. Вам потребуется также убедиться, что в файле [.filename]#/etc/rc.conf# присутствует строка:

[.programlisting]
....
gateway_enable="YES"
....

===== Какой getty?

Раздел crossref:serialcomms[dialup,Настройка FreeBSD для входящих соединений] дает хорошее описание включения входящих соединений с использованием man:getty[8].

Альтернатива `getty` это http://www.leo.org/~doering/mgetty/index.html[mgetty], более интеллектуальная версия `getty`, разработанная специально для приема входящих звонков..

Преимущество использование `mgetty` в том, что она активно _общается_ с модемами, то есть если порт будет выключен в [.filename]#/etc/ttys#, модем не будет отвечать на звонок.

Последние версии `mgetty` (от 0.99beta и выше) поддерживают также автоматическое определение потоков PPP, позволяя клиентам безскриптовое подключение к серверу.

Обратитесь к разделу <<userppp-mgetty,Mgetty и AutoPPP>> за дальнейшей информацией по `mgetty`.

===== Права PPP

Программа `ppp` обычно запускается с правами пользователя `root`. Если вы хотите разрешить запуск `ppp` в режиме сервера с правами обычного пользователя путем запуска `ppp` как описано ниже, этого пользователя необходимо добавить в группу `network` в файле [.filename]#/etc/group#.

Вам также потребуется дать ему доступ к одному или более разделов конфигурации, используя команду `allow`:

[.programlisting]
....
allow users fred mary
....

Если эта команда используется в разделе `default`, она дает пользователю полный доступ.

===== Оболочки PPP для пользователей с динамическими IP

Создайте файл, называющийся [.filename]#/etc/ppp/ppp-shell# и содержащий следующее:

[.programlisting]
....
#!/bin/sh
IDENT=`echo $0 | sed -e 's/^.*-\(.*\)$/\1/'`
CALLEDAS="$IDENT"
TTY=`tty`

if [ x$IDENT = xdialup ]; then
        IDENT=`basename $TTY`
fi

echo "PPP for $CALLEDAS on $TTY"
echo "Starting PPP for $IDENT"

exec /usr/sbin/ppp -direct $IDENT
....

Этот скрипт должен быть исполняемым. Теперь создайте на этот скрипт символическую ссылку с именем [.filename]#ppp-dialup# с помощью следующей команды:

[source,shell]
....
# ln -s ppp-shell /etc/ppp/ppp-dialup
....

Используйте этот скрипт в качестве _оболочки_ для удаленных пользователей. Ниже приведен пример записи в [.filename]#/etc/password# для удаленных пользователей PPP с именем пользователя `pchilds` (не забывайте использовать `vipw` для редактирования файла паролей).

[.programlisting]
....
pchilds:*:1011:300:Peter Childs PPP:/home/ppp:/etc/ppp/ppp-dialup
....

Создайте каталог [.filename]#/home/ppp#, который доступен для чтения и содержит следующие файлы нулевой длины:

[source,shell]
....
-r--r--r--   1 root     wheel	   0 May 27 02:23 .hushlogin
-r--r--r--   1 root     wheel           0 May 27 02:22 .rhosts
....

Это предотвратит отображение [.filename]#/etc/motd#.

===== Оболочки PPP для пользователей со статическими IP

Создайте файл [.filename]#ppp-shell# как в примере выше, и для каждой учетной записи со статически назначаемым IP создайте символическую ссылку на [.filename]#ppp-shell#.

Например, если у вас три пользователя удаленного доступа, `fred`, `sam` и `mary`, которые подключаются к вашей сети класса C, выполните следующее:

[source,shell]
....
# ln -s /etc/ppp/ppp-shell /etc/ppp/ppp-fred
# ln -s /etc/ppp/ppp-shell /etc/ppp/ppp-sam
# ln -s /etc/ppp/ppp-shell /etc/ppp/ppp-mary
....

Оболочка каждого из этих пользователей удаленного доступа должна быть символической ссылкой, созданной выше (например, оболочка пользователя `mary` должна быть [.filename]#/etc/ppp/ppp-mary#).

===== Настройка [.filename]#ppp.conf# для пользователей с динамическими IP

Файл [.filename]#/etc/ppp/ppp.conf# должен содержать примерно такие строки:

[.programlisting]
....
default:
  set debug phase lcp chat
  set timeout 0

ttyd0:
  set ifaddr 203.14.100.1 203.14.100.20 255.255.255.255
  enable proxy

ttyd1:
  set ifaddr 203.14.100.1 203.14.100.21 255.255.255.255
  enable proxy
....

[NOTE]
====
Необходимо соблюдать отступы.
====

Раздел `default:` загружается для каждого соединения. Для каждой строки, включенной в [.filename]#/etc/ttys#, создайте запись, подобную `ttyd0:` выше. Каждая строка должна содержать уникальные IP адреса из вашего пула IP адресов, выделенных пользователям с динамическими IP.

===== Настройка [.filename]#ppp.conf# для пользователей со статическими IP

Помимо содержимого, описанного в примере файла [.filename]#/usr/shared/examples/ppp/ppp.conf# выше, вам потребуется добавить раздел для каждого из пользователей со статическими IP. Мы продолжим использовать имена `fred`, `sam` и `mary` в качестве примера.

[.programlisting]
....
fred:
  set ifaddr 203.14.100.1 203.14.101.1 255.255.255.255

sam:
  set ifaddr 203.14.100.1 203.14.102.1 255.255.255.255

mary:
  set ifaddr 203.14.100.1 203.14.103.1 255.255.255.255
....

Если требуется, файл [.filename]#/etc/ppp/ppp.linkup# должен также содержать информацию о маршрутизации для каждого пользователя со статическим IP. В строке ниже через клиентское соединение добавляется маршрут к сети класса C``203.14.101.0``.

[.programlisting]
....
fred:
  add 203.14.101.0 netmask 255.255.255.0 HISADDR

sam:
  add 203.14.102.0 netmask 255.255.255.0 HISADDR

mary:
  add 203.14.103.0 netmask 255.255.255.0 HISADDR
....

[[userppp-mgetty]]
===== `mgetty` и AutoPPP

Настройка и компиляция `mgetty` с параметром `AUTO_PPP` позволяет `mgetty` определять LCP фазу PPP соединений и автоматически порождать оболочку ppp. Однако, поскольку стандартный метод логин/пароль не используется, необходима аутентификация пользователей через PAP или CHAP.

В этом разделе предполагается, что пользователь успешно настроил, скомпилировал и установил версию `mgetty` с параметром `AUTO_PPP` (v0.99beta или более поздняя).

Убедитесь, что в файле [.filename]#/usr/local/etc/mgetty+sendfax/login.config# имеется следующая строка:

[.programlisting]
....
/AutoPPP/ -     -		      /etc/ppp/ppp-pap-dialup
....

Это укажет `mgetty` запускать скрипт [.filename]#ppp-pap-dialup# для обнаруженных соединений PPP.

Создайте файл [.filename]#/etc/ppp/ppp-pap-dialup#, содержащий следующее (этот файл должен быть выполняемым):

[.programlisting]
....
#!/bin/sh
exec /usr/sbin/ppp -direct pap$IDENT
....

Для каждой линии, включенной в [.filename]#/etc/ttys#, создайте соответствующую запись в [.filename]#/etc/ppp/ppp.conf#. Она будет отлично сочетаться с тем, что было создано выше.

[.programlisting]
....
pap:
  enable pap
  set ifaddr 203.14.100.1 203.14.100.20-203.14.100.40
  enable proxy
....

Для каждого пользователя, входящего по этому методу, в файле [.filename]#/etc/ppp/ppp.secret# должна присутствовать запись с логином/паролем, или, в качестве альтернативы, для аутентификации пользователей по PAP через [.filename]#/etc/password#, необходимо использовать следующий параметр.

[.programlisting]
....
enable passwdauth
....

Если вы хотите присвоить некоторым пользователям статический IP, задайте его в качестве третьего аргумента в [.filename]#/etc/ppp/ppp.secret#. Обратитесь к к [.filename]#/usr/shared/examples/ppp/ppp.secret.sample# за примерами.

===== MS расширения

Возможна настройка PPP для выдачи адресов DNS и NetBIOS по запросу.

Для включения этих расширений с PPP версии 1.x, необходимо добавить к соответствующему разделу [.filename]##/etc/ppp/ppp.conf##следующие строки.

[.programlisting]
....
enable msext
set ns 203.14.100.1 203.14.100.2
set nbns 203.14.100.5
....

Для PPP версии 2 и выше:

[.programlisting]
....
accept dns
set dns 203.14.100.1 203.14.100.2
set nbns 203.14.100.5
....

Клиентам будут выдаваться адреса первичного и вторичного серверов имен, и адрес хоста NetBIOS.

Если в версии 2 и выше строка `set dns` будет опущена, PPP использует значения из [.filename]#/etc/resolv.conf#.

[[userppp-PAPnCHAP]]
===== Аутентификация PAP и CHAP

Некоторые провайдеры настраивают систему так, что аутентификация производится с использованием либо PAP либо CHAP. В этом случае, приглашение `login:` при соединении не выдается и соединение PPP начинается сразу.

PAP менее безопасен, чем CHAP, но безопасность в данном случае не страдает, поскольку хотя пароли и передаются открытым текстом, они передаются только по модемной линии. У кракеров не так много возможностей для кражи паролей.

В примерах выше <<userppp-staticIP,PPP и статические IP адреса>> или <<userppp-dynamicIP,PPP и динамические IP адреса>> должны быть сделаны следующие изменения:

[.programlisting]
....
13      set authname MyUserName
14      set authkey MyPassword
15      set login
....

Строка 13:::
Эта строка указывает имя пользователя PAP/CHAP. Вам потребуется заменить _MyUserName_ на правильное значение.

Строка 14:::
Эта строка указывает пароль PAP/CHAP. Вам потребуется заменить _MyPassword_ на правильное значение. Вы можете также добавить дополнительную строку, такую как:
+

[.programlisting]
....
16      accept PAP
....

+
или
+

[.programlisting]
....
16      accept CHAP
....

+
для явного указания протокола, но и PAP и CHAP поддерживаются по умолчанию.

Строка 15:::
Ваш провайдер обычно не потребует входа на сервер при использовании PAP или CHAP. Следовательно, вы должны отключить строку "set login".

===== Изменение настроек `ppp` "на лету"

Возможно изменение настроек `ppp` программы во время ее работы в фоновом режиме, но только если открыт соответствующий диагностический порт. Для его открытия добавьте в настройку следующую строку:

[.programlisting]
....
set server /var/run/ppp-tun%d DiagnosticPassword 0177
....

С этой директивой ppp будет прослушивать заданный UNIX(R) сокет, запрашивая у клиентов пароль перед выдачей доступа. Символы``%d`` заменяются на номер используемого устройства [.filename]#tun#.

Как только сокет открыт, в скриптах, выполняющих настройку работающей программы, можно использовать man:pppctl[8].

[[userppp-nat]]
==== Использование NAT

PPP имеет возможность использовать встроенный NAT без преобразования пакетов в ядре. Эта возможность может быть включена следующей строкой в [.filename]#/etc/ppp/ppp.conf#:

[.programlisting]
....
nat enable yes
....

Альтернативно, PPP NAT может быть включен параметром командной строки `-nat`. Существует также переменная [.filename]#/etc/rc.conf#`ppp_nat`, которая включена по умолчанию.

Если вы используете эту возможность, вы также можете найти полезными параметры [.filename]#/etc/ppp/ppp.conf# для включения пересылки входящих соединений:

[.programlisting]
....
nat port tcp 10.0.0.2:ftp ftp
nat port tcp 10.0.0.2:http http
....

или отключить все входящие соединения

[.programlisting]
....
nat deny_incoming yes
....

[[userppp-final]]
==== Завершающая настройка системы

Теперь, когда программа `ppp` настроена, осталось выполнить еще несколько действий прежде, чем все это заработает. Они выполняются путем редактирования файла [.filename]#/etc/rc.conf#.

Просматривая этот файл, убедитесь, что добавлена строка `hostname=`, например:

[.programlisting]
....
hostname="foo.example.com"
....

Если провайдер предоставил вам статический IP адрес и имя, возможно лучше всего использовать это имя в качестве имени хоста.

Проверьте переменную `network_interfaces`. Если вы хотите настроить систему для дозвона по требованию, убедитесь, что устройство [.filename]#tun0# добавлено в список, иначе удалите его.

[.programlisting]
....
network_interfaces="lo0 tun0"
ifconfig_tun0=
....

[NOTE]
====
Переменная `ifconfig_tun0` должна быть пуста, необходимо также создать файл [.filename]#/etc/start_if.tun0#. В этом файле должна находиться строка:

[.programlisting]
....
ppp -auto mysystem
....

Этот скрипт выполняется во время настройки сети, запуская даемона ppp в автоматическом режиме. Если эта машина является шлюзом для локальной сети, вы можете также использовать переключатель `-alias`. Обратитесь к странице справочника за дальнейшей информацией.
====

Убедитесь, что программа маршрутизации отключена переменной в файле [.filename]#/etc/rc.conf#:

[.programlisting]
....
router_enable="NO"
....

Важно, чтобы даемон `routed` не был запущен, поскольку он может удалить запись маршрута по умолчанию, создаваемую `ppp`.

Возможно, стоит обратить внимание на переменную `sendmail_flags` и убедиться, что она не включает параметр `-q`, иначе `sendmail` попытается сразу же обратиться к сети, и компьютер может начать дозвон. Вы можете попробовать:

[.programlisting]
....
sendmail_flags="-bd"
....

Обратная сторона этого решения в том, что необходим запуск очереди `sendmail` после поднятия соединения ppp:

[source,shell]
....
# /usr/sbin/sendmail -q
....

Вы можете использовать команду `!bg` в файле [.filename]#ppp.linkup# для автоматического выполнения этой задачи:

[.programlisting]
....
1     provider:
2       delete ALL
3       add 0 0 HISADDR
4       !bg sendmail -bd -q30m
....

Если вам это не нужно, возможна настройка "dfilter" для блокирования SMTP трафика. Обратитесь файлам примеров за дальнейшей информацией.

Все, что осталось, это перегрузить компьютер. После перезагрузки вы можете либо выполнить:

[source,shell]
....
# ppp
....

и затем набрать `dial provider` для запуска сессии PPP, либо, если вы хотите, чтобы программа `ppp` начинала соединение автоматически при появлении исходящего трафика (и файл [.filename]#start_if.tun0# не создан), выполните:

[source,shell]
....
# ppp -auto provider
....

==== Итоги

Для первоначальной настройки ppp необходимо пройти следующие шаги:

Сторона клиента:

[.procedure]
====
. Убедитесь, что устройство [.filename]#tun# встроено в ядро.
. Убедитесь, что устройства [.filename]#tunN# находятся в каталоге [.filename]#/dev#.
. Создайте запись в [.filename]#/etc/ppp/ppp.conf#. Пример [.filename]#pmdemand# должен подойти для большинства провайдеров.
. Если у вас динамический IP адрес, создайте запись в [.filename]#/etc/ppp/ppp.linkup#.
. Обновите файл [.filename]#/etc/rc.conf#.
. Создайте скрипт [.filename]#start_if.tun0#, если необходим дозвон по требованию.
====

Сторона сервера:

[.procedure]
====
. Убедитесь, что устройство [.filename]#tun# встроено в ядро.
. Убедитесь, что устройства [.filename]#tunN# находятся в каталоге [.filename]#/dev#.
. Создайте запись в [.filename]#/etc/passwd# (используя программу man:vipw[8]).
. Создайте профиль в домашнем каталоге пользователя, запускающий `ppp -direct direct-server` или подобную команду.
. Создайте запись в [.filename]#/etc/ppp/ppp.conf#. Пример [.filename]#direct-server# должен подойти.
. Создайте запись в [.filename]#/etc/ppp/ppp.linkup#.
. Обновите файл [.filename]#/etc/rc.conf#.
====

[[ppp]]
== PPP уровня ядра

=== Настройка PPP уровня ядра

Перед началом настройки PPP на вашем компьютере, убедитесь, что `pppd` находится в [.filename]#/usr/sbin# и каталог [.filename]#/etc/ppp# существует.

`pppd` может работать в двух режимах:

. В качестве "клиента" - когда вы хотите подключить компьютер к внешнему миру через последовательное соединение PPP или модемную линию.
. В качестве "сервера" - когда компьютер подключен к сети и используется для подключения других компьютеров через PPP.

В обеих случаях вам потребуется настроить файл параметров ([.filename]#/etc/ppp/options# или [.filename]#~/.ppprc# если на вашем компьютере более одного пользователя работают с PPP).

Вам потребуется также программа для модемных/последовательных линий (предпочтительно package:comms/kermit[]) для дозвона и установки соединения с удаленным хостом.

=== Использование `pppd` в качестве клиента

Для подключения к линии PPP терминального сервера Cisco может использоваться следующий файл [.filename]#/etc/ppp/options#.

[.programlisting]
....
crtscts	 # enable hardware flow control
modem           # modem control line
noipdefault     # remote PPP server must supply your IP address
                # if the remote host does not send your IP during IPCP
                # negotiation, remove this option
passive         # wait for LCP packets
domain ppp.foo.com      # put your domain name here

:<remote_ip>    # put the IP of remote PPP host here
                # it will be used to route packets via PPP link
                # if you didn't specified the noipdefault option
                # change this line to <local_ip>:<remote_ip>

defaultroute    # put this if you want that PPP server will be your
                # default router
....

Для подключения:

[.procedure]
====
. Дозвонитесь на удаленный хост, используя kermit (или любую другую модемную программу), и введите ваше имя пользователя и пароль (или те данные, которые требуются для установления PPP соединения с удаленным хостом).
. Выйдите из kermit (без обрыва соединения).
. Введите следующее:
+
[source,shell]
....
# /usr/src/usr.sbin/pppd.new/pppd /dev/tty01 19200
....
+ 
Убедитесь, что выбраны подходящая скорость и правильное имя устройства.
====

Теперь ваш компьютер подключен по PPP. Если соединение не состоялось, вы можете добавить параметр `debug` к файлу [.filename]#/etc/ppp/options#, и отследить проблему по сообщениям на консоли.

Следующий скрипт [.filename]#/etc/ppp/pppup# проведет все 3 стадии в автоматическом режиме:

[.programlisting]
....
#!/bin/sh
ps ax |grep pppd |grep -v grep
pid=`ps ax |grep pppd |grep -v grep|awk '{print $1;}'`
if [ "X${pid}" != "X" ] ; then
        echo 'killing pppd, PID=' ${pid}
        kill ${pid}
fi
ps ax |grep kermit |grep -v grep
pid=`ps ax |grep kermit |grep -v grep|awk '{print $1;}'`
if [ "X${pid}" != "X" ] ; then
        echo 'killing kermit, PID=' ${pid}
        kill -9 ${pid}
fi

ifconfig ppp0 down
ifconfig ppp0 delete

kermit -y /etc/ppp/kermit.dial
pppd /dev/tty01 19200
....

[.filename]#/etc/ppp/kermit.dial# это скрипт kermit, который дозванивается до удаленного хоста и проходит необходимую авторизацию (пример такого скрипта находится в конце этого раздела).

Используйте следующий скрипт [.filename]#/etc/ppp/pppdown# для отключения от PPP линии:

[.programlisting]
....
#!/bin/sh
pid=`ps ax |grep pppd |grep -v grep|awk '{print $1;}'`
if [ X${pid} != "X" ] ; then
        echo 'killing pppd, PID=' ${pid}
        kill -TERM ${pid}
fi

ps ax |grep kermit |grep -v grep
pid=`ps ax |grep kermit |grep -v grep|awk '{print $1;}'`
if [ "X${pid}" != "X" ] ; then
        echo 'killing kermit, PID=' ${pid}
        kill -9 ${pid}
fi

/sbin/ifconfig ppp0 down
/sbin/ifconfig ppp0 delete
kermit -y /etc/ppp/kermit.hup
/etc/ppp/ppptest
....

Проверьте, запущен ли еще `pppd`, выполнив [.filename]#/usr/etc/ppp/ppptest#, который выглядит примерно так:

[.programlisting]
....
#!/bin/sh
pid=`ps ax| grep pppd |grep -v grep|awk '{print $1;}'`
if [ X${pid} != "X" ] ; then
        echo 'pppd running: PID=' ${pid-NONE}
else
        echo 'No pppd running.'
fi
set -x
netstat -n -I ppp0
ifconfig ppp0
....

Для обрыва соединения, выполните [.filename]#/etc/ppp/kermit.hup#, который должен содержать:

[.programlisting]
....
set line /dev/tty01	; put your modem device here
set speed 19200
set file type binary
set file names literal
set win 8
set rec pack 1024
set send pack 1024
set block 3
set term bytesize 8
set command bytesize 8
set flow none

pau 1
out +++
inp 5 OK
out ATH0\13
echo \13
exit
....

Существует альтернативный метод, использующий `chat` вместо `kermit`:

Для установления соединения `pppd` достаточно двух файлов.

[.filename]#/etc/ppp/options#:

[.programlisting]
....
/dev/cuaa1 115200

crtscts		# enable hardware flow control
modem		# modem control line
connect "/usr/bin/chat -f /etc/ppp/login.chat.script"
noipdefault	# remote PPP serve must supply your IP address
	        # if the remote host doesn't send your IP during
                # IPCP negotiation, remove this option
passive         # wait for LCP packets
domain <your.domain>	# put your domain name here

:		# put the IP of remote PPP host here
	        # it will be used to route packets via PPP link
                # if you didn't specified the noipdefault option
                # change this line to <local_ip>:<remote_ip>

defaultroute	# put this if you want that PPP server will be
	        # your default router
....

[.filename]#/etc/ppp/login.chat.script#:

[NOTE]
====
Все это может быть расположено на одной строке.
====

[.programlisting]
....
ABORT BUSY ABORT 'NO CARRIER' "" AT OK ATDT<phone.number>
  CONNECT "" TIMEOUT 10 ogin:-\\r-ogin: <login-id>
  TIMEOUT 5 sword: <password>
....

Как только эти файлы будут созданы и отредактированы, необходимо только запустить `pppd`, вот так:

[source,shell]
....
# pppd
....

=== Использование `pppd` в качестве сервера

[.filename]#/etc/ppp/options# должен содержать примерно следующее:

[.programlisting]
....
crtscts                         # Hardware flow control
netmask 255.255.255.0           # netmask (not required)
192.114.208.20:192.114.208.165  # IP's of local and remote hosts
                                # local ip must be different from one
                                # you assigned to the Ethernet (or other)
                                # interface on your machine.
                                # remote IP is IP address that will be
                                # assigned to the remote machine
domain ppp.foo.com              # your domain
passive                         # wait for LCP
modem                           # modem line
....

Следующий скрипт [.filename]#/etc/ppp/pppserv# укажет pppd работать в качестве сервера:

[.programlisting]
....
#!/bin/sh
ps ax |grep pppd |grep -v grep
pid=`ps ax |grep pppd |grep -v grep|awk '{print $1;}'`
if [ "X${pid}" != "X" ] ; then
        echo 'killing pppd, PID=' ${pid}
        kill ${pid}
fi
ps ax |grep kermit |grep -v grep
pid=`ps ax |grep kermit |grep -v grep|awk '{print $1;}'`
if [ "X${pid}" != "X" ] ; then
        echo 'killing kermit, PID=' ${pid}
        kill -9 ${pid}
fi

# reset ppp interface
ifconfig ppp0 down
ifconfig ppp0 delete

# enable autoanswer mode
kermit -y /etc/ppp/kermit.ans

# run ppp
pppd /dev/tty01 19200
....

Используйте этот скрипт [.filename]#/etc/ppp/pppservdown# для остановки сервера:

[.programlisting]
....
#!/bin/sh
ps ax |grep pppd |grep -v grep
pid=`ps ax |grep pppd |grep -v grep|awk '{print $1;}'`
if [ "X${pid}" != "X" ] ; then
        echo 'killing pppd, PID=' ${pid}
        kill ${pid}
fi
ps ax |grep kermit |grep -v grep
pid=`ps ax |grep kermit |grep -v grep|awk '{print $1;}'`
if [ "X${pid}" != "X" ] ; then
        echo 'killing kermit, PID=' ${pid}
        kill -9 ${pid}
fi
ifconfig ppp0 down
ifconfig ppp0 delete

kermit -y /etc/ppp/kermit.noans
....

Следующий kermit скрипт ([.filename]#/etc/ppp/kermit.ans#) включит/отключит режим ответа модема на входящие звонки. Он должен выглядеть примерно так:

[.programlisting]
....
set line /dev/tty01
set speed 19200
set file type binary
set file names literal
set win 8
set rec pack 1024
set send pack 1024
set block 3
set term bytesize 8
set command bytesize 8
set flow none

pau 1
out +++
inp 5 OK
out ATH0\13
inp 5 OK
echo \13
out ATS0=1\13   ; change this to out ATS0=0\13 if you want to disable
                ; autoanswer mode
inp 5 OK
echo \13
exit
....

Скрипт, называющийся [.filename]#/etc/ppp/kermit.dial#, используется для дозвона и аутентификации на удаленном хосте. Вам потребуется приспособить его под собственные нужды. Поместите ваш логин и пароль в этот скрипт; вам также потребуется изменить операторы input в зависимости от ответов от модема и удаленного хоста.

[.programlisting]
....
;
; put the com line attached to the modem here:
;
set line /dev/tty01
;
; put the modem speed here:
;
set speed 19200
set file type binary            ; full 8 bit file xfer
set file names literal
set win 8
set rec pack 1024
set send pack 1024
set block 3
set term bytesize 8
set command bytesize 8
set flow none
set modem hayes
set dial hangup off
set carrier auto                ; Then SET CARRIER if necessary,
set dial display on             ; Then SET DIAL if necessary,
set input echo on
set input timeout proceed
set input case ignore
def \%x 0                       ; login prompt counter
goto slhup

:slcmd                          ; put the modem in command mode
echo Put the modem in command mode.
clear                           ; Clear unread characters from input buffer
pause 1
output +++                      ; hayes escape sequence
input 1 OK\13\10                ; wait for OK
if success goto slhup
output \13
pause 1
output at\13
input 1 OK\13\10
if fail goto slcmd              ; if modem doesn't answer OK, try again

:slhup                          ; hang up the phone
clear                           ; Clear unread characters from input buffer
pause 1
echo Hanging up the phone.
output ath0\13                  ; hayes command for on hook
input 2 OK\13\10
if fail goto slcmd              ; if no OK answer, put modem in command mode

:sldial                         ; dial the number
pause 1
echo Dialing.
output atdt9,550311\13\10               ; put phone number here
assign \%x 0                    ; zero the time counter

:look
clear                           ; Clear unread characters from input buffer
increment \%x                   ; Count the seconds
input 1 {CONNECT }
if success goto sllogin
reinput 1 {NO CARRIER\13\10}
if success goto sldial
reinput 1 {NO DIALTONE\13\10}
if success goto slnodial
reinput 1 {\255}
if success goto slhup
reinput 1 {\127}
if success goto slhup
if < \%x 60 goto look
else goto slhup

:sllogin                        ; login
assign \%x 0                    ; zero the time counter
pause 1
echo Looking for login prompt.

:slloop
increment \%x                   ; Count the seconds
clear                           ; Clear unread characters from input buffer
output \13
;
; put your expected login prompt here:
;
input 1 {Username: }
if success goto sluid
reinput 1 {\255}
if success goto slhup
reinput 1 {\127}
if success goto slhup
if < \%x 10 goto slloop         ; try 10 times to get a login prompt
else goto slhup                 ; hang up and start again if 10 failures

:sluid
;
; put your userid here:
;
output ppp-login\13
input 1 {Password: }
;
; put your password here:
;
output ppp-password\13
input 1 {Entering SLIP mode.}
echo
quit

:slnodial
echo \7No dialtone.  Check the telephone line!\7
exit 1

; local variables:
; mode: csh
; comment-start: "; "
; comment-start-skip: "; "
; end:
....

[[ppp-troubleshoot]]
== Решение проблем с соединениями PPP

Этот раздел охватывает несколько вопросов, которые могут возникнуть при использовании PPP через модемные соединения. Например, предположим, что вам потребовалось узнать, какое именно приглашение отображает система, до которой вы дозваниваетесь. Некоторые провайдеры выдают приглашение `ssword`, другие `password`; если `ppp` скрипт не обрабатывает такие приглашения, попытка входа завершится неудачно. Наиболее общий способ отладки соединений `ppp` это подключение вручную. Ниже дана пошаговая информация по подключению вручную.

=== Проверьте файлы устройств

Если вы пересобирали ядро, проверьте устройство [.filename]#sio#. Если вы не перенастраивали ядро, нет причин для беспокойства. Просто проверьте вывод `dmesg` для модемного устройства следующей командой:

[source,shell]
....
# dmesg | grep sio
....

Вы должны получить информацию о устройствах [.filename]#sio#. Это COM порты, которые нам необходимы. Если ваш модем работает как стандартный последовательный порт, вы увидите его на [.filename]#sio1#, или [.filename]#COM2#. Если это так, вам не требуется пересобирать ядро, необходимо лишь создать последовательное устройство. Вы можете сделать это, зайдя в [.filename]#/dev# и запустив скрипт [.filename]#MAKEDEV#. Создайте последовательные устройства:

[source,shell]
....
# sh MAKEDEV cuaa0 cuaa1 cuaa2 cuaa3
....

Если модем находится на [.filename]#sio1#, или [.filename]#COM2# в DOS, модемным устройством будет [.filename]#/dev/cuaa1#.

=== Подключение вручную

Подключение к интернет с контролированием `ppp` вручную это быстрый, легкий и действенный способ отладки соединения или получения информации о обслуживании провайдером клиентского соединения `ppp`. Запустите PPP из командной строки. В примерах в качестве имени хоста мы будем использовать _example_. Запустите `ppp`, введя команду `ppp`:

[source,shell]
....
# ppp
....

Теперь программа `ppp` запущена.

[source,shell]
....
ppp ON example> set device /dev/cuaa1
....

Мы указали модемное устройство, в данном случае [.filename]#cuaa1#.

[source,shell]
....
ppp ON example> set speed 115200
....

Мы установили скорость подключения к модему, в данном случае 115,200 кбит/с.

[source,shell]
....
ppp ON example> enable dns
....

Сообщает `ppp` настроить разрешение имен, добавив строки в [.filename]#/etc/resolv.conf#. Если `ppp` не может определить имя хоста, его можно настроить позже вручную.

[source,shell]
....
ppp ON example> term
....

Переключение в "терминальный" режим для контроля модема вручную.

[.programlisting]
....
deflink: Entering terminal mode on /dev/cuaa1
type '~h' for help
....

[source,shell]
....
at
OK
atdt123456789
....

Использование команды `at` для инициализации модема, а затем `atdt` и номера провайдера для начала дозвона.

[source,shell]
....
CONNECT
....

Подтверждение соединения, если есть проблемы с соединением, не вызванные проблемами в оборудовании, здесь мы попытаемся решить их.

[source,shell]
....
ISP Login:myusername
....

Здесь вам предлагается ввести имя пользователя в приглашение, выводимое сервером провайдера.

[source,shell]
....
ISP Pass:mypassword
....

Здесь предлагается ввести пароль, предоставленный провайдером. Как и при входе в FreeBSD, пароль не отображается.

[source,shell]
....
Shell or PPP:ppp
....

В зависимости от вашего провайдера, это приглашение может не появиться. Здесь задается вопрос, хотите ли вы использовать оболочку на компьютере провайдера или запустить `ppp`. В этом примере мы выбрали `ppp`, поскольку хотим соединиться с интернет.

[source,shell]
....
Ppp ON example>
....

Обратите внимание, что в этом примере первая буква `p` появилась в верхнем регистре. Это означает, что мы успешно подключились к провайдеру.

[source,shell]
....
PPp ON example>
....

Мы успешно аутентифицировались у провайдера и ожидаем присвоения IP адреса.

[source,shell]
....
PPP ON example>
....

Мы завершили согласование IP адресов, соединение успешно установлено.

[source,shell]
....
PPP ON example>add default HISADDR
....

Это маршрут по умолчанию, его необходимо настроить, чтобы сделать возможной связь с внешним миром, поскольку на этот момент установлена связь только с удаленной стороной. Если маршрут не устанавливается из-за уже существующего маршрута, добавьте символ `!` перед `add`. Альтернативно вы можете сделать настройку перед установкой соединения.

Если все прошло удачно, на данный момент должно работать соединение с интернет, которое можно поместить в фоновый режим клавишами kbd:[CTRL+z]. Переход строки `PPP` в приглашении в нижний регистр (`ppp`) означает, что соединение было разорвано. Таким образом, символы P в верхнем регистре означают наличие соединения, а в нижнем - потерю соединения.

==== Отладка

Если у вас выделенная линия и нет необходимости устанавливать соединение, выключите контроль передачи данных CTS/RTS командой `set ctsrts off`. Это обычно необходимо при подключении к поддерживающим PPP терминальным серверам, когда PPP прерывается при попытке записать данные в ваше соединение, и ожидает сигнала CTS, или Clear To Send, который не появляется. Если вы используете этот параметр, используйте также параметр `set accmap`, который может быть необходим для устранения зависимости от оборудования путем пропускания определенных символов через соединение, обычно XON/XOFF. Обратитесь к странице справочника man:ppp[8] за более подробной информацией по этому параметру и его использованию.

Если у вас старый модем, может потребоваться использование `set parity even`. Проверка четности по умолчанию отключена, но она используется для для устранения ошибок (с серьезным увеличением объема трафика) на старых модемах и у некоторых провайдеров.

PPP может не вернуться в командный режим, что обычно вызвано ошибкой согласования, когда провайдер ждет от вас начала процесса согласования. В этот момент использование команды `~p` заставит ppp начать отправку настроечной информации.

Если вы не получаете приглашения на вход, скорее всего вам требуется использование аутентификации PAP или CHAP вместо UNIX(R) стиля как в примерах выше. Для использования PAP или CHAP просто добавьте следующие параметры PPP перед переходом в терминальный режим:

[source,shell]
....
ppp ON example> set authname myusername
....

Необходимо заменить _myusername_ на имя пользователя, выданное провайдером.

[source,shell]
....
ppp ON example> set authkey mypassword
....

Где _mypassword_ должен быть заменен на пароль, выданный провайдером.

Если вы подключаетесь, не можете определить ни одно доменное имя, попробуйте использовать man:ping[8] с каким-либо IP адресом и просмотрите выводимую информацию. Если 100 процентов (100%) пакетов теряются, скорее всего не назначен маршрут по умолчанию. Дважды проверьте, что параметр `add default HISADDR` установлен во время соединения. Если вы можете подключиться к удаленному IP адресу, возможно, что адрес сервера имен не был добавлен в [.filename]#/etc/resolv.conf#. Этот файл должен выглядеть примерно так:

[.programlisting]
....
domain example.com
nameserver x.x.x.x
nameserver y.y.y.y
....

Где _x.x.x.x_ и _y.y.y.y_ должны быть заменены на IP адреса DNS серверов провайдера. Эта информация может предоставляться провайдером, вы можете выяснить это в службе поддержки.

Вы можете также настроить man:syslog[3] для протоколирования PPP соединения. Просто добавьте:

[.programlisting]
....
!ppp
*.*     /var/log/ppp.log
....

в файл [.filename]#/etc/syslog.conf#. В большинстве случаев эти строки уже присутствуют.

[[pppoe]]
== Использование PPP через Ethernet (PPPoE)

Этот раздел описывает настройку PPP через Ethernet (PPP over Ethernet, PPPoE).

=== Настройка ядра

Для PPPoE более не требуется настройка ядра. Если необходимая поддержка netgraph не встроена в ядро, она будет динамически загружена ppp.

=== Настройка [.filename]#ppp.conf#

Вот пример работающего [.filename]#ppp.conf#:

[.programlisting]
....
default:
  set log Phase tun command # you can add more detailed logging if you wish
  set ifaddr 10.0.0.1/0 10.0.0.2/0

name_of_service_provider:
  set device PPPoE:xl1 # replace xl1 with your Ethernet device
  set authname YOURLOGINNAME
  set authkey YOURPASSWORD
  set dial
  set login
  add default HISADDR
....

=== Запуск ppp

Под пользователем `root` вы можете запустить:

[source,shell]
....
# ppp -ddial name_of_service_provider
....

=== Запуск ppp при загрузке

Добавьте к [.filename]#/etc/rc.conf# следующее:

[.programlisting]
....
ppp_enable="YES"
ppp_mode="ddial"
ppp_nat="YES"	# if you want to enable nat for your local network, otherwise NO
ppp_profile="name_of_service_provider"
....

=== Использование тега сервиса PPPoE

Иногда для установки соединения необходимо использовать тег сервиса. Теги сервисов используются для различения PPPoE серверов, подключенных к одной сети.

В документации, предоставляемой провайдером, должна находиться необходимая информация о теге сервиса. Если вы не можете ее обнаружить, обратитесь в службу поддержки.

В крайнем случае, вы можете попробовать метод, предложенный в программе http://www.roaringpenguin.com/pppoe/[Roaring Penguin PPPoE], которая находится в crossref:ports[ports,коллекции портов]. Учтите, что этот метод может сделать ваш модем неработоспособным, так что дважды подумайте перед тем, как воспользоваться им. Просто установите программу, поставляемую с модемом вашим провайдером. Затем, войдите в меню menu:System[] программы. Имя вашего профиля должно находиться здесь. Обычно это _ISP_.

Имя профиля (тег сервиса) будет использоваться в записи настройки PPPoE в файле [.filename]#ppp.conf# (часть команды `set device`, относящаяся к провайдеру). Обратитесь к странице справочника man:ppp[8] за более подробной информацией. Эта команда должна выглядеть примерно так:

[.programlisting]
....
set device PPPoE:xl1:ISP
....

Не забудьте изменить _xl1_ на имя устройства вашей Ethernet карты.

Не забудьте изменить _ISP_ на профиль, определенный вами ранее.

Дополнительная информация:

* http://renaud.waldura.com/doc/freebsd/pppoe/[Cheaper Broadband with FreeBSD on DSL], опубликовал Renaud Waldura.
* http://www.ruhr.de/home/nathan/FreeBSD/tdsl-freebsd.html[ Nutzung von T-DSL und T-Online mit FreeBSD] by Udo Erdelhoff (на немецком).

[[ppp-3com]]
=== PPPoE c 3Com(R) HomeConnect(TM) ADSL Modem Dual Link

Этот модем не поддерживает http://www.faqs.org/rfcs/rfc2516.html[RFC 2516] (_Метод соединения PPP через Ethernet (PPPoE)_, написанный L. Mamakos, K. Lidl, J. Evarts, D. Carrel, D. Simone, и R. Wheeler). Вместо этого, для фреймов Ethernet используются различные коды типов пакетов. Сообщите http://www.3com.com/[3Com] если считаете, что они должны соблюдать спецификации PPPoE.

Для включения поддержки этого нестандартного устройства, в FreeBSD необходимо установить переменную sysctl. Это может быть сделано автоматически, поместите в [.filename]#/etc/sysctl.conf# следующую переменную:

[.programlisting]
....
net.graph.nonstandard_pppoe=1
....

или, для непосредственного включения, выполните команду `sysctl net.graph.nonstandard_pppoe=1`.

К сожалению, поскольку эта настройка влияет на всю систему, невозможно одновременно взаимодействовать с нормальным PPPoE клиентом или сервером и 3Com(R) HomeConnect(TM) ADSL Modem.

[[pppoa]]
== Использование PPP через ATM (PPPoA)

Далее описано как настроить PPP через ATM (PPP over ATM, PPPoA). PPPoA популярен у европейских провайдеров DSL.

=== Использование PPPoA с Alcatel SpeedTouch(TM) USB

Поддержка PPPoA для этого устройства в FreeBSD поставляется в виде порта, поскольку встроенное программное обеспечение поставляется под http://www.speedtouchdsl.com/disclaimer_lx.htm[лицензионным соглашением Alcatel] и не может свободно распространяться с основной системой FreeBSD.

Для установки этой программы, просто используйте crossref:ports[ports,коллекцию портов]. Установите порт package:net/pppoa[] и следуйте инструкциям.

Как и многие устройства USB, Alcatel SpeedTouch(TM) USB должен загрузить встроенное программное обеспечение с компьютера. Возможна автоматизация этого процесса в FreeBSD, чтобы эта передача происходила при подключении устройства к порту USB. Для включения этой автоматической передачи необходимо добавить в [.filename]#/etc/usbd.conf# нижеприведенную информацию. Этот файл необходимо отредактировать под пользователем `root`.

[.programlisting]
....
device "Alcatel SpeedTouch USB"
    devname "ugen[0-9]+"
    vendor 0x06b9
    product 0x4061
    attach "/usr/local/sbin/modem_run -f /usr/local/libdata/mgmt.o"
....

Для включения даемона USB, usbd, поместите в [.filename]#/etc/rc.conf# следующую строку:

[.programlisting]
....
usbd_enable="YES"
....

Возможна также настройка ppp для дозвона при запуске. Для этого добавьте в [.filename]#/etc/rc.conf# нижеприведенные строки. Опять же, для этого вам необходимо войти под пользователем `root`.

[.programlisting]
....
ppp_enable="YES"
ppp_mode="ddial"
ppp_profile="adsl"
....

Необходимо также использовать пример файла [.filename]#ppp.conf#, поставляемый с портом package:net/pppoa[].

=== Использование mpd

Вы можете использовать mpd для подключения к различным сервисам, в частности к сервисам PPTP. Вы можете найти mpd в коллекции портов, package:net/mpd[]. Многие ADSL модемы требуют, чтобы PPTP туннель был создан между модемом и компьютером, один из таких модемов это Alcatel SpeedTouch(TM) Home.

Сначала установите порт, затем настройте mpd под собственные нужды и настройки провайдера. Порт помещает набор примеров настройки в каталог [.filename]#PREFIX/etc/mpd/#. _PREFIX_ означает каталог, в который устанавливаются порты, по умолчанию это [.filename]#/usr/local/#. Полное руководство по настройке mpd доступно в HTML формате после установки порта. Оно находится в [.filename]#PREFIX/shared/doc/mpd/#. Ниже находится пример настройки mpd для соединения с ADSL сервисом. Настройка разделена на два файла, первый это [.filename]#mpd.conf#:

[.programlisting]
....
default:
    load adsl

adsl:
    new -i ng0 adsl adsl
    set bundle authname username <.>
    set bundle password password <.>
    set bundle disable multilink

    set link no pap acfcomp protocomp
    set link disable chap
    set link accept chap
    set link keep-alive 30 10

    set ipcp no vjcomp
    set ipcp ranges 0.0.0.0/0 0.0.0.0/0

    set iface route default
    set iface disable on-demand
    set iface enable proxy-arp
    set iface idle 0

    open
....

<.> Имя пользователя, используемое для аутентификации у провайдера.

<.> Пароль, используемый для аутентификации у провайдера.

Файл [.filename]#mpd.links# содержит информацию о соединении или соединениях, которые вы планируете установить. Пример [.filename]#mpd.links#, соответствующий приведенному выше примеру:

[.programlisting]
....
adsl:
    set link type pptp
    set pptp mode active
    set pptp enable originate outcall
    set pptp self 10.0.0.1 <.>
    set pptp peer 10.0.0.138 <.>
....

<.> IP адрес компьютера FreeBSD, с которого вы будете использовать mpd.
<.> IP адрес модема ADSL. Для Alcatel SpeedTouch(TM) Home этот адрес по умолчанию `10.0.0.138`.

Инициализация соединения возможно простым выполнением следующей команды под `root`:

[source,shell]
....
# mpd -b adsl
....

Вы можете просмотреть статус соединения с помощью следующей команды:

[source,shell]
....
% ifconfig ng0
ng0: flags=88d1<UP,POINTOPOINT,RUNNING,NOARP,SIMPLEX,MULTICAST> mtu 1500
     inet 216.136.204.117 --> 204.152.186.171 netmask 0xffffffff
....

Использование mpd это рекомендуемый способ подключения к сервису ADSL из FreeBSD.

=== Использование pptpclient

Возможно также использование FreeBSD для подключения к сервисам PPPoA с помощью package:net/pptpclient[].

Для подключения к сервису DSL с использованием package:net/pptpclient[], установите порт или пакет и отредактируйте [.filename]#/etc/ppp/ppp.conf#. Вам потребуется работать под `root`. Пример настройки [.filename]#ppp.conf# дан ниже. За дальнейшей информацией по параметрам [.filename]#ppp.conf# обратитесь к странице справочника ppp, man:ppp[8].

[.programlisting]
....
adsl:
 set log phase chat lcp ipcp ccp tun command
 set timeout 0
 enable dns
 set authname username <.>
 set authkey password <.>
 set ifaddr 0 0
 add default HISADDR
....

<.> Имя пользователя вашей учетной записи у провайдера DSL.

<.> Пароль для вашей учетной записи.

[WARNING]
====

Поскольку вам необходимо поместить пароль в незашифрованном виде в файл [.filename]#ppp.conf#, убедитесь что никто другой не сможет прочесть содержимое этого файла. Следующая последовательность команд сделает этот файл доступным для чтения только пользователю `root`. Обратитесь к страницам справочника man:chmod[1] и man:chown[8] за дальнейшей информацией.

[source,shell]
....
# chown root:wheel /etc/ppp/ppp.conf
# chmod 600 /etc/ppp/ppp.conf
....

====

Следующая команда откроет туннель для PPP сессии к вашему DSL маршрутизатору. Модемы Ethernet DSL поставляются с настроенным IP адресом локальной сети, к которому вы подключаетесь. У Alcatel SpeedTouch(TM) Home этот адрес `10.0.0.138`. В документации на ваш маршрутизатор должно быть указано, какой адрес используется. Для открытия туннеля и начала PPP сессии выполните:

[source,shell]
....
# pptp address adsl
....

[TIP]
====

Чтобы вернуться в приглашение командной строки после выполнения этой команды, добавьте символ "&" в конец строки.
====

Устройство виртуального туннеля [.filename]#tun# будет создано для взаимодействия между процессами pptp и ppp. Как только вы вернетесь в приглашение, или процесс pptp выполнит соединение, вы можете проверить туннель примерно такой командой:

[source,shell]
....
% ifconfig tun0
tun0: flags=8051<UP,POINTOPOINT,RUNNING,MULTICAST> mtu 1500
        inet 216.136.204.21 --> 204.152.186.171 netmask 0xffffff00
        Opened by PID 918
....

Если вы не сможете соединиться, проверьте настройку маршрутизатора, которая обычно доступна через telnet или через веб браузер. Если вы все еще не можете подключиться, проверьте вывод команды `pptp` и содержимое лог файла ppp, [.filename]#/var/log/ppp.log#.

[[slip]]
== Использование SLIP

[[slipc]]
=== Настройка SLIP клиента

Ниже дан один из способов настройки FreeBSD для подключения к SLIP сети со статическим адресом. Для динамического подключения (адрес изменяется при каждом дозвоне) возможно потребуется более сложная настройка.

Сначала определите, к какому последовательному порту подключен модем. Многие создают символическую ссылку, такую как [.filename]#/dev/modem#, на настоящий файл устройства, [.filename]#/dev/cuaaN#. Это позволяет абстрагироваться от имени файла устройства, например если вы переносите модем на другой порт. Довольно сложно править множество файлов в [.filename]#/etc# и [.filename]#.kermrc# во всей системе!

[NOTE]
====
[.filename]#/dev/cuaa0# это [.filename]#COM1#, [.filename]#cuaa1# это [.filename]#COM2#, и т.д.
====

Убедитесь, что в вашем файле настройки ядра присутствует строка:

[.programlisting]
....
pseudo-device   sl      1
....

В FreeBSD 5.X, используйте вместо этой строки следующую:

[.programlisting]
....
device   sl
....

Эта строка включена в ядро [.filename]#GENERIC#, так что если вы ее не удаляли, проблем быть не должно.

==== То, что необходимо сделать только один раз

[.procedure]
====

. Добавьте ваш компьютер, шлюз и сервера имен в файл [.filename]#/etc/hosts#. Вот пример такого файла:
+
[.programlisting]
....
127.0.0.1	       localhost loghost
136.152.64.181          water.CS.Example.EDU water.CS water
136.152.64.1            inr-3.CS.Example.EDU inr-3 slip-gateway
128.32.136.9            ns1.Example.EDU ns1
128.32.136.12           ns2.Example.EDU ns2
....
+
. Убедитесь, что в файле [.filename]#/etc/host.conf#`hosts` находится перед `bind` (для FreeBSD версий до 5.0). Начиная с FreeBSD 5.0, система использует файл [.filename]#/etc/nsswitch.conf#, убедитесь, что параметр `files` находится перед `dns` в строке `hosts` этого файла. Без этого параметра могут происходить странные вещи.
. Отредактируйте файл [.filename]#/etc/rc.conf#.
.. Установите имя хоста, настроив переменную hostname:
+
[.programlisting]
....
hostname="myname.my.domain"
....
+ 
Здесь необходимо использовать полное доменное имя вашего компьютера в интернет.
.. Добавьте [.filename]#sl0# к списку сетевых интерфейсов, изменив переменную:
+
[.programlisting]
....
network_interfaces="lo0"
....
+ 
на:
+
[.programlisting]
....
network_interfaces="lo0 sl0"
....
+
.. Измените параметры [.filename]#sl0#, добавив строку:
+
[.programlisting]
....
ifconfig_sl0="inet ${hostname} slip-gateway netmask 0xffffff00 up"
....
+
.. Назначьте маршрутизатор по умолчанию, изменив строку:
+
[.programlisting]
....
defaultrouter="NO"
....
+ 
на:
+
[.programlisting]
....
defaultrouter="slip-gateway"
....
+
. Создайте файл [.filename]#/etc/resolv.conf#, содержащий:
+
[.programlisting]
....
domain CS.Example.EDU
nameserver 128.32.136.9
nameserver 128.32.136.12
....
+ 
Как вы видите, здесь указаны адреса серверов имен. Конечно, реальные имена доменов и адреса для вас будут другими.
. Перегрузите компьютер и убедитесь, что его имя хоста настроено правильно.
====

==== Создание SLIP соединения

[.procedure]
====

. Дозвонитесь на удаленный сервер, введите `slip` в приглашение, имя своего компьютера и пароль. Все, что требуется ввести в вашем случае. Если вы используете kermit, попробуйте такой скрипт:
+
[.programlisting]
....
# kermit setup
set modem hayes
set line /dev/modem
set speed 115200
set parity none
set flow rts/cts
set terminal bytesize 8
set file type binary
# The next macro will dial up and login
define slip dial 643-9600, input 10 =>, if failure stop, -
output slip\x0d, input 10 Username:, if failure stop, -
output silvia\x0d, input 10 Password:, if failure stop, -
output ***\x0d, echo \x0aCONNECTED\x0a
....
+ 
Конечно, вам потребуется заменить имя хоста и пароль на ваши собственные. После этого, для подключения просто введите `slip` из приглашения kermit.
+
[NOTE]
======
Хранение пароля в любом месте файловой системы в незашифрованном виде это обычно плохая идея. Вы делаете это на свой риск.
======
+
. Выйдите из kermit (вы можете приостановить его, нажав kbd:[Ctrl+z]) и введите под `root`:
+
[source,shell]
....
# slattach -h -c -s 115200 /dev/modem
....
+ 
Если вы сможете выполнить `ping` для хостов по другую сторону маршрутизатора, вы подключились! Если это не работает, попробуйте параметр `slattach -a` вместо `-c`.
====

==== Как прервать соединение:

Сделайте следующее:

[source,shell]
....
# kill -INT `cat /var/run/slattach.modem.pid`
....

для остановки `slattach`. Помните, что вы должны работать под `root` для выполнения этой команды. Затем вернитесь в kermit (запустив `fg`, если он приостановлен) и выйдите из него (`q`).

Страница справочника `slattach` сообщает, что для отключения интерфейса необходимо использовать `ifconfig sl0 down`, но это похоже не играет никакой роли. (`ifconfig sl0` сообщает о том же.)

Иногда модем может не сбросить соединение (это бывает довольно часто). В этом случае просто запустите kermit и выйдите из него еще раз. При второй попытке соединение обычно разрывается.

==== Решение проблем

Вот наиболее часто встречающиеся ситуации:

* Не используются параметры `slattach``-c` или `-a` (это может быть не фатально, но иногда вызывает проблемы.)
* Используется `s10` вместо `sl0` (с некоторыми шрифтами сложно увидеть разницу).
* Попробуйте использовать `ifconfig sl0` для просмотра статуса интерфейса. Например, вы можете получить такую информацию:
+
[source,shell]
....
# ifconfig sl0
sl0: flags=10<POINTOPOINT>
        inet 136.152.64.181 --> 136.152.64.1 netmask ffffff00
....

* Если вы получите сообщение `no route to host` от команды ping, возможно это проблема с таблицей маршрутизации. Используйте команду `netstat -r` для отображения существующих маршрутов:
+
[source,shell]
....
# netstat -r
Routing tables
Destination      Gateway            Flags     Refs     Use  IfaceMTU    Rtt    Netmasks:

(root node)
(root node)

Route Tree for Protocol Family inet:
(root node) =>
default          inr-3.Example.EDU  UG          8   224515  sl0 -      -
localhost.Exampl localhost.Example. UH          5    42127  lo0 -       0.438
inr-3.Example.ED water.CS.Example.E UH          1        0  sl0 -      -
water.CS.Example localhost.Example. UGH        34 47641234  lo0 -       0.438
(root node)
....
+ 
Предыдущий пример получен на относительно загруженной системе. Числа в вашей системе будут сильно зависеть от загрузки сети.

[[slips]]
=== Настройка SLIP сервера

Этот документ предоставляет решение для настройки SLIP сервера в системе FreeBSD, что обычно означает настройку системы для автоматического запуска соединений при удаленном входе SLIP клиентов.

[[slips-prereqs]]
==== Предварительные требования

Информация в этом разделе чисто техническая, поэтому требуются некоторые предварительные знания. Предполагается, что вы знакомы с сетевым протоколом TCP/IP, и в частности, с адресацией сетей и хостов, сетевыми масками, делением на подсети, маршрутизацией и протоколами маршрутизации, такими как RIP. Настройка SLIP сервисов на сервере удаленного доступа требует знания этих концепций, и если вы не знакомы с ними, прочтите или книгу _TCP/IP Network Administration_ от Craig Hunt, опубликованную O'Reilly & Associates, Inc. (ISBN Number 0-937175-82-X), или книги Douglas Comer по протоколу TCP/IP.

В дальнейшем предполагается, что вы уже настроили ваш модем (модемы) и настроили соответствующие системные файлы для разрешения входа через них. Если вы еще не подготовили систему соответствующим образом, обратитесь к руководству по настройке сервисов удаленного входа; просмотрите список руководств на link:https://www.FreeBSD.org/ru/docs/[http://www.FreeBSD.org/ru/docs/]. Вы можете также обратиться к странице справочника man:sio[4] за информацией о драйвере последовательного порта и к страницам man:gettytab[5], man:getty[8] и man:init[8] за информацией по настройке системы для удаленного входа в систему через модемы, и возможно man:stty[1] за информацией о настройке параметров последовательных портов (таких как `clocal` для подключаемых непосредственно последовательных интерфейсов).

==== Краткий обзор

В типичной конфигурации FreeBSD работает в качестве SLIP сервера так: пользователь SLIP дозванивается на FreeBSD SLIP сервер и входит в систему со специальным SLIP логином, использующим [.filename]#/usr/sbin/sliplogin# в качестве оболочки. Программа `sliplogin` просматривает файл [.filename]#/etc/sliphome/slip.hosts# на предмет строки, соответствующей специальному пользователю, и если находит совпадение, подключает последовательную линию к доступному SLIP интерфейсу, а затем запускает shell скрипт [.filename]#/etc/sliphome/slip.login# для настройки SLIP интерфейса.

===== Пример входа на SLIP сервер

Например, идентификатор пользователя на SLIP сервере `Shelmerg`. Соответствующая запись в [.filename]#/etc/master.passwd# будет выглядеть примерно так:

[.programlisting]
....
Shelmerg:password:1964:89::0:0:Guy Helmer - SLIP:/usr/users/Shelmerg:/usr/sbin/sliplogin
....

Когда `Shelmerg` входит в систему, `sliplogin` ищет строку в [.filename]#/etc/sliphome/slip.hosts#, в которой находится соответствующий идентификатор пользователя; например, строка может быть такой:

[.programlisting]
....
Shelmerg	dc-slip sl-helmer       0xfffffc00		  autocomp
....

После обнаружения этой строки `sliplogin` подключает последовательную линию к следующему доступному SLIP интерфейсу, а затем выполняет [.filename]#/etc/sliphome/slip.login# примерно так:

[.programlisting]
....
/etc/sliphome/slip.login 0 19200 Shelmerg dc-slip sl-helmer 0xfffffc00 autocomp
....

Если все проходит нормально, [.filename]#/etc/sliphome/slip.login# вызовет `ifconfig` для SLIP интерфейса, к которому подключилась программа `sliplogin` (slip интерфейс 0 в примере выше, первый параметр в списке, задаваемом [.filename]#slip.login#) для установки локального IP адреса ((`dc-slip`), удаленного IP адреса (`sl-helmer`), сетевой маски для SLIP интерфейса (`0xfffffc00`), и любых дополнительных флагов (`autocomp`). Если что-то идет не так, `sliplogin` обычно протоколирует соответствующие сообщения в через уровень `daemon` syslog; эти сообщения как правило попадают в [.filename]#/var/log/messages# (обратитесь к страницам справочника man:syslogd[8] и man:syslog.conf[5], а также проверьте файл [.filename]#/etc/syslog.conf#, чтобы выяснить, что протоколирует `syslogd` и куда помещается информация).

Достаточно примеров - давайте начнем настройку системы.

==== Настройка ядра

Стандартное ядро FreeBSD обычно поставляется с двумя SLIP интерфейсами (([.filename]#sl0# и [.filename]#sl1#); вы можете использовать команду `netstat -i`, чтобы выяснить, определены ли эти интерфейсы в вашем ядре.

Пример вывода `netstat -i`:

[source,shell]
....
Name  Mtu   Network     Address            Ipkts Ierrs    Opkts Oerrs  Coll
ed0   1500  <Link>0.0.c0.2c.5f.4a         291311     0   174209     0   133
ed0   1500  138.247.224 ivory             291311     0   174209     0   133
lo0   65535 <Link>                            79     0       79     0     0
lo0   65535 loop        localhost             79     0       79     0     0
sl0*  296   <Link>                             0     0        0     0     0
sl1*  296   <Link>                             0     0        0     0     0
....

Наличие в выводе `netstat -i` интерфейсов [.filename]#sl0# и [.filename]#sl1# означает, что SLIP интерфейсы встроены в ядро (символ `*` показывает неактивность интерфейсов).

Ядро FreeBSD по умолчанию не пересылает пакеты между интерфейсами (компьютер FreeBSD не работает как маршрутизатор), вследствие требований RFC (см. RFCs 1009 [Requirements for Internet Gateways], 1122 [Requirements for Internet Hosts - Communication Layers], и возможно 1127 [A Perspective on the Host Requirements RFCs]). Если вы хотите, чтобы FreeBSD SLIP работал в качестве маршрутизатора, отредактируйте файл [.filename]#/etc/rc.conf# и присвойте переменной `gateway_enable` значение `YES`.

Для вступления изменений в силу потребуется перезагрузка.

В файле настройки стандартного ядра ([.filename]#/sys/i386/conf/GENERIC#) находится строка:

[.programlisting]
....
pseudo-device sl 2
....

Она определяет число доступных устройств SLIP в ядре; Число в конце строки определяет максимально возможное количество одновременных SLIP соединений.

Обратитесь к crossref:kernelconfig[kernelconfig, Настройка ядра FreeBSD] за информацией по настройке ядра FreeBSD.

==== Настройка sliplogin

Как упоминалось ранее, в каталоге [.filename]#/etc/sliphome# находятся три файла, являющиеся частью настройки для [.filename]#/usr/sbin/sliplogin# (для `sliplogin` существует страница справочника, man:sliplogin[8]): [.filename]#slip.hosts#, определяющий список пользователей SLIP и связанные с ними IP адреса; [.filename]#slip.login#, который обычно всего лишь настраивает SLIP интерфейс; [.filename]#slip.logout#, который восстанавливает состояние системы до запуска [.filename]#slip.login# после завершения последовательного соединения.

===== Настройка [.filename]#slip.hosts#

[.filename]#/etc/sliphome/slip.hosts# содержит строки, в которых находится как минимум четыре параметра, разделенных пробелами:

* ID пользователя SLIP
* Локальный адрес (локальный для SLIP сервера) SLIP соединения
* Удаленный адрес SLIP соединения
* Сетевая маска

Локальные и удаленные адреса могут быть именами хостов (разрешаемыми в IP адреса через файл [.filename]#/etc/hosts# или через службу доменных имен, в зависимости от настроек в файле [.filename]#/etc/nsswitch.conf# для FreeBSD 5.X, или [.filename]#/etc/host.conf# для FreeBSD 4.X), а сетевая маска может быть именем, разрешаемым через файл [.filename]#/etc/networks#. В системе, используемой в качестве примера, файл [.filename]#/etc/sliphome/slip.hosts# выглядит так:

[.programlisting]
....
#
# login local-addr      remote-addr     mask            opt1    opt2
#                                               (normal,compress,noicmp)
#
Shelmerg  dc-slip       sl-helmerg      0xfffffc00      autocomp
....

В конце строки находятся один или более параметров.

* `normal` - нет сжатия заголовков
* `compress` - сжимать заголовки
* `autocomp` - сжимать заголовки, если удаленная сторона это позволяет
* `noicmp` - запретить ICMP пакеты (любые "ping" пакеты будут отброшены и не станут помехой для другого трафика)

Выбор локального и удаленного адреса для SLIP соединений зависит от того, используете ли вы выделенную TCP/IP сеть, или используете на SLIP сервере "ARP прокси". (это не "настоящий" ARP прокси, но данная терминология используется в этом разделе). Если вы не уверены, какой метод выбрать, или как присвоить IP адреса, обратитесь к книгам по TCP/IP, упомянутым выше (<<slips-prereqs>>).

Если вы собираетесь использовать отдельную подсеть для SLIP клиентов, потребуется выделить адреса за пределом адресов вашей сети и присвоить каждому SLIP клиенту IP адрес из данной подсети. Затем вам возможно потребуется настроить статический маршрут в используемую для SLIP подсеть через SLIP сервер на ближайшем IP маршрутизаторе.

Иначе, если вы будете использовать метод "proxy ARP", потребуется присвоить SLIP клиентам IP адреса, не входящие в Ethernet подсеть сервера SLIP, а также настроить скрипты [.filename]#/etc/sliphome/slip.login# и [.filename]#/etc/sliphome/slip.logout#, чтобы использовать man:arp[8] для управления записями ARP прокси в таблице ARP сервера SLIP.

===== Настройка [.filename]#slip.login#

Типичный файл [.filename]#/etc/sliphome/slip.login# выглядит примерно так:

[.programlisting]
....
#!/bin/sh -
#
#       @(#)slip.login  5.1 (Berkeley) 7/1/90

#
# generic login file for a slip line.  sliplogin invokes this with
# the parameters:
#      1        2         3        4          5         6     7-n
#   slipunit ttyspeed loginname local-addr remote-addr mask opt-args
#
/sbin/ifconfig sl$1 inet $4 $5 netmask $6
....

Этот файл [.filename]#slip.login# всего лишь запускает `ifconfig` для соответствующего SLIP интерфейса с заданными локальным и удаленным адресом и сетевой маской.

Если вы решили использовать метод "ARP прокси" (вместо использования отдельной подсети для SLIP клиентов), ваш файл [.filename]#/etc/sliphome/slip.login# должен выглядеть примерно так:

[.programlisting]
....
#!/bin/sh -
#
#       @(#)slip.login  5.1 (Berkeley) 7/1/90

#
# generic login file for a slip line.  sliplogin invokes this with
# the parameters:
#      1        2         3        4          5         6     7-n
#   slipunit ttyspeed loginname local-addr remote-addr mask opt-args
#
/sbin/ifconfig sl$1 inet $4 $5 netmask $6
# Answer ARP requests for the SLIP client with our Ethernet addr
/usr/sbin/arp -s $5 00:11:22:33:44:55 pub
....

Дополнительная строка в этом [.filename]#slip.login#, `arp -s $5 00:11:22:33:44:55 pub`, создает ARP запись в ARP таблице SLIP сервера. При соединении другого узла в Ethernet с IP адресом SLIP клиента, SLIP сервер выдает ответ с собственным Ethernet MAC адресом.

При использовании примера выше убедитесь, что заменили Ethernet MAC адрес (`00:11:22:33:44:55`) на MAC адрес Ethernet карты вашей системы, или ваш "ARP прокси" точно не будет работать! Вы можете определить Ethernet MAC адрес SLIP сервера, просмотрев вывод команды `netstat -i` выше; информация об адресе находится второй строке:

[source,shell]
....
ed0   1500  <Link>0.2.c1.28.5f.4a         191923	0   129457     0   116
....

Это означает, что в данной системе Ethernet MAC адрес `00:02:c1:28:5f:4a` - точки в MAC адресе, выдаваемые `netstat -i`, должны быть заменены на двоеточия, необходимо также добавить нуль в начало каждого односимвольного шестнадцатеричного номера для преобразования этого адреса в форму, пригодную для man:arp[8]; обратитесь к странице справочника man:arp[8] за полной информацией по использованию.

[NOTE]
====
При создании [.filename]#/etc/sliphome/slip.login# и [.filename]#/etc/sliphome/slip.logout#, должен быть установлен бит "выполнения" (`chmod 755 /etc/sliphome/slip.login /etc/sliphome/slip.logout`), или `sliplogin` не сможет их выполнить.
====

===== Настройка [.filename]#slip.logout#

[.filename]#/etc/sliphome/slip.logout# не является совершенно необходимым (если только вы не реализуете "ARP прокси"), но если вы решили создать его, воспользуйтесь следующим примером:

[.programlisting]
....
#!/bin/sh -
#
#       slip.logout

#
# logout file for a slip line.  sliplogin invokes this with
# the parameters:
#      1        2         3        4          5         6     7-n
#   slipunit ttyspeed loginname local-addr remote-addr mask opt-args
#
/sbin/ifconfig sl$1 down
....

Если вы используете "ARP прокси", потребуется удаление записи ARP для SLIP клиента через [.filename]#/etc/sliphome/slip.logout#:

[.programlisting]
....
#!/bin/sh -
#
#       @(#)slip.logout

#
# logout file for a slip line.  sliplogin invokes this with
# the parameters:
#      1        2         3        4          5         6     7-n
#   slipunit ttyspeed loginname local-addr remote-addr mask opt-args
#
/sbin/ifconfig sl$1 down
# Quit answering ARP requests for the SLIP client
/usr/sbin/arp -d $5
....

Команда `arp -d $5` удаляет запись ARP, добавленную [.filename]#slip.login# при входе SLIP клиента.

Повторяем: убедитесь, что на файл [.filename]#/etc/sliphome/slip.logout# установлен бит выполнения (`chmod 755 /etc/sliphome/slip.logout`).

==== Соглашения о маршрутизации

Если вы не используете "ARP прокси" метод для маршрутизации пакетов между SLIP клиентами и остальной сетью (и возможно интернет), вам возможно потребуется статический маршрут (маршруты) до ближайшего шлюза (шлюзов) для маршрутизации подсети SLIP клиентов через SLIP сервер.

===== Статические маршруты

Добавление статических маршрутов может стать для кого-то проблемой (это даже невозможно, если у вас нет соответствующих прав). Если в вашей организации сеть с несколькими маршрутизаторами, некоторые маршрутизаторы, например Cisco и Proteon, требуют не только настройки статического маршрута в подсеть SLIP, но и указания, о каких статических маршрутах сообщать другим маршрутизаторам, так что для наладки работоспособности статической маршрутизации может потребоваться некоторое исследование и отладка.

===== Запуск GateD(R)

[NOTE]
====
GateD(R) это закрытое программно обеспечение, более недоступное в исходных текстах (дополнительная информация находится на вебсайте http://www.gated.org/[GateD(R)]). Этот раздел существует лишь в целях обратной совместимости для тех, кто все еще использует старую версию.
====

Альтернатива головной боли со статическими маршрутами это установка GateD(R) на FreeBSD SLIP сервере и настройка его для использования соответствующих протоколов маршрутизации (RIP/OSPF/BGP/EGP) для сообщения другим маршрутизаторам о вашей SLIP подсети. Вам потребуется создать [.filename]#/etc/gated.conf# для настройки gated. Ниже дан пример:

[.programlisting]
....
#
# gated configuration file for dc.dsu.edu; for gated version 3.5alpha5
# Only broadcast RIP information for xxx.xxx.yy out the ed Ethernet interface
#
#
# tracing options
#
traceoptions "/var/tmp/gated.output" replace size 100k files 2 general ;

rip yes {
  interface sl noripout noripin ;
  interface ed ripin ripout version 1 ;
  traceoptions route ;
} ;

#
# Turn on a bunch of tracing info for the interface to the kernel:
kernel {
  traceoptions remnants request routes info interface ;
} ;

#
# Propagate the route to xxx.xxx.yy out the Ethernet interface via RIP
#

export proto rip interface ed {
  proto direct {
      xxx.xxx.yy mask 255.255.252.0 metric 1; # SLIP connections
  } ;
} ;

#
# Accept routes from RIP via ed Ethernet interfaces

import proto rip interface ed {
  all ;
} ;
....

В примере выше используется широковещательная рассылка информации о маршрутизации для подсети SLIP _xxx.xxx.yy_ протоколом RIP на сеть Ethernet; если вы используете другой драйвер Ethernet вместо [.filename]#ed#, потребуется соответственно изменить запись для [.filename]#ed#. В этом примере отладочная информация переправляется в [.filename]#/var/tmp/gated.output#; вы можете выключить отладку, если GateD(R) работает. Вам потребуется заменить _xxx.xxx.yy_ в сетевом адресе на вашу подсеть SLIP (убедитесь, что изменение сетевой маски в `proto direct` работает нормально).

Как только вы установили и настроили GateD(R), потребуется сообщить стартовым скриптам FreeBSD запускать его вместо routed. Простейший способ сделать это - установить переменные `router` и `router_flags` в [.filename]#/etc/rc.conf#. Обратитесь к странице справочника GateD(R) за информацией о параметрах командной строки.
