---
title: Глава 25. Сетевые серверы
part: Часть IV. Сетевые коммуникации
prev: books/handbook/mail
next: books/handbook/firewalls
---

[[network-servers]]
= Сетевые серверы
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:source-highlighter: rouge
:experimental:
:skip-front-matter:
:toc-title: Содержание
:table-caption: Таблица
:figure-caption: Рисунок
:example-caption: Пример
:xrefstyle: basic
:relfileprefix: ../
:outfilesuffix:
:sectnumoffset: 25

ifeval::["{backend}" == "html5"]
:imagesdir: ../../../images/books/handbook/network-servers/
endif::[]

ifeval::["{backend}" == "pdf"]
:imagesdir: ../../../../static/images/books/handbook/network-servers/
endif::[]

ifeval::["{backend}" == "epub3"]
:imagesdir: ../../../../static/images/books/handbook/network-servers/
endif::[]

include::shared/authors.adoc[]
include::shared/releases.adoc[]
include::shared/ru/mailing-lists.adoc[]
include::shared/ru/teams.adoc[]
include::shared/ru/urls.adoc[]

toc::[]

[[network-servers-synopsis]]
== Краткий обзор

Эта глава посвящена некоторым наиболее часто используемым сетевым службам систем UNIX(R). Мы опишем, как установить, настроить, протестировать и поддерживать многие различные типы сетевых сервисов. Для облегчения вашей работы в главу включены примеры конфигурационных файлов.

После чтения этой главы вы будете знать:

* Как управлять даемоном inetd.
* Как настроить сетевую файловую систему.
* Как настроить сетевой сервер информации для совместного использования учётных записей пользователей.
* Как настроить автоматическое конфигурирование сетевых параметров при помощи DHCP.
* Как настроить сервер имён.
* Как настроить Apache HTTP сервер.
* Как настроить файловый и сервер печати для Windows(R) клиентов с использованием Samba.
* Как синхронизировать дату и время, а также настроить сервер времени с протоколом NTP.
* Как настроить стандартный демон протоколирования, `syslogd`, принимать сообщения от удалённых хостов.

Перед чтением этой главы вы должны:

* Понимать основы работы скриптов [.filename]#/etc/rc#.
* Свободно владеть основными сетевыми терминами.
* Знать как устанавливать дополнительные программы сторонних разработчиков (crossref:ports[ports, Установка приложений. порты и пакеты]).

[[network-inetd]]
== "Супер-сервер"inetd

[[network-inetd-overview]]
=== Обзор

man:inetd[8] иногда называют также "супер-сервером Интернет", потому что он управляет соединениями к многим сервисам. Когда inetd принимает соединение, он определяет, для какой программы предназначено соединение, запускает соответствующий процесс и предоставляет ему сокет, ссылка на который передается процессу в качестве стандартных устройств ввода, вывода и сообщения об ошибках. Для не слишком нагруженных серверов запуск через inetd может уменьшить общую нагрузку на систему по сравнению с запуском каждого даемона индивидуально в выделенном режиме.

В первую очередь inetd используется для вызова других даемонов, но несколько простых протоколов, таких, как chargen, auth и daytime, обслуживаются непосредственно.

Этот раздел посвящен основам настройки inetd посредством его параметров командной строки и его конфигурационного файла, [.filename]#/etc/inetd.conf#.

[[network-inetd-settings]]
=== Настройки

inetd инициализируется посредством системы man:rc[8]. Параметр `inetd_enable` по умолчанию установлен в `NO`, однако может быть включен утилитой sysinstall в процессе установки. Указание

[.programlisting]
....
inetd_enable="YES"
....

или

[.programlisting]
....
inetd_enable="NO"
....

в файле [.filename]#/etc/rc.conf# разрешит или запретит запуск inetd во время загрузки. Команда

[.programlisting]
....
/etc/rc.d/inetd rcvar
....

покажет текущие установки переменных, относящихся к inetd.

Кроме того, через `inetd_flags` даемону inetd могут быть переданы различные параметры командной строки.

[[network-inetd-cmdline]]
=== Параметры командной строки

Как и большинство даемонов, для inetd существует большое количество разнообразных опций, изменяющих его поведение. Полный из список таков:

`inetd [-d] [-l] [-w] [-W] [-c maximum] [-C rate] [-a address | hostname] [-p filename] [-R rate] [-s maximum] [configuration file]`

Опции могут передаваться inetd при помощи переменной `inetd_flags` файла [.filename]#/etc/rc.conf#. По умолчанию переменная `inetd_flags` установлена в `-wW -C 60`, то есть включает обработку TCP wrapping и запрещает обращаться с одного IP-адреса к сервису более чем 60 раз в минуту.

Несмотря на то, что ниже по тексту мы упоминаем опции ограничения частоты обращения к службам (rate-limiting), в большинстве случаев начинающим пользователям нет необходимости менять эти параметры. Эти опции могут стать полезными в том случае, если вы обнаружите, что ваша система принимает чрезмерное количество соединений. Полный список опций можно найти на странице справочника man:inetd[8].

-c maximum::
Определение максимального числа одновременных запусков каждой службы; по умолчание не ограничено. Может быть переопределено индивидуально для каждой службы при помощи параметра `max-child`.

-C rate::
Определение по умолчанию максимального количества раз, которое служба может быть вызвана с одного IP-адреса в минуту; по умолчанию не ограничено. Может быть переопределено для каждой службы параметром `max-connections-per-ip-per-minute`.

-R rate::
Определяет максимальное количество раз, которое служба может быть вызвана в минуту; по умолчанию 256. Частота, равная 0, не ограничивает число вызовов.

-s maximum::
Задает максимальное количество процессов, одновременно обслуживающих один сервис для одного IP-адреса; по умолчанию не ограничено. Может переопределяться для каждой службы параметром `max-child-per-ip`.

[[network-inetd-conf]]
=== [.filename]#inetd.conf#

Настройка inetd производится через файл [.filename]#/etc/inetd.conf#.

Если в файле [.filename]#/etc/inetd.conf# делались изменения, то inetd можно заставить считать его конфигурационный файл повторно посредством команды

[[network-inetd-reread]]
.Перезагрузка конфигурационного файла inetd
[example]
====

[source,bash]
....
# /etc/rc.d/inetd reload
....

====

В каждой строке конфигурационного файла описывается отдельный даемон. Комментариям в файле предшествует знак "#". Строки в файле [.filename]##/etc/inetd.conf## имеют такой формат:

[.programlisting]
....
service-name
socket-type
protocol
{wait|nowait}[/max-child[/max-connections-per-ip-per-minute[/max-child-per-ip]]]
user[:group][/login-class]
server-program
server-program-arguments
....

Пример записи для даемона man:ftpd[8], использующего IPv4:

[.programlisting]
....
ftp     stream  tcp     nowait  root    /usr/libexec/ftpd       ftpd -l
....

service-name::
Это имя сервиса, предоставляемого конкретным даемоном. Оно должно соответствовать сервису, указанному в файле [.filename]#/etc/services#. Здесь определяется, какой порт должен обслуживать inetd. При создании нового сервиса он должен помещаться сначала в файл [.filename]#/etc/services#.

socket-type::
`stream`, `dgram`, `raw` либо `seqpacket`. `stream` должен использоваться для ориентированных на соединение даемонов TCP, когда как `dgram` используется для даемонов, использующих транспортный протокол UDP.

protocol::
Одно из следующих:
+

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Протокол
| Описание

|tcp, tcp4
|TCP IPv4

|udp, udp4
|UDP IPv4

|tcp6
|TCP IPv6

|udp6
|UDP IPv6

|tcp46
|TCP как для IPv4, так и для v6

|udp46
|UDP как для IPv4, так и для v6
|===
{wait|nowait}[/max-child[/max-connections-per-ip-per-minute[/max-child-per-ip]]]::
`wait|nowait` определяет, может ли даемон, вызванный из inetd, работать с собственным сокетом, или нет. Сокеты типа `dgram` должны использовать параметр `wait`, когда как даемоны с потоковыми сокетами, которые обычно многопоточны, должны использовать `nowait`. `wait` обычно передает много сокетов одному даемону, когда как `nowait` порождает даемон для каждого нового сокета.
+
Максимальное число порожденных даемонов, которых может создать inetd, может быть задано параметром `max-child`. Если нужно ограничение в десять экземпляров некоторого даемона, то после параметра `nowait` нужно задать `/10`. При задании `/0` ограничения на количество экземпляров снимаются.
+
Кроме `max-child`, могут быть задействованы два других параметра, ограничивающих максимальное число соединений от одного источника. `max-connections-per-ip-per-minute` ограничивает количество соединений от одного IP-адреса в течение минуты, так что значение, равное десяти, будет ограничивать любой заданный IP-адрес на выполнение десяти попыток подключения к некоторому сервису в минуту. Параметр `max-child-per-ip` ограничивает количество дочерних процессов, которые могут быть одновременно задействованы на обслуживание одного IP-адреса. Эти опции полезны для предотвращения намеренного или ненамеренного расходования ресурсов и атак типа Denial of Service (DoS) на машину.
+
В этом поле одно из значений `wait` или `nowait` обязательны. `max-child`, `max-connections-per-ip-per-minute` и `max-child-per-ip` опциональны.
+
Многопоточный даемон типа stream без ограничений `max-child`, `max-connections-per-ip-per-minute` или `max-child-per-ip` будет определен просто как `nowait`.
+
Тот же самый даемон с ограничением в максимум десять даемонов будет определен так: `nowait/10`.
+
Та же конфигурация с ограничением в двадцать соединений на IP-адрес в минуту и общим ограничением в максимум десять порожденных даемонов выглядит так: `nowait/10/20`.
+
Эти параметры, используемые все со значениями по умолчанию даемоном man:fingerd[8], имеют такой вид:
+
[.programlisting]
....
finger stream  tcp     nowait/3/10 nobody /usr/libexec/fingerd fingerd -s
....
+
Наконец, пример, описывающий ограничение на 100 даемонов в целом, при этом не более чем по 5 на один IP-адрес, будет выглядеть так: `nowait/100/0/5`.

user::
Это имя пользователя, под которым должен работать соответствующий даемон. Чаще всего даемоны работают как пользователь `root`. Для обеспечения безопасности некоторые серверы запускаются как пользователь `daemon` или как пользователь с минимальными правами `nobody`.

server-program::
Полный маршрут к даемону, который будет выполняться при установлении соединения. Если даемон является сервисом, предоставляемым самим inetd, то нужно задать ключевое слово `internal`.

server-program-arguments::
Этот параметр работает вместе с параметром `server-program`, задавая параметры, начиная с `argv[0]`, передаваемые даемону при запуске. Если в командной строке задано `mydaemon -d`, то `mydaemon -d` будет являться значением для `server-program-arguments`. И снова, если даемон является внутренней службой, то здесь нужно использовать `internal`.

[[network-inetd-security]]
=== Безопасность

В зависимости от выбранных при установке параметров, многие из служб inetd могут оказаться по умолчанию включенными. Если нет особой нужды в некотором даемоне, подумайте, не стоит ли его выключить? Поместите знак "#" перед ненужным даемоном в [.filename]##/etc/inetd.conf## и <<network-inetd-reread,пошлите сигнал для inetd>>. Некоторые даемоны, такие, как fingerd, вообще нежелательны, потому что они дают информацию, которая может оказаться полезной атакующему.

Некоторые даемоны не заботятся о безопасности и имеют большие тайм-ауты для соединений или вообще их не имеют. Это позволяет атакующему неспешно устанавливать соединения к конкретному даемону, истощая имеющиеся ресурсы. Может оказаться полезным задать для некоторых даемонов ограничения `max-connections-per-ip-per-minute`, `max-child` и `max-child-per-ip`, особенно если вы обнаружите слишком большое число соединений.

По умолчанию механизм TCP wrapping включен. Обратитесь к справочной странице по man:hosts_access[5] для получения более подробной информации о задании ограничений TCP для различных даемонов, запускаемых посредством inetd.

[[network-inetd-misc]]
=== Разное

daytime, time, echo, discard, chargen и auth все являются услугами, предоставляемыми самим inetd.

Сервис auth предоставляет идентификационные сетевые услуги и поддается настройке; прочие сервисы ненастраиваемы.

Обратитесь к справочной странице по man:inetd[8] для получения более подробной информации.

[[network-nfs]]
== Network File System (NFS)

Кроме поддержки многих прочих типов файловых систем, во FreeBSD встроена поддержка сетевой файловой системы (Network File System), известной как NFS. NFS позволяет системе использовать каталоги и файлы совместно с другими машинами, посредством сети. Посредством NFS пользователи и программы могут получать доступ к файлам на удалённых системах точно так же, как если бы это были файлы на собственных дисках.

Вот некоторые из наиболее заметных преимуществ, которые даёт использование NFS:

* Отдельно взятые рабочие станции используют меньше собственного дискового пространства, так как совместно используемые данные могут храниться на одной отдельной машине и быть доступными для других машин в сети.
* Пользователям не нужно иметь домашние каталоги, отдельные для каждой машины в вашей сети. Домашние каталоги могут располагаться на сервере NFS и их можно сделать доступными отовсюду в сети.
* Устройства хранения информации, такие, как дискеты, приводы CD-ROM и устройства Zip(R), могут использоваться другими машинами в сети. Это может привести к уменьшению переносимых устройств хранения информации в сети.

=== Как работает NFS

NFS строится по крайней мере из двух основных частей: сервера и одного или большего количества клиентов. Клиент обращается к данным, находящимся на сервере, в режиме удалённого доступа. Для того, чтобы это нормально функционировало, нужно настроить и запустить несколько процессов.

На сервере работают следующие даемоны:

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Даемон
| Описание

|nfsd
|Даемон NFS, обслуживающий запросы от клиентов NFS.

|mountd
|Даемон монтирования NFS, который выполняет запросы, передаваемые ему от man:nfsd[8].

|rpcbind
|Этот даемон позволяет клиентам NFS определить порт, используемый сервером NFS.
|===

Клиент может запустить также даемон, называемый nfsiod. nfsiod обслуживает запросы, поступающие от сервера от сервера NFS. Он необязателен, увеличивает производительность, однако для нормальной и правильной работы не требуется. Для получения дополнительной информации обратитесь к разделу справочной системы о man:nfsiod[8].

[[network-configuring-nfs]]
=== Настройка NFS

Настройка NFS является достаточно незамысловатым процессом. Все процессы, которые должны быть запущены, могут быть запущены во время загрузки посредством нескольких модификаций в вашем файле [.filename]#/etc/rc.conf#.

Проверьте, что на NFS-сервере в файле [.filename]#/etc/rc.conf# имеются такие строки:

[.programlisting]
....
rpcbind_enable="YES"
nfs_server_enable="YES"
nfs_server_flags="-u -t -n 4"
mountd_flags="-r"
....

mountd запускается автоматически, если включена функция сервера NFS.

На клиенте убедитесь, что в файле [.filename]#/etc/rc.conf# присутствует такой параметр:

[.programlisting]
....
nfs_client_enable="YES"
....

Файл [.filename]#/etc/exports# определяет, какие файловые системы на вашем сервере NFS будут экспортироваться (иногда их называют "совместно используемыми"). Каждая строка в [.filename]#/etc/exports# задаёт файловую систему, которая будет экспортироваться и какие машины будут иметь к ней доступ. Кроме машин, имеющих доступ, могут задаваться другие параметры, влияющие на характеристики доступа. Имеется полный набор параметров, которые можно использовать, но здесь пойдёт речь лишь о некоторых из них. Описания остальных параметров можно найти на страницах справочной системы по man:exports[5].

Вот несколько примерных строк из файла [.filename]#/etc/exports#:

В следующих примерах даётся общая идея того, как экспортировать файловые системы, хотя конкретные параметры могут отличаться в зависимости от ваших условий и конфигурации сети. К примеру, чтобы экспортировать каталог [.filename]#/cdrom# для трёх машин, находящихся в том же самом домене, что и сервер (поэтому отсутствует доменное имя для каждой машины) или для которых имеются записи в файле [.filename]#/etc/hosts#. Флаг `-ro` указывает на использование экспортируемой файловой системы в режиме только чтения. С этим флагом удалённая система не сможет никоим образом изменить экспортируемую файловую систему.

[.programlisting]
....
/cdrom -ro host1 host2 host3
....

В следующей строке экспортируется файловая система [.filename]#/home#, которая становится доступной трем хостам, указанным по их IP-адресам. Это полезно, если у вас есть собственная сеть без настроенного сервера DNS. Как вариант, файл [.filename]#/etc/hosts# может содержать внутренние имена хостов; пожалуйста, обратитесь к справочную систему по man:hosts[5] для получения дополнительной информации. Флаг `-alldirs` позволяет рассматривать подкаталоги в качестве точек монтирования. Другими словами, это не монтирование подкаталогов, но разрешение клиентам монтировать только каталоги, которые им требуются или нужны.

[.programlisting]
....
/home  -alldirs  10.0.0.2 10.0.0.3 10.0.0.4
....

В строке, приведённой ниже, файловая система [.filename]#/a# экспортируется таким образом, что она доступна двум клиентам из других доменов. Параметр `-maproot=root` позволяет пользователю `root` удалённой системы осуществлять запись на экспортируемую файловую систему как пользователь `root`. Если параметр `-maproot=root` не задан, то даже если пользователь имеет права доступа `root` на удалённой системе, он не сможет модифицировать файлы на экспортированной файловой системе.

[.programlisting]
....
/a  -maproot=root  host.example.com box.example.org
....

Для того, чтобы клиент смог обратиться к экспортированной файловой системе, он должен иметь права сделать это. Проверьте, что клиент указан в вашем файле [.filename]#/etc/exports#.

В файле [.filename]#/etc/exports# каждая строка содержит информацию об экспортировании для отдельной файловой системы для отдельно взятого хоста. Удалённый хост может быть задан только один раз для каждой файловой системы, и может иметь только одну запись, используемую по умолчанию, для каждой локальной файловой системы. К примеру, предположим, что [.filename]#/usr# является отдельной файловой системой. Следующий [.filename]#/etc/exports# будет некорректен:

[.programlisting]
....
# Invalid when /usr is one file system
/usr/src   client
/usr/ports client
....

Одна файловая система, [.filename]#/usr#, имеет две строки, задающие экспортирование для одного и того же хоста, `client`. Правильный формат в этом случае таков:

[.programlisting]
....
/usr/src /usr/ports  client
....

Свойства отдельной файловой системы, экспортируемой некоторому хосту, должны задаваться в одной строке. Строки без указания клиента воспринимаются как отдельный хост. Это ограничивает то, как вы можете экспортировать файловые системы, но для большинства это не проблема.

Ниже приведён пример правильного списка экспортирования, где [.filename]#/usr# и [.filename]#/exports# являются локальными файловыми системами:

[.programlisting]
....
# Экспортируем src и ports для client01 и client02, но
# только client01 имеет права пользователя root на них
/usr/src /usr/ports -maproot=root    client01
/usr/src /usr/ports	       client02
# Клиентские машины имеют пользователя root и могут монтировать всё в
# каталоге /exports.  Кто угодно может монтировать /exports/obj в режиме чтения
/exports -alldirs -maproot=root      client01 client02
/exports/obj -ro
....

Даемон mountd должен быть проинформирован об изменении файла [.filename]#/etc/exports#, чтобы изменения вступили в силу. Это может быть достигнуто посылкой сигнала HUP процессу `mountd`:

[source,bash]
....
# kill -HUP `cat /var/run/mountd.pid`
....

или вызовом скрипта `mountd` подсистемы man:rc[8] с соответствующим параметром:

[source,bash]
....
# /etc/rc.d/mountd onereload
....

За подробной информацией о работе скриптов rc.d обращайтесь к crossref:config[configtuning-rcd,Использование rc во FreeBSD 5.X и последующих версиях].

Как вариант, при перезагрузке FreeBSD всё настроится правильно. Хотя выполнять перезагрузку вовсе не обязательно. Выполнение следующих команд пользователем `root` запустит всё, что нужно.

На сервере NFS:

[source,bash]
....
# rpcbind
# nfsd -u -t -n 4
# mountd -r
....

На клиенте NFS:

[source,bash]
....
# nfsiod -n 4
....

Теперь всё должно быть готово к реальному монтированию удалённой файловой системы. В приводимых примерах сервер будет носить имя `server`, а клиент будет носить имя `client`. Если вы только хотите временно смонтировать удалённую файловую систему, или всего лишь протестировать ваши настройки, то просто запустите команды, подобные приводимым здесь, работая как пользователь `root` на клиентской машине:

[source,bash]
....
# mount server:/home /mnt
....

По этой команде файловая система [.filename]#/home# на сервере будет смонтирована в каталог [.filename]#/mnt# на клиенте. Если всё настроено правильно, вы сможете войти в каталог [.filename]#/mnt# на клиенте и увидеть файлы, находящиеся на сервере.

Если вы хотите автоматически монтировать удалённую файловую систему при каждой загрузке компьютера, добавьте файловую систему в [.filename]#/etc/fstab#. Вот пример:

[.programlisting]
....
server:/home	  /mnt	  nfs	  rw	  0	  0
....

На страницах справочной системы по man:fstab[5] перечислены все доступные параметры.

=== Блокировка файлов

Некоторым приложениям (например, mutt) для корректной работы необходима возможность блокировки файлов (file locking). При работе по NFS блокировка файлов может осуществляться при помощи демона rpc.lockd. Чтобы его активировать, добавьте следующие записи в файл [.filename]#/etc/rc.conf# как на клиенте, так и на сервере NFS (предполагается, что и клиент, и сервер уже сконфигурированы):

[.programlisting]
....
rpc_lockd_enable="YES"
rpc_statd_enable="YES"
....

Запустите демоны, выполнив следующие команды:

[source,bash]
....
# /etc/rc.d/lockd start
# /etc/rc.d/statd start
....

Если нет необходимости в настоящей блокировке файлов между сервером NFS и клиентами, то клиент NFS может быть настроен так, чтобы выполнять блокировки файлов локально, для чего необходимо передать опцию `-L` команде man:mount_nfs[8]. За подробностями обратитесь к странице справочника man:mount_nfs[8].

=== Практическое использование

У NFS есть много вариантов практического применения. Ниже приводится несколько наиболее широко распространённых способов её использования:

* Настройка несколько машин для совместного использования CDROM или других носителей. Это более дешёвый и зачастую более удобный способ установки программного обеспечения на несколько машин.
* В больших сетях может оказаться более удобным настроить центральный сервер NFS, на котором размещаются все домашние каталоги пользователей. Эти домашние каталоги могут затем экспортироваться в сеть так, что пользователи всегда будут иметь один и тот же домашний каталог вне зависимости от того, на какой рабочей станции они работают.
* Несколько машин могут иметь общий каталог [.filename]#/usr/ports/distfiles#. Таким образом, когда вам нужно будет установить порт на несколько машин, вы сможете быстро получить доступ к исходным текстам без их загрузки на каждой машине.

[[network-amd]]
=== Автоматическое монтирование с amd

man:amd[8] (даемон автоматического монтирования) автоматически монтирует удалённую файловую систему, как только происходит обращение к файлу или каталогу в этой файловой системе. Кроме того, файловые системы, которые были неактивны некоторое время, будут автоматически размонтированы даемоном amd. Использование amd является простой альтернативой статическому монтированию, так как в последнем случае обычно всё должно быть описано в файле [.filename]#/etc/fstab#.

amd работает, сам выступая как сервер NFS для каталогов [.filename]#/host# и [.filename]#/net#. Когда происходит обращение к файлу в одном из этих каталогов, amd ищет соответствующий удаленный ресурс для монтирования и автоматически его монтирует. [.filename]#/net# используется для монтирования экспортируемой файловой системы по адресу IP, когда как каталог [.filename]#/host# используется для монтирования ресурса по удаленному имени хоста.

Обращение к файлу в каталоге [.filename]#/host/foobar/usr# укажет amd на выполнение попытки монтирования ресурса [.filename]#/usr#, который находится на хосте `foobar`.

.Монтирование ресурса при помощи amd
[example]
====
Вы можете посмотреть доступные для монтирования ресурсы отдалённого хоста командой `showmount`. К примеру, чтобы посмотреть ресурсы хоста с именем `foobar`, вы можете использовать:

[source,bash]
....
% showmount -e foobar
Exports list on foobar:
/usr			       10.10.10.0
/a				 10.10.10.0
% cd /host/foobar/usr
....

====

Как видно из примера, `showmount` показывает [.filename]#/usr# как экспортируемый ресурс. При переходе в каталог [.filename]#/host/foobar/usr# даемон amd пытается разрешить имя хоста `foobar` и автоматически смонтировать требуемый ресурс.

amd может быть запущен из скриптов начальной загрузки, если поместить такую строку в файл [.filename]#/etc/rc.conf#:

[.programlisting]
....
amd_enable="YES"
....

Кроме того, даемону amd могут быть переданы настроечные флаги через параметр `amd_flags`. По умолчанию `amd_flags` настроен следующим образом:

[.programlisting]
....
amd_flags="-a /.amd_mnt -l syslog /host /etc/amd.map /net /etc/amd.map"
....

Файл [.filename]#/etc/amd.map# задает опции, используемые по умолчанию при монтировании экспортируемых ресурсов. В файле [.filename]#/etc/amd.conf# заданы настройки некоторых более сложных возможностей amd.

Обратитесь к справочным страницам по man:amd[8] и man:amd.conf[8] для получения более полной информации.

[[network-nfs-integration]]
=== Проблемы взаимодействия с другими системами

Некоторые сетевые адаптеры для систем PC с шиной ISA имеют ограничения, которые могут привести к серьезным проблемам в сети, в частности, с NFS. Эти проблемы не специфичны для FreeBSD, однако эту систему они затрагивают.

Проблема, которая возникает практически всегда при работе по сети систем PC (FreeBSD) с высокопроизводительными рабочими станциями, выпущенными такими производителями, как Silicon Graphics, Inc. и Sun Microsystems, Inc. Монтирование по протоколу NFS будет работать нормально, и некоторые операции также будут выполняться успешно, но неожиданно сервер окажется недоступным для клиент, хотя запросы к и от других систем будут продолжаться обрабатываться. Такое встречается с клиентскими системами, не зависимо от того, является ли клиент машиной с FreeBSD или рабочей станцией. Во многих системах при возникновении этой проблемы нет способа корректно завершить работу клиента. Единственным выходом зачастую является холодная перезагрузка клиента, потому что ситуация с NFS не может быть разрешена.

Хотя "правильным" решением является установка более производительного и скоростного сетевого адаптера на систему FreeBSD, имеется простое решение, приводящее к удовлетворительным результатам. Если система FreeBSD является _сервером_, укажите параметр `-w=1024` на клиенте при монтировании. Если система FreeBSD является _клиентом_, то смонтируйте файловую систему NFS с параметром `-r=1024`. Эти параметры могут быть заданы в четвертом поле записи в файле [.filename]#fstab# клиента при автоматическом монтировании, или при помощи параметра `-o` в команде man:mount[8] при монтировании вручную.

Нужно отметить, что имеется также другая проблема, ошибочно принимаемая за приведенную выше, когда серверы и клиенты NFS находятся в разных сетях. Если это тот самый случай, _проверьте_, что ваши маршрутизаторы пропускают нужную информацию UDP, в противном случае вы ничего не получите, что бы вы ни предпринимали.

В следующих примерах `fastws` является именем хоста (интерфейса) высокопроизводительной рабочей станции, а `freebox` является именем хоста (интерфейса) системы FreeBSD со слабым сетевым адаптером. Кроме того, [.filename]#/sharedfs# будет являться экспортируемой через NFS файловой системой (обратитесь к страницам справочной системы по команде man:exports[5]), а [.filename]#/project# будет точкой монтирования экспортируемой файловой системы на клиенте. В любом случае, отметьте, что для вашего приложения могут понадобиться дополнительные параметры, такие, как `hard`, `soft` или `bg`.

Пример системы FreeBSD (`freebox`) как клиента в файле [.filename]#/etc/fstab# на машине `freebox`:

[.programlisting]
....
fastws:/sharedfs /project nfs rw,-r=1024 0 0
....

Команда, выдаваемая вручную на машине `freebox`:

[source,bash]
....
# mount -t nfs -o -r=1024 fastws:/sharedfs /project
....

Пример системы FreeBSD в качестве сервера в файле [.filename]#/etc/fstab# на машине `fastws`:

[.programlisting]
....
freebox:/sharedfs /project nfs rw,-w=1024 0 0
....

Команда, выдаваемая вручную на машине `fastws`:

[source,bash]
....
# mount -t nfs -o -w=1024 freebox:/sharedfs /project
....

Практически все 16-разрядные сетевые адаптеры позволят работать без указанных выше ограничений на размер блоков при чтении и записи.

Для тех, кто интересуется, ниже описывается, что же происходит в при появлении этой ошибки, и объясняется, почему ее невозможно устранить. Как правило, NFS работает с "блоками" размером 8 килобайт (хотя отдельные фрагменты могут иметь меньшие размеры). Так, пакет Ethernet имеет максимальный размер около 1500 байт, то "блок" NFS разбивается на несколько пакетов Ethernet, хотя на более высоком уровне это все тот же единый блок, который должен быть принят, собран и _подтвержден_ как один блок. Высокопроизводительные рабочие станции могут посылать пакеты, которые соответствуют одному блоку NFS, сразу друг за другом, насколько это позволяет делать стандарт. На слабых, низкопроизводительных адаптерах пакеты, пришедшие позже, накладываются поверх ранее пришедших пакетов того же самого блока до того, как они могут быть переданы хосту и блок как единое целое не может быть собран или подтвержден. В результате рабочая станция входит в ситуацию тайм-аута и пытается повторить передачу, но уже с полным блоком в 8 КБ, и процесс будет повторяться снова, до бесконечности.

Задав размер блока меньше размера пакета Ethernet, мы достигаем того, что любой полностью полученный пакет Ethernet может быть подтвержден индивидуально, и избежим тупиковую ситуацию.

Наложение пакетов может все еще проявляться, когда высокопроизводительные рабочие станции сбрасывают данные на PC-систему, однако повторение этой ситуации не обязательно с более скоростными адаптерами с "блоками" NFS. Когда происходит наложение, затронутые блоки будут переданы снова, и скорее всего, они будут получены, собраны и подтверждены.

[[network-nis]]
== Network Information System (NIS/YP)

=== Что это такое?

NIS, что является сокращением от Network Information Services (Сетевые Информационные Службы), которые были разработаны компанией Sun Microsystems для централизованного администрирования систем UNIX(R) (изначально SunOS(TM)). В настоящее время эти службы практически стали промышленным стандартом; все основные UNIX(R)-подобные системы (Solaris(TM), HP-UX, AIX(R), Linux, NetBSD, OpenBSD, FreeBSD и так далее) поддерживают NIS.

NIS первоначально назывались Yellow Pages (или yp), но из-за проблем с торговым знаком Sun изменила это название. Старое название (и yp) всё ещё часто употребляется.

Это система клиент/сервер на основе вызовов RPC, которая позволяет группе машин в одном домене NIS совместно использовать общий набор конфигурационных файлов. Системный администратор может настроить клиентскую систему NIS только с минимальной настроечной информацией, а затем добавлять, удалять и модифицировать настроечную информацию из одного места.

Это похоже на систему доменов Windows NT(R); хотя их внутренние реализации не так уж и похожи, основные функции сравнимы.

=== Термины/программы, о которых вы должны знать

Существует несколько терминов и некоторое количество пользовательских программ, которые будут нужны, когда вы будете пытаться сделать NIS во FreeBSD, и в случае создания сервера, и в случае работы в качестве клиента NIS:

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Термин
| Описание

|Имя домена NIS
|Главный сервер NIS и все его клиенты (включая вторичные серверы), имеют доменное имя NIS. Как и в случае с именем домена Windows NT(R), имя домена NIS не имеет ничего общего с DNS.

|rpcbind
|Для обеспечения работы RPC (Remote Procedure Call, Удалённого Вызова Процедур, сетевого протокола, используемого NIS), должен быть запущен даемон rpcbind. Если даемон rpcbind не запущен, невозможно будет запустить сервер NIS, или работать как NIS-клиент.

|ypbind
|"Связывает" NIS-клиента с его NIS-сервером. Он определяет имя NIS-домена системы, и при помощи RPC подключается к серверу. ypbind является основой клиент-серверного взаимодействия в среде NIS; если на клиентской машине программа ypbind перестанет работать, то эта машина не сможет получить доступ к серверу NIS.

|ypserv
|Программа `ypserv`, которая должна запускаться только на серверах NIS: это и есть сервер NIS. Если man:ypserv[8] перестанет работать, то сервер не сможет отвечать на запросы NIS (к счастью, на этот случай предусмотрен вторичный сервер). Есть несколько реализаций NIS (к FreeBSD это не относится), в которых не производится попыток подключиться к другому серверу, если ранее используемый сервер перестал работать. Зачастую единственным средством, помогающим в этой ситуации, является перезапуск серверного процесса (или сервера полностью) или процесса ypbind на клиентской машине.

|rpc.yppasswdd
|Программа `rpc.yppasswdd`, другой процесс, который запускается только на главных NIS-серверах: это даемон, позволяющий клиентам NIS изменять свои пароли NIS. Если этот даемон не запущен, то пользователи должны будут входить на основной сервер NIS и там менять свои пароли.
|===

=== Как это работает?

В системе NIS существует три типа хостов: основные (master) серверы, вторичные (slave) серверы и клиентские машины. Серверы выполняют роль централизованного хранилища информации о конфигурации хостов. Основные серверы хранят оригиналы этой информации, когда как вторичные серверы хранят ее копию для обеспечения избыточности. Клиенты связываются с серверами, чтобы предоставить им эту информацию.

Информация во многих файлах может совместно использоваться следующим образом. Файлы [.filename]#master.passwd#, [.filename]#group# и [.filename]#hosts# используются совместно через NIS. Когда процессу, работающему на клиентской машине, требуется информация, как правило, находящаяся в этих файлах локально, то он делает запрос к серверу NIS, с которым связан.

==== Типы машин

* _Основной сервер NIS_. Такой сервер, по аналогии с первичным контроллером домена Windows NT(R), хранит файлы, используемые всеми клиентами NIS. Файлы [.filename]#passwd#, [.filename]#group# и различные другие файлы, используемые клиентами NIS, находятся на основном сервере.
+
[NOTE]
====
Возможно использование одной машины в качестве сервера для более чем одного домена NIS. Однако, в этом введении такая ситуация не рассматривается, и предполагается менее масштабное использование NIS.
====

* _Вторичные серверы NIS_. Похожие на вторичные контроллеры доменов Windows NT(R), вторичные серверы NIS содержат копии оригинальных файлов данных NIS. Вторичные серверы NIS обеспечивают избыточность, что нужно в критичных приложениях. Они также помогают распределять нагрузку на основной сервер: клиенты NIS всегда подключаются к тому серверу NIS, который ответил первым, в том числе и к вторичным серверам.
* _Клиенты NIS_. Клиенты NIS, как и большинство рабочих станций Windows NT(R), аутентифицируются на сервере NIS (или на контроллере домена Windows NT(R) для рабочих станций Windows NT(R)) во время входа в систему.

=== Использование NIS/YP

В этом разделе приводится пример настройки NIS.

==== Планирование

Давайте предположим, что вы являетесь администратором в маленькой университетской лаборатории. В настоящий момент в этой лаборатории с 15 машинами отсутствует единая точка администрирования; на каждой машине имеются собственные файлы [.filename]#/etc/passwd# и [.filename]#/etc/master.passwd#. Эти файлы синхронизируются друг с другом только вручную; сейчас, когда вы добавляете пользователя в лаборатории, вы должны выполнить команду `adduser` на всех 15 машинах. Понятно, что такое положение вещей нужно исправлять, так что вы решили перевести сеть на использование NIS, используя две машины в качестве серверов.

Итак, конфигурация лаборатории сейчас выглядит примерно так:

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Имя машины
| IP-адрес
| Роль машины

|`ellington`
|`10.0.0.2`
|Основной сервер NIS

|`coltrane`
|`10.0.0.3`
|Вторичный сервер NIS

|`basie`
|`10.0.0.4`
|Факультетская рабочая станция

|`bird`
|`10.0.0.5`
|Клиентская машина

|`cli[1-11]`
|`10.0.0.[6-17]`
|Другие клиентские машины
|===

Если вы определяете схему NIS первый раз, ее нужно хорошо обдумать. Вне зависимости от размеров вашей сети, есть несколько ключевых моментов, которые требуют принятия решений.

===== Выбор имени домена NIS

Это имя не должно быть "именем домена", которое вы использовали. Более точно это имя называется "именем домена NIS". Когда клиент рассылает запросы на получение информации, он включает в них имя домена NIS, частью которого является. Таким способом многие сервера в сети могут указать, какой сервер на какой запрос должен отвечать. Думайте о домене NIS как об имени группы хостов, которые каким-то образом связаны.

Некоторые организации в качестве имени домена NIS используют свой домен Интернет. Это не рекомендуется, так как может вызвать проблемы в процессе решения сетевых проблем. Имя домена NIS должно быть уникальным в пределах вашей сети и хорошо, если оно будет описывать группу машин, которые представляет. Например, художественный отдел в компании Acme Inc. может находиться в домене NIS с именем "acme-art". В нашем примере положим, что мы выбрали имя `test-domain`.

Несмотря на это, некоторые операционные системы (в частности, SunOS(TM)) используют свое имя домена NIS в качестве имени домена Интернет. Если одна или более машин в вашей сети имеют такие ограничения, вы _обязаны_ использовать имя домена Интернет в качестве имени домена NIS.

===== Требования к серверу

Есть несколько вещей, которые нужно иметь в виду при выборе машины для использования в качестве сервера NIS. Одной из обескураживающей вещью, касающейся NIS, является уровень зависимости клиентов от серверов. Если клиент не может подключиться к серверу своего домена NIS, зачастую машину просто становится нельзя использовать. Отсутствие информации о пользователях и группах приводит к временной остановке работы большинства систем. Зная это, вы должны выбрать машину, которая не должна подвергаться частым перезагрузкам и не используется для разработки. Сервер NIS в идеале должен быть отдельно стоящей машиной, единственным целью в жизни которой является быть сервером NIS. Если вы работаете в сети, которая не так уж сильно загружена, то можно поместить сервер NIS на машине, на которой запущены и другие сервисы, просто имейте в виду, что если сервер NIS становится недоступным, то это негативно отражается на _всех_ клиентах NIS.

==== Серверы NIS

Оригинальные копии всей информации NIS хранится на единственной машине, которая называется главным сервером NIS. Базы данных, которые используются для хранения информации, называются картами NIS. Во FreeBSD эти карты хранятся в [.filename]#/var/yp/[domainname]#, где [.filename]#[domainname]# является именем обслуживаемого домена NIS. Один сервер NIS может поддерживать одновременно несколько доменов, так что есть возможность иметь несколько таких каталогов, по одному на каждый обслуживаемый домен. Каждый домен будет иметь свой собственный независимый от других набор карт.

Основной и вторичный серверы обслуживают все запросы NIS с помощью даемона `ypserv`. `ypserv` отвечает за получение входящих запросов от клиентов NIS, распознавание запрашиваемого домена и отображение имени в путь к соответствующему файлы базы данных, а также передаче информации из базы данных обратно клиенту.

===== Настройка основного сервера NIS

Настройка основного сервера NIS может оказаться сравнительно простой, в зависимости от ваших потребностей. В поставку FreeBSD сразу включена поддержка NIS. Все, что вам нужно, это добавить следующие строки в файл [.filename]#/etc/rc.conf#, а FreeBSD сделает за вас всё остальное..

[.procedure]
====
[.programlisting]
....
nisdomainname="test-domain"
....
. В этой строке задается имя домена NIS, которое будет `test-domain`, еще до настройки сети (например, после перезагрузки).
+
[.programlisting]
....
nis_server_enable="YES"
....
. Здесь указывается FreeBSD на запуск процессов серверов NIS, когда дело доходит до сетевых настроек.
+
[.programlisting]
....
nis_yppasswdd_enable="YES"
....
. Здесь указывается на запуск даемона `rpc.yppasswdd`, который, как это отмечено выше, позволит пользователям менять свой пароль NIS с клиентской машины.
====

[NOTE]
====
В зависимости от ваших настроек NIS, вам могут понадобиться дополнительные строки. Обратитесь к <<network-nis-server-is-client,"разделу о серверах NIS, которые являются и клиентами NIS">> ниже для получения подробной информации.
====

После добавления вышеприведенных строк, запустите команду `/etc/netstart`, работая как администратор. По ней произойдет настройка всего, при этом будут использоваться значения, заданные в файле [.filename]#/etc/rc.conf#. И наконец, перед инициализацией карт NIS, запустите вручную демон ypserv:

[source,bash]
....
# /etc/rc.d/ypserv start
....

===== Инициализация карт NIS

_Карты NIS_ являются файлами баз данных, которые хранятся в каталоге [.filename]#/var/yp#. Они генерируются из конфигурационных файлов, находящихся в каталоге [.filename]#/etc# основного сервера NIS, за одним исключением: файл [.filename]#/etc/master.passwd#. На это есть весомая причина, вам не нужно распространять пароли пользователя `root` и других административных пользователей на все серверы в домене NIS. По этой причине, прежде чем инициализировать карты NIS, вы должны сделать вот что:

[source,bash]
....
# cp /etc/master.passwd /var/yp/master.passwd
# cd /var/yp
# vi master.passwd
....

Вы должны удалить все записи, касающиеся системных пользователей (`bin`, `tty`, `kmem`, `games` и так далее), а также записи, которые вы не хотите распространять клиентам NIS (например, `root` и другие пользователи с UID, равным 0 (администраторы)).

[NOTE]
====
Проверьте, чтобы файл [.filename]#/var/yp/master.passwd# был недоступен для записи ни для группы, ни для остальных пользователей (режим доступа 600)! Воспользуйтесь командой `chmod`, если это нужно.
====

Когда с этим будет покончено, самое время инициализировать карты NIS! В поставку FreeBSD включен скрипт с именем `ypinit`, который делает это (обратитесь к его справочной странице за дополнительной информацией). Отметьте, что этот скрипт имеется в большинстве операционных систем UNIX(R), но не во всех. В системе Digital Unix/Compaq Tru64 UNIX он называется `ypsetup`. Так как мы генерируем карты для главного сервера NIS, то при вызове программы `ypinit` мы передаем ей параметр `-m`. Для генерации карт NIS в предположении, что вы уже сделали шаги, описанные выше, выполните следующее:

[source,bash]
....
ellington# ypinit -m test-domain
Server Type: MASTER Domain: test-domain
Creating an YP server will require that you answer a few questions.
Questions will all be asked at the beginning of the procedure.
Do you want this procedure to quit on non-fatal errors? [y/n: n] n
Ok, please remember to go back and redo manually whatever fails.
If you don't, something might not work.
At this point, we have to construct a list of this domains YP servers.
rod.darktech.org is already known as master server.
Please continue to add any slave servers, one per line. When you are
done with the list, type a <control D>.
master server	:  ellington
next host to add:  coltrane
next host to add:  ^D
The current list of NIS servers looks like this:
ellington
coltrane
Is this correct?  [y/n: y] y

[..вывод при генерации карт..]

NIS Map update completed.
ellington has been setup as an YP master server without any errors.
....

Программа `ypinit` должна была создать файл [.filename]#/var/yp/Makefile# из [.filename]#/var/yp/Makefile.dist#. При создании этого файла предполагается, что вы работаете в окружении с единственным сервером NIS и только с машинами FreeBSD. Так как в домене `test-domain` имеется также и вторичный сервер, то вы должны отредактировать файл [.filename]#/var/yp/Makefile#:

[source,bash]
....
ellington# vi /var/yp/Makefile
....

Вы должны закомментировать строку, в которой указано

[.programlisting]
....
NOPUSH = "True"
....

(она уже не раскомментирована).

===== Настройка вторичного сервера NIS

Настройка вторичного сервера NIS осуществляется ещё проще, чем настройка главного сервера. Войдите на вторичный сервер и отредактируйте файл [.filename]#/etc/rc.conf# точно также, как вы делали это ранее. Единственным отличием является то, что при запуске программы `ypinit` мы теперь должны использовать опцию `-s`. Применение опции `-s` требует также указание имени главного сервера NIS, так что наша команда должна выглядеть так:

[source,bash]
....
coltrane# ypinit -s ellington test-domain

Server Type: SLAVE Domain: test-domain Master: ellington

Creating an YP server will require that you answer a few questions.
Questions will all be asked at the beginning of the procedure.

Do you want this procedure to quit on non-fatal errors? [y/n: n]  n

Ok, please remember to go back and redo manually whatever fails.
If you don't, something might not work.
There will be no further questions. The remainder of the procedure
should take a few minutes, to copy the databases from ellington.
Transferring netgroup...
ypxfr: Exiting: Map successfully transferred
Transferring netgroup.byuser...
ypxfr: Exiting: Map successfully transferred
Transferring netgroup.byhost...
ypxfr: Exiting: Map successfully transferred
Transferring master.passwd.byuid...
ypxfr: Exiting: Map successfully transferred
Transferring passwd.byuid...
ypxfr: Exiting: Map successfully transferred
Transferring passwd.byname...
ypxfr: Exiting: Map successfully transferred
Transferring group.bygid...
ypxfr: Exiting: Map successfully transferred
Transferring group.byname...
ypxfr: Exiting: Map successfully transferred
Transferring services.byname...
ypxfr: Exiting: Map successfully transferred
Transferring rpc.bynumber...
ypxfr: Exiting: Map successfully transferred
Transferring rpc.byname...
ypxfr: Exiting: Map successfully transferred
Transferring protocols.byname...
ypxfr: Exiting: Map successfully transferred
Transferring master.passwd.byname...
ypxfr: Exiting: Map successfully transferred
Transferring networks.byname...
ypxfr: Exiting: Map successfully transferred
Transferring networks.byaddr...
ypxfr: Exiting: Map successfully transferred
Transferring netid.byname...
ypxfr: Exiting: Map successfully transferred
Transferring hosts.byaddr...
ypxfr: Exiting: Map successfully transferred
Transferring protocols.bynumber...
ypxfr: Exiting: Map successfully transferred
Transferring ypservers...
ypxfr: Exiting: Map successfully transferred
Transferring hosts.byname...
ypxfr: Exiting: Map successfully transferred

coltrane has been setup as an YP slave server without any errors.
Don't forget to update map ypservers on ellington.
....

Теперь у вас должен быть каталог с именем [.filename]#/var/yp/test-domain#. Копии карт главного сервера NIS должны быть в этом каталоге. Вы должны удостовериться, что этот каталог обновляется. Следующие строки в [.filename]#/etc/crontab# вашего вторичного сервера должны это делать:

[.programlisting]
....
20	*	*	*	*	root   /usr/libexec/ypxfr passwd.byname
21	*	*	*	*	root   /usr/libexec/ypxfr passwd.byuid
....

Эти две строки заставляют вторичный сервер синхронизировать свои карты с картами главного сервера. Эти строки не являются обязательными, так как главный сервер автоматически пытается передать вторичным серверам все изменения в своих картах NIS. Однако, учитывая важность информации о паролях для клиентов, зависящих от вторичного сервера, рекомендуется выполнять частые обновления карт с паролями. Это особенно важно в загруженных сетях, в которых обновления карт могут не всегда завершаться успешно.

А теперь точно также запустите команду `/etc/netstart` на вторичном сервере, по которой снова выполнится запуск сервера NIS.

==== Клиенты NIS

Клиент NIS выполняет так называемую привязку к конкретному серверу NIS при помощи даемона `ypbind`. `ypbind` определяет домен, используемый в системе по умолчанию (тот, который устанавливается по команде `domainname`), и начинает широковещательную рассылку запросов RPC в локальной сети. В этих запросах указано имя домена, к серверу которого `ypbind` пытается осуществить привязку. Если сервер, который был настроен для обслуживания запрашиваемого домена, получит широковещательный запрос, он ответит `ypbind`, который, в свою очередь запомнит адрес сервера. Если имеется несколько серверов (например, главный и несколько вторичных), то `ypbind` будет использовать адрес первого ответившего. С этого момента клиентская система будет направлять все свои запросы NIS на этот сервер. Время от времени `ypbind` будет "пинать" сервер для проверки его работоспособности. Если на один из тестовых пакетов не удастся получить ответа за разумное время, то `ypbind` пометит этот домен как домен, с которым связка разорвана, и снова начнет процесс посылки широковещательных запросов в надежде найти другой сервер.

===== Настройка клиента NIS

Настройка машины с FreeBSD в качестве клиента NIS достаточно проста.

[.procedure]
====

. Отредактируйте файл [.filename]#/etc/rc.conf#, добавив туда следующие строки для того, чтобы задать имя домена NIS и запустить `ypbind` во время запуска сетевых служб:
+
[.programlisting]
....
nisdomainname="test-domain"
nis_client_enable="YES"
....
+
. Для импортирования всех возможных учётных записей от сервера NIS, удалите все записи пользователей из вашего файла [.filename]#/etc/master.passwd# и воспользуйтесь командой `vipw` для добавления следующей строки в конец файла:
+
[.programlisting]
....
+:::::::::
....
+
[NOTE]
======
Эта строчка даст всем пользователям с корректной учетной записью в картах учетных баз пользователей доступ к этой системе. Есть множество способов настроить ваш клиент NIS, изменив эту строку. Посмотрите ниже текст, касающийся <<network-netgroups,сетевых групп>>, чтобы получить более подробную информацию. Дополнительная информация для изучения находится в книге издательства O'Reilly под названием `Managing NFS and NIS`.
======
+
[NOTE]
======
Вы должны оставить хотя бы одну локальную запись (то есть не импортировать ее через NIS) в вашем [.filename]#/etc/master.passwd# и эта запись должна быть также членом группы `wheel`. Если с NIS что-то случится, эта запись может использоваться для удаленного входа в систему, перехода в режим администратора и исправления неисправностей.
======
+
. Для импортирования всех возможных записей о группах с сервера NIS, добавьте в ваш файл [.filename]#/etc/group# такую строчку:
+
[.programlisting]
....
+:*::
....
====

Для немедленного запуска клиента NIS выполните следующую команду с правами пользователя `root`:

[source,bash]
....
# /etc/netstart
# /etc/rc.d/ypbind start
....

После завершения выполнения этих шагов у вас должно получиться запустить команду `ypcat passwd` и увидеть карту учетных записей сервера NIS.

=== Безопасность NIS

В общем-то любой пользователь, зная имя вашего домена, может выполнить запрос RPC к man:ypserv[8] и получить содержимое ваших карт NIS. Для предотвращения такого неавторизованного обмена man:ypserv[8] поддерживает так называемую систему "securenets", которая может использоваться для ограничения доступа к некоторой группе хостов. При запуске man:ypserv[8] будет пытаться загрузить информацию, касающуюся securenets, из файла [.filename]#/var/yp/securenets#.

[NOTE]
====
Имя каталога зависит от параметра, указанного вместе с опцией `-p`. Этот файл содержит записи, состоящие из указания сети и сетевой маски, разделенных пробелом. Строчки, начинающиеся со знака "#", считаются комментариями. Примерный файл securenets может иметь примерно такой вид:
====

[.programlisting]
....
# allow connections from local host -- mandatory
127.0.0.1     255.255.255.255
# allow connections from any host
# on the 192.168.128.0 network
192.168.128.0 255.255.255.0
# allow connections from any host
# between 10.0.0.0 to 10.0.15.255
# this includes the machines in the testlab
10.0.0.0      255.255.240.0
....

Если man:ypserv[8] получает запрос от адреса, который соответствует одному из этих правил, он будет отрабатывать запрос обычным образом. Если же адрес не подпадает ни под одно правило, запрос будет проигнорирован и в журнал будет записано предупреждающее сообщение. Если файл [.filename]#/var/yp/securenets# не существует, `ypserv` будет обслуживать соединения от любого хоста.

Программа `ypserv` также поддерживает пакет программ TCP Wrapper от Wietse Venema. Это позволяет администратору для ограничения доступа вместо [.filename]#/var/yp/securenets# использовать конфигурационные файлы TCP Wrapper.

[NOTE]
====
Хотя оба этих метода управления доступом обеспечивают некоторую безопасность, они, как основанные на проверке привилегированного порта, оба подвержены атакам типа "IP spoofing". Весь сетевой трафик, связанный с работой NIS, должен блокироваться вашим брандмауэром.

Серверы, использующие файл [.filename]#/var/yp/securenets#, могут быть не в состоянии обслуживать старых клиентов NIS с древней реализацией протокола TCP/IP. Некоторые из этих реализаций при рассылке широковещательных запросов устанавливают все биты машинной части адреса в ноль и/или не в состоянии определить маску подсети при вычислении адреса широковещательной рассылки. Хотя некоторые из этих проблем могут быть решены изменением конфигурации клиента, другие могут привести к отказу от использования [.filename]#/var/yp/securenets#.

Использование [.filename]#/var/yp/securenets# на сервере с такой архаичной реализацией TCP/IP является весьма плохой идеей, и приведёт к потере работоспособности NIS в большой части вашей сети.

Использование пакета TCP Wrapper увеличит время отклика вашего сервера NIS. Дополнительной задержки может оказаться достаточно для возникновения тайм-аутов в клиентских программах, особенно в загруженных сетях или с медленными серверами NIS. Если одна или более ваших клиентских систем страдают от таких проблем, вы должны преобразовать такие клиентские системы во вторичные серверы NIS и сделать принудительную их привязку к самим себе.
====

=== Запрет входа некоторых пользователей

В нашей лаборатории есть машина `basie`, о которой предполагается, что она является исключительно факультетской рабочей станцией. Мы не хотим исключать эту машину из домена NIS, однако файл [.filename]#passwd# на главном сервере NIS содержит учетные записи как для работников факультета, так и студентов. Что мы можем сделать?

Есть способ ограничить вход некоторых пользователей на этой машине, даже если они присутствуют в базе данных NIS. Чтобы это сделать, вам достаточно добавить `-_username_` в конец файла [.filename]#/etc/master.passwd# на клиентской машине, где _username_ является именем пользователя, которому вы хотите запретить вход. Рекомендуется сделать это с помощью утилиты `vipw`, так как `vipw` проверит ваши изменения в [.filename]#/etc/master.passwd#, а также автоматически перестроит базу данных паролей по окончании редактирования. Например, если мы хотим запретить пользователю `bill` осуществлять вход на машине `basie`, то мы сделаем следующее:

[source,bash]
....
basie# vipw
[add -bill to the end, exit]
vipw: rebuilding the database...
vipw: done

basie# cat /etc/master.passwd

root:[password]:0:0::0:0:The super-user:/root:/bin/csh
toor:[password]:0:0::0:0:The other super-user:/root:/bin/sh
daemon:*:1:1::0:0:Owner of many system processes:/root:/sbin/nologin
operator:*:2:5::0:0:System &:/:/sbin/nologin
bin:*:3:7::0:0:Binaries Commands and Source,,,:/:/sbin/nologin
tty:*:4:65533::0:0:Tty Sandbox:/:/sbin/nologin
kmem:*:5:65533::0:0:KMem Sandbox:/:/sbin/nologin
games:*:7:13::0:0:Games pseudo-user:/usr/games:/sbin/nologin
news:*:8:8::0:0:News Subsystem:/:/sbin/nologin
man:*:9:9::0:0:Mister Man Pages:/usr/shared/man:/sbin/nologin
bind:*:53:53::0:0:Bind Sandbox:/:/sbin/nologin
uucp:*:66:66::0:0:UUCP pseudo-user:/var/spool/uucppublic:/usr/libexec/uucp/uucico
xten:*:67:67::0:0:X-10 daemon:/usr/local/xten:/sbin/nologin
pop:*:68:6::0:0:Post Office Owner:/nonexistent:/sbin/nologin
nobody:*:65534:65534::0:0:Unprivileged user:/nonexistent:/sbin/nologin
+:::::::::
-bill

basie#
....

[[network-netgroups]]
=== Использование сетевых групп

Способ, описанный в предыдущем разделе, работает достаточно хорошо, если вам нужны особые правила для очень малой группы пользователей или машин. В более крупных сетях вы _забудете_ о запрете входа определенных пользователей на важные машины или даже будете настраивать каждую машину по отдельности, теряя таким образом главное преимущество использования NIS: _централизованное_ администрирование.

Ответом разработчиков NIS на эту проблему являются _сетевые группы_. Их назначение и смысл можно сравнить с обычными группами, используемыми в файловых системах UNIX(R). Главное отличие заключается в отсутствии числового идентификатора и возможности задать сетевую группу включением как пользователей, так и других сетевых групп.

Сетевые группы были разработаны для работы с большими, сложными сетями с сотнями пользователей и машин. С одной стороны, хорошо, если вам приходится с такой ситуацией. С другой стороны, эта сложность делает невозможным описание сетевых групп с помощью простых примеров. Пример, используемый в дальнейшем, демонстрирует эту проблему.

Давайте предположим, что успешное внедрение системы NIS в вашей лаборатории заинтересовало ваше руководство. Вашим следующим заданием стало расширение домена NIS для включения в него некоторых других машин студенческого городка. В двух таблицах перечислены имена новых машин и пользователей, а также их краткое описание.

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Имена пользователей
| Описание

|`alpha`, `beta`
|Обычные служащие IT-департамента

|`charlie`, `delta`
|Практиканты IT-департамента

|`echo`, `foxtrott`, `golf`, ...
|Обычные сотрудники

|`able`, `baker`, ...
|Проходящие интернатуру
|===

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Имена машин
| Описание

|`war`, `death`, `famine`, `pollution`
|Ваши самые важные серверы. Только служащим IT позволяется входить на эти машины.

|`pride`, `greed`, `envy`, `wrath`, `lust`, `sloth`
|Менее важные серверы. Все сотрудники департамента IT могут входить на эти машины.

|`one`, `two`, `three`, `four`, ...
|Обычные рабочие станции. Только _реально нанятым_ служащим позволяется использовать эти машины.

|`trashcan`
|Очень старая машина без каких-либо критичных данных. Даже проходящим интернатуру разрешено ее использовать.
|===

Если вы попытаетесь реализовать эти требования, ограничивая каждого пользователя по отдельности, то вам придется добавить на каждой машине в файл [.filename]#passwd# по одной строчке `-_user_` для каждого пользователя, которому запрещено входить на эту систему. Если вы забудете даже одну строчку, у вас могут начаться проблемы. Гораздо проще делать это правильно во время начальной установки, однако вы постепенно _будете забывать_ добавлять строчки для новых пользователей во время повседневной работы. В конце концов, Мерфи был оптимистом.

Использование в этой ситуации сетевых групп дает несколько преимуществ. Нет необходимости описывать по отдельности каждого пользователя; вы ставите в соответствие пользователю одну или несколько сетевых групп и разрешаете или запрещаете вход всем членам сетевой группы. Если вы добавляете новую машину, вам достаточно определить ограничения на вход для сетевых групп. Если добавляется новый пользователь, вам достаточно добавить его к одной или большему числу сетевых групп. Эти изменения независимы друг от друга: нет больше комбинаций "для каждого пользователя и машины". Если настройка вашей системы NIS тщательно спланирована, то для разрешения или запрещения доступа к машинам вам нужно будет модифицировать единственный конфигурационный файл.

Первым шагом является инициализация карты NIS по имени netgroup. Программа man:ypinit[8] во FreeBSD по умолчанию этой карты не создаёт, хотя реализация NIS будет её поддерживает, как только она будет создана. Чтобы создать пустую карту, просто наберите

[source,bash]
....
ellington# vi /var/yp/netgroup
....

и начните добавлять содержимое. Например, нам нужно по крайней мере четыре сетевых группы: сотрудники IT, практиканты IT, обычные сотрудники и интернатура.

[.programlisting]
....
IT_EMP	(,alpha,test-domain)	(,beta,test-domain)
IT_APP	(,charlie,test-domain)	(,delta,test-domain)
USERS	(,echo,test-domain)	(,foxtrott,test-domain) \
	(,golf,test-domain)
INTERNS (,able,test-domain)	(,baker,test-domain)
....

`IT_EMP`, `IT_APP` и так далее являются именами сетевых групп. Несколько слов в скобках служат для добавления пользователей в группу. Три поля внутри группы обозначают следующее:

. Имя хоста или хостов, к которым применимы последующие записи. Если имя хоста не указано, то запись применяется ко всем хостам. Если же указывается имя хоста, то вы получите мир темноты, ужаса и страшной путаницы.
. Имя учетной записи, которая принадлежит этой сетевой группе.
. Домен NIS для учетной записи. Вы можете импортировать в вашу сетевую группу учетные записи из других доменов NIS, если вы один из тех несчастных, имеющих более одного домена NIS.

Каждое из этих полей может содержать шаблоны, подробности даны в странице справочника по man:netgroup[5].

[NOTE]
====
Не нужно использовать имена сетевых групп длиннее 8 символов, особенно если в вашем домене NIS имеются машины, работающие под управлением других операционных систем. Имена чувствительны к регистру; использование заглавных букв для имен сетевых групп облегчает распознавание пользователей, имен машин и сетевых групп.

Некоторые клиенты NIS (отличные от FreeBSD) не могут работать с сетевыми группами, включающими большое количество записей. Например, в некоторых старых версиях SunOS(TM) возникают проблемы, если сетевая группа содержит более 15 _записей_. Вы можете обойти это ограничение, создав несколько подгрупп с 15 или меньшим количеством пользователей и настоящую сетевую группу, состоящую из подгрупп:

[.programlisting]
....
BIGGRP1  (,joe1,domain)  (,joe2,domain)  (,joe3,domain) [...]
BIGGRP2  (,joe16,domain)  (,joe17,domain) [...]
BIGGRP3  (,joe31,domain)  (,joe32,domain)
BIGGROUP  BIGGRP1 BIGGRP2 BIGGRP3
....

Вы можете повторить этот процесс, если вам нужно иметь более 225 пользователей в одной сетевой группе.
====

Активация и распространение вашей карты NIS проста:

[source,bash]
....
ellington# cd /var/yp
ellington# make
....

Это приведет к созданию трех карт NIS [.filename]#netgroup#, [.filename]#netgroup.byhost# и [.filename]#netgroup.byuser#. Воспользуйтесь утилитой man:ypcat[1] для проверки доступности ваших новых карт NIS:

[source,bash]
....
ellington% ypcat -k netgroup
ellington% ypcat -k netgroup.byhost
ellington% ypcat -k netgroup.byuser
....

Вывод первой команды должен соответствовать содержимому файла [.filename]#/var/yp/netgroup#. Вторая команда не выведет ничего, если вы не зададите сетевые группы, специфичные для хоста. Третья команда может использоваться пользователем для получения списка сетевых групп.

Настройка клиента достаточно проста. Чтобы настроить сервер `war`, вам достаточно запустить man:vipw[8] и заменить строку

[.programlisting]
....
+:::::::::
....

на

[.programlisting]
....
+@IT_EMP:::::::::
....

Теперь только данные, касающиеся пользователей, определенных в сетевой группе `IT_EMP`, импортируются в базу паролей машины `war` и только этим пользователям будет разрешен вход.

К сожалению, это ограничение также касается и функции `~` командного процессора и всех подпрограмм, выполняющих преобразование между именами пользователей и их числовыми ID. Другими словами, команда `cd ~_user_` работать не будет, команда `ls -l` будет выдавать числовые идентификаторы вместо имён пользователей, а `find . -user joe -print` работать откажется, выдавая сообщение `No such user`. Чтобы это исправить, вам нужно будет выполнить импорт всех записей о пользователях _без разрешения на вход на ваши серверы_.

Это можно сделать, добавив еще одну строку в файл [.filename]#/etc/master.passwd#. Эта строка должна содержать:

`+:::::::::/sbin/nologin`, что означает "Произвести импортирование всех записей с заменой командного процессора на [.filename]#/sbin/nologin# в импортируемых записях". Вы можете заменить любое поле в строке с паролем, указав значение по умолчанию в вашем [.filename]#/etc/master.passwd#.

[WARNING]
====

Проверьте, что строка `+:::::::::/sbin/nologin` помещена после `+@IT_EMP:::::::::`. В противном случае все пользовательские записи, импортированные из NIS, будут иметь [.filename]#/sbin/nologin# в качестве оболочки.
====

После этого изменения при появлении нового сотрудника IT вам будет достаточно изменять только одну карту NIS. Вы можете применить подобный метод для менее важных серверов, заменяя старую строку `+:::::::::` в их файлах [.filename]#/etc/master.passwd# на нечто, подобное следующему:

[.programlisting]
....
+@IT_EMP:::::::::
+@IT_APP:::::::::
+:::::::::/sbin/nologin
....

Соответствующие строки для обычных рабочих станций могут иметь такой вид:

[.programlisting]
....
+@IT_EMP:::::::::
+@USERS:::::::::
+:::::::::/sbin/nologin
....

И все было прекрасно до того момента, когда через несколько недель изменилась политика: Департамент IT начал нанимать интернатуру. Интернатуре в IT позволили использовать обычные рабочие станции и менее важные серверы; практикантам позволили входить на главные серверы. Вы создали новую сетевую группу `IT_INTERN`, добавили в нее новую интернатуру и начали изменять настройки на всех и каждой машине... Как говорит старая мудрость: "Ошибки в централизованном планировании приводят к глобальному хаосу".

Возможность в NIS создавать сетевые группы из других сетевых групп может использоваться для предотвращения подобных ситуаций. Одним из вариантов является создание сетевых групп на основе ролей. Например, вы можете создать сетевую группу с именем `BIGSRV` для задания ограничений на вход на важные серверы, другую сетевую группу с именем `SMALLSRV` для менее важных серверов и третью сетевую группу под названием `USERBOX` для обычных рабочих станций. Каждая из этих сетевых групп содержит сетевые группы, которым позволено входить на эти машины. Новые записи для вашей карты NIS сетевой группы должны выглядеть таким образом:

[.programlisting]
....
BIGSRV	  IT_EMP  IT_APP
SMALLSRV  IT_EMP  IT_APP  ITINTERN
USERBOX   IT_EMP  ITINTERN USERS
....

Этот метод задания ограничений на вход работает весьма хорошо, если вы можете выделить группы машин с одинаковыми ограничениями. К сожалению, такая ситуация может быть исключением, но не правилом. В большинстве случаев вам нужна возможность определять ограничения на вход индивидуально для каждой машины.

Задание сетевых групп в зависимости от машин является другой возможностью, которой можно воспользоваться при изменении политики, описанной выше. При таком развитии событий файл [.filename]#/etc/master.passwd# на каждой машине содержит две строки, начинающиеся с "+". Первая из них добавляет сетевую группу с учётными записями, которым разрешено входить на эту машину, а вторая добавляет все оставшиеся учетные записи с [.filename]#/sbin/nologin# в качестве командного процессора. Хорошей идеей является использование "ИМЕНИ МАШИНЫ" заглавными буквами для имени сетевой группы. Другими словами, строки должны иметь такой вид:

[.programlisting]
....
+@BOXNAME:::::::::
+:::::::::/sbin/nologin
....

Как только вы завершите эту работу для всех ваших машин, вам не нужно будет снова модифицировать локальные версии [.filename]#/etc/master.passwd#. Все будущие изменения могут быть выполнены изменением карты NIS. Вот пример возможной карты сетевой группы для этого случая с некоторыми полезными дополнениями:

[.programlisting]
....
# Сначала определяем группы пользователей
IT_EMP	  (,alpha,test-domain)	  (,beta,test-domain)
IT_APP	  (,charlie,test-domain)  (,delta,test-domain)
DEPT1	  (,echo,test-domain)	  (,foxtrott,test-domain)
DEPT2	  (,golf,test-domain)	  (,hotel,test-domain)
DEPT3	  (,india,test-domain)	  (,juliet,test-domain)
ITINTERN  (,kilo,test-domain)	  (,lima,test-domain)
D_INTERNS (,able,test-domain)	  (,baker,test-domain)
#
# Теперь задаем несколько групп на основе ролей
USERS	  DEPT1   DEPT2     DEPT3
BIGSRV	  IT_EMP  IT_APP
SMALLSRV  IT_EMP  IT_APP    ITINTERN
USERBOX   IT_EMP  ITINTERN  USERS
#
# И группы для специальных задач
# Открыть пользователям echo и golf доступ к антивирусной машине
SECURITY  IT_EMP  (,echo,test-domain)  (,golf,test-domain)
#
# Сетевые группы, специфичные для машин
# Наши главные серверы
WAR	  BIGSRV
FAMINE	  BIGSRV
# Пользователю india необходим доступ к этому серверу
POLLUTION  BIGSRV  (,india,test-domain)
#
# Этот очень важен и ему требуются большие ограничения доступа
DEATH	  IT_EMP
#
# Антивирусная машина, упомянутая выше
ONE	  SECURITY
#
# Ограничить машину единственным пользователем
TWO	  (,hotel,test-domain)
# [...далее следуют другие группы]
....

Если вы используете какие-либо базы данных для управления учетными записями ваших пользователей, вы должны смочь создать первую часть карты с помощью инструментов построения отчетов вашей базы данных. В таком случае новые пользователи автоматически получат доступ к машинам.

И последнее замечание: Не всегда бывает разумно использовать сетевые группы на основе машин. Если в студенческих лабораториях вы используете несколько десятков или даже сотен одинаковых машин, то вам нужно использовать сетевые группы на основе ролей, а не основе машин, для того, чтобы размеры карты NIS оставались в разумных пределах.

=== Важные замечания

Есть некоторые действия, которые нужно будет выполнять по-другому, если вы работаете с NIS.

* Каждый раз, когда вы собираетесь добавить пользователя в лаборатории, вы должны добавить его _только_ на главном сервере NIS и _обязательно перестроить карты NIS_. Если вы забудете сделать это, то новый пользователь не сможет нигде войти, кроме как на главном сервере NIS. Например, если в лаборатории нам нужно добавить нового пользователя `jsmith`, мы делаем вот что:
+

[source,bash]
....
# pw useradd jsmith
# cd /var/yp
# make test-domain
....

+ 
Вместо `pw useradd jsmith` вы можете также запустить команду `adduser jsmith`.
* _Не помещайте административные учетные записи в карты NIS_. Вам не нужно распространять административных пользователей и их пароли на машины, которые не должны иметь доступ к таким учётным записям.
* _Сделайте главный и вторичные серверы NIS безопасными и минимизируйте их время простоя_. Если кто-то либо взломает, либо просто отключит эти машины, то люди без права входа в лабораторию с легкостью получат доступ.
+ 
Это основное уязвимое место в любой централизованно администрируемой системе. Если вы не защищаете ваши серверы NIS, вы будете иметь дело с толпой разозлённых пользователей!

=== Совместимость с NIS v1

ypserv из поставки FreeBSD имеет встроенную поддержку для обслуживания клиентов NIS v1. Реализация NIS во FreeBSD использует только протокол NIS v2, хотя другие реализации имеют поддержку протокола v1 для совместимости со старыми системами. Даемоны ypbind, поставляемые с такими системами, будут пытаться осуществить привязку к серверу NIS v1, даже если это им не нужно (и они будут постоянно рассылать широковещательные запросы в поиске такого сервера даже после получения ответа от сервера v2). Отметьте, что хотя имеется поддержка обычных клиентских вызовов, эта версия ypserv не отрабатывает запросы на передачу карт v1; следовательно, она не может использоваться в качестве главного или вторичного серверов вместе с другими серверами NIS, поддерживающими только протокол v1. К счастью, скорее всего, в настоящий момент такие серверы практически не используются.

[[network-nis-server-is-client]]
=== Серверы NIS, которые также являются клиентами NIS

Особое внимание следует уделить использованию ypserv в домене со многими серверами, когда серверные машины являются также клиентами NIS. Неплохо бы заставить серверы осуществить привязку к самим себе, запретив рассылку запросов на привязку и возможно, перекрестную привязку друг к другу. Если один сервер выйдет из строя, а другие будут зависеть от него, то в результате могут возникнуть странные ситуации. Постепенно все клиенты попадут в тайм-аут и попытаются привязаться к другим серверам, но полученная задержка может быть значительной, а странности останутся, так как серверы снова могут привязаться друг к другу.

Вы можете заставить хост выполнить привязку к конкретному серверу, запустив команду `ypbind` с флагом `-S`. Если вы не хотите делать это вручную каждый раз при перезагрузке вашего сервера NIS, то можете добавить в файл [.filename]#/etc/rc.conf# такие строки:

[.programlisting]
....
nis_client_enable="YES"   # run client stuff as well
nis_client_flags="-S NIS domain,server"
....

Дополнительную информацию можно найти на странице справки по man:ypbind[8].

=== Форматы паролей

Одним из общих вопросов, которые возникают в начале работы с NIS, является вопрос совместимости форматов паролей. Если ваш сервер NIS использует пароли, зашифрованные алгоритмом DES, то он будет поддерживать только тех клиентов, что также используют DES. К примеру, если в вашей сети имеются клиенты NIS, использующие Solaris(TM), то вам, скорее всего, необходимо использовать пароли с шифрованием по алгоритму DES.

Чтобы понять, какой формат используют ваши серверы и клиенты, загляните в файл [.filename]#/etc/login.conf#. Если хост настроен на использование паролей, зашифрованных по алгоритму DES, то класс `default` будет содержать запись вроде следующей:

[.programlisting]
....
default:\
	:passwd_format=des:\
	:copyright=/etc/COPYRIGHT:\
	[Последующие строки опущены]
....

Другими возможными значениями для `passwd_format` являются `blf` и `md5` (для паролей, шифруемых по стандартам Blowfish и MD5 соответственно).

Если вы внесли изменения в файл [.filename]#/etc/login.conf#, то вам также нужно перестроить базу данных параметров входа в систему, что достигается запуском следующей команды пользователем `root`:

[source,bash]
....
# cap_mkdb /etc/login.conf
....

[NOTE]
====
Формат паролей, которые уже находятся в файле [.filename]#/etc/master.passwd#, не будет изменён до тех пор, пока пользователь не сменит свой пароль _после_ перестроения базы данных параметров входа в систему.
====

После этого, чтобы удостовериться в том, что пароли зашифрованы в том формате, который выбран вами, нужно проверить, что строка `crypt_default` в [.filename]#/etc/auth.conf# указывает предпочтение выбранного вами формата паролей. Для этого поместите выбранный формат первым в списке. Например, при использовании DES-шифрования паролей строка будет выглядеть так:

[.programlisting]
....
crypt_default	=	des blf md5
....

Выполнив вышеперечисленные шаги на каждом из серверов и клиентов NIS, работающих на FreeBSD, вы можете обеспечить их согласованность относительно используемого в вашей сети формата паролей. Если у вас возникли проблемы с аутентификацией клиента NIS, начать её решать определённо стоит отсюда. Запомните: если вы хотите использовать сервер NIS в гетерогенной сети, вам, наверное, нужно будет использовать DES на всех системах в силу того, что это минимальный общий стандарт.

[[network-dhcp]]
== Автоматическая настройка сети (DHCP)

=== Что такое DHCP?

DHCP, или Dynamic Host Configuration Protocol (Протокол Динамической Конфигурации Хостов), описывает порядок, по которому система может подключиться к сети и получить необходимую информацию для работы в ней. Во FreeBSD используется `dhclient`, импортированный из OpenBSD 3.7. Вся информация здесь, относительно `dhclient` относится либо к ISC, либо к DHCP клиентам. DHCP сервер включён в ISC дистрибутив.

=== Что описывается в этом разделе

В этом разделе описываются, как компоненты клиентской части ISC или OpenBSD DHCP клиента, так и компоненты ISC DHCP системы со стороны сервера. Программа, работающая на клиентской стороне, `dhclient`, интегрирована в поставку FreeBSD, а серверная часть доступна в виде порта package:net/isc-dhcp42-server[]. Кроме ссылок ниже, много полезной информации находится на страницах справочной системы, описывающих man:dhclient[8], man:dhcp-options[5] и man:dhclient.conf[5].

=== Как это работает

Когда на клиентской машине выполняется программа `dhclient`, являющаяся клиентом DHCP, она начинает широковещательную рассылку запросов на получение настроечной информации. По умолчанию эти запросы делаются на 68 порт UDP. Сервер отвечает на UDP 67, выдавая клиенту адрес IP и другую необходимую информацию, такую, как сетевую маску, маршрутизатор и серверы DNS. Вся эта информация даётся в форме "аренды" DHCP и верна только определенное время (что настраивается администратором сервера DHCP). При таком подходе устаревшие адреса IP тех клиентов, которые больше не подключены к сети, могут автоматически использоваться повторно.

Клиенты DHCP могут получить от сервера очень много информации. Подробный список находится в странице Справочника man:dhcp-options[5].

=== Интеграция с FreeBSD

DHCP клиент от OpenBSD, `dhclient`, полностью интегрирован во FreeBSD. Поддержка клиента DHCP есть как в программе установки, так и в самой системе, что исключает необходимость в знании подробностей конфигурации сети в любой сети, имеющей сервер DHCP.

DHCP поддерживается утилитой sysinstall. При настройке сетевого интерфейса из программы sysinstall второй вопрос, который вам задается: "Do you want to try DHCP configuration of the interface?" ("Хотите ли вы попробовать настроить этот интерфейс через DHCP?"). Утвердительный ответ приведёт к запуску программы `dhclient`, и при удачном его выполнении к автоматическому заданию информации для настройки интерфейса.

Есть две вещи, которые вы должны сделать для того, чтобы ваша система использовала DHCP при загрузке:

* Убедитесь, что устройство [.filename]#bpf# включено в компиляцию вашего ядра. Чтобы это сделать, добавьте строчку `device bpf` в конфигурационный файл ядра и перестройте ядро. Более подробная информация о построении ядер имеется в crossref:kernelconfig[kernelconfig, Настройка ядра FreeBSD].
+ 
Устройство [.filename]#bpf# уже является частью ядра [.filename]#GENERIC#, которое поставляется вместе с FreeBSD, так что, если вы не используете другое ядро, то вам и не нужно его делать для того, чтобы работал DHCP.
+
[NOTE]
====
Те, кто беспокоится о безопасности, должны иметь в виду, что устройство [.filename]#bpf# является также тем самым устройством, которое позволяет работать программам-снифферам пакетов (хотя для этого они должны быть запущены пользователем `root`). Наличие устройства [.filename]#bpf#_необходимо_ для использования DHCP, но если вы чересчур беспокоитесь о безопасности, то вам нельзя добавлять устройство [.filename]#bpf# в ядро только для того, чтобы в неопределённом будущем использовать DHCP.
====

* По умолчанию, конфигурирование FreeBSD по протоколу DHCP выполняется фоновым процессом, или _асинхронно_. Остальные стартовые скрипты продолжают работу не ожидая завершения процесса конфигурирования, тем самым ускоряя загрузку системы.
+ 
Фоновое конфигурирование не создает проблем в случае, если сервер DHCP быстро отвечает на запросы, и процесс конфигурирования происходит быстро. Однако, в некоторых случаях настройка по DHCP может длиться значительное время. При этом запуск сетевых сервисов может потерпеть неудачу, если будет произведен ранее завершения конфигурирования по DHCP. Запуск DHCP в _синхронном_ режиме предотвращает проблему, откладывая выполнение остальных стартовых скриптов до момента завершения конфигурирования по DHCP.
+ 
Для осуществления фонового конфигурирования по DHCP (асинхронный режим), используйте значение "`DHCP`" в [.filename]#/etc/rc.conf#:
+
[.programlisting]
....
ifconfig_fxp0="DHCP"
....

+ 
Для откладывания запуска стартовых скриптов до завершения конфигурирования по DHCP (синхронный режим), укажите значение "`SYNCDHCP`":
+
[.programlisting]
....
ifconfig_fxp0="SYNCDHCP"
....

+
[NOTE]
====
Замените используемое в этих примерах имя _fxp0_ на имя интерфейса, который необходимо сконфигурировать динамически, как это описано в crossref:config[config-network-setup,Настройка карт сетевых интерфейсов].
====

+ 
Если `dhclient` в вашей системе находится в другом месте или если вы хотите задать дополнительные параметры для `dhclient`, то также укажите следующее (изменив так, как вам нужно):
+
[.programlisting]
....
dhclient_program="/sbin/dhclient"
dhclient_flags=""
....

Сервер DHCP, dhcpd, включён как часть порта package:net/isc-dhcp42-server[] в коллекцию портов. Этот порт содержит DHCP-сервер от ISC и документацию.

=== Файлы

* [.filename]#/etc/dhclient.conf#
+ 
`dhclient` требует наличия конфигурационного файла, [.filename]#/etc/dhclient.conf#. Как правило, файл содержит только комментарии, а настройки по умолчанию достаточно хороши. Этот настроечный файл описан на страницах справочной системы по man:dhclient.conf[5].
* [.filename]#/sbin/dhclient#
+ 
`dhclient` скомпонован статически и находится в каталоге [.filename]#/sbin#. На страница Справочника man:dhclient[8] дается более подробная информация о `dhclient`.
* [.filename]#/sbin/dhclient-script#
+ 
`dhclient-script` является специфичным для FreeBSD скриптом настройки клиента DHCP. Он описан в man:dhclient-script[8], но для нормального функционирования никаких модификаций со стороны пользователя не требуется.
* [.filename]#/var/db/dhclient.leases#
+ 
В этом файле клиент DHCP хранит базу данных выданных к использованию адресов в виде журнала. На странице man:dhclient.leases[5] дается гораздо более подробное описание.

=== Дополнительная литература

Полное описание протокола DHCP дается в http://www.freesoft.org/CIE/RFC/2131/[RFC 2131]. Кроме того, дополнительная информация есть на сервере http://www.dhcp.org/[http://www.dhcp.org/].

[[network-dhcp-server]]
=== Установка и настройка сервера DHCP

==== Чему посвящён этот раздел

Этот раздел даёт информацию о том, как настроить систему FreeBSD для работы в качестве сервера DHCP на основе реализации пакета DHCP от ISC (Internet Systems Consortium).

Серверная часть пакета не поставляется как часть FreeBSD, так что вам потребуется установить порт package:net/isc-dhcp42-server[] для получения этого сервиса. Обратитесь к crossref:ports[ports, Установка приложений. порты и пакеты] для получения более полной информации об использовании коллекции портов.

==== Установка сервера DHCP

Для того, чтобы настроить систему FreeBSD на работу в качестве сервера DHCP, вам необходимо обеспечить присутствие устройства man:bpf[4], вкомпилированного в ядро. Для этого добавьте строку `device bpf` в файл конфигурации вашего ядра. Для получения более полной информации о построении ядер, обратитесь к crossref:kernelconfig[kernelconfig, Настройка ядра FreeBSD].

Устройство [.filename]#bpf# уже входит в состав ядра [.filename]#GENERIC#, поставляемого с FreeBSD, так что вам не нужно создавать собственное ядро для обеспечения работы DHCP.

[NOTE]
====
Те, кто обращает особое внимание на вопросы безопасности, должны заметить, что [.filename]#bpf# является тем устройством, что позволяет нормально работать снифферам пакетов (хотя таким программам требуются привилегированный доступ). Наличие устройства [.filename]#bpf#_обязательно_ для использования DHCP, но если вы очень обеспокоены безопасностью, наверное, вам не нужно включать [.filename]#bpf# в ваше ядро только потому, что в отдалённом будущем вы собираетесь использовать DHCP.
====

Следующим действием, которое вам нужно выполнить, является редактирование примерного [.filename]#dhcpd.conf#, который устанавливается в составе порта package:net/isc-dhcp42-server[]. По умолчанию это файл [.filename]#/usr/local/etc/dhcpd.conf.sample#, и вы должны скопировать его в файл [.filename]#/usr/local/etc/dhcpd.conf# перед тем, как его редактировать.

==== Настройка сервера DHCP

[.filename]#dhcpd.conf# состоит из деклараций относительно подсетей и хостов, и проще всего описывается на примере:

[.programlisting]
....
option domain-name "example.com";<.>
option domain-name-servers 192.168.4.100;<.>
option subnet-mask 255.255.255.0;<.>

default-lease-time 3600;<.>
max-lease-time 86400;<.>
ddns-update-style none;<.>

subnet 192.168.4.0 netmask 255.255.255.0 {
  range 192.168.4.129 192.168.4.254;<.>
  option routers 192.168.4.1;<.>
}

host mailhost {
  hardware ethernet 02:03:04:05:06:07;<.>
  fixed-address mailhost.example.com;<.>
}
....

<.> Этот параметр задаёт домен, который будет выдаваться клиентам в качестве домена, используемого по умолчанию при поиске. Обратитесь к страницам справочной системы по man:resolv.conf[5] для получения дополнительной информации о том, что это значит.

<.> Этот параметр задаёт список разделённых запятыми серверов DNS, которые должен использовать клиент.

<.> Маска сети, которая будет выдаваться клиентам.

<.> Клиент может запросить определённое время, которое будет действовать выданная информация. В противном случае сервер выдаст настройки с этим сроком (в секундах).

<.> Это максимальное время, на которое сервер будет выдавать конфигурацию. Если клиент запросит больший срок, он будет подтверждён, но будет действовать только `max-lease-time` секунд.

<.> Этот параметр задаёт, будет ли сервер DHCP пытаться обновить DNS при выдаче или освобождении конфигурационной информации. В реализации ISC этот параметр является _обязательным_.

<.> Это определение того, какие IP-адреса должны использоваться в качестве резерва для выдачи клиентам. IP-адреса между и включая границы, будут выдаваться клиентам.

<.> Объявление маршрутизатора, используемого по умолчанию, который будет выдаваться клиентам.

<.> Аппаратный MAC-адрес хоста (чтобы сервер DHCP мог распознать хост, когда тот делает запрос).

<.> Определение того, что хосту всегда будет выдаваться один и тот же IP-адрес. Заметьте, что указание здесь имени хоста корректно, так как сервер DHCP будет разрешать имя хоста самостоятельно до того, как выдать конфигурационную информацию.

Когда вы закончите составлять свой [.filename]#dhcpd.conf#, нужно разрешить запуск сервера DHCP в файле [.filename]#/etc/rc.conf#, добавив в него строки

[.programlisting]
....
dhcpd_enable="YES"
dhcpd_ifaces="dc0"
....

Замените `dc0` именем интерфейса (или именами интерфейсов, разделяя их пробелами), на котором(ых) сервер DHCP должен принимать запросы от клиентов.

Затем вы можете стартовать сервер DHCP при помощи команды

[source,bash]
....
# /usr/local/etc/rc.d/isc-dhcpd start
....

Если в будущем вам понадобится сделать изменения в настройке вашего сервера, то важно заметить, что посылка сигнала `SIGHUP` приложению dhcpd_не приведёт_ к перезагрузке настроек, как это бывает для большинства даемонов. Вам нужно послать сигнал `SIGTERM` для остановки процесса, а затем перезапустить его при помощи вышеприведённой команды.

==== Файлы

* [.filename]#/usr/local/sbin/dhcpd#
+ 
dhcpd скомпонован статически и расположен в каталоге [.filename]#/usr/local/sbin#. Страницы справочной системы man:dhcpd[8], устанавливаемые портом, содержат более полную информацию о dhcpd.
* [.filename]#/usr/local/etc/dhcpd.conf#
+ 
dhcpd требует наличия конфигурационного файла, [.filename]#/usr/local/etc/dhcpd.conf#, до того, как он будет запущен и начнёт предоставлять сервис клиентам. Необходимо, чтобы этот файл содержал все данные, которая будет выдаваться обслуживаемым клиентам, а также информацию о работе сервера. Этот конфигурационный файл описывается на страницах справочной системы man:dhcpd.conf[5], которые устанавливаются портом.
* [.filename]#/var/db/dhcpd.leases#
+ 
Сервер DHCP ведёт базу данных выданной информации в этом файле, который записывается в виде протокола. Страницы справочной системы man:dhcpd.leases[5], устанавливаемые портом, дают гораздо более подробное описание.
* [.filename]#/usr/local/sbin/dhcrelay#
+ 
dhcrelay используется в сложных ситуациях, когда сервер DHCP пересылает запросы от клиента другому серверу DHCP в отдельной сети. Если вам нужна такая функциональность, то установите порт package:net/isc-dhcp42-relay[]. На страницах справочной системы man:dhcrelay[8], которые устанавливаются портом, даётся более полное описание.

[[network-dns]]
== Domain Name System (DNS)

=== Обзор

По умолчанию во FreeBSD используется одна из версий программы BIND (Berkeley Internet Name Domain), являющейся самой распространенной реализацией протокола DNS. DNS - это протокол, при помощи которого имена преобразуются в IP-адреса и наоборот. Например, в ответ на запрос о `www.FreeBSD.org` будет получен IP-адрес веб-сервера Проекта FreeBSD, а запрос о `ftp.FreeBSD.org` возвратит IP-адрес соответствующей машины с FTP-сервером. Точно также происходит и обратный процесс. Запрос, содержащий IP-адрес машины, возвратит имя хоста. Для выполнения запросов к DNS вовсе не обязательно иметь в системе работающий сервер имён.

FreeBSD в настоящее время поставляется с сервером DNSBIND9, предоставляющим расширенные настройки безопасности, новую схему расположения файлов конфигурации и автоматические настройки для man:chroot[8].

В сети Интернет DNS управляется через достаточно сложную систему авторизированных корневых серверов имён, серверов доменов первого уровня (Top Level Domain, TLD) и других менее крупных серверов имён, которые содержат и кэшируют информацию о конкретных доменах.

На данный момент пакет BIND поддерживается Internet Systems Consortium https://www.isc.org/[https://www.isc.org/].

=== Используемая терминология

Для понимания этого документа нужно понимать значения некоторых терминов, связанных с работой DNS.

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Термин
| Определение

|Прямой запрос к DNS (forward DNS)
|Преобразование имён хостов в адреса IP

|Ориджин (origin)
|Обозначает домен, покрываемый конкретным файлом зоны

|named, bind
|Общеупотребительные названия для обозначения пакета BIND, обеспечивающего работу сервера имён во FreeBSD.

|Резолвер
|Системный процесс, посредством которого машина обращается к серверу имён для получения информации о зоне

|Обратный DNS (reverse DNS)
|Преобразование адресов IP в имена хостов

|Корневая зона
|Начало иерархии зон Интернет. Все зоны находятся под корневой зоной, подобно тому, как все файлы располагаются ниже корневого каталога.

|Зона
|Отдельный домен, поддомен или часть DNS, управляемая одним сервером.
|===

Примеры зон:

* `.` - так обычно обозначается в документации корневая зона.
* `org.` - домен верхнего уровня (TLD) в корневой зоне.
* `example.org.` является зоной в домене верхнего уровня (TLD) `org.`.
* `1.168.192.in-addr.arpa` является зоной, в которую включены все IP-адреса, формирующие пространство адресов `192.168.1.*`.

Как можно видеть, уточняющая часть имени хоста появляется слева. Например, `example.org.` более точен, чем `org.`, также, как `org.` более точен, чем корневая зона. Расположение каждой части имени хоста сильно похоже на файловую систему: каталог [.filename]#/dev# расположен в корневой файловой системе, и так далее.

=== Причины, по которым вам может понадобиться сервер имён

Сервера имён обычно используются в двух видах: авторитетный сервер имён и кэширующий сервер имён, также называемый распознавателем (resolver).

Авторитетный сервер имён нужен, когда:

* нужно предоставлять информацию о DNS остальному миру, отвечая на запросы авторизированно.
* зарегистрирован домен, такой, как `example.org` и в этом домене требуется поставить имена машин в соответствие с их адресами IP.
* блоку адресов IP требуется обратные записи DNS (IP в имена хостов).
* резервный (slave) сервер имён должен отвечать на запросы.

Кэширующий сервер имён нужен, когда:

* локальный сервер DNS может кэшировать информацию и отвечать на запросы быстрее, чем это происходит при прямом опросе внешнего сервера имён.

Например, когда кто-нибудь запрашивает информацию о `www.FreeBSD.org`, то обычно резолвер обращается к серверу имён вашего провайдера, посылает запрос и ожидает ответа. С локальным кэширующим сервером DNS запрос во внешний мир будет делаться всего один раз. Последующие запросы не будут посылаться за пределы локальной сети, потому что информация уже имеется в кэше.

=== Как это работает

Во FreeBSD даемон BIND называется named.

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Файл
| Описание

|man:named[8]
|Даемон BIND

|man:rndc[8]
|Программа управления даемоном сервера имён

|[.filename]#/etc/namedb#
|Каталог, в котором располагается вся информация о зонах BIND

|[.filename]#/etc/namedb/named.conf#
|Конфигурационный файл для даемона
|===

Файлы зон обычно располагаются в каталоге [.filename]#/etc/namedb# и содержат информацию о зоне DNS, за которую отвечает сервер имён.

В зависимости от способа конфигурации зоны на сервере файлы зон могут располагаться в подкаталогах [.filename]#master#, [.filename]#slave# или [.filename]#dynamic# иерархии [.filename]#/etc/namedb#. Эти файлы содержат DNS информацию, которую и будет сообщать в ответ на запросы сервер имен.

=== Запуск BIND

Так как сервер имён BIND устанавливается по умолчанию, его настройка сравнительно проста.

Стандартная конфигурация named запускает простой кэширующий сервер в ограниченной среде man:chroot[8], который прослушивает запросы на интерфейсе обратной связи (loopback) с адресом (127.0.0.1). Для одноразового запуска даемона в этой конфигурации используйте команду

[source,bash]
....
# /etc/rc.d/named onestart
....

Чтобы даемон named запускался во время загрузки, поместите в [.filename]#/etc/rc.conf# следующую строку:

[.programlisting]
....
named_enable="YES"
....

Разумеется, существует множество различных конфигураций [.filename]#/etc/namedb/named.conf#, лежащих за рамками данного документа. Разнообразные опции запуска named во FreeBSD описаны в переменных `named__*_` файла [.filename]#/etc/defaults/rc.conf# и странице справочника man:rc.conf[5]. Кроме того, полезной может оказаться crossref:config[configtuning-rcd,Использование rc во FreeBSD 5.X и последующих версиях].

=== Конфигурационные файлы

Файлы конфигурации даемона named расположены в каталоге [.filename]#/etc/namedb# и, за исключением случая, когда вам требуется просто резолвер, требуют модификации.

==== [.filename]#/etc/namedb/named.conf#

[.programlisting]
....
// $FreeBSD$
//
// If you are going to set up an authoritative server, make sure you
// understand the hairy details of how DNS works.  Even with
// simple mistakes, you can break connectivity for affected parties,
// or cause huge amounts of useless Internet traffic.

options {
	// All file and path names are relative to the chroot directory,
	// if any, and should be fully qualified.
	directory	"/etc/namedb/working";
	pid-file	"/var/run/named/pid";
	dump-file	"/var/dump/named_dump.db";
	statistics-file	"/var/stats/named.stats";

// If named is being used only as a local resolver, this is a safe default.
// For named to be accessible to the network, comment this option, specify
// the proper IP address, or delete this option.
	listen-on	{ 127.0.0.1; };

// If you have IPv6 enabled on this system, uncomment this option for
// use as a local resolver.  To give access to the network, specify
// an IPv6 address, or the keyword "any".
//	listen-on-v6	{ ::1; };

// These zones are already covered by the empty zones listed below.
// If you remove the related empty zones below, comment these lines out.
	disable-empty-zone "255.255.255.255.IN-ADDR.ARPA";
	disable-empty-zone "0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.IP6.ARPA";
	disable-empty-zone "1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.IP6.ARPA";

// If you've got a DNS server around at your upstream provider, enter
// its IP address here, and enable the line below.  This will make you
// benefit from its cache, thus reduce overall DNS traffic in the Internet.
/*
	forwarders {
		127.0.0.1;
	};
*/

// If the 'forwarders' clause is not empty the default is to 'forward first'
// which will fall back to sending a query from your local server if the name
// servers in 'forwarders' do not have the answer.  Alternatively you can
// force your name server to never initiate queries of its own by enabling the
// following line:
//	forward only;

// If you wish to have forwarding configured automatically based on
// the entries in /etc/resolv.conf, uncomment the following line and
// set named_auto_forward=yes in /etc/rc.conf.  You can also enable
// named_auto_forward_only (the effect of which is described above).
//	include "/etc/namedb/auto_forward.conf";
....

Как и говорится в комментариях, если вы хотите получить эффект от использования кэша провайдера, то можно включить раздел `forwarders`. В обычном случае сервер имён будет рекурсивно опрашивать определённые серверы имён Интернет до тех пор, пока не получит ответ на свой запрос. При включении этого раздела он будет автоматически опрашивать сервер имён вашего провайдера (или тот, который здесь указан), используя преимущества его кэша. наличия нужной информации. Если соответствующий сервер имён провайдера работает быстро и имеет хороший канал связи, то в результате такой настройки вы можете получить хороший результат.

[WARNING]
====

`127.0.0.1` здесь работать _не будет_. Измените его на IP-адрес сервера имён провайдера.
====

[.programlisting]
....
/*
	   Modern versions of BIND use a random UDP port for each outgoing
	   query by default in order to dramatically reduce the possibility
	   of cache poisoning.  All users are strongly encouraged to utilize
	   this feature, and to configure their firewalls to accommodate it.

	   AS A LAST RESORT in order to get around a restrictive firewall
	   policy you can try enabling the option below.  Use of this option
	   will significantly reduce your ability to withstand cache poisoning
	   attacks, and should be avoided if at all possible.

	   Replace NNNNN in the example with a number between 49160 and 65530.
	*/
	// query-source address * port NNNNN;
};

// If you enable a local name server, don't forget to enter 127.0.0.1
// first in your /etc/resolv.conf so this server will be queried.
// Also, make sure to enable it in /etc/rc.conf.

// The traditional root hints mechanism. Use this, OR the slave zones below.
zone "." { type hint; file "/etc/namedb/named.root"; };

/*	Slaving the following zones from the root name servers has some
	significant advantages:
	1. Faster local resolution for your users
	2. No spurious traffic will be sent from your network to the roots
	3. Greater resilience to any potential root server failure/DDoS

	On the other hand, this method requires more monitoring than the
	hints file to be sure that an unexpected failure mode has not
	incapacitated your server.  Name servers that are serving a lot
	of clients will benefit more from this approach than individual
	hosts.  Use with caution.

	To use this mechanism, uncomment the entries below, and comment
	the hint zone above.

	As documented at http://dns.icann.org/services/axfr/ these zones:
	"." (the root), ARPA, IN-ADDR.ARPA, IP6.ARPA, and ROOT-SERVERS.NET
	are available for AXFR from these servers on IPv4 and IPv6:
	xfr.lax.dns.icann.org, xfr.cjr.dns.icann.org
*/
/*
zone "." {
	type slave;
	file "/etc/namedb/slave/root.slave";
	masters {
		192.5.5.241;	// F.ROOT-SERVERS.NET.
	};
	notify no;
};

zone "arpa" {
	type slave;
	file "/etc/namedb/slave/arpa.slave";
	masters {
		192.5.5.241;	// F.ROOT-SERVERS.NET.
	};
	notify no;
};
*/

/*	Serving the following zones locally will prevent any queries
	for these zones leaving your network and going to the root
	name servers.  This has two significant advantages:
	1. Faster local resolution for your users
	2. No spurious traffic will be sent from your network to the roots
*/
// RFCs 1912 and 5735 (and BCP 32 for localhost)
zone "localhost"	{ type master; file "/etc/namedb/master/localhost-forward.db"; };
zone "127.in-addr.arpa"	{ type master; file "/etc/namedb/master/localhost-reverse.db"; };
zone "255.in-addr.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };

// RFC 1912-style zone for IPv6 localhost address
zone "0.ip6.arpa"	{ type master; file "/etc/namedb/master/localhost-reverse.db"; };

// "This" Network (RFCs 1912 and 5735)
zone "0.in-addr.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };

// Private Use Networks (RFCs 1918 and 5735)
zone "10.in-addr.arpa"	   { type master; file "/etc/namedb/master/empty.db"; };
zone "16.172.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "17.172.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "18.172.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "19.172.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "20.172.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "21.172.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "22.172.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "23.172.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "24.172.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "25.172.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "26.172.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "27.172.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "28.172.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "29.172.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "30.172.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "31.172.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "168.192.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };

// Link-local/APIPA (RFCs 3927 and 5735)
zone "254.169.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };

// IETF protocol assignments (RFCs 5735 and 5736)
zone "0.0.192.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };

// TEST-NET-[1-3] for Documentation (RFCs 5735 and 5737)
zone "2.0.192.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "100.51.198.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "113.0.203.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };

// IPv6 Range for Documentation (RFC 3849)
zone "8.b.d.0.1.0.0.2.ip6.arpa" { type master; file "/etc/namedb/master/empty.db"; };

// Domain Names for Documentation and Testing (BCP 32)
zone "test" { type master; file "/etc/namedb/master/empty.db"; };
zone "example" { type master; file "/etc/namedb/master/empty.db"; };
zone "invalid" { type master; file "/etc/namedb/master/empty.db"; };
zone "example.com" { type master; file "/etc/namedb/master/empty.db"; };
zone "example.net" { type master; file "/etc/namedb/master/empty.db"; };
zone "example.org" { type master; file "/etc/namedb/master/empty.db"; };

// Router Benchmark Testing (RFCs 2544 and 5735)
zone "18.198.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "19.198.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };

// IANA Reserved - Old Class E Space (RFC 5735)
zone "240.in-addr.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "241.in-addr.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "242.in-addr.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "243.in-addr.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "244.in-addr.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "245.in-addr.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "246.in-addr.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "247.in-addr.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "248.in-addr.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "249.in-addr.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "250.in-addr.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "251.in-addr.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "252.in-addr.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "253.in-addr.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "254.in-addr.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };

// IPv6 Unassigned Addresses (RFC 4291)
zone "1.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "3.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "4.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "5.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "6.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "7.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "8.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "9.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "a.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "b.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "c.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "d.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "e.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "0.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "1.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "2.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "3.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "4.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "5.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "6.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "7.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "8.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "9.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "a.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "b.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "0.e.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "1.e.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "2.e.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "3.e.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "4.e.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "5.e.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "6.e.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "7.e.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };

// IPv6 ULA (RFC 4193)
zone "c.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "d.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };

// IPv6 Link Local (RFC 4291)
zone "8.e.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "9.e.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "a.e.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "b.e.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };

// IPv6 Deprecated Site-Local Addresses (RFC 3879)
zone "c.e.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "d.e.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "e.e.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };
zone "f.e.f.ip6.arpa"	{ type master; file "/etc/namedb/master/empty.db"; };

// IP6.INT is Deprecated (RFC 4159)
zone "ip6.int"		{ type master; file "/etc/namedb/master/empty.db"; };

// NB: Do not use the IP addresses below, they are faked, and only
// serve demonstration/documentation purposes!
//
// Example slave zone config entries.  It can be convenient to become
// a slave at least for the zone your own domain is in.  Ask
// your network administrator for the IP address of the responsible
// master name server.
//
// Do not forget to include the reverse lookup zone!
// This is named after the first bytes of the IP address, in reverse
// order, with ".IN-ADDR.ARPA" appended, or ".IP6.ARPA" for IPv6.
//
// Before starting to set up a master zone, make sure you fully
// understand how DNS and BIND work.  There are sometimes
// non-obvious pitfalls.  Setting up a slave zone is usually simpler.
//
// NB: Don't blindly enable the examples below. :-)  Use actual names
// and addresses instead.

/* An example dynamic zone
key "exampleorgkey" {
	algorithm hmac-md5;
	secret "sf87HJqjkqh8ac87a02lla==";
};
zone "example.org" {
	type master;
	allow-update {
		key "exampleorgkey";
	};
	file "dynamic/example.org";
};
*/

/* Example of a slave reverse zone
zone "1.168.192.in-addr.arpa" {
	type slave;
	file "/etc/namedb/slave/1.168.192.in-addr.arpa";
	masters {
		192.168.1.1;
	};
};
*/
....

Это примеры описаний прямой и обратной зон из файла [.filename]#named.conf# для вторичных серверов.

Для каждого новой зоны, которую будет обслуживать сервер имён, в файл [.filename]#named.conf# должна быть добавлена запись.

К примеру, самая простая запись для домена `example.org` может выглядеть вот так:

[.programlisting]
....
zone "example.org" {
	type master;
	file "master/example.org";
};
....

Зона является первичной, что отражается в поле `type`, и информация о зоне хранится в файле [.filename]#/etc/namedb/master/example.org#, что указывается в поле `file`.

[.programlisting]
....
zone "example.org" {
	type slave;
	file "slave/example.org";
};
....

В случае вторичной зоны информация о ней передается с основного сервера имён для заданной зоны и сохраняется в указанном файле. Если и когда основной сервер имён выходит и строя или недосягаем, то скачанная информация о зоне будет находиться на вторичных серверах, и они смогут обслуживать эту зону.

==== Файлы зон

Пример файла зоны `example.org` для основного сервера (располагающийся в файле [.filename]#/etc/namedb/master/example.org#) имеет такой вид:

[.programlisting]
....
$TTL 3600        ; 1 hour default TTL
example.org.    IN      SOA      ns1.example.org. admin.example.org. (
                                2006051501      ; Serial
                                10800           ; Refresh
                                3600            ; Retry
                                604800          ; Expire
                                300             ; Negative Response TTL
                        )

; DNS Servers
                IN      NS      ns1.example.org.
                IN      NS      ns2.example.org.

; MX Records
                IN      MX 10   mx.example.org.
                IN      MX 20   mail.example.org.

                IN      A       192.168.1.1

; Machine Names
localhost       IN      A       127.0.0.1
ns1             IN      A       192.168.1.2
ns2             IN      A       192.168.1.3
mx              IN      A       192.168.1.4
mail            IN      A       192.168.1.5

; Aliases
www             IN      CNAME   example.org.
....

Заметьте, что все имена хостов, оканчивающиеся на ".", задают полное имя, тогда как все имена без символа "." на конце считаются заданными относительно origin. Например, `ns1` преобразуется в `ns1._example.org._`

Файл зоны имеет следующий формат:

[.programlisting]
....
recordname      IN recordtype  value
....

Наиболее часто используемые записи DNS:

SOA::
начало зоны ответственности

NS::
авторитативный сервер имен

A::
адрес хоста

CNAME::
каноническое имя для алиаса

MX::
обмен почтой

PTR::
указатель на доменное имя (используется в обратных зонах DNS)

[.programlisting]
....
example.org. IN SOA ns1.example.org. admin.example.org. (
                        2006051501      ; Serial
                        10800           ; Refresh after 3 hours
                        3600            ; Retry after 1 hour
                        604800          ; Expire after 1 week
                        300 )           ; Negative Response TTL
....

`example.org.`::
имя домена, а также ориджин для этого файла зоны.

`ns1.example.org.`::
основной/авторитативный сервер имён для этой зоны.

`admin.example.org.`::
человек, отвечающий за эту зону, адрес электронной почты с символом "@" замененным на точку. (mailto:admin@example.org[admin@example.org] становится `admin.example.org`)

`2006051501`::
последовательный номер файла. При каждом изменении файла зоны это число должно увеличиваться. В настоящее время для нумерации многие администраторы предпочитают формат `ггггммддвв`. `2006051501` будет означать, что файл последний раз изменялся 15.05.2006, а последнее число `01` означает, что это была первая модификация файла за день. Последовательный номер важен, так как он служит для того, чтобы вторичные серверы узнавали об обновлении зоны.

[.programlisting]
....
       IN      NS      ns1.example.org.
....

Это NS-запись. Такие записи должны иметься для всех серверов имён, которые будут отвечать за зону.

[.programlisting]
....
localhost       IN      A       127.0.0.1
ns1             IN      A       192.168.1.2
ns2             IN      A       192.168.1.3
mx              IN      A       192.168.1.4
mail            IN      A       192.168.1.5
....

Записи типа A служат для обозначения имён машин. Как это видно выше, имя `ns1.example.org` будет преобразовано в `192.168.1.2`.

[.programlisting]
....
       IN      A       192.168.1.1
....

Эта строка присваивает IP адрес `192.168.1.1` текущему ориджину, в данном случае домену `example.org`.

[.programlisting]
....
www	     IN CNAME	@
....

Записи с каноническими именами обычно используются для присвоения машинам псевдонимов. В этом примере `www` является псевдонимом для "главной" машины, имя которой по воле случая совпало с именем домена `example.org` (`192.168.1.1`). Записи типа CNAME нельзя использовать совместно с другими типами записей для одного и того же имени хоста (recordname).

[.programlisting]
....
	       IN MX   10      mail.example.org.
....

MX-запись указывает, какие почтовые серверы отвечают за обработку входящей электронной почты для зоны. `mail.example.org` является именем почтового сервера, а 10 обозначает приоритет этого почтового сервера.

Можно иметь несколько почтовых серверов с приоритетами, например, 10, 20 и так далее. Почтовый сервер, пытающийся доставить почту для `example.org`, сначала попробует связаться с машиной, имеющий MX-запись с самым большим приоритетом (наименьшим числовым значением в поле MX), затем с приоритетом поменьше и так далее, до тех пор, пока почта не будет отправлена.

Для файлов зон in-addr.arpa (обратные записи DNS) используется тот же самый формат, отличающийся только использованием записей PTR вместо A или CNAME.

[.programlisting]
....
$TTL 3600

1.168.192.in-addr.arpa. IN SOA ns1.example.org. admin.example.org. (
                        2006051501      ; Serial
                        10800           ; Refresh
                        3600            ; Retry
                        604800          ; Expire
                        300 )           ; Negative Response TTL

        IN      NS      ns1.example.org.
        IN      NS      ns2.example.org.

1       IN      PTR     example.org.
2       IN      PTR     ns1.example.org.
3       IN      PTR     ns2.example.org.
4       IN      PTR     mx.example.org.
5       IN      PTR     mail.example.org.
....

В этом файле дается полное соответствие имён хостов IP-адресам в нашем описанном ранее вымышленном домене.

Следует отметить, что все имена в правой части PTR-записи должны быть полными доменными именами (то есть, заканчиваться точкой ".").

=== Кэширующий сервер имён

Кэширующий сервер имён - это сервер имен, чья главная задача - разрешение рекурсивных запросов. Он просто выполняет запросы от своего имени и сохраняет результаты для последующего использования.

=== * DNSSEC

Этот раздел не переведен.

=== Безопасность

Хотя BIND является самой распространенной реализацией DNS, всегда стоит вопрос об обеспечении безопасности. Время от времени обнаруживаются возможные и реальные бреши в безопасности.

FreeBSD автоматически запускает named в ограниченном окружении (man:chroot[8]); помимо этого, есть еще несколько механизмов, помогающих защититься от возможных атак на сервис DNS.

Весьма полезно прочесть сообщения безопасности http://www.cert.org/[CERT] и подписаться на {freebsd-security-notifications} для того, чтобы быть в курсе текущих проблем с обеспечением безопасности Internet и FreeBSD.

[TIP]
====

Если возникает проблема, то наличие последних исходных текстов и свежесобранного named может способствовать её решению.
====

[[dns-read]]
=== Дополнительная литература

Справочная информация по BIND/named: man:rndc[8], man:named[8], man:named.conf[8], man:nsupdate[8], man:dnssec-signzone[8], man:dnssec-keygen[8]

* https://www.isc.org/software/bind[ Официальная страница ISC BIND]
* https://www.isc.org/software/guild[ Официальный форум ISC BIND]
* http://www.oreilly.com/catalog/dns5/[ Книга издательства O'Reilly DNS and BIND 5th Edition]
* http://www.root-dnssec.org/documentation/[Root DNSSEC]
* http://data.iana.org/root-anchors/draft-icann-dnssec-trust-anchor.html[DNSSEC Trust Anchor Publication for the Root Zone]
* http://tools.ietf.org/html/rfc1034[RFC1034 - Domain Names - Concepts and Facilities]
* http://tools.ietf.org/html/rfc1035[RFC1035 - Domain Names - Implementation and Specification]
* http://tools.ietf.org/html/rfc4033[RFC4033 - DNS Security Introduction and Requirements]
* http://tools.ietf.org/html/rfc4034[RFC4034 - Resource Records for the DNS Security Extensions]
* http://tools.ietf.org/html/rfc4035[RFC4035 - Protocol Modifications for the DNS Security Extensions]
* http://tools.ietf.org/html/rfc4641[RFC4641 - DNSSEC Operational Practices]
* http://tools.ietf.org/html/rfc5011[RFC5011 - Automated Updates of DNS Security (DNSSEC Trust Anchors]

[[network-apache]]
== Apache HTTP сервер

=== Обзор

FreeBSD используется в качестве платформы для многих из самых нагруженных серверов в мире. Большинство серверов в интернет используют Apache HTTP сервер. Пакеты Apache должны быть включены в поставку FreeBSD. Если вы не установили их во вместе с системой, воспользуйтесь портами package:www/apache13[] или package:www/apache22[].

Как только Apache был успешно установлен, его необходимо настроить.

[NOTE]
====
В этом разделе рассказывается о версии 1.3.X Apache HTTP сервера, поскольку эта версия наиболее широко используется в FreeBSD. Apache 2.X содержит много новых технологий, но здесь они не обсуждаются. За дополнительной информацией о Apache 2.X, обращайтесь к http://httpd.apache.org/[http://httpd.apache.org/].
====

=== Настройка

В FreeBSD основной файл настройки Apache HTTP сервера устанавливается в [.filename]#/usr/local/etc/apache/httpd.conf#. Это обычный текстовый UNIX(R) файл настройки с строками комментариев, начинающимися с символа `#`. Исчерпывающее описание всех возможных параметров настройки находится за пределом рассмотрения этой книги, поэтому здесь будут описаны только наиболее часто модифицируемые директивы.

`ServerRoot "/usr/local"`::
Указывает верхний каталог установки Apache по умолчанию. Бинарные файлы находятся в [.filename]#bin# и [.filename]#sbin#, подкаталоги расположены относительно корневого каталога сервера, файлы настройки находятся в [.filename]#etc/apache#.

`ServerAdmin you@your.address`::
Адрес, на который должны будут отправляться сообщения о проблемах с сервером. Этот адрес выводится на некоторые генерируемые сервером страницы, например с сообщениями об ошибках.

`ServerName www.example.com`::
`ServerName` позволяет вам устанавливать имя хоста, которое отправляется обратно клиентам, если оно отличается от того, с которым настроен хост (например, использование `www` вместо реального имени хоста).

`DocumentRoot "/usr/local/www/data"`::
`DocumentRoot`: Каталог, внутри которого будут храниться документы. По умолчанию, все запросы обрабатываются внутри этого каталога, но символические ссылки и синонимы могут использоваться для указания на другие каталоги.

Хорошей идеей будет сделать резервные копии настроек Apache перед внесением изменений. Как только вы будете удовлетворены первоначальной настройкой, можно запускать Apache.

=== Запуск Apache

Apache не запускается из inetd, как это делают многие другие сетевые серверы. Он настроен для автономного запуска, чтобы обеспечивать большую производительность при обработке HTTP запросов от браузеров клиентов. Для упрощения запуска, остановки и перезапуска сервера существует shell скрипт. Для запуска Apache в первый раз просто выполните:

[source,bash]
....
# /usr/local/sbin/apachectl start
....

Вы можете остановить сервер в любой момент, выполнив:

[source,bash]
....
# /usr/local/sbin/apachectl stop
....

После внесения любых изменений в файл настроек, вам потребуется перезапустить сервер:

[source,bash]
....
# /usr/local/sbin/apachectl restart
....

Для перезапуска Apache без прерывания имеющихся соединений, выполните:

[source,bash]
....
# /usr/local/sbin/apachectl graceful
....

Дополнительная информация находится на странице справочного руководства man:apachectl[8].

Для запуска Apache при старте системы, добавьте в [.filename]#/etc/rc.conf# следующую строку:

[.programlisting]
....
apache_enable="YES"
....

или для Apache 2.2:

[.programlisting]
....
apache22_enable="YES"
....

Если вы хотите передать программе Apache`httpd` дополнительные параметры командной при загрузке системы, они могут быть помещены в дополнительную строку [.filename]#rc.conf#:

[.programlisting]
....
apache_flags=""
....

Теперь, когда веб сервер запущен, вы можете просмотреть свой веб сайт, задав в строке браузера адрес `http://localhost/`. По умолчанию отображается веб страница [.filename]#/usr/local/www/data/index.html#.

=== Виртуальный хостинг

Apache поддерживает два различных типа виртуального хостинга (Virtual Hosting). Первый метод основан на именах (Name-based Virtual Hosting). Он использует полученные от клиента заголовки HTTP/1.1 для определения имени хоста. Это позволяет многим различным доменам использовать один и тот же IP адрес.

Для настройки Apache на использование этого типа хостинга добавьте в [.filename]#httpd.conf# запись подобную следующей:

[.programlisting]
....
NameVirtualHost *
....

Если веб сервер назывался `www.domain.tld` и вы хотите настроить виртуальный домен для `www.someotherdomain.tld`, необходимо добавить в [.filename]#httpd.conf# следующие записи:

[source,bash]
....
<VirtualHost *>
ServerName www.domain.tld
DocumentRoot /www/domain.tld
</VirtualHost>

<VirtualHost *>
ServerName www.someotherdomain.tld
DocumentRoot /www/someotherdomain.tld
</VirtualHost>
....

Замените адреса и пути к документам на те, что вы будете использовать.

За дополнительной информацией по настройке виртуальных хостов обращайтесь к официальной документации Apache: http://httpd.apache.org/docs/vhosts/[http://httpd.apache.org/docs/vhosts/].

=== Модули Apache

Существуют множество различных модулей Apache, которые добавляют функциональность к основному серверу. Коллекция портов FreeBSD предоставляет простой способ установки Apache с некоторыми наиболее популярными дополнительными модулями.

==== mod_ssl

Модуль mod_ssl использует библиотеку OpenSSL для сильной криптографии через протоколы Secure Sockets Layer (SSL v2/v3) и Transport Layer Security (TLS v1). Этот модуль содержит все необходимое для запроса подписанного сертификата из центра сертификации для защищенного веб сервера на FreeBSD.

Если вы еще не установили Apache, версия Apache 1.3.X с mod_ssl может быть установлена через порт package:www/apache13-modssl[]. Поддержка SSL также доступна для Apache 2.X через порт package:www/apache22[], где она включена по умолчанию.

==== Apache и скриптовые языки

Для большинства скриптовых языков созданы модули Apache. На базе таких модулей возможно создание других модулей Apache, написанных полностью на скриптовом языке. Они также часто используются как встроенные в сервер интерпретаторы, что исключает накладные расходы на запуск внешнего интерпретатора и сокращает время построения динамических страниц.

=== Построение динамических сайтов

В последнее десятилетие все большее число компаний обращает внимание на Интернет как площадку для ведения и расширения бизнеса. Среди прочего, этот процесс подчеркивает потребность в интерактивном содержимом сайтов. Некоторые компании, такие как Microsoft(R), представляют свои закрытые решения; сообщество разработчиков открытых программ отвечает на вызов. Среди современных решений для предоставления динамического контента следует отметить Django, Ruby on Rails, mod_perl и mod_php.

==== Django

Django - это распространяемая под лицензией BSD инфраструктура, позволяющая разработчикам быстро создавать элегантные, высокопроизводительные веб-приложения. Она предоставляет в распоряжение разработчика объектно-реляционное отображение (object-relational mapper), таким образом типы данных разрабатываются как объекты Python. Для этих объектов предоставляется богатый интерфейс доступа к базам данных, при этом у разработчика не возникает необходимости написания SQL-запросов. Django также предоставляет расширяемую систему шаблонов, так что логика приложения отделена от его HTML-представления.

Для Django требуются следующие компоненты: mod_python, Apache и одна из нескольких возможных SQL СУБД. Укажите соответствующие опции сборки, и порт установит всё необходимое.

[[network-www-django-install]]
.Установка Django совместно с Apache2, mod_python3 и PostgreSQL
[example]
====

[source,bash]
....
# cd /usr/ports/www/py-django; make all install clean -DWITH_MOD_PYTHON3 -DWITH_POSTGRESQL
....

====

После установки Django и всех необходимых ему компонентов вам потребуется создать каталог для проекта Django. Далее потребуется настроить Apache для определенных URL адресов на вашем сайте выполнять ваше приложение встроенным интерпретатором Python.

[[network-www-django-apache-config]]
.Конфигурация Apache для Django/mod_python
[example]
====
Чтобы настроить Apache отправлять запросы для определенных URL адресов вашему веб-приложению, вам потребуется внести несколько строк в конфигурационный файл [.filename]#httpd.conf#:

[source,bash]
....
<Location "/">
    SetHandler python-program
    PythonPath "['/dir/to/your/django/packages/'] + sys.path"
    PythonHandler django.core.handlers.modpython
    SetEnv DJANGO_SETTINGS_MODULE mysite.settings
    PythonAutoReload On
    PythonDebug On
</Location>
....

====

==== Ruby on Rails

Ruby on Rails это еще одна веб инфраструктура с открытым исходным кодом, которая предоставляет полный стек разработки и которая оптимизированa для продуктивного и быстрого создания мощных веб-приложений. Ruby on Rails может быть легко установлена из коллекции портов.

[source,bash]
....
# cd /usr/ports/www/rubygem-rails; make all install clean
....

==== mod_perl

Проект интеграции Apache/Perl объединяет мощь языка программирования Perl и HTTP сервера Apache. С модулем mod_perl возможно написание модулей Apache полностью на Perl. Кроме того, постоянно запущенный встроенный в сервер интерпретатор позволяет не тратить ресурсы на запуск внешнего интерпретатора и время на запуск Perl.

mod_perl можно использовать различными способами. Помните, что mod_perl 1.0 работает только с Apache 1.3, тогда как mod_perl 2.0 совместим только с Apache 2.X. mod_perl 1.0 доступен как порт package:www/mod_perl[], а также в виде статически скомпилированной версии в package:www/apache13-modperl[]. mod_perl 2.0 доступен как package:www/mod_perl2[].

==== mod_php

PHP, также известный как "Препроцессор гипертекста" ("Hypertext Preprocessor"), - это скриптовый язык общего назначения, в основном предназначенный для веб разработки. Этот язык может быть встроен в HTML, его синтаксис заимствован из C, Java(TM) и Perl, и он позволяет веб разработчикам быстро писать динамически генерируемые страницы.

Добавление поддержки PHP5 к веб серверу Apache производится путем установки порта package:lang/mod_php5[].

Если порт package:lang/php5[] устанавливается впервые, то автоматически отобразятся все доступные опции (`OPTIONS`). Если меню не отображается, так как порт package:lang/php5[] устанавливался ранее, всегда можно повторно вызвать диалог меню выполнив следующую команду в каталоге порта:

[source,bash]
....
# make config
....

Выберите в меню опцию `APACHE`, тем самым вы построите загружаемый модуль mod_php5 для веб сервера Apache.

[NOTE]
====
Множество сайтов по разным причинам (например, из-за проблем совместимости или из-за наличия уже развёрнутых веб приложений) всё еще используют PHP4. Если требуется mod_php4 вместо mod_php5, то воспользуйтесь портом package:lang/php4[]. Порт package:lang/php4[] поддерживает многие из конфигурационных и установочных опций порта package:lang/php5[].
====

Этот порт устанавливает и настраивает модули, необходимые для поддержки динамических PHP веб страниц. Убедитесь, что в файл [.filename]#/usr/local/etc/apache/httpd.conf# были добавлены следующие секции:

[.programlisting]
....
LoadModule php5_module        libexec/apache/libphp5.so
....

[.programlisting]
....
AddModule mod_php5.c
    <IfModule mod_php5.c>
        DirectoryIndex index.php index.html
    </IfModule>
    <IfModule mod_php5.c>
        AddType application/x-httpd-php .php
        AddType application/x-httpd-php-source .phps
    </IfModule>
....

Для загрузки модуля PHP после этого просто вызовите команду `apachectl` с параметром graceful:

[source,bash]
....
# apachectl graceful
....

При дальнейших обновлениях PHP команда `make config` больше не потребуется; выбранные опции сохраняются автоматически инфраструктурой портов FreeBSD

Поддержка PHP в FreeBSD построена по модульному принципу, поэтому базовая установка обладает очень ограниченной функциональностью. Дополнительная функциональность может быть легко добавлена при помощи порта package:lang/php5-extensions[], управляющего набором расширений PHP через меню, либо просто путем установки дополнительных портов.

Например, для добавления поддержки MySQL к PHP5, просто установите порт [.filename]#databases/php5-mysql#.

После установки новых расширений сервер Apache должен быть рестартован, чтобы изменения в конфигурации вступили в силу:

[source,bash]
....
# apachectl graceful
....

[[network-samba]]
== Файл сервер и печать для Microsoft(R) Windows(R) клиентов (Samba)

=== Обзор

Samba это популярный пакет программ с открытыми исходными текстами, которая предоставляет файловые и принт-сервисы Microsoft(R) Windows(R) клиентам. Эти клиенты могут подключаться и использовать файловое пространство FreeBSD, как если бы это был локальный диск, или принтеры FreeBSD, как если бы это были локальные принтеры.

Пакет Samba должен быть включен в поставку FreeBSD. Если вы не установили Samba при первой установке системы, ее можно установить из порта или пакета package:net/samba34[].

=== Настройка

Файл настройки Samba по умолчанию устанавливается в [.filename]#/usr/local/shared/examples/samba34/smb.conf.default#. Этот файл необходимо скопировать в [.filename]#/usr/local/etc/smb.conf# и отредактировать перед использованием Samba.

В файле [.filename]#smb.conf# находится информация, необходимая для работы Samba, например определение принтеров и "общих каталогов", которые будут использоваться совместно с Windows(R) клиентами. В пакет Samba входит программа с веб интерфейсом, называемая swat, которая дает простой способ редактирования файла [.filename]#smb.conf#.

==== Использование Samba Web Administration Tool (SWAT)

Программа веб администрирования Samba (Samba Web Administration Tool, SWAT) запускается как даемон из inetd. Следовательно, в [.filename]#/etc/inetd.conf# необходимо снять комментарий перед тем, как использовать swat для настройки Samba:

[.programlisting]
....
swat   stream  tcp     nowait/400      root    /usr/local/sbin/swat    swat
....

Как описано в <<network-inetd-reread>>, после изменения настроек inetd необходимо перечитать конфигурацию.

Как только swat был включен [.filename]#inetd.conf#, вы можете использовать браузер для подключения к http://localhost:901[http://localhost:901]. Сначала необходимо зарегистрироваться с системной учетной записью `root`.

После успешного входа на основную страницу настройки Samba, вы можете просмотреть документацию или начать настройку, нажав на кнопку menu:Globals[]. Раздел menu:Globals[] соответствует переменным, установленным в разделе `[global]` файла [.filename]#/usr/local/etc/smb.conf#.

==== Глобальные настройки

Независимо от того, используете ли вы swat, или редактируете [.filename]#/usr/local/etc/smb.conf# непосредственно, первые директивы, которые вы скорее всего встретите при настройке Samba, будут следующими:

`workgroup`::
Имя домена или рабочей группы NT для компьютеров, которые будут получать доступ к этому серверу.

`netbios name`::
Устанавливает имя NetBIOS, под которым будет работать Samba сервер. По умолчанию оно устанавливается равным первому компоненту DNS имени хоста.

`server string`::
Устанавливает строку, которая будет показана командой `net view` и некоторыми другими сетевыми инструментами, которые отображают строку описания сервера.

==== Настройки безопасности

Две из наиболее важных настроек в [.filename]#/usr/local/etc/smb.conf# отвечают за выбор модели безопасности и за формат паролей для клиентов. Эти параметры контролируются следующими директивами:

`security`::
Два наиболее часто используемых параметра это `security = share` и `security = user`. Если имена пользователей для клиентов совпадают с их именами на компьютере FreeBSD, вы возможно захотите включить безопасность уровня пользователя (user). Это политика безопасности по умолчанию, она требует, чтобы клиент авторизовался перед доступом к совместно используемым ресурсам.
+
На уровне безопасности share клиенту не требуется входить на сервер перед подключением к ресурсу. Эта модель безопасности использовалась по умолчанию в старых версиях Samba.

`passdb backend`::
Samba поддерживает несколько различных подсистем аутентификации. Вы можете аутентифицировать клиентов с помощью LDAP, NIS+, базы данных SQL, или через модифицированный файл паролей. Метод аутентификации по умолчанию `smbpasswd`, и здесь рассматривается только он.

Предполагая, что используется подсистема по умолчанию `smbpasswd`, необходимо создать файл [.filename]#/usr/local/etc/samba/smbpasswd#, чтобы Samba могла аутентифицировать клиентов. Если вы хотите разрешить к учетным записям UNIX(R) доступ с Windows(R) клиентов, используйте следующую команду:

[source,bash]
....
# smbpasswd -a username
....

[NOTE]
====
Ныне рекомендуемой подсистемой аутентификации является `tdbsam`, поэтому для добавления пользователей используйте следующую команду:

[source,bash]
....
# pdbedit -a -u username
....

====

Пожалуйста, обратитесь к http://www.samba.org/samba/docs/man/Samba-HOWTO-Collection/[Official Samba HOWTO] за дополнительной информацией о параметрах настройки. Основные настройки, рассмотренные здесь, достаточны для первого запуска Samba.

=== Запуск Samba

Порт package:net/samba34[] добавляет новый стартовый сценарий, который может быть использован для контроля Samba. Для того, чтобы им можно было запускать, останавливать или перезапускать сервер Samba, добавьте следующую запись в файл [.filename]#/etc/rc.conf#:

[.programlisting]
....
samba_enable="YES"
....

Или, для более тонкого контроля:

[.programlisting]
....
nmbd_enable="YES"
....

[.programlisting]
....
smbd_enable="YES"
....

[NOTE]
====
Внесение этих записей в [.filename]#/etc/rc.conf# также обеспечит автоматический запуск сервера Samba во время старта системы.
====

Теперь становится возможным запустить сервер Samba, для чего наберите следующую команду:

[source,bash]
....
# /usr/local/etc/rc.d/samba start
Starting SAMBA: removing stale tdbs :
Starting nmbd.
Starting smbd.
....

За дальнейшей информацией об использовании rc скриптов обратитесь к crossref:config[configtuning-rcd,Использование rc во FreeBSD 5.X и последующих версиях].

Samba состоит из трех отдельных даемонов. Вы можете видеть, что nmbd и smbd запускаются скриптом [.filename]#samba#. Если вы включили сервис разрешения имен winbind в [.filename]#smb.conf#, то увидите также запуск даемона winbindd.

Вы можете остановить Samba в любой момент, набрав:

[source,bash]
....
# /usr/local/etc/rc.d/samba stop
....

Samba это сложный программный набор с функциональностью, позволяющей полную интеграцию в сети Microsoft(R) Windows(R). За дальнейшей информацией о функциях, выходящих за рамки описанной здесь базовой установки, обращайтесь к http://www.samba.org[http://www.samba.org].

[[network-ftp]]
== Протокол передачи файлов (FTP)

=== Обзор

Протокол передачи файлов (File Transfer Protocol, FTP) дает пользователям простой путь передачи файлов на и с FTP сервера. В FreeBSD серверная программа FTP, ftpd, включена в базовую систему. Это упрощает настройку и администрирование FTP сервера в FreeBSD.

=== Настройка

Наиболее важный шаг заключается в определении того, каким учетным записям будет позволено получать доступ к FTP серверу. В обычной системе FreeBSD есть множество системных учетных записей, используемых различными даемонами, но пользователям должно быть запрещен вход с использованием этих учетных записей. В файле [.filename]#/etc/ftpusers# находится список пользователей, которым запрещен доступ по FTP. По умолчанию он включает упомянутые системные учетные записи, но в него можно добавить и определенных пользователей, которым будет запрещен доступ по FTP.

Вам может понадобиться ограничить доступ определенных пользователей без полного запрета использования FTP. Это можно сделать через файл [.filename]#/etc/ftpchroot#. В нем находится список пользователей и групп, к которым применяется ограничение доступа. На странице справочника man:ftpchroot[5] дана подробная информация, и она не будет дублироваться здесь.

Если вы захотите разрешить анонимный FTP доступ на сервер, в системе FreeBSD необходимо создать пользователя `ftp`. Этот пользователь сможет входить на FTP сервер с именем пользователя `ftp` или `anonymous`, с любым паролем (существует соглашение об использовании почтового адреса пользователя в качестве пароля). FTP сервер выполнит man:chroot[2] при входе пользователя anonymous для ограничения доступа только домашним каталогом пользователя `ftp`.

Существуют два текстовых файла, определяющих сообщение, отправляемое FTP клиентам. Содержимое файла [.filename]#/etc/ftpwelcome# будет выведено пользователям перед приглашением на вход. После успешного входа будет выведено содержимое файла [.filename]#/etc/ftpmotd#. Обратите внимание, что путь к этому файлу задается относительно домашнего каталога пользователя, так что анонимным пользователям будет отправляться [.filename]#~ftp/etc/ftpmotd#.

Как только FTP сервер был правильно настроен, он должен быть включен в [.filename]#/etc/inetd.conf#. Все, что необходимо, это удалить символ комментария "#" из начала существующей строки ftpd:

[.programlisting]
....
ftp	stream	tcp	nowait	root	/usr/libexec/ftpd	ftpd -l
....

Как описано в <<network-inetd-reread>>, inetd должен перечитать конфигурацию после того, как этот файл настройки был изменен. Пожалуйста обратитесь к <<network-inetd-settings>> за деталями по запуску inetd на вашей системе.

В качестве альтернативы, демон ftpd может быть запущен как самостоятельный сервер. В этом случае достаточно установить соответствующую переменную в файле [.filename]#/etc/rc.conf#:

[.programlisting]
....
ftpd_enable="YES"
....

Демон будет запущен автоматически при следующей загрузке системы. Также демон можно запустить вручную, для чего выполните следующую команду как пользователь `root`:

[source,bash]
....
# /etc/rc.d/ftpd start
....

Теперь вы можете войти на FTP сервер, введя:

[source,bash]
....
% ftp localhost
....

=== Поддержка

Для протоколирования даемон ftpd использует сообщения man:syslog[3]. По умолчанию, man:syslog[3] поместит сообщения, относящиеся к FTP, в файл [.filename]#/var/log/xferlog#. Местоположение лог файла FTP может быть изменено путем изменения следующей строки в файле [.filename]#/etc/syslog.conf#:

[.programlisting]
....
ftp.info      /var/log/xferlog
....

Учитывайте потенциальные проблемы, возникающие с анонимным FTP сервером. В частности, вы должны дважды подумать, прежде чем позволить анонимным пользователям загружать файлы на сервер. Вы можете обнаружить, что FTP сайт стал форумом, на котором происходит обмен нелицензионным коммерческим программным обеспечением или чем-то еще хуже. Если вам необходимо разрешить анонимную выгрузку файлов на FTP, права должны быть настроены таким образом, чтобы эти файлы не могли прочитать другие анонимные пользователи до их рассмотрения администратором.

[[network-ntp]]
== Синхронизация часов через NTP

=== Обзор

С течением времени часы компьютера имеют тенденцию отставать. Network Time Protocol - Сетевой Протокол Времени (NTP) является одним из способов вести точное время.

Многие сервисы Интернет опираются или сильно зависят от точности часов компьютеров. К примеру, веб-сервер может получать запрос на посылку файла, который был недавно модифицирован. В локальной сети необходимо, чтобы часы компьютеров, совместно использующих файлы, были синхронизированы, чтобы время модификации файлов устанавливалось правильно. Такие службы, как man:cron[8], также зависят от правильности установки системных часов, поскольку запускают команды в определенное время.

FreeBSD поставляется с сервером NTP man:ntpd[8], который можно использовать для опроса других серверов NTP для установки часов на вашей машине или предоставления услуг точного времени.

=== Выбор подходящих серверов NTP

Для синхронизации ваших часов вам нужно найти для использования один или большее количество серверов NTP. Ваш сетевой администратор или провайдер могут иметь сервер NTP для этой цели-обратитесь к ним, так ли это в вашем случае. Существует http://support.ntp.org/bin/view/Servers/WebHome[онлайн список общедоступных серверов NTP], которым можно воспользоваться для поиска ближайшего к вам сервера NTP. Не забудьте выяснить политику выбранного вами сервера и спросить разрешения, если это требуется.

Выбор нескольких несвязанных серверов NTP является хорошей идеей в том случае, если один из используемых вами серверов станет недоступным или его часы неточны. man:ntpd[8] использует ответы, которые он получает от других серверов с умом-он делает предпочтение надежным серверам.

=== Настройка вашей машины

==== Базовая конфигурация

Если вам нужно только синхронизировать ваши часы при загрузке машины, вы можете воспользоваться утилитой man:ntpdate[8]. Это может подойти для некоторых настольных машин, которые часто перезагружаются и только требуют изредка синхронизироваться, но на большинстве машин должен работать man:ntpd[8].

Использование man:ntpdate[8] при загрузке также хорошо для машин, на которых запущен даемон man:ntpd[8]. Программа man:ntpd[8] изменяет время постепенно, тогда как man:ntpdate[8] устанавливает время вне зависимости от того, насколько велика разница между текущим временем машины и точным временем.

Для включения man:ntpdate[8] во время загрузки, добавьте строчку `ntpdate_enable="YES"` в файл [.filename]#/etc/rc.conf#. Вам также потребуется указать все серверы, с которыми вы хотите синхронизироваться, и все параметры, которые передаются в man:ntpdate[8], в `ntpdate_flags`.

==== Общие настройки

NTP настраивается в файле [.filename]#/etc/ntp.conf#, формат которого описан в man:ntp.conf[5]. Вот простой пример:

[.programlisting]
....
server ntplocal.example.com prefer
server timeserver.example.org
server ntp2a.example.net

driftfile /var/db/ntp.drift
....

Параметр `server` задает, какие серверы будут использоваться, по одному в каждой строке. Если сервер задан с аргументом `prefer`, как `ntplocal.example.com`, то этому серверу отдается предпочтение перед остальными. Ответ от предпочтительного сервера будет отброшен, если он значительно отличается от ответов других серверов, в противном случае он будет использоваться безотносительно к другим ответам. Аргумент `prefer` обычно используется для серверов NTP, о которых известно, что они очень точны, такими, на которых используется специальное оборудование точного времени.

Параметр `driftfile` задает файл, который используется для хранения смещения частоты системных часов. Программа man:ntpd[8] использует его для автоматической компенсации естественного смещения часов, позволяя ему поддерживать достаточно правильную настройку, даже если он на некоторый период отключается от внешнего источника информации о времени.

Параметр `driftfile` задает, какой файл используется для сохранения информации о предыдущих ответах от серверов NTP, которые вы используете. Этот файл содержит внутреннюю информацию для NTP. Он не должен изменяться никакими другими процессами.

==== Управление доступом к вашему серверу

По умолчанию ваш сервер NTP будет доступен всем хостам в Интернет. Параметр `restrict` в файле [.filename]#/etc/ntp.conf# позволяет вам контролировать, какие машины могут обращаться к вашему серверу.

Если вы хотите запретить всем машинам обращаться к вашему серверу NTP, добавьте следующую строку в файл [.filename]#/etc/ntp.conf#:

[.programlisting]
....
restrict default ignore
....

[NOTE]
====
Эта строка конфигурации также предотвратит доступ вашего сервера к другим серверам, перечисленным в вашей локальной конфигурации. Если вам необходимо синхронизировать ваш сервер с внешним сервером NTP, вам необходимо будет изменить настройки относительно этого конкретного сервера. За более детальной информацией обратитесь к странице руководства man:ntp.conf[5].
====

Если вы хотите разрешить синхронизировать свои часы с вашим сервером только машинам в вашей сети, но запретить им настраивать сервер или быть равноправными участниками синхронизации времени, то вместо указанной добавьте строчку

[.programlisting]
....
restrict 192.168.1.0 mask 255.255.255.0 nomodify notrap
....

где `192.168.1.0` является адресом IP вашей сети, а `255.255.255.0` её сетевой маской.

[.filename]#/etc/ntp.conf# может содержать несколько директив `restrict`. Для получения подробной информации обратитесь к подразделу `Access Control Support` (Поддержка Управления Доступом) в man:ntp.conf[5].

=== Запуск сервера NTP

Для того, чтобы сервер NTP запускался при загрузке, добавьте строку `ntpd_enable="YES"` в файл [.filename]#/etc/rc.conf#. Если вы хотите передать дополнительные опции в man:ntpd[8], то отредактируйте параметр `ntpd_flags` в файле [.filename]#/etc/rc.conf#.

Для запуска сервера без перезагрузки вашей машины, выполните команду `ntpd`, не забыв задать дополнительные параметры из переменной `ntpd_flags` в файле [.filename]#/etc/rc.conf#. К примеру:

[source,bash]
....
# ntpd -p /var/run/ntpd.pid
....

=== Использование ntpd с временным подключением к Интернет

Для нормальной работы программе man:ntpd[8] не требуется постоянное подключение к Интернет. Однако если ваше временное подключение к Интернет настроено для дозвона по требованию, хорошо бы запретить трафику NTP вызывать дозвон или поддерживать соединение постоянно. Если вы используете пользовательский PPP, то можете воспользоваться директивами `filter` в файле [.filename]#/etc/ppp/ppp.conf#. К примеру:

[.programlisting]
....
 set filter dial 0 deny udp src eq 123
 # Prevent NTP traffic from initiating dial out
 set filter dial 1 permit 0 0
 set filter alive 0 deny udp src eq 123
 # Prevent incoming NTP traffic from keeping the connection open
 set filter alive 1 deny udp dst eq 123
 # Prevent outgoing NTP traffic from keeping the connection open
 set filter alive 2 permit 0/0 0/0
....

Более подробную информацию можно найти в разделе `PACKET FILTERING` (ФИЛЬТРАЦИЯ ПАКЕТОВ) в man:ppp[8], а примеры в [.filename]#/usr/shared/examples/ppp/#.

[NOTE]
====
Некоторые провайдеры Интернет блокируют трафик по портам с маленькими номерами, что приводит к неработоспособности NTP, так как ответы никогда не достигают вашей машины.
====

=== Дополнительная литература

Документация по серверу NTP может быть найдена в каталоге [.filename]#/usr/shared/doc/ntp/# в формате HTML.

[[network-syslogd]]
== * Remote Host Logging with `syslogd`

Этот раздел не переведен.
