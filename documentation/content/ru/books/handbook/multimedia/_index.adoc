---
title: Глава 8. Мультимедиа
part: Часть II. Общие задачи
prev: books/handbook/desktop
next: books/handbook/kernelconfig
showBookMenu: true
weight: 11
path: "/books/handbook/multimedia/"
---

[[multimedia]]
= Мультимедиа
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 8
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/multimedia/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[multimedia-synopsis]]
== Краткий обзор

FreeBSD поддерживает большое количество различных звуковых карт, что позволяет вам насладится высококачественным звуком. Это также дает возможность записывать и воспроизводить звуковые файлы в формате MPEG Audio Layer 3 (MP3), WAV, Ogg Vorbis, а также во множестве других форматов. Коллекция Портов FreeBSD также содержит ряд приложений, позволяющих редактировать записанные звуковые файлы, добавлять звуковые эффекты, управлять подключенными MIDI устройствами.

FreeBSD может поддерживать воспроизведение видеофайлов и DVD. Количество приложений, позволяющих кодировать, преобразовывать и воспроизводить различные форматы видео, существенно меньше количества приложений для работы со звуком. Например, на время написания этого документа в Коллекции Портов FreeBSD не существовало хорошего приложения для преобразования видео, которое могло бы быть использовано для преобразований между разными форматами, как, например, package:audio/sox[]. Впрочем, ситуация в этой области меняется быстро.

Эта глава описывает необходимые шаги для настройки вашей звуковой карты. Настройка и установка X11 (crossref:x11[x11, X Window System]) уже охватывает вопросы, связанные с аппаратными установками вашей видеокарты, хотя могут быть возможности дополнительной настройки для улучшения воспроизведения.

После прочтения этой главы вы будете знать:

* Как настроить систему так, чтобы звуковая карта была опознана.
* Методы проверки работы звуковой карты при помощи тестовых приложений.
* Как исправить проблемы, возникающие при работе со звуковыми картами.
* Как прослушать и создать MP3 и другие форматы.
* Как X сервер поддерживает видео.
* Некоторые проигрыватели и кодировщики видео, которые показывают хорошие результаты.
* Как воспроизвести DVD, [.filename]#.mpg# и [.filename]#.avi# файлы.
* Как скопировать информацию с CD и DVD в файлы.
* Как настроить ТВ тюнер.
* Как настроить сканер.

Перед чтением этой главы вам потребуется:

* Узнать, как конфигурировать и устанавливать новое ядро (crossref:kernelconfig[kernelconfig, Настройка ядра FreeBSD]).

[WARNING]
====

Попытка смонтировать аудио CD при помощи команды man:mount[8] как минимум, сообщит об ошибке и, как максимум, может привести к _панике ядра_. Эти носители имеют специальные форматы, которые отличны от обычной файловой системы ISO.
====

[[sound-setup]]
== Настройка звуковой карты

[[sound-device]]
=== Настройка системы

Перед тем как начать, определите модель вашей карты, процессор, который она использует, и интерфейс карты: PCI или ISA. FreeBSD поддерживает множество разных PCI и ISA карт. Сверьтесь со списком поддерживаемых аудио устройств в link:{u-rel120-hardware}[Информации об оборудовании], чтобы проверить, поддерживается ли ваша карта. Этот документ также содержит информацию о том, какой драйвер поддерживает вашу карту.

Для того, чтобы использовать звуковую карту, вы должный загрузить соответствующий драйвер устройства. Этого можно достигнуть двумя путями. Простейший способ - это просто загрузить соответствующий вашей карте модуль ядра используя man:kldload[8], что можно сделать или из командной строки:

[source,shell]
....
# kldload snd_emu10k1
....

или добавлением соответствующей строки к файлу [.filename]#/boot/loader.conf#:

[.programlisting]
....
snd_emu10k1_load="YES"
....

Эти примеры приведены для звуковой карты Creative SoundBlaster(R) Live!. Другие имеющиеся модули драйверов звуковых карты приведены в [.filename]#/boot/defaults/loader.conf# Если вы не уверены, какой драйвер использовать, попробуйте загрузить [.filename]#snd_driver#:

[source,shell]
....
# kldload snd_driver
....

Это мета-драйвер, загружающий сразу все наиболее распространенные драйверы сразу. Это повышает скорость поиска правильного драйвера. Возможна также загрузка всех звуковых драйверов через [.filename]#/boot/loader.conf#.

Для того чтобы узнать, какой именно драйвер требуется для вашей звуковой карты, вы можете проверить содержимое файла [.filename]#/dev/sndstat# при помощи команды `cat /dev/sndstat`.

Другой способ заключается в добавлении статического драйвера в ядро. В разделе ниже дана более подробная информация о том, что вам нужно сделать для добавления поддержки оборудования. Более подробно о конфигурация ядра описана в crossref:kernelconfig[kernelconfig, Настройка ядра FreeBSD].

==== Настройка собственного ядра с поддержкой звука

Первое, что необходимо сделать, это добавить в ядро общий звуковой драйвер man:sound[4]. Добавьте в файл конфигурации ядра следующую строку:

[.programlisting]
....
device sound
....

Затем необходимо добавить поддержку имеющейся звуковой карты. Следовательно, нужно знать какой драйвер поддерживает карту. Для этого сверьтесь со списком поддерживаемых устройств из link:{u-rel120-hardware}[Информации об оборудовании]. Например, звуковая карта Creative SoundBlaster(R) Live! поддерживается драйвером man:snd_emu10k1[4]. Для добавления поддержки этой карты, используйте:

[.programlisting]
....
device snd_emu10k1
....

Прочтите страницу справочника драйвера, чтобы узнать, какой синтаксис использовать. Информация, относящаяся к синтаксису включения звуковых драйверов в файл конфигурации ядра, может быть также найдена в файле [.filename]#/usr/src/sys/conf/NOTES#.

Не-PnP ISA карты могут потребовать включения в ядро информации о настройках звуковой карты (IRQ, I/O port, и т.д.). Эта информация добавляется редактированием файла [.filename]#/boot/device.hints#. Во время загрузки системы man:loader[8] прочтет этот файл и передаст настройки ядру. Например, старая ISA не-PnP карта Creative SoundBlaster(R) 16 использует драйвер man:snd_sbc[4] совместно с snd_sb16(4). Для этой карты к файлу настройки ядра необходимо добавить следующие строки:

[.programlisting]
....
device snd_sbc
device snd_sb16
....

и со следующей информацией в [.filename]#/boot/device.hints#:

[.programlisting]
....
hint.sbc.0.at="isa"
hint.sbc.0.port="0x220"
hint.sbc.0.irq="5"
hint.sbc.0.drq="1"
hint.sbc.0.flags="0x15"
....

В данном случае, карта использует порт ввода-вывода `0x220` и IRQ `5`.

Синтаксис, используемый в файле [.filename]#/boot/device.hints#, описан в справочной странице драйвера.

Установки, приведенные выше, используются по умолчанию. В некоторых случаях вам может потребоваться изменить IRQ или другие настройки в соответствии с настройками карты. За более подробной информацией обратитесь к странице справочника man:snd_sbc[4].

[[sound-testing]]
=== Тестирование звуковой карты

После перезагрузки модифицированного ядра, или после загрузки необходимого модуля, звуковая карта должна появиться в буфере системных сообщений (man:dmesg[8]) примерно так:

[source,shell]
....
pcm0: <Intel ICH3 (82801CA)> port 0xdc80-0xdcbf,0xd800-0xd8ff irq 5 at device 31.5 on pci0
pcm0: [GIANT-LOCKED]
pcm0: <Cirrus Logic CS4205 AC97 Codec>
....

Статус звуковой карты может быт проверен через файл [.filename]#/dev/sndstat#:

[source,shell]
....
# cat /dev/sndstat
FreeBSD Audio Driver (newpcm)
Installed devices:
pcm0: <Intel ICH3 (82801CA)> at io 0xd800, 0xdc80 irq 5 bufsz 16384
kld snd_ich (1p/2r/0v channels duplex default)
....

Вывод этой команды для вашей системы может отличаться. Если устройства [.filename]#pcm# не появились, вернитесь назад и проверьте выполненные действия. Проверьте файл настройки ядра еще раз и убедитесь, что выбрано подходящее устройство. Часто встречающиеся проблемы приведены в <<troubleshooting>>.

Если всё пройдет удачно, звуковая карта заработает. Если CD-ROM или DVD-ROM привод правильно подключён к звуковой карте, вы можете вставить CD в привод и воспроизвести его при помощи man:cdcontrol[1].

[source,shell]
....
% cdcontrol -f /dev/acd0 play 1
....

Различные приложения, например package:audio/workman[] могут предоставить более дружественный пользователю интерфейс. Вы можете также установить приложения для прослушивания звуковых файлов MP3, как например package:audio/mpg123[]. Быстрым способом тестирования звуковой карты является отправка данных в файл [.filename]#/dev/dsp#, как показано здесь:

[source,shell]
....
% cat filename > /dev/dsp
....

где _filename_ может быть любым файлом. Результатом выполнения этой команды станет шум, который означает, что звуковая карта на самом деле работает.

Уровни громкости звука могут быть изменены командой man:mixer[8]. Более подробная информация находится на странице справочной системы man:mixer[8].

[[troubleshooting]]
==== Часто встречающиеся проблемы

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Ошибка
| Решение

|`unsupported subdevice XX`
|

Одно или более устройств не были правильно созданы. Повторите приведенные выше шаги.

|`sb_dspwr(XX) timed out`
|

Порт ввода-вывода указан неправильно.

|`bad irq XX`
|

IRQ установлен неправильно. Убедитесь, что настройки в системе и на карте одинаковы.

|`xxx: gus pcm not attached, out of memory`
|

Для использования устройства недостаточно памяти.

|`xxx: can't open /dev/dsp!`
|

Проверьте с помощью `fstat \| grep dsp`, не занято ли устройство другим приложением. Создать проблемы могут esound и поддержка звука в KDE.
|===

[[sound-multiple-sources]]
=== Использование нескольких источников звука

Достаточно часто встречается необходимость иметь несколько источников звука, которые должны воспроизводить одновременно, например когда esound или artsd не поддерживают совместное использование звукового устройства с некоторым приложением.

FreeBSD позволяет делать это при помощи _виртуальных звуковых каналов_, которые могут быть настроены с помощью man:sysctl[8]. Виртуальные каналы позволяют вам мультиплексировать каналы воспроизведения звуковой карты, смешивая звук в ядре.

Для установки количества виртуальных каналов вы можете использовать две переменные sysctl, которые, если вы пользователь `root`, могут быть установлены таким образом:

[source,shell]
....
# sysctl hw.snd.pcm0.vchans=4
# sysctl hw.snd.maxautovchans=4
....

В этом примере выделяются четыре виртуальных канала, чего вполне достаточно для повседневного использования. `hw.snd.pcm0.vchans` это количество виртуальных каналов устройства [.filename]#pcm0#, оно может быть установлено сразу же, как только устройство было подключено. `hw.snd.maxautovchans` это количество виртуальных каналов, которые выделяются новому аудио устройству, когда оно подключается при помощи man:kldload[8]. Так как модуль [.filename]#pcm# может быть загружен независимо от аппаратных драйверов, `hw.snd.maxautovchans` может указывать количество виртуальных каналов для любых устройств, которые будут подключены позже.

[NOTE]
====
Количество виртуальных каналов не может быть изменено, если аудио устройство занято. Вам потребуется предварительно закрыть все программы, работающие со звуком, такие как медиа-проигрыватели или звуковые даемоны.
====

Если вы не используете man:devfs[5], необходимо будет указать приложениям [.filename]#/dev/dsp0#._x_, где _x_ это число от 0 до 3, если `hw.snd.pcm0.vchans` установлено в значение 4. Для системы, использующей man:devfs[5], вышеуказанные настройки будут сделаны автоматически прозрачно для пользователя.

=== Установка значений по умолчанию для каналов mixer

Значения по умолчанию для различных каналов mixer жестко прописаны в исходных текстах драйвера man:pcm[4]. Существует множество различных приложений и даемонов, которые позволяют устанавливать значения для mixer, которые они запоминают и выставляют каждый раз при запуске, но это не совсем правильное решение, нам нужны значения по умолчанию на уровне драйвера. Они могут быть установлены путем указания в [.filename]#/boot/device.hints#. Например:

[.programlisting]
....
hint.pcm.0.vol="100"
....

Установит значение для канала volume в значение по умолчанию 100, как только будет загружен модуль man:pcm[4].

[[sound-mp3]]
== Звук MP3

MP3 (MPEG Layer 3 Audio) достигает качества звука, близкого к CD, и нет причин не воспользоваться им на вашей рабочей станции.

[[mp3-players]]
=== Проигрыватели MP3

На данный момент наиболее популярным MP3-проигрывателем для X11 является XMMS (X Multimedia System). Скины приложения WinAMP могут быть использованы для XMMS так как графический интерфейс пользователя практически идентичен интерфейсу программы WinAMP от Nullsoft. XMMS поддерживает также собственные расширения.

XMMS может быть установлен из порта или пакета package:multimedia/xmms[].

Интерфейс XMMS интуитивно понятен и включает в себя список песен, графический эквалайзер и многое другое. Те, кто знаком с WinAMP, найдут XMMS очень простым в использовании.

Порт package:audio/mpg123[] является альтернативой, это MP3-проигрыватель для командной строки.

mpg123 может быть запущен с указанием звукового устройства и файла MP3 в командной строке как показано ниже:

[source,shell]
....
# mpg123 -a /dev/dsp1.0 Foobar-GreatestHits.mp3
High Performance MPEG 1.0/2.0/2.5 Audio Player for Layer 1, 2 and 3.
Version 0.59r (1999/Jun/15). Written and copyrights by Michael Hipp.
Uses code from various people. See 'README' for more!
THIS SOFTWARE COMES WITH ABSOLUTELY NO WARRANTY! USE AT YOUR OWN RISK!

Playing MPEG stream from Foobar-GreatestHits.mp3 ...
MPEG 1.0 layer III, 128 kbit/s, 44100 Hz joint-stereo
....

`/dev/dsp1.0` должно быть заменено соответствующим устройством [.filename]#dsp# для вашей системы.

[[rip-cd]]
=== Копирование аудио дорожек с CD

Перед тем как преобразовывать CD или дорожку CD в MP3, аудио данные на CD должны быть скопированы на жёсткий диск. Это можно сделать путём копирования данных CDDA (CD Digital Audio) в файл WAV.

Утилита `cdda2wav`, которая является частью пакета package:sysutils/cdrtools[], может быть использована для копирования аудио информации с CD, а также различной связанной информации.

Когда музыкальный CD находится в приводе, следующая команда может быть выполнена под `root` для того, чтобы скопировать весь CD в отдельные (один на каждую дорожку) WAV файлы:

[source,shell]
....
# cdda2wav -D 0,1,0 -B
....

cdda2wav поддерживает ATAPI (IDE) приводы CDROM. Для копирования с IDE привода, укажите имя устройства вместо номеров SCSI. Например, для того, чтобы скопировать 7-ую аудио дорожку с IDE-привода:

[source,shell]
....
# cdda2wav -D /dev/acd0 -t 7
....

Параметр `-D _0,1,0_` указывает устройство SCSI [.filename]#0,1,0#, соответственно результату работы `cdrecord -scanbus`.

Для того, чтобы копировать отдельные дорожки, используйте параметр `-t` как показано ниже:

[source,shell]
....
# cdda2wav -D 0,1,0 -t 7
....

Этот пример показывает как скопировать 7-ю дорожку музыкального CD. Для того чтобы скопировать набор дорожек, например, с первой по седьмую, укажите диапазон:

[source,shell]
....
# cdda2wav -D 0,1,0 -t 1+7
....

Утилита man:dd[1] также может быть использована для копирования аудио дорожек на приводах ATAPI, для того, чтобы узнать больше об этом, прочитайте crossref:disks[duplicating-audiocds,Копирование аудио CD].

[[mp3-encoding]]
=== Создание файлов MP3

На сегодняшний день наилучшим выбором программы для создания mp3 является lame. Lame находится в дереве портов в подкаталоге package:audio/lame[].

Используя скопированные файлы WAV, следующая команда преобразует [.filename]#audio01.wav# в [.filename]#audio01.mp3#:

[source,shell]
....
# lame -h -b 128 \
--tt "Foo Song Title" \
--ta "FooBar Artist" \
--tl "FooBar Album" \
--ty "2001" \
--tc "Ripped and encoded by Foo" \
--tg "Genre" \
audio01.wav audio01.mp3
....

Частота 128 килобит является стандартом "де факто" для MP3. Многие, однако, используют более высокие частоты для получения лучшего качества, 160 или 192 килобита. Чем выше частота, тем больше дискового пространства будет занимать получаемый MP3, но качество будет выше. Параметр `-h` включает режим "лучшее качество, но меньше скорость". Параметры, начинающиеся с `--t` указывают теги ID3, которые обычно содержат информацию о песне, включаемую в файл MP3. О дополнительных настройках преобразования можно узнать, прочитав страницу руководства lame.

[[mp3-decoding]]
=== Декодирование MP3

Для того, чтобы записать музыкальный CD из файлов MP3, они должны быть преобразованы в несжатый формат WAV. Как XMMS, так и mpg123 поддерживают вывод MP3 в распакованный формат файлов.

Запись на диск в XMMS:

[.procedure]
====
. Запустите XMMS:
. Нажмите правой кнопкой мыши в главном окне XMMS для того, чтобы показать меню.
. Выберите `Preferences` (либо `Свойства`, если у вас локализованная версия XMMS) в `Options`.
. Измените расширение вывода на "Disk Writer Plugin" (или "Расширение записи на диск", если у вас локализованная версия XMMS).
. Нажмите `Configure` (или "Настройка", если у вас локализованная версия XMMS).
. Введите (или выберите при помощи обзора) каталог, в который следует сохранять распакованные файлы.
. Загрузите файл MP3 в XMMS как вы это делаете обычно. Установите громкость на 100% и отключите эквалайзер.
. Нажмите `Воспроизвести` - XMMS будет выглядеть так же как и при обычном воспроизведении MP3, но самой музыки слышно не будет. На самом деле MP3 воспроизводится в файл.
. Убедитесь, что вы установили расширение вывода таким, как оно было до этого, для того, чтобы снова слушать MP3.
====

Запись в stdout в mpg123:

[.procedure]
====
. Запустите `mpg123 -s _audio01.mp3_ > audio01.pcm`
====

XMMS записывает файл в формате WAV, в то время как mpg123 преобразовывает MP3 в простые аудио данные PCM. Оба формата могут быть использованы cdrecord для создания музыкальных CD. Для использования man:burncd[8] вам потребуются простые аудио данные PCM. Если же вы будете использовать файлы в формате WAV, то заметите небольшой щелчок в начале каждой аудио дорожки, этот щелчок - заголовок файла в формате WAV. Вы очень просто можете избавиться от него путём удаления заголовка WAV при помощи утилиты SoX (она может быть установлена из порта package:audio/sox[] или соответствующего пакета:

[source,shell]
....
% sox -t wav -r 44100 -s -w -c 2 track.wav track.raw
....

Прочтите crossref:disks[creating-cds,Запись и использование оптических носителей (CD)] для того, чтобы узнать больше о записи CD в FreeBSD.

[[video-playback]]
== Воспроизведение видео

Воспроизведение видео является очень новой и быстро развивающейся областью применения. Будьте терпеливы. Не всё будет работать так беспроблемно, как это было со звуком.

Прежде, чем вы начнёте, определите модель видеокарты и чипсет, который она использует. Хотя Xorg и XFree86(TM) поддерживают множество различных видеокарт, только их малая часть показывает хорошую скорость воспроизведения видео. Для того, чтобы получить список расширений, поддерживаемых X-сервером, который используется вашей видеокартой, используйте команду man:xdpyinfo[1] во время работы X11.

Неплохо также иметь небольшой файл MPEG, который бы использовался как тестовый файл для проверки различных проигрывателей и настроек. Так как некоторые проигрыватели DVD будут искать носитель DVD как [.filename]#/dev/dvd# по умолчанию или быть жёстко настроены на него, возможно будет полезно сделать символические ссылки на правильные устройства:

[source,shell]
....
# ln -sf /dev/acd0 /dev/dvd
# ln -sf /dev/acd0 /dev/rdvd
....

Обратите внимание, природа man:devfs[5] такова, что такие созданные вручную ссылки не сохраняются при перезагрузке системы. Для автоматического создания символических ссылок при каждой загрузке системы добавьте в [.filename]#/etc/devfs.conf# следующие строки:

[.programlisting]
....
link acd0 dvd
link acd0 rdvd
....

Кроме того, декодирование DVD требует доступа к специальным функциям DVD-ROM, поэтому должен быть доступ на запись для устройств DVD.

Для того, чтобы улучшить работу разделяемой памяти X11, рекомендуется увеличить значения некоторых переменных man:sysctl[8]:

[.programlisting]
....
kern.ipc.shmmax=67108864
kern.ipc.shmall=32768
....

[[video-interface]]
=== Определение возможностей видео

Существует несколько возможных путей отображения видео под X11. Что именно будет действительно работать, во многом зависит от аппаратного обеспечения. Каждый из описанных методов будет работать с различным качеством на разном аппаратном обеспечении. Во-вторых, воспроизведение видео в X11, это тема, которой уделяется достаточно много внимания последнее время, и с каждой новой версией Xorg или XFree86(TM) могут наблюдаться значительные улучшения.

Список наиболее часто используемых видеоинтерфейсов:

. X11: обычный вывод X11 с использованием разделяемой памяти.
. XVideo: расширение интерфейса X11, которое поддерживает видео в любом объекте X11.
. SDL: the Simple Directmedia Layer.
. DGA: the Direct Graphics Access - прямой доступ для графики.
. SVGAlib: низкоуровневый доступ к графике на консоли.

[[video-interface-xvideo]]
==== XVideo

Xorg и XFree86(TM) 4.X включают в себя расширение, называющееся _XVideo_ (также известное как Xvideo, Xv и xv), которое позволяет отображать видео прямо на объектах при помощи специального ускорения. Это расширение предоставляет очень хорошее качество воспроизведения даже на low-end машинах.

Для того чтобы проверить, работает ли это расширение, используйте команду `xvinfo`:

[source,shell]
....
% xvinfo
....

XVideo поддерживается вашей видеокартой, если результат выглядит приблизительно так:

[source,shell]
....
X-Video Extension version 2.2
screen #0
  Adaptor #0: "Savage Streams Engine"
    number of ports: 1
    port base: 43
    operations supported: PutImage
    supported visuals:
      depth 16, visualID 0x22
      depth 16, visualID 0x23
    number of attributes: 5
      "XV_COLORKEY" (range 0 to 16777215)
              client settable attribute
              client gettable attribute (current value is 2110)
      "XV_BRIGHTNESS" (range -128 to 127)
              client settable attribute
              client gettable attribute (current value is 0)
      "XV_CONTRAST" (range 0 to 255)
              client settable attribute
              client gettable attribute (current value is 128)
      "XV_SATURATION" (range 0 to 255)
              client settable attribute
              client gettable attribute (current value is 128)
      "XV_HUE" (range -180 to 180)
              client settable attribute
              client gettable attribute (current value is 0)
    maximum XvImage size: 1024 x 1024
    Number of image formats: 7
      id: 0x32595559 (YUY2)
        guid: 59555932-0000-0010-8000-00aa00389b71
        bits per pixel: 16
        number of planes: 1
        type: YUV (packed)
      id: 0x32315659 (YV12)
        guid: 59563132-0000-0010-8000-00aa00389b71
        bits per pixel: 12
        number of planes: 3
        type: YUV (planar)
      id: 0x30323449 (I420)
        guid: 49343230-0000-0010-8000-00aa00389b71
        bits per pixel: 12
        number of planes: 3
        type: YUV (planar)
      id: 0x36315652 (RV16)
        guid: 52563135-0000-0000-0000-000000000000
        bits per pixel: 16
        number of planes: 1
        type: RGB (packed)
        depth: 0
        red, green, blue masks: 0x1f, 0x3e0, 0x7c00
      id: 0x35315652 (RV15)
        guid: 52563136-0000-0000-0000-000000000000
        bits per pixel: 16
        number of planes: 1
        type: RGB (packed)
        depth: 0
        red, green, blue masks: 0x1f, 0x7e0, 0xf800
      id: 0x31313259 (Y211)
        guid: 59323131-0000-0010-8000-00aa00389b71
        bits per pixel: 6
        number of planes: 3
        type: YUV (packed)
      id: 0x0
        guid: 00000000-0000-0000-0000-000000000000
        bits per pixel: 0
        number of planes: 0
        type: RGB (packed)
        depth: 1
        red, green, blue masks: 0x0, 0x0, 0x0
....

Следует заметить, что перечисленные форматы (YUV2, YUV12 и т.п.) не присутствуют в каждой реализации XVideo и их отсутствие может быть помехой для некоторых проигрывателей.

Если результат выглядит так:

[source,shell]
....
X-Video Extension version 2.2
screen #0
no adaptors present
....

то, возможно, XVideo не поддерживается для вашей видеокарты.

Если XVideo не поддерживается вашей видеокартой, то это всего лишь означает, что будет сложнее получить приемлемые для воспроизведения видео вычислительные мощности. В зависимости от вашей видеокарты и процессора, возможно, вы сможете получить удовлетворительный результат. Возможно, вы должны будете прочитать о путях улучшения производительности в <<video-further-reading>>.

[[video-interface-SDL]]
==== Simple Directmedia Layer

SDL был задуман как уровень абстракции для разработки кросплатформенных приложений под Microsoft(R) Windows(R), BeOS и UNIX(R), позволяя им эффективно использовать звук и графику. SDL предоставляет низкоуровневые абстракции для аппаратного обеспечения, и может быть более эффективным чем интерфейс X11.

SDL есть в Коллекции портов FreeBSD: package:devel/sdl12[].

[[video-interface-DGA]]
==== Прямой доступ для графики (DGA)

DGA это расширение X11, которое позволяет программам напрямую изменять кадровый буфер (framebuffer) без участия X-сервера. Поскольку DGA основывается на низкоуровневом доступе к памяти, программы, которые используют его должны исполняться от пользователя `root`.

Расширение DGA может быть протестировано при помощи man:dga[1]. Когда `dga` запущена, она изменяет цвета на экране при каждом нажатии клавиш. Для того, чтобы выйти из неё, используйте kbd:[q].

[[video-ports]]
=== Порты и пакеты для работы с видео

Этот раздел обсуждает программное обеспечение для работы с видео из Коллекции Портов FreeBSD. Воспроизведение видео является очень активной сферой разработок программного обеспечения и возможности различных приложений могут несколько отличаться от описанных здесь.

Во-первых, важно помнить, что многие приложения для работы с видео, которые работают на FreeBSD, были разработаны как приложения Linux. Многие из этих приложений все еще бета-качества. Вот некоторые проблемы, которые могут встретиться в работе видео пакетов на FreeBSD:

. Приложение не может воспроизвести файл, который создало другое приложение.
. Приложение не может воспроизвести файл, который создало само.
. Одно и то же приложение на разных машинах, скомпилированное на каждой машине специально для неё, воспроизводит один и тот же файл различно.
. Кажущийся тривиальным фильтр, например фильтр изменения размеров изображения, приводит к очень плохим "артефактам" из-за неправильной функции изменения размера.
. Приложение часто не работает (оставляет core-файл).
. Документация не устанавливается вместе с портом и может быть найдена лишь на сайте или в каталоге порта [.filename]#work#.

Многие из этих приложений могут также проявлять "линуксизмы". Так, это могут быть некоторые проблемы, связанные со способом реализации некоторых стандартных библиотек в дистрибутивах Linux, или некоторыми дополнительными возможностями ядра Linux, которые авторы приложений посчитали существующими везде. Эти проблемы не всегда могут быть обнаружены людьми, поддерживающими порт (порты), вследствие чего могут возникнуть проблемы, сходные с нижеперечисленными:

. Использование [.filename]#/proc/cpuinfo# для того, чтобы определить характеристики процессора.
. Неправильное использование нитей (threads), которое может привести к зависанию программы при завершении вместо нормального выхода.
. Программного обеспечения, которое обычно используется совместно с данным приложением, ещё нет в Коллекции Портов FreeBSD.

Таким образом, разработчики этих приложений должны сотрудничать с людьми, поддерживающими порты, для того, чтобы минимизировать количество обходных путей, необходимых для портирования.

[[video-mplayer]]
==== MPlayer

MPlayer это недавно разработанный и быстро развивающийся проигрыватель видео. Задачами команды разработчиков MPlayer являются скорость и гибкость при работе на Linux и других Unix-системах. Проект был начат, когда его основатель стал сыт по горло плохой производительностью и качеством проигрывателей того времени. Некоторые могут сказать, что графический интерфейс был принесён в жертву рационализированному дизайну. Однако, как только вы привыкнете к опциям командной строки MPlayer и его управлению с клавиатуры, всё будет хорошо.

[[video-mplayer-building]]
===== Компиляция MPlayer

MPlayer находится в package:multimedia/mplayer[]. MPlayer производит различные тесты аппаратного обеспечения во время процесса компиляции, в результате чего полученные исполняемые модули не могут быть перенесены с одной системы на другую. Поэтому важно собирать его из портов, а не использовать бинарный пакет. Также, при сборке вы можете указать различные установки при помощи параметров командной строки `make`, как описывается в [.filename]#Makefile# в начале сборки:

[source,shell]
....
# cd /usr/ports/multimedia/mplayer
# make
N - O - T - E

Take a careful look into the Makefile in order
to learn how to tune mplayer towards you personal preferences!
For example,
make WITH_GTK1
builds MPlayer with GTK1-GUI support.
If you want to use the GUI, you can either install
/usr/ports/multimedia/mplayer-skins
or download official skin collections from
http://www.mplayerhq.hu/homepage/dload.html
....

Параметры порта по умолчанию должны подходить большинству пользователей. Однако, если вам необходим кодек XviD, необходимо указать в командной строке параметр `WITH_XVID`. Устройство DVD по умолчанию также может быть указано в командной строке параметром `WITH_DVD_DEVICE`, по умолчанию используется [.filename]#/dev/acd0#.

На время написания данного документа порт MPlayer'а собирает и устанавливает свою документацию в формате HTML и два исполняемых файла, `mplayer` и `mencoder`, который является утилитой для перекодировки видео.

Документация к MPlayer очень информативна. Если читатель найдет информацию этой главы о аппаратном обеспечении для поддержки видео и интерфейсах недостаточной, то документация MPlayer будет очень хорошим дополнением. Обязательно уделите время чтению документации MPlayer, если вам нужна информация о поддержке видео под UNIX(R).

[[video-mplayer-using]]
===== Использование MPlayer

Каждый пользователь MPlayer должен создать подкаталог [.filename]#.mplayer# в своем домашнем каталоге. Для того, чтобы его создать, выполните следующие действия:

[source,shell]
....
% cd /usr/ports/multimedia/mplayer
% make install-user
....

Параметры для `mplayer` перечислены в страничке руководства mplayer. За более подробной информацией вы можете обратиться к документации в формате HTML. В этом разделе мы опишем несколько самых распространённых случаев использования mplayer.

Для того, чтобы воспроизвести файл, например [.filename]#testfile.avi# через один из многих видеоинтерфейсов, используйте параметр `-vo`:

[source,shell]
....
% mplayer -vo xv testfile.avi
....

[source,shell]
....
% mplayer -vo sdl testfile.avi
....

[source,shell]
....
% mplayer -vo x11 testfile.avi
....

[source,shell]
....
# mplayer -vo dga testfile.avi
....

[source,shell]
....
# mplayer -vo 'sdl:dga' testfile.avi
....

Стоит испробовать все варианты интерфейсов, так как их производительность зависит от множества факторов и будет заметно меняться в зависимости от аппаратного обеспечения.

Для того, чтобы воспроизвести DVD, замените [.filename]#testfile.avi# на `dvd://_N_ -dvd-device _DEVICE_`, где _N_ является номером дорожки, с которой следует начать воспроизведение и [.filename]#DEVICE# файл устройства привода DVD. Например, для того, чтобы воспроизвести дорожку 3 с [.filename]#/dev/dvd#:

[source,shell]
....
# mplayer -vo xv dvd://3 -dvd-device /dev/dvd
....

[NOTE]
====
Устройство DVD по умолчанию может быть определено во время сборки порта MPlayer параметром `WITH_DVD_DEVICE`. По умолчанию, это устройство [.filename]#/dev/acd0#. Дополнительную информацию можно найти в [.filename]#Makefile# порта.
====

Для того, чтобы остановить, приостановить или продолжить воспроизведение, воспользуйтесь привязкой клавиш, информация о которой может быть получена посредством запуска `mplayer -h`, либо на страничке документации.

Дополнительные, достаточно важные параметры воспроизведения: `-fs -zoom`, которые включают полноэкранный режим и `-framedrop`, который улучшает производительность на медленных системах.

Для того, чтобы командная строка запуска mplayer не становилась слишком большой, пользователь может создать файл [.filename]#.mplayer/config# и установить параметры по умолчанию там:

[.programlisting]
....
vo=xv
fs=yes
zoom=yes
....

Также `mplayer` может быть использован для копирования дорожек DVD в [.filename]#.vob# файлы. Для того, чтобы скопировать вторую дорожку DVD необходимо выполнить следующую команду:

[source,shell]
....
# mplayer -dumpstream -dumpfile out.vob dvd://2 -dvd-device /dev/dvd
....

Полученный файл, [.filename]#out.vob#, будет представлять собой MPEG, с которым можно производить различные действия при помощи программ, которые будут описаны далее в этом разделе.

[[video-mencoder]]
===== mencoder

Перед использованием `mencoder`, было бы неплохо ближе ознакомится с его параметрами, используя документацию в формате HTML. Также существует страничка справочника mplayer, но она не очень полезна без HTML документации. Существует бесчисленное множество способов улучшения качества, снижения битрейта и изменения формата; и некоторые из этих приёмов могут влиять на производительность. Ниже приведено несколько примеров использования `mencoder`. Во-первых, простое копирование:

[source,shell]
....
% mencoder input.avi -oac copy -ovc copy -o output.avi
....

Неправильная комбинация параметров командной строки может привести к появлению файлов, которые невозможно будет воспроизвести даже `mplayer`. Поэтому, если вы хотите скопировать изображение в файл, лучше использовать только параметр `mplayer -dumpfile`.

Для того, чтобы преобразовать [.filename]#input.avi# в MPEG4 со звуком в формате MPEG Audio Layer 3 (MP3) (требуется package:audio/lame[]):

[source,shell]
....
% mencoder input.avi -oac mp3lame -lameopts br=192 \
     -ovc lavc -lavcopts vcodec=mpeg4:vhq -o output.avi
....

Эта команда создаст файл, воспроизводимый `mplayer` и `xine`.

[.filename]#input.avi# может быть заменён на `dvd://1 -dvd-device /dev/dvd` и `mplayer`, запущенный от пользователя `root`, будет преобразовывать дорожку DVD напрямую. Так как первый раз, скорее всего, вы будете недовольны полученными результатами, всё же рекомендуется копировать дорожку в файл и работать затем с файлом.

[[video-xine]]
==== Проигрыватель хine

xine - это большой проект, в задачи которого входит не только создание решения для видео все-в-одном, но и создание базовой библиотеки с возможностью расширения путем использования плагинов. Поставляется он как в виде порта, так и в виде пакета, package:multimedia/xine[].

xine все еще несовершенен, но все-таки это хорошее начало. На практике xine требует либо быстрого процессора с быстрой видеокартой или поддержки расширения XVideo. Графический интерфейс можно использовать, но он все еще немного неуклюж.

На время написания этого документа в поставке xine не существовало модуля ввода, который бы мог воспроизводить DVD, закодированные по алгоритму CSS. Существуют сборки, в которых есть такой модуль, но ни одна из них не входит в Коллекцию Портов FreeBSD.

По сравнению с MPlayer, xine является более дружелюбным к пользователю, но, в то же время, скрывает более тонкие настройки и управление от пользователя. Также xine лучше работает на XVideo интерфейсах.

По умолчанию, xine запускается с графическим интерфейсом. Для открытия файлов используются меню.

[source,shell]
....
% xine
....

В качестве альтернативы можно использовать его для запуска файла непосредственно, без GUI, следующей командой:

[source,shell]
....
% xine -g -p mymovie.avi
....

[[video-ports-transcode]]
==== Утилиты transcode

Приложение transcode не является проигрывателем. Это набор инструментов для преобразования видео и звуковых файлов. При помощи transcode можно объединять видеофайлы, исправлять поврежденные файлы, использовать инструменты командной строки для работы с потоками ввода/вывода [.filename]#stdin/stdout#.

Большое количество опций может быть указано во время сборки порта package:multimedia/transcode[]. Для сборки transcode мы рекомендуем использовать следующую командную строку:

[source,shell]
....
# make WITH_OPTIMIZED_CFLAGS=yes WITH_LIBA52=yes WITH_LAME=yes WITH_OGG=yes \
WITH_MJPEG=yes -DWITH_XVID=yes
....

Предложенных установок должно быть достаточно для большинства пользователей.

Для иллюстрации возможностей `transcode` приводится пример, показывающий как сконвертировать файл DivX формата в PAL MPEG-1 файл (PAL VCD):

[source,shell]
....
% transcode -i input.avi -V --export_prof vcd-pal -o output_vcd
% mplex -f 1 -o output_vcd.mpg output_vcd.m1v output_vcd.mpa
....

Итоговый MPEG файл [.filename]#output_vcd.mpg# может быть проигран с помощью MPlayer. Вы можете даже записать файл на CD-R носитель для создания Video CD. В этом случае, вам нужно будет установить и использовать программы package:multimedia/vcdimager[] и package:sysutils/cdrdao[].

Существует страничка справочника для `transcode`, но вы также должны проконсультироваться с http://www.transcoding.org/cgi-bin/transcode[transcode wiki] для получения более детальной информации и примеров.

[[video-further-reading]]
=== Дальнейшее чтение

Различные пакеты видео программ для FreeBSD интенсивно разрабатываются. Очень возможно, что в ближайшем будущем многие обсуждаемые здесь проблемы разрешатся. Это займет время, и те, кто желает получить максимум от аудио/видео возможностей FreeBSD, должны будут собирать необходимые знания из нескольких списков часто задаваемых вопросов и обучающих статей, а также использовать различные приложения. Этот раздел существует для того, чтобы читатель мог получить указания на несколько источников дополнительной информации.

http://www.mplayerhq.hu/DOCS/[Документация MPlayer] очень содержательна в техническом плане. Возможно, эти документы должны использоваться любым человеком, желающим получить высокий уровень знаний о видео на UNIX(R) системах. Список рассылки MPlayer враждебен для любого, кто не потрудился прочитать документацию, так что, если у вас есть желание сообщать о найденных ошибках, прочитайте вначале документацию.

http://dvd.sourceforge.net/xine-howto/en_GB/html/howto.html[xine HOWTO] содержит главу об улучшении производительности, которая применима к любому проигрывателю.

Наконец, существует несколько многообещающих приложений, которые читатель может испробовать:

* http://avifile.sourceforge.net/[Avifile], для которого также существует порт package:multimedia/avifile[].
* http://www.dtek.chalmers.se/groups/dvd/[Ogle], для которого также существует порт package:multimedia/ogle[].
* http://xtheater.sourceforge.net/[Xtheater]
* package:multimedia/dvdauthor[], пакет с открытыми текстами для распространения DVD контента.

[[tvcard]]
== Настройка ТВ тюнеров

=== Введение

ТВ тюнеры предназначены для просмотра широковещательного или кабельного телевидения на компьютере. Большинство тюнеров поддерживают композитный видео вход RCA или S-video, а некоторые из них поставляются с FM радио тюнером.

FreeBSD поддерживает PCI ТВ тюнеры, использующие Brooktree Bt848/849/878/879 или Conexant CN-878/Fusion 878a Video Capture Chip через драйвер man:bktr[4]. Вы должны также убедиться, что тюнер поддерживается; обратитесь к странице справочника man:bktr[4] за списком поддерживаемых тюнеров.

=== Добавление драйвера

Для использования карты потребуется загрузить драйвер man:bktr[4], что можно сделать, добавив в [.filename]#/boot/loader.conf# следующую строку:

[.programlisting]
....
bktr_load="YES"
....

В качестве альтернативы, вы можете статически скомпилировать ядро с поддержкой ТВ тюнера; добавьте следующие строки в файл конфигурации ядра:

[.programlisting]
....
device	 bktr
device	iicbus
device	iicbb
device	smbus
....

Эти дополнительные драйвера устройств необходимы, поскольку компоненты карты соединены через шину I2C. Затем соберите и установите новое ядро.

Как только поддержка тюнера будет добавлена в систему, перегрузите компьютер. Во время загрузки TV карта должна отобразить примерно такие строки:

[.programlisting]
....
bktr0: <BrookTree 848A> mem 0xd7000000-0xd7000fff irq 10 at device 10.0 on pci0
iicbb0: <I2C bit-banging driver> on bti2c0
iicbus0: <Philips I2C bus> on iicbb0 master-only
iicbus1: <Philips I2C bus> on iicbb0 master-only
smbus0: <System Management Bus> on bti2c0
bktr0: Pinnacle/Miro TV, Philips SECAM tuner.
....

Конечно, эти сообщения будут различаться на разном оборудовании. Тем не менее, проверьте, что тюнер определяется правильно; возможна перезапись параметров, определенных ядром, с помощью man:sysctl[8] MIB и параметров в файле настройки ядра. Например, если вы хотите указать, что это Philips SECAM тюнер, добавьте следующую строку к файлу настройки ядра:

[.programlisting]
....
options OVERRIDE_TUNER=6
....

или прямо задайте переменную man:sysctl[8]:

[source,shell]
....
# sysctl hw.bt848.tuner=6
....

Обратитесь к странице man:bktr[4] и файлу [.filename]#/usr/src/sys/conf/NOTES# за более детальной информацией о доступных параметрах.

=== Полезные приложения

Для использования ТВ тюнера вам потребуется установить одно из следующих приложений:

* package:multimedia/fxtv[] предоставляет возможности ТВ-в-окне и захвата изображений/аудио/видео.
* package:multimedia/xawtv[] это также приложение для ТВ тюнера, с теми же, что и у fxtv возможностями.
* package:misc/alevt[] раскодирует и отображает видеотекст/телетекст.
* package:audio/xmradio[], приложение для использования с FM радио тюнером, поставляемым с некоторыми ТВ тюнерами.
* package:audio/wmtune[], это удобное приложение для радио тюнеров.

В коллекции портов FreeBSD можно найти и другие приложения.

=== Решение проблем

Если вы столкнулись с какой-либо проблемой, связанной с ТВ тюнером, проверьте в первую очередь поддержку микросхемы захвата видео и тюнера драйвером man:bktr[4], а также правильность установки параметров. За дальнейшей поддержкой и с вопросами о ТВ тюнере вы можете обращаться в {freebsd-multimedia} и использовать его архивы.

[[scanners]]
== Сканеры

=== Введение

В FreeBSD доступ к сканерам обеспечивается программой SANE (Scanner Access Now Easy), обеспечивающей универсальный интерфейс (API) и доступной в коллекции портов FreeBSD. Для общения со сканерами SANE использует некоторые драйвера устройств FreeBSD.

FreeBSD поддерживает сканеры с интерфейсом как SCSI, так и USB. Убедитесь, что ваш сканер поддерживается SANE перед тем, как приступить к конфигурации. Для SANE существует http://www.sane-project.org/sane-supported-devices.html[список поддерживаемых устройств] где находится информация о поддержке сканера и статусе этой поддержки. Кроме того, страница справочника man:uscanner[4] также перечисляет поддерживаемые устройства.

=== Конфигурация ядра

Как уже отмечалось, поддерживаются как SCSI, так и USB сканеры. В зависимости от интерфейса вашего сканера требуется поддержка разных драйверов устройств.

[[scanners-kernel-usb]]
==== USB

Стандартное ядро [.filename]#GENERIC# включает в себя драйвера, необходимые для поддержки USB сканеров. Если вы компилируете собственное ядро, убедитесь, что в его конфигурации присутствуют строки

[.programlisting]
....
device usb
device uhci
device ohci
device uscanner
....

В зависимости от чипсета USB, встроенного в вашу материнскую плату, потребуется лишь один из драйверов `device uhci` или `device ohci`, однако, наличие обеих строк в конфигурации ядра никому не повредит.

Если вы не хотите перестраивать ядро, и при этом ваше ядро не является стандартным ([.filename]#GENERIC#), вы можете загрузить модуль драйвера поддержки сканеров man:uscanner[4] при помощи команды man:kldload[8]:

[source,shell]
....
# kldload uscanner
....

Для автоматической загрузки модуля при старте системы добавьте в файл [.filename]#/boot/loader.conf# строку

[.programlisting]
....
uscanner_load="YES"
....

После перезагрузки с новым ядром или загрузки модуля подключите ваш USB сканер. В буфере системных сообщений (man:dmesg[8]) должна появиться строка об обнаружении сканера:

[source,shell]
....
uscanner0: EPSON EPSON Scanner, rev 1.10/3.02, addr 2
....

В данном случае сканер будет использовать устройство [.filename]#/dev/uscanner0#.

==== SCSI

Если ваш сканер имеет интерфейс SCSI, важно знать, к какому контроллеру он подключен. В зависимости от контроллера потребуются различные драйвера в файле конфигурации ядра. Стандартное ядро [.filename]#GENERIC# поддерживает большинство распространенных SCSI-контроллеров. Внимательно прочитайте файл [.filename]#NOTES# и добавьте необходимые строки в файл конфигурации вашего ядра. Помимо строки для драйвера адаптера, вам потребуются следующие строки:

[.programlisting]
....
device scbus
device pass
....

После установки и загрузки нового ядра, в буфере системных сообщений должны появиться строки о вашем сканере, например:

[source,shell]
....
pass2 at aic0 bus 0 target 2 lun 0
pass2: <AGFA SNAPSCAN 600 1.10> Fixed Scanner SCSI-2 device
pass2: 3.300MB/s transfers
....

Если сканер не был включен в момент загрузки, его можно принудительно опознать, выполнив сканирование SCSI шины при помощи команды man:camcontrol[8]:

[source,shell]
....
# camcontrol rescan all
Re-scan of bus 0 was successful
Re-scan of bus 1 was successful
Re-scan of bus 2 was successful
Re-scan of bus 3 was successful
....

После этого сканер должен появиться в списке устройств:

[source,shell]
....
# camcontrol devlist
<IBM DDRS-34560 S97B>              at scbus0 target 5 lun 0 (pass0,da0)
<IBM DDRS-34560 S97B>              at scbus0 target 6 lun 0 (pass1,da1)
<AGFA SNAPSCAN 600 1.10>           at scbus1 target 2 lun 0 (pass3)
<PHILIPS CDD3610 CD-R/RW 1.00>     at scbus2 target 0 lun 0 (pass2,cd0)
....

Более подробная информация о устройствах SCSI доступна на страницах справочника man:scsi[4] и man:camcontrol[8].

=== Конфигурация SANE

Система SANE состоит из двух частей: аппаратной поддержки (backend, package:graphics/sane-backends[]) и программной поддержки (frontend, package:graphics/sane-frontends[]). Первая часть обеспечивает собственно доступ к сканеру. http://www.sane-project.org/sane-supported-devices.html[Список поддерживаемых устройств]SANE содержит информацию о необходимом вам аппаратном модуле. Вторая часть обеспечивает графический интерфейс для сканирования (xscanimage).

В первую очередь следует установить порт или пакет package:graphics/sane-backends[], после чего при помощи команды `sane-find-scanner` проверить поддержку сканера системой SANE:

[source,shell]
....
# sane-find-scanner -q
found SCSI scanner "AGFA SNAPSCAN 600 1.10" at /dev/pass3
....

В выводе должны присутствовать интерфейс сканера и имя используемого устройства. Производитель и модель сканера могут отсутствовать: это нормально.

[NOTE]
====
Некоторым USB сканерам может потребоваться загрузка прошивки. Подробности смотрите в страницах справочника драйвера сканера, man:sane-find-scanner[1] и man:linprocfs[7].
====

Теперь необходимо убедиться, что сканер опознан программой графического интерфейса. В состав системы SANE входит утилита man:sane[1], позволяющая работать со сканером из командной строки. Опция `-L` используется для показа информации о сканере:

[source,shell]
....
# scanimage -L
device `snapscan:/dev/pass3' is a AGFA SNAPSCAN 600 flatbed scanner
....

Отсутствие сообщений или сообщение об отсутствии устройств означает, что утилита man:sane[1] не смогла идентифицировать сканер. В этом случае вам потребуется отредактировать файл конфигурации аппаратного модуля и указать устройство, используемое сканером. Все файлы настройки находятся в каталоге [.filename]#/usr/local/etc/sane.d/#. Такие проблемы присущи некоторым моделям USB сканеров. 

Например, в случае USB сканера, описанного в <<scanners-kernel-usb>>, утилита `sane-find-scanner` выдаст следующую информацию: 

[source,shell]
....
# sane-find-scanner -q
found USB scanner (UNKNOWN vendor and product) at device /dev/uscanner0
....

Сканер обнаружен корректно, он использует интерфейс USB и доступен через устройство [.filename]#/dev/uscanner0#. Теперь попробуем идентифицировать его:

[source,shell]
....
# scanimage -L

No scanners were identified. If you were expecting something different,
check that the scanner is plugged in, turned on and detected by the
sane-find-scanner tool (if appropriate). Please read the documentation
which came with this software (README, FAQ, manpages).
....

Поскольку сканер не идентифицирован, нам потребуется изменить файл конфигурации [.filename]#/usr/local/etc/sane.d/epson.conf#. В нашем примере использован сканер EPSON Perfection(R) 1650, так что мы знаем, что будет использоваться драйвер `epson`. Не забудьте прочитать комментарии в файле конфигурации. Требуемые изменения весьма просты: закомментируйте все строки, описывающие интерфейсы, не соответствующие интерфейсу вашего сканера (в нашем случае, все строки, начинающиеся со `scsi`: наш сканер использует интерфейс USB), и добавьте в конец файла строку, содержащую интерфейс и имя использованного устройства. Мы добавим строку

[.programlisting]
....
usb /dev/uscanner0
....

Пожалуйста, прочтите комментарии в файле конфигурации, а также страницы справочника для более полной информации. Теперь мы можем проверить, что наш сканер опознан:

[source,shell]
....
# scanimage -L
device `epson:/dev/uscanner0' is a Epson GT-8200 flatbed scanner
....

Наш USB сканер опознан. Не столь важно, что имя и номер модели не совпадают, главное, что используются правильные имя устройства и драйвер: `epson:/dev/uscanner0`.

После того как команда `scanimage -L` опознала сканер, конфигурация завершена. Все готово к сканированию.

Хотя утилита man:sane[1] позволяет производить сканирование из командной строки, как правило, для сканирования предпочтительнее использовать графический интерфейс. Для этого в состав SANE входит простая, но эффективная утилита xscanimage (package:graphics/sane-frontends[]).

Другой популярной программой графического интерфейса к сканеру является Xsane (package:graphics/xsane[]). Эта программа поддерживает такие расширенные возможности, как разные режимы сканирования (фотокопия, факс и т.п.), цветокоррекцию, потоковое сканирование и другие. Оба приложения пригодны для использования в качестве плагинов сканирования для GIMP. 

=== Доступ к сканеру для других пользователей

Все описанные операции выполнялись нами с привилегиями суперпользователя (`root`). Вам может потребоваться дать доступ к сканеру другим пользователям. Для этого необходимо разрешить доступ на чтение и запись к файлу устройства, обслуживающему сканер. В нашем примере USB сканер использует устройство [.filename]#/dev/uscanner0#, принадлежащее группе `operator`. Добавление пользователя `joe` в группу `operator` разрешит ему использовать сканер: 

[source,shell]
....
# pw groupmod operator -m joe
....

За подробностями обращайтесь к странице справочника man:pw[8]. Вам также потребуется установить нужные права доступа (0660 или 0664) к устройству [.filename]#/dev/uscanner0#, поскольку по умолчанию группа `operator` может лишь читать из него. Это достигается добавлением следующей строки в файл [.filename]#/etc/devfs.rules#:

[.programlisting]
....
[system=5]
add path uscanner0 mode 660
....

Затем добавьте в файл конфигурации системы [.filename]#/etc/rc.conf# такую строку (после чего перезагрузите систему):

[.programlisting]
....
devfs_system_ruleset="system"
....

Подробную информацию о правах на файлы устройств вы найдете на странице справочника man:devfs[8].

[NOTE]
====
Разумеется, по соображениям безопасности, вы должны как следует подумать, прежде чем добавлять пользователя в другие группы, в особенности в группу `operator`.
====
