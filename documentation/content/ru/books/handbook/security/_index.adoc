---
title: Глава 14. Безопасность
part: Часть III. Системное администрирование
prev: books/handbook/boot
next: books/handbook/mac
showBookMenu: true
weight: 18
path: "/books/handbook/security/"
---

[[security]]
= Безопасность
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 14
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/security/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[security-synopsis]]
== Краткое описание

Эта глава представляет введение в основные концепции безопасности системы, некоторые эмпирические правила и более подробно обращается к отдельным темам, касающимся FreeBSD. Большая часть затрагиваемых тем может быть применена к безопасности системы и безопасности в интернет вообще. Интернет больше не то "дружественное" место, где каждый хочет быть вам добрым соседом. Защита системы необходима для сохранения ваших данных, интеллектуальной собственности, времени и всего остального от хакеров и им подобных.

FreeBSD предоставляет массу утилит и механизмов для обеспечения целостности и безопасности системы и сети.

После прочтения этой главы вы узнаете:

* Основные концепции безопасности системы, специфику FreeBSD.
* О различных механизмах шифрования в FreeBSD, таких как DES и MD5.
* Как настроить аутентификацию с использованием одноразовых паролей.
* Как настроить TCP Wrappers для использования с `inetd`.
* Как настроить KerberosIV в релизах FreeBSD до 5.0.
* Как настроить Kerberos5 в FreeBSD.
* Как настроить IPsec и создать VPN между компьютерами на FreeBSD/Windows(R).
* Как настроить и использовать OpenSSH, реализацию SSH в FreeBSD.
* Что такое ACL и как их использовать.
* Как использовать утилиту Portaudit для проверки пакетов сторонних разработчиков, установленных из Коллекции Портов.
* Как работать с сообщениями безопасности FreeBSD.
* Что такое Process Accounting и как активировать его во FreeBSD.

Перед чтением этой главы вам потребуется:

* Понимание основных концепций FreeBSD и интернет.

В этой книге рассмотрены и другие вопросы безопасности. Например, принудительный контроль доступа (Mandatory Access Control) рассматривается в crossref:mac[mac, Принудительный контроль доступа (MAC)], а брандмауэры в crossref:firewalls[firewalls, Межсетевые экраны].

[[security-intro]]
== Введение

Безопасность это первая и основная функция системного администратора. Хотя все многопользовательские системы BSD UNIX(R) уже снабжены некоторой защитой, работа по созданию и поддержке дополнительных механизмов безопасности, обеспечивающих защищенную работу пользователей, это одна из самых серьезных задач системного администратора. Компьютеры безопасны настолько, насколько вы сделаете их безопасными и требования безопасности всегда находятся в противоречии с удобством работы пользователей. Системы UNIX(R) способны одновременно работать с огромным количеством процессов и многие из этих процессов серверные - это означает, что с ними могут взаимодействовать внешние программы. Сегодня десктопы заменили мини-компьютеры и мэйнфрэймы, и поскольку компьютеры в наши дни подключены к сети интернет, безопасность важна как никогда.

Наилучшая реализация системы безопасности представима в виде "послойной" системы. Вообще говоря все, что нужно сделать, это создать столько слоев безопасности, сколько необходимо и затем внимательно следить за вторжениями в систему. Не переусердствуйте в настройке системы безопасности, иначе она сделает невозможной обнаружение вторжений, являющееся одним из наиболее важных аспектов механизма безопасности. Например, нет большого смысла в установке флага `schg` (man:chflags[1]) на каждый исполняемый файл системы, поскольку хотя таким способом можно временно защитить исполняемые файлы, это помешает обнаружению факта взлома системы.

Безопасность системы также относится к различным формам атак, имеющих своей целью вызвать крах системы, или сделать систему недоступной другим способом, но не пытающихся получить доступ к учётной записи `root` ("break root"). Угрозы безопасности могут быть поделены на несколько категорий:

. Отказ в обслуживании (Denial of service, DoS).
. Взлом пользовательских учётных записей.
. Взлом учётной записи root через доступные сервисы.
. Взлом учётной записи root через учётные записи пользователей.
. Создание backdoor.

Атака "отказ в обслуживании" отбирает у машины необходимые ресурсы. Обычно DoS атаки используют грубую силу, чтобы попытаться обрушить систему или сделать ее недоступной другим способом, превысив лимиты ее сервисов или сетевого стека. Некоторые DoS атаки пытаются использовать ошибки в сетевом стеке для обрушения системы одним пакетом. Эту проблему можно решить только исправив ядро системы. Атаки зачастую можно предотвратить правильной установкой параметров, ограничивающих нагрузку на систему в неблагоприятных условиях. С атаками, использующими грубую силу, бороться сложно. Например, атака с использованием пакетов с поддельными адресами, которую почти невозможно остановить, может быстро отключить вашу систему от интернет. Возможно, она не приведет к отказу системы, но сможет переполнить соединение с интернет.

Взлом учётной записи пользователя обычно встречается чаще, чем DoS атаки. Многие системные администраторы все еще используют стандартные сервисы telnetd, rlogind и ftpd на своих серверах. Эти сервисы по умолчанию не работают с зашифрованными соединениям. В результате при среднем количестве пользователей пароль одного или нескольких пользователей, входящих в систему через внешнее соединение (это обычный и наиболее удобный способ входа в систему), будет перехвачен. Внимательный системный администратор должен анализировать логи удаленного доступа на предмет подозрительных адресов пользователей даже в случае успешного входа.

Кто-то может предположить, что атакующий при наличии доступа к учётной записи пользователя может взломать учётную запись `root`. Однако, реальность такова, что в хорошо защищенной и поддерживаемой системе доступ к учётной записи пользователя не обязательно даст атакующему доступ к `root`. Разница между доступом к обычной учётной записи и к `root` важна, поскольку без доступа к `root` атакующий обычно не способен скрыть свои действия, и в худшем случае сможет лишь испортить файлы пользователя или вызвать крах системы. Взлом пользовательских учётных записей встречается очень часто, поскольку пользователи заботятся о безопасности так, как системные администраторы.

Системные администраторы должны помнить, что существует множество потенциальных способов взлома учётной записи `root`. Атакующий может узнать пароль `root`, найти ошибку в сервисе, работающем с привилегиями и взломать учётную запись `root` через сетевое соединение с этим сервисом, или узнать об ошибке в suid-root программе, позволяющей атакующему взлом `root` с помощью взломанной учётной записи пользователя. Если атакующий нашел способ взлома `root`, ему может не понадобиться установка backdoor. Многие из обнаруженных и закрытых на сегодняшний день брешей в системе, позволяющие взлом `root`, требуют от атакующего серьезной работы по заметанию следов, поэтому большинство атакующих устанавливают backdoor. Backdoor предоставляет атакующему простой способ восстановления доступа к системе с привилегиями `root`, но также дает системному администратору удобный способ обнаружения вторжения. Устранение возможности установки backdoor возможно повредит безопасности системы, поскольку это не устранит брешь, позволившую проникнуть в систему.

Меры безопасности всегда должны реализовываться на нескольких уровнях, которые могут быть классифицированы следующим образом:

. Защита `root` и служебных учётных записей.
. Защита работающих под `root` сервисов и suid/sgid исполняемых файлов.
. Защита учётных записей пользователей.
. Защита файла паролей.
. Защита ядра, raw устройств и файловых систем.
. Быстрое обнаружение несанкционированных изменений в системе.
. Паранойя.

В следующем разделе этой главы эти темы изложены более подробно.

[[securing-freebsd]]
== Защита FreeBSD

[NOTE]
.Команда и протокол
====
В этом документе мы будет использовать выделенный текст, упоминая приложение, и `моноширинный` шрифт, упоминая определенные команды. Для протоколов используется обычный шрифт. Это типографическое отличие полезно для таких случаев, как ssh, поскольку это и команда и протокол.
====

В последующем разделе будут рассмотрены методы защиты системы FreeBSD, упомянутые в <<security-intro,предыдущем разделе>> этой главы.

[[securing-root-and-staff]]
=== Защита учётной записи `root` и служебных учётных записей

Во-первых, не беспокойтесь о защите служебных учётных записей, если не защищена учётная запись `root`. В большинстве систем у учётной записи `root` есть пароль. Использование пароля `root` опасно _всегда_. Это не означает, что вы должны удалить пароль. Пароль почти всегда необходим для доступа по консоли. Но это означает, что вы должны сделать невозможным использование пароля не из консоли или может быть даже с помощью команды man:su[1]. Например, убедитесь, что псевдо-терминалы в файле [.filename]#/etc/ttys# перечислены с параметром `insecure`, что делает невозможным вход на них под `root` напрямую с помощью `telnet` или `rlogin`. При использовании других средств входа, таких как sshd, убедитесь что вход под `root` напрямую отключен и в них. Сделайте это, открыв файл [.filename]#/etc/ssh/sshd_config#, и убедившись, что параметр `PermitRootLogin` установлен в `NO`. Проверьте каждый метод доступа - сервис FTP и ему подобные часто подвержены взлому. Прямой вход под `root` должен быть разрешен только с системной консоли.

Конечно, как системный администратор вы должны иметь доступ `root`, поэтому потребуется открыть несколько "лазеек". Но убедитесь, что для доступа к ним необходим дополнительный пароль. Одним из способов доступа к `root` является добавление соответствующих учётных записей к группе `wheel` (в файле [.filename]#/etc/group#). Это позволяет использовать `su` для доступа к `root`. Вы никогда не должны давать таким учётным записям доступ к `wheel` непосредственно, помещая их в группу `wheel` в файле паролей. Служебные учётные записи должны помещаться в группу `staff`, а затем добавляться к группе `wheel` в файле [.filename]#/etc/group#. Только те члены группы staff, которым действительно нужен доступ к `root`, должны быть помещены в группу `wheel`. При работе с такими методами аутентификации как Kerberos, возможно также использование файла [.filename]#.k5login# в каталоге пользователя `root` для доступа к учётной записи `root` с помощью man:ksu[1] без помещения кого-либо в группу `wheel`. Это решение возможно лучше, поскольку механизм `wheel` все еще позволяет взлом `root`, если злоумышленник получил копию файла паролей и смог взломать служебную учётную запись. Хотя использование механизма `wheel` лучше, чем работа через `root` напрямую, это не обязательно самый безопасный способ.

Непрямой способ защиты служебных учётных записей и конечно `root` это использование альтернативных методов доступа и замена зашифрованных паролей на символ "`*`". Используя команду man:vipw[8], замените каждый зашифрованный пароль служебных учётных записей на этот символ для запрета входа с аутентификацией по паролю. Эта команда обновит файл [.filename]#/etc/master.passwd# и базу данных пользователей/паролей.

Служебная учётная запись вроде этой:

[.programlisting]
....
foobar:R9DT/Fa1/LV9U:1000:1000::0:0:Foo Bar:/home/foobar:/usr/local/bin/tcsh
....

Должна быть заменена на такую:

[.programlisting]
....
foobar:*:1000:1000::0:0:Foo Bar:/home/foobar:/usr/local/bin/tcsh
....

Это изменение предотвратит обычный вход, поскольку зашифрованный пароль никогда не совпадет с "`\*`". После этого члены группы staff должны использовать другой механизм аутентификации, например man:kerberos[1] или man:ssh[1] с парой ключей: публичным и приватным. При использовании такой системы как Kerberos, потребуется защитить сервер Kerberos и рабочую станцию. При использовании пары публичного/приватного ключей с ssh, потребуется защитить компьютер, _с_ которого происходит вход (обычно это рабочая станция). Дополнительных слой защиты может быть добавлен путем защиты пары ключей при создании их с помощью man:ssh-keygen[1]. Возможность заменить пароли служебных учётных записей на "`*`" гарантирует также, что вход может быть осуществлен только через защищенные методы доступа, которые вы настроили. Это принуждает всех членов staff использовать защищенные, шифрованные соединения для всех входов, что закрывает большую брешь, используемую многими нарушителями: перехват паролей с другого, слабо защищенного компьютера.

Более непрямой механизм безопасности предполагает, что вы входите с более защищенного сервера на менее защищенный. Например, если главный сервер работает со всеми сервисами, рабочая станция не должна работать ни с одним. Для поднятия уровня безопасности до приемлемого уровня, число запущенных на ней сервисов необходимо сократить до минимума, вплоть до отключения их всех, кроме того необходимо использовать защищенный паролем хранитель экрана. Конечно, при наличии физического доступа к рабочей станции атакующий может взломать любую систему безопасности. Это определенно проблема, которую вы должны учитывать, но учтите также тот факт, что большинство взломов совершаются удаленно, через сеть, людьми, которые не имеют физического доступа к вашим рабочим станциям или серверам.

Использование такой системы как Kerberos дает возможность заблокировать или изменить пароль в одном месте, что сразу отразиться на всех компьютерах, где существует служебная учётная запись. Если эта учётная запись будет взломана, возможность немедленно изменить пароль на всех компьютерах нельзя недооценивать. Без этой возможности изменение паролей на N машинах может стать проблемой. Вы можете также наложить ограничения на смену паролей с помощью Kerberos: не только установить значения timeout в Kerberos, но и добавить требование смены пароля пользователем после определенного периода времени (скажем, раз в месяц).

=== Защита работающих под root сервисов и suid/sgid исполняемых файлов

Предусмотрительный системный администратор запускает только те сервисы, в которых нуждается, ни больше ни меньше. Учитывайте, что сервисы сторонних разработчиков наиболее подвержены ошибкам. К примеру, работа со старыми версиями imapd или popper это все равно что раздача доступа `root` всему миру. Никогда не запускайте сервисы, которые вы не проверили достаточно внимательно. Многим сервисам не требуется работа под `root`. Например, даемоны ntalk, comsat, и finger могут быть запущены в так называемых _песочницах_ (_sandboxes_). Песочница это не идеальное решение, поскольку вызывает много проблем, но она подходит под модель послойной безопасности: если кто-то сможет взломать сервис, работающий в песочнице, ему потребуется взломать еще и саму песочницу. Чем больше уровней ("слоев") потребуется пройти атакующему, тем меньше вероятность его успеха. Ошибки, позволяющие получать root доступ, находили фактически во всех сервисах, запускаемых под `root`, включая основные системные сервисы. Если вы обслуживаете машину, на которую входят только через sshd и никогда не входят через telnetd, rshd или rlogind, отключите эти сервисы!

В FreeBSD сервисы ntalkd, comsat и finger теперь по умолчанию работают в "песочнице". Другая программа, которая может быть кандидатом на запуск в "песочнице" это man:named[8]. [.filename]#/etc/defaults/rc.conf# включает необходимые для запуска named в "песочнице" аргументы в закомментированой форме. В зависимости от того, устанавливаете ли вы новую систему, или обновляете старую, учётные записи пользователей, используемые этими "песочницами" могут не быть созданы. Предусмотрительный системный администратор должен узнать о "песочницах" для сервисов и установить их если есть возможность.

Есть множество других сервисов, которые обычно не работают в "песочницах": sendmail, popper, imapd, ftpd, и другие. Некоторым из этих сервисов есть альтернативы, но их установка может потребовать больше работы, чем вы готовы выполнить (фактор удобства). Вы можете запустить эти сервисы под `root` и положиться на другие механизмы обнаружения вторжений, которые могут пройти через них.

Другая большая потенциальная `root` брешь в системе это suid-root и sgid исполняемые файлы. Большинство этих исполняемых файлов, таких как rlogin, установлены в [.filename]#/bin#, [.filename]#/sbin#, [.filename]#/usr/bin#, или [.filename]#/usr/sbin#. Хотя ничто не может быть безопасно на 100%, находящиеся по умолчанию в системе suid и sgid исполняемые файлы могут быть признаны достаточно безопасными. Но `root` бреши все еще обнаруживаются в этих исполняемых файлах. `root` брешь, обнаруженная в `Xlib` в 1998 делала xterm (который обычно suid) подверженным взлому. Лучше сразу принять меры предосторожности, чем сожалеть потом. Предусмотрительный системный администратор ограничит права запуска suid исполняемых файлов, которые должны запускаться пользователями группы staff, только этой группой, а также запретит доступ (`chmod 000`) к тем исполняемым файлам suid, которые никем не используются. Серверу без монитора обычно не требуется исполняемый файл xterm. Исполняемые sgid исполняемые файлы могут быть почти так же опасны. Если нарушитель сможет взломать sgid-kmem исполняемый файл, он возможно сможет прочесть [.filename]#/dev/kmem# и таким образом получить файл зашифрованных паролей, что потенциально делает возможным взлом любой защищённой паролем учётной записи. Аналогично нарушитель, проникший в группу `kmem`, может отслеживать последовательности клавиш, отправляемые через псевдо-терминалы, включая те, что используют защищённые соединения. Нарушитель, вошедший в группу `tty` может сделать вывод почти на любой пользовательский терминал. Если пользователь работает с терминальной программой или эмулятором с возможностью эмуляции клавиатуры, взломщик может потенциально сгенерировать поток данных, который заставит терминал пользователя ввести команду, и она будет запущена с правами этого пользователя.

[[secure-users]]
=== Защита учётных записей пользователей

Учетные записи пользователей обычно сложнее всего защитить. Вы можете ввести драконовские ограничения доступа к служебным учётным записям, заменив их пароли на символ "`*`", но возможно не сможете сделать то же с обычными учётными записями пользователей. Если есть такая возможность, вы возможно сможете защитить учётные записи пользователей соответствующим образом. Если нет, просто более бдительно отслеживайте эти учётные записи. Использование ssh и Kerberos для учётных записей пользователей более проблематично, поскольку требует дополнительной административной работы и технической поддержки, но все же это решение лучше, чем файл с шифрованными паролями.

=== Защита файла паролей

Единственный абсолютно надежный способ это замена на `*` максимально возможного количества паролей и использование ssh или Kerberos для доступа к таким учётным записям. Хотя файл с шифрованными паролями ([.filename]#/etc/spwd.db#) доступен для чтения только `root`, возможно, что нарушитель сможет получить доступ на чтение к этому файлу, даже если не получит права `root` на запись.

Ваши скрипты безопасности должны всегда проверять и составлять отчет об изменениях файла паролей (обратитесь к разделу <<security-integrity,Проверка целостности файлов>> ниже по тексту).

=== Защита ядра, raw устройств и файловых систем

Если атакующий взломает `root`, он сможет сделать практически все, но есть способы усложнить его задачу. Например, в большинстве современных ядер встроено устройство перехвата пакетов. В FreeBSD оно называется [.filename]#bpf#. Нарушитель обычно пытается запустить перехват пакетов на взломанной машине. Вы не должны предоставлять ему такой возможности, на большинстве систем устройство [.filename]#bpf# не должно быть встроено в ядро.

Но даже если вы выключите устройство [.filename]#bpf#, все еще остаются проблемы, связанные с устройствами [.filename]#/dev/mem# и [.filename]#/dev/kmem#. Нарушитель все еще может писать на дисковые raw устройства. Есть также другая возможность ядра, загрузка модулей, man:kldload[8]. Активный нарушитель может использовать KLD модуль для установки собственного устройства [.filename]#bpf# или другого перехватывающего устройства на работающее ядро. Для решения этих проблем запускайте ядро с большим уровнем безопасности, как минимум 1. Уровень безопасности может быть установлен с помощью `sysctl` через переменную `kern.securelevel`. После установки уровня безопасности в 1 доступ на запись в raw устройства будет запрещена и полностью заработают специальные флаги `chflags`, такие как `schg`. Убедитесь также, что флаг `schg` установлен на критически важных загрузочных исполняемых файлах, каталогах и файлах скриптов - на всем, что запускается до установке уровня безопасности. Это требует большого объема работы, и обновление системы на более высоком уровне безопасности может стать гораздо сложнее. Вы можете пойти на компромисс и запускать систему на высоком уровне безопасности, но не устанавливать флаг `schg` для каждого существующего системного файла и каталога. Другая возможность состоит в монтировании [.filename]#/# и [.filename]#/usr# только для чтения. Необходимо заметить, что такие правила слишком жесткие и могут помешать обнаружению вторжения.

[[security-integrity]]
=== Проверка целостности файлов: исполняемые, конфигурационные файлы и т.д.

Вы можете защищать только ядро, файлы настройки и управления системой только до тех пор, пока эта защита не вступит в конфликт с удобством работы в системе. Например, использование `chflags` для установки бита `schg` на большинство файлов в [.filename]#/# вероятно может только навредить, поскольку хотя и может защитить файлы, препятствует обнаружению. Последний слой системы безопасности, возможно, наиболее важный - обнаружение. Остальные меры безопасности практически бесполезны (или, что еще хуже, могут дать вам ложное ощущение безопасности) если вы не обнаружите потенциальное вторжение. Половина функций системы безопасности направлена на замедление атакующего, а не на его остановку, для того, чтобы дать системе обнаружения возможность поймать нарушителя на месте преступления.

Лучший способ обнаружения вторжения - отслеживание измененных, отсутствующих, или неожиданно появившихся файлов. Для наблюдения за измененными файлами лучше всего использовать другую (зачастую централизованную) систему с ограниченным доступом. Добавление написанных вами скриптов к этой дополнительно защищенной системе с ограниченным доступом делает ее практически невидимой для потенциальных взломщиков, и это важно. В целях достижения максимального эффекта вам может потребоваться предоставить этой системе доступ к другим машинам в сети, обычно с помощью NFS экспорта только для чтения или сгенерировав пары ключей ssh для доступа к другим машинам по ssh. Помимо большого объема сетевого трафика, NFS более скрытый метод - он позволяет контролировать файловые системы на каждом клиентском компьютере практически незаметно. Если ваш сервер с ограниченным доступом подключен к клиентским компьютерам через коммутатор, NFS метод это зачастую лучший выбор. При соединении через концентратор, или через несколько маршрутизаторов, NFS метод может стать слишком небезопасным и использование ssh может стать лучшим выбором даже несмотря на то, что ssh оставляет следы своей работы.

Как только у вас появился сервер с ограниченным доступом, и как минимум доступ на чтение в клиентских системах, потребуется написать скрипты для выполнения мониторинга. При наличии доступа по NFS вы можете написать скрипты с помощью простых системных утилит, таких как man:find[1] и man:md5[1]. Лучше всего подсчитывать md5 файлов на клиентском компьютере как минимум один раз в день, а файлы, контролирующие запуск из [.filename]#/etc# и [.filename]#/usr/local/etc# даже более часто. При обнаружении расхождений в md5, контролирующий компьютер должен просигналить системному администратору проверить изменившиеся файлы. Хороший скрипт безопасности проверит также наличие несоответствующих исполняемых suid файлов и новых или измененных файлов в системных разделах [.filename]#/# и [.filename]#/usr#.

При использовании ssh вместо NFS, написать скрипты безопасности гораздо сложнее. Вам обязательно потребуется скопировать (`scp`) скрипты на клиентский компьютер, сделать из невидимыми, и для безопасности потребуется также скопировать исполняемые файлы (такие как find), которые будут использоваться скриптом. Приложение ssh на клиентском компьютере может быть уже взломано. В конечном итоге, без ssh не обойтись при работе через небезопасные соединения, но его гораздо сложнее использовать.

Хороший скрипт безопасности проверит также изменения в файлах настройки, работающих при подключении пользователей и служебных учётных записей: [.filename]#.rhosts#, [.filename]#.shosts#, [.filename]#.ssh/authorized_keys# и так далее... файлы, которые могли не попасть в область проверки `MD5`.

Если для пользователей выделен большой объем дискового пространства, проверка каждого файла на таких разделах может занять слишком много времени. В таком случае установка флагов монтирования для запрета suid исполняемых файлов и устройств на таких разделах это хорошая идея. Примените параметры man:mount[8] `nodev` и `nosuid`. Проверяйте эти разделы в любом случае, хотя бы раз в неделю, поскольку необходимо обнаруживать попытки взлома, независимо от того, эффективны они или нет.

Учет процессов (man:accton[8]) это относительно несложная возможность операционной системы, которая может помочь как механизм обнаружения состоявшихся вторжений. Она особенно полезна для обнаружения пути проникновения нарушителя в систему, если файл не был затронут проникновением.

Наконец, скрипты безопасности должны обработать лог файлы, которые необходимо создавать настолько защищенным способом, насколько это возможно - подключение syslog удаленно может быть очень полезным. Злоумышленник попытается уничтожить следы взлома, и лог файлы критически важны для системного администратора, пытающегося отследить время и метод первого проникновения. Один из надежных способов получения лог файлов является подключение системной консоли к последовательному порту и постоянный сбор информации через защищенную машину, отслеживающую консоли.

=== Паранойя

Немного паранойи никогда не повредит. Как правило, системный администратор может добавлять элементы безопасности в любом количестве, пока это не влияет на удобство, а также некоторое количество элементов безопасности, _влияющих_ на удобство. Что даже более важно, системный администратор должен немного изменить их - если вы используете рекомендации, например те, что даны в этом документе, они становятся известны атакующему, который также имеет доступ к этому документу.

=== Атаки DoS

Этот раздел охватывает DoS атаки. DoS атаки это обычно пакетные атаки. Хотя против современной атаки с подделкой пакетов, которая перегружает сеть, мало что можно сделать, вы можете ограничить повреждения, убедившись, что атака не может обрушить ваши сервера.

. Ограничение количества порождаемых процессов.
. Уменьшение последствий springboard атак (ICMP ответ, широковещательный ping и т.д.).
. Кэш маршрутизации ядра.

Обычная DoS атака против порождающего процессы сервера пытается исчерпать ресурсы сервера по процессам, файловым дескрипторам и памяти до тех пор, пока машина не "повиснет". У inetd (обратитесь к man:inetd[8]) есть несколько параметров, позволяющих ограничить такие атаки. Необходимо учесть, что хотя можно предотвратить падение системы, в общем случае невозможно предотвратить прекращение работы сервиса. Внимательно прочтите страницу справочника и обратите особое внимание на параметры `-c`, `-C`, и `-R`. Учтите, что параметр `-C` не работает в случае атак с использованием поддельных IP пакетов, поэтому как правило необходимо использование комбинации параметров. Некоторые standalone сервисы используют собственные параметры, ограничивающие порождение процессов.

У Sendmail есть собственный параметр `-OMaxDaemonChildren`, которая работает гораздо лучше, чем параметр sendmail, ограничивающий нагрузку. Вам необходимо задать параметр запуска sendmail`MaxDaemonChildren` достаточно большим, чтобы обслуживать ожидаемую нагрузку, но так, чтобы компьютер мог обслужить такое количество приложений sendmail без падения системы. Хорошей мерой является запуск sendmail в режиме очереди (`-ODeliveryMode=queued`) и запуск даемона (`sendmail -bd`) отдельно от очереди (`sendmail -q15m`). Если вы все же хотите организовать доставку в режиме реального времени, запускайте очередь с меньшим интервалом `-q1m`, но убедитесь в правильной установке параметра sendmail `MaxDaemonChildren` для предотвращения ошибок.

Syslogd может быть атакован непосредственно, настоятельно рекомендуется использовать параметр `-s` если это возможно и параметр `-a` в остальных случаях.

Вы также должны быть очень осторожны с сервисами, совершающими обратное подключение, например, с TCP Wrapper и его обратным identd-запросом, который может быть атакован напрямую. По этой причине возможность TCP Wrapper генерировать обратный ident обычно не следует использовать.

Правильным будет запрет доступа к внутренним сервисам из внешней сети путем соответствующей настройки брандмауэра на внешнем маршрутизаторе. Идея в том, чтобы предотвратить перегрузку сервисов атаками из внешней сети, а кроме того защитить `root` от взлома через сеть. Всегда настраивайте исключающий брандмауэр, т.е. "закрыть все _кроме_ портов A, B, C, D, и M-Z". Этим способом вы можете закрыть все порты нижнего диапазона, кроме явно указанных, таких как named (если вы поддерживаете интернет-зону), ntalkd, sendmail, и других сервисов, доступных из интернет. Если вы попробуете настроить брандмауэр другим способом - включающий, или разрешающий брандмауэр, есть большой шанс забыть "закрыть" пару сервисов, или добавить новый внутрисетевой сервис и забыть обновить брандмауэр. Вы можете открыть диапазон портов с большими номерами для обычных приложений без угрозы портам нижнего диапазона. Учтите также, что FreeBSD позволяет вам контролировать диапазоны портов, используемые для динамической привязки через различные переменные `sysctl``net.inet.ip.portrange` (`sysctl -a | fgrep portrange`), что позволяет упростить настройку брандмауэра. Например, вы можете использовать обычный диапазон портов со значениями от 4000 до 5000, и диапазон портов с большими номерами от 49152 до 65535, а затем заблокировать все до 4000 порта (конечно оставив доступ из интернет к определенным портам.

Другой распространенный тип DoS атак называется springboard - сервер атакуется таким образом, что генерируемые ответы перегружают его, локальную сеть или какие-то другие компьютеры. Наиболее распространенная атака этого вида это _широковещательная ICMP ping атака_. Атакующий подделывает пакеты ping, подставляя IP адрес машины, которую он намеревается атаковать, и отправляет их на широковещательный адрес вашей локальной сети. Если ваш внешний маршрутизатор не настроен на отбрасывание пакетов ping на широковещательные адреса, ваша сеть начинает генерировать соответствующие ответы на поддельный адрес, что приводит к перегрузке хоста-жертвы, особенно если атакующий использует этот же трюк с множеством широковещательных адресов в множестве сетей одновременно. Были зарегистрированы широковещательные атаки свыше ста двадцати мегабит. Другая распространенная springboard атака направлена на ICMP систему сообщения об ошибках. Конструируя пакеты, вызывающие ICMP сообщения об ошибках, атакующий может нагрузить входящее соединение сервера и вынудить сервер нагрузить исходящее соединение ICMP ответами. Этот тип атаки может также обрушить сервер, когда тот исчерпает mbuf, обычно если сервер не может ограничить число ответов ICMP, когда они генерируются слишком быстро. Используйте переменную sysctl`net.inet.icmp.icmplim`. Последний основной класс springboard атак относится к определенным внутренним сервисам inetd, таким как сервис udp echo. Атакующий просто подделывает адрес источника и адрес назначения UDP пакетов, устанавливая в их качестве соответственно echo порт сервера A и B, оба этих сервера принадлежат вашей локальной сети. Эти два сервера начинают перебрасываться этим пакетом друг с другом. Атакующий может вызвать перегрузку обеих серверов и их сетей, просто отправив несколько пакетов таким способом. Аналогичные проблемы существуют с портом chargen. Компетентный системный администратор должен отключить эти тестовые сервисы inetd.

Атаки с поддельными пакетами могут также использоваться для переполнения кэша маршрутизации ядра. Обратитесь к параметрам `sysctl``net.inet.ip.rtexpire`, `rtminexpire`, и `rtmaxcache`. Атака с поддельными пакетами, использующая произвольный IP адрес источника, заставит ядро сгенерировать временный кэшированный маршрут в таблице маршрутизации, который можно увидеть с помощью `netstat -rna | fgrep W3`. Эти маршруты обычно удаляются через 1600 секунд или около того. Если ядро определит, что кэшированная маршрутная таблица стала слишком большой, оно динамически уменьшит `rtexpire`, но никогда не станет делать его меньше чем `rtminexpire`. С этим связаны две проблемы:

. Ядро не отреагирует достаточно быстро, когда легко нагруженный сервер будет внезапно атакован.
. Значение `rtminexpire` недостаточно мало для поддержки работоспособности в условиях продолжительной атаки.

Если ваши серверы подключены к интернет через линию T3 или более быструю, предусмотрительно будет изменить оба значения `rtexpire` и `rtminexpire` с помощью man:sysctl[8]. Никогда не устанавливайте ни один из этих параметров в нуль (если только вы не хотите обрушить систему). Установка обеих параметров в значение 2 секунды должна предотвратить таблицу маршрутизации от атак.

=== Проблемы, связанные с доступом к Kerberos и SSH

При использовании Kerberos и ssh необходимо учесть несколько возможных проблем. Kerberos V это отличный протокол аутентификации, но в адаптированных к нему приложениях telnet и rlogin есть несколько ошибок, которые могут сделать их непригодными к работе с бинарными потоками. К тому же, по умолчанию Kerberos не шифрует сессию, если вы не используете параметр `-x`. ssh шифрует все по умолчанию.

ssh работает очень хорошо во всех ситуациях, но пересылает ключи по умолчанию. Это означает, что если вы работаете с защищенной рабочей станции, ключи на которой дают доступ к остальной сети, и заходите по ssh на незащищенный компьютер, эти ключи могут быть использованы для взлома. Атакующему не удастся получить сами ключи, но поскольку ssh открывает порт во время входа в систему, то если на незащищенной машине взломан `root`, эти ключи могут быть использованы для доступа к другим компьютерам, на которых они действуют.

Мы рекомендуем использовать ssh в комбинации с Kerberos для служебных учётных записей если это возможно. ssh может быть собран с поддержкой Kerberos. Это уменьшает зависимость от потенциально подверженных взлому ssh ключей, и в то же время защищает пароли через Kerberos. Ключи ssh должны использоваться только для работы скриптов на защищенных компьютерах (там, где Kerberos использовать не получится). Мы также рекомендуем или выключить передачу ключей в настройках ssh, или использовать параметр `from=IP/DOMAIN`, поддерживаемый ssh в файле [.filename]#authorized_keys#, который позволяет использовать ключи только с определенных компьютеров.

[[crypt]]
== DES, MD5, и шифрование

У каждого пользователя UNIX(R) системы есть пароль, связанный с его учётной записью. Очевидно, что эти пароли должны быть известны только пользователю и соответствующей операционной системе. Для защиты паролей они шифруются способом, известным как "односторонний хэш", то есть их можно легко зашифровать, но нельзя расшифровать. Другими словами, то, что мы сказали чуть раньше было очевидно, но не совсем верно: операционной системе _сам пароль_ неизвестен. Ей известен только пароль в _зашифрованной_ форме. Единственный способ получить "обычный" пароль это простой перебор всех возможных паролей.

К сожалению, единственный способ шифрования пароля при появлении UNIX(R) был основан на DES, Data Encryption Standard. Это не было проблемой для пользователей, живущих в США, но поскольку исходный код DES нельзя было экспортировать из США, FreeBSD нашла способ одновременно не нарушать законов США и сохранить совместимость со всеми другими вариантами UNIX(R), где все еще использовался DES.

Решение было в разделении библиотек шифрования, чтобы пользователи в США могли устанавливать и использовать библиотеки DES, а у остальных пользователей был метод шифрования, разрешенный к экспорту. Так FreeBSD пришла к использованию MD5 в качестве метода шифрования по умолчанию. MD5 считается более безопасным, чем DES, поэтому установка DES рекомендуется в основном из соображений совместимости.

=== Определения механизма шифрования

На данный момент библиотека поддерживает хэши DES, MD5 и Blowfish. По умолчанию FreeBSD использует для шифрования паролей MD5.

Довольно легко определить какой метод шифрования используется в FreeBSD. Один из способов это проверка файла [.filename]#/etc/master.passwd#. Пароли, зашифрованные в хэш MD5 длиннее, чем те, что зашифрованы с помощью DES и начинаются с символов `$1$`. Пароли, начинающиеся с символов `$2a$` зашифрованы с помощью Blowfish. Пароли, зашифрованные DES не содержат каких-то определенных идентифицирующих символов, но они короче, чем пароли MD5 и закодированы в 64-символьном алфавите, не содержащем символа `$`, поэтому относительно короткая строка, не начинающаяся с этого символа это скорее всего DES пароль.

Формат паролей, используемых для новых паролей, определяется параметром `passwd_format` в [.filename]#/etc/login.conf#, которое может принимать значения `des`, `md5` или `blf`. Обратитесь к странице справочника man:login.conf[5] за дополнительной информацией о параметрах login.

[[one-time-passwords]]
== Одноразовые пароли

FreeBSD использует для одноразовых паролей OPIE (One-time Passwords In Everything). OPIE по умолчанию использует MD5.

Есть три различных вида паролей, о которых мы поговорим ниже. Первый вид это ваш обычный пароль UNIX(R) или пароль Kerberos; мы будем называть его "пароль UNIX(R)". Второй вид это одноразовый пароль, сгенерированный программой OPIE man:opiekey[1] и принимаемый командой man:opiepasswd[1] и в приглашении login; мы будем называть их "одноразовыми паролями". Последний вид паролей это защищенные пароли, которые вы передаете программам `opiekey` (и иногда `opiepasswd`), и которые эти программы используют для создания одноразовых паролей; мы будем называть его "защищенными паролями" или просто "паролями".

Защищенный пароль не имеет никакого отношения к вашему паролю UNIX(R); они могут быть одинаковыми, но это не рекомендуется. Защищенные пароли OPIE не ограничены 8-ю символами, как старые UNIX(R) пароли, они могут быть настолько длинными, насколько вы захотите. Очень часто используются пароли длиной в шесть или семь символов. По большей части система OPIE работает полностью независимо от системы паролей UNIX(R).

Помимо паролей, есть два других вида данных, важных для OPIE. Первый, известный как "seed" или "ключ", состоит из двух букв и пяти цифр. Другой, называемый "счетчиком цикла", это номер от 1 до 100. OPIE создает одноразовый пароль, соединяя ключ и защищенный пароль, а затем применяя MD4 столько раз, сколько указано счетчиком цикла и выдает результат в виде шести коротких слов на английском. Эти шесть слов на английском и есть ваш одноразовый пароль. Система аутентификации (как правило PAM) хранит последний использованный одноразовый пароль, и пользователь аутентифицируется если хэш вводимого пользователем пароля совпадает с предыдущим паролем. Поскольку используется односторонний хэш, невозможно сгенерировать следующий одноразовый пароль если получен предыдущий; счетчик цикла уменьшается после каждого успешного входа для поддержки синхронизации пользователя с программой login. Когда счетчик цикла уменьшается до 1, набор OPIE должен быть переинициализирован.

В каждой из обсуждаемых ниже систем задействованы три программы. Программа `opiekey` получает счетчик цикла, ключ и защищенный пароль и создает одноразовый пароль или последовательный список одноразовых паролей. Программа `opiepasswd` используется для инициализации OPIE соответственно, и для смены паролей, счетчиков цикла, или ключей; она принимает защищенный пароль или счетчик цикла, ключ и одноразовый пароль. Программа `opieinfo` проверяет соответствующий файл ([.filename]#/etc/opiekeys#) и печатает текущий счетчик цикла и ключ вызывающего пользователя.

Мы рассмотрим четыре вида операций. Первая это использование `opiepasswd` через защищенное соединение для первоначальной настройки системы одноразовых паролей, или для изменения пароля или ключа. Вторая операция это использование в тех же целях `opiepasswd` через незащищенное соединение, в сочетании с `opiekey` через защищенное соединение. Третья это использование `opiekey` для входа через незащищенное соединение. Четвертая это использование `opiekey` для генерации набора ключей, которые могут быть записаны или распечатаны для соединения из места, где защищенное соединение недоступно.

=== Защищенная установка соединения

Для первоначальной настройки OPIE используется команда `opiepasswd`:

[source,shell]
....
% opiepasswd -c
[grimreaper] ~ $ opiepasswd -f -c
Adding unfurl:
Only use this method from the console; NEVER from remote. If you are using
telnet, xterm, or a dial-in, type ^C now or exit with no password.
Then run opiepasswd without the -c parameter.
Using MD5 to compute responses.
Enter new secret pass phrase:
Again new secret pass phrase:
ID unfurl OTP key is 499 to4268
MOS MALL GOAT ARM AVID COED
....

В приглашениях `Enter new secret pass phrase:` или `Enter secret password:`, введите пароль или фразу. Запомните, это не тот пароль, с которым вы будете входить, он используется для генерации одноразовых паролей. Строка "ID" содержит информацию для вашего конкретного случая: имя пользователя, счетчик цикла и ключ. При входе система запомнит эти параметры и отправит их вам, поэтому их не надо запоминать. В последней строке находится одноразовый пароль, соответствующий этим параметрам и секретному паролю; если вы войдете в систему сразу, используйте этот одноразовый пароль.

=== Незащищенная установка соединения

Для инициализации или изменения защищенного пароля через незащищенное соединение, вам потребуется существующее защищенное соединение куда-то, где вы сможете запустить `opiekey`; это может быть shell на компьютере, которому вы доверяете. Вам потребуется также установить значение счетчика цикла (100 возможно подойдет), и задать ключ или использовать сгенерированный. Через незащищенное соединение (к компьютеру, на котором производится настройка), используйте команду `opiepasswd`:

[source,shell]
....
% opiepasswd

Updating unfurl:
You need the response from an OTP generator.
Old secret pass phrase:
        otp-md5 498 to4268 ext
        Response: GAME GAG WELT OUT DOWN CHAT
New secret pass phrase:
        otp-md5 499 to4269
        Response: LINE PAP MILK NELL BUOY TROY

ID mark OTP key is 499 gr4269
LINE PAP MILK NELL BUOY TROY
....

Чтобы принять ключ по умолчанию нажмите kbd:[Enter]. Затем, перед вводом пароля доступа введите те же параметры в вашем защищенном соединении или средстве доступа OPIE:

[source,shell]
....
% opiekey 498 to4268
Using the MD5 algorithm to compute response.
Reminder: Don't use opiekey from telnet or dial-in sessions.
Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT
....

Теперь переключитесь на незащищенное соединение и скопируйте одноразовый пароль, сгенерированный соответствующей программой.

=== Создание одного одноразового пароля

Как только вы настроите OPIE, во время входа появится приглашение вроде этого:

[source,shell]
....
% telnet example.com
Trying 10.0.0.1...
Connected to example.com
Escape character is '^]'.

FreeBSD/i386 (example.com) (ttypa)

login: <username>
otp-md5 498 gr4269 ext
Password: 
....

Кроме того, у OPIE есть полезная особенность (не показанная здесь): если вы нажмете kbd:[Enter] в приглашении на ввод пароля, включится эхо, и вы сможете увидеть то, что вводите. Это может быть очень полезно, если вы пытаетесь ввести пароль вручную, например с распечатки.

В этот момент вам потребуется сгенерировать одноразовый пароль, чтобы ввести его в приглашение. Это должно быть выполнено на защищенной системе, в которой вы можете запустить `opiekey` (есть версии для DOS, Windows(R) и Mac OS(R)). Им требуются значения счетчика цикла и ключ в качестве параметров командной строки. Вы можете скопировать и вставить их прямо из приглашения login компьютера, на который входите.

В защищенной системе:

[source,shell]
....
% opiekey 498 to4268
Using the MD5 algorithm to compute response.
Reminder: Don't use opiekey from telnet or dial-in sessions.
Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT
....

Теперь, когда у вас есть одноразовый пароль, можете продолжить вход в систему.

=== Создание нескольких одноразовых паролей

Иногда вы отправляетесь туда, где нет доступа к защищенному компьютеру или защищенному соединению. В этом случае, можно использовать команду `opiekey` для создания нескольких одноразовых паролей, которые вы сможете распечатать и забрать с собой. Например:

[source,shell]
....
% opiekey -n 5 30 zz99999
Using the MD5 algorithm to compute response.
Reminder: Don't use opiekey from telnet or dial-in sessions.
Enter secret pass phrase: <secret password>
26: JOAN BORE FOSS DES NAY QUIT
27: LATE BIAS SLAY FOLK MUCH TRIG
28: SALT TIN ANTI LOON NEAL USE
29: RIO ODIN GO BYE FURY TIC
30: GREW JIVE SAN GIRD BOIL PHI
....

Параметр `-n 5` запрашивает пять паролей, `30` указывает значение последнего счетчика цикла. Обратите внимание, что пароли печатаются в _обратном_ по сравнению с обычным использованием порядке. Если вы действительно параноик, перепишите результат вручную; иначе скопируйте и передайте его `lpr`. Обратите внимание, что каждая линия содержит как счетчик цикла, так и одноразовый пароль; вам может показаться удобным отрывать пароль после использования.

=== Ограничение использования UNIX(R) паролей

OPIE может ограничивать использование паролей UNIX(R) на основе IP адреса. Соответствующий файл называется [.filename]#/etc/opieaccess#, он существует по умолчанию. Обратитесь к man:opieaccess[5] за более подробной информацией об этом файле и о предосторожностях, которые вы должны предпринять при использовании этого файла.

Вот пример файла [.filename]#opieaccess#:

[.programlisting]
....
permit 192.168.0.0 255.255.0.0
....

Эта строка позволяет пользователям, чей IP адрес (который подвержен подделке) соответствует указанному значению и маске, входить с паролем UNIX(R).

Если ни одно из правил в [.filename]#opieaccess# не сработало, поведением по умолчанию является запрет всех не-OPIE входов.

[[tcpwrappers]]
== TCP Wrappers

Каждый, кто знаком с man:inetd[8], возможно когда-то слышал о TCP Wrappers. Но немногие полностью понимают их полезность в сетевой среде: большинство используют брандмауэр. Хотя его применимость очень широка, есть вещи, с которыми брандмауэр не может работать, такие как отправка текста обратно вызывающей стороне. Программное обеспечение уровня TCP может делать это и многое другое. В следующих нескольких разделах обсуждаются многие возможности TCP Wrappers, и, когда это необходимо, даются примеры настроек.

Программное обеспечение TCP Wrappers расширяет возможность `inetd` по поддержке каждого даемона. С ним становится возможным протоколирование, возврат сообщений вызывающей стороне, ограничение подключений внутренней сетью и т.п. Хотя некоторые из этих возможностей могут быть реализованы брандмауэром, TCP Wrappers не только предоставляют дополнительный уровень защиты, но и дают больше контроля над системой, чем это возможно с брандмауэром.

Расширенная функциональность обработчиков TCP не может заменить хороший сетевой экран. Тем не менее, обработчики TCP могут использоваться совместно с сетевым экраном и другими средствами обеспечения информационной безопасности, обеспечивая тем самым дополнительный уровень защиты системы.

Поскольку рассматривается расширение к настройкам `inetd`, предполагается, что читатель ознакомился с разделом о crossref:network-servers[network-inetd,настройке inetd].

[NOTE]
====
Хотя программы, запускаемые из man:inetd[8], на самом деле не соответствуют термину "даемоны", существует традиция называть их именно так. Этот термин и используется в данном разделе.
====

=== Начальная настройка

Единственное требование для использования TCP Wrappers в FreeBSD это наличие в [.filename]#rc.conf# параметров запуска `inetd``-Ww`; это настройки по умолчанию. Конечно, ожидается также наличие правильной настройки [.filename]#/etc/hosts.allow#, но man:syslogd[8] отправит сообщения в системный протокол если что-то не так.

[NOTE]
====
В отличие от других реализаций TCP Wrappers, использование [.filename]#hosts.deny# не поддерживается. Все параметры настройки должны быть помещены в [.filename]#/etc/hosts.allow#.
====

В простейшей конфигурации, политика подключения сводится к разрешению или блокированию в зависимости от параметров в [.filename]#/etc/hosts.allow#. Настройка в FreeBSD по умолчанию заключается в разрешении подключения к любому даемону, запущенному из `inetd`. Изменение этого поведения будет обсуждаться только после рассмотрения базовой настройки.

Базовая настройка обычно принимает форму `daemon : address : action`, где `daemon` это имя даемона, который запускается `inetd`. В поле `address` может находиться имя хоста, IP адрес, или IPv6 адрес, заключенный в квадратные скобки ([ ]). Поле action может принимать значения allow или deny, чтобы соответственно разрешать или запрещать доступ. Помните, что поиск правил производится до первого совпадения. При обнаружении совпадения применяется соответствующее правило и поиск прерывается.

Существуют и другие параметры, но они будут описаны в следующих разделах. Простая конфигурация может быть, например, такой: для разрешения соединений по протоколу POP3 к даемону package:mail/qpopper[], в [.filename]#hosts.allow# необходимо добавить следующие строки:

[.programlisting]
....
# This line is required for POP3 connections:
qpopper : ALL : allow
....

После добавления этой строки, `inetd` необходимо перезапустить. Это можно выполнить командой man:kill[1] или скриптом [.filename]#/etc/rc.d/inetd# с параметром [parameter]#restart#.

=== Расширенная конфигурация

У TCP Wrappers имеются дополнительные параметры; они дают дополнительные возможности контроля над соединениями. Иногда бывает полезно возвращать комментарий определенным хостам или при подключении к определенным даемонам. В других случаях может быть необходимо добавить запись в лог файл, или отправить письмо администратору. В определенных ситуациях сервис должен использоваться только для локальных соединений. Все это возможно с использованием параметров c шаблонами, символами подстановки и путем выполнения внешних команд. Следующие два раздела посвящены этим типам настроек.

==== Внешние команды

Предположим ситуацию, в которой соединение должно быть запрещено, а о причине необходимо сообщить вызывающей стороне. Как это можно сделать? Соответствующую возможность предоставляет параметр `twist`. При попытке подключения выполняется команда или скрипт, заданный этим параметром. Пример дан в файле [.filename]#hosts.allow#:

[.programlisting]
....
# The rest of the daemons are protected.
ALL : ALL \
        : severity auth.info \
        : twist /bin/echo "You are not welcome to use %d from %h."
....

В этом примере сообщение, "You are not allowed to use `daemon` from `hostname`." будет возвращено от всех даемонов, которые не были предварительно настроены в файле доступа. Обратите внимание, что возвращаемое сообщение _должно_ быть заключено в кавычки; из этого правила нет исключений.

[WARNING]
====

Возможна реализация DoS атаки, когда группа атакующих производит множество запросов на подключение.
====

Возможно также использование параметра `spawn`. Как и параметр `twist`, параметр `spawn` подразумевает запрет соединения и может использоваться для запуска команд или скриптов. В отличие от `twist`, `spawn` не отправляет ответ вызывающей стороне. Например, следующая конфигурация:

[.programlisting]
....
# We do not allow connections from example.com:
ALL : .example.com \
        : spawn (/bin/echo %a from %h attempted to access %d >> \
          /var/log/connections.log) \
        : deny
....

отклонит все попытки соединения из домена `*.example.com`; имя хоста, IP адрес и даемон протоколируются в файл [.filename]#/var/log/connections.log#.

Помимо приведенных выше символов подстановки, например %a, существует еще несколько символов. Обратитесь к странице man:hosts_access[5] справочной системы за полным списком.

==== Параметры - шаблоны

До этого момента в примерах использовался шаблон `ALL`. Существуют и другие параметры, функциональность которых в дальнейшем может быть расширена. `ALL` соответствует любому даемону, домену или IP адресу. Другой доступный шаблон это `PARANOID`, который соответствует хосту, IP адрес которого может быть подделан. Другими словами, `paranoid` может быть использован для определения действия с хостами, IP адрес которых не соответствует имени хоста. Вот пример применения этого параметра:

[.programlisting]
....
# Block possibly spoofed requests to sendmail:
sendmail : PARANOID : deny
....

В этом примере все запросы на подключения к `sendmail` от хостов, IP адрес которых не соответствует имени хоста, будут отклонены.

[CAUTION]
====

Использование `PARANOID` невозможно, если у клиента или сервера неправильно настроен DNS. В таких случаях необходимо вмешательство администратора.
====

Более подробная информация о шаблонах и их возможностях дана на странице man:hosts_access[5] справочной системы.

Для того, чтобы любая выбранная конфигурация заработала, в [.filename]#hosts.allow# необходимо закомментировать первую строку настройки. В начале раздела об этом не упоминалось.

[[kerberosIV]]
== KerberosIV

Kerberos это сетевая дополнительная система/протокол, которая делает возможной аутентификацию пользователей через сервисы на защищенном сервере. Такие сервисы, как удаленный вход, удаленное копирование, защищенное копирование файлов между системами и другие задачи с высоким риском становятся допустимо безопасными и более контролируемыми.

Последующие инструкции могут использоваться в качестве руководства по настройке поставляемого с FreeBSD Kerberos. Тем не менее, вам могут потребоваться страницы справочника полного дистрибутива.

=== Установка KerberosIV

Kerberos это опциональный компонент FreeBSD. Простейший способ установки этой программы это выбор `krb4` или `krb5` из sysinstall во время первой установки FreeBSD. Будет установлен "eBones" (KerberosIV) или "Heimdal" (Kerberos5) вариант Kerberos. Включение этих реализаций объясняется тем, что они разработаны вне США/Канады и доступны вне этих стран, поскольку на них не влияют ограничения на экспорт криптографического кода из США.

Кроме того, реализация MIT Kerberos доступна из Коллекции Портов в виде пакета package:security/krb5[].

=== Создание базы данных

Это необходимо сделать только на сервере Kerberos. Во-первых, убедитесь что не осталось старой базы данных Kerberos. Войдите в каталог [.filename]#/etc/kerberosIV# и убедитесь, что в нем находятся только эти файлы:

[source,shell]
....
# cd /etc/kerberosIV
# ls
README	        krb.conf        krb.realms
....

Если присутствуют еще какие-то файлы (такие как [.filename]#principal.*# или [.filename]#master_key#), используйте команду `kdb_destroy` для удаления старой базы данных Kerberos, или, если Kerberos не запущен, просто удалите эти файлы.

Затем отредактируйте файлы [.filename]#krb.conf# и [.filename]#krb.realms#, введя ваши данные. В этом примере уникальный идентификатор `EXAMPLE.COM`, сервер `grunt.example.com`. Отредактируем или создадим файл [.filename]#krb.conf#:

[source,shell]
....
# cat krb.conf
EXAMPLE.COM
EXAMPLE.COM grunt.example.com admin server
CS.BERKELEY.EDU okeeffe.berkeley.edu
ATHENA.MIT.EDU kerberos.mit.edu
ATHENA.MIT.EDU kerberos-1.mit.edu
ATHENA.MIT.EDU kerberos-2.mit.edu
ATHENA.MIT.EDU kerberos-3.mit.edu
LCS.MIT.EDU kerberos.lcs.mit.edu
TELECOM.MIT.EDU bitsy.mit.edu
ARC.NASA.GOV trident.arc.nasa.gov
....

В этом примере другие идентификаторы введены для иллюстрации настройки c несколькими хостами. С целью упрощения настройки вы можете не включать их.

Первая строка содержит идентификатор, под которым работает эта система. Остальные строки связывают идентификаторы с именами хостов. Сначала указывается идентификатор, затем хост под этим идентификатором, работающий как "центр распространения ключей". Слова `admin server` с последующим именем хоста означают, что этот хост также является сервером администрирования базы данных. За дальнейшей информацией об этих терминах обратитесь к страницам справочника по Kerberos.

Мы добавили `grunt.example.com` к идентификатору `EXAMPLE.COM` и кроме того сопоставили всем хостам в домене `.example.com` идентификатор `EXAMPLE.COM`. Файл [.filename]#krb.realms# будет выглядеть так:

[source,shell]
....
# cat krb.realms
grunt.example.com EXAMPLE.COM
.example.com EXAMPLE.COM
.berkeley.edu CS.BERKELEY.EDU
.MIT.EDU ATHENA.MIT.EDU
.mit.edu ATHENA.MIT.EDU
....

Как и в предыдущем примере, другие идентификаторы добавлены только для примера. С целью упрощения настройки вы можете не включать их.

В первой строке _определенная_ система сопоставляется с идентификатором. В остальных строках показано, сопоставить идентификатору остальные системы определенного поддомена.

Теперь мы готовы к созданию базы данных. Потребуется всего лишь запустить сервер Kerberos (или центр распространения ключей). Используйте для этого `kdb_init`:

[source,shell]
....
# kdb_init
Realm name [default  ATHENA.MIT.EDU ]: EXAMPLE.COM
You will be prompted for the database Master Password.
It is important that you NOT FORGET this password.

Введите главный ключ Kerberos: 
....

Теперь мы должны сохранить ключ, чтобы сервера на локальных компьютерах могли его взять. Используйте для этого команду `kstash`:

[source,shell]
....
# kstash

Enter Kerberos master key:

Current Kerberos master key version is 1.

Master key entered. BEWARE!
....

Этой командой зашифрованный главный пароль сохранен в [.filename]#/etc/kerberosIV/master_key#.

=== Запуск Kerberos

Для каждой системы, защищаемой Kerberos, в базу данных должны быть добавлены две записи. Это `kpasswd` и `rcmd`. Они добавляются вместе с именем системы.

Эти даемоны, kpasswd и rcmd позволяют другим системам изменять пароли Kerberos и запускать такие команды как man:rcp[1], man:rlogin[1], man:rsh[1].

Теперь добавим эти записи:

[source,shell]
....
# kdb_edit
Opening database...

Enter Kerberos master key:

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Previous or default values are in [brackets] ,
enter return to leave the same, or new value.

Principal name: passwd
Instance: grunt

<Not found>, Create [y] ? y

Principal: passwd, Instance: grunt, kdc_key_ver: 1
New Password:                    <---- enter RANDOM here
Verifying password

New Password: <---- enter RANDOM here

Random password [y] ? y

Principal's new key version = 1
Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ?
Max ticket lifetime (*5 minutes) [ 255 ] ?
Attributes [ 0 ] ?
Edit O.K.
Principal name: rcmd
Instance: grunt

<Not found>, Create [y] ?

Principal: rcmd, Instance: grunt, kdc_key_ver: 1
New Password:		<---- enter RANDOM here
Verifying password

New Password:           <---- enter RANDOM here

Random password [y] ?

Principal's new key version = 1
Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ?
Max ticket lifetime (*5 minutes) [ 255 ] ?
Attributes [ 0 ] ?
Edit O.K.
Principal name:         <---- null entry here will cause an exit
....

=== Создание файла настройки сервера

Теперь необходимо создать все записи сервисов, которые были определены для каждого компьютера. Используем для этого команду `ext_srvtab`. Будет создан файл, который должен быть скопирован или перемещен _безопасным способом_ в каталог [.filename]#/etc/kerberosIV# каждого Kerberos клиента. Этот файл должен присутствовать на каждом сервере и клиенте, он необходим для работы Kerberos.

[source,shell]
....
# ext_srvtab grunt
Enter Kerberos master key:

Current Kerberos master key version is 1.

Master key entered. BEWARE!
Generating 'grunt-new-srvtab'....
....

Эта команда создаст временный файл, который должен быть переименован в [.filename]#srvtab#, чтобы серверы смогли обратиться к нему. Используйте команду man:mv[1] для перемещения его в исходной системе:

[source,shell]
....
# mv grunt-new-srvtab srvtab
....

Если файл предназначен для клиентской системы, и сеть не безопасна, скопируйте [.filename]#client-new-srvtab# на съемный носитель и перенесите файл с его помощью. Убедитесь, что переименовали его в [.filename]#srvtab# в каталоге [.filename]#/etc/kerberosIV# клиента, и что режим доступа к нему 600:

[source,shell]
....
# mv grumble-new-srvtab srvtab
# chmod 600 srvtab
....

=== Пополнение базы данных

Теперь необходимо добавить в базу данных пользователей. Во-первых, создадим запись для пользователя `jane`. Используйте команду `kdb_edit`:

[source,shell]
....
# kdb_edit
Opening database...

Enter Kerberos master key:

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Previous or default values are in [brackets] ,
enter return to leave the same, or new value.

Principal name: jane
Instance:

<Not found>, Create [y] ? y

Principal: jane, Instance: , kdc_key_ver: 1
New Password:                <---- enter a secure password here
Verifying password

New Password:                <---- re-enter the password here
Principal's new key version = 1
Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ?
Max ticket lifetime (*5 minutes) [ 255 ] ?
Attributes [ 0 ] ?
Edit O.K.
Principal name:		   <---- null entry here will cause an exit
....

=== Тестирование всей системы

Во-первых, запустите даемоны Kerberos. При правильном редактировании файла [.filename]#/etc/rc.conf# они запустятся автоматически при перезагрузке. Это необходимо только на сервере Kerberos. Клиенты Kerberos получат все необходимые данные из каталога [.filename]#/etc/kerberosIV#.

[source,shell]
....
# kerberos &
Kerberos server starting
Sleep forever on error
Log file is /var/log/kerberos.log
Current Kerberos master key version is 1.

Master key entered. BEWARE!

Current Kerberos master key version is 1
Local realm: EXAMPLE.COM
# kadmind -n &
KADM Server KADM0.0A initializing
Please do not use 'kill -9' to kill this job, use a
regular kill instead

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
....

Теперь для получения доступа через созданного пользователя `jane` используйте `kinit`:

[source,shell]
....
% kinit jane
MIT Project Athena (grunt.example.com)
Kerberos Initialization for "jane"
Password: 
....

Попробуйте просмотреть имеющиеся данные с помощью `klist`:

[source,shell]
....
% klist
Ticket file:    /tmp/tkt245
Principal:      jane@EXAMPLE.COM

  Issued           Expires          Principal
Apr 30 11:23:22  Apr 30 19:23:22  krbtgt.EXAMPLE.COM@EXAMPLE.COM
....

Теперь попробуйте изменить пароль с помощью man:passwd[1], чтобы убедиться, что даемон kpasswd может получить информацию из базы данных Kerberos:

[source,shell]
....
% passwd
realm EXAMPLE.COM
Old password for jane:
New Password for jane:
Verifying password
New Password for jane:
Password changed.
....

=== Включение `su`

Kerberos позволяет назначить _каждому_ пользователю, который нуждается в привилегиях `root`, свой _собственный_ пароль man:su[1]. Необходимо добавить учётную запись, которой разрешено получать `root` доступ через man:su[1]. Это делается путем связывания учётной записи `root` с пользовательской учётной записью. Создадим в базе данных Kerberos запись `jane.root` с помощью `kdb_edit`:

[source,shell]
....
# kdb_edit
Opening database...

Enter Kerberos master key:

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Previous or default values are in [brackets] ,
enter return to leave the same, or new value.

Principal name: jane
Instance: root

<Not found>, Create [y] ? y

Principal: jane, Instance: root, kdc_key_ver: 1
New Password:                    <---- enter a SECURE password here
Verifying password

New Password:    	 	 <---- re-enter the password here

Principal's new key version = 1
Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ?
Max ticket lifetime (*5 minutes) [ 255 ] ? 12 <--- Keep this short!
Attributes [ 0 ] ?
Edit O.K.
Principal name:		         <---- null entry here will cause an exit
....

Теперь проверим работоспособность этой записи:

[source,shell]
....
# kinit jane.root
MIT Project Athena (grunt.example.com)
Kerberos Initialization for "jane.root"
Password:
....

Необходимо добавить пользователя к `root` файлу [.filename]#.klogin#:

[source,shell]
....
# cat /root/.klogin
jane.root@EXAMPLE.COM
....

Теперь попробуйте выполнить man:su[1]:

[source,shell]
....
% su
Password:
....

и посмотрите на имеющиеся данные:

[source,shell]
....
# klist
Ticket file:	/tmp/tkt_root_245
Principal:      jane.root@EXAMPLE.COM

  Issued           Expires          Principal
May  2 20:43:12  May  3 04:43:12  krbtgt.EXAMPLE.COM@EXAMPLE.COM
....

=== Использование других команд

В примере выше мы создали запись (principal) `jane` с доступом к `root` (instance). Она основана на пользователе с таким же именем, как и идентификатор, что принято Kerberos по умолчанию; `<principal>.<instance>` в форме `<username>.``root` позволяет использовать man:su[1] для доступа к `root`, если соответствующие записи находятся в файле [.filename]#.klogin# домашнего каталога `root`:

[source,shell]
....
# cat /root/.klogin
jane.root@EXAMPLE.COM
....

Подобно этому, если в файле [.filename]#.klogin# из домашнего каталога пользователя есть строки в форме:

[source,shell]
....
% cat ~/.klogin
jane@EXAMPLE.COM
jack@EXAMPLE.COM
....

это позволит любому с идентификатором `EXAMPLE.COM`, кто аутентифицировался как `jane` или `jack` (с помощью команды `kinit`, см. выше) получить доступ к учётной записи пользователя `jane` или файлам этой системы (`grunt`) через man:rlogin[1], man:rsh[1] или man:rcp[1].

Например, `jane` может входить в другую систему используя Kerberos:

[source,shell]
....
% kinit
MIT Project Athena (grunt.example.com)
Password:
% rlogin grunt
Last login: Mon May  1 21:14:47 from grumble
Copyright (c) 1980, 1983, 1986, 1988, 1990, 1991, 1993, 1994
        The Regents of the University of California.   All rights reserved.

FreeBSD BUILT-19950429 (GR386) #0: Sat Apr 29 17:50:09 SAT 1995
....

Или `jack` входит в учётную запись `jane`'s на этом же компьютере (файл [.filename]#.klogin#`jane` настроен как показано выше, и в Kerberos настроена учётная запись _jack_):

[source,shell]
....
% kinit
% rlogin grunt -l jane
MIT Project Athena (grunt.example.com)
Password:
Last login: Mon May  1 21:16:55 from grumble
Copyright (c) 1980, 1983, 1986, 1988, 1990, 1991, 1993, 1994
        The Regents of the University of California.   All rights reserved.
FreeBSD BUILT-19950429 (GR386) #0: Sat Apr 29 17:50:09 SAT 1995
....

[[kerberos5]]
== Kerberos5

Все релизы FreeBSD после FreeBSD-5.1 включают поддержку только Kerberos5. Таким образом, Kerberos5 это единственная включаемая в поставку версия и его конфигурация похожа на KerberosIV во многих аспектах. Эта информация применима только к Kerberos5 из релизов после FreeBSD-5.0. Пользователи, желающие использовать пакет KerberosIV, могут установить его из порта package:security/krb4[].

Kerberos это дополнительная сетевая система/протокол, позволяющая пользователям авторизоваться через защищенные сервисы на защищенном сервере. Такие сервисы как удаленный вход, удаленное копирование, защищенное копирование файлов между системами и другие задачи с высоким риском становятся допустимо безопасными и более контролируемыми.

Kerberos может быть описана как прокси система идентификации-проверки. Она также может быть описана как защищенная внешняя система аутентификации. Kerberos предоставляет только одну функцию - защищенную аутентификацию пользователей сети. Он не предоставляет функций авторизации (что разрешено делать пользователям) или функций аудита (какой пользователь что делает). После того, как клиент и сервер использовали Kerberos для идентификации, они могут зашифровать все соединения для гарантирования собственной безопасности и целостности данных.

Следовательно крайне рекомендуется использовать Kerberos с другими методами безопасности, предоставляющими сервисы авторизации и аудита.

Последующие инструкции могут использоваться в качестве руководства по настройке Kerberos, поставляемого с FreeBSD. Тем не менее, вам потребуется обратиться к соответствующим страницам справочника за полным описанием.

В целях демонстрации установки Kerberos, будут применены следующие обозначения:

* DNS домен ("зона") example.org.
* Уникальный идентификатор Kerberos EXAMPLE.ORG.

[NOTE]
====
Используйте действующие имена доменов при настройке Kerberos даже если вы будете использовать его во внутренней сети. Это позволит избежать проблем с DNS и гарантирует возможность связи с Kerberos под другими идентификаторами.
====

=== История

Kerberos был создан MIT в качестве решения проблем с безопасностью сети. Протокол Kerberos использует стойкую криптографию, так что клиент может идентифицироваться на сервере (и обратно) через незащищенное сетевое соединение.

Kerberos это и имя сетевого протокола аутентификации и общий термин для описания программ, где он реализован (например, Kerberos telnet). Текущая версия протокола 5 описана в RFC 1510.

Доступно несколько свободных реализаций этого протокола, работающих на множестве операционных систем. Massachusetts Institute of Technology (MIT), где Kerberos был первоначально разработан, продолжает разрабатывать собственный пакет Kerberos. Он обычно использовался в США как криптографический продукт, и в этом качестве попадал под действие ограничений на экспорт. MITKerberos доступен в виде порта (package:security/krb5[]). Heimdal Kerberos это другая реализация версии 5, которая разрабатывалась исключительно вне США для обхода экспортных ограничений (и поэтому часто включалась в некоммерческие реализации UNIX(R)). Heimdal Kerberos доступен в виде порта (package:security/heimdal[]), его минимальный комплект включен в базовую установку FreeBSD.

В целях получения наибольшей аудитории, в этих инструкциях предполагается использование Heimdal включаемого в FreeBSD.

=== Настройка Heimdal KDC

Центр распространения ключей (Key Distribution Center, KDC) это централизованный сервис аутентификации, предоставляемый Kerberos - это компьютер, который предоставляет доступ через Kerberos. KDC считается доверяемым всеми другими компьютерами с определенным идентификатором Kerberos и поэтому к нему предъявляются высокие требования безопасности.

Имейте ввиду, что хотя работа сервера Kerberos требует очень немного вычислительных ресурсов, из соображений безопасности для него рекомендуется отдельный компьютер, работающий только в качестве KDC.

Перед началом настройки KDC, убедитесь что в файле [.filename]#/etc/rc.conf# содержатся правильные настройки для работы в качестве KDC (вам может потребоваться изменить пути в соответствии с собственной системой):

[.programlisting]
....
kerberos5_server_enable="YES"
kadmind5_server_enable="YES"
....

Затем приступим к редактированию файла настройки Kerberos, [.filename]#/etc/krb5.conf#:

[.programlisting]
....
[libdefaults]
    default_realm = EXAMPLE.ORG
[realms]
    EXAMPLE.ORG = {
        kdc = kerberos.example.org
        admin_server = kerberos.example.org
    }
[domain_realm]
    .example.org = EXAMPLE.ORG
....

Обратите внимание что в файле [.filename]#/etc/krb5.conf# подразумевается наличие у KDC полного имени `kerberos.example.org`. Вам потребуется добавить CNAME (синоним) к файлу зоны, если у KDC другое имя.

[NOTE]
====
Для больших сетей с правильно настроенным сервером BINDDNS пример выше может быть урезан до:

[.programlisting]
....
[libdefaults]
      default_realm = EXAMPLE.ORG
....

Со следующими строками, добавленными в файл зоны `example.org`:

[.programlisting]
....
_kerberos._udp      IN  SRV     01 00 88 kerberos.example.org.
_kerberos._tcp      IN  SRV     01 00 88 kerberos.example.org.
_kpasswd._udp       IN  SRV     01 00 464 kerberos.example.org.
_kerberos-adm._tcp  IN  SRV     01 00 749 kerberos.example.org.
_kerberos           IN  TXT     EXAMPLE.ORG
....

====

[NOTE]
====
Чтобы клиенты могли найти сервисы Kerberos, _необходимо_ наличие или полностью настроенного [.filename]#/etc/krb5.conf# или минимально настроенного [.filename]#/etc/krb5.conf#_и_ правильно настроенного DNS сервера.
====

Создадим теперь базу данных Kerberos. Эта база данных содержит ключи всех основных хостов, зашифрованных с помощью главного пароля. Вам не требуется помнить этот пароль, он хранится в файле ([.filename]#/var/heimdal/m-key#). Для создания главного ключа запустите `kstash` и введите пароль.

Как только будет создан главный ключ, вы можете инициализировать базу данных с помощью программы `kadmin` с ключом `-l` (означающим "local"). Этот ключ сообщает `kadmin` обращаться к файлам базы данных непосредственно вместо использования сетевого сервиса `kadmind`. Это помогает решить "проблему курицы и яйца", когда обращение идет к еще не созданной базе данных. Как только вы увидите приглашение `kadmin`, используйте команду `init` для создания базы данных идентификаторов.

Наконец, оставаясь в приглашении `kadmin`, создайте первую запись с помощью команды `add`. Оставьте неизменными параметры по умолчанию, вы всегда сможете изменить их позже с помощью команды `modify`. Обратите внимание, что вы всегда можете использовать команду `?` для просмотра доступных параметров.

Пример создания базы данных показан ниже:

[source,shell]
....
# kstash
Master key: xxxxxxxx
Verifying password - Master key: xxxxxxxx

# kadmin -l
kadmin> init EXAMPLE.ORG
Realm max ticket life [unlimited]:
kadmin> add tillman
Max ticket life [unlimited]:
Max renewable life [unlimited]:
Attributes []:
Password: xxxxxxxx
Verifying password - Password: xxxxxxxx
....

Теперь пришло время запустить сервисы KDC. Выполните команды `/etc/rc.d/kerberos start` и `/etc/rc.d/kadmind start` для запуска сервисов. Заметьте, что ни один из поддерживающих Kerberos даемонов на этот момент запущен не будет, но у вас должна быть возможность убедиться в том, что KDC функционирует путем получения списка доступа для пользователя, которого вы только что самостоятельно создали из командной строки самого KDC:

[source,shell]
....
% k5init tillman
tillman@EXAMPLE.ORG's Password:

% k5list
Credentials cache: FILE:/tmp/krb5cc_500
        Principal: tillman@EXAMPLE.ORG

  Issued           Expires          Principal
Aug 27 15:37:58  Aug 28 01:37:58  krbtgt/EXAMPLE.ORG@EXAMPLE.ORG
....

=== Сервер Kerberos с сервисами Heimdal

Для начала нам потребуется копия файла настройки Kerberos, [.filename]#/etc/krb5.conf#. Просто скопируйте его с KDC на клиентский компьютер безопасным способом (используя сетевые утилиты, такие как man:scp[1], или физически, с помощью дискеты).

Затем вам понадобится файл [.filename]#/etc/krb5.keytab#. Это основное различие между сервером, поддерживающим Kerberos и рабочими станциями - на сервере должен быть файл [.filename]#keytab#. В этом файле находится центральный ключ сервера, который позволяет KDC проверять все другие идентификаторы. Он должен быть помещен на сервер безопасным способом, поскольку безопасность сервера может быть нарушена, если ключ станет общедоступен. Это означает, что его передача через прозрачный канал, такой как FTP - очень плохая идея.

Обычно перенос файла [.filename]#keytab# на сервер производится с помощью программы `kadmin`. Это удобно, поскольку вам потребуется также создать запись хоста (KDC часть [.filename]#krb5.keytab#) с помощью `kadmin`.

Обратите внимание, что должны быть уже зарегистрированы в системе и необходимо наличие прав на использование интерфейса `kadmin` в файле [.filename]#kadmind.acl#. Обратитесь к разделу "Remote administration" в info страницах Heimdal (`info heimdal`) за деталями по составлению списка доступа. Если вы не хотите включать удаленный доступ `kadmin`, можете просто подключиться к KDC через защищенное соединение (локальную консоль, man:ssh[1] или Kerberos man:telnet[1]) и выполнять администрирование локально с помощью `kadmin -l`.

После добавления файла [.filename]#/etc/krb5.conf#, вы можете использовать `kadmin` с сервера Kerberos. Команда `add --random-key` позволит вам добавить запись для сервера, а команда `ext` позволит перенести эту запись в собственный keytab файл сервера. Например:

[source,shell]
....
# kadmin
kadmin> add --random-key host/myserver.example.org
Max ticket life [unlimited]:
Max renewable life [unlimited]:
Attributes []:
kadmin> ext host/myserver.example.org
kadmin> exit
....

Обратите внимание, что команда `ext` (сокращение от "extract") сохраняет полученный ключ в файле [.filename]#/etc/krb5.keytab# по умолчанию.

Если на KDC не запущен `kadmind` (возможно по соображениям безопасности) и вы не можете получить доступ к `kadmin` удаленно, возможно добавление записи хоста (`host/myserver.EXAMPLE.ORG`) непосредственно на KDC с последующим извлечением ее во временный файл (и перезаписью [.filename]#/etc/krb5.keytab# на KDC) примерно так:

[source,shell]
....
# kadmin
kadmin> ext --keytab=/tmp/example.keytab host/myserver.example.org
kadmin> exit
....

Затем вы можете скопировать keytab на сервер защищенным способом (например, используя `scp` или дискету). Убедитесь, что используемое имя keytab не совпадает с именем по умолчанию во избежание перезаписывания keytab на KDC.

Теперь ваш сервер может связываться с KDC (добавлен файл [.filename]#krb5.conf#) и идентифицировать себя (добавлен файл [.filename]#krb5.keytab#). Теперь вы готовы к включению некоторых сервисов Kerberos. В этом примере мы включим сервис `telnet`, поместив в [.filename]#/etc/inetd.conf# нижеприведенную строку и перезапустив сервис man:inetd[8] командой `/etc/rc.d/inetd restart`:

[.programlisting]
....
telnet    stream  tcp     nowait  root    /usr/libexec/telnetd  telnetd -a user
....

Очень важно установить ключ `-a` (тип аутентификации) в user. Обратитесь к странице справочника man:telnetd[8] за подробной информацией.

=== Клиент Kerberos с Heimdal

Настройка клиентского компьютера почти тривиально проста. Как только настройка Kerberos закончена, вам потребуется только файл настройки Kerberos, [.filename]#/etc/krb5.conf#. Просто скопируйте его безопасным способом на клиентский компьютер с KDC.

Протестируйте клиентский компьютер, попытавшись использовать `kinit`, `klist`, и `kdestroy` для получения, отображения и удаления списка доступа. Соединитесь с Kerberos севером используя клиент Kerberos, если соединение не работает и получение доступа является проблемой, это скорее всего проблема сервера, а не клиента или KDC.

При тестировании приложения вроде `telnet`, попробуйте использовать программу перехвата пакетов (такую как man:tcpdump[1]), чтобы убедиться, что ваш пароль не передается незашифрованным. Попробуйте использовать `telnet` с параметром `-x`, чтобы зашифровать весь поток данных (подобно `ssh`).

Основные клиентские приложения Kerberos (традиционно называющиеся `kinit`, `klist`, `kdestroy`, и `kpasswd`) находятся в базовой установке FreeBSD. Обратите внимание, что в FreeBSD версий до 5.0 они были переименованы в `k5init`, `k5list`, `k5destroy`, `k5passwd`, и `k5stash` (хотя их обычно использовали лишь однократно).

Различные неосновные клиентские приложения Kerberos также устанавливаются по умолчанию. Здесь проявляется "минимальность" базовой установки Heimdal: `telnet` это единственное приложение, поддерживающее Kerberos.

Порт Heimdal добавляет некоторые отсутствующие клиентские приложения: поддерживающие Kerberos версии `ftp`, `rsh`, `rcp`, `rlogin`, и некоторые другие реже используемые программы. Порт MIT также содержит полный пакет клиентских приложений Kerberos.

=== Пользовательские файлы настройки: [.filename]#.k5login# и [.filename]#.k5users#

Учётные записи пользователя в Kerberos (например `tillman@EXAMPLE.ORG`) обычно связаны с локальными учётными записями (например с локальной учётной записью6 `tillman`). Клиентские приложения, такие как `telnet`, обычно не требуют указания имени пользователя или учётной записи.

Тем не менее, время от времени вам может потребоваться дать доступ к локальной учётной записи кому-то, у кого нет соответствующей учётной записи Kerberos. Например, пользователю `tillman@EXAMPLE.ORG` может потребоваться доступ к локальной учётной записи `webdevelopers`. Другим учётным записям также может потребоваться доступ к этой локальной учётной записи.

Файлы [.filename]#.k5login# и [.filename]#.k5users#, помещенные в домашний каталог пользователя, могут быть использованы подобно действенной комбинации [.filename]#.hosts# и [.filename]#.rhosts# для решения этой проблемы. Например, файл [.filename]#.k5login# со следующим содержанием:

[source,shell]
....
tillman@example.org
jdoe@example.org
....

помещен в домашний каталог локального пользователя `webdevelopers`, то обе упомянутые учётные записи получат доступ к этой учётной записи без необходимости наличия общего пароля.

Рекомендуется прочитать страницу справочника по этим командам. Обратите внимание, что страница справочника о `ksu` содержит информацию по [.filename]#.k5users#.

=== Подсказки, советы и решение проблем с Kerberos

* При использовании портов как Heimdal так и MITKerberos убедитесь, что в `PATH` версии Kerberos клиентов указаны перед их версиями в базовой системе.
* Все ли компьютеры в пределах данного realm синхронизированы по времени? Если нет, аутентификация может завершиться неудачно. crossref:network-servers[network-ntp,Синхронизация часов через NTP] описывает как синхронизировать часы с использованием NTP.
* MIT и Heimdal успешно взаимодействуют. За исключением `kadmin`, протокол для которого не стандартизован.
* Если вы изменяете hostname, потребуется также изменить учётную запись `host/` и обновить keytab. Это также необходимо для специальных записей в keytab, таких как `www/` запись модуля Apache package:www/mod_auth_kerb[].
* Все хосты под общим идентификатором должны разрешаться DNS (прямое и обратное разрешение), или как минимум через [.filename]#/etc/hosts#. Записи CNAME будут работать, но записи A и PTR должны быть корректны и находиться на своем месте. Сообщение об ошибке не всегда интуитивно понятно: `Kerberos5 refuses authentication because Read req failed: Key table entry not found`.
* Некоторые операционные системы, способные работать в качестве клиентов KDC не устанавливают права для `ksu` в setuid `root`. Это означает, что `ksu` не работает, что хорошо является хорошей идеей для безопасности, но неудобно. Это не ошибка KDC.
* С MITKerberos, если вы хотите продлить действие доступа до значения большего, чем десять часов по умолчанию, используйте команду `modify_principal` в `kadmin` для изменения maxlife доступа к самой учётной записи и к учётной записи `krbtgt`. Затем возможно использование `kinit` с параметром `-l` для запроса доступа с большим временем действия.
*
[NOTE]
====
Если вы запускаете перехватчик пакетов на KDC для разрешения проблем, а затем запускаете `kinit` с рабочей станции, то увидите, что TGT посылается непосредственно при запуске `kinit` - даже до того, как вы введете пароль! Объяснение в том, что сервер Kerberos свободно распространяет TGT (Ticket Granting Ticket) на каждый неавторизованный запрос; однако, каждый TGT зашифрован ключом, полученным из пароля пользователя. Следовательно, когда пользователь вводит свой пароль, он не отправляется на KDC, а используется для расшифровка TGT, который уже получен `kinit`. Если в процессе расшифровки получается правильный билет с правильным значением времени, у пользователя есть действующее "удостоверение". Это удостоверение содержит ключ сессии для установления безопасного соединения с сервером Kerberos, как и действующий TGT, зашифрованный ключом сервера Kerberos. Второй уровень шифрования недоступен пользователю, но позволяет серверу Kerberos проверять правильность каждого TGT.
====

* Если вы хотите установить большое время жизни доступа (например, неделю), и используете OpenSSH для соединения с компьютером, где хранится "билет", убедитесь, что параметр Kerberos`TicketCleanup` установлен в `no` в файле [.filename]#sshd_config#, или билеты будут уничтожены при выходе из сеанса.
* Запомните, что время жизни билетов хостов больше. Если время жизни билета для учётной записи пользователя составляет неделю, а время жизни учётной записи хоста, к которому вы подсоединяетесь девять часов, учётная запись хоста в кэше устареет и кэш билетов будет работать не так, как ожидается.
* При настройке файла [.filename]#krb5.dict# на предотвращение использования определенных плохих паролей (страница справочника для `kadmind` кратко рассказывает об этом), запомните, что это применимо только к учётным записям, для которых действует политика паролей. Формат файла [.filename]#krb5.dict# прост: одно слово на строку. Может помочь создание символической ссылки на [.filename]#/usr/shared/dict/words#.

=== Отличия от порта MIT

Основное различие между установками MIT и Heimdal относится к программе `kadmin`, которая имеет другой (но эквивалентный) набор команд и использует другой протокол. Если ваш KDC работает на MIT, вы не сможете использовать `kadmin` для удаленного администрирования KDC (и наоборот, по этой же причине).

Опции командной строки клиентов также могут немного отличаться для одинаковых задач. Рекомендуется следование инструкциям на MITKerberos Web-сайте (http://web.mit.edu/Kerberos/www/[http://web.mit.edu/Kerberos/www/]). Будьте внимательны при определении `PATH`: порт MIT устанавливается по умолчанию в [.filename]#/usr/local/#, и если в `PATH` вначале указаны системные каталоги, вместо приложений MIT могут быть запущены системные приложения.

[NOTE]
====
С портом MITpackage:security/krb5[], предоставляемым FreeBSD, убедитесь что файл [.filename]#/usr/local/shared/doc/krb5/README.FreeBSD# установлен портом, если вы хотите понять почему вход через `telnetd` и `klogind` иногда происходит так странно. Наиболее важно, исправление "incorrect permissions on cache file" требует использования бинарного файла `login.krb5` для аутентификации, чтобы права на переданное удостоверение передавались правильно.
====

=== Преодоление ограничений, обнаруженных в Kerberos

==== Kerberos это все или ничего

Каждый сервис, работающий в сети, должен быть модифицирован для работы с Kerberos (или другим способом защищен от атак по сети) или удостоверения пользователей могут быть украдены или использованы повторно. В качестве примера может быть приведено использование Kerberos версий оболочек для удаленной работы (например через `rsh` и `telnet`), при наличии POP3 сервера, получающего пароли в незашифрованном виде.

==== Kerberos предназначен для однопользовательских рабочих станций

В многопользовательской среде Kerberos менее безопасен. Это потому, что он хранит билеты в каталоге [.filename]#/tmp#, которая доступна для чтения всем. Если пользователь работает с несколькими другими пользователями одновременно на одном компьютере (т.е. в многопользовательской среде), возможна кража (копирование) билета другим пользователем.

Решить проблему можно с помощью параметра командной строки `-c` или (предпочтительно) с помощью переменной окружения `KRB5CCNAME`, но это делается редко. Для преодоления ограничения достаточно сохранять билет в домашнем каталоге пользователя и использовать простые ограничения на доступ к файлам.

==== От KDC зависит вся система

Архитектура системы такова, что KDC должен быть максимально защищен, поскольку главный пароль базы данных содержится в нем. На KDC не должно быть запущено никаких других сервисов и он должен быть защищен физически. Опасность велика, поскольку Kerberos хранит все пароли зашифрованными одним ключом ("главным" ключом), который хранится в файле на KDC.

Хорошей новостью является то, что кража главного ключа не станет такой проблемой, как может показаться. Главный ключ используется только для шифрования базы данных Kerberos и в качестве seed для генератора случайных чисел. Поскольку доступ к KDC защищен, атакующий мало что сможет сделать с главным ключом.

Кроме того, если KDC станет недоступен (возможно по причине атак DoS или проблем в сети) сетевые сервисы будет невозможно использовать, поскольку аутентификация не может быть выполнена. Уменьшить последствия можно при наличии нескольких KDC (один главный и один или несколько резервных) и с аккуратно реализованной резервной аутентификацией (отлично подойдет PAM).

==== Недостатки Kerberos

Kerberos позволяет пользователям, хостам и сервисам производить аутентификацию друг друга. В нем нет механизма аутентификации KDC для пользователей, хостов или сервисов. Это означает, что поддельный `kinit` (например) может записывать все имена пользователей и паролей. Помочь решить проблему может package:security/tripwire[] или другой инструмент проверки целостности файловой системы.

=== Ресурсы и информация для дальнейшего изучения

* http://www.faqs.org/faqs/Kerberos-faq/general/preamble.html[ Kerberos FAQ]
* http://web.mit.edu/Kerberos/www/dialogue.html[Разработка системы аутентификации: диалог в четырех сценах]
* http://www.ietf.org/rfc/rfc1510.txt?number=1510[RFC 1510, Kerberos Network Authentication Service (V5)]
* http://web.mit.edu/Kerberos/www/[Домашняя страница MIT Kerberos]
* http://www.pdc.kth.se/heimdal/[Домашняя страница Heimdal Kerberos]

[[openssl]]
== OpenSSL

Одной из программ, требующих особого внимания пользователей, является набор программ OpenSSL, включенный в FreeBSD. OpenSSL предоставляет уровень шифрования поверх обычных уровней соединения; следовательно, он может быть использован многими сетевыми приложениями и сервисами.

OpenSSL может использоваться для шифрования соединений почтовых клиентов, транзакций через интернет, например для кредитных карт, и многого другого. Многие порты, такие как package:www/apache13-ssl[] и package:mail/sylpheed-claws[] собираются с OpenSSL.

[NOTE]
====
В большинстве случаев в Коллекции Портов будет сделана попытка построения порта package:security/openssl[], если только переменная `WITH_OPENSSL_BASE` не установлена явно в "yes".
====

Версия OpenSSL, включаемая в FreeBSD, поддерживает сетевые протоколы безопасности Secure Sockets Layer v2/v3 (SSLv2/SSLv3), Transport Layer Security v1 (TLSv1) и может быть использована в качестве основной криптографической библиотеки.

[NOTE]
====
Хотя OpenSSL поддерживает алгоритм IDEA, по умолчанию он отключен из-за патентных ограничений Соединенных Штатов. Для его использования необходимо ознакомиться с лицензией, и, если ограничения приемлемы, установить в [.filename]#make.conf# переменную `MAKE_IDEA`.
====

Наиболее часто OpenSSL используется для создания сертификатов, используемых программными пакетами. Эти сертификаты подтверждают, что данные компании или частного лица верны и не подделаны. Если рассматриваемый сертификат не был проверен одним из нескольких сертификационных центров ("Certificate Authorities" - CA), обычно выводится предупреждение. Центр сертификации представляет собой компанию, такую, как http://www.verisign.com[ VeriSign], которая подписывает сертификаты для подтверждения данных частных лиц или компаний. Эта процедура не бесплатна и не является абсолютно необходимой для использования сертификатов; однако может успокоить некоторых особо осторожных пользователей.

=== Генерирование сертификатов

Для генерирования сертификатов доступна следующая команда:

[source,shell]
....
# openssl req -new -nodes -out req.pem -keyout cert.pem
Generating a 1024 bit RSA private key
................++++++
.......................................++++++
writing new private key to 'cert.pem'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [AU]:US
State or Province Name (full name) [Some-State]:PA
Locality Name (eg, city) []:Pittsburgh
Organization Name (eg, company) [Internet Widgits Pty Ltd]:My Company
Organizational Unit Name (eg, section) []:Systems Administrator
Common Name (eg, YOUR name) []:localhost.example.org
Email Address []:trhodes@FreeBSD.org

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:SOME PASSWORD
An optional company name []:Another Name
....

Ввод после приглашения "Common Name" содержит имя домена. Здесь вводится имя сервера для верификации; помещение в это поле чего-либо кроме этого имени приведет к созданию бесполезного сертификата. Доступны и другие параметры, например срок действия, альтернативные алгоритмы шифрования и т.д. Полный список находится на странице справочного руководства man:openssl[1].

В текущем каталоге, из которого была вызвана вышеуказанная команда, должны появиться два файла. Файл [.filename]#req.pem# с запросом на сертификацию может быть послан в центр выдачи сертификатов, который проверит введённые вами подтверждающие данные, подпишет запрос и возвратит сертификат вам. Второй созданный файл будет иметь название [.filename]#cert.pem# и содержать приватный сертификационный ключ, который необходимо тщательно защищать; если он попадёт в руки посторонних лиц, то может быть использован для имитации лично вас (или вашего сервера).

Когда подпись CA не требуется, может быть создан самоподписанный сертификат. Сначала создайте ключ RSA:

[source,shell]
....
# openssl dsaparam -rand -genkey -out myRSA.key 1024
....

Теперь создайте ключ CA:

[source,shell]
....
# openssl gendsa -des3 -out myca.key myRSA.key
....

Используйте этот ключ при создании сертификата:

[source,shell]
....
# openssl req -new -x509 -days 365 -key myca.key -out new.crt
....

В каталоге должно появиться два новых файла: подпись сертификата, [.filename]#myca.key# и сам сертификат, [.filename]#new.crt#. Они должны быть помещены в каталог, доступный для чтения только `root`, желательно внутри [.filename]#/etc#. Права на каталог можно изменить `chmod` с параметрами 0700.

=== Использование сертификатов, пример

Итак, что могут сделать эти файлы? Хорошим применением может стать шифрование соединений для SendmailMTA. Это сделает ненужным использование простой текстовой аутентификации для тех, кто отправляет почту через локальный MTA.

[NOTE]
====
Это не лучшее из возможных использований, поскольку некоторые MUA выдадут ошибку, если сертификат не установлен локально. Обратитесь к поставляемой с программой документации за информацией по установке сертификата.
====

Следующие строки должны быть помещены в локальный файл [.filename]#.mc#:

[.programlisting]
....
dnl SSL Options
define(`confCACERT_PATH',`/etc/certs')dnl
define(`confCACERT',`/etc/certs/new.crt')dnl
define(`confSERVER_CERT',`/etc/certs/new.crt')dnl
define(`confSERVER_KEY',`/etc/certs/myca.key')dnl
define(`confTLS_SRV_OPTIONS', `V')dnl
....

Где [.filename]#/etc/certs/# это каталог для локального хранения сертификата и ключей. После настройки необходимо собрать локальный файл [.filename]#.cf#. Это легко сделать, набрав `make`[parameter]#install# в каталоге [.filename]#/etc/mail#. Затем выполните команду `make`[parameter]#restart#, которая должна запустить даемон Sendmail.

Если все пройдет нормально, в файле [.filename]#/var/log/maillog# не появятся сообщения об ошибках и запустится процесс Sendmail.

Для проведения простого теста подключитесь к почтовому серверу программой man:telnet[1]:

[source,shell]
....
# telnet example.com 25
Trying 192.0.34.166...
Connected to example.com.
Escape character is '^]'.
220 example.com ESMTP Sendmail 8.12.10/8.12.10; Tue, 31 Aug 2004 03:41:22 -0400 (EDT)
ehlo example.com
250-example.com Hello example.com [192.0.34.166], pleased to meet you
250-ENHANCEDSTATUSCODES
250-PIPELINING
250-8BITMIME
250-SIZE
250-DSN
250-ETRN
250-AUTH LOGIN PLAIN
250-STARTTLS
250-DELIVERBY
250 HELP
quit
221 2.0.0 example.com closing connection
Connection closed by foreign host.
....

Если в выводе появилась строка "STARTTLS", все работает правильно.

[[ipsec]]
== VPN через IPsec

Создание VPN между двумя сетями, соединенными через интернет, с использованием шлюзов FreeBSD.

=== Принципы работы IPsec

Этот раздел послужит вам руководством по настройке IPsec и его использованию в среде FreeBSD и Microsoft(R) Windows(R) 2000/XP, соединяемых безопасным способом. Для настройки IPsec необходимо ознакомиться с процессом сборки ядра (crossref:kernelconfig[kernelconfig, Настройка ядра FreeBSD]).

_IPsec_ это протокол, расположенный поверх слоя Internet Protocol (IP). Он позволяет двум или более хостам связываться защищенным способом (отсюда и название протокола). "Сетевой стек" FreeBSD IPsec основан на реализации http://www.kame.net/[KAME], поддерживающей оба семейства протоколов, IPv4 и IPv6.

[NOTE]
====
FreeBSD содержит "аппаратно поддерживаемый" стек IPsec, известный как "Fast IPsec", заимствованный из OpenBSD. Для оптимизации производительности IPsec он задействует криптографическое оборудование (когда оно доступно) через подсистему man:crypto[4]. Это новая подсистема и она не поддерживает всех возможностей, доступных в KAME версии IPsec. Для включения IPsec с аппаратной поддержкой необходимо добавить в файл настройки ядра следующий параметр:

[source,shell]
....
options	  FAST_IPSEC  # new IPsec (cannot define w/ IPSEC)
....

Обратите внимание, что на данный момент невозможно использовать подсистему "Fast IPsec" вместе с KAME реализацией IPsec. Обратитесь к странице справочника man:fast_ipsec[4] за дальнейшей информацией.
====

[NOTE]
====
Для того, чтобы применять к туннелям man:gif[4] межсетевые экраны, вам потребуется включить в ядро опцию `IPSEC_FILTERGIF`:

[source,shell]
....
options   IPSEC_FILTERGIF  #filter ipsec packets from a tunnel
....

====

IPsec состоит из двух подпротоколов:

* _Encapsulated Security Payload (ESP)_, защищающей данные IP пакета от вмешательства третьей стороны путем шифрования содержимого с помощью симметричных криптографических алгоритмов (таких как Blowfish,3DES).
* _Authentication Header (AH)_, защищающий заголовок IP пакета от вмешательства третьей стороны и подделки путем вычисления криптографической контрольной суммы и хеширования полей заголовка IP пакета защищенной функцией хеширования. К пакету добавляется дополнительный заголовок с хэшем, позволяющий аутентификацию информации пакета.

ESP и AH могут быть использованы вместе или по отдельности, в зависимости от обстоятельств.

IPsec может быть использован или для непосредственного шифрования трафика между двумя хостами (_транспортный режим_); или для построения "виртуальных туннелей" между двумя подсетями, которые могут быть использованы для защиты соединений между двумя корпоративными сетями (_туннельный режим_). Последний обычно называют _виртуальной частной сетью_ (Virtual Private Network, VPN). За детальной информацией о подсистеме IPsec в FreeBSD обратитесь к странице справочника man:ipsec[4].

Для включения поддержки IPsec в ядре, добавьте следующие параметры к файлу настройки ядра:

[source,shell]
....
options   IPSEC        #IP security
options   IPSEC_ESP    #IP security (crypto; define w/ IPSEC)
....

Если желательна поддержка отладки IPsec, должна быть также добавлена следующая строка:

[source,shell]
....
options   IPSEC_DEBUG  debug for IP security
....

=== Проблема

Не существует стандарта VPN. Они могут быть реализованы множеством различных технологий, каждая из которых имеет свои сильные и слабые стороны. Этот раздел представляет сценарий и стратегию реализации VPN для этого сценария.

=== Сценарий: Две сети, подключенных к интернет, работающие как одна

Исходные условия таковы:

* Существует как минимум две сети
* Внутри обеих сетей используется IP
* Обе сети соединены через интернет через шлюз, работающий на FreeBSD.
* У шлюза каждой из сетей есть как минимум один публичный IP адрес.
* Внутренние IP адреса двух сетей могут быть публичными или приватными, не имеет значения. На шлюзе может работать NAT, если это необходимо.
* Внутренние IP адреса двух сетей _не должны пересекаться_. Хотя вероятно теоретически возможно использование комбинации VPN технологии и NAT для настройки такой конфигурации, эта конфигурация будет кошмарна.

Если две сети, которые вы пытаетесь соединить, используют один и тот же диапазон приватных адресов (например, обе используют `192.168.1.x`), номера в одной из сетей необходимо изменить.

Топология сети может выглядеть примерно так:

image::ipsec-network.png[]

Заметьте, что здесь присутствуют два публичных IP-адреса. В дальнейшем для их обозначения будут использоваться буквы. Если вы увидите эти буквы, замените их на свои публичные IP адреса. Также обратите внимание, что у обеих шлюзов внутренний адрес заканчивается на .1 и диапазоны приватных адресов двух сетей различны (`192.168.1.x` и `192.168.2.x` соответственно). Все компьютеры локальных сетей настроены на использование в качестве шлюза по умолчанию компьютера с адресом, оканчивающимся на `.1`.

С сетевой точки зрения замысел в том, чтобы каждая сеть видела компьютеры из другой сети так, как если бы они были непосредственно подключены к тому же самому маршрутизатору - хотя и немного медленному маршрутизатору, иногда теряющему пакеты.

Это означает, что (например) компьютер `192.168.1.20` может запустить

[.programlisting]
....
ping 192.168.2.34
....

и это будет прозрачно работать. Компьютеры с Windows(R) должны видеть компьютеры в другой сети, просматривать сетевые ресурсы, и так далее, точно так же, как и для компьютеров в локальной сети.

И все это безопасным способом. Это означает, что трафик между сетями зашифрован.

Создание VPN между этими двумя сетями это многошаговый процесс. Этапы создания VPN таковы:

. Создание "виртуального" сетевого подключения между двумя сетями через интернет. Тестирование подключения с помощью таких инструментов как man:ping[8], чтобы убедиться, что оно работает.
. Применение политики безопасности чтобы убедиться, что трафик между двумя сетями прозрачно шифруется и расшифровывается если необходимо. Тестирование с помощью таких инструментов как man:tcpdump[1], чтобы убедиться, что трафик шифруется.
. Настройка дополнительных программ на шлюзах FreeBSD, чтобы компьютеры Windows(R) из одной сети видели компьютеры в другой через VPN.

==== Шаг 1: Создание и тестирование "виртуального" сетевого подключения

Предположим, что вы работаете на шлюзе сети #1 (с публичным адресом `A.B.C.D`, приватным адресом `192.168.1.1`) и запускаете `ping 192.168.2.1`, т.е. на приватный адрес машины с IP адресом `W.X.Y.Z`. Что должно произойти, чтобы это сработало?

. Шлюз должен знать, как достичь `192.168.2.1`. Другими словами, у него должен быть маршрут к `192.168.2.1`.
. Приватные IP адреса, такие как диапазон `192.168.x` не адресуются в интернет. Каждый пакет, отправляемый на `192.168.2.1` должен быть "завернут" в другой пакет. Исходным адресом пакета должен быть `A.B.C.D`, а адресом назначения `W.X.Y.Z`. Этот процесс называется _инкапсуляцией_.
. Как только этот пакет достигнет `W.X.Y.Z`, необходимо будет "декапсулировать" его и доставить к `192.168.2.1`.

Как вы можете увидеть, это требует "туннеля" между двумя сетями. Два конца "туннеля" это IP адреса `A.B.C.D` и `W.X.Y.Z`. Туннель используется для передачи трафика с приватными IP адресами через интернет.

В FreeBSD этот туннель создается с помощью устройства generic interface, или [.filename]#gif#. Как вы можете догадаться, интерфейс [.filename]#gif# на каждом хосте должен быть настроен с четырьмя IP адресами; два для публичных IP адресов и два для приватных IP адресов.

В ядро обеих компьютеров FreeBSD должна быть встроена поддержка устройства gif. Вы можете сделать это, добавив строку:

[.programlisting]
....
device gif
....

к файлу настройки ядра на обеих компьютерах, с последующей компиляцией, установкой и перезагрузкой.

Настройка туннеля это двухшаговый процесс. Во-первых, необходимо задать сведения о внешнем (или публичном) IP адресе с помощью man:ifconfig[8]. Затем о приватном IP адресе, также с помощью man:ifconfig[8].

На шлюзе сети #1 для настройки туннеля вам потребуется запустить следующие две команды.

[.programlisting]
....
ifconfig gif0 A.B.C.D W.X.Y.Z
ifconfig gif0 inet 192.168.1.1 192.168.2.1 netmask 0xffffffff
....

На другом шлюзе подобные команды, но с IP адресами в обратном порядке.

[.programlisting]
....
ifconfig gif0 W.X.Y.Z A.B.C.D
ifconfig gif0 inet 192.168.2.1 192.168.1.1 netmask 0xffffffff
....

Затем вы можете запустить:

[.programlisting]
....
ifconfig gif0
....

для просмотра настройки. Например, на шлюзе сети #1 вы увидите:

[source,shell]
....
# ifconfig gif0
gif0: flags=8011<UP,POINTTOPOINT,MULTICAST> mtu 1280
inet 192.168.1.1 --> 192.168.2.1 netmask 0xffffffff
physical address inet A.B.C.D --> W.X.Y.Z
....

Как вы можете видеть, был создан туннель между физическими адресами `A.B.C.D` и `W.X.Y.Z`, для туннелирования разрешен трафик между `192.168.1.1` и `192.168.2.1`.

Это также добавляет запись к таблице маршрутизации на обеих машинах, вы можете проверить запись командой `netstat -rn`. Вот вывод этой команды на шлюзе сети #1.

[source,shell]
....
# netstat -rn
Routing tables

Internet:
Destination      Gateway       Flags    Refs    Use    Netif  Expire
...
192.168.2.1      192.168.1.1   UH        0        0    gif0
...
....

Как показывает значение поля "Flags", это маршрут к хосту, что означает, что каждый шлюз знает, как достичь другого шлюза, но не знает как достичь остальной части соответствующей сети. Эта проблема будет быстро решена.

Вероятно, на обеих машинах запущен брандмауэр. VPN должен обходить его. Вы можете разрешить весь трафик между двумя сетями, или включить правила, защищающие каждый конец соединения от другого.

Это сильно упрощает тестирование настройки брандмауэра, если вы разрешаете весь трафик через VPN. Вы всегда можете усилить защиту позже. Если вы используете на шлюзах man:ipfw[8], команда вроде этой

[.programlisting]
....
ipfw add 1 allow ip from any to any via gif0
....

разрешит весь трафик между двумя концами VPN без влияния на другие правила брандмауэра. Очевидно, вам потребуется запустить эту команду на обеих шлюзах.

Этого достаточно для включения ping с одного шлюза на другой. На `192.168.1.1`, вы сможете запустить

[.programlisting]
....
ping 192.168.2.1
....

и получить ответ, и аналогично на другом шлюзе.

Однако, машины в другой сети пока недоступны. Это из-за маршрутизации - хотя шлюзы знают, как связаться друг с другом, они не знают, как связаться с сетью за другим шлюзом.

Для решения этой проблемы вы должны добавить статический маршрут на каждом шлюзе. Команда на первом шлюзе будет выглядеть так:

[.programlisting]
....
route add 192.168.2.0 192.168.2.1 netmask 0xffffff00
....

Она говорит "Для достижения хостов в сети `192.168.2.0`, отправляйте пакеты хосту `192.168.2.1`". Вам потребуется запустить похожую команду на другом шлюзе, но с адресами `192.168.1.x`.

IP трафик с хостов в одной сети теперь может достичь хосты в другой сети.

Теперь создано две трети VPN между двумя сетями, поскольку это "виртуальная (virtual)""сеть (network)". Она еще не приватная (private). Вы можете протестировать ее с помощью man:ping[8] и man:tcpdump[1]. Войдите на шлюз и запустите

[.programlisting]
....
tcpdump dst host 192.168.2.1
....

В другой сессии на этом же хосте запустите

[.programlisting]
....
ping 192.168.2.1
....

Вы увидите примерно такие строки:

[.programlisting]
....

16:10:24.018080 192.168.1.1 > 192.168.2.1: icmp: echo request
16:10:24.018109 192.168.1.1 > 192.168.2.1: icmp: echo reply
16:10:25.018814 192.168.1.1 > 192.168.2.1: icmp: echo request
16:10:25.018847 192.168.1.1 > 192.168.2.1: icmp: echo reply
16:10:26.028896 192.168.1.1 > 192.168.2.1: icmp: echo request
16:10:26.029112 192.168.1.1 > 192.168.2.1: icmp: echo reply
....

Как вы видите, ICMP сообщения пересылаются вперед и назад незашифрованными. Если вы использовали с man:tcpdump[1] параметр `-s` для получения большего объема данных пакета, то увидите больше информации.

Конечно же это неприемлемо. В следующем разделе мы обсудим защиту соединения между двумя сетями, так что весь трафик будет автоматически шифроваться.

.Резюме:
* Настройте оба ядра с "device gif".
* Отредактируйте [.filename]#/etc/rc.conf# на шлюзе #1 и добавьте следующие строки (подставляя IP адреса где необходимо).
+
[.programlisting]
....
gifconfig_gif0="A.B.C.D W.X.Y.Z"
ifconfig_gif0="inet 192.168.1.1 192.168.2.1 netmask 0xffffffff"
static_routes="vpn"
route_vpn="192.168.2.0 192.168.2.1 netmask 0xffffff00"
....

* Отредактируйте скрипт брандмауэра ([.filename]#/etc/rc.firewall#, или подобный) на обеих хостах и добавьте
+
[.programlisting]
....
ipfw add 1 allow ip from any to any via gif0
....

* Выполните соответствующие изменения в [.filename]#/etc/rc.conf# на шлюзе #2, меняя порядок IP адресов.

==== Шаг 2: Защита соединения

Для защиты соединения мы будем использовать IPsec. IPsec предоставляет хостам механизм определения ключа для шифрования и для последующего использования этого ключа для шифрования данных между двумя хостами.

Здесь будут рассмотрены два аспекта настройки.

. У хостов должен быть способ согласования используемого алгоритма шифрования. Как только хосты договорятся об этом, можно говорить об установленном между ними "безопасном соединении".
. Должен быть механизм определения, какой трафик необходимо шифровать. Конечно, вам не требуется шифровать весь исходящий трафик - достаточно шифровать только трафик, идущий через VPN. Правила, определяющие то, какой трафик необходимо шифровать, называются "политикой безопасности".

Безопасное соединение и политика безопасности поддерживаются ядром, и могут быть изменены программами пользователя. Однако перед тем, как вы сможете сделать это, необходимо настроить поддержку протоколов IPsec и Encapsulated Security Payload (ESP) в ядре. Это делается добавлением в настройку ядра параметров:

[.programlisting]
....
options IPSEC
options IPSEC_ESP
....

с последующим перекомпилированием, переустановкой и перезагрузкой. Как и прежде вам потребуется сделать это с ядрами на обеих шлюзах.

При настройке параметров безопасности (security associations) у вас есть два варианта. Вы можете настроить их вручную для обеих хостов, задав алгоритм шифрования, ключи для шифрования и так далее, или использовать даемоны, реализующие Internet Key Exchange protocol (IKE), который сделает это за вас.

Рекомендуется последнее. Помимо прочего, этот способ более прост.

Редактирование и отображение политики безопасности выполняется с помощью man:setkey[8]. По аналогии, `setkey` используется для настройки таблиц политики безопасности ядра так же, как man:route[8] используется для настройки таблиц маршрутизации ядра. `setkey` также может отображать текущие параметры безопасности, и продолжая аналогию дальше, это соответствует `netstat -r`.

Существует множество даемонов для управления параметрами безопасности в FreeBSD. Здесь будет описано использование одного из них, racoon - он доступен в составе порта package:security/ipsec-tools[] в Коллекции Портов FreeBSD.

Даемон racoon должен работать на обеих шлюзах. На каждом из хостов он настраивается с IP адресом другого конца VPN, и секретным ключом (по вашему выбору, должен быть одним и тем же на обеих шлюзах).

Эти два даемона подключаются друг к другу, подтверждают, что они именно те, за кого себя выдают (используя секретный ключ, заданный вами). Затем даемоны генерируют новый секретный ключ и используют его для шифрования трафика через VPN. Они периодически изменяют этот ключ, так что даже если атакующий сломает один из ключей (что теоретически почти невозможно) это не даст ему слишком много - он сломал ключ, который два даемона уже сменили на другой.

Настройки racoon сохраняются в файле [.filename]#${PREFIX}/etc/racoon#. Этот файл не требует слишком больших изменений. Другим компонентом настройки racoon, который потребуется изменить, является "предварительный ключ".

В настройке по умолчанию racoon ищет его в файле [.filename]#${PREFIX}/etc/racoon/psk.txt#. Необходимо отметить, что предварительный ключ _не_ используется для шифрования трафика через VPN соединение это просто маркер, позволяющий управляющим ключами даемонам доверять друг другу.

[.filename]#psk.txt# содержит строку для каждого удаленного сервера, с которым происходит соединение. В этом примере два сервера, каждый файл [.filename]#psk.txt# будет содержать одну строку (каждый конец VPN общается только с другим концом.

На шлюзе #1 эта строка будет выглядеть примерно так:

[.programlisting]
....
W.X.Y.Z            secret
....

То есть _публичный_ IP-адрес противоположной стороны, пробел и текстовая строка c секретной фразой. Конечно, вам не стоит использовать в качестве ключевой фразы слово "secret" -- здесь применяются обычные правила выбора паролей.

На шлюзе #2 строка будет выглядеть примерно так:

[.programlisting]
....
A.B.C.D            secret
....

То есть публичный IP адрес удаленной стороны и та же секретная фраза. Перед запуском racoon режим доступа к файлу [.filename]#psk.txt# должен быть установлен в `0600` (т.е. запись и чтение только для `root`).

Вы должны запустить racoon на обоих шлюзах. Вам также потребуется добавить правила для включения IKE трафика, передающегося по UDP через порт ISAKMP (Internet Security Association Key Management Protocol). Опять же, они должны быть расположены насколько возможно ближе к началу набора правил.

[.programlisting]
....
ipfw add 1 allow udp from A.B.C.D to W.X.Y.Z isakmp
ipfw add 1 allow udp from W.X.Y.Z to A.B.C.D isakmp
....

Как только racoon будет запущен, вы можете попробовать выполнить ping с одного шлюза на другой. Соединение все еще не зашифровано, но racoon установит параметры безопасности между двумя хостами - это может занять время и вы можете заметить небольшую задержку перед началом ответа команды ping.

Как только параметры безопасности установлены, вы можете просмотреть их используя man:setkey[8]. Запустите

[.programlisting]
....
setkey -D
....

на любом из хостов для просмотра информации о параметрах безопасности.

Это одна сторона проблемы. Другая сторона это настройка политики безопасности.

Для создания разумной политики безопасности давайте вспомним, что уже было настроено. Это рассмотрение относится к обеим концам соединения.

Каждый отправляемый IP пакет имеет заголовок, содержащий информацию о пакете. Заголовок включает IP адреса источника и назначения. Как мы уже знаем, приватные IP адреса, такие как `192.168.x.y`, не могут появиться в интернет. Они должны быть сначала включены внутрь другого пакета. В этом пакете приватные IP адреса источника и назначения заменяются публичными IP адресами.

То есть исходящий пакет, который выглядит примерно так:

image::ipsec-out-pkt.png[]

будет инкапсулирован в другой пакет, выглядящий примерно так:

image::ipsec-encap-pkt.png[]

Этой инкапсуляцией занимается устройство [.filename]#gif#. Как вы можете видеть, теперь у пакета есть реальный IP адрес, исходный пакет был включен в этот пакет в виде данных, которые передаются через интернет.

Конечно, мы хотим зашифровать весь трафик между VPN. Вы можете сформулировать это на словах так:

"Если пакет отправляется с `A.B.C.D`, и предназначен для `W.X.Y.Z`, расшифровать его, используя необходимые параметры безопасности."

"Если пакет отправляется с `W.X.Y.Z`, и предназначен для `A.B.C.D`, расшифровать его, используя необходимые параметры безопасности."

Это похоже на желаемое, но не совсем то. Если вы сделаете это, весь трафик от и к `W.X.Y.Z`, даже если он не является частью VPN, будет зашифрован. Правильная политика такова:

"Если пакет отправляется с `A.B.C.D`, в нем инкапсулирован другой пакет и адрес назначения `W.X.Y.Z`, зашифровать его, используя необходимые параметры безопасности."

"Если пакет отправляется с `W.X.Y.Z`, в нем инкапсулирован другой пакет и адрес назначения `A.B.C.D`, зашифровать его, используя необходимые параметры безопасности."

Тонкое, но необходимое различие.

Политика безопасности также устанавливается с использованием man:setkey[8]. В man:setkey[8] предусмотрен язык определения политики man:setkey[8]. Вы можете или ввести инструкции по настройке со стандартного ввода, или использовать параметр `-f` для задания файла, содержащего эти инструкции.

Настройка на шлюзе #1 (где есть публичный IP адрес `A.B.C.D`) для включения шифрования всего предназначенного `W.X.Y.Z` трафика:

[.programlisting]
....

spdadd A.B.C.D/32 W.X.Y.Z/32 ipencap -P out ipsec esp/tunnel/A.B.C.D-W.X.Y.Z/require;
....

Поместите эти команды в файл (например, [.filename]#/etc/ipsec.conf#) и запустите

[source,shell]
....
# setkey -f /etc/ipsec.conf
....

`spdadd` указывает man:setkey[8] добавить правило к базе данных политики безопасности. Остальная часть строки указывает какие пакеты будут соответствовать политике. `A.B.C.D/32` и `W.X.Y.Z/32` это IP адреса и сетевые маски, определяющие сети или хосты, к которым будет применяться данная политика. В данном случае мы хотим применить их к трафику между этими двумя хостами. Параметр `ipencap` сообщает ядру, что эта политика должна применяться только к пакетам, инкапсулирующим другие пакеты. Параметр `-P out` сообщает, что эта политика применяется к исходящим пакетам, и `ipsec` - то, что пакеты будут зашифрованы.

Оставшаяся часть строки определяет, как эти пакеты будут зашифрованы. Будет использоваться протокол `esp`, а параметр `tunnel` показывает, что пакет в дальнейшем будет инкапсулирован в IPsec пакет. Повторное использование `A.B.C.D` и `W.X.Y.Z` предназначено для выбора используемых параметров безопасности, и наконец параметр `require` разрешает шифрование пакетов, попадающих под это правило.

Это правило соответствует только исходящим пакетам. Вам потребуется похожее правило, соответствующее входящим пакетам.

[.programlisting]
....
spdadd W.X.Y.Z/32 A.B.C.D/32 ipencap -P in ipsec esp/tunnel/W.X.Y.Z-A.B.C.D/require;
....

Обратите внимание, что вместо `in` используется `out` и IP адреса переставлены.

Другому шлюзу (с публичным IP адресом `W.X.Y.Z`) потребуются похожие правила.

[.programlisting]
....
spdadd W.X.Y.Z/32 A.B.C.D/32 ipencap -P out ipsec esp/tunnel/W.X.Y.Z-A.B.C.D/require;
spdadd A.B.C.D/32 W.X.Y.Z/32 ipencap -P in ipsec esp/tunnel/A.B.C.D-W.X.Y.Z/require;
....

Наконец, вам потребуется добавить правила к брандмауэру для включения прохождения пакетов ESP и IPENCAP в обе стороны. На обеих хостах потребуется добавить следующие правила:

[.programlisting]
....
ipfw add 1 allow esp from A.B.C.D to W.X.Y.Z
ipfw add 1 allow esp from W.X.Y.Z to A.B.C.D
ipfw add 1 allow ipencap from A.B.C.D to W.X.Y.Z
ipfw add 1 allow ipencap from W.X.Y.Z to A.B.C.D
....

Поскольку правила симметричны, можно использовать их без изменения на обеих хостах

Исходящие пакеты теперь будут выглядеть примерно так:

image::ipsec-crypt-pkt.png[]

Когда эти пакеты будут получены на удаленном конце VPN соединения, они будут расшифрованы (используя параметры безопасности, о которых договорился racoon). Затем они будут переданы интерфейсу [.filename]#gif#, который "развернет" второй слой, оставив пакет с внутренними адресами, который сможет попасть во внутреннюю сеть.

Вы можете проверить безопасность тем же man:ping[8], который использовался ранее. Сначала войдите на шлюз `A.B.C.D` и запустите:

[.programlisting]
....
tcpdump dst host 192.168.2.1
....

В другой сессии на том же хосте запустите

[.programlisting]
....
ping 192.168.2.1
....

В этот момент вы должны увидеть примерно это:

[.programlisting]
....
XXX tcpdump output
....

Теперь, как видите, man:tcpdump[1] показывает ESP пакеты. Если вы попытаетесь просмотреть их с параметром `-s`, то вероятно увидите нечто непонятное, поскольку применяется шифрование.

Поздравляем. Вы только что настроили VPN между двумя удаленными сетями.

.Резюме
* Настройте оба ядра с:
+
[.programlisting]
....
options IPSEC
options IPSEC_ESP
....

* Установите package:security/ipsec-tools[]. Отредактируйте [.filename]#${PREFIX}/etc/racoon/psk.txt# на обеих шлюзах, добавив запись для каждого IP адреса удаленного хоста и секретный ключ, который будет известен им обеим. Убедитесь, что режим доступа к файлу 0600.
* Добавьте к [.filename]#/etc/rc.conf# на каждом хосте следующие строки:
+
[.programlisting]
....
ipsec_enable="YES"
ipsec_file="/etc/ipsec.conf"
....

* Создайте [.filename]#/etc/ipsec.conf# на каждом хосте с необходимыми строками spdadd. На шлюзе #1 он будет таким:
+
[.programlisting]
....

spdadd A.B.C.D/32 W.X.Y.Z/32 ipencap -P out ipsec
  esp/tunnel/A.B.C.D-W.X.Y.Z/require;
spdadd W.X.Y.Z/32 A.B.C.D/32 ipencap -P in ipsec
  esp/tunnel/W.X.Y.Z-A.B.C.D/require;
....

+ 
А на шлюзе #2 таким:
+
[.programlisting]
....

spdadd W.X.Y.Z/32 A.B.C.D/32 ipencap -P out ipsec
  esp/tunnel/W.X.Y.Z-A.B.C.D/require;
spdadd A.B.C.D/32 W.X.Y.Z/32 ipencap -P in ipsec
  esp/tunnel/A.B.C.D-W.X.Y.Z/require;
....

* Добавьте правила к брандмауэрам обеих хостов для включения IKE, ESP и IPENCAP трафика:
+
[.programlisting]
....

ipfw add 1 allow udp from A.B.C.D to W.X.Y.Z isakmp
ipfw add 1 allow udp from W.X.Y.Z to A.B.C.D isakmp
ipfw add 1 allow esp from A.B.C.D to W.X.Y.Z
ipfw add 1 allow esp from W.X.Y.Z to A.B.C.D
ipfw add 1 allow ipencap from A.B.C.D to W.X.Y.Z
ipfw add 1 allow ipencap from W.X.Y.Z to A.B.C.D
....

Двух приведенных шагов должно быть достаточно для настройки и включения VPN. Машины в каждой сети смогут обращаться друг к другу по IP адресам, и весь трафик через соединение будет автоматически надежно зашифрован.

[[openssh]]
== OpenSSH

OpenSSH это набор сетевых инструментов, используемых для защищенного доступа к удаленным компьютерам. Он может быть использован в качестве непосредственной замены `rlogin`, `rsh`, `rcp` и `telnet`. Кроме того, через SSH могут быть безопасно туннелированы и/или перенаправлены произвольные TCP/IP соединения. OpenSSH шифрует весь трафик, эффективно предотвращая кражу данных, перехват соединения и другие сетевые атаки.

OpenSSH поддерживается проектом OpenBSD, он основан на SSH v1.2.12 со всеми последними исправлениями и обновлениями, совместим с протоколами SSH версий 1 и 2.

=== Преимущества использования OpenSSH

Обычно при использовании man:telnet[1] или man:rlogin[1] данные пересылаются по сети в незашифрованной форме. Перехватчик пакетов в любой точке сети между клиентом и сервером может похитить информацию о пользователе/пароле или данные, передаваемые через соединение. Для предотвращения этого OpenSSH предлагает различные методы шифрования.

=== Включение sshd

В FreeBSD даемон sshd должен быть разрешен в процессе инсталляции. За запуск ответственна следующая строка в файле [.filename]#rc.conf#:

[source,shell]
....
sshd_enable="YES"
....

При следующей загрузке системы будет запущен man:sshd[8], даемон для OpenSSH. Вы можете также воспользоваться скриптом [.filename]#/etc/rc.d/sshd# системы man:rc[8] для запуска OpenSSH:

[.programlisting]
....
/etc/rc.d/sshd start
....

=== SSH клиент

Утилита man:ssh[1] работает подобно man:rlogin[1].

[source,shell]
....
# ssh user@example.com
Host key not found from the list of known hosts.
Are you sure you want to continue connecting (yes/no)? yes
Host 'example.com' added to the list of known hosts.
user@example.com's password: *******
....

Вход продолжится так же, как если бы сессия была инициирована с использованием `rlogin` или `telnet`. SSH использует систему опознавательных ключей для проверки подлинности сервера при подключении клиента. Пользователю предлагается `yes` только при первом подключении. Дальнейшие попытки входа предваряются проверкой сохраненного ключа сервера. SSH клиент сообщит вам, если сохраненный ключ будет отличаться от только что полученного. Ключи серверов сохраняются в [.filename]#~/.ssh/known_hosts#, или в [.filename]#~/.ssh/known_hosts2# для SSH v2.

По умолчанию современные серверы OpenSSH настроены на приём только соединений SSH v2. Клиент будет использовать версию 2 там, где это возможно, а затем версию 1. Также, клиент можно заставить использовать конкретную версию при помощи опций `-1` и `-2` для указания соответствующей версии протокола. Версия 1 поддерживается ради совместимости со старыми серверами.

=== Безопасное копирование

Команда man:scp[1] работает подобно man:rcp[1]; она копирует файл с удаленного компьютера, но делает это безопасным способом.

[source,shell]
....
#  scp user@example.com:/COPYRIGHT COPYRIGHT
user@example.com's password: *******
COPYRIGHT            100% |*****************************|  4735       00:00
#
....

Поскольку в предыдущем примере ключ сервера уже был сохранен, в этом примере он проверяется при использовании man:scp[1].

Параметры, передаваемые man:scp[1], похожи на параметры man:cp[1], с файлом или файлами в качестве первого аргумента и приемником копирования во втором. Поскольку файлы передаются по сети через SSH, один или более аргументов принимают форму `user@host:<path_to_remote_file>`.

=== Настройка

Системные файлы настройки для даемона и клиента OpenSSH расположены в каталоге [.filename]#/etc/ssh#.

Файл [.filename]#ssh_config# используется для настройки клиента, а [.filename]#sshd_config# для даемона.

Кроме того, параметры `sshd_program` (по умолчанию [.filename]#/usr/sbin/sshd#), и `sshd_flags`[.filename]#rc.conf# дают дополнительные возможности настройки.

[[ssh-keygen]]
=== ssh-keygen

Вместо использования паролей, с помощью man:ssh-keygen[1] можно создать ключи DSA или RSA, которыми пользователи могут аутентифицироваться:

[source,shell]
....
% ssh-keygen -t dsa
Generating public/private dsa key pair.
Enter file in which to save the key (/home/user/.ssh/id_dsa):
Created directory '/home/user/.ssh'.
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /home/user/.ssh/id_dsa.
Your public key has been saved in /home/user/.ssh/id_dsa.pub.
The key fingerprint is:
bb:48:db:f2:93:57:80:b6:aa:bc:f5:d5:ba:8f:79:17 user@host.example.com
....

man:ssh-keygen[1] создаст пару публичного и приватного ключей, используемых для аутентификации. Приватный ключ сохраняется в [.filename]#~/.ssh/id_dsa# или [.filename]#~/.ssh/id_rsa#, а публичный в [.filename]#~/.ssh/id_dsa.pub# или [.filename]#~/.ssh/id_rsa.pub# (для ключей DSA и RSA соответственно). Для включения аутентификации по ключам публичный ключ должен быть помещен в файл [.filename]#~/.ssh/authorized_keys# на удаленном компьютере.

Это позволяет соединяться с удаленным компьютером с помощью SSH-ключей вместо паролей.

Если при генерации ключей был использован пароль, каждый раз при использовании приватного ключа он будет запрашиваться у пользователя. Для того, чтобы избежать непрерывного набора кодовой фразы, можно использовать утилиту man:ssh-agent[1], как описано в разделе <<security-ssh-agent>> ниже.

[WARNING]
====

Параметры и имена файлов могут различаться для разных версий OpenSSH, установленных в системе, для решения проблем обратитесь к странице справочника man:ssh-keygen[1].
====

[[security-ssh-agent]]
=== Утилиты ssh-agent и ssh-add

Утилиты man:ssh-agent[1] и man:ssh-add[1] позволяют сохранять ключи SSH в памяти, чтобы не набирать кодовые фразы при каждом использовании ключа.

Утилита man:ssh-agent[1] обеспечивает процесс аутентификации загруженными в нее секретными ключами; для этого утилита man:ssh-agent[1] должна запустить внешний процесс. В самом простом случае это может быть шелл-процесс; в чуть более продвинутом - оконный менеджер.

Для использования man:ssh-agent[1] совместно с шеллом, man:ssh-agent[1] должен быть запущен с именем этого шелла в качестве аргумента. После этого в его память при помощи утилиты man:ssh-add[1] могут быть добавлены необходимые ключи; при этом будут запрошены соответствующие кодовые фразы. Добавленные ключи могут затем использоваться для man:ssh[1] на машины, на которых установлены соответствующие публичные ключи:

[source,shell]
....
% ssh-agent csh
% ssh-add
Enter passphrase for /home/user/.ssh/id_dsa:
Identity added: /home/user/.ssh/id_dsa (/home/user/.ssh/id_dsa)
%
....

Для того чтобы использовать man:ssh-agent[1] в X11, вызов man:ssh-agent[1]должен быть помещен в файл [.filename]#~/.xinitrc#. Это обеспечит поддержкой man:ssh-agent[1] все программы, запущенные в X11. Файл [.filename]#~/.xinitrc# может выглядеть, например, так:

[.programlisting]
....
exec ssh-agent startxfce4
....

При этом будет запущен man:ssh-agent[1], который, в свою очередь, вызовет запуск XFCE, при каждом старте X11. После запуска X11, выполните команду man:ssh-add[1] для добавления ваших SSH-ключей.

[[security-ssh-tunneling]]
=== Туннелирование SSH

OpenSSH поддерживает возможность создания туннеля для пропуска соединения по другому протоколу через защищенную сессию.

Следующая команда указывает man:ssh[1] создать туннель для telnet:

[source,shell]
....
% ssh -2 -N -f -L 5023:localhost:23 user@foo.example.com
%
....

Команда `ssh` используется со следующими параметрами:

`-2`::
Указывает `ssh` использовать версию 2 протокола (не используйте этот параметр, если работаете со старыми SSH серверами).

`-N`::
Означает использование в не-командном режиме, только для туннелирования. Если этот параметр опущен, `ssh` запустит обычную сессию.

`-f`::
Указывает `ssh` запускаться в фоновом режиме.

`-L`::
Означает локальный туннель в стиле _localport:remotehost:remoteport_.

`user@foo.example.com`::
Удаленный сервер SSH.

Туннель SSH создается путем создания прослушивающего сокета на определенном порту `localhost`. Затем все принятые на локальном хосту/порту соединения переправляются через SSH на определенный удаленный хост и порт.

В этом примере, порт _5023_ на `localhost` перенаправляется на порт _23_ на `localhost` удаленного компьютера. Поскольку _23_ это порт telnet, будет создано защищенное соединение telnet через туннель SSH.

Этот метод можно использовать для любого числа небезопасных протоколов, таких как SMTP, POP3, FTP, и так далее.

.Использование SSH для создания защищенного туннеля на SMTP
[example]
====

[source,shell]
....
% ssh -2 -N -f -L 5025:localhost:25 user@mailserver.example.com
user@mailserver.example.com's password: *****
% telnet localhost 5025
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
220 mailserver.example.com ESMTP
....
Этот метод можно использовать вместе с man:ssh-keygen[1] и дополнительными пользовательскими учётными записями для создания более удобного автоматического SSH туннелирования. Ключи могут быть использованы вместо паролей, и туннели могут запускаться от отдельных пользователей.
====

==== Практические примеры SSH туннелирования

===== Защищенный доступ к серверу POP3

На работе находится SSH сервер, принимающий соединения снаружи. В этой же офисной сети находится почтовый сервер, поддерживающий протокол POP3. Сеть или сетевое соединение между вашим домом и офисом могут быть или не быть полностью доверяемыми. По этой причине вам потребуется проверять почту через защищенное соединение. Решение состоит в создании SSH соединения к офисному серверу SSH и туннелирование через него к почтовому серверу.

[source,shell]
....
% ssh -2 -N -f -L 2110:mail.example.com:110 user@ssh-server.example.com
user@ssh-server.example.com's password: ******
....

Когда туннель включен и работает, вы можете настроить почтовый клиент для отправки запросов POP3 на `localhost`, порт 2110. Соединение будет безопасно переправлено через туннель на `mail.example.com`.

===== Прохождение через Драконовский Брандмауэр

Некоторые сетевые администраторы устанавливают на брандмауэрах драконовские правила, фильтруя не только входящие соединения, но и исходящие. Вам может быть разрешен доступ к удаленным компьютерам только по портам 22 и 80, для SSH и просмотра сайтов.

Вам может потребоваться доступ к другому (возможно, не относящемуся к работе) сервису, такому как Ogg Vorbis для прослушивания музыки. Если этот сервер Ogg Vorbis выдает поток не с портов 22 или 80, вы не сможете получить к нему доступ.

Решение состоит в создании SSH соединения с компьютером вне брандмауэра и использование его для туннелирования сервера Ogg Vorbis.

[source,shell]
....
% ssh -2 -N -f -L 8888:music.example.com:8000 user@unfirewalled-system.example.org
user@unfirewalled-system.example.org's password: *******
....

Клиентскую программу теперь можно настроить на `localhost` порт 8888, который будет перенаправлен на `music.example.com` порт 8000, успешно обойдя брандмауэр.

=== Параметр ограничения пользователей `AllowUsers`

Зачастую хорошие результаты даёт ограничение того, какие именно пользователи и откуда могут регистрироваться в системе. Задание параметра `AllowUsers` является хорошим способом добиться этого. К примеру, для разрешения регистрации только пользователю `root` с машины `192.168.1.32`, в файле [.filename]#/etc/ssh/sshd_config# нужно указать нечто вроде следующего:

[.programlisting]
....
AllowUsers root@192.168.1.32
....

Для разрешения регистрации пользователя `admin` из любой точки, просто укажите имя пользователя:

[.programlisting]
....
AllowUsers admin
....

Несколько пользователей должны перечислять в одной строке, как здесь:

[.programlisting]
....
AllowUsers root@192.168.1.32 admin
....

[NOTE]
====
Важно, чтобы бы перечислили всех пользователей, которые должны регистрироваться на этой машине; в противном случае они будут заблокированы.
====

После внесения изменений в [.filename]#/etc/ssh/sshd_config# вы должны указать man:sshd[8] на повторную загрузку конфигурационных файлов, выполнив следующую команду:

[source,shell]
....
# /etc/rc.d/sshd reload
....

=== Дополнительная литература

http://www.openssh.com/[OpenSSH]

man:ssh[1] man:scp[1] man:ssh-keygen[1] man:ssh-agent[1] man:ssh-add[1] man:ssh_config[5]

man:sshd[8] man:sftp-server[8] man:sshd_config[5]

[[fs-acl]]
== Списки контроля доступа файловой системы (ACL)

В дополнение к другим расширениям файловой системы, таким как снимки (snapshots), FreeBSD 5.0 и более поздние версии системы предлагают защиту с помощью списков контроля доступа файловой системы (File System Access Control Lists, ACLs).

Списки контроля доступа расширяют стандартную модель прав UNIX(R) высоко совместимым (POSIX(R).1e) способом. Эта возможность позволяет администратору получить преимущество от использования более интеллектуальной модели безопасности.

Для включения поддержки ACL в файловой системе UFS, следующая строка:

[.programlisting]
....
options UFS_ACL
....

должна быть добавлена в файл настройки ядра. Если параметр не добавлен, при попытке монтирования систем, поддерживающих ACL, появится предупреждающее сообщение. Этот параметр включен в ядро [.filename]#GENERIC#. ACL основывается на дополнительных атрибутах, встроенных в файловую систему. Дополнительные атрибуты поддерживаются по умолчанию следующим поколением файловых систем UNIX(R), UFS2.

[NOTE]
====
Для включения дополнительных атрибутов в UFS1 требуется больше усилий по сравнению с UFS2. Производительность дополнительных атрибутов в UFS2 также существенно выше. По этим причинам для работы с списками контроля доступа предпочтительно использование UFS2
====

ACL включаются во время монтирования флагом `acls`, который добавляется к [.filename]#/etc/fstab#. Этот флаг также можно сделать постоянным с помощью man:tunefs[8], изменив флаг ACL в заголовке файловой системы. Вообще говоря, использование флага в суперблоке предпочтительно по нескольким причинам:

* Постоянный ACL флаг не может быть изменен путем перемонтирования системы (man:mount[8] `-u`), а только через man:umount[8] и man:mount[8]. Это означает, что ACL нельзя включить на корневой файловой системе после загрузки. Это также означает, что вы не можете изменить флаг на используемой файловой системе.
* Установка флага в суперблоке приводит к постоянному монтированию файловой системы с включенным ACL, даже если нет записи в [.filename]#fstab# или при смене порядка устройств. Это предотвращает случайное монтирование файловой системы без ACL, которое может повлечь за собой проблемы с безопасностью.

[NOTE]
====
Мы можем изменить поведение ACL для включения флага без полного перемонтирования, но считаем, что желательно исключить случайное монтирование без ACL, поскольку вы можете попасть в неприятную ситуацию, если включите ACL, затем выключите их, затем опять включите без сброса расширенных атрибутов. Обычно, как только вы включили ACL в файловой системе, они не должны быть выключены, поскольку получающаяся защита файлов может быть не совместима с той, что применяется пользователями системы, и повторное включение ACL может подключить предыдущие списки контроля доступа к файлам, права на которые изменены, что приведет к непредсказуемому поведению.
====

Файловые системы с включенными ACLs показывают знак `+` при просмотре прав на файлы. Например:

[.programlisting]
....
drwx------  2 robert  robert  512 Dec 27 11:54 private
drwxrwx---+ 2 robert  robert  512 Dec 23 10:57 directory1
drwxrwx---+ 2 robert  robert  512 Dec 22 10:20 directory2
drwxrwx---+ 2 robert  robert  512 Dec 27 11:57 directory3
drwxr-xr-x  2 robert  robert  512 Nov 10 11:54 public_html
....

Здесь мы видим, что каталоги [.filename]#directory1#, [.filename]#directory2#, и [.filename]#directory3# используют преимущества ACL. Каталог [.filename]#public_html# их не использует.

=== Использование ACL

ACL файловой системы можно просмотреть с помощью утилиты man:getfacl[1]. Например, для просмотра настроек ACL файла [.filename]#test#, может использоваться команда:

[source,shell]
....
% getfacl test
        #file:test
        #owner:1001
        #group:1001
        user::rw-
        group::r--
        other::r--
....

Для изменения ACL этого файла, вызовите утилиту man:setfacl[1]. Выполните:

[source,shell]
....
% setfacl -k test
....

Параметр `-k` удалит все установленные на данный момент ACL из файла или файловой системы. Более предпочтительный метод это использование параметра `-b`, который оставит необходимые для работы ACL поля.

[source,shell]
....
% setfacl -m u:trhodes:rwx,group:web:r--,o::--- test
....

В вышеприведенной команде параметр `-m` использован для изменения записей ACL по умолчанию. Поскольку предустановленных записей не было (они были удалены предыдущей командой), эта команда восстановит параметры по умолчанию и задаст приведенные параметры. Имейте ввиду, при добавлении пользователя или группы, которых нет в системе, на [.filename]#stdout# будет выведена ошибка `Invalid argument`.

[[security-portaudit]]
== Мониторинг вопросов безопасности в ПО сторонних разработчиков

В последние годы в области информационной безопасности произошло много улучшений, касающихся выработки оценки уязвимости. Угроза проникновения в систему увеличивается вместе с установкой и настройкой утилит сторонних разработчиков, какой бы современной операционной системы это ни касалось.

Оценка уязвимости является ключевым фактором обеспечения защиты, и хотя для базового комплекта FreeBSD выпускаются бюллетени безопасности, но делать это для каждой сторонней утилиты выше возможностей участников Проекта FreeBSD. Существует способ смягчения уязвимостей программного обеспечения сторонних разработчиков и предупреждения администраторов об известных проблемах с безопасностью. Во FreeBSD существует утилита под названием Portaudit, которая служит исключительно этой цели.

Порт package:security/portaudit[] обращается к базе данных, обновляемой и поддерживаемой Группой информационной безопасности FreeBSD и разработчиками портов, для получения информации об известных проблемах с защитой.

Для того, чтобы приступить к использованию Portaudit, необходимо установить его из Коллекции Портов:

[source,shell]
....
# cd /usr/ports/security/portaudit && make install clean
....

В процессе установки будут обновлены конфигурационные файлы для man:periodic[8], в которые будет добавлена выдача Portaudit при ежедневном её запуске. Проверьте, что ежедневные сообщения электронной почты, касающиеся безопасности, которые посылаются на адрес `root`, прочитываются. Другой дополнительной настройки больше не понадобится.

После установки администратор может обновить базу данных и посмотреть список известных уязвимостей в установленных пакетах при помощи команды

[source,shell]
....
# portaudit -Fda
....

[NOTE]
====
База данных будет автоматически обновлена при запуске man:periodic[8]; таким образом, предыдущая команду можно полностью опустить. Она требуется только для следующих примеров.
====

Для аудита утилит сторонних разработчиков, установленных как часть Коллекции Портов, администратору достаточно запускать только следующую команду:

[source,shell]
....
# portaudit -a
....

Утилита portaudit выдаст примерно следующее:

[.programlisting]
....
Affected package: cups-base-1.1.22.0_1
Type of problem: cups-base -- HPGL buffer overflow vulnerability.
Reference: <http://www.FreeBSD.org/ports/portaudit/40a3bca2-6809-11d9-a9e7-0001020eed82.html>

1 problem(s) in your installed packages found.

You are advised to update or deinstall the affected package(s) immediately.
....

Перейдя в Web-браузере по показанному URL, администратор может получить более подробную информацию о показанной уязвимости. В неё войдёт перечисление версий, затронутых соответствующей версией порта FreeBSD, а также другие Web-сайты, которые могут содержать бюллетени безопасности.

Если описывать вкратце, то Portaudit является мощной и, при использовании вместе с портом Portupgrade, чрезвычайно полезной утилитой.

[[security-advisories]]
== Сообщения безопасности FreeBSD

Как многие и высококачественные операционные системы, FreeBSD публикует "Сообщения безопасности" ("Security Advisories"). Эти сообщения обычно отправляются по почте в списки рассылки, посвященные безопасности и публикуются в списке проблем только после выхода исправлений к соответствующим релизам. В этом разделе разъясняется, что такое сообщения безопасности, как их читать и какие меры принимать для исправления системы.

=== Как выглядит сообщение?

Сообщение безопасности FreeBSD выглядит подобно сообщению ниже, взятому из списка рассылки {freebsd-security-notifications}.

[.programlisting]
....
=============================================================================
FreeBSD-SA-XX:XX.UTIL                                     Security Advisory
                                                          The FreeBSD Project

Topic:          denial of service due to some problem<.>

Category:       core<.>
Module:         sys<.>
Announced:      2003-09-23<.>
Credits:        Person@EMAIL-ADDRESS<.>
Affects:        All releases of FreeBSD<.>
                FreeBSD 4-STABLE prior to the correction date
Corrected:      2003-09-23 16:42:59 UTC (RELENG_4, 4.9-PRERELEASE)
                2003-09-23 20:08:42 UTC (RELENG_5_1, 5.1-RELEASE-p6)
                2003-09-23 20:07:06 UTC (RELENG_5_0, 5.0-RELEASE-p15)
                2003-09-23 16:44:58 UTC (RELENG_4_8, 4.8-RELEASE-p8)
                2003-09-23 16:47:34 UTC (RELENG_4_7, 4.7-RELEASE-p18)
                2003-09-23 16:49:46 UTC (RELENG_4_6, 4.6-RELEASE-p21)
                2003-09-23 16:51:24 UTC (RELENG_4_5, 4.5-RELEASE-p33)
                2003-09-23 16:52:45 UTC (RELENG_4_4, 4.4-RELEASE-p43)
                2003-09-23 16:54:39 UTC (RELENG_4_3, 4.3-RELEASE-p39)<.>
CVE Name:   CVE-XXXX-XXXX<.>

For general information regarding FreeBSD Security Advisories,
including descriptions of the fields above, security branches, and the
following sections, please visit
http://www.FreeBSD.org/security/.

I.   Background<.>

II.  Problem Description<.>

III. Impact<.>

IV.  Workaround<.>

V.   Solution<.>

VI.  Correction details<.>

VII. References<.>
....

<.> Поле `Topic` показывает в чем именно заключается проблема. Это обычно введение в сообщение безопасности, упоминающее утилиту, в которой возникла ошибка.
<.> Поле `Category` относится к затронутой части системы и может быть выбрана из `core`, `contrib`, или `ports`. Категория `core` означает, что уязвимость затрагивает основной компонент операционной системы FreeBSD. Категория `contrib` означает, что уязвимость затрагивает программы, предоставленные проекту FreeBSD, например sendmail. Наконец, категория `ports` означает, что уязвимость затрагивает программное обеспечение, доступное из Коллекции Портов.
<.> Поле `Module` указывает на местоположение компонента, например `sys`. В этом примере мы видим, что затронут модуль `sys`, следовательно, эта уязвимость относится к компоненту, используемому в ядре.
<.> Поле `Announced` отражает дату публикации сообщения безопасности, или его анонсирования. Это означает, что команда обеспечения безопасности убедилась, что проблема существует и что патч помещён в хранилище исходных текстов FreeBSD.
<.> Поле `Credits` упоминает частное лицо или организацию, обнаружившую уязвимость и сообщившую о ней.
<.> Поле `Affects` дает информацию о релизах FreeBSD, к которым относится данная уязвимость. Для базовой системы, просмотр вывода команды `ident` для файлов, затронутых уязвимостью, поможет определить ревизию. Номер версии портов приведен после имени порта в каталоге [.filename]#/var/db/pkg#. Если система не синхронизируется с CVS-хранилищем FreeBSD и не пересобирается ежедневно, высок шанс, что она затронута уязвимостью.
<.> Поле `Corrected` показывает дату, время, смещение во времени и релиз, в котором исправлена ошибка.
<.> Зарезервировано для идентификации уязвимости в общей базе данных CVD (Common Vulnerabilities Database).
<.> Поле `Background` дает информацию именно о той утилите, для которой выпущено сообщение. Как правило информация о том, зачем утилита присутствует в FreeBSD, для чего она используется, и немного информации о том, как появилась эта утилита.
<.> Поле `Problem Description` дает более глубокие разъяснения возникшей проблемы. Оно может включать информацию об ошибочном коде, или даже о том, как утилита может быть использована для создания бреши в системе безопасности.
<.> Поле `Impact` описывает тип воздействия, который проблема может оказать на систему. Это может быть все, что угодно, от атаки на отказ в обслуживании до получения пользователями дополнительных привилегий, или даже получения атакующим прав суперпользователя.
<.> Поле `Workaround` предлагает тем, системным администраторам, которые не могут обновить систему, обходной путь решения проблемы. Он может пригодиться при недостатке времени, отсутствии подключения к сети или по массе других причин. В любом случае, к безопасности нельзя относиться несерьезно, и необходимо либо применить указанный обходной путь, либо исправить систему.
<.> Поле `Solution` предлагает инструкции по исправлению затронутой системы. Это пошаговое руководство, протестированный метод восстановления безопасности системы.
<.> Поле `Correction Details` показывает ветвь CVS (имя релиза с точками, замененными на символы подчеркивания). Здесь также показан номер ревизии каждого файла из каждой ветви.
<.> Поле `References` обычно упоминает другие источники информации. Это могут быть Web-страницы, книги, списки рассылки и группы новостей.

[[security-accounting]]
== Учёт используемых ресурсов

Учёт используемых процессами ресурсов представляет собой метод защиты, при котором администратор может отслеживать использование системных ресурсов и их распределение между пользователями для нужд системного мониторинга и минимального отслеживания команд пользователей.

На самом деле здесь есть свои положительный и отрицательные моменты. Положительной стороной является то, что проникновение может быть отслежено до первоначальной точки входа. Отрицательной стороной является объём протоколов, который генерируется при мониторинге, и соответствующие требования к дисковому пространству. В этом разделе администратору даются основы учёта ресурсов процессов.

=== Активация и использование учёта ресурсов

Прежде чем использовать систему учёта ресурсов, её необходимо активировать. Для этого выполните следующие команды:

[source,shell]
....
# touch /var/account/acct

# accton /var/account/acct

# echo 'accounting_enable="YES"' >> /etc/rc.conf
....

После активации система учёта ресурсов начнёт отслеживать статистику CPU, команд и так далее. Все протоколы учёта ведутся в формате, недоступном для чтения человеком, и могут просматриваться при помощи утилиты man:sa[8]. Запущенная без параметров, `sa` выдаст информацию, относящуюся к количеству вызовов в расчёте на каждого пользователя, общее затраченное время в минутах, общее время CPU и пользователя в минутах, среднее количество операций ввода/вывода и так далее.

Для просмотра информации о запущенных командах, необходимо воспользоваться утилитой man:lastcomm[1]. Команду `lastcomm` можно использовать, например, для выдачи списка директив, выданных пользователями определённого терминала man:ttys[5]:

[source,shell]
....
# lastcomm ls trhodes ttyp1
....

Эта команда выдаст все зафиксированные использования команды `ls` пользователем `trhodes` на терминале ttyp1.

Существует многие другие полезные параметры, которые описаны на соответствующих справочных страницах man:lastcomm[1], man:acct[5] и man:sa[8].
