---
title: Глава 19. Поддержка файловых систем
part: Часть III. Системное администрирование
prev: books/handbook/geom
next: books/handbook/l10n
---

[[filesystems]]
= Поддержка файловых систем
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:source-highlighter: rouge
:experimental:
:skip-front-matter:
:toc-title: Содержание
:table-caption: Таблица
:figure-caption: Рисунок
:example-caption: Пример
:xrefstyle: basic
:relfileprefix: ../
:outfilesuffix:
:sectnumoffset: 19

ifeval::["{backend}" == "html5"]
:imagesdir: ../../../images/books/handbook/filesystems/
endif::[]

ifeval::["{backend}" == "pdf"]
:imagesdir: ../../../../static/images/books/handbook/filesystems/
endif::[]

ifeval::["{backend}" == "epub3"]
:imagesdir: ../../../../static/images/books/handbook/filesystems/
endif::[]

include::shared/authors.adoc[]
include::shared/releases.adoc[]
include::shared/ru/mailing-lists.adoc[]
include::shared/ru/teams.adoc[]
include::shared/ru/urls.adoc[]

toc::[]

[[filesystems-synopsis]]
== Краткий обзор

Файловые системы - неотъемлемая часть любой операционной системы. Они позволяют пользователям записывать и хранить файлы, получать доступ к данным, и, конечно-же, пользоваться жесткими дисками. У разных операционных систем есть одна общая черта - их основная файловая система (native filesystem). Для FreeBSD это Fast File System (или FFS), которая произошла от Unix(TM) File System (сокращенно UFS).

FreeBSD также поддерживает ряд других файловых систем, тем самым предоставляя возможность получать доступ к данным от других операционных систем локально, например: к данным, находящимся на подключенных USB устройствах хранения, флэш-накопителях и жестких дисках. В списке поддерживаемых есть файловые системы, разработанные для других операционных систем, например Linux(R) Extended File System (EXT) и Sun(TM) Z File System (ZFS).

FreeBSD имеет разные уровни поддержки для разных файловых систем. Для некоторых будет достаточно загрузки модуля ядра, другим может потребоваться установка набора утилит (toolset). Цель этого раздела - дать представления пользователям FreeBSD о возможностях использования других файловых систем на их операционных системах. Начнем с Sun(TM) Z file system.

После прочтения этого раздела вы будете знать:

* Разницу между основной и поддерживаемой файловой системой.
* Какие файловые системы поддерживаются FreeBSD.
* Как подключить, сконфигурировать, получить доступ и использовать поддерживаемые файловые системы.

Перед прочтением этого раздела вам необходимо:

* Понимать основы UNIX(R) и FreeBSD (crossref:basics[basics, Основы UNIX]).
* Знать азы конфигурирования и компиляции ядра (crossref:kernelconfig[kernelconfig, Настройка ядра FreeBSD]).
* Уметь устанавливать приложения сторонних разработчиков в FreeBSD (crossref:ports[ports, Установка приложений. порты и пакеты]).
* Быть знакомым с именованием дисков и устройств хранения в FreeBSD (crossref:disks[disks, Устройства хранения]).

[[filesystems-zfs]]
== Файловая система ZFS

Файловая система ZFS, разработанная компанией Sun(TM), основана на использовании метода пулов устройств хранения данных. Это значит, что емкость носителя занимается только тогда, когда она становится необходимой для сохранения данных. ZFS также была разработана с упором на максимальную целостность данных, поддерживая снимки (snapshot), множество копий и контрольные суммы данных. Новая модель репликации данных, известная как RAID-Z, подобна RAID-5, но специально разработана для предотвращения повреждений данных при записи.

=== Настройка ZFS

Подсистема ZFS занимает значительную часть ресурсов системы. Чтобы получить от нее максимум эффективности в повседневном использовании, потребуется выполнить некоторые настройки. ZFS является экспериментальной функциональной возможностью в FreeBSD, но ситуация может измениться в ближайшем будущем; однако на данный момент рекомендуется выполнить следующие шаги.

==== Память

Общий размер ОЗУ должен быть как минимум равен одному гигабайту, хотя рекомендуется два гигабайта или более. Во всех нижеследующих примерах используется система с 1ГБ памяти совместно с другими специальными настройками.

Известно, что некоторые пользователи преуспели в использовании ZFS на системах, имеющих менее одного гигабайта памяти, но с таким ограниченным объемом ОЗУ и при серьезной загрузке машины очень вероятны паники FreeBSD из-за нехватки памяти.

==== Настройка ядра

Рекомендуется исключить из файла конфигурации ядра неиспользуемые драйвера и опции. Так как большинство драйверов устройств доступно в виде модулей, то они просто могут быть загружены с помощью соответствующих записей в файле [.filename]#/boot/loader.conf#.

Пользователям архитектуры i386(TM) необходимо добавить следующую опцию в их файл конфигурации ядра, перестроить ядро и перезагрузиться:

[.programlisting]
....
options         KVA_PAGES=512
....

Эта опция расширит адресное пространство ядра, тем самым позволяя переменной `vm.kvm_size` быть установленной за текущий предел в 1 ГБ (2 ГБ для PAE). Чтобы найти наиболее подходящее значение для этой опции, разделите имеющийся объем ОЗУ, выраженный в мегабайтах, на 4. Приведенное выше значение `512` рекомендуется для систем с 2 ГБ оперативной памяти.

==== Параметры loader.conf

Адресное пространство [.filename]#kmem# должно быть увеличено на всех FreeBSD архитектурах. На тестовой системе с одним гигабайтом физической памяти стабильная работа была получена со следующими параметрами, которые необходимо внести в файл [.filename]#/boot/loader.conf# и перезагрузить систему.

[.programlisting]
....
vm.kmem_size="330M"
vm.kmem_size_max="330M"
vfs.zfs.arc_max="40M"
vfs.zfs.vdev.cache.size="5M"
....

За более детальными рекомендациями по тонкой настройке системы под ZFS, обратитесь к странице: http://wiki.freebsd.org/ZFSTuningGuide[http://wiki.freebsd.org/ZFSTuningGuide].

=== Использование ZFS

Существует стартовый механизм, позволяющий монтировать ZFS пулы во время инициализации системы. Чтобы его задействовать, выполните следующие команды:

[source,bash]
....
# echo 'zfs_enable="YES"' >> /etc/rc.conf
# /etc/rc.d/zfs start
....

Здесь и далее в статье подразумевается, что в системе установлено три SCSI диска с именами устройств [.filename]#da0#, [.filename]#da1# и [.filename]#da2#. Использующим IDE диски необходимо подставить имена устройств [.filename]#ad# вместо имен устройств SCSI.

==== Простой дисковый пул

Для создания простого пула ZFS без избыточности, задействовав при этом один жесткий диск, воспользуйтесь командой `zpool`:

[source,bash]
....
# zpool create example /dev/da0
....

Чтобы увидеть новый пул, просмотрите вывод команды `df`:

[source,bash]
....
# df
Filesystem  1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a   2026030  235230  1628718    13%    /
devfs               1       1        0   100%    /dev
/dev/ad0s1d  54098308 1032846 48737598     2%    /usr
example      17547136       0 17547136     0%    /example
....

Этот вывод четко показывает, что пул `example` был не только создан, но также и _примонтирован_. Он также доступен, как и обычная файловая система, в нем можно создавать файлы, а пользователи могут просматривать его содержимое, например:

[source,bash]
....
# cd /example
# ls
# touch testfile
# ls -al
total 4
drwxr-xr-x   2 root  wheel    3 Aug 29 23:15 .
drwxr-xr-x  21 root  wheel  512 Aug 29 23:12 ..
-rw-r--r--   1 root  wheel    0 Aug 29 23:15 testfile
....

Однако в этом примере простого пула не задействованы никакие функциональные возможности ZFS. Создайте файловую систему в этом пуле и активируйте сжатие данных на ней:

[source,bash]
....
# zfs create example/compressed
# zfs set compression=gzip example/compressed
....

С этого момента для файловой системы ZFS `example/compressed` активировано сжатие данных. Попробуйте поместить на нее несколько больших файлов копируя их в [.filename]#/example/compressed#.

А вот как можно отключить сжатие данных:

[source,bash]
....
# zfs set compression=off example/compressed
....

Для того чтобы размонтировать файловую систему, выполните следующую команду и проверьте результат утилитой `df`:

[source,bash]
....
# zfs umount example/compressed
# df
Filesystem  1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a   2026030  235232  1628716    13%    /
devfs               1       1        0   100%    /dev
/dev/ad0s1d  54098308 1032864 48737580     2%    /usr
example      17547008       0 17547008     0%    /example
....

Снова смонтируйте файловую систему и проверьте результат при помощи `df`:

[source,bash]
....
# zfs mount example/compressed
# df
Filesystem         1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a          2026030  235234  1628714    13%    /
devfs                      1       1        0   100%    /dev
/dev/ad0s1d         54098308 1032864 48737580     2%    /usr
example             17547008       0 17547008     0%    /example
example/compressed  17547008       0 17547008     0%    /example/compressed
....

Пул и файловая система также отображается в выводе команды `mount`:

[source,bash]
....
# mount
/dev/ad0s1a on / (ufs, local)
devfs on /dev (devfs, local)
/dev/ad0s1d on /usr (ufs, local, soft-updates)
example on /example (zfs, local)
example/data on /example/data (zfs, local)
example/compressed on /example/compressed (zfs, local)
....

Как вы уже убедились, файловые системы ZFS после создания могут использоваться как и обычные файловые системы; однако доступно множество других возможностей. В следующем примере мы создадим новую файловую систему `data`. На ней мы будем содержать важные данные, поэтому файловая система сконфигурирована хранить две копии каждого блока:

[source,bash]
....
# zfs create example/data
# zfs set copies=2 example/data
....

Снова проверьте свободное и использованное место выполнив команду `df`:

[source,bash]
....
# df
Filesystem         1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a          2026030  235234  1628714    13%    /
devfs                      1       1        0   100%    /dev
/dev/ad0s1d         54098308 1032864 48737580     2%    /usr
example             17547008       0 17547008     0%    /example
example/compressed  17547008       0 17547008     0%    /example/compressed
example/data        17547008       0 17547008     0%    /example/data
....

Заметьте, что каждая файловая система в пуле имеет тот же объем свободного места. Мы использовали команду `df` на протяжении этих примеров, чтобы показать, что файловые системы занимают только необходимое им пространство, используя ресурс одного и того же пула. ZFS уходит от привычных понятий "том (volume)" и "раздел (partition)", позволяя файловым системам занимать один и тот же пул. Уничтожьте файловые системы, потом уничтожьте пул, так как в них уже нет нужды:

[source,bash]
....
# zfs destroy example/compressed
# zfs destroy example/data
# zpool destroy example
....

Жесткие диски со временем выходят из строя, это неизбежно. Когда этот диск выйдет из строя, данные будут утеряны. Одним из способов избежать потери данных из-за вышедшего из строя жесткого диска является построение RAID массивов. ZFS поддерживает эту функциональную возможность в своем дизайне, и это описано в следующем разделе.

==== ZFS RAID-Z

Как уже было сказано выше, в этой статье подразумевается, что в нашей системе в распоряжении есть три SCSI диска: [.filename]#da0#, [.filename]#da1# и [.filename]#da2# (или [.filename]#ad0# и далее в случае IDE дисков). Для того, чтобы создать RAID-Z пул, выполните следующую команду:

[source,bash]
....
# zpool create storage raidz da0 da1 da2
....

[NOTE]
====
Sun(TM) рекомендует использовать от трех до девяти жестких дисков в конфигурации RAID-Z. Если есть необходимость в использовании 10 или более дисков, подумайте над тем, чтобы разбить их на меньшие группы RAID-Z. Если у вас есть только два диска и вам всё-таки требуется избыточность, возможно лучшим вариантом будет создание ZFS зеркала. Смотрите страницу справочника man:zpool[8] для получения более подробных сведений.
====

По завершении команды должен создаться пул `storage`. Как и прежде, это может быть проверено при помощи команд man:mount[8] и man:df[1]. Больше дисковых устройств может быть задействовано путем добавления их в конец списка параметров команды, приведенной выше. Создайте в пуле новую файловую систему, называемую `home`, в которой будут размещаться пользовательские файлы:

[source,bash]
....
# zfs create storage/home
....

На данном этапе возможно активировать сжатие данных и организовать автоматическое создание копий пользовательских домашних каталогов и файлов. Это может быть достигнуто так же, как и ранее, при помощи следующих команд:

[source,bash]
....
# zfs set copies=2 storage/home
# zfs set compression=gzip storage/home
....

Чтобы организовать в этой файловой системе хранение домашних каталогов пользователей, скопируйте сюда их содержимое и создайте соответствующие символические ссылки:

[source,bash]
....
# cp -rp /home/* /storage/home
# rm -rf /home /usr/home
# ln -s /storage/home /home
# ln -s /storage/home /usr/home
....

С этого момента пользовательские данные сохраняются на новой файловой системе [.filename]#/storage/home#. Для проверки создайте учетную запись нового пользователя и войдите ею в систему.

Попробуйте создать снимок (snapshot), к которому можно будет откатиться при необходимости:

[source,bash]
....
# zfs snapshot storage/home@08-30-08
....

Заметьте, что снимок (snapshot) захватит реальную файловую систему, а не домашний каталог или файл. Символ `@` отделяет имя файловой системы или имя тома от имени снимка. Когда возникнет необходимость восстановить пользовательские домашние каталоги, выполните следующую команду:

[source,bash]
....
# zfs rollback storage/home@08-30-08
....

Чтобы получить список имеющихся в наличии снимков, выполните команду `ls` в каталоге [.filename]#.zfs/snapshot#. Например, чтобы увидеть сделанный ранее снимок, выполните следующую команду:

[source,bash]
....
# ls /storage/home/.zfs/snapshot
....

Можно написать скрипт, выполняющий снимки пользовательских данных ежемесячно; однако, со временем, они могут занять значительную часть дискового пространства. Предыдущий снимок может быть удален используя следующую команду:

[source,bash]
....
# zfs destroy storage/home@08-30-08
....

Нет причины после наших экспериментов далее держать в текущем состоянии [.filename]#/storage/home#. Сделаем ее реальной файловой системой [.filename]#/home#:

[source,bash]
....
# zfs set mountpoint=/home storage/home
....

Выполнение команд `df` и `mount` покажет, что с этого момента операционная система воспринимает нашу файловую систему как обычную [.filename]#/home#:

[source,bash]
....
# mount
/dev/ad0s1a on / (ufs, local)
devfs on /dev (devfs, local)
/dev/ad0s1d on /usr (ufs, local, soft-updates)
storage on /storage (zfs, local)
storage/home on /home (zfs, local)
# df
Filesystem   1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a    2026030  235240  1628708    13%    /
devfs                1       1        0   100%    /dev
/dev/ad0s1d   54098308 1032826 48737618     2%    /usr
storage       26320512       0 26320512     0%    /storage
storage/home  26320512       0 26320512     0%    /home
....

На этом завершим конфигурацию RAID-Z. Чтобы во время ночных запусков man:periodic[8] получать информацию о статусе созданных файловых систем, выполните следующую команду:

[source,bash]
....
# echo 'daily_status_zfs_enable="YES"' >> /etc/periodic.conf
....

==== Восстановление RAID-Z

Каждая система программных RAID массивов предоставляет возможность отображать информацию о своем `состоянии`. ZFS - не исключение. Статус устройств RAID-Z может быть просмотрен при помощи следующей команды:

[source,bash]
....
# zpool status -x
....

Если пулы исправны и всё нормально, возвратится следующее сообщение:

[source,bash]
....
all pools are healthy
....

А если есть какие-то неполадки, например диск выведен из массива, возвращенное состояние пула будет подобным следующему:

[source,bash]
....
  pool: storage
 state: DEGRADED
status: One or more devices has been taken offline by the administrator.
	Sufficient replicas exist for the pool to continue functioning in a
	degraded state.
action: Online the device using 'zpool online' or replace the device with
	'zpool replace'.
 scrub: none requested
config:

	NAME        STATE     READ WRITE CKSUM
	storage     DEGRADED     0     0     0
	  raidz1    DEGRADED     0     0     0
	    da0     ONLINE       0     0     0
	    da1     OFFLINE      0     0     0
	    da2     ONLINE       0     0     0

errors: No known data errors
....

Вывод показывает, что устройство было переведено в автономный режим администратором. Это верно для данного отдельного примера. Чтобы перевести диск в автономный режим, была выполнена команда:

[source,bash]
....
# zpool offline storage da1
....

Теперь после останова системы возможно заменить [.filename]#da1#. Когда система загрузится снова, выполните следующую команду чтобы заменить диск в массиве:

[source,bash]
....
# zpool replace storage da1
....

С этого момента статус может быть проверен опять и на этот раз без флага `-x`:

[source,bash]
....
# zpool status storage
 pool: storage
 state: ONLINE
 scrub: resilver completed with 0 errors on Sat Aug 30 19:44:11 2008
config:

	NAME        STATE     READ WRITE CKSUM
	storage     ONLINE       0     0     0
	  raidz1    ONLINE       0     0     0
	    da0     ONLINE       0     0     0
	    da1     ONLINE       0     0     0
	    da2     ONLINE       0     0     0

errors: No known data errors
....

В выводе сообщается, что при перестроении массива ошибок обнаружено не было.

==== Проверка данных

Как уже было сказано ранее, ZFS использует `контрольные суммы` для проверки целостности сохраненных данных. Подсчет и сохранение контрольных сумм включается автоматически во время создания файловых систем и может быть отключен при помощи команды:

[source,bash]
....
# zfs set checksum=off storage/home
....

Отключение подсчета контрольных сумм - не очень хорошая идея; особенно ввиду того, что они занимают мало места, а также при их использовании нет существенных расходов ресурсов системы. Пока подсчет включен, возможно выполнять проверки целостности данных ZFS, используя контрольные суммы. Этот процесс известен как "очистка (scrubbing)". Чтобы проверить целостность данных пула `storage`, выполните следующую команду:

[source,bash]
....
# zpool scrub storage
....

Этот процесс может занять значительное время в зависимости от количества сохранённых данных. Очистка (scrubbing) порождает интенсивный ввод/вывод, поэтому только один экземпляр этой операции может выполняться в один момент времени. После завершения очистки (scrubbing) статус обновится, его можно просмотреть выполнив следующий запрос:

[source,bash]
....
# zpool status storage
 pool: storage
 state: ONLINE
 scrub: scrub completed with 0 errors on Sat Aug 30 19:57:37 2008
config:

	NAME        STATE     READ WRITE CKSUM
	storage     ONLINE       0     0     0
	  raidz1    ONLINE       0     0     0
	    da0     ONLINE       0     0     0
	    da1     ONLINE       0     0     0
	    da2     ONLINE       0     0     0

errors: No known data errors
....

Время завершения отображается в простом виде в этом примере. Очистка помогает удостовериться в целостности данных на протяжении длительного времени.

В этом разделе была освещена лишь малая часть возможностей ZFS. За более подробной информацией обратитесь к страницам справочника man:zfs[8] и man:zpool[8].
