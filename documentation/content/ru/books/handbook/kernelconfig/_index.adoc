---
title: Глава 9. Настройка ядра FreeBSD
part: Часть II. Общие задачи
prev: books/handbook/multimedia
next: books/handbook/printing
---

[[kernelconfig]]
= Настройка ядра FreeBSD
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:source-highlighter: rouge
:experimental:
:skip-front-matter:
:toc-title: Содержание
:table-caption: Таблица
:figure-caption: Рисунок
:example-caption: Пример
:xrefstyle: basic
:relfileprefix: ../
:outfilesuffix:
:sectnumoffset: 9

ifeval::["{backend}" == "html5"]
:imagesdir: ../../../images/books/handbook/kernelconfig/
endif::[]

ifeval::["{backend}" == "pdf"]
:imagesdir: ../../../../static/images/books/handbook/kernelconfig/
endif::[]

ifeval::["{backend}" == "epub3"]
:imagesdir: ../../../../static/images/books/handbook/kernelconfig/
endif::[]

include::shared/authors.adoc[]
include::shared/releases.adoc[]
include::shared/ru/mailing-lists.adoc[]
include::shared/ru/teams.adoc[]
include::shared/ru/urls.adoc[]

toc::[]

[[kernelconfig-synopsis]]
== Краткий обзор

Ядро - это основная часть операционной системы FreeBSD. Оно ответственно за управление памятью, параметры безопасности, работу с сетью, доступ к дискам и многое другое. Несмотря на то, что FreeBSD становится всё более динамически конфигурируемой, иногда приходится собирать собственное ядро.

После прочтения этой главы вы узнаете:

* Почему вам может понадобиться сборка собственного ядра.
* Как написать файл конфигурации ядра или изменить существующий.
* Как использовать файл конфигурации ядра для того, чтобы создать и собрать новое ядро.
* Как установить новое ядро.
* Что делать, если что-то не работает или работает не так, как должно.

Все команды, приводимые в этой главе в качестве примера, должны выполняться от пользователя `root`.

[[kernelconfig-custom-kernel]]
== Зачем собирать собственное ядро?

Традиционно в FreeBSD использовалось так называемое "монолитное" ядро. Это означает, что ядро - это одна большая программа, которая поддерживает фиксированный набор устройств и в случае, если необходимо изменить его поведение, требуется сборка нового ядра и перезагрузка компьютера уже с новым ядром.

На сегодняшний день FreeBSD быстро продвигается к модели, в которой большая часть функциональности содержится в модулях, которые могут быть при необходимости динамически загружены и выгружены из ядра. Это позволяет ядру использовать устройства, которые "внезапно" появились в системе (например, устройства PCMCIA в лэптопе) или добавлять новую функциональность в ядро, которая не была необходима в момент первоначальной сборки ядра. Такой подход известен как модульность ядра.

Несмотря на это, всё ещё иногда бывает необходимо, чтобы некоторая функциональность была вкомпилирована в ядро статически. В некоторых случаях это продиктовано тем, что эта функциональность настолько сильно привязана к ядру, что не может быть динамически загружаемой. В других случаях это может быть просто потому, что никто не уделил время написанию динамически загружаемого модуля для этой функциональности.

Сборка собственного ядра - один из наиболее важных ритуалов, совершаемых опытными пользователями BSD. Несмотря на длительность этого процесса, ваша FreeBSD останется только в выигрыше. В отличие от ядра [.filename]#GENERIC#, которое должно поддерживать широкий спектр аппаратного обеспечения, собственное ядро содержит поддержку аппаратного обеспечения только _вашего_ компьютера. Это может давать следующие преимущества:

* Меньшее время загрузки. Поскольку ядро будет пытаться определить только то аппаратное обеспечение, которое установлено в вашем компьютере, время, которое потребуется системе для загрузки, может значительно уменьшиться.
* Уменьшение использования памяти. Собственное ядро часто использует меньше памяти, чем ядро [.filename]#GENERIC#, так как из него исключены лишние драйвера и неиспользуемые функциональные возможности. Это важно тем, что часть оперативной памяти постоянно занята кодом ядра и поэтому не может быть выделена приложениям. Именно по этой причине собственное ядро особенно полезно при использовании систем с малым объемом оперативной памяти.
* Поддержка дополнительного аппаратного обеспечения. Собственное ядро позволяет вам добавить поддержку устройств, отсутствующих в ядре [.filename]#GENERIC#.

[[kernelconfig-devices]]
== Определение аппаратного обеспечения

Перед тем, как углубиться в конфигурирование ядра, было бы разумно составить перечень установленного в компьютер аппаратного обеспечения. Если FreeBSD не является основной операционной системой, то перечень оборудования может быть легко составлен на основании анализа конфигурации текущей операционной системы. Например, Диспетчер устройств (Device Manager) от Microsoft(R) обычно содержит необходимую информацию об установленных устройствах. Диспетчер устройств находится на панели управления (control panel).

[NOTE]
====
У некоторых версий Microsoft(R) Windows(R) есть значок Система (System), вызов которого отобразит экран, содержащий среди прочих и Диспетчер устройств.
====

Если других операционных систем на машине не установлено, системному администратору придется искать эту информацию самостоятельно. Один из методов подразумевает использование утилиты man:dmesg[8] и команды man:man[1]. У большинства драйверов во FreeBSD есть страницы справочника, содержащие список поддерживаемого оборудования, а найденные во время начальной загрузки устройства будут перечислены в man:dmesg[8]. К примеру, следующие строки информируют о том, что драйвер [.filename]#psm# обнаружил мышь: 

[.programlisting]
....
psm0: <PS/2 Mouse> irq 12 on atkbdc0
psm0: [GIANT-LOCKED]
psm0: [ITHREAD]
psm0: model Generic PS/2 mouse, device ID 0
....

Этот драйвер необходимо будет включить в конфигурацию собственного ядра или загрузить посредством man:loader.conf[5].

В некоторых случаях `dmesg` отображает только системные сообщения вместо сообщений начальной загрузки. В таких случаях необходимо обращаться к файлу [.filename]#/var/run/dmesg.boot#.

Еще один метод нахождения аппаратного обеспечения подразумевает использование достаточно информативной утилиты man:pciconf[8]. Например:

[.programlisting]
....
ath0@pci0:3:0:0:        class=0x020000 card=0x058a1014 chip=0x1014168c rev=0x01 hdr=0x00
    vendor     = 'Atheros Communications Inc.'
    device     = 'AR5212 Atheros AR5212 802.11abg wireless'
    class      = network
    subclass   = ethernet
....

Эта часть вывода, полученная в результате запуска команды `pciconf -lv`, показывает, что драйвер [.filename]#ath# обнаружил беспроводное Ethernet устройство. Набрав `man _ath_`, вы получите страницу справочника man:ath[4].

Также, для извлечения необходимой информации, можно воспользоваться ключом `-k` к команде man:man[1]. В вышеприведенном случае можно набрать:

[source,bash]
....
# man -k Atheros
....

чтобы получить страницы справочника, содержащие определенное слово:

[.programlisting]
....
ath(4)                   - Atheros IEEE 802.11 wireless network driver
ath_hal(4)               - Atheros Hardware Access Layer (HAL)
....

Теперь, имея в распоряжении перечень аппаратного оборудования, можно безбоязненно приступить к сборке специализированного ядра.

[[kernelconfig-modules]]
== Драйвера, подсистемы и модули ядра

Перед построением специализированного ядра, обдумайте причины, побудившие вас к этому. Если требуется поддержка специального оборудования, то она наверняка уже реализована в виде модуля.

Модули ядра находятся в каталоге [.filename]#/boot/kernel#, и они могут быть динамически включены в работающее ядро при помощи man:kldload[8]. Если не все, то большинство драйверов существуют в виде модулей, и у них есть соответствующая страница справочника. К примеру, в предыдущем разделе упоминался драйвер [.filename]#ath# беспроводного Ethernet устройства. Соответствующая ему страница справочника гласит:

[.programlisting]
....
Alternatively, to load the driver as a module at boot time, place the
following line in man:loader.conf[5]:

    if_ath_load="YES"
....

Как уже выше сказано, добавление строки `if_ath_load="YES"` в файл [.filename]#/boot/loader.conf# позволит динамически загружать этот модуль во время загрузки системы.

В некоторых случаях, однако, интересующего вас модуля не существует. Чаще всего это справедливо для определенных подсистем и очень важных драйверов. Например, поддержка файловой системы FreeBSD (FFS) является обязательной опцией в ядре. Как и поддержка сети (INET). К сожалению, единственный способ определить является ли драйвер обязательным - это проверить наличие соответствующего модуля.

[WARNING]
====

Довольно легко удалить поддержку устройства или опцию, получив тем самым неработоспособное ядро. Например, если драйвер man:ata[4] изъят из конфигурации ядра, то система, использующая диски ATA, может не загрузиться без записи о модуле, добавленной в [.filename]#loader.conf#. Если есть сомнения, проверьте наличие модуля, и только потом исключайте поддержку в ядре.
====

[[kernelconfig-building]]
== Сборка и установка собственного ядра

[NOTE]
====
Для сборки ядра необходимо наличие всех исходных файлов FreeBSD.
====

Во-первых, давайте сделаем краткий обзор каталога, в котором будет происходить сборка ядра. Все каталоги, которые будут упоминаться, будут относительными по отношению к основному каталогу [.filename]#/usr/src/sys#, который также доступен как каталог [.filename]#/sys#. Этот каталог содержит множество подкаталогов, представляющих собой различные части ядра, но наиболее важным для нас будет каталог [.filename]#arch/conf#, в котором вы будете редактировать конфигурационный файл ядра и в котором находится каталог [.filename]#compile#, где будет собираться ваше ядро. _arch_ может быть [.filename]#i386#, [.filename]#amd64#, [.filename]#ia64#, [.filename]#powerpc#, [.filename]#sparc64# или [.filename]#pc98# (альтернативная ветвь аппаратного обеспечения, популярная в Японии). Все, что находится внутри каталога определенной архитектуры, относится только к этой архитектуре; остальной код является машинно независимым и общим для всех платформ, на которые FreeBSD может быть потенциально портирована. Обратите внимание на логическую структуру каталогов, в которой каждое поддерживаемое устройство, каждая файловая система и каждая опция размещается в своём собственном каталоге.

В примерах этой главы подразумевается, что вы используете архитектуру i386. Если архитектура вашей системы отличается от используемой в примерах, то вам необходимо будет соответственно изменить имена каталогов.

[NOTE]
====
Если каталог [.filename]#/usr/src/# отсутствует в вашей системе (или этот каталог пуст), то это значит, что исходные тексты не были установлены. Наиболее простой способ установить их - воспользоваться man:csup[1], как описано в crossref:cutting-edge[synching,Синхронизация исходных текстов]. Далее, создайте символическую ссылку на [.filename]#/usr/src/sys/#:

[source,bash]
....
# ln -s /usr/src/sys /sys
....

====

Затем, перейдите в каталог [.filename]#arch/conf# и скопируйте файл конфигурации [.filename]#GENERIC# в файл с выбранным вами именем. Например:

[source,bash]
....
# cd /usr/src/sys/i386/conf
# cp GENERIC MYKERNEL
....

По традиции имя состоит из букв в верхнем регистре, и если вы поддерживаете несколько компьютеров FreeBSD на различном оборудовании, хорошая идея добавлять это имя к имени хоста. Мы назвали ядро [.filename]#MYKERNEL# в этом примере.

[TIP]
====

Помещение файла конфигурации ядра в [.filename]#/usr/src# может быть плохой идеей. Если вы испытываете проблемы, их можно решить удалив [.filename]#/usr/src# и начав все с начала. После этого обычно требуется несколько секунд, чтобы понять, что вы удалили собственный файл настройки ядра. Не редактируйте непосредственно [.filename]#GENERIC#, он может быть также перезаписан и при следующем crossref:cutting-edge[updating-upgrading,обновлении дерева исходных текстов], и изменения ядра будут потеряны.

Вы можете сохранить файл конфигурации ядра в другом месте, а затем создать символическую ссылку на этот файл в каталоге [.filename]#i386#.

Например:

[source,bash]
....
# cd /usr/src/sys/i386/conf
# mkdir /root/kernels
# cp GENERIC /root/kernels/MYKERNEL
# ln -s /root/kernels/MYKERNEL
....

====

Теперь отредактируйте файл [.filename]#MYKERNEL# в своём любимом текстовом редакторе. Если вы только начинаете, единственным доступным редактором скорее всего будет vi, который слишком сложен для того, чтобы описать его здесь, но в <<bibliography,библиографии>> перечислено множество книг, в которых его использование хорошо освещено. Однако FreeBSD предоставляет более простой редактор ee, который, если вы - новичок, подойдёт вам больше всего. Не стесняйтесь изменять строки комментариев в начале файла, с тем, чтобы отобразить вашу конфигурацию или изменения, которые вы сделали по сравнению с [.filename]#GENERIC#.

Если вам приходилось собирать ядро для SunOS(TM) или какой-либо другой операционной системы типа BSD, многое из того, что содержится в этом файле будет очень знакомо вам. Если же вы, напротив, использовали другую операционную систему, такую как DOS, файл конфигурации [.filename]#GENERIC# может показаться вам крайне сложным, поэтому следуйте инструкциям в разделе <<kernelconfig-config,Конфигурационный файл>> медленно и внимательно.

[NOTE]
====
Если вы crossref:cutting-edge[updating-upgrading,синхронизируете дерево исходных текстов] с деревом проекта FreeBSD, не забудьте свериться с файлом [.filename]#/usr/src/UPDATING# перед обновлением. В этом файле описаны все важные вопросы и области исходного кода, требующие особого внимания. [.filename]#/usr/src/UPDATING# всегда соответствует версии ваших исходных текстов FreeBSD, поэтому является более актуальным источником информации, чем это руководство.
====

Теперь вы должны скомпилировать ядро.

[.procedure]
====
*Procedure: Сборка ядра*

[NOTE]
======
Для сборки ядра необходимо наличие всех исходных файлов FreeBSD.
======

. Перейдите в каталог [.filename]#/usr/src#:
+
[source,bash]
....
# cd /usr/src
....
+
. Соберите ядро:
+
[source,bash]
....
# make buildkernel KERNCONF=MYKERNEL
....
+
. Установите новое ядро:
+
[source,bash]
....
# make installkernel KERNCONF=MYKERNEL
....
====

[TIP]
====

По умолчанию, при построении ядра, _все_ модули ядра так же будут пересобраны. Если вы хотите обновить ядро быстрее или построить только определённые модули, то вам нужно отредактировать файл [.filename]#/etc/make.conf# перед началом процесса сборки ядра:

[.programlisting]
....
MODULES_OVERRIDE = linux acpi sound/sound sound/driver/ds1 ntfs
....

Эта переменная устанавливает список модулей, которые нужно построить вместо построения всех модулей.

[.programlisting]
....
WITHOUT_MODULES = linux acpi sound ntfs
....

В этой переменной перечисляются основные модули, которые необходимо исключить из процесса сборки. За другими переменными, которые вы можете посчитать полезными в процессе сборки ядра, обращайтесь к странице справочника man:make.conf[5].
====

Новое ядро будет скопировано в каталог [.filename]#/boot/kernel# как [.filename]#/boot/kernel/kernel#, а старое ядро будет перемещено в [.filename]#/boot/kernel.old/kernel#. Теперь перезагрузите систему для того, чтобы использовать новое ядро. Если что-то пойдёт не так, вы можете обратиться к разделу <<kernelconfig-trouble,Решение проблем>> в конце этой главы, который может оказаться полезен. Не забудьте прочитать раздел, который объясняет как исправить ситуацию, когда ядро <<kernelconfig-noboot,не загружается>>.

[NOTE]
====
Другие файлы, относящиеся к процессу загрузки, такие как загрузчик (man:loader[8]) и его конфигурационные файлы, размещаются в [.filename]#/boot#. Модули сторонних производителей могут быть помещены в [.filename]#/boot/kernel#, хотя пользователи должны знать, что очень важно, чтобы модули были синхронизированы с собранным ядром. Модули, не рассчитанные на работу с собранным ядром, могут вызвать нестабильность и некорректность работы.
====

[[kernelconfig-config]]
== Конфигурационный файл

Формат конфигурационного файла достаточно прост. Каждая строка представляет собой ключевое слово и один или более аргументов. Для простоты большинство строк содержат только один аргумент. Всё, что следует за символом `#` является комментарием и игнорируется. Следующие разделы описывают каждый параметр, в порядке, в котором они появляются в [.filename]##GENERIC##. [[kernelconfig-options]] За полным списком архитектурно-зависимых параметров и устройств обратитесь к файлу [.filename]##NOTES## в том же каталоге, что и [.filename]##GENERIC##. Архитектурно независимые параметры находятся в [.filename]##/usr/src/sys/conf/NOTES##.

Директива `include` стала доступной для использования в конфигурационных файлах. Она позволяет включать в текущий конфигурационный файл содержимое другого файла, тем самым упрощая процесс внесения небольших изменений в существующий файл. Например, если вам необходимо добавить всего несколько дополнительных опций или драйверов в ядро [.filename]#GENERIC#, то вам придется поддерживать только разницу к файлу GENERIC:

[.programlisting]
....
include GENERIC
ident MYKERNEL

options         IPFIREWALL
options         DUMMYNET
options         IPFIREWALL_DEFAULT_TO_ACCEPT
options         IPDIVERT
....

Большинство администраторов оценят значительные преимущества перед старым способом - написанием конфигурационного файла "с нуля": ваш конфигурационный файл будет отображать только изменения относительно [.filename]#GENERIC#. А после обновлений исходного кода, новые функциональные возможности, появившиеся в GENERIC, будут добавлены и в вашу конфигурацию, если только не препятствовать этому директивами `nooptions` или `nodevice`. Далее в этом разделе описывается типовой конфигурационный файл, его опции и устройства, а также их роли.

[NOTE]
====
Для сборки ядра со всеми возможными опциями (обычно используется для тестирования), выполните от имени суперпользователя (`root`) следующую команду:

[source,bash]
....
# cd /usr/src/sys/i386/conf && make LINT
....

====

Это пример конфигурационного файла ядра [.filename]#GENERIC# с различными дополнительными комментариями, которые могут понадобиться для ясности. Этот пример должен совпадать с вашей копией в [.filename]#/usr/src/sys/i386/conf/GENERIC# практически полностью.

[.programlisting]
....
machine        i386
....

Это архитектура машины. Она должна быть одной из следующих: `amd64`, `i386`, `ia64`, `pc98`, `powerpc`, или `sparc64`.

[.programlisting]
....
cpu          I486_CPU
cpu          I586_CPU
cpu          I686_CPU
....

Эта опция указывает тип процессора, который используется в вашей системе. В конфигурационном файле может быть несколько вхождений этой опции (например, если вы не уверены, какой из типов процессора необходимо использовать - `I586_CPU` или `I686_CPU`), но для собственного ядра лучше указывать только тот тип процессора, который установлен в вашей системе. Если вы не уверены, какой тип необходимо использовать вам, вы можете воспользоваться файлом [.filename]#/var/run/dmesg.boot#, чтобы увидеть протокол загрузки системы.

[.programlisting]
....
ident          GENERIC
....

Этот параметр определяет "метку" ядра. Необходимо, чтобы она соответствовала названию файла конфигурации ядра, например `_MYKERNEL_`, если вы следовали инструкциям в предыдущих примерах. Значение, которое вы присвоите параметру `ident` будет выводиться в процессе загрузки, поэтому полезно давать новым ядрам другие имена для того, чтобы отличать их от обычного ядра (например, если вы хотите собрать экспериментальное ядро).

[.programlisting]
....
#To statically compile in device wiring instead of /boot/device.hints
#hints          "GENERIC.hints"         # Default places to look for devices.
....

man:device.hints[5] используются для настройки параметров драйверов устройств. Путь по умолчанию, который man:loader[8] будет проверять при загрузке - [.filename]#/boot/device.hints#. Используя опцию `hints` вы можете вкомпилировать эти параметры статически в ваше ядро. В этом случае не требуется создавать файл [.filename]#device.hints# в каталоге [.filename]#/boot#.

[.programlisting]
....
makeoptions     DEBUG=-g          # Build kernel with gdb(1) debug symbols
....

При обычном построении ядра в сборку включается отладочная информация: опция `-g` передается компилятору man:gcc[1].

[.programlisting]
....
options          SCHED_ULE         # ULE scheduler
....

Планировщик по умолчанию во FreeBSD. Оставьте эту опцию.

[.programlisting]
....
options          PREEMPTION         # Enable kernel thread preemption
....

Позволяет высокоприоритетным нитям ядра вытеснять конкурентов, находящихся в режиме выполнения. Эта опция может помочь повысить реактивность системы по отношению к внешним воздействиям, например, за счет снижения латентности нитей, обрабатывающих прерывания.

[.programlisting]
....
options          INET              # InterNETworking
....

Поддержка сетевых возможностей. Оставьте эту опцию включенной, даже если вы не планируете подключаться к сети. Большинство программ требуют, чтобы работал хотя бы интерфейс обратной связи (loopback) (т.е. создание сетевых соединений внутри вашего ПК), так что эта опция в принципе является обязательной.

[.programlisting]
....
options          INET6             # IPv6 communications protocols
....

Включает поддержку коммуникационных протоколов IPv6.

[.programlisting]
....
options          FFS               # Berkeley Fast Filesystem
....

Включает поддержку основной файловой системы. Не удаляйте эту опцию, если вы планируете загружаться с жесткого диска.

[.programlisting]
....
options          SOFTUPDATES       # Enable FFS Soft Updates support
....

Этот параметр включает в ядре технологию Soft Updates, которая повышает скорость записи на диски. Несмотря на то, что эта технология включена в ядре, она должна быть включена для отдельных дисков. Просмотрите вывод команды man:mount[8] чтобы определить, включены ли Soft Updates для дисков вашей системы. Если вы не увидите параметр `soft-updates`, вам будет необходимо активировать его при помощи команды man:tunefs[8] (для существующих файловых систем) или команды man:newfs[8] (для новых файловых систем).

[.programlisting]
....
options          UFS_ACL           # Support for access control lists
....

Этот параметр включает в ядре поддержку списков управления доступом (ACL). Основывается на использовании расширенных атрибутов и UFS2, детальное описание вы сможете найти в crossref:security[fs-acl,Списки контроля доступа файловой системы (ACL)]. ACL включены по умолчанию и не должны выключаться в случае, если они ранее использовались на файловой системе, так как это удалит списки управления доступом и изменит то, как защищены файлы, непредсказуемым образом.

[.programlisting]
....
options          UFS_DIRHASH       # Improve performance on big directories
....

Эта опция включает функциональность, которая повышает скорость дисковых операций на больших каталогах в обмен на использование дополнительной памяти. Для большого сервера или рабочей станции рекомендуется оставить ее включенной, и выключить для системы, для которой более приоритетна память, чем скорость доступа к дискам, например для брандмауэра.

[.programlisting]
....
options          MD_ROOT           # MD is a potential root device
....

Этот параметр включает поддержку использования дисков в памяти для корневой файловой системы.

[.programlisting]
....
options          NFSCLIENT         # Network Filesystem Client
options          NFSSERVER         # Network Filesystem Server
options          NFS_ROOT          # NFS usable as /, requires NFSCLIENT
....

Сетевая файловая система. Если вы не планируете монтировать разделы с файлового сервера UNIX(R) через TCP/IP, вы можете исключить этот параметр из конфигурационного файла ядра.

[.programlisting]
....
options          MSDOSFS           # MSDOS Filesystem
....

Файловая система MS-DOS(R). Если вы не собираетесь монтировать форматированный в DOS раздел жесткого диска в момент загрузки, вы можете безопасно закомментировать этот параметр. Необходимый модуль будет автоматически загружен, когда вы в первый раз смонтируете раздел DOS, так, как это описано ниже. Кроме того, замечательный пакет package:emulators/mtools[] позволяет получить доступ к DOS дискетам без необходимости монтировать и размонтировать их (и не требует наличия `MSDOSFS`).

[.programlisting]
....
options          CD9660            # ISO 9660 Filesystem
....

Файловая система ISO 9660 для компакт-дисков. Если у вас нет привода CDROM или вы будете лишь изредка монтировать компакт-диски с данными, закомментируйте эту строку, так как необходимый модуль будет загружен автоматически при первом монтировании компакт-диска с данными. Для использования звуковых компакт-дисков эта файловая система не потребуется.

[.programlisting]
....
options          PROCFS            # Process filesystem (requires PSEUDOFS)
....

Файловая система процессов. Это "виртуальная" файловая система монтируемая в [.filename]#/proc#, которая позволяет таким приложениям, как man:ps[1] выдавать вам больше информации о запущенных процессах. Использование `PROCFS` не требуется, так как большинство мониторинговых и отладочных инструментов было адаптировано для работы без `PROCFS`: система по умолчанию не монтирует файловую систему процессов.

[.programlisting]
....
options          PSEUDOFS          # Pseudo-filesystem framework
....

Ядра, которые используют `PROCFS`, должны также включать поддержку `PSEUDOFS`,

[.programlisting]
....
options          GEOM_PART_GPT     # GUID Partition Tables.
....

Добавляет поддержку http://en.wikipedia.org/wiki/GUID_Partition_Table[Таблиц Разделов GUID]. Этот параметр делает возможным наличие большого количества разделов на одном диске, до 128 в стандартной конфигурации.

[.programlisting]
....
options          COMPAT_43         # Compatible with BSD 4.3 [KEEP THIS!]
....

Совместимость с 4.3BSD. Не выключайте эту опцию; некоторые приложения будут вести себя странно, если этой опции не будет в ядре.

[.programlisting]
....
options          COMPAT_FREEBSD4   # Compatible with FreeBSD4
....

Эта опция требуется для поддержки приложений, собранных на более старых версиях FreeBSD, которые используют старые интерфейсы вызовов. Рекомендуется использовать данную опцию на всех системах на платформах i386(TM), на которых могут запускаться старые приложения; платформы, поддержка которых появилась только в FreeBSD 5.X, например ia64 и sparc64, не требуют этой опции.

[.programlisting]
....
options          COMPAT_FREEBSD5   # Compatible with FreeBSD5
....

Эта опция необходима для поддержки приложений, скомпилированных на FreeBSD 5.X и использующих интерфейс системных вызовов FreeBSD 5.X.

[.programlisting]
....
options          COMPAT_FREEBSD6   # Compatible with FreeBSD6
....

Эта опция требуется для поддержки приложений, собранных на FreeBSD версий 6.X, которые используют интерфейсы системных вызовов FreeBSD 6.X.

[.programlisting]
....
options          COMPAT_FREEBSD7   # Compatible with FreeBSD7
....

Эта опция требуется на системах FreeBSD версий 8 и более поздних для поддержки приложений, собранных для FreeBSD 7.X и использующих интерфейсы системных вызовов FreeBSD 7.X.

[.programlisting]
....
options          SCSI_DELAY=5000  # Delay (in ms) before probing SCSI
....

Этот параметр заставляет ядро приостановиться на 5 секунд перед тем, как идентифицировать каждое устройство SCSI в вашей системе. Если у вас установлены только жесткие диски IDE, вы можете игнорировать эту опцию, в противном случае, возможно, вы захотите уменьшить это число, для того чтобы ускорить загрузку. Естественно, если вы сделаете это, а у FreeBSD появятся проблемы с распознанием ваших устройств SCSI, необходимо будет увеличить этот параметр.

[.programlisting]
....
options          KTRACE            # ktrace(1) support
....

Включает поддержку трассировки процессов, что удобно при отладке.

[.programlisting]
....
options          SYSVSHM           # SYSV-style shared memory
....

Этот параметр предоставляет поддержку разделяемой памяти System V. Наиболее распространенное применение этого - расширение XSHM в X, которое многие приложения, интенсивно работающие с графикой, будут автоматически использовать для повышения скорости работы. Если вы используете X, эта опция будет необходима.

[.programlisting]
....
options          SYSVMSG           # SYSV-style message queues
....

Поддержка сообщений System V. Этот параметр добавляет в ядро всего лишь несколько сотен байт.

[.programlisting]
....
options          SYSVSEM           # SYSV-style semaphores
....

Поддержка семафоров System V. Не настолько часто используемая возможность, но в ядро добавляет всего несколько сотен байт.

[NOTE]
====
Команда man:ipcs[1] с параметром `-p` покажет все процессы, которые используют любую из этих возможностей System V.
====

[.programlisting]
....
options 	     _KPOSIX_PRIORITY_SCHEDULING # POSIX P1003_1B real-time extensions
....

Расширения реального времени, добавленные 1993 POSIX(R). Определенные приложения из коллекции используют их, например StarOffice(TM).

[.programlisting]
....
options          KBD_INSTALL_CDEV  # install a CDEV entry in /dev
....

Этот параметр разрешает формирование файлов устройств в [.filename]#/dev# для клавиатур.

[.programlisting]
....
options          ADAPTIVE_GIANT    # Giant mutex is adaptive.
....

Giant - имя механизма защиты ("спящего" мьютекса) для крупных наборов ресурсов ядра. На нынешний момент Giant представляется фактически непригодным для использования в связи с серьезными потерями в производительности, и активно заменяется на механизмы, защищающие отдельные ресурсы ядра. Параметр `ADAPTIVE_GIANT` включает Giant в число адаптивных мьютексов: в случае, когда нить ядра нуждается в Giant, а он уже захвачен нитью, выполняющейся на другом процессоре, первая нить будет продолжать выполнение и ждать освобождения Giant. В норме нить должна была бы уснуть, пока не настанет очередной момент ее выполнения. Если вы не уверены, оставьте этот параметр в покое.

[NOTE]
====
Для FreeBSD 8.0-RELEASE и более поздних версий, все мьютексы являются адаптивными по умолчанию, если обратное не указано специально опцией `NO_ADAPTIVE_MUTEXES`. Следовательно, Giant также адаптивен по умолчанию, и поэтому опция `ADAPTIVE_GIANT` была удалена из файла конфигурации ядра.
====

[.programlisting]
....
device          apic               # I/O APIC
....

Устройство apic разрешает использование набора I/O APIC для распределения прерываний. Оно может быть использовано как с однопроцессорными, так и с многопроцессорными ядрами (для последних наличие apic является обязательным). Для поддержки многопроцессорности добавьте строку `options SMP`.

[NOTE]
====
Устройство apic существует только на архитектурах i386. На других архитектурах этот конфигурационный параметр использовать не следует.
====

[.programlisting]
....
device          eisa
....

Включите эту опцию если у вас материнская плата EISA. Это включает автоопределение и конфигурирование поддержки всех устройств на шине EISA.

[.programlisting]
....
device          pci
....

Включите этот параметр, если у вас материнская плата с поддержкой PCI. Это включит автоопределение карт PCI и проксирование из шины PCI в шину ISA.

[.programlisting]
....
# Floppy drives
device          fdc
....

Контроллер флоппи-диска.

[.programlisting]
....
# ATA and ATAPI devices
device          ata
....

Этот драйвер поддерживает все устройства ATA и ATAPI. Вам необходима только одна строка `device ata` в ядре для того, чтобы обнаружить все PCI устройства ATA/ATAPI в современных машинах.

[.programlisting]
....
device          atadisk                 # ATA disk drives
....

Эта строка необходима вместе с `device ata` для поддержки дисков ATA.

[.programlisting]
....
device          ataraid                 # ATA RAID drives
....

Эта строка необходима вместе с `device ata` для поддержки дисков ATA RAID.

[.programlisting]
....

device          atapicd                 # ATAPI CDROM drives
....

Поддержка приводов ATAPI CDROM. Используется вместе с `device ata`.

[.programlisting]
....
device          atapifd                 # ATAPI floppy drives
....

Поддержка флоппи-приводов ATAPI. Используется вместе с `device ata`.

[.programlisting]
....
device          atapist                 # ATAPI tape drives
....

Поддержка ленточных приводов ATAPI (стримеров). Используется вместе с `device ata`.

[.programlisting]
....
options         ATA_STATIC_ID           # Static device numbering
....

Заставляет драйвер нумеровать устройства статически; в противном случае происходит динамическая нумерация.

[.programlisting]
....
# SCSI Controllers
device          ahb        # EISA AHA1742 family
device          ahc        # AHA2940 and onboard AIC7xxx devices
options         AHC_REG_PRETTY_PRINT    # Print register bitfields in debug
                                        # output.  Adds ~128k to driver.
device          ahd        # AHA39320/29320 and onboard AIC79xx devices
options         AHD_REG_PRETTY_PRINT    # Print register bitfields in debug
                                        # output.  Adds ~215k to driver.
device          amd        # AMD 53C974 (Teckram DC-390(T))
device          isp        # Qlogic family
#device         ispfw      # Firmware for QLogic HBAs- normally a module
device          mpt        # LSI-Logic MPT-Fusion
#device         ncr        # NCR/Symbios Logic
device          sym        # NCR/Symbios Logic (newer chipsets + those of `ncr')
device          trm        # Tekram DC395U/UW/F DC315U adapters

device          adv        # Advansys SCSI adapters
device          adw        # Advansys wide SCSI adapters
device          aha        # Adaptec 154x SCSI adapters
device          aic        # Adaptec 15[012]x SCSI adapters, AIC-6[23]60.
device          bt         # Buslogic/Mylex MultiMaster SCSI adapters

device          ncv        # NCR 53C500
device          nsp        # Workbit Ninja SCSI-3
device          stg        # TMC 18C30/18C50
....

Контроллеры SCSI. Закомментируйте те, которых у вас в системе нет. Если у вас в системе исключительно IDE устройства, вы можете удалить все эти строки. Строки вида `*_REG_PRETTY_PRINT` включают режим отладки для соответствующих драйверов.

[.programlisting]
....
# SCSI peripherals
device          scbus      # SCSI bus (required for SCSI)
device          ch         # SCSI media changers
device          da         # Direct Access (disks)
device          sa         # Sequential Access (tape etc)
device          cd         # CD
device          pass       # Passthrough device (direct SCSI access)
device          ses        # SCSI Environmental Services (and SAF-TE)
....

Периферийные устройства SCSI. Опять-таки, закомментируйте те, которых у вас в системе нет, или, если у вас в наличии исключительно IDE, можете удалить все.

[NOTE]
====
USB man:umass[4] драйвер (и некоторые другие драйверы) используют подсистему SCSI, хотя и не являются настоящими SCSI устройствами. Следовательно, вам необходимо сохранить поддержку SCSI, если какой-либо из этих драйверов включен в конфигурацию ядра.
====

[.programlisting]
....
# RAID controllers interfaced to the SCSI subsystem
device          amr        # AMI MegaRAID
device		arcmsr	   # Areca SATA II RAID
device          asr        # DPT SmartRAID V, VI and Adaptec SCSI RAID
device          ciss       # Compaq Smart RAID 5*
device          dpt        # DPT Smartcache III, IV - See NOTES for options
device          hptmv      # Highpoint RocketRAID 182x
device          hptrr      # Highpoint RocketRAID 17xx, 22xx, 23xx, 25xx
device          iir        # Intel Integrated RAID
device          ips        # IBM (Adaptec) ServeRAID
device          mly        # Mylex AcceleRAID/eXtremeRAID
device          twa        # 3ware 9000 series PATA/SATA RAID

# RAID controllers
device          aac        # Adaptec FSA RAID
device          aacp       # SCSI passthrough for aac (requires CAM)
device          ida        # Compaq Smart RAID
device          mfi        # LSI MegaRAID SAS
device          mlx        # Mylex DAC960 family
device          pst        # Promise Supertrak SX6000
device          twe        # 3ware ATA RAID
....

Поддерживаемые RAID-контроллеры. Если у вас нет таковых, можете их закомментировать или удалить эти строки.

[.programlisting]
....
# atkbdc0 controls both the keyboard and the PS/2 mouse
device          atkbdc     # AT keyboard controller
....

Контроллер клавиатуры (`atkbdc`) предоставляет средства ввода/вывода для клавиатуры AT и PS/2 устройств. Этот контроллер необходим драйверу клавиатуры (`atkbd`) и PS/2 устройств (`psm`).

[.programlisting]
....
device          atkbd      # AT keyboard
....

Драйвер `atkbd` вместе с контроллером `atkbdc` предоставляет доступ к клавиатуре AT 84 или улучшенной клавиатуре AT, которая подключена к контроллеру AT клавиатуры.

[.programlisting]
....
device          psm        # PS/2 mouse
....

Используйте это устройство, если ваша мышь включается в порт PS/2.

[.programlisting]
....
device          kbdmux        # keyboard multiplexer
....

Поддержка мультиплексора клавиатур. Если использование двух и более клавиатур не планируется, можете смело исключать этот параметр.

[.programlisting]
....
device          vga        # VGA video card driver
....

Драйвер видеокарты.

[.programlisting]
....

device          splash     # Splash screen and screen saver support
....

Заставка при загрузке. Хранители экрана также требуют этого устройства.

[.programlisting]
....
# syscons is the default console driver, resembling an SCO console
device          sc
....

`sc` - это драйвер консоли по умолчанию, который имитирует консоль SCO. Так как большая часть консольных полноэкранных приложений обращаются к консоли через терминальную библиотеку [.filename]#termcap#, вас не должно волновать, будете ли вы использовать этот драйвер, либо драйвер `vt`, который является `VT220`-совместимым драйвером консоли. Если у вас возникнут какие-либо проблемы с приложениями, работающими с этим драйвером консоли, установите переменную окружения `TERM` в значение `scoansi`.

[.programlisting]
....
# Enable this for the pcvt (VT220 compatible) console driver
#device          vt
#options         XSERVER          # support for X server on a vt console
#options         FAT_CURSOR       # start with block cursor
....

VT220-совместимый драйвер консоли, обратно совместимый с VT100/102. Он работает лучше на некоторых лэптопах, у которых возникают проблемы несовместимости с `sc`. Также, установите переменную окружения `TERM` в значение `vt100` или `vt220`. Этот драйвер также может быть полезен в случаях подключения к большому количеству различных машин через сеть, на которых параметры для устройства `sc` для [.filename]#termcap# или [.filename]#terminfo# могут отсутствовать - `vt100` присутствует практически на любой платформе.

[.programlisting]
....
device          agp
....

Включите эту опцию, если у вас есть AGP карта в системе. Это включит поддержку AGP и AGP GART для тех карт, которые поддерживают эту возможность.

[.programlisting]
....
# Power management support (see NOTES for more options)
#device          apm
....

Поддержка Advanced Power Management. Чаще всего используется в лэптопах, хотя и отключена по умолчанию.

[.programlisting]
....
# Add suspend/resume support for the i8254.
device           pmtimer
....

Устройство таймера для управления энергопотреблением, APM и ACPI.

[.programlisting]
....
# PCCARD (PCMCIA) support
# PCMCIA and cardbus bridge support
device          cbb               # cardbus (yenta) bridge
device          pccard            # PC Card (16-bit) bus
device          cardbus           # CardBus (32-bit) bus
....

Поддержка PCMCIA. Включите ее, если вы используете лэптоп.

[.programlisting]
....
# Serial (COM) ports
device          sio               # 8250, 16[45]50 based serial ports
....

Четыре последовательных порта, которые известны как [.filename]#COM# порты в мире MS-DOS(R)/Windows(R)

[NOTE]
====
Если у вас есть внутренний модем на [.filename]#COM4# и последовательный порт [.filename]#COM2#, вам понадобится поменять IRQ модема на 2 (по непонятным техническим причинам IRQ2 = IRQ9) для того, чтобы получить к нему доступ из FreeBSD. Если у вас есть многопортовая карта с последовательными портами, ознакомьтесь с man:sio[4] чтобы узнать корректные значения для добавления в [.filename]#/boot/device.hints#. Некоторые видеокарты (в частности те, что используют чипы S3) используют адреса ввода/вывода в форме `0x*2e8` и, так как многие дешевые последовательные карты не полностью раскодируют шестнадцатибитное пространство адресов ввода/вывода, они конфликтуют с этими картами, в итоге [.filename]#COM4# оказывается практически недоступным.

Каждый последовательный порт требует уникального IRQ (кроме тех случаев, когда вы используете мультипортовую карту, которая поддерживает совместное использование прерываний), поэтому значения IRQ по умолчанию для [.filename]#COM3# и [.filename]#COM4# не могут быть использованы.
====

[.programlisting]
....
# Parallel port
device          ppc
....

Интерфейс параллельного порта на шине ISA.

[.programlisting]
....
device          ppbus      # Parallel port bus (required)
....

Поддержка шины параллельного порта.

[.programlisting]
....
device          lpt        # Printer
....

Поддержка принтеров на параллельном порту.

[NOTE]
====
Все три последних устройства необходимы для поддержка принтеров на параллельном порту.
====

[.programlisting]
....
device          plip       # TCP/IP over parallel
....

Драйвер TCP/IP через параллельный порт.

[.programlisting]
....
device          ppi        # Parallel port interface device
....

Поддержка ввода/вывода общего назначения ("geek port") + IEEE1284 ввода/вывода.

[.programlisting]
....
#device         vpo        # Requires scbus and da
....

Драйвер привода Iomega Zip. Требует наличия `scbus` и `da`. Наилучшая производительность достигается с портами в режиме EPP 1.9.

[.programlisting]
....
#device         puc
....

Раскомментируйте это устройство, если у вас есть "простая" последовательная или параллельная PCI карта, поддерживаемая драйвером man:puc[4].

[.programlisting]
....
# PCI Ethernet NICs.
device          de         # DEC/Intel DC21x4x (Tulip)
device          em         # Intel PRO/1000 adapter Gigabit Ethernet Card
device          ixgb       # Intel PRO/10GbE Ethernet Card
device          txp        # 3Com 3cR990 (Typhoon)
device          vx         # 3Com 3c590, 3c595 (Vortex)
....

Драйвера сетевых карт PCI. Закомментируйте или удалите драйвера тех карт, которые отсутствуют в вашей системе.

[.programlisting]
....
# PCI Ethernet NICs that use the common MII bus controller code.
# NOTE: Be sure to keep the 'device miibus' line in order to use these NICs!
device          miibus     # MII bus support
....

Поддержка шины MII требуется для некоторых PCI 10/100 Ethernet карт, которые используют MII-совместимые передатчики или реализуют интерфейс управления передатчиком, который имитирует MII. Добавление `device miibus` в конфигурационный файл ядра включает поддержку стандартного API miibus и всех драйверов PHY, включая стандартный для тех PHY, которые не обрабатываются специфическим образом конкретным драйвером.

[.programlisting]
....
device          bfe        # Broadcom BCM440x 10/100 Ethernet
device          bge        # Broadcom BCM570xx Gigabit Ethernet
device          dc         # DEC/Intel 21143 and various workalikes
device          fxp        # Intel EtherExpress PRO/100B (82557, 82558)
device		lge	   # Level 1 LXT1001 gigabit ethernet
device          msk        # Marvell/SysKonnect Yukon II Gigabit Ethernet
device		nge	   # NatSemi DP83820 gigabit ethernet
device          pcn        # AMD Am79C97x PCI 10/100 (precedence over 'lnc')
device          re         # RealTek 8139C+/8169/8169S/8110S
device          rl         # RealTek 8129/8139
device          sf         # Adaptec AIC-6915 (Starfire)
device          sis        # Silicon Integrated Systems SiS 900/SiS 7016
device          sk         # SysKonnect SK-984x > SK-982x gigabit Ethernet
device          ste        # Sundance ST201 (D-Link DFE-550TX)
device          stge       # Sundance/Tamarack TC9021 gigabit Ethernet
device          ti         # Alteon Networks Tigon I/II gigabit Ethernet
device          tl         # Texas Instruments ThunderLAN
device          tx         # SMC EtherPower II (83c170 EPIC)
device		vge	   # VIA VT612x gigabit ethernet
device          vr         # VIA Rhine, Rhine II
device          wb         # Winbond W89C840F
device          xl         # 3Com 3c90x (Boomerang, Cyclone)
....

Драйвера, которые используют контроллер шины MII.

[.programlisting]
....
# ISA Ethernet NICs.  pccard NICs included.
device          cs         # Crystal Semiconductor CS89x0 NIC
# 'device ed' requires 'device miibus'
device          ed         # NE[12]000, SMC Ultra, 3c503, DS8390 cards
device          ex         # Intel EtherExpress Pro/10 and Pro/10+
device          ep         # Etherlink III based cards
device          fe         # Fujitsu MB8696x based cards
device          ie         # EtherExpress 8/16, 3C507, StarLAN 10 etc.
device          lnc        # NE2100, NE32-VL Lance Ethernet cards
device          sn         # SMC's 9000 series of Ethernet chips
device          xe         # Xircom pccard Ethernet

# ISA devices that use the old ISA shims
#device         le
....

Драйвера сетевых карт ISA. Ознакомьтесь с файлом [.filename]#/usr/src/sys/i386/conf/NOTES#, чтобы узнать, какие сетевые карты каким драйвером поддерживаются.

[.programlisting]
....
# Wireless NIC cards
device          wlan            # 802.11 support
....

Generic 802.11 support. This line is required for wireless networking.

[.programlisting]
....
device          wlan_wep        # 802.11 WEP support
device          wlan_ccmp       # 802.11 CCMP support
device          wlan_tkip       # 802.11 TKIP support
....

Crypto support for 802.11 devices. These lines are needed if you intend to use encryption and 802.11i security protocols.

[.programlisting]
....
device          an         # Aironet 4500/4800 802.11 wireless NICs.
device          ath             # Atheros pci/cardbus NIC's
device          ath_hal         # Atheros HAL (Hardware Access Layer)
device          ath_rate_sample # SampleRate tx rate control for ath
device          awi        # BayStack 660 and others
device          wi         # WaveLAN/Intersil/Symbol 802.11 wireless NICs.
#device         wl         # Older non 802.11 Wavelan wireless NIC.
....

Поддержка различных беспроводных карт.

[.programlisting]
....
# Pseudo devices
device   loop          # Network loopback
....

Стандартное устройство обратной связи для TCP/IP. Если вы запускаете telnet или FTP по отношению `localhost` (он же `127.0.0.1`), то соединение пройдёт через это устройство. Этот параметр _обязателен_.

[.programlisting]
....
device   random        # Entropy device
....

Генератор случайных чисел для криптографической защиты.

[.programlisting]
....
device   ether         # Ethernet support
....

`ether` необходим лишь в случае, если у вас есть сетевая карта. Он включает поддержку стандартного кода протокола Ethernet.

[.programlisting]
....
device   sl            # Kernel SLIP
....

`sl` - это поддержка SLIP. SLIP был практически вытеснен PPP, который легче настраивается, лучше подходит для соединений модем-модем и имеет больше возможностей.

[.programlisting]
....
device   ppp           # Kernel PPP
....

Поддержка PPP в ядре для соединений dial-up. Также существует версия PPP, реализованного как приложение, использующее `tun`, и предлагающее большую гибкость и большее количество возможностей, как, например, соединение при необходимости (наличии обращения к сети).

[.programlisting]
....
device   tun           # Packet tunnel.
....

Используется пользовательским программным обеспечением PPP. Обратитесь к разделу crossref:ppp-and-slip[userppp,PPP] этой книги за дальнейшей информацией.

[.programlisting]
....

device   pty           # Pseudo-ttys (telnet etc)
....

"псевдо-терминал" или имитированный порт для входа. Используется входящими `telnet` и `rlogin`-сессиями, приложением xterm и некоторыми другими приложениями, такими как Emacs.

[.programlisting]
....
device   md            # Memory disks
....

Псевдо-устройства дисков в памяти.

[.programlisting]
....
device   gif           # IPv6 and IPv4 tunneling
....

Поддержка туннелирования IPv6 через IPv4, IPv4 через IPv6, IPv4 через IPv4 и IPv6 через IPv6. Устройство `gif` является "автоклонируемым", и будет срздавать файлы устройств по мере необходимости.

[.programlisting]
....
device   faith         # IPv6-to-IPv4 relaying (translation)
....

Это псевдо-устройство захватывает пакеты, которые были посланы ему и перенаправляет их даемону трансляции IPv4/IPv6.

[.programlisting]
....
# The `bpf' device enables the Berkeley Packet Filter.
# Be aware of the administrative consequences of enabling this!
# Note that 'bpf' is required for DHCP.
device   bpf           # Berkeley packet filter
....

Фильтр пакетов Berkeley. Это псевдо-устройство позволяет переводить сетевые интерфейсы в "неразборчивый" (promiscuous) режим, в котором перехватывается любой пакет в широковещательной сети (например ethernet). Эти пакеты могут быть сохранены на диск и/или исследованы при помощи man:tcpdump[1].

[NOTE]
====
Устройство man:bpf[4] также используется программой man:dhclient[8] для того, чтобы получить адрес шлюза по умолчанию и т.п. Если вы используете DCHP, не удаляйте эту опцию.
====

[.programlisting]
....
# USB support
device          uhci          # UHCI PCI->USB interface
device          ohci          # OHCI PCI->USB interface
device		ehci	      # EHCI PCI->USB interface (USB 2.0)
device          usb           # USB Bus (required)
#device         udbp          # USB Double Bulk Pipe devices
device          ugen          # Generic
device          uhid          # Human Interface Devices
device          ukbd          # Keyboard
device          ulpt          # Printer
device          umass         # Disks/Mass storage - Requires scbus and da
device          ums           # Mouse
device          ural          # Ralink Technology RT2500USB wireless NICs
device          urio          # Diamond Rio 500 MP3 player
device          uscanner      # Scanners
# USB Ethernet, requires mii
device          aue           # ADMtek USB Ethernet
device          axe           # ASIX Electronics USB Ethernet
device		cdce	      # Generic USB over Ethernet
device          cue           # CATC USB Ethernet
device          kue           # Kawasaki LSI USB Ethernet
device          rue           # RealTek RTL8150 USB Ethernet
....

Поддержка различных USB устройств.

[.programlisting]
....
# FireWire support
device          firewire      # FireWire bus code
device          sbp           # SCSI over FireWire (Requires scbus and da)
device          fwe           # Ethernet over FireWire (non-standard!)
....

Поддержка различных устройств Firewire.

За дальнейшей информацией о дополнительных устройствах, поддерживаемых FreeBSD, обратитесь к файлу [.filename]#/usr/src/sys/i386/conf/NOTES#.

=== Конфигурации с большим количеством оперативной памяти (PAE)

Машины с большим количеством оперативной памяти, в которых требуется более 4 гигабайт в пользовательском адресном пространстве и адресном пространстве ядра (User+Kernel Virtual Address, KVA) в обычном случае не смогут использовать более 4 гигабайт. Для решения этой проблемы Intel добавили поддержку 36-битной адресации в Pentium(R) Pro и более поздних моделях процессоров.

Расширение физического адресного пространства (PAE) в процессорах Intel(R) Pentium(R) Pro и более поздних позволяет использовать до 64 гигабайт оперативной памяти. FreeBSD имеет поддержку этой возможности посредством опции ядра `PAE`, доступной во всех текущих версиях FreeBSD. В связи с ограничениями архитектуры Intel, не делается никакого различия между памятью ниже или выше 4 гигабайт. Память, размещенная выше 4 гигабайт, просто добавляется к доступной памяти.

Для того, чтобы включить PAE в ядре, просто добавьте приведенную строку в конфигурационный файл ядра:

[.programlisting]
....
options            PAE
....

[NOTE]
====
Поддержка PAE в FreeBSD существует только для процессоров Intel(R) IA-32. Также следует заметить, что PAE в FreeBSD не было полностью протестировано и должно считаться находящимся в состоянии бета-тестирования по сравнению с другими, стабильными возможностями FreeBSD.
====

Поддержка PAE в FreeBSD имеет следующие ограничения:

* Процесс не может получить доступ к более, чем 4 гигабайтам пространства VM.
* Драйверы устройств, которые не используют интерфейс man:bus_dma[9], приведут к повреждению информации в ядре с включенным PAE. Не рекомендуется использовать такие драйверы. По этой причине в FreeBSD включен конфигурационный файл ядра [.filename]#PAE#, из которого удалены все драйверы, о которых известно, что они не работают при включенной поддержке PAE.
* Некоторые системные переменные определяют использование ресурсов памяти по количеству доступной физической памяти. Такие переменные могут привести к ненужному чрезмерному выделению памяти из-за особенностей работы системы PAE. Один из таких примеров - переменная `kern.maxvnodes`, которая управляет максимальным количеством vnode, разрешенных в ядре. Рекомендуется установить эту и подобные ей переменные вручную в адекватные значения.
* Возможно, понадобится увеличить пространство виртуальных адресов ядра (KVA) или уменьшить какую-либо переменную (см. выше), значение которой было неоправданно велико и могло привести к исчерпанию KVA. Для этого может быть использована опция ядра `KVA_PAGES`.

В случае сомнений относительно производительности и стабильности рекомендуется обратиться к странице руководства man:tuning[7]. Страница руководства man:pae[4] содержит свежую информацию о поддержке PAE в FreeBSD.

[[kernelconfig-trouble]]
== Решение проблем

Существует четыре категории проблем, которые могут возникнуть при сборке собственного ядра. Вот они:

Не удаётся отработать команде `config`:::
Если команда man:config[8] не может отработать, то, скорее всего, вы допустили где-нибудь маленькую ошибку. К счастью, man:config[8] выведет номер проблемной строки, поэтому вы можете быстро найти строку, содержащую ошибку. Например, если вы видите:
+
[source,bash]
....
config: line 17: syntax error
....
+
Убедитесь, что опция введена верно путём сравнения с файлом [.filename]#GENERIC# или другим источником.

Не удаётся отработать команде `make`:::
Если не удаётся отработать команде `make`, обычно это означает ошибку в описании конфигурации ядра, которая не достаточно тривиальна для того, чтобы man:config[8] мог обнаружить её. Опять-таки, просмотрите файл конфигурации, и, если вы все еще не можете решить проблему, напишите письмо в {freebsd-questions}, включив в письмо файл конфигурации ядра. Скорее всего проблема будет решена быстро.

Ядро не загружается:[[kernelconfig-noboot]]::
Если ваше новое ядро не загружается или ему не удаётся обнаружить ваши устройства - не паникуйте! К счастью, в FreeBSD существует отличный механизм для восстановления после установки несовместимого ядра. Просто выберите ядро, которое хотите загрузить, в загрузчике FreeBSD. Доступ к нему вы можете получить, когда система находится в стартовом меню. Выберите шестой пункт ("Escape to a loader prompt"), введите команду `boot _kernel.old_`, или используйте любое другое ядро, которое загрузится без проблем. Во время переконфигурирования ядра всегда полезно оставлять копию ядра, о котором известно, что оно рабочее.
+
После загрузки с рабочим ядром вы можете проверить ваш файл конфигурации и попробовать собрать ядро опять. Очень полезным в данном случае окажется файл [.filename]#/var/log/messages#, в котором, среди других записей, имеются сообщения ядра от каждой успешной загрузки. Также, команда man:dmesg[8] выведет сообщения ядра от текущей загрузки.
+
[NOTE]
====
Если у вас возникли проблемы со сборкой ядра, убедитесь, что вы сохранили ядро [.filename]#GENERIC# или другое рабочее ядро под другим именем, чтобы оно не было удалено при следующей сборке. Вы не можете использовать [.filename]#kernel.old#, потому что при установке нового ядра [.filename]#kernel.old# перезаписывается последним установленным ядром, которое может оказаться нерабочим. Также, как можно скорее переместите рабочее ядро в [.filename]#/boot/kernel#, так как некоторые команды, такие как man:ps[1] будут работать некорректно. Для этого просто переместите каталог, содержащий работоспособное ядро:

[source,bash]
....
# mv /boot/kernel /boot/kernel.bad
# mv /boot/kernel.good /boot/kernel
....

====

Ядро работает, но man:ps[1] больше не работает:::
Если вы установили версию ядра отличную от той, с которой были собраны ваши системные утилиты, например, ядро от -CURRENT на системе -RELEASE, большая часть системных команд, таких как man:ps[1] и man:vmstat[8] не будут больше работать. Вам потребуется crossref:cutting-edge[makeworld,перекомпилировать и установить систему] той же версии исходных текстов, что и ядро. Это одна из причин, по которой не следует использовать версию ядра, отличную от версии всей остальной системы.
