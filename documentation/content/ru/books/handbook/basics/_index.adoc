---
title: Глава 4. Основы UNIX
part: Часть I. В начале
prev: books/handbook/bsdinstall
next: books/handbook/ports
---

[[basics]]
= Основы UNIX
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:source-highlighter: rouge
:experimental:
:skip-front-matter:
:toc-title: Содержание
:table-caption: Таблица
:figure-caption: Рисунок
:example-caption: Пример
:xrefstyle: basic
:relfileprefix: ../
:outfilesuffix:
:sectnumoffset: 4

ifeval::["{backend}" == "html5"]
:imagesdir: ../../../../images/books/handbook/basics/
endif::[]

ifeval::["{backend}" == "pdf"]
:imagesdir: ../../../../static/images/books/handbook/basics/
endif::[]

ifeval::["{backend}" == "epub3"]
:imagesdir: ../../../../static/images/books/handbook/basics/
endif::[]

include::shared/authors.adoc[]
include::shared/releases.adoc[]
include::shared/ru/mailing-lists.adoc[]
include::shared/ru/teams.adoc[]
include::shared/ru/urls.adoc[]

toc::[]

[[basics-synopsis]]
== Краткий обзор

В этой главе мы попытаемcя раскрыть основные принципы и команды операционной системы FreeBSD. Большая часть нижеизложенного материала в более или менее равной степени применима к любой UNIX(R)-подобной операционной системе. Если вы уверены, что не найдете здесь ничего нового для себя, можете смело пропустить эту главу. Если же вы новичок, мы настоятельно рекомендуем внимательно прочесть это главу.

Прочитав эту главу, вы узнаете:

* Как использовать "виртуальные консоли" FreeBSD.
* Как работают права доступа на файлы в UNIX(R) и как следует интерпретировать флаги файлов в ОС FreeBSD.
* Иерархия каталогов FreeBSD.
* Организация дисков FreeBSD.
* Как монтировать и размонтировать файловые системы.
* Что такое процессы, даемоны и сигналы.
* Что такое командная оболочка (или интерпретатор команд) и как настроить личное рабочее окружение.
* Как пользоваться стандартными текстовыми редакторами.
* Что такое устройства и файлы устройств.
* Какие бинарные форматы используются в FreeBSD.
* Как пользоваться справочным руководством для получения дополнительной информации.

[[consoles]]
== Виртуальные консоли и терминалы

FreeBSD можно использовать разными способами. Один из них - набор команд в текстовом терминале. Используйте этот способ, и вся гибкость и мощь систем UNIX(R) будет в ваших руках. Этот раздел рассказывает о "терминалах", "консолях" и их использовании в FreeBSD.

[[consoles-intro]]
=== Консоль

Если во время установки вы не настроили FreeBSD для автоматического запуска графической среды при загрузке, система запросит ввод логина сразу после завершения стартовых скриптов. Вы увидите примерно следующее:

[source,bash]
....
Additional ABI support:.
Local package initialization:.
Additional TCP options:.

Fri Sep 20 13:01:06 EEST 2002

FreeBSD/i386 (pc3.example.org) (ttyv0)

login:
....

В вашей системе сообщение может быть другим, но очень похожим на это. В данный момент нас интересуют последние две строки. Вторая с конца строка:

[.programlisting]
....
FreeBSD/i386 (pc3.example.org) (ttyv0)
....

В этой строке содержится немного информации о только что загруженной системе. Это консоль "FreeBSD", работающей на Intel или совместимом процессоре x86 архитектуры. Имя этого компьютера (у каждого компьютера UNIX(R) есть имя) `pc3.example.org`, и в данный момент вы видите системную консоль - терминал [.filename]#ttyv0#.

Наконец, последняя строка всегда:

[.programlisting]
....
login:
....

Здесь вам предлагается ввести "имя пользователя", чтобы войти в FreeBSD. Следующий раздел описывает способ, которым вы можете сделать это.

[[consoles-login]]
=== Вход в FreeBSD

FreeBSD это многопользовательская, многопроцессорная система. Это формальное описание системы, которая может быть использована множеством разных людей, одновременно запускающих большое количество программ на одном компьютере.

Любой многопользовательской системе нужен способ отличать каждого "пользователя" от остальных. В FreeBSD (и всех UNIX(R)-подобных операционных системах), эта задача решается путем "входа" пользователя в систему перед запуском каких-либо программ. У каждого пользователя есть уникальное имя ("имя пользователя") и персональный, секретный ключ ("пароль"). Перед тем, как разрешить пользователю выполнять какие-либо программы, FreeBSD запрашивает их оба.

Сразу после загрузки FreeBSD и завершения работы стартовых скриптов, система предложит вам ввести имя пользователя:

[source,bash]
....
login:
....

В этом примере, предположим что ваше имя пользователя `john`. Введите `john` в этом приглашении и нажмите kbd:[Enter]. Далее должно появиться приглашение ввести "пароль":

[source,bash]
....
login: john
Password:
....

Введите соответствующий имени `john` пароль и нажмите kbd:[Enter]. Пароль _не виден_! Не беспокойтесь об этом. Это сделано по соображениям безопасности.

Если вы ввели пароль правильно, то сразу же войдете в FreeBSD и можете начать выполнять команды.

Вы увидите сообщение дня (MOTD, или message of the day) за которым последует командная строка (с символом `#`, `$`, или `%`). Это означает, что вы успешно вошли в FreeBSD.

[[consoles-virtual]]
=== Множественные консоли

Запуск команд UNIX(R) из консоли - это конечно хорошо, но FreeBSD может выполнять множество программ одновременно, поэтому наличие одной консоли может быть недостатком. В таком случае очень полезны "виртуальные консоли".

FreeBSD может быть настроена для работы с несколькими виртуальными консолями. Вы можете переключаться с одной виртуальной консоли на другую, нажимая соответствующие сочетания клавиш на клавиатуре. У каждой консоли есть свой канал вывода и FreeBSD заботится о том, чтобы правильно перенаправить ввод с клавиатуры и вывод на монитор, как только вы переключитесь с одной консоли на другую.

Для переключения между консолями зарезервированы специальные комбинации клавиш. Вы можете использовать сочетания kbd:[Alt+F1], kbd:[Alt+F2], до kbd:[Alt+F8] чтобы переключаться между различными виртуальными консолями в FreeBSD.

При переключении от одной консоли к другой, FreeBSD заботится о сохранении и восстановлении вывода на экран. Результатом является "иллюзия" наличия множества "виртуальных" экранов и клавиатур, которые могут быть использованы для ввода и запуска команд FreeBSD. Программы, которые вы запускаете на одной виртуальной консоли, не прекращают выполнение, когда консоль становится невидимой. Они продолжают выполняться, когда вы переключаетесь на другую виртуальную консоль.

[[consoles-ttys]]
=== Файл [.filename]#/etc/ttys#

В конфигурации по умолчанию FreeBSD запускает восемь виртуальных консолей. Тем не менее, это не ограничение оборудования, и вы можете легко настроить систему для загрузки большего или меньшего числа виртуальных консолей. Число и параметры виртуальных консолей задаются в файле [.filename]#/etc/ttys#.

Вы можете использовать это файл для настройки виртуальных консолей FreeBSD. Любая не закомментированная строка в этом файле (строка, не начинающаяся с символа `#`), содержит настройки для одного терминала или виртуальной консоли. Версия этого файла по умолчанию, поставляемая с FreeBSD, содержит настройки для девяти виртуальных консолей и включает восемь терминалов. Это строки, начинающиеся с `ttyv`:

[.programlisting]
....
# name  getty                           type    status          comments
#
ttyv0   "/usr/libexec/getty Pc"         cons25  on  secure
# Virtual terminals
ttyv1   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv2   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv3   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv4   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv5   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv6   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv7   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv8   "/usr/X11R6/bin/xdm -nodaemon"  xterm   off secure
....

За детальным описанием каждой колонки этого файла и всех опций, которые можно указать для настройки виртуальных консолей, обращайтесь к man:ttys[5].

[[consoles-singleuser]]
=== Консоль в однопользовательском режиме

Детальное описание "однопользовательского режима" можно найти в crossref:boot[boot-singleuser,Однопользовательский режим]. Стоит отметить, что при работе FreeBSD в однопользовательском режиме есть только одна консоль. Виртуальных консолей нет. Установки консоли в однопользовательском режиме можно найти в файле [.filename]#/etc/ttys#. Обратите внимание на строку, начинающуюся с `console`:

[.programlisting]
....
# name  getty                           type    status          comments
#
# If console is marked "insecure", then init will ask for the root password
# when going to single-user mode.
console none                            unknown off secure
....

[NOTE]
====
Как сказано в комментариях выше строки `console`, можно отредактировать эту строку и изменить `secure` на `insecure`. Если вы сделаете это, FreeBSD даже при загрузке в однопользовательском режиме будет запрашивать пароль `root`.

__Будьте осторожны при изменении этого значения на ``insecure``__. Если вы забудете пароль `root`, загрузка в однопользовательский режим сильно усложнится. Это все еще возможно, но несколько более сложно для тех, кто еще не очень освоился с процессом загрузки FreeBSD и вызова программ.
====

[[consoles-vidcontrol]]
=== Изменение видеорежимов консоли

Установленный по умолчанию размер изображения для консоли FreeBSD может быть изменен до значения 1024x768, 1280x1024, или любого другого, который поддерживается вашим монитором и видеокартой. Для того, чтобы задействовать иной видеорежим, вам прежде всего необходимо будет пересобрать ядро вашей системы, добавив в файл конфигурации две дополнительные опции:

[.programlisting]
....
options VESA
options SC_PIXEL_MODE
....

После пересборки и установки ядра воспользуйтесь утилитой man:vidcontrol[1] для определения видеорежимов, поддерживаемых вашим оборудованием. Чтобы получить перечень видеорежимов, выполните следующую команду:

[source,bash]
....
# vidcontrol -i mode
....

Команда отобразит список поддерживаемых видеорежимов. Теперь вы можете выбрать один из них и установить его на консоли при помощи man:vidcontrol[1]:

[source,bash]
....
# vidcontrol MODE_279
....

Если новый видеорежим вас устраивает, то его можно определить устанавливаемым автоматически во время старта системы, для чего добавьте в [.filename]#/etc/rc.conf# следующую строку:

[.programlisting]
....
allscreens_flags="MODE_279"
....

[[users-synopsis]]
== Пользователи и основы управления учетными записями

FreeBSD допускает одновременную работу множества пользователей на одном компьютере. В то время, как только один пользователь может сидеть за клавиатурой и перед экраном в один момент времени, любое количество пользователей может войти в систему через сеть. Для использования системы у каждого пользователя должна быть учетная запись.

В этом разделе описаны:

* Разные типы учетных записей в системе FreeBSD.
* Как добавлять, удалять и изменять учетные записи пользователей.
* Как устанавливать ограничения на использование ресурсов для учетных записей или групп учетных записей.
* Как использовать группы для упрощения управлением учетными записями.

[[users-introduction]]
=== Разновидности учетных записей

Так как доступ к системе FreeBSD осуществляется через учетные записи, и все процессы запускаются пользователями, то управление пользователями и учетными записями является важным аспектом администрирования.

Существует три разновидности учетных записей: системные учетные записи, учетные записи пользователей и суперпользователь.

[[users-system]]
==== Системные учетные записи

Системные учетные записи предназначены для запуска сервисов, таких как DNS, почта, веб серверы. Это необходимо по соображениям безопасности; если бы все сервисы работали от суперпользователя, они могли бы действовать без ограничений.

Примеры системных учетных записей: `daemon`, `operator`, `bind`, `news` и `www`.

`nobody` это общепринятая непривилегированная системная учетная запись. Однако, чем больше сервисов используют `nobody`, тем больше файлов и процессов связано с этим пользователем, и следовательно тем больше привилегий появляется у этого пользователя.

[[users-user]]
==== Учетные записи пользователей

Учетные записи пользователей служат для предоставления доступа к системе обычным людям. Каждый человек, имеющий доступ к системе, должен иметь уникальную учетную запись пользователя. Это позволяет администратору выяснять кто что делает и предотвращает сбивание одним пользователем настроек других пользователей.

Каждый пользователь посредством выбора оболочки, редактора, привязок клавиш и настроек языка может настраивать свою собственную рабочую среду для приспособления системы под свои нужды.

С каждой учетной записью в системе FreeBSD связана определенная идентификационная информация:

Имя пользователя::
Имя пользователя вводится в приглашение `login:`. Имена пользователей должны быть уникальны. Существует множество правил для создания допустимых имен пользователей, документированных в man:passwd[5]. Рекомендуется составлять имена пользователей из восьми или меньшего количества символов в нижнем регистре, чтобы поддерживать обратную совместимость с приложениями.

Пароль::
С каждой учетной записью связан пароль.

ID пользователя (User ID, UID)::
Идентификатор пользователя (UID) - это номер, используемый для однозначной идентификации пользователя в системе FreeBSD. Любая команда, принимающая в качестве аргумента имя пользователя, первым делом преобразует его к UID. Рекомендуется выбирать значения UID, не превышающие 65535, так как большие значения могут вызывать проблемы совместимости для некоторых пользовательских программ.

Идентификатор группы (Group ID, GID)::
Идентификатор группы (GID) - это номер, используемый для однозначной идентификации главной группы, к которой принадлежит пользователь. Группы это механизм для контроля доступа к ресурсам на основе GID пользователя вместо его UID. Это может значительно уменьшить размер некоторых файлов настройки. Кроме того, пользователь может быть включен более чем в одну группу. Рекомендуется использовать значения GID, не превышающие 65535, так как большие значения могут стать проблемой для некоторых программ.

Класс доступа (login class)::
Классы доступа это расширение к механизму групп, позволяющее более гибко приспосабливать систему для различных пользователей. Классы доступа описаны в <<users-limiting>>.

Срок действия пароля::
По умолчанию пароли не устаревают. Однако, есть возможность ограничить срок действия текущего пароля пользователя, и тем самым обязать его обновить пароль.

Срок действия учетной записи::
По умолчанию во FreeBSD время действия учетных записей не ограничено. При создании учетных записей ограниченного срока действия, например для студентов в учебном заведении, при помощи man:pw[8] укажите дату истечения действия учетной записи. После наступления указанной даты учетная запись становится непригодной для входа в систему, хотя каталоги и файлы этой учетной записи останутся нетронутыми.

Полное имя пользователя::
Имя пользователя является уникальным идентификатором учетной записи в FreeBSD, однако оно не обязано соответствовать реальному имени пользователя. Это поле может содержать реальное имя пользователя. Здесь допустимы пробелы, символы подчеркивания, строка не ограничена до 8 символов.

Домашний каталог::
Домашний каталог определяется полным путем в системе. С него пользователь начнет работу после входа в систему. По общепринятому соглашению все домашние каталоги пользователей помещаются в [.filename]#/home/username# или [.filename]#/usr/home/username#. Пользователи хранят личные файлы и подкаталоги в своих домашних каталогах.

Оболочка пользователя::
Оболочка необходима пользователям как средство взаимодействия с системой. Существует множество различных видов оболочек, опытные пользователи работают с собственными настройками, которые могут быть отражены в установках их учетных записей.

[[users-superuser]]
==== Учетная запись суперпользователя

Учетная запись суперпользователя, обычно называемая `root`, используется для управления системой без ограничения привилегий. Поэтому она не должна использоваться для повседневных задач, таких как получение и отправка почты, общее исследование системы или программирование.

Суперпользователь, в отличие от обычных пользователей, может работать без ограничений и поэтому неправильное использование учетной записи суперпользователя может привести к полному уничтожению системы. Учетные записи пользователей не способны уничтожить систему вследствие ошибки, поэтому если нет необходимости в привилегиях суперпользователя, то лучше использовать учетные записи обычных пользователей везде, где это возможно.

Всегда перепроверяйте и переперепроверяйте команды, выполняемые под учетной записью суперпользователя, поскольку даже один лишний пробел или отсутствующий символ может привести к безвозвратной потере данных.

Есть несколько способов получения привилегий суперпользователя. Наименее удобный способ - войти в систему под учетной записью `root`.

Вместо этого можно воспользоваться man:su[1]. Если при запуске этой команды указывается ключ `-`, пользователь получит настройки окружения учетной записи `root`. Пользователь, запускающий эту команду, обязан входить в группу `wheel`, в противном случае команда не выполнится. Пользователь также должен знать пароль учетной записи `root`.

В следующем примере пользователь повышает привилегии для запуска команды `make install`, так как этот шаг требует прав суперпользователя. По завершении работы команды пользователь набирает `exit`, тем самым выходя из учетной записи суперпользователя и возвращая привилегии собственной учетной записи.

.Установка программы с привилегиями суперпользователя
[example]
====

[source,bash]
....
% configure
% make
% su -
Password:
# make install
# exit
%
....

====

Утилита man:su[1] прекрасно подходит для одиночных систем или небольших сетей с единственным системным администратором. В качестве альтернативы ей следует упомянуть порт или пакет package:security/sudo[]. Эта утилита предоставляет журналирование активности, а также позволяет администратору указывать перечень утилит, доступных пользователю для запуска с правами суперпользователя.

[[users-modifying]]
=== Изменение учетных записей

FreeBSD располагает набором различных команд для работы с учетными записями пользователей. <<users-modifying-utilities>> перечисляет наиболее часто используемые команды, ниже находятся примеры их использования. За исчерпывающей информацией по каждой утилите следует обратиться к соответствующим страницам справочников.
[[users-modifying-utilities]]
.Утилиты для управления учетными записями
[cols="1,1", frame="none", options="header"]
|===
| Команда
| Краткое описание

|man:adduser[8]
|Рекомендуемое приложение командной строки для добавления новых пользователей.

|man:rmuser[8]
|Рекомендуемое приложение командной строки для удаления пользователей.

|man:chpass[1]
|Гибкий инструмент для изменения информации в базе данных пользователей.

|man:passwd[1]
|Инструмент командной строки для изменения паролей пользователей.

|man:pw[8]
|Мощный и гибкий инструмент для изменения любой информации, связанной с учетными записями пользователей.
|===

[[users-adduser]]
==== `adduser`

Для добавления новых пользователей рекомендуется использовать man:adduser[8]. При добавлении нового пользователя программа автоматически обновляет [.filename]#/etc/passwd# и [.filename]#/etc/group#. Она также создает домашний каталог для нового пользователя, копируя файлы настройки по умолчанию из [.filename]#/usr/shared/skel#, и может отправлять новому пользователю приветственное сообщение электронной почтой. Эту утилиту необходимо запускать с правами суперпользователя.

Утилита man:adduser[8] является интерактивной. Для создания новой учетной записи потребуется ответить на несколько вопросов. Как показано в <<users-modifying-adduser>>, ответом считается либо ввод необходимой информации, либо нажатие клавиши kbd:[Return] для принятия значения по умолчанию, которое показано в квадратных скобках. В этом примере пользователь включен в группу `wheel`, что дает возможность ему повышать привилегии до суперпользователя при помощи man:su[1]. На последнем шаге утилита предложит создать еще одну учетную запись или завершить работу.

[[users-modifying-adduser]]
.Добавление пользователя в FreeBSD
[example]
====

[source,bash]
....
# adduser
Username: jru
Full name: J. Random User
Uid (Leave empty for default):
Login group [jru]:
Login group is jru. Invite jru into other groups? []: wheel
Login class [default]:
Shell (sh csh tcsh zsh nologin) [sh]: zsh
Home directory [/home/jru]:
Home directory permissions (Leave empty for default):
Use password-based authentication? [yes]:
Use an empty password? (yes/no) [no]:
Use a random password? (yes/no) [no]:
Enter password:
Enter password again:
Lock out the account after creation? [no]:
Username   : jru
Password   : ****
Full Name  : J. Random User
Uid        : 1001
Class      :
Groups     : jru wheel
Home       : /home/jru
Shell      : /usr/local/bin/zsh
Locked     : no
OK? (yes/no): yes
adduser: INFO: Successfully added (jru) to the user database.
Add another user? (yes/no): no
Goodbye!
#
....

====

[NOTE]
====
При наборе пароля текст не отображается, поэтому постарайтесь не допускать опечаток в пароле при создании учетной записи.
====

[[users-rmuser]]
==== `rmuser`

Для полного удаления пользователя из системы запустите man:rmuser[8] с правами суперпользователя. Эта программа выполняет следующие действия:

[.procedure]
====
. Если в man:crontab[1] существуют записи пользователя, то они удаляются.
. Удаляются принадлежащие пользователю задачи man:at[1].
. Уничтожаются все процессы, принадлежащие пользователю.
. Удаляется запись пользователя из локального файла паролей.
. Если домашний каталог принадлежит пользователю, то каталог удаляется.
. Удаляется принадлежащая пользователю входящая почта из [.filename]#/var/mail#.
. Удаляются все файлы, принадлежащие пользователю, из каталогов с временными файлами, например из [.filename]#/tmp#.
. Наконец, в [.filename]#/etc/group# из всех групп удаляется имя пользователя. Если после этого удаления группа остается пустой и имя группы совпадает с именем пользователя, она удаляется. Это необходимо для удаления пользовательских уникальных групп, создаваемых man:adduser[8].
====

man:rmuser[8] не может использоваться для удаления учетной записи суперпользователя, поскольку это почти всегда означает разрушение системы.

По умолчанию используется интерактивный режим, это показано в следующем примере.

.Интерактивное удаление учетной записи с помощью `rmuser`
[example]
====

[source,bash]
....
# rmuser jru
Matching password entry:
jru:*:1001:1001::0:0:J. Random User:/home/jru:/usr/local/bin/zsh
Is this the entry you wish to remove? y
Remove user's home directory (/home/jru)? y
Removing user (jru): mailspool home passwd.
#
....

====

[[users-chpass]]
==== `chpass`

При помощи man:chpass[1] любой пользователь может изменять информацию, связанную с его учетной записью. И только суперпользователю разрешено менять информацию других пользователей.

При запуске без параметров (кроме необязательного имени пользователя), man:chpass[1] вызывает редактор, содержащий информацию о пользователе. Когда пользователь выходит из редактора, база данных пользователей обновляется новой информацией.

[NOTE]
====
Если утилита не была запущена с правами суперпользователя, то после выхода из редактора будет запрошен пароль пользователя.
====

В <<users-modifying-chpass-su>> суперпользователь, выполнив команду `chpass jru`, просматривает доступные для изменения поля. Если `jru` запустит эту команду, то лишь последние шесть строк будут доступны ему для редактирования. Это показано в <<users-modifying-chpass-ru>>.

[[users-modifying-chpass-su]]
.Работа с `chpass` с правами суперпользователя
[example]
====

[source,bash]
....
#Changing user database information for jru.
Login: jru
Password: *
Uid [#]: 1001
Gid [# or name]: 1001
Change [month day year]:
Expire [month day year]:
Class:
Home directory: /home/jru
Shell: /usr/local/bin/zsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:
....

====

[[users-modifying-chpass-ru]]
.Работа с `chpass` с правами обычного пользователя
[example]
====

[source,bash]
....
#Changing user database information for jru.
Shell: /usr/local/bin/zsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:
....

====

[NOTE]
====
man:chfn[1] и man:chsh[1] это ссылки на man:chpass[1], как и man:ypchpass[1], man:ypchfn[1] и man:ypchsh[1]. Так как NIS поддерживается автоматически, указание `yp` перед командой не обязательно. Настройка NIS будет рассмотрена в crossref:network-servers[network-servers, Сетевые серверы].
====

[[users-passwd]]
==== `passwd`

Любой пользователь может изменить собственный пароль при помощи man:passwd[1]. Для предотвращения случайного или несанкционированного изменения, команда запрашивает текущий пароль пользователя перед установкой нового:

.Изменение пароля
[example]
====

[source,bash]
....
% passwd
Changing local password for jru.
Old password:
New password:
Retype new password:
passwd: updating the database...
passwd: done
....

====

Суперпользователь может изменить пароль любого пользователя, указав его имя при запуске man:passwd[1]. Утилита, запущенная с правами суперпользователя, не запрашивает текущий пароль пользователя. Благодаря этому возможно устанавливать новые пароли забывчивым пользователям.

.Изменение пароля другого пользователя суперпользователем
[example]
====

[source,bash]
....
# passwd jru
Changing local password for jru.
New password:
Retype new password:
passwd: updating the database...
passwd: done
....

====

[NOTE]
====
Как и в случае с man:chpass[1], man:yppasswd[1] это всего лишь ссылка на man:passwd[1], так что NIS работает с обеими командами.
====

[[users-pw]]
==== `pw`

man:pw[8] это утилита командной строки для создания, удаления, модифицирования и отображения пользователей и групп. Она функционирует как внешний интерфейс к системным файлам пользователей и групп. У man:pw[8] очень мощный набор параметров командной строки, что делает это программу подходящей для использования в shell скриптах, но новым пользователям она может показаться более сложной, чем другие представленные здесь команды.

[[users-limiting]]
=== Ограничение пользователей

FreeBSD предоставляет администратору несколько способов ограничения количества занимаемых пользователями системных ресурсов. Дисковые квоты, как один из видов ограничения ресурсов, обсуждаются в отдельном разделе, остальные ограничения перечислены далее в тексте.

Дисковые квоты ограничивают объем дискового пространства, занимаемого пользователями, а также предоставляют способ быстрой проверки занимаемого объема без пересчета его каждый раз. Квоты обсуждаются в crossref:disks[quotas,Квотирование файловых систем].

Другие ограничения ресурсов включают способы ограничения использования CPU, памяти и других ресурсов, которые могут потребляться пользователем. Ограничения накладываются с помощью классов учетных записей и обсуждаются в этом разделе.

Классы учетных записей определяются в [.filename]#/etc/login.conf#, они детально описаны на странице справочника man:login.conf[5]. Каждой учетной записи присвоен класс (`default` по умолчанию), и каждому классу присвоен набор характеристик. Характеристика определяется в виде пары `имя=значение`, где _имя_ это определенный идентификатор, а _значение_ это произвольная строка, обрабатываемая в зависимости от _имени_. Настройка классов и характеристик довольно проста, и также описана в man:login.conf[5].

[NOTE]
====
FreeBSD, как правило, не читает настройки в [.filename]#/etc/login.conf# непосредственно, вместо этого она обращается к файлу базы данных [.filename]#/etc/login.conf.db# для ускорения доступа к данным. Всякий раз после редактирования [.filename]#/etc/login.conf# необходимо обновить [.filename]#/etc/login.conf.db# при помощи следующей команды:

[source,bash]
....
# cap_mkdb /etc/login.conf
....

====

Ограничения на ресурсы отличаются от обычных характеристик: во-первых, для каждого ограничения существует "мягкое" (текущее) и "жесткое" ограничение. Мягкое ограничение может настраиваться пользователем или приложением, но не может превышать жесткое ограничение. Последнее может быть уменьшено пользователем, а увеличено - лишь суперпользователем. Во-вторых, большинство ограничений ресурсов накладываются на каждый процесс определенного пользователя, а не к пользователю вообще. Эти различия диктуются особенностями обработки ограничений, а не реализацией структуры характеристик учетных записей.

Ниже приведен список наиболее часто используемых ограничений на ресурсы. Остальные, вместе с другими характеристиками, можно найти в man:login.conf[5].

`coredumpsize`::
Ограничение на размер файла дампа памяти , генерируемого программой, подчиняющееся другим ограничениям  на используемое дисковое пространство, таким как `filesize`, или дисковым квотам. Это ограничение часто используется как менее строгий метод контролирования потребления дискового пространства. Поскольку пользователь не создает файлы дампов памяти самостоятельно, и зачастую не удаляет их, установка этого параметра может предохранить пользователя от выхода за пределы ограничений на дисковое пространство, в случае если большая программа создаст файл аварийного дампа памяти.

`cputime`::
Это максимальное количество времени  ЦПУ, потребляемого пользователем. Превысившие это время процессы будут уничтожены ядром.
+

[NOTE]
====
Это ограничение потребляемого _времени_ ЦПУ, а не процентов использования ЦПУ, которые отображаются в некоторых полях man:top[1] и man:ps[1].
====

`filesize`::
Это максимальный размер файла , которым может владеть пользователь. В отличие от crossref:disks[quotas,дисковых квот], это ограничение применяется к отдельным файлам, а не ко всему набору принадлежащих пользователю файлов.

`maxproc`::
Это максимальное число процессов , которые могут быть запущены пользователем. В это число включаются и консольные, и фоновые процессы. Это ограничение не может превышать системный лимит, указываемый через переменную man:sysctl[8] `kern.maxproc`. Установка слишком жестких ограничений может стать помехой работе пользователя: зачастую ему удобно входить в систему с нескольких консолей или использовать каналы. Некоторые задачи, такие как компиляция большой программы, порождают множество процессов.

`memorylocked`::
Это максимальный объем памяти , блокировка которого может быть запрошена процессом при помощи man:mlock[2]. Некоторые критически важные для системы программы, такие как man:amd[8], блокируют отведенную процессу память так, что в случае "пробуксовывания" системы (system thrashing) они не усугубляют проблему.

`memoryuse`::
Это максимальный объем памяти , которая может быть занята процессом в любой момент времени. Сюда входит основная память и использование подкачки. Это ограничение не снимает все вопросы, связанные с использованием памяти, но для начала это подходящее ограничение.

`openfiles`::
Это максимальное количество файлов, которые могут быть открыты  процессом. В FreeBSD файлы также используются для представления сокетов и каналов IPC, поэтому не устанавливайте слишком маленькое значение. Ограничение этого параметра, устанавливаемое для всей системы, определяется переменной man:sysctl[8] `kern.maxfiles`.

`sbsize`::
Это ограничение на объем сетевой памяти, т.е. mbufs , которую может занять пользователь. В общем, это ограничение может быть использовано для ограничения сетевых взаимодействий.

`stacksize`::
Это максимальный размер сегмента стека  процесса. Сам по себе этот параметр не может ограничить размер используемой программой памяти, следовательно, его необходимо использовать вместе с другими ограничениями.

Существуют несколько других аспектов, которые необходимо учитывать при установке ограничений ресурсов. Ниже приведены некоторые общие подсказки, советы и различные комментарии.

* Процессам, загружаемым при старте системы скриптами [.filename]#/etc/rc# присваивается класс `daemon`.
* Хотя поставляемый с системой [.filename]#/etc/login.conf# - это хороший источник корректных значений для большинства ограничений, сами ограничения могут не подходить для конкретной системы. Установка слишком слабых ограничений может повлечь злоупотребления системой, а установка слишком сильных ограничений может стать помехой производительности.
* Пользователи Xorg возможно должны получить больше ресурсов, чем другие пользователи. Xorg сама по себе потребляет много ресурсов, а также провоцирует пользователей на одновременный запуск большего количества программ.
* Многие ограничения применяются к отдельным процессам, а не к пользователю вообще. Например, установка `openfiles` в 50 означает, что каждый процесс, запущенный пользователем, может открывать до 50 файлов. Общее количество файлов, которые могут быть открыты пользователем, вычисляется как `openfiles`, умноженное на `maxproc`. Это также применимо к потребляемой памяти.

За дальнейшей информацией по ограничениям на ресурсы, классам учетных записей и характеристикам, обращайтесь к man:cap.mkdb[1], man:getrlimit[2], и man:login.conf[5].

[[users-groups]]
=== Группы

Группа это список пользователей. Группа идентифицируется по имени и GID (Group ID). В FreeBSD для определения прав процесса ядро использует UID процесса, а также список групп, которым он принадлежит. В большинстве случаев, GID пользователя означает первую группу из списка.

Имена групп связываются с GID в файле [.filename]#/etc/group#. Это текстовый файл с четырьмя разделенными двоеточием полями. Первое поле это имя группы, второе это зашифрованный пароль, третье это GID, а четвертое это разделенный запятыми список членов группы. За более полным описанием синтаксиса обратитесь к man:group[5].

Суперпользователь может редактировать [.filename]#/etc/group# при помощи текстового редактора. Как вариант, можно задействовать man:pw[8] для добавления и редактирования групп. Например, для добавления группы, называемой `teamtwo`, и проверки ее существования вы можете использовать:

.Добавление группы с использованием man:pw[8]
[example]
====

[source,bash]
....
# pw groupadd teamtwo
# pw groupshow teamtwo
teamtwo:*:1100:
....

====

В этом примере число `1100` это GID группы `teamtwo`. На данный момент в `teamtwo` нет членов. Следующая команда добавит `jru` в группу `teamtwo`.

.Добавление пользователей в новую группу при помощи man:pw[8]
[example]
====

[source,bash]
....
# pw groupmod teamtwo -M jru
# pw groupshow teamtwo
teamtwo:*:1100:jru
....

====

Аргумент к параметру `-M` это разделенный запятыми список пользователей, которые добавляются в новую (пустую) группу или заменяют существующих членов группы. Что касается пользователя - это членство в группе отличается от первичной группы пользователя, указанного в файле паролей. Это значит, что пользователь не будет показан как член группы при использовании man:pw[8] `groupshow`, но будет отображен при использовании man:id[1] или похожего инструмента. Когда программа man:pw[8] задействована для добавления пользователя в группу, то она работает только с файлом [.filename]#/etc/group# и не ищет дополнительную информацию в файле [.filename]#/etc/passwd#.

.Добавление нового члена группы с использованием man:pw[8]
[example]
====

[source,bash]
....
# pw groupmod teamtwo -m db
# pw groupshow teamtwo
teamtwo:*:1100:jru,db
....

====

В этом примере аргументом к опции `-m` является разделенный запятыми список пользователей, добавляемых в группу. В отличие от предыдущего примера, пользователи добавляются в группу, а не замещают имеющийся список пользователей группы.

.Использование man:id[1] для определения принадлежности к группам
[example]
====

[source,bash]
....
% id jru
uid=1001(jru) gid=1001(jru) groups=1001(jru), 1100(teamtwo)
....

====

В этом примере `jru` является членом групп `jru` и `teamtwo`.

За дальнейшей информацией об этой команде и о формате файла [.filename]#/etc/group# обратитесь к man:pw[8] и man:group[5].

[[permissions]]
== Права доступа

FreeBSD является прямым потомком BSD UNIX(R) и основывается на некоторых ключевых концепциях UNIX(R). В первую очередь это, конечно, тот факт, что FreeBSD - многопользовательская операционная система. Это означает, что несколько пользователей могут работать одновременно, решая различные задачи и совершенно не мешая друг другу. На системе лежит ответственность за правильное разделение и управление такими ресурсами как память, процессорное время, периферийные устройства и прочее.

Многопользовательская среда предполагает наличие механизма регулирования прав доступа к любому ресурсу в системе. Существует три типа прав доступа: на чтение, запись и исполнение. Права сгруппированы три по три, соответственно чтение/запись/выполнение для владельца/группы/всех остальных. Численное представление:

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Значение
| Права доступа
| Список файлов каталога

|0
|Ничего не разрешено
|`---`

|1
|Нельзя читать и писать, разрешено исполнять
|`--x`

|2
|Нельзя читать и исполнять, разрешено писать
|`-w-`

|3
|Нельзя читать, разрешено писать и исполнять
|`-wx`

|4
|Разрешено читать, нельзя писать и исполнять
|`r--`

|5
|Разрешено читать и исполнять, нельзя писать
|`r-x`

|6
|Разрешено читать и писать, нельзя исполнять
|`rw-`

|7
|Разрешено все
|`rwx`
|===

Вы можете использовать опцию `-l` команды man:ls[1] для получения подробного листинга каталога, включающего колонку с информацией о правах на файл для владельца, группы и всех остальных. Например, команда `ls -l` в произвольном каталоге может вывести следующее:

[source,bash]
....
% ls -l
total 530
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 myfile
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 otherfile
-rw-r--r--  1 root  wheel    7680 Sep  5 12:31 email.txt
...
....

Вот как выглядит первая колонка вывода `ls -l`:

[source,bash]
....
-rw-r--r--
....

Первый (считая слева) символ говорит обычный ли это файл, каталог, символьное устройство, сокет или любое другое псевдо-файловое устройство. В нашем случае `-` указывает на обычный файл. Следующие три символа (в данном случае это `rw-`) задают права доступа владельца файла. Затем идут права группы, которой принадлежит файл (`r--`). Последняя тройка (`r--`) определяет права для всех остальных. Минус означает отсутствие каких-либо прав (т.е. нельзя ни читать, ни писать, ни выполнять). В данном случае права установлены таким образом, что владелец может читать и писать в файл, а группа и другие могут только читать. Таким образом, численное представление прав `644`, где каждая цифра представляет три части прав на файл.

Права на устройства контролируются аналогичным образом. В FreeBSD все устройства представлены в виде файлов, которые можно открывать, читать и писать в них. Эти специальные файлы содержатся в каталоге [.filename]#/dev#.

Каталоги также являются файлами. К ним применимы те же права на чтение, запись и выполнение. Правда, в данном случае "выполнение" имеет несколько другой смысл. Когда каталог помечен как "исполнимый", это означает, что можно "зайти" в него (с помощью команды `cd`, change directory). Это также означает, что в данном каталоге можно получить доступ к файлам, имена которых известны (конечно, если собственные права на файл разрешают такой доступ).

Если же требуется получить список файлов в некотором каталоге, права доступа на него должные включать доступ на чтение. Для того, чтобы удалить из каталога какой-либо файл, имя которого известно, на этот каталог должны быть даны права на запись _и_ на исполнение.

Существуют и другие права доступа, но они как правило используются в особых случаях, например, setuid-бит на выполняемые файлы и sticky-бит на каталоги. За дополнительными сведениями по этому вопросу обращайтесь к man:chmod[1].

=== Символические обозначения прав

Символические обозначения, иногда называемые символическими выражениями, используют буквы вместо восьмеричных значений для назначения прав на файлы и каталоги. Символические выражения используют синтаксис (кто) (действие) (права), где существуют следующие значения:

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Опция
| Буква
| Значение

|(кто)
|u
|Пользователь (User)

|(кто)
|g
|Группа (Group)

|(кто)
|o
|Другие (Other)

|(кто)
|a
|Все (All, "world")

|(действие)
|+
|Добавление прав

|(действие)
|-
|Удаление прав

|(действие)
|=
|Явная установка прав

|(права)
|r
|Чтение (Read)

|(права)
|w
|Запись (Write)

|(права)
|x
|Выполнение (Execute)

|(права)
|t
|Sticky бит

|(права)
|s
|SUID или SGID
|===

Эти значения используются командой man:chmod[1] так же как и раньше, но с буквами. Например, вы можете использовать следующую команду для запрета доступа других пользователей к _FILE_:

[source,bash]
....
% chmod go= FILE
....

Для изменения более чем одного набора прав можно применить список, разделенный запятыми. Например, следующая команда удалит права группы и "всех остальных" на запись в _FILE_, а затем добавит права на выполнение для всех:

[source,bash]
....
% chmod go-w,a+x FILE
....

=== Флаги файлов в FreeBSD

Кроме уже описанных прав доступа к файлам, FreeBSD поддерживает использование "флагов файлов". Эти флаги обеспечивают дополнительный уровень защиты и контроля над файлами, но не могут применяться к каталогам.

Эти флаги добавляют дополнительные возможности контроля над файлами, обеспечивая (при определенных условиях) невозможность их удаления или изменения даже пользователю `root`.

Файловые флаги изменяются при помощи утилиты man:chflags[1] посредством простого интерфейса. К примеру, чтобы установить системный признак неудаляемости на файл [.filename]#file1#, выполните следующую команду:

[source,bash]
....
# chflags sunlink file1
....

Чтобы отключить флаг неудаляемости, просто выполните предыдущую команду с ключом "no" перед параметром `sunlink`. Вот так:

[source,bash]
....
# chflags nosunlink file1
....

Чтобы просмотреть флаги этого файла, воспользуйтесь командой man:ls[1] с параметрами `-lo`:

[source,bash]
....
# ls -lo file1
....

Результат выполнения команды должен выглядеть примерно так:

[.programlisting]
....
-rw-r--r--  1 trhodes  trhodes  sunlnk 0 Mar  1 05:54 file1
....

Некоторые флаги могут быть установлены или сняты с файлов только пользователем `root`. В остальных случаях эти флаги может установить владелец файла. Для получения дополнительной информации мы рекомендуем изучить содержимое справки по командам man:chflags[1] и man:chflags[2].

=== setuid, setgid и sticky-биты в правах доступа

В дополнение к рассмотренным выше правам доступа и флагам файлов необходимо также упомянуть еще три бита прав доступа, о которых должны знать все системные администраторы. Это такие биты, как `setuid`, `setgid` и `sticky`.

Эти биты играют важную роль в определённых моментах работы UNIX(R), так как они предоставляют функциональность, расширяющую права обычного пользователя. Чтобы понять как они работают, необходимо определить различие между реальным идентификатором пользователя (UID) и действующим идентификатором пользователя (effective UID, EUID).

Реальный UID - это идентификатор пользователя, запустившего процесс на выполнение. Действующий UID (EUID) - это идентификатор пользователя, с которым на самом деле выполняется процесс. Например, утилита man:passwd[1] во время смены пароля пользователем запускается с реальным ID пользователя; однако, чтобы внести изменения в базу данных пользователей, ей необходимо работать с действующим ID пользователя `root`. Это тот механизм, который позволяет обычным пользователям изменять свои пароли и при этом не наблюдать ошибку `Permission Denied`.

[NOTE]
====
Опция `nosuid`, указанная при монтировании файловой системы, отменяет действие битов `setuid` и `setgid`. То есть, утилиты, использующие эти биты прав, откажутся выполняться, даже не выдав пользователю никакого предостережения. К тому же, (с точки зрения обеспечения безопасности) эта опция монтирования не является абсолютно надежной, так как, согласно странице справочника man:mount[8], накладываемые ею ограничения могут быть обойдены при помощи "обертки" `nosuid` (`nosuid` wrapper).
====

Бит setuid устанавливается добавлением цифры четыре (4) перед численным представлением прав доступа, например:

[source,bash]
....
# chmod 4755 suidexample.sh
....

Теперь права доступа на файл [.filename]#suidexample.sh# выглядят подобно следующему:

[.programlisting]
....
-rwsr-xr-x   1 trhodes  trhodes    63 Aug 29 06:36 suidexample.sh
....

В вышеприведенной строке приметно то, что в перечне прав доступа для владельца файла присутствует символ `s`, который заменил собой бит выполнения. 

Чтобы посмотреть `setuid` в действии, откройте два терминала. На одном из них запустите команду `passwd` с правами обычного пользователя. Пока утилита ждет ввода нового пароля, просмотрите таблицу процессов и найдите в ней запись о процессе `passwd`.

В терминале А:

[source,bash]
....
Changing local password for trhodes
Old Password:
....

В терминале Б:

[source,bash]
....
# ps aux | grep passwd
....

[source,bash]
....
trhodes  5232  0.0  0.2  3420  1608   0  R+    2:10AM   0:00.00 grep passwd
root     5211  0.0  0.2  3620  1724   2  I+    2:09AM   0:00.01 passwd
....

Как уже было сказано, утилита `passwd` запущена с правами обычного пользователя, но ее действующий UID - `root`.

Действие бита `setgid` подобно действию `setuid`; отличие заключается в том, что изменяются настройки прав для группы. Когда выполняется приложение (или утилита) с установленным битом `setgid`, то ему (ей) будут обеспечены права в соответствии с группой владельца файла, а не с группой пользователя, запустившего процесс.

Чтобы установить на файл бит `setgid`, выполните команду `chmod`, добавив цифру два (2) перед численным представлением прав доступа, например:

[source,bash]
....
# chmod 2755 sgidexample.sh
....

Новый бит отображается подобно предыдущему случаю: обратите внимание на наличие `s` в перечне прав доступа для группы:

[source,bash]
....
-rwxr-sr-x   1 trhodes  trhodes    44 Aug 31 01:49 sgidexample.sh
....

[NOTE]
====
В этих примерах, несмотря на то, что сценарий оболочки является исполняемым файлом, он не будет выполняться с другим действующим идентификатором пользователя (EUID). Так происходит потому, что сценариям командного интерпретатора недоступен системный вызов man:setuid[2].
====

Позволяя расширять права пользователя, оба бита прав доступа (`setuid` и `setgid`) могут привести к снижению безопасности системы. Третий обсуждаемый здесь бит - `sticky` - способствует повышению безопасности системы.

Бит `sticky`, будучи установленным на каталог, позволяет производить удаление файла только владельцу файла. Этот бит применяется для предотвращения удаления файлов в публичных каталогах, таких как [.filename]#/tmp#, пользователями, не владеющими файлом. Чтобы задействовать этот бит, добавьте единицу (1) перед численным представлением прав доступа. Например:

[source,bash]
....
# chmod 1777 /tmp
....

Проверить результат можно при помощи команды `ls`:

[source,bash]
....
# ls -al / | grep tmp
....

[source,bash]
....
drwxrwxrwt  10 root  wheel         512 Aug 31 01:49 tmp
....

Отличительной особенностью бита `sticky` является наличие символа `t` в самом конце перечня прав.

[[dirstructure]]
== Структура каталогов

Файловая система FreeBSD является ключевым моментом в понимании устройства всей системы. Самым важным понятием является, несомненно, корневой каталог, обозначаемый символом "/". Корневой каталог монтируется самым первым на этапе загрузки и содержит все необходимое, чтобы подготовить систему к загрузке в многопользовательский режим. Корневой каталог также содержит точки монтирования для остальных файловых систем, которые монтируются во время перехода в многопользовательский режим.

Точкой монтирования называется каталог, находящийся в родительской (обычно - корневой) файловой системе, к которому может быть подсоединена другая файловая система. Более детально это описывается в <<disk-organization>>. Стандартные точки монтирования включают [.filename]#/usr#, [.filename]#/var#, [.filename]#/tmp#, [.filename]#/mnt# и [.filename]#/cdrom#. Эти каталоги обычно перечислены в файле [.filename]#/etc/fstab#, в котором указаны файловые системы и их точки монтирования. Большинство файловых систем, описанных в [.filename]#/etc/fstab# монтируются автоматически из скрипта man:rc[8], если только для них не указана опция `noauto`. Более детальная информация находится в <<disks-fstab>>.

Полное описание иерархии файловой системы есть в man:hier[7]. Здесь же мы упомянем лишь наиболее важные каталоги.

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Каталог
| Описание

|[.filename]#/#
|Корневой каталог файловой системы.

|[.filename]#/bin/#
|Основные утилиты, необходимые для работы как в однопользовательском, так и в многопользовательском режимах.

|[.filename]#/boot/#
|Программы и конфигурационные файлы, необходимые для нормальной загрузки операционной системы.

|[.filename]#/boot/defaults/#
|Конфигурационные файлы с настройками по умолчанию, используемые в процессе загрузки операционной системы (см. man:loader.conf[5]).

|[.filename]#/dev/#
|Файлы устройств (см. man:intro[4]).

|[.filename]#/etc/#
|Основные конфигурационные файлы системы и скрипты.

|[.filename]#/etc/defaults/#
|Основные конфигурационные файлы системы с настройками по умолчанию (см. man:rc[8]).

|[.filename]#/etc/mail/#
|Конфигурационные файлы для систем обработки почты (например, man:sendmail[8]).

|[.filename]#/etc/namedb/#
|Конфигурационные файлы для утилиты `named` (см. man:named[8]).

|[.filename]#/etc/periodic/#
|Файлы сценариев, выполняемые ежедневно, еженедельно и ежемесячно (см. man:cron[8] и man:periodic[8]).

|[.filename]#/etc/ppp/#
|Конфигурационные файлы для утилиты `ppp` (см. man:ppp[8]).

|[.filename]#/mnt/#
|Пустой каталог, часто используемый системными администраторами как временная точка монтирования.

|[.filename]#/proc/#
|Виртуальная файловая система, отображающая текущие процессы (см. man:procfs[5], man:mount_procfs[8]).

|[.filename]#/rescue/#
|Статически собранные программы для восстановления после сбоев. Обратитесь к man:rescue[8].

|[.filename]#/root/#
|Домашний каталог пользователя `root`.

|[.filename]#/sbin/#
|Системные утилиты и утилиты администрирования, необходимые для работы как в однопользовательском, так и в многопользовательском режимах.

|[.filename]#/tmp/#
|Временные файлы. Содержимое [.filename]#/tmp# обычно теряется во время перезагрузки системы. Файловая система в памяти часто монтируется в [.filename]#/tmp#. Это может быть автоматизированно с помощью переменных относительно tmpmfs из man:rc.conf[5] (или же с помощью записи в [.filename]#/etc/fstab#; обращайтесь к man:mdmfs[8]).

|[.filename]#/usr/#
|Большинство пользовательских утилит и приложений.

|[.filename]#/usr/bin/#
|Пользовательские утилиты и приложения общего назначения.

|[.filename]#/usr/include/#
|Стандартные заголовочные файлы для языка C.

|[.filename]#/usr/lib/#
|Файлы стандартных библиотек.

|[.filename]#/usr/libdata/#
|Файлы данных для различных утилит.

|[.filename]#/usr/libexec/#
|Системные даемоны и утилиты (выполняемые другими программами).

|[.filename]#/usr/local/#
|Локальные пользовательские приложения, библиотеки, и т.д. Также используется по умолчанию коллекцией портов. Внутри [.filename]#/usr/local# иерархия каталогов должна следовать man:hier[7] для [.filename]#/usr#. Исключение составляют каталог [.filename]#man#, который расположен непосредственно в [.filename]#/usr/local#, а не в [.filename]#/usr/local/share#, и документация портов, которая расположена в [.filename]#share/doc/port#. 

|[.filename]#/usr/obj/#
|Архитектурно-зависимые файлы и каталоги, образующиеся в процессе сборки системы из исходных текстов в [.filename]#/usr/src#.

|[.filename]#/usr/ports/#
|Коллекция портов FreeBSD (опционально).

|[.filename]#/usr/sbin/#
|Системные утилиты и утилиты администрирования (исполняемые пользователем).

|[.filename]#/usr/shared/#
|Архитектурно-независимые файлы.

|[.filename]#/usr/src/#
|Исходные тексты BSD и/или программ.

|[.filename]#/usr/X11R6/#
|Утилиты, приложения и библиотеки X11R6 (X Window System; необязательно).

|[.filename]#/var/#
|Файлы журналов общего назначения, временные, перемещаемые файлы и файлы очередей. Файловая система в памяти иногда монтируется в [.filename]#/var#. Это может быть автоматизированно с помощью переменных относительно varmfs из man:rc.conf[5] (или же с помощью записи в [.filename]#/etc/fstab#; обращайтесь к man:mdmfs[8]).

|[.filename]#/var/log/#
|Различные файлы системных журналов.

|[.filename]#/var/mail/#
|Почтовые ящики пользователей.

|[.filename]#/var/spool/#
|Файлы очередей печати, почты, и пр.

|[.filename]#/var/tmp/#
|Временные файлы, которые обычно сохраняются во время перезагрузки системы, если только [.filename]#/var# не является файловой системой в памяти.

|[.filename]#/var/yp/#
|Карты (maps) NIS.
|===

[[disk-organization]]
== Организация дисков

Наименьшая единица, которую FreeBSD использует для обращения к файлам, это имя файла. Имена файлов чувствительны к регистру, поэтому [.filename]#readme.txt# и [.filename]#README.TXT# - два разных файла. FreeBSD не использует расширение файла ([.filename]#.txt#) для определения программа это, документ или другой тип данных.

Файлы хранятся в каталогах. Каталоги могут не содержать файлов, или могут содержать много сотен файлов. Каталоги также могут содержать другие каталоги, что позволяет создавать иерархию каталогов один в другом. Это упрощает организацию данных.

Обращение к файлам происходит путем задания имени файла или каталога, дополняемого прямым слэшем `/`, за которым может следовать имя другого каталога. Если есть каталог [.filename]#foo#, содержащий каталог [.filename]#bar#, который содержит файл [.filename]#readme.txt#, полное имя, или _путь_ к файлу будет [.filename]#foo/bar/readme.txt#.

Каталоги и файлы хранятся в файловой системе. Каждая файловая система содержит один каталог на верхнем уровне, называемый _корневым каталогом_ этой файловой системы. Этот корневой каталог может содержать другие каталоги.

Внешне это может быть похоже на те операционные системы, которые вы возможно использовали. Есть несколько отличий: например, MS-DOS(R) использует `\` для разделения имен файлов и каталогов, а Mac OS(R) использует `:`.

FreeBSD не использует букв дисков, или других имен дисков в пути. Вам не нужно писать [.filename]#c:/foo/bar/readme.txt# в FreeBSD.

Вместо этого, одна файловая система назначается _корневой файловой системой_. Обращение к корневому каталогу корневой файловой системы происходит через `/`. Любая другая файловая система _монтируется_ к корневой файловой системе. Неважно как много дисков есть в вашей системе FreeBSD, каждый каталог будет выглядеть как расположенный на том же диске.

Предположим, у вас есть три файловых системы: `A`, `B`, и `C`. Каждая файловая система имеет один корневой каталог, в котором содержатся другие каталоги, называемые `A1`, `A2` (и аналогично `B1`, `B2` и `C1`, `C2`).

Назовем `A` корневой файловой системой. Если вы используете команду `ls` для просмотра содержимого каталога, вы увидите два подкаталога, `A1` и `A2`. Дерево каталогов выглядит так:

image::example-dir1.png[]

Файловая система должна быть подмонтирована к каталогу другой файловой системы. Предположим, что вы монтируете файловую систему `B` на каталог `A1`. Корневой каталог `B` замещается `A1`, а каталоги в `B` отображаются соответственно:

image::example-dir2.png[]

Если потребуется, любые файлы из каталогов `B1` или `B2` могут быть получены через путь [.filename]#/A1/B1# или [.filename]#/A1/B2#. Все файлы, бывшие в [.filename]#/A1#, временно скрыты. Они появятся, если `B` будет _размонтирована_ с A.

Если `B` была смонтирована на `A2,` диаграмма будет выглядеть так:

image::example-dir3.png[]

а пути будут [.filename]#/A2/B1# и [.filename]#/A2/B2# соответственно.

Файловые системы могут быть смонтированы одна на другую. Продолжая предыдущий пример, файловая система `C` может быть смонтирована на каталог `B1` файловой системы `B` в таком порядке:

image::example-dir4.png[]

Или `C` может быть смонтирована прямо на файловую систему `A`, на каталог `A1`:

image::example-dir5.png[]

Если вы знакомы с MS-DOS(R), это похоже, хотя и не идентично, команде `join`.

Как правило, это не должно вас интересовать. Обычно вы создаете файловые системы во время установки FreeBSD, решаете куда их монтировать, и ничего не меняете, пока не понадобится добавить новый диск.

Можно создать одну большую корневую файловую систему и не создавать других. У такого подхода есть несколько недостатков и одно преимущество.

.Преимущества нескольких файловых систем
* Различные файловые системы могут иметь различные _опции монтирования_. Например, в целях безопасности корневая файловая система может быть смонтирована только для чтения, что делает невозможным случайное удаление или редактирование критически важного файла. Отделение файловых систем, используемых пользователями для записи, таких как [.filename]#/home#, от других файловых систем позволяет также монтировать их с параметром _nosuid_; этот параметр отменяет действие битов _suid_/ _guid_ на исполняемых файлах, в этой файловой системе, что потенциально повышает безопасность.
* FreeBSD автоматически оптимизирует расположение файлов на файловой системе в зависимости от того, как файловая система используется. Файловая система, содержащая множество мелких часто записываемых файлов, будет иметь оптимизацию, отличную от таковой для файловой системы, содержащей несколько больших файлов. На одной большой файловой системе эта оптимизация не работает.
* Файловые системы FreeBSD очень устойчивы к внезапному отключению. Тем не менее, потеря питания в критический момент все же может повредить структуру файловой системы. Разделение данных на несколько файловых систем повышает шансы, что система все-таки будет работать и делает более легким восстановление с резервной копии.

.Преимущество одной файловой системы
* Размер файловых систем фиксирован. Если вы создаете файловую систему при установке FreeBSD и задаете определенный размер, позднее вы можете обнаружить что нужен раздел большего размера. Это не так легко сделать без резервного копирования, создания файловых систем нового размера и последующего восстановления сохраненных данных.
+
[IMPORTANT]
====
В FreeBSD представлена команда man:growfs[8], которая позволяет увеличивать размер файловой системы на лету, устраняя это ограничение.
====

Файловые системы содержатся в разделах. Этот термин не имеет того же смысла, что и при более раннем его использовании в этой главе, из-за наследия UNIX(R) в FreeBSD. Каждый раздел обозначается буквой от `a` до `h`. Каждый раздел может содержать только одну файловую систему, это значит что файловая система может быть описана ее точкой монтирования в файловой иерархии, или буквой раздела, в котором она содержится.

FreeBSD также использует дисковое пространство под _раздел подкачки (swap space)_. Подкачка позволяет FreeBSD работать с _виртуальной памятью_. Ваш компьютер может работать так, как если бы у него было больше памяти, чем есть на самом деле. Когда у FreeBSD кончается память, она перемещает часть данных, не используемых в данный момент, в раздел подкачки и возвращает их обратно (перемещая в подкачку что-то другое), когда они нужны.

По некоторым разделам есть определенные соглашения.

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Раздел
| Соглашение

|`a`
|Как правило, содержит корневую файловую систему

|`b`
|Как правило, содержит раздел подкачки

|`c`
|Как правило, такого же размера, что и весь слайс (slice). Это позволяет утилитам, которым нужно работать над всем слайсом (например, сканер плохих блоков), работать с разделом `c`. В обычной ситуации не нужно создавать файловую систему на этом разделе.

|`d`
|Раздел `d` создавался для специальных целей, хотя сейчас они не актуальны и `d` может быть задействован как обычный раздел.
|===

Каждый раздел-содержащий-файловую-систему хранится на том, что во FreeBSD называется _слайс (slice)_. Слайс - это термин FreeBSD, то, что обычно называют разделом, и опять же это из-за UNIX(R) основы FreeBSD. Слайсы нумеруются с 1 по 4.

Номера слайсов следуют за именем устройства, предваряемые строчной `s`, начиная с 1. Так "da0__s1__" это первый слайс первого SCSI устройства. Может быть только четыре физических слайса на диске, но могут быть логические слайсы нужного типа внутри физических слайсов. Эти дополнительные слайсы нумеруются начиная с 5, так что "ad0__s5__" это первый дополнительный слайс на первом IDE диске. Эти устройства используются файловыми системами, занимающими весь слайс.

Слайсы, "эксклюзивно выделенные (dangerously dedicated)" физические устройства и другие устройства содержат _разделы_, представляемые буквами от `a` до `h`. Эти буквы добавляются к имени устройства. "da0__a__" это раздел a на первом устройстве da, который "эксклюзивно выделен". "ad1s3__e__" это пятый раздел в третьем слайсе второго IDE диска.

Наконец, каждый диск идентифицирован. Имя диска начинается с кода, обозначающего тип диска, затем идет номер диска. В отличие от слайсов, нумерация дисков начинается с 0. Основные коды, которые вам могут встретиться, есть в <<basics-dev-codes>>.

В то время, как ссылка на раздел FreeBSD требует также указания слайса и диска, содержащего раздел, ссылка на слайс требует также указания имени диска. Другими словами, ссылаясь на раздел, указывайте имя диска, `s`, номер слайса, и затем букву раздела. Примеры показаны в <<basics-disk-slice-part>>.

<<basics-concept-disk-model>> показывает концептуальную модель диска, которая должна помочь прояснить ситуацию.

Для установки FreeBSD вы должны сначала настроить слайсы дисков, затем создать разделы внутри слайсов, которые будут использованы для FreeBSD, а затем создать файловую систему (или подкачку) в каждом разделе и решить, куда файловая система будет смонтирована.

[[basics-dev-codes]]
.Коды дисковых устройств
[cols="1,1", frame="none", options="header"]
|===
| Код
| Значение

|[.filename]#ad#
|ATAPI (IDE) диск

|[.filename]#da#
|SCSI direct access диск

|[.filename]#acd#
|ATAPI (IDE) CDROM

|[.filename]#cd#
|SCSI CDROM

|[.filename]#fd#
|Floppy disk
|===

[[basics-disk-slice-part]]
.Пример имен диска, слайса, и раздела
[example]
====
[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Имя
| Значение

|`ad0s1a`
|Первый раздел (`a`) на первом слайсе (`s1`) первого IDE диска (`ad0`).

|`da1s2e`
|Пятый раздел (`e`) на втором слайсе (`s2`) второго SCSI диска (`da1`).
|===
====

[[basics-concept-disk-model]]
.Концептуальная модель диска
[example]
====
Эта диаграмма показывает первый подключенный к системе IDE диск с точки зрения FreeBSD. Предположим, что размер диска 4 GB, и он содержит два 2 GB слайса (MS-DOS(R) разделы). Первый слайс содержит MS-DOS(R) диск, [.filename]#C:#, а второй слайс содержит установленную FreeBSD. В этом примере у установленной FreeBSD есть три раздела с данными и раздел подкачки.

В каждом из трех разделов есть файловая система. Раздел `a` используется для корневой файловой системы, `e` для иерархии каталогов [.filename]#/var#, а `f` для иерархии каталогов [.filename]#/usr#.

image::disk-layout.png[]

====

[[mount-unmount]]
== Монтирование и размонтирование файловых систем

Файловая система лучше всего представима в виде дерева, с корнем в [.filename]#/#. Каталоги, [.filename]#/dev#, [.filename]#/usr# и прочие - это ветви дерева, которые, в свою очередь, являются корнями для поддеревьев, также имеющих ветви ([.filename]#/usr/local#), и т.д.

Хорошей практикой является разнесение некоторых особо важных каталогов на разные файловые системы. Например, [.filename]#/var#, содержит [.filename]#log/#, [.filename]#spool/#, а также всевозможные временные файлы и нередко может занять все свободное место на диске. Поэтому лучше смонтировать [.filename]#/var# отдельно, чтобы избежать переполнения [.filename]#/#.

Часто бывает так, что некоторые разделы файловой системы расположены на разных физических носителях (дисках, CDROM), виртуальных или сетевых (например, crossref:network-servers[network-nfs,"сетевая файловая система (Network File System, NFS)"]). В этом случае узлы файловой иерархии будут расположены на разных файловых системах.

[[disks-fstab]]
=== Файл [.filename]#fstab#

Файловые системы, перечисленные в [.filename]#/etc/fstab#, монтируются автоматически в crossref:boot[boot,процессе загрузки] (если, конечно, для них не указана опция `noauto`).

Формат файла [.filename]#/etc/fstab# следующий (файловые системы перечисляются построчно):

[.programlisting]
....

	устройство	/точка-монтирования	тип файловой системы	опции	частота дампов	порядок проверки
....

`устройство`::
Имя устройства (которое должно присутствовать), как описано в crossref:disks[disks-naming,Имена устройств].

`точка монтирования`::
Каталог (существующий), куда следует смонтировать файловую систему.

`тип файловой системы`::
Тип файловой системы, который передается программе man:mount[8]. По умолчанию FreeBSD использует `ufs`.

`опции`::
Например, `rw`, для монтирования файловой системы в режиме "чтение-запись", или `ro`, для режима "только чтение", за которыми могут следовать и другие опции. Довольно часто используется опция `noauto`, чтобы не монтировать автоматически файловые системы в процессе загрузки. Об остальных опциях можно прочитать в man:mount[8].

`частота дампов`::
Используется утилитой man:dump[8] для определения файловых систем, с которых необходимо периодически снимать специальные архивные копии. При отсутствии этого параметра принимается равным нулю.

`порядок проверки`::
Определяет порядок, в котором следует проверять файловые системы (чаще всего, в случае некорректного размонтирования или внезапной перезагрузки системы). Если файловую системы не нужно проверять, этот параметр должен быть установлен в ноль. Для корневой файловой системы (которая должна быть проверена в первую очередь) установите его в 1. Для всех остальных - 2 или больше. Если две или более файловые системы имеют одинаковое значение `passno`, man:fsck[8] попытается проверять их параллельно (если, конечно, это возможно физически).

Обратитесь к man:fstab[5] за дополнительной информацией о формате файла [.filename]#/etc/fstab# и различных опциях монтирования.

[[disks-mount]]
=== Команда `mount`

Команда man:mount[8] используется, как следует из ее имени, для монтирования файловых систем.

Пример использования (простейший случай):

[example]
====

[source,bash]
....
# mount устройство точка-монтирования
....

====

Перечислим основные опции, которые может принимать команда man:mount[8] (полный список смотрите на странице справочника):

.Опции монтирования
`-a`::
Смонтировать все файловые системы, перечисленные в файле [.filename]#/etc/fstab#. Исключение составляют помеченные как "noauto", перечисленные после опции `-t` и уже смонтированные.

`-d`::
Сделать все, кроме самого системного вызова mount. Эта опция полезна вместе с флагом `-v` для определения того, что на самом деле пытается сделать man:mount[8].

`-f`::
Монтировать поврежденный раздел (опасно!), или форсировать отмену всех запросов на запись при изменении режима монтирования с "чтение-запись" на "только чтение".

`-r`::
Монтировать файловую систему в режиме "только для чтения". То же самое, что и указание аргумента `ro` для опции `-o`.

`-t` _fstype_::
Монтировать файловую систему как систему указанного типа, или, в случае опции `-a`, только файловые системы данного типа.
+
По умолчанию, тип файловой системы - "ufs".

`-u`::
Обновить опции монтирования для файловой системы.

`-v`::
Выдавать более подробную информацию.

`-w`::
Монтировать файловую систему в режиме "чтение-запись".

Опция `-o` принимает разделенные запятыми аргументы, включая нижеперечисленные:

noexec::
Запрет на исполнение бинарных файлов на файловой системе (тоже полезная опция для повышения безопасности системы).

nosuid::
Игнорировать setuid и setgid биты на файловой системе (еще одна полезная опция для повышения безопасности системы).

[[disks-umount]]
=== Команда `umount`

Команда man:umount[8] принимает в качестве параметра точку монтирования какой-либо файловой системы, имя устройства, опцию `-a` или `-A`.

Кроме того, вы можете дополнительно указать опцию `-f` для форсированного размонтирования файловой системы, и `-v` для получения более подробной информации. Имейте ввиду, что это в общем случае опасно и потому не рекомендуется, так как тем самым вы можете нарушить работу компьютера или повредить данные на файловой системе.

Опции `-a` и `-A` используются для размонтирования всех файловых систем (разве что вы укажете опцию `-t`). Разница состоит в том, что `-A` не пытается размонтировать корневую файловую систему.

[[basics-processes]]
== Процессы

FreeBSD является многозадачной операционной системой. Это означает, что одновременно может быть запущена более чем одна программа. Каждая программа, работающая в некоторый момент времени, называется _процессом_. Каждая команда, которую вы запускаете, порождает хотя бы один процесс. Есть несколько системных процессов, запущенных все время и поддерживающих функциональность системы.

У каждого процесса есть уникальный номер, называемый _process ID_, или _PID_, и, как и у файлов, у каждого процесса есть владелец и группа. Информация о владельце и группе процесса используется для определения того, какие файлы и устройства могут быть открыты процессом с учетом прав на файлы, о которых говорилось ранее. Также у большинства процессов есть родительский процесс. Например, при запуске команд из оболочки, оболочка является процессом и любая запущенная команда также является процессом. Для каждого запущенного таким путем процесса оболочка будет являться родительским процессом. Исключением из этого правила является специальный процесс, называемый man:init[8]. `init` всегда первый процесс, его PID всегда 1. `init` запускается автоматически ядром во время загрузки FreeBSD.

Две команды очень полезны для просмотра работающих в системе процессов, это man:ps[1] и man:top[1]. Команда `ps` используется для получения списка запущенных процессов и может показать их PID, сколько памяти они используют, команду, которой они были запущены и т.д. Команда `top` показывает запущенные процессы и обновляет экран каждые несколько секунд, что позволяет наблюдать за работой компьютера в реальном времени.

По умолчанию, `ps` показывает только принадлежащие вам процессы. Например:

[source,bash]
....
% ps
  PID  TT  STAT      TIME COMMAND
  298  p0  Ss     0:01.10 tcsh
 7078  p0  S      2:40.88 xemacs mdoc.xsl (xemacs-21.1.14)
37393  p0  I      0:03.11 xemacs freebsd.dsl (xemacs-21.1.14)
48630  p0  S      2:50.89 /usr/local/lib/netscape-linux/navigator-linux-4.77.bi
48730  p0  IW     0:00.00 (dns helper) (navigator-linux-)
72210  p0  R+     0:00.00 ps
  390  p1  Is     0:01.14 tcsh
 7059  p2  Is+    1:36.18 /usr/local/bin/mutt -y
 6688  p3  IWs    0:00.00 tcsh
10735  p4  IWs    0:00.00 tcsh
20256  p5  IWs    0:00.00 tcsh
  262  v0  IWs    0:00.00 -tcsh (tcsh)
  270  v0  IW+    0:00.00 /bin/sh /usr/X11R6/bin/startx -- -bpp 16
  280  v0  IW+    0:00.00 xinit /home/nik/.xinitrc -- -bpp 16
  284  v0  IW     0:00.00 /bin/sh /home/nik/.xinitrc
  285  v0  S      0:38.45 /usr/X11R6/bin/sawfish
....

Как вы можете видеть в данном примере, вывод man:ps[1] организован в несколько колонок. Идентификатор процесса `PID` обсуждался ранее. PID назначаются с 1 до 99999 и опять с начала, если последнее число будет превышено (однажды выданный и используемый PID не может быть назначен повторно). Колонка `TT` показывает терминал (tty), на котором запущена программа (можете пока забыть про это). `STAT` показывает состояние программы и опять же может быть пока проигнорирован. `TIME` это количество времени центрального процессора, использованное программой - это обычно не время, прошедшее с запуска программы, поскольку большинство программы проводят много времени в ожидании некоторого события перед тем, как занять время процессора. Наконец, `COMMAND` это команда, которой программа была запущена.

У man:ps[1] есть множество различных опций, влияющих на выводимую информацию. Один из наиболее полезных наборов опций это `auxww`. `a` позволяет показать информацию о всех запущенных процессах, а не только тех, которыми вы владеете. `u` показывает имя пользователя, владеющего процессом, и информацию об используемой памяти. `x` показывает информацию о процессах-даемонах и `ww` указывает man:ps[1] показать всю командную строку для каждого процесса, вместо обрезания ее, когда она станет слишком длинной, чтобы уместиться на экран.

Вывод man:top[1] похож на только что описанный. Обычно он выглядит так:

[source,bash]
....
% top
last pid: 72257;  load averages:  0.13,  0.09,  0.03    up 0+13:38:33  22:39:10
47 processes:  1 running, 46 sleeping
CPU states: 12.6% user,  0.0% nice,  7.8% system,  0.0% interrupt, 79.7% idle
Mem: 36M Active, 5256K Inact, 13M Wired, 6312K Cache, 15M Buf, 408K Free
Swap: 256M Total, 38M Used, 217M Free, 15% Inuse

  PID USERNAME PRI NICE  SIZE    RES STATE    TIME   WCPU    CPU COMMAND
72257 nik       28   0  1960K  1044K RUN      0:00 14.86%  1.42% top
 7078 nik        2   0 15280K 10960K select   2:54  0.88%  0.88% xemacs-21.1.14
  281 nik        2   0 18636K  7112K select   5:36  0.73%  0.73% XF86_SVGA
  296 nik        2   0  3240K  1644K select   0:12  0.05%  0.05% xterm
48630 nik        2   0 29816K  9148K select   3:18  0.00%  0.00% navigator-linu
  175 root       2   0   924K   252K select   1:41  0.00%  0.00% syslogd
 7059 nik        2   0  7260K  4644K poll     1:38  0.00%  0.00% mutt
...
....

Вывод разбит на два раздела. Заголовок (первые пять строк) показывает PID последнего запущенного процесса, среднее значение загрузки системы (которое показывает насколько система занята), время работы системы с последней перезагрузки и текущее время. Другие цифры заголовка относятся к количеству запущенных процессов (в данном примере 47), количеству занятой памяти и подкачки и время, занимаемое различными состояниями процессора.

Ниже идут несколько колонок, содержащих похожую на вывод man:ps[1] информацию. Как и раньше, это PID, время процессора, командная строка. man:top[1] показывает также величину занятой процессом памяти. Это значение разбито на две колонки, одна для общего объема, а другая для резидентного - общий объем показывает сколько всего памяти нужно приложению, а резидентный показывает количество памяти, используемой в данный момент. Из этого примера видно, что man:getenv[3] требует почти 30 MB памяти, но в данный момент использует только 9 MB.

man:top[1] автоматически обновляет экран каждые две секунды; это значение можно изменить опцией `s`.

[[basics-daemons]]
== Даемоны, сигналы, уничтожение процессов

Если вы запускаете редактор, им можно легко управлять, открывать в нем файлы и т.д. Вы можете делать это, поскольку редактор предоставляет такие возможности и потому, что редактор присоединен к _терминалу_. Некоторые программы разработаны без поддержки интерфейса пользователя, поэтому они отсоединяются от терминала при первой возможности. Например, веб-сервер целый день отвечает на запросы из сети, и ему как правило не требуется ваше вмешательство. Программы, передающие почту от сервера к серверу - другой пример приложений этого класса.

Мы называем эти программы _даемонами_. Даемоны это персонажи греческой мифологии: хорошие или плохие, они были спутниками человека и, вообще говоря, выполняли полезную работу для людей, почти как веб- и почтовые серверы выполняют полезную работу сегодня. Это причина, по которой талисманом BSD долгое время является веселый даемон в кедах и с вилами.

Есть соглашение, по которому имя программы, которая обычно запускается как даемон, заканчивается на "d". BIND это Berkeley Internet Name Domain, а выполняемая программа называется `named`; программа веб сервера Apache называется `httpd`; даемон очереди печати это `lpd` и так далее. Это соглашение, а не жесткое правило; например, главный почтовый даемон для Sendmail называется `sendmail`, а не `maild`, как вы могли бы предположить.

Иногда может потребоваться взаимодействие с процессом даемона. Один из способов взаимодействия с процессом даемона (или с любым другим запущенным процессом) - это посылка ему так называемого _сигнала_. Есть множество различных сигналов - некоторые из них имеют специальное значение, другие обрабатываются приложением, реакция которого на эти сигналы должна быть описана в документации. Вы можете посылать сигналы только тем процессам, владельцем которых являетесь. Если вы отправите сигнал какому-то другому процессу с помощью man:kill[1] или man:kill[2], доступ будет запрещен. Исключением из правил является пользователь `root`, который может отправлять сигналы любому процессу.

В некоторых случаях FreeBSD тоже посылает сигналы приложениям. Если приложение плохо написано и пробует обратиться к области памяти, к которой оно не должно обращаться, FreeBSD посылает процессу сигнал _нарушение сегментации_ (`SIGSEGV`). Если приложение использует системный вызов man:alarm[3], чтобы получить уведомление по истечении определенного периода времени, будет отправлен сигнал Alarm (`SIGALRM`) и т.д.

Два сигнала могут быть использованы для завершения процесса, `SIGTERM` и `SIGKILL`. `SIGTERM` это корректный способ завершить процесс; процесс может _поймать_ сигнал, определить, что его хотят завершить, закрыть любые файлы, которые он мог открыть, и закончить то, что он делал в момент перед закрытием. В некоторых случаях процесс может даже игнорировать `SIGTERM`, если выполняет задачу, которая не может быть прервана.

`SIGKILL` не может быть проигнорирован процессом. Этот сигнал говорит "Меня не волнует что ты делаешь - остановись немедленно". Если вы посылаете процессу `SIGKILL`, FreeBSD сразу же остановит этот процесс.

Другие сигналы, которые возможно вам понадобятся, `SIGHUP`, `SIGUSR1`, и `SIGUSR2`. Это сигналы общего назначения, различные приложения могут по-разному реагировать на них.

Предположим, что вы изменили файл конфигурации веб сервера - теперь нужно указать ему перечитать конфигурацию. Можно остановить и запустить `httpd`, но это приведет к кратковременной остановке сервера, которая может быть нежелательна. Большинство даемонов написаны так, чтобы при получении сигнала `SIGHUP` перечитывать файлы конфигурации. Поэтому вместо уничтожения и запуска `httpd` можно послать сигнал `SIGHUP`. Поскольку нет стандартного способа реагирования на этот сигнал, различные даемоны будут вести себя по разному; прочитайте документацию на даемон по этому вопросу.

Сигналы посылаются с помощью команды man:kill[1], как показано в этом примере.

[.procedure]
====
*Procedure: Отправка сигнала процессу*

Этот пример показывает как послать сигнал man:inetd[8]. Файл конфигурации `inetd`[.filename]#/etc/inetd.conf#, `inetd` перечитает этот файл, если ему отправить сигнал `SIGHUP`.

. Нужно определить PID процесса, которому вы хотите отправить сигнал. Сделайте это с помощью man:ps[1] и man:grep[1]. Команда man:grep[1] используется для поиска по заданной строке в выходном потоке. Эта команда запускается под обычным пользователем, а man:inetd[8] под `root`, поэтому man:ps[1] должна быть запущена с параметром `ax`.
+
[source,bash]
....
% ps -ax | grep inetd
  198  ??  IWs    0:00.00 inetd -wW
....
+ 
Итак, PID man:inetd[8] 198. В некоторых случаях в выводе команды может также появиться `grep inetd`. Это из-за способа, которым man:ps[1] получает список запущенных процессов.
. Используйте man:kill[1] для отправки сигнала. Поскольку man:inetd[8] запускается из под `root`, нужно сначала использовать man:su[1] для получения прав `root`.
+
[source,bash]
....
% su
Password:
# /bin/kill -s HUP 198
....
+ 
Как и большинство команд UNIX(R), man:kill[1] ничего не выведет, если отработает нормально. Если вы посылаете сигнал процессу, которым не владеете, на экране появится `kill: _PID_: Operation not permitted`. При неправильно набранном PID вы или отправите сигнал другому процессу, что может привести к неприятностям, или, если повезет, сигнал будет отправлен на PID, который в данный момент не используется - на экране появится `kill: _PID_: No such process`.
+
[NOTE]
.Зачем использовать `/bin/kill`?
======
Во многих оболочках команда `kill` встроена; таким образом, оболочка вместо вызова [.filename]#/bin/kill# сама посылает сигнал. Это может быть очень полезно, но в разных оболочках имя сигнала указывается по-разному. Чем пытаться выучить их все, гораздо проще использовать `/bin/kill _..._` непосредственно.
======
====

Отправка других сигналов очень похожа, просто замените `TERM` или `KILL` в командной строке на имя другого сигнала.

[IMPORTANT]
====
Уничтожение процессов наугад может быть плохой идеей. В частности, man:init[8], чей PID 1, имеет особое значение. Выполнение `/bin/kill -s KILL 1` - быстрый способ перегрузить систему. _Всегда_ дважды проверяйте параметры запуска man:kill[1] _перед_ тем, как нажать kbd:[Enter].
====

[[shells]]
== Интерпретатор команд

При работе с FreeBSD, в большинстве случаев для выполнения повседневных задач используется командный интерфейс (так называемая "оболочка", "shell"). Основная задача интерпретатора - принимать вводимые команды и выполнять их. Многие командные интерпретаторы имеют встроенные средства для выполнения повседневной работы, например, операции над файлами и каталогами, редактирование командной строки, командные макросы и переменные окружения. Вместе с FreeBSD поставляется несколько командных интерпретаторов, например, `sh`, или Bourne Shell, и `tcsh`, расширенная версия C-shell. Многие другие интерпретаторы доступны из коллекции портов FreeBSD, например `zsh` и `bash`.

Какой из командных интерпретаторов использовать? Это дело вкуса. Если вы программируете на C, то вам, возможно, понравится `tcsh`. Если вы работали с Linux, или только начинаете работать с интерфейсом командной строки UNIX(R), попробуйте `bash`. Каждый из названных интерпретаторов имеет свои особенности, которые отличат его от других, и, возможно, повлияют на ваш выбор.

Одна из наиболее часто используемых функций командного интерпретатора - дополнение частичного имени файла до полного. Вы можете набрать только первые несколько символов имени файла, нажать клавишу табуляции (TAB), и командный интерпретатор автоматически завершит имя. Например, у нас есть два файла, названные [.filename]#foobar# и [.filename]#foo.bar#. Допустим, мы хотим удалить файл [.filename]#foo.bar#. Для этого, наберем на клавиатуре `rm fo[Tab].[Tab]`.

Вы увидите следующее: `rm foo[BEEP].bar`.

Здесь [BEEP] - это так называемый консольный сигнал, оповещающий о том, что интерпретатор не в состоянии закончить имя файла, так как по введенным вами символам невозможно однозначно идентифицировать файл. Например, имена файлов [.filename]#foobar# и [.filename]#foo.bar# оба начинаются с `fo`, но после нажатия TAB можно однозначно дополнить только до `foo`. Если же теперь ввести точку (`.`) и вновь нажать TAB, интерпретатор достроит имя файла целиком.

Дополнительные возможности при работе с интерпретатором дает использование переменных окружения. Переменные окружения это пары переменная/значение, хранящиеся в памяти интерпретатора. Значение переменных окружения может быть прочитано любой программой, запущенной из командного интерпретатора, и часто содержит настройки для многих приложений и утилит. Ниже приведены некоторые наиболее часто встречающиеся переменные окружения и их значения:

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Переменная
| Описание

|`USER`
|Имя текущего пользователя.

|`PATH`
|Каталоги, разделенные двоеточием, для поиска исполняемых файлов.

|`DISPLAY`
|Сетевое имя виртуального дисплея X11, доступного для подключения.

|`SHELL`
|Текущий командный интерпретатор.

|`TERM`
|Тип терминала пользователя. Используется, чтобы узнать возможности терминала.

|`TERMCAP`
|Список escape-последовательностей для управления различными функциями терминала.

|`OSTYPE`
|Название (тип) операционной системы. Например, FreeBSD.

|`MACHTYPE`
|Архитектура машины (процессора).

|`EDITOR`
|Выбранный пользователем текстовый редактор.

|`PAGER`
|Выбранная пользователем утилита просмотра файлов.

|`MANPATH`
|Каталоги, разделенные двоеточием, для поиска файлов системного справочника.
|===

Установка значений переменных окружения различна для разных оболочек. Например, в интерпретаторах C-стиля, таких как `tcsh` и `csh`, это `setenv`. В интерпретаторах Bourne, таких как `sh` и `bash`, это `export`. Например, чтобы установить или изменить значение переменной `EDITOR` к значению [.filename]#/usr/local/bin/emacs# в `csh` или `tcsh`, выполните команду:

[source,bash]
....
% setenv EDITOR /usr/local/bin/emacs
....

В оболочках Bourne:

[source,bash]
....
% export EDITOR="/usr/local/bin/emacs"
....

Чтобы получить значение переменной, например, в командной строке, поместите символ `$` перед именем переменной. Например, команда `echo $TERM` выведет значение переменной `$TERM`.

Командный интерпретатор воспринимает некоторые символы, называемые метасимволами, в качестве управляющих. Один из наиболее часто используемых - символ `\*`, который заменяет любое количество символов в имени файла. Метасимволы используются для поиска файлов по маске, например, команда `echo *` делает практически тоже самое, что и команда `ls`, поскольку интерпретатор вызывает команду `echo`, передавая ей имена всех файлов, попадающих под маску `*`.

В некоторых ситуациях требуется, чтобы интерпретатор воспринимал метасимволы как обычные, не несущие специальной смысловой нагрузки. Этого можно достичь, поставив перед символом обратную косую черту (`\`). Например, команда `echo $TERM` выведет тип вашего терминала, в то же время команда `echo \$TERM` выведет именно слово `$TERM`, а не значение переменной `$TERM`.

[[changing-shells]]
=== Как изменить командный интерпретатор по умолчанию

Самым простым способом, пожалуй, будет воспользоваться командой `chsh`. Если переменная `EDITOR` определена, то будет загружен соответствующий текстовый редактор, иначе vi. Вам нужно будет изменить значение поля "Shell:" и выйти из редактора с сохранением результатов.

Можно также воспользоваться опцией `-s` команды `chsh`. Например, если вы хотите изменить интерпретатор на `bash`, выполните:

[source,bash]
....
% chsh -s /usr/local/bin/bash
....

[NOTE]
====
Интерпретатор, который вы будете использовать, _обязательно_ должен быть в файле [.filename]#/etc/shells#. Обычно, при установке интерпретаторов из crossref:ports[ports,коллекции портов], это делается автоматически. Если же это не так, вам нужно будет самостоятельно добавить соответствующую строчку в этот файл.

Например, если вы установили `bash` вручную и поместили его в каталог [.filename]#/usr/local/bin#, нужно набрать:

[source,bash]
....
# echo "/usr/local/bin/bash" >> /etc/shells
....

Теперь можно смело использовать команду `chsh`.
====

[[editors]]
== Текстовые редакторы

Большинство настроек в FreeBSD производится путем редактирования текстовых файлов. Соответственно, вам нужно будет освоиться с каким-либо текстовым редактором. Вместе с FreeBSD поставляются лишь некоторые из них, гораздо больше редакторов доступно из Коллекции портов.

Самым простым в изучении и использовании, по-видимому, можно назвать ee, что расшифровывается как "easy editor", т.е. "простой редактор". Чтобы начать редактировать какой-либо файл, наберите в командной строке `ee _filename_`, где _filename_ имя редактируемого файла. Например, для редактирования файла [.filename]#/etc/rc.conf#, наберите `ee /etc/rc.conf`. В верхней части экрана вы увидите список основных команд редактора. Символ каретки (`^`) означает клавишу kbd:[Ctrl], таким образом, `^e` означает комбинацию клавиш kbd:[Ctrl+e]. Чтобы выйти из редактора, нажмите клавишу kbd:[Esc], затем kbd:[Enter]. Если остались какие-либо не сохраненные данные, вам потребуется подтвердить выход, сохранив результат работы или оставив файл без изменения.

В FreeBSD присутствует также более мощный текстовый редактор vi, а редакторы emacs и vim можно найти в коллекции портов (package:editors/emacs[] и package:editors/vim[]). Эти редакторы обладают еще большей функциональностью и мощью, но они также и более сложны в изучении. Однако, если в будущем вам потребуется часто редактировать большие объемы текстов, то время, потраченное на изучение более мощного редактора, такого как vim или Emacs, окупится с лихвой.

Многие приложения, модифицирующие файлы или требующие текстового ввода, автоматически открывают текстовый редактор. Чтобы сменить используемый по умолчанию редактор, установите переменную окружения `EDITOR`. За деталями обратитесь к разделу <<shells,интерпретатор команд>>.

[[basics-devices]]
== Устройства и файлы устройств

Термин "устройство" используется в основном по отношению к аппаратному обеспечению системы, такому как диски, принтеры, графические адаптеры, устройства ввода текста. При загрузке FreeBSD главным образом выводит на экран информацию об обнаруженных устройствах. Вы можете найти эти сообщения в файле [.filename]#/var/run/dmesg.boot#.

Например, [.filename]#acd0# это первый диск IDE CDROM, а [.filename]#kbd0# - клавиатура.

В UNIX(R) доступ к большинству этих устройств можно получить через специальные файлы устройств, расположенные в каталоге [.filename]#/dev#.

=== Создание файлов устройств

При добавлении в систему нового устройства, или добавлении поддержки дополнительных устройств, потребуется создать один или несколько файлов устройств для нового оборудования.

==== `DEVFS` (DEVice File System)

Device filesystem, или `DEVFS`, предоставляет доступ к пространству устройств ядра через общую файловую систему. Вместо создания и модификации файлов устройств, `DEVFS` создает специальную файловую систему.

Обращайтесь к man:devfs[5] за дополнительной информацией.

[[binary-formats]]
== Бинарные форматы

Для понимания того, почему FreeBSD использует формат man:elf[5], вам потребуется сначала немного узнать о трех "доминирующих" исполняемых форматах для UNIX(R):

* man:a.out[5]
+ 
Старейший и "классический" объектный формат UNIX(R). Он использует короткий и компактный заголовок с магическим числом в начале, которое часто используется для описания формата (смотрите man:a.out[5] с более подробной информацией). Он содержит три загружаемых сегмента: .text, .data и .bss плюс таблицу символов и таблицу строк.
* COFF
+ 
Объектный формат SVR3. Заголовок включает таблицу разделов, так что могут быть сегменты кроме .text, .data и .bss.
* man:elf[5]
+ 
Наследник формата COFF, поддерживающий множественные сегменты и 32-битные или 64-битные значения. Одно важное замечание: ELF был разработан в предположении что есть только по одному ABI на одну архитектуру. Это предположение совершенно неверно, и не только в мире коммерческих SYSV (в котором есть как минимум три ABI: SVR4, Solaris, SCO).
+ 
FreeBSD пытается обойти эту проблему, в частности предоставляя утилиту для _оглавления_ известного исполняемого файла ELF информацией об ABI с которым он совместим. Обратитесь к странице справочника man:brandelf[1] за более подробной информацией.

FreeBSD имеет произошла из "классического" лагеря и использовала формат man:a.out[5], технологию опробованную и проверенную на многих поколениях релизов BSD, до начала ветки 3.X. Хотя собирать и запускать родные бинарные файлы ELF (и ядро) в системе FreeBSD можно было несколько раньше, FreeBSD вначале сопротивлялась "проталкиванию"ELF как формата по умолчанию. Почему? Когда лагерь Linux производил болезненный переход к ELF, у него не было большого преимущества перед исполняемым форматом [.filename]#a.out#, из-за негибкого, основанного на таблице переходов механизма разделяемых библиотек, что делало создание разделяемых библиотек очень трудным для поставщиков и разработчиков. Когда доступные инструменты ELF предоставили решение проблемы разделяемых библиотек, и появилась некоторая перспектива, цена перехода была признана допустимой и он был сделан. Механизм разделяемых библиотек FreeBSD близок по стилю к механизму разделяемых библиотек SunOS(TM) от Sun, и поэтому очень прост в использовании.

Итак, почему так много разных форматов?

Давно, в темном далеком прошлом, оборудование было простым. Это простое оборудование поддерживало простые, маленькие системы. [.filename]#a.out# был совершенно адекватен задаче представления бинарных файлов на таких простых системах (PDP-11). Люди, портировавшие UNIX(R) с этих простых систем, оставили [.filename]#a.out# формат потому, что он был достаточен для ранних портов UNIX(R) на архитектуры, подобные Motorola 68k, VAXen, etc.

Затем какой-то смышленый инженер по оборудованию решил, что если он сможет заставить программы исполнять некоторые трюки, то сможет несколько упростить дизайн и заставить ядро CPU работать быстрее. Хотя это было сделано с новым типом оборудования (известного сейчас как RISC), формат [.filename]#a.out# не подходил для него, и было разработано множество форматов, чтобы получить лучшую производительность на таком оборудовании по сравнению с той, которую мог предоставить простой формат [.filename]#a.out#. Были изобретены форматы COFF, ECOFF и некоторые другие малоизвестные форматы, и их ограничения были учтены, когда все похоже остановились на ELF.

Кроме того, размеры программ стали огромны, а диски (и оперативная память) остались относительно малы, поэтому появилась концепция разделяемых библиотек. Система VM также стала более сложной. Хотя все эти усовершенствования были выполнены с форматом [.filename]#a.out#, его полезность все больше и больше уменьшалась с каждым нововведением. К тому же потребовалась динамическая загрузка во время выполнения, или выгрузка частей программы после выполнения стартового кода для экономии памяти или места на диске. Языки усложнялись, и потребовался автоматический вызов кода перед главной программой. Множество изменений было внесено в формат [.filename]#a.out#, чтобы все это появилось, и в основном работало некоторое время. Настал момент, когда [.filename]#a.out# не смог решить все эти проблемы без чрезмерного увеличения размера и сложности. В то время, как ELF решил многие из этих проблем, перевод этого формата с системы на систему болезнен. Поэтому формату ELF пришлось подождать, пока не стало более болезненным оставаться с [.filename]#a.out#, чем перейти на ELF.

Тем временем, инструменты разработки, от которых произошли инструменты разработки FreeBSD (особенно ассемблер и загрузчик), развивались в двух параллельных направлениях. Направление FreeBSD добавило разделяемые библиотеки и устранило некоторые ошибки. Люди из GNU, написавшие эти программы, переписали их и добавили простую поддержку сборки кросс-компиляторов, подключения различных форматов в будущем и так далее. Многим требовалось собрать кросс-компиляторы для FreeBSD, и это не удалось, поскольку устаревшие исходные тексты FreeBSD для as и ld не подходили для этой задачи. Новый набор инструментов GNU (binutils) поддерживает кросс-компилирование, ELF, разделяемые библиотеки, C++, расширения и т.д. В дополнение, многие поставщики выпустили программы в формате ELF и они хорошо подходят для запуска в FreeBSD.

ELF более выразителен, чем [.filename]#a.out#, позволяет базовой системе быть более гибкой. ELF лучше поддерживается, и предоставляет поддержку кросс-компиляторов, что важно для многих людей. ELF может быть немного медленнее, чем [.filename]#a.out#, но замерить это сложно. Есть также множество деталей, отличающихся для этих двух форматов, в том как они отображают страницы, обрабатывают начальный код, и т.д. В этом нет ничего очень важного, но они различаются. В настоящее время поддержка [.filename]#a.out# убрана из ядра [.filename]#GENERIC#, и со временем будет убрана из ядра, как только потребность в запуске старых программ [.filename]#a.out# останется в прошлом.

[[basics-more-information]]
== Дополнительная информация

[[basics-man]]
=== Системный справочник (man)

Пожалуй, самым полным руководством по FreeBSD является системный справочник (man). Практически каждое приложение или утилита имеют соответствующую страницу (часто не одну), описывающую тот или иной аспект работы программы, всевозможные опции и настройки. Для просмотра этих страниц существует команда `man`:

[source,bash]
....
% man command
....

Здесь `command` - это команда, о которой вы хотите получить информацию. Например, чтобы узнать побольше о команде `ls`, наберите:

[source,bash]
....
% man ls
....

Содержимое системного справочника для удобства разделено на несколько разделов:

. Пользовательские команды.
. Системные вызовы и коды ошибок.
. Функции стандартных библиотек.
. Драйверы устройств.
. Форматы файлов.
. Развлечения и игры.
. Дополнительная информация.
. Команды системного администрирования.
. Для разработчиков ядра.

В некоторых случаях (не так уж редко), страницы, относящиеся к одной и той же команде, находятся в различных разделах справочника. Например, есть команда `chmod` и системный вызов `chmod()`. В этом случае, необходимо явно указать раздел `man`, в котором нужно искать соответствующую страницу:

[source,bash]
....
% man 1 chmod
....

Эта команда выведет справку об утилите `chmod`. По традиции, конкретный раздел справочника указывается в скобках после команды, например, man:chmod[1] относится к утилите `chmod`, а man:chmod[2] - к соответствующему системному вызову.

Часто бывает так, что вы не знаете название команды, но имеете представление о том, что она должна делать. В этом случае можно попытаться найти нужную команду по ключевым словам, встречающимся в ее описании, используя опцию `-k` программы `man`:

[source,bash]
....
% man -k mail
....

Вы получите список команд, имеющих слово "mail" в своих описаниях. Это эквивалентно использованию команды `apropos`.

Или например, вы видите список файлов в каталоге [.filename]#/usr/bin#, при этом не имея ни малейшего представления о том, какие функции выполняет каждый их них? Просто наберите:

[source,bash]
....
% cd /usr/bin
% man -f *
....

или

[source,bash]
....
% cd /usr/bin
% whatis *
....

что фактически одно и то же.

[[basics-info]]
=== Файлы GNU Info

FreeBSD поставляется с многочисленными приложениями и утилитами от Фонда Свободного Программного Обеспечения, Free Software Foundation (FSF). В дополнение к страницам справочника, с этими программами поставляется обширная гипертекстовая документация в виде так называемых `info` файлов, которые могут быть просмотрены с помощью команды `info`, или, если установлен emacs, в info режиме этого редактора.

Чтобы воспользоваться командой man:info[1], просто наберите в командной строке:

[source,bash]
....
% info
....

Вызвать на экран краткое введение можно набрав `h`. Краткий список команд можно получить набрав `?`.
