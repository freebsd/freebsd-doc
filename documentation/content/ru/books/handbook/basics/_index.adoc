---
description: 'Основные команды и функциональные возможности операционной системы FreeBSD'
next: books/handbook/ports
params:
  path: /books/handbook/basics/
part: 'В начале'
prev: books/handbook/bsdinstall
showBookMenu: 'true'
tags: ["basics", "virtual consoles", "users", "management", "permissions", "directory structure", "disk organization", "mounting", "processes", "daemons", "shell", "editor", "manual pages", "devices"]
title: 'Глава 3. Основы FreeBSD'
weight: 5
---

[[basics]]
= Основы FreeBSD
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 3
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/basics/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[basics-synopsis]]
== Обзор

В этой главе рассматриваются основные команды и функциональные возможности операционной системы FreeBSD. Большая часть материала применима к любым UNIX(R)-подобным операционным системам. Новым пользователям FreeBSD рекомендуется внимательно ознакомиться с этой главой.

Прочитав эту главу, вы будете знать:

* Как использовать и настраивать виртуальные консоли.
* Как создавать пользователей и группы пользователей во FreeBSD и управлять ими.
* Как работают права доступа на файлы в UNIX® и файловые флаги во FreeBSD.
* Иерархию каталогов FreeBSD.
* Организация дисков в FreeBSD.
* Как монтировать и размонтировать файловые системы.
* Что такое процессы, демоны и сигналы.
* Что такое оболочка и как изменить среду входа по умолчанию.
* Как использовать основные текстовые редакторы.
* Что такое устройства и узлы устройств.
* Как читать справочные страницы для получения дополнительной информации.

[[consoles]]
== Виртуальные консоли и терминалы

Если FreeBSD не настроена для автоматического запуска графической среды во время загрузки, система загрузится в командную строку с приглашением для входа, как показано в этом примере:

[.programlisting]
....
FreeBSD/amd64 (pc3.example.org) (ttyv0)

login:
....

Первая строка содержит некоторую информацию о системе. `amd64` указывает, что FreeBSD работает на 64-битной x86 системе. Имя хоста — `pc3.example.org`, а `ttyv0` означает, что это «системная консоль». Вторая строка — это приглашение для входа в систему.

Поскольку FreeBSD — это многопользовательская система, требуется способ различать пользователей. Для этого необходимо, чтобы каждый пользователь вошел в систему перед получением доступа к программам. У каждого пользователя есть уникальное «имя пользователя» и личный «пароль».

Для входа в системную консоль введите имя пользователя, заданное при установке системы, как описано в crossref:bsdinstall[bsdinstall-addusers,Добавление пользователей], и нажмите kbd:[Enter]. Затем введите пароль, связанный с этим именем пользователя, и нажмите kbd:[Enter]. Пароль _не отображается_ в целях безопасности.

После ввода правильного пароля будет отображено сообщение дня (MOTD), за которым последует приглашение командной строки. В зависимости от выбранной оболочки при создании пользователя, это приглашение может быть символом `+#+`, `$` или `%`. Приглашение указывает, что пользователь теперь вошел в консоль системы FreeBSD и готов попробовать доступные команды.

[[consoles-virtual]]
=== Виртуальные консоли

Хотя системную консоль можно использовать для взаимодействия с системой, пользователь, работающий из командной строки на клавиатуре FreeBSD, обычно вместо этого входит в виртуальную консоль. Это связано с тем, что системные сообщения по умолчанию настроены на отображение на системной консоли. Эти сообщения будут появляться поверх команды или файла, с которыми работает пользователь, что затрудняет концентрацию на текущей задаче.

По умолчанию FreeBSD настроена для предоставления нескольких виртуальных консолей для ввода команд. Каждая виртуальная консоль имеет собственную приглашение для входа и оболочку, и переключение между виртуальными консолями осуществляется легко. Это, по сути, предоставляет эквивалент командной строки для одновременного открытия нескольких окон в графической среде.

Сочетания клавиш kbd:[Alt+F1] — kbd:[Alt+F8] зарезервированы в FreeBSD для переключения между виртуальными консолями. Используйте kbd:[Alt+F1] для перехода к системной консоли (`ttyv0`), kbd:[Alt+F2] для доступа к первой виртуальной консоли (`ttyv1`), kbd:[Alt+F3] для доступа ко второй виртуальной консоли (`ttyv2`) и так далее. При использовании Xorg в качестве графической консоли для возврата к текстовой виртуальной консоли используется сочетание kbd:[Ctrl+Alt+F1].

При переключении с одной консоли на другую FreeBSD управляет выводом на экран. В результате создаётся иллюзия наличия нескольких виртуальных экранов и клавиатур, которые можно использовать для ввода команд на выполнение в FreeBSD. Программы, запущенные в одной виртуальной консоли, продолжают работать при переключении пользователя на другую виртуальную консоль.

Обратитесь к man:kbdcontrol[1], man:vidcontrol[1], man:atkbd[4], man:syscons[4] и man:vt[4] для более технического описания консоли FreeBSD и её драйверов клавиатуры.

В FreeBSD количество доступных виртуальных консолей настраивается в этом разделе `/etc/ttys`:

[.programlisting]
....
# name    getty                         type  status comments
#
ttyv0   "/usr/libexec/getty Pc"         xterm   on  secure
# Virtual terminals
ttyv1   "/usr/libexec/getty Pc"         xterm   on  secure
ttyv2   "/usr/libexec/getty Pc"         xterm   on  secure
ttyv3   "/usr/libexec/getty Pc"         xterm   on  secure
ttyv4   "/usr/libexec/getty Pc"         xterm   on  secure
ttyv5   "/usr/libexec/getty Pc"         xterm   on  secure
ttyv6   "/usr/libexec/getty Pc"         xterm   on  secure
ttyv7   "/usr/libexec/getty Pc"         xterm   on  secure
ttyv8   "/usr/X11R6/bin/xdm -nodaemon"  xterm   off secure
....

Чтобы отключить виртуальную консоль, поставьте символ комментария (`+#+`) в начале строки, соответствующей этой виртуальной консоли. Например, чтобы уменьшить количество доступных виртуальных консолей с восьми до четырёх, добавьте `+#+` перед последними четырьмя строками, представляющими виртуальные консоли `ttyv5` до `ttyv8`. _Не_ комментируйте строку системной консоли `ttyv0`. Обратите внимание, что последняя виртуальная консоль (`ttyv8`) используется для доступа к графической среде, если Xorg установлен и настроен, как описано в crossref:x11[x11,Система X Window].

Для подробного описания каждой колонки в этом файле и доступных опций для виртуальных консолей обратитесь к man:ttys[5].

[[consoles-singleuser]]
=== Однопользовательский режим

В меню загрузки FreeBSD есть пункт с названием "Boot Single User". При выборе этого пункта система загрузится в особый режим, известный как "однопользовательский режим". Этот режим обычно используется для восстановления системы, которая не загружается, или для сброса пароля `root`, если он неизвестен. В однопользовательском режиме сеть и другие виртуальные консоли недоступны. Однако предоставляется полный доступ `root` к системе, и по умолчанию пароль `root` не требуется. По этим причинам для загрузки в этом режиме необходим физический доступ к клавиатуре, и определение того, кто имеет такой доступ, является важным аспектом обеспечения безопасности системы FreeBSD.

Настройки, управляющие однопользовательским режимом, находятся в этом разделе файла `/etc/ttys`:

[.programlisting]
....
# name  getty                           type  status  comments
#
# If console is marked "insecure", then init will ask for the root password
# when going to single-user mode.
console none                            unknown  off  secure
....

По умолчанию статус установлен в `secure`. Это предполагает, что тот, кто имеет физический доступ к клавиатуре, либо не важен, либо контролируется политикой физической безопасности. Если этот параметр изменён на `insecure`, предполагается, что среда сама по себе небезопасна, так как любой может получить доступ к клавиатуре. При изменении этой строки на `insecure` FreeBSD будет запрашивать пароль `root`, когда пользователь выбирает загрузку в однопользовательском режиме.

[NOTE]
====
_Будьте осторожны при изменении этой настройки на `insecure`!_ Если пароль `root` забыт, загрузка в однопользовательском режиме всё ещё возможна, но может быть затруднительна для тех, кто не знаком с процессом загрузки FreeBSD.
====

[[consoles-vidcontrol]]
=== Изменение видеорежимов консоли

Режим видео по умолчанию в консоли FreeBSD может быть изменён на 1024x768, 1280x1024 или любой другой, поддерживаемый графическим чипом и монитором. Для использования другого видео режима загрузите модуль `VESA`:

[source, shell]
....
# kldload vesa
....

Для определения видеорежимов, поддерживаемых оборудованием, используйте man:vidcontrol[1]. Чтобы получить список поддерживаемых видеорежимов, выполните следующую команду:

[source, shell]
....
# vidcontrol -i mode
....

Результат выполнения этой команды выводит список видеорежимов, поддерживаемых оборудованием. Чтобы выбрать новый видеорежим, укажите режим с помощью man:vidcontrol[1] от имени пользователя `root`:

[source, shell]
....
# vidcontrol MODE_279
....

Если новый видео-режим приемлем, его можно установить постоянным при загрузке, добавив в `/etc/rc.conf`:

[.programlisting]
....
allscreens_flags="MODE_279"
....

[[users-synopsis]]
== Пользователи и базовая настройка учетных записей

FreeBSD позволяет нескольким пользователям одновременно работать на компьютере. Хотя только один пользователь может находиться перед экраном и использовать клавиатуру в любой момент времени, любое количество пользователей может войти в систему через сеть. Для использования системы каждый пользователь должен иметь свою собственную учетную запись.

Эта глава описывает:

* Типы учетных записей пользователей в системе FreeBSD.
* Как добавлять, удалять и изменять учетные записи пользователей.
* Как установить ограничения для контроля ресурсов, доступных пользователям и группам.
* Как создавать группы и добавлять пользователей в качестве членов группы.

[[users-introduction]]
=== Типы учетных записей

Поскольку весь доступ к системе FreeBSD осуществляется с использованием учетных записей, а все процессы выполняются пользователями, управление пользователями и учетными записями является важным.

Существует три основных типа учетных записей: системные учетные записи, пользовательские учетные записи и учетная запись суперпользователя.

[[users-system]]
==== Системные учетные записи

Системные учетные записи используются для запуска служб, таких как DNS, почтовые и веб-серверы. Причина этого — безопасность: если бы все службы работали от имени суперпользователя, они могли бы действовать без ограничений.

Примеры системных учетных записей: `daemon`, `operator`, `bind`, `news` и `www`.

`nobody` — это общая непривилегированная системная учётная запись. Однако чем больше сервисов используют `nobody`, тем больше файлов и процессов будут связаны с этим пользователем, и, следовательно, тем больше привилегий он получит.

[[users-user]]
==== Пользовательские учетные записи

Пользовательские учетные записи назначаются реальным людям и используются для входа в систему и работы с ней. Каждый человек, получающий доступ к системе, должен иметь уникальную учетную запись. Это позволяет администратору отслеживать, кто и что делает, и предотвращает возможность изменения пользователями настроек друг друга.

Каждый пользователь может настроить свою собственную среду для удобной работы с системой, изменив настройки оболочки по умолчанию, редактора, сочетаний клавиш и языковых параметров.

Каждая учетная запись пользователя в системе FreeBSD имеет определенную связанную с ней информацию:

Имя пользователя::
Имя пользователя вводится в приглашении `login:`. У каждого пользователя должно быть уникальное имя. Существует ряд правил для создания допустимых имен пользователей, которые описаны в man:passwd[5]. Рекомендуется использовать имена, состоящие из восьми или менее строчных символов, для обеспечения обратной совместимости с приложениями.

Пароль::
У каждой учетной записи есть связанный с ней пароль.

Идентификатор пользователя (UID)::
Идентификатор пользователя (UID) — это число, используемое для однозначной идентификации пользователя в системе FreeBSD. Команды, которые позволяют указать имя пользователя, сначала преобразуют его в UID. Рекомендуется использовать UID меньше 65535, так как более высокие значения могут вызвать проблемы совместимости с некоторым программным обеспечением.

Идентификатор группы (GID)::
Идентификатор группы (GID) — это число, используемое для однозначной идентификации основной группы, к которой принадлежит пользователь. Группы представляют собой механизм управления доступом к ресурсам на основе GID пользователя, а не его UID. Это может значительно уменьшить размер некоторых конфигурационных файлов и позволяет пользователям быть членами более чем одной группы. Рекомендуется использовать GID 65535 или меньше, так как более высокие GID могут привести к неработоспособности некоторых программ.

Класс входа (Login class)::
Классы входа являются расширением механизма групп, предоставляющим дополнительную гибкость при настройке системы для различных пользователей. Подробнее классы входа рассматриваются в crossref:security[users-limiting,Настройка классов входа].

Время изменения пароля::
По умолчанию пароли не имеют срока действия. Однако можно включить истечение срока действия пароля для отдельных пользователей, что заставит некоторых или всех пользователей изменить свои пароли по истечении определённого времени.

Время истечения срока действия учетной записи::
По умолчанию FreeBSD не ограничивает срок действия учётных записей. При создании учётных записей с ограниченным сроком действия, например, для учащихся в школе, укажите дату истечения срока с помощью man:pw[8]. После истечения указанного времени учётная запись не может быть использована для входа в систему, хотя каталоги и файлы этой учётной записи останутся.

Полное имя пользователя::
Имя пользователя уникально идентифицирует учетную запись в FreeBSD, но не обязательно отражает реальное имя пользователя. Как и в случае с комментарием, эта информация может содержать пробелы, заглавные буквы и быть длиннее 8 символов.

Домашний каталог::
Домашний каталог — это полный путь к каталогу в системе. Это стартовый каталог пользователя при входе в систему. Общепринятое соглашение — размещать все домашние каталоги пользователей в `/home/имя_пользователя` или `/usr/home/имя_пользователя`. Каждый пользователь хранит свои личные файлы и подкаталоги в собственном домашнем каталоге.

Оболочка пользователя::
Оболочка предоставляет пользователю среду по умолчанию для взаимодействия с системой. Существует множество различных видов оболочек, и опытные пользователи могут выбрать предпочтительную, настроив её в параметрах своей учётной записи.

[[users-superuser]]
==== Учетная запись суперпользователя

Учетная запись суперпользователя, обычно называемая `root`, используется для управления системой без ограничений в правах. По этой причине её не следует использовать для повседневных задач, таких как отправка и получение почты, обычное изучение системы или программирование.

Суперпользователь, в отличие от других учётных записей, может работать без ограничений, и неправильное использование учётной записи суперпользователя может привести к серьёзным последствиям. Обычные пользователи не могут случайно разрушить операционную систему, поэтому рекомендуется входить в систему под обычной учётной записью и становиться суперпользователем только тогда, когда команде требуются дополнительные привилегии.

Всегда дважды и трижды проверяйте команды, выполняемые от имени суперпользователя, поскольку лишний пробел или пропущенный символ могут привести к невосполнимой потере данных.

Существует несколько способов получения привилегий суперпользователя. Хотя можно войти в систему как `root`, это крайне не рекомендуется.

Вместо этого используйте man:su[1], чтобы стать суперпользователем. Если при выполнении этой команды указан параметр `-`, пользователь также унаследует окружение пользователя root. Пользователь, выполняющий эту команду, должен состоять в группе `wheel`, иначе команда завершится ошибкой. Пользователь также должен знать пароль учётной записи `root`.

В этом примере пользователь становится суперпользователем только для выполнения команды `make install`, так как этот шаг требует прав суперпользователя. После завершения команды пользователь вводит `exit`, чтобы выйти из учётной записи суперпользователя и вернуться к правам своей учётной записи.

.Установка программы от имени суперпользователя
[example]
====
[source, shell]
....
% configure
% make
% su -
Password:
# make install
# exit
%
....
====

Встроенная система man:su[1] хорошо подходит для отдельных компьютеров или небольших сетей с одним системным администратором. Альтернативой является установка пакета package:security/sudo[] или порта. Это программное обеспечение обеспечивает журналирование действий и позволяет администратору настроить, какие пользователи могут выполнять определённые команды с правами суперпользователя.

[[users-modifying]]
=== Управление учетными записями

FreeBSD предоставляет различные команды для управления учетными записями пользователей. Наиболее распространенные команды перечислены в crossref:basics[users-modifying-utilities,Утилиты для управления учетными записями пользователей], а также приведены примеры их использования. Для получения дополнительной информации и примеров использования обратитесь к руководству (man) каждой утилиты.

[[users-modifying-utilities]]
.Утилиты для управления учетными записями пользователей
[cols="25h,~"]
|===
| Команда
| Краткое содержание

|man:adduser[8]
|Рекомендуемое приложение командной строки для добавления новых пользователей.

|man:rmuser[8]
|Рекомендуемое приложение командной строки для удаления пользователей.

|man:chpass[1]
|Гибкий инструмент для изменения информации в пользовательской базе данных.

|man:passwd[1]
|Инструмент командной строки для изменения паролей пользователей.

|man:pw[8]
|Мощный и гибкий инструмент для изменения всех аспектов пользовательских учетных записей.

|man:bsdconfig[8]
|Утилита для настройки системы с поддержкой управления учётными записями.
|===

[[users-adduser]]
==== Добавление пользователя

Рекомендуемая программа для добавления новых пользователей — man:adduser[8]. При добавлении нового пользователя эта программа автоматически обновляет `/etc/passwd` и `/etc/group`. Она также создаёт домашний каталог для нового пользователя, копирует в него стандартные конфигурационные файлы из `/usr/share/skel` и может отправить новому пользователю приветственное письмо. Эту утилиту необходимо запускать от имени суперпользователя.

Утилита man:adduser[8] интерактивна и проводит пользователя через шаги создания новой учётной записи. Как показано в crossref:basics[users-modifying-adduser, Добавление пользователя в FreeBSD], можно ввести необходимую информацию или нажать kbd:[Enter], чтобы принять значение по умолчанию, указанное в квадратных скобках. В этом примере пользователь был добавлен в группу `wheel`, что позволяет ему стать суперпользователем с помощью man:su[1]. По завершении утилита предложит создать ещё одного пользователя или выйти.

[[users-modifying-adduser]]
.Добавление пользователя в FreeBSD
[example]
====
[source, shell]
....
# adduser
....

Вывод должен быть похож на следующий:

[.programlisting]
....
Username: jru
Full name: J. Random User
Uid (Leave empty for default):
Login group [jru]:
Login group is jru. Invite jru into other groups? []: wheel
Login class [default]:
Shell (sh csh tcsh zsh nologin) [sh]: zsh
Home directory [/home/jru]:
Home directory permissions (Leave empty for default):
Use password-based authentication? [yes]:
Use an empty password? (yes/no) [no]:
Use a random password? (yes/no) [no]:
Enter password:
Enter password again:
Lock out the account after creation? [no]:
Username   : jru
Password   : ****
Full Name  : J. Random User
Uid        : 1001
Class      :
Groups     : jru wheel
Home       : /home/jru
Shell      : /usr/local/bin/zsh
Locked     : no
OK? (yes/no): yes
adduser: INFO: Successfully added (jru) to the user database.
Add another user? (yes/no): no
Goodbye!
....
====

[NOTE]
====
Поскольку пароль не отображается при вводе, будьте внимательны, чтобы не ошибиться при создании учетной записи пользователя.
====

[[users-rmuser]]
==== Удаление пользователя

Чтобы полностью удалить пользователя из системы, выполните команду man:rmuser[8] с правами суперпользователя. Эта команда выполняет следующие действия:

[.procedure]
====
. Удаляет запись пользователя в man:crontab[1], если она существует.
. Удаляет все задания man:at[1], принадлежащие пользователю.
. Посылает сигнал SIGKILL всем процессам, принадлежащим пользователю.
. Удаляет пользователя из локального файла паролей системы.
. Удаляет домашний каталог пользователя (если он принадлежит пользователю), включая обработку символических ссылок в пути к фактическому домашнему каталогу.
. Удаляет входящие почтовые файлы пользователя из `/var/mail`.
. Удаляет все файлы, принадлежащие пользователю, из `/tmp`, `/var/tmp` и `/var/tmp/vi.recover`.
. Удаляет имя пользователя из всех групп, к которым он принадлежит в `/etc/group`. (Если группа становится пустой и имя группы совпадает с именем пользователя, группа удаляется; это дополняет функциональность man:adduser[8] в части уникальных групп для каждого пользователя.)
. Удаляет все очереди сообщений, сегменты разделяемой памяти и семафоры, принадлежащие пользователю.
====

man:rmuser[8] не может быть использован для удаления учетных записей суперпользователя, так как это почти всегда свидетельствует о катастрофических последствиях.

По умолчанию используется интерактивный режим, как показано в следующем примере.

.`rmuser` Интерактивное удаление учетной записи
[example]
====
[source, shell]
....
# rmuser jru

....

Вывод должен быть похож на следующий:

[.programlisting]
....
Matching password entry:
jru:*:1001:1001::0:0:J. Random User:/home/jru:/usr/local/bin/zsh
Is this the entry you wish to remove? y
Remove user's home directory (/home/jru)? y
Removing user (jru): mailspool home passwd.
....
====

[[users-chpass]]
==== Изменить информацию о пользователе

Любой пользователь может использовать man:chpass[1] для изменения своей оболочки по умолчанию и персональной информации, связанной с его учётной записью. Суперпользователь может использовать эту утилиту для изменения дополнительных параметров учётной записи любого пользователя.

Без указания опций, за исключением необязательного имени пользователя, man:chpass[1] отображает редактор с информацией о пользователе. После выхода пользователя из редактора база данных пользователей обновляется новой информацией.

[NOTE]
====
Этотa утилитa запрашивает пароль пользователя при выходе из редактора, если только она не запущена от имени суперпользователя.
====

В crossref:basics[users-modifying-chpass-su,Использование `chpass` суперпользователем], суперпользователь ввел `chpass jru` и теперь видит поля, которые можно изменить для этого пользователя. Если же команду выполнит сам `jru`, будут отображены и доступны для редактирования только последние шесть полей. Это показано в crossref:basics[users-modifying-chpass-ru,Использование `chpass` обычным пользователем].

[[users-modifying-chpass-su]]
.Использование `chpass` с правами суперпользователя
[example]
====
[source, shell]
....
# chpass jru
....

Вывод должен быть похож на следующий:

[.programlisting]
....
# Changing user database information for jru.
Login: jru
Password: *
Uid [#]: 1001
Gid [# or name]: 1001
Change [month day year]:
Expire [month day year]:
Class:
Home directory: /home/jru
Shell: /usr/local/bin/zsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:
....
====

[[users-modifying-chpass-ru]]
.Использование `chpass` обычным пользователем
[example]
====
[source, shell]
....
#Changing user database information for jru.
Shell: /usr/local/bin/zsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:
....
====

[NOTE]
====
Команды man:chfn[1] и man:chsh[1] являются ссылками на man:chpass[1], как и man:ypchpass[1], man:ypchfn[1] и man:ypchsh[1]. Поскольку поддержка NIS автоматическая, указывать `yp` перед командой не требуется. Настройка NIS описана в crossref:network-servers[network-servers,Сетевые серверы].
====

[[users-passwd]]
==== Изменение пароля пользователя

Любой пользователь может легко изменить свой пароль с помощью man:passwd[1]. Для предотвращения случайных или несанкционированных изменений эта команда запросит исходный пароль пользователя перед установкой нового пароля:

.Смена собственного пароля
[example]
====
[source, shell]
....
% passwd
....

Вывод должен быть похож на следующий:

[.programlisting]
....
Changing local password for jru.
Old password:
New password:
Retype new password:
passwd: updating the database...
passwd: done
....
====

Суперпользователь может изменить пароль любого пользователя, указав имя пользователя при запуске man:passwd[1]. При запуске этой утилиты с правами суперпользователя она не запрашивает текущий пароль пользователя. Это позволяет изменить пароль, если пользователь не может вспомнить исходный пароль.

.Изменение пароля другого пользователя суперпользователем
[example]
====
[source, shell]
....
# passwd jru
....

Вывод должен быть похож на следующий:

[.programlisting]
....
Changing local password for jru.
New password:
Retype new password:
passwd: updating the database...
passwd: done
....
====

[NOTE]
====
Как и man:chpass[1], man:yppasswd[1] является ссылкой на man:passwd[1], поэтому NIS работает с любой из этих команд.
====

[[users-pw]]
==== Создание, удаление, изменение и отображение пользователей и групп системы

Утилита man:pw[8] может создавать, удалять, изменять и отображать пользователей и группы. Она работает как интерфейс к системным файлам пользователей и групп. man:pw[8] обладает мощным набором параметров командной строки, что делает её пригодной для использования в shell-скриптах, но новым пользователям она может показаться сложнее других команд, представленных в этом разделе.

[[users-groups]]
=== Управление группами

Группа — это список пользователей. Группа идентифицируется по своему названию и GID. В FreeBSD ядро использует UID процесса и список групп, к которым он принадлежит, чтобы определить, что процесс может делать. В большинстве случаев под GID пользователя или процесса обычно подразумевается первая группа в списке.

Соответствие имен групп и GID перечислено в `/etc/group`. Это простой текстовый файл с четырьмя полями, разделенными двоеточиями. Первое поле — имя группы, второе — зашифрованный пароль, третье — GID, а четвертое — список участников, разделенных запятыми. Полное описание синтаксиса смотрите в man:group[5].

Суперпользователь может изменить `/etc/group` с помощью текстового редактора, однако предпочтительнее редактировать файл групп с помощью man:vigr[8], так как это позволяет избежать некоторых распространённых ошибок. Альтернативно, для добавления и редактирования групп можно использовать man:pw[8]. Например, чтобы добавить группу с именем `teamtwo` и затем убедиться, что она существует:

[WARNING]
====
При использовании группы operator необходимо соблюдать осторожность, так как могут быть предоставлены непредусмотренные привилегии, аналогичные правам суперпользователя, включая, но не ограничиваясь, возможностью выключения системы, перезагрузки и доступа ко всем элементам в `/dev` в рамках группы.
====

.Добавление группы с помощью man:pw[8]
[example]
====
[source, shell]
....
# pw groupadd teamtwo
# pw groupshow teamtwo
....

Вывод должен быть похож на следующий:

[.programlisting]
....
teamtwo:*:1100:
....
====

В этом примере `1100` — это GID группы `teamtwo`. На данный момент в `teamtwo` нет участников. Эта команда добавит `jru` в качестве участника `teamtwo`.

.Добавление пользовательских учетных записей в новую группу с помощью man:pw[8]
[example]
====
[source, shell]
....
# pw groupmod teamtwo -M jru
# pw groupshow teamtwo
....

Вывод должен быть похож на следующий:

[.programlisting]
....
teamtwo:*:1100:jru
....
====

Аргумент `-M` представляет собой разделённый запятыми список пользователей, которые будут добавлены в новую (пустую) группу или заменят членов существующей группы. Для пользователя это членство в группе отличается от (и дополняет) его основной группы, указанной в файле паролей. Это означает, что пользователь не будет отображаться как член группы при использовании `groupshow` с man:pw[8], но будет виден при запросе информации через man:id[1] или аналогичный инструмент. Когда man:pw[8] используется для добавления пользователя в группу, он только изменяет `/etc/group` и не пытается читать дополнительные данные из `/etc/passwd`.

.Добавление нового участника в группу с помощью man:pw[8]
[example]
====
[source, shell]
....
# pw groupmod teamtwo -m db
# pw groupshow teamtwo
....

Вывод должен быть похож на следующий:

[.programlisting]
....
teamtwo:*:1100:jru,db
....
====

В этом примере аргумент `-m` представляет собой список пользователей, разделённых запятыми, которые будут добавлены в группу. В отличие от предыдущего примера, эти пользователи добавляются к группе и не заменяют уже существующих в ней пользователей.

.Использование man:id[1] для определения членства в группе
[example]
====
[source, shell]
....
% id jru
....

Вывод должен быть похож на следующий:

[.programlisting]
....
uid=1001(jru) gid=1001(jru) groups=1001(jru), 1100(teamtwo)
....
====

В этом примере `jru` является участником групп `jru` и `teamtwo`.

Для получения дополнительной информации об этой команде и формате файла `/etc/group` обратитесь к man:pw[8] и man:group[5].

[[permissions]]
== Разрешения

В FreeBSD каждому файлу и каталогу сопоставлен набор прав доступа, и существует несколько утилит для просмотра и изменения этих прав. Понимание работы прав доступа необходимо для того, чтобы пользователи могли получать доступ к нужным им файлам, но не имели возможности несанкционированного доступа к файлам операционной системы или файлам других пользователей.

В этом разделе рассматриваются традиционные права доступа UNIX(R), используемые в FreeBSD. Для более детального управления доступом к файловой системе обратитесь к crossref:security[fs-acl,Списки контроля доступа].

В UNIX(R) базовые права доступа назначаются с использованием трех типов доступа: чтение, запись и выполнение. Эти типы доступа определяют права на файл для владельца, группы и остальных (всех остальных). Права на чтение, запись и выполнение могут быть представлены буквами `r`, `w` и `x`. Они также могут быть представлены в виде двоичных чисел, так как каждое право либо включено, либо выключено (`0`). При представлении в виде чисел порядок всегда читается как `rwx`, где `r` имеет значение `4`, `w` — `2`, а `x` — `1`.

Таблица 4.1 обобщает возможные числовые и буквенные варианты. В столбце "Список файлов каталога" символ `-` используется для обозначения отключённого разрешения.

.Права доступа UNIX(R)
[cols="1,1,1", frame="none", options="header"]
|===
| Значение
| Разрешение
| Список файлов каталога

|0
|Нет чтения, нет записи, нет выполнения
|`---`

|1
|Нет чтения, нет записи, выполнение
|`--x`

|2
|Нет чтения, записи, выполнения
|`-w-`

|3
|Нет прав на чтение, запись, выполнение
|`-wx`

|4
|Чтение, нет записи, нет выполнения
|`r--`

|5
|Чтение, нет записи, выполнение
|`r-x`

|6
|Чтение, запись, без выполнения
|`rw-`

|7
|Чтение, запись, выполнение
|`rwx`
|===

Используйте аргумент `-l` с man:ls[1] для просмотра длинного списка каталога, который включает колонку с информацией о правах доступа к файлу для владельца, группы и всех остальных. Например, `ls -l` в произвольном каталоге может вывести:

[source, shell]
....
% ls -l
....

Вывод должен быть похож на следующий:

[.programlisting]
....
total 530
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 myfile
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 otherfile
-rw-r--r--  1 root  wheel    7680 Sep  5 12:31 email.txt
....

Рассматривая строку для файла `myfile`, первый `(крайний слева)` символ указывает, является ли этот файл обычным файлом, каталогом, специальным символьным устройством, сокетом или любым другим специальным псевдофайловым устройством. В данном примере символ `-` обозначает обычный файл. Следующие три символа, в этом примере `rw-`, указывают права для владельца файла. Следующие три символа, `r--`, указывают права для группы, к которой принадлежит файл. Последние три символа, `r--`, указывают права для всех остальных. Дефис означает, что право отключено. В этом примере права настроены так, что владелец может читать и записывать файл, группа может читать файл, а все остальные могут только читать файл. Согласно приведённой выше таблице, права для этого файла будут `644`, где каждая цифра представляет одну из трёх частей прав файла.

Как система управляет правами доступа к устройствам? FreeBSD рассматривает большинство аппаратных устройств как файлы, которые программы могут открывать, читать и записывать в них данные. Эти специальные файлы устройств хранятся в `/dev/`.

Каталоги также рассматриваются как файлы. У них есть права на чтение, запись и выполнение. Бит выполнения для каталога имеет несколько иное значение, чем для файлов. Если каталог помечен как исполняемый, это означает, что в него можно перейти с помощью man:cd[1]. Это также означает, что можно получить доступ к файлам внутри этого каталога, в зависимости от прав на сами файлы.

Для выполнения списка файлов в каталоге необходимо установить право на чтение для этого каталога. Чтобы удалить файл, имя которого известно, требуются права на запись _и_ выполнение для каталога, содержащего этот файл.

Существуют и другие биты разрешений, но они в основном используются в особых случаях, таких как setuid-бинарники и sticky-каталоги. Для получения дополнительной информации о правах доступа к файлам и их настройке обратитесь к man:chmod[1].

=== Символьные права доступа

Символьные права доступа используют символы вместо восьмеричных значений для назначения прав доступа файлам или каталогам. Синтаксис символьных прав доступа имеет вид (кто) (действие) (права доступа), где доступны следующие значения:

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Опция
| Буква
| Представляет

|(кто)
|u
|Пользователь

|(кто)
|g
|Владелец группы

|(кто)
|o
|Другие

|(кто)
|a
|Все (all, "world")

|(действие)
|+
|Добавление разрешений

|(действие)
|-
|Удаление прав доступа

|(действие)
|=
|Явно заданные разрешения

|(права доступа)
|r
|Чтение

|(права доступа)
|w
|Запись

|(права доступа)
|x
|Выполнение

|(права доступа)
|t
|Бит закрепления (sticky)

|(права доступа)
|s
|Установка UID или GID
|===

Эти значения используются с man:chmod[1], но с буквами вместо чисел. Например, следующая команда запретит доступ к _FILE_ как членам группы, связанной с _FILE_, так и всем остальным пользователям:

[source, shell]
....
% chmod go= FILE
....

Список, разделённый запятыми, может быть указан, если к файлу необходимо применить более одного изменения. Например, следующая команда удаляет разрешение на запись для группы и всех остальных пользователей у _FILE_, а также добавляет разрешение на выполнение для всех:

[source, shell]
....
% chmod go-w,a+x FILE
....

=== Флаги файлов FreeBSD

В дополнение к правам доступа к файлам FreeBSD поддерживает использование "флагов файлов". Эти флаги добавляют дополнительный уровень безопасности и контроля над файлами, но не над каталогами. С помощью флагов файлов даже пользователь `root` может быть лишён возможности удалять или изменять файлы.

Флаги файлов изменяются с помощью man:chflags[1]. Например, чтобы установить системный флаг «неудаляемый» для файла `file1`, выполните следующую команду:

[source, shell]
....
# chflags sunlink file1
....

Чтобы отключить системный флаг "неудаляемый", добавьте "no" перед `sunlink`:

[source, shell]
....
# chflags nosunlink file1
....

Чтобы просмотреть флаги файла, используйте `-lo` с man:ls[1]:

[source, shell]
....
# ls -lo file1
....

[.programlisting]
....
-rw-r--r--  1 trhodes  trhodes  sunlnk 0 Mar  1 05:54 file1
....

Некоторые флаги файлов могут быть добавлены или удалены только пользователем `root`. В остальных случаях владелец файла может устанавливать его флаги. Дополнительную информацию можно найти в man:chflags[1] и man:chflags[2].

=== Установленные биты setuid, setgid и sticky

Помимо уже рассмотренных прав доступа, существуют три специальных параметра, которые должны знать все администраторы. Это права `setuid`, `setgid` и `sticky`.

Эти настройки важны для некоторых операций UNIX(R), так как предоставляют функциональность, обычно недоступную обычным пользователям. Чтобы понять их, необходимо отметить разницу между реальным идентификатором пользователя (real user ID) и эффективным идентификатором пользователя (effective user ID).

Реальный идентификатор пользователя (UID) — это UID, который владеет или запускает процесс. Эффективный идентификатор пользователя — это UID, от имени которого выполняется процесс. Например, man:passwd[1] запускается с реальным UID, когда пользователь меняет свой пароль. Однако для обновления базы данных паролей команда выполняется с эффективным UID пользователя `root`. Это позволяет пользователям изменять свои пароли без ошибки `Permission Denied`.

Разрешение setuid может быть добавлено символически путем добавления права `s` для пользователя, как в следующем примере:

[source, shell]
....
# chmod u+s suidexample.sh
....

Права setuid также могут быть установлены путем добавления числа четыре (4) перед набором прав, как показано в следующем примере:

[source, shell]
....
# chmod 4755 suidexample.sh
....

Разрешения для файла `suidexample.sh` теперь выглядят следующим образом:

[.programlisting]
....
-rwsr-xr-x   1 trhodes  trhodes    63 Aug 29 06:36 suidexample.sh
....

Обратите внимание, что `s` теперь является частью набора прав для владельца файла, заменив бит исполнения. Это позволяет создавать программы, требующие повышенных прав, таких как man:passwd[1].

[NOTE]
====
Опция `nosuid` в man:mount[8] приведёт к тихому отказу таких бинарных файлов без уведомления пользователя. Эта опция не полностью надежна, так как обёртка `nosuid` может её обойти.
====

Чтобы наблюдать это в реальном времени, откройте два терминала. В одном введите `passwd` как обычный пользователь. Пока команда ожидает ввода нового пароля, проверьте таблицу процессов и посмотрите информацию о пользователе для man:passwd[1]:

В терминале A:

[source, shell]
....
Changing local password for trhodes
Old Password:
....

В терминале B:

[source, shell]
....
# ps aux | grep passwd
....

[source, shell]
....
trhodes  5232  0.0  0.2  3420  1608   0  R+    2:10AM   0:00.00 grep passwd
root     5211  0.0  0.2  3620  1724   2  I+    2:09AM   0:00.01 passwd
....

Хотя man:passwd[1] запускается от имени обычного пользователя, он использует эффективный UID `root`.

Разрешение `setgid` выполняет ту же функцию, что и разрешение `setuid`, за исключением того, что оно изменяет настройки группы. Когда приложение или утилита запускается с этой настройкой, оно получает разрешения в соответствии с группой, которой принадлежит файл, а не пользователем, запустившим процесс.

Чтобы установить право `setgid` на файл в символьном виде, добавьте право `s` для группы с помощью man:chmod[1]:

[source, shell]
....
# chmod g+s sgidexample.sh
....

В качестве альтернативы укажите в man:chmod[1] ведущую двойку (2):

[source, shell]
....
# chmod 2755 sgidexample.sh
....

В следующем листинге обратите внимание, что символ `s` теперь находится в поле, предназначенном для настроек прав группы:

[source, shell]
....
-rwxr-sr-x   1 trhodes  trhodes    44 Aug 31 01:49 sgidexample.sh
....

[NOTE]
====
В этих примерах, даже если рассматриваемый shell-скрипт является исполняемым файлом, он не будет запускаться с другим EUID или эффективным идентификатором пользователя. Это происходит потому, что shell-скрипты не могут использовать системные вызовы man:setuid[2].
====

`setuid` и `setgid` биты прав могут снизить безопасность системы, предоставляя повышенные привилегии. Третий специальный бит прав, `sticky bit`, напротив, может повысить безопасность системы.

Когда `sticky bit` установлен на директории, он разрешает удаление файлов только владельцу файла. Это полезно для предотвращения удаления файлов в общедоступных директориях, таких как `/tmp`, пользователями, не являющимися владельцами файла. Чтобы использовать этот режим доступа, добавьте режим `t` к файлу:

[source, shell]
....
# chmod +t /tmp
....

В качестве альтернативы можно добавить единицу (1) перед набором прав доступа:

[source, shell]
....
# chmod 1777 /tmp
....

Разрешение `sticky bit` отображается как `t` в самом конце набора разрешений:

[source, shell]
....
# ls -al / | grep tmp
....

[source, shell]
....
drwxrwxrwt  10 root  wheel         512 Aug 31 01:49 tmp
....

[[dirstructure]]
== Структура каталогов

Иерархия каталогов FreeBSD является основой для общего понимания системы. Наиболее важным каталогом является корневой или "/". Этот каталог монтируется первым при загрузке и содержит базовую систему, необходимую для подготовки операционной системы к многопользовательскому режиму. Корневой каталог также содержит точки монтирования для других файловых систем, которые монтируются во время перехода в многопользовательский режим.

Точка монтирования — это каталог, в который можно подключить дополнительные файловые системы к родительской файловой системе (обычно корневой файловой системе). Это подробно описано в разделе crossref:basics[disk-organization,Организация дисков]. Стандартные точки монтирования включают `/usr/`, `/var/`, `/tmp/`, `/mnt/` и `/cdrom/`. Эти каталоги обычно связаны с записями в файле `/etc/fstab`. Этот файл представляет собой таблицу различных файловых систем и точек монтирования, которая читается системой. Большинство файловых систем в `/etc/fstab` автоматически монтируются при загрузке с помощью скрипта man:rc[8], если их запись не содержит параметра `noauto`. Подробности можно найти в разделе crossref:basics[disks-fstab,Файл fstab].

Полное описание иерархии файловой системы доступно в man:hier[7]. В следующей таблице представлен краткий обзор наиболее распространённых каталогов.

[cols="25h,~"]
|===
| Каталог
| Описание

|`/`
|Корневой каталог файловой системы.

|`/bin/`
|Пользовательские утилиты, основные как для однопользовательской, так и для многопользовательской среды.

|`/boot/`
|Программы и конфигурационные файлы, используемые при загрузке операционной системы.

|`/boot/defaults/`
|Файлы конфигурации загрузки по умолчанию. Подробности смотрите в man:loader.conf[5].

|`/dev/`
|Специальные файлы устройств, управляемые man:devfs[5]

|`/etc/`
|Системные конфигурационные файлы и скрипты.

|`/etc/defaults/`
|Файлы конфигурации системы по умолчанию. Подробности смотрите в man:rc[8].

|`/etc/periodic/`
|Скрипты, выполняемые ежедневно, еженедельно и ежемесячно, через man:cron[8]. Подробности смотрите в man:periodic[8].

|`/lib/`
|Критические системные библиотеки, необходимые для бинарных файлов в `/bin` и `/sbin`

|`/libexec/`
|Критические системные файлы

|`/media/`
|Содержит подкаталоги, предназначенные для использования в качестве точек монтирования съемных носителей, таких как компакт-диски, USB-накопители и дискеты

|`/mnt/`
|Пустая директория, обычно используемая системными администраторами в качестве временной точки монтирования.

|`/net/`
|Автомонтируемые NFS-ресурсы; см. man:auto_master[5]

|`/proc/`
|Файловая система процессов. Подробности смотрите в man:procfs[5].

|`/rescue/`
|Статически связанные программы для аварийного восстановления, как описано в man:rescue[8].

|`/root/`
|Домашний каталог для учетной записи `root`.

|`/sbin/`
|Системные программы и административные утилиты, необходимые как для однопользовательского, так и для многопользовательского окружения.

|`/tmp/`
|Временные файлы, которые обычно _не_ сохраняются после перезагрузки системы. Часто в `/tmp` монтируется файловая система в памяти. Это можно автоматизировать, используя переменные, связанные с tmpmfs, из man:rc.conf[5], или добавив запись в `/etc/fstab`; подробности смотрите в man:mdmfs[8].

|`/usr/`
|Большинство пользовательских утилит и приложений.

|`/usr/bin/`
|Общие утилиты, инструменты программирования и приложения.

|`/usr/include/`
|Стандартные включаемые файлы языка C.

|`/usr/lib/`
|Библиотеки архивов.

|`/usr/libdata/`
|Различные вспомогательные файлы данных.

|`/usr/libexec/`
|Системные демоны и системные утилиты, выполняемые другими программами.

|`/usr/local/`
|Локальные исполняемые файлы и библиотеки. Также используется как путь по умолчанию для установки портов FreeBSD. Внутри `/usr/local` должна использоваться общая структура каталогов, описанная в man:hier[7] для `/usr`. Исключениями являются каталог man, который находится непосредственно в `/usr/local`, а не в `/usr/local/share`, а документация портов располагается в `share/doc/port`.

|`/usr/ports/`
|Коллекция портов FreeBSD (опционально).

|`/usr/sbin/`
|Системные демоны и системные утилиты, выполняемые пользователями.

|`/usr/share/`
|Архитектурно-независимые файлы.

|`/usr/src/`
|BSD и/или локальные исходные файлы.

|`/var/`
|Многоцелевые файлы журналов, временные, транзиентные и файлы очередей.

|`/var/log/`
|Различные системные журналы.

|`/var/tmp/`
|Временные файлы, которые обычно сохраняются после перезагрузки системы.

|===

[[disk-organization]]
== Организация диска

Наименьшей единицей организации, которую FreeBSD использует для поиска файлов, является имя файла. Имена файлов чувствительны к регистру, что означает, что `readme.txt` и `README.TXT` — это два разных файла. FreeBSD не использует расширение файла для определения, является ли файл программой, документом или каким-либо другим видом данных.

Файлы хранятся в каталогах. Каталог может не содержать файлов или содержать сотни файлов. Каталог также может содержать другие каталоги, что позволяет создавать иерархию вложенных каталогов для организации данных.

Файлы и каталоги указываются путём перечисления имени файла или каталога, за которым следует косая черта `/`, а затем — при необходимости — другие имена каталогов. Например, если каталог `foo` содержит каталог `bar`, в котором находится файл `readme.txt`, то полное имя или _путь_ к файлу будет `foo/bar/readme.txt`. Обратите внимание, что это отличается от Windows(R), где для разделения имён файлов и каталогов используется `\`. В FreeBSD не используются буквы дисков или другие обозначения накопителей в пути. Например, в FreeBSD не указывают путь вида `c:\foo\bar\readme.txt`.

[[disks-file-systems]]
=== Файловые системы

Каталоги и файлы хранятся в файловой системе. Каждая файловая система содержит ровно один каталог на самом верхнем уровне, называемый _корневым каталогом_ для этой файловой системы. Этот корневой каталог может содержать другие каталоги. Одна файловая система назначается _корневой файловой системой_ или `/`. Все остальные файловые системы _монтируются_ в корневую файловую систему. Независимо от количества дисков в системе FreeBSD, каждый каталог выглядит как часть одного и того же диска.

Рассмотрим три файловые системы: `A`, `B` и `C`. Каждая файловая система имеет один корневой каталог, который содержит два других каталога с именами `A1`, `A2` (аналогично `B1`, `B2` и `C1`, `C2`).

Назовем корневую файловую систему `A`. Если использовать man:ls[1] для просмотра содержимого этого каталога, будут видны два подкаталога, `A1` и `A2`. Дерево каталогов выглядит следующим образом:

image::example-dir1.png["Дерево каталогов с корневым каталогом и двумя подкаталогами", A1 and A2]

Файловая система должна быть смонтирована в каталог другой файловой системы. При монтировании файловой системы `B` в каталог `A1` корневой каталог `B` заменяет `A1`, а каталоги в `B` отображаются соответствующим образом:

image::example-dir2.png["Дерево каталогов с корневым каталогом и двумя подкаталогами", A1 and A2. And more subdirectories, B1 and B2 hanging from A1]

Любые файлы в каталогах `B1` или `B2` доступны по пути `/A1/B1` или `/A1/B2` соответственно. Файлы, которые находились в `/A1`, временно скрыты. Они снова станут доступны, если `B` будет _отмонтирован_ из `A`.

Если бы `B` был смонтирован на `A2`, то диаграмма выглядела бы так:

image::example-dir3.png["Дерево каталогов с корневым каталогом и двумя подкаталогами", A1 and A2. And more subdirectories, B1 and B2 hanging from A2]

и пути будут `/A2/B1` и `/A2/B2` соответственно.

Файловые системы могут монтироваться одна поверх другой. Продолжая последний пример, файловая система `C` может быть смонтирована поверх каталога `B1` в файловой системе `B`, что приведёт к следующей структуре:

image::example-dir4.png["Сложная древовидная структура каталогов. С различными подкаталогами, отходящими от корневого."]

Или `C` может быть непосредственно смонтирована в файловую систему `A`, в каталог `A1`:

image::example-dir5.png["Сложная древовидная структура каталогов. С различными подкаталогами, отходящими от корневого."]

Вполне возможно иметь одну большую корневую файловую систему и не создавать других. У такого подхода есть несколько недостатков и одно преимущество.

.Преимущества нескольких файловых систем
* Различные файловые системы могут иметь разные _параметры монтирования_. Например, корневая файловая система может быть смонтирована в режиме только для чтения, что предотвращает случайное удаление или редактирование важных файлов пользователями. Разделение файловых систем, доступных для записи пользователями, таких как `/home`, от остальных позволяет монтировать их с опцией _nosuid_. Эта опция предотвращает действие битов _suid_/_guid_ у исполняемых файлов, хранящихся в данной файловой системе, что может повысить безопасность.
* FreeBSD автоматически оптимизирует расположение файлов в файловой системе в зависимости от того, как она используется. Таким образом, файловая система, содержащая множество часто записываемых небольших файлов, будет оптимизирована иначе, чем система с меньшим количеством более крупных файлов. При использовании одной большой файловой системы такая оптимизация нарушается.
* Файловые системы FreeBSD устойчивы к потере питания. Однако отключение питания в критический момент всё же может повредить структуру файловой системы. Разделение данных между несколькими файловыми системами увеличивает вероятность успешной загрузки системы, упрощая восстановление из резервной копии при необходимости.

.Преимущество единой файловой системы
* Файловые системы имеют фиксированный размер. Если вы создали файловую систему при установке FreeBSD и задали ей определённый размер, позже может оказаться, что раздел нужно увеличить. Это нелегко сделать без резервного копирования, пересоздания файловой системы с новым размером и последующего восстановления данных из резервной копии.
+
[IMPORTANT]
====
FreeBSD предоставляет команду man:growfs[8], которая позволяет увеличивать размер файловой системы на лету, устраняя это ограничение. Файловая система может быть расширена только в свободное пространство раздела, в котором она находится. Если после раздела есть место, сам раздел можно расширить с помощью man:gpart[8]. Если раздел является последним на виртуальном диске и диск расширен, то раздел также можно расширить.
====

[[disks-partitions]]
=== Разделы диска

Файловые системы содержатся в _разделах_. Диски разделяются на разделы с использованием одной из нескольких схем разметки; см. crossref:bsdinstall[bsdinstall-part-manual, Ручная разметка разделов]. Более новая схема — GPT; старые компьютеры на базе BIOS используют MBR. GPT поддерживает разделение диска на разделы с указанием размера, смещения и типа. Она поддерживает большое количество разделов и их типов, и рекомендуется к использованию везде, где это возможно. Разделы GPT используют имя диска с суффиксом, где суффикс `p1` соответствует первому разделу, `p2` — второму и так далее. MBR, однако, поддерживает только небольшое количество разделов. Разделы MBR в FreeBSD называются _слайсами_. Слайсы могут использоваться для разных операционных систем. Слайсы FreeBSD дополнительно разбиваются на разделы с использованием меток BSD (см. man:bsdlabel[8]).

Номера слайсов указываются после имени устройства с префиксом `s` и начинаются с 1. Таким образом, "da0__s1__" — это первый слайс на первом SCSI-диске. На диске может быть только четыре физических слайса, но внутри физических слайсов соответствующего типа могут находиться логические слайсы. Эти расширенные слайсы нумеруются, начиная с 5, поэтому "ada0__s5__" — это первый расширенный слайс на первом SATA-диске. Эти устройства используются файловыми системами, которые предназначены для размещения в слайсе.

Каждый раздел GPT или BSD может содержать только одну файловую систему, что означает, что файловые системы часто описываются либо по их стандартной точке монтирования в иерархии файловых систем, либо по имени раздела, в котором они находятся.

FreeBSD также использует место на диске для _раздела подкачки_ (_swap space_), чтобы обеспечить работу _виртуальной памяти_. Это позволяет компьютеру вести себя так, как будто у него больше памяти, чем есть на самом деле. Когда FreeBSD исчерпывает доступную память, она перемещает часть данных, которые в данный момент не используются, в раздел подкачки, а затем возвращает их обратно (перемещая что-то другое), когда они нужны. Этот процесс называется _подкачкой_ (_paging_).

Некоторые разделы BSD имеют определенные соглашения, связанные с ними.

[cols="25h,~"]
|===
| Раздел
| Соглашение

|`a`
|Обычно содержит корневую файловую систему.

|`b`
|Обычно содержит раздел подкачки.

|`c`
|Обычно имеет тот же размер, что и окружающий слайс. Это позволяет утилитам, которым необходимо работать со всем слайсом, например, сканеру плохих блоков, работать с разделом `c`. Файловая система обычно не создается на этом разделе.

|`d`
|Раздел `d` ранее имел особое значение, но сейчас это ушло в прошлое, и `d` может использоваться как обычный раздел.
|===

Слайсы и «опасно выделенные» (dangerously dedicated) физические диски содержат разделы BSD, которые обозначаются буквами от `a` до `h`. Эта буква добавляется к имени устройства, поэтому «da0__a__» — это раздел `a` на первом диске `da`, который является «опасно выделенным». «ada1s3__e__» — это пятый раздел в третьем срезе второго диска SATA.

Наконец, каждый диск в системе идентифицируется. Имя диска начинается с кода, указывающего тип диска, за которым следует номер, обозначающий конкретный диск. В отличие от разделов и слайсов, нумерация дисков начинается с 0. Распространённые коды перечислены в crossref:basics[disks-naming,Имена устройств дисков].

При указании раздела в слайсе укажите имя диска, `s`, номер слайса, а затем букву раздела. Примеры приведены в разделе crossref:basics[basics-disk-slice-part,Примеры имен дисков, слайсов и разделов]. Разделы GPT включают имя диска, `p`, а затем номер раздела.

crossref:basics[basics-concept-disk-model,Концептуальная модель диска] показывает концептуальную модель разметки диска с использованием разделов MBR.

При установке FreeBSD настройте слайсы диска, если используется MBR, и создайте разделы внутри слайса, который будет использоваться для FreeBSD. Если используется GPT, настройте разделы для каждой файловой системы. В обоих случаях создайте файловую систему или область подкачки в каждом разделе и определите, где будет монтироваться каждая файловая система. Подробности о работе с разделами см. в man:gpart[8].

[[disks-naming]]
.Имена устройств дисков
[cols="1,1", frame="none", options="header"]
|===
| Тип накопителя
| Имя устройства накопителя

|SATA и IDE жёсткие диски
|`ada`

|SCSI жесткие диски и USB устройства хранения данных
|`da`

|Хранилище NVMe
|`nvd` или `nda`

|SATA и IDE приводы CD-ROM
|`cd`

|SCSI CD-ROM приводы
|`cd`

|Накопители на гибких дисках
|`fd`

|SCSI-ленточные накопители
|`sa`

|RAID-диски
|Примеры включают `aacd` для Adaptec(R) AdvancedRAID, `mlxd` и `mlyd` для Mylex(R), `amrd` для AMI MegaRAID(R), `idad` для Compaq Smart RAID, `twed` для 3ware(R) RAID.
|===

[example]
====
[[basics-disk-slice-part]]
.Примеры названий дисков, слайсов и разделов
[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Имя
| Значение

|`ada0s1a`
|Первый раздел (`a`) на первом слайсе (`s1`) на первом SATA-диске (`ada0`).

|`da1s2e`
|Пятый раздел (`e`) на втором срезе (`s2`) второго SCSI-диска (`da1`).
|===
====

[[basics-concept-disk-model]]
.Концептуальная модель диска
[example]
====
На этой диаграмме показано, как FreeBSD видит первый SATA-диск, подключённый к системе. Предположим, что размер диска составляет 250 ГБ, и он содержит раздел на 80 ГБ и раздел на 170 ГБ (разделы MS-DOS(R)). Первый раздел содержит файловую систему Windows(R) NTFS, `C:`, а второй раздел содержит установленную систему FreeBSD. В данном примере установки FreeBSD присутствуют четыре раздела с данными и один раздел подкачки.

Четыре раздела содержат файловые системы. Раздел `a` используется для корневой файловой системы, `d` — для `/var/`, `e` — для `/tmp/`, а `f` — для `/usr/`. Буква раздела `c` относится ко всему слайсу и поэтому не используется для обычных разделов.

image::disk-layout.png["Компоновка общего диска между Windows и FreeBSD"]
====

[[mount-unmount]]
== Монтирование и демонтирование файловых систем

Файловую систему удобно визуализировать как дерево, корнем которого является `/`. Каталоги `/dev`, `/usr` и другие в корневом каталоге представляют собой ветви, которые, в свою очередь, могут иметь собственные ветви, например `/usr/local`, и так далее.

Существуют различные причины для размещения некоторых из этих каталогов на отдельных файловых системах. `/var` содержит каталоги `log/`, `spool/` и различные типы временных файлов, поэтому может заполняться. Заполнение корневой файловой системы нежелательно, поэтому часто предпочтительно отделить `/var` от `/`.

Еще одна распространённая причина размещать определённые каталоги на других файловых системах — это необходимость их размещения на отдельных физических дисках или виртуальных дисках, таких как сетевые файловые системы (NFS), описанные в crossref:network-servers[network-nfs,“Сетевая файловая система (NFS)”], или приводы CDROM.

[[disks-fstab]]
=== Файл fstab

В процессе загрузки (crossref:boot[boot,Процесс загрузки FreeBSD]), файловые системы, перечисленные в `/etc/fstab`, автоматически монтируются, за исключением записей, содержащих `noauto`. Этот файл содержит записи в следующем формате:

[.programlisting]
....
device       /mount-point fstype     options      dumpfreq     passno
....

`device`::
Существующее имя устройства, как описано в crossref:basics[disks-naming,Имена устройств дисков].

`mount-point`::
Существующий каталог, на который монтируется файловая система.

`fstype`::
Тип файловой системы, передаваемый в man:mount[8]. Файловая система по умолчанию в FreeBSD — `ufs`.

`options`::
`rw` для файловых систем с доступом на чтение и запись или `ro` для файловых систем только для чтения, за которыми могут следовать другие необходимые опции. Часто используется опция `noauto` для файловых систем, которые обычно не монтируются при загрузке. Другие опции перечислены в man:mount[8].

`dumpfreq`::
Используется man:dump[8] для определения, какие файловые системы требуют дампинга. Если поле отсутствует, предполагается значение ноль.

`passno`::
Определяет порядок проверки файловых систем UFS с помощью man:fsck[8] после перезагрузки. Файловые системы, которые следует пропускать, должны иметь значение `passno`, равное нулю. Корневая файловая система должна проверяться первой и иметь значение `passno`, равное единице. Остальные файловые системы должны иметь значения больше единицы. Если несколько файловых систем имеют одинаковое значение `passno`, man:fsck[8] попытается проверять их параллельно, если это возможно.

См. man:fstab[5] для получения дополнительной информации о формате `/etc/fstab` и его параметрах.

[[disks-mount]]
=== Использование man:mount[8]

Файловые системы монтируются с помощью man:mount[8]. Базовая синтаксическая конструкция выглядит следующим образом:

[example]
====
[source, shell]
....
# mount device mountpoint
....
====

Файловая система, указанная в `/etc/fstab`, также может быть смонтирована, если указать только точку монтирования.

Эта команда предоставляет множество опций, которые описаны в man:mount[8]. Наиболее часто используемые опции включают:

.Параметры монтирования
`-a`::
Смонтировать все файловые системы, перечисленные в `/etc/fstab`, за исключением тех, которые помечены как "noauto", исключены флагом `-t` или уже смонтированы.

`-d`::
Выполнить все действия, кроме самого системного вызова mount. Эта опция полезна в сочетании с флагом `-v` для определения того, что на самом деле пытается сделать man:mount[8].

`-f`::
Принудительно смонтировать поврежденную файловую систему (опасно) или отозвать права на запись при понижении статуса монтирования файловой системы с чтения-записи на только чтение.

`-r`::
Смонтировать файловую систему в режиме только для чтения. Это эквивалентно использованию `-o ro`.

``-t _тип_фс_``::
Смонтировать указанный тип файловой системы или смонтировать только файловые системы данного типа, если включен параметр `-a`. Тип файловой системы "ufs" используется по умолчанию.

`-u`::
Обновить параметры монтирования файловой системы.

`-v`::
Выдавать более подробную информацию.

`-w`::
Смонтировать файловую систему в режиме чтения-записи.

Следующие параметры могут быть переданы в `-o` в виде списка, разделенного запятыми:

`nosuid`::
Не интерпретировать флаги setuid или setgid на файловой системе. Это также полезная опция безопасности.

[[disks-umount]]
=== Использование man:umount[8]

Для размонтирования файловой системы используйте man:umount[8]. Эта команда принимает один параметр, которым может быть точка монтирования, имя устройства, `-a` или `-A`.

Все формы команды принимают параметр `-f` для принудительного размонтирования и `-v` для вывода подробной информации. Учтите, что использование `-f` обычно не рекомендуется, так как это может привести к аварийному завершению работы компьютера или повреждению данных в файловой системе.

Для размонтирования всех смонтированных файловых систем или только файловых систем указанных после `-t` типов используйте `-a` или `-A`. Обратите внимание, что `-A` не пытается размонтировать корневую файловую систему.

[[basics-processes]]
== Процессы и Демоны

FreeBSD - это многозадачная операционная система. Каждая программа, выполняемая в любой момент времени, называется _процессом_. Каждая запущенная команда создает как минимум один новый процесс, и в системе FreeBSD выполняется ряд системных процессов.

Каждый процесс однозначно идентифицируется числом, называемым _идентификатором процесса_ (PID). Подобно файлам, каждый процесс имеет владельца и группу, а права владельца и группы используются для определения того, какие файлы и устройства процесс может открыть. Большинство процессов также имеют родительский процесс, который их запустил. Например, оболочка — это процесс, и любая команда, запущенная в оболочке, является процессом, для которого оболочка выступает родительским процессом. Исключением является специальный процесс man:init[8], который всегда запускается первым при загрузке и всегда имеет PID `1`.

Некоторые программы не предназначены для постоянного взаимодействия с пользователем и отключаются от терминала при первой возможности. Например, веб-сервер отвечает на веб-запросы, а не на действия пользователя. Почтовые серверы — ещё один пример таких приложений. Эти программы называются _демонами_. Термин «демон» происходит из греческой мифологии и обозначает сущность, которая не является ни доброй, ни злой и незаметно выполняет полезные задачи. Именно поэтому талисманом BSD стал улыбающийся демон в кроссовках и с вилами.

Существует соглашение называть программы, которые обычно работают как демоны, с добавлением буквы "d" в конце. Например, BIND — это Berkeley Internet Name Domain, но фактическая программа, которая выполняется, называется `named`. Веб-сервер Apache называется `httpd`, а демон очереди печати — `lpd`. Это всего лишь соглашение об именовании. Например, основной почтовый демон для приложения Sendmail называется `sendmail`, а не `maild`.

=== Просмотр процессов

Чтобы просмотреть процессы, выполняемые в системе, используйте man:ps[1] или man:top[1]. Для отображения статичного списка текущих процессов, их PID, объема используемой памяти и команд, которыми они были запущены, используйте man:ps[1]. Для отображения всех выполняемых процессов с периодическим обновлением списка каждые несколько секунд, чтобы интерактивно наблюдать за работой компьютера, используйте man:top[1].

По умолчанию man:ps[1] отображает только команды, выполняемые и принадлежащие текущему пользователю. Например:

[source, shell]
....
% ps
....

Вывод должен быть похож на следующий:

[.programlisting]
....
 PID TT  STAT    TIME COMMAND
8203  0  Ss   0:00.59 /bin/csh
8895  0  R+   0:00.00 ps
....

Вывод команды man:ps[1] организован в несколько столбцов. В столбце `PID` отображается идентификатор процесса. PID начинаются с 1, достигают 99999, затем снова начинаются с начала. Однако, если PID уже используется, он не будет повторно назначен. Столбец `TT` показывает tty, на котором выполняется программа, а `STAT` отображает состояние программы. `TIME` — это время, в течение которого программа выполнялась на CPU. Обычно это не общее время с момента запуска программы, так как большинство программ проводят много времени в ожидании событий, прежде чем им потребуется время на CPU. Наконец, `COMMAND` — это команда, которая использовалась для запуска программы.

Доступно несколько различных опций для изменения отображаемой информации. Один из наиболее полезных наборов — `auxww`, где `a` показывает информацию обо всех запущенных процессах всех пользователей, `u` отображает имя пользователя и использование памяти владельцем процесса, `x` показывает информацию о процессах демонов, а `ww` заставляет man:ps[1] выводить полную командную строку для каждого процесса вместо её обрезки, когда она становится слишком длинной для экрана.

Вывод команды man:top[1] выглядит аналогично:

[source, shell]
....
% top
....

Вывод должен быть похож на следующий:

[.programlisting]
....
last pid:  9609;  load averages:  0.56,  0.45,  0.36              up 0+00:20:03  10:21:46
107 processes: 2 running, 104 sleeping, 1 zombie
CPU:  6.2% user,  0.1% nice,  8.2% system,  0.4% interrupt, 85.1% idle
Mem: 541M Active, 450M Inact, 1333M Wired, 4064K Cache, 1498M Free
ARC: 992M Total, 377M MFU, 589M MRU, 250K Anon, 5280K Header, 21M Other
Swap: 2048M Total, 2048M Free

  PID USERNAME    THR PRI NICE   SIZE    RES STATE   C   TIME   WCPU COMMAND
  557 root          1 -21  r31   136M 42296K select  0   2:20  9.96% Xorg
 8198 dru           2  52    0   449M 82736K select  3   0:08  5.96% kdeinit4
 8311 dru          27  30    0  1150M   187M uwait   1   1:37  0.98% firefox
  431 root          1  20    0 14268K  1728K select  0   0:06  0.98% moused
 9551 dru           1  21    0 16600K  2660K CPU3    3   0:01  0.98% top
 2357 dru           4  37    0   718M   141M select  0   0:21  0.00% kdeinit4
 8705 dru           4  35    0   480M    98M select  2   0:20  0.00% kdeinit4
 8076 dru           6  20    0   552M   113M uwait   0   0:12  0.00% soffice.bin
 2623 root          1  30   10 12088K  1636K select  3   0:09  0.00% powerd
 2338 dru           1  20    0   440M 84532K select  1   0:06  0.00% kwin
 1427 dru           5  22    0   605M 86412K select  1   0:05  0.00% kdeinit4
....

Вывод разделён на две части. Заголовок (первые пять или шесть строк) показывает PID последнего запущенного процесса, среднюю загрузку системы (которая отражает, насколько система занята), время работы системы (время с последней перезагрузки) и текущее время. Остальные данные в заголовке относятся к количеству запущенных процессов, объёму используемой оперативной памяти и файла подкачки (свопа), а также времени, которое система проводит в различных состояниях процессора. Если загружен модуль файловой системы ZFS, строка `ARC` указывает, сколько данных было прочитано из кэша памяти, а не с диска.

Ниже заголовка расположен ряд столбцов с информацией, аналогичной выводу команды man:ps[1], такой как PID, имя пользователя, объем CPU времени и команда, запустившая процесс. По умолчанию man:top[1] также отображает объем памяти, занимаемый процессом. Эта информация разделена на два столбца: один для общего размера и один для резидентного размера. Общий размер — это объем памяти, который потребовался приложению, а резидентный размер — это объем, который оно фактически использует в данный момент.

man:top[1] автоматически обновляет отображение каждые две секунды. Другой интервал можно указать с помощью `-s`.

[[basics-daemons]]
=== Прекращение процессов

Один из способов взаимодействия с любым запущенным процессом или демоном — отправить _сигнал_ с помощью man:kill[1]. Существует множество различных сигналов; некоторые имеют определённое значение, в то время как другие описаны в документации приложения. Пользователь может отправлять сигналы только своим процессам, и попытка отправить сигнал чужому процессу приведёт к ошибке отказа в доступе. Исключением является пользователь `root`, который может отправлять сигналы любым процессам.

Операционная система также может отправлять сигналы процессу. Если приложение написано с ошибками и пытается получить доступ к памяти, к которой оно не должно обращаться, FreeBSD отправит процессу сигнал "Нарушение сегментации" (`SIGSEGV`). Если приложение было написано с использованием системного вызова man:alarm[3] для оповещения по истечении определенного времени, ему будет отправлен сигнал "Будильник" (`SIGALRM`).

Для остановки процесса могут использоваться два сигнала: `SIGTERM` и `SIGKILL`. `SIGTERM` — это вежливый способ завершить процесс, так как процесс может прочитать сигнал, закрыть все открытые файлы журналов и попытаться завершить текущие операции перед остановкой. В некоторых случаях процесс может игнорировать `SIGTERM`, если он находится в середине задачи, которую нельзя прервать.

`SIGKILL` не может быть проигнорирован процессом. Отправка `SIGKILL` процессу обычно немедленно останавливает этот процесс. footnote:[Существует несколько задач, которые не могут быть прерваны. Например, если процесс пытается прочитать файл, находящийся на другом компьютере в сети, и этот компьютер недоступен, процесс считается непрерываемым. В конечном итоге процесс завершится по таймауту, обычно через две минуты. Как только это произойдет, процесс будет убит.].

Другие часто используемые сигналы — это `SIGHUP`, `SIGUSR1` и `SIGUSR2`. Поскольку они предназначены для общего применения, разные программы могут реагировать на них по-разному.

Например, после изменения конфигурационного файла веб-сервера необходимо указать веб-серверу перечитать его конфигурацию. Перезапуск `httpd` приведёт к кратковременному простою веб-сервера. Вместо этого отправьте демону сигнал `SIGHUP`. Учтите, что разные демоны могут вести себя по-разному, поэтому обратитесь к документации демона, чтобы определить, приведёт ли `SIGHUP` к желаемому результату.

[IMPORTANT]
====
Убить случайный процесс в системе — плохая идея. В частности, man:init[8], PID 1, является особым. Запуск `/bin/kill -s KILL 1` — это быстрый, но не рекомендуемый способ выключить систему. _Всегда_ перепроверяйте аргументы для man:kill[1] _перед_ нажатием kbd:[Return].
====

[[shells]]
== Оболочки

_Оболочка_ предоставляет интерфейс командной строки для взаимодействия с операционной системой. Оболочка получает команды из входного канала и выполняет их. Многие оболочки предоставляют встроенные функции для помощи в повседневных задачах, таких как управление файлами, подстановка имён файлов (file globbing), редактирование командной строки, макросы команд и переменные окружения. FreeBSD поставляется с несколькими оболочками, включая Bourne shell (man:sh[1]) и расширенную C shell (man:tcsh[1]). Другие оболочки доступны в коллекции портов FreeBSD, например `zsh` и `bash`.

Используемая оболочка — это действительно вопрос предпочтений. Программисту на C может быть удобнее работать с C-подобной оболочкой, такой как man:tcsh[1]. Пользователь Linux(R) может предпочесть `bash`. Каждая оболочка обладает уникальными свойствами, которые могут подходить или не подходить под предпочитаемую пользователем рабочую среду, поэтому существует выбор, какую оболочку использовать.

Одной из распространённых возможностей оболочки является завершение имён файлов. Когда пользователь вводит первые несколько букв команды или имени файла и нажимает kbd:[Tab], оболочка автоматически дописывает оставшуюся часть команды или имени файла. Рассмотрим два файла с именами `foobar` и `football`. Чтобы удалить `foobar`, пользователь может ввести `rm foo` и нажать kbd:[Tab] для завершения имени файла.

Но оболочка показывает только `rm foo`. Она не смогла завершить имя файла, потому что и `foobar`, и `football` начинаются с `foo`. Некоторые оболочки издают звуковой сигнал или показывают все варианты, если совпадает более одного имени. Пользователь должен затем ввести дополнительные символы, чтобы указать нужное имя файла. Ввод `t` и повторное нажатие kbd:[Tab] достаточно, чтобы оболочка определила, какое имя файла требуется, и заполнила остальное.

Еще одна особенность оболочки — использование переменных окружения. Переменные окружения представляют собой пару переменная/ключ, хранящуюся в окружении оболочки. Это окружение может быть прочитано любой программой, запущенной оболочкой, и поэтому содержит множество настроек программ. В crossref:basics[shell-env-vars,Распространенные переменные окружения] приведен список распространенных переменных окружения и их значений. Обратите внимание, что имена переменных окружения всегда записываются в верхнем регистре.

[[shell-env-vars]]
.Распространенные переменные окружения
[cols="25h,~"]
|===
| Переменная
| Описание

|`USER`
|Имя текущего вошедшего пользователя.

|`PATH`
|Двоеточием разделённый список каталогов для поиска бинарных файлов.

|`DISPLAY`
|Сетевое имя дисплея Xorg для подключения, если доступно.

|`SHELL`
|Текущая оболочка.

|`TERM`
|Имя типа терминала пользователя. Используется для определения возможностей терминала.

|`TERMCAP`
|Запись в базе данных escape-кодов терминала для выполнения различных функций терминала.

|`OSTYPE`
|Тип операционной системы.

|`MACHTYPE`
|Архитектура процессора системы.

|`EDITOR`
|Предпочитаемый текстовый редактор пользователя.

|`PAGER`
|Предпочитаемая пользователем утилита для просмотра текста постранично.

|`MANPATH`
|Двоеточием разделённый список каталогов для поиска страниц руководства.
|===

Как установить переменную окружения, зависит от используемой оболочки. В man:tcsh[1] и man:csh[1] используйте `setenv` для установки переменных окружения. В man:sh[1] и `bash` используйте `export` для установки текущих переменных окружения. В этом примере устанавливается значение `EDITOR` по умолчанию в `/usr/local/bin/emacs` для оболочки man:tcsh[1]:

[source, shell]
....
% setenv EDITOR /usr/local/bin/emacs
....

Эквивалентная команда для `bash` будет:

[source, shell]
....
% export EDITOR="/usr/local/bin/emacs"
....

Чтобы раскрыть переменную окружения и увидеть её текущее значение, введите символ `$` перед её именем в командной строке. Например, `echo $TERM` выведет текущее значение переменной `$TERM`.

Оболочки интерпретируют специальные символы, известные как метасимволы, как особые представления данных. Наиболее распространённый метасимвол — `\*`, который обозначает любое количество символов в имени файла. Метасимволы могут использоваться для подстановки имён файлов (globbing). Например, команда `echo *` эквивалентна `ls`, поскольку оболочка выбирает все файлы, соответствующие шаблону `\*`, а `echo` выводит их в командной строке.

Чтобы предотвратить интерпретацию специального символа оболочкой, экранируйте его с помощью обратной косой черты (`\`). Например, `echo $TERM` выводит настройки терминала, тогда как `echo \$TERM` выводит строку `$TERM` буквально.

[[changing-shells]]
=== Изменение оболочки

Самый простой способ навсегда изменить оболочку по умолчанию — использовать `chsh`. Запуск этой команды откроет редактор, настроенный в переменной окружения `EDITOR`, которая по умолчанию установлена в man:vi[1]. Измените строку `Shell:` на полный путь к новой оболочке.

Или используйте `chsh -s`, который установит указанную оболочку без открытия редактора. Например, чтобы изменить оболочку на `bash`:

[source, shell]
....
% chsh -s /usr/local/bin/bash
....

Введите пароль в командной строке и нажмите kbd:[Return], чтобы изменить оболочку. Выйдите из системы и войдите снова, чтобы начать использовать новую оболочку.

[NOTE]
====
Новая оболочка *обязательно* должна присутствовать в `/etc/shells`. Если оболочка была установлена из Коллекции портов FreeBSD, как описано в crossref:ports[ports,Установка приложений: Пакеты и порты], она должна быть автоматически добавлена в этот файл. Если её там нет, добавьте её с помощью следующей команды, заменив путь на путь к вашей оболочке:

[source, shell]
....
# echo /usr/local/bin/bash >> /etc/shells
....

Затем снова запустите man:chsh[1].
====

=== Продвинутые методы работы с оболочкой

UNIX(R) оболочка — это не просто командный интерпретатор, а мощный инструмент, который позволяет пользователям выполнять команды, перенаправлять их вывод и ввод, а также объединять команды в цепочки для улучшения конечного результата. В сочетании со встроенными командами это предоставляет пользователю среду, способную максимизировать эффективность работы.

Перенаправление в оболочке — это действие отправки вывода или ввода команды в другую команду или файл. Например, чтобы сохранить вывод команды man:ls[1] в файл, перенаправьте вывод:

[source, shell]
....
% ls > directory_listing.txt
....

Содержимое каталога теперь будет отображено в файле `directory_listing.txt`. Некоторые команды, например man:sort[1], могут использоваться для чтения ввода. Чтобы отсортировать этот список, перенаправьте ввод:

[source, shell]
....
% sort < directory_listing.txt
....

Входные данные будут отсортированы и выведены на экран. Чтобы перенаправить эти данные в другой файл, можно перенаправить вывод `man:sort[1]`, изменив направление:

[source, shell]
....
% sort < directory_listing.txt > sorted.txt
....

Во всех предыдущих примерах команды выполняют перенаправление с использованием файловых дескрипторов. Каждая UNIX(R)-система имеет файловые дескрипторы, включая стандартный ввод (stdin), стандартный вывод (stdout) и стандартный вывод ошибок (stderr). Каждый из них имеет своё назначение: ввод может осуществляться с клавиатуры или мыши — устройств, предоставляющих входные данные. Вывод может направляться на экран или бумагу в принтере. А ошибки — это всё, что используется для диагностических или сообщений об ошибках. Все три типа считаются файловыми дескрипторами, основанными на вводе-выводе, и иногда называются потоками.

С помощью этих дескрипторов оболочка позволяет передавать вывод и ввод между различными командами и перенаправлять их в файл или из файла. Другой метод перенаправления — оператор конвейера.

Оператор UNIX(R) pipe, `|`, позволяет передавать вывод одной команды напрямую или направлять его другой программе. По сути, pipe позволяет передать стандартный вывод одной команды в качестве стандартного ввода другой команды, например:

[source, shell]
....
% cat directory_listing.txt | sort | less
....

В этом примере содержимое файла `directory_listing.txt` будет отсортировано, а вывод передан в man:less[1]. Это позволяет пользователю прокручивать вывод в удобном темпе и предотвращает его исчезновение с экрана.

[[editors]]
== Текстовые редакторы

Большая часть настройки FreeBSD выполняется путём редактирования текстовых файлов, поэтому рекомендуется освоить текстовый редактор. В базовую систему FreeBSD входит несколько таких редакторов, а ещё больше доступно в Коллекции портов.

Простой редактор для освоения — это man:ee[1], что означает «легкий редактор». Чтобы запустить его, введите `ee _имя_файла_`, где _имя_файла_ — это имя редактируемого файла. Внутри редактора все команды для управления его функциями перечислены в верхней части экрана. Символ каретки (`^`) обозначает kbd:[Ctrl], поэтому `^e` означает kbd:[Ctrl+e]. Для выхода из man:ee[1] нажмите kbd:[Esc] и выберите пункт «покинуть редактор» в главном меню. Если файл был изменен, редактор предложит сохранить изменения.

FreeBSD также включает более мощные текстовые редакторы, такие как man:vi[1], в составе базовой системы. Другие редакторы, например package:editors/emacs[] и package:editors/vim[], доступны в коллекции портов FreeBSD. Эти редакторы предоставляют больше возможностей, но их освоение сложнее. Изучение более мощного редактора, такого как vim или Emacs, может сэкономить время в долгосрочной перспективе.

Многие приложения, которые изменяют файлы или требуют ввода текста, автоматически открывают текстовый редактор. Чтобы изменить редактор по умолчанию, установите переменную окружения `EDITOR`, как описано в crossref:basics[shells, Оболочки].

[[basics-devices]]
== Устройства и Узлы Устройств

Устройство — это термин, в основном используемый для описания аппаратных компонентов системы, таких как диски, принтеры, видеокарты и клавиатуры. При загрузке FreeBSD большинство сообщений относятся к обнаружению устройств. Копия этих сообщений сохраняется в файле `/var/run/dmesg.boot`.

У каждого устройства есть имя и номер. Например, `ada0` — это первый жёсткий диск SATA, а `kbd0` обозначает клавиатуру.

Большинство устройств в FreeBSD должны быть доступны через специальные файлы, называемые узлами устройств, которые расположены в `/dev`.

[[basics-more-information]]
== Справочник

Наиболее полная документация по FreeBSD представлена в виде Справочника (manual pages). Почти каждая программа в системе имеет краткое справочное руководство, объясняющее основы работы и доступные аргументы. Эти руководства можно просматривать с помощью команды `man`:

[source, shell]
....
% man command
....

где _command_ — это название команды, о которой нужно узнать больше. Например, чтобы узнать больше о man:ls[1], введите:

[source, shell]
....
% man ls
....

Страницы Справочника разделены на разделы, которые обозначают тип темы. В FreeBSD доступны следующие разделы:

. Пользовательские команды.
. Системные вызовы и коды ошибок.
. Функции в библиотеках C.
. Драйверы устройств.
. Форматы файлов.
. Развлечения и другие игры.
. Различная информация.
. Системные команды обслуживания и эксплуатации.
. Интерфейсы ядра системы.

В некоторых случаях одна и та же тема может встречаться в нескольких разделах онлайн-руководства. Например, существует пользовательская команда `chmod` и системный вызов `chmod()`. Чтобы указать man:man[1], какой раздел отображать, укажите номер раздела:

[source, shell]
....
% man 1 chmod
....

Это отобразит справочную страницу для пользовательской команды man:chmod[1]. Ссылки на определённый раздел онлайн-руководства традиционно заключаются в скобки в письменной документации, поэтому man:chmod[1] относится к пользовательской команде, а man:chmod[2] — к системному вызову.

Если название страницы руководства неизвестно, используйте `man -k` для поиска ключевых слов в описаниях страниц руководства:

[source, shell]
....
% man -k mail
....

Эта команда выводит список команд, содержащих ключевое слово "mail" в их описаниях. Это эквивалентно использованию man:apropos[1].

Чтобы прочитать описания всех команд в `/usr/sbin`, введите:

[source, shell]
....
% cd /usr/sbin
% man -f * | more
....

или

[source, shell]
....
% cd /usr/sbin
% whatis * |more
....

[[basics-info]]
=== Файлы GNU Info

FreeBSD включает несколько приложений и утилит, созданных Free Software Foundation (FSF). Помимо man-страниц, эти программы могут содержать гипертекстовые документы, называемые файлами `info`. Их можно просматривать с помощью man:info[1] или, если установлен package:editors/emacs[], в режиме info редактора emacs.

Чтобы использовать man:info[1], введите:

[source, shell]
....
% info
....

Для краткого введения введите `h`. Для быстрой справки по командам введите `?`.
