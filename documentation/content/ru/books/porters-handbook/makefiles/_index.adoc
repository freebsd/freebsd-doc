---
title: Глава 5. Настройка файла Makefile
prev: books/porters-handbook/slow-porting
next: books/porters-handbook/special
showBookMenu: true
weight: 5
path: "/books/porters-handbook/makefiles/"
---

[[makefiles]]
= Настройка файла Makefile
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 5
:partnums:
:source-highlighter: rouge
:experimental:
:gcc-plus-plus: g++
:images-path: books/porters-handbook/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

Настройка файла [.filename]#Makefile# достаточно проста, и мы снова предполагаем, что перед тем, как начать, вы посмотрите на существующие примеры. К тому же в этом руководстве имеется <<porting-samplem,примерный Makefile>>, так что взгляните на него и, пожалуйста, следуйте порядку переменных и разделов в этом образце, чтобы облегчить чтение вашего порта другими людьми.

Итак, расположим решаемые задачи в порядке их возникновения при создании вашего нового файла [.filename]#Makefile#:

[[makefile-source]]
== Оригинальные исходный код

Находится ли он в каталоге `DISTDIR` в виде стандартного упакованного архиватором `gzip` tar-архива с именем типа [.filename]#foozolix-1.2.tar.gz#? Если это так, можно перейти к следующему шагу. Если нет, то вы должны попытаться переопределить некоторые из переменных `DISTVERSION`, `DISTNAME`, `EXTRACT_CMD`, `EXTRACT_BEFORE_ARGS`, `EXTRACT_AFTER_ARGS`, `EXTRACT_SUFX` или `DISTFILES` в зависимости от того, насколько необычен формат дистрибутивного файла.

В худшем случае вы можете просто определить свою собственную цель `do-extract` для переопределения действий по умолчанию, хотя к этому нужно будет прибегать в очень редких случаях, если вообще придётся.

[[makefile-naming]]
== Именование

В первой части [.filename]#Makefile# порта ему даётся название, указывается его номер версии и принадлежность к правильной категории.

=== `PORTNAME` и `PORTVERSION`

В переменной `PORTNAME` вы должны указать основную часть имени вашего порта, а в переменной `PORTVERSION` - номер версии.

[[makefile-naming-revepoch]]
=== `PORTREVISION` и `PORTEPOCH`

==== `PORTREVISION`

Переменная `PORTREVISION` представляет собой монотонно увеличивающееся число, которое обнуляется при каждом увеличении значения переменной `PORTVERSION` (то есть каждый раз, когда создателями выпускается новый официальный релиз), и добавляется к имени пакета, если оно не равно нулю. Изменения в `PORTREVISION` используются автоматизированными инструментами (например, `pkg version`, см. man:pkg-version[8]) для определения факта появления нового пакета.

Значение `PORTREVISION` должно увеличиваться каждый раз, когда в порте FreeBSD делаются изменения, которые как-либо меняют получаемый пакет. Сюда относятся только изменения, затрагивающие построение пакета с <<makefile-options,параметрами>> по умолчанию.

Примеры случаев, когда значение `PORTREVISION` должно быть увеличено:

* Добавление патчей для исправления уязвимостей, ошибок, или добавления новой функциональности в порт.
* Изменения в файле [.filename]#Makefile# порта для включения и выключения параметров, определяемых при компиляции пакета.
* Изменения в списке упаковки или в поведении пакета во время его установки (например, изменение скрипта, генерирующего начальные данные для пакета, такие, как ssh-ключи для хоста).
* Увеличение версии динамической библиотеки, от которой зависит порт (в этом случае тот, кто попытается установить старый пакет после установки более новой версии библиотеки, не сможет этого сделать, потому что при этом будет делаться поиск старой библиотеки libfoo.x, а не libfoo.(x+1)).
* Большие функциональные изменения в дистрибутивном файле порта, происходящие без объявлений, и приводящие к большим изменениям, то есть изменения в дистрибутиве требуют корректировки файла [.filename]#distinfo# без соответствующего изменения `PORTVERSION`, когда как команда `diff -ru` между новой и старой версиями показывает нетривиальные изменения в коде.

Примеры изменений, которые не требуют увеличения переменной `PORTREVISION`:

* Изменения стиля в скелете порта без функциональных изменений в пакете.
* Изменения в переменной `MASTER_SITES` или другие функциональные изменения порта, которые не затрагивают получающегося пакета.
* Тривиальные патчи к дистрибутивному файлу, такие, как исправления опечаток, которые не так уж важны, что пользователи пакета должны озаботиться обновлением.
* Исправления, касающиеся этапа построения, которые делают возможным построение пакета, если ранее это было невозможно сделать (пока изменения не приводят к изменению работы на любых других платформах, на которых порт ранее строился). Так как `PORTREVISION` отражает содержимое пакета, то, если ранее пакет не строился, то нет нужды увеличивать `PORTREVISION` для отметки изменения.

Правило, которому нужно приблизительно следовать, заключается в том, что нужно спрашивать себя, является ли вносимое в порт изменение таким, что от него выиграют все (в виде усовершенствования, исправления или благодаря тому, что новый пакет будет вообще работоспособным), и примите во внимание тот факт, что при этом все, кто регулярно обновляют своё дерево портов, будут обязаны это сделать. Если это так, то переменная `PORTREVISION` должна быть увеличена.

==== `PORTEPOCH`

Время от времени разработчик программного обеспечения или создатель порта FreeBSD делают что-то не так и выпускают версию программы, номер которой меньше предыдущей версии. Примером этого является порт, название которого меняется с foo-20000801 на foo-1.0 (изначально это не считалось бы более новой версией, так как 20000801 численно больше, чем 1).

[TIP]
====

Результат сравнения номера версии не всегда очевиден. Для выполнения сравнения двух строк с номером версии можно использовать `pkg version` (см. man:pkg-version[8]). Например:

[source,shell]
....
% pkg version -t 0.031 0.29
>
....

Строка `>` в выводе команды означает, что версия 0.031 считается выше, чем версия 0.29, что может быть не очевидно для того, кто выполняет портирование.
====

В ситуациях, подобных этой, должно быть увеличено значение `PORTEPOCH`. Если значение `PORTEPOCH` не равно нулю, то оно добавляется к имени пакета, как описано в разделе выше. Значение `PORTEPOCH` никогда не должно уменьшаться или сбрасываться в ноль, потому что это приведёт к ошибке сравнения с пакетом с меньшим номером эпохи (то есть то, что пакет устарел, обнаружено не будет): номер новой версии (например, `1.0,1` в примере выше) останется меньше, чем номер предыдущей версии (20000801), однако суффикс `,1` интерпретируется различными автоматизированными утилитами особым образом, и окажется больше, чем предполагаемый суффикс `,0` более раннего пакета).

Некорректное уменьшение или сброс `PORTEPOCH` приводит к печальным последствиям; если вы не поняли, о чём шла речь ранее, пожалуйста, всё же разберитесь с этим, либо спросите в списках рассылки.

Предполагается, что в большинстве портов переменная `PORTEPOCH` использоваться не будет, но при корректном использовании `PORTVERSION` может появиться необходимость её иметь, если в будущих релизах программное обеспечение должно изменить структуру номера версии. Однако создателям портов для FreeBSD нужно быть внимательными, когда разработчик выпускает релиз без официального номера версии - эдакие "промежуточные" релизы. Имеется соблазн пометить релиз датой его выхода, что может вызвать проблемы, как и в примере выше, когда будет выпущен новый "официальный" релиз.

Например, если промежуточный релиз помечен датой 20000917, а предыдущая версия программного обеспечения имела номер 1.2, то промежуточному релизу должно быть поставлено в соответствие значение `PORTVERSION`, равное 1.2.20000917 или что-то похожее, но не 20000917, так как последующий релиз, скажем, 1.3, должен иметь численно большее значение.

==== Пример использования переменных `PORTREVISION` и `PORTEPOCH`

Выполнен коммит порта `gtkmumble`, версии `0.10`, в коллекцию портов.

[.programlisting]
....
PORTNAME=	gtkmumble
PORTVERSION=	0.10
....

Значение `PKGNAME` станет равным `gtkmumble-0.10`.

Обнаружена брешь в безопасности, исправление которой потребовало создания локального патча для FreeBSD. Соответственно было увеличено значение переменной `PORTREVISION`.

[.programlisting]
....
PORTNAME=	gtkmumble
PORTVERSION=	0.10
PORTREVISION=	1
....

`PKGNAME` принимает значение `gtkmumble-0.10_1`

Разработчиком выпущена новая версия с номером `0.2` (оказалось, что под номером `0.10` автор имел в виду `0.1.0`, а не "то, что будет выпущено после версии 0.9" - извините, теперь уже поздно). Так как новый младший номер версии `2` по значению меньше, чем номер предыдущей версии `10`, то должно быть увеличено значение `PORTEPOCH` для того, чтобы заставить распознавать вновь создаваемый пакет как "более новый". Так как это новый релиз программы, то `PORTREVISION` обнуляется (или удаляется из файла [.filename]#Makefile#).

[.programlisting]
....
PORTNAME=	gtkmumble
PORTVERSION=	0.2
PORTEPOCH=	1
....

`PKGNAME` принимает значение `gtkmumble-0.2,1`

Следующий релиз имеет номер версии 0.3. Так как значение переменной `PORTEPOCH` никогда не уменьшается, что переменные, определяющие версии, теперь выглядят так:

[.programlisting]
....
PORTNAME=	gtkmumble
PORTVERSION=	0.3
PORTEPOCH=	1
....

`PKGNAME` принимает значение `gtkmumble-0.3,1`

[NOTE]
====
Если значение `PORTEPOCH` этим обновлением было бы сброшено в `0`, то кто-нибудь, имеющий установленный пакет `gtkmumble-0.10_1`, не смог бы опознать пакет `gtkmumble-0.3` как более новый, так как `3` было бы меньше, чем `10`. Помните, что в первую очередь это касается `PORTEPOCH`.
====

=== Переменные `PKGNAMEPREFIX` и `PKGNAMESUFFIX`

Две необязательные переменные, `PKGNAMEPREFIX` и `PKGNAMESUFFIX`, объединяются со значениями `PORTNAME` и `PORTVERSION` для формирования `PKGNAME` в форме `${PKGNAMEPREFIX}${PORTNAME}${PKGNAMESUFFIX}-${PORTVERSION}`. Добейтесь того, чтобы это соответствовало нашим <<porting-pkgname,рекомендациям по правильному выбору названий для пакетов>>. В частности, в переменной `PORTVERSION` _не разрешается_ использование дефиса (`-`). Кроме того, если в имени пакета присутствует часть _language-_ или _-compiled.specifics_ (смотрите ниже), то используйте переменные `PKGNAMEPREFIX` и `PKGNAMESUFFIX`, соответственно. Не делайте их частью значения переменной `PORTNAME`.

[[porting-pkgname]]
=== Соглашения по именованию пакетов

Далее описаны некоторые соглашения, которым вы должны следовать в именовании ваших пакетов. Они были разработаны для облегчения просмотра каталога, так как имеется уже тысячи пакетов, а пользователи отвернутся от нас, если список не понравится их взору!

Имя пакета должно иметь вид [.filename]#language_region-name-compiled.specifics-version.numbers#.

Имя пакета определяется как `${PKGNAMEPREFIX}${PORTNAME}${PKGNAMESUFFIX}-${PORTVERSION}`. Вы должны задавать значения переменных в соответствии с этим форматом.

. FreeBSD пытается поддерживать языки, на которых разговаривают её пользователи. Часть _language-_ должна быть двухсимвольным сокращением от названия языка по стандарту ISO-639, если порт специфичен для конкретного языка. Примерами являются `ja` для японского, `ru` для русского, `vi` для вьетнамского, `zh` для китайского, `ko` для корейского и `de` для немецкого языков.
+ 
Если ваш порт специфичен для конкретного региона внутри области использования языка, добавьте также двухсимвольный код страны. Примерами являются `en_US` для US English и `fr_CH` для Swiss French.
+ 
Часть _language-_ должна задаваться в переменной `PKGNAMEPREFIX`.
. Первая буква части [.filename]#name# должна быть в нижнем регистре. (Оставшаяся часть названия может содержать буквы в верхнем регистре, так что принимайте решение сами, когда преобразуете имя программного пакета, содержащего в имени некоторое количество заглавных букв.) Существует традиция именовать модули для `Perl 5`, добавляя впереди `p5-` и преобразуя пару двоеточий в дефис; например, модуль `Data::Dumper` будет именоваться `p5-Data-Dumper`.
. Убедитесь, что имя порта и версия четко отделены и размещаются в переменных `PORTNAME` и `PORTVERSION`. Единственная причина, по которой `PORTNAME` содержит версионную часть, это если полученный дистрибутив сам назван таким образом, как это сделано для портов [.filename]#textproc/libxml2# или [.filename]#japanese/kinput2-freewnn#. В противном случае `PORTNAME` не должен содержать никакой информации, указывающей на версию. То, что некоторые порты имеют одинаковый `PORTNAME`, является вполне нормальным, как для портов [.filename]#www/apache*#; в этом случае различные версии (и различные записи в индексе) отличаются по значениям `PKGNAMEPREFIX` и `PKGNAMESUFFIX`.
. Если порт может быть построен с различными <<makefile-masterdir,статически заданными значениями по умолчанию>> (обычно это часть имени каталога в семействе портов), то часть _-compiled.specifics_ должна определять вкомпилированные значения по умолчанию (дефис не обязателен). Примерами являются размеры бумаги и шрифтов.
+ 
Часть _-compiled.specifics_ должна задаваться в переменной `PKGNAMESUFFIX`.
. Строка с номером версии должна следовать за дефисом (`-`) и являться списком разделенных двоеточием чисел и букв в нижнем регистре. В частности, не разрешается иметь еще один дефис внутри строки с обозначением номера версии. Единственным исключением является строчка `pl` (означающая "patchlevel"), которая может использоваться _только_ тогда, когда у программного обеспечения нет старшего и младшего номера версии. Если в номер версии программного обеспечения включена строчка типа "alpha", "beta", "rc" или "pre", возьмите из неё первую букву и поставьте её непосредственно после точки. Если после таких строк номер версии ещё продолжается, то после буквы должно следовать число без дополнительной разделяющей точки.
+ 
Смысл такого формата заключается в удобстве сортировки портов по номеру версии. В частности, следите за тем, чтобы компоненты номера версии разделялись точкой, и если там присутствует дата, то используйте формат `0.0.yyyy.mm.dd`, но не `dd.mm.yyyy` или не совместимый с проблемой Y2K `yy.mm.dd`. Добавление к версии префикса `0.0.` является важным, в случае если выпущен релиз с присвоением настоящей версии, которая в числовом представлении, конечно же, будет ниже, чем `yyyy`.

Вот несколько (реальных) примеров того, как преобразовать имя из оригинального, придуманного авторами, к подходящему для имени пакета:

[.informaltable]
[cols="1,1,1,1,1,1", frame="none", options="header"]
|===
| Имя дистрибутива
| PKGNAMEPREFIX
| PORTNAME
| PKGNAMESUFFIX
| PORTVERSION
| Обоснование

|mule-2.2.2
|(пусто)
|mule
|(пусто)
|2.2.2
|Изменений не потребовалось

|EmiClock-1.0.2
|(пусто)
|emiclock
|(пусто)
|1.0.2
|Для отдельных программ имена с заглавными буквами запрещены

|rdist-1.3alpha
|(пусто)
|rdist
|(пусто)
|1.3.a
|Строчки типа `alpha` запрещены

|es-0.9-beta1
|(пусто)
|es
|(пусто)
|0.9.b1
|Строчки типа `beta` запрещены

|mailman-2.0rc3
|(пусто)
|mailman
|(пусто)
|2.0.r3
|Строчки типа `rc` запрещены

|v3.3beta021.src
|(пусто)
|tiff
|(пусто)
|3.3
|Что это такое было вообще?

|tvtwm
|(пусто)
|tvtwm
|(пусто)
|pl11
|Всегда требуется указание номера версии

|piewm
|(пусто)
|piewm
|(пусто)
|1.0
|Всегда требуется указание номера версии

|xvgr-2.10pl1
|(пусто)
|xvgr
|(пусто)
|2.10.1
|`pl` разрешено только при отсутствии старшего/младшего номера версии

|gawk-2.15.6
|ja-
|gawk
|(пусто)
|2.15.6
|Версия на японском языке

|psutils-1.13
|(пусто)
|psutils
|-letter
|1.13
|Размер бумаги задается статически во время построения пакета

|pkfonts
|(пусто)
|pkfonts
|300
|1.0
|пакет для шрифтов 300dpi
|===

Если в исходном коде абсолютно нет информации о номере версии и не похоже, что автор собирается выпускать другую версию, то в качестве номера версии задайте просто `1.0` (как в примере с `piewm` выше). В противном случае спросите автора программы или используйте дату (`0.0.yyyy.mm.dd`) в качестве номера версии.

[[makefile-categories]]
== Разделение по категориям

=== `CATEGORIES`

В процессе создания пакета он помещается в каталог [.filename]#/usr/ports/packages/All#, а в одном или более подкаталогов из [.filename]#/usr/ports/packages# создаются на него ссылки. Имена этих подкаталогов определяются переменной `CATEGORIES`. Такая схема нужна для облегчения жизни пользователя, когда он сталкивается с массой пакетов на FTP-сервере или компакт-диске. Пожалуйста, посмотрите на <<porting-categories,текущий список категорий>> и выберите те из них, которые более всего подходят к вашему порту.

Этот список также определяет, куда в дереве портов будет помещен порт. Если вы укажете здесь более одной категории, то предполагается, что файлы порта будут помещены в подкаталог с именем первой категории. Посмотрите <<choosing-categories,ниже>> для получения подробной информации о том, как правильно выбрать категории.

[[porting-categories]]
=== Текущий список категорий

Вот текущий список категорий. Те, которые отмечены звёздочкой (`*`), являются _виртуальными_ категориями-они не имеют собственного подкаталога в дереве портов. Они используются только в качестве вторичных категорий, и только для поиска.

[NOTE]
====
Для невиртуальных категорий имеется однострочное описание в `COMMENT` в [.filename]#Makefile# соответствующего подкаталога.
====

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Категория
| Описание
| Примечания

|[.filename]#accessibility#
|Порты для помощи пользователям с ограниченными возможностями.
|

|[.filename]#afterstep*#
|Порты, поддерживающие менеджер окон http://www.afterstep.org[AfterStep].
|

|[.filename]#arabic#
|Поддержка арабского языка.
|

|[.filename]#archivers#
|Инструменты для работы с архивами.
|

|[.filename]#astro#
|Приложения, связанные с астрономией.
|

|[.filename]#audio#
|Поддержка работы со звуком.
|

|[.filename]#benchmarks#
|Утилиты для измерения производительности системы.
|

|[.filename]#biology#
|Программное обеспечение, связанное с биологией.
|

|[.filename]#cad#
|Инструменты Систем Автоматизированного Проектирования.
|

|[.filename]#chinese#
|Поддержка китайского языка.
|

|[.filename]#comms#
|Коммуникационное программное обеспечение.
|В основном программы для работы с последовательным портом.

|[.filename]#converters#
|Утилиты для преобразования символьных форматов.
|

|[.filename]#databases#
|Базы данных.
|

|[.filename]#deskutils#
|То, что было на столе до изобретения компьютеров.
|

|[.filename]#devel#
|Утилиты для разработки программного обеспечения.
|Не помещайте сюда библиотеки просто потому, что это библиотеки-если они подпадают под какую-то другую категорию, то их быть здесь не должно.

|[.filename]#dns#
|Программное обеспечение для работы DNS.
|

|[.filename]#docs*#
|Мета-порты для документации FreeBSD.
|

|[.filename]#editors#
|Редакторы общего назначения.
|Специализированные редакторы относят к разделу для соответствующих инструментов (например, редактор математических формул попадает в категорию [.filename]#math#).

|[.filename]#elisp*#
|Порты для Emacs lisp.
|

|[.filename]#emulators#
|Эмуляторы других операционных систем.
|Эмуляторы терминалов сюда _не_ относятся-те, которые разработаны для X, должны быть в категории [.filename]#x11#, а текстовые в [.filename]#comms# или [.filename]#misc#, в зависимости от конкретного их предназначения.

|[.filename]#finance#
|Приложения для работы с деньгами, финансами и всем, что с этим связано.
|

|[.filename]#french#
|Поддержка французского языка.
|

|[.filename]#ftp#
|Клиенты и серверы FTP.
|Если ваш порт понимает как FTP, так и HTTP, поместите его в категорию [.filename]#ftp# и укажите вторичную категорию [.filename]#www#.

|[.filename]#games#
|Игры.
|

|[.filename]#geography*#
|Программное обеспечение, связанное с географией.
|

|[.filename]#german#
|Поддержка немецкого языка.
|

|[.filename]#gnome*#
|Порты Проекта http://www.gnome.org[GNOME].
|

|[.filename]#gnustep*#
|Программное обеспечение для окружения рабочего стола GNUstep.
|

|[.filename]#graphics#
|Графические утилиты.
|

|[.filename]#hamradio*#
|Программное обеспечение для любительского радио
|

|[.filename]#haskell*#
|Программное обеспечение, связанное с языком Haskell.
|

|[.filename]#hebrew#
|Поддержка иврита.
|

|[.filename]#hungarian#
|Поддержка венгерского языка.
|

|[.filename]#ipv6*#
|Программное обеспечение, связанное с IPv6.
|

|[.filename]#irc#
|Утилиты для Internet Relay Chat.
|

|[.filename]#japanese#
|Поддержка японского языка.
|

|[.filename]#java#
|Программное обеспечение, связанное с языком Java(TM).
|Категория [.filename]#java# ни в коем случае не должна быть единственной для порта. Оставьте для портов, непосредственно имеющих отношение к языку Java, портерам также рекомендуется не использовать [.filename]#java# как основную категорию порта.

|[.filename]#kde*#
|Порты проекта http://www.kde.org[KDE].
|

|[.filename]#kld*#
|Загружаемые модули ядра.
|

|[.filename]#korean#
|Поддержка корейского языка.
|

|[.filename]#lang#
|Языки программирования.
|

|[.filename]#linux*#
|Linux приложения и утилиты.
|

|[.filename]#lisp*#
|Программное обеспечение, связанное с языком Lisp.
|

|[.filename]#mail#
|Программы для работы с почтой.
|

|[.filename]#math#
|Программное обеспечение для численных вычислений и другие утилиты, связанные с математикой.
|

|[.filename]#mbone*#
|Приложения для MBone.
|

|[.filename]#misc#
|Различные утилиты
|В общем, то, что не попадает в другие категории. Если это возможно, попробуйте найти более подходящую, чем `misc`, категорию для вашего порта, так как здесь порты теряются.

|[.filename]#multimedia#
|Программное обеспечение для работы с мультимедиа.
|

|[.filename]#net#
|Различное сетевое программное обеспечение.
|

|[.filename]#net-im#
|Программы мгновенного обмена сообщениями.
|

|[.filename]#net-mgmt#
|Программное обеспечение для сетевого управления.
|

|[.filename]#net-p2p#
|Приложения для пиринговых сетей.
|

|[.filename]#news#
|Программное обеспечение для работы с конференциями USENET.
|

|[.filename]#palm#
|Программная поддержка http://www.palm.com/[Palm(TM)].
|

|[.filename]#parallel*#
|Приложения, связанные с параллельными вычислениями.
|

|[.filename]#pear*#
|Порты, относящиеся к технологии Pear PHP.
|

|[.filename]#perl5*#
|Порты, которым для работы требуется Perl версии 5.
|

|[.filename]#plan9*#
|Различные программы из http://www.cs.bell-labs.com/plan9dist/[Plan9].
|

|[.filename]#polish#
|Поддержка польского языка.
|

|[.filename]#ports-mgmt#
|Порты для управления, установки и разработки портов и пакетов FreeBSD.
|

|[.filename]#portuguese#
|Поддержка португальского языка.
|

|[.filename]#print#
|Программное обеспечение для печати.
|Инструменты для вёрстки (просмотрщики и тому подобное) тоже относятся сюда.

|[.filename]#python*#
|Программное обеспечение, связанное с языком http://www.python.org/[Python].
|

|[.filename]#ruby*#
|Программное обеспечение, связанное с языком http://www.ruby-lang.org/[Ruby].
|

|[.filename]#rubygems*#
|Порты для пакетов http://www.rubygems.org/[RubyGems].
|

|[.filename]#russian#
|Поддержка русского языка.
|

|[.filename]#scheme*#
|Программное обеспечение, связанное с языком Scheme.
|

|[.filename]#science#
|Научные программы, которые не подпадают под другие категории, скажем, [.filename]#astro#, [.filename]#biology# или [.filename]#math#.
|

|[.filename]#security#
|Программы, обеспечивающие безопасность системы.
|

|[.filename]#shells#
|Различные командные процессоры.
|

|[.filename]#sysutils#
|Системные утилиты.
|

|[.filename]#spanish*#
|Поддержка испанского языка.
|

|[.filename]#tcl*#
|Порты, для работы которых нужен Tcl.
|

|[.filename]#textproc#
|Утилиты для обработки текстов.
|Инструменты для вёрстки помещаются в категорию [.filename]#print#, а не сюда.

|[.filename]#tk*#
|Порты, для работы которых нужен Tk.
|

|[.filename]#ukrainian#
|Поддержка украинского языка.
|

|[.filename]#vietnamese#
|Поддержка вьетнамского языка.
|

|[.filename]#windowmaker*#
|Порты для поддержки менеджера окон WindowMaker.
|

|[.filename]#www#
|Программное обеспечение, связанное со всемирной паутиной.
|Поддержка языка HTML относится сюда же.

|[.filename]#x11#
|X Window System и иже с ними.
|Эта категория предназначена только для программного обеспечения, которое поддерживает саму оконную систему. Не помещайте сюда обычные приложения для X: большинство из них должны быть перенесены в другие категории [.filename]#x11-*# (смотрите ниже).

|[.filename]#x11-clocks#
|Часы для X11.
|

|[.filename]#x11-drivers#
|Драйверы X11.
|

|[.filename]#x11-fm#
|Менеджеры файлов для X11.
|

|[.filename]#x11-fonts#
|Шрифты для X11 и утилиты для работы с ними.
|

|[.filename]#x11-servers#
|Серверы для X11.
|

|[.filename]#x11-themes#
|Темы для X11.
|

|[.filename]#x11-toolkits#
|Пакеты разработчика для X11.
|

|[.filename]#x11-wm#
|Оконные менеджеры для X11.
|

|[.filename]#xfce*#
|Порты, связанные с окружением рабочего стола http://www.xfce.org/[Xfce].
|

|[.filename]#zope*#
|Поддержка http://www.zope.org/[Zope].
|
|===

[[choosing-categories]]
=== Выбор правильной категории

Так как многие категории перекрываются, вам часто необходимо будет выбирать, какая их них должна быть основной для вашего порта. Есть несколько правил, по которым можно решить этот вопрос. Вот список приоритетов, в уменьшающейся степени предпочтения:

* Первая категория должна быть физической категорий (смотрите <<porting-categories,выше>>). Это необходимо для создания пакетов. После этого виртуальные и физические категории могут смешиваться.
* Сначала всегда идут категории, специфичные для языков. Например, если ваш порт устанавливает японские шрифты для X11, то строчка `CATEGORIES` должна иметь вид [.filename]#japanese x11-fonts#.
* Более конкретные категории идут первыми перед более общими. В частности, редактор HTML должен быть описан как [.filename]#www editors#, а не наоборот. Кроме того, вы не должны указывать категорию [.filename]#net#, если порт относится к одной из категорий [.filename]#irc#, [.filename]#mail#, [.filename]#news#, [.filename]#security# или [.filename]#www#, так как [.filename]#net# включается автоматически.
* [.filename]#x11# используется как вторичная категория только в случае, если в качестве основной категории указан естественный язык. В частности, вам не нужно указывать [.filename]#x11# в качестве категории для приложений X.
* Режимы для редактора Emacs должны помещаться в ту же категорию, что и приложение, которое поддерживается этим режимом, а не в [.filename]#editors#. Например, режим Emacs для редактирования исходного кода некоторого языка программирования должен быть помещен в категорию [.filename]#lang#.
* Порты, устанавливающие загружаемые модули ядра, должны содержать виртуальную категорию [.filename]#kld# в строке `CATEGORIES`. Это одно из действий, выполняемых автоматически с добавлением `kmod` в строке `USES`.
* [.filename]#misc# не должна указываться вместе с любой другой невиртуальной категорией. Если вы указываете `misc` вместе с чем-то ещё в строке `CATEGORIES`, это значит, что вы можете спокойно удалить `misc` и просто поместить порт в этот другой подкаталог!
* Если ваш порт решительным образом не подпадает ни под какую категорию, поместите его в [.filename]#misc#.

Если вы не уверены в правильности выбора категории, пожалуйста, отметьте это в вашем сообщении man:send-pr[1], чтобы мы могли обсудить это до того, как включить порт в Коллекцию. Если вы являетесь коммиттером, пошлите замечание на адрес {freebsd-ports}, чтобы мы могли обсудить это. Зачастую новые порты помещаются не в ту категорию только для того, чтобы их оттуда сразу же удалили. Это приводит к излишнему и ненужному росту основного хранилища исходных текстов.

[[proposing-categories]]
=== Предложение новой категории

Поскольку со временем Коллекция Портов увеличилась, то в связи с этим были добавлены различные новые категории. Новые категории могут быть или _виртуальными_ категориями-которые не имеют соответствующего подкаталога в дереве портов-или _физическими_ категориями-у которых он есть. Следующий текст содержит обсуждение вопросов, возникающих при создании новой физической категории, чтобы вы могли понимать их, когда предложите новую категорию.

В соответствие с существующей практикой мы избегаем создания новой физической категории, пока достаточно большое число портов логически ей не принадлежит или же порты, которые могли бы ей принадлежать, не являются логически обособленной группой, представляющей для всех ограниченный интерес (в частности, категории, относящиеся к естественным языкам); предпочтительно выполнение обоих условий.

Основной причиной для этого является то, что такое изменение создает extref:{committers-guide}[изрядное количество работы, ports] и для коммиттеров, и для всех тех пользователей, которые отслеживают изменения в Коллекции Портов. В дополнение, предложенная категория создает естественное разногласие. (Пожалуй, потому что не существует четкого соглашения, является ли категория "слишком большой", или должны ли категории предоставлять себя для просмотра (и, таким образом, какое количество категорий было бы идеальным значением), и так далее.)

Процедура:

[.procedure]
====
. Предложите новую категорию на {freebsd-ports}. Вам следует включить для новой категории детальное обоснование, в том числе почему вы считаете, что существующие категории не являются достаточными, и список существующих портов, предложенных для перемещения. (Если есть новые порты, ожидающие в GNATS и попадающие в эту категорию, то укажите их тоже.) Если вы являетесь сопровождающим и/или отправителем, то укажите это соответственно, так как это может помочь вам в вашем деле.
. Принимайте участие в обсуждении.
. Если кажется, что для вашей идеи появилась поддержка, отправьте PR, который будет включать обоснование и список существующих портов, которые надо переместить. В идеале этот PR должен также включать патчи для следующего:

** [.filename]#Makefile#'ы для новых портов в результате репозиторного копирования
** [.filename]#Makefile# для категорий старых портов
** [.filename]#Makefile#'ы для портов, зависящих от старых портов
** (в дополнение, вы можете включить другие файлы, требующие изменений, согласно процедуре из Руководства Коммиттера.)

. Поскольку это затрагивает инфраструктуру портов и охватывает не только выполнение репозиторного копирования, но также, возможно, и выполнение регрессивных тестов на кластере построения, то PR должна назначать себе {portmgr}.
. Если этот PR одобрен, то коммиттеру нужно продолжить остальную часть процедуры, которая extref:{committers-guide}[изложена в Руководстве Коммиттера, ports].
====

Предложение новой виртуальной категории должно быть схожим с вышеизложенным, но при этом затрагивать намного меньше, поскольку ни один из портов не будет перемещен в действительности. В этом случае единственными патчами, включенными в PR, будут те, что добавляют новую категорию в `CATEGORIES` каждого из затрагиваемых портов.

[[proposing-reorg]]
=== Предложение реорганизации всех категорий

Время от времени кто-нибудь предлагает произвести реорганизацию категорий либо до двухуровневой, либо другого типа на основе ключевых слов. На данный момент из этих предложений ничего не получилось, потому что, хотя они просты в реализации, но предполагаемая переделка всей коллекции портов по меньшей мере приводит в уныние. Пожалуйста, прочтите историю этих предложений в архивах рассылок перед тем, как присылать свои соображения; более того, вы должны быть готовы представить работающий прототип.

[[makefile-distfiles]]
== Дистрибутивные файлы

Во второй части [.filename]#Makefile# задаётся, какие файлы и откуда должны быть сгружены для того, чтобы построить порт.

=== `DISTVERSION/DISTNAME`

В переменной `DISTNAME` указывается имя порта так, как назвали его создатели программного обеспечения. Значение `DISTNAME` по умолчанию совпадает с `${PORTNAME}-${PORTVERSION}`, так что переопределяете её значение только в случае необходимости. `DISTNAME` используется только в двух местах. Во-первых, список дистрибутивных файлов (`DISTFILES`) по умолчанию состоит из `${DISTNAME}${EXTRACT_SUFX}`. И во-вторых, предполагается, что дистрибутивный файл будет распакован в подкаталог с именем `WRKSRC`, значение которого по умолчанию есть не что иное, как [.filename]#work/${DISTNAME}#.

Названия некоторых дистрибутивов, которые не укладываются в `${PORTNAME}-${PORTVERSION}`-схему, могут быть автоматически обработаны посредством установки переменной `DISTVERSION`. `PORTVERSION` и `DISTNAME` будут унаследованы автоматически, но конечно же могут быть переопределены. Следующая таблица демонстрирует некоторые примеры:

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| DISTVERSION
| PORTVERSION

|0.7.1d
|0.7.1.d

|10Alpha3
|10.a3

|3Beta7-pre2
|3.b7.p2

|8:f_17
|8f.17
|===

[NOTE]
====
Значения переменных `PKGNAMEPREFIX` и `PKGNAMESUFFIX` не влияют на значение `DISTNAME`. Заметьте также, что если значение `WRKSRC` равно [.filename]#work/${PORTNAME}-${PORTVERSION}#, и в случае, когда оригинальный архив называется по имени, отличном от `${PORTNAME}-${PORTVERSION}${EXTRACT_SUFX}`, скорее всего, вы должны оставить `DISTNAME` как есть- лучше переопределить `DISTFILES`, чем задавать значения как `DISTNAME`, так и `WRKSRC` (и, возможно, ещё и `EXTRACT_SUFX`).
====

=== `MASTER_SITES`

Содержит часть с каталогом FTP/HTTP-URL, которая указывает на оригинальный архив на сервере `MASTER_SITES`. Не забудьте лидирующий слэш ([.filename]#/#)!

Макрос команды `make` будет пытаться воспользоваться этой переменной для получения дистрибутивного файла с помощью программы `FETCH`, если он не будет найден в системе.

Рекомендуется помещать в список много сайтов, предпочтительно с разных континентов. Это поможет при наличии проблем с мировой сетью. Мы даже планируем добавить поддержку автоматического определения ближайшего сайта и сгрузки файлов оттуда; наличие нескольких сайтов будет способствовать этому начинанию.

Если оригинальный архив находится на одном из таких популярных серверов, как SourceForge, GNU или Perl CPAN, то указывайте эти сайты в простой форме при помощи `MASTER_SITE_*` (к примеру, `MASTER_SITE_SOURCEFORGE`, `MASTER_SITE_GNU` или `MASTER_SITE_PERL_CPAN`. Просто укажите в переменной `MASTER_SITES` одно из этих значений, а в переменной `MASTER_SITE_SUBDIR` задайте путь к архиву. Вот пример:

[.programlisting]
....
MASTER_SITES=		${MASTER_SITE_GNU}
MASTER_SITE_SUBDIR=	make
....

Или можно использовать сокращенный формат:

[.programlisting]
....
MASTER_SITES=	GNU/make
....

Эти переменные определены в файле [.filename]#/usr/ports/Mk/bsd.sites.mk#. Всё время добавляются новые записи, так что обращайтесь к последней версии этого файла перед тем, как послать нам свой порт.

Для популярных сайтов существует несколько _магических_ макросов с заранее известной структурой каталогов. Используйте для них сокращения, и система попытается угадать для вас правильный подкаталог.

[.programlisting]
....
MASTER_SITES=	SF
....

Если попытка угадать не удалась, то это может быть переписано следующим образом.

[.programlisting]
....
MASTER_SITES=	SF/stardict/WyabdcRealPeopleTTS/${PORTVERSION}
....

Что также можно записать в таком виде:

[.programlisting]
....
MASTER_SITES=	SF
MASTER_SITE_SUBDIR=	stardict/WyabdcRealPeopleTTS/${PORTVERSION}
....

.Популярные магические макросы для `MASTER_SITES`
[cols="1,1", frame="none", options="header"]
|===
| Макрос
| Предполагаемый подкаталог

|`APACHE_JAKARTA`
|`/dist/jakarta/${PORTNAME:S,-,,/,}/source`

|`BERLIOS`
|`/${PORTNAME:L}`

|`CHEESESHOP`
|`/packages/source/source/${DISTNAME:C/(.).\*/\1/}/${DISTNAME:C/(.*)-[0-9].*/\1/}`

|`DEBIAN`
|`/debian/pool/main/${PORTNAME:C/^((lib)?.).*$/\1/}/${PORTNAME}`

|`GCC`
|`/pub/gcc/releases/${DISTNAME}`

|`GNOME`
|`/pub/GNOME/sources/${PORTNAME}/${PORTVERSION:C/^([0-9]+\.[0-9]+).*/\1/}`

|`GNU`
|`/gnu/${PORTNAME}`

|`MOZDEV`
|`/pub/mozdev/${PORTNAME:L}`

|`PERL_CPAN`
|`/pub/CPAN/modules/by-module/${PORTNAME:C/-.*//}`

|`PYTHON`
|`/ftp/python/${PYTHON_PORTVERSION:C/rc[0-9]//}`

|`RUBYFORGE`
|`/${PORTNAME:L}`

|`SAVANNAH`
|`/${PORTNAME:L}`

|`SF`
|`/project/${PORTNAME:L}/${PORTNAME:L}/${PORTVERSION}`
|===

=== `EXTRACT_SUFX`

Если у вас имеется один дистрибутивный файл, и в его имени используется странное окончание для указания типа сжатия, задайте переменную `EXTRACT_SUFX`.

К примеру, если дистрибутивный файл носит имя [.filename]#foo.tgz#, а не более привычное [.filename]#foo.tar.gz#, вы должны написать:

[.programlisting]
....
DISTNAME=	foo
EXTRACT_SUFX=	.tgz
....

Переменные `USE_BZIP2`, `USE_XZ` и `USE_ZIP` при необходимости автоматически устанавливают значение `EXTRACT_SUFX` в `.tar.bz2`, `.tar.xz` или `.zip`. Если ни одна из этих переменных не задана, то значение `EXTRACT_SUFX` по умолчанию устанавливается в `.tar.gz`.

[NOTE]
====
Вам не нужно задавать значения `EXTRACT_SUFX` и `DISTFILES` одновременно.
====

=== `DISTFILES`

Иногда имена сгружаемых файлов не соответствуют имени порта. К примеру, файл может называться [.filename]#source.tar.gz# или подобным образом. В других случаях исходный код приложения может располагаться в нескольких отличающихся архивах, и все они должны быть сгружены.

Если это ваш случай, то задайте в переменной `DISTFILES` список разделённых пробелами имён файлов, которые нужно сгрузить.

[.programlisting]
....
DISTFILES=	source1.tar.gz source2.tar.gz
....

Если переменная `DISTFILES` не задана явно, то её значением по умолчанию будет `${DISTNAME}${EXTRACT_SUFX}`.

=== `EXTRACT_ONLY`

Если только некоторые из `DISTFILES` должны быть распакованы-к примеру, часть из них является исходным кодом, а другие представляют собой неупакованную документацию-перечислите имена файлов, которые должны быть распакованы, в `EXTRACT_ONLY`.

[.programlisting]
....
DISTFILES=	source.tar.gz manual.html
EXTRACT_ONLY=	source.tar.gz
....

Если _ни один_ из `DISTFILES` не должен распаковываться, то установите пустое значение переменной `EXTRACT_ONLY`.

[.programlisting]
....
EXTRACT_ONLY=
....

[[porting-patchfiles]]
=== `PATCHFILES`

Если вашему порту требуются некоторых дополнительные патчи, которые доступны по FTP или HTTP, задайте имена этих файлов в переменной `PATCHFILES`, а в переменной `PATCH_SITES` укажите URL того каталога, в котором они содержатся (формат такой же, как для `MASTER_SITES`).

Если патч не относится к самому верху дерева исходных текстов (то есть `WRKSRC`), потому что он содержит некоторые дополнительные пути, установите соответственно значение переменной `PATCH_DIST_STRIP`. В частности, если все имена путей в патче имеют дополнительный путь `foozolix-1.0/` перед именем файла, то задайте `PATCH_DIST_STRIP=-p1`.

Не волнуйтесь, если патчи упакованы; они будут распакованы автоматически, если имена файлов оканчиваются на [.filename]#.gz# или [.filename]#.Z#.

Если патч распространяется вместе с какими-то другими файлами, такими, как документация, в виде tar-архива `gzip`, вы не можете просто использовать `PATCHFILES`. Если это ваш случай, добавьте имя и местоположение архива с патчем к `DISTFILES` и `MASTER_SITES`. Затем воспользуйтесь переменной `EXTRA_PATCHES` для указания этих файлов, и [.filename]#bsd.port.mk# автоматически применит эти патчи. В частности, _не копируйте_ файлы с патчами в каталог `PATCHDIR`-этот каталог может быть недоступным для записи.

[NOTE]
====
Архив будет распакован вне исходного кода, как обычно, и к тому же его не нужно явно распаковывать, если это обычный архив `gzip` или `compress`. Если вы сделаете последнее, приложите дополнительные усилия для того, чтобы не перезаписать что-либо, уже существующее в этом каталоге. Также не забудьте добавить команду для удаления скопированного патча в цели `pre-clean`.
====

[[porting-master-sites-n]]
=== Несколько дистрибутивных файлов или патчей с различных серверов и подкаталогов (`MASTER_SITES:n`)

(Этот раздел можно считать немного "повышенной трудности"; те, кто впервые знакомятся с этим текстом, могут пропустить этот раздел).

В этом разделе находится информация о механизме сгрузки, известном как `MASTER_SITES:n` и `MASTER_SITES_NN`. Далее мы будем называть этот механизм `MASTER_SITES:n`.

Сначала немного общей информации. В OpenBSD имеется полезная возможность, используемая в переменных `DISTFILES` и `PATCHFILES`, которая позволяет закреплять после имен файлов и патчей идентификаторы типа `:n`. Здесь `n` может быть из диапазона `[0-9]` и обозначать закреплённую группу. К примеру:

[.programlisting]
....
DISTFILES=	alpha:0 beta:1
....

В OpenBSD дистрибутивный файл [.filename]#alpha# будет связан с переменной `MASTER_SITES0`, но не с нашей общей переменной `MASTER_SITES`, а файл [.filename]#beta# с переменной `MASTER_SITES1`.

Этот очень интересная возможность, которая может уменьшить этот бесконечный поиск работающего сайта для сгрузки.

Просто представьте себе 2 файла в `DISTFILES` и 20 сайтов в `MASTER_SITES`; сайты очень медленные, причём [.filename]#beta# находится на всех сайтах из `MASTER_SITES`, а [.filename]#alpha# может быть найден только на 20-м сайте. Будет неправильно проверять их все, если создатель знает об этом, не правда ли? Неподходящее начало для таких прекрасных выходных!

Теперь, когда вы получили общее представление, просто представьте ещё большее количество `DISTFILES` и `MASTER_SITES`. Конечно, наш "магистр доступности дистрибутивов" представляет масштабы нагрузки на сеть, которую это даёт.

В последующих разделах информация будет даваться вместе с реализацией этой идеи во FreeBSD. Мы несколько улучшили концепцию OpenBSD.

==== Упрощённая информация

В этом разделе рассказывается, как быстро подготовить точную сгрузку нескольких дистрибутивных файлов и патчей с разных сайтов и каталогов. Мы описываем здесь случай упрощённого использования `MASTER_SITES:n`. Для большинства сценариев этого будет достаточно. Однако, если вам нужна дополнительная информация, обратитесь к следующему разделу.

Некоторые приложения состоят из многих дистрибутивных файлов, которые должны быть сгружены с нескольких различных сайтов. К примеру, Ghostscript состоит из основной программы и большого числа файлов драйверов, которые используются в зависимости от принтера пользователя. Некоторые из этих файлов драйверов поставляются с основной программой, но при этом многие другие должны быть сгружены с множества различных сайтов.

Чтобы это поддерживать, за каждой записью в `DISTFILES` может следовать символ двоеточия и "имя метки". За каждым сайтом, перечисленным в `MASTER_SITES`, тоже следует двоеточие и метка, которая указывает, какие файлы дистрибутива должны быть сгружены с этого сайта.

Например, рассмотрим приложение, исходный код которого разделён на две части, [.filename]#source1.tar.gz# и [.filename]#source2.tar.gz#, которые должны быть сгружены с двух различных источников. Файл [.filename]#Makefile# порта будет содержать строчки типа <<ports-master-sites-n-example-simple-use-one-file-per-site>>.

[[ports-master-sites-n-example-simple-use-one-file-per-site]]
.Упрощённое использование `MASTER_SITES:n` с 1 файлом на каждом сайте
[example]
====
[.programlisting]
....
MASTER_SITES=	ftp://ftp.example1.com/:source1 \
		ftp://ftp.example2.com/:source2
DISTFILES=	source1.tar.gz:source1 \
		source2.tar.gz:source2
....

====

Несколько дистрибутивных файлов могут иметь одну и ту же метку. Продолжая предыдущий пример, положим, что имеется и третий дистрибутивный файл, [.filename]#source3.tar.gz#, который должен быть сгружен с `ftp.example2.com`. Тогда файл [.filename]#Makefile# будет написан как <<ports-master-sites-n-example-simple-use-more-than-one-file-per-site>>.

[[ports-master-sites-n-example-simple-use-more-than-one-file-per-site]]
.Упрощённое использование `MASTER_SITES:n` с более чем 1 файлом на каждом сервере
[example]
====
[.programlisting]
....
MASTER_SITES=	ftp://ftp.example1.com/:source1 \
		ftp://ftp.example2.com/:source2
DISTFILES=	source1.tar.gz:source1 \
		source2.tar.gz:source2 \
		source3.tar.gz:source2
....

====

==== Подробная информация

Прекрасно, но пример из предыдущего раздела не показал вам всё, что вам нужно? В этом разделе мы подробно опишем, как работает механизм `MASTER_SITES:n` точной сгрузки и как вы можете изменить ваши порты, чтобы это использовать.

. За элементами могут следовать символы `:n`, где _n_ это `[^:,]+`, то есть _n_ может теоретически быть любой алфавитно-цифровой строкой, но пока мы будем ограничивать их `[a-zA-Z_][0-9a-zA-Z_]+`.
+ 
Более того, совпадение строк чувствительно к регистру; другими словами, `n` отличается от `N`.
+ 
Однако следующие слова не могут использоваться для этих нужд, так как они имеют особое значение: `default`, `all` и `ALL` (они используются для своих нужд в <<porting-master-sites-n-what-changes-in-port-targets,ii>>). Кроме того, `DEFAULT` является специальным ключевым словом (посмотрите <<porting-master-sites-n-DEFAULT-group,3>>).
. Элементы, за которыми следуют `:n`, принадлежат группе `n`, `:m` относится к группе `m` и так далее.
[[porting-master-sites-n-DEFAULT-group]]
. Элементы без таких суффиксов не относятся ни к какой группе, то есть они принадлежат к особой группе `DEFAULT`. Если вы укажете суффиксом любого элемента `DEFAULT`, вы просто выполните излишнюю работу, если только вы не хотите отнесения элемента как к группе `DEFAULT`, так и какой-то другой в одно и то же время (посмотрите на пункт <<porting-master-sites-n-comma-operator,5>>).
+ 
Следующие примеры равнозначны, но первый более предпочтителен:
+
[.programlisting]
....
MASTER_SITES=	alpha
....

+
[.programlisting]
....
MASTER_SITES=	alpha:DEFAULT
....

. Группы не являются эксклюзивными, элемент может принадлежать к нескольким отличающимся группам одновременно, а группа может либо иметь несколько различных элементов, либо не иметь их вовсе. Повторяющиеся элементы в одной и той же группе будут являться просто повторяющимися элементами.
[[porting-master-sites-n-comma-operator]]
. Если в хотите, чтобы элемент принадлежал к нескольким группам одновременно, вы можете использовать запятую (`,`).
+ 
Вместо того, чтобы повторять их несколько раз, каждый раз с разным постфиксом, мы можем перечислить несколько групп за раз в одном постфиксе. Например, `:m,n,o` определяет элемент, принадлежащий группам `m`, `n` и `o`.
+ 
Все следующие примеры имеют один смысл, но последний является предпочтительным:
+
[.programlisting]
....
MASTER_SITES=	alpha alpha:SOME_SITE
....

+
[.programlisting]
....
MASTER_SITES=	alpha:DEFAULT alpha:SOME_SITE
....

+
[.programlisting]
....
MASTER_SITES=	alpha:SOME_SITE,DEFAULT
....

+
[.programlisting]
....
MASTER_SITES=	alpha:DEFAULT,SOME_SITE
....

. Все серверы внутри определённой группы сортируются в соответствии с `MASTER_SORT_AWK`. Все группы в `MASTER_SITES` и `PATCH_SITES` тоже сортируются.
[[porting-master-sites-n-group-semantics]]
. Семантика групп может использоваться в любой из следующих переменных `MASTER_SITES`, `PATCH_SITES`, `MASTER_SITE_SUBDIR`, `PATCH_SITE_SUBDIR`, `DISTFILES` и `PATCHFILES` в соответствии со следующим синтаксисом:
.. Все элементы `MASTER_SITES`, `PATCH_SITES`, `MASTER_SITE_SUBDIR` и `PATCH_SITE_SUBDIR` должны заканчиваться символом прямого слэша `/`. Если какие-то элементы принадлежат каким-то группам, постфикс группы `:n` должен следовать сразу после завершающего символа `/`. Механизм `MASTER_SITES:n` опирается на наличие завершающего символа `/` во избежание совпадающих элементов, где `:n` является корректной частью элемента с вхождениями, где `:n` обозначает группу `n`. Для целей совместимости, так как завершающий символ `/` ранее не требовался в элементах `MASTER_SITE_SUBDIR` и `PATCH_SITE_SUBDIR`, если символ, сразу предшествующий постфиксу, не является символом `/`, то `:n` будет считаться корректной частью элемента, а не постфиксом группы, даже если за элементом следует `:n`. Посмотрите <<ports-master-sites-n-example-detailed-use-master-site-subdir>> и <<ports-master-sites-n-example-detailed-use-complete-example-master-sites>>.
+
[[ports-master-sites-n-example-detailed-use-master-site-subdir]]
.Подробное использование `MASTER_SITES:n` в `MASTER_SITE_SUBDIR`
[example]
====
[.programlisting]
....
MASTER_SITE_SUBDIR=	old:n new/:NEW
....

*** Каталоги внутри группы `DEFAULT` -> old:n
*** Каталоги внутри группы `NEW` -> new

====
+
[[ports-master-sites-n-example-detailed-use-complete-example-master-sites]]
.Подробное использование `MASTER_SITES:n` с запятыми, несколькими файлами, несколькими серверами и несколькими подкаталогами
[example]
====
[.programlisting]
....
MASTER_SITES=	http://site1/%SUBDIR%/ http://site2/:DEFAULT \
		http://site3/:group3 http://site4/:group4 \
		http://site5/:group5 http://site6/:group6 \
		http://site7/:DEFAULT,group6 \
		http://site8/%SUBDIR%/:group6,group7 \
		http://site9/:group8
DISTFILES=	file1 file2:DEFAULT file3:group3 \
		file4:group4,group5,group6 file5:grouping \
		file6:group7
MASTER_SITE_SUBDIR=	directory-trial:1 directory-n/:groupn \
			directory-one/:group6,DEFAULT \
			directory
....

Предыдущий пример приводит к следующей точной сгрузке. Серверы перечислены в точном порядке их использования.

*** [.filename]#file1# будет сгружаться с

**** `MASTER_SITE_OVERRIDE`
**** http://site1/directory-trial:1/
**** http://site1/directory-one/
**** http://site1/directory/
**** http://site2/
**** http://site7/
**** `MASTER_SITE_BACKUP`

*** [.filename]#file2# будет сгружаться точно также, как [.filename]#file1#, так как они оба относятся к одной и той же группе

**** `MASTER_SITE_OVERRIDE`
**** http://site1/directory-trial:1/
**** http://site1/directory-one/
**** http://site1/directory/
**** http://site2/
**** http://site7/
**** `MASTER_SITE_BACKUP`

*** [.filename]#file3# будет сгружен с

**** `MASTER_SITE_OVERRIDE`
**** http://site3/
**** `MASTER_SITE_BACKUP`

*** [.filename]#file4# будет сгружаться с

**** `MASTER_SITE_OVERRIDE`
**** http://site4/
**** http://site5/
**** http://site6/
**** http://site7/
**** http://site8/directory-one/
**** `MASTER_SITE_BACKUP`

*** [.filename]#file5# будет сгружен с

**** `MASTER_SITE_OVERRIDE`
**** `MASTER_SITE_BACKUP`

*** [.filename]#file6# будет сгружаться с

**** `MASTER_SITE_OVERRIDE`
**** http://site8/
**** `MASTER_SITE_BACKUP`

====

. Как мне группировать одну из специальных переменных из [.filename]#bsd.sites.mk#, например, `MASTER_SITE_SOURCEFORGE`?
+ 
Посмотрите <<ports-master-sites-n-example-detailed-use-master-site-sourceforge>>.
+
[[ports-master-sites-n-example-detailed-use-master-site-sourceforge]]
.Подробное использование `MASTER_SITES:n` с `MASTER_SITE_SOURCEFORGE`
[example]
====
[.programlisting]
....
MASTER_SITES=	http://site1/ ${MASTER_SITE_SOURCEFORGE:S/$/:sourceforge,TEST/}
DISTFILES=	something.tar.gz:sourceforge
....

====
+ 
[.filename]#something.tar.gz# будет сгружаться со всех сайтов из `MASTER_SITE_SOURCEFORGE`.
. Как мне использовать это с переменными `PATCH*`?
+ 
Все примеры выполнялись с переменными `MASTER*`, и они работают точно так же и для `PATCH*`, как это можно видеть в <<ports-master-sites-n-example-detailed-use-patch-sites>>.
+
[[ports-master-sites-n-example-detailed-use-patch-sites]]
.Упрощённое использование `MASTER_SITES:n` с `PATCH_SITES`.
[example]
====
[.programlisting]
....
PATCH_SITES=	http://site1/ http://site2/:test
PATCHFILES=	patch1:test
....

====

==== Что изменится для портов? А что не изменится?

[lowerroman]
. Все имеющиеся порты остаются без изменений. Код для механизма `MASTER_SITES:n` активируется, если только есть элементы, которые заканчиваются на `:n`, как и элементы в соответствии с вышеописанным синтаксисом, особенно как это показано в пункте <<porting-master-sites-n-group-semantics,7>>.
[[porting-master-sites-n-what-changes-in-port-targets]]
. Цели порт остаются теми же самыми: `checksum`, `makesum`, `patch`, `configure`, `build` и так далее. С обычными исключениями для `do-fetch`, `fetch-list`, `master-sites` и `patch-sites`.

** `do-fetch`: использует новую группировку с постфиксами в `DISTFILES` и `PATCHFILES` с соответствующими элементами групп в `MASTER_SITES` и `PATCH_SITES`, которые используют группы из `MASTER_SITE_SUBDIR` и `PATCH_SITE_SUBDIR`. Посмотрите <<ports-master-sites-n-example-detailed-use-complete-example-master-sites>>.
** `fetch-list`: работает так же, как старая цель `fetch-list` с тем исключением, что она группирует, как и `do-fetch`.
** `master-sites` и `patch-sites`: (несовместимы со старыми версиями) только возвращают элементы группы `DEFAULT`; на самом деле они выполняют цели `master-sites-default` и `patch-sites-default` соответственно.
+ 
Более того, использование целей `master-sites-all` или `patch-sites-all` предпочтительно для непосредственной проверки `MASTER_SITES` или `PATCH_SITES`. Также работа прямой проверки в последующих версиях не гарантируется. Посмотрите <<porting-master-sites-n-new-port-targets-master-sites-all, B>> для получения более дополнительной информации об этих новых целях.

. Новые цели построения портов
.. Имеются цели `master-sites-_n_` и `patch-sites-_n_`, которые будут перечислять элементы соответствующей группы _n_ из `MASTER_SITES` и `PATCH_SITES` соответственно. К примеру, `master-sites-DEFAULT` и `patch-sites-DEFAULT` обе будут возвращать элементы группы `DEFAULT`, `master-sites-test` и `patch-sites-test` группы `test` и так далее.
[[porting-master-sites-n-new-port-targets-master-sites-all]]
.. Имеются новые цели `master-sites-all` и `patch-sites-all`, которые выполняют работу старых `master-sites` и `patch-sites`. Они возвращают элементы всех групп, как если бы они все принадлежали одной и той же группе с тем, что она перечисляет ровно столько `MASTER_SITE_BACKUP` и `MASTER_SITE_OVERRIDE`, как и группы, определённые в `DISTFILES` или `PATCHFILES`; соответственно для `master-sites-all` и `patch-sites-all`.

=== `DIST_SUBDIR`

Не позволяйте вашему порту засорять [.filename]#/usr/ports/distfiles#. Если вашему порту требуется сгрузить много файлов, или он содержит имя файла, могущее вызвать конфликты с другими портами (например, [.filename]#Makefile#), то укажите в переменной `DIST_SUBDIR` имя порта (должны подойти `${PORTNAME}` или `${PKGNAMEPREFIX}${PORTNAME}`). Это изменит значение переменной `DISTDIR` со значения по умолчанию [.filename]#/usr/ports/distfiles# к значению [.filename]#/usr/ports/distfiles/DIST_SUBDIR#, и в результате всё, что требуется для порта, будет помещено в этот подкаталог.

Он заглянет также в подкаталог с тем же именем на основном резервном сервере [.filename]#ftp.FreeBSD.org#. (Явное задание переменной `DISTDIR` в вашем файле `Makefile` этого не сделает, так что, пожалуйста, воспользуйтесь `DIST_SUBDIR`.)

[NOTE]
====
Это не коснётся тех сайтов `MASTER_SITES`, которые вы указали в вашем файле [.filename]#Makefile#.
====

=== `ALWAYS_KEEP_DISTFILES`

Если ваш порт использует двоичные дистрибутивные файлы и обладает лицензией, требующей, чтобы исходный код предоставлялся вместе с пакетами, распространяемыми в двоичной форме, например GPL, то `ALWAYS_KEEP_DISTFILES` даст кластеру построения FreeBSD указание сохранять копию файлов, указанных в `DISTFILES`. Пользователям таких портов эти файлы в основном не нужны, поэтому хорошей идеей является добавление в `DISTFILES` исходных дистрибутивных файлов, только когда определена переменная `PACKAGE_BUILDING`.

[[ports-master-sites-n-example-always-keep-distfiles]]
.Использование `ALWAYS_KEEP_DISTFILES`.
[example]
====
[.programlisting]
....
.if defined(PACKAGE_BUILDING)
DISTFILES+=		foo.tar.gz
ALWAYS_KEEP_DISTFILES=	yes
.endif
....

====

При добавлении дополнительных файлов в `DISTFILES` убедитесь, что вы их также добавляете в [.filename]#distinfo#. Кроме того, дополнительные файлы обычно распаковываются также в `WRKDIR`, что для некоторых портов может вызывать нежелательные подобные эффекты и требовать особую обработку.

[[makefile-maintainer]]
== `MAINTAINER`

Укажите здесь ваш адрес электронной почты. Пожалуйста. _:-)_

Заметьте, что в качестве значения для `MAINTAINER` допустимо использование только одного адреса без поля комментария. Должен использоваться формат `user@hostname.domain`. Пожалуйста, не включайте никакого описательного текста, например, вашего настоящего имени в эту строку-это несколько сбивает с толку [.filename]#bsd.port.mk#.

Сопровождающий ответственен за поддержание порта в актуальном состоянии и обеспечение правильной работы порта. За подробным описанием обязанностей сопровождающего порт обращайтесь к главе extref:{contributing}[The challenge for port maintainers, maintain-port].

Перед фиксацией в репозитории изменения в порте будут отправлены сопровождающему для просмотра и одобрения. Если сопровождающий порта не ответил на запрос пользователя об обновлении в течение двух недель (исключая большие праздники), то это можно считать тайм-аутом сопровождающего, и обновление может быть выполнено без явного подтверждения от сопровождающего. Если сопровождающий не отвечает в течение трёх месяцев, то считается, что он отсутствует, и как сопровождающий порта, о котором идёт речь, может быть заменён. Исключениями из этого правила является всё, что сопровождает {portmgr} или {security-officer}. Запрещено делать любые несанкционированные изменения в портах, которые ведут эти группы.

Мы оставляем за собой право изменять сообщение сопровождающего для лучшего соответствия существующим политикам и стилю Коллекции Портов без явного одобрения со стороны отправителя. Также, крупные изменения в инфраструктуре могут повлечь изменения в порте без согласия сопровождающего. Такой вид изменений никогда не будет затрагивать функциональность порта.

За {portmgr} оставляется право снять или назначить кого-либо сопровождающим по любой причине, а за {security-officer} оставляется право лишать или назначать права на сопровождение порта по соображениям информационной безопасности.

[[makefile-comment]]
== `COMMENT`

Содержит однострочное описание порта. Пожалуйста, соблюдайте следующие правила:

. Старайтесь делать строку COMMENT длиной не больше, чем 70 символов, так как эта строка будет использована командой `pkg info` (см. man:pkg-info[8]) для отображения однострочного описания порта;
. _Не_ включайте сюда название пакета (или номер версии программного обеспечения);
. Комментарий должен начинаться с заглавной буквы и не заканчиваться точкой;
. Не начинайте комментарий с неопределённого артикля (A или An);
. Имена пишутся с заглавной буквы (например, Apache, JavaScript, Perl);
. Для перечислений используйте английскую Оксфордскую запятую (англ. Oxford comma) (например, green, red, and blue);
. Используйте программу проверки орфографии.

Вот пример:

[.programlisting]
....
COMMENT=	Cat chasing a mouse all over the screen
....

В файле [.filename]#Makefile# переменная COMMENT должна следовать сразу за переменной MAINTAINER.

[[makefile-portscout]]
== `PORTSCOUT`

Portscout являет собой автоматизированное средство проверки доступности дистрибутивных файлов для Коллекции Портов FreeBSD, подробное описание которого предоставляет crossref:keeping-up[distfile-survey, Portscout: сканер дистрибутивных файлов портов FreeBSD].

Переменная `PORTSCOUT` задаёт специальные условия, ограничивающие работу Portscout - сканера дистрибутивных файлов.

Ситуации, при которых следует указывать переменную `PORTSCOUT`:

* Когда должны игнорироваться дистрибутивные файлы для конкретных версий или младших ревизий. Например, чтобы исключить из проверок новых версий дистрибутивных файлов версию _8.2_ по причине того, что она является поломанной, добавьте следующее:
+
[.programlisting]
....
PORTSCOUT=	ignore:8.2
....

* Когда должны проверяться конкретные версии или старшие и младшие ревизии дистрибутивных файлов. Например, если следует ограничиться проверкой версии _0.6.4_, потому что более новые версии имеют проблемы совместимости с FreeBSD, добавьте:
+
[.programlisting]
....
PORTSCOUT=	limit:^0\.6\.4
....

* Когда URL, в которых указаны доступные версии, отличаются от URL их загрузки. Например, чтобы привязать проверку новых версий дистрибутивных файлов к странице загрузки для порта package:databases/pgtune[], добавьте:
+
[.programlisting]
....
PORTSCOUT=	site:http://pgfoundry.org/frs/?group_id=1000416
....

[[makefile-depend]]
== Зависимости

Многие порты зависят от других портов. Это очень удобная замечательная особенность большинства Unix-подобных операционных систем, включая FreeBSD. Множество портов могут использовать общую зависимость совместно, а не включать её в состав каждого порта или пакета, который в ней нуждается. Имеется семь переменных, которые вы можете использовать для обеспечения того, что всё требуемое находится на машине пользователя. Имеется также несколько предопределённых переменных, отражающих зависимости для общих случаев, плюс ещё несколько для управления поведением зависимостей.

=== `LIB_DEPENDS`

Эта переменная указывает, от каких совместно используемых библиотек зависит порт. Это список пар lib:dir, где _lib_ - это имя библиотеки, _dir_ - это каталог, в котором можно ее найти в случае, если ее нет на машине. Например,

[.programlisting]
....
LIB_DEPENDS=	libjpeg.so:${PORTSDIR}/graphics/jpeg
....

проверит наличие библиотеки jpeg с любым номером версии и перейдет в подкаталог [.filename]#graphics/jpeg# вашего дерева портов для ее построения и установки, если библиотека отсутствует.

Зависимость проверяется дважды, один раз внутри цели `build`, а затем из цели `install`. Кроме того, имя зависимости помещается в пакет, так что `pkg install` (см. man:pkg-install[8]) будет автоматически её устанавливать, если её нет на пользовательской системе.

=== `RUN_DEPENDS`

В этой переменной перечисляются выполнимые файлы или файлы, от которых зависит работа порта. Это список пар вида path:dir:target, где _path_ - это имя программы или файла, а _dir_ - каталог, в котором можно найти порт в случае, если его нет в системе, и _target_ - это цель, которую нужно вызвать в этом каталоге. Если _path_ начинается со слэша (`/`), он воспринимается как файл и его существование проверяется командой `test -e`; в противном случае предполагается, что это выполнимый файл, и для определения того, имеется ли программа в пути поиска, используется команда `which -s`.

Например,

[.programlisting]
....
RUN_DEPENDS=	${LOCALBASE}/news/bin/innd:${PORTSDIR}/news/inn \
		xmlcatmgr:${PORTSDIR}/textproc/xmlcatmgr
....

проверит существование файла или каталога [.filename]#/usr/local/news/bin/innd#, и если ничего не будет найдено, то построит и установит порт из подкаталога [.filename]#news/inn# дерева портов. Также будет выполнена проверка, присутствует ли в пути поиска исполняемый файл с именем `xmlcatmgr`, и перейдет в подкаталог [.filename]#textproc/xmlcatmgr# вашего дерева портов для его построения и установки, если он не будет найден.

[NOTE]
====
В приведенном примере `innd` является выполнимым файлом; если выполнимый файл находится в месте, которое отсутствует в списке путей файлов, то вы должны указать полный путь к файлу.
====

[NOTE]
====
Официальным значением переменной поиска `PATH`, используемым в кластере построения портов является

[.programlisting]
....
/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin
....

====

Зависимость проверяется внутри цели `install`. Кроме того, имя зависимости помещается в пакет, так что `pkg install` (см. man:pkg-install[8]) будет автоматически его устанавливать, если он не будет найден в пользовательской системе. Часть _target_ может быть опущена, если она совпадает с `DEPENDS_TARGET`.

Довольно распространенной является ситуация, когда `RUN_DEPENDS` буквально такая же как `BUILD_DEPENDS`, особенно если переносимое программное обеспечение написано на языке сценариев, или если оно требует такое же окружение для исполнения, как и используемое во время построения. В этом случае, очень заманчивым или довольно естественным является присвоение одного другому:

[.programlisting]
....
RUN_DEPENDS=	${BUILD_DEPENDS}
....

Тем не менее, подобные присвоения могут загрязнять зависимости времени исполнения содержимым, не заданным в `BUILD_DEPENDS` исходного порта. Такое случается из-за ленивого вычисления в man:make[1] присваиваемых переменных. Представьте [.filename]#Makefile# с переменными `USE_*`, которые обрабатываются в [.filename]#ports/Mk/bsd.*.mk# для пополнения первоначальных зависимостей построения. Например, `USES= gmake` добавляет package:devel/gmake[] в `BUILD_DEPENDS`. Для предотвращения загрязнения `RUN_DEPENDS` подобными дополнительными зависимостями проявляйте осторожность с присвоением с раскрытием, т.е. с раскрытием значения перед его присвоением переменной:

[.programlisting]
....
RUN_DEPENDS:=	${BUILD_DEPENDS}
....

=== `BUILD_DEPENDS`

В этой переменной перечисляются выполнимые или обычные файлы, которые требуются порту для его построения. Как и `RUN_DEPENDS`, это список пар path:dir:target. Например,

[.programlisting]
....
BUILD_DEPENDS=	unzip:${PORTSDIR}/archivers/unzip
....

будет проверять наличие выполнимого фала с именем `unzip` и перейдет в подкаталог [.filename]#archivers/unzip# вашего дерева портов для его построения и установки, если последний не будет найден.

[NOTE]
====
Под "построением" здесь понимается всё, от распаковки до компиляции. Зависимость проверяется из цели `extract`. Часть _target_ может быть опущена, если она совпадает с `DEPENDS_TARGET`.
====

=== `FETCH_DEPENDS`

В этой переменной перечисляются выполняемые файлы или просто файлы, которые требуются порту для сгрузки. Как и предыдущие две переменные, это список пар path:dir:target. Например,

[.programlisting]
....
FETCH_DEPENDS=	ncftp2:${PORTSDIR}/net/ncftp2
....

будет проверять наличие выполняемого файла с именем `ncftp2` и перейдет в каталог [.filename]#net/ncftp2# вашего дерева портов для его построения и установки, если тот не будет найден.

Зависимость проверяется при выполнении цели `fetch`. Часть _target_ может быть опущена, если она совпадает с `DEPENDS_TARGET`.

=== `EXTRACT_DEPENDS`

В этой переменной указываются программы или файлы, которые требуются для распаковки порта. Как и в предыдущих случаях, это список пар вида path:dir:target. Например,

[.programlisting]
....
EXTRACT_DEPENDS=	unzip:${PORTSDIR}/archivers/unzip
....

будет проверять наличие программы с именем `unzip`, и перейдёт в подкаталог [.filename]#archivers/unzip# вашего дерева портов для её построения и установки, если такой программы не будет найдено.

Зависимость проверяется внутри цели `extract`. Часть _target_ может быть опущена, если она совпадает с `DEPENDS_TARGET`.

[NOTE]
====
Используйте эту переменную, только если распаковка не работает (по умолчанию предполагается использование `gzip`) и это не исправляется при помощи `USE_ZIP` или `USE_BZIP2`, которые описаны в <<use-vars>>.
====

=== `PATCH_DEPENDS`

Эта переменная указывает на программы или файлы, которые нужны порту для применения патчей. Как и в предыдущих случаях, это список пар вида path:dir:target. Например,

[.programlisting]
....
PATCH_DEPENDS=	${NONEXISTENT}:${PORTSDIR}/java/jfc:extract
....

будет переходить в подкаталог [.filename]#java/jfc# вашего дерева портов для распаковки.

Зависимость проверяется внутри цели `patch`. Часть _target_ может быть опущена, если она совпадает с `DEPENDS_TARGET`.

[[uses-makefiles]]
=== `USES`

Могут быть добавлены параметры для определения различных характерных особенностей и зависимостей, которыми обладает данный порт. Они указываются путём добавления в [.filename]#Makefile# этой строки:

[.programlisting]
....
USES= feature[:arguments]
....

Для получения полного списка значений смотрите <<uses-makefiles>>.

[WARNING]
====

Значение `USES` нельзя присваивать после подключения [.filename]#bsd.port.pre.mk#.
====

[[use-vars]]
=== `USE_*`

Для определения общих зависимостей, совместно используемых многими портами, предназначено несколько переменных. Их использование является необязательным, но помогает упростить избыточность файлов [.filename]#Makefile# порта. Каждый из них оформляется как `USE_*`. Эти переменные можно использовать только в [.filename]#Makefile# порта и [.filename]#ports/Mk/bsd.*.mk#. Они не предназначены для установки пользователями параметров - используйте для этих целей `PORT_OPTIONS`.

[NOTE]
====
Установка любых `USE_*` в [.filename]#/etc/make.conf# _всегда_ является ошибочным действием. В частности, установка

[.programlisting]
....
USE_GCC=X.Y
....

(где X.Y соответствует версии) добавит зависимость от gccXY к каждому порту, включая и сам `lang/gccXY`!
====

.Переменные `USE_*`
[cols="1,1", frame="none", options="header"]
|===
| Переменная
| Значение

|`USE_BZIP2`
|tar-архивы порта упакованы при помощи `bzip2`.

|`USE_ZIP`
|tar-архивы порта упакованы при помощи `zip`.

|`USE_GCC`
|Для сборки порта требуется GCC (gcc или {gcc-plus-plus}). Некоторым портам подходит любая версия, для других требуются последние современные версии. Обычно используется со значением `any` (в этом случае используется встроенный GCC в тех версиях FreeBSD, в состав которых он всё ещё входит, или устанавливается порт `lang/gcc`, когда Clang является компилятором C/C++ по умолчанию) или `yes` (всегда используется стабильная современная версия GCC из порта `lang/gcc`). Также в значении переменной можно указать точную версию, например `4.7`. Минимально допустимую версию можно указать как `4.6+`. GCC из основной системы используется в случае, если его версия удовлетворяет запрошенной, иначе собирается подходящая версии компилятора из порта с соответствующей коррекцией переменных `CC` и `CXX`.
|===

Переменные, относящиеся к gmake и сценарию [.filename]#configure#, описаны в crossref:special[building, Механизмы построения], а autoconf, automake и libtool описаны в crossref:special[using-autotools, Использование GNU Autotools]. Переменные, связанные с Perl, описаны в crossref:special[using-perl, Использование Perl]. Переменные X11 перечислены в crossref:special[using-x11, Использование X11]. crossref:special[using-gnome, Использование GNOME] работает с переменными GNOME и crossref:special[using-kde, Использование KDE] с KDE. crossref:special[using-java, Использование Java] описывает переменные Java, а crossref:special[using-php, Веб-приложения, Apache и PHP] содержит информацию об Apache, PHP и модулях PEAR. Python обсуждается в crossref:special[using-python, Использование Python], а Ruby в crossref:special[using-ruby, Использование Ruby]. crossref:special[using-sdl, Использование SDL] предоставляет переменные, используемые для приложений SDL, и, наконец, crossref:special[using-xfce, Использование Xfce] содержит информацию о приложении Xfce.

=== Минимальная версия зависимости

Минимальная версия зависимости может быть указана в любой переменной `*_DEPENDS`, за исключением `LIB_DEPENDS`, с использованием следующего синтаксиса:

[.programlisting]
....
p5-Spiffy>=0.26:${PORTSDIR}/devel/p5-Spiffy
....

Первое поле содержит название зависимого пакета, которое обязано совпадать с записью в базе данные пакетов, знак сравнения и версию пакета. Зависимость удовлетворяется, если на машине установлен p5-Spiffy-0.26 или новее.

=== Замечания касательно зависимостей

Как уже отмечено выше, целью, которая вызывается по умолчанию в случае, когда это требует зависимость, является `DEPENDS_TARGET`. Она по умолчанию есть `install`. Это пользовательская переменная; она нигде не определена в файле [.filename]#Makefile# порта. Если вашему порту требуется особый метод обработки зависимости, воспользуйтесь частью `:target` переменной `*_DEPENDS` вместо того, чтобы переопределять `DEPENDS_TARGET`.

Когда вы набираете команду `make clean`, эта операция также выполняется и над зависимостями этого порта. Если вы не хотите, чтобы это случилось, определите переменную `NOCLEANDEPENDS` в вашем окружении. Это может быть особенно нужным, если порт имеет нечто, что занимает много времени на построение, в своём списке зависимостей, например, KDE, GNOME или Mozilla.

Чтобы безусловно зависеть от другого порта, укажите переменную `${NONEXISTENT}` в качестве первого поля переменной `BUILD_DEPENDS` или `RUN_DEPENDS`. Пользуйтесь этим, только когда вам нужно иметь исходный код другого порта. Вы можете сэкономить время на компиляции, указав также и цель. Например,

[.programlisting]
....
BUILD_DEPENDS=	${NONEXISTENT}:${PORTSDIR}/graphics/jpeg:extract
....

всегда будет переходить в каталог с портом `jpeg` и распаковывать его.

=== Зацикленные зависимости фатальны

[IMPORTANT]
====
Не помещайте зацикливающиеся зависимости в дерево портов!
====

Технология построения портов не защищена от зацикленных зависимостей. Если вы создадите такую, то у кого-нибудь и где-нибудь установка FreeBSD будет немедленно сломана, а у остальных сломается несколько позже. Это на самом деле очень трудно распознать; если вы сомневаетесь, то перед внесением изменений проверьте, что выполнили следующее: `cd /usr/ports; make index`. Этот процесс может быть достаточно медленным на старых машинах, хотя вы сможете спасти большое количество людей-включая себя-от грядущих бед.

=== Автоматические зависимости и проблемы, которые они вызывают

Зависимости должны быть указаны либо явно, либо с использованием <<makefile-options,фреймворка OPTIONS>>. Использование прочих методов, таких как автоматическое обнаружение зависимостей, усложняет индексирование, что вызывает проблемы в управлении портами и пакетами.

.Некорректное объявление необязательной зависимости
[example]
====
[.programlisting]
....
.include <bsd.port.pre.mk>

.if exists(${LOCALBASE}/bin/foo)
LIB_DEPENDS=	libbar.so:${PORTSDIR}/foo/bar
.endif
....

====

Проблема автоматического добавления зависимостей заключается в том, что файлы и настройки за пределами порта могут произвольно меняться. Пример: после построения индекса устанавливается набор портов. При этом один из них устанавливает проверяемый файл. На этом этапе индекс будет неправильным, потому что установленный порт неожиданно получит новую зависимость. Индекс может быть по прежнему неправильным даже после его перестроения, в случае если другие порты также определят дополнительные зависимости, основываясь на существовании других файлов.

.Корректное объявление необязательной зависимости
[example]
====
[.programlisting]
....
OPTIONS_DEFINE=	BAR
BAR_DESC=	Bar support

.include <bsd.port.options.mk>

.if ${PORT_OPTIONS:MBAR}
LIB_DEPENDS=	libbar.so:${PORTSDIR}/foo/bar
.endif
....

====

Правильным способом является проверка переменных параметров. Этот способ не приводит к несоответствиям в индексе набора портов, поскольку параметры определены до построения индекса. При этом можно использовать простые скрипты для автоматизации построения, установки и обновления этих портов и соответствующих им пакетов.

[[use-want]]
=== `USE_` и `WANT_`

Переменные `USE_` задаются мейнтейнером порта для определения программного обеспечения, от которого этот порт зависит. Порт, для которого нужен Firefox, укажет

[.programlisting]
....
USE_FIREFOX=	yes
....

Некоторые переменные `USE_` могут принимать номера версий или другие параметры. Например, порт, который требует Apache 2.2, укажет

[.programlisting]
....
USE_APACHE=	22
....

В некоторых случаях для большего контроля над зависимостями используются переменные `WANT_`, которые позволяют указывать требования в более точной форме. Например, взгляните на порт package:mail/squirrelmail[]. Этому порту нужны несколько модулей PHP, которые перечислены в переменной `USE_PHP`:

[.programlisting]
....
USE_PHP=	session mhash gettext mbstring pcre openssl xml
....

Эти модули доступны в версиях CLI и web, поэтому версия web выбрана с переменной `WANT_`:

[.programlisting]
....
WANT_PHP_WEB=	yes
....

Имеющиеся переменные `USE_` и `WANT_` определены в файлах в [.filename]#/usr/ports/Mk#.

[[makefile-masterdir]]
== `MASTERDIR`

Если вашему порту требуется построение довольно различающихся версий пакетов через переменную (задающую, например, разрешение, или размер бумаги), которая принимает различные значения, создайте для каждого пакета отдельный подкаталог, чтобы пользователям было легче определить, каким пакетом воспользоваться, но попробуйте использовать совместно между портами как можно больше файлов. В типичном случае вам потребуются только очень короткие файлы [.filename]#Makefile# во всех каталогах, кроме одного, если вы будете использовать переменные с умом. В отдельных файлах [.filename]#Makefile# вы можете использовать переменную `MASTERDIR` для указания каталога, в котором находятся все остальные файлы. Также используйте переменную как часть <<porting-pkgname,`PKGNAMESUFFIX`>>, чтобы пакеты имели разные имена.

Продемонстрируем это на примере. Вот часть файла [.filename]#japanese/xdvi300/Makefile#:

[.programlisting]
....
PORTNAME=	xdvi
PORTVERSION=	17
PKGNAMEPREFIX=	ja-
PKGNAMESUFFIX=	${RESOLUTION}
 :
# default
RESOLUTION?=	300
.if ${RESOLUTION} != 118 && ${RESOLUTION} != 240 && \
	${RESOLUTION} != 300 && ${RESOLUTION} != 400
	@${ECHO_MSG} "Error: invalid value for RESOLUTION: \"${RESOLUTION}\""
	@${ECHO_MSG} "Possible values are: 118, 240, 300 (default) and 400."
	@${FALSE}
.endif
....

Порт package:japanese/xdvi300[] содержит также все обычные патчи, файлы для пакета и так далее. Если вы введете здесь команду `make`, она возьмет в качестве разрешения значение по умолчанию (300) и построит порт обычным образом.

Для другого разрешения приведем _полный_[.filename]#xdvi118/Makefile#:

[.programlisting]
....
RESOLUTION=	118
MASTERDIR=	${.CURDIR}/../xdvi300

.include "${MASTERDIR}/Makefile"
....

([.filename]#xdvi240/Makefile# и [.filename]#xdvi400/Makefile# похожи). Задание `MASTERDIR` говорит [.filename]#bsd.port.mk#, что обычный набор подкаталогов типа `FILESDIR` и `SCRIPTDIR` находится в каталоге [.filename]#xdvi300#. Строчка `RESOLUTION=118` переопределят строку `RESOLUTION=300` в файле [.filename]#xdvi300/Makefile# и порт будет построен с разрешением 118.

[[makefile-manpages]]
== Страницы Справочника

Если ваш порт определяет корнем для файлов Справочника каталог, отличный от `PREFIX`, вы можете использовать переменную `MANDIRS`, чтобы указать эти каталоги. Обратите внимание, что файлы страниц справочника следует размещать в [.filename]#pkg-plist# наряду с остальными файлами. `MANDIRS` предназначена для автоматического сжатия страниц справочника, так чтобы имена файлов оканчивались на [.filename]#.gz#.

[[makefile-info]]
== Файлы в формате info

Если в вашем пакете нужна установка файлов GNU info, они должны быть перечислены в переменной `INFO` (без окончания `.info`), по записи на документ. Предполагается, что эти файлы устанавливаются в [.filename]#PREFIX/INFO_PATH#. Вы можете изменить `INFO_PATH`, если ваш пакет использует другое место для размещения. Однако, это не рекомендуется делать. Эти записи всего лишь содержат путь относительно [.filename]#PREFIX/INFO_PATH#. Например, package:lang/gcc34[] устанавливает файлы info в [.filename]#PREFIX/INFO_PATH/gcc34#, и в `INFO` будет что-то вроде этого:

[.programlisting]
....
INFO=	gcc34/cpp gcc34/cppinternals gcc34/g77 ...
....

Перед регистрацией пакета соответствующий код установки/удаления будет автоматически добавлен во временный [.filename]#pkg-plist#.

[[makefile-options]]
== Опции для Makefile

Многие приложения могут быть построены в различных конфигурациях и с дополнительной функциональностью. Например, выбор естественного (человеческого) языка, GUI против командной строки или типа используемой базы данных. Пользователи могут нуждаться в различных конфигурациях, отличных от используемой по умолчанию, поэтому в системе портов предусмотрен механизм, позволяющий автору порта управлять сборкой того или иного варианта конфигурации. Правильная поддержка этих необязательных параметров облегчает пользователям жизнь и даёт два или более порта по цене одного.

=== Knobs

==== `WITH__*_` и `WITHOUT__*_`

Эти переменные предназначены для установки системным администратором. Многие из них стандартизованы в файле http://svnweb.FreeBSD.org/ports/head/KNOBS?view=markup[ports/KNOBS].

При создании порта не давайте имя для knob, специфичное для данного приложения. На примере порта Avahi, используйте `WITHOUT_MDNS` вместо `WITHOUT_AVAHI_MDNS`.

[NOTE]
====
Не стоит рассчитывать, что `WITH__*_` обязательно имеет соответствующую переменную `WITHOUT__*_`, и наоборот. В общем случае, предполагается значение по умолчанию.
====

[NOTE]
====
Если обратное не указано, то проверяется только факт установки самих переменных, но не их конкретное значение типа `YES` или `NO`.
====

.Основные переменные `WITH__*_` и `WITHOUT__*_`
[cols="1,1", frame="none", options="header"]
|===
| Переменная
| Значение

|`WITH_OPENSSL_BASE`
|Использовать версию OpenSSL из базовой системы.

|`WITH_OPENSSL_PORT`
|Устанавливает версию OpenSSL из package:security/openssl[], даже если в базовой системе последняя версия.
|===

==== Наименование KNOBS

Портеры должны использовать так называемые knobs для помощи конечным пользователям и для поддержания количества наименований knobs в небольшом количестве. Список популярных названий knobs можно найти в файле http://svnweb.FreeBSD.org/ports/head/KNOBS?view=markup[KNOBS]

Названия knobs должны отражать, что это такое и что выполняет. Если у порта имеется библиотечный префикс в `PORTNAME`, то он должен присутствовать в названии knobs.

=== `OPTIONS`

==== Описание

При установке порта переменные `OPTIONS_*` предоставляют пользователю окно диалога с отображением доступных параметров, с записью выбранных параметров в файл [.filename]#/var/db/ports/${UNIQUENAME}/options#. Эти опции повторно используются при следующем построении порта.

Когда пользователь запускает `make config` (или запускает впервые `make build`), инфраструктура выполняет проверку существования файла [.filename]#/var/db/ports/${UNIQUENAME}/options#. Если этот файл не существует, то используются значения `OPTIONS_*` и отображается диалоговое окно, в котором эти параметры можно включить или выключить. Затем сохраняется файл опций [.filename]#options#, и выбранные переменные используются при построении порта.

Если новая версия порта добавляет новые значения `OPTIONS`, то пользователю будет представлено окно диалога с сохраненными заполненными значениями старых `OPTIONS.`

`make showconfig` отображает сохраненную конфигурацию. Для удаления сохраненной конфигурации используйте `make rmconfig`.

==== Синтаксис

`OPTIONS_DEFINE` содержит список используемых `OPTIONS`. Они независимы друг от друга и не сгруппированы:

[.programlisting]
....
OPTIONS_DEFINE=	OPT1 OPT2
....

Далее после определения следует описание `OPTIONS` (не является обязательным, но настоятельно рекомендуется):

[.programlisting]
....
OPT1_DESC=	Describe OPT1
OPT2_DESC=	Describe OPT2
OPT3_DESC=	Describe OPT3
OPT4_DESC=	Describe OPT4
OPT5_DESC=	Describe OPT5
OPT6_DESC=	Describe OPT6
....

[TIP]
====

[.filename]#ports/Mk/bsd.options.desc.mk# содержит описание множества наиболее используемых `OPTIONS`; переопределять их, как правило, не нужно.
====

[TIP]
====

При описании параметров старайтесь представить себя на месте пользователя: "Что это делает?" и "Для чего бы я захотел включить это?" Не делайте простое повторение названия. Например, описание параметра `NLS` как "include NLS support" ("включить поддержку NLS") не поможет пользователю, который уже видит название параметра, но может не знать, что это означает. Описав его как "Native Language Support via gettext utilities" ("Поддержка национального языка через утилиты gettext"), вы поможете пользователю гораздо больше.
====

`OPTIONS` можно группировать в виде переключателей, для которых разрешен выбор единственного варианта в каждой группе:

[.programlisting]
....
OPTIONS_SINGLE=		SG1
OPTIONS_SINGLE_SG1=	OPT3 OPT4
....

`OPTIONS` можно группировать в виде переключателей, для которых разрешен выбор единственного варианта (или ни одного) в каждой группе:

[.programlisting]
....
OPTIONS_RADIO=		RG1
OPTIONS_RADIO_RG1=	OPT7 OPT8
....

`OPTIONS` также можно группировать в виде списков со множественным выбором, для которых обязан быть включен _по крайней мере один_ из параметров:

[.programlisting]
....
OPTIONS_MULTI=		MG1
OPTIONS_MULTI_MG1=	OPT5 OPT6
....

`OPTIONS` также можно группировать в виде списков со множественным выбором, для которых могут быть включены любые параметры, включая отсутствие выбора:

[.programlisting]
....
OPTIONS_GROUP=		GG1
OPTIONS_GROUP_GG1=	OPT9 OPT10
....

По умолчанию `OPTIONS` находится в выключенном положении, если при этом оно также отсутствует в списке `OPTIONS_DEFAULT`:

[.programlisting]
....
OPTIONS_DEFAULT=	OPT1 OPT3 OPT6
....

Определения `OPTIONS` обязаны быть до подключения [.filename]#bsd.port.options.mk#. Переменные `PORT_OPTIONS` могут быть проверены только после подключения [.filename]#bsd.port.options.mk#. Вместо этого также можно использовать подключение [.filename]#bsd.port.pre.mk#, что все еще широко используется в портах, написанных до появления [.filename]#bsd.port.options.mk#. Но имейте в виду, что некоторые переменные, обычно, это некоторые флаги `USE_*`, после подключения [.filename]#bsd.port.pre.mk# будут работать не так, как этого от них ожидают.

[[ports-options-simple-use]]
.Простое использование `OPTIONS`
[example]
====
[.programlisting]
....
OPTIONS_DEFINE=	FOO BAR
FOO_DESC=	Enable option foo
BAR_DESC=	Support feature bar

.include <bsd.port.options.mk>

.if ${PORT_OPTIONS:MFOO}
CONFIGURE_ARGS+=--with-foo
.else
CONFIGURE_ARGS+=--without-foo
.endif

.if ${PORT_OPTIONS:MBAR}
RUN_DEPENDS+=	bar:${PORTSDIR}/bar/bar
.endif

.include <bsd.port.mk>
....

====

[[ports-options-check-unset]]
.Проверка незаданных значений `OPTIONS`
[example]
====
[.programlisting]
....
.if ! ${PORT_OPTIONS:MEXAMPLES}
CONFIGURE_ARGS+=--without-examples
.endif
....

====

[[ports-options-practical-use]]
.Пример реального использования `OPTIONS`
[example]
====
[.programlisting]
....
OPTIONS_DEFINE=		EXAMPLES

OPTIONS_SINGLE=		BACKEND
OPTIONS_SINGLE_BACKEND=	MYSQL PGSQL BDB

OPTIONS_MULTI=		AUTH
OPTIONS_MULTI_AUTH=	LDAP PAM SSL

EXAMPLES_DESC=		Install extra examples
MYSQL_DESC=		Use MySQL as backend
PGSQL_DESC=		Use PostgreSQL as backend
BDB_DESC=		Use Berkeley DB as backend
LDAP_DESC=		Build with LDAP authentication support
PAM_DESC=		Build with PAM support
SSL_DESC=		Build with OpenSSL support

OPTIONS_DEFAULT=	PGSQL LDAP SSL

.include <bsd.port.options.mk>

.if ${PORT_OPTIONS:MPGSQL}
USE_PGSQL=		yes
CONFIGURE_ARGS+=	--with-postgres
.else
CONFIGURE_ARGS+=	--without-postgres
.endif

.if ${PORT_OPTIONS:MICU}
LIB_DEPENDS+=	libicuuc.so:${PORTSDIR}/devel/icu
.endif

.if ! ${PORT_OPTIONS:MEXAMPLES}
CONFIGURE_ARGS+=	--without-examples
.endif

# Проверка других параметров OPTIONS

.include <bsd.port.mk>
....

====

==== Параметры по умолчанию

Следующие параметры по умолчанию всегда включены.

* `DOCS` - построение и установка документации.
* `NLS` - интернационализация.
* `EXAMPLES` - построение и установка примеров использования.
* `IPV6` - поддержка протокола IPv6.

[NOTE]
====
Нет необходимости добавлять эти параметры в `OPTIONS_DEFAULT`. Тем не менее, чтобы отобразить их в окне диалога выбора параметров, они должны быть добавлены в `OPTIONS_DEFINE`.
====

=== Функция автоматической активации

При использовании сценария GNU configure, следите за тем, какие необязательные функции задействуются посредством автоматической активации. Отключайте явным образом те необязательные функции, которые вы не хотели бы использовать, через передачу соответствующих `--without-xxx` или `--disable-xxx` в переменной `CONFIGURE_ARGS`.

.Неправильное управление опцией
[example]
====
[.programlisting]
....
.if ${PORT_OPTIONS:MFOO}
LIB_DEPENDS+=		libfoo.so:${PORTSDIR}/devel/foo
CONFIGURE_ARGS+=	--enable-foo
.endif
....

====

В приведенном выше примере представьте себе библиотеку libfoo, установленную в системе. Пользователь не желает, чтобы приложение использовало libfoo, и поэтому он выключает соответствующую опцию в диалоге `make config`. Но сценарий configure приложения определяет наличие библиотеки в системе и включает ее поддержку в итоговый исполняемый файл. Теперь, когда пользователь решит удалить libfoo из системы, система портов позволит это сделать (т.к. зависимость от libfoo не была записана), но приложение перестанет работать.

.Правильное управление опцией
[example]
====
[.programlisting]
....
.if ${PORT_OPTIONS:MFOO}
LIB_DEPENDS+=		libfoo.so:${PORTSDIR}/devel/foo
CONFIGURE_ARGS+=	--enable-foo
.else
CONFIGURE_ARGS+=	--disable-foo
.endif
....

====

Во втором примере библиотека libfoo отключена явным образом. Сценарий configure не включает соответствующие функции в приложении, несмотря на присутствие библиотеки в системе.

[NOTE]
====
При определенных условиях сокращенный синтаксис записи условий может вызывать проблемы со сложными конструкциями. Если вы получаете ошибки, такие как `Malformed conditional`, то может быть использован альтернативный синтаксис.

[.programlisting]
....
.if !empty(VARIABLE:MVALUE)
# as an alternative to
.if ${VARIABLE:MVALUE}
....

====

=== Вспомогательные макросы

Существует несколько макросов, упрощающих запись условных значений, которые отличаются в зависимости от набора параметров.

Если переменная `OPTIONS_SUB` имеет значение `yes`, то каждый из указанных в `OPTIONS_DEFINE` параметров будет добавлен в `PLIST_SUB`. Следующая запись:

[.programlisting]
....
OPTIONS_DEFINE=	OPT1
OPTIONS_SUB=	yes
....

соответствует:

[.programlisting]
....
OPTIONS_DEFINE=	OPT1

.include <bsd.port.options.mk>

.if ${PORT_OPTIONS:MOPT1}
PLIST_SUB+=	OPT1=""
.else
PLIST_SUB+=	OPT1="@comment "
.endif
....

`X_CONFIGURE_ENABLE` дописывает в `CONFIGURE_ARGS` строку `--enable-${X_CONFIGURE_ENABLE}` или `--disable-${X_CONFIGURE_ENABLE}` в соответствии с состоянием `X`. Следующая запись:

[.programlisting]
....
OPTIONS_DEFINE=	OPT1
OPT1_CONFIGURE_ENABLE=	test
....

соответствует:

[.programlisting]
....
OPTIONS_DEFINE=	OPT1

.include <bsd.port.options.mk>

.if ${PORT_OPTIONS:MOPT1}
CONFIGURE_ARGS+=	--enable-test
.else
CONFIGURE_ARGS+=	--disable-test
.endif
....

`X_CONFIGURE_WITH` дописывает в `CONFIGURE_ARGS` строку `--with-${X_CONFIGURE_WITH}` или `--without-${X_CONFIGURE_WITH}` в соответствии с состоянием `X`. Следующая запись:

[.programlisting]
....
OPTIONS_DEFINE=	OPT1
OPT1_CONFIGURE_WITH=	test
....

соответствует:

[.programlisting]
....
OPTIONS_DEFINE=	OPT1

.include <bsd.port.options.mk>

.if ${PORT_OPTIONS:MOPT1}
CONFIGURE_ARGS+=	--with-test
.else
CONFIGURE_ARGS+=	--without-test
.endif
....

Значение переменной `X_CONFIGURE_ON` будет дописано в `CONFIGURE_ARGS` в соответствии с состоянием `X`. Следующая запись:

[.programlisting]
....
OPTIONS_DEFINE=	OPT1
OPT1_CONFIGURE_ON=	--add-test
....

соответствует:

[.programlisting]
....
OPTIONS_DEFINE=	OPT1

.include <bsd.port.options.mk>

.if ${PORT_OPTIONS:MOPT1}
CONFIGURE_ARGS+=	--add-test
.endif
....

Значение переменной `X_CONFIGURE_OFF` будет дописано в `CONFIGURE_ARGS` в соответствии с состоянием `X`. Следующая запись:

[.programlisting]
....
OPTIONS_DEFINE=	OPT1
OPT1_CONFIGURE_OFF=	--no-test
....

соответствует:

[.programlisting]
....
OPTIONS_DEFINE=	OPT1
.include <bsd.port.options.mk>
.if ! ${PORT_OPTIONS:MOPT1}
CONFIGURE_ARGS+=	--no-test
.endif
....

Значение переменной `X_CMAKE_ON` будет дописано в `CMAKE_ARGS` в соответствии с состоянием `X`. Следующая запись:

[.programlisting]
....
OPTIONS_DEFINE=	OPT1
OPT1_CMAKE_ON=	-DTEST:BOOL=true
....

соответствует:

[.programlisting]
....
OPTIONS_DEFINE=	OPT1

.include <bsd.port.options.mk>

.if ${PORT_OPTIONS:MOPT1}
CMAKE_ARGS+=	-DTEST:BOOL=true
.endif
....

Значение переменной `X_CMAKE_OFF` будет дописано в `CMAKE_ARGS` в соответствии с состоянием `X`. Следующая запись:

[.programlisting]
....
OPTIONS_DEFINE=	OPT1
OPT1_CMAKE_OFF=	-DTEST:BOOL=false
....

соответствует:

[.programlisting]
....
OPTIONS_DEFINE=	OPT1

.include <bsd.port.options.mk>

.if ! ${PORT_OPTIONS:MOPT1}
CMAKE_ARGS+=	-DTEST:BOOL=false
.endif
....

Для любой из следующих переменных:

* `ALL_TARGET`
* `CATEGORIES`
* `CFLAGS`
* `CPPFLAGS`
* `CXXFLAGS`
* `CONFIGURE_ENV`
* `DISTFILES`
* `EXTRA_PATCHES`
* `INSTALL_TARGET`
* `LDFLAGS`
* `MAKE_ARGS`
* `MAKE_ENV`
* `PATCH_SITES`
* `PATCHFILES`
* `PLIST_FILES`
* `PLIST_DIRS`
* `PLIST_DIRSTRY`
* `USES`

Значение переменной `X_ABOVEVARIABLE` будет дописано в `ABOVEVARIABLE` в соответствии с состоянием `X`. Следующая запись:

[.programlisting]
....
OPTIONS_DEFINE=	OPT1
OPT1_USES=	gmake
OPT1_CFLAGS=	-DTEST
....

соответствует:

[.programlisting]
....
OPTIONS_DEFINE=	OPT1

.include <bsd.port.options.mk>

.if ${PORT_OPTIONS:MOPT1}
USES+=		gmake
CFLAGS+=	-DTEST
.endif
....

Если установлена `X_ABOVEVARIABLE_OFF`, то флаг `ABOVEVARIABLE` будет автоматически выставлен при выключенном параметре `X`. Например:

[.programlisting]
....
OPTIONS_DEFINE=	OPT1
OPT1_USES_OFF=gmake
....

соответствует:

[.programlisting]
....
OPTIONS_DEFINE=	OPT1

.include <bsd.port.options.mk>

.if ! ${PORT_OPTIONS:MOPT1}
USES+=	gmake
.endif
....

Для любого из следующих типов зависимости:

* `PKG_DEPENDS`
* `EXTRACT_DEPENDS`
* `PATCH_DEPENDS`
* `FETCH_DEPENDS`
* `BUILD_DEPENDS`
* `LIB_DEPENDS`
* `RUN_DEPENDS`

Значение переменной `X_ABOVEVARIABLE` будет дописано в `ABOVEVARIABLE` в соответствии с состоянием `X`. Следующая запись:

[.programlisting]
....
OPTIONS_DEFINE=	OPT1
OPT1_LIB_DEPENDS=	liba.so:${PORTSDIR}/devel/a
....

соответствует:

[.programlisting]
....
OPTIONS_DEFINE=	OPT1

.include <bsd.port.options.mk>

.if ${PORT_OPTIONS:MOPT1}
LIB_DEPENDS+=	liba.so:${PORTSDIR}/devel/a
.endif
....

Если установлена `X_ABOVEVARIABLE_OFF`, то зависимость типа `ABOVEVARIABLE` будет добавлена при выключенном параметре `X`. Например:

[.programlisting]
....
OPTIONS_DEFINE=	OPT1
OPT1_LIB_DEPENDS_OFF= liba.so:${PORTSDIR}/devel/a
....

соответствует:

[.programlisting]
....
OPTIONS_DEFINE= OPT1

.include <bsd.port.options.mk>

. if ! ${PORT_OPTIONS:MOPT1}
LIB_DEPENDS+=	liba.so:${PORTSDIR}/devel/a
.endif
....

[[makefile-wrkdir]]
== Задание рабочего каталога

Каждый порт распаковывается в рабочий каталог, который должен быть доступным для записи. В системе портов по умолчанию `DISTFILES` распаковываются в каталог с именем `${DISTNAME}`. Другими словами, если вы задали:

[.programlisting]
....
PORTNAME=	foo
PORTVERSION=	1.0
....

то дистрибутивные файлы порта содержат каталог верхнего уровня, [.filename]#foo-1.0#, и все файлы расположены в этом каталоге.

Если это не ваш случай, то имеется несколько переменных, которые вы можете переопределить.

=== `WRKSRC`

Эта переменная задаёт имя каталога, который создаётся при распаковке исходных файлов приложения. В нашем предыдущем примере если бы распаковка происходила в каталог с именем [.filename]#foo# (а не [.filename]#foo-1.0#), то вы должны написать:

[.programlisting]
....
WRKSRC=	${WRKDIR}/foo
....

или, как вариант

[.programlisting]
....
WRKSRC=	${WRKDIR}/${PORTNAME}
....

=== `NO_WRKSUBDIR`

Если порт вообще не распаковывается ни в какой каталог, то вы должны задать для этого переменную `NO_WRKSUBDIR`.

[.programlisting]
....
NO_WRKSUBDIR=	yes
....

[[conflicts]]
== Разрешение конфликтов

Для регистрации конфликта между пакетами и портами используются три различные переменные: `CONFLICTS`, `CONFLICTS_INSTALL` и `CONFLICTS_BUILD`.

[NOTE]
====
Переменные регистрации конфликта автоматически определяют переменную `IGNORE`, которая более подробно описана в crossref:porting-dads[dads-noinstall, "Пометка неустанавливаемого порта как `BROKEN`, `FORBIDDEN` или `IGNORE` "].
====

При удалении одного из конфликтующих портов целесообразно сохранить записи `CONFLICTS` в тех других портах в течении нескольких месяцев, чтобы позаботиться о тех пользователей, которые обновляются от случая к случаю.

=== `CONFLICTS_INSTALL`

Если ваш пакет не может существовать вместе с другими (из-за конфликта файлов, несовместимости времени выполнения и так далее), перечислите имена остальных пакетов в переменной `CONFLICTS_INSTALL`. Здесь вы можете использовать шаблоны командного интерпретатора, такие как `*` и `?`. Имена пакетов должны выглядеть так же, как в [.filename]#/var/db/pkg#. Пожалуйста, убедитесь, что `CONFLICTS_INSTALL` не содержит пакет самого этого порта. В противном случае не будет работать установка с использованием переменной `FORCE_PKG_REGISTER`. Проверка CONFLICTS_INSTALL выполняется после процесса сборки и до процесса установки.

=== `CONFLICTS_BUILD`

Если ваш порт не может быть собран, когда уже установлен другой, перечислите имена остальных портов в переменной `CONFLICTS_BUILD`. Здесь вы можете использовать шаблоны командного интерпретатора, такие как `*` и `?`. Имена пакетов должны выглядеть так же, как в [.filename]#/var/db/pkg#. Проверка CONFLICTS_BUILD выполняется до процесса сборки. Конфликты сборки в получаемом пакете не записываются.

=== `CONFLICTS`

Если ваш порт не может быть собран, когда уже установлен другой, а получаемый пакет не может существовать вместе с другими, перечислите имена остальных пакетов в переменной `CONFLICTS`. Здесь вы можете использовать шаблоны командного интерпретатора, такие как `*` и `?`. Имена пакетов должны выглядеть так же, как в [.filename]#/var/db/pkg#. Пожалуйста, убедитесь, что `CONFLICTS` не содержит пакет самого этого порта. В противном случае не будет работать установка с использованием переменной `FORCE_PKG_REGISTER`. Проверка CONFLICTS выполняется до процессов сборки и установки.

[[install]]
== Установка файлов

[[install-macros]]
=== Макросы `INSTALL_*`

Используйте макросы, которые есть в файле [.filename]#bsd.port.mk# для обеспечения правильных прав доступа файлов в целях `*-install` порта. Устанавливайте права владения напрямую в [.filename]#pkg-plist# через соответствующие записи `@owner owner` и `@group group`. Эти операторы работают до момента их переопределения или до конца [.filename]#pkg-plist#, поэтому не забывайте их сбрасывать, когда они больше не нужны. По умолчанию владение устанавливается для `root:wheel`.

* `INSTALL_PROGRAM` - это команда для установки бинарных выполнимых файлов.
* `INSTALL_SCRIPT` - это команда для установки выполнимых скриптов.
* `INSTALL_LIB` - это команда для установки динамических библиотек.
* `INSTALL_KLD` - это команда для установки загружаемых модулей ядра. Некоторые архитектуры предпочитают, чтобы для модулей сохранялись отладочные сведения, по этой причине используйте эту команду вместо `INSTALL_PROGRAM`.
* `INSTALL_DATA` - это команда для установки совместно используемых файлов данных.
* `INSTALL_MAN` - это команда для установки страниц Справочника и другой документации (никаких файлов она не сжимает).

В основе работы этих макросов лежит команда `install` со всеми соответствующими флагами. Смотрите пример их использования ниже.

[[install-strip]]
=== Удаление отладочной информации в бинарных файлах и динамических библиотеках

Не удаляйте отладочную информацию из бинарных файлов вручную, если вы это делали. Во всех двоичных файлах отладочная информация должна быть удалена, и макрос `INSTALL_PROGRAM` выполнит установку и удаление отладочной информации одновременно (обратитесь к следующему разделу). Макрос `INSTALL_LIB` делает то же самое для динамических библиотек.

Если вам нужно удалить отладочную информацию из файла без использования макросов `INSTALL_PROGRAM` и `INSTALL_LIB`, то это можно сделать при помощи `${STRIP_CMD}`. Обычно это делается внутри цели `post-install`. К примеру:

[.programlisting]
....
post-install:
	${STRIP_CMD} ${STAGEDIR}${PREFIX}/bin/xdl
....

Удаление отладочной информации из нескольких файлов:

[.programlisting]
....
post-install:
	.for l in geometry media body track world
	${STRIP_CMD} ${STAGEDIR}${PREFIX}/lib/lib${PORTNAME}-${l}.so.0
	.endfor
....

Для проверки того, удалена ли отладочная информация из файла, используйте man:file[1]. Для двоичных файлов man:file[1] печатает `stripped` или `not stripped`. Кроме того, man:strip[1] определяет, была ли уже удалена из программы отладочная информация, и в этом случае просто завершает свою работу.

[[install-copytree]]
=== Установка целого дерева файлов

Иногда должно быть установлено большое количество файлов с сохранением их иерархической организации. Например, копирование дерева каталогов целиком из `WRKSRC` в целевой каталог внутри `PREFIX`. Обратите внимание, что `PREFIX`, `EXAMPLESDIR`, `DATADIR` и другие переменные пути всегда должны предваряться `STAGEDIR`, чтобы не ломать staging (смотрите <<staging>>).

Для этой ситуации существует два макроса. Преимущество от использования этих макросов вместо команды `cp` в том, что они гарантируют установку правильного владельца и прав на конечные файлы. Первый макрос, `COPYTREE_BIN`, делает все устанавливаемые файлы исполняемыми, что подходит для установки в [.filename]#PREFIX/bin#. Второй макрос, `COPYTREE_SHARE`, не устанавливает на файлы права исполнения, и, таким образом, подходит для установки файлов внутри каталога [.filename]#PREFIX/share#.

[.programlisting]
....
post-install:
	${MKDIR} ${STAGEDIR}${EXAMPLESDIR}
	(cd ${WRKSRC}/examples && ${COPYTREE_SHARE} . ${STAGEDIR}${EXAMPLESDIR})
....

В этом примере устанавливается содержимое каталога [.filename]#examples# из установочных файлов производителя в надлежащее место для примеров вашего порта.

[.programlisting]
....
post-install:
	${MKDIR} ${STAGEDIR}${DATADIR}/summer
	(cd ${WRKSRC}/temperatures && ${COPYTREE_SHARE} "June July August" ${STAGEDIR}${DATADIR}/summer)
....

А в этом примере будут установлены данные летних месяцев в подкаталог [.filename]#summer# каталога [.filename]#DATADIR#.

В качестве третьего параметра в макросе `COPYTREE_*` можно передать дополнительные параметры `find`. Например, чтобы в первом примере установить все файлы кроме файлов Makefile, можно использовать следующую команду.

[.programlisting]
....
post-install:
	${MKDIR} ${STAGEDIR}${EXAMPLESDIR}
	(cd ${WRKSRC}/examples && \
	${COPYTREE_SHARE} . ${STAGEDIR}${EXAMPLESDIR} "! -name Makefile")
....

Эти макросы не производят добавление устанавливаемых файлов в [.filename]#pkg-plist#. Они должны быть добавлены туда вручную. Необязательные файлы документации (`PORTDOCS`, смотрите <<install-documentation>>) и примеров (`PORTEXAMPLES`) всегда должны предваряться в [.filename]#pkg-plist# префиксами `%%PORTDOCS%%` или `%%PORTEXAMPLES%%`.

[[install-documentation]]
=== Установка дополнительной документации

Если с вашим программным обеспечением поставляется некоторая документация, отличающаяся от стандартных страниц Справочника и файлов info, которая, как вы думаете, будет полезна пользователям, установите ее в каталог [.filename]#PREFIX/shared/doc#. Это может быть сделано, как и в предыдущем разделе, в цели `post-install`.

Создайте для вашего порта новый каталог. Имя каталога должно соответствовать тому, что представляет из себя порт. Обычно это означает `PORTNAME`. Однако, если вы думаете, что пользователь захочет иметь разные версии порта, установленные одновременно, то вы можете использовать полное имя `PKGNAME`.

Поскольку устанавливаются только файлы, перечисленные в [.filename]#pkg-plist#, безопасным способом будет устанавливать документацию в `STAGEDIR` всегда (смотрите crossref:special[staging, Staging]). Следовательно, блоки `.if` нужны только для файлов достаточно большого размера, установка которых влечёт значительные накладные расходы на операции ввода/вывода.

[.programlisting]
....
post-install:
	${MKDIR} ${STAGEDIR}${DOCSDIR}
	${INSTALL_MAN} ${WRKSRC}/docs/xvdocs.ps ${STAGEDIR}${DOCSDIR}
....

Вот несколько полезных переменных и то, как они преобразуются по умолчанию при использовании в [.filename]#Makefile#:

* `DATADIR` преобразуется в [.filename]#PREFIX/shared/PORTNAME#.
* `DATADIR_REL` преобразуется в [.filename]#share/PORTNAME#.
* `DOCSDIR` преобразуется в [.filename]#PREFIX/shared/doc/PORTNAME#.
* `DOCSDIR_REL` преобразуется в [.filename]#share/doc/PORTNAME#.
* `EXAMPLESDIR` преобразуется в [.filename]#PREFIX/shared/examples/PORTNAME#.
* `EXAMPLESDIR_REL` преобразуется в [.filename]#share/examples/PORTNAME#.

[NOTE]
====
Параметр `DOCS` управляет установкой дополнительной документации в `DOCSDIR`. Это не относится к стандартным страницам справочника и страницам info. Все, что устанавливается в `DATADIR` и `EXAMPLESDIR`, соответственно управляется через параметры `DATA` и `EXAMPLES`.
====

Эти переменные экспортируются в `PLIST_SUB`. Их значения появятся там в виде имён путей относительно [.filename]#PREFIX#, если это возможно. То есть [.filename]#share/doc/PORTNAME# в списке сборки по умолчанию будет заменен на `%%DOCSDIR%%`, и так далее. (Дополнительную информацию о подстановке в [.filename]#pkg-plist# можно найти <<plist-sub,здесь>>.)

Все условно устанавливаемые файлы и каталоги с документацией должны быть перечислены в файле [.filename]#pkg-plist# с префиксом `%%PORTDOCS%%`, например:

[.programlisting]
....
%%PORTDOCS%%%%DOCSDIR%%/AUTHORS
%%PORTDOCS%%%%DOCSDIR%%/CONTACT
%%PORTDOCS%%@dirrm %%DOCSDIR%%
....

В качестве альтернативы перечислению файлов документации в файле [.filename]#pkg-plist#, порт может указать в переменной `PORTDOCS` список имён файлов и глобальных шаблонов командного процессора для добавления в окончательный список сборки. Имена будут задаваться относительно `DOCSDIR`. Таким образом, порт, использующий `PORTDOCS` и нестандартное местоположение документации, должен задавать соответствующим образом и `DOCSDIR`. Если каталог указан в `PORTDOCS` или соответствует шаблону для этой переменной, то полное поддерево с входящими в него файлами и каталогами будет регистрироваться в окончательном списке сборки. Если параметр `DOCS` не задан, то файлы и каталоги, перечисленные в `PORTDOCS`, не будут установлены и добавлены в список сборки порта. Установка документации в `PORTDOCS`, как это показано выше, остаётся за самим портом. Типичный пример использования `PORTDOCS` выглядит следующим образом:

[.programlisting]
....
PORTDOCS=	README.* ChangeLog docs/*
....

[NOTE]
====
Эквивалентами `PORTDOCS` для файлов, устанавливаемых в `DATADIR` и `EXAMPLESDIR` являются `PORTDATA` и `PORTEXAMPLES` соответственно.

Во время установки выводится содержимое [.filename]#pkg-message#. За подробной информацией обратитесь к <<porting-message,разделу об использовании [.filename]#pkg-message#>>. Файл [.filename]#pkg-message# не нужно добавлять в [.filename]#pkg-plist#.
====

[[install-subdirs]]
=== Подкаталоги внутри PREFIX

Попробуйте поместить все файлы порта в правильных подкаталогах каталога `PREFIX`. Некоторые порты игнорируют все установки и помещают все в подкаталог с именем порта, что неправильно. Также многие порты помещают все, кроме бинарных файлов, файлов заголовков и страниц Справочника, в подкаталог каталога [.filename]#lib#, что не очень хорошо работает с подходом BSD. Многие файлы должны быть перемещены в одно из следующих местоположений: [.filename]#etc# (настроечные/конфигурационные файлы), [.filename]#libexec# (выполнимые файлы, запускаемые из других программ), [.filename]#sbin# (исполнимые файлы для администраторов/менеджеров системы), [.filename]#info# (документация в формате info для просмотрщика info) или [.filename]#share# (независимые от архитектуры файлы). Обратитесь к man:hier[7] для прояснения деталей; правила, покрывающие [.filename]#/usr#, достаточно хорошо подходят также и к [.filename]#/usr/local#. Исключением являются порты, имеющие дело с "новостями" USENET. Они могут использовать каталог [.filename]#PREFIX/news# для установки своих файлов.
