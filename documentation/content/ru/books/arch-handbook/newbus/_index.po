# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR The FreeBSD Project
# This file is distributed under the same license as the FreeBSD Documentation package.
# Vladlen Popolitov <vladlenpopolitov@list.ru>, 2025.
msgid ""
msgstr ""
"Project-Id-Version: FreeBSD Documentation VERSION\n"
"POT-Creation-Date: 2025-10-14 22:43+0300\n"
"PO-Revision-Date: 2025-07-05 04:45+0000\n"
"Last-Translator: Vladlen Popolitov <vladlenpopolitov@list.ru>\n"
"Language-Team: Russian <https://translate-dev.freebsd.org/projects/"
"documentation/booksarch-handbooknewbus_index/ru/>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2;\n"
"X-Generator: Weblate 4.17\n"

#. type: Title =
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:1
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:19
#, no-wrap
msgid "Newbus"
msgstr "Newbus"

#. type: Yaml Front Matter Hash Value: title
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:1
#, no-wrap
msgid "Chapter 14. Newbus"
msgstr "Глава 14. Newbus"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:57
msgid ""
"_Special thanks to Matthew N. Dodd, Warner Losh, Bill Paul, Doug Rabson, "
"Mike Smith, Peter Wemm and Scott Long_."
msgstr ""
"_Особая благодарность Мэтью Н. Додду, Уорнеру Лошу, Биллу Полу, Дагу "
"Рэбсону, Майку Смиту, Питеру Вемму и Скотту Лонгу_."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:59
msgid "This chapter explains the Newbus device framework in detail."
msgstr "Эта глава подробно объясняет фреймворк устройств Newbus."

#. type: Title ==
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:61
#, no-wrap
msgid "Device Drivers"
msgstr "Драйверы устройств"

#. type: Title ===
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:63
#, no-wrap
msgid "Purpose of a Device Driver"
msgstr "Назначение драйвера устройства"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:66
msgid ""
"A device driver is a software component which provides the interface between "
"the kernel's generic view of a peripheral (e.g., disk, network adapter) and "
"the actual implementation of the peripheral. The _device driver interface "
"(DDI)_ is the defined interface between the kernel and the device driver "
"component."
msgstr ""
"Драйвер устройства — это программный компонент, который предоставляет "
"интерфейс между обобщённым представлением периферийного устройства "
"(например, диска, сетевого адаптера) в ядре и его фактической реализацией. "
"_Интерфейс драйвера устройства (DDI)_ — это определённый интерфейс между "
"ядром и компонентом драйвера устройства."

#. type: Title ===
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:67
#, no-wrap
msgid "Types of Device Drivers"
msgstr "Типы драйверов устройств"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:70
msgid ""
"There used to be days in UNIX(R), and thus FreeBSD, in which there were four "
"types of devices defined:"
msgstr ""
"В UNIX(R), а следовательно, и в FreeBSD, были времена, когда определялось "
"четыре типа устройств:"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:72
msgid "block device drivers"
msgstr "драйверы блочных устройств"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:73
msgid "character device drivers"
msgstr "драйверы символьных устройств"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:74
msgid "network device drivers"
msgstr "драйверы сетевых устройств"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:75
msgid "pseudo-device drivers"
msgstr "драйверы псевдоустройств"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:77
msgid ""
"_Block devices_ performed in a way that used fixed size blocks [of data]. "
"This type of driver depended on the so-called _buffer cache_, which had "
"cached accessed blocks of data in a dedicated part of memory. Often this "
"buffer cache was based on write-behind, which meant that when data was "
"modified in memory it got synced to disk whenever the system did its "
"periodical disk flushing, thus optimizing writes."
msgstr ""
"_Блочные устройства_ работали таким образом, что использовали блоки [данных] "
"фиксированного размера. Этот тип драйвера зависел от так называемого "
"_буферного кэша_, который кэшировал доступные блоки данных в выделенной "
"части памяти. Часто этот буферный кэш был основан на отложенной записи "
"(write-behind), что означало, что при изменении данных в памяти они "
"синхронизировались с диском во время периодической очистки диска системой, "
"тем самым оптимизируя запись."

#. type: Title ===
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:78
#, no-wrap
msgid "Character Devices"
msgstr "Символьные устройства"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:81
msgid ""
"However, in the versions of FreeBSD 4.0 and onward the distinction between "
"block and character devices became non-existent."
msgstr ""
"Однако в версиях FreeBSD 4.0 и выше различие между блочными и символьными "
"устройствами перестало существовать."

#. type: Title ==
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:83
#, no-wrap
msgid "Overview of Newbus"
msgstr "Обзор Newbus"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:86
msgid ""
"_Newbus_ is the implementation of a new bus architecture based on "
"abstraction layers which saw its introduction in FreeBSD 3.0 when the Alpha "
"port was imported into the source tree. It was not until 4.0 before it "
"became the default system to use for device drivers. Its goals are to "
"provide a more object-oriented means of interconnecting the various busses "
"and devices which a host system provides to the _Operating System_."
msgstr ""
"_Newbus_ — это реализация новой архитектуры шины, основанной на уровнях "
"абстракции, которая была впервые представлена в FreeBSD 3.0, когда порт для "
"Alpha был добавлен в дерево исходного кода. Однако только в версии 4.0 она "
"стала системой по умолчанию для использования с драйверами устройств. Её "
"цель — предоставить более объектно-ориентированный способ взаимодействия "
"между различными шинами и устройствами, которые хост-система предоставляет "
"_операционной системе_."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:88
msgid "Its main features include amongst others:"
msgstr "Основные функции включают, среди прочего:"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:90
msgid "dynamic attaching"
msgstr "динамическое присоединение"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:91
msgid "easy modularization of drivers"
msgstr "простая модуляризация драйверов"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:92
msgid "pseudo-busses"
msgstr "псевдо-шины"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:94
msgid ""
"One of the most prominent changes is the migration from the flat and ad-hoc "
"system to a device tree layout."
msgstr ""
"Одним из наиболее заметных изменений является переход от плоской и "
"нерегламентированной системы к структуре дерева устройств."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:96
msgid ""
"At the top level resides the _\"root\"_ device which is the parent to hang "
"all other devices on. For each architecture, there is typically a single "
"child of \"root\" which has such things as _host-to-PCI bridges_, etc. "
"attached to it. For x86, this \"root\" device is the _\"nexus\"_ device. For "
"Alpha, various different models of Alpha have different top-level devices "
"corresponding to the different hardware chipsets, including _lca_, _apecs_, "
"_cia_ and _tsunami_."
msgstr ""
"На верхнем уровне находится устройство _\"root\"_, которое является "
"родительским для всех остальных устройств. Для каждой архитектуры обычно "
"существует единственный дочерний элемент \"root\", к которому подключены "
"такие компоненты, как _мосты host-to-PCI_ и т.д. Для x86 этим устройством "
"\"root\" является устройство _\"nexus\"_. Для Alpha различные модели Alpha "
"имеют разные устройства верхнего уровня, соответствующие различным "
"аппаратным наборам микросхем, включая _lca_, _apecs_, _cia_ и _tsunami_."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:98
msgid ""
"A device in the Newbus context represents a single hardware entity in the "
"system. For instance each PCI device is represented by a Newbus device. Any "
"device in the system can have children; a device which has children is often "
"called a _\"bus\"_. Examples of common busses in the system are ISA and PCI, "
"which manage lists of devices attached to ISA and PCI busses respectively."
msgstr ""
"Устройство в контексте Newbus представляет собой отдельную аппаратную "
"сущность в системе. Например, каждое PCI-устройство представлено устройством "
"Newbus. Любое устройство в системе может иметь дочерние устройства; "
"устройство, у которого есть дочерние устройства, часто называют _\"шиной\"_. "
"Примерами распространённых шин в системе являются ISA и PCI, которые "
"управляют списками устройств, подключённых к шинам ISA и PCI соответственно."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:100
msgid ""
"Often, a connection between different kinds of bus is represented by a "
"_\"bridge\"_ device, which normally has one child for the attached bus. An "
"example of this is a _PCI-to-PCI bridge_ which is represented by a device "
"_[.filename]#pcibN#_ on the parent PCI bus and has a child "
"_[.filename]#pciN#_ for the attached bus. This layout simplifies the "
"implementation of the PCI bus tree, allowing common code to be used for both "
"top-level and bridged busses."
msgstr ""
"Часто соединение между различными типами шин представлено устройством "
"_\"мост\"_, которое обычно имеет один дочерний элемент для подключенной "
"шины. Примером этого является _PCI-to-PCI мост_, который представлен "
"устройством _[.filename]#pcibN#_ на родительской PCI-шине и имеет дочерний "
"элемент _[.filename]#pciN#_ для подключенной шины. Такая структура упрощает "
"реализацию дерева PCI-шин, позволяя использовать общий код как для "
"верхнеуровневых, так и для соединенных через мост шин."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:102
msgid ""
"Each device in the Newbus architecture asks its parent to map its resources. "
"The parent then asks its own parent until the nexus is reached. So, "
"basically the nexus is the only part of the Newbus system which knows about "
"all resources."
msgstr ""
"Каждое устройство в архитектуре Newbus запрашивает у своего родителя "
"отображение своих ресурсов. Затем родитель запрашивает у своего собственного "
"родителя, пока запрос не достигнет nexus. Таким образом, по сути, nexus - "
"это единственная часть системы Newbus, которая знает обо всех ресурсах."

#. type: delimited block = 4
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:106
msgid ""
"An ISA device might want to map its IO port at `0x230`, so it asks its "
"parent, in this case the ISA bus. The ISA bus hands it over to the PCI-to-"
"ISA bridge which in its turn asks the PCI bus, which reaches the host-to-PCI "
"bridge and finally the nexus. The beauty of this transition upwards is that "
"there is room to translate the requests. For example, the `0x230` IO port "
"request might become memory-mapped at `0xb0000230` on a MIPS box by the PCI "
"bridge."
msgstr ""
"Устройство ISA может захотеть отобразить свой порт ввода-вывода по адресу "
"`0x230`, поэтому оно запрашивает у своего родителя, в данном случае — шины "
"ISA. Шина ISA передаёт запрос мосту PCI-to-ISA, который, в свою очередь, "
"запрашивает шину PCI. Запрос доходит до моста host-to-PCI и, наконец, до "
"nexus. Прелесть этого восходящего перехода в том, что есть возможность "
"преобразовывать запросы. Например, запрос порта ввода-вывода `0x230` может "
"быть преобразован в отображение памяти по адресу `0xb0000230` на системе "
"MIPS с помощью моста PCI."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:109
msgid ""
"Resource allocation can be controlled at any place in the device tree. For "
"instance on many Alpha platforms, ISA interrupts are managed separately from "
"PCI interrupts and resource allocations for ISA interrupts are managed by "
"the Alpha's ISA bus device. On IA-32, ISA and PCI interrupts are both "
"managed by the top-level nexus device. For both ports, memory and port "
"address space is managed by a single entity - nexus for IA-32 and the "
"relevant chipset driver on Alpha (e.g., CIA or tsunami)."
msgstr ""
"Распределение ресурсов может контролироваться в любом месте дерева "
"устройств. Например, на многих платформах Alpha прерывания ISA управляются "
"отдельно от прерываний PCI, а распределение ресурсов для прерываний ISA "
"осуществляется устройством шины ISA Alpha. На IA-32 прерывания ISA и PCI "
"управляются устройством верхнего уровня nexus. Для обеих архитектур "
"управление пространством памяти и портов осуществляется единым объектом — "
"nexus для IA-32 и соответствующим драйвером чипсета на Alpha (например, CIA "
"или tsunami)."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:111
msgid ""
"In order to normalize access to memory and port mapped resources, Newbus "
"integrates the `bus_space` APIs from NetBSD. These provide a single API to "
"replace inb/outb and direct memory reads/writes. The advantage of this is "
"that a single driver can easily use either memory-mapped registers or port-"
"mapped registers (some hardware supports both)."
msgstr ""
"Для стандартизации доступа к памяти и ресурсам, отображённым на порты, "
"Newbus интегрирует API `bus_space` из NetBSD. Они предоставляют единый API "
"для замены inb/outb и прямых операций чтения/записи в память. Преимущество "
"этого подхода в том, что один драйвер может легко использовать либо "
"регистры, отображённые в память, либо регистры, отображённые на порты "
"(некоторое оборудование поддерживает оба варианта)."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:113
msgid ""
"This support is integrated into the resource allocation mechanism. When a "
"resource is allocated, a driver can retrieve the associated "
"`bus_space_tag_t` and `bus_space_handle_t` from the resource."
msgstr ""
"Эта поддержка интегрирована в механизм распределения ресурсов. При выделении "
"ресурса драйвер может получить связанные `bus_space_tag_t` и "
"`bus_space_handle_t` из этого ресурса."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:115
msgid ""
"Newbus also allows for definitions of interface methods in files dedicated "
"to this purpose. These are the [.filename]#.m# files that are found under "
"the [.filename]#src/sys# hierarchy."
msgstr ""
"Newbus также позволяет определять методы интерфейса в файлах, "
"предназначенных для этой цели. Это файлы с расширением [.filename]#.m#, "
"которые находятся в иерархии [.filename]#src/sys#."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:117
msgid ""
"The core of the Newbus system is an extensible \"object-based programming\" "
"model. Each device in the system has a table of methods which it supports. "
"The system and other devices uses those methods to control the device and "
"request services. The different methods supported by a device are defined by "
"a number of \"interfaces\". An \"interface\" is simply a group of related "
"methods which can be implemented by a device."
msgstr ""
"Ядро системы Newbus представляет собой расширяемую модель «объектно-"
"ориентированного программирования». Каждое устройство в системе имеет "
"таблицу поддерживаемых методов. Система и другие устройства используют эти "
"методы для управления устройством и запроса услуг. Различные методы, "
"поддерживаемые устройством, определяются рядом «интерфейсов». «Интерфейс» — "
"это просто группа связанных методов, которые могут быть реализованы "
"устройством."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:119
msgid ""
"In the Newbus system, the methods for a device are provided by the various "
"device drivers in the system. When a device is attached to a driver during "
"_auto-configuration_, it uses the method table declared by the driver. A "
"device can later _detach_ from its driver and _re-attach_ to a new driver "
"with a new method table. This allows dynamic replacement of drivers which "
"can be useful for driver development."
msgstr ""
"В системе Newbus методы для устройства предоставляются различными драйверами "
"устройств в системе. Когда устройство подключается к драйверу во время "
"_автоконфигурации_, оно использует таблицу методов, объявленную драйвером. "
"Устройство может позже _отключиться_ от своего драйвера и _подключиться_ к "
"новому драйверу с новой таблицей методов. Это позволяет динамически заменять "
"драйверы, что может быть полезно для разработки драйверов."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:121
msgid ""
"The interfaces are described by an interface definition language similar to "
"the language used to define vnode operations for file systems. The interface "
"would be stored in a methods file (which would normally be named "
"[.filename]#foo_if.m#)."
msgstr ""
"Интерфейсы описываются языком определения интерфейсов, похожим на язык, "
"используемый для определения операций vnode для файловых систем. Интерфейс "
"хранится в файле методов (который обычно называется [.filename]#foo_if.m#)."

#. type: Block title
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:122
#, no-wrap
msgid "Newbus Methods"
msgstr "Методы Newbus"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:128
#, no-wrap
msgid "      # Foo subsystem/driver (a comment...)\n"
msgstr "      # Foo subsystem/driver (a comment...)\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:130
#, no-wrap
msgid "\t  INTERFACE foo\n"
msgstr "\t  INTERFACE foo\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:134
#, no-wrap
msgid ""
"\tMETHOD int doit {\n"
"\t\tdevice_t dev;\n"
"\t};\n"
msgstr ""
"\tMETHOD int doit {\n"
"\t\tdevice_t dev;\n"
"\t};\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:137
#, no-wrap
msgid ""
"\t# DEFAULT is the method that will be used, if a method was not\n"
"\t# provided via: DEVMETHOD()\n"
msgstr ""
"\t# DEFAULT is the method that will be used, if a method was not\n"
"\t# provided via: DEVMETHOD()\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:142
#, no-wrap
msgid ""
"\tMETHOD void doit_to_child {\n"
"\t\tdevice_t dev;\n"
"\t\tdriver_t child;\n"
"\t} DEFAULT doit_generic_to_child;\n"
msgstr ""
"\tMETHOD void doit_to_child {\n"
"\t\tdevice_t dev;\n"
"\t\tdriver_t child;\n"
"\t} DEFAULT doit_generic_to_child;\n"

#. type: delimited block = 4
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:146
msgid ""
"When this interface is compiled, it generates a header file "
"\"[.filename]#foo_if.h#\" which contains function declarations:"
msgstr ""
"Когда этот интерфейс компилируется, он генерирует заголовочный файл "
"\"[.filename]#foo_if.h#\", который содержит объявления функций:"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:151
#, no-wrap
msgid ""
"      int FOO_DOIT(device_t dev);\n"
"      int FOO_DOIT_TO_CHILD(device_t dev, device_t child);\n"
msgstr ""
"      int FOO_DOIT(device_t dev);\n"
"      int FOO_DOIT_TO_CHILD(device_t dev, device_t child);\n"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:154
msgid ""
"A source file, \"[.filename]#foo_if.c#\" is also created to accompany the "
"automatically generated header file; it contains implementations of those "
"functions which look up the location of the relevant functions in the "
"object's method table and call that function."
msgstr ""
"Исходный файл `[.filename]#foo_if.c#` также создается для сопровождения "
"автоматически сгенерированного заголовочного файла; он содержит реализации "
"функций, которые ищут расположение соответствующих функций в таблице методов "
"объекта и вызывают эту функцию."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:156
msgid ""
"The system defines two main interfaces. The first fundamental interface is "
"called _\"device\"_ and includes methods which are relevant to all devices. "
"Methods in the _\"device\"_ interface include _\"probe\"_, _\"attach\"_ and "
"_\"detach\"_ to control detection of hardware and _\"shutdown\"_, "
"_\"suspend\"_ and _\"resume\"_ for critical event notification."
msgstr ""
"Система определяет два основных интерфейса. Первый фундаментальный интерфейс "
"называется _\"device\"_ (устройство) и включает методы, которые относятся ко "
"всем устройствам. Методы в интерфейсе _\"device\"_ включают _\"probe\"_ "
"(обнаружение), _\"attach\"_ (присоединение) и _\"detach\"_ (отсоединение) "
"для управления обнаружением оборудования, а также _\"shutdown\"_ "
"(выключение), _\"suspend\"_ (приостановка) и _\"resume\"_ (возобновление) "
"для уведомления о критических событиях."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:158
msgid ""
"The second, more complex interface is _\"bus\"_. This interface contains "
"methods suitable for devices which have children, including methods to "
"access bus specific per-device information footnote:"
"[man:bus_generic_read_ivar[9] and man:bus_generic_write_ivar[9]], event "
"notification (`_child_detached_`, `_driver_added_`) and resource management "
"(`_alloc_resource_`, `_activate_resource_`, `_deactivate_resource_`, "
"`_release_resource_`)."
msgstr ""
"Второй, более сложный интерфейс — _\"bus\"_. Этот интерфейс содержит методы, "
"подходящие для устройств, имеющих дочерние элементы, включая методы доступа "
"к специфичной для шины информации об устройстве footnote:"
"[man:bus_generic_read_ivar[9] и man:bus_generic_write_ivar[9]], уведомления "
"о событиях (`_child_detached_`, `_driver_added_`) и управление ресурсами "
"(`_alloc_resource_`, `_activate_resource_`, `_deactivate_resource_`, "
"`_release_resource_`)."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:160
msgid ""
"Many methods in the \"bus\" interface are performing services for some child "
"of the bus device. These methods would normally use the first two arguments "
"to specify the bus providing the service and the child device which is "
"requesting the service. To simplify driver code, many of these methods have "
"accessor functions which lookup the parent and call a method on the parent. "
"For instance the method `BUS_TEARDOWN_INTR(device_t dev, device_t "
"child, ...)` can be called using the function `bus_teardown_intr(device_t "
"child, ...)`."
msgstr ""
"Многие методы в интерфейсе \"bus\" выполняют сервисы для некоторого "
"дочернего устройства шины. Эти методы обычно используют первые два аргумента "
"для указания шины, предоставляющей сервис, и дочернего устройства, "
"запрашивающего сервис. Для упрощения кода драйвера многие из этих методов "
"имеют вспомогательные функции, которые находят родительское устройство и "
"вызывают метод у родителя. Например, метод `BUS_TEARDOWN_INTR(device_t dev, "
"device_t child, ...)` может быть вызван с помощью функции "
"`bus_teardown_intr(device_t child, ...)`."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:162
msgid ""
"Some bus types in the system define additional interfaces to provide access "
"to bus-specific functionality. For instance, the PCI bus driver defines the "
"\"pci\" interface which has two methods `_read_config_` and `_write_config_` "
"for accessing the configuration registers of a PCI device."
msgstr ""
"Некоторые типы шин в системе определяют дополнительные интерфейсы для "
"предоставления доступа к специфичной для шины функциональности. Например, "
"драйвер шины PCI определяет интерфейс \"pci\", который имеет два метода "
"`_read_config_` и `_write_config_` для доступа к конфигурационным регистрам "
"устройства PCI."

#. type: Title ==
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:164
#, no-wrap
msgid "Newbus API"
msgstr "Newbus API"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:167
msgid ""
"As the Newbus API is huge, this section makes some effort at documenting it. "
"More information to come in the next revision of this document."
msgstr ""
"Поскольку API Newbus очень обширен, в этом разделе предпринята попытка его "
"документирования. Дополнительная информация будет добавлена в следующей "
"версии этого документа."

#. type: Title ===
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:168
#, no-wrap
msgid "Important Locations in the Source Hierarchy"
msgstr "Важные места в иерархии исходного кода"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:171
msgid ""
"[.filename]#src/sys/[arch]/[arch]# - Kernel code for a specific machine "
"architecture resides in this directory. For example, the `i386` "
"architecture, or the `SPARC64` architecture."
msgstr ""
"[.filename]#src/sys/[arch]/[arch]# - Код ядра для конкретной аппаратной "
"архитектуры находится в этом каталоге. Например, архитектура `i386` или "
"архитектура `SPARC64`."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:173
msgid ""
"[.filename]#src/sys/dev/[bus]# - device support for a specific `[bus]` "
"resides in this directory."
msgstr ""
"[.filename]#src/sys/dev/[bus]# - поддержка устройств для конкретной `[bus]` "
"находится в этом каталоге."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:175
msgid ""
"[.filename]#src/sys/dev/pci# - PCI bus support code resides in this "
"directory."
msgstr ""
"[.filename]#src/sys/dev/pci# - Код поддержки шины PCI находится в этом "
"каталоге."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:177
msgid ""
"[.filename]#src/sys/[isa|pci]# - PCI/ISA device drivers reside in this "
"directory. The PCI/ISA bus support code used to exist in this directory in "
"FreeBSD version `4.0`."
msgstr ""
"[.filename]#src/sys/[isa|pci]# - В этом каталоге находятся драйверы "
"устройств PCI/ISA. Код поддержки шины PCI/ISA располагался в этом каталоге в "
"FreeBSD версии `4.0`."

#. type: Title ===
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:178
#, no-wrap
msgid "Important Structures and Type Definitions"
msgstr "Важные структуры и определения типов"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:181
msgid ""
"`devclass_t` - This is a type definition of a pointer to a `struct devclass`."
msgstr "`devclass_t` - Это определение типа указателя на `struct devclass`."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:183
msgid ""
"`device_method_t` - This is the same as `kobj_method_t` (see [.filename]#src/"
"sys/kobj.h#)."
msgstr ""
"`device_method_t` - Это то же самое, что и `kobj_method_t` (см. "
"[.filename]#src/sys/kobj.h#)."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:185
msgid ""
"`device_t` - This is a type definition of a pointer to a `struct device`. "
"`device_t` represents a device in the system. It is a kernel object. See "
"[.filename]#src/sys/sys/bus_private.h# for implementation details."
msgstr ""
"`device_t` - Это определение типа указателя на структуру `struct device`. "
"`device_t` представляет устройство в системе. Это объект ядра. Подробности "
"реализации см. в [.filename]#src/sys/sys/bus_private.h#."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:187
msgid ""
"`driver_t` - This is a type definition which references `struct driver`. The "
"`driver` struct is a class of the `device` kernel object; it also holds data "
"private to the driver."
msgstr ""
"`driver_t` - Это определение типа, которое ссылается на `struct driver`. "
"Структура `driver` является классом объекта ядра `device`; она также "
"содержит данные, приватные для драйвера."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:189
#, fuzzy
#| msgid "*_driver_t_ Implementation*\n"
msgid "*_driver_t_ Implementation*"
msgstr "* Реализация _driver_t_*\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:195
#, no-wrap
msgid ""
"\t  struct driver {\n"
"\t\tKOBJ_CLASS_FIELDS;\n"
"\t\tvoid\t*priv;\t\t\t/* driver private data */\n"
"\t  };\n"
msgstr ""
"\t  struct driver {\n"
"\t\tKOBJ_CLASS_FIELDS;\n"
"\t\tvoid\t*priv;\t\t\t/* driver private data */\n"
"\t  };\n"

#. type: Plain text
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:198
msgid ""
"A `device_state_t` type, which is an enumeration, `device_state`. It "
"contains the possible states of a Newbus device before and after the "
"autoconfiguration process."
msgstr ""
"Тип `device_state_t`, который является перечислением, `device_state`. Он "
"содержит возможные состояния устройства Newbus до и после процесса "
"автонастройки."

#. type: Plain text
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:200
#, fuzzy
#| msgid "*Device States _device_state_t*\n"
msgid "*Device States _device_state_t*"
msgstr "*Состояния устройств _device_state_t*\n"

#. type: delimited block . 4
#: documentation/content/en/books/arch-handbook/newbus/_index.adoc:211
#, no-wrap
msgid ""
"\t  /*\n"
"\t   * src/sys/sys/bus.h\n"
"\t   */\n"
"\t  typedef enum device_state {\n"
"\t\tDS_NOTPRESENT,\t/* not probed or probe failed */\n"
"\t\tDS_ALIVE,\t\t/* probe succeeded */\n"
"\t\tDS_ATTACHED,\t/* attach method called */\n"
"\t\tDS_BUSY\t\t\t/* device is open */\n"
"\t  } device_state_t;\n"
msgstr ""
"\t  /*\n"
"\t   * src/sys/sys/bus.h\n"
"\t   */\n"
"\t  typedef enum device_state {\n"
"\t\tDS_NOTPRESENT,\t/* not probed or probe failed */\n"
"\t\tDS_ALIVE,\t\t/* probe succeeded */\n"
"\t\tDS_ATTACHED,\t/* attach method called */\n"
"\t\tDS_BUSY\t\t\t/* device is open */\n"
"\t  } device_state_t;\n"
