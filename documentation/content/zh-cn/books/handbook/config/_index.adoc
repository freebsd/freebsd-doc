---
title: 第 12 章 设置和调整
part: 部分 III. 系统管理
prev: books/handbook/partiii
next: books/handbook/boot
showBookMenu: true
weight: 16
path: "/books/handbook/config/"
---

[[config-tuning]]
= 设置和调整
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 12
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/config/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[config-synopsis]]
== 概述

使用 FreeBSD 的一个重要问题是系统配置。 正确地配置系统能充分地减少以后维护和升级系统所需的工作量。 这章将解释一些 FreeBSD 的配置过程，包括一些可以调整的 FreeBSD 系统的一些参数。

读完本章， 您将了解：

* 如何有效地利用文件系统和交换分区。
* [.filename]#rc.conf# 的基本设置以及 [.filename]#/usr/local/etc/rc.d# 启动体系。
* 如何设置和测试网卡。
* 如何在您的网络设备上配置虚拟主机。
* 如何使用 [.filename]#/etc# 下的各配置文件。
* 如何通过 `sysctl` 变量来对 FreeBSD 系统进行调优。
* 怎样调整磁盘性能和修改内核限制。

在阅读本章之前，您应该了解：

* 了解 UNIX(R) 和 FreeBSD 的基础知识 (crossref:basics[basics,UNIX 基础])。
* 熟悉内核配置编译的基础知识 (crossref:kernelconfig[kernelconfig,配置FreeBSD的内核])。

[[configtuning-initial]]
== 初步配置

=== 分区规划

==== 基本分区

当使用 man:bsdlabel[8] 或者 man:sysinstall[8] 来分割您的文件系统的时候， 要记住硬盘驱动器外磁道传输数据要比从内磁道传输数据快。 因此应该将小的和经常访问的文件系统放在驱动器靠外的位置， 一些大的分区比如 [.filename]#/usr# 应该放在磁盘比较靠里的位置。 以类似这样的顺序建立分区是一个不错的主意：root，swap， [.filename]#/var#， [.filename]#/usr#。

[.filename]#/var# 分区的大小能反映您的机器使用情况。 [.filename]#/var# 文件系统用来存储邮件， 日志文件和打印队列缓存， 特别是邮箱和日志文件可能会达到无法预料的大小， 这主要取决于在您的系统上有多少用户和您的日志文件可以保存多长时间。 大多数用户很少需要 [.filename]#/var# 有 1GB 以上的闲置空间。

[NOTE]
====
有时候 [.filename]#/var/tmp# 需要很多的磁盘空间。 在使用 man:pkg_add[1] 安装新的软件时，包管理工具会在 [.filename]#/var/tmp# 中解压出一份临时拷贝。 大的软件包，像 Firefox， OpenOffice 或者 LibreOffice 在安装时如果 [.filename]#/var/tmp# 中没有足够的空间就可能需要一些技巧了。
====

[.filename]#/usr# 分区存储很多用来系统运行所需要的文件例如 man:ports[7] (建议这样做) 和源代码 (可选的)。 ports 和基本系统的源代码在安装时都是可选的， 但我们建议给这个分区至少保留 2GB 的可用空间。

当选择分区大小的时候，记住保留一些空间。 用完了一个分区的空间而在另一个分区上还有很多， 可能会导致出现一些错误。

[NOTE]
====
一些用户会发现 man:sysinstall[8] 的 `Auto-defaults` 自动分区有时会分配给 [.filename]#/var# 和 [.filename]#/# 较小的分区空间。 分区应该精确一些并且大一些。
====

[[swap-design]]
==== 交换分区

一般来讲，交换分区应该大约是系统内存 (RAM) 的两倍。 例如，如果机器有 128M 内存，交换文件应该是 256M。 较小内存的系统可以通过多一点地交换分区来提升性能。 不建议小于 256 兆的交换分区，并且扩充您的内存应该被考虑一下。 当交换分区最少是主内存的两倍的时候，内核的 VM (虚拟内存) 页面调度算法可以将性能调整到最好。如果您给机器添加更多内存， 配置太小的交换分区会导致 VM 页面扫描的代码效率低下。

在使用多块SCSI磁盘(或者不同控制器上的IDE磁盘)的大系统上， 建议在每个驱动器上建立交换分区(直到四个驱动器)。 交换分区应该大约一样大小。内核可以使用任意大小， 但内部数据结构则是最大交换分区的 4 倍。保持交换分区同样的大小， 可以允许内核最佳地调度交换空间来访问磁盘。 即使不太使用，分配大的交换分区也是好的， 在被迫重启之前它可以让您更容易的从一个失败的程序中恢复过来。

==== 为什么要分区？

一些用户认为一个单独的大分区将会很好， 但是有很多原因会证明为什么这是个坏主意。首先， 每个分区有不同的分区特性，因此分开可以让文件系统调整它们。 例如，根系统和 [.filename]#/usr# 一般只是读取，写入很少。 很多读写频繁的被放在 [.filename]#/var# 和 [.filename]##/var/tmp##中。

适当的划分一个系统， 在其中使用较小的分区， 这样， 那些以写为主的分区将不会比以读为主的分区付出更高的代价。 将以写为主的分区放在靠近磁盘的边缘， 例如放在实际的大硬盘的前面代替放在分区表的后面，将会提高您需要的分区的 I/O 性能。现在可能也需要在比较大的分区上有很好的 I/O 性能， 把他们移动到磁盘外围不会带来多大的性能提升，反而把 [.filename]#/var# 移到外面会有很好的效果。最后涉及到安全问题。 一个主要是只读的小的、整洁的根分区可以提高从一个严重的系统崩溃中恢复过来的机会。 

[[configtuning-core-configuration]]
== 核心配置

系统的配置信息主要位于 [.filename]#/etc/rc.conf#。 这个文件包含了配置信息很大的一部分，主要在系统启动的时候来配置系统， 这个名字直接说明了这点；它也是 [.filename]#rc*# 文件的配置信息。

系统管理员应该在 [.filename]#rc.conf# 文件中建立记录来覆盖 [.filename]#/etc/defaults/rc.conf# 中的默认设置。 这个默认文件不应该被逐字的复制到 [.filename]#/etc# ―― 它包含的是默认值而不是一个例子。 所有特定的改变应该在 [.filename]#rc.conf# 中。

在集群应用中，为了降低管理成本， 可以采用多种策略把涉及全站范围的设置从特定于系统的设置中分离出来。 推荐的方法是把系统范围的配置放到 [.filename]#/etc/rc.conf.local# 文件中。 例如：

* [.filename]#/etc/rc.conf#:
+
[.programlisting]
....
sshd_enable="YES"
keyrate="fast"
defaultrouter="10.1.1.254"
....

* [.filename]#/etc/rc.conf.local#:
+
[.programlisting]
....
hostname="node1.example.org"
ifconfig_fxp0="inet 10.1.1.1/8"
....

[.filename]#rc.conf# 文件可以通过 `rsync` 或类似的程序来分发到所有的机器上， 而各自的 [.filename]#rc.conf.local# 文件则保持不变。

使用 man:sysinstall[8] 或者 `make world` 来升级系统不会覆盖 [.filename]#rc.conf# 文件， 所以系统配置信息不会丢失。

[TIP]
====

配置文件 [.filename]#/etc/rc.conf# 是通过 man:sh[1] 解析的。 这使得系统管理员可以在其中添加一些逻辑， 从而创建能够适应非常复杂的场景的配置。 请参阅联机手册 man:rc.conf[5] 来了解关于这一话题的进一步信息。
====

[[configtuning-appconfig]]
== 应用程序配置

典型的，被安装的应用程序有他自己的配置文件、语法等等。 从基本系统中分开他们是很重要的以至于他们可以容易的被 package 管理工具定位和管理

一般来说，这些文件被安装在 [.filename]#/usr/local/etc#。这个例子中， 一个应用程序有很多配置文件并且创建了一个子目录来存放他们。

通常，当一个 port 或者 package 被安装的时候， 配置文件示例也同样被安装了。它们通常用 [.filename]#.default# 的后缀来标识。如果不存在这个应用程序的配置文件， 它们会通过复制 [.filename]#.default# 文件来创建。

例如，看一下这个目下的内容 [.filename]#/usr/local/etc/apache#：

....
-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf
-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf.default
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf.default
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic.default
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types.default
-rw-r--r--  1 root  wheel   7980 May 20  1998 srm.conf
-rw-r--r--  1 root  wheel   7933 May 20  1998 srm.conf.default
....

文件大小显示了只有 [.filename]#srm.conf# 改变了。以后 Apache 的升级就不会改变这个文件。

[[configtuning-starting-services]]
== 启动服务

许多用户会选择使用 Ports Collection 来在 FreeBSD 上安装第三方软件。 很多情况下这可能需要进行一些配置以便让这些软件能够在系统初始化的过程中启动。 服务， 例如 package:mail/postfix[] 或 package:www/apache13[] 就是这些需要在系统初始化时启动的软件包中的两个典型代表。 这一节解释了启动第三方软件所需要的步骤。

FreeBSD 包含的大多数服务，例如 man:cron[8]， 就是通过系统启动脚本启动的。 这些脚本也许会有些不同， 这取决于 FreeBSD 版本。 但是不管怎样， 需要考虑的一个重要方面是他们的启动配置文件要能被基本启动脚本识别捕获。

=== 扩展应用程序配置

现在 FreeBSD 提供了 [.filename]#rc.d#， 这使得对应用软件的启动进行配置变得更加方便， 并提供了更多的其他功能。 例如， 使用在 <<configtuning-rcd,rc.d>> 一节中所介绍的关键字， 应用程序就可以设置在某些其他服务， 例如 DNS 之后启动； 除此之外， 还可以通过 [.filename]#rc.conf# 来指定一些额外的启动参数， 而不再需要将它们硬编码到启动脚本中。 基本的启动脚本如下所示：

[.programlisting]
....
#!/bin/sh
#
# PROVIDE: utility
# REQUIRE: DAEMON
# KEYWORD: shutdown

. /etc/rc.subr

name=utility
rcvar=utility_enable

command="/usr/local/sbin/utility"

load_rc_config $name

#
# DO NOT CHANGE THESE DEFAULT VALUES HERE
# SET THEM IN THE /etc/rc.conf FILE
#
utility_enable=${utility_enable-"NO"}
pidfile=${utility_pidfile-"/var/run/utility.pid"}

run_rc_command "$1"
....

这个脚本将保证 utility 能够在 `DAEMON` 服务之后启动。 它同时也提供了设置和跟踪 PID， 也就是进程 ID 文件的方法。

可以在 [.filename]#/etc/rc.conf# 中加入：

[.programlisting]
....
utility_enable="YES"
....

这个方法也使得命令行参数、包含 [.filename]#/etc/rc.subr# 中所提供的功能， 兼容 man:rcorder[8] 工具并提供更简单的通过 [.filename]#rc.conf# 文件来配置的方法。

=== 用服务来启动服务

其他服务， 例如 POP3 服务器， IMAP， 等等， 也可以通过 man:inetd[8] 来启动。 这一过程包括从 Ports Collection 安装相应的应用程序， 并把配置加入到 [.filename]#/etc/inetd.conf# 文件， 或去掉当前配置中的某些注释。 如何使用和配置 inetd 在 crossref:network-servers[network-inetd,inetd] 一节中进行了更为深入的阐述。

一些情况下， 通过 man:cron[8] 来启动系统服务也是一种可行的选择。 这种方法有很多好处， 因为 `cron` 会以 [.filename]#crontab# 的文件属主身份执行那些进程。 这使得普通用户也能够执行他们的应用。

`cron` 工具提供了一个独有的功能， 以 `@reboot` 来指定时间。 这样的设置将在 man:cron[8] 启动时运行， 通常这也是系统初始化的时候。

[[configtuning-cron]]
== 配置 `cron`

FreeBSD 最有用的软件包(utilities)中的一个是 man:cron[8]。 `cron` 软件在后台运行并且经常检查 [.filename]#/etc/crontab# 文件。`cron` 软件也检查 [.filename]#/var/cron/tabs# 目录，搜索新的 [.filename]#crontab# 文件。这些 [.filename]#crontab# 文件存储一些 `cron` 在特定时间执行任务的信息。

`cron` 程序使用两种不同类型的配置文件， 即系统 crontab 和用户 crontabs。 两种格式的唯一区别是第六个字段。 在系统 crontab 中，第六个字段是用于执行命令的用户名。 这给予了系统 crontab 以任意用户身份执行命令的能力。 在用户 crontab 中， 第六个字段是要执行的命令， 所有的命令都会以这个用户自己的身份执行； 这是一项重要的安全功能。

[NOTE]
====
同其他用户一样， `root` 用户也可以有自己的 crontab。 它不同于 [.filename]#/etc/crontab# (也就是系统 crontab)。 由于有系统 crontab 的存在， 通常并不需要给 `root` 建立单独的用户 crontab。
====

让我们来看一下 [.filename]#/etc/crontab# 文件：

[.programlisting]
....
# /etc/crontab - root's crontab for FreeBSD
#
# $FreeBSD: src/etc/crontab,v 1.32 2002/11/22 16:13:39 tom Exp $
## <.>
#
SHELL=/bin/sh
PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin <.>
HOME=/var/log
#
#
#minute	hour	mday	month	wday	who	command <.>
#
#
*/5	*	*	*	*	root	/usr/libexec/atrun <.>
....

<.> 像大多数 FreeBSD 配置文件一样，`#` 字符是注释。 这样， 就可以编写注释来说明要执行什么操作， 以及这样做的原因。 需要注意的是， 注释应该另起一行， 而不能跟命令放在同一行上， 否则它们会被看成命令的一部分。 这个文件中的空行会被忽略。

<.> 首先应该定义环境变量。等号 (`=`) 字符用来定义任何环境变量，像这个例子用到了 `SHELL`，`PATH` 和 `HOME` 变量。如果 shell 行被忽略掉，`cron` 将会用默认值 `sh`。如果 `PATH` 变量被忽略， 那么就没有默认值并且需要指定文件绝对位置。如果 `HOME` 被忽略，`cron` 将用用执行者的 home 目录。

<.> 这一行定义了七个字段。它们是 `minute`、 `hour`、`mday`、 `month`、`wday`、 `who` 和 `command`。 它们差不多已经说明了各自的用处。Minute 是命令要运行时的分钟，Hour 跟 minute 差不多，只是用小时来表示。Mday 是每个月的天。Month 跟 hour 还有 minute 都差不多，用月份来表示。wday 字段表示星期几。 所有这些字段的值必须是数字并且用24小时制来表示。"who" 字段是特别的，并且只在 [.filename]#/etc/crontab# 文件中存在。 这个字段指定了命令应该以哪个用户的身份来运行。当一个用户添加了他(她)的 [.filename]#crontab# 文件的时候，他们就会没有这个字段选项。最后，是 `command` 字段。这是最后的一个字段， 所以自然就是它指定要运行的程序。

<.> 最后一行定义了上面所说的值。注意这里我们有一个 `*/5` 列表，紧跟着是一些 `*` 字符。`*` 字符代表"开始到最后"， 也可以被解释成 _每次_。所以，根据这行， 显然表明了无论在何时每隔 5 分钟以 `root` 身份来运行 `atrun` 命令。查看 man:atrun[8] 手册页以获得 `atrun` 的更多信息。命令可以有任意多个传递给它们的标志。无论怎样， 扩展到多行的命令应该用反斜线("\")来续行。

这是每个 [.filename]#crontab# 文件的基本设置， 虽然它们有一个不同。第六行我们指定的用户名只存在于系统 [.filename]#/etc/crontab# 文件。这个字段在普通用户的 [.filename]#crontab# 文件中应该被忽略。

[[configtuning-installcrontab]]
=== 安装 Crontab

[IMPORTANT]
====
绝对不要用这种方法来编辑/安装系统 crontab。 您需要做的只是使用自己喜欢的编辑器： `cron` 程序会注意到文件发生了变化， 并立即开始使用新的版本。参见 extref:{faq}[这个 FAQ 项目, ROOT-NOT-FOUND-CRON-ERRORS] 以了解进一步的情况。
====

要安装刚写好的用户 [.filename]#crontab#， 首先使用最习惯的编辑器来创建一个符合要求格式的文件，然后用 `crontab` 程序来完成。最常见的用法是：

[source,shell]
....
% crontab crontab-file
....

在前面的例子中， [.filename]#crontab-file# 是一个事先写好的 [.filename]#crontab#。

还有一个选项用来列出安装的 [.filename]#crontab# 文件： 只要传递 `-l` 选项给 `crontab` 然后看一下输出。

用户想不用模板(已经存在的文件)而直接安装他的 crontab 文件，用 `crontab -e` 选项也是可以的。 它将会启动一个编辑器并且创建一个新文件，当这个文件被保存的时候， 它会自动的用 `crontab` 来安装这个文件。 

如果您稍后想要彻底删除自己的用户 [.filename]#crontab# 可以使用 `crontab` 的 `-r` 选项。 

[[configtuning-rcd]]
== 在 FreeBSD 中使用 rc

在 2002 年， FreeBSD 整合了来自 NetBSD 的 [.filename]#rc.d# 系统， 并通过它来完成系统的初始化工作。 用户要注意在 [.filename]#/etc/rc.d# 目录下的文件。 这里面的许多文件是用来管理基础服务的， 它们可以通过 `start`、 `stop`， 以及 `restart` 选项来控制。 举例来说， man:sshd[8] 可以通过下面的命令来重启：

[source,shell]
....
# /etc/rc.d/sshd restart
....

对其它服务的操作与此类似。 当然， 这些服务通常是在启动时根据 man:rc.conf[5] 自动启动的。 例如， 要配置使系统启动时启动网络地址转换服务， 可以简单地通过在 [.filename]#/etc/rc.conf# 中加入如下设置来完成：

[.programlisting]
....
natd_enable="YES"
....

如果 `natd_enable="NO"` 行已经存在， 只要简单的把 `NO` 改成 `YES` 即可。 rc 脚本在下次重新启动的时候会自动的装载所需要的服务， 像下面所描述的那样。

由于 [.filename]#rc.d# 系统在系统启动/关闭时首先启动/停止服务，如果设置了适当的 [.filename]#/etc/rc.conf# 变量，标准的 `start`、`stop` 和 `restart` 选项将会执行他们的动作。例如 `sshd restart` 命令只在 [.filename]#/etc/rc.conf# 中的 `sshd_enable` 设置成 `YES` 的时候工作。不管是否在 [.filename]#/etc/rc.conf# 中设置了，要 `start`、`stop` 或者 `restart` 一个服务，命令前可以加上一个"one"前缀。例如要不顾当前 [.filename]#/etc/rc.conf# 的设置重新启动 `sshd`，执行下面的命令：

[source,shell]
....
# /etc/rc.d/sshd onerestart
....

用选项 `rcvar` 可以简单来的检查 [.filename]#/etc/rc.conf# 中用适当的 [.filename]#rc.d# 脚本启动的服务是否被启用。从而管理员可以运行这样的程序来检查 `sshd` 是否真的在 [.filename]#/etc/rc.conf# 中被启动了：

[source,shell]
....
# /etc/rc.d/sshd rcvar
# sshd
$sshd_enable=YES
....

[NOTE]
====
第二行 (`# sshd`) 是从 `sshd` 命令中输出的，而不是 `root` 控制台。
====

为了确定一个服务是否真的在运行，可以用 `status` 选项。例如验证 `sshd` 是否真的启动了：

[source,shell]
....
# /etc/rc.d/sshd status
sshd is running as pid 433.
....

有些时候也可以 `reload` 服务。 这一操作实际上是向服务发送一个信号， 来强制其重新加载配置。 多数情况下， 发给服务的会是 `SIGHUP` 信号。 并非所有服务都支持这一功能。

[.filename]#rc.d# 系统不仅用于网络服务， 它也为系统初始化中的多数过程提供支持。 比如 [.filename]#bgfsck# 文件， 当它被执行时， 将会给出下述信息：

[source,shell]
....
Starting background file system checks in 60 seconds.
....

这个文件用做后台文件系统检查，系统初始化的时候完成。

很多系统服务依赖其他服务提供的相应功能。例如，NIS 和其他基于 RPC 的服务启动可能在 `rpcbind` 服务启动之前失败。 要解决这个问题，依赖关系信息和其他头信息当作注释被包含在每个启动脚本文件的前面。 程序在系统初始化时分析这些注释以决定调用其他系统服务来满足依赖关系。

下面的字句必须被包含在所有的启动脚本文件里， （他们都是 man:rc.subr[8] 用来 "enable" 启动脚本必需的）:

* `PROVIDE`: 指定此文件所提供的服务的名字。

以下的字句可以被包含在启动文件的顶部。严格来说他们不是必需的， 但作为对于 man:rcorder[8] 有一定的提示作用：

* `REQUIRE`: 列出此服务启动之前所需要的其他服务。 此脚本提供的服务会在指定的那些服务 _之后_ 启动。
* `BEFORE`: 列出依赖此服务的其他服务。 此脚本提供的服务将在指定的那些服务 _之前_ 启动。

通过在启动脚本中仔细设定这些关键字， 系统管理员可以很有条理的控制脚本的启动顺序， 进而避免使用像其他 UNIX(R) 操作系统那样混乱的 "runlevels"。

更多关于 [.filename]#rc.d# 系统的信息， 可以在 man:rc[8] 和 man:rc.subr[8] 联机手册中找到。 如果您有意撰写自己的 [.filename]#rc.d# 脚本， 或对现有的脚本进行一些改进， 也可以参考 extref:{rc-scripting}[这篇文章]。

[[config-network-setup]]
== 设置网卡

现在我们不可想象一台计算机没有网络连接的情况。 添加和配置一块网卡是任何 FreeBSD 系统管理员的一项基本任务。 

=== 查找正确的驱动程序

在开始之前，您应该知道您的网卡类型，它用的芯片和它是 PCI 还是 ISA 网卡。FreeBSD 支持很多种 PCI 和 ISA 网卡。 可以查看您的版本硬件兼容性列表以确定您的网卡被支持。 

确认系统能够支持您的网卡之后， 您还需要为它选择合适的驱动程序。 [.filename]#/usr/src/sys/conf/NOTES# 和 [.filename]#/usr/src/sys/arch/conf/NOTES# 将为您提供所支持的一些网卡和芯片组的信息。 如果您怀疑驱动程序是否使所要找的那一个， 请参考驱动程序的联机手册。 联机手册将提供关于所支持的硬件更详细的信息， 甚至还包括可能发生的问题。

如果您的网卡很常见的话， 大多数时候您不需要为驱动浪费精力。 常用的网卡在 [.filename]#GENERIC# 内核中已经支持了， 所以您的网卡在启动时就会显示出来，像是：

[source,shell]
....
dc0: <82c169 PNIC 10/100BaseTX> port 0xa000-0xa0ff mem 0xd3800000-0xd38
000ff irq 15 at device 11.0 on pci0
miibus0: <MII bus> on dc0
bmtphy0: <BCM5201 10/100baseTX PHY> PHY 1 on miibus0
bmtphy0:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
dc0: Ethernet address: 00:a0:cc:da:da:da
dc0: [ITHREAD]
dc1: <82c169 PNIC 10/100BaseTX> port 0x9800-0x98ff mem 0xd3000000-0xd30
000ff irq 11 at device 12.0 on pci0
miibus1: <MII bus> on dc1
bmtphy1: <BCM5201 10/100baseTX PHY> PHY 1 on miibus1
bmtphy1:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
dc1: Ethernet address: 00:a0:cc:da:da:db
dc1: [ITHREAD]
....

在这个例子中，我们看到有两块使用 man:dc[4] 驱动的网卡在系统中。

如果您的网卡没有出现在 [.filename]#GENERIC# 中， 则需要手工加载合适的驱动程序。 要完成这项工作可以使用下面两种方法之一：

* 最简单的办法是用 man:kldload[8] 加载网卡对应的内核模块。 除此之外， 通过在 [.filename]#/boot/loader.conf# 文件中加入适当的设置， 也可以让系统在引导时自动加载这些模块。 不过， 并不是所有的网卡都能够通过这种方法提供支持； ISA 网卡是比较典型的例子。
* 另外， 您也可以将网卡的支持静态联编进内核。 察看 [.filename]#/usr/src/sys/conf/NOTES#， [.filename]#/usr/src/sys/arch/conf/NOTES# 以及驱动程序的联机手册以了解需要在您的内核配置文件中加一些什么。 要了解关于重新编译内核的进一步细节， 请参见 crossref:kernelconfig[kernelconfig,配置FreeBSD的内核]。 如果您的卡在引导时可以被内核 ([.filename]#GENERIC#) 识别， 您应该不需要编译新的内核。

[[config-network-ndis]]
==== 使用 Windows(R) NDIS 驱动程序

不幸的是， 许多厂商由于认为驱动程序会涉及许多敏感的商业机密， 至今仍不愿意将把驱动程序作为开放源代码形式发布列入他们的时间表。 因此， FreeBSD 和其他操作系统的开发者就只剩下了两种选择： 要么经历长时间的痛苦过程来对驱动进行逆向工程， 要么使用现存的为 Microsoft(R) Windows(R) 平台提供的预编译版本的驱动程序。 包括参与 FreeBSD 开发的绝大多数开发人员， 都选择了后一种方法。

得益于 Bill Paul (wpaul) 的工作， 已经可以 "直接地" 支持 网络驱动接口标准 (NDIS, Network Driver Interface Specification) 了。 FreeBSD NDISulator (也被称为 Project Evil) 可以支持二进制形式的 Windows(R) 驱动程序， 并让它相信正在运行的是 Windows(R)。 由于 man:ndis[4] 驱动使用的是用于 Windows(R) 的二进制形式的驱动， 因此它只能在 i386(TM) 和 amd64 系统上使用。

[NOTE]
====
man:ndis[4] 驱动在设计时主要提供了 PCI、 CardBus 和 PCMCIA 设备的支持， 而 USB 设备目前则没有提供支持。
====

要使用 NDISulator， 您需要三件东西：

. 内核的源代码
. 二进制形式的 Windows(R) XP 驱动程序 (扩展名为 [.filename]#.SYS#)
. Windows(R) XP 驱动程序配置文件 (扩展名为 [.filename]#.INF#)

您需要找到用于您的卡的这些文件。 一般而言， 这些文件可以在随卡附送的 CD 或制造商的网站上找到。 在下面的例子中， 我们用 [.filename]#W32DRIVER.SYS# 和 [.filename]#W32DRIVER.INF# 来表示这些文件。

[NOTE]
====
不能在 FreeBSD/amd64 上使用 Windows(R)/i386 驱动程序。 必须使用 Windows(R)/amd64 驱动才能在其上正常工作。
====

接下来的步骤是将二进制形式的驱动程序组装成内核模块。 要完成这一任务， 需要以 `root` 用户的身份执行 man:ndisgen[8]：

[source,shell]
....
# ndisgen /path/to/W32DRIVER.INF /path/to/W32DRIVER.SYS
....

man:ndisgen[8] 是一个交互式的程序， 它会提示您输入所需的一些其他的额外信息； 这些工作完成之后， 它会在当前目录生成一个内核模块文件， 这个文件可以通过下述命令来加载：

[source,shell]
....
# kldload ./W32DRIVER_SYS.ko
....

除了刚刚生成的内核模块之外， 还必须加载 [.filename]#ndis.ko# 和 [.filename]#if_ndis.ko# 这两个内核模块， 在您加载需要 man:ndis[4] 的模块时， 通常系统会自动完成这一操作。 如果希望手工加载它们， 则可以使用下列命令：

[source,shell]
....
# kldload ndis
# kldload if_ndis
....

第一个命令会加载 NDIS 袖珍端口驱动封装模块， 而第二条命令则加载实际的网络接口。

现在请查看 man:dmesg[8] 来了解是否发生了错误。 如果一切正常， 您会看到类似下面的输出：

[source,shell]
....
ndis0: <Wireless-G PCI Adapter> mem 0xf4100000-0xf4101fff irq 3 at device 8.0 on pci1
ndis0: NDIS API version: 5.0
ndis0: Ethernet address: 0a:b1:2c:d3:4e:f5
ndis0: 11b rates: 1Mbps 2Mbps 5.5Mbps 11Mbps
ndis0: 11g rates: 6Mbps 9Mbps 12Mbps 18Mbps 36Mbps 48Mbps 54Mbps
....

这之后， 就可以像使用其它网络接口 (例如 [.filename]#dc0#) 一样来使用 [.filename]#ndis0# 设备了。

与任何其它模块一样， 您也可以配置系统， 令其在启动时自动加载 NDIS 模块。 首先， 将生成的模块 [.filename]#W32DRIVER_SYS.ko# 复制到 [.filename]#/boot/modules# 目录中。 接下来， 在 [.filename]#/boot/loader.conf# 中加入：

[.programlisting]
....
W32DRIVER_SYS_load="YES"
....

=== 配置网卡

现在正确的网卡驱动程序已经装载，那么就应该配置它了。 跟其他配置一样，网卡可以在安装时用  sysinstall  来配置。

要显示您系统上的网络接口的配置，输入下列命令：

[source,shell]
....
% ifconfig
dc0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500
        options=80008<VLAN_MTU,LINKSTATE>
        ether 00:a0:cc:da:da:da
        inet 192.168.1.3 netmask 0xffffff00 broadcast 192.168.1.255
        media: Ethernet autoselect (100baseTX <full-duplex>)
        status: active
dc1: flags=8802<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500
        options=80008<VLAN_MTU,LINKSTATE>
        ether 00:a0:cc:da:da:db
        inet 10.0.0.1 netmask 0xffffff00 broadcast 10.0.0.255
        media: Ethernet 10baseT/UTP
        status: no carrier
plip0: flags=8810<POINTOPOINT,SIMPLEX,MULTICAST> metric 0 mtu 1500
lo0: flags=8049<UP,LOOPBACK,RUNNING,MULTICAST> metric 0 mtu 16384
        options=3<RXCSUM,TXCSUM>
        inet6 fe80::1%lo0 prefixlen 64 scopeid 0x4
        inet6 ::1 prefixlen 128
        inet 127.0.0.1 netmask 0xff000000
        nd6 options=3<PERFORMNUD,ACCEPT_RTADV>
....

在这个例子中，显示出了下列设备：

* [.filename]#dc0#: 第一个以太网接口 
* [.filename]#dc1#: 第二个以太网接口 
* [.filename]#plip0#： 并口 (如果系统中有并口的话)
* [.filename]#lo0#: 回环设备

FreeBSD 使用内核引导时检测到的网卡驱动顺序来命名网卡。例如 [.filename]#sis2# 是系统中使用 man:sis[4] 驱动的第三块网卡。 

在这个例子中，[.filename]#dc0# 设备启用了。主要表现在：

. `UP` 表示这块网卡已经配置完成准备工作。
. 这块网卡有一个 Internet (`inet`) 地址 (这个例子中是 `192.168.1.3`)。
. 它有一个有效的子网掩码 (`netmask`； `0xffffff00` 等同于 `255.255.255.0`)。
. 它有一个有效的广播地址 (这个例子中是 `192.168.1.255`)。
. 网卡的 MAC (`ether`) 地址是 `00:a0:cc:da:da:da`
. 物理传输媒介模式处于自动选择状态 (`media: Ethernet autoselect (100baseTX <full-duplex>)`)。我们看到 [.filename]#dc1# 被配置成运行在 `10baseT/UTP` 模式下。 要了解驱动媒介类型的更多信息， 请查阅它们的使用手册。
. 连接状态 (`status`)是 `active`，也就是说连接信号被检测到了。对于 [.filename]#dc1#，我们看到 `status: no carrier`。 这通常是网线没有插好。

如果 man:ifconfig[8] 的输出显示了类似于：

[source,shell]
....
dc0: flags=8843<BROADCAST,SIMPLEX,MULTICAST> metric 0 mtu 1500
        options=80008<VLAN_MTU,LINKSTATE>
        ether 00:a0:cc:da:da:da
        media: Ethernet autoselect (100baseTX <full-duplex>)
        status: active
....

的信息，那么就是还没有配置网卡。

要配置网卡，您需要 `root` 权限。 网卡配置可以通过使用 man:ifconfig[8] 命令行方式来完成， 但是这样每次启动都要做一遍。放置网卡配置信息的文件是 [.filename]#/etc/rc.conf#。

用您自己喜欢的编辑器打开 [.filename]#/etc/rc.conf#。 并且您需要为每一块系统中存在的网卡添加一行， 在我们的例子中，添加如下几行：

[.programlisting]
....
ifconfig_dc0="inet 192.168.1.3 netmask 255.255.255.0"
ifconfig_dc1="inet 10.0.0.1 netmask 255.255.255.0 media 10baseT/UTP"
....

用自己正确的设备名和地址来替换例子中的 [.filename]#dc0#，[.filename]#dc1# 等内容。您应该应该查阅网卡驱动和 man:ifconfig[8] 的手册页来了解各选项，也要查看一下 man:rc.conf[5] 帮助页来了解 [.filename]#/etc/rc.conf# 的语法。

如果在安装的时候配置了网络，关于网卡的一些行可能已经存在了。 所以在添加新行前仔细检查一下 [.filename]#/etc/rc.conf#。

您也可能需要编辑 [.filename]#/etc/hosts# 来添加局域网中不同的机器名称和 IP 地址， 如果它们不在那里的话。 请查看联机手册 man:hosts[5] 和 [.filename]#/usr/shared/examples/etc/hosts# 以了解更多信息。

[NOTE]
====
如果计划通过这台机器访问 Internet， 您还需要手工配置默认网关和域名解析服务器：

[source,shell]
....
# echo 'defaultrouter="your_default_router"' >> /etc/rc.conf
# echo 'nameserver your_DNS_server' >> /etc/resolv.conf
....

====

=== 测试和调试

对 [.filename]#/etc/rc.conf# 做了必要的修改之后应该重启系统以应用对接口的修改， 并且确认系统重启后没有任何配置错误。 另外您也可以重启网络系统：

[source,shell]
....
# /etc/rc.d/netif restart
....

[NOTE]
====
如果在 [.filename]#/etc/rc.conf# 中配置了默认网关， 还需要运行下面的命令：

[source,shell]
....
# /etc/rc.d/routing restart
....

====

网络系统重启之后， 应测试网络接口。

==== 测试以太网卡

为了确认网卡被正确的配置了，在这里我们要做两件事情。首先， ping 自己的网络接口，接着 ping 局域网内的其他机器。

首先测试本地接口：

[source,shell]
....
% ping -c5 192.168.1.3
PING 192.168.1.3 (192.168.1.3): 56 data bytes
64 bytes from 192.168.1.3: icmp_seq=0 ttl=64 time=0.082 ms
64 bytes from 192.168.1.3: icmp_seq=1 ttl=64 time=0.074 ms
64 bytes from 192.168.1.3: icmp_seq=2 ttl=64 time=0.076 ms
64 bytes from 192.168.1.3: icmp_seq=3 ttl=64 time=0.108 ms
64 bytes from 192.168.1.3: icmp_seq=4 ttl=64 time=0.076 ms

--- 192.168.1.3 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.074/0.083/0.108/0.013 ms
....

现在我们应该 ping 局域网内的其他机器：

[source,shell]
....
% ping -c5 192.168.1.2
PING 192.168.1.2 (192.168.1.2): 56 data bytes
64 bytes from 192.168.1.2: icmp_seq=0 ttl=64 time=0.726 ms
64 bytes from 192.168.1.2: icmp_seq=1 ttl=64 time=0.766 ms
64 bytes from 192.168.1.2: icmp_seq=2 ttl=64 time=0.700 ms
64 bytes from 192.168.1.2: icmp_seq=3 ttl=64 time=0.747 ms
64 bytes from 192.168.1.2: icmp_seq=4 ttl=64 time=0.704 ms

--- 192.168.1.2 ping statistics ---
5 packets transmitted, 5 packets received, 0 packet loss
round-trip min/avg/max/stddev = 0.700/0.729/0.766/0.025 ms
....

您如果您设置了 [.filename]#/etc/hosts# 文件，也可以用机器名来替换 `192.168.1.2`。

==== 调试

调试硬件和软件配置一直是一件头痛的事情， 从最简单的开始可以减轻一些痛苦。 例如网线是否插好了？是否配置好了网络服务？防火墙配置正确吗？ 是否使用了被 FreeBSD 支持的网卡？ 在发送错误报告之前您应该查看一下硬件说明， 升级 FreeBSD 到最新的 STABLE 版本， 看一下邮件列表或者在 Internet 上搜索一下。

如果网卡工作了， 但性能低下，应该好好阅读一下 man:tuning[7] 联机手册。 您也可以检查一下网络配置， 不正确的设置会导致慢速的网络连接。

一些用户可能会在一些网卡上经历一到两次 `device timeouts`， 这通常是正常现象。 如果经常这样甚至引起麻烦， 则应确定一下它跟其他设备没有冲突。 仔细检查网线连接， 或者换一块网卡。

有时用户会看到少量 `watchdog timeout` 错误。 这种情况要做的第一件事就是检查线缆连接。 一些网卡需要支持总线控制的 PCI 插槽。 在一些老的主板上，只有一个 PCI 插槽支持 (一般是 slot 0)。 检查网卡和主板说明书来确定是不是这个问题。

`No route to host` 通常发生在如果系统不能发送一个路由到目的主机的包的时候。 这在没有指定默认路由或者网线没有插上时会发生。 检查 `netstat -rn` 的输出并确认有一个有效的路由能到达相应的主机。 如果没有，请查阅 crossref:advanced-networking[advanced-networking,高级网络应用]。

`ping: sendto: Permission denied` 错误信息经常由防火墙的配置错误引起。 如果 `ipfw` 在内核中启用了但是没有定义规则， 那么默认的规则就是拒绝所有通讯，甚至 ping 请求！ 查阅 crossref:firewalls[firewalls,防火墙] 以了解更多信息。

有时网卡性能低下或者低于平均水平， 这种情况最好把传输媒介模式从 `autoselect` 改变为正确的传输介质模式。 这通常对大多数硬件有用， 但可能不会解决所有人的问题。 接着，检查所有网络设置，并且阅读 man:tuning[7] 手册页。

[[configtuning-virtual-hosts]]
== 虚拟主机

FreeBSD 的一个很普通的用途是虚拟主机站点， 一个服务器虚拟成很多服务器一样提供网络服务。 这通过在一个接口上绑定多个网络地址来实现。

一个特定的网络接口有一个"真实"的地址， 也可能有一些"别名"地址。这些别名通常用 [.filename]#/etc/rc.conf# 中的记录来添加。

一个 [.filename]#fxp0# 的别名记录类似于：

[.programlisting]
....
ifconfig_fxp0_alias0="inet xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx"
....

记住别名记录必须从 `alias0` 开始并且按顺序递增(例如 `_alias1`、 `_alias2`)。 配置程序将会停止在第一个缺少的数字的地方。

f计算别名的子网掩码是很重要的，幸运的是它很简单。 对于一个接口来说，必须有一个描述子网掩码的地址。 任何在这个网段下的地址必须有一个全是 `1` 的子网掩码(通常表示为 `255.255.255.255` 或 `0xffffffff`。

举例来说， 假设使用 [.filename]#fxp0# 连接到两个网络， 分别是 `10.1.1.0`， 其子网掩码为 `255.255.255.0`， 以及 `202.0.75.16`， 其子网掩码为 `255.255.255.240`。 我们希望从 `10.1.1.1` 到 `10.1.1.5` 以及从 `202.0.75.17` 到 `202.0.75.20` 的地址能够互相访问。 如前所述， 只有两个网段中的第一个地址 (本例中， `10.0.1.1` 和 `202.0.75.17`) 应使用真实的子网掩码； 其余的 (`10.1.1.2` 到 `10.1.1.5` 以及 `202.0.75.18` 到 `202.0.75.20`) 则必须配置为使用 `255.255.255.255` 作为子网掩码。

下面是根据上述描述所进行的 [.filename]#/etc/rc.conf# 配置：

[.programlisting]
....
ifconfig_fxp0="inet 10.1.1.1 netmask 255.255.255.0"
ifconfig_fxp0_alias0="inet 10.1.1.2 netmask 255.255.255.255"
ifconfig_fxp0_alias1="inet 10.1.1.3 netmask 255.255.255.255"
ifconfig_fxp0_alias2="inet 10.1.1.4 netmask 255.255.255.255"
ifconfig_fxp0_alias3="inet 10.1.1.5 netmask 255.255.255.255"
ifconfig_fxp0_alias4="inet 202.0.75.17 netmask 255.255.255.240"
ifconfig_fxp0_alias5="inet 202.0.75.18 netmask 255.255.255.255"
ifconfig_fxp0_alias6="inet 202.0.75.19 netmask 255.255.255.255"
ifconfig_fxp0_alias7="inet 202.0.75.20 netmask 255.255.255.255"
....

[[configtuning-configfiles]]
== 配置文件

=== [.filename]#/etc# 布局

在配置信息中有很多的目录，这些包括：

[.informaltable]
[cols="1,1", frame="none"]
|===

|[.filename]#/etc#
|一般的系统配置信息。这儿的数据是与特定系统相关的。

|[.filename]#/etc/defaults#
|系统配置文件的默认版本。

|[.filename]#/etc/mail#
|额外的 man:sendmail[8] 配置信息，其他 MTA 配置文件。 

|[.filename]#/etc/ppp#
|用于用户级和内核级 ppp 程序的配置。 

|[.filename]#/etc/namedb#
|man:named[8] 数据的默认位置。通常 [.filename]#named.conf# 和区域文件存放在这里。

|[.filename]#/usr/local/etc#
|被安装的应用程序配置文件。可以参考每个应用程序的子目录。

|[.filename]#/usr/local/etc/rc.d#
|被安装程序的 启动/停止 脚本。

|[.filename]#/var/db#
|特定系统自动产生的数据库文件，像 package 数据库，位置数据库等等。
|===

=== 主机名

==== [.filename]#/etc/resolv.conf#

[.filename]#/etc/resolv.conf# 指示了 FreeBSD 如何访问域名系统(DNS)。

[.filename]#resolv.conf# 中最常见的记录是： 

[.informaltable]
[cols="1,1", frame="none"]
|===

|`nameserver`
|按顺序要查询的名字服务器的 IP 地址，最多三个。

|`search`
| 搜索机器名的列表。这通常由本地机器名的域决定。

|`domain`
|本地域名。
|===

一个典型的 [.filename]#resolv.conf# 文件：

[.programlisting]
....
search example.com
nameserver 147.11.1.11
nameserver 147.11.100.30
....

[NOTE]
====
只能使用一个 `search` 和 `domain` 选项。
====

如果您在使用 DHCP，man:dhclient[8] 经常使用从 DHCP 服务器接受来的信息重写 [.filename]#resolv.conf#。

==== [.filename]#/etc/hosts#

[.filename]#/etc/hosts# 是 Internet 早期使用的一个简单文本数据库。 它结合 DNS 和 NIS 提供名字到 IP 地址的映射。 通过局域网连接的机器可以用这个简单的命名方案来替代设置一个 man:named[8] 服务器。另外，[.filename]#/etc/hosts# 也可以提供一个 Internet 名称的本地纪录以减轻需要从外部查询带来的负担。

[.programlisting]
....
# $FreeBSD$
#
#
# Host Database
#
# This file should contain the addresses and aliases for local hosts that
# share this file.  Replace 'my.domain' below with the domainname of your
# machine.
#
# In the presence of the domain name service or NIS, this file may
# not be consulted at all; see /etc/nsswitch.conf for the resolution order.
#
#
::1			localhost localhost.my.domain
127.0.0.1		localhost localhost.my.domain
#
# Imaginary network.
#10.0.0.2		myname.my.domain myname
#10.0.0.3		myfriend.my.domain myfriend
#
# According to RFC 1918, you can use the following IP networks for
# private nets which will never be connected to the Internet:
#
#	10.0.0.0	-   10.255.255.255
#	172.16.0.0	-   172.31.255.255
#	192.168.0.0	-   192.168.255.255
#
# In case you want to be able to connect to the Internet, you need
# real official assigned numbers.  Do not try to invent your own network
# numbers but instead get one from your network provider (if any) or
# from your regional registry (ARIN, APNIC, LACNIC, RIPE NCC, or AfriNIC.)
#
....

[.filename]#/etc/hosts# 用简单的格式：

[.programlisting]
....
[Internet address] [official hostname] [alias1] [alias2] ...
....

例如：

[.programlisting]
....
10.0.0.1 myRealHostname.example.com myRealHostname foobar1 foobar2
....

参考 man:hosts[5] 以获得更多信息。

=== 日志文件配置

==== [.filename]#syslog.conf#

[.filename]#syslog.conf# 是 man:syslogd[8] 程序的配置文件。 它指出了的 `syslog` 哪种信息类型被存储在特定的日志文件中。

[.programlisting]
....
# $FreeBSD$
#
#       Spaces ARE valid field separators in this file. However,
#       other *nix-like systems still insist on using tabs as field
#       separators. If you are sharing this file between systems, you
#       may want to use only tabs as field separators here.
#       Consult the syslog.conf(5) manual page.
*.err;kern.debug;auth.notice;mail.crit          /dev/console
*.notice;kern.debug;lpr.info;mail.crit;news.err /var/log/messages
security.*                                      /var/log/security
mail.info                                       /var/log/maillog
lpr.info                                        /var/log/lpd-errs
cron.*                                          /var/log/cron
*.err                                           root
*.notice;news.err                               root
*.alert                                         root
*.emerg                                         *
# uncomment this to log all writes to /dev/console to /var/log/console.log
#console.info                                   /var/log/console.log
# uncomment this to enable logging of all log messages to /var/log/all.log
#*.*                                            /var/log/all.log
# uncomment this to enable logging to a remote log host named loghost
#*.*                                            @loghost
# uncomment these if you're running inn
# news.crit                                     /var/log/news/news.crit
# news.err                                      /var/log/news/news.err
# news.notice                                   /var/log/news/news.notice
!startslip
*.*                                             /var/log/slip.log
!ppp
*.*                                             /var/log/ppp.log
....

参考 man:syslog.conf[5] 手册页以获得更多信息

==== [.filename]#newsyslog.conf#

[.filename]#newsyslog.conf# 是一个通常用 man:cron[8] 计划运行的 man:newsyslog[8] 程序的配置文件。 man:newsyslog[8] 指出了什么时候日志文件需要打包或者重新整理。 比如 [.filename]#logfile# 被移动到 [.filename]#logfile.0#，[.filename]#logfile.0# 被移动到 [.filename]#logfile.1# 等等。另外，日志文件可以用 man:gzip[1] 来压缩，它们是这样的命名格式： [.filename]#logfile.0.gz#，[.filename]#logfile.1.gz# 等等。

[.filename]#newsyslog.conf# 指出了哪个日志文件要被管理，要保留多少和它们什么时候被创建。 日志文件可以在它们达到一定大小或者在特定的日期被重新整理。

[.programlisting]
....
# configuration file for newsyslog
# $FreeBSD$
#
# filename          [owner:group]    mode count size when [ZB] [/pid_file] [sig_num]
/var/log/cron                           600  3     100  *     Z
/var/log/amd.log                        644  7     100  *     Z
/var/log/kerberos.log                   644  7     100  *     Z
/var/log/lpd-errs                       644  7     100  *     Z
/var/log/maillog                        644  7     *    @T00  Z
/var/log/sendmail.st                    644  10    *    168   B
/var/log/messages                       644  5     100  *     Z
/var/log/all.log                        600  7     *    @T00  Z
/var/log/slip.log                       600  3     100  *     Z
/var/log/ppp.log                        600  3     100  *     Z
/var/log/security                       600  10    100  *     Z
/var/log/wtmp                           644  3     *    @01T05 B
/var/log/daily.log                      640  7     *    @T00  Z
/var/log/weekly.log                     640  5     1    $W6D0 Z
/var/log/monthly.log                    640  12    *    $M1D0 Z
/var/log/console.log                    640  5     100  *     Z
....

参考 man:newsyslog[8] 手册页以获得更多信息。

[[configtuning-sysctlconf]]
=== [.filename]#sysctl.conf#

[.filename]#sysctl.conf# 和 [.filename]#rc.conf# 这两个文件的风格很接近。 其中的配置均为 `变量=值` 这样的形式。 在这个文件中配置的值， 均会在系统进入多用户模式之后进行实际的修改操作。 需要注意的是， 并不是所有的变量都能够在多用户模式下修改。

如果希望关闭对收到致命的信号退出的进程进行记录， 并阻止普通用户看到其他用户的进程， 可以在 [.filename]#sysctl.conf# 中进行下列配置：

[.programlisting]
....
# 不记录由于致命信号导致的进程退出 (例如信号 11，访问越界)
kern.logsigexit=0

# 阻止用户看到以其他用户 UID 身份执行的进程。
security.bsd.see_other_uids=0
....

[[configtuning-sysctl]]
== 用 sysctl 进行调整

man:sysctl[8] 是一个允许您改变正在运行中的 FreeBSD 系统的接口。它包含一些 TCP/IP 堆栈和虚拟内存系统的高级选项， 这可以让有经验的管理员提高引人注目的系统性能。用 man:sysctl[8] 可以读取设置超过五百个系统变量。

基于这点，man:sysctl[8] 提供两个功能：读取和修改系统设置。

查看所有可读变量：

[source,shell]
....
% sysctl -a
....

读一个指定的变量，例如 `kern.maxproc`：

[source,shell]
....
% sysctl kern.maxproc
kern.maxproc: 1044
....

要设置一个指定的变量，直接用 _variable_=_value_ 这样的语法：

[source,shell]
....
# sysctl kern.maxfiles=5000
kern.maxfiles: 2088 -> 5000
....

sysctl 变量的设置通常是字符串、数字或者布尔型。 (布尔型用 `1` 来表示'yes'，用 `0` 来表示'no')。

如果你想在每次机器启动时自动设置某些变量， 可将它们加入到文件 [.filename]#/etc/sysctl.conf# 之中。更多信息，请参阅手册页 man:sysctl.conf[5] 及 <<configtuning-sysctlconf>>。

[[sysctl-readonly]]
=== 只读的 man:sysctl[8]

有时可能会需要修改某些只读的 man:sysctl[8] 的值。 尽管有时不得不这样做， 但只有通过(重新)启动才能达到这样的目的。

例如一些膝上型电脑的 man:cardbus[4] 设备不会探测内存范围，并且产生看似于这样的错误：

[source,shell]
....
cbb0: Could not map register memory
device_probe_and_attach: cbb0 attach returned 12
....

像上面的错误通常需要修改一些只读的 man:sysctl[8] 默认设置。要实现这点，用户可以在本地的 [.filename]#/boot/loader.conf.local# 里面放一个 man:sysctl[8] "OIDs"。那些设置定位在 [.filename]#/boot/defaults/loader.conf# 文件中。

修复上面的问题用户需要在刚才所说的文件中设置 `hw.pci.allow_unsupported_io_range=1`。现在 man:cardbus[4] 就会正常的工作了。

[[configtuning-disk]]
== 调整磁盘

=== Sysctl 变量

==== `vfs.vmiodirenable`

`vfs.vmiodirenable` sysctl 变量可以设置成0(关)或者1(开)；默认是1。 这个变量控制目录是否被系统缓存。大多数目录是小的， 在系统中只使用单个片断(典型的是1K)并且在缓存中使用的更小 (典型的是512字节)。当这个变量设置为关闭 (`0`) 时， 缓存器仅仅缓存固定数量的目录，即使您有很大的内存。 而将其开启 (设置为1) 时， 则允许缓存器用 VM 页面缓存来缓存这些目录，让所有可用内存来缓存目录。 不利的是最小的用来缓存目录的核心内存是大于 512 字节的物理页面大小(通常是 4k)。 我们建议如果您在运行任何操作大量文件的程序时保持这个选项打开的默认值。 这些服务包括 web 缓存，大容量邮件系统和新闻系统。 尽管可能会浪费一些内存，但打开这个选项通常不会降低性能。 但还是应该检验一下。

==== `vfs.write_behind`

`vfs.write_behind` sysctl 变量默认是 `1` (打开)。 它告诉文件系统簇被收集满的时候把内容写进介质， 典型的是在写入大的连续的文件时。 主要的想法是， 如果可能对 I/O 性能会产生负面影响时， 应尽量避免让缓冲缓存被未同步缓冲区充满。 然而它可能降低处理速度并且在某些情况下您可能想要关闭它。

==== `vfs.hirunningspace`

`vfs.hirunningspace` sysctl 变量决定了在任何给定情况下， 有多少写 I/O 被排进队列以给系统的磁盘控制器。 默认值一般是足够的，但是对有很多磁盘的机器来说您可能需要把它设置成 4M 或 5M。注意这个设置成很高的值(超过缓存器的写极限)会导致坏的性能。 不要盲目的把它设置太高！高的数值会导致同时发生的读操作的迟延。

sysctl 中还有许多与 buffer cache 和 VM页面 cache 有关的值， 一般不推荐修改它们。 虚拟内存系统已经能够很好地进行自动调整了。

==== `vm.swap_idle_enabled`

`vm.swap_idle_enabled` sysctl 变量在有很多用户进入、离开系统和有很多空闲进程的大的多用户系统中很有用。 这些系统注重在空闲的内存中间产生连续压力的处理。通过 `vm.swap_idle_threshold1` 和 `vm.swap_idle_threshold2` 打开这个特性并且调整交换滞后 (在空闲时)允许您降低内存页中空闲进程的优先权，从而比正常的出页 (pageout)算法更快。这给出页守护进程带来了帮助。 除非您需要否则不要把这个选项打开，因为您所权衡的是更快地进入内存， 因而它会吃掉更多的交换和磁盘带宽。在小的系统上它会有决定性的效果， 但是在大的系统上它已经做了合适的页面调度这个选项允许 VM 系统容易的让全部的进程进出内存。

==== `hw.ata.wc`

FreeBSD 4.3 中默认将 IDE 的写缓存关掉了。 这会降低到 IDE 磁盘用于写入操作的带宽， 但我们认为这有助于避免硬盘厂商所引入的， 可能引致严重的数据不一致问题。 这类问题实际上是由于 IDE 硬盘就写操作完成这件事的不诚实导致的。 当启用了 IDE 写入缓存时， IDE 硬盘驱动器不但不会按顺序将数据写到盘上， 而且当磁盘承受重载时， 它甚至会自作主张地对推迟某些块的实际写操作。 这样一来， 在系统发生崩溃或掉电时， 就会导致严重的文件系统损坏。 基于这些考虑， 我们将 FreeBSD 的默认配置改成了更为安全的禁用 IDE 写入缓存。 然而不幸的是， 这样做导致了性能的大幅降低， 因此在后来的发行版中这个配置又改为默认启用了。 您可以通过观察 `hw.ata.wc` sysctl 变量， 来确认您的系统中所采用的默认值。 如果 IDE 写缓存被禁用， 您可以通过将内核变量设置为 1 来启用它。 这一操作必须在启动时通过 boot loader 来完成。 在内核启动之后尝试这么做是没有任何作用的。

要了解更多的信息，请查阅 man:ata[4]。

==== `SCSI_DELAY` (`kern.cam.scsi_delay`)

`SCSI_DELAY` 内核配置会缩短系统启动时间。 默认值在系统启动过程中有 `15` 秒的迟延时间， 这是一个足够多且可靠的值。把它减少到 `5` 通常也能工作(特别是现代的驱动器)。 您可以在系统引导时调整引导加载器变量 `kern.cam.scsi_delay` 来改变它。 需要注意的是， 此处使用的单位是 _毫秒_ 而 _不_ 是 _秒_ 。

[[soft-updates]]
=== Soft Updates

man:tunefs[8] 程序能够用来很好的调整文件系统。 这个程序有很多不同的选项，但是现在只介绍 Soft Updates 的打开和关闭，这样做：

[source,shell]
....
# tunefs -n enable /filesystem
# tunefs -n disable /filesystem
....

在文件系统被挂载之后不能用 man:tunefs[8] 来修改。打开 Soft Updates 的最佳时机是在单用户模式下任何分区被挂载前。

Soft Updates 极大地改善了元数据修改的性能， 主要是文件创建和删除，通过内存缓存。我们建议您在所有的文件系统上使用 Soft Updates。应该知道 Soft Updates 的两点：首先， Soft Updates 保证了崩溃后的文件系统完整性，但是很可能有几秒钟 (甚至一分钟！) 之前的数据没有写到物理磁盘。如果您的系统崩溃了您可能会丢失很多工作。 第二，SoftUpdates 推迟文件系统块的释放时间。如果在文件系统 (例如根文件系统)快满了的情况下对系统进行大规模的升级比如 `make installworld`， 可能会引起磁盘空间不足从而造成升级失败。 

==== Soft Updates 的详细资料

有两种传统的方法来把文件系统的元数据 (meta-data) 写入磁盘。 (Meta-data更新是更新类似 inodes 或者目录这些没有内容的数据)

从前，默认方法是同步更新这些元数据(meta-data)。 如果一个目录改变了，系统在真正写到磁盘之前一直等待。 文件数据缓存(文件内容)在这之后以非同步形式写入。 这么做有利的一点是操作安全。如果更新时发生错误，元数据(meta-data) 一直处于完整状态。文件要不就被完整的创建要不根本就不创建。 如果崩溃时找不到文件的数据块，man:fsck[8] 可以找到并且依靠把文件大小设置为 0 来修复文件系统。 另外，这么做既清楚又简单。缺点是元数据(meta-data)更新很慢。例如 `rm -r` 命令，依次触及目录下的所有文件， 但是每个目录的改变(删除一个文件)都要同步写入磁盘。 这包含它自己更新目录，inode 表和可能对文件分散的块的更新。 同样问题出现大的文件操作上(比如 `tar -x`)。

第二种方法是非同步元数据更新。这是 Linux/ext2fs 和 *BSD ufs 的 `mount -o async` 默认的方法。所有元数据更新也是通过缓存。 也就是它们会混合在文件内容数据更新中。 这个方法的优点是不需要等待每个元数据更新都写到磁盘上， 所以所有引起元数据更新大的操作比同步方式更快。同样， 这个方法也是清楚且简单的，所以代码中的漏洞风险很小。 缺点是不能保证文件系统的状态一致性。如果更新大量元数据时失败 (例如掉电或者按了重启按钮)，文件系统会处在不可预知的状态。 系统再启动时没有机会检查文件系统的状态；inode 表更新的时候可能文件的数据块已经写入磁盘了但是相关联的目录没有，却不能用 `fsck` 命令来清理(因为磁盘上没有所需要的信息)。 如果文件系统修复后损坏了，唯一的选择是使用 man:newfs[8] 并且从备份中恢复它。 

这个问题通常的解决办法是使用 _dirty region logging_ 或者 _journaling_ 尽管它不是一贯的被使用并且有时候应用到其他的事务纪录中更好。 这种方法元数据更新依然同步写入，但是只写到磁盘的一个小区域。 过后他们将会被移动到正确的位置。因为纪录区很小， 磁盘上接近的区域磁头不需要移动很长的距离，所以这些比写同步快一些。 另外这个方法的复杂性有限，所以出现错误的机会也很少。缺点是元数据要写两次 (一次写到纪录区域，一次写到正确的区域)。正常情况下， 悲观的性能可能会发生。从另一方面来讲， 崩溃的时候所有未发生的元数据操作可以很快的在系统启动之后从记录中恢复过来。 

Kirk McKusick，伯克利 FFS 的开发者，用 Soft Updates 解决了这个问题：元数据更新保存在内存中并且按照排列的顺序写入到磁盘 ("有序的元数据更新")。这样的结果是，在繁重的元数据操作中， 如果先前的更新还在内存中没有被写进磁盘，后来的更新就会捕捉到。 所以所有的目录操作在写进磁盘的时候首先在内存中执行 (数据块按照它们的位置来排列，所以它们不会在元数据前被写入)。 如果系统崩溃了这将导致一个固定的 "日志回朔"： 所有不知如何写入磁盘的操作都像没有发生过一样。文件系统的一致性保持在 30 到 60 秒之前。它保证了所有正在使用的资源被标记例如块和 inodes。崩溃之后， 唯一的资源分配错误是一个实际是"空闲"的资源的资源被标记为"使用"。 man:fsck[8] 可以认出这种情况并且释放不再使用的资源。它对于忽略崩溃后用 `mount -f` 强制挂上的文件系统的错误状态是安全的。 为了释放可能没有使用的资源，man:fsck[8] 需要在过后的时间运行。一个主意是用 _后台 fsck_：系统启动的时候只有一个文件系统的 _快照_ 被记录下来。`fsck` 可以在过后运行。所有文件系统可以在"有错误"的时候被挂接， 所以系统可以在多用户模式下启动。接着，后台 `fsck` 可以在所有文件系统需要的时候启动来释放可能没有使用的资源。 (尽管这样，不用 Soft Updates 的文件系统依然需要通常的 `fsck`。) 

f它的优点是元数据操作几乎跟非同步一样快 (也就是比需要两次元数据写操作的 _logging_ 更快)。缺点是代码的复杂性(意味着对于丢失用户敏感数据有更多的风险) 和高的内存使用量。另外它有些特点需要知道。崩溃之后， 文件系统状态会"落后"一些。同步的方法用 `fsck` 后在一些地方可能产生一些零字节的文件， 这些文件在用 Soft Updates 文件系统之后不会存在， 因为元数据和文件内容根本没有写进磁盘(可能发生在运行 `rm` 之后)。这可能在文件系统上安装大量数据时候引发问题， 没有足够的剩余空间来两次存储所有文件。

[[configtuning-kernel-limits]]
== 调整内核限制

[[file-process-limits]]
=== 文件/进程限制

[[kern-maxfiles]]
==== `kern.maxfiles`

`kern.maxfiles` 可以根据系统的需要适当增减。 这个变量用于指定在系统中允许的文件描述符的最大数量。 当文件描述符表满的时候， `file: table is full` 会在系统消息缓冲区中反复出现， 您可以使用 `dmesg` 命令来观察这一现象。

每个打开的文件、 套接字和管道， 都会占用一个文件描述符。 在大型生产服务器上， 可能会轻易地用掉数千个文件描述符， 具体用量取决于服务的类型和并行启动的服务数量。

在早期版本的 FreeBSD 中， `kern.maxfiles` 的默认值， 是根据您内核配置文件中的 `maxusers` 选项计算的。 `kern.maxfiles` 这个数值， 会随 `maxusers` 成比例地增减。 当编译定制的内核时， 按照您系统的用途来修改这个值是个好主意。 这个数字同时还决定内核的许多预设的限制值。 有时， 尽管并不会真的有 256 个用户同时连接一台生产服务器， 但对于高负载的 web 服务器而言， 却可能需要与之类似的资源。

变量 `kern.maxusers` 会在系统启动时， 根据可用内存的尺寸进行计算， 在内核开始运行之后， 可以通过只读的 `kern.maxusers` sysctl 变量值来进行观察。 有些情况下， 可能会希望使用更大或更小一些的 `kern.maxusers`， 它可以以加载器变量的形式进行配置； 类似 64、 128 和 256 这样的值都并不罕见。 我们不推荐使用超过 256 的值， 除非您需要巨量的文件描述符； 根据 `kern.maxusers` 推算默认值的那些变量， 一般都可以在引导甚至运行时通过 [.filename]#/boot/loader.conf# (请参见 man:loader.conf[5] 联机手册或 [.filename]#/boot/defaults/loader.conf# 文件来获得相关的指导) 或这篇文档的其余部分所介绍的方式来调整。

在较早的版本中， 如果您明确地将 `maxusers` 设置为 `0`， 则系统会自动地根据硬件配置来确定这个值。。 在 FreeBSD 5.X 和更高版本中， `maxusers` 如果不指定的话， 就会取默认值 `0`。 如果希望自行管理 `maxusers`， 则应配置一个不低于 4 的值， 特别是使用 X Window System 或编译软件的时候。 这样做的原因是， `maxusers` 所决定的一个最为重要的表的尺寸会影响最大进程数， 这个数值将是 `20 + 16 * maxusers`。 因此如果将 `maxusers` 设置为 1， 您就只能同时运行 36 个进程， 这还包括了 18 个左右的系统引导时启动的进程， 以及 15 个左右的， 在您启动 X Window System 时所引发的进程。 即使是简单的任务， 如阅读联机手册， 也需要启动多至九个的进程， 用以过滤、 解压缩， 并显示它。 将 `maxusers` 设为 64 将允许您同时执行最多 1044 个进程， 这几乎足以满足任何需要了。 不过， 如果您看在启动其它程序， 或运行用以支持大量用户的服务 (例如 `ftp.FreeBSD.org`) 时， 看到令人担忧的  错误， 就应该提高这一数值， 并重新联编内核。

[NOTE]
====
`maxusers` 并 _不能_ 限制实际能够登录到您系统上来的用户的数量。 它的主要作用是根据您可能支持的用户数量来为一系列系统数据表设置合理的尺寸， 以便提供支持他们所需运行的进程资源。
====

==== `kern.ipc.somaxconn`

`kern.ipc.somaxconn` sysctl 变量 限制了接收新 TCP 连接侦听队列的大小。对于一个经常处理新连接的高负载 web服务环境来说，默认的 `128` 太小了。 大多数环境这个值建议增加到 `1024` 或者更多。 服务进程会自己限制侦听队列的大小(例如 man:sendmail[8] 或者 Apache)， 常常在它们的配置文件中有设置队列大小的选项。 大的侦听队列对防止拒绝服务  攻击也会有所帮助。

[[nmbclusters]]
=== 网络限制

`NMBCLUSTERS` 内核配置选项指出了系统可用的网络Mbuf的数量。 一个高流量的服务器使用一个小数目的网络缓存会影响 FreeBSD 的性能。 每个 cluster 可能需要2K内存，所以一个1024的值需要在内核中给网络缓存保留2M内存。 可以用简单的方法计算出来需要多少网络缓存。 如果您有一个同时发生1000个以上连接的web服务器， 并且每个连接用掉16K接收和发送缓存， 就需要大概32M网络缓存来确保web服务器的工作。 一个好的简单计算方法是乘以2，所以2x32Mb/2Kb=64MB/2kb=32768。 我们建议在有大量内存的机器上把这个值设置在4096到32768之间。 没有必要把它设置成任意太高的值，它会在启动时引起崩溃。 man:netstat[1] 的 `-m` 选项可以用来观察网络cluster使用情况。

`kern.ipc.nmbclusters` 可以用来在启动时刻调节这个。 仅仅在旧版本的 FreeBSD 需要使用 `NMBCLUSTERS` man:config[8] 选项。

经常使用 man:sendfile[2] 系统调用的繁忙的服务器， 有必要通过 `NSFBUFS` 内核选项或者在 [.filename]#/boot/loader.conf# (查看 man:loader[8] 以获得更多细节) 中设置它的值来调节 man:sendfile[2] 缓存数量。 这个参数需要调节的普通原因是在进程中看到 `sfbufa` 状态。sysctl `kern.ipc.nsfbufs` 变量在内核配置变量中是只读的。 这个参数是由 `kern.maxusers` 决定的，然而它可能有必要因此而调整。

[IMPORTANT]
====
即使一个套接字被标记成非阻塞，在这个非阻塞的套接字上呼叫 man:sendfile[2] 可能导致 man:sendfile[2] 呼叫阻塞直到有足够的 `struct sf_buf` 可用。 
====

==== `net.inet.ip.portrange.*`

`net.inet.ip.portrange.*` sysctl 变量自动的控制绑定在 TCP 和 UDP 套接字上的端口范围。 这里有三个范围：一个低端范围，一个默认范围和一个高端范围。 大多数网络程序分别使用由 `net.inet.ip.portrange.first` 和 `net.inet.ip.portrange.last` 控制的从 1024 到 5000 的默认范围。端口范围用作对外连接，并且某些情况可能用完系统的端口， 这经常发生在运行一个高负荷 web 代理服务器的时候。 这个端口范围不是用来限制主要的例如 web 服务器进入连接或者有固定端口例如邮件传递对外连接的。 有时您可能用完了端口，那就建议适当的增加 `net.inet.ip.portrange.last`。 `10000`、`20000` 或者 `30000` 可能是适当的值。 更改端口范围的时候也要考虑到防火墙。 一些防火墙会阻止端口的大部分范围 (通常是低范围的端口)并且用高端口进行对外连接(-)。 基于这个问题建议不要把 `net.inet.ip.portrange.first` 设的太小。

==== TCP 带宽迟延(Bandwidth Delay Product)

限制 TCP 带宽延迟积和 NetBSD 的 TCP/Vegas 类似。 它可以通过将 sysctl 变量 `net.inet.tcp.inflight.enable` 设置成 `1` 来启用。 系统将尝试计算每一个连接的带宽延迟积， 并将排队的数据量限制在恰好能保持最优吞吐量的水平上。

这一特性在您的服务器同时向使用普通调制解调器， 千兆以太网， 乃至更高速度的光与网络连接 (或其他带宽延迟积很大的连接) 的时候尤为重要， 特别是当您同时使用滑动窗缩放， 或使用了大的发送窗口的时候。 如果启用了这个选项， 您还应该把 `net.inet.tcp.inflight.debug` 设置为 `0` (禁用调试)， 对于生产环境而言， 将 `net.inet.tcp.inflight.min` 设置成至少 `6144` 会很有好处。 然而， 需要注意的是， 这个值设置过大事实上相当于禁用了连接带宽延迟积限制功能。 这个限制特性减少了在路由和交换包队列的堵塞数据数量， 也减少了在本地主机接口队列阻塞的数据的数量。在少数的等候队列中、 交互式连接，尤其是通过慢速的调制解调器，也能用低的 __往返时间__操作。但是，注意这只影响到数据发送 (上载/服务端)。对数据接收(下载)没有效果。 

调整 `net.inet.tcp.inflight.stab` 是 _不_ 推荐的。 这个参数的默认值是 20， 表示把 2 个最大包加入到带宽延迟积窗口的计算中。 额外的窗口似的算法更为稳定， 并改善对于多变网络环境的相应能力， 但也会导致慢速连接下的 ping 时间增长 (尽管还是会比没有使用 inflight 算法低许多)。 对于这些情形， 您可能会希望把这个参数减少到 15， 10， 或 5； 并可能因此而不得不减少 `net.inet.tcp.inflight.min` (比如说， 3500) 来得到希望的效果。 减少这些参数的值， 只应作为最后不得已时的手段来使用。

=== 虚拟内存

==== `kern.maxvnodes`

vnode 是对文件或目录的一种内部表达。 因此， 增加可以被操作系统利用的 vnode 数量将降低磁盘的 I/O。 一般而言， 这是由操作系统自行完成的， 也不需要加以修改。 但在某些时候磁盘 I/O 会成为瓶颈， 而系统的 vnode 不足， 则这一配置应被增加。 此时需要考虑是非活跃和空闲内存的数量。

要查看当前在用的 vnode 数量：

[source,shell]
....
# sysctl vfs.numvnodes
vfs.numvnodes: 91349
....

要查看最大可用的 vnode 数量：

[source,shell]
....
# sysctl kern.maxvnodes
kern.maxvnodes: 100000
....

如果当前的 vnode 用量接近最大值， 则将 `kern.maxvnodes` 值增大 1,000 可能是个好主意。 您应继续查看 `vfs.numvnodes` 的数值， 如果它再次攀升到接近最大值的程度， 仍需继续提高 `kern.maxvnodes`。 在 man:top[1] 中显示的内存用量应有显著变化， 更多内存会处于活跃 (active) 状态。

[[adding-swap-space]]
== 添加交换空间

不管您计划得如何好，有时候系统并不像您所期待的那样运行。 如果您发现需要更多的交换空间，添加它很简单。 有三种方法增加交换空间：添加一块新的硬盘驱动器、通过 NFS 使用交换空间和在一个现有的分区上创建一个交换文件。

要了解关于如何加密交换区， 相关配置， 以及为什么要这样做， 请参阅手册的 crossref:disks[swap-encrypting,对交换区进行加密]。

[[new-drive-swap]]
=== 在新的硬盘驱动器上使用交换空间

这是添加交换空间最好的方法， 当然为了达到这个目的需要添加一块硬盘。 毕竟您总是可以使用另一块磁盘。如果能这么做， 重新阅读一下手册中关于交换空间的 <<configtuning-initial>> 来了解如何最优地安排交换空间。

[[nfs-swap]]
=== 通过 NFS 交换

除非没有可以用作交换空间的本地硬盘时， 否则不推荐您使用 NFS 来作为交换空间使用。 NFS 交换会受到可用网络带宽限制并且增加 NFS 服务器的负担。

[[create-swapfile]]
=== 交换文件

您可以创建一个指定大小的文件用来当作交换文件。 在我们的例子中我们将会使用叫做 [.filename]#/usr/swap0# 的 64MB 大小的文件。当然您也可以使用任何您所希望的名字。

.在 FreeBSD 中创建交换文件
[example]
====
. 确认您的内核配置包含虚拟磁盘(Memory disk)驱动 (man:md[4])。它在 [.filename]#GENERIC# 内核中是默认的。
+
[.programlisting]
....
device   md   # Memory "disks"
....
+
. 创建一个交换文件([.filename]#/usr/swap0#)：
+
[source,shell]
....
# dd if=/dev/zero of=/usr/swap0 bs=1024k count=64
....
+
. 赋予它([.filename]#/usr/swap0#)一个适当的权限：
+
[source,shell]
....
# chmod 0600 /usr/swap0
....
+
. 在 [.filename]#/etc/rc.conf# 中启用交换文件：
+
[.programlisting]
....
swapfile="/usr/swap0"   # Set to name of swapfile if aux swapfile desired.
....
+
. 通过重新启动机器或下面的命令使交换文件立刻生效：
+
[source,shell]
....
# mdconfig -a -t vnode -f /usr/swap0 -u 0 && swapon /dev/md0
....

====

[[acpi-overview]]
== 电源和资源管理

BIOS 接口管理，例如__可插拔 BIOS (PNPBIOS)__或者__高级电源管理(APM)__ 等等。电源和资源管理是现代操作系统的关键组成部分。 例如您可能当系统温度过高的时候让您的操作系统能监视到 (并且可能提醒您)。 

以有效的方式利用硬件资源是非常重要的。 在引入 ACPI 之前， 管理电源使用和系统散热对操作系统是很困难的。 硬件由 BIOS 进行管理， 因而用户对电源管理配置的控制和查看都比较困难。 一些系统通过 _高级电源管理 (APM)_ 提供了有限的配置能力。 电源和资源管理是现代操作系统的一个关键组件。 例如， 您可能希望操作系统监视系统的一些限制， 例如系统的温度是否超出了预期的增长速度 (并在需要时发出警告)。

在 FreeBSD 使用手册的这一章节，我们将提供 ACPI 全面的信息。 参考资料会在末尾给出。

[[acpi-intro]]
=== 什么是 ACPI？

高级配置和电源接口 (ACPI) 是一个业界标准的硬件资源和电源管理接口 (因此而得名) 。它是 _操作系统控制的配置和电源管理(Operating System-directed configuration and Power Management)_，也就是说， 它给操作系统(OS)提供了更多的控制和弹性。 在引入 ACPI 之前， 现代操作系统使得目前即插即用接口的局限性更加 "凸现" 出来。 ACPI 是 APM(高级电源管理) 的直接继承者。

[[acpi-old-spec]]
=== 高级电源管理 (APM) 的缺点

_高级电源管理 (APM)_ 是一种基于系统目前的活动控制其电源使用的机制。 APM BIOS 由 (系统的) 制造商提供， 并且是硬件平台专属的。 在 OS 中的 APM 驱动作为中介来访问 _APM 软件接口_， 从而实现对电源使用的管理。 在 2000 年或更早的时期生产的计算机系统， 仍需要使用 APM。

APM 有四个主要的问题。 首先， 电源管理是通过 (制造商专属的) BIOS 实现的， 而 OS 则完全不了解其细节。 例如， 用户在 APM BIOS 中设置了硬盘驱动器的空闲等待数值， 当超过这一空闲时间的限制时， 它 (BIOS) 将会减慢硬盘驱动器的速度， 而不会征求 OS 的同意。 第二， APM 逻辑是嵌入 BIOS 的， 因此它是在 OS 的控制之外运转的。 这意味着用户只能通过通过刷新他们 ROM 中的 APM BIOS 才能够解决某些问题； 而这是一个很危险的操作， 因为它可能使系统进入一个无法恢复的状态。 第三， APM 是一种制造商专属的技术， 也就是说有很多第三方的 (重复的工作) 以及 bugs， 如果在一个制造商的 BIOS 中有， 也未必会在其他的产品中解决。 最后但绝不是最小的问题， APM BIOS 没有为实现复杂的电源策略提供足够的余地， 也无法实现能够非常适合具体机器的策略。

_即插即用 BIOS (PNPBIOS)_ 在很多时候都是不可靠的。 PNPBIOS 是 16-位 的技术， 因此 OS 不得不使用 16-位 模拟才能够与 PNPBIOS 的方法 "接口"。

FreeBSD APM 驱动在 man:apm[4] 手册页中有描述。

[[acpi-config]]
=== 配置 ACPI

默认情况下， [.filename]#acpi.ko# 驱动， 会在系统引导时由 man:loader[8] 加载， 而 _不应_ 直接联编进内核。 这样做的原因是模块操作起来更方便， 例如， 无需重新联编内核就可以切换到另一个 [.filename]#acpi.ko# 版本。 这样可以让测试变得更简单一些。 另一个原因是， 许多时候在启动已经启动之后再启动 ACPI 可能会有些问题。 如果您遇到了问题， 可以全面禁用 ACPI。 这个驱动不应， 目前也无法卸载， 因为系统总线通过它与许多不同的硬件进行交互。 ACPI 可以通过在 [.filename]#/boot/loader.conf# 中配置或在 man:loader[8] 提示符处配置 `hint.acpi.0.disabled="1"` 来禁用。 

[NOTE]
====
ACPI 和 APM 不能共存， 相反， 它们应分开使用。 后加载的驱动如果发现系统中已经执行了其中的一个， 便会停止执行。
====

ACPI 可以用来让系统进入休眠模式， 方法是使用 man:acpiconf[8] 的 `-s` 参数， 加上一个 `1-5` 的数字。 多数用户会希望使用 `1` 或 `3` (挂起到 RAM)。 而 `5` 则会让系统执行与下列命令效果类似的软关机：

[source,shell]
....
# halt -p
....

除此之外， 还有一些通过 man:sysctl[8] 提供的选项。 请参见联机手册 man:acpi[4] 和 man:acpiconf[8] 以获得更多信息。 

[[ACPI-debug]]
== 使用和调试 FreeBSD ACPI

ACPI 是一种全新的发现设备、 管理电源使用、 以及提供过去由 BIOS 管理的访问不同硬件的标准化方法。 让 ACPI 在各种系统上都能正确使用的工作一直在进行， 但许多主板的 _ACPI 机器语言_ (AML) 字节代码中的 bug， FreeBSD 的内核中子系统设计的不完善， 以及 Intel(R) ACPI-CA 解释器中的 bug 仍然不时会出现。

这份文档期望能够帮助您协助 FreeBSD ACPI 的维护人员来找到您所观察到的问题的根源， 并通过调试找到其解决方法。 感谢您阅读这份文档， 我们也希望能够解决您的系统上的问题。

[[ACPI-submitdebug]]
=== 提交调试信息

[NOTE]
====
在提交问题之前， 请确认您已经在运行最新的 BIOS 版本， 此外， 也包括嵌入式控制器的固件版本。
====

如果您希望提交一个问题， 请确保将下述信息发到 link:mailto:freebsd-acpi@FreeBSD.org[freebsd-acpi@FreeBSD.org]:

* 问题行为的描述， 包括系统类型、型号，以及任何触发问题的相关信息。 另外， 请注意尽可能准确地描述这一问题是否对您是陌生的。
* 在 "boot -v" 之后得到的 man:dmesg[8] 输出， 以及任何在重现 bug 时出现的错误信息。
* 在禁用了 ACPI 之后的 "boot -v" 的 man:dmesg[8] 输出， 如果您发现禁用 ACPI 能够帮助消除问题。
* 来自 ``fsysctl hw.acpi``的输出。 这也是找到您的系统所提供的功能的一种好办法。
* 能够得到您的 _ACPI Source Language_ (ASL) 的 URL。 _不要_ 把 ASL 直接发到邮件列表中， 因为它们可能非常大。 为了得到 ASL 您可以运行这个命令：
+
[source,shell]
....
# acpidump -dt > name-system.asl
....
+ 
(把 _name_ 改为您的登录名， 并把 _system_ 改为您的硬件制造商及其型号。 例如： [.filename]#njl-FooCo6000.asl#)

许多开发者也会订阅 {freebsd-current} 但还是请发到 {freebsd-acpi} 这样它会被更多人看到。 请耐心等待， 因为我们都有全职的其他工作。 如果您的 bug 不是显而易见的， 我们可能会要求您通过 man:send-pr[1] 来提交一个 PR。 在输入 PR 时，请将同样的信息包含进去。 这将帮助我们来追踪和解决问题。 不要在给 {freebsd-acpi} 写信之前发送 PR 因为我们把它当作已知文体的备忘录而不是报告机制。 您的问题很可能已经被其他人报告过了。

[[ACPI-background]]
=== 背景

ACPI 存在于采用 ia32 (x86)、 ia64 (安腾)、 以及 amd64 (AMD) 架构的所有现代计算机上。 完整的标准具有大量的各式功能， 包括 CPU 性能管理、 电源控制、 温度监控、 电池系统、 嵌入式控制器以及总线枚举。 绝大多数系统实现比完整标准的功能要少一些。 例如， 桌面系统通常只实现总线枚举部分， 而笔记本则通常支持降温和电源管理功能。 笔记本通常还提供休眠和唤醒支持， 并提供与此适应的复杂功能。

符合 ACPI 的系统中有许多组件。 BIOS 和芯片组制造商提供一些固定的表 (例如， FADT) 在存储器中， 以提供类似 APIC 映射 (用于 SMP)、 配置寄存器、 以及简单的配置值等等。 另外， 一个字节代码 (bytecode) 表 (__系统区别描述表__DSDT) 则提供了通过树状命名空间来指定设备及其功能的方法。

ACPI 驱动必须要处理固定表， 实现字节码解释器， 并修改驱动程序和内核， 以接受来自 ACPI 子系统的信息。 对于 FreeBSD， Intel(R) 提供了一个解释器 (ACPI-CA)， 它在 Linux 和 NetBSD 也可以使用。 ACPI-CA 源代码可以在 [.filename]#src/sys/contrib/dev/acpica# 找到。 用于在 FreeBSD 中允许 ACPI-CA 正确运转的代码则在 [.filename]#src/sys/dev/acpica/Osd#。 最后， 用于实现 ACPI 设备的驱动可以在 [.filename]#src/sys/dev/acpica# 找到。

[[ACPI-comprob]]
=== 常见问题

要让 ACPI 正常工作， 它的每一部分都必须工作正常。 下面是一些常见的问题， 按照出新的频繁程度排序， 并给出了一些绕过或修正它们的方法。

==== 鼠标问题

某些时候， 唤醒操作会导致鼠标不再正常工作。 已知的绕过这一问题的方法， 是在 [.filename]#/boot/loader.conf# 文件中添加 `hint.psm.0.flags="0x3000"` 设置。 如果这样做不能解决问题， 请考虑按前面介绍的方法提交问题报告。

==== 休眠/唤醒

ACPI 提供了三种休眠到 RAM (STR) 的状态， `S1`-`S3`， 以及一个休眠到磁盘的状态 (`STD`)， 称作 `S4`。 `S5` 是 "软关机" 同时也是系统接好电源但没有开机时的正常状态。 `S4` 实际上可以用两种不同的方法来实现。 ``S4``BIOS 是一种由 BIOS 辅助的挂起到磁盘方法， 而 ``S4``OS 则是完全由操作系统实现的。

可以使用 `sysctl hw.acpi` 来查看与休眠有关的项目。 这里是我的 Thinkpad 上得到的结果。

[source,shell]
....
hw.acpi.supported_sleep_state: S3 S4 S5
hw.acpi.s4bios: 0
....

这表示我可以使用 `acpiconf -s` 来测试 `S3`， ``S4``OS， 以及 `S5`。 如果 `s4bios` 是一 (`1`)， 则可以使用 ``S4``BIOS 来代替 ``S4``OS。

当测试休眠/唤醒时， 从 `S1` 开始， 如果它被支持的话。 这个状态是最可能正常工作的状态， 因为它不需要太多的驱动支持。 没有人实现 `S2` 但如果您有它的支持， 则应该和 `S1` 类似。 下一件值得尝试的是 `S3`。 这是最深的 STR 状态， 并需要一系列驱动的支持才能够正常地重新初始化您的硬件。 如果您在唤醒系统时遇到问题， 请不要吝惜发邮件给 {freebsd-acpi} 邮件列表， 尽管不要指望问题一定会很快解决， 因为有许多驱动程序/硬件需要进行更多的测试和改进。

休眠和唤醒操作最常见的问题是某些设备驱动程序不会保存、 恢复或正确地重新初始化其固件、 寄存器或设备内存。 尝试调试这些问题时， 首先可以尝试：

[source,shell]
....
# sysctl debug.bootverbose=1
# sysctl debug.acpi.suspend_bounce=1
# acpiconf -s 3
....

这个测试会模拟休眠和恢复过程而不真的进入 `S3` 状态。 有时， 您会用这种方式很容易地抓住问题 (例如， 丢失固件状态、 设备 watchdog 超时， 以及一直重试等)。 注意系统不会真的进入 `S3` 状态， 这意味着这些设备可能不会掉电， 而许多设备在完全不提供休眠和恢复方法时仍可正常工作， 而不像使用真的 `S3` 状态那样。

较难的情况则需要更多的硬件， 例如用于串口控制台的串口/线， 以及用于 man:dcons[4] 的火线口/线和内核调试技能。

为了帮助隔离问题， 请在内核中删去尽可能多的驱动。 如果这样做能够解决问题， 请尝试逐个加载驱动直到问题再次出现。 通常预编译的驱动程序如 [.filename]#nvidia.ko#、 X11 显示驱动， 以及 USB 的问题最多， 而以太网卡的驱动则通常工作的很好。 如果您能够通过加载和卸载驱动使系统正常工作， 您可以通过将适当的命令放到 [.filename]#/etc/rc.suspend# 和 [.filename]#/etc/rc.resume# 来将这个过程自动化。 在这两个文件中有一个注释掉的卸载和加载驱动程序的例子供您参考。 另外您还可以将 `hw.acpi.reset_video` 设置为零 (`0`)， 如果您的显示在唤醒之后显得很混乱。 此外您还可以尝试更长或更短的 `hw.acpi.sleep_delay` 值看看是否有所助益。

另一件值得一试的事情是使用一个比较新的包含 ACPI 支持的 Linux 发行版来试试看他们的 休眠/唤醒 功能是否在同样的硬件上能够正常工作。 如果在 Linux 下正常， 则很可能是 FreeBSD 驱动程序的问题， 而隔离问题并找到存在问题的驱动有助于解决它。 需要注意的是 ACPI 的维护人员通常并不维护其他驱动 (例如 声音、 ATA， 等等) 因此如果最终发现是驱动的问题最好还是发到 {freebsd-current} 邮件列表并发给驱动程序的维护者。 如果您喜欢冒险， 则可以加一些 man:printf[3] 到有问题的驱动中， 以找到它的恢复功能发生问题的位置。

最后， 试试看禁用 ACPI 并代之以启用 APM。 如果 休眠/唤醒 能够在 APM 下正常工作， 使用 APM 可能会更好， 特别是对于较老的硬件 (2000年以前)。 硬件制造商需要一些时间来让老硬件的 ACPI 工作正常， 而 ACPI 的问题十之八九是 BIOS 中的毛病引发的。

==== 系统停止响应 (暂时或永久性地)

绝大多数系统停止响应是由于未能及时响应中断或发生了中断风暴导致的。 芯片组有很多问题最终会溯源到 BIOS 如何在引导系统之前配置中断， APIC (MADT) 表的正确性， 以及 _系统控制中断_ (SCI) 如何路由。

通过察看 `vmstat -i` 的输出中包括 `acpi0` 的那一行可以区分中断风暴和未能及时响应中断。 如果每秒计数器增长的速度多于一两个， 则您是遇到了中断风暴。 如果系统停止了响应， 您可以尝试停止内核并进入 DDB (在控制台上按 kbd:[CTRL+ALT+ESC]) 并输入 `show interrupts`。

处理中断问题的救命稻草是尝试禁用 APIC 支持， 这是通过在 [.filename]#loader.conf# 中加入 `hint.apic.0.disabled="1"` 完成的。

==== 崩溃

崩溃对于 ACPI 是比较罕见的情况， 如果发现， 我们将会非常重视并很快修复它。 您要做的第一件事是设法隔离出能够重现崩溃 (如果可能的话) 的操作并获取一份调用堆栈。 请启用 `options DDB` 并设置串行控制台 (参见 crossref:serialcomms[serialconsole-ddb,通过串口线进入DDB调试器]) 或配置一个 man:dump[8] 分区。 您将在 DDB 中通过 `tr` 得到调用堆栈。 如果您只能用手抄的方法记录它， 一定要记下头五 (5) 行和最后五 (5) 行。

然后， 尝试通过在启动时禁用 ACPI 来隔离故障。 如果这样做能够正常工作， 请通过设置 `debug.acpi.disable` 的那组数值来隔离具体是哪个 ACPI 子系统的问题。 请参见 man:acpi[4] 联机手册中给出的那些例子。

==== 系统在休眠或关机之后又启动了

首先请尝试在 man:loader.conf[5] 中设置 ``hw.acpi.disable_on_poweroff=``"0"。 这将让 ACPI 不再在关机过程中禁用一些事件。 基于同样的原因， 一些系统需要把这个值设置为 "1" (这是默认值)。 这通常能够修复在休眠或关机时立即再次启动的问题。

==== 其他问题

如果您有 ACPI 的其他问题 (同 docking station 协同工作、 无法检测设备， 等等)， 请把描述发给邮件列表； 不过， 这些问题也有可能和 ACPI 中尚未完成的部分有关， 它们可能需要时间才能被实现。 请给点耐心， 并准备测试我们可能会发给您的补丁。

[[ACPI-aslanddump]]
=== ASL、`acpidump`， 以及 IASL

最常见的问题是 BIOS 制造商提供的不正确 (甚至完全错误的!) 字节代码。 这通常会以类似下面这样的内核消息显示在控制台上：

[source,shell]
....
ACPI-1287: *** Error: Method execution failed [\\_SB_.PCI0.LPC0.FIGD._STA] \\
(Node 0xc3f6d160), AE_NOT_FOUND
....

许多时候， 您可以通过将 BIOS 升级到最新版本来解决此类问题。 绝大多数控制台消息是无害的， 但如果您有其他问题例如电池工作不正常， 则从 AML 开始查找问题将是一条捷径。 字节代码， 或常说的 AML， 是从一种叫做 ASL 的语言写成的源代码进行编译得到的结果。 AML 一般存放在 DSDT 表中。 要得到您系统的 ASL， 需要使用 man:acpidump[8]。 需要同时指定 `-t` (显示固定标的内容) 和 `-d` (将 AML 反编译成 ASL) 两个选项。 请参见 <<ACPI-submitdebug,如何提交调试信息>> 一节了解如何使用它。

最方便的初步检查是尝试重新编译 ASL 来看看是否有错误。 通常可以忽略这一过程中产生的警告， 但错误一般就都是 bug， 它们通常就是导致 ACPI 无法正常工作的原因。 要重新编译您的 ASL， 可以使用下面的命令：

[source,shell]
....
# iasl your.asl
....

[[ACPI-fixasl]]
=== 修复 ASL

我们的长期目标是让每一个人都能够在不需要任何用户干预的情况下使用 ACPI。 然而， 目前我们仍然在开发绕过 BIOS 制造商常见错误的方法。 Microsoft(R) 解释器 ([.filename]#acpi.sys# 和 [.filename]#acpiec.sys#) 并不会严格地检查是否遵守了标准， 因此许多只在 Windows(R) 中测试 ACPI 的 BIOS 制造商很可能永远不会修正他们的 ASL。 我们希望不断地找出并用文档说明 Microsoft(R) 的解释器到底允许那些不标准的行为， 并在 FreeBSD 进行对应的修改使它能够正常工作而不需要用户修正 ASL。 作为一项临时缓解问题的方法， 并帮助我们确认其行为， 您可以手工修正 ASL。 如果这样能够解决问题， 请把新旧 ASL 的 man:diff[1] 发给我们， 这样我们就有可能绕过 ACPI-CA 中的错误行为， 从而不再需要您来手工修正。

下面是一些常见的错误信息， 它们的原因， 以及如何修正。

==== _OS dependencies (_OS 依赖)

某些 AML 假定世界是由不同版本的 Windows(R) 组成的。 您可以让 FreeBSD 声称自己是任意 OS 来看一看是否能够修正问题。 比较简单的办法是设置 `hw.acpi.osname`="Windows 2001" 到 [.filename]#/boot/loader.conf# 中， 或使用您在 ASL 中找到的其他字符串。

==== Missing Return statements (缺少返回语句)

一些方法可能没按照标准要求的那样显式地返回值。 尽管 ACPI-CA 无法处理它， 但 FreeBSD 提供了一个绕过它并允许其暗含地返回值的方法。 您也可以增加一个显式的 Return 语句， 如果您知道那里需要返回一个值的话。 要强制 `iasl` 编译 ASL， 需要使用 `-f` 标志。

==== 替换默认的 AML

在定制 [.filename]#your.asl# 之后， 您可以通过下面的命令编译它：

[source,shell]
....
# iasl your.asl
....

可以使用 `-f` 标志来强制创建 AML， 即使在编译过程中发生了错误。 请注意某些错误 (例如， 缺少 Return 语句) 会自动被解释器忽略掉。

[.filename]#DSDT.aml# 是 `iasl` 命令的默认输出文件名。 可以加载它来取代您 BIOS 中存在问题的副本 (它仍然存在于闪存中)， 其方法是按下面的说明编辑 [.filename]#/boot/loader.conf#：

[.programlisting]
....
acpi_dsdt_load="YES"
acpi_dsdt_name="/boot/DSDT.aml"
....

一定要把您的 [.filename]#DSDT.aml# 复制到 [.filename]#/boot# 目录中。

[[ACPI-debugoutput]]
=== 从 ACPI 中获取调试输出信息

ACPI 驱动程序提供了非常灵活的调试机制。 这允许您指定一组子系统， 以及所需要的详细信息。 需要调试的子系统可以按 "layers(层)" 来指定， 并分为 ACPI-CA 组件 (ACPI_ALL_COMPONENTS) 和 ACPI 硬件支持 (ACPI_ALL_DRIVERS)。 调试输出的详细程度可以通过 "level(详细度)" 来指定， 其范围是 ACPI_LV_ERROR (只报告错误) 到 ACPI_LV_VERBOSE (显示所有)。 "level" 是一个位掩码因此可以一次设置多个选项， 中间用空格分开。 实际使用中您应该考虑使用串行控制台来记录输出， 如果它太长以至于冲掉了控制台消息缓冲的话。 不同的层和输出详细度的完整列表可以在 man:acpi[4] 联机手册中找到。

调试输出默认并不开启。 要起用它， 您需要在内核设置中添加 `options ACPI_DEBUG`， 如果您的内核中编入了 ACPI 的话。 您还可以在 [.filename]#/etc/make.conf# 中加入 `ACPI_DEBUG=1` 来在全局起用它。 如果它只是模块， 您可以用下面的方法来重新编译 [.filename]#acpi.ko#：

[source,shell]
....
# cd /sys/modules/acpi/acpi
&& make clean &&
make ACPI_DEBUG=1
....

安装 [.filename]#acpi.ko# 到 [.filename]#/boot/kernel# and add your 并把所需的详细度和层在 [.filename]#loader.conf# 中指定。 这个例子将启用所有 ACPI-CA 组件以及所有 ACPI 硬件驱动 (CPU、 LID， 等等) 的消息。 只输出错误信息， 也就是最低的详细度。

[.programlisting]
....
debug.acpi.layer="ACPI_ALL_COMPONENTS ACPI_ALL_DRIVERS"
debug.acpi.level="ACPI_LV_ERROR"
....

如果您需要的信息是由某个特定的事件触发的 (比如说， 休眠之后的唤醒)， 您可以不修改 [.filename]#loader.conf# 而转而使用 `sysctl` 来在启动和为那个事件准备系统之后再指定层和详细度。 这些 `sysctl` 的名字和 [.filename]#loader.conf# 中的一致。

[[ACPI-References]]
=== 参考文献

关于 ACPI 的更多信息可以从下面这些地方找到：

* The {freebsd-acpi}
* ACPI 邮件列表存档 http://lists.freebsd.org/pipermail/freebsd-acpi/[http://lists.freebsd.org/pipermail/freebsd-acpi/]
* 旧的 ACPI 邮件列表存档 http://home.jp.FreeBSD.org/mail-list/acpi-jp/[http://home.jp.FreeBSD.org/mail-list/acpi-jp/]
* The https://uefi.org/specifications#ACPI[ACPI 标准]
* FreeBSD 手册页: man:acpi[4], man:acpi_thermal[4], man:acpidump[8], man:iasl[8], man:acpidb[8]
* http://www.cpqlinux.com/acpi-howto.html#fix_broken_dsdt[DSDT 调试资源]. (使用 Compaq 作为例子但通常情况下都很有用。)
