---
title: 第 28 章 PPP 和 SLIP
part: 部分 IV. 网络通讯
prev: books/handbook/serialcomms
next: books/handbook/mail
showBookMenu: true
weight: 33
path: "/books/handbook/ppp-and-slip/"
---

[[ppp-and-slip]]
= PPP 和 SLIP
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 28
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/ppp-and-slip/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[ppp-and-slip-synopsis]]
== 概述

FreeBSD 有很多方法可以将计算机与计算机连接起来。 通过使用拨号 modem 来建立网络或 Internet 连接， 或允许其他人通过您的机器来连上网络， 这些都要求使用 PPP 或 SLIP。 这章将详细介绍设置这些基于 modem 的通信服务的方法。

读完这一章， 您将了解：

* 如何设置用户级 PPP。
* 如何设置内核级 PPP。 (仅限 FreeBSD 7.X)。
* 如何设置 PPPoE (PPP over Ethernet)。
* 如何设置 PPPoA (PPP over ATM)。
* 如何配置和安装 SLIP 客户端和服务器。 (仅限 FreeBSD 7.X)。

在阅读这章之前， 您应：

* 熟悉基本的网络术语。
* 理解拨号连接和 PPP、 SLIP 的基础知识。

您可能想知道用户级 PPP 与内核级 PPP 之间的不同之处。 回答很简单： 用户级 PPP 处理用户级的输入和输出数据， 而不是内核级。 在内核与用户区之间复制数据的花费要大一些， 但它能提供具有更多特性的PPP实现。 用户级PPP使用 [.filename]#tun# 设备与外界通信而内核级 PPP 使用 [.filename]#ppp# 设备。

[NOTE]
====
在这章中， 如果没有特殊说明， 则 ppp 指的是用户态 PPP， 除非需要和其它 PPP 软件， 例如 pppd (仅限 FreeBSD 7.X) 加以区分。 另外， 若没有额外的注明， 本章所介绍的所有命令都需要以 `root` 身份来运行权限。
====

[[userppp]]
== 使用用户级 PPP

[WARNING]
====

从 FreeBSD 8.0 开始， man:uart[4] 驱动取代了 man:sio[4] 驱动。 用以表示串口的设备节点由分别 [.filename]#/dev/cuadN# 改为了 [.filename]#/dev/cuauN#， 并从 [.filename]#/dev/ttydN# 改为了 [.filename]#/dev/ttyuN#。 FreeBSD 7.X 用户在升级时需要因应之对配置文件进行必要的更改。
====

=== 用户级 PPP

==== 前提条件

本章假定您具备如下条件：

* 您有一个 ISP 提供的用于连接使用 PPP 的帐号。
* 您需要有连接在系统上， 并做了正确配置的 modem， 或其他能够连接您 ISP 的设备。
* ISP 的拨号号码。
* 您的登录名称和密码 (可能是一般的 UNIX 风格的登录名和密码对， 也可能是 PAP 或 CHAP 登录名和密码对)。
* 一个或多个域名服务器 IP 地址。 通常， 您会从ISP处得到两个这样的IP地址。 如果您至少得到了一个， 就可以在文件 [.filename]#ppp.conf# 中加入 `enable dns` 命令使 ppp 设置域名服务。 这个功能取决于 ISP 对支持 DNS 协商的具体实现。

下面的信息由您的 ISP 提供， 但不是必需的：

* ISP的网关IP地址。 网关是您准备连接， 并设为 _默认路由_ 的主机。 如果您没有这个信息， 您可以虚构一个， 在连接时 ISP 的 PPP 服务器会自动告诉您正确的值。
+ 
这个虚构的 IP 地址在 ppp 中记做 `HISADDR`。
* 准备使用的子网掩码。 如果ISP没有提供， 一般使用 `255.255.255.255` 是没有问题的。
* 如果 ISP 提供了静态的IP地址和主机名， 可以输入它们。 反之， 则应让对方主机指定它认为合适的 IP 地址。

如果您不知道这些信息， 请与您的 ISP 联系。

[NOTE]
====
在这节中， 所有作为例子展示的配置文件中都有行号。 这些行号只是为了使解释和讨论变得方便， 在真实的文件中并不存在。 此外， 在必要时应使用 Tab 和空格来进行缩进。
====

==== PPP自动化配置

``ppp``和``pppd``(PPP的内核级实现， 仅限 FreeBSD 7.X) 都使用 [.filename]#/etc/ppp# 目录中的配置文件。 用户级 PPP 的例子可以在 [.filename]#/usr/shared/examples/ppp/# 中找到。

配置``ppp``要求根据您的需要编辑几个文件。 编辑哪几个文件取决于您的 IP 是静态分配 (每次都使用同一个地址) 还是动态分配的 (每次连接到 ISP 都会获得不同的 IP 地址)。

[[userppp-staticIP]]
===== PPP和静态IP地址

您需要编辑配置文件[.filename]##/etc/ppp/ppp.conf##， 如下所示。

[NOTE]
====
以冒号``:``结尾的行从第一列 (行首)开始， 其它所有的行都要使用空格或制表符 (Tab) 来缩进。
====

[.programlisting]
....
1     default:
2       set log Phase Chat LCP IPCP CCP tun command
3       ident user-ppp VERSION (built COMPILATIONDATE)
4       set device /dev/cuau0
5       set speed 115200
6       set dial "ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 5 \
7                 \"\" AT OK-AT-OK ATE1Q0 OK \\dATDT\\T TIMEOUT 40 CONNECT"
8       set timeout 180
9       enable dns
10
11    provider:
12      set phone "(123) 456 7890"
13      set authname foo
14      set authkey bar
15      set login "TIMEOUT 10 \"\" \"\" gin:--gin: \\U word: \\P col: ppp"
16      set timeout 300
17      set ifaddr x.x.x.x y.y.y.y 255.255.255.255 0.0.0.0
18      add default HISADDR
....

行1：::
指定默认的项。 当PPP运行时这个项中的命令将自动执行。

行2：::
启用登录参数。 工作正常后， 为避免产生过多的日志文件， 这行应该简化为：
+

[.programlisting]
....
set log phase tun
....

行 3：::
告诉 PPP 怎样向对方标识自己。 如果在建立或使用连接时遇到任何麻烦， PPP就会向对方主机自我标识。 对方主机管理员在处理这个问题时， 这些信息会有用。

行 4：::
标明modem要连接的端口号。 [.filename]#COM1# 对应的设备是 [.filename]#/dev/cuau0# 而 [.filename]#COM2# 对应的则是 [.filename]#/dev/cuau1#。

行 5：::
设置连接的速度。 如果 115200 有问题， 试试 38400。

行 6 & 7：::
拨号字符串。 用户级 PPP 使用一种与 man:chat[8]程序相似的语法。 请参考联机手册了解这种语言的相关信息。
+
注意， 为了便于阅读此命令进行了换行。 任何 [.filename]#ppp.conf# 里的命令都可以这样做， 前提是行的最后一个字符必须是 `\`。

行 8：::
设置连接的时间间隔。 默认是 180 秒， 所以这一行是多余的。

行 9：::
告诉PPP向对方主机确认本地域名解析设置。 如果您运行了本地的域名服务器， 要注释或删除掉这一行。

行 10：::
为了可读性的需要设置一个空行。 空行会被PPP忽略。

行 11：::
为 "provider"指定一个项。 可以改成 ISP的名字， 这样您以后就可以使用 `load _ISP_` 来开启连接。

行 12：::
设置提供商的电话号码。 多个电话号码可以使用冒号 (`:`) 或管道符号 (`|`) 隔开。 这两个字符的区别在man:ppp[8]的联机手册中有介绍。 总的来讲， 如果您要循环使用这些号码， 可以使用冒号。 如果您想使用第一个号码， 当第一个号码失败了再用第二个号码， 就使用管道符号。 如所示的那样， 要给整个电话号码加上引号(")。
+
如果电话号码里有空格， 必须用引号(`"`)将其括起来。 否则会造成简单却难以察觉的错误。

行 13 & 14：::
指定用户名和密码。 当使用 UNIX(R) 风格的命令提示符登录时， 这些值可以用带有 \U \P 参数的 `set login` 命令进行修改。 当使用PAP或CHAP进行连接时， 这些值在验证使用。

行 15：::
如果您使用的是PAP或者CHAP， 在这里就不会有登录。 要注释或删除掉这一行。 请参考 <<userppp-PAPnCHAP,PAP 和 CHAP认证>> 以了解更多细节。
+
登录命令是的语法是chat类型的。 在这个例子中是这样的：
+
[source,shell]
....
J. Random Provider
login: foo
password: bar
protocol: ppp
....
+
您需要改变这个脚本以适合您自己的需要。 当您第一次写这个脚本时， 应当确保已经启用 "chat" 并处于登录状态， 这样您才能确认通信是否正在按计划进行。

行16：::
设置默认的超时时间。 这里， 连接若在 300 秒内无响应将被断开。如果您不想设置成超时， 将这个值设置成0， 或在命令行使用 `-ddial` 选项。

行 17：::
设置接口地址。 您需要用 ISP 提供给您的 IP 地址替换字符串 _x.x.x.x_， 用 ISP 的网关 IP 地址 (即您要连接的主机) 替换字符串 _y.y.y.y_。 如果ISP没有给您提供网关地址， 可以使用 `10.0.0.2/0`。 如果您需要使用一个 "猜到"的地址， 请确保在 [.filename]#/etc/ppp/ppp.linkup# 中为每个 <<userppp-dynamicIP,PPP和动态IP地址>> 指令创建了这一项。 如果没有这一行， `ppp` 将无法以 `-auto` 模式运行。

第18行：::
添加一个到ISP网关的默认路由。 ``HISADDR``这个关键字会被第17行所指定的网关地址替换。 这行必须出现在第17行之后，以免在 ``HISADDR`` 初始化之前使用它的值。
+
如果您不想使用 `-auto` 的 PPP，则这行应挪到 [.filename]#ppp.linkup# 文件中。

若您有一个静态IP地址， 且使用``-auto`` 模式运行ppp(因为在连接之前已经正确设置了路由表项)， 那就不需要再向[.filename]##ppp.linkup## 添加项。 您可能希望在连接以后创建一个项来调用程序。 这在以后的sendmail的例子中会解释。

示例配置文件可以在目录 [.filename]#/usr/shared/examples/ppp/# 中找到。

[[userppp-dynamicIP]]
===== PPP和动态IP地址

如果ISP没给您指定静态的IP地址， ``ppp``要被配置成能够与对方协商确定本地和远程地址。 要完成这项工作， 先要"猜"一个IP地址， 然后允许 ``ppp``在连接后使用IP配置协议(IPCP)进行正确配置。 [.filename]##ppp.conf##的配置是与 <<userppp-staticIP,PPP和静态IP地址>>一样的， 除了以下的改变：

[.programlisting]
....
17      set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.255 0.0.0.0
....

再次强调， 不要包括行号， 它只是一个引用标记。 缩排一个空格是必需的。

行17：::
`/` 字符后面是 PPP 所要求的地址掩码。 您可以根据需要使用不同 IP 地址， 但以上的例子永远是可行的。
+
最后的参数(``0.0.0.0``)告诉 PPP从``0.0.0.0`` 而不是 ``10.0.0.1`` 开始协商地址， 对于有些ISP， 这是必需的。 不要将 ``0.0.0.0`` 作为 ``set ifaddr`` 的第一个参数， 因为这使得 PPP 在 `-auto` 模式时不能设置初始路由。

如果您不运行``-auto``模式， 就需要在[.filename]##/etc/ppp/ppp.linkup##中创建一个项。 连接建立之后， [.filename]##ppp.linkup##被启用。 这时候， ``ppp``将指派接口地址， 接着再添加路由表项：

[.programlisting]
....
1     provider:
2        add default HISADDR
....

行 1：::
为了建立连接， `ppp` 会按照如下规则在 [.filename]##ppp.linkup##寻找项:首先， 试图寻找相同的标签 (如同在[.filename]##ppp.conf##一样）。 如果失败了， 寻找作为网关 IP 地址的项， 此项是四个八位字节的风格。 如果依旧没有找到， 就寻找 `MYADDR` 项

行 2：::
这行告诉 ``ppp``添加指向 ``HISADDR``的默认路由。 ``HISADDR``由通过IPCP协商得到的IP号替换。

参考[.filename]##/usr/shared/examples/ppp/ppp.conf.sample## 和[.filename]##/usr/shared/examples/ppp/ppp.linkup.sample## 中的``pmdemand``项以获取细节化的例子。

===== 接收拨入

当要配置 ppp接受来自LAN上的 拨入时， 您需要决定是否将包转给LAN。 如果是的话， 您就必须从 LAN 子网中给对方分配一个IP， 需要在文件 [.filename]#/etc/ppp/ppp.conf# 中使用命令 `enable proxy`。 您还应该确定文件 [.filename]#/etc/rc.conf# 中包含以下内容：

[.programlisting]
....
gateway_enable="YES"
....

===== 使用哪个getty？

crossref:serialcomms[dialup,配置 FreeBSD 的拨号服务] 描述了如何用 man:getty[8] 来启动拨号服务。

除了 `getty` 之外还有 http://mgetty.greenie.net/[mgetty] (可通过 package:comms/mgetty+sendfax[] port 来安装)， 它是 `getty` 的智能版本， 是按照拨号线的思想设计的。

使用 `mgetty` 的好处是它能积极地与 modem 进行 _会话_， 这就意味着如果在[.filename]##/etc/ttys##中的端口被关闭， 您的moderm就不会回应拨入。

较新版本的 `mgetty` (从 0.99beta 起) 也支持自动检测 PPP 数据流， 这样即便客户端不使用脚本也能访问服务器了。

参考<<userppp-mgetty,Mgetty 和 AutoPPP>>的联机手册了解更多信息。

===== PPP 权限

`ppp` 命令通常必须以 `root` 用户的身份运行。 如果希望以普通用户的身份启动 `ppp` 服务 (就像下面描述的那样)， 就必须把此用户加入 `network` 组， 使其获得运行 `ppp` 的权限。

您还需要使用``allow``命令使用户能访问配置文 件的一个或多个部分：

[.programlisting]
....
allow users fred mary
....

如果这个命令被用在 `default` 部分中， 您可以让指定的用户访问任何东西。

===== 动态IP用户的PPP Shell

创建一个名为[.filename]##/etc/ppp/ppp-shell##文件， 加入以下内容：

[.programlisting]
....
#!/bin/sh
IDENT=`echo $0 | sed -e 's/^.*-\(.*\)$/\1/'`
CALLEDAS="$IDENT"
TTY=`tty`

if [ x$IDENT = xdialup ]; then
        IDENT=`basename $TTY`
fi

echo "PPP for $CALLEDAS on $TTY"
echo "Starting PPP for $IDENT"

exec /usr/sbin/ppp -direct $IDENT
....

这个脚本要有可执行属性。 然后通过如下命令创建一个指向此脚本且名为 [.filename]##ppp-dialup##的符号链接：

[source,shell]
....
# ln -s ppp-shell /etc/ppp/ppp-dialup
....

您应该将这个脚本作为所有拨入用户的 _shell_。 以下是在文件 [.filename]#/etc/passwd# 中关于 PPP 用户 `pchilds` 的例子 (切记， 不要直接修改这个密码文件， 用 man:vipw[8] 来修改它)。

[.programlisting]
....
pchilds:*:1011:300:Peter Childs PPP:/home/ppp:/etc/ppp/ppp-dialup
....

创建一个名为 [.filename]#/home/ppp# 的目录作为拨入用户的主目录， 其中包含以下这些空文件：

[source,shell]
....
-r--r--r--   1 root     wheel           0 May 27 02:23 .hushlogin
-r--r--r--   1 root     wheel           0 May 27 02:22 .rhosts
....

这样就可以防止[.filename]##/etc/motd##被显示出来。

===== 静态IP用户的Shell

像上面那样创建[.filename]##ppp-shell##文件， 为每个静态分配IP用户创建一个到 [.filename]##ppp-shell##的 符号链接。

例如， 如果您希望为三个拨号用户， `fred`， `sam`， 和 `mary` 路由 /24 CIDR 的网络， 则需要键入以下内容：

[source,shell]
....
# ln -s /etc/ppp/ppp-shell /etc/ppp/ppp-fred
# ln -s /etc/ppp/ppp-shell /etc/ppp/ppp-sam
# ln -s /etc/ppp/ppp-shell /etc/ppp/ppp-mary
....

每个用户的Shell必须被设成一个符号链接(例如用户 ``mary``的Shell应该是[.filename]##/etc/ppp/ppp-mary##)。

===== 为动态IP用户设置[.filename]##ppp.conf##

[.filename]##/etc/ppp/ppp.conf##文件应该包含下面 这些行：

[.programlisting]
....
default:
  set debug phase lcp chat
  set timeout 0

ttyu0:
  set ifaddr 203.14.100.1 203.14.100.20 255.255.255.255
  enable proxy

ttyu1:
  set ifaddr 203.14.100.1 203.14.100.21 255.255.255.255
  enable proxy
....

[NOTE]
====
缩进得必须的。
====

``default:``项在每次会话时都会加载。 每个在 [.filename]#/etc/ttys# 中启用的行都必须为其创建一个相似于 ``ttyu0:`` 的项。 每一行应该从动态 IP 地址池中取得唯一的IP地址。

===== 为静态 IP 用户配置 [.filename]#ppp.conf#

根据上面 [.filename]#/usr/shared/examples/ppp/ppp.conf# 文件的内容， 您必须为每个静态拨号用户添加一个项。 我们继续以 ``fred``、 `sam` 以及 ``mary``为例。

[.programlisting]
....
fred:
  set ifaddr 203.14.100.1 203.14.101.1 255.255.255.255

sam:
  set ifaddr 203.14.100.1 203.14.102.1 255.255.255.255

mary:
  set ifaddr 203.14.100.1 203.14.103.1 255.255.255.255
....

如果需要， [.filename]#/etc/ppp/ppp.linkup# 也应该包括每个静态IP用户的的路由信息。 下面这一行为客户连接添加了到 ``203.14.101.0/24`` 网络的路由。

[.programlisting]
....
fred:
  add 203.14.101.0 netmask 255.255.255.0 HISADDR

sam:
  add 203.14.102.0 netmask 255.255.255.0 HISADDR

mary:
  add 203.14.103.0 netmask 255.255.255.0 HISADDR
....

[[userppp-mgetty]]
===== ``mgetty``和AutoPPP

默认情况下， package:comms/mgetty+sendfax[] port 在编译时启用了 `AUTO_PPP` 选项， 它使 `mgetty` 能够检测 PPP 连接的 LCP 状态， 并自动产生 PPP shell。 不过， 由于在默认配置中的 login/password 序列并不出现， 因此， 就必须使用 PAP 或 CHAP 来严重用户身份。

这节假定用户已经在系统中成功地编译并安装了 package:comms/mgetty+sendfax[]。

确认您的 [.filename]#/usr/local/etc/mgetty+sendfax/login.config# 文件中包含以下内容：

[.programlisting]
....
/AutoPPP/ -     -		      /etc/ppp/ppp-pap-dialup
....

这行告诉``mgetty``运行 [.filename]##ppp-pap-dialup##脚本来侦听PPP连接。

创建[.filename]##/etc/ppp/ppp-pap-dialup##文件写入以下内容 (此文件应该是可执行的)：

[.programlisting]
....
#!/bin/sh
exec /usr/sbin/ppp -direct pap$IDENT
....

对应于每个在[.filename]##/etc/ttys##的启用行， 都要在[.filename]##/etc/ppp/ppp.conf## 中创建相应的项。 这和上面的定义是相同的。

[.programlisting]
....
pap:
  enable pap
  set ifaddr 203.14.100.1 203.14.100.20-203.14.100.40
  enable proxy
....

每个以这种方式登录的用户， 都必须在 [.filename]#/etc/ppp/ppp.secret# 文件中给出用户名/口令， 或者使用以下选项， 来通过 PAP 方式以 [.filename]#/etc/passwd# 文件提供的信息来完成身份验证。

[.programlisting]
....
enable passwdauth
....

如果您想为某些用户分配静态IP， 可以在 [.filename]#/etc/ppp/ppp.secret# 中将IP号作为第三个参数指定。 请参见 [.filename]#/usr/shared/examples/ppp/ppp.secret.sample# 中的例子。

===== MS Extensions

可以配置PPP以提供DNS和NetBIOS域名服务器地址。

要在 PPP 1.x 版本中启用这些扩展， 需要在 [.filename]#/etc/ppp/ppp.conf# 的对应项中加入下列配置：

[.programlisting]
....
enable msext
set ns 203.14.100.1 203.14.100.2
set nbns 203.14.100.5
....

PPP版本2及以上：

[.programlisting]
....
accept dns
set dns 203.14.100.1 203.14.100.2
set nbns 203.14.100.5
....

这将告诉客户端首选域名服务器和备用域名服务器。

在版本2及以上版本中， 如果省略了 `set dns`， PPP会使用 [.filename]##/etc/resolv.conf##中的值。

[[userppp-PAPnCHAP]]
===== PAP 和 CHAP 验证

一些 ISP 将系统配置为使用 PAP 或 CHAP 机制来完成连接验证。 如果遇到这种情况， 在您连接时 ISP 就不会看到 `login:` 提示符， 而是立即开始 PPP 对话。

PAP 安全性要比 CHAP 差一些， 但在这里安全性并不是问题， 因为密码 (即使用明文传送) 只是通过串行线传送， 攻击者并没有太多机会去 "窃听" 它。

参考 <<userppp-staticIP,PPP 与静态 IP 地址>> 或 <<userppp-dynamicIP,PPP 与动态 IP 地址>> 小节， 并完成下列改动：

[.programlisting]
....
13      set authname MyUserName
14      set authkey MyPassword
15      set login
....

第 13 行：::
这一行指明您的PAP/CHAP用户名。 您需要为_MyUserName_输入正确的值。

第 14 行：::
这一行指明您的 PAP/CHAP password密码。 您需要为 _MyPassword_ 输入正确的值。 另外，您可能希望加入一些额外的选项，例如：
+
[.programlisting]
....
16      accept PAP
....
+
或
+
[.programlisting]
....
16      accept CHAP
....
+
以明确您的意图， 不过， 默认情况下 PAP 和 CHAP 都会被接受。

行 15：::
如果您使用的是 PAP 或 CHAP， 一般来说 ISP 就不会要求您登录服务器了。 这时， 就必须禁用 "set login" 设置。

===== 即时改变您的``ppp`` 配置

与后台运行的``ppp``程序进行对话是可能的， 前提是设置了一个合适的诊断端口。 做到这一点， 需要把下面的行加入到您的配置中：

[.programlisting]
....
set server /var/run/ppp-tun%d DiagnosticPassword 0177
....

这行告诉 PPP在指定的UNIX(R)域socket中侦听， 当用户连接时需要给出指定的密码。 ``%d``用[.filename]##tun##设备号替换。

一旦启用了socket， 就可以在脚本中调用程序man:pppctl[8]来处理正在运行的 的PPP。

[[userppp-nat]]
==== 使用PPP网络地址翻译

PPP 可以使用内建的 NAT， 而无需内核支持。 您可以在 [.filename]#/etc/ppp/ppp.conf# 中加入如下配置来启用它：

[.programlisting]
....
nat enable yes
....

PPP NAT也可以使用命令行选项 ``-nat``启动。 在 [.filename]#/etc/rc.conf# 文件中也有 ``ppp_nat`` 项， 并默认启用。

如果您使用了这个特性， 您还会发现在 [.filename]##/etc/ppp/ppp.conf##中以下 选项对于启用incoming connections forwarding是有用的：

[.programlisting]
....
nat port tcp 10.0.0.2:ftp ftp
nat port tcp 10.0.0.2:http http
....

或者完全不信任外来的请求

[.programlisting]
....
nat deny_incoming yes
....

[[userppp-final]]
==== 最后的系统配置

现在您已配置了``ppp``， 但在真正工作之前还有一些事情要做。 即修改 [.filename]#/etc/rc.conf#。

从上依次往下看， 确认已经正确地配置了 `hostname=`， 例如：

[.programlisting]
....
hostname="foo.example.com"
....

如果您的ISP提供给您一个静态的IP和名字， 将这个名字设为hostname是最合适的。

寻找 `network_interfaces` 变量。 如果要配置系统通过拨号连入ISP， 一定要将[.filename]##tun0##设备加入这个列表， 否则就删除它。

[.programlisting]
....
network_interfaces="lo0 tun0"
ifconfig_tun0=
....

[NOTE]
====
``ifconfig_tun0``变量应该是空的， 且要创建一个名为 [.filename]##/etc/start_if.tun0##的文件。 这个文件应该包含这一行：

[.programlisting]
....
ppp -auto mysystem
....

此脚本在网络配置时被执行， 开启PPP守护进程进入自动模式。 如果这台机子充当一个LAN的网关， 您可能希望使用 `-alias`。 参考相关联机手册了解更多细节。
====

务必在 [.filename]#/etc/rc.conf# 中， 把路由程序设置为 `NO`：

[.programlisting]
....
router_enable="NO"
....

不启动 `routed` 服务程序非常重要， 因为 `routed` 总会删掉由 `ppp` 所建立的默认路由。

此外， 我们建议您确认一下 `sendmail_flags` 这一行中没有指定 `-q` 参数， 否则 `sendmail` 将会不断地尝试查找网络， 而这样做将会导致机器不断地进行拨号。 可以考虑：

[.programlisting]
....
sendmail_flags="-bd"
....

替代的做法是当每次 PPP 连接建立时您必须通过键入以下命令强制 `sendmail` 重新检查邮件队列：

[source,shell]
....
# /usr/sbin/sendmail -q
....

您也可以在[.filename]##ppp.linkup##使用``!bg``命令自动完成这些工作：

[.programlisting]
....
1     provider:
2       delete ALL
3       add 0 0 HISADDR
4       !bg sendmail -bd -q30m
....

如果您不喜欢这样做， 可以设立一个 "dfilter" 以阻止 SMTP 传输。 参考相关文件了解更多细节。

现在您唯一要做的事是重新启动计算机。 重启之后，可以输入：

[source,shell]
....
# ppp
....

然后是``dial provider``以开启 PPP会话。 或者如果您想让``ppp``自动建立会话， 因为您有一条广域网连接 (且没有创建 [.filename]#start_if.tun0# 脚本)， 键入：

[source,shell]
....
# ppp -auto provider
....

==== 总结

当第一次设置PPP时， 下面几步是必须的：

客户端：

[.procedure]
====
. 确保 [.filename]##tun##编译进了进核。
. 确保 [.filename]##/dev## 目录中名为 [.filename]##tunN## 的设备文件是可用的。
. 在 [.filename]##/etc/ppp/ppp.conf##中创建一个项。 [.filename]##pmdemand##示例应该适合于绝大多数ISP。
. 如果您使用动态IP地址， 在[.filename]##/etc/ppp/ppp.linkup##创建一个项。
. 更新[.filename]##/etc/rc.conf## 文件。
. 如果您要求按需拨号， 创建一个[.filename]##start_if.tun0##脚本。
====

服务器端：

[.procedure]
====
. 确保[.filename]##tun##设备已编译入内核。
. 确保 [.filename]##/dev## 目录中名为 [.filename]##tunN## 的设备文件是可用的。
. 在[.filename]##/etc/passwd##中创建一个项 (使用man:vipw[8]程序)。
. 在用户的home目录创建一个运行 ``ppp -direct direct-server``或相似命令的profile。
. 在[.filename]##/etc/ppp/ppp.conf##中创建一个项。 [.filename]##direct-server##示例应该能满足要求。
. 在 [.filename]##/etc/ppp/ppp.linkup##中创建一个项。
. 更新 [.filename]##/etc/rc.conf## 文件。
====

[[ppp]]
== 使用内核级PPP

[WARNING]
====

这节内容只在 FreeBSD 7.X 上可用。
====

=== 设立内核级PPP

在开始配置 PPP 之前， 请确认 `pppd` 已经存放在 [.filename]#/usr/sbin# 中， 并且 [.filename]#/etc/ppp# 目录是存在的。

``pppd``能在两种模式下工作：

. 作为一个 "客户" - 您要通过PPP串行线或modem线把您的机器连接到互联网上。
. 作为"服务器" -计算机已经位于网络上， 且被用于通过PPP与其它计算机连接。

两种情况您都需要设立一个选项文件， ([.filename]#/etc/ppp/options# 或者是 [.filename]#~/.ppprc# 如果您的计算机有多个用户使用PPP)。

您还需要一些modem/serial软件(package:comms/kermit[]就很适合)， 使您能够拨号并与远程主机建立连接。

=== 使用``pppd``作为客户端

下面这个 [.filename]##/etc/ppp/options##选项文件能够被用来与CISCO终端服务器的 PPP线连接。

[.programlisting]
....
crtscts         # enable hardware flow control
modem           # modem control line
noipdefault     # remote PPP server must supply your IP address
                # if the remote host does not send your IP during IPCP
                # negotiation, remove this option
passive         # wait for LCP packets
domain ppp.foo.com      # put your domain name here

:remote_ip    # put the IP of remote PPP host here
                # it will be used to route packets via PPP link
                # if you didn't specified the noipdefault option
                # change this line to local_ip:remote_ip

defaultroute    # put this if you want that PPP server will be your
                # default router
....

连接：

[.procedure]
====
. 使用 Kermit (或其他 modem 程序来拨号)， 然后输入您的用户名和口令 (或在远程主机上启用 PPP 所需的其他信息)。
. 退出 Kermit (并不挂断连接)。
. 键入下面这行：
+
[source,shell]
....
# /usr/sbin/pppd /dev/tty01 19200
....
+ 
一定要使用正确的速度和设备名。
====

现在您的计算机已经用PPP连接。 如果连接失败， 您可在文件 [.filename]#/etc/ppp/options# 中添加 `debug` 选项， 并查看控制台信息以跟踪问题。

下面这个[.filename]##/etc/ppp/pppup##脚本能自动完成这三个步骤：

[.programlisting]
....
#!/bin/sh
pgrep -l pppd
pid=`pgrep pppd`
if [ "X${pid}" != "X" ] ; then
        echo 'killing pppd, PID=' ${pid}
        kill ${pid}
fi
pgrep -l kermit
pid=`pgrep kermit`
if [ "X${pid}" != "X" ] ; then
        echo 'killing kermit, PID=' ${pid}
        kill -9 ${pid}
fi

ifconfig ppp0 down
ifconfig ppp0 delete

kermit -y /etc/ppp/kermit.dial
pppd /dev/tty01 19200
....

[.filename]#/etc/ppp/kermit.dial# 是一个 Kermit 脚本， 它会完成拨号， 并在远程主机上完成所有需要的身份验证过程 (这份文档的最后有一个脚本实例)。

使用下面这个脚本[.filename]##/etc/ppp/pppdown##断开PPP连线：

[.programlisting]
....
#!/bin/sh
pid=`pgrep pppd`
if [ X${pid} != "X" ] ; then
        echo 'killing pppd, PID=' ${pid}
        kill -TERM ${pid}
fi

pgrep -l kermit
pid=`pgrep kermit`
if [ "X${pid}" != "X" ] ; then
        echo 'killing kermit, PID=' ${pid}
        kill -9 ${pid}
fi

/sbin/ifconfig ppp0 down
/sbin/ifconfig ppp0 delete
kermit -y /etc/ppp/kermit.hup
/etc/ppp/ppptest
....

通过执行[.filename]##/usr/etc/ppp/ppptest##， 看看``pppd`` 是否仍在运行：

[.programlisting]
....
#!/bin/sh
pid=`pgrep pppd`
if [ X${pid} != "X" ] ; then
        echo 'pppd running: PID=' ${pid-NONE}
else
        echo 'No pppd running.'
fi
set -x
netstat -n -I ppp0
ifconfig ppp0
....

执行脚本 [.filename]##/etc/ppp/kermit.hup##以挂起moderm， 这个文件包含：

[.programlisting]
....
set line /dev/tty01	; put your modem device here
set speed 19200
set file type binary
set file names literal
set win 8
set rec pack 1024
set send pack 1024
set block 3
set term bytesize 8
set command bytesize 8
set flow none

pau 1
out +++
inp 5 OK
out ATH0\13
echo \13
exit
....

也可以用``chat`` 代替``kermit``：

以下两个文件用以建立``pppd``连接。

[.filename]#/etc/ppp/options#：

[.programlisting]
....
/dev/cuad1 115200

crtscts		# enable hardware flow control
modem		# modem control line
connect "/usr/bin/chat -f /etc/ppp/login.chat.script"
noipdefault	# remote PPP serve must supply your IP address
	        # if the remote host doesn't send your IP during
                # IPCP negotiation, remove this option
passive         # wait for LCP packets
domain your.domain	# put your domain name here

:		# put the IP of remote PPP host here
	        # it will be used to route packets via PPP link
                # if you didn't specified the noipdefault option
                # change this line to local_ip:remote_ip

defaultroute	# put this if you want that PPP server will be
	        # your default router
....

[.filename]#/etc/ppp/login.chat.script#：

[NOTE]
====
以下的内容应该放在一行内。
====

[.programlisting]
....
ABORT BUSY ABORT 'NO CARRIER' "" AT OK ATDTphone.number
  CONNECT "" TIMEOUT 10 ogin:-\\r-ogin: login-id
  TIMEOUT 5 sword: password
....

一旦这些被安装且修改正确， 您所要做的就是运行``pppd``， 就像这样：

[source,shell]
....
# pppd
....

=== 使用``pppd``作为服务器

[.filename]##/etc/ppp/options##要包括下面这些内容：

[.programlisting]
....
crtscts                         # Hardware flow control
netmask 255.255.255.0           # netmask (not required)
192.114.208.20:192.114.208.165  # IP's of local and remote hosts
                                # local ip must be different from one
                                # you assigned to the Ethernet (or other)
                                # interface on your machine.
                                # remote IP is IP address that will be
                                # assigned to the remote machine
domain ppp.foo.com              # your domain
passive                         # wait for LCP
modem                           # modem line
....

下面这个脚本[.filename]##/etc/ppp/pppserv## 使pppd以服务器方式启动：

[.programlisting]
....
#!/bin/sh
pgrep -l pppd
pid=`pgrep pppd`
if [ "X${pid}" != "X" ] ; then
        echo 'killing pppd, PID=' ${pid}
        kill ${pid}
fi
pgrep -l kermit
pid=`pgrep kermit`
if [ "X${pid}" != "X" ] ; then
        echo 'killing kermit, PID=' ${pid}
        kill -9 ${pid}
fi

# reset ppp interface
ifconfig ppp0 down
ifconfig ppp0 delete

# enable autoanswer mode
kermit -y /etc/ppp/kermit.ans

# run ppp
pppd /dev/tty01 19200
....

使用脚本[.filename]##/etc/ppp/pppservdown##停止服务器：

[.programlisting]
....
#!/bin/sh
pgrep -l pppd
pid=`pgrep pppd`
if [ "X${pid}" != "X" ] ; then
        echo 'killing pppd, PID=' ${pid}
        kill ${pid}
fi
pgrep -l kermit
pid=`pgrep kermit`
if [ "X${pid}" != "X" ] ; then
        echo 'killing kermit, PID=' ${pid}
        kill -9 ${pid}
fi
ifconfig ppp0 down
ifconfig ppp0 delete

kermit -y /etc/ppp/kermit.noans
....

下面的 Kermit 脚本 ([.filename]##/etc/ppp/kermit.ans##) 能够启用/禁用您 modem 的自动应答模式。 其内容类似下面这样：

[.programlisting]
....
set line /dev/tty01
set speed 19200
set file type binary
set file names literal
set win 8
set rec pack 1024
set send pack 1024
set block 3
set term bytesize 8
set command bytesize 8
set flow none

pau 1
out +++
inp 5 OK
out ATH0\13
inp 5 OK
echo \13
out ATS0=1\13   ; change this to out ATS0=0\13 if you want to disable
                ; autoanswer mode
inp 5 OK
echo \13
exit
....

一个名为[.filename]##/etc/ppp/kermit.dial##的脚本用于向远程主机 进行拨号和验证。 您要根据需要定制它。 要加入您的登寻名和密码， 您还要根据 modem 和远程主机的反应修改输入语句。

[.programlisting]
....
;
; put the com line attached to the modem here:
;
set line /dev/tty01
;
; put the modem speed here:
;
set speed 19200
set file type binary            ; full 8 bit file xfer
set file names literal
set win 8
set rec pack 1024
set send pack 1024
set block 3
set term bytesize 8
set command bytesize 8
set flow none
set modem hayes
set dial hangup off
set carrier auto                ; Then SET CARRIER if necessary,
set dial display on             ; Then SET DIAL if necessary,
set input echo on
set input timeout proceed
set input case ignore
def \%x 0                       ; login prompt counter
goto slhup

:slcmd                          ; put the modem in command mode
echo Put the modem in command mode.
clear                           ; Clear unread characters from input buffer
pause 1
output +++                      ; hayes escape sequence
input 1 OK\13\10                ; wait for OK
if success goto slhup
output \13
pause 1
output at\13
input 1 OK\13\10
if fail goto slcmd              ; if modem doesn't answer OK, try again

:slhup                          ; hang up the phone
clear                           ; Clear unread characters from input buffer
pause 1
echo Hanging up the phone.
output ath0\13                  ; hayes command for on hook
input 2 OK\13\10
if fail goto slcmd              ; if no OK answer, put modem in command mode

:sldial                         ; dial the number
pause 1
echo Dialing.
output atdt9,550311\13\10               ; put phone number here
assign \%x 0                    ; zero the time counter

:look
clear                           ; Clear unread characters from input buffer
increment \%x                   ; Count the seconds
input 1 {CONNECT }
if success goto sllogin
reinput 1 {NO CARRIER\13\10}
if success goto sldial
reinput 1 {NO DIALTONE\13\10}
if success goto slnodial
reinput 1 {\255}
if success goto slhup
reinput 1 {\127}
if success goto slhup
if < \%x 60 goto look
else goto slhup

:sllogin                        ; login
assign \%x 0                    ; zero the time counter
pause 1
echo Looking for login prompt.

:slloop
increment \%x                   ; Count the seconds
clear                           ; Clear unread characters from input buffer
output \13
;
; put your expected login prompt here:
;
input 1 {Username: }
if success goto sluid
reinput 1 {\255}
if success goto slhup
reinput 1 {\127}
if success goto slhup
if < \%x 10 goto slloop         ; try 10 times to get a login prompt
else goto slhup                 ; hang up and start again if 10 failures

:sluid
;
; put your userid here:
;
output ppp-login\13
input 1 {Password: }
;
; put your password here:
;
output ppp-password\13
input 1 {Entering SLIP mode.}
echo
quit

:slnodial
echo \7No dialtone.  Check the telephone line!\7
exit 1

; local variables:
; mode: csh
; comment-start: "; "
; comment-start-skip: "; "
; end:
....

[[ppp-troubleshoot]]
== PPP 连接故障排除

[WARNING]
====

从 FreeBSD 8.0 开始， man:uart[4] 驱动取代了 man:sio[4] 驱动。 用以表示串口的设备节点由分别 [.filename]#/dev/cuadN# 改为了 [.filename]#/dev/cuauN#， 并从 [.filename]#/dev/ttydN# 改为了 [.filename]#/dev/ttyuN#。 FreeBSD 7.X 用户在升级时需要因应之对配置文件进行必要的更改。
====

本节将讲述通过modem连接使用PPP时可能出现的问题。 例如， 您可能需要确切地知道您拨入的系统会出现一个怎样的命令行提示符。 有些 ISP 会提供 ``ssword``提示符， 而其它的可能会出现 ``password``； 如果没有根据情况的不同相应地编写 ``ppp`` 脚本， 登录就会失败。 诊断 ``ppp`` 最常用的方法是手动进行连接。 以下的信息会一步一步地带您完成手动连接。

=== 检查设备节点

如果使用的是定制内核， 确认在其编译配置中包含下列配置：

[.programlisting]
....
device   uart
....

默认的 `GENERIC` 内核中包含了 [.filename]#uart# 设备， 因此如果您使用的是它的话， 就不需要担心了。 只要查看 `dmesg` 输出中是否有 modem 设备：

[source,shell]
....
# dmesg | grep uart
....

您应该找到与 [.filename]##uart## 设备有关的输出。 这些就是我们需要的 COM 端口。 如果您的 modem 按照标准串行端口工作， 您就会在 [.filename]##uart1## 或 [.filename]##COM2## 上找到它。 如果 modem 设备连接在 [.filename]##uart1## 接口 (在 DOS 中称为[.filename]##COM2##)， 那么您的 modem 将会是 [.filename]##/dev/cuau1##。

=== 手动连接

通过手动控制``ppp``来连接Internet 是诊断连接及获知ISP处理PPP客户端方式的一个快速， 简单的方法。 让我们从PPP 命令行开始， 在所有的例子中我们使用 _example_ 表示运行 PPP 服务的主机名。 键入``ppp`` 命令打开 ``ppp``：

[source,shell]
....
# ppp
....

现在我们已经打开了``ppp``。

[source,shell]
....
ppp ON example> set device /dev/cuau1
....

设置modem设备， 在本例子中是 [.filename]#cuau1#。

[source,shell]
....
ppp ON example> set speed 115200
....

设置连接速度， 在本例中我们使用15,200 kbps。

[source,shell]
....
ppp ON example> enable dns
....

使``ppp``配置域名服务， 在文件[.filename]##/etc/resolv.conf##中添加域名服务器行。 如果 ``ppp``不能确定我们的主机名， 可以在稍后设置。

[source,shell]
....
ppp ON example> term
....

切换到 "终端"样我们就能手动地控制这台 modem 的模式。

[.programlisting]
....
deflink: Entering terminal mode on /dev/cuau1
type '~h' for help
....

[source,shell]
....
at
OK
atdt123456789
....

使用命令``at``初始化modem， 然后使用``atdt``和ISP给您的号码进行拨号。

[source,shell]
....
CONNECT
....

连接配置， 如果我们遇到了与硬件无关的连接问题， 可以在这里尝试解决。

[source,shell]
....
ISP Login:myusername
....

这里提示您输入用户名， 输入ISP提供的用户名然后按回车。

[source,shell]
....
ISP Pass:mypassword
....

这时提示我们输入密码， 输入 ISP提供的密码。 如同登录入FreeBSD， 密码不会显示。

[source,shell]
....
Shell or PPP:ppp
....

由于ISP的不同， 这个提示符可能不会出现。 这里我们需要考虑： 是使用运行于提供商端的 Shell， 还是启动 `ppp`？ 这本例中， 我们选择使用 `ppp`， 因为我们希望得到 Internet 连接。

[source,shell]
....
Ppp ON example>
....

注意在这个例子中， 第一个 ``p``已经大写。 这表示我们已经成功地连接上了 ISP。

[source,shell]
....
PPp ON example>
....

我们已经成功通过了 ISP的验证， 正在等待分配IP地址。

[source,shell]
....
PPP ON example>
....

我们得到了一个 IP 地址， 成功地完成了连接。

[source,shell]
....
PPP ON example>add default HISADDR
....

这样就完成了添加默认路由所需的配置。 这是与外界通信所必需的。 因为之前我们只是与服务器端建立了连接。 如果由于已存在的路由而导致操作失败， 您可以在 `add` 前加 ``!``号。 除此之外， 您也可以在真正连接之前设置这些 (指 add default HISADDR)， ppp 会根据这项设定协商取得新的路由。

如果一切顺利， 现在我们应该能得到一个活动的 Internet 连接， 可以使用 kbd:[CTRL+z] 使其转入后台。 如果您发现 ``PPP``重新变为 ``ppp``， 则表示连接被断开。 大写的 P 表明建立了到 ISP 的连接， 而小写的 p 则表示连接由于某种原因被断开， 这有助于帮助我们了解连接的状态。 ``ppp`` 只有这两个状态。

==== 诊断排错

如果您有一根直连线且似乎不能建立连接， 要使用``set ctsrts off``以关闭字节流的CTS/RTS。 这种情况一般发生在连接兼容 PPP 的终端服务器时。 当它向通信连接写入数据时， PPP就会挂起， 一直等待一个CTS， 或者一个不可能出现的 Clear to Send 信号。 如果使用了这个选项， 您还应使用 ``set accmap``选项， 某些存在缺陷的硬件在完成端对端发送特定字符， 特别是 XON/XOFF 时可能会遇到困难。 请参见 man:ppp[8] 联机手册以了解关于可用选项的更多细节， 以及如何使用它们。

如果您的 modem 比较旧， 就需要使用 ``set parity even`` 了。 奇偶校验的默认设置是 none， 但在旧式的 (当流量大量增加时) 调制解调器和某些 ISP 被用来纠错。 您需要使用这个选项才能使用 Compuserve ISP。

PPP 可能并不返回命令模式， 这通常是 ISP 等待您这一端发起协商时发生了错误。 此时， 使用 ``~p`` 命令将强制 ppp 开始发送配置信息。

如果您没有看到登录提示， 则很可能需要使用 PAP 或 CHAP 验证来代替前面例子中的 UNIX(R) 风格验证。 要使用 PAP 或 CHAP 只需在进入终端模式之前把下面的选项加入 PPP：

[source,shell]
....
ppp ON example> set authname myusername
....

此处 _myusername_ 应改为您的 ISP 分配给您的用户名。

[source,shell]
....
ppp ON example> set authkey mypassword
....

此处 _mypassword_ 应该为您的 ISP 分配给您的口令。

如果连接正常， 但无法查找域名， 请尝试 man:ping[8] 某个 IP 地址来看看是否返回了信息。 如果您发现百分之百 (100%) 丢包， 那么您很可能没有分配默认路由。 请仔细检查选项 `add default HISADDR` 是否在连接时被设置了。 如果您能连接到远程的 IP 地址则有可能域名解析服务器的地址没有被加入到 [.filename]#/etc/resolv.conf#。 这个文件应该是下面的样子：

[.programlisting]
....
domain example.com
nameserver x.x.x.x
nameserver y.y.y.y
....

此处 _x.x.x.x_ 和 _y.y.y.y_ 应该改为您的 ISP 的 DNS 服务器的 IP 地址。 这一信息在您注册时可能会提供给您， 不过通常只需给 ISP 打个电话就能知道了。

您还可以让 man:syslog[3] 为您的 PPP 连接提供日志。 只需增加：

[.programlisting]
....
!ppp
*.*     /var/log/ppp.log
....

到 [.filename]#/etc/syslog.conf# 中。 绝大多数情况下， 这个功能默认已经打开了。

[[pppoe]]
== 使用基于以太网的PPP(PPPoE)

本节将介绍如何建立基于以太网的PPP (PPPoE)。

=== 配置内核

对于PPPOE， 并没有必须的内核配置。 如果必需的 netgraph 支持没有编译入内核， 它可以由 ppp 动态加载。

=== 设置[.filename]##ppp.conf##

以下是一个[.filename]##ppp.conf##的例子：

[.programlisting]
....
default:
  set log Phase tun command # you can add more detailed logging if you wish
  set ifaddr 10.0.0.1/0 10.0.0.2/0

name_of_service_provider:
  set device PPPoE:xl1 # replace xl1 with your Ethernet device
  set authname YOURLOGINNAME
  set authkey YOURPASSWORD
  set dial
  set login
  add default HISADDR
....

=== 运行ppp

以 `root` 身份执行：

[source,shell]
....
# ppp -ddial name_of_service_provider
....

=== 启动时运行ppp

在 [.filename]#/etc/rc.conf# 中加入以下内容：

[.programlisting]
....
ppp_enable="YES"
ppp_mode="ddial"
ppp_nat="YES"	# if you want to enable nat for your local network, otherwise NO
ppp_profile="name_of_service_provider"
....

=== 使用 PPPoE 服务标签

在某些时候， 有必要使用一个服务标签来建立您的连接。 服务标签用于区分同一网络中的不同服务器。

您可以在ISP提供的文档中找到必要的服务标签信息。 若不能找到， 则应向您的 ISP 寻求技术支持。

作为最后的方法， 您可以试试 http://www.roaringpenguin.com/pppoe/[Roaring Penguin PPPoE]， 它可以在 crossref:ports[ports,Ports Collection] 中找到。 然而需要注意的是， 它可能会清楚 modem 的固件， 并使其无法正常工作， 因此一定要仔细考虑之后再做这个操作。 简单地安装由服务提供商随 modem 提供的程序。 随后， 选择 menu:System[] 菜单。 您的配置文件应该会在这里列出。 一般来说它的名字应该是 _ISP_。

配置文件名 (service tag， 服务标签) 将被用于 PPPoE 在 [.filename]#ppp.conf# 中的配置项， 作为服务商 `set device` 命令的一部分 (参见 man:ppp[8] 联机手册以了解更多细节)。 它应该类似下面的样子：

[.programlisting]
....
set device PPPoE:xl1:ISP
....

记住将_xl1_换成实际的以太网设备。

记住将 _ISP_ 换成您刚刚找到的profile名。

获得更多的信息， 请参考：

* http://renaud.waldura.com/doc/freebsd/pppoe/[Cheaper Broadband with FreeBSD on DSL] by Renaud Waldura.
* http://www.ruhr.de/home/nathan/FreeBSD/tdsl-freebsd.html[ Nutzung von T-DSL und T-Online mit FreeBSD] by Udo Erdelhoff (in German).

[[ppp-3com]]
=== 带有一个3Com(R) HomeConnect(TM) ADSL Modem的PPPOE双重连接

这个 modem 不遵循 http://www.faqs.org/rfcs/rfc2516.html[RFC 2516] (_A Method for transmitting PPP over Ethernet (PPPoE)_， 其作者为 L. Mamakos、 K. Lidl、 J. Evarts、 D. Carrel、 D. Simone 以及 R. Wheeler)。 而是使用不同的数据包格式作为以太网的框架。 请向 http://www.3com.com/[3Com] 抱怨， 如果您认为它应该遵守 PPPoE 的规范。

为了让FreeBSD能够与这个设备通信， 必须设置sysctl。 通过更改[.filename]##/etc/sysctl.conf##， 这一步可以在启动时自动完成：

[.programlisting]
....
net.graph.nonstandard_pppoe=1
....

或者， 也可以直接执行下面的命令：

[source,shell]
....
# sysctl net.graph.nonstandard_pppoe=1
....

很不幸，由于这是系统全局设置， 无法同时与正常的PPP客户端(或服务器) 和3Com(R)HomeConnect(TM) ADSL Modem通信。

[[pppoa]]
== 使用 ATM 上的 PPP (PPPoA)

以下将介绍如何设置基于ATM的PPP(PPPoA)。 PPPoA是欧洲DSL提供商的普遍选择。

=== 使用 Alcatel SpeedTouch(TM)USB 的 PPPoA

针对这一设备的 PPPoA 支持， 在 FreeBSD 中是作为 port 提供的， 因为其固件使用了 http://www.speedtouchdsl.com/disclaimer_lx.htm[阿尔卡特许可协议]， 因而不能与 FreeBSD 的基本系统一起免费地再发布。

使用 crossref:ports[ports,Ports 套件] 可以非常方便地安装 package:net/pppoa[] port， 之后按照它提供的指示操作就可以了。

和许多 USB 设备类似， 阿尔卡特的 SpeedTouch(TM) USB 需要从主机上下载固件才能够正常工作。 在 FreeBSD 中您可以将此操作自动化， 在有设备插到某个 USB 口的时候自动下载固件。 可以在 [.filename]#/etc/usbd.conf# 文件中加入下面的信息来让它自动完成固件的传送。 注意， 必须以 `root` 用户的身份编辑它。

[.programlisting]
....
device "Alcatel SpeedTouch USB"
    devname "ugen[0-9]+"
    vendor 0x06b9
    product 0x4061
    attach "/usr/local/sbin/modem_run -f /usr/local/libdata/mgmt.o"
....

要启动USB守护进程usbd， 在[.filename]##/etc/rc.conf##加入以下行：

[.programlisting]
....
usbd_enable="YES"
....

也可以将ppp设置成启动时拨号。 向 [.filename]##/etc/rc.conf##加入以下这几行。 同样地您需要以``root``用户登录。

[.programlisting]
....
ppp_enable="YES"
ppp_mode="ddial"
ppp_profile="adsl"
....

为了使其正常工作， 您需要使用package:net/pppoa[] port提供的[.filename]##ppp.conf##样例。

=== 使用mpd

可以使用 mpd 来连接多种类型的服务， 特别是 PPTP 服务。 您可以在 Ports Collection 中找到 mpd， 它的位置是 package:net/mpd[]。 许多 ADSL modem 需要在 modem 和计算机之间建立一条 PPTP 隧道， 而阿尔卡特 SpeedTouch(TM) Home 正是其中的一种。

首先需要从 port 完成安装， 然后才能配置 mpd 来满足您的需要， 并完成服务商的配置。 port 会把一系列包括了详细注解的配置文件实例放到 [.filename]#PREFIX/etc/mpd/#。 注意， 这里的 _PREFIX_ 表示 ports 安装的目录， 默认情况下， 应该是 [.filename]#/usr/local/#。 关于配置 mpd 的完整说明， 会以 HTML 格式随 port 一起安装。 这些文件将放在 [.filename]#PREFIX/shared/doc/mpd/#。 下面是通过 mpd 连接 ADSL 服务的一个简单例子。 配置被分别放到了两个文件中， 第一个是 [.filename]#mpd.conf#：

[.programlisting]
....
default:
    load adsl

adsl:
    new -i ng0 adsl adsl
    set bundle authname username <.>
    set bundle password password <.>
    set bundle disable multilink

    set link no pap acfcomp protocomp
    set link disable chap
    set link accept chap
    set link keep-alive 30 10

    set ipcp no vjcomp
    set ipcp ranges 0.0.0.0/0 0.0.0.0/0

    set iface route default
    set iface disable on-demand
    set iface enable proxy-arp
    set iface idle 0

    open
....

<.> username用来向您的ISP进行验证。

<.> password用来向您的ISP进行验证。

[.filename]##mpd.links##包含连接的信息：

[.programlisting]
....
adsl:
    set link type pptp
    set pptp mode active
    set pptp enable originate outcall
    set pptp self 10.0.0.1 <.>
    set pptp peer 10.0.0.138 <.>
....

<.> 运行mpd的主机的IP地址。

<.> ADSL modem的IP地址。 Alcatel SpeedTouch(TM) Home 默认的是 `10.0.0.138`。

初始化连接：

[source,shell]
....
# mpd -b adsl
....

您可以通过以下命令查看连接状态：

[source,shell]
....
% ifconfig ng0
ng0: flags=88d1<UP,POINTOPOINT,RUNNING,NOARP,SIMPLEX,MULTICAST> mtu 1500
     inet 216.136.204.117 --> 204.152.186.171 netmask 0xffffffff
....

使用mpd连接ADSL服务是推荐的方式。

=== 使用pptpclient

也可以使用package:net/pptpclient[]连接其它的 PPPoA。

要使用 package:net/pptpclient[] 连接 DSL 服务， 需要安装 port 或 package 并编辑 [.filename]#/etc/ppp/ppp.conf#。 您需要有 `root` 权限才能完成这两项操作。 以下是 [.filename]#ppp.conf# 中的一个示例项。 参考 ppp 的联机手册 man:ppp[8]， 以了解更多有关 [.filename]#ppp.conf# 选项的信息。

[.programlisting]
....
adsl:
 set log phase chat lcp ipcp ccp tun command
 set timeout 0
 enable dns
 set authname username <.>
 set authkey password <.>
 set ifaddr 0 0
 add default HISADDR
....

<.> 您在 DSL 服务提供商那里的用户名

<.> 您帐户的口令。

[WARNING]
====

由于您必须将帐号密码以明文的方式放入[.filename]##ppp.conf## 您应该确保没有任何人能看到此文件的内容。 以下一系列命令将会确保此文件只对 ``root``用户可读。 请参见 man:chmod[1] 和 man:chown[8] 的联机手册以了解有关如何操作的进一步信息。

[source,shell]
....
# chown root:wheel /etc/ppp/ppp.conf
# chmod 600 /etc/ppp/ppp.conf
....

====

以下将为到 DSL 路由器的会话打开一个 tunnel。 以太网DSL modem有一个设置的局域网IP地址。 以 Alcatel SpeedTouch(TM) Home 为例， 这个地址是 `10.0.0.138`。 路由器的文档应该会告诉您它使用的地址。 执行以下命令以打开 tunnel 并开始会话：

[source,shell]
....
# pptp address adsl
....

[TIP]
====

您应该在命令的最后加上("&")号， 否则 pptp 无法返回到命令行提示符。
====

要创建一个 [.filename]##tun##虚拟设备用于进程pptp 和ppp 之间的交互。 一旦您回到了命令行， 或者 pptp 进程确认了一个连接， 您可以这样检查tunnel设备：

[source,shell]
....
% ifconfig tun0
tun0: flags=8051<UP,POINTOPOINT,RUNNING,MULTICAST> mtu 1500
        inet 216.136.204.21 --> 204.152.186.171 netmask 0xffffff00
        Opened by PID 918
....

如果您无法连接， 一般可以通过telnet或者web浏览器检查路由器(modem)的配置。 如果依旧无法连接， 您应该检查``pptp``的输出及ppp的日志文件 [.filename]#/var/log/ppp.log# 以获得线索。

[[slip]]
== 使用SLIP

[WARNING]
====

这节内容只在 FreeBSD 7.X 上可用。
====

[[slipc]]
=== 设置 SLIP 客户端

下面是在静态主机网络上配置 FreeBSD 机器使用 SLIP 的方法。 对于动态主机名分配 (您的地址会随每次拨号而不同)， 您可能需要稍复杂一些的设置。

首先， 您需要确认调制解调器所连接的串口。 许多人会设置一个符号连接， 例如 [.filename]#/dev/modem#， 用以指向实际的设备名， 如 [.filename]#/dev/cuadN#。 这样您就可以对实际的设备名进行抽象， 以备调制解调器换到其他串口时方便调整之用。 不然， 修改 [.filename]#/etc# 和遍布于系统中的 [.filename]#.kermrc# 文件将是一件很麻烦的事情！

[NOTE]
====
[.filename]#/dev/cuad0# 对应 [.filename]#COM1#， 而 [.filename]#/dev/cuad1# 则对应 [.filename]#COM2#， 等等。
====

确保您的内核文件包含以下内容：

[.programlisting]
....
device   sl
....

这包含在[.filename]##GENERIC##内核， 所以这应该不会是个问题， 除非您 已经删除了它。

==== 只需做一次的事情

[.procedure]
====

. 把您本地网络上的机器、 网关以及域名服务器， 都加入到 [.filename]#/etc/hosts# 文件中。 我们的是下面这个样子：
+
[.programlisting]
....
127.0.0.1               localhost loghost
136.152.64.181          water.CS.Example.EDU water.CS water
136.152.64.1            inr-3.CS.Example.EDU inr-3 slip-gateway
128.32.136.9            ns1.Example.EDU ns1
128.32.136.12           ns2.Example.EDU ns2
....
+
. 请确保在您的 [.filename]#/etc/nsswitch.conf# 中的 `hosts:` 小节里面， `files` 先于 `dns` 出现。 如果不是这样的话， 可能会产生一些不希望的现象。
. 编辑[.filename]##/etc/rc.conf##。
.. 编辑以下这行设置主机名(hostname)：
+
[.programlisting]
....
hostname="myname.my.domain"
....
+ 
应该用您主机的Internet全名代替。
..
+ 
改变这一行以指明默认的路由：
+
[.programlisting]
....
defaultrouter="NO"
....
+ 
改为：
+
[.programlisting]
....
defaultrouter="slip-gateway"
....
+
. 创建文件[.filename]##/etc/resolv.conf##， 写入以下内容：
+
[.programlisting]
....
domain CS.Example.EDU
nameserver 128.32.136.9
nameserver 128.32.136.12
....
+ 
正如您看到的， 这些行设置了域名服务器。 当然， 实际的域名和IP地址取决于您的环境。
. 设置``root``和 ``toor``的密码(其它任何没有密码的帐号)。
. 重启计算机， 然后确认使用了正确的主机名。
====

==== 创建一个SLIP连接

[.procedure]
====

. 在命令提示符之后输入 ``slip`` 进行拨号， 输入您的机器名和口令。 具体需要输入什么， 与您的环境密切相关。 如果使用 Kermit， 则可以使用类似下面的脚本：
+
[.programlisting]
....
# kermit setup
set modem hayes
set line /dev/modem
set speed 115200
set parity none
set flow rts/cts
set terminal bytesize 8
set file type binary
# The next macro will dial up and login
define slip dial 643-9600, input 10 =>, if failure stop, -
output slip\x0d, input 10 Username:, if failure stop, -
output silvia\x0d, input 10 Password:, if failure stop, -
output ***\x0d, echo \x0aCONNECTED\x0a
....
+ 
当然， 您还需要修改用户名和口令来满足实际需要。 完成这些操作之后， 只需在 Kermit 提示符之后输入 `slip` 就可以连接了。
+
[NOTE]
======
将密码以纯文本的形式存放在文件系统无论如何都是个 _坏_ 主意。 请考虑这样做的风险。
======
+
. 在这里退出 Kermit (也可以用 kbd:[Ctrl+z] 将其挂起)， 以 `root` 用户键入：
+
[source,shell]
....
# slattach -h -c -s 115200 /dev/modem
....
+ 
如果您能``ping``通路由器另一端的主机， 就是连接好了! 如果不行， 您可以使用``-a``选项代替 ``-c``作为``slattach``的参数。
====

==== 关闭连接

按下面的步骤做：

[source,shell]
....
# kill -INT `cat /var/run/slattach.modem.pid`
....

来杀掉 `slattach`。 切记上述操作只有以 `root` 身份才能完成。 接下来回到 `kermit` (如果之前是将它挂起了， 则使用 `fg`) 并退出 (kbd:[q])。

在 man:slattach[8] 联机手册中提到， 必须使用 `ifconfig sl0 down` 才能将接口标记为关闭， 但和这样做似乎没有什么区别。 (`ifconfig sl0` 仍然报告同样的东西。)

有时， 您的 modem 可能会拒绝挂断。 这种情况下， 只需重新启动 `kermit` 并再次退出它就可以了。 一般来说试二次就可以了。

==== 问题解答

如果还不行， 尽管发邮件到 link:{freebsd-net-url}[freebsd-net] 邮件列表来提问。 常见的问题包括：

* 执行 ``slattach`` 时不使用 ``-c``和``-a``选项 (这应该不是关键的， 但有些用户报告这样做解决了问题)。
* 使用``s10``替换 ``sl0`` (在一些字体下很难看出不同)。
* 试试``ifconfig sl0``来查看您的接口状态。 例如， 您可以这样做：
+
[source,shell]
....
# ifconfig sl0
sl0: flags=10<POINTOPOINT>
        inet 136.152.64.181 --> 136.152.64.1 netmask ffffff00
....

* 如果在使用 man:ping[8] 时得到了 `no route to host` 这样的提示， 则说明您的路由表可能有问题。 可以用 `netstat -r` 命令来显示当前的路由：
+
[source,shell]
....
# netstat -r
Routing tables
Destination      Gateway            Flags     Refs     Use  IfaceMTU    Rtt    Netmasks:

(root node)
(root node)

Route Tree for Protocol Family inet:
(root node) =>
default          inr-3.Example.EDU  UG          8   224515  sl0 -      -
localhost.Exampl localhost.Example. UH          5    42127  lo0 -       0.438
inr-3.Example.ED water.CS.Example.E UH          1        0  sl0 -      -
water.CS.Example localhost.Example. UGH        34 47641234  lo0 -       0.438
(root node)
....
+ 
前述的例子来自于一个非常繁忙的系统。 您系统上的这些数字会因网络活动的不同而改变。

[[slips]]
=== 设置SLIP服务器

本文提供了在 FreeBSD 上设置 SLIP 服务， 也就是如何配置您的系统， 使其能在远程 SLIP 客户端登录时自动地开启连接的建议。

[[slips-prereqs]]
==== 前提条件

这一节技术性很强， 所以要求您有一定的背景知识。 本节假定您熟悉 TCP/IP 网络协议， 特别是网络和节点寻址、 子网掩码、 子网划分、 路由、 路由协议 (如RIP) 等知识。 在拨号服务器上配置 SLIP 需要这些概念性的知识。 如果您不熟悉它们， 请先阅读 Craig Hunt 的 _TCP/IP 网络管理_ 由O'Reilly & Associates, Inc. 出版 (ISBN 0-937175-82-X)， 或 Douglas Comer 有关 TCP/IP 协议的书籍。

此外还假定您已经配置好了您的调制解调器以及相应的系统文件， 以允许通过调制解调器进行登录。 如果您还没有为此配置好系统， 请参见 crossref:serialcomms:[dialup,拨入服务] 以了解关于如何进行拨号服务的配置。 您可能也会想看一看 man:sio[4] 的联机手册， 以了解关于串口设备驱动的进一步信息， 以及 man:ttys[5]、 man:gettytab[5]、 man:getty[8] & man:init[8] 上关于怎样配置系统来接受来自调制解调器的登录请求的具体情况， 还有 man:stty[1] 以了解关于设置串口参数 (例如 `clocal` 表示串口直联) 等。

==== 快速浏览

使用FreeBSD作为SLIP服务器， 在典型配置时， 它是这样工作的： 一个SLIP客户拨号并以专用的login ID登录到FreeBSD SLIP服务器系统。 这个用户使用 [.filename]#/usr/sbin/sliplogin# 作为 shell。 `sliplogin` 程序会在文件 [.filename]#/etc/sliphome/slip.hosts# 中查找这个用户的项， 如果找到了匹配项， 就将串行线连接到一个可用的 SLIP 接口， 然后运行 shell 脚本 [.filename]#/etc/sliphome/slip.login# 以配置 SLIP 接口。

===== 一个SLIP服务器登录的例子

例如， 如果一个SLIP用户的ID是``Shelmerg``， 在[.filename]##/etc/master.passwd##中``Shelmerg``的项如下的所示：

[.programlisting]
....
Shelmerg:password:1964:89::0:0:Guy Helmer - SLIP:/usr/users/Shelmerg:/usr/sbin/sliplogin
....

``Shelmerg``登录时， ``sliplogin``在文件 [.filename]##/etc/sliphome/slip.hosts##中搜索与用户ID匹配的行;如下所示：

[.programlisting]
....
Shelmerg        dc-slip sl-helmer       0xfffffc00		  autocomp
....

``sliplogin``找到这条区配行， 并将串行线与另一个可用的SLIP接口连起来， 然后执行[.filename]##/etc/sliphome/slip.login##脚本：

[.programlisting]
....
/etc/sliphome/slip.login 0 19200 Shelmerg dc-slip sl-helmer 0xfffffc00 autocomp
....

如果一切顺利 [.filename]#/etc/sliphome/slip.login# 将在 ``sliplogin`` 绑定的 SLIP 接口上发出 `ifconfig` (前述的例子中是 SLIP 接口 0， 这是 [.filename]#slip.login# 的第一个参数)， 以设置本地 IP 地址 (`dc-slip`)、 远程 IP 地址 (`sl-helmer`)、 这一 SLIP 接口的子网掩码 (`0xfffffc00`)， 以及任何其他标志 (`autocomp`)。 如果发生错误， `sliplogin` 通常会通过 syslogd 的 daemon facility 记下有用的信息， 前者会把这些信息保存到 [.filename]#/var/log/messages# (参见 man:syslogd[8] 和 man:syslog.conf[5] 以及 [.filename]#/etc/syslog.conf# 的联机手册， 以了解 syslogd 在记录什么， 以及这些内容将被记在哪里)。

==== 内核配置

FreeBSD 的默认内核 ([.filename]#GENERIC#) 提供了 SLIP (man:sl[4]) 支持； 使用定制的内核时， 您必须把下面的设置加入到配置文件：

[.programlisting]
....
device   sl
....

默认情况下， 您的 FreeBSD 计算机不会转发包。 如果您希望将 FreeBSD SLIP 服务器作为路由器使用， 就需要修改 [.filename]#/etc/rc.conf# 文件， 将 `gateway_enable` 变量设为 `YES`。 这样下次系统引导时就能够保持这一配置了。

要立即应用这些配置， 可以 `root` 的身份运行：

[source,shell]
....
# /etc/rc.d/routing start
....

请参阅 crossref:kernelconfig[kernelconfig,配置FreeBSD的内核] 以了解如何配置 FreeBSD 内核， 并获得在重新配置内核方面的指导。

==== Sliplogin配置

正如先前所提到的， [.filename]#/etc/sliphome# 目录中有三个文件， 它们共同构成 [.filename]#/usr/sbin/sliplogin# 的配置 (参考 `sliplogin` 的联机手册 man:sliplogin[8])： 用于定义 SLIP 用户和相关的 IP 地址的 [.filename]#slip.hosts#、 通常仅用于配置 SLIP 接口的 [.filename]#slip.login#， 以及 (可选的) [.filename]#slip.logout#， 用以撤销由 [.filename]#slip.login# 所执行的动作。

===== 配置 [.filename]#slip.hosts#

[.filename]##/etc/sliphome/slip.hosts##里的每行包含至少四个元素， 元素之间由空格隔开：

* SLIP用户的登录ID
* SLIP连接的本地地址(指SLIP服务器)
* SLIP连接的远程地址
* 网络掩网

本地和远程地址可以是主机名 (通过文件[.filename]##/etc/hosts##或者域名服务解析为IP地址， 这取决于文件[.filename]##/etc/nsswitch.conf## 中的设置)， 网络掩网可以是一个 能通过文件[.filename]##/etc/networks##解析的名字。 在一个样例系统中， [.filename]##/etc/sliphome/slip.hosts##是这样的：

[.programlisting]
....
#
# login local-addr      remote-addr     mask            opt1    opt2
#                                               (normal,compress,noicmp)
#
Shelmerg  dc-slip       sl-helmerg      0xfffffc00      autocomp
....

在这行末尾是一或多个选项：

* `normal` -不压缩报头 
* `compress` - 压缩报头
* `autocomp` -如果远程端允许， 压缩报头
* `noicmp` -禁用ICMP数据包 (这样就会丢弃所有的"ping"数据包， 不占用您的带宽)

对SLIP连接的本地及远程地址的选择取决是您是准备在SLIP服务器上使用 TCP/IP 子网还是使用"ARP代理" (它并不是"真正的"ARP代理， 而是我们在本节用于介绍的术语)。 如果您不能确定选择何种方式或者如何分配地址， 请参考"前提条件"(<<slips-prereqs>>)里列出的TCP/IP书籍 或者向您的IP网络管理员请教。

如果打算为您的 SLIP 客户使用一个独立的子网， 就需要先从分配得到的网络号中取出一个子网号， 然后再在这个子网里给每个 SLIP 客户分配 IP 地址。 接下来， 您还需要通过 SLIP 服务器在最近的 IP 路由器上配置一个指向 SLIP 子网的静态路由。

如果要使用 "代理 ARP" 的方式， 您还需要从 SLIP 服务器的以太子网中为每个 SLIP 客户分配IP地址， 还必须修改[.filename]##/etc/sliphome/slip.login## 和 [.filename]##/etc/sliphome/slip.logout##脚本以使用 man:arp[8]来管理在 SLIP 服务器 ARP 表中的 "代理 ARP" 项。

===== [.filename]#slip.login# Configuration

典型的[.filename]##/etc/sliphome/slip.login## 如下所示：

[.programlisting]
....
#!/bin/sh -
#
#       @(#)slip.login  5.1 (Berkeley) 7/1/90

#
# generic login file for a slip line.  sliplogin invokes this with
# the parameters:
#      1        2         3        4          5         6     7-n
#   slipunit ttyspeed loginname local-addr remote-addr mask opt-args
#
/sbin/ifconfig sl$1 inet $4 $5 netmask $6
....

这个[.filename]##slip.login##脚本仅仅为带有相应本地及远程地址和掩码的SLIP接口执行 `ifconfig`。

如果您决定使用"ARP代理" 方式(而非为您的SLIP客户使用独立的子网)， 您的[.filename]##/etc/sliphome/slip.login## 应该是这样：

[.programlisting]
....
#!/bin/sh -
#
#       @(#)slip.login  5.1 (Berkeley) 7/1/90

#
# generic login file for a slip line.  sliplogin invokes this with
# the parameters:
#      1        2         3        4          5         6     7-n
#   slipunit ttyspeed loginname local-addr remote-addr mask opt-args
#
/sbin/ifconfig sl$1 inet $4 $5 netmask $6
# Answer ARP requests for the SLIP client with our Ethernet addr
/usr/sbin/arp -s $5 00:11:22:33:44:55 pub
....

[.filename]##slip.login##新加的行``arp -s $5 00:11:22:33:44:55 pub`` 在 SLIP 服务器的 ARP 表中加入了一个表项。 这个ARP项使得每当这个以太网上的其它 IP 节点对 SLIP 客户端 IP 地址进行 ARP 请求时， SLIP 服务器会以自已的以太网MAC地址作为回应。

当使用以上的例子时， 一定要将 以太网MAC地址 （``00:11:22:33:44:55``） 替换成您系统网卡的MAC地址， 否则"ARP代理" 将完全无法工作！ 您可以查看 ``netstat -i`` 输出结果以取得以太网 MAC 地址; 输出的第二行应该是这样：

[source,shell]
....
ed0   1500  <Link>0.2.c1.28.5f.4a         191923	0   129457     0   116
....

这行表明这个系统的以太网MAC地址是``00:02:c1:28:5f:4a`` -``netstat -i``输出的以太网MAC地址必须改成用冒号隔开， 并且要单个十六进数前加上。 这是man:arp[8]要求的格式; 参考man:arp[8] 的联机手册以获取完整的使用方法。

[NOTE]
====
在编写 [.filename]#/etc/sliphome/slip.login# 和 [.filename]#/etc/sliphome/slip.logout# 时， 一定要设置 "可执行" (execute) 位 (换言之， ``chmod 755 /etc/sliphome/slip.login /etc/sliphome/slip.logout``)， 否则 ``sliplogin``将无法执行它。
====

===== [.filename]##slip.logout##配置

[.filename]##/etc/sliphome/slip.logout##并不是必需的 (除非您使用了"ARP代理")， 如果您准备创建它， 这里有一个基本的 [.filename]##slip.logout## 脚本的例子：

[.programlisting]
....
#!/bin/sh -
#
#       slip.logout

#
# logout file for a slip line.  sliplogin invokes this with
# the parameters:
#      1        2         3        4          5         6     7-n
#   slipunit ttyspeed loginname local-addr remote-addr mask opt-args
#
/sbin/ifconfig sl$1 down
....

如果使用了 "代理 ARP"， 则可能希望 [.filename]#/etc/sliphome/slip.logout# 在用户注销时自动为 SLIP 客户端删除 ARP 项：

[.programlisting]
....
#!/bin/sh -
#
#       @(#)slip.logout

#
# logout file for a slip line.  sliplogin invokes this with
# the parameters:
#      1        2         3        4          5         6     7-n
#   slipunit ttyspeed loginname local-addr remote-addr mask opt-args
#
/sbin/ifconfig sl$1 down
# Quit answering ARP requests for the SLIP client
/usr/sbin/arp -d $5
....

`arp -d $5` 将删除由 "代理 ARP"[.filename]#slip.login# 在 SLIP 客户程序登录时所生成的 ARP 项。

再次强调： 建立 [.filename]#/etc/sliphome/slip.logout# 之后， 一定要设置可执行位 (也就是说， `chmod 755 /etc/sliphome/slip.logout`)。

==== 路由考虑

如果没有使用 "代理 ARP" 的方法来在您的 SLIP 客户机和网络的其余部分 (也可能是 Internet) 之间路由数据包， 您可能需要增加离您最近的默认路由器的静态路由， 以便通过 SLIP 服务器来在 SLIP 客户机子网上进行路由。

===== 静态路由

向您最近的默认路由添加一个静态路由可以说是很麻烦 (或者说是不可能， 如果您没有权限这么做)。 如果在您的组织中使用多路由器网络， 有些路由器 (比如 Cisco 和 Proteon 生产的) 不但要配置指向 SLIP 子网的路由， 而且还需要配置将哪些静态路由传给其它的路由器。 所以一些专家意见和问题解答对于使基于静态路由表的路由正常工作很有必要。
