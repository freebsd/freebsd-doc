---
title: Chapter 6. The TrustedBSD MAC Framework
authors: 
  - author: Chris Costello
    email: chris@FreeBSD.org
  - author: Robert Watson
    email: rwatson@FreeBSD.org
prev: books/arch-handbook/sysinit
next: books/arch-handbook/vm
---

[[mac]]
= The TrustedBSD MAC Framework
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:source-highlighter: rouge
:experimental:
:skip-front-matter:
:xrefstyle: basic
:relfileprefix: ../
:outfilesuffix:
:sectnumoffset: 6

include::shared/mirrors.adoc[]
include::shared/authors.adoc[]
include::shared/releases.adoc[]
include::shared/en/mailing-lists.adoc[]
include::shared/en/teams.adoc[]
include::shared/en/urls.adoc[]

toc::[]

[[mac-copyright]]
== MAC Documentation Copyright

This documentation was developed for the FreeBSD Project by Chris Costello at Safeport Network Services and Network Associates Laboratories, the Security Research Division of Network Associates, Inc. under DARPA/SPAWAR contract N66001-01-C-8035 ("CBOSS"), as part of the DARPA CHATS research program.

Redistribution and use in source (SGML DocBook) and 'compiled' forms (SGML, HTML, PDF, PostScript, RTF and so forth) with or without modification, are permitted provided that the following conditions are met:

. Redistributions of source code (SGML DocBook) must retain the above copyright notice, this list of conditions and the following disclaimer as the first lines of this file unmodified.
. Redistributions in compiled form (transformed to other DTDs, converted to PDF, PostScript, RTF and other formats) must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

[IMPORTANT]
====
THIS DOCUMENTATION IS PROVIDED BY THE NETWORKS ASSOCIATES TECHNOLOGY, INC "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETWORKS ASSOCIATES TECHNOLOGY, INC BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS DOCUMENTATION, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
====

[[mac-synopsis]]
== Synopsis

FreeBSD includes experimental support for several mandatory access control policies, as well as a framework for kernel security extensibility, the TrustedBSD MAC Framework. The MAC Framework is a pluggable access control framework, permitting new security policies to be easily linked into the kernel, loaded at boot, or loaded dynamically at run-time. The framework provides a variety of features to make it easier to implement new security policies, including the ability to easily tag security labels (such as confidentiality information) onto system objects.

This chapter introduces the MAC policy framework and provides documentation for a sample MAC policy module.

[[mac-introduction]]
== Introduction

The TrustedBSD MAC framework provides a mechanism to allow the compile-time or run-time extension of the kernel access control model. New system policies may be implemented as kernel modules and linked to the kernel; if multiple policy modules are present, their results will be composed. The MAC Framework provides a variety of access control infrastructure services to assist policy writers, including support for transient and persistent policy-agnostic object security labels. This support is currently considered experimental.

This chapter provides information appropriate for developers of policy modules, as well as potential consumers of MAC-enabled environments, to learn about how the MAC Framework supports access control extension of the kernel.

[[mac-background]]
== Policy Background

Mandatory Access Control (MAC), refers to a set of access control policies that are mandatorily enforced on users by the operating system. MAC policies may be contrasted with Discretionary Access Control (DAC) protections, by which non-administrative users may (at their discretion) protect objects. In traditional UNIX systems, DAC protections include file permissions and access control lists; MAC protections include process controls preventing inter-user debugging and firewalls. A variety of MAC policies have been formulated by operating system designers and security researches, including the Multi-Level Security (MLS) confidentiality policy, the Biba integrity policy, Role-Based Access Control (RBAC), Domain and Type Enforcement (DTE), and Type Enforcement (TE). Each model bases decisions on a variety of factors, including user identity, role, and security clearance, as well as security labels on objects representing concepts such as data sensitivity and integrity.

The TrustedBSD MAC Framework is capable of supporting policy modules that implement all of these policies, as well as a broad class of system hardening policies, which may use existing security attributes, such as user and group IDs, as well as extended attributes on files, and other system properties. In addition, despite the name, the MAC Framework can also be used to implement purely discretionary policies, as policy modules are given substantial flexibility in how they authorize protections.

[[mac-framework-kernel-arch]]
== MAC Framework Kernel Architecture

The TrustedBSD MAC Framework permits kernel modules to extend the operating system security policy, as well as providing infrastructure functionality required by many access control modules. If multiple policies are simultaneously loaded, the MAC Framework will usefully (for some definition of useful) compose the results of the policies.

[[mac-framework-kernel-arch-elements]]
=== Kernel Elements

The MAC Framework contains a number of kernel elements:

* Framework management interfaces
* Concurrency and synchronization primitives.
* Policy registration
* Extensible security label for kernel objects
* Policy entry point composition operators
* Label management primitives
* Entry point API invoked by kernel services
* Entry point API to policy modules
* Entry points implementations (policy life cycle, object life cycle/label management, access control checks).
* Policy-agnostic label-management system calls
* `mac_syscall()` multiplex system call
* Various security policies implemented as MAC policy modules

[[mac-framework-kernel-arch-management]]
=== Framework Management Interfaces

The TrustedBSD MAC Framework may be directly managed using sysctl's, loader tunables, and system calls.

In most cases, sysctl's and loader tunables of the same name modify the same parameters, and control behavior such as enforcement of protections relating to various kernel subsystems. In addition, if MAC debugging support is compiled into the kernel, several counters will be maintained tracking label allocation. It is generally advisable that per-subsystem enforcement controls not be used to control policy behavior in production environments, as they broadly impact the operation of all active policies. Instead, per-policy controls should be preferred, as they provide greater granularity and greater operational consistency for policy modules.

Loading and unloading of policy modules is performed using the system module management system calls and other system interfaces, including boot loader variables; policy modules will have the opportunity to influence load and unload events, including preventing undesired unloading of the policy.

[[mac-framework-kernel-arch-synchronization]]
=== Policy List Concurrency and Synchronization

As the set of active policies may change at run-time, and the invocation of entry points is non-atomic, synchronization is required to prevent loading or unloading of policies while an entry point invocation is in progress, freezing the set of active policies for the duration. This is accomplished by means of a framework busy count: whenever an entry point is entered, the busy count is incremented; whenever it is exited, the busy count is decremented. While the busy count is elevated, policy list changes are not permitted, and threads attempting to modify the policy list will sleep until the list is not busy. The busy count is protected by a mutex, and a condition variable is used to wake up sleepers waiting on policy list modifications. One side effect of this synchronization model is that recursion into the MAC Framework from within a policy module is permitted, although not generally used.

Various optimizations are used to reduce the overhead of the busy count, including avoiding the full cost of incrementing and decrementing if the list is empty or contains only static entries (policies that are loaded before the system starts, and cannot be unloaded). A compile-time option is also provided which prevents any change in the set of loaded policies at run-time, which eliminates the mutex locking costs associated with supporting dynamically loaded and unloaded policies as synchronization is no longer required.

As the MAC Framework is not permitted to block in some entry points, a normal sleep lock cannot be used; as a result, it is possible for the load or unload attempt to block for a substantial period of time waiting for the framework to become idle.

[[mac-framework-kernel-arch-label-synchronization]]
=== Label Synchronization

As kernel objects of interest may generally be accessed from more than one thread at a time, and simultaneous entry of more than one thread into the MAC Framework is permitted, security attribute storage maintained by the MAC Framework is carefully synchronized. In general, existing kernel synchronization on kernel object data is used to protect MAC Framework security labels on the object: for example, MAC labels on sockets are protected using the existing socket mutex. Likewise, semantics for concurrent access are generally identical to those of the container objects: for credentials, copy-on-write semantics are maintained for label contents as with the remainder of the credential structure. The MAC Framework asserts necessary locks on objects when invoked with an object reference. Policy authors must be aware of these synchronization semantics, as they will sometimes limit the types of accesses permitted on labels: for example, when a read-only reference to a credential is passed to a policy via an entry point, only read operations are permitted on the label state attached to the credential.

[[mac-framework-kernel-arch-policy-synchronization]]
=== Policy Synchronization and Concurrency

Policy modules must be written to assume that many kernel threads may simultaneously enter one more policy entry points due to the parallel and preemptive nature of the FreeBSD kernel. If the policy module makes use of mutable state, this may require the use of synchronization primitives within the policy to prevent inconsistent views on that state resulting in incorrect operation of the policy. Policies will generally be able to make use of existing FreeBSD synchronization primitives for this purpose, including mutexes, sleep locks, condition variables, and counting semaphores. However, policies should be written to employ these primitives carefully, respecting existing kernel lock orders, and recognizing that some entry points are not permitted to sleep, limiting the use of primitives in those entry points to mutexes and wakeup operations.

When policy modules call out to other kernel subsystems, they will generally need to release any in-policy locks in order to avoid violating the kernel lock order or risking lock recursion. This will maintain policy locks as leaf locks in the global lock order, helping to avoid deadlock.

[[mac-framework-kernel-arch-registration]]
=== Policy Registration

The MAC Framework maintains two lists of active policies: a static list, and a dynamic list. The lists differ only with regards to their locking semantics: an elevated reference count is not required to make use of the static list. When kernel modules containing MAC Framework policies are loaded, the policy module will use `SYSINIT` to invoke a registration function; when a policy module is unloaded, `SYSINIT` will likewise invoke a de-registration function. Registration may fail if a policy module is loaded more than once, if insufficient resources are available for the registration (for example, the policy might require labeling and insufficient labeling state might be available), or other policy prerequisites might not be met (some policies may only be loaded prior to boot). Likewise, de-registration may fail if a policy is flagged as not unloadable.

[[mac-framework-kernel-arch-entrypoints]]
=== Entry Points

Kernel services interact with the MAC Framework in two ways: they invoke a series of APIs to notify the framework of relevant events, and they provide a policy-agnostic label structure pointer in security-relevant objects. The label pointer is maintained by the MAC Framework via label management entry points, and permits the Framework to offer a labeling service to policy modules through relatively non-invasive changes to the kernel subsystem maintaining the object. For example, label pointers have been added to processes, process credentials, sockets, pipes, vnodes, Mbufs, network interfaces, IP reassembly queues, and a variety of other security-relevant structures. Kernel services also invoke the MAC Framework when they perform important security decisions, permitting policy modules to augment those decisions based on their own criteria (possibly including data stored in security labels). Most of these security critical decisions will be explicit access control checks; however, some affect more general decision functions such as packet matching for sockets and label transition at program execution.

[[mac-framework-kernel-arch-composition]]
=== Policy Composition

When more than one policy module is loaded into the kernel at a time, the results of the policy modules will be composed by the framework using a composition operator. This operator is currently hard-coded, and requires that all active policies must approve a request for it to return success. As policies may return a variety of error conditions (success, access denied, object does not exist, ...), a precedence operator selects the resulting error from the set of errors returned by policies. In general, errors indicating that an object does not exist will be preferred to errors indicating that access to an object is denied. While it is not guaranteed that the resulting composition will be useful or secure, we have found that it is for many useful selections of policies. For example, traditional trusted systems often ship with two or more policies using a similar composition.

[[mac-framework-kernel-arch-labels]]
=== Labeling Support

As many interesting access control extensions rely on security labels on objects, the MAC Framework provides a set of policy-agnostic label management system calls covering a variety of user-exposed objects. Common label types include partition identifiers, sensitivity labels, integrity labels, compartments, domains, roles, and types. By policy agnostic, we mean that policy modules are able to completely define the semantics of meta-data associated with an object. Policy modules participate in the internalization and externalization of string-based labels provides by user applications, and can expose multiple label elements to applications if desired.

In-memory labels are stored in slab-allocated `struct label`, which consists of a fixed-length array of unions, each holding a `void *` pointer and a `long`. Policies registering for label storage will be assigned a "slot" identifier, which may be used to dereference the label storage. The semantics of the storage are left entirely up to the policy module: modules are provided with a variety of entry points associated with the kernel object life cycle, including initialization, association/creation, and destruction. Using these interfaces, it is possible to implement reference counting and other storage models. Direct access to the object structure is generally not required by policy modules to retrieve a label, as the MAC Framework generally passes both a pointer to the object and a direct pointer to the object's label into entry points. The primary exception to this rule is the process credential, which must be manually dereferenced to access the credential label. This may change in future revisions of the MAC Framework.

Initialization entry points frequently include a sleeping disposition flag indicating whether or not an initialization is permitted to sleep; if sleeping is not permitted, a failure may be returned to cancel allocation of the label (and hence object). This may occur, for example, in the network stack during interrupt handling, where sleeping is not permitted, or while the caller holds a mutex. Due to the performance cost of maintaining labels on in-flight network packets (Mbufs), policies must specifically declare a requirement that Mbuf labels be allocated. Dynamically loaded policies making use of labels must be able to handle the case where their init function has not been called on an object, as objects may already exist when the policy is loaded. The MAC Framework guarantees that uninitialized label slots will hold a 0 or NULL value, which policies may use to detect uninitialized values. However, as allocation of Mbuf labels is conditional, policies must also be able to handle a NULL label pointer for Mbufs if they have been loaded dynamically.

In the case of file system labels, special support is provided for the persistent storage of security labels in extended attributes. Where available, extended attribute transactions are used to permit consistent compound updates of security labels on vnodes--currently this support is present only in the UFS2 file system. Policy authors may choose to implement multilabel file system object labels using one (or more) extended attributes. For efficiency reasons, the vnode label (`v_label`) is a cache of any on-disk label; policies are able to load values into the cache when the vnode is instantiated, and update the cache as needed. As a result, the extended attribute need not be directly accessed with every access control check.

[NOTE]
====
Currently, if a labeled policy permits dynamic unloading, its state slot cannot be reclaimed, which places a strict (and relatively low) bound on the number of unload-reload operations for labeled policies.
====

[[mac-framework-kernel-arch-syscalls]]
=== System Calls

The MAC Framework implements a number of system calls: most of these calls support the policy-agnostic label retrieval and manipulation APIs exposed to user applications.

The label management calls accept a label description structure, `struct mac`, which contains a series of MAC label elements. Each element contains a character string name, and character string value. Each policy will be given the chance to claim a particular element name, permitting policies to expose multiple independent elements if desired. Policy modules perform the internalization and externalization between kernel labels and user-provided labels via entry points, permitting a variety of semantics. Label management system calls are generally wrapped by user library functions to perform memory allocation and error handling, simplifying user applications that must manage labels.

The following MAC-related system calls are present in the FreeBSD kernel:

* `mac_get_proc()` may be used to retrieve the label of the current process.
* `mac_set_proc()` may be used to request a change in the label of the current process.
* `mac_get_fd()` may be used to retrieve the label of an object (file, socket, pipe, ...) referenced by a file descriptor.
* `mac_get_file()` may be used to retrieve the label of an object referenced by a file system path.
* `mac_set_fd()` may be used to request a change in the label of an object (file, socket, pipe, ...) referenced by a file descriptor.
* `mac_set_file()` may be used to request a change in the label of an object referenced by a file system path.
* `mac_syscall()` permits policy modules to create new system calls without modifying the system call table; it accepts a target policy name, operation number, and opaque argument for use by the policy.
* `mac_get_pid()` may be used to request the label of another process by process id.
* `mac_get_link()` is identical to `mac_get_file()`, only it will not follow a symbolic link if it is the final entry in the path, so may be used to retrieve the label on a symlink.
* `mac_set_link()` is identical to `mac_set_file()`, only it will not follow a symbolic link if it is the final entry in a path, so may be used to manipulate the label on a symlink.
* `mac_execve()` is identical to the `execve()` system call, only it also accepts a requested label to set the process label to when beginning execution of a new program. This change in label on execution is referred to as a "transition".
* `mac_get_peer()`, actually implemented via a socket option, retrieves the label of a remote peer on a socket, if available.

In addition to these system calls, the `SIOCSIGMAC` and `SIOCSIFMAC` network interface ioctls permit the labels on network interfaces to be retrieved and set.

[[mac-policy-architecture]]
== MAC Policy Architecture

Security policies are either linked directly into the kernel, or compiled into loadable kernel modules that may be loaded at boot, or dynamically using the module loading system calls at runtime. Policy modules interact with the system through a set of declared entry points, providing access to a stream of system events and permitting the policy to influence access control decisions. Each policy contains a number of elements:

* Optional configuration parameters for policy.
* Centralized implementation of the policy logic and parameters.
* Optional implementation of policy life cycle events, such as initialization and destruction.
* Optional support for initializing, maintaining, and destroying labels on selected kernel objects.
* Optional support for user process inspection and modification of labels on selected objects.
* Implementation of selected access control entry points that are of interest to the policy.
* Declaration of policy identity, module entry points, and policy properties.

[[mac-policy-declaration]]
=== Policy Declaration

Modules may be declared using the `MAC_POLICY_SET()` macro, which names the policy, provides a reference to the MAC entry point vector, provides load-time flags determining how the policy framework should handle the policy, and optionally requests the allocation of label state by the framework.

[.programlisting]
....
static struct mac_policy_ops mac_policy_ops =
{
        .mpo_destroy = mac_policy_destroy,
        .mpo_init = mac_policy_init,
        .mpo_init_bpfdesc_label = mac_policy_init_bpfdesc_label,
        .mpo_init_cred_label = mac_policy_init_label,
/* ... */
        .mpo_check_vnode_setutimes = mac_policy_check_vnode_setutimes,
        .mpo_check_vnode_stat = mac_policy_check_vnode_stat,
        .mpo_check_vnode_write = mac_policy_check_vnode_write,
};
....

The MAC policy entry point vector, `mac__policy__ops` in this example, associates functions defined in the module with specific entry points. A complete listing of available entry points and their prototypes may be found in the MAC entry point reference section. Of specific interest during module registration are the .mpo_destroy and .mpo_init entry points. .mpo_init will be invoked once a policy is successfully registered with the module framework but prior to any other entry points becoming active. This permits the policy to perform any policy-specific allocation and initialization, such as initialization of any data or locks. .mpo_destroy will be invoked when a policy module is unloaded to permit releasing of any allocated memory and destruction of locks. Currently, these two entry points are invoked with the MAC policy list mutex held to prevent any other entry points from being invoked: this will be changed, but in the mean time, policies should be careful about what kernel primitives they invoke so as to avoid lock ordering or sleeping problems.

The policy declaration's module name field exists so that the module may be uniquely identified for the purposes of module dependencies. An appropriate string should be selected. The full string name of the policy is displayed to the user via the kernel log during load and unload events, and also exported when providing status information to userland processes.

[[mac-policy-flags]]
=== Policy Flags

The policy declaration flags field permits the module to provide the framework with information about its capabilities at the time the module is loaded. Currently, three flags are defined:

MPC_LOADTIME_FLAG_UNLOADOK::
This flag indicates that the policy module may be unloaded. If this flag is not provided, then the policy framework will reject requests to unload the module. This flag might be used by modules that allocate label state and are unable to free that state at runtime.

MPC_LOADTIME_FLAG_NOTLATE::
This flag indicates that the policy module must be loaded and initialized early in the boot process. If the flag is specified, attempts to register the module following boot will be rejected. The flag may be used by policies that require pervasive labeling of all system objects, and cannot handle objects that have not been properly initialized by the policy.

MPC_LOADTIME_FLAG_LABELMBUFS::
This flag indicates that the policy module requires labeling of Mbufs, and that memory should always be allocated for the storage of Mbuf labels. By default, the MAC Framework will not allocate label storage for Mbufs unless at least one loaded policy has this flag set. This measurably improves network performance when policies do not require Mbuf labeling. A kernel option, `MAC_ALWAYS_LABEL_MBUF`, exists to force the MAC Framework to allocate Mbuf label storage regardless of the setting of this flag, and may be useful in some environments.

[NOTE]
====
Policies using the `MPC_LOADTIME_FLAG_LABELMBUFS` without the `MPC_LOADTIME_FLAG_NOTLATE` flag set must be able to correctly handle `NULL` Mbuf label pointers passed into entry points. This is necessary as in-flight Mbufs without label storage may persist after a policy enabling Mbuf labeling has been loaded. If a policy is loaded before the network subsystem is active (i.e., the policy is not being loaded late), then all Mbufs are guaranteed to have label storage.
====

[[mac-policy-entry-points]]
=== Policy Entry Points

Four classes of entry points are offered to policies registered with the framework: entry points associated with the registration and management of policies, entry points denoting initialization, creation, destruction, and other life cycle events for kernel objects, events associated with access control decisions that the policy module may influence, and calls associated with the management of labels on objects. In addition, a `mac_syscall()` entry point is provided so that policies may extend the kernel interface without registering new system calls.

Policy module writers should be aware of the kernel locking strategy, as well as what object locks are available during which entry points. Writers should attempt to avoid deadlock scenarios by avoiding grabbing non-leaf locks inside of entry points, and also follow the locking protocol for object access and modification. In particular, writers should be aware that while necessary locks to access objects and their labels are generally held, sufficient locks to modify an object or its label may not be present for all entry points. Locking information for arguments is documented in the MAC framework entry point document.

Policy entry points will pass a reference to the object label along with the object itself. This permits labeled policies to be unaware of the internals of the object yet still make decisions based on the label. The exception to this is the process credential, which is assumed to be understood by policies as a first class security object in the kernel.

[[mac-entry-point-reference]]
== MAC Policy Entry Point Reference

[[mac-mpo-general]]
=== General-Purpose Module Entry Points

[[mac-mpo-init]]
==== `mpo_init`

[source,c]
----
void mpo_init(	conf);	 
struct mac_policy_conf *conf;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`conf`
|MAC policy definition
|
|===

Policy load event. The policy list mutex is held, so sleep operations cannot be performed, and calls out to other kernel subsystems must be made with caution. If potentially sleeping memory allocations are required during policy initialization, they should be made using a separate module SYSINIT().

[[mpo-destroy]]
==== `mpo_destroy`

[source,c]
----
void mpo_destroy(	conf);	 
struct mac_policy_conf *conf;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`conf`
|MAC policy definition
|
|===

Policy load event. The policy list mutex is held, so caution should be applied.

[[mac-mpo-syscall]]
==== `mpo_syscall`

[source,c]
----
int mpo_syscall(	td, 	 
 	call, 	 
 	arg);	 
struct thread *td;
int call;
void *arg;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`td`
|Calling thread
|

|`call`
|Policy-specific syscall number
|

|`arg`
|Pointer to syscall arguments
|
|===

This entry point provides a policy-multiplexed system call so that policies may provide additional services to user processes without registering specific system calls. The policy name provided during registration is used to demux calls from userland, and the arguments will be forwarded to this entry point. When implementing new services, security modules should be sure to invoke appropriate access control checks from the MAC framework as needed. For example, if a policy implements an augmented signal functionality, it should call the necessary signal access control checks to invoke the MAC framework and other registered policies.

[NOTE]
====
Modules must currently perform the `copyin()` of the syscall data on their own.
====

[[mac-mpo-thread-userret]]
==== `mpo_thread_userret`

[source,c]
----
void mpo_thread_userret(	td);	 
struct thread *td;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`td`
|Returning thread
|
|===

This entry point permits policy modules to perform MAC-related events when a thread returns to user space, via a system call return, trap return, or otherwise. This is required for policies that have floating process labels, as it is not always possible to acquire the process lock at arbitrary points in the stack during system call processing; process labels might represent traditional authentication data, process history information, or other data. To employ this mechanism, intended changes to the process credential label may be stored in the `p_label` protected by a per-policy spin lock, and then set the per-thread `TDF_ASTPENDING` flag and per-process `PS_MACPENDM` flag to schedule a call to the userret entry point. From this entry point, the policy may create a replacement credential with less concern about the locking context. Policy writers are cautioned that event ordering relating to scheduling an AST and the AST being performed may be complex and interlaced in multithreaded applications.

[[mac-label-ops]]
=== Label Operations

[[mac-mpo-init-bpfdesc]]
==== `mpo_init_bpfdesc_label`

[source,c]
----
void mpo_init_bpfdesc_label(	label);	 
struct label *label;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`label`
|New label to apply
|
|===

Initialize the label on a newly instantiated bpfdesc (BPF descriptor). Sleeping is permitted.

[[mac-mpo-init-cred-label]]
==== `mpo_init_cred_label`

[source,c]
----
void mpo_init_cred_label(	label);	 
struct label *label;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`label`
|New label to initialize
|
|===

Initialize the label for a newly instantiated user credential. Sleeping is permitted.

[[mac-mpo-init-devfsdirent]]
==== `mpo_init_devfsdirent_label`

[source,c]
----
void mpo_init_devfsdirent_label(	label);	 
struct label *label;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`label`
|New label to apply
|
|===

Initialize the label on a newly instantiated devfs entry. Sleeping is permitted.

[[mac-mpo-init-ifnet]]
==== `mpo_init_ifnet_label`

[source,c]
----
void mpo_init_ifnet_label(	label);	 
struct label *label;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`label`
|New label to apply
|
|===

Initialize the label on a newly instantiated network interface. Sleeping is permitted.

[[mac-mpo-init-ipq]]
==== `mpo_init_ipq_label`

[source,c]
----
void mpo_init_ipq_label(	label, 	 
 	flag);	 
struct label *label;
int flag;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`label`
|New label to apply
|

|`flag`
|Sleeping/non-sleeping man:malloc[9]; see below
|
|===

Initialize the label on a newly instantiated IP fragment reassembly queue. The `flag` field may be one of M_WAITOK and M_NOWAIT, and should be employed to avoid performing a sleeping man:malloc[9] during this initialization call. IP fragment reassembly queue allocation frequently occurs in performance sensitive environments, and the implementation should be careful to avoid sleeping or long-lived operations. This entry point is permitted to fail resulting in the failure to allocate the IP fragment reassembly queue.

[[mac-mpo-init-mbuf]]
==== `mpo_init_mbuf_label`

[source,c]
----
void mpo_init_mbuf_label(	flag, 	 
 	label);	 
int flag;
struct label *label;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`flag`
|Sleeping/non-sleeping man:malloc[9]; see below
|

|`label`
|Policy label to initialize
|
|===

Initialize the label on a newly instantiated mbuf packet header (`mbuf`). The `flag` field may be one of M_WAITOK and M_NOWAIT, and should be employed to avoid performing a sleeping man:malloc[9] during this initialization call. Mbuf allocation frequently occurs in performance sensitive environments, and the implementation should be careful to avoid sleeping or long-lived operations. This entry point is permitted to fail resulting in the failure to allocate the mbuf header.

[[mac-mpo-init-mount]]
==== `mpo_init_mount_label`

[source,c]
----
void mpo_init_mount_label(	mntlabel, 	 
 	fslabel);	 
struct label *mntlabel;
struct label *fslabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`mntlabel`
|Policy label to be initialized for the mount itself
|

|`fslabel`
|Policy label to be initialized for the file system
|
|===

Initialize the labels on a newly instantiated mount point. Sleeping is permitted.

[[mac-mpo-init-mount-fs-label]]
==== `mpo_init_mount_fs_label`

[source,c]
----
void mpo_init_mount_fs_label(	label);	 
struct label *label;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`label`
|Label to be initialized
|
|===

Initialize the label on a newly mounted file system. Sleeping is permitted

[[mac-mpo-init-pipe-label]]
==== `mpo_init_pipe_label`

[source,c]
----
void mpo_init_pipe_label(	label);	 
struct label*label;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`label`
|Label to be filled in
|
|===

Initialize a label for a newly instantiated pipe. Sleeping is permitted.

[[mac-mpo-init-socket]]
==== `mpo_init_socket_label`

[source,c]
----
void mpo_init_socket_label(	label, 	 
 	flag);	 
struct label *label;
int flag;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`label`
|New label to initialize
|

|`flag`
|man:malloc[9] flags
|
|===

Initialize a label for a newly instantiated socket. The `flag` field may be one of M_WAITOK and M_NOWAIT, and should be employed to avoid performing a sleeping man:malloc[9] during this initialization call.

[[mac-mpo-init-socket-peer-label]]
==== `mpo_init_socket_peer_label`

[source,c]
----
void mpo_init_socket_peer_label(	label, 	 
 	flag);	 
struct label *label;
int flag;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`label`
|New label to initialize
|

|`flag`
|man:malloc[9] flags
|
|===

Initialize the peer label for a newly instantiated socket. The `flag` field may be one of M_WAITOK and M_NOWAIT, and should be employed to avoid performing a sleeping man:malloc[9] during this initialization call.

[[mac-mpo-init-proc-label]]
==== `mpo_init_proc_label`

[source,c]
----
void mpo_init_proc_label(	label);	 
struct label *label;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`label`
|New label to initialize
|
|===

Initialize the label for a newly instantiated process. Sleeping is permitted.

[[mac-mpo-init-vnode]]
==== `mpo_init_vnode_label`

[source,c]
----
void mpo_init_vnode_label(	label);	 
struct label *label;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`label`
|New label to initialize
|
|===

Initialize the label on a newly instantiated vnode. Sleeping is permitted.

[[mac-mpo-destroy-bpfdesc]]
==== `mpo_destroy_bpfdesc_label`

[source,c]
----
void mpo_destroy_bpfdesc_label(	label);	 
struct label *label;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`label`
|bpfdesc label
|
|===

Destroy the label on a BPF descriptor. In this entry point a policy should free any internal storage associated with `label` so that it may be destroyed.

[[mac-mpo-destroy-cred]]
==== `mpo_destroy_cred_label`

[source,c]
----
void mpo_destroy_cred_label(	label);	 
struct label *label;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`label`
|Label being destroyed
|
|===

Destroy the label on a credential. In this entry point, a policy module should free any internal storage associated with `label` so that it may be destroyed.

[[mac-mpo-destroy-devfsdirent]]
==== `mpo_destroy_devfsdirent_label`

[source,c]
----
void mpo_destroy_devfsdirent_label(	label);	 
struct label *label;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`label`
|Label being destroyed
|
|===

Destroy the label on a devfs entry. In this entry point, a policy module should free any internal storage associated with `label` so that it may be destroyed.

[[mac-mpo-destroy-ifnet-label]]
==== `mpo_destroy_ifnet_label`

[source,c]
----
void mpo_destroy_ifnet_label(	label);	 
struct label *label;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`label`
|Label being destroyed
|
|===

Destroy the label on a removed interface. In this entry point, a policy module should free any internal storage associated with `label` so that it may be destroyed.

[[mac-mpo-destroy-ipq-label]]
==== `mpo_destroy_ipq_label`

[source,c]
----
void mpo_destroy_ipq_label(	label);	 
struct label *label;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`label`
|Label being destroyed
|
|===

Destroy the label on an IP fragment queue. In this entry point, a policy module should free any internal storage associated with `label` so that it may be destroyed.

[[mac-mpo-destroy-mbuf-label]]
==== `mpo_destroy_mbuf_label`

[source,c]
----
void mpo_destroy_mbuf_label(	label);	 
struct label *label;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`label`
|Label being destroyed
|
|===

Destroy the label on an mbuf header. In this entry point, a policy module should free any internal storage associated with `label` so that it may be destroyed.

[[mac-mpo-destroy-mount-label]]
==== `mpo_destroy_mount_label`

[source,c]
----
void mpo_destroy_mount_label(	label);	 
struct label *label;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`label`
|Mount point label being destroyed
|
|===

Destroy the labels on a mount point. In this entry point, a policy module should free the internal storage associated with `mntlabel` so that they may be destroyed.

[[mac-mpo-destroy-mount]]
==== `mpo_destroy_mount_label`

[source,c]
----
void mpo_destroy_mount_label(	mntlabel, 	 
 	fslabel);	 
struct label *mntlabel;
struct label *fslabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`mntlabel`
|Mount point label being destroyed
|

|`fslabel`
|File system label being destroyed>
|
|===

Destroy the labels on a mount point. In this entry point, a policy module should free the internal storage associated with `mntlabel` and `fslabel` so that they may be destroyed.

[[mac-mpo-destroy-socket]]
==== `mpo_destroy_socket_label`

[source,c]
----
void mpo_destroy_socket_label(	label);	 
struct label *label;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`label`
|Socket label being destroyed
|
|===

Destroy the label on a socket. In this entry point, a policy module should free any internal storage associated with `label` so that it may be destroyed.

[[mac-mpo-destroy-socket-peer-label]]
==== `mpo_destroy_socket_peer_label`

[source,c]
----
void mpo_destroy_socket_peer_label(	peerlabel);	 
struct label *peerlabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`peerlabel`
|Socket peer label being destroyed
|
|===

Destroy the peer label on a socket. In this entry point, a policy module should free any internal storage associated with `label` so that it may be destroyed.

[[mac-mpo-destroy-pipe-label]]
==== `mpo_destroy_pipe_label`

[source,c]
----
void mpo_destroy_pipe_label(	label);	 
struct label *label;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`label`
|Pipe label
|
|===

Destroy the label on a pipe. In this entry point, a policy module should free any internal storage associated with `label` so that it may be destroyed.

[[mac-mpo-destroy-proc-label]]
==== `mpo_destroy_proc_label`

[source,c]
----
void mpo_destroy_proc_label(	label);	 
struct label *label;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`label`
|Process label
|
|===

Destroy the label on a process. In this entry point, a policy module should free any internal storage associated with `label` so that it may be destroyed.

[[mac-mpo-destroy-vnode-label]]
==== `mpo_destroy_vnode_label`

[source,c]
----
void mpo_destroy_vnode_label(	label);	 
struct label *label;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`label`
|Process label
|
|===

Destroy the label on a vnode. In this entry point, a policy module should free any internal storage associated with `label` so that it may be destroyed.

[[mac-mpo-copy-mbuf-label]]
==== `mpo_copy_mbuf_label`

[source,c]
----
void mpo_copy_mbuf_label(	src, 	 
 	dest);	 
struct label *src;
struct label *dest;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`src`
|Source label
|

|`dest`
|Destination label
|
|===

Copy the label information in `src` into `dest`.

[[mac-mpo-copy-pipe-label]]
==== `mpo_copy_pipe_label`

[source,c]
----
void mpo_copy_pipe_label(	src, 	 
 	dest);	 
struct label *src;
struct label *dest;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`src`
|Source label
|

|`dest`
|Destination label
|
|===

Copy the label information in `src` into `dest`.

[[mac-mpo-copy-vnode-label]]
==== `mpo_copy_vnode_label`

[source,c]
----
void mpo_copy_vnode_label(	src, 	 
 	dest);	 
struct label *src;
struct label *dest;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`src`
|Source label
|

|`dest`
|Destination label
|
|===

Copy the label information in `src` into `dest`.

[[mac-mpo-externalize-cred-label]]
==== `mpo_externalize_cred_label`

[source,c]
----
int mpo_externalize_cred_label(	label, 	 
 	element_name, 	 
 	sb, 	 
 	*claimed);	 
struct label *label;
char *element_name;
struct sbuf *sb;
int *claimed;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`label`
|Label to be externalized
|

|`element_name`
|Name of the policy whose label should be externalized
|

|`sb`
|String buffer to be filled with a text representation of label
|

|`claimed`
|Should be incremented when `element_data` can be filled in.
|
|===

Produce an externalized label based on the label structure passed. An externalized label consists of a text representation of the label contents that can be used with userland applications and read by the user. Currently, all policies' `externalize` entry points will be called, so the implementation should check the contents of `element_name` before attempting to fill in `sb`. If `element_name` does not match the name of your policy, simply return 0. Only return nonzero if an error occurs while externalizing the label data. Once the policy fills in `element_data`, `*claimed` should be incremented.

[[mac-mpo-externalize-ifnet-label]]
==== `mpo_externalize_ifnet_label`

[source,c]
----
int mpo_externalize_ifnet_label(	label, 	 
 	element_name, 	 
 	sb, 	 
 	*claimed);	 
struct label *label;
char *element_name;
struct sbuf *sb;
int *claimed;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`label`
|Label to be externalized
|

|`element_name`
|Name of the policy whose label should be externalized
|

|`sb`
|String buffer to be filled with a text representation of label
|

|`claimed`
|Should be incremented when `element_data` can be filled in.
|
|===

Produce an externalized label based on the label structure passed. An externalized label consists of a text representation of the label contents that can be used with userland applications and read by the user. Currently, all policies' `externalize` entry points will be called, so the implementation should check the contents of `element_name` before attempting to fill in `sb`. If `element_name` does not match the name of your policy, simply return 0. Only return nonzero if an error occurs while externalizing the label data. Once the policy fills in `element_data`, `*claimed` should be incremented.

[[mac-mpo-externalize-pipe-label]]
==== `mpo_externalize_pipe_label`

[source,c]
----
int mpo_externalize_pipe_label(	label, 	 
 	element_name, 	 
 	sb, 	 
 	*claimed);	 
struct label *label;
char *element_name;
struct sbuf *sb;
int *claimed;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`label`
|Label to be externalized
|

|`element_name`
|Name of the policy whose label should be externalized
|

|`sb`
|String buffer to be filled with a text representation of label
|

|`claimed`
|Should be incremented when `element_data` can be filled in.
|
|===

Produce an externalized label based on the label structure passed. An externalized label consists of a text representation of the label contents that can be used with userland applications and read by the user. Currently, all policies' `externalize` entry points will be called, so the implementation should check the contents of `element_name` before attempting to fill in `sb`. If `element_name` does not match the name of your policy, simply return 0. Only return nonzero if an error occurs while externalizing the label data. Once the policy fills in `element_data`, `*claimed` should be incremented.

[[mac-mpo-externalize-socket-label]]
==== `mpo_externalize_socket_label`

[source,c]
----
int mpo_externalize_socket_label(	label, 	 
 	element_name, 	 
 	sb, 	 
 	*claimed);	 
struct label *label;
char *element_name;
struct sbuf *sb;
int *claimed;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`label`
|Label to be externalized
|

|`element_name`
|Name of the policy whose label should be externalized
|

|`sb`
|String buffer to be filled with a text representation of label
|

|`claimed`
|Should be incremented when `element_data` can be filled in.
|
|===

Produce an externalized label based on the label structure passed. An externalized label consists of a text representation of the label contents that can be used with userland applications and read by the user. Currently, all policies' `externalize` entry points will be called, so the implementation should check the contents of `element_name` before attempting to fill in `sb`. If `element_name` does not match the name of your policy, simply return 0. Only return nonzero if an error occurs while externalizing the label data. Once the policy fills in `element_data`, `*claimed` should be incremented.

[[mac-mpo-externalize-socket-peer-label]]
==== `mpo_externalize_socket_peer_label`

[source,c]
----
int mpo_externalize_socket_peer_label(	label, 	 
 	element_name, 	 
 	sb, 	 
 	*claimed);	 
struct label *label;
char *element_name;
struct sbuf *sb;
int *claimed;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`label`
|Label to be externalized
|

|`element_name`
|Name of the policy whose label should be externalized
|

|`sb`
|String buffer to be filled with a text representation of label
|

|`claimed`
|Should be incremented when `element_data` can be filled in.
|
|===

Produce an externalized label based on the label structure passed. An externalized label consists of a text representation of the label contents that can be used with userland applications and read by the user. Currently, all policies' `externalize` entry points will be called, so the implementation should check the contents of `element_name` before attempting to fill in `sb`. If `element_name` does not match the name of your policy, simply return 0. Only return nonzero if an error occurs while externalizing the label data. Once the policy fills in `element_data`, `*claimed` should be incremented.

[[mac-mpo-externalize-vnode-label]]
==== `mpo_externalize_vnode_label`

[source,c]
----
int mpo_externalize_vnode_label(	label, 	 
 	element_name, 	 
 	sb, 	 
 	*claimed);	 
struct label *label;
char *element_name;
struct sbuf *sb;
int *claimed;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`label`
|Label to be externalized
|

|`element_name`
|Name of the policy whose label should be externalized
|

|`sb`
|String buffer to be filled with a text representation of label
|

|`claimed`
|Should be incremented when `element_data` can be filled in.
|
|===

Produce an externalized label based on the label structure passed. An externalized label consists of a text representation of the label contents that can be used with userland applications and read by the user. Currently, all policies' `externalize` entry points will be called, so the implementation should check the contents of `element_name` before attempting to fill in `sb`. If `element_name` does not match the name of your policy, simply return 0. Only return nonzero if an error occurs while externalizing the label data. Once the policy fills in `element_data`, `*claimed` should be incremented.

[[mac-mpo-internalize-cred-label]]
==== `mpo_internalize_cred_label`

[source,c]
----
int mpo_internalize_cred_label(	label, 	 
 	element_name, 	 
 	element_data, 	 
 	claimed);	 
struct label *label;
char *element_name;
char *element_data;
int *claimed;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`label`
|Label to be filled in
|

|`element_name`
|Name of the policy whose label should be internalized
|

|`element_data`
|Text data to be internalized
|

|`claimed`
|Should be incremented when data can be successfully internalized.
|
|===

Produce an internal label structure based on externalized label data in text format. Currently, all policies' `internalize` entry points are called when internalization is requested, so the implementation should compare the contents of `element_name` to its own name in order to be sure it should be internalizing the data in `element_data`. Just as in the `externalize` entry points, the entry point should return 0 if `element_name` does not match its own name, or when data can successfully be internalized, in which case `*claimed` should be incremented.

[[mac-mpo-internalize-ifnet-label]]
==== `mpo_internalize_ifnet_label`

[source,c]
----
int mpo_internalize_ifnet_label(	label, 	 
 	element_name, 	 
 	element_data, 	 
 	claimed);	 
struct label *label;
char *element_name;
char *element_data;
int *claimed;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`label`
|Label to be filled in
|

|`element_name`
|Name of the policy whose label should be internalized
|

|`element_data`
|Text data to be internalized
|

|`claimed`
|Should be incremented when data can be successfully internalized.
|
|===

Produce an internal label structure based on externalized label data in text format. Currently, all policies' `internalize` entry points are called when internalization is requested, so the implementation should compare the contents of `element_name` to its own name in order to be sure it should be internalizing the data in `element_data`. Just as in the `externalize` entry points, the entry point should return 0 if `element_name` does not match its own name, or when data can successfully be internalized, in which case `*claimed` should be incremented.

[[mac-mpo-internalize-pipe-label]]
==== `mpo_internalize_pipe_label`

[source,c]
----
int mpo_internalize_pipe_label(	label, 	 
 	element_name, 	 
 	element_data, 	 
 	claimed);	 
struct label *label;
char *element_name;
char *element_data;
int *claimed;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`label`
|Label to be filled in
|

|`element_name`
|Name of the policy whose label should be internalized
|

|`element_data`
|Text data to be internalized
|

|`claimed`
|Should be incremented when data can be successfully internalized.
|
|===

Produce an internal label structure based on externalized label data in text format. Currently, all policies' `internalize` entry points are called when internalization is requested, so the implementation should compare the contents of `element_name` to its own name in order to be sure it should be internalizing the data in `element_data`. Just as in the `externalize` entry points, the entry point should return 0 if `element_name` does not match its own name, or when data can successfully be internalized, in which case `*claimed` should be incremented.

[[mac-mpo-internalize-socket-label]]
==== `mpo_internalize_socket_label`

[source,c]
----
int mpo_internalize_socket_label(	label, 	 
 	element_name, 	 
 	element_data, 	 
 	claimed);	 
struct label *label;
char *element_name;
char *element_data;
int *claimed;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`label`
|Label to be filled in
|

|`element_name`
|Name of the policy whose label should be internalized
|

|`element_data`
|Text data to be internalized
|

|`claimed`
|Should be incremented when data can be successfully internalized.
|
|===

Produce an internal label structure based on externalized label data in text format. Currently, all policies' `internalize` entry points are called when internalization is requested, so the implementation should compare the contents of `element_name` to its own name in order to be sure it should be internalizing the data in `element_data`. Just as in the `externalize` entry points, the entry point should return 0 if `element_name` does not match its own name, or when data can successfully be internalized, in which case `*claimed` should be incremented.

[[mac-mpo-internalize-vnode-label]]
==== `mpo_internalize_vnode_label`

[source,c]
----
int mpo_internalize_vnode_label(	label, 	 
 	element_name, 	 
 	element_data, 	 
 	claimed);	 
struct label *label;
char *element_name;
char *element_data;
int *claimed;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`label`
|Label to be filled in
|

|`element_name`
|Name of the policy whose label should be internalized
|

|`element_data`
|Text data to be internalized
|

|`claimed`
|Should be incremented when data can be successfully internalized.
|
|===

Produce an internal label structure based on externalized label data in text format. Currently, all policies' `internalize` entry points are called when internalization is requested, so the implementation should compare the contents of `element_name` to its own name in order to be sure it should be internalizing the data in `element_data`. Just as in the `externalize` entry points, the entry point should return 0 if `element_name` does not match its own name, or when data can successfully be internalized, in which case `*claimed` should be incremented.

[[mac-label-events]]
=== Label Events

This class of entry points is used by the MAC framework to permit policies to maintain label information on kernel objects. For each labeled kernel object of interest to a MAC policy, entry points may be registered for relevant life cycle events. All objects implement initialization, creation, and destruction hooks. Some objects will also implement relabeling, allowing user processes to change the labels on objects. Some objects will also implement object-specific events, such as label events associated with IP reassembly. A typical labeled object will have the following life cycle of entry points:

[.programlisting]
....
Label initialization          o
(object-specific wait)         \
Label creation                  o
                                 \
Relabel events,                   o--<--.
Various object-specific,          |     |
Access control events             ~-->--o
                                         \
Label destruction                         o
....

Label initialization permits policies to allocate memory and set initial values for labels without context for the use of the object. The label slot allocated to a policy will be zeroed by default, so some policies may not need to perform initialization.

Label creation occurs when the kernel structure is associated with an actual kernel object. For example, Mbufs may be allocated and remain unused in a pool until they are required. mbuf allocation causes label initialization on the mbuf to take place, but mbuf creation occurs when the mbuf is associated with a datagram. Typically, context will be provided for a creation event, including the circumstances of the creation, and labels of other relevant objects in the creation process. For example, when an mbuf is created from a socket, the socket and its label will be presented to registered policies in addition to the new mbuf and its label. Memory allocation in creation events is discouraged, as it may occur in performance sensitive ports of the kernel; in addition, creation calls are not permitted to fail so a failure to allocate memory cannot be reported.

Object specific events do not generally fall into the other broad classes of label events, but will generally provide an opportunity to modify or update the label on an object based on additional context. For example, the label on an IP fragment reassembly queue may be updated during the MAC_UPDATE_IPQ entry point as a result of the acceptance of an additional mbuf to that queue.

Access control events are discussed in detail in the following section.

Label destruction permits policies to release storage or state associated with a label during its association with an object so that the kernel data structures supporting the object may be reused or released.

In addition to labels associated with specific kernel objects, an additional class of labels exists: temporary labels. These labels are used to store update information submitted by user processes. These labels are initialized and destroyed as with other label types, but the creation event is MAC_INTERNALIZE, which accepts a user label to be converted to an in-kernel representation.

[[mac-fs-label-event-ops]]
==== File System Object Labeling Event Operations

[[mac-mpo-associate-vnode-devfs]]
===== `mpo_associate_vnode_devfs`

[source,c]
----
void mpo_associate_vnode_devfs(	mp, 	 
 	fslabel, 	 
 	de, 	 
 	delabel, 	 
 	vp, 	 
 	vlabel);	 
struct mount *mp;
struct label *fslabel;
struct devfs_dirent *de;
struct label *delabel;
struct vnode *vp;
struct label *vlabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`mp`
|Devfs mount point
|

|`fslabel`
|Devfs file system label (`mp->mnt_fslabel`)
|

|`de`
|Devfs directory entry
|

|`delabel`
|Policy label associated with `de`
|

|`vp`
|vnode associated with `de`
|

|`vlabel`
|Policy label associated with `vp`
|
|===

Fill in the label (`vlabel`) for a newly created devfs vnode based on the devfs directory entry passed in `de` and its label.

[[mac-mpo-associate-vnode-extattr]]
===== `mpo_associate_vnode_extattr`

[source,c]
----
int mpo_associate_vnode_extattr(	mp, 	 
 	fslabel, 	 
 	vp, 	 
 	vlabel);	 
struct mount *mp;
struct label *fslabel;
struct vnode *vp;
struct label *vlabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`mp`
|File system mount point
|

|`fslabel`
|File system label
|

|`vp`
|Vnode to label
|

|`vlabel`
|Policy label associated with `vp`
|
|===

Attempt to retrieve the label for `vp` from the file system extended attributes. Upon success, the value `0` is returned. Should extended attribute retrieval not be supported, an accepted fallback is to copy `fslabel` into `vlabel`. In the event of an error, an appropriate value for `errno` should be returned.

[[mac-mpo-associate-vnode-singlelabel]]
===== `mpo_associate_vnode_singlelabel`

[source,c]
----
void mpo_associate_vnode_singlelabel(	mp, 	 
 	fslabel, 	 
 	vp, 	 
 	vlabel);	 
struct mount *mp;
struct label *fslabel;
struct vnode *vp;
struct label *vlabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`mp`
|File system mount point
|

|`fslabel`
|File system label
|

|`vp`
|Vnode to label
|

|`vlabel`
|Policy label associated with `vp`
|
|===

On non-multilabel file systems, this entry point is called to set the policy label for `vp` based on the file system label, `fslabel`.

[[mac-mpo-create-devfs-device]]
===== `mpo_create_devfs_device`

[source,c]
----
void mpo_create_devfs_device(	dev, 	 
 	devfs_dirent, 	 
 	label);	 
dev_t dev;
struct devfs_dirent *devfs_dirent;
struct label *label;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`dev`
|Device corresponding with `devfs_dirent`
|

|`devfs_dirent`
|Devfs directory entry to be labeled.
|

|`label`
|Label for `devfs_dirent` to be filled in.
|
|===

Fill out the label on a devfs_dirent being created for the passed device. This call will be made when the device file system is mounted, regenerated, or a new device is made available.

[[mac-mpo-create-devfs-directory]]
===== `mpo_create_devfs_directory`

[source,c]
----
void mpo_create_devfs_directory(	dirname, 	 
 	dirnamelen, 	 
 	devfs_dirent, 	 
 	label);	 
char *dirname;
int dirnamelen;
struct devfs_dirent *devfs_dirent;
struct label *label;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`dirname`
|Name of directory being created
|

|`namelen`
|Length of string `dirname`
|

|`devfs_dirent`
|Devfs directory entry for directory being created.
|
|===

Fill out the label on a devfs_dirent being created for the passed directory. This call will be made when the device file system is mounted, regenerated, or a new device requiring a specific directory hierarchy is made available.

[[mac-mpo-create-devfs-symlink]]
===== `mpo_create_devfs_symlink`

[source,c]
----
void mpo_create_devfs_symlink(	cred, 	 
 	mp, 	 
 	dd, 	 
 	ddlabel, 	 
 	de, 	 
 	delabel);	 
struct ucred *cred;
struct mount *mp;
struct devfs_dirent *dd;
struct label *ddlabel;
struct devfs_dirent *de;
struct label *delabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`mp`
|Devfs mount point
|

|`dd`
|Link destination
|

|`ddlabel`
|Label associated with `dd`
|

|`de`
|Symlink entry
|

|`delabel`
|Label associated with `de`
|
|===

Fill in the label (`delabel`) for a newly created man:devfs[5] symbolic link entry.

[[mac-mpo-create-vnode-extattr]]
===== `mpo_create_vnode_extattr`

[source,c]
----
int mpo_create_vnode_extattr(	cred, 	 
 	mp, 	 
 	fslabel, 	 
 	dvp, 	 
 	dlabel, 	 
 	vp, 	 
 	vlabel, 	 
 	cnp);	 
struct ucred *cred;
struct mount *mp;
struct label *fslabel;
struct vnode *dvp;
struct label *dlabel;
struct vnode *vp;
struct label *vlabel;
struct componentname *cnp;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`mount`
|File system mount point
|

|`label`
|File system label
|

|`dvp`
|Parent directory vnode
|

|`dlabel`
|Label associated with `dvp`
|

|`vp`
|Newly created vnode
|

|`vlabel`
|Policy label associated with `vp`
|

|`cnp`
|Component name for `vp`
|
|===

Write out the label for `vp` to the appropriate extended attribute. If the write succeeds, fill in `vlabel` with the label, and return 0. Otherwise, return an appropriate error.

[[mac-mpo-create-mount]]
===== `mpo_create_mount`

[source,c]
----
void mpo_create_mount(	cred, 	 
 	mp, 	 
 	mnt, 	 
 	fslabel);	 
struct ucred *cred;
struct mount *mp;
struct label *mnt;
struct label *fslabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`mp`
|Object; file system being mounted
|

|`mntlabel`
|Policy label to be filled in for `mp`
|

|`fslabel`
|Policy label for the file system `mp` mounts.
|
|===

Fill out the labels on the mount point being created by the passed subject credential. This call will be made when a new file system is mounted.

[[mac-mpo-create-root-mount]]
===== `mpo_create_root_mount`

[source,c]
----
void mpo_create_root_mount(	cred, 	 
 	mp, 	 
 	mntlabel, 	 
 	fslabel);	 
struct ucred *cred;
struct mount *mp;
struct label *mntlabel;
struct label *fslabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

3+|See <<mac-mpo-create-mount>>.
|===

Fill out the labels on the mount point being created by the passed subject credential. This call will be made when the root file system is mounted, after mpo_create_mount;.

[[mac-mpo-relabel-vnode]]
===== `mpo_relabel_vnode`

[source,c]
----
void mpo_relabel_vnode(	cred, 	 
 	vp, 	 
 	vnodelabel, 	 
 	newlabel);	 
struct ucred *cred;
struct vnode *vp;
struct label *vnodelabel;
struct label *newlabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`vp`
|vnode to relabel
|

|`vnodelabel`
|Existing policy label for `vp`
|

|`newlabel`
|New, possibly partial label to replace `vnodelabel`
|
|===

Update the label on the passed vnode given the passed update vnode label and the passed subject credential.

[[mac-mpo-setlabel-vnode-extattr]]
===== `mpo_setlabel_vnode_extattr`

[source,c]
----
int mpo_setlabel_vnode_extattr(	cred, 	 
 	vp, 	 
 	vlabel, 	 
 	intlabel);	 
struct ucred *cred;
struct vnode *vp;
struct label *vlabel;
struct label *intlabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`vp`
|Vnode for which the label is being written
|

|`vlabel`
|Policy label associated with `vp`
|

|`intlabel`
|Label to write out
|
|===

Write out the policy from `intlabel` to an extended attribute. This is called from `vop_stdcreatevnode_ea`.

[[mac-mpo-update-devfsdirent]]
===== `mpo_update_devfsdirent`

[source,c]
----
void mpo_update_devfsdirent(	devfs_dirent, 	 
 	direntlabel, 	 
 	vp, 	 
 	vnodelabel);	 
struct devfs_dirent *devfs_dirent;
struct label *direntlabel;
struct vnode *vp;
struct label *vnodelabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`devfs_dirent`
|Object; devfs directory entry
|

|`direntlabel`
|Policy label for `devfs_dirent` to be updated.
|

|`vp`
|Parent vnode
|Locked
|

|`vnodelabel`
|Policy label for `vp`
|
|===

Update the `devfs_dirent` label from the passed devfs vnode label. This call will be made when a devfs vnode has been successfully relabeled to commit the label change such that it lasts even if the vnode is recycled. It will also be made when a symlink is created in devfs, following a call to `mac_vnode_create_from_vnode` to initialize the vnode label.

[[mac-ipc-label-ops]]
==== IPC Object Labeling Event Operations

[[mac-mpo-create-mbuf-from-socket]]
===== `mpo_create_mbuf_from_socket`

[source,c]
----
void mpo_create_mbuf_from_socket(	so, 	 
 	socketlabel, 	 
 	m, 	 
 	mbuflabel);	 
struct socket *so;
struct label *socketlabel;
struct mbuf *m;
struct label *mbuflabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`socket`
|Socket
|Socket locking WIP

|`socketlabel`
|Policy label for `socket`
|

|`m`
|Object; mbuf
|

|`mbuflabel`
|Policy label to fill in for `m`
|
|===

Set the label on a newly created mbuf header from the passed socket label. This call is made when a new datagram or message is generated by the socket and stored in the passed mbuf.

[[mac-mpo-create-pipe]]
===== `mpo_create_pipe`

[source,c]
----
void mpo_create_pipe(	cred, 	 
 	pipe, 	 
 	pipelabel);	 
struct ucred *cred;
struct pipe *pipe;
struct label *pipelabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`pipe`
|Pipe
|

|`pipelabel`
|Policy label associated with `pipe`
|
|===

Set the label on a newly created pipe from the passed subject credential. This call is made when a new pipe is created.

[[mac-mpo-create-socket]]
===== `mpo_create_socket`

[source,c]
----
void mpo_create_socket(	cred, 	 
 	so, 	 
 	socketlabel);	 
struct ucred *cred;
struct socket *so;
struct label *socketlabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|Immutable

|`so`
|Object; socket to label
|

|`socketlabel`
|Label to fill in for `so`
|
|===

Set the label on a newly created socket from the passed subject credential. This call is made when a socket is created.

[[mac-mpo-create-socket-from-socket]]
===== `mpo_create_socket_from_socket`

[source,c]
----
void mpo_create_socket_from_socket(	oldsocket, 	 
 	oldsocketlabel, 	 
 	newsocket, 	 
 	newsocketlabel);	 
struct socket *oldsocket;
struct label *oldsocketlabel;
struct socket *newsocket;
struct label *newsocketlabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`oldsocket`
|Listening socket
|

|`oldsocketlabel`
|Policy label associated with `oldsocket`
|

|`newsocket`
|New socket
|

|`newsocketlabel`
|Policy label associated with `newsocketlabel`
|
|===

Label a socket, `newsocket`, newly man:accept[2]ed, based on the man:listen[2] socket, `oldsocket`.

[[mac-mpo-relabel-pipe]]
===== `mpo_relabel_pipe`

[source,c]
----
void mpo_relabel_pipe(	cred, 	 
 	pipe, 	 
 	oldlabel, 	 
 	newlabel);	 
struct ucred *cred;
struct pipe *pipe;
struct label *oldlabel;
struct label *newlabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`pipe`
|Pipe
|

|`oldlabel`
|Current policy label associated with `pipe`
|

|`newlabel`
|Policy label update to apply to `pipe`
|
|===

Apply a new label, `newlabel`, to `pipe`.

[[mac-mpo-relabel-socket]]
===== `mpo_relabel_socket`

[source,c]
----
void mpo_relabel_socket(	cred, 	 
 	so, 	 
 	oldlabel, 	 
 	newlabel);	 
struct ucred *cred;
struct socket *so;
struct label *oldlabel;
struct label *newlabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|Immutable

|`so`
|Object; socket
|

|`oldlabel`
|Current label for `so`
|

|`newlabel`
|Label update for `so`
|
|===

Update the label on a socket from the passed socket label update.

[[mpo-set-socket-peer-from-mbuf]]
===== `mpo_set_socket_peer_from_mbuf`

[source,c]
----
void mpo_set_socket_peer_from_mbuf(	mbuf, 	 
 	mbuflabel, 	 
 	oldlabel, 	 
 	newlabel);	 
struct mbuf *mbuf;
struct label *mbuflabel;
struct label *oldlabel;
struct label *newlabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`mbuf`
|First datagram received over socket
|

|`mbuflabel`
|Label for `mbuf`
|

|`oldlabel`
|Current label for the socket
|

|`newlabel`
|Policy label to be filled out for the socket
|
|===

Set the peer label on a stream socket from the passed mbuf label. This call will be made when the first datagram is received by the stream socket, with the exception of Unix domain sockets.

[[mac-mpo-set-socket-peer-from-socket]]
===== `mpo_set_socket_peer_from_socket`

[source,c]
----
void mpo_set_socket_peer_from_socket(	oldsocket, 	 
 	oldsocketlabel, 	 
 	newsocket, 	 
 	newsocketpeerlabel);	 
struct socket *oldsocket;
struct label *oldsocketlabel;
struct socket *newsocket;
struct label *newsocketpeerlabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`oldsocket`
|Local socket
|

|`oldsocketlabel`
|Policy label for `oldsocket`
|

|`newsocket`
|Peer socket
|

|`newsocketpeerlabel`
|Policy label to fill in for `newsocket`
|
|===

Set the peer label on a stream UNIX domain socket from the passed remote socket endpoint. This call will be made when the socket pair is connected, and will be made for both endpoints.

[[mac-net-labeling-event-ops]]
==== Network Object Labeling Event Operations

[[mac-mpo-create-bpfdesc]]
===== `mpo_create_bpfdesc`

[source,c]
----
void mpo_create_bpfdesc(	cred, 	 
 	bpf_d, 	 
 	bpflabel);	 
struct ucred *cred;
struct bpf_d *bpf_d;
struct label *bpflabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|Immutable

|`bpf_d`
|Object; bpf descriptor
|

|`bpf`
|Policy label to be filled in for `bpf_d`
|
|===

Set the label on a newly created BPF descriptor from the passed subject credential. This call will be made when a BPF device node is opened by a process with the passed subject credential.

[[mac-mpo-create-ifnet]]
===== `mpo_create_ifnet`

[source,c]
----
void mpo_create_ifnet(	ifnet, 	 
 	ifnetlabel);	 
struct ifnet *ifnet;
struct label *ifnetlabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`ifnet`
|Network interface
|

|`ifnetlabel`
|Policy label to fill in for `ifnet`
|
|===

Set the label on a newly created interface. This call may be made when a new physical interface becomes available to the system, or when a pseudo-interface is instantiated during the boot or as a result of a user action.

[[mac-mpo-create-ipq]]
===== `mpo_create_ipq`

[source,c]
----
void mpo_create_ipq(	fragment, 	 
 	fragmentlabel, 	 
 	ipq, 	 
 	ipqlabel);	 
struct mbuf *fragment;
struct label *fragmentlabel;
struct ipq *ipq;
struct label *ipqlabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`fragment`
|First received IP fragment
|

|`fragmentlabel`
|Policy label for `fragment`
|

|`ipq`
|IP reassembly queue to be labeled
|

|`ipqlabel`
|Policy label to be filled in for `ipq`
|
|===

Set the label on a newly created IP fragment reassembly queue from the mbuf header of the first received fragment.

[[mac-mpo-create-datagram-from-ipq]]
===== `mpo_create_datagram_from_ipq`

[source,c]
----
void mpo_create_create_datagram_from_ipq(	ipq, 	 
 	ipqlabel, 	 
 	datagram, 	 
 	datagramlabel);	 
struct ipq *ipq;
struct label *ipqlabel;
struct mbuf *datagram;
struct label *datagramlabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`ipq`
|IP reassembly queue
|

|`ipqlabel`
|Policy label for `ipq`
|

|`datagram`
|Datagram to be labeled
|

|`datagramlabel`
|Policy label to be filled in for `datagramlabel`
|
|===

Set the label on a newly reassembled IP datagram from the IP fragment reassembly queue from which it was generated.

[[mac-mpo-create-fragment]]
===== `mpo_create_fragment`

[source,c]
----
void mpo_create_fragment(	datagram, 	 
 	datagramlabel, 	 
 	fragment, 	 
 	fragmentlabel);	 
struct mbuf *datagram;
struct label *datagramlabel;
struct mbuf *fragment;
struct label *fragmentlabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`datagram`
|Datagram
|

|`datagramlabel`
|Policy label for `datagram`
|

|`fragment`
|Fragment to be labeled
|

|`fragmentlabel`
|Policy label to be filled in for `datagram`
|
|===

Set the label on the mbuf header of a newly created IP fragment from the label on the mbuf header of the datagram it was generate from.

[[mac-mpo-create-mbuf-from-mbuf]]
===== `mpo_create_mbuf_from_mbuf`

[source,c]
----
void mpo_create_mbuf_from_mbuf(	oldmbuf, 	 
 	oldmbuflabel, 	 
 	newmbuf, 	 
 	newmbuflabel);	 
struct mbuf *oldmbuf;
struct label *oldmbuflabel;
struct mbuf *newmbuf;
struct label *newmbuflabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`oldmbuf`
|Existing (source) mbuf
|

|`oldmbuflabel`
|Policy label for `oldmbuf`
|

|`newmbuf`
|New mbuf to be labeled
|

|`newmbuflabel`
|Policy label to be filled in for `newmbuf`
|
|===

Set the label on the mbuf header of a newly created datagram from the mbuf header of an existing datagram. This call may be made in a number of situations, including when an mbuf is re-allocated for alignment purposes.

[[mac-mpo-create-mbuf-linklayer]]
===== `mpo_create_mbuf_linklayer`

[source,c]
----
void mpo_create_mbuf_linklayer(	ifnet, 	 
 	ifnetlabel, 	 
 	mbuf, 	 
 	mbuflabel);	 
struct ifnet *ifnet;
struct label *ifnetlabel;
struct mbuf *mbuf;
struct label *mbuflabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`ifnet`
|Network interface
|

|`ifnetlabel`
|Policy label for `ifnet`
|

|`mbuf`
|mbuf header for new datagram
|

|`mbuflabel`
|Policy label to be filled in for `mbuf`
|
|===

Set the label on the mbuf header of a newly created datagram generated for the purposes of a link layer response for the passed interface. This call may be made in a number of situations, including for ARP or ND6 responses in the IPv4 and IPv6 stacks.

[[mac-mpo-create-mbuf-from-bpfdesc]]
===== `mpo_create_mbuf_from_bpfdesc`

[source,c]
----
void mpo_create_mbuf_from_bpfdesc(	bpf_d, 	 
 	bpflabel, 	 
 	mbuf, 	 
 	mbuflabel);	 
struct bpf_d *bpf_d;
struct label *bpflabel;
struct mbuf *mbuf;
struct label *mbuflabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`bpf_d`
|BPF descriptor
|

|`bpflabel`
|Policy label for `bpflabel`
|

|`mbuf`
|New mbuf to be labeled
|

|`mbuflabel`
|Policy label to fill in for `mbuf`
|
|===

Set the label on the mbuf header of a newly created datagram generated using the passed BPF descriptor. This call is made when a write is performed to the BPF device associated with the passed BPF descriptor.

[[mac-mpo-create-mbuf-from-ifnet]]
===== `mpo_create_mbuf_from_ifnet`

[source,c]
----
void mpo_create_mbuf_from_ifnet(	ifnet, 	 
 	ifnetlabel, 	 
 	mbuf, 	 
 	mbuflabel);	 
struct ifnet *ifnet;
struct label *ifnetlabel;
struct mbuf *mbuf;
struct label *mbuflabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`ifnet`
|Network interface
|

|`ifnetlabel`
|Policy label for `ifnetlabel`
|

|`mbuf`
|mbuf header for new datagram
|

|`mbuflabel`
|Policy label to be filled in for `mbuf`
|
|===

Set the label on the mbuf header of a newly created datagram generated from the passed network interface.

[[mac-mpo-create-mbuf-multicast-encap]]
===== `mpo_create_mbuf_multicast_encap`

[source,c]
----
void mpo_create_mbuf_multicast_encap(	oldmbuf, 	 
 	oldmbuflabel, 	 
 	ifnet, 	 
 	ifnetlabel, 	 
 	newmbuf, 	 
 	newmbuflabel);	 
struct mbuf *oldmbuf;
struct label *oldmbuflabel;
struct ifnet *ifnet;
struct label *ifnetlabel;
struct mbuf *newmbuf;
struct label *newmbuflabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`oldmbuf`
|mbuf header for existing datagram
|

|`oldmbuflabel`
|Policy label for `oldmbuf`
|

|`ifnet`
|Network interface
|

|`ifnetlabel`
|Policy label for `ifnet`
|

|`newmbuf`
|mbuf header to be labeled for new datagram
|

|`newmbuflabel`
|Policy label to be filled in for `newmbuf`
|
|===

Set the label on the mbuf header of a newly created datagram generated from the existing passed datagram when it is processed by the passed multicast encapsulation interface. This call is made when an mbuf is to be delivered using the virtual interface.

[[mac-mpo-create-mbuf-netlayer]]
===== `mpo_create_mbuf_netlayer`

[source,c]
----
void mpo_create_mbuf_netlayer(	oldmbuf, 	 
 	oldmbuflabel, 	 
 	newmbuf, 	 
 	newmbuflabel);	 
struct mbuf *oldmbuf;
struct label *oldmbuflabel;
struct mbuf *newmbuf;
struct label *newmbuflabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`oldmbuf`
|Received datagram
|

|`oldmbuflabel`
|Policy label for `oldmbuf`
|

|`newmbuf`
|Newly created datagram
|

|`newmbuflabel`
|Policy label for `newmbuf`
|
|===

Set the label on the mbuf header of a newly created datagram generated by the IP stack in response to an existing received datagram (`oldmbuf`). This call may be made in a number of situations, including when responding to ICMP request datagrams.

[[mac-mpo-fragment-match]]
===== `mpo_fragment_match`

[source,c]
----
int mpo_fragment_match(	fragment, 	 
 	fragmentlabel, 	 
 	ipq, 	 
 	ipqlabel);	 
struct mbuf *fragment;
struct label *fragmentlabel;
struct ipq *ipq;
struct label *ipqlabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`fragment`
|IP datagram fragment
|

|`fragmentlabel`
|Policy label for `fragment`
|

|`ipq`
|IP fragment reassembly queue
|

|`ipqlabel`
|Policy label for `ipq`
|
|===

Determine whether an mbuf header containing an IP datagram (`fragment`) fragment matches the label of the passed IP fragment reassembly queue (`ipq`). Return (1) for a successful match, or (0) for no match. This call is made when the IP stack attempts to find an existing fragment reassembly queue for a newly received fragment; if this fails, a new fragment reassembly queue may be instantiated for the fragment. Policies may use this entry point to prevent the reassembly of otherwise matching IP fragments if policy does not permit them to be reassembled based on the label or other information.

[[mac-mpo-ifnet-relabel]]
===== `mpo_relabel_ifnet`

[source,c]
----
void mpo_relabel_ifnet(	cred, 	 
 	ifnet, 	 
 	ifnetlabel, 	 
 	newlabel);	 
struct ucred *cred;
struct ifnet *ifnet;
struct label *ifnetlabel;
struct label *newlabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`ifnet`
|Object; Network interface
|

|`ifnetlabel`
|Policy label for `ifnet`
|

|`newlabel`
|Label update to apply to `ifnet`
|
|===

Update the label of network interface, `ifnet`, based on the passed update label, `newlabel`, and the passed subject credential, `cred`.

[[mac-mpo-update-ipq]]
===== `mpo_update_ipq`

[source,c]
----
void mpo_update_ipq(	fragment, 	 
 	fragmentlabel, 	 
 	ipq, 	 
 	ipqlabel);	 
struct mbuf *fragment;
struct label *fragmentlabel;
struct ipq *ipq;
struct label *ipqlabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`mbuf`
|IP fragment
|

|`mbuflabel`
|Policy label for `mbuf`
|

|`ipq`
|IP fragment reassembly queue
|

|`ipqlabel`
|Policy label to be updated for `ipq`
|
|===

Update the label on an IP fragment reassembly queue (`ipq`) based on the acceptance of the passed IP fragment mbuf header (`mbuf`).

[[mac-proc-labeling-event-ops]]
==== Process Labeling Event Operations

[[mac-mpo-create-cred]]
===== `mpo_create_cred`

[source,c]
----
void mpo_create_cred(	parent_cred, 	 
 	child_cred);	 
struct ucred *parent_cred;
struct ucred *child_cred;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`parent_cred`
|Parent subject credential
|

|`child_cred`
|Child subject credential
|
|===

Set the label of a newly created subject credential from the passed subject credential. This call will be made when man:crcopy[9] is invoked on a newly created struct ucred. This call should not be confused with a process forking or creation event.

[[mac-mpo-execve-transition]]
===== `mpo_execve_transition`

[source,c]
----
void mpo_execve_transition(	old, 	 
 	new, 	 
 	vp, 	 
 	vnodelabel);	 
struct ucred *old;
struct ucred *new;
struct vnode *vp;
struct label *vnodelabel;

----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`old`
|Existing subject credential
|Immutable

|`new`
|New subject credential to be labeled
|

|`vp`
|File to execute
|Locked

|`vnodelabel`
|Policy label for `vp`
|
|===

Update the label of a newly created subject credential (`new`) from the passed existing subject credential (`old`) based on a label transition caused by executing the passed vnode (`vp`). This call occurs when a process executes the passed vnode and one of the policies returns a success from the `mpo_execve_will_transition` entry point. Policies may choose to implement this call simply by invoking `mpo_create_cred` and passing the two subject credentials so as not to implement a transitioning event. Policies should not leave this entry point unimplemented if they implement `mpo_create_cred`, even if they do not implement `mpo_execve_will_transition`.

[[mac-mpo-execve-will-transition]]
===== `mpo_execve_will_transition`

[source,c]
----
int mpo_execve_will_transition(	old, 	 
 	vp, 	 
 	vnodelabel);	 
struct ucred *old;
struct vnode *vp;
struct label *vnodelabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`old`
|Subject credential prior to man:execve[2]
|Immutable

|`vp`
|File to execute
|

|`vnodelabel`
|Policy label for `vp`
|
|===

Determine whether the policy will want to perform a transition event as a result of the execution of the passed vnode by the passed subject credential. Return 1 if a transition is required, 0 if not. Even if a policy returns 0, it should behave correctly in the presence of an unexpected invocation of `mpo_execve_transition`, as that call may happen as a result of another policy requesting a transition.

[[mac-mpo-create-proc0]]
===== `mpo_create_proc0`

[source,c]
----
void mpo_create_proc0(	cred);	 
struct ucred *cred;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential to be filled in
|
|===

Create the subject credential of process 0, the parent of all kernel processes.

[[mac-mpo-create-proc1]]
===== `mpo_create_proc1`

[source,c]
----
void mpo_create_proc1(	cred);	 
struct ucred *cred;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential to be filled in
|
|===

Create the subject credential of process 1, the parent of all user processes.

[[mac-mpo-relabel-cred]]
===== `mpo_relabel_cred`

[source,c]
----
void mpo_relabel_cred(	cred, 	 
 	newlabel);	 
struct ucred *cred;
struct label *newlabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`newlabel`
|Label update to apply to `cred`
|
|===

Update the label on a subject credential from the passed update label.

[[mac-access-control-checks]]
=== Access Control Checks

Access control entry points permit policy modules to influence access control decisions made by the kernel. Generally, although not always, arguments to an access control entry point will include one or more authorizing credentials, information (possibly including a label) for any other objects involved in the operation. An access control entry point may return 0 to permit the operation, or an man:errno[2] error value. The results of invoking the entry point across various registered policy modules will be composed as follows: if all modules permit the operation to succeed, success will be returned. If one or modules returns a failure, a failure will be returned. If more than one module returns a failure, the errno value to return to the user will be selected using the following precedence, implemented by the `error_select()` function in [.filename]#kern_mac.c#:

[.informaltable]
[cols="1,1", frame="none"]
|===

|Most precedence
|EDEADLK

|
|EINVAL

|
|ESRCH

|
|EACCES

|Least precedence
|EPERM
|===

If none of the error values returned by all modules are listed in the precedence chart then an arbitrarily selected value from the set will be returned. In general, the rules provide precedence to errors in the following order: kernel failures, invalid arguments, object not present, access not permitted, other.

[[mac-mpo-bpfdesc-check-receive-from-ifnet]]
==== `mpo_check_bpfdesc_receive`

[source,c]
----
int mpo_check_bpfdesc_receive(	bpf_d, 	 
 	bpflabel, 	 
 	ifnet, 	 
 	ifnetlabel);	 
struct bpf_d *bpf_d;
struct label *bpflabel;
struct ifnet *ifnet;
struct label *ifnetlabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`bpf_d`
|Subject; BPF descriptor
|

|`bpflabel`
|Policy label for `bpf_d`
|

|`ifnet`
|Object; network interface
|

|`ifnetlabel`
|Policy label for `ifnet`
|
|===

Determine whether the MAC framework should permit datagrams from the passed interface to be delivered to the buffers of the passed BPF descriptor. Return (0) for success, or an `errno` value for failure Suggested failure: EACCES for label mismatches, EPERM for lack of privilege.

[[mac-mpo-check-kenv-dump]]
==== `mpo_check_kenv_dump`

[source,c]
----
int mpo_check_kenv_dump(	cred);	 
struct ucred *cred;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|
|===

Determine whether the subject should be allowed to retrieve the kernel environment (see man:kenv[2]).

[[mac-mpo-check-kenv-get]]
==== `mpo_check_kenv_get`

[source,c]
----
int mpo_check_kenv_get(	cred, 	 
 	name);	 
struct ucred *cred;
char *name;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`name`
|Kernel environment variable name
|
|===

Determine whether the subject should be allowed to retrieve the value of the specified kernel environment variable.

[[mac-mpo-check-kenv-set]]
==== `mpo_check_kenv_set`

[source,c]
----
int mpo_check_kenv_set(	cred, 	 
 	name);	 
struct ucred *cred;
char *name;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`name`
|Kernel environment variable name
|
|===

Determine whether the subject should be allowed to set the specified kernel environment variable.

[[mac-mpo-check-kenv-unset]]
==== `mpo_check_kenv_unset`

[source,c]
----
int mpo_check_kenv_unset(	cred, 	 
 	name);	 
struct ucred *cred;
char *name;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`name`
|Kernel environment variable name
|
|===

Determine whether the subject should be allowed to unset the specified kernel environment variable.

[[mac-mpo-check-kld-load]]
==== `mpo_check_kld_load`

[source,c]
----
int mpo_check_kld_load(	cred, 	 
 	vp, 	 
 	vlabel);	 
struct ucred *cred;
struct vnode *vp;
struct label *vlabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`vp`
|Kernel module vnode
|

|`vlabel`
|Label associated with `vp`
|
|===

Determine whether the subject should be allowed to load the specified module file.

[[mac-mpo-check-kld-stat]]
==== `mpo_check_kld_stat`

[source,c]
----
int mpo_check_kld_stat(	cred);	 
struct ucred *cred;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|
|===

Determine whether the subject should be allowed to retrieve a list of loaded kernel module files and associated statistics.

[[mac-mpo-check-kld-unload]]
==== `mpo_check_kld_unload`

[source,c]
----
int mpo_check_kld_unload(	cred);	 
struct ucred *cred;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|
|===

Determine whether the subject should be allowed to unload a kernel module.

[[mac-mpo-check-pipe-ioctl]]
==== `mpo_check_pipe_ioctl`

[source,c]
----
int mpo_check_pipe_ioctl(	cred, 	 
 	pipe, 	 
 	pipelabel, 	 
 	cmd, 	 
 	data);	 
struct ucred *cred;
struct pipe *pipe;
struct label *pipelabel;
unsigned long cmd;
void *data;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`pipe`
|Pipe
|

|`pipelabel`
|Policy label associated with `pipe`
|

|`cmd`
|man:ioctl[2] command
|

|`data`
|man:ioctl[2] data
|
|===

Determine whether the subject should be allowed to make the specified man:ioctl[2] call.

[[mac-mpo-check-pipe-poll]]
==== `mpo_check_pipe_poll`

[source,c]
----
int mpo_check_pipe_poll(	cred, 	 
 	pipe, 	 
 	pipelabel);	 
struct ucred *cred;
struct pipe *pipe;
struct label *pipelabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`pipe`
|Pipe
|

|`pipelabel`
|Policy label associated with `pipe`
|
|===

Determine whether the subject should be allowed to poll `pipe`.

[[mac-mpo-check-pipe-read]]
==== `mpo_check_pipe_read`

[source,c]
----
int mpo_check_pipe_read(	cred, 	 
 	pipe, 	 
 	pipelabel);	 
struct ucred *cred;
struct pipe *pipe;
struct label *pipelabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`pipe`
|Pipe
|

|`pipelabel`
|Policy label associated with `pipe`
|
|===

Determine whether the subject should be allowed read access to `pipe`.

[[mac-mpo-check-pipe-relabel]]
==== `mpo_check_pipe_relabel`

[source,c]
----
int mpo_check_pipe_relabel(	cred, 	 
 	pipe, 	 
 	pipelabel, 	 
 	newlabel);	 
struct ucred *cred;
struct pipe *pipe;
struct label *pipelabel;
struct label *newlabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`pipe`
|Pipe
|

|`pipelabel`
|Current policy label associated with `pipe`
|

|`newlabel`
|Label update to `pipelabel`
|
|===

Determine whether the subject should be allowed to relabel `pipe`.

[[mac-mpo-check-pipe-stat]]
==== `mpo_check_pipe_stat`

[source,c]
----
int mpo_check_pipe_stat(	cred, 	 
 	pipe, 	 
 	pipelabel);	 
struct ucred *cred;
struct pipe *pipe;
struct label *pipelabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`pipe`
|Pipe
|

|`pipelabel`
|Policy label associated with `pipe`
|
|===

Determine whether the subject should be allowed to retrieve statistics related to `pipe`.

[[mac-mpo-check-pipe-write]]
==== `mpo_check_pipe_write`

[source,c]
----
int mpo_check_pipe_write(	cred, 	 
 	pipe, 	 
 	pipelabel);	 
struct ucred *cred;
struct pipe *pipe;
struct label *pipelabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`pipe`
|Pipe
|

|`pipelabel`
|Policy label associated with `pipe`
|
|===

Determine whether the subject should be allowed to write to `pipe`.

[[mac-mpo-cred-check-socket-bind]]
==== `mpo_check_socket_bind`

[source,c]
----
int mpo_check_socket_bind(	cred, 	 
 	socket, 	 
 	socketlabel, 	 
 	sockaddr);	 
struct ucred *cred;
struct socket *socket;
struct label *socketlabel;
struct sockaddr *sockaddr;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`socket`
|Socket to be bound
|

|`socketlabel`
|Policy label for `socket`
|

|`sockaddr`
|Address of `socket`
|
|===

[[mac-mpo-cred-check-socket-connect]]
==== `mpo_check_socket_connect`

[source,c]
----
int mpo_check_socket_connect(	cred, 	 
 	socket, 	 
 	socketlabel, 	 
 	sockaddr);	 
struct ucred *cred;
struct socket *socket;
struct label *socketlabel;
struct sockaddr *sockaddr;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`socket`
|Socket to be connected
|

|`socketlabel`
|Policy label for `socket`
|

|`sockaddr`
|Address of `socket`
|
|===

Determine whether the subject credential (`cred`) can connect the passed socket (`socket`) to the passed socket address (`sockaddr`). Return 0 for success, or an `errno` value for failure. Suggested failure: EACCES for label mismatches, EPERM for lack of privilege.

[[mac-mpo-check-socket-receive]]
==== `mpo_check_socket_receive`

[source,c]
----
int mpo_check_socket_receive(	cred, 	 
 	so, 	 
 	socketlabel);	 
struct ucred *cred;
struct socket *so;
struct label *socketlabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`so`
|Socket
|

|`socketlabel`
|Policy label associated with `so`
|
|===

Determine whether the subject should be allowed to receive information from the socket `so`.

[[mac-mpo-check-socket-send]]
==== `mpo_check_socket_send`

[source,c]
----
int mpo_check_socket_send(	cred, 	 
 	so, 	 
 	socketlabel);	 
struct ucred *cred;
struct socket *so;
struct label *socketlabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`so`
|Socket
|

|`socketlabel`
|Policy label associated with `so`
|
|===

Determine whether the subject should be allowed to send information across the socket `so`.

[[mac-mpo-check-cred-visible]]
==== `mpo_check_cred_visible`

[source,c]
----
int mpo_check_cred_visible(	u1, 	 
 	u2);	 
struct ucred *u1;
struct ucred *u2;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`u1`
|Subject credential
|

|`u2`
|Object credential
|
|===

Determine whether the subject credential `u1` can "see" other subjects with the passed subject credential `u2`. Return 0 for success, or an `errno` value for failure. Suggested failure: EACCES for label mismatches, EPERM for lack of privilege, or ESRCH to hide visibility. This call may be made in a number of situations, including inter-process status sysctl's used by `ps`, and in procfs lookups.

[[mac-mpo-cred-check-socket-visible]]
==== `mpo_check_socket_visible`

[source,c]
----
int mpo_check_socket_visible(	cred, 	 
 	socket, 	 
 	socketlabel);	 
struct ucred *cred;
struct socket *socket;
struct label *socketlabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`socket`
|Object; socket
|

|`socketlabel`
|Policy label for `socket`
|
|===

[[mac-mpo-cred-check-ifnet-relabel]]
==== `mpo_check_ifnet_relabel`

[source,c]
----
int mpo_check_ifnet_relabel(	cred, 	 
 	ifnet, 	 
 	ifnetlabel, 	 
 	newlabel);	 
struct ucred *cred;
struct ifnet *ifnet;
struct label *ifnetlabel;
struct label *newlabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`ifnet`
|Object; network interface
|

|`ifnetlabel`
|Existing policy label for `ifnet`
|

|`newlabel`
|Policy label update to later be applied to `ifnet`
|
|===

Determine whether the subject credential can relabel the passed network interface to the passed label update.

[[mac-mpo-cred-check-socket-relabel]]
==== `mpo_check_socket_relabel`

[source,c]
----
int mpo_check_socket_relabel(	cred, 	 
 	socket, 	 
 	socketlabel, 	 
 	newlabel);	 
struct ucred *cred;
struct socket *socket;
struct label *socketlabel;
struct label *newlabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`socket`
|Object; socket
|

|`socketlabel`
|Existing policy label for `socket`
|

|`newlabel`
|Label update to later be applied to `socketlabel`
|
|===

Determine whether the subject credential can relabel the passed socket to the passed label update.

[[mac-mpo-cred-check-cred-relabel]]
==== `mpo_check_cred_relabel`

[source,c]
----
int mpo_check_cred_relabel(	cred, 	 
 	newlabel);	 
struct ucred *cred;
struct label *newlabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`newlabel`
|Label update to later be applied to `cred`
|
|===

Determine whether the subject credential can relabel itself to the passed label update.

[[mac-mpo-cred-check-vnode-relabel]]
==== `mpo_check_vnode_relabel`

[source,c]
----
int mpo_check_vnode_relabel(	cred, 	 
 	vp, 	 
 	vnodelabel, 	 
 	newlabel);	 
struct ucred *cred;
struct vnode *vp;
struct label *vnodelabel;
struct label *newlabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|Immutable

|`vp`
|Object; vnode
|Locked

|`vnodelabel`
|Existing policy label for `vp`
|

|`newlabel`
|Policy label update to later be applied to `vp`
|
|===

Determine whether the subject credential can relabel the passed vnode to the passed label update.

[[mpo-cred-check-mount-stat]]
==== `mpo_check_mount_stat`

[source,c]
----
int mpo_check_mount_stat(	cred, 	 
 	mp, 	 
 	mountlabel);	 
struct ucred *cred;
struct mount *mp;
struct label *mountlabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`mp`
|Object; file system mount
|

|`mountlabel`
|Policy label for `mp`
|
|===

Determine whether the subject credential can see the results of a statfs performed on the file system. Return 0 for success, or an `errno` value for failure. Suggested failure: EACCES for label mismatches or EPERM for lack of privilege. This call may be made in a number of situations, including during invocations of man:statfs[2] and related calls, as well as to determine what file systems to exclude from listings of file systems, such as when man:getfsstat[2] is invoked.

[[mac-mpo-cred-check-proc-debug]]
==== `mpo_check_proc_debug`

[source,c]
----
int mpo_check_proc_debug(	cred, 	 
 	proc);	 
struct ucred *cred;
struct proc *proc;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|Immutable

|`proc`
|Object; process
|
|===

Determine whether the subject credential can debug the passed process. Return 0 for success, or an `errno` value for failure. Suggested failure: EACCES for label mismatch, EPERM for lack of privilege, or ESRCH to hide visibility of the target. This call may be made in a number of situations, including use of the man:ptrace[2] and man:ktrace[2] APIs, as well as for some types of procfs operations.

[[mac-mpo-cred-check-vnode-access]]
==== `mpo_check_vnode_access`

[source,c]
----
int mpo_check_vnode_access(	cred, 	 
 	vp, 	 
 	label, 	 
 	flags);	 
struct ucred *cred;
struct vnode *vp;
struct label *label;
int flags;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`vp`
|Object; vnode
|

|`label`
|Policy label for `vp`
|

|`flags`
|man:access[2] flags
|
|===

Determine how invocations of man:access[2] and related calls by the subject credential should return when performed on the passed vnode using the passed access flags. This should generally be implemented using the same semantics used in `mpo_check_vnode_open`. Return 0 for success, or an `errno` value for failure. Suggested failure: EACCES for label mismatches or EPERM for lack of privilege.

[[mac-mpo-cred-check-vnode-chdir]]
==== `mpo_check_vnode_chdir`

[source,c]
----
int mpo_check_vnode_chdir(	cred, 	 
 	dvp, 	 
 	dlabel);	 
struct ucred *cred;
struct vnode *dvp;
struct label *dlabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`dvp`
|Object; vnode to man:chdir[2] into
|

|`dlabel`
|Policy label for `dvp`
|
|===

Determine whether the subject credential can change the process working directory to the passed vnode. Return 0 for success, or an `errno` value for failure. Suggested failure: EACCES for label mismatch, or EPERM for lack of privilege.

[[mac-mpo-check-vnode-chroot]]
==== `mpo_check_vnode_chroot`

[source,c]
----
int mpo_check_vnode_chroot(	cred, 	 
 	dvp, 	 
 	dlabel);	 
struct ucred *cred;
struct vnode *dvp;
struct label *dlabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`dvp`
|Directory vnode
|

|`dlabel`
|Policy label associated with `dvp`
|
|===

Determine whether the subject should be allowed to man:chroot[2] into the specified directory (`dvp`).

[[mac-mpo-cred-check-vnode-create]]
==== `mpo_check_vnode_create`

[source,c]
----
int mpo_check_vnode_create(	cred, 	 
 	dvp, 	 
 	dlabel, 	 
 	cnp, 	 
 	vap);	 
struct ucred *cred;
struct vnode *dvp;
struct label *dlabel;
struct componentname *cnp;
struct vattr *vap;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`dvp`
|Object; vnode
|

|`dlabel`
|Policy label for `dvp`
|

|`cnp`
|Component name for `dvp`
|

|`vap`
|vnode attributes for `vap`
|
|===

Determine whether the subject credential can create a vnode with the passed parent directory, passed name information, and passed attribute information. Return 0 for success, or an `errno` value for failure. Suggested failure: EACCES for label mismatch, or EPERM for lack of privilege. This call may be made in a number of situations, including as a result of calls to man:open[2] with O_CREAT, man:mkfifo[2], and others.

[[mac-mpo-cred-check-vnode-delete]]
==== `mpo_check_vnode_delete`

[source,c]
----
int mpo_check_vnode_delete(	cred, 	 
 	dvp, 	 
 	dlabel, 	 
 	vp, 	 
 	label, 	 
 	cnp);	 
struct ucred *cred;
struct vnode *dvp;
struct label *dlabel;
struct vnode *vp;
void *label;
struct componentname *cnp;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`dvp`
|Parent directory vnode
|

|`dlabel`
|Policy label for `dvp`
|

|`vp`
|Object; vnode to delete
|

|`label`
|Policy label for `vp`
|

|`cnp`
|Component name for `vp`
|
|===

Determine whether the subject credential can delete a vnode from the passed parent directory and passed name information. Return 0 for success, or an `errno` value for failure. Suggested failure: EACCES for label mismatch, or EPERM for lack of privilege. This call may be made in a number of situations, including as a result of calls to man:unlink[2] and man:rmdir[2]. Policies implementing this entry point should also implement `mpo_check_rename_to` to authorize deletion of objects as a result of being the target of a rename.

[[mac-mpo-cred-check-vnode-deleteacl]]
==== `mpo_check_vnode_deleteacl`

[source,c]
----
int mpo_check_vnode_deleteacl(	cred, 	 
 	vp, 	 
 	label, 	 
 	type);	 
struct ucred *cred;
struct vnode *vp;
struct label *label;
acl_type_t type;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|Immutable

|`vp`
|Object; vnode
|Locked

|`label`
|Policy label for `vp`
|

|`type`
|ACL type
|
|===

Determine whether the subject credential can delete the ACL of passed type from the passed vnode. Return 0 for success, or an `errno` value for failure. Suggested failure: EACCES for label mismatch, or EPERM for lack of privilege.

[[mac-mpo-cred-check-vnode-exec]]
==== `mpo_check_vnode_exec`

[source,c]
----
int mpo_check_vnode_exec(	cred, 	 
 	vp, 	 
 	label);	 
struct ucred *cred;
struct vnode *vp;
struct label *label;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`vp`
|Object; vnode to execute
|

|`label`
|Policy label for `vp`
|
|===

Determine whether the subject credential can execute the passed vnode. Determination of execute privilege is made separately from decisions about any transitioning event. Return 0 for success, or an `errno` value for failure. Suggested failure: EACCES for label mismatch, or EPERM for lack of privilege.

[[mpo-cred-check-vnode-getacl]]
==== `mpo_check_vnode_getacl`

[source,c]
----
int mpo_check_vnode_getacl(	cred, 	 
 	vp, 	 
 	label, 	 
 	type);	 
struct ucred *cred;
struct vnode *vp;
struct label *label;
acl_type_t type;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`vp`
|Object; vnode
|

|`label`
|Policy label for `vp`
|

|`type`
|ACL type
|
|===

Determine whether the subject credential can retrieve the ACL of passed type from the passed vnode. Return 0 for success, or an `errno` value for failure. Suggested failure: EACCES for label mismatch, or EPERM for lack of privilege.

[[mac-mpo-cred-check-vnode-getextattr]]
==== `mpo_check_vnode_getextattr`

[source,c]
----
int mpo_check_vnode_getextattr(	cred, 	 
 	vp, 	 
 	label, 	 
 	attrnamespace, 	 
 	name, 	 
 	uio);	 
struct ucred *cred;
struct vnode *vp;
struct label *label;
int attrnamespace;
const char *name;
struct uio *uio;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`vp`
|Object; vnode
|

|`label`
|Policy label for `vp`
|

|`attrnamespace`
|Extended attribute namespace
|

|`name`
|Extended attribute name
|

|`uio`
|I/O structure pointer; see man:uio[9]
|
|===

Determine whether the subject credential can retrieve the extended attribute with the passed namespace and name from the passed vnode. Policies implementing labeling using extended attributes may be interested in special handling of operations on those extended attributes. Return 0 for success, or an `errno` value for failure. Suggested failure: EACCES for label mismatch, or EPERM for lack of privilege.

[[mac-mpo-check-vnode-link]]
==== `mpo_check_vnode_link`

[source,c]
----
int mpo_check_vnode_link(	cred, 	 
 	dvp, 	 
 	dlabel, 	 
 	vp, 	 
 	label, 	 
 	cnp);	 
struct ucred *cred;
struct vnode *dvp;
struct label *dlabel;
struct vnode *vp;
struct label *label;
struct componentname *cnp;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`dvp`
|Directory vnode
|

|`dlabel`
|Policy label associated with `dvp`
|

|`vp`
|Link destination vnode
|

|`label`
|Policy label associated with `vp`
|

|`cnp`
|Component name for the link being created
|
|===

Determine whether the subject should be allowed to create a link to the vnode `vp` with the name specified by `cnp`.

[[mac-mpo-check-vnode-mmap]]
==== `mpo_check_vnode_mmap`

[source,c]
----
int mpo_check_vnode_mmap(	cred, 	 
 	vp, 	 
 	label, 	 
 	prot);	 
struct ucred *cred;
struct vnode *vp;
struct label *label;
int prot;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`vp`
|Vnode to map
|

|`label`
|Policy label associated with `vp`
|

|`prot`
|Mmap protections (see man:mmap[2])
|
|===

Determine whether the subject should be allowed to map the vnode `vp` with the protections specified in `prot`.

[[mac-mpo-check-vnode-mmap-downgrade]]
==== `mpo_check_vnode_mmap_downgrade`

[source,c]
----
void mpo_check_vnode_mmap_downgrade(	cred, 	 
 	vp, 	 
 	label, 	 
 	prot);	 
struct ucred *cred;
struct vnode *vp;
struct label *label;
int *prot;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|See <<mac-mpo-check-vnode-mmap>>.
|

|`vp`
|
|

|`label`
|
|

|`prot`
|Mmap protections to be downgraded
|
|===

Downgrade the mmap protections based on the subject and object labels.

[[mac-mpo-check-vnode-mprotect]]
==== `mpo_check_vnode_mprotect`

[source,c]
----
int mpo_check_vnode_mprotect(	cred, 	 
 	vp, 	 
 	label, 	 
 	prot);	 
struct ucred *cred;
struct vnode *vp;
struct label *label;
int prot;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`vp`
|Mapped vnode
|

|`prot`
|Memory protections
|
|===

Determine whether the subject should be allowed to set the specified memory protections on memory mapped from the vnode `vp`.

[[mac-mpo-check-vnode-poll]]
==== `mpo_check_vnode_poll`

[source,c]
----
int mpo_check_vnode_poll(	active_cred, 	 
 	file_cred, 	 
 	vp, 	 
 	label);	 
struct ucred *active_cred;
struct ucred *file_cred;
struct vnode *vp;
struct label *label;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`active_cred`
|Subject credential
|

|`file_cred`
|Credential associated with the struct file
|

|`vp`
|Polled vnode
|

|`label`
|Policy label associated with `vp`
|
|===

Determine whether the subject should be allowed to poll the vnode `vp`.

[[mac-mpo-check-vnode-rename-from]]
==== `mpo_check_vnode_rename_from`

[source,c]
----
int mpo_vnode_rename_from(	cred, 	 
 	dvp, 	 
 	dlabel, 	 
 	vp, 	 
 	label, 	 
 	cnp);	 
struct ucred *cred;
struct vnode *dvp;
struct label *dlabel;
struct vnode *vp;
struct label *label;
struct componentname *cnp;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`dvp`
|Directory vnode
|

|`dlabel`
|Policy label associated with `dvp`
|

|`vp`
|Vnode to be renamed
|

|`label`
|Policy label associated with `vp`
|

|`cnp`
|Component name for `vp`
|
|===

Determine whether the subject should be allowed to rename the vnode `vp` to something else.

[[mac-mpo-check-vnode-rename-to]]
==== `mpo_check_vnode_rename_to`

[source,c]
----
int mpo_check_vnode_rename_to(	cred, 	 
 	dvp, 	 
 	dlabel, 	 
 	vp, 	 
 	label, 	 
 	samedir, 	 
 	cnp);	 
struct ucred *cred;
struct vnode *dvp;
struct label *dlabel;
struct vnode *vp;
struct label *label;
int samedir;
struct componentname *cnp;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`dvp`
|Directory vnode
|

|`dlabel`
|Policy label associated with `dvp`
|

|`vp`
|Overwritten vnode
|

|`label`
|Policy label associated with `vp`
|

|`samedir`
|Boolean; `1` if the source and destination directories are the same
|

|`cnp`
|Destination component name
|
|===

Determine whether the subject should be allowed to rename to the vnode `vp`, into the directory `dvp`, or to the name represented by `cnp`. If there is no existing file to overwrite, `vp` and `label` will be NULL.

[[mac-mpo-cred-check-socket-listen]]
==== `mpo_check_socket_listen`

[source,c]
----
int mpo_check_socket_listen(	cred, 	 
 	socket, 	 
 	socketlabel);	 
struct ucred *cred;
struct socket *socket;
struct label *socketlabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`socket`
|Object; socket
|

|`socketlabel`
|Policy label for `socket`
|
|===

Determine whether the subject credential can listen on the passed socket. Return 0 for success, or an `errno` value for failure. Suggested failure: EACCES for label mismatch, or EPERM for lack of privilege.

[[mac-mpo-cred-check-vnode-lookup]]
==== `mpo_check_vnode_lookup`

[source,c]
----
int mpo_check_vnode_lookup(	, 	 
 	, 	 
 	, 	 
 	cnp);	 
struct ucred *cred;
struct vnode *dvp;
struct label *dlabel;
struct componentname *cnp;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`dvp`
|Object; vnode
|

|`dlabel`
|Policy label for `dvp`
|

|`cnp`
|Component name being looked up
|
|===

Determine whether the subject credential can perform a lookup in the passed directory vnode for the passed name. Return 0 for success, or an `errno` value for failure. Suggested failure: EACCES for label mismatch, or EPERM for lack of privilege.

[[mac-mpo-cred-check-vnode-open]]
==== `mpo_check_vnode_open`

[source,c]
----
int mpo_check_vnode_open(	cred, 	 
 	vp, 	 
 	label, 	 
 	acc_mode);	 
struct ucred *cred;
struct vnode *vp;
struct label *label;
int acc_mode;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`vp`
|Object; vnode
|

|`label`
|Policy label for `vp`
|

|`acc_mode`
|man:open[2] access mode
|
|===

Determine whether the subject credential can perform an open operation on the passed vnode with the passed access mode. Return 0 for success, or an errno value for failure. Suggested failure: EACCES for label mismatch, or EPERM for lack of privilege.

[[mac-mpo-cred-check-vnode-readdir]]
==== `mpo_check_vnode_readdir`

[source,c]
----
int mpo_check_vnode_readdir(	, 	 
 	, 	 
 	);	 
struct ucred *cred;
struct vnode *dvp;
struct label *dlabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`dvp`
|Object; directory vnode
|

|`dlabel`
|Policy label for `dvp`
|
|===

Determine whether the subject credential can perform a `readdir` operation on the passed directory vnode. Return 0 for success, or an `errno` value for failure. Suggested failure: EACCES for label mismatch, or EPERM for lack of privilege.

[[mac-mpo-cred-check-vnode-readlink]]
==== `mpo_check_vnode_readlink`

[source,c]
----
int mpo_check_vnode_readlink(	cred, 	 
 	vp, 	 
 	label);	 
struct ucred *cred;
struct vnode *vp;
struct label *label;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`vp`
|Object; vnode
|

|`label`
|Policy label for `vp`
|
|===

Determine whether the subject credential can perform a `readlink` operation on the passed symlink vnode. Return 0 for success, or an `errno` value for failure. Suggested failure: EACCES for label mismatch, or EPERM for lack of privilege. This call may be made in a number of situations, including an explicit `readlink` call by the user process, or as a result of an implicit `readlink` during a name lookup by the process.

[[mac-mpo-cred-check-vnode-revoke]]
==== `mpo_check_vnode_revoke`

[source,c]
----
int mpo_check_vnode_revoke(	cred, 	 
 	vp, 	 
 	label);	 
struct ucred *cred;
struct vnode *vp;
struct label *label;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`vp`
|Object; vnode
|

|`label`
|Policy label for `vp`
|
|===

Determine whether the subject credential can revoke access to the passed vnode. Return 0 for success, or an `errno` value for failure. Suggested failure: EACCES for label mismatch, or EPERM for lack of privilege.

[[mac-mpo-cred-check-vnode-setacl]]
==== `mpo_check_vnode_setacl`

[source,c]
----
int mpo_check_vnode_setacl(	cred, 	 
 	vp, 	 
 	label, 	 
 	type, 	 
 	acl);	 
struct ucred *cred;
struct vnode *vp;
struct label *label;
acl_type_t type;
struct acl *acl;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`vp`
|Object; vnode
|

|`label`
|Policy label for `vp`
|

|`type`
|ACL type
|

|`acl`
|ACL
|
|===

Determine whether the subject credential can set the passed ACL of passed type on the passed vnode. Return 0 for success, or an `errno` value for failure. Suggested failure: EACCES for label mismatch, or EPERM for lack of privilege.

[[mac-mpo-cred-check-vnode-setextattr]]
==== `mpo_check_vnode_setextattr`

[source,c]
----
int mpo_check_vnode_setextattr(	cred, 	 
 	vp, 	 
 	label, 	 
 	attrnamespace, 	 
 	name, 	 
 	uio);	 
struct ucred *cred;
struct vnode *vp;
struct label *label;
int attrnamespace;
const char *name;
struct uio *uio;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`vp`
|Object; vnode
|

|`label`
|Policy label for `vp`
|

|`attrnamespace`
|Extended attribute namespace
|

|`name`
|Extended attribute name
|

|`uio`
|I/O structure pointer; see man:uio[9]
|
|===

Determine whether the subject credential can set the extended attribute of passed name and passed namespace on the passed vnode. Policies implementing security labels backed into extended attributes may want to provide additional protections for those attributes. Additionally, policies should avoid making decisions based on the data referenced from `uio`, as there is a potential race condition between this check and the actual operation. The `uio` may also be `NULL` if a delete operation is being performed. Return 0 for success, or an `errno` value for failure. Suggested failure: EACCES for label mismatch, or EPERM for lack of privilege.

[[mac-mpo-cred-check-vnode-setflags]]
==== `mpo_check_vnode_setflags`

[source,c]
----
int mpo_check_vnode_setflags(	cred, 	 
 	vp, 	 
 	label, 	 
 	flags);	 
struct ucred *cred;
struct vnode *vp;
struct label *label;
u_long flags;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`vp`
|Object; vnode
|

|`label`
|Policy label for `vp`
|

|`flags`
|File flags; see man:chflags[2]
|
|===

Determine whether the subject credential can set the passed flags on the passed vnode. Return 0 for success, or an `errno` value for failure. Suggested failure: EACCES for label mismatch, or EPERM for lack of privilege.

[[mac-mpo-cred-check-vnode-setmode]]
==== `mpo_check_vnode_setmode`

[source,c]
----
int mpo_check_vnode_setmode(	cred, 	 
 	vp, 	 
 	label, 	 
 	mode);	 
struct ucred *cred;
struct vnode *vp;
struct label *label;
mode_t mode;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`vp`
|Object; vnode
|

|`label`
|Policy label for `vp`
|

|`mode`
|File mode; see man:chmod[2]
|
|===

Determine whether the subject credential can set the passed mode on the passed vnode. Return 0 for success, or an `errno` value for failure. Suggested failure: EACCES for label mismatch, or EPERM for lack of privilege.

[[mac-mpo-cred-check-vnode-setowner]]
==== `mpo_check_vnode_setowner`

[source,c]
----
int mpo_check_vnode_setowner(	cred, 	 
 	vp, 	 
 	label, 	 
 	uid, 	 
 	gid);	 
struct ucred *cred;
struct vnode *vp;
struct label *label;
uid_t uid;
gid_t gid;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`vp`
|Object; vnode
|

|`label`
|Policy label for `vp`
|

|`uid`
|User ID
|

|`gid`
|Group ID
|
|===

Determine whether the subject credential can set the passed uid and passed gid as file uid and file gid on the passed vnode. The IDs may be set to (`-1`) to request no update. Return 0 for success, or an `errno` value for failure. Suggested failure: EACCES for label mismatch, or EPERM for lack of privilege.

[[mac-mpo-cred-check-vnode-setutimes]]
==== `mpo_check_vnode_setutimes`

[source,c]
----
int mpo_check_vnode_setutimes(	, 	 
 	, 	 
 	, 	 
 	, 	 
 	);	 
struct ucred *cred;
struct vnode *vp;
struct label *label;
struct timespec atime;
struct timespec mtime;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`vp`
|Object; vp
|

|`label`
|Policy label for `vp`
|

|`atime`
|Access time; see man:utimes[2]
|

|`mtime`
|Modification time; see man:utimes[2]
|
|===

Determine whether the subject credential can set the passed access timestamps on the passed vnode. Return 0 for success, or an `errno` value for failure. Suggested failure: EACCES for label mismatch, or EPERM for lack of privilege.

[[mac-mpo-cred-check-proc-sched]]
==== `mpo_check_proc_sched`

[source,c]
----
int mpo_check_proc_sched(	ucred, 	 
 	proc);	 
struct ucred *ucred;
struct proc *proc;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`proc`
|Object; process
|
|===

Determine whether the subject credential can change the scheduling parameters of the passed process. Return 0 for success, or an `errno` value for failure. Suggested failure: EACCES for label mismatch, EPERM for lack of privilege, or ESRCH to limit visibility.

See man:setpriority[2] for more information.

[[mac-mpo-cred-check-proc-signal]]
==== `mpo_check_proc_signal`

[source,c]
----
int mpo_check_proc_signal(	cred, 	 
 	proc, 	 
 	signal);	 
struct ucred *cred;
struct proc *proc;
int signal;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`proc`
|Object; process
|

|`signal`
|Signal; see man:kill[2]
|
|===

Determine whether the subject credential can deliver the passed signal to the passed process. Return 0 for success, or an `errno` value for failure. Suggested failure: EACCES for label mismatch, EPERM for lack of privilege, or ESRCH to limit visibility.

[[mac-mpo-cred-check-vnode-stat]]
==== `mpo_check_vnode_stat`

[source,c]
----
int mpo_check_vnode_stat(	cred, 	 
 	vp, 	 
 	label);	 
struct ucred *cred;
struct vnode *vp;
struct label *label;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`vp`
|Object; vnode
|

|`label`
|Policy label for `vp`
|
|===

Determine whether the subject credential can `stat` the passed vnode. Return 0 for success, or an `errno` value for failure. Suggested failure: EACCES for label mismatch, or EPERM for lack of privilege.

See man:stat[2] for more information.

[[mac-mpo-cred-check-ifnet-transmit]]
==== `mpo_check_ifnet_transmit`

[source,c]
----
int mpo_check_ifnet_transmit(	cred, 	 
 	ifnet, 	 
 	ifnetlabel, 	 
 	mbuf, 	 
 	mbuflabel);	 
struct ucred *cred;
struct ifnet *ifnet;
struct label *ifnetlabel;
struct mbuf *mbuf;
struct label *mbuflabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`ifnet`
|Network interface
|

|`ifnetlabel`
|Policy label for `ifnet`
|

|`mbuf`
|Object; mbuf to be sent
|

|`mbuflabel`
|Policy label for `mbuf`
|
|===

Determine whether the network interface can transmit the passed mbuf. Return 0 for success, or an `errno` value for failure. Suggested failure: EACCES for label mismatch, or EPERM for lack of privilege.

[[mac-mpo-cred-check-socket-deliver]]
==== `mpo_check_socket_deliver`

[source,c]
----
int mpo_check_socket_deliver(	cred, 	 
 	ifnet, 	 
 	ifnetlabel, 	 
 	mbuf, 	 
 	mbuflabel);	 
struct ucred *cred;
struct ifnet *ifnet;
struct label *ifnetlabel;
struct mbuf *mbuf;
struct label *mbuflabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`ifnet`
|Network interface
|

|`ifnetlabel`
|Policy label for `ifnet`
|

|`mbuf`
|Object; mbuf to be delivered
|

|`mbuflabel`
|Policy label for `mbuf`
|
|===

Determine whether the socket may receive the datagram stored in the passed mbuf header. Return 0 for success, or an `errno` value for failure. Suggested failures: EACCES for label mismatch, or EPERM for lack of privilege.

[[mac-mpo-check-socket-visible]]
==== `mpo_check_socket_visible`

[source,c]
----
int mpo_check_socket_visible(	cred, 	 
 	so, 	 
 	socketlabel);	 
struct ucred *cred;
struct socket *so;
struct label *socketlabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|Immutable

|`so`
|Object; socket
|

|`socketlabel`
|Policy label for `so`
|
|===

Determine whether the subject credential cred can "see" the passed socket (`socket`) using system monitoring functions, such as those employed by man:netstat[8] and man:sockstat[1]. Return 0 for success, or an `errno` value for failure. Suggested failure: EACCES for label mismatches, EPERM for lack of privilege, or ESRCH to hide visibility.

[[mac-mpo-check-system-acct]]
==== `mpo_check_system_acct`

[source,c]
----
int mpo_check_system_acct(	ucred, 	 
 	vp, 	 
 	vlabel);	 
struct ucred *ucred;
struct vnode *vp;
struct label *vlabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`ucred`
|Subject credential
|

|`vp`
|Accounting file; man:acct[5]
|

|`vlabel`
|Label associated with `vp`
|
|===

Determine whether the subject should be allowed to enable accounting, based on its label and the label of the accounting log file.

[[mac-mpo-check-system-nfsd]]
==== `mpo_check_system_nfsd`

[source,c]
----
int mpo_check_system_nfsd(	cred);	 
struct ucred *cred;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|
|===

Determine whether the subject should be allowed to call man:nfssvc[2].

[[mac-mpo-check-system-reboot]]
==== `mpo_check_system_reboot`

[source,c]
----
int mpo_check_system_reboot(	cred, 	 
 	howto);	 
struct ucred *cred;
int howto;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`howto`
|`howto` parameter from man:reboot[2]
|
|===

Determine whether the subject should be allowed to reboot the system in the specified manner.

[[mac-mpo-check-system-settime]]
==== `mpo_check_system_settime`

[source,c]
----
int mpo_check_system_settime(	cred);	 
struct ucred *cred;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|
|===

Determine whether the user should be allowed to set the system clock.

[[mac-mpo-check-system-swapon]]
==== `mpo_check_system_swapon`

[source,c]
----
int mpo_check_system_swapon(	cred, 	 
 	vp, 	 
 	vlabel);	 
struct ucred *cred;
struct vnode *vp;
struct label *vlabel;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`vp`
|Swap device
|

|`vlabel`
|Label associated with `vp`
|
|===

Determine whether the subject should be allowed to add `vp` as a swap device.

[[mac-mpo-check-system-sysctl]]
==== `mpo_check_system_sysctl`

[source,c]
----
int mpo_check_system_sysctl(	cred, 	 
 	name, 	 
 	namelen, 	 
 	old, 	 
 	oldlenp, 	 
 	inkernel, 	 
 	new, 	 
 	newlen);	 
struct ucred *cred;
int *name;
u_int *namelen;
void *old;
size_t *oldlenp;
int inkernel;
void *new;
size_t newlen;
----

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Parameter
| Description
| Locking

|`cred`
|Subject credential
|

|`name`
|See man:sysctl[3]
|

|`namelen`
|
|

|`old`
|
|

|`oldlenp`
|
|

|`inkernel`
|Boolean; `1` if called from kernel
|

|`new`
|See man:sysctl[3]
|

|`newlen`
|
|
|===

Determine whether the subject should be allowed to make the specified man:sysctl[3] transaction.

[[mac-label-management]]
=== Label Management Calls

Relabel events occur when a user process has requested that the label on an object be modified. A two-phase update occurs: first, an access control check will be performed to determine if the update is both valid and permitted, and then the update itself is performed via a separate entry point. Relabel entry points typically accept the object, object label reference, and an update label submitted by the process. Memory allocation during relabel is discouraged, as relabel calls are not permitted to fail (failure should be reported earlier in the relabel check).

[[mac-userland-arch]]
== Userland Architecture

The TrustedBSD MAC Framework includes a number of policy-agnostic elements, including MAC library interfaces for abstractly managing labels, modifications to the system credential management and login libraries to support the assignment of MAC labels to users, and a set of tools to monitor and modify labels on processes, files, and network interfaces. More details on the user architecture will be added to this section in the near future.

[[mac-userland-labels]]
=== APIs for Policy-Agnostic Label Management

The TrustedBSD MAC Framework provides a number of library and system calls permitting applications to manage MAC labels on objects using a policy-agnostic interface. This permits applications to manipulate labels for a variety of policies without being written to support specific policies. These interfaces are used by general-purpose tools such as man:ifconfig[8], man:ls[1] and man:ps[1] to view labels on network interfaces, files, and processes. The APIs also support MAC management tools including man:getfmac[8], man:getpmac[8], man:setfmac[8], man:setfsmac[8], and man:setpmac[8]. The MAC APIs are documented in man:mac[3].

Applications handle MAC labels in two forms: an internalized form used to return and set labels on processes and objects (`mac_t`), and externalized form based on C strings appropriate for storage in configuration files, display to the user, or input from the user. Each MAC label contains a number of elements, each consisting of a name and value pair. Policy modules in the kernel bind to specific names and interpret the values in policy-specific ways. In the externalized string form, labels are represented by a comma-delimited list of name and value pairs separated by the `/` character. Labels may be directly converted to and from text using provided APIs; when retrieving labels from the kernel, internalized label storage must first be prepared for the desired label element set. Typically, this is done in one of two ways: using man:mac_prepare[3] and an arbitrary list of desired label elements, or one of the variants of the call that loads a default element set from the man:mac.conf[5] configuration file. Per-object defaults permit application writers to usefully display labels associated with objects without being aware of the policies present in the system.

[NOTE]
====
Currently, direct manipulation of label elements other than by conversion to a text string, string editing, and conversion back to an internalized label is not supported by the MAC library. Such interfaces may be added in the future if they prove necessary for application writers.
====

[[mac-userland-credentials]]
=== Binding of Labels to Users

The standard user context management interface, man:setusercontext[3], has been modified to retrieve MAC labels associated with a user's class from man:login.conf[5]. These labels are then set along with other user context when either `LOGIN_SETALL` is specified, or when `LOGIN_SETMAC` is explicitly specified.

[NOTE]
====
It is expected that, in a future version of FreeBSD, the MAC label database will be separated from the [.filename]#login.conf# user class abstraction, and be maintained in a separate database. However, the man:setusercontext[3] API should remain the same following such a change.
====

[[mac-conclusion]]
== Conclusion

The TrustedBSD MAC framework permits kernel modules to augment the system security policy in a highly integrated manner. They may do this based on existing object properties, or based on label data that is maintained with the assistance of the MAC framework. The framework is sufficiently flexible to implement a variety of policy types, including information flow security policies such as MLS and Biba, as well as policies based on existing BSD credentials or file protections. Policy authors may wish to consult this documentation as well as existing security modules when implementing a new security service.
