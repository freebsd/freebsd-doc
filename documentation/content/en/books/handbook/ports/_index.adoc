---
title: "Chapter 4. Installing Applications: Packages and Ports"
part: Part I. Getting Started
prev: books/handbook/basics
next: books/handbook/x11
description: "FreeBSD provides two complementary technologies for installing third-party software: the FreeBSD Ports Collection, for installing from source, and packages, for installing from pre-built binaries"
tags: ["ports", "collection", "pkg", "poudriere", "management"]
showBookMenu: true
weight: 6
path: "/books/handbook/"
aliases: [
"/en/books/handbook/ports-overview/",
"/en/books/handbook/ports-finding-applications/",
"/en/books/handbook/pkgng-intro/",
"/en/books/handbook/ports-using/",
"/en/books/handbook/ports-poudriere/",
"/en/books/handbook/ports-nextsteps/",
"/en/books/handbook/ports-broken/"
]
---

[[ports]]
= Installing Applications: Packages and Ports
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 4
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/ports/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[ports-synopsis]]
== Synopsis

FreeBSD is bundled with a rich collection of system tools as part of the base system.
In addition, FreeBSD provides two complementary technologies for installing third-party software: the FreeBSD Ports Collection,
for installing from source, and packages, for installing from pre-built binaries.
Either method may be used to install software from local media or from the network.

After reading this chapter, you will know:

* The difference between binary packages and ports.
* How to find third-party software that has been ported to FreeBSD.
* How to manage binary packages using pkg.
* How to build third-party software from source using the Ports Collection.
* How to find the files installed with the application for post-installation configuration.
* What to do if a software installation fails.

[[ports-overview]]
== Overview of Software Installation

The typical steps for installing third-party software on a UNIX(R) system include:

[.procedure]
. Find and download the software, which might be distributed in source code format or as a binary.
. Unpack the software from its distribution format. This is typically a tarball compressed with a program such as man:compress[1], man:gzip[1], man:bzip2[1] or man:xz[1].
. Locate the documentation in [.filename]#INSTALL#, [.filename]#README# or some file in a [.filename]#doc/# subdirectory and read up on how to install the software.
. If the software was distributed in source format, compile it. This may involve editing a [.filename]#Makefile# or running a `configure` script.
. Test and install the software.

A FreeBSD _port_ is a collection of files designed to automate the process of compiling an application from source code.
The files that comprise a port contain all the necessary information to automatically download, extract, patch, compile, and install the application.

If the software has not already been adapted and tested on FreeBSD, the source code might need editing in order for it to install and run properly.

However, over link:https://www.FreeBSD.org/ports/[{numports}] third-party applications have already been ported to FreeBSD.
When feasible, these applications are made available for download as pre-compiled _packages_.

Packages can be manipulated with the FreeBSD package management commands.

Both packages and ports understand dependencies.
If a package or port is used to install an application and a dependent library is not already installed, the library will automatically be installed first.

A FreeBSD package contains pre-compiled copies of all the commands for an application, as well as any configuration files and documentation.
A package can be manipulated with the man:pkg[8] commands, such as `pkg install`.

While the two technologies are similar, packages and ports each have their own strengths.
Select the technology that meets your requirements for installing a particular application.

.Package Benefits
* A compressed package tarball is typically smaller than the compressed tarball containing the source code for the application.
* Packages do not require compilation time. For large applications, such as Mozilla, KDE, or GNOME, this can be important on a slow system.
* Packages do not require any understanding of the process involved in compiling software on FreeBSD.

.Port Benefits
* Packages are normally compiled with conservative options because they have to run on the maximum number of systems. By compiling from the port, one can change the compilation options.
* Some applications have compile-time options relating to which features are installed. For example, Apache can be configured with a wide variety of different built-in options.
+
In some cases, multiple packages will exist for the same application to specify certain settings. For example, Ghostscript is available as a [.filename]#ghostscript# package and a [.filename]#ghostscript-nox11# package, depending on whether or not Xorg is installed. Creating multiple packages rapidly becomes impossible if an application has more than one or two different compile-time options.
* The licensing conditions of some software forbid binary distribution. Such software must be distributed as source code which must be compiled by the end-user.
* Some people do not trust binary distributions or prefer to read through source code in order to look for potential problems.
* Source code is needed in order to apply custom patches.

To keep track of updated ports, subscribe to the {freebsd-ports} and the {freebsd-ports-bugs}.

[WARNING]
====

Before installing any application, check https://vuxml.freebsd.org/[] for security issues related to the application or type `pkg audit -F` to check all installed applications for known vulnerabilities.
====

The remainder of this chapter explains how to use packages and ports to install and manage third-party software on FreeBSD.

[[ports-finding-applications]]
== Finding Software

FreeBSD's list of available applications is growing all the time.
There are a number of ways to find software to install:

* The FreeBSD web site maintains an up-to-date searchable list of all the available applications, at link:https://www.FreeBSD.org/ports/[https://www.FreeBSD.org/ports/]. The ports can be searched by application name or by software category.
* Dan Langille maintains http://www.FreshPorts.org/[FreshPorts.org] which provides a comprehensive search utility and also tracks changes to the applications in the Ports Collection. Registered users can create a customized watch list in order to receive an automated email when their watched ports are updated.
* If finding a particular application becomes challenging, try searching a site like http://www.sourceforge.net/[SourceForge.net] or http://www.github.com/[GitHub.com] then check back at the link:https://www.FreeBSD.org/ports/[FreeBSD site] to see if the application has been ported.
* To search the binary package repository for an application:
+
[source,shell]
....
# pkg search subversion
git-subversion-1.9.2
java-subversion-1.8.8_2
p5-subversion-1.8.8_2
py27-hgsubversion-1.6
py27-subversion-1.8.8_2
ruby-subversion-1.8.8_2
subversion-1.8.8_2
subversion-book-4515
subversion-static-1.8.8_2
subversion16-1.6.23_4
subversion17-1.7.16_2
....
+
Package names include the version number and, in the case of ports based on python, the version number of the version of python the package was built with.
Some ports also have multiple versions available.
In the case of Subversion, there are different versions available, as well as different compile options.
In this case, the statically linked version of Subversion.
When indicating which package to install, it is best to specify the application by the port origin, which is the path in the ports tree.
Repeat the `pkg search` with `-o` to list the origin of each package:
+
[source,shell]
....
# pkg search -o subversion
devel/git-subversion
java/java-subversion
devel/p5-subversion
devel/py-hgsubversion
devel/py-subversion
devel/ruby-subversion
devel/subversion16
devel/subversion17
devel/subversion
devel/subversion-book
devel/subversion-static
....
+
Searching by shell globs, regular expressions, exact match, by description, or any other field in the repository database is also supported by `pkg search`.
After installing package:ports-mgmt/pkg[] or package:ports-mgmt/pkg-devel[], see man:pkg-search[8] for more details.
* If the Ports Collection is already installed, there are several methods to query the local version of the ports tree. To find out which category a port is in, type `whereis _file_`, where _file_ is the program to be installed:
+
[source,shell]
....
# whereis lsof
lsof: /usr/ports/sysutils/lsof
....
+
Alternately, an man:echo[1] statement can be used:
+
[source,shell]
....
# echo /usr/ports/*/*lsof*
/usr/ports/sysutils/lsof
....
+
Note that this will also return any matched files downloaded into the [.filename]#/usr/ports/distfiles# directory.
* Another way to find software is by using the Ports Collection's built-in search mechanism. To use the search feature, cd to [.filename]#/usr/ports# then run `make search name=program-name` where _program-name_ is the name of the software. For example, to search for `lsof`:
+
[source,shell]
....
# cd /usr/ports
# make search name=lsof
Port:   lsof-4.88.d,8
Path:   /usr/ports/sysutils/lsof
Info:   Lists information about open files (similar to fstat(1))
Maint:  ler@lerctr.org
Index:  sysutils
B-deps:
R-deps:
....
+
[TIP]
====
The built-in search mechanism uses a file of index information.
If a message indicates that the [.filename]#INDEX# is required, run `make fetchindex` to download the current index file.
With the [.filename]#INDEX# present, `make search` will be able to perform the requested search.
====
+
The "Path:" line indicates where to find the port.
+
To receive less information, use the `quicksearch` feature:
+
[source,shell]
....
# cd /usr/ports
# make quicksearch name=lsof
Port:   lsof-4.88.d,8
Path:   /usr/ports/sysutils/lsof
Info:   Lists information about open files (similar to fstat(1))
....
+
For more in-depth searching, use `make search key=_string_` or `make quicksearch key=_string_`, where _string_ is some text to search for.
The text can be in comments, descriptions, or dependencies in order to find ports which relate to a particular subject when the name of the program is unknown.
+
When using `search` or `quicksearch`, the search string is case-insensitive.
Searching for "LSOF" will yield the same results as searching for "lsof".

[[pkgng-intro]]
== Using pkg for Binary Package Management

pkg is the next generation replacement for the traditional FreeBSD package management tools, offering many features that make dealing with binary packages faster and easier.

For sites wishing to only use prebuilt binary packages from the FreeBSD mirrors, managing packages with pkg can be sufficient.

However, for those sites building from source or using their own repositories, a separate <<ports-upgrading-tools,port management tool>> will be needed.

Since pkg only works with binary packages, it is not a replacement for such tools.
Those tools can be used to install software from both binary packages and the Ports Collection, while pkg installs only binary packages.

[[pkgng-initial-setup]]
=== Getting Started with pkg

FreeBSD includes a bootstrap utility which can be used to download and install pkg and its manual pages.
This utility is designed to work with versions of FreeBSD starting with 10._X_.

[NOTE]
====
Not all FreeBSD versions and architectures support this bootstrap process.
The current list is at https://pkg.freebsd.org/[].
For other cases, pkg must instead be installed from the Ports Collection or as a binary package.
====

To bootstrap the system, run:

[source,shell]
....
# /usr/sbin/pkg
....

You must have a working Internet connection for the bootstrap process to succeed.

Otherwise, to install the port, run:

[source,shell]
....
# cd /usr/ports/ports-mgmt/pkg
# make
# make install clean
....

When upgrading an existing system that originally used the older pkg_* tools,
the database must be converted to the new format, so that the new tools are aware of the already installed packages.
Once pkg has been installed, the package database must be converted from the traditional format to the new format by running this command:

[source,shell]
....
# pkg2ng
....

[NOTE]
====
This step is not required for new installations that do not yet have any third-party software installed.
====

[IMPORTANT]
====
This step is not reversible.
Once the package database has been converted to the pkg format, the traditional `pkg_*` tools should no longer be used.
====

[NOTE]
====
The package database conversion may emit errors as the contents are converted to the new version.
Generally, these errors can be safely ignored.
However, a list of software that was not successfully converted is shown after `pkg2ng` finishes.
These applications must be manually reinstalled.
====

To ensure that the Ports Collection registers new software with pkg instead of the traditional packages database,
FreeBSD versions earlier than 10._X_ require this line in [.filename]#/etc/make.conf#:

[.programlisting]
....
WITH_PKGNG=   yes
....

By default, pkg uses the binary packages from the FreeBSD package mirrors (the _repository_).
For information about building a custom package repository, see <<ports-poudriere>>.

Additional pkg configuration options are described in man:pkg.conf[5].

Usage information for pkg is available in the man:pkg[8] manual page or by running `pkg` without additional arguments.

Each pkg command argument is documented in a command-specific manual page.
To read the manual page for `pkg install`, for example, run either of these commands:

[source,shell]
....
# pkg help install
....

[source,shell]
....
# man pkg-install
....

The rest of this section demonstrates common binary package management tasks which can be performed using pkg.
Each demonstrated command provides many switches to customize its use.
Refer to a command's help or man page for details and more examples.

[[quarterly-latest-branch]]
=== Quarterly and Latest Ports Branches

The `Quarterly` branch provides users with a more predictable and stable experience for port and package installation and upgrades.
This is done essentially by only allowing non-feature updates.
Quarterly branches aim to receive security fixes (that may be version updates, or backports of commits), bug fixes and ports compliance or framework changes.
The Quarterly branch is cut from HEAD at the beginning of every (yearly) quarter in January, April, July, and October.
Branches are named according to the year (YYYY) and quarter (Q1-4) they are created in.
For example, the quarterly branch created in January 2016, is named 2016Q1.
And the `Latest` branch provides the latest versions of the packages to the users.

To switch from quarterly to latest run the following commands:

[source,shell]
....
# mkdir -p /usr/local/etc/pkg/repos
# cp /etc/pkg/FreeBSD.conf /usr/local/etc/pkg/repos/FreeBSD.conf
....

Edit the file [.filename]#/usr/local/etc/pkg/repos/FreeBSD.conf# and change the string _quarterly_ to _latest_ in the `url:` line.

The result should be similar to the following:

[.programlisting]
....
FreeBSD: {
  url: "pkg+http://pkg.FreeBSD.org/${ABI}/latest",
  mirror_type: "srv",
  signature_type: "fingerprints",
  fingerprints: "/usr/share/keys/pkg",
  enabled: yes
}
....

And finally run this command to update from the new (latest) repository metadata.

[source,shell]
....
# pkg update -f
....

[[pkgng-pkg-info]]
=== Obtaining Information About Installed Packages

Information about the packages installed on a system can be viewed by running `pkg info` which, when run without any switches,
will list the package version for either all installed packages or the specified package.

For example, to see which version of pkg is installed, run:

[source,shell]
....
# pkg info pkg
pkg-1.1.4_1
....

[[pkgng-installing-deinstalling]]
=== Installing and Removing Packages

To install a binary package use the following command, where _packagename_ is the name of the package to install:

[source,shell]
....
# pkg install packagename
....

This command uses repository data to determine which version of the software to install and if it has any uninstalled dependencies.
For example, to install curl:

[source,shell]
....
# pkg install curl
Updating repository catalogue
/usr/local/tmp/All/curl-7.31.0_1.txz          100% of 1181 kB 1380 kBps 00m01s

/usr/local/tmp/All/ca_root_nss-3.15.1_1.txz   100% of  288 kB 1700 kBps 00m00s

Updating repository catalogue
The following 2 packages will be installed:

        Installing ca_root_nss: 3.15.1_1
        Installing curl: 7.31.0_1

The installation will require 3 MB more space

0 B to be downloaded

Proceed with installing packages [y/N]: y
Checking integrity... done
[1/2] Installing ca_root_nss-3.15.1_1... done
[2/2] Installing curl-7.31.0_1... done
Cleaning up cache files...Done
....

The new package and any additional packages that were installed as dependencies can be seen in the installed packages list:

[source,shell]
....
# pkg info
ca_root_nss-3.15.1_1	The root certificate bundle from the Mozilla Project
curl-7.31.0_1	Non-interactive tool to get files from FTP, GOPHER, HTTP(S) servers
pkg-1.1.4_6	New generation package manager
....

Packages that are no longer needed can be removed with `pkg delete`.
For example:

[source,shell]
....
# pkg delete curl
The following packages will be deleted:

	curl-7.31.0_1

The deletion will free 3 MB

Proceed with deleting packages [y/N]: y
[1/1] Deleting curl-7.31.0_1... done
....

[[pkgng-upgrading]]
=== Upgrading Installed Packages

Installed packages can be upgraded to their latest versions by running:

[source,shell]
....
# pkg upgrade
....

This command will compare the installed versions with those available in the repository catalogue and upgrade them from the repository.

[[pkgng-auditing]]
=== Auditing Installed Packages

Software vulnerabilities are regularly discovered in third-party applications.
To address this, pkg includes a built-in auditing mechanism.
To determine if there are any known vulnerabilities for the software installed on the system, run:

[source,shell]
....
# pkg audit -F
....

[[pkgng-autoremove]]
=== Automatically Removing Unused Packages

Removing a package may leave behind dependencies which are no longer required.
Unneeded packages that were installed as dependencies (leaf packages) can be automatically detected and removed using:

[source,shell]
....
# pkg autoremove
Packages to be autoremoved:
	ca_root_nss-3.15.1_1

The autoremoval will free 723 kB

Proceed with autoremoval of packages [y/N]: y
Deinstalling ca_root_nss-3.15.1_1... done
....

Packages installed as dependencies are called _automatic_ packages.
Non-automatic packages, i.e the packages that were explicity installed not as a dependency to another package, can be listed using:

[source,shell]
....
# pkg prime-list
nginx
openvpn
sudo
....

`pkg prime-list` is an alias command declared in [.filename]#/usr/local/etc/pkg.conf#.
There are many others that can be used to query the package database of the system.
For instance, command `pkg prime-origins` can be used to get the origin port directory of the list mentioned above:

[source,shell]
....
# pkg prime-origins
www/nginx
security/openvpn
security/sudo
....

This list can be used to rebuild all packages installed on a system using build tools such as package:ports-mgmt/poudriere[] or package:ports-mgmt/synth[].

Marking an installed package as automatic can be done using:

[source,shell]
....
# pkg set -A 1 devel/cmake
....

Once a package is a leaf package and is marked as automatic, it gets selected by `pkg autoremove`.

Marking an installed package as _not_ automatic can be done using:

[source,shell]
....
# pkg set -A 0 devel/cmake
....

[[pkgng-backup]]
=== Restoring the Package Database

Unlike the traditional package management system, pkg includes its own package database backup mechanism.
This functionality is enabled by default.

[TIP]
====
To disable the periodic script from backing up the package database, set `daily_backup_pkgdb_enable="NO"` in man:periodic.conf[5].
====

To restore the contents of a previous package database backup,
run the following command replacing _/path/to/pkg.sql_ with the location of the backup:

[source,shell]
....
# pkg backup -r /path/to/pkg.sql
....

[NOTE]
====
If restoring a backup taken by the periodic script, it must be decompressed prior to being restored.
====

To run a manual backup of the pkg database, run the following command,
replacing _/path/to/pkg.sql_ with a suitable file name and location:

[source,shell]
....
# pkg backup -d /path/to/pkg.sql
....

[[pkgng-clean]]
=== Removing Stale Packages

By default, pkg stores binary packages in a cache directory defined by `PKG_CACHEDIR` in man:pkg.conf[5].
Only copies of the latest installed packages are kept. Older versions of pkg kept all previous packages.
To remove these outdated binary packages, run:

[source,shell]
....
# pkg clean
....

The entire cache may be cleared by running:

[source,shell]
....
# pkg clean -a
....

[[pkgng-set]]
=== Modifying Package Metadata

Software within the FreeBSD Ports Collection can undergo major version number changes.
To address this, pkg has a built-in command to update package origins.
This can be useful, for example, if package:lang/php5[] is renamed to package:lang/php53[] so that package:lang/php5[] can now represent version `5.4`.

To change the package origin for the above example, run:

[source,shell]
....
# pkg set -o lang/php5:lang/php53
....

As another example, to update package:lang/ruby18[] to package:lang/ruby19[], run:

[source,shell]
....
# pkg set -o lang/ruby18:lang/ruby19
....

As a final example, to change the origin of the [.filename]#libglut# shared libraries from package:graphics/libglut[] to package:graphics/freeglut[], run:

[source,shell]
....
# pkg set -o graphics/libglut:graphics/freeglut
....

[NOTE]
====
When changing package origins, it is important to reinstall packages that are dependent on the package with the modified origin.
To force a reinstallation of dependent packages, run:

[source,shell]
....
# pkg install -Rf graphics/freeglut
....

====

[[ports-using]]
== Using the Ports Collection

The Ports Collection is a set of [.filename]##Makefile##s, patches, and description files.
Each set of these files is used to compile and install an individual application on FreeBSD, and is called a _port_.

By default, the Ports Collection itself is stored as a subdirectory of [.filename]#/usr/ports#.

[WARNING]
====
Before installing and using the Ports Collection, please be aware that it is generally ill-advised to use the Ports Collection in conjunction with the binary packages provided via pkg to install software.
pkg, by default, tracks quarterly branch-releases of the ports tree and not HEAD.
Dependencies could be different for a port in HEAD compared to its counterpart in a quarterly branch release and this could result in conflicts between dependencies installed by pkg and those from the Ports Collection.
If the Ports Collection and pkg must be used in conjunction, then be sure that your Ports Collection and pkg are on the same branch release of the ports tree.
====

The Ports Collection contains directories for software categories.
Inside each category are subdirectories for individual applications.
Each application subdirectory contains a set of files that tells FreeBSD how to compile and install that program, called a _ports skeleton_.
Each port skeleton includes these files and directories:

* [.filename]#Makefile#: contains statements that specify how the application should be compiled and where its components should be installed.
* [.filename]#distinfo#: contains the names and checksums of the files that must be downloaded to build the port.
* [.filename]#files/#: this directory contains any patches needed for the program to compile and install on FreeBSD. This directory may also contain other files used to build the port.
* [.filename]#pkg-descr#: provides a more detailed description of the program.
* [.filename]#pkg-plist#: a list of all the files that will be installed by the port. It also tells the ports system which files to remove upon deinstallation.

Some ports include [.filename]#pkg-message# or other files to handle special situations.
For more details on these files, and on ports in general, refer to the extref:{porters-handbook}[FreeBSD Porter's Handbook].

The port does not include the actual source code, also known as a [.filename]#distfile#.
The extract portion of building a port will automatically save the downloaded source to [.filename]#/usr/ports/distfiles#.

[[ports-using-installation-methods]]
=== Installing the Ports Collection

Before an application can be compiled using a port, the Ports Collection must first be installed.
If it was not installed during the installation of FreeBSD, use one of the following methods to install it:

[[ports-using-portsnap-method]]
[.procedure]
****
*Procedure: Portsnap Method*

The base system of FreeBSD includes Portsnap.
This is a fast and user-friendly tool for retrieving the Ports Collection and is the recommended choice for most users not running FreeBSD-CURRENT.
This utility connects to a FreeBSD site, verifies the secure key, and downloads a new copy of the Ports Collection.
The key is used to verify the integrity of all downloaded files.

Note that Portsnap updates are generated from a snapshot of the main
branch of the Ports Collection and cannot be configured to use a
different branch (for example, `quarterly`).
If it is necessary to use a different branch of the Ports Collection
(for instance as referenced earlier in conjunction with binary
packages), then the <<ports-using-git-method,Git method>> must be used.

. To download a compressed snapshot of the Ports Collection into [.filename]#/var/db/portsnap#:
+
[source,shell]
....
# portsnap fetch
....
+
. When running Portsnap for the first time, extract the snapshot into [.filename]#/usr/ports#:
+
[source,shell]
....
# portsnap extract
....
+
. After the first use of Portsnap has been completed as shown above, [.filename]#/usr/ports# can be updated as needed by running:
+
[source,shell]
....
# portsnap fetch
# portsnap update
....
+
When using `fetch`, the `extract` or the `update` operation may be run consecutively, like so:
+
[source,shell]
....
# portsnap fetch update
....
****

[[ports-using-git-method]]
[.procedure]
****
*Procedure: Git Method*

If more control over the ports tree is needed or if local changes need to be maintained, or if running FreeBSD-CURRENT,
Git can be used to obtain the Ports Collection.
Refer to extref:{committers-guide}[the Git Primer, git-primer] for a detailed description of Git.

. Git must be installed before it can be used to check out the ports tree. If a copy of the ports tree is already present, install Git like this:
+
[source,shell]
....
# cd /usr/ports/devel/git
# make install clean
....
+
If the ports tree is not available, or pkg is being used to manage packages, Git can be installed as a package:
+
[source,shell]
....
# pkg install git
....
+
. Check out a copy of the HEAD branch of the ports tree:
+
[source,shell]
....
# git clone https://git.FreeBSD.org/ports.git /usr/ports
....
+
. Or, check out a copy of a quarterly branch:
+
[source,shell]
....
# git clone https://git.FreeBSD.org/ports.git -b 2020Q3 /usr/ports
....
+
. As needed, update [.filename]#/usr/ports# after the initial Git checkout:
+
[source,shell]
....
# git -C /usr/ports pull
....
+
. As needed, switch [.filename]#/usr/ports# to a different quarterly branch:
+
[source,shell]
....
# git -C /usr/ports switch 2020Q4
....
****

=== Installing Ports

This section provides basic instructions on using the Ports Collection to install or remove software.
The detailed description of available `make` targets and environment variables is available in man:ports[7].

[WARNING]
====

Before compiling any port, be sure to update the Ports Collection as described in the previous section.
Since the installation of any third-party software can introduce security vulnerabilities, it is recommended to first check https://vuxml.freebsd.org/[] for known security issues related to the port.
Alternately, run `pkg audit -F` before installing a new port.
This command can be configured to automatically perform a security audit and an update of the vulnerability database during the daily security system check. For more information, refer to man:pkg-audit[8] and man:periodic[8].
====

Using the Ports Collection assumes a working Internet connection.
It also requires superuser privilege.

To compile and install the port, change to the directory of the port to be installed, then type `make install` at the prompt.
Messages will indicate the progress:

[source,shell]
....
# cd /usr/ports/sysutils/lsof
# make install
>> lsof_4.88D.freebsd.tar.gz doesn't seem to exist in /usr/ports/distfiles/.
>> Attempting to fetch from ftp://lsof.itap.purdue.edu/pub/tools/unix/lsof/.
===>  Extracting for lsof-4.88
...
[extraction output snipped]
...
>> Checksum OK for lsof_4.88D.freebsd.tar.gz.
===>  Patching for lsof-4.88.d,8
===>  Applying FreeBSD patches for lsof-4.88.d,8
===>  Configuring for lsof-4.88.d,8
...
[configure output snipped]
...
===>  Building for lsof-4.88.d,8
...
[compilation output snipped]
...

===>  Installing for lsof-4.88.d,8
...
[installation output snipped]
...
===>   Generating temporary packing list
===>   Compressing manual pages for lsof-4.88.d,8
===>   Registering installation for lsof-4.88.d,8
===>  SECURITY NOTE:
      This port has installed the following binaries which execute with
      increased privileges.
/usr/local/sbin/lsof
#
....

Since `lsof` is a program that runs with increased privileges, a security warning is displayed as it is installed.
Once the installation is complete, the prompt will be returned.

Some shells keep a cache of the commands that are available in the directories listed in the `PATH` environment variable, to speed up lookup operations for the executable file of these commands.
Users of the `tcsh` shell should type `rehash` so that a newly installed command can be used without specifying its full path.
Use `hash -r` instead for the `sh` shell.
Refer to the documentation for the shell for more information.

During installation, a working subdirectory is created which contains all the temporary files used during compilation.
Removing this directory saves disk space and minimizes the chance of problems later when upgrading to the newer version of the port:

[source,shell]
....
# make clean
===>  Cleaning for lsof-88.d,8
#
....

[NOTE]
====
To save this extra step, instead use `make install clean` when compiling the port.
====

==== Customizing Ports Installation

Some ports provide build options which can be used to enable or disable application components, provide security options, or allow for other customizations.
Examples include package:www/firefox[], package:security/gpgme[], and package:mail/sylpheed-claws[].
If the port depends upon other ports which have configurable options,
it may pause several times for user interaction as the default behavior is to prompt the user to select options from a menu.
To avoid this and do all of the configuration in one batch, run `make config-recursive` within the port skeleton.
Then, run `make install [clean]` to compile and install the port.

[TIP]
====
When using `config-recursive`, the list of ports to configure are gathered by the `all-depends-list` target.
It is recommended to run `make config-recursive` until all dependent ports options have been defined,
and ports options screens no longer appear, to be certain that all dependency options have been configured.
====

There are several ways to revisit a port's build options menu in order to add, remove, or change these options after a port has been built.
One method is to `cd` into the directory containing the port and type `make config`.
Another option is to use `make showconfig`.
Another option is to execute `make rmconfig` which will remove all selected options and allow you to start over.
All of these options, and others, are explained in great detail in man:ports[7].

The ports system uses man:fetch[1] to download the source files, which supports various environment variables.
The `FTP_PASSIVE_MODE`, `FTP_PROXY`, and `FTP_PASSWORD` variables may need to be set if the FreeBSD system is behind a firewall or FTP/HTTP proxy.
See man:fetch[3] for the complete list of supported variables.

For users who cannot be connected to the Internet all the time, `make fetch` can be run within [.filename]#/usr/ports#,
to fetch all distfiles, or within a category, such as [.filename]#/usr/ports/net#, or within the specific port skeleton.
Note that if a port has any dependencies, running this command in a category or ports skeleton will _not_ fetch the distfiles of ports from another category.
Instead, use `make fetch-recursive` to also fetch the distfiles for all the dependencies of a port.

In rare cases, such as when an organization has a local distfiles repository, the `MASTER_SITES` variable can be used to override the download locations specified in the [.filename]#Makefile#.
When using, specify the alternate location:

[source,shell]
....
# cd /usr/ports/directory
# make MASTER_SITE_OVERRIDE= \
ftp://ftp.organization.org/pub/FreeBSD/ports/distfiles/ fetch
....

The `WRKDIRPREFIX` and `PREFIX` variables can override the default working and target directories. For example:

[source,shell]
....
# make WRKDIRPREFIX=/usr/home/example/ports install
....

will compile the port in [.filename]#/usr/home/example/ports# and install everything under [.filename]#/usr/local#.

[source,shell]
....
# make PREFIX=/usr/home/example/local install
....

will compile the port in [.filename]#/usr/ports# and install it in [.filename]#/usr/home/example/local#. And:

[source,shell]
....
# make WRKDIRPREFIX=../ports PREFIX=../local install
....

will combine the two.

These can also be set as environmental variables.
Refer to the manual page for your shell for instructions on how to set an environmental variable.

[[ports-removing]]
=== Removing Installed Ports

Installed ports can be uninstalled using `pkg delete`.
Examples for using this command can be found in the man:pkg-delete[8] manual page.

Alternately, `make deinstall` can be run in the port's directory:

[source,shell]
....
# cd /usr/ports/sysutils/lsof
# make deinstall
===>  Deinstalling for sysutils/lsof
===>   Deinstalling
Deinstallation has been requested for the following 1 packages:

	lsof-4.88.d,8

The deinstallation will free 229 kB
[1/1] Deleting lsof-4.88.d,8... done
....

It is recommended to read the messages as the port is uninstalled.
If the port has any applications that depend upon it, this information will be displayed but the uninstallation will proceed.
In such cases, it may be better to reinstall the application in order to prevent broken dependencies.

[[ports-upgrading]]
=== Upgrading Ports

Over time, newer versions of software become available in the Ports Collection.
This section describes how to determine which software can be upgraded and how to perform the upgrade.

To determine if newer versions of installed ports are available, ensure that the latest version of the ports tree is installed,
using the updating command described in either <<ports-using-portsnap-method, “Portsnap Method”>> or <<ports-using-git-method, “Git Method”>>.
On FreeBSD 10 and later, or if the system has been converted to pkg, the following command will list the installed ports which are out of date:

[source,shell]
....
# pkg version -l "<"
....

For FreeBSD 9._X_ and lower, the following command will list the installed ports that are out of date:

[source,shell]
....
# pkg_version -l "<"
....

[IMPORTANT]
====
Before attempting an upgrade, read [.filename]#/usr/ports/UPDATING# from the top of the file to the date closest to the last time ports were upgraded or the system was installed.
This file describes various issues and additional steps users may encounter and need to perform when updating a port, including such things as file format changes, changes in locations of configuration files, or any incompatibilities with previous versions.
Make note of any instructions which match any of the ports that need upgrading and follow these instructions when performing the upgrade.
====

[[ports-upgrading-tools]]
==== Tools to Upgrade and Manage Ports

The Ports Collection contains several utilities to perform the actual upgrade.
Each has its strengths and weaknesses.

Historically, most installations used either Portmaster or Portupgrade.
Synth is a newer alternative.

[NOTE]
====
The choice of which tool is best for a particular system is up to the system administrator.
It is recommended practice to back up your data before using any of these tools.
====

[[portmaster]]
==== Upgrading Ports Using Portmaster

package:ports-mgmt/portmaster[] is a very small utility for upgrading installed ports.
It is designed to use the tools installed with the FreeBSD base system without depending on other ports or databases.
To install this utility as a port:

[source,shell]
....
# cd /usr/ports/ports-mgmt/portmaster
# make install clean
....

Portmaster defines four categories of ports:

* Root port: has no dependencies and is not a dependency of any other ports.
* Trunk port: has no dependencies, but other ports depend upon it.
* Branch port: has dependencies and other ports depend upon it.
* Leaf port: has dependencies but no other ports depend upon it.

To list these categories and search for updates:

[source,shell]
....
# portmaster -L
===>>> Root ports (No dependencies, not depended on)
===>>> ispell-3.2.06_18
===>>> screen-4.0.3
        ===>>> New version available: screen-4.0.3_1
===>>> tcpflow-0.21_1
===>>> 7 root ports
...
===>>> Branch ports (Have dependencies, are depended on)
===>>> apache22-2.2.3
        ===>>> New version available: apache22-2.2.8
...
===>>> Leaf ports (Have dependencies, not depended on)
===>>> automake-1.9.6_2
===>>> bash-3.1.17
        ===>>> New version available: bash-3.2.33
...
===>>> 32 leaf ports

===>>> 137 total installed ports
        ===>>> 83 have new versions available
....

This command is used to upgrade all outdated ports:

[source,shell]
....
# portmaster -a
....

[NOTE]
====
By default, Portmaster makes a backup package before deleting the existing port.
If the installation of the new version is successful, Portmaster deletes the backup.
Using `-b` instructs Portmaster not to automatically delete the backup.
Adding `-i` starts Portmaster in interactive mode, prompting for confirmation before upgrading each port.
Many other options are available.
Read through the manual page for man:portmaster[8] for details regarding their usage.
====

If errors are encountered during the upgrade process, add `-f` to upgrade and rebuild all ports:

[source,shell]
....
# portmaster -af
....

Portmaster can also be used to install new ports on the system, upgrading all dependencies before building and installing the new port.
To use this function, specify the location of the port in the Ports Collection:

[source,shell]
....
# portmaster shells/bash
....

More information about package:ports-mgmt/portmaster[] may be found in its [.filename]#pkg-descr#.

[[portupgrade]]
==== Upgrading Ports Using Portupgrade

package:ports-mgmt/portupgrade[] is another utility that can be used to upgrade ports.
It installs a suite of applications which can be used to manage ports.
However, it is dependent upon Ruby. To install the port:

[source,shell]
....
# cd /usr/ports/ports-mgmt/portupgrade
# make install clean
....

Before performing an upgrade using this utility, it is recommended to scan the list of installed ports using `pkgdb -F` and to fix all the inconsistencies it reports.

To upgrade all the outdated ports installed on the system, use `portupgrade -a`.
Alternately, include `-i` to be asked for confirmation of every individual upgrade:

[source,shell]
....
# portupgrade -ai
....

To upgrade only a specified application instead of all available ports, use `portupgrade _pkgname_`.
It is very important to include `-R` to first upgrade all the ports required by the given application:

[source,shell]
....
# portupgrade -R firefox
....

If `-P` is included, Portupgrade searches for available packages in the local directories listed in `PKG_PATH`.
If none are available locally, it then fetches packages from a remote site.
If packages can not be found locally or fetched remotely, Portupgrade will use ports.
To avoid using ports entirely, specify `-PP`.
This last set of options tells Portupgrade to abort if no packages are available:

[source,shell]
....
# portupgrade -PP gnome3
....

To just fetch the port distfiles, or packages, if `-P` is specified, without building or installing anything, use `-F`.
For further information on all of the available switches, refer to the manual page for `portupgrade`.

More information about package:ports-mgmt/portupgrade[] may be found in its [.filename]#pkg-descr#.

[[ports-disk-space]]
=== Ports and Disk Space

Using the Ports Collection will use up disk space over time.
After building and installing a port, running `make clean` within the ports skeleton will clean up the temporary [.filename]#work# directory.
If Portmaster is used to install a port, it will automatically remove this directory unless `-K` is specified.
If Portupgrade is installed, this command will remove all [.filename]#work# directories found within the local copy of the Ports Collection:

[source,shell]
....
# portsclean -C
....

In addition, outdated source distribution files accumulate in [.filename]#/usr/ports/distfiles# over time.
To use Portupgrade to delete all the distfiles that are no longer referenced by any ports:

[source,shell]
....
# portsclean -D
....

Portupgrade can remove all distfiles not referenced by any port currently installed on the system:

[source,shell]
....
# portsclean -DD
....

If Portmaster is installed, use:

[source,shell]
....
# portmaster --clean-distfiles
....

By default, this command is interactive and prompts the user to confirm if a distfile should be deleted.

In addition to these commands, package:ports-mgmt/pkg_cutleaves[] automates the task of removing installed ports that are no longer needed.

[[ports-poudriere]]
== Building Packages with Poudriere

Poudriere is a `BSD`-licensed utility for creating and testing FreeBSD packages.
It uses FreeBSD jails to set up isolated compilation environments.
These jails can be used to build packages for versions of FreeBSD that are different from the system on which it is installed, and also to build packages for i386 if the host is an amd64 system.
Once the packages are built, they are in a layout identical to the official mirrors.
These packages are usable by man:pkg[8] and other package management tools.

Poudriere is installed using the package:ports-mgmt/poudriere[] package or port.
The installation includes a sample configuration file [.filename]#/usr/local/etc/poudriere.conf.sample#.
Copy this file to [.filename]#/usr/local/etc/poudriere.conf#.
Edit the copied file to suit the local configuration.

While `ZFS` is not required on the system running poudriere, it is beneficial.
When `ZFS` is used, `ZPOOL` must be specified in [.filename]#/usr/local/etc/poudriere.conf# and `FREEBSD_HOST` should be set to a nearby mirror.
Defining `CCACHE_DIR` enables the use of package:devel/ccache[] to cache compilation and reduce build times for frequently-compiled code.
It may be convenient to put poudriere datasets in an isolated tree mounted at [.filename]#/poudriere#.
Defaults for the other configuration values are adequate.

The number of processor cores detected is used to define how many builds will run in parallel.
Supply enough virtual memory, either with `RAM` or swap space.
If virtual memory runs out, the compilation jails will stop and be torn down, resulting in weird error messages.

[[poudriere-initialization]]
=== Initialize Jails and Port Trees

After configuration, initialize poudriere so that it installs a jail with the required FreeBSD tree and a ports tree.
Specify a name for the jail using `-j` and the FreeBSD version with `-v`.
On systems running FreeBSD/amd64, the architecture can be set with `-a` to either `i386` or `amd64`.
The default is the architecture shown by `uname`.

[source,shell]
....
# poudriere jail -c -j 11amd64 -v 11.4-RELEASE
[00:00:00] Creating 11amd64 fs at /poudriere/jails/11amd64... done
[00:00:00] Using pre-distributed MANIFEST for FreeBSD 11.4-RELEASE amd64
[00:00:00] Fetching base for FreeBSD 11.4-RELEASE amd64
/poudriere/jails/11amd64/fromftp/base.txz              125 MB 4110 kBps    31s
[00:00:33] Extracting base... done
[00:00:54] Fetching src for FreeBSD 11.4-RELEASE amd64
/poudriere/jails/11amd64/fromftp/src.txz               154 MB 4178 kBps    38s
[00:01:33] Extracting src... done
[00:02:31] Fetching lib32 for FreeBSD 11.4-RELEASE amd64
/poudriere/jails/11amd64/fromftp/lib32.txz              24 MB 3969 kBps    06s
[00:02:38] Extracting lib32... done
[00:02:42] Cleaning up... done
[00:02:42] Recording filesystem state for clean... done
[00:02:42] Upgrading using ftp
/etc/resolv.conf -> /poudriere/jails/11amd64/etc/resolv.conf
Looking up update.FreeBSD.org mirrors... 3 mirrors found.
Fetching public key from update4.freebsd.org... done.
Fetching metadata signature for 11.4-RELEASE from update4.freebsd.org... done.
Fetching metadata index... done.
Fetching 2 metadata files... done.
Inspecting system... done.
Preparing to download files... done.
Fetching 124 patches.....10....20....30....40....50....60....70....80....90....100....110....120.. done.
Applying patches... done.
Fetching 6 files... done.
The following files will be added as part of updating to
11.4-RELEASE-p1:
/usr/src/contrib/unbound/.github
/usr/src/contrib/unbound/.github/FUNDING.yml
/usr/src/contrib/unbound/contrib/drop2rpz
/usr/src/contrib/unbound/contrib/unbound_portable.service.in
/usr/src/contrib/unbound/services/rpz.c
/usr/src/contrib/unbound/services/rpz.h
/usr/src/lib/libc/tests/gen/spawnp_enoexec.sh
The following files will be updated as part of updating to
11.4-RELEASE-p1:
[…]
Installing updates...Scanning //usr/share/certs/blacklisted for certificates...
Scanning //usr/share/certs/trusted for certificates...
 done.
11.4-RELEASE-p1
[00:04:06] Recording filesystem state for clean... done
[00:04:07] Jail 11amd64 11.4-RELEASE-p1 amd64 is ready to be used
....

[source,shell]
....
# poudriere ports -c -p local -m git+https
[00:00:00] Creating local fs at /poudriere/ports/local... done
[00:00:00] Checking out the ports tree... done
....

On a single computer, poudriere can build ports with multiple configurations, in multiple jails, and from different port trees.
Custom configurations for these combinations are called _sets_.
See the CUSTOMIZATION section of man:poudriere[8] for details after package:ports-mgmt/poudriere[] or package:ports-mgmt/poudriere-devel[] is installed.

The basic configuration shown here puts a single jail-, port-, and set-specific [.filename]#make.conf# in [.filename]#/usr/local/etc/poudriere.d#.
The filename in this example is created by combining the jail name, port name, and set name: [.filename]#11amd64-local-workstation-make.conf#.
The system [.filename]#make.conf# and this new file are combined at build time to create the [.filename]#make.conf# used by the build jail.

Packages to be built are entered in [.filename]#11amd64-local-workstation-pkglist#:

[.programlisting]
....
editors/emacs
devel/git
ports-mgmt/pkg
...
....

Options and dependencies for the specified ports are configured:

[source,shell]
....
# poudriere options -j 11amd64 -p local -z workstation -f 11amd64-local-workstation-pkglist
....

Finally, packages are built and a package repository is created:

[source,shell]
....
# poudriere bulk -j 11amd64 -p local -z workstation -f 11amd64-local-workstation-pkglist
....

While running, pressing kbd:[Ctrl+t] displays the current state of the build.
Poudriere also builds files in [.filename]#/poudriere/logs/bulk/jailname# that can be used with a web server to display build information.

After completion, the new packages are now available for installation from the poudriere repository.

For more information on using poudriere, see man:poudriere[8] and the main web site, https://github.com/freebsd/poudriere/wiki[].

=== Configuring pkg Clients to Use a Poudriere Repository

While it is possible to use both a custom repository along side of the official repository, sometimes it is useful to disable the official repository.
This is done by creating a configuration file that overrides and disables the official configuration file.
Create [.filename]#/usr/local/etc/pkg/repos/FreeBSD.conf# that contains the following:

[.programlisting]
....
FreeBSD: {
	enabled: no
}
....

Usually it is easiest to serve a poudriere repository to the client machines via HTTP.
Set up a webserver to serve up the package directory, for instance: [.filename]#/usr/local/poudriere/data/packages/11amd64#, where [.filename]#11amd64# is the name of the build.

If the URL to the package repository is: `http://pkg.example.com/11amd64`,
then the repository configuration file in [.filename]#/usr/local/etc/pkg/repos/custom.conf# would look like:

[.programlisting]
....
custom: {
	url: "http://pkg.example.com/11amd64",
	enabled: yes,
}
....

[[ports-nextsteps]]
== Post-Installation Considerations

Regardless of whether the software was installed from a binary package or port, most third-party applications require some level of configuration after installation.
The following commands and locations can be used to help determine what was installed with the application.

* Most applications install at least one default configuration file in [.filename]#/usr/local/etc#. In cases where an application has a large number of configuration files, a subdirectory will be created to hold them. Often, sample configuration files are installed which end with a suffix such as [.filename]#.sample#. The configuration files should be reviewed and possibly edited to meet the system's needs. To edit a sample file, first copy it without the [.filename]#.sample# extension.
* Applications which provide documentation will install it into [.filename]#/usr/local/share/doc# and many applications also install manual pages. This documentation should be consulted before continuing.
* Some applications run services which must be added to [.filename]#/etc/rc.conf# before starting the application. These applications usually install a startup script in [.filename]#/usr/local/etc/rc.d#. See crossref:config[configtuning-starting-services,Starting Services] for more information.
+
[NOTE]
====
By design, applications do not run their startup script upon installation, nor do they run their stop script upon deinstallation or upgrade.
This decision is left to the individual system administrator.
====

* Users of man:csh[1] should run `rehash` to rebuild the known binary list in the shells `PATH`.
* Use `pkg info` to determine which files, man pages, and binaries were installed with the application.

[[ports-broken]]
== Dealing with Broken Ports

When a port does not build or install, try the following:

. Search to see if there is a fix pending for the port in the link:https://www.FreeBSD.org/support/[Problem Report database]. If so, implementing the proposed fix may fix the issue.
. Ask the maintainer of the port for help. Type `make maintainer` in the ports skeleton or read the port's [.filename]#Makefile# to find the maintainer's email address. Remember to include the output leading up to the error in the email to the maintainer.
+
[NOTE]
====
Some ports are not maintained by an individual but instead by a group maintainer represented by a extref:{mailing-list-faq}[mailing list].
Many, but not all, of these addresses look like mailto:freebsd-listname@FreeBSD.org[freebsd-listname@FreeBSD.org].
Please take this into account when sending an email.

In particular, ports maintained by mailto:ports@FreeBSD.org[ports@FreeBSD.org] are not maintained by a specific individual.
Instead, any fixes and support come from the general community who subscribe to that mailing list. More volunteers are always needed!
====
+
If there is no response to the email, use Bugzilla to submit a bug report using the instructions in extref:{problem-reports}[Writing FreeBSD Problem Reports].
. Fix it! The extref:{porters-handbook}[Porter's Handbook] includes detailed information on the ports infrastructure so that you can fix the occasional broken port or even submit your own!
. Install the package instead of the port using the instructions in <<pkgng-intro>>.
