---
title: 3. Fejezet - A UNIX alapjai
part: I. Rész - Bevezetés
prev: books/handbook/install
next: books/handbook/ports
showBookMenu: true
weight: 5
path: "/books/handbook/basics/"
---

[[basics]]
= A UNIX alapjai
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 3
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/basics/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[basics-synopsis]]
== Áttekintés

Ez a fejezet a FreeBSD operációs rendszer alapvetõ funkcióit és parancsait mutatja be. Az itt tárgyalásra kerülõ anyag nagy része érvényes bármelyik más UNIX(R)-szerû operációs rendszer esetén is. Ezért, ha már ismerjük az említésre kerülõ ismereteket, minden további gond nélkül átugorhatjuk ezt a fejezetet. Azonban ha még teljesen ismeretlen számunkra a FreeBSD, minden bizonnyal ez lesz az, amit alaposan át kell majd olvasnunk.

A fejezet elolvasása során megismerjük:

* az ún. "virtuális konzolok" használatát FreeBSD alatt;
* hogyan mûködnek együtt a UNIX(R) állományokra vonatkozó engedélyei a FreeBSD saját kiegészítéseivel;
* egy FreeBSD állományrendszer alapértelmezett kialakítását;
* a FreeBSD lemezszervezését;
* hogyan csatlakoztassunk és válasszunk le állományrendszereket;
* mik azok a folyamatok, démonok és jelzések;
* mik azok a parancsértelmezõk, és miként tudjuk megváltoztatni az alapértelmezett bejelentkezési környezetünket;
* hogyan használjuk az alapvetõ szövegszerkesztõket;
* mik az eszközök és az eszközleírók;
* FreeBSD alatt milyen bináris formátumokat használhatunk;
* szükség esetén hogyan olvassuk el a megfelelõ man oldalakat.

[[consoles]]
== Virtuális konzolok és terminálok

A FreeBSD számos módon használható. Ezek közül az egyik az, ha parancsokat gépelünk be a szöveges terminálon. Így érhetõ el egyszerûen a UNIX(R) operációs rendszer rugalmasságának és erejének jelentõs része. Ebben a szakaszban megtudhatjuk, mik azok a "terminálok" és "konzolok" és miként tudjuk ezeket FreeBSD alatt használni.

[[consoles-intro]]
=== A konzol

Ha nem állítottuk volna be, hogy a FreeBSD indulása során automatikusan induljon el a grafikus felület is, akkor a rendszer egy bejelentkezõ képernyõt fog mutatni közvetlenül a rendszerindítás befejezõdése után. Ekkor valami ilyesmit kell majd látnunk:

[source,shell]
....
Additional ABI support:.
Local package initialization:.
Additional TCP options:.

Fri Sep 20 13:01:06 EEST 2002

FreeBSD/i386 (pc3.example.org) (ttyv0)

login:
....

Egyes rendszereken ugyan némileg eltérhetnek az üzenetek, de hasonlót kell látnunk. Minket most az utolsó két sor érdekel. Az utolsó elõtti sorban ez olvasható:

[.programlisting]
....
FreeBSD/i386 (pc3.example.org) (ttyv0)
....

Ez a sor arról értesít minket, hogy a rendszerünk éppen most indult el: egy "FreeBSD" konzolt látunk, amely egy Intel(R) x86 architektúrájú processzoron fut . A gépünk neve (mivel minden UNIX(R)-os gép rendelkezik egy névvel) `pc3.example.org`, és ennek a rendszerkonzolját látjuk most éppen - a [.filename]#ttyv0# terminált.

Végezetül az utolsó sor mindig:

[.programlisting]
....
login:
....

Ez az a rész, ahova a FreeBSD-be történõ bejelentkezéshez meg kell adnunk a "felhasználói nevünket" (user name). A következõ szakaszban errõl olvashatunk.

[[consoles-login]]
=== Bejelentkezés a FreeBSD-be

A FreeBSD egy többfelhasználós, többfeladatos rendszer. Így hívják hivatalosan azokat a rendszereket, amelyeket többen tudnak használni és egyetlen számítógépen egyszerre rengeteg programot képesek futtatni.

Minden többfelhasználós rendszernek valamilyen módon meg kell tudnia különböztetnie egy "felhasználóját" a többitõl. A FreeBSD-ben (és minden más UNIX(R)-szerû operációs rendszerben) ezt úgy érik el, hogy a programok futtatása elõtt minden felhasználónak "be kell jelentkeznie" a rendszerbe. Minden felhasználó rendelkezik egy egyedi névvel (ez a "felhasználói név") és ehhez egy titkos kulcssal (ez a "jelszó"). A FreeBSD a programok futtatásához ezt a kettõt fogja elkérni a felhasználótól.

Egybõl miután a FreeBSD elindult és befejezte a rendszerindításhoz használt szkriptjeinek lefuttatását , ez a kijelzés (vagy más néven "prompt") fog megjelenni és kér egy érvényes felhasználói nevet:

[source,shell]
....
login:
....

A példa kedvéért most tegyük fel, hogy a felhasználói nevünk `pgj`. Az iménti prompthoz írjuk be, hogy `pgj` és nyomjuk le az kbd:[Enter] billentyût. Ezt követõen meg kell jelennie egy másik promptnak is, amely egy "jelszót" (password) kér:

[source,shell]
....
login: pgj
Password:
....

Most pedig gépeljük be `pgj` jelszavát és nyomjunk utána egy kbd:[Enter] billentyût. Vigyázzunk, hogy a jelszót _nem látjuk_ a beírás során! Emiatt most ne aggódjunk. Ezzel kapcsolatban elegendõ csak annyit tudni, hogy mindez biztonsági megfontolásokból történik.

Amennyiben jól adtuk meg a jelszavunkat, sikeresen bejelentkezünk a FreeBSD rendszerébe és készen állunk az összes elérhetõ parancs kipróbálására.

Bejelentkezés után a MOTD (message of the day) vagy más néven "a nap üzenete" jelenik meg, amelyet a parancssor követ (egy `#`, `$` vagy `%` jel). Innen tudhatjuk meg, hogy sikerült bejelentkeznünk.

[[consoles-virtual]]
=== Több konzol használata

A UNIX(R) parancsokat egy konzolon is szépen ki tudjuk adni, de a FreeBSD egyszerre ugyebár több programot is tud futtatni. A parancsok megadásához viszont egyetlen konzol használata elég nagy pazarlás lenne, hiszen egy olyan operációs rendszer mint a FreeBSD, tucatnyi programot képes futtatni egy idõben. Ebben az esetben jelenthetnek számunkra segítséget a "virtuális konzolok".

A FreeBSD beállítható úgy, hogy sok-sok különféle virtuális konzolt ajánljon fel számunkra. A virtuális konzolok között a billentyûzeten a megfelelõ gombok lenyomásával tudunk váltani. Mindegyik konzolnak megvan a saját kimeneti csatornája, és a virtuális konzolok közti váltás folyamán a FreeBSD gondoskodik a billentyûzetrõl érkezõ bemenet, valamint a monitorra irányított kimenet megfelelõ kezelésérõl.

A konzolok közti váltásra a FreeBSD külön billentyûkombinációkat tart fenn . A FreeBSD-ben a különbözõ virtuális konzolok közti váltásra az kbd:[Alt+F1], kbd:[Alt+F2] billentyûket, az kbd:[Alt+F8] billentyûkombinációval bezárólag használhatjuk.

A konzolok közti váltogatás során a FreeBSD ügyel a képernyõ tartalmának elmentésére és visszaállítására. Ennek eredményeképpen "úgy látszik", mintha több "virtuális" képernyõn és billentyûzeten adnánk parancsokat a FreeBSD-nek.

[[consoles-ttys]]
=== Az [.filename]#/etc/ttys# állomány

A FreeBSD alapértelmezés szerint nyolc virtuális konzollal indul. Ez azonban nem egy elõre rögzített érték, hiszen könnyedén testreszabhatjuk úgy a telepített rendszerünket, hogy több vagy esetleg kevesebb virtuális konzollal induljon el. A virtuális konzolok száma és azok pontos beállítása az [.filename]#/etc/ttys# állományon keresztül adható meg.

A FreeBSD virtuális konzoljait tehát az [.filename]#/etc/ttys# állomány megfelelõ módosításával tudjuk behangolni. Itt minden egyes olyan sor, amely nem megjegyzés (vagyis azok a sorok, amelyek nem a `#` karakterrel kezdõdnek), tartalmazza az egyes terminálok vagy virtuális konzolok beállításait. Az állomány a FreeBSD telepítésében szereplõ, alapértelmezett változata kilenc virtuális konzol konfigurációját tartalmazza, amelyek közül nyolc aktív. Ezek a `ttyv` résszel kezdõdõ sorok:

[.programlisting]
....
# name  getty                           type    status          comments
#
ttyv0   "/usr/libexec/getty Pc"         cons25  on  secure
# Virtual terminals
ttyv1   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv2   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv3   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv4   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv5   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv6   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv7   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv8   "/usr/X11R6/bin/xdm -nodaemon"  xterm   off secure
....

Az állományban található oszlopok kimerítõ magyarázatát, illetve a virtuális konzolok beállításához használható kapcsolókat a man:ttys[5] man oldalon olvashatjuk.

[[consoles-singleuser]]
=== Az egyfelhasználós mód konzolja

Az "egyfelhasználós mód" részletes leírása a crossref:boot[boot-singleuser,Egyfelhasználós mód]ban található. Fontos tudni, hogy amikor a FreeBSD-t egyfelhasználós módban futtatjuk, csupán egyetlen konzolunk van, és a virtuális konzolok nem érhetõek el. Egyébként az egyfelhasználós mód erre vonatkozó beállításai is megtalálhatóak az [.filename]#/etc/ttys# állományban. Ehhez keressük meg a `console` kezdetû sort:

[.programlisting]
....
# name  getty                           type    status          comments
#
# Ha a konzolt "insecure" (nem biztonságos) típusúnak választjuk meg,
# akkor a használatához az egyfelhasználós mód aktivilásá elõtt a rendszer
# kérni fogja a rendszeradminisztrátori jelszót.
console none                            unknown off secure
....

[NOTE]
====
A `console` felett látható megjegyzés jelzi, hogy át tudjuk írni ebben a sorban a `secure` (biztonságos) értékû paramétert `insecure` (nem biztonságos) értékûre. Ilyenkor, hogy ha a FreeBSD egyfelhasználós módban indul, kérni fogja a `root` felhasználó (a rendszeradminisztrátor) jelszavát.

__Vigyázzunk, amikor ezt az értéket ``insecure``-ra állítjuk!__ Ha ugyanis véletlenül elfeledkeznénk a `root` jelszaváról, akkor azzal az egyfelhasználós mód használata is veszélybe kerülhet. Habár ettõl függetlenül is lehetséges, azokra számára mégis nehéz helyzetnek bizonyulhat, akik nem mozognak elég otthonosan a FreeBSD rendszerindítási folyamatának és a hozzákapcsolódó programok ismeretében.
====

[[consoles-vidcontrol]]
=== A videomód váltása konzolban

A FreeBSD konzol alapértelmezett videomódja átállítható 1024x768-ra, 1280x1024-re, vagy bármilyen olyan más méretre, amit a videokártyánk és monitorunk képes megjeleníteni. Az eltérõ videomódok használatához elõször újra kell fordítanunk a rendszermagunkat az alábbi két beállítás hozzáadásával:

[.programlisting]
....
options VESA
options SC_PIXEL_MODE
....

Miután a rendszermagot sikeresen újrafordítottuk a fenti beállításokkal, a man:vidcontrol[1] segédprogrammal tudjuk megállapítani, hogy a hardverünk milyen videomódokat enged használni. Az összes támogatott videomódot a következõképpen tudjuk lekérdezni:

[source,shell]
....
# vidcontrol -i mode
....

A parancs eredményeképpen tehát megkapjuk a hardverünk által ismert videomódokat. Ezek közül tudjuk kiválasztani valamelyikõjüket és `root` felhasználóként a man:vidcontrol[1] segítségével beállítani:

[source,shell]
....
# vidcontrol MODE_279
....

Ha az új videomód megfelel számunkra, akkor ezt a beállítást az [.filename]#/etc/rc.conf# állományon keresztül véglegesíthetjük is:

[.programlisting]
....
allscreens_flags="MODE_279"
....

[[permissions]]
== Engedélyek

A FreeBSD, mivel a BSD UNIX(R) egyik közvetlen leszármazottja, számos UNIX(R)-os alapötletre épül. Ezek közül az elsõ és talán a leginkább kihangsúlyozott, hogy a FreeBSD egy többfelhasználós operációs rendszer. Egy olyan rendszer, amely egyszerre több, egymástól független feladattal foglalkozó felhasználót képes kiszolgálni. A rendszer felelõs a hardveres eszközök, a különféle perifériák, a memória és a processzor idejének minden egyes felhasználó számára szabályos és pártatlan megosztásáért és a feléjük irányuló kérések szervezéséért.

Mivel a rendszer több felhasználót is képes támogatni, az általa kezelt erõforrások rendelkeznek engedélyek egy adott halmazával, amelyek eldöntik, ki tudja ezeket olvasni, írni és végrehajtani. Az engedélyek háromszor három bit formájában jelennek meg, amelyek közül az elsõ bitcsoport az állomány tulajdonosára, a második az állomány csoportjára, végül az utolsó pedig a mindenki másra vonatkozó engedélyeket tárolja.

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Érték
| Engedély
| Könyvtárlistában

|0
|Nem olvasható, nem írható, nem hajtható végre
|`---`

|1
|Nem olvasható, nem írható, végrehajtható
|`--x`

|2
|Nem olvasható, írható, nem hajtható végre
|`-w-`

|3
|Nem olvasható, írható, végrehajtható
|`-wx`

|4
|Olvasható, nem írható, nem hajtható végre
|`r--`

|5
|Olvasható, nem írható, végrehajtható
|`r-x`

|6
|Olvasható, írható, nem hajtható végre
|`rw-`

|7
|Olvasható, írható, végrehajtható
|`rwx`
|===

A man:ls[1] `-l` kapcsolójának segítségével megnézhetjük a könyvtárak tartalmának részletes listáját, amiben megjelennek az állományok tulajdonosaira, csoportjára és a mindenki másra vonatkozó engedélyek is. Például ezt láthatjuk, ha kiadjuk az `ls -l` parancsot egy tetszõleges könyvtárban:

[source,shell]
....
% ls -l
total 530
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 egyik
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 masik
-rw-r--r--  1 root  wheel    7680 Sep  5 12:31 e-mail.txt
...
....

A példabeli `ls -l` parancs kimenetének elsõ oszlopa így bomlik fel:

[source,shell]
....
-rw-r--r--
....

Az elsõ (bal szélsõ) karakter mondja meg, hogy ez egy hagyományos állomány, könyvtár, speciális karakteres eszköz, socket vagy bármilyen más különleges pszeudoállomány. Ebben az esetben a `-` jelzi, hogy egy hagyományos állományról van szó. A következõ három karakter, ami ebben a példában az `rw-`, adja meg az állomány tulajdonosának engedélyeit. Az ezután következõ három karakter, az `r--` mutatja az állomány csoportjának engedélyeit. Az utolsó három karakter, vagyis itt az `r--` adja meg a többiek engedélyeit. A kötõjel arra utal, hogy az adott engedélyû tevékenység nem engedélyezett. Tehát ennél az állománynál az engedélyek a következõek: a tulajdonosa tudja olvasni és írni, a csoportja csak olvasni tudja, ugyanígy bárki más. A fenti táblázatnak megfelelõen az állomány engedélyének kódja `644` lesz, ahol az egyes számjegyek jelentik az állomány engedélyeinek három elemét.

Ez mind szép és jó, de vajon a rendszer milyen módon kezeli az állományok engedélyeit? A FreeBSD a legtöbb hardveres eszközt állománynak tekinti, amelyeket a programok meg tudnak nyitni, tudnak róluk olvasni és adatokat tudnak kiírni rájuk pontosan úgy, mint bármilyen más állomány esetén. Ezeket a speciális állományokat a [.filename]#/dev# könyvtárban találjuk.

A könyvtárakat is állományokként kezeli, ezért azok is rendelkeznek olvasási, írási és végrehajtási engedélyekkel. Azonban a könyvtárak végrehajtását engedélyezõ bit némileg más jelentéssel bír, mint az állományok esetén. Amikor ugyanis egy könyvtárat végrehajthatónak jelölünk meg, az arra fog utalni, hogy bele tudunk lépni, vagyis hogy ki tudjuk rá adni a "könyvtárváltás" (cd, change directory) parancsát. Ez továbbá arra is utal, hogy az ismert nevû állományokhoz hozzá tudunk férni (természetesen az egyes állományok engedélyeinek megfelelõen).

A könyvtárak tartalmát ennek megfelelõen viszont csak úgy láthatjuk, ha olvasási engedéllyel rendelkezünk a könyvtárra, míg egy általunk ismert állomány törléséhez a tartalmazó könyvtárhoz kell írási _és_ végrehajtási engedélyekkel rendelkeznünk.

Ezeken kívül még léteznek további engedélyek is, de ezeket csak olyan különleges esetekben használják, mint például a felhasználóváltó programok (setuid program) vagy a ragadós könyvtárak (sticky directory) létrehozása. Az állományok engedélyeinek behatóbb megismeréséhez és beállításához mindenképpen nézzük át a man:chmod[1] man oldalt.

=== Szimbolikus engedélyek

A szimbolikus engedélyek (gyakran csak szimbolikus kifejezések) az állományok és könyvtárak engedélyeinek megadása során a számok helyett karaktereket használnak. A szimbolikus kifejezések (ki) (hogyan) (milyen engedélyt) alakúak, ahol az alábbi értékek adhatóak meg:

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Elem
| Betû
| Jelentése

|(ki)
|u
|tulajdonos

|(ki)
|g
|csoport tulajdonos

|(ki)
|o
|egyéb

|(ki)
|a
|mindenki (a "világ")

|(hogyan)
|+
|engedély megadása

|(hogyan)
|-
|engedély visszavonása

|(hogyan)
|=
|engedély explicit beállítása

|(milyen engedély)
|r
|olvasás

|(milyen engedély)
|w
|írás

|(milyen engedély)
|x
|végrehajtás

|(milyen engedély)
|t
|ragadós (sticky bit)

|(milyen engedély)
|s
|UID vagy GID állítása
|===

Ezek az értékek a man:chmod[1] paranccsal az eddigiekhez hasonló módon használhatóak, csak itt betûket kell megadnunk. Például az alábbi paranccsal akadályozhatjuk meg, hogy a tulajdonosán kívül bárki hozzáférhessen az _ÁLLOMÁNY_ nevû állományhoz:

[source,shell]
....
% chmod go= ÁLLOMÁNY
....

Amennyiben egy állománnyal kapcsolatban több változtatást is el kívánunk végezni, össze tudjuk ezeket fûzni egy vesszõkkel elhatárolt felsorolásban:

[source,shell]
....
% chmod go-w,a+x ÁLLOMÁNY
....

=== A FreeBSD állományjelzõi

A korábban tárgyalt engedélyek mellett még a FreeBSD ismeri az ún. "állományjelzõk" (file flags) beállítását is. Ezek a jelzõbitek egy további biztonsági és irányítási szintet nyújtanak az állományok felett, viszont a könyvtárakra nem vonatkoznak.

Ezek az állományjelzõk az állományok felett további vezérlést adnak a kezünkbe, aminek révén gondoskodhatunk róla, hogy akár még a `root` felhasználó (a rendszer adminisztrátora) se legyen képes állományokat eltávolítani vagy módosítani.

Az állományjelzõk értékei egy egyszerû felületen keresztül, a man:chflags[1] segédprogrammal változtathatóak meg. Például a következõ paranccsal állíthatjuk a rendszer törölhetetlen (undeletable) jelzését az [.filename]#allomany1# állományon:

[source,shell]
....
# chflags sunlink allomany1
....

A törölhetetlen jelzés eltávolításához egyszerûen csak írjuk be az elõzõ parancsot úgy, hogy a "sunlink" paraméter elejére még beszúrunk egy "no" szövegrészt. Így:

[source,shell]
....
# chflags nosunlink allomany1
....

Az állományokra éppen érvényes jelzéseket az man:ls[1] parancs `-lo` kapcsolójának segítségével jeleníthetjük meg:

[source,shell]
....
# ls -lo file1
....

Ennek megfelelõen az eredménynek valahogy így kellene kinéznie:

[.programlisting]
....
-rw-r--r--  1 trhodes  trhodes  sunlnk 0 Mar  1 05:54 allomany1
....

Sok jelzés csak a `root` felhasználón keresztül vehetõ fel vagy távolítható el. Más esetekben viszont az állomány tulajdonosa állíthatja ezeket. A rendszergazdáknak javasoljuk, hogy ezzel kapcsolatban a man:chflags[1] és man:chflags[2] man oldalakat tanulmányozzák át.

=== A setuid, setgid és sticky engedélyek

A korábban említett engedélyeken kívül létezik még további három, amelyekkel minden rendszergazdának illik tisztában lennie. Ezek név szerint a `setuid`, `setgid` és `sticky` típusú engedélyek.

Ezek a beállítások bizonyos UNIX(R) mûveletek esetén nagyon fontosak, mivel az átlagos felhasználók számára általában el nem érhetõ funkciók használatát támogatják. A megértésükhöz elsõként a felhasználók valódi és effektív azonosítója közti különbségeket kell tisztáznunk.

A valódi azonosító tulajdonképpen az a felhasználói azonosító, amellyel a programot indítjuk el vagy futás elõtt birtokoljuk. A program futása közben azonban az effektív felhasználói azonosítóval fut. Például a man:passwd[1] segédprogram a jelszavát megváltoztatni kívánó felhasználó valódi azonosítójával indul, miközben a jelszavakat tároló adatbázis elérésékor már a `root` felhasználó effektív azonosítójával fut. Ezáltal a privilégiumokkal nem rendelkezõ felhasználók is meg tudják anélkül változtatni a jelszavaikat, hogy a `Permission Denied` hibaüzenettel találkoznának.

[NOTE]
====
A man:mount[8] `nosuid` beállításával azonban az ilyen típusú binárisok minden különösebb jel nélkül csõdöt fognak mondani. Mellesleg a man:mount[8] man oldala szerint ez az opció nem is teljesen megbízható, mivel `nosuid` wrapperek segítségével meg lehet kerülni.
====

Ahogy azt az alábbi példa is szemlélteti, a setuid engedélyt a többi elé egy négyes (4) beszúrásával tudjuk beállítani:

[source,shell]
....
# chmod 4755 suidexample.sh
....

A [.filename]#suidexample.sh# állomány engedélyei ezt követõen már így fognak megjelenni:

[source,shell]
....
-rwsr-xr-x   1 trhodes  trhodes    63 Aug 29 06:36 suidexample.sh
....

Most már jól látható, hogy az állomány tulajdonosához tartozó engedélyek között a végrehajthatóságot szabályozó bit lecserélõdött egy `s` bitre. Ennek köszönhetõen a `passwd` parancshoz hasonló módon kibõvített engedélyekkel leszünk képesek futtatni programokat.

Két terminál megnyitásával mindezt valós idõben is megvizsgálhatjuk. Az egyiken indítsuk el normál felhasználóként a `passwd` programot. Miközben a program várakozik az új jelszó megadására, a másik terminálon kérdezzük le a programhoz tartozó felhasználói információkat.

Tehát az egyik terminálon a következõt látjuk:

[source,shell]
....
% passwd
Changing local password for trhodes
Old Password:
....

Eközben pedig a másikon:

[source,shell]
....
# ps aux | grep passwd
trhodes  5232  0.0  0.2  3420  1608   0  R+    2:10AM   0:00.00 grep passwd
root     5211  0.0  0.2  3620  1724   2  I+    2:09AM   0:00.01 passwd
....

A `passwd` parancsot egyszerû felhasználóként adtunk ki, azonban jól látható, hogy valójában a `root` felhasználó azonosítójával fut.

A `setgid` a `setuid` engedélyhez hasonlóan mûködik, egyedül annyiban tér el, hogy a csoportra vonatkozó beállításokat módosítja. Amikor egy alkalmazást vagy segédprogramot ilyen engedéllyel futtatunk, akkor az adott programot birtokló csoport engedélyeit kapjuk meg.

Úgy tudjuk állományokon beállítani a `setgid` típusú engedélyt, ha az iménti példához hasonlóan a `chmod` parancs hívásakor még egy kettest (2) írunk az engedélyek elé:

[source,shell]
....
# chmod 2755 sgidexample.sh
....

Az így beállított engedélyek az elõbbihöz hasonló módon szemlélhetõek meg, azonban ebben az esetben a csoporthoz tartozó engedélyeknél jelenik meg az `s` bit:

[source,shell]
....
-rwxr-sr-x   1 trhodes  trhodes    44 Aug 31 01:49 sgidexample.sh
....

[NOTE]
====
Az elõbb tárgyalt példákkal kapcsolatban fontos megemlítenünk, hogy habár a szkriptek is végrehajtható állományok, nem fognak a valóditól eltérõ effektív felhasználói azonosítóval futni. Ennek oka abban keresendõ, hogy a parancssori szkriptek nem hívhatják a man:setuid[2] rendszerhívást.
====

Ez a két speciális engedély (a `setuid` és a `setgid`) a programhoz tartozó engedélyek kiterjesztésével csökkentheti rendszerünk biztonságát. Ezzel szemben viszont a harmadik bemutatandó speciális engedély rendszerünk védelmének erõsítésére szolgál: ez az ún. `sticky` bit.

Ha a `sticky` típusú engedélyt könyvtárra adjuk meg, akkor a benne levõ állományok törlését kizárólag azok tulajdonosainak engedi. Ezzel az engedéllyel lényegében a [.filename]#/tmp# könyvtárhoz hasonló nyilvános, bárki által elérhetõ könyvtárakban akadályozhatjuk meg az állományok idegen felhasználók általi törlését. Az engedély beállításához egy egyest (1) kell a többi elé fûznünk, mint például:

[source,shell]
....
# chmod 1777 /tmp
....

Most már az `ls` parancs segítségével láthatjuk ennek a hatását:

[source,shell]
....
# ls -al / | grep tmp
drwxrwxrwt  10 root  wheel          512 Aug 31 01:49 tmp
....

A `sticky` bit a beállítások végén felbukkanó `t` révén azonosítható be.

[[dirstructure]]
== A könyvtárak elrendezése

A FreeBSD könyvtárszerkezetének ismerete alapvetõ jelentõségû a rendszer egészének megértése szempontjából. Ezen belül is a legfontosabb a gyökérkönyvtár, a "/". Ez az elsõ könyvtár, amelyet a rendszer a rendszerindítás során csatlakoztat és a többfelhasználós mód elõkészítéséhez elegendhetlenül szükséges alaprendszert tartalmazza. A gyökérkönyvtár emellett csatlakozási pontokat szolgáltat a többfelhasználós mûködésre váltás során csatlakoztatandó további állományrendszerek számára.

A csatlakozási pont egy olyan könyvtár, ahová a szülõ állományrendszeren (ami gyakran maga a gyökér-állományrendszer) belül további állományrendszereket tudunk beoltani. Errõl bõvebben a <<disk-organization>>ban olvashatunk. A szabványos csatlakozási pontok: [.filename]#/usr#, [.filename]#/var#, [.filename]#/tmp#, [.filename]#/mnt# és [.filename]#/cdrom#. Ezekre a könyvtárakra általában az [.filename]#/etc/fstab# állományban találunk hivatkozásokat. Az [.filename]#/etc/fstab# állomány a rendszer számára a különbözõ állományrendszerek és a hozzájuk tartozó csatlakozási pontok táblázatát tartalmazza. Az [.filename]#/etc/fstab# állományban szereplõ legtöbb állományrendszer a rendszerindítás során automatikusan csatlakoztatásra kerül az man:rc[8] szkriptbõl, hacsak nem tartalmazzák a `noauto` beállítást. Ennek részleteit a <<disks-fstab>>ban találhatjuk meg.

Az állományrendszerek hierarchiájának teljes leírását a man:hier[7] man oldalon olvashatjuk. Mi egyelõre most megelégszünk a leggyakrabban megjelenõ könyvtárak rövid áttekintésével.

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Könyvtár
| Mi található itt

|[.filename]#/#
|Az állományrendszer gyökere.

|[.filename]#/bin/#
|Az egy- és többfelhasználós környezetekben is egyaránt alapvetõ felhasználói segédprogramok.

|[.filename]#/boot/#
|Az operációs rendszer indítása során használt programok és konfigurációs állományok.

|[.filename]#/boot/defaults/#
|A rendszerindítás alapértelmezett konfigurációs állományai. Lásd man:loader.conf[5]

|[.filename]#/dev/#
|Eszközleírók, lásd man:intro[4].

|[.filename]#/etc/#
|Rendszerkonfigurációs állományok és szkriptek.

|[.filename]#/etc/defaults/#
|Az alapértelmezett rendszerkonfigurációs állományok, lásd man:rc[8].

|[.filename]#/etc/mail/#
|A man:sendmail[8] programhoz hasonló levélküldõ rendszerek konfigurációs állományai.

|[.filename]#/etc/namedb/#
|A `named` program konfigurációs állományai, lásd man:named[8].

|[.filename]#/etc/periodic/#
|A man:cron[8] által naponta, hetente és havonta lefuttatandó szkriptek, lásd man:periodic[8].

|[.filename]#/etc/ppp/#
|A `ppp` program konfigurációs állományai, lásd man:ppp[8].

|[.filename]#/mnt/#
|Egy üres könyvtár, amelyet a rendszergazdák általában ideiglenes csatlakozási pontként használnak.

|[.filename]#/proc/#
|A futó programokat tartalmazó állományrendszer, lásd man:procfs[5], illetve man:mount_procfs[8].

|[.filename]#/rescue/#
|Statikusan linkelt programok vészhelyzet esetére, lásd man:rescue[8].

|[.filename]#/root/#
|A `root` felhasználó könyvtára.

|[.filename]#/sbin/#
|Az egy- és többfelhasználós környezetekben fontos rendszerprogramok és rendszerfelügyeleti eszközök.

|[.filename]#/tmp/#
|Átmeneti állományok. A [.filename]#/tmp# könyvtár tartalma általában NEM marad meg az újraindítás után. Erre a célra gyakran memóriában létrehozott állományrendszert szoktak csatlakoztatni a [.filename]#/tmp# könyvtárba. Ez utóbbit az man:rc.conf[5] tmpmfs-re vonatkozó változóinak beállításával lehet automatikussá tenni (vagy a [.filename]#/etc/fstab# megfelelõ módosításával, lásd man:mdmfs[8]).

|[.filename]#/usr/#
|A felhasználói programok és alkalmazások többsége.

|[.filename]#/usr/bin/#
|Általános segédprogramok, programozási eszközök és alkalmazások.

|[.filename]#/usr/include/#
|Szabványos C include-állományok.

|[.filename]#/usr/lib/#
|Függvénykönyvtárak.

|[.filename]#/usr/libdata/#
|Egyéb hasznos adatállományok.

|[.filename]#/usr/libexec/#
|(Más programok által használt) Rendszerdémonok és rendszereszközök.

|[.filename]#/usr/local/#
|A helyi rendszeren telepített programok, függvénykönyvtárak stb. A FreeBSD portrendszere is ezt használja alapértelmezés szerint. A [.filename]#/usr/local# könyvtáron belül a man:hier[7] man oldalon található [.filename]#/usr# könyvtár általános felépítése használatos. Ez alól kivételt képez a man alkönyvtár, amely közvetlenül a [.filename]#/usr/local# alatt található, nem pedig a [.filename]#/usr/local/share# könyvtáron belül, valamint a portok dokumentációja a [.filename]#share/doc/port# könyvtárban található.

|[.filename]#/usr/obj/#
|A [.filename]#/usr/src# könyvtárfában található források fordítása során keletkezõ architektúrafüggõ objektumok.

|[.filename]#/usr/ports/#
|A FreeBSD Portgyûjtemény (választható).

|[.filename]#/usr/sbin/#
|(A felhasználók által használt) Rendszerdémonok és rendszereszközök.

|[.filename]#/usr/shared/#
|Architektúrafüggõ állományok.

|[.filename]#/usr/src/#
|BSD és/vagy helyi források.

|[.filename]#/usr/X11R6/#
|Az X11R6 rendszer programjai, függvénykönyvtárai stb. (választható)

|[.filename]#/var/#
|Különféle napló, átmeneti, ideiglenes és pufferben tárolt állományok. A memóriában létrehozott állományrendszereket is olykor a [.filename]#/var# könyvtárban találjuk. Ezt az man:rc.conf[5] állományban található varmfs-változók beállításával tehetjük automatikussá (vagy a [.filename]#/etc/fstab# megfelelõ módosításával, lásd man:mdmfs[8]).

|[.filename]#/var/log/#
|Mindenféle rendszernaplók.

|[.filename]#/var/mail/#
|A felhasználók postafiókjait tároló állományok.

|[.filename]#/var/spool/#
|A nyomtatók és a levelezés puffereléséhez használt könyvtárak.

|[.filename]#/var/tmp/#
|Átmeneti állományok. Az itt található állományok általában megmaradnak a következõ rendszerindítás alkalmával is, hacsak a [.filename]#/var# nem egy memóriában létezõ állományrendszer.

|[.filename]#/var/yp#
|A NIS állományai.
|===

[[disk-organization]]
== A lemezek szervezése

Az állománynév a legkisebb szervezési egység, amin keresztül a FreeBSD képes megtalálni az állományokat. Az állományok neveiben a kis- és nagybetût megkülönböztetjük, tehát a [.filename]#readme.txt# és a [.filename]#README.TXT# elnevezés két különbözõ állományra utal. A FreeBSD nem az állományok kiterjesztése (ami a konkrét példánkban a [.filename]#.txt# volt) alapján dönti el, hogy az adott állomány vajon program, dokumentum vagy valamilyen más fajtájú adat.

Az állományok könyvtárakban tárolódnak. Egy könyvtár lehet akár üres (nincs benne egyetlen állomány sem), vagy többszáz állományt is tartalmazhat. Egy könyvtár ráadásul további könyvtárakat is tárolhat, és így az egymásban elhelyezkedõ könyvtárak segítségével könyvtárak egy hierarchiáját tudjuk felépíteni. Ezzel sokkalta könnyebben szervezhetõvé válnak az adataink.

Az állományokat és könyvtárakat úgy tudjuk elérni, ha megadjuk az állomány vagy a könyvtárt tároló könyvtár nevét, amit egy perjel, a `/` követ, valamint így összefûzve az eléréshez szükséges további könyvtárak felsorolása. Tehát, ha van egy [.filename]#ize# nevû könyvtárunk, amelyben található egy [.filename]#mize# könyvtár, amelyen belül pedig egy [.filename]#readme.txt#, akkor ennek az állománynak a teljes neve, vagy másképpen szólva az _elérési útja_ [.filename]#ize/mize/readme.txt# lesz.

A könyvtárak és az állományok egy állományrendszerben tárolódnak. Minden állományrendszer pontosan egy könyvtárat tartalmaz a legfelsõ szintjén, amelyet az adott állományrendszer _gyökérkönyvtárának_ nevezünk. Ez a gyökérkönyvtár tartalmazhat aztán további könyvtárakat.

Eddig még valószínûleg minden nagyon hasonló a más operációs rendszerekben tapasztalható fogalmakhoz. Azonban adónak különbségek: például az MS-DOS(R) a `\` jellel választja el az állományok és könyvtárak neveit, miközben a Mac OS(R) erre a `:` jelet használja.

A FreeBSD az elérési utakban sem betûkkel, sem pedig semmilyen más névvel nem jelöli meg a meghajtókat. Tehát a FreeBSD-ben nem írhatjuk, hogy a [.filename]#c:/ize/mize/readme.txt#.

Helyette az egyik állományrendszert kijelölik _gyökér-állományrendszernek_. A gyökér-állományrendszer gyökérkönyvtárára hivatkoznak késõbb `/` könyvtárként. Ezután minden más állományrendszert a gyökér-állományrendszerhez _csatlakoztatunk_. Ennek értelmében nem számít, hogy mennyi lemezünk is van a FreeBSD rendszerünkben, hiszen minden könyvtár egyazon lemez részeként jelenik meg.

Tegyük fel, hogy van három állományrendszerünk, hívjuk ezeket `A`-nak, `B`-nek és `C`-nek. Minden állományrendszer rendelkezik egy gyökérkönyvtárral, amely két további könyvtárat tartalmaz: `A1`-et és `A2`-t (és ennek megfelelõen a többi `B1`-et és `B2`-t, valamint `C1` és `C2`-t).

Nevezzük `A`-t a gyökér-állományrendszernek. Ha a könyvtár tartalmának megjelenítéséhez most kiadnánk az `ls` parancsot, két alkönyvtárat látnánk, az `A1`-et és `A2`-t. A létrejött könyvtárfa valahogy így nézne ki:

image::example-dir1.png[]

Egy állományrendszert csak egy másik állományrendszer valamelyik könyvtárába tudunk csatlakoztatni. Ezért most tételezzük fel, hogy a `B` állományrendszert az `A1` könyvtárba csatlakoztatjuk. Ezután a `B` gyökérkönyvtára átveszi a `A1` helyét az állományrendszerben, és ennek megfelelõen megjelennek a `B` könyvtárai is:

image::example-dir2.png[]

A `B1` vagy `B2` könyvtárakban található állományok bármelyike innentõl kezdve a [.filename]#/A1/B1#, illetve a [.filename]#/A1/B2# elérési utakon érhetõek el. Az [.filename]#A1# könyvtárban található állományok erre az idõre rejtve maradnak. Akkor fognak újra felbukkanni, ha a `B` állományrendszert _leválasztjuk_ az `A` állományrendszerrõl.

Ha a `B` állományrendszert az `A2` könyvtárba csatlakoztatnánk, az iménti ábra nagyjából így nézne ki:

image::example-dir3.png[]

és ennek megfelelõen az elõbb tárgyalt elérési utak [.filename]#/A2/B1# és [.filename]#/A2/B2# lennének.

Az állományrendszerek egymáshoz is csatlakoztathatóak. A példát ennek megfelelõen úgy is folytathatjuk, hogy a `C` állományrendszert csatlakoztatjuk `B` állományrendszerben található `B1` könyvtárhoz. Ennek eredménye a következõ elrendezés lesz:

image::example-dir4.png[]

Vagy a `C` állományrendszer az `A1` könyvtáron keresztül csatlakoztatható akár közvetlenül az `A` állományrendszerhez is:

image::example-dir5.png[]

Az MS-DOS(R) operációs rendszert ismerõk számára ez hasonló lehet a `join` parancshoz (habár teljesen nem egyezik meg vele).

Általában azonban ezzel nem kell törõdnünk, hiszen többnyire csak a FreeBSD telepítése során hozunk létre állományrendszereket és választjuk meg a csatlakozási pontjukat. A késõbbiekben ez legfeljebb akkor kerül elõ ismét, amikor újabb lemezeket adunk hozzá a rendszerhez.

Teljességgel megengedhetõ, hogy elhagyjuk a többit és csak egyetlen óriási gyökér-állományrendszert használjunk. Ennek viszont megvannak a maga hátrányai és az egyetlen elõnye.

.Több állományrendszer használatának elõnyei
* A különbözõ állományrendszereknek különbözõ _csatlakoztatási beállításai_ (mount options) lehetnek. Például, ha kellõen elõvigyázatosak akarunk lenni, a gyökér-állományrendszer írásvédett módon is csatlakoztatható, aminek köszönhetõen lehetetlenné válik a rendszer számára fontos állományok véletlen törlése vagy felülírása. Ha elkülönítjük a felhasználók számára írható állományrendszereket (például a [.filename]#/home# könyvtárakat) a többi állományrendszertõl, lehetõvé válik számunkra, hogy _nosuid_ beállítással csatlakoztassuk ezeket. Ez a beállítás megakadályozza, hogy ezekben a _suid_/_guid_ bitekkel rendelkezõ végrehajtható állományok használhatóak legyenek, ezáltal növeli a rendszer biztonságosságát.
* A FreeBSD az állományrendszer használatától függõen magától határoz a benne található állományok optimális kiosztását illetõen. Így tehát a gyakorta módosított, kisebb állományokat tartalmazó állományrendszerek esetén teljesen más technikákat alkalmaz, mint például a nagyobb, kevésbé változó állományok esetén. Azonban egyetlen állományrendszer használatával ez a gyorsítási módszer odavész.
* Noha a FreeBSD állományrendszerei nagyon jól tûrik a hirtelen áramkimaradásokat, egy döntõ ponton bekövetkezõ váratlan leállás mégis kárt okozhat a szerkezetükben. Ha azonban több állományrendszerre osztjuk a tárolandó adatainkat, sokkal valószínûbbé válik, hogy egy ilyen eset után a rendszerünk talpra tud állni, és szükség esetén nekünk is könnyebb lesz a biztonsági mentéseinkbõl helyreállítani a sérült állományokat.

.Egyetlen állományrendszer használatának elõnyei
* Az állományrendszerek mérete rögzített. Miután a FreeBSD telepítése során létrehoztunk egy adott méretû állományrendszert, elõfordulhat, hogy késõbb szükségünk lesz a méretének növelésére. Ilyenkor nehezen kerülhetjük el az ilyenkor szokásos teendõket: biztonsági mentés készítése, az új méretnek megfelelõ állományrendszer létrehozása, majd ezután a lementett adataink visszaállítása.
+
[IMPORTANT]
====
A FreeBSD-ben azonban megtalálható a man:growfs[8] parancs, amelynek segítségével az állományrendszerek mérete használat közben növelhetõ, és ezzel megszûnik a méretre vonatkozó korlátozás.
====

Az állományrendszerek partíciókban tárolódnak. A FreeBSD UNIX(R)-os eredete miatt azonban ez a kifejezés nem a hétköznapi "partíció" jelentését takarja (mint például egy MS-DOS(R) partíció). Minden partíciót egy betû azonosít `a`-tól `h`-ig. Mindegyik partíció csak egyetlen állományrendszert tartalmazhat, aminek révén az állományrendszereket vagy az állományrendszerek hierarchiájában található csatlakozási pontjukkal vagy pedig az ezeket tartalmazó partíció betûjével azonosíthatjuk.

A FreeBSD ezeken felül külön lemezterülen tárolja a __lapozóállomány__t (swap space). A lapozóállományt használja a FreeBSD _virtuális memória_ (virtual memory) megvalósításához. Ennek köszönhetõen a számítógép képes úgy viselkedni, mintha jóval több memóriával rendelkezne, mint valójában. Így, amikor a FreeBSD kifogy a memóriából, egyszerûen kirakja a memóriából a lapozóállományba az éppen nem használt adatokat, majd amikor ismét szüksége lesz rájuk, visszatölti ezeket (és ilyenkor megint kirak valami mást).

Némely partícióhoz kötõdnek bizonyos megszokások.

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Partíció
| Megszokás

|`a`
|Általában ez tartalmazza a gyökér-állományrendszert.

|`b`
|Általában ez tartalmazza a lapozóállományt.

|`c`
|Mérete általában a tartalmazó slice méretével egyezik meg. Ennek köszönhetõen a segédprogramok (például egy hibás szektorokat keresõ program) a `c` partíción keresztül képesek akár az egész slice-szal dolgozni. Normális esetben ezen a partíción nem hozunk létre állományrendszert.

|`d`
|A `d` partícióhoz egykoron kapcsolódott különleges jelentés, azonban mostanra ez már megszûnt, és a `d` egy teljesen átlagos partíciónak tekinthetõ.
|===

Minden állományrendszert tartalmazó partíciót a FreeBSD egy ún. _slice_-ban tárol. A FreeBSD számára a slice elnevezés utal mindarra, amit általában partíciónak neveznek, és ismét megemlítjük, mindez a UNIX(R)-os eredet miatt. A slice-okat 1-tõl 4-ig sorszámozzák.

A slice-ok sorszáma 1-tõl indulva az eszközök neve után egy `s` betûvel elválasztva következik. Így tehát a "da0__s1__" jelentése az elsõ slice lesz az elsõ SCSI-meghajtón. Lemezenként négy fizikai slice hozható létre, de ezeken belül tetszõleges típusú logikai slice-ok helyezhetõek el. Ezen további slice-ok sorszámozása 5-tõl kezdõdik, így ennek megfelelõen a "ad0__s5__" lesz az elsõ IDE-lemezen található elsõ kiterjesztett slice. Ezeket az eszközöket foglalják el a különbözõ állományrendszerek.

A slice-ok, a "veszélyesen dedikált" (Dangerously Dedicated) fizikai meghajtók, és minden más olyan meghajtó, amely _partíciókat_ tartalmaz, `a`-tól `h`-ig jelölõdnek. Ez a betû az eszköz neve után következik, így ennek megfelelõen a "da0__a__" lesz az elsõ "da" meghajtó "a", vagyis a "veszélyesen dedikált" partíciója. Az "ad1s3__e__" lesz a második IDE-lemezmeghajtón a harmadik slice-ban szereplõ ötödik partíció.

Végezetül, a rendszerben minden lemezt azonosítunk. A lemez neve a típusára utaló kóddal kezdõdik, amely után aztán egy sorszám jelzi, hogy melyik lemezrõl is van szó. Azonban eltérõen a slice-okétól, a lemezek sorszámozása 0-tól indul. Az általánosan elterjedt kódolások a <<basics-dev-codes>>ban találhatóak.

Amikor hivatkozunk egy partícióra, a FreeBSD elvárja tõlünk, hogy nevezzük meg az adott partíciót tartalmazó slice-ot és lemezt is. Emiatt egy partícióra mindig úgy hivatkozunk, hogy elõször megadjuk a tartalmazó lemez nevét, ettõl `s`-sel elválasztva a tartalmazó slice sorszámát, majd ezt a partíció betûjelével zárjuk. Erre példákat a <<basics-disk-slice-part>>ban láthatunk.

Az érhetõség kedvéért a <<basics-concept-disk-model>> bemutatja egy lemez kiosztásának fogalmi sablonját.

A FreeBSD telepítéséhez elõször be kell állítani a lemezen található slice-okat, majd létrehozni benne a FreeBSD-hez használni kívánt partíciókat, kialakítani rajtuk az állományrendszereket (vagy a lapozóállományt) és eldönteni, melyik állományrendszert kívánjuk csatlakoztatni.

[[basics-dev-codes]]
.Lemezes eszközök kódjai
[cols="1,1", frame="none", options="header"]
|===
| Kód
| Jelentés

|[.filename]#ad#
|ATAPI (IDE) lemez

|[.filename]#da#
|közvetlen hozzáférésû SCSI lemez

|[.filename]#acd#
|ATAPI (IDE) CDROM

|[.filename]#cd#
|SCSI CDROM

|[.filename]#fd#
|Floppylemez
|===

[[basics-disk-slice-part]]
.Példák lemezek, slice-ok és partíciók neveire
[example]
====
[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Név
| Jelentés

|`ad0s1a`
|Az elsõ IDE lemezen (`ad0`) levõ elsõ slice (`s1`) elsõ partíciója (`a`).

|`da1s2e`
|A második SCSI-lemzen (`da1`) levõ második slice (`s2`) ötödik partíciója (`e`).
|===
====

[[basics-concept-disk-model]]
.Egy lemez kialakításának sablonja
[example]
====
Az ábrán a rendszerhez csatlakoztatott elsõ IDE-lemez látható a FreeBSD szemszögébõl. Tegyük fel, hogy ez a lemez 4 GB méretû és két, egyenként 2 GB méretû slice-ot (avagy MS-DOS(R) partíciót) tartalmaz. Az elsõ slice egy MS-DOS(R) formátumú lemezt foglal magában, a [.filename]#C:# meghajtót, illetve a második slice egy telepített FreeBSD-t tartalmaz. Ebben a példában a FreeBSD három adatot és egy lapozóállományt tároló partícióval rendelkezik.

A három partíció mindegyikén találhatunk egy-egy állományrendszert. Az `a` partíció lesz a gyökér-állományrendszer, az `e` lesz a rendszerünkben a [.filename]#/var# és az `f` pedig a [.filename]#/usr# könyvtár.

image::disk-layout.png[]

====

[[mount-unmount]]
== Állományrendszerek csatlakoztatása és leválasztása

Az állományrendszereket legkönnyebben egy-egy faként tudjuk magunk elõtt elképzelni, amelyek a [.filename]#/# könyvtárból nõnek ki. A [.filename]#/dev#, [.filename]#/usr# és mellettük szereplõ, hozzájuk hasonló összes többi könyvtár csupán egy-egy ág, amelyeknek saját ágaik is lehetnek, mint például a [.filename]#/usr/local# és így tovább.

Különféle okai vannak annak, hogy egyes könyvtárakat különálló állományrendszereken tárolunk. A [.filename]#/var# könyvtár tartalmazza a [.filename]#log/#, [.filename]#spool/# könyvtárakat és különféle átmeneti állományokat, azonban az ilyen állományok könnyen megszaporodhatnak és megtölthetik az állományrendszert. Mivel a gyökér-állományrendszert nem tanácsos elárasztani mindenféle állománnyal, ezért gyakran a hasznunkra válhat, ha a [.filename]#/var# könyvtárat leválasztjuk a [.filename]#/# könyvtárból.

A másik gyakori ok, ami az imént említett fa egyes ágainak különbözõ állományrendszereken történõ tárolását indokolja, hogy ezek gyakran más fizikai vagy virtuális lemezeken, például a rendszerhez csatlakoztatott crossref:network-servers[network-nfs,Hálózati állományrendszer]eken vagy éppen CD-meghajtókon találhatóak.

[[disks-fstab]]
=== Az [.filename]#fstab# állomány

A crossref:boot[boot,rendszerindítás folyamata] során az [.filename]#/etc/fstab# állományban felsorolt állományrendszerek maguktól kerülnek csatlakoztatásra (kivéve amikor a `noauto` beállítással szerepelnek).

Az [.filename]#/etc/fstab# állományban található sorok az alábbi szerkezetûek:

[.programlisting]
....
eszköz       /csatlakozási-pont típus     beállítások      mentésigyak     ellszám
....

`eszköz`::
A crossref:disks[disks-naming,Az eszközök elnevezései]ban leírtak szerint megnevezett (létezõ) eszköz.

`csatlakozási-pont`::
Egy (létezõ) könyvtár, ahova az állományrendszer csatlakozik.

`típus`::
Az állományrendszer man:mount[8] parancs szerint ismert típusa. A FreeBSD alapértelmezett állományrendszere az `ufs`.

`beállítások`::
Az írható-olvasható állományrendszerek esetén `rw`, az írásvédettek esetén pedig `ro`, amelyet igény szerint további beállítások követhetnek. A rendszerindítás során automatikusan nem csatlakoztatandó állományrendszerek esetén gyakran alkalmazott beállítás itt még a `noauto`. Egyéb lehetõségeket a man:mount[8] man oldalon láthatunk.

`mentésigyak`::
Ezt általában a man:dump[8] parancs használja a menteni szükséges állományrendszerek megállapításához. Amennyiben hiányzik ez a mezõ, az automatikusan a nulla értéket jelöli.

`ellszám`::
Megadja, hogy mely állományrendszereket kell ellenõrizni. A nullás `pass` értékkel rendelkezõ állományrendszerek nem kerülnek ellenõrzésre. A gyökér-állományrendszer (melyet minden más elõtt kell ellenõrizni) `passno` értéke egy, míg az összes többi állományrendszer `passno` értéke általában egytõl különbözõ. Ha egynél több állományrendszer is ugyanazt a `passno` értéket kapta, akkor az man:fsck[8] a lehetõségei szerint megpróbálja ezeket egyszerre ellenõrizni.

Az [.filename]#/etc/fstab# felépítésérõl és a benne használható beállításokról bõvebben a man:fstab[5] man oldalon olvashatunk.

[[disks-mount]]
=== A `mount` parancs

Az állományrendszerek tényleges csatlakoztatására avagy "mountolására" a man:mount[8] parancs használható.

Legegyszerûbb formája:

[source,shell]
....
# mount eszköz csatlakozási-pont
....

Ahogy a man:mount[8] man oldalán is olvashatjuk, itt rengeteg opció is megadható, de ezek közül a leggyakoribbak:

.Csatlakoztatási opciók
`-a`::
Csatlakoztatja az [.filename]#/etc/fstab# állományban felsorolt összes állományrendszert, kivéve azokat, amelyek a "noauto" beállítást tartalmazzák, vagy kizártuk a `-t` kapcsolóval, esetleg korábban már csatlakoztattuk.

`-d`::
A tényleges csatlakoztatás elvégzése nélkül végrehajt minden mást. Ez az opció leginkább `-v` opcióval együtt használható annak megállapítására, hogy a man:mount[8] valójában mit is akar csinálni.

`-f`::
Egy nem tiszta állományrendszer csatlakoztatásának kényszerítése (veszélyes!) vagy egy korábban már csatlakoztatott állományrendszer írható állapotának felfüggesztése.

`-r`::
Az állományrendszer írásvédett csatlakoztatása. Megegyezik a `-o` opciónál megadható `ro` (vagy a FreeBSD 5.2-nél régebbi verziója esetén a `rdonly`) beállítás használatával.

`-t` _típus_::
Az adott állományrendszert az adott típusnak megfelelõen csatlakoztatja, vagy az `-a` használata esetén csak az adott típusú állományrendszereket.
+
Az "ufs" az állományrendszerek alapértelmezett típusa.

`-u`::
Frissíti az állományrendszerre vonatkozó csatlakoztatási beállításokat.

`-v`::
Részletesebb kijelzés.

`-w`::
Az állományrendszer csatlakoztatása írásra és olvasásra.

Az `-o` opció után vesszõvel elválasztott beállításokat adhatunk meg, többek közt az alábbiakat:

noexec::
Az állományrendszeren található állományok végrehajtásának tiltása. Ez egy nagyon hasznos biztonsági beállítás.

nosuid::
Az állományrendszeren nem használhatóak a felhasználó- (setuid) vagy csoportváltásra (setgid) vonatkozó engedélyek. Nagyon hasznos biztonsági beállítás.

[[disks-umount]]
=== Az `umount` parancs

Az man:umount[8] parancs paraméterként egy csatlakozási pontot, egy eszköznevet vagy a `-a`, illetve az `-A` opciókat várja.

A leválasztás kényszerítéséhez mindegyik alakban szerepelhet az `-f` opció, valamint a részletesebb kijelzést a `-v` opcióval kapcsolhatjuk be. Azonban szeretnénk mindenkit figyelmeztetni, hogy a `-f` használata alapvetõen nem ajánlott. Az erõszakkal leválasztott állományrendszerek összeomlaszthatják a számítógépet vagy kárt okozhatnak az állományrendszereken található adatokban.

Az `-a` és `-A` opciók használatosak az összes csatlakoztatott állományrendszer leválasztására, amelyek típusait a `-t` opció megadása után sorolhatjuk fel. Fontos különbség azonban, hogy az `-A` opció a gyökér állományrendszert nem próbálja meg leválasztani.

[[basics-processes]]
== Folyamatok

A FreeBSD egy többfeladatos operációs rendszer. Ez azt jelenti, hogy képes látszólag egyszerre több programot is futtatni. Az így egyszerre futó programokat egyenként __folyamat__oknak (process) nevezzük. Minden kiadott parancsunk elindít legalább egy ilyen folyamatot, és a rendszerünk mozgásban tartásához bizonyos rendszerszintû folyamatok állandóan futnak a háttérben.

Minden folyamatot egy __folyamatazonosító__nak (process ID vagy __PID__) nevezett szám azonosít egyértelmûen, és az állományokhoz hasonlóan, minden folyamatnak van tulajdonosa és csoportja is. A tulajdonos és a csoport ismeretében állapítja meg a rendszer, hogy az adott folyamat a korábban említett engedélyek szerint milyen állományokhoz és eszközökhöz férhet hozzá. Ezenkívül a legtöbb folyamatnak van még egy szülõfolyamata is. A szülõfolyamat az a folyamat, amely az adott folyamatot elindította. Például amikor parancsokat adunk egy parancsértelmezõn keresztül, akkor maga a parancsértelmezõ is egy ilyen folyamat lesz ugyanúgy, ahogy a benne kiadott parancsok által elindított programok. Ennek megfelelõen az így létrehozott összes folyamat szülõje maga a parancsértelmezõ folyamata lesz. Az említettek alól egyik kivétel az man:init[8] nevû speciális folyamat. Az `init` lesz a rendszerben mindig az elsõ folyamat, ezért a PID-je is mindig 1. Az `init` programot a FreeBSD indulásakor a rendszermag fogja automatikusan elindítani.

A rendszerben futó programok vizsgálatához két, különösen hasznos parancsot találhatunk: ezek a man:ps[1] és a man:top[1]. A `ps` parancs használatos a pillanatnyilag futó programok statikus listájának megjelenítésére. Ebben olvashatjuk a futó programok azonosítóit, mennyi memóriát használnak éppen, milyen paranccsal indították ezeket stb. A `top` parancs mutatja az összes aktívan futó programot, majd néhány másodpercenként automatikusan frissíti ezt a listát, aminek révén folyamatosan láthatjuk, miként viselkednek a futó programok.

A `ps` alapértelmezés szerint csupán az általunk futtatott programokat mutatja. Például:

[source,shell]
....
% ps
  PID  TT  STAT      TIME COMMAND
  298  p0  Ss     0:01.10 tcsh
 7078  p0  S      2:40.88 xemacs mdoc.xsl (xemacs-21.1.14)
37393  p0  I      0:03.11 xemacs freebsd.dsl (xemacs-21.1.14)
48630  p0  S      2:50.89 /usr/local/lib/netscape-linux/navigator-linux-4.77.bi
48730  p0  IW     0:00.00 (dns helper) (navigator-linux-)
72210  p0  R+     0:00.00 ps
  390  p1  Is     0:01.14 tcsh
 7059  p2  Is+    1:36.18 /usr/local/bin/mutt -y
 6688  p3  IWs    0:00.00 tcsh
10735  p4  IWs    0:00.00 tcsh
20256  p5  IWs    0:00.00 tcsh
  262  v0  IWs    0:00.00 -tcsh (tcsh)
  270  v0  IW+    0:00.00 /bin/sh /usr/X11R6/bin/startx -- -bpp 16
  280  v0  IW+    0:00.00 xinit /home/nik/.xinitrc -- -bpp 16
  284  v0  IW     0:00.00 /bin/sh /home/nik/.xinitrc
  285  v0  S      0:38.45 /usr/X11R6/bin/sawfish
....

Ahogy az a fenti példában is látszik, a man:ps[1] kimenete oszlopokra tagolható. Ezek közül a `PID` tartalmazza a korábban már ismertetett folyamatazonosítókat. Az azonosítók 1-tõl indulva egészen 99999-ig sorszámozódhatnak, illetve ha kifutnánk belõlük, akkor a számozás kezdõdik elölrõl (azonban a használatban levõ azonosítók sosem kerülnek újra kiosztásra). A `TT` oszlopban láthatjuk azt a terminált, amelyen az adott program éppen fut, de ezt pillanatnyilag akár nyugodtan figyelmen kívül is hagyhatjuk. A `STAT` oszlopban a program állapotát kapjuk meg, de szintén átugorható. A `TIME` a program processzoron eltöltött idejét mutatja - ez általában nem arra utal, hogy mennyi ideje fut maga a program, hiszen a legtöbb program sok idõt tölt tétlenül, mielõtt egyáltalán szüksége lenne processzora. Végezetül a `COMMAND` oszlopban olvashatjuk azt a parancsot, amellyel a programot elindították.

A man:ps[1] számos különféle beállítást ismer az általa megjelenített információk megválasztásához. Az egyik ilyen leghasznosabb beállítás az `auxww`: az `a` segítségével az összes futó programot láthatjuk, nem csak a sajátjainkat; az `u` megadásával láthatóvá válik a folyamat tulajdonosának a felhasználói neve, valamint a memóriahasználata is; az `x` megmutatja a démon (avagy háttér)folyamatok adatait is és a `ww` hatására pedig a man:ps[1] az összes folyamathoz a teljes parancssort kiírja, még akkor is, ha nem férne ki a képernyõre.

A man:top[1] kimenete is hasonló. Ha elindítjuk, általában ezt láthatjuk:

[source,shell]
....
% top
last pid: 72257;  load averages:  0.13,  0.09,  0.03    up 0+13:38:33  22:39:10
47 processes:  1 running, 46 sleeping
CPU states: 12.6% user,  0.0% nice,  7.8% system,  0.0% interrupt, 79.7% idle
Mem: 36M Active, 5256K Inact, 13M Wired, 6312K Cache, 15M Buf, 408K Free
Swap: 256M Total, 38M Used, 217M Free, 15% Inuse

  PID USERNAME PRI NICE  SIZE    RES STATE    TIME   WCPU    CPU COMMAND
72257 nik       28   0  1960K  1044K RUN      0:00 14.86%  1.42% top
 7078 nik        2   0 15280K 10960K select   2:54  0.88%  0.88% xemacs-21.1.14
  281 nik        2   0 18636K  7112K select   5:36  0.73%  0.73% XF86_SVGA
  296 nik        2   0  3240K  1644K select   0:12  0.05%  0.05% xterm
48630 nik        2   0 29816K  9148K select   3:18  0.00%  0.00% navigator-linu
  175 root       2   0   924K   252K select   1:41  0.00%  0.00% syslogd
 7059 nik        2   0  7260K  4644K poll     1:38  0.00%  0.00% mutt
...
....

A kimenet két részre osztható. A fejlécben (vagyis az elsõ öt sorban) látható az utoljára futtatott program azonosítója (PID), a rendszer átlagos terhelése (load average, amellyel mérjük, hogy a rendszerünk mennyire lefoglalt), a rendszer indítása óta eltelt idõ (up mint uptime) és a jelenlegi idõ. A fejlécben még megtalálhatjuk azt is, mennyi program fut (esetünkben ez most 47), mennyi memóriát és lapozóállományt használnak, és mennyi idõt tölt a rendszer a processzor különbözõ állapotaiban.

A fejléc alatt a man:ps[1] kimenetéhez hasonló módon oszlopokba rendezve találhatjuk meg a folyamatok adatait: az azonosítóikat, a tulajdonosaik nevét, a felhasznált processzoridõt, a futtatott parancsot. A man:top[1] alapértelmezés szerint mutatja a futó programok által használt memória mennyiségét is: ez további két oszlopra oszlik, ahol az egyikben a teljes memóriafoglalást (SIZE), a másikban pedig a jelen pillanatban aktívan használt memóriát (RES) láthatjuk. A példában látható is, hogy a man:getenv[3] (navigator-linu) alkalmazásnak majdnem 30 MB-nyi memóriára van szüksége, de ebbõl aktívan csak 9 MB-ot használ.

A man:top[1] a kijelzést minden második másodpercben magától frissíti, de ez az `s` kapcsolóval állítható.

[[basics-daemons]]
== Démonok, jelzések és a futó programok leállítása

Amikor elindítunk egy szövegszerkesztõt, nem sok gondunk akad az irányításával, könnyen utasíthatjuk az állományok betöltésére és így tovább. Mindezt azért tehetjük meg, mert a szövegszerkesztõ erre lehetõséget biztosít és mivel a szövegszerkesztõ egy __terminál__hoz kapcsolódik. Egyes programok azonban nem úgy lettek kialakítva, hogy állandóan a felhasználó utasításaira támaszkodjanak, ezért az elsõ adandó alkalommal lekapcsolódnak a terminálról. Például egy webszerver egész nap csak webes kéréseket válaszol meg, és általában semmi szüksége nincs a felhasználók utasításaira. A szerverek között leveleket közvetítõ programok is ugyanezen osztályba tartoznak.

Ezeket a programokat __démon__onoknak hívjuk. A démonok a görög mitológiában jelentek meg: sem a jót, sem pedig a gonoszt nem képviselték, egyszerû apró szellemecskék voltak, akik az emberiség javát szolgálták, pontosan úgy, ahogy ma teszik azt a különféle web- és levelezõ szerverek. Ezért is ábrázolták sokáig a BSD kabalafiguráját is egy tornacipõs, vasvillás vidám démonként.

A démonként futó programok nevéhez a hagyományok szerint hozzá szokták fûzni a "d" betût. A BIND a Berkeley Internet Name Domain (névfeloldó) szolgáltatása, azonban a hozzá tartozó program neve `named`, az Apache webszerver programját `httpd`-nek nevezik, a sornyomtató kezeléséért felelõs démon pedig az `lpd` és így tovább. Ez csupán egy hagyomány, megszokás, nem pedig egy kõbe vésett szabály: például a Sendmail levelezõ démonának neve `sendmail` és nem pedig `maild`.

Néha azért szükségünk lehet arra, hogy felvegyük valahogy a kapcsolatot a démonként futó programokkal is. Ennek egyik lehetséges módja a __jelzés__ek (signal) küldése (de alapvetõen bármilyen futó programnak küldhetünk). Több különféle jelzés küldhetõ - egyeseknek közülük megkülönböztetett jelentése van, másokat magukat az alkalmazások értelmeznek, amelyrõl a dokumentációjukban tájékozódhatunk. A man:kill[1] vagy man:kill[2] paranccsal más tulajdonában levõ futó programoknak nem tudunk jelzéseket küldeni, ami alól egyedüli kivétel a `root` felhasználó.

Bizonyos esetekben a FreeBSD maga is küld néha jelzéseket. Amikor egy alkalmazást rosszul programoznak le és megpróbál egy számára tiltott memóriaterülethez hozzáférni, a FreeBSD küld neki egy _Segmentation Violation_ (`SIGSEGV`, szegmentálási hiba) jelzést. Ha egy alkalmazás az man:alarm[3] rendszerhíváson keresztül kér egy adott idõ utáni bekövetkezõ értesítést, akkor kap errõl egy Alarm (`SIGALRM`) jelzést és így tovább.

A folyamatok leállítására két jelzés használható: a `SIGTERM` (befejeztetés) és a `SIGKILL` (leállítás). A `SIGTERM` a folyamatok leállításának illedelmes módja, mivel ekkor a futó program képes _elkapni_ ezt a jelzést és észrevenni, hogy le akarjuk állítani. Ilyenkor a leállítás elõtt lehetõsége van szabályosan lezárni a naplóit és általánosságban véve befejezni mindent, amit éppen csinál. Elõfordulhat azonban, hogy a folyamatok figyelmen kívül hagyják a `SIGTERM` jelzést, ha például éppen egy félbeszakíthatatlan feladat közepén tartanak.

A `SIGKILL` jelzést azonban egyetlen futó program sem hagyhatja figyelmen kívül. Ez lenne a "Nem érdekel, mivel foglalkozol, azonnal hagyd abba!" jelzés. Amikor `SIGKILL` jelzést küldünk egy folyamatnak, a FreeBSD leállítja a folyamatot ott és ahol tart .

További használható jelzések: `SIGHUP`, `SIGUSR1` és `SIGUSR2`. Ezek általános célú jelzések, amelyeket az alkalmazások eltérõ módokon kezelnek.

Tegyük fel, hogy megváltoztattuk a webszerverünk beállításait tartalmazó állományt - valamilyen módon szeretnénk tudatni a szerverrel, hogy olvassa be újra a beállításait. Ezt megtehetjük úgy, hogy leállítjuk és újraindítjuk a `httpd` démont, de ezzel kiesést okozhatunk a szerver mûködésében, amit viszont nem engedhetünk meg. A legtöbb démont úgy készítették el, hogy a `SIGHUP` jelzés hatására olvassa be újra a beállításait tartalmazó állományt. Így a `httpd` leállítása és újraindítása helyett egyszerûen elegendõ egy `SIGHUP` jelzés küldése. Mivel azonban ez nem szabványosított, a különbözõ démonok ezt a jelzést többféleképpen is értelmezhetik. Ezért a használata elõtt ennek mindenképpen járjunk utána a kérdéses démon dokumentációjában.

A jelzéseket a man:kill[1] paranccsal tudjuk elküldeni, ahogy ezt a következõ példában is láthatjuk.

[.procedure]
====
*Procedure: Jelzés küldése egy futó programnak*

Ebben a példában megmutatjuk, hogyan lehet jelzést küldeni az man:inetd[8] démonnak. Az `inetd` a beállításait az [.filename]#/etc/inetd.conf# állományban tárolja, és az `inetd` a `SIGHUP` jelzés hatására képes újraolvasni ezt.

. Keressük meg annak a folyamatnak az azonosítóját, amelynek a jelzést kívánjuk küldeni. Ezt a man:ps[1] és a man:grep[1] használatával tehetjük meg. A man:grep[1] parancs segítségével más parancsok kimenetében tudunk megkeresni egy általunk megadott szöveget. Ezt a parancsot átlagos felhasználóként futtatjuk, azonban az man:inetd[8] démont a `root` birtokolja, ezért az man:ps[1] használata során meg kell adnunk az `ax` kapcsolókat is.
+
[source,shell]
....
% ps -ax | grep inetd
  198  ??  IWs    0:00.00 inetd -wW
....
+ 
Innen kiderül, hogy az man:inetd[8] azonosítója 198. Elõfordulhat, hogy az eredményben maga a `grep inetd` parancs is megjelenik. Ez a man:ps[1] listázási módszere miatt következhet be.
. A jelzés elküldésére használjuk a man:kill[1] parancsot. Mivel az man:inetd[8] démont a `root` felhasználó futtatja, ehhez elõször a man:su[1] parancs kiadásával nekünk is `root` felhasználóvá (rendszeradminisztrátorrá) kell válnunk.
+
[source,shell]
....
% su
Password:
# /bin/kill -s HUP 198
....
+ 
Ahogy az a legtöbb UNIX(R) esetén elfogadott, a sikeres végrehajtás esetén a man:kill[1] sem válaszol semmit. Amikor viszont nem egy saját programunknak akarunk jelzést küldeni, akkor a `kill: _PID_: Operation not permitted` (a mûvelet nem engedélyezett) hibaüzenetet látunk. Ha véletlenül elgépeltük volna a futó program azonosítóját, akkor a küldendõ jelzés nem a megfelelõ folyamatnál fog kikötni (ami nem éppen jó), vagy ha szerencsénk van, akkor a jelzést egy éppen használaton kívüli azonosítóra küldtük. Az utóbbi esetben a következõ láthatjuk: `kill: _PID_: No such process` (nincs ilyen folyamat).
+
[NOTE]
.Miért `/bin/kill`?
======
A legtöbb parancsértelmezõ beépítetten tartalmazza a saját `kill` parancsát, tehát ilyenkor közvetlenül maga a parancsértelmezõ küldi a jelzést, nem pedig a [.filename]#/bin/kill# programon keresztül. Ez gyakran a javunkra válhat, azonban a küldhetõ jelzések megadása parancsértelmezõnként eltérhet. Így, ahelyett, hogy egyenként ismernünk kellene mindegyiket, sokkal egyszerûbb közvetlenül a `/bin/kill ...` parancsot használni.
======
====

A többi jelzés küldése is nagyon hasonló módon történik, hiszen elegendõ csupán a `TERM` vagy a `KILL` behelyettesítése a parancs megfelelõ helyére.

[IMPORTANT]
====
A rendszerünkben óvatosan bánjunk a futó programok leállítgatásával, és legyünk különös tekintettel az 1-es azonosítóval rendelkezõ, speciális feladattal bíró man:init[8] folyamatra. A `/bin/kill -s KILL 1` parancs kiadásával ugyanis gyorsan le tudjuk állítani a rendszerünket. _Mielõtt_ egy man:kill[1] parancsot lezárnánk az kbd:[Enter] billentyûvel, _mindig_ gyõzõdjünk meg róla, hogy valóban tényleg a jó paramétereket adtuk meg.
====

[[shells]]
== Parancsértelmezõk

A FreeBSD-ben hétköznapi munkánk legnagyobb részét a parancsértelmezõknek (shell) nevezett parancssoros felületen tudjuk elvégezni. A parancsértelmezõ fõ feladata a beérkezõ parancsok elfogadása és végrehajtatása. Sok parancsértelmezõ ezenfelül rendelkezik beépített funkciókkal is, amelyek olyan hétköznapi feladatokban igyekeznek segíteni, mint például az állományok kezelése és tömeges elérése reguláris kifejezések használatával, a parancssor szerkesztése, parancsok makrózása és a környezeti változók használata. A FreeBSD alapból tartalmaz néhány parancsértelmezõt, ilyen például az `sh`, a Bourne Shell, és a `tcsh`, a továbbfejlesztett C-shell. Sok más parancsértelmezõ, mint például a `zsh` és `bash` is elérhetõ a FreeBSD Portgyûjteményébõl.

De melyik parancsértelmezõt is válasszuk? Ez igazából ízlés kérdése. Ha inkább C programozók vagyunk, akkor valószínûleg egy olyan C-szerû shelllel tudunk kényelmesen dolgozni, amilyen például a `tcsh`. Ha viszont egy linuxos rendszert használtunk korábban vagy éppen még soha nem használtunk volna a UNIX(R) parancssorát, érdemes a `bash`-sel megpróbálkoznunk. A lényeg az, hogy minden parancsértelmezõnek vannak olyan egyedi jellemezõi, amiért használatóak vagy éppen nem használatóak a munkánkban, ezért magunknak kell kiválasztani a nekünk megfelelõt.

A shellek egyik legáltalánosabb jellemzõje az állományok neveinek kiegészítése. Miután begépeljük egy parancs vagy állománynév elsõ néhány karakterét, a kbd:[Tab] billentyû lenyomásával megkérhetjük a parancsértelmezõt, hogy magától egészítse ki ("találja ki") a fennmaradó részt. Nézzük erre egy példát. Tegyük fel, hogy van két állományunk, [.filename]#izemize# és [.filename]#ize.mize#, és szeretnénk letörölni az [.filename]#ize.mize# nevût. Ehhez a következõt kell begépelnünk: `rm iz[Tab].[Tab]`.

Erre a parancsértelmezõ a következõ parancsot írja ki: `rm ize[SIPOLÁS].mize`.

A [SIPOLÁS] itt a konzol sípjára vonatkozik, amellyel jelzi, hogy nem tudta teljesen kiegészíteni az állomány nevét, mivel egynél több is megfelel a megadott alaknak. Az [.filename]#izemize# és az [.filename]#ize.mize# is egyaránt az `iz` elõtaggal kezdõdik, azonban ebbõl a parancsértelmezõ csak az `ize` elõtagot tudta kikövetkeztetni. Ha most begépelünk még egy `.` karaktert és újra megnyomjuk a kbd:[Tab] billentyût, a parancsértelmezõ ezúttal képes lesz az állomány teljes nevét megállapítani.

A parancsértelmezõk másik általános jellemzõje a környezeti változók használata. A környezeti változók lényegében a parancsértelmezõ környezetéhez tárolt név-érték párok. Ezt a környezetet látja minden olyan program, amit a parancsértelmezõbõl meghívunk, és ezért tartalmazni is szokott sok ilyen beállítást. Íme a leggyakoribb környezeti változók felsorolása és rövid leírása:

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Változó
| Leírás

|`USER`
|A bejelentkezett felhasználó neve.

|`PATH`
|Vesszõvel elválasztott könyvtárak, ahol a parancsértelmezõ a végrehajtható állományokat keresi.

|`DISPLAY`
|Az aktuálisan használt X11 megjelenítõ hálózati neve, amennyiben létezik ilyen.

|`SHELL`
|A használt parancsértelmezõ.

|`TERM`
|A felhasználó által használt terminál típusa. Ebbõl a terminál képességeit lehet megállapítani.

|`TERMCAP`
|A terminálok adatbázisából származó, különbözõ terminálfunkciókhoz tartozó helyettesítõ (escape) kódok.

|`OSTYPE`
|Az operációs rendszer típusa, például FreeBSD.

|`MACHTYPE`
|A rendszer alatt futó gép architektúrája.

|`EDITOR`
|A felhasználó által használt szövegszerkesztõ.

|`PAGER`
|A felhasználó által lapozásra használt program.

|`MANPATH`
|Vesszõvel elválasztott könyvtárak, ahol a parancsértelmezõ a man oldalakat keresi.
|===

A környezeti változók beállítása parancsértelmezõnként valamennyire eltér. Például egy C stílusú parancsértelmezõ, mint például a `tcsh` vagy a `csh`, a `setenv` paranccsal állítja a környezeti változókat. A Bourne-féle parancsértelmezõk, mint például az `sh` vagy a `bash`, az `export` parancsot használják a környezeti változók beállítására. Például a `csh` vagy a `tcsh` használata során a következõképpen tudjuk be- vagy átállítani az `EDITOR` környezeti változó értékét [.filename]#/usr/local/bin/emacs#-re:

[source,shell]
....
% setenv EDITOR /usr/local/bin/emacs
....

Ugyanez a Bourne-féle parancsértelmezõkben:

[source,shell]
....
% export EDITOR="/usr/local/bin/emacs"
....

A legtöbb parancsértelmezõben a nevük elõtt szerepeltetett `$` jel segítségével kérhetjük a környezeti változók értékének behelyettesítését a parancssorba. Ennek megfelelõen az `echo $TERM` parancs kiíratja a `TERM` változó aktuális értékét, mivel ebbe a parancsértelmezõ már az `echo` meghívása elõtt behelyettesíti a `TERM` értékét.

A parancsértelmezõk számos speciális karaktert, ún. metakaraktert az adatok különleges reprezentációjaként kezelnek. Köztük a leggyakrabban használt a `\*`, amely tetszõleges számú karaktert helyettesít egy állomány nevében. Az ilyen metakarakterek segítségével tudunk egyszerre több állományt is megnevezni. Például ha begépeljük az `echo *` parancsot, akkor majdnem ugyanazt kapjuk eredményül, mintha az `ls` parancsot adtuk volna ki, hiszen a parancsértelmezõ ilyenkor veszi az összes `*` metakarakterre illeszkedõ állományt, és a kiíratásukhoz pedig rendre behelyettesíti ezeket a parancssorba az `echo` paramétereként.

Ha nem szeretnénk, hogy a parancsértelmezõ értelmezze a speciális karaktereket, akkor egy "backslash" (visszaper) (`\`) karaktert eléjük téve mindezt megakadályozhatjuk. Az `echo $TERM` parancs ugyebár kiíratja a terminálra vonatkozó környezeti változó beállítását, azonban a `echo \$TERM` változatlanul kiírja a `$TERM` szöveget.

[[changing-shells]]
=== A parancsértelmezõnk megváltoztatása

A parancsértelmezõnk legegyszerûbben a `chsh` parancs használatával változtatható meg. A `chsh` kiadása után elindítja az `EDITOR` környezeti változónak megfelelõ szövegszerkesztõt, ha nem lenne ilyen, akkor alapértelmezés szerint a `vi` hívódik meg. Az így megnyitott állományban változtassuk meg kedvünk szerint a "Shell: " kezdetû sort.

A `chsh` parancsnak megadhatjuk az `-s` opciót is, amin keresztül szövegszerkesztõ használata nélkül be tudjuk állítani a parancsértelmezõt. Például ha a parancsértelmezõnket a `bash`-re akarjuk lecserélni, akkor ezt írjuk be:

[source,shell]
....
% chsh -s /usr/local/bin/bash
....

[NOTE]
====
A használni kívánt parancsértelmezõnek szerepelnie _kell_ az [.filename]#/etc/shells# állományban. Ha a kiválasztott parancsértelmezõt a crossref:ports[ports,Portgyûjtemény]bõl telepítettük fel, akkor az már minden bizonnyal bekerült oda. Ha viszont saját magunk raktuk volna fel, akkor ide is fel kell vennünk.

Például ha a `bash`-t manuálisan telepítettük és másoltuk a [.filename]#/usr/local/bin# könyvtárba, akkor így kell eljárnunk:

[source,shell]
....
# echo "/usr/local/bin/bash" >> /etc/shells
....

Majd próbálkozzunk újra a `chsh` paranccsal.
====

[[editors]]
== Szövegszerkesztõk

A FreeBSD beállításának nagy része szöveges állományok szerkesztésével történik. Emiatt sosem árt legalább egy szövegszerkesztõt ismernünk. A FreeBSD alaprendszerében, valamint a Portgyûjteményben is találhatunk néhányat belõlük.

A legegyszerûbben megtanulható és legkönnyedebb szövegszerkesztõt ee-nek, avagy "easy editornak" hívják. Az ee indításához írjuk be az `ee állománynév` parancsot, ahol az _állománynév_ lesz a szerkesztendõ állomány neve. Így például az [.filename]#/etc/rc.conf# állomány szerkesztéséhez gépeljük be az `ee /etc/rc.conf` parancsot. Miután elindult az `ee`, az összes szerkesztéshez használható parancsa megjelenik a képernyõ felsõ részében. Itt a "kalap" (`^`) karakter a kbd:[Ctrl] billentyû lenyomására utal, így tehát a `^e` jelölés a kbd:[Ctrl+e] billentyûkombinációt jelenti. Ha ki akarunk lépni az ee-bõl, nyomjuk le az kbd:[Esc] billentyût, majd a felbukkanó menübõl válasszuk a szerkesztõ elhagyását (leave editor). Ha az állományt módosítottuk, kilépés elõtt még a szövegszerkesztõ rákérdez, hogy mentse-e a változtatásainkat.

A FreeBSD nagyobb tudású szövegszerkesztõket, mint például a vi-t, is tartalmaz az alaprendszer részeként, miközben a többi, mint például az Emacs vagy a vim a Portgyûjtemény részeként (package:editors/emacs[] és package:editors/vim[]) érhetõ el. Ezek a szerkesztõk sokkal több lehetõséget és erõt képviselnek, amiért cserébe viszont valamivel nehezebb megtanulni a használatukat. Ha viszont rengeteg szöveget akarunk majd szerkeszteni, akkor egy vim vagy Emacs használatának megismerésével sok idõt megspórolhatunk.

Számos alkalmazás, amely állományokat akar módosítani vagy szöveges bemenetre van szüksége, automatikusan szövegszerkesztõt nyit meg. Ezt az `EDITOR` környezeti változó beállításával tudjuk meghatározni. Errõl részletesebben a <<shells,parancsértelmezõknél>> olvashatunk.

[[basics-devices]]
== Eszközök és eszközleírók

Az eszköz elnevezést leginkább a rendszerben folyó, hardverrel kapcsolatos tevékenységek kapcsán használják lemezekre, nyomtatókra, grafikus kártyákra és billentyûzetekre. A FreeBSD indulása során többnyire azt láthatjuk, hogy milyen eszközöket sikerült felismernie. Ezeket a rendszerindításkor megjelenõ üzeneteket a [.filename]#/var/run/dmesg.boot# állományban nézhetjük meg újra.

Például az [.filename]#acd0# az elsõ IDE CD-meghajtót, míg a [.filename]#kbd0# a billentyûzetet képviseli.

A UNIX(R) operációs rendszerben a legtöbb eszközt a [.filename]#/dev# könyvtárban található, eszközleíróknak (device node) nevezett speciális állományokon keresztül érhetjük el.

=== Eszközleírók létrehozása

Amikor egy újfajta eszközt adunk hozzá a rendszerhez vagy csak annak egy új példányát, mindig létre kell hoznunk hozzá egy új eszközleírót.

==== `DEVFS` (DEVice File System, Eszköz-állományrendszer)

Az eszközöket tartalmazó állományrendszer, avagy `DEVFS`, ad hozzáférést a rendszermag által ismert eszközök neveihez a globális állományrendszer nevein keresztül. Így ahelyett, hogy magunknak kellene létrehoznunk és módosítanunk az eszközleírókat, a `DEVFS` erre a célra fenntart egy külön állományrendszert.

A man:devfs[5] man oldalon olvashatunk bõvebben errõl.

[[binary-formats]]
== Bináris formátumok

Annak megértéséhez, hogy a FreeBSD miért az man:elf[5] formátumot használja, elõször is tisztában kell lennünk a UNIX(R) típusú rendszerekben használt végrehajtható állományok három "uralkodó" formátumával:

* man:a.out[5]
+ 
A legõsibb és egyben a "klasszikus" UNIX(R)-os tárgykódformátum. Egy tömör és rövidke fejlécet használ, aminek az elején a formátum leírására szolgáló "bûvös szám" található (errõl bõvebben lásd man:a.out[5]). Három betöltött szegmenst tartalmaz: .text, .data és .bss, valamint egy szimbólumokat és karakterláncokat tároló táblát.
* COFF
+ 
Az SVR3 tárgykódformátuma. A fejléc itt már tartalmaz egy table nevû szegmenst is, tehát a .text, .data és .bss szegmensekhez hasonlóan ebbõl is többet tud tárolni.
* man:elf[5]
+ 
A COFF után következõ formátum, amelyben több szegmens is megtalálható, valamint létezik 32 bites és 64 bites változatban is. Egyetlen hátránya van: az ELF tervezése során rendszerarchitektúránként csupán egyetlen ABI-t (bináris alkalmazói felületet) feltételeztek. Ez azonban meglehetõsen helytelen, mivel még a kereskedelmi SYSV világában (ahol már legalább három ABI található: SVR4, Solaris és SCO) sem állja meg a helyét.
+ 
A FreeBSD ezt a problémát a _megbélyegzés_ (branding) segítségével próbálja megoldani, aminek révén el tudunk látni egy ismert ELF állományt a futtatásához megfelelõ ABI-ra vonatkozó információkkal. Errõl részletesebben a man:brandelf[1] oldalán tájékozódhatunk.

A FreeBSD a "klasszikusok" táborából indult, ezért kezdetben az man:a.out[5] formátumot használta, mivel ez a technológia a BSD kiadások számos generációjában megmérettetett és bevált, egészen a 3.X ág elindulásáig. Habár már jóval elõtte lehetett fordítani és futtatni natív ELF binárisokat (és rendszermagokat) a FreeBSD rendszereken, a FreeBSD kezdetben ódzkodott váltani az alapértelmezés szerinti ELF formátumra. De vajon miért? Nos, amikor a Linux-tábor megtette a maga fájdalmas váltását az ELF-re, az nem annyira azért volt, hogy megszabaduljanak az [.filename]#a.out# végrehajtható formátumtól, hanem mert a rugalmatlan, ugrótáblákon alapuló oszottkönyvtár-kezelési mechanizmusaik nagyon megnehezítették a gyártók és fejlesztõk számára az osztott függvénykönyvtárak létrehozását. Mivel az ELF formátumhoz rendelkezésre álló eszközök megoldást kínáltak az osztott könyvtárak gondjaira, és mivel általánosan elfogadták "a jövõbe vezetõ útként", a FreeBSD is felvállalta az átállással kapcsolatos költségeket és végrehajtotta azt. A FreeBSD az osztott könyvtárakat leginkább a Sun SunOS(TM) rendszeréhez hasonlóan kezeli, ami egy nagyon könnyen használható megoldás.

De miért van ilyen sok különbözõ formátum?

A ködös és sötét múltban egyszerûbb hardverek voltak. Ezek az egyszerû hardverek egyszerû, kicsi rendszereket támogattak. Az [.filename]#a.out# tökéletesen megfelelõ volt egy ilyen egyszerû rendszer (egy PDP-11) binárisainak tárolására. Ahogy az emberek nekiláttak átültetni errõl az egyszerû rendszerrõl a UNIX(R)-ot más rendszerekre, az [.filename]#a.out# formátumot továbbra is megtartották, mivel a UNIX(R) kezdeti, Motorola 68k-ra, VAXenre készített átírataihoz is elegendõ volt.

Ezután néhány éles elméjû hardvermérnök kitalálta, ha rá tudnák kényszeríteni a programokat egy-két ügyetlen trükkre, akkor a terveken meg tudnának spórolni néhány logikai kaput és ezzel a processzor is gyorsabban tudna futni. Miközben az [.filename]#a.out# formátumot ilyen hardverre (amit manapság RISC-nek hívnak) is szerették volna áthozni, kiderült, hogy ebben az esetben szinte használhatatlan. Ezért az [.filename]#a.out# formátum által felkínáltnál nagyobb teljesítmény elérése érdekében nekiláttak számos más formátumot is kidolgozni. Ekkor jöttek létre a COFF, ECOFF és más hasonló formátumok, amelyek elõbb-utóbb korlátokba ütköztek, még mielõtt a történelem megállapodott volna az ELF formátumnál.

Ráadásul a programok méretei egyre inkább kezdtek nõni, miközben a lemezek (valamint a fizikai memória) továbbra is viszonylag kicsik maradtak, ezért megszületett az osztott könyvtár ötlete, és a virtuális memóriát kezelõ alrendszer is sokat finomodott. Mivel ezek a különbözõ fejlesztések az [.filename]#a.out# formátumra épültek, annak használatósága a beletömött módosítások számával együtt romlott. Emellett az emberek még szerettek volna betölteni különféle dolgokat futási idõben dinamikusan, vagy éppen a memória és a lapozóállomány megspórolásához kipucolni a programjaik egyes részeit az inicializáló kódrészletek lefutása után. A programozási nyelvek is fejlõdtek, és az emberek a fõprogram futása elõtt is akartak kódot futtatni. Az [.filename]#a.out# formátum rengeteg apró foltozáson esett keresztül, amelyek egy ideig még tudták is tartani magukat. Azonban egy idõ után már az [.filename]#a.out# formátum egyre növekvõ teljesítménycsökkenés nélkül már nem volt képes állni a sarat. Habár az ELF megszüntette a fennálló problémák jelentõs részét, egyúttal megnehezítette egy alapvetõen mûködõ rendszer leváltását. Ezért az ELF formátumnak meg kellett várnia azt a pillanatot, amikorra az [.filename]#a.out# használata már kényelmetlenné vált.

Azonban ahogy múlt az idõ, az eszközökbõl, amelyekbõl a FreeBSD a fordításához szükséges eszközöket származtatta (különösen az assembler és a betöltõ),létrejött két párhuzamos fejlesztési fa. A FreeBSD-fa kiegészült az osztott könyvtárak támogatásával és hibákat javított, miközben a GNU-fa alkotói, akik eredetileg készítették ezeket a programokat, újraírták az eszközeiket és a keresztfordításhoz egyszerûbb támogatást készítettek, cserélhetõvé tették a különbözõ formátumokat és így tovább. Sokan akartak FreeBSD-re keresztfordítani, azonban nem volt szerencséjük, mert a FreeBSD régebbi forrásait az as és ld már nem emésztette meg. Az új GNU eszköztár (a binutils) viszont ismeri már a keresztfordítást, az ELF formátumot, az osztott könyvtárakat, a C++ kiterjesztéseit stb. Idõközben egyre több gyártó ELF formátumú binárisokat adott ki, és jó érzés volt ezeket FreeBSD-n is futtatni.

Az ELF sokkal kifejezõbb az [.filename]#a.out# formátumnál, és jóval több bõvítési lehetõséget enged az alaprendszerben. Az ELF formátumhoz tartozó eszközöket jobban karbantartják és támogatja a keresztfordítást, ami viszont sokaknak fontos. Az ELF talán némileg lassabb, mint az [.filename]#a.out#, azonban ez nehezen mérhetõ le. Számos részletben eltérnek ugyan, például hogyan képeznek le lapokat, hogyan kezelik az inicializáló kódot stb., de ezek egyike sem igazán fontos. Idõvel az [.filename]#a.out# támogatása ki fog kerülni a [.filename]#GENERIC# rendszermagból, és végül majd teljesen eltávolításra kerül, ahogy a régi [.filename]#a.out# formátumú programok szépen lassan kifutnak.

[[basics-more-information]]
== Bõvebben olvashatunk...

[[basics-man]]
=== Man oldalak

A FreeBSD legátfogóbb dokumentációja a benne található man oldalak összessége. A rendszerben található szinte majdnem mindegyik programhoz létezik egy rövid használati útmutató, amely bemutatja az adott program alapvetõ mûködését és a különbözõ beállításait. Ezek a leírások a `man` parancs segítségével jeleníthetõek meg. A `man` parancs használata egyszerû:

[source,shell]
....
% man parancs
....

ahol a `parancs` a megismerni kívánt parancsra utal. Például ha az `ls` parancsról szeretnénk többet megtudni, írjuk be:

[source,shell]
....
% man ls
....

Az elérhetõ használati útmutatókat a következõ számozott szakaszokra osztották:

. Felhasználói parancsok
. Rendszerhívások és hibakódok
. A C függvénykönyvtár függvényei
. Eszközmeghajtók
. Állományformátumok
. Játékok és egyéb szórakoztató alkalmazások
. Egyéb információk
. Rendszerkarbantartási és -mûködtetési parancsok
. Rendszermagfejlesztõk számára

Bizonyos esetekben ugyanaz a téma az útmutatók több szakaszában is elérhetõ. Például létezik `chmod` felhasználói parancs és a `chmod()` rendszerhívás. Ilyenkor a `man` parancsnak meg tudjuk adni pontosan, melyik szakaszra is vagyunk kíváncsiak:

[source,shell]
....
% man 1 chmod
....

Ennek hatására a `chmod` felhasználói parancshoz tartozó oldal jelenik meg. Írott formában a használati útmutatók különbözõ szakaszaira hagyományosan a név után zárójelbe tett számmal hivatkoznak, így a man:chmod[1] a `chmod` felhasználói parancs és a man:chmod[2] a rendszerhívás.

Ez a módszer remekül mûködik abban az esetben, amikor ismerjük a parancs nevét, azonban mit tegyünk akkor, ha nem is emlékszünk a nevére? A `man` parancs a `-k` segítségével paraméterezhetõ úgy is, hogy a parancsok leírásai között keressen valamilyen kulcsszó mentén:

[source,shell]
....
% man -k mail
....

Ezzel a paranccsal megkapjuk azon parancsok listáját, amelyek leírásában szerepel a "mail" kulcsszó. Ez egyébként mûködésében teljesen megegyezik a `apropos` paranccsal.

Szóval szeretnénk megtudni, hogy a [.filename]#/usr/bin# könyvtárban levõ parancsok pontosan mit is csinálnak? Ehhez írjuk be:

[source,shell]
....
% cd /usr/bin
% man -f *
....

vagy

[source,shell]
....
% cd /usr/bin
% whatis *
....

ami ugyanezt teszi.

[[basics-info]]
=== A GNU info állományok

A FreeBSD-ben megtalálható a Szabad Szoftver Alapítvány (Free Software Foundation, FSF) által készített számos alkalmazás. Ezek a programok a szokványos man oldalakon kívül még általában tartalmaznak egy ``info``nak nevezett, sokkal részletesebb hipertext alapú leírást is, amelyeket az `info` paranccsal, vagy ha van fenn emacs, akkor annak az info módjában tudjuk megjeleníteni.

Az man:info[1] parancs használatához ennyit kell beírnunk:

[source,shell]
....
% info
....

Itt a `h` lenyomásával kapunk egy rövid bemutatkozást. A parancsok rövid listáját a `?` billentyû hozza elõ.
