---
title: Κεφάλαιο 4. Βασικές Έννοιες στο UNIX®
part: Μέρος I. Ξεκινώντας με το FreeBSD
prev: books/handbook/install
next: books/handbook/ports
showBookMenu: true
weight: 6
path: "/books/handbook/basics/"
---

[[basics]]
= Βασικές Έννοιες στο UNIX(R)
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 4
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/basics/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[basics-synopsis]]
== Σύνοψη

Το ακόλουθο κεφάλαιο θα καλύψει τις βασικές εντολές και λειτουργίες του λειτουργικού συστήματος FreeBSD. Το μεγαλύτερο μέρος αυτής της ύλης σχετίζεται με όλα τα Λ.Σ. που είναι βασισμένα στο UNIX(R). Εάν η ύλη σας φαίνεται οικεία μπορείτε να διατρέξετε γρήγορα αυτό το κεφάλαιο. Εάν - αντιθέτως - είστε νέος στο FreeBSD τότε οπωσδήποτε θα πρέπει να διαβάσετε προσεκτικά ολόκληρο το κεφάλαιο.

Μετά την ανάγνωση του κεφαλαίου, θα γνωρίζετε:

* Πως να χρησιμοποιείτε τις "εικονικές κονσόλες" του FreeBSD.
* Πως λειτουργούν οι άδειες αρχείων στο UNIX(R) και θα καταλάβετε την χρήση των file flags στο FreeBSD.
* Την προεπιλεγμένη διάταξη του συστήματος αρχείων του FreeBSD.
* Την οργάνωση των δίσκων στο FreeBSD.
* Τι είναι και πώς λειτουργεί η προσάρτηση (mount) και αποπροσάρτηση (unmount) συστημάτων αρχείων.
* Τι είναι οι διεργασίες (processes), τα σήματα (signals) και οι δαίμονες (daemons).
* Τι είναι το κέλυφος (shell) και πως να αλλάζετε το προεπιλεγμένο περιβάλλον εργασίας.
* Πως να χρησιμοποιείτε βασικά προγράμματα επεξεργασίας κειμένου (editors).
* Τι είναι οι συσκευές (devices) και τα αρχεία συσκευής (device nodes).
* Ποια έκδοση εκτελέσιμων χρησιμοποιείται στο FreeBSD.
* Πως να διαβάζετε τις σελίδες βοηθείας (manual pages) για περισσότερες πληροφορίες.

[[consoles]]
== Εικονικές Κονσόλες και Τερματικά

Μπορείτε να χειριστείτε το FreeBSD με διάφορους τρόπους. Ένας από αυτούς, είναι πληκτρολογώντας εντολές κειμένου σε ένα τερματικό. Με αυτό τον τρόπο έχετε στα χέρια σας ένα ευέλικτο και δυνατό λειτουργικό σύστημα UNIX(R). Αυτή η ενότητα περιγράφει τι είναι τα "τερματικά" και οι "κονσόλες" και πως μπορούν να χρησιμοποιηθούν στο FreeBSD.

[[consoles-intro]]
=== Η Κονσόλα

Εάν δεν έχετε ρυθμίσει το FreeBSD να ξεκινά αυτόματα κάποιο γραφικό περιβάλλον εργασίας, τότε αμέσως μετά την εκκίνηση του συστήματος και την ολοκλήρωση των σεναρίων εκκίνησης (startup scripts) θα εμφανιστεί η προτροπή σύνδεσης (login prompt). Θα δείτε κάτι παρόμοιο στην οθόνη σας:

[source,shell]
....
Additional ABI support:.
Local package initialization:.
Additional TCP options:.

Fri Sep 20 13:01:06 EEST 2002

FreeBSD/i386 (pc3.example.org) (ttyv0)

login:
....

Το μήνυμα μπορεί να είναι λίγο διαφορετικό στο σύστημα σας, αλλά δεν πρέπει να διαφέρει κατά πολύ. Θα εστιάσουμε την προσοχή μας στις τελευταίες δύο γραμμές. Η προτελευταία γραμμή αναφέρει:

[.programlisting]
....
FreeBSD/i386 (pc3.example.org) (ttyv0)
....

Αυτή η γραμμή περιέχει μερικές πληροφορίες για το σύστημα που μόλις εκκινήσατε. Έχετε μπροστά σας μια κονσόλα "FreeBSD", που τρέχει με επεξεργαστή αρχιτεκτονικής x86 της Intel ή άλλον συμβατό . Το όνομα αυτής της μηχανής (όλες οι μηχανές UNIX(R) έχουν κάποιο όνομα) είναι `pc3.example.org`, και έχετε ανοικτό μπροστά σας το τερματικό [.filename]#ttyv0# - κονσόλα του συστήματος.

Ολοκληρώνοντας, η τελευταία γραμμή είναι πάντα:

[.programlisting]
....
login:
....

Σε αυτό το μέρος θα πρέπει να πληκτρολογήσετε το "όνομα χρήστη" (username) για να συνδεθείτε στο FreeBSD. Στην επόμενη ενότητα θα περιγράψουμε ακριβώς αυτήν την διαδικασία.

[[consoles-login]]
=== Εισαγωγή Χρήστη στο Σύστημα FreeBSD

Το FreeBSD είναι ένα σύστημα πολυχρηστικό (multiuser) και πολυεπεξεργαστικό (multiprocessing). Αυτός είναι ο ακαδημαϊκός ορισμός που δίνεται συνήθως σε ένα σύστημα που μπορεί να χρησιμοποιείται από πολλούς διαφορετικούς ανθρώπους, ενώ ταυτόχρονα τρέχουν διαφορετικά προγράμματα στην ίδια μηχανή.

Κάθε σύστημα multiuser χρειάζεται κάποιους τρόπους ώστε να ξεχωρίζει κάθε "χρήστη" από τους υπολοίπους. Στο FreeBSD (όπως και σε όλα τα Λ.Σ. που βασίζονται στο UNIX(R)), αυτό επιτυγχάνεται απαιτώντας κάθε χρήστης να "είναι συνδεδεμένος (log in)" πριν να μπορεί να τρέξει προγράμματα. Κάθε χρήστης έχει ξεχωριστό όνομα (το "όνομα χρήστη ή username") και μία προσωπική δικλείδα ασφαλείας, (τον "κωδικό πρόσβασης ή password"). Αυτά θα ζητηθούν από το FreeBSD σε κάθε χρήστη πριν να του επιτραπεί να τρέξει οποιαδήποτε εφαρμογή.

Αμέσως μετά την ολοκλήρωση των διεργασιών εκκίνησης του FreeBSD και των σεναρίων εκκίνησης (startup scripts) , θα εμφανιστεί το σύμβολο της προτροπής (prompt) και θα σας ζητηθεί ένα έγκυρο όνομα χρήστη:

[source,shell]
....
login:
....

Για παράδειγμα, ας υποθέσουμε πως το όνομα χρήστη σας είναι `john`. Πληκτρολογήστε `john` στην προτροπή και πατήστε kbd:[Enter]. Θα ακολουθήσει μια νέα προτροπή για να δώσετε τον "κωδικό πρόσβασης (password)":

[source,shell]
....
login: john
Password:
....

Πληκτρολογήστε τώρα τον κωδικό πρόσβασης του `john`, και πατήστε kbd:[Enter]. Ο κωδικός πρόσβασης _δεν είναι ορατός!_ Δεν χρειάζεται να ανησυχείτε για αυτό. Είναι επαρκές να πούμε πως αυτό συμβαίνει για λόγους ασφαλείας.

Αν έχετε πληκτρολογήσει σωστά τον κωδικό πρόσβασης, τότε έχετε συνδεθεί στο FreeBSD και είστε έτοιμοι να δοκιμάσετε όλες τις διαθέσιμες εντολές UNIX(R).

Πρέπει να δείτε το MOTD ή αλλιώς το ημερήσιο μήνυμα και στη συνέχεια την προτροπή εντολής (ένα χαρακτήρα `#`, `$`, ή `%`). Αυτό σημαίνει πως έχετε συνδεθεί επιτυχώς στο FreeBSD.

[[consoles-virtual]]
=== Πολλαπλές Κονσόλες

Η εκτέλεση εντολών UNIX(R) σε μία μόνο κονσόλα μπορεί να είναι ικανοποιητική, αλλά το FreeBSD μπορεί να τρέχει ταυτόχρονα πολλά προγράμματα. Η ύπαρξη μίας μόνο κονσόλας για πληκτρολόγηση εντολών θα ήταν πραγματικά ελλιπής για ένα Λ.Σ. όπως το FreeBSD που μπορεί να τρέχει ταυτόχρονα δεκάδες προγράμματα. Εδώ είναι που χρειάζονται οι "εικονικές κονσόλες".

Το FreeBSD μπορεί να ρυθμιστεί κατάλληλα ώστε να παρουσιάζεται με διάφορες εικονικές κονσόλες. Η εναλλαγή από μία εικονική κονσόλα σε οποιαδήποτε άλλη μπορεί να γίνει πατώντας μερικά πλήκτρα στο πληκτρολόγιο. Η κάθε κονσόλα έχει το δικό της κανάλι εξόδου, και καθώς εναλλάσσετε εικονικές κονσόλες το FreeBSD αποθηκεύει και επαναφέρει προσεκτικά το αντίστοιχο πληκτρολόγιο και οθόνη για κάθε κονσόλα σαν να υπήρχε πραγματική εναλλαγή.

Συνδυασμοί ειδικών πλήκτρων χρησιμοποιούνται από το FreeBSD για την εναλλαγή κονσολών . Μπορείτε να χρησιμοποιήσετε kbd:[Alt+F1], kbd:[Alt+F2],έως kbd:[Alt+F8] για να μεταβείτε στις διάφορες εικονικές κονσόλες του FreeBSD.

Καθώς εναλλάσσεστε από τη μία κονσόλα στην άλλη, το FreeBSD αποθηκεύει και επαναφέρει προσεκτικά την αντίστοιχη οθόνη. Το αποτέλεσμα είναι ένα "οπτικό τρικ" σαν να είχαμε πολλαπλές "εικονικές" οθόνες και πληκτρολόγια που θα μπορούσαμε να χρησιμοποιήσουμε για να τρέχουμε εντολές στο FreeBSD. Τα προγράμματα που τρέχετε από μια κονσόλα δεν σταματούν να λειτουργούν όταν η κονσόλα δεν είναι ορατή. Συνεχίζουν να τρέχουν κι όταν βρίσκεστε σε διαφορετική κονσόλα.

[[consoles-ttys]]
=== Το Αρχείο [.filename]#/etc/ttys#

Η εξ' ορισμού ρύθμιση του FreeBSD θα ξεκινήσει με οκτώ εικονικές κονσόλες. Δεν πρόκειται για μια πολύπλοκη ρύθμιση και μπορείτε εύκολα να την αλλάξετε ώστε να φορτώνονται περισσότερες ή λιγότερες εικονικές κονσόλες κατά την εκκίνηση. Το πλήθος και η παραμετροποίηση των εικονικών κονσολών ρυθμίζεται στο αρχείο [.filename]#/etc/ttys#.

Μπορείτε να χρησιμοποιήσετε το αρχείο [.filename]#/etc/ttys# για να ρυθμίσετε τις εικονικές κονσόλες στο FreeBSD. Κάθε γραμμή του αρχείου που δεν είναι σχόλιο (οι γραμμές που δεν ξεκινούν με τον χαρακτήρα `#`) περιέχουν ρυθμίσεις για ένα τερματικό ή για μια εικονική κονσόλα. Η προκαθορισμένη έκδοση του αρχείου, η οποία περιέχεται στην διανομή FreeBSD, περιέχει εννέα εικονικές κονσόλες, εκ των οποίων οι οκτώ είναι ενεργοποιημένες. Είναι στις γραμμές που ξεκινούν με `ttyv`:

[.programlisting]
....
# name  getty                           type    status          comments
#
ttyv0   "/usr/libexec/getty Pc"         cons25  on  secure
# Virtual terminals
ttyv1   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv2   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv3   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv4   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv5   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv6   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv7   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv8   "/usr/X11R6/bin/xdm -nodaemon"  xterm   off secure
....

Για μια λεπτομερή περιγραφή κάθε στήλης του αρχείου και όλων των ρυθμίσεων που μπορούν να εφαρμοστούν για τις εικονικές κονσόλες συμβουλευτείτε την σελίδα βοηθείας man:ttys[5].

[[consoles-singleuser]]
=== Κονσόλα σε Κατάσταση Ενός Χρήστη

Μπορείτε να βρείτε μια λεπτομερή περιγραφή για το τι είναι "κατάσταση ενός χρήστη" στην ενότητα crossref:boot[boot-singleuser,"Κατάσταση Λειτουργίας Ενός Χρήστη"]. Αξίζει να αναφέρουμε πως υπάρχει ενεργή μόνο μία κονσόλα όταν τρέχετε το FreeBSD σε κατάσταση ενός χρήστη. Δεν υπάρχουν διαθέσιμες εικονικές κονσόλες. Στο αρχείο [.filename]#/etc/ttys# μπορείτε να βρείτε τις ρυθμίσεις σε κατάσταση ενός χρήστη. Αναζητήστε την γραμμή που ξεκινά με `console`:

[.programlisting]
....
# name  getty                           type    status          comments
#
# If console is marked "insecure", then init will ask for the root password
# when going to single-user mode.
console none                            unknown off secure
....

[NOTE]
====
Όπως αναφέρουν τα σχόλια πάνω από το `console`, μπορείτε να επεξεργαστείτε αυτήν τη γραμμή και να αντικαταστήσετε την λέξη `secure` με `insecure`. Σε αυτή την περίπτωση κατά την εκκίνηση του FreeBSD σε κατάσταση ενός χρήστη, θα σας ζητηθεί ο κωδικός πρόσβασης του υπερχρήστη `root`.

__Προσέχετε όταν κάνετε την μετατροπή σε ``insecure``__. Εάν τύχει να ξεχάσετε τον κωδικό πρόσβασης του `root`, η πρόσβαση σε κατάσταση λειτουργίας ενός χρήστη μπορεί να γίνει δύσβατη. Υπάρχει ακόμη τρόπος να κάνετε εκκίνηση, αλλά ίσως να είναι δύσκολο για κάποιον που δεν γνωρίζει πολλά για τις διεργασίες και τα προγράμματα εκκίνησης του FreeBSD.
====

[[consoles-vidcontrol]]
=== Αλλάζοντας την Ανάλυση (video mode) της Κονσόλας

Η προεπιλεγμένη απεικόνιση της κονσόλας στο FreeBSD μπορεί να ρυθμιστεί σε ανάλυση 1024x768, 1280x1024, ή σε οποιοδήποτε άλλο μέγεθος υποστηρίζεται από την κάρτα γραφικών και την οθόνη σας. Για να χρησιμοποιήσετε διαφορετική ανάλυση, θα πρέπει πρώτα από όλα να επαναμεταγλωττίσετε τον πυρήνα σας, και να συμπεριλάβετε τις παρακάτω δύο επιλογές:

[.programlisting]
....
options VESA
options SC_PIXEL_MODE
....

Μετά τη μεταγλώττιση του πυρήνα με τις παραπάνω δύο επιλογές, μπορείτε να βρείτε ποιες αναλύσεις υποστηρίζονται από το υλικό σας, χρησιμοποιώντας το βοηθητικό πρόγραμμα man:vidcontrol[1]. Για να δείτε μια λίστα από τις υποστηριζόμενες αναλύσεις, δώστε την ακόλουθη εντολή:

[source,shell]
....
# vidcontrol -i mode
....

Η έξοδος της εντολής αυτής, είναι μια λίστα από αναλύσεις οθόνης που υποστηρίζονται από το υλικό σας. Μπορείτε έπειτα να επιλέξετε μια νέα ανάλυση, δίνοντας την ως όρισμα στην man:vidcontrol[1] σε μια κονσόλα που έχετε συνδεθεί ως `root`:

[source,shell]
....
# vidcontrol MODE_279
....

Αν η νέα ανάλυση γίνει δεκτή, μπορείτε να την ορίσετε ως προεπιλεγμένη για κάθε εκκίνηση, με την κατάλληλη ρύθμιση στο αρχείο [.filename]#/etc/rc.conf#:

[.programlisting]
....
allscreens_flags="MODE_279"
....

[[permissions]]
== Άδειες (Permissions)

Το FreeBSD είναι απόγονος του BSD UNIX(R), και για αυτό το λόγο βασίζεται σε μερικές έννοιες κλειδιά του UNIX(R). Η πρώτη και πιο σημαντική είναι πως το FreeBSD είναι ένα πολυχρηστικό (multiuser) λειτουργικό σύστημα. Το σύστημα μπορεί να εξυπηρετήσει πολλούς χρήστες που εργάζονται ταυτόχρονα και σε εντελώς ανεξάρτητες εφαρμογές. Το σύστημα είναι υπεύθυνο για τον σωστό διαμοιρασμό και τις ανάγκες διαχείρισης συσκευών hardware, περιφερειακών, μνήμης, και την σωστή κατανομή των πόρων της CPU για κάθε χρήστη.

Επειδή το σύστημα έχει την ικανότητα να εξυπηρετεί πολλούς χρήστες, σε οτιδήποτε διαχειρίζεται, υπάρχει μια ομάδα αδειών που ορίζει ποιος μπορεί να διαβάσει, να γράψει και να εκτελέσει αυτούς τους πόρους. Οι άδειες αποθηκεύονται σε οκτάδες διαχωρισμένες σε τρία μέρη, ένα για τον ιδιοκτήτη του αρχείου, ένα για την ομάδα στην οποία ανήκει το αρχείο, και ένα μέρος για όλους τους άλλους. Στη συνέχεια παρουσιάζεται πίνακας με τις αντιστοιχίες μεταξύ των ομάδων αδειών και των αριθμητικών τους τιμών.

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Τιμή
| Άδεια
| Εμφάνιση σε περιεχόμενα καταλόγων

|0
|Ανάγνωση:όχι, Εγγραφή:όχι, Εκτέλεση:όχι
|`---`

|1
|Ανάγνωση:όχι, Εγγραφή:όχι, Εκτέλεση:ναι
|`--x`

|2
|Ανάγνωση:όχι, Εγγραφή:ναι, Εκτέλεση:όχι
|`-w-`

|3
|Ανάγνωση:όχι, Εγγραφή:ναι, Εκτέλεση:ναι
|`-wx`

|4
|Ανάγνωση:ναι, Εγγραφή:όχι, Εκτέλεση:όχι
|`r--`

|5
|Ανάγνωση:ναι, Εγγραφή:όχι, Εκτέλεση:ναι
|`r-x`

|6
|Ανάγνωση:ναι, Εγγραφή:ναι, Εκτέλεση:όχι
|`rw-`

|7
|Ανάγνωση:ναι, Εγγραφή:ναι, Εκτέλεση:ναι
|`rwx`
|===

Μπορείτε να χρησιμοποιήσετε την εντολή man:ls[1] με πρόθεμα `-l` στην γραμμή εντολών για να δείτε τα περιεχόμενα καταλόγου και παρατηρήστε πως περιέχεται μια στήλη με τις άδειες των αρχείων για τον ιδιοκτήτη, την ομάδα, και για όλους τους άλλους. Για παράδειγμα, αν δώσουμε `ls -l` σε ένα τυχαίο κατάλογο:

[source,shell]
....
% ls -l
total 530
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 myfile
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 otherfile
-rw-r--r--  1 root  wheel    7680 Sep  5 12:31 email.txt
...
....

Η πρώτη στήλη που παίρνουμε με την εντολή `ls -l` διαχωρίζεται ως εξής:

[source,shell]
....
-rw-r--r--
....

Ο πρώτος χαρακτήρας (από τα αριστερά) μας ενημερώνει αν πρόκειται για ένα κανονικό αρχείο, κατάλογο, ειδική συσκευή χαρακτήρων, υποδοχέα (socket), ή οποιαδήποτε άλλo αρχείο ψευδο-συσκευής. Στην περίπτωση μας, το `-` υποδηλώνει ένα κανονικό αρχείο. Οι ακόλουθοι τρεις χαρακτήρες, στο παράδειγμα μας, `rw-`, ορίζουν τις άδειες για τον ιδιοκτήτη του αρχείου. Οι τρεις επόμενοι χαρακτήρες, `r--`, ορίζουν τις άδειες για την ομάδα στην οποία ανήκει το αρχείο. Οι τελευταίοι τρεις χαρακτήρες, `r--`, ορίζουν τις άδειες για τον υπόλοιπο κόσμο. Η παύλα σημαίνει πως η άδεια είναι απενεργοποιημένη. Στην περίπτωση του αρχείου μας, οι άδειες έχουν οριστεί ώστε ο ιδιοκτήτης να μπορεί να διαβάζει και να γράφει στο αρχείο, η ομάδα να μπορεί να διαβάσει το αρχείο, και ο υπόλοιπος κόσμος να μπορεί μόνο να διαβάσει το αρχείο. Σύμφωνα με τον παραπάνω πίνακα, οι άδειες για αυτό το αρχείο είναι `644`, όπου καθένα από τα τρία ψηφία παρουσιάζει το αντίστοιχο μέρος αδειών του αρχείου.

Μέχρι εδώ είναι όλα καλά, αλλά όμως πως το σύστημα ελέγχει τις άδειες συσκευών; Το FreeBSD μεταχειρίζεται τις περισσότερες συσκευές σαν ένα αρχείο το οποίο τα προγράμματα μπορούν να ανοίξουν, να διαβάσουν και να γράψουν σε αυτό σαν να ήταν ένα οποιοδήποτε αρχείο. Αυτά τα ειδικά αρχεία συσκευών αποθηκεύονται στον κατάλογο [.filename]#/dev#.

Το σύστημα μεταχειρίζεται επίσης και τους καταλόγους ως αρχεία. Έχουν άδειες ανάγνωσης, εγγραφής και εκτέλεσης. Το bit που ορίζει την εκτέλεση στους καταλόγους έχει ελαφρώς διαφορετικό νόημα από ότι στα αρχεία. Όταν ένας κατάλογος έχει οριστεί εκτελέσιμος, σημαίνει πως είναι προσπελάσιμος, δηλαδή είναι επιτρεπτό να περάσουμε σε ένα υποκατάλογο του (να κάνουμε "cd"). Αυτό επίσης σημαίνει πως επιτρέπεται η πρόσβαση σε όλα τα γνωστά (αυτό έχει να κάνει με τις άδειες των ίδιων των αρχείων) αρχεία.

Ειδικότερα, για να εμφανίζονται τα περιεχόμενα καταλόγου πρέπει να έχει τεθεί άδεια ανάγνωσης (read) στον κατάλογο, ενώ για να διαγραφεί ένα αρχείο του οποίου γνωρίζετε το όνομα είναι αναγκαίο να έχουν δοθεί οι άδειες εγγραφής (write) _και_ εκτέλεσης (execute) στον κατάλογο που περιέχει το αρχείο.

Υπάρχουν κι άλλα bit αδειών, αλλά χρησιμοποιούνται κυρίως σε ειδικές περιπτώσεις όπως σε setuid binaries και sticky directories. Αν θέλετε περισσότερες πληροφορίες για τις άδειες αρχείων και πως να τις ορίζετε, συμβουλευτείτε οπωσδήποτε την σελίδα manual man:chmod[1].

=== Συμβολικές Άδειες

Οι συμβολικές άδειες, μερικές φορές αναφέρονται και ως συμβολικές εκφράσεις, χρησιμοποιούν χαρακτήρες στην θέση των οκτώ τιμών για να θέτουν άδειες σε αρχεία ή καταλόγους. Οι συμβολικές εκφράσεις χρησιμοποιούν την σύνταξη (ποιος) (ενέργεια) (άδειες), όπου είναι διαθέσιμες οι ακόλουθες τιμές:

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Επιλογή
| Γράμμα
| Σημαίνει

|(ποιος)
|u
|User (Χρήστης)

|(ποιος)
|g
|Group owner (Ομάδα που ανήκει)

|(ποιος)
|o
|Other (Υπόλοιποι χρήστες)

|(ποιος)
|a
|All (όλοι, "world")

|(ενέργεια)
|+
|Πρόσθεση αδειών

|(ενέργεια)
|-
|Αφαίρεση αδειών

|(ενέργεια)
|=
|Άμεσος ορισμός αδειών

|(άδειες)
|r
|Read (Ανάγνωση)

|(άδειες)
|w
|Write (Εγγραφή)

|(άδειες)
|x
|Execute (Εκτέλεση)

|(άδειες)
|t
|Sticky bit

|(άδειες)
|s
|Set UID ή GID
|===

Οι τιμές εισάγονται με την εντολή man:chmod[1] όπως πριν, αλλά με γράμματα. Για παράδειγμα, θα μπορούσατε να χρησιμοποιήσετε την ακόλουθη εντολή για να απαγορεύσετε σε άλλους χρήστες την πρόσβαση στο _FILE_:

[source,shell]
....
% chmod go= FILE
....

Μπορούν να γίνουν πάνω από μία αλλαγές στις άδειες ενός αρχείου ταυτόχρονα διαχωρίζοντας τις αλλαγές με κόμμα. Για παράδειγμα, η ακόλουθη εντολή θα αφαιρέσει στην ομάδα και στον "υπόλοιπο κόσμο" την άδεια εγγραφής, και στη συνέχεια θα προσθέσει άδεια εκτέλεσης σε όλους.

[source,shell]
....
% chmod go-w,a+x FILE
....

=== FreeBSD File Flags

Πέρα από τις άδειες αρχείων που συζητήθηκαν πριν από λίγο, το FreeBSD υποστηρίζει την χρήση των "file flags." Αυτά τα flags προσθέτουν ένα επιπρόσθετο επίπεδο ασφαλείας και ελέγχου σε αρχεία, αλλά όχι σε καταλόγους.

Αυτά τα flags προσθέτουν ένα πρόσθετο επίπεδο ελέγχου σε αρχεία, διασφαλίζοντας μας πως σε κάποιες περιπτώσεις ακόμη κι ο `root` να μην μπορεί να διαγράψει ή να μετατρέψει αρχεία.

Η μετατροπή των file flags γίνεται με την man:chflags[1], χρησιμοποιώντας μια απλή διασύνδεση. Για παράδειγμα, για να ενεργοποιήσουμε το flag του συστήματος μη διαγραφής αρχείου στο αρχείο [.filename]#file1#, δίνουμε την ακόλουθη εντολή:

[source,shell]
....
# chflags sunlink file1
....

Για να απενεργοποιήσουμε το flag του συστήματος μη διαγραφής αρχείου, απλά δίνουμε την προηγούμενη εντολή με "no" μπροστά από το `sunlink`. Παρατηρήστε:

[source,shell]
....
# chflags nosunlink file1
....

Για να δείτε τα flags ενός αρχείου, χρησιμοποιήστε την εντολή man:ls[1] με το πρόθεμα `-lo`:

[source,shell]
....
# ls -lo file1
....

Στην έξοδο θα πρέπει να δείτε κάτι παρόμοιο με το ακόλουθο:

[.programlisting]
....
-rw-r--r--  1 trhodes  trhodes  sunlnk 0 Mar  1 05:54 file1
....

Μερικά flags μπορούν να προστεθούν ή να αφαιρεθούν μόνο από τον χρήστη `root`. Στις υπόλοιπες περιπτώσεις, ο ιδιοκτήτης του αρχείου μπορεί να θέσει αυτά τα flags. Προτείνουμε στους διαχειριστές να διαβάσουν τις σελίδες βοηθείας man:chflags[1] και man:chflags[2] για περισσότερες πληροφορίες.

=== Οι Άδειες setuid, setgid και sticky

Εκτός από τις άδειες που έχουμε συζητήσει ήδη, υπάρχουν τρεις ακόμα τις οποίες κάθε διαχειριστής πρέπει να γνωρίζει. Πρόκειται για τις άδειες `setuid`, `setgid` και `sticky`.

Οι παραπάνω είναι σημαντικές για κάποιες λειτουργίες στο UNIX(R), καθώς παρέχουν λειτουργίες που δεν είναι φυσιολογικά διαθέσιμες στους κοινούς χρήστες. Για να τις κατανοήσετε, θα πρέπει πρώτα να καταλάβετε την διαφορά μεταξύ του πραγματικού αναγνωριστικού χρήστη (real user ID) και του ενεργού αναγνωριστικού χρήστη (effective user ID).

Το πραγματικό ID του χρήστη, είναι το UID στο οποίο ανήκει, ή με το οποίο ξεκινά, μια διεργασία. Το ενεργό UID, είναι το αναγνωριστικό χρήστη το οποίο εκτελεί την διεργασία. Για παράδειγμα, το βοηθητικό πρόγραμμα man:passwd[1] εκτελείται με το πραγματικό ID του χρήστη που αλλάζει τον κωδικό του. Ωστόσο, για να μπορεί να διαχειριστεί την βάση δεδομένων με τους κωδικούς του συστήματος, το πρόγραμμα αυτό χρησιμοποιεί ως ενεργό ID αυτό του χρήστη `root`. Με αυτό τον τρόπο, επιτρέπεται στους απλούς χρήστες να αλλάζουν τους κωδικούς τους χωρίς να παίρνουν το μήνυμα λάθους `Permission Denied` (απαγόρευση πρόσβασης).

[NOTE]
====
Η επιλογή `nosuid` στην εντολή man:mount[8] θα προκαλέσει αποτυχία εκτέλεσης αυτών των εντολών, και μάλιστα χωρίς κάποιο μήνυμα λάθους. Με λίγα λόγια, η εκτέλεση τους θα αποτύχει, και ο χρήστης δεν θα ενημερωθεί για αυτό. Η επιλογή αυτή δεν είναι επίσης απόλυτα ασφαλής, καθώς (σύμφωνα με τη σελίδα manual man:mount[8]) υπάρχει τρόπος να παρακαμφθεί μέσω κάποιου ενδιάμεσου `nosuid` προγράμματος (wrapper).
====

Μπορείτε να καθορίσετε την άδεια setuid, τοποθετώντας τον αριθμό τέσσερα (4) μπροστά από το γενικό σετ των αδειών, όπως φαίνεται στο ακόλουθο παράδειγμα:

[source,shell]
....
# chmod 4755 suidexample.sh
....

Οι άδειες στο αρχείο [.filename]#suidexample.sh# θα φαίνονται τώρα όπως παρακάτω:

[.programlisting]
....
-rwsr-xr-x   1 trhodes  trhodes    63 Aug 29 06:36 suidexample.sh
....

Παρατηρήστε στο παράδειγμα, ότι το `s` είναι πλέον μέλος του συνόλου αδειών που έχουν καθοριστεί για τον ιδιοκτήτη του αρχείου, και έχει αντικαταστήσει την αντίστοιχη άδεια εκτέλεσης. Με τον τρόπο αυτό λειτουργούν προγράμματα που χρειάζονται αυξημένα δικαιώματα, όπως για παράδειγμα η εντολή `passwd`.

Για να παρατηρήσετε αυτή τη λειτουργία την ώρα που συμβαίνει, ανοίξτε δύο τερματικά. Στο πρώτο, ξεκινήστε την εντολή `passwd` ως κανονικός χρήστης. Καθώς η εντολή εκτελείται και περιμένει για την εισαγωγή του νέου κωδικού, ελέγξτε τον πίνακα διεργασιών και αναζητήστε τις πληροφορίες του χρήστη που εκτελεί την εντολή `passwd`.

Στο τερματικό Α:

[source,shell]
....
Changing local password for trhodes
Old Password:
....

Στο τερματικό Β:

[source,shell]
....
# ps aux | grep passwd
....

[source,shell]
....
trhodes  5232  0.0  0.2  3420  1608   0  R+    2:10AM   0:00.00 grep passwd
root     5211  0.0  0.2  3620  1724   2  I+    2:09AM   0:00.01 passwd
....

Όπως είπαμε παραπάνω, η εντολή `passwd` εκτελείται από ένα κανονικό χρήστη, αλλά χρησιμοποιεί το ενεργό UID του χρήστη `root`.

Η άδεια `setgid` εκτελεί την ίδια λειτουργία όπως και η `setuid`, αλλά επιδρά στις άδειες της ομάδας (group). Όταν εκτελέσετε μια τέτοια εφαρμογή ή βοηθητικό πρόγραμμα, θα χρησιμοποιεί τις άδειες της ομάδας στην οποία ανήκει το αρχείο, και όχι του χρήστη που την ξεκίνησε.

Για να θέσετε την άδεια `setgid` σε ένα αρχείο, θα πρέπει να τοποθετήσετε τον αριθμό δύο (2) μπροστά από το σύνολο αδειών, στην εντολή `chmod`. Δείτε το παρακάτω παράδειγμα:

[source,shell]
....
# chmod 2755 sgidexample.sh
....

Όπως και πριν, θα παρατηρήσετε τη νέα άδεια `s`, αλλά αυτή τη φορά στο σετ των αδειών της ομάδας:

[source,shell]
....
-rwxr-sr-x   1 trhodes  trhodes    44 Aug 31 01:49 sgidexample.sh
....

[NOTE]
====
Στα παραδείγματα μας, αν και το αρχείο είναι ένα εκτελέσιμο script για κέλυφος, δεν θα εκτελεστεί με διαφορετικό ενεργό ID (EUID). Αυτό συμβαίνει γιατί σε αυτά τα scripts δεν επιτρέπεται η πρόσβαση στις κλήσεις man:setuid[2] του συστήματος.
====

Οι δύο πρώτες ειδικές άδειες που αναφέραμε, οι `setuid` και `setgid`, ενδεχομένως να μειώσουν την ασφάλεια του συστήματος, αφού επιτρέπουν σε προγράμματα να εκτελούνται με αυξημένα δικαιώματα. Υπάρχει ωστόσο μια τρίτη ειδική άδεια, η οποία μπορεί να αυξήσει την ασφάλεια του συστήματος: το `sticky bit`.

Όταν θέσετε το `sticky bit` σε ένα κατάλογο, επιτρέπεται η διαγραφή ενός αρχείου μόνο από τον ιδιοκτήτη του. Η άδεια αυτή είναι χρήσιμη για να αποφεύγεται η διαγραφή ενός αρχείου από κοινόχρηστους καταλόγους, όπως για παράδειγμα ο [.filename]#/tmp#, από κάποιο χρήστη που δεν είναι ο ιδιοκτήτης του. Για να θέσετε αυτή την άδεια, τοποθετήστε τον αριθμό ένα (1) στην αρχή του σετ αδειών:

[source,shell]
....
# chmod 1777 /tmp
....

Μπορείτε τώρα να δείτε το αποτέλεσμα, χρησιμοποιώντας την εντολή `ls`:

[source,shell]
....
# ls -al / | grep tmp
....

[source,shell]
....
drwxrwxrwt  10 root  wheel         512 Aug 31 01:49 tmp
....

Η άδεια `sticky bit` φαίνεται ως `t` στο τέλος του συνόλου των αδειών.

[[dirstructure]]
== Δομή Καταλόγου

Η ιεραρχική δομή του FreeBSD είναι ένα βασικό στοιχείο που πρέπει να γνωρίζετε αν θέλετε να έχετε μια ολοκληρωμένη εικόνα του συστήματος. Η πιο σημαντική έννοια είναι αυτή του ριζικού (root) καταλόγου, "/". Αυτός ο κατάλογος προσαρτάται (mount) πρώτος κατά την εκκίνηση και περιέχει το βασικό σύστημα ικανό να ετοιμάσει το Λ.Σ. για λειτουργία multi-user. Ο root κατάλογος περιέχει επίσης σημεία προσάρτησης για άλλα συστήματα αρχείων που προσαρτώνται κατά την μετάβαση σε κατάσταση λειτουργίας multi-user.

Σημείο προσάρτησης (mount point) είναι ένας κατάλογος στον οποίο μπορούν να αναπτυχθούν πρόσθετα συστήματα αρχείων σε ένα γονικό σύστημα αρχείων (συνήθως στο root σύστημα αρχείων). Αυτό περιγράφεται αναλυτικά στην ενότητα <<disk-organization>>. Στα στάνταρντ σημεία προσάρτησης περιλαμβάνονται: οι [.filename]#/usr#, [.filename]#/var#, [.filename]#/tmp#, [.filename]#/mnt#, και [.filename]#/cdrom#. Αυτοί οι κατάλογοι συνήθως είναι καταχωρημένοι στο αρχείο [.filename]#/etc/fstab#. Το [.filename]#/etc/fstab# είναι ένας πίνακας αντιστοιχίας διαφόρων συστημάτων αρχείων και σημείων προσάρτησης για αναφορά στο σύστημα. Τα περισσότερα συστήματα που αναφέρονται στο [.filename]#/etc/fstab# προσαρτώνται αυτόματα κατά την εκκίνηση του συστήματος από το script man:rc[8] εκτός αν περιέχεται η επιλογή `noauto`. Λεπτομέρειες μπορείτε να βρείτε στο <<disks-fstab>>.

Μια πλήρη περιγραφή της ιεραρχίας του συστήματος αρχείων είναι διαθέσιμη στο man:hier[7]. Ακολουθεί μια σύντομη ανασκόπηση με τους πιο συνήθεις καταλόγους.

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Κατάλογος
| Περιγραφή

|[.filename]#/#
| Ριζικός (root) κατάλογος του συστήματος αρχείων.

|[.filename]#/bin/#
|Χρήσιμα εργαλεία για περιβάλλον ενός ή πολλαπλών χρηστών.

|[.filename]#/boot/#
|Προγράμματα και αρχεία ρυθμίσεων που χρησιμοποιούνται κατά την εκκίνηση του λειτουργικού συστήματος.

|[.filename]#/boot/defaults/#
|Προκαθορισμένα αρχεία ρυθμίσεων εκκίνησης, δείτε man:loader.conf[5].

|[.filename]#/dev/#
|Αρχεία συσκευών, δείτε man:intro[4].

|[.filename]#/etc/#
|Αρχεία ρυθμίσεων συστήματος και σενάρια εκκίνησης. 

|[.filename]#/etc/defaults/#
|Προκαθορισμένα αρχεία ρυθμίσεων συστήματος, δείτε την man:rc[8].

|[.filename]#/etc/mail/#
|Αρχεία ρυθμίσεων για πράκτορες μεταφοράς ηλεκτρ. ταχυδρομείου (ΜΤΑ) όπως το man:sendmail[8].

|[.filename]#/etc/namedb/#
|Αρχεία ρυθμίσεων `named`, δείτε man:named[8].

|[.filename]#/etc/periodic/#
|Σενάρια λειτουργιών που τρέχουν σε ημερήσια, εβδομαδιαία, και μηνιαία βάση, man:cron[8]; δείτε man:periodic[8].

|[.filename]#/etc/ppp/#
|Αρχεία ρυθμίσεων `ppp`, δείτε τις man:ppp[8].

|[.filename]#/mnt/#
|Κενός κατάλογος που συνήθως χρησιμοποιείται από τους διαχειριστές συστημάτων ως προσωρινό σημείο προσάρτησης.

|[.filename]#/proc/#
|Σύστημα αρχείων διεργασιών, δείτε τις man:procfs[5], man:mount_procfs[8].

|[.filename]#/rescue/#
|Προγράμματα με στατική σύνδεση (static link) για ασφαλή επαναφορά συστήματος, δείτε την man:rescue[8].

|[.filename]#/root/#
|Προσωπικός κατάλογος του χρήστη `root`.

|[.filename]#/sbin/#
|Προγράμματα συστήματος και χρήσιμα εργαλεία διαχείρισης για περιβάλλον ενός ή πολλαπλών χρηστών.

|[.filename]#/tmp/#
|Προσωρινά αρχεία. Τα περιεχόμενα του [.filename]#/tmp# συνήθως δεν διατηρούνται μετά από επανεκκίνηση του συστήματος. Στο [.filename]#/tmp# συνήθως προσαρτάται ένα σύστημα αρχείων μνήμης. Αυτό μπορεί να επιτευχθεί αυτομάτως χρησιμοποιώντας τις σχετικές μεταβλητές tmpmfs του man:rc.conf[5] (ή με μια καταχώρηση στον [.filename]#/etc/fstab#, δείτε την man:mdmfs[8]).

|[.filename]#/usr/#
|Περιέχονται σχεδόν όλα τα βοηθητικά προγράμματα και οι εφαρμογές χρηστών.

|[.filename]#/usr/bin/#
|Κοινόχρηστα βοηθητικά προγράμματα, εργαλεία προγραμματισμού, και εφαρμογές.

|[.filename]#/usr/include/#
|Στάνταρ αρχεία συμπερίληψης C (include files).

|[.filename]#/usr/lib/#
|Αρχεία βιβλιοθηκών.

|[.filename]#/usr/libdata/#
|Διάφορα αρχεία δεδομένων βοηθητικών προγραμμάτων.

|[.filename]#/usr/libexec/#
|Δαίμονες συστήματος & βοηθητικά προγράμματα συστήματος (εκτελούνται από άλλα προγράμματα).

|[.filename]#/usr/local/#
|Τοπικά εκτελέσιμα, βιβλιοθήκες, κτλ. Επίσης είναι και ο προκαθορισμένος προορισμός για προγράμματα που εγκαθίστανται από τα ports του FreeBSD. Μέσα στον [.filename]#/usr/local#, χρησιμοποιείται γενικά η διάταξη του [.filename]#/usr# που περιγράφεται στο man:hier[7]. Εξαιρούνται οι κατάλογοι σελίδων βοηθείας man, που βρίσκεται άμεσα κάτω από τον [.filename]#/usr/local# και όχι κάτω από τον [.filename]#/usr/local/share#, καθώς και η τεκμηρίωση κάθε port που βρίσκεται στον [.filename]#share/doc/port#.

|[.filename]#/usr/obj/#
|Δέντρο προορισμού που εξαρτάται από την αρχιτεκτονική του μηχανήματος και παράγεται μεταγλωττίζοντας το δέντρο [.filename]#/usr/src#.

|[.filename]#/usr/ports/#
|Η Συλλογή Ports του FreeBSD (προαιρετικό).

|[.filename]#/usr/sbin/#
|Δαίμονες συστήματος & βοηθητικά προγράμματα συστήματος (εκτελούνται από χρήστες).

|[.filename]#/usr/shared/#
|Αρχεία ανεξάρτητα από την Αρχιτεκτονική του μηχανήματος.

|[.filename]#/usr/src/#
|Αρχεία BSD και/ή τοπικά αρχεία πηγαίου κώδικα.

|[.filename]#/usr/X11R6/#
|Εκτελέσιμα, βιβλιοθήκες, κτλ. για την διανομή X11R6 (προαιρετικό).

|[.filename]#/var/#
|Αρχεία αναφοράς (log) διαφόρων χρήσεων, temporary, transient, και spool. Μερικές φορές προσαρτάται στον [.filename]#/var# ένα σύστημα αρχείων μνήμης. Αυτό μπορεί να επιτευχθεί αυτόματα χρησιμοποιώντας τις σχετικές μεταβλητές varmfs του man:rc.conf[5] (ή με μία καταχώρηση στο [.filename]#/etc/fstab#, δείτε τις man:mdmfs[8]).

|[.filename]#/var/log/#
|Διάφορα αρχεία συμβάντων του συστήματος.

|[.filename]#/var/mail/#
|Αρχεία γραμματοκιβωτίου (mailbox) χρηστών.

|[.filename]#/var/spool/#
|Διάφοροι κατάλογοι παροχέτευσης (spool) εκτυπωτών και ηλεκτρονικής αλληλογραφίας του συστήματος.

|[.filename]#/var/tmp/#
|Προσωρινά (temporary) αρχεία. Τα αρχεία αυτά συνήθως διατηρούνται κατά την διάρκεια επανεκκίνησης του συστήματος, εκτός αν ο [.filename]#/var# είναι ένα σύστημα αρχείων μνήμης.

|[.filename]#/var/yp/#
|Απεικονίσεις (maps) NIS.
|===

[[disk-organization]]
== Οργάνωση Δίσκου

Η μικρότερη μονάδα οργάνωσης που χρησιμοποιεί το FreeBSD για να βρει αρχεία είναι το όνομα αρχείου. Τα ονόματα αρχείων είναι ευαίσθητα στα κεφαλαία- μικρά, το οποίο σημαίνει ότι το [.filename]#readme.txt# και το [.filename]#README.TXT# είναι δύο διαφορετικά αρχεία. Το FreeBSD δεν χρησιμοποιεί την επέκταση [.filename]#.txt# αρχείου για να προσδιορίσει αν ένα αρχείο είναι πρόγραμμα, ή έγγραφο, ή άλλος τύπος δεδομένων.

Τα αρχεία αποθηκεύονται σε καταλόγους. Ένας κατάλογος μπορεί να μην περιέχει αρχεία, ή μπορεί να περιέχει εκατοντάδες αρχεία. Ένας κατάλογος μπορεί επίσης να περιέχει άλλους καταλόγους, επιτρέποντας σας να κατασκευάσετε μια ιεραρχική δομή καταλόγων όπου κατάλογοι εσωκλείουν άλλους καταλόγους. Αυτό μας επιτρέπει να οργανώσουμε τα δεδομένα μας πολύ ευκολότερα.

Η αναφορά σε αρχεία και καταλόγους γίνεται δίνοντας το όνομα αρχείου ή το όνομα καταλόγου, ακολουθεί μία αριστερόστροφη κάθετος, `/` και έπειτα οποιοδήποτε άλλο κατάλληλο όνομα καταλόγου. Εάν έχετε τον κατάλογο [.filename]#foo#, ο οποίος περιέχει τον κατάλογο [.filename]#bar#, ο οποίος περιέχει το αρχείο [.filename]#readme.txt#, τότε το ολοκληρωμένο όνομα, _διαδρομή (path)_ στο αρχείο είναι [.filename]#foo/bar/readme.txt#.

Κατάλογοι και αρχεία αποθηκεύονται σε ένα σύστημα αρχείων. Κάθε σύστημα αρχείων περιέχει ένα κατάλογο στο ανώτερο επίπεδο, που ονομάζεται _root (ριζικός) κατάλογος_ για το συγκεκριμένο σύστημα αρχείων. Ο root κατάλογος μπορεί να περιέχει άλλους καταλόγους.

Αυτό πιθανώς είναι παρόμοιο με οποιοδήποτε άλλο λειτουργικό σύστημα έχετε χρησιμοποιήσει. Ωστόσο υπάρχουν μερικές διαφορές. Για παράδειγμα, το MS-DOS(R) χρησιμοποιεί `\` για να διαχωρίζει ονόματα καταλόγων και αρχείων, ενώ το Mac OS(R) χρησιμοποιεί `:`.

Το FreeBSD δεν χρησιμοποιεί γράμματα οδηγών ή ονόματα οδηγών στη διαδρομή. Επομένως δεν θα πρέπει να γράφετε [.filename]#c:/foo/bar/readme.txt# στο FreeBSD.

Αντιθέτως, ένα σύστημα αρχείων καθορίζεται ως root σύστημα αρχείων. Ο ριζικός κατάλογος του root συστήματος αρχείων αναφέρεται ως `/`. Κάθε άλλο σύστημα αρχείου _προσαρτάται_ κάτω από το root σύστημα αρχείων Δεν έχει σημασία πόσους δίσκους έχετε στο FreeBSD σύστημα σας, κάθε κατάλογος εμφανίζεται να είναι μέρος του ίδιου δίσκου.

Ας υποθέσουμε πως έχετε τρία συστήματα αρχείων, τα ονομάζουμε `A`, `B` και `C`. Κάθε σύστημα αρχείου έχει έναν ριζικό κατάλογο, ο οποίος περιέχει δύο άλλους καταλόγους, που τους ονομάζουμε `A1`, `A2` (και παρομοίως `B1`, `B2` και `C1`, `C2`).

Ας θεωρήσουμε ότι το `A` είναι το root σύστημα αρχείων. Αν χρησιμοποιήσετε την εντολή `ls` για να δείτε τα περιεχόμενα αυτού του καταλόγου, θα δείτε δύο υποκαταλόγους, `A1` και `A2`. Το δέντρο του καταλόγου μοιάζει σαν αυτό:

image::example-dir1.png[]

Κάθε σύστημα αρχείων πρέπει να προσαρτάται σε ένα κατάλογο διαφορετικού συστήματος αρχείων. Ας υποθέσουμε πως θέλετε να προσαρτήσετε το σύστημα αρχείου `B` στον `κατάλογο A1`. Ο ριζικός κατάλογος του `B` αντικαθιστά τον `A1`, και οι κατάλογοι του `B` εμφανίζονται αναλόγως:

image::example-dir2.png[]

Όλα τα αρχεία που περιέχονται στους καταλόγους `B1` και `B2` τα βρίσκουμε με τη διαδρομή [.filename]#/A1/B1# ή με [.filename]#/A1/B2# αντίστοιχα. Όλα τα αρχεία που βρίσκονταν στο [.filename]#/A1# είναι προσωρινά κρυμμένα. Θα επανεμφανιστούν όταν ο `B` θα _αποπροσαρτηθεί_ από τον A.

Αν ο `B` είχε προσαρτηθεί στον `A2` τότε το διάγραμμα θα έδειχνε κάπως έτσι:

image::example-dir3.png[]

και οι διαδρομές θα ήταν [.filename]#/A2/B1# και [.filename]#/A2/B2# αντίστοιχα.

Τα συστήματα αρχείων μπορούν να προσαρτώνται στην κορυφή άλλων συστημάτων. Συνεχίζοντας το τελευταίο παράδειγμα, το σύστημα αρχείου `C` θα μπορούσε να προσαρτηθεί στην κορυφή του καταλόγου `B1` στο σύστημα αρχείου `B`, οδηγώντας σε αυτήν την κατανομή:

image::example-dir4.png[]

Ή ακόμη το `C` θα μπορούσε να προσαρτηθεί άμεσα στο σύστημα αρχείου `A`, κάτω από τον κατάλογο `A1`:

image::example-dir5.png[]

Αν γνωρίζετε το σύστημα MS-DOS(R), είναι παρόμοιο, αλλά όχι ακριβώς το ίδιο, με την εντολή `join`.

Αυτό συνήθως δεν είναι κάτι που πρέπει να γνωρίζετε άμεσα. Τυπικά, εσείς δημιουργείτε συστήματα αρχείων όταν εγκαθιστάτε το FreeBSD και αποφασίζετε το σημείο προσάρτησης αυτών, και έπειτα δεν χρειάζεται να τα αλλάξετε εκτός αν πρόκειται να προσθέσετε ένα καινούργιο δίσκο.

Είναι απόλυτα δυνατόν να έχετε ένα μεγάλο root σύστημα αρχείων, και να μην χρειάζεται να δημιουργήσετε άλλα. Με αυτή την τακτική υπάρχουν μερικά μειονεκτήματα και ένα πλεονέκτημα.

.Προτερήματα Πολλαπλών Συστημάτων Αρχείων
* Διαφορετικά συστήματα αρχείων μπορούν να έχουν διαφορετικές _επιλογές προσάρτησης_. Για παράδειγμα, με προσεκτικό σχεδιασμό, το root σύστημα αρχείων μπορεί να προσαρτηθεί μόνο για ανάγνωση, ώστε να είναι αδύνατη η διαγραφή ή η μετατροπή κάποιου σημαντικού αρχείου. Διαχωρίζοντας συστήματα αρχείων με δυνατότητα εγγραφής από τον χρήστη, όπως ο [.filename]#/home#, επιτρέπει επίσης την προσάρτηση τους ως _nosuid_. Αυτή η επιλογή περιορίζει την χρήση εκτελέσιμων που είναι αποθηκευμένα στο σύστημα αρχείων, με ενεργοποιημένα τα bits _suid_/_guid_, βελτιώνοντας πιθανώς την ασφάλεια.
* Ανάλογα με το πως θα χρησιμοποιηθεί το σύστημα αρχείων, το FreeBSD ρυθμίζει με τον καλύτερο τρόπο την διάταξη των αρχείων στο σύστημα. Επομένως ένα σύστημα που περιέχει πολλά μικρά αρχεία που μεταβάλλονται συχνά, θα έχει διαφορετική διάταξη από ένα άλλο που περιέχει λιγότερα σε αριθμό, αλλά πιο ογκώδη αρχεία. Εάν έχετε ένα μοναδικό σύστημα αρχείων, τότε χάνετε αυτή τη δυνατότητα.
* Τα συστήματα αρχείων του FreeBSD είναι πολύ ισχυρά. Ωστόσο, μια αδυναμία σε κάποιο σημαντικό σημείο μπορεί ακόμη να οδηγήσει σε κατάρρευση της δομής του συστήματος αρχείων. Ο διαχωρισμός των δεδομένων σας σε πολλαπλά συστήματα αρχείων κάνει πιο εύκολη μια πιθανή επαναφορά από backup, όταν αυτό είναι αναγκαίο.

.Προτερήματα ενός Μονοκόμματου Συστήματος Αρχείου
* Τα συστήματα αρχείων είναι συγκεκριμένου σταθερού μεγέθους. Αν δημιουργήσετε ένα σύστημα αρχείων κατά την εγκατάσταση του FreeBSD και του δώσετε ένα ορισμένο μέγεθος, μπορεί αργότερα να ανακαλύψετε πως χρειάζεστε να φτιάξετε μια μεγαλύτερη κατάτμηση. Αυτό δεν είναι εύκολα πραγματοποιήσιμο δίχως backup, αναδημιουργία του συστήματος αρχείου με το νέο μέγεθος, και επαναφορά των αποθηκευμένων δεδομένων.
+
[IMPORTANT]
====
Στο FreeBSD περιέχεται η εντολή man:growfs[8], η οποία επιτρέπει να αυξήσουμε το μέγεθος ενός συστήματος αρχείων κατά τη λειτουργία του, αφαιρώντας αυτόν τον περιορισμό.
====

Τα συστήματα αρχείων περιέχονται σε κατατμήσεις (partitions). Αυτό δεν έχει την ίδια έννοια με την κοινή χρήση του όρου κατάτμηση (όπως για παράδειγμα, η κατάτμηση του MS-DOS(R)), λόγω της κληρονομιάς που φέρει το FreeBSD από το UNIX(R). Κάθε κατάτμηση αναγνωρίζεται από ένα λατινικό χαρακτήρα ξεκινώντας από `a` έως το `h`. Κάθε κατάτμηση μπορεί να περιέχει μόνο ένα σύστημα αρχείων, το οποίο σημαίνει πως η αναφορά στα συστήματα αρχείων γίνεται είτε από το τυπικό σημείο προσάρτησης στην ιεραρχία του συστήματος αρχείων, είτε από το λατινικό χαρακτήρα της κατάτμησης.

Επίσης το FreeBSD χρησιμοποιεί μέρος από το δίσκο για _χώρο swap_. Ο χώρος Swap παρέχει στο FreeBSD _εικονική μνήμη (virtual memory)_. Αυτό επιτρέπει στον υπολογιστή σας να συμπεριφέρεται σαν να είχε πολύ περισσότερη μνήμη από όσο πραγματικά έχει. Όταν το FreeBSD δεν έχει διαθέσιμη μνήμη μεταφέρει μερικά από τα δεδομένα που δεν χρησιμοποιούνται, την προκειμένη στιγμή, στον χώρο swap, και όταν τα χρειαστεί τα επαναφέρει (ενώ μεταφέρει κάποια άλλα δεδομένα στον χώρο swap).

Υπάρχουν κάποιες συμβάσεις σχετικά με τις κατατμήσεις

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Κατάτμηση
| Σύμβαση

|`a`
|Συνήθως περιλαμβάνει το root σύστημα αρχείων

|`b`
|Συνήθως περιλαμβάνει τον χώρο swap

|`c`
|Συνήθως ιδίου μεγέθους με την περιλαμβανόμενη φέτα (slice). Αυτό επιτρέπει σε βοηθητικά προγράμματα που πρέπει να δουλέψουν σε ολόκληρο το κομμάτι (για παράδειγμα, ένας ανιχνευτής κατεστραμμένων μπλοκ) να λειτουργούν στην `c` κατάτμηση. Κανονικά δεν θα πρέπει να δημιουργείτε σύστημα αρχείων σε αυτή την κατάτμηση.

|`d`
|Η κατάτμηση `d` είχε στο παρελθόν μια ειδική αντιστοιχία, κάτι που δεν ισχύει πλέον σήμερα, επομένως η `d` μπορεί να χρησιμοποιείται σαν μια κανονική κατάτμηση.
|===

Κάθε κατάτμηση που περιέχει ένα σύστημα αρχείων αποθηκεύεται στο FreeBSD σε μια τοποθεσία που ονομάζεται _φέτα (slice)_. Η φέτα είναι ένας όρος του FreeBSD για αυτό που κοινώς αποκαλείται κατάτμηση, και αυτό επίσης οφείλεται στην καταγωγή του FreeBSD από το UNIX(R). Οι φέτες αριθμούνται αρχίζοντας από το 1 έως το 4.

Ο αριθμός της φέτας ακολουθεί το όνομα συσκευής μετά το πρόθεμα `s` ξεκινώντας από το 1. Επομένως, "da0__s1__" είναι η πρώτη φέτα του πρώτου οδηγού SCSI. Μπορούν να υπάρχουν μέχρι τέσσερις φέτες σε κάθε δίσκο, αλλά μπορείτε να δημιουργήσετε λογικές φέτες μέσα σε κατάλληλου τύπου φυσικές φέτες. Σε αυτές τις εκτεταμένες φέτες η αρίθμηση ξεκινάει από το 5, επομένως "ad0__s5__" είναι η πρώτη εκτεταμένη φέτα στον πρώτο δίσκο IDE. Αυτές οι συσκευές χρησιμοποιούνται από συστήματα αρχείων που πρέπει να καταλαμβάνουν μια ολόκληρη φέτα.

Οι φέτες, οι "επικίνδυνα αφοσιωμένοι (dangerously dedicated) " φυσικοί οδηγοί καθώς και άλλοι οδηγοί, περιέχουν _κατατμήσεις_, οι οποίες παρουσιάζονται με λατινικούς χαρακτήρες από το `a` έως το `h`. Αυτός ο χαρακτήρας αναφέρεται στο όνομα συσκευής, επομένως "da0__a__" είναι η a κατάτμηση στον πρώτο οδηγό da, ο οποίος είναι "επικίνδυνα αφοσιωμένος". Η "ad1s3__e__" είναι η πέμπτη κατάτμηση στην τρίτη φέτα του δεύτερου οδηγού δίσκου IDE.

Ολοκληρώνοντας, κάθε δίσκος στο σύστημα είναι μονόδρομα ορισμένος. Κάθε όνομα δίσκου ξεκινά με ένα κωδικό που υποδεικνύει τον τύπο του δίσκου, και ένα νούμερο που υποδηλώνει ποιος δίσκος είναι. Αντίθετα με τις φέτες, οι δίσκοι αριθμούνται ξεκινώντας από το 0. Οι πιο συνήθεις κωδικοί που θα συναντήσετε αναφέρονται στην <<basics-dev-codes>>.

Όταν γίνεται αναφορά σε μια κατάτμηση, το FreeBSD ζητά να δηλωθεί επιπλέον η ονομασία της φέτας και του δίσκου που περιέχει την κατάτμηση, ενώ στην περίπτωση που αναφέρεστε σε μια φέτα θα πρέπει να δηλώνετε το όνομα του δίσκου. Επομένως, όταν αναφέρεστε σε μια κατάτμηση χρειάζεται να δηλώνετε το όνομα του δίσκου, `s`, τον αριθμό της φέτας, και τον χαρακτήρα της κατάτμησης. Παραδείγματα μπορείτε να βρείτε στην <<basics-disk-slice-part>>.

Η <<basics-concept-disk-model>> παρουσιάζει ένα εννοιολογικό μοντέλο για τη δομή του δίσκου που θα σας βοηθήσει να καταλάβετε καλύτερα κάποια πράγματα.

Για να εγκαταστήσετε το FreeBSD πρέπει πρώτα να ρυθμίσετε τις φέτες του δίσκου, να δημιουργήσετε τις κατατμήσεις μέσα στις φέτες που θα χρησιμοποιήσετε για το FreeBSD, έπειτα να δημιουργήσετε ένα σύστημα αρχείων (ή χώρο swap) σε κάθε κατάτμηση, και τέλος να αποφασίσετε σε ποιο σημείο θα προσαρτηθεί το σύστημα αρχείων.

[[basics-dev-codes]]
.Κωδικοί Συσκευών Δίσκων
[cols="1,1", frame="none", options="header"]
|===
| Κώδικας
| Σημαίνει

|[.filename]#ad#
|Δίσκος ATAPI (IDE)

|[.filename]#da#
|Δίσκος SCSI άμεσης πρόσβασης

|[.filename]#acd#
|ATAPI (IDE) CDROM

|[.filename]#cd#
|SCSI CDROM

|[.filename]#fd#
|Μονάδα Δισκέτας (Floppy)
|===

[[basics-disk-slice-part]]
.Υποδείγματα Ονομάτων Δίσκου, Φέτας, Κατάτμησης
[example]
====
[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Ονομασία
| Σημαίνει

|`ad0s1a`
|Η πρώτη κατάτμηση (`a`) στην πρώτη φέτα (`s1`) του πρώτου δίσκου IDE (`ad0`).

|`da1s2e`
|Η πέμπτη κατάτμηση (`e`) στην δεύτερη φέτα (`s2`) του δεύτερου δίσκου SCSI (`da1`).
|===
====

[[basics-concept-disk-model]]
.Εννοιολογικό Μοντέλο ενός Δίσκου
[example]
====
Το διάγραμμα παρουσιάζει μια εικόνα του πρώτου δίσκου IDE που είναι προσαρτημένος στο σύστημα. Ας υποθέσουμε πως ο δίσκος έχει μέγεθος 4 GB, και περιέχει δύο φέτες των 2 GB (κατατμήσεις MS-DOS(R)). Η πρώτη φέτα περιέχει ένα δίσκο MS-DOS(R), [.filename]#C:#, και η δεύτερη φέτα μία εγκατάσταση FreeBSD. Σε αυτό το παράδειγμα, η εγκατάσταση FreeBSD έχει τρεις κατατμήσεις δεδομένων και μία κατάτμηση swap.

Καθεμία από τις τρεις κατατμήσεις θα περιέχει ένα σύστημα αρχείων. Η κατάτμηση `a` θα χρησιμοποιηθεί για το root σύστημα αρχείων, η `e` για τη δομή κατάλογου [.filename]#/var#, και η `f` για τη δομή καταλόγου [.filename]#/usr#.

image::disk-layout.png[]

====

[[mount-unmount]]
== Προσάρτηση και Αποπροσάρτηση Συστημάτων Αρχείων

Ένα σύστημα αρχείων αναπαριστάται καλύτερα σε μορφή δέντρου, με τις ρίζες του στο [.filename]#/#. Οι κατάλογοι [.filename]#/dev#, [.filename]#/usr#, και άλλοι είναι κλαδιά του καταλόγου root, και μπορεί να έχουν με τη σειρά τους, τα δικά τους κλαδιά, όπως τον [.filename]#/usr/local#, και ούτω καθεξής.

Υπάρχουν διάφοροι λόγοι για τους οποίους θα έπρεπε να τοποθετήσουμε κάποιους από αυτούς τους καταλόγους σε διαφορετικά συστήματα αρχείων. Ο κατάλογος [.filename]#/var# περιέχει τους καταλόγους [.filename]#log/#, [.filename]#spool/#, και διάφορους άλλους τύπους προσωρινών αρχείων, και για το λόγο αυτό μπορεί να γεμίσει. Δεν θα ήταν καλή ιδέα να γεμίσει το root σύστημα αρχείων, επομένως ο διαχωρισμός του [.filename]#/var# από τον [.filename]#/# είναι συχνά επιθυμητός.

Ένας άλλος συνηθισμένος λόγος να έχουμε διάφορους καταλόγους σε διαφορετικά συστήματα αρχείων είναι όταν πρόκειται να φιλοξενηθούν σε διαφορετικούς φυσικούς δίσκους, ή είναι ξεχωριστοί εικονικοί δίσκοι, όπως συμβαίνει με το crossref:network-servers[network-nfs,Δικτυακό Σύστημα Αρχείων (Network File System)], και τους οδηγούς CDROM.

[[disks-fstab]]
=== Το Αρχείο [.filename]#fstab#

Κατά τη crossref:boot[boot,διεργασία εκκίνησης], τα συστήματα αρχείων που αναφέρονται στο [.filename]#/etc/fstab# προσαρτώνται αυτόματα (εκτός αν αναφέρονται με την επιλογή `noauto` ).

Το αρχείο [.filename]#/etc/fstab# περιέχει μια σειρά από γραμμές με διάταξη όπως η ακόλουθη:

[.programlisting]
....
device       /mount-point fstype     options      dumpfreq     passno
....

`device`::
Όνομα συσκευής (η οποία θα πρέπει να υπάρχει), όπως εξηγείται στην crossref:disks[disks-naming,"Device Names"].

`mount-point`::
Κατάλογος (θα πρέπει να υπάρχει) στον οποίο προσαρτάται το σύστημα αρχείων.

`fstype`::
Ο τύπος του συστήματος αρχείων που θα δοθεί στην man:mount[8]. Το προκαθορισμένο σύστημα αρχείων του FreeBSD είναι το `ufs`.

`options`::
Το `rw` για συστήματα αρχείων ανάγνωσης- εγγραφής (read- write), ή `ro` για συστήματα αρχείων μόνο ανάγνωσης (read-only), συμπληρωμένο με όποια άλλη επιλογή μπορεί να χρειάζεστε. Μία συνήθης επιλογή είναι η `noauto` για συστήματα αρχείων που δεν προσαρτώνται αυτόματα κατά τις διεργασίες εκκίνησης του συστήματος. Άλλες επιλογές αναφέρονται στην σελίδα βοήθειας man:mount[8].

`dumpfreq`::
Αυτό το πεδίο χρησιμοποιείται από το man:dump[8] για να ορίσει ποια συστήματα αρχείων χρειάζονται dumping. Αν το πεδίο απουσιάζει, τότε η προκαθορισμένη τιμή του είναι μηδέν.

`passno`::
Αυτό ορίζει την σειρά με την οποία θα ελέγχονται τα συστήματα αρχείων. Συστήματα αρχείων που δεν επιθυμούμε να ελεγχθούν θα πρέπει να έχουν στο πεδίο `passno` τιμή μηδέν. Το root σύστημα αρχείων (το οποίο πρέπει να ελεγχθεί πριν από όλα τα άλλα) θα έχει στο πεδίο `passno` την τιμή ένα και όλα τα άλλα συστήματα αρχείων θα έχουν στο πεδίο `passno` τιμές μεγαλύτερες από ένα. Αν περισσότερα από ένα συστήματα αρχείων έχουν την ίδια τιμή `passno` τότε το man:fsck[8] θα επιχειρήσει να ελέγξει παράλληλα τα συστήματα αρχείων, αν αυτό είναι εφικτό.

Συμβουλευτείτε την σελίδα βοηθείας man:fstab[5] για περισσότερες πληροφορίες για την μορφή του αρχείου [.filename]#/etc/fstab# και για τις επιλογές που μπορεί να περιέχει.

[[disks-mount]]
=== Η Εντολή `mount`

Η εντολή man:mount[8] είναι αυτό ακριβώς που χρειάζεστε για την προσάρτηση συστημάτων αρχείων.

Η βασική μορφή της είναι:

[source,shell]
....
# mount device mountpoint
....

Υπάρχει πληθώρα επιλογών, όπως αναφέρεται στην σελίδα βοηθείας man:mount[8], αλλά οι πιο συνήθεις είναι:

.Επιλογές εντολής mount
`-a`::
Προσάρτηση όλων των συστημάτων αρχείων που αναφέρονται στο [.filename]#/etc/fstab#, εκτός αυτών που φέρουν την επιλογή "noauto", εξαιρούνται μέσω της επιλογής `-t`, ή αυτών που ήδη έχουν προσαρτηθεί.

`-d`::
Κάνει τα πάντα εκτός από την πραγματική προσάρτηση του συστήματος. Αυτή η επιλογή είναι χρήσιμη σε συνεργασία με το πρόθεμα `-v` για να προσδιοριστεί τι ακριβώς προσπαθεί να κάνει η man:mount[8] την συγκεκριμένη στιγμή.

`-f`::
Αναγκάζει την προσάρτηση ενός μη-καθαρού συστήματος αρχείων (επικίνδυνο), ή εξαναγκάζει την ανάκληση πρόσβασης εγγραφής όταν υποβιβάζεται η προσάρτηση ενός συστήματος αρχείων ανάγνωσης-εγγραφής (read-write) σε μόνο-ανάγνωσης.

`-r`::
Προσαρτά το σύστημα αρχείων σε κατάσταση μόνο-ανάγνωσης. Είναι ακριβώς το ίδιο με τη χρήση του προθέματος `ro` με την επιλογή `-o`.

`-t` _fstype_::
Προσαρτά το υπάρχον σύστημα αρχείων, χρησιμοποιώντας τον τύπο συστήματος αρχείων που δίνεται, ή προσαρτά μόνο συστήματα αρχείων του συγκεκριμένου τύπου, εάν δοθεί μαζί με την επιλογή `-a`.
+
Το "ufs" είναι ο προεπιλεγμένος τύπος συστήματος αρχείων.

`-u`::
Ανανεώνει τις επιλογές προσάρτησης στο σύστημα αρχείων.

`-v`::
Συμπεριλαμβάνει αναλυτική αναφορά.

`-w`::
Προσαρτά το σύστημα αρχείων για ανάγνωση-εγγραφή (read-write).

Η επιλογή `-o` δέχεται μία σειρά από επιλογές χωρισμένες με κόμμα, περιλαμβάνοντας τις ακόλουθες:

noexec::
Δεν επιτρέπεται η λειτουργία εκτελέσιμων σε αυτό το σύστημα αρχείων. Αυτό είναι επίσης μια επιλογή ασφαλείας.

nosuid::
Δεν λαμβάνονται υπ' όψιν setuid ή setgid flags στο σύστημα αρχείων.

[[disks-umount]]
=== Η Εντολή `umount`

Η εντολή man:umount[8] παίρνει, ως παράμετρο, ένα εκ των σημείων προσάρτησης, το όνομα μιας συσκευής, ή τις επιλογές `-a` ή `-A`.

Όλοι οι τύποι δέχονται την `-f` για να εξαναγκάσουν σε αποπροσάρτηση, και την `-v` για αναλυτική αναφορά. Σας προειδοποιούμε πως η επιλογή `-f` γενικά δεν είναι καλή ιδέα. Η εξ' αναγκασμού αποπροσάρτηση μπορεί να οδηγήσει σε κατάρρευση τον υπολογιστή ή να καταστρέψει δεδομένα στο σύστημα αρχείων.

Οι `-a` και `-A` χρησιμοποιούνται για να αποπροσαρτήσουν όλα τα προσαρτημένα συστήματα αρχείων, σύμφωνα και με τις επιλογές που δίνονται από το `-t`, αν υπάρχει. Το `-A`, ωστόσο, δεν θα επιχειρήσει να αποπροσαρτήσει το root σύστημα αρχείων.

[[basics-processes]]
== Διεργασίες

To FreeBSD είναι ένα λειτουργικό σύστημα multi-tasking. Αυτό σημαίνει πως κάθε στιγμή μπορούν να τρέχουν παραπάνω από ένα προγράμματα. Κάθε πρόγραμμα που τρέχει οποιαδήποτε στιγμή ονομάζεται _διεργασία_ (process). Κάθε εντολή που τρέχετε ξεκινάει τουλάχιστον μία νέα διεργασία, και υπάρχουν κάποιες διεργασίες του συστήματος που τρέχουν συνέχεια για να κρατούν το σύστημα σε λειτουργία.

Κάθε διεργασία χαρακτηρίζεται από ένα μοναδικό αριθμό που ονομάζεται _ID διεργασίας_ ή _PID_, και όπως ακριβώς συμβαίνει με τα αρχεία, κάθε διεργασία έχει έναν ιδιοκτήτη και ένα γκρουπ. Οι πληροφορίες του ιδιοκτήτη και του γκρουπ χρειάζονται για να προσδιορίζεται ποια αρχεία και συσκευές μπορεί να ανοίξει η συγκεκριμένη διεργασία, χρησιμοποιώντας τις άδειες αρχείων που συζητήσαμε νωρίτερα. Οι περισσότερες διεργασίες έχουν επίσης μία γονική διεργασία. Η γονική διεργασία είναι εκείνη η διεργασία που τις ξεκίνησε. Για παράδειγμα, εάν πληκτρολογείτε εντολές στο κέλυφος, τότε το κέλυφος είναι μία διεργασία, και κάθε εντολή που τρέχετε είναι επίσης μία διεργασία. Επομένως κάθε διεργασία που τρέχετε με αυτόν τον τρόπο θα έχει γονική διεργασία το κέλυφος σας. Η μόνη εξαίρεση είναι μία διεργασία που ονομάζεται man:init[8]. Η `init` είναι πάντα η πρώτη διεργασία, και επομένως το PID της είναι πάντα 1. Η `init` ξεκινά αυτόματα από τον πυρήνα κατά την εκκίνηση του FreeBSD.

Δύο ιδιαίτερα χρήσιμες εντολές για να παρατηρείτε τις διεργασίες στο σύστημα, είναι οι man:ps[1] και man:top[1]. Η εντολή `ps` χρησιμοποιείται για την προβολή μιας στατικής λίστας των τρέχοντων διεργασιών, και μπορεί να εμφανίζει το PID τους, πόση μνήμη χρησιμοποιούν, την εντολή με την οποία ξεκίνησαν, και άλλες πληροφορίες. Η εντολή `top` εμφανίζει όλες τις τρέχουσες διεργασίες, και ανανεώνει την οθόνη σας ανά λίγα δευτερόλεπτα, επομένως μπορείτε να παρατηρείτε τι ακριβώς κάνει ο υπολογιστή σας τη δεδομένη στιγμή.

Η `ps`, από προεπιλογή, εμφανίζει μόνο τις εντολές που τρέχουν και ανήκουν σε εσάς. Για παράδειγμα:

[source,shell]
....
% ps
  PID  TT  STAT      TIME COMMAND
  298  p0  Ss     0:01.10 tcsh
 7078  p0  S      2:40.88 xemacs mdoc.xsl (xemacs-21.1.14)
37393  p0  I      0:03.11 xemacs freebsd.dsl (xemacs-21.1.14)
48630  p0  S      2:50.89 /usr/local/lib/netscape-linux/navigator-linux-4.77.bi
48730  p0  IW     0:00.00 (dns helper) (navigator-linux-)
72210  p0  R+     0:00.00 ps
  390  p1  Is     0:01.14 tcsh
 7059  p2  Is+    1:36.18 /usr/local/bin/mutt -y
 6688  p3  IWs    0:00.00 tcsh
10735  p4  IWs    0:00.00 tcsh
20256  p5  IWs    0:00.00 tcsh
  262  v0  IWs    0:00.00 -tcsh (tcsh)
  270  v0  IW+    0:00.00 /bin/sh /usr/X11R6/bin/startx -- -bpp 16
  280  v0  IW+    0:00.00 xinit /home/nik/.xinitrc -- -bpp 16
  284  v0  IW     0:00.00 /bin/sh /home/nik/.xinitrc
  285  v0  S      0:38.45 /usr/X11R6/bin/sawfish
....

Όπως μπορείτε να δείτε σε αυτό το παράδειγμα, η έξοδος από την ps προβάλλεται σε στήλες. `PID` είναι το PID της διεργασίας όπως αναφέραμε νωρίτερα. Τα PID διανέμονται από 1, έως 99999, και όταν υπερβούν το 99999 ξεκινούν από την αρχή (ένα PID δεν μπορεί να αποδοθεί ξανά αν είναι ήδη σε χρήση). Η στήλη `TT` δείχνει το τερματικό (tty) του προγράμματος που εκτελείται, και μπορεί να αγνοηθεί αυτή τη στιγμή δίχως πρόβλημα. Η `STAT` υποδεικνύει την κατάσταση του προγράμματος, και πάλι μπορεί να αγνοηθεί. Η `TIME` είναι η χρονική διάρκεια που το πρόγραμμα απασχολεί την CPU, αυτό συνήθως δεν είναι ο χρόνος εκτέλεσης αφού τα περισσότερα προγράμματα καθυστερούν με άλλες εργασίες πριν απασχολήσουν την CPU. Η τελευταία στήλη, η `COMMAND` είναι η γραμμή εντολής που δόθηκε για να τρέξει το πρόγραμμα.

Η man:ps[1] υποστηρίζει διάφορες επιλογές για να αλλάξει την γκάμα των πληροφοριών που εμφανίζονται. Μία από τις πιο χρήσιμες επιλογές είναι η `auxww`. Η `a` εμφανίζει πληροφορίες για όλες τις τρέχουσες διεργασίες, όχι μόνο τις δικές σας. Η `u` εμφανίζει το όνομα χρήστη του ιδιοκτήτη της διεργασίας, όπως και τη χρήσης της μνήμης. Η `x` εμφανίζει πληροφορίες σχετικά με τις διεργασίες των δαιμόνων και η `ww` αναγκάζει την man:ps[1] να εμφανίσει ολόκληρη την εντολή γραμμής για κάθε διεργασία, αφού συνήθως εμφανίζεται κομμένη λόγω του μήκους της που δεν χωρά να εμφανιστεί στην οθόνη.

Η έξοδος της man:top[1] είναι παρόμοια. Ένα δείγμα εργασίας της μοιάζει σαν αυτή:

[source,shell]
....
% top
last pid: 72257;  load averages:  0.13,  0.09,  0.03    up 0+13:38:33  22:39:10
47 processes:  1 running, 46 sleeping
CPU states: 12.6% user,  0.0% nice,  7.8% system,  0.0% interrupt, 79.7% idle
Mem: 36M Active, 5256K Inact, 13M Wired, 6312K Cache, 15M Buf, 408K Free
Swap: 256M Total, 38M Used, 217M Free, 15% Inuse

  PID USERNAME PRI NICE  SIZE    RES STATE    TIME   WCPU    CPU COMMAND
72257 nik       28   0  1960K  1044K RUN      0:00 14.86%  1.42% top
 7078 nik        2   0 15280K 10960K select   2:54  0.88%  0.88% xemacs-21.1.14
  281 nik        2   0 18636K  7112K select   5:36  0.73%  0.73% XF86_SVGA
  296 nik        2   0  3240K  1644K select   0:12  0.05%  0.05% xterm
48630 nik        2   0 29816K  9148K select   3:18  0.00%  0.00% navigator-linu
  175 root       2   0   924K   252K select   1:41  0.00%  0.00% syslogd
 7059 nik        2   0  7260K  4644K poll     1:38  0.00%  0.00% mutt
...
....

Η έξοδος είναι χωρισμένη σε δύο τομείς. Η κεφαλίδα (οι πέντε πρώτες γραμμές) εμφανίζουν το PID της τελευταίας διεργασίας που έτρεξε, την μέση τιμή φορτίου (είναι μια μέτρηση που δείχνει πόσο απασχολημένο είναι το σύστημα), ο χρόνος λειτουργίας (uptime) του συστήματος (από την τελευταία επανεκκίνηση) και την τρέχουσα ώρα. Τα άλλα στοιχεία στην κεφαλίδα σχετίζονται με το νούμερο των διεργασιών που τρέχουν (47 σε αυτή τη περίπτωση), πόση μνήμη και χώρο swap κατέχουν και πόσο χρόνο ξοδεύει το σύστημα σε διάφορες καταστάσεις λειτουργίας της CPU.

Πιο κάτω ακολουθεί μια σειρά από στήλες, που περιέχουν παρόμοιες πληροφορίες με την έξοδο της ps. Όπως και νωρίτερα μπορείτε να δείτε το PID, το όνομα χρήστη, το ποσοστό χρήσης της CPU, και την εντολή με την οποία ξεκίνησε η διεργασία. Η man:top[1] από προεπιλογή, εμφανίζει επίσης το ποσοστό μνήμης που χρησιμοποιείται από τη διεργασία. Αυτή χωρίζεται σε δύο στήλες. Η μία είναι για το συνολικό μέγεθος μνήμης που χρειάστηκε η εφαρμογή, ενώ η άλλη για το μέγεθος της μνήμης που καταναλώνει την παρούσα στιγμή. Σε αυτό το παράδειγμα μπορείτε να δείτε ότι ο man:getenv[3] χρειάστηκε σχεδόν 30 MB RAM, αλλά την παρούσα στιγμή χρησιμοποιεί μόνο 9 MB.

Η man:top[1] αυτόματα ανανεώνει το περιεχόμενο της κάθε δύο δευτερόλεπτα. Αυτό μπορεί να ρυθμιστεί με την επιλογή `s`.

[[basics-daemons]]
== Δαίμονες, Σήματα, και Τερματισμός Διεργασιών

Όταν χρησιμοποιείτε ένα κειμενογράφο, είναι εύκολο να τον ελέγχετε, να φορτώνετε αρχεία, και οτιδήποτε άλλο. Αυτό συμβαίνει διότι ο κειμενογράφος παρέχει αυτές τις δυνατότητες, και επίσης επειδή είναι προσαρτημένος σε ένα _τερματικό_. Μερικά προγράμματα δεν είναι σχεδιασμένα να δουλεύουν με συνεχείς χειρισμούς από τον χρήστη, και επομένως αποσυνδέονται από το τερματικό με την πρώτη ευκαιρία. Για παράδειγμα, ένας εξυπηρετητής web ξοδεύει όλο του το χρόνο στο να απαντά σε αιτήματα web, επομένως δεν χρειάζεται καμιά εισαγωγή δεδομένων από τον χρήστη. Άλλο παραπλήσιο παράδειγμα εφαρμογής, είναι τα προγράμματα μεταφοράς μηνυμάτων ηλεκτρονικής αλληλογραφίας από μια τοποθεσία σε μιαν άλλη.

Ονομάζουμε αυτά τα προγράμματα _δαίμονες (daemons)_. Οι δαίμονες ήταν χαρακτήρες της Ελληνικής μυθολογίας (ούτε καλοί - ούτε κακοί), ήταν απλά μικρά συνοδευτικά πνεύματα που έκαναν χρήσιμα πράγματα για την ανθρωπότητα, όπως ακριβώς και οι διακομιστές web και εξυπηρετητές ηλεκτρονικής αλληλογραφίας σήμερα κάνουν χρήσιμα πράγματα. Αυτός είναι και ο λόγος για τον οποίο η μασκότ του BSD είναι εδώ και πολύ καιρό ο χαρούμενος δαίμονας με πάνινα σπορ παπούτσια και την τρίαινα.

Η ονομασία των προγραμμάτων που τρέχουν σαν δαίμονες συμβατικά τελειώνει με "d". Το BIND είναι το Berkeley Internet Name Domain, αλλά το πραγματικό πρόγραμμα που τρέχει ονομάζεται `named`, το πρόγραμμα του εξυπηρετητή web Apache λέγεται `httpd`, ο δαίμονας ελέγχου των εκτυπωτών γραμμής είναι ο `lpd` και ούτω καθεξής. Αυτή είναι απλά μια σύμβαση, όχι απόλυτος κανόνας, για παράδειγμα, ο κύριος δαίμονας ηλεκτρονικής αλληλογραφίας για την εφαρμογή Sendmail ονομάζεται `sendmail`, και όχι `maild`, όπως θα ήταν αναμενόμενο.

Μερικές φορές θα χρειαστεί να επικοινωνείτε με τη διεργασία ενός δαίμονα. Ένας τρόπος για να γίνει αυτό είναι στέλνοντας (όπως και σε κάθε εκτελέσιμη διεργασία) _σήματα (signals)_. Υπάρχουν διάφορα σήματα που μπορείτε να στείλετε - μερικά από αυτά έχουν μια συγκεκριμένη σημασία, ενώ άλλα ερμηνεύονται μέσα από την εφαρμογή, και επομένως για να ξέρουμε πως ερμηνεύονται τα σήματα θα πρέπει να διαβάσουμε την τεκμηρίωση της εφαρμογής. Μπορείτε να στείλετε σήμα σε μια διεργασία μόνο αν σας ανήκει. Αν στείλετε σήμα σε μια διεργασία που ανήκει σε κάποιον άλλο με man:kill[1] ή man:kill[2], δεν θα σας επιτραπεί. Η μοναδική εξαίρεση σε αυτό, είναι ο χρήστης `root`, που μπορεί να στέλνει σήματα στις διεργασίες οποιουδήποτε άλλου χρήστη του συστήματος.

Το FreeBSD στέλνει επίσης σήματα σε εφαρμογές σε μερικές περιπτώσεις. Αν μία εφαρμογή είναι γραμμένη άσχημα, και προσπαθεί να προσπελάσει μνήμη που δεν της ανήκει, το FreeBSD στέλνει στη διεργασία το σήμα _Segmentation Violation_ (`SIGSEGV`). Αν μια εφαρμογή χρησιμοποίησε το σύστημα ειδοποίησης man:alarm[3] για να ειδοποιηθεί μετά την πάροδο μιας χρονικής περιόδου τότε το FreeBSD θα στείλει το Alarm signal (`SIGALRM`), και ούτω καθ'εξής.

Δύο σήματα μπορούν να χρησιμοποιηθούν για να σταματήσουν μία διαδικασία, το `SIGTERM` και το `SIGKILL`. Το `SIGTERM` είναι ο σωστός τρόπος για να σταματήσουμε μια διαδικασία. Η διεργασία _αντιλαμβάνεται_ το σήμα, εκτελεί το σταμάτημα κλείνοντας όλα τα αρχεία αναφοράς (log files), που πιθανώς να είναι ανοιχτά, και γενικώς τελειώνει οτιδήποτε κάνει την συγκεκριμένη χρονική στιγμή πριν σταματήσει. Σε μερικές περιπτώσεις η διεργασία μπορεί να αγνοήσει το `SIGTERM` εάν βρίσκεται στα μισά κάποιας εργασίας που δεν μπορεί να διακοπεί.

Το σήμα `SIGKILL` δεν μπορεί να αγνοηθεί από μία διεργασία. Είναι σαν να λέει στη διεργασία, "Δεν με ενδιαφέρει τι κάνεις, σταμάτα τώρα αμέσως". Αν στείλετε το σήμα `SIGKILL` σε μια διαδικασία τότε το FreeBSD θα σταματήσει την διαδικασία άμεσα .

Άλλα σήματα που πιθανώς να θέλετε να χρησιμοποιήσετε είναι τα `SIGHUP`, `SIGUSR1`, και `SIGUSR2`. Αυτά είναι σήματα γενικής χρήσης, και όταν αποστέλλονται κάνουν διαφορετικά πράγματα ανάλογα με την εφαρμογή.

Ας υποθέσουμε πως αλλάξατε το αρχείο ρύθμισης του εξυπηρετητή διαδικτύου σας, και πως θα θέλατε να πείτε στον εξυπηρετητή να ξαναδιαβάσει τις ρυθμίσεις. Θα μπορούσατε να σταματήσετε και να επανεκκινήσετε το `httpd`, αλλά αυτό θα οδηγούσε σε μια χρονική περίοδο όπου ο εξυπηρετητής θα έμενε εκτός λειτουργίας, κάτι το οποίο μπορεί να είναι ανεπιθύμητο. Οι περισσότεροι δαίμονες είναι σχεδιασμένοι να απαντούν σε σήματα `SIGHUP` για την εκ νέου ανάγνωση του αρχείου ρύθμισης τους. Επομένως, αντί να σταματήσουμε και να επανεκκινήσουμε το `httpd` θα μπορούσαμε να του στείλουμε το σήμα `SIGHUP`. Επειδή δεν υπάρχει συγκεκριμένος τρόπος στην απάντηση αυτών των σημάτων, και διαφορετικοί δαίμονες έχουν διαφορετική συμπεριφορά, πρέπει να διαβάσετε πρώτα την τεκμηρίωση για τον συγκεκριμένο δαίμονα.

Τα σήματα στέλνονται χρησιμοποιώντας την εντολή man:kill[1], όπως υποδεικνύει το ακόλουθο παράδειγμα.

[.procedure]
====
*Procedure: Στέλνοντας Σήμα σε μία Διεργασία*

Αυτό το παράδειγμα δείχνει πως να στείλετε σήμα στην man:inetd[8]. Το αρχείο ρύθμισης της `inetd` είναι το [.filename]#/etc/inetd.conf#, και η `inetd` θα ξανα-διαβάσει αυτό το αρχείο ρύθμισης όταν θα σταλεί το σήμα `SIGHUP`.

. Βρείτε το PID της διεργασίας, της οποίας επιθυμείτε να στείλετε το σήμα. Ενεργήστε χρησιμοποιώντας τις εντολές man:ps[1] και man:grep[1]. Η εντολή man:grep[1] χρησιμοποιείται για να ψάξει στην έξοδο μιας εντολής, για τους αλφαριθμητικούς χαρακτήρες που έχετε ορίσει. Η εντολή εκτελείται από έναν απλό χρήστη, ενώ η man:inetd[8] εκτελείται από τον `root`, επομένως θα πρέπει να προσθέσετε την επιλογή `ax` στην man:ps[1].
+
[source,shell]
....
% ps -ax | grep inetd
  198  ??  IWs    0:00.00 inetd -wW
....
+ 
Επομένως το PID της man:inetd[8] είναι το 198. Σε μερικές περιπτώσεις μπορεί να εμφανίζεται στην έξοδο η εντολή `grep inetd`. Αυτό οφείλεται στον τρόπο με τον οποίο η man:ps[1] ψάχνει την λίστα των ενεργών διεργασιών.
+
. Χρησιμοποιήστε την man:kill[1] για να στείλετε το σήμα. Επειδή η man:inetd[8] τρέχει από τον `root` θα πρέπει πρώτα να χρησιμοποιήσετε man:su[1] για να γίνετε πρώτα `root`.
+
[source,shell]
....
% su
Password:
# /bin/kill -s HUP 198
....
+ 
Όπως και με τις περισσότερες εντολές στο UNIX(R), η man:kill[1] δεν θα τυπώσει τίποτε στην έξοδο αν η εντολή είχε επιτυχία. Εάν στείλετε ένα σήμα σε μια διεργασία που δεν σας ανήκει θα δείτε `kill: _PID_: Operation not permitted`. Αν πληκτρολογήσετε λάθος το PID τότε ή θα στείλετε το σήμα σε λάθος διεργασία,κάτι που μπορεί να είναι άσχημο, ή, αν είστε τυχερός, θα έχετε στείλει το σήμα σε ένα PID που δεν χρησιμοποιείται τη συγκεκριμένη στιγμή, και θα δείτε `kill: _PID_: No such process`.

[NOTE]
.Γιατί να χρησιμοποιήσετε την εντολή `/bin/kill`;
======
Πολλά κελύφη παρέχουν την εντολή `kill` ως ενσωματωμένη εντολή. Αυτό σημαίνει πως το κέλυφος θα στείλει το σήμα άμεσα, αντί να τρέξει το [.filename]#/bin/kill#. Αυτό μπορεί να είναι πολύ χρήσιμο, αλλά διαφορετικά κελύφη έχουν διαφορετική σύνταξη για τον καθορισμό το όνομα του σήματος που πρέπει να αποσταλεί. Αντί λοιπόν να πρέπει να μάθουμε όλες τις περιπτώσεις ,είναι ευκολότερο απλά να χρησιμοποιούμε την εντολή `/bin/kill ...` άμεσα.
======
====

Η αποστολή άλλων σημάτων μοιάζει πάρα πολύ, απλά αντικαταστήστε το `TERM` ή το `KILL` στη γραμμή εντολών με κάποιο άλλο.

[IMPORTANT]
====
Η φόνευση τυχαίων διεργασιών στο σύστημα μπορεί να είναι κακή ιδέα. Ιδιαίτερα, η man:init[8], με PID 1, είναι πολύ ειδική. Η εκτέλεση της εντολής `/bin/kill -s KILL 1` είναι ένας γρήγορος τρόπος να σβήσετε το σύστημα σας. _Πάντα_ να ελέγχετε δύο φορές τις παραμέτρους που χρησιμοποιείτε με την man:kill[1] _πριν_ πιέσετε kbd:[Return].
====

[[shells]]
== Κελύφη

Στο FreeBSD ένα μεγάλο μέρος της καθημερινής εργασίας γίνεται σε ένα περιβάλλον γραμμής εντολών ονόματι κέλυφος (shell). Η κύρια δουλειά του κελύφους είναι να παίρνει εντολές από το κανάλι εισόδου και να τις εκτελεί. Μερικά κελύφη έχουν ενσωματωμένες λειτουργίες ώστε να βοηθούν στις καθημερινές προγραμματισμένες εργασίες όπως διαχείριση αρχείων, file globbing, επεξεργασία γραμμής εντολών, μακροεντολές, και μεταβλητές περιβάλλοντος. Το FreeBSD διατίθεται με διάφορα κελύφη, όπως το `sh`, το Bourne Shell και το `tcsh`, το βελτιωμένο C-shell. Διάφορα άλλα κελύφη είναι διαθέσιμα από την Συλλογή των Ports του FreeBSD, όπως τα `zsh` και `bash`.

Ποιο κέλυφος να χρησιμοποιήσετε; Είναι πραγματικά θέμα γούστου. Εάν είστε προγραμματιστής σε γλώσσα C θα αισθανθείτε περισσότερο οικείος με τα κελύφη τύπου C, όπως το `tcsh`. Εάν έρχεστε από το Linux ή είστε νέος σε περιβάλλον γραμμής εντολών UNIX(R) μπορείτε να δοκιμάσετε το `bash`. Η ουσία είναι πως κάθε κέλυφος έχει μοναδικές ιδιότητες που μπορεί να συνεργαστούν με το περιβάλλον εργασίας της προτίμησης σας, και επομένως είναι επιλογή σας ποιο κέλυφος να χρησιμοποιήσετε.

Μια κοινή ιδιότητα όλων των κελυφών είναι η αυτόματη συμπλήρωση ονομάτων αρχείων. Αφού έχετε πληκτρολογήσει τα πρώτα γράμματα μιας εντολής ή ενός ονόματος αρχείου αν πιέσετε το πλήκτρο kbd:[Tab] στο πληκτρολόγιο, τότε το κέλυφος αυτόματα θα ολοκληρώσει το υπόλοιπο της εντολής ή του ονόματος αρχείου. Ας δώσουμε ένα παράδειγμα. Ας υποθέσουμε πως έχετε δύο αρχεία [.filename]#foobar# και [.filename]#foo.bar#. Αν θέλετε να σβήσετε το [.filename]#foo.bar# θα πρέπει να πληκτρολογήσετε `rm fo[Tab].[Tab]`.

Το κέλυφος θα τυπώσει αυτόματα `rm foo[BEEP].bar`.

Το [BEEP] είναι το κουδούνι της κονσόλας, το οποίο μας πληροφορεί πως δεν ήταν δυνατόν να ολοκληρώσει το όνομα του αρχείου διότι υπάρχουν περισσότερα από ένα ονόματα αρχείων που ταιριάζουν. Όντως το [.filename]#foobar# και το [.filename]#foo.bar# ξεκινούν με `fo`, και το κέλυφος κατάφερε να συμπληρώσει ως το `foo`. Αν πληκτρολογήσετε επιπλέον `.`, και μετά πάλι kbd:[Tab], το κέλυφος θα καταφέρει να συμπληρώσει το υπόλοιπο του ονόματος αρχείου για σας.

Άλλο ιδιαίτερο χαρακτηριστικό του κελύφους είναι η χρήση των μεταβλητών περιβάλλοντος. Οι μεταβλητές περιβάλλοντος είναι ένα ζεύγος μεταβλητών/κλειδιών αποθηκευμένα στον περιβάλλοντα χώρο του κελύφους Αυτός ο χώρος μπορεί να διαβαστεί από οποιοδήποτε πρόγραμμα που καλείται από το κέλυφος, και έτσι περιέχει πλήθος ρυθμίσεων προγραμμάτων. Ακολουθεί μία λίστα με συνήθεις μεταβλητές περιβάλλοντος και τη σημασία τους:

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Μεταβλητή
| Περιγραφή

|`USER`
|Όνομα του τρέχοντα χρήστη.

|`PATH`
|Λίστα καταλόγων για την αναζήτηση εκτελέσιμων χωρισμένη με άνω-κάτω τελείες.

|`DISPLAY`
|Όνομα δικτύου της οθόνης X11 που είναι διαθέσιμη για σύνδεση, αν υπάρχει.

|`SHELL`
|Το ενεργό κέλυφος.

|`TERM`
|Το όνομα του τύπου του τερματικού χρήστη. Ορίζει τις δυνατότητες του τερματικού.

|`TERMCAP`
|Εγγραφή στη βάση δεδομένων κωδικών escape για διάφορες λειτουργίες τερματικών.

|`OSTYPE`
|Ο τύπος του λειτουργικού συστήματος π.χ., FreeBSD.

|`MACHTYPE`
|Η αρχιτεκτονική CPU στην οποία δουλεύει το σύστημα.

|`EDITOR`
|Ο προεπιλεγμένος κειμενογράφος του χρήστη.

|`PAGER`
|Το προεπιλεγμένο πρόγραμμα σελιδοποίησης του χρήστη.

|`MANPATH`
|Λίστα καταλόγων για την αναζήτηση των σελίδων βοηθείας (man pages) χωρισμένη με άνω-κάτω τελείες.
|===

Ο ορισμός μιας μεταβλητής περιβάλλοντος διαφέρει κάπως από κέλυφος σε κέλυφος. Για παράδειγμα στα κελύφη τύπου-C, όπως τα `tcsh` και `csh`, θα πρέπει να χρησιμοποιήσετε την `setenv` για να ορίσετε μεταβλητές περιβάλλοντος. Σε κελύφη Bourne όπως τα `sh` και `bash`, θα πρέπει να χρησιμοποιείτε την `export` για να θέσετε τις τρέχουσες μεταβλητές περιβάλλοντος. Για παράδειγμα, για να ορίσετε ή να μετατρέψετε την μεταβλητή περιβάλλοντος `EDITOR`, σε `csh` ή `tcsh` θα πρέπει να δώσετε μια εντολή που να θέτει τη μεταβλητή `EDITOR` στο [.filename]#/usr/local/bin/emacs#:

[source,shell]
....
% setenv EDITOR /usr/local/bin/emacs
....

Για κελύφη Bourne:

[source,shell]
....
% export EDITOR="/usr/local/bin/emacs"
....

Μπορείτε επίσης στα περισσότερα κελύφη να αναπτύσσετε τις μεταβλητές περιβάλλοντος τοποθετώντας μπροστά τους τον χαρακτήρα `$`. Για παράδειγμα, η `echo $TERM` θα τυπώσει την τιμή που έχουμε θέσει στην μεταβλητή, διότι το κέλυφος αναπτύσσει την `$TERM` και περνά την τιμή της στην `echo`.

Τα κελύφη χρησιμοποιούν μερικούς ειδικούς χαρακτήρες, που ονομάζονται meta-χαρακτήρες για εμφανίσεις ιδιαίτερων δεδομένων. Ο πιο κοινός εξ' αυτών είναι ο χαρακτήρας `*`, ο οποίος αντιπροσωπεύει οποιοδήποτε αλφαριθμητικό χαρακτήρα σε ένα όνομα αρχείου. Αυτοί οι ειδικοί meta-χαρακτήρες μπορούν να χρησιμοποιηθούν για να κάνουν filename globbing. Για παράδειγμα, αν πληκτρολογήσετε `echo *` είναι σχεδόν το ίδιο με το να δώσετε `ls` διότι το κέλυφος παίρνει όλα τα αρχεία που ταιριάζουν με `*` και τα προωθεί στην γραμμή εντολών για την `echo`.

Για να εμποδίσετε το κέλυφος να επεξεργαστεί αυτούς τους ειδικούς χαρακτήρες, μπορείτε να χρησιμοποιήσετε το σύμβολο διαφυγής (escape) τοποθετώντας μπροστά τους μια δεξιόστροφη κάθετο (`\`). Η `echo $TERM` τυπώνει τον τύπο του τερματικού σας, ενώ η `echo \$TERM` τυπώνει απλά `$TERM`.

[[changing-shells]]
=== Αλλάζοντας το Κέλυφος σας

Ο ευκολότερος τρόπος για να αλλάξετε το κέλυφος σας είναι να χρησιμοποιήσετε την εντολή `chsh`. Τρέχοντας την `chsh` θα οδηγηθείτε στον κειμενογράφο που έχετε θέσει στην μεταβλητή περιβάλλοντος `EDITOR`, ενώ αν δεν έχετε θέσει, θα οδηγηθείτε στο `vi`. Αλλάξτε κατάλληλα τη γραμμή "Shell:"

Μπορείτε επίσης να δώσετε στην `chsh` την επιλογή `-s`, αυτή θα θέσει το κέλυφος για σας, δίχως να χρειαστεί να χρησιμοποιήσετε τον κειμενογράφο. Για παράδειγμα, αν θέλετε να αλλάξετε το κέλυφος σας σε `bash`, η ακόλουθη εντολή είναι ακριβώς αυτό που χρειάζεστε:

[source,shell]
....
% chsh -s /usr/local/bin/bash
....

[NOTE]
====
Το κέλυφος στο οποίο επιθυμείτε να μεταβείτε _πρέπει_ να είναι καταχωρημένο στο αρχείο [.filename]#/etc/shells#. Αν έχετε εγκαταστήσει ένα κέλυφος από τη crossref:ports[ports,συλλογή των ports], τότε αυτό θα πρέπει να έχει ήδη γίνει. Αν εγκαταστήσατε το κέλυφος μόνοι σας, τότε θα πρέπει να εκτελέσετε τη διαδικασία που ακολουθεί.

Αν για παράδειγμα, εγκαταστήσατε το `bash` μόνοι σας και το τοποθετήσατε στον [.filename]#/usr/local/bin#, τότε θα πρέπει να δώσετε:

[source,shell]
....
# echo "/usr/local/bin/bash" >> /etc/shells
....

Και μετά ξανατρέξτε την `chsh`.
====

[[editors]]
== Κειμενογράφοι

Αρκετές ρυθμίσεις στο FreeBSD γίνονται με επεξεργασία αρχείων κειμένου. Για αυτό το λόγο, θα ήταν καλή ιδέα να εξοικειωθείτε με ένα κειμενογράφο. Αρκετοί περιέχονται στο βασικό σύστημα του FreeBSD και πολλοί περισσότεροι είναι διαθέσιμοι στην Συλλογή των Ports (Ports Collection).

Ο ευκολότερος και απλούστερος κειμενογράφος για να μάθετε ονομάζεται ee, που σημαίνει easy editor (εύκολος κειμενογράφος). Για να ξεκινήσετε τον ee, πρέπει να πληκτρολογήσετε στην γραμμή εντολών `ee filename` όπου _filename_ είναι το όνομα του αρχείου που θέλετε να επεξεργαστείτε. Για παράδειγμα, για να επεξεργαστείτε το [.filename]#/etc/rc.conf#, πληκτρολογείτε `ee /etc/rc.conf`. Μόλις εισέλθετε στο `ee`, όλες οι εντολές για να χειριστείτε τις λειτουργίες του κειμενογράφου αναφέρονται στο πάνω μέρος της οθόνης. Ο χαρακτήρας καπέλο `^` σημαίνει το πλήκτρο kbd:[Ctrl], επομένως `^e` σημαίνει πως πρέπει να πληκτρολογήσετε τον συνδυασμό πλήκτρων kbd:[Ctrl+e]. Για να βγείτε από το ee, πιέζετε το πλήκτρο kbd:[Esc], και επιλέγετε leave editor. Ο κειμενογράφος θα σας προτρέψει να σώσετε τυχόν αλλαγές, αν έχετε επεξεργαστεί το αρχείο.

Το FreeBSD παρέχεται επίσης με πιο εξελιγμένους κειμενογράφους όπως το ενσωματωμένο στο βασικό σύστημα vi. Το Emacs και το vim, είναι μέρος της Συλλογής των Ports του FreeBSD (package:editors/emacs[] και package:editors/vim[]). Αυτοί οι κειμενογράφοι προσφέρουν πολλές περισσότερες λειτουργίες και δυνατότητες, με κόστος αυξημένη πολυπλοκότητα και δυσκολία εκμάθησης. Ωστόσο αν σχεδιάζετε να επεξεργαστείτε αρκετά κείμενα, η εκμάθηση ενός ισχυρού κειμενογράφου όπως το vim ή το Emacs θα σας γλυτώσει πολύ περισσότερο χρόνο επεξεργασίας στην πορεία.

Πολλές εφαρμογές που χρειάζεται να αλλάξουν κάποιο αρχείο ή απαιτούν από το χρήστη να πληκτρολογήσει κάποιο κείμενο, θα ανοίξουν αυτόματα κάποιο κειμενογράφο. Για να αλλάξετε τον προεπιλεγμένο κειμενογράφο, θα πρέπει να θέσετε κατάλληλη τιμή στην μεταβλητή περιβάλλοντος `EDITOR`. Δείτε την ενότητα <<shells,Κελύφη>> για περισσότερες λεπτομέρειες.

[[basics-devices]]
== Συσκευές και Αρχεία συσκευών

Συσκευή είναι ένας όρος που αναφέρεται σε σχέση με λειτουργίες hardware ενός συστήματος, περιλαμβάνοντας δίσκους, εκτυπωτές, κάρτες γραφικών και πληκτρολόγια. Κατά την εκκίνηση του FreeBSD οι περισσότερες πληροφορίες που αναγράφονται στην οθόνη είναι συσκευές που αναγνωρίζονται από το σύστημα. Μπορείτε να ξαναδείτε τα μηνύματα εκκίνησης, διαβάζοντας το [.filename]#/var/run/dmesg.boot#.

Για παράδειγμα, [.filename]#acd0# είναι ο πρώτος οδηγός IDE CDROM, ενώ το [.filename]#kbd0# αντιπροσωπεύει το πληκτρολόγιο.

Στις περισσότερες από αυτές τις συσκευές σε ένα λειτουργικό σύστημα UNIX(R) η πρόσβαση πρέπει να γίνεται διαμέσου ειδικών αρχείων που ονομάζονται αρχεία συσκευών, και είναι τοποθετημένα στον κατάλογο [.filename]#/dev#.

=== Δημιουργώντας Αρχεία Συσκευών

Όταν προσθέτετε μια νέα συσκευή στο σύστημα σας, ή μεταγλωττίζετε πηγαίο κώδικα για υποστήριξη νέων οδηγών, πρέπει να δημιουργούνται νέα αρχεία συσκευών.

==== `DEVFS` (DEVice File System)

Το σύστημα αρχείων συσκευών ή, `DEVFS`, παρέχει πρόσβαση στο χώρο ονομάτων συσκευών του πυρήνα (device namespace) στο global σύστημα αρχείων του συστήματος. Αντί να δημιουργείτε και να μετατρέπετε αρχεία συσκευών, το `DEVFS` συντηρεί για σας αυτό το ιδιαίτερο σύστημα αρχείων.

Δείτε την σελίδα βοηθείας man:devfs[5] για περισσότερες πληροφορίες.

[[binary-formats]]
== Τύποι Εκτελέσιμων

Για να καταλάβετε γιατί το FreeBSD χρησιμοποιεί τον τύπο man:elf[5] θα πρέπει πρώτα να γνωρίζετε μερικά πράγματα για τους τρεις "κυρίαρχους" τύπους εκτελέσιμων για το UNIX(R)

* man:a.out[5]
+ 
Ο παλαιότερος και πιο "κλασσικός" τύπος αντικειμένων του UNIX(R). Χρησιμοποιεί μια μικρή και συμπαγή κεφαλίδα με ένα μαγικό νούμερο στην αρχή που συχνά χρησιμοποιείται για να χαρακτηρίζει τον τύπο (δείτε για περισσότερες πληροφορίες την man:a.out[5]). Περιέχει τρία φορτωμένα τμήματα: .text, .data και .bss και επιπλέον ένα πίνακα συμβόλων και ένα πίνακα αλφαριθμητικών χαρακτήρων.
* COFF
+ 
Ο τύπος αντικειμένου SVR3. Η κεφαλίδα τώρα αποτελείται από ένα πίνακα τομέων, ώστε να μπορούμε να έχουμε κάτι παραπάνω από απλά .text, .data και .bss.
* man:elf[5]
+ 
Ο διάδοχος του COFF, περιλαμβάνει πολλαπλά τμήματα και δέχεται τιμές 32 ή 64 bit. Το βασικό μειονέκτημα: Ο ELF σχεδιάστηκε με την προϋπόθεση πως θα υπήρχε μόνο ένα ABI για κάθε αρχιτεκτονική συστήματος. Αυτή η υπόθεση είναι όμως εσφαλμένη τώρα, αφού ακόμη και στον εμπορικό κόσμο του SYSV (όπου υπάρχουν τουλάχιστον τρία ABI: SRV4, Solaris, SCO) δεν ισχύει.
+ 
Το FreeBSD προσπαθεί να ξεπεράσει αυτό το πρόβλημα παρέχοντας ένα βοηθητικό πρόγραμμα με το οποίο μπορούμε να _ενσωματώσουμε (branding)_ σε ένα εκτελέσιμο ELF τις πληροφορίες για το ABI που είναι συμβατό με αυτό. Δείτε την σελίδα manual του man:brandelf[1] για περισσότερες πληροφορίες.

Το FreeBSD προέρχεται από τον "κλασσικό" χώρο και μέχρι την αρχή της σειράς 3.X, χρησιμοποιούσε τον τύπο man:a.out[5], μια τεχνολογία δοκιμασμένη και αποδεδειγμένη σε πολλές γενιές εκδόσεων του BSD. Αν και η μεταγλώττιση και εκτέλεση εγγενών εκτελέσιμων (και πυρήνων) τύπου ELF ήταν δυνατή στα FreeBSD συστήματα ήδη από πολύ καιρό πριν, το FreeBSD αρχικά αντιστάθηκε στην "ώθηση" για καθιέρωση του ELF ως προκαθορισμένου τύπου. Γιατί; Όταν ο κόσμος του Λίνουξ έκανε την οδυνηρή μετάβαση προς το ELF, δεν ήταν τόσο για να ξεφύγει από τον τύπο εκτελέσιμων [.filename]#a.out# όσο για να αντιμετωπίσει το δύσκαμπτο δικό τους μηχανισμό κοινόχρηστων βιβλιοθηκών, ο οποίος βασίζονταν σε jump-tables και προκαλούσε μεγάλη δυσχέρεια στην κατασκευή τους, τόσο στους προγραμματιστές όσο και στους μεταπωλητές. Από τη στιγμή που τα διαθέσιμα εργαλεία του ELF προσέφεραν λύση στο πρόβλημα των κοινών βιβλιοθηκών και έγινε γενικώς αποδεκτό πως ήταν "ο δρόμος προς τα εμπρός", έγινε αποδεκτό το αναγκαίο κόστος της μεταφοράς και επιτεύχθηκε η μετακίνηση. Ο μηχανισμός κοινόχρηστων βιβλιοθηκών του FreeBSD βασίζεται σε μεγάλο βαθμό στον αντίστοιχο μηχανισμό του SunOS(TM) της Sun και είναι πολύ εύκολος στη χρήση.

Τότε, γιατί υπάρχουν τόσοι διαφορετικοί τύποι;

Πίσω στο σκοτεινό παρελθόν, υπήρχε απλό hardware. Αυτό το απλό hardware υποστήριζε ένα απλό, μικρό σύστημα. Το [.filename]#a.out# ήταν απόλυτα κατάλληλο για την αναπαράσταση εκτελέσιμων σε αυτό το απλό σύστημα (ένα PDP-11). Όταν ο κόσμος άρχισε να μεταφέρει το UNIX(R) από αυτό το απλό σύστημα, διατηρήθηκε ο τύπος [.filename]#a.out# γιατί ήταν ικανοποιητικός για τα πρώτα ports του UNIX(R) σε αρχιτεκτονικές όπως η Motorola 68k, VAXen, κτλ.

Μετέπειτα κάποιος λαμπρός μηχανικός hardware αποφάσισε πως αφού μπορούσε να εξαναγκάζει το λογισμικό να κάνει τόσα πρόχειρα κόλπα, θα μπορούσε επίσης να παραλείψει μερικές πύλες από το σχεδιασμό ώστε να επιτρέψει στον πυρήνα της CPU να τρέχει γρηγορότερα. Αν και διασκευάσθηκε ώστε να δουλεύει με αυτό το νέο είδος hardware (γνωστό σήμερα ως RISC), ο τύπος [.filename]#a.out# ήταν τελικά ακατάλληλος για αυτό, και έτσι σχεδιάστηκαν πολλοί νέοι τύποι για να επιτευχθεί καλύτερη απόδοση από το hardware από ότι ήταν δυνατόν με τον απλό και περιοριστικό τύπο [.filename]#a.out#. Εφευρέθηκαν διάφοροι τύποι όπως οι COFF, ECOFF, και μερικοί άλλοι λιγότερο γνωστοί, και ερευνήθηκαν οι περιορισμοί τους ώσπου τα πράγματα σταθεροποιήθηκαν στο ELF.

Επιπλέον, το μέγεθος των προγραμμάτων γινόταν όλο και μεγαλύτερο και οι δίσκοι (και η φυσική μνήμη) ήταν ακόμη σχετικά μικροί και κάπως έτσι γεννήθηκε η ιδέα της κοινής βιβλιοθήκης. Το σύστημα VM έγινε επίσης περισσότερο περίπλοκο. Κάθε μία από τις βελτιώσεις γινόταν με βάση τον τύπο [.filename]#a.out#, που όμως γινόταν όλο και πιο δύσχρηστος με κάθε νέα προσθήκη. Επιπρόσθετα, ο κόσμος ήθελε να φορτώνει τμήματα δυναμικά ενώ το σύστημα ήταν σε φάση εκτέλεσης, ή να εξαλείφει μέρη προγραμμάτων αφού είχε εκτελεστεί ο κώδικας αρχικοποίησης (init) ώστε να εξοικονομηθεί φυσική μνήμη και χώρος swap. Οι γλώσσες προγραμματισμού γινόντουσαν ακόμα πιο περίπλοκες και ο κόσμος ήθελε αυτόματη φόρτωση και εκτέλεση κώδικα πριν την κλήση της main. Έγιναν πρόχειρες διορθώσεις (hacks) στον τύπο [.filename]#a.out# ώστε να συμβαδίζει με όλες αυτές τις αλλαγές, και πράγματι, για μια περίοδο έδειχνε να λειτουργεί. Με τον καιρό όμως, φάνηκε ότι ο τύπος [.filename]#a.out# δεν θα μπορούσε να αντεπεξέλθει σε όλα αυτά τα προβλήματα, αφού θα έπρεπε να αναπτύσσεται συνεχώς και με περίπλοκο τρόπο. Αν και το ELF έλυνε πολλά από αυτά τα προβλήματα, η μετάβαση σε αυτό ενός συστήματος που βασικά λειτουργούσε, θα οδηγούσε σε οδυνηρές καταστάσεις. Έτσι ο τύπος ELF έπρεπε να περιμένει μέχρι τη στιγμή όπου η παραμονή στο [.filename]#a.out# θα δημιουργούσε περισσότερα προβλήματα από ότι η μετάβαση στο ELF.

Ωστόσο, όσο ο καιρός περνούσε, και τα εργαλεία μεταγλώττισης από τα οποία προέρχονται τα αντίστοιχα εργαλεία του FreeBSD (ειδικότερα ο assembler και ο loader), αναπτύχθηκαν παράλληλα σε δύο δέντρα. Το δέντρο του FreeBSD πρόσθεσε κοινές βιβλιοθήκες και διόρθωσε κάποια σφάλματα. Η ομάδα του GNU που είχε αρχικά γράψει αυτά τα προγράμματα, τα έγραψε ξανά και πρόσθεσε ευκολότερη υποστήριξη για κατασκευή cross compilers, την ενσωμάτωση διαφορετικών τύπων κατά βούληση, κλπ. Αν και πολλοί ζητούσαν να κατασκευαστούν cross compilers για FreeBSD, ήταν άτυχοι, αφού ο παλιός πηγαίος κώδικας του FreeBSD για τα as και ld τα έκανε ακατάλληλα. Η νέα αλυσίδα εργαλείων του GNU (binutils) υποστηρίζει cross compiling, ELF, κοινές βιβλιοθήκες, προεκτάσεις C++, κτλ. Επιπλέον, πολλοί τρίτοι κατασκευαστές προσφέρουν εκτελέσιμα ELF, και είναι πολύ καλό να μπορούν να εκτελεστούν στο FreeBSD.

Ο ELF είναι πιο εκφραστικός από τον [.filename]#a.out# και περισσότερο επεκτάσιμος στο βασικό σύστημα. Τα εργαλεία ELF είναι ευκολότερα στην συντήρηση και προσφέρουν υποστήριξη για cross compilers, κάτι που είναι πολύ σημαντικό για μερικούς ανθρώπους. Μπορεί ο ELF να είναι λίγο πιο αργός από τον [.filename]#a.out#, αλλά η διαφορά δεν είναι αισθητή. Υπάρχουν επίσης πολλές άλλες διαφορές μεταξύ τους, σε λεπτομέρειες όπως τον τρόπο που αντιστοιχίζουν σελίδες, που χειρίζονται τον κώδικα init, κλπ. Καμιά από αυτές δεν είναι πολύ σημαντική, αλλά ωστόσο δεν παύουν να είναι διαφορές. Με τον καιρό η υποστήριξη για το [.filename]#a.out# θα απομακρυνθεί από τον πυρήνα GENERIC, και τελικά θα αφαιρεθεί εντελώς από τον πυρήνα όταν εκλείψει ολοκληρωτικά η ανάγκη εκτέλεσης παλαιών προγραμμάτων τύπου [.filename]#a.out#.

[[basics-more-information]]
== Για Περισσότερες Πληροφορίες

[[basics-man]]
=== Σελίδες Βοηθείας

Η πιο κατανοητή τεκμηρίωση στο FreeBSD προσφέρεται με τη μορφή των σελίδων βοηθείας (manual pages). Σχεδόν για κάθε πρόγραμμα του συστήματος δίνεται μια σύντομη αναφορά που εξηγεί τις βασικές λειτουργίες και διάφορα άλλα θέματα. Αυτές οι σελίδες προβάλλονται με την εντολή `man`. Η χρήση της εντολής `man` είναι απλή:

[source,shell]
....
% man command
....

όπου `command` είναι το όνομα της εντολής για την οποία επιθυμείτε να μάθετε περισσότερες πληροφορίες. Για παράδειγμα, για να μάθετε περισσότερα για την εντολή `ls` πληκτρολογήστε:

[source,shell]
....
% man ls
....

Το online manual χωρίζεται σε τέσσερις αριθμημένες ενότητες:

. Εντολές χρήστη.
. Κλήσεις συστήματος και αριθμοί σφαλμάτων.
. Συναρτήσεις των βιβλιοθηκών της C.
. Οδηγοί συσκευών.
. Τύποι αρχείων.
. Παιχνίδια και άλλες εφαρμογές διασκέδασης.
. Διάφορες πληροφορίες.
. Συντήρηση συστήματος και εντολές λειτουργίας.
. Ανάπτυξη πυρήνα.

Σε μερικές περιπτώσεις, το ίδιο θέμα μπορεί να εμφανίζεται σε περισσότερες ενότητες των σελίδων βοηθείας. Για παράδειγμα, υπάρχει η εντολή χρήστη `chmod` και η κλήση συστήματος `chmod()`. Σε αυτή τη περίπτωση, μπορείτε να πείτε στην εντολή `man` ποια ακριβώς θέλετε επιλέγοντας την ενότητα:

[source,shell]
....
% man 1 chmod
....

Με αυτόν τον τρόπο θα εμφανιστεί η σελίδα βοηθείας για την εντολή χρήστη `chmod`. Οι αναφορές σε μια ειδική ενότητα των σελίδων βοηθείας τοποθετούνται παραδοσιακά μέσα σε παρένθεση στην τυπωμένη τεκμηρίωση, επομένως το man:chmod[1] αναφέρεται στην εντολή χρήστη `chmod` και το man:chmod[2] αναφέρεται στην κλήση συστήματος.

Αυτό είναι χρήσιμο όταν γνωρίζουμε το όνομα της εντολής και απλά επιθυμούμε να μάθουμε πως να την χρησιμοποιήσουμε, αλλά τι γίνεται αν δεν γνωρίζουμε το όνομα της; Μπορείτε να χρησιμοποιήσετε το `man` για να αναζητήσετε λέξεις κλειδιά από τις περιγραφές των εντολών χρησιμοποιώντας την επιλογή `-k`:

[source,shell]
....
% man -k mail
....

Με την εντολή αυτή θα εμφανιστεί μία λίστα από εντολές που περιέχουν την λέξη κλειδί "mail" στην περιγραφή τους. Αυτό είναι αντίστοιχο με το να χρησιμοποιήσετε την εντολή `apropos`.

Επομένως, βλέπετε όλες αυτές τις γουστόζικες εντολές στον [.filename]#/usr/bin# αλλά δεν έχετε την παραμικρή ιδέα του τι πραγματικά κάνουν; Απλά πληκτρολογήστε:

[source,shell]
....
% cd /usr/bin
% man -f *
....

ή

[source,shell]
....
% cd /usr/bin
% whatis *
....

το οποίο κάνει ακριβώς το ίδιο πράγμα.

[[basics-info]]
=== GNU Info Files

Το FreeBSD περιλαμβάνει πολλές εφαρμογές και βοηθητικά προγράμματα που έχουν δημιουργηθεί από την Free Software Foundation (FSF). Πέρα από τις σελίδες βοηθείας, τα προγράμματα αυτά παρέχονται με τεκμηρίωση μορφής hypertext σε αρχεία που ονομάζονται `info` και τα οποία μπορείτε να προβάλλετε με την εντολή `info` ή, αν έχετε εγκαταστήσει το emacs, μέσω της κατάστασης λειτουργίας info mode του emacs.

Για να χρησιμοποιήσετε την εντολή man:info[1], απλά πληκτρολογήστε:

[source,shell]
....
% info
....

Για μια σύντομη εισαγωγή, πληκτρολογήστε `h`. Για μια γρήγορη αναφορά εντολής, πληκτρολογήστε `?`.
