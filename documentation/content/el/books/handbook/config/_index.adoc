---
title: Κεφάλαιο 12. Ρύθμιση και Βελτιστοποίηση
part: Μέρος III. Διαχείριση Συστήματος
prev: books/handbook/partiii
next: books/handbook/boot
---

[[config-tuning]]
= Ρύθμιση και Βελτιστοποίηση
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:source-highlighter: rouge
:experimental:
:skip-front-matter:
:toc-title: Πίνακας Περιεχομένων
:table-caption: Πίνακας
:figure-caption: Σχήμα
:example-caption: Παράδειγμα
:xrefstyle: basic
:relfileprefix: ../
:outfilesuffix:
:sectnumoffset: 12

ifeval::["{backend}" == "html5"]
:imagesdir: ../../../images/books/handbook/config/
endif::[]

ifeval::["{backend}" == "pdf"]
:imagesdir: ../../../../static/images/books/handbook/config/
endif::[]

ifeval::["{backend}" == "epub3"]
:imagesdir: ../../../../static/images/books/handbook/config/
endif::[]

include::shared/authors.adoc[]
include::shared/releases.adoc[]
include::shared/el/mailing-lists.adoc[]
include::shared/el/teams.adoc[]
include::shared/el/urls.adoc[]

toc::[]

[[config-synopsis]]
== Σύνοψη

Ένα από τα σημαντικά χαρακτηριστικά του FreeBSD είναι η δυνατότητα ρύθμισης του συστήματος. Με τις σωστές ρυθμίσεις συστήματος είναι εύκολο να αποφευχθούν πολλά προβλήματα κατά τη διάρκεια μελλοντικών αναβαθμίσεων. Το κεφάλαιο αυτό θα εξηγήσει μεγάλο μέρος της διαδικασίας ρύθμισης του FreeBSD, συμπεριλαμβανομένων και κάποιων παραμέτρων που μπορούν να ρυθμιστούν για την βελτιστοποίηση της απόδοσης του συστήματος.

Αφού διαβάσετε αυτό το κεφάλαιο, θα ξέρετε:

* Πως να δουλέψετε αποδοτικά με συστήματα αρχείων και κατατμήσεις swap.
* Τα βασικά των συστημάτων ρύθμισης και εκκίνησης [.filename]#rc.conf# και [.filename]#/usr/local/etc/rc.d#.
* Πως να ρυθμίσετε και να δοκιμάσετε μια κάρτα δικτύου.
* Πως να ρυθμίσετε virtual hosts στις δικτυακές σας συσκευές.
* Πως να χρησιμοποιήσετε τα διάφορα αρχεία ρυθμίσεων στον κατάλογο [.filename]#/etc#.
* Πως να βελτιστοποιήσετε το FreeBSD χρησιμοποιώντας μεταβλητές `sysctl`.
* Πως να βελτιστοποιήσετε την απόδοση του δίσκου και να αλλάξετε τους περιορισμούς του πυρήνα.

Πριν διαβάσετε αυτό το κεφάλαιο, θα πρέπει:

* Να κατανοείτε βασικές έννοιες του UNIX(R) και του FreeBSD (crossref:basics[basics,Βασικές Έννοιες στο UNIX(R)]).
* Να είστε εξοικειωμένοι με τα βασικά της ρύθμισης και της μεταγλώττισης του πυρήνα (crossref:kernelconfig[kernelconfig,Ρυθμίζοντας τον Πυρήνα του FreeBSD]).

[[configtuning-initial]]
== Αρχική Ρύθμιση

=== Διάταξη Κατατμήσεων

==== Βασικές Κατατμήσεις

Όταν δημιουργείτε συστήματα αρχείων με το man:bsdlabel[8] ή το man:sysinstall[8], θυμηθείτε ότι οι σκληροί δίσκοι μεταφέρουν δεδομένα γρηγορότερα απο τα εξωτερικά μέροι τους στα εσωτερικά. Έτσι μικρότερα και περισσότερο προσβάσιμα συστήματα αρχείων πρέπει να είναι πλησιέστερα στο εξωτερικό του δίσκου, ενώ μεγαλύτερες κατατμήσεις όπως το [.filename]#/usr# πρέπει να τοποθετούνται πιο κοντά στο εσωτερικό του δίσκου. Είναι καλή ιδέα να δημιουργείτε κατατμήσεις με παρόμοια σειρά με αυτήν: root, swap, [.filename]#/var#, [.filename]#/usr#.

Το μέγεθος του [.filename]#/var# αντανακλά την επιδιωκούμενη χρήση του μηχανήματος. Το [.filename]#/var# χρησιμοποιείτε για την αποθήκευση των γραμματοκιβωτίων, των αρχείων καταγραφής και του spooler του εκτυπωτή. Τα γραμματοκιβώτια και τα αρχεία καταγραφής μπορούν να μεγαλώσουν σε απροσδόκητα μεγέθη ανάλογα με τον αριθμό των χρηστών του συστήματος και το χρονικό διάστημα που κρατούνται τα αρχεία καταγραφής. Σπάνια χρειάζεται το [.filename]#/var/tmp# να έχει πάνω από ένα gigabyte χώρο, αλλά καλό είναι να έχετε κατά νου ότι πρέπει να είναι αρκετά μεγάλο για να κρατάει τα πακέτα που θέλετε να εγκαταστήσετε.

Η κατάτμηση [.filename]#/usr# περιέχει τα περισσότερα αρχεία που απαιτούνται για την υποστήριξη του συστήματος, τη συλλογή των man:ports[7] (προτείνεται) και τον πηγαίο κώδικα (προαιρετικό). Και τα δύο αυτά είναι προαιρετικά κατα την εγκατάσταση. Τουλάχιστον 2 gigabytes προτείνονται για αυτή την κατάτμηση.

Όταν επιλέγετε μέγεθος για τις κατατμήσεις, να έχετε υπόψιν σας τις απαιτήσεις σε χώρο. Μπορεί να είναι λίγο πρόβλημα το να μείνετε χωρίς χώρο σε μια κατάτμηση ενώ χρησιμοποιείτε ελάχιστα μια άλλη.

[NOTE]
====
Μερικές φορές η επιλογή `Auto-defaults` του κατατμητή του man:sysinstall[8] μπορεί να επιλέξει πολύ μικρό μέγεθος για τις κατατμήσεις [.filename]#/var# και [.filename]#/#. Προσπαθείστε να επιλέξετε έξυπνα και γενναιόδωρα μεγέθη για τις κατατμήσεις σας.
====

[[swap-design]]
==== Swap Κατάτμηση

Ένας εμπειρικός κανόνας για να επιλέξετε μέγεθος για την κατάτμηση swap είναι: πρέπει να είναι περίπου διπλή απο το μέγεθος της μνήμης (RAM) του συστήματος. Για παράδειγμα, αν το μηχάνημα έχει 128 megabytes μνήμης, η κατάτμηση swap πρέπει να είναι 256 megabytes. Συστήματα με λιγότερη μνήμη μπορούν να αποδίδουν καλύτερα με περισσότερο swap. Λιγότερο απο 256 megabytes swap δεν προτείνεται και πρέπει να εξεταστεί η επέκταση της μνήμης. Οι αλγόριθμοι VM paging του πυρήνα είναι έτσι φτιαγμένοι ώστε να αποδίδουν καλύτερα όταν η κατάτμηση swap είναι τουλάχιστον δύο φορές το μέγεθος της κεντρικής μνήμης. Αν ρυθμίσετε πολύ μικρό swap, μπορεί να έχουν μειωμένη απόδοση οι αλγόριθμοι σάρωσης σελίδων του υποσυστήματος VM και μπορεί αργότερα να δημιουργηθούν προβλήματα αν προστεθεί περισσότερη φυσική μνήμη.

Σε μεγαλύτερα συστήματα με πολλαπλούς SCSI δίσκους (ή πολλαπλούς IDE δίσκους σε διαφορετικούς ελεγκτές), είναι προτιμότερο το swap να είναι ρυθμισμένο σε κάθε δίσκο (μέχρι τέσσερις δίσκους). Οι ξεχωριστές κατατμήσεις swap καλό είναι να έχουν περίπου το ίδιο μέγεθος. Ο πυρήνας μπορεί να χειριστεί αυθαίρετα μεγέθη swap, αλλά οι εσωτερικές δομές δεδομένων ρυθμίζονται με βάση το μέγεθος της μεγαλύτερης κατάτμησης swap. Κρατώντας την κατάτμηση swap σχεδόν στο ίδιο μέγεθος θα επιτρέψει στον πυρήνα να βελτιστοποιήσει την χρήση του swap, μοιράζοντας πιο καλά το φόρτο σε κάθε δίσκο. Δεν πειράζει να έχετε μεγάλο μέγεθος swap, ακόμα και αν δε χρησιμοποιείται αρκετά. Μπορεί να είναι ευκολότερη η ανάκαμψη απο ένα εκτός ελέγχου πρόγραμμα προτού χρειαστεί να επανεκκινήσετε το σύστημα.

==== Γιατί να φτιάξετε κατατμήσεις;

Αρκετοί χρήστες νομίζουν ότι μία μεγάλη κατάτμηση θα είναι εντάξει, αλλά υπάρχουν αρκετοί λόγοι γιατί αυτό είναι κακή ιδέα. Καταρχήν, κάθε κατάτμηση έχει διαφορετικά λειτουργικά χαρακτηριστικά, οπότε ξεχωρίζοντας τις κατατμήσεις επιτρέπουμε στο σύστημα αρχείων να εναρμονίζεται ανάλογα. Για παράδειγμα, οι root και [.filename]#/usr# κατατμήσεις είναι κυρίως για ανάγνωση, χωρίς πολλές εγγραφές. Αντίθετα, γίνονται πολλές αναγνώσεις και εγγραφές στις [.filename]#/var# και [.filename]#/var/tmp#.

Κάνοντας σωστή κατάτμηση σε ένα σύστημα, ο κατακερματισμός που συμβαίνει σε μικρότερες και περισσότερο εγγράψιμες κατατμήσεις δεν θα διαρρεύσει στις κατατμήσεις που διαβάζονται πιο συχνά από ότι γράφονται. Κρατώντας τις περισσότερο εγγράψιμες κατατμήσεις πιο κοντά στην άκρη του δίσκου, θα αυξηθεί η I/O απόδοση στις κατατμήσεις όπου και χρειάζεται πιο συχνά. Τώρα ενώ η απόδοση I/O χρειάζεται στις μεγαλύτερες κατατμήσεις, αλλάζοντας αυτές πιο κοντά στην άκρη του δίσκου δεν θα οδηγήσει σε σημαντική αύξηση της απόδοσης όσο το να μετακινήσετε την [.filename]#/var# στην άκρη. Τέλος, υπάρχει και θέμα ασφάλειας. Μία μικρή, προσεγμένη root κατάτμηση η οποία είναι διαβάζεται πιο συχνά από ότι γράφεται έχει μεγαλύτερη πιθανότητα να επιζήσει ενός άσχημου χτυπήματος.

[[configtuning-core-configuration]]
== Κύρια Ρύθμιση

Η κύρια τοποθεσία των πληροφοριών για την ρύθμιση του συστήματος βρίσκεται μέσα στο [.filename]#/etc/rc.conf#. Αυτό το αρχείο περιέχει ένα ευρύ φάσμα ρυθμίσεων, κυρίως χρησιμοποιούμενες στην εκκίνηση του συστήματος για την ρύθμιση του συστήματος. Το όνομα του απευθείας συνεπάγεται αυτό; είναι ρυθμίσεις για τα αρχεία [.filename]#rc*#.

Ένας διαχειριστής πρέπει να δημιουργήσει εγγραφές μέσα στο αρχείο [.filename]#rc.conf# ώστε να αντικαταστήσει τις προεπιλεγμένες ρυθμίσεις απο το αρχείο [.filename]#/etc/defaults/rc.conf#. Το αρχείο προεπιλογών δεν πρέπει να αντιγραφεί αυτολεξεί στο [.filename]#/etc# - αυτό περιέχει προεπιλεγμένες τιμές, όχι παραδείγματα. Όλες οι αλλαγές που αφορούν το σύστημα πρέπει να γίνουν στο αρχείο [.filename]#rc.conf# αποκλειστικά.

Ένας αριθμός στρατηγικών μπορεί να εφαρμοστεί σε ένα σύνολο εφαρμογών για να ξεχωρίσουμε ρυθμίσεις του ευρύ συνόλου απο τις ρυθμίσεις επικεντρωμένες για ένα σύστημα για να κρατήσουμε τον φόρτο διαχείρισης χαμηλά. Η προτεινόμενη προσέγγιση είναι να τοποθετούμε τις ρυθμίσεις ευρύ συνόλου σε ένα διαφορετικό αρχείο, όπως το [.filename]#/etc/rc.conf.site#, και τότε να συμπεριλάβουμε το αρχείο αυτό στο [.filename]#/etc/rc.conf#, το οποίο θα περιέχει πληροφορίες επικεντρωμένες για ένα σύστημα.

Μιάς και το [.filename]#rc.conf# διαβάζεται απο το man:sh[1] είναι εύκολο να το επιτύχουμε αυτό. Για παράδειγμα:

* rc.conf:
+
[.programlisting]
....
	. /etc/rc.conf.site
	hostname="node15.example.com"
	network_interfaces="fxp0 lo0"
	ifconfig_fxp0="inet 10.1.1.1"
....

* rc.conf.site:
+
[.programlisting]
....
	defaultrouter="10.1.1.254"
	saver="daemon"
	blanktime="100"
....

Το αρχείο [.filename]#rc.conf.site# μπορεί έπειτα να διανεμηθεί σε κάθε σύστημα χρησιμοποιώντας το `rsync` ή κάποιο παρόμοιο πρόγραμμα, ενώ το αρχείο [.filename]#rc.conf# παραμένει μοναδικό.

Αναβαθμίζοντας το σύστημα χρησιμοποιώντας man:sysinstall[8] ή `make world` δεν θα αντικαταστήσει το αρχείο [.filename]#rc.conf#, έτσι οι ρυθμίσεις δεν θα χαθούν.

[[configtuning-appconfig]]
== Ρύθμιση Εφαρμογών

Τυπικά, οι εγκατεστημένες εφαρμογές έχουν τα δικά τους αρχεία ρυθμίσεων, με το δικό τους τρόπο σύνταξης, κτλπ. Είναι σημαντικό αυτά τα αρχεία να κρατούνται ξεχωριστά απο το βασικό σύστημα, έτσι ώστε να είναι εύκολα εντοπίσιμα και διαχειρίσιμα απο τα εργαλεία διαχείρισης πακέτων.

Τυπικά, αυτά τα αρχεία είναι εγκατεστημένα στο [.filename]#/usr/local/etc#. Σε αυτή την περίπτωση όταν μία εφαρμογή έχει μεγάλο αριθμό αρχείων ρυθμίσεων, ένας υποκατάλογος δημιουργείται για να τα αποθηκεύσει.

Κανονικά, όταν ένα port ή ένα package εγκαθιστάτε, παραδείγματα αρχείων ρυθμίσεων εγκαθιστάνται επίσης. Αυτά είναι συνήθως αναγνωρίσιμα απο την [.filename]#.default# κατάληξη τους. Αν δεν υπάρχουν αρχεία ρυθμίσεων για την εφαρμογή, τότε θα δημιουργηθούν κάνοντας αντιγραφή τα [.filename]#.default# αρχεία.

Για παράδειγμα, έχετε υπόψη σας τα περιεχόμενα του καταλόγου [.filename]#/usr/local/etc/apache#:

....
-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf
-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf.default
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf.default
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic.default
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types.default
-rw-r--r--  1 root  wheel   7980 May 20  1998 srm.conf
-rw-r--r--  1 root  wheel   7933 May 20  1998 srm.conf.default
....

Τα μεγέθοι των αρχείων δείχνουν ότι μόνο το αρχείο [.filename]#srm.conf# έχει αλλάξει. Μία μετέπειτα αναβάθμιση του port της εφαρμογής Apache δεν θα αντικαταστήσει το αλλαγμένο αρχείο.

[[configtuning-starting-services]]
== Eκκινώντας Υπηρεσίες

Πολλοί χρήστες επιλέγουν να εγκαταστήσουν λογισμικό απο τρίτους κατασκευαστές στο FreeBSD απο την συλλογή των Ports. Σε πολλές απο αυτές τις περιπτώσεις μπορεί να είναι απαραίτητο να ρυθμίσουν το λογισμικό με τέτοιο τρόπο ώστε να μπορεί να επιτραπεί η εκκίνηση του κατα την εκκίνηση του συστήματος. Υπηρεσίες, όπως το package:mail/postfix[] ή το package:www/apache13[] είναι μόνο δύο απο τα πολλά πακέτα λογισμικού που μπορεί να χρειάζονται να εκκινηθούν κατά την εκκίνηση του συστήματος. Το μέρος αυτό θα εξηγήσει τις διαθέσιμες διαδικασίες για την εκκίνηση λογισμικού προερχόμενο απο τρίτους κατασκευαστές.

Στο FreeBSD, οι περισσότερες περιεχόμενες υπηρεσίες, όπως το man:cron[8], είναι εκκινήσιμες μέσα από τα σενάρια εκκίνησης του συστήματος. Τα σενάρια αυτά μπορεί να διαφέρουν ανάλογα το FreeBSD ή την έκδοση του κατασκευαστή; ωστόσο, η πιο σημαντική πτυχή που πρέπει να εξεταστεί είναι ότι οι ρυθμίσεις εκκίνησης τους μπορούν να χειριστούν μέσα απο ένα απλό σενάριο εκκίνησης.

Πριν την έλευση του [.filename]#rc.d#, οι εφαρμογές μπορούσαν να τοποθετήσουν ένα απλό σενάριο εκκίνησης μέσα στον κατάλογο [.filename]#/usr/local/etc/rc.d# ο οποίος μπορούσε να διαβαστεί απο τα σενάρια εκκίνησης του συστήματος. Αυτά τα σενάρια μπορούσαν να εκτελεστούν κατα τα μετέπειτα στάδια εκκίνησης του συστήματος.

Ενώ πολλοί ιδιώτες ξόδευαν χρόνο προσπαθώντας να συνχωνεύσουν το παλιό στυλ ρυθμίσεων με το νέο στυλ, παραμένει γεγονός ότι μερικά προγράμματα ακόμα απαιτούν ένα σενάριο να τοποθετηθεί μέσα στον προαναφερθέντα κατάλογο. Οι λεπτές διαφορές ανάμεσα στα σενάρια εξαρτώνται από το αν ή όχι ο [.filename]#rc.d# χρησιμοποιείτε. Προγενέστερα του FreeBSD 5.1 το παλιό στυλ ρυθμίσεων χρησιμοποιούνταν και σχεδόν σε όλες τις περιπτώσεις ένα νέου στυλ σενάριο θα είναι συμβατό.

Ενώ κάθε σενάριο πρέπει να τηρεί ορισμένες ελάχιστες απαιτήσεις, τις περισσότερες φορές αυτές οι απαιτήσεις είναι ανεξάρτητες της έκδοσης του FreeBSD. Κάθε σενάριο πρέπει να έχει μια [.filename]#.sh# επέκταση προσαρτημένη στο τέλος του και κάθε σενάριο πρέπει να είναι εκτελέσιμο απο το σύστημα. Το δεύτερο μπορεί να επιτευχθεί χρησιμοποιώντας την `chmod` εντολή και ρυθμίζοντας την άδεια `755`. Εκεί πρέπει να υπάρχει, τουλάχιστον, μια επιλογή `start` και μία επιλογή `stop` για την εφαρμογή.

Το πιο απλό σενάριο εκκίνησης πιθανότατα να μοιάζει με το παρακάτω:

[.programlisting]
....
#!/bin/sh
echo -n ' utility'

case "$1" in
start)
        /usr/local/bin/utility
        ;;
stop)
        kill -9 `cat /var/run/utility.pid`
        ;;
*)
        echo "Usage: `basename $0` {start|stop}" >&2
        exit 64
        ;;
esac

exit 0
....

Το σενάριο αυτό παρέχει μια `stop` και μια `start` επιλογή για την εφαρμογή όπου στο παράδειγμα εδώ αναφέρεται σαν `utility`.

Μπορεί να εκκινηθεί χειρωνακτικά κάνοντας:

[source,bash]
....
# /usr/local/etc/rc.d/utility.sh start
....

Παρόλο που δεν απαιτούν όλες οι εφαρμογές να προστεθεί μία εγγραφή στο [.filename]#rc.conf#, σχεδόν καθημερινά και ένα νέο port θα τροποποιήτε για να δέχεται αυτή την ρύθμιση. Ελέγξετε την τελική έξοδο της εγκατάστασης για περισσότερες πληροφορίες πάνω στην συγκεκριμένη εφαρμογή. Μερικές εφαρμογές απο τρίτους κατασκευαστές παρέχουν σενάρια εκκίνησης τα οποία επιτρέπουν στην εφαρμογή να χρησιμοποιηθεί με το [.filename]#rc.d#, παρόλα αυτα, αυτό θα συζητηθεί στο επόμενο μέρος.

=== Εκτεταμένη Ρύθμιση Εφαρμογών

Πλέον το FreeBSD περιέχει το [.filename]#rc.d#, η ρύθμιση της εκκίνησης των εφαρμογών έχει γίνει ευκολότερη, και πιο πλούσια σε χαρακτηρικά. Χρησιμοποιώντας λέξεις κλειδία μέσα στον κατάλογο <<configtuning-rcd,rc.d>>, οι εφαρμογές μπορούν πλέον να εκκινούν έπειτα απο συγκεκριμένες υπηρεσίες για παράδειγμα την DNS, μπορεί να επιτραπεί η εισαγωγή επιπλέον παραμέτρων μέσα απο το [.filename]#rc.conf# στην θέση των ήδη υπάρχoντον παραμέτρων απο τα σενάρια εκκινήσης, κτλπ. Ένα βασικό σενάριο μπορεί να μοιάζει με το ακόλουθο:

[.programlisting]
....
#!/bin/sh
#
# PROVIDE: utility
# REQUIRE: DAEMON
# KEYWORD: shutdown

. /etc/rc.subr

name=utility
rcvar=utility_enable

command="/usr/local/sbin/utility"

load_rc_config $name

#
# DO NOT CHANGE THESE DEFAULT VALUES HERE
# SET THEM IN THE /etc/rc.conf FILE
#
utility_enable=${utility_enable-"NO"}
pidfile=${utility_pidfile-"/var/run/utility.pid"}

run_rc_command "$1"
....

Το σενάριο αυτό θα εξασφαλίσει ότι το πρόγραμμα utility θα εκκινηθεί μετά απο την `daemon` υπηρεσία. Θα εξασφαλίσει επιπλέον έναν τρόπο για την ρύθμιση και τον εντοπισμό του PID, ή του αρχείου του ID της διεργασίας.

Η εφαρμογή μπορεί πλέον να έχει την παρακάτω γραμμή τοποθετημένη στο [.filename]#/etc/rc.conf#:

[.programlisting]
....
utility_enable="YES"
....

Ο νέος αυτός τρόπος επιτρέπει επιπλέον τον ευκολότερο χειρισμό των παραμέτρων της γραμμής εντολών, σε συνδυασμό με τις προυπάρχουσες λειτουργίες παρεχόμενες απο το [.filename]#/etc/rc.subr#, τη συμβατότητα με το βοηθητικό πρόγραμμα man:rcorder[8] και επιπλέον την ευκολότερη ρύθμιση μέσω του [.filename]#rc.conf# αρχείου.

=== Χρησιμοποιώντας Υπηρεσίες Για Την Εκκίνηση Υπηρεσιών

Άλλες υπηρεσίες, όπως ο δαίμονας του εξυπηρετή POP3, IMAP, κτλπ. μπορούν να εκκινηθούν χρησιμοποιώντας το man:inetd[8]. Αυτό απαιτεί την εγκατάσταση του βοηθητικού προγράμματος υπηρεσιών απο την Ports συλλογή και μια γραμμή ρυθμίσεων προσαρτημένη στο αρχείο [.filename]#/etc/inetd.conf#, ή αποχαρακτηρίζοντας μια απο τις ήδη υπάρχουσες γραμμές ρυθμίσεων. Δουλεύοντας με το inetd και τις ρυθμίσεις του περιγράφεται αναλυτικά στο μέρος crossref:network-servers[network-inetd,inetd].

Σε πολλές περιπτώσεις, είναι εύλογο να χρησιμοποιείτε ο δαίμονας man:cron[8] για την εκκίνηση των υπηρεσιών του συστήματος. Η προσέγγιση αυτή έχει έναν αριθμό πλεονεκτημάτων γιατί το `cron` τρέχει τις διεργασίες σαν ιδιοκτήτης του [.filename]#crontab# αρχείου. Αυτό επιτρέπει στους κανονικούς χρήστες να εκκινούν και να διαχειρίζονται μερικές εφαρμογές.

Το βοηθητικό πρόγραμμα `cron` παρέχει ένα μοναδικό χαρακτηριστικό, το `@reboot`, το οποίο μπορεί να χρησιμοποιηθεί στην θέση του χρονικού ορισμού. Αυτό θα κάνει την εργασία να τρέξει όταν το man:cron[8] εκκινηθεί, συνήθως κατά την εκκίνηση του συστήματος.

[[configtuning-cron]]
== Ρυθμίζοντας Το Πρόγραμμα `cron`

Ένα απο τα πιο χρήσιμα βοηθητικά προγράμματα στο FreeBSD είναι το man:cron[8]. Το πρόγραμμα `cron` τρέχει στο παρασκήνιο και συνεχώς ελέγχει το αρχείο [.filename]#/etc/crontab#. Το `cron` ελέγχει επίσης τον κατάλογο [.filename]#/var/cron/tabs#, αναζητώντας καινούργια αρχεία [.filename]#crontab#. Τα αρχεία [.filename]#crontab# έχουν αποθηκευμένες πληροφορίες για συγκεκριμένες διαδικασίες τις οποίες το `cron` πρέπει να εκτελέσει σε συγκεκριμένο χρόνο.

Το `cron` χρησιμοποιεί δύο διαφορετικούς τύπους αρχείων ρυθμίσεων, το crontab του συστήματος και το crontab των χρηστών. Η μόνη διαφορά ανάμεσα στους δύο αυτούς τύπους είναι το έκτο πεδίο. Στο crontab του συστήματος, το έκτο πεδίο είναι το όνομα του χρήστη με του οποίου θα εκτελεστεί η εντολή. Αυτό δίνει την δυνατότητα στο crontab του συστήματος να εκτελεί εντολές σαν οποιοδήποτε χρήστης. Στο crontab των χρηστών, το έκτο πεδίο είναι η εντολή που πρέπει να εκτελεστεί, και όλες οι εντολές εκτελούνται στο όνομα του χρήστη που δημιούργησε το crontab; αυτό είναι ένα σημαντικό χαρακτηριστικό ασφαλείας.

[NOTE]
====
Τα crontabs των χρηστών επιτρέπουν σε μεμονωμένους χρήστες να προγραμματίσουν εργρασίες χωρίς την ανάγκη `root` δικαιωμάτον. Οι εντολές μέσα στο crontab ενός χρήστη τρέχουν με τα δικαιώματα του χρήστη του οποίου ανήκει το crontab.

Ο χρήστης `root` μπορεί να έχει ένα crontab χρήστη ακριβώς όπως κάθε χρήστης. Αυτό είναι διαφορετικό απο το [.filename]#/etc/crontab# (το crontab του συστήματος). Λόγο του crontab του συστήματος, δεν υπάρχει συνήθως καμία ανάγκη για την δημιουργία ενός ξεχωριστού crontab για τον χρήστη `root`.
====

Ας ρίξουμε μια ματία στο αρχείο [.filename]#/etc/crontab# (το crontab του συστήματος):

[.programlisting]
....
# /etc/crontab - root's crontab for FreeBSD
#
# $FreeBSD: src/etc/crontab,v 1.32 2002/11/22 16:13:39 tom Exp $
## <.>
#
SHELL=/bin/sh
PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin <.>
HOME=/var/log
#
#
#minute	hour	mday	month	wday	who	command <.>
#
#
*/5	*	*	*	*	root	/usr/libexec/atrun <.>
....

<.> Όπως στα περισσότερα αρχεία ρυθμίσεων στο FreeBSD, ο χαρακτήρας `#` παριστάνει ένα σχόλιο. Ένα σχόλιο μπορεί να τοποθετηθεί μέσα στο αρχείο σαν υπενθύμιση για το τι πραγματοποιεί και γιατί μία ενέργεια. Τα σχόλια δεν μπορούν να είναι στην ίδια γραμμή με μία εντολή γιατί αλλιώς θα ερμηνευτούν σαν κομμάτι της εντολής; πρέπει να είναι σε μία νέα γραμμή. Οι κενές γραμμές αγνοούνται.

<.> Καταρχήν, πρέπει να καθοριστεί το περιβάλλον. Ο χαρακτήρας ίσον (`=`) χρησιμοποιείτε για να καθορίσει τις ρυθμίσεις του περιβάλλοντος, όπως σε αυτό το παράδειγμα που χρησιμοποιούνται οι μεταβλητές `SHELL`, `PATH`, και `HOME`. Αν η γραμμή του κέλυφους παραμεληθεί, το `cron` θα χρησιμοποιήσει την προεπιλεγμένη, οι οποία είναι η `sh`. Αν η μεταβλητή `PATH` παραμεληθεί, δεν θα χρησιμοποιηθεί προεπιλεγμένη και η τοποθεσίες των αρχείων θα πρέπει να καθοριστούν με ακρίβεια. Αν η `HOME` παραμεληθεί, το `cron` θα χρησιμοποιήσει τον κεντρικό κατάλογο των εκάστοτε χρηστών.

<.> Η γραμμή αυτή καθορίζει συνολικά επτά πεδία. Τα πεδία αυτά είναι τα `minute`, `hour`, `mday`, `month`, `wday`, `who`, και `command`. Αυτά είναι απο μόνα τους επεξηγηματικά. Το πεδίο `minute` είναι ο χρόνος σε λεπτά τον οποίον η εντολή θα εκτελεστεί. Το πεδίο `hour` είναι παρόμοιο με το πεδίο `minute`, απλά είναι σε ώρες. Το πεδίο `mday` καθορίζει την ημέρα του μήνα. Το πεδίο `month` είναι παρόμοιο με το πεδίο `hour` και το πεδίο `minute`, υποδεικνύοντας τον μήνα. Το πεδίο `wday` καθορίζει την ημέρα της εβδομάδας. Όλα αυτά τα πεδία πρέπει να έχουν αριθμητικές τιμές, και να ακολουθούν το είκοσι-τετράωρο ρολόι. Το πεδίο `who` είναι ιδιαίτερο, και υπάρχει μόνο μέσα στο αρχείο [.filename]#/etc/crontab#. Το πεδίο αυτό καθορίζει σαν ποιός χρήστης θα τρέξει την εντολή. Όταν ένας χρήστης εγκαθιστά το [.filename]#crontab# αρχείο του, δεν θα έχει το πεδίο αυτό διαθέσιμο. Τέλος, θα ακολουθήσει η επιλογή `command`. Αυτό είναι το τελευταίο πεδίο, έτσι και λογικά υποδεικνύει την εντολή που θα εκτελεστεί.

<.> Η τελευταία αυτή γραμμή θα καθορίσει τα μεγέθοι που συζητήθηκαν παραπάνω. Προσέξτε εδώ ότι έχουμε έναν ορισμό `\*/5`, ακολουθούμενο απο αρκετούς χαρακτήρες `*`. Οι χαρακτήρες `*` σημαίνουν "πρώτο-τελευταίο", και μπορούν να ερμηνευθούν σαν _κάθε_ φορά. Έτσι, κρίνοντας απο αυτή την γραμμή, είναι προφανές ότι η εντολή `atrun` επικαλείται απο τον χρήστη `root` κάθε πέντε λεπτά ανεξάρτητα απο την ημέρα και τον μήνα. Για περισσότερες πληροφορίες σχετικά με την εντολή `atrun`, κοιτάξτε την σελίδα βοηθείας man:atrun[8].Οι εντολές μπορούν να έχουν απεριόριστο αριθμό παραμέτρων, ωστόσο, οι εντολές με εκτεταμένο αριθμό γραμμών πρέπει να διασπαστούν με τον χαρακτήρα συνέχειας αντίθετης καθέτου "\".

Αυτές είναι οι βασικές ρυθμίσεις για κάθε αρχείο [.filename]#crontab#, ωστόσο υπάρχει και κάτι διαφορετικό. Το πεδίο έξι, όπου και καθορίζουμε το όνομα χρήστη, υπάρχει μόνο στο αρχείο του συστήματος [.filename]#/etc/crontab#. Το πεδίο αυτό πρέπει να παραλειφθεί για κάθε [.filename]#crontab# αρχείο χρήστη.

[[configtuning-installcrontab]]
=== Εγκαθιστώντας Ένα Crontab

[IMPORTANT]
====
Δεν θα πρέπει να χρησιμοποιήσετε την διαδικασία που περιγράφεται εδώ για την διόρθωση/εγκατάσταση του crontab του συστήματος. Απλά χρησιμοποιήστε τον αγαπημένο σας κειμενογράφο: το `cron` θα εντοπίσει ότι το αρχείο έχει τροποποιηθεί και θα αρχίσει άμεσα να χρησιμοποιεί την ανανεωμένη έκδοση του. Δείτε link:{faq}#ROOT-NOT-FOUND-CRON-ERRORS[αυτή την εγγραφή του FAQ ] για περισσότερες πληροφορίες.
====

Για να εγκαταστήσετε ένα νέο [.filename]#crontab# χρήστη, πρώτα χρησιμοποιήστε τον αγαπημένο σας κειμενογράφο για να δημιουργήσετε ένα αρχείο με το απαιτούμενο τύπο, και τότε χρησιμοποιήστε το `crontab`. Η πιο κοινή χρήση του είναι:

[source,bash]
....
% crontab crontab-file
....

Στο παράδειγμα αυτό, το αρχείο [.filename]#crontab-file# είναι το όνομα του αρχείου [.filename]#crontab# που είχε δημιουργηθεί προηγουμένως.

Υπάρχει επίσης μία επιλογή για να απαριθμήσετε τα εγκατεστημένα αρχεία [.filename]#crontab#: απλά εισάγετε την επιλογή `-l` στην εντολή `crontab` και ελέγξτε το αποτέλεσμα.

Για τους χρήστες που θέλουν να αρχίσουν το crontab αρχείο τους απο την αρχή, χωρίς την χρήση προτύπου, μπορούν να χρησιμοποιήσουν την εντολή `crontab -e`. Αυτή η εντολή θα ξεκινήσει τον κειμενογράφο με ένα κενό αρχείο. Όταν το αρχείο αποθηκευθεί, θα εγκατασταθεί αυτόματα απο την εντολή `crontab`.

Αν αργότερα θέλετε να διαγράψετε το [.filename]#crontab# αρχείο χρήστη τελείως, χρησιμοποιήστε την εντολή `crontab` μαζί με την επιλογή `-r`. 

[[configtuning-rcd]]
== Χρησιμοποιώντας Το Σύστημα rc Στο FreeBSD

Το 2002 το FreeBSD ενσωμάτωσε το σύστημα [.filename]#rc.d# του NetBSD για την εκκίνηση του συστήματος. Οι χρήστες θα πρέπει να έχουν αντιληφθεί τα αρχεία που βρίσκονται στον κατάλογο [.filename]#/etc/rc.d#. Πολλά απο αυτά τα αρχεία είναι για τις βασικές υπηρεσίες και μπορούν να ελεγθούν με τις επιλογές `start`, `stop`, και `restart`. Για παράδειγμα, το man:sshd[8] μπορεί να ελεγθεί χρησιμοποιώντας την εξής εντολή:

[source,bash]
....
# /etc/rc.d/sshd restart
....

Η διαδικασία αυτή είναι παρόμοια και για τις υπόλοιπες υπηρεσίες. Φυσικά, οι υπηρεσίες αυτές είναι συνήθως αυτόματα εκκινήσιμες κατα την εκκίνηση του συστήματος όπως και καθορίζεται στο man:rc.conf[5]. Για παράδειγμα, ενεργοποιώντας τον δαίμονα Network Address Translation στην εκκίνηση είναι τόσο απλό όσο κάνοντας προσθήκη της ακόλουθης γραμμής στο [.filename]#/etc/rc.conf#:

[.programlisting]
....
natd_enable="YES"
....

Αν η επιλογή `natd_enable="NO"` είναι ήδη παρούσα, τότε απλά αλλάζετε την επιλογή `NO` σε `YES`. Τα σενάρια rc θα φορτώσουν αυτόματα οποιαδήποτε εξαρτώμενη υπηρεσία κατά την διάρκεια της επόμενης εκκίνησης, όπως και περιγράφεται παρακάτω.

Μιας και το σύστημα [.filename]#rc.d# είναι κυρίως για την εκκίνηση και τον τερματισμό υπηρεσιών κατα την εκκίνηση και τον τερματισμό του συστήματος αντίστοιχα, οι προκαθορισμένες επιλογές `start`, `stop` και `restart` θα πραγματοποιήσουν τις αντίστοιχες ενέργειες αν η κατάλληλες μεταβλητές είναι καθορισμένες στο [.filename]#/etc/rc.conf#. Για παράδειγμα η παραπάνω εντολή `sshd restart` θα δουλέψει μόνο αν η μεταβλητή `sshd_enable` έχει τεθεί σε `YES` μέσα στο [.filename]#/etc/rc.conf#. Για να εκτελέσετε τις επιλογές `start`, `stop` ή `restart` μιας υπηρεσίας ανεξάρτητα απο τις ρυθμίσεις της στο [.filename]#/etc/rc.conf#, η εντολή πρέπει να έχει χαρακτηριστεί με "one". Για παράδειγμα για την επανεκκίνηση του `sshd` ανεξάρτητα απο τις τρέχουσες ρυθμίσεις στο [.filename]#/etc/rc.conf#, εκτελείτε την ακόλουθη εντολή:

[source,bash]
....
# /etc/rc.d/sshd onerestart
....

Είναι εύκολο να ελέγξετε αν η υπηρεσία είναι ενεργοποιημένη στο [.filename]#/etc/rc.conf# τρέχοντας το κατάλληλο σενάριο [.filename]#rc.d# με την παράμετρο `rcvar`. Κατά συνέπεια, ένας διαχειριστής μπορεί να ελέγξει αν το `sshd` είναι όντως ενεργοποιημένο στο [.filename]#/etc/rc.conf# εκτελώντας:

[source,bash]
....
# /etc/rc.d/sshd rcvar
# sshd
$sshd_enable=YES
....

[NOTE]
====
Η δεύτερη γραμμή (`# sshd`) είναι η έξοδος της εντολής `sshd`, και όχι η κονσολά του χρήστη `root`.
====

Για να ελέγξετε αν μια υπηρεσία τρέχει, η επιλογή `status` είναι διαθέσιμη. Για παράδειγμα για να επιβεβαιώστε ότι η υπηρεσία `sshd` τρέχει:

[source,bash]
....
# /etc/rc.d/sshd status sshd is
      running as pid 433.
....

Σε πολλές περιπτώσεις είναι δυνατόν το `reload` μίας υπηρεσίας. Αυτό θα στείλει ένα σήμα στην υπηρεσία, επιβάλλοντας της να ξαναφορτώσει τα αρχεία ρυθμίσεων της. Στην πραγματικότητα αυτό σημαίνει ότι θα στείλει ένα σήμα `SIGHUP` στην υπηρεσία. Η υποστήριξη για αυτό το χαρακτηριστικό δεν παρέχεται σε κάθε υπηρεσία.

Το σύστημα [.filename]#rc.d# δεν χρησιμοποιείτε μόνο για τις υπηρεσίες δικτύου, αλλά επίσης συμβάλει και κατα την εκκίνηση του συστήματος. Για παράδειγμα, σκεφτείτε το αρχείο [.filename]#bgfsck#. Όταν ένα σενάριο εκτελείτε, θα εκτυπώνει το ακόλουθο μήνυμα:

[source,bash]
....
Starting background file system checks in 60 seconds.
....

Επομένος το αρχείο αυτό χρησιμοποιείτε στο παρασκήνιο για τον έλεγχο του συστήματος αρχείων, ο οποίος και συμβαίνει κατα στην εκκίνηση του συστήματος.

Πολλές υπηρεσίες εξαρτώνται από άλλες υπηρεσίες για να τα καταφέρουν να λειτουργήσουν σωστά. Για παράδειγμα, η υπηρεσία NIS και άλλες βασισμένες στο RPC υπηρεσίες θα αποτύχουν να εκκινηθούν αν η υπηρεσία `rpcbind` (portmapper) δεν έχει ήδη εκκινηθεί. Για να λύθει το πρόβλημα αυτό, υπάρχουν πληροφορίες για τις εξαρτήσεις και άλλα μετα-δεδομένα μέσα στα σχόλια στην αρχή κάθε σεναρίου. Το πρόγραμμα man:rcorder[8] χρησιμοποιείτε για την ανάλυση των σχολίων αυτών κατά την εκκίνηση του συστήματος για να καθορίστει με ποιά σειρά θα πρέπει να εκκινηθούν οι υπηρεσίες ώστε να εκπληρωθούν οι εξαρτήσεις. Οι επόμενες προτάσεις μπορούν να περιληφθούν μέσα σε κάθε αρχείο εκκίνησης:

* `PROVIDE`: Καθόριζει την υπηρεσία που παρέχει το αρχείο αυτό.
* `REQUIRE`: Απαριθμεί τις υπηρεσίες που απαιτούνται για την την υπηρεσία αυτή. Το αρχείο αυτό θα εκτελεστεί _μετά_ απο την καθορισμένη υπηρεσία.
* `BEFORE`: Απαριθμεί τις υπηρεσίες οι οποίες εξαρτώνται απο την υπηρεσία αυτή. Το αρχείο αυτό θα εκτελεστεί _πρίν_ τις καθορισμένες υπηρεσίες.

Χρησιμοποιώντας την μέθοδο αυτή, οι διαχειριστές μπορούν εύκολα να ελέγξουν τις υπηρεσίες του συστήματος χωρίς τα δυσνόητα "runlevels" όπως σε μερικά άλλα λειτουργικά συστήματα UNIX(R).

Επιπλέον πληροφορίες για το σύστημα [.filename]#rc.d# μπορούν να βρεθούν στις σελίδες βοηθείας man:rc[8] και man:rc.subr[8]. Αν ενδιαφέρεστε για την εγγραφή δικών σας σεναρίων [.filename]#rc.d# ή για την βελτίωση των ήδη υπάρχοντων, θα βρείτε link:{rc-scripting}[τον σύνδεσμο αυτόν] αρκετά χρήσιμο.

[[config-network-setup]]
== Ρυθμίζοντας Τις Κάρτες Δικτύου

Την σήμερον εποχή δεν μπορούμε να σκεφτούμε έναν υπολογιστή χωρίς να σκεφτούμε και μία σύνδεση δικτύου. Προσθέτοντας και ρυθμίζοντας μια κάρτα δικτύου είναι μία συνηθισμένη εργασία για έναν οποιοδήποτε διαχειριστή του FreeBSD.

=== Εντοπίζοντας Τον Σωστό Οδηγό

Πριν αρχίσετε, θα πρέπει να γνωρίζετε το μοντέλο της κάρτας που έχετε, ποιό chip χρησιμοποιεί, και αν είναι PCI ή ISA κάρτα. Το FreeBSD υποστηρίζει ένα μεγάλο εύρος καρτών PCI και ISA. Ελέγξτε την Λίστα Συμβατότητας Υλικού για την έκδοση σας για να δείτε αν η κάρτα σας υποστηρίζεται.

Εφόσον είστε πλέον σίγουρος ότι η κάρτα σας υποστηρίζεται, θα χρειαστεί να καθορίσετε τον κατάλληλο οδηγό για την κάρτα σας. Το αρχείο [.filename]#/usr/src/sys/conf/NOTES# και το αρχείο [.filename]#/usr/src/sys/arch/conf/NOTES# θα σας δώσουν μια λίστα με κάρτες δικτύου και μερικές πληροφορίες για τα υποστηριζόμενα chipsets και τις υποστηριζόμενες κάρτες. Αν έχετε αμφιβολίες για το ποιός οδηγός είναι ο σωστός, διαβάστε την σελίδα βοηθείας του οδηγού. Η σελίδα βοηθείας θα σας δώσει περισσότερες πληροφορίες σχετικά με το υποστηριζόμενο υλικό και ακόμα και για τα πιθανά προβλήματα που μπορεί να προκύψουν.

Αν έχετε μια συνηθισμένη κάρτα, κατα πάσα πιθανότητα δεν θα χρειαστεί να ψάξετε πολύ για τον οδηγό. Οι οδηγοί για τις συνηθισμένες κάρτες δικτύου υπάρχουν στον πυρήνα [.filename]#GENERIC#, έτσι ώστε και θα εμφανιστεί κατα την διάρκεια της εκκίνησης, για παράδειγμα:

[source,bash]
....
dc0: <82c169 PNIC 10/100BaseTX> port 0xa000-0xa0ff mem 0xd3800000-0xd38
000ff irq 15 at device 11.0 on pci0
dc0: Ethernet address: 00:a0:cc:da:da:da
miibus0: <MII bus> on dc0
ukphy0: <Generic IEEE 802.3u media interface> on miibus0
ukphy0:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
dc1: <82c169 PNIC 10/100BaseTX> port 0x9800-0x98ff mem 0xd3000000-0xd30
000ff irq 11 at device 12.0 on pci0
dc1: Ethernet address: 00:a0:cc:da:da:db
miibus1: <MII bus> on dc1
ukphy1: <Generic IEEE 802.3u media interface> on miibus1
ukphy1:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
....

Στο παράδειγμα αυτό, βλέπουμε ότι δύο κάρτες που χρησιμοποιούν τον οδηγό man:dc[4] έχουν εντοπιστεί στο σύστημα.

Αν ο οδηγός της NIC σας δεν είναι παρόν στον [.filename]#GENERIC#, θα πρέπει να φορτώσετε τον κατάλληλο οδηγό για να χρησιμοποιήσετε την NIC σας. Αυτό μπορεί να επιτευχθεί με έναν απο τους δύο αυτούς τρόπους:

* Ο ποιό εύκολο τρόπος είναι απλά να φορτώσετε ένα άρθρωμα του πυρήνα για την κάρτα δικτύου σας με το man:kldload[8], ή αυτόματα κατα την εκκίνηση προσθέτοντας την κατάλληλη γραμμή στο αρχείο [.filename]#/boot/loader.conf#. Δεν είναι όλοι οι οδηγοί NIC διαθέσιμοι σαν αρθρώματα, χαρακτηριστικά παραδείγματα είναι τα αρθρώματα για συσκευές ISA.
* Εναλλακτικά, μπορείτε να μεταγλώττισετε στατικά την υποστήριξη για την κάρτα σας στον πυρήνα. Ελέγξετε το αρχείο [.filename]#/usr/src/sys/conf/NOTES#, το [.filename]#/usr/src/sys/arch/conf/NOTES# και την σελίδα βοηθείας του οδηγού για να μάθετε τι πρέπει να προσθέσετε στο αρχείο ρυθμίσεων του πυρήνα. Για περισσότερες πληροφορίες για το πως να μεταγλωττίσετε τον πυρήνα, παρακαλώ διαβάστε το crossref:kernelconfig[kernelconfig,Ρυθμίζοντας τον Πυρήνα του FreeBSD]. Αν η κάρτα σας εντοπιστεί κατα την εκκίνηση απο τον πυρήνα ([.filename]#GENERIC#) δεν χρειάζετε να μεταγλώττισετε έναν νέο πυρήνα.

[[config-network-ndis]]
==== Χρησιμοποιώντας Οδηγούς Windows(R) Με Το NDIS

Δυστυχώς, υπάρχουν ακόμα πολλοί κατασκευαστές που δεν παρέχουν τεχνικές προδιαγραφές για τους οδηγούς τους στην κοινότητα του ανοικτού λογισμικού γιατί αντιμετωπίζουν τέτοιες πληροφορίες σαν μυστικά του εμπορίου. Συνεπώς, οι υπεύθυνοι για την ανάπτυξη του FreeBSD και άλλων λειτουργικών συστημάτων μένουν με δύο επιλογές: να αναπτύξουν οδηγούς με την μακρά και επίπονη διαδικασία της αντίστροφης μηχανικής ή να χρησιμοποιήσουν ήδη υπάρχοντες οδηγούς σε δυαδική μορφή διαθέσιμους για την πλατφόρμα Microsoft(R) Windows(R). Οι περισσότεροι υπεύθυνοι για την ανάπτυξη, μεταξύ τους και αυτοί που εμπλέκονται με το FreeBSD, έχουν επιλέξει την δεύτερη προσέγγιση.

Χάρη την προσφορά του Bill Paul (wpaul), μιάς και απο το FreeBSD 5.3-RELEASE υπάρχει "γηγενής" υποστήριξη για το Network Driver Interface Specification (NDIS). Το έργο FreeBSD NDISulator (διαφορετικά γνωστό σας Project Evil) παίρνει έναν οδηγό Windows(R) σε δυαδική μορφή και στην ουσία τον εξαπατά ώστε να νομίζει ότι τρέχει σε Windows(R). Λόγο του ότι ο οδηγός man:ndis[4] χρησιμοποιεί μία Windows(R) δυαδική μορφή, μπορεί να χρησιμοποιηθεί μόνο σε i386(TM) και amd64 συστήματα.

[NOTE]
====
Ο οδηγός man:ndis[4] είναι σχεδιασμένος ώστε να υποστηρίζει κυρίως συσκευές PCI, CardBus και PCMCIA, οι συσκευές USB δεν υποστηρίζονται ακόμα.
====

Για να χρησιμοποιήσετε τον NDISulator, θα χρειαστείτε τρία πράγματα:

. Τον πηγαίο κώδικα του πυρήνα
. Την Windows(R) XP δυαδική μορφή του οδηγού ([.filename]#.SYS# επέκταση)
. Το Windows(R) XP αρχείο ρυθμίσεων του οδηγού ([.filename]#.INF# επέκταση)

Εντοπίστε τα αρχεία αυτά για την κάρτα σας. Γενικά, αυτά μπορούν να βρεθούν στα παρεχόμενα CDs ή στους ιστότοπους των κατασκευαστών. Στα ακόλουθα παραδείγματα, θα χρησιμοποιήσουμε τα αρχεία [.filename]#W32DRIVER.SYS# και [.filename]#W32DRIVER.INF#.

[NOTE]
====
Δεν μπορείτε να χρησιμοποιήσετε οδηγούς Windows(R)/i386 σε συστήματα FreeBSD/amd64, θα πρέπει να βρείτε οδηγούς Windows(R)/amd64 για να δουλέψουν σωστά.
====

Το επόμενο βήμα είναι να μεταγλωττίσετε τον δυαδικό οδηγό μέσα σε ένα φορτώσιμο άρθρωμα του πυρήνα. Για να το επιτύχετε αυτό, θα πρέπει σαν `root`, να χρησιμοποιήσετε το man:ndisgen[8]:

[source,bash]
....
# ndisgen /path/to/W32DRIVER.INF /path/to/W32DRIVER.SYS
....

Το βοηθητικό πρόγραμμα man:ndisgen[8] είναι διαδραστικό και θα σας ενημερώσει για οποιαδήποτε επιπλέον πληροφορία μπορεί να χρειαστεί; θα παράγει ένα άρθρωμα του πυρήνα στον τρέχωντα κατάλογο και μπορεί να φορτωθεί ως εξής:

[source,bash]
....
# kldload ./W32DRIVER.ko
....

Επιπλέον του παραχθέντος αρθρώματος, θα πρέπει να φορτώσετε τα αρθρώματα [.filename]#ndis.ko# και [.filename]#if_ndis.ko#. Αυτό θα πρέπει να γίνει αυτόματα όταν φορτώνετε οποιαδήποτε εξαρτάται απο το man:ndis[4]. Αν θέλετε να το κάνετε χειρωνακτικά, θα πρέπει να χρησιμοποιήσετε τις ακόλουθες εντολές:

[source,bash]
....
# kldload ndis
# kldload if_ndis
....

Η πρώτη εντολή φορτώνει τον οδηγό NDIS miniport wrapper, ενώ η δεύτερη φορτώνει την πραγματική κάρτα δικτύου.

Τώρα, ελέγξτε το man:dmesg[8] για να δείτε αν υπάρχουν σφάλματα κατα την φόρτωση. Αν όλα πήγαν καλά, θα πρέπει να δείτε μια παρόμοια έξοδο με την επόμενη:

[source,bash]
....
ndis0: <Wireless-G PCI Adapter> mem 0xf4100000-0xf4101fff irq 3 at device 8.0 on pci1
ndis0: NDIS API version: 5.0
ndis0: Ethernet address: 0a:b1:2c:d3:4e:f5
ndis0: 11b rates: 1Mbps 2Mbps 5.5Mbps 11Mbps
ndis0: 11g rates: 6Mbps 9Mbps 12Mbps 18Mbps 36Mbps 48Mbps 54Mbps
....

Απο εδώ και πέρα μπορείτε να χειριστείτε την συσκευή [.filename]#ndis0# σαν μια οποιαδήποτε κάρτα δικτύου (π.χ., [.filename]#dc0#).

Μπορείτε να ρυθμίσετε το σύστημα να φορτώνει τα NDIS αρθρώματα κατα την εκκίνηση με τον ίδιο τρόπο με τα όπως με οποιαδήποτε άλλα αρθρώματα. Πρώτα, αντιγράψτε το παραχθείσα άρθρωμα, [.filename]#W32DRIVER.ko#, στον κατάλογο [.filename]#/boot/modules#. Τότε, προσθέστε την ακόλουθη γραμμή στο [.filename]#/boot/loader.conf#:

[.programlisting]
....
W32DRIVER_load="YES"
....

=== Ρυθμίζοντας Την Κάρτα Δικτύου

Μόλις ο κατάλληλος οδηγός φορτωθεί για την κάρτα δικτύου, χρειάζεται να ρυθμιστεί. Όπως πολλά άλλα πράγματα, η κάρτα δικτύου είχε ρυθμιστεί κατα την στιγμή της εγκατάστασης με το sysinstall.

Για να εμφανίσετε τις κάρτες δικτύου που έχετε στο σύστημα σας, πληκτρολογήστε την ακόλουθη εντολή:

[source,bash]
....
% ifconfig
dc0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500
        inet 192.168.1.3 netmask 0xffffff00 broadcast 192.168.1.255
        ether 00:a0:cc:da:da:da
        media: Ethernet autoselect (100baseTX <full-duplex>)
        status: active
dc1: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500
        inet 10.0.0.1 netmask 0xffffff00 broadcast 10.0.0.255
        ether 00:a0:cc:da:da:db
        media: Ethernet 10baseT/UTP
        status: no carrier
lp0: flags=8810<POINTOPOINT,SIMPLEX,MULTICAST> mtu 1500
lo0: flags=8049<UP,LOOPBACK,RUNNING,MULTICAST> mtu 16384
        inet 127.0.0.1 netmask 0xff000000
tun0: flags=8010<POINTOPOINT,MULTICAST> mtu 1500
....

[NOTE]
====
Παλαιότερες εκδόσεις του FreeBSD μπορεί να χρειάζονται την παράμετρο `-a` ακολουθούμενη στην man:ifconfig[8], για περισσότερες λεπτομέρειες σχετικά με την σωστή σύνταξη του man:ifconfig[8], παρακαλώ ανατρέξτε στην σελίδα βοηθείας. Σημειώστε επίσης ότι οι εγγραφές που αφορούν το IPv6 (`inet6` κτλπ.) έχουν παραμεληθεί σε αυτό το παράδειγμα.
====

Σε αυτό το παράδειγμα, οι ακόλουθες συσκευές έχουν εμφανιστεί:

* [.filename]#dc0#: Η πρώτη Ethernet κάρτα δικτύου
* [.filename]#dc1#: Η δεύτερη Ethernet κάρτα δικτύου
* [.filename]#lp0#: Η παράλληλη πόρτα 
* [.filename]#lo0#: Η συσκευή loopback
* [.filename]#tun0#: Η συσκευή tunnel χρησιμοποιούμενη απο το πρόγραμμα ppp

Το FreeBSD χρησιμοποιεί τα ονόματα των οδηγών με την σειρά κατα την οποία εντοπίστηκαν οι αντίστοιχες κάρτες κατα την εκκίνηση. Για παράδειγμα η συσκευή [.filename]#sis2# θα είναι η τρίτη κάρτα δικτύου που χρησιμοποιεί τον οδηγό man:sis[4].

Στο παράδειγμα αυτό, η συσκευή [.filename]#dc0# είναι πάνω και τρέχει. Οι λέξεις κλειδία είναι:

. `UP` σημαίνει ότι η κάρτα είναι ρυθμισμένη και έτοιμη.
. Η κάρτα έχει μία Internet διεύθυνση (`inet`) ρυθμισμένη (σε αυτή την περίπτωση `192.168.1.3`).
. Έχει μία έγκυρη μάσκα υποδικτύου (`netmask`; `0xffffff00` είναι το ίδιο με το `255.255.255.0`).
. Έχει μία έγκυρη broadcast διεύθυνση (σε αυτή την περίπτωση, `192.168.1.255`).
. Η διεύθυνση MAC της κάρτας (`ether`) είναι `00:a0:cc:da:da:da`
. Η επιλογή του φυσικού μέσου είναι σε κατάσταση autoselection (`media: Ethernet autoselect (100baseTX <full-duplex>)`). Παρατηρούμε ότι η [.filename]#dc1# έχει ρυθμιστεί να τρέχει σαν `10baseT/UTP` μέσο. Για περισσότερες πληροφορίες για τους τύπους των μέσων ενός οδηγού, παρακαλώ ανατρέξτε στην σελίδα βοηθείας.
. Η κατάσταση της σύνδεσης (`status`) είναι `active`, δηλ. έχει εντοπιστεί σήμα μεταφοράς. Στην [.filename]#dc1#, παρατηρούμε `status: no carrier`. Αυτό είναι λογικό αφού το καλώδιο Ethernet δεν έχει συνδεθεί με την κάρτα.

Αν το man:ifconfig[8] εμφανίζει κάτι παρόμοιο με αυτό:

[source,bash]
....
dc0: flags=8843<BROADCAST,SIMPLEX,MULTICAST> mtu 1500
	        ether 00:a0:cc:da:da:da
....

σημαίνει ότι η κάρτα δεν έχει ρυθμιστεί.

Για να ρυθμίσετε την κάρτα σας, θα χρειαστείτε προνόμια `root`. Η ρύθμιση της κάρτας δικτύου μπορεί να γίνει απο την γραμμή εντολών με το man:ifconfig[8] αλλά θα πρέπει να το επαναλάβετε σε κάθε επανεκκίνηση του συστήματος. Το αρχείο [.filename]#/etc/rc.conf# είναι εκεί όπου πρέπει να προσθέσετε τις ρύθμισεις της κάρτας δικτύου.

Ανοίξτε το αρχείο [.filename]#/etc/rc.conf# με τον αγαπημένο σας κειμενογράφο. Θα χρειαστεί να προσθέσετε μία γραμμή για κάθε κάρτα δικτύου που υπάρχει στο σύστημα σας, για παράδειγμα στην περίπτωση μας, θα πρέπει να προσθέσετε τι εξής γραμμές:

[.programlisting]
....
ifconfig_dc0="inet 192.168.1.3 netmask 255.255.255.0"
ifconfig_dc1="inet 10.0.0.1 netmask 255.255.255.0 media 10baseT/UTP"
....

Θα πρέπει να αντικαταστήσετε το [.filename]#dc0#, [.filename]#dc1#, και ούτω κάθε εξής, με τις σωστές συσκευές των καρτών σας, και τις σωστές διευθύνσεις. Θα πρέπει να διαβάσετε την σελίδα βοηθείας του οδηγού και του man:ifconfig[8] για περισσότερες λεπτομέριες σχετικά με τις επιτρεπόμενες παραμέτρους και επίσης την σελίδα βοηθείας του man:rc.conf[5] για περισσότερες λεπτομέριες σχετικά με την σύνταξη του [.filename]#/etc/rc.conf#.

Αν ρυθμίσατε το δίκτυο σας κατα την εγκατάσταση, μερικές γραμμές σχετικές με την/τις κάρτα/κάρτες δικτύου θα υπάρχουν ήδη. Ελέγξτε διπλά το [.filename]#/etc/rc.conf# προτού προσθέστε επιπλέον γραμμές.

Θα πρέπει επίσης να διορθώσετε το αρχείο [.filename]#/etc/hosts# ώστε να προσθέσετε τα ονόματα και τις IP διεύθυνσεις απο τα διάφορα μηχανήματα στο LAN σας, αν δεν είναι ήδη ρυθμισμένα. Για περισσότερες πληροφορίες ανατρέξτε στην σελίδα βοηθείας του man:hosts[5] και του [.filename]#/usr/shared/examples/etc/hosts#.

=== Δοκιμές Και Επίλυση Προβλημάτων

Μόλις κάνετε τις βασικές αλλαγές στο [.filename]#/etc/rc.conf#, θα πρέπει να επανεκκινήσετε το σύστημα σας. Αυτό θα επιτρέψει σε πιθανές αλλαγές στις κάρτες να εφαρμοστούν, και να επιβεβαιώσετε ότι το σύστημα επανεκκινεί χωρίς κανένα λάθος στις ρυθμίσεις.

Μόλις το σύστημα επανεκκινηθεί, θα πρέπει να δοκιμάσετε τις κάρτες δικτύου.

==== Δοκιμάζοντας Μια Ethernet Κάρτα

Για να επιβεβαιώσετε ότι η Ethernet κάρτα λειτουργεί σωστά, θα πρέπει να κάνετε δύο πράγματα. Πρώτα, κάντε ping την κάρτα την ίδια, και μετά κάντε ping ένα άλλο μηχάνημα στο LAN.

Πρώτα δοκιμάστε στην τοπική κάρτα:

[source,bash]
....
% ping -c5 192.168.1.3
PING 192.168.1.3 (192.168.1.3): 56 data bytes
64 bytes from 192.168.1.3: icmp_seq=0 ttl=64 time=0.082 ms
64 bytes from 192.168.1.3: icmp_seq=1 ttl=64 time=0.074 ms
64 bytes from 192.168.1.3: icmp_seq=2 ttl=64 time=0.076 ms
64 bytes from 192.168.1.3: icmp_seq=3 ttl=64 time=0.108 ms
64 bytes from 192.168.1.3: icmp_seq=4 ttl=64 time=0.076 ms

--- 192.168.1.3 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.074/0.083/0.108/0.013 ms
....

Τώρα δοκιμάστε σε ένα άλλο μηχάνημα στο LAN:

[source,bash]
....
% ping -c5 192.168.1.2
PING 192.168.1.2 (192.168.1.2): 56 data bytes
64 bytes from 192.168.1.2: icmp_seq=0 ttl=64 time=0.726 ms
64 bytes from 192.168.1.2: icmp_seq=1 ttl=64 time=0.766 ms
64 bytes from 192.168.1.2: icmp_seq=2 ttl=64 time=0.700 ms
64 bytes from 192.168.1.2: icmp_seq=3 ttl=64 time=0.747 ms
64 bytes from 192.168.1.2: icmp_seq=4 ttl=64 time=0.704 ms

--- 192.168.1.2 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.700/0.729/0.766/0.025 ms
....

Μπορείτε να χρησιμοποιήσετε και το όνομα το μηχανήματος αντί της διεύθυνσης `192.168.1.2` αν έχετε ρυθμίσει το αρχείο [.filename]#/etc/hosts#.

==== Επίλυση Προβλημάτων

Η επίλυση προβλημάτων υλικού και λογισμικού είναι πάντοτε επίπονη, ένας πόνος ο οποιός μπορεί να ανακουφιστεί ελέγχοντας μερικά απλά πράγματα πρώτα. Είναι το καλώδιο του δικτύου συνδεδεμένο; Έχετε ρυθμίσει σωστά τις υπηρεσίες δικτύου; Έχετε ρυθμίσει σωστά το πύρινο τείχος; Έχει πράγματι το FreeBSD υποστήριξη για αυτή την κάρτα δικτύου; Πρέπει πάντα να ελέγχετε τις σημειώσεις του υλικού πριν στείλε μία αναφορά για ένα πρόβλημα. Αναβαθμίστε την έκδοση του FreeBSD στην τελευταία ΣΤΑΘΕΡΗ έκδοση. Ελέγξτε τα αρχεία των λιστών μηνυμάτων, ή ψάξτε στο Internet.

Αν η κάρτα δουλεύει, αλλά με χαμηλή απόδοση, θα άξιζε να διαβάσετε την σελίδα βοηθείας man:tuning[7]. Μπορείτε επίσης να ελέγξετε οι αν λανθασμένες ρυθμίσεις του δικτύου προκαλούν τις αργές συνδέσεις.

Μερικοί χρήστες αντιμετωπίζουν ένα ή δύο μηνύματα `device timeout`, τα οποία είναι φυσιολογικά για μερικές κάρτες. Αν συνεχιστούν, ή γίνουν ενοχλητικά, θα πρέπει να ελέγξετε μήπως και κάποιες συσκευές παρεμποδίζουν η μία την άλλη. Ελέγξτε διπλά τις συνδέσεις των καλωδίων. Ίσως θα πρέπει να αποκτήσετε μία άλλη κάρτα.

Μερικές φορές, οι χρήστες παρατηρούν μερικά μηνύματα λάθους `watchdog timeout`. Το πρώτο πράγμα που πρέπει να κάνετε είναι να ελέγξετε το καλώδιο του δικτύου. Αρκέτες κάρτες χρειάζονται μία θέση PCI που να υποστηρίζει Bus Mastering. Σε μερικές παλιές μητρικές κάρτες. μόνο μία θέση PCI το υποστήριζε (συνήθως η θέση 0). Ελέγξτε την κάρτα δικτύου και την τεκμηρίωση της μητρικής κάρτας για να διαπιστώσετε αν εκεί είναι το πρόβλημα.

Το μήνυμα `No route to host` εμφανίζεται αν το σύστημα αδυνατεί να δρομολογήσει τα πακέτα στον προορισμό τους. Αυτό συμβαίνει αν δεν έχει καθοριστεί προεπιλεγμένη διεύθυνση δρομολόγησης, ή αν ένα καλώδιο έχει ξεσυνδεθεί. Ελέγξτε την έξοδο τις εντολής `netstat -rn` και σιγουρευτείτε ότι η διεύθυνση δρομολόγησης είναι έγκυρη. Αν δεν έχει καθοριστεί, διαβάστε το crossref:advanced-networking[advanced-networking,Προχωρημένα Θέματα Δικτύωσης] για περισσότερες πληροφορίες.

Το μήνυμα λάθους `ping: sendto: Permission denied` συμβαίνει κυρίως λόγο κάποιας λάθος ρύθμισης στο πύρινο τείχος. Αν το `ipfw` είναι ενεργοποιημένο στον πυρήνα αλλά δεν έχουν καθοριστεί κανόνες, τότε η προεπιλεγμένη πολιτική είναι η απαγόρευση όλης της κίνησης, ακόμα και των αιτημάτων ping! Διαβάστε το crossref:firewalls[firewalls,Firewalls] για περισσότερες πληροφορίες.

Μερικές φορές η απόδοση της κάρτας μπορεί να είναι φτωχή, ή κάτω του μέσου όρου. Σε αυτές τις περιπτώσεις το καλύτερο είναι να ρυθμίσετε την κατάσταση του μέσου απο `autoselect` στην κατάλληλη κατάσταση. Ενώ συνήθως αυτό φαίνετε να δουλεύει στα περισσότερα υλικά, μπορεί να μην λύσει το πρόβλημα στον καθέναν. Και πάλι, ελέγξτε όλες τις ρυθμίσεις του δικτύου, και ξαναδιαβάστε πάλι την σελίδα βοηθείας man:tuning[7].

[[configtuning-virtual-hosts]]
== Εικονικά Hosts

Μία αρκετά συνηθισμένη χρήση του FreeBSD είναι η εικονική φιλοξενία ιστοχώρων, όπου και ένας εξυπηρετητής εμφανίζεται στο δίκτυο σαν περισσότερο απο ένας. Αυτό επιτυγχάνεται αναθέτοντας πολλαπλές δικτυακές διευθύνσεις σε μία και μόνο συσκευή.

Μία κάρτα δικτύου έχει μία "πραγματική" διεύθυνση, και απεριόριστο αριθμό "εικονικών" διευθύνσεων. Οι εικονικές αυτές διεύθυνσεις προσθέτονται με την μορφή εγγραφών στο αρχείο [.filename]#/etc/rc.conf#.

Μία εγγραφή εικονικής διεύθυνσης για την κάρτα δικτύου [.filename]#fxp0# μοιάζει ως εξής:

[.programlisting]
....
ifconfig_fxp0_alias0="inet xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx"
....

Σημειώστε ότι οι εγγραφές αυτές πρέπει να ξεκινούν με `alias0` και να συνεχίζουν πρός τα πάνω σε σειρά, (για παράδειγμα, `_alias1`, `_alias2`, και ούτω κάθε εξής). Η διαδικασία ρύθμισης θα σταματήσει στον πρώτο αριθμό που λείπει.

Ο υπολογισμός της μάσκας δικτύου είναι σημαντικός, αλλά ευτυχώς και εύκολος. Για κάθε κάρτα, πρέπει να υπάρχει μία διεύθυνση η οποία αντιπροσωπεύει σωστά την μάσκα του δικτύου. Οποιαδήποτε άλλη διεύθυνση που συμπίπτει στο ίδιο δίκτυο πρέπει να έχει μάσκα δικτύου ``1``s (εκφρασμένη είτε σαν `255.255.255.255` είτε σαν `0xffffffff`).

Για παράδειγμα, εξετάστε την περίπτωση όπου η κάρτα δικτύου [.filename]#fxp0# είναι συνδεδεμένη σε δύο δίκτυα, το δίκτυο `10.1.1.0` με μάσκα δικτύου `255.255.255.0` και το δίκτυο `202.0.75.16` με μάσκα δικτύου `255.255.255.240`. Θέλουμε το σύστημα να πάρει τις διευθύνσεις από `10.1.1.1` μέχρι `10.1.1.5` και τις `202.0.75.17` μέχρι `202.0.75.20`. Όπως σημειώθηκε παραπάνω, μόνο η πρώτες διευθύνσεις (στην περίπτωση αυτή, η `10.0.1.1` και η `202.0.75.17`) πρέπει να έχουν πραγματικές μάσκες δικτύου. Όλες οι υπόλοιπες, από (`10.1.1.2` μέχρι `10.1.1.5` και `202.0.75.18` μέχρι `202.0.75.20`) πρέπει να ρυθμιστούν με μάσκα δικτύου `255.255.255.255`.

Η ακόλουθες εγγραφές στο αρχείο [.filename]#/etc/rc.conf# θα ρυθμίσουν την κάρτα όπως πρέπει για το παράδειγμα:

[.programlisting]
....
ifconfig_fxp0="inet 10.1.1.1 netmask 255.255.255.0"
ifconfig_fxp0_alias0="inet 10.1.1.2 netmask 255.255.255.255"
ifconfig_fxp0_alias1="inet 10.1.1.3 netmask 255.255.255.255"
ifconfig_fxp0_alias2="inet 10.1.1.4 netmask 255.255.255.255"
ifconfig_fxp0_alias3="inet 10.1.1.5 netmask 255.255.255.255"
ifconfig_fxp0_alias4="inet 202.0.75.17 netmask 255.255.255.240"
ifconfig_fxp0_alias5="inet 202.0.75.18 netmask 255.255.255.255"
ifconfig_fxp0_alias6="inet 202.0.75.19 netmask 255.255.255.255"
ifconfig_fxp0_alias7="inet 202.0.75.20 netmask 255.255.255.255"
....

[[configtuning-configfiles]]
== Αρχεία Ρυθμίσεων

=== Ο κατάλογος [.filename]#/etc#

Τα αρχεία ρυθμίσεων αποθηκεύονται σε καταλόγους. Μερικοί απο αυτούς είναι:

[.informaltable]
[cols="1,1", frame="none"]
|===

|[.filename]#/etc#
|Γενικές ρυθμίσεις του συστήματος, data here is system-specific.

|[.filename]#/etc/defaults#
|Default versions of system configuration files.

|[.filename]#/etc/mail#
|Extra man:sendmail[8] configuration, other MTA configuration files. 

|[.filename]#/etc/ppp#
|Configuration for both user- and kernel-ppp programs. 

|[.filename]#/etc/namedb#
|Default location for man:named[8] data. Normally [.filename]#named.conf# and zone files are stored here.

|[.filename]#/usr/local/etc#
|Configuration files for installed applications. May contain per-application subdirectories.

|[.filename]#/usr/local/etc/rc.d#
|Start/stop scripts for installed applications.

|[.filename]#/var/db#
|Automatically generated system-specific database files, such as the package database, the locate database, and so on
|===

=== Hostnames

==== [.filename]#/etc/resolv.conf#

[.filename]#/etc/resolv.conf# dictates how FreeBSD's resolver accesses the Internet Domain Name System (DNS).

The most common entries to [.filename]#resolv.conf# are: 

[.informaltable]
[cols="1,1", frame="none"]
|===

|`nameserver`
|The IP address of a name server the resolver should query. The servers are queried in the order listed with a maximum of three.

|`search`
|Search list for hostname lookup. This is normally determined by the domain of the local hostname.

|`domain`
|The local domain name.
|===

A typical [.filename]#resolv.conf#:

[.programlisting]
....
search example.com
nameserver 147.11.1.11
nameserver 147.11.100.30
....

[NOTE]
====
Only one of the `search` and `domain` options should be used.
====

If you are using DHCP, man:dhclient[8] usually rewrites [.filename]#resolv.conf# with information received from the DHCP server.

==== [.filename]#/etc/hosts#

[.filename]#/etc/hosts# is a simple text database reminiscent of the old Internet. It works in conjunction with DNS and NIS providing name to IP address mappings. Local computers connected via a LAN can be placed in here for simplistic naming purposes instead of setting up a man:named[8] server. Additionally, [.filename]#/etc/hosts# can be used to provide a local record of Internet names, reducing the need to query externally for commonly accessed names.

[.programlisting]
....
# $FreeBSD$
#
# Host Database
# This file should contain the addresses and aliases
# for local hosts that share this file.
# In the presence of the domain name service or NIS, this file may
# not be consulted at all; see /etc/nsswitch.conf for the resolution order.
#
#
::1                     localhost localhost.my.domain myname.my.domain
127.0.0.1               localhost localhost.my.domain myname.my.domain

#
# Imaginary network.
#10.0.0.2               myname.my.domain myname
#10.0.0.3               myfriend.my.domain myfriend
#
# According to RFC 1918, you can use the following IP networks for
# private nets which will never be connected to the Internet:
#
#       10.0.0.0        -   10.255.255.255
#       172.16.0.0      -   172.31.255.255
#       192.168.0.0     -   192.168.255.255
#
# In case you want to be able to connect to the Internet, you need
# real official assigned numbers.  PLEASE PLEASE PLEASE do not try
# to invent your own network numbers but instead get one from your
# network provider (if any) or from the Internet Registry (ftp to
# rs.internic.net, directory `/templates').
#
....

[.filename]#/etc/hosts# takes on the simple format of:

[.programlisting]
....
[Internet address] [official hostname] [alias1] [alias2] ...
....

For example:

[.programlisting]
....
10.0.0.1 myRealHostname.example.com myRealHostname foobar1 foobar2
....

Consult man:hosts[5] for more information.

=== Log File Configuration

==== [.filename]#syslog.conf#

[.filename]#syslog.conf# is the configuration file for the man:syslogd[8] program. It indicates which types of `syslog` messages are logged to particular log files.

[.programlisting]
....
# $FreeBSD$
#
#       Spaces ARE valid field separators in this file. However,
#       other *nix-like systems still insist on using tabs as field
#       separators. If you are sharing this file between systems, you
#       may want to use only tabs as field separators here.
#       Consult the syslog.conf(5) manual page.
*.err;kern.debug;auth.notice;mail.crit          /dev/console
*.notice;kern.debug;lpr.info;mail.crit;news.err /var/log/messages
security.*                                      /var/log/security
mail.info                                       /var/log/maillog
lpr.info                                        /var/log/lpd-errs
cron.*                                          /var/log/cron
*.err                                           root
*.notice;news.err                               root
*.alert                                         root
*.emerg                                         *
# uncomment this to log all writes to /dev/console to /var/log/console.log
#console.info                                   /var/log/console.log
# uncomment this to enable logging of all log messages to /var/log/all.log
#*.*                                            /var/log/all.log
# uncomment this to enable logging to a remote log host named loghost
#*.*                                            @loghost
# uncomment these if you're running inn
# news.crit                                     /var/log/news/news.crit
# news.err                                      /var/log/news/news.err
# news.notice                                   /var/log/news/news.notice
!startslip
*.*                                             /var/log/slip.log
!ppp
*.*                                             /var/log/ppp.log
....

Consult the man:syslog.conf[5] manual page for more information.

==== [.filename]#newsyslog.conf#

[.filename]#newsyslog.conf# is the configuration file for man:newsyslog[8], a program that is normally scheduled to run by man:cron[8]. man:newsyslog[8] determines when log files require archiving or rearranging. [.filename]#logfile# is moved to [.filename]#logfile.0#, [.filename]#logfile.0# is moved to [.filename]#logfile.1#, and so on. Alternatively, the log files may be archived in man:gzip[1] format causing them to be named: [.filename]#logfile.0.gz#, [.filename]#logfile.1.gz#, and so on.

[.filename]#newsyslog.conf# indicates which log files are to be managed, how many are to be kept, and when they are to be touched. Log files can be rearranged and/or archived when they have either reached a certain size, or at a certain periodic time/date.

[.programlisting]
....
# configuration file for newsyslog
# $FreeBSD$
#
# filename          [owner:group]    mode count size when [ZB] [/pid_file] [sig_num]
/var/log/cron                           600  3     100  *     Z
/var/log/amd.log                        644  7     100  *     Z
/var/log/kerberos.log                   644  7     100  *     Z
/var/log/lpd-errs                       644  7     100  *     Z
/var/log/maillog                        644  7     *    @T00  Z
/var/log/sendmail.st                    644  10    *    168   B
/var/log/messages                       644  5     100  *     Z
/var/log/all.log                        600  7     *    @T00  Z
/var/log/slip.log                       600  3     100  *     Z
/var/log/ppp.log                        600  3     100  *     Z
/var/log/security                       600  10    100  *     Z
/var/log/wtmp                           644  3     *    @01T05 B
/var/log/daily.log                      640  7     *    @T00  Z
/var/log/weekly.log                     640  5     1    $W6D0 Z
/var/log/monthly.log                    640  12    *    $M1D0 Z
/var/log/console.log                    640  5     100  *     Z
....

Consult the man:newsyslog[8] manual page for more information.

[[configtuning-sysctlconf]]
=== [.filename]#sysctl.conf#

[.filename]#sysctl.conf# looks much like [.filename]#rc.conf#. Values are set in a `variable=value` form. The specified values are set after the system goes into multi-user mode. Not all variables are settable in this mode.

To turn off logging of fatal signal exits and prevent users from seeing processes started from other users, the following tunables can be set in [.filename]#sysctl.conf#:

[.programlisting]
....
# Do not log fatal signal exits (e.g. sig 11)
kern.logsigexit=0

# Prevent users from seeing information about processes that
# are being run under another UID.
security.bsd.see_other_uids=0
....

[[configtuning-sysctl]]
== Tuning with sysctl

man:sysctl[8] is an interface that allows you to make changes to a running FreeBSD system. This includes many advanced options of the TCP/IP stack and virtual memory system that can dramatically improve performance for an experienced system administrator. Over five hundred system variables can be read and set using man:sysctl[8].

At its core, man:sysctl[8] serves two functions: to read and to modify system settings.

To view all readable variables:

[source,bash]
....
% sysctl -a
....

To read a particular variable, for example, `kern.maxproc`:

[source,bash]
....
% sysctl kern.maxproc
kern.maxproc: 1044
....

To set a particular variable, use the intuitive _variable_=_value_ syntax:

[source,bash]
....
# sysctl kern.maxfiles=5000
kern.maxfiles: 2088 -> 5000
....

Settings of sysctl variables are usually either strings, numbers, or booleans (a boolean being `1` for yes or a `0` for no).

If you want to set automatically some variables each time the machine boots, add them to the [.filename]#/etc/sysctl.conf# file. For more information see the man:sysctl.conf[5] manual page and the <<configtuning-sysctlconf>>.

[[sysctl-readonly]]
=== man:sysctl[8] Read-only

In some cases it may be desirable to modify read-only man:sysctl[8] values. While this is sometimes unavoidable, it can only be done on (re)boot.

For instance on some laptop models the man:cardbus[4] device will not probe memory ranges, and fail with errors which look similar to:

[source,bash]
....
cbb0: Could not map register memory
device_probe_and_attach: cbb0 attach returned 12
....

Cases like the one above usually require the modification of some default man:sysctl[8] settings which are set read only. To overcome these situations a user can put man:sysctl[8] "OIDs" in their local [.filename]#/boot/loader.conf#. Default settings are located in the [.filename]#/boot/defaults/loader.conf# file.

Fixing the problem mentioned above would require a user to set `hw.pci.allow_unsupported_io_range=1` in the aforementioned file. Now man:cardbus[4] will work properly.

[[configtuning-disk]]
== Tuning Disks

=== Sysctl Variables

==== `vfs.vmiodirenable`

The `vfs.vmiodirenable` sysctl variable may be set to either 0 (off) or 1 (on); it is 1 by default. This variable controls how directories are cached by the system. Most directories are small, using just a single fragment (typically 1 K) in the file system and less (typically 512 bytes) in the buffer cache. With this variable turned off (to 0), the buffer cache will only cache a fixed number of directories even if you have a huge amount of memory. When turned on (to 1), this sysctl allows the buffer cache to use the VM Page Cache to cache the directories, making all the memory available for caching directories. However, the minimum in-core memory used to cache a directory is the physical page size (typically 4 K) rather than 512 bytes. We recommend keeping this option on if you are running any services which manipulate large numbers of files. Such services can include web caches, large mail systems, and news systems. Keeping this option on will generally not reduce performance even with the wasted memory but you should experiment to find out.

==== `vfs.write_behind`

The `vfs.write_behind` sysctl variable defaults to `1` (on). This tells the file system to issue media writes as full clusters are collected, which typically occurs when writing large sequential files. The idea is to avoid saturating the buffer cache with dirty buffers when it would not benefit I/O performance. However, this may stall processes and under certain circumstances you may wish to turn it off.

==== `vfs.hirunningspace`

The `vfs.hirunningspace` sysctl variable determines how much outstanding write I/O may be queued to disk controllers system-wide at any given instance. The default is usually sufficient but on machines with lots of disks you may want to bump it up to four or five _megabytes_. Note that setting too high a value (exceeding the buffer cache's write threshold) can lead to extremely bad clustering performance. Do not set this value arbitrarily high! Higher write values may add latency to reads occurring at the same time. 

There are various other buffer-cache and VM page cache related sysctls. We do not recommend modifying these values, the VM system does an extremely good job of automatically tuning itself.

==== `vm.swap_idle_enabled`

The `vm.swap_idle_enabled` sysctl variable is useful in large multi-user systems where you have lots of users entering and leaving the system and lots of idle processes. Such systems tend to generate a great deal of continuous pressure on free memory reserves. Turning this feature on and tweaking the swapout hysteresis (in idle seconds) via `vm.swap_idle_threshold1` and `vm.swap_idle_threshold2` allows you to depress the priority of memory pages associated with idle processes more quickly then the normal pageout algorithm. This gives a helping hand to the pageout daemon. Do not turn this option on unless you need it, because the tradeoff you are making is essentially pre-page memory sooner rather than later; thus eating more swap and disk bandwidth. In a small system this option will have a determinable effect but in a large system that is already doing moderate paging this option allows the VM system to stage whole processes into and out of memory easily.

==== `hw.ata.wc`

FreeBSD 4.3 flirted with turning off IDE write caching. This reduced write bandwidth to IDE disks but was considered necessary due to serious data consistency issues introduced by hard drive vendors. The problem is that IDE drives lie about when a write completes. With IDE write caching turned on, IDE hard drives not only write data to disk out of order, but will sometimes delay writing some blocks indefinitely when under heavy disk loads. A crash or power failure may cause serious file system corruption. FreeBSD's default was changed to be safe. Unfortunately, the result was such a huge performance loss that we changed write caching back to on by default after the release. You should check the default on your system by observing the `hw.ata.wc` sysctl variable. If IDE write caching is turned off, you can turn it back on by setting the kernel variable back to 1. This must be done from the boot loader at boot time. Attempting to do it after the kernel boots will have no effect.

For more information, please see man:ata[4].

==== `SCSI_DELAY` (`kern.cam.scsi_delay`)

The `SCSI_DELAY` kernel config may be used to reduce system boot times. The defaults are fairly high and can be responsible for `15` seconds of delay in the boot process. Reducing it to `5` seconds usually works (especially with modern drives). Newer versions of FreeBSD (5.0 and higher) should use the `kern.cam.scsi_delay` boot time tunable. The tunable, and kernel config option accept values in terms of _milliseconds_ and _not seconds_.

[[soft-updates]]
=== Soft Updates

The man:tunefs[8] program can be used to fine-tune a file system. This program has many different options, but for now we are only concerned with toggling Soft Updates on and off, which is done by:

[source,bash]
....
# tunefs -n enable /filesystem
# tunefs -n disable /filesystem
....

A filesystem cannot be modified with man:tunefs[8] while it is mounted. A good time to enable Soft Updates is before any partitions have been mounted, in single-user mode.

Soft Updates drastically improves meta-data performance, mainly file creation and deletion, through the use of a memory cache. We recommend to use Soft Updates on all of your file systems. There are two downsides to Soft Updates that you should be aware of: First, Soft Updates guarantees filesystem consistency in the case of a crash but could very easily be several seconds (even a minute!) behind updating the physical disk. If your system crashes you may lose more work than otherwise. Secondly, Soft Updates delays the freeing of filesystem blocks. If you have a filesystem (such as the root filesystem) which is almost full, performing a major update, such as `make installworld`, can cause the filesystem to run out of space and the update to fail.

==== More Details about Soft Updates

There are two traditional approaches to writing a file systems meta-data back to disk. (Meta-data updates are updates to non-content data like inodes or directories.)

Historically, the default behavior was to write out meta-data updates synchronously. If a directory had been changed, the system waited until the change was actually written to disk. The file data buffers (file contents) were passed through the buffer cache and backed up to disk later on asynchronously. The advantage of this implementation is that it operates safely. If there is a failure during an update, the meta-data are always in a consistent state. A file is either created completely or not at all. If the data blocks of a file did not find their way out of the buffer cache onto the disk by the time of the crash, man:fsck[8] is able to recognize this and repair the filesystem by setting the file length to 0. Additionally, the implementation is clear and simple. The disadvantage is that meta-data changes are slow. An `rm -r`, for instance, touches all the files in a directory sequentially, but each directory change (deletion of a file) will be written synchronously to the disk. This includes updates to the directory itself, to the inode table, and possibly to indirect blocks allocated by the file. Similar considerations apply for unrolling large hierarchies (`tar -x`).

The second case is asynchronous meta-data updates. This is the default for Linux/ext2fs and `mount -o async` for *BSD ufs. All meta-data updates are simply being passed through the buffer cache too, that is, they will be intermixed with the updates of the file content data. The advantage of this implementation is there is no need to wait until each meta-data update has been written to disk, so all operations which cause huge amounts of meta-data updates work much faster than in the synchronous case. Also, the implementation is still clear and simple, so there is a low risk for bugs creeping into the code. The disadvantage is that there is no guarantee at all for a consistent state of the filesystem. If there is a failure during an operation that updated large amounts of meta-data (like a power failure, or someone pressing the reset button), the filesystem will be left in an unpredictable state. There is no opportunity to examine the state of the filesystem when the system comes up again; the data blocks of a file could already have been written to the disk while the updates of the inode table or the associated directory were not. It is actually impossible to implement a `fsck` which is able to clean up the resulting chaos (because the necessary information is not available on the disk). If the filesystem has been damaged beyond repair, the only choice is to use man:newfs[8] on it and restore it from backup. 

The usual solution for this problem was to implement _dirty region logging_, which is also referred to as _journaling_, although that term is not used consistently and is occasionally applied to other forms of transaction logging as well. Meta-data updates are still written synchronously, but only into a small region of the disk. Later on they will be moved to their proper location. Because the logging area is a small, contiguous region on the disk, there are no long distances for the disk heads to move, even during heavy operations, so these operations are quicker than synchronous updates. Additionally the complexity of the implementation is fairly limited, so the risk of bugs being present is low. A disadvantage is that all meta-data are written twice (once into the logging region and once to the proper location) so for normal work, a performance "pessimization" might result. On the other hand, in case of a crash, all pending meta-data operations can be quickly either rolled-back or completed from the logging area after the system comes up again, resulting in a fast filesystem startup.

Kirk McKusick, the developer of Berkeley FFS, solved this problem with Soft Updates: all pending meta-data updates are kept in memory and written out to disk in a sorted sequence ("ordered meta-data updates"). This has the effect that, in case of heavy meta-data operations, later updates to an item "catch" the earlier ones if the earlier ones are still in memory and have not already been written to disk. So all operations on, say, a directory are generally performed in memory before the update is written to disk (the data blocks are sorted according to their position so that they will not be on the disk ahead of their meta-data). If the system crashes, this causes an implicit "log rewind": all operations which did not find their way to the disk appear as if they had never happened. A consistent filesystem state is maintained that appears to be the one of 30 to 60 seconds earlier. The algorithm used guarantees that all resources in use are marked as such in their appropriate bitmaps: blocks and inodes. After a crash, the only resource allocation error that occurs is that resources are marked as "used" which are actually "free". man:fsck[8] recognizes this situation, and frees the resources that are no longer used. It is safe to ignore the dirty state of the filesystem after a crash by forcibly mounting it with `mount -f`. In order to free resources that may be unused, man:fsck[8] needs to be run at a later time. This is the idea behind the _background fsck_: at system startup time, only a _snapshot_ of the filesystem is recorded. The `fsck` can be run later on. All file systems can then be mounted "dirty", so the system startup proceeds in multiuser mode. Then, background ``fsck``s will be scheduled for all file systems where this is required, to free resources that may be unused. (File systems that do not use Soft Updates still need the usual foreground `fsck` though.)

The advantage is that meta-data operations are nearly as fast as asynchronous updates (i.e. faster than with _logging_, which has to write the meta-data twice). The disadvantages are the complexity of the code (implying a higher risk for bugs in an area that is highly sensitive regarding loss of user data), and a higher memory consumption. Additionally there are some idiosyncrasies one has to get used to. After a crash, the state of the filesystem appears to be somewhat "older". In situations where the standard synchronous approach would have caused some zero-length files to remain after the `fsck`, these files do not exist at all with a Soft Updates filesystem because neither the meta-data nor the file contents have ever been written to disk. Disk space is not released until the updates have been written to disk, which may take place some time after running `rm`. This may cause problems when installing large amounts of data on a filesystem that does not have enough free space to hold all the files twice.

[[configtuning-kernel-limits]]
== Tuning Kernel Limits

[[file-process-limits]]
=== File/Process Limits

[[kern-maxfiles]]
==== `kern.maxfiles`

`kern.maxfiles` can be raised or lowered based upon your system requirements. This variable indicates the maximum number of file descriptors on your system. When the file descriptor table is full, `file: table is full` will show up repeatedly in the system message buffer, which can be viewed with the `dmesg` command.

Each open file, socket, or fifo uses one file descriptor. A large-scale production server may easily require many thousands of file descriptors, depending on the kind and number of services running concurrently.

In older FreeBSD releases, the default value of `kern.maxfiles` is derived from the `maxusers` option in your kernel configuration file. `kern.maxfiles` grows proportionally to the value of `maxusers`. When compiling a custom kernel, it is a good idea to set this kernel configuration option according to the uses of your system. From this number, the kernel is given most of its pre-defined limits. Even though a production machine may not actually have 256 users connected at once, the resources needed may be similar to a high-scale web server.

As of FreeBSD 4.5, `kern.maxusers` is automatically sized at boot based on the amount of memory available in the system, and may be determined at run-time by inspecting the value of the read-only `kern.maxusers` sysctl. Some sites will require larger or smaller values of `kern.maxusers` and may set it as a loader tunable; values of 64, 128, and 256 are not uncommon. We do not recommend going above 256 unless you need a huge number of file descriptors; many of the tunable values set to their defaults by `kern.maxusers` may be individually overridden at boot-time or run-time in [.filename]#/boot/loader.conf# (see the man:loader.conf[5] man page or the [.filename]#/boot/defaults/loader.conf# file for some hints) or as described elsewhere in this document. Systems older than FreeBSD 4.4 must set this value via the kernel man:config[8] option `maxusers` instead.

In older releases, the system will auto-tune `maxusers` for you if you explicitly set it to `0`. When setting this option, you will want to set `maxusers` to at least 4, especially if you are using the X Window System or compiling software. The reason is that the most important table set by `maxusers` is the maximum number of processes, which is set to `20 + 16 * maxusers`, so if you set `maxusers` to 1, then you can only have 36 simultaneous processes, including the 18 or so that the system starts up at boot time and the 15 or so you will probably create when you start the X Window System. Even a simple task like reading a manual page will start up nine processes to filter, decompress, and view it. Setting `maxusers` to 64 will allow you to have up to 1044 simultaneous processes, which should be enough for nearly all uses. If, however, you see the dreaded  error when trying to start another program, or are running a server with a large number of simultaneous users (like `ftp.FreeBSD.org`), you can always increase the number and rebuild.

[NOTE]
====
`maxusers` does _not_ limit the number of users which can log into your machine. It simply sets various table sizes to reasonable values considering the maximum number of users you will likely have on your system and how many processes each of them will be running. One keyword which _does_ limit the number of simultaneous remote logins and X terminal windows is crossref:kernelconfig[kernelconfig-ptys,`pseudo-device pty 16`]. With FreeBSD 5.X, you do not have to worry about this number since the man:pty[4] driver is "auto-cloning"; you simply use the line `device pty` in your configuration file.
====

==== `kern.ipc.somaxconn`

The `kern.ipc.somaxconn` sysctl variable limits the size of the listen queue for accepting new TCP connections. The default value of `128` is typically too low for robust handling of new connections in a heavily loaded web server environment. For such environments, it is recommended to increase this value to `1024` or higher. The service daemon may itself limit the listen queue size (e.g. man:sendmail[8], or Apache) but will often have a directive in its configuration file to adjust the queue size. Large listen queues also do a better job of avoiding Denial of Service () attacks.

[[nmbclusters]]
=== Network Limits

The `NMBCLUSTERS` kernel configuration option dictates the amount of network Mbufs available to the system. A heavily-trafficked server with a low number of Mbufs will hinder FreeBSD's ability. Each cluster represents approximately 2 K of memory, so a value of 1024 represents 2 megabytes of kernel memory reserved for network buffers. A simple calculation can be done to figure out how many are needed. If you have a web server which maxes out at 1000 simultaneous connections, and each connection eats a 16 K receive and 16 K send buffer, you need approximately 32 MB worth of network buffers to cover the web server. A good rule of thumb is to multiply by 2, so 2x32 MB / 2 KB = 64 MB / 2 kB = 32768. We recommend values between 4096 and 32768 for machines with greater amounts of memory. Under no circumstances should you specify an arbitrarily high value for this parameter as it could lead to a boot time crash. The `-m` option to man:netstat[1] may be used to observe network cluster use.

`kern.ipc.nmbclusters` loader tunable should be used to tune this at boot time. Only older versions of FreeBSD will require you to use the `NMBCLUSTERS` kernel man:config[8] option.

For busy servers that make extensive use of the man:sendfile[2] system call, it may be necessary to increase the number of man:sendfile[2] buffers via the `NSFBUFS` kernel configuration option or by setting its value in [.filename]#/boot/loader.conf# (see man:loader[8] for details). A common indicator that this parameter needs to be adjusted is when processes are seen in the `sfbufa` state. The sysctl variable `kern.ipc.nsfbufs` is a read-only glimpse at the kernel configured variable. This parameter nominally scales with `kern.maxusers`, however it may be necessary to tune accordingly.

[IMPORTANT]
====
Even though a socket has been marked as non-blocking, calling man:sendfile[2] on the non-blocking socket may result in the man:sendfile[2] call blocking until enough ``struct sf_buf``'s are made available.
====

==== `net.inet.ip.portrange.*`

The `net.inet.ip.portrange.*` sysctl variables control the port number ranges automatically bound to TCP and UDP sockets. There are three ranges: a low range, a default range, and a high range. Most network programs use the default range which is controlled by the `net.inet.ip.portrange.first` and `net.inet.ip.portrange.last`, which default to 1024 and 5000, respectively. Bound port ranges are used for outgoing connections, and it is possible to run the system out of ports under certain circumstances. This most commonly occurs when you are running a heavily loaded web proxy. The port range is not an issue when running servers which handle mainly incoming connections, such as a normal web server, or has a limited number of outgoing connections, such as a mail relay. For situations where you may run yourself out of ports, it is recommended to increase `net.inet.ip.portrange.last` modestly. A value of `10000`, `20000` or `30000` may be reasonable. You should also consider firewall effects when changing the port range. Some firewalls may block large ranges of ports (usually low-numbered ports) and expect systems to use higher ranges of ports for outgoing connections - for this reason it is not recommended that `net.inet.ip.portrange.first` be lowered.

==== TCP Bandwidth Delay Product

The TCP Bandwidth Delay Product Limiting is similar to TCP/Vegas in NetBSD. It can be enabled by setting `net.inet.tcp.inflight.enable` sysctl variable to `1`. The system will attempt to calculate the bandwidth delay product for each connection and limit the amount of data queued to the network to just the amount required to maintain optimum throughput.

This feature is useful if you are serving data over modems, Gigabit Ethernet, or even high speed WAN links (or any other link with a high bandwidth delay product), especially if you are also using window scaling or have configured a large send window. If you enable this option, you should also be sure to set `net.inet.tcp.inflight.debug` to `0` (disable debugging), and for production use setting `net.inet.tcp.inflight.min` to at least `6144` may be beneficial. However, note that setting high minimums may effectively disable bandwidth limiting depending on the link. The limiting feature reduces the amount of data built up in intermediate route and switch packet queues as well as reduces the amount of data built up in the local host's interface queue. With fewer packets queued up, interactive connections, especially over slow modems, will also be able to operate with lower _Round Trip Times_. However, note that this feature only effects data transmission (uploading / server side). It has no effect on data reception (downloading). 

Adjusting `net.inet.tcp.inflight.stab` is _not_ recommended. This parameter defaults to 20, representing 2 maximal packets added to the bandwidth delay product window calculation. The additional window is required to stabilize the algorithm and improve responsiveness to changing conditions, but it can also result in higher ping times over slow links (though still much lower than you would get without the inflight algorithm). In such cases, you may wish to try reducing this parameter to 15, 10, or 5; and may also have to reduce `net.inet.tcp.inflight.min` (for example, to 3500) to get the desired effect. Reducing these parameters should be done as a last resort only.

=== Virtual Memory

==== `kern.maxvnodes`

A vnode is the internal representation of a file or directory. So increasing the number of vnodes available to the operating system cuts down on disk I/O. Normally this is handled by the operating system and does not need to be changed. In some cases where disk I/O is a bottleneck and the system is running out of vnodes, this setting will need to be increased. The amount of inactive and free RAM will need to be taken into account.

To see the current number of vnodes in use:

[.programlisting]
....
#  sysctl vfs.numvnodes
vfs.numvnodes: 91349
....

To see the maximum vnodes:

[.programlisting]
....
#  sysctl kern.maxvnodes
kern.maxvnodes: 100000
....

If the current vnode usage is near the maximum, increasing `kern.maxvnodes` by a value of 1,000 is probably a good idea. Keep an eye on the number of `vfs.numvnodes`. If it climbs up to the maximum again, `kern.maxvnodes` will need to be increased further. A shift in your memory usage as reported by man:top[1] should be visible. More memory should be active.

[[adding-swap-space]]
== Adding Swap Space

No matter how well you plan, sometimes a system does not run as you expect. If you find you need more swap space, it is simple enough to add. You have three ways to increase swap space: adding a new hard drive, enabling swap over NFS, and creating a swap file on an existing partition.

For information on how to encrypt swap space, what options for this task exist and why it should be done, please refer to crossref:disks[swap-encrypting,Encrypting Swap Space] of the Handbook.

[[new-drive-swap]]
=== Swap on a New Hard Drive

The best way to add swap, of course, is to use this as an excuse to add another hard drive. You can always use another hard drive, after all. If you can do this, go reread the discussion of swap space in <<configtuning-initial>> of the Handbook for some suggestions on how to best arrange your swap.

[[nfs-swap]]
=== Swapping over NFS

Swapping over NFS is only recommended if you do not have a local hard disk to swap to; NFS swapping will be limited by the available network bandwidth and puts an additional burden on the NFS server.

[[create-swapfile]]
=== Swapfiles

You can create a file of a specified size to use as a swap file. In our example here we will use a 64MB file called [.filename]#/usr/swap0#. You can use any name you want, of course.

.Creating a Swapfile on FreeBSD
[example]
====
. Be certain that your kernel configuration includes the memory disk driver (man:md[4]). It is default in [.filename]#GENERIC# kernel.
+
[.programlisting]
....
device   md   # Memory "disks"
....

. Create a swapfile ([.filename]#/usr/swap0#):
+
[source,bash]
....
# dd if=/dev/zero of=/usr/swap0 bs=1024k count=64
....

. Set proper permissions on ([.filename]#/usr/swap0#):
+
[source,bash]
....
# chmod 0600 /usr/swap0
....

. Enable the swap file in [.filename]#/etc/rc.conf#:
+
[.programlisting]
....
swapfile="/usr/swap0"   # Set to name of swapfile if aux swapfile desired.
....

. Reboot the machine or to enable the swap file immediately, type:
+
[source,bash]
....
# mdconfig -a -t vnode -f /usr/swap0 -u 0 && swapon /dev/md0
....

====

[[acpi-overview]]
== Power and Resource Management

It is important to utilize hardware resources in an efficient manner. Before ACPI was introduced, it was difficult and inflexible for operating systems to manage the power usage and thermal properties of a system. The hardware was managed by the BIOS and thus the user had less control and visibility into the power management settings. Some limited configurability was available via _Advanced Power Management (APM)_. Power and resource management is one of the key components of a modern operating system. For example, you may want an operating system to monitor system limits (and possibly alert you) in case your system temperature increased unexpectedly.

In this section of the FreeBSD Handbook, we will provide comprehensive information about ACPI. References will be provided for further reading at the end.

[[acpi-intro]]
=== What Is ACPI?

Advanced Configuration and Power Interface (ACPI) is a standard written by an alliance of vendors to provide a standard interface for hardware resources and power management (hence the name). It is a key element in _Operating System-directed configuration and Power Management_, i.e.: it provides more control and flexibility to the operating system (OS). Modern systems "stretched" the limits of the current Plug and Play interfaces prior to the introduction of ACPI. ACPI is the direct successor to APM (Advanced Power Management).

[[acpi-old-spec]]
=== Shortcomings of Advanced Power Management (APM)

The _Advanced Power Management (APM)_ facility controls the power usage of a system based on its activity. The APM BIOS is supplied by the (system) vendor and it is specific to the hardware platform. An APM driver in the OS mediates access to the _APM Software Interface_, which allows management of power levels. APM should still be used for systems manufactured at or before the year 2000.

There are four major problems in APM. Firstly, power management is done by the (vendor-specific) BIOS, and the OS does not have any knowledge of it. One example of this, is when the user sets idle-time values for a hard drive in the APM BIOS, that when exceeded, it (BIOS) would spin down the hard drive, without the consent of the OS. Secondly, the APM logic is embedded in the BIOS, and it operates outside the scope of the OS. This means users can only fix problems in their APM BIOS by flashing a new one into the ROM; which is a very dangerous procedure with the potential to leave the system in an unrecoverable state if it fails. Thirdly, APM is a vendor-specific technology, which means that there is a lot of parity (duplication of efforts) and bugs found in one vendor's BIOS, may not be solved in others. Last but not the least, the APM BIOS did not have enough room to implement a sophisticated power policy, or one that can adapt very well to the purpose of the machine.

_Plug and Play BIOS (PNPBIOS)_ was unreliable in many situations. PNPBIOS is 16-bit technology, so the OS has to use 16-bit emulation in order to "interface" with PNPBIOS methods.

The FreeBSD APM driver is documented in the man:apm[4] manual page.

[[acpi-config]]
=== Configuring ACPI

The [.filename]#acpi.ko# driver is loaded by default at start up by the man:loader[8] and should _not_ be compiled into the kernel. The reasoning behind this is that modules are easier to work with, say if switching to another [.filename]#acpi.ko# without doing a kernel rebuild. This has the advantage of making testing easier. Another reason is that starting ACPI after a system has been brought up often doesn't work well. If you are experiencing problems, you can disable ACPI altogether. This driver should not and can not be unloaded because the system bus uses it for various hardware interactions. ACPI can be disabled by setting `hint.acpi.0.disabled="1"` in [.filename]#/boot/loader.conf# or at the man:loader[8] prompt. 

[NOTE]
====
ACPI and APM cannot coexist and should be used separately. The last one to load will terminate if the driver notices the other running.
====

ACPI can be used to put the system into a sleep mode with man:acpiconf[8], the `-s` flag, and a `1-5` option. Most users will only need `1` or `3` (suspend to RAM). Option `5` will do a soft-off which is the same action as:

[source,bash]
....
# halt -p
....

Other options are available via man:sysctl[8]. Check out the man:acpi[4] and man:acpiconf[8] manual pages for more information. 

[[ACPI-debug]]
== Using and Debugging FreeBSD ACPI

ACPI is a fundamentally new way of discovering devices, managing power usage, and providing standardized access to various hardware previously managed by the BIOS. Progress is being made toward ACPI working on all systems, but bugs in some motherboards' _ACPI Machine Language_ (AML) bytecode, incompleteness in FreeBSD's kernel subsystems, and bugs in the Intel(R) ACPI-CA interpreter continue to appear.

This document is intended to help you assist the FreeBSD ACPI maintainers in identifying the root cause of problems you observe and debugging and developing a solution. Thanks for reading this and we hope we can solve your system's problems.

[[ACPI-submitdebug]]
=== Submitting Debugging Information

[NOTE]
====
Before submitting a problem, be sure you are running the latest BIOS version and, if available, embedded controller firmware version.
====

For those of you that want to submit a problem right away, please send the following information to link:mailto:freebsd-acpi@FreeBSD.org[ freebsd-acpi@FreeBSD.org]:

* Description of the buggy behavior, including system type and model and anything that causes the bug to appear. Also, please note as accurately as possible when the bug began occurring if it is new for you.
* The man:dmesg[8] output after `boot -v`, including any error messages generated by you exercising the bug.
* The man:dmesg[8] output from `boot -v` with ACPI disabled, if disabling it helps fix the problem.
* Output from `sysctl hw.acpi`. This is also a good way of figuring out what features your system offers.
* URL where your _ACPI Source Language_ (ASL) can be found. Do _not_ send the ASL directly to the list as it can be very large. Generate a copy of your ASL by running this command:
+

[source,bash]
....
# acpidump -dt > name-system.asl
....

+ 
(Substitute your login name for _name_ and manufacturer/model for _system_. Example: [.filename]#njl-FooCo6000.asl#)

Most of the developers watch the {freebsd-current} but please submit problems to {freebsd-acpi} to be sure it is seen. Please be patient, all of us have full-time jobs elsewhere. If your bug is not immediately apparent, we will probably ask you to submit a PR via man:send-pr[1]. When entering a PR, please include the same information as requested above. This will help us track the problem and resolve it. Do not send a PR without emailing {freebsd-acpi} first as we use PRs as reminders of existing problems, not a reporting mechanism. It is likely that your problem has been reported by someone before.

[[ACPI-background]]
=== Background

ACPI is present in all modern computers that conform to the ia32 (x86), ia64 (Itanium), and amd64 (AMD) architectures. The full standard has many features including CPU performance management, power planes control, thermal zones, various battery systems, embedded controllers, and bus enumeration. Most systems implement less than the full standard. For instance, a desktop system usually only implements the bus enumeration parts while a laptop might have cooling and battery management support as well. Laptops also have suspend and resume, with their own associated complexity.

An ACPI-compliant system has various components. The BIOS and chipset vendors provide various fixed tables (e.g., FADT) in memory that specify things like the APIC map (used for SMP), config registers, and simple configuration values. Additionally, a table of bytecode (the _Differentiated System Description Table_ DSDT) is provided that specifies a tree-like name space of devices and methods.

The ACPI driver must parse the fixed tables, implement an interpreter for the bytecode, and modify device drivers and the kernel to accept information from the ACPI subsystem. For FreeBSD, Intel(R) has provided an interpreter (ACPI-CA) that is shared with Linux and NetBSD. The path to the ACPI-CA source code is [.filename]#src/sys/contrib/dev/acpica#. The glue code that allows ACPI-CA to work on FreeBSD is in [.filename]#src/sys/dev/acpica/Osd#. Finally, drivers that implement various ACPI devices are found in [.filename]#src/sys/dev/acpica#.

[[ACPI-comprob]]
=== Common Problems

For ACPI to work correctly, all the parts have to work correctly. Here are some common problems, in order of frequency of appearance, and some possible workarounds or fixes.

==== Mouse Issues

In some cases, resuming from a suspend operation will cause the mouse to fail. A known work around is to add `hint.psm.0.flags="0x3000"` to the [.filename]#/boot/loader.conf# file. If this does not work then please consider sending a bug report as described above.

==== Suspend/Resume

ACPI has three suspend to RAM (STR) states, `S1`-`S3`, and one suspend to disk state (`STD`), called `S4`. `S5` is "soft off" and is the normal state your system is in when plugged in but not powered up. `S4` can actually be implemented two separate ways. ``S4``BIOS is a BIOS-assisted suspend to disk. ``S4``OS is implemented entirely by the operating system.

Start by checking `sysctl hw.acpi` for the suspend-related items. Here are the results for a Thinkpad:

[source,bash]
....
hw.acpi.supported_sleep_state: S3 S4 S5
hw.acpi.s4bios: 0
....

This means that we can use `acpiconf -s` to test `S3`, ``S4``OS, and `S5`. If `s4bios` was one (`1`), we would have ``S4``BIOS support instead of ``S4``OS.

When testing suspend/resume, start with `S1`, if supported. This state is most likely to work since it does not require much driver support. No one has implemented `S2` but if you have it, it is similar to `S1`. The next thing to try is `S3`. This is the deepest STR state and requires a lot of driver support to properly reinitialize your hardware. If you have problems resuming, feel free to email the {freebsd-acpi} list but do not expect the problem to be resolved since there are a lot of drivers/hardware that need more testing and work.

To help isolate the problem, remove as many drivers from your kernel as possible. If it works, you can narrow down which driver is the problem by loading drivers until it fails again. Typically binary drivers like [.filename]#nvidia.ko#, X11 display drivers, and USB will have the most problems while Ethernet interfaces usually work fine. If you can properly load/unload the drivers, you can automate this by putting the appropriate commands in [.filename]#/etc/rc.suspend# and [.filename]#/etc/rc.resume#. There is a commented-out example for unloading and loading a driver. Try setting `hw.acpi.reset_video` to zero (`0`) if your display is messed up after resume. Try setting longer or shorter values for `hw.acpi.sleep_delay` to see if that helps.

Another thing to try is load a recent Linux distribution with ACPI support and test their suspend/resume support on the same hardware. If it works on Linux, it is likely a FreeBSD driver problem and narrowing down which driver causes the problems will help us fix the problem. Note that the ACPI maintainers do not usually maintain other drivers (e.g sound, ATA, etc.) so any work done on tracking down a driver problem should probably eventually be posted to the {freebsd-current} list and mailed to the driver maintainer. If you are feeling adventurous, go ahead and start putting some debugging man:printf[3]s in a problematic driver to track down where in its resume function it hangs.

Finally, try disabling ACPI and enabling APM instead. If suspend/resume works with APM, you may be better off sticking with APM, especially on older hardware (pre-2000). It took vendors a while to get ACPI support correct and older hardware is more likely to have BIOS problems with ACPI.

==== System Hangs (temporary or permanent)

Most system hangs are a result of lost interrupts or an interrupt storm. Chipsets have a lot of problems based on how the BIOS configures interrupts before boot, correctness of the APIC (MADT) table, and routing of the _System Control Interrupt_ (SCI).

Interrupt storms can be distinguished from lost interrupts by checking the output of `vmstat -i` and looking at the line that has `acpi0`. If the counter is increasing at more than a couple per second, you have an interrupt storm. If the system appears hung, try breaking to DDB (kbd:[CTRL+ALT+ESC] on console) and type `show interrupts`.

Your best hope when dealing with interrupt problems is to try disabling APIC support with `hint.apic.0.disabled="1"` in [.filename]#loader.conf#.

==== Panics

Panics are relatively rare for ACPI and are the top priority to be fixed. The first step is to isolate the steps to reproduce the panic (if possible) and get a backtrace. Follow the advice for enabling `options DDB` and setting up a serial console (see crossref:serialcomms:[serialconsole-ddb,Είσοδος στον DDB Debugger Μέσω της Σειριακής Γραμμής]) or setting up a man:dump[8] partition. You can get a backtrace in DDB with `tr`. If you have to handwrite the backtrace, be sure to at least get the lowest five (5) and top five (5) lines in the trace.

Then, try to isolate the problem by booting with ACPI disabled. If that works, you can isolate the ACPI subsystem by using various values of `debug.acpi.disable`. See the man:acpi[4] manual page for some examples.

==== System Powers Up After Suspend or Shutdown

First, try setting `hw.acpi.disable_on_poweroff="0"` in man:loader.conf[5]. This keeps ACPI from disabling various events during the shutdown process. Some systems need this value set to `1` (the default) for the same reason. This usually fixes the problem of a system powering up spontaneously after a suspend or poweroff.

==== Other Problems

If you have other problems with ACPI (working with a docking station, devices not detected, etc.), please email a description to the mailing list as well; however, some of these issues may be related to unfinished parts of the ACPI subsystem so they might take a while to be implemented. Please be patient and prepared to test patches we may send you.

[[ACPI-aslanddump]]
=== ASL, `acpidump`, and IASL

The most common problem is the BIOS vendors providing incorrect (or outright buggy!) bytecode. This is usually manifested by kernel console messages like this:

[source,bash]
....
ACPI-1287: *** Error: Method execution failed [\\_SB_.PCI0.LPC0.FIGD._STA] \\
(Node 0xc3f6d160), AE_NOT_FOUND
....

Often, you can resolve these problems by updating your BIOS to the latest revision. Most console messages are harmless but if you have other problems like battery status not working, they are a good place to start looking for problems in the AML. The bytecode, known as AML, is compiled from a source language called ASL. The AML is found in the table known as the DSDT. To get a copy of your ASL, use man:acpidump[8]. You should use both the `-t` (show contents of the fixed tables) and `-d` (disassemble AML to ASL) options. See the <<ACPI-submitdebug,Submitting Debugging Information>> section for an example syntax.

The simplest first check you can do is to recompile your ASL to check for errors. Warnings can usually be ignored but errors are bugs that will usually prevent ACPI from working correctly. To recompile your ASL, issue the following command:

[source,bash]
....
# iasl your.asl
....

[[ACPI-fixasl]]
=== Fixing Your ASL

In the long run, our goal is for almost everyone to have ACPI work without any user intervention. At this point, however, we are still developing workarounds for common mistakes made by the BIOS vendors. The Microsoft(R) interpreter ([.filename]#acpi.sys# and [.filename]#acpiec.sys#) does not strictly check for adherence to the standard, and thus many BIOS vendors who only test ACPI under Windows(R) never fix their ASL. We hope to continue to identify and document exactly what non-standard behavior is allowed by Microsoft(R)'s interpreter and replicate it so FreeBSD can work without forcing users to fix the ASL. As a workaround and to help us identify behavior, you can fix the ASL manually. If this works for you, please send a man:diff[1] of the old and new ASL so we can possibly work around the buggy behavior in ACPI-CA and thus make your fix unnecessary.

Here is a list of common error messages, their cause, and how to fix them:

==== _OS dependencies

Some AML assumes the world consists of various Windows(R) versions. You can tell FreeBSD to claim it is any OS to see if this fixes problems you may have. An easy way to override this is to set `hw.acpi.osname="Windows 2001"` in [.filename]#/boot/loader.conf# or other similar strings you find in the ASL.

==== Missing Return statements

Some methods do not explicitly return a value as the standard requires. While ACPI-CA does not handle this, FreeBSD has a workaround that allows it to return the value implicitly. You can also add explicit Return statements where required if you know what value should be returned. To force `iasl` to compile the ASL, use the `-f` flag.

==== Overriding the Default AML

After you customize [.filename]#your.asl#, you will want to compile it, run:

[source,bash]
....
# iasl your.asl
....

You can add the `-f` flag to force creation of the AML, even if there are errors during compilation. Remember that some errors (e.g., missing Return statements) are automatically worked around by the interpreter.

[.filename]#DSDT.aml# is the default output filename for `iasl`. You can load this instead of your BIOS's buggy copy (which is still present in flash memory) by editing [.filename]#/boot/loader.conf# as follows:

[.programlisting]
....
acpi_dsdt_load="YES"
acpi_dsdt_name="/boot/DSDT.aml"
....

Be sure to copy your [.filename]#DSDT.aml# to the [.filename]#/boot# directory.

[[ACPI-debugoutput]]
=== Getting Debugging Output From ACPI

The ACPI driver has a very flexible debugging facility. It allows you to specify a set of subsystems as well as the level of verbosity. The subsystems you wish to debug are specified as "layers" and are broken down into ACPI-CA components (ACPI_ALL_COMPONENTS) and ACPI hardware support (ACPI_ALL_DRIVERS). The verbosity of debugging output is specified as the "level" and ranges from ACPI_LV_ERROR (just report errors) to ACPI_LV_VERBOSE (everything). The "level" is a bitmask so multiple options can be set at once, separated by spaces. In practice, you will want to use a serial console to log the output if it is so long it flushes the console message buffer. A full list of the individual layers and levels is found in the man:acpi[4] manual page.

Debugging output is not enabled by default. To enable it, add `options ACPI_DEBUG` to your kernel configuration file if ACPI is compiled into the kernel. You can add `ACPI_DEBUG=1` to your [.filename]#/etc/make.conf# to enable it globally. If it is a module, you can recompile just your [.filename]#acpi.ko# module as follows:

[source,bash]
....
# cd /sys/modules/acpi/acpi
&& make clean &&
make ACPI_DEBUG=1
....

Install [.filename]#acpi.ko# in [.filename]#/boot/kernel# and add your desired level and layer to [.filename]#loader.conf#. This example enables debug messages for all ACPI-CA components and all ACPI hardware drivers (CPU, LID, etc.). It will only output error messages, the least verbose level.

[.programlisting]
....
debug.acpi.layer="ACPI_ALL_COMPONENTS ACPI_ALL_DRIVERS"
debug.acpi.level="ACPI_LV_ERROR"
....

If the information you want is triggered by a specific event (say, a suspend and then resume), you can leave out changes to [.filename]#loader.conf# and instead use `sysctl` to specify the layer and level after booting and preparing your system for the specific event. The ``sysctl``s are named the same as the tunables in [.filename]#loader.conf#.

[[ACPI-References]]
=== References

More information about ACPI may be found in the following locations:

* The {freebsd-acpi}
* The ACPI Mailing List Archives http://lists.freebsd.org/pipermail/freebsd-acpi/[http://lists.freebsd.org/pipermail/freebsd-acpi/]
* The old ACPI Mailing List Archives http://home.jp.FreeBSD.org/mail-list/acpi-jp/[http://home.jp.FreeBSD.org/mail-list/acpi-jp/]
* The ACPI 2.0 Specification http://acpi.info/spec.htm[http://acpi.info/spec.htm]
* FreeBSD Manual pages: man:acpi[4], man:acpi_thermal[4], man:acpidump[8], man:iasl[8], man:acpidb[8]
* http://www.cpqlinux.com/acpi-howto.html#fix_broken_dsdt[DSDT debugging resource]. (Uses Compaq as an example but generally useful.)
