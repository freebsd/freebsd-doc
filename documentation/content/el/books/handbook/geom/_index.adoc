---
title: "Κεφάλαιο 20. GEOM: Διαχείριση Συστοιχιών Δίσκων"
part: Μέρος III. Διαχείριση Συστήματος
prev: books/handbook/disks
next: books/handbook/filesystems
---

[[geom]]
= GEOM: Διαχείριση Συστοιχιών Δίσκων
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:source-highlighter: rouge
:experimental:
:skip-front-matter:
:toc-title: Πίνακας Περιεχομένων
:table-caption: Πίνακας
:figure-caption: Σχήμα
:example-caption: Παράδειγμα
:xrefstyle: basic
:relfileprefix: ../
:outfilesuffix:
:sectnumoffset: 20

ifeval::["{backend}" == "html5"]
:imagesdir: ../../../../images/books/handbook/geom/
endif::[]

ifeval::["{backend}" == "pdf"]
:imagesdir: ../../../../static/images/books/handbook/geom/
endif::[]

ifeval::["{backend}" == "epub3"]
:imagesdir: ../../../../static/images/books/handbook/geom/
endif::[]

include::shared/authors.adoc[]
include::shared/releases.adoc[]
include::shared/el/mailing-lists.adoc[]
include::shared/el/teams.adoc[]
include::shared/el/urls.adoc[]

toc::[]

[[GEOM-synopsis]]
== Σύνοψη

Το κεφάλαιο αυτό καλύπτει τη χρήση των δίσκων κάτω από το πλαίσιο λειτουργιών GEOM στο FreeBSD. Περιλαμβάνει τα κυριότερα προγράμματα ελέγχου RAID των οποίων οι ρυθμίσεις βασίζονται στο πλαίσιο GEOM. Το κεφάλαιο αυτό δεν αναλύει σε βάθος τον τρόπο με τον οποίο το GEOM χειρίζεται ή ελέγχει λειτουργίες Εισόδου / Εξόδου (IO), το υποσύστημα που βρίσκεται κάτω από αυτό, ή τον κώδικα του. Οι πληροφορίες αυτές παρέχονται από τη σελίδα manual του man:geom[4] καθώς και από τις αναφορές που περιέχει σε άλλες σχετικές σελίδες. Επίσης το κεφάλαιο αυτό δεν αποτελεί καθοριστικό οδηγό για όλες τις ρυθμίσεις του RAID. Θα συζητηθούν μόνο οι καταστάσεις λειτουργίας του RAID που υποστηρίζονται από το GEOM.

Αφού διαβάσετε αυτό το κεφάλαιο, θα ξέρετε:

* Το είδος της υποστήριξης RAID που είναι διαθέσιμο μέσω του GEOM.
* Πως να χρησιμοποιήσετε τα βασικά βοηθητικά προγράμματα για την ρύθμιση, συντήρηση και διαχείριση των διαφόρων επιπέδων  RAID.
* Πως να δημιουργήσετε mirror ή stripe, να κρυπτογραφήσετε, και να συνδέσετε δίσκους με το GEOM, μέσω μιας απομακρυσμένης σύνδεσης.
* Πως να αντιμετωπίσετε προβλήματα δίσκων που χρησιμοποιούν το πλαίσιο λειτουργιών GEOM.

Πριν διαβάσετε αυτό το κεφάλαιο, θα πρέπει:

* Να κατανοείτε πως μεταχειρίζεται το FreeBSD τις συσκευές δίσκων (crossref:disks[disks,Αποθηκευτικά Μέσα]).
* Να γνωρίζετε πως θα ρυθμίσετε και θα εγκαταστήσετε ένα νέο πυρήνα στο FreeBSD (crossref:kernelconfig[kernelconfig,Ρυθμίζοντας τον Πυρήνα του FreeBSD]).

[[GEOM-intro]]
== Εισαγωγή στο GEOM

Το GEOM επιτρέπει την πρόσβαση και τον έλεγχο σε κλάσεις - όπως την Κεντρική Εγγραφή Εκκίνησης (Master Boot Record), τα BSD labels, κ.α. - μέσω της χρήσης παροχέων, ή μέσω ειδικών αρχείων στον κατάλογο [.filename]#/dev#. Το GEOM υποστηρίζει διάφορες διατάξεις RAID και παρέχει διάφανη πρόσβαση στο λειτουργικό σύστημα και τα βοηθητικά του προγράμματα.

[[GEOM-striping]]
== RAID0 - Striping

Το striping είναι μια μέθοδος που συνδυάζει διαφορετικούς φυσικούς δίσκους σε ένα μοναδικό λογικό τόμο. Σε πολλές περιπτώσεις, αυτό γίνεται με την βοήθεια εξειδικευμένου υλικού (ελεγκτών). Το υποσύστημα δίσκων GEOM παρέχει υποστήριξη μέσω λογισμικού για τη διάταξη RAID0, η οποία είναι γνωστή και ως striping.

Σε ένα σύστημα RAID0, τα δεδομένα χωρίζονται σε blocks τα οποία γράφονται τμηματικά σε όλους τους δίσκους που αποτελούν τη συστοιχία. Αντί να χρειάζεται να περιμένετε το σύστημα να γράψει 256k δεδομένων σε ένα δίσκο, ένα σύστημα RAID0 μπορεί να γράψει ταυτόχρονα 64k σε καθένα από τους τέσσερις δίσκους μιας συστοιχίας, προσφέροντας έτσι εξαιρετική απόδοση εισόδου/εξόδου (I/O). Η απόδοση αυτή μπορεί να αυξηθεί περισσότερο, με τη χρήση πολλαπλών ελεγκτών δίσκων.

Κάθε δίσκος σε ένα stripe RAID0 πρέπει να είναι του ίδιου μεγέθους, καθώς οι αιτήσεις I/O μοιράζονται όσο αφορά την ανάγνωση και εγγραφή, σε πολλούς παράλληλους δίσκους.

image::striping.png[Διάγραμμα Disk Striping]

[.procedure]
====
*Procedure: Δημιουργία Stripe από μη-Διαμορφωμένους ATA Δίσκους*

. Φορτώστε το άρθρωμα [.filename]#geom_stripe.ko#:
+
[source,bash]
....
# kldload geom_stripe
....

. Εξασφαλίστε ότι υπάρχει κατάλληλο σημείο προσάρτησης. Αν ο τόμος πρόκειται να γίνει κατάτμηση root, προσαρτήστε τον προσωρινά σε κάποιο άλλο σημείο προσάρτησης, όπως το [.filename]#/mnt#:
+
[source,bash]
....
# mkdir /mnt
....

. Καθορίστε τα ονόματα των συσκευών για τους δίσκους που πρόκειται να γίνουν stripe, και δημιουργήστε τη νέα συσκευή stripe. Για παράδειγμα, για να δημιουργήσετε ένα stripe από δύο αχρησιμοποίητους και χωρίς κατατμήσεις δίσκους ATA, όπως π.χ. τους [.filename]#/dev/ad2# και [.filename]#/dev/ad3#:
+
[source,bash]
....
# gstripe label -v st0 /dev/ad2 /dev/ad3
Metadata value stored on /dev/ad2.
Metadata value stored on /dev/ad3.
Done.
....

. Γράψτε ένα τυποποιημένο label (πίνακα κατατμήσεων) στο νέο τόμο, και εγκαταστήστε τον προεπιλεγμένο κώδικα εκκίνησης (bootstrap):
+
[source,bash]
....
# bsdlabel -wB /dev/stripe/st0
....

. Η διαδικασία αυτή θα δημιουργήσει τη συσκευή [.filename]#st0#, καθώς και δύο ακόμα συσκευές στον κατάλογο [.filename]#/dev/stripe#. Οι συσκευές αυτές θα ονομάζονται [.filename]#st0a# και [.filename]#st0c#. Στο σημείο αυτό, μπορείτε πλέον να δημιουργήσετε σύστημα αρχείων στη συσκευή [.filename]#st0a# χρησιμοποιώντας το βοηθητικό πρόγραμμα `newfs`:
+
[source,bash]
....
# newfs -U /dev/stripe/st0a
....
+ 
Θα δείτε μια μεγάλη σειρά αριθμών να περνά γρήγορα από την οθόνη σας, και μετά από λίγα δευτερόλεπτα η διαδικασία θα έχει ολοκληρωθεί. Ο τόμος θα έχει δημιουργηθεί και θα είναι έτοιμος για προσάρτηση.
====

Για να προσαρτήσετε χειροκίνητα το stripe που δημιουργήσατε:

[source,bash]
....
# mount /dev/stripe/st0a /mnt
....

Για να γίνεται αυτόματα η προσάρτηση αυτού του συστήματος αρχείων κατά την διαδικασία εκκίνησης, τοποθετήστε τις πληροφορίες του τόμου στο αρχείο [.filename]#/etc/fstab#. Για το σκοπό αυτό, δημιουργούμε ένα μόνιμο σημείο προσάρτησης, το [.filename]#stripe#:

[source,bash]
....
# mkdir /stripe
# echo "/dev/stripe/st0a /stripe ufs rw 2 2" \
    >> /etc/fstab
....

Το άρθρωμα [.filename]#geom_stripe.ko# θα πρέπει να φορτώνεται αυτόματα κατά την εκκίνηση του συστήματος. Εκτελέστε την παρακάτω εντολή, για να προσθέσετε την κατάλληλη ρύθμιση στο [.filename]#/boot/loader.conf#:

[source,bash]
....
# echo 'geom_stripe_load="YES"' >> /boot/loader.conf
....

[[GEOM-mirror]]
== RAID1 - Mirroring

Το mirroring (καθρεφτισμός) είναι μια τεχνολογία που χρησιμοποιείται από πολλές εταιρίες και οικιακούς χρήστες για να ασφαλίσουν τα δεδομένα τους χωρίς διακοπές. Σε μια διάταξη mirror, ο δίσκος Β είναι απλώς ένα πλήρες αντίγραφο του δίσκου Α. Ή μπορεί οι δίσκοι Γ+Δ να είναι αντίγραφα των δίσκων A+B. Άσχετα με την ακριβή διάταξη των δίσκων, το σημαντικό είναι ότι οι πληροφορίες ενός δίσκου ή μιας κατάτμησης αντιγράφονται σε άλλους. Οι πληροφορίες αυτές μπορεί αργότερα να αποκατασταθούν με εύκολο τρόπο, ή να αντιγραφούν χωρίς να προκληθεί διακοπή στις υπηρεσίες του μηχανήματος ή στην πρόσβαση των δεδομένων. Μπορούν ακόμα και να μεταφερθούν και να φυλαχθούν σε άλλο, ασφαλές μέρος.

Για να ξεκινήσετε, βεβαιωθείτε ότι το σύστημα σας έχει δύο σκληρούς δίσκους ίδιου μεγέθους. Στα παραδείγματα μας θεωρούμε ότι οι δίσκοι είναι τύπου SCSI (απευθείας πρόσβασης, man:da[4]).

=== Mirroring στους Βασικούς Δίσκους

Υποθέτοντας ότι το FreeBSD έχει εγκατασταθεί στον πρώτο δίσκο [.filename]#da0#, θα πρέπει να ρυθμίσετε το man:gmirror[8] να αποθηκεύσει εκεί τα βασικά δεδομένα του.

Πριν δημιουργήσετε το mirror, ενεργοποιήστε την δυνατότητα εμφάνισης περισσότερων λεπτομερειών (που μπορεί να σας βοηθήσουν σε περίπτωση προβλήματος) και επιτρέψτε την απευθείας πρόσβαση στη συσκευή δίσκου. Για το σκοπό αυτό θέστε τη μεταβλητή `kern.geom.debugflags` του man:sysctl[8] στην παρακάτω τιμή:

[source,bash]
....
# sysctl kern.geom.debugflags=17
....

Μπορείτε τώρα να δημιουργήσετε το mirror. Ξεκινήστε τη διαδικασία αποθηκεύοντας τα μετα-δεδομένα (meta-data) στον βασικό δίσκο, δημιουργώντας ουσιαστικά τη συσκευή [.filename]#/dev/mirror/gm#. Χρησιμοποιήστε την παρακάτω εντολή:

[WARNING]
====

Η δημιουργία mirror στο δίσκο εκκίνησης μπορεί να έχει ως αποτέλεσμα την απώλεια δεδομένων, αν ο τελευταίος τομέας του δίσκου έχει ήδη χρησιμοποιηθεί. Η πιθανότητα αυτή είναι πολύ μικρότερη αν το mirror δημιουργηθεί αμέσως μετά από μια νέα εγκατάσταση του FreeBSD. Η παρακάτω διαδικασία είναι επίσης ασύμβατη με τις προεπιλεγμένες ρυθμίσεις εγκατάστασης του FreeBSD 9._X_ στις οποίες χρησιμοποιείται το σύστημα κατατμήσεων GPT. To GEOM καταστρέφει τα μεταδεδομένα του GPT, και θα προκαλέσει απώλεια δεδομένων και πιθανή αδυναμία εκκίνησης του συστήματος.
====

[source,bash]
....
# gmirror label -vb round-robin gm0 /dev/da0
....

Το σύστημα θα ανταποκριθεί με το παρακάτω μήνυμα:

[source,bash]
....
Metadata value stored on /dev/da0.
Done.
....

Αρχικοποιήστε το GEOM. Η παρακάτω εντολή θα φορτώσει το άρθρωμα [.filename]#/boot/kernel/geom_mirror.ko# στον πυρήνα:

[source,bash]
....
# gmirror load
....

[NOTE]
====
Με την επιτυχή εκτέλεση αυτής της εντολής, δημιουργείται η συσκευή [.filename]#gm0# μέσα στον κατάλογο [.filename]#/dev/mirror#.
====

Ενεργοποιήστε το φόρτωμα του αρθρώματος [.filename]#geom_mirror.ko# κατά την εκκίνηση του συστήματος:

[source,bash]
....
# echo 'geom_mirror_load="YES"' >> /boot/loader.conf
....

Επεξεργαστείτε το αρχείο [.filename]#/etc/fstab#, αντικαθιστώντας τις αναφορές στις παλιές συσκευές [.filename]#da0# με τις αντίστοιχες καινούριες [.filename]#gm0# που αντιπροσωπεύουν το mirror.

[NOTE]
====
Αν χρησιμοποιείτε το man:vi[1], μπορείτε να ακολουθήσετε τα παρακάτω βήματα για να ολοκληρώσετε εύκολα αυτή τη διαδικασία:

[source,bash]
....
# vi /etc/fstab
....

Στο man:vi[1], κρατήστε αντίγραφο ασφαλείας του τρέχοντος αρχείου [.filename]#fstab# πληκτρολογώντας `:w /etc/fstab.bak`. Έπειτα αντικαταστήστε όλες τις αναφορές στις παλιές συσκευές [.filename]#da0# με τις νέες [.filename]#gm0# γράφοντας `:%s/da/mirror\/gm/g`.
====

Το [.filename]#fstab# που θα προκύψει, θα μοιάζει με το παρακάτω. Δεν έχει σημασία αν οι δίσκοι ήταν αρχικά SCSI ή ATA, η συσκευή RAID θα έχει πάντα το όνομα [.filename]#gm#.

[.programlisting]
....
# Device                  Mountpoint  FStype      Options   Dump     Pass#
/dev/mirror/gm0s1b        none        swap        sw        0        0
/dev/mirror/gm0s1a        /           ufs         rw        1        1
/dev/mirror/gm0s1d        /usr        ufs         rw        0        0
/dev/mirror/gm0s1f        /home       ufs         rw        2        2
#/dev/mirror/gm0s2d       /store      ufs         rw        2        2
/dev/mirror/gm0s1e        /var        ufs         rw        2        2
/dev/acd0                 /cdrom      cd9660      ro,noauto 0        0
....

Επανεκκινήστε το σύστημα:

[source,bash]
....
# shutdown -r now
....

Κατά την εκκίνηση του συστήματος, θα πρέπει πλέον να χρησιμοποιείται η συσκευή [.filename]#gm0# αντί για την [.filename]#da0#. Μετά το τέλος της εκκίνησης, μπορείτε να ελέγξετε ότι όλα λειτουργούν σωστά, εξετάζοντας την έξοδο της εντολής `mount`:

[source,bash]
....
# mount
Filesystem         1K-blocks    Used    Avail Capacity  Mounted on
/dev/mirror/gm0s1a   1012974  224604   707334    24%    /
devfs                      1       1        0   100%    /dev
/dev/mirror/gm0s1f  45970182   28596 42263972     0%    /home
/dev/mirror/gm0s1d   6090094 1348356  4254532    24%    /usr
/dev/mirror/gm0s1e   3045006 2241420   559986    80%    /var
devfs                      1       1        0   100%    /var/named/dev
....

Η έξοδος φαίνεται σωστή, όπως αναμενόταν. Τελικά, για να ξεκινήσει ο συγχρονισμός, εισάγετε και την συσκευή [.filename]#da1# στο mirror, χρησιμοποιώντας την ακόλουθη εντολή:

[source,bash]
....
# gmirror insert gm0 /dev/da1
....

Κατά τη διάρκεια του συγχρονισμού του mirror, μπορείτε να δείτε την πρόοδο της διαδικασίας με την παρακάτω εντολή:

[source,bash]
....
# gmirror status
....

Μετά το τέλος της δόμησης του mirror, και αφού έχουν συγχρονιστεί όλα τα δεδομένα, η έξοδος της παραπάνω εντολής θα μοιάζει με την ακόλουθη:

[source,bash]
....
      Name    Status  Components
mirror/gm0  COMPLETE  da0
                      da1
....

Αν υπάρχουν προβλήματα, ή αν το mirror βρίσκεται ακόμα στη διαδικασία συγχρονισμού, το παράδειγμα θα δείχνει `DEGRADED` αντί για `COMPLETE`.

=== Αντιμετώπιση Προβλημάτων

==== Το σύστημα αρνείται να ξεκινήσει

Αν το σύστημα σας σταματάει σε μια προτροπή που μοιάζει με την παρακάτω:

[.programlisting]
....
ffs_mountroot: can't find rootvp
Root mount failed: 6
mountroot>
....

Επανεκκινήστε το σύστημα σας μέσω του διακόπτη τροφοδοσίας ή του πλήκτρου reset. Στο μενού εκκίνησης, επιλέξτε το (6). Με τον τρόπο αυτό θα βρεθείτε στην προτροπή του man:loader[8]. Φορτώστε χειροκίνητα το άρθρωμα στον πυρήνα:

[source,bash]
....
OK? load geom_mirror
OK? boot
....

Αν το παραπάνω λειτουργήσει, τότε για κάποιο λόγο το άρθρωμα δεν φορτώθηκε σωστά. Ελέγξτε αν είναι σωστή η σχετική καταχώριση στο αρχείο [.filename]#/boot/loader.conf#. Αν το πρόβλημα παραμένει, προσθέστε τη γραμμή:

[.programlisting]
....
options	GEOM_MIRROR
....

στο αρχείο ρυθμίσεων του πυρήνα σας, αναδημιουργήστε και επανεγκαταστήστε τον πυρήνα σας. Το πρόβλημα σας θα πρέπει να διορθωθεί.

=== Επαναφορά Μετά από Αποτυχία Δίσκου

Το εκπληκτικό με το mirroring είναι ότι όταν ένας σκληρός δίσκος χαλάσει, μπορείτε να τον αντικαταστήσετε χωρίς να χάσετε καθόλου δεδομένα.

Υποθέτοντας ότι χρησιμοποιούμε τις ρυθμίσεις RAID1 που δείξαμε προηγουμένως, ας θεωρήσουμε ότι χάλασε ο δίσκος [.filename]#da1# και πρέπει να αντικατασταθεί. Για να τον αντικαταστήσετε, βρείτε ποιος δίσκος είναι και απενεργοποιήστε το σύστημα. Στο σημείο αυτό, μπορείτε πλέον να ανταλλάξετε το δίσκο με ένα νέο και να ενεργοποιήσετε ξανά το σύστημα. Μετά την επανενεργοποίηση του συστήματος, μπορείτε να χρησιμοποιήσετε τις παρακάτω εντολές για να θέσετε σε λειτουργία το νέο δίσκο:

[source,bash]
....
# gmirror forget gm0
....

[source,bash]
....
# gmirror insert gm0 /dev/da1
....

Χρησιμοποιήστε την εντολή `gmirror status` για να παρακολουθείτε τη διαδικασία του συγχρονισμού. Είναι στα αλήθεια τόσο απλό.

[[GEOM-raid3]]
== RAID3 - Striping σε Επίπεδο Byte με Αφοσιωμένο Parity

Το RAID3 είναι μια μέθοδος που συνδυάζει αρκετούς διαφορετικούς σκληρούς δίσκους σε ένα τόμο με ένα δίσκο αφοσιωμένο στην ισοτιμία (parity). Σε ένα σύστημα RAID3, τα δεδομένα χωρίζονται σε ένα αριθμό από bytes που εγγράφονται σε όλους τους δίσκους της συστοιχίας εκτός από ένα που χρησιμοποιείται αποκλειστικά ως δίσκος ισοτιμίας. Αυτό σημαίνει ότι για να διαβάσουμε 1024KB από μια υλοποίηση του RAID3 θα πρέπει να προσπελάσουμε όλους τους δίσκους της συστοιχίας. Η απόδοση αυξάνεται με τη χρήση χωριστών ελεγκτών σκληρών δίσκων. Η συστοιχία RAID3 προσφέρει ανοχή σε βλάβη ενός δίσκου ενός παρέχει χωρητικότητα 1 - 1/n φορές τη χωρητικότητα όλων των δίσκων της συστοιχίας, όπου n είναι το πλήθος των δίσκων που την απαρτίζουν. Αυτού του είδους οι συστοιχίες είναι κατάλληλες για αποθήκευση μεγάλων αρχείων, για παράδειγμα αρχείων πολυμέσων.

Χρειάζονται τουλάχιστον 3 φυσικοί σκληροί δίσκοι για τη δημιουργία μια συστοιχίας RAID3. Κάθε δίσκος θα πρέπει να είναι το ίδιο μέγεθος καθώς οι αιτήσεις Ι/Ο (εισόδου/εξόδου) εναλλάσσονται ώστε να γίνεται εγγραφή και ανάγνωση σε πολλαπλούς δίσκους παράλληλα. Επίσης, εξαιτίας της φύσης του RAID3, ο αριθμός των δίσκων πρέπει να είναι 3, 5, 9, 17 κλπ. (2^n+1).

=== Δημιουργία Συστοιχίας RAID3

Στο FreeBSD, η υποστήριξη για RAID3 υλοποιείται μέσω της κλάσης man:graid3[8] του GEOM. Η δημιουργία μιας συστοιχίας RAID3 στο FreeBSD απαιτεί τα παρακάτω βήματα.

[NOTE]
====
Αν και είναι θεωρητικά δυνατό να φτιάξετε μια εκκινήσιμη συστοιχία RAID3 στο FreeBSD, δεν συνίσταται καθώς πρόκειται για ασυνήθιστη λειτουργία.
====

[.procedure]
. Αρχικά, φορτώστε το [.filename]#geom_rai3.ko# άρθρωμα του πυρήνα μέσω της ακόλουθης εντολής:
+
[source,bash]
....
# graid3 load
....
+ 
Εναλλακτικά, είναι δυνατόν να φορτώσετε το άρθρωμα χειροκίνητα:
+
[source,bash]
....
# kldload geom_raid3.ko
....

. Εξασφαλίστε ότι υπάρχει κατάλληλο σημείο προσάρτησης, ή δημιουργήστε ένα καινούριο:
+
[source,bash]
....
# mkdir /multimedia
....

. Προσδιορίστε τα ονόματα συσκευών των δίσκων που θα προστεθούν στη συστοιχία και δημιουργήστε τη νέα συσκευή RAID3. Στο παράδειγμα μας χρησιμοποιούμε τρεις οδηγούς ATA οι οποίοι δεν περιέχουν κατατμήσεις: [.filename]#ada1# και [.filename]#ada2# για τα δεδομένα και [.filename]#ada3# για το parity.
+
[source,bash]
....
# graid3 label -v gr0 /dev/ada1 /dev/ada2 /dev/ada3
Metadata value stored on /dev/ada1
Metadata value stored on /dev/ada2
Metadata value stored on /dev/ada3
Done.
....

. Δημιουργήστε κατατμήσεις στη νέα συσκευή [.filename]#gr0# και διαμορφώστε την με σύστημα αρχείων UFS:
+
[source,bash]
....
# gpart create -s GPT /dev/raid3/gr0
# gpart add -t freebsd-ufs /dev/raid3/gr0
# newfs -j /dev/raid3/gr0p1
....
+ 
Θα δείτε μεγάλο πλήθος αριθμών να περνάει από την οθόνη σας και μετά από λίγο η διαδικασία θα ολοκληρωθεί. Ο τόμος έχει πλέον δημιουργηθεί και είναι έτοιμος να προσαρτηθεί.
. Το τελευταίο βήμα είναι η προσάρτηση του συστήματος αρχείων:
+
[source,bash]
....
# mount /dev/raid3/gr0p1 /multimedia
....
+ 
Η συστοιχία RAID3 είναι τώρα έτοιμη προς χρήση.

Θα χρειαστεί να κάνετε επιπλέον ρυθμίσεις ώστε η συστοιχία να είναι άμεσα διαθέσιμη μετά από κάθε εκκίνηση του υπολογιστή σας.

[.procedure]
. Το άρθρωμα [.filename]#geom_raid3.ko# θα πρέπει να φορτώνεται πριν την προσάρτηση της συστοιχίας. Για να φορτώνεται αυτόματα κατά την εκκίνηση του συστήματος, προσθέστε την παρακάτω γραμμή στο [.filename]#/boot/loader.conf#:
+
[.programlisting]
....
geom_raid3_load="YES"
....

. Θα πρέπει να προσθέσετε τις παρακάτω πληροφορίες σχετικά με τον τόμο στο αρχείο [.filename]#/etc/fstab# ώστε η προσάρτηση του συστήματος αρχείων της συστοιχίας να γίνεται αυτόματα κατά τη διαδικασία εκκίνησης του συστήματος:
+
[.programlisting]
....
/dev/raid3/gr0p1    /multimedia    ufs    rw    2    2
....

[[geom-ggate]]
== Δικτυακές Συσκευές μέσω GEOM Gate

Το GEOM υποστηρίζει απομακρυσμένη χρήση συσκευών, όπως οι σκληροί δίσκοι, τα CD-ROM, τα αρχεία κ.λ.π. χρησιμοποιώντας τα βοηθητικά προγράμματα πύλης (gate). Η λειτουργία είναι παρόμοια με το NFS.

Για να ξεκινήσετε, πρέπει να δημιουργήσετε ένα αρχείο exports. Το αρχείο αυτό καθορίζει ποιος επιτρέπεται να αποκτήσει πρόσβαση στους κοινόχρηστους πόρους και τι επιπέδου θα είναι αυτή η πρόσβαση. Για παράδειγμα, για να διαμοιράσετε την τέταρτη κατάτμηση (slice) του πρώτου δίσκου SCSI, είναι αρκετό να δημιουργήσετε το παρακάτω αρχείο [.filename]#/etc/gg.exports#:

[.programlisting]
....
192.168.1.0/24 RW /dev/da0s4d
....

Το παραπάνω θα επιτρέψει σε όλους τους υπολογιστές του ιδιωτικού σας δικτύου, να έχουν πρόσβαση μέσω δικτύου στο σύστημα αρχείων της κατάτμησης [.filename]#da0s4d#.

Για να διαμοιράσετε αυτή τη συσκευή, βεβαιωθείτε ότι δεν είναι προσαρτημένη τη δεδομένη στιγμή, και ξεκινήστε το δαίμονα εξυπηρετητή man:ggated[8]:

[source,bash]
....
# ggated
....

Για να προσαρτήσετε την συσκευή στο μηχάνημα πελάτη, χρησιμοποιήστε τις ακόλουθες εντολές:

[source,bash]
....
# ggatec create -o rw 192.168.1.1 /dev/da0s4d
ggate0
# mount /dev/ggate0 /mnt
....

Από εδώ και στο εξής, μπορείτε να έχετε πρόσβαση στη συσκευή μέσω του σημείου προσάρτησης [.filename]#/mnt#.

[NOTE]
====
Πρέπει να τονιστεί ότι η διαδικασία θα αποτύχει αν η συσκευή είναι τη δεδομένη στιγμή προσαρτημένη, είτε στον εξυπηρετητή, είτε σε οποιοδήποτε άλλο υπολογιστή στο δίκτυο.
====

Όταν δεν χρειάζεστε πλέον τη συσκευή, μπορείτε να την αποπροσαρτήσετε με ασφάλεια, χρησιμοποιώντας την εντολή man:umount[8], όπως γίνεται και με οποιαδήποτε άλλη συσκευή δίσκου.

[[geom-glabel]]
== Δημιουργώντας Ετικέτες (Labels) στις Συσκευές Δίσκων

Κατά τη διάρκεια της αρχικοποίησης, στην εκκίνηση του συστήματος, ο πυρήνας του FreeBSD θα δημιουργήσει τα απαραίτητα αρχεία για κάθε συσκευή που ανιχνεύει. Αυτή η μέθοδος ανίχνευσης συσκευών, μπορεί να δημιουργήσει προβλήματα. Για παράδειγμα, τι θα γίνει αν προσθέσουμε ένα νέο δίσκο USB; Είναι αρκετά πιθανό μια συσκευή μνήμης flash να πάρει το όνομα [.filename]#da0# και η αρχική [.filename]#da0# να μετακινηθεί στο [.filename]#da1#. Αυτό θα προκαλέσει προβλήματα στην προσάρτηση των συστημάτων αρχείων, αν υπάρχουν οι αντίστοιχες καταχωρίσεις τους στο [.filename]#/etc/fstab#, και μπορεί ακόμα και να παρεμποδίσει την κανονική εκκίνηση του συστήματος.

Μια λύση είναι να ρυθμίσετε τις συσκευές SCSI με τέτοιο τρόπο, ώστε η αρίθμηση τους να είναι συνεχόμενη. Έτσι, κάθε φορά που προσθέτετε μια νέα συσκευή στον ελεγκτή SCSI θα είστε σίγουρος ότι θα λάβει αριθμό που δεν έχει χρησιμοποιηθεί. Αλλά τι γίνεται με τις συσκευές USB που μπορεί να αντικαταστήσουν τον κύριο SCSI δίσκο; Αυτό μπορεί πράγματι να συμβεί, καθώς οι συσκευές USB ανιχνεύονται κατά βάση πριν από τον ελεγκτή SCSI. Μια λύση είναι να βάζετε τις συσκευές αυτές μόνο μετά την εκκίνηση του συστήματος. Μια άλλη μέθοδος είναι να χρησιμοποιείτε μόνο μια συσκευή τύπου ATA και να μην καταχωρείτε ποτέ τους δίσκους SCSI στο [.filename]#/etc/fstab#.

Υπάρχει ωστόσο καλύτερη λύση. Χρησιμοποιώντας το βοηθητικό πρόγραμμα `glabel`, ένας διαχειριστής ή χρήστης, μπορεί να αποδώσει ετικέτες στις συσκευές δίσκων και να τις χρησιμοποιήσει στο [.filename]#/etc/fstab#, αντί για τα συμβατικά ονόματα συσκευών. Επειδή η `glabel` αποθηκεύει την ετικέτα στον τελευταίο τομέα του κάθε παροχέα (συσκευής δίσκου), η ετικέτα διατηρείται και μετά από την επανεκκίνηση του συστήματος. Χρησιμοποιώντας αυτή την ετικέτα ως όνομα συσκευής, θα μπορείτε να προσαρτήσετε πάντα το σύστημα αρχείων, άσχετα με το πραγματικό όνομα συσκευής που έχει αποδοθεί στο δίσκο.

[NOTE]
====
Δεν χρειάζεται φυσικά να τονίσουμε ότι αυτή η ετικέτα θα πρέπει να είναι μόνιμη. Το βοηθητικό πρόγραμμα `glabel` μπορεί να δημιουργήσει τόσο μόνιμες όσο και προσωρινές ετικέτες. Μόνο οι μόνιμες ετικέτες διατηρούνται ανέπαφες μετά από μια επανεκκίνηση. Δείτε τη σελίδα manual της man:glabel[8] για περισσότερες πληροφορίες σχετικά με τα είδη των ετικετών.
====

=== Είδη Ετικετών και Παραδείγματα

Υπάρχουν δύο τύποι ετικετών, η γενική ετικέτα και η ετικέτα συστήματος αρχείων. Οι ετικέτες μπορεί να είναι προσωρινές ή μόνιμες. Οι μόνιμες ετικέτες μπορούν να δημιουργηθούν με τις εντολές man:tunefs[8] ή man:newfs[8]. Στην περίπτωση αυτή, θα δημιουργηθούν σε ένα υποκατάλογο του [.filename]#/dev#. Για παράδειγμα, οι ετικέτες συσκευών με σύστημα αρχείων UFS2, θα δημιουργηθούν στον κατάλογο [.filename]#/dev/ufs#. Μόνιμες ετικέτες μπορούν επίσης να δημιουργηθούν με χρήση της εντολής `glabel label`. Οι ετικέτες αυτές δεν εξαρτώνται από το σύστημα αρχείων, και δημιουργούνται στον κατάλογο [.filename]#/dev/label#.

Οι ετικέτες προσωρινού τύπου, χάνονται σε κάθε επανεκκίνηση του συστήματος. Οι ετικέτες αυτές δημιουργούνται στον κατάλογο [.filename]#/dev/label# και είναι τέλειες για πειραματισμούς. Μπορείτε να δημιουργήσετε προσωρινές ετικέτες με την εντολή `glabel create`. Για περισσότερες πληροφορίες, διαβάστε τη σελίδα manual της man:glabel[8].

Για να δημιουργήσετε μια μόνιμη ετικέτα για ένα σύστημα αρχείων UFS2, χωρίς να καταστρέψετε τα δεδομένα που περιέχει, χρησιμοποιήστε την ακόλουθη εντολή:

[source,bash]
....
# tunefs -L home /dev/da3
....

[WARNING]
====

Αν το σύστημα αρχείων είναι γεμάτο, η παραπάνω εντολή μπορεί να προκαλέσει καταστροφή δεδομένων. Ωστόσο, αν το σύστημα αρχείων είναι γεμάτο, στόχος σας θα πρέπει να είναι να διαγράψετε τα αρχεία που δεν χρησιμοποιούνται, και όχι να προσθέτετε ετικέτες.
====

Θα πρέπει τώρα να υπάρχει μια ετικέτα στον κατάλογο [.filename]#/dev/ufs# η οποία μπορεί να προστεθεί στο [.filename]#/etc/fstab#:

[.programlisting]
....
/dev/ufs/home		/home            ufs     rw              2      2
....

[NOTE]
====
Το σύστημα αρχείων δεν πρέπει να είναι προσαρτημένο καθώς εκτελείτε την εντολή `tunefs`.
====

Μπορείτε τώρα να προσαρτήσετε το σύστημα αρχείων με το συνήθη τρόπο:

[source,bash]
....
# mount /home
....

Από εδώ και πέρα, και όσο το άρθρωμα [.filename]#geom_label.ko# φορτώνεται στον πυρήνα μέσω του [.filename]#/boot/loader.conf# ή εφόσον έχετε βάλει την επιλογή `GEOM_LABEL` στον πυρήνα σας, ακόμα και αν το όνομα της συσκευής αλλάξει, δεν θα έχει καμιά δυσμενή επίδραση στο σύστημα σας.

Μπορείτε επίσης να δημιουργήσετε συστήματα αρχείων με προεπιλεγμένη ετικέτα, χρησιμοποιώντας την επιλογή `-L` στην εντολή `newfs`. Δείτε την σελίδα manual του man:newfs[8] για περισσότερες πληροφορίες.

Μπορείτε να χρησιμοποιήσετε την παρακάτω εντολή για να καταστρέψετε μια ετικέτα:

[source,bash]
....
# glabel destroy home
....

Το επόμενο παράδειγμα δείχνει πως μπορούν να δοθούν ετικέτες στις κατατμήσεις του δίσκου εκκίνησης.

.Δημιουργία Ετικετών στις Κατατμήσεις του Δίσκου Εκκίνησης
[example]
====
Δημιουργώντας μόνιμες ετικέτες στις κατατμήσεις του δίσκου εκκίνησης, το σύστημα σας θα συνεχίσει να εκκινεί κανονικά ακόμα και αν μεταφέρετε το δίσκο σε άλλο ελεγκτή ή ακόμα και σε διαφορετικό σύστημα. Στο παράδειγμα μας, θεωρούμε ότι χρησιμοποιείται ένας δίσκος ATA, ο οποίος αναγνωρίζεται από το σύστημα ως [.filename]#ad0#. Θεωρούμε επίσης ότι χρησιμοποιείται η συνηθισμένη διάταξη κατατμήσεων του FreeBSD, που περιλαμβάνει τις κατατμήσεις [.filename]#/#, [.filename]#/var#, [.filename]#/usr# και [.filename]#/tmp# όπως επίσης και μια κατάτμηση swap.

Επανεκκινήστε το σύστημα, και όταν εμφανιστεί η προτροπή του man:loader[8], πιέστε το kbd:[4] για να πραγματοποιηθεί εκκίνηση σε κατάσταση ενός χρήστη. Έπειτα, δώστε τις ακόλουθες εντολές:

[source,bash]
....
# glabel label rootfs /dev/ad0s1a
GEOM_LABEL: Label for provider /dev/ad0s1a is label/rootfs
# glabel label var /dev/ad0s1d
GEOM_LABEL: Label for provider /dev/ad0s1d is label/var
# glabel label usr /dev/ad0s1f
GEOM_LABEL: Label for provider /dev/ad0s1f is label/usr
# glabel label tmp /dev/ad0s1e
GEOM_LABEL: Label for provider /dev/ad0s1e is label/tmp
# glabel label swap /dev/ad0s1b
GEOM_LABEL: Label for provider /dev/ad0s1b is label/swap
# exit
....

Η εκκίνηση θα συνεχιστεί κανονικά και το σύστημα θα έλθει σε κατάσταση πολλαπλών χρηστών (multi-user). Μετά το τέλος της εκκίνησης, επεξεργαστείτε το αρχείο [.filename]#/etc/fstab# και αλλάξτε τα συμβατικά ονόματα συσκευών με τις αντίστοιχες ετικέτες. Το τελικό αρχείο [.filename]#/etc/fstab# θα μοιάζει με το παρακάτω:

[.programlisting]
....
# Device                Mountpoint      FStype  Options         Dump    Pass#
/dev/label/swap         none            swap    sw              0       0
/dev/label/rootfs       /               ufs     rw              1       1
/dev/label/tmp          /tmp            ufs     rw              2       2
/dev/label/usr          /usr            ufs     rw              2       2
/dev/label/var          /var            ufs     rw              2       2
....

Μπορείτε τώρα να επανεκκινήσετε το σύστημα. Αν όλα πήγαν καλά, η εκκίνηση θα είναι κανονική, και η εντολή `mount` θα δείξει:

[source,bash]
....
# mount
/dev/label/rootfs on / (ufs, local)
devfs on /dev (devfs, local)
/dev/label/tmp on /tmp (ufs, local, soft-updates)
/dev/label/usr on /usr (ufs, local, soft-updates)
/dev/label/var on /var (ufs, local, soft-updates)
....

====

Ξεκινώντας από το FreeBSD 7.2, το man:glabel[8] υποστηρίζει ένα νέο είδος ετικέτας για συστήματα αρχείων UFS, που βασίζεται σε ένα μοναδιαίο αναγνωριστικό τους, το `ufsid`. Οι ετικέτες αυτές βρίσκονται στον κατάλογο [.filename]#/dev/ufsid#, δημιουργούνται αυτόματα κατά την εκκίνηση του συστήματος και είναι δυνατόν να χρησιμοποιηθούν για την προσάρτηση κατατμήσεων μέσω του [.filename]#/etc/fstab#. Μπορείτε να χρησιμοποιήσετε την εντολή `glabel status` για να λάβετε μια λίστα των συστημάτων αρχείων με τις αντίστοιχες `ufsid` ετικέτες τους:

[source,bash]
....
% glabel status
                  Name  Status  Components
ufsid/486b6fc38d330916     N/A  ad4s1d
ufsid/486b6fc16926168e     N/A  ad4s1f
....

Στο παραπάνω παράδειγμα, το [.filename]#ad4s1d# αντιπροσωπεύει το σύστημα αρχείων [.filename]#/var#, ενώ το [.filename]#ad4s1f# αντιπροσωπεύει το σύστημα αρχείων [.filename]#/usr#. Χρησιμοποιώντας τις τιμές `ufsid` που φαίνονται, η προσάρτηση αυτών των κατατμήσεων μπορεί να γίνει με τις παρακάτω καταχωρίσεις στο [.filename]#/etc/fstab#:

[.programlisting]
....
/dev/ufsid/486b6fc38d330916        /var        ufs        rw        2      2
/dev/ufsid/486b6fc16926168e        /usr        ufs        rw        2      2
....

Οποιαδήποτε κατάτμηση διαθέτει αναγνωριστικό `ufsid` μπορεί να προσαρτηθεί με τον ίδιο τρόπο, χωρίς να υπάρχει πλέον ανάγκη να δημιουργηθεί μόνιμη ετικέτα χειροκίνητα. Η προσάρτηση μέσω ετικέτας `ufsid`, παρέχει το πλεονέκτημα της ανεξαρτησίας από το όνομα συσκευής, το οποίο παρέχουν και οι μόνιμες ετικέτες.

[[geom-gjournal]]
== UFS Journaling Μέσω GEOM

Στην έκδοση 7.0 του FreeBSD υλοποιείται για πρώτη φορά η νέα (και από πολλούς αναμενόμενη) δυνατότητα για χρήση ημερολογίου (journal) στο σύστημα αρχείων. Η υλοποίηση παρέχεται μέσω του υποσυστήματος GEOM και μπορεί να ρυθμιστεί εύκολα μέσω του βοηθητικού προγράμματος man:gjournal[8].

Τι είναι το journaling; Το journaling αποθηκεύει σε ένα αρχείο καταγραφής (log, ημερολόγιο, ή απλώς journal) τις συναλλαγές του συστήματος αρχείων. Παράδειγμα συναλλαγής είναι οι αλλαγές που απαιτούνται για μια πλήρη διαδικασία εγγραφής στο δίσκο. Έτσι, στο log αποθηκεύονται οι αλλαγές στα μετα-δεδομένα (meta-data) και στα ίδια τα αρχεία, πριν γίνει η τελική (κανονική) αποθήκευση τους στο δίσκο. Το αρχείο καταγραφής μπορεί αργότερα να ξαναχρησιμοποιηθεί ώστε η συναλλαγή να γίνει από την αρχή, εξασφαλίζοντας με αυτό τον τρόπο ότι το σύστημα αρχείων θα παραμείνει σε σταθερή κατάσταση.

Πρόκειται ουσιαστικά για μια ακόμα μέθοδο προφύλαξης από απώλεια δεδομένων και ασυνέπειες στο σύστημα αρχείων. Σε αντίθεση με τα Soft Updates τα οποία εντοπίζουν και υποχρεώνουν την άμεση εγγραφή των μετα-δεδομένων, και των στιγμιοτύπων (Snapshots) τα οποία είναι εικόνες του συστήματος αρχείων σε μια δεδομένη στιγμή, το log αποθηκεύεται σε χώρο που έχει εκχωρηθεί ειδικά για αυτό το σκοπό, και σε μερικές περιπτώσεις μπορεί να αποθηκεύεται σε εντελώς διαφορετικό δίσκο.

Σε αντίθεση με υλοποιήσεις journaling σε άλλα συστήματα αρχείων, η μέθοδος `gjournal` βασίζεται σε blocks, και δεν υλοποιείται ως μέρος του συστήματος αρχείων, αλλά μόνο ως επέκταση του GEOM.

Για ενεργοποίηση της υποστήριξης `gjournal`, θα πρέπει να υπάρχει η παρακάτω επιλογή στον πυρήνα του FreeBSD. Η επιλογή αυτή υπάρχει από προεπιλογή στην έκδοση 7.0 και όλες τις νεότερες εκδόσεις του FreeBSD.

[.programlisting]
....
options	UFS_GJOURNAL
....

Αν χρειάζεται να προσαρτώνται τόμοι με journaling κατά την εκκίνηση, θα πρέπει επίσης να φορτώνεται αυτόματα και το άρθρωμα πυρήνα [.filename]#geom_journal.ko#. Για το σκοπό αυτό, προσθέστε την παρακάτω γραμμή στο αρχείο [.filename]#/boot/loader.conf#:

[.programlisting]
....
geom_journal_load="YES"
....

Εναλλακτικά, η λειτουργία αυτή μπορεί να ενσωματωθεί σε ένα προσαρμοσμένο πυρήνα, με την προσθήκη της παρακάτω γραμμής στο αντίστοιχο αρχείο ρυθμίσεων:

[.programlisting]
....
options	GEOM_JOURNAL
....

Η δημιουργία journal σε ένα ελεύθερο σύστημα αρχείων, μπορεί τώρα να γίνει με τα ακόλουθα βήματα, θεωρώντας ότι η συσκευή [.filename]#da4# είναι ένας νέος δίσκος SCSI:

[source,bash]
....
# gjournal load
# gjournal label /dev/da4
....

Στο σημείο αυτό θα υπάρχει μια συσκευή [.filename]#/dev/da4# καθώς και μια συσκευή [.filename]#/dev/da4.journal#. Στη συσκευή αυτή μπορείτε τώρα να δημιουργήσετε σύστημα αρχείων:

[source,bash]
....
# newfs -O 2 -J /dev/da4.journal
....

Η παραπάνω εντολή θα δημιουργήσει ένα σύστημα αρχείων UFS2 στη συσκευή [.filename]#/dev/da4.journal#, η οποία έχει ήδη υποστήριξη για journaling.

Μπορείτε να χρησιμοποιήσετε την εντολή `mount` για να προσαρτήσετε την συσκευή στο επιθυμητό σημείο προσάρτησης, όπως φαίνεται παρακάτω:

[source,bash]
....
# mount /dev/da4.journal /mnt
....

[NOTE]
====
Στην περίπτωση αρκετών slice, θα δημιουργηθεί ένα journal για κάθε επιμέρους slice. Για παράδειγμα, αν υπάρχουν τα slices [.filename]#ad4s1# και [.filename]#ad4s2# τότε το `gjournal` θα δημιουργήσει τις συσκευές [.filename]#ad4s1.journal# και [.filename]#ad4s2.journal#.
====

Για καλύτερη απόδοση, ίσως είναι επιθυμητή η τήρηση του journal σε διαφορετικό δίσκο. Για τις περιπτώσεις αυτές, ο παροχέας ημερολογίου (η συσκευή δίσκου που θα περιέχει το journal) πρέπει να δίνεται ως παράμετρος στην εντολή, αμέσως μετά τη συσκευή δίσκου στην οποία θα ενεργοποιηθεί το journaling. Μπορείτε επίσης να ενεργοποιήσετε το journaling σε υπάρχοντα συστήματα αρχείων χρησιμοποιώντας την εντολή `tunefs`. Ωστόσο, θα πρέπει να κρατήσετε αντίγραφο ασφαλείας των αρχείων σας, πριν επιχειρήσετε να κάνετε αλλαγές σε ένα υπάρχον σύστημα αρχείων. Στις περισσότερες περιπτώσεις, η `tunefs` θα αποτύχει αν δεν μπορέσει να δημιουργήσει το journal, αλλά αυτό δεν σας προστατεύει από απώλεια δεδομένων που μπορεί να προέλθει από κακή χρήση της `tunefs`.

Είναι επίσης δυνατόν να χρησιμοποιηθεί journaling στον δίσκο εκκίνησης ενός συστήματος FreeBSD. Διαβάστε το άρθρο link:{gjournal-desktop}[Υλοποίηση του UFS Journaling σε ένα Desktop Υπολογιστή] για λεπτομερείς οδηγίες.
