---
title: Κεφάλαιο 24. Ενημέρωση και Αναβάθμιση του FreeBSD
part: Μέρος III. Διαχείριση Συστήματος
prev: books/handbook/l10n
next: books/handbook/dtrace
---

[[updating-upgrading]]
= Ενημέρωση και Αναβάθμιση του FreeBSD
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:source-highlighter: rouge
:experimental:
:skip-front-matter:
:toc-title: Πίνακας Περιεχομένων
:table-caption: Πίνακας
:figure-caption: Σχήμα
:example-caption: Παράδειγμα
:xrefstyle: basic
:relfileprefix: ../
:outfilesuffix:
:sectnumoffset: 24

ifeval::["{backend}" == "html5"]
:imagesdir: ../../../images/books/handbook/cutting-edge/
endif::[]

ifeval::["{backend}" == "pdf"]
:imagesdir: ../../../../static/images/books/handbook/cutting-edge/
endif::[]

ifeval::["{backend}" == "epub3"]
:imagesdir: ../../../../static/images/books/handbook/cutting-edge/
endif::[]

include::shared/authors.adoc[]
include::shared/releases.adoc[]
include::shared/el/mailing-lists.adoc[]
include::shared/el/teams.adoc[]
include::shared/el/urls.adoc[]

toc::[]

[[updating-upgrading-synopsis]]
== Σύνοψη

Το FreeBSD βρίσκεται υπό συνεχή εξέλιξη μεταξύ των επίσημων εκδόσεων του. Μερικοί άνθρωποι προτιμούν να χρησιμοποιούν τις επίσημες εκδόσεις, ενώ άλλοι προτιμούν να κρατούν το σύστημα τους ενημερωμένο με τις τελευταίες εξελίξεις. Ωστόσο, ακόμα και οι επίσημες εκδόσεις ενημερώνονται συχνά με διορθώσεις κρίσιμων σφαλμάτων και ασφαλείας. Όποια έκδοση και να χρησιμοποιήσετε, το FreeBSD παρέχει όλα τα απαραίτητα εργαλεία για να κρατήσετε το σύστημα σας ενημερωμένο, και επίσης σας επιτρέπει να αναβαθμιστείτε εύκολα σε κάποια επόμενη έκδοση. Το κεφάλαιο αυτό θα σας βοηθήσει να αποφασίσετε αν θέλετε να παρακολουθείτε το σύστημα ανάπτυξης, ή αν θα προτιμήσετε να παραμείνετε σε μια από τις παγιωμένες εκδόσεις. Θα παρουσιάσουμε επίσης τα βασικά εργαλεία που απαιτούνται για την ενημέρωση και αναβάθμιση του συστήματος.

Αφού διαβάσετε αυτό το κεφάλαιο, θα ξέρετε:

* Ποια βοηθητικά προγράμματα μπορείτε να χρησιμοποιήσετε για να ενημερώσετε το σύστημα και την Συλλογή των Ports.
* Πως να διατηρείτε το σύστημα σας ενημερωμένο με τα προγράμματα freebsd-updateCVSup, CVS, ή CTM.
* Πως να συγκρίνετε την κατάσταση ενός εγκατεστημένου συστήματος, με αναφορά ένα γνωστό και εγγυημένα σωστό σύστημα.
* Πως να διατηρήσετε την τεκμηρίωση σας ενημερωμένη μέσω του CVSup ή των ports της τεκμηρίωσης .
* Τη διαφορά μεταξύ των δύο κλάδων που βρίσκονται σε εξέλιξη: του FreeBSD-STABLE και του FreeBSD-CURRENT.
* Πως να ξαναφτιάξετε και να επανεγκαταστήσετε ολόκληρο το βασικό σύστημα με την `make buildworld` (κλπ).

Πριν διαβάσετε αυτό το κεφάλαιο, θα πρέπει:

* Να ρυθμίσετε σωστά τη σύνδεση σας στο δίκτυο (crossref:advanced-networking[advanced-networking,Προχωρημένα Θέματα Δικτύωσης]).
* Να γνωρίζετε πως να εγκαταστήσετε πρόσθετο λογισμικό τρίτου κατασκευαστή (crossref:ports[ports,Εγκατάσταση Εφαρμογών: Πακέτα και Ports]).

[NOTE]
====
Στο κεφάλαιο αυτό γίνεται συχνά χρήση της εντολής `cvsup` για την ανάκτηση ή ενημέρωση των αρχείων πηγαίου κώδικα του FreeBSD. Για να την χρησιμοποιήσετε, θα πρέπει να εγκαταστήσετε ένα πακέτο ή port όπως το package:net/cvsup[] (αν δεν θέλετε να εγκαταστήσετε γραφικό πρόγραμμα `cvsup`, μπορείτε να εγκαταστήσετε το port package:net/cvsup-without-gui[]). Μπορείτε να αντικαταστήσετε αυτή την εντολή με την man:csup[1] η οποία ανήκει στο βασικό σύστημα.
====

[[updating-upgrading-freebsdupdate]]
== Ενημερώνοντας το FreeBSD

Η εφαρμογή ενημερώσεων ασφαλείας αποτελεί ένα σημαντικό τμήμα της συντήρησης λογισμικού, ειδικά όταν πρόκειται για το λειτουργικό σύστημα. Για μεγάλο διάστημα, η διαδικασία αυτή δεν ήταν εύκολη στο FreeBSD. Έπρεπε να εφαρμοστούν patches στον πηγαίο κώδικα, να γίνει μεταγλώττιση του από την αρχή, και να εγκατασταθούν ξανά τα νέα εκτελέσιμα.

Αυτό δεν είναι πλέον αναγκαίο, καθώς το FreeBSD διαθέτει τώρα ένα βοηθητικό πρόγραμμα, το `freebsd-update`. Το πρόγραμμα παρέχει δύο διαφορετικές λειτουργίες. Η πρώτη είναι η δυνατότητα δυαδικής (binary) ενημέρωσης του βασικού συστήματος με τις τελευταίες διορθώσεις ασφάλειας και λαθών, χωρίς να χρειάζεται ξανά μεταγλώττιση και εγκατάσταση. Η δεύτερη είναι η δυνατότητα αναβάθμισης του συστήματος σε μια νέα μικρή ή μεγάλη επίσημη έκδοση (release).

[NOTE]
====
Δυαδικές διορθώσεις λαθών και ασφάλειας, διατίθενται για όλες τις αρχιτεκτονικές και εκδόσεις που υποστηρίζονται από την ομάδα ασφάλειας. Πριν προχωρήσετε στην αναβάθμιση σε μια νέα έκδοση, θα πρέπει να διαβάσετε τις σχετικές με αυτήν ανακοινώσεις, καθώς μπορεί να περιέχουν σημαντικές πληροφορίες. Μπορείτε να δείτε τις ανακοινώσεις εκδόσεων στην παρακάτω τοποθεσία: http://www.FreeBSD.org/releases/[http://www.FreeBSD.org/releases/].
====

Αν υπάρχει κάποιο `crontab` που χρησιμοποιεί τις δυνατότητες του `freebsd-update`, θα πρέπει να απενεργοποιηθεί πριν ξεκινήσει η παρακάτω διαδικασία. Μπορείτε να εγκαταστήσετε την τελευταία έκδοση του `freebsd-update` κατεβάζοντας το συμπιεσμένο πακέτο από το παραπάνω URL και εκτελώντας τις παρακάτω εντολές:

[source,bash]
....
# gunzip -c freebsd-update-upgrade.tgz | tar xvf -
# mv freebsd-update.sh /usr/sbin/freebsd-update
# mv freebsd-update.conf /etc
....

Δεν απαιτείται να κατεβάσετε την τελευταία έκδοση, αν χρησιμοποιείτε κάποια από τις τρέχουσες εκδόσεις του FreeBSD.

[[freebsdupdate-config-file]]
=== Το Αρχείο Ρυθμίσεων

Κάποιοι χρήστες ίσως θέλουν να αλλάξουν το προεπιλεγμένο αρχείο ρυθμίσεων [.filename]#/etc/freebsd-update.conf#, ώστε να έχουν καλύτερο έλεγχο της διαδικασίας. Οι επιλογές είναι γενικά αρκετά καλά τεκμηριωμένες, αλλά οι παρακάτω ίσως να χρειάζονται κάποιες επιπλέον επεξηγήσεις:

[.programlisting]
....
# Components of the base system which should be kept updated.
Components src world kernel
....

Αυτή η παράμετρος ελέγχει ποια τμήματα του FreeBSD θα διατηρούνται ενημερωμένα. Η προεπιλογή είναι να ενημερώνεται ο πηγαίος κώδικας, όλο το βασικό σύστημα, και ο πυρήνας. Τα τμήματα είναι τα ίδια που διατίθενται και κατά την εγκατάσταση, για παράδειγμα αν βάλετε την επιλογή `world/games` θα εγκαθίστανται ενημερώσεις για τα παιχνίδια. Αν βάλετε `src/bin` θα επιτρέψετε την ενημέρωση του πηγαίου κώδικα του καταλόγου [.filename]#src/bin#.

Η καλύτερη επιλογή είναι να αφήσετε εδώ την προεπιλεγμένη τιμή, καθώς αν την αλλάξετε ώστε να περιέχει συγκεκριμένα μόνο τμήματα, θα αναγκαστείτε να αναφέρετε χωριστά μέσα στο αρχείο ρυθμίσεων κάθε τμήμα που θέλετε να ενημερώνεται. Αυτό ίσως έχει καταστροφικά αποτελέσματα, καθώς είναι πιθανό ο πηγαίος κώδικας και τα εκτελέσιμα προγράμματα να μην είναι πλέον σε συγχρονισμό μεταξύ τους.

[.programlisting]
....
# Paths which start with anything matching an entry in an IgnorePaths
# statement will be ignored.
IgnorePaths
....

Προσθέστε διαδρομές σε καταλόγους, όπως [.filename]#/bin# ή [.filename]#/sbin# για να αφήσετε απείραχτους τους συγκεκριμένους καταλόγους κατά την διαδικασία ενημέρωσης. Η επιλογή αυτή μπορεί να χρησιμοποιηθεί για να αποτρέψει το `freebsd-update` να γράψει πάνω σε πιθανόν δικές σας τοπικές αλλαγές.

[.programlisting]
....
# Paths which start with anything matching an entry in an UpdateIfUnmodified
# statement will only be updated if the contents of the file have not been
# modified by the user (unless changes are merged; see below).
UpdateIfUnmodified /etc/ /var/ /root/ /.cshrc /.profile
....

Η επιλογή αυτή θα ενημερώσει τα αρχεία ρυθμίσεων στους καταλόγους που καθορίζονται, μόνο αν αυτά δεν έχουν μεταβληθεί από το χρήστη. Αν υπάρχουν τοπικές αλλαγές, δεν θα γίνει ενημέρωση. Υπάρχει μια ακόμα επιλογή, η `KeepModifiedMetadata`, η οποία οδηγεί το `freebsd-update` να αποθηκεύσει τις αλλαγές μεταξύ των δύο εκδόσεων κατά τη διάρκεια της συγχώνευσης (merge).

[.programlisting]
....
# When upgrading to a new FreeBSD release, files which match MergeChanges
# will have any local changes merged into the version from the new release.
MergeChanges /etc/ /var/named/etc/
....

Πρόκειται για τη λίστα των καταλόγων που περιέχουν αρχεία ρυθμίσεων, και στα οποία το `freebsd-update` θα επιχειρεί την διαδικασία συγχώνευσης αλλαγών. Η διαδικασία συγχώνευσης γίνεται με μια σειρά από patches τύπου man:diff[1] παρόμοια με το man:mergemaster[8] αλλά με λιγότερες επιλογές. Οι συγχωνεύσεις είτε γίνονται δεκτές, είτε προκαλούν το άνοιγμα κάποιου συντάκτη κειμένου, διαφορετικά η εκτέλεση του `freebsd-update` ακυρώνεται. Αν δεν είστε σίγουρος, κρατήστε αντίγραφο ασφαλείας του καταλόγου [.filename]#/etc# και απλώς δεχθείτε τις αλλαγές. Δείτε το <<mergemaster>> για περισσότερες πληροφορίες σχετικά με την εντολή `mergemaster`.

[.programlisting]
....
# Directory in which to store downloaded updates and temporary
# files used by FreeBSD Update.
# WorkDir /var/db/freebsd-update
....

Στον κατάλογο αυτό φυλάσσονται όλα τα patches και τα προσωρινά αρχεία. Σε περιπτώσεις όπου ο χρήστης εκτελεί αναβάθμιση σε μια νεότερη έκδοση του FreeBSD, θα πρέπει να διαθέτει τουλάχιστον ένα gigabyte ελεύθερου χώρου.

[.programlisting]
....
# When upgrading between releases, should the list of Components be
# read strictly (StrictComponents yes) or merely as a list of components
# which *might* be installed of which FreeBSD Update should figure out
# which actually are installed and upgrade those (StrictComponents no)?
# StrictComponents no
....

Αν θέσετε την παραπάνω επιλογή στο `yes`, το `freebsd-update` θα υποθέσει ότι η λίστα `Components` είναι πλήρης και δεν θα επιχειρήσει να προχωρήσει σε αλλαγές εκτός λίστας. Ουσιαστικά, το `freebsd-update` θα προσπαθήσει να ενημερώσει κάθε αρχείο που ανήκει στη λίστα `Components`.

[[freebsdupdate-security-patches]]
=== Patches Σχετικά με την Ασφάλεια

Τα patches που σχετίζονται με την ασφάλεια, αποθηκεύονται σε ένα απομακρυσμένο μηχάνημα και μπορούν να μεταφορτωθούν και να εγκατασταθούν με την ακόλουθη εντολή:

[source,bash]
....
# freebsd-update fetch
# freebsd-update install
....

Αν με την παραπάνω εντολή εγκατασταθούν ενημερώσεις στον πυρήνα, θα χρειαστεί να επανεκκινήσετε το σύστημα. Αν όλα πάνε καλά, το σύστημα θα είναι πλέον ενημερωμένο και μπορείτε να εκτελείτε το `freebsd-update` αυτόματα με την βοήθεια του man:cron[8]. Μια απλή καταχώριση στο αρχείο [.filename]#/etc/crontab# είναι επαρκής για αυτό το σκοπό:

[.programlisting]
....
@daily                                  root    freebsd-update cron
....

Η παραπάνω καταχώριση ορίζει ότι το `freebsd-update` θα εκτελείται μια φορά την ημέρα. Με τον τρόπο αυτό, και όταν η εκτέλεση είναι μέσω της επιλογής `cron`, το `freebsd-update` απλώς θα ελέγχει για ενημερώσεις. Αν υπάρχουν, η εφαρμογή θα τις κατεβάζει, αλλά δεν θα τις εγκαθιστά. Θα στέλνει όμως ένα email στο χρήστη `root` ώστε να τις εγκαταστήσει χειροκίνητα.

Αν οτιδήποτε πάει στραβά, το `freebsd-update` έχει την ικανότητα να επιστρέφει στην προηγούμενη σταθερή κατάσταση, αναιρώντας το τελευταίο σετ αλλαγών με την ακόλουθη εντολή:

[source,bash]
....
# freebsd-update rollback
....

Με την ολοκλήρωση της εντολής, θα πρέπει να επανεκκινήσετε το σύστημα αν έχουν γίνει αλλαγές στον πυρήνα ή σε κάποιο από τα αρθρώματα του. Αυτό θα επιτρέψει στο FreeBSD να φορτώσει τα νέα εκτελέσιμα στη μνήμη.

Το βοηθητικό πρόγραμμα `freebsd-update` μπορεί να ενημερώσει αυτόματα μόνο τον πυρήνα [.filename]#GENERIC#. Αν χρησιμοποιείται προσαρμοσμένος πυρήνας, θα πρέπει να μεταγλωττιστεί ξανά, όταν το `freebsd-update` τελειώσει με την εγκατάσταση των υπόλοιπων ενημερώσεων. Ωστόσο, το `freebsd-update` θα ανιχνεύσει και θα ενημερώσει τον πυρήνα [.filename]#GENERIC# στο [.filename]#/boot/GENERIC# (αν υπάρχει), ακόμα και αν δεν είναι ο ενεργός πυρήνας του συστήματος (αυτός που εκτελείται τη συγκεκριμένη στιγμή).

[NOTE]
====
Είναι γενικά καλή ιδέα να έχετε πάντα ένα αντίγραφο του πυρήνα [.filename]#GENERIC# στον κατάλογο [.filename]#/boot/GENERIC#. Θα σας βοηθήσει στην διάγνωση διάφορων προβλημάτων, καθώς και στην αναβάθμιση σε επόμενες εκδόσεις του FreeBSD, μέσω του `freebsd-update`. Η διαδικασία αυτή περιγράφεται στο <<freebsdupdate-upgrade>>.
====

Αν δεν έχουν γίνει αλλαγές στις προεπιλεγμένες ρυθμίσεις στο αρχείο [.filename]#/etc/freebsd-update.conf#, το `freebsd-update` θα εγκαταστήσει τα ανανεωμένα αρχεία πηγαίου κώδικα μαζί με τις υπόλοιπες ενημερώσεις. Μπορείτε έπειτα να προχωρήσετε στη μεταγλώττιση και εγκατάσταση νέου προσαρμοσμένου πυρήνα, με το συνήθη τρόπο.

[NOTE]
====
Οι ενημερώσεις που διανέμονται μέσω του `freebsd-update` δεν περιλαμβάνουν πάντοτε αλλαγές στον πυρήνα. Δεν είναι απαραίτητο να επαναμεταγλωττίσετε τον προσαρμοσμένο πυρήνα σας, αν η εκτέλεση του `freebsd-update install` δεν επέφερε αλλαγές στα αρχεία πηγαίου κώδικα του πυρήνα. Ωστόσο, το `freebsd-update` ενημερώνει πάντοτε το αρχείο [.filename]#/usr/src/sys/conf/newvers.sh#. Το αρχείο αυτό περιέχει το τρέχον επίπεδο ενημερώσεων (patch level) το οποίο και αναφέρεται ως αριθμός `-p` από εντολές όπως η `uname -r`. Μεταγλωττίζοντας ξανά τον προσαρμοσμένο πυρήνα σας (ακόμα και αν δεν υπάρχουν άλλες αλλαγές) θα δώσετε τη δυνατότητα στην man:uname[1] να αναφέρει με ακρίβεια το επίπεδο ενημερώσεων. Αυτό μπορεί να είναι ιδιαίτερα χρήσιμο όταν συντηρείτε πολλαπλά συστήματα, καθώς σας επιτρέπει να αξιολογήσετε με μια ματιά τι ενημερώσεις έχουν εγκατασταθεί στο καθένα.
====

[[freebsdupdate-upgrade]]
=== Αναβαθμίσεις σε Μικρές και Μεγάλες Εκδόσεις

Η διαδικασία αυτή θα απομακρύνει τα παλιά αρχεία αντικειμενικού κώδικα (object files) καθώς και τις παλιές βιβλιοθήκες, κάνοντας τις περισσότερες εφαρμογές τρίτων κατασκευαστών να μη λειτουργούν. Σας συνιστούμε είτε να απεγκαταστήσετε όλα τα εγκατεστημένα ports και να τα εγκαταστήσετε ξανά, ή να τα αναβαθμίσετε αργότερα, χρησιμοποιώντας το βοηθητικό πρόγραμμα package:ports-mgmt/portupgrade[]. Οι περισσότεροι χρήστες θα θέλουν να κάνουν μια δοκιμαστική μεταγλώττιση χρησιμοποιώντας την ακόλουθη εντολή:

[source,bash]
....
# portupgrade -af
....

Με αυτό τον τρόπο εξασφαλίζεται ότι τα πάντα θα επανεγκατασταθούν σωστά. Σημειώστε ότι αν θέσετε την μεταβλητή περιβάλλοντος `BATCH` στην τιμή `yes`, όλες οι πιθανές ερωτήσεις που θα εμφανιστούν κατά τη διαδικασία, θα απαντηθούν αυτόματα με `yes`. Έτσι δεν υπάρχει πλέον ανάγκη για παρέμβαση του χρήστη κατά τη διάρκεια της διαδικασίας μεταγλώττισης.

Αν χρησιμοποιείται προσαρμοσμένος πυρήνας, η διαδικασία αναβάθμισης είναι ελαφρά πιο πολύπλοκη. Θα χρειαστείτε ένα αντίγραφο του πυρήνα [.filename]#GENERIC# στον κατάλογο [.filename]#/boot/GENERIC#. Αν δεν υπάρχει ήδη ο πυρήνας [.filename]#GENERIC# στο σύστημα σας, μπορείτε να τον ανακτήσετε χρησιμοποιώντας μια από τις παρακάτω μεθόδους:

* Αν έχετε μεταγλωττίσει προσαρμοσμένο πυρήνα μόνο μια φορά, ο πυρήνας στον κατάλογο [.filename]#/boot/kernel.old# είναι στην πραγματικότητα ο [.filename]#GENERIC#. Απλώς μετονομάστε τον κατάλογο σε [.filename]#/boot/GENERIC#.
* Αν έχετε φυσική πρόσβαση στο μηχάνημα, μπορείτε να εγκαταστήσετε ένα αντίγραφο του πυρήνα [.filename]#GENERIC# από το CD-ROM της εγκατάστασης. Τοποθετήστε το CD-ROM στον οδηγό και χρησιμοποιήστε τις παρακάτω εντολές:
+
[source,bash]
....
# mount /cdrom
# cd /cdrom/X.Y-RELEASE/kernels
# ./install.sh GENERIC
....
+ 
Αντικαταστήστε το [.filename]#X.Y-RELEASE# με τους πραγματικούς αριθμούς της έκδοσης που χρησιμοποιείτε. Ο πυρήνας [.filename]#GENERIC# θα εγκατασταθεί από προεπιλογή στον κατάλογο [.filename]#/boot/GENERIC#.
* Αν δεν έχετε κάποια από τις παραπάνω επιλογές, μπορείτε να μεταγλωττίσετε και να εγκαταστήσετε τον πυρήνα [.filename]#GENERIC# μέσω του πηγαίου κώδικα:
+
[source,bash]
....
# cd /usr/src/
# env DESTDIR=/boot/GENERIC make kernel
# mv /boot/GENERIC/boot/kernel/* /boot/GENERIC
# rm -rf /boot/GENERIC/boot
....
+ 
Για να αναγνωριστεί αυτός ο πυρήνας ως [.filename]#GENERIC# από το `freebsd-update`, δεν θα πρέπει να έχουν γίνει αλλαγές στο αρχείο ρυθμίσεων του [.filename]#GENERIC#. Συνίσταται επίσης η μεταγλώττιση να γίνει χωρίς άλλες εξειδικευμένες ρυθμίσεις (κατά προτίμηση με κενό το [.filename]#/etc/make.conf#).

Δεν χρειάζεται τη δεδομένη στιγμή να επανεκκινήσετε με τον πυρήνα [.filename]#GENERIC#.

Είναι δυνατές οι αναβαθμίσεις τόσο σε μικρές όσο και σε μεγάλες εκδόσεις, δίνοντας στην εντολή `freebsd-update` τον επιθυμητό αριθμό έκδοσης. Για παράδειγμα, η ακόλουθη εντολή θα αναβαθμίσει το σύστημα σε FreeBSD 8.1:

[source,bash]
....
# freebsd-update -r 8.1-RELEASE upgrade
....

Μετά τη λήψη της εντολής, το `freebsd-update` θα αξιολογήσει την κατάσταση του συστήματος και του αρχείου ρυθμίσεων του, σε μια απόπειρα να μαζέψει τις απαραίτητες πληροφορίες για την αναβάθμιση του συστήματος. Οι πληροφορίες που ανιχνεύθηκαν θα εμφανιστούν στην οθόνη με τη μορφή μιας λίστας εγκατεστημένων προγραμμάτων. Για παράδειγμα:

[source,bash]
....
Looking up update.FreeBSD.org mirrors... 1 mirrors found.
Fetching metadata signature for 8.0-RELEASE from update1.FreeBSD.org... done.
Fetching metadata index... done.
Inspecting system... done.

The following components of FreeBSD seem to be installed:
kernel/smp src/base src/bin src/contrib src/crypto src/etc src/games
src/gnu src/include src/krb5 src/lib src/libexec src/release src/rescue
src/sbin src/secure src/share src/sys src/tools src/ubin src/usbin
world/base world/info world/lib32 world/manpages

The following components of FreeBSD do not seem to be installed:
kernel/generic world/catpages world/dict world/doc world/games
world/proflibs

Does this look reasonable (y/n)? y
....

Στο σημείο αυτό, το `freebsd-update` θα κατεβάσει όλα τα αρχεία που απαιτούνται για την αναβάθμιση. Σε μερικές περιπτώσεις, ο χρήστης θα κληθεί να απαντήσει σε ερωτήσεις σχετικά με το τι θα εγκατασταθεί ή πως πρέπει να προχωρήσει η διαδικασία.

Όταν χρησιμοποιείται προσαρμοσμένος πυρήνας, το παραπάνω βήμα θα προκαλέσει την εμφάνιση της παρακάτω προειδοποίησης:

[source,bash]
....
WARNING: This system is running a "MYKERNEL" kernel, which is not a
kernel configuration distributed as part of FreeBSD 8.0-RELEASE.
This kernel will not be updated: you MUST update the kernel manually
before running "/usr/sbin/freebsd-update install"
....

Μπορείτε να αγνοήσετε αυτή την προειδοποίηση. Θα χρησιμοποιήσουμε τον ενημερωμένο πυρήνα [.filename]#GENERIC# ως ενδιάμεσο βήμα στη διαδικασία αναβάθμισης.

Αφού μεταφορτωθούν όλα τα patches στο τοπικό σύστημα, θα γίνει και η εφαρμογή τους. Η διαδικασία αυτή ίσως πάρει λίγο χρόνο, ανάλογα με την ταχύτητα και το φορτίο του μηχανήματος. Έπειτα θα γίνει η συγχώνευση των αρχείων ρυθμίσεων. Αυτό το μέρος της διαδικασίας απαιτεί παρέμβαση του χρήστη, καθώς σε κάποια αρχεία θα χρειαστεί η συγχώνευση να γίνει χειροκίνητα με τη βοήθεια κάποιου συντάκτη κειμένου. Ο χρήστης θα ενημερώνεται για το αποτέλεσμα κάθε επιτυχημένης συγχώνευσης καθώς εξελίσσεται η διαδικασία. Σε περίπτωση αποτυχημένης συγχώνευσης (ή αγνόησης της), η διαδικασία αναβάθμισης θα διακοπεί. Ενδεχομένως να θέλετε να κρατήσετε αντίγραφο ασφαλείας του καταλόγου [.filename]#/etc# και να συγχωνεύσετε αργότερα (χειροκίνητα) κάποια σημαντικά αρχεία, όπως το [.filename]#master.passwd# ή το [.filename]#group#.

[NOTE]
====
Στο σημείο αυτό δεν έχει γίνει ακόμα καμιά αλλαγή στο σύστημα, καθώς όλη η διαδικασία της αναβάθμισης και συγχώνευσης γίνεται σε διαφορετικό κατάλογο. Όταν εφαρμοστούν επιτυχώς όλα τα patches και ολοκληρωθεί με επιτυχία η διαδικασία της συγχώνευσης όλων των αρχείων ρύθμισης, ο χρήστης θα πρέπει να επιβεβαιώσει την τελική εγκατάσταση.
====

Με το τέλος αυτής τη διαδικασίας, η αναβάθμιση μπορεί να οριστικοποιηθεί στο δίσκο, με τη χρήση της ακόλουθης εντολής:

[source,bash]
....
# freebsd-update install
....

Στην πρώτη φάση, θα αλλαχθεί ο πυρήνας και τα σχετικά αρθρώματα. Στο σημείο αυτό, θα πρέπει να γίνει επανεκκίνηση του μηχανήματος. Σε μηχάνημα με προσαρμοσμένο πυρήνα, χρησιμοποιήστε την εντολή man:nextboot[8] ώστε να θέσετε τον πυρήνα για την επόμενη εκκίνηση στον [.filename]#/boot/GENERIC# (ο οποίος έχει ήδη αναβαθμιστεί):

[source,bash]
....
# nextboot -k GENERIC
....

[WARNING]
====

Πριν επανεκκινήσετε με τον πυρήνα [.filename]#GENERIC#, βεβαιωθείτε ότι περιέχει όλα τα προγράμματα οδήγησης που απαιτούνται για την επιτυχή εκκίνηση του συστήματος σας (και τη λειτουργία του δικτύου, αν αναβαθμίζετε κάποιο απομακρυσμένο μηχάνημα). Ειδικότερα, αν ο προηγούμενος προσαρμοσμένος πυρήνας περιείχε λειτουργίες που συνήθως παρέχονται από αρθρώματα (modules), βεβαιωθείτε ότι φροντίσατε να φορτωθούν προσωρινά στον πυρήνα [.filename]#GENERIC# χρησιμοποιώντας τις δυνατότητες του αρχείου [.filename]#/boot/loader.conf#. Ίσως επίσης να θέλετε να απενεργοποιήσετε υπηρεσίες, προσαρτήσεις δίσκων και δικτύου κ.λ.π. που δεν είναι απαραίτητες, μέχρι την ολοκλήρωση της διαδικασίας αναβάθμισης.
====

Μπορείτε να χρησιμοποιήσετε την ακόλουθη εντολή για να επανεκκινήσετε το μηχάνημα με τον νέο πυρήνα:

[source,bash]
....
# shutdown -r now
....

Μόλις το σύστημα επανέλθει σε λειτουργία, θα πρέπει να εκτελέσετε ξανά το `freebsd-update`. Η προηγούμενη λειτουργία έχει αποθηκευθεί, και έτσι το `freebsd-update` δεν θα ξεκινήσει από την αρχή, αλλά θα απομακρύνει όλες τις παλιές κοινόχρηστες βιβλιοθήκες και τα αρχεία αντικειμενικού κώδικα. Για να συνεχίσετε σε αυτό το στάδιο, δώστε την ακόλουθη εντολή:

[source,bash]
....
# freebsd-update install
....

[NOTE]
====
Ανάλογα με το αν υπήρξαν αλλαγές στους αριθμούς εκδόσεων των βιβλιοθηκών, ίσως να υπάρχουν μόνο δύο φάσεις εγκατάστασης αντί για τρεις.
====

Όλο το λογισμικό τρίτου κατασκευαστή θα πρέπει τώρα να μεταγλωττιστεί και να επανεγκατασταθεί από την αρχή. Αυτό απαιτείται καθώς το εγκατεστημένο λογισμικό ίσως εξαρτάται από βιβλιοθήκες οι οποίες αφαιρέθηκαν κατά τη διαδικασία της αναβάθμισης. Μπορείτε να χρησιμοποιήσετε την εντολή package:ports-mgmt/portupgrade[] για να αυτοματοποιήσετε αυτή τη διαδικασία. Για να ξεκινήσετε, δώστε τις παρακάτω εντολές:

[source,bash]
....
# portupgrade -f ruby
# rm /var/db/pkg/pkgdb.db
# portupgrade -f ruby18-bdb
# rm /var/db/pkg/pkgdb.db /usr/ports/INDEX-*.db
# portupgrade -af
....

Μόλις ολοκληρωθεί το παραπάνω, ολοκληρώστε τη διαδικασία αναβάθμισης με μια τελευταία κλήση της εντολής `freebsd-update`. Δώστε την παρακάτω εντολή για να ολοκληρώσετε οτιδήποτε έχει απομείνει στη διαδικασία αναβάθμισης:

[source,bash]
....
# freebsd-update install
....

Αν χρησιμοποιούσατε προσωρινά τον πυρήνα [.filename]#GENERIC#, αυτή είναι η κατάλληλη στιγμή για να μεταγλωττίσετε και να εγκαταστήσετε νέο προσαρμοσμένο πυρήνα, με το συνήθη τρόπο.

Επανεκκινήστε το μηχάνημα σας στην νέα έκδοση του FreeBSD. Η διαδικασία έχει ολοκληρωθεί.

[[freebsdupdate-system-comparison]]
=== Σύγκριση Κατάστασης του Συστήματος

Το βοηθητικό πρόγραμμα `freebsd-update` μπορεί να χρησιμοποιηθεί για να ελέγξετε την κατάσταση της εγκατεστημένης έκδοσης του FreeBSD σε σχέση με μια γνωστή και σωστή εγκατάσταση. Η επιλογή αυτή συγκρίνει και αξιολογεί την τρέχουσα έκδοση των προγραμμάτων συστήματος, των βιβλιοθηκών και των αρχείων ρύθμισης. Για να ξεκινήσετε τη σύγκριση, δώστε την ακόλουθη εντολή:

[source,bash]
....
# freebsd-update IDS >> outfile.ids
....

[WARNING]
====

Αν και το όνομα της εντολής είναι IDS, δεν θα πρέπει σε καμιά περίπτωση να θεωρηθεί υποκατάστατο ενός συστήματος ανίχνευσης εισβολέα (intrusion detection system) όπως είναι για παράδειγμα το package:security/snort[]. Καθώς το `freebsd-update` αποθηκεύει τα δεδομένα του στο δίσκο, υπάρχει πάντα η πιθανότητα να έχει γίνει αλλοίωση τους. Αν και η πιθανότητα αυτή μπορεί να μειωθεί χρησιμοποιώντας τη ρύθμιση `kern.securelevel` και αποθηκεύοντας τα δεδομένα της εντολής `freebsd-update` σε ένα σύστημα αρχείων μόνο για ανάγνωση, μια ακόμα καλύτερη λύση θα ήταν να συγκρίνετε το σύστημα με κάποιο δίσκο που θεωρείτε σίγουρα ασφαλή. Μπορείτε να χρησιμοποιήσετε ένα δίσκο DVD ή ένα εξωτερικό δίσκο USB που φυλάσσετε σε ασφαλή τοποθεσία.
====

Θα γίνει τώρα μια επιθεώρηση του συστήματος και θα εκτυπωθεί μια λίστα από αρχεία και τιμές hash του τύπου man:sha256[1], τόσο για το εγκατεστημένο όσο και για το γνωστό σύστημα. Επειδή πρόκειται για μεγάλη λίστα, την ανακατευθύνουμε στο αρχείο [.filename]#outfile.ids#. Στην οθόνη το κείμενο θα κυλούσε πολύ γρήγορα, και σύντομα θα γέμιζε την προσωρινή μνήμη απεικόνισης της κονσόλας.

Οι γραμμές αυτές έχουν γενικά μεγάλο μήκος, αλλά είναι εύκολο να επεξεργαστούμε την έξοδο. Για παράδειγμα, για να δείτε μια λίστα όλων των αρχείων που διαφέρουν από αυτά της επίσημης έκδοσης, δώστε την ακόλουθη εντολή:

[source,bash]
....
# cat outfile.ids | awk '{ print $1 }' | more
/etc/master.passwd
/etc/motd
/etc/passwd
/etc/pf.conf
....

Τα παραπάνω είναι μόνο ένα μέρος της εξόδου, υπάρχουν ακόμα πολλά διαφορετικά αρχεία. Κάποια από αυτά τα αρχεία είναι φυσιολογικό να έχουν τροποποιηθεί. Για παράδειγμα, το [.filename]#/etc/passwd# έχει τροποποιηθεί, καθώς έχουν προστεθεί χρήστες στο σύστημα. Σε μερικές περιπτώσεις, μπορεί να υπάρχουν και άλλα αρχεία, όπως π.χ. αρθρώματα πυρήνα τα οποία διαφέρουν αφού έχουν ενημερωθεί μέσω της `freebsd-update`. Για να εξαιρέσετε συγκεκριμένα αρχεία ή καταλόγους, προσθέστε τα στην επιλογή `IDSIgnorePaths` στο αρχείο ρυθμίσεων [.filename]#/etc/freebsd-update.conf#.

Εκτός από την χρήση που αναφέραμε προηγουμένως, το σύστημα αυτό μπορεί να χρησιμοποιηθεί και ως τμήμα μιας λεπτομερούς διαδικασίας αναβάθμισης.

[[updating-upgrading-portsnap]]
== Portsnap: Ένα Εργαλείο Ενημέρωσης της Συλλογής των Ports

Το βασικό σύστημα του FreeBSD περιλαμβάνει επίσης ένα βοηθητικό πρόγραμμα για την ενημέρωση της Συλλογής των Ports. Πρόκειται για το man:portsnap[8]. Όταν το εκτελέσετε, θα συνδεθεί σε ένα απομακρυσμένο διακομιστή, θα επαληθεύσει το κλειδί του πηγαίου κώδικα, και θα κατεβάσει ένα νέο αντίγραφο της Συλλογής των Ports. Το κλειδί χρησιμοποιείται για να επαληθεύσει την ακεραιότητα όλων των αρχείων που μεταφορτώνονται, εξασφαλίζοντας ότι δεν έχουν αλλοιωθεί κατά την μεταφορά. Για να κατεβάσετε τα τελευταία αρχεία της Συλλογής των Ports, εκτελέστε την ακόλουθη εντολή:

[source,bash]
....
# portsnap fetch
Looking up portsnap.FreeBSD.org mirrors... 9 mirrors found.
Fetching snapshot tag from geodns-1.FreeBSD.org... done.
Fetching snapshot metadata... done.
Updating from Tue May 22 02:12:15 CEST 2012 to Wed May 23 16:28:31 CEST 2012.
Fetching 3 metadata patches.. done.
Applying metadata patches... done.
Fetching 3 metadata files... done.
Fetching 90 patches.....10....20....30....40....50....60....70....80....90. done.
Applying patches... done.
Fetching 133 new ports or files... done.
....

Το παραπάνω παράδειγμα δείχνει ότι το man:portsnap[8] βρήκε και επαλήθευσε αρκετά patches τα οποία πρέπει να εφαρμοστούν στο υπάρχον δέντρο των ports. Αυτό δείχνει επίσης ότι το πρόγραμμα έχει εκτελεστεί κατά το παρελθόν. Αν αυτή ήταν η πρώτη φορά που εκτελούνταν, θα γίνονταν απλώς κατέβασμα της συλλογής.

Όταν το man:portsnap[8] εκτελέσει επιτυχώς τη λειτουργία `fetch`, η Συλλογή των Ports και τα αντίστοιχα patches έχουν αποθηκευθεί στο τοπικό σύστημα και έχει γίνει η επαλήθευση τους. Την πρώτη φορά που θα εκτελέσετε το `portsnap`, θα πρέπει να χρησιμοποιήσετε το `extract` για να εγκαταστήσετε τα ενημερωμένα αρχεία:

[source,bash]
....
# portsnap extract
/usr/ports/.cvsignore
/usr/ports/CHANGES
/usr/ports/COPYRIGHT
/usr/ports/GIDs
/usr/ports/KNOBS
/usr/ports/LEGAL
/usr/ports/MOVED
/usr/ports/Makefile
/usr/ports/Mk/bsd.apache.mk
/usr/ports/Mk/bsd.autotools.mk
/usr/ports/Mk/bsd.cmake.mk
...
....

Αν έχετε ήδη εγκατεστημένη την Συλλογή των Ports, χρησιμοποιήστε την εντολή `portsnap update` για να την ενημέρωσετε:

[source,bash]
....
# portsnap update
....

Η διαδικασία έχει πλέον ολοκληρωθεί, και μπορείτε να εγκαταστήσετε ή να αναβαθμίσετε εφαρμογές χρησιμοποιώντας την ενημερωμένη Συλλογή των Ports.

Μπορείτε να εκτελέσετε τις διαδικασίες `fetch` και `extract` ή `update` διαδοχικά, όπως φαίνεται στο παρακάτω παράδειγμα:

[source,bash]
....
# portsnap fetch update
....

Η παραπάνω εντολή θα κατεβάσει την τελευταία έκδοση της Συλλογής των Ports και θα ενημερώσει τα τοπικά αρχεία σας στον κατάλογο [.filename]#/usr/ports#.

[[updating-upgrading-documentation]]
== Ενημερώνοντας την Τεκμηρίωση

Εκτός από το βασικό σύστημα και την Συλλογή των Ports, η τεκμηρίωση αποτελεί επίσης βασικό τμήμα ενός συστήματος FreeBSD. Αν και πάντα μπορείτε να βρείτε την πιο πρόσφατη τεκμηρίωση στην http://www.freebsd.org/doc/[δικτυακή τοποθεσία του FreeBSD], ορισμένοι χρήστες ίσως έχουν αργή ή μη σταθερή σύνδεση με το Διαδίκτυο. Ευτυχώς υπάρχουν αρκετοί τρόποι για να ενημερώσετε την τεκμηρίωση η οποία παρέχεται με κάθε επίσημη έκδοση, διατηρώντας το δικό σας τοπικό αντίγραφο της πιο πρόσφατης τεκμηρίωσης του FreeBSD.

[[csup-doc]]
=== Χρησιμοποιώντας το CVSup για την Ενημέρωση της Τεκμηρίωσης

Ο πηγαίος κώδικας και το εγκατεστημένο αντίγραφο της τεκμηρίωσης του FreeBSD, μπορούν να ενημερωθούν με την βοήθεια του CVSup, χρησιμοποιώντας ένα μηχανισμό παρόμοιο με αυτόν που χρησιμοποιείται στο βασικό σύστημα (δείτε το <<makeworld>>). Η ενότητα αυτή περιγράφει:

* Πως να εγκαταστήσετε τα εργαλεία που απαιτούνται για την τεκμηρίωση, με τα οποία μπορείτε να δημιουργήσετε την τεκμηρίωση του FreeBSD ξεκινώντας από τον πηγαίο της κώδικα.
* Πως να κατεβάσετε ένα αντίγραφο του πηγαίου κώδικα της τεκμηρίωσης στον κατάλογο [.filename]#/usr/doc# χρησιμοποιώντας το CVSup.
* Πως να αναδημιουργήσετε την τεκμηρίωση του FreeBSD από τον πηγαίο της κώδικα, και να την εγκαταστήσετε στον κατάλογο [.filename]#/usr/shared/doc/#.

[[installing-documentation-toolchain]]
=== Εγκαθιστώντας το CVSup και τη Σειρά Εργαλείων της Τεκμηρίωσης

Η αναδημιουργία της τεκμηρίωσης του FreeBSD από τον πηγαίο κώδικα, απαιτεί μια σχετικά μεγάλη συλλογή εργαλείων. Τα εργαλεία αυτά δεν είναι μέρος του βασικού συστήματος του FreeBSD, καθώς χρειάζονται αρκετό χώρο στο δίσκο και δεν είναι χρήσιμα σε όλους τους χρήστες. Είναι χρήσιμα μόνο στους χρήστες που ασχολούνται με τη συγγραφή νέας τεκμηρίωσης για το FreeBSD, ή που ενημερώνουν συχνά την τοπική τους τεκμηρίωση μέσω του πηγαίου κώδικα.

Όλα τα απαιτούμενα εργαλεία διατίθενται μέσω της Συλλογής των Ports. Το package:textproc/docproj[] είναι το κύριο port το οποίο έχει αναπτυχθεί από την Ομάδα Τεκμηρίωσης του FreeBSD, για να βοηθήσει στην αρχική εγκατάσταση και τις μελλοντικές αναβαθμίσεις αυτών των εργαλείων.

[NOTE]
====
Αν δεν απαιτείται η δημιουργία τεκμηρίωσης σε μορφές PostScript(R) ή PDF, μπορείτε να εγκαταστήσετε το port package:textproc/docproj-nojadetex[]. Αυτή η έκδοση των εργαλείων περιέχει τα πάντα εκτός από την μηχανή στοιχειοθεσίας teTeX. Το teTeX είναι μια αρκετά μεγάλη συλλογή εργαλείων, και δεν έχει νόημα να το εγκαταστήσετε αν δεν σας είναι απαραίτητη η παραγωγή της τεκμηρίωσης σε μορφή PDF.
====

Για περισσότερες πληροφορίες σχετικά με την εγκατάσταση και χρήση του CVSup, δείτε την ενότητα crossref:mirrors[cvsup,Χρησιμοποιώντας το CVSup].

[[updating-documentation-sources]]
=== Ενημερώνοντας τον Πηγαίο Κώδικα της Τεκμηρίωσης

Το βοηθητικό πρόγραμμα CVSup μπορεί να κατεβάσει ένα καθαρό αντίγραφο του πηγαίου κώδικα της τεκμηρίωσης, χρησιμοποιώντας το [.filename]#/usr/shared/examples/cvsup/doc-supfile# ως πρότυπο αρχείο ρυθμίσεων. Ο προεπιλεγμένος υπολογιστής ενημερώσεων στο παραπάνω αρχείο είναι ρυθμισμένος σε πλασματική τιμή. Ωστόσο, η man:cvsup[1] δέχεται όνομα υπολογιστή μέσω της γραμμής εντολών, έτσι μπορείτε να ανακτήσετε τον πηγαίο κώδικα της τεκμηρίωσης μέσω κάποιου εξυπηρετητή CVSup γράφοντας:

[source,bash]
....
# cvsup -h cvsup.FreeBSD.org -g -L 2 /usr/shared/examples/cvsup/doc-supfile
....

Αλλάξτε το _cvsup.FreeBSD.org_ με τον κοντινότερο σας εξυπηρετητή CVSup. Δείτε το crossref:mirrors[cvsup-mirrors,Τοποθεσίες CVSup] για μια πλήρη λίστα των mirror sites.

Το αρχικό κατέβασμα του πηγαίου κώδικα της τεκμηρίωσης μπορεί να διαρκέσει αρκετή ώρα. Αφήστε το να εκτελείται μέχρι να ολοκληρωθεί.

Μπορείτε να συνεχίσετε να ενημερώνετε τον πηγαίο κώδικα της τεκμηρίωσης χρησιμοποιώντας την ίδια εντολή. Το βοηθητικό πρόγραμμα CVSup κατεβάζει και αντιγράφει μόνο τις ενημερώσεις σε σχέση με την τελευταία εκτέλεση του, έτσι κάθε εκτέλεση του CVSup μετά την πρώτη θα πρέπει να είναι αρκετά γρήγορη.

Μετά την αρχική ανάκτηση του πηγαίου κώδικα, ένας εναλλακτικός τρόπος ενημέρωσης της τεκμηρίωσης είναι μέσω του αρχείου [.filename]#Makefile# στον κατάλογο [.filename]#/usr/doc#. Θέτοντας τις μεταβλητές `SUP_UPDATE`, `SUPHOST` και `DOCSUPFILE` στο αρχείο [.filename]#/etc/make.conf#, μπορείτε να εκτελέσετε:

[source,bash]
....
# cd /usr/doc
# make update
....

Τυπικές τιμές για τις παραπάνω επιλογές του man:make[1] στο αρχείο [.filename]#/etc/make.conf# είναι:

[.programlisting]
....
SUP_UPDATE= yes
SUPHOST?= cvsup.freebsd.org
DOCSUPFILE?= /usr/shared/examples/cvsup/doc-supfile
....

[NOTE]
====
Αν θέσετε τις τιμές των `SUPHOST` και `DOCSUPFILE` σε `?=`, θα μπορείτε να ορίσετε άλλες τιμές για αυτές στη γραμμή εντολής του make. Αυτός είναι και ο συνιστώμενος τρόπος να προσθέσετε επιλογές στο [.filename]#make.conf#, ώστε να αποφεύγετε να τροποποιείτε συνέχεια το αρχείο κάθε φορά που θέλετε να δοκιμάσετε μια νέα τιμή σε μια επιλογή.
====

[[updating-documentation-options]]
=== Προσαρμογή Επιλογών στον Πηγαίο Κώδικα της Τεκμηρίωσης

Το σύστημα ενημέρωσης και μεταγλώττισης της τεκμηρίωσης του FreeBSD, υποστηρίζει μερικές επιλογές που διευκολύνουν τη διαδικασία ενημέρωσης ενός μόνο μέρους της τεκμηρίωσης, ή την μεταγλώττιση της τεκμηρίωσης κάποιων συγκεκριμένων μεταφράσεων. Αν θέλετε οι επιλογές αυτές να ισχύουν μόνιμα, μπορείτε να τις ορίσετε μέσα στο αρχείο [.filename]#/etc/make.conf#, διαφορετικά μπορείτε να τις ορίζετε κάθε φορά στη γραμμή εντολής της man:make[1].

Κάποιες από τις επιλογές αυτές φαίνονται παρακάτω:

`DOC_LANG`::
Λίστα των γλωσσών και κωδικοποιήσεων που θα μεταγλωττιστούν και θα εγκατασταθούν, π.χ. `en_US.ISO8859-1` αν είναι επιθυμητή μόνο η Αγγλική τεκμηρίωση.

`FORMATS`::
Η μορφή (ή μια λίστα από μορφές) στην οποία θα παραχθεί η μεταγλωττισμένη τεκμηρίωση. Τη δεδομένη στιγμή υποστηρίζονται οι μορφές `html`, `html-split`, `txt`, `ps`, `pdf` και `rtf`.

`SUPHOST`::
Το όνομα του εξυπηρετητή CVSup που θα χρησιμοποιηθεί κατά την ενημέρωση.

`DOCDIR`::
Ο κατάλογος στον οποίο θα εγκατασταθεί η τεκμηρίωση. Από προεπιλογή είναι ο [.filename]#/usr/shared/doc#.

Για περισσότερες πληροφορίες σχετικά με τις μεταβλητές του make που υποστηρίζονται ως επιλογές συστήματος στο FreeBSD, δείτε την σελίδα manual του man:make.conf[5].

Για περισσότερες πληροφορίες και μεταβλητές make που υποστηρίζονται από το σύστημα μεταγλώττισης της τεκμηρίωσης του FreeBSD, παρακαλούμε δείτε τις link:/books/fdp-primer[Οδηγίες της Ομάδας Τεκμηρίωσης του FreeBSD για Νέους Συγγραφείς].

[[updating-installed-documentation]]
=== Εγκατάσταση της Τεκμηρίωσης του FreeBSD από τον Πηγαίο Κώδικα

Έχοντας ενημερώσει το τοπικό αντίγραφο του πηγαίου κώδικα της τεκμηρίωσης στον κατάλογο [.filename]#/usr/doc#, είμαστε έτοιμοι για την ενημέρωση της εγκατεστημένης τεκμηρίωσης.

Μπορείτε να προχωρήσετε σε πλήρη ενημέρωση όλων των γλωσσών που ορίζονται στην επιλογή `DOC_LANG` του Makefile, γράφοντας:

[source,bash]
....
# cd /usr/doc
# make install clean
....

Αν έχετε ρυθμίσει το [.filename]#make.conf# με τις σωστές τιμές για τις επιλογές `DOCSUPFILE`, `SUPHOST` και `SUP_UPDATE`, μπορείτε να συνδυάσετε τα βήματα ενημέρωσης και εγκατάστασης του πηγαίου κώδικα σε ένα, γράφοντας:

[source,bash]
....
# cd /usr/doc
# make update install clean
....

Αν επιθυμείτε την ενημέρωση μιας μόνο συγκεκριμένης γλώσσας, μπορείτε να καλέσετε την man:make[1] σε ένα συγκεκριμένο υποκατάλογο του [.filename]#/usr/doc#, π.χ.:

[source,bash]
....
# cd /usr/doc/en_US.ISO8859-1
# make update install clean
....

Μπορείτε να καθορίσετε τη μορφή της τεκμηρίωσης που θα εγκατασταθεί, ρυθμίζοντας τη μεταβλητή `FORMATS` του make, π.χ.:

[source,bash]
....
# cd /usr/doc
# make FORMATS='html html-split' install clean
....

[[doc-ports]]
=== Χρησιμοποιώντας τα Ports της Τεκμηρίωσης

Στην προηγούμενη ενότητα, παρουσιάσαμε μια μέθοδο για την ενημέρωση της τεκμηρίωσης του FreeBSD μέσω του πηγαίου κώδικα. Ωστόσο, οι ενημερώσεις που βασίζονται στον πηγαίο κώδικα μπορεί να μην είναι δυνατές ή πρακτικές για κάθε σύστημα FreeBSD. Η διαδικασία μεταγλώττισης του πηγαίου κώδικα της τεκμηρίωσης απαιτεί σχετικά μεγάλο αριθμό εργαλείων και βοηθητικών προγραμμάτων, γνωστά ως _εργαλεία τεκμηρίωσης_. Απαιτεί επίσης και μια σχετική εξοικείωση με το CVS και τη διαδικασία ανάκτησης των αρχείων από αυτό, καθώς και μια σειρά από βήματα για τη μεταγλώττιση του κώδικα. Στην ενότητα αυτή περιγράφουμε ένα εναλλακτικό τρόπο ενημέρωσης της τεκμηρίωσης που εγκαθίσταται μαζί με το FreeBSD. Η μέθοδος αυτή χρησιμοποιεί την Συλλογή των Ports και δίνει τις παρακάτω δυνατότητες:

* Κατέβασμα και εγκατάσταση προ-μεταγλωττισμένων στιγμιότυπων της τεκμηρίωσης, χωρίς να απαιτείται καμιά τοπική μεταγλώττιση (εξαλείφοντας έτσι και την ανάγκη εγκατάστασης όλων των εργαλείων τεκμηρίωσης).
* Κατέβασμα του πηγαίου κώδικα της τεκμηρίωσης και μεταγλώττιση του μέσω των δυνατοτήτων που παρέχουν τα εργαλεία των ports (απλοποιώντας με αυτό τον τρόπο τη χειροκίνητη διαδικασία ανάκτησης και μεταγλώττισης).

Αυτές οι δύο μέθοδοι ενημέρωσης της τεκμηρίωσης του FreeBSD υποστηρίζονται από μια σειρά από _ports τεκμηρίωσης_ τα οποία ενημερώνονται κάθε μήνα από την {doceng}. Στη Συλλογή των Ports, θα τα βρείτε κάτω από την κατηγορία http://www.freshports.org/docs/[docs].

[[doc-ports-install-make]]
==== Μεταγλώττιση και Εγκατάσταση των Ports της Τεκμηρίωσης

Τα ports της τεκμηρίωσης χρησιμοποιούν τις δυνατότητες μεταγλώττισης που παρέχει το σύστημα των ports ώστε να διευκολύνουν τη διαδικασία δημιουργίας της τεκμηρίωσης. Με αυτό τον τρόπο η ανάκτηση του πηγαίου κώδικα της τεκμηρίωσης γίνεται αυτόματα με την εκτέλεση της man:make[1] και τις κατάλληλες ρυθμίσεις στο περιβάλλον. Η εγκατάσταση και απεγκατάσταση της τεκμηρίωσης είναι το ίδιο εύκολη με την εγκατάσταση οποιουδήποτε άλλου port ή πακέτου στο FreeBSD.

[NOTE]
====
Σε περίπτωση τοπικής μεταγλώττισης των ports της τεκμηρίωσης, απαιτείται και η εγκατάσταση των _εργαλείων τεκμηρίωσης_. Τα εργαλεία αυτά ωστόσο θα εγκατασταθούν αυτόματα.
====

Η οργάνωση των ports τεκμηρίωσης φαίνεται παρακάτω:

* Υπάρχει ένα κεντρικό "master port", το package:misc/freebsd-doc-en[] το οποίο διαθέτει τα απαραίτητα αρχεία και αποτελεί την βάση όλων των άλλων ports τεκμηρίωσης. Από προεπιλογή, το port αυτό μεταγλωττίζει μόνο την Αγγλική τεκμηρίωση.
* Υπάρχει ένα port "όλα σε ένα", το package:misc/freebsd-doc-all[] το οποίο μεταγλωττίζει και εγκαθιστά όλη την τεκμηρίωση σε όλες τις διαθέσιμες γλώσσες.
* Τέλος, υπάρχει ένα "εξαρτώμενο port" για κάθε μετάφραση, π.χ.: package:misc/freebsd-doc-el[] για την Ελληνική τεκμηρίωση. Όλα αυτά τα ports εξαρτώνται από το master port και εγκαθιστούν την τεκμηρίωση που έχει μεταφραστεί στην αντίστοιχη γλώσσα.

Για να εγκαταστήσετε ένα port τεκμηρίωσης από τον πηγαίο κώδικα, εκτελέστε τις παρακάτω εντολές (ως `root`):

[source,bash]
....
# cd /usr/ports/misc/freebsd-doc-en
# make install clean
....

Το παραπάνω θα μεταγλωττίσει και θα εγκαταστήσει την Αγγλική τεκμηρίωση σε μορφή τμηματικών HTML κειμένων (όπως χρησιμοποιούνται και στο http://www.FreeBSD.org[http://www.FreeBSD.org]), στον κατάλογο [.filename]#/usr/local/shared/doc/freebsd#.

[[doc-ports-options]]
===== Συνηθισμένες Επιλογές και Παράμετροι Μεταγλώττισης

Μπορείτε να χρησιμοποιήσετε αρκετές επιλογές για την τροποποίηση της προεπιλεγμένης συμπεριφοράς των ports τεκμηρίωσης. Παρακάτω δείχνουμε μερικές μόνο από αυτές:

`WITH_HTML`::
Επιτρέπει τη δημιουργία της τεκμηρίωσης σε μορφή HTML. Θα δημιουργηθεί ένα αρχείο HTML για κάθε κείμενο. Η μορφοποιημένη τεκμηρίωση θα αποθηκευθεί, ανάλογα με την περίπτωση, σε ένα αρχείο με όνομα [.filename]#article.html# ή [.filename]#book.html#. Θα γίνει επίσης και αποθήκευση των αντίστοιχων εικόνων.

`WITH_PDF`::
Επιτρέπει τη δημιουργία εγγράφου σε μορφή Adobe(R) Portable Document Format (PDF) για χρήση με τον Adobe(R) Acrobat Reader(R), το Ghostscript, ή άλλα προγράμματα προβολής εγγράφων PDF. Η μορφοποιημένη τεκμηρίωση θα αποθηκευθεί, ανάλογα με την περίπτωση, σε ένα αρχείο [.filename]#article.pdf# ή [.filename]#book.pdf#.

`DOCBASE`::
Πρόκειται για την θέση στην οποία θα εγκατασταθεί η τεκμηρίωση. Από προεπιλογή, είναι ο κατάλογος [.filename]#/usr/local/shared/doc/freebsd#.
+

[NOTE]
====
Παρατηρήστε ότι ο προεπιλεγμένος κατάλογος διαφέρει από αυτόν που χρησιμοποιείται στη μέθοδο CVSup. Αυτό συμβαίνει επειδή γίνεται εγκατάσταση port, τα οποία από προεπιλογή χρησιμοποιούν τον κατάλογο [.filename]#/usr/local#. Μπορείτε να παρακάμψετε αυτή την προεπιλογή, αλλάζοντας την τιμή της μεταβλητής `PREFIX`.
====

Παρακάτω θα βρείτε ένα σύντομο παράδειγμα σχετικό με τη χρήση των μεταβλητών για την εγκατάσταση της Αγγλικής τεκμηρίωσης σε μορφή PDF:

[source,bash]
....
# cd /usr/ports/misc/freebsd-doc-en
# make -DWITH_PDF DOCBASE=share/doc/freebsd/en install clean
....

[[doc-ports-install-package]]
==== Χρήση Έτοιμων Πακέτων Τεκμηρίωσης

Η μεταγλώττιση των ports τεκμηρίωσης από τον πηγαίο κώδικα (όπως είδαμε στην προηγούμενη ενότητα), απαιτεί τοπική εγκατάσταση των αντίστοιχων εργαλείων τεκμηρίωσης και επάρκεια χώρου στο δίσκο για την διαδικασία. Όταν δεν διατίθενται οι απαραίτητοι πόροι για την εγκατάσταση των εργαλείων τεκμηρίωσης (ή επειδή η μεταγλώττιση από τα ports θα χρησιμοποιούσε πολύ χώρο), η εγκατάσταση μπορεί να γίνει μέσω έτοιμων πακέτων τεκμηρίωσης.

H {doceng} προετοιμάζει μηνιαία στιγμιότυπα πακέτων τεκμηρίωσης του FreeBSD. Τα έτοιμα αυτά πακέτα μπορούν να χρησιμοποιηθούν με την βοήθεια οποιουδήποτε εργαλείου διαχείρισης πακέτων που διατίθεται με το FreeBSD, όπως για παράδειγμα τα man:pkg_add[1], man:pkg_delete[1] κ.λ.π.

[NOTE]
====
Όταν χρησιμοποιείτε έτοιμα πακέτα, η εγκατάσταση της τεκμηρίωσης της επιλεγμένης γλώσσας θα γίνεται σε όλες τις διαθέσιμες μορφές.
====

Για παράδειγμα, η παρακάτω εντολή θα εγκαταστήσει την τελευταία έκδοση του έτοιμου πακέτου της Ελληνικής τεκμηρίωσης:

[source,bash]
....
# pkg_add -r el-freebsd-doc
....

[NOTE]
====
Τα πακέτα χρησιμοποιούν τη μορφή `lang-freebsd-doc` στο όνομα τους, η οποία διαφέρει από την αντίστοιχη μορφή του port. Το _lang_ είναι η σύντομη μορφή της γλώσσας, π.χ. `el` για Ελληνικά ή `zh_cn` για Απλοποιημένα Κινέζικα.
====

[[doc-ports-update]]
==== Ενημερώνοντας τα Ports της Τεκμηρίωσης

Για να ενημερώσετε ένα ήδη εγκατεστημένο port τεκμηρίωσης, μπορείτε να χρησιμοποιήσετε οποιοδήποτε εργαλείο αναβάθμισης ports. Για παράδειγμα, η παρακάτω εντολή ενημερώνει την εγκατεστημένη Ελληνική τεκμηρίωση μέσω του εργαλείου package:ports-mgmt/portupgrade[] με τη χρήση μόνο έτοιμων πακέτων:

[source,bash]
....
# portupgrade -PP el-freebsd-doc
....

[[current-stable]]
== Παρακολούθηση Ενός Κλάδου Ανάπτυξης

Υπάρχουν δύο κλάδοι ανάπτυξης στο FreeBSD, το FreeBSD-CURRENT και το FreeBSD-STABLE. Στην ενότητα αυτή, θα εξηγήσουμε κάποια πράγματα σχετικά με αυτούς τους κλάδους, και θα περιγράψουμε πως μπορείτε να διατηρήσετε το σύστημα σας ενημερωμένο σε κάποιον από αυτούς. Θα μιλήσουμε αρχικά για το FreeBSD-CURRENT και έπειτα για το FreeBSD-STABLE.

[[current]]
=== Παρακολουθώντας το FreeBSD-CURRENT

Καθώς διαβάζετε αυτό το κείμενο, να έχετε υπόψιν σας ότι το FreeBSD-CURRENT είναι πράγματι η "κόψη του ξυραφιού" στην ανάπτυξη του FreeBSD. Οι χρήστες του FreeBSD-CURRENT αναμένεται να έχουν αυξημένες τεχνικές γνώσεις, και να είναι ικανοί να επιλύουν δύσκολα προβλήματα του συστήματος τους, χωρίς βοήθεια. Αν είστε καινούριος στο FreeBSD, μάλλον θα πρέπει να το ξανασκεφτείτε πριν το εγκαταστήσετε.

==== Τι Είναι το FreeBSD-CURRENT;

Το FreeBSD-CURRENT αποτελείται από τον πλέον πρόσφατο λειτουργικό πηγαίο κώδικα του FreeBSD. Περιλαμβάνει αλλαγές που βρίσκονται σε εξέλιξη, πειραματικές αλλαγές, και μηχανισμούς μετάβασης οι οποίοι δεν είναι σίγουρο ότι θα περιλαμβάνονται στην επόμενη επίσημη έκδοση του λογισμικού. Αν και πολλά μέλη της ομάδας ανάπτυξης του FreeBSD μεταγλωττίζουν καθημερινά τον πηγαίο κώδικα του FreeBSD-CURRENT, υπάρχουν χρονικές περίοδοι που η μεταγλώττιση του είναι αδύνατη. Τα προβλήματα αυτά γενικά επιλύονται όσο πιο γρήγορα γίνεται, αλλά το αν το FreeBSD-CURRENT θα σας φέρει την καταστροφή ή κάποιο πολυπόθητο χαρακτηριστικό, είναι περισσότερο θέμα της χρονικής στιγμής που θα επιλέξετε να ανακτήσετε τον πηγαίο κώδικα!

==== Ποιος Χρειάζεται το FreeBSD-CURRENT;

Το FreeBSD-CURRENT διατίθεται και ενδιαφέρει κυρίως τις παρακάτω τρεις ομάδες:

. Μέλη της κοινότητας του FreeBSD που δουλεύουν ενεργά σε κάποιο τμήμα του πηγαίου κώδικα, και για τους οποίους η παρακολούθηση του FreeBSD-CURRENT είναι απόλυτα απαραίτητη.
. Μέλη της κοινότητας του FreeBSD που είναι ενεργοί testers και είναι πρόθυμοι να αναλώσουν το χρόνο τους για να λύσουν προβλήματα, ώστε να εξασφαλίσουν ότι το FreeBSD-CURRENT θα παραμείνει όσο το δυνατόν πιο σωστό. Συνήθως, τα μέλη αυτά κάνουν προτάσεις για τοπικές αλλαγές και για την γενική κατεύθυνση του FreeBSD, και στέλνουν patches για την πραγματοποίηση τους.
. Αυτοί που απλώς θέλουν να βλέπουν τις τελευταίες ενημερώσεις, ή να χρησιμοποιούν τον τελευταίο πηγαίο κώδικα ως αναφορά (π.χ. για _μελέτη_ και όχι για εκτέλεση). Μέλη αυτής της ομάδας μπορεί επίσης περιστασιακά να συνεισφέρουν σχόλια ή κώδικα.

==== Τι _Δεν_ Είναι το FreeBSD-CURRENT;

. Δεν είναι ένας γρήγορος τρόπος να πάρετε κώδικα ο οποίος δεν έχει κυκλοφορήσει ακόμα σε κάποια έκδοση, με την ελπίδα ότι περιέχει κάποια νέα εκπληκτική δυνατότητα και θέλετε να είστε ο πρώτος που τη χρησιμοποιεί. Αν είστε πράγματι ο πρώτος που την χρησιμοποιεί, θα είστε επίσης και ο πρώτος που θα συναντήσετε τα νέα προβλήματα και bugs.
. Δεν είναι ένας γρήγορος τρόπος για να ανακτήσετε διορθώσεις προβλημάτων. Κάθε νέα έκδοση του FreeBSD-CURRENT μπορεί να εισάγει τόσα νέα bugs όσα και αυτά που διορθώνει.
. Το FreeBSD-CURRENT δεν αποτελεί "επίσημα υποστηριζόμενο" κώδικα. Αν και καταβάλλουμε κάθε δυνατή προσπάθεια να βοηθήσουμε όσους ανήκουν "πραγματικά" σε κάποια από τις τρεις ομάδες που αναφέραμε, ωστόσο _δεν έχουμε το χρόνο_ να παρέχουμε τεχνική υποστήριξη. Αυτό δεν συμβαίνει επειδή είμαστε κακοήθεις και δύσκολοι και δεν θέλουμε να βοηθάμε τους ανθρώπους (δεν θα είχαμε καν δημιουργήσει το FreeBSD αν σκεφτόμασταν έτσι). Πολύ απλά, δεν μπορούμε να απαντάμε εκατοντάδες μηνύματα την ημέρα και _ταυτόχρονα_ να δουλεύουμε στο FreeBSD! Αν δώσετε σε οποιοδήποτε μέλος της ομάδας ανάπτυξης την επιλογή να απαντάει σε πολλές ερωτήσεις σχετικά με πειραματικό κώδικα ή να δουλεύει για τη βελτίωση του FreeBSD, θα επιλέξει σίγουρα το δεύτερο.

==== Χρησιμοποιώντας το FreeBSD-CURRENT

. Γραφτείτε στις λίστες {freebsd-current} και {svn-src-head}. Δεν είναι απλώς καλή ιδέα, είναι _βασικό_ να το κάνετε. Αν δεν είστε γραμμένος στη λίστα _{freebsd-current}_, δεν θα βλέπετε τα σχόλια σχετικά με την τρέχουσα κατάσταση του συστήματος από όσους το χρησιμοποιούν, και έτσι πιθανώς θα καταλήξετε να αντιμετωπίζετε πολλά προβλήματα που άλλοι έχουν ήδη ανακαλύψει και λύσει. Ακόμα πιο σημαντικό είναι ότι θα χάνετε σημαντικές ανακοινώσεις, οι οποίες μπορεί να είναι κρίσιμες για την διατήρηση του συστήματος σας σε υγιή κατάσταση.
+ 
Η λίστα {svn-src-head} θα σας επιτρέψει να βλέπετε τις καταχωρήσεις στο commit log για κάθε αλλαγή που γίνεται, καθώς και πληροφορίες για πιθανές παρενέργειες που μπορεί να έχει.
+ 
Για να γραφτείτε σε αυτές, ή σε οποιεσδήποτε από τις υπάρχουσες λίστες, επισκεφθείτε την τοποθεσία {mailman-lists-url} και επιλέξτε τη λίστα στην οποία θέλετε να γίνετε συνδρομητής. Οδηγίες για την υπόλοιπη διαδικασία θα βρείτε επιτόπου. Αν σας ενδιαφέρει να παρακολουθείτε τις αλλαγές σε όλο το δέντρο πηγαίου κώδικα, σας συνιστούμε να εγγραφείτε στη λίστα {svn-src-all}.
. Ανακτήστε τον πηγαίο κώδικα από ένα crossref:mirrors[mirrors,mirror site] του FreeBSD. Αυτό μπορεί να γίνει με δύο τρόπους:
.. Χρησιμοποιήστε το πρόγραμμα crossref:mirrors[cvsup,cvsup] σε συνδυασμό με το [.filename]#supfile# με την ονομασία [.filename]#standard-supfile# το οποίο θα βρείτε στον κατάλογο [.filename]#/usr/shared/examples/cvsup#. Αυτή είναι και η πλέον συνιστώμενη μέθοδος, καθώς σας επιτρέπει να ανακτήσετε όλη τη συλλογή με μια κίνηση, και στις επόμενες ανανεώσεις θα παίρνετε μόνο τις αλλαγές. Πολλοί χρήστες εκτελούν το `cvsup` μέσω του `cron` ώστε να κρατάνε τον πηγαίο κώδικα του συστήματος τους πάντα ανανεωμένο αυτόματα. Θα πρέπει να προσαρμόσετε το υπόδειγμα του [.filename]#supfile# που δίνουμε παραπάνω, και να ρυθμίσετε το crossref:mirrors[cvsup,cvsup] για το περιβάλλον σας.
+
[NOTE]
====
Το υπόδειγμα του αρχείου [.filename]#standard-supfile# προορίζεται για χρήση με κάποιο συγκεκριμένο κλάδο ασφάλειας (security branch) του FreeBSD, και όχι με το FreeBSD-CURRENT. Θα πρέπει να επεξεργαστείτε το αρχείο και να αντικαταστήσετε την παρακάτω γραμμή:

[.programlisting]
....
*default release=cvs tag=RELENG_X_Y
....

με την ακόλουθη:

[.programlisting]
....
*default release=cvs tag=.
....

Για περισσότερες πληροφορίες σχετικά με τα tags που μπορείτε να χρησιμοποιήσετε, παρακαλούμε διαβάστε στο Εγχειρίδιο την ενότητα crossref:mirrors[cvs-tags,Ετικέτες (Tags) για το CVS].
====

.. Χρησιμοποιήστε την υπηρεσία CTM. Αν έχετε πολύ κακή συνδεσιμότητα (υψηλό κόστος σύνδεσης ή πρόσβαση μόνο μέσω email) το CTM αποτελεί για σας μια εναλλακτική λύση. Μπορεί ωστόσο να σας δημιουργήσει διάφορα προβλήματα και να καταλήξετε με χαλασμένα αρχεία. Για το λόγο αυτό, το CTM χρησιμοποιείται σπάνια, κάτι το οποίο αυξάνει ακόμα περισσότερο την πιθανότητα να μη δουλεύει σωστά για μεγάλα χρονικά διαστήματα. Σας συνιστούμε να χρησιμοποιήσετε το CVSup αν διαθέτετε modem 9600 bps ή ταχύτερο.

. Αν σκοπεύετε να ανακτήσετε τον πηγαίο κώδικα για κανονική χρήση (εκτέλεση) και όχι απλώς για να τον δείτε, τότε ανακτήστε _ολόκληρο_ το FreeBSD-CURRENT και όχι κάποια επιλεγμένα τμήματα. Σε διαφορετική περίπτωση, είναι αρκετά πιθανό να συναντήσετε προβλήματα, καθώς πολλά κομμάτια του κώδικα εξαρτώνται από ανανεώσεις σε άλλα, και δεν μπορούν να μεταγλωττιστούν αυτόνομα.
+ 
Πριν μεταγλωττίσετε το FreeBSD-CURRENT, διαβάστε προσεκτικά το [.filename]#Makefile# στον κατάλογο [.filename]#/usr/src#. Θα πρέπει να <<makeworld,μεταγλωττίσετε τον πυρήνα και όλο το βασικό σύστημα (world)>> την πρώτη φορά, ως μέρος της διαδικασίας αναβάθμισης. Διαβάζοντας την {freebsd-current} και το [.filename]#/usr/src/UPDATING# θα είστε ενημερωμένοι για νέες διαδικασίες όσο αφορά την εκκίνηση στο νέο σας σύστημα. Οι διαδικασίες αυτές είναι συχνά απαραίτητες όσο πλησιάζουμε σε μια νέα επίσημη έκδοση.
. Γίνετε ενεργό μέλος! Αν χρησιμοποιείτε το FreeBSD-CURRENT, θέλουμε να ξέρουμε τη γνώμη σας για αυτό, ειδικά αν έχετε προτάσεις για βελτιώσεις ή διορθώσεις λαθών. Προτάσεις που συνοδεύονται και από κώδικα γίνονται δεκτές με ενθουσιασμό!

[[stable]]
=== Χρησιμοποιώντας το FreeBSD-STABLE

==== Τι Είναι το FreeBSD-STABLE;

Το FreeBSD-STABLE είναι ένας κλάδος ανάπτυξης από τον οποίο προκύπτουν οι "μεγάλες" (major) εκδόσεις. Οι αλλαγές εισάγονται σε αυτό τον κλάδο με διαφορετικό ρυθμό, και με τη γενική παραδοχή ότι έχουν πρώτα περάσει από το FreeBSD-CURRENT για δοκιμή. Ωστόσο, _δεν παύει_ να είναι ένας κλάδος ανάπτυξης, και αυτό σημαίνει ότι ο κώδικας του FreeBSD-STABLE μπορεί μια δεδομένη χρονική στιγμή να είναι ακατάλληλος για συγκεκριμένες εφαρμογές. Πρόκειται για μια ακόμα γραμμή ανάπτυξης για τους προγραμματιστές, και δεν είναι απαραίτητα κατάλληλη για τους τελικούς χρήστες.

==== Ποιος Χρειάζεται το FreeBSD-STABLE;

Αν σας ενδιαφέρει να παρακολουθείτε ή να συμβάλλετε στην ανάπτυξη του FreeBSD, και ειδικά όσο αφορά την επόμενη επίσημη έκδοση του από τον ίδιο κλάδο (point release), είναι καλή ιδέα να παρακολουθείτε το FreeBSD-STABLE.

Αν και είναι αλήθεια ότι οι διορθώσεις ασφάλειας γίνονται και στον κλάδο FreeBSD-STABLE, ωστόσο _δεν χρειάζεται_ να παρακολουθείτε το FreeBSD-STABLE μόνο για αυτό το λόγο. Κάθε αναφορά προβλήματος ασφάλειας του FreeBSD εξηγεί πως να διορθώσετε το πρόβλημα για κάθε επίσημη έκδοση η οποία επηρεάζεται από αυτό , και η παρακολούθηση ενός κλάδου ανάπτυξης μόνο για λόγους ασφαλείας, πιθανόν να φέρει επίσης και άλλες ανεπιθύμητες αλλαγές μαζί της.

Αν και καταβάλλουμε κάθε δυνατή προσπάθεια ώστε να εξασφαλίσουμε ότι ο κλάδος FreeBSD-STABLE μπορεί να μεταγλωττιστεί και να εκτελεστεί σε κάθε δεδομένη χρονική στιγμή, δεν μπορούμε ωστόσο να το εγγυηθούμε. Επιπρόσθετα, αν και ο κώδικας αναπτύσσεται στο FreeBSD-CURRENT πριν περάσει στο FreeBSD-STABLE, ο κόσμος που εκτελεί το FreeBSD-STABLE είναι περισσότερος, και έτσι είναι αναπόφευκτο να ανακαλύπτονται πιο πολλά σφάλματα και ακραίες περιπτώσεις στο FreeBSD-STABLE τα οποία δεν έχουν γίνει εμφανή στο FreeBSD-CURRENT.

Για τους λόγους αυτούς, _δεν_ συνιστούμε να παρακολουθείτε τυφλά το FreeBSD-STABLE, και ειδικότερα είναι σημαντικό να μην αναβαθμίζετε σε αυτό εξυπηρετητές σε περιβάλλοντα παραγωγής, χωρίς να έχετε πρώτα ελέγξει αναλυτικά τον κώδικα στο δικό σας περιβάλλον ανάπτυξης.

Αν δεν διαθέτετε τους πόρους για να το κάνετε αυτό, σας συνιστούμε να χρησιμοποιείτε την τελευταία επίσημη έκδοση του FreeBSD, και να αναβαθμίζεστε από τη μια έκδοση στην επόμενη μέσω του μηχανισμού δυαδικών ενημερώσεων.

==== Χρησιμοποιώντας το FreeBSD-STABLE

. Γραφτείτε συνδρομητής στη λίστα {freebsd-stable}. Θα είστε έτσι ενημερωμένοι για εξαρτήσεις μεταγλώττισης που ίσως εμφανιστούν στο FreeBSD-STABLE, ή για άλλα προβλήματα που χρήζουν ειδικής προσοχής. Στη λίστα αυτή θα βρίσκετε επίσης ανακοινώσεις από μέλη της ομάδας ανάπτυξης, όταν πρόκειται να συμπεριληφθεί κάποια αμφιλεγόμενη ανανέωση ή διόρθωση, δίνοντας έτσι στους χρήστες την ευκαιρία να εκφέρουν γνώμη σχετικά με τα προβλήματα που θα προκαλέσει η προτεινόμενη αλλαγή.
+ 
Θα πρέπει να εγγραφείτε στην κατάλληλη λίστα SVN ανάλογα με τον κλάδο που παρακολουθείτε. Για παράδειγμα, αν παρακολουθείτε τον κλάδο 7-STABLE, η κατάλληλη λίστα είναι η link:{svn-src-stable-7-url}[svn-src-stable-7]. Αυτό θα σας επιτρέψει να βλέπετε τις καταχωρήσεις στο commit log για κάθε αλλαγή που γίνεται, καθώς και πληροφορίες για πιθανές παρενέργειες που μπορεί να έχει.
+ 
Για να γραφτείτε σε αυτές, ή σε οποιεσδήποτε από τις υπάρχουσες λίστες, επισκεφθείτε την τοποθεσία {mailman-lists-url} και επιλέξτε τη λίστα στην οποία θέλετε να γίνετε συνδρομητής. Οδηγίες για την υπόλοιπη διαδικασία θα βρείτε επιτόπου. Αν σας ενδιαφέρει να παρακολουθείτε τις αλλαγές σε όλο το δέντρο πηγαίου κώδικα, σας συνιστούμε να εγγραφείτε στη λίστα {svn-src-all}.
. Αν πρόκειται να εγκαταστήσετε ένα νέο σύστημα με σκοπό να εκτελείτε τα μηνιαία snapshot του FreeBSD-STABLE, παρακαλούμε να ελέγξετε την τοποθεσία link:https://www.FreeBSD.org/snapshots/[Snapshots] για περισσότερες πληροφορίες. Εναλλακτικά, είναι δυνατόν να εγκαταστήσετε το πιο πρόσφατο FreeBSD-STABLE από κάποιο crossref:mirrors[mirrors,mirror site] ακολουθώντας τις παρακάτω οδηγίες ώστε να αναβαθμίσετε το σύστημα σας στην πλέον πρόσφατη έκδοση πηγαίου κώδικα του FreeBSD-STABLE.
+ 
Αν διαθέτετε ήδη κάποια προηγούμενη έκδοση του FreeBSD και επιθυμείτε να αναβαθμιστείτε μέσω του πηγαίου κώδικα, μπορείτε εύκολα να χρησιμοποιήσετε κάποιο crossref:mirrors[mirrors,mirror site] του FreeBSD. Υπάρχουν δύο τρόποι για να γίνει αυτό:
.. Χρησιμοποιήστε το πρόγραμμα crossref:mirrors[cvsup,cvsup] σε συνδυασμό με το [.filename]#supfile# με την ονομασία [.filename]#stable-supfile# το οποίο θα βρείτε στον κατάλογο [.filename]#/usr/shared/examples/cvsup#. Αυτή είναι και η πλέον συνιστώμενη μέθοδος, καθώς σας επιτρέπει να ανακτήσετε όλη τη συλλογή με μια κίνηση, και στις επόμενες ανανεώσεις θα παίρνετε μόνο τις αλλαγές. Πολλοί χρήστες εκτελούν το `cvsup` μέσω του `cron` ώστε να κρατάνε τον πηγαίο κώδικα του συστήματος τους πάντα ανανεωμένο αυτόματα. Θα πρέπει να προσαρμόσετε το υπόδειγμα του [.filename]#supfile# που δίνουμε παραπάνω, και να ρυθμίσετε το crossref:mirrors[cvsup,cvsup] για το περιβάλλον σας.
.. Χρησιμοποιήστε την υπηρεσία CTM. Αν δεν έχετε γρήγορη και φτηνή σύνδεση με το Internet, αυτή είναι η συνιστώμενη μέθοδος.

. Ουσιαστικά, αν χρειάζεστε γρήγορη και κατά απαίτηση πρόσβαση στον πηγαίο κώδικα, και το εύρος ζώνης της σύνδεσης δεν αποτελεί πρόβλημα, χρησιμοποιήστε το `cvsup` ή το `ftp`. Διαφορετικά, χρησιμοποιήστε το CTM.
. Πριν μεταγλωττίσετε το FreeBSD-STABLE, διαβάστε προσεκτικά το [.filename]#Makefile# στον κατάλογο [.filename]#/usr/src#. Θα πρέπει να <<makeworld,μεταγλωττίσετε τον πυρήνα και όλο το βασικό σύστημα (world)>> την πρώτη φορά, ως μέρος της διαδικασίας αναβάθμισης. Διαβάζοντας την {freebsd-stable} και το [.filename]#/usr/src/UPDATING# θα είστε ενημερωμένοι για νέες διαδικασίες όσο αφορά την εκκίνηση στο νέο σας σύστημα. Οι διαδικασίες αυτές είναι συχνά απαραίτητες όσο πλησιάζουμε σε μια νέα επίσημη έκδοση.

[[synching]]
== Συγχρονίζοντας τον Πηγαίο σας Κώδικα

Υπάρχουν διάφοροι τρόποι να χρησιμοποιήσετε μια σύνδεση Internet (ή email) για να ενημερώνετε οποιοδήποτε τμήμα πηγαίου κώδικα του FreeBSD Project σας ενδιαφέρει, ή και όλα αν το επιθυμείτε. Οι βασικές υπηρεσίες που προσφέρουμε είναι το crossref:mirrors[anoncvs,Ανώνυμο CVS], το crossref:mirrors[cvsup,CVSup], και το crossref:mirrors[ctm,CTM].

[WARNING]
====

Αν και είναι δυνατόν να ενημερώσετε μόνο κάποια τμήματα του δέντρου πηγαίου κώδικα, η μόνη διαδικασία ενημέρωσης που υποστηρίζεται αφορά την ενημέρωση ολόκληρου του δέντρου. Μετά την ενημέρωση, θα πρέπει να μεταγλωττίσετε ξανά τόσο το userland (δηλ. τα προγράμματα που εκτελούνται στην περιοχή χρήστη, όπως αυτά που βρίσκονται στους καταλόγους [.filename]#/bin# και [.filename]#/sbin#) όσο και τον πηγαίο κώδικα του πυρήνα. Αν ενημερώσετε μόνο ένα τμήμα του πηγαίου κώδικα, μόνο τον πυρήνα ή μόνο το userland, θα αντιμετωπίσετε προβλήματα. Τα προβλήματα αυτά μπορεί να κυμαίνονται από σφάλματα μεταγλώττισης μέχρι kernel panic και καταστροφή δεδομένων.
====

Το Ανώνυμο CVS και το CVSup χρησιμοποιούν τη μέθοδο _pull_ για την ενημέρωση του πηγαίου κώδικα. Στην περίπτωση του CVSup, ο χρήστης (η κάποιο script που εκτελείται μέσω `cron`) εκτελεί το πρόγραμμα `cvsup` το οποίο αλληλεπιδρά με ένα αντίστοιχο εξυπηρετητή `cvsupd` ώστε να ενημερώσει τα σχετικά αρχεία. Οι ενημερώσεις που λαμβάνετε είναι πάντοτε οι τελευταίες διαθέσιμες, και θα τις λάβετε μόνο όταν τις ζητήσετε. Μπορείτε εύκολα να περιορίσετε τις ενημερώσεις σε συγκεκριμένα αρχεία ή καταλόγους τα οποία σας ενδιαφέρουν. Οι ενημερώσεις δημιουργούνται δυναμικά από τον εξυπηρετητή, ανάλογα με το τι έχετε εγκατεστημένο και τι επιθυμείτε να λάβετε. Το Ανώνυμο CVS είναι κάπως πιο απλοϊκό από το CVSup, δεδομένου ότι είναι απλώς μια επέκταση του CVS που επιτρέπει την ανάκτηση αλλαγών απευθείας από κάποιο απομακρυσμένο CVS repository. Το CVSup είναι αρκετά πιο αποτελεσματικό σε αυτόν το τομέα, αλλά το Ανώνυμο CVS είναι απλούστερο στη χρήση.

Από την άλλη μεριά, το CTM δεν συγκρίνει άμεσα τον πηγαίο κώδικα που έχετε με αυτόν που υπάρχει στον κεντρικό εξυπηρετητή ώστε να ανακτήσει μόνο τις αλλαγές. Αντίθετα, στο κεντρικό μηχάνημα CTM, εκτελείται αρκετές φορές την ημέρα ένα script. Το script αυτό αναγνωρίζει τις αλλαγές στα αρχεία σε σχέση με την προηγούμενη εκτέλεση του, και έπειτα πακετάρει και συμπιέζει τις αλλαγές με τρόπο κατάλληλο για αποστολή μέσω email (μόνο εκτυπώσιμοι ASCII χαρακτήρες). Σε κάθε τέτοιο πακέτο αλλαγών αντιστοιχίζεται ένας μοναδιαίος αριθμός ακολουθίας (sequence number) που το αναγνωρίζει. Μετά τη λήψη τους, μπορείτε να δώσετε αυτά τα αρχεία διαφορών του CTM ("CTM deltas") στο βοηθητικό πρόγραμμα man:ctm_rmail[1] το οποίο αυτόματα θα τα αποκωδικοποιήσει, θα τα επαληθεύσει, και θα εφαρμόσει τις αλλαγές στο αντίγραφο πηγαίου κώδικα του χρήστη. Η διαδικασία αυτή είναι πολύ πιο αποδοτική από το CVSup, και επιβαρύνει λιγότερο τους εξυπηρετητές μας, καθώς είναι μια διαδικασία τύπου _push_ αντί για _pull_.

Υπάρχουν φυσικά κάποια σημεία που υστερεί. Αν από λάθος διαγράψετε κάποια τμήματα του πηγαίου σας κώδικα, το CVSup θα ανιχνεύσει και θα διορθώσει αυτόματα τη βλάβη για σας. Το CTM δεν θα το κάνει αυτό, και αν σβήσετε κάποιο τμήμα του δέντρου σας (και δεν έχετε αντίγραφο ασφαλείας) θα πρέπει να ξεκινήσετε από την αρχή (από το πιο πρόσφατο CVS "base delta") και να το ξανακτίσετε από την αρχή με το CTM. Με το Ανώνυμο CVS, μπορείτε απλώς να διαγράψετε τα προβληματικά αρχεία και να συγχρονίσετε ξανά τον πηγαίο σας κώδικα.

[[makeworld]]
== Μεταγλωττίζοντας το Βασικό Σύστημα ("world")

Έχοντας συγχρονίσει το τοπικό σας δέντρο πηγαίου κώδικα σε κάποια συγκεκριμένη έκδοση του FreeBSD (FreeBSD-STABLE, FreeBSD-CURRENT, κ.ο.κ.), μπορείτε έπειτα να το χρησιμοποιήσετε για να μεταγλωττίσετε το σύστημα σας από την αρχή.

[WARNING]
.Δημιουργήστε Ένα Αντίγραφο Ασφαλείας
====
Δεν μπορούμε παρά να τονίσουμε πόσο σημαντικό είναι να δημιουργήσετε ένα αντίγραφο ασφαλείας του συστήματος σας _πριν_ ξεκινήσετε αυτή τη διαδικασία. Αν και η μεταγλώττιση του βασικού συστήματος είναι (όσο τουλάχιστον ακολουθείτε αυτές τις οδηγίες) μια σχετικά απλή διαδικασία, αναμφίβολα θα υπάρξουν και περιπτώσεις που λάθη δικά σας, ή άλλων (στο δέντρο πηγαίου κώδικα), θα σας οδηγήσουν σε ένα σύστημα που δεν θα μπορεί να εκκινήσει.

Βεβαιωθείτε ότι έχετε ενημερωμένο αντίγραφο ασφαλείας. Καλό θα είναι να έχετε επίσης πρόχειρη μια δισκέτα fixit ή ένα CD εκκίνησης. Ίσως να μην χρειαστεί ποτέ να τα χρησιμοποιήσετε, αλλά καλύτερα να είστε ασφαλής παρά να το μετανοιώνετε αργότερα!
====

[WARNING]
.Γίνετε Συνδρομητής στη Σωστή Λίστα Ηλ. Ταχυδρομείου
====
Από τη φύση τους, οι κλάδοι FreeBSD-STABLE και FreeBSD-CURRENT βρίσκονται σε συνεχή _ανάπτυξη_. Όσοι συνεισφέρουν στο FreeBSD είναι απλώς άνθρωποι, και περιστασιακά λάθη απλώς συμβαίνουν.

Ορισμένες φορές τα λάθη αυτά είναι μάλλον ακίνδυνα, και το μόνο που κάνουν είναι να εμφανίζουν μερικές διαγνωστικές προειδοποιήσεις στο σύστημα σας. Ή μπορεί η αλλαγή να είναι καταστροφική, και να οδηγήσει το σύστημα σας σε αδυναμία εκκίνησης ή ακόμα και να καταστρέψει τα συστήματα αρχείων σας (ή και ακόμα χειρότερες συνέπειες).

Αν συμβούν τέτοια προβλήματα, σύντομα θα εμφανιστεί ένα μήνυμα τύπου "heads up" στις σχετικές λίστες ταχυδρομείου, το οποίο θα εξηγεί το πρόβλημα και ποια συστήματα επηρεάζει. Όταν το πρόβλημα λυθεί, θα γίνει μια αντίστοιχη "all clear" ανακοίνωση.

Αν προσπαθείτε να ακολουθήσετε το FreeBSD-STABLE ή το FreeBSD-CURRENT, και δεν διαβάζετε τις αντίστοιχες λίστες {freebsd-stable} και {freebsd-current}, ψάχνετε για μπελάδες.
====

[WARNING]
.Μην Χρησιμοποιήσετε την εντολή `make world`
====
Μεγάλο μέρος της παλαιότερης τεκμηρίωσης, συνιστά τη χρήση της εντολής `make world`. Αν την χρησιμοποιήσετε, θα παραλειφθούν ορισμένα σημαντικά βήματα της διαδικασίας. Χρησιμοποιήστε τη μόνο αν είστε απόλυτα σίγουροι για αυτό που κάνετε. Για τις περισσότερες περιπτώσεις, η εντολή `make world` είναι λανθασμένη, και αντί για αυτή θα πρέπει να ακολουθήσετε τη διαδικασία που περιγράφουμε παρακάτω.
====

[[canonical-build]]
=== Ο Κανονικός Τρόπος να Ενημερώσετε το Σύστημα σας

Πριν ενημερώσετε το σύστημα σας, θα πρέπει να ελέγξετε το [.filename]#/usr/src/UPDATING# για τυχόν βήματα που θα πρέπει να εκτελέσετε πριν την εκκίνηση της μεταγλώττισης. Τα βήματα αυτά εξαρτώνται από την έκδοση του πηγαίου κώδικα που πρόκειται να χρησιμοποιήσετε. Έπειτα, ακολουθήστε τη διαδικασία που περιγράφεται στις επόμενες παραγράφους.

Η διαδικασία αναβάθμισης η οποία περιγράφεται εδώ βασίζεται στην υπόθεση ότι έχετε ήδη εγκαταστήσει μια παλιότερη έκδοση του FreeBSD, με μια παλιά έκδοση του μεταγλωττιστή, ένα παλιό πυρήνα, παλιά "εργαλεία χρήστη" και αρχεία ρυθμίσεων. Εργαλεία χρήστη θεωρούνται τα βασικά εκτελέσιμα, οι βιβλιοθήκες και τα αρχεία προγραμματισμού. Ο μεταγλωττιστής είναι κι αυτός μέρος των "εργαλείων χρήστη" στο FreeBSD, αλλά χρειάζεται ειδική μεταχείριση κατά τη διαδικασία αναβάθμισης.

Υποθέτουμε, επίσης, ότι έχετε ήδη κατεβάσει μια ενημερωμένη έκδοση από τον πηγαίο κώδικα του συστήματος. Αν ο πηγαίος κώδικας στο συγκεκριμένο σύστημα είναι από παλιότερη έκδοση, δείτε το <<synching>> για λεπτομερείς οδηγίες σχετικά με το πως να συγχρονίσετε τον πηγαίο κώδικα σε μια νεότερη έκδοση.

Η αναβάθμιση του FreeBSD από τον πηγαίο κώδικά του φαίνεται να είναι πολύ απλή διαδικασία. Στην πραγματικότητα, έχει κάποιες ιδιαιτερότητες. Με τα χρόνια, καθώς οι εξαρτήσεις μεταξύ των βημάτων της αναβάθμισης ανακαλύπτονται ή αναλύονται καλύτερα, οι προγραμματιστές του FreeBSD αλλάζουν σιγά-σιγά αυτή τη διαδικασία. Οι παρακάτω παράγραφοι περιγράφουν τη λογική με την οποία έχει σχεδιασθεί η προτεινόμενη διαδικασία αναβάθμισης.

Μια επιτυχής διαδικασία αναβάθμισης πρέπει να καλύψει τουλάχιστον τις δύο πιο βασικές ιδιαιτερότητες μιας αναβάθμισης από πηγαίο κώδικα:

* Ο παλιός μεταγλωττιστής συστήματος μπορεί να είναι ακατάλληλος για μεταγλώττιση του νέου πυρήνα. (Και οι μεταγλωττιστές έχουν ορισμένες φορές προβλήματα, όπως κάθε άλλο λογισμικό.) Οπότε ο νέος πυρήνας πρέπει να μεταγλωττιστεί με το νέο μεταγλωττιστή. Πιο συγκεκριμένα, ο νέος μεταγλωττιστής πρέπει να αναβαθμιστεί πριν από το νέο πυρήνα. Αυτό δε σημαίνει βέβαια ότι αυτός ο νέος μεταγλωττιστής πρέπει να _εγκατασταθεί_ πριν μεταγλωττιστεί ο νέος πυρήνας.
* Τα νέα εργαλεία χρήστη από το βασικό σύστημα του FreeBSD μπορεί να εξαρτώνται από τον τρόπο λειτουργίας του νέου πυρήνα. Οπότε ο νέος πυρήνας πρέπει να εγκατασταθεί πριν από το νέο βασικό σύστημα.

Αυτά τα δύο σημεία είναι οι βασικοί λόγοι για τους οποίους προτείνονται τα κεντρικά βήματα μιας αναβάθμισης, τα βήματα `buildworld`, `buildkernel`, `installkernel`, και `installworld`. Στις επόμενες παραγράφους θα περιγράψουμε πιο αναλυτικά αυτά τα βήματα. Υπάρχουν κι άλλοι λόγοι όμως για τους οποίους χρειάζεται προσοχή όταν κάνετε μια τέτοια αναβάθμιση. Μερικοί από αυτούς είναι οι εξής:

* Τα παλιά εργαλεία του βασικού συστήματος μπορεί να μην τρέχουν σωστά με το νέο πυρήνα. Γι αυτό πρέπει να εγκατασταθεί το ενημερωμένο βασικό σύστημα αμέσως μετά την εγκατάσταση του νέου πυρήνα.
* Μερικές φορές χρειάζονται αλλαγές στα αρχεία ρυθμίσεων πριν εγκατασταθεί το νέο βασικό σύστημα. Άλλες φορές η εγκατάσταση όλων των αρχείων ρυθμίσεων μπορεί να δημιουργήσει προβλήματα στην εγκατάσταση. Γι αυτό έχουμε χωρίσει την ενημέρωση των αρχείων ρυθμίσεων σε δύο ξεχωριστά βήματα.
* Στην πλειοψηφία των περιπτώσεων η διαδικασία εγκατάστασης αντικαθιστά ή προσθέτει αρχεία του συστήματος· δε σβήνει κανένα υπάρχον αρχείο. Σε μερικές περιπτώσεις αυτό μπορεί να δημιουργήσει προβλήματα. Όταν υπάρχει τέτοια περίπτωση, η διαδικασία εγκατάστασης τυπώνει ενημερωτικά μηνύματα για τα αρχεία τα οποία πρέπει να σβηστούν χειροκίνητα. Αυτό το βήμα μπορεί να αυτοματοποιηθεί στο μέλλον.

Έχοντας όλες αυτές τις ιδιαιτερότητες μιας αναβάθμισης από πηγαίο κώδικα, καταλήξαμε στην παρακάτω διαδικασία αναβάθμισης. Ορισμένες φορές μπορεί να χρειάζεται να προσθέσετε κάποια βήματα σε αυτή τη διαδικασία. Τα βασικά βήματα όμως παραμένουν τα ίδια, κι είναι τα εξής:

. `make buildworld`
+ 
Αυτό το βήμα μεταγλωττίζει πρώτα μια ενημερωμένη έκδοση του ίδιου του μεταγλωττιστή συστήματος και μερικών απαραίτητων εργαλείων. Ύστερα, χρησιμοποιώντας το νέο μεταγλωττιστή, προετοιμάζει μια νέα έκδοση όλου του βασικού συστήματος του FreeBSD. Τα ενημερωμένα εκτελέσιμα, βιβλιοθήκες και αρχεία προγραμματισμού καταλήγουν στον κατάλογο [.filename]#/usr/obj#.
. `make buildkernel`
+ 
Σε αντίθεση με παλιότερες διαδικασίες αναβάθμισης (οι οποίες καλούσαν χειροκίνητα το man:config[8] και το man:make[1]) αυτό το βήμα μεταγλωττίζει τον πυρήνα του FreeBSD χρησιμοποιώντας τον ενημερωμένο μεταγλωττιστή συστήματος από τον κατάλογο [.filename]#/usr/obj#. Αυτό σας προστατεύει από προβλήματα ασυμβατότητας μεταξύ του μεταγλωττιστή και του πυρήνα.
. `make installkernel`
+ 
Εγκατάσταση του νέου πυρήνα και των αρθρωμάτων του στο δίσκο του συστήματος. Έτσι μπορεί πλέον το σύστημα να ξεκινήσει με το νέο, ενημερωμένο πυρήνα.
. Εκκίνηση σε λειτουργία single user.
+ 
Η λειτουργία single user ελαχιστοποιεί την πιθανότητα να έχετε προβλήματα επειδή αναβαθμίσατε κάποιο πρόγραμμα που τρέχει ήδη. Είναι επίσης πιο ασφαλής, αφού δε χρειάζεται να τρέξετε τις εφαρμογές του παλιού βασικού συστήματος με το νέο πυρήνα.
. `mergemaster -p`
+ 
Αυτό το βήμα ενημερώνει τα απολύτως βασικά αρχεία ρυθμίσεων του FreeBSD, για να μπορέσετε να εγκαταστήσετε σωστά το νέο βασικό σύστημα. Ενημερώνει, για παράδειγμα, τη βάση χρηστών και ομάδων χρηστών του FreeBSD. Κάθε φορά που προστίθεται ένας νέος χρήστης συστήματος ή μια νέα ομάδα χρηστών, το βήμα `installworld` της αναβάθμισης θεωρεί ότι έχετε ήδη ρυθμίσει τους νέους χρήστες ή τις νέες ομάδες. Αυτό ακριβώς κάνει σε αυτό το σημείο το εργαλείο man:mergemaster[8].
. `make installworld`
+ 
Το επόμενο βήμα είναι να εγκαταστήσετε το ενημερωμένο βασικό σύστημα από τον κατάλογο [.filename]#/usr/obj#. Μετά από αυτό έχετε πλέον ένα νέο πυρήνα και ένα ενημερωμένο βασικό σύστημα, το οποίο ταιριάζει με τον νέο πυρήνα.
. `mergemaster`
+ 
Ένα από τα τελευταία βήματα είναι η αναβάθμιση των αρχείων ρυθμίσεων του συστήματος. Το εργαλείο man:mergemaster[8] μπορεί να σας βοηθήσει σε αυτό το βήμα, αφού ενημερώνει τα αρχεία ρυθμίσεων κρατώντας και οποιεσδήποτε τοπικές αλλαγές έχετε κάνει στο σύστημά σας.
. Επανεκκινήστε το σύστημα.
+ 
Μια τελευταία επανεκκίνηση του συστήματος σας εξασφαλίζει ότι το σύστημα ξεκινάει με το νέο πυρήνα, το ενημερωμένο βασικό σύστημα και τα καινούρια αρχεία ρυθμίσεων.

Αν η αναβάθμιση που κάνετε είναι από μια έκδοση του FreeBSD σε μια πιο καινούρια έκδοση του ίδιου κλάδου ανάπτυξης, π.χ. από 7.0 σε 7.1, τότε μερικά από τα βήματα αυτή της διαδικασίας μπορεί να μη χρειάζονται αφού είναι λιγότερο πιθανό να συναντήσετε ασυμβατότητες μεταξύ του μεταγλωττιστή συστήματος, του πυρήνα, του βασικού συστήματος και των αρχείων ρυθμίσεων. Η αναβάθμιση σε τέτοιες περιπτώσεις, μεταξύ δύο minor εκδόσεων του FreeBSD, ίσως μπορεί να γίνει και με την παλιότερη διαδικασία: τρέχοντας `make world` και ύστερα μεταγλωττίζοντας και στήνοντας ένα νέο πυρήνα.

Όταν όμως αναβαθμίσετε το FreeBSD μεταξύ major εκδόσεων, καλύτερα να χρησιμοποιήσετε τη διαδικασία που περιγράφουμε εδώ. Αλλιώς μπορεί να αντιμετωπίσετε προβλήματα είτε κατά τη διάρκεια της αναβάθμισης ή αφού έχει πλέον ολοκληρωθεί.

Κάποιες από τις αναβαθμίσεις (π.χ. από μια έκδοση 4._X_ σε 5.0) μπορεί να απαιτούν μερικά χειροκίνητα βήματα (όπως το να μετακινήσετε ή να σβήσετε συγκεκριμένα αρχεία πριν το βήμα `installworld`). Πριν από κάθε αναβάθμιση διαβάστε προσεκτικά τις οδηγίες στο αρχείο [.filename]#/usr/src/UPDATING#· ειδικά τις οδηγίες στο τέλος του αρχείου, οι οποίες περιγράφουν αναλυτικά την προτεινόμενη διαδικασία αναβάθμισης.

Αυτή η διαδικασία αναβάθμισης εξελίσσεται και διορθώνεται καθώς οι προγραμματιστές του FreeBSD ανακαλύπτουν καινούριες εξαρτήσεις μεταξύ των συστατικών του συστήματος ή κάνουν διορθώσεις για να αποφύγουν ασυμβατότητες μεταξύ των διαφορετικών υποσυστημάτων. Ελπίζουμε ότι τα κεντρικά βήματα της διαδικασίας που περιγράφεται εδώ δε θα αλλάξουν πολύ για αρκετό καιρό πλέον.

Ανακεφαλαιώνοντας όλα τα βήματα τα οποία περιγράψαμε παραπάνω, η προτεινόμενη διαδικασία αναβάθμισης του FreeBSD από τον πηγαίο κώδικα του συστήματος είναι:

[source,bash]
....
# cd /usr/src
# make buildworld
# make buildkernel
# make installkernel
# shutdown -r now
....

[NOTE]
====
Υπάρχουν κάποιες μάλλον σπάνιες περιπτώσεις, που απαιτείται μια επιπλέον εκτέλεση του `mergemaster -p` πριν το βήμα `buildworld`. Οι περιπτώσεις αυτές περιγράφονται στο [.filename]#UPDATING#. Σε γενικές γραμμές πάντως, μπορείτε με ασφάλεια να παραλείψετε αυτό το βήμα, αν δεν αναβαθμίζετε το σύστημα σας μεταξύ πολλαπλών εκδόσεων του FreeBSD.
====

Μετά την επιτυχή ολοκλήρωση του `installkernel`, θα πρέπει να επανεκκινήσετε σε κατάσταση ενός χρήστη (π.χ. χρησιμοποιώντας την εντολή `boot -s` στην προτροπή του φορτωτή εκκίνησης). Έπειτα εκτελέστε:

[source,bash]
....
# mount -u /
# mount -a -t ufs
# adjkerntz -i
# mergemaster -p
# cd /usr/src
# make installworld
# mergemaster
# reboot
....

.Διαβάστε τις Επιπλέον Εξηγήσεις
[WARNING]
====

Η διαδικασία που περιγράψαμε παραπάνω είναι μια απλή περίληψη για να σας βοηθήσει να ξεκινήσετε. Θα πρέπει ωστόσο να διαβάσετε τις παρακάτω ενότητες για να κατανοήσετε πλήρως κάθε βήμα, ειδικά αν θέλετε να χρησιμοποιήσετε δικό σας προσαρμοσμένο πυρήνα.
====

[[src-updating]]
=== Διαβάστε το [.filename]#/usr/src/UPDATING#

Πριν κάνετε οτιδήποτε άλλο, διαβάστε το [.filename]#/usr/src/UPDATING# (ή το αντίστοιχο αρχείο, αν έχετε αποθηκεύσει τον πηγαίο κώδικα σε άλλο κατάλογο). Το αρχείο αυτό περιέχει σημαντικές πληροφορίες σχετικά με προβλήματα που μπορεί να συναντήσετε ή ίσως να καθορίζει τη σειρά με την οποία πρέπει να εκτελεστούν κάποιες εντολές. Αν το αρχείο [.filename]#UPDATING# έρχεται σε σύγκρουση με κάτι που διαβάσατε εδώ, προτεραιότητα έχει το αρχείο [.filename]#UPDATING#.

[IMPORTANT]
====
Η ανάγνωση του αρχείου [.filename]#UPDATING# δεν είναι αποδεκτό υποκατάστατο της συνδρομής στη σωστή λίστα ηλεκτρονικού ταχυδρομείου, όπως περιγράψαμε προηγουμένως. Οι δύο απαιτήσεις είναι συμπληρωματικές, δεν αλληλοαναιρούνται.
====

[[make-conf]]
=== Ελέγξτε το [.filename]#/etc/make.conf#

Εξετάστε τα αρχεία [.filename]#/usr/shared/examples/etc/make.conf# και [.filename]#/etc/make.conf#. Το πρώτο περιέχει κάποιες προεπιλεγμένες μεταβλητές (defines), οι περισσότερες από τις οποίες είναι ως σχόλια. Για να τα χρησιμοποιήσετε όταν μεταγλωττίζετε το σύστημα σας, προσθέστε τα στο [.filename]#/etc/make.conf#. Να έχετε υπόψη σας, πως οτιδήποτε προσθέτετε στο αρχείο [.filename]#/etc/make.conf# χρησιμοποιείτε επίσης κάθε φορά που εκτελείτε την εντολή `make`, έτσι είναι γενικά καλή ιδέα να βάλετε τιμές που είναι λογικές για το σύστημα σας.

Ένας τυπικός χρήστης θα θέλει πιθανώς να αντιγράψει τις γραμμές `CFLAGS` και `NO_PROFILE` από το αρχείο [.filename]#/usr/shared/examples/etc/make.conf# στο [.filename]#/etc/make.conf# αφαιρώντας ταυτόχρονα και το σύμβολο του σχολίου.

Εξετάστε και τις άλλες μεταβλητές (`COPTFLAGS`, `NOPORTDOCS` κ.ο.κ.) και αποφασίστε αν σχετίζονται με το επιθυμητό για σας αποτέλεσμα.

[[updating-etc]]
=== Ενημερώστε τα Αρχεία στο [.filename]#/etc#

Ο κατάλογος [.filename]#/etc# περιέχει μεγάλο μέρος των πληροφοριών ρύθμισης του συστήματος σας, όπως επίσης και scripts που εκτελούνται κατά την εκκίνηση του συστήματος. Μερικά από τα scripts αυτά αλλάζουν από έκδοση σε έκδοση του FreeBSD.

Ορισμένα από τα αρχεία ρυθμίσεων χρησιμοποιούνται επίσης κατά την καθημερινή χρήση του συστήματος. Το [.filename]#/etc/group# είναι ένα από αυτά.

Έχουν υπάρξει περιπτώσεις στο παρελθόν, όπου το `make installworld` ανέμενε από πριν την ύπαρξη συγκεκριμένων ονομάτων χρηστών (usernames) ή ομάδων (groups). Κατά τη διαδικασία της αναβάθμισης ήταν αρκετά πιθανό αυτοί οι χρήστες ή ομάδες να μην υπήρχαν. Αυτό δημιουργούσε προβλήματα στην διαδικασία. Σε κάποιες περιπτώσεις, το `make buildworld` θα ελέγξει αν υπάρχουν αυτοί οι χρήστες ή ομάδες.

Μια τέτοια περίπτωση παρουσιάστηκε όταν προστέθηκε ο χρήστης `smmsp`. Η διαδικασία αναβάθμισης αποτύγχανε σε πολλούς χρήστες, τη στιγμή που το man:mtree[8] προσπαθούσε να δημιουργήσει τον κατάλογο [.filename]#/var/spool/clientmqueue#.

Η λύση είναι να εκτελέσετε το man:mergemaster[8] σε κατάσταση προ-εγκατάστασης, δίνοντας την επιλογή `-p`. Αυτή θα συγκρίνει μόνο τα αρχεία που είναι απαραίτητα για την επιτυχία εκτέλεσης του `buildworld` ή του `installworld`.

[source,bash]
....
# cd /usr/src/usr.sbin/mergemaster
# ./mergemaster.sh -p
....

[TIP]
====

Αν αισθάνεστε ιδιαίτερα παρανοϊκός, μπορείτε να ελέγξετε το σύστημα σας για να δείτε ποια αρχεία ανήκουν στην ομάδα που μετονομάζετε ή διαγράφετε:

[source,bash]
....
# find / -group GID -print
....

Η παραπάνω εντολή θα σας δείξει όλα τα αρχεία τα οποία ανήκουν στην ομάδα _GID_ (μπορείτε να δώσετε όνομα ή αριθμητικό αναγνωριστικό της ομάδας).
====

[[makeworld-singleuser]]
=== Μεταβείτε σε Κατάσταση Ενός Χρήστη

Ίσως προτιμάτε να μεταγλωττίσετε το σύστημα σε κατάσταση ενός χρήστη. Εκτός από το προφανές πλεονέκτημα της ελαφρά μεγαλύτερης ταχύτητας, η επανεγκατάσταση του συστήματος θα επηρεάσει πολλά σημαντικά αρχεία του συστήματος, όλα τα εκτελέσιμα αρχεία του βασικού συστήματος, τις βιβλιοθήκες, τα αρχεία include κ.α. Αν τα αλλάξετε αυτά σε ένα σύστημα που βρίσκεται σε κανονική λειτουργία (και ειδικά αν υπάρχουν ενεργοί χρήστες την δεδομένη στιγμή), ψάχνετε για μπελάδες.

Μια άλλη μέθοδος είναι να μεταγλωττίσετε το σύστημα σε κατάσταση κανονικής λειτουργίας, αλλά να μεταβείτε σε κατάσταση ενός χρήστη για την εγκατάσταση. Αν θέλετε να το κάνετε με αυτό τον τρόπο, απλώς μην εκτελέσετε τα ακόλουθα βήματα μέχρι το τέλος της μεταγλώττισης. Μπορείτε να αναβάλλετε τη μετάβαση σε κατάσταση ενός χρήστη μέχρι να είστε έτοιμοι για το `installkernel` ή `installworld`.

Ως υπερχρήστης μπορείτε να εκτελέσετε:

[source,bash]
....
# shutdown now
....

σε ένα σύστημα σε κανονική λειτουργία για να μεταβείτε σε κατάσταση ενός χρήστη.

Εναλλακτικά, επανεκκινήστε το σύστημα και στην προτροπή του φορτωτή εκκίνησης, επιλέξτε "single user". Το σύστημα θα ξεκινήσει σε κατάσταση ενός χρήστη. Στην προτροπή της γραμμής εντολών θα πρέπει να γράψετε:

[source,bash]
....
# fsck -p
# mount -u /
# mount -a -t ufs
# swapon -a
....

Θα γίνει έλεγχος στα συστήματα αρχείων, και προσάρτηση του [.filename]#/# με δυνατότητα ανάγνωσης/εγγραφής. Έπειτα θα προσαρτηθούν όλα τα άλλα συστήματα αρχείων UFS τα οποία αναφέρονται στο [.filename]#/etc/fstab#, και θα ενεργοποιηθεί το swap.

[NOTE]
====
Αν το CMOS ρολόι του υπολογιστή σας είναι ρυθμισμένο σε τοπική ώρα και όχι σε GMT (αυτό είναι αλήθεια αν η έξοδος της εντολής man:date[1] δεν δείχνει σωστή ημερομηνία και ώρα), ίσως χρειαστεί να εκτελέσετε επίσης την παρακάτω εντολή:

[source,bash]
....
# adjkerntz -i
....

Με αυτό τον τρόπο θα βεβαιωθείτε ότι οι τοπικές σας ρυθμίσεις ώρας έχουν ρυθμιστεί σωστά. Διαφορετικά, μπορεί να συναντήσετε προβλήματα αργότερα.
====

[[cleaning-usr-obj]]
=== Διαγράψτε το [.filename]#/usr/obj#

Καθώς γίνεται η επαναμεταγλώττιση, τμήματα του συστήματος τοποθετούνται από προεπιλογή σε υποκαταλόγους του [.filename]#/usr/obj#. Οι υποκατάλογοι αυτοί αντιγράφουν τη δομή που ακολουθείται στο [.filename]#/usr/src#.

Μπορείτε να επιταχύνετε τη διαδικασία του `make buildworld` και επίσης να γλυτώσετε από κάποια πιθανά προβλήματα, αν διαγράψετε και αυτό τον κατάλογο.

Κάποια αρχεία σε υποκαταλόγους του [.filename]#/usr/obj# μπορεί να έχουν χαρακτηριστεί ως immutable μέσω του αντίστοιχου flag (για περισσότερες λεπτομέρειες δείτε το man:chflags[1]). Πριν διαγράψετε αυτά τα αρχεία, θα πρέπει πρώτα να καταργήσετε αυτό το flag.

[source,bash]
....
# cd /usr/obj
# chflags -R noschg *
# rm -rf *
....

[[updating-upgrading-compilebase]]
=== Επαναμεταγλωττίστε το Βασικό Σύστημα

==== Αποθηκεύστε την Έξοδο

Καθώς εκτελείται η man:make[1], είναι καλή ιδέα η έξοδος της να αποθηκεύεται σε κάποιο άλλο αρχείο. Αν κάτι πάει στραβά, θα έχετε ένα αντίγραφο του μηνύματος λάθους. Αν και αυτό ίσως δεν σας βοηθήσει να βρείτε τι πήγε στραβά, μπορεί να διευκολύνει άλλους αν στείλετε το μήνυμα σας σε μια από τις λίστες ηλεκτρονικού ταχυδρομείου του FreeBSD.

Ο ευκολότερος τρόπος για να γίνει αυτό, είναι χρησιμοποιώντας την εντολή man:script[1] με μια παράμετρο που να καθορίζει το όνομα του αρχείου στο οποίο θα αποθηκευτεί η έξοδος. Θα πρέπει να το εκτελέσετε αμέσως πριν ξεκινήσετε την μεταγλώττιση του βασικού συστήματος, και να γράψετε `exit` μόλις η διαδικασία ολοκληρωθεί.

[source,bash]
....
# script /var/tmp/mw.out
Script started, output file is /var/tmp/mw.out
# make TARGET
... μεταγλώττιση, μεταγλώττιση, μεταγλώττιση ...
# exit
Script done, ...
....

Αν αποφασίσετε να αποθηκεύσετε την έξοδο, _μη χρησιμοποιήσετε_ για αυτό το σκοπό τον κατάλογο [.filename]#/tmp#. Τα περιεχόμενα αυτού του καταλόγου πιθανώς να διαγραφούν την επόμενη φορά που θα εκκινήσετε το σύστημα σας. Ένας καλύτερος κατάλογος για την αποθήκευση του είναι ο [.filename]#/var/tmp# (όπως στο προηγούμενο παράδειγμα) ή ο προσωπικός κατάλογος του `root`.

[[make-buildworld]]
==== Μεταγλωττίστε το Βασικό Σύστημα

Θα πρέπει να βρίσκεστε στον κατάλογο [.filename]#/usr/src#:

[source,bash]
....
# cd /usr/src
....

(εκτός αν φυσικά έχετε αποθηκεύσει τον πηγαίο κώδικα σε κάποιο άλλο κατάλογο, οπότε απλώς μετακινηθείτε σε αυτόν).

Για να επαναμεταγλωττίσετε το βασικό σύστημα, χρησιμοποιήστε την εντολή man:make[1]. Η εντολή αυτή διαβάζει τις σχετικές οδηγίες από το αρχείο [.filename]#Makefile#, το οποίο περιγράφει με ποιο τρόπο πρέπει να μεταγλωττιστούν τα προγράμματα από τα οποία αποτελείται το FreeBSD, τη σειρά με την οποία πρέπει να γίνει η μεταγλώττιση κ.ο.κ.

Η γενική μορφή της εντολής που θα πληκτρολογήσετε είναι η παρακάτω:

[source,bash]
....
# make -x -DVARIABLE target
....

Στο παράδειγμα αυτό, το `-_x_` αντιπροσωπεύει μια επιλογή που θέλετε να δώσετε στην man:make[1]. Δείτε την σελίδα manual του man:make[1] για παραδείγματα δυνατών επιλογών.

Η επιλογή `-D__VARIABLE__` περνάει μια μεταβλητή στο [.filename]#Makefile#. Η συμπεριφορά του [.filename]#Makefile# ελέγχεται από τέτοιου είδους μεταβλητές. Πρόκειται για τις ίδιες μεταβλητές που καθορίζονται και στο [.filename]#/etc/make.conf#, και αυτός είναι ένας ακόμα τρόπος καθορισμού τους.

[source,bash]
....
# make -DNO_PROFILE target
....

Το παραπάνω δείχνει ένα επιπλέον τρόπο να καθορίσετε ότι δεν θέλετε να μεταγλωττιστούν οι βιβλιοθήκες με πληροφορίες profiling, και αντιστοιχεί με την παρακάτω γραμμή στο [.filename]#/etc/make.conf#:

[.programlisting]
....
NO_PROFILE=    true 	#    Avoid compiling profiled libraries
....

Το _target_ δηλώνει στο man:make[1] τι θέλετε να κάνετε. Σε κάθε [.filename]#Makefile# ορίζεται ένας αριθμός διαφορετικών "targets", και η επιλογή που θα κάνετε, καθορίζει τι ακριβώς θα γίνει.

Κάποια από τα targets που καθορίζονται στο [.filename]#Makefile#, δεν προορίζονται για άμεση εκτέλεση από το χρήστη. Αντί για αυτό, χρησιμοποιούνται από τη διαδικασία μεταγλώττισης για να μοιραστεί ο αριθμός των βημάτων που απαιτούνται για τη μεταγλώττιση του συστήματος, σε ένα αριθμό υπo-βημάτων.

Στις περισσότερες περιπτώσεις δεν θα χρειαστεί να δώσετε καμία παράμετρο στο man:make[1], και έτσι η εντολή σας θα μοιάζει με την παρακάτω:

[source,bash]
....
# make target
....

Όπου το _target_ θα είναι μια από τις πολλές επιλογές μεταγλώττισης. Το πρώτο target θα πρέπει πάντα να είναι το `buildworld`.

Όπως εννοείται και από το όνομα, το `buildworld` μεταγλωττίζει ένα πλήρες δέντρο μέσα στον κατάλογο [.filename]#/usr/obj#, ενώ το `installworld`, εγκαθιστά αυτό το δέντρο στο τρέχον μηχάνημα.

Η ύπαρξη διαφορετικών επιλογών, είναι χρήσιμη για δύο λόγους. Πρώτα από όλα, σας επιτρέπει να εκτελέσετε τη διαδικασία μεταγλώττισης με ασφάλεια, γνωρίζοντας ότι δεν πρόκειται να επηρεαστεί κανένα τμήμα του τρέχοντος συστήματος σας. Η διαδικασία μεταγλώττισης είναι "self hosted", απομονωμένη από την υπόλοιπη λειτουργία του μηχανήματος. Μπορείτε έτσι να εκτελέσετε το `buildworld` σε ένα μηχάνημα που βρίσκεται σε κανονική λειτουργία (πολλαπλών χρηστών) χωρίς να υπάρχει φόβος παρενεργειών. Ωστόσο, συνίσταται να εκτελέσετε το `installworld` σε κατάσταση λειτουργίας ενός χρήστη.

Ο δεύτερος λόγος είναι ότι σας επιτρέπει να χρησιμοποιήσετε προσαρτήσεις NFS για να αναβαθμίσετε πολλά μηχανήματα του δικτύου σας. Αν έχετε τρία μηχανήματα, τα `A`, `B` και `C` τα οποία θέλετε να αναβαθμίσετε, εκτελέστε το `make buildworld` και το `make installworld` στο μηχάνημα `A`. Το `B` και το `C` μπορούν να προσαρτήσουν τον κατάλογο [.filename]#/usr/src# και τον [.filename]#/usr/obj# από τον `A` μέσω NFS, και έπειτα μπορείτε να εκτελέσετε το `make installworld` για να εγκαταστήσετε το έτοιμο πλέον σύστημα στον `B` και `C`.

Αν και υπάρχει ακόμα το target `world`, δεν συνίσταται πλέον η χρήση του.

Εκτελέστε την εντολή:

[source,bash]
....
# make buildworld
....

Μπορείτε να καθορίσετε την επιλογή `-j` στην `make` ώστε να εκτελεστεί σε πολλαπλές διεργασίες. Αυτό είναι περισσότερο χρήσιμο σε μηχανήματα με πολλούς επεξεργαστές, ωστόσο καθώς το μεγαλύτερο μέρος της διαδικασίας μεταγλώττισης καθυστερεί εξαιτίας του σκληρού δίσκου (IO bound) και όχι της CPU, μπορεί να σας φανεί χρήσιμο ακόμα και σε μηχανήματα με ένα επεξεργαστή.

Σε ένα τυπικό μηχάνημα με μια CPU, θα μπορούσατε να δώσετε:

[source,bash]
....
# make -j4 buildworld
....

Με την παραπάνω εντολή, το man:make[1] θα χρησιμοποιεί μέχρι 4 διεργασίες κάθε χρονική στιγμή. Από την εμπειρία που έχουμε και από ότι αναφέρουν οι χρήστες στις λίστες, φαίνεται ότι η ρύθμιση αυτή δίνει γενικά την καλύτερη απόδοση.

Αν έχετε μηχάνημα με πολλούς επεξεργαστές, και χρησιμοποιείτε πυρήνα με δυνατότητα SMP, δοκιμάστε τιμές μεταξύ του 6 και του 10 για να δείτε ποια επιταχύνει καλύτερα το αποτέλεσμα.

==== Χρόνος Μεταγλώττισης

Ο χρόνος που απαιτείται για την μεταγλώττιση επηρεάζεται από πολλούς παράγοντες. Ωστόσο, σε σύγχρονα μηχανήματα η διαδικασία δεν κρατάει συνήθως παραπάνω από μία ή δύο ώρες, όταν γίνεται μεταγλώττιση του δέντρου FreeBSD-STABLE, και μάλιστα χωρίς να χρειάζεται να γίνουν ειδικές ρυθμίσεις ή κόλπα. Το δέντρο FreeBSD-CURRENT χρειάζεται γενικά λίγο περισσότερο χρόνο για να μεταγλωττιστεί.

[[new-kernel]]
=== Μεταγλωττίστε και Εγκαταστήστε Νέο Πυρήνα

Για να εκμεταλλευθείτε πλήρως το νέο σας σύστημα, θα πρέπει να επαναμεταγλωττίσετε τον πυρήνα. Αυτό είναι πρακτικά αναγκαίο, καθώς κάποιες δομές στη μνήμη πιθανώς να έχουν αλλάξει, και έτσι προγράμματα όπως τα man:ps[1] και man:top[1] δεν θα λειτουργούν σωστά μέχρι να συγχρονίσετε τον πυρήνα με την έκδοση πηγαίου κώδικα του βασικού συστήματος.

Ο απλούστερος και πλέον ασφαλής τρόπος, είναι να μεταγλωττίσετε και να εγκαταστήσετε ένα πυρήνα βασισμένο στον [.filename]#GENERIC#. Αν και ο [.filename]#GENERIC# μπορεί να μην περιέχει όλες τις απαραίτητες συσκευές για το σύστημα σας, θα πρέπει να περιέχει ότι χρειάζεται ώστε να ξεκινήσετε ξανά το σύστημα σας σε κατάσταση λειτουργίας ενός χρήστη. Αυτό είναι ένα καλό τεστ σωστής λειτουργίας του συστήματος. Μετά την εκκίνηση με τον [.filename]#GENERIC#, και αφού επαληθεύσετε τη σωστή λειτουργία του συστήματος, μπορείτε να μεταγλωττίσετε ένα νέο πυρήνα βασισμένο στο δικό σας προσαρμοσμένο αρχείο ρυθμίσεων.

Στο FreeBSD είναι σημαντικό να εκτελέσετε το <<make-buildworld,build world>> πριν μεταγλωττίσετε νέο πυρήνα.

[NOTE]
====
Αν θέλετε να μεταγλωττίσετε νέο πυρήνα, και έχετε ήδη ένα αρχείο με προσαρμοσμένες ρυθμίσεις, χρησιμοποιήστε απλώς την επιλογή `KERNCONF=MYKERNEL` με τον τρόπο που φαίνεται παρακάτω:

[source,bash]
....
# cd /usr/src
# make buildkernel KERNCONF=MYKERNEL
# make installkernel KERNCONF=MYKERNEL
....

====

Σημειώστε ότι αν έχετε ανεβάσει την τιμή του `kern.securelevel` πάνω από το 1, _και_ έχετε θέσει το flag `noschg` ή κάποιο αντίστοιχο στο εκτελέσιμο αρχείο του πυρήνα, μάλλον θα χρειαστεί να μεταβείτε σε κατάσταση λειτουργίας ενός χρήστη για να χρησιμοποιήσετε το `installkernel`. Διαφορετικά, μπορείτε να εκτελέσετε και τις δύο αυτές εντολές από την κανονική κατάσταση λειτουργίας (πολλών χρηστών) χωρίς να δημιουργηθούν προβλήματα. Δείτε τη σελίδα manual του man:init[8] για λεπτομέρειες σχετικά με τη ρύθμιση `kern.securelevel` και τη σελίδα του man:chflags[1] για λεπτομέρειες σχετικά με τα διάφορα flags που χρησιμοποιούνται σε αρχεία.

[[new-kernel-singleuser]]
=== Επανεκκινήστε σε Κατάσταση Λειτουργίας Ενός Χρήστη

Θα πρέπει να επανεκκινήσετε σε κατάσταση λειτουργίας ενός χρήστη για να επαληθεύσετε τη λειτουργία του νέου πυρήνα. Για το σκοπό αυτό, χρησιμοποιήστε τις οδηγίες που είδαμε στο <<makeworld-singleuser>>.

[[make-installworld]]
=== Εγκαταστήστε τα Νέα Εκτελέσιμα του Συστήματος

Θα πρέπει τώρα να χρησιμοποιήσετε το `installworld` για να εγκαταστήσετε τα νέα εκτελέσιμα του συστήματος.

Εκτελέστε τις παρακάτω εντολές:

[source,bash]
....
# cd /usr/src
# make installworld
....

[NOTE]
====
Αν έχετε καθορίσει μεταβλητές στη γραμμή εντολών του `make buildworld` θα πρέπει να καθορίσετε τις ίδιες μεταβλητές και στην γραμμή εντολών του `make installworld`. Αυτό δεν είναι απαραίτητα αλήθεια για άλλες επιλογές. Για παράδειγμα, η επιλογή `-j` δεν πρέπει ποτέ να χρησιμοποιείτε με το `installworld`.

Για παράδειγμα αν εκτελέσετε:

[source,bash]
....
# make -DNO_PROFILE buildworld
....

Θα πρέπει να εγκαταστήσετε το αποτέλεσμα χρησιμοποιώντας:

[source,bash]
....
# make -DNO_PROFILE installworld
....

διαφορετικά το man:make[1] θα προσπαθήσει να εγκαταστήσει βιβλιοθήκες με profiling, τις οποίες όμως δεν μεταγλωττίσατε κατά τη διάρκεια της φάσης `make buildworld`.
====

[[post-installworld-updates]]
=== Ενημερώστε Όσα Αρχεία δεν Ενημερώθηκαν από το `make installworld`

Η επαναμεταγλώττιση του βασικού συστήματος δεν θα ενημερώσει ορισμένους καταλόγους (ειδικότερα τους [.filename]#/etc#, [.filename]#/var# και [.filename]#/usr#) με τα νέα ή αλλαγμένα αρχεία ρυθμίσεων.

Ο απλούστερος τρόπος για να ενημερώσετε τα αρχεία αυτά είναι να χρησιμοποιήσετε το man:mergemaster[8], αν και μπορείτε να το κάνετε και χειροκίνητα αν προτιμάτε. Άσχετα από τον τρόπο που θα προτιμήσετε, βεβαιωθείτε ότι έχετε πάρει αντίγραφο ασφαλείας του [.filename]#/etc# σε περίπτωση που κάτι πάει στραβά.

[[mergemaster]]
==== `mergemaster`

Το βοηθητικό πρόγραμμα man:mergemaster[8] είναι ένα Bourne script το οποίο θα σας βοηθήσει να καθορίσετε τις διαφορές μεταξύ των εγκατεστημένων στο [.filename]#/etc# αρχείων ρυθμίσεων, και των αντίστοιχων στο δέντρο πηγαίου κώδικα στο [.filename]#/usr/src/etc#. Αυτή είναι και η συνιστώμενη λύση για να ενημερώσετε τα αρχεία ρυθμίσεων του συστήματος με τυχόν αλλαγές που έχουν γίνει στον νέο πηγαίο κώδικα.

Για να ξεκινήσετε, απλώς γράψτε `mergemaster` στην προτροπή της γραμμής εντολών και παρακολουθήστε την καθώς λειτουργεί. Το `mergemaster` θα δημιουργήσει ένα προσωρινό περιβάλλον root, από το [.filename]#/# και κάτω, και θα το γεμίσει με διάφορα αρχεία ρυθμίσεων του συστήματος. Έπειτα θα γίνει σύγκριση αυτών των αρχείων με τα αντίστοιχα που βρίσκονται ήδη εγκατεστημένα στο σύστημα σας. Στο σημείο αυτό, θα σας δείξει τα αρχεία που διαφέρουν με μορφή man:diff[1], όπου οι γραμμές που έχουν τροποποιηθεί ή είναι νέες θα φαίνονται με ένα `+`, ενώ με το `-` θα φαίνονται οι γραμμές που είτε αφαιρούνται εντελώς ή που αντικαθίστανται από μια νέα γραμμή. Δείτε τη σελίδα manual του man:diff[1] για περισσότερες πληροφορίες σχετικά με τη σύνταξη του man:diff[1] και για τον τρόπο με τον οποίο φαίνονται οι διαφορές μεταξύ των αρχείων.

Το man:mergemaster[8] θα σας δείξει έπειτα κάθε αρχείο που παρουσιάζει διαφορές, και στο σημείο αυτό θα έχετε την δυνατότητα είτε να διαγράψετε το νέο αρχείο (το οποίο αναφέρεται ως προσωρινό αρχείο), είτε να εγκαταστήσετε το προσωρινό αρχείο χωρίς να κάνετε σε αυτό καμιά αλλαγή, είτε να συγχωνεύσετε τις αλλαγές των δύο αρχείων, ή τέλος να ξαναδείτε τις διαφορές μέσω της man:diff[1].

Αν επιλέξετε να διαγράψετε το προσωρινό αρχείο, το man:mergemaster[8] θα καταλάβει ότι επιθυμείτε να διατηρήσετε το τρέχον αρχείο σας χωρίς αλλαγές, και να διαγράψετε τη νέα έκδοση. Η επιλογή αυτή γενικά δεν συνίσταται, εκτός αν δεν βλέπετε κανένα λόγο να αλλάξετε το τρέχον αρχείο. Μπορείτε να δείτε βοήθεια οποιαδήποτε στιγμή κατά τη διάρκεια της διαδικασίας, πληκτρολογώντας kbd:[?] στην προτροπή του man:mergemaster[8]. Αν αποφασίσετε να παραλείψετε κάποιο αρχείο, αυτό θα εμφανιστεί ξανά μετά το τέλος όλων των άλλων αρχείων.

Αν επιλέξετε να εγκαταστήσετε το προσωρινό αρχείο χωρίς αλλαγές, αυτό θα αντικαταστήσει το ήδη εγκατεστημένο σας αρχείο. Αυτή είναι και η καλύτερη επιλογή για τα αρχεία τα οποία δεν έχετε αλλάξει εσείς χειροκίνητα.

Αν επιλέξετε να συγχωνεύσετε τα δύο αρχεία, θα εμφανιστεί ένας επεξεργαστής κειμένου με τα περιεχόμενα και των δύο αρχείων. Μπορείτε τώρα να τα συγχωνεύσετε παρατηρώντας ταυτόχρονα και τα δύο αρχεία δίπλα-δίπλα, και επιλέγοντας τμήματα και από τα δύο για να δημιουργήσετε την τελική έκδοση. Κατά τη σύγκριση αυτή, μπορείτε να χρησιμοποιήσετε το πλήκτρο kbd:[l] για να επιλέξετε τα περιεχόμενα που φαίνονται στην αριστερή πλευρά, ή το kbd:[r] για τα αντίστοιχα περιεχόμενα στη δεξιά. Το τελικό αποτέλεσμα θα είναι ένα αρχείο που θα αποτελείται από τμήματα και των δύο αρχείων, και το οποίο μπορείτε να εγκαταστήσετε. Η επιλογή αυτή χρησιμοποιείται συνήθως για αρχεία των οποίων το περιεχόμενο έχει μεταβληθεί από το χρήστη.

Αν επιλέξετε να δείτε ξανά τις διαφορές μέσω της man:diff[1], αυτές θα εμφανιστούν ακριβώς όπως έγινε και πριν σας ρωτήσει το man:mergemaster[8] να επιλέξετε τι θέλετε να κάνετε με το αρχείο.

Μόλις ολοκληρωθεί η λειτουργία του man:mergemaster[8] στα αρχεία συστήματος, θα σας ρωτήσει για άλλες επιλογές. Το man:mergemaster[8] ίσως σας ρωτήσει αν θέλετε να αναδημιουργήσετε το αρχείο των κωδικών (password file), και θα τελειώσει δίνοντας σας την επιλογή να διαγράψετε τυχόν προσωρινά αρχεία που δημιουργήθηκαν κατά την διαδικασία.

==== Χειροκίνητη Ενημέρωση

Αν επιθυμείτε να κάνετε την ενημέρωση χειροκίνητα, δεν μπορείτε απλώς να αντιγράψετε τα αρχεία από τον κατάλογο [.filename]#/usr/src/etc# στον [.filename]#/etc# και να περιμένετε ότι το σύστημα σας θα λειτουργήσει σωστά. Κάποια από αυτά τα αρχεία θα πρέπει να "εγκατασταθούν" πρώτα. Αυτό συμβαίνει επειδή ο κατάλογος [.filename]#/usr/src/etc#_δεν είναι_ κανονικό αντίγραφο του [.filename]#/etc#. Επιπρόσθετα, υπάρχουν αρχεία τα οποία πρέπει να βρίσκονται στον κατάλογο [.filename]#/etc#, αλλά δεν υπάρχουν στον [.filename]#/usr/src/etc#.

Αν χρησιμοποιείτε το man:mergemaster[8] (όπως και συνίσταται), μπορείτε να διαβάσετε κατευθείαν την <<updating-upgrading-rebooting,επόμενη ενότητα>>.

Ο απλούστερος τρόπος να το κάνετε αυτό χειροκίνητα, είναι να εγκαταστήσετε τα αρχεία σε ένα νέο κατάλογο, και έπειτα να τα εξετάσετε ένα-ένα ψάχνοντας για τις αλλαγές.

[WARNING]
.Κρατήστε Ένα Αντίγραφο Ασφαλείας του Καταλόγου [.filename]#/etc#
====
Αν και θεωρητικά, τίποτα δεν πρόκειται να πειράξει αυτό τον κατάλογο αυτόματα, είναι πάντα καλύτερα να είμαστε σίγουροι. Για το λόγο αυτό, αντιγράψτε τον υπάρχοντα κατάλογο [.filename]#/etc# σε κάποιο ασφαλές μέρος. Χρησιμοποιήστε μια εντολή όπως η παρακάτω:

[source,bash]
....
# cp -Rp /etc /etc.old
....

Η επιλογή `-R` πραγματοποιεί αναδρομική αντιγραφή, ενώ η `-p` διατηρεί τα δικαιώματα, την ιδιοκτησία, τις ημερομηνίες των αρχείων, κ.ο.κ.
====

θα πρέπει να δημιουργήσετε μια ψευτο-δομή καταλόγων για να εγκαταστήσετε το νέο κατάλογο [.filename]#/etc# και άλλα αρχεία. Μια λογική επιλογή είναι ο κατάλογος [.filename]#/var/tmp/root#, και κάτω από αυτόν, θα πρέπει επίσης να δημιουργήσετε και μια ολόκληρη σειρά από τους υποκαταλόγους που απαιτούνται.

[source,bash]
....
# mkdir /var/tmp/root
# cd /usr/src/etc
# make DESTDIR=/var/tmp/root distrib-dirs distribution
....

Οι παραπάνω εντολές θα δημιουργήσουν την απαιτούμενη δομή καταλόγων και θα εγκαταστήσουν τα αρχεία. Μεγάλο μέρος των υποκαταλόγων που έχουν δημιουργηθεί κάτω από τον [.filename]#/var/tmp/root# είναι άδειοι, και πρέπει να διαγραφούν. Ο απλούστερος τρόπος για να γίνει αυτό, φαίνεται παρακάτω:

[source,bash]
....
# cd /var/tmp/root
# find -d . -type d | xargs rmdir 2/dev/null
....

Αυτό θα διαγράψει όλους τους άδειους υποκαταλόγους. (Η έξοδος σφάλματος ανακατευθύνεται στο [.filename]#/dev/null# ώστε να μην εμφανίζονται στην οθόνη προειδοποιήσεις για καταλόγους που δεν είναι άδειοι.)

Τώρα, ο [.filename]#/var/tmp/root# περιέχει όλα τα αρχεία που θα πρέπει να τοποθετηθούν σε κατάλληλες θέσεις κάτω από τον [.filename]#/#. Θα πρέπει τώρα να διατρέξετε καθένα από αυτά τα αρχεία, και να καθορίσετε πως καθένα από αυτά διαφέρει από το αντίστοιχο υπάρχον (εγκατεστημένο) αρχείο.

Σημειώστε ότι κάποια από τα αρχεία τα οποία έχουν εγκατασταθεί στον [.filename]#/var/tmp/root# έχουν μια αρχική ".". Τη στιγμή που γράφονται αυτές οι γραμμές, τα μόνα αρχεία στα οποία συμβαίνει αυτό είναι τα αρχεία εκκίνησης του κελύφους στον κατάλογο [.filename]#/var/tmp/root/# και [.filename]#/var/tmp/root/root/#, αν και μπορεί να υπάρχουν και άλλα (ανάλογα με το πότε διαβάζετε το κείμενο). Βεβαιωθείτε ότι χρησιμοποιείτε την εντολή `ls -a` για να τα δείτε όλα.

Ο απλούστερος τρόπος για να συγκρίνετε δύο αρχεία, είναι να χρησιμοποιήσετε την εντολή man:diff[1]:

[source,bash]
....
# diff /etc/shells /var/tmp/root/etc/shells
....

Η παραπάνω εντολή θα σας δείξει τις διαφορές μεταξύ του αρχείου [.filename]#/etc/shells# και του νέου αρχείου [.filename]#/var/tmp/root/etc/shells#. Χρησιμοποιήστε τις διαφορές αυτές για να αποφασίσετε αν θα πρέπει να συγχωνεύσετε τις αλλαγές που έχετε κάνει, ή απλώς να αντιγράψετε το παλιό σας αρχείο πάνω από το νέο.

[TIP]
.Προσθέστε την Ημερομηνία στο Όνομα του Νέου Root Καταλόγου, ([.filename]#/var/tmp/root#) Ώστε να Μπορείτε Εύκολα να Συγκρίνετε Διαφορετικές Εκδόσεις Μεταξύ τους
====
Αν μεταγλωττίζετε συχνά το βασικό σύστημα, θα πρέπει επίσης να ενημερώνετε συχνά τον κατάλογο [.filename]#/etc#, το οποίο μπορεί να είναι ενοχλητικό.

Μπορείτε να επιταχύνετε αυτή τη διαδικασία, τηρώντας ένα αντίγραφο του τελευταίου σετ αλλαγμένων αρχείων τα οποία συγχωνεύσατε στον κατάλογο [.filename]#/etc#. Η παρακάτω διαδικασία θα σας δώσει μια ιδέα για το πως μπορεί να γίνει αυτό:

[.procedure]
. Μεταγλωττίστε το βασικό σύστημα όπως κάνετε συνήθως. Όταν θέλετε να ενημερώσετε τον [.filename]#/etc# και τους άλλους καταλόγους, δώστε στον κατάλογο προορισμού ένα όνομα βασισμένο στην τρέχουσα ημερομηνία. Αν το κάνατε αυτό στις 14 Φεβρουαρίου 1998, θα γράφατε κάτι σαν το παρακάτω:
+
[source,bash]
....
# mkdir /var/tmp/root-19980214
# cd /usr/src/etc
# make DESTDIR=/var/tmp/root-19980214 \
    distrib-dirs distribution
....

. Συγχωνεύστε τις αλλαγές από αυτό τον κατάλογο, με τον τρόπο που περιγράψαμε παραπάνω.
+ 
_Μην διαγράψετε_ τον κατάλογο [.filename]#/var/tmp/root-19980214# όταν τελειώσετε με την παραπάνω διαδικασία.
. Όταν κατεβάσετε την τελευταία έκδοση του πηγαίου κώδικα και τον μεταγλωττίσετε ξανά, ακολουθήστε το βήμα 1. Αυτό θα σας δώσει ένα κατάλογο που μπορεί να ονομάζεται [.filename]#/var/tmp/root-19980221# (αν ανάμεσα στις δύο μεταγλωττίσεις παρεμβάλλεται διάστημα μιας εβδομάδας).
. Μπορείτε τώρα να δείτε τις διαφορές που υπάρχουν ανάμεσα στις δύο εβδομάδες, χρησιμοποιώντας την εντολή man:diff[1] σε αναδρομική λειτουργία για να δημιουργήσετε τις διαφορές μεταξύ των δύο καταλόγων:
+
[source,bash]
....
# cd /var/tmp
# diff -r root-19980214 root-19980221
....
+ 
Τυπικά, αυτό το σετ αλλαγών θα είναι πολύ μικρότερο από αυτό μεταξύ του [.filename]#/var/tmp/root-19980221/etc# και του [.filename]#/etc#. Καθώς αυτό το σετ αλλαγών είναι μικρότερο, είναι και πιο εύκολο να εφαρμόσετε αυτές τις αλλαγές στον κατάλογο [.filename]#/etc#.
. Μπορείτε τώρα να διαγράψετε τον παλιότερο από τους δύο καταλόγους [.filename]#/var/tmp/root-*#:
+
[source,bash]
....
# rm -rf /var/tmp/root-19980214
....

. Επαναλάβετε αυτή τη διαδικασία κάθε φορά που θέλετε να συγχωνεύσετε τις αλλαγές στον κατάλογο [.filename]#/etc#.

Μπορείτε επίσης να χρησιμοποιήσετε την εντολή man:date[1] για να αυτοματοποιήσετε την δημιουργία των ονομάτων καταλόγων:

[source,bash]
....
# mkdir /var/tmp/root-`date "+%Y%m%d"`
....

====

[[updating-upgrading-rebooting]]
=== Επανεκκίνηση

Η διαδικασία έχει πλέον ολοκληρωθεί. Αφού επαληθεύσετε ότι όλα βρίσκονται στις σωστές θέσεις, μπορείτε να επανεκκινήσετε το σύστημα. Μια απλή εντολή man:shutdown[8] είναι επαρκής:

[source,bash]
....
# shutdown -r now
....

=== Ολοκλήρωση

Έχετε πλέον αναβαθμίσει το FreeBSD σύστημα σας. Συγχαρητήρια.

Αν τα πράγματα δεν πήγαν εντελώς σωστά, είναι εύκολο να μεταγλωττίσετε ξανά οποιοδήποτε τμήμα του συστήματος. Για παράδειγμα, αν διαγράψετε κατά λάθος το [.filename]#/etc/magic# ως μέρος μιας αναβάθμισης ή συγχώνευσης του [.filename]#/etc#, η εντολή man:file[1] θα σταματήσει να λειτουργεί. Στην περίπτωση αυτή, η διόρθωση είναι να εκτελέσετε:

[source,bash]
....
# cd /usr/src/usr.bin/file
# make all install
....

[[updating-questions]]
=== Ερωτήσεις

==== Πρέπει να μεταγλωττίσω ξανά ολόκληρο το βασικό σύστημα σε κάθε αλλαγή;

Δεν υπάρχει εύκολη απάντηση σε αυτό το ερώτημα, καθώς εξαρτάται από τη φύση της αλλαγής. Για παράδειγμα, αν εκτελέσετε το CVSup, και δείτε ότι ενημερώθηκαν τα παρακάτω αρχεία:

[source,bash]
....
src/games/cribbage/instr.c
src/games/sail/pl_main.c
src/release/sysinstall/config.c
src/release/sysinstall/media.c
src/shared/mk/bsd.port.mk
....

Το πιθανότερο είναι ότι δεν χρειάζεται να μεταγλωττίσετε ξανά όλο το βασικό σύστημα. Μπορείτε απλώς να μεταβείτε στους σχετικούς υποκαταλόγους και να εκτελέσετε το `make all install`, και θα έχετε τελειώσει. Αν όμως υπάρχει κάποια σημαντική αλλαγή, για παράδειγμα το [.filename]#src/lib/libc/stdlib#, θα πρέπει είτε να επαναμεταγλωττίσετε το βασικό σύστημα, ή τουλάχιστον αυτά τα κομμάτια τα οποία είναι στατικά συνδεδεμένα (όπως και οτιδήποτε άλλο έχετε προσθέσει εσείς και το οποίο είναι στατικά συνδεδεμένο).

Τελικά, η απόφαση είναι δική σας. Μπορεί να είστε ικανοποιημένος αν μεταγλωττίζετε το βασικό σύστημα κάθε δύο βδομάδες, αφήνοντας τις αλλαγές να συγκεντρωθούν στη διάρκεια αυτού του διαστήματος. Ή μπορεί να θέλετε να μεταγλωττίσετε μόνο τις αλλαγές, αν έχετε την πεποίθηση ότι μπορείτε να εντοπίσετε όλες τις εξαρτήσεις τους.

Και φυσικά, όλα αυτά εξαρτώνται από το πόσο συχνά θέλετε να ενημερώνετε το σύστημα σας, και από το αν ακολουθείτε το FreeBSD-STABLE ή το FreeBSD-CURRENT.

==== Η μεταγλώττιση μου απέτυχε με πλήθος μηνυμάτων signal 11signal 11 (ή λάθη με άλλα σήματα). Τι έχει συμβεί;

Αυτό συνήθως δείχνει προβλήματα υλικού. Η διαδικασία μεταγλώττισης του βασικού συστήματος είναι ένας αποτελεσματικός τρόπος να δοκιμάσετε το υλικό σας στα όρια του, και συχνά θα δείξει προβλήματα που σχετίζονται με τη μνήμη. Το πιο σύνηθες σύμπτωμα, είναι η απότομη διακοπή της μεταγλώττισης, με τον μεταγλωττιστή να φαίνεται ότι έχει λάβει κάποιο μυστηριώδες σήμα.

Ένα σίγουρο σημάδι για το παραπάνω, είναι να επανεκκινήσετε τη διαδικασία, και αυτή να σταματήσει σε διαφορετικό σημείο.

Στην περίπτωση αυτή, δεν υπάρχουν και πολλά που μπορείτε να κάνετε, εκτός από το να αρχίσετε να αλλάζετε εξαρτήματα στο μηχάνημα σας μέχρι να βρείτε αυτό που είναι υπαίτιο.

==== Μπορώ να διαγράψω το /usr/obj όταν τελειώσω;

Η σύντομη απάντηση είναι ναι.

Το [.filename]#/usr/obj# περιέχει όλα τα αντικειμενικά αρχεία που παράγονται κατά τη διάρκεια της μεταγλώττισης. Συνήθως, ένα από τα πρώτα βήματα στην διαδικασία `make buildworld` είναι η διαγραφή αυτού του καταλόγου και η αναδημιουργία του. Στην περίπτωση αυτή, το να κρατήσετε τον κατάλογο [.filename]#/usr/obj# αφού έχετε τελειώσει, δεν έχει και πολύ νόημα, ενώ αν τον σβήσετε θα κερδίσετε ένα μεγάλο κομμάτι ελεύθερου χώρου (την παρούσα στιγμή περίπου 2 GB).

Όμως, αν ξέρετε τι κάνετε, μπορείτε να οδηγήσετε το `make buildworld` να παραλείψει αυτό το βήμα. Αυτό θα επιταχύνει ιδιαίτερα τις νέες μεταγλωττίσεις, καθώς τα περισσότερα τμήματα του πηγαίου κώδικα δεν θα χρειάζονται ξανά μεταγλώττιση. Το μειονέκτημα είναι ότι ορισμένες φορές εμφανίζονται προβλήματα που έχουν σχέση με όχι και τόσο εμφανείς εξαρτήσεις, και μπορεί να οδηγήσουν σε μυστηριώδη αποτυχία της μεταγλώττισης. Τέτοια προβλήματα συχνά δημιουργούν "θόρυβο" στις λίστες του FreeBSD, όταν κάποιος χρήστης παραπονιέται ότι η μεταγλώττιση του αποτυγχάνει, χωρίς να αντιλαμβάνεται ότι αυτό οφείλεται στην προσπάθεια του να συντομεύσει την διαδικασία.

==== Μπορώ να συνεχίσω μια μεταγλώττιση που διέκοψα;

Αυτό εξαρτάται από το πόσο έχετε προχωρήσει στη διαδικασία μέχρι τη στιγμή που βρήκατε το πρόβλημα.

_Σε γενικές γραμμές_ (και αυτός δεν είναι κανόνας που ισχύει πάντα), η διεργασία του `make buildworld` μεταγλωττίζει νέα αντίγραφα βασικών εργαλείων (όπως τα man:gcc[1], και man:make[1]) καθώς και των βιβλιοθηκών συστήματος. Έπειτα εγκαθιστώνται αυτά τα εργαλεία και οι βιβλιοθήκες. Τα νέα εργαλεία και βιβλιοθήκες χρησιμοποιούνται έπειτα για να επαναμεταγλωττίσουν τους εαυτούς τους, και εγκαθίστανται ξανά. Ολόκληρο το σύστημα (το οποίο τώρα περιλαμβάνει και τα συνηθισμένα προγράμματα χρήστη όπως το man:ls[1] ή το man:grep[1]) επαναμεταγλωττίζεται χρησιμοποιώντας τα νέα αρχεία του συστήματος.

Αν βρίσκεστε στο τελευταίο στάδιο, το οποίο θα το γνωρίζετε κοιτάζοντας την έξοδο που έχετε αποθηκεύσει, είναι σχετικά ασφαλές να κάνετε:

[source,bash]
....
... fix the problem ...
# cd /usr/src
# make -DNO_CLEAN all
....

Με τον τρόπο αυτό δεν θα αναιρέσετε την εργασία που έχει γίνει από το προηγούμενο `make buildworld`.

Αν δείτε το μήνυμα:

[source,bash]
....
--------------------------------------------------------------
Building everything..
--------------------------------------------------------------
....

στην έξοδο της εντολής `make buildworld`, τότε είναι μάλλον ασφαλές να προχωρήσετε με αυτό τον τρόπο.

Αν δεν δείτε αυτό το μήνυμα, ή αν δεν είστε σίγουρος, τότε είναι καλύτερα να κάνετε πλήρη μεταγλώττιση παρά να μετανιώνετε αργότερα.

==== Πως μπορώ να επιταχύνω τη μεταγλώττιση του βασικού συστήματος;

* Εκτελέστε την σε κατάσταση ενός χρήστη.
* Βάλτε τους καταλόγους [.filename]#/usr/src# και [.filename]#/usr/obj# σε διαφορετικά συστήματα αρχείων τα οποία βρίσκονται και σε διαφορετικούς φυσικούς δίσκους. Αν είναι δυνατόν, βάλτε αυτούς τους δίσκους σε χωριστούς ελεγκτές.
* Ακόμα καλύτερα, μοιράστε αυτά τα συστήματα αρχείων σε πολλαπλούς δίσκους, χρησιμοποιώντας το πρόγραμμα οδήγησης man:ccd[4] (concatenated disk driver, οδήγησης συνενωμένων δίσκων).
* Απενεργοποιήστε το profiling (θέστε την μεταβλητή "NO_PROFILE=true" στο [.filename]#/etc/make.conf#). Είναι σχεδόν σίγουρο ότι δεν το χρειάζεστε.
* Στο αρχείο [.filename]#/etc/make.conf#, θέστε το `CFLAGS` σε κάτι όπως `-O -pipe`. Η βελτιστοποίηση `-O2` χρειάζεται αρκετά περισσότερο χρόνο, και η διαφορά απόδοσης μεταξύ `-O` και `-O2` είναι συνήθως αμελητέα. Το `-pipe` επιτρέπει στον μεταγλωττιστή να χρησιμοποιήσει pipes για επικοινωνία αντί για προσωρινά αρχεία. Αυτό καταναλώνει περισσότερη μνήμη, αλλά χρησιμοποιεί λιγότερο το σκληρό δίσκο.
* Χρησιμοποιήστε την επιλογή `-j__n__` στο man:make[1] ώστε να εκτελούνται παράλληλα πολλαπλές διεργασίες μεταγλώττισης. Αυτό συνήθως βοηθάει ακόμα και σε περίπτωση που έχετε μηχάνημα με ένα επεξεργαστή.
* Μπορείτε να προσαρτήσετε (ή να επαναπροσαρτήσετε) το σύστημα αρχείων στο οποίο είναι αποθηκευμένο το [.filename]#/usr/src# με την επιλογή `noatime`. Αυτό αποτρέπει την καταγραφή ημερομηνίας / ώρας πρόσβασης στο σύστημα αρχείων. Κατά πάσα πιθανότητα, δεν χρειάζεστε αυτή την πληροφορία έτσι και αλλιώς.
+
[source,bash]
....
# mount -u -o noatime /usr/src
....
+
[WARNING]
====

Το παράδειγμα προϋποθέτει ότι έχετε το [.filename]#/usr/src# στο δικό του σύστημα αρχείων. Αν αυτό δεν συμβαίνει (αν είναι μέρος του [.filename]#/usr# για παράδειγμα) θα χρειαστεί να χρησιμοποιήσετε αυτό το σημείο προσάρτησης, και όχι το [.filename]#/usr/src#.
====

* Μπορείτε να προσαρτήσετε (ή να επαναπροσαρτήσετε) το σύστημα αρχείων που περιέχει το [.filename]#/usr/obj# με την επιλογή `async`. Με τον τρόπο αυτό, οι εγγραφές στο δίσκο θα γίνονται ασύγχρονα. Με άλλα λόγια, οι εγγραφές φαίνεται ότι ολοκληρώνονται άμεσα, ενώ η πραγματική εγγραφή στο δίσκο γίνεται λίγα δευτερόλεπτα αργότερα. Αυτό επιτρέπει την ομαδοποίηση των εγγραφών, το οποίο μπορεί να προσφέρει δραματική βελτίωση απόδοσης.
+
[WARNING]
====

Να έχετε υπόψιν σας ότι αυτή η επιλογή μπορεί να κάνει το σύστημα αρχείων σας πολύ πιο ευαίσθητο. Με την επιλογή αυτή, υπάρχει αυξημένη πιθανότητα το σύστημα αρχείων να βρεθεί σε μη επισκευάσιμη κατάσταση αν υπάρξει διακοπή ρεύματος.

Αν το σύστημα αρχείων περιέχει μόνο το [.filename]#/usr/obj#, το παραπάνω δεν είναι πρόβλημα. Αν ωστόσο έχετε και άλλα πολύτιμα δεδομένα στο ίδιο σύστημα αρχείων, σιγουρευτείτε ότι έχετε ενημερωμένα αντίγραφα ασφαλείας πριν ενεργοποιήσετε αυτή την επιλογή.
====
+
[source,bash]
....
# mount -u -o async /usr/obj
....
+
[WARNING]
====

Όπως και προηγουμένως, αν το [.filename]#/usr/obj# δεν είναι σύστημα αρχείων από μόνο του, αντικαταστήστε το στο παράδειγμα με το όνομα του πραγματικού σημείου προσάρτησης.
====

==== Τι να κάνω αν κάτι πάει στραβά;

Σιγουρευτείτε ότι το περιβάλλον σας δεν έχει υπολείμματα από προηγούμενες μεταγλωττίσεις. Αυτό είναι αρκετά απλό.

[source,bash]
....
# chflags -R noschg /usr/obj/usr
# rm -rf /usr/obj/usr
# cd /usr/src
# make cleandir
# make cleandir
....

Ναι, θα πρέπει να εκτελέσετε το `make cleandir` δύο φορές.

Επανεκκινήστε έπειτα όλη τη διαδικασία, ξεκινώντας με το `make buildworld`.

Αν έχετε ακόμα προβλήματα, στείλτε το μήνυμα λάθους και την έξοδο του `uname -a` στην {freebsd-questions}. Να είστε προετοιμασμένοι να απαντήσετε επιπλέον ερωτήσεις σχετικά με την εγκατάσταση σας!

[[make-delete-old]]
== Διαγραφή Παρωχημένων Αρχείων, Καταλόγων και Βιβλιοθηκών

Κατά την συνεχή ανάπτυξη του FreeBSD είναι φυσιολογικό κάποια αρχεία κατά καιρούς να χαρακτηρίζονται ως παρωχημένα. Αυτό μπορεί να συμβεί αν οι λειτουργίες που παρείχαν υλοποιούνται πλέον διαφορετικά, αν ο ο αριθμός έκδοσης της βιβλιοθήκης έχει αλλάξει ή ακόμα και αν έχει διαγραφεί οριστικά από το σύστημα. Στα αρχεία αυτά περιλαμβάνονται επίσης βιβλιοθήκες κατάλογοι που πρέπει να διαγραφούν όταν γίνεται αναβάθμιση του συστήματος. Το όφελος για το χρήστη είναι ότι το σύστημα του δεν γεμίζει από παλιά αρχεία τα οποία καταλαμβάνουν άχρηστο χώρο στο μέσο αποθήκευσης και στο backup. Επιπρόσθετα, αν κάποια παλιά βιβλιοθήκη είχε προβλήματα σταθερότητας ή ασφάλειας θα πρέπει να την αναβαθμίσετε για να κρατήσετε το σύστημα σας σταθτερό και ασφαλές. Τα αρχεία, οι κατάλογοι και οι βιβλιοθήκες που θεωρούνται παρωχημένες φαίνονται στο [.filename]#/usr/src/ObsoleteFiles.inc#. Οι παρακάτω οδηγίες θα σας βοηθήσουν να διαγράψετε αυτά τα αρχεία κατά τη διαδικασία αναβάθμισης του συστήματος.

Υποθέτουμε ότι χρησιμοποιείτε τα βήματα που περιγράφονται στο <<canonical-build>>. Μετά την επιτυχή εκτέλση της εντολής `make installworld` και του `mergemaster` που ακολουθεί, θα πρέπει να ελέγξετε για παρωχημένα αρχεία και βιβλιοθήκες όπως φαίνεται παρακάτω:

[source,bash]
....
# cd /usr/src
# make check-old
....

Αν βρεθούν παρωχημένα αρχεία, μπορείτε να τα διαγράψετε με τις παρακάτω εντολές:

[source,bash]
....
# make delete-old
....

[TIP]
====

Δείτε το [.filename]#/usr/src/Makefile# για περισσότερες ενδιαφέρουσες επιλογές της `make`.
====

Για κάθε αρχείο που θα διαγραφεί, θα σας ζητηθεί να επιβεβαιώσετε την ενέργεια. Μπορείτε να παραλείψετε την ερώτηση και να αφήσετε το σύστημα να διαγράψει αυτά τα αρχεία αυτόματα χρησιμοποιώντας την μεταβλητή του make `BATCH_DELETE_OLD_FILES` με τον τρόπο που φαίνεται παρακάτω:

[source,bash]
....
# make -DBATCH_DELETE_OLD_FILES delete-old
....

[WARNING]
====
Η διαγραφή παρωχημένων αρχείων, θα προκαλέσει δυσλειτουργία των εφαρμογών που εξακολουθούν να βασίζονται σε αυτά. Αυτό συμβαίνει ιδιαίτερα σε παλιές βιβλιοθήκες. Στις περισσότερες περιπτώσεις, θα πρέπει να επαναμεταγλωττίσετε τα προγράμματα, ports ή βιβλιοθήκες που χρησιμοποιούσαν την παλιά βιβλιοθήκη πριν εκτελέσετε την εντολή `make delete-old-libs`.
====

Μπορείτε να βρείτε προγράμματα που ελέγχουν τις εξαρτήσεις των κοινόχρηστων βιβλιοθηκών στη Συλλογή των Ports, στο package:sysutils/libchk[] ή package:sysuilts/bsdadminscripts[].

Οι παρωχημένες κοινόχρηστες βιβλιοθήκες μπορούν να δημιουργήσουν προβλήματα λόγω συγκρούσεων με νεώτερες εκδόσεις. Σε αυτές τις περιπτώσεις, θα δείτει μηνύματα όπως τα παρακάτω:

[source,bash]
....
/usr/bin/ld: warning libz.so.4, needed by /usr/local/lib/libtiff.so, may conflict with libz.so.5
/usr/bin/ld: warning: librpcsvc.so.4, needed by /usr/local/lib/libXext.so may conflict with librpcsvc.so.5
....

Για να επιλύσετε τέτοιου είδους προβλήματα, βρείτε ποιο port εγκατέστησε την βιβλιοθήκη:

[source,bash]
....
# pkg_info -W /usr/local/lib/libtiff.so
/usr/local/lib/libtiff.so was installed by package tiff-3.9.4
# pkg_info -W /usr/local/lib/libXext.so
/usr/local/lib/libXext.so was installed by package libXext-1.1.1,1
....

Έπειτα, απεγκαταστήστε, επαναμεταγλωττίστε και επανεγκατασήστε το port. Για να αυτοματοποιήσετε αυτή τη διαδικασία μπορείτε να χρησιμοποιήσετε τα βοηθητικά προγράμματα package:ports-mgmt/portmaster[] και package:ports-mgmt/portupgrade[]. Αφού βεβαιωθείτε ότι οι παλιές βιβλιοθήκες δεν χρησιμοποιούνται πλέον από κανένα πρόγραμμα, μπορείτε να τις διαγράψετε με την παρακάτω εντολή:

[source,bash]
....
# make delete-old-libs
....

[[small-lan]]
== Διαδικασία για Πολλαπλά Μηχανήματα

Αν έχετε πολλαπλά μηχανήματα στα οποία πρόκειται να χρησιμοποιήσετε το ίδιο δέντρο πηγαίου κώδικα, είναι σπατάλη πόρων (δίσκου, δικτύου και επεξεργαστή) να επαναλαμβάνετε σε όλα τη διαδικασία ανάκτησης και μεταγλώττισης. Η λύση είναι να ορίσετε ένα μηχάνημα να εκτελεί το μεγαλύτερο μέρος της εργασίας, ενώ τα υπόλοιπα θα μπορούν να την ανακτούν μέσω NFS. Στην ενότητα αυτή θα παρουσιάσουμε ένα τρόπο με τον οποίο μπορεί να γίνει αυτό.

[[small-lan-preliminaries]]
=== Προκαταρκτικά

Πρώτα από όλα, αναγνωρίστε το σετ των μηχανημάτων στα οποία σκοπεύετε να χρησιμοποιήσετε τα ίδια εκτελέσιμα. Θα ονομάσουμε αυτή την ομάδα _σετ μεταγλώττισης_. Κάθε μηχάνημα μπορεί να έχει δικό του προσαρμοσμένο πυρήνα, αλλά θα έχουν όλα τα ίδια εκτελέσιμα userland. Από το σετ αυτό, επιλέξτε ένα μηχάνημα το οποίο θα γίνει το _μηχάνημα μεταγλώττισης_. Θα είναι το μηχάνημα στο οποίο θα μεταγλωττίζεται το βασικό σύστημα και ο πυρήνας. Το ιδανικό είναι να επιλέξετε ένα γρήγορο μηχάνημα, στο οποίο να υπάρχει αρκετός ελεύθερος χρόνος στον επεξεργαστή για να εκτελεί τα `make buildworld` και `make buildkernel`. Θα πρέπει επίσης να επιλέξετε ένα _μηχάνημα δοκιμών_ στο οποίο θα δοκιμάζετε τις ενημερώσεις λογισμικού πριν τις μεταφέρετε στην παραγωγή. Μπορεί να είναι και το ίδιο το μηχάνημα μεταγλώττισης, αλλά αυτό δεν είναι απαραίτητο.

Όλα τα μηχανήματα στο σετ μεταγλώττισης χρειάζεται να προσαρτήσουν το [.filename]#/usr/obj# και το [.filename]#/usr/src# από το ίδιο μηχάνημα, και στο ίδιο σημείο προσάρτησης. Το ιδανικό είναι αυτά τα δύο συστήματα αρχείων να βρίσκονται σε διαφορετικό φυσικό δίσκο στο μηχάνημα μεταγλώττισης, αλλά μπορείτε να τα προσαρτήσετε μέσω NFS ακόμα και σε αυτό το μηχάνημα. Αν έχετε πολλαπλά σετ μεταγλώττισης, το [.filename]#/usr/src# θα πρέπει να βρίσκεται σε ένα από τα μηχανήματα μεταγλώττισης, και να προσαρτάται στα υπόλοιπα μέσω NFS.

Τέλος, βεβαιωθείτε ότι τα αρχεία [.filename]#/etc/make.conf# και [.filename]#/etc/src.conf# σε όλα τα μηχανήματα του σετ μεταγλώττισης, είναι ίδια με τα αντίστοιχα στο μηχάνημα μεταγλώττισης. Αυτό σημαίνει ότι το μηχάνημα μεταγλώττισης θα πρέπει να μεταγλωττίζει όλα τα τμήματα του βασικού συστήματος τα οποία θα εγκατασταθούν σε κάθε μηχάνημα του σετ. Επίσης, σε κάθε μηχάνημα στο σετ μεταγλώττισης θα πρέπει να οριστεί το όνομα του δικού του προσαρμοσμένου πυρήνα μέσω της μεταβλητής `KERNCONF` στο [.filename]#/etc/make.conf#, ενώ και το μηχάνημα μεταγλώττισης θα πρέπει να έχει μια λίστα όλων των άλλων στο `KERNCONF`, ξεκινώντας από το δικό του. Το μηχάνημα μεταγλώττισης, θα πρέπει να έχει τα αρχεία ρύθμισης του πυρήνα όλων των άλλων μηχανημάτων στον κατάλογο [.filename]#/usr/src/sys/arch/conf# αν πρόκειται να μεταγλωττίζει τους πυρήνες τους.

[[small-lan-base-system]]
=== Το Βασικό Σύστημα

Έχοντας πραγματοποιήσει όλα τα παραπάνω, είστε έτοιμος να μεταγλωττίσετε τα πάντα. Μεταγλωττίστε τον πυρήνα και το βασικό σύστημα όπως περιγράψαμε στο <<make-buildworld>> χρησιμοποιώντας το μηχάνημα μεταγλώττισης, αλλά μην εγκαταστήσετε τίποτα. Μετά το τέλος της μεταγλώττισης, χρησιμοποιήστε το μηχάνημα δοκιμών και εγκαταστήστε τον πυρήνα που μόλις δημιουργήσατε. Αν το μηχάνημα αυτό προσαρτά το [.filename]#/usr/src# και το [.filename]#/usr/obj# μέσω NFS, όταν το επανεκκινήσετε σε κατάσταση ενός χρήστη, θα χρειαστεί να ενεργοποιήσετε το δίκτυο και να τα προσαρτήσετε. Ο ευκολότερος τρόπος για αυτό, είναι να εκκινήσετε σε κατάσταση πολλαπλών χρηστών και έπειτα να εκτελέσετε `shutdown now` για να μεταβείτε σε κατάσταση ενός χρήστη. Μόλις γίνει αυτό, μπορείτε να εγκαταστήσετε τον νέο πυρήνα και το βασικό σύστημα, και να εκτελέσετε το `mergemaster` όπως θα κάνατε συνήθως. Όταν τελειώσετε, επανεκκινήστε αυτό το μηχάνημα στην κανονική λειτουργία πολλαπλών χρηστών.

Όταν βεβαιωθείτε ότι όλα λειτουργούν σωστά στο μηχάνημα δοκιμών, χρησιμοποιήστε την ίδια διαδικασία για να εγκαταστήσετε το νέο λογισμικό σε κάθε ένα από τα υπόλοιπα μηχανήματα του σετ μεταγλώττισης.

[[small-lan-ports]]
=== Ports

Μπορείτε να χρησιμοποιήσετε τις ίδιες ιδέες και για το δέντρο των ports. Το πρώτο κρίσιμο βήμα είναι να προσαρτήσετε το [.filename]#/usr/ports# από το ίδιο μηχάνημα, σε όλα τα μηχανήματα του σετ μεταγλώττισης. Μπορείτε έπειτα να ρυθμίσετε το [.filename]#/etc/make.conf# ώστε να διαμοιράζονται τα distfiles. Θα πρέπει να θέσετε το `DISTDIR` σε ένα κοινόχρηστο κατάλογο, στον οποίο θα δώσετε δικαιώματα εγγραφής σε οποιοδήποτε χρήστη έχετε δηλώσει ως `root` στο NFS. Σε κάθε μηχάνημα θα πρέπει επίσης να οριστεί η μεταβλητή `WRKDIRPREFIX` ώστε να δείχνει σε ένα τοπικό κατάλογο. Τέλος, αν σκοπεύετε να μεταγλωττίζετε και να διανέμετε έτοιμα πακέτα, θα πρέπει να θέσετε την μεταβλητή `PACKAGES` σε ένα κατάλογο, όπως κάνατε και με την `DISTDIR`.
