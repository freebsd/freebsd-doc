---
title: Бүлэг 21. Файлын системийн дэмжлэг
part: хэсэг III. Системийн Удирдлага
prev: books/handbook/geom
next: books/handbook/vinum
showBookMenu: true
weight: 25
path: "/books/handbook/filesystems/"
---

[[filesystems]]
= Файлын системийн дэмжлэг
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 21
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/filesystems/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[filesystems-synopsis]]
== Ерөнхий агуулга

Файлын системүүд нь үйлдлийн системийн бүрэлдэхүүн хэсэг юм. Тэдгээр нь хэрэглэгчдэд файл хуулж хадгалах, өгөгдөлд хандах боломжийг бүрдүүлэх, тэгээд мэдээж хатуу хөтчүүдийг ашигтай болгодог. Өөр өөр үйлдлийн системүүд нь нийтлэг нэг гол үзэлтэй бөгөөд тэр нь тэдгээрийн эх файлын систем юм. FreeBSD дээр энэ файлын систем нь бас UFS гэгддэг эх Unix(TM) Файлын Систем дээр бүтээгдсэн Түргэн Файлын Систем буюу FFS юм. Энэ нь өгөгдөлд хандахад зориулж хатуу дискүүд дээр байрлуулагддаг FreeBSD дээрх эх файлын систем юм.

FreeBSD нь бас бусад үйлдлийн системийн өгөгдөлд өөр дээрээсээ өөрөөр хэлбэл холбогдсон USB хадгалалтын төхөөрөмжүүд, флэш хөтчүүд болон хатуу дискүүд дээр хадгалагдсан өгөгдөлд хандах боломжийг бүрдүүлэх зорилгоор төрөл бүрийн олон файлын системийг дэмждэг. Бас зарим эх бус файлын системүүдэд зориулсан дэмжлэг байдаг. Эдгээр нь Linux(R)-ийн Extended буюу Өргөтгөсөн Файлын Систем (EXT), болон Sun(TM)-ий Z Файлын Систем (ZFS) зэрэг өөр үйлдлийн системүүд дээр хөгжүүлэгдсэн файлын системүүд юм.

FreeBSD дээр төрөл бүрийн файлын системүүдэд зориулсан дэмжлэгийн янз бүрийн түвшингүүд байдаг. Зарим нь цөмийн модулийг дуудахыг шаарддаг бол зарим нь хэрэгслүүд суулгахыг шаардаж болох юм. Энэ бүлэг нь FreeBSD-ийн хэрэглэгчдэд өөрийн систем дээрээ Sun(TM)-ий Z файлын системээс эхлээд бусад файлын системүүдэд хандахад туслах зорилгоор хийгдсэн.

Энэ бүлгийг уншсаны дараа, та дараах зүйлсийг мэдэх болно:

* Эх болон дэмжигдсэн файлын системүүдийн ялгаа.
* FreeBSD дээр ямар файлын системүүд дэмжигдсэн талаар.
* Эх бус файлын системүүдийг хэрхэн идэвхжүүлж, тохируулж хандан ашиглах талаар.

Энэ бүлгийг уншихаасаа өмнө та дараах зүйлсийг гүйцэтгэх хэрэгтэй:

* UNIX(R) болон FreeBSD-ийн үндсүүдийг (crossref:basics[basics,Юниксийн үндэс]) ойлгох.
* Цөмийн тохиргоо/эмхэтгэлтийн (crossref:kernelconfig[kernelconfig,FreeBSD цөмийг тохируулах нь]) үндсийг мэддэг байх.
* FreeBSD дээр гуравдагчдын програм хангамжийг суулгаж (crossref:ports[ports,Програм суулгах. Багцууд болон портууд]) чаддаг байх.
* FreeBSD дээрх диск, хадгалалт болон төхөөрөмжийн нэрстэй танилцсан байх (crossref:disks[disks,Хадгалалт]).

[[filesystems-zfs]]
== Z Файлын Систем (ZFS)

Sun(TM)-ий хөгжүүлсэн Z файлын систем нь цөөрөм хэлбэрийн хадгалалтын аргыг ашиглахаар хийгдсэн шинэ технолог юм. Энэ нь зай зөвхөн өгөгдөл хадгалалтад хэрэгтэй нөхцөлд ашиглагдана гэсэн үг юм. Энэ нь өгөгдлийн хормын хувилбарууд, олон хуулбарууд, болон өгөгдлийн хяналтын нийлбэрийг дэмжин өгөгдлийн максимум бүрэн бүтэн байдалд зориулагдан бас хийгдсэн юм. RAID-Z гэгддэг өгөгдлийн шинэ хуулбарлах загвар нэмэгдсэн. RAID-Z загвар нь RAID5-тай төстэй боловч өгөгдлийн бичилтийн эвдрэлтээс хамгаалахаар хийгдсэн.

=== ZFS тааруулалт

ZFS дэд систем нь системийн эх үүсвэрүүдийн ихэнхийг хэрэглэгдэг учир өдөр тутмын хэрэглээнд максимум үр ашгийг хангахад шаардлагатай зарим нэг тааруулалт шаардлагатай байдаг. FreeBSD дээр туршилтын боломж гэгдэж байгаа боловч энэ нь ойрын ирээдүйд өөрчлөгдөж болох юм. Гэхдээ одоогоор дараах алхмуудыг зөвлөдөг.

==== Санах ой

Нийт системийн санах ой хамгийн багаа бодоход нэг гигабайт байх ёстой бөгөөд хоёр болон түүнээс дээшхийг зөвлөдөг. Энд байгаа бүх жишээнүүдэд систем нь нэг гигабайт санах ойтой, хэд хэдэн бусад тааруулах аргын хамтаар байх болно.

Зарим хүмүүс нэг гигабайт санах ойгоос бага санах ойг амжилттай ашиглаж чадсан боловч тийм хязгаарлагдмал физик санах ойтой систем ачаалал ихтэй үед FreeBSD нь санах ойн шавхалтаас болж үймэх нь маш боломжийн байх болно.

==== Цөмийн тохиргоо

Хэрэгцээгүй драйверууд болон тохиргоонуудыг цөмийн тохиргооны файлаас устгахыг зөвлөдөг. Ихэнх төхөөрөмжүүд модуль хэлбэрээр байдаг болохоор тэдгээрийг [.filename]#/boot/loader.conf# файлын тусламжтай дуудаж болно.

i386(TM) архитектурын хэрэглэгчид өөрсдийн цөмийн тохиргооны файлдаа дараах тохиргоог нэмж цөмөө дахин бүтээж дахин ачаалах хэрэгтэй:

[.programlisting]
....
options 	KVA_PAGES=512
....

Энэ тохиргоо нь `vm.kvm_size` тохируулгыг одоо байгаа 1 GB (PAE-ийн хувьд 2 GB) хязгаарыг давах боломжийг бүрдүүлж цөмийн хаягийн талбарыг өргөтгөх болно. Энэ тохиргооны хувьд хамгийн тохиромжтой утгыг олохын тулд мегабайтаар хүссэн хаягийн талбараа дөрөвт (4) хуваана. Энэ тохиолдолд 2 GB-ийн хувьд `512` байна.

==== Дуудагчийн тохируулгууд

[.filename]#kmem# хаягийн талбарыг FreeBSD-ийн бүх архитектур дээр ихэсгэх ёстой. Нэг гигабайт физик санах ойтой тест систем дээр [.filename]#/boot/loader.conf# файлд хийсэн дараах тохируулгууд болон системийг дахин ачаалсны дараа амжилттай болсон:

[.programlisting]
....
vm.kmem_size="330M"
vm.kmem_size_max="330M"
vfs.zfs.arc_max="40M"
vfs.zfs.vdev.cache.size="5M"
....

ZFS-тэй холбоотой тохируулгуудын талаар илүү дэлгэрэнгүй зөвлөмжүүдийн жагсаалтыг http://wiki.freebsd.org/ZFSTuningGuide[http://wiki.freebsd.org/ZFSTuningGuide] хаягаас үзнэ үү.

=== ZFS-г ашиглах нь

ZFS цөөрмүүдийг систем эхлэх үед холбох боломжийг FreeBSD-д олгох эхлүүлэх арга зам байдаг. Үүнийг тохируулахын тулд дараах тушаалуудыг ажиллуулна:

[source,shell]
....
# echo 'zfs_enable="YES"' >> /etc/rc.conf
# /etc/rc.d/zfs start
....

Энэ баримтын үлдсэн хэсэг 3 SCSI диск байна гэж үзэх бөгөөд тэдгээр төхөөрөмжийн нэрс нь [.filename]#da0#, [.filename]#da1# болон [.filename]#da2# юм. IDE тоног төхөөрөмжийн хэрэглэгчид SCSI-ийн оронд [.filename]#ad# төхөөрөмжүүдийг ашигладаг.

==== Ганц дискийн цөөрөм

Ганц дискийн төхөөрөмж ашиглан энгийн, нөөцгүй ZFS цөөрөм үүсгэхийн тулд `zpool` тушаалыг ашиглана:

[source,shell]
....
# zpool create example /dev/da0
....

Шинэ цөөрмийг харахын тулд `df` тушаалын гаралтыг үзнэ:

[source,shell]
....
# df
Filesystem  1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a   2026030  235230  1628718    13%    /
devfs               1       1        0   100%    /dev
/dev/ad0s1d  54098308 1032846 48737598     2%    /usr
example      17547136       0 17547136     0%    /example
....

Энэ гаралт нь `example` цөөрөм зөвхөн үүсгэгдээд зогсохгүй бас _холбогдсон_ гэдгийг тодорхой харуулж байна. Энэ нь энгийн файлын систем шиг хандах боломжтой, үүн дээр файлууд үүсгэж хэрэглэгчид дараах жишээн дээрх шиг үзэх боломжтой байна:

[source,shell]
....
# cd /example
# ls
# touch testfile
# ls -al
total 4
drwxr-xr-x   2 root  wheel    3 Aug 29 23:15 .
drwxr-xr-x  21 root  wheel  512 Aug 29 23:12 ..
-rw-r--r--   1 root  wheel    0 Aug 29 23:15 testfile
....

Харамсалтай нь энэ цөөрөм ZFS-ийн боломжуудын давуу талыг ашиглахгүй байна. Файлын системийг энэ цөөрөм дээр үүсгэж түүн дээр шахалтыг идэвхжүүлнэ:

[source,shell]
....
# zfs create example/compressed
# zfs set compression=gzip example/compressed
....

`example/compressed` нь одоо ZFS шахагдсан файлын систем боллоо. Зарим нэг том файлуудыг [.filename]#/example/compressed# хуулан түүн рүү хуулж үз.

Шахалтыг дараах тушаалаар болиулж болно:

[source,shell]
....
# zfs set compression=off example/compressed
....

Файлын системийг салгахын тулд дараах тушаалыг ажиллуулж `df` хэрэгслээр шалгана:

[source,shell]
....
# zfs umount example/compressed
# df
Filesystem  1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a   2026030  235232  1628716    13%    /
devfs               1       1        0   100%    /dev
/dev/ad0s1d  54098308 1032864 48737580     2%    /usr
example      17547008       0 17547008     0%    /example
....

Файлын системийг дахин холбож дахин хандах боломжтой болгоод `df` тушаалаар шалгана:

[source,shell]
....
# zfs mount example/compressed
# df
Filesystem         1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a          2026030  235234  1628714    13%    /
devfs                      1       1        0   100%    /dev
/dev/ad0s1d         54098308 1032864 48737580     2%    /usr
example             17547008       0 17547008     0%    /example
example/compressed  17547008       0 17547008     0%    /example/compressed
....

Цөөрөм болон файлын системийг `mount` тушаалын гаралтыг шалган бас ажиглаж болно:

[source,shell]
....
# mount
/dev/ad0s1a on / (ufs, local)
devfs on /dev (devfs, local)
/dev/ad0s1d on /usr (ufs, local, soft-updates)
example on /example (zfs, local)
example/data on /example/data (zfs, local)
example/compressed on /example/compressed (zfs, local)
....

Ажигласнаар ZFS файлын системүүд нь үүсгэгдсэнийхээ дараагаар жирийн файлын системүүд шигээр ашиглагдаж болно, гэхдээ өөр бусад олон боломжууд бас байдаг. Дараах жишээн дээр шинэ файлын систем `data` үүсгэгдэж байна. Чухал файлууд энд хадгалагдах учир файлын систем нь өгөгдлийн блок бүрийн хоёр хуулбарыг хадгалахаар тохируулагдсан:

[source,shell]
....
# zfs create example/data
# zfs set copies=2 example/data
....

Одоо `df`-г дахин ажиллуулж өгөгдөл болон зайн хэрэглээг харах боломжтой:

[source,shell]
....
# df
Filesystem         1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a          2026030  235234  1628714    13%    /
devfs                      1       1        0   100%    /dev
/dev/ad0s1d         54098308 1032864 48737580     2%    /usr
example             17547008       0 17547008     0%    /example
example/compressed  17547008       0 17547008     0%    /example/compressed
example/data        17547008       0 17547008     0%    /example/data
....

Цөөрөм дээрх файлын систем бүр ижил хэмжээтэй зайтай байгааг хараарай. Файлын системүүд нь зөвхөн хэрэгцээтэй зайгаа ашиглаж ижил цөөрмөөс авч байгааг харуулахын тулд `df` тушаалыг энэ жишээнүүд дээр ашигласан шалтгаантай юм. ZFS файлын систем нь эзлэхүүн болон хуваалтууд гэх мэт ойлголтуудаас ангид байж хэд хэдэн файлын систем нэг цөөрмийг эзлэхийг зөвшөөрдөг. Файлын системүүдийг устгаад дараа нь цөөрмийг хэрэгцээгүй болсон болохоор устгана:

[source,shell]
....
# zfs destroy example/compressed
# zfs destroy example/data
# zpool destroy example
....

Дискүүд муудаж эвдрэх нь тойрох боломжгүй нөхцөл юм. Энэ диск муудсан үед өгөгдөл алдагдах болно. Эвдэрсэн хатуу дискээс болоод өгөгдлийн алдагдлаас хамгаалах нэг арга нь RAID-г ашиглах явдал юм. ZFS нь энэ боломжийг дараагийн хэсэгт тайлбарлах өөрийн цөөрмийн дизайндаа дэмжсэн байдаг.

==== ZFS RAID-Z

Өмнө хэлсэнчлэн энэ хэсэг нь гурван SCSI диск байгаа гэж үзэх бөгөөд [.filename]#da0# [.filename]#da1# болон [.filename]#da2# (буюу эсвэл IDE диск ашиглагдаж байвал [.filename]#ad0# гэх мэтээр) байна. RAID-Z цөөрөм үүсгэхийн тулд дараах тушаалыг өгнө:

[source,shell]
....
# zpool create storage raidz da0 da1 da2
....

[NOTE]
====
Sun(TM)-ий зөвлөснөөр RAID-Z тохиргоонд ашиглагдах төхөөрөмжүүдийн тоо гурваас есийн хооронд байна. Хэрэв та 10 буюу түүнээс олон дискээс тогтсон ганц цөөрөм үүсгэхийг хүсэж байгаа бол түүнийг арай жижиг хэмжээтэй RAID-Z бүлгүүдэд хуваахыг бодох хэрэгтэй. Хэрэв танд зөвхөн хоёр диск байгаа бөгөөд нөөцтэй байхыг хүсэж байгаа бол ZFS толийг ашиглах хэрэгтэй. Дэлгэрэнгүйг man:zpool[8] гарын авлагын хуудаснаас үзнэ үү.
====

`storage` zpool үүсгэгдсэн байх ёстой. Өмнөх шиг man:mount[8] болон man:df[1] тушаалуудыг ашиглан үүнийг шалгаж болно. Дээрх жагсаалтын төгсгөлд өөр илүү дискийн төхөөрөмжүүдийг нэмэн хуваарилж болно. Хэрэглэгчийн файлууд удахгүй байрлах `home` гэгдсэн шинэ файлын системийг цөөрөмд хийнэ:

[source,shell]
....
# zfs create storage/home
....

Одоо шахалтыг идэвхжүүлж хэрэглэгчийн гэрийн сангууд болон файлуудын илүү хуулбаруудыг хадгалах боломжтой. Үүнийг өмнөх шиг дараах тушаалуудыг ашиглан хийж болно:

[source,shell]
....
# zfs set copies=2 storage/home
# zfs set compression=gzip storage/home
....

Үүнийг хэрэглэгчдийн шинэ гэрийн сан болгохын тулд хэрэглэгчийн өгөгдлийг энэ сан руу хуулж тохирох тэмдэгт холбоосуудыг үүсгэнэ:

[source,shell]
....
# cp -rp /home/* /storage/home
# rm -rf /home /usr/home
# ln -s /storage/home /home
# ln -s /storage/home /usr/home
....

Одоо хэрэглэгчдийн хувьд шинээр үүсгэгдсэн [.filename]#/storage/home# файлын систем дээр тэдний өгөгдөл хадгалагдсан байх болно. Шинэ хэрэглэгч нэмж тэр хэрэглэгчээр нэвтэрч үзээрэй.

Дараа нь буцааж болох хормын хувилбар үүсгэж үзээрэй:

[source,shell]
....
# zfs snapshot storage/home@08-30-08
....

Хормын хувилбар тохиргоо нь гэрийн сан ч биш эсвэл файл ч биш зөвхөн жинхэнэ файлын системийг авахыг анхаараарай. `@` тэмдэгт нь файлын системийн нэр эсвэл эзлэхүүний нэрийн хооронд ашиглагдсан зааглагч юм. Хэрэглэгчийн гэрийн сан устгагдах үед түүнийг доорх тушаалаар сэргээнэ:

[source,shell]
....
# zfs rollback storage/home@08-30-08
....

Байгаа хормын хувилбаруудын жагсаалтыг авахын тулд `ls`-г файлын системийн [.filename]#.zfs/snapshot# сан дотор ажиллуулна. Жишээ нь өмнө нь авсан хормын хувилбарыг харахын тулд дараах тушаалыг гүйцэтгэнэ:

[source,shell]
....
# ls /storage/home/.zfs/snapshot
....

Хэрэглэгчийн өгөгдөл дээр сар бүрийн хормын хувилбар үүсгэх скрипт бичих боломжтой боловч хожим хормын хувилбарууд нь ихээхэн хэмжээний дискийн хэмжээ эзлэх болно. Түрүүчийн хормын хувилбарыг дараах тушаал ашиглан устгаж болно:

[source,shell]
....
# zfs destroy storage/home@08-30-08
....

Энэ бүх тестийн дараагаар [.filename]#/storage/home# санг бид одоо байгаа төлөвт нь байлгаад байх шалтгаан байх ёсгүй юм. Үүнийг жинхэнэ [.filename]#/home# файлын систем болгох хэрэгтэй:

[source,shell]
....
# zfs set mountpoint=/home storage/home
....

`df` болон `mount` тушаалуудыг ажиллуулснаар систем бидний файлын системийг жинхэнэ [.filename]#/home# сан гэж үзэж байгааг харуулна:

[source,shell]
....
# mount
/dev/ad0s1a on / (ufs, local)
devfs on /dev (devfs, local)
/dev/ad0s1d on /usr (ufs, local, soft-updates)
storage on /storage (zfs, local)
storage/home on /home (zfs, local)
# df
Filesystem   1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a    2026030  235240  1628708    13%    /
devfs                1       1        0   100%    /dev
/dev/ad0s1d   54098308 1032826 48737618     2%    /usr
storage       26320512       0 26320512     0%    /storage
storage/home  26320512       0 26320512     0%    /home
....

Ингэснээр RAID-Z тохиргоо дуусаж байна. Шөнө бүрийн man:periodic[8] ажиллах үед үүссэн файлын системүүдийн талаар төлвийн шинэчлэлтүүдийг авахын тулд дараах тушаалыг ажиллуулна:

[source,shell]
....
# echo 'daily_status_zfs_enable="YES"' >> /etc/periodic.conf
....

==== RAID-Z-г сэргээх нь

Програм хангамжийн RAID бүр өөрсдийн `төлвийг` хянах аргатай байдаг. ZFS нь ч мөн адил. RAID-Z төхөөрөмжүүдийн төлвийг дараах тушаалаар харж болно:

[source,shell]
....
# zpool status -x
....

Хэрэв бүх цөөрмүүд эрүүл ба бүгд хэвийн бол дараах мэдэгдэл гарна:

[source,shell]
....
all pools are healthy
....

Хэрэв асуудал байвал магадгүй диск холболтгүй болчихвол цөөрмийн төлөв иймэрхүү харагдах болно:

[source,shell]
....
  pool: storage
 state: DEGRADED
status: One or more devices has been taken offline by the administrator.
	Sufficient replicas exist for the pool to continue functioning in a
	degraded state.
action: Online the device using 'zpool online' or replace the device with
	'zpool replace'.
 scrub: none requested
config:

	NAME        STATE     READ WRITE CKSUM
	storage     DEGRADED     0     0     0
	  raidz1    DEGRADED     0     0     0
	    da0     ONLINE       0     0     0
	    da1     OFFLINE      0     0     0
	    da2     ONLINE       0     0     0

errors: No known data errors
....

Энэ нь төхөөрөмжийг администратор салгасан гэдгийг харуулж байна. Ялангуяа энэ жишээний хувьд энэ нь үнэн юм. Дискийг салгахын тулд дараах тушаалыг ашиглажээ:

[source,shell]
....
# zpool offline storage da1
....

Одоо системийг унтраасны дараа [.filename]#da1#-г солих боломжтой. Систем буцаж ассаны дараа дараах тушаалыг ажиллуулж дискийг солино:

[source,shell]
....
# zpool replace storage da1
....

Эндээс төлвийг дахин шалгаж болох бөгөөд энэ удаад төлвийн мэдээллийг авахын тулд `-x` өгөгдөлгүйгээр үзнэ:

[source,shell]
....
# zpool status storage
 pool: storage
 state: ONLINE
 scrub: resilver completed with 0 errors on Sat Aug 30 19:44:11 2008
config:

	NAME        STATE     READ WRITE CKSUM
	storage     ONLINE       0     0     0
	  raidz1    ONLINE       0     0     0
	    da0     ONLINE       0     0     0
	    da1     ONLINE       0     0     0
	    da2     ONLINE       0     0     0

errors: No known data errors
....

Энэ жишээнээс харахад бүгд хэвийн харагдаж байна.

==== Өгөгдлийн шалгалт

Өмнө дурдсанчлан ZFS нь хадгалагдсан өгөгдлийн бүрэн бүтэн байдлыг шалгахдаа `хяналтын нийлбэрийг` ашигладаг. Тэдгээр нь файлын системүүдийг үүсгэхэд автоматаар идэвхждэг бөгөөд дараах тушаалыг ашиглан болиулж болно:

[source,shell]
....
# zfs set checksum=off storage/home
....

Энэ нь ухаалаг санаа биш боловч хяналтын нийлбэрүүд нь маш бага хадгалалтын зай эзэлдэг бөгөөд идэвжсэн байхдаа илүү ашигтай байдаг. Бас тэдгээрийг идэвхжүүлснээр мэдэгдэхээр зардал бас ажиглагддаггүй. Идэвхжсэн байх үед өгөгдлийн бүрэн бүтэн байдлыг хяналтын нийлбэрийн шалгалт ашиглан ZFS шалгах боломжтой байдаг. Энэ процессийг "цэвэрлэх" гэж хэлдэг. `storage` цөөрмийн өгөгдлийн бүрэн бүтэн байдлыг шалгахын тулд дараах тушаалыг ажиллуулна:

[source,shell]
....
# zpool scrub storage
....

Энэ процесс хадгалагдсан өгөгдлийн хэмжээнээс хамаарч ихээхэн хэмжээний хугацаа шаардаж болох юм. Энэ нь бас эдгээр үйлдлүүдийн зөвхөн нэг нь тухайн үед ажиллаж болохоор тийм ихээр I/O-г ашигладаг байна. Цэвэрлэлт дууссаны дараа төлөв шинэчлэгдэж төлвийн хүсэлтийг илгээн харж болно:

[source,shell]
....
# zpool status storage
 pool: storage
 state: ONLINE
 scrub: scrub completed with 0 errors on Sat Aug 30 19:57:37 2008
config:

	NAME        STATE     READ WRITE CKSUM
	storage     ONLINE       0     0     0
	  raidz1    ONLINE       0     0     0
	    da0     ONLINE       0     0     0
	    da1     ONLINE       0     0     0
	    da2     ONLINE       0     0     0

errors: No known data errors
....

Дууссан хугацаа энэ жишээн дээр цэврээр харуулагдаж байна. Энэ боломж нь өгөгдлийн бүрэн бүтэн байдлыг урт хугацааны турш хадгалахад баталгаа болж тусалдаг.

Z файлын системд зориулсан өөр олон тохиргоонууд байдаг бөгөөд man:zfs[8] болон man:zpool[8] гарын авлагын хуудсуудыг үзнэ үү.

==== ZFS квот

ZFS нь өөр төрлийн квотуудыг дэмждэг. Эдгээр нь ref квот, ердийн квот ба бүлгийн квот юм. Энэ хэсэг нь тус бүрийн талаар танилцуулах бөгөөд зарим нэг хэрэглээний заавруудыг оруулах болно.

Квот нь өгөгдөл болон түүнээс үүссэн бусад удмын хэрэглэх зайг хязгаарладаг бөгөөд эдгээр удмуудад зориулсан хормын хувилбарууд болон файлын системүүдийн хэрэглэдэг зайнд хязгаарлалт тавьж өгдөг. Хэрэглэгчийн хувьд квот нь тухайн хэрэглэгч ашиглаж болох зайг хязгаарлахад ашигтай байдаг.

[NOTE]
====
Квотыг эзлэхүүн дээр тавьж болдоггүй бөгөөд учир нь `volsize` шинж чанар нь далд квотыг илэрхийлдэг.
====

ref квот `refquota=size` нь ашиглах зайнд хатуу хязгаар тавин зайнд хязгаарладаг. Гэхдээ энэ хатуу хязгаар нь файлын системүүд эсвэл хормын хувилбарууд зэрэг өгөгдлийн удмуудын хэрэглэдэг зайнд хамааралгүй юм.

[.filename]#storage/home/bob#-д зориулж 10 GB ердийн квот тавихын тулд дараахийг ашиглана:

[source,shell]
....
# zfs set quota=10G storage/home/bob
....

Тухайн заагдсан хэрэглэгч ашиглаж болох зайг хэрэглэгчийн квот хязгаарлаж өгдөг. Ерөнхий бичих хэлбэр нь `userquota@user=size` байх бөгөөд хэрэглэгчийн нэр дараах хэлбэрийн аль нэг байх ёстой:

* POSIX нийцтэй нэр (жишээ нь _joe_).
* POSIX тоон ID (жишээ нь _789_).
* SID нэр (жишээ нь _joe.bloggs@example.com_).
* SID тоон ID (жишээ нь _S-1-123-456-789_).

Жишээ нь _joe_ хэрэглэгчийн хувьд 50 GB квот тавихын тулд дараахийг ашиглана:

[source,shell]
....
# zfs set userquota@joe=50G
....

Квотыг устгах эсвэл тавигдаагүй эсэхийг шалгахын тулд дараахийг хэрэглэнэ:

[source,shell]
....
# zfs set userquota@joe=none
....

Хэрэглэгчийн квотын шинж чанаруудыг `zfs get all` тушаал харуулдаггүй. `root` биш хэрэглэгчид `userquota` зөвшөөрөл өгөгдөөгүй л бол зөвхөн өөрийн квотуудыг харж болно. Энэ зөвшөөрөлтэй хэрэглэгчид бүгдийн квотыг харж тогтоох боломжтой байна.

Бүлгийн квот нь заагдсан хэрэглэгчийн бүлэг ашиглаж болох зайг хязгаарладаг. Ерөнхий бичиглэл нь `groupquota@group=size` байна.

_firstgroup_ бүлэгт 50 GB квот зааж өгөхийн тулд дараахийг ашиглана:

[source,shell]
....
# zfs set groupquota@firstgroup=50G
....

_firstgroup_ бүлгийн хувьд квотыг устгах эсвэл тавигдаагүй байгаа эсэхийг шалгахын тулд дараахийг хэрэглэнэ:

[source,shell]
....
# zfs set groupquota@firstgroup=none
....

Хэрэглэгчийн квот шинж чанарын хувьд `root` биш хэрэглэгчид зөвхөн өөрсдийн харьяалагддаг хэрэглэгчийн бүлэгтэй холбоотой квотуудыг харж чадна, гэхдээ `root` хэрэглэгч эсвэл `groupquota` зөвшөөрөл бүхий хэрэглэгч бүх бүлгийн хувьд квотыг харах болон тавих боломжтой байна.

`zfs userspace` дэд тушаал заагдсан файлын систем эсвэл хормын хувилбар дээр хэрэглэгч бүрийн ашиглаж байгаа зай болон квотын хамтаар харуулдаг. `zfs groupspace` дэд тушаал бүлгийн хувьд адилыг харуулна. Дэмжигдсэн боломжуудын талаар эсвэл тухайн нэг боломжийг зөвхөн харуулъя гэвэл man:zfs[1] гарын авлагын хуудсыг үзнэ үү.

Хэрэв танд хэрэгтэй зөвшөөрлүүд байгаа, аль эсвэл `root` хэрэглэгч бол [.filename]#storage/home/bob#-н хувьд квотыг харуулахын тулд дараахийг ашиглана:

[source,shell]
....
# zfs get quota storage/home/bob
....

==== ZFS захиалгууд

ZFS нь хоёр төрлийн зайн захиалгыг дэмждэг. Энэ хэсэг нь тус бүрийн талаар зарим нэг жишээ оролцуулан тайлбарлах болно.

`reservation` шинж чанар нь өгөгдөл болон түүний удамд хэрэгтэй хамгийн бага зайг захиалж нөөцлөх боломжийг бүрдүүлдэг. Энэ нь хэрэв 10 GB зай [.filename]#storage/home/bob# дээр тавигдсан бол дискийн зай бага болсон тохиолдолд уг өгөгдөлд хамгийн багадаа 10 GB зай нөөцлөгдсөн байна гэсэн үг юм. `refreservation` шинж чанар нь хормын хувилбарууд зэрэг удмуудыг хасаад зөвхөн уг өгөгдөлд хэрэгтэй хамгийн бага зайг зааж өгөх юм уу тохируулж өгдөг. Жишээ нь [.filename]#storage/home/bob#-н хормын хувилбарыг авсан бол үйлдэл амжилттай болохын тулд `refreservation` хэмжээнээс гадна хангалттай дискний зай байх ёстой, яагаад гэвэл гол өгөгдлийн удмууд нь `refreservation` хэмжээнд хамааралгүй бөгөөд өгөгдсөн зайнд баригдахгүй байна.

Аль ч төрлийн захиалгууд ихэнх тохиолдолд ашигтай байдаг бөгөөд жишээлбэл шинэ систем дээр дискний зайг хуваарилах тохиромжийг турших болон төлөвлөх, эсвэл системийг сэргээх үйл ажиллагаа болон файлуудад зориулсан хангалттай зай файлын системүүд дээр байгаа эсэхэд баттай байхын тулд ашиглаж болно.

`reservation` шинж чанарын ерөнхий бичиглэл нь `reservation=size` байх бөгөөд [.filename]#storage/home/bob#-д 10 GB зайг захиалахын тулд дараах тушаалыг ашиглана:

[source,shell]
....
# zfs set reservation=10G storage/home/bob
....

Захиалга хийгдээгүй аль эсвэл захиалгыг устгахын тулд дараахийг ашиглана:

[source,shell]
....
# zfs set reservation=none storage/home/bob
....

refreservation-г тохируулахад `refreservation=size` гэсэн ерөнхий бичиглэл ижил зарчмаар `refreservation` шинж чанарт үйлчилж болно.

Ямар нэг захиалга эсвэл [.filename]#storage/home/bob#-н хувьд захиалга байгаа эсэхийг шалгахдаа дараах тушаалуудын аль нэгийг ажиллуулаарай:

[source,shell]
....
# zfs get reservation storage/home/bob
# zfs get refreservation storage/home/bob
....

[[filesystems-linux]]
== Linux(R) файлын системүүд

Энэ хэсэг FreeBSD-н дэмждэг зарим нэг Linux(R) файлын системүүдийн талаар тайлбарлах болно.

=== Ext2FS

man:ext2fs[5] файлын системийн цөмийн шийдлийг Годмар Бэк бичсэн бөгөөд драйвер нь анх FreeBSD 2.2 дээр гарч ирсэн. FreeBSD 8 ба түүнээс өмнөх хувилбарууд дээр GNU нийтийн лицензийн доор байдаг бөгөөд харин FreeBSD 9 дээр код бичигдсэн ба BSD лицензээр лицензлэгдсэн байгаа.

man:ext2fs[5] драйвер нь FreeBSD-н цөмд ext2 файлын систем рүү унших бичих боломжийг олгодог.

Эхлээд цөмийн дуудагдах модулийг ачаална:

[source,shell]
....
# kldload ext2fs
....

Дараа нь [.filename]#/dev/ad1s1#-д байрлах man:ext2fs[5] эзлэхүүнийг холбоно:

[source,shell]
....
# mount -t ext2fs /dev/ad1s1 /mnt
....

=== XFS

X файлын систем XFS-г анхлан IRIX-д зориулж SGI бичсэн бөгөөд Linux(R) руу порт хийгдсэн байдаг. Эх код нь GNU нийтийн лицензийн доор гарсан байдаг. Илүү дэлгэрэнгүйг http://oss.sgi.com/projects/xfs[энэ] хаягаас үзнэ үү. FreeBSD-н портыг Рассел Каттелан, {kan}, болон {rodrigc} нар эхлүүлсэн.

XFS-г цөмийн дуудагдах модуль хэлбэрээр ачаалахын тулд:

[source,shell]
....
# kldload xfs
....

man:xfs[5] драйвер нь FreeBSD-д XFS файлын систем рүү хандах боломжийг олгодог. Гэхдээ одоогоор зөвхөн унших хандалтыг дэмжсэн байгаа. Эзлэхүүн рүү бичих боломж байхгүй.

[.filename]#/dev/ad1s1#-д байрлах man:xfs[5] эзлэхүүнийг холбохын тулд дараахийг хийнэ:

[source,shell]
....
# mount -t xfs /dev/ad1s1 /mnt
....

package:sysutils/xfsprogs[] порт нь XFS файлын системийг үүсгэх боломжийг бүрдүүлэх `mkfs.xfs` хэрэгсэл болон бусад анализ хийж засах хэрэгслүүдээс тогддогийг мэдэхэд илүүдэхгүй юм.

`mkfs.xfs`-д `-p` сонголтыг зааж өгөн man:xfs[5] файлын системийг файлууд болон бусад мета өгөгдлүүдийн хамтаар үүсгэхэд хэрэглэж болно. Ийм замаар зөвхөн унших боложмтой файлын системийг хурдан үүсгэн FreeBSD дээр тест хийхэд хэрэглэж болно.

=== ReiserFS

Reiser файлын систем ReiseFS-г FreeBSD рүү {dumbbell} порт хийсэн бөгөөд GNU нийтийн лицензийн доор гарсан байдаг.

ReiserFS драйвер нь FreeBSD цөмд ReiserFS файлын системд хандах болон одоогоор зөвхөн түүн дээр байгаа агуулгыг унших (бичиж болохгүй) боломжийг олгодог.

Эхлээд цөмийн дуудагдах модулийг ачаалах хэрэгтэй:

[source,shell]
....
# kldload reiserfs
....

Дараа нь [.filename]#/dev/ad1s1#-д байгаа ReiserFS эзлэхүүнийг холбохын тулд:

[source,shell]
....
# mount -t reiserfs /dev/ad1s1 /mnt
....
