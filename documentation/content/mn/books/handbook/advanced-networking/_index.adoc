---
title: Бүлэг 32. Сүлжээний нэмэлт ойлголтууд
part: хэсэг IV. Сүлжээний Холболт
prev: books/handbook/firewalls
next: books/handbook/partv
---

[[advanced-networking]]
= Сүлжээний нэмэлт ойлголтууд
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:source-highlighter: rouge
:experimental:
:skip-front-matter:
:toc-title: Гарчиг
:table-caption: Хүснэгт
:figure-caption: Зураг
:example-caption: Жишээ
:xrefstyle: basic
:relfileprefix: ../
:outfilesuffix:
:sectnumoffset: 32

ifeval::["{backend}" == "html5"]
:imagesdir: ../../../../images/books/handbook/advanced-networking/
endif::[]

ifeval::["{backend}" == "pdf"]
:imagesdir: ../../../../static/images/books/handbook/advanced-networking/
endif::[]

ifeval::["{backend}" == "epub3"]
:imagesdir: ../../../../static/images/books/handbook/advanced-networking/
endif::[]

include::shared/authors.adoc[]
include::shared/releases.adoc[]
include::shared/mn/mailing-lists.adoc[]
include::shared/mn/teams.adoc[]
include::shared/mn/urls.adoc[]

toc::[]

[[advanced-networking-synopsis]]
== Ерөнхий агуулга

Энэ бүлэг нь хэд хэдэн сүлжээний дэвшилтэт нэмэлт сэдвүүдийг хамрах болно.

Энэ бүлгийг уншсаны дараа, та дараах зүйлсийг мэдэх болно:

* Гарцууд болон чиглүүлэлтүүдийн үндсүүд.
* IEEE(R) 802.11 болон Bluetooth(R) төхөөрөмжүүдийг хэрхэн суулгах талаар.
* FreeBSD-г гүүр болгож хэрхэн тохируулах талаар.
* Дискгүй машин дээр сүлжээгээр ачаалахыг хэрхэн тохируулах талаар.
* NFS root файлын систем ашиглан сүлжээгээр PXE ачаалалт хийхийг тохируулах талаар.
* Сүлжээний хаягийн хөрвүүлэлтийг хэрхэн тохируулах талаар.
* FreeBSD машин дээр IPv6-г хэрхэн тохируулах талаар.
* ATM-ийг хэрхэн тохируулах талаар.
* FreeBSD дээр Common Address Redundancy Protocol буюу CARP-ийн боломжуудыг хэрхэн идэвхжүүлж ашиглах талаар.

Энэ бүлгийг уншихаасаа өмнө та дараах зүйлсийг гүйцэтгэх хэрэгтэй:

* [.filename]#/etc/rc# скриптүүдийн үндсүүдийг ойлгосон байх.
* Сүлжээний үндсэн ухагдахуудын талаар мэдлэгтэй байх.
* Шинэ FreeBSD цөм хэрхэн тохируулж суулгах талаар мэдэх (crossref:kernelconfig[kernelconfig,FreeBSD цөмийг тохируулах нь]).
* Нэмэлт гуравдагч талуудын хийсэн програм хангамжийг хэрхэн суулгах талаар мэдэх (crossref:ports[ports,Програм суулгах. Багцууд болон портууд]).

[[network-routing]]
== Гарцууд болон Чиглүүлэлтүүд

Сүлжээгээр нэг машин нөгөө машиныг олж чаддаг байхын тулд нэгээс нөгөө уруу хэрхэн хүрэхийг тайлбарласан арга замууд байх ёстой. Үүнийг _routing_ буюу _чиглүүлэлт хийх_ гэдэг. "Чиглүүлэлт" нь "destination буюу зорьсон газар" болон "гарц" хаягийн хослолоор тодорхойлогддог. Хэрэв та энэ "зорьсон газар" уруу очихоор оролдож байгаа бол энэ "гарц"аар холбогдоно гэж энэ хослол нь зааж байгаа юм. Гурван төрлийн зорьсон газар байдаг: эдгээр нь хостууд, дэд сүлжээнүүд болон "анхдагч" юм. "Анхдагч чиглүүлэлт" нь аль ч чиглүүлэлтэд хамаарахгүй бол ашиглагддаг. Бид анхдагч чиглүүлэлтийн талаар дараа нь арай дэлгэрэнгүй ярилцах болно. Бас гурван төрлийн гарц байдаг: эдгээр нь хостууд, интерфэйсүүд (бас "links" буюу холбоосууд гэгддэг) болон Ethernet тоног төхөөрөмжийн хаягууд (MAC хаягууд) юм. 

=== Жишээ

Чиглүүлэлтийн өөр ойлголтуудыг үзүүлэхийн тулд бид `netstat`-ийн дараах жишээг ашиглах болно:

[source,bash]
....
% netstat -r
Routing tables

Destination      Gateway            Flags     Refs     Use     Netif Expire

default          outside-gw         UGSc       37      418      ppp0
localhost        localhost          UH          0      181       lo0
test0            0:e0:b5:36:cf:4f   UHLW        5    63288       ed0     77
10.20.30.255     link#1             UHLW        1     2421
example.com      link#1             UC          0        0
host1            0:e0:a8:37:8:1e    UHLW        3     4601       lo0
host2            0:e0:a8:37:8:1e    UHLW        0        5       lo0 =>
host2.example.com link#1             UC          0        0
224              link#1             UC          0        0
....

Эхний хоёр мөр нь анхдагч чиглүүлэлт (бид үүнийг <<network-routing-default,дараагийн хэсэг>>т авч үзэх болно) болон `localhost` чиглүүлэлтийг заана.

Энэ чиглүүлэлтийн хүснэгтийн заасан `localhost`-д зориулж ашиглах интерфэйс (`Netif` багана) нь [.filename]#lo0# бөгөөд энэ нь бас loopback буюу буцах интерфэйс гэгддэг. Энэ нь уг очих газрын хувьд бүх урсгалыг LAN уруу илгээхийн оронд дотооддоо үлдээнэ гэж хэлж байгаа бөгөөд энэ нь хаанаас эхэлсэн тэндээ буцаж очих учраас тэр юм.

Дараагийн байгаа зүйл бол `0:e0:`-с эхэлсэн хаягууд юм. Эдгээр нь Ethernet тоног төхөөрөмжийн хаягууд бөгөөд бас MAC хаягууд гэгддэг. FreeBSD нь локал Ethernet дээр байгаа ямар ч хостуудыг (жишээн дээрх `test0`) автоматаар таньж тэр хостод зориулж шууд түүн уруу [.filename]#ed0# Ethernet интерфэйсээр гарахаар чиглүүлэлт нэмдэг. Энэ төрлийн чиглүүлэлттэй холбоотой хугацаа (`Expire` багана) байдаг бөгөөд энэ нь заасан хугацаанд тэр хостоос бид нар юу ч сонсохгүй үед ашиглагддаг. Ийм явдал болоход энэ хост уруу заагдсан чиглүүлэлт автоматаар устгагдах болно. Эдгээр хостууд нь RIP (Routing Information Protocol буюу чиглүүлэлтийн мэдээллийн протокол) гэгддэг арга замаар танигддаг бөгөөд энэ нь хамгийн богино замыг тодорхойлсны үндсэн дээр локал хостууд уруу очих чиглүүлэлтийг олдог.

FreeBSD нь бас локал дэд сүлжээнд зориулж дэд сүлжээний чиглүүлэлтүүдийг нэмдэг (`10.20.30.255` нь `10.20.30` дэд сүлжээний цацах хаяг бөгөөд `example.com` нь тэр дэд сүлжээтэй холбоотой домэйний нэр юм). `link#1` тэмдэглэгээ нь машин дахь эхний Ethernet картыг заана. Та тэдгээрт зориулж ямар ч нэмэлт интерфэйс заагдаагүйг харах болно.

Эдгээр бүлгүүд (локал сүлжээний хостууд болон локал дэд сүлжээнүүд) нь автоматаар routed гэгддэг дэмоноор тохируулагдсан чиглүүлэлтүүдтэй байна. Хэрэв энэ нь ажиллахгүй байгаа бол зөвхөн статикаар тодорхойлогдсон (өөрөө хэлбэл илэрхий оруулж өгсөн) чиглүүлэлтүүд байх болно.

`host1` мөр нь бидний хостыг зааж байгаа бөгөөд түүнийг Ethernet хаягаар нь мэддэг. Бид илгээж байгаа хост болохоор FreeBSD нь Ethernet интерфэйсээр илгээхийн оронд loopback буюу буцах интерфэйсийг ([.filename]#lo0#) ашиглахаа мэддэг.

Хоёр `host2` мөрүүд нь биднийг man:ifconfig[8] alias буюу өөр нэр ашиглах үед (Ethernet-ийн талаар дурдсан хэсгээс бид үүнийг яагаад хийдгийг үзээрэй) учирч болзошгүй зүйлийн жишээ юм. [.filename]#lo0# интерфэйсийн дараа байгаа `=>` тэмдэг нь бид зөвхөн loopback буюу буцах интерфэйсийг ашиглаад зогсохгүй (энэ хаяг нь бас локал хостыг хэлж байгаа болохоор) энэ нь ялангуяа alias буюу өөр нэр гэдгийг хэлж байгаа юм. Ийм чиглүүлэлтүүд нь alias-ийг дэмждэг хост дээр зөвхөн харагдана; локал сүлжээн дэх бусад бүх хостууд ийм чиглүүлэлтүүдийнхээ хувьд ердөө л `link#1` мөртэй байна.

Төгсгөлийн мөр (очих дэд сүлжээ `224`) нь multicast-тай ажиллаж байгаа бөгөөд үүнийг өөр хэсэгт авч үзэх болно.

Төгсгөлд нь чиглүүлэлт бүрийн төрөл бүрийн шинж чанаруудыг `Flags` баганаас харж болно. Эдгээр тугуудын зарим болон тэдгээрийн харгалзах утга санаануудыг доорх богино хүснэгтээр харуулав:

[.informaltable]
[cols="1,1", frame="none"]
|===

|U
|Up: Чиглүүлэлт идэвхтэй байна.

|H
|Host: Чиглүүлэлтийн очих газар нь ганц хост байна.

|G
|Gateway: Энэ очих газарт зориулж бүгдийг энэ алсын систем уруу илгээх бөгөөд алсын систем нь тэндээсээ хаашаа илгээхээ олох болно.

|S
|Static: Энэ чиглүүлэлт нь системээр автоматаар үүсгэгдсэн биш гараар тохируулагдсан.

|C
|Clone: Бидний холбогдож байгаа машины хувьд энэ чиглүүлэлт дээр үндэслэн шинэ чиглүүлэлт үүсгэдэг. Энэ төрлийн чиглүүлэлт нь ихэвчлэн локал сүлжээнүүдэд ашиглагддаг.

|W
|WasCloned: Локал сүлжээний (Clone) чиглүүлэлт дээр үндэслэн автоматаар тохируулагдсан чиглүүлэлтийг заана.

|L
|Link: Чиглүүлэлт нь Ethernet тоног төхөөрөмжтэй холбоотой зүйлийг хамарна.
|===

[[network-routing-default]]
=== Анхдагч чиглүүлэлтүүд

Локал систем нь алсын хост уруу холболт хийх хэрэгтэй үед мэдэгдэж байгаа зам байгаа эсэхийг тодорхойлохын тулд энэ нь чиглүүлэлтийн хүснэгтээс шалгадаг. Хэрэв алсын хост нь бидний хэрхэн хүрэхийг нь мэдэх (клон хийгдсэн чиглүүлэлтүүд) дэд сүлжээнд байгаа бол систем тэр интерфэйсээр холбогдож болох эсэхийг шалгадаг.

Хэрэв бүх мэдэгдэж байгаа зам амжилтгүй болвол системд сүүлчийн ганц сонголт "анхдагч" чиглүүлэлт үлдэнэ. Энэ чиглүүлэлт нь гарц чиглүүлэлтийн тусгай төрөл (системд ихэвчлэн ганц байдаг) бөгөөд тугнуудын талбартаа үргэлж `c` гэж тэмдэглэгдсэн байдаг. Локал сүлжээн дэх хостын хувьд энэ гарц нь машины гадаад ертөнц уруу шууд холбогдох зүйлээр (PPP холболт, DSL, кабель модем, T1, эсвэл өөр сүлжээний интерфэйсээр) тохируулагддаг.

Хэрэв та өөрөө гаднах ертөнц уруу гарц маягаар ажиллаж байгаа машины хувьд анхдагч чиглүүлэлтийг тохируулж байгаа бол анхдагч чиглүүлэлт нь таны Интернэтийн Үйлчилгээ Үзүүлэгчийн (ISP) сайт дахь гарц машин болох юм.

Анхдагч чиглүүлэлтүүдийн жишээг харцгаая. Энэ нь нийтлэг тохиргоо юм:

image::net-routing.png[]

`Local1` болон `Local2` хостууд нь таны сайтад байна. `Local1` нь ISP уруу dial-up PPP холболтоор холбогдсон. Энэ PPP сервер компьютер нь дотоод сүлжээгээр өөр нэг гарц компьютер уруу гадаад интерфэйсээр ISP-ийн Интернэт өгч байгаа уруу холбогдсон байна.

Таны машин бүрийн хувьд анхдагч чиглүүлэлтүүд нь ийм болно:

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Хост
| Анхдагч Гарц
| Интерфэйс

|Local2
|Local1
|Ethernet

|Local1
|T1-GW
|PPP
|===

Түгээмэл асуулт нь "Бид яагаад `Local1`-ийн хувьд түүний холбогдсон ISP-ийн серверийн оронд `T1-GW`-г анхдагч гарц гэж тохируулсан бэ?" гэсэн асуулт юм.

PPP интерфэйс нь өөрийн талын холболтондоо ISP-ийн локал сүлжээн дэх хаягийг ашиглаж байгаа болохоор ISP-ийн локал сүлжээн дэх бусад дурын машинуудад зориулсан чиглүүлэлт автоматаар үүсгэгдэх болно гэдгийг санаарай. Ийм учраас та `T1-GW` машин уруу хэрхэн хүрэхээ аль хэдийн мэдэж байгаа болохоор ISP-ийн сервер уруу урсгал илгээх дундын алхам шаардлагагүй юм.

Өөрийн локал сүлжээний хувьд `X.X.X.1` хаягийг гарц хаяг болгож ашиглах нь түгээмэл байдаг. Тэгэхээр (адил жишээг ашиглаад) хэрэв таны локал C ангиллын хаягийн талбар `10.20.30` байсан бөгөөд таны ISP `10.9.9`-г ашиглаж байгаа бол анхдагч чиглүүлэлтүүд нь ийм байна:

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Хост
| Анхдагч Чиглүүлэлт

|Local2 (10.20.30.2)
|Local1 (10.20.30.1)

|Local1 (10.20.30.1, 10.9.9.30)
|T1-GW (10.9.9.1)
|===

Та [.filename]#/etc/rc.conf# файлын тусламжтай анхдагч чиглүүлэлтийг хялбараар тодорхойлж болно. Бидний жишээн дээр `Local2` машин дээр бид дараах мөрийг [.filename]#/etc/rc.conf# файлд нэмсэн:

[.programlisting]
....
defaultrouter="10.20.30.1"
....

Үүнийг шууд тушаалын мөрөөс man:route[8] тушаалаар хийж бас болно:

[source,bash]
....
# route add default 10.20.30.1
....

Сүлжээний чиглүүлэлтийн хүснэгтүүдийг гараар удирдах талаар дэлгэрэнгүй мэдээллийг man:route[8] гарын авлагын хуудаснаас лавлана уу.

=== Хос гэртэй хостууд

Өөр бас нэг тохиргооны төрлийг бид хэлэлцэх ёстой бөгөөд энэ нь хоёр өөр сүлжээн дээр байгаа хостын тухай юм. Техникийн хувьд гарц болж байгаа дурын машин (дээрх жишээн дээр PPP холболтыг ашиглах нь) хос гэртэй хост гэж тооцогддог. Гэхдээ үнэндээ энэ ухагдахуун нь хоёр дотоод сүлжээнд байгаа машиныг хэлэхэд зөвхөн ашиглагддаг.

Нэг тохиолдолд машин нь хоёр Ethernet карттай бөгөөд карт бүр тусдаа дэд сүлжээний хаягтай байна. Өөрөөр, машин нь зөвхөн нэг Ethernet карттай бөгөөд man:ifconfig[8] alias хийлт буюу өөр нэрийг ашигладаг байж болно. Эхнийх нь физикийн хувьд тусдаа хоёр Ethernet сүлжээ ашиглагдаж байгаа үед хэрэглэгдэх бөгөөд сүүлийнх нь ганц физик сүлжээний сегмент байгаа боловч логикийн хувьд хоёр тусдаа дэд сүлжээнүүд байгаа үед хэрэглэгддэг.

Аль ч тохиолдолд энэ машин нь нөгөө дэд сүлжээ уруу хүрэх тодорхойлогдсон гарц (гаднаас ирэх чиглүүлэлт) гэдгийг дэд сүлжээ бүр мэддэг байхаар чиглүүлэлтийн хүснэгтүүд тохируулагддаг. Хоёр дэд сүлжээний хооронд чиглүүлэгч маягаар ажиллах машинтай энэ тохиргоо нь бид аль нэг тал уруу эсвэл хоёр талын хоёулангийн хувьд пакет шүүгч буюу галт хана дээр тулгуурласан аюулгүй байдлын шийдлийг хийх шаардлагатай үед ихэвчлэн хэрэглэгддэг.

Хоёр интерфэйсийн хооронд пакетуудыг дамжуулдаг байхаар энэ машиныг байлгахыг хэрэв та хүсвэл энэ боломжийг идэвхжүүлэхийг FreeBSD-д хэлэх хэрэгтэй. Үүнийг хэрхэн хийх талаар дэлгэрэнгүйг дараагийн хэсгээс үзнэ үү.

[[network-dedicated-router]]
=== Чиглүүлэгч бүтээх нь

Сүлжээний чиглүүлэгч нь ердөө л нэг интерфэйсээс нөгөө интерфэйс уруу пакетуудыг дамжуулдаг систем юм. Интернэтийн стандартууд болон сайн инженерчлэлийн туршлага нь үүнийг FreeBSD дээр анхдагчаар идэвхжүүлсэн байхаас FreeBSD төслийг сэргийлдэг. man:rc.conf[5] дахь дараах хувьсагчийг `YES` болгон өөрчилснөөр та энэ боломжийг идэвхжүүлж болно:

[.programlisting]
....
gateway_enable="YES"          # Set to YES if this host will be a gateway
....

Энэ тохируулга нь man:sysctl[8]-ийн хувьсагч `net.inet.ip.forwarding`-г `1` болгоно. Хэрэв та чиглүүлэлтийг түр зуур зогсоох хэрэгтэй бол үүнийг түр зуур `0` болгож тохируулж болно.

Урсгалыг хааш нь илгээхээ мэдэхийн тулд таны шинэ чиглүүлэгчид чиглүүлэлтүүд хэрэгтэй болно. Хэрэв таны сүлжээ хангалттай хялбар байх юм бол статик чиглүүлэлтүүд ашиглаж болно. FreeBSD нь стандарт BSD чиглүүлэлтийн дэмон man:routed[8] програмтай бас ирдэг. Энэ нь RIP (1 ба 2-р хувилбар) болон IRDP протоколуудыг дэмждэг. BGP v4, OSPF v2 болон бусад төвөгтэй чиглүүлэлтийн протоколуудын дэмжлэгийг package:net/zebra[] багц хангадаг. GateD(R) зэрэг арилжааны бүтээгдэхүүнүүд бас илүү төвөгтэй сүлжээний чиглүүлэлтийн шийдлүүдэд зориулагдсан байдаг.

[[network-static-routes]]
=== Статик чиглүүлэлтүүдийг тохируулах нь

==== Гар тохиргоо

Бид дараах сүлжээтэй байна гэж төсөөлье:

image::static-routes.png[]

Энэ тохиолдолд `RouterA` нь Интернэт уруу гарах чиглүүлэгч маягаар ажиллаж байгаа бидний FreeBSD машин байна. Энэ нь анхдагч чиглүүлэлтээ `10.0.0.1` гэж тохируулсан бөгөөд ингэснээр гаднах ертөнц уруу холбогдох боломжийг олгоно. Бид `RouterB` нь зөв тохируулагдсан бөгөөд хаа явах хэрэгцээтэй газраа хэрхэн хүрэхээ мэддэг гэж үзэх болно. (Энэ нь зураг дээр хялбар юм. Ердөө л `RouterB` дээр `192.168.1.1`-г гарц болгон анхдагч чиглүүлэлт нэмнэ.)

Хэрэв бид `RouterA`-ийн чиглүүлэлтийн хүснэгтийг харвал доор дурдсантай төстэйг харах болно:

[source,bash]
....
% netstat -nr
Routing tables

Internet:
Destination        Gateway            Flags    Refs      Use  Netif  Expire
default            10.0.0.1           UGS         0    49378    xl0
127.0.0.1          127.0.0.1          UH          0        6    lo0
10.0.0.0/24          link#1             UC          0        0    xl0
192.168.1.0/24       link#2             UC          0        0    xl1
....

Энэ үеийн чиглүүлэлтийн хүснэгттэй байхад `RouterA` нь бидний Internal Net 2 буюу дотоод сүлжээ 2 уруу хүрч чадахгүй байх болно. Энэ нь `192.168.2.0/24`-ийн хувьд чиглүүлэлтгүй байна. Үүнийг арилгах нэг арга нь гараар чиглүүлэлт нэмэх явдал юм. Дараах тушаал нь `RouterA`-ийн чиглүүлэлтийн хүснэгтэд `192.168.1.2`-г дараагийн зөрлөг (hop) болгон ашиглан Internal Net 2 сүлжээг нэмэх болно:

[source,bash]
....
# route add -net 192.168.2.0/24 192.168.1.2
....

Одоо `RouterA` нь `192.168.2.0/24` сүлжээн дэх дурын хост уруу хүрч чадна.

==== Байнгын тохиргоо

Дээрх жишээ нь ажиллаж байгаа систем дээр статик чиглүүлэлтийг тохируулахад төгс төгөлдөр юм. Гэхдээ нэг асуудал нь таны FreeBSD машин дахин ачаалахад чиглүүлэлтийн мэдээлэл үлдэхгүй байх явдал юм. Статик чиглүүлэлтийг байнга байлгахын тулд түүнийг [.filename]#/etc/rc.conf# файлд нэмнэ:

[.programlisting]
....
# Add Internal Net 2 as a static route
static_routes="internalnet2"
route_internalnet2="-net 192.168.2.0/24 192.168.1.2"
....

`static_routes` тохиргооны хувьсагч нь зайгаар тусгаарлагдсан үгнүүдийн жагсаалт юм. Үг бүр чиглүүлэлтийн нэрийг заана. Бидний жишээн дээр `static_routes` мөрөнд бид зөвхөн нэг үгтэй байна. Энэ нь _internalnet2_ юм. Бид дараа нь man:route[8] тушаалд өгөх бүх тохиргооны нэмэлт өгөгдлүүдийг `route_internalnet2` гэгдсэн тохиргооны хувьсагчийн хамтаар нэмнэ. Бидний жишээний хувьд бид ийм тушаал ашиглаж болно:

[source,bash]
....
# route add -net 192.168.2.0/24 192.168.1.2
....

тэгэхээр бидэнд `"-net 192.168.2.0/24 192.168.1.2"` хэрэгтэй.

Дээр дурдсанаар бид `static_routes` мөрөнд нэгээс илүү үгс оруулж болно. Энэ нь бидэнд олон статик чиглүүлэлтүүд үүсгэх боломжийг олгоно. Дараах мөрүүд нь `192.168.0.0/24` болон `192.168.1.0/24` сүлжээний хувьд статик чиглүүлэлтүүдийг санаандаа төсөөлсөн чиглүүлэгч дээрээ нэмж байгаа жишээг үзүүлж байна:

[.programlisting]
....
static_routes="net1 net2"
route_net1="-net 192.168.0.0/24 192.168.0.1"
route_net2="-net 192.168.1.0/24 192.168.1.1"
....

[[network-routing-propagation]]
=== Чиглүүлэлтийн тархалт

Бид гаднах ертөнц уруу чиглэсэн өөрсдийн чиглүүлэлтүүдийг хэрхэн тодорхойлох талаар ярилцсан боловч гаднах ертөнц хэрхэн биднийг олох талаар хэлэлцээгүй билээ.

Чиглүүлэлтийн хүснэгтүүдийг тухайн нэг хаягийн талбарын (бидний жишээн дээр C ангиллын дэд сүлжээ) бүх урсгал тэр сүлжээний тухайн нэг хост уруу илгээгдэж тэр нь пакетуудыг дотогшоо дамжуулдгаар тохируулж болно гэдгийг бид мэдэж байгаа билээ.

Та өөрийн сайтдаа заагдсан хаягийн талбарыг авах үед таны үйлчилгээ үзүүлэгч өөрсдийн чиглүүлэлтийн хүснэгтүүдийг таны дэд сүлжээнд зориулагдсан бүх урсгал таны PPP холбоосоор таны сайт уруу илгээгддэгээр тохируулах болно. Гэхдээ улс даяар байх бусад сайтууд таны ISP уруу илгээхээ яаж мэдэх вэ?

Бүх заагдсан хаягийн талбаруудыг хянаж Интернэтийн үндсэн сүлжээ уруу холбогдох холболтын цэгийг тодорхойлдог систем (тараагдсан DNS-ийн мэдээлэлтэй бараг адил) байдаг. "Backbone" буюу "гол нуруу (үндсэн сүлжээ)" нь улс даяар болон дэлхий даяар Интернэтийн урсгалыг зөөвөрлөж байдаг гол шугамнууд юм. Гол нуруу машин бүр мастер хүснэгтүүдийн хуулбартай байдаг бөгөөд эдгээр хүснэгтүүд нь тухайн нэг сүлжээнд зориулсан урсгалыг онцгой гол нуруу зөөвөрлөгч уруу чиглүүлж тэндээсээ доош бусад үйлчилгээ үзүүлэгчдээр дамжин таны сүлжээнд хүрдэг.

Үндсэн (гол нуруу) сайтууд уруу зарлаж тэдгээр нь таны сайтын хувьд холболтын цэг (буюу орох зам) гэж тодорхойлох нь таны үйлчилгээ үзүүлэгчийн үүрэг юм. Үүнийг чиглүүлэлтийн тархалт гэж нэрлэдэг.

[[network-routing-troubleshooting]]
=== Алдааг олж засварлах

Заримдаа чиглүүлэлтийн тархалт асуудалтай бөгөөд зарим нэгэн сайтууд өөр уруу чинь холбогдож чадахгүй байж болно. Чиглүүлэлт хаана ажиллахгүй болж байгааг олоход тус болох магадгүй хамгийн ашигтай тушаал нь man:traceroute[8] тушаал юм. Хэрэв та алсын машин уруу холбогдож чадахгүй юм шиг байвал (өөрөөр хэлбэл man:ping[8] амжилтгүй болвол) энэ нь бас адил ашигтай байдаг.

man:traceroute[8] тушаалыг таны холбогдохыг оролдож байгаа алсын хостын нэртэй ажиллуулдаг. Энэ нь гарц хостуудыг оролдлого хийж байгаа замын хамтаар харуулдаг бөгөөд эцсийн хост уруу хүрэх юм уу эсвэл холболтын асуудлаас болоод эцсийн хост уруугаа хүрэлгүйгээр ажиллаж дуусдаг.

Дэлгэрэнгүй мэдээллийг man:traceroute[8]-ийн гарын авлагын хуудаснаас үзнэ үү.

[[network-routing-multicast]]
=== Multicast чиглүүлэлт хийх

FreeBSD нь multicast програмууд болон multicast чиглүүлэлтийг угаасаа дэмждэг. Multicast програмууд нь FreeBSD-ийн ямар нэг тусгай тохиргоо шаарддаггүй; програмууд нь шууд л ажилладаг. Multicast чиглүүлэлт нь дэмжлэгийг цөмд эмхэтгэхийг шаарддаг:

[.programlisting]
....
options MROUTING
....

Мөн multicast чиглүүлэлтийн дэмон man:mrouted[8] нь туннелиуд болон DVMRP-г үүсгэхээр [.filename]#/etc/mrouted.conf# файлын тусламжтай тохируулагдсан байх ёстой. Multicast тохиргооны талаар дэлгэрэнгүй мэдээллийг man:mrouted[8]-ийн гарын авлагын хуудаснаас олж болно.

[NOTE]
====
man:mrouted[8] multicast чиглүүлэлтийн демон нь DVMRP multicast чиглүүлэлтийн протоколыг хэрэгжүүлдэг бөгөөд үүнийг ихэнх multicast суулгацуудад man:pim[4]-р ихэвчлэн сольсон байдаг. Холбогдох man:map-mbone[8] болон man:mrinfo[8] хэрэгслүүд нь FreeBSD-ийн портын цуглуулгад package:net/mrouted[] портод байгаа болно.
====

[[network-wireless]]
== Утасгүй сүлжээ

=== Утасгүй сүлжээний үндсүүд

Ихэнх утасгүй сүлжээнүүд нь IEEE(R) 802.11-ийн стандартууд дээр үндэслэсэн байдаг. Үндсэн утасгүй сүлжээ нь 2.4GHz юм уу эсвэл 5GHz-ийн зурваст цацдаг радио долгионоор холбогддог олон станцуудаас тогтдог (энэ нь орон нутгаас хамаарч өөр өөр байдаг бөгөөд 2.3GHz-с 4.9GHz-ийн хүрээнд холбоог идэвхжүүлэхээр өөрчлөгдөж байгаа).

802.11 сүлжээ нь хоёр аргаар зохион байгуулагддаг: __дэд бүтцийн горим__д нэг станц мастер маягаар ажиллаж бусад станцууд нь түүнтэй холбогддог; энэ сүлжээг BSS гэдэг бөгөөд мастер станц нь хандалтын цэг (access point)(AP) гэгддэг. BSS-т бүх холбоо AP-р дамждаг; нэг станц өөр нэг утасгүй станцтай холбоо тогтоохыг хүссэн байсан ч гэсэн мэдэгдлүүд нь AP-р дамжих ёстой байдаг. Хоёр дахь хэлбэрийн сүлжээнд мастер байдаггүй бөгөөд станцууд нь шууд холбогддог. Энэ сүлжээний хэлбэрийг IBSS гэдэг бөгөөд бас _ad-hoc сүлжээ_ гэгддэг.

802.11 сүлжээнүүд нь 2.4GHz-ийн зурваст IEEE(R) 802.11 болон 802.11b стандартуудаар тодорхойлогдсон протоколуудыг ашиглан эхлэн хийгдэж байсан. Эдгээр тодорхойлолтууд нь ажиллах давтамжууд, хүрээ хийх болон дамжуулах хурд (холболт төрөл бүрийн хурдаар хийгдэж болно) зэрэг MAC давхаргын үзүүлэлтүүдийг агуулдаг. Сүүлд 802.11a стандарт нь өөр дохионы арга замууд болон илүү өндөр дамжуулах хурдууд зэрэг 5GHz-ийн зурвасын ажиллагааг тодорхойлсон билээ. Мөн дараа нь 802.11b сүлжээнүүдтэй буцаж нийцтэй байхаар 802.11a дохионы хэрэглээ болон 2.4GHz-ийн зурваст дамжуулах арга замуудыг идэвхжүүлж 802.11g стандарт тодорхойлогдсон байна.

Суурь болсон дамжуулах техникүүдээс гадна 802.11 сүлжээнүүд нь төрөл бүрийн аюулгүй байдлын арга замуудтай байдаг. Анхдагч 802.11 тодорхойлолтууд нь WEP гэгддэг аюулгүй байдлын энгийн протоколыг тодорхойлсон билээ. Энэ протокол нь тогтмол, урьдчилан хуваалцсан түлхүүр болон RC4 криптограф шифр ашиглан сүлжээнд дамжуулагдах өгөгдлийг кодчилдог. Станцууд нь өөр хоорондоо холбогдохын тулд бүгд нэг тогтмол түлхүүр дээр зөвшилцөх ёстой. Энэ схемийг амархан эвдэх боломжтойг харуулсан бөгөөд дамжин өнгөрөх хэрэглэгчдийг сүлжээнд нэгдэхийг зөвлөдөггүйгээс бусад тохиолдолд одоо ховор ашиглагдах болсон байна. Криптографийн шинэ шифрүүд болон станцуудыг хандалтын цэгт танин нэвтрүүлж өгөгдлийн холболтыг хийхийн тулд түлхүүрүүдийг солилцох нэмэлт протоколыг тодорхойлдог IEEE(R) 802.11i тодорхойлолтоор одоогийн аюулгүй байдлын практикийг тодорхойлдог. Мөн криптограф түлхүүрүүд нь үе үе шинэчлэгддэг бөгөөд халдлагын оролдлогуудыг илрүүлэх (ба халдлагын оролдлогуудыг сөрөх) арга замууд бас байдаг. Утасгүй сүлжээнүүдэд түгээмэл ашиглагддаг өөр нэг аюулгүй байдлын протоколын тодорхойлолт нь WPA юм. Энэ нь үйлдвэрлэлийн бүлгийн тодорхойлсон 802.11i-ийн өмнөх протокол бөгөөд 802.11i-г батлахыг хүлээж байх хугацаанд түр зуурын арга хэмжээ болох юм. WPA нь 802.11i-д байгаа шаардлагуудын дэд олонлогийг тодорхойлж хуучин тоног төхөөрөмжүүд дээрх шийдэлд зориулагдан хийгджээ. Ялангуяа WPA нь анхдагч WEP шифрээс гарсан TKIP шифрийг зөвхөн шаарддаг. 802.11i нь TKIP-ийн хэрэглээг зөвшөөрдөг боловч өгөгдлийг шифрлэхэд зориулж илүү хүчирхэг шифр болох AES-CCM-ийн дэмжлэгийг бас шаарддаг. (AES шифр нь WPA-д шаардагддаггүй, учир нь үүнийг хуучин тоног төхөөрөмж дээр хийхэд тооцооллын хувьд өртөгтэй гэж үздэг.)

Дээрх протоколын стандартуудаас гадна мэдэж байх өөр нэг чухал стандарт бол 802.11e юм. Энэ нь 802.11 сүлжээнд видео дамжуулах, IP дээгүүрх дуу (VoIP) зэрэг мультимедиа хэрэглээнүүдэд шаардлагатай протоколуудыг тодорхойлдог. 802.11i-тай адил 802.11e нь үйлдвэрлэлийн бүлгээс 802.11e-ийн дэд олонлог гэж тодорхойлсон, 802.11e-г батлахыг хүлээж байх хугацаанд мультимедиа хэрэглээнүүдийг идэвхжүүлэхэд ашиглаж болох WME (сүүлд WMM) гэгдсэн урьдчилсан тодорхойлолт байдаг. 802.11e болон WME/WMM-ийн талаар мэдэх ёстой хамгийн чухал зүйл нь утасгүй сүлжээний зэрэглэл тогтоогдсон урсгалын хэрэглээг Quality of Service (QoS) буюу үйлчилгээний чанарын протоколууд болон өргөтгөсөн зөөвөрлөгчийн хандалтын протоколуудын тусламжтайгаар идэвхжүүлдэг явдал юм. Эдгээр протоколуудын зөв шийдэл нь өгөгдлийн өндөр хурдтай тэсрэлт болон зэрэглэл тогтоогдсон урсгалыг идэвхжүүлдэг.

FreeBSD нь 802.11a, 802.11b, болон 802.11g-г ашиглан ажилладаг сүлжээнүүдийг дэмждэг. WPA болон 802.11i аюулгүй байдлын протоколууд нь адилхан (11a, 11b, болон 11g-тэй цуг) дэмжигдсэн байдаг бөгөөд WME/WMM протоколуудын шаарддаг QoS болон урсгалын зэрэглэлт нь хязгааргүй тооны утасгүй төхөөрөмжүүдэд дэмжигдсэн байдаг.

[[network-wireless-basic]]
=== Үндсэн тохируулга

==== Цөмийн тохиргоо

Утасгүй сүлжээг ашиглахын тулд танд утасгүй сүлжээний карт болон цөмийг тохирох утасгүй сүлжээний дэмжлэгтэйгээр тохируулах хэрэгтэй болно. Сүүлийнх нь олон модулиудад хуваагддаг. Тэгэхээр танд зөвхөн өөрийнхөө ашиглах програм хангамжийг тохируулах хэрэгтэй болох юм.

Танд эхлээд хэрэг болох зүйл нь утасгүй сүлжээний төхөөрөмж юм. Хамгийн түгээмэл хэрэглэгддэг төхөөрөмжүүд нь Atheros-ийн хийдэг хэсгүүдийг ашигладаг төхөөрөмжүүд байдаг. Эдгээр төхөөрөмжүүд нь man:ath[4] драйвераар дэмжигддэг бөгөөд [.filename]#/boot/loader.conf# файлд дараах мөрийг нэмэхийг шаарддаг:

[.programlisting]
....
if_ath_load="YES"
....

Atheros драйвер нь гурван тусдаа хэсэгт хуваагддаг: эдгээр нь зөв драйвер (man:ath[4]), бичил схемийн функцуудыг зохицуулдаг, тоног төхөөрөмжийн дэмжлэгийн давхарга (man:ath_hal[4]), болон хүрээнүүдийг дамжуулахын тулд хэд хэдэн боломжит хурдуудаас (энд ath_rate_sample) сонгох алгоритм юм. Эдгээр дэмжлэгийг модуль хэлбэрээр дуудах үед түүнтэй хамааралтай зүйлс автоматаар зохицуулагдах болно. Хэрэв танд Atheros төхөөрөмжийн оронд өөр төхөөрөмж байгаа бол та тэр төхөөрөмжид зориулсан модулийг сонгох юм, өөрөөр хэлбэл:

[.programlisting]
....
if_wi_load="YES"
....

гэж Intersil Prism хэсгүүд дээр суурилсан төхөөрөмжүүдийн хувьд хийж өгнө (man:wi[4] driver).

[NOTE]
====
Энэ баримтын үлдсэн хэсэгт бид man:ath[4] төхөөрөмжийг ашиглах бөгөөд жишээнүүд дээрх төхөөрөмжийн нэр таны тохиргооны дагуу өөрчлөгдөх ёстой. Байгаа утасгүй драйверууд болон дэмжигдсэн адаптеруудын жагсаалтыг FreeBSD Hardware Notes хуудаснаас олж болно. Төрөл бүрийн хувилбарууд болон архитектуруудад зориулсан эдгээр тэмдэглэгээнүүдийн хуулбар FreeBSD-ийн вэб сайтын http://www.FreeBSD.org/releases/[Хувилбарын Мэдээлэл] хуудсанд бий. Таны утасгүй төхөөрөмжид зориулагдсан FreeBSD-ийн драйвер байхгүй бол магадгүй Windows(R) драйверийг crossref:config[config-network-ndis,NDIS] драйверийн гүйцэтгэл хялбаршуулагчийн тусламжтай шууд ашиглаж болох юм.
====

Үүнтэй цуг таны ашиглах аюулгүй байдлын протоколуудад зориулагдсан криптографын дэмжлэгийг хийдэг модулиуд хэрэгтэй болно. Эдгээр нь man:wlan[4] модулиар автоматаар шаардлагын дагуу дуудагддаг байхаар зориулагдсан боловч одоохондоо эдгээрийг гараар тохируулах шаардлагатай. Дараах модулиуд байдаг: man:wlan_wep[4], man:wlan_ccmp[4] болон man:wlan_tkip[4]. man:wlan_ccmp[4] болон man:wlan_tkip[4] драйверууд нь WPA ба/эсвэл 802.11i аюулгүй байдлын протоколуудыг ашиглахаар болсон тохиолдолд танд зөвхөн хэрэгтэй байдаг. Хэрэв таны сүлжээ шифрлэлт ашигладаггүй бол танд man:wlan_wep[4] дэмжлэг хэрэггүй. Эдгээр модулиудыг ачаалах үед дуудахын тулд дараах мөрүүдийг [.filename]#/boot/loader.conf# файлд нэмнэ:

[.programlisting]
....
wlan_wep_load="YES"
wlan_ccmp_load="YES"
wlan_tkip_load="YES"
....

Системийн эхлүүлэх тохиргооны файлд (өөрөөр хэлбэл [.filename]#/boot/loader.conf#) ийм мэдээлэлтэйгээр та өөрийн FreeBSD хайрцгийг дахин ачаалах хэрэгтэй. Хэрэв та өөрийн машиныг дахин ачаалахыг хүсэхгүй байгаа бол та модулиудыг man:kldload[8]-ийн тусламжтайгаар гараар дуудаж болно.

[NOTE]
====
Хэрэв та модулиудыг ашиглахыг хүсэхгүй байгаа бол дараах мөрүүдийг өөрийн цөмийн тохиргооны файлд нэмж эдгээр драйверуудыг цөмд эмхэтгэж болно:

[.programlisting]
....
device wlan               # 802.11 support
device wlan_wep          # 802.11 WEP support
device wlan_ccmp         # 802.11 CCMP support
device wlan_tkip         # 802.11 TKIP support
device wlan_amrr         # AMRR transmit rate control algorithm
device ath               # Atheros pci/cardbus NIC's
device ath_hal           # pci/cardbus chip support
options AH_SUPPORT_AR5416 # enable AR5416 tx/rx descriptors
device ath_rate_sample   # SampleRate tx rate control for ath
....

Цөмийн тохиргооны файлдаа ийм мэдээлэлтэйгээр цөмөө дахин эмхэтгээд өөрийн FreeBSD машиныг дахин ачаалах хэрэгтэй.
====

Систем ассаны дараа ачаалах үеийн мэдэгдлүүдэд үүнтэй адил утасгүй төхөөрөмжийн талаар зарим мэдээллийг олж болно:

[source,bash]
....
ath0: <Atheros 5212> mem 0x88000000-0x8800ffff irq 11 at device 0.0 on cardbus1
ath0: [ITHREAD]
ath0: AR2413 mac 7.9 RF2413 phy 4.5
....

=== Дэд бүтцийн горим

Дэд бүтцийн горим буюу BSS горим нь ихэвчлэн ашиглагддаг горим юм. Энэ горимд утасгүй хандалтын цэгүүд нь утастай сүлжээнд холбогдсон байдаг. Утасгүй сүлжээ бүр өөрийн нэртэй байдаг бөгөөд энэ нэр нь сүлжээний SSID гэгддэг. Утасгүй клиентүүд нь утасгүй хандалтын цэгүүдэд холбогддог.

==== FreeBSD клиентүүд

===== Хандалтын цэгүүдийг хэрхэн олох вэ

Сүлжээнүүдийг хайхын тулд `ifconfig` тушаалыг ашиглана. Энэ хүсэлт нь хэсэг хором болж болох бөгөөд боломжтой утасгүй давтамж бүр уруу шилжиж, байгаа хандалтын цэгүүдийг шалгахыг системээс шаарддаг. Зөвхөн супер хэрэглэгч ийм хайлт эхлүүлж чадна:

[source,bash]
....
# ifconfig wlan0 create wlandev ath0
# ifconfig wlan0 up scan
SSID/MESH ID        BSSID              CHAN RATE    S:N   INT CAPS
dlinkap         00:13:46:49:41:76   11   54M -90:96   100 EPS  WPA WME
freebsdap       00:11:95:c3:0d:ac    1   54M -83:96   100 EPS  WPA
....

[NOTE]
====
Та хайлт хийхээсээ өмнө интерфэйсээ `up` болгож тэмдэглэх ёстой. Дараа дараагийн хайлтын хүсэлтүүд интерфэйсийг up болгож тэмдэглэхийг шаарддаггүй.
====

Хайлтын хүсэлтийн гаралт олсон BSS/IBSS сүлжээ бүрийг харуулдаг. Сүлжээний нэр `SSID`-с гадна хандалтын цэгийн MAC хаяг болох `BSSID`-г бид харах болно. `CAPS` талбар нь сүлжээ бүрийн төрөл болон тэнд ажиллаж байгаа станцуудын боломжуудыг заана:

.Station Capability Codes
[cols="1,1", frame="none", options="header"]
|===
| Capability Code
| Meaning

|`E`
|Extended Service Set (ESS) буюу өргөтгөсөн үйлчилгээний олонлог. Станц нь дэд бүтцийн сүлжээний хэсэг гэдгийг харуулна (IBSS/ad-hoc сүлжээтэй харьцуулах юм бол ).

|`I`
|IBSS/ad-hoc сүлжээ. Станц нь ad-hoc сүлжээний хэсэг гэдгийг харуулна (ESS сүлжээтэй харьцуулах юм бол).

|`P`
|Хувийн нууц. BSS-ийн дотор солилцож байгаа өгөгдлийн бүх хүрээнүүдэд өгөгдлийн нууц байдал шаардлагатай байдаг. Энэ BSS нь бусадтай солилцох өгөгдлийн хүрээнүүдийг шифрлэх/буцаах WEP, TKIP эсвэл AES-CCMP зэрэг криптограф ашиглахыг станцаас шаарддаг гэсэн үг юм.

|`S`
|Богино оршил (preamble). Сүлжээ богино оршлуудыг (802.11b өндөр хурд/DSSS PHY-д тодорхойлогдсоноор богино оршил нь урт оршилд ашиглагддаг 128 бит талбартай харьцуулах юм бол 56 бит sync талбарыг хэрэглэдэг) ашиглаж байгааг харуулдаг.

|`s`
|Богино слот (ангархай) хугацаа. 802.11g сүлжээ хуучин (802.11b) станцууд байхгүй байгаа учраас богино слот хугацааг хэрэглэж байгааг харуулна.
|===

Мэдэгдэж байгаа сүлжээнүүдийн одоогийн жагсаалтыг бас доорх тушаалаар харуулж болно:

[source,bash]
....
# ifconfig wlan0 list scan
....

Энэ мэдээллийг автоматаар хувиргагчаар (adapter) эсвэл гараар `scan` хүсэлтийн тусламжтай шинэчилж болно. Хуучин өгөгдөл кэшээс автоматаар арилгагдах болохоор хэсэг хугацаа өнгөрсний дараа нэмэлт хайлтууд хийхгүй л бол энэ жагсаалт багасаж болох юм.

===== Үндсэн тохиргоонууд

Энэ хэсэгт FreeBSD дээр утасгүй сүлжээний хувиргагчийг шифрлэлтгүйгээр хэрхэн ажиллуулахыг харуулсан энгийн жишээг үзүүлнэ. Эдгээр ойлголтуудыг мэддэг болсныхоо дараа өөрийнхөө утасгүй сүлжээг тохируулахдаа <<network-wireless-wpa,WPA>>-г ашиглахыг бид тууштай зөвлөж байна.

Утасгүй сүлжээг тохируулах гурван үндсэн алхам байдаг: эдгээрт хандалтыг цэгийг сонгох, өөрийн станцыг таниулж нэвтрүүлэх, болон IP хаягийг тохируулах багтана. Дараах хэсэг алхам бүрийг хэлэлцэнэ.

====== Хандалтын цэгийг сонгох нь

Ихэнх тохиолдолд систем өөртөө бүтээгдсэн гүнзгийрүүлэн шалгах аргаа (heuristic) ашиглан хандалтын цэгийг сонгохыг нь зөвшөөрөх хангалттай байдаг. Таныг интерфэйсийг up гэж тэмдэглэх үед энэ нь анхдагч байх бөгөөд хэрэв үгүй бол интерфэйсийг [.filename]#/etc/rc.conf# файлд жагсаан тохируулна, өөрөөр хэлбэл:

[.programlisting]
....
ifconfig_ath0="wlan0"
ifconfig_wlan0="DHCP"
....

Хэрэв олон хандалтын цэгүүд байгаа бөгөөд та тухайн нэгийг сонгохыг хүсвэл түүнийг SSID-аар нь сонгож болно:

[.programlisting]
....
wlans_ath0="wlan0"
ifconfig_wlan0="ssid your_ssid_here DHCP"
....

Адил SSID-тай олон хандалтын цэгүүд байгаа орчинд (роуминг-ийг (тэнүүчлэх) хялбар болгохын тулд ихэвчлэн хийдэг) аль нэг тухайн төхөөрөмж уруу холбогдох шаардлагатай болж болох юм. Энэ тохиолдолд та хандалтын цэгийн BSSID-ийг зааж өгч бас болох юм (та бас SSID-ийг үлдээж болно):

[.programlisting]
....
wlans_ath0="wlan0"
ifconfig_wlan0="ssid your_ssid_here bssid xx:xx:xx:xx:xx:xx DHCP"
....

Системийн хайлт хийх давтамжуудын олонлогийг хязгаарлах зэрэг хандалтын цэгийн сонголтыг шаардах өөр аргууд байдаг.Та олон зурвасын утасгүй сүлжээний карттай байх тохиолдолд энэ нь ашигтай байдаг. Ийм тохиолдолд бүх боломжит сувгуудыг хайх нь цаг хугацаа шаардсан ажил байдаг. Ажиллагааг тухайн нэг зурвас дээр хязгаарлахын тулд `mode` параметрийг та ашиглаж болно, өөрөөр хэлбэл:

[.programlisting]
....
wlans_ath0="wlan0"
ifconfig_wlan0="mode 11g ssid your_ssid_here DHCP"
....

нь картыг 2.4GHz давтамжуудын хувьд тодорхойлогдсон 802.11g горимд картыг ажиллуулах бөгөөд бусад 5GHz-ийн сувгуудыг авч үзэхгүй байх болно. Үүнийг хийх өөр нэг арга нь ажиллагааг тухайн нэг давтамжид түгжих `channel` параметр болон хайлт хийхдээ сувгуудын жагсаалтыг заах `chanlist` параметрийг ашиглах явдал юм. Эдгээр параметрүүдийн талаар дэлгэрэнгүй мэдээллийг man:ifconfig[8] гарын авлагын хуудаснаас лавлана уу.

====== Нэвтрэлт танилт

Хандалтын цэгийг сонгосны дараа таны станц өгөгдөл дамжуулахаа өмнө өөрийгөө таниулан нэвтрэх хэрэгтэй. Нэвтрэлт танилт хэд хэдэн аргаар хийгдэж болно. Ашиглагддаг хамгийн түгээмэл схем бол нээлттэй нэвтрэлт танилт гэгддэг бөгөөд энэ нь дурын станц сүлжээнд нэгдэж холбогдохыг зөвшөөрдөг. Энэ нь эхний удаа утасгүй сүлжээг тохируулж байхдаа тестийн зорилгоор таны ашиглах ёстой нэвтрэлт танилт юм. Бусад схемүүд нь өгөгдлийн урсгал эхлэхээс өмнө криптограф мэдээлэл солилцоо хийгдэхийг шаарддаг; урьдчилсан хуваалцсан түлхүүрүүд эсвэл нууц үгс ашиглах эсвэл RADIUS зэрэг арын үйлчилгээнүүдийг ашигладаг илүү төвөгтэй схемүүд зэргийг дурдаж болно. Ихэнх хэрэглэгчид нээлттэй нэвтрэлт танилт ашиглах бөгөөд энэ нь анхдагч тохиргоо байдаг. Дараагийн хамгийн түгээмэл тохируулга бол WPA-PSK бөгөөд энэ нь бас WPA Personal гэгддэг. Энэ тохируулга <<network-wireless-wpa-wpa-psk,доор>> тайлбарлагдсан байгаа.

[NOTE]
====
Хэрэв танд хандалтын цэгт зориулсан Apple(R) AirPort(R) Extreme дээр суурилсан үндсэн станц байгаа бол WEP түлхүүртэй хамт хуваалцсан түлхүүрийг тохируулах хэрэгтэй болж болох юм. Үүнийг [.filename]#/etc/rc.conf# файл эсвэл man:wpa_supplicant[8] програмыг ашиглан хийж болно. Хэрэв та ганц AirPort(R) үндсэн станцтай бол хандалтыг иймэрхүүгээр хийж өгч болно:

[.programlisting]
....
wlans_ath0="wlan0"
ifconfig_wlan0="authmode shared wepmode on weptxkey 1 wepkey 01234567 DHCP"
....

Ерөнхийдээ хуваалцсан түлхүүр бүхий нэвтрэлт танилтыг ашиглахаас зайлсхийх хэрэгтэй, яагаад гэвэл WEP түлхүүрийн материалыг их хүчилсэн хэлбэрээр ашигладаг нь түлхүүрийг эвдэх боломжийг илүү амархан болгодог. Хэрэв WEP ашиглагдах ёстой бол (өөрөөр хэлбэл хуучин төхөөрөмжтэй нийцтэй байх үүднээс) WEP-ийг `open` буюу нээлттэй нэвтрэлт танилттай цуг ашиглах нь зүйтэй юм. WEP-ийн талаар дэлгэрэнгүй мэдээллийг <<network-wireless-wep>>-с олж болно.
====

====== DHCP-ээр IP хаяг авах

Хандалтын цэгийг сонгож нэвтрэлт танилтын параметрүүдийг тохируулсны дараа холбогдохын тулд та IP хаяг авах хэрэгтэй болно. Та өөрийн утасгүй IP хаягийг ихэвчлэн DHCP-ээр авах болно. Ингэхийн тулд ердөө л [.filename]#/etc/rc.conf# файлыг засварлаж дээрх жишээн дээр үзүүлсэн шиг өөрийн төхөөрөмжийн тохиргоонд зориулж `DHCP` гэж нэмж өгнө:

[.programlisting]
....
wlans_ath0="wlan0"
ifconfig_wlan0="DHCP"
....

Энэ хүрэхэд та утасгүй интерфэйсээ ажиллуулахад бэлэн байх болно:

[source,bash]
....
# service netif start
....

Интерфэйс ажиллаж эхэлсний дараа [.filename]#ath0# интерфэйсийн төлөвийг үзэхийн тулд `ifconfig` тушаалыг ашиглана:

[source,bash]
....
# ifconfig wlan0
wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500
        ether 00:11:95:d5:43:62
	inet 192.168.1.100 netmask 0xffffff00 broadcast 192.168.1.255
        media: IEEE 802.11 Wireless Ethernet OFDM/54Mbps mode 11g
        status: associated
	ssid dlinkap channel 11 (2462 Mhz 11g) bssid 00:13:46:49:41:76
	country US ecm authmode OPEN privacy OFF txpower 21.5 bmiss 7
  	scanvalid 60 bgscan bgscanintvl 300 bgscanidle 250 roam:rssi 7
  	roam:rate 5 protmode CTS wme burst
....

`status: associated` мөр нь таныг утасгүй сүлжээнд (бидний тохиолдолд `dlinkap` сүлжээ уруу) холбогдсон гэдгийг харуулж байна. `bssid 00:13:46:49:41:76` хэсэг нь таны хандалтын цэгийн MAC хаяг юм; `authmode OPEN` хэсэг нь холболт шифрлэгдээгүй гэдгийг танд харуулж байна (`OPEN`).

====== Статик IP хаяг

DHCP серверээс IP хаяг авч чадахгүй тохиолдолд тогтмол IP хаяг та тавьж болно. Дээр үзүүлсэн `DHCP` гэсэн түлхүүр үгийг хаягийн мэдээллээр солих хэрэгтэй. Хандалтын цэгийг сонгохдоо хэрэглэсэн бусад параметрүүдийг үлдээхээ мартуузай:

[.programlisting]
....
wlans_ath0="wlan0"
ifconfig_wlan0="inet 192.168.1.100 netmask 255.255.255.0 ssid your_ssid_here"
....

[[network-wireless-wpa]]
===== WPA

WPA (Wi-Fi Protected Access буюу Wi-Fi Хамгаалагдсан Хандалт) нь <<network-wireless-wep,WEP>>-ийн сул тал болон зөв нэвтрэлт танилтын дутмаг байдлыг арилгах зорилгоор 802.11 сүлжээнүүдэд цуг ашиглагддаг аюулгүй байдлын протокол юм. WPA нь 802.1X нэвтрэлт танилтын протоколыг хөшүүрэгддэг бөгөөд өгөгдлийн бүрэн бүтэн байдалд зориулж WEP-ийн оронд хэд хэдэн шифрүүдийн нэгийг ашигладаг. WPA-ийн шаарддаг цорын ганц шифр бол TKIP (Temporary Key Integrity Protocol) юм. TKIP нь бүрэн бүтэн байдал шалгалт, хуурамч үйлдлийг илрүүлэлт болон илрүүлсэн халдлагуудад хариулахад зориулсан арга хэмжээнүүдийг WEP-ийн ашигладаг үндсэн RC4 шифрт нэмэн өргөтгөсөн шифр юм. TKIP нь хуучин тоног төхөөрөмж дээр зөвхөн програм хангамжийн өөрчлөлттэйгөөр ажиллахаар хийгдсэн; энэ нь аюулгүй байдлыг сайжруулдаг боловч халдлагаас бүрэн гүйцэд хамгаалж чаддаггүй. WPA нь TKIP-г орлуулж AES-CCMP шифрийг бас заадаг бөгөөд боломжтой тохиолдолд үүнийг хэрэглэхийг урьтал болгодог; энэ тодорхойлолтод WPA2 (эсвэл RSN) гэсэн ухагдахуун нийтлэг ашиглагддаг.

WPA нь нэвтрэлт танилт болон шифрлэлтийн протоколуудыг тодорхойлдог. Нэвтрэлт танилт нь хоёр техникийн аль нэгээр ихэвчлэн хийгддэг: 802.1X болон RADIUS зэрэг арын нэвтрэлт танилтын үйлчилгээгээр эсвэл урьдчилан хуваалцсан нууц үг ашиглан станц болон хандалтын хооронд хамгийн багаар мэдээлэл солилцох (handshake) замаар хийгддэг. Эхнийх нь ихэвчлэн WPA Enterprise, сүүлийнх нь WPA Personal гэгддэг. Ихэнх хүмүүс утасгүй сүлжээнд зориулж арын RADIUS сервер өөрсөддөө зориулж тохируулдаггүй учир WPA-PSK нь WPA-д зориулсан хамгийн түгээмэл тохиолддог тохиргоо юм.

Утасгүй холболтын хяналт болон нэвтрэлт танилт (түлхүүрийн тохиролцоо эсвэл сервертэй хийх нэвтрэлт танилт) нь man:wpa_supplicant[8] хэрэгслээр хийгддэг. Энэ програм нь ажиллахын тулд [.filename]#/etc/wpa_supplicant.conf# тохиргооны файл шаарддаг. Энэ файлын талаар дэлгэрэнгүй мэдээллийг man:wpa_supplicant.conf[5] гарын авлагын хуудаснаас олж болно.

[[network-wireless-wpa-wpa-psk]]
====== WPA-PSK

WPA-PSK нь бас WPA Personal гэгддэг бөгөөд өгөгдсөн нууц үгээс үүсгэгдсэн pre-shared key буюу (PSK) урьдчилан хуваалцсан түлхүүр дээр суурилдаг бөгөөд утасгүй сүлжээнд мастер түлхүүр болон ашиглагддаг. Энэ нь утасгүй хэрэглэгч бүр адил түлхүүрийг хуваалцана гэсэн үг юм. WPA-PSK нь нэвтрэлт танилтын сервер хэрэглэх боломжгүй эсвэл шаардлагагүй жижиг сүлжээнүүдэд зориулагдсан юм.

[WARNING]
====

Хангалттай урт, төрөл бүрийн тэмдэгтүүдээс бүтсэн, таах буюу/эсвэл халдах боломжгүй хэцүү нууц үгсийг үргэлж ашиглах хэрэгтэй.
====

Эхний алхам нь [.filename]#/etc/wpa_supplicant.conf# файлыг өөрийн сүлжээний SSID болон урьдчилан хуваалцсан түлхүүрээр тохируулах явдал юм:

[.programlisting]
....
network={
  ssid="freebsdap"
  psk="freebsdmall"
}
....

Дараа нь бид [.filename]#/etc/rc.conf# файлд утасгүй төхөөрөмжийн тохиргоо WPA-аар хийгдэж IP хаяг DHCP-ээс авагдана гэдгийг зааж өгнө:

[.programlisting]
....
wlans_ath0="wlan0"
ifconfig_wlan0="WPA DHCP"
....

Дараа нь бид интерфэйсийг босгож ажиллуулна:

[source,bash]
....
# service netif start
Starting wpa_supplicant.
DHCPDISCOVER on wlan0 to 255.255.255.255 port 67 interval 5
DHCPDISCOVER on wlan0 to 255.255.255.255 port 67 interval 6
DHCPOFFER from 192.168.0.1
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPACK from 192.168.0.1
bound to 192.168.0.254 -- renewal in 300 seconds.
wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL
....

Эсвэл та үүнийг гараар <<network-wireless-wpa-wpa-psk,дээрх>> [.filename]#/etc/wpa_supplicant.conf# ашиглан хийж доор дурдсан тушаалыг ажиллуулж болно:

[source,bash]
....
# wpa_supplicant -i wlan0 -c /etc/wpa_supplicant.conf
Trying to associate with 00:11:95:c3:0d:ac (SSID='freebsdap' freq=2412 MHz)
Associated with 00:11:95:c3:0d:ac
WPA: Key negotiation completed with 00:11:95:c3:0d:ac [PTK=CCMP GTK=CCMP]
  	 CTRL-EVENT-CONNECTED - Connection to 00:11:95:c3:0d:ac completed (auth) [id=0 id_str=]
....

Дараагийн үйлдэл нь DHCP серверээс IP хаяг авахын тулд `dhclient` тушаалыг ажиллуулах явдал юм:

[source,bash]
....
# dhclient wlan0
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPACK from 192.168.0.1
bound to 192.168.0.254 -- renewal in 300 seconds.
# ifconfig wlan0
wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL
....

[NOTE]
====
Хэрэв [.filename]#/etc/rc.conf# файл нь `DHCP` гэсэн утгатай `ifconfig_wlan0` мөртэй тохируулагдсан бол (`ifconfig_wlan0="DHCP"`) `wpa_supplicant` нь холболтын цэгтэй холбогдсоны дараа `dhclient` тушаал автоматаар ажиллах болно.
====

DHCP-ийн хэрэглээ боломжгүй тохиолдолд `wpa_supplicant` станцыг таниулж нэвтрүүлсний дараа та статик IP хаяг тохируулж болно:

[source,bash]
....
# service netif start
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPACK from 192.168.0.20
bound to 192.168.0.254 -- renewal in 300 seconds.
wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL
....

Урьд нь үзүүлсний адил интерфэйсийг гараар `wpa_supplicant` болон `ifconfig` тушаалуудаар босгох боломжтой байдаг.

[[network-wireless-wpa-eap-ttls]]
====== EAP-TTLS-тэй WPA

EAP-TLS-тэй байхад нэвтрэлт танилтын сервер болон клиентэд сертификат хэрэгтэй бол EAP-TTLS-тэй (EAP-Tunneled Transport Layer Security) байхад клиентийн сертификат нэмэлт сонголт байдаг. Энэ арга нь зорчигчид клиент талдаа сертификатгүй байсан ч гэсэн нууцлаг SSL туннель үүсгэж чаддаг зарим нэг аюулгүй вэб сайтуудын хийдэгтэй ойролцоо байдаг. EAP-TTLS нь нэвтрэлт танилтын өгөгдлийг аюулгүй тээвэрлэхэд зориулж шифрлэгдсэн TLS туннелийг ашиглах болно.

Тохиргоог [.filename]#/etc/wpa_supplicant.conf# файлаар хийнэ:

[.programlisting]
....
network={
  ssid="freebsdap"
  proto=RSN
  key_mgmt=WPA-EAP
  eap=TTLS <.>
  identity="test" <.>
  password="test" <.>
  ca_cert="/etc/certs/cacert.pem" <.>
  phase2="auth=MD5" 
}
....

<.> Энэ талбарт бид өөрийн холболтондоо зориулж EAP аргыг дурдана.

<.> `identity` талбар нь шифрлэгдсэн TLS туннель доторх EAP нэвтрэлт танилтад зориулсан таниулах мөрийг агуулна.

<.> `password` талбар нь EAP нэвтрэлт танилтад зориулсан нэвтрэх үгийг агуулна.

<.> `ca_cert` талбар нь CA сертификатын файлын замын нэрийг заана. Энэ файл нь серверийн сертификатыг шалгахад хэрэгтэй байдаг.

Энэ талбарт бид шифрлэгдсэн TLS туннельд ашиглагдсан нэвтрэлт танилтын аргыг заана. Бидний тохиолдолд MD5-Challenge-тай цуг EAP ашиглагдаж байна. "inner authentication" дотоод нэвтрэлт танилт үе нь ихэвчлэн "phase2" буюу хоёрдугаар үе гэгддэг.

Дараах мөрүүдийг та [.filename]#/etc/rc.conf# файлд бас нэмэх хэрэгтэй:

[.programlisting]
....
wlans_ath0="wlan0"
ifconfig_wlan0="WPA DHCP"
....

Дараагийн алхам бол интерфэйсийг босгож ажиллуулах явдал юм:

[source,bash]
....
# service netif start
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPACK from 192.168.0.20
bound to 192.168.0.254 -- renewal in 300 seconds.
wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL
....

[[network-wireless-wpa-eap-peap]]
====== EAP-PEAP-тэй WPA

[NOTE]
====
PEAPv0/EAP-MSCHAPv2 нь хамгийн түгээмэл PEAP арга юм. Баримтын үлдсэн хэсэгт энэ аргыг PEAP гэж нэрлэх болно.
====

PEAP (Protected EAP) нь EAP-TTLS-ийн өөр нэг хувилбар хэлбэрээр байхаар хийгдсэн бөгөөд хамгийн EAP-TLS-с гадна хамгийн түгээмэл EAP стандарт юм. Өөрөөр хэлбэл хэрэв та төрөл бүрийн OS-үүд холилдсон сүлжээтэй бол PEAP нь EAP-TLS-ийн дараа орох хамгийн ихээр дэмжигдсэн стандарт байх юм.

PEAP нь EAP-TLS-тэй төстэй байдаг: энэ нь клиент болон нэвтрэлт танилтын серверийн хооронд нэвтрэлт танилтын мэдээллийн солилцоог хамгаалах шифрлэгдсэн туннель үүсгэн клиентүүдийг танин нэвтрүүлэхийн тулд сервер талын сертификатыг ашигладаг. Аюулгүй байдлын ухагдахуун дахь EAP-TTLS болон PEAP-ийн хоорондох ялгаа нь PEAP нэвтрэлт танилт хэрэглэгчийн нэрийг цэвэр текст хэлбэрээр, зөвхөн нууц үгийг шифрлэгдсэн TLS туннелээр цацдаг явдал юм. EAP-TTLS нь хэрэглэгчийн нэр болон нууц үгт зориулж TLS туннелийг ашиглах болно.

Бид [.filename]#/etc/wpa_supplicant.conf# файлыг засварлаж EAP-PEAP-тэй холбоотой тохируулгуудыг нэмэх хэрэгтэй болно:

[.programlisting]
....
network={
  ssid="freebsdap"
  proto=RSN
  key_mgmt=WPA-EAP
  eap=PEAP <.>
  identity="test" <.>
  password="test" <.>
  ca_cert="/etc/certs/cacert.pem" <.>
  phase1="peaplabel=0" <.>
  phase2="auth=MSCHAPV2" <.>
}
....

<.> Энэ талбарт бид өөрийн холболтондоо зориулж EAP аргыг ашиглахаа дурдана.

<.> `identity` талбар нь шифрлэгдсэн TLS туннель доторх EAP нэвтрэлт танилтад зориулсан таниулах мөрийг агуулна.

<.> `password` талбар нь EAP нэвтрэлт танилтад зориулсан нэвтрэх үгийг агуулна.

<.> `ca_cert` талбар нь CA сертификатын файлын замын нэрийг заана. Энэ файл нь серверийн сертификатыг шалгахад хэрэгтэй байдаг.

<.> Энэ талбар нь нэвтрэлт танилтын (TLS туннель) эхний үед зориулсан параметрүүдийг агуулна. Ашигласан нэвтрэлт танилтын серверээс хамаараад нэвтрэлт танилтад зориулж тусгай хаяг/шошгыг зааж өгөх хэрэгтэй болно. Ихэнх тохиолдолд хаяг/шошго нь "клиентийн EAP шифрлэлт" байх бөгөөд үүнийг `peaplabel=0` гэж тохируулна. Илүү мэдээллийг man:wpa_supplicant.conf[5] гарын авлагын хуудаснаас олж болно.

<.> Энэ талбарт бид шифрлэгдсэн TLS туннельд ашиглагдсан нэвтрэлт танилтын аргыг заана. PEAP-ийн хувьд энэ нь `auth=MSCHAPV2` байна.

Доор дурдсаныг [.filename]#/etc/rc.conf# файлд нэмэх ёстой:

[.programlisting]
....
wlans_ath0="wlan0"
ifconfig_wlan0="WPA DHCP"
....

Дараа нь бид интерфэйсийг босгож ажиллуулж болно:

[source,bash]
....
# /etc/rc.d/netif start
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPACK from 192.168.0.20
bound to 192.168.0.254 -- renewal in 300 seconds.
wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL
....

[[network-wireless-wep]]
===== WEP

WEP (Wired Equivalent Privacy) нь анхдагч 802.11 стандартын хэсэг юм. Үүнд ямар ч нэвтрэлт танилтын арга байхгүй, энэ нь хандалт хяналтын зөвхөн сул хэлбэр бөгөөд хялбар эвдэх боломжтой байдаг.

WEP-ийг `ifconfig` тушаалаар тохируулж болно:

[source,bash]
....
# ifconfig wlan0 create wlandev ath0
	    # ifconfig wlan0 inet 192.168.1.100 netmask 255.255.255.0 \
	      ssid my_net wepmode on weptxkey 3 wepkey 3:0x3456789012
....

* `weptxkey` нь дамжуулалтад ямар WEP түлхүүр ашиглахыг хэлж байна. Энд бид гурав дахь түлхүүрийг ашиглаж байна. Энэ нь хандалтын цэг дэх тохиргоотой таарах ёстой. Хэрэв та хандалтын цэг дээр ямар түлхүүр ашиглагдаж байгааг мэдэхгүй байгаа бол энэ утгад `1`-ийг (өөрөөр хэлбэл эхний түлхүүр) ашиглах хэрэгтэй.
* `wepkey` нь аль нэг WEP түлхүүрийг сонгоно. Энэ нь _index:key_ хэлбэрийн байх ёстой. Анхдагчаар `1` гэж түлхүүр тохируулагдана. Хэрэв бид эхний түлхүүрээс өөр түлхүүрүүдийг ашиглах бол индексийг тохируулах хэрэгтэй.
+
[NOTE]
====
Та `0x3456789012`-г хандалтын цэг дээр ашиглахаар тохируулсан түлхүүрээр солих ёстой.
====

Цаашхи мэдээллийг man:ifconfig[8] гарын авлагын хуудаснаас унших нь зүйтэй юм.

`wpa_supplicant` хэрэгслийг өөрийн утасгүй интерфэйсийг WEP-тэй тохируулахын тулд бас ашиглаж болно. Дараах мөрийг [.filename]#/etc/wpa_supplicant.conf# файлд нэмж дээрх жишээг тохируулж болно:

[.programlisting]
....
network={
  ssid="my_net"
  key_mgmt=NONE
  wep_key3=3456789012
  wep_tx_keyidx=3
}
....

Дараа нь:

[source,bash]
....
# wpa_supplicant -i wlan0 -c /etc/wpa_supplicant.conf
Trying to associate with 00:13:46:49:41:76 (SSID='dlinkap' freq=2437 MHz)
Associated with 00:13:46:49:41:76
....

=== Ad-hoc горим

IBSS горим буюу бас ad-hoc гэгддэг горим нь цэгээс цэгт холбогдох холболтуудад зориулагдан хийгдсэн. Жишээ нь `A` машин болон `B` машины хооронд ad-hoc сүлжээ үүсгэхийн тулд бид ердөө л хоёр IP хаяг болон SSID сонгох хэрэгтэй болно.

`A` машин дээр:

[source,bash]
....
# ifconfig wlan0 create wlandev ath0 wlanmode adhoc
# ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap
# ifconfig wlan0
wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500
	  ether 00:11:95:c3:0d:ac
          inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g <adhoc>
	  status: running
	  ssid freebsdap channel 2 (2417 Mhz 11g) bssid 02:11:95:c3:0d:ac
          country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
	  protmode CTS wme burst
....

`adhoc` параметр нь интерфэйс IBSS горимд ажиллаж байгааг харуулж байна.

`B` машин дээр бид `A` машиныг илрүүлж чадах ёстой:

[source,bash]
....
# ifconfig wlan0 create wlandev ath0 wlanmode adhoc
# ifconfig wlan0 up scan
  SSID/MESH ID       BSSID             CHAN RATE        S:N   INT CAPS
  freebsdap       02:11:95:c3:0d:ac    2   54M -64:-96   100 IS  WME
....

Гаралт дээрх `I` нь `A` машин ad-hoc горимд байгааг батална. Бид одоо `B`-г өөр IP хаягтайгаар тохируулах хэрэгтэй:

[source,bash]
....
# ifconfig wlan0 inet 192.168.0.2 netmask 255.255.255.0 ssid freebsdap
# ifconfig wlan0
wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500
	  ether 00:11:95:d5:43:62
          inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g <adhoc>
	  status: running
	  ssid freebsdap channel 2 (2417 Mhz 11g) bssid 02:11:95:c3:0d:ac
          country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
	  protmode CTS wme burst
....

`A` болон `B` нь одоо мэдээлэл солилцоход бэлэн боллоо.

[[network-wireless-ap]]
=== FreeBSD хандах цэг болж ажиллах

FreeBSD нь Access Point (AP) буюу хандах цэг болж ажилласнаар нэмэлт хандах цэг болсон төхөөрөмж худалдаж авах эсвэл цэгээс цэгийн хооронд холбогдож ажилладаг сүлжээ байгуулах зэрэг нэмэлт үйлдлүүдийг хэмнэж болдог. Хэрэв таны FreeBSD машин сүлжээнээс сүлжээний хооронд дамжуулдаг гүүр болж (жишээ нь интернэтэд холбож) ажиллах шаардлагатай үед илүү тохирдог.

[[network-wireless-ap-basic]]
==== Үндсэн тохиргоо

FreeBSD машинаа хандах цэг болж ажилладгаар тохируулахаасаа өмнө цөмөө сүлжээнийхээ картанд тохируулж тохируулсан байх ёстой. Та мөн хэрэглэх нууцлалын дамжуулах протокол буюу бүртгэлээ нэмэх хэрэгтэй. Нэмэлт мэдээллийг <<network-wireless-basic>> хэсгээс харна уу.

[NOTE]
====
NDIS хэмээгч драйвер орлуулагч болон Виндоусын драйверуудыг ашигласан тохиолдолд хандах цэг болгож ашиглах боломж одоогоор байхгүй. Зөвхөн FreeBSD-н үндсэн утасгүй холболтын драйвер л хандах цэг болох горимыг дэмжиж байгаа.
====

Утасгүй холболтын сүлжээ дэмжигдэх ажилладаг болж ирэнгүүт нь утасгүй сүлжээний төхөөрөмж тань тухайн машин дээрээ хандах цэг болж ажиллах чадвартайг шалгаж болдог (заримдаа hostap горим гэж нэрлэдэг):

[source,bash]
....
# ifconfig wlan0 create wlandev ath0
# ifconfig wlan0 list caps
drivercaps=6f85edc1<STA,FF,TURBOP,IBSS,HOSTAP,AHDEMO,TXPMGT,SHSLOT,SHPREAMBLE,MONITOR,MBSS,WPA1,WPA2,BURST,WME,WDS,BGSCAN,TXFRAG>
cryptocaps=1f<WEP,TKIP,AES,AES_CCM,TKIPMIC>
....

Дээрх тушаалын гаралтаас `HOSTAP` гэдэг үг нь тухай утасгүй сүлжээний карт нь хандах цэг болж ажиллах чадвартай гэдгийг баталж өгч байна. Мөн төрөл бүрийн нууцлалын боломжууд нь WEP, TKIP, AES, гэх мэтээр дурдагддаг. Эдгээр нь хандах цэгийн дамжуулалтаа нууцлахад хэрэглэгдэх чухал хэрэгтэй мэдээлэл болж өгдөг.

Сүлжээний псевдо төхөөрөмжийг үүсгэх үед утасгүй сүлжээний төхөөрөмжийг зөвхөн hostap горимд оруулах боломжтой байдаг, тэгэхээр өмнө нь үүсгэсэн төхөөрөмжийг эхлээд устгах ёстой:

[source,bash]
....
# ifconfig wlan0 destroy
....

Дараа нь харин бусад параметрүүдийг тохируулахаасаа өмнө зөв тохиргоотойгоор дахин үүсдэг:

[source,bash]
....
# ifconfig wlan0 create wlandev ath0 wlanmode hostap
# ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap mode 11g channel 1
....

Дахин `ifconfig` тушаалаар [.filename]#wlan0# төхөөрөмжийн төлөв байдлыг шалгая:

[source,bash]
....
# ifconfig wlan0
  wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500
	  ether 00:11:95:c3:0d:ac
	  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g <hostap>
	  status: running
	  ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
	  protmode CTS wme burst dtimperiod 1 -dfs
....

`hostap` үг нь уг төхөөрөмжийг тухайн машин дээр хандах цэг болж ажиллаж байгааг нь илэрхийлж байна.

Тухайн төхөөрөмжийн ийм тохируулгыг машин асах үед нь хийгдэхээр тохируулъя гэж бодсон тохиолдолд [.filename]#/etc/rc.conf# файлд дараах мөрүүдийг оруулж өгөх хэрэгтэй:

[.programlisting]
....
wlans_ath0="wlan0"
create_args_wlan0="wlanmode hostap"
ifconfig_wlan0="inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap mode 11g channel 1"
....

==== Тухайн машин дээр хандах цэг нь нэвтрэх үйлдэл болон нууцлах үйлчилгээ ашиглахгүй ажиллах

Хэдийгээр хандах цэгийг нэвтрэх үйлдэл болон холболтын нууцлал ашиглахгүйгээр ажиллуулах нь тийм сайшаалтай биш боловч хандах цэгийн ажиллагааг шалгахын тулд ингэж тохируулж ажиллуулах шаардлага гардаг. Энэ тохируулга нь мөн хэрэглэгчтэй холбогдолтой хүндрэлүүдийг шийдэхэд бас хэрэглэгдэж болно.

Өмнө харуулснаар тохируулагдсан хандах цэгийг өөр утасгүй сүлжээтэй ажиллаж буй машинаас хайлт хийж олж болдог:

[source,bash]
....
# ifconfig wlan0 create wlandev ath0
# ifconfig wlan0 up scan
SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS
freebsdap       00:11:95:c3:0d:ac    1   54M -66:-96  100 ES   WME
....

Хэрэглэгч машинаас хандах цэгийг ингэж олоод түүнтэй дараах маягаар холбогдож болно:

[source,bash]
....
# ifconfig wlan0 inet 192.168.0.2 netmask 255.255.255.0 ssid freebsdap
# ifconfig wlan0
  wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500
	  ether 00:11:95:d5:43:62
	  inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet OFDM/54Mbps mode 11g
	  status: associated
	  ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy OFF txpower 21.5 bmiss 7
	  scanvalid 60 bgscan bgscanintvl 300 bgscanidle 250 roam:rssi 7
	  roam:rate 5 protmode CTS wme burst
....

==== WPA нууцлалтай хандах цэг болсон машин

Энэ хэсэгт хандах цэг болж ажиллаж буй FreeBSD машиныг WPA нууцлалын бүртгэл хэрэглэх тухай өгүүлэх болно. WPA нууцлалтай холбогдолтой болон WPA дээр суурилсан хэрэглэгчийн тохиргооны талаар дэлгэрэнгүй мэдээллийг <<network-wireless-wpa>> хэсгээс хараарай.

hostapd нэртэй далд чөтгөр нь WPA-г ашиглаж буй хандах цэг дээр хэрэглэгчийг нэвтрүүлэх болон түлхүүр үг солилцох үйлдлүүдэд зориулагдсан байдаг.

Дараах жишээн дээр бүх тохиргооны үйлдлүүд нь хандах цэг болж ажиллаж буй FreeBSD машин дээр гүйцэтгэгдэх болно. Хандах цэг зөв ажиллаж эхэлсэн үед hostapd далд чөтгөрийг автоматаар машиныг ачаалагдах үед зөвшөөрөхийн тулд [.filename]#/etc/rc.conf# файлд дараах мөрийг нэмж өгөх хэрэгтэй:

[.programlisting]
....
hostapd_enable="YES"
....

hostapd далд чөтгөрийг тохируулахаасаа өмнө <<network-wireless-ap-basic>> хэсэгт заасан ерөнхий тохиргоог хийсэн эсэхээ магадлаарай.

===== WPA-PSK

WPA-PSK нь хэрэглэгчид нэвтрэх үйлдэл хийдэг сервер шаардлагагүй юм уу эсвэл боломжгүй болсон бага зэргийг сүлжээнд зориулагдсан билээ.

Тохиргоо нь [.filename]#/etc/hostapd.conf# файлд хийгддэг:

[.programlisting]
....
interface=wlan0 <.>
debug=1 <.>
ctrl_interface=/var/run/hostapd <.>
ctrl_interface_group=wheel <.>
ssid=freebsdap <.>
wpa=1 <.>
wpa_passphrase=freebsdmall <.>
wpa_key_mgmt=WPA-PSK <.>
wpa_pairwise=CCMP TKIP <.>
....

<.> Энэ талбар нь хандах цэг болж ажиллаж буй утасгүй сүлжээний төхөөрөмжийг заадаг.

<.> hostapd-н гүйцэтгэж байгаа явцыг харуулалтын түвшинг заадаг талбар. `1` гэсэн утга нь хамгийн бага түвшинг зааж байгаа билээ.
`ctrl_interface` гэсэн талбар нь hostapd-д хэрэглэгддэг man:hostapd_cli[8] төрлийн гадны програмуудтай холбогдоход хэрэглэгддэг домэйн сокет файлуудыг хадгалах сангийн байрлалыг зааж өгдөг. Энд анхдагч утга нь хэрэглэгдсэн байна.
<.> `ctrl_interface_group` гэсэн мөрөнд хяналт хийдэг төхөөрөмж рүү хандаж болох бүлгийн нэр (энд `wheel` бүлгийг оруулсан) байна.

<.> Энэ талбарт сүлжээний нэрийг оруулдаг.

<.> `wpa` талбар нь WPA нууцлалыг зөвшөөрдөг бөгөөд ямар бүртгэл шаардлагатайг нь тодорхойлж өгнө. `1` гэсэн утга нь хандах цэгийг WPA-PSK нууцлалаар 
тохируулдаг.

<.> `wpa_passphrase` талбарт ASCII тэмдэгтээр бичигдсэн WPA нэвтрэх үйлдлийн нууц үг агуулагддаг.

<.> `wpa_key_mgmt` мөр нь хэрэглэж буй түлхүүр үгний зориулалтанд хамаатай. Манай тохиолдолд энэ нь WPA-PSK байна.

<.> `wpa_pairwise` талбар нь хандах цэгт тохиромжтой нууц хувиргалтуудыг харуулдаг. Энд TKIP (WPA) ба CCMP (WPA2) хувиргагчид хоёулаа хүлээн зөвшөөрөгдөнө. CCMP хувиргагч нь TKIP-н бас нэг хувилбар бөгөөд боломжтой бол үүнийг илүүд үзэх хэрэгтэй. TKIP хувиргагчийг CCMP хувиргагч хэрэглэх боломжгүй үед л сонгох нь зүйтэй.

Дараагийн алхам нь hostapd-г эхлүүлэх:

[source,bash]
....
# service hostapd forcestart
....

[source,bash]
....
# ifconfig wlan0
  wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 2290
	  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
	  inet6 fe80::211:95ff:fec3:dac%ath0 prefixlen 64 scopeid 0x4
	  ether 00:11:95:c3:0d:ac
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g <hostap>
	  status: associated
	  ssid freebsdap channel 1 bssid 00:11:95:c3:0d:ac
	  authmode WPA2/802.11i privacy MIXED deftxkey 2 TKIP 2:128-bit txpowmax 36 protmode CTS dtimperiod 1 bintval 100
....

Хандах цэг одоо ажиллагаанд орсон бөгөөд хэрэглэгчийн зүгээс холбогдох тухай дэлгэрэнгүй мэдээллийг <<network-wireless-wpa>> хэсгээс харна уу. Хандах цэгт холбогдсон төхөөрөмжүүдийг `ifconfig wlan0 list sta` гэсэн тушаалаар харж болно.

==== WEP нууцлал хэрэглэж хандах цэг болсон машин

Ямар ч нэвтрэх үйлдэл хэрэглэдэггүй учраас амархан дайралтад өртдөгийн улмаас WEP нууцлалын хувиргуурыг хэрэглэх нь тийм сайшаалтай биш. Зарим худалдаанд хэрэглэгдэж буй утасгүй сүлжээний картууд нь зөвхөн WEP нууцлалын бүртгэл хэрэглэдэг ба ийм картуудыг хандах цэг болгож хэрэглэхээр бол хэрэглэгчийн таних үйлдэл хийхээр тохируулах боломж байхгүй байх болно.

Утасгүй сүлжээний төхөөрөмж тэгэхээр одоо hostap горимд ажиллаж болох бөгөөд шаардлагатай зөв SSID дугаар болон IP хаягаа авах шаардлагатай:

[source,bash]
....
# ifconfig wlan0 create wlandev ath0 wlanmode hostap
# ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 \
	ssid freebsdap wepmode on weptxkey 3 wepkey 3:0x3456789012 mode 11g
....

* `weptxkey` гэдэг нь дамжуулалтад WEP нууцлал хэрэглэхийг зааж өгч байна. Энд бид гуравдугаар түлхүүрийг (түлхүүрийн дугаар нь `1` гэсэн тоогоор эхэлдэг) хэрэглэсэн байна. Энэ сонголт нь дамжуулагдах өгөгдлийг хувиргахад хэрэглэгддэг.
* `wepkey` гэдэг нь WEP түлхүүрийг сонгосныг зааж байна. Энэ нь _index:key_ гэсэн хэлбэртэй байдаг ба хэрэв эхний дугаарлалт нь заагдаагүй бол түлхүүр нь `1` гэж суугддаг. Тэгэхээр хэрэв эхний түлхүүрээс өөр түлхүүр хэрэглэх шаардлагатай бол эхний дугаарлалтыг нь зааж өгөх шаардлагатай гэсэн үг.

Ингээд дахин `ifconfig` тушаалыг ашиглаж [.filename]#wlan0# төхөөрөмжийн төлөв байдлыг шалгаж болно:

[source,bash]
....
# ifconfig wlan0
  wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500
	  ether 00:11:95:c3:0d:ac
	  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g <hostap>
	  status: running
	  ssid freebsdap channel 4 (2427 Mhz 11g) bssid 00:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy ON deftxkey 3 wepkey 3:40-bit
	  txpower 21.5 scanvalid 60 protmode CTS wme burst dtimperiod 1 -dfs
....

Өөр утасгүй холбогддог машинаас хандах цэгийг хайж шалгаж болдог:

[source,bash]
....
# ifconfig wlan0 create wlandev ath0
# ifconfig wlan0 up scan
SSID            BSSID              CHAN RATE  S:N   INT CAPS
freebsdap       00:11:95:c3:0d:ac    1   54M 22:1   100 EPS
....

Хэрэглэгчийн машинаас хандах цэгийг олоод зөв тохиргоог нь зааж өгөн (дугаар түлхүүр гэх мэт) холбогдох тухай дэлгэрэнгүй зааврыг <<network-wireless-wep>> хэсгээс харна уу.

=== Утастай болон утасгүй холболтыг ашиглах нь

Утастай сүлжээний холболт нь илүү сайн ажиллагаа болон найдвартай байдлыг хангадаг бол утасгүй сүлжээний холболт нь уян хатан байдал, зөөх боломжийг бүрдүүлдэг бөгөөд зөөврийн компьютер ашигладаг хэрэглэгчид ихэвчлэн эдгээрийг хамтад нь ашиглаж хооронд нь чөлөөтэй шилжиж байхыг хүсдэг.

FreeBSD дээр хоёр болон түүнээс олон сүлжээний интерфэйсийг нийлүүлж "failover" горимоор ашиглах боломжтой бөгөөд энэ нь сүлжээний интерфэйсүүдээс хамгийн боломжтойг ашиглаж холболтын төлөв өөрчлөгдөхөд үйлдлийн системийн тусламжтайгаар автоматаар өөр холболт руу шилжих боломж юм.

Бид холболт нийлүүлэх болон failover горимыг <<network-aggregation>> хэсэгт авч үзэх бөгөөд утастай болон утасгүй холболтыг ашиглах талаарх жишээ <<networking-lagg-wired-and-wireless>> хэсэгт бас байгаа болно.

=== Алдааг олж засварлах

Хэрэв та утасгүй сүлжээндээ асуудалтай байгаа бол асуудлыг олж засварлахад туслах хэд хэдэн алхмууд байдаг.

* Хайлт хийж байхдаа та хандалтын цэгийг олж харахгүй байгаа бол та өөрийн утасгүй төхөөрөмжөө тодорхой хэдэн сувгууд дээр хязгаарлаж тохируулаагүй эсэхээ шалгаарай.
* Хэрэв та хандалтын цэгт холбогдож чадахгүй байгаа бол таны станцын тохиргоо хандалтын цэгийн аль нэгтэй тохирч байгаа эсэхийг шалгаарай. Үүнд нэвтрэлт танилтын схем болон аюулгүй байдлын протоколууд хамаарна. Өөрийн тохиргоогоо аль болох хялбаршуулах хэрэгтэй. Хэрэв та WPA эсвэл WEP зэрэг аюулгүй байдлын протоколыг ашиглаж байгаа бол хандалтын цэгийг нээлттэй нэвтрэлт танилтад зориулж ямар нэгэн аюулгүй байдлын хамгаалалтгүй тохируулж урсгал дамжиж байгаа эсэхийг үзэх хэрэгтэй.
* Хандалтын цэгт холбогдсоныхоо дараа man:ping[8] зэрэг хялбар хэрэгслүүдийг ашиглаад ямар ч аюулгүй байдлын тохиргоог оношилж болно.
+ 
`wpa_supplicant` нь илүү дибаг хийх дэмжлэгтэй байдаг; үүнийг `-dd` сонголттой гараар ажиллуулж системийн бүртгэлүүдийг шалгах хэрэгтэй.
* Мөн олон доод түвшний дибаг хийх хэрэгслүүд бас байдаг. Та 802.11 протоколын дэмжлэг давхаргад дибаг мэдэгдлүүдийг [.filename]#/usr/src/tools/tools/net80211# дахь `wlandebug` програмыг ашиглан идэвхжүүлж болно. Жишээ нь:
+
[source,bash]
....
# wlandebug -i ath0 +scan+auth+debug+assoc
  net.wlan.0.debug: 0 => 0xc80000<assoc,auth,scan>
....
+ 
тушаал нь хандалтын цэгүүдийг хайх болон холбоог зохион байгуулах 802.11 протоколын мэдээлэл солилцоонуудыг хийхтэй холбоотой консолын мэдэгдлүүдийг идэвхжүүлэхэд ашиглагдаж болох юм.
+ 
802.11 давхаргын арчилж байдаг олон ашигтай статистикууд бас байдаг; энэ мэдээллийг `wlanstats` хэрэгсэл харуулах болно. Эдгээр статистикууд нь 802.11 давхаргаар танигдсан бүх алдаануудыг таних ёстой. Гэхдээ 802.11 давхаргаас доош орших төхөөрөмжийн драйверууд дээр танигдсан зарим алдаанууд нь харуулагдахгүй байж болохыг санаарай. Төхөөрөмжтэй холбоотой асуудлуудыг оношлохын тулд та драйверийн баримтаас лавлах хэрэгтэй юм.

Хэрэв дээрх мэдээлэл асуудлыг тодруулахад тань туслахгүй байгаа бол дээрх хэрэгслүүдээс гарсан гаралтыг оруулж асуудлынхаа тайланг илгээгээрэй.

[[network-bluetooth]]
== Bluetooth

=== Танилцуулга

Bluetooth нь 10 метрийн дотор 2.4 GHz давтамжийн лицензжүүлээгүй зурваст ажиллах хувийн сүлжээнүүд үүсгэхэд зориулагдсан утасгүй технологи юм. Сүлжээнүүд нь үүрэн утас, гарын цахим жижиг хэрэгслүүд, болон зөөврийн компьютерууд зэрэг зөөврийн төхөөрөмжүүдээс ad-hoc ихэвчлэн бүрдүүлдэг. Бусад түгээмэл утасгүй технологиудаас ялгаатай тал нь Wi-Fi, Bluetooth нь илүү өндөр түвшний үйлчилгээний хувийн тохиргоонуудыг санал болгодог, өөрөөр хэлбэл FTP-тэй адил файлын серверүүд, файл түлхэх, дуу дамжуулалт, цуваа шугамын эмуляц зэрэг олныг дурдаж болно.

FreeBSD дэх Bluetooth стек нь Netgraph тогтолцоог ашиглан хийгдсэн байдаг (man:netgraph[4]-г үзнэ үү). Олон төрлийн Bluetooth USB хамгаалах төхөөрөмжүүд (dongle) man:ng_ubt[4] драйвераар дэмжигдсэн байдаг. Broadcom BCM2033 бичил схем дээр суурилсан Bluetooth төхөөрөмжүүд нь man:ubtbcmfw[4] болон man:ng_ubt[4] драйверуудаар дэмжигдсэн байдаг. 3Com Bluetooth PC Карт 3CRWB60-A нь man:ng_bt3c[4] драйвераар дэмжигдсэн байдаг. Цуваа болон UART дээр суурилсан Bluetooth төхөөрөмжүүд нь man:sio[4], man:ng_h4[4] болон man:hcseriald[8] драйверуудаар дэмжигдсэн. Энэ хэсэг нь USB Bluetooth dongle-ийн хэрэглээг тайлбарлах болно.

=== Төхөөрөмжид залгах нь

Анхдагчаар Bluetooth төхөөрөмжийн драйверууд нь цөмийн модуль хэлбэрээр байдаг. Төхөөрөмжийг залгахаасаа өмнө та драйверийг цөмд дуудаж ачаалах хэрэгтэй болно:

[source,bash]
....
# kldload ng_ubt
....

Хэрэв Bluetooth төхөөрөмж системийг эхлүүлэх явцад системд байх юм бол [.filename]#/boot/loader.conf# файлаас модулийг дуудна:

[.programlisting]
....
ng_ubt_load="YES"
....

Өөрийн USB dongle-ийг залга. Консол (эсвэл syslog) дээр доор дурдсантай төстэй гаралт гарч ирэх болно:

[source,bash]
....
ubt0: vendor 0x0a12 product 0x0001, rev 1.10/5.25, addr 2
ubt0: Interface 0 endpoints: interrupt=0x81, bulk-in=0x82, bulk-out=0x2
ubt0: Interface 1 (alt.config 5) endpoints: isoc-in=0x83, isoc-out=0x3,
      wMaxPacketSize=49, nframes=6, buffer size=294
....

man:service[8] нь Bluetooth стекийг эхлүүлэх болон зогсооход хэрэглэгддэг. Төхөөрөмжийг салгахаасаа өмнө стекийг зогсоох нь зөв байдаг, гэхдээ энэ нь (ихэвчлэн) сүйрлийн биш байдаг. Стекийг эхлүүлж байхад доор дурдсантай төстэй гаралтыг та хүлээн авах болно:

[source,bash]
....
# service bluetooth start ubt0
BD_ADDR: 00:02:72:00:d4:1a
Features: 0xff 0xff 0xf 00 00 00 00 00
<3-Slot> <5-Slot> <Encryption> <Slot offset>
<Timing accuracy> <Switch> <Hold mode> <Sniff mode>
<Park mode> <RSSI> <Channel quality> <SCO link>
<HV2 packets> <HV3 packets> <u-law log> <A-law log> <CVSD>
<Paging scheme> <Power control> <Transparent SCO data>
Max. ACL packet size: 192 bytes
Number of ACL packets: 8
Max. SCO packet size: 64 bytes
Number of SCO packets: 8
....

=== Host Controller Interface (HCI) буюу Хостын Хянагчийн Интерфэйс

Host Controller Interface (HCI) буюу Хостын Хянагчийн Интерфэйс нь үндсэн зурвасын хянагч болон холболтын менежерт тушаалын интерфэйсийг, тоног төхөөрөмжийн төлөв болон хяналтын регистрүүдэд хандалтыг өгдөг байна. Энэ интерфэйс нь Bluetooth-ийн үндсэн зурвасын боломжуудад хандах нэгэн хэвийн аргыг олгодог. Хост дээрх HCI давхарга нь өгөгдөл болон тушаалуудыг Bluetooth тоног төхөөрөмж дээрх HCI firmware-тэй солилцдог. Хостын Хянагчийн Тээврийн Давхаргын (өөрөөр хэлбэл физик шугам) драйвер нь HCI давхаргуудад нэг нь нөгөөдөө мэдээлэл солилцох боломжоор хангаж өгдөг.

_hci_ төрлийн ганц Netgraph цэг ганц Bluetooth төхөөрөмжийн хувьд үүсдэг. HCI цэг нь Bluetooth төхөөрөмжийн драйверийн цэгт (доош) болон L2CAP цэгт (дээш) ихэвчлэн холбогддог. Бүх HCI үйлдлүүд нь төхөөрөмжийн драйверийн цэг дээр биш HCI цэг дээр хийгдэх ёстой. HCI цэгийн анхдагч нэр нь "devicehci" юм. Илүү дэлгэрэнгүй мэдээллийг man:ng_hci[4] гарын авлагын хуудаснаас лавлана уу.

Хамгийн нийтлэг ажлуудын нэг нь RF-ийн ойр Bluetooth төхөөрөмжүүдийг олох явдал юм. Энэ үйлдлийг _inquiry_ буюу лавлагаа гэдэг. Лавлагаа болон бусад HCI-тэй холбоотой үйлдлүүд нь man:hccontrol[8] хэрэгслээр хийгддэг. Доорх жишээ нь ойр орчим ямар Bluetooth төхөөрөмжүүд байгааг хэрхэн олохыг харуулж байна. Та төхөөрөмжүүдийн жагсаалтыг хэдхэн секундэд авах ёстой. Алсын төхөөрөмж нь _илрүүлэгдэх_ горимд байгаа тохиолдолд лавлагаанд зөвхөн хариулах болно гэдгийг санаарай.

[source,bash]
....
% hccontrol -n ubt0hci inquiry
Inquiry result, num_responses=1
Inquiry result #0
       BD_ADDR: 00:80:37:29:19:a4
       Page Scan Rep. Mode: 0x1
       Page Scan Period Mode: 00
       Page Scan Mode: 00
       Class: 52:02:04
       Clock offset: 0x78ef
Inquiry complete. Status: No error [00]
....

`BD_ADDR` нь Bluetooth төхөөрөмжийн сүлжээний картанд байдаг MAC хаягууд шиг давтагдашгүй хаяг юм. Энэ хаяг нь төхөөрөмжтэй холбогдоход цаашид хэрэг болдог. BD_ADDR-т хүн уншиж болохоор нэр өгөх боломжтой байдаг. [.filename]#/etc/bluetooth/hosts# файл нь мэдэгдэж байгаа Bluetooth хостуудын тухай мэдээллийг агуулдаг. Дараах жишээ нь алсын төхөөрөмжид өгсөн хүн уншиж болохоор нэрийг хэрхэн авч болохыг үзүүлж байна:

[source,bash]
....
% hccontrol -n ubt0hci remote_name_request 00:80:37:29:19:a4
BD_ADDR: 00:80:37:29:19:a4
Name: Pav's T39
....

Хэрэв та лавлагааг алсын Bluetooth төхөөрөмж дээр хийх юм бол энэ нь таны компьютерийг "your.host.name (ubt0)" хэлбэрээр олох болно. Локал төхөөрөмжид өгсөн нэрийг ямар ч үед өөрчилж болно.

Bluetooth систем нь цэгээс-цэгт-хүрэх (point-to-point) эсвэл цэгээс-олон-цэгт-хүрэх (point-to-multipoint) холболтын боломжийг олгодог. Цэгээс-олон-цэгт-хүрэх (point-to-multipoint) холболтод холболт нь хэд хэдэн Bluetooth төхөөрөмжүүдийн хооронд хуваалцан хэрэглэгддэг. Дараах жишээ нь локал төхөөрөмжийн хувьд идэвхтэй үндсэн зурвасын холболтуудын жагсаалтыг хэрхэн авахыг үзүүлж байна:

[source,bash]
....
% hccontrol -n ubt0hci read_connection_list
Remote BD_ADDR    Handle Type Mode Role Encrypt Pending Queue State
00:80:37:29:19:a4     41  ACL    0 MAST    NONE       0     0 OPEN
....

_connection handle_ буюу _холболтын гар_ нь үндсэн зурвасын холболтыг дуусгах шаардлагатай үед ашигтай байдаг. Үүнийг гараар хийхийг ерөнхийдөө шаарддаггүйг санаарай. Стек нь идэвхгүй байгаа үндсэн зурвасын холболтуудыг автоматаар дуусгах болно.

[source,bash]
....
# hccontrol -n ubt0hci disconnect 41
Connection handle: 41
Reason: Connection terminated by local host [0x16]
....

HCI тушаалуудын бүрэн жагсаалыг `hccontrol help` гэж лавлана уу. HCI тушаалуудын ихэнх нь супер хэрэглэгчийн зөвшөөрлүүдийг шаарддаггүй.

=== Logical Link Control and Adaptation Protocol (L2CAP) буюу Логик Холболтын Хяналт ба Тааруулах Протокол

Логик Холболтын Хяналт ба Тааруулах Протокол (L2CAP) нь холболт дээр тулгуурласан болон холболтгүй (connection-oriented and connectionless) өгөгдлийн үйлчилгээнүүдийг протокол олон хуваагдах (multiplex) чадвар болон сегмент болгож дахин цуглуулах үйлдэлтэй цуг дээд түвшний протоколуудад хангаж өгдөг. L2CAP нь уртаараа 64 килобайт хүртэл хэмжээний L2CAP пакетуудыг дамжуулж хүлээн авахыг өндөр түвшний протоколууд болон програмуудад зөвшөөрдөг.

L2CAP нь _сувгууд_ гэсэн ойлголт дээр тулгуурладаг. Суваг нь үндсэн зурвасын холболт дээрх логик холболт юм. Суваг бүр ганц протоколд олноос нэг уруу чиглэсэн загвараар уягдсан байдаг. Олон сувгууд нэг протоколд уягдаж болдог боловч нэг сувгийг олон протоколд уяж болдоггүй. Суваг дээр хүлээн авсан L2CAP пакет бүр зохих дээд түвшний протокол уруу чиглүүлэгддэг. Олон сувгууд нь нэг үндсэн зурвасын холболтыг хуваалцаж болно.

_l2cap_ төрлийн ганц Netgraph цэг ганц Bluetooth төхөөрөмжийн хувьд үүсгэгддэг. L2CAP цэг нь Bluetooth HCI цэг (доош) болон Bluetooth сокетуудад (дээш) ихэвчлэн холбогддог. Илүү дэлгэрэнгүй мэдээллийг man:ng_l2cap[4] гарын авлагын хуудаснаас лавлана уу.

Ашигтай тушаал бол бусад хэрэгслүүд уруу ping хийхэд хэрэглэгддэг man:l2ping[8] тушаал юм. Зарим нэг Bluetooth шийдлүүд нь тэдэн уруу илгээсэн бүх өгөгдлийг буцаахгүй байж болох учраас дараах жишээн дээрх `0 bytes` гэдэг нь хэвийн юм.

[source,bash]
....
# l2ping -a 00:80:37:29:19:a4
0 bytes from 0:80:37:29:19:a4 seq_no=0 time=48.633 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=1 time=37.551 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=2 time=28.324 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=3 time=46.150 ms result=0
....

man:l2control[8] хэрэгсэл нь L2CAP цэгүүд дээр төрөл бүрийн үйлдлүүдийг хийдэг. Энэ жишээ нь логик холболтуудын (сувгууд) жагсаалт болон локал төхөөрөмжийн хувьд үндсэн зурвасын жагсаалтыг хэрхэн авахыг үзүүлж байна:

[source,bash]
....
% l2control -a 00:02:72:00:d4:1a read_channel_list
L2CAP channels:
Remote BD_ADDR     SCID/ DCID   PSM  IMTU/ OMTU State
00:07:e0:00:0b:ca    66/   64     3   132/  672 OPEN
% l2control -a 00:02:72:00:d4:1a read_connection_list
L2CAP connections:
Remote BD_ADDR    Handle Flags Pending State
00:07:e0:00:0b:ca     41 O           0 OPEN
....

Өөр нэг оношлогооны хэрэгсэл бол man:btsockstat[1] юм. Энэ нь man:netstat[1]-ийн хийдэгтэй төстэйг хийдэг, гэхдээ зөвхөн Bluetooth сүлжээтэй холбоотой өгөгдлийн бүтцүүдийн хувьд хийдэг. Доорх жишээ нь дээрх man:l2control[8]-ийн нэгэн адил логик холболтыг харуулж байна.

[source,bash]
....
% btsockstat
Active L2CAP sockets
PCB      Recv-Q Send-Q Local address/PSM       Foreign address   CID   State
c2afe900      0      0 00:02:72:00:d4:1a/3     00:07:e0:00:0b:ca 66    OPEN
Active RFCOMM sessions
L2PCB    PCB      Flag MTU   Out-Q DLCs State
c2afe900 c2b53380 1    127   0     Yes  OPEN
Active RFCOMM sockets
PCB      Recv-Q Send-Q Local address     Foreign address   Chan DLCI State
c2e8bc80      0    250 00:02:72:00:d4:1a 00:07:e0:00:0b:ca 3    6    OPEN
....

=== RFCOMM Протокол

RFCOMM протокол нь L2CAP протоколын дээгүүр цуваа портуудыг эмуляц хийх боломжийг хангадаг. Энэ протокол нь ETSI стандарт TS 07.10 дээр суурилсан юм. RFCOMM нь RS-232 (EIATIA-232-E) цуваа портуудын 9 замыг эмуляц хийх нэмэлт бэлтгэл бүхий ердийн тээвэрлэх протокол юм. RFCOMM протокол нь хоёр Bluetooth төхөөрөмжийн хооронд 60 хүртэлх зэрэг холболтуудыг (RFCOMM сувгууд) дэмждэг.

RFCOMM-ийн хувьд өөр өөр төхөөрөмжүүд (холбооны төгсгөлийн цэгүүд) дээр ажиллаж байгаа хоёр програм болон тэдгээрийн хоорондын холбооны сегмент холбооны бүрэн замд ордог. RFCOMM нь төхөөрөмжүүд дээр байгаа цуваа портуудыг ашигладаг програмуудад зориулагдсан юм. Холбооны сегмент нь нэг төхөөрөмжөөс нөгөө уруу холбогдсон (шууд холболт) Bluetooth холбоос юм.

RFCOMM нь шууд холболтын үед төхөөрөмжүүдийн хоорондох холболт эсвэл сүлжээний хувьд төхөөрөмж болон модемийн хоорондох холболтод зөвхөн санаа тавьдаг. RFCOMM нь нэг талдаа Bluetooth утасгүй технологийг ашиглаж холбогддог бөгөөд нөгөө талдаа утастай интерфэйсээр хангадаг модулиуд зэрэг бусад тохиргоонуудыг дэмждэг.

FreeBSD дээр RFCOMM протокол нь Bluetooth сокетуудын давхаргад хийгддэг.

=== Төхөөрөмжүүдийг хослох

Анхдагчаар Bluetooth холбоонд нэвтрэлт танилт хийгддэггүй бөгөөд ямар ч төхөөрөмж ямар ч төхөөрөмжтэй ярилцаж чаддаг. Bluetooth төхөөрөмж (жишээ нь үүрэн утас) тухайн нэг үйлчилгээг (жишээ нь Dial-Up үйлчилгээ) хангахын тулд нэвтрэлт танилтыг шаарддаг байхаар байж болно. Bluetooth нэвтрэлт танилт нь хэвийн үед _PIN кодуудаар_ хийгддэг. Хоёр төхөөрөмжийн хувьд хэрэглэгч адил PIN кодыг оруулах шаардлагатай. Хэрэглэгч PIN код оруулсны дараа хоёр төхөөрөмж _холболтын түлхүүр_ үүсгэнэ. Түүний дараа холболтын түлхүүр нь уг төхөөрөмжүүд дээрээ эсвэл байнгын хадгалалтад хадгалагдаж болно. Дараагийн удаа хоёр төхөөрөмж нь урьд нь үүсгэсэн холболтын түлхүүрээ ашиглах болно. Энэ тайлбарласан процедурыг _pairing_ буюу _хослох_ гэж нэрлэдэг. Ямар нэг төхөөрөмж холболтын түлхүүрийг гээх юм бол хослолтыг дахин хийх ёстой.

man:hcsecd[8] дэмон нь бүх Bluetooth нэвтрэлт танилтын хүсэлтүүдтэй ажиллах үүрэгтэй. Анхдагч тохиргооны файл нь [.filename]#/etc/bluetooth/hcsecd.conf# юм. Дурын "1234" гэж тохируулагдсан PIN кодтой үүрэн утасны жишээ хэсгийг доор үзүүлэв:

[.programlisting]
....
device {
        bdaddr  00:80:37:29:19:a4;
        name    "Pav's T39";
        key     nokey;
        pin     "1234";
      }
....

PIN код дээр хязгаарлалт байдаггүй (уртаас гадна). Зарим төхөөрөмжүүдэд (жишээ нь Bluetooth чихэвчнүүд) тогтмол PIN код цуг бүтээгдсэн байж болох юм. `-d` тохируулга нь man:hcsecd[8] дэмонг нүүрэнд үлдэж ажиллахыг заадаг бөгөөд ингэснээр юу болж байгааг харах боломжтой юм. Хослолыг хүлээн авч алсын төхөөрөмж уруу Bluetooth холболт эхлүүлэхээр алсын төхөөрөмжийг тохируулна. Алсын төхөөрөмж нь хослол хийлтийг хүлээн авсан гэдгээ хэлж PIN код хүсэх ёстой. [.filename]#hcsecd.conf# файлд байгаатай адил PIN код оруулаарай. Одоо таны PC болон алсын төхөөрөмж хосолсон байна. Өөрөөр та хослол хийлтийг алсын төхөөрөмж дээр эхлүүлж болно.

hcsecd-г систем эхлэхэд автоматаар эхлүүлэхийн тулд дараах мөрийг [.filename]#/etc/rc.conf# файлд нэмэн хийж болно:

[.programlisting]
....
hcsecd_enable="YES"
....

hcsecd дэмоны гаралтын жишээг доор үзүүлэв:

[.programlisting]
....
hcsecd[16484]: Got Link_Key_Request event from 'ubt0hci', remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name 'Pav's T39', link key doesn't exist
hcsecd[16484]: Sending Link_Key_Negative_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Got PIN_Code_Request event from 'ubt0hci', remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name 'Pav's T39', PIN code exists
hcsecd[16484]: Sending PIN_Code_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4
....

=== Service Discovery Protocol (SDP) буюу Үйлчилгээ Илрүүлэх Протокол

Service Discovery Protocol (SDP) буюу Үйлчилгээ Илрүүлэх Протокол нь сервер програмуудын үзүүлдэг үйлчилгээнүүдийн байгаа эсэх болон тэдгээр үйлчилгээнүүдийн шинж чанаруудыг илрүүлэх боломжийг клиент програмуудад олгодог. Үйлчилгээний шинж чанарууд нь санал болгосон үйлчилгээний төрөл эсвэл ангилал болон үйлчилгээг хэрэглэхэд шаардагдах арга зам юм уу эсвэл протоколын мэдээллийг агуулдаг.

SDP-д SDP сервер болон SDP клиентийн хоорондох холбоо ордог. Сервер нь сервертэй холбоотой үйлчилгээнүүдийн шинж чанаруудыг тайлбарладаг үйлчилгээний бичлэгүүдийн жагсаалтыг арчилж байдаг. Үйлчилгээний бичлэг бүр ганц үйлчилгээний талаар мэдээллийг агуулдаг. SDP серверийн арчилж байдаг үйлчилгээний бичлэгээс клиент SDP хүсэлт илгээн мэдээллийг авч болно. Хэрэв клиент эсвэл клиенттэй холбоотой програм нь үйлчилгээг ашиглахаар шийдвэл үйлчилгээг хэрэглэхийн тулд үйлчилгээ үзүүлэгч уруу тусдаа холболт нээх ёстой. SDP нь үйлчилгээнүүд болон тэдгээрийн шинж чанаруудыг илрүүлэх арга замаар хангадаг боловч тэдгээр үйлчилгээнүүдийг хэрэглэх арга замуудаар хангадаггүй юм.

Хэвийн үед SDP клиент нь үйлчилгээнүүдийн зарим хүссэн онцгой шинжүүд дээр тулгуурлан үйлчилгээнүүдийг хайдаг. Гэхдээ үйлчилгээнүүдийн талаар урьд нь ямар ч мэдээлэл байхгүй байхад SDP серверийн үйлчилгээний бичлэгүүдээр тайлбарлагдсан үйлчилгээнүүдийн ямар төрлүүд байгааг олохыг хүсэх үеүүд байдаг. Санал болгосон дурын үйлчилгээнүүдийг хайх процесс нь _browsing_ буюу _үзэх_ гэгддэг.

Bluetooth SDP сервер man:sdpd[8] болон тушаалын мөрийн клиент man:sdpcontrol[8] нь стандарт FreeBSD суулгацад орсон байдаг. Дараах жишээ нь SDP үзэх хүсэлтийг хэрхэн хийж байгаа харуулж байна.

[source,bash]
....
% sdpcontrol -a 00:01:03:fc:6e:ec browse
Record Handle: 00000000
Service Class ID List:
        Service Discovery Server (0x1000)
Protocol Descriptor List:
        L2CAP (0x0100)
                Protocol specific parameter #1: u/int/uuid16 1
                Protocol specific parameter #2: u/int/uuid16 1

Record Handle: 0x00000001
Service Class ID List:
        Browse Group Descriptor (0x1001)

Record Handle: 0x00000002
Service Class ID List:
        LAN Access Using PPP (0x1102)
Protocol Descriptor List:
        L2CAP (0x0100)
        RFCOMM (0x0003)
                Protocol specific parameter #1: u/int8/bool 1
Bluetooth Profile Descriptor List:
        LAN Access Using PPP (0x1102) ver. 1.0
....

... гэх мэт байна. Үйлчилгээ болгон шинж чанаруудтай байгааг анхаараарай (жишээ нь RFCOMM суваг). Үйлчилгээнээс хамаараад та зарим нэг шинж чанаруудын талаар тэмдэглэгээ хийж авах хэрэгтэй болж болох юм. Зарим Bluetooth шийдлүүд нь үйлчилгээ үзэх боломжийг дэмждэггүй бөгөөд хоосон жагсаалт буцааж болох юм. Энэ тохиолдолд тодорхой үйлчилгээг хайх боломжтой байдаг. Доорх жишээ нь OBEX-ийн Обьект Түлхэх (OPUSH) үйлчилгээг хэрхэн хайхыг үзүүлж байна:

[source,bash]
....
% sdpcontrol -a 00:01:03:fc:6e:ec search OPUSH
....

FreeBSD дээр Bluetooth клиентүүдэд үйлчилгээнүүдийг санал болохдоо man:sdpd[8] серверийн тусламжтайгаар хийдэг. [.filename]#/etc/rc.conf# файлд дараах мөрийг нэмж болно:

[.programlisting]
....
sdpd_enable="YES"
....

Дараа нь sdpd дэмонг ингэж эхлүүлж болно:

[source,bash]
....
# service sdpd start
....

Алсын клиентүүдэд Bluetooth үйлчилгээг үзүүлэхийг хүссэн локал серверийн програм нь үйлчилгээг SDP дэмонд бүртгэх болно. Ийм програмуудын нэг нь man:rfcomm_pppd[8] юм. Эхэлснийхээ дараа энэ нь Bluetooth LAN үйлчилгээг локал SDP дэмонд бүртгэх болно.

Локал SDP серверт бүртгэсэн үйлчилгээнүүдийн жагсаалтыг локал хяналтын сувгаар SDP-ийн үзэх хүсэлтийг илгээн авч болно:

[source,bash]
....
# sdpcontrol -l browse
....

=== Dial-Up сүлжээ (DUN) ба PPP ашиглах Сүлжээний Хандалт (LAN) хувийн тохиргоонууд

Dial-Up сүлжээ (DUN) хувийн тохиргоо нь модемууд болон үүрэн утаснуудтай ихэвчлэн ашиглагддаг. Энэ хувийн тохиргоонд хамаарах тохиолдлуудыг доор дурдав:

* үүрэн утас эсвэл модемийг компьютер дээрээ Интернэтийн хандалтын сервер уруу залгаж холбогдох юм уу эсвэл бусад dial-up үйлчилгээнүүдэд хэрэглэхээр утасгүй модем маягаар ашиглах;
* үүрэн утас эсвэл модемийг компьютер дээрээ өгөгдлийн дуудлагуудыг хүлээн авахад ашиглах.

PPP ашиглах Сүлжээний Хандалт (LAN) хувийн тохиргоо дараах тохиолдлуудад ашиглагдаж болно:

* Ганц Bluetooth төхөөрөмжид зориулсан LAN хандалт; 
* Олон Bluetooth төхөөрөмжид зориулсан LAN хандалт; 
* PC-ээс PC уруу (цуваа кабелийн эмуляцаар PPP сүлжээ ашиглан).

FreeBSD дээр энэ хоёр хувийн тохиргоо нь man:ppp[8] болон man:rfcomm_pppd[8] програмуудаар хийгддэг. man:rfcomm_pppd[8] нь RFCOMM Bluetooth холболтыг PPP-ийн ажиллаж чадах ямар нэгэн зүйл болгож хувиргадаг гүйцэтгэл хялбаршуулагч юм. Аль ч хувийн тохиргоог ашиглахаасаа өмнө [.filename]#/etc/ppp/ppp.conf# файлд шинэ PPP хаяг үүсгэгдсэн байх ёстой. Жишээнүүдийн талаар man:rfcomm_pppd[8] гарын авлагаас лавлана уу. 

Дараах жишээн дээр man:rfcomm_pppd[8] нь DUN RFCOMM суваг дээр BD_ADDR 00:80:37:29:19:a4 хаягтай алсын төхөөрөмж уруу RFCOMM холболт хийхэд ашиглагдах болно. RFCOMM сувгийн дугаарыг алсын төхөөрөмжөөс SDP-ээр авах болно. RFCOMM сувгийг гараар зааж өгөх боломжтой бөгөөд энэ тохиолдолд man:rfcomm_pppd[8] нь SDP хүсэлт хийхгүй байх болно. Алсын төхөөрөмж дээр RFCOMM сувгийг олохын тулд man:sdpcontrol[8]-г ашиглаарай.

[source,bash]
....
# rfcomm_pppd -a 00:80:37:29:19:a4 -c -C dun -l rfcomm-dialup
....

PPP ашиглах Сүлжээний Хандалтын (LAN) үйлчилгээг хангахын тулд man:sdpd[8] сервер ажиллаж байх ёстой. LAN клиентүүдэд зориулсан шинэ оруулгууд [.filename]#/etc/ppp/ppp.conf# файлд үүсгэгдсэн байх ёстой. Жишээнүүдийн талаар man:rfcomm_pppd[8] гарын авлагын хуудаснаас лавлана уу. Төгсгөлд нь RFCOMM PPP серверийг зөв RFCOMM сувгийн дугаар дээр эхлүүлнэ. RFCOMM PPP сервер нь Bluetooth LAN үйлчилгээг локал SDP дэмонд автоматаар бүртгэх болно. Доорх жишээ нь RFCOMM PPP серверийг хэрхэн эхлүүлэхийг үзүүлж байна.

[source,bash]
....
# rfcomm_pppd -s -C 7 -l rfcomm-server
....

=== OBEX Object Push (OPUSH) буюу OBEX Обьект Түлхэх хувийн тохиргоо

OBEX нь хөдөлгөөнт төхөөрөмжүүдийн хооронд энгийн файл дамжуулалт хийхэд зориулагдсан өргөн ашиглагддаг протокол юм. Үүний гол хэрэглээ нь хэт ягаан туяаны холбоо бөгөөд зөөврийн компьютерууд эсвэл PDA-уудын хооронд ердийн файл дамжуулахад, нэрийн хуудас эсвэл цагалбарыг үүрэн утас болон PIM програмуудтай бусад төхөөрөмжүүдийн хооронд илгээхэд хэрэглэгддэг.

OBEX сервер болон клиент нь гуравдагч талын багц obexapp хэлбэрээр хийгдсэн байдаг бөгөөд энэ нь package:comms/obexapp[] порт хэлбэрээр байдаг.

OBEX клиент нь OBEX серверт обьектуудыг түлхэж оруулах буюу/эсвэл татахад хэрэглэгддэг. Обьект нь жишээ нь нэрийн хуудас юм уу эсвэл уулзалт байж болно. OBEX клиент нь алсын төхөөрөмжөөс SDP-ээр RFCOMM сувгийн дугаарыг авч болно. RFCOMM сувгийн дугаарын оронд үйлчилгээний нэрийг зааж үүнийг хийж болно. Дэмжигдсэн үйлчилгээний нэрсэд: IrMC, FTRN, болон OPUSH ордог. RFCOMM сувгийг дугаар болгон зааж өгөх боломжтой байдаг. Төхөөрөмжийн мэдээллийн обьектийг үүрэн утаснаас татаж авч байгаа болон шинэ обьектийг (нэрийн хуудас) утасны сан уруу хийж байгаа OBEX сессийн жишээг доор үзүүлэв.

[source,bash]
....
% obexapp -a 00:80:37:29:19:a4 -C IrMC
obex> get telecom/devinfo.txt devinfo-t39.txt
Success, response: OK, Success (0x20)
obex> put new.vcf
Success, response: OK, Success (0x20)
obex> di
Success, response: OK, Success (0x20)
....

OBEX-ийн Обьект Түлхэх үйлчилгээг хангахын тулд man:sdpd[8] сервер ажиллаж байх ёстой. Бүх ирж байгаа обьектууд хадгалагдах root хавтас үүсгэгдэх ёстой. root сангийн анхдагч зам нь [.filename]#/var/spool/obex# байна. Төгсгөлд нь OBEX серверийг зөв RFCOMM сувгийн дугаар дээр эхлүүлнэ. OBEX сервер нь OBEX-ийн Обьект Түлхэх үйлчилгээг локал SDP дэмонд автоматаар бүртгүүлэх болно. Доорх жишээ нь OBEX серверийг хэрхэн эхлүүлэхийг харуулж байна.

[source,bash]
....
# obexapp -s -C 10
....

=== Serial Port Profile (SPP) буюу Цуваа портын хувийн тохиргоо

Serial Port Profile (SPP) буюу Цуваа портын хувийн тохиргоо нь Bluetooth төхөөрөмжүүдэд RS232 (эсвэл түүнтэй төстэй) цуваа кабелийн эмуляц хийхийг зөвшөөрдөг. Энэ хувийн тохиргоонд хамаатай тохиолдол нь кабелийн оронд виртуал цуваа портын хийсвэрлэлтийн тусламжтай Bluetooth-ийг ашигладаг хуучин програмуудтай харьцдаг.

man:rfcomm_sppd[1] хэрэгсэл нь цуваа портын хувийн тохиргоог хийдэг. Псевдо tty нь виртуал цуваа портын хийсвэрлэлт болон ашиглагддаг. Доорх жишээ нь алсын төхөөрөмжийн цуваа портын үйлчилгээ уруу хэрхэн холбогдохыг харуулж байна. Та RFCOMM сувгийг заах шаардлагагүйг санаарай - man:rfcomm_sppd[1] нь алсын төхөөрөмжөөс SDP-ээр авч чаддаг. Хэрэв та үүнийг дарж өөрчлөхийг хүсвэл тушаалын мөрөнд RFCOMM сувгийг зааж өгөх хэрэгтэй.

[source,bash]
....
# rfcomm_sppd -a 00:07:E0:00:0B:CA -t /dev/ttyp6
rfcomm_sppd[94692]: Starting on /dev/ttyp6...
....

Холбогдсоны дараа псевдо tty нь цуваа порт шиг ашиглагдаж болно:

[source,bash]
....
# cu -l ttyp6
....

=== Алдааг олж засварлах

==== Алсын төхөөрөмж холбогдож чадахгүй байх

Зарим нэг хуучин Bluetooth төхөөрөмжүүд нь үүрэг шилжүүлэлтийг дэмждэггүй. Анхдагчаар FreeBSD нь шинэ холболтыг хүлээн авахдаа үүргийг өөрчилж мастер болохыг оролддог. Үүнийг дэмждэггүй төхөөрөмжүүд нь холбогдож чаддаггүй. Шинэ холболт хийгдэхэд үүрэг шилжүүлэлт хийгддэгийг санаарай. Тийм учраас алсын төхөөрөмжөөс үүрэг шилжүүлэлтийг дэмждэг эсэхийг нь асуух боломжгүй юм. Локал тал дээрээ үүрэг шилжүүлэлтийг хаах HCI тохируулга байдаг:

[source,bash]
....
# hccontrol -n ubt0hci write_node_role_switch 0
....

==== Ямар нэгэн юм буруу болоод байна, би яг юу болоод байгааг харж болох уу?

Тиймээ, та харж болно. package:comms/hcidump[] порт хэлбэрээр байдаг гуравдагч талын багц hcidump-г ашиглана. hcidump хэрэгсэл нь man:tcpdump[1]-тай төстэй. Энэ нь Bluetooth пакетуудын агуулгыг терминал дээр харуулж Bluetooth пакетуудыг файл уруу гаргахад хэрэглэгдэж болно.

[[network-bridging]]
== Гүүр

=== Танилцуулга

Заримдаа нэг физик сүлжээг (Ethernet сегмент зэрэг) IP дэд сүлжээнүүд үүсгэж сегментүүдийг хооронд нь чиглүүлэгчээр цугт нь холбож ашиглалгүйгээр хоёр тусдаа сүлжээний сегмент болгох нь ашигтай байдаг. Ийм маягаар хоёр сүлжээг хооронд нь холбодог төхөөрөмжийг "bridge" буюу "гүүр" гэдэг. Хоёр сүлжээний интерфэйс карттай FreeBSD систем гүүр маягаар ажиллаж чаддаг.

Гүүр нь өөрийн сүлжээний интерфэйс бүрийн төхөөрөмжийн MAC давхаргын хаягуудыг (Ethernet хаягууд) сурч ажилладаг. Түүний эх болон төгсгөл нь зөвхөн өөр өөр сүлжээнд байгаа тохиолдолд хоёр сүлжээний хооронд урсгалыг дамжуулдаг.

Олон талаараа гүүр нь маш цөөн порттой Ethernet шилжүүлэгчтэй адил юм.

=== Гүүр хийхэд тохирох тохиолдлууд

Өнөөдөр гүүр ашиглагддаг олон нийтлэг тохиолдол байдаг.

==== Сүлжээнүүдийг холбох нь

Гүүрний үндсэн үйлдэл нь хоёр буюу түүнээс олон сүлжээний сегментүүдийг хооронд нь холбох явдал юм. Кабелийн хязгаарлалт, галт хана хийх эсвэл виртуал машины интерфэйс зэрэг псевдо сүлжээнүүдийг холбох зэрэг сүлжээний энгийн төхөөрөмжийн оронд хост дээр тулгуурласан гүүрийг ашиглах шалтгаан олон байдаг. Гүүр нь бас hostap горимд ажиллаж байгаа утасгүй сүлжээний интерфэйсийг утастай сүлжээ рүү холбож хандалтын цэг маягаар ажиллах чадвартай.

==== Шүүх/урсгал хэлбэржүүлэх галт хана

Нийтлэг тохиолдол бол чиглүүлэлт юм уу эсвэл сүлжээний хаягийн хөрвүүлэлтгүй (NAT) галт ханын ажиллагаа шаардлагатай тохиолдол юм.

Үүний жишээ нь DSL юм уу эсвэл ISDN-ээр ISP уруугаа холбогдсон жижиг компани юм. Тэд 13 ширхэг гаднаас хандах боломжтой IP хаягийг өөрсдийн ISP-ээс авдаг бөгөөд сүлжээндээ 10 PC-тэй. Энэ тохиолдолд чиглүүлэгч дээр тулгуурласан галт хана нь дэд сүлжээний асуудлуудаас болоод төвөгтэй байна.

Гүүр дээр тулгуурласан галт ханыг тохируулж тэдний DSL/ISDN чиглүүлэгчийн замд ямар нэгэн IP хаяглалтын асуудалгүйгээр тавьж болно.

==== Сүлжээ сонсогч (Network tap)

Гүүр нь сүлжээний хоёр сегментийг холбож тэдгээрийн хооронд дамжиж байгаа бүх Ethernet урсгалыг шалгахад хэрэглэгдэж болно. Энэ нь гүүр интерфэйс дээр man:bpf[4]/man:tcpdump[1] ашиглах юм уу эсвэл бүх урсгалын хуулбарыг нэмэлт интерфэйс (span порт) уруу илгээх замаар байж болно.

==== Түвшин 2 VPN

Хоёр Ethernet сүлжээ нь IP холбоосын дагуу EtherIP туннель юм уу эсвэл OpenVPN зэрэг man:tap[4] дээр тулгуурласан шийдлүүдийн тусламжтайгаар холбогдож болно.

==== Түвшин 2 Давхцал

Сүлжээ нь хоорондоо олон холбоосоор холбогдож давхацсан замуудыг хаахын тулд Spanning Tree протоколыг ашиглаж болно. Ethernet сүлжээ нь зөв ажилладаг байхын тулд хоёр төхөөрөмжийн хооронд зөвхөн нэг идэвхтэй зам байх ёстой байдаг бөгөөд Spanning Tree нь давталтыг илрүүлж давхацсан холбоосуудыг хаалттай төлөвт оруулдаг. Аль нэг идэвхтэй холбоос амжилтгүй болсон тохиолдолд уг протокол өөр модыг тооцоолж сүлжээн дэх бүх цэгүүдэд хүрэх холболтыг сэргээхийн тулд аль нэг хаалттай замыг дахин идэвхжүүлдэг.

=== Цөмийн тохиргоо

Энэ хэсэг нь man:if_bridge[4] гүүрний шийдлийн тухай өгүүлэх болно, netgraph гүүрний драйвер бас байдаг бөгөөд илүү дэлгэрэнгүй мэдээллийг man:ng_bridge[4] гарын авлагын хуудаснаас үзнэ үү.

Гүүрний драйвер нь цөмийн модуль бөгөөд man:ifconfig[8]-оор гүүр интерфэйсийг үүсгэх үед автоматаар дуудагддаг. Өөрийн цөмийн тохиргооны файлд `device if_bridge` гэж нэмэн гүүрийг цөмд эмхэтгэж болно.

man:pfil[9] тогтолцоогоор холбогддог галт ханын дурын багцтай пакет шүүлтийг ашиглаж болдог. Галт хана нь модуль хэлбэрээр дуудагдах юм уу эсвэл цөмд эмхэтгэгдэж болно.

Гүүр нь man:altq[4] эсвэл man:dummynet[4]-тэй цуг урсгал хэлбэржүүлэгч болон ашиглагдаж болно.

=== Гүүрийг идэвхжүүлэх нь

Интерфэйс хуулбарлалтыг ашиглан гүүрийг үүсгэдэг. Гүүрийг үүсгэхийн тулд man:ifconfig[8]-ийг ашиглана. Хэрэв гүүрний драйвер цөмд байхгүй бол автоматаар дуудагддаг.

[source,bash]
....
# ifconfig bridge create
bridge0
# ifconfig bridge0
bridge0: flags=8802<BROADCAST,SIMPLEX,MULTICAST> metric 0 mtu 1500
        ether 96:3d:4b:f1:79:7a
        id 00:00:00:00:00:00 priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 timeout 1200
        root id 00:00:00:00:00:00 priority 0 ifcost 0 port 0
....

Гүүр интерфэйс үүсч түүнд санамсаргүйгээр үүсгэгдсэн Ethernet хаяг автоматаар өгөгддөг. `maxaddr` болон `timeout` нэмэлт өгөгдлүүд нь өөрийн дамжуулах хүснэгтэд хичнээн MAC хаягийг хадгалах болон сүүлд харагдсанаасаа хойш оруулга бүр хичнээн секундын дараа устгагдах вэ гэдгийг хянадаг. Бусад нэмэлт өгөгдлүүд нь Spanning Tree хэрхэн ажиллахыг хянадаг.

Гишүүн сүлжээний интерфэйсийг гүүрэнд нэмэх хэрэгтэй. Гүүрний хувьд пакетуудыг дамжуулахын тулд бүх гишүүн интерфэйсүүд болон гүүр өөрөө идэвхжсэн байх шаардлагатай:

[source,bash]
....
# ifconfig bridge0 addm fxp0 addm fxp1 up
# ifconfig fxp0 up
# ifconfig fxp1 up
....

Гүүр нь одоо Ethernet хүрээнүүдийг [.filename]#fxp0# болон [.filename]#fxp1#-ийн хооронд дамжуулж байна. Гүүр нь ачаалах үед үүсгэгдэх [.filename]#/etc/rc.conf#-ийн тохиргоо ийм байна:

[.programlisting]
....
cloned_interfaces="bridge0"
ifconfig_bridge0="addm fxp0 addm fxp1 up"
ifconfig_fxp0="up"
ifconfig_fxp1="up"
....

Хэрэв гүүр хостод IP хаяг хэрэгтэй бол үүнийг тохируулах зөв газар бол гишүүн интерфэйсийн аль нэг биш харин гүүр интерфэйс өөрөө юм. Үүнийг статикаар эсвэл DHCP-ээр тохируулж болно:

[source,bash]
....
# ifconfig bridge0 inet 192.168.0.1/24
....

Гүүр интерфэйсд IPv6 хаягийг өгч бас болно.

=== Галт хана

Пакет шүүлт идэвхжсэн тохиолдолд гүүр хийгдсэн пакетууд нь гарч байгаа интерфэйс ба гүүр интерфэйс дээрээ гарах шүүлтээр, тохирох интерфэйс дээрээ орох шүүлтээр дамждаг. Аль ч шатыг хааж болдог. Пакетийн урсгалын чиглэл нь чухал бол гүүрэн дээр галт хана хийснээс гишүүн интерфэйсүүд дээр хийсэн нь дээр байдаг.

Гүүр нь IP бус ба ARP пакетуудыг дамжуулах болон IPFW-ийн тусламжтай хийгдэх хоёрдугаар түвшний галт хананд зориулсан хэд хэдэн тохируулж болох тохируулгуудтай байдаг. Дэлгэрэнгүй мэдээллийг man:if_bridge[4]-ээс үзнэ үү.

=== Spanning Tree

Гүүрний драйвер нь хуучин Spanning Tree Протоколтой (STP) нийцтэй Rapid Spanning Tree Protocol (RSTP эсвэл 802.1w) буюу Түргэн Spanning Tree Протоколыг хийж гүйцэтгэсэн байдаг. Spanning Tree нь сүлжээн дэх давталтуудыг илрүүлж арилгахад хэрэглэгддэг. RSTP нь хуучин STP-г бодох юм бол илүү түргэн нийлэх боломжийг олгодог. Энэ протокол нь давхцал үүсгэлгүйгээр дамжуулалтад хурдан шилжихийн тулд хөрш шилжүүлэгчидтэйгээ мэдээлэл солилцдог. FreeBSD нь RSTP болон STP-г ажиллах горим хэлбэрээр дэмждэг бөгөөд RSTP нь анхдагч горим юм.

Spanning Tree-г `stp` тушаал ашиглан гишүүн интерфэйсүүд дээр идэвхжүүлж болно. Одоо [.filename]#fxp0# болон [.filename]#fxp1# интерфэйсүүдтэй гүүрний хувьд STP-г идэвхжүүлэхийн тулд доор дурдсаныг хийнэ:

[source,bash]
....
# ifconfig bridge0 stp fxp0 stp fxp1
bridge0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500
        ether d6:cf:d5:a0:94:6d
        id 00:01:02:4b:d4:50 priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 timeout 1200
        root id 00:01:02:4b:d4:50 priority 32768 ifcost 0 port 0
        member: fxp0 flags=1c7<LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP>
                port 3 priority 128 path cost 200000 proto rstp
                role designated state forwarding
        member: fxp1 flags=1c7<LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP>
                port 4 priority 128 path cost 200000 proto rstp
                role designated state forwarding
....

Энэ гүүр нь `00:01:02:4b:d4:50` гэсэн ID болон `32768` гэсэн ээлж бүхий spanning tree-тэй байна. `root id` адил байгаа нь модны хувьд root гүүр гэдгийг илтгэж байна.

Сүлжээн дэх өөр нэг гүүр бас идэвхжсэн spanning tree-тэй байна:

[source,bash]
....
bridge0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500
        ether 96:3d:4b:f1:79:7a
        id 00:13:d4:9a:06:7a priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 timeout 1200
        root id 00:01:02:4b:d4:50 priority 32768 ifcost 400000 port 4
        member: fxp0 flags=1c7<LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP>
                port 4 priority 128 path cost 200000 proto rstp
                role root state forwarding
        member: fxp1 flags=1c7<LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP>
                port 5 priority 128 path cost 200000 proto rstp
                role designated state forwarding
....

`root id 00:01:02:4b:d4:50 priority 32768 ifcost 400000 port 4` мөр нь root гүүр нь дээр дурдсантай адил `00:01:02:4b:d4:50` бөгөөд энэ гүүрнээс `400000` гэсэн замын өртөгтэй, root гүүр рүү хүрэх зам нь [.filename]#fxp0# болох `port 4`-өөр дамжина гэдгийг үзүүлж байна.

=== Гүүрний нэмэлт тохиргоо

==== Урсгалыг бүтээх/шинэчлэх

Гүүр нь монитор буюу хянах горимыг дэмждэг бөгөөд энэ горимд пакетууд нь man:bpf[4] процесс хийгдсэний дараа хаягдаж цааш процесс хийгдэхгүй эсвэл дамжуулагдахгүй болдог. Хоёр буюу түүнээс дээш тооны интерфэйсүүдийн оролтыг нэгтгэж нэг man:bpf[4] урсгал руу гаргахад үүнийг ашиглаж болно. RX/TX дохионуудыг гадагш хоёр тусдаа интерфэйсээр дамжуулах сүлжээний сонсогчид зориулсан урсгал бүтээхэд энэ нь ашигтай байдаг.

Сүлжээний дөрвөн интерфэйсээс оролтыг нэг урсгал уруу уншихын тулд:

[source,bash]
....
# ifconfig bridge0 addm fxp0 addm fxp1 addm fxp2 addm fxp3 monitor up
# tcpdump -i bridge0
....

==== Span портууд

Гүүрний хүлээн авсан Ethernet хүрээ бүрийн хуулбар томилогдсон span порт уруу дамждаг. Гүүрэн дээр тохируулагдсан span портуудын тоо хязгааргүй байдаг, хэрэв интерфэйс нь span порт гэж томилогдсон бол энэ нь ердийн гүүрний порт маягаар ашиглагдах боломжгүй байж болох юм. Энэ нь гүүрний аль нэг span порт руу холбогдсон өөр нэг хост дээрээс гүүр хийгдсэн сүлжээг идэвхгүйгээр хулгайгаар үзэхэд их ашигтай байдаг.

Бүх хүрээнүүдийн хуулбарыг [.filename]#fxp4# гэж нэрлэгдсэн интерфэйс рүү илгээхийн тулд:

[source,bash]
....
# ifconfig bridge0 span fxp4
....

==== Хувийн интерфэйсүүд

Хувийн интерфэйс нь бусад хувийн интерфэйсүүд рүү ямар ч урсгалыг дамжуулдаггүй. Урсгал нь ямар нэг нөхцөлгүйгээр хаагддаг бөгөөд ARP зэрэг ямар ч Ethernet хүрээнүүд дамжуулагдахгүй. Хэрэв урсгал нь сонголтын дагуу хаагдах хэрэгтэй бол үүний оронд галт хана ашиглах ёстой байдаг.

==== Наалттай интерфэйсүүд

Хэрэв гүүрний гишүүн интерфэйс нь наалттай гэж тэмдэглэгдсэн бол динамикаар тогтоосон хаягийн оруулгуудыг дамжуулалтын кэшд ороход статик гэж үздэг. Хаяг өөр интерфэйс дээр үзэгдсэн байлаа ч гэсэн наалттай оруулгууд нь хэзээ ч кэшээс гарч хуучирдаггүй эсвэл солигддоггүй. Энэ нь дамжуулалтын хүснэгтийг урьдчилан нутагшуулах шаардлагагүй болгож статик хаягийн оруулгуудын ашгийг өгдөг бөгөөд гүүрний тодорхой нэг сегмент дээр тогтоогдсон хэрэглэгчид өөр сегмент рүү тэнүүчилж чаддаггүй.

Наалттай хаягуудыг ашиглах өөр нэг жишээ нь IP хаягийн талбарыг дэмий үрэлгүйгээр хэрэглэгчийн сүлжээнүүд нь тусгаарлагдсан чиглүүлэгчийг үүсгэхийн тулд гүүрийг VLAN-уудтай нэгтгэх явдал юм. `CustomerA` нь `vlan100` дээр `CustomerB` нь `vlan101` дээр гэж үзье. Гүүр нь `192.168.0.1` гэсэн хаягтай бөгөөд бас интернэт чиглүүлэгч юм.

[source,bash]
....
# ifconfig bridge0 addm vlan100 sticky vlan100 addm vlan101 sticky vlan101
# ifconfig bridge0 inet 192.168.0.1/24
....

Хоёр клиент хоёулаа `192.168.0.1`-г өөрсдийн анхдагч гарц гэж харах бөгөөд гүүрний кэш нь наалттай болохоор тэд өөрсдийн урсгалыг дундаас нь оруулах гэж нөгөө хэрэглэгчийнхээ MAC хаягийг ашиглан хуурч чадахгүй юм.

VLAN-уудын хоорондох ямар ч холбоог хувийн интерфэйсүүд (эсвэл галт хана) ашиглан хааж болно:

[source,bash]
....
# ifconfig bridge0 private vlan100 private vlan101
....

Хэрэглэгчид нь нэг нэгнээсээ бүр мөсөн тусгаарлагдсан бөгөөд бүх `/24` хаягийн бүсийг дэд сүлжээ болгон хуваалгүйгээр хуваарилж болно.

==== Хаягийн хязгаарууд

Интерфэйсийн цаана байгаа давтагдашгүй эх MAC хаягуудын тоо хязгаартай байж болно. Тэр хязгаарт хүрэх үед мэдэгдэхгүй эх хаягтай пакетууд нь тухайн үед байгаа хостын кэш оруулгын хугацаа дуусах юм уу эсвэл устгагдах хүртэл хаягдсаар байх болно.

Доор дурдсан жишээ нь `vlan100` дээр байгаа `CustomerA`-д зориулж Ethernet төхөөрөмжүүдийн хамгийн их тоог 10 болгон тохируулж байна.

[source,bash]
....
# ifconfig bridge0 ifmaxaddr vlan100 10
....

==== SNMP монитор хийх

Гүүр интерфэйс болон STP параметрүүдийг FreeBSD-ийн үндсэн системд орсон байдаг SNMP демоны тусламжтайгаар монитор хийж болно. Экспорт хийгдсэн гүүрний MIB-үүд нь IETF-ийн стандартуудыг хангаж байдаг. Тийм болохоор дурын SNMP клиент эсвэл монитор хийдэг багцыг өгөгдлийг хүлээн авахад хэрэглэж болно.

Гүүр машин дээр [.filename]#/etc/snmp.config# файлд `begemotSnmpdModulePath."bridge" = "/usr/lib/snmp_bridge.so"` мөрийг тайлбар болгосныг болиулж bsnmpd дэмоныг эхлүүлэх хэрэгтэй. Community буюу нийгмийн нэрс болон хандалтын жагсаалтууд зэрэг бусад тохиргоонуудыг өөрчлөх шаардлагатай байж болно. Дэлгэрэнгүй мэдээллийг man:bsnmpd[1] болон man:snmp_bridge[3]-с үзнэ үү.

Доор дурдсан жишээнүүд нь гүүрэнд хүсэлт илгээхийн тулд Net-SNMP програм хангамжийг (package:net-mgmt/net-snmp[]) ашиглаж байгаа бөгөөд package:net-mgmt/bsnmptools[] портыг бас ашиглаж болно. Гүүрний MIB тодорхойлолтуудыг Net-SNMP руу оруулж ирэхийн тулд SNMP клиент хост дээрээ [.filename]#$HOME/.snmp/snmp.conf# файлд доор дурдсан мөрүүдийг нэмэх хэрэгтэй:

[.programlisting]
....
mibdirs +/usr/shared/snmp/mibs
mibs +BRIDGE-MIB:RSTP-MIB:BEGEMOT-MIB:BEGEMOT-BRIDGE-MIB
....

Ганц гүүрийг IETF BRIDGE-MIB (RFC4188)-ээр монитор хийхийн тулд доор дурдсаныг хийнэ

[source,bash]
....
% snmpwalk -v 2c -c public bridge1.example.com mib-2.dot1dBridge
BRIDGE-MIB::dot1dBaseBridgeAddress.0 = STRING: 66:fb:9b:6e:5c:44
BRIDGE-MIB::dot1dBaseNumPorts.0 = INTEGER: 1 ports
BRIDGE-MIB::dot1dStpTimeSinceTopologyChange.0 = Timeticks: (189959) 0:31:39.59 centi-seconds
BRIDGE-MIB::dot1dStpTopChanges.0 = Counter32: 2
BRIDGE-MIB::dot1dStpDesignatedRoot.0 = Hex-STRING: 80 00 00 01 02 4B D4 50
...
BRIDGE-MIB::dot1dStpPortState.3 = INTEGER: forwarding(5)
BRIDGE-MIB::dot1dStpPortEnable.3 = INTEGER: enabled(1)
BRIDGE-MIB::dot1dStpPortPathCost.3 = INTEGER: 200000
BRIDGE-MIB::dot1dStpPortDesignatedRoot.3 = Hex-STRING: 80 00 00 01 02 4B D4 50
BRIDGE-MIB::dot1dStpPortDesignatedCost.3 = INTEGER: 0
BRIDGE-MIB::dot1dStpPortDesignatedBridge.3 = Hex-STRING: 80 00 00 01 02 4B D4 50
BRIDGE-MIB::dot1dStpPortDesignatedPort.3 = Hex-STRING: 03 80
BRIDGE-MIB::dot1dStpPortForwardTransitions.3 = Counter32: 1
RSTP-MIB::dot1dStpVersion.0 = INTEGER: rstp(2)
....

`dot1dStpTopChanges.0`-ийн утга хоёр бөгөөд энэ нь STP гүүрний бүтэц хоёр удаа өөрчлөгдсөн гэдгийг харуулж байна. Бүтцийн өөрчлөлт гэдэг нь сүлжээн дэх нэг буюу олон холбоосууд өөрчлөгдсөн юм уу эсвэл амжилтгүй болсон бөгөөд шинэ мод тооцоологдсон гэсэн үг юм. `dot1dStpTimeSinceTopologyChange.0`-ийн утга ийм зүйл хэзээ болсныг харуулах болно.

Олон гүүрний интерфэйсийг монитор хийхийн тулд хувийн BEGEMOT-BRIDGE-MIB-г ашиглаж болно:

[source,bash]
....
% snmpwalk -v 2c -c public bridge1.example.com
enterprises.fokus.begemot.begemotBridge
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseName."bridge0" = STRING: bridge0
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseName."bridge2" = STRING: bridge2
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseAddress."bridge0" = STRING: e:ce:3b:5a:9e:13
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseAddress."bridge2" = STRING: 12:5e:4d:74:d:fc
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseNumPorts."bridge0" = INTEGER: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseNumPorts."bridge2" = INTEGER: 1
...
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTimeSinceTopologyChange."bridge0" = Timeticks: (116927) 0:19:29.27 centi-seconds
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTimeSinceTopologyChange."bridge2" = Timeticks: (82773) 0:13:47.73 centi-seconds
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTopChanges."bridge0" = Counter32: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTopChanges."bridge2" = Counter32: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeStpDesignatedRoot."bridge0" = Hex-STRING: 80 00 00 40 95 30 5E 31
BEGEMOT-BRIDGE-MIB::begemotBridgeStpDesignatedRoot."bridge2" = Hex-STRING: 80 00 00 50 8B B8 C6 A9
....

`mib-2.dot1dBridge` дэд модоор монитор хийгдэж байгаа гүүрний интерфэйсийг солихын тулд доор дурдсаныг хийнэ:

[source,bash]
....
% snmpset -v 2c -c private bridge1.example.com
BEGEMOT-BRIDGE-MIB::begemotBridgeDefaultBridgeIf.0 s bridge2
....

[[network-aggregation]]
== Холбоос нэгтгэлт ба ослыг тойрон гарах (Link Aggregation and Failover)

=== Танилцуулга

man:lagg[4] интерфэйс нь fault-tolerance буюу алдаанд тэсвэртэй байдал болон өндөр хурдны холбоосуудыг хангах зорилгоор сүлжээний олон интерфэйсүүдийг нэг виртуал интерфэйс болгон нэгтгэх боломжийг олгодог.

=== Ажиллагааны горимууд

Failover::
Зөвхөн мастер портоор урсгалыг илгээж хүлээн авна. Хэрэв мастер порт байхгүй болвол дараагийн идэвхтэй порт ашиглагдана. Эхний нэмэгдсэн интерфэйс нь мастер порт болох бөгөөд үүний дараа нэмэгдсэнүүд нь ослыг тойрон гарах төхөөрөмжүүд болон ашиглагдах болно. Хэрэв мастер биш порт дээр тойрон гарах үйлдэл хийгдвэл анхдагч порт дахин боломжтой болонгуутаа мастер порт болдог.

Cisco(R) Fast EtherChannel(R)::
Cisco(R) Fast EtherChannel(R) (FEC) нь статик тохируулга бөгөөд нөгөө талтайгаа нэгтгэлт хийхэд тохиролцдоггүй эсвэл холбоосыг монитор хийхийн тулд хүрээнүүд солилцдоггүй. Хэрэв шилжүүлэгч LACP-г дэмждэг бол түүнийг ашиглах ёстой.
+
FEC нь хэш хийгдсэн протоколын толгойн мэдээлэл дээр үндэслэн идэвхтэй портуудаар гарч байгаа урсгалыг тэнцвэржүүлж дурын идэвхтэй портоос ирж байгаа урсгалыг хүлээн авна. Хэш нь Ethernet эхлэл болон очих хаяг ба хэрэв байгаа бол VLAN хаяг болон IPv4/IPv6 эхлэл болон очих хаягийг багтаадаг.

LACP::
IEEE(R) 802.3ad Link Aggregation Control Protocol (LACP) буюу Холбоос Нэгтгэлт Хянах Протокол болон Marker буюу Тэмдэглэгээний Протокол. LACP нь нэгтгэж болох холбоосуудыг нөгөө талтай нь нэг буюу хэд хэдэн Link Aggregated Group буюу Холбоос Нэгтгэгдсэн бүлгүүд (LAG) болгон тохиролцуулдаг. LAG бүр нь адил хурдтай, гүйцэд дуплекс ажиллагаанд тохируулсан портуудаас тогтоно. Урсгал нь LAG дахь портуудын дагуу хамгийн их нийт хурдаар тэнцвэржүүлэгдэх бөгөөд ихэнх тохиолдолд бүх портуудыг агуулсан зөвхөн нэг LAG байх болно. Физик холболт өөрчлөгдөхөд Холбоос Нэгтгэлт шинэ тохиргоо уруу хурдан шилжих болно.
+
LACP нь хэш хийгдсэн протоколын толгойн мэдээлэл дээр үндэслэн идэвхтэй портуудаар гарч байгаа урсгалыг тэнцвэржүүлж дурын идэвхтэй портоос ирж байгаа урсгалыг хүлээн авна. Хэш нь Ethernet эхлэл болон очих хаяг ба хэрэв байгаа бол VLAN хаяг болон IPv4/IPv6 эхлэл болон очих хаягийг багтаадаг.

Loadbalance::
Энэ нь _FEC_ горимын хуулбар юм.

Round-robin::
Тойрон эргэх хуваарилалтыг ашиглан гарч байгаа урсгалыг бүх идэвхтэй портуудаар тарааж дурын идэвхтэй портоос ирж байгаа урсгалыг хүлээн авна. Энэ горим нь Ethernet хүрээний дарааллыг зөрчих бөгөөд болгоомжтой ашиглах шаардлагатай байдаг.

=== Жишээнүүд

[[networking-lacp-aggregation-cisco]]
.Cisco(R) шилжүүлэгчтэй LACP нэгтгэлт
[example]
====
Энэ жишээ нь FreeBSD машины хоёр интерфэйсийг шилжүүлэгч рүү ачаалал тэнцвэржүүлсэн, алдаанд тэсвэртэй ганц холбоосоор холбож байна. Дамжуулах чанар болон алдаанд тэсвэртэй байдлыг сайжруулах зорилгоор илүү олон интерфэйсүүдийг нэмж болно. Ethernet холбоосууд дээр хүрээний дараалал чухал байдаг учраас хоёр станцын хоорондох ямар ч урсгал аль нэг интерфэйсийн хамгийн их хурдаар хязгаарлагдан тэр физик холбоосоор үргэлж урсаж байдаг. Дамжуулах алгоритм нь өөр өөр урсгалуудыг ялгаж, байгаа интерфэйсүүдээр тэдгээрийг тэнцвэржүүлэхийн тулд аль болох их мэдээллийг ашиглахыг оролддог.

Cisco(R) шилжүүлэгч дээр _FastEthernet0/1_ болон _FastEthernet0/2_ интерфэйсүүдийг _1_ сувгийн бүлэгт нэмнэ.

[source,bash]
....
interface FastEthernet0/1
channel-group 1 mode active
channel-protocol lacp
!
interface FastEthernet0/2
 channel-group 1 mode active
 channel-protocol lacp
....

_fxp0_ болон _fxp1_-г ашиглан man:lagg[4] интерфэйсийг үүсгээд _10.0.0.3/24_ гэсэн IP хаяг тавьж интерфэйсийг босгоно:

[source,bash]
....
# ifconfig fxp0 up
# ifconfig fxp1 up
# ifconfig lagg0 create 
# ifconfig lagg0 up laggproto lacp laggport fxp0 laggport fxp1 10.0.0.3/24
....

Доорх тушаалыг ажиллуулж интерфэйсийн төлвийг харна:

[source,bash]
....
# ifconfig lagg0
....

_ACTIVE_ гэж тэмдэглэгдсэн портууд нь алсын шилжүүлэгчтэй тохиролцсон, идэвхтэй нэгтгэлтийн бүлгийн хэсэг бөгөөд урсгал нь дамжуулагдаж хүлээн авагдах болно. LAG таних тэмдгүүдийг үзэхийн тулд man:ifconfig[8]-ийн дэлгэрэнгүй гаралтыг ашиглаарай.

[source,bash]
....
lagg0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500
        options=8<VLAN_MTU>
        ether 00:05:5d:71:8d:b8
	inet 10.0.0.15 netmask 0xffffff00 broadcast 10.0.0.255
        media: Ethernet autoselect
        status: active
        laggproto lacp
        laggport: fxp1 flags=1c<ACTIVE,COLLECTING,DISTRIBUTING>
        laggport: fxp0 flags=1c<ACTIVE,COLLECTING,DISTRIBUTING>
....

Шилжүүлэгч дээр портын төлвийг харахын тулд `show lacp neighbor` тушаалыг ашиглах хэрэгтэй.

[source,bash]
....
switch# show lacp neighbor
Flags:  S - Device is requesting Slow LACPDUs
        F - Device is requesting Fast LACPDUs
        A - Device is in Active mode       P - Device is in Passive mode

Channel group 1 neighbors

Partner's information:

                  LACP port                        Oper    Port     Port
Port      Flags   Priority  Dev ID         Age     Key     Number   State
Fa0/1     SA      32768     0005.5d71.8db8  29s    0x146   0x3      0x3D
Fa0/2     SA      32768     0005.5d71.8db8  29s    0x146   0x4      0x3D
....

Дэлгэрэнгүйг харахыг хүсвэл `show lacp neighbor detail` тушаалыг ашиглана.
====

[[networking-lagg-failover]]
.Failover горим
[example]
====
Failover буюу ослыг тойрон гарах горимыг мастер интерфэйс дээр холбоос тасарсан тохиолдолд хоёр дахь интерфэйс уруу шилжихэд ашиглаж болно. _fxp0_ нь мастер интерфэйс, _fxp1_ нь хоёр дахь интерфэйс байхаар _lagg0_ интерфэйсийг үүсгэж тохируулна:

[source,bash]
....
# ifconfig lagg0 create
# ifconfig lagg0 up laggproto failover laggport fxp0 laggport fxp1
....

Интерфэйс нь үүнтэй төстэй байх бөгөөд гол ялгаа нь MAC хаяг болон төхөөрөмжийн нэрс байх болно:

[source,bash]
....
# ifconfig lagg0
lagg0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500
        options=8<VLAN_MTU>
        ether 00:05:5d:71:8d:b8
        media: Ethernet autoselect
        status: active
        laggproto failover
        laggport: fxp1 flags=0<>
        laggport: fxp0 flags=5<MASTER,ACTIVE>
....

Урсгал _fxp0_ дээр хүлээн авагдаж дамжих болно. Хэрэв холбоос _fxp0_ дээр тасарсан бол _fxp1_ нь идэвхтэй холбоос болно. Хэрэв холбоос нь мастер интерфэйс дээр сэргээгдсэн бол энэ нь эргээд идэвхтэй холбоос болно.

Дахин ачаалахад энэ тохиргоог хэвээр байлгахын тулд дараах мөрүүдийг [.filename]#/etc/rc.conf# файлд нэмж өгнө:

[.programlisting]
....
ifconfig_fxp0="up"
ifconfig_fxp1="up"
cloned_interfaces="lagg0"
ifconfig_lagg0="laggproto failover laggport fxp0 laggport fxp1 10.0.0.15/24"
....

====

[[networking-lagg-wired-and-wireless]]
.Утастай болон утасгүй сүлжээний интерфэйсүүдийн хоорондох Failover горим
[example]
====
Зөөврийн компьютертай хэрэглэгчдийн хувьд утастай сүлжээний холболт байхгүй болсон үед ашиглахаар утасгүй сүлжээний интерфэйсийг хоёр дахь интерфэйс болгох нь зүйтэй байдаг. Өгөгдлийг утасгүй холболтоор дамжуулах боломжийг хангахын хажуугаар man:lagg[4]-ийн тусламжтайгаар нэг IP хаяг ашиглах, ажиллагаа болон аюулгүй байдлаас болоод утастай холболтыг илүүд үзэх боломжтой юм.

Энэ тохиргоонд утасгүй сүлжээний MAC хаягийг ашиглагдаж байгаа мастер интерфэйс болох утастай сүлжээний интерфэйсээс авсан man:lagg[4]-ийн хаягтай адилаар тавих хэрэгтэй.

Энэ тохиргоонд утастай сүлжээний интерфэйс _bge0_-ийг мастер, утасгүй сүлжээний интерфэйс _wlan0_-ийг failover интерфэйс гэж авч үзнэ. _wlan0_-ийг _iwn0_-ээс үүсгэсэн бөгөөд бид үүнд утастай сүлжээний холболтын MAC хаяг зааж өгөх болно. Эхний алхам бол MAC хаягийг утастай сүлжээний интерфэйсээс авах явдал юм:

[source,bash]
....
# ifconfig bge0
bge0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500
	options=19b<RXCSUM,TXCSUM,VLAN_MTU,VLAN_HWTAGGING,VLAN_HWCSUM,TSO4>
	ether 00:21:70:da:ae:37
	inet6 fe80::221:70ff:feda:ae37%bge0 prefixlen 64 scopeid 0x2
	nd6 options=29<PERFORMNUD,IFDISABLED,AUTO_LINKLOCAL>
	media: Ethernet autoselect (1000baseT <full-duplex>)
	status: active
....

Та _bge0_-ийг өөрт байгаагаар солих хэрэгтэй бөгөөд ингэхэд таны утастай сүлжээний интерфэйсийн MAC хаяг бүхий өөр `ether` хаягийг авах болно. Одоо утасгүй сүлжээний интерфэйс _iwn0_-ийг солино:

[source,bash]
....
# ifconfig iwn0 ether 00:21:70:da:ae:37
....

Утасгүй сүлжээний интерфэйсийг босгоно, гэхдээ ямар ч IP хаяг тавих хэрэггүй:

[source,bash]
....
# ifconfig wlan0 create wlandev iwn0 ssid my_router up
....

_bge0_ интерфэйсийг босгоно. _bge0_-ийг мастер маягаар ашиглан хэрэв шаардлагатай бол _wlan0_ руу failover хийх боломжтойгоор man:lagg[4] интерфэйс үүсгэнэ:

[source,bash]
....
# ifconfig bge0 up
# ifconfig lagg0 create
# ifconfig lagg0 up laggproto failover laggport bge0 laggport wlan0
....

Интерфэйс нь үүнтэй төстэй байх бөгөөд гол ялгаа нь MAC хаяг ба төхөөрөмжийн нэрс байх болно:

[source,bash]
....
# ifconfig lagg0
lagg0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500
        options=8<VLAN_MTU>
        ether 00:21:70:da:ae:37
        media: Ethernet autoselect
        status: active
        laggproto failover
        laggport: wlan0 flags=0<>
        laggport: bge0 flags=5<MASTER,ACTIVE>
....

Дараа нь IP хаяг авахын тулд DHCP клиентийг эхлүүлнэ:

[source,bash]
....
# dhclient lagg0
....

Дахин ачаалахад энэ тохиргоог хэвээр байлгахын тулд дараах мөрүүдийг [.filename]#/etc/rc.conf# файлд нэмж өгнө:

[.programlisting]
....
ifconfig_bge0="up"
ifconfig_iwn0="ether 00:21:70:da:ae:37"
wlans_iwn0="wlan0"
ifconfig_wlan0="WPA"
cloned_interfaces="lagg0"
ifconfig_lagg0="laggproto failover laggport bge0 laggport wlan0 DHCP"
....

====

[[network-diskless]]
== Дискгүй ажиллагаа

FreeBSD машин сүлжээгээр ачаалан локал дискгүйгээр NFS сервер дээр холбогдсон файлын системүүд ашиглаад ажиллаж чаддаг. Стандарт тохиргооны файлуудаас өөр системийн өөрчлөлт шаардлагагүй. Ийм системийг харьцангуй хялбараар тохируулж болдог. Учир нь шаардлагатай бүх элементүүд бэлэн байдаг:

* Цөмийг сүлжээгээр ачаалах хоёр боломжит арга хамгийн багаар бодоход байдаг:

** PXE: Intel(R)-ийн Preboot eXecution Environment буюу ачаалалт хийгдэхээс өмнөх ажиллуулах орчны систем нь зарим сүлжээний картууд эсвэл эх хавтангуудад цуг бүтээгдсэн байдаг ухаалаг ачаалах ROM-ийн нэг хэлбэр юм. Илүү дэлгэрэнгүйг man:pxeboot[8]-с үзнэ үү.
** Etherboot порт (package:net/etherboot[]) нь цөмийг сүлжээгээр ачаалах ROM хийгдэх боломжтой код үүсгэдэг. Код нь сүлжээний картан дээр ачаалах ROM уруу шарагдсан байх юм уу эсвэл локал уян (эсвэл хатуу) дискний хөтчөөс эсвэл ажиллаж байгаа MS-DOS(R) системээс дуудагдахаар байдаг. Олон сүлжээний карт дэмжигдсэн байгаа.

* Жишээ скрипт ([.filename]#/usr/shared/examples/diskless/clone_root#) нь сервер дээр ажлын станцын root файлын системийг үүсгэх болон түүний ажиллагааг хангах үйлдлийг хөнгөвчилдөг. Скрипт нь магадгүй жижиг өөрчлөлтийг шаардаж болох боловч энэ нь таныг хурдан эхлүүлэх болно.
* Дискгүй системийн эхлүүлэлтийг илрүүлж дэмжих стандарт системийн эхлүүлэгч файлууд [.filename]#/etc# санд байдаг.
* swap хийх хэрэв шаардлагатай бол NFS файл эсвэл локал диск уруу хийж болох юм.

Дискгүй ажлын станцуудыг тохируулах олон арга байдаг. Олон элементүүд үүнд хамрагддаг бөгөөд өөрийн сонирхлоор ихэнхийг нь өөрчилж болно. Дараах нь бүрэн системийг тохируулах талаар хувилбаруудыг тайлбарлах болно. Ингэхдээ стандарт FreeBSD эхлүүлэх скриптүүдтэй хялбар, нийцтэй байхыг чухалчлах болно. Тайлбарласан систем нь дараах шинжүүдтэй байна:

* Дискгүй ажлын станцууд нь хуваалцсан, зөвхөн уншигдах [.filename]#/# файлын систем болон хуваалцсан, зөвхөн уншигдах [.filename]#/usr#-г ашигладаг.
+ 
root файлын систем нь зөвхөн дискгүй ажиллагаатай холбоотой эсвэл тэдгээрийн харьяалагдах ажлын станцтай холбоотой зарим тохиргооны файлууд нь өөрчлөгдсөн стандарт FreeBSD root-ийн (ихэвчлэн серверийн) хуулбар юм.
+ 
Бичигдэх боломжтой байх root-ийн хэсэг нь man:md[4] файлын системээр дээр тавигддаг (overlaid). Систем дахин ачаалахад хийгдсэн өөрчлөлтүүд алга болох болно.
* Цөм дамжуулагдаж Etherboot эсвэл PXE-ийн аль нэгээр дуудагддаг бөгөөд зарим тохиолдолд зөвхөн аль нэг аргыг ашиглахыг шаардаж болох юм.

[CAUTION]
====

Тайлбарласны дагуу энэ систем нь аюултай юм. Энэ нь сүлжээний хамгаалагдсан талбарт байх ёстой бөгөөд бусад хостуудаас хандахааргүй байх ёстой.
====

Энэ хэсгийн бүх мэдээллийг FreeBSD 5.2.1-RELEASE ашиглан тест хийсэн болно.

=== Үндсэн мэдээлэл

Дискгүй ажлын станцуудыг тохируулах нь харьцангуй амархан боловч алдаанд өртөх хандлагатай байдаг. Хэд хэдэн шалтгаанаас болоод эдгээрийг заримдаа оношлох төвөгтэй байдаг. Жишээ нь:

* Эмхэтгэлтийн үеийн тохируулгууд нь ажиллах үед өөрөөр ажиллахыг тодорхойлж болох юм.
* Алдааны мэдэгдлүүд нь ихэвчлэн нуугдмал эсвэл бүр байхгүй ч байж болно.

Энд гарч болзошгүй асуудлуудыг шийдэхэд үндсэн арга замуудын зарим нэг мэдлэгийг ашиглах нь маш ашигтай байдаг.

Амжилттайгаар эхлүүлэхийн тулд хэд хэдэн үйлдлүүдийг хийх хэрэгтэй:

* Машин өөрийн IP хаяг, ажиллах файлын нэр, серверийн нэр, root зам зэрэг эхний параметрүүдийг авах хэрэгтэй. Үүнийг DHCP эсвэл BOOTP протоколуудыг ашиглан хийдэг. DHCP нь BOOTP-ийн нийцтэй өргөтгөл бөгөөд адил портын дугаарууд болон үндсэн пакетийн хэлбэршүүлэлтийг ашигладаг.
+ 
Зөвхөн BOOTP ашиглахаар системийг тохируулах боломжтой. man:bootpd[8] серверийн програм нь үндсэн FreeBSD системд орсон байдаг.
+ 
Гэхдээ DHCP нь BOOTP-ээс хэд хэдэн давуу талтай байдаг (илүү сайхан тохиргооны файлууд, PXE ашиглах боломж, дискгүй ажиллагаатай шууд холбоогүй бусад олон давуу талууд) бөгөөд бид голчлон DHCP тохиргоог боломжтой бол man:bootpd[8] ашиглан таарах жишээнүүдтэй нь хамт тайлбарлах болно. Жишээ тохиргоо нь ISC DHCP програм хангамжийн багцыг (тест сервер дээр 3.0.1.r12 хувилбар суулгагдсан) ашиглах болно.
* Машин нь нэг буюу хэд хэдэн програмуудыг локал санах ой уруугаа дамжуулах хэрэгтэй болно. TFTP юм уу эсвэл NFS ашиглагдана. TFTP болон NFS-ийн сонголтыг хэд хэдэн газар эмхэтгэх үеийн тохируулгаар хийдэг. Алдааны түгээмэл эх үүсвэр нь буруу протоколд зориулж файлын нэрүүдийг заах явдал юм: TFTP нь сервер дээрх ганц сангаас бүх файлуудыг ихэвчлэн дамжуулдаг бөгөөд энэ сантай харьцангуй файлын нэрсийг хүлээдэг. NFS-д файлын туйлын (абсолют) замууд хэрэгтэй байдаг. 
* Боломжит дундын эхлүүлэх програмууд болон цөм нь эхлэн тохируулагдаж ажиллах шаардлагатай. Энд хэд хэдэн чухал хувилбарууд байдаг:

** PXE нь FreeBSD-ийн гурав дахь шатны дуудагчийн өөрчлөгдсөн хувилбар болох man:pxeboot[8]-ийг ачаална. man:pxeboot[8] нь системийг эхлүүлэхэд шаардлагатай ихэнх параметрүүдийг авч хяналтыг дамжуулахаасаа өмнө тэдгээрийг цөмийн орчинд үлдээх болно. Энэ тохиолдолд [.filename]#GENERIC# цөмийг ашиглах боломжтой.
** Etherboot нь бага бэлтгэлтэйгээр цөмийг шууд ачаалах болно. Та цөмийг тусгай тохируулгуудтай бүтээх хэрэгтэй болно.
+ 
PXE болон Etherboot нь адилхан ажиллана; гэхдээ цөмүүд нь man:loader[8]-ийн тэдэнд зориулж илүү ажил хийх боломжийг олгодог болохоор PXE нь зохимжтой арга юм.
+ 
Хэрэв таны BIOS болон сүлжээний картууд нь PXE-г дэмждэг бол та үүнийг ашиглах хэрэгтэй байж болох юм.
* Эцэст нь машин өөрийн файлын системүүдэд хандах хэрэгтэй болно. NFS нь бүх тохиолдолд хэрэглэгдэнэ.

man:diskless[8] гарын авлагын хуудсыг бас үзнэ үү.

=== Тохируулах зааврууд

==== ISC DHCP ашиглах тохиргоо

ISC DHCP сервер BOOTP болон DHCP хүсэлтүүдэд хариулж чаддаг.

ISC DHCP 4.2 нь үндсэн системийн хэсэг биш юм. Та эхлээд package:net/isc-dhcp42-server[] порт юм уу эсвэл тохирох багцыг суулгах хэрэгтэй.

ISC DHCP суулгагдсаны дараа ажиллахын тулд тохиргооны файл хэрэгтэй болно (ихэвчлэн [.filename]#/usr/local/etc/dhcpd.conf# гэж нэрлэгддэг). Доор `margaux` хост Etherboot-ийг ашигласан ба `corbieres` хост PXE-г ашиглаж байгаа тайлбар хийгдсэн жишээ байна:

[.programlisting]
....
default-lease-time 600;
max-lease-time 7200;
authoritative;

option domain-name "example.com";
option domain-name-servers 192.168.4.1;
option routers 192.168.4.1;

subnet 192.168.4.0 netmask 255.255.255.0 {
  use-host-decl-names on; <.>
  option subnet-mask 255.255.255.0;
  option broadcast-address 192.168.4.255;

  host margaux {
    hardware ethernet 01:23:45:67:89:ab;
    fixed-address margaux.example.com;
    next-server 192.168.4.4; <.>
    filename "/data/misc/kernel.diskless"; <.>
    option root-path "192.168.4.4:/data/misc/diskless"; <.>
  }
  host corbieres {
    hardware ethernet 00:02:b3:27:62:df;
    fixed-address corbieres.example.com;
    next-server 192.168.4.4;
    filename "pxeboot";
    option root-path "192.168.4.4:/data/misc/diskless";
  }
}
....

<.> Энэ тохируулга нь `host` зарлалтууд дахь утгыг дискгүй хостын хувьд хостын нэр болгон илгээхийг dhcpd-д хэлнэ. Өөр нэг арга нь `option host-name margaux` мөрийг `host` зарлалтуудын дотор нэмэх явдал юм.

<.> `next-server` тохируулга нь дуудагч эсвэл цөмийн файлыг дуудахад зориулж TFTP эсвэл NFS серверийг ашиглахыг зааж өгнө (анхдагчаар DHCP сервер байгаа хостыг ашиглана).

<.> `filename` тохируулга нь Etherboot эсвэл PXE-ийн дараагийн ажиллуулах алхамд дуудах файлыг тодорхойлно. Үүнийг ашиглах дамжуулалтын аргын дагуу заасан байх ёстой. Etherboot-ийг NFS эсвэл TFTP ашиглахаар эмхэтгэж болно. FreeBSD порт нь NFS-ийг анхдагчаар тохируулдаг. PXE нь TFTP-г ашигладаг. Энд яагаад харьцангуй файлын нэр хэрэглэгддэгийн учир нь тэр юм (энэ нь TFTP серверийн тохиргооноос хамаарах боловч ерөнхийдөө нэлээн энгийн байх болно). PXE нь цөмийг биш бас [.filename]#pxeboot#-г дууддаг. FreeBSD CD-ROM [.filename]#/boot# сангаас [.filename]#pxeboot#-ийг дуудах зэрэг бусад сонирхолтой боломжууд байдаг (man:pxeboot[8] нь [.filename]#GENERIC# цөмийг ачаалж чаддаг бөгөөд энэ нь алсын CD-ROM-с ачаалахын тулд PXE-г ашиглах боломжтой болгодог юм).

<.> `root-path` тохируулга нь root файлын систем хүрэх замыг энгийн NFS бичлэгээр тодорхойлдог. PXE ашиглаж байгаа үед цөмийн тохиргоо BOOTP-г идэвхжүүлээгүй байхад хостын IP-г орхигдуулах боломжтой байдаг. NFS сервер дараа нь TFTP сервертэй адил болох болно.

==== BOOTP ашиглах тохиргоо

Энд bootpd-ийн адил тохиргоо (нэг клиент болгож багасгасан) байна. Үүнийг [.filename]#/etc/bootptab# файлаас олж болно.

BOOTP-г ашиглахын тулд Etherboot-ийг анхдагч биш тохируулга `NO_DHCP_SUPPORT`-тойгоор эмхэтгэх ёстой бөгөөд PXE-д DHCP _хэрэгтэй_ гэдгийг санаарай. bootpd-ийн цорын ганц илэрхий давуу тал бол үндсэн системд орсон байдаг явдал юм.

[.programlisting]
....
.def100:\
  :hn:ht=1:sa=192.168.4.4:vm=rfc1048:\
  :sm=255.255.255.0:\
  :ds=192.168.4.1:\
  :gw=192.168.4.1:\
  :hd="/tftpboot":\
  :bf="/kernel.diskless":\
  :rp="192.168.4.4:/data/misc/diskless":

margaux:ha=0123456789ab:tc=.def100
....

==== Ачаалах програмыг Etherboot-ээр бэлдэх

http://etherboot.sourceforge.net[Etherboot-ийн вэб сайт] нь Линукс системд голчлон зориулагдсан боловч ашигтай мэдээлэл агуулсан http://etherboot.sourceforge.net/doc/html/userman/t1.html[ өргөтгөсөн баримт]ыг агуулдаг. Дараах нь FreeBSD систем дээр Etherboot-г хэрхэн ашиглах талаар тайлбарлах болно.

Та эхлээд package:net/etherboot[] багц юм уу эсвэл портыг суулгах ёстой.

Etherboot-ийн тохиргоог Etherboot-ийн эх байгаа сан дахь [.filename]#Config# файлыг засварлаж (өөрөөр хэлбэл NFS-ийн оронд TFTP-г ашиглахын тулд) өөрчилж болно.

Бидний тохиргооны хувьд бид ачаалах уян дискийг ашиглах болно. Бусад аргуудын хувьд (PROM, эсвэл MS-DOS(R) програм) Etherboot-ийн баримтаас лавлана уу.

Ачаалах уян дискийг хийхийн тулд Etherboot суулгасан машин дээрх хөтөч уруугаа уян дискээ хийгээд Etherboot мод дахь [.filename]#src# сан уруу болгож одоогийн сангаа солиод доор дурдсан тушаалыг бичнэ:

[source,bash]
....
# gmake bin32/devicetype.fd0
....

_devicetype_ нь дискгүй ажлын станц дахь Ethernet картын төрлөөс хамаарна. Зөв _devicetype_ буюу төхөөрөмжийн төрлийг тодорхойлохын тулд тэр сан дахь [.filename]#NIC# файлд хандана.

==== PXE-ээр ачаалах

Анхдагчаар man:pxeboot[8] дуудагч нь NFS-ээр цөмийг дууддаг. [.filename]#/etc/make.conf# файлд `LOADER_TFTP_SUPPORT` тохируулга заахын оронд TFTP-г ашиглахаар эмхэтгэгдэж болно. Заавруудын талаар [.filename]#/usr/shared/examples/etc/make.conf# файл дахь тайлбаруудыг үзнэ үү.

Цуваа консол дискгүй машин тохируулахад ашигтай байж болох [.filename]#make.conf# файлын өөр хоёр тохируулга байдаг: эдгээр нь `BOOT_PXELDR_PROBE_KEYBOARD`, болон `BOOT_PXELDR_ALWAYS_SERIAL` юм.

Машин эхлэхэд PXE-г ашиглахын тулд та өөрийн BIOS-ийн тохируулгаас `Boot from network` буюу `Сүлжээнээс ачаалах` сонголтыг сонгох юм уу эсвэл PC-г эхлүүлж байх үед функцийн товчлуурыг дарах хэрэгтэй.

==== TFTP болон NFS серверүүдийг тохируулах

Хэрэв та TFTP ашиглахаар тохируулсан PXE юм уу эсвэл Etherboot-г ашиглаж байгаа бол файл сервер дээрээ tftpd-г идэвхжүүлэх хэрэгтэй:

[.procedure]
====

. tftpd-д зориулж файлууд байх сан үүсгэнэ, өөрөөр хэлбэл [.filename]#/tftpboot#.
. Энэ мөрийг өөрийн [.filename]#/etc/inetd.conf# файлд нэмнэ:
+
[.programlisting]
....
tftp	dgram	udp	wait	root	/usr/libexec/tftpd	tftpd -l -s /tftpboot
....
+
[NOTE]
======
Зарим нэгэн PXE хувилбарууд нь TFTP-ийн TCP хувилбарыг хүсдэг байна. Энэ тохиолдолд `dgram udp` мөрийг `stream tcp` болгон сольж хоёр дахь мөрийг нэмнэ.
======
+
. inetd-д өөрийн тохиргооны файлаа дахин уншихыг хэлээрэй. Энэ тушаалыг зөв ажиллуулахын тулд [.filename]#/etc/rc.conf# файлд `inetd_enable="YES"` тохируулга заагдсан байх ёстой:
+
[source,bash]
....
# service inetd restart
....
====

Та [.filename]#tftpboot# санг серверийнхээ хаана ч байрлуулж болно. [.filename]#inetd.conf# болон [.filename]#dhcpd.conf# файлууд дээрээ байрлалаа заасан эсэхээ шалгаарай.

Аль ч тохиолдолд та бас NFS-ээ идэвхжүүлж NFS сервер дээрээ тохирох файлын системээ экспорт хийх хэрэгтэй юм.

[.procedure]
====

. Үүнийг [.filename]#/etc/rc.conf#-д нэмнэ:
+
[.programlisting]
....
nfs_server_enable="YES"
....
+
. Доор дурдсаныг [.filename]#/etc/exports# файл уруу нэмж дискгүй root сан байгаа файлын системээ экспорт хийнэ (эзлэхүүний холбох цэгийг тааруулж _margaux corbieres_ гэснийг дискгүй ажлын станцуудын нэрсээр солих хэрэгтэй):
+
[.programlisting]
....
/data/misc -alldirs -ro margaux corbieres
....
+
. mountd-д өөрийн тохиргооны файлаа дахин уншихыг хэлнэ. Хэрэв та эхний шатандаа NFS-г [.filename]#/etc/rc.conf# файлд идэвхжүүлэх хэрэгтэй болсон бол харин дахин ачаалахыг хүсэж болох юм.
+
[source,bash]
....
# service mountd restart
....
====

==== Дискгүй цөмийг бүтээх

Хэрэв Etherboot-г ашиглаж байгаа бол дискгүй клиентдээ зориулж дараах тохируулгуудтайгаар (ердийн тохируулгуудын хамтаар) цөмийн тохиргооны файл үүсгэх хэрэгтэй:

[.programlisting]
....
options     BOOTP          # Use BOOTP to obtain IP address/hostname
options     BOOTP_NFSROOT  # NFS mount root file system using BOOTP info
....

Та бас `BOOTP_NFSV3`, `BOOT_COMPAT` болон `BOOTP_WIRED_TO` ([.filename]#NOTES# файлаас лавлана уу) тохируулгуудыг ашиглахыг хүсэж болох юм.

Эдгээр тохируулгуудын нэрс нь уламжлалт бөгөөд тэдгээр нь яг үнэндээ DHCP болон BOOTP-ийн өөр хэрэглээг цөм дотор идэвхжүүлдэг болохоор нэлээн төөрөгдөлд хүргэж болох юм (зөвхөн BOOTP эсвэл DHCP-ийн хэрэглээг ашиглахаар болгох бас боломжтой байдаг).

Цөмийг бүтээж (crossref:kernelconfig[kernelconfig,FreeBSD цөмийг тохируулах нь]-г үзнэ үү), [.filename]#dhcpd.conf# файлд заасан байрлал уруу хуулах хэрэгтэй.

[NOTE]
====
PXE-г ашиглаж байгаа үед дээрх тохируулгуудтайгаар цөмийг бүтээх нь заавал шаардлагагүй (хэдийгээр зөвлөдөг боловч). Тэдгээрийг идэвхжүүлэх нь цөмийг эхлүүлэх явцад илүү олон DHCP хүсэлтүүдийг үүсгэж шинэ утгууд болон зарим тусгай тохиолдлуудад man:pxeboot[8]-ийн авсан утгуудын хооронд нийцэмжгүй байдлын жижиг эрсдэл гаргахад хүргэдэг. Тэдгээрийг ашиглахын давуу тал нь буруу нөлөөллөөс болоод хостын нэр тохируулагддаг явдал юм. Үгүй бол та хостын нэрийг өөр аргаар, жишээ нь клиентэд тусгайлан зориулсан [.filename]#rc.conf# файлд тохируулах хэрэгтэй болно.
====

[NOTE]
====
Etherboot-ээр дуудагдах боломжтой байхын тулд цөмд төхөөрөмжийн бяцхан зааврууд эмхэтгэгдсэн байх хэрэгтэй байдаг. Ингэхдээ та дараах тохируулгыг тохиргооны файлдаа тохируулах болно ([.filename]#NOTES# тохиргооны тайлбаруудын файлыг үзнэ үү):

[.programlisting]
....
hints		"GENERIC.hints"
....

====

==== Root файлын системийг бэлдэх

Дискгүй ажлын станцад зориулж [.filename]#dhcpd.conf# файлд `root-path` гэж жагсаагдсан байрлалд root файлын системийг та үүсгэх хэрэгтэй.

===== root-ийг суурьшуулахын тулд `make world` тушаал ашиглах

Энэ арга нь хурдан байх бөгөөд бүрэн онгон системийг (зөвхөн root файлын систем биш) `DESTDIR` уруу суулгах болно. Та дараах скриптийг л ердөө ажиллуулах хэрэгтэй болно:

[.programlisting]
....
#!/bin/sh
export DESTDIR=/data/misc/diskless
mkdir -p ${DESTDIR}
cd /usr/src; make buildworld && make buildkernel
make installworld && make installkernel
cd /usr/src/etc; make distribution
....

Үүнийг хийсний дараа танд өөрийнхөө хэрэгцээний дагуу `DESTDIR`-д байрлуулагдсан өөрийн [.filename]#/etc/rc.conf# болон [.filename]#/etc/fstab# файлуудаа өөрчлөн тохируулах шаардлага гарч болох юм.

==== Swap-ийг тохируулах

Шаардлагатай бол сервер дээр байрласан swap файлд NFS-ээр хандаж болно.

===== NFS Swap

Цөм нь ачаалах үед NFS swap-ийг идэвхжүүлэхийг дэмждэггүй. Бичигдэх файлын системийг холбож swap файлыг үүсгэн идэвхжүүлэх замаар эхлүүлэх скриптүүдээр swap нь идэвхжүүлэгдэх ёстой. Зохих хэмжээ бүхий swap файлыг үүсгэхдээ та ингэж хийж болно:

[source,bash]
....
# dd if=/dev/zero of=/path/to/swapfile bs=1k count=1 oseek=100000
....

Үүнийг идэвхжүүлэхийн тулд та дараах мөрийг өөрийн [.filename]#rc.conf# файлд нэмэх хэрэгтэй:

[.programlisting]
....
swapfile=/path/to/swapfile
....

==== Бусад асуудлууд

===== Зөвхөн уншигдах [.filename]#/usr# сантайгаар ажиллах

Хэрэв дискгүй ажлын станц нь X-ийг ажиллуулахаар тохируулагдсан бол анхдагчаар [.filename]#/usr#-т алдааны бүртгэлийг хийдэг XDM тохиргооны файлыг та тааруулах хэрэгтэй болно.

===== FreeBSD биш сервер ашиглах

root файлын системд зориулсан сервер нь FreeBSD-г ажиллуулаагүй бол та FreeBSD машин дээр root файлын систем үүсгээд хэрэгтэй байрлал уруу нь `tar` эсвэл `cpio` тушаал ашиглан хуулах хэрэгтэй болно.

Энэ тохиолдолд бүхэл тооны их/бага (major/minor) хэмжээнүүдийн ялгаанаас болоод [.filename]#/dev# дахь тусгай файлуудад заримдаа асуудал гардаг. Энэ асуудлын шийдэл нь FreeBSD биш серверээс уг санг экспорт хийж энэ сангаа FreeBSD машин дээр холбон хэрэглэгчийн хувьд төхөөрөмжийн цэгүүдийг харагдахгүйгээр (transparently) хуваарилахын тулд man:devfs[5]-ийг ашиглах явдал юм.

[[network-pxe-nfs]]
== NFS root файлын систем ашиглан PXE ачаалалт хийх

Intel(R)-н Preboot eXecution Environment (PXE) буюу Ачаалалтаас өмнө ажиллуулах орчин нь үйлдлийн системийг сүлжээгээр ачаалах боломжийг олгодог. PXE дэмжлэг орчин үеийн эх хавтангуудын BIOS дээр ихэвчлэн хийгдсэн байдаг бөгөөд BIOS тохиргоонуудад үүнийг идэвхжүүлэн сүлжээгээр ачаалах боломжтой болгодог. Бүрэн хэмжээгээр ажиллах PXE тохиргоотой байхын тулд зөв тохируулсан DHCP болон TFTP сервертэй байхыг шаарддаг.

Хост компьютер ачаалахдаа DHCP-с TFTP ашиглан эхний ачаалагч дуудагчийг хаанаас авч болох мэдээллийг авдаг. Энэ мэдээллийг хост компьютер хүлээж авсныхаа дараа ачаалагч дуудагчийг TFTP-р татаж аван ажиллуулдаг. Үүнийг http://download.intel.com/design/archives/wfm/downloads/pxespec.pdf[Preboot Execution Environment (PXE)-ийн тодорхойлолт] хаягийн 2.2.1 хэсэг бичсэн байгаа. FreeBSD дээр PXE процессын явцад хүлээн авсан ачаалагч дуудагч нь [.filename]#/boot/pxeboot# байна. [.filename]#/boot/pxeboot# ажилласны дараа FreeBSD-н цөм дуудагддаг бөгөөд FreeBSD-н бусад ачаалалт хийгддэг. FreeBSD-н ачаалах процессын талаар дэлгэрэнгүйг crossref:boot[boot,FreeBSD-ийн Ачаалах процесс] хэсгээс үзнэ үү.

=== NFS root файлын системд зориулж `chroot` орчин тохируулах

[.procedure]
====

. FreeBSD суулгац байх NFS-р холбож болох санг сонгоно. Жишээ нь [.filename]#/b/tftpboot/FreeBSD/install# гэх мэт санг ашиглаж болно.
+
[source,bash]
....
# export NFSROOTDIR=/b/tftpboot/FreeBSD/install
# mkdir -p ${NFSROOTDIR}
....
+
. crossref:network-servers[network-configuring-nfs,NFS-н тохиргоог хийх] хэсэг дэх зааврыг даган NFS серверийг идэвхжүүлнэ.
. Дараахийг [.filename]#/etc/exports# файлд нэмэн NFS-р санг экспорт хийнэ:
+
[.programlisting]
....
/b -ro -alldirs
....
+
. NFS серверийг дахин асаана:
+
[source,bash]
....
# service nfsd restart
....
+
. crossref:network-servers[network-inetd-settings,Тохиргоо] хэсэгт заасан алхмуудын дагуу man:inetd[8]-г идэвхжүүлнэ.
. [.filename]#/etc/inetd.conf#-д дараах мөрийг нэмнэ:
+
[.programlisting]
....
tftp dgram udp wait root /usr/libexec/tftpd tftpd -l -s /b/tftpboot
....
+
. inetd-г дахин асаана:
+
[source,bash]
....
# service inetd restart
....
+
. crossref:cutting-edge[makeworld,FreeBSD-н цөм болон хэрэглэгчийн талбарыг дахин бүтээнэ]:
+
[source,bash]
....
# cd /usr/src
# make buildworld
# make buildkernel
....
+
. NFS-р холбогдсон санд FreeBSD-г суулгана:
+
[source,bash]
....
# make installworld DESTDIR=${NFSROOTDIR}
# make installkernel DESTDIR=${NFSROOTDIR}
# make distribution DESTDIR=${NFSROOTDIR}
....
+
. TFTP ажиллаж байгааг болон PXE-р дамжин ачаалагч дуудагчийг татаж авч байгаа эсэхийг шалгана:
+
[source,bash]
....
# tftp localhost
tftp> get FreeBSD/install/boot/pxeboot
Received 264951 bytes in 0.1 seconds
....
+
. [.filename]#${NFSROOTDIR}/etc/fstab#-г засварлан root файлын системийг NFS-р холбох мөрийг үүсгэнэ:
+
[.programlisting]
....
# Device                                         Mountpoint    FSType   Options  Dump Pass
myhost.example.com:/b/tftpboot/FreeBSD/install       /         nfs      ro        0    0
....
+ 
_myhost.example.com_ гэдгийг таны өөрийн NFS серверийн IP хаяг эсвэл хостын нэрээр солих хэрэгтэй. Энэ жишээн дээр NFS хэрэглэгчид root файлын системийн агуулгыг устгачих магадлалаас хамгаалж root файлын системийг "зөвхөн унших" эрхээр холбосон байгаа.
. man:chroot[8] орчинд root нууц үгийг тохируулна.
+
[source,bash]
....
# chroot ${NFSROOTDIR}
# passwd
....
+ 
Энэ нь PXE-р ачаалж байгаа хэрэглэгч машинуудад зориулж root нууц үгийг тохируулах болно.
. [.filename]#${NFSROOTDIR}/etc/ssh/sshd_config# файлыг засварлан `PermitRootLogin` гэдгийг идэвхжүүлж PXE-р ачаалж байгаа хэрэглэгч машинуудад зориулж ssh-р дамжин root хэрэглэгч нэвтрэх боломжийг бүрдүүлнэ. Үүнийг man:sshd_config[5]-д тайлбарласан байгаа.
. ${NFSROOTDIR} дахь man:chroot[8] орчинд бусад өөрчлөлтүүдийг хийнэ. Эдгээр өөрчлөлтүүдэд man:pkg_add[1] ашиглан багцууд нэмэх, man:vipw[8], ашиглан нууц үгийн файлыг засварлах, эсвэл автоматаар холбохын тулд man:amd.conf[8] харгалзааг засварлах зэрэг орж болно. Жишээ нь:
+
[source,bash]
....
# chroot ${NFSROOTDIR}
# pkg_add -r bash
....
====

=== [.filename]#/etc/rc.initdiskless# ашигладаг Санах Ойн Файлын системийг тохируулах

Хэрэв та NFS root-с ачаалсан бол [.filename]#/etc/rc# нь NFS-ээр ачаалсныг мэдэж [.filename]#/etc/rc.initdiskless# скриптийг ажиллуулдаг. Юу болж байгааг энэ скрипт доторх тайлбаруудыг уншиж мэдээрэй. Бид [.filename]#/etc# болон [.filename]#/var# гэсэн санах ой дээр тулгуурласан файлын систем үүсгэх хэрэгтэй, учир нь NFS root сан нь зөвхөн уншигдах эрхтэй бөгөөд эдгээр сангууд нь бичигдэх боломжтой байх ёстой.

[source,bash]
....
# chroot ${NFSROOTDIR}
# mkdir -p conf/base
# tar -c -v -f conf/base/etc.cpio.gz --format cpio --gzip etc
# tar -c -v -f conf/base/var.cpio.gz --format cpio --gzip var
....

Систем ачаалахад [.filename]#/etc# болон [.filename]#/var#-д зориулсан санах ойн файлын системүүд үүсч холбогдох бөгөөд [.filename]#cpio.gz# файлуудын агуулга тэдгээр рүү хуулагдах болно.

[[network-pxe-setting-up-dhcp]]
=== DHCP сервер тохируулах

PXE нь TFTP болон DHCP сервер тохируулсан байхыг шаарддаг. DHCP сервер нь TFTP сервер байгаа машин дээр заавал байх шаардлагагүй бөгөөд таны сүлжээнээс хандаж болох боломжтой байх ёстой.

[.procedure]
====

. crossref:network-servers[network-dhcp-server,DHCP Серверийг Суулгах болон Тохируулах] заасан зааврын дагуу DHCP серверийг суулгана. [.filename]#/etc/rc.conf# болон [.filename]#/usr/local/etc/dhcpd.conf# файлуудыг зөв тохируулсан эсэхийг шалгаарай.
. [.filename]#/usr/local/etc/dhcpd.conf# файлын `next-server`, `filename`, болон `option root-path` тохиргоонуудад TFTP-н IP хаяг, TFTP дэх [.filename]#/boot/pxeboot# хүрэх зам болон NFS root файлын системийн замыг зааж өгнө. Жишээ [.filename]#dhcpd.conf# файл ийм байна:
+
[.programlisting]
....
subnet 192.168.0.0 netmask 255.255.255.0 {
   range 192.168.0.2 192.168.0.3 ;
   option subnet-mask 255.255.255.0 ;
   option routers 192.168.0.1 ;
   option broadcast-address 192.168.0.255 ;
   option domain-name-server 192.168.35.35, 192.168.35.36 ;
   option domain-name "example.com";

   # IP address of TFTP server
   next-server 192.168.0.1 ;

   # path of boot loader obtained
   # via tftp
   filename "FreeBSD/install/boot/pxeboot" ;

   # pxeboot boot loader will try to NFS mount this directory for root FS
   option root-path "192.168.0.1:/b/tftpboot/FreeBSD/install/" ;

}
....
====

=== PXE хэрэглэгчийг тохируулах ба холболтын үеийн асуудлуудад дибаг хийх

[.procedure]
====

. Хэрэглэгч машин ачаалахдаа BIOS тохиргооны цэс рүү орно. Сүлжээнээс ачаалахыг BIOS-д тохируулна. Хэрэв өмнөх бүх алхмууд зөв бол бүгд "зүгээр л ажиллах ёстой".
. PXE ачаалах процессын явцад үүсэх сүлжээний урсгалыг дибаг хийхийн тулд package:net/wireshark[]-г ашиглаарай. Үүнийг доорх диаграм дээр дүрсэлсэн байгаа. <<network-pxe-setting-up-dhcp>> хэсэгт жишээ тохиргоог харуулсан бөгөөд DHCP, TFTP ба NFS серверүүд нь нэг машин дээр байна. Гэхдээ эдгээр серверүүд нь өөр өөр машин дээр байж болно.
+
.NFS root холболт ашиглан PXE ачаалах процесс
image::pxe-nfs.png[]
+
. [.filename]#pxeboot#-г TFTP-р авч болж байгаа эсэхийг шалгаарай. TFTP сервер дээрээ [.filename]#/var/log/xferlog# файлыг нээж харан [.filename]#pxeboot# файл зөв газраас татагдаж байгаа эсэхийг шалгаарай. Дээрх [.filename]#dhcpd.conf# файлын тохиргоог шалгахын тулд:
+
[source,bash]
....
# tftp 192.168.0.1
tftp> get FreeBSD/install/boot/pxeboot
Received 264951 bytes in 0.1 seconds
....
+ 
man:tftpd[8] ба man:tftp[1] гарын авлагын хуудаснуудыг уншаарай. TFTP-н зарим нэг хязгаарлалтуудыг `BUGS` хэсэгт тайлбарласан байгаа.
. root файлын системийг NFS-р холбож болж байгаа эсэхийг шалгаарай. Дээрх [.filename]#dhcpd.conf# файлын тохиргоог шалгахын тулд:
+
[source,bash]
....
# mount -t nfs 192.168.0.1:/b/tftpboot/FreeBSD/install /mnt
....
+
. `boot.nfsroot.server` болон `boot.nfsroot.path` гэх мэт хувьсагчуудыг [.filename]#pxeboot# дуудагч хэрхэн тохируулдагийг [.filename]#src/sys/boot/i386/libi386/pxe.c# файлын кодыг уншиж ойлгоорой. Эдгээр хувьсагчууд дараагаар нь [.filename]#src/sys/nfsclient/nfs_diskless.c# файлын NFS-р дискгүй root холбох кодод ашиглагддаг.
. man:pxeboot[8] болон man:loader[8] гарын авлагын хуудаснуудыг уншина уу.
====

[[network-isdn]]
== ISDN

ISDN технологи болон тоног төхөөрөмжийн тухай мэдээллийн сайн эх үүсвэр нь http://www.alumni.caltech.edu/~dank/isdn/[Дан Кегелийн ISDN хуудас] юм.

ISDN-ий тухай хялбар заавруудыг доор дурдав:

* Хэрэв та Европд амьдарч байгаа бол ISDN картын хэсгийг та магадгүй шалгахыг хүсэж болох юм.
* Хэрэв та Интернэт уруу Интернэтийн үйлчилгээ үзүүлэгчтэй dial-up-аар байнгын бишээр холбогдохдоо ISDN-ийг голчлон хэрэглэхээр төлөвлөж байгаа бол та Терминал Хувиргагчдыг үзэж болох юм. Хэрэв та үйлчилгээ үзүүлэгчдээ солих бол энэ нь асуудлууд хамгийн багатайгаар хамгийн уян хатан чанарыг танд өгөх болно.
* Хэрэв та хоёр LAN-ийг хооронд нь холбож байгаа бол эсвэл Интернэт уруу зориулагдсан ISDN холболтоор холбогдож байгаа бол зориулагдсан чиглүүлэгч/гүүр сонголтыг бодолцож болох юм.

Аль шийдлийг сонгохыг тодорхойлоход чухал хүчин зүйл нь өртөг юм. Дараах сонголтуудыг хамгийн бага өртөгтэйгөөс нь эхлээд хамгийн их өртөгтэй хүртэл жагсаав.

[[network-isdn-cards]]
=== ISDN картууд

FreeBSD-ийн ISDN шийдэл нь идэвхгүй картыг ашиглаад зөвхөн DSS1/Q.931 (буюу Euro-ISDN) стандартыг дэмждэг. Firmware нь бас бусад дохионы протоколуудыг дэмждэг зарим идэвхтэй картуудыг дэмждэг; энэ нь бас хамгийн эхэнд дэмжигдсэн Primary Rate (PRI) буюу Анхдагч Хурд бүхий ISDN картыг оруулдаг.

isdn4bsd програм хангамж нь бусад ISDN чиглүүлэгчүүдтэй түүхий HDLC дээгүүрх IP юм уу эсвэл синхрон PPP: өөрчлөн засварласан man:sppp[4] драйвер `isppp`-тэй цөмийн PPP юм уу эсвэл хэрэглэгчийн талбарын man:ppp[8] ашиглан холбогдох боломжийг олгодог. Хэрэглэгчийн талбарын man:ppp[8] ашиглан хоёр буюу түүнээс дээш ISDN B-сувгуудын суваг холболтыг (channel bonding) хийх боломжтой байдаг. Утас хариулагч машины хэрэглээ бас байдаг байдаг бөгөөд бас програм хангамжийн 300 baud модем зэрэг олон хэрэгслүүд байдаг.

FreeBSD дээр дэмжигдсэн зарим PC ISDN картуудын тоо өсөн нэмэгдэж байгаа бөгөөд энэ нь бүх л Европ болон дэлхийн бусад олон хэсэгт амжилттайгаар ашиглагдаж байгаа мэдээллүүд байдаг.

Дэмжигдсэн идэвхгүй (пассив) ISDN картууд нь ихэвчлэн Infineon (хуучин Siemens) ISAC/HSCX/IPAC ISDN бичил схемтэй байдаг, гэхдээ бас Cologne Chip-ийн (зөвхөн ISA шугамд) бичил схемүүдтэй ISDN картууд, Winbond W6692 бичил схемүүдтэй PCI картууд, Tiger300/320/ISAC бичил схемийн хослолуудтой зарим картууд болон AVM Fritz!Card PCI V.1.0 болон AVM Fritz!Card PnP зэрэг зарим нэгэн үйлдвэрлэгчээс хамааралтай бичил схем бүхий картууд ордог.

Одоогоор идэвхтэй дэмжигдсэн ISDN картууд нь AVM B1 (ISA болон PCI) BRI картууд болон AVM T1 PCI PRI картууд юм.

isdn4bsd-ийн баримтын талаар http://people.FreeBSD.org/~hm/[isdn4bsd гарын авлага] зэрэг илүү баримтыг заасан http://www.freebsd-support.de/i4b/[isdn4bsd-ийн эх хуудас] хаягаас үзээрэй.

Хэрэв та өөр ISDN протокол, одоогоор дэмжигдээгүй байгаа ISDN PC картанд зориулж дэмжлэг нэмэх эсвэл isdn4bsd-ийг өргөжүүлэх сонирхолтой байгаа бол {hm}-тай холбоо барьна уу.

isdn4bsd-ийн суулгалт, тохиргоо болон алдааг олж засварлах тухай асуултуудад зориулагдсан link:{freebsd-isdn-url}[freebsd-isdn] захидлын жагсаалт байдаг.

=== ISDN Терминал Хувиргагчид

Терминал хувиргагчид (TA) нь модемууд нь ердийн утасны шугамд зориулагдсан байдаг шиг ISDN-ий хувьд зориулагдсан байдаг.

Ихэнх TA нь стандарт Hayes модемийн AT тушаалын олонлогийг ашигладаг бөгөөд модемийг шууд солих зориулалтаар ашиглаж болно.

TA нь ерөнхийдөө модемтой адил ажилладаг. Ялгаатай тал нь холболт болон дамжуулах хурдны хувьд таны хуучин модемоос хамаагүй хурдан байдаг явдал юм. Та модемийн тохиргоотой яг адил crossref:ppp-and-slip[ppp,PPP]-г тохируулах хэрэгтэй болно. Цуваа хурдыг хамгийн өндрөөр аль болох тавьсан эсэхээ шалгаарай.

TA-г ашиглахын гол давуу тал нь динамик PPP-ээр хийж болдогтой адил Интернэтийн үйлчилгээ үзүүлэгчтэй холбогдох явдал юм. IP хаягийн хэмжээ өдөр ирэх тутам багасаж байгаа өнөө үед ихэнх үйлчилгээ үзүүлэгчид танд статик IP өгөх хүсэлгүй байдаг. Ихэнх зориулагдсан чиглүүлэгчид динамик IP хуваарилалттай зохицож чаддаггүй.

TA-уудын боломжууд болон холболтын тогтвортой байдалд зориулан таны ажиллуулж байдаг PPP дэмонд TA-ууд нь бүрэн найддаг. Хэрэв та PPP-г аль хэдийн тохируулсан бол энэ нь FreeBSD машин дээр модемийг ашиглаж байгаад ISDN уруу хялбараар сайжруулах боломжийг олгодог. Гэхдээ танд тулгарсан PPP програм дээр байсан асуудлууд бас хэвээр үлдэх болно.

Хэрэв та максимум тогтвортой байдлыг хүсэж байгаа бол crossref:ppp-and-slip[userppp,хэрэглэгчийн талбарын PPP] биш цөмийн crossref:ppp-and-slip[ppp,PPP] тохируулгыг ашиглаарай.

Дараах TA-ууд нь FreeBSD-тэй ажилладаг:

* Motorola BitSurfer болон Bitsurfer Pro
* Adtran

Ихэнх бусад TA-ууд нь магадгүй бас ажиллах байх. TA үйлдвэрлэгчид нь өөрсдийнхөө бүтээгдэхүүнийг стандарт модемийн AT тушаалын олонлогийн ихэнхийг хүлээн авч чаддагаар хийхийг оролддог.

Гадаад TA-ийн жинхэнэ асуудал нь модемуудын адил таны компьютер дээр сайн цуваа карт хэрэгтэй явдал юм.

Та цуваа төхөөрөмжүүдийн тухай дэлгэрэнгүй ойлголт болон асинхрон ба синхрон цуваа портуудын ялгаануудын талаар link:{serial-uart}[FreeBSD Цуваа Тоног Төхөөрөмж]ийн заавраас унших шаардлагатай.

Стандарт PC цуваа порт (асинхрон) дээр ажиллаж байгаа TA нь таныг 128 Kbs холболттой байсан ч гэсэн 115.2 Kbs хурдаар хязгаарладаг. ISDN-ий чаддаг 128 Kbs хурдыг бүрэн ашиглахын тулд та TA-г синхрон цуваа карт уруу шилжүүлэх шаардлагатай.

Дотоод TA худалдан авч синхрон/асинхрон асуудлаас тойрон гарчихлаа гэж битгий тэнэгтээрэй. Дотоод TA-ууд нь ердөө л өөр дээрээ бүтээгдсэн стандарт PC цуваа портын бичил схемтэй байдаг. Энэ нь ердөө л өөр цуваа кабель худалдан авч өөр хоосон цахилгаан сокет олох асуудлыг хөнгөвчилдөг.

TA-тэй синхрон карт нь ядаж дангаараа зориулагдсан чиглүүлэгчтэй адил хурдан байдаг бөгөөд түүнийг энгийн FreeBSD хайрцаг удирдаж байгаа нь магадгүй илүү уян хатан юм.

Синхрон карт/TA болон зориулагдсан чиглүүлэгчийн алийг сонгох нь голчлон сүсэг бишрэлийн асуудал байдаг. Энэ талаар зарим хэлэлцүүлэг захидлын жагсаалтуудаар явагдсан байгаа. Бүрэн хэлэлцүүлгийг link:https://www.FreeBSD.org/search/[архивууд]аас хайхыг бид санал болгож байна.

=== Зориулагдсан ISDN Гүүрнүүд/Чиглүүлэгчид

ISDN гүүрнүүд эсвэл чиглүүлэгчид нь зөвхөн FreeBSD эсвэл бусад үйлдлийн системийн хувьд биш юм. Чиглүүлэлт болон гүүр хийх технологийн талаар илүү дэлгэрэнгүй тайлбарыг сүлжээний ямар нэг номноос үзнэ үү.

Энэ хэсгийн хувьд чиглүүлэгч болон гүүр гэсэн ухагдахуунууд нь харилцан солигдож ашиглагдана.

Доод зэрэглэлийн ISDN чиглүүлэгчид/гүүрнүүдийн үнэ багасаж байгаа болохоор энэ нь улам илүү түгээмэл сонголт болох юм. ISDN чиглүүлэгч нь таны локал Ethernet сүлжээ уруу шууд залгагддаг жижиг хайрцаг байдаг бөгөөд бусад гүүр/чиглүүлэгчтэй хийх өөрийн холболтоо удирддаг. Энэ нь PPP болон бусад түгээмэл протоколуудын тусламжтай холболт хийх өөртөө цуг бүтээгдсэн програм хангамжтай байдаг.

Чиглүүлэгч нь бүрэн ISDN холболтыг ашиглах болохоор стандарт TA-аас хамаагүй илүү хурдан дамжуулах боломжийг олгодог.

ISDN чиглүүлэгчид болон гүүрнүүдийн гол асуудал нь үйлдвэрлэгчид хоорондын харилцан ажиллах боломж асуудал хэвээр байгаа явдал юм. Хэрэв та Интернэтийн үйлчилгээ үзүүлэгчтэй холбогдохоор төлөвлөж байгаа бол тэд нартай өөрийн хэрэгцээний талаар хэлэлцэх нь зүйтэй юм.

Хэрэв та өөрийн гэрийн LAN-ийг оффисийн LAN-тай холбох зэргээр хоёр LAN сегментийг хооронд нь холбохоор төлөвлөж байгаа бол энэ нь хамгийн хялбар ажиллагаа багатай шийдэл юм. Та холболт хийгдэх гэж байгаа хоёр талдаа хоёуланд нь зориулан төхөөрөмж авах болохоор холболт ажиллах тал дээр итгэлтэй байж болно.

Жишээ нь гэрийн компьютер эсвэл салбар оффисийн сүлжээг гол оффисийн сүлжээтэй холбохын тулд дараах тохируулгыг ашиглаж болно:

.Салбар оффис эсвэл Гэрийн сүлжээ
[example]
====
Сүлжээ нь 10 base 2 Ethernet ("thinnet") сүлжээний шугаман хэлбэрийг ашиглана. Шаардлагатай бол чиглүүлэгчийг сүлжээний кабельтай AUI/10BT хувиргагчаар холбоно.

image::isdn-bus.png[10 Base 2 Ethernet]

Хэрэв таны гэр/салбар оффис нь зөвхөн нэг компьютер бол та зориулагдсан чиглүүлэгчийг холбохын тулд эрчилсэн хос зөрсөн кабелийг (twisted pair crossover cable) ашиглаж болно.
====

.Гол оффис эсвэл бусад LAN
[example]
====
Сүлжээ нь 10 base T Ethernet ("Twisted Pair") сүлжээний од хэлбэрийг ашиглана.

image::isdn-twisted-pair.png[ISDN Сүлжээний зураг]

====

Ихэнх чиглүүлэгчид/гүүрнүүдийн нэг том давуу тал нь _нэг зэрэг_ 2 тусдаа сайт уруу 2 _тусдаа чөлөөтэй_ PPP холболтуудтай байх боломжийг олгодог явдал юм. Хоёр цуваа порттой тусгай (ихэвчлэн үнэтэй) загваруудыг тооцохгүй бол энэ нь ихэнх TA-ууд дээр дэмжигдээгүй байдаг. Үүнийг суваг холболт (channel bonding), MPP зэрэгтэй андуурч болохгүй.

Жишээ нь хэрэв та оффис дээрээ зориулагдсан ISDN холболттой бөгөөд түүнийг чагнахыг хүсэж байгаа боловч өөр нэг ISDN шугам авахыг хүсэхгүй байгаа бол энэ нь маш ашигтай боломж байж болох юм. Оффист байгаа чиглүүлэгч нь Интернэт уруу хийх зориулагдсан B сувгийн холболтыг (64 Kbps) удирдаж тусдаа өгөгдлийн холболтод зориулж өөр B сувгийг ашиглаж чадна. Хоёр дахь B суваг нь гаднаас залгах, гадагш залгах юм уу эсвэл илүү өргөн зурваст зориулж эхний B сувагтай цуг динамикаар холболт (bonding) хийхэд (MPP зэрэг) ашиглагдаж болно.

Ethernet гүүр нь зөвхөн IP урсгал биш бас өөр илүүг дамжуулах боломжийг танд олгодог. Та IPX/SPX эсвэл өөрийн ашигладаг бусад протоколуудынхаа алийг ч бас илгээж болох юм.

[[network-natd]]
== Network Address Translation буюу Сүлжээний Хаягийн Хөрвүүлэлт

[[network-natoverview]]
=== Тойм

FreeBSD-ийн Network Address Translation буюу Сүлжээний Хаягийн Хөрвүүлэлтийн дэмон нь man:natd[8] гэгддэг бөгөөд ирж байгаа түүхий IP пакетуудыг хүлээн авч эх хаягийг локал машиныхаар сольж эдгээр пакетуудыг гарч байгаа IP пакетийн урсгалд буцааж дахин оруулдаг. man:natd[8] нь өгөгдлийг буцаан хүлээн авахад өгөгдлийн анхны байрлалыг тодорхойлж чаддаг байхаар эхлэл IP хаяг болон портыг өөрчилж түүнийг анхлан хүсэгчид буцааж дамжуулдаг.

NAT-ийн хамгийн түгээмэл хэрэглээ бол Интернэтийн холболт хуваалцах гэгддэгийг хийж гүйцэтгэх явдал юм.

[[network-natsetup]]
=== Анхны тохируулга

IP хаягийн хэмжээ багасаж байгаа болон кабель эсвэл DSL зэрэг өндөр хурдны хэрэглэгчийн шугамууд ашиглах хэрэглэгчдийн тоо ихэссэнээс болоод хүмүүст Интернэтийн холболт хуваалцах шийдлийн хэрэгцээ нэмэгдэх болсон билээ. Хэд хэдэн компьютеруудыг шууд нэг холболтоор холбох чадвар болон IP хаяг нь man:natd[8]-г боломжийн сонголт болгодог.

Хамгийн түгээмэл тохиолдол нь хэрэглэгч кабель эсвэл DSL шугаманд нэг IP хаягтай холбогдсон машинтай бөгөөд LAN-аар дамжуулан хэд хэдэн компьютеруудад Интернэтийн хандалт өгөхийн тулд энэ холбогдсон нэг компьютераа ашиглахыг хүсдэг явдал юм.

Үүнийг хийхийн тулд Интернэт дэх FreeBSD машин нь гарц маягаар ажиллах ёстой. Энэ гарц машин нь хоёр NIC-тэй байх ёстой-нэг нь Интернэтийн чиглүүлэгч уруу холбогдохын тулд, нөгөөх нь LAN уруу холбогдохын тулд ашиглагдах ёстой. LAN дахь бүх машинууд нь холбох төхөөрөмж (hub) юм уу эсвэл шилжүүлэгчээр (switch) холбогдсон байна.

[NOTE]
====
FreeBSD гарцаар LAN-ийг Интернэттэй холбох олон арга замууд байдаг. Энэ жишээ нь хамгийн багаар бодоход хоёр NIC-тэй гарцыг зөвхөн тайлбарлах болно.
====

image::natd.png[Network Layout]

Үүнтэй адил тохиргоог Интернэтийн холболтыг хуваалцахын тулд түгээмэл ашигладаг. LAN машинуудын нэг нь Интернэтэд холбогдсон. Бусад машинууд нь тэр "гарц" машинаар Интернэтэд ханддаг.

[[network-natdloaderconfiguration]]
=== Ачаалагч дуудагчийн тохиргоо

man:natd[8]-ийн тусламжтайгаар хийх сүлжээний хаягийн хөрвүүлэлтэд зориулсан цөмийн боломжууд [.filename]#GENERIC# цөмд идэвхжүүлэгдээгүй байдаг боловч [.filename]#/boot/loader.conf# файлд хоёр тохиргоо нэмж тэдгээрийг ачаалах явцад дуудахаар тохируулж болдог:

[.programlisting]
....
ipfw_load="YES"
ipdivert_load="YES"
....

Мөн `net.inet.ip.fw.default_to_accept` тохиргоог `1` болгож болно:

[.programlisting]
....
net.inet.ip.fw.default_to_accept="1"
....

[NOTE]
====
Галт хана болон NAT гарцыг анх удаа тохируулахдаа энэ тохиргоог тохируулах нь зүйтэй байдаг. Ингэснээр man:ipfw[8]-ийн анхдагч бодлого нь илүү хаалттай `deny ip from any to any` гэсэн бодлого биш харин `allow ip from any to any` гэсэн илүү нээлттэй бодлого болох бөгөөд дахин ачаалалтын дараа системд хандах боломж хэвээр байх юм.
====

[[network-natdkernconfiguration]]
=== Цөмийн тохиргоо

Модулиудыг сонгодгоор биш эсвэл бүх шаардлагатай боломжуудыг цөмд оруулж бүтээхийг хүсэж байгаа бол дараах тохируулгууд цөмийн тохиргооны файлд байх ёстой:

[.programlisting]
....
options IPFIREWALL
options IPDIVERT
....

Мөн нэмэлтээр дараах нь бас тохиромжтой байж болох юм:

[.programlisting]
....
options IPFIREWALL_DEFAULT_TO_ACCEPT
options IPFIREWALL_VERBOSE
....

[[network-natdsystemconfiguration]]
=== Системийн эхлүүлэх тохиргоо

Галт хана болон NAT дэмжлэгийг ачаалах явцад идэвхжүүлэхийн тулд дараах мөрүүдийг [.filename]#/etc/rc.conf# файлд оруулж өгөх ёстой:

[.programlisting]
....
gateway_enable="YES" <.>
firewall_enable="YES" <.>
firewall_type="OPEN" <.>
natd_enable="YES"
natd_interface="fxp0" <.>
natd_flags="" <.>
....

<.> Машиныг гарц маягаар ажиллахыг тохируулна. `sysctl net.inet.ip.forwarding=1` тушаалыг ажиллуулах нь бас адил үр дүнтэй.
[.filename]#/etc/rc.firewall# файл дахь галт ханын дүрмүүдийг ачаалах үед идэвхжүүлнэ.

<.> Энэ нь урьдчилан тодорхойлсон байдаг бүгдийг оруулахыг зөвшөөрдөг галт ханын дүрмийн олонлогийг заана. Нэмэлт төрлүүдийн талаар [.filename]#/etc/rc.firewall# файлаас үзнэ үү.

<.> Аль интерфэйс пакетуудыг нэвтрүүлэн дамжуулахыг заана (Интернэтэд холбогдсон интерфэйс).

<.> Ачаалах үед man:natd[8]-д дамжуулах нэмэлт тохиргооны сонголтууд.

Өмнөх тохируулгуудыг [.filename]#/etc/rc.conf# файлд тодорхойлсноор `natd -interface fxp0` тушаалыг ачаалах үед ажиллуулна. Үүнийг гараар бас ажиллуулж болно.

[NOTE]
====
Их олон сонголтуудыг дамжуулах бол man:natd[8]-д зориулж тохиргооны файлыг ашиглаж бас болно. Энэ тохиолдолд дараах мөрийг [.filename]#/etc/rc.conf# файлд нэмж тохиргооны файлыг тодорхойлох шаардлагатай:

[.programlisting]
....
natd_flags="-f /etc/natd.conf"
....

[.filename]#/etc/natd.conf# файл нь тохиргооны сонголтуудын жагсаалтыг нэг мөрөнд нэгийг байхаар агуулдаг. Жишээ нь дараах хэсгийн хувьд доорх файлыг ашиглах болно:

[.programlisting]
....
redirect_port tcp 192.168.0.2:6667 6667
redirect_port tcp 192.168.0.3:80 80
....

Тохиргооны файлын тухай дэлгэрэнгүй мэдээллийг man:natd[8] гарын авлагын хуудасны `-f` тохируулгын талаар бичсэнээс лавлана уу.
====

LAN-ий ард байгаа машин болон интерфэйс бүр link:ftp://ftp.isi.edu/in-notes/rfc1918.txt[RFC 1918]-д тодорхойлогдсон хувийн сүлжээний хаягаас заагдсан IP хаягтай, natd машины дотоод IP хаягийг анхдагч гарц болгон заасан байх ёстой.

Жишээ нь LAN-ий цаана байгаа клиент `A` болон `B` нь `192.168.0.2` болон `192.168.0.3` гэсэн IP хаягтай байх бол natd машины LAN интерфэйс нь `192.168.0.1` гэсэн IP хаягтай байна. Клиент `A` болон `B`-ийн анхдагч гарц natd машины `192.168.0.1`-ээр тохируулагдах ёстой. natd машины гадаад буюу Интернэтийн интерфэйс нь man:natd[8]-г ажиллуулахын тулд ямар нэгэн тусгайлсан өөрчлөлтийг шаарддаггүй.

[[network-natdport-redirection]]
=== Порт дахин чиглүүлэлт

man:natd[8]-ийн сул тал нь LAN клиентүүдэд Интернэтээс хандах боломжгүй байдаг. LAN дахь клиентүүд нь гаднах ертөнц уруу чиглэсэн гадагшаа холболтуудыг хийж чадах боловч ирж байгааг хүлээн авч чаддаггүй. LAN клиент машинуудын аль нэгэн дээр Интернэтийн үйлчилгээнүүдийг ажиллуулахыг оролдох үед энэ нь асуудал үүсгэдэг. Үүнийг тойрох хялбар арга бол natd машины сонгосон Интернэтийн портуудыг LAN клиент уруу дахин чиглүүлэх явдал юм. 

Жишээ нь `A` клиент дээр IRC сервер, `B` клиент дээр вэб сервер ажиллаж байна гэж үзье. Эдгээр нь зөв ажиллахын тулд 6667 (IRC) болон 80 (вэб) портууд дээр хүлээн авсан холболтууд нь тохирох машинууд уруу дахин чиглүүлэгдэх ёстой юм. 

man:natd[8] уруу `-redirect_port` тохируулга зохих сонголтуудтай дамжуулагдах ёстой. Зөв бичих дүрэм нь ийм байна:

[.programlisting]
....
     -redirect_port proto targetIP:targetPORT[-targetPORT]
                 [aliasIP:]aliasPORT[-aliasPORT]
                 [remoteIP[:remotePORT[-remotePORT]]]
....

Дээрх жишээний хувьд нэмэлт өгөгдөл нь ийм байх ёстой:

[.programlisting]
....
    -redirect_port tcp 192.168.0.2:6667 6667
    -redirect_port tcp 192.168.0.3:80 80
....

 Энэ нь зөв _tcp_ портуудыг LAN клиент машинууд уруу дахин чиглүүлэх болно. 

`-redirect_port` нэмэлт өгөгдлийг порт тус бүрийг заахад ашиглахаас гадна бас бүлэг портуудыг заахад хэрэглэж болно. Жишээ нь _tcp 192.168.0.2:2000-3000 2000-3000_ нь 2000-аас 3000 хүртэлх портууд дээр хүлээн авсан бүх холболтуудыг `A` клиентийн 2000-аас 3000 хүртэлх портууд уруу дахин чиглүүлэх болно.

Эдгээр тохируулгуудыг man:natd[8]-г шууд ажиллуулж байх үед [.filename]#/etc/rc.conf# файлд `natd_flags=""` тохируулга дотор оруулж ашиглаж болохоос гадна тохиргооны файлын тусламжтай дамжуулж болно.

Тохиргооны сонголтуудын талаар man:natd[8]-с лавлана уу

[[network-natdaddress-redirection]]
=== Хаяг дахин чиглүүлэлт

Хаягийн дахин чиглүүлэлт нь хэд хэдэн IP хаягууд байгаа бөгөөд тэдгээр нь нэг машин дээр байх ёстой үед ашигтай байдаг. Үүнийг ашиглаад man:natd[8] нь өөрийн LAN клиент бүрдээ өөрийн гадаад IP хаягуудыг өгч чаддаг. Дараа нь man:natd[8] нь LAN клиентүүдээс ирэх гадагш чиглэсэн пакетуудыг зөв гадаад IP хаягаас болгон дахин бичиж тухайн IP хаяг дээр ирж байгаа бүх урсгалыг тохирох LAN клиент уруу дахин чиглүүлдэг. Энэ нь бас статик NAT гэж нэрлэгддэг. Жишээ нь `128.1.1.1`, `128.1.1.2`, болон `128.1.1.3` гэсэн IP хаягууд нь natd гарц машинд харьяалагдаж байна гэж үзье. `128.1.1.1` нь natd гарц машины гадаад IP хаяг болон ашиглагдаж болох бол `128.1.1.2` болон `128.1.1.3` нь `A` болон `B` LAN клиентүүд уруу буцааж дамжуулагдахаар байж болно.

`-redirect_address` бичлэг нь дараах маягийн байна:

[.programlisting]
....
-redirect_address localIP publicIP
....

[.informaltable]
[cols="1,1", frame="none"]
|===

|localIP
|LAN клиентийн дотоод IP хаяг.

|publicIP
|LAN клиентэд тохирох гадаад IP хаяг.
|===

Энэ жишээний хувьд энэхүү нэмэлт өгөгдөл нь ингэж уншигдаж болно:

[.programlisting]
....
-redirect_address 192.168.0.2 128.1.1.2
-redirect_address 192.168.0.3 128.1.1.3
....

`-redirect_port` тохируулгын нэгэн адил эдгээр нэмэлт өгөгдлүүдийг [.filename]#/etc/rc.conf# файлын `natd_flags=""` тохируулгад хийж өгч болохоос гадна тохиргооны файлаар дамжуулж болно. Хаягийн дахин чиглүүлэлт дээр тухайн нэг IP хаяг дээр хүлээн авсан бүх өгөгдөл дахин чиглүүлэгддэг учраас портын дахин чиглүүлэлт шаардлагагүй байдаг.

natd машины гадаад IP хаягууд нь идэвхтэй байж гадаад интерфэйсийн нэрээр нэрлэгдсэн байх ёстой. Үүнийг хийхийн тулд man:rc.conf[5]-г үзнэ үү.

[[network-ipv6]]
== IPv6

IPv6 (бас IPng "IP next generation" буюу дараа үеийн IP гэгддэг) нь олонд танигдсан IP протоколын (бас IPv4 гэгддэг) шинэ хувилбар юм. Одоогийн бусад *BSD системүүдийн адил FreeBSD нь KAME IPv6 лавлагаа шийдлийг агуулдаг. Тэгэхээр таны FreeBSD систем таныг IPv6-г туршихад хэрэгтэй бүхнийг агуулсан байдаг. Энэ хэсэг нь IPv6-г тохируулж ажиллуулах талаар анхаарлаа хандуулах болно.

1990 оны эхэн үеэс хүмүүс IPv4-ийн хаягийн хэмжээ хурдацтай багасаж байгааг мэдэх болсон. Интернэтийн өсөлтийн хурдаас хамаараад хоёр гол асуудал гарч ирсэн:

* Хаяггүй болж эхэлсэн. RFC1918 хувийн хаягийн талбар (`10.0.0.0/8`, `172.16.0.0/12`, болон `192.168.0.0/16`) болон Network Address Translation (NAT) буюу Сүлжээний хаягийн хөрвүүлэлтийг ашигладаг болсон болохоор өнөөдөр энэ нь тийм ч чухал асуудал байхаа больсон.
* Чиглүүлэгчийн хүснэгтийн оруулгууд хэтэрхий ихсэж байгаа явдал. Энэ нь өнөөдөр асуудал хэвээр байгаа билээ.

IPv6 нь эдгээр асуудлууд болон өөр бусад олныг шийддэг:

* 128 битийн хаягийн талбар. Өөрөөр хэлбэл онолын хувьд 340,282,366,920,938,463,463,374,607,431,768,211,456 хаяг байна. Энэ нь манай гариг дээрх нэг квадрат метр бүрт ойролцоогоор 6.67 * 10^27 IPv6 хаяг байна гэсэн үг юм.
* Чиглүүлэгчүүд нь зөвхөн сүлжээний нийлбэр хаягуудыг өөрсдийн чиглүүлэлтийн хүснэгтүүдэд хадгалах бөгөөд ингэснээр чиглүүлэлтийн хүснэгтийн дундаж хэмжээг 8192 хүртэл бууруулдаг.

IPv6-ийн бусад ашигтай олон боломжууд бас байдаг, тэдгээрээс дурдвал:

* Хаягийн автомат тохиргоо (http://www.ietf.org/rfc/rfc2462.txt[RFC2462])
* Anycast хаягууд ("one-out-of many" буюу олноос ганц)
* Зайлшгүй шаардлагатай (mandatory) multicast хаягууд
* IPsec (IP security буюу нууцлаг)
* Хялбаршуулсан толгойн бүтэц
* Хөдөлгөөнт IP
* IPv6-to-IPv4 шилжилтийн арга замууд

Дэлгэрэнгүй мэдээллийн талаар доороос үзнэ үү:

* http://playground.sun.com/pub/ipng/html/ipng-main.html[playground.sun.com] дэх IPv6-ийн тухай тойм 
* http://www.kame.net[KAME.net]

=== IPv6 хаягуудын тухай суурь мэдээлэл

IPv6 хаягуудын өөр өөр төрлүүд байдаг: Unicast, Anycast, болон Multicast.

Unicast хаягууд нь бидний мэддэг хаягууд юм. Unicast хаяг уруу илгээсэн пакет нь яг тэр хаягт харгалзах интерфэйс дээр ирдэг.

Anycast хаягуудыг unicast хаягуудаас ялгах боломжгүй байдаг боловч тэдгээр нь бүлэг интерфэйсүүдийг хаягладаг. Anycast хаяг уруу чиглэсэн пакет хамгийн ойрын (чиглүүлэгчийн хэмжилтийн хувьд) интерфэйс дээр ирэх болно. Anycast хаягуудыг зөвхөн чиглүүлэгчид ашиглаж болох юм.

Multicast хаягууд нь бүлэг интерфэйсүүдийг таньдаг. Multicast хаяг уруу чиглэсэн пакет нь multicast бүлэгт харьяалагдах бүх интерфэйсүүд дээр ирэх болно.

[NOTE]
====
IPv4 цацах (broadcast) хаяг (ихэвчлэн `xxx.xxx.xxx.255`) нь IPv6-ийн multicast хаягуудаар илэрхийлэгддэг.
====

.Нөөц IPv6 хаягууд
[cols="1,1,1,1", frame="none", options="header"]
|===
| IPv6 хаяг
| Prefixlength буюу угтварын урт (битээр)
| Тайлбар
| Тэмдэглэл

|`::`
|128 бит
|тодорхойлогдоогүй
|харьцуулбал IPv4 дэх `0.0.0.0`

|`::1`
|128 бит
|loopback буюу буцах хаяг
|харьцуулбал IPv4 дэх `127.0.0.1`

|`::00:xx:xx:xx:xx`
|96 бит
|суулгагдсан IPv4
|Бага 32 бит нь IPv4 хаяг юм. Бас "IPv4 нийцтэй IPv6 хаяг" гэгддэг

|`::ff:xx:xx:xx:xx`
|96 бит
|IPv4-р илэрхийлэгдсэн IPv6 хаяг
|Бага 32 бит нь IPv4 хаяг юм. IPv6-г дэмждэггүй хостуудад зориулсан.

|`fe80::` - `feb::`
|10 бит
|link-local
|харьцуулбал IPv4 дэх loopback буюу буцах хаяг

|`fec0::` - `fef::`
|10 бит
|site-local
|

|`ff::`
|8 бит
|multicast
|

|`001` (хоёртын системээр)
|3 бит
|глобал unicast
|Бүх глобал unicast хаягууд нь энэ цөөрмөөс заагдана. Эхний 3 бит нь "001" байна.
|===

=== IPv6 хаягуудыг унших нь

Дүрмийн дагуу ийм хэлбэртэй байна: `x:x:x:x:x:x:x:x` хэлбэрийн байх бөгөөд "x" бүр нь 16 битийн арван зургаат утга байна. Жишээ нь `FEBC:A574:382B:23C1:AA49:4592:4EFE:9982`

Хаяг нь ихэнхдээ дандаа тэгүүдээс тогтох урт дэд хэсгүүдээс тогтож болох бөгөөд хаягийн тийм хэсгийг "::" гэж хураангуйлж болно. Дөрвөн арван зургаат тооны гурав хүртэлх эхний "0"-үүдийг орхиж бас болно. Жишээ нь `fe80::1` нь дүрэмд заасан хэлбэрээр бол `fe80:0000:0000:0000:0000:0000:0000:0001` байна.

Гурав дахь хэлбэр нь сүүлийн 32 бит хэсгийг бидний мэддэг (аравтын) IPv4 загварын цэгүүдээр "." тусгаарлаж бичих явдал юм. Жишээ нь `2002::10.0.0.1` нь (арван зургаатын) дүрэмд зааснаар `2002:0000:0000:0000:0000:0000:0a00:0001` болох бөгөөд үүнийг бас `2002::a00:1` гэж бичиж болох юм.

Энэ хүртэл уншигч доор дурдсаныг ойлгож чадаж байх ёстой:

[source,bash]
....
# ifconfig
....

[.programlisting]
....
rl0: flags=8943<UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST> mtu 1500
         inet 10.0.0.10 netmask 0xffffff00 broadcast 10.0.0.255
         inet6 fe80::200:21ff:fe03:8e1%rl0 prefixlen 64 scopeid 0x1
         ether 00:00:21:03:08:e1
         media: Ethernet autoselect (100baseTX )
         status: active
....

`fe80::200:21ff:fe03:8e1%rl0` нь автоматаар тохируулагдсан link-local хаяг юм. Энэ нь MAC хаягаас автомат тохиргооны хэсэг болон үүсгэгддэг.

IPv6 хаягуудын бүтцийн тухай дэлгэрэнгүй мэдээллийг http://www.ietf.org/rfc/rfc3513.txt[RFC3513] хаягаас үзнэ үү.

=== Холбогдох нь

Одоогоор бусад IPv6 хостууд болон сүлжээнүүдтэй холбогдох дөрвөн арга байдаг:

* IPv6 үйлчилгээ үзүүлдэг эсэхийг мэдэхийн тулд өөрийн Интернэтийн үйлчилгээ үзүүлэгчид хандах хэрэгтэй.
* http://www.sixxs.net[SixXS] нь дэлхий даяар эцсийн хэрэглэгчдийн хооронд туннелийн үйлчилгээ үзүүлдэг.
* 6-аас-4 уруу туннель хийх (http://www.ietf.org/rfc/rfc3068.txt[RFC3068])
* Хэрэв та dial-up холболт дээр байгаа бол package:net/freenet6[] портыг ашиглах хэрэгтэй.

=== IPv6 ертөнц дэх DNS

IPv6-д зориулсан хоёр төрлийн DNS бичлэг байдаг. IETF нь A6 бичлэгийг хуучин, хэрэгцээнээс гарсан гэж зарласан. AAAA бичлэгүүд нь одоо стандарт болсон байгаа.

AAAA бичлэгүүдийг ашиглах нь амархан. Өөрийн хостын нэрийг дөнгөж авсан шинэ IPv6 хаягт зааж доор дурдсаныг:

[.programlisting]
....
MYHOSTNAME           AAAA    MYIPv6ADDR
....

өөрийн анхдагч бүсийн DNS файл уруу нэмж өгнө. Та өөрийн DNS бүсүүдийг удирддаггүй бол өөрийн DNS үйлчилгээ үзүүлэгчээс асуух хэрэгтэй. bind (8.3 ба 9 хувилбар) болон package:dns/djbdns[]-ийн (IPv6 засвартай) одоогийн хувилбарууд AAAA бичлэгүүдийг дэмждэг.

=== [.filename]#/etc/rc.conf# файлд хэрэгцээтэй өөрчлөлтүүдийг хийх нь

==== IPv6 клиентийн тохиргоонууд

Эдгээр тохиргоонууд нь таны LAN-д байх машиныг чиглүүлэгч биш клиент маягаар ажиллуулахаар тохируулахад танд туслах болно. Таны интерфэйсийг ачаалах үед автоматаар man:rtsol[8]-оор тохируулуулахын тулд FreeBSD 9._x_ ба түүнээс хойшхи хувилбарууд дээр дараах мөрийг:

[.programlisting]
....
ipv6_prefer="YES"
....

[.filename]#rc.conf# файлд нэмнэ.

FreeBSD 8._x_ болон түүнээс өмнөх дээр дараахийг нэмнэ:

[.programlisting]
....
ipv6_enable="YES"
....

`2001:471:1f11:251:290:27ff:fee0:2093` зэрэг IP хаягийг өөрийн [.filename]#fxp0# интерфэйсд статикаар өгөхийн тулд FreeBSD 9._x_-н хувьд доор дурдсаныг нэмнэ:

[.programlisting]
....
ifconfig_fxp0_ipv6="inet6 2001:471:1f11:251:290:27ff:fee0:2093 prefixlen 64"
....

[NOTE]
====
Компьютерийн сүлжээнд холбогдсон тэр дэд сүлжээний зөв утгыг оруулж _prefixlen 64_-г солихоо мартуузай.
====

FreeBSD 8__x__ болон түүнээс өмнөхийн хувьд дараахийг нэмнэ:

[.programlisting]
....
ipv6_ifconfig_fxp0="2001:471:1f11:251:290:27ff:fee0:2093"
....

`2001:471:1f11:251::1` анхдагч чиглүүлэгчийг зааж өгөхдөө доор дурдсаныг [.filename]#/etc/rc.conf# файлд нэмнэ:

[.programlisting]
....
ipv6_defaultrouter="2001:471:1f11:251::1"
....

==== IPv6 чиглүүлэгч/гарцын тохиргоонууд

Энэ нь таны туннелийн үйлчилгээ үзүүлэгчийн өгсөн чиглэлүүдийг авч тэдгээрийг дахин ачаалсан ч гэсэн үлдэхээр болгож тохиргоо болгон хөрвүүлэхэд танд туслах болно. Эхлүүлэх үед өөрийн туннелийг сэргээхийн тулд доор дурдсантай төстэйг [.filename]#/etc/rc.conf# файлд ашиглана:

Тохируулах Ердийн Туннель хийх интерфэйсүүдийг жагсаана. Жишээ нь [.filename]#gif0#:

[.programlisting]
....
gif_interfaces="gif0"
....

_MY_IPv4_ADDR_ гэсэн локал төгсгөлтэй интерфэйсийг _REMOTE_IPv4_ADDR_ гэсэн алсын төгсгөл уруу тохируулахын тулд:

[.programlisting]
....
gifconfig_gif0="MY_IPv4_ADDR REMOTE_IPv4_ADDR"
....

Өөрийн IPv6 туннелийн төгсгөл болгон ашиглахаар таны зааж өгсөн IPv6 хаягийг хамааруулахын тулд FreeBSD 9._x_ болон түүнээс хойшхийн хувьд доор дурдсаныг нэмнэ:

[.programlisting]
....
ifconfig_gif0_ipv6="inet6 MY_ASSIGNED_IPv6_TUNNEL_ENDPOINT_ADDR"
....

FreeBSD 8._x_ ба түүнээс өмнөхийн хувьд дараахийг нэмнэ:

[.programlisting]
....
ipv6_ifconfig_gif0="MY_ASSIGNED_IPv6_TUNNEL_ENDPOINT_ADDR"
....

Тэгээд таны хийх зүйл чинь IPv6-д зориулж анхдагч чиглүүлэлт тохируулах явдал юм. Энэ нь IPv6 туннелийн нөгөө тал байх болно:

[.programlisting]
....
ipv6_defaultrouter="MY_IPv6_REMOTE_TUNNEL_ENDPOINT_ADDR"
....

==== IPv6 туннелийн тохиргоонууд

Хэрэв сервер нь таны бусад сүлжээ болон гадаад ертөнцийн хооронд IPv6-г чиглүүлэх бол дараах [.filename]#/etc/rc.conf# тохируулга бас хэрэгтэй болно:

[.programlisting]
....
ipv6_gateway_enable="YES"
....

=== Чиглүүлэгчийн зарлалт ба Хостын автомат тохиргоо

Энэ хэсэг нь IPv6 анхдагч чиглүүлэлтийг зарлахын тулд man:rtadvd[8]-г тохируулахад тань туслах болно.

man:rtadvd[8]-г идэвхжүүлэхийн тулд таны [.filename]#/etc/rc.conf# файлд дараах тохиргоо хэрэгтэй болно:

[.programlisting]
....
rtadvd_enable="YES"
....

IPv6 чиглүүлэгчийн төлөөлөлт хийгдэх интерфэйсийг заах нь чухал юм. Жишээ нь man:rtadvd[8]-д [.filename]#fxp0#-г ашиглахыг хэлж өгөхийн тулд доор дурдсаныг нэмнэ:

[.programlisting]
....
rtadvd_interfaces="fxp0"
....

Одоо бид [.filename]#/etc/rtadvd.conf# тохиргооны файл үүсгэх ёстой. Энд жишээ байна:

[.programlisting]
....
fxp0:\
	:addrs#1:addr="2001:471:1f11:246::":prefixlen#64:tc=ether:
....

[.filename]#fxp0#-г өөрийн ашиглах интерфэйсээр солих хэрэгтэй.

Дараа нь `2001:471:1f11:246::`-г өөрийн хуваарилалтын угтвараар солиорой.

Хэрэв та `/64` дэд сүлжээг зориулсан бол өөр бусад ямар ч өөрчлөлт хийх хэрэггүй. Хэрэв тийм биш бол та `prefixlen#` буюу угтварын уртыг зөв утгаар өөрчлөх шаардлагатай.

[[network-atm]]
== Asynchronous Transfer Mode (ATM) буюу Асинхрон Дамжуулах Горим

=== ATM дээгүүр классик IP тохируулах нь (PVC-нүүд)

Classical IP over ATM (CLIP) буюу ATM дээгүүрх классик IP нь Asynchronous Transfer Mode (ATM) буюу Асинхрон Дамжуулах Горимыг IP-тай ашиглах хамгийн энгийн арга юм. Энэ нь switched буюу шилжүүлэгдсэн (SVC-нүүд) ба permanent буюу байнгын (PVC-нүүд) холболтуудтай ашиглагдаж болдог. Энэ хэсэг нь сүлжээн дээр тулгуурласныг PVC-нүүд дээр хэрхэн тохируулах талаар тайлбарладаг.

==== Бүрэн тор хэлбэрийн тохиргоонууд

CLIP-ийг PVC-нүүдтэй тохируулах эхний арга нь машин бүрийг сүлжээн дэх бусад машин бүртэй зориулагдсан PVC-ээр холбох явдал юм. Үүнийг тохируулах хялбар байдаг боловч их олон тооны машинууд дээр бүтэшгүй байдаг. Энэ жишээ нь сүлжээнд бидэнд дөрвөн машин байгаа бөгөөд машин бүр ATM сүлжээнд ATM хувиргагч картын тусламжтай холбогдсон гэж үздэг. Эхний алхам нь IP хаягууд болон машинуудын хооронд ATM холболтуудыг төлөвлөх явдал юм. Бид доор дурдсаныг ашиглана:

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Хост
| IP хаяг

|`hostA`
|`192.168.173.1`

|`hostB`
|`192.168.173.2`

|`hostC`
|`192.168.173.3`

|`hostD`
|`192.168.173.4`
|===

Бүрэн тор хэлбэрийн сүлжээг бүтээхийн тулд машинуудын хослол бүрийн хооронд нэг ATM холболт бидэнд хэрэгтэй:

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Машинууд
| VPI.VCI хослол

|`hostA` - `hostB`
|0.100

|`hostA` - `hostC`
|0.101

|`hostA` - `hostD`
|0.102

|`hostB` - `hostC`
|0.103

|`hostB` - `hostD`
|0.104

|`hostC` - `hostD`
|0.105
|===

Холболтын төгсгөл бүр дэх VPI болон VCI утгууд нь мэдээж ялгаатай байх боловч амархан байлгах үүднээс бид тэдгээрийг адил гэж үзнэ. Дараа нь бид ATM интерфэйсүүдийг хост бүр дээр тохируулах хэрэгтэй болно:

[source,bash]
....
hostA# ifconfig hatm0 192.168.173.1 up
hostB# ifconfig hatm0 192.168.173.2 up
hostC# ifconfig hatm0 192.168.173.3 up
hostD# ifconfig hatm0 192.168.173.4 up
....

Ингэхдээ бүх хостууд дээр ATM интерфэйс нь [.filename]#hatm0# гэж үзэх болно. Одоо PVC-нүүд нь `hostA` дээр тохируулагдах шаардлагатай (бид тэдгээрийг ATM шилжүүлэгч дээр аль хэдийн тохируулагдсан гэж үзнэ, үүнийг хэрхэн хийхийг шилжүүлэгчийн гарын авлагаас лавлах хэрэгтэй).

[source,bash]
....
hostA# atmconfig natm add 192.168.173.2 hatm0 0 100 llc/snap ubr
hostA# atmconfig natm add 192.168.173.3 hatm0 0 101 llc/snap ubr
hostA# atmconfig natm add 192.168.173.4 hatm0 0 102 llc/snap ubr

hostB# atmconfig natm add 192.168.173.1 hatm0 0 100 llc/snap ubr
hostB# atmconfig natm add 192.168.173.3 hatm0 0 103 llc/snap ubr
hostB# atmconfig natm add 192.168.173.4 hatm0 0 104 llc/snap ubr

hostC# atmconfig natm add 192.168.173.1 hatm0 0 101 llc/snap ubr
hostC# atmconfig natm add 192.168.173.2 hatm0 0 103 llc/snap ubr
hostC# atmconfig natm add 192.168.173.4 hatm0 0 105 llc/snap ubr

hostD# atmconfig natm add 192.168.173.1 hatm0 0 102 llc/snap ubr
hostD# atmconfig natm add 192.168.173.2 hatm0 0 104 llc/snap ubr
hostD# atmconfig natm add 192.168.173.3 hatm0 0 105 llc/snap ubr
....

Мэдээж хэрэг UBR-с бусад урсгалын хэлэлцээнүүд хэрэв ATM хувиргагч тэдгээрийг дэмждэг бол ашиглагдаж болно. Энэ тохиолдолд урсгалын хэлэлцээний нэр нь урсгалын нэмэлт өгөгдлүүдийн дараа орж байна. man:atmconfig[8] хэрэгсэлд зориулсан тусламжийг дараах тушаалыг ашиглан:

[source,bash]
....
# atmconfig help natm add
....

авч болох бөгөөд эсвэл man:atmconfig[8] гарын авлагаас авч болно.

Үүнтэй адил тохиргоог [.filename]#/etc/rc.conf# ашиглан бас хийж болно. `hostA`-ийн хувьд энэ нь иймэрхүү харагдана:

[.programlisting]
....
network_interfaces="lo0 hatm0"
ifconfig_hatm0="inet 192.168.173.1 up"
natm_static_routes="hostB hostC hostD"
route_hostB="192.168.173.2 hatm0 0 100 llc/snap ubr"
route_hostC="192.168.173.3 hatm0 0 101 llc/snap ubr"
route_hostD="192.168.173.4 hatm0 0 102 llc/snap ubr"
....

Бүх CLIP чиглүүлэлтүүдийн тухайн үеийн төлвийг дараах тушаалаар авч болно:

[source,bash]
....
hostA# atmconfig natm show
....

[[carp]]
== Common Address Redundancy Protocol (CARP)

Common Address Redundancy Protocol буюу CARP нь олон хостуудад нэг IP хаяг хуваалцах боломжийг олгодог. Зарим тохиргоонуудын хувьд үүнийг байнгын бэлэн байдал юм уу эсвэл ачаалал тэгш хуваарилахад ашиглаж болох юм. Энд дурдсан жишээний адилаар хостууд нь бас өөр өөр IP хаягууд ашиглаж болох юм.

CARP-ийн дэмжлэгийг идэвхжүүлэхийн тулд FreeBSD цөмийг crossref:kernelconfig[kernelconfig,FreeBSD цөмийг тохируулах нь] бүлэгт заасны дагуу дараах тохируулгатайгаар бүтээсэн байх хэрэгтэй:

[.programlisting]
....
device	carp
....

Мөн өөрөөр [.filename]#if_carp.ko# модулийг ачаалах үед дуудаж болно. Ингэхийн тулд дараах мөрийг [.filename]#/boot/loader.conf# нэмж өгнө:

[.programlisting]
....
if_carp_load="YES"
....

CARP боломж нь одоо хүртээмжтэй болсон байх ёстой бөгөөд түүнийг хэд хэдэн `sysctl`-ийн OID-уудын тусламжтайгаар тааруулж болно:

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| OID
| Тайлбар

|`net.inet.carp.allow`
|Ирж байгаа CARP пакетуудыг хүлээж авах. Анхдагчаар идэвхжсэн байдаг.

|`net.inet.carp.preempt`
|Энэ тохируулга нь хост дээрх бүх CARP интерфэйсүүдийг аль нэг нь зогссон тохиолдолд зогсоодог. Анхдагчаар идэвхжээгүй байдаг.

|`net.inet.carp.log`
|`0` гэсэн утга нь бүртгэлийг идэвхжүүлдэггүй. `1` гэсэн утга нь муу CARP пакетуудын бүртгэлийг идэвхжүүлдэг. `1`-ээс их утгууд нь CARP интерфэйсүүдийн хувьд төлвийн өөрчлөлтүүдийн бүртгэлийг идэвхжүүлдэг. Анхдагч утга нь `1` байна.

|`net.inet.carp.arpbalance`
|ARP ашиглан дотоод сүлжээний урсгалыг тэнцвэржүүлнэ. Анхдагчаар идэвхжээгүй байдаг.

|`net.inet.carp.suppress_preempt`
|Preemption буюу өөр илүү өндөр давуу эрх бүхий бодлого/урсгалаар солигдох боломжийг хаасан хориглолтын төлвийг үзүүлэх зөвхөн уншигдах OID. Хэрэв интерфэйс дээрх холбоос босоогүй бол илүү өндөр давуу эрх бүхий бодлого/урсгалаар солигдох боломжийг хааж болно. `0` утга нь илүү өндөр давуу эрх бүхий бодлого/урсгалаар солигдох боломж хаагдаагүй гэсэн утгатай. Асуудал бүр энэ OID-ийг нэгээр ахиулж нэмэгдүүлнэ.
|===

CARP төхөөрөмжүүдийг `ifconfig` тушаалаар үүсгэж болно:

[source,bash]
....
# ifconfig carp0 create
....

Жинхэнэ амьдрал дээр эдгээр интерфэйсүүдэд VHID гэгддэг давхардахгүй дугаарууд хэрэгтэй болно. Энэ VHID буюу Виртуал Хостын Үнэмлэх нь сүлжээн дэх хостыг ялгахад хэрэглэгдэх болно.

=== Серверт хандах боломжийг байнга хангахын тулд CARP-ийг ашиглах нь (CARP)

Дээр дурдсан CARP-ийн нэг хэрэглээ нь серверийн бэлэн байдалд зориулагджээ. Энэ жишээ нь өөр өөр IP хаягуудтай, ижил вэбийн агуулга бүхий гурван хостын хувьд байнгын бэлэн байдалд байх дэмжлэгийг харуулах болно. Эдгээр машинууд нь Тойрон Эргэх DNS тохиргоотойгоор ажиллах болно. Амжилтгүй болсон үед хандах нөөц машин нь хоёр нэмэлт CARP интерфэйстэй байх бөгөөд агуулгын сервер бүрийн IP-ний хувьд ашиглагдана. Хандалт амжилтгүй болоход амжилтгүй болсон машины IP хаягийг нөөц сервер авах ёстой. Энэ нь хэрэглэгчид амжилтгүй болсон нь мэдэгдэхгүй гэсэн үг юм. Нөөц сервер нь ачааллыг авах ёстой бол бусад агуулгын серверүүдтэй ижил агуулга болон үйлчилгээнүүдтэй байх ёстой.

Хоёр машин нь өгөгдсөн хостын нэр болон VHID-үүдээс бусдаараа адилхан тохируулагдсан байх ёстой. Энэ жишээн дээр эдгээр машинуудыг `hosta.example.org` болон `hostb.example.org` гэж нэрлэсэн байгаа. Эхлээд CARP-ийн тохиргоонд шаардлагатай мөрүүдийг [.filename]#rc.conf# файлд нэмэх хэрэгтэй. `hosta.example.org` хостын хувьд [.filename]#rc.conf# файл доор дурдсан мөрүүдийг агуулсан байх ёстой:

[.programlisting]
....
hostname="hosta.example.org"
ifconfig_fxp0="inet 192.168.1.3 netmask 255.255.255.0"
cloned_interfaces="carp0"
ifconfig_carp0="vhid 1 pass testpass 192.168.1.50/24"
....

`hostb.example.org` дээр доор дурдсан мөрүүдийг [.filename]#rc.conf# файл агуулсан байх ёстой:

[.programlisting]
....
hostname="hostb.example.org"
ifconfig_fxp0="inet 192.168.1.4 netmask 255.255.255.0"
cloned_interfaces="carp0"
ifconfig_carp0="vhid 2 pass testpass 192.168.1.51/24"
....

[NOTE]
====
Хамгийн чухал нь `ifconfig` тушаалд `pass` тохируулгаар заагдсан нууц үгс нь адил байх ёстой. [.filename]#carp# төхөөрөмжүүд нь зөвхөн зөв нууц үг бүхий машинуудаас ирэх зарлалтуудыг сонсох болно. VHID нь машин бүрийн хувьд өөр өөр байх ёстой.
====

Гурав дахь `provider.example.org` машиныг аль нэг хост руу хандахад амжилтгүй болоход хандаж болохоор болгож бэлдэх хэрэгтэй. Энэ машинд хоёр [.filename]#carp# төхөөрөмж хэрэгтэй болох бөгөөд нэг нэгээрээ хоёр хосттой ажиллах юм. [.filename]#rc.conf#-ийн зөв тохиргооны мөрүүд доор дурдсантай төсөөтэй байх болно:

[.programlisting]
....
hostname="provider.example.org"
ifconfig_fxp0="inet 192.168.1.5 netmask 255.255.255.0"
cloned_interfaces="carp0 carp1"
ifconfig_carp0="vhid 1 advskew 100 pass testpass 192.168.1.50/24"
ifconfig_carp1="vhid 2 advskew 100 pass testpass 192.168.1.51/24"
....

Хоёр [.filename]#carp# төхөөрөмжтэй байх нь хариу өгөхөө байсан аль нэг машиныг мэдэж IP хаягийг нь авах боломжийг `provider.example.org` хостод олгох болно.

[NOTE]
====
Анхдагч FreeBSD цөм дээр preemption буюу өөр илүү өндөр давуу эрх бүхий бодлого/урсгалаар солигдох боломж идэвхжсэн байж _болох_ юм. Хэрэв тийм бол `provider.example.org` нь IP хаягийг анхдагч агуулгын сервер рүү суллахгүй байж болох юм. Энэ тохиолдолд администратор мастер уруу буцааж IP-г хүчилж болох юм. Дараах тушаалыг `provider.example.org` дээр ажиллуулах шаардлагатай:

[source,bash]
....
# ifconfig carp0 down && ifconfig carp0 up
....

Хостод тохирох [.filename]#carp# интерфэйс дээр үүнийг хийх ёстой.
====

Энэ хүрэхэд CARP бүрмөсөн идэвхжиж тест хийхэд бэлэн болсон байх ёстой. Сүлжээг дахин эхлүүлэх буюу эсвэл машинуудыг дахин ачаалаад тест хийгээрэй.

Дэлгэрэнгүй мэдээллийг man:carp[4] гарын авлагын хуудаснаас олж болно.
