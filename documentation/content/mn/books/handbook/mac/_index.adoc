---
title: Бүлэг 17. Mandatory Access Control буюу Албадмал Хандалтын хяналт
part: хэсэг III. Системийн Удирдлага
prev: books/handbook/jails
next: books/handbook/audit
showBookMenu: true
weight: 21
path: "/books/handbook/mac/"
---

[[mac]]
= Mandatory Access Control буюу Албадмал Хандалтын хяналт
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 17
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/mac/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[mac-synopsis]]
== Ерөнхий агуулга

FreeBSD 5.X нь POSIX(R).1e ноорог дээр тулгуурласан TrustedBSD төслийн аюулгүй байдлын шинэ өргөтгөлүүдийг танилцуулсан. Хамгийн чухал аюулгүй байдлын шинэ арга замуудын хоёр нь файлын системийн Access Control Lists буюу Хандалтын Хяналтын Жагсаалтууд (ACL-үүд) болон Mandatory Access Control (MAC) буюу Албадмал Хандалтын Хяналт боломжууд юм. Албадмал Хандалтын Хяналт нь аюулгүй байдлын шинэ бодлогуудыг бий болгож хандалтын хяналтын модулиудыг ачаалах боломжийг олгодог. Зарим нь тухайн үйлчилгээг хатуужуулж системийн нарийн дэд олонлогуудын хамгаалалтуудыг хангадаг. Бусад нь хаяглагдсан, олон талын аюулгүй байдлыг бүх субьект болон обьектуудын хувьд хангадаг байна. Тодорхойлолтын албадмал буюу зайлшгүй шаардлагатай гэж хэлсэн хэсэг нь хяналтуудын албадлагыг администраторууд болон систем хийдэг бөгөөд discretionary access control (DAC, FreeBSD дээрх стандарт файл болон System V IPC зөвшөөрлүүд) буюу тусдаа байх хандалтын хяналтаар хийгддэг шиг хэрэглэгчээр өөрөөр нь хийлгэдэггүй гэсэн үг юм.

Энэ бүлэг Mandatory Access Control Framework (MAC Framework) буюу Албадмал Хандалтын Хяналт Тогтолцоо болон залгагдаж болох аюулгүй байдлын бодлогын модулиудын олонлогт анхаарлаа төвлөрүүлж төрөл бүрийн аюулгүй байдлын арга замуудыг идэвхжүүлэх болно.

Энэ бүлгийг уншсаны дараа, та дараах зүйлсийг мэдэх болно:

* Одоогоор FreeBSD-д ямар ямар аюулгүй байдлын MAC бодлогын модулиуд орсон болон тэдгээртэй холбоотой арга замуудын талаар.
* Аюулгүй байдлын MAC бодлогын модулиуд юу шийддэг болон хаяглагдсан болон хаяглагдаагүй бодлогын хоорондын ялгааны талаар.
* Системийг хэрхэн үр ашигтайгаар MAC тогтолцоог ашиглахаар тохируулах талаар.
* MAC тогтолцоонд орсон аюулгүй байдлын өөр өөр бодлогын модулиудыг хэрхэн тохируулах талаар.
* MAC тогтолцоо болон үзүүлсэн жишээнүүдийг ашиглан илүү аюулгүй орчинг хэрхэн бий болгох талаар.
* Тогтолцоо зөв хийгдсэнийг шалгахын тулд MAC тохиргоог хэрхэн тест хийх талаар.

Энэ бүлгийг уншихаасаа өмнө та дараах зүйлсийг гүйцэтгэх хэрэгтэй:

* UNIX(R) болон FreeBSD-ийн үндсүүдийг ойлгосон байх (crossref:basics[basics,Юниксийн үндэс]).
* Цөмийн тохиргоо/эмхэтгэлийн (crossref:kernelconfig[kernelconfig,FreeBSD цөмийг тохируулах нь]) үндсүүдтэй танилцсан байх.
* Аюулгүй байдалтай танилцаж энэ нь FreeBSD-д хэрхэн хамааралтай болохыг мэдэх (crossref:security[security,Аюулгүй байдал]).

[WARNING]
====

Энд байгаа мэдээллийг буруу ашиглавал системд хандаж чадахгүй болгох, хэрэглэгчдийн доройтол эсвэл X11-ийн хангадаг боломжуудад хандаж чадахгүйд хүргэж болох юм. Хамгийн чухал нь MAC нь системийг бүр мөсөн аюулгүй болгоно гэж найдаж болохгүй юм. MAC тогтолцоо нь байгаа аюулгүй байдлын бодлогыг зөвхөн сайжруулдаг; аюулгүй байдлын сайн практикгүй, байнгын аюулгүй байдлын шалгалтгүйгээр систем хэзээ ч бүрэн аюулгүй байж чадахгүй.

Мөн энэ бүлгийн хүрээнд байгаа жишээнүүд нь зөвхөн жишээнүүд гэдгийг тэмдэглэх ёстой юм. Ялангуяа эдгээр тухайлсан тохиргоонуудыг жинхэнэ систем дээр хэрэглэхийг зөвлөдөггүй. Төрөл бүрийн аюулгүй байдлын бодлогын модулиудыг бүтээх нь ихээхэн бодолт болон тест хийхийг шаарддаг. Бүгд хэрхэн яаж ажилладгийг бүрэн ойлгоогүй хүнийн хувьд бүхэл системийг дахин үзэж олон файлууд эсвэл сангуудыг дахин тохируулахад хүргэж болох юм.
====

=== Юуг хэлэлцэхгүй вэ

Энэ бүлэг нь MAC тогтолцоотой холбоотой өргөн хүрээний аюулгүй байдлын асуудлуудыг хамардаг. Шинэ MAC аюулгүй байдлын бодлогын модулиудыг хөгжүүлэх талаар хэлэлцэхгүй болно. MAC тогтолцоонд орсон хэд хэдэн аюулгүй байдлын бодлогын модулиуд нь тусгай онцлогуудтай бөгөөд эдгээр нь тест хийх болон шинэ модуль хөгжүүлэхэд зориулагдсан юм. Эдгээрт man:mac_test[4], man:mac_stub[4] болон man:mac_none[4] орно. Эдгээр аюулгүй байдлын бодлогын модулиудын талаар болон тэдгээрийн хангадаг төрөл бүрийн арга замуудын талаар дэлгэрэнгүй мэдээллийг гарын авлагын хуудаснуудаас лавлана уу.

[[mac-inline-glossary]]
== Энэ бүлэг дэх түлхүүр ухагдахуунууд

Энэ бүлгийг уншихаасаа өмнө хэд хэдэн түлхүүр ухагдахуунуудыг тайлбарлах ёстой. Энэ нь учирч болох ямар нэг эндүүрлийг цэгцэлж шинэ ухагдахуунууд болон мэдээллийн огцом танилцуулгаас зайлсхийх болно гэж найдаж байна.

* _compartment_ буюу тасалгаа: Тасалгаа нь хэрэглэгчдэд системийн тусгай бүрэлдэхүүн хэсгүүдэд хандах хандалтыг өгдөг хуваагдах эсвэл тусгаарлагдах програмууд болон өгөгдлийн олонлог юм. Мөн тасалгаа нь ажлын групп, хэлтэс, төсөл эсвэл сэдэв зэрэг бүлэглэлийг илэрхийлдэг. Тасалгаануудыг ашиглан мэдэх хэрэгтэй аюулгүй байдлын бодлогыг хийж гүйцэтгэх боломжтой байдаг.
* _high water mark_ буюу өндөр түвшин: Өндөр түвшин бодлого нь өндөр түвшний мэдээлэлд хандах зорилгоор аюулгүй байдлын түвшнүүдийг дээшлүүлэхийг зөвшөөрдөг бодлого юм. Ихэнх тохиолдолд процесс дууссаны дараа анхдагч түвшин сэргээгддэг. Одоогоор FreeBSD MAC тогтолцоо нь үүнд зориулсан бодлогогүй, гэхдээ бүрэн бүтэн байдлын үүднээс тодорхойлолт нь оржээ.
* _integrity_ буюу бүрэн бүтэн байдал: Бүрэн бүтэн байдал нь түлхүүр ойлголт бөгөөд өгөгдөлд тавигдаж болох итгэмжлэлийн түвшин юм. Өгөгдлийн бүрэн бүтэн байдал дээшлэх тусам тэр өгөгдөлд итгэх чадвар бас дээшилдэг.
* _label_ буюу хаяг/шошго: Хаяг/шошго нь файлууд, сангууд эсвэл систем дэх бусад зүйлсэд хамааруулж болох аюулгүй байдлын шинж чанар юм. Энэ нь итгэмжлэлийн тамга гэгдэж болно; хаяг/шошго файлд тавигдсан бол тэр файлын аюулгүй байдлын өмчүүдийг тайлбарлах бөгөөд зөвхөн ижил аюулгүй байдлын тохиргоотой файлууд, хэрэглэгчид, эх үүсвэрүүд гэх зэргээс хандалтыг зөвшөөрөх болно. Хаяг/шошгоны утгуудын утга санаа болон тайлбар нь бодлогын тохиргооноос хамаардаг: зарим бодлогууд нь хаяг/шошгыг обьектийн бүрэн бүтэн байдал эсвэл нууцгай байдал гэж ойлгодог бол бусад бодлогууд хаяг/шошгыг хандалт хийхийн тулд дүрмүүдийг агуулахад ашиглаж болох юм.
* _level_ буюу түвшин: Аюулгүй байдлын шинж чанарын ихэсгэсэн эсвэл багасгасан тохиргоо. Түвшин ихсэх тусам түүний аюулгүй байдал бас дээшилнэ гэж үздэг.
* _low water mark_ буюу доод түвшин: Доод түвшин нь тийм ч аюулгүй биш мэдээлэлд хандахын тулд аюулгүй байдлын түвшингүүдийг доошлуулахыг зөвшөөрдөг бодлого юм. Ихэнх тохиолдолд процесс дууссаны дараа хэрэглэгчийн анхдагч аюулгүй байдлын түвшин сэргээгддэг. FreeBSD-д үүнийг ашигладаг цорын ганц аюулгүй байдлын бодлогын модуль бол man:mac_lomac[4] юм.
* _multilabel_ буюу олон хаяг/шошго: `multilabel` өмч нь ганц хэрэглэгчийн горимд man:tunefs[8] хэрэгсэл, ачаалалтын үйлдлүүдийн үед эсвэл шинэ файлын систем үүсгэх үед man:fstab[5] файл ашиглан тохируулж болох файлын системийн тохируулга юм. Энэ тохируулга нь өөр өөр обьектуудад өөр өөр MAC хаяг/шошгонуудыг хамааруулахыг администраторт зөвшөөрөх болно. Энэ тохируулга нь хаяглалтыг дэмждэг аюулгүй байдлын бодлогын модулиудад зөвхөн хамаардаг.
* _object_ буюу обьект: Обьект буюу системийн обьект нь _subject_ буюу субьектийн удирдлагын доор мэдээлэл дамжин урсдаг тэр мөн чанар юм. Үүнд сангууд, файлууд, талбарууд, дэлгэцүүд, гарууд, санах ой, соронзон хадгалалт, хэвлэгчид эсвэл бусад дурын хадгалалт/хөдлөх төхөөрөмж ордог. Үндсэндээ обьект нь өгөгдлийн чингэлэг эсвэл системийн эх үүсвэр юм; _обьект_од хандах нь өгөгдөлд хандана гэсэн үг юм.
* _policy_ буюу бодлого: Зорилгод хэрхэн хүрэхийг тодорхойлох дүрмүүдийн цуглуулга юм. _Бодлого_ нь ихэвчлэн зарим нэг зүйлүүдтэй хэрхэн ажиллахыг баримтжуулдаг. Энэ бүлэг нь сэдэв дахь _бодлого_ гэсэн энэ нэр томъёог _аюулгүй байдлын бодлого_ гэж үзэх болно; өөрөөр хэлбэл өгөгдөл болон мэдээллийн урсгалыг хянах дүрмүүдийн цуглуулга гэж үзэх бөгөөд тэр өгөгдөл болон мэдээлэлд хэн хандалттай байхыг тодорхойлох болно.
* _sensitivity_ буюу мэдрэмтгий байдал: MLS-ийг хэлэлцэж байх үед ихэвчлэн хэрэглэдэг. Мэдрэмтгий байдлын түвшин нь өгөгдөл ямар чухал эсвэл нууцлаг байх ёстой болохыг тайлбарлахад хэрэглэгддэг нэр томъёо юм. Мэдрэмтгий байдлын түвшин ихсэх тусам нууцгай байдлын чухал ач холбогдол эсвэл өгөгдлийн итгэмжлэгдсэн байдал бас ихэсдэг.
* _single label_ буюу ганц хаяг/шошго: Ганц хаяг/шошго нь өгөгдлийн урсгалд хандалтын хяналт хийхийн тулд бүхэл файлын систем ганц хаяг/шошгыг хэрэглэх үе юм. `multilabel` тохируулгыг тохируулаагүй ямар ч үед файлын систем үүнийг тохируулсан байхад бүх файлууд нь ижил хаяг/шошгоны тохиргоог дагах болно.
* _subject_ буюу субьект: субьект нь хэрэглэгч, хэрэглэгчийн процессор, системийн процесс гэх мэт _обьектууд_ийн хооронд мэдээллийг урсгах идэвхтэй мөн чанар юм. FreeBSD дээр энэ нь бараг үргэлж хэрэглэгчийн өмнөөс процессод үйлчилж байгаа thread буюу урсгал байдаг.

[[mac-initial]]
== MAC-ийн тайлбар

Энэ бүх шинэ ухагдахуунуудыг санаад MAC тогтолцоо хэрхэн системийн аюулгүй байдлыг ерөнхийд нь нэмэгдүүлдэгийг эргэцүүлье. MAC тогтолцооны хангадаг төрөл бүрийн аюулгүй байдлын модулиуд нь сүлжээ болон файлын системүүдийг хамгаалах, зарим портууд болон сокетуудад хэрэглэгчид хандахыг хаах гэх зэрэгт ашиглагдаж болно. Магадгүй бодлогын модулиудыг ашиглах хамгийн шилдэг арга нь хэд хэдэн аюулгүй байдлын бодлогын модулиудыг нэг зэрэг олон давхаргажсан аюулгүй байдлын орчны хувьд дуудаж тэдгээрийг холих явдал байж болох юм. Олон давхаргажсан аюулгүй байдлын орчинд олон бодлогын модулиуд нь аюулгүй байдлыг шалгаж ажиллаж байдаг. Энэ нь зөвхөн тусгай зориулалтаар ашиглаж байгаа системийн элементүүдийг ихэвчлэн хатуужуулдаг чангатгах бодлогоос өөр юм. Цорын ганц сул тал нь олон файлын системийн хаяг/шошгонууд, сүлжээний хандалтын хяналтыг хэрэглэгч бүр дээр тохируулах гэх мэт тохиолдлуудад удирдлагын хувьд илүү ажилтай байдаг явдал юм.

Сул талууд нь тогтолцооны үйлчлэх нөлөөлөлтэй харьцуулахад бага зүйл юм. Жишээ нь тусгайлсан тохиргоонд ямар бодлогууд шаардлагатайг шилж сонгох чадвар нь ажиллагааны хувьд илүү ачааллыг багасгадаг. Хэрэгцээгүй бодлогуудын дэмжлэгийг багасгах нь системийн нийт ажиллагааг нэмэгдүүлэхээс гадна сонголтын уян хатан байдлыг санал болгодог. Сайн шийдэл нь аюулгүй байдлын ерөнхий шаардлагуудыг бодолцож энэ тогтолцооны санал болгодог төрөл бүрийн аюулгүй байдлын модулиудыг үр ашигтайгаар авч хэрэгжүүлдэг.

Тиймээс MAC боломжуудыг ашигладаг систем нь хэрэглэгчийн хүссэнээрээ аюулгүй байдлын шинж чанаруудыг өөрчлөх боломжийг хамгийн багаар бодоход зөвшөөрөхгүй байж баталгаажуулах ёстой юм. Хэрэглэгчийн бүх хэрэгслүүд, програмууд болон скриптүүд нь сонгосон аюулгүй байдлын бодлогын модулиудын хандалтын дүрмүүдийн шахалтын доор ажиллах ёстой бөгөөд MAC хандалтын дүрмүүдийн ерөнхий хяналт нь системийн администраторын гарт байдаг байна.

Аюулгүй байдлын бодлогын модулиудыг анхааралтай сонгох нь системийн администраторын цорын ганц үүрэг байдаг. Зарим орчнуудын хувьд сүлжээнд хандалтын хяналтыг хязгаарлах хэрэгтэй байдаг. Ийм тохиолдлуудад man:mac_portacl[4], man:mac_ifoff[4] болон бүр man:mac_biba[4] бодлогын модулиуд зөв эхлэл болж болох юм. Бусад тохиолдлуудад файлын системийн обьектуудын чанд нууцлал/итгэмжлэлийг шаардаж болох юм. Энэ зорилгоор man:mac_bsdextended[4] болон man:mac_mls[4] зэрэг бодлогын модулиуд байдаг.

Сүлжээний тохиргоон дээр үндэслэн бодлогын шийдвэрүүдийг хийдэг. Магадгүй сүлжээ эсвэл Интернэтэд хандахын тулд man:ssh[1]-ийн хангадаг боломжуудад зөвхөн зарим нэг хэрэглэгчдийг хандахыг зөвшөөрөх ёстой байж болох юм. Эдгээр тохиолдлуудад man:mac_portacl[4] нь сонгох бодлогын модуль болох юм. Гэхдээ файлын системүүдийн хувьд юу хийх ёстой вэ? Зарим нэг сангуудад бусад бүлгүүдээс эсвэл тусгай хэрэглэгчдээс хандах бүх хандалтыг чангаруулах ёстой юу? Эсвэл тусгай файлууд уруу хийх хэрэглэгчийн эсвэл хэрэгслийн хандалтыг зарим обьектуудыг нууц гэж тохируулан бид хязгаарлах ёстой юу?

Файлын системийн тохиолдолд обьектуудад хандах хандалт нь зарим хэрэглэгчдийн хувьд итгэмжлэгдсэн/нууц, бусдуудын хувьд үгүй байж болох юм. Жишээ нь хөгжүүлэх том багийг хэд хэдэн хөгжүүлэгчдээс тогтох жижиг бүлгүүдэд хувааж болох юм. B төсөл дэх хөгжүүлэгчдийн бичсэн обьектуудад A төсөл дэх хөгжүүлэгчид хандах ёсгүй. Бас тэд C төсөл дэх хөгжүүлэгчдийн үүсгэсэн обьектуудад хандах хэрэгтэй байж болох юм. Ийм тохиолдол харин ч байж болох юм. MAC тогтолцооны өөр өөр аюулгүй байдлын бодлогын модулиудыг ашиглан хэрэглэгчдийг эдгээр бүлгүүдэд хувааж мэдээллийн алдагдлаас айлгүйгээр тохирох талбаруудад хандалтыг өгч болох юм.

Тиймээс аюулгүй байдлын бодлогын модуль бүр нь системийн ерөнхий аюулгүй байдлыг сайжруулах өвөрмөц аргатай байдаг. Модулийн сонголтыг хийхдээ аюулгүй байдлын бодлогын хувьд сайн бодож хийх хэрэгтэй. Ихэнх тохиолдлуудад ерөнхий бодлогыг дахин харж сайжруулан систем дээр дахин хэрэгжүүлэх хэрэгтэй байж болох юм. MAC тогтолцооны санал болгодог өөр өөр аюулгүй байдлын бодлогын модулиудыг ойлгох нь администраторуудад өөр өөрсдийн нөхцөлдөө тохируулан хамгийн шилдэг бодлогуудыг сонгоход туслах болно.

FreeBSD-ийн анхдагч цөм нь MAC тогтолцоонд зориулсан тохируулгагүй байдаг, тиймээс энэ бүлэгт байгаа жишээнүүд эсвэл мэдээллийг туршихаасаа өмнө дараах цөмийн тохируулгыг нэмэх ёстой:

[.programlisting]
....
options	MAC
....

Тэгээд цөмийг дахин бүтээж суулгах шаардлагатай болно.

[CAUTION]
====

MAC бодлогын модулиудын төрөл бүрийн гарын авлагын хуудаснууд нь тэдгээрийг цөмд оруулан бүтээсэн гэж мэдэгддэг боловч системийг сүлжээнээс гаргаж түгжих зэрэг олон боломжтой байдаг. MAC-ийг хэрэгжүүлэх нь галт ханыг хэрэгжүүлэхтэй бараг адил бөгөөд системээс бүр мөсөн гарч түгжигдэхээс сэргийлэхийн тулд анхааралтай байх ёстой. Өмнөх тохиргоондоо эргэж буцааж болдог байх чадварыг бодолцох ёстой бөгөөд MAC шийдлийг алсаас хийхдээ маш болгоомжтой хийх хэрэгтэй юм.
====

[[mac-understandlabel]]
== MAC хаяг/шошгонуудыг ойлгох нь

MAC хаяг/шошго нь системийн турш нэлэнхүйд нь субьектууд болон обьектуудад өгч болох аюулгүй байдлын шинж чанар юм.

Хаяг/шошгыг тохируулах үед хэрэглэгч үүнийг яг юу болох, юу хийгдэхийг ойлгож чадаж байх ёстой. Обьект дээр байдаг шинж чанарууд нь бодлогын модуль дуудагдсан болон бодлогын модулиуд тэдгээрийн шинж чанаруудыг өөр аргаар ойлгуулдгаас хамаарна. Дутуу ойлгосноос эсвэл утга санаануудыг нь ойлгох чадваргүй байдлаас болоод буруу тохируулсан бол үр дүн нь тааж болшгүй байх бөгөөд магадгүй системийн хүсээгүй ажиллагаанд хүргэж болох юм.

Обьект дээрх аюулгүй байдлын хаяг/шошго нь бодлогын гаргах аюулгүй байдлын хандалтын хяналтын шийдвэрийн хэсэг болон хэрэглэгддэг. Зарим бодлогуудад хаяг/шошго нь өөрөө шийдвэр гаргахад шаардлагатай бүх мэдээллийг агуулдаг; бусад загваруудад хаяг/шошгонууд нь илүү том дүрмийн олонлогийн хэсэг болон процесс хийгдэж болох юм. Гэх мэт олныг дурдаж болно.

Жишээ нь файл дээр `biba/low` гэж хаяг/шошгыг тохируулах нь Biba аюулгүй байдлын бодлогын модулиар хангагдаж байдаг хаяг/шошгыг "low" гэсэн утгатайгаар илэрхийлж байна гэсэн үг юм.

FreeBSD-д хаяглалтын боломжийг дэмждэг цөөн бодлогын модулиуд нь урьдчилан тодорхойлсон тусгай гурван хаяг/шошгыг санал болгодог. Эдгээр нь low буюу доод, high буюу өндөр болон equal буюу тэнцүү гэсэн хаяг/шошгууд юм. Тэдгээр нь хандалтын хяналтыг бодлогын модуль бүртэй өөр өөрөөр хийдэг боловч low хаяг/шошго нь хамгийн доод тохиргоо болох ба equal хаяг/шошго нь субьект эсвэл обьектийг хаах эсвэл хамаарахгүй гэж тохируулах бөгөөд high хаяг/шошго нь Biba болон MLS бодлогын модулиудад байх хамгийн дээд тохиргоог хийх болно.

Ганц хаяг/шошго бүхий файлын системийн орчинд обьектууд дээр зөвхөн нэг хаяг/шошго хэрэглэгдэх болно. Энэ нь хандалтын зөвшөөрлүүдийн нэг олонлогийг бүхэл бүтэн системийн дагуу ашиглах бөгөөд олон орчны хувьд энэ нь хангалттай байж болох юм. Файлын систем дэх обьектууд эсвэл субьектууд дээр олон хаяг/шошгонууд тавих цөөн тохиолдлууд байдаг. Ийм тохиолдолд `multilabel` тохируулгыг man:tunefs[8] уруу дамжуулж өгч болох юм.

Biba болон MLS-ийн хувьд тоон хаяг/шошгыг шаталсан хяналтын тодорхой түвшинг заахын тулд тохируулж болно. Энэ тоон түвшин нь мэдээллийг ангиллын өөр өөр бүлгүүдэд хуваах буюу эрэмбэлж тэр бүлэг эсвэл илүү өндөр бүлгийн түвшинд хандах хандалтыг зөвхөн зөвшөөрөхөд хэрэглэгддэг.

Ихэнх тохиолдлуудад администратор нь файлын системийн дагуу хэрэглэхийн тулд зөвхөн ганц хаяг/шошгыг тохируулдаг.

_Хөөе хүлээгээрэй, энэ нь DAC-тай адил юм байна! MAC нь хяналтыг зөвхөн администраторт өгдөг гэж бодсон._ Энэ өгүүлбэр нь зарим талаараа үнэн хэвээр байгаа, учир нь `root` хэрэглэгчид хяналт байгаа бөгөөд тэрээр хэрэглэгчдийг тохирох зэрэглэл/хандалтын түвшингүүдэд байрлуулахаар бодлогуудыг тохируулдаг. Харамсалтай нь бодлогын олон модулиуд нь `root` хэрэглэгчийг бас хязгаарлаж чадна. Обьектууд дээрх үндсэн хяналт нь тэгээд бүлэгт суллагдах боловч `root` нь тохиргоонуудыг ямар ч үед буцааж эсвэл өөрчилж болох юм. Энэ нь Biba болон MLS зэрэг бодлогуудын хамардаг шаталсан/цэвэрлэгээ загвар юм.

=== Хаяг/шошгоны тохиргоо

Хаяг/шошгоны бодлогын модулийн тохиргооны бараг л бүх зүйлсийг үндсэн системийн хэрэгслүүдийг ашиглан гүйцэтгэдэг. Эдгээр тушаалууд нь обьект эсвэл субьектийн тохиргоо эсвэл тохиргооны удирдлага болон шалгалтын хувьд энгийн интерфэйсээр хангадаг.

Бүх тохиргоог man:setfmac[8] болон man:setpmac[8] хэрэгслүүдийг ашиглан хийнэ. `setfmac` тушаал нь системийн обьектууд дээр MAC хаяг/шошгонуудыг тохируулахад хэрэглэгддэг бол `setpmac` тушаал нь системийн субьектууд дээр хаяг/шошгонуудыг тохируулахад хэрэглэгддэг. Дараах тушаалыг ажиглаарай:

[source,shell]
....
# setfmac biba/high test
....

Дээрх тушаалыг ажиллуулсны дараа хэрэв ямар ч алдаа гараагүй бол хүлээх мөр буцаагдах болно. Эдгээр тушаалууд нь хөдөлгөөнгүй биш байх цорын ганц үе нь алдаа гарах үе юм; man:chmod[1] болон man:chown[8] тушаалуудтай адил юм. Зарим тохиолдолд энэ алдаа нь `Permission denied` гэсэн байж болох бөгөөд энэ нь ихэвчлэн хязгаарласан обьект дээр хаяг/шошгыг тохируулах буюу засах үед гардаг. Системийн администратор үүнийг давж гарахын тулд дараах тушаалуудыг ашиглаж болно:

[source,shell]
....
# setfmac biba/high test
Permission denied
# setpmac biba/low setfmac biba/high test
# getfmac test
test: biba/high
....

Дээрхээс харахад ажиллуулсан процессод өөр хаяг/шошго зааж бодлогын модулийн тохиргоонуудыг өөрчлөхөд `setpmac` тушаалыг хэрэглэж болох юм байна. `getpmac` хэрэгсэл нь ихэвчлэн тухайн үед ажиллаж байгаа sendmail зэрэг процессуудад хэрэглэгддэг. Хэдийгээр энэ нь тушаалын оронд процессийн ID-г авдаг боловч логик нь туйлын төстэй юм. Хэрэв хэрэглэгчид өөрийн хандалтад байхгүй файлыг удирдахыг оролдвол дуудагдсан бодлогын модулиудын дүрмүүдээс болоод `Operation not permitted` алдаа `mac_set_link` функцээр харуулагдах болно.

==== Нийтлэг хаяг/шошгоны төрлүүд

man:mac_biba[4], man:mac_mls[4] болон man:mac_lomac[4] бодлогын модулиудын хувьд энгийн хаяг/шошгонуудыг зааж өгөх боломж олгогдсон байдаг. Эдгээр нь high буюу өндөр/дээд, equal буюу тэнцүү болон low буюу доод гэсэн хэлбэрийг авах бөгөөд эдгээр хаяг/шошгонуудын юу хангадаг талаар товч тайлбарыг доор дурдав:

* `low` хаяг/шошго нь обьект эсвэл субьектийн авч болох хамгийн доод хаяг/шошгоны тохиргоо гэгддэг. Үүнийг обьектууд эсвэл субьектууд дээр тохируулах нь өндөр гэж тэмдэглэгдсэн обьектууд эсвэл субьектууд уруу хандах тэдгээрийн хандалтыг хаах болно.
* `equal` хаяг/шошго нь бодлогоос чөлөөлөгдөх обьектууд дээр зөвхөн тавигдах ёстой.
* `high` хаяг/шошго нь обьект эсвэл субьектэд хамгийн их боломжит тохиргоог зөвшөөрдөг.

Бодлогын модуль бүрийн хувьд тэдгээр тохиргоо бүр өөр өөр мэдээллийн урсгалын зааврыг хийх болно. Тохирох гарын авлагын хуудаснуудыг унших нь эдгээр ерөнхий хаяг/шошгоны тохиргоонуудын төрх байдлыг цаашид тайлбарлах болно.

===== Хаяг/шошгоны илүү нарийн тохиргоо

Тоон зэргээр илэрхийлсэн хаяг/шошгонууд нь `comparison:compartment+compartment` буюу `харьцуулалт:тасалгаа+тасалгаа` гэсэнд зориулагдаж хэрэглэгддэг, тиймээс дараах нь:

[.programlisting]
....
biba/10:2+3+6(5:2+3-20:2+3+4+5+6)
....

Ингэж тайлбарлагдаж болно:

"Biba Бодлогын Хаяг/Шошго"/"Зэрэг 10" :"Тасалгаанууд 2, 3 болон 6": ("зэрэг 5 ...")

Энэ жишээн дээр эхний зэрэг нь "эффектив тасалгаанууд"тай "эффектив зэрэг" гэж тооцогддог, хоёр дахь зэрэг нь доод зэрэг бөгөөд хамгийн сүүлийнх нь өндөр зэрэг юм. Ихэнх тохиргоонуудад эдгээр тохируулгуудыг ашигладаггүй, харин тэдгээрийг илүү нарийн тохиргоонд зориулж санал болгодог.

Системийн обьектуудад хамааруулахад тэдгээр нь системийн субьектуудтай харьцуулах юм бол зөвхөн тухайн үеийн зэрэг/тасалгаануудтай байдаг. Системийн субьектууд нь систем болон сүлжээний интерфэйсүүдэд байгаа эрхүүдийн хүрээг тусгадаг. Сүлжээний интерфэйсүүд дээр хандалтын хяналтын хувьд хаяг/шошгонууд нь ашиглагддаг.

Субьект болон обьект хослол дахь зэрэг болон тасалгаанууд нь "давамгайлал" гэгддэг харилцааг бүтээхэд хэрэглэгддэг. Энэ харилцаанд субьект нь обьектийг давамгайлдаг, эсвэл обьект нь субьектийг давамгайлдаг, эсвэл аль нэг нь нөгөөгөө давамгайлахгүй, эсвэл хоёулаа нэг нэгнийгээ давамгайлдаг. "хоёулаа давамгайлах" тохиолдол нь хоёр хаяг/шошго тэнцүү байхад тохиолддог. Biba-ийн мэдээллийн урсгалын мөн чанараас болоод төсөлд тохирох "мэдэх хэрэгтэй" тасалгаануудын олонлогийн эрхүүд танд байдаг. Гэхдээ обьектууд нь бас тасалгаануудын олонлогтой байна. Хэрэглэгчид нь өөрсдөө хязгаарлалтгүй байдаг тасалгаа дахь обьектуудад хандахын тулд `su` эсвэл `setpmac` тушаалуудыг ашиглан өөрсдийнхөө эрхүүдийг дэд эрхүүд болгож болох юм.

==== Хэрэглэгчид болон хаяг/шошгоны тохиргоонууд

Хэрэглэгчдийн өөрсдийнх нь файлууд болон процессууд систем дээр тодорхойлсон аюулгүй байдлын бодлоготой зөв харилцан ажилладаг байхын тулд хэрэглэгчид нь өөрсдөө хаяг/шошгонуудтай байх шаардлагатай байдаг. Үүнийг [.filename]#login.conf# файлд нэвтрэлтийн ангиллуудыг ашиглан тохируулдаг. Хаяг/шошгонуудыг ашигладаг бодлогын модуль бүр хэрэглэгчийн ангиллын тохиргоог хийх болно.

Бодлогын модуль бүрийн тохиргоог агуулах жишээ оруулгыг доор үзүүлэв:

[.programlisting]
....
default:\
	:copyright=/etc/COPYRIGHT:\
	:welcome=/etc/motd:\
	:setenv=MAIL=/var/mail/$,BLOCKSIZE=K:\
	:path=~/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin:\
	:manpath=/usr/shared/man /usr/local/man:\
	:nologin=/usr/sbin/nologin:\
	:cputime=1h30m:\
	:datasize=8M:\
	:vmemoryuse=100M:\
	:stacksize=2M:\
	:memorylocked=4M:\
	:memoryuse=8M:\
	:filesize=8M:\
	:coredumpsize=8M:\
	:openfiles=24:\
	:maxproc=32:\
	:priority=0:\
	:requirehome:\
	:passwordtime=91d:\
	:umask=022:\
	:ignoretime@:\
	:label=partition/13,mls/5,biba/10(5-15),lomac/10[2]:
....

`label` тохируулга нь хэрэглэгчийн ангиллын MAC-ийн үйлчлэх анхдагч хаяг/шошгыг тохируулахад хэрэглэгддэг. Хэрэглэгчид энэ утгыг өөрчлөх зөвшөөрөл хэзээ ч өгөгдөхгүй учраас энэ нь хэрэглэгчийн хувьд сонгох боломжгүй юм. Гэхдээ жинхэнэ тохиргоон дээр администратор нь бодлогын модуль бүрийг идэвхжүүлэхийг хэзээ ч хүсэхгүй. Энэ тохиргоонуудаас аль нэгийг нь хийж гүйцэтгэхээсээ өмнө энэ бүлгийн үлдсэнийг дахин шалгаж уншихыг зөвлөж байна.

[NOTE]
====
Хэрэглэгчид нь эхний нэвтрэлтийнхээ дараа өөрсдийн хаяг/шошгыг өөрчилж болох юм. Гэхдээ энэ өөрчлөлт нь бодлогын шахалтуудын эрхшээлд байдаг. Дээрх жишээ нь процессийн хамгийн бага бүрэн бүтэн байдлыг 5, түүний хамгийн их утга нь 15, гэхдээ анхдагч эффектив хаяг/шошго нь 10 гэж Biba бодлогод хэлж байна. Процесс нь магадгүй хэрэглэгч setpmac тушаалыг ажиллуулснаас болоод хаяг/шошгоо өөрчлөхөөр сонгох хүртэл 10 дээр ажиллах болно. setpmac тушаал нь нэвтрэлтийн үед хүрээг тохируулах Biba-ийн шахалтад байх болно.
====

Бүх тохиолдлуудад [.filename]#login.conf#-д өөрчлөлт хийсний дараа нэвтрэлтийн ангиллын боломжийн мэдээллийн баазыг `cap_mkdb` тушаал ашиглан дахин бүтээх ёстой бөгөөд энэ нь ойртож байгаа жишээ эсвэл хэлэлцүүлэг бүрт тусгагдах болно.

Олон сайтууд нь хэд хэдэн өөр өөр хэрэглэгчийн ангиллуудыг шаарддаг ялангуяа асар их тооны хэрэглэгчидтэй байж болохыг тэмдэглэх хэрэгтэй юм. Маш сайн төлөвлөх хэрэгтэй бөгөөд удирдахад туйлын хэцүү болж болох юм.

==== Сүлжээний интерфэйсүүд болон хаяг/шошгоны тохиргоонууд

Хаяг/шошгонууд нь сүлжээний дагуух өгөгдлийн урсгалыг хянахад туслах зорилгоор сүлжээний интерфэйсүүд дээр бас тавигдаж болно. Бүх тохиолдолд тэдгээр нь бодлогууд обьектуудад үйлчилдэг шигээр үйлчилдэг. `biba` дээрх өндөр тохиргоонуудтай хэрэглэгчдийг жишээ нь доод хаяг/шошготой сүлжээний интерфэйсүүдэд хандахыг зөвшөөрдөггүй.

Сүлжээний интерфэйсүүд дээр MAC хаяг/шошгыг тохируулахдаа `maclabel` тохируулгыг `ifconfig` тушаал уруу өгч болох юм. Жишээ нь:

[source,shell]
....
# ifconfig bge0 maclabel biba/equal
....

тушаал нь `biba/equal`-ийн MAC хаяг/шошгыг man:bge[4] интерфэйс дээр тохируулах болно. `biba/high(low-high)`-тай төстэй тохиргоог ашиглаж байх үед бүх хаяг/шошгыг тэр чигээр нь хаалтанд ("") хийх ёстой, тэгэхгүй бол алдаа буцаагдах болно.

Хаяглалтыг дэмждэг бодлогын модуль бүр тааруулах боломжтой хувьсагчтай байдаг бөгөөд тэдгээрийг сүлжээний интерфэйсүүд дээр MAC хаяг/шошгыг хаахдаа хэрэглэж болох юм. Хаяг/шошгыг `equal` буюу тэнцүү гэж тохируулах нь ижил нөлөөлөлтэй байх болно. Тэдгээр тааруулах боломжтой хувьсагчуудын хувьд `sysctl`-ийн тушаалын гаралт, бодлогын гарын авлагын хуудаснууд эсвэл бүр энэ бүлгийн үлдсэн хэсэг дэх мэдээллийг дахин үзээрэй.

=== Ганц хаяг/шошго уу эсвэл олон хаяг/шошго уу?

Анхдагчаар систем нь `singlelabel` тохируулгыг ашиглах болно. Гэхдээ энэ нь администраторт юу гэж ойлгогдох вэ? Хэд хэдэн ялгаанууд байдаг бөгөөд тэдгээр нь системийн аюулгүй байдлын загварт уян хатан чанарын хувьд давуу болон сул талуудыг үзүүлдэг.

`singlelabel` нь зөвхөн нэг хаяг/шошгоны хувьд зөвшөөрөх бөгөөд жишээлбэл `biba/high`-ийг субьект эсвэл обьект бүрийн хувьд ашиглах юм. Энэ нь удирдлагын хувьд бага ажиллагааг өгдөг боловч хаяглалтыг дэмждэг бодлогуудын уян хатан чанарыг бууруулдаг. Олон администраторууд өөрсдийн аюулгүй байдлын бодлогодоо `multilabel` тохируулгыг ашиглахыг хүсэж болох юм.

`multilabel` тохируулга нь субьект эсвэл обьект бүрийг хуваалтад зөвхөн нэг хаяг/шошгыг зөвшөөрөх стандарт `singlelabel` тохируулгын оронд өөрийн гэсэн тусдаа MAC хаягтай байхыг зөвшөөрөх болно. `multilabel` болон `single` хаяг/шошгоны тохируулгууд нь Biba, Lomac, MLS болон SEBSD зэрэг хаяглалтын боломжийг хийж гүйцэтгэдэг бодлогуудад зөвхөн шаардлагатай байдаг.

Ихэнх тохиолдолд `multilabel`-ийг тохируулах ерөөсөө хэрэггүй байж болох юм. Дараах тохиолдол болон аюулгүй байдлын загварыг авч үзье:

* MAC тогтолцоо болон төрөл бүрийн бодлогуудын холимгийг ашигладаг FreeBSD вэб сервер.
* Энэ машин нь зөвхөн нэг хаяг/шошго `biba/high`-ийг системийн бүх юмандаа шаарддаг. Энд ганц хаяг/шошго нь үргэлж нөлөөлөх болохоор файлын систем нь `multilabel` тохируулгыг шаардахгүй.
* Гэхдээ энэ машин нь вэб сервер болох бөгөөд бичих боломжоос хамгаалахын тулд вэб серверийг `biba/low`-д ажиллуулах ёстой. Biba бодлого болон энэ нь хэрхэн ажилладаг талаар сүүлд хэлэлцэх болно. Тэгэхээр хэрэв өмнөх тайлбар ойлгоход хэцүү байгаа бол зүгээр л цааш үргэлжлүүлэн уншаад буцаж эргэж ирээрэй. Сервер нь ажиллаж байх үеийн төлвийнхээ ихэнх үед `biba/low` тавигдсан тусдаа хуваалтыг ашиглаж болох юм. Энэ жишээн дээр нэлээн их зүйл байхгүй байгаа, жишээ нь өгөгдөл, тохиргоо болон хэрэглэгчийн тохиргоонууд дээр хязгаарлалтууд байхгүй; гэхдээ энэ нь зөвхөн дээр дурдсаныг батлах хурдхан жишээ юм.

Хэрэв хаягладаггүй бодлогуудын аль нэг ашиглагдах бол `multilabel` тохируулга хэзээ ч шаардагдахгүй. Эдгээрт `seeotheruids`, `portacl` болон `partition` бодлогууд ордог.

Хуваалтад `multilabel` тохируулгыг ашиглаж `multilabel`-ийн ажиллагаан дээр тулгуурласан аюулгүй байдлын загварыг байгуулах нь удирдлагын хувьд илүү ажиллагаанд хүргэж болох юм. Учир нь файлын систем дэх бүх зүйлс хаяг/шошготой болох юм. Эдгээр зүйлсэд сангууд, файлууд, болон бүр төхөөрөмжийн цэгүүд хүртэл орно.

Дараах тушаал нь файлын системүүд дээр олон хаяг/шошготой байхаар `multilabel`-ийг тохируулна. Үүнийг зөвхөн ганц хэрэглэгчийн горимд хийж болно:

[source,shell]
....
# tunefs -l enable /
....

Энэ нь swap файлын системийн хувьд шаардлагатай биш юм.

[NOTE]
====
Зарим хэрэглэгчид `multilabel` тугийг root хуваалт дээр тохируулахад асуудлуудтай тулгарсан байж болох юм. Хэрэв ийм тохиолдол бол энэ бүлгийн <<mac-troubleshoot>> хэсгийг дахин үзнэ үү.
====

[[mac-planning]]
== Аюулгүй байдлын тохиргоог төлөвлөх нь

Шинэ технологи хийгдэх болгонд төлөвлөлтийн үе шат үргэлж зөв зүйтэй санаа байдаг. Төлөвлөх шатуудын үеэр администратор ерөнхийд нь "том дүр зургийг" харах ёстой бөгөөд ядаж дараах зүйлүүдийг хараандаа байлгаж байх хэрэгтэй:

* Шийдлийн шаардлагууд;
* Шийдлийн зорилгууд;

MAC суулгацуудын хувьд эдгээрт дараах зүйлс орно:

* Системүүд дээр байгаа мэдээлэл болон эх үүсвэрүүдийг хэрхэн ангилах.
* Мэдээлэл ба эх үүсвэрүүдийн ямар төрлүүдэд хандахыг хийгдэх ёстой хязгаарлалтуудын төрлийн хамтаар хязгаарлах.
* Энэ зорилгод хүрэхийн тулд аль MAC модуль эсвэл модулиуд шаардлагатай болох.

Системийн эх үүсвэрүүд болон аюулгүй байдлын тохиргоонуудыг дахин тохируулж өөрчлөх боломж үргэлж байдаг бөгөөд системээс хайж файлууд болон хэрэглэгчийн бүртгэлүүдийг засах нь ихэвчлэн маш тохиромжгүй байдаг. Төлөвлөх нь ямар нэг асуудалгүй, үр ашигтай итгэгдсэн системийг бүтээхэд туслах юм. Тохиргоо бүхий итгэгдсэн системийн туршилт нь ихэвчлэн амин чухал байдаг бөгөөд MAC шийдлийг жинхэнэ ажиллах системүүд дээр ашиглахаас _өмнө_ лавтай ашигтай байдаг билээ. MAC бүхий систем дээр сул тохируулж орхих нь амжилтгүй байдлыг тохируулж байна гэсэн үг юм.

Өөр өөр орчнууд өөр тусгай хэрэгцээ болон шаардлагуудтай байж болох юм. Гүнзгий, бүрэн гүйцэд аюулгүй байдлын хувийн тохируулгыг үүсгэх нь систем ажиллагаанд орсны дараа өөрчлөлтүүдийн хэрэгцээг багасгах болно. Тиймээс дараа дараагийн хэсгүүд администраторуудад байдаг өөр өөр модулиудын талаар өгүүлэх бөгөөд тэдгээрийн хэрэглээ болон тохиргоог тайлбарлаж зарим тохиолдолд тэдгээр нь ямар нөхцөл байдлын үед хамгийн тохиромжтой байхыг харуулах болно. Жишээ нь вэб сервер нь man:mac_biba[4] болон man:mac_bsdextended[4] бодлогуудыг ашиглаж болох юм. Бусад тохиолдлуудад жишээ нь маш цөөн локал хэрэглэгчидтэй машины хувьд man:mac_partition[4] магадгүй зөв сонголт болж болох юм.

[[mac-modules]]
== Модулийн тохиргоо

MAC тогтолцоонд орсон модуль бүр дээр дурдсан шиг цөмд эмхэтгэгдэж эсвэл цөмийн ажиллах үеийн модуль хэлбэрээр дуудагдаж болно. Бидний зөвлөдөг арга бол модулийг эхний ачаалалтын үйлдлийн үеэр дуудагдахаар болгож модулийн нэрийг [.filename]#/boot/loader.conf# файлд нэмэх явдал юм.

Дараах хэсгүүд нь төрөл бүрийн MAC модулиудыг хэлэлцэж тэдгээрийн боломжуудыг тайлбарлах болно. Тэдгээрийг тусгай орчинд хийж гүйцэтгэхийг энэ бүлэг бас хамрах болно. Зарим модулиуд хаяглалтын хэрэглээг дэмждэг бөгөөд хаяглалт нь "энийг зөвшөөрсөн, харин энийг зөвшөөрөөгүй" гэх зэрэг хаяг/шошгыг хэрэгжүүлж хандалтыг хянадаг байна. Хаяг/шошгоны тохиргооны файл нь файлуудад хэрхэн хандаж болох, сүлжээний холболтыг хэрхэн солилцож болох гэх зэрэг олон асуудлуудыг хянадаг. Өмнөх хэсэг нь файл бүрийн эсвэл хуваалт бүрийн хандалтын хяналтыг идэвхжүүлэхийн тулд `multilabel` тугийг файлын системүүдэд хэрхэн тохируулах талаар үзүүлсэн.

Ганц хаяг/шошго бүхий тохиргоо нь системийн дагуу зөвхөн нэг хаяг/шошгыг хэрэглэх бөгөөд ийм учраас `tunefs`-ийн тохируулга `multilabel` гэж нэрлэгдсэн юм.

[[mac-seeotheruids]]
== MAC seeotheruids модуль

Модулийн нэр: [.filename]#mac_seeotheruids.ko#

Цамийн тохиргооны мөр: `options MAC_SEEOTHERUIDS`

Ачаалалтын тохируулга: `mac_seeotheruids_load="YES"`

man:mac_seeotheruids[4] модуль нь `sysctl`-ийн тааруулах боломжтой `security.bsd.see_other_uids` болон `security.bsd.see_other_gids` хувьсагчуудыг дуурайж өргөтгөдөг. Энэ тохируулга нь тохиргооноос өмнө ямар ч хаяг/шошгонуудыг тохируулахыг шаарддаггүй бөгөөд бусад модулиудтай хамааралгүйгээр ажиллаж чаддаг.

Модулийг дуудаж ачаалсны дараа боломжуудыг хянахын тулд дараах `sysctl`-ийн тааруулах боломжтой хувьсагчуудыг ашиглаж болно:

* `security.mac.seeotheruids.enabled` нь модулийн боломжуудыг идэвхжүүлж анхдагч тохируулгуудыг ашиглана. Эдгээр анхдагч тохируулгууд нь бусад хэрэглэгчдийн эзэмшиж байгаа процессууд болон сокетуудыг харах боломжийг хэрэглэгчдийн хувьд хаах болно.
* `security.mac.seeotheruids.specificgid_enabled` нь зарим нэг бүлгүүдийг энэ бодлогоос чөлөөлж тэдгээрийг зөвшөөрөх болно. Энэ бодлогоос зарим нэг бүлгүүдийг чөлөөлөхийн тулд `sysctl` тушаалын `security.mac.seeotheruids.specificgid=XXX` хувьсагчийг ашиглана. Дээрх жишээн дээрх _XXX_-ийг чөлөөлөх бүлгийн тоон ID-аар солих хэрэгтэй.
* `security.mac.seeotheruids.primarygroup_enabled` нь тусгай анхдагч бүлгүүдийг энэ бодлогоос чөлөөлөхийн тулд ашигладаг. Энэ хувьсагчийг хэрэглэхэд `security.mac.seeotheruids.specificgid_enabled` хувьсагч тохируулагдаагүй байж болно.

[[mac-bsdextended]]
== MAC bsdextended модуль

Модулийн нэр: [.filename]#mac_bsdextended.ko#

Цөмийн тохиргооны мөр: `options MAC_BSDEXTENDED`

Ачаалалтын тохируулга: `mac_bsdextended_load="YES"`

man:mac_bsdextended[4] модуль файлын системийн галт ханыг идэвхжүүлдэг. Энэ модулийн бодлого нь стандарт файлын системийн зөвшөөрлүүдийн загварын өргөтгөл болж файлын систем дэх файлууд, хэрэгслүүд болон сангуудыг хамгаалахын тулд администраторт галт ханатай адил дүрмийн олонлогийг үүсгэх боломжийг олгодог. Файлын системийн обьектод хандахыг оролдоход дүрмүүдийн жагсаалтаас тохирох дүрэм таарах хүртэл эсвэл төгсгөл хүртэл шалгадаг. Энэ ажиллагааг man:sysctl[8]-ийн хувьсагч security.mac.bsdextended.firstmatch_enabled параметрийг хэрэглэж өөрчилж болно. FreeBSD дэх бусад галт ханын модулиудтай адилаар хандалтын хяналтын дүрмүүдийг агуулах файлыг үүсгэж man:rc.conf[5]-ийн хувьсагчийн тусламжтайгаар ачаалах үед системээр уншуулж болно.

Дүрмийн жагсаалтыг man:ipfw[8]-ийн синтакстай төстэйгөөр бичигддэг man:ugidfw[8] хэрэгслийг ашиглан оруулж болно. Илүү хэрэгслүүдийг man:libugidfw[3] сан дахь функцуудыг ашиглан бичиж болно.

Энэ модультай ажиллаж байхдаа маш болгоомжтой байх хэрэгтэй; учир нь буруу хэрэглээ файлын системийн зарим хэсэгт хандах боломжгүй болгож болох юм.

=== Жишээнүүд

man:mac_bsdextended[4] модуль ачаалагдсаны дараа тухайн үед байгаа дүрмийн тохиргоог жагсаахад дараах тушаал ашиглагдаж болно:

[source,shell]
....
# ugidfw list
0 slots, 0 rules
....

Яг бодож байсны дагуу ямар ч дүрмүүд тодорхойлогдоогүй байна. Энэ нь бүгд хандах боломжтой байна гэсэн үг юм. `root`-ийг орхиж бусад хэрэглэгчдийн бүх хандалтыг хаах дүрмийг үүсгэхийн тулд ердөө л дараах тушаалыг ажиллуулна:

[source,shell]
....
# ugidfw add subject not uid root new object not uid root mode n
....

Энэ нь бүх хэрэглэгчдийг `ls` зэрэг хамгийн энгийн тушаалуудыг ажиллуулахыг хаах учраас маш буруу санаа юм. Илүү эх оронч дүрмүүдийн жагсаалт иймэрхүү байж болно:

[source,shell]
....
# ugidfw set 2 subject uid user1 object uid user2 mode n
# ugidfw set 3 subject uid user1 object gid user2 mode n
....

Энэ нь `user1` хэрэглэгчээс `_user2_`-ийн гэрийн сан уруу хандах сангийн жагсаалт үзүүлэх зэрэг дурын болон бүх хандалтыг хаах болно.

`user1`-ийн оронд `not uid _user2_` тохируулгыг дамжуулж болно. Энэ нь дээрхийн адил хандалтын хязгаарлалтуудыг зөвхөн нэг хэрэглэгчийн хувьд биш бүх хэрэглэгчийн хувьд тавих болно.

[NOTE]
====
`root` хэрэглэгчид эдгээр өөрчлөлтүүд нөлөөлөхгүй.
====

Энэ нь файлын системийг бэхэлж батжуулахад туслахын тулд man:mac_bsdextended[4] модулийг хэрхэн ашиглаж болох ерөнхий санааг харуулах ёстой. Илүү дэлгэрэнгүй мэдээллийг man:mac_bsdextended[4] болон man:ugidfw[8] гарын авлагын хуудаснуудаас үзнэ үү.

[[mac-ifoff]]
== MAC ifoff модуль

Модулийн нэр: [.filename]#mac_ifoff.ko#

Цөмийн тохиргооны мөр: `options MAC_IFOFF`

Ачаалалтын тохируулга: `mac_ifoff_load="YES"`

man:mac_ifoff[4] модуль нь сүлжээний интерфэйсүүдийг шууд идэвхгүй болгож системийн эхний ачаалалтын үеэр идэвхжүүлэхгүй байлгах зорилгоор байдаг. Энэ нь систем дээр ямар ч хаяг/шошгуудыг тохируулахыг шаарддаггүйгээс гадна бас бусад MAC модулиудаас хамааралгүй юм.

Хяналтын ихэнх нь доор дурдсан `sysctl`-ийн тааруулж болох хувьсагчуудаар хийгддэг.

* `security.mac.ifoff.lo_enabled` нь loopback (man:lo[4]) буюу буцах интерфэйс дээрх бүх урсгалыг нээнэ/хаана.
* `security.mac.ifoff.bpfrecv_enabled` нь Berkeley Packet Filter буюу Беркли Пакет шүүгч интерфэйс (man:bpf[4]) дээрх бүх урсгалыг нээнэ/хаана.
* `security.mac.ifoff.other_enabled` нь бусад бүх интерфэйсүүд дээр бүх урсгалыг нээнэ/хаана.

man:mac_ifoff[4]-ийн хамгийн нийтлэг хэрэглээний нэг бол ачаалах дарааллын үеэр сүлжээний урсгалыг зөвшөөрөх ёсгүй орчинд сүлжээг монитор хийх явдал юм. Өөр нэг санал болгох хэрэглээ бол хамгаалагдсан сангуудад шинэ эсвэл өөрчлөгдсөн файлуудыг олсон тохиолдолд сүлжээний урсгалыг автоматаар хаахын тулд package:security/aide[]-г ашигладаг скриптийг бичих байж болох юм.

[[mac-portacl]]
== MAC portacl модуль

Модулийн нэр: [.filename]#mac_portacl.ko#

Цөмийн тохиргооны мөр: `MAC_PORTACL`

Ачаалалтын тохируулга: `mac_portacl_load="YES"`

man:mac_portacl[4] модулийг төрөл бүрийн `sysctl` хувьсагчуудыг ашиглан локал TCP болон UDP портуудыг холбохыг хязгаарлахад хэрэглэдэг. Мөн чанартаа man:mac_portacl[4] нь заагдсан эрх бүхий портуудыг өөрөөр хэлбэл 1024-оос бага портуудыг холбох боломжийг `root` биш хэрэглэгчдэд зөвшөөрдөг.

Ачаалагдсаны дараа энэ модуль нь бүх сокетууд дээр MAC бодлогыг идэвхжүүлдэг. Дараах тааруулж болох хувьсагчууд байдаг:

* `security.mac.portacl.enabled` нь бодлогыг бүр мөсөн нээнэ/хаана.
* `security.mac.portacl.port_high` нь man:mac_portacl[4]-ийн хамгаалалтыг нь идэвхжүүлдэг хамгийн дээд портын дугаарыг тохируулдаг.
* `security.mac.portacl.suser_exempt` нь тэгээс ялгаатай утгаар тохируулагдсан үедээ `root` хэрэглэгчийг энэ бодлогоос чөлөөлнө.
* `security.mac.portacl.rules` нь яг mac_portacl бодлогыг заадаг; доорхоос харна уу.

`mac_portacl` бодлого нь `security.mac.portacl.rules` sysctl-д заагдсаны дагуу хэрэгцээнээсээ хамааран хэдэн ч дүрмүүдтэй байж болох `rule[,rule,...]` текст хэлбэрийн байдаг. Дүрэм бүр `idtype:id:protocol:port` гэсэн хэлбэрийн байдаг. [parameter]#idtype# параметр нь `uid` эсвэл `gid` байж болох бөгөөд [parameter]#id# параметрийг хэрэглэгчийн id эсвэл бүлгийн id гэж тайлбарладаг. [parameter]#protocol# параметр нь `tcp` эсвэл `udp` гэж заагдан дүрмийг TCP эсвэл UDP-ийн алинд хамаарахыг тодорхойлоход хэрэглэгддэг. Сүүлийн [parameter]#port# параметр нь заагдсан хэрэглэгч эсвэл бүлэгт холбохыг зөвшөөрөх портын дугаар юм.

[NOTE]
====
Дүрмийн олонлог нь цөмөөр шууд тайлбарлагддаг болохоор хэрэглэгчийн ID бүлгийн ID болон портын параметруудын хувьд зөвхөн тоон утгуудыг ашиглаж болно. Өөрөөр хэлбэл хэрэглэгч, бүлэг болон портын үйлчилгээний нэрсийг ашиглаж болохгүй.
====

Анхдагчаар UNIX(R) төст системүүд дээр 1024-өөс бага портуудыг зөвхөн эрх бүхий процессууд буюу өөрөөр хэлбэл `root`-ээр ажилладаг процессуудад ашиглахад/холбоход хэрэглэдэг. man:mac_portacl[4]-ийн хувьд эрхгүй процессуудыг 1024-өөс бага портуудад холбохыг зөвшөөрөхдөө энэ стандарт UNIX(R) хязгаарлалтыг хаасан байх ёстой. Үүнийг man:sysctl[8]-ийн `net.inet.ip.portrange.reservedlow` болон `net.inet.ip.portrange.reservedhigh` хувьсагчуудыг тэг болгон хийж болно.

Доор жишээнүүдийг үзнэ үү, эсвэл дэлгэрэнгүй мэдээллийг man:mac_portacl[4] гарын авлагын хуудаснаас лавлана уу.

=== Жишээнүүд

Дараах жишээнүүд нь дээрх хэлэлцүүлгийг арай илүү тайлбарлах болно:

[source,shell]
....
# sysctl security.mac.portacl.port_high=1023
# sysctl net.inet.ip.portrange.reservedlow=0 net.inet.ip.portrange.reservedhigh=0
....

Эхлээд бид man:mac_portacl[4]-ийг стандарт эрх бүхий портуудыг хамарч ердийн UNIX(R) холболтын хязгаарлалтуудыг хаахаар тохируулна.

[source,shell]
....
# sysctl security.mac.portacl.suser_exempt=1
....

`root` хэрэглэгчийг энэ бодлогоор хязгаарлахгүйн тулд `security.mac.portacl.suser_exempt`-г тэгээс ялгаатай утгаар тохируулна. man:mac_portacl[4] модуль нь одоо UNIX(R) төст системүүд анхдагч тохиргоотойгоор ажилладаг шигээр тохируулагдсан байна.

[source,shell]
....
# sysctl security.mac.portacl.rules=uid:80:tcp:80
....

UID 80 бүхий (ердийн тохиолдолд `www` хэрэглэгч) хэрэглэгчид 80 портыг холбохыг зөвшөөрнө. `root` эрхгүйгээр вэб сервер ажиллуулахыг `www` хэрэглэгчид зөвшөөрөхөд үүнийг ашиглаж болно.

[source,shell]
....
# sysctl security.mac.portacl.rules=uid:1001:tcp:110,uid:1001:tcp:995
....

UID 1001 бүхий хэрэглэгчид TCP 110 ("pop3") болон 995 ("pop3s") портуудыг холбохыг зөвшөөрнө. Энэ нь 110 болон 995 портуудаар холболтуудыг хүлээн авдаг сервер эхлүүлэхийг хэрэглэгчид зөвшөөрдөг.

[[mac-partition]]
== MAC хуваалтын модуль

Модулийн нэр: [.filename]#mac_partition.ko#

Цөмийн тохиргооны мөр: `options MAC_PARTITION`

Ачаалалтын тохируулга: `mac_partition_load="YES"`

man:mac_partition[4] бодлого нь процессуудыг тэдгээрийн MAC хаяг/шошго дээр үндэслэн тусгай "хуваалтуудад" оруулдаг. Үүнийг man:jail[8]-ийн тусгай нэг төрөл гэж бодох хэрэгтэй, гэхдээ энэ нь тийм ч зохистой харьцуулалт биш юм.

Ачаалах процессийн үеэр энэ бодлогыг дуудаж идэвхжүүлэхийн тулд man:loader.conf[5] файлд нэмэгдэх ёстой нэг модуль нь энэ юм.

Энэ бодлогын ихэнх тохиргоо нь доор тайлбарлагдах man:setpmac[8] хэрэгслээр хийгддэг. Энэ бодлогод зориулагдсан дараах `sysctl`-ийн хувьсагч байдаг:

* `security.mac.partition.enabled` нь MAC процессийн хуваалтуудыг хэрэглэхийг идэвхжүүлдэг.

Энэ бодлого идэвхтэй болоход хэрэглэгчдэд зөвхөн өөрийн процессуудыг болон нэг хуваалтад байгаа бусад хэрэглэгчдийн процессуудыг харахыг зөвшөөрөх бөгөөд гэхдээ энэ хуваалтын хүрээнээс гадна байгаа хэрэгслүүдтэй ажиллахыг зөвшөөрөхгүй байх болно. Жишээ нь дээрх `insecure` ангилалд байгаа хэрэглэгчийг `top` тушаал болон процесс үүсгэх ёстой бусад олон тушаалуудад хандахыг зөвшөөрөхгүй юм.

Хэрэгслүүдийг хуваалтын хаяг/шошго уруу оруулах буюу тохируулахын тулд `setpmac` хэрэгслийг хэрэглэнэ:

[source,shell]
....
# setpmac partition/13 top
....

Энэ нь `top` тушаалыг `insecure` ангилал дахь хэрэглэгчдийн хаяг/шошгоны олонлогт нэмэх болно. `insecure` ангиллын хэрэглэгчдийн үүсгэсэн бүх процессууд `partition/13` хаяг/шошгод байхыг тэмдэглэх нь зүйтэй юм.

=== Жишээнүүд

Дараах тушаал нь хуваалтын хаяг/шошго болон процессийн жагсаалтыг танд харуулах болно:

[source,shell]
....
# ps Zax
....

Дараагийн тушаал нь өөр хэрэглэгчийн процессийн хуваалтын хаяг/шошго болон тэр хэрэглэгчийн тухайн үед ажиллаж байгаа процессуудыг харахыг зөвшөөрөх болно:

[source,shell]
....
# ps -ZU trhodes
....

[NOTE]
====
man:mac_seeotheruids[4] бодлого дуудагдаж ачаалагдаагүй бол `root` хаяг/шошго дахь процессуудыг хэрэглэгч харж чадна.
====

Жинхэнэ ур дүй шаардсан шийдэл нь [.filename]#/etc/rc.conf# файл дахь бүх үйлчилгээнүүдийг хааж тэдгээрт зөв хаяглалтыг тохируулж тэдгээрийг скриптээр эхлүүлдэг байж болох юм.

[NOTE]
====
Дараах бодлогууд нь санал болгосон гурван анхдагч хаяг/шошгоны оронд бүхэл тоон тохируулгуудыг дэмждэг. Эдгээр тохируулгууд болон тэдгээрийн хязгаарлалтууд нь модулийн гарын авлагын хуудаснуудад дэлгэрэнгүй тайлбарлагдсан байгаа.
====

[[mac-mls]]
== MAC олон түвшинт аюулгүй байдлын модуль

Модулийн нэр: [.filename]#mac_mls.ko#

Цөмийн тохиргооны мөр: `options MAC_MLS`

Ачаалалтын тохируулга: `mac_mls_load="YES"`

man:mac_mls[4] бодлого нь систем дэх субьектууд болон обьектуудын хоорондын хандалтыг мэдээллийн урсгалын чанд бодлогын тусламжтайгаар хянаж хэрэгжүүлдэг.

MLS орчнуудад "clearance" буюу цэвэрлэгээ түвшин нь субьект болон обьектуудын хаяг/шошгонд тасалгаануудын цуг тохируулагддаг. Эдгээр цэвэрлэгээ буюу мэдрэхүйн түвшингүүд нь зургаан мянгаас их тоонд хүрч болох учир ямар ч администраторын хувьд субьект эсвэл обьект бүрийг нарийн тохируулах нь сүрдмээр ажил байдаг. Харин үүнийг хөнгөвчлөх гурван ширхэг "хормын" хаяг/шошго энэ бодлогод орсон байдаг.

Эдгээр хаяг/шошгонууд нь `mls/low`, `mls/equal` болон `mls/high` юм. Эдгээр хаяг/шошгонууд нь гарын авлагын хуудсанд дэлгэрэнгүй тайлбарлагдсан болохоор энд зөвхөн товчхон тайлбарлая:

* `mls/low` хаяг/шошго нь доод тохиргоог агуулдаг бөгөөд энэ нь түүнийг бусад бүх обьектуудаар захируулахыг зөвшөөрдөг. `mls/low`-ээр хаяглагдсан болгон доод цэвэрлэгээний түвшинтэй байх бөгөөд өндөр түвшний мэдээлэлд хандах нь зөвшөөрөгдөөгүй байх болно. Мөн энэ хаяг/шошго нь цэвэрлэгээний өндөр түвшингийн обьектуудад бичих эсвэл тэдгээрт мэдээлэл дамжуулахаас сэргийлдэг.
* `mls/equal` хаяг/шошго энэ бодлогоос чөлөөлөгдөхөөр болсон обьектуудад тавигдах ёстой.
* `mls/high` хаяг/шошго нь цэвэрлэгээний боломжит хамгийн өндөр түвшин юм. Энэ хаяг/шошгыг заасан обьектууд систем дэх бусад бүх обьектуудаас давуу эрхтэй байх бөгөөд гэхдээ тэдгээр нь доод ангиллын обьектуудад мэдээлэл алдагдахыг зөвшөөрөхгүй байх болно.

MLS дараах боломжуудыг олгодог:

* Шатлаагүй зэрэглэлүүдийн олонлогтой аюулгүй байдлын шаталсан түвшин;
* Тогтмол дүрмүүд: дээш уншихгүй, доош бичихгүй (субьект нь өөрөөсөө дээд түвшинд биш зөвхөн өөрийн түвшний болон доод түвшний обьектуудад унших хандалттай байж болно. Үүнтэй адилаар субьект нь өөрөөсөө доод түвшинд биш зөвхөн өөрийн түвшний болон дээд түвшний обьектуудад бичих хандалттай байж болно.);
* Нууцлаг байдал (өгөгдлийн зохисгүй ил болголтоос сэргийлэх);
* Мэдрэмжийн олон түвшингүүдэд өгөгдөлтэй зэрэгцээгээр ажиллах системүүдийн дизайны үндэс (нууц болон итгэмжлэгдсэн мэдээллийн хооронд мэдээлэл алдахгүйгээр).

Тусгай төхөөрөмжүүд болон интерфэйсүүдийн хувьд дараах `sysctl`-ийн тааруулах боломжтой хувьсагчууд байдаг:

* `security.mac.mls.enabled` нь MLS бодлогыг нээх/хаахад хэрэглэгддэг.
* `security.mac.mls.ptys_equal` нь бүх man:pty[4] төхөөрөмжүүдийг үүсгэлтийнх нь үеэр `mls/equal` гэж хаяглана.
* `security.mac.mls.revocation_enabled` нь обьектуудын хаяг/шошго доод зэргийнх уруу болж өөрчлөгдсөний дараа тэдгээрт хандах хандалтыг цуцлахад хэрэглэгддэг.
* `security.mac.mls.max_compartments` нь обьектуудад хамгийн их тооны тасалгааны түвшингүүдийг тохируулахад хэрэглэгддэг; үндсэндээ системд зөвшөөрөгдсөн тасалгааны хамгийн их дугаар байна.

MLS хаяг/шошгонуудтай ажиллахын тулд man:setfmac[8] байдаг. Обьектод хаяг/шошгыг олгохын тулд дараах тушаалыг ажиллуулна:

[source,shell]
....
# setfmac mls/5 test
....

[.filename]#test# файлын хувьд MLS хаяг/шошгыг авахын тулд дараах тушаалыг ажиллуулна:

[source,shell]
....
# getfmac test
....

Энэ нь MLS бодлогын боломжуудын товч дүгнэлт юм. Өөр нэг хандлага нь MLS бодлогын мэдээллийг тохируулах мастер бодлогын файлыг [.filename]#/etc# санд үүсгэж тэр файлыг `setfmac` тушаалд өгөх явдал юм. Энэ аргыг бүх бодлогуудыг авч үзсэнийхээ дараа тайлбарлах болно.

=== Албадмал Мэдрэмжийг төлөвлөх нь

Олон түвшинт аюулгүй байдлын бодлогын модулиар администратор эмзэг мэдээллийн урсгалыг хянахын тулд төлөвлөдөг. Анхдагчаар өөрийн блок дээш унших, блок доош бичих мөн чанараараа систем бүгдийг доод төлөвт болгодог. Бүгд хандах боломжтой байх бөгөөд администратор тохиргооны явцад аажмаар үүнийг мэдээллийн итгэмжлэгдсэн байдлыг нэмэгдүүлэн өөрчилдөг.

Дээрх гурван үндсэн хаяг/шошгоноос гадна администратор хэрэглэгчид болон бүлгүүдийг шаардлагын дагуу тэдгээрийн хооронд мэдээллийн урсгалыг хаахаар бүлэглэж болно. Цэвэрлэгээний түвшингүүдэд мэдээллийг танигдсан үгсээр хайх нь амар байж болох бөгөөд жишээ нь `Confidential`, `Secret`, болон `Top Secret` гэх зэрэг ангиллууд байж болох юм. Зарим администраторууд төслийн түвшингүүд дээр үндэслэн өөр бүлгүүдийг үүсгэж болох юм. Ангиллын аргаас үл хамааран ийм хязгаарласан бодлогыг хийхээс өмнө сайн бодож гаргасан төлөвлөгөө байж байх ёстой.

Энэ аюулгүй байдлын бодлогын модулийн хувьд зарим жишээ тохиолдлууд гэх юм бол e-commerce вэб сервер, компанийн чухал мэдээлэл болон санхүүгийн байгууллагын орчнуудыг агуулсан файл сервер байж болох юм. Хамгийн үнэмшилгүй газар бол зөвхөн хоёр, гуравхан хэрэглэгчтэй ажлын станц байх юм.

[[mac-biba]]
== MAC Biba модуль

Модулийн нэр: [.filename]#mac_biba.ko#

Цөмийн тохиргооны мөр: `options MAC_BIBA`

Ачаалалтын тохируулга: `mac_biba_load="YES"`

man:mac_biba[4] модуль MAC Biba бодлогыг дууддаг. Энэ бодлого нь MLS бодлоготой адил ажилладаг бөгөөд ялгаатай нь мэдээллийн урсгалын дүрмүүд нь нэлээн эсрэгээр байдаг. Энэ нь эмзэг мэдээллийн буурсан урсгалаас сэргийлдэг гэдэг бол MLS бодлого нь эмзэг мэдээллийн өгссөн урсгалаас сэргийлдэг; тиймээс энэ хэсгийн ихэнх нь хоёр бодлогод хоёуланд нь хамаатай юм.

Biba орчнуудад "integrity" буюу бүрэн бүтэн байдлын хаяг/шошго субьект эсвэл обьект бүр дээр тавигддаг. Эдгээр хаяг/шошгууд нь шаталсан зэргүүд болон шатлаагүй бүрэлдэхүүнүүдээс тогтдог. Обьект болон субьектийн зэрэг өсөх тусам бүрэн бүтэн байдал ч бас дээшилдэг.

Дэмжигдсэн хаяг/шошгууд нь `biba/low`, `biba/equal`, болон `biba/high` бөгөөд доор тайлбарлав:

* `biba/low` хаяг/шошго нь обьект эсвэл субьектийн авч болох хамгийн доод бүрэн бүтэн байдал гэж үздэг. Үүнийг обьектууд эсвэл субьектууд дээр тавих нь илүү өндрөөр тэмдэглэгдсэн обьектууд эсвэл субьектууд уруу хийх тэдгээрийн бичих хандалтыг хаана. Гэхдээ тэдгээрт унших хандалт байх болно.
* `biba/equal` хаяг/шошго нь бодлогоос чөлөөлөгдөх обьектууд дээр зөвхөн тавигдах ёстой.
* `biba/high` хаяг/шошго нь доод хаяг/шошго дээр тавигдсан обьектуудад бичихийг зөвшөөрөх боловч тэр обьектийг уншихыг зөвшөөрдөггүй. Бүхэл системийн бүрэн бүтэн байдалд нөлөөлдөг обьектуудад энэ хаяг/шошгыг тавихыг зөвлөдөг.

Biba дараах боломжуудыг олгодог:

* Шатлаагүй бүрэн бүтэн байдлын зэрэглэлүүдийн олонлог бүхий шаталсан бүрэн бүтэн байдлын түвшин;
* Тогтмол дүрмүүд: дээш бичихгүй, доош уншихгүй (MLS-ийн эсрэг). Субьект нь өөрөөсөө дээд түвшинд биш зөвхөн өөрийн түвшний болон доод түвшний обьектуудад бичих хандалттай байж болно. Үүнтэй адилаар субьект нь өөрөөсөө доод түвшинд биш зөвхөн өөрийн түвшний болон дээд түвшний обьектуудад унших хандалттай байж болно;
* Бүрэн бүтэн байдал (өгөгдлийн зохисгүй өөрчлөлтөөс сэргийлэх);
* Бүрэн бүтэн байдлын түвшингүүд (MLS-ийн мэдрэмжийн түвшингүүдийн оронд).

Дараах `sysctl`-ийн тааруулах боломжтой хувьсагчуудыг Biba бодлоготой ажиллахын тулд хэрэглэж болно.

* `security.mac.biba.enabled` нь машин дээр Biba бодлогыг нээхэд/хаахад хэрэглэгдэж болно.
* `security.mac.biba.ptys_equal` нь Biba бодлогыг man:pty[4] төхөөрөмжүүд дээр хаахад хэрэглэглэгдэж болно.
* `security.mac.biba.revocation_enabled` нь хаяг/шошго субьектийг захирахаар өөрчлөгдсөн бол обьектод хийх хандалтыг цуцлах болно.

Системийн обьектууд дахь Biba бодлогын тохиргоонд хандахын тулд `setfmac` болон `getfmac` тушаалуудыг ашиглана:

[source,shell]
....
# setfmac biba/low test
# getfmac test
test: biba/low
....

=== Албадмал бүрэн бүтэн байдлыг төлөвлөх нь

Бүрэн бүтэн байдал нь мэдрэмтгий байдлаас өөр бөгөөд мэдээллийг итгэгдээгүй талуудаар хэзээ ч удирдуулахгүй байлгаж баталгаажуулдаг. Үүнд субьектууд болон обьектууд, тэдгээрийн хооронд дамжих мэдээлэл ордог. Энэ нь хэрэглэгчдэд зөвхөн өөрчилж чадах боломж болон бүр зарим тохиолдолд тэдэнд хэрэгтэй мэдээлэлд хандах боломжийг олгодог.

man:mac_biba[4] аюулгүй байдлын бодлогын модуль нь аль файлууд болон програмуудыг хэрэглэгч эсвэл хэрэглэгчид харах ёстойг заахыг администраторт зөвшөөрч програмууд болон файлууд нь аюул заналаас ангид бөгөөд тэр хэрэглэгч, эсвэл хэрэглэгчдийн бүлгийн хувьд системээр итгэгдсэн гэдгийг баталгаажуулж дууддаг.

Эхний төлөвлөлтийн үеэр администратор зэргүүд, түвшингүүд болон бүсүүдэд хэрэглэгчдийг хуваахад бэлдэх ёстой. Хэрэглэгчдийн хувьд зөвхөн өгөгдлөөс гадна бас програмууд болон хэрэгслүүдэд тэдгээрийг эхлэхээс өмнө болон тэдгээрийг эхлүүлсний дараа тэдгээрт хандах хандалт хаагдсан байх болно. Энэ бодлогын модуль идэвхжүүлэгдсэний дараа систем өндөр хаяг/шошго уруу анхдагчаар шилжих бөгөөд хэрэглэгчдийн хувьд өөр зэргүүд болон түвшингүүдийг тохируулах нь администраторын хэрэг юм. Цэвэрлэгээний түвшингүүдийг дээр тайлбарласны дагуу ашиглахын оронд сайн төлөвлөх арга нь сэдвүүдийг оруулж болох юм. Жишээ нь эх кодын архив, эх код эмхэтгэгч болон бусад хөгжүүлэлтийн хэрэгслүүдэд өөрчлөх хандалтыг зөвхөн хөгжүүлэгчдэд зөвшөөрөх байж болно. Тэгээд бусад хэрэглэгчдийг тест хийгчид, дизайн хийгчид эсвэл зүгээр л энгийн хэрэглэгчид зэрэг өөр зэрэглэлд бүлэглэж зөвхөн унших хандалтыг зөвшөөрөх юм.

Цаанаасаа хийгдсэн аюулгүй байдлын хяналтаас болоод доод түвшний бүрэн бүтэн байдлын субьект нь дээд түвшний бүрэн бүтэн байдлын субьект уруу бичиж чаддаггүй; дээд түвшний бүрэн бүтэн байдлын субьект нь доод түвшний бүрэн бүтэн байдлын обьектийг ажиглаж эсвэл уншиж чаддаггүй. Хамгийн доод боломжит зэрэгт хаяг/шошгыг тохируулах нь субьектуудыг түүнд хандах боломжгүй болгож болох юм. Энэ аюулгүй байдлын бодлогын модулийн зарим хэтийн орчнуудад хүчилсэн вэб сервэр, хөгжүүлэлтийн болон тестийн машин, болон эх кодын архив зэрэг орж болох юм. Тийм ч ашигтай бус шийдэлд персонал ажлын станц, чиглүүлэгч маягаар ашиглагдаж байгаа машин эсвэл сүлжээний галт хана зэрэг байж болох юм.

[[mac-lomac]]
== MAC LOMAC модуль

Модулийн нэр: [.filename]#mac_lomac.ko#

Цөмийн тохиргооны файл: `options MAC_LOMAC`

Ачаалалтын тохируулга: `mac_lomac_load="YES"`

MAC Biba бодлогоос ондоо нь man:mac_lomac[4] бодлого нь бүрэн бүтэн байдлын дүрмүүдийг эвдэхгүйн тулд бүрэн бүтэн байдлын түвшинг заавал багасгасны дараа бүрэн бүтэн байдлын хувьд доор орших обьект уруу хандахыг зөвшөөрдөг.

Low-watermark integrity policy буюу доод түвшний бүрэн бүтэн байдлын MAC хувилбарыг хуучин man:lomac[4]-ийн шийдэлтэй эндүүрч болохгүй бөгөөд энэ хувилбар нь Biba-тай бараг л төстэй ажилладаг боловч ялгаатай тал нь субьектийн бууруулалтыг туслах зэргийн тасалгааны тусламжтай дэмжихийн тулд хөвөгч хаяг/шошгуудыг ашигладаг явдал юм. Энэ хоёр дахь тасалгаа нь `[auxgrade]` хэлбэрийг авдаг. lomac бодлогыг туслах зэргээр зааж өгөх үед энэ нь иймэрхүү харагдах ёстой: `lomac/10[2]`. Энд байгаа хоёр (2) гэсэн тоо нь туслах зэрэг юм.

MAC LOMAC бодлого нь бүрэн бүтэн байдлын хаяг/шошгоор бүх системийн обьектуудыг хаа сайгүй хаяглах явдалд тулгуурладаг бөгөөд субьектуудад бүрэн бүтэн байдлын хувьд доор орших обьектуудаас уншихыг зөвшөөрч дараа нь өндөр бүрэн бүтэн байдал бүхий обьектуудад ирээдүйд хийгдэж болзошгүй бичилтүүдээс урьдчилан сэргийлэхийн тулд субьект дээрх хаяг/шошгыг доошлуулж бууруулдаг. Энэ нь дээр хэлэлцэгдсэн `[auxgrade]` тохируулга болохоор уг бодлого нь илүү сайн нийцтэй байдлыг хангаж Biba-аас бага эхний тохиргоог шаардаж болох юм.

=== Жишээнүүд

Biba болон MLS бодлогуудын нэгэн адил `setfmac` болон `setpmac` хэрэгслүүд системийн обьектууд дээр хаяг/шошгонууд байрлуулахад хэрэглэгдэж болно:

[source,shell]
....
# setfmac /usr/home/trhodes lomac/high[low]
# getfmac /usr/home/trhodes lomac/high[low]
....

Энд байгаа туслах зэрэг нь `low` буюу доор гэж байгааг анзаараарай, энэ нь зөвхөн MAC LOMAC бодлогын хангадаг боломж юм.

[[mac-implementing]]
== MAC Шорон дахь Nagios

Дараах нь зөв тохируулсан бодлогуудын хамтаар төрөл бүрийн MAC модулиудыг ашиглан аюулгүй орчинг үүсгэхийг харуулах болно. Энэ нь зөвхөн тест бөгөөд хүн бүгдийн аюулгүй байдлын асуудалд бүрэн хариулт болно гэж тооцох ёсгүй юм. Бодлогыг зөвхөн шийдэж түүнийг орхигдуулах нь хэзээ ч ажиллахгүй бөгөөд жинхэнэ ажиллаж байгаа үйлдвэрлэлийн орчинд сүйрлийн болж болох юм.

Энэ процессийг эхлүүлэхээсээ өмнө `multilabel` тохируулга файлын систем бүр дээр энэ бүлгийн эхэнд дурдсаны дагуу тавигдах ёстой. Ингэж хийхгүй бол алдаа гарах болно. Энд байхдаа package:net-mngt/nagios-plugins[], package:net-mngt/nagios[], болон package:www/apache22[] портууд бүгд суулгагдаж тохируулагдаж зөв ажиллаж байгаа эсэхийг шалгаарай.

=== Хэрэглэгчийн insecure ангилал үүсгэнэ

Дараах хэрэглэгчийн ангиллыг [.filename]#/etc/login.conf# файлд нэмж:

[.programlisting]
....
insecure:\
:copyright=/etc/COPYRIGHT:\
:welcome=/etc/motd:\
:setenv=MAIL=/var/mail/$,BLOCKSIZE=K:\
:path=~/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin
:manpath=/usr/shared/man /usr/local/man:\
:nologin=/usr/sbin/nologin:\
:cputime=1h30m:\
:datasize=8M:\
:vmemoryuse=100M:\
:stacksize=2M:\
:memorylocked=4M:\
:memoryuse=8M:\
:filesize=8M:\
:coredumpsize=8M:\
:openfiles=24:\
:maxproc=32:\
:priority=0:\
:requirehome:\
:passwordtime=91d:\
:umask=022:\
:ignoretime@:\
:label=biba/10(10-10):
....

мөн дараах мөрийг анхдагч хэрэглэгчийн ангилалд нэмж процедурыг эхэлнэ:

[.programlisting]
....
:label=biba/high:
....

Энэ хийгдсэний дараа мэдээллийн баазыг дахин бүтээхийн тулд дараах тушаалыг ажиллуулах ёстой:

[source,shell]
....
# cap_mkdb /etc/login.conf
....

=== Ачаалалтын тохиргоо

Дахин ачаалах гэсний хэрэггүй, шаардлагатай модулиудыг систем эхлүүлэхэд дуудахын тулд дараах мөрүүдийг [.filename]#/boot/loader.conf# файлд нэмнэ:

[.programlisting]
....
mac_biba_load="YES"
mac_seeotheruids_load="YES"
....

=== Хэрэглэгчдийг тохируулна

`root` хэрэглэгчийг анхдагч ангилалд доор дурдсаныг ашиглан тохируулна:

[source,shell]
....
# pw usermod root -L default
....

`root` эсвэл системийн хэрэглэгчид биш бүх хэрэглэгчийн бүртгэлүүд одоо нэвтрэлийн ангилал шаардах болно. Нэвтрэлтийн ангилал шаардлагатай, түүнгүй бол хэрэглэгчид man:vi[1] зэрэг нийтлэг тушаалд хандах боломжгүй болно. Дараах `sh` скрипт үүнийг хийх болно:

[source,shell]
....
# for x in `awk -F: '($3 >= 1001) && ($3 != 65534) { print $1 }' \
	/etc/passwd`; do pw usermod $x -L default; done;
....

`nagios` болон `www` хэрэглэгчдийг insecure ангилалд оруулна:

[source,shell]
....
# pw usermod nagios -L insecure
....

[source,shell]
....
# pw usermod www -L insecure
....

=== Contexts буюу Сэдвийн файл үүсгэнэ

Сэдвийн файл нь одоо үүсгэгдсэн байх ёстой; дараах жишээ файлыг [.filename]#/etc/policy.contexts#-д байрлуулах ёстой.

[.programlisting]
....
# This is the default BIBA policy for this system.

# System:
/var/run                        biba/equal
/var/run/*                      biba/equal

/dev                            biba/equal
/dev/*                          biba/equal

/var				biba/equal
/var/spool                      biba/equal
/var/spool/*                    biba/equal

/var/log                        biba/equal
/var/log/*                      biba/equal

/tmp				biba/equal
/tmp/*				biba/equal
/var/tmp			biba/equal
/var/tmp/*			biba/equal

/var/spool/mqueue		biba/equal
/var/spool/clientmqueue		biba/equal

# For Nagios:
/usr/local/etc/nagios
/usr/local/etc/nagios/*         biba/10

/var/spool/nagios               biba/10
/var/spool/nagios/*             biba/10

# For apache
/usr/local/etc/apache           biba/10
/usr/local/etc/apache/*         biba/10
....

Энэ бодлого нь мэдээллийн урсгалд хязгаарлалтуудыг тавьж аюулгүй байдлыг хангадаг. Энэ тусгайлсан тохиргооны хувьд хэрэглэгчид, `root` болон бусад хэрэглэгчид Nagios програмд хандахаар хэзээ ч зөвшөөрөгдсөн байх ёсгүй. Nagios-ийн тохиргооны файлууд болон процессууд нь бүр мөсөн өөртөө багтсан буюу шоронд хийгдсэн байх болно.

Одоо энэ файлыг өөрийн систем уруу уншуулахдаа дараах тушаалыг ажиллуулна:

[source,shell]
....
# setfsmac -ef /etc/policy.contexts /
# setfsmac -ef /etc/policy.contexts /
....

[NOTE]
====
Дээрх файлын системийн байршил орчноосоо хамааран өөр байж болно; гэхдээ үүнийг файлын систем бүр дээр ажиллуулах ёстой.
====

[.filename]#/etc/mac.conf# файл гол хэсэгт дараах өөрчлөлтүүдийг шаарддаг:

[.programlisting]
....
default_labels file ?biba
default_labels ifnet ?biba
default_labels process ?biba
default_labels socket ?biba
....

=== Сүлжээг идэвхжүүлнэ

Дараах мөрийг [.filename]#/boot/loader.conf#-д нэмнэ:

[.programlisting]
....
security.mac.biba.trust_all_interfaces=1
....

Тэгээд дараа нь доор дурдсаныг [.filename]#rc.conf# файлд хадгалагдсан сүлжээний картны тохиргоонд нэмнэ. Хэрэв анхдагч Интернэтийн тохиргоо DHCP-ээр хийгдсэн бол системийг ачаалах болгоны дараа үүнийг гараараа тохируулах хэрэгтэй болох юм:

[.programlisting]
....
maclabel biba/equal
....

=== Тохиргоог тест хийх нь

Вэб сервер болон Nagios нь системийг эхлүүлэхэд ажиллахааргүй байгаа эсэхийг шалгаад дахин ачаална. `root` хэрэглэгч Nagios-ийн тохиргооны сан дахь ямар ч файлд хандаж чадах ёсгүйг баталгаажуулна. Хэрэв `root` нь [.filename]#/var/spool/nagios#-д man:ls[1]-ийг ажиллуулж чадаж байвал ямар нэг юм буруу байна гэсэн үг. Зөв бол "permission denied" алдаа буцаагдах ёстой.

Хэрэв бүгд зүгээр юм шиг санагдвал Nagios, Apache, болон Sendmail-ийг одоо аюулгүй байдлын бодлогод тааруулж ажиллуулж болно. Үүнийг дараах тушаал хийх болно:

[source,shell]
....
# cd /etc/mail && make stop && \
setpmac biba/equal make start && setpmac biba/10\(10-10\) apachectl start && \
setpmac biba/10\(10-10\) /usr/local/etc/rc.d/nagios.sh forcestart
....

Бүгд зөв ажиллаж байгаа эсэхийг баталгаажуулж дахин шалгаарай. Хэрэв үгүй бол бүртгэлийн файлуудаас алдааны мэдэгдлүүд байгаа эсэхийг шалгана. man:sysctl[8] хэрэгсэл ашиглаж man:mac_biba[4] аюулгүй байдлын бодлогын модулийн үйлчлэлийг хааж бүгдийг эхнээс нь эхлэхийг оролдоорой.

[NOTE]
====
`root` хэрэглэгч аюулгүй байдлын үйлчлэлийг өөрчилж тохиргооны файлыг айлгүйгээр засварлаж чадна. Дараах тушаал нь шинээр үүсгэсэн бүрхүүлийн хувьд аюулгүй байдлын бодлогыг доод зэрэг уруу орж буурахыг зөвшөөрөх болно:

[source,shell]
....
# setpmac biba/10 csh
....

Үүнийг болгохгүй байлгахын тулд man:login.conf[5]-оор хэрэглэгчийг хүрээнд оруулна. Хэрэв man:setpmac[8] тушаалыг тасалгааных нь хүрээнээс гадна ажиллуулах гэж оролдвол алдаа буцаагдах бөгөөд тушаал ажиллахгүй байх болно. Энэ тохиолдолд root-ийг `biba/high(high-high)` болгож тохируулна.
====

[[mac-userlocked]]
== Хэрэглэгчийг түгжих

Энэ жишээ нь харьцангуй жижиг, тавиас бага хэрэглэгчтэй хадгалалтын системийг авч үздэг. Хэрэглэгчид нь нэвтрэлтийн боломжуудтай байх бөгөөд тэдэнд зөвхөн өгөгдөл биш бас хандалтын эх үүсвэрүүдийг хадгалахыг зөвшөөрнө.

Энэ тохиолдолд man:mac_bsdextended[4] нь man:mac_seeotheruids[4]-тэй холилдон оршиж болох бөгөөд системийн обьектуудад хандахыг хаагаад зогсохгүй бас хэрэглэгчийн процессийг нуух хандалтыг бас хаадаг.

Дараах мөрийг [.filename]#/boot/loader.conf# файлд нэмж эхэлнэ:

[.programlisting]
....
mac_seeotheruids_load="YES"
....

man:mac_bsdextended[4] аюулгүй байдлын бодлогын модулийг дараах rc.conf хувьсагчийг хэрэглэн идэвхтэй болгож болно:

[.programlisting]
....
ugidfw_enable="YES"
....

[.filename]#/etc/rc.bsdextended# файлд хадгалагдах анхдагч дүрмүүд нь системийг эхлүүлэхэд дуудагдана. Гэхдээ анхдагч оруулгууд нь өөрчлөлтүүд шаардаж болох юм. Энэ машин нь зөвхөн хэрэглэгчдэд үйлчлэхээр зориулагдсан болохоор сүүлийн хоёроос бусдыг хааж тайлбар болгон үлдээж болох юм. Сүүлийн хоёр нь анхдагчаар хэрэглэгчийн эзэмших системийн обьектуудыг дуудуулах болно.

Шаардлагатай хэрэглэгчдийг энэ машин уруу нэмээд дахин ачаална. Тест хийх зорилгоор хоёр консол дээр өөр хэрэглэгчээр нэвтрэхийг оролдоорой. Бусад хэрэглэгчдийн процессууд харж болохоор байгаа эсэхийг харахын тулд `ps aux` тушаалыг ажиллуулна. man:ls[1]-ийг нөгөө хэрэглэгчийн гэрийн сан дээр ажиллуулахыг оролдоорой, энэ нь амжилтгүй болох болно.

Супер хэрэглэгчийн хандалтыг хаахын тулд ашигладаг тусгай `sysctl`-уудыг өөрчлөхөөс бусад тохиолдолд `root` хэрэглэгчээр тест битгий хийгээрэй.

[NOTE]
====
Шинэ хэрэглэгч нэмэгдэхэд тэдгээрийн man:mac_bsdextended[4] дүрмүүд дүрмийн олонлогийн жагсаалтад байхгүй байна. Дүрмийн олонлогийг хурдан шинэчлэхийн тулд man:kldunload[8] болон man:kldload[8] хэрэгслүүдийг ашиглан аюулгүй байдлын бодлогын модулийг буулгаж дараа нь түүнийг дахин ачаалж хийнэ.
====

[[mac-troubleshoot]]
== MAC Тогтолцооны алдааг олж засварлах

Хөгжүүлэлтийн явцад цөөн хэрэглэгчид энгийн тохируулга дээр асуудлууд гарснаа мэдээлсэн. Эдгээр асуудлуудын заримыг доор жагсаав:

=== `multilabel` тохируулгыг [.filename]#/# дээр идэвхжүүлж болохгүй байна

`multilabel` туг миний root ([.filename]#/#) хуваалтан дээр идэвхтэй болохгүй байна!

50 хэрэглэгч тутмын нэг нь ийм асуудалтай байдаг бололтой, харин бид энэ асуудалтай эхний тохиргооны үеэр тулгарсан. "bug" буюу "цох" гэж нэрлэгдэх үүний цаадах ажиглалт нь үүнийг буруу баримтжуулалт эсвэл баримтын буруу тайлбарлалтын үр дүн гэж намайг итгэхэд хүргэсэн. Энэ яагаад болсноос үл хамааран үүнийг шийдэхийн тулд дараах алхмуудыг хийж болох юм:

[.procedure]
====
. [.filename]#/etc/fstab#-ийг засварлаж root хуваалтыг зөвхөн унших зорилгоор `ro` гэж тохируулна.
. Ганц хэрэглэгчийн горимд дахин ачаална.
. `tunefs -l enable` тушаалыг [.filename]#/# дээр ажиллуулна.
. Системийг энгийн горимд дахин ачаална.
. `mount -urw`[.filename]#/# тушаалыг ажиллуулж `ro` тохируулгыг `rw` болгож [.filename]#/etc/fstab# файлд өөрчлөн системийг дахин ачаална.
. root файлын систем дээр `multilabel` тохируулга зөв тохируулагдсаныг баталгаажуулж `mount` тушаалын гаралтыг дахин шалгаарай.
====

=== MAC-ийн дараа X11 серверийг эхлүүлж чадахгүй байна

MAC-ийн тусламжтай аюулгүй орчинг үүсгэсний дараа би X-ийг дахиж эхлүүлж чадахаа больчихлоо!

Энэ нь MAC ``хуваалт``ын бодлого эсвэл MAC хаяглалтын бодлогуудын аль нэгний буруу хаяглалтаас болсон байж болох юм. Дибаг хийхийн тулд доор дурдсаныг оролдоод үзээрэй:

[.procedure]
====
. Алдааны мэдэгдлийг шалгана; хэрэв хэрэглэгч `insecure` ангилалд байгаа бол ``хуваалт``ын бодлого гэмтэн байж болох юм. Хэрэглэгчийн ангиллыг `default` буюу анхдагч ангилал уруу тохируулж мэдээллийн баазыг `cap_mkdb` тушаалын тусламжтай дахин бүтээх хэрэгтэй. Хэрэв энэ нь асуудлыг арилгаж чадахгүй байгаа бол хоёрдугаар алхам уруу ор.
. Хаяг/шошгоны бодлогуудыг давхар шалгаарай. Асуудалтай байгаа хэрэглэгч, X11 програм болон [.filename]#/dev# оруулгуудын хувьд бодлогууд зөв заагдсан эсэхийг баталгаажуулаарай.
. Хэрэв эдгээрийн аль нь ч асуудлыг тань шийдэхгүй бол http://www.TrustedBSD.org[TrustedBSD] вэб сайтад байрлах TrustedBSD-ийн хэлэлцүүлгийн жагсаалтууд эсвэл {freebsd-questions} захидлын жагсаалт уруу алдааны мэдэгдэл болон өөрийн орчны тухай мэдээллийг илгээгээрэй.
====

=== Error: man:_secure_path[3] cannot stat [.filename]#.login_conf#

Намайг `root` хэрэглэгчээс систем дээрх өөр хэрэглэгч уруу шилжихийг оролдох үед `_secure_path: unable to state .login_conf` гэсэн алдаа гараад байна.

Энэ мэдэгдэл нь тэр болох гэж байгаа хэрэглэгчийн хаяг/шошгоны тохиргооноос хэрэглэгчийн өөрийнх нь тохиргоо өндөр байгааг ихэвчлэн үзүүлдэг. Жишээ нь систем дээрх хэрэглэгч `joe` анхдагч `biba/low` гэсэн хаяг/шошготой байна гэж бодъё. `biba/high` хаяг/шошготой `root` хэрэглэгч `joe`-ийн гэр санг харж чадахгүй. Энэ нь `root` хэрэглэгч `su` тушаал ашиглан `joe` болсон ч гэсэн болохгүй байна. Энэ тохиолдолд Biba бүрэн бүтэн байдлын загвар нь `root` хэрэглэгчийг бүрэн бүтэн байдлын доод түвшин тохируулагдсан обьектуудыг харахыг зөвшөөрөхгүй байх болно.

=== `root` хэрэглэгчийн нэр эвдэрсэн байна!

Энгийн эсвэл бүр ганц хэрэглэгчийн горимд `root` хэрэглэгч танигддаггүй. `whoami` тушаал 0 (тэг) буцаах бөгөөд `su` тушаал `who are you?` гэсэн алдааны мэдэгдлийг буцаадаг. Юу болоод байгаа юм бол оо?

Энэ нь хаяглах бодлого man:sysctl[8]-оор хаагдсан эсвэл бодлогын модулийг буулгаснаас болдог. Хэрэв бодлого хаагдсан эсвэл түр зуур хаагдсан бол `label` тохируулгыг арилган нэвтрэлтийн боломжуудын мэдээллийн баазыг дахин тохируулах хэрэгтэй. Бүх `label` тохируулгууд арилсан эсэхийг баталгаажуулж [.filename]#login.conf# файлаа дахин шалгаж мэдээллийн баазаа `cap_mkdb` тушаалаар дахин бүтээх хэрэгтэй.

Энэ нь [.filename]#master.passwd# файлд эсвэл мэдээллийн баазад хандах хандалтыг бодлого хязгаарласнаас болоод бас гарч болох юм. Системд ашиглагдаж байгаа ерөнхий бодлоготой зөрчилдөх хаяг/шошгоны доор администратор файлыг өөрчлөхөд ихэвчлэн ингэдэг. Ийм тохиолдлуудад хэрэглэгчийн мэдээллийг систем унших бөгөөд файл нь шинэ хаяг/шошго удамшин авсан болохоор хандалт хаалттай байх болно. Бодлогыг man:sysctl[8]-ий тусламжтай хаах хэрэгтэй. Ингэхэд бүх зүйлс хэвийндээ эргэн орох болно.
