---
title: Бүлэг 19. Хадгалалт
part: хэсэг III. Системийн Удирдлага
prev: books/handbook/audit
next: books/handbook/geom
---

[[disks]]
= Хадгалалт
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:source-highlighter: rouge
:experimental:
:skip-front-matter:
:toc-title: Гарчиг
:table-caption: Хүснэгт
:figure-caption: Зураг
:example-caption: Жишээ
:xrefstyle: basic
:relfileprefix: ../
:outfilesuffix:
:sectnumoffset: 19

ifeval::["{backend}" == "html5"]
:imagesdir: ../../../images/books/handbook/disks/
endif::[]

ifeval::["{backend}" == "pdf"]
:imagesdir: ../../../../static/images/books/handbook/disks/
endif::[]

ifeval::["{backend}" == "epub3"]
:imagesdir: ../../../../static/images/books/handbook/disks/
endif::[]

include::shared/authors.adoc[]
include::shared/releases.adoc[]
include::shared/mn/mailing-lists.adoc[]
include::shared/mn/teams.adoc[]
include::shared/mn/urls.adoc[]

toc::[]

[[disks-synopsis]]
== Ерөнхий агуулга

Энэ бүлэг нь FreeBSD дээр дискнүүдийг ашиглах талаар тайлбарлах болно. Эдгээрт санах ой дээр тулгуурласан дискнүүд, сүлжээнд залгагдсан дискнүүд, стандарт SCSI/IDE хадгалалтын төхөөрөмжүүд болон USB интерфэйс ашигладаг төхөөрөмжүүд багтах юм.

Энэ бүлгийг уншсаны дараа, та дараах зүйлсийг мэдэх болно:

* Физик диск (хуваалтууд болон зүсмэлүүд) дээрх өгөгдлийн зохион байгуулалтыг тайлбарладаг FreeBSD-ийн ашигладаг ухагдахуун.
* Өөрийн систем дээр нэмэлт хатуу дискнүүдийг хэрхэн нэмэх талаар.
* USB хадгалалтын төхөөрөмжүүдийг ашиглахын тулд FreeBSD-г хэрхэн тохируулах талаар.
* Санах ойн диск зэрэг виртуал файлын системүүдийг хэрхэн тохируулах талаар.
* Дискний зайн хэрэглээг хязгаарлахын тулд ноогдлыг хэрхэн ашиглах талаар.
* Дискийг халдагчдаас хамгаалж нууцлахын тулд хэрхэн шифрлэх талаар.
* FreeBSD дээр CD болон DVD-г хэрхэн үүсгэж шарах талаар.
* Нөөцлөлтөд зориулсан хадгалалтын төрөл бүрийн тохируулгууд.
* FreeBSD дээр байдаг нөөцлөлтийн програмуудыг хэрхэн ашиглах талаар.
* Уян диск уруу хэрхэн нөөцлөх талаар.
* Файлын системийн хормын хувилбар гэж юу болох түүнийг хэрхэн үр дүнтэйгээр ашиглах талаар.

Энэ бүлгийг уншихаасаа өмнө та дараах зүйлсийг гүйцэтгэх хэрэгтэй:

* Шинэ FreeBSD цөмийг хэрхэн тохируулж суулгах талаар мэдэх (crossref:kernelconfig[kernelconfig,FreeBSD цөмийг тохируулах нь]).

[[disks-naming]]
== Төхөөрөмжийн нэрс

Дараах нь FreeBSD-д дэмжигдсэн физик хадгалалтын төхөөрөмжүүд болон тэдгээртэй холбоотой төхөөрөмжийн нэрсийн жагсаалт юм.

[[disk-naming-physical-table]]
.Физик диск нэрлэх заншил
[cols="1,1", frame="none", options="header"]
|===
| Хөтчийн төрөл
| Хөтчийн төхөөрөмжийн нэр

|IDE хатуу хөтчүүд
|`ad`

|IDE CDROM хөтчүүд
|`acd`

|SCSI хатуу хөтчүүд болон USB Mass хадгалалтын төхөөрөмжүүд
|`da`

|SCSI CDROM хөтчүүд
|`cd`

|Төрөлжүүлсэн стандарт бус CDROM хөтчүүд
|Mitsumi CD-ROM-ийн хувьд `mcd` ба Sony CD-ROM хөтчүүдийн хувьд `scd`

|Уян хөтчүүд
|`fd`

|SCSI соронзон хальсны хөтчүүд
|`sa`

|IDE соронзон хальсны хөтчүүд
|`ast`

|Flash хөтчүүд
|DiskOnChip(R) Flash хөтчийн хувьд `fla`

|RAID хөтчүүд
|Adaptec(R) AdvancedRAID-н хувьд `aacd`, Mylex(R)-ийн хувьд `mlxd` ба `mlyd`, AMI MegaRAID(R)-ийн хувьд `amrd`, Compaq Smart RAID-ийн хувьд `idad`, 3ware(R) RAID-ийн хувьд `twed`.
|===

[[disks-adding]]
== Диск нэмэх

Дараах хэсэг зөвхөн нэг хөтөчтэй машинд шинэ SCSI диск хэрхэн нэмэх талаар тайлбарлах болно. Эхлээд компьютераа унтраагаад хөтчийг компьютер, хянагч болон хөтчийн үйлдвэрлэгчийн заавруудын дагуу суулгана. Үүнийг хийх маш олон төрлийн процедуруудаас болоод энэ тухай дэлгэрэнгүй мэдээлэл нь энэ баримтын хамрах хүрээнээс гадна юм.

`root` хэрэглэгчээр нэвтрэх хэрэгтэй. Та хөтчийг суулгасны дараа шинэ диск олдсон эсэхийг [.filename]#/var/run/dmesg.boot#-с шалгаарай. Шинээр нэмсэн хөтөч нь [.filename]#da1# байх бөгөөд бид үүнийг [.filename]#/1# дээр холбохыг хүснэ (хэрэв та IDE хөтөч нэмж байгаа бол төхөөрөмжийн нэр нь [.filename]#ad1# болно).

FreeBSD нь IBM-PC-тэй нийцтэй компьютеруудтай ажилладаг учраас PC BIOS хуваалтуудыг бодолцох ёстой. Эдгээр нь уламжлалт BSD хуваалтуудаас өөр юм. PC диск нь дөрөв хүртэлх тооны BSD хуваалттай байдаг. Хэрэв диск нь жинхэнээрээ FreeBSD-д зориулагдах бол та _dedicated буюу зориулагдсан_ горимыг ашиглаж болно. Үгүй бол FreeBSD нь PC BIOS хуваалтуудын аль нэгэн дээр байрлах болно. FreeBSD нь PC BIOS хуваалтуудыг уламжлалт BSD хуваалтуудтай эндүүрэхгүйн тулд _зүсмэлүүд_ гэж нэрлэдэг. Та бас FreeBSD-д зориулагдсан боловч өөр үйлдлийн систем суулгагдсан компьютер дээр ашигласан диск дээрх зүсмэлүүдийг хэрэглэж болох юм. Энэ нь FreeBSD биш өөр үйлдлийн системийн `fdisk` хэрэгсэлтэй андуурахаас хамгаалах нэг сайн арга юм.

Зүсмэлийн хувьд бол хөтөч нь [.filename]#/dev/da1s1e# гэж нэмэгдэх болно. Үүнийг SCSI диск, нэгжийн дугаар 1 (хоёр дахь SCSI диск), зүсмэл 1 (PC BIOS хуваалт 1) болон [.filename]#e# BSD хуваалт гэж уншина. Зориулагдсан тохиолдолд хөтөч нь ердөө л [.filename]#/dev/da1e# гэж нэмэгдэнэ.

Секторуудын тоог хадгалахын тулд 32 битийн бүхэл тоог ашигладгаас болоод man:bsdlabel[8] нь нэг дискний хувьд 2^32-1 сектор буюу ихэнх тохиолдолд 2TB болж хязгаарлагддаг. man:fdisk[8] хэлбэршүүлэлт нь 2^32-1-с ихгүй эхлэх сектор болон 2^32-1-с ихгүй уртыг зөвшөөрч хуваалтуудыг 2TB, дискнүүдийг ихэнх тохиолдолд 4TB болгож хязгаарладаг. man:sunlabel[8] хэлбэршүүлэлт нь нэг хуваалтын хувьд 2^32-1 сектороор, нийтдээ 16TB-ийн 8 хуваалтаар хязгаарлагддаг. Илүү том дискнүүдийн хувьд man:gpart[8] ашиглан GPT хуваалтуудыг үүсгэж болно. GPT нь 4 зүсмэлээр хязгаарлагддагүйгээрээ ашигтай байдаг.

=== man:sysinstall[8]-г ашиглах нь

[.procedure]
====

. Sysinstall-г жолоодох нь
+ 
Та `sysinstall`-н хялбар ашиглаж болох цэснүүдийн тусламжтайгаар шинэ дискийг хуваан хаяглаж болох юм. `root` хэрэгчээр нэвтрэх буюу эсвэл `su` тушаалыг ашиглаарай. `sysinstall`-г ажиллуулж `Configure` цэс уруу орно. `FreeBSD Configuration Menu` дотор доош шилжиж `Fdisk` тохируулгыг сонгоно.
. fdisk хуваалт засварлагч
+ 
fdisk-ийн дотор байхдаа kbd:[A]-г дарвал дискийг бүхэлд нь FreeBSD-д ашиглах болно. Асуух үед нь хэрэв та "ирээдүйд суулгаж болзошгүй үйлдлийн системүүдтэй хамтран ажиллахаар үлдэхийг хүсвэл" `YES` гэж хариулаарай. kbd:[W]-г ашиглан өөрчлөлтүүдийг диск уруу бичнэ. Одоо FDISK засварлагчаас kbd:[Q]-г дарж гараарай. Дараа нь танаас "Master Boot Record буюу Мастер Ачаалагч Бичлэгийн" талаар асуух болно. Та ажиллаж байгаа систем дээр диск нэмж байгаа болохоор `None`-г сонгох хэрэгтэй.
. Дискний Шошго засварлагч
+ 
Дараа нь sysinstall-с гарч дахин түүнийг эхлүүлэх хэрэгтэй. Дээрх заавруудыг дагаарай, гэхдээ энэ удаад `Label` тохируулгыг сонгоорой. Энэ нь `Disk Label Editor буюу дискний шошго засварлагч` уруу орно. Энд та уламжлалт BSD хуваалтуудыг үүсгэдэг. Диск нь `a-h` гэж хаяглагдсан найм хүртэлх хуваалтуудтай байж болно. Хуваалтын шошгонуудын цөөн хэд нь тусгай хэрэглээтэй байдаг. `a` хуваалт нь root хуваалтанд ([.filename]#/#) ашиглагддаг. Тиймээс зөвхөн таны системийн диск (өөрөөр хэлбэл таны ачаалалт хийсэн диск) `a` хуваалттай байх ёстой. `b` хуваалт нь swap хуваалтуудад хэрэглэгддэг бөгөөд та swap хуваалттай олон дисктэй байж болох юм. `c` хуваалт нь зориулагдсан горимд бүх дискийг, зүсмэлийн горимд бүхэл FreeBSD зүсмэлийг эсвэл заадаг. Бусад хуваалтууд нь ерөнхий хэрэглээнд зориулагдсан.
+ 
sysinstall-ийн шошго засварлагч нь root биш, swap биш хуваалтуудад зориулж `e` хуваалтыг илүүтэй үздэг. Шошго засварлагч дотор байхдаа kbd:[C]-г даран ганц файлын систем үүсгэх хэрэгтэй. Асуух үед, хэрэв энэ нь FS (файлын систем) эсвэл swap байх юм бол `FS`-г сонгож холбох цэгийг (өөрөөр хэлбэл [.filename]#/mnt#) бичээрэй. Хэрэв дискийг суулгацын дараах горимд нэмж байгаа бол sysinstall нь танд зориулж оруулгуудыг [.filename]#/etc/fstab# файлд үүсгэхгүй, тиймээс таны зааж өгсөн холбох цэг нь чухал биш юм.
+ 
Та одоо шинэ шошгыг диск уруу бичиж түүн дээр файлын систем үүсгэхэд бэлэн боллоо. Үүнийг kbd:[W]-г дарж хийнэ. sysinstall-ын шинэ хуваалтыг холбож чадахгүй байна гэсэн алдааг өнгөрүүлэх хэрэгтэй. Шошго засварлагч болон sysinstall-с бүр мөсөн гараарай.
. Төгсгөл
+ 
Хамгийн сүүлийн алхам нь [.filename]#/etc/fstab# файлыг засварлаж өөрийн шинэ дискний оруулгыг нэмэх явдал юм.
====

=== Тушаалын мөрийн хэрэгслүүдийг ашиглах нь

==== Зүсмэлүүдийг ашиглах нь

Энэ тохиргоо нь таны дискийг өөрийн чинь компьютер дээр суулгагдсан байж болох бусад үйлдлийн системтэй зөв ажиллаж өөр бусад үйлдлийн системийн `fdisk` хэрэгслүүдтэй эндүүрэхгүй байх боломжийг бүрдүүлдэг. Шинэ дискийг суулгахад энэ аргыг ашиглахыг зөвлөдөг. Хэрэв танд үнэхээр тохирох шалтгаан байгаа тохиолдолд `зориулагдсан` горимыг ашиглаарай!

[source,bash]
....
# dd if=/dev/zero of=/dev/da1 bs=1k count=1
# fdisk -BI da1 #Initialize your new disk
# bsdlabel -B -w da1s1 auto #Label it.
# bsdlabel -e da1s1 # Edit the bsdlabel just created and add any partitions.
# mkdir -p /1
# newfs /dev/da1s1e # Repeat this for every partition you created.
# mount /dev/da1s1e /1 # Mount the partition(s)
# vi /etc/fstab # Add the appropriate entry/entries to your /etc/fstab.
....

Хэрэв танд IDE диск байвал [.filename]#da#-г [.filename]#ad# гэж солиорой.

==== Зориулагдсан

Хэрэв та шинэ хөтчийг өөр үйлдлийн системтэй цуг хуваалцахгүй бол `зориулагдсан` горимыг ашиглаж болох юм. Энэ горим нь Microsoft үйлдлийн системийн толгойг эргүүлж болохыг санаарай; гэхдээ тэдгээр нь ямар ч эвдрэл гэмтэл үүсгэхгүй. IBM-ийн OS/2(R) нь харин олсон бүх ойлгохгүй байгаа ямар ч хуваалтыг хувьдаа "завших" болно.

[source,bash]
....
# dd if=/dev/zero of=/dev/da1 bs=1k count=1
# bsdlabel -Bw da1 auto
# bsdlabel -e da1				# create the `e' partition
# newfs /dev/da1e
# mkdir -p /1
# vi /etc/fstab				# add an entry for /dev/da1e
# mount /1
....

Өөр нэг арга нь:

[source,bash]
....
# dd if=/dev/zero of=/dev/da1 count=2
# bsdlabel /dev/da1 | bsdlabel -BR da1 /dev/stdin
# newfs /dev/da1e
# mkdir -p /1
# vi /etc/fstab					# add an entry for /dev/da1e
# mount /1
....

[[raid]]
== RAID

[[raid-soft]]
=== Програм хангамжийн RAID

[[ccd]]
==== Нийлүүлэгдсэн Дискний Драйвер (Concatenated Disk Driver буюу CCD) тохиргоо

Бөөн хадгалалтын шийдлийг сонгохдоо бодолцох хамгийн чухал хүчин зүйлүүд нь хурд, найдвартай байдал болон өртөг юм. Энэ гурвыг гурвууланг нь тэнцүү байлгах нь ховор байдаг; ерөнхийдөө хурдан, найдвартай бөөн хадгалалтын төхөөрөмж нь үнэтэй бөгөөд үнийн хувьд хямдыг сонгох нь хурд эсвэл найдвартай байдлын аль нэгийг золиослох хэрэгтэй болдог.

Доор тайлбарласан системийг дизайн хийхдээ өртгийг хамгийн чухал хүчин зүйл гэж сонгож авсан бөгөөд үүний дараа хурд, хурдын дараа найдвартай байдлыг сонгосон. Энэ системийн өгөгдөл дамжуулах хурд нь эцсийн эцэст сүлжээгээр шахагддаг. Найдвартай байдал нь маш чухал боловч доор тайлбарласан CCD хөтөч нь CD-R-ууд дээр аль хэдийн бүтнээрээ нөөцлөгдсөн, амархнаар солигдож болох өгөгдөлд шууд үйлчилдэг.

Өөрийн шаардлагыг тодорхойлох нь бөөн хадгалалтын шийдлийг сонгох анхны алхам юм. Хэрэв таны шаардлага нь хурд эсвэл найдвартай байдлыг өртгөөс илүүтэй үзэж байгаа бол таны шийдэл энэ хэсэгт тайлбарласан шийдлээс өөр болох болно.

[[ccd-installhw]]
===== Тоног төхөөрөмжийг суулгах нь

IDE системийн дискнээс гадна гурван Western Digital 30GB, 5400 RPM IDE диск нь доор тайлбарласан CCD дискний гол цөм болж нийтдээ ойролцоогоор 90GB шууд хадгалалт болно. Туйлын хүслээр бол IDE диск бүр өөрийн IDE хянагч болон кабельтай байна, гэхдээ өртгийг багасгахын тулд нэмэлт IDE хянагчууд ашиглагдаагүй болно. Харин дискнүүд нь jumper буюу холбогчоор тохируулагдсан бөгөөд ингэснээр IDE хянагч бүр нэг мастер болон нэг боолтой байна.

Дахин ачаалах үед системийн BIOS залгагдсан дискнүүдийг автоматаар олохоор тохируулагдсан байдаг. Илүү чухал зүйл нь FreeBSD тэдгээрийг дахин ачаалахад олсон явдал юм:

[.programlisting]
....
ad0: 19574MB <WDC WD205BA> [39770/16/63] at ata0-master UDMA33
ad1: 29333MB <WDC WD307AA> [59598/16/63] at ata0-slave UDMA33
ad2: 29333MB <WDC WD307AA> [59598/16/63] at ata1-master UDMA33
ad3: 29333MB <WDC WD307AA> [59598/16/63] at ata1-slave UDMA33
....

[NOTE]
====
Хэрэв FreeBSD дискнүүдийг бүгдийг нь олохгүй байгаа бол та тэдгээрийг зөвөөр холбосон эсэхээ шалгаарай. IDE хөтчүүдийн ихэнх нь бас "Cable Select" холбогчтой байдаг. Энэ нь мастер/боол харилцаанд зориулагдсан холбогч _биш_ юм. Хөтчийн баримтаас зөв холбогчийг таних талаар лавлаарай.
====

Дараа нь тэдгээрийг файлын системийн хэсэг болгон залгах талаар бодох хэрэгтэй. Та man:vinum[4] (crossref:vinum[vinum-vinum,Vinum Эзлэхүүн Менежер]) болон man:ccd[4] хоёуланг судлах хэрэгтэй. Энэ тохиргооны хувьд man:ccd[4]-г сонгосон.

[[ccd-setup]]
===== CCD-г тохируулах нь

man:ccd[4] хөтөч нь хэд хэдэн адил дискнүүдийг авч тэдгээрийг нэг логик файл систем болгон нийлүүлэх боломжийг олгодог. man:ccd[4]-г ашиглахын тулд танд man:ccd[4] дэмжлэг цуг бүтээгдсэн цөм хэрэгтэй. Энэ мөрийг цөмийн тохиргооны файлдаа нэмээд цөмөө дахин бүтээж суулгаарай:

[.programlisting]
....
device   ccd
....

man:ccd[4] дэмжлэг цөмийн дуудагдах модуль хэлбэрээр бас дуудагдаж болно.

man:ccd[4]-г тохируулахын тулд та эхлээд дискнүүдийг хаяглах man:bsdlabel[8]-г ашиглах ёстой:

[.programlisting]
....
bsdlabel -w ad1 auto
bsdlabel -w ad2 auto
bsdlabel -w ad3 auto
....

Энэ нь бүх дискний дагуух [.filename]#ad1c#, [.filename]#ad2c# болон [.filename]#ad3c#-д зориулж bsdlabel үүсгэдэг.

Дараагийн алхам нь дискний шошгоны төрлийг өөрчлөх явдал юм. Та дискнүүдийг засварлахдаа man:bsdlabel[8]-г ашиглаж болно:

[.programlisting]
....
bsdlabel -e ad1
bsdlabel -e ad2
bsdlabel -e ad3
....

Энэ нь диск бүр дэх тухайн дискний шошгыг `EDITOR` орчны хувьсагчид заасан засварлагчаар, ихэнхдээ man:vi[1]-ээр онгойлгодог.

Өөрчлөлт хийгдээгүй дискний шошго иймэрхүү харагдах болно:

[.programlisting]
....
8 partitions:
#        size   offset    fstype   [fsize bsize bps/cpg]
  c: 60074784        0    unused        0     0     0   # (Cyl.    0 - 59597)
....

man:ccd[4]-д зориулж ашиглахаар шинэ `e` хуваалтыг нэмнэ. Үүнийг ихэвчлэн `c` хуваалтаас хуулж болох боловч `fstype` нь `4.2BSD` байх _ёстой_. Дискний шошго одоо иймэрхүү харагдах ёстой:

[.programlisting]
....
8 partitions:
#        size   offset    fstype   [fsize bsize bps/cpg]
  c: 60074784        0    unused        0     0     0   # (Cyl.    0 - 59597)
  e: 60074784        0    4.2BSD        0     0     0   # (Cyl.    0 - 59597)
....

[[ccd-buildingfs]]
===== Файлын системийг бүтээх нь

Та бүх дискнүүдээ хаягласны дараа man:ccd[4]-г бүтээх ёстой. Үүнийг хийхийн тулд дараах тохируулгуудтай адилаар man:ccdconfig[8]-г ашиглана:

[.programlisting]
....
ccdconfig ccd0 32 0 /dev/ad1e /dev/ad2e /dev/ad3e
....

Тохируулга бүрийн хэрэглээ болон утгыг доор харуулав:
* Эхний нэмэлт өгөгдөл нь тохируулах төхөөрөмж байх бөгөөд энэ тохиолдолд [.filename]#/dev/ccd0c# байна. [.filename]#/dev/# хэсэг байхгүй ч байж болно.
* Файлын системд зориулсан interleave. interleave нь дискний блокууд дээрх судлын хэмжээг тодорхойлдог бөгөөд нэг бүр нь ихэвчлэн 512 байт байдаг. Тэгэхээр 32 interleave нь 16,384 байт байна.
* man:ccdconfig[8]-д зориулсан тугнууд. Хэрэв та хөтчийг толин тусгал үүсгэж идэвхжүүлэхийг хүсвэл тугийг энд зааж өгч болно. Энэ тохиргоо нь man:ccd[4]-н хувьд толин тусгал үүсгэлтийг хангадаггүй учир энэ нь 0 (тэг) гэж тохируулагдсан.
* man:ccdconfig[8] уруу өгөгдөх сүүлийн нэмэлт өгөгдлүүд нь массивт оруулах төхөөрөмжүүд юм. Төхөөрөмж бүрийн хувьд бүрэн гүйцэд замын нэрийг ашиглах хэрэгтэй.

man:ccdconfig[8]-г ажиллуулсны дараа man:ccd[4] тохируулагдана. Файлын систем суулгагдаж болно. Тохируулгуудын талаар man:newfs[8]-с лавлана уу, эсвэл ердөө л ингэж ажиллуулна: 

[.programlisting]
....
newfs /dev/ccd0c
....

[[ccd-auto]]
===== Бүгдийг автомат болгох нь

Ерөнхийдөө та man:ccd[4]-г дахин ачаалах бүртээ холбохыг хүснэ. Үүнийг хийхийн тулд та эхлээд тохируулах хэрэгтэй. Өөрийн одоогийн тохиргоогоо дараах тушаал ашиглаж [.filename]#/etc/ccd.conf# уруу бичих хэрэгтэй:

[.programlisting]
....
ccdconfig -g > /etc/ccd.conf
....

Дахин ачаалах үед скрипт `/etc/rc` нь хэрэв [.filename]#/etc/ccd.conf# байвал `ccdconfig -C` тушаалыг ажиллуулна. Энэ нь man:ccd[4]-г холбож болохоор болгож автоматаар тохируулна.

[NOTE]
====
Хэрэв та ганц хэрэглэгчийн горим уруу ачаалж байгаа бол man:ccd[4]-г man:mount[8] хийхээсээ өмнө массивыг тохируулахын тулд дараах тушаалыг ажиллуулах шаардлагатай:

[.programlisting]
....
ccdconfig -C
....

====

man:ccd[4]-г автоматаар холбохын тулд man:ccd[4]-н оруулгыг [.filename]#/etc/fstab# файлд байрлуулах хэрэгтэй. Ингэсэн тохиолдолд энэ нь ачаалах үед холбогдох болно:

[.programlisting]
....
/dev/ccd0c              /media       ufs     rw      2       2
....

[[vinum]]
==== Vinum Эзлэхүүн Менежер

Vinum Эзлэхүүн Менежер нь виртуал диск хөтчийг хийдэг блок төхөөрөмжийн драйвер юм. Энэ нь дискний тоног төхөөрөмжийг блок төхөөрөмжийн интерфэйсээс тусгаарлаж уян хатан байдал, ажиллагаа болон найдвартай байдлыг дискний хадгалалтын уламжлалт зүсмэлийн харагдалтаас илүүтэйгээр хангах тийм аргаар өгөгдлийг дүрсэлдэг. man:vinum[4] нь RAID-0, RAID-1 болон RAID-5 загваруудыг тус бүрт нь болон холбоотой байдлаар нь шийддэг.

man:vinum[4]-ийн талаар дэлгэрэнгүй мэдээллийг crossref:vinum[vinum-vinum,Vinum Эзлэхүүн Менежер]-с үзнэ үү.

[[raid-hard]]
=== Тоног төхөөрөмжийн RAID

FreeBSD нь бас төрөл бүрийн тоног төхөөрөмжийн RAID хянагчуудыг дэмждэг. Эдгээр төхөөрөмжүүд нь FreeBSD-д зориулсан тусгай програм хангамжаар массивыг удирдах шаардлагагүйгээр RAID дэд системийг хянадаг.

Карт дээрх BIOS-г ашиглан карт нь дискний үйлдлүүдийн ихэнхийг өөрөө хянадаг. Дараах нь Promise IDERAID хянагчийг ашиглах тохиргооны товч тайлбар юм. Энэ карт суулгагдаж систем эхлэх үед мэдээллийг хүсэх мөрийг харуулна. Картны тохиргооны дэлгэц уруу орохын тулд заавруудыг дагана. Эндээс залгагдсан бүх хөтчүүдийг нэгтгэх боломж танд байх болно. Ингэж хийснийхээ дараа диск(нүүд) нь FreeBSD-д нэг хөтөч шиг харагдах болно. Бусад RAID түвшингүүдийг бас тохируулж болно. 

=== ATA RAID1 массивуудыг дахин бүтээх нь

FreeBSD нь массив дахь гэмтсэн, ажиллагаагүй болсон дискийг шууд солих боломжийг олгодог. Энэ нь дахин ачаалахаасаа өмнө таныг ийм асуудлыг мэдэхийг шаарддаг.

Та магадгүй доор дурдсантай адилыг [.filename]#/var/log/messages# эсвэл man:dmesg[8] гаралт дээр харж болох юм:

[.programlisting]
....
ad6 on monster1 suffered a hard error.
ad6: READ command timeout tag=0 serv=0 - resetting
ad6: trying fallback to PIO mode
ata3: resetting devices .. done
ad6: hard error reading fsbn 1116119 of 0-7 (ad6 bn 1116119; cn 1107 tn 4 sn 11)\\
status=59 error=40
ar0: WARNING - mirror lost
....

man:atacontrol[8] ашиглан дэлгэрэнгүй мэдээллийг шалгана:

[source,bash]
....
# atacontrol list
ATA channel 0:
	Master:      no device present
	Slave:   acd0 <HL-DT-ST CD-ROM GCR-8520B/1.00> ATA/ATAPI rev 0

ATA channel 1:
	Master:      no device present
	Slave:       no device present

ATA channel 2:
	Master:  ad4 <MAXTOR 6L080J4/A93.0500> ATA/ATAPI rev 5
	Slave:       no device present

ATA channel 3:
	Master:  ad6 <MAXTOR 6L080J4/A93.0500> ATA/ATAPI rev 5
	Slave:       no device present

# atacontrol status ar0
ar0: ATA RAID1 subdisks: ad4 ad6 status: DEGRADED
....

[.procedure]
====

. Та дискийг аюулгүйгээр салган авахын тулд эхлээд ata сувгийг ажиллахгүй байгаа дисктэй цуг салгана:
+
[source,bash]
....
# atacontrol detach ata3
....
+
. Дискийг сольно.
. ata сувгийг дахин залгана:
+
[source,bash]
....
# atacontrol attach ata3
Master:  ad6 <MAXTOR 6L080J4/A93.0500> ATA/ATAPI rev 5
Slave:   no device present
....
+
. Шинэ дискийг массивт нөөц маягаар нэмнэ:
+
[source,bash]
....
# atacontrol addspare ar0 ad6
....
+
. Массивыг дахин бүтээнэ:
+
[source,bash]
....
# atacontrol rebuild ar0
....
+
. Дараах тушаалыг ашиглаж үйл явцыг шалгаж болно:
+
[source,bash]
....
# dmesg | tail -10
[output removed]
ad6: removed from configuration
ad6: deleted from ar0 disk1
ad6: inserted into ar0 disk1 as spare

# atacontrol status ar0
ar0: ATA RAID1 subdisks: ad4 ad6 status: REBUILDING 0% completed
....
+
. Энэ үйлдэл хийгдэж дуустал хүлээх хэрэгтэй.
====

[[usb-disks]]
== USB хадгалалтын төхөөрөмжүүд

Одоо үед маш олон гадаад хадгалалтын шийдлүүд байгаа бөгөөд Universal Serial Bus (USB): хатуу хөтчүүд, USB хуруун хөтчүүд, CD-R шарагчид зэргийг ашигладаг. FreeBSD нь эдгээр төхөөрөмжүүдийн дэмжлэгийг хангадаг.

=== Тохиргоо

USB бөөн хадгалалтын төхөөрөмжүүдийн драйвер man:umass[4] нь USB хадгалалтын төхөөрөмжүүдийн дэмжлэгийг хангадаг. Хэрэв та [.filename]#GENERIC# цөм ашиглавал өөрийн тохиргоондоо юу ч өөрчлөх шаардлагагүй. Хэрэв та өөрчлөн тохируулсан цөм ашиглах бол таны цөмийн тохиргооны файлд дараах мөрүүд байгаа эсэхийг шалгаарай:

[.programlisting]
....
device scbus
device da
device pass
device uhci
device ohci
device ehci
device usb
device umass
....

man:umass[4] драйвер нь USB хадгалалтын төхөөрөмжүүдэд хандахын тулд SCSI дэд системийг хэрэглэдэг бөгөөд таны USB төхөөрөмж системд SCSI төхөөрөмж маягаар харагдах болно. Таны эх хавтан дээрх USB бичил схемээс хамаарч USB 1.X-ийн дэмжлэгийн хувьд танд зөвхөн `device uhci` эсвэл `device ohci` хоёрын аль нэг хэрэгтэй болно, гэхдээ хоёуланг нь цөмийн тохиргоондоо байлгах нь гэмгүй юм. USB 2.0 хянагчуудад зориулсан дэмжлэгийг man:ehci[4] драйвер (`device ehci` мөр) хангадаг. Хэрэв та ямар нэг мөр нэмсэн бол шинэ цөмөө эмхэтгэж суулгахаа битгий мартаарай.

[NOTE]
====
Хэрэв таны USB төхөөрөмж чинь CD-R эсвэл DVD шарагч бол SCSI CD-ROM драйвер man:cd[4]-г цөмд дараах мөрийн тусламжтай нэмэх ёстой:

[.programlisting]
....
device cd
....

Шарагч нь SCSI хөтөч гэж харагддаг учир man:atapicam[4] драйверийг цөмийн тохиргоонд ашиглах ёсгүй.
====

=== Тохиргоог тест хийх нь

Тохиргоог тест хийхэд бэлэн боллоо: өөрийн USB төхөөрөмжийг залгахад системийн мэдэгдлийн буферт (man:dmesg[8]) хөтөч нь иймэрхүү харагдах ёстой:

[source,bash]
....
umass0: USB Solid state disk, rev 1.10/1.00, addr 2
GEOM: create disk da0 dp=0xc2d74850
da0 at umass-sim0 bus 0 target 0 lun 0
da0: <Generic Traveling Disk 1.11> Removable Direct Access SCSI-2 device
da0: 1.000MB/s transfers
da0: 126MB (258048 512 byte sectors: 64H 32S/T 126C)
....

Мэдээж хэрэг үйлдвэрлэгч, төхөөрөмжийн цэг ([.filename]#da0#) болон бусад зүйлс таны тохиргооноос хамаараад өөр байж болно.

USB төхөөрөмж нь SCSI төхөөрөмж гэж харагддаг болохоор `camcontrol` тушаалыг ашиглаж системд холбогдсон USB хадгалалтын төхөөрөмжүүдийн жагсаалтыг харуулж болно:

[source,bash]
....
# camcontrol devlist
<Generic Traveling Disk 1.11>      at scbus0 target 0 lun 0 (da0,pass0)
....

Хэрэв хөтөч нь файлын системтэй ирвэл та түүнийг холбож чадна. <<disks-adding>> хэсэг нь хэрэв шаардлагатай бол USB хөтчийг хэлбэршүүлж түүн дээр хуваалт үүсгэхэд танд туслах болно.

[WARNING]
====

Дурын төхөөрөмжийг итгэлгүй хэрэглэгчдэд холбох боломжийг олгох нь өөрөөр хэлбэл `vfs.usermount`-ийг доор тайлбарласнаар идэвхжүүлэх нь аюулгүй байдлын үүднээс авч үзвэл аюултай юм. FreeBSD дээрх ихэнх файлын систем нь хортой төхөөрөмжийн эсрэг хамгаалалтгүй байдаг.
====

Энэ төхөөрөмжийг энгийн хэрэглэгч холбож чаддагаар болгохын тулд тодорхой алхмуудыг хийх хэрэгтэй. Эхлээд USB хадгалалтын төхөөрөмж холбогдсон үед үүссэн төхөөрөмжүүдэд хэрэглэгч хандаж болохоор байх хэрэгтэй. Үүний шийдэл нь эдгээр төхөөрөмжүүдийн бүх хэрэглэгчдийг `operator` бүлгийн гишүүн болгох явдал юм. Үүнийг man:pw[8]-ээр хийнэ. Хоёрдугаарт төхөөрөмжүүд нь үүсэх үед `operator` бүлэг тэдгээрийг уншиж бичиж чадаж байх ёстой. Тохирох мөрүүдийг [.filename]#/etc/devfs.rules# файлд нэмснээр үүнийг хийж болно:

[.programlisting]
....
[localrules=5]
add path 'da*' mode 0660 group operator
....

[NOTE]
====
Хэрэв системд SCSI дискнүүд байгаа бол үүнийг арай өөрөөр хийх ёстой. Өөрөөр хэлбэл хэрэв систем нь аль хэдийн [.filename]#da0#-ээс [.filename]#da2# хүртэлх холбогдсон дискнүүдийг агуулж байвал хоёр дахь мөрийг дараах маягаар солих хэрэгтэй:

[.programlisting]
....
add path 'da[3-9]*' mode 0660 group operator
....

Энэ нь байгаа дискнүүдийг `operator` бүлэгт хамааруулахгүй болгоно.
====

Та бас өөрийн man:devfs.rules[5] дүрмийн олонлогийг [.filename]#/etc/rc.conf# файлд идэвхжүүлэх хэрэгтэй:

[.programlisting]
....
devfs_system_ruleset="localrules"
....

Дараа нь цөм нь ердийн хэрэглэгчдэд файлын системийг холбох боломжтойгоор тохируулагдах ёстой. Хамгийн хялбар арга бол [.filename]#/etc/sysctl.conf#-д мөр нэмэх явдал юм:

[.programlisting]
....
vfs.usermount=1
....

Дараагийн дахин ачаалалтын дараа энэ нь идэвхжихийг санаарай. Өөрөөр энэ хувьсагчийг тохируулахын тулд man:sysctl[8]-г ашиглаж болох юм.

Төгсгөлийн алхам нь файлын систем холбогдох санг үүсгэх явдал юм. Энэ санг файлын системийг холбох хэрэглэгч эзэмшсэн байх хэрэгтэй. Үүнийг хийх нэг арга нь `root`-ийн хувьд тэр хэрэглэгчийн эзэмшсэн дэд санг [.filename]#/mnt/username# (_username_-г тухайн хэрэглэгчийнхээ нэвтрэх нэрээр болон _usergroup_-г хэрэглэгчийнхээ үндсэн бүлгийн нэрээр солиорой) гэж үүсгэх явдал юм:

[source,bash]
....
# mkdir /mnt/username
# chown username:usergroup /mnt/username
....

USB хуруун хөтөч залгагдаж [.filename]#/dev/da0s1# төхөөрөмж гарч иржээ гэж бодъё. Эдгээр төхөөрөмжүүд нь ихэвчлэн FAT файлын системээр хэлбэршүүлэгдсэн ирдэг бөгөөд эдгээрийг иймэрхүү маягаар холбож болно:

[source,bash]
....
% mount -t msdosfs -m=644 -M=755 /dev/da0s1 /mnt/username
....

Хэрэв та төхөөрөмжийг залгаснаа салгавал (дискийг урьдаар салгах ёстой) та системийн мэдэгдлийн буфераас доор дурдсантай төстэй мэдэгдлийг харах ёстой:

[source,bash]
....
umass0: at uhub0 port 1 (addr 2) disconnected
(da0:umass-sim0:0:0:0): lost device
(da0:umass-sim0:0:0:0): removing device entry
GEOM: destroy disk da0 dp=0xc2d74850
umass0: detached
....

=== Нэмэлт унших материалууд

<<disks-adding,Диск нэмэх>> болон crossref:basics[mount-unmount,Файлын системүүдийг холбох болон салгах] хэсгүүдээс гадна төрөл бүрийн гарын авлагын хуудаснуудыг унших нь хэрэгтэй байж болох юм: FreeBSD 8.X-ийн хувьд man:umass[4], man:camcontrol[8], болон man:usbconfig[8] эсвэл FreeBSD-ийн өмнөх хувилбаруудын хувьд man:usbdevs[8] байна.

[[creating-cds]]
== Оптик зөөвөрлөгчийг (CD-үүд) үүсгэж ашиглах нь

=== Танилцуулга

CD-үүд нь тэдгээрийг ердийн дискнүүдээс ялгах хэд хэдэн боломжуудтай байдаг. Эхлээд хэрэглэгч CD дээр бичих боломжгүй байсан. Тэдгээр нь замуудын хооронд толгойг шилжүүлэхдээ сааталгүйгээр үргэлжлэн уншдагаар хийгджээ. Тэр үед байсан адил хэмжээтэй зөөвөрлөгчийг зөөхөөс тэдгээрийг систем хооронд зөөх нь хамаагүй хялбар байдаг.

CD-үүд нь замтай байдаг боловч энэ нь дискний физик хэсэг биш харин үргэлжлэн уншигдах өгөгдлийн хэсгийг хэлдэг. FreeBSD дээр CD үүсгэхдээ CD дээр замууд үүсгэх өгөгдлийн файлуудыг бэлдэж дараа нь замуудыг CD уруу бичнэ.

ISO 9660 файлын систем нь эдгээр ялгаануудтай ажиллахаар хийгдсэн. Энэ нь тэр үед нийтлэг байсан файлын системийн хязгааруудыг харамсалтай нь кодчилдог. Азаар энэ нь зөв бичигдсэн CD-үүдэд тэдгээр хязгааруудыг давж гарахыг зөвшөөрөх өргөтгөлөөр хангадаг бөгөөд тэдгээр өргөтгөлүүдийг дэмждэггүй системүүдтэй ажиллаж чадсан хэвээр байдаг.

package:sysutils/cdrtools[] портод ISO 9660 файлын системийг агуулах өгөгдлийн файлыг үүсгэдэг програм man:mkisofs[8] байдаг. Энэ нь төрөл бүрийн өргөтгөлүүдийг дэмждэг тохируулгуудтай бөгөөд доор тайлбарлагдсан болно.

CD шарахдаа ямар хэрэгслийг ашиглах нь таны CD шарагч ATAPI юу аль эсвэл өөр үү гэдгээс шалтгаална. ATAPI CD шарагчид нь үндсэн системийн `burncd` програмыг ашигладаг. SCSI болон USB CD шарагчид нь package:sysutils/cdrtools[] портын `cdrecord`-г ашиглах ёстой. Мөн ATAPI тоног төхөөрөмж дээр SCSI хөтчүүдийн хувьд <<atapicam,ATAPI/CAM модул>> ашиглан `cdrecord`-г хэрэглэх боломжтой байдаг.

Хэрэв та график хэрэглэгчийн интерфэйстэй CD шарагч програм хангамжийг хүсэж байгаа бол X-CD-Roast эсвэл K3b-г үзээрэй. Эдгээр хэрэгслүүд нь багц хэлбэрээр эсвэл package:sysutils/xcdroast[] болон package:sysutils/k3b[] портуудад байдаг. X-CD-Roast болон K3b нь ATAPI тоног төхөөрөмж дээр <<atapicam,ATAPI/CAM модул>>ийг шаарддаг.

[[mkisofs]]
=== mkisofs

package:sysutils/cdrtools[] портын хэсэг man:mkisofs[8] програм нь UNIX(R)-ийн файлын системийн нэрийн талбар дахь сангийн модны дүрс болох ISO 9660 файлын системийг үүсгэдэг. Хамгийн хялбар хэрэглээ нь:

[source,bash]
....
# mkisofs -o imagefile.iso /path/to/tree
....

Энэ тушаал нь _/path/to/tree_ дахь модны хуулбар ISO 9660 файлын системийг агуулах _imagefile.iso_ файлыг үүсгэх болно. Энэ процессод файлын нэрсийг ISO 9660 файлын системийн стандартын хязгаарлалтуудад багтах нэрсэд тааруулах бөгөөд ISO файлын системүүдэд байдаггүй нэрс бүхий файлуудыг оруулахгүй байх болно.

Тэдгээр хязгаарлалтуудыг давж гарах хэд хэдэн тохируулгууд байдаг. Ялангуяа `-R` тохируулга UNIX(R) системүүдэд нийтлэг байдаг Rock Ridge өргөтгөлүүдийг идэвхжүүлдэг, `-J` нь Microsoft системүүдэд хэрэглэгддэг Joilet өргөтгөлүүдийг идэвхжүүлдэг бөгөөд `-hfs` нь Mac OS(R)-д хэрэглэгддэг HFS файлын системүүдийг үүсгэхэд ашиглагддаг.

Зөвхөн FreeBSD системүүдэд ашиглагдах CD-үүдийн хувьд `-U` тохируулга бүх файлын нэрийн хязгаарлалтуудыг хаахад ашиглагдаж болно. `-R` тохируулгатай хэрэглэгдэх үед энэ нь таны эхэлсэн FreeBSD-ийн модтой ижил файлын системийн дүрсийг үүсгэдэг, гэхдээ энэ нь ISO 9660 стандартыг хэд хэдэн замаар зөрчиж болох юм.

Ердийн хэрэглээний сүүлийн тохируулга нь `-b` юм. Энэ нь ачаалагдах "El Torito" CD-г үүсгэхэд хэрэглэгдэх ачаалагдах дүрсний байрлалыг заахад ашиглагддаг. Энэ тохируулга нь CD уруу бичигдэх модны дээд хэсгийн ачаалагдах дүрс хүрэх замыг заах нэмэлт өгөгдлийг авдаг. Анхдагчаар man:mkisofs[8] нь "floppy disk emulation буюу уян дискний эмуляц" гэж нэрлэгддэг горимд ISO дүрсийг үүсгэдэг бөгөөд ачаалагдах дүрсийг яг 1200, 1440, эсвэл 2880 KB хэмжээтэй байна гэж тооцдог. FreeBSD түгээлтийн дискнүүдэд хэрэглэгддэг ачаалагч дуудагч зэрэг зарим ачаалагч дуудагчид нь эмуляц горимыг ашигладаггүй; энэ тохиолдолд `-no-emul-boot` тохируулгыг ашиглах шаардлагатай. Тэгэхээр хэрэв [.filename]#/tmp/myboot# нь ачаалагдах FreeBSD системийг [.filename]#/tmp/myboot/boot/cdboot# дэх ачаалагдах дүрстэй цуг агуулж байвал та ISO 9660 файлын системийн дүрсийг [.filename]#/tmp/bootable.iso#-д иймэрхүү маягаар үүсгэж болох юм:

[source,bash]
....
# mkisofs -R -no-emul-boot -b boot/cdboot -o /tmp/bootable.iso /tmp/myboot
....

Үүнийг хийснийхээ дараа хэрэв та цөмдөө [.filename]#md#-г тохируулсан бол файлын системийг ингэж холбож болно:

[source,bash]
....
# mdconfig -a -t vnode -f /tmp/bootable.iso -u 0
# mount -t cd9660 /dev/md0 /mnt
....

Энэ үед та [.filename]#/mnt# болон [.filename]#/tmp/myboot# нь ижил болохыг шалгаж болно.

man:mkisofs[8]-ийн ажиллагааг нарийн тааруулахын тулд та түүний бусад олон тохируулгуудыг ашиглаж болно. Ялангуяа ISO 9660-ийн байрлал болон Joilet ба HFS дискнүүдийн үүсгэлтэд өөрчлөлтүүд хийж болно. Дэлгэрэнгүйг man:mkisofs[8]-ийн гарын авлагын хуудаснаас үзнэ үү.

[[burncd]]
=== burncd

Хэрэв танд ATAPI CD шарагч байгаа бол та ISO дүрсийг CD уруу шарахдаа `burncd` тушаалыг ашиглаж болно. `burncd` нь үндсэн системийн хэсэг бөгөөд [.filename]#/usr/sbin/burncd# гэж суулгагдсан байдаг. Энэ нь цөөн тохируулгуудтай болохоор хэрэглэхэд их хялбар байдаг:

[source,bash]
....
# burncd -f cddevice data imagefile.iso fixate
....

Дээрх тушаал нь _imagefile.iso_-н хуулбарыг _cddevice_ уруу шарах болно. Анхдагч төхөөрөмж нь [.filename]#/dev/acd0# юм. Бичих хурд, шарсны дараа CD-г гаргах болон аудио өгөгдөл бичихийг заах тохируулгуудын талаар man:burncd[8]-с үзнэ үү.

[[cdrecord]]
=== cdrecord

Хэрэв танд ATAPI CD шарагч байхгүй бол та өөрийн CD-үүдийг шарахын тулд `cdrecord`-г ашиглах шаардлагатай. `cdrecord` нь үндсэн системд байдаггүй; та үүнийг package:sysutils/cdrtools[] дахь портоос эсвэл тохирох багцаас суулгах ёстой. Үндсэн системд хийгдсэн өөрчлөлт нь энэ програмын хоёртын хувилбарыг ажиллахгүй болгож, магадгүй "асуудалд (coaster)" хүргэж болох юм. Тийм болохоор та өөрийн системээ шинэчлэхдээ портоо бас шинэчлэх эсвэл хэрэв та crossref:cutting-edge[stable,-STABLE салбарыг дагаж] байгаа бол портыг шинэ хувилбар гарахад нь шинэчлэх хэрэгтэй.

`cdrecord` нь олон тохируулгатай байдаг боловч үндсэн хэрэглээ нь `burncd`-с бүр илүү хялбар байдаг. ISO 9660 дүрсийг шарахдаа:

[source,bash]
....
# cdrecord dev=device imagefile.iso
....

`cdrecord`-г хэрэглэхэд гардаг нэг заль нь `dev` тохируулгыг олох явдал юм. Зөв тохиргоог олохын тулд `cdrecord`-ийн `-scanbus` тугийг хэрэглэх хэрэгтэй бөгөөд энэ нь иймэрхүү үр дүнд хүргэж болох юм:

[source,bash]
....
# cdrecord -scanbus
Cdrecord-Clone 2.01 (i386-unknown-freebsd7.0) Copyright (C) 1995-2004 Jörg Schilling
Using libscg version 'schily-0.1'
scsibus0:
        0,0,0     0) 'SEAGATE ' 'ST39236LW       ' '0004' Disk
        0,1,0     1) 'SEAGATE ' 'ST39173W        ' '5958' Disk
        0,2,0     2) *
        0,3,0     3) 'iomega  ' 'jaz 1GB         ' 'J.86' Removable Disk
        0,4,0     4) 'NEC     ' 'CD-ROM DRIVE:466' '1.26' Removable CD-ROM
        0,5,0     5) *
        0,6,0     6) *
        0,7,0     7) *
scsibus1:
        1,0,0   100) *
        1,1,0   101) *
        1,2,0   102) *
        1,3,0   103) *
        1,4,0   104) *
        1,5,0   105) 'YAMAHA  ' 'CRW4260         ' '1.0q' Removable CD-ROM
        1,6,0   106) 'ARTEC   ' 'AM12S           ' '1.06' Scanner
        1,7,0   107) *
....

Энэ нь жагсаалтан дахь төхөөрөмжүүдийн хувьд тохирох `dev` утгыг жагсаадаг. Өөрийн CD шарагчийг олохын тулд `dev` тохируулгын утгад гурван дугаарыг таслалаар тусгаарлан хэрэглэнэ. Энэ тохиолдолд CRW төхөөрөмж нь 1,5,0, байх бөгөөд тохирох оролт нь `dev=1,5,0` болно. Энэ утгыг заах амархан аргууд байдаг; дэлгэрэнгүйг man:cdrecord[1]-с үзнэ үү. Мөн тэндээс аудио замуудыг бичих, хурдыг хянах болон бусад зүйлүүдийн тухай мэдээллийг үзэж болно.

[[duplicating-audiocds]]
=== Аудио CD-үүдийг хувилах

Та аудио өгөгдлийг CD-ээс файлуудын цуваа болгон задалж дараа нь эдгээр файлуудыг хоосон CD дээр бичин аудио CD-г хувилж болно. Энэ процесс нь ATAPI болон SCSI хөтчүүдийн хувьд нэлээн өөр байдаг.

[.procedure]
====

*Procedure: SCSI хөтчүүд*

. Аудиог `cdda2wav` ашиглан задлана.
+
[source,bash]
....
% cdda2wav -vall -D2,0 -B -Owav
....
+
. `cdrecord` ашиглан [.filename]#.wav# файлуудыг бичнэ.
+
[source,bash]
....
% cdrecord -v dev=2,0 -dao -useinfo  *.wav
....
+ 
<<cdrecord>> хэсэгт тайлбарласны дагуу _2,0_ гэж зөв заагдсан эсэхийг шалгаарай.
====

[.procedure]
====

*Procedure: ATAPI хөтчүүд*

[NOTE]
======
<<atapicam,ATAPI/CAM модулийн>> тусламжтай `cdda2wav` тушаал ATAPI хөтчүүд дээр ашиглагдаж болно. Энэ хэрэгсэл нь доор санал болгож байгаа аргыг бодвол ихэнх хэрэглэгчдийн хувьд ихэвчлэн илүүтэй сонголт байдаг (доргио засварлалт, төгсгөгчийн асуудал гэх мэт).
======

. ATAPI CD драйвер нь зам бүрийг [.filename]#/dev/acddtnn# маягаар болгодог бөгөөд _d_ нь хөтчийн дугаар ба _nn_ нь шаардлагатай бол урдаа 0 тавьж хоёр оронтой тоогоор бичигдсэн замын дугаар юм. Тэгэхээр эхний диск дээрх эхний зам нь [.filename]#/dev/acd0t01#, хоёр дахь нь [.filename]#/dev/acd0t02#, гурав дахь нь [.filename]#/dev/acd0t03# гэх мэтчилэн байна.
+ 
Тохирох файлууд [.filename]#/dev# санд байгаа эсэхийг шалгаарай. Хэрэв оруулгууд байхгүй байгаа бол зөөвөрлөгчийг дахин үзэхээр системийг хүчлэх хэрэгтэй:
+
[source,bash]
....
# dd if=/dev/acd0 of=/dev/null count=1
....
+
. Зам бүрийг man:dd[1] ашиглан задална. Файлуудыг задлахдаа та тусгай блокийн хэмжээг бас ашиглах ёстой.
+
[source,bash]
....
# dd if=/dev/acd0t01 of=track1.cdr bs=2352
# dd if=/dev/acd0t02 of=track2.cdr bs=2352
...
....
+
. Задалсан файлуудаа диск уруу `burncd` ашиглан шарна. Та эдгээрийг аудио файл гэж зааж өгөх хэрэгтэй бөгөөд `burncd` нь дуусахдаа дискийг бэхжүүлэх ёстой.
+
[source,bash]
....
# burncd -f /dev/acd0 audio track1.cdr track2.cdr ... fixate
....
====

[[imaging-cd]]
=== Өгөгдлийн CD-үүдийг хувилах

Та өгөгдлийн CD-г man:mkisofs[8]-р үүсгэсэн дүрс файлтай ажиллагааны хувьд адилхан дүрс файл уруу хуулж болох бөгөөд та үүнийг ямар ч өгөгдлийн CD хувилахад ашиглаж болно. Энд өгөгдсөн жишээ нь таны CDROM төхөөрөмжийг [.filename]#acd0# гэж үзэх болно. Өөрийн зөв CDROM төхөөрөмжөөр солиорой.

[source,bash]
....
# dd if=/dev/acd0 of=file.iso bs=2048
....

Одоо та нэгэнт дүрстэй болсон болохоор үүнийг CD уруу дээр тайлбарласны дагуу шарж болно.

[[mounting-cd]]
=== Өгөгдлийн CD-үүдийг ашиглах

Одоо та стандарт өгөгдлийн CDROM үүсгэсэн болохоор түүнийг холбож түүн дээрх өгөгдлийг уншихыг хүсэх байх. Анхдагчаар man:mount[8] нь файлын системийг `ufs` төрлийнх гэж үздэг. Хэрэв та доорх шиг оролдвол:

[source,bash]
....
# mount /dev/cd0 /mnt
....

`Incorrect super block` гэж гомдоллохыг та харах бөгөөд холболт хийгдэхгүй байх болно. CDROM нь `UFS` файлын систем биш, тэгэхээр ингэж холбохыг оролдох нь амжилтгүй болох болно. Та man:mount[8]-д файлын системийн төрөл нь `ISO9660` гэж зааж өгөхөд л бүгд ажиллах болно. Та `-t cd9660` тохируулгыг man:mount[8]-д өгч үүнийг хийнэ. Жишээ нь хэрэв та CDROM төхөөрөмж [.filename]#/dev/cd0#-г [.filename]#/mnt#-д холбохыг хүсвэл дараах тушаалыг ажиллуулах болно:

[source,bash]
....
# mount -t cd9660 /dev/cd0 /mnt
....

Таны төхөөрөмжийн нэр (энэ жишээн дээр [.filename]#/dev/cd0#) таны CDROM ямар интерфэйс ашиглаж байгаагаас хамааран өөр байж болох юм. Мөн `-t cd9660` тохируулга нь ердөө л man:mount_cd9660[8]-г ажиллуулдаг. Дээрх жишээг ингэж богиносгож болно:

[source,bash]
....
# mount_cd9660 /dev/cd0 /mnt
....

Та ерөнхийдөө энэ аргаар ямар ч үйлдвэрлэгчийн өгөгдлийн CDROM-уудыг ашиглаж болно. Гэхдээ зарим нэг ISO 9660 өргөтгөлүүдтэй дискнүүд хачин ажиллаж болох юм. Жишээ нь Joilet дискнүүд нь бүх файлын нэрсийг хоёр байт Юникод тэмдэгтээр хадгалдаг. FreeBSD цөм нь Юникодоор ярьдаггүй, гэхдээ FreeBSD-ийн CD9660 драйвер Юникод тэмдэгтүүдийг шууд хувиргаж чаддаг. Хэрэв зарим нэг Англи бус тэмдэгтүүд асуултын тэмдэг хэлбэрээр харагдвал та ашиглаж байгаа локал тэмдэгтийн олонлогоо `-C` тохируулгаар зааж өгөх хэрэгтэй. Дэлгэрэнгүй мэдээллийг man:mount_cd9660[8] гарын авлагын хуудаснаас лавлана уу.

[NOTE]
====
Энэ тэмдэгтийн хувиргалтыг `-C` тохируулгын тусламжтай хийхийн тулд цөм [.filename]#cd9660_iconv.ko# модулийг дуудсан байхыг шаардах болно. Энэ мөрийг [.filename]#loader.conf# файлд нэмж үүнийг:

[.programlisting]
....
cd9660_iconv_load="YES"
....

гэж хийн машиныг дахин ачаалах буюу эсвэл модулийг man:kldload[8]-н тусламжтай дуудан хийж болох юм.
====

Хааяа таныг CDROM-г холбохыг оролдох үед `Device not configured` гэсэн алдаа гарч болох юм. Энэ нь ихэнхдээ CDROM хөтөч нь төхөөрөмжид диск байхгүй эсвэл хөтөч нь шугаманд (bus) харагдахгүй байна гэж үзэж байна гэсэн үг юм. CDROM хөтөч нь хоёр секундын дотор үүнийг мэддэг болохоор тэвчээртэй байгаарай.

Шугамын дахин тогтоолтод хариу өгөх хангалттай хугацаа байхгүйн улмаас заримдаа SCSI CDROM-ийг олохгүй байж болох юм. Хэрэв та SCSI CDROM-той бол та дараах тохируулгыг цөмийн тохиргоондоо нэмж crossref:kernelconfig[kernelconfig-building,өөрийн цөмийг дахин бүтээнэ үү].

[.programlisting]
....
options SCSI_DELAY=15000
....

Энэ нь таны SCSI шугамд ачаалах үедээ 15 секунд түр саатахыг хэлж өгөх бөгөөд ингэснээр шугамын дахин тогтоолтод таны CDROM хөтчөөр хариу өгүүлэхийн тулд бүх байж болох боломжийг түүнд өгч байна гэсэн үг юм.

[[rawdata-cd]]
=== Түүхий өгөгдлийн CD-үүдийг шарах

Та ISO 9660 файлын системийг үүсгэлгүйгээр файлыг CD уруу шууд шарахаар сонгож болно. Зарим хүмүүс үүнийг нөөцлөх зорилгоор хийдэг. Энэ нь стандарт CD-г шарахаас илүү хурдан ажилладаг:

[source,bash]
....
# burncd -f /dev/acd1 -s 12 data archive.tar.gz fixate
....

Тийм CD-д шарагдсан өгөгдлийг авахын тулд та түүхий төхөөрөмжийн цэгээс өгөгдлийг унших ёстой:

[source,bash]
....
# tar xzvf /dev/acd1
....

Та энэ дискийг ердийн CDROM-ийг холбодог шиг холбож чадахгүй. Ийм CDROM нь FreeBSD-ээс өөр ямар ч үйлдлийн систем дээр уншигдахгүй. Хэрэв та CD-гээ холбохыг эсвэл өөр үйлдлийн системтэй өгөгдлөө хуваалцах хүсэлтэй байгаа бол дээр тайлбарласны дагуу man:mkisofs[8]-г ашиглах ёстой.

[[atapicam]]
=== ATAPI/CAM драйверийг ашиглах

Энэ драйвер нь ATAPI төхөөрөмжүүдэд (CD-ROM, CD-RW, DVD хөтчүүд гэх мэт...) SCSI дэд системээр хандах боломжийг олгох бөгөөд ингэснээр package:sysutils/cdrdao[] эсвэл man:cdrecord[1] зэрэг програмуудыг ашиглах боломжийг олгодог.

Энэ драйверыг ашиглахын тулд та дараах мөрийг [.filename]#/boot/loader.conf# файл уруу нэмэх хэрэгтэй болно:

[.programlisting]
....
atapicam_load="YES"
....

тэгээд өөрийн машинаа дахин ачаална.

[NOTE]
====
Хэрэв та өөрийн цөмдөө man:atapicam[4] дэмжлэгийг статикаар эмхэтгэхийг хүсвэл энэ мөрийг өөрийн цөмийн тохиргооны файлдаа нэмэх хэрэгтэй болно:

[.programlisting]
....
device atapicam
....

Мөн та өөрийн цөмийн тохиргооны файлдаа дараах мөрүүдийг бас нэмэх хэрэгтэй болно:

[.programlisting]
....
device ata
device scbus
device cd
device pass
....

Эдгээр нь аль хэдийн байж байх ёстой. Дараа нь дахин бүтээгээд өөрийн цөмийг суулгаж машинаа дахин ачаалах хэрэгтэй.
====

Ачаалах процессийн үед таны шарагч иймэрхүү маягаар гарч ирэх ёстой:

[source,bash]
....
acd0: CD-RW <MATSHITA CD-RW/DVD-ROM UJDA740> at ata1-master PIO4
cd0 at ata1 bus 0 target 0 lun 0
cd0: <MATSHITA CDRW/DVD UJDA740 1.00> Removable CD-ROM SCSI-0 device
cd0: 16.000MB/s transfers
cd0: Attempt to query device size failed: NOT READY, Medium not present - tray closed
....

Одоо хөтчид [.filename]#/dev/cd0# төхөрөөмжийн нэрийг ашиглан хандаж болох бөгөөд жишээ нь CD-ROM-г [.filename]#/mnt#-д холбохдоо дараах тушаалыг бичих хэрэгтэй:

[source,bash]
....
# mount -t cd9660 /dev/cd0 /mnt
....

`root` хэрэглэгчээр дараах тушаалыг ажиллуулж та шарагчийн SCSI хаягийг авч болно:

[source,bash]
....
# camcontrol devlist
<MATSHITA CDRW/DVD UJDA740 1.00>   at scbus1 target 0 lun 0 (pass0,cd0)
....

Тэгэхээр `1,0,0` нь man:cdrecord[1] болон бусад SCSI програмтай ашиглах SCSI хаяг болох юм.

ATAPI/CAM болон SCSI системийн талаар дэлгэрэнгүй мэдээллийг man:atapicam[4] болон man:cam[4] гарын авлагын хуудаснуудаас лавлана уу.

[[creating-dvds]]
== Оптик зөөвөрлөгчийг (DVD-үүд) үүсгэж ашиглах нь

=== Танилцуулга

CD-тэй харьцуулахад DVD нь оптик зөөвөрлөгч хадгалалтын технологийн дараачийн үе юм. DVD нь ямар ч CD-ээс илүү өгөгдлийг агуулдаг бөгөөд одоогийн видео хэвлэлтийн стандарт болжээ.

Бичигддэг DVD гэж бидний нэрлэдэг DVD-үүдийн физик 5 бичигддэг хэлбэршүүлэлтийг тодорхойлж болно:

* DVD-R: Энэ нь бичигддэг DVD-ий анхны хэлбэршүүлэлт юм. DVD-R стандарт нь http://www.dvdforum.com/forum.shtml[DVD хэлэлцүүлгээр] тодорхойлогдсон бөгөөд энэ нь зөвхөн нэг удаа бичих хэлбэршүүлэлт юм.
* DVD-RW: Энэ нь DVD-R стандартын дахин бичигдэх хувилбар юм. DVD-RW нь ойролцоогоор 1000 удаа бичигдэх боломжтой.
* DVD-RAM: Энэ нь DVD хэлэлцүүлгийн дэмждэг бас дахин бичигддэг хэлбэршүүлэлт юм. DVD-RAM нь зөөгдөж болох хатуу хөтөч маягаар харагддаг. Гэхдээ энэ зөөвөрлөгч нь ихэнх DVD-ROM хөтчүүд болон DVD-Видео тоглуулагчуудтай нийцтэй биш байдаг; цөөн DVD бичигчид DVD-RAM хэлбэршүүлэлтийг дэмждэг. DVD-RAM-ийн хэрэглээний талаар илүү дэлгэрэнгүйг <<creating-dvd-ram>>-с уншина уу.
* DVD+RW: Энэ нь http://www.dvdrw.com/[DVD+RW холбооноос] тодорхойлсон дахин бичигдэх хэлбэршүүлэлт юм. DVD+RW нь ойролцоогоор 1000 удаа бичигдэх боломжтой.
* DVD+R: Энэ хэлбэршүүлэлт нь DVD+RW хэлбэршүүлэлтийн нэг удаа бичих хувилбар юм.

Бичигддэг DVD-ий нэг давхарга нь 4,700,000,000 байт буюу 4.38 GB эсвэл 4485 MB (1 килобайт нь 1024 байт) хүртэлх мэдээлэл агуулж чадна.

[NOTE]
====
Физик зөөвөрлөгч болон програмыг ялгаж ойлгох ёстой. Жишээ нь DVD-Видео нь дурын бичигддэг DVD физик зөөвөрлөгч DVD-R, DVD+R, DVD-RW гэх зэрэг уруу бичигдэж болох тусгай байршлын зураглал юм. Зөөвөрлөгчийн төрлийг сонгохын өмнө шарагч болон DVD-Видео тоглуулагч (дан тоглуулагч эсвэл компьютер дээрх DVD-ROM хөтөч) нь хэрэглэхээр төлөвлөж байгаа зөөвөрлөгчтэй нийцтэй эсэхийг шалгах хэрэгтэй.
====

=== Тохиргоо

DVD бичлэг хийхэд man:growisofs[1] програм ашиглагдана. Энэ тушаал нь dvd+rw-tools хэрэгслүүдийн (package:sysutils/dvd+rw-tools[]) нэг хэсэг юм. dvd+rw-tools нь DVD зөөвөрлөгчийн бүх төрлийг дэмждэг.

Эдгээр хэрэгслүүд нь төхөөрөмжүүд уруу хандахын тулд SCSI дэд системийг ашигладаг, тиймээс таны цөмд <<atapicam,ATAPI/CAM дэмжлэг>> нэмэгдсэн байх ёстой. Хэрэв таны шарагч USB интерфэйс ашигладаг бол энэ нэмэлт нь хэрэггүй бөгөөд та USB төхөөрөмжүүдийн тохиргооны талаар илүү дэлгэрэнгүйг <<usb-disks>>-с унших шаардлагатай.

Та мөн ATAPI төхөөрөмжүүдийн хувьд DMA хандалтыг идэвхжүүлэх ёстой бөгөөд дараах мөрийг [.filename]#/boot/loader.conf# файлд нэмж үүнийг хийнэ:

[.programlisting]
....
hw.ata.atapi_dma="1"
....

dvd+rw-tools-г ашиглахаасаа өмнө өөрийн DVD шарагчтай холбоотой мэдээллийг http://fy.chalmers.se/~appro/linux/DVD+RW/hcn.html[dvd+rw-tools' тоног төхөөрөмжийн нийцтэй байдал] хаягаас лавлах хэрэгтэй.

[NOTE]
====
Хэрэв та график хэрэглэгчийн интерфэйсийг хүсэж байвал man:growisofs[1] болон бусад олон шарагч хэрэгслүүдийг хэрэглэгчид ашиглахад амар интерфэйсээр хангадаг K3b (package:sysutils/k3b[]) програмыг үзэх хэрэгтэй.
====

=== Өгөгдлийн DVD-үүдийг шарах нь

man:growisofs[1] тушаал нь <<mkisofs,mkisofs>>-ийн нүүр хэсэг юм, энэ нь шинэ файлын системийн байршлыг үүсгэхийн тулд man:mkisofs[8]-г дуудах бөгөөд DVD дээр бичих үйлдлийг гүйцэтгэнэ. Энэ нь та шарах процессоос өмнө өгөгдлийн дүрсийг үүсгэх хэрэггүй гэсэн үг юм.

DVD+R эсвэл DVD-R уруу өгөгдлийг [.filename]#/path/to/data# сангаас шарахдаа дараах тушаалыг ашиглана:

[source,bash]
....
# growisofs -dvd-compat -Z /dev/cd0 -J -R /path/to/data
....

Файлын системийг үүсгэхдээ `-J -R` тохируулгуудыг man:mkisofs[8]-д дамжуулдаг (энэ тохиолдолд Joilet болон Rock Ridge өргөтгөлүүдтэй ISO 9660 файлын систем). Дэлгэрэнгүйг man:mkisofs[8] гарын авлагын хуудаснаас лавлана уу.

`-Z` тохируулгыг ямар ч тохиолдолд (олон сессүүд эсвэл ганц сесс) эхний сессийг бичихдээ хэрэглэдэг. DVD төхөөрөмж _/dev/cd0_-г өөрийн тохиргооны дагуу өөрчлөх хэрэгтэй. `-dvd-compat` параметр дискийг хаах бөгөөд бичилтийг нэмэх нь боломжгүй болох юм. Энэ нь DVD-ROM хөтчүүдтэй зөөвөрлөгчийн нийцтэй байдлыг илүүтэй хангах юм.

Мөн урьдчилан урласан дүрсийг шарах бас боломжтой, жишээ нь _imagefile.iso_ дүрсийг шарахын тулд бид дараах тушаалыг ажиллуулна:

[source,bash]
....
# growisofs -dvd-compat -Z /dev/cd0=imagefile.iso
....

Бичих хурдыг олж зөөвөрлөгч ба ашиглагдаж байгаа хөтчөөс хамаарч автоматаар тохируулах болно. Хэрэв та бичих хурдыг өөрчлөх хүсэлтэй байгаа бол `-speed=` параметрийг ашиглах хэрэгтэй. Дэлгэрэнгүй мэдээллийг man:growisofs[1] гарын авлагын хуудаснаас уншина уу.

[NOTE]
====
Та өөртөө 4.38GB-аас их хэмжээтэй, ажиллагаатай файлтай болохын тулд man:mkisofs[8] болон бусад бүх програмд (жишээ нь man:growisofs[1]) `-udf -iso-level 3` гэсэн сонголтыг өгч UDF/ISO-9660 гибрид файлын системийг үүсгэсэн байх шаардлагатай. Энэ нь зөвхөн файлыг шууд диск рүү бичих эсвэл ISO дүрс файлыг үүсгэхэд л шаардлагатай. Энэ замаар үүсгэсэн дискийг зөвхөн UDF-г дэмждэг үйлдлийн системд ашиглагдах боломжтой байхаар man:mount_udf[8] хэрэгслийн тусламжтайгаар UDF файлын систем маягаар холбох ёстой бөгөөд тэгэхгүй бол энэ нь эвдэрсэн файлуудтай юм шиг харагдах болно.

Ийм ISO дүрс үүсгэхийн тулд:

[source,bash]
....
% mkisofs -R -J -udf -iso-level 3 -o imagefile.iso /path/to/data
....

Диск рүү файлуудыг шууд бичихийн тулд:

[source,bash]
....
# growisofs -dvd-compat -udf -iso-level 3 -Z /dev/cd0 -J -R /path/to/data
....

Том файлууд аль хэдийн агуулсан ISO дүрс танд байгаа бол түүнийг диск рүү шарахад нэмэлт сонголтууд man:growisofs[1]-д шаардлагагүй.

Мөн хуучин хувилбарууд нь том файлыг дэмждэггүй учир та package:sysutils/cdrtools[] (man:mkisofs[8]-г агуулдаг) хэрэгслийн хамгийн сүүлийн хувилбартай байгаа эсэхээ шалгаарай. Хэрэв та асуудалтай тулгарвал хөгжүүлэлтийн хувилбар руу шилжээрэй, өөрөөр хэлбэл package:sysutils/cdrtools-devel[] рүү шилжээд man:mkisofs[8]-ийн гаран авлагын хуудсыг уншаарай.
====

=== DVD-Видео шарах нь

DVD-Видео нь ISO 9660 болон микро-UDF (M-UDF тодорхойлолтууд дээр тулгуурласан тусгай файлын байршлын зураглал юм. DVD-Видео нь бас өгөгдлийн бүтцийн тусгай шатлалыг үзүүлдэг бөгөөд энэ нь DVD-г зохиохын тулд package:multimedia/dvdauthor[] зэрэг тусгай програмыг та яагаад ашиглах хэрэгтэй болдгийн шалтгаан юм.

Хэрэв танд DVD-Видео файлын системийн дүрс байгаа бол ямар ч дүрсний нэгэн адил аргаар шарах хэрэгтэй. Өмнөх хэсгийн жишээнээс үзнэ үү. Хэрэв та DVD зохиолт хийсэн бөгөөд үр дүн нь жишээ нь [.filename]#/path/to/video# санд байгаа бол DVD-Видеог шарахын тулд дараах тушаалыг ашиглах хэрэгтэй:

[source,bash]
....
# growisofs -Z /dev/cd0 -dvd-video /path/to/video
....

`-dvd-video` тохируулга man:mkisofs[8]-д дамжуулагдах бөгөөд энэ нь DVD-Видео файлын системийн байршлын зураглал үүсгэхийг тушаах болно. Үүнээс гадна `-dvd-video` тохируулга нь man:growisofs[1]-ийн `-dvd-compat` тохируулгыг агуулдаг.

=== DVD+RW ашиглах нь

CD-RW-с ялгаатай нь шинэ DVD+RW нь ашиглагдахаа өмнө хэлбэршүүлэгдсэн байх ёстой. man:growisofs[1] нь шаардлагатай үед автоматаар үүнийг хийх бөгөөд энэ аргыг _зөвлөдөг_ юм. Гэхдээ та `dvd+rw-format` тушаалыг ашиглан DVD+RW-г хэлбэршүүлж болно:

[source,bash]
....
# dvd+rw-format /dev/cd0
....

Та энэ үйлдлийг зөвхөн нэг удаа хийх хэрэгтэй бөгөөд зөвхөн шинэ DVD+RW зөөвөрлөгчдийн хувьд хэлбэршүүлэх ёстойг санаарай. Дараа нь та DVD+RW-г дээрх хэсгүүдэд дурдсаны адил шарж болно.

Хэрэв та шинэ өгөгдлийг (зарим өгөгдлийг нэмэх биш бүр мөсөн шинэ файлын систем шарах) DVD+RW уруу шарахыг хүсэж байгаа бол түүнийг хоосон болгох шаардлагагүй юм, иймэрхүүгээр өмнөх бичилтэн дээрээ (шинэ сесс үүсгээд) дараад л бичих хэрэгтэй юм:

[source,bash]
....
# growisofs -Z /dev/cd0 -J -R /path/to/newdata
....

DVD+RW хэлбэршүүлэлт нь өмнөх бичилтэд өгөгдлийг хялбараар нэмэх боломжийг олгодог. Энэ үйлдэл нь шинэ сессийг хуучин байгаатай нь нийлүүлэх бөгөөд энэ нь олон сесс бүхий бичилт биш юм. man:growisofs[1] нь зөөвөрлөгч дээр байгаа ISO 9660 файлын системийг _өсгөх (сунгах)_ болно.

Жишээ нь хэрэв бид өөрсдийн урьдны DVD+RW уруу өгөгдөл нэмэхийг хүсвэл доор дурдсаныг ашиглах хэрэгтэй болно:

[source,bash]
....
# growisofs -M /dev/cd0 -J -R /path/to/nextdata
....

Эхний сессийг шарахдаа бидний хэрэглэдэг man:mkisofs[8]-ийн адил тохируулгууд дараагийн бичилтүүдийн үеэр хэрэглэгдэх ёстой.

[NOTE]
====
Хэрэв та DVD-ROM хөтчүүдтэй зөөвөрлөгчийн хувьд илүүтэй нийцтэй байхыг хүсвэл `-dvd-compat` тохируулгыг хэрэглэхийг хүсэж болох юм. DVD+RW тохиолдлын хувьд энэ нь таныг өгөгдөл нэмэхийг болиулж чадахгүй юм.
====

Хэрэв та ямар нэг шалтгаанаар зөөвөрлөгчийг хоосон болгохыг хүсвэл доор дурдсаныг хийх хэрэгтэй:

[source,bash]
....
# growisofs -Z /dev/cd0=/dev/zero
....

=== DVD-RW ашиглах нь

DVD-RW нь дискний хоёр хэлбэршүүлэлтийг авдаг: нэмэгдсэн дараалсан хэлбэршүүлэлт болон хязгаарлагдмал дарж бичих хэлбэршүүлэлт юм. Анхдагчаар DVD-RW дискнүүд нь дараалсан хэлбэршүүлэлтэд байдаг.

Шинэ DVD-RW нь хэлбэршүүлэлт хийгдэлгүйгээр шууд бичигдэж болдог, гэхдээ шинэ биш дараалсан хэлбэршүүлэлтэд байх DVD-RW нь шинэ эхний сесс бичигдэхээс өмнө хоосон болгогдсон байх шаардлагатай байдаг.

Дараалсан горим дахь DVD-RW-г хоослохдоо дараах тушаалыг ажиллуулна:

[source,bash]
....
# dvd+rw-format -blank=full /dev/cd0
....

[NOTE]
====
Бүр мөсөн хоослолт (`-blank=full`) 1x зөөвөрлөгч дээр нэг цаг орчим болно. Хэрэв DVD-RW нь Disk-At-Once (DAO) горимоор бичигдэх бол хурдан хоослолтыг `-blank` тохируулга ашиглан хийж болно. DVD-RW-г DAO горимд шарахын тулд дараах тушаалыг ашиглана:

[source,bash]
....
# growisofs -use-the-force-luke=dao -Z /dev/cd0=imagefile.iso
....

`-use-the-force-luke=dao` тохируулгыг шаардах ёсгүй, учир нь man:growisofs[1] нь (хурдан хоосолсон) зөөвөрлөгчийг илрүүлэхийг бага оролдож DAO бичилтийг захиалах болно.

Яг үнэндээ дурын DVD-RW-ийн хувьд хязгаарлагдмал дарж бичих горимыг ашиглах хэрэгтэй бөгөөд энэ хэлбэршүүлэлт нь анхдагч нэмэгдсэн дараалсан хэлбэршүүлэлтээс илүү уян хатан байдаг.
====

Дараалсан DVD-RW дээр өгөгдлийг бичихдээ бусад DVD хэлбэршүүлэлтийн нэгэн адил заавруудыг ашиглана:

[source,bash]
....
# growisofs -Z /dev/cd0 -J -R /path/to/data
....

Хэрэв та зарим өгөгдлийг өөрийн урьдны бичлэгт нэмэхийг хүсвэл man:growisofs[1]-ийн `-M` тохируулгыг ашиглах хэрэгтэй болно. Гэхдээ хэрэв та нэмэгдсэн дараалсан горимд байгаа DVD-RW уруу өгөгдлийг нэмэх үйлдлийг хийвэл диск дээр шинэ сесс үүсгэгдэх бөгөөд үүний үр дүн нь олон сесс бүхий диск болох юм.

DVD-RW нь хязгаарлагдмал дарж бичих хэлбэршүүлэлтэд шинэ эхний сессээс өмнө хоосон болгогдох шаардлагагүй, та ердөө л дискийг `- Z` тохируулгатай дарж бичих хэрэгтэй бөгөөд энэ нь DVD+RW тохиолдолтой төстэй юм. Мөн диск дээр бичигдсэн байгаа ISO 9660 файлын системийг DVD+RW-тэй адил аргаар `-M` тохируулгын тусламжтай өсгөж (сунгаж) бас болно. Үр дүн нь нэг сесс бүхий DVD болох юм.

DVD-RW-г хязгаарлагдмал дарж бичих хэлбэршүүлэлтэд оруулахдаа дараах тушаалыг ашиглах ёстой:

[source,bash]
....
# dvd+rw-format /dev/cd0
....

Дараалсан хэлбэршүүлэлт уруу буцааж өөрчлөхдөө дараах тушаалыг ашиглана:

[source,bash]
....
# dvd+rw-format -blank=full /dev/cd0
....

=== Олон сесс

Маш цөөн DVD-ROM хөтчүүд олон сесс бүхий DVD-үүдийг дэмждэг бөгөөд тэдгээр нь ихэнхдээ зөвхөн эхний сессийг уншдаг. DVD+R, DVD-R болон DVD-RW нь дараалсан хэлбэршүүлэлтдээ олон сессийг хүлээн авч чаддаг бөгөөд DVD+RW болон DVD-RW хязгаарлагдмал дарж бичих хэлбэршүүлэлтүүдийн хувьд олон сесс гэсэн ойлголт байдаггүй.

Дараалсан хэлбэршүүлэлтэд DVD+R, DVD-R эсвэл DVD-RW дээрх эхний (хаагдаагүй) сессийн дараа дараах тушаалыг ашиглаж дискэнд шинэ сесс үүсгэнэ:

[source,bash]
....
# growisofs -M /dev/cd0 -J -R /path/to/nextdata
....

Энэ тушаалын мөрийг DVD+RW эсвэл DVD-RW-тэй цуг ашиглан хязгаарлагдмал дарж бичих горим дээр шинэ сессийг хуучин байгаатай нийлүүлэн өгөгдлийг нэмэх болно. Үр дүн нь нэг сесс бүхий диск болох юм. Энэ нь эдгээр зөөвөрлөгчүүд дээр эхний бичилтийн дараа өгөгдөл нэмэх арга юм.

[NOTE]
====
Зөөвөрлөгч дээрх зарим зай нь сесс бүрийн хооронд сессийн төгсгөл болон эхлэлд хэрэглэгддэг. Тиймээс зөөвөрлөгчийн зайг оновчтой ашиглахын тулд их өгөгдөлтэй сессүүдийг нэмэх ёстой юм. Сессийн тоо DVD+R-ийн хувьд 154, DVD-R-ийн хувьд 2000 орчим, DVD+R хос давхаргын хувьд 127-оор хязгаарлагдана.
====

=== Дэлгэрэнгүй мэдээллийг

DVD-ийн талаар илүү мэдээллийг авахын тулд `dvd+rw-mediainfo /dev/cd0` тушаалыг хөтөч дотор диск байхад ажиллуулж болно.

dvd+rw-tools-н тухай дэлгэрэнгүй мэдээлэл нь man:growisofs[1] гарын авлагын хуудас, http://fy.chalmers.se/~appro/linux/DVD+RW/[dvd+rw-tools вэб сайт] болон http://lists.debian.org/cdwrite/[cdwrite захидлын жагсаалт]ын архивуудаас олдож болно.

[NOTE]
====
Бичигдсэн үр дүн эсвэл асуудалтай зөөвөрлөгчийн `dvd+rw-mediainfo` гаралт нь ямар ч асуудлын тайлангийн чухал хэсэг юм. Энэ гаралтгүйгээр танд туслах бараг л боломжгүй юм.
====

[[creating-dvd-ram]]
=== DVD-RAM ашиглах нь

==== Тохиргоо

DVD-RAM бичигчид нь SCSI аль эсвэл ATAPI интерфэйстэй цуг ирдэг. ATAPI төхөөрөмжүүдийн хувьд DMA хандалт идэвхтэй болсон байх ёстой, дараах мөрийг [.filename]#/boot/loader.conf# файлд нэмж үүнийг хийнэ:

[.programlisting]
....
hw.ata.atapi_dma="1"
....

==== Зөөвөрлөгчийг бэлдэх нь

Өмнө нь бүлгийн танилцуулгад дурдсанаар DVD-RAM нь зөөврийн хатуу хөтөч маягаар харагддаг. Бусад хатуу дискнүүдийн адил DVD- RAM нь ашиглагдаж эхлэхээсээ өмнө "бэлдэгдсэн" байх ёстой. Жишээн дээр дискний бүх зай стандарт UFS2 файлын системтэй ашиглагдана:

[source,bash]
....
# dd if=/dev/zero of=/dev/acd0 bs=2k count=1
# bsdlabel -Bw acd0
# newfs /dev/acd0
....

DVD төхөөрөмж [.filename]#acd0#-ийг өөрийн тохиргооны дагуу өөрчлөн ашиглах ёстой.

==== Зөөвөрлөгчийг ашиглах нь

Дээрх үйлдлүүд DVD-RAM дээр хийгдсэний дараа үүнийг энгийн хатуу хөтчийн нэгэн адил холбож болно:

[source,bash]
....
# mount /dev/acd0 /mnt
....

Үүний дараа DVD-RAM нь уншигдах бичигдэх боломжтой болно.

[[floppies]]
== Уян дискнүүдийг үүсгэж ашиглах нь

Өгөгдлийг уян дискнүүд уруу хадгалах нь заримдаа ашигтай байдаг. Жишээ нь хэн нэгэнд нь шилжүүлж болдог ямар ч хадгалалтын зөөвөрлөгч байхгүй тохиолдолд эсвэл бага хэмжээний өгөгдлийг өөр компьютер уруу зөөх хэрэгцээ гарсан үед уян диск нь хэрэг болдог.

Энэ хэсэг нь FreeBSD дээр уян дискийг хэрхэн ашиглах талаар тайлбарлах болно. Энд 3.5 инчийн DOS уян дискнүүдийг хэлбэршүүлж ашиглах талаар үндсэндээ тайлбарлах бөгөөд гэхдээ энэ ойлголт нь бусад уян дискний хэлбэршүүлэлттэй төстэй юм.

=== Уян дискнүүдийг хэлбэршүүлэх нь

==== Төхөөрөмж

Уян дискнүүдэд бусад төхөөрөмжүүдийн адил [.filename]#/dev# сан дахь оруулгуудаар ханддаг. Түүхий уян дискэнд хандахын тулд [.filename]#/dev/fdN#-г ердөө л ашиглах хэрэгтэй.

==== Хэлбэршүүлэх нь

Уян дискийг ашиглахаасаа өмнө доод түвшний хэлбэршүүүлэлт хийсэн байх хэрэгтэй. Үүнийг ихэвчлэн үйлдвэрлэгч хийдэг боловч хэлбэршүүлэлт нь зөөвөрлөгчийн бүрэн бүтэн байдлыг шалгах нэг сайн арга юм. Илүү том (эсвэл жижиг) дискний хэмжээг хүчлэн ашиглах боломжтой байдаг боловч 1440kB хэмжээнд зориулагдан ихэнх уян диск хийгдсэн байдаг.

Уян дискэнд доод түвшний хэлбэршүүлэлт хийхийн тулд та man:fdformat[1]-г ашиглах хэрэгтэй. Энэ хэрэгсэл нь төхөөрөмжийн нэрийг нэмэлт өгөгдөл маягаар оруулахыг хүлээж байдаг.

Алдааны мэдэгдлийг тэмдэглэж аваарай, учир нь эдгээр нь дискийг сайн эсвэл муу эсэхийг тодорхойлоход туслах болно.

===== Уян дискнүүдийг хэлбэршүүлэх нь

[.filename]#/dev/fdN# төхөөрөмжүүдийг ашиглан уян дискийг хэлбэршүүлэх хэрэгтэй. Шинэ 3.5 инч диск өөрийн хөтөч уруугаа хийгээд дараах тушаалыг ажиллуул:

[source,bash]
....
# /usr/sbin/fdformat -f 1440 /dev/fd0
....

=== Дискний шошго

Дискэнд доод түвшний хэлбэршүүлэлт хийсний дараа танд диск дээр шошго тавих хэрэгтэй болно. Энэ дискний шошго нь дараа нь устгагдах боловч дискний хэмжээ болон геометрийг дараа нь тодорхойлоход системд хэрэг болдог.

Шинэ дискний шошго нь бүхэл дискийг хамарч уян дискний геометрийн тухай бүх л зөв мэдээллийг агуулах болно. Дискний шошгоны геометрийн утгууд нь [.filename]#/etc/disktab# файлд жагсаагдсан байдаг.

Та одоо ингэж man:bsdlabel[8]-г ажиллуулж болно:

[source,bash]
....
# /sbin/bsdlabel -B -w /dev/fd0 fd1440
....

=== Файлын систем

Одоо уян дискэнд дээд түвшний хэлбэршүүлэлт хийхэд бэлэн боллоо. Энэ нь дискийг FreeBSD унших болон түүнд бичих боломжийг олгох шинэ файлын системийг диск дээр байрлуулах болно. Шинэ файлын системийг үүсгэсний дараа дискний шошго устгагдах бөгөөд хэрэв та дискийг дахин хэлбэршүүлэхийг хүсвэл дискний шошгыг дахин үүсгэх шаардлагатай болно.

Уян дискний файлын систем нь UFS эсвэл FAT хоёрын аль нэг нь байна. FAT нь ерөнхийдөө уян дискнүүдийн хувьд илүү дээр сонголт байдаг.

Уян диск дээр шинэ файлын системийг байрлуулахын талд дараах тушаалыг ажиллуулна:

[source,bash]
....
# /sbin/newfs_msdos /dev/fd0
....

Диск одоо ашиглахад бэлэн боллоо.

=== Уян дискийг ашиглах нь

Уян дискийг ашиглахын тулд man:mount_msdosfs[8] тушаалаар холбох хэрэгтэй. Мөн портын цуглуулгаас package:emulators/mtools[]-г ашиглаж бас болох юм.

[[backups-tapebackups]]
== Өгөгдлийн соронзон хальснууд үүсгэж ашиглах нь

Гол соронзон хальс зөөвөрлөгчүүд нь 4мм, 8мм, QIC, мини-хайрцаг болон DLT юм.

[[backups-tapebackups-4mm]]
=== 4мм (DDS: Digital Data Storage)

4мм соронзон хальснууд нь QIC-г халж ажлын станцын нөөц зөөвөрлөгч болон сонгогдож байна. Conner компани нь QIC хөтчүүдийн тэргүүлэх үйлдвэрлэгч Archive-г худалдаж авч дараа нь QIC хөтчүүдийг үйлдвэрлэхээ зогсоосноор энэ чиг хандлага нь илүү хурдассан юм. 4мм хөтчүүд нь жижиг, чимээгүй боловч 8мм хөтчүүд шиг найдвартай ажиллагаагаараа алдартай биш юм. Хайрцагнууд нь үнэтэй биш бөгөөд 8мм-ийн хайрцагнуудаас бага (3 x 2 x 0.5 инч, 76 x 51 x 12 мм) юм. 4мм соронзон хальс нь 8мм-ийн нэгэн адил шалтгаанаар толгой нь богино настай бөгөөд хоёулаа мушгиа сканыг ашигладаг.

Эдгээр хөтчүүд дээрх өгөгдлийн дамжуулах чадвар нь ~150 kB/s-с эхэлж ~500 kB/s хүрнэ. Өгөгдлийн багтаамж 1.3 GB-с эхэлж 2.0 GB хүрнэ. Тоног төхөөрөмжийн шахалт энэ хөтчүүдийн ихэнхэд байх бөгөөд энэ нь багтаамжийг ойролцоогоор хоёр дахин нэмэгдүүлдэг. Олон хөтөч бүхий соронзон хальсны сан (library) автомат соронзон хальс солигчтой нэг кабинетийн хувьд 6 хөтөчтэй байж болно. Сангийн багтаамж нь 240 GB хүрнэ.

DDS-3 стандарт нь одоогоор 12 GB (эсвэл 24 GB шахагдсан) багтаамжтай соронзон хальсыг дэмждэг.

4мм хөтчүүд нь 8мм-ийн хөтчүүдийн нэгэн адил мушгиа хайлтыг хэрэглэдэг. Мушгиа хайлт хийхийн бүх ашигтай тал болон сул талууд нь 4мм болон 8мм-ийн хөтчүүдийн аль алинд нь хамаардаг.

Соронзон хальснууд нь 2000 удаагийн ашиглалт эсвэл 100 бүрэн нөөцлөлтийн дараа хэрэглээнээс гарах ёстой.

[[backups-tapebackups-8mm]]
=== 8мм (Exabyte)

8мм соронзон хальснууд нь хамгийн нийтлэг SCSI соронзон хальсны хөтчүүд юм; тэдгээр нь соронзон хальснууд солих хамгийн сайн сонголт болдог. Бараг сайт бүр Exabyte 2 GB 8мм-ийн соронзон хальсны хөтөчтэй байдаг. 8мм-ийн хөтчүүд нь найдвартай, хэрэглэхэд амар, чимээгүй байдаг. Хайрцагнууд нь хямд, жижиг (4.8 x 3.3 x 0.6 инч; 122 x 84 x 15 мм) байдаг. 8мм-ийн соронзон хальсны нэг сул тал нь толгойнуудын дагуух соронзон хальсны харьцангуй хөдөлгөөний өндөр хувиас болоод харьцангуй богино толгой ба соронзон хальсны амьдрах хугацаатай байдаг явдал юм.

Өгөгдөл дамжуулах чадвар нь ~250 kB/s-аас ~500 kB/s хүртэл байна. Өгөгдлийн хэмжээ нь 300 MB-аас эхэлж 7 GB хүрнэ. Тоног төхөөрөмжийн шахалт энэ хөтчүүдийн ихэнхэд байх бөгөөд энэ нь багтаамжийг ойролцоогоор хоёр дахин нэмэгдүүлдэг. Эдгээр хөтчүүд нь нэг буюу эсвэл нэг кабинетдаа 6 хөтөч болон 120 соронзон хальстай олон хөтөч бүхий соронзон хальсны сан (library) хэлбэрээр байдаг. соронзон хальснууд нь автоматаар солигддог. Сангийн багтаамж 840+ GB хүрнэ.

Exabyte "Mammoth" загвар нь нэг соронзон хальс дээр 12 GB ((24 GB шахалттайгаар) дэмждэг бөгөөд ердийн соронзон хальсны хөтчөөс ойролцоогоор хоёр дахин үнэтэй байдаг.

Өгөгдөл нь соронзон хальс уруу мушгиа скан ашиглагдан бичигддэг, толгойнууд нь зөөвөрлөгч уруу өнцгөөр байрладаг (ойролцоогоор 6 градус). Соронзон хальс нь толгойнуудыг барьж байдаг дамрын 270 градус орчим ороодог. Соронзон хальс дамар дээгүүр гулгаж байхад дамар нь эргэж байдаг. Үр дүнд нь өгөгдлийн өндөр нягтрал болон соронзон хальсны дагуу нэг ирмэгээс нөгөө уруу өнцөгдсөн ойрхон багцалсан замууд үүсэх болно.

[[backups-tapebackups-qic]]
=== QIC

QIC-150 соронзон хальснууд болон хөтчүүд нь магадгүй хамгийн нийтлэг соронзон хальсны хөтөч, зөөвөрлөгч юм. QIC соронзон хальсны хөтчүүд нь хамгийн хямд "нухацтай" нөөцлөлтийн хөтчүүд юм. Сул тал нь зөөвөрлөгчийн үнэ байдаг. QIC соронзон хальснууд нь 8мм болон 4мм соронзон хальснуудтай харьцуулахад GB өгөгдлийн хадгалалтын хувьд 5 дахин үнэтэй байдаг. Гэхдээ таны хэрэглээнд цөөн (half-dozen) соронзон хальснууд хангалттай бол QIC нь магадгүй зөв сонголт болж болох юм. QIC нь _хамгийн_ нийтлэг соронзон хальсны хөтөч юм. Сайт бүр ямар нэг хэмжээний QIC хөтөчтэй байдаг. QIC нь физикийн хувьд төстэй (заримдаа адил) соронзон хальснуудад их хэмжээний нягтралтай байдаг. QIC хөтчүүд нь чимээгүй биш юм. Эдгээр хөтчүүд нь өгөгдлийг бичиж эхлэхээсээ өмнө дуутайгаар хайдаг бөгөөд унших, бичих эсвэл хайхдаа мэдэгдэхүйц дуутай байдаг. QIC соронзон хальснууд нь 6 x 4 x 0.7 инч (152 x 102 x 17 мм) хэмжээтэй байдаг.

Өгөгдлийн дамжуулах чадвар ~150 kB/s-с ~500 kB/s хүртэл байна. Өгөгдлийн багтаамж 40 MB-с 15 GB хүртэл байна. Шинэ QIC хөтчүүдийн ихэнхэд тоног төхөөрөмжийн шахалт байдаг. QIC хөтчүүд нь бага суулгагддаг; тэдгээр нь DAT хөтчүүдээр шахагдсан юм.

Өгөгдөл нь соронзон хальс уруу замаар бичигддэг. Замууд нь соронзон хальсны зөөвөрлөгчийн нэг төгсгөлөөс нөгөө уруу урт тэнхлэгийн дагуу байдаг. Замуудын тоо болон замын өргөн соронзон хальсны багтаамжаас хамаарч өөр өөр байдаг. Бүх шинэ хөтчүүдийн ихэнх нь хамгийн багадаа бодоход уншилтын (ихэнхдээ бас бичилтийн хувьд) хуучинтайгаа нийцтэй байдаг. QIC нь өгөгдлийн аюулгүй байдлын хувьд нэлээн нэр хүндтэй байдаг (механизм нь хөтчүүдийг мушгиа скан хийснээс илүү хялбар бөгөөд хүчирхэг байдаг).

5,000 нөөцлөлтийн дараа соронзон хальснуудыг ашиглахаа болих шаардлагатай.

[[backups-tapebackups-dlt]]
=== DLT

DLT нь энд жагсаагдсан бүх хөтчийн төрлүүдээс хамгийн хурдан өгөгдөл дамжуулах чадвартай байдаг. 1/2" (12.5мм) соронзон хальс нь ганц дамартай хайрцагт (4 x 4 x 1 инч; 100 x 100 x 25 мм) байдаг. Хайрцаг нь нэг талаараа ганхах хаалгатай байдаг. Хөтчийн механизм соронзон хальсны тэргүүнийг гаргаж авахын тулд энэ хаалгыг онгойлгодог. Соронзон хальсны тэргүүн нь зууван нүхтэй байх бөгөөд хөтөч соронзон хальсыг "дэгээдэхдээ" үүнийг ашигладаг. Авах (take-up) дамар нь соронзон хальсны хөтчийн дотор байрладаг. Энд жагсаагдсан бусад соронзон хальсны хайрцагнууд (9 замтай соронзон хальснууд нь жич юм) нь соронзон хальсны хайрцган дотор байрлах хангах болон take-up дамруудтай байдаг.

Өгөгдөл дамжуулах чадвар нь ойролцоогоор 1.5 MB/s бөгөөд 4мм, 8м, QIC соронзон хальсны хөтчүүдийн дамжуулах чадвараас 3 дахин их байдаг. Өгөгдлийн багтаамж нь нэг хөтчийн хувьд 10 GB-аас 20 GB хүрдэг. Хөтчүүд нь олон соронзон хальс солигчид болон олон соронзон хальс хэлбэрээр байдаг, олон хөтөч бүхий соронзон хальсны сангууд нь нийтдээ 50 GB-с 9 TB хүртэл хадгалалт бүхий 5-аас 900 хүртэл соронзон хальснуудыг 1-ээс 20 хүртэлх хөтчүүд дээр агуулдаг.

Шахалттай бол DLT Төрөл 4 хэлбэршүүлэлт нь 70 GB багтаамжийг дэмждэг.

Өгөгдөл нь соронзон хальсны замууд дээр аялалын чиглэлийн дагуу (QIC соронзон хальснуудын адил) зэрэгцээгээр бичигддэг. Хоёр зам нэг удаа бичигддэг. Унших/бичих толгойны амьдрах хугацаа харьцангуй урт байдаг; соронзон хальс хөдлөхөө болиход толгой болон соронзон хальсны хоорондын хамаатай хөдөлгөөн байхгүй болно.

=== AIT

AIT нь Sony-гоос гаргасан шинэ хэлбэршүүлэлт бөгөөд нэг соронзон хальсны хувьд 50 GB хүртэл (шахалттайгаар) мэдээллийг агуулж чадна. Соронзон хальснууд нь санах ойн бичил схемүүдийг агуулдаг бөгөөд эдгээр нь соронзон хальсны агуулгын индексийг хадгалдаг. Бусад соронзон хальснуудын хувьд хэд хэдэн минут шаардагддаг бол харин энэ индексийг соронзон хальсны хөтөч соронзон хальс дээрх файлуудын байрлалыг тодорхойлохын тулд маш хурдан уншдаг. SAMS:Alexandria зэрэг програм нь соронзон хальсны санах ойн бичил схемтэй шууд холбогдон агуулгыг дэлгэцэд гаргаж, ямар файлууд аль соронзон хальс уруу нөөцлөгдсөнийг тодорхойлж, зөв соронзон хальсыг олон ачаалж соронзон хальснаас өгөгдлийг сэргээн дөч болон түүнээс дээш AIT соронзон хальсны сангуудыг ажиллуулж чаддаг.

Үүнтэй адил сангууд $20,000 хавьцаа үнэ хүрч тэдгээрийг сонирхогчдын зах зээлээс бага зэрэг шахдаг байна.

=== Шинэ соронзон хальсыг анх удаа ашиглах нь

Анхны удаа шинэ, хов хоосон соронзон хальсыг уншихыг оролдвол амжилтгүй болно. Консолын мэдэгдлүүд үүнтэй төстэй байна:

[source,bash]
....
sa0(ncr1:4:0): NOT READY asc:4,1
sa0(ncr1:4:0):  Logical unit is in process of becoming ready
....

Соронзон хальс нь Identifier Block буюу Танигч Блокийг (block number 0) агуулаагүй байна. Бүх QIC соронзон хальснууд нь QIC-525 стандартыг хэрэглэж эхэлснээс хойш Танигч Блокийг соронзон хальсанд бичдэг. Хоёр шийдэл байдаг:

* `mt fsf 1` тушаал нь Танигч Блокийг соронзон хальс уруу бичихийг соронзон хальсны хөтчид хэлнэ.
* Нүүрний товчлуурыг ашиглан соронзон хальсыг гаргаж авна.
+ 
Соронзон хальсыг дахин хийгээд түүн уруу өгөгдлийг `dump` хийнэ.
+ 
`dump` тушаал нь `DUMP: End of tape detected` гэж мэдэгдэх бөгөөд консол `HARDWARE FAILURE info:280 asc:80,96` гэж харуулна.
+ 
`mt rewind` тушаал ашиглан соронзон хальсыг буцаана.
+ 
Дараа дараачийн соронзон хальсны үйлдлүүд амжилттай болно.

[[backups-floppybackups]]
== Уян диск уруу нөөцлөх

[[floppies-using]]
=== Өөрийн өгөгдлийг нөөцлөхийн тулд би уян дискнүүдийг ашиглаж болох уу?

Уян дискнүүд нь нөөц хийхэд тийм ч тохиромжтой зөөвөрлөгч биш юм, учир нь:

* Энэ зөөвөрлөгч нь найдваргүй, ялангуяа урт хугацааны туршид найдваргүй байдаг.
* Нөөцлөх болон буцааж сэргээх нь их удаан байдаг.
* Тэдгээр нь маш хязгаарлагдмал багтаамжтай (бүхэл бүтэн хатуу дискийг хэдэн арван уян дискэнд нөөцлөх нь их олон өдөр шаардана).

Гэхдээ хэрэв танд өөрийн өгөгдлийг нөөцлөх өөр ямар ч арга байхгүй бол уян дискнүүдэд нөөцлөх нь нөөц хийхгүй байснаас хамаагүй дээр юм.

Хэрэв та уян дискнүүд ашиглах шаардлагатай болсон бол сайн чанарынхыг ашигласан эсэхээ шалгах хэрэгтэй. Оффис дээр чинь хоёр жил хэвтсэн уян дискнүүд муу сонголт болох юм. Нэр хүндтэй үйлдвэрлэгчээс гаргасан шинэ дискнүүдийг ашиглах нь зүйтэй юм.

[[floppies-creating]]
=== Тэгэхээр би өөрийн өгөгдлийг уян диск уруу хэрхэн нөөцлөх вэ?

Уян диск уруу нөөцлөх хамгийн шилдэг арга нь man:tar[1] тушаалыг `-M` (олон эзлэхүүн) тохируулгатайгаар ашиглах явдал юм. Энэ нь олон уян дискнүүдэд нөөцлөх боломжийг олгодог.

Тухайн сан болон дэд сан доторх бүх файлуудыг нөөцлөхийн тулд үүнийг ашиглах хэрэгтэй (`root` хэрэглэгчээр):

[source,bash]
....
# tar Mcvf /dev/fd0 *
....

Эхний уян диск дүүрсний дараа man:tar[1] нь дараагийн эзлэхүүнийг оруулахыг хүсэх болно (учир нь man:tar[1] нь зөөвөрлөгчөөс хамааралгүй бөгөөд эзлэхүүнүүдэд ханддаг; энд уян дискийг хэлж байна).

[source,bash]
....
Prepare volume #2 for /dev/fd0 and hit return:
....

Энэ нь заагдсан файлууд архивлагдах хүртэл (эзлэхүүний дугаар нэмэгдэн) давтагдах болно.

[[floppies-compress]]
=== Би өөрийнхөө нөөцүүдийг шахаж болох уу?

Харамсалтай нь man:tar[1] нь олон эзлэхүүн бүхий архивуудын хувьд `-z` тохируулгыг ашиглахыг зөвшөөрдөггүй. Мэдээж та бүх файлуудыг man:gzip[1] хийж тэдгээрийг уян диск уруу man:tar[1] хийж дараа нь файлуудыг дахин man:gunzip[1] хийж болно!

[[floppies-restoring]]
=== Би өөрийн нөөцүүдийг хэрхэн сэргээх вэ?

Бүхэл архивыг сэргээхдээ дараах тушаалыг ашиглана:

[source,bash]
....
# tar Mxvf /dev/fd0
....

Зөвхөн заагдсан файлуудыг сэргээх хоёр арга байдаг бөгөөд та тэдгээрийг ашиглаж болно. Эхлээд та эхний дискнээс эхлээд дараах тушаалыг ашиглана:

[source,bash]
....
# tar Mxvf /dev/fd0 filename
....

man:tar[1] хэрэгсэл нь шаардлагатай файлыг олох хүртлээ дараа дараагийн уян дискнүүдийг хийхийг танаас хүсэх болно.

Өөрөөр, хэрэв та файл нь яг аль уян диск дээр байгааг мэдэж байвал ердөө л тэр уян дискийг оруулж дээрхтэй адил тушаалыг ашиглах хэрэгтэй. Хэрэв уян диск дээрх эхний файл нь өмнөх диск дээрхийн үргэлжлэл бол таныг асуугаагүй байсан ч гэсэн man:tar[1] үүнийг сэргээж чадахгүй гэж танд анхааруулах болно!

[[backup-strategies]]
== Нөөцлөх стратегууд

Нөөцлөх төлөвлөгөөг боловсруулах эхний шаардлага нь дараах бүх асуудлуудыг хамарсан эсэхийг шалгах явдал юм:

* Дискний гэмтэл
* Санамсаргүй файл устгалт
* Санамсаргүй файлын эвдрэл
* Газар дээрх нөөцүүд байвал тэдгээрийг оруулаад машины бүрэн сүйрэл (өөрөө хэлбэл гал).

Эдгээр асуудал бүрийг шал өөр техникээр шийдэснээр зарим системүүдийг илүүтэй ажиллуулах төгс боломж байж болох юм. Маш бага үнэ цэнэтэй өгөгдөл бүхий чанга хувийн системүүдийг тооцохгүй юм бол нэг техник нь бүх асуудлуудыг хамрах нь бараг боломжгүй юм.

Хэрэгслийн хайрцаг дахь зарим нэг техникүүдийг дурдвал:

* Бүх системийн архивууд нь сайтаас гадна байнгын зөөвөрлөгчид нөөцлөгдөнө. Энэ нь дээр дурдсан бүх асуудлуудаас хамгаалах боловч сэргээх нь тохиромжгүй удаан байдаг. Та нөөцүүдийн хуулбаруудыг газар дээр нь ба/эсвэл шууд авч болохоор хадгалж болох боловч файлуудыг сэргээх нь ялангуяа зөвшөөрөгдөөгүй хэрэглэгчдэд бас л тохиромжгүй хэвээр байдаг.
* Файлын системийн хормын хувилбарууд. Энэ нь яг үнэндээ зөвхөн санамсаргүйгээр файлыг устгасан тохиолдолд тустай, гэхдээ энэ нь тийм тохиолдолд _маш_ тус болохуйц байдаг бөгөөд хурдан, ажиллахад хялбар байдаг.
* Бүх файлын систем ба/эсвэл дискнүүдийн хуулбарууд (бүхэл машины үе үе давтагдах man:rsync[1]). Энэ нь ерөнхийдөө онцгой шаардлага бүхий сүлжээнүүдэд хамгийн ашигтай байдаг. Дискний эвдрэл, гэмтлийн эсрэг ерөнхий хамгаалалтын хувьд энэ нь ихэвчлэн RAID-с чанарын хувьд муу байдаг. Санамсаргүйгээр устгасан файлуудыг сэргээхэд энэ нь UFS хормын хувилбартай дүйцэхээр боловч та алийг дээдэлдгээс хамаарах юм.
* RAID. Диск эвдрэх, гэмтэх үед зогсох хугацааг багасгаж зайлсхийдэг. Маш бага шаардлагатай хэдий ч дискний эвдрэлүүдтэй илүүтэй зууралдах (учир нь та олон дисктэй) хэрэгтэй болдог.
* Файлуудын байрлалыг (хурууны хээ) шалгах. Үүнд man:mtree[8] хэрэгсэл их ашигтай байдаг. Энэ нь нөөцлөх техник биш боловч танд өөрийн нөөцүүддээ хандахаар болох үед та хэрэг болох болно. Энэ нь сайтаас гаднах шууд бус нөөцүүдийн хувьд ялангуяа чухал бөгөөд үе үе шалгагдаж байх ёстой.

Үүнээс илүү олон техникийг бодож олох нь амархан бөгөөд тэдгээрийн ихэнх нь дээр дурдсан техникүүдийн өөр хувилбарууд юм. Тусгайлсан шаардлагууд нь ихэвчлэн тусгайлсан техникт хүргэдэг (жишээ нь шууд ажиллаж байгаа мэдээллийн баазыг нөөцлөх нь зөвхөн мэдээллийн санд зориулагдсан аргыг дундын шат болгон ихэвчлэн ашиглахыг шаарддаг). Ямар аюулуудаас та хамгаалахыг хүсэж байгаа болон тэдгээр тус бүртэй хэрхэн ажиллахаа мэдэх нь чухал юм.

[[backup-basics]]
== Нөөцлөлтийн үндсүүд

Гурван гол нөөцлөх програм бол man:dump[8], man:tar[1] болон man:cpio[1] юм.

=== Dump ба Restore

Уламжлалт UNIX(R) нөөцлөх програмууд нь `dump` ба `restore` юм. Тэдгээр нь файлын системүүдээр үүсгэгдсэн файлууд, холбоосууд болон сангуудын хийсвэр ойлголтуудын доор хөтчүүд дээр дискний блокуудын цуглуулга хэлбэрээр ажилладаг. Бусад нөөцлөх програмуудаас ялгаатай нь `dump` нь төхөөрөмж дээрх бүхэл файлын системийг нөөцөлдөг. Файлын системийн зөвхөн хэсгийг эсвэл нэгээс илүү файлын систем дагуу байрлах сангийн модыг энэ нь нөөцөлж чаддаггүй. `dump` нь файлууд болон сангуудыг соронзон хальс уруу бичдэггүй, харин файлууд болон сангуудаас тогтох түүхий өгөгдлийн блокуудыг бичдэг. Өгөгдлийг задлахад хэрэглэгдэхдээ `restore` нь анхдагчаар түр зуурын файлуудыг [.filename]#/tmp/# санд хадгалдаг. Хэрэв та жижиг хэмжээний [.filename]#/tmp# сан бүхий нөөц сэргээх диск дээрээс ажиллаж байгаа бол сэргээлтийг амжилттай гүйцээхийн тулд илүү чөлөөтэй зайтай сан руу `TMPDIR` орчны хувьсагчийг зааж өгөх хэрэгтэй байж болох юм.

[NOTE]
====
Хэрэв та өөрийн root сандаа `dump`-г хэрэглэвэл та [.filename]#/home#, [.filename]#/usr# эсвэл бусад олон сангуудыг нөөцлөхгүй бөгөөд үүний учир бол эдгээр нь ихэвчлэн бусад файлын системүүдийн холбох цэгүүд буюу эсвэл тэдгээр файлын системүүд уруу заасан симболын холбоосууд байдаг.
====

`dump` нь өөрийн хөгжлийн эхний өдрүүд болох AT&T UNIX-ийн 6-р хувилбараас (1975 он орчим) үлдсэн кодтой байдаг. Анхдагч параметрүүд нь өнөөдөр байгаа өндөр нягтралтай (62,182 ftpi хүртэл) зөөвөрлөгчид биш 9 зам (6250 bpi) бүхий соронзон хальсанд тохирдог. Одоогийн соронзон хальсны хөтчүүдийн багтаамжийг хэрэглэхийн тулд эдгээр анхдагчуудыг тушаалын мөрөөс дарж өөрчлөх ёстой.

Мөн сүлжээгээр өөр компьютерт холбогдсон соронзон хальсны хөтөч уруу өгөгдлийг `rdump` болон `rrestore` тушаал ашиглан нөөцлөх боломжтой байдаг. Энэ хоёр програм нь алсын соронзон хальсны хөтчид хандахдаа man:rcmd[3] болон man:ruserok[3]-д тулгуурладаг. Тиймээс нөөцлөлтийг хийж байгаа хэрэглэгч алсын компьютерийн [.filename]#.rhosts# файл дотор жагсаагдсан байх ёстой. `rdump` болон `rrestore` тушаалуудад өгөх нэмэлт өгөгдлүүд нь алсын компьютер дээр ашиглаж болохоор байх ёстой. `komodo` гэж нэрлэгдсэн Sun уруу холбогдсон Exabyte соронзон хальсны хөтөч уруу FreeBSD компьютераас `rdump` хийхдээ дараах тушаалыг ашиглана:

[source,bash]
....
# /sbin/rdump 0dsbfu 54000 13000 126 komodo:/dev/nsa8 /dev/da0a 2>&1
....

Болгоомжлоорой: [.filename]#.rhosts# танин нэвтрэлтийг зөвшөөрөх нь аюулгүй байдлын асуудлууд үүсгэдэг. Өөрийн нөхцөл байдлыг анхааралтай үнэлэх хэрэгтэй.

Мөн `dump` болон `restore` тушаалыг илүү аюулгүй загвараар `ssh` дээгүүр ашиглах бас боломжтой байдаг.

.ssh-ээр `dump`-г ашиглах нь
[example]
====

[source,bash]
....
# /sbin/dump -0uan -f - /usr | gzip -2 | ssh -c blowfish \
          targetuser@targetmachine.example.com dd of=/mybigfiles/dump-usr-l0.gz
....

====

Эсвэл `dump`-ийн дотор байдаг нэг арга болох `RSH` орчны хувьсагчийг тохируулан ашиглаж болно:

.ssh-ээр `RSH` тохируулан `dump`-г ашиглах нь
[example]
====

[source,bash]
....
# env RSH=/usr/bin/ssh /sbin/dump -0uan -f targetuser@targetmachine.example.com:/dev/sa0 /usr
....

====

=== `tar`

man:tar[1] нь бас AT&T UNIX-ийн 6-р хувилбараас (1975 он орчим) эхтэй. `tar` нь файлын системтэй хамт ажилладаг; энэ нь файлууд болон сангуудыг соронзон хальс уруу бичдэг. `tar` нь man:cpio[1]-д байдаг бүрэн хэмжээний тохируулгуудыг дэмждэггүй боловч энэ нь `cpio`-ийн хэрэглэдэг ховор тушаалын дамжуулах хоолойг шаарддаггүй.

`komodo` гэж нэрлэгдсэн Sun уруу холбогдсон Exabyte соронзон хальсны хөтөч уруу `tar` хийхдээ дараах тушаалыг ашиглана:

[source,bash]
....
# tar cf - . | rsh komodo dd of=tape-device obs=20b
....

Хэрэв та сүлжээгээр нөөцлөхийн аюулгүй байдалд санаа зовж байгаа бол `rsh`-ийн оронд `ssh` тушаалыг ашиглах хэрэгтэй.

=== `cpio`

man:cpio[1] нь соронзон зөөвөрлөгчид зориулагдсан UNIX(R)-ийн анхны файл солилцох соронзон хальсны програм юм. `cpio` нь (бусад олон тохируулгуудын дотроос) байт солилцохыг хийх, хэд хэдэн төрлийн архивын хэлбэршүүлэлтүүдийг бичих болон өгөгдлийг өөр програм уруу хоолойгоор гаргах зэрэг тохируулгуудтай байдаг. Сүүлийн боломж нь `cpio`-г суулгацын зөөвөрлөгчийн хувьд сайн сонголт болгодог. `cpio` нь сангийн модоор хэрхэн явахаа мэддэггүй бөгөөд файлуудын жагсаалтыг [.filename]#stdin#-ээс хангаж өгөх ёстой.

`cpio` нь сүлжээгээр нөөцлөхийг дэмждэггүй. Та дамжуулах хоолой болон `rsh`-ийг ашиглаж өгөгдлийг алсын соронзон хальсны хөтөч уруу илгээж болно.

[source,bash]
....
# for f in directory_list; do
find $f >> backup.list
done
# cpio -v -o --format=newc < backup.list | ssh user@host "cat > backup_device"
....

_directory_list_ нь таны нөөцлөхийг хүссэн сангуудын жагсаалт бол _user_@_host_ нь нөөцлөлтийг хийж байгаа хэрэглэгч/хостын нэрийн хослол бөгөөд _backup_device_ нь нөөцлөлт хийгдэх төхөөрөмж (өөрөөр хэлбэл [.filename]#/dev/nsa0#) юм.

=== `pax`

man:pax[1] нь `tar` болон `cpio` тушаалын IEEE/POSIX(R)-ийн хариулт юм. Жил ирэх тутам `tar` болон `cpio` тушаалуудын төрөл бүрийн хувилбарууд нь хоорондоо мэдэгдэхүйц нийцгүй болж ирсэн юм. Тэдгээртэй тэмцэж бүр мөсөн стандартчилахын оронд POSIX(R) нь архивын шинэ хэрэгсэл үүсгэсэн юм. `pax` нь өөрийн шинэ хэлбэршүүлэлтээс гадна `cpio` болон `tar` тушаалуудын төрөл бүрийн хэлбэршүүлэлтийн ихэнхийг уншиж бичихийг оролддог. Энэ тушаалын олонлог нь `tar` тушаалынхтай биш харин `cpio` тушаалынхтай илүү төстэй байдаг.

[[backups-programs-amanda]]
=== Amanda

Amanda (Advanced Maryland Network Disk Archiver) нь нэг програм биш клиент/сервер програм юм. Amanda сервер нь ганц соронзон хальсны хөтөч уруу Amanda клиенттэй, Amanda сервер уруу сүлжээгээр холбогдсон дурын тооны компьютерийг нөөцлөх болно. Хэд хэдэн том дискнүүд бүхий сайтууд дээр байдаг нийтлэг асуудлууд нь өгөгдлийг соронзон хальс уруу нөөцлөхөд шаардагдах хугацаа нь уг үйлдлийн хувьд зориулагдсан хугацаанаас илүү гарах явдал юм. Amanda нь энэ асуудлыг шийддэг. Amanda нь хэд хэдэн файлын системүүдийг нэг зэрэг нөөцлөхдөө "holding disk буюу хүлээгдэх диск"ийг ашигладаг. Amanda нь "архивын олонлогууд" буюу Amanda-ийн тохиргооны файлд жагсаагдсан бүх файлын системүүдийн бүрэн нөөцлөлтүүдийг үүсгэхэд хэсэг хугацаанд хэрэглэгдсэн бүлэг соронзон хальснуудыг үүсгэдэг. "Архивын олонлогууд" нь бас файлын системүүдийн шөнө болгоны нэмэгдсэн (эсвэл ялгаатай) нөөцлөлтүүдийг агуулдаг. Эвдэрсэн файлын системийг сэргээх нь хамгийн сүүлийн бүрэн нөөцлөлт болон нэмэгдсэн нөөцлөлтүүдийг шаарддаг.

Тохиргооны файл нь нөөцлөлтүүд болон Amanda-ийн үүсгэдэг сүлжээний урсгалыг нарийн хянах боломжийг хангадаг. Amanda нь өгөгдлийг соронзон хальс уруу бичихийн тулд дээр дурдсан нөөцлөлтийн програмуудыг ашиглана. Amanda нь порт эсвэл багц хэлбэрээр байдаг бөгөөд анхдагчаар суулгагдаагүй байдаг.

=== Юу ч хийхгүй байх

"Юу ч хийхгүй байх" нь компьютерийн програм биш боловч энэ нь хамгийн их ашиглагддаг нөөцлөлтийн стратеги юм. Ямар ч эхний зардал байхгүй. Мөрдөх нөөцлөлтийн төлөвлөгөө байхгүй. Зүгээр л үгүй гэх хэрэгтэй. Хэрэв таны өгөгдөлд ямар нэг асуудал тохиолдвол шүд зуугаад л тэвчих хэрэгтэй!

Хэрэв таны цаг болон өгөгдөл нь тийм ч чухал биш эсвэл юу ч биш бол "Do nothing буюу юу ч хийхгүй байх" нь таны компьютерийн хувьд хамгийн тохиромжтой нөөцлөлтийн програм болох юм. Гэхдээ UNIX(R) нь ашигтай хэрэгсэл юм, та зургаан сарын дотор үнэтэй файлуудын цуглуулгатай болж үүнийг мэдрэх болно.

"Юу ч хийхгүй байх" нь [.filename]#/usr/obj# болон таны компьютераар яг үүсгэгдэж болох бусад сангийн моднуудын хувьд зөв нөөцлөх арга болдог. Үүний жишээ нь энэ гарын авлагын HTML эсвэл PostScript(R)-с тогтох хувилбарын файлууд байж болох юм. Эдгээр баримтын хэлбэршүүлэлтүүд нь XML оролтын файлуудаас үүсгэгддэг. HTML эсвэл PostScript(R) файлуудын нөөцлөлтийг үүсгэх нь шаардлагагүй юм. XML файлууд нь байнга нөөцлөгддөг.

=== Аль нөөцлөлтийн програм хамгийн шилдэг нь вэ?

man:dump[8] _Үе._ Элизабет Д. Звики энд дурдагдсан бүх нөөцлөлтийн програмуудыг зовоосон тест хийсэн. Өөрийн бүх өгөгдөл болон UNIX(R) файлын системүүдийн онцлогуудыг хадгалах цэвэр сонголт бол `dump` болсон байна. Элизабет маш их төрөл бүрийн ховор нөхцөлүүдийг (зарим нь тийм ч ховор биш) агуулсан файлын системүүдийг үүсгэж тэдгээр файлын системүүдийг нөөцлөн дараа нь сэргээж програм бүрийг тест хийсэн байна. Онцгой зүйлүүдэд цоорхойтой файлууд, хоосон блоктой болон цоорхойтой файлууд, сонин тэмдэгт бүхий нэрээс тогтсон файлууд, бичигдэх боломжгүй уншигдах боломжгүй файлууд, төхөөрөмжүүд, нөөцлөлтийн үед хэмжээгээ өөрчлөх файлууд, нөөцлөлтийн үед үүсгэгдэж/устгагдсан файлууд зэргийг дурдаж болох юм. Тэрээр үр дүнгээ 1991 оны 10 сард LISA дээр үзүүлсэн байна. http://www.coredumps.de/doc/dump/zwicky/testdump.doc.html[Нөөцлөлт болон Архивын програмуудыг зовоох тест] холбоосыг үзнэ үү.

=== Яаралтай сэргээх процедур

==== Гамшгийн өмнө

Учирч болзошгүй гамшигт бэлтгэхийн тулд таны хийх ёстой дөрвөн үе шат байдаг.

Эхлээд өөрийн диск бүрийн bsdlabel (өөрөөр хэлбэл `bsdlabel da0 | lpr`), өөрийн файлын системийн хүснэгт ([.filename]#/etc/fstab#) болон бүх ачаалалтын мэдэгдлүүдийг тус бүр хоёр хувь хэвлэх хэрэгтэй.

Дараа нь "livefs" CDROM шарах хэрэгтэй. Энэ CDROM нь FreeBSD "livefs" аврах горим руу ачаалж орох боломжийг агуулсан байдаг. Ингэснээр хэрэглэгч man:dump[8],man:restore[8], man:fdisk[8], man:bsdlabel[8], man:newfs[8], man:mount[8] гэх мэт олон үйлдлийг хийх боломжтой болох юм. FreeBSD/i386 {rel112-current}-RELEASE-д зориулсан Livefs CD дүрс link:ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/ISO-IMAGES/{rel112-current}/FreeBSD-{rel112-current}-RELEASE-i386-livefs.iso[ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/ISO-IMAGES/{rel112-current}/FreeBSD-{rel112-current}-RELEASE-i386-livefs.iso] хаяг дээр бий.

[NOTE]
====
Livefs CD дүрснүүд FreeBSD {rel120-current}-RELEASE болон түүнээс хойшхи хувилбаруудын хувьд байдаггүй. CDROM суулгалтын дүрснээс гадна флэш суулгалтын дүрснүүд ашиглан системийг сэргээж болно. FreeBSD/i386 {rel120-current}-RELEASE-д зориулсан "memstick" дүрс link:ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/i386/ISO-IMAGES/{rel120-current}/FreeBSD-{rel120-current}-RELEASE-i386-memstick.img[ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/i386/ISO-IMAGES/{rel120-current}/FreeBSD-{rel120-current}-RELEASE-i386-memstick.img] хаяг дээр бий.
====

Гуравдугаарт нөөц соронзон хальснуудыг байнга үүсгэж байх хэрэгтэй. Таны сүүлийн нөөцлөлтөөс хойш хийгдсэн өөрчлөлтүүд буцааж авагдах боломжгүйгээр алга болж болох юм. Нөөц соронзон хальснууд уруу хийж болзошгүй бичилтийг хамгаалах хэрэгтэй.

Дөрөвдүгээрт хоёрдугаар шатанд хийсэн "livefs" CDROM болон нөөцийн соронзон хальснуудыг шалгах ёстой. Процедурынхаа талаар тэмдэглэгээ хийх хэрэгтэй. Эдгээр тэмдэглэгээнүүдээ CDROM, хэвлэсэн зүйл болон нөөц соронзон хальснуудтайгаа цуг хадгалах хэрэгтэй. Сэргээж байх үед таны анхаарал их сарнисан байж болох бөгөөд тэдгээр тэмдэглэгээнүүд чинь таныг өөрийн нөөц соронзон хальснуудаа устгахаас сэргийлэх болно (Яаж? `tar xvf /dev/sa0` тушаалын оронд та санамсаргүйгээр `tar cvf /dev/sa0` гэж бичээд өөрийн нөөц соронзон хальсыг дарж бичиж болох юм).

Аюулгүй байдлын нэмэгдэл арга хэмжээ болгож тухайг бүрт нь ачаалагдах "livefs" CDROM болон нөөц соронзон хальс хоёрыг бэлдэж байх хэрэгтэй. Тус бүрийг нь тусад нь алсад өөр газар хадгалах хэрэгтэй. Тэр өөр газар нь яг тэр оффисийн байрны подвал байх ЁСГҮЙ. Дэлхийн Худалдааны Төвийн хэд хэдэн фирм үүнийг хэцүү замаар мэдэрсэн юм. Тэр өөр газар нь таны компьютерууд болон дискний хөтчүүдээс тусгаарлагдсан физикийн хувьд нэлээд зайтай газар байх ёстой.

==== Гамшгийн дараа

Түлхүүр асуулт бол: таны тоног төхөөрөмж амьд гарч чадсан уу? Байнгын нөөцлөлт хийж байсан болохоор програм хангамжийн талаар та санаа зовох хэрэггүй юм.

Хэрэв тоног төхөөрөмж эвдэрсэн бол компьютерийг ашиглахаасаа өмнө эвдэрсэн хэсгүүдийг солих шаардлагатай.

Хэрэв таны тоног төхөөрөмж зүгээр байгаа бол CDROM хөтөч рүү "livefs" CDROM-оо хийгээд компьютераа ачаалах хэрэгтэй. Эхний суулгах цэс дэлгэц дээр гарах болно. Зөв улсаа сонгоод [.guimenuitem]#Fixit -- Repair mode with CDROM/DVD/floppy or start a shell.# сонголтыг сонгоод [.guimenuitem]#CDROM/DVD -- Use the live filesystem CDROM/DVD# цэсийг сонгоно. Танд хэрэгтэй `restore` болон бусад програмууд [.filename]#/mnt2/rescue# санд байрлана.

Файлын систем бүрийг тус тусад нь сэргээнэ.

Өөрийн эхний дискний root хуваалтыг `mount` (өөрөөр хэлбэл `mount /dev/da0a /mnt`) хийхийг оролдоорой. Хэрэв bsdlabel эвдэрсэн бол `bsdlabel` тушаалыг ашиглан дискийг дахин хувааж таны хэвлэж хадгалсан шошготой адил тааруулж хаяглах хэрэгтэй. `newfs` тушаал ашиглан файлын системүүдийг дахин үүсгэнэ. Дискний root хуваалтыг унших-бичихээр дахин холбох хэрэгтэй (`mount -u -o rw /mnt`). Энэ файлын системийн хувьд өгөгдлийг сэргээхийн тулд өөрийн нөөцлөх програм болон соронзон хальснуудыг ашиглана (өөрөөр хэлбэл `restore vrf /dev/sa0`). Файлын системийг салгана (өөрөөр хэлбэл `umount /mnt`). Эвдэрсэн файлын систем бүрийн хувьд давтана.

Таны систем ажилласны дараа өөрийн өгөгдлийг шинэ соронзон хальс уруу нөөцлөх хэрэгтэй. Сүйрэл эсвэл өгөгдлийн алдагдалд хүргэсэн тэр явдал дахин болж болох юм. Одоо зарцуулсан нэг цаг таныг зовлонд учрахаас хожим аварч болох юм.

[[disks-virtual]]
== Сүлжээ, санах ой болон файл дээр тулгуурласан файлын системүүд

Өөрийн компьютер уруу физикээр хийж болдог уян диск, CD-үүд, хатуу хөтчүүд гэх зэрэг дискнүүдээс гадна бусад хэлбэрийн дискнүүд буюу __виртуал дискнүүд__ийг FreeBSD ойлгодог.

Эдгээрт crossref:network-servers[network-nfs,Network File System буюу сүлжээний файлын систем] болон Coda зэрэг сүлжээний файлын системүүд, санах ой дээр тулгуурласан файлын системүүд болон файл дээр тулгуурласан файлын системүүд орно.

FreeBSD-ийн ямар хувилбарыг ажиллуулж байгаагаас хамаарч та файл дээр болон санах ой дээр тулгуурласан файлын системүүдийг үүсгэж ашиглахдаа өөр өөр хэрэгслүүдийг хэрэглэх шаардлагатай болно.

[NOTE]
====
Хэрэглэгчийн хувьд мэдэгдэлгүйгээр төхөөрөмжийн цэгүүдийг хуваарилахын тулд man:devfs[5]-г ашиглана.
====

[[disks-mdconfig]]
=== Файл дээр тулгуурласан файлын систем

man:mdconfig[8] хэрэгсэл нь FreeBSD дээр санах ой дээр тулгуурласан дискнүүд, man:md[4]-г тохируулж идэвхжүүлэхэд хэрэглэгддэг. man:mdconfig[8]-г ашиглахын тулд та man:md[4] модулийг ачаалах хэрэгтэй, эсвэл өөрийн цөмийн тохиргооны файлдаа дэмжлэгийг нэмэх хэрэгтэй болно:

[.programlisting]
....
device md
....

man:mdconfig[8] тушаал нь гурван төрлийн санах ой дээр тулгуурласан виртуал дискийг дэмждэг: эдгээр нь man:malloc[9]-р хуваарилагдсан санах ойн дискнүүд, файл эсвэл swap зай ашигласан санах ойн дискнүүд юм. Нэг боломжтой хэрэглээ нь файлд хадгалагдсан уян эсвэл CD дүрсийг холбох явдал юм.

Байгаа файлын системийн дүрсийг холбохдоо:

.`mdconfig` ашиглан байгаа файлын системийн дүрсийг холбох нь
[example]
====

[source,bash]
....
# mdconfig -a -t vnode -f diskimage -u 0
# mount /dev/md0 /mnt
....

====

man:mdconfig[8] ашиглан шинэ файлын системийн дүрсийг үүсгэхдээ:

.`mdconfig` тушаал ашиглан шинэ файл дээр тулгуурласан диск үүсгэх нь
[example]
====

[source,bash]
....
# dd if=/dev/zero of=newimage bs=1k count=5k
5120+0 records in
5120+0 records out
# mdconfig -a -t vnode -f newimage -u 0
# bsdlabel -w md0 auto
# newfs md0a
/dev/md0a: 5.0MB (10224 sectors) block size 16384, fragment size 2048
        using 4 cylinder groups of 1.25MB, 80 blks, 192 inodes.
super-block backups (for fsck -b #) at:
 160, 2720, 5280, 7840
# mount /dev/md0a /mnt
# df /mnt
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md0a       4710    4  4330     0%    /mnt
....

====

Хэрэв та `-u` тохируулгаар нэгжийн дугаарыг зааж өгөхгүй юм бол man:mdconfig[8] нь хэрэглэгдээгүй төхөөрөмжийг сонгохын тулд man:md[4] автомат хуваарилалтыг ашиглах болно. Хуваарилагдсан нэгжийн нэр нь stdout уруу [.filename]#md4# мэтээр гарах болно. man:mdconfig[8]-ийн тухай дэлгэрэнгүй мэдээллийг гарын авлагын хуудаснаас лавлана уу.

man:mdconfig[8] хэрэгсэл нь их ашигтай, гэхдээ энэ нь файл дээр тулгуурласан файлын систем үүсгэхийн тулд олон тушаалын мөрийг асуудаг. FreeBSD нь бас man:mdmfs[8] гэж нэрлэгддэг хэрэгсэлтэй ирдэг, энэ програм нь man:md[4]-г man:mdconfig[8] тушаал ашиглан тохируулж man:newfs[8] ашиглан UFS файлын систем түүн дээр тавьж man:mount[8] ашиглан түүнийг холбодог. Жишээ нь хэрэв та дээрхтэй ижил файлын системийн дүрсийг үүсгэж холбохыг хүсвэл ердөө л дараах тушаалыг бичээрэй:

.`mdmfs` тушаал ашиглан файл дээр тулгуурласан дискийг тохируулж холбох нь
[example]
====

[source,bash]
....
# dd if=/dev/zero of=newimage bs=1k count=5k
5120+0 records in
5120+0 records out
# mdmfs -F newimage -s 5m md0 /mnt
# df /mnt
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md0        4718    4  4338     0%    /mnt
....

====

Хэрэв та `md` тохируулгыг нэгжийн дугааргүй ашиглавал man:mdmfs[8] нь ашиглагдаагүй төхөөрөмжийг автоматаар сонгохдоо man:md[4] авто-нэгж боломжийг ашиглах болно. man:mdmfs[8]-ийн тухай дэлгэрэнгүй мэдээллийг гарын авлагын хуудаснаас лавлана уу.

[[disks-md-freebsd5]]
=== Санах ой дээр тулгуурласан файлын систем

Санах ой дээр тулгуурласан файлын системийн хувьд "swap backing буюу swap дээрх тулгуурлалтыг" ихэнхдээ ашиглах хэрэгтэй. swap дээрх тулгуурлалтыг ашиглах нь санах ойн диск нь анхдагчаар диск уруу swap хийгдэнэ гэсэн үг биш бөгөөд харин ердөө л санах ойн диск нь санах ойн цөөрмөөс хуваарилагдаж хэрэв хэрэгцээтэй бол диск уруу swap хийгдэж болно гэсэн үг юм. Мөн man:malloc[9] дээр тулгуурласан санах ойн дискийг үүсгэх боломжтой байдаг. Гэхдээ malloc дээр тулгуурласан санах ойн дискнүүдийг, ялангуяа том хэмжээтэйг нь ашиглах нь цөм санах ойгүй болох тохиолдолд системийг сүйрэлд хүргэж болох юм.

.`mdconfig` тушаал ашиглан шинэ санах ой дээр тулгуурласан диск үүсгэх нь
[example]
====

[source,bash]
....
# mdconfig -a -t swap -s 5m -u 1
# newfs -U md1
/dev/md1: 5.0MB (10240 sectors) block size 16384, fragment size 2048
        using 4 cylinder groups of 1.27MB, 81 blks, 192 inodes.
        with soft updates
super-block backups (for fsck -b #) at:
 160, 2752, 5344, 7936
# mount /dev/md1 /mnt
# df /mnt
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md1        4718    4  4338     0%    /mnt
....

====

.`mdmfs` тушаал ашиглан шинэ санах ой дээр тулгуурласан диск үүсгэх нь
[example]
====

[source,bash]
....
# mdmfs -s 5m md2 /mnt
# df /mnt
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md2        4846    2  4458     0%    /mnt
....

====

=== Системээс санах ойн дискийг салгах нь

Санах ой дээр тулгуурласан эсвэл файл дээр тулгуурласан файлын систем ашиглагдахгүй байгаа бол та бүх эх үүсвэрүүдийг системд суллаж өгөх шаардлагатай. Эхний хийх ёстой зүйл нь файлын системийг салгаад дараа нь man:mdconfig[8] ашиглан дискийг системээс салгаж эх үүсвэрүүдийг суллана.

Жишээ нь [.filename]#/dev/md4#-г салгаж түүний хэрэглэсэн бүх эх үүсвэрүүдийг чөлөөлөхийн тулд дараах тушаалыг ажиллуулна:

[source,bash]
....
# mdconfig -d -u 4
....

Тохиргоо хийгдсэн man:md[4] төхөөрөмжүүдийн тухай мэдээллийг `mdconfig -l` тушаал ашиглан жагсааж болно.

[[snapshots]]
== Файлын системийн хормын хувилбарууд

FreeBSD нь crossref:cutting-edge[soft-updates,Soft Updates буюу зөөлөн шинэчлэлтүүд]ийн хамт Файлын системийн хормын хувилбарууд боломжийг санал болгодог.

Хормын хувилбарууд нь заасан файлын системүүдийн дүрсийг үүсгэж тэдгээртэй файлтай ханддаг шиг хандах боломжийг хэрэглэгчид зөвшөөрдөг. Хормын хувилбарын файлууд нь үйлдэл хийгдсэн файлын систем дээр үүсгэгдэх ёстой бөгөөд нэг файлын системийн хувьд 20-с ихгүй хормын хувилбаруудыг хэрэглэгч үүсгэж болно. Идэвхтэй хормын хувилбарууд нь супер блокт бичигддэг бөгөөд ингэснээр тэдгээр нь системийн дахин ачаалалтуудын үед салгах болон дахин холбох явцад тэсвэртэй байдаг. Хормын хувилбар нь хэрэггүй болсон үед энэ нь стандарт man:rm[1] тушаалаар устгагдаж болно. Хормын хувилбарууд нь ямар ч дарааллаар устгагдаж болох бөгөөд гэхдээ ашиглагдсан бүх зайг дахин олж авахгүй байж болох юм. Учир нь өөр нэг хормын хувилбар чөлөөлөгдсөн блокуудын заримыг шаардаж болзошгүй юм.

Өөрчлөгдөхгүй `snapshot` файл тохируулга нь хормын хувилбарыг эхлээд үүсгэсний дараа man:mksnap_ffs[8] тушаалаар заагддаг. man:unlink[1] тушаал нь хормын хувилбарын файлуудын хувьд орхидог бөгөөд учир нь энэ нь тэдгээрийг устгахыг зөвшөөрдөг байна.

Хормын хувилбарууд нь man:mount[8] тушаалаар үүсгэгддэг. [.filename]#/var#-ийн хормын хувилбарыг [.filename]#/var/snapshot/snap# файлд байрлуулахын тулд дараах тушаалыг ашиглана:

[source,bash]
....
# mount -u -o snapshot /var/snapshot/snap /var
....

Өөрөөр та хормын хувилбар үүсгэхийн тулд man:mksnap_ffs[8]-г ашиглаж болно:

[source,bash]
....
# mksnap_ffs /var /var/snapshot/snap
....

Файлын систем (өөрөөр хэлбэл [.filename]#/var#) дээр хормын хувилбарын файлуудыг man:find[1] тушаал ашиглан олж болно:

[source,bash]
....
# find /var -flags snapshot
....

Хормын хувилбар үүсгэгдсэний дараа энэ нь хэд хэдэн хэрэглээтэй байдаг:

* Зарим администраторууд хормын хувилбарын файлыг нөөцийн зорилгоор ашигладаг, учир нь хормын хувилбар нь CD-үүд эсвэл соронзон хальс уруу дамжуулагдаж болдог.
* Файлын системийн бүрэн бүтэн байдлыг шалгадаг man:fsck[8] нь хормын хувилбар дээр ажиллаж болдог. Файлын систем нь холбогдсон үедээ цэвэр байсан гэж үзвэл та үргэлж цэвэр (өөрчлөгдөөгүй) үр дүнг авах болно. Үүнийг гол нь арын man:fsck[8] процесс хийдэг.
* man:dump[8] хэрэгслийг хормын хувилбар дээр ажиллуулдаг. Хормын хувилбарын файлын систем болон цагтай нэг янз хуулбар хийгддэг. man:dump[8] нь бас хормын хувилбарыг авч нөөц дүрсийг үүсгэж чаддаг бөгөөд дараа нь хормын хувилбарыг нэг тушаалаар `-L` тугийг ашиглан устгаж чаддаг.
* Хормын хувилбарыг файлын системийн хөлдөөгдсөн дүрс маягаар man:mount[8] хийдэг. [.filename]#/var/snapshot/snap# хормын хувилбарыг man:mount[8] хийхийн тулд доор дурдсаныг ажиллуулна:
+

[source,bash]
....
# mdconfig -a -t vnode -f /var/snapshot/snap -u 4
# mount -r /dev/md4 /mnt
....

Та одоо [.filename]#/mnt#-д холбогдсон өөрийн хөлдөөгдсөн [.filename]#/var# файлын системийн шатлалаар аялж болно. Хормын хувилбар үүсгэх үе дэх төлвийн адил төлөвт бүгд эхлээд байна. Цорын ганц өөр зүйл нь өмнөх хормын хувилбарууд нь тэг урттай файлууд маягаар гарч ирэх болно. Хормын хувилбарын хэрэглээг хязгаарлах үед үүнийг дараах тушаалыг ажиллуулан салгаж болно:

[source,bash]
....
# umount /mnt
# mdconfig -d -u 4
....

`softupdates` буюу зөөлөн шинэчлэлтүүд болон файлын системийн хормын хувилбаруудын талаар дэлгэрэнгүй мэдээллийг техникийн баримтуудыг оролцуулаад та Маршал Кирк МкКюзикийн вэб хуудас http://www.mckusick.com/[http://www.mckusick.com/] уруу зочлон орж үзэж болно.

[[quotas]]
== Файлын системийн ноогдлууд

Quota буюу ноогдол нь хэрэглэгч эсвэл бүлгийн гишүүдийн хувьд дискний зай ба/эсвэл файлуудын тоог файлын систем тус бүрийн хувьд хуваарилж хязгаарлах боломжийг бүрдүүлэх үйлдлийн системийн нэг нэмэлт боломж юм. Энэ нь дурын нэг хэрэглэгч эсвэл бүлэг хэрэглэгчдийн хуваарилж болох эх үүсвэрүүдийг хязгаарлах шаардлагатай цаг хуваалцах систем дээр ихэвчлэн хэрэглэгддэг. Энэ нь нэг хэрэглэгч эсвэл бүлэг хэрэглэгчид бүх байгаа дискний зайг хэрэглэхээс хамгаалдаг юм.

=== Дискний ноогдлуудыг идэвхтэй болгохын тулд өөрийн системийг тохируулах нь

Дискний ноогдлыг ашиглаж эхлэхээсээ өмнө ноогдлууд нь цөмд тохируулагдсан эсэхийг шалгах шаардлагатай. Дараах мөрийг өөрийн цөмийн тохиргооны файлд нэмж үүнийг хийнэ:

[.programlisting]
....
options QUOTA
....

Анхны [.filename]#GENERIC# цөм нь үүнийг анхнаасаа идэвхжүүлээгүй байдаг болохоор та дискний ноогдлуудыг ашиглахын тулд тусгайлсан цөмийг тохируулж бүтээн суулгах хэрэгтэй болох юм. Цөмийн тохиргооны талаар дэлгэрэнгүй мэдээллийг crossref:kernelconfig[kernelconfig,FreeBSD цөмийг тохируулах нь]-с лавлана уу.

Дараа нь та дискний ноогдлуудыг [.filename]#/etc/rc.conf# файлд идэвхжүүлэх хэрэгтэй. FreeBSD 7.X болон түүнээс өмнөх дээр дараах мөрийг нэмж үүнийг хийнэ:

[.programlisting]
....
enable_quotas="YES"
....

FreeBSD 8.0-RELEASE болон түүнээс хойшхи дээр дараах мөрийг нэмнэ:

[.programlisting]
....
quota_enable="YES"
....

Өөрийн ноогдлын эхлүүлэлтэд сайн хяналт тавихад хэрэгтэй нэмэлт тохиргооны хувьсагчууд байдаг. Ердийн үед ачаалалтын үеэр файлын систем бүрийн ноогдлын бүрэн бүтэн байдал man:quotacheck[8] програмаар шалгагддаг. man:quotacheck[8] боломж нь ноогдлын мэдээллийн бааз дахь өгөгдөл файлын систем дээрх өгөгдлийг зөв тусгаж байгаа эсэхийг шалгаж байдаг. Энэ нь хугацаа их шаардсан процесс бөгөөд таны систем ачаалах хугацаанд мэдэгдэхүйц нөлөөлдөг. Хэрэв та энэ алхмыг алгасахыг хүсвэл энэ зорилгоор хувьсагчийг [.filename]#/etc/rc.conf# файлд тохируулах хэрэгтэй:

[.programlisting]
....
check_quotas="NO"
....

Төгсгөлд нь та файлын систем бүрийн хувьд дискний ноогдлуудыг идэвхжүүлэхийн тулд [.filename]#/etc/fstab# файлыг засварлах хэрэгтэй. Энд та хэрэглэгч эсвэл бүлгийн ноогдлууд эсвэп хоёуланг нь өөрийн бүх файлын системийн хувьд идэвхжүүлэх боломжтой юм.

Файлын систем дээр хэрэглэгч бүрийн хувьд ноогдлуудыг идэвхжүүлэхийн тулд өөрийн ноогдлууд идэвхжүүлэхийг хүсэж байгаа файлын системийн хувьд [.filename]#/etc/fstab# файлын харгалзах оруулгын options буюу тохируулгыг заах талбарт `userquota` тохируулгыг нэмж өгөх хэрэгтэй. Жишээ нь:

[.programlisting]
....
/dev/da1s2g   /home    ufs rw,userquota 1 2
....

Үүнтэй төстэйгээр бүлгийн ноогдлуудыг идэвхжүүлэхийн тулд `userquota` тохируулгын оронд `groupquota` тохируулгыг ашиглах хэрэгтэй. Хэрэглэгч болон бүлгийн ноогдлуудыг хоёуланг нь идэвхжүүлэхийн тулд оруулгыг ингэж өөрчилнө:

[.programlisting]
....
/dev/da1s2g    /home    ufs rw,userquota,groupquota 1 2
....

Анхдагчаар ноогдлын файлууд файлын системийн root санд хэрэглэгчийн ноогдлын хувьд [.filename]#quota.user#, бүлгийн ноогдлын хувьд [.filename]#quota.group# нэрээр хадгалагддаг. Дэлгэрэнгүй мэдээллийг man:fstab[5]-с үзнэ үү. man:fstab[5] гарын авлагын хуудас ноогдлын файлуудын хувьд өөр байрлалыг зааж өгч болохыг хэлдэг боловч ноогдлын төрөл бүрийн хэрэгслүүд үүнтэй зөв ажиллаж чаддаггүй болохоор ингэхийг зөвлөдөггүй юм.

Энэ үед хүрээд та өөрийн системийг шинэ цөмтэй дахин ачаалах хэрэгтэй. [.filename]#/etc/rc# нь таны [.filename]#/etc/fstab# файлд идэвхжүүлсэн бүх ноогдлуудын хувьд эхний ноогдлын файлуудыг үүсгэдэг тохирох тушаалуудыг автоматаар ажиллуулах бөгөөд ингэснээр ямар ч тэг урттай ноогдлын файлуудыг гараар үүсгэх шаардлагагүй юм.

Ердийн үйлдлүүдийн үед man:quotacheck[8], man:quotaon[8], эсвэл man:quotaoff[8] тушаалуудыг та заавал ажиллуулах ёсгүй юм. Гэхдээ тэдгээрийн хийдэг үйлдлүүдтэй танилцахын тулд тэдгээрийн гарын авлагын хуудаснуудыг уншихыг хүсэж болох юм.

=== Ноогдлын хязгаарлалтуудыг тохируулах нь

Та ноогдлыг идэвхжүүлж өөрийн системийг тохируулсны дараа тэдгээр нь яг жинхэнэдээ идэвхтэй болсон эсэхийг шалгаарай. Үүнийг хийх хялбар арга нь дараах тушаалыг ажиллуулах явдал юм:

[source,bash]
....
# quota -v
....

Та ноогдлууд идэвхжүүлэгдсэн файлын систем бүрийн хувьд дискний хэрэглээ болон тухайн үеийн ноогдлын хязгаарлалтуудын ерөнхий нэг мөр үр дүнг харах ёстой.

Та одоо man:edquota[8] тушаал ашиглан ноогдлын хязгаарлалтуудыг зааж өгч эхлэхэд бэлэн боллоо.

Хэрэглэгч эсвэл бүлгийн хуваарилж болох дискний зай болон тэд хичнээн файл үүсгэж болох хэмжээний хязгаарлалтуудыг хүчлэн зааж өгч болох хэд хэдэн сонголт танд байдаг. Та хуваарилалтыг дискний зай (блок ноогдлууд) эсвэл файлын тоо (inode ноогдлууд) эсвэл хоёулангийн хослолоор хязгаарлан өгч болно. Эдгээр хязгаарлалт бүр дараа нь хоёр зэрэглэлт хуваагддаг: энэ нь хатуу ба зөөлөн хязгаарлалтууд юм.

Хатуу хязгаарлалтаас илүү гарч болохгүй. Хэрэглэгч өөрийн хатуу хязгаарлалтад хүрэхэд асуудалтай байгаа файлын систем дээр хэрэглэгч ямар ч хуваарилалт хийж чадахгүй болно. Жишээ нь хэрэв хэрэглэгч файлын систем дээр 500 кбайт хатуу хязгаарлалттай бөгөөд 490 кбайтыг одоогоор ашиглаж байгаа бол хэрэглэгч зөвхөн 10 кбайтыг нэмж хуваарилж чадна. 11 кбайт нэмж хуваарилахыг оролдох нь амжилтгүй болох болно.

Нөгөө талаас зөөлөн хязгаарлалтууд нь тодорхой хугацааны туршид илүү гарч болно. Энэ хугацааг энэрэнгүй хугацаа гэдэг бөгөөд анхдагчаар нэг долоо хоног байдаг. Хэрэв хэрэглэгч өөрийн зөөлөн хязгаарлалтаас илүү гарсан хэвээр энэрэнгүй хугацааг өнгөрөх юм бол зөөлөн хязгаарлалт нь хатуу хязгаарлалт болж дахин хуваарилалтыг зөвшөөрдөггүй. Хэрэглэгч зөөлөн хязгаарлалтаас доош орвол энэрэнгүй хугацаа дахин тавигдах болно.

Дараах нь man:edquota[8] тушаалыг ажиллуулах үед таны харж болох гаралтын жишээ юм. man:edquota[8] тушаалыг ажиллуулахад `EDITOR` орчны хувьсагчид заагдсан засварлагч уруу эсвэл `EDITOR` хувьсагч заагдаагүй бол vi засварлагч уруу таныг оруулах бөгөөд энэ нь ноогдлын хязгаарлалтуудыг засварлах боломжийг танд олгоно.

[source,bash]
....
# edquota -u test
....

[.programlisting]
....
Quotas for user test:
/usr: kbytes in use: 65, limits (soft = 50, hard = 75)
        inodes in use: 7, limits (soft = 50, hard = 60)
/usr/var: kbytes in use: 0, limits (soft = 50, hard = 75)
        inodes in use: 0, limits (soft = 50, hard = 60)
....

Та ноогдлууд идэвхжүүлэгдсэн файлын систем бүрийн хувьд хоёр мөрийг ердийн үед харах болно. Нэг мөр нь блокийн хязгаарлалтад, нөгөө мөр нь inode хязгаарлалтад зориулагддаг. Ноогдлын хязгаарлалтуудыг өөрчлөхийн тулд та ердөө л утгыг шинэчлэхийг хүсэж байгаа утгаараа солих хэрэгтэй. Жишээ нь энэ хэрэглэгчийн блок хязгаарлалтыг зөөлөн хязгаарлалт 50, хатуу хязгаарлалт 75 байсныг зөөлөн хязгаарлалт 500 болон хатуу хязгаарлалт 600 болгон өсгөхийн тулд дараах:

[.programlisting]
....
/usr: kbytes in use: 65, limits (soft = 50, hard = 75)
....

мөрийг доорх шиг болгож өөрчлөх хэрэгтэй:

[.programlisting]
....
/usr: kbytes in use: 65, limits (soft = 500, hard = 600)
....

Таныг засварлагчаас гарсны дараа шинэ ноогдлын хязгаарлалтууд байрандаа орох болно.

Заримдаа ноогдлын хязгаарлалтуудыг зарим UID-ийн хүрээний хувьд зааж өгөх шаардлага гардаг. Үүнийг man:edquota[8] тушаалд `-p` тохируулгыг ашиглан хийдэг. Эхлээд хэрэглэгчид хүссэн ноогдлын хязгаарлалтаа зааж өгөөд дараа нь `edquota -p protouser startuid-enduid` тушаалыг ажиллуулна. Жишээ нь хэрэв хэрэглэгч `test` хүссэн ноогдлын хязгаарлалттай байгаа бол энэ ноогдлын хязгаарлалтыг 10,000-с 19,999 хүртэлх UID-уудад хувилж хамааруулахын тулд дараах тушаалыг ажиллуулна:

[source,bash]
....
# edquota -p test 10000-19999
....

Дэлгэрэнгүй мэдээллийг man:edquota[8] гарын авлагын хуудаснаас үзнэ үү.

=== Ноогдлын хязгаарлалтууд болон дискний хэрэглээг шалгах нь

Ноогдлын хязгаарлалтууд болон дискний хэрэглээг шалгахын тулд та man:quota[1] эсвэл man:repquota[8] тушаалын нэгийг ашиглаж болно. man:quota[1] тушаалыг хэрэглэгч эсвэл бүлгийн ноогдлууд болон дискний зайг шалгахад хэрэглэж болно. Хэрэглэгч нь зөвхөн өөрийн ноогдол болон өөрийн гишүүн бүлгийн ноогдлыг шалгаж чадна. Зөвхөн супер хэрэглэгч бүх хэрэглэгч болон бүлгийн ноогдлуудыг харж болно. man:repquota[8] тушаалыг ноогдлууд идэвхжүүлэгдсэн файлын системүүдийн хувьд бүх ноогдлууд болон дискний хэрэглээний ерөнхий дүнг авахад хэрэглэж болно.

Дараах нь хоёр файлын систем дээр ноогдлын хязгаарлалттай хэрэглэгчийн хувьд `quota -v` тушаалын жишээ гаралт юм.

[.programlisting]
....
Disk quotas for user test (uid 1002):
     Filesystem  usage    quota   limit   grace   files   quota   limit   grace
           /usr      65*     50      75   5days       7      50      60
       /usr/var       0      50      75               0      50      60
....

Дээрх жишээний [.filename]#/usr# файлын систем дээр хэрэглэгч 50 кбайтын зөөлөн хязгаарлалтыг 15 кбайтаар илүүдүүлсэн байгаа бөгөөд 5 хоногийн энэрэнгүй хугацаа үлдсэн байна. Од `*` тэмдэгт нь хэрэглэгч өөрийн ноогдлын хязгаарлалтаас илүү гарсныг харуулж байна.

Ердийн үед хэрэглэгч ямар ч дискний зай ашиглаагүй байгаа тийм файлын системүүд, файлын системийн хувьд ноогдлын хязгаарлалт байсан ч гэсэн man:quota[1] тушаалын гаралтад харагддаггүй байна. `-v` тохируулга нь тэдгээр файлын системүүдийг харуулах бөгөөд дээрх жишээн дээр [.filename]#/usr/var# файлын системийг харуулж байна.

=== NFS дээгүүрх ноогдлууд

Ноогдлууд нь NFS сервер дээр ноогдлын дэд системээр хянагддаг. man:rpc.rquotad[8] демон нь NFS клиентүүд дээр өөрсдийн ноогдлын статистикуудыг хэрэглэгчдэд үзэх боломжийг олгож ноогдлын мэдээллийг тэдгээр машинууд дээр man:quota[1] тушаалд бэлэн болгож өгдөг.

`rpc.rquotad`-г [.filename]#/etc/inetd.conf# файлд ингэж идэвхжүүлнэ:

[.programlisting]
....
rquotad/1      dgram rpc/udp wait root /usr/libexec/rpc.rquotad rpc.rquotad
....

Одоо `inetd`-г дахин ачаал:

[source,bash]
....
# /etc/rc.d/inetd restart
....

[[disks-encrypting]]
== Дискний хуваалтуудыг шифрлэх нь

FreeBSD нь өгөгдөлд зөвшөөрөгдөөгүй хандах хандалтын эсрэг маш сайн шууд хамгаалалтуудыг санал болгодог. Файлын зөвшөөрлүүд болон Mandatory Access Control (MAC) буюу Албадмал Хандалт Хяналт (crossref:mac[mac,Mandatory Access Control буюу Албадмал Хандалтын хяналт]-г үзнэ үү) нь компьютер ассан, үйлдлийн систем идэвхтэй байх үед зөвшөөрөлгүй гуравдагч нөхдүүдийг өгөгдөлд хандахаас хамгаалахад тусалдаг. Гэхдээ хэрэв халдагч компьютерт физик хандалт олж аван компьютерийн хатуу хөтчийг өөр систем уруу зөөн эмзэг өгөгдлийг хуулж шинжилгээ хийж чадах бол үйлдлийн системийн мөрдүүлдэг зөвшөөрлүүд нь хамааралгүй болох юм.

Халдагч хэрхэн хатуу диск эсвэл унтраасан компьютерийг эзэмшсэнээс үл хамаарч FreeBSD дээрх GEOM Based Disk Encryption (gbde) буюу GEOM дээр тулгуурласан дискний шифрлэлт болон `geli` криптограф дэд системүүд нь компьютерийн файлын системүүд дээрх өгөгдлийг бүр чухал эх үүсвэрүүд бүхий, зорилгодоо хүрэхээр ихээхэн чармайсан халдагчдаас хамгаалж чадах юм. Зөвхөн тухайн файл бүрийг шифрлэдэг ярвигтай шифрлэлтийн аргуудаас ялгаатай нь `gbde` болон `geli` нь бүх файлын системүүдийг харагдаж мэдэгдэхгүйгээр шифрлэдэг. Хатуу дискний хавтгайд цэвэр текст хэзээ ч бичигддэггүй.

=== gbde-ээр диск шифрлэх

[.procedure]
====

. `root` болно
+ 
gbde-г тохируулахад супер хэрэглэгчийн эрхүүдийг шаарддаг.
+
[source,bash]
....
% su -
Password:
....
+
. Цөмийн тохиргооны файлдаа man:gbde[4] дэмжлэгийг нэмнэ
+ 
Дараах мөрийг цөмийн тохиргооны файлдаа нэмнэ:
+ 
`options GEOM_BDE`
+ 
Цөмөө crossref:kernelconfig[kernelconfig,FreeBSD цөмийг тохируулах нь]-д тайлбарласны дагуу дахин бүтээнэ.
+ 
Шинэ цөм уруугаа дахин ачаална.
. Цөмийг дахин бүтээхээс өөр нэг арга нь `kldload` ашиглаж man:gbde[4]-г ачаалах явдал юм:
+
[source,bash]
....
# kldload geom_bde
....
====

==== Шифрлэгдсэн хатуу хөтчүүдийг бэлдэх нь

Дараах жишээ нь таныг өөрийн систем уруу шинэ хатуу хөтөч нэмж ганц шифрлэгдсэн хуваалтыг агуулна гэж тооцдог. Энэ хуваалт нь [.filename]#/private# гэж холбогдох болно. gbde нь [.filename]#/home# болон [.filename]#/var/mail#-г бас шифрлэхэд ашиглагддаг боловч энэ нь энэ танилцуулгын хүрээнээс хальж илүү төвөгтэй заавруудыг шаарддаг.

[.procedure]
====

. Шинэ хатуу хөтчийг нэмнэ
+ 
Шинэ хөтчийг систем уруу <<disks-adding>>-д тайлбарласны дагуу нэмнэ. Энэ жишээн дээр шинэ хатуу хөтчийн хуваалт [.filename]#/dev/ad4s1c# гэж нэмэгдсэн байгаа. [.filename]#/dev/ad0s1*# төхөөрөмжүүд нь жишээ систем дээр байгаа стандарт FreeBSD хуваалтуудыг харуулж байна.
+
[source,bash]
....
# ls /dev/ad*
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4
....
+
. `gbde` цоож файлуудыг агуулах санг үүсгэнэ
+
[source,bash]
....
# mkdir /etc/gbde
....
+ 
gbde цоож файл нь шифрлэгдсэн хуваалтуудад хандахад gbde-д шаардагдах мэдээллийг агуулдаг. Цоож файлд хандах боломжгүй бол gbde нь шифрлэгдсэн хуваалтын агуулсан өгөгдлийг хөндлөнгийн их хүч шаардсан оролцоогүйгээр буцааж тайлж чадахгүй юм. Үүнийг програм хангамж дэмждэггүй. Шифрлэгдсэн хуваалт бүр тусдаа цоож файл ашигладаг.
+
. `gbde` хуваалтыг эхлүүлнэ
+ 
gbde хуваалт ашиглагдаж эхлэхээсээ өмнө эхэлж тохируулагдсан байх шаардлагатай. Энэ эхний тохируулга нь зөвхөн нэг удаа хийгдэх ёстой:
+
[source,bash]
....
# gbde init /dev/ad4s1c -i -L /etc/gbde/ad4s1c.lock
....
+ 
man:gbde[8] нь загварт төрөл бүрийн тохиргооны сонголтуудыг зааж өгөх боломжийг танд өгч таны засварлагчийг онгойлгох болно. UFS1 эсвэл UFS2-той ашиглахын тулд sector_size-г 2048 гэж заана:
+
[.programlisting]
....
# $FreeBSD: src/sbin/gbde/template.txt,v 1.1.36.1 2009/08/03 08:13:06 kensmith Exp $
#
# Sector size is the smallest unit of data which can be read or written.
# Making it too small decreases performance and decreases available space.
# Making it too large may prevent filesystems from working.  512 is the
# minimum and always safe.  For UFS, use the fragment size
#
sector_size     =       2048
[...]
....
+ 
man:gbde[8] нь өгөгдлийг аюулгүй болгоход хэрэглэгдэх ёстой нэвтрэх үгийг хоёр удаа бичихийг танаас хүснэ. Нэвтрэх үг нь хоёуланд нь адил байх ёстой. gbde-ийн таны өгөгдлийг хамгаалах чадвар таны сонгосон нэвтрэх үгийн чанараас бүхэлдээ хамаарна. 
+ 
`gbde init` тушаал нь таны gbde хуваалтад зориулж цоож файлыг үүсгэх бөгөөд энэ жишээн дээр [.filename]#/etc/gbde/ad4s1c.lock# гэж хадгалагдсан байна. gbde цоож файлууд нь [.filename]#/etc/rc.d/gbde# эхлүүлэх скриптээр зөв танигдахын тулд ".lock" гэж төгсөх ёстой.
+
[CAUTION]
======

gbde цоож файлууд нь шифрлэгдсэн хуваалтуудын агуулгатай цуг нөөцлөгдөх _ёстой_. Зөвхөн цоож файлыг устгах нь шийдсэн халдагч gbde хуваалтыг буцааж тайлахаас хамгаалж чаддаггүй бөгөөд цоож файлгүйгээр хууль ёсны эзэмшигч нь шифрлэгдсэн хуваалт дээрх өгөгдөлд man:gbde[8] болон түүнийг зохиогчийн ерөөсөө дэмждэггүй, их хүч шаардсан ажиллагаагүйгээр хандаж чадахгүй болох юм.
======
+
. Шифрлэгдсэн хуваалтыг цөмд залгана
+
[source,bash]
....
# gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c.lock
....
+ 
Шифрлэгдсэн хуваалтыг эхэлж тохируулж байх үед таны сонгосон нэвтрэх үгийг оруулахыг танаас асуух болно. Шинэ шифрлэгдсэн төхөөрөмж [.filename]#/dev# дотор [.filename]#/dev/device_name.bde# гэж гарч ирнэ:
+
[source,bash]
....
# ls /dev/ad*
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4        /dev/ad4s1c.bde
....
+
. Шифрлэгдсэн төхөөрөмж дээр файлын систем үүсгэнэ
+ 
Шифрлэгдсэн төхөөрөмж цөмд залгагдсаны дараа та энэ төхөөрөмж дээр файлын систем үүсгэж болно. Шифрлэгдсэн төхөөрөмж дээр файлын систем үүсгэхийн тулд man:newfs[8]-г ашиглана. Хуучин UFS1 файлын системийг эхлүүлснээс шинэ UFS2 файлын системийг эхлүүлэх нь хамаагүй хурдан учраас man:newfs[8]-г `-O2` тохируулгатай хэрэглэхийг зөвлөдөг.
+
[source,bash]
....
# newfs -U -O2 /dev/ad4s1c.bde
....
+
[NOTE]
======
man:newfs[8] тушаал нь төхөөрөмжийн нэрэндээ [.filename]#*.bde# гэж өргөтгөлөөр танигдах залгагдсан gbde хуваалт дээр хийгдэх ёстой.
======
+
. Шифрлэгдсэн хуваалтыг холбоно
+ 
Шифрлэгдсэн файлын системд зориулж холбох цэгийг үүсгэнэ.
+
[source,bash]
....
# mkdir /private
....
+
Шифрлэгдсэн файлын системийг холбоно.
+
[source,bash]
....
# mount /dev/ad4s1c.bde /private
....
+
. Шифрлэгдсэн файлын систем байгаа эсэхийг шалгана
+ 
Шифрлэгдсэн файлын систем одоо man:df[1]-д харагдаж ашиглахад бэлэн болох ёстой.
+
[source,bash]
....
% df -H
Filesystem        Size   Used  Avail Capacity  Mounted on
/dev/ad0s1a      1037M    72M   883M     8%    /
/devfs            1.0K   1.0K     0B   100%    /dev
/dev/ad0s1f       8.1G    55K   7.5G     0%    /home
/dev/ad0s1e      1037M   1.1M   953M     0%    /tmp
/dev/ad0s1d       6.1G   1.9G   3.7G    35%    /usr
/dev/ad4s1c.bde   150G   4.1K   138G     0%    /private
....
====

==== Байгаа шифрлэгдсэн файлын системүүдийг холбох нь

Ачаалалт бүрийн дараа ямар ч шифрлэгдсэн файлын системүүдийг ашиглаж эхлэхээсээ өмнө цөмд дахин залгаж, алдааг нь шалгаж холбож болно. Шаардлагатай тушаалуудыг `root` хэрэглэгч ажиллуулах ёстой гэж үздэг.

[.procedure]
====

. `gbde` хуваалтыг цөмд залгана
+
[source,bash]
....
# gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c.lock
....
+ 
Шифрлэгдсэн gbde хуваалтыг эхэлж тохируулж байх үед таны сонгосон нэвтрэх үгийг оруулахыг танаас асуух болно.
. Файлын систем дээр алдааг шалгана
+ 
Шифрлэгдсэн файлын системүүд нь автоматаар холбогдохын тулд [.filename]#/etc/fstab# файлд одоохондоо жагсаагдах боломжгүй учир файлын системүүд дээр алдаа байгаа эсэхийг шалгаж тэдгээрийг холбохоос өмнө man:fsck[8]-г гараар ажиллуулах ёстой.
+
[source,bash]
....
# fsck -p -t ffs /dev/ad4s1c.bde
....
+
. Шифрлэгдсэн файлын системийг холбоно
+
[source,bash]
....
# mount /dev/ad4s1c.bde /private
....
+ 
Шифрлэгдсэн файлын систем одоо ашиглахад бэлэн боллоо.
====

===== Шифрлэгдсэн хуваалтуудыг автоматаар холбох нь

Шифрлэгдсэн хуваалтыг автоматаар залган шалгаж холбох скриптийг үүсгэж болох боловч аюулгүй байдлын шалтгаанаас болоод скрипт нь man:gbde[8] нууц үгийг агуулсан байх ёсгүй. Харин эдгээр скриптүүдийг гараар ажиллуулж нууц үгийг консол эсвэл man:ssh[1]-ээр оруулахыг зөвлөдөг.

Өөр нэг арга нь [.filename]#rc.d# скрипт байдаг. Энэ скриптийн нэмэлт өгөгдлүүдийг man:rc.conf[5]-оор дамжуулж болно, жишээ нь:

[.programlisting]
....
gbde_autoattach_all="YES"
gbde_devices="ad4s1c"
gbde_lockdir="/etc/gbde"
....

Энэ нь gbde нэвтрэх үгийг ачаалах үед оруулахыг шаарддаг. Зөв нэвтрэх үгийг бичсэний дараа gbde шифрлэгдсэн хуваалт автоматаар холбогдох болно. Энэ нь gbde-г зөөврийн компьютер дээр хэрэглэж байгаа үед их ашигтай байдаг.

==== `gbde`-ийн ажиллуулдаг криптограф хамгаалалтууд

man:gbde[8] нь 128-bit AES-ийг CBC горимд ашиглан сектор ачааг шифрлэдэг. Диск дээрх сектор бүр өөр өөр AES түлхүүрээр шифрлэгддэг. Секторын түлхүүрүүд хэрэглэгчийн оруулсан нэвтрэх үгээс хэрхэн гаргагддаг зэрэг gbde-ийн криптограф дизайны талаар дэлгэрэнгүйг man:gbde[4]-ээс үзнэ үү.

==== Нийцтэй байдлын асуудлууд

man:sysinstall[8] нь gbde-шифрлэгдсэн төхөөрөмжүүдтэй нийцгүй байдаг. Бүх [.filename]#*.bde# төхөөрөмжүүдийг man:sysinstall[8] эхлүүлэхээс өмнө цөмөөс салгасан байх ёстой бөгөөд ингэхгүй бол энэ нь төхөөрөмжүүдийг шалгаж эхлэхдээ сүйрэх болно. Бидний жишээн дээр ашиглагдсан шифрлэгдсэн төхөөрөмжийг салгахдаа дараах тушаалыг ашиглана:

[source,bash]
....
# gbde detach /dev/ad4s1c
....

Мөн man:vinum[4] нь man:geom[4] дэд системийг ашигладаггүйг анхаараарай, та gbde-г vinum эзлэхүүнүүдтэй ашиглаж болохгүй.

=== `geli`-ээр диск шифрлэх нь

Шинэ криптограф GEOM ангилал `geli` гэж бий. Үүнийг одоогоор {pjd} хөгжүүлж байгаа болно. `geli` нь `gbde`-ээс өөр бөгөөд энэ нь өөр боломжуудыг санал болгож криптограф үйлдэлдээ өөр схемийг ашигладаг.

man:geli[8]-ийн хамгийн чухал боломжууд бол:

* man:crypto[9] тогтолцоог ашигладаг - криптограф тоног төхөөрөмж бэлэн болоход `geli` түүнийг автоматаар ашигладаг.
* Олон криптограф алгоритмуудыг дэмждэг (одоогоор AES, Blowfish, болон 3DES).
* root хуваалтыг шифрлэх боломжийг олгодог. Шифрлэгдсэн root хуваалтад хандахад хэрэглэгддэг нэвтрэх үгийг систем ачаалахад асуудаг.
* Бие биеэндээ хамааралгүй хоёр түлхүүрүүдийг ашиглахыг зөвшөөрдөг (өөрөөр хэлбэл "key" болон "company key").
* `geli` нь хурдан байдаг. Энгийн сектороос сектор уруу шифрлэлтийг хийдэг.
* Мастер түлхүүрүүдийг нөөцлөх ба сэргээхийг зөвшөөрдөг. Хэрэглэгч өөрийн түлхүүрүүдийг устгах хэрэгтэй болоход нөөцөөс түлхүүрүүдийг сэргээж өгөгдөлд дахин хандах боломжтой болох юм.
* Дискийг санамсаргүй, нэг удаагийн түлхүүрээр залгахыг зөвшөөрдөг - энэ нь swap хуваалтууд болон түр зуурын файлын системүүдэд ашигтай байдаг.

`geli`-ийн илүү боломжуудыг man:geli[8]-ийн гарын авлагын хуудаснаас олж болно.

Дараагийн алхмууд нь `geli`-ийн дэмжлэгийг FreeBSD цөмд хэрхэн идэвхжүүлэхийг тайлбарлах бөгөөд шинэ `geli` шифрлэлт үзүүлэгчийг хэрхэн үүсгэх болон ашиглах талаар өгүүлэх болно.

Цөмд өөрчлөлтүүд шаардлагатай учраас супер хэрэглэгчийн эрхүүд хэрэгтэй болно.

[.procedure]
====

. Цөмд `geli` дэмжлэгийг нэмэх нь
+ 
Дараах мөрийг цөмийн тохиргооны файлд нэмнэ:
+
[.programlisting]
....
options GEOM_ELI
device crypto
....
+ 
Цөмөө crossref:kernelconfig[kernelconfig,FreeBSD цөмийг тохируулах нь]-д тайлбарласны дагуу дахин бүтээнэ.
+ 
Мөн `geli` модулийг ачаалах үед дуудаж болно. Дараах мөрийг [.filename]#/boot/loader.conf# файлд нэмнэ:
+
[.programlisting]
....
geom_eli_load="YES"
....
+ 
man:geli[8] нь одоо цөмд дэмжигдсэн байх ёстой.
+
. Мастер түлхүүр үүсгэх нь
+ 
Дараах жишээ нь түлхүүр файлыг хэрхэн үүсгэх талаар тайлбарлах бөгөөд энэ нь [.filename]#/private# доор холбогдсон шифрлэгдсэн үзүүлэгчийн Мастер түлхүүрийн хэсэг болон ашиглагдах болно. Түлхүүр файл нь Мастер түлхүүрийг шифрлэхэд хэрэглэгдэх зарим санамсаргүй өгөгдлийг өгөх болно. Мастер түлхүүр нь нэвтрэх үгээр бас хамгаалагдах болно. Үзүүлэгчийн секторын хэмжээ 4kB том байх болно. Мөн энэ хэлэлцүүлэг нь `geli` үзүүлэгчийг хэрхэн залгаж түүн дээр файлын систем үүсгэх, хэрхэн түүнийг холбож ажиллах болон төгсгөлд нь хэрхэн салгах талаар тайлбарлах болно.
+ 
Илүү сайн ажиллагааг хангахын тулд секторын том хэмжээг (4kB ч юм уу) ашиглахыг зөвлөдөг.
+ 
Мастер түлхүүр нь нэвтрэх үгээр хамгаалагдах бөгөөд түлхүүр файлд зориулагдсан өгөгдлийн эх нь [.filename]#/dev/random# байх болно. Бидний үзүүлэгч гэж нэрлэдэг [.filename]#/dev/da2.eli#-ийн секторын хэмжээ 4kB байх болно.
+
[source,bash]
....
# dd if=/dev/random of=/root/da2.key bs=64 count=1
# geli init -s 4096 -K /root/da2.key /dev/da2
Enter new passphrase:
Reenter new passphrase:
....
+ 
Нэвтрэх үг болон түлхүүр файлыг хоёуланг нь заавал ашиглах шаардлагагүй; Мастер түлхүүрийг нууцлах аль ч аргыг тусад нь ашиглаж болно.
+ 
Хэрэв түлхүүр файл "-" гэж өгөгдсөн бол стандарт оролтыг ашиглана. Энэ жишээ нь нэгээс олон түлхүүр файлыг хэрхэн ашиглаж болох талаар харуулж байна.
+
[source,bash]
....
# cat keyfile1 keyfile2 keyfile3 | geli init -K - /dev/da2
....
+
. Үзүүлэгчийг үүсгэсэн түлхүүрийн тусламжтай залгах нь
+
[source,bash]
....
# geli attach -k /root/da2.key /dev/da2
Enter passphrase:
....
+ 
Шинэ цэвэр текст төхөөрөмж [.filename]#/dev/da2.eli# гэж нэрлэгдэх болно.
+
[source,bash]
....
# ls /dev/da2*
/dev/da2  /dev/da2.eli
....
+
. Шинэ файлын системийг үүсгэх нь
+
[source,bash]
....
# dd if=/dev/random of=/dev/da2.eli bs=1m
# newfs /dev/da2.eli
# mount /dev/da2.eli /private
....
+ 
Шифрлэгдсэн файлын систем man:df[1]-д харагдаж ашиглахад бэлэн болох ёстой:
+
[source,bash]
....
# df -H
Filesystem     Size   Used  Avail Capacity  Mounted on
/dev/ad0s1a    248M    89M   139M    38%    /
/devfs         1.0K   1.0K     0B   100%    /dev
/dev/ad0s1f    7.7G   2.3G   4.9G    32%    /usr
/dev/ad0s1d    989M   1.5M   909M     0%    /tmp
/dev/ad0s1e    3.9G   1.3G   2.3G    35%    /var
/dev/da2.eli   150G   4.1K   138G     0%    /private
....
+
. Үзүүлэгчийг холбосныг салгаж залгасныг болиулах
+ 
Шифрлэгдсэн хуваалт дээрх ажил хийгдэж дуусаад [.filename]#/private# хуваалт хэрэггүй болох үед `geli` шифрлэгдсэн хуваалтыг холбосноо салган цөмд залгаснаа бас салгах нь зүйтэй юм.
+
[source,bash]
....
# umount /private
# geli detach da2.eli
....
====

man:geli[8]-ийг хэрэглэх тухай дэлгэрэнгүй мэдээллийг гарын авлагын хуудаснаас олж болно.

==== [.filename]#geli# [.filename]#rc.d# скриптийг ашиглах нь

`geli` нь `geli`-ийн хэрэглээг хялбаршуулахад ашиглаж болох [.filename]#rc.d# скрипттэй цуг ирдэг. `geli`-г man:rc.conf[5]-оор тохируулах жишээг дараахаас харж болно:

[.programlisting]
....
geli_devices="da2"
geli_da2_flags="-p -k /root/da2.key"
....

Энэ нь [.filename]#/dev/da2#-г Мастер түлхүүр файл нь [.filename]#/root/da2.key#-д байрлах `geli` үзүүлэгч гэж тохируулах бөгөөд үзүүлэгчийг залгаж байхдаа `geli` нь нэвтрэх үгийг ашиглахгүй (хэрэв `-P` сонголт `geli init` хийгдэх үед өгөгдсөн тохиолдолд энэ нь ашиглагдах боломжтой). Систем нь `geli` үзүүлэгчийг цөмөөс систем унтрахаас өмнө салгах болно.

[.filename]#rc.d#-г тохируулах талаар дэлгэрэнгүй мэдээлэл энэхүү гарын авлагын crossref:config[configtuning-rcd,rc.d] хэсэгт байгаа болно.

[[swap-encrypting]]
== Swap зайг шифрлэх

FreeBSD дээрх swap-ийн шифрлэлт нь тохируулахад амархан байдаг. FreeBSD-ийн аль хувилбарыг ашиглаж байгаагаас хамаараад өөр өөр тохируулгууд байдаг бөгөөд тохиргоо нь нэлээн өөр өөр байдаг. man:gbde[8] эсвэл man:geli[8] шифрлэх системүүдийг swap-ийг шифрлэхэд ашиглаж болно. Энэ хоёр систем нь хоёулаа [.filename]#encswap# crossref:config[configtuning-rcd,rc.d] скриптийг ашигладаг.

Өмнөх <<disks-encrypting,Дискний хуваалтуудыг шифрлэх>> хэсэг нь өөр өөр шифрлэх системүүдийн тухай богино хэлэлцүүлгийг агуулдаг.

=== Swap яагаад шифрлэгдэх ёстой вэ?

Дискний хуваалтуудын шифрлэлтийн нэгэн адил swap зайн шифрлэлт нь эмзэг мэдээллийг хамгаалахын тулд хийгддэг. Нууц үгстэй ажилладаг програм байлаа гэж бодъё. Эдгээр нууц үгс нь физик санах ойд байгаа үед бүгд зүгээр байна. Гэхдээ хэрэв үйлдлийн систем нь бусад програмуудад зориулж зайг чөлөөлөхийн тулд санах ойн хуудаснуудыг swap хийж эхэлбэл нууц үгс нь дискний хавтгай дээр шифрлэгдэлгүй бичигдэж болох бөгөөд энэ нь өрсөлдөгчийн хувьд олж авахад амархан болох юм. Swap зайг шифрлэх нь энэ тохиолдолд шийдэл болж болох юм.

=== Бэлтгэл

[NOTE]
====
Энэ хэсгийн үлдсэн хэсэгт [.filename]#ad0s1b# нь swap хуваалт байх болно.
====

Энэ хүртэл swap нь шифрлэгдээгүй байгаа билээ. Аль хэдийн нууц үгс эсвэл бусад эмзэг өгөгдөл дискний хавтгайнууд дээр цэвэр текстээр байж болзошгүй юм. Үүнийг засварлахын тулд swap хуваалт дээрх өгөгдлийг санамсаргүй хаягдлаар дарж бичих хэрэгтэй:

[source,bash]
....
# dd if=/dev/random of=/dev/ad0s1b bs=1m
....

=== man:gbde[8] ашиглан swap шифрлэлт хийх

`.bde` дагаварыг [.filename]#/etc/fstab#-ийн тохирох swap мөр дэх төхөөрөмжид нэмэх шаардлагатай:

[.programlisting]
....
# Device                Mountpoint      FStype  Options         Dump    Pass#
/dev/ad0s1b.bde         none            swap    sw              0       0
....

=== man:geli[8] ашиглан swap шифрлэлт хийх

Өөрөөр, swap шифрлэлтэд зориулж man:geli[8]-г ашиглах процедур нь man:gbde[8] ашиглахтай төстэй. `.eli` дагаварыг [.filename]#/etc/fstab#-ийн тохирох swap мөр дэх төхөөрөмжид нэмэх шаардлагатай:

[.programlisting]
....
# Device                Mountpoint      FStype  Options         Dump    Pass#
/dev/ad0s1b.eli         none            swap    sw              0       0
....

man:geli[8] нь AES алгоритмийг анхдагчаар 128 битийн урттай түлхүүртэй ашигладаг.

Мөн эдгээр анхдагчуудыг [.filename]#/etc/rc.conf# файлд `geli_swap_flags` тохируулгыг ашиглан өөрчилж болно. Дараах мөр нь [.filename]#encswap# rc.d скриптийг "detach on last close" тохируулгыг зааж 4 килобайтын секторын хэмжээтэй, 128 бит түлхүүрийн урттайгаар Blowfish алгоритм ашиглан man:geli[8] swap хуваалт үүсгэ гэж хэлж байна:

[.programlisting]
....
geli_swap_flags="-e blowfish -l 128 -s 4096 -d"
....

man:geli[8] гарын авлагын хуудсан дахь `onetime` тушаалын тайлбараас боломжит тохируулгуудын жагсаалтыг лавлана уу.

=== Ажиллаж байгаа эсэхийг шалгах

Систем дахин ачаалагдсаны дараа шифрлэгдсэн swap-ийн зөв үйлдлийг `swapinfo` тушаал ашиглан шалгаж болно.

Хэрэв man:gbde[8] ашиглагдаж байвал:

[source,bash]
....
% swapinfo
Device          1K-blocks     Used    Avail Capacity
/dev/ad0s1b.bde    542720        0   542720     0%
....

Хэрэв man:geli[8] ашиглагдаж байвал:

[source,bash]
....
% swapinfo
Device          1K-blocks     Used    Avail Capacity
/dev/ad0s1b.eli    542720        0   542720     0%
....

[[disks-hast]]
== Highly Available Storage (HAST)

=== Ерөнхий зүйл

Байнгын бэлэн ажиллагаатай байх (High-availability) нь бизнесийн чухал програм хангамжуудын хувьд хамгийн гол шаардлага бөгөөд тийм хадгалалтын төхөөрөмж нь уг орчны түлхүүр хэсэг юм. Highly Available STorage буюу HAST-г {pjd} хөгжүүлсэн бөгөөд энэ нь өгөгдлийг TCP/IP сүлжээнд холбогдсон хэд хэдэн тусдаа байгаа машинууд дээр тунгалгаар хадгалах боломжийг бүрдүүлдэг. HAST-г сүлжээний RAID1 (толь) гэж ойлгож болох бөгөөд GNU/Linux(R) тавцангийн хувьд байдаг DRBD(R) хадгалалтын системтэй төстэй юм. CARP зэрэг FreeBSD-н бусад байнгын бэлэн ажиллагааг хангагч боломжуудын хамтаар HAST нь тоног төхөөрөмжийн эвдрэлээс ангид байнгын бэлэн ажиллагаатай хадгалалтын кластер бүтээх боломжийг бүрдүүлдэг.

Энэ хэсгийг уншаад та дараах зүйлсийг мэдэх болно:

* HAST гэж юу болох, хэрхэн ажилладаг болон ямар боломжуудыг хангадаг талаар.
* FreeBSD дээр HAST-г хэрхэн тохируулж ашиглах талаар.
* CARP болон man:devd[8]-г хэрхэн тохируулж уян хатан хадгалалтын систем бүтээх талаар.

Энэ хэсгийг уншихаасаа өмнө та дараах зүйлсийг мэдсэн байх шаардлагатай:

* UNIX(R) болон FreeBSD-ийн үндсийг ойлгосон байх (crossref:basics[basics,Юниксийн үндэс]).
* Сүлжээний интерфэйсүүд болон FreeBSD-н бусад гол дэд системүүдийг хэрхэн тохируулах талаар мэддэг байх (crossref:config[config-tuning,Тохиргоо ба Тааруулалт]).
* FreeBSD-н сүлжээний талаар сайн мэддэг байх (crossref:partiv[network-communication,Сүлжээний Холболт]).
* FreeBSD 8.1-RELEASE буюу түүнээс хойшхи хувилбарыг ашиглах.

HAST төслийг FreeBSD сан http://www.omc.net/[OMCnet Internet Service GmbH] болон http://www.transip.nl/[TransIP BV]-н дэмжлэгтэйгээр санхүүжүүлжээ.

=== HAST-н боломжууд

HAST системийн гол боломжуудад:

* Локал хатуу дискний хөтчүүд дээрх I/O алдаануудыг халхлахад ашиглаж болох боломж.
* FreeBSD-н дэмждэг дурын файлын системийг ашиглах боломжийг бүрдүүлдэг файлын системээс үл хамаарсан байдал.
* Тухайн цэг унасан байх үед зөвхөн өөрчлөгдсөн блокуудыг синхрончлох замаар үр ашигтай, хурдан дахин синхрончлох боломж.
* Нэмэлт нөөц бололцоог нэмэхийн тулд аль хэдийн бий болгосон орчинд ашиглах боломж.
* CARP, Heartbeat эсвэл бусад хэрэгслүүдийн хамтаар уян хатан, бөх бат хадгалалтын системийг бүтээхэд цуг ашиглаж боломж.

=== HAST-н ажиллагаа

HAST нь дурын хадгалалтын төхөөрөмжийн хувьд блок түвшний синхрон олшруулалтыг хэд хэдэн машин уруу хийдэг болохоор хамгийн багадаа хоёр цэг (физик машинууд) шаарддаг - Эдгээр нь `анхдагч` (бас `мастер` гэгддэг) цэг болон `хоёрдогч` (`боол`) цэг юм. Энэ хоёр машиныг хамтад нь кластер гэж дуудах болно.

[NOTE]
====
HAST нь одоогоор хоёр кластерын цэгээр хязгаарлагдсан байгаа.
====

HAST нь анхдагч-хоёрдогч тохиргоогоор ажилладаг болохоор тухайн үед зөвхөн нэг кластерын цэгийг идэвхтэй байхыг зөвшөөрдөг. `анхдагч` цэг буюу `актив` нь HAST-р удирдуулсан төхөөрөмжүүдэд хандах I/O хүсэлтүүдтэй ажилладаг цэг юм. `хоёрдогч` цэг нь дараа нь `primary` цэгээсээ автоматаар синхрончлогддог.

HAST системийн физик хэсгүүд нь:

* локал диск (анхдагч цэг дээрх)
* алсын машин дээрх диск (хоёрдогч цэг)

HAST нь блок түвшинд синхроноор ажилладаг бөгөөд энэ нь файлын системүүд болон програм хангамжуудын хувьд тунгалаг болгодог. HAST нь бусад хэрэгслүүд эсвэл програм хангамжуудад ашиглах боломжтойгоор [.filename]#/dev/hast/# санд ердийн GEOM үйлчилгээ үзүүлэгчдээр хангадаг бөгөөд ингэснээр HAST-р хангагдсан төхөөрөмжүүд болон түүхий дискнүүд, хуваалтууд гэх зэргүүдийн хооронд ялгаа байхгүй болдог байна.

Бичих, устгах, эсвэл flush үйлдэл бүрийг локал диск болон алсын диск рүү TCP/IP ашиглан илгээдэг. Унших үйлдэлд локал диск дээрх мэдээлэл шинэ биш эсвэл I/O алдаа гараагүй л бол локал дискнээс хариу өгдөг. Хэрэв тийм тохиолдол байвал унших үйлдлийг хоёрдогч цэг рүү илгээдэг.

==== Синхрончлол ба Олшруулалтын горимууд

HAST нь унасан байдлаас хурдан сэргээх боломжийг бий болгохыг оролддог. Энэ зорилгоор цэг унасны дараа синхрончлох хугацааг багасгах нь хамгийн чухал юм. Синхрончлолыг хурдан хангахын тулд HAST нь диск дээрх бохир өгөгдлүүдийн битмапыг зохицуулж байдаг бөгөөд ердийн синхрончлолын үед зөвхөн тэдгээрийг синхрончилдог (эхний синхрончлолыг тооцолгүйгээр).

Синхрончлолтой ажиллах олон аргууд байдаг. HAST нь янз бүрийн синхрончлолын аргуудтай (доор дурдсан) ажиллахын тулд хэд хэдэн олшруулалтын горимыг хийдэг:

* _memsync_: локал бичих үйлдэл дууссан ба алсын цэг өгөгдөл ирснийг баталгаажуулсан бөгөөд өгөгдлийг яг хадгалахаас өмнөх үед бичих үйлдэл дууссан гэж үздэг. Алсын цэг дээрх өгөгдөл баталгаажуулалт илгээгдсэний дараа хадгалагддаг. Энэ горим нь саатлыг багасгах зориулалттай бөгөөд маш сайн найдвартай байдлыг хангадаг. _memsync_ олшруулалтын горим нь одоогоор хийгдээгүй байгаа.
* _fullsync_: локал болон алсын бичих үйлдэл хийгдэж дууссаны дараа бичих үйлдэл дууссан гэж үздэг. Энэ нь хамгийн найдвартай бөгөөд удаан горим юм. Энэ горим нь анхдагч байдаг.
* _async_: локал бичих үйлдэл дууссан үед бичих үйлдлийг дууссан гэж үздэг. Энэ нь хамгийн хурдан бөгөөд аюултай олшруулалтын горим юм. Энэ горимыг бусад горимын хувьд саатал хэтэрхий өндөр байгаа алсын цэг рүү олшруулахдаа ашиглах ёстой. _async_ олшруулалтын горим одоогоор хийгдээгүй байгаа.

[WARNING]
====

Зөвхөн _fullsync_ олшруулалтын горим одоогоор дэмжигдсэн.
====

=== HAST-н тохиргоо

HAST нь ажиллахын тулд `GEOM_GATE` дэмжлэгийг шаарддаг. `GENERIC` цөм нь анхдагчаар `GENERIC`-г _агуулдаггүй_ боловч FreeBSD-н анхдагч суулгацад дуудагдах боломжтой [.filename]#geom_gate.ko# модуль байдаг. Мөн дараах мөрийг цөмийн тохиргооны файлд нэмэн `GEOM_GATE` дэмжлэгийг цөмд оруулан бүтээж болдог:

[.programlisting]
....
options	GEOM_GATE
....

HAST тогтолцоо нь үйлдлийн системийн өнцгөөс харахад хэд хэдэн хэсгээс тогтдог:

* өгөгдлийн синхрончлолд зориулсан man:hastd[8] демон,
* хэрэглэгчийн талбарын удирдлагын хэрэгсэл man:hastctl[8],
* man:hast.conf[5] тохиргооны файл.

Дараах жишээ хоёр цэгийг `мастер`-`боол` / `анхдагч`-`хоёрдогч` үйлдлийн хувьд өгөгдлийг уг хоёр цэгийн хооронд олшруулахын тулд HAST ашиглан тохируулах талаар тайлбарлана. Цэгүүдийг _172.16.0.1_ IP хаягтай `hasta` болон _172.16.0.2_ IP хаягтай `hastb` гэж нэрлэе. Эдгээр цэгүүд нь HAST үйлдлийн хувьд ижил хэмжээтэй өөр өөрийн [.filename]#/dev/ad6# хатуу дисктэй байна. HAST нөөцийг (заримдаа эх үүсвэр гэгддэг, өөрөөр хэлбэл [.filename]#/dev/hast/# дахь GEOM үйлчилгээ үзүүлэгч) [.filename]#test# гэж нэрлэнэ.

HAST-н тохиргоог [.filename]#/etc/hast.conf# файлд хийнэ. Энэ файл нь хоёр цэг дээр ижил байх ёстой. Боломжит хамгийн хялбар тохиргоо дараах байдалтай байна:

[.programlisting]
....
resource test {
	on hasta {
		local /dev/ad6
		remote 172.16.0.2
	}
	on hastb {
		local /dev/ad6
		remote 172.16.0.1
	}
}
....

Илүү дэлгэрэнгүй тохиргооны талаар man:hast.conf[5] гарын авлагаас үзнэ үү.

[TIP]
====

Мөн `remote` гэсэн хэсэгт хостын нэрийг ашиглаж бас болно. Тэр тохиолдолд тэдгээр хостуудыг таних боломжтой байх ёстойг анхаараарай, өөрөөр хэлбэл тэдгээр нь [.filename]#/etc/hosts# файл юм уу эсвэл локал DNS дээр тодорхойлогдсон байх ёстой.
====

Одоо хоёр цэг дээр тохиргоо байгаа болохоор HAST нөөцийг үүсгэх боломжтой. Хоёр цэг дээр дараах тушаалыг ажиллуулж эхний мета өгөгдлийг локал диск дээр байрлуулж man:hastd[8] демонг ажиллуулна:

[source,bash]
....
# hastctl create test
# /etc/rc.d/hastd onestart
....

[NOTE]
====
GEOM үйлчилгээ үзүүлэгчдийг одоо байгаа файлын систем дээр ашиглаж _болохгүй_ (жишээ нь HAST-р удирдуулсан нөөц рүү одоо байгаа хадгалалтын төхөөрөмжийг хувиргах). Учир нь энэ процедур нь ямар нэг мета өгөгдлийг үйлчилгээ үзүүлэгч дээр хадгалах хэрэгтэй байдаг бөгөөд шаардлагатай зай хангалттай байхгүй байх болно.
====

HAST цэгийн үүргийг (`анхдагч` эсвэл `хоёрдогч`) администратор тохируулах юм уу эсвэл man:hastctl[8] хэрэгсэл ашиглан Heartbeat зэрэг бусад програмаар тохируулж болно. Анхдагч цэг рүү (`hasta`) шилжээд дараах тушаалыг өгнө:

[source,bash]
....
# hastctl role primary test
....

Үүнтэй адилаар хоёрдогч цэг дээр (`hastb`) дараах тушаалыг ажиллуулна:

[source,bash]
....
# hastctl role secondary test
....

[CAUTION]
====

Хоёр цэг хоорондоо холбогдож чадахгүй бөгөөд хоёулаа анхдагч гэж тохируулагдсан бол үүнийг `split-brain` гэж нэрлэдэг. Энэ тохиолдолд алдааг олж засварлахын тулд <<disks-hast-sb>> хэсэгт зааснаар ажиллана.
====

Цэг бүр дээр man:hastctl[8] хэрэгсэл ашиглан үр дүнг шалгаж болно:

[source,bash]
....
# hastctl status test
....

Хамгийн чухал текст нь `status` мөр бөгөөд хоёр цэг дээр `complete` гэж байх ёстой. Хэрэв энэ нь `degraded` гэж байх юм бол ямар нэг юм болохоо больсныг илтгэнэ. Энэ үед цэгүүдийн хооронд синхрончлол явагдаад эхэлчихсэн байна. `hastctl status` тушаал `dirty` гэдэг дээр 0 байт харуулж байвал синхрончлол дууссан гэсэн үг юм.

Дараагийн алхам бол [.filename]#/dev/hast/test# GEOM үйлчилгээ үзүүлэгч дээр файлын систем үүсгэж холбох явдал юм. Үүнийг `анхдагч` цэг (учир нь [.filename]#/dev/hast/test# зөвхөн `primary` цэг дээр харагдана) дээр хийх ёстой. Хатуу дискийн хэмжээнээс хамаарч хэдэн минут үргэлжилж болох юм:

[source,bash]
....
# newfs -U /dev/hast/test
# mkdir /hast/test
# mount /dev/hast/test /hast/test
....

HAST тогтолцоог зөв тохируулсны дараа хамгийн сүүлийн алхам бол HAST систем ачаалах үед автоматаар эхэлсэн байхыг шалгах явдал юм. Дараах мөрийг [.filename]#/etc/rc.conf# файлд нэмж өгөх шаардлагатай:

[.programlisting]
....
hastd_enable="YES"
....

==== Нэгээс нөгөөд шилжих тохиргоо

Энэ жишээний зорилго нь өгөгдсөн дурын цэг ажиллахаа больсон тохиолдолд ажиллаж байх уян хатан хадгалалтын систем бүтээх явдал юм. Кластерын `анхдагч` цэг ажиллахаа болих тохиолдол байж болно. Хэрэв ийм явдал боллоо гэхэд `хоёрдогч` цэг сааталгүйгээр авч ажиллан файлын системийг шалган холбож өгөгдлийн нэг ч битийг алдалгүйгээр үргэлжлүүлэн ажиллах ёстой.

Энэ зорилтод хүрэхийн тулд FreeBSD-ийн IP давхарга дээр автоматаар шилжих боломжийг бүрдүүлдэг CARP-г ашиглах шаардлагатай байдаг. CARP (Common Address Redundancy Protocol) ижил сүлжээнд олон хостууд IP хаяг хуваалцаж хэрэглэх боломжийг бүрдүүлдэг. CARP-г кластерын цэг бүр дээр crossref:advanced-networking[carp,Common Address Redundancy Protocol (CARP)] хэсэгт зааснаар тохируулна. Үүнийг хийсний дараа цэг бүр хуваалцсан IP _172.16.0.254_ гэсэн хаягтай [.filename]#carp0# гэсэн интерфэйстэй байх болно. Кластерын анхдагч HAST цэг мастер CARP цэг байх ёстой.

Өмнөх хэсэгт үүсгэсэн HAST нөөц сүлжээн дэх бусад хостууд руу экспорт хийгдэхэд бэлэн болсон байна. Үүнийг NFS, Samba гэх мэтүүдийн тусламжтайгаар хуваалцсан IP хаяг _172.16.0.254_ ашиглан экспорт хийх замаар хийнэ. Шийдэгдээгүй цор ганц асуудал бол анхдагч цэг унахад автоматаар шилжих асуудал юм.

Хэрэв CARP интерфэйсүүд унаж босоод байвал FreeBSD үйлдлийн систем man:devd[8] үйл явдал гаргах бөгөөд энэ нь CARP интерфэйсүүд дээр төлвийг харах боломжийг бүрдүүлдэг. CARP интерфэйс дээрх төлвийн өөрчлөлт нь аль нэг цэг ажиллахаа байсан эсвэл ажиллаж эхэлснийг харуулна. Эдгээр төлвийн өөрчлөлт нь HAST шилжилтийг автоматаар зохицуулах тусгай скриптийг ажиллуулах боломжтой юм.

CARP интерфэйсүүд дээрх төлвийн өөрчлөлтүүдийг барьж чадахын тулд дараах тохиргоог цэг бүр дээр [.filename]#/etc/devd.conf# файлд хийж өгөх ёстой:

[.programlisting]
....
notify 30 {
	match "system" "IFNET";
	match "subsystem" "carp0";
	match "type" "LINK_UP";
	action "/usr/local/sbin/carp-hast-switch master";
};

notify 30 {
	match "system" "IFNET";
	match "subsystem" "carp0";
	match "type" "LINK_DOWN";
	action "/usr/local/sbin/carp-hast-switch slave";
};
....

Шинэ тохиргоог идэвхтэй болгохын тулд man:devd[8]-г цэг бүр дээр дахин ажиллуулна:

[source,bash]
....
# /etc/rc.d/devd restart
....

[.filename]#carp0# интерфэйс унаж босож байгаа тохиолдолд (өөрөөр хэлбэр интерфэйсийн төлөв өөрчлөлгдсөн тохиолдолд) систем мэдээлэл өгөх бөгөөд энэ нь man:devd[8] дэд системд скрипт ажиллуулах боломжийг бүрдүүлэх бөгөөд энэ тохиолдолд [.filename]#/usr/local/sbin/carp-hast-switch# байна. Энэ скрипт нь автоматаар шилжих шилжилтийг зохицуулах юм. Дээрх man:devd[8] тохиргооны талаар дэлгэрэнгүйг man:devd.conf[5] гарын авлагаас үзнэ үү.

Ийм скриптийн жишээ дараах байдлаар байж болох юм:

[.programlisting]
....
#!/bin/sh

# Original script by Freddie Cash <fjwcash@gmail.com>
# Modified by Michael W. Lucas <mwlucas@BlackHelicopters.org>
# and Viktor Petersson <vpetersson@wireload.net>

# The names of the HAST resources, as listed in /etc/hast.conf
resources="test"

# delay in mounting HAST resource after becoming master
# make your best guess
delay=3

# logging
log="local0.debug"
name="carp-hast"

# end of user configurable stuff

case "$1" in
	master)
		logger -p $log -t $name "Switching to primary provider for ${resources}."
		sleep ${delay}

		# Wait for any "hastd secondary" processes to stop
		for disk in ${resources}; do
			while $( pgrep -lf "hastd: ${disk} \(secondary\)" > /dev/null 2>&1 ); do
				sleep 1
			done

			# Switch role for each disk
			hastctl role primary ${disk}
			if [ $? -ne 0 ]; then
				logger -p $log -t $name "Unable to change role to primary for resource ${disk}."
				exit 1
			fi
		done

		# Wait for the /dev/hast/* devices to appear
		for disk in ${resources}; do
			for I in $( jot 60 ); do
				[ -c "/dev/hast/${disk}" ] && break
				sleep 0.5
			done

			if [ ! -c "/dev/hast/${disk}" ]; then
				logger -p $log -t $name "GEOM provider /dev/hast/${disk} did not appear."
				exit 1
			fi
		done

		logger -p $log -t $name "Role for HAST resources ${resources} switched to primary."

		logger -p $log -t $name "Mounting disks."
		for disk in ${resources}; do
			mkdir -p /hast/${disk}
			fsck -p -y -t ufs /dev/hast/${disk}
			mount /dev/hast/${disk} /hast/${disk}
		done

	;;

	slave)
		logger -p $log -t $name "Switching to secondary provider for ${resources}."

		# Switch roles for the HAST resources
		for disk in ${resources}; do
			if ! mount | grep -q "^/dev/hast/${disk} on "
			then
			else
				umount -f /hast/${disk}
			fi
			sleep $delay
			hastctl role secondary ${disk} 2>&1
			if [ $? -ne 0 ]; then
				logger -p $log -t $name "Unable to switch role to secondary for resource ${disk}."
				exit 1
			fi
			logger -p $log -t $name "Role switched to secondary for resource ${disk}."
		done
	;;
esac
....

Товчхондоо скрипт нь эдгээр алхмуудыг цэг `мастер` / `анхдагч` болох үед хийнэ:

* Өгөгдсөн цэг дээр HAST нөөцийг анхдагч болгоно.
* HAST нөөц доор байгаа файлын системийг шалгана.
* Тохирох газарт нь нөөцүүдийг холбоно.

`нөөц` / `хоёрдогч` болсон тохиолдолд:

* HAST нөөцүүдийг салгана.
* HAST нөөцүүдийг хоёрдогч болгож бууруулна.

[CAUTION]
====

Энэ нь зөвхөн боломжой шийдэл байдаг гэдгийг харуулсан жишээ скрипт гэдгийг санаарай. Энэ нь бүх л боломжит нөхцлийг тооцоогүй бөгөөд шаардлагатай үйлчилгээг эхлүүлэх/зогсоох гэх мэтээр сайжруулж өргөтгөх юм уу эсвэл дураараа өөрчлөх боломжтой юм.
====

[TIP]
====

Энэ жишээн дээр бид стандарт UFS файлын системийг ашигласан. Сэргээхэд шаардлагатай цагийг багасгахын тулд журнал дэмжигдсэн UFS эсвэл ZFS файлын системийг ашиглаж болох юм.
====

Нэмэлт жишээнүүд бүхий илүү дэлгэрэнгүй мэдээллийг http://wiki.FreeBSD.org/HAST[HAST Wiki] хуудаснаас олж болно.

=== Алдааг олж засварлах

==== Алдааг олж засварлах ерөнхий аргууд

HAST ерөнхийдөө асуудалгүй ажиллах ёстой. Гэхдээ бусад програмуудын нэгэн адил ажиллах ёстойгоосоо өөрөөр ажиллах тохиолдол байдаг. Асуудлын шалтгаан өөр өөр байж болох боловч гол шалгах юм нь кластерын цэгүүдийн хооронд цаг синхрончлогдсон байгаа эсэхийг мэдэх явдал юм.

HAST-н асуудлуудыг шалгаж байхдаа man:hastd[8]-г `-d` өгөгдөлтэйгээр ажиллуулан man:hastd[8]-н дибаг түвшинг ихэсгэж үзэх ёстой. Дибаг түвшинг дахин дахин ихэсгэхийн тулд энэ аргументыг олон удаа тавьж өгч болно. Энэ замаар маш их хэрэгтэй мэдээллийг олж авч болно. Мөн `-F` аргументыг ашиглан man:hastd[8] демонг ил ажиллуулах нь зүйтэй байдаг.

[[disks-hast-sb]]
==== Split-brain нөхцлөөс сэргэж гарах

`split-brain` гэдэг нь хоёр цэг нэг нэгэнтэйгээ холбогдож чадахгүй бөгөөд хоёул анхдагч цэг гэж тохируулагдсан үе юм. Энэ нь аюултай нөхцөл бөгөөд учир нь энэ тохиолдолд өгөгдөлд хоёр цэг хоёул нийцгүй өөрчлөлтийг хийх боломжийг олгодог. Энэ нөхцлийг системийн администратор гараар засварлах шаардлагатай.

Администратор аль цэг хамгийн чухал өөрчлөлттэй байгаа дээр шийдвэр гаргаж (эсвэл гараар нийлүүлэн) HAST-д эвдэрсэн өгөгдөл бүхий цэгийн бүтэн синхрончлол хийх боломжийг олгох ёстой. Ингэхийн тулд дараах тушаалуудыг дахин синхрончлол шаардлагатай байгаа цэг дээр ажиллуулна:

[source,bash]
....
# hastctl role init <resource>
# hastctl create <resource>
# hastctl role secondary <resource>
....
