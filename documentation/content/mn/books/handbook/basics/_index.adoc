---
title: Бүлэг 4. Юниксийн үндэс
part: хэсэг I. Эхлэл
prev: books/handbook/install
next: books/handbook/ports
showBookMenu: true
weight: 6
path: "/books/handbook/basics/"
---

[[basics]]
= Юниксийн үндэс
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 4
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/basics/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[basics-synopsis]]
== Ерөнхий агуулга

Дараах бүлгүүд нь FreeBSD үйлдлийн системийн үндсэн тушаал мөн гүйцэтгэлүүдийг хамрах болно. Энэ материалын ихэнх хэсэг нь UNIX(R)-төрлийн үйлдлийн системтэй хамаатай. Хэрэв та юникс төрлийн үйлдлийн системтэй танил бол энэ бүлгийг алгасаж болно. Харин та FreeBSD-г шинээр сурагч бол энэ бүлгийг тун анхааралтай унших хэрэгтэй.

Энэ бүлгийг уншсаны дараа, та дараах зүйлсийг мэдэх болно:

* FreeBSD-н "виртуал консолыг" хэрхэн хэрэглэх.
* FreeBSD дээрх файлын тугийг ойлгосноор UNIX(R)-н файлын зөвшөөрөл хэрхэн ажилладгийг мэдэх.
* Үндсэн FreeBSD файл системийн байрлуулалтыг мэдэх.
* FreeBSD диск зохион байгуулалт.
* Файл системийг хэрхэн холбох болон салгах.
* Процесс, далд чөтгөр дэмон, мөн дохионууд гэж юу болох.
* Бүрхүүл гэж юу болох, мөн хэрхэн анхны нэвтрэх орчноо өөрчлөх.
* Үндсэн текст засварлагчийг хэрхэн хэрэглэх.
* Төхөөрөмж болох төхөөрөмжийн цэг гэж юу болох.
* FreeBSD-д ямар хоёртын хэлбэр хэрэглэгддэг болох.
* Нэмэлт мэдээллийг товч гарын авлагаас хэрхэн харах.

[[consoles]]
== Виртуал консол болон терминал

FreeBSD нь олон аргаар хэрэглэгдэж чадна. Тэдний нэг нь тушаалуудыг текст терминал дээр бичиж хэрэглэх юм. Хэрэв та FreeBSD-г ингэж хэрэглэвэл, UNIX(R)-н маш олон боломж болон хүч таны гарт байна гэсэн үг. Энэ бүлэг танд, "терминал" болон "консол" гэж юу болох, мөн тэд нарыг FreeBSD дээр хэрхэн хэрэглэх талаар танд тодорхойлж өгөх болно.

[[consoles-intro]]
=== Консол

Хэрэв та FreeBSD-г эхлэх үедээ автоматаар график горимд эхлүүлэхээр тохируулаагүй бол, систем нь эхлэлтийн гүйцэтгэдэг бичиглэлүүдээ дуусгасны дараа танд нэвтрэх хуудас харуулдаг. Та нэг иймэрхүү хуудас харах байх:

[source,shell]
....
Additional ABI support:.
Local package initialization:.
Additional TCP options:.

Fri Sep 20 13:01:06 EEST 2002

FreeBSD/i386 (pc3.example.org) (ttyv0)

login:
....

Энд харуулсан текстүүд нь таны систем дээр жаахан өөр байж магадгүй ч, ерөнхийдөө үүнтэй ижил байх ёстой. Сүүлийн хоёр мөр нь бидэнд одоогоор чухал мөрүүд. Сүүлээсээ хоёр дахь мөр нь ингэж уншигдаж байна:

[.programlisting]
....
FreeBSD/i386 (pc3.example.org) (ttyv0)
....

Энэ мөр нь таны дөнгөж сая эхлүүлсэн системийн тухай товч мэдээллийг агуулсан байна. Та x86 архитектуртай тохиромжтой Интел юм уу тохирох систем дээр ажиллаж буй "FreeBSD" консолыг харж байна . Энэ машины нэр нь (UNIX(R) машин болгон өөрийн нэртэй ) `pc3.example.org`, бөгөөд та энэ системийн консолын - [.filename]#ttyv0# нэртэй терминалыг харж байна.

Эцэст нь, сүүлийн мөр бол үргэлж:

[.programlisting]
....
login:
....

Энэ хэсэг нь, таны FreeBSD уруу нэвтрэх "хэрэглэгчийн-нэрээ" бичдэг хэсэг. Дараагийн хэсэгт энэ талаар тодорхойлсон байгаа.

[[consoles-login]]
=== FreeBSD уруу нэвтрэх

FreeBSD бол олон хэрэглэгчийн бас олон үйлдлийн систем. Энэ нь, нэг машин уруу олон хүмүүс зэрэг холбогдож нэгэн зэрэг олон үйлдэл хийж болдог системийн ерөнхий тодорхойлолт юм. 

Олон хэрэглэгчийн систем нь ямар нэгэн аргаар нэг "хэрэглэгчийг" бусдаас нь ялгаж чаддаг байх ёстой. FreeBSD дээр (мөн бусад UNIX(R)-төрлийн системүүд дээр) энэ нь, хэрэглэгч ямар нэгэн програм ажиллуулахаасаа өмнө систем уруу "нэвтрэх үйлдэл" хийж хэрэгждэг. Хэрэглэгч бүрд гоц нэр ( "хэрэглэгчийн-нэр") мөн хувийн нууц үг ( "нууц-үг") харгалзах ёстой. Хэрэглэгчийг програм хэрэглэж эхлэхээс өмнө FreeBSD энэ хоёрыг асуух болно.

Дөнгөж FreeBSD эхлэх үедээ эхлүүлэгч бичлэгүүдийг  гүйцэтгэж дуусаад танаас зөв хэрэглэгчийн нэр оруулахыг лавлаж асууна:

[source,shell]
....
login:
....

Энэ жишээнд зориулаад бүгдээрээ таны хэрэглэгчийн нэрийг `john` гэж бодоцгооё. Лавлаж асуусан мөрөнд `john` гэж бичээд kbd:[Enter] товч дарна. Ингээд дараа нь танаас "password" гэж нууц үг асуух болно:

[source,shell]
....
login: john
Password:
....

`john`-ны нууц үгийг оруулаад kbd:[Enter] товч дарна. Нууц үгийг _танд харуулдаггүй!_ Энэ талаар та одоохондоо санаагаа зовоох хэрэггүй. Нууцлалын шалтгаанаар ингэж байгаа юм гэж хэлэхэд хангалттай.

Хэрэв та нууц үгээ зөв оруулсан бол ингээд FreeBSD уруу нэвтрэх бөгөөд боломжтой бүх програмуудыг туршиж болохоор боллоо.

Та MOTD эсвэл тухайн өдрийн мэдээллийг тушаал бичигчийн араас харах болно ( тушаал бичигч нь `#`, `$`, эсвэл `%` гэсэн тэмдэгтүүдийн нэг нь байдаг). Энэ нь таныг FreeBSD уруу амжилттай нэвтэрснийг илэрхийлдэг.

[[consoles-virtual]]
=== Олон консолууд

UNIX(R) тушаалуудыг нэг консол дээр гүйцэтгэх нь ердийнх, гэхдээ FreeBSD олон програмыг нэг дор ажиллуулж чадна. FreeBSD олон програмыг нэг дор нэг цагт ажиллуулж чадаж байхад, нэг консол дээр олон тушаал өгч суух нь цаг алдахын л нэмэр. Ийм үед л "виртуал консолын" тусламж хэрэг болдог.

FreeBSD нь танд олон төрлийн виртуал консол хэрэглүүлэхээр тохируулагдаж чаддаг. Нэг виртуал консолоос нөгөөх уруу нь гарын хэдхэн товчлуур дараад л шилжиж болдог. Консол бүр өөрийн төрөл бүрийн гаралтын сувагтай бөгөөд FreeBSD нь таныг нэг консолоос нөгөө консол уруу сэлгэх үед гарын оруулга болон дэлгэцийн гаралтыг тухайн консолд тохируулж дамжуулж өгдөг.

Гарын тусгай товчлолууд нь FreeBSD дээр консол сэлгэхэд зориулж нөөцлөгдсөн байдаг . Та kbd:[Alt+F1], kbd:[Alt+F2], аас kbd:[Alt+F8] хүртэлх товчлуурыг дарж FreeBSD дээр консолуудын хооронд шилжиж болно.

Таныг нэгээс нөгөөх уруу нь шилжих үед, FreeBSD таны дэлгэцийн гаралтыг хадгалж санаа тавьдаг. Ингэсний үр дүнд гарнаас тушаал оруулж програмуудыг ажиллуулж болдог маш олон "виртуал" дэлгэцүүдтэй мэт үзэгддэг. Нэг виртуал консол дээр таны ажиллуулсан програм нь уг консолоос сэлгээд өөр консол дээр сэлгэсэн ч гэсэн зогсохгүй ажиллаж л байдаг. 

[[consoles-ttys]]
=== [.filename]#/etc/ttys# Файл

FreeBSD анхны тохируулгаараа найман виртуал консолтой эхэлдэг. Энэ нь хатуу тогтоосон тохируулга биш бөгөөд хэрэв та хүсвэл олон юм уу цөөн болгож амархан өөрчлөх боломжтой. Виртуал консолын тоо болон тохируулга нь [.filename]#/etc/ttys# файлд байдаг.

Та [.filename]#/etc/ttys# файлыг хэрэглэж FreeBSD дээрх виртуал консолуудыг тохируулж болно. Энэ файлын тайлбар тавиагүй мөр болгон ( `#` тэмдгээр эхлээгүй мөрүүд) виртуал консол эсвэл ганц терминалын тохируулгыг агуулж байдаг. Энэ файл FreeBSD-тэй анх цуг ирэхдээ есөн виртуал консолтой гэж тохируулагдаж ирдэг бөгөөд тэдний наймыг нь хэрэглэж болохыг зөвшөөрсөн байдаг. Тэдгээр нь `ttyv` гэж эхэлсэн байдаг:

[.programlisting]
....
# name  getty                           type    status          comments
#
ttyv0   "/usr/libexec/getty Pc"         cons25  on  secure
# Virtual terminals
ttyv1   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv2   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv3   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv4   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv5   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv6   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv7   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv8   "/usr/X11R6/bin/xdm -nodaemon"  xterm   off secure
....

Виртуал консолыг тохируулдаг энэ файлын баганууд мөн нэмэлт сонголтуудын дэлгэрэнгүй тайлбарыг та man:ttys[5] гарын авлагаас харна уу.

[[consoles-singleuser]]
=== Ганц хэрэглэгчийн горимын консол

"Ганц хэрэглэгчийн горим" гэж юу болох талаар дэлгэрэнгүй мэдээлэл crossref:boot[boot-singleuser,Ганц-хэрэглэгчийн горим]-д буй. FreeBSD дээр ганц хэрэглэгчийн горимд ажиллаж байхад зөвхөн нэг консол байдаг гэдгийг мэдэх хэрэгтэй. Энэ үед ямар ч виртуал консолууд боломжгүй. Ганц хэрэглэгчийн горимын тохируулгыг бас [.filename]#/etc/ttys# файл дотор хийж болно. `console` гэж эхэлсэн мөрүүдийг харна уу:

[.programlisting]
....
# name  getty                           type    status          comments
#
# If console is marked "insecure", then init will ask for the root password
# when going to single-user mode.
console none                            unknown off secure
....

[NOTE]
====
Дээрх `console` гэсэн мөрний дээд хэсэгт бичсэн тайлбарт бичсэний дагуу та `secure` гэдгийг `insecure` гэж өөрчилж болно. Хэрэв та ингэвэл, FreeBSD ганц хэрэглэгчийн горимд эхэлсэн ч гэсэн танаас `root` нууц үг асуух болно.

_Үүнийг `_insecure_` гэж солихдоо та тун болгоомжтой байх хэрэгтэй_. Хэрэв та хэзээ нэгэн цагт `root` нууц үгээ мартаад ганц хэрэглэгчийн горимд орвол жаахан хүндрэлтэй байх болно. Энэ нь гэхдээ шийдэж болохоор хүндрэл боловч FreeBSD-н эхлэх үйлдэл болон хамрагдсан програмуудад нь дасаагүй хүнд бол жаахан хүндрэлтэй байж магадгүй.
====

[[consoles-vidcontrol]]
=== Консолын Видео горимуудыг өөрчлөх нь

FreeBSD-ийн консолын анхдагч видео горимыг 1024x768, 1280x1024, эсвэл таны график бичил схем болон дэлгэц дэмжиж чадах дурын хэмжээгээр тохируулж болох юм. Өөр видео горимыг ашиглахын тулд та `VESA` модулийг дуудна:

[source,shell]
....
# kldload vesa
....

Дараа нь таны тоног төхөөрөмж ямар видео горимуудыг дэмждэгийг man:vidcontrol[1] хэрэгсэл ашиглан та тодорхойлж болно. Дэмжигдсэн видео горимуудын жагсаалтыг авахын тулд доор дурдсан тушаалыг бичнэ:

[source,shell]
....
# vidcontrol -i mode
....

Энэ тушаалын үр дүн нь таны тоног төхөөрөмжийн дэмждэг видео горимуудын жагсаалт байх болно. Та дараа нь `root` консол дээр шинэ видео горимыг сонгон man:vidcontrol[1] уруу өгч болно:

[source,shell]
....
# vidcontrol MODE_279
....

Хэрэв шинэ видео горим боломжийн бол [.filename]#/etc/rc.conf# файлд ачаалахад үүнийг үргэлж сонгодог байхаар тохируулж болно:

[.programlisting]
....
allscreens_flags="MODE_279"
....

[[permissions]]
== Зөвшөөрлүүд

FreeBSD нь BSD UNIX(R)-ээс уламжилж байх үедээ, UNIX(R)-н үндсэн хэдэн бүтэц дээр суурилсан. Эхний бөгөөд хамгийн чухал тунхаглал нь FreeBSD бол олон хэрэглэгчийн үйлдлийн систем юм. Систем нь олон хэрэглэгчийн хоорондоо хамааралгүй олон үйлдлийг ачаалж чаддаг. Хэрэглэгч болгонд шаардагдах компьютерийн төхөөрөмж, санах ой мөн процессорын давтамжийг зөв шударга хуваарилахыг систем хариуцдаг.

Систем олон хэрэглэгчтэй ажиллах болохоор, системийн хийх ёстой зүйл нь хэн тухайн нөөцийг унших, бичих, гүйцэтгэх вэ гэдгийг зохицуулах юм. Эдгээр зөвшөөрлүүд нь гурав гурваараа нийлүүлэгдсэн гурван хэсэг тоо байдаг. Нэг нь файлын эзэмшигчид, нөгөөх нь файлын хамаарагддаг бүлэгт, үлдсэн нь хүн болгонд гэж хуваарилагдана. Энэ тоон дараалал нь дараах маягаар ажилладаг.:

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Утга
| Зөвшөөрөл
| Жагсаах харуулалт

|0
|Уншигдахгүй, бичигдэхгүй, гүйцэтгэгдэхгүй
|`---`

|1
|Уншигдахгүй, бичигдэхгүй, гүйцэтгэгдэнэ
|`--x`

|2
|Уншигдахгүй, бичигдэнэ, гүйцэтгэгдэхгүй
|`-w-`

|3
|Уншигдахгүй, бичигдэнэ, гүйцэтгэгдэнэ
|`-wx`

|4
|Уншигдана, бичигдэхгүй, гүйцэтгэгдэхгүй
|`r--`

|5
|Уншигдана, бичигдэхгүй, гүйцэтгэгдэнэ
|`r-x`

|6
|Уншигдана, бичигдэнэ, гүйцэтгэгдэхгүй
|`rw-`

|7
|Уншигдана, бичигдэнэ, гүйцэтгэгдэнэ
|`rwx`
|===

Та man:ls[1] тушаалыг `-l` сонголттой хэрэглэж файлын эзэмшигч, бүлэг, мөн хүн болгонд хуваарилсан зөвшөөрлийг харуулсан баганатай дэлгэрэнгүй мэдээллийг харж болно. Жишээлбэл, `ls -l` тушаалыг нэг сан дотор гүйцэтгэвэл дараах маягаар харагдана:

[source,shell]
....
% ls -l
total 530
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 myfile
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 otherfile
-rw-r--r--  1 root  wheel    7680 Sep  5 12:31 email.txt
...
....

Энд `ls -l` тушаалын эхний баганыг авч үзье:

[source,shell]
....
-rw-r--r--
....

Хамгийн эхний (зүүн талын) тэмдэг нь үүнийг ердийн файл юм уу, эсвэл сан, онцгой тэмдэг төхөөрөмж, сокет, эсвэл ямар нэгэн холбоост файл мөн эсэхийг илэрхийлдэг. Энэ тохиолдолд `-` нь ердийн файлыг зааж байна. Дараагийн гурван тэмдэгт `rw-` нь энэ тохиолдолд энэ файлын эзэмшигчид зөвшөөрөл өгч байна. Дараагийн гурван тэмдэгт `r--` нь файлын хамаарах бүлэгт эрх өгч байна. Сүүлийн гурван тэмдэгт `r--` нь бусад бүх хүмүүст эрх өгч байна. Зураас нь зөвшөөрөл өгөөгүйг илэрхийлдэг. Энэ файлын тохиолдолд, файлыг унших бичих эрхийг эзэмшигчид нь өгөөд, бүлэг нь файлыг унших эрхтэй, бусад хүмүүс энэ файлыг зөвхөн унших эрхтэй гэж заагдсан байна. Дээр тайлбарласан хүснэгтийн дагуу, энэ файлын зөвшөөрөл нь `644` гэж дээрх гурван төрөлд заагдаж байна.

Энэ бол сайн бөгөөд сайхан хэрэг, гэхдээ төхөөрөмж рүү хандах зөвшөөрлийг систем яаж хянах вэ? FreeBSD бараг ихэнх төхөөрөмжийг нээж уншиж өгөгдөл бичдэг файл мэт хандаж уншиж бичдэг. Тэдгээр онцгой төхөөрөмжүүд нь [.filename]#/dev# сан дотор байрладаг.

Сангууд ч гэсэн бас файл мэт хандагддаг. Тэд нарт бас уншигдах, бичигдэх, гүйцэтгэгдэх зөвшөөрлүүд байдаг. Сангийн гүйцэтгэгдэх тэмдэг нь файлаас арай өөрөөр хэрэгждэг. Хэрэв сан нь гүйцэтгэгдэнэ гэж тэмдэглэгдсэн бол, энэ сан нь дамжиж өнгөрүүлэгдэж болох буюу "cd" тушаалыг (сан сольдог) хэрэглэж ийшээ орж болно гэсэн үг. Энэ нь мөн сан дотор харагдаж байгаа файлууд уруу хандаж болно гэсэн үг. (бас нэг зүйл, мэдээжээр, файлууд бас өөр дээрээ зөвшөөрөл агуулсан байгаа).

Ерөнхийдөө бол, сан доторх файлуудыг жагсааж харахыг хүсвэл, уг санд уншигдах зөвшөөрөл суугдсан байх ёстой. Хэрэв санд байгаа файлыг устгана гэвэл бичигдэх _болон_ гүйцэтгэгдэх зөвшөөрлүүд уг санд суугдах ёстой.

Мөн нэмээд хэдэн зөвшөөрлийн битүүд байдаг, гэхдээ тэдгээр нь ажилладаг файлын setuid дугаар болон sticky сан зэрэг тусгай зориулалтаар хэрэглэгддэг. Файлын зөвшөөрлийн талаар нэмэлт мэдээлэл авахыг хүсвэл man:chmod[1] гарын авлага хуудаснаас хараарай.

=== Тэмдэгт зөвшөөрлүүд

Сан эсвэл файлд тоон утганы оронд заримдаа тэмдгэн зөвшөөрлийг хэрэглэдэг. Тэмдгэн зөвшөөрлийг бичихдээ (хэн) (үйлдэл) (зөвшөөрөл) гэсэн дарааллаар бичих бөгөөд дараах утгуудыг авдаг:

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Сонголт
| Үсэг
| Илэрхийлэл нь

|(хэн)
|u
|Хэрэглэгч

|(хэн)
|g
|Бүлгийн эзэмшигч

|(хэн)
|o
|Бусад

|(хэн)
|a
|Бүгд ("ертөнц")

|(үйлдэл)
|+
|Зөвшөөрөл нэмэх

|(action)
|-
|Зөвшөөрлийг устгах

|(үйлдэл)
|=
|зөвхөн тухайн зөвшөөрлийг суулгах

|(зөвшөөрөл)
|r
|Унших

|(зөвшөөрөл)
|w
|Бичих

|(зөвшөөрөл)
|x
|Гүйцэтгэх

|(зөвшөөрөл)
|t
|Sticky бит

|(зөвшөөрөл)
|s
|UID эсвэл GID суулгах
|===

Эдгээр утгууд нь өмнөх жишээ шиг man:chmod[1] тушаалтай хэрэглэгддэг бөгөөд гэхдээ үсэг хэрэглэнэ. Жишээлбэл, та _FILE_ уруу бусад хэрэглэгчид хандахыг хориглохдоо:

[source,shell]
....
% chmod go= FILE
....

Файлд нэгээс олон өөрчлөлт хийх шаардлага гарвал таслалаар тусгаарласан мөр бичиж болно. Жишээлбэл, дараах тушаал нь бүлэг болон "дэлхийг"_FILE_ дээр бичих эрхийг нь аваад дараа нь хүн болгонд гүйцэтгэж болно гэсэн эрх өгч байна:

[source,shell]
....
% chmod go-w,a+x FILE
....

=== FreeBSD файлын туг

Өмнө ярилцсан файлын зөвшөөрлөөс гадна FreeBSD нь "файлын туг" хэрэглээгээр хангагдсан байдаг. Эдгээр туг нь файлд нэмэлт нууцлалын болон хяналтын түвшин тогтоож өгдөг, гэхдээ санд бол үгүй.

Эдгээр файлын тугнууд нь файлд нэмэлт түвшний хяналт тогтоож өгснөөрөө зарим тохиолдолд `root` хэрэглэгч хүртэл файлыг устгах юм уу өөрчилж чадахгүй болгож тусалдаг.

Файлын тугнууд нь энгийн загвартай man:chflags[1] багажаар ашиглагддаг. Жишээлбэл, [.filename]#file1# файл дээр устгагдахгүй гэсэн туг хатгахыг системд зөвшөөрүүлэхийн тулд дараах тушаалыг гүйцэтгэнэ:

[source,shell]
....
# chflags sunlink file1
....

Хэрэв устгагдахгүй тугийг буцааж авна гэвэл өмнөх тушаал дээрээ `sunlink`-ын өмнө "no" залгаж ажиллуулна:

[source,shell]
....
# chflags nosunlink file1
....

Энэ файлын тугийг харахын тулд man:ls[1] тушаалыг `-lo` сонголттой хамт ажиллуулна:

[source,shell]
....
# ls -lo file1
....

Тушаалын гаралт нь дараах маягаар харагдах ёстой:

[.programlisting]
....
-rw-r--r--  1 trhodes  trhodes  sunlnk 0 Mar  1 05:54 file1
....

Нэлээн хэдэн тугнууд нь файлд зөвхөн `root` хэрэглэгчээр нэмэгдэж устгагдана. Бусад тохиолдолд файлын эзэмшигч нь тугийг суулгах боломжтой. Администраторуудыг man:chflags[1] болон man:chflags[2] гарын авлагуудыг уншихыг зөвлөж байна.

=== `setuid`, `setgid`, болон `sticky` буюу наалдамхай зөвшөөрлүүд

Өмнө хэлэлцсэн зөвшөөрлүүдээс гадна бүх администраторуудын мэдэх ёстой өөр гурван тусгай тохиргоо байдаг. Эдгээр нь `setuid`, `setgid` болон `sticky` буюу наалдамхай зөвшөөрлүүд юм.

Эдгээр тохиргоонууд нь ерөнхийдөө энгийн хэрэглэгчдэд зөвшөөрөгддөггүй ажиллагаагаар хангадаг бөгөөд UNIX(R)-ийн зарим нэг үйлдлүүдэд чухал байдаг. Эдгээрийг ойлгохын тулд жинхэнэ хэрэглэгчийн ID болон хүчинтэй хэрэглэгчийн ID-ийн ялгааг дурдах хэрэгтэй.

Жинхэнэ хэрэглэгчийн ID нь процессийг эзэмшдэг юм уу эсвэл процессийг эхлүүлдэг UID юм. Хүчинтэй хэрэглэгчийн UID нь процессийн ажиллаж байгаа тэр хэрэглэгчийн ID юм. Жишээ нь man:passwd[1] хэрэгсэл нь хэрэглэгч өөрсдийн нууц үгээ сольж байгаа болохоор жинхэнэ хэрэглэгчийн ID-аар ажиллах боловч нууц үгийн санд өөрчлөлт хийхийн тулд `root` хэрэглэгчийн хүчинтэй ID-аар ажилладаг. Ингэснээр энгийн хэрэглэгчдэд `Permission Denied` буюу зөвшөөрөл хаалттай гэсэн алдааг харуулалгүйгээр өөрсдийн нууц үгсийг солих боломжийг олгодог.

[NOTE]
====
`nosuid` man:mount[8] тохиргоо нь эдгээр хоёртын файлуудыг дуугай амжилтгүй болоход хүргэдэг. Энэ нь хэрэглэгчдэд мэдэгдэлгүйгээр ажиллагаа амжилтгүй болно гэсэн үг юм. man:mount[8] гарын авлагын дагуу энэ тохиргоо нь `nosuid` гүйцэтгэл хялбаршуулагчийн хамгаалж болох шиг бүрэн найдвартай бас биш юм.
====

setuid зөвшөөрлийг зөвшөөрлийн цуглуулгын өмнө дөрвийн тоог (4) доорх жишээн дээрх шигээр тавьж тохируулж болно:

[source,shell]
....
# chmod 4755 suidexample.sh
....

[.filename]#suidexample.sh# файл дээрх зөвшөөрлүүд нь одоо доорх шиг харагдах ёстой:

[.programlisting]
....
-rwsr-xr-x   1 trhodes  trhodes    63 Aug 29 06:36 suidexample.sh
....

Энэ жишээн дээр `s` нь ажиллуулах битийг сольж файлын эзэмшигчид зориулсан зөвшөөрлүүдийн цуглуулгын хэсэг болж байгаа нь харагдах ёстой. Энэ нь `passwd` зэрэг дээшлүүлсэн зөвшөөрлүүдийг шаарддаг хэрэгслүүдийг зөвшөөрдөг.

Жинхнээр нь үүнийг харахын тулд хоёр терминал нээ. Нэг дээр нь энгийн хэрэглэгчээр `passwd` процессийг эхлүүл. Шинэ нууц үг хүлээж байхад нь процессийн хүснэгтийг шалгаад `passwd` тушаалын хэрэглэгчийн мэдээллийг хар.

Терминал A дээр:

[source,shell]
....
Changing local password for trhodes
Old Password:
....

Терминал B дээр:

[source,shell]
....
# ps aux | grep passwd
....

[source,shell]
....
trhodes  5232  0.0  0.2  3420  1608   0  R+    2:10AM   0:00.00 grep passwd
root     5211  0.0  0.2  3620  1724   2  I+    2:09AM   0:00.01 passwd
....

Дээр харуулснаар `passwd` нь энгийн хэрэглэгчээр ажиллаж байгаа боловч `root` хэрэглэгчийн хүчинтэй UID ашиглаж байна.

`setgid` зөвшөөрөл нь `setuid` зөвшөөрөлтэй адил үүргийг гүйцэтгэдэг, гэхдээ бүлгийн тохиргоог өөрчилдөг. Програм юм уу эсвэл хэрэгсэл нь энэ тохиргоотойгоор ажиллахдаа процессийг эхлүүлсэн хэрэглэгч биш файлыг эзэмшиж байгаа бүлэг дээр тулгуурласан зөвшөөрлүүдийг олгодог.

Файл дээр `setgid` зөвшөөрлийг тохируулахдаа дараах жишээн дээрх шиг `chmod` тушаалыг өмнөө хоёртой (2) өгнө:

[source,shell]
....
# chmod 2755 sgidexample.sh
....

Шинэ тохиргоог өмнөх шигээ харж болох бөгөөд `s` нь одоо бүлгийн зөвшөөрлийн тохиргоонд зориулагдсан талбарт байгааг анхаараарай:

[source,shell]
....
-rwxr-sr-x   1 trhodes  trhodes    44 Aug 31 01:49 sgidexample.sh
....

[NOTE]
====
Эдгээр жишээнүүд дээр бүрхүүлийн скрипт нь хэдийгээр ажиллах боломжтой файл боловч өөр EUID буюу хүчинтэй хэрэглэгчийн ID-аар ажиллахгүй. Энэ нь яагаад гэвэл бүрхүүлийн скрипт нь man:setuid[2] системийн дуудлагуудад хандаж чадахгүйтэй холбоотой юм.
====

Бидний хэлэлцсэн эхний хоёр тусгай зөвшөөрлийн битүүд нь (`setuid` болон `setgid` зөвшөөрлийн битүүд) дээшлүүлсэн зөвшөөрлүүдийг зөвшөөрч системийн аюулгүй байдлыг доошлуулж болох юм. Системийн аюулгүй байдлыг чангатгаж чадах гурав дахь тусгай зөвшөөрлийн бит байдаг нь `sticky bit` буюу наалдамхай бит юм.

`sticky bit` нь санд тавигдсан үед файл устгалтыг зөвхөн файлыг эзэмшигчид зөвшөөрдөг. Энэ зөвшөөрлийн цуглуулга нь [.filename]#/tmp# зэрэг нийтийн сангаас файлыг эзэмшдэггүй хэрэглэгч уг файлыг устгахаас хамгаалахад ашиг тустай байдаг. Энэ зөвшөөрлийг ашиглахын тулд зөвшөөрлийн урд нэгийг (1) тавьж өгнө. Жишээ нь:

[source,shell]
....
# chmod 1777 /tmp
....

Одоо үр дүнг `ls` тушаал ашиглан харах боломжтой:

[source,shell]
....
# ls -al / | grep tmp
....

[source,shell]
....
drwxrwxrwt  10 root  wheel         512 Aug 31 01:49 tmp
....

`sticky bit` буюу наалдамхай бит зөвшөөрөл нь цуглуулгын хамгийн сүүлд байгаа `t`-ээс ялгаатай юм.

[[dirstructure]]
== Сангийн бүтэц

FreeBSD ийн сангийн бүтэц нь уг системийг ойлгоход тун чухал үүрэг гүйцэтгэнэ. Хамгийн чухал бөгөөд үндсэн ойлголт бол root буюу хамгийн дээд эх сан "/" юм. Энэ сан нь систем эхлэх үед хамгийн түрүүнд танигдах ёстой бөгөөд олон хэрэглэгчид зориулсан үйлдлийн системийг бэлдэхэд чухал үүрэгтэй. Энэ дээд эх сан нь олон хэрэглэгчийн ажиллагаанд шилжих үед холбогдох бусад файлын системүүдийн холболтын цэгүүдийг бас агуулж байдаг.

Холболтын цэг нь үндсэн файл систем уруу (ихэвчлэн эх root файл систем) нэмэлт файлын системүүдийг холбож нэмдэг цэг юм. Энэ тухай цаашид <<disk-organization>>-д тайлбарласан байгаа. Үндсэн холбох цэгүүд нь [.filename]#/usr#, [.filename]#/var#, [.filename]#/tmp#, [.filename]#/mnt#, мөн [.filename]#/cdrom# сангуудыг агуулж байдаг. Эдгээр сангууд нь голдуу [.filename]#/etc/fstab# файлд заагдсан байдаг. [.filename]#/etc/fstab# файл нь төрөл бүрийн файл системүүдийг системд ойлгуулах гэж бичсэн хүснэгт бичлэг. [.filename]#/etc/fstab# файлд байгаа ихэнх файл системүүд компьютер эхэлж ачаалагдах үед автоматаар man:rc[8] гүйцэтгэгддэг бичлэгээс таниулагддаг. Гэхдээ хэрэв `noauto` гэсэн сонголтыг агуулсан бол автоматаар таниулагддаггүй. Дэлгэрэнгүй мэдээлэл <<disks-fstab>> хэсэгт буй.

Файл системийн бүтцийн тухай бүрэн мэдээллийг man:hier[7]-с харж болно. Одоохондоо байнга хэрэглэгддэг сангуудыг товч тайлбарлахад хангалттай.

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Сан
| Тодорхойлолт

|[.filename]#/#
|Файл системийн Root буюу хамгийн дээд эх сан.

|[.filename]#/bin/#
|Ганц болон олон хэрэглэгчийн орчны үндсэн хэрэгслийн сан.

|[.filename]#/boot/#
|Үйлдлийн систем эхлэж ачаалагдах үеийн програмууд болон тохируулга файлууд.

|[.filename]#/boot/defaults/#
|Анхдагч ачаалах үеийн тохируулгын файлууд; дэлгэрэнгүйг man:loader.conf[5] хуудаснаас харна уу.

|[.filename]#/dev/#
|Төхөөрөмжүүд байдаг сан; man:intro[4] хуудаснаас харна уу.

|[.filename]#/etc/#
|Системийн тохируулгын файлууд болон гүйцэтгэх бичлэгүүд.

|[.filename]#/etc/defaults/#
|Анхдагч системийн тохируулгын файлууд; дэлгэрэнгүйг man:rc[8] хуудаснаас хараарай.

|[.filename]#/etc/mail/#
|man:sendmail[8] мэтийн захиа илгээгчдийн тохируулгын файлууд. 

|[.filename]#/etc/namedb/#
|`named`-н тохируулгын файл; man:named[8] хуудаснаас дэлгэрэнгүйг харна уу.

|[.filename]#/etc/periodic/#
|man:cron[8]-г ашиглаж өдрөөр, сараар, эсвэл жилээр гэх мэт давтамжаар ажиллаж чаддаг бичлэгүүд ; дэлгэрэнгүйг man:periodic[8] хуудаснаас харна уу.

|[.filename]#/etc/ppp/#
|`ppp` тохируулга файлууд; man:ppp[8]-с харна уу.

|[.filename]#/mnt/#
|Администратор голдуу түр зуур бусад файл систем эсвэл төхөөрөмжийг таниулахад хэрэглэдэг хоосон сан.

|[.filename]#/proc/#
|Процесийн файл систем; man:procfs[5] болон man:mount_procfs[8]-с харна уу.

|[.filename]#/rescue/#
|Эвдэрч гэмтсэн үед сэргээхэд хэрэглэгддэг програмууд man:rescue[8]-с харна уу.

|[.filename]#/root/#
|`root` хэрэглэгчийн гэрийн сан.

|[.filename]#/sbin/#
|Ганц болон олон хэрэглэгчийн орчинд хэрэглэж болохоор системийн програм ба администраторын үндсэн хэрэгслүүд.

|[.filename]#/tmp/#
|Түр зуурын файлууд. [.filename]#/tmp# сан доторх файлууд нь систем шинээр ачаалагдах үед хадгалагдалгүйгээр устгагдана. Санах ойгоос ажилладаг файл системүүд голцуу [.filename]#/tmp# санд таниулагдаж байрлуулагддаг. Энэ үйлдэл нь man:rc.conf[5]-тай холбоотой tmpmfs-төрлийг ашиглаж автоматжуулагдаж болдог (эсвэл [.filename]#/etc/fstab# дотор буй оруулгууд бүгдээрээ; man:mdmfs[8]-с харна уу).

|[.filename]#/usr/#
|Програм болон хэрэглэгчийн хэрэглэдэг үндсэн хэрэгслүүд.

|[.filename]#/usr/bin/#
|Үндсэн хэрэгслүүд, програмын багажууд, мөн програмууд.

|[.filename]#/usr/include/#
|Стандарт C-ийн include файлууд.

|[.filename]#/usr/lib/#
|Програмын шахаж бэлдсэн багцууд.

|[.filename]#/usr/libdata/#
|Төрөл бүрийн хэрэгслийн өгөгдлийн файлууд.

|[.filename]#/usr/libexec/#
|Системийн далд чөтгөр буюу дэмон болон системийн хэрэгслүүд (бусад програмаас дуудагдаж ажилладаг).

|[.filename]#/usr/local/#
|Дотоод гүйцэтгэгддэг болон програмын сангууд гэх мэт програмууд байдаг. Мөн FreeBSD-н портуудын анхны байрлуулах газар болж өгдөг. [.filename]#/usr/local# -ийн доторх нь, man:hier[7]-аар [.filename]#/usr# сангийн дотор байгааг байрлуулсан шиг зохион байгуулагдах хэрэгтэй. Гэхдээ энэнд хамаарахгүй сангууд нь man гэж [.filename]#/usr/local/share# сан дотор биш [.filename]#/usr/local# дотор байрладаг сан, мөн [.filename]#share/doc/port# дотор байдаг портуудын бичиг баримт байдаг сан юм. 

|[.filename]#/usr/obj/#
|Архитектураасаа хамаараад [.filename]#/usr/src# санг хөрвүүлэх үед бүтээгддэг сан..

|[.filename]#/usr/ports/#
|FreeBSD Портын цуглуулга (сонгомол).

|[.filename]#/usr/sbin/#
|Системийн дэмон болон системийн хэрэгслүүд (хэрэглэгчдээр гүйцэтгэгдэнэ).

|[.filename]#/usr/shared/#
|Архитектуртаа хамаатай файлууд.

|[.filename]#/usr/src/#
|BSD болон/эсвэл дотоод эх файлууд.

|[.filename]#/usr/X11R6/#
|X11R6 цогцолборын гүйцэтгэж болдог програмууд, програмын сан зэргүүд (сонгомол).

|[.filename]#/var/#
|Олон зорилгоор хэрэглэгддэг бүртгэл бичлэг, түр зуурын, дараалал зэргийн файлууд. Санах ойд тулгуурлаж ажилладаг зарим файлын системүүд [.filename]#/var# дотор танигдаж үүсгэгддэг. Энэ үйлдэл нь man:rc.conf[5]-тай холбоотой varmfs-төрлийг ашиглаж автоматжуулагдаж болдог (эсвэл [.filename]#/etc/fstab# дотор буй оруулгууд бүгдээрээ; man:mdmfs[8]-с харна уу).

|[.filename]#/var/log/#
|Системийн төрөл бүрийн бүртгэл бичлэгийн файлууд.

|[.filename]#/var/mail/#
|Хэрэглэгчийн ирсэн захиаг хадгалах файлууд.

|[.filename]#/var/spool/#
|Төрөл бүрийн хэвлэгч болон захианы системийн дарааллыг удирдах сангууд. 

|[.filename]#/var/tmp/#
|Түр зуурын файлууд. Энэ санд буй файлууд нь голдуу системийг эхлэх үед зориулагдахаар нөөцлөгдсөн байдаг. Гэхдээ, хэрэв [.filename]#/var# нь санах ойд тулгуурласан файлын систем бол өмнө хэлсэн зүйл хүчингүй.

|[.filename]#/var/yp/#
|NIS maps.
|===

[[disk-organization]]
== Диск зохион байгуулалт

FreeBSD нь файл олохын тулд хэрэглэдэг хамгийн жижиг хэрэгсэл бол файлын нэр юм. Файлын нэрний том болон бага үсэгнүүд нь бас ялгаатай. Энэ нь юу гэсэн үг вэ гэвэл [.filename]#readme.txt# болон [.filename]#README.TXT# гэсэн хоёр файл нь хоорондоо ялгаатай файл гэсэн үг. FreeBSD нь файлын төрлийг програм, бичиг баримт, эсвэл бусад төрлийн файл байна гэж ялгахын тулд ([.filename]#.txt#) гэх мэтийн өргөтгөл хэрэглэдэггүй.

Файлууд сан дотор хадгалагддаг. Сан нь зуу зуун файл агуулж болох бөгөөд эсвэл хоосон байж болно. Сан нь сангаа агуулж бас болох ба ингэж сангийн угсарсан модлог бүтэц үүсгэж болно. Ингэвэл та файлуудаа илүү амархан зохицуулах болно.

Файл ба сангууд нь `/` тэмдгийн араас шаардлагатай бол сангуудын нэрийг бичиж өгөгдсөн нэрээрээ хандагдана. Хэрэв танд [.filename]#foo# нэртэй сан нь [.filename]#bar# санг агуулдаг бөгөөд уг сан дотор [.filename]#readme.txt# файл байгаа бол, файлын хандах бүтэн нэр буюу _зам_ нь [.filename]#foo/bar/readme.txt# гэж бичигдэнэ.

Сан болон файлууд нь файл системд хадгалагддаг. Файл систем болгон хамгийн эхний дээд хэсэгт заавал нэг сан агуулдаг бөгөөд, түүнийг уг файл системийн _root сан_ буюу дээд эх сан гэж нэрлэдэг. Тэгээд энэ эх сан нь цаашаагаа өөр сангуудыг агуулж явдаг.

Энэ хүртэл таны уншсан зүйлүүд нь таны бусад мэддэг үйлдлийн системтэй ижил байж магадгүй. Гэхдээ жаахан ялгаанууд бий. Жишээлбэл MS-DOS(R) үйлдлийн систем нь файл болон санг тусгаарлахдаа `\` тэмдэг хэрэглэдэг байхад Mac OS(R) үйлдлийн систем нь `:` тэмдгийг хэрэглэдэг.

FreeBSD дискэнд үсэглэж нэр өгдөггүй бөгөөд үсгээр нэр өгөгдсөн файлын замыг хэрэглэдэггүй. Та FreeBSD дээр [.filename]#c:/foo/bar/readme.txt# гэж бичиж болохгүй.

Харин түүний оронд нэг файл системийг нэг _root файл систем_ гэж ангилдаг. Уг root буюу эх файл системийн эх сан нь `/` гэж хандагдана. Бусад өөр файл системүүд энэ root буюу эх файл систем дотор _холбогддог_. Та FreeBSD систем дээрээ хэдэн ч дисктэй байсан, сан болгонууд нь нэг дискний хэсэг мэт харагддаг.

Жишээлбэл `A`, `B`, мөн `C` гэсэн гурван файл систем танд байна гэж бодъё. Файл систем бүр нь өөртөө хоёр сан агуулсан тус тусын эх сантай гэж үзье. Тэдгээр сангууд нь дараах нэртэй байг. `A1`, `A2` (гэх мэтчилэн `B1`, `B2` мөн `C1`, `C2`).

`A`-г эх сан гэж үзнэ. Хэрэв та `ls` тушаалаар энэ сангийн дотор байгааг харвал, `A1` ба `A2` гэсэн хоёр санг та харах болно. Энэ сангийн модлог загвар нь ингэж харагдаж байна:

image::example-dir1.png[]

Хэрэв файл систем өөр файл системд холбогдохоор бол, холбогдож байгаа системийнхээ нэг сан дор холбогдоно. Тэгвэл одоо `B` файл системийг `A1` санд холбоно гэж үзье. Тэгвэл `B`-ийн эх сан нь `A1`-ээр орлуулагдаж, `B` доторх файлууд дараах маягаар харагдана:

image::example-dir2.png[]

Хэрэв `B1` эсвэл `B2` сан доторх файлууд шаардлага гаран хандагдахаар бол [.filename]#/A1/B1# эсвэл [.filename]#/A1/B2# гэсэн зам хэрэглэгдэж бичигдэнэ. Хэрэв [.filename]#/A1# дотор файлууд байсан бол тэдгээрийг түр зуур нуудаг. `B` файл систем A системээс _салгагдсан_ үед л тэр файлууд харагдана.

Хэрэв `B` файл систем `A2` дор холбогдсон бол дараах маягаар харагдана:

image::example-dir3.png[]

мөн файл уруу хандах зам нь [.filename]#/A2/B1# болон [.filename]#/A2/B2# гэж тус тусдаа хандагдах болно.

Файл системүүд нэг нэгнийхээ дээр холбогдож болдог. Сүүлийн жишээгээ үргэлжлүүлээд `C` файл системийг `B` файл систем доторх `B1` сангийн дээд хэсэгт холбож өгвөл дараах зохион байгуулалт үүсэж байна:

image::example-dir4.png[]

Эсвэл `C` файл систем `A` файл систем дотор `A1` санд холбогдож болно:

image::example-dir5.png[]

Хэрэв та MS-DOS(R) системийг гадарладаг бол энэ нь `join` тушаалтай төсөөтэй боловч яг адилхан биш.

Угтаа бол энэ нь тийм их анхаарлаа хандуулаад байхаар зүйл биш. Ердийн үед та FreeBSD суулгах үедээ нэг файл систем үүсгээд хаана холбохыг нь шийдэж холбоод, шинэ диск нэмэхгүй л бол түүнийгээ хэзээ ч өөрчлөх шаардлага гардаггүй.

Өөр файл систем үүсгэлгүйгээр нэг бүхэл эх файл систем үүсгэж болдог. Ийм үед зарим сул талууд гарч ирдэг бөгөөд нэг л давуу тал үүснэ.

.Олон файл системүүдийн давуу талууд
* Олон төрлийн файл системүүд нь олон төрлийн _холбох нөхцөлтэй_. Жишээлбэл, сайн төлөвлөсний дараагаар, эх файл систем нь зөвхөн уншигдахаар холбогдож, ингэснээр санамсаргүй юм уу алдаа ослын шалтгаанаар чухал файлуудыг устгахаас сэргийлж болно. Хэрэглэгчдээр бичигдэж болдог файл систем, жишээ нь [.filename]#/home# мэтийн бусад системээс тусгаарлаж _nosuid_ төрлийн гэж холбож болно; энэ сонголт нь файл систем дээр буй гүйцэтгэж болдог файлд _suid_/_guid_ бит утга тавигдахаас сэргийлж аюулгүй байдлыг хангаж өгдөг.
* FreeBSD файл систем ямар зорилгоор хэрэглэгдэхээс нь хамаараад файл систем дээр файлын зохион байгуулалтыг автоматаар хийдэг. Тийм болохоор байнга бичигдэж байдаг олон жижигхэн файлуудын байгаа файл систем дээр цөөхөн бичигддэг том файл агуулсан файл системийг бодвол олон бичигдэхэд зориулж арай өөр файлын зохион байгуулалт хийгддэг. Ганц том эх файл системд ийм зохион байгуулалт хийх боломжгүй.
* FreeBSD-н файл систем нь цахилгаан тэжээлээс огцом салгагдсан үед ч дискний алдаа үүсгэдэггүй найдвартай байдаг. Гэвч маш ноцтой үед цахилгаан тэжээлээс огцом салгагдахад файл системийн бүтэц эвдэрч болзошгүй юм. Өгөгдлүүдээ олон файл системд хувааж байрлуулах нь дараа нь эвдрэлээс буцааж сэргээхэд амар байдаг.

.Нэг файл системтэй байх үеийн давуу тал
* Энэ файл систем нь тогтсон хэмжээтэй байдаг. Хэрэв та FreeBSD-ийг суулгах үедээ тодорхой зааж өгсөн файл систем үүсгээд, сүүлд нь түүнийгээ өргөжүүлэхийг хүсвэл, энэ нь тийм амархан биелэхгүй. Та эхлээд байгаа файл системийнхээ файлуудыг нөөцөлж хадгалаад дараа нь файл системдээ шинэ хэмжээ өгч өргөтгөөд дараа нь нөөцөөсөө файлуудаа буцааж сэргээж хадгалах болно.
+
[IMPORTANT]
====
FreeBSD-н man:growfs[8] тушаал нь дээрх хүндрэлийг алга болгож, файлыг нөөцлөх шаардлагагүйгээр шууд файл системийг өргөтгөж болдог болсон.
====

Дискний хуваалт дотор файл систем оршиж байдаг. FreeBSD нь юниксээс уламжилсан болохоор диск хуваалтын ойлголт нь ердийн хэрэглээтэй ижилхэн биш (жишээлбэл, MS-DOS(R) диск зохион байгуулалт). Дискний хуваагдал бүр `a` үсэгнээс эхлээд `h` хүртэл үсгээр тэмдэглэгддэг. Хуваагдал бүр зөвхөн ганцхан файл систем агуулах ёстой. Ийм болохоор файл систем нь агуулж байгаа диск хуваалтынхаа үсгээр илэрхийлэгдэх бөгөөд хэрэв өөр файл системд холбогдвол, холбосон сан нь уг файл системийг илэрхийлнэ.

FreeBSD мөн _swap _-д зориулж дискэнд зай бэлддэг. Swap хэмжээ нь FreeBSD-н _виртуал санах ой_ юм. Ингэснээр таны компьютер байгаа бодит хэмжээнээсээ илүү санах ой хэрэглэж байгаа мэт ажилладаг. Хэрэв зарим програм FreeBSD дээр ажиллаад санах ойноос хэтрэх хүндрэл гарвал, хэрэглэгдэхгүй байгаа хэсгийг swap зай руу зөөж, шаардлагатай үед буцааж санах ой руу зөөх зарчмаар хэрэглэгддэг.

Зарим дискний хуваалт нь тогтсон журамтай байдаг.

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Хуваалт
| Тогтсон журам

|`a`
|Ихэнхдээ root файл системийг агуулж байдаг

|`b`
|Ихэнхдээ swap хэмжээг агуулдаг

|`c`
|Ихэнх үед агуулж буй зүсмэлийнхээ хэмжээтэй ижил хэмжээтэй байдаг. Энэ нь ямар нэгэн хэрэгслүүдийг (жишээлбэл, дискний эвдэрсэн хэсгийг шалгагч) `c` хуваалт дээрх зүсмэл дээр бүхэлд нь ажиллаж болох зөвшөөрөл өгдөг. Ердийн үед та үүн дээр файл систем үүсгэх шаардлага байхгүй.

|`d`
|Урьд нь `d` хуваалт онцгой үүрэгтэй байсан боловч одоо тийм биш, харин ердийн хуваалт шиг хэрэглэгдэж болно.
|===

FreeBSD дээр файл систем агуулж байгаа хуваалтыг _зүсмэл_ гэж нэрлэдэг. Хуваалтын ерөнхий нэр нь FreeBSD дээр зүсмэл гэж яригдах бөгөөд FreeBSD-ийн UNIX(R) гаралд цаад утга учир нь бий. Зүсмэл нь 1 -ээс эхлээд 4 хүртэлх тоогоор дугаарлагдана.

Зүсмэлийн дугаар нь төхөөрөмжийн нэрний араас `s` үсгээр эхэлж бичигддэг. Тэгэхээр "da0_s1_" гэдэг нь, эхний SCSI диск дээрх эхний зүсмэлийг илэрхийлж байна. Диск дээр физик чанараараа зөвхөн дөрвөн ширхэг зүсмэл байрлуулж болно. Харин логик зүсмэлийг та физик зүсмэл дотор дурын хэмжээтэй үүсгэж болно. Ингэж өргөтгөж нэмсэн зүсмэлүүд нь 5 гэсэн дугаараар эхэлж цаашаагаа тоологддог. Тэгэхээр "ad0_s5_" гэдэг нь эхний IDE диск дээрх эхний өргөтгөсөн зүсмэлийг хэлж байна. Ингэж өргөтгөсөн зүсмэлүүд нь файл систем агуулж, систем дээр ердийн зүсмэл мэт харагдаж ажиллана.

Зүсмэлүүд нь физик диск дээр "аюултай зориулалт"аар буюу өөрөөp хэлбэл хүчээр байрлуулагддаг. Харин бусад дискнүүд нь `a` -с эхлээд `h` хүртэл нэрлэсэн _хуваалт_ агуулж болдог. Эдгээр үсэгнүүд нь төхөөрөмжийн ард залгагдаж бичигддэг ба "da0_a_" гэдэг нь эхний da диск дээр байгаа a хуваалтыг илэрхийлж байна. "ad1s3_e_" бол хоёр дахь IDE диск дээр байгаа гурав дахь зүсмэлийн тав дахь хуваалтыг илэрхийлж байна.

Эцэст нь хэлэхэд, диск болгон системд танигдах ёстой. Дискний нэр нь дискний төрлийг илэрхийлсэн үсгээр эхлээд тэгээд араас нь хэд дэх диск вэ гэдгийг нь илэрхийлсэн дугаартай байдаг. Зүсмэлээс ялгарах зүйл нь, дискний дугаар 0 -ээс эхэлдэг. Ерөнхий хэрэглээний жишээг <<basics-dev-codes>> хүснэгтээс харна уу.

Хуваалт уруу хандах үед FreeBSD уг хуваалтыг агуулсан зүсмэл болон дискийг тодорхойлохыг шаарддаг. Тэгээд зүсмэл рүү хандах үед зүсмэлийг агуулсан дискний нэрийг шаардах болно. Тэгэхээр та дискний нэр, `s`, зүсмэлийн дугаар, тэгээд хуваалтын үсэг гэсэн дарааллаар нэрлэх нь байна. Жишээнүүдийг <<basics-disk-slice-part>>-д харуулав.

Танд ойлгоход тань дөхөм болгож <<basics-concept-disk-model>> жишээн дээр дискний зохион байгуулалтын тогтсон загварыг харуулж байна.

FreeBSD суулгахын тулд та эхлээд дискний зүсмэлийг тохируулна, дараа нь зүсмэл дотор FreeBSD-н хэрэглэх хуваалт үүсгээд, дараа нь хуваалт бүрд файл систем (эсвэл swap зайг) үүсгэж эцэст нь хаана холбогдохыг нь (mount) зааж өгдөг.

[[basics-dev-codes]]
.Диск төхөөрөмжийн нэрнүүд
[cols="1,1", frame="none", options="header"]
|===
| Нэр
| Утга

|[.filename]#ad#
|ATAPI (IDE) disk

|[.filename]#da#
|SCSI direct access disk

|[.filename]#acd#
|ATAPI (IDE) CDROM

|[.filename]#cd#
|SCSI CDROM

|[.filename]#fd#
|Floppy disk
|===

[[basics-disk-slice-part]]
.Диск, Зүсмэл, Хуваалтын нэрлэх жишээ
[example]
====
[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Нэр
| Утга

|`ad0s1a`
| Эхний IDE диск (`ad0`) дээрх эхний зүсмэлийн (`s1`) эхний хуваалт (`a`).

|`da1s2e`
| Хоёр дахь SCSI диск (`da1`) дээрх хоёр дахь (`s2`) зүсмэлийн тав дахь (`e`) хуваалт. 
|===
====

[[basics-concept-disk-model]]
.Дискний тогтсон загвар
[example]
====
Дараах загвар нь системд буй IDE диск FreeBSD дээр хэрхэн харагдаж байгааг харуулж байна. Дискний хэмжээг 4 ГБ-н хэмжээтэй гэж үзээд хоёр ширхэг 2 ГБ зүсмэл байна (нэг зүсмэл дээр нь MS-DOS(R) хуваалт байгаа). Эхний зүсмэл нь MS-DOS(R)-н [.filename]#C:# диск агуулсан, харин хоёр дахь зүсмэл дээр FreeBSD суугдсан. Энэ жишээн дээр FreeBSD нь гурван өгөгдлийн хуваалт мөн swap хуваалт хэрэглэж байна.

Гурван хуваалт нь тус тусдаа файл систем агуулж байгаа. `a` хуваалт root файл системд зориулагдаж, `e` хуваалт [.filename]#/var# санд, мөн `f` хуваалт [.filename]#/usr# санд тус тус зориулагдсан.

image::disk-layout.png[]

====

[[mount-unmount]]
== Файл системийг холбох болон салгах

Файл систем нь [.filename]#/# гэсэн эхээс эхлэн модлог хэлбэрээр маш сайн харагддаг. [.filename]#/dev#, [.filename]#/usr#, мөн бусад сангууд нь root буюу эх сангаасаа салбарласан салаа мөчир бөгөөд цаашаа уг мөчир нь бас [.filename]#/usr/local# гэж салаалах зэргээр өргөжиж салаалж болдог.

Эдгээр сангуудын заримыг нь өөр файл системд байрлуулах маш олон шалтгаан бий. [.filename]#/var# сан нь жишээлбэл [.filename]#log/#, [.filename]#spool/#, гэх зэрэг янз бүрийн түр зуурын файлуудыг агуулдаг бөгөөд түргэн дүүрэх магадлалтай. Эх сан буюу root файл систем түргэн дүүрнэ гэдэг бол тийм ч сайн юм биш. Тийм болохоор [.filename]#/var# санг [.filename]#/# сангаас тусад нь өөр газар байрлуулах нь тун хэрэгтэй.

Тодорхой хэдэн сангуудыг тусад нь өөр файл систем дээр байрлуулах хүндтэй шалтгаан бол, хэрвээ уг сангууд нь өөр физик диск дээр, тусдаа виртуал диск дээр, crossref:network-servers[network-nfs,Сүлжээний файл систем] дээр, эсвэл CDROM дээр байх явдал юм.

[[disks-fstab]]
=== [.filename]#fstab# файл

[.filename]#/etc/fstab# файлд жагсаагдсан файл системүүд нь системийн crossref:boot[boot,ачаалах явцад] автоматаар холбогддог (гэхдээ хэрэв тэдгээр нь `noauto` сонголт хэрэглээгүй үед).

[.filename]#/etc/fstab# нь дараах маягийн жагсаалтыг агуулж байдаг:

[.programlisting]
....
төхөөрөмж       /холбох-цэг файл-системийн-төрөл     сонголтууд      dumpfreq     passno
....

`төхөөрөмж`::
Төхөөрөмжийн нэр (заавал байх ёстой). crossref:disks[disks-naming,Төхөөрөмжийн нэрс] хуудсанд тайлбарласан байгаа.

`mount-point буюу холбох цэг`::
Файл системийг байрлуулах сангийн нэр (заавал байх ёстой).

`файл-системийн-төрөл`::
man:mount[8] хуудсанд тайлбарласан байгаа тул алгасав. FreeBSD-н анхдагч файл систем бол `ufs`.

`сонголтууд`::
Уншиж бичигдэх файл системийг заасан `rw` эсвэл зөвхөн уншигдах файл системд зориулсан `ro` сонголт байж болох бөгөөд цаашаагаа мөн нэмэлт сонголтууд агуулж болно. Ердийн сонголт бол `noauto` бөгөөд ингэснээр систем эхлэх үед уг файл систем холбогддоггүй. Бусад сонголтууд man:mount[8] гарын авлагад тодорхой бичигдсэн байгаа.

`dumpfreq`::
Энэ сонголт нь man:dump[8] хэрэгслээр хэрэглэгддэг бөгөөд аль файл системд нөөц хадгалалт хийх вэ гэдгийг тодорхойлж өгдөг. Хэрэв энэ сонголтыг бичээгүй бол хоосон утгыг агуулж байдаг.

`passno`::
Энэ сонголтыг ашиглан ямар дарааллаар файл системүүдийг шалгах вэ гэдгийг зааж өгдөг. Шалгалгүйгээр алгасна гэсэн файл системүүд нь `passno` талбардаа 0 утгатай байх ёстой. root буюу эх файл системийн (энэ файл систем нь хамгийн түрүүнд шалгагддаг) `passno` талбарын утга нь 1 байдаг бөгөөд бусад системийн `passno` нь нэгээс их байх ёстой. Хэрэв нэгээс илүү олон файл системүүд `passno` талбартаа ижил утгатай бол man:fsck[8] нь тэдгээр файл системийг хэрэв боломжтой зэрэг шалгахыг оролдох болно.

[.filename]#/etc/fstab# файлын бүтэц болон тохируулдаг сонголтуудын тухай дэлгэрэнгүй мэдээллийг man:fstab[5] гарын авлагаас харна уу.

[[disks-mount]]
=== `mount` тушаал

man:mount[8] тушаал нь файл системийг холбоход хэрэглэгддэг цорын ганц тушаал юм.

Таны хамгийн өргөн хэрэглэх хэлбэр бол:

[source,shell]
....
# mount төхөөрөмж-буюу-диск холбох-цэг
....

man:mount[8]-н гарын авлагад зааснаар бол маш олон сонголт байдаг бөгөөд өргөн хэрэглэгддэг нь:

.Холбох тохируулгууд
`-a`::
[.filename]#/etc/fstab# файлд жагсааж бичсэн бүх файл системийг холбоно. Гэхдээ "noauto" гэж тэмдэглэснийг, `-t` гэж туг хатгасныг, эсвэл өмнө нь холбогдчихсон файл системүүдийг холбохгүй.

`-d`::
Дуудаж ажиллуулж байгаа файл системээсээ бусдад нь дурын үйлдлээ хийнэ. Энэ сонголтыг `-v` тугтай хамт хэрэглэж man:mount[8]-г юу хийж байгааг нь харж болдог.

`-f`::
Бохир файл систем (аюултай), эсвэл файл системийн унших-бичигдэх төлвөөс зөвхөн-унших төлөв рүү шилжүүлэн бичих эрхийг хасаж холбох үед хүчээр холбодог.

`-r`::
Файл системийг зөвхөн-унших төлвөөр холбоно. Энэ нь `-o` сонголтыг `ro` утгатай хэрэглэсэнтэй ижил.

`-t` _fstype_::
Өгөгдсөн файл системйиг өгөгдсөн төрлөөр холбоно. Эсвэл `-a` сонголт өгөгдсөн бол зөвхөн өгөгдсөн төрлөөр холбоно.
+
"ufs" нь анхдагч файл систем юм.

`-u`::
Файл системд холболтын сонголтыг шинэчилнэ.

`-v`::
Болж байгаа үйл явцыг харуулж мэдэгдэнэ.

`-w`::
Файл системийг унших-бичих төлвөөр холбоно.

`-o` сонголт нь дараах зүйлүүдийг таслалаар тусгаарлаж хэрэглэж болно:

noexec::
Энэ нь файл систем дээр хоёрлосон файл буюу ачаалагдаж ажиллаж болдог файл ажиллахыг үл зөвшөөрнө. Энэ нь мөн аюулгүй байдлын зорилгоор хэрэгтэй.

nosuid::
Файл систем дээр setuid эсвэл setgid тугуудыг бүү хэрэглэ. Мөн аюулгүй байдлын шалтгаанаар.

[[disks-umount]]
=== `umount` тушаал

man:umount[8] тушаал нь ардаа холбосон цэг, төхөөрөмжийн нэр зэргийг авдаг бөгөөд мөн `-a` сонголт эсвэл бас `-A` сонголтуудыг авч болдог.

Бүх хэлбэрүүд нь `-f` сонголтыг хүчээр салгах үед болон `-v` сонголтыг явцын мэдээллийг харахад хэрэглэдэг. `-f` сонголт нь тийм сайн санаа биш гэдгийг анхааруулмаар байна. Хүчээр файл системийг салгах нь файл эсвэл системийн эвдрэлд хүргэж болзошгүй.

`-a` болон `-A` сонголтууд нь холбогдсон бүх файл системийг салгахад хэрэглэгддэг. Эсвэл мөн `-t` сонголтоор өөрчлөгдсөн файл системүүдийг салгахад хэрэглэнэ. Гэхдээ `-A` сонголт нь root файл системийг салгах гэж оролддоггүй.

[[basics-processes]]
== Процесс буюу програмын явц

FreeBSD бол олон үйлдэл зэрэг хийх чадвартай систем. Энэ нь олон програм нэг дор зэрэг ажиллана гэсэн үг. Програмын тухайн үед ажиллаж байгааг нь _процесс буюу програмын явц_ гэдэг. Таны ажиллуулсан тушаал болгон шинэ процесс эхлүүлдэг бөгөөд систем дээр бүхэлдээ тэр чигээрээ процессууд үргэлж ажиллаж системийн ажиллагааг бүрэлдүүлж байдаг.

Програмын явц бүр _процесс ID_, эсвэл _PID_ гэсэн дугаар агуулж байдаг бөгөөд файлтай бас ижилхэн өөрийн гэсэн эзэмшигч болон бүлэгт харъяалагдаж байдаг. Эзэмшигч ба бүлгийн мэдээлэл нь уг процесс файлд хандах эрхийг нь хэрэглэж файлтай хэрхэн хандах вэ гэдгийг тодорхойлж өгдөг. Ихэнх процесс нь мөн эцэг процесстой байдаг. Эцэг процесс нь тэдгээр процессийг эхлүүлж өгдөг. Жишээлбэл, хэрэв та тушаалуудыг бүрхүүлд бичиж гүйцэтгэвэл, бүрхүүл ч процесс, тушаалууд ч процесс болдог бөгөөд таны бичсэн тушаал болгон процесс болдог. Ийм маягаар ажиллуулаад байвал бүрхүүл нь тэдгээр процессуудын эцэг нь болно. Үүнээс өөр онцгой процесс байдаг ба түүнийг man:init[8] процесс гэж нэрлэдэг. `init` бол хамгийн эхний процесс байдаг бөгөөд үүний PID дугаар үргэлж 1 байдаг. FreeBSD эхлэх үед `init` процесс автоматаар эхэлдэг.

Системд гүйцэтгэгдэж байгаа процессуудыг хардаг хоёр тушаал бол man:ps[1] ба man:top[1] хоёр юм. `ps` тушаал нь одоо ажиллаж байгаа процессуудыг PID дугаартай нь харуулж, мөн хичнээн санах ойн хэмжээ хэрэглэж байгаа, ямар тушаалаар гүйцэтгэгдэж байгаа зэргийг нь харуулдаг. `top` тушаал нь ажиллаж байгаа бүх процессуудыг харуулдаг бөгөөд хэдэн секунд тутамд шинэчлэгдэж байдаг. Ингэснээр таны компьютер тухайн үед юу хийж байгааг харж болно.

Анхдагч горимондоо, `ps` тушаал нь зөвхөн таны эзэмшиж байгаа процессуудыг харуулдаг. Жишээлбэл:

[source,shell]
....
% ps
  PID  TT  STAT      TIME COMMAND
  298  p0  Ss     0:01.10 tcsh
 7078  p0  S      2:40.88 xemacs mdoc.xsl (xemacs-21.1.14)
37393  p0  I      0:03.11 xemacs freebsd.dsl (xemacs-21.1.14)
48630  p0  S      2:50.89 /usr/local/lib/netscape-linux/navigator-linux-4.77.bi
48730  p0  IW     0:00.00 (dns helper) (navigator-linux-)
72210  p0  R+     0:00.00 ps
  390  p1  Is     0:01.14 tcsh
 7059  p2  Is+    1:36.18 /usr/local/bin/mutt -y
 6688  p3  IWs    0:00.00 tcsh
10735  p4  IWs    0:00.00 tcsh
20256  p5  IWs    0:00.00 tcsh
  262  v0  IWs    0:00.00 -tcsh (tcsh)
  270  v0  IW+    0:00.00 /bin/sh /usr/X11R6/bin/startx -- -bpp 16
  280  v0  IW+    0:00.00 xinit /home/nik/.xinitrc -- -bpp 16
  284  v0  IW     0:00.00 /bin/sh /home/nik/.xinitrc
  285  v0  S      0:38.45 /usr/X11R6/bin/sawfish
....

Дээрх жишээнд харуулснаар, man:ps[1] тушаалын гаралт нь хэд хэдэн баганаар харуулагдаж байна. `PID` бол өмнө ярьсны дагуу процессийн ID дугаар. PID дугаарууд нь 1 гэж эхлээд 99999 хүртэл дугаарлагддаг бөгөөд хэтрээд ирэхээрээ эхнээсээ эхэлж тоологддог (PID нь ашиглагдаж байгаа бол дахин олгогддоггүй). `TT` багана нь, уг програмын ажиллаж байгаа tty буюу терминалыг нь харуулдаг бөгөөд одоохондоо хэрэгсэх шаардлага байхгүй. `STAT` нь програмын төлвийг харуулдаг бөгөөд мөн одоохондоо хэрэгсэхгүй байж болно. `TIME` нь процессор дээр хэр удаан ажиллаж байгааг нь заадаг бөгөөд гэхдээ энэ нь програм эхэлснээс хойш тооцож эхэлсэн цаг биш. Ихэнх програм нь процессор дээр гүйцэтгэх гэж хэсэг хугацаа зарцуулж хүлээдэг. Эцэст нь, `COMMAND` нь тухайн програмыг ажиллуулсан тушаалыг харуулдаг.

Харуулах мэдээллээ өөрчилж болдог хэд хэдэн нэмэлт сонголт man:ps[1] тушаалд бий. Байнга хэрэглэгддэг сонголтуудын багц бол `auxww` юм. `a` сонголт нь зөвхөн өөрийн эзэмшдэг процесс биш харин ажиллаж байгаа бүх процессийг харуулдаг. `u` сонголт нь процессийг эзэмшиж байгаа хэрэглэгчийн нэрийг харуулдаг бөгөөд мөн хэрэглэж байгаа санах ойг нь харуулдаг. `x` сонголт нь далд ажиллаж байгаа буюу дэмон эсэхийг нь харуулдаг. `ww` сонголт нь процессуудыг ажиллуулсан тушаалын бүтэн нэрийг нь харуулдаг. Бусад үед, хэрэв тушаалын нэр нь дэлгэцэнд багтахгүй урт байх тохиолдолд хасаж харуулдаг.

man:top[1] тушаалын гаралт нь өмнөх жишээтэй ижилхэн. Жишээ болгож нэг гаралтыг харцгаая:

[source,shell]
....
% top
last pid: 72257;  load averages:  0.13,  0.09,  0.03    up 0+13:38:33  22:39:10
47 processes:  1 running, 46 sleeping
CPU states: 12.6% user,  0.0% nice,  7.8% system,  0.0% interrupt, 79.7% idle
Mem: 36M Active, 5256K Inact, 13M Wired, 6312K Cache, 15M Buf, 408K Free
Swap: 256M Total, 38M Used, 217M Free, 15% Inuse

  PID USERNAME PRI NICE  SIZE    RES STATE    TIME   WCPU    CPU COMMAND
72257 nik       28   0  1960K  1044K RUN      0:00 14.86%  1.42% top
 7078 nik        2   0 15280K 10960K select   2:54  0.88%  0.88% xemacs-21.1.14
  281 nik        2   0 18636K  7112K select   5:36  0.73%  0.73% XF86_SVGA
  296 nik        2   0  3240K  1644K select   0:12  0.05%  0.05% xterm
48630 nik        2   0 29816K  9148K select   3:18  0.00%  0.00% navigator-linu
  175 root       2   0   924K   252K select   1:41  0.00%  0.00% syslogd
 7059 nik        2   0  7260K  4644K poll     1:38  0.00%  0.00% mutt
...
....

Тушаалын гаралт хоёр хэсэгт хуваагдсан байна. Толгой хэсэг (эхний таван мөр) нь сүүлд ажиллаж байгаа PID дугаарыг, системийн ачаалалтын дунджууд (энэ нь системийг хэр завгүй байгааг илтгэдэг), системийн асаалттай байгаа хугацаа (унтраалгүй хэр удсан эсэхийг) мөн одоогийн цаг зэргийг харуулдаг. Бусад илэрхийллүүд нь, хичнээн процессууд ажиллаж байгаа (энэ тохиолдолд 47 ), хичнээн санах ойн хэмжээ болон swap хэмжээ хэрэглэгдэж байгаа, мөн хичнээн хугацааг процессорын бусад төлөв байдалд зарцуулсан зэргийг илэрхийлж байна.

Доорх баганууд нь man:ps[1] тушаалтай ойролцоо мэдэгдлүүдийг харуулж байна. Эхлээд PID дугаар дараа нь хэрэглэгчийн нэр, процессороос хэрэглэсэн хугацаа, ажиллуулсан тушаал гэх мэт. man:top[1] тушаал нь анхдагч тохируулгаараа, процессийн хэрэглэж байгаа санах ойн хэмжээг харуулдаг. Тэр хэсэг нь хоёр баганад харуулагддаг бөгөөд эхнийх нь нийт хэмжээ дараагийх нь тухайн үеийнх нь хэмжээ юм. Нийт хэмжээ гэдэг нь програм ажиллахад хэд хэрэгтэйг хэлдэг бөгөөд тухайн үеийнх нь хэмжээ нь одоогоор хэдийг хэрэглэж байгааг заадаг. Энэ жишээн дээр man:getenv[3] програм бараг 30 МБ хэмжээг RAM санах ойд шаардлагатай гэсэн боловч одоогоор 9 МБ хэмжээ хэрэглэж байна гэж заасан байна.

man:top[1] нь энэ харуулалтыг хоёр секунд тутам шинэчилдэг бөгөөд үүнийг `s` тохируулгаар өөрчилж болно.

[[basics-daemons]]
== Далд чөтгөр буюу дэмонууд, дохионууд, мөн процессуудыг зогсоох нь

Та хэрэв ямар нэг текст засварлагч дээр ажиллаж байхдаа файл нээх, хаах, хадгалах гэх мэт уг програмыг сайн хянаж чаддаг. Та яагаад тэгж чадаж байна вэ гэвэл, уг програм нь _терминал_ дээр холбогдон ажиллаж танд тийм боломж олгож байгаа билээ. Зарим програм тэгэхэд үргэлж хүн гарнаас оруулалт хийх шаардлагагүй зориулалтаар бүтээгдсэн байдаг бөгөөд хамгийн эхний боломж гарангуут терминалаас салангид ажилладаг. Жишээлбэл вэб серверүүд өдөржин хүмүүсээс ирсэн хүсэлтэд хариулт өгч байдаг бөгөөд ердийн үед танаас оруулга шаарддаггүй. Ийм төрлийн бас нэг програм бол захиа илгээгч програм юм.

Бид ийм програмыг _далд чөтгөр буюу дэмон_ гэж нэрлэдэг. Дэмонууд нь Грекийн домогт байдаг сайн муугийн аль нь ч биш бөгөөд жижигхэн мөртлөө хүмүүст хэрэгтэй юм хийж байдаг сүнсийг хэлдэг. Вэб сервер болон захианы серверүүд үүнтэй ижил хүмүүст тустай юм хийдэг. Тийм болохоор BSD нь спорт шаахайтай, жижигхэн, сэрээ барьсан чөтгөрийг олон жилээр дуртайяа өөрийнхөө билэг тэмдэг болгож байгаа билээ.

Далд ажиллаж байгаа буюу дэмон болж ажиллаж байгаа програмын нэрний ард "d" үсэг залгаж бичдэг зарчим бий. BIND програмын бүтэн нэр нь Berkeley Internet Name Daemon бөгөөд үндсэн далд ажилладаг програмын нэр нь `named`, мөн Apache вэб серверийн далд ажилладаг програмын нэр нь `httpd`, хэвлэх дарааллыг далд ажиллаж зохицуулж байдаг програмын нэр нь `lpd` гэх мэт нэртэй байдаг. Энэ нь ерөнхийдөө ингэж зарчим гаргасан болохоос хатуу тогтоосон дүрэм биш; жишээлбэл захиа илгээгч үндсэн програм Sendmail-н далд ажилладаг програмыг та `maild` гэж төсөөлж байгаа бол эндүүрэх бөгөөд харин `sendmail` гэж нэрлэдэг.

Заримдаа та эдгээр дэмон процессуудтай холбогдож харилцах хэрэг гарна. Ингэх нэг арга нь түүн рүү (эсвэл бусад ажиллаж байгаа процесс уруу) _дохио_ гэгддэг зүйл илгээх явдал юм. Маш олон төрлийн илгээж болох дохионууд байдаг - зарим дохионууд онцгой зориулалттай нийтэд нь хэрэгждэг, зарим нь тухайн програмдаа зориулж өөр өөрөөр хөрвүүлэгддэг бөгөөд програмын заавар дээр ямар дохиог яаж хөрвүүлэн ойлгох вэ гэдгийг заасан байдаг. Та өөрийнхөө эзэмшиж байгаа процесс уруугаа дохио илгээж болно. Хэрэв та бусдын эзэмшдэг процесс уруу man:kill[1] эсвэл man:kill[2] гэх зэрэг дохио илгээвэл таны эрх дутаж хэрэгждэггүй. Гэхдээ ийм эрхээр дутагддаггүй хэрэглэгч бол `root` хэрэглэгч бөгөөд хүн болгоны процесс уруу дохио илгээж чаддаг.

Мөн FreeBSD-ээс програм уруу зарим тохиолдолд дохио илгээдэг. Жишээлбэл, хэрэв муу зохиогдсон нэг програм санах ойг зориулсан хэмжээнээсээ илүү хэрэглээд эхэлбэл FreeBSD уг програм уруу _Хэсгийн буруу хэрэглээ_ дохио илгээдэг (`SIGSEGV`). Мөн хэрэв ямар нэгэн програм нь man:alarm[3] гэдэг системийн сануулах програмыг ашигласан бол тухайн хугацаа нь хэтрэх үед Сэрүүлэг дохио уг програмд ирэх (`SIGALRM`) зэрэг олон дохио бий.

Процесийг зогсоох хоёр дохио байдаг, `SIGTERM` ба `SIGKILL` хоёр. `SIGTERM` нь арай эелдэг аргаар процессийг зогсоодог; процесс нь эхлээд дохиог _хүлээж аваад_ өөрийг нь хаах гэж байгаад мэдээд нээлттэй байгаа бүртгэл бичлэг файлуудаа хаагаад тэгээд хийж байгаа ерөнхий үйлдлээ зогсоодог. Зарим тохиолдолд уг процесс нь таслагдаж болохооргүй үйлдэл хийж байх үедээ `SIGTERM` дохиог хэрэгсэхгүй байдал үүсдэг.

`SIGKILL` дохиог ямар ч процесс хэрэгсэхгүй байж чаддаггүй. Өөрөөр хэлбэл энэ нь "Чиний юу хийж байх нь надад хамаагүй, одоо шууд зогсоо" гэсэн дохио юм. Хэрэв та `SIGKILL` дохиог процесс уруу илгээвэл FreeBSD уг процессийг зогсоодог .

Таны хэрэглэж болохоор бусад дохионууд нь `SIGHUP`, `SIGUSR1`, мөн `SIGUSR2`. Эдгээр дохио нь ерөнхий зориулалтаар хэрэглэгддэг бөгөөд эдгээр дохиог хүлээж авсан програмууд тус тусдаа өөр өөр хариу үйлдэл хийдэг.

Жишээлбэл, та вэб серверийнхээ тохируулгын файлд өөрчлөлт хийгээд уг серверийг тохируулгын файлаа дахин шинээр уншуулахыг хүссэн гэж бодъё. Та `httpd` дэмоноо зогсоогоод дахин шинээр эхлүүлж болох боловч ажиллаж байгаа вэб серверийг зогсоож болохгүй нөхцөл байж болно. Ихэнх дэмонууд нь `SIGHUP` дохиог хүлээж авбал өөрийнхөө тохируулгынхаа файлыг уншина гэж тохируулагдсан байдаг. Тэгэхээр `httpd` дэмоноо зогсоогоод шинээр ачаалж байхын оронд `SIGHUP` дохиог илгээхэд хангалттай. Учир нь энэ дохионд тэгж хариулна гэсэн тогтоосон арга зам байхгүй тул дэмон болгон өөр өөр үйлчлэл үзүүлдгийг ойлгож тухайн дэмоны заавар бичгийг нь судлах хэрэгтэй. 

дохио илгээхдээ man:kill[1] тушаалыг ашигладаг. 

[.procedure]
====
*Procedure: Процесс уруу дохио илгээх*

Энэ жишээ нь man:inetd[8] уруу хэрхэн дохио илгээхийг харуулах болно. `inetd` -н тохируулгын файл [.filename]#/etc/inetd.conf# гэж байрласан бөгөөд `inetd`-ийг тохируулгын файлаа дахин уншуулахын тулд `SIGHUP` дохиог илгээх болно.

. Илгээх процессийн процесс ID дугаарыг мэдэх хэрэгтэй. Ингэхийн тулд man:pgrep[1] тушаалыг ашиглана.
+
[source,shell]
....
% pgrep -l inetd
  198  inetd -wW
....
+ 
За тэгэхээр, man:inetd[8]-ийн PID дугаар нь 198 гэж энэ тохиолдолд хэлж байна. Зарим тохиолдолд `grep inetd` гэсэн тушаал нь өөрөө энэ гаралтад байж байдаг. Учир нь, man:ps[1] програм нь уг тушаалыг ажиллуулж байгаа процессийг олсон үед тэгж гаргаж харуулдаг.
+
. man:kill[1] тушаалыг хэрэглэж дохио илгээнэ. man:inetd[8] нь `root` хэрэглэгчээр гүйцэтгэгдэж байгаа болохоор, та эхлээд man:su[1] тушаалыг ашиглан `root` хэрэглэгч болох хэрэгтэй.
+
[source,shell]
....
% su
Password:
# /bin/kill -s HUP 198
....
+ 
Ихэнх UNIX(R) системийн тушаалуудын адил, man:kill[1] тушаал нь хэрэв амжилттай хэрэгжвэл ямар нэгэн төлвийн мэдээлэл харуулдаггүй. Хэрэв та өөрийнхөө эзэмшдэггүй процесс уруу дохио илгээвэл `kill: _PID_: Operation not permitted` буюу энэ үйлдлийг хийх эрх байхгүй байна гэсэн мэдэгдэл гарч ирнэ. Хэрэв та PID дугаараа буруу бичих, эсвэл буруу процесс уруу дохио илгээвэл, азгүй тохиолдолд уг дохио нь тухайн процесс уруу илгээгдэх бөгөөд, уг процесс нь азаар байхгүй байгаа тохиолдолд `kill: _PID_: No such process` буюу тийм процесс алга байна гэсэн мэдэгдэл гарч ирнэ.
+
[NOTE]
.Яагаад `/bin/kill` тушаалыг хэрэглэх хэрэгтэй вэ?
======
Ихэнх shells буюу бүрхүүлүүд `kill` тушаалыг өөртөө агуулсан байдаг бөгөөд [.filename]#/bin/kill# тушаалыг бичихийн оронд шууд бүрхүүлд буй тушаалыг нь гүйцэтгэх нь шулуухан байдаг. Энэ нь амарчилсан ашигтай арга боловч бүрхүүл болгон өөрсдийн илгээх дохионы өөр өөр нэртэй байдгийг мэдэх хэрэгтэй. Тийм болохоор бүрхүүл болгоны дохионы бичлэгийг судлахын оронд шууд `/bin/kill ...` тушаалыг хэрэглэх нь зөв арга юм.
======
====

Бусад дохио илгээх үйлдлүүд нь үүнтэй тун ижил бөгөөд `TERM` эсвэл `KILL` дохионуудын оронд шаардлагатай дохиогоо бичих хэрэгтэй.

[IMPORTANT]
====
Санаанд орсон тоотой дохио болгоныг устгана гэдэг бол буруу санаа юм. man:init[8] процесс ялангуяа 1 гэсэн процесс ID байх нь онцгой тохиолдол. Тийм болохоор `/bin/kill -s KILL 1` гэвэл системийг шууд унтраана. man:kill[1] тушаалыг гүйцэтгэхээсээ өмнө kbd:[Return] товч дарахынхаа _өмнө__үргэлж_ ямар процесс уруу ямар дохио илгээж байгаагаа давхар шалгах хэрэгтэй.
====

[[shells]]
== Shell буюу бүрхүүл

FreeBSD дээр маш олон ажил тушаал бичиж оруулдаг shell буюу бүрхүүл хэмээх орчинд хийгддэг. Бүрхүүлийн гол үүрэг нь гарнаас оруулсан тушаалыг гүйцэтгэх юм. Өдөр болгон гүйцэтгэхэд шаардагддаг файл зохицуулах, тушаал оруулагч мөрийг засварлах, тушаалын багц, орчны хувьсагч зэрэг туслах тушаалуудыг олон бүрхүүлүүд агуулж байдаг. FreeBSD нь `sh` буюу Bourne Shell, мөн `tcsh` буюу сайжруулсан C-shell зэрэг багц бүрхүүлүүдтэй хамт ирдэг. `zsh` болон `bash` зэрэг маш олон бүрхүүлүүд FreeBSD-ийн портын цуглуулганд ирдэг.

Та ямар бүрхүүл хэрэглэдэг вэ? Энэ бол тухайн хүний дур сонирхолтой хамаатай. Хэрэв та C програмын хэл дээр програм бичдэг бол C-тэй адилхан бичигддэг `tcsh` төрлийн бүрхүүлд дуртай болж болох юм. Хэрэв та Linux системээс ирсэн юм уу эсвэл UNIX(R)-ийн тушаалуудтай дөнгөж танилцаж байгаа шинэ хүн бол `bash` бүрхүүлээр эхлэх нь амар байж болох юм. Хамгийн гол нь бүрхүүл болгон өөрийн гэсэн онцгой шинж чанартай болохоор өөрийнхөө хүсэл зорилгод тааруулж бүрхүүлээ сонгож дадах нь чухал.

Бүрхүүлийн хамгийн энгийн чадвар бол файлын нэрийн автомат гүйцэтгэл юм. Тушаал юм уу файлын эхний хэдхэн үсгийг бичээд гарын kbd:[Tab] товчийг дарахад уг үсгээр эхэлсэн файлын нэрийг танд гүйцээж бичиж өгдөг. Энд нэг жишээ авч үзье. Танд [.filename]#foobar# болон [.filename]#foo.bar# гэсэн хоёр файл байгаа гэж бодъё. Та [.filename]#foo.bar# файлыг устгахыг хүсэв. Тэгвэл та компьютерийнхаа гаран дээр ингэж бичих болно: `rm fo[Tab].[Tab]`.

Бүрхүүл танд ингэж харуулна `rm foo[BEEP].bar`.

[BEEP] гэдэг нь консолоос гаргаж байгаа хонхны дуу бөгөөд ингэж эхэлсэн файлын нэр нэгээс олон байгааг танд мэдэгдэж байгаа юм. [.filename]#foobar# болон [.filename]#foo.bar# хоёр хоёулаа `fo` гэж эхэлж байгаа ч гэсэн `foo` гэж танд дүүргэж өгдөг. Хэрэв та `.` гэж бичээд kbd:[Tab] дахин дарвал бүрхүүл танд уг хүссэн файлын тань нэрийг гүйцээж өгдөг.

Бүрхүүлийн бас нэг шинж чанар бол орчны хувьсагчийн хэрэглээ юм. Орчны хувьсагч гэдэг нь бүрхүүлийн орчинд хадгалагддаг, нэрэнд утга өгсөн хослол байдаг. Энэ бүрхүүлийн орчин нь уг бүрхүүлээс гүйцэтгэгдэж байгаа бүх програм болон програмын тохируулгад харагдаж байдаг. Байнга хэрэглэгддэг ерөнхий орчны хувьсагчдыг дор жагсааж тайлбарлав:

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Хувьсагч
| Тодорхойлолт

|`USER`
|Холбогдсон байгаа тухайн хэрэглэгчийн нэр.

|`PATH`
|Ачаалагдаж болдог хоёртын файлуудыг агуулдаг сангуудыг таслалаар тусгаарлаж бичсэн жагсаалт.

|`DISPLAY`
|Хэрэв холбогдох боломжтой бол, X11 дэлгэцийн сүлжээгээр холбогдох цэг.

|`SHELL`
|Хэрэглэж байгаа shell буюу бүрхүүл.

|`TERM`
|Хэрэглэгчийн терминалын төрлийн нэр. Терминалын шинж чанарыг тодорхойлоход хэрэглэгддэг.

|`TERMCAP`
|Төрөл бүрийн терминалуудад алгасах ёстой кодуудын өгөгдлийн бааз.

|`OSTYPE`
|Үйлдлийн системийн төрөл. жишээ нь, FreeBSD.

|`MACHTYPE`
|Системийн ажиллаж байгаа процессорын архитектур.

|`EDITOR`
|Хэрэглэгчийн эрхэмлэж хэрэглэгддэг текст засварлагч.

|`PAGER`
|Хэрэглэгчийн эрхэмлэж хэрэглэдэг пэйжер.

|`MANPATH`
|Таслалаар тусгаарлаж жагсаасан, гарын авлагын хуудсуудыг агуулсан хайх сангууд.
|===

Бүрхүүл болгонд орчны хувьсагчаа өөр өөр тохируулдаг. Жишээлбэл, C-маягийн бүрхүүл `tcsh` болон `csh` дээр, та `setenv` тушаалыг ашиглаж орчны хувьсагчийг зааж өгдөг. Bourne төрлийн бүрхүүлүүд болох `sh` болон `bash` дээр, та `export` тушаалыг ашиглаж орчны хувьсагчийг зааж өгнө. Жишээ нь, орчны хувьсагч `EDITOR`-г өөрчлөх юм уу зааж өгөхийн тулд `csh` юм уу эсвэл `tcsh` бүрхүүл дээр `EDITOR` хувьсагчид [.filename]#/usr/local/bin/emacs# утгыг өгөхийн тулд:

[source,shell]
....
% setenv EDITOR /usr/local/bin/emacs
....

Bourne бүрхүүлүүд дээр:

[source,shell]
....
% export EDITOR="/usr/local/bin/emacs"
....

Ихэнх бүрхүүлийн орчны хувьсагчийн утгыг харахын тулд хувьсагчийн нэрний урд `$` тэмдгийг хэрэглэж харна. Жишээ нь, `echo $TERM` гэсэн тушаал нь `$TERM` хувьсагчид ямар утга байгааг консол дээр харуулна. Учир нь, бүрхүүл `$TERM` дотор буй утгыг `echo` тушаалд дамжуулж өгснөөр консол дээр харуулагддаг.

Бүрхүүл маш олон тэмдэгтийг тусгай зориулалтаар өгөгдлийг илэрхийлэхдээ хэрэглэдэг бөгөөд тэдгээр тэмдэгтийг мета-тэмдэгтүүд гэж нэрлэдэг. Байнга хэрэглэгддэг тэмдэгтийн нэг нь `*` юм. Энэ тэмдэгт нь файлын нэрэнд байгаа тэмдэгтүүдийг хэд ч байсан хамаагүй орохыг илэрхийлдэг. Тэдгээр мета-тэмдэгтүүд нь файлын нэрийг орлуулахад байнга хэрэглэгддэг. Жишээлбэл, `echo *` гэсэн тушаал нь `ls` тушаалтай ижилхэн үүрэг гүйцэтгэх бөгөөд, яагаад гэвэл бүрхүүл нь `*` тэмдэгтэд тохирох бүх файлуудыг авч `echo` тушаал руу дамжуулж харуулдаг.

Бүрхүүл дээр мета-тэмдэгтүүдийг хэрэв тухайн онцгой тохиолдлоор нь биш харин зүгээр тэмдэгт хэлбэрээр нь хэрэглэхийг хүсвэл, уг тэмдэгтийн урд ташуу зураасыг (`\`) бичиж өгдөг. `echo $TERM` гэсэн тушаал нь ямар терминал заагдсан байгааг харуулна. Харин `echo \$TERM` тушаал нь ердөө `$TERM` гэж харуулна.

[[changing-shells]]
=== Өөрийнхөө бүрхүүлийг солих

Бүрхүүлээ буюу shell-ээ солих хамгийн амархан арга бол `chsh` тушаалыг хэрэглэх юм. `chsh` тушаал нь таныг `EDITOR` орчны хувьсагчид заагдсан засварлагч уруу оруулдаг бөгөөд хэрэв энэ хувьсагчид утга заагдаагүй байвал шууд `vi` засварлагчийг ажиллуулдаг. Тэгээд та "Shell:" мөрөнд буй утгыг өөрчилж бүрхүүлээ өөрчилнө.

Та мөн `chsh` тушаалыг `-s` сонголттой хэрэглэж болох бөгөөд ингэсэн үед нэмэлт засварлагч нээлгүйгээр шууд бүрхүүлийг өөрчилдөг. Жишээ нь та өөрийнхөө бүрхүүлийг `bash` бүрхүүлээр солихыг хүсвэл дараа тушаалыг өгөх болно:

[source,shell]
....
% chsh -s /usr/local/bin/bash
....

[NOTE]
====
Таны хэрэглэхийг хүсэж байгаа бүрхүүл тань [.filename]#/etc/shells# файл дотор _заавал_ байх ёстой. Хэрэв та crossref:ports[ports,портын цуглуулгаас] бүрхүүл суулгасан бол энэ нь автоматаар хийгдчихдэг. Харин та гар аргаар ямар нэг бүрхүүл суулгавал энэ файлд өөрөө нэмэх хэрэгтэй.

Жишээ нь та `bash` бүрхүүлийг гар аргаар суулгаад [.filename]#/usr/local/bin# байршилд байрлуулсан бол дараах тушаалыг өгөх хэрэгтэй:

[source,shell]
....
# echo "/usr/local/bin/bash" >> /etc/shells
....

Тэгээд дараа нь `chsh` тушаалыг хэрэглэх хэрэгтэй.
====

[[editors]]
== Текст засварлагчид

FreeBSD дээр текст файлуудыг засварлаж маш олон тохиргоонуудыг хийдэг. Тийм болохоор та текст засварлагч дээр гаршиж сурах нь чухал. FreeBSD нь үндсэн хэдэн засварлагчтай хамт ирдэг бөгөөд портын цуглуулга дээрээ бол олон зуун засварлагчтай.

Хамгийн амархан бөгөөд сурахад хялбар засварлагч бол ee бөгөөд easy editor буюу хялбар засварлагч гэдгийг товчилсон нэр юм. ee-г эхлүүлэхийн тулд тушаал бичих мөрөнд `ee файлын-нэр` гэж бичих бөгөөд _файлын-нэр_ нь засварлагдах файлын нэр. Жишээ нь, [.filename]#/etc/rc.conf# файлыг засварлахын тулд `ee /etc/rc.conf` гэж бичнэ. `ee` засварлагч дотроо дээд хэсэгт нь програмыг хэрэглэх заавар нь бичээстэй байдаг. `^` гэсэн тэмдэг нь гарын kbd:[Ctrl] товчийг илэрхийлдэг бөгөөд `^e` гэдэг нь kbd:[Ctrl+e] гэсэн гарын товчлол юм. ee програмаас гарахын тулд kbd:[Esc] товч дараад leave editor буюу засварлагчаас гарна гэдгийг сонгох хэрэгтэй. Хэрэв файлд өөрчлөлт орсон бол гарахаас өмнө хадгалах эсэхийг лавлаж асуух болно.

Мөн FreeBSD нь vi гэсэн хүчирхэг засварлагчийг системийн үндсэн хэсэгтэй цуг зөөвөрлөдөг бөгөөд бас Emacs болон vim зэрэг зaсварлагчдыг FreeBSD Портын цуглуулгадаа багтаасан байдаг (package:editors/emacs[] болон package:editors/vim[]). Эдгээр засварлагчид нь ажиллах хүчин чадвараараа илүү боловч сурахад арай илүү төвөгтэй байдаг. Гэвч та текст файлыг засварлахад маш их хөдөлмөр гаргахаар бол vim эсвэл Emacs програмуудыг сурснаар таны цаг болон хөдөлмөрийг цаашид улам илүү хөнгөвчлөх болно.

Файлууд засварладаг эсвэл бичихийг шаарддаг олон програм текст засварлагчийг автоматаар нээдэг. Ашиглагдах анхдагч засварлагчийг өөрчлөхийн тулд `EDITOR` орчны хувьсагчийг тохируулах хэрэгтэй. Дэлгэрэнгүйг <<shells,Бүрхүүлүүд>> хэсгээс үзнэ үү.

[[basics-devices]]
== Төхөөрөмж ба төхөөрөмжийн цэгүүд

Төхөөрөмж гэдэг ойлголт нь голдуу системд буй төхөөрөмж болох диск, хэвлэгч, график карт, мөн гар зэрэг ордог. FreeBSD эхэлж ачаалах үедээ, гол чухал таньсан төхөөрөмжүүдээ харуулдаг. Ингэж эхлэхдээ харуулсан бичлэгийг та дахин харахыг хүсвэл [.filename]#/var/run/dmesg.boot# файлыг хараарай.

Жишээ нь, [.filename]#acd0# гэдэг нь эхний IDE CDROM төхөөрөмж байхад, [.filename]#kbd0# гэдэг нь гарыг илэрхийлж байдаг.

UNIX(R) үйлдлийн систем нь эдгээр төхөөрөмж уруу хандахдаа төхөөрөмжийн цэг гэж нэрлэгдэх тусгай файл уруу ханддаг. Эдгээр төхөөрөмжийн цэгүүд нь [.filename]#/dev# санд байдаг.

=== Төхөөрөмжийн цэг үүсгэх

Хэрэв системд шинэ төхөөрөмж нэмэгдвэл, эсвэл нэмэлт төхөөрөмжид зориулсан шаардлага гарвал шинэ төхөөрөмжийн цэг үүсгэх ёстой.

==== `DEVFS` (DEVice File System буюу төхөөрөмжийн файл систем)

Төхөөрөмжийн файл систем буюу `DEVFS` нь ерөнхий файлын системийн нэрийн талбарын цөм дахь төхөөрөмжийн нэрийн талбарт хандах боломжийг өгдөг. Төхөөрөмжийн цэгийг үүсгэх эсвэл өөрчлөх зэрэг үйлдлийг `DEVFS` нь бидэнд хийж өгч амар болгож өгдөг.

man:devfs[5] гарын авлагаас нэмэлт мэдээллийг харна уу.

[[binary-formats]]
== Хоёртын хэлбэрүүд

FreeBSD яагаад man:elf[5] хэлбэр хэрэглэдгийг ойлгохын тулд, та ачаалагдаж ажилладаг файлын төрлөөс UNIX(R) дээр "ноёлдог" гурван хэлбэрийг мэдэх ёстой:

* man:a.out[5]
+ 
UNIX(R)-н хамгийн хуучин бөгөөд "сонгодог" ачаалагддаг файлын хэлбэр. Энэ нь эхэн хэсэгтээ өөрийнхөө хэлбэрийг таниулах зориулалттай шидэт дугаар агуулж байдаг (man:a.out[5] хуудаснаас дэлгэрэнгүй мэдээлэл авна уу). Ачаалагдсан үедээ санах ойд гурван хэсэгт хуваагддаг: .text, .data, мөн .bss бөгөөд дээрээс нь хэрэглэгдэх обьектуудыг агуулсан хүснэгт мөн мөрийн хүснэгтийг агуулж байдаг.
* COFF
+ 
SVR3 обьект хэлбэр. Толгой хэсэгтээ тодорхой зориулалттай хүснэгт агуулж байдаг. Тийм болохоор зөвхөн .text, .data, болон .bss хэсгүүдээс гадна нэмэлт зүйлс агуулж чадна.
* man:elf[5]
+ 
COFF-н дараагийн үе. Энэ нь олон хэсэг агуулахаас гадна 32-бит эсвэл 64-битийн утга агуулах чадвартай. Нэг муу тал бий: ELF нь тухайн системийн архитектурт зөвхөн ганцхан ABI байгаа гэж авч үздэг. SYSV ертөнц (хамгийн багадаа гурван ABI агуулж байдаг: SVR4, Solaris, SCO) байсаар байхад ингэж авч үзэх нь буруу юм.
+ 
FreeBSD нь энэ хүндрэлийг, ABI-н мэдээлэл агуулсан ачаалагддаг ELF файлуудыг зохицуулдаг _branding_ хэрэгслийг ашиглаж сайжруулахыг боддог. Нэмэлт мэдээллийг man:brandelf[1] хуудаснаас харна уу.

FreeBSD нь хуучны "сонгодог" отгоос салбарлаж гарсан тул man:a.out[5] хэлбэрийг хэрэглэж байсан бөгөөд энэ хэлбэрээ 3.X салбар гарах хүртэл маш олон BSD хувилбартаа ашиглаж байжээ. Хэдийгээр FreeBSD дээр өмнө нь ELF хоёртын хэлбэрийг хөрвүүлж мөн ажиллуулж (цөм дээр ч гэсэн) болдог байсан ч, FreeBSD нь анхнаасаа ELF хэлбэрийг анхдагч хэлбэрээ болгохыг "татгалзсан" билээ. Яагаад? Учир нь, Линукс систем нь хуваалцдаг кодын сан буюу "Shared-Libraries" -д зориулсан үсэрч ажилладаг хүснэгт, мөн түүнийг хөгжүүлэгчид болон байгууллагад хүндрэлтэй байдаг шалтгаанаар [.filename]#a.out# хэлбэрээс зайлсхийж ELF хэлбэр рүү шилжих гэж нүсэр хүнд хөдөлмөр зарсан юм. ELF хэлбэр нь хуваалцдаг кодын сан буюу "Shared-Libraries" хүндрэлийг давах боломж олгосон хэрэгслүүдийг санал болгосон бөгөөд тэгээд ч хөгжлийн явцад "нэг алхам урд нь" явж байгааг бодож мөн нэг хэлбэрээс нөгөө хэлбэрт шилжүүлэх үйл явцад гарах хүнд зардал байсан ч шилжүүлэхээр шийдсэн юм. FreeBSD-н кодын санг хуваалцах зарчим нь Sun-н SunOS(TM) загвартай ижил бөгөөд хэрэглэхэд тун хялбар.

Тэгэхээр, яагаад ийм олон хэлбэр байдаг юм бэ?

Энэ асуултанд хариулахын тулд хуучны, энгийн ажиллах зарчимтай төхөөрөмж хэрэглэж байсан бүүдгэр өнгөрсөн цаг уруу буцацгаая. Энэ энгийн төхөөрөмж нь энгийн жижигхэн систем дээр л ажиллахыг хүснэ. [.filename]#a.out# нь (PDP-11) төрлийн иймэрхүү энгийн систем дээр бүгдийг нь хангаж байлаа. Хүмүүс UNIX(R) системийг ийм энгийн системээс үүсгэсэн болохоор хуучны загвар болох Motorola 68k, VAXen зэрэг системтэй зохицохын тулд [.filename]#a.out# хэлбэрийг үлдээсэн юм.

Тэгтэл дараа нь нэг сүрхий инженер хөвүүн, зохиогдсон төхөөрөмжийн зарим ажиллах сул талыг нөхөж процессорыг илүү хурдан ажиллуулах хөнгөхөн програм бичжээ. Энэ програм нь шинэ төрлийн архитектурт (тэр үедээ RISC гэж нэрлэгддэг байсан архитектур) зориулан ажиллахаар бичигдсэн болохоор [.filename]#a.out# хэлбэр нь энэ төхөөрөмжид тохиромжгүй болон хангахуйц сайн биш болж ирэв. Тийм болохоор энэ шинэ төхөөрөмжтэй илүү үр дүнтэй ажиллахын тулд илүү олон хэлбэрүүд шинэ загварт зориулж зохиогдож байсан бөгөөд хуучин төрөлд бол энгийн [.filename]#a.out# төрлийг санал болгож болох юм. COFF, ECOFF мөн өөр илүү хэд хэдэн хэлбэр нь алдаануудаа нөхөн дэс дараалан үүсгэгдсээр ELF хүртэл хөгжжээ.

Мөн цаашлаад програмын хэмжээ хэдийгээр ихэссэн ч дискний (мөн санах ойн) хэмжээ харьцангуй бага байсан болохоор хуваалцаж болдог кодын сангийн "Shared-Libraries" санаа үүссэн юм. Мөн VM системүүд сайн хөгжиж эхлэв. Хэдийгээр эдгээр сайжруулалт болгон [.filename]#a.out# хэлбэрийг хэрэглэж байсан ч, шинэ боломжууд үүсэх тоолонд энэ хэлбэрийг хэрэглэхгүй болж ирэх нь улам ихэссэн билээ. Мөн түүнчлэн, санах ойг хэмнэх үүднээс эхлэн ачаалсны дараа өөр тийшээ үсрэх юм уу эсвэл явцын дунд код нэмэгдэж болох загваруудыг хүмүүс сонирхож эхлэв. Програмын хэлүүд улам сайжирч хүмүүс програмын үндсэн хэсгийг автоматжуулсан код хүсэх болжээ. Энэ бүх боломжуудыг биелүүлэх гэж [.filename]#a.out# хэлбэрийг маш их олон янзаар яргалсан бөгөөд хэсэгтээ л энэ нь ажилладаг байв. Нэг мэдэхэд [.filename]#a.out# хэлбэр нь ихсэж буй бүх хүндрэлийг зохицуулж чадахааргүй бичлэгийн төвөгтэй болон хэрэглэхэд хэцүү байдалд хүрсэн байна. Хэдийгээр энэ хүндрэлүүдийг ELF хэлбэр нь давдаг боловч шилжих явц нь маш хүндрэлтэй байдаг. Тийм болохоор ELF хэлбэр руу шилжих төвөг нь [.filename]#a.out# хэлбэрийг хэрэглэх төвгөөс их байвал ELF хэлбэр нь хүлээгдэхээс өөр аргагүй болжээ.

Гэвч цаг хугацаа өнгөрсөөр, FreeBSD ба түүний уламжилж гарсан системийн хөрвүүлэх хэрэгсэл нь (ялангуяа ассемблер болон дуудагч буюу loader) хоёр замаар зэрэг хөгжсөөр байв. FreeBSD салаа нь кодын хуваалцдаг санг нэмж мөн зарим алдааг нь залруулсан байна. Үүнийг анх бичсэн GNU-н ард түмэн уг кодоо шинэчилж дахин бичээд янз бүрийн хэлбэрүүдийг нэмж болдог болгоод мөн хөрвүүлэгчээс хамааралгүй хөрвүүлэгддэг болгох зэрэг цааш нь хөгжүүлжээ. Хэдийгээр маш олон хүн FreeBSD дээр хөрвүүлэгчээс хамаарахгүй хөрвүүлэхийг хүссэн боловч FreeBSD-н as болон ld-д зориулсан хуучин кодноос болоод азгүйтжээ. GNU-н шинэ хэрэгслүүд нь (binutils) хөрвүүлэгчээс хамааралгүй, ELF, кодын хуваалцдаг сан, C++ өргөтгөл зэргүүдийг хөрвүүлж чаддаг болжээ. Мөн цаашлаад маш олон байгууллагууд ELF хэлбэртэй хоёртын програмуудыг гаргаж эхэлсэн тул тэдгээрийг хэрэглэхийн тулд FreeBSD уг хэлбэрийг дэмжих нь зөв гэж шийдсэн юм.

ELF хэлбэр нь [.filename]#a.out# хэлбэрийг бодвол илүү өргөн хүрээтэй бөгөөд үндсэн системийг илүү өргөжүүлдэг. ELF хэрэгслүүд нь маш сайн зохион байгуулагдсан бөгөөд хөрвүүлэгчээс хамаардаггүй болохоор хүмүүсийн хүсэлд яг тохирдог. ELF нь [.filename]#a.out# хэлбэрийг бодвол жаахан удаан байж болох боловч үүнийг хэмжиж тодорхойлно гэдэг нь хэцүү билээ. Мөн энэ хоёрыг санах ойд хуудас зохицуулах, эхлэн ажиллах зарчим зэргийг нь харьцуулсан маш олон шинж чанарууд байдаг. Тэдгээр шинж чанарууд нь тийм ч чухал биш бөгөөд энэ нь зөвхөн ялгаа нь билээ. Одоо бол [.filename]#a.out# хэлбэр нь [.filename]#GENERIC# цөмөөс хасагдсан бөгөөд [.filename]#a.out# хэлбэрийг ажиллуулдаг байсан цөм нь хуучны цөмд тооцогдоно.

[[basics-more-information]]
== Нэмэлт мэдээлэл олж авах нь

[[basics-man]]
=== Гарын авлага

Ихэнх дэлгэрэнгүй мэдээллүүд нь FreeBSD дээр гарын авлага хэлбэрээр оршиж байдаг. Систем дээр ажиллаж байгаа бараг бүх програмууд нь ажиллах болон авдаг шинж чанараа тодорхойлсон товч заавар буюу гарын авлагатай хамт ирдэг. Тийм гарын авлагыг `man` тушаалаар харна. `man` тушаалын хэрэглээ нь тун хялбар:

[source,shell]
....
% man тушаал
....

`тушаал` нь судалж уншихыг хүссэн тушаалын нэр байх ёстой. Жишээлбэл `ls` тушаалын тухай мэдээлэл харахыг хүсвэл:

[source,shell]
....
% man ls
....

Гарын авлага нь дотроо дараах хэсгүүдэд дугаарлагдаж хуваагддаг:

. Хэрэглэгчийн тушаал.
. Системийн дуудлага болон алдааны дугаар.
. C програмын хэлний санд байрлах функц нь.
. Төхөөрөмжийн драйвер.
. Файлын хэлбэр.
. Тоглоом болон бусад салбар.
. Төрөл бүрийн бусад мэдээлэл.
. Системээс санаа тавьж үйлдэх тушаал.
. Цөм хөгжүүлэгч.

Зарим тохиолдолд гарын авлагын зарим бүлэг нь саяны хуваасан хэсэгт бүрд ижил байдаг. Жишээлбэл `chmod` тушаалыг хэрэглэгч нэг янзаар хэрэглэж байхад систем бас `chmod()` тушаалыг өөр зорилгоор хэрэглэдэг. Энэ тохиолдолд та системд аль сэдвээ сонгож байгаагаа ойлгуулахын тулд харгалзах дугаарыг нь өгөх ёстой:

[source,shell]
....
% man 1 chmod
....

Энэ тохиолдолд `chmod` тушаалыг хэрэглэгч яаж дуудаж хэрэглэх тухай харуулна. Гарын авлагын тухайн хэсгийг нь харахын тулд голдуу хаалт дотор тухайн хэсгийн дугаарыг нь бичиж ханддаг. Тэгэхээр man:chmod[1] гэвэл хэрэглэгчид хамаатай хэсэг нь, man:chmod[2] гэвэл системд хамаатай хэсэг харуулагдана.

Хэрэв та тушаалынхаа нэрийг мэдэж байвал энэ аргаар маш амархан хэрэглэх зааврыг уншиж чадахаар боллоо. Гэтэл та тушаалынхаа нэрийг мэдэхгүй тохиолдолд яах вэ? Энэ үед та `man` тушаалд тухайн хэрэгтэй тушаалын зааварт хайх түлхүүр үгийг `-k` сонголт ашиглан зааж өгч болдог. :

[source,shell]
....
% man -k mail
....

Энэ тохиолдолд, заавартаа "mail" гэдэг үг агуулсан тушаалуудыг жагсааж танд харуулна. Энэ арга нь үндсэндээ `apropos` тушаалын үүрэгтэй ижил болно.

За тэгэхээр, таны [.filename]#/usr/bin# санд маш их олон тушаалууд байгааг та мэддэг мөртлөө ямар үйлдэл хийдгийг нь сайн мэдэхгүй тохиолдолд яах вэ? Хамгийн амархан арга бол:

[source,shell]
....
% cd /usr/bin
% man -f *
....

эсвэл

[source,shell]
....
% cd /usr/bin
% whatis *
....

энэ хоёр хоёулаа ижилхэн үйлдэл хийдэг.

[[basics-info]]
=== GNU Info файлууд

FreeBSD нь Free Software Foundation (FSF) буюу Чөлөөт Програмын Сангаас бүтээсэн маш олон програмуудыг агуулж байдаг. Гарын авлага хуудаснаас гадна эдгээр програмууд нь мөн нэмэлт текст загвартай `info` файл агуулж байдаг бөгөөд уг төрлийн мэдээлэл нь `info` тушаалаар харуулагддаг. Хэрэв та emacs-г суулгасан бол emacs-н info горимд бас харж болно.

man:info[1] тушаалыг хэрэглэхийн тулд ердөө:

[source,shell]
....
% info тушаал
....

Товч тайлбарыг нь харахын тулд `h` дарна. Тушаалын түргэн зааврыг харахын тулд `?` гэж дараарай.
