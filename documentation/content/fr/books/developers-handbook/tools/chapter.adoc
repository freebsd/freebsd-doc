---
title: Chapitre 5. Outils de programmation
authors:
  - author: James Raynard
  - author: Murray Stokely
---

[[tools]]
= Outils de programmation
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:source-highlighter: rouge
:experimental:
:skip-front-matter:
:toc-title: Table des matières
:table-caption: Tableau
:example-caption: Exemple
:xrefstyle: basic
:relfileprefix: ../
:outfilesuffix:

:c-plus-plus-command: c++
:gcc-plus-plus-command: gcc++

:lg-plus-plus: -lg++
:lstdc-plus-plus: -lstdc++

_Ce chapître a été écrit par James Raynard. Les modifications pour le livre de chevet du développeur par Murray Stokely._

== Synopsis

Ce document est une introduction à l'utilisation de quelques outils de programmation fournis avec FreeBSD, toutefois tout sera applicable à beaucoup d'autres versions d'Unix. Cette introduction _n'essaye_ pas de décrire la programmation dans le détail. La plupart du document suppose que vous possédez peu ou pas de connaissances en programmation, espérant que les programmeurs trouveront un intérêt dans ce document.

== Introduction

FreeBSD offre un excellent environnement de développement. Des compilateurs pour c, c++ et Fortran ainsi qu'un assembleur sont fournis avec le système de base, sans parler de l'interpréteur PERL ni des outils classiques Unix comme `sed` et `awk`. Si cela n'est pas suffisant, il y a encore plus de compilateurs et d'interpréteurs dans la collection des logiciels portés. FreeBSD est compatible avec les standards comme POSIX et C ANSI, aussi bien qu'avec son propre héritage BSD, aussi il est possible d'écrire des applications qui se compileront et s'exécuteront avec peu ou pas de modifications sur un grand nombre de plateformes.

Toutefois, toute cette puissance peut être plutôt écrasante au premier abord si vous n'avez jamais écrit de programmes sur une plateforme Unix auparavant. Ce document a pour but de vous aider à commencer, sans entrer trop loin dans des sujets plus avancés. L'intention est que ce document devrait vous donner assez de bases pour être capable de donner du sens à la documentation.

La majeure partie du document requiert peu ou pas de connaissance de la programmation, bien qu'il suppose une compétence de base dans l'utilisation d'Unix et dans la bonne volonté d'apprendre !

== Introduction à la programmation

Un programme est un ensemble d'instructions qui disent à l'ordinateur de faire diverses choses; quelques fois, l'instruction qu'il a à exécuter dépend de ce qui s'est passé lors de l'exécution d'une instruction précédente. Cette section donne un aperçu des deux manières par lesquelles vous pouvez donner ces instructions, ou "commandes" comme elles sont habituellement nommées. Une façon utilise un _interpréteur_, l'autre un _compilateur_. Comme les langages humains sont trop difficiles à comprendre sans ambiguïté par un ordinateur, les commandes sont habituellement écrites dans un langage ou un autre spécialement conçus pour cet usage.

=== Les interpréteurs

Avec un interpréteur, le langage va avec un environnement où vous entrez des commandes à un invite de commandes et l'environnement les exécute pour vous. Pour des programmes plus compliqués, vous pouvez entrer les commandes dans un fichier et demander à l'interpréteur de charger le fichier et d'exécuter les commandes qui sont à l'intérieur. Si quoique ce soit se passe mal, beaucoup d'interpréteurs vous enverrons dans un dévermineur pour vous aider à débusquer le problème.

L'avantage de cela est que vous pouvez voir les résultats de vos commandes immédiatement, et les erreurs peuvent être corrigées facilement. Le plus gros désavantage arrive quand vous voulez partager vos programmes avec d'autres personnes. Ils doivent avoir le même interpréteur ou bien vous devez avoir un moyen de leur donner, et ils doivent comprendre comment l'utiliser. Par ailleurs, les utilisateurs pourraient ne pas apprécier d'être renvoyés dans un dévermineur s'ils ont appuyé sur la mauvaise touche ! D'un point de vue performance, les interpréteurs peuvent utiliser beaucoup de mémoire et généralement ne génèrent pas un code aussi efficace que les compilateurs.

A mon avis, les langages interprétés sont le meilleur moyen pour démarrer si vous n'avez jamais programmé. Ce genre d'environnement se trouve typiquement avec des langages comme Lisp, Smalltalk, Perl et Basic. Il peut aussi être dit que l'interpréteur de commandes Unix (`sh`, `csh`) est lui-même un interpréteur, et beaucoup de gens écrivent en fait des "scripts" (procédures) pour l'interpréteur pour les aider dans diverses tâches "domestiques" sur leur machine. En effet, une partie de la philosophie d'origine d'Unix était de fournir plein de petits programmes utilitaires qui pouvaient être liés ensemble dans des procédures pour effectuer des tâches utiles.

=== Les interpréteurs disponibles avec FreeBSD

Voici la liste des interpréteurs qui sont disponibles sous la forme de link:ftp://ftp.FreeBSD.org:pub/FreeBSD/packages/[ logiciels pré-compilés pour FreeBSD], avec une brève description de quelques uns des langages interprétés les plus populaires.

Pour obtenir un de ces logiciels pré-compilés, tout ce que vous avez à faire est de cliquer sur le lien du logiciel et d'exécuter

[source,bash]
....
# pkg_add nom du logiciel
....

en tant que super-utilisateur. Evidemment, vous aurez besoin d'un FreeBSD 2.1.0 ou plus en état de marche pour que le logiciel fonctionne !

BASIC::
Abbréviation de "Beginner's All-purpose Symbolic Instruction Code" (code d'instruction symbolique tout usage pour le débutant). Développé dans les années 50 pour apprendre aux étudiants d'université à programmer et fourni avec tout ordinateur qui se respecte dans les années 80, BASIC a été le premier langage de programmation pour beaucoup de programmeurs. Il est aussi le fondement même du Visual Basic.
+
L'interpréteur Basic link:ftp://ftp.FreeBSD.org:pub/FreeBSD/packages/lang/bwbasic-2.10.tgz[Bywater ] et l'interpréteur Basic de link:ftp://ftp.FreeBSD.org:pub/FreeBSD/packages/lang/pbasic-2.0.tgz[Phil Cockroft] (anciennement Rabbit Basic) sont disponibles pour FreeBSD sous forme delink:ftp://ftp.FreeBSD.org:pub/FreeBSD/packages/[ logiciels pré-compilés ]

Lisp::
Un langage qui a été développé à la fin des années 50 comme une alternative aux langages "dévoreurs de calculs" qui étaient très populaires à l'époque. Plutôt qu'être basé sur les nombres, Lisp est basé sur les listes; en fait le nom est l'abbréviation de "List Processing". Très populaire en IA (Intelligence Artificielle).
+
Lisp est un langage extrèmement puissant et sophistiqué , mais peut être assez lourd et peu maniable.
+
FreeBSD a link:ftp://ftp.FreeBSD.org:pub/FreeBSD/packages/gcl-2.0.tgz[GNU Common Lisp] de disponible sous la forme d'un logiciel pré-compilé.

Perl::
Très populaire auprès des administrateurs système pour la rédaction de procédures; aussi souvent utilisé sur les serveurs Internet pour l'écriture de procédures CGI.
+
La dernière version (version 5) est fournie avec FreeBSD.

Scheme::
Un dérivé du Lisp qui est plutôt plus compact et plus propre que le Common Lisp. Populaire dans les universités étant suffisamment simple à apprendre aux étudiants comme premier langage , il possède un niveau d'abstraction suffisamment important pour être utilisé dans le travail de recherche.
+
On trouve pour FreeBSD les logiciels pré-compilés link:ftp://ftp.FreeBSD.org:pub/FreeBSD/packages/lang/elk-3.0.tgz[interpréteur Scheme Elk], link:ftp://ftp.FreeBSD.org:pub/FreeBSD/packages/lang/mit-scheme-7.3.tgz[l'interpréteur Scheme du MIT] et link:ftp://ftp.FreeBSD.org:pub/FreeBSD/packages/lang/scm-4e1.tgz[l'interpréteur Scheme SCM].

Icon::
link:ftp://ftp.FreeBSD.org:pub/FreeBSD/packages/lang/icon-9.0.tgz[Le langage de programmation Icon].

Logo::
link:ftp://ftp.FreeBSD.org:pub/FreeBSD/packages/lang/ucblogo-3.3.tgz[l'interpréteur Logo de Brian Harvey].

Python::
link:ftp://ftp.FreeBSD.org:pub/FreeBSD/packages/lang/python-1.2[Le langage orienté objet Python]

=== Les compilateurs

Les compilateurs sont plutôt différents entre eux. Tout d'abord, vous écrivez votre code dans un fichier (ou des fichiers) en utilisant un éditeur de texte. Vous exécutez ensuite le compilateur et vérifiez qu'il accepte votre programme. S'il ne compile pas, grincez des dents et retournez à l'éditeur; s'il compile et vous donne un programme, vous pouvez exécuter ce dernier à l'invite de commande ou dans un dévermineur pour voir s'il fonctionne correctement. 

Evidemment, ce n'est pas aussi direct que d'utiliser un interpréteur. Toutefois cela vous permet de faire beaucoup de choses qui sont difficiles ou même impossibles avec un interpréteur, comme écrire du code qui interagit de façon proche du système d'exploitation ou même d'écrire votre propre système d'exploitation ! C'est aussi utile si vous avez besoin d'écrire du code très efficace, étant donné que le compilateur peut prendre son temps et optimiser le code, ce qui ne serait pas acceptable avec un interpréteur. Et distribuer un programme écrit pour un compilateur est habituellement plus évident qu'un écrit pour un interpréteur-vous pouvez juste donner une copie de l'exécutable, en supposant que l'utilisateur possède le même système d'exploitation que vous.

Les langages compilés incluent Pascal, C et C++. C et C++ sont des langages plutôt impitoyables et conviennent mieux aux programmeurs expérimentés; Pascal, d'autre part, a été conçu comme un langage éducatif, et est un assez bon langage pour commencer. Malheureusement, FreeBSD ne possède aucun support Pascal, excepté pour un convertisseur Pascal vers C dans les logiciels portés.

Le cycle édition-compilation-exécution-déverminage étant relativement pénible lors de l'utilisation de programmes séparés, beaucoup de fabricants de compilateur ont produit des environnements de développement intégrés (ou IDE pour Integrated Development Environments et EDI dans la langue de Molière). FreeBSD ne possède pas d'EDI tel quel; toutefois il est possible d'utiliser Emacs à cet effet. Ceci est vu dans <<emacs>>.

== Compiler avec `cc`

Cette section traite uniquement du compilateur GNU pour C et C++, celui-ci faisant partie du système FreeBSD de base. Il peut être invoqué soit par `cc` ou `gcc`. Les détails de production d'un programme avec un interpréteur varient considérablement d'un interpréteur à l'autre, et sont habituellement bien couverts par la documentation et l'aide en ligne de l'interpréteur.

Une fois que vous avez écrit votre chef d'oeuvre, la prochaine étape est de le convertir en quelque chose qui s'exécutera (espérons !) sur FreeBSD. Cela implique normalement plusieurs étapes, réalisées chacune par un programme différent.

[.procedure]
====
. Pré-traiter votre code source pour retirer les commentaires et faire d'autres trucs comme développer (expanser) les macros en C.
. Vérifier la syntaxe de votre code source pour voir si vous avez obéi aux règles du langage. Si vous ne l'avez pas fait, il se plaindra !
. Convertir le code source en langage assembleur- cela est vraiment proche du code machine, mais reste compréhensible par des humains. Prétendument. 
. Convertir le langage assembleur en code machine -ouais, on parle de bits et d'octets, de uns et de zéros.
. Vérifier que vous avez utilisé des choses comme des fonctions et des variables globales de façon consistente. Par exemple, si vous avez appelé une fonction inexistente, le compilateur se plaindra.
. Si vous essayez de produire un exécutable depuis plusieurs fichiers de code source, résoudre comment les faire fonctionner ensemble.
. Résoudre comment produire quelque chose que le chargeur au vol du système sera capable de charger en mémoire et exécuter.
. Finalement, écrire l'exécutable dans le système de fichiers.
====

Le mot _compilation_ est souvent utilisé pour les étapes 1 à 4 seules-les autres correspondent au terme _liaison_. Quelquefois, l'étape 1 est appelée _pre-traitement_ et les étapes 3-4 _assemblage_.

Heureusement, la plupart de ces détails vous sont cachés, étant donné que `cc` est un frontal qui s'occupe d'appeler tous les programmes avec les arguments corrects pour vous; tapez simplement

[source,bash]
....
% cc foobar.c
....

compilera [.filename]#foobar.c# avec toutes les étapes au-dessus. Si vous avez plus d'un fichier à compiler, faites simplement quelque chose comme

[source,bash]
....
% cc foo.c bar.c
....

Notez que la vérification de syntaxe n'est que cela-vérifier la syntaxe. Cela ne vérifiera pas les erreurs de logique que vous pouvez avoir faites, comme mettre le programme en boucle infinie ou utiliser un tri à bulles quand vous devriez utiliser un tri binaire. 

Il y a beaucoup d'options pour `cc`, qui qui se trouvent toutes dans les pages de manuel en ligne. Voici quelques unes des plus importantes, avec des exemples illustrant leur utilisation.

`-o __nom_du_fichier__`::
Le nom de sortie du fichier. Si vous n'utilisez pas cette option, `cc` produira un exécutable appelé [.filename]#a.out#. 
+
[source,bash]
....
% cc foobar.c               l'exécutable est a.out
% cc -o foobar foobar.c     l'exécutable est foobar
....

`-c`::
Compile juste le fichier, ne le lie pas. Utile pour les programmes jouets dont vous voulez juste vérifier la syntaxe, ou si vous utilisez un [.filename]#Makefile#.
+
[source,bash]
....
% cc -c foobar.c
....
+
Cela va produire un _fichier objet_ (pas un exécutable) appelé [.filename]#foobar.o#. Celui-ci peut être lié ensuite avec d'autres fichiers objets pour produire un exécutable.

`-g`::
Crée une version de déverminage de l'exécutable. Cela oblige le compilateur à placer des informations dans l'exécutable comme telle ligne du fichier source correspond à tel appel de fonction. Un dévermineur peut utiliser cette information pour vous montrer le code source au fur et à mesure que vous avancez pas à pas dans le programme, ce qui est _très_ utile; le désavantage est que toutes ces informations supplémentaires rendent le programme plus gros. Normalement, vous compilez avec l'option `-g` quand vous êtes en train de développer un programme et compilez ensuite une "version de production" sans `-g` quand vous êtes satisfait du fonctionnement.
+
[source,bash]
....
% cc -g foobar.c
....
+
Cela va produire une version de déverminage du programme foobar. 

`-O`::
Crée une version optimisée de l'exécutable. Le compilateur effectue différents trucs malins pour essayer de produire un exécutable qui s'exécute plus rapidement que normal. Vous pouvez ajouter un nombre après l'option `-O` pour spécifier un niveau d'optimisation plus important, mais cela vous expose souvent aux bogues dans l'optimiseur du compilateur. Par exemple, la version de `cc` fournit avec la version 2.1.0 FreeBSD est connue pour produire du mauvais code avec l'option `-O2` dans certaines circonstances.
+
L'optimisation est habituellement activée uniquement lors de la compilation d'une version de production.
+
[source,bash]
....
% cc -O -o foobar foobar.c
....
+
Cela va produire une version optimisée de [.filename]#foobar#.

Les trois prochaines options vont forcer `cc` à vérifier que votre code est conforme au standard international en cours, se référant souvent à la norme ANSI, qui pour dire précisement est un standard ISO.

`-Wall`::
Active tous les avertissements que les auteurs de `cc` pensent valoir le coup. Malgré le nom, il n'active pas tous les avertissements dont `cc` est capable.

`-ansi`::
Désactive la plupart, mais pas toutes, des caractéristiques du C fournies par `cc` qui sont non-ANSI . Malgré le nom, cela ne garantit pas strictement que votre code sera conforme au standard.

`-pedantic`::
Désactive _toutes_ les caractéristiques de `cc` qui ne sont pas ANSI .

Sans ces options, `cc` vous permettrait d'utiliser quelques extensions au standard non-standards. Quelques unes de celles-ci sont très utiles, mais ne fonctionneront pas avec d'autres compilateurs -en fait, un des principaux buts du standard est de permettre aux gens d'écrire du code qui fonctionnera avec n'importe quel compilateur sur n'importe quel système. Cela est connu sous le nom de _code portable_.

Generalement, vous devriez essayer de faire votre code aussi portable que possible, sinon vous pourriez avoir a ré-écrire totalement votre programme plus tard pour le faire fonctionner autre part-et qui sait ce que vous utiliserez dans quelques années?

[source,bash]
....
% cc -Wall -ansi -pedantic -o foobar foobar.c
....

Cela produira un exécutable [.filename]#foobar# après avoir vérifié que [.filename]#foobar.c# est conforme au standard.

`-l _librairie_`::
Spécifie une librairie de fonctions à utiliser lors de l'édition des liens.
+
L'exemple le plus commun de cela est lors de la compilation d'un programme qui utilise quelques fonctions mathématiques en C. A l'inverse de la plupart des plateformes, celles-ci se trouvent dans une librairie standard du C et vous devez dire au compilateur de l'ajouter. 
+
La règle est que si une librairie est appelée [.filename]#libquelque_chose.a#, vous donnez à `cc` l'argument `-l __quelque_chose__`. Par exemple, la librairie des fonctions mathématiques est [.filename]#libm.a#, aussi vous donnez à `cc` le paramètre `-lm`. Un "piège" habituel avec la librairie math est qu'elle doit être la dernière sur la ligne de commande.
+
[source,bash]
....
% cc -o foobar foobar.c -lm
....
+
Cela va lier les fonctions de la librairie math à l'interieur de [.filename]#foobar#.
+
Si vous compilez du {c-plus-plus-command}; vous devrez ajouter {lg-plus-plus}, ou {lstdc-plus-plus} si vous utilisez FreeBSD 2.2 ou ultérieur, à la ligne de commande de `cc` pour lier avec les fonctions de la librairie {c-plus-plus-command}. Alternativement, vous pouvez utiliser {c-plus-plus-command} plutôt que `cc`, qui fait tout cela pour vous. {c-plus-plus-command} peut aussi être invoqué par {gcc-plus-plus-command} sur FreeBSD.
+
[source,bash]
....
% cc -o foobar foobar.cc -lg++     Pour FreeBSD 2.1.6 et antérieur
% cc -o foobar foobar.cc -lstdc++  Pour FreeBSD 2.2 et ultérieur
% c++ -o foobar foobar.cc
....
+
Chacune de ces commandes va produire un exécutable [.filename]#foobar# à partir du fichier source {c-plus-plus-command} [.filename]#foobar.cc#. Notez que, sur les systèmes Unix , les fichiers source {c-plus-plus-command} se terminent traditionnellement en [.filename]#.C#, [.filename]#.cxx# ou [.filename]#.cc#, plutôt que le style MS-DOS [.filename]#.cpp# (qui était déjà utilisé pour autre chose). `gcc` a utilisé cela pour trouver le type de compilateur à utiliser sur le fichier source; toutefois, cette restriction ne s'applique plus, aussi vous pouvez maintenant appeler vos fichiers {c-plus-plus-command} [.filename]#.cpp# en toute impunité !

=== Questions et problèmes usuels sur `cc`

==== J'essaye d'écrire un programme qui utilise la fonction sin() et je reçois l'erreur suivante. Que cela signifie-t-il ?

Lors de l'utilisation des fonctions mathématiques comme `sin()`, vous devez dire à `cc` de lier avec la librairie math, comme :

[source,bash]
....
% cc -o foobar foobar.c -lm
....

==== J'ai écrit un programme simple pour m'exercer à l'utilisation de l'option -lm. Tout ce qu'il fait est d'élever 2,1 à la puissance 6.

Quand le compilateur voit que vous appelez une fonction, il vérifie s'il a déjà un prototype pour celle-ci. S'il ne l'a pas vu, il suppose que la fonction retourne un [type]#int#, ce qui n'est absolument pas ce que vous voulez ici. 

==== Alors comment puis-je le réparer?

Les prototypes des fonctions mathématiques sont dans [.filename]#math.h#. Si vous incluez ce fichier, le compilateur sera capable de trouver le prototype et il arrêtera de faire des trucs étranges à vos calculs! 

[.programlisting]
....
#include <math.h>
#include <stdio.h>

int main() {
...
....

Après avoir recompilé comme précédemment, exécutez : 

[source,bash]
....
% ./a.out
2.1 ^ 6 = 85.766121
....

Si vous utilisez quelques fonctions mathématiques que ce soit, incluez _toujours_ [.filename]#math.h# et n'oubliez pas de lier avec la librairie math.

==== J'ai compilé un fichier appelé foobar.c et je ne trouve pas d'exécutable appelé foobar. Où est-il parti?

Souvenez-vous, `cc` appellera l'exécutable [.filename]#a.out# sauf si vous lui dites de faire autrement. Utilisez l'option `-o _nomfichier_`:

[source,bash]
....
% cc -o foobar foobar.c
....

==== OK, j'ai un exécutable appelé foobar, je peux le voir en exécutant ls, mais quand je tape foobar à l'invite de commandes, la réponse est qu'il n'y a pas de tel fichier. Pourquoi le système ne le trouve pas? 

A l'inverse de MS-DOS, Unix ne regarde pas dans le répertoire courant lorsqu'il essaye de trouver un exécutable que vous voulez exécuter, sauf si vous lui avez dit de le faire. Vous pouvez soit taper `./foobar`, ce qui signifie "exécute le fichier nommé [.filename]#foobar# dans le répertoire courant", soit changer votre variable d'environnement `PATH` de façon à ce qu'elle ressemble à quelque chose comme 

[source,bash]
....
bin:/usr/bin:/usr/local/bin:.
....

Le point à la fin signifie "regarde dans le repertoire courant s'il n'est dans aucun autre".

==== J'ai appelé mon exécutable test, mais rien ne se passe quand je l'exécute. Que se passe-t-il? 

La plupart des systèmes Unix ont un programme appelé `test` dans [.filename]#/usr/bin# et l'interpréteur prend celui-ci avant de vérifier dans le répertoire courant. Soit vous tapez 

[source,bash]
....
% ./test
....

soit vous choisissez un meilleur nom pour votre programme !! 

==== J'ai compilé mon programme et il semble fonctionner au premier abord, puis il y a une erreur et le système a dit quelque chose comme core dumped. Que cela signifie-t-il?

Le nom _core dump_ date des tous premiers jours d'Unix, quand les machines utilisaient la mémoire centralepour stocker les données. Simplement, si le programme a échoué sous certaines conditions, le système va écrire le contenu de la mémoire centrale sur le disque dans un fichier appelé [.filename]#core#, que le programmeur peut ensuite examiner de près pour trouver ce qui s'est mal passé. 

==== Fascinant, mais que suis-je supposé faire ?

Utilisez `gdb` pour analyser le fichier [.filename]#core# (voir <<debugging>>).

==== Quand mon programme a généré un fichier core, il a parlé d'une erreur segmentation fault. Qu'est-ce que c'est ?

Cela signifie simplement que votre programme a essayé d'effectuer une opération illégale sur la mémoire; Unix est conçu pour protéger le système d'exploitation et les autres programmes des programmes crapuleux. 

Les causes habituelles de cela sont :

* Essayer d'écrire dans un pointeur NULL, par exemple 
+
[.programlisting]
....
char *foo = NULL;
strcpy(foo, "bang!");
....

* Utiliser un pointeur qui n'a pas été initialisé, par exemple
+
[.programlisting]
....
char *foo;
strcpy(foo, "bang!");
....
+ 
Le pointeur va avoir une valeur aléatoire qui avec de la chance, pointera dans une zone de la mémoire qui n'est pas disponible pour votre programme et le noyau va tuer votre programme avant qu'il ne fasse des dommages. Si vous êtes malchanceux, il pointera quelque part dans votre propre programme et altèrera une de vos structures de données, faisant planter votre programme mystérieusement. 
* Essayer d'accèder la mémoire au-delà de la fin d'un tableau, par exemple
+
[.programlisting]
....
int bar[20];
bar[27] = 6;
....

* Essayer de stocker quelque chose dans la mémoire en lecture seule, par exemple
+
[.programlisting]
....
char *foo = "Ma chaine";
strcpy(foo, "bang!");
....
+ 
Les compilateurs Unix mettent souvent les chaînes comme `"Ma chaine"` dans des zones de mémoire en lecture seule. 
* Faire des trucs sales avec `malloc()` et `free()`, par exemple
+
[.programlisting]
....
char bar[80];
free(bar);
....
+ 
ou
+
[.programlisting]
....
char *foo = malloc(27);
free(foo);
free(foo);
....

Faire une de ces fautes ne conduit pas toujours à une erreur, mais elles sont toujours de mauvais entrainements. Certains systèmes et compilateurs sont plus tolérants que d'autres, ce qui explique pourquoi des programmes qui fonctionnent bien sur un système peuvent planter si vous les essayer sur un autre. 

==== Des fois quand je reçoit une erreur core dump, il est précisé bus error. Il est dit dans mon livre Unix qu'il s'agit d'un problème matériel mais l'ordinateur semble toujours fonctionner. Est-ce vrai ? 

Non, heureusement non (sauf si bien sûr vous avez réellement un problème matériel...). Cela est habituellement une manière de dire que vous avez accédé à la mémoire d'une façon que vous n'auriez pas dû. 

==== Toute cette affaire de fichier core semble être assez utile, si je peux le faire apparaître quand je le désire. Puis-je faire cela, ou dois-je attendre la prochaine erreur ?

Oui, ouvrez une autre console ou xterm, faites

[source,bash]
....
% ps
....

pour trouver l'identifiant du processus de votre programme, et faites 

[source,bash]
....
% kill -ABRT identifiant
....

où [parameter]#_identifiant_# est l'identifiant du processus que vous avez trouvé.

Ceci est utile si votre programme est bloqué dans une boucle infinie, par exemple. Si votre programme arrive à bloquer le signal SIGABRT, il y a d'autres signaux qui ont des effets similaires. 

Alternativement, vous pouvez créer un fichier [.filename]#core# depuis votre programme, en appelant la fonction `abort()`. Voir la page de manuel en ligne de man:abort[3] pour en savoir plus. 

Si vous voulez créer un fichier [.filename]#core# depuis l'extérieur de votre programme, mais ne voulez pas que le processus s'arrêt,vous pouvez utiliser le programme `gcore`. Voir la page de manuel en ligne de man:gcore[1] pour plus d'informations. 

== Make

=== Qu'est-ce que `make`?

Quand vous travaillez sur un programme simple avec seulement un ou deux fichiers source, taper 

[source,bash]
....
% cc fichier1.c fichier2.c
....

n'est pas si mal, mais cela devient rapidement fastidieux quand il y a plusieurs fichiers-et cela peut prendre du temps à compiler aussi. 

Une façon de contourner cela est d'utiliser les fichiers objet et de recompiler le fichier source seulement si le code source a changé. Aussi, nous pourrions avoir quelque chose comme ça: 

[source,bash]
....
% cc fichier1.o fichier2.o … fichier37.c …
....

si nous avions changé le fichier [.filename]#fichier37.c# mais aucun des autres depuis la dernère compilation. Cela pourrait accélerer assez bien la compilation mais cela ne resoud pas le problème de la frappe au clavier. 

Ou nous pourrions écrire une procédure pour résoudre ce problème de frappe, mais celle-ci devrait tout re-compiler, devenant ainsi inefficace sur un gros projet. 

Que se passe-t-il si nous avons des centaines de fichiers source ? Que se passe-t-il si nous travaillons dans une équipe avec d'autres personnes qui oublient de nous dire quand ils ont changé un de leurs fichiers source que nous utilisons ? 

Peut-être pourrions nous mettre ensemble les deux solutions et écrire quelque chose comme une procédure qui contiendrait quelque règle magique disant quand notre fichier source doit être compilé. Maintenant, tout ce dont nous avons besoin est un programme qui comprend ces règles, alors que c'est trop compliqué pour l'interpréteur. 

Ce programme s'appelle `make`. Il lit dans un fichier, appelé un _makefile_, qui lui dit comment les différents fichiers dépendent les uns des autres, et détermine quels fichiers ont besoin d'être recompilés et quels n'en ont pas besoin. Par exemple, une règle pourrait dire quelque chose comme "si [.filename]#fromboz.o# est plus ancien que [.filename]#fromboz.c#, cela signifie que quelqu'un a dû changer [.filename]#fromboz.c#, aussi il a besoin d'être recompilé." Le makefile possède aussi des règles pour dire à `make` _comment_ re-compiler un fichier source, en faisant ainsi un outil encore plus puissant. 

Les [.filename]##Makefile##s sont typiquement stockés dans le même répertoire que le source auxquels il s'appliquent, et peuvent être appelés [.filename]#makefile#, [.filename]#Makefile# ou [.filename]#MAKEFILE#. La plupart des programmeurs utilise le nom [.filename]#Makefile#, celui-ci se trouvant proche du début de la liste du contenu du répertoire où il peut être facilement vu. 

=== Exemple d'utilisation de `make`

Voici un exemple très simple de [.filename]#Makefile#: 

[.programlisting]
....
foo: foo.c
	cc -o foo foo.c
....

Il consiste en deux lignes, une ligne de dépendance et une ligne de création. 

La ligne de dépendance ici consiste en le nom du programme (connu comme _cible_), suivi de deux-points puis un espace et enfin le nom du fichier source. Quand `make` lit cette ligne, il vérifie si [.filename]#foo# existe; s'il existe, il compare la date à laquelle [.filename]#foo# a été modifié la dernière fois avec la date de dernière modification de [.filename]#foo.c#. Si [.filename]#foo# n'existe pas ou est plus ancien que [.filename]#foo.c#, il regarde la ligne de création pour trouver ce qu'il doit faire. En d'autres termes, il s'agit de la règle à utiliser quand [.filename]#foo.c# a besoin d'être re-compilé. 

La ligne de création commence avec un tab (appuyez sur la touche kbd:[tab]) suivi de la commande que vous taperiez pour créer [.filename]#foo# si vous deviez le faire à l'invite de commandes. Si [.filename]#foo# n'est pas à jour ou n'existe pas, `make` exécute alors cette commande pour le créer. En d'autres termes, il s'agit de la règle permettant à make de re-compiler [.filename]#foo.c#. 

Aussi, quand vous tapez `make`, il vérifiera que [.filename]#foo# est à jour en respect de vos derniers changements sur [.filename]#foo.c#. Ce principe peut être étendu à des [.filename]##Makefile##s de plusieurs centaines de cibles-en fait, sur FreeBSD, il est possible de compiler un système d'exploitation entier en tapant juste `make world` dans le répertoire approprié ! 

Une autre propriété utile des makefiles est que les cibles n'ont pas nécessairement besoin d'être des programmes. Par exemple, nous pourrions avoir un [.filename]#Makefile# qui ressemble à cela: 

[.programlisting]
....
foo: foo.c
	cc -o foo foo.c

install:
	cp foo /home/moi
....

Nous pouvons dire à `make` quelle cible nous voulons en tapant: 

[source,bash]
....
% make cible
....

`make` ira seulement voir cette cible et ingorera les autres. Par exemple, si nous tapons `make foo` avec le [.filename]#Makefile# du dessus, `make` ignorera la cible install. 

Si nous tapons juste `make`, `make` regardera toujours la première cible et s'arrêtera sans regarder aucune autre. Aussi, si nous avions tapé `make` seul, `make` serait juste allé à la cible foo, aurait recompilé [.filename]#foo# si nécessaire et se serait arrêté sans aller à la cible install. 

Notez que la cible install ne dépend pour l'instant de rien ! Cela signifie que la commande qui suit est toujours exécutée lorsque nous essayons de créer cette cible en tapant `make install`. Dans ce cas, `make` va copier [.filename]#foo# dans le répertoire de l'utilisateur. Cela est souvent utilisé par les [.filename]##Makefile##s des applications, ainsi l'application peut être installée dans le répertoire correct quand elle a été correctement compilée 

Il s'agit d'un sujet légèrement embrouillant à essayer et expliquer. Si vous ne comprenez pas bien comment `make` fonctionne, la meilleure chose à faire est d'écrire un petit programme comme "bonjour monde" et un fichier [.filename]#Makefile# comme le précédent et de le tester. Ensuite continuez en utilisant plus d'un fichier source ou en ayant un fichier source incluant un fichier d'en-tête. La commande `touch` est très utile ici-elle change la date sur un fichier sans avoir à l'éditer. 

=== Les [.filename]#Makefiles# de FreeBSD

Les [.filename]##Makefile##s peuvent être plutôt compliqués à écrire. Heureusement, les systèmes BSD comme FreeBSD sont fournis avec des fichiers très puissants comme partie intégrante du système. Un très bon exemple est le système des logiciels portés. Voici la partie essentielle d'un [.filename]#Makefile# typique des logiciels portés: 

[.programlisting]
....
MASTER_SITES=   ftp://freefall.cdrom.com/pub/FreeBSD/LOCAL_PORTS/
DISTFILES=      scheme-microcode+dist-7.3-freebsd.tgz

.include <bsd.port.mk>
....

Maintenant, si nous allons dans le répertoire de ce logiciel porté et tapons `make`, la chose suivante se passe : 

[.procedure]
====
. Une vérification est faite pour voir si le code source de ce logiciel porté est déjà dans le système. 
. Si celui-ci n'y est pas, une connexion FTP à l'URL dans MASTER_SITES est faite pour télécharger le source. 
. La somme de contrôle (`checksum`) du source est calculée et comparée avec celle d'une bonne et connue copie du source. Cela est fait pour être sûr que le source n'a pas été corrompu pendant le transfert. 
. Tout changement requis pour faire fonctionner le source sur FreeBSD est appliqué- cela est connu sous le nom de _correctif_. 
. Toute configuration spéciale nécessaire pour le source est faite. (Beaucoup de distributions de programmes Unix essaye de fonctionner quelle que soit la version d'Unix sur laquelle elles sont compilées et quelles que soient les caractéristiques optionnelles qui sont présentes-c'est ce qui se trouve dans le scénario des logiciels portés pour FreeBSD). 
. Le code source pour ce programme est compilé. En effet, nous changeons de répertoire pour le répertoire où le source a été décompressé et faisons `make`-le fichier [.filename]#Makefile# du programme contient les informations nécessaires pour construire le programme. 
. Nous avons maintenant une version compilée du programme. Si nous le désirons, nous pouvons le tester maintenant; quand nous sommes confiant dans le programme, nous pouvons taper `make install`. Cela va installer le programme et ses fichiers de soutien nécessaires au bon endroit; une entrée est aussi créée dans la `base de données des logiciels pré-compilés`, ainsi le logiciel porté peut être facilement désinstallé plus tard si nous changeons d'avis sur ce programme. 
====

Maintenant je pense que vous serez d'accord que c'est plus impressionnant qu'une procédure de quatre lignes ! 

Le secret réside dans la dernière ligne qui dit à `make` de regarder dans le [.filename]#Makefile# système appelé [.filename]#bsd.port.mk#. Il est facile de fermer les yeux sur cette ligne mais c'est ici que tous les trucs forts se passent-quelqu'un a écrit un [.filename]#Makefile# qui dit à `make` de faire tout ce qu'il y a au-dessus (plus un couple d'autres choses que je n'ai pas mentionnées, comme la gestion des erreurs) et n'importe qui peut avoir accès à cela simplement est ajoutant une simple ligne dans son propre fichier [.filename]#Makefile# ! 

Si vous voulez jeter un regard sur ces [.filename]##Makefile##s système, ils se trouvent [.filename]##/usr/shared/mk## mais il est probablement mieux d'attendre un moment jusqu'à ce que vous ayez un peu d'entrainement avec les [.filename]##Makefile##s car ceux-ci sont très compliqués (et si vous les lisez, soyez sûr d'avoir un thermos de café fort à portée de main !) 

=== Utilisations plus avancées de `make`

`Make` est un outil très puissant et peut faire beaucoup plus que le simple exemple précédent ne l'a montré. Malheureusement, il y a différentes versions de `make` et elles diffèrent considérablement. Le meilleur moyen d'apprendre ce qu'elles peuvent faire est probablement de lire la documentation-heureusement cette introduction vous donnera la base à partir de laquelle vous pourrez faire cela. 

La version de `make` fournies avec FreeBSD est le Berkeley make(make de Berkeley); il y a un cours d'instruction pour celui-ci dans [.filename]#/usr/shared/doc/psd/12.make#. Pour le voir, faites 

[source,bash]
....
% zmore paper.ascii.gz
....

dans ce répertoire.

Beaucoup d'applications dans les logiciels portés utilisent GNU make, qui possède un très bon ensemble de page d'"info". Si vous avez installé un de ces logiciels portés, GNU make aura été automatiquement installé sous le nom de `gmake`. Il est aussi disponible comme logiciel porté ou logiciel pré-compilé seul. 

Pour voir les pages d'info pour GNU make, vous devrez editer le fichier [.filename]#dir# dans le répertoire [.filename]#/usr/local/info# pour ajouter une entrée pour celui-ci. Cela implique d'ajouter une ligne 

[.programlisting]
....
 * Make: (make).                 l'utilitaire GNU Make.
....

au fichier. Une fois que vous avez fait ceci, vous pouvez taper `info` et ensuite sélectionner [.guimenuitem]#make# dans le menu (ou dans Emacs, faites `C-h i`). 

[[debugging]]
== Déverminer

=== Le dévermineur

Le dévermineur fourni avec FreeBSD est appelé `gdb` (GNU debugger). Vous pouvez le démarrer en tapant 

[source,bash]
....
% gdb nomprog
....

bien que la plupart des gens préfèrent le démarrer au sein d'Emacs. Vous pouvez faire cela avec: 

[source,bash]
....
 M-x gdb RET nomprog RET
....

Utiliser un dévermineur vous permet d'exécuter le programme dans des circonstances plus contrôlées. Typiquement, vous pouvez exécuter le programme ligne à ligne, inspecter la valeur des variables, changer cette dernière, dire au dévermineur d'exécuter jusqu'à un certain point puis de s'arrêter etc... Vous pouvez même vous brancher sur un programme en fonctionnement, ou charger un fichier [.filename]#core# pour enquêter sur le plantage du programme. Il est même possible de déverminer le noyau, quoique ce soit un peu plus rusé que de déverminer des applications utilisateur dont nous discuterons dans cette section. 

`gdb` dispose d'une assez bonne aide en ligne comme d'un ensemble de pages d'info, aussi cette section va se concentrer sur quelques commandes basiques. 

Finalement, si vous trouvez son interface texte non fonctionnelle, il y a une interface graphique pour celui-ci, link:../../ports/devel.html[xxgdb], dans la collection des logiciels portés. 

Cette section a pour but d'être une introduction à l'utilisation de `gdb` et ne couvre pas les sujets très spécialisés comme le déverminage du noyau. 

=== Exécuter un programme dans le dévermineur

Vous devrez avoir compilé le programme avec l'option `-g` pour avoir la meilleure utilisation de `gdb`. Il fonctionnera sans mais vous ne verrez que le nom de la fonction dans laquelle vous vous trouvez plutôt que son code source. Si vous voyez une ligne comme: 

[source,bash]
....
... (no debugging symbols found) ...
....

quand `gdb` démarre, vous saurez que le programme n'a pas été compilé avec l'option `-g`. 

A l'invite de `gdb`, tapez `break main`. Cela dira au dévermineur de passer le code préliminaire d'initialisation du programme et de démarrer au début de votre code. Maintenant tapez `run` pour démarrer le programme-cela va démarrer au début du code d'initialisation et ensuite s'arrêtera lors de l'appel à `main()`. (Si vous vous êtes toujours demandé où `main()` était appelé, maintenant vous le savez !). 

Vous pouvez maintenant vous déplacer dans le programme ligne par ligne en pressant `n`. Si vous arrivez à l'appel d'une fonction, vous pouvez entrer dans celle-ci en appuyant sur `s`. Une fois que vous êtes dans l'appel de la fonction, vous pouvez retourner dans le code appelant en appuyant sur `f`. Vous pouvez aussi utiliser `up` et `down` pour avoir une vue rapide de l'appelant. 

Voici un exemple simple de comment détecter une erreur dans un programme avec `gdb`. Voici notre programme (avec une erreur délibérée): 

[.programlisting]
....
#include <stdio.h>

int bazz(int anint);

main() {
	int i;

	printf("C'est mon programme\n");
	bazz(i);
	return 0;
}

int bazz(int anint) {
	printf("Vous m'avez fourni %d\n", anint);
	return anint;
}
....

Le programme met i à `5` et le passe à une fonction `bazz()` qui imprime le nombre que nous lui avons donné. 

Puis nous compilons et exécutons le programme obtenu 

[source,bash]
....
% cc -g -o temp temp.c
% ./temp
C'est mon programme
Vous m'avez fourni 4231
....

Ce n'était pas ce que nous attendions ! Il est temps de voir ce qui se passe ! 

[source,bash]
....
% gdb temp
GDB is free software and you are welcome to distribute copies of it
 under certain conditions; type "show copying" to see the conditions.
There is absolutely no warranty for GDB; type "show warranty" for details.
GDB 4.13 (i386-unknown-freebsd), Copyright 1994 Free Software Foundation, Inc.
(gdb) break main				passe le code d'initialisation
Breakpoint 1 at 0x160f: file temp.c, line 9.	gdb met un point d'arrêt sur main()
(gdb) run					Exécute jusqu'à main()
Starting program: /home/james/tmp/temp		Le programme démarre

Breakpoint 1, main () at temp.c:9		gdb s'arrête à main()
(gdb) n						Va à la ligne suivante
C'est mon programme				Le programme écrit
(gdb) s						entre dans bazz()
bazz (anint=4231) at temp.c:17			gdb montre la pile
(gdb)
....

Arrêtons-nous une minute! Comment anint a eu la valeur `4231`? Ne l'avons-nous pas mis à `5` dans `main()`? Remontons dans `main()` et regardons. 

[source,bash]
....
(gdb) up					Remonte la pile des appels
#1  0x1625 in main () at temp.c:11		gdb montre la pile
(gdb) p i					Montre la valeur de i
$1 = 4231					gdb montre 4231
....

Oh ! En regardant dans le code, nous avons oublié d'initialiser i. Nous aurions dû mettre 

[.programlisting]
....
...
main() {
	int i;

	i = 5;
	printf("C'est mon programme\n");
...
....

mais nous n'avions pas mis la ligne `i=5;`. Comme nous n'avons pas initialisé i, il a pris le nombre se trouvant dans la zone de mémoire quand le programme a démarré, ce qui dans ce cas était `4231`. 

[NOTE]
====
`gdb` montre la pile chaque fois que nous entrons ou sortons d'une fonction, même si nous avons utilisé `up` et `down` pour nous déplacer dans la pile des appels. Cela montre le nom de la fonction et les valeurs de ses arguments, ce qui nous aide à garder une trace d'où nous sommes et de ce qui se passe. (La pile est une zone de stockage où le programme stocke les informations sur les arguments passés aux fonctions et où il doit aller quand il revient d'une fonction). 
====

=== Examiner un fichier [.filename]#core#

Un fichier [.filename]#core# est basiquement un fichier qui contient l'état complet du processus quand il s'est planté. Dans "le bon vieux temps", les programmeurs devait imprimer des listings en hexadécimal de fichiers [.filename]#core# et transpirer sur leur manuels de code machine, mais la vie est maintenant un peu plus facile. Par chance, sous FreeBSD et les autres systèmes 4.4BSD, un fichier [.filename]#core# est appelé [.filename]#nomprog.core# plutôt que juste [.filename]#core#, pour mieux savoir à quel programme appartient un fichier [.filename]#core#. 

Pour examiner un fichier [.filename]#core#, démarrez `gdb` de façon habituel. Plutôt que de taper `break` ou `run`, tapez 

[source,bash]
....
(gdb) core nomprog.core
....

Si vous n'êtes pas dans le même répertoire que le fichier [.filename]#core#, vous devrez faire `dir /path/to/core/file` d'abord. 

Vous devriez voir quelque chose comme cela: 

[source,bash]
....
% gdb a.out
GDB is free software and you are welcome to distribute copies of it
 under certain conditions; type "show copying" to see the conditions.
There is absolutely no warranty for GDB; type "show warranty" for details.
GDB 4.13 (i386-unknown-freebsd), Copyright 1994 Free Software Foundation, Inc.
(gdb) core a.out.core
Core was generated by `a.out'.
Program terminated with signal 11, Segmentation fault.
Cannot access memory at address 0x7020796d.
#0  0x164a in bazz (anint=0x5) at temp.c:17
(gdb)
....

Dans ce cas, le programme a été appelé [.filename]#a.out#, aussi le fichier [.filename]#core# s'appelle [.filename]#a.out.core#. Nous pouvons voir que le programme s'est planté car il a essayé d'accèder à une zone dans la mémoire qui n'était pas disponible dans la fonction appelée `bazz`. 

Quelquefois il est utile de pouvoir voir comment une fonction a été appelée car le problème peut avoir eu lieu bien avant dans la pile des appels dans un programme complexe. La commande `bt` demande à `gdb` d'afficher une trace inverse de la pile des appels: 

[source,bash]
....
(gdb) bt
#0  0x164a in bazz (anint=0x5) at temp.c:17
#1  0xefbfd888 in end ()
#2  0x162c in main () at temp.c:11
(gdb)
....

La fonction `end()` est appelée lorsque le programme se plante; dans ce cas, la fonction `bazz()` a été appelée `main()`. 

=== Se brancher sur un programme en cours d'exécution

Une des plus belles caractéristiques de `gdb` est qu'il peut se brancher sur un programme qui s'exécute déjà. Bien sûr, cela suppose que vous ayez les privilèges suffisants pour le faire. Un problème habituel est quand vous vous déplacez dans un programme qui se dédouble et que vous voulez tracer le programme fils cependant le dévermineur ne vous laissera seulement tracer le père. 

Ce que vous devez faire est de démarrer un autre `gdb`, utiliser `ps` pour trouver l'ID du processus fils et faire 

[source,bash]
....
(gdb) attach identifiant_processus
....

dans `gdb`, et déverminer ensuite comme d'habitude. 

"C'est tout simple," pensez-vous certainement," mais pendant le temps que je faisais ça, le processus fils sera déjà parti loin". Ne vous en faites pas, noble lecteur, voici comment faire (avec l'appui des pages d'info de `gdb`): 

[source,bash]
....
…
if ((pid = fork()) < 0)		/* _Toujours_ verifier cela */
	error();
else if (pid == 0) {		/* le fils */
	int PauseMode = 1;

	while (PauseMode)
		sleep(10);	/* Attendre jusqu'a ce que quelqu'un se brache sur nous */
	…
} else {			/* le pere */
	…
....

Maintenant tout ce que nous avons à faire est de nous brancher sur le processus fils, de mettre PauseMode à `0` et d'attendre que l'appel à la fonction `sleep()` retourne ! 

[[emacs]]
== Utiliser Emacs comme environnement de développement

=== Emacs

Malheureusement, les systèmes Unix ne sont pas fournis avec des sortes d'environnements de développement intégrés tout-ce-que-vous-avez-toujours-voulu-et-beaucoup-plus-dans-un-ensemble-gigantesque que d'autres sytèmes ont.  Toutefois, il est possible de se faire son propre environnement. Cela n'est pas forcément aussi joli et il peut ne pas être autant intégré mais vous pouvez le personnaliser comme vous voulez. Et c'est gratuit. Et vous en avez les sources. 

La clé de tout cela est Emacs. Maintenant il y a des gens qui le détestent, mais beaucoup l'aiment. Si vous êtes un du premier groupe, j'ai peur que cette section ait peu d'intérêt pour vous. Vous aurez besoin d'une quantité moyenne de mémoire pour le faire fonctionner-Je recommenderai 8Mo en mode texte et 16Mo dans X pour avoir un minimum de performances. 

Emacs est basiquement un éditeur hautement personnalisable -en effet, il a été personnalisé au point de ressembler plus à un système d'exploitation qu'à un éditeur! Beaucoup de développeurs et d'administrateurs système passent en fait pratiquement tout leur temps à travailler dans Emacs, en ne le quittant qu'à leur déconnexion. 

Il est impossible de dire tout ce qu'Emacs peut faire ici, mais voici quelques unes des caractéristiques d'intérêt pour les développeurs: 

* Un très puissant éditeur, permettant le chercher-remplacer sur les chaînes et les expressions régulières (motifs), sauter à la fin ou au début d'un bloc, etc, etc. 
* Menus déroulants et aide en ligne. 
* Colorisation syntaxique en fonction du langage et indentation. 
* Totalement personnalisable. 
* Vous pouvez compiler et déverminer des programmes dans Emacs. 
* Sur erreur de compilation, vous pouvez aller directement à la ligne de code source fautive. 
* Une interface amicale au programme `info` utilisé pour lire la documentation hypertexte GNU, incluant la documentation sur Emacs elle-même. 
* Une interface agréable à `gdb`, vous permettant de voir le code source au fur et à mesure que vous vous déplacez dans votre programme. 
* Vous pouvez lire les nouvelles Usenet et envoyer des e-mails pendant que votre programme est en compilation. 

Et sans doute beaucoup plus que je n'ai survolé. 

Emacs peut être installé sur FreeBSD en utilisant Emacs link:../../ports/editors.html[le logiciel porté Emacs]. 

Une fois installé, démarrez-le et faites `C-h t` pour lire un cours sur Emacs-cela signifie maintenir la touche kbd:[control], presser kbd:[h], relâcher la touche kbd:[control] et presser kbd:[t]. (Alternativement, vous pouvez utiliser la souris pour sélectionner [.guimenuitem]#Emacs Tutorial# dans le menu menu:Help[]). 

Bien que Emacs possède des menus, il est valable d'apprendre les raccourcis clavier, étant plus rapide quand vous éditez quelque chose d'appuyer sur un couple de touches que de reprendre la souris et de cliquer au bon endroit. Et, quand vous discutez avec des utilisateurs expérimentés d'Emacs, vous trouverez qu'ils parlent souvent de choses comme "`M-x replace-s RET foo RET bar RET`" aussi il est utile de savoir ce que cela veut dire. Et dans tous les cas, Emacs possède beaucoup trop de fonctions pour qu'elles soient dans les barres de menus. 

Heureusement, il est assez simple de récupérer les raccourcis clavier car ils sont affichés à côté des éléments des menus déroulants. Mon conseil est d'utiliser un élément de menu pour, disons, ouvrir un fichier jusqu'à ce que vous sachiez comment cela fonctionne et que quand vous vous sentez à l'aise avec, essayez `C-x C-f`. Quand vous serez content avec ça, passez à une autre commande du menu. 

Si vous ne pouvez pas vous rappeler de ce qu'une combinaison de touches particulières fait, sélectionnez [.guimenuitem]#Describe Key# dans le menu menu:Help[] et tapez-la-Emacs vous dira ce qu'elle fait. Vous pouvez aussi utiliser l'élément de menu [.guimenuitem]#Command Apropos# pour trouver toutes les commandes qui contiennent un mot particulier, avec leur raccourci clavier. 

De cette manière, l'expression ci-dessus signifie maintenir la touche kbd:[Meta], taper kbd:[x], relâcher la touche kbd:[Meta], taper `replace-s` (raccourci pour `replace-string`- une autre caractéristique d'Emacs est que vous pouvez abréger les commandes), appuyer sur la touche kbd:[Entrée], taper `foo` (la chaîne que vous voulez remplacer), presser la touche kbd:[Entrée], taper `bar` (la chaîne que vous voulez substituer à `foo`) puis appuyer sur kbd:[Entrée] une dernière fois. Emacs va alors faire l'opération chercher-remplacer que vous avez demandé. 

Si vous vous demandez ce qu'est cette touche kbd:[Meta], il s'agit d'une touche spéciale que beaucoup de stations de travail Unix possèdent. Malheureusement, les PC n'en ont pas, aussi c'est habituellement la touche kbd:[alt] (ou si vous n'avez pas de chance, la touche kbd:[échap]). 

Oh, et pour sortir d'Emacs, faites `C-x C-c` (ce qui signifie maintenir la touche kbd:[control] appuyée, appuyer kbd:[c] et relâcher la touche kbd:[control]. Si vous avez des fichiers non sauvegardés ouverts, Emacs vous demandera si vous voulez les sauvegarder. (Ignorez le bout de documentation où il est dit que `C-z` est la manière habituelle de quitter Emacs- qui quitte Emacs en le laissant tourner en tâche de fond et qui n'est vraiment utile que si vous avez un système sans terminal virtuel). 

=== Configurer Emacs

Emacs fait des choses merveilleuses; une partie est intégrée directement, une autre doit être configurée. 

Plutôt que d'utiliser un macro langage propriétaire pour la configuration, Emacs utilise une version du Lisp spécialement adaptée pour les éditeurs, connue sous le nom d'Emacs Lisp. Celui-ci peut être assez utile si vous voulez poursuivre et apprendre quelque chose comme le Common Lisp, car il est considérablement plus petit que le Common Lisp (bien que déjà assez gros!). 

La meilleure façon d'apprendre l'Emacs Lisp est de télécharger le link:ftp://prep.ai.mit.edu:pub/gnu/elisp-manual-19-2.4.tar.gz[cours d'Emacs]

Toutefois, il n'y a pas besoin de connaître le Lisp pour commencer la configuration d'Emacs, car j'ai inclus un exemple de fichier [.filename]#.emacs# qui devrait être suffisant pour commencer. Copiez juste celui-ci dans votre répertoire utilisateur et redémarrez Emacs si celui-ci s'exécute, il lira les commandes du fichier et (si tout va bien!) vous donnera une configuration basique utile. 

=== Un fichier exemple [.filename]#.emacs#

Malheureusement, il y a beaucoup trop de choses ici pour les expliquer en détail; toutefois, il y a un ou deux points qui valent d'être mentionnés. 

* Tout ce qui commence avec un `;` est un commentaire et est ignoré par Emacs. 
* A la première ligne, le `-*- Emacs-Lisp -*-` est tel que vous pouvez éditer le fichier [.filename]#.emacs# lui-même à l'intérieur d'Emacs et d'obtenir tous les fantaisistes dispositifs pour l'édition en Emacs Lisp. Emacs essaye habituellement de deviner cela en se basant sur le nom du fichier, et ne trouvera peut-être pas pour [.filename]#.emacs#. 
* La touche kbd:[tab] est liée à la fonction d'indentation dans certains modes, aussi quand vous l'enfoncez, cela va indenter la ligne courante de code. Si vous voulez mettre un caractère tab dans quoique ce soit que vous tapiez, maintenez la touche kbd:[control] enfoncée pendant que vous appuyez sur kbd:[tab]. 
* Ce fichier supporte la colorisation de syntaxe pour les langages C, C++, Perl, Lisp et Scheme en devinant le langage par leur nom. 
* Emacs possède déjà une fonction pré-définie appelée `next-error`. Dans la fenêtre de sortie d'une compilation, cela vous permet de vous déplacer d'une erreur de compilation à la suivante en faisant `M-n`; nous définissons une fonction complémentaire `previous-error`, qui vous permet d'aller à l'erreur précédente en faisant `M-p`. Le plus beau dispositif de tous est que `C-c C-c` va ouvrir le fichier source dans lequel l'erreur a eu lieu et sautera à la ligne appropriée. 
* Nous autorisons la capacité d'Emacs à agir comme un serveur ainsi si vous faites quelque chose en dehors d'Emacs et voulez éditer un fichier, tapez juste 
+
[source,bash]
....
% emacsclient nomfichier
....
+ 
et alors vous pouvez éditer le fichier dans votre Emacs! 

.Un fichier exemple [.filename]#.emacs#
[example]
====
[.programlisting]
....
;; -*-Emacs-Lisp-*-

;; Ce fichier est concu pour etre reevalue, utiliser la variable first-time
;; pour eviter tout probleme.
(defvar first-time t
  "Valeur signifiant que c'est la premiere fois que .emacs a ete evalue"
  )

;; Meta
(global-set-key "\M- " 'set-mark-command)
(global-set-key "\M-\C-h" 'backward-kill-word)
(global-set-key "\M-\C-r" 'query-replace)
(global-set-key "\M-r" 'replace-string)
(global-set-key "\M-g" 'goto-line)
(global-set-key "\M-h" 'help-command)

;; Function keys
(global-set-key [f1] 'manual-entry)
(global-set-key [f2] 'info)
(global-set-key [f3] 'repeat-complex-command)
(global-set-key [f4] 'advertised-undo)
(global-set-key [f5] 'eval-current-buffer)
(global-set-key [f6] 'buffer-menu)
(global-set-key [f7] 'other-window)
(global-set-key [f8] 'find-file)
(global-set-key [f9] 'save-buffer)
(global-set-key [f10] 'next-error)
(global-set-key [f11] 'compile)
(global-set-key [f12] 'grep)
(global-set-key [C-f1] 'compile)
(global-set-key [C-f2] 'grep)
(global-set-key [C-f3] 'next-error)
(global-set-key [C-f4] 'previous-error)
(global-set-key [C-f5] 'display-faces)
(global-set-key [C-f8] 'dired)
(global-set-key [C-f10] 'kill-compilation)

;; Keypad bindings
(global-set-key [up] "\C-p")
(global-set-key [down] "\C-n")
(global-set-key [left] "\C-b")
(global-set-key [right] "\C-f")
(global-set-key [home] "\C-a")
(global-set-key [end] "\C-e")
(global-set-key [prior] "\M-v")
(global-set-key [next] "\C-v")
(global-set-key [C-up] "\M-\C-b")
(global-set-key [C-down] "\M-\C-f")
(global-set-key [C-left] "\M-b")
(global-set-key [C-right] "\M-f")
(global-set-key [C-home] "\M-<")
(global-set-key [C-end] "\M->")
(global-set-key [C-prior] "\M-<")
(global-set-key [C-next] "\M->")

;; Souris
(global-set-key [mouse-3] 'imenu)

;; Divers
(global-set-key [C-tab] "\C-q\t")	; Control tab quotes a tab.
(setq backup-by-copying-when-mismatch t)

;; Traite 'y' ou <CR> comme yes, 'n' comme no.
(fset 'yes-or-no-p 'y-or-n-p)
    (define-key query-replace-map [return] 'act)
    (define-key query-replace-map [?\C-m] 'act)

;; Charge les ajouts
(require 'desktop)
(require 'tar-mode)

;; Diff mode sympa
(autoload 'ediff-buffers "ediff" "Intelligent Emacs interface to diff" t)
(autoload 'ediff-files "ediff" "Intelligent Emacs interface to diff" t)
(autoload 'ediff-files-remote "ediff"
  "Intelligent Emacs interface to diff")

(if first-time
    (setq auto-mode-alist
	  (append '(("\\.cpp$" . c++-mode)
		    ("\\.hpp$" . c++-mode)
                    ("\\.lsp$" . lisp-mode)
		    ("\\.scm$" . scheme-mode)
		    ("\\.pl$" . perl-mode)
		    ) auto-mode-alist)))

;; Mode de verrouillage automatique de la police de caracteres
(defvar font-lock-auto-mode-list
  (list 'c-mode 'c++-mode 'c++-c-mode 'emacs-lisp-mode 'lisp-mode 'perl-mode 'scheme-mode)
  "List of modes to always start in font-lock-mode")

(defvar font-lock-mode-keyword-alist
  '((c++-c-mode . c-font-lock-keywords)
    (perl-mode . perl-font-lock-keywords))
  "Associations between modes and keywords")

(defun font-lock-auto-mode-select ()
  "Automatically select font-lock-mode if the current major mode is
in font-lock-auto-mode-list"
  (if (memq major-mode font-lock-auto-mode-list)
      (progn
	(font-lock-mode t))
    )
  )

(global-set-key [M-f1] 'font-lock-fontify-buffer)

;; New dabbrev stuff
;(require 'new-dabbrev)
(setq dabbrev-always-check-other-buffers t)
(setq dabbrev-abbrev-char-regexp "\\sw\\|\\s_")
(add-hook 'emacs-lisp-mode-hook
	  '(lambda ()
	     (set (make-local-variable 'dabbrev-case-fold-search) nil)
	     (set (make-local-variable 'dabbrev-case-replace) nil)))
(add-hook 'c-mode-hook
	  '(lambda ()
	     (set (make-local-variable 'dabbrev-case-fold-search) nil)
	     (set (make-local-variable 'dabbrev-case-replace) nil)))
(add-hook 'text-mode-hook
	  '(lambda ()
	     (set (make-local-variable 'dabbrev-case-fold-search) t)
	     (set (make-local-variable 'dabbrev-case-replace) t)))

;; mode C++ et C...
(defun my-c++-mode-hook ()
  (setq tab-width 4)
  (define-key c++-mode-map "\C-m" 'reindent-then-newline-and-indent)
  (define-key c++-mode-map "\C-ce" 'c-comment-edit)
  (setq c++-auto-hungry-initial-state 'none)
  (setq c++-delete-function 'backward-delete-char)
  (setq c++-tab-always-indent t)
  (setq c-indent-level 4)
  (setq c-continued-statement-offset 4)
  (setq c++-empty-arglist-indent 4))

(defun my-c-mode-hook ()
  (setq tab-width 4)
  (define-key c-mode-map "\C-m" 'reindent-then-newline-and-indent)
  (define-key c-mode-map "\C-ce" 'c-comment-edit)
  (setq c-auto-hungry-initial-state 'none)
  (setq c-delete-function 'backward-delete-char)
  (setq c-tab-always-indent t)
;; Style d'indentation BSD
  (setq c-indent-level 4)
  (setq c-continued-statement-offset 4)
  (setq c-brace-offset -4)
  (setq c-argdecl-indent 0)
  (setq c-label-offset -4))

;; mode Perl
(defun my-perl-mode-hook ()
  (setq tab-width 4)
  (define-key c++-mode-map "\C-m" 'reindent-then-newline-and-indent)
  (setq perl-indent-level 4)
  (setq perl-continued-statement-offset 4))

;; mode Scheme...
(defun my-scheme-mode-hook ()
  (define-key scheme-mode-map "\C-m" 'reindent-then-newline-and-indent))

;; mode Emacs-Lisp...
(defun my-lisp-mode-hook ()
  (define-key lisp-mode-map "\C-m" 'reindent-then-newline-and-indent)
  (define-key lisp-mode-map "\C-i" 'lisp-indent-line)
  (define-key lisp-mode-map "\C-j" 'eval-print-last-sexp))

;; Ajoute tout le reste...
(add-hook 'c++-mode-hook 'my-c++-mode-hook)
(add-hook 'c-mode-hook 'my-c-mode-hook)
(add-hook 'scheme-mode-hook 'my-scheme-mode-hook)
(add-hook 'emacs-lisp-mode-hook 'my-lisp-mode-hook)
(add-hook 'lisp-mode-hook 'my-lisp-mode-hook)
(add-hook 'perl-mode-hook 'my-perl-mode-hook)

;; Le complement a next-error
(defun previous-error (n)
  "Visit previous compilation error message and corresponding source code."
  (interactive "p")
  (next-error (- n)))

;; Divers...
(transient-mark-mode 1)
(setq mark-even-if-inactive t)
(setq visible-bell nil)
(setq next-line-add-newlines nil)
(setq compile-command "make")
(setq suggest-key-bindings nil)
(put 'eval-expression 'disabled nil)
(put 'narrow-to-region 'disabled nil)
(put 'set-goal-column 'disabled nil)

;; Recherche des archives Elisp
(autoload 'format-lisp-code-directory "lispdir" nil t)
(autoload 'lisp-dir-apropos "lispdir" nil t)
(autoload 'lisp-dir-retrieve "lispdir" nil t)
(autoload 'lisp-dir-verify "lispdir" nil t)

;; Mode de verrouillage de police
(defun my-make-face (face colour &optional bold)
  "Create a face from a colour and optionally make it bold"
  (make-face face)
  (copy-face 'default face)
  (set-face-foreground face colour)
  (if bold (make-face-bold face))
  )

(if (eq window-system 'x)
    (progn
      (my-make-face 'blue "blue")
      (my-make-face 'red "red")
      (my-make-face 'green "dark green")
      (setq font-lock-comment-face 'blue)
      (setq font-lock-string-face 'bold)
      (setq font-lock-type-face 'bold)
      (setq font-lock-keyword-face 'bold)
      (setq font-lock-function-name-face 'red)
      (setq font-lock-doc-string-face 'green)
      (add-hook 'find-file-hooks 'font-lock-auto-mode-select)

      (setq baud-rate 1000000)
      (global-set-key "\C-cmm" 'menu-bar-mode)
      (global-set-key "\C-cms" 'scroll-bar-mode)
      (global-set-key [backspace] 'backward-delete-char)
					;      (global-set-key [delete] 'delete-char)
      (standard-display-european t)
      (load-library "iso-transl")))

;; X11 ou PC utilisant les ecritures directes a l'ecran
(if window-system
    (progn
      ;;      (global-set-key [M-f1] 'hilit-repaint-command)
      ;;      (global-set-key [M-f2] [?\C-u M-f1])
      (setq hilit-mode-enable-list
	    '(not text-mode c-mode c++-mode emacs-lisp-mode lisp-mode
		  scheme-mode)
	    hilit-auto-highlight nil
	    hilit-auto-rehighlight 'visible
	    hilit-inhibit-hooks nil
	    hilit-inhibit-rebinding t)
      (require 'hilit19)
      (require 'paren))
  (setq baud-rate 2400)			; For slow serial connections
  )

;; Terminal de type TTY
(if (and (not window-system)
	 (not (equal system-type 'ms-dos)))
    (progn
      (if first-time
	  (progn
	    (keyboard-translate ?\C-h ?\C-?)
	    (keyboard-translate ?\C-? ?\C-h)))))

;; Sous Unix
(if (not (equal system-type 'ms-dos))
    (progn
      (if first-time
	  (server-start))))

;; Add any face changes here
(add-hook 'term-setup-hook 'my-term-setup-hook)
(defun my-term-setup-hook ()
  (if (eq window-system 'pc)
      (progn
;;	(set-face-background 'default "red")
	)))

;; Restaure le  "desktop" - faire cela le plus tard possible
(if first-time
    (progn
      (desktop-load-default)
      (desktop-read)))

;; Indique que ce fichier a ete lu au moins une fois
(setq first-time nil)

;; Pas besoin de deverminer quoique ce soit maintenant

(setq debug-on-error nil)

;; Tout est fait
(message "All done, %s%s" (user-login-name) ".")
....

====

=== Etendre la palette de langages qu'Emacs comprend

Maintenant, Emacs est très bien si vous voulez seulement programmer dans des langages déjà fournis dans le fichier [.filename]#.emacs# (C, C++, Perl, Lisp et Scheme), mais qu'arrive-t-il si un nouveau langage appelé "whizbang" sort, plein d'excitantes fonctionnalités ? 

La première chose à faire est de savoir si whizbang est fourni avec des fichiers de configuration pour Emacs. Ceux-ci se terminent habituellement par [.filename]#.el#, raccourci pour "Emacs Lisp". Par exemple, si whizbang est un logiciel porté FreeBSD, nous pouvons localiser ces fichiers en faisant 

[source,bash]
....
% find /usr/ports/lang/whizbang -name "*.el" -print
....

et les installer en les copiant dans le répertoire Lisp d'Emacs. Sur FreeBSD 2.1.0-RELEASE, il s'agit de [.filename]#/usr/local/shared/emacs/site-lisp#. 

Aisni par exemple, si la sortie de la commande `find` était 

[source,bash]
....
/usr/ports/lang/whizbang/work/misc/whizbang.el
....

nous ferions 

[source,bash]
....
# cp /usr/ports/lang/whizbang/work/misc/whizbang.el /usr/local/shared/emacs/site-lisp
....

Ensuite, nous devons décider quel extension les fichiers source whizbang ont. Disons qu'il s'agit de fichiers se terminant par [.filename]#.wiz#. Nous devons ajouter une entrée dans notre fichier [.filename]#.emacs# pour être sûr qu'Emacs sera capable d'utiliser les informations dans [.filename]#whizbang.el#. 

Trouvez l'entrée auto-mode-alist dans [.filename]#.emacs# et ajoutez une ligne pour whizbang, comme : 

[.programlisting]
....
...
("\\.lsp$" . lisp-mode)
("\\.wiz$" . whizbang-mode)
("\\.scm$" . scheme-mode)
...
....

Cela signifie qu'Emacs ira automatiquement dans la fonction `whizbang-mode` quand vous éditerez un fichier se terminant par [.filename]#.wiz#. 

Juste en-dessous, vous trouverez l'entrée font-lock-auto-mode-list. Ajoutez `whizbang-mode` à celle-ci comme ceci : 

[.programlisting]
....
;; Auto font lock mode
(defvar font-lock-auto-mode-list
  (list 'c-mode 'c++-mode 'c++-c-mode 'emacs-lisp-mode 'whizbang-mode 'lisp-mode 'perl-mode 'scheme-mode)
  "List of modes to always start in font-lock-mode")
....

Cela signifie qu'Emacs autorisera toujours `font-lock-mode` (ie colorisation de la syntaxe) pendant l'édition d'un fichier [.filename]#.wiz#. 

Et c'est tout ce qui est nécessaire. S'il y a quoique ce soit que vous voulez de fait automatiquement quand vous ouvrez un fichier [.filename]#.wiz#, vous pouvez ajouter un `whizbang-mode hook` (voir `my-scheme-mode-hook` pour un exemple simple qui ajoute `auto-indent`, l'auto-indentation). 

== Pour aller plus loin

* Brian Harvey and Matthew Wright _Simply Scheme_ MIT 1994. ISBN 0-262-08226-8
* Randall Schwartz _Learning Perl_ O'Reilly 1993 ISBN 1-56592-042-2
* Patrick Henry Winston and Berthold Klaus Paul Horn _Lisp (3rd Edition)_ Addison-Wesley 1989 ISBN 0-201-08319-1
* Brian W. Kernighan and Rob Pike _The Unix Programming Environment_ Prentice-Hall 1984 ISBN 0-13-937681-X
* Brian W. Kernighan and Dennis M. Ritchie _The C Programming Language (2nd Edition)_ Prentice-Hall 1988 ISBN 0-13-110362-8
* Bjarne Stroustrup _The C++ Programming Language_ Addison-Wesley 1991 ISBN 0-201-53992-6
* W. Richard Stevens _Advanced Programming in the Unix Environment_ Addison-Wesley 1992 ISBN 0-201-56317-7
* W. Richard Stevens _Unix Network Programming_ Prentice-Hall 1990 ISBN 0-13-949876-1
