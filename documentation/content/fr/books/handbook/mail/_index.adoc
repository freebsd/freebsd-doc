---
title: Chapitre 29. Courrier électronique
part: Partie IV. Réseau
prev: books/handbook/ppp-and-slip
next: books/handbook/network-servers
showBookMenu: true
weight: 34
path: "/books/handbook/mail/"
---

[[mail]]
= Courrier électronique
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 29
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/mail/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[mail-synopsis]]
== Synopsis

Le "courrier électronique", plus connu sous le nom d'email, est une des formes de communication les plus utilisées aujourd'hui. Ce chapitre fournit une introduction sur comment faire fonctionner un serveur de courrier électronique sous FreeBSD, et comment envoyer et recevoir du courrier électronique sous FreeBSD. Cependant, cela n'est pas un document de référence, en fait de nombreux éléments importants ont été omis. Pour une couverture plus complète du sujet, le lecteur doit se référer aux nombreux ouvrages excellents listés dans l'crossref:bibliography[bibliography,Bibliographie].

Après la lecture de ce chapitre, vous connaîtrez:

* Quels composants logiciel sont impliqués dans l'envoi et la réception du courrier électronique.
* Où se trouvent sous FreeBSD les fichiers de configuration de base de sendmail.
* La différence entre boîtes aux lettres distantes et boîtes aux lettres locale.
* Comment empêcher les personnes à l'origine de courriers non sollicités (spam) d'utiliser votre serveur de courrier comme relais.
* Comment installer et configurer un agent de transfert de courrier alternatif sur votre système, en remplacement de sendmail.
* Comment dépanner les problèmes courants des serveurs de courrier électronique.
* Comment utiliser le protocole SMTP avec UUCP.
* Comment utiliser le courrier électronique avec une connexion temporaire.
* Comment configurer l'authentification SMTP pour une sécurité accrue.
* Comment installer et utiliser un client de messagerie, comme mutt pour envoyer et lire du courrier électronique.
* Comme récupérer votre courrier électronique à partir d'un serveur POP ou IMAP distant.
* Comment appliquer automatiquement des règles de filtrage au courrier entrant.

Avant de lire ce chapitre, vous devrez:

* Configurer correctement votre connexion réseau (crossref:advanced-networking[advanced-networking,Administration réseau avancée]).
* Configurer correctement les informations DNS pour votre serveur de courrier (crossref:advanced-networking[advanced-networking,Administration réseau avancée]).
* Savoir comment installer des logiciels tiers (crossref:ports[ports,Installer des applications. les logiciels pré-compilés et les logiciels portés]).

[[mail-using]]
== Utilisation du courrier électronique

Il y a cinq éléments majeurs impliqués dans un échange de courrier. Ce sont: <<mail-mua,le programme utilisateur>>, <<mail-mta,le "daemon" serveur de courrier>>, <<mail-dns,le serveur DNS>>, <<mail-receive,une boîte aux lettres distante ou locale>>, et bien sûr le <<mail-host,le serveur de courrier lui-même >>.

[[mail-mua]]
=== Le programme utilisateur

Cela inclut des programmes en ligne de commande comme mutt, pine, elm, et mail, et des programmes graphiques comme balsa, xfmail pour juste en nommer quelques-uns, ou quelque chose de plus "sophisticated" comme un navigateur WWW. Ces programmes transmettent simplement toutes les transactions concernant le courrier électronique au <<mail-host,serveur de courrier local>>, soit en invoquant un des <<mail-mta,"daemons" serveurs>> (Agents de transfert de courrier) disponibles, soit via TCP.

[[mail-mta]]
=== Le "daemon" serveur de courrier

FreeBSD est fourni par défaut avec sendmail, mais supporte également de nombreux autres "daemons" serveurs de courrier, parmi lesquels:

* exim;
* postfix;
* qmail.

Le serveur a généralement deux fonctions-il est responsable de la réception du courrier comme celle de son envoi. Il n'est cependant _pas_ responsable de la récupération du courrier électronique en utilisant des protocoles comme POP ou IMAP pour lire votre courrier, il ne vous permet pas non plus la connexion à des boîtes aux lettres locales de type [.filename]#mbox# ou maildir. Vous avez besoin d'un <<mail-receive,"daemon">> supplémentaire pour cela.

[WARNING]
====

Les anciennes version de sendmail ont de sérieux problèmes de sécurité qui peuvent avoir pour conséquence l'obtention d'un accès local et/ou à distance à votre machine pour une personne malveillante. Vérifiez que vous utilisez une version à jour pour éviter de tels problèmes. Vous avez cependant toujours la possibilité d'installer un autre MTA à partir du crossref:ports[ports,catalogue des logiciels portés de FreeBSD].
====

[[mail-dns]]
=== Courrier électronique et DNS

Le système de noms de domaines (DNS) et son "daemon" `named` jouent un rôle important dans la transmission du courrier électronique. Afin de délivrer du courrier de votre site à un autre, le serveur recherchera le site distant dans la base de données DNS pour déterminer la machine qui recevra le courrier électronique pour le destinataire. Ce processus intervient également quand un courrier électronique est envoyé à partir d'une machine distante vers votre serveur de courrier.

Le DNS gère la correspondance entre nom de machine et adresse IP, et le stockage des informations spécifiques à la distribution du courrier électronique, connues sous le nom d'enregistrements MX. L'enregistrement MX ("Mail eXchanger") définit la machine, ou les machines, qui recevra le courrier pour un domaine particulier. Si vous n'avez pas d'enregistrement MX pour votre machine ou votre domaine, le courrier sera directement envoyé à votre machine à condition que vous ayez un enregistrement A faisant correspondre à votre nom de machine votre adresse IP.

Vous pouvez obtenir les enregistrements MX pour n'importe quel domaine en utilisant la commande man:host[1] est présentée ci-dessous:

[source,shell]
....
% host -t mx FreeBSD.org
FreeBSD.org mail is handled (pri=10) by mx1.FreeBSD.org
....

[[mail-receive]]
=== Réception de courrier

La réception du courrier pour votre domaine se fait par le serveur de courrier. Il collectera le courrier qui est envoyé à destination de votre domaine et le stockera soit sous le format [.filename]#mbox# (la méthode par défaut de stockage du courrier électronique) ou le format Maildir, en fonction de votre configuration. Une fois le courrier stocké, il peut être lu localement en utilisant des applications comme man:mail[1] ou mutt, ou lu à distance et récupéré en utilisant des protocoles tels que POP ou IMAP. Cela signifie que si vous désirez uniquement lire votre courrier électroniquement en local, vous n'avez pas besoin d'installer un serveur POP ou IMAP.

[[pop-and-imap]]
==== Accès aux boîtes aux lettres distantes en utilisant POP et IMAP

Pour accéder à des boîtes aux lettres distantes, vous devez avoir un accès à un serveur POP ou IMAP. Ces protocoles permettent aux utilisateurs de se connecter aisément à leurs boîtes aux lettres à partir de machines distantes. Bien que POP et IMAP permettent, tous les deux, l'accès aux boîtes aux lettres pour les utilisateurs, IMAP offre de nombreux avantages, parmi lesquels:

* IMAP peut stocker les messages sur un serveur distant et les récupérer.
* IMAP supporte les mises à jour concourantes.
* IMAP peut être extrêmement utile pour les connexions lentes car il permet aux utilisateurs de récupérer la structure des messages sans les télécharger. Il peut également effectuer des tâches comme la recherche sur le serveur pour réduire les transferts de données entre clients et serveurs.

Pour installer un serveur POP ou IMAP, les étapes suivantes doivent être suivies:

[.procedure]
====
. Choisissez un serveur IMAP ou POP correspondant à vos besoins. Les serveurs POP et IMAP suivants sont connus et sont de bons exemples:

** qpopper;
** teapop;
** imap-uw;
** courier-imap;

. Installez le "daemon" POP ou IMAP de votre choix à partir du catalogue des logiciels portés.
. Si cela est nécessaire, modifiez le fichier [.filename]#/etc/inetd.conf# pour charger le serveur POP ou IMAP.
====

[WARNING]
====

Il doit être noté que POP et IMAP transmettent les données, y compris les noms d'utilisateurs et mot de passe d'authentification en clair. Cela signifie que si vous désirez sécuriser la transmission des données avec ces protocoles, vous devriez considérer l'utilisation de de tunnels man:ssh[1]. L'utilisation de tels tunnels est décrite dans la crossref:security[security-ssh-tunneling,Tunnels SSH].
====

[[local]]
==== Accès aux boîtes aux lettres locales

Les boîtes aux lettres peuvent être accessibles localement en utilisant un client de messagerie sur le serveur où se trouve la boîte. Cela peut être fait en employant des applications telles que mutt ou man:mail[1].

[[mail-host]]
=== Le serveur de courrier

Le serveur de courrier est le nom donné au serveur qui est responsable de la transmission et la réception du courrier pour votre machine, et probablement votre réseau.

[[sendmail]]
== Configuration de sendmail

man:sendmail[8] est l'agent de transfert de courrier (Mail Transfert Agent-MTA) par défaut sous FreeBSD. Le rôle de sendmail est d'accepter le courrier en provenance des agents de courrier utilisateur (Mail User Agents-MUA) et de délivrer le courrier aux programmes de gestion du courrier définis dans son fichier de configuration. sendmail peut également accepter les connexions réseau et délivrer le courrier dans des boîtes aux lettres locales ou le transmettre à un autre programme.

sendmail utilise les fichiers de configuration suivants:

[.informaltable]
[cols="1,1", options="header"]
|===
| Fichier
| Fonction

|[.filename]#/etc/mail/access#
|Fichier de la base de données d'accès de sendmail

|[.filename]#/etc/mail/aliases#
|Alias de boîte aux lettres

|[.filename]#/etc/mail/local-host-names#
|Liste des machines pour lesquelles sendmail accepte du courrier

|[.filename]#/etc/mail/mailer.conf#
|Configuration du programme de gestion du courrier

|[.filename]#/etc/mail/mailertable#
|Table de livraison du courrier

|[.filename]#/etc/mail/sendmail.cf#
|Fichier de configuration principal de sendmail

|[.filename]#/etc/mail/virtusertable#
|Table des domaines et utilisateurs virtuels
|===

=== [.filename]#/etc/mail/access#

La base de données d'accès définit quelle(s) machine(s) ou adresses IP ont accès au serveur de courrier local et quel type d'accès ils ont. Les machines peuvent être listées avec `OK`, `REJECT`, `RELAY` ou simplement transférées à la routine de gestion des erreurs sendmail avec une erreur donnée. Les machines qui sont listées avec `OK`, qui est le comportement par défaut, sont autorisées à envoyer du courrier à cette machine dès que la destination finale du courrier est la machine locale. Les machines listées avec `REJECT` se verront rejeter pour toute connexion au serveur. Les machines présentes avec l'option `RELAY` sont autorisées à envoyer du courrier à n'importe quelle destination par l'intermédiaire de ce serveur de courrier.

.Configuration de la base de données d'accès de sendmail
[example]
====
[.programlisting]
....
cyberspammer.com                550 We don't accept mail from spammers
FREE.STEALTH.MAILER@            550 We don't accept mail from spammers
another.source.of.spam          REJECT
okay.cyberspammer.com           OK
128.32                          RELAY
....

====

Dans cet exemple nous avons cinq entrées. Les émetteurs de courrier qui correspondent à la partie gauche de la table sont affectés par l'action donnée sur la partie droite de la table. Les deux premiers exemples donnent un code d'erreur à la routine de gestion d'erreur de sendmail. Le message est affiché sur la machine distante quand un courrier électronique correspond à la partie gauche de la table. L'entrée suivante rejette le courrier en provenance d'une machine précise de l'Internet, `another.source.of.spam`. L'entrée suivante accepte les connexions à partir de la machine `okay.cyberspammer.com`, qui est plus précis que le `cyberspammer.com` de la ligne précédente. Les correspondances plus spécifiques priment sur les moins précises. La dernière entrée autorise le relais du courrier électronique en provenance de machines avec une adresse IP qui commence par `128.32`. Ces machines seront en mesure d'envoyer du courrier destiné à d'autres serveurs de courrier par l'intermédiaire de ce serveur de courrier.

Quand ce fichier est mis à jour, vous devez exécuter la commande `make` dans [.filename]#/etc/mail/# pour mettre à jour la base de données.

=== [.filename]#/etc/mail/aliases#

La base de données d'alias contient une liste de boîtes aux lettres virtuelles dont le contenu sera transmis à d'autres utilisateurs, fichiers, programmes ou d'autres alias. Voici quelques exemples qui peuvent être utilisés dans [.filename]#/etc/mail/aliases#:

.Exemple de base de données d'alias
[example]
====
[.programlisting]
....
root: localuser
ftp-bugs: joe,eric,paul
bit.bucket:  /dev/null
procmail: "|/usr/local/bin/procmail"
....

====

Le format du fichier est simple; le nom de la boîte aux lettres à gauche et la cible sur la droite. Le premier exemple transfère la boîte aux lettres `root` vers la boîte aux lettres `localuser`, qui est ensuite recherchée dans la base de données d'alias. Si aucune correspondance n'est trouvée alors le message est délivré à l'utilisateur locale `localuser`. L'exemple suivant montre une liste de correspondance. Un courrier envoyé à la boîte aux lettres `ftp-bugs` sera délivré aux trois boites locales `joe`, `eric`, et `paul`. Notez qu'une boîte aux lettres distante comme `user@exemple.com`/procmail pourra être spécifiée. L'exemple suivant montre comment transférer le courrier dans un fichier, dans notre cas [.filename]#/dev/null#. Le dernier exemple montre l'envoi du courrier à un programme, dans le cas présent le message est écrit sur l'entrée standard de [.filename]#/usr/local/bin/procmail# par l'intermédiaire d'un tube UNIX(R).

Quand ce fichier est mis à jour, vous devez exécuter la commande `make` dans [.filename]#/etc/mail/# pour mettre à jour la base de données.

=== [.filename]#/etc/mail/local-host-names#

C'est la liste des machines pour lesquelles man:sendmail[8] accepte du courrier comme s'il était destiné à la machine locale. Placez-y tous les domaines ou machines pour lesquels sendmail doit recevoir du courrier. Par exemple, si le serveur de courrier devait accepter du courrier pour le domaine `exemple.com` et la machine `mail.exemple.com`, sont [.filename]#local-host-names# ressemblera à quelque chose comme ceci:

[.programlisting]
....
exemple.com
mail.exemple.com
....

Quand ce fichier est mis à jour, man:sendmail[8] doit être relancé pour lire les changements.

=== [.filename]#/etc/mail/sendmail.cf#

Fichier principal de configuration de sendmail, [.filename]#sendmail.cf# contrôle le comportement général de sendmail, y compris tout depuis la réécriture des adresses de courrier jusqu'à l'envoi de message de rejet aux serveurs de courrier distants. Naturellement, avec tant de différentes activités, ce fichier de configuration est relativement complexe et son étude détaillée n'est pas le but de cette section. Heureusement, ce fichier a rarement besoin d'être modifié pour les serveurs de courrier standards.

Le fichier de configuration principal de sendmail peut être créé à partir de macros man:m4[1] qui définissent les fonctions et le comportement de sendmail. Veuillez consulter [.filename]#/usr/src/contrib/sendmail/cf/README# pour plus de détails.

Quand des modifications à ce fichier sont apportées, sendmail doit être redémarré pour que les changements prennent effet.

=== [.filename]#/etc/mail/virtusertable#

La table [.filename]#virtusertable# fait correspondre les adresses de courrier électronique pour des domaines virtuels et les boîtes aux lettres avec des boîtes aux lettres réelles. Ces boîtes aux lettres peuvent être locales, distantes, des alias définis dans [.filename]#/etc/mail/aliases# ou des fichiers.

.Exemple de correspondance de domaine virtuel de courrier
[example]
====
[.programlisting]
....
root@exemple.com                root
postmaster@exemple.com          postmaster@noc.exemple.net
@exemple.com                    joe
....

====

Dans l'exemple ci-dessus, nous avons une correspondance pour un domaine `exemple.com`. Ce fichier est traité jusqu'à trouver la première correspondance. Le premier élément fait correspondre `root@exemple.com` à la boîte aux lettres root locale. L'entrée suivante fait correspondre `postmaster@exemple.com` à la boîte aux lettres postmaster sur la machine `noc.exemple.net`. Et enfin, si un courrier en provenance de `exemple.com` n'a pas trouvé de correspondance, il correspondra à la dernière ligne, qui régira tous les autres messages adressés à quelqu'un du domaine `exemple.com`. La correspondance sera la boîte aux lettres locale `joe`.

[[mail-changingmta]]
== Changer votre agent de transfert de courrier

Comme mentionné précédemment, FreeBSD est fournit avec sendmail comme agent de transfert du courrier (MTA - Mail Transfert Agent). Il est donc par défaut en charge de votre courrier sortant et entrant.

Cependant, pour une variété de raison, certains administrateurs système désirent changer le MTA de leur système. Ces raisons vont de la simple envie d'essayer un autre agent au besoin d'une fonction ou ensemble spécifique qui dépend d'un autre gestionnaire de courrier. Heureusement, quelle qu'en soit la raison, FreeBSD rend le changement aisé.

=== Installer un nouveau MTA

Vous avez un vaste choix d'agent disponible. Un bon point de départ est le crossref:ports[ports,catalogue des logiciels portés de FreeBSD] où vous pourrez en trouver un grand nombre. Bien évidemment vous êtes libres d'utiliser n'importe quel agent de n'importe quelle origine, dès que vous pouvez le faire fonctionner sous FreeBSD.

Commencez par installer votre nouvel agent. Une fois ce dernier installé, il vous donne une chance de décider s'il remplit vraiment vos besoins, et vous donne l'opportunité de configurer votre nouveau logiciel avant de remplacer sendmail. Quand vous faites cela, vous devez être sûr que l'installation du nouveau logiciel ne tentera pas de remplacer des binaires du système comme [.filename]#/usr/bin/sendmail#. Sinon, votre nouveau logiciel sera mis en service avant d'avoir pu le configurer.

Veuillez vous référer à la documentation de l'agent choisi pour de l'information sur comment configurer le logiciel que vous avez choisi.

=== Désactiver sendmail

La procédure utilisée pour lancer sendmail a changé de façon significative entre la 4.5-RELEASE et la 4.6-RELEASE. Par conséquent, la procédure utilisée pour la désactiver est légèrement différente.

==== FreeBSD 4.5-STABLE d'avant le 2002/4/4 et plus ancienne (y compris 4.5-RELEASE et précédentes)

Ajoutez:

[.programlisting]
....
sendmail_enable="NO"
....

dans [.filename]#/etc/rc.conf#. Cela désactivera le service de courrier entrant de sendmail mais si [.filename]#/etc/mail/mailer.conf# (voir plus bas) n'est pas modifié, sendmail sera toujours utilisé pour envoyer du courrier électronique.

==== FreeBSD 4.5-STABLE d'après le 2002/4/4 (y compris 4.6-RELEASE et suivantes)

Afin de complètement désactiver sendmail vous devez utiliser

[.programlisting]
....
sendmail_enable="NONE"
....

dans [.filename]#/etc/rc.conf.#

[WARNING]
====

Si vous désactivez le service d'envoi de courrier de sendmail de cette manière, il est important que vous le remplaciez par un système de courrier alternatif fonctionnant parfaitement. Si vous choisissez de ne pas le faire, des fonctions du système comme man:periodic[8] ne seront pas en mesure de délivrer leur résultat par courrier électronique comme elles s'attendent normalement à le faire. De nombreux composants de votre système s'attendent à avoir un système compatible à sendmail en fonctionnement. Si des applications continuent à utiliser les binaires de sendmail pour essayer d'envoyer du courrier électronique après la désactivation, le courrier pourra aller dans une file d'attente inactive, et pourra n'être jamais livré.
====

Si vous voulez uniquement désactiver le service de réception de courrier de sendmail vous devriez fixer

[.programlisting]
....
sendmail_enable="NO"
....

dans [.filename]#/etc/rc.conf#. Plus d'information sur les options de démarrage de sendmail est disponible à partir de la page de manuel de man:rc.sendmail[8].

=== Lancement de votre nouvel agent au démarrage

Vous pourrez avoir le choix entre deux méthodes pour lancer votre nouvel agent au démarrage, encore une fois en fonction de la version de FreeBSD dont vous disposez.

==== FreeBSD 4.5-STABLE d'avant le 2002/4/11 (y compris 4.5-RELEASE et précédentes)

Ajouter une procédure dans [.filename]#/usr/local/etc/rc.d/# qui se termine en [.filename]#.sh# et qui est exécutable par `root`. La procédure devrait accepter les paramètres `start` et `stop`. Au moment du démarrage les procédures système exécuteront la commande

[.programlisting]
....
/usr/local/etc/rc.d/supermailer.sh start
....

que vous pouvez également utiliser pour démarrer le serveur. Au moment de l'arrêt du système, les procédures système utiliseront l'option `stop` en exécutant la commande

[.programlisting]
....
/usr/local/etc/rc.d/supermailer.sh stop
....

que vous pouvez également utiliser manuellement pour arrêter le serveur quand le système est en fonctionnement.

==== FreeBSD 4.5-STABLE d'après le 2002/4/11 (y compris 4.6-RELEASE et suivantes)

Avec les versions suivantes de FreeBSD, vous pouvez utiliser la méthode ci-dessus ou fixer

[.programlisting]
....
mta_start_script="nomfichier"
....

dans [.filename]#/etc/rc.conf#, où _nomfichier_ est le nom d'une procédure que vous voulez exécuter au démarrage pour lancer votre agent.

=== Remplacer sendmail comme gestionnaire du courrier du système par défaut

Le programme sendmail est tellement omniprésent comme logiciel standard sur les systèmes UNIX(R) que certains programmes supposent qu'il est tout simplement déjà installé et configuré. Pour cette raison, de nombreux agents alternatifs fournissent leur propre implémentation compatible avec l'interface en ligne de commande de sendmail; cela facilite leur utilisation comme remplaçant pour sendmail.

Donc, si vous utilisez un programme alternatif, vous devrez vérifier que le logiciel essayant d'exécuter les binaires standards de sendmail comme [.filename]#/usr/bin/sendmail# exécute réellement l'agent que vous avez choisi à la place. Heureusement, FreeBSD fournit un système appelé man:mailwrapper[8] qui remplit ce travail pour vous.

Quand sendmail fonctionne tel qu'il a été installé, vous trouverez quelque chose comme ce qui suit dans [.filename]#/etc/mail/mailer.conf#:

[.programlisting]
....
sendmail	 /usr/libexec/sendmail/sendmail
send-mail	/usr/libexec/sendmail/sendmail
mailq		/usr/libexec/sendmail/sendmail
newaliases	/usr/libexec/sendmail/sendmail
hoststat	/usr/libexec/sendmail/sendmail
purgestat	/usr/libexec/sendmail/sendmail
....

Cela signifie que lorsque l'une des commandes courantes (comme [.filename]#sendmail# lui-même) est lancée, le système invoque en fait une copie de "mailwrapper" appelée [.filename]#sendmail#, qui lit [.filename]#mailer.conf# et exécute [.filename]#/usr/libexec/sendmail/sendmail# à la place. Ce système rend aisé le changement des binaires qui sont réellement exécutés quand les fonctions de [.filename]#sendmail# par défaut sont invoquées.

Donc si vous avez voulu que [.filename]#/usr/local/supermailer/bin/sendmail-compat# soit lancé en place de sendmail, vous pourrez modifier [.filename]#/etc/mail/mailer.conf# de cette façon:

[.programlisting]
....
sendmail	 /usr/local/supermailer/bin/sendmail-compat
send-mail	/usr/local/supermailer/bin/sendmail-compat
mailq		/usr/local/supermailer/bin/mailq-compat
newaliases	/usr/local/supermailer/bin/newaliases-compat
hoststat	/usr/local/supermailer/bin/hoststat-compat
purgestat	/usr/local/supermailer/bin/purgestat-compat
....

=== Pour en terminer

Une fois que vous avez tout configuré de la façon dont vous le désirez, vous devriez soit tuer les processus de sendmail dont vous n'avez plus besoin et lancer les processus appartenant à votre nouveau logiciel, ou tout simplement redémarrer. Le redémarrage vous donnera l'opportunité de vous assurer que vous avez correctement configuré votre système pour le lancement automatique de votre nouvel agent au démarrage.

[[mail-trouble]]
== Dépannage

=== Pourquoi faut-il que j'utilise le FQDN ("Fully Qualified Domain Name" - nom complet de machine) pour les machines de mon site?

Vous vous rendrez probablement compte que la machine est en fait dans un domaine différent; par exemple, si vous êtes dans le domaine `foo.bar.edu` et que vous voulez atteindre la machine `mumble` du domaine `bar.edu`, vous devrez utiliser son nom de machine complet, `mumble.bar.edu`, au lieu de juste `mumble`.

C'était traditionnellement autorisé par les résolveurs BIND BSD. Néanmoins, la version de BIND qui est maintenant livrée avec FreeBSD ne sait pas compléter les noms de machines abrégés autrement qu'avec le nom de votre domaine. Donc le nom non qualifié `mumble` doit correspondre à `mumble.foo.bar.edu`, sans quoi il sera recherché dans le domaine racine.

Cela diffère du comportement précédent, où la recherche se prolongeait à `mumble.bar.edu`, puis `mumble.edu`. Consultez la RFC 1535 pour savoir pourquoi cela était considéré comme une mauvaise pratique, voire même un trou de sécurité.

Comme solution, vous pouvez mettre la ligne: 

[.programlisting]
....
search foo.bar.edu bar.edu
....

à la place de: 

[.programlisting]
....
domain foo.bar.edu
....

dans votre fichier [.filename]#/etc/resolv.conf#. Cependant, assurez-vous que la recherche ne franchit pas la "limite entre l'administration locale et publique", selon l'expression de la RFC 1535.

=== sendmail affiche le message mail loops back to myself

La réponse donnée dans la FAQ de sendmail est la suivante:

[.programlisting]
....
J'obtiens les messages d'erreur suivant:

553 MX list for domain.net points back to relay.domain.net
554 user@domain.net... Local configuration error

Comment puis-je résoudre ce problème?

Vous avez demandé que le courrier pour un domaine (e.g., domain.net)
soit transmis à une machine donnée (dans ce cas précis, relay.domain.net)
en utilisant un enregistrement MXMX record
, mais la machine relais ne se
connaît pas elle-même comme domain.net.  Ajoutez domain.net à
/etc/mail/local-host-names [connu sous le nom /etc/sendmail.cw dans les versionsantérieure à 8.10] (si vous utilisez FEATURE(use_cw_file))
ou ajoutez "Cw domain.net" à
/etc/mail/sendmail.cf.
....

La FAQ de sendmail peut être trouvée à l'adresse http://www.sendmail.org/faq/[http://www.sendmail.org/faq/] et sa lecture est recommandée si vous voulez "bidouiller" votre configuration du courrier électronique.

=== Comment puis-je faire tourner un serveur de courrier électronique avec une connexion téléphonique PPP PPP

Vous voulez connecter une machine FreeBSD du réseau local à l'Internet. Cette machine servira de passerelle de courrier électronique pour le réseau local. La connexion PPP n'est pas dédiée.

Il y a au moins deux façons de faire. L'une d'elle est d'utiliser UUCP.

L'autre méthode étant d'obtenir un serveur Internet constamment connecté pour qu'il vous fournisse les services MX pour votre domaine. Par exemple, si le domaine de votre compagnie est `exemple.com` et votre fournisseur d'accès a configuré `exemple.net` pour fournir un MX secondaire pour votre domaine:

[.programlisting]
....
exemple.com.            MX        10      exemple.com.
                      MX        20      exemple.net.
....

Une seule machine devrait être spécifiée comme destinataire final (ajoutez `Cw exemple.com` au fichier [.filename]#/etc/mail/sendmail.cf# de `exemple.com`).

Quand le `sendmail` expéditeur tente de vous délivrer du courrier, il essaiera de se connecter à votre serveur (`exemple.com`) via votre liaison par modem. Ce qui échouera très probablement par dépassement de délai puisque vous n'êtes pas en ligne. Le programme sendmail enverra automatiquement le courrier au site MX secondaire, i.e. votre fournisseur d'accès (`exemple.net`). Le site MX secondaire essayera périodiquement de se connecter à votre machine pour expédier le courrier au site MX primaire (`exemple.com`).

Vous pourrez vouloir utiliser quelque chose comme ceci comme procédure de connexion:

[.programlisting]
....
#!/bin/sh
# Mettez-moi dans /usr/local/bin/pppmyisp
( sleep 60 ; /usr/sbin/sendmail -q ) 
/usr/sbin/ppp -direct pppmyisp
....

Si vous avez l'intention de définir une procédure de connexion particulière pour un utilisateur, vous pourrez utiliser `sendmail -qRexemple.com` à la place de la procédure ci-dessus. Cela forcera le traitement immédiat de tout le courrier dans votre file d'attente pour `exemple.com`.

On peut encore affiner la configuration comme suit:

Message emprunté à la {freebsd-isp}.

[.programlisting]
....
 Nous fournissons un MX secondaire à un
client.  Le client se connecte
 à notre service automatiquement plusieurs fois par jour pour acheminer
 le courrier sur son MX primaire (nous n'appelons pas son site lorsque
 du courrier pour ses domaines arrive).  Notre sendmail envoie le courrier de la
 file d'attente toutes les demi-heures.  Pour l'instant, il doit rester
 une demi-heure en ligne pour être sûr que tout le courrier soit
 arrivé au MX primaire.

 Y-a-t-il une commande qui permette de dire à sendmail d'envoyer
 sur-le-champ tout le courrier? L'utilisateur n'a évidemment pas
 les droits super-utilisateur sur la machine.

Dans la section "privacy flags" (indicateurs de
confidentialité) de sendmail.cf, il y a la définition Opgoaway,restrictqrun

Supprimer restrictqrun permet à d'autres utilisateurs que le
super-utilisateur de lancer le traitement de la file d'attente.  Vous
pouvez aussi redéfinir les MXs.  Nous sommes le premier MX pour les
utilisateurs de ce type, et nous avons défini:

# Si nous sommes le meilleur MX pour une machine, essayer directement
# au lieu d'émettre des messages d'erreur de configuration locale.
OwTrue

De cette façon, un site distant vous enverra directement le courrier,
sans essayer de se connecter chez votre client.  Vous le lui
transmettez ensuite.  Cela ne marche qu'avec les "machines",
votre client doit nommer son serveur de courrier
"client.com" aussi bien que
"machine.client.com" dans le DNS.  Mettez seulement un
enregistrement A pour "client.com".
....

=== Pourquoi j'obtiens le message d'erreur Relaying Denied à chaque fois que j'envoie du courrier à partir d'autres machines?

Dans l'installation par défaut de FreeBSD, sendmail est configuré pour envoyer du courrier uniquement à partir de la machine sur laquelle il tourne. Par exemple, si un serveur POP est disponible, alors les utilisateurs pourront retirer leur courrier depuis l'école, le travail, ou toute autre machine distante mais ils ne seront toujours pas en mesure d'envoyer du courrier électronique à partir de machines extérieures. Généralement, quelques instants après une tentative, un courrier électronique sera envoyé par le MAILER-DAEMON avec un message `5.7 Relaying Denied`.

Il y a plusieurs façons d'y remédier. La solution la plus directe est de mettre l'adresse de votre fournisseur d'accès dans un fichier de domaine à relayer [.filename]#/etc/mail/relay-domains#. Une façon rapide de le faire serait:

[source,shell]
....
# echo "votre.fai.exemple.com" > /etc/mail/relay-domains
....

Après avoir créé ou édité ce fichier vous devez redémarrer sendmail. Cela fonctionne parfaitement si vous êtes l'administrateur d'un serveur et vous ne désirez pas envoyer de courrier localement, ou que vous désiriez utiliser un système ou un client "clic-bouton" sur une autre machine ou un autre FAI. C'est également très utile si vous avez uniquement qu'un ou deux comptes de courrier électronique configurés. S'il y a un grand nombre d'adresses à ajouter, vous pouvez tout simplement ouvrir ce fichier dans votre éditeur de texte favori et ensuite ajouter les domaines, un par ligne:

[.programlisting]
....
votre.fai.exemple.com
autre.fai.exemple.net
utilisateurs-fai.exemple.org
www.exemple.org
....

Désormais tout courrier envoyé vers votre système, par n'importe quelle machine de cette liste (en supposant que l'utilisateur possède un compte sur votre système), sera accepté. C'est un bon moyen d'autoriser aux utilisateurs d'envoyer du courrier électronique à distance depuis votre système sans autoriser l'utilisation de votre système pour l'envoi de courrier électronique non sollicité (SPAM).

[[mail-advanced]]
== Sujets avancés

LA fonction suivante couvre des sujets plus avancés comme la configuration du courrier électronique pour l'intégralité de votre domaine.

[[mail-config]]
=== Basic Configuration

Sans aucune configuration, vous devrez être en mesure d'envoyer du courrier électronique à des machines extérieures à partir du moment où vous avez configuré [.filename]#/etc/resolv.conf# ou que vous avez votre propre serveur de noms. Si vous désirez que le courrier pour votre machine soit délivré au serveur de courrier (e.g., sendmail) sur votre propre machine FreeBSD, il y a deux méthodes:

* Faites tourner votre propre serveur de noms et possédez votre propre domaine. Par exemple `FreeBSD.org`
* Faire délivrer le courrier directement sur votre machine. Cela est possible en délivrant directement le courrier à la machine sur lequel pointe le DNS pour le courrier qui vous est destiné. Par exemple `exemple.FreeBSD.org`.

Indépendamment de la méthode que vous choisissez, afin d'avoir le courrier délivré directement à votre machine, elle doit avoir une adresse IP statique permanente (et non pas une adresse dynamique, comme avec la plupart des connexions PPP par modem). Si vous êtes derrière un coupe-feu, il doit autoriser le trafic SMTP en votre direction. Si vous voulez recevoir directement le courrier sur votre machine, vous devez être sûrs de l'une de ces deux choses:

* Assurez-vous que l'enregistrement MX (le nombre le plus bas) de votre DNS pointe sur l'adresse IP de votre machine.
* Assurez-vous qu'il n'y a pas d'entrée MX pour votre machine dans votre DNS.

Une des deux conditions précédentes vous permettra de recevoir directement le courrier pour votre machine.

Essayez:

[source,shell]
....
# hostname
exemple.FreeBSD.org
# host exemple.FreeBSD.org
exemple.FreeBSD.org has address 204.216.27.XX
....

Si c'est la réponse que vous obtenez, le courrier adressé à mailto:votreindentifiant@exemple.FreeBSD.org[votreindentifiant@exemple.FreeBSD.org] arrivera sans problème (en supposant que sendmail fonctionne correctement sur `exemple.FreeBSD.org`).

Si au lieu de cela vous obtenez quelque chose de similaire à ceci:

[source,shell]
....
# host exemple.FreeBSD.org
exemple.FreeBSD.org has address 204.216.27.XX
exemple.FreeBSD.org mail is handled (pri=10) by hub.FreeBSD.org
....

Tout le courrier adressé à votre machine (`exemple.FreeBSD.org`) arrivera sur `hub` adressé au même utilisateur au lieu d'être directement envoyé à votre machine.

L'information précédente est gérée par votre serveur DNS. L'enregistrement du DNS qui contient l'information de routage de courrier est l'entrée MX (_M_ail e_X_change). S'il n'y pas d'enregistrement MX, le courrier sera directement envoyé à la machine en utilisant son adresse IP.

Voici ce que fut à un moment donné l'entrée MX pour `freefall.FreeBSD.org`:

[.programlisting]
....
freefall		MX	30	mail.crl.net
freefall		MX	40	agora.rdrop.com
freefall		MX	10	freefall.FreeBSD.org
freefall		MX	20	who.cdrom.com
....

Comme vous pouvez le voir, `freefall` avait plusieurs entrées MX. L'entrée MX dont le numéro est le plus bas est la machine qui reçoit directement le courrier si elle est disponible; si elle n'est pas accessible pour diverses raisons, les autres (parfois appelées "MX de secours") acceptent temporairement les messages, et les transmettent à une machine de numéro plus faible quand elle devient disponible, et par la suite à la machine de numéro le plus bas.

Les sites MX alternatifs devraient avoir une connexion Internet séparée de la votre afin d'être les plus utiles. Votre fournisseur d'accès ou tout autre site amical ne devrait pas avoir de problème pour vous fournir ce service.

[[mail-domain]]
=== Courrier pour votre domaine

Pour configurer un serveur de courrier vous devez faire en sorte que tout le courrier à destination des diverses stations de travail lui soit envoyé. Concrètement, vous voulez "revendiquer" tout courrier pour n'importe quelle machine de votre domaine (dans ce cas `*.FreeBSD.org`) et le détourner vers votre serveur de courrier de sorte que vos utilisateurs puissent recevoir leur courrier sur le serveur de courrier principal.

Pour rendre les choses plus aisées, un compte utilisateur avec le même _nom d'utilisateur_ devrait exister sur les deux machines. Utilisez man:adduser[8] pour ce faire.

Le serveur de courrier que vous utiliserez sera défini comme "mail exchanger" pour chaque station de travail du réseau. Cela est fait dans votre configuration de DNS de cette manière:

[.programlisting]
....
exemple.FreeBSD.org	A	204.216.27.XX		; Station de travail
			MX	10 hub.FreeBSD.org	; Serveur de courrier
....

Cela redirigera le courrier pour votre station de travail au serveur de courrier quelque soit la machine sur laquelle pointe l'enregistrement A. Le courrier est envoyé sur la machine MX.

Vous ne pouvez le faire vous-même que si vous gérez un serveur de noms. Si ce n'est pas le cas, ou que vous ne pouvez avoir votre propre serveur DNS, parlez-en à votre fournisseur d'accès ou à celui qui fournit votre DNS.

Si vous faites de l'hébergement virtuel du courrier électronique, l'information suivante sera utile. Pour cet exemple, nous supposerons que vous avez un client qui possède son propre domaine, dans notre cas `client1.org`, et vous voulez que tout le courrier pour `client1.org` arrive sur votre serveur de courrier, `mail.mamachine.com`. L'entrée dans votre DNS devrait ressembler à ceci:

[.programlisting]
....
client1.org		MX	10	mail.mamachine.com
....

Vous n'avez _pas_ besoin d'un enregistrement A pour `client1.org` si vous ne voulez gérer que le courrier pour ce domaine.

[NOTE]
====
Soyez conscient que "pinger" `client1.org` ne fonctionnera pas à moins qu'un enregistrement A existe pour cette machine.
====

La dernière chose que vous devez faire est d'indiquer à sendmail sur le serveur de courrier quels sont les domaines et/ou machines pour lesquels il devrait accepter du courrier. Il y a peu de façons différentes de le faire. L'une des deux méthodes suivantes devrait fonctionner:

* Ajoutez les machines à votre fichier [.filename]#/etc/mail/local-host-names# si vous utilisez la fonction `FEATURE(use_cw_file)`. Si vous utilisez une version de sendmail antérieure à la version 8.10, le fichier sera [.filename]#/etc/sendmail.cw#.
* Ajoutez une ligne `Cwyour.host.com` à votre fichier [.filename]#/etc/sendmail.cf# ou [.filename]#/etc/mail/sendmail.cf# si vous utilisez sendmail 8.10 ou supérieur.

[[SMTP-UUCP]]
== SMTP avec UUCP

La configuration de sendmail fournie avec FreeBSD est conçue pour les sites directement connectés à l'Internet. Les sites désirant échanger leur courrier électronique par l'intermédiaire d'UUCP doivent installer un autre fichier de configuration pour sendmail.

Modifier manuellement le fichier [.filename]#/etc/mail/sendmail.cf# est un sujet réservé aux spécialistes. Dans version 8 de sendmail la génération des fichiers de configuration se fait par l'intermédiaire du processeur man:m4[1], où la configuration se fait à un haut niveau d'abstraction. Les fichiers de configuration man:m4[1] se trouvent dans le répertoire [.filename]#/usr/src/usr.sbin/sendmail/cf#.

Si vous n'avez pas installé toutes les sources du système, l'ensemble des fichiers de configuration de sendmail a été regroupé dans une archive séparée des autres sources. En supposant que vous avez monté votre CDROM FreeBSD contenant les sources, faites:

[source,shell]
....
# cd /cdrom/src
# cat scontrib.?? | tar xzf - -C /usr/src/contrib/sendmail
....

Cette extraction ne donne lieu qu'à une centaine de kilo-octets. Le fichier [.filename]#README# dans le répertoire [.filename]#cf# pourra faire office d'une introduction à la configuration man:m4[1].

La meilleure façon d'ajouter le support UUCP est d'utiliser la fonctionnalité `mailertable`. Cela créé une base de données que sendmail utilise pour décider de la manière dont il va router le courrier électronique.

Tout d'abord, vous devez créer votre fichier [.filename]#.mc#. Le répertoire [.filename]#/usr/src/usr.sbin/sendmail/cf/cf# contient quelques exemples. En supposant que vous avez appelé votre fichier [.filename]#foo.mc#, tout ce dont vous avez besoin de faire pour le convertir en un fichier [.filename]#sendmail.cf# valide est:

[source,shell]
....
# cd /usr/src/usr.sbin/sendmail/cf/cf
# make foo.cf
# cp foo.cf /etc/mail/sendmail.cf
....

Un fichier [.filename]#.mc# classique devrait ressembler à ceci:

[.programlisting]
....
VERSIONID(`Votre numéro de version') OSTYPE(bsd4.4)

FEATURE(accept_unresolvable_domains)
FEATURE(nocanonify)
FEATURE(mailertable, `hash -o /etc/mail/mailertable')

define(`UUCP_RELAY', votre.relai.uucp)
define(`UUCP_MAX_SIZE', 200000)
define(`confDONT_PROBE_INTERFACES')

MAILER(local)
MAILER(smtp)
MAILER(uucp)

Cw    alias.de.votre.nom.de.machine
Cw    votrenomdenoeuduucp.UUCP
....

Les lignes contenant les directives `accept_unresolvable_domains`, `nocanonify`, et `confDONT_PROBE_INTERFACES` empêcheront l'utilisation du DNS lors de l'envoi du courrier électronique. La directive `UUCP_RELAY` est nécessaire pour le support de l'UUCP. Mettez juste un nom de machine Internet capable de gérer des adresses d'un pseudo-domaine .UUCP; la plupart du temps, vous mettrez le nom du serveur de messagerie de votre fournisseur d'accès.

Après avoir défini tout ceci, vous avez besoin d'un fichier [.filename]#/etc/mail/mailertable#. Si vous n'avez qu'un seul lien avec l'extérieur qui est utilisé pour votre courrier électronique, le fichier suivant devrait suffire:

[.programlisting]
....
#
# makemap hash /etc/mail/mailertable.db  /etc/mail/mailertable
.                             uucp-dom:your.uucp.relay
....

Un exemple plus complexe ressemblerait à ceci:

[.programlisting]
....
#
# makemap hash /etc/mail/mailertable.db  /etc/mail/mailertable
#
horus.interface-business.de   uucp-dom:horus
.interface-business.de        uucp-dom:if-bus
interface-business.de         uucp-dom:if-bus
.heep.sax.de                  smtp8:%1
horus.UUCP                    uucp-dom:horus
if-bus.UUCP                   uucp-dom:if-bus
.                             uucp-dom:
....

Les trois premières lignes gèrent les cas spécifiques où les courriers électroniques pour l'extérieur ne devraient pas être envoyés au serveur par défaut, mais plutôt à des serveurs UUCP voisins afin de "raccourcir" le chemin à parcourir. La ligne suivante gère le courrier électronique destiné au domaine Ethernet local et qui peut être distribué en utilisant le protocole SMTP. Et enfin, les voisins UUCP sont mentionnés dans la notation de pseudo-domaine UUCP, pour permettre à un courrier du type `voisin-uucp !destinataire` de passer outre les règles par défaut. La dernière ligne doit toujours être un point, ce qui correspond à tout le reste, avec la distribution UUCP vers un voisin UUCP qui sert de passerelle universelle de courrier électronique vers le reste du monde. Tous les noms de noeuds placés après le mot clé `uucp-dom:` doivent être des noms valides de voisins UUCP, que vous pouvez vérifier en utilisant la commande `uuname`.

Pour vous rappeler que ce fichier doit être converti en un fichier de base de données DBM avant d'être utilisable. La ligne de commande pour accomplir cette conversion est rappelée dans les commentaires au début du fichier [.filename]#mailertable#. Vous devez lancer cette commande à chaque fois que vous modifiez votre fichier [.filename]#mailertable#.

Pour finir: si vous n'êtes pas certain du bon fonctionnement de certaines configurations de routage du courrier électronique, rappelez-vous de l'option `-bt` de sendmail. Cela lance sendmail dans le _mode test d'adresse_; entrez simplement `3,0`, suivi de l'adresse que vous désirez tester. La dernière ligne vous indiquera le type d'agent utilisé pour l'envoi, la machine de destination à laquelle l'agent doit envoyer le message, et l'adresse (peut-être traduite) à laquelle il l'enverra. Pour quitter ce mode tapez kbd:[Ctrl+D].

[source,shell]
....
% sendmail -bt
ADDRESS TEST MODE (ruleset 3 NOT automatically invoked)
Enter <ruleset> <address>
> 3,0 foo@example.com
canonify           input: foo @ example . com
...
parse            returns: $# uucp-dom $@ your.uucp.relay $: foo < @ example . com . >
> ^D
....

[[outgoing-only]]
== Configuration pour l'envoi seul

Il existe de nombreux cas où vous désirez être capable d'uniquement envoyer du courrier électronique par l'intermédiaire d'un relais. Quelques exemples:

* Votre ordinateur est une machine de bureau, mais vous voulez utilisez des programmes comme man:send-pr[1]. Pour cela vous devez utiliser le relais de courrier électronique de votre FAI.
* L'ordinateur est un serveur qui ne gère pas le courrier électronique localement, mais a besoin de soumettre tout le courrier à un relais pour qu'il soit transmis.

N'importe quel MTA est capable d'assurer cette fonction. Malheureusement, il peut être très compliqué de configurer correctement un MTA complet pour juste gérer le courrier sortant. Des logiciels comme sendmail et postfix sont largement surdimensionnés pour cette utilisation.

De plus, si vous utilisez un accès Internet classique, votre contrat peut vous interdire de faire tourner un "serveur de courrier électronique".

La manière la plus simple pour répondre à ce besoin est d'installer le logiciel porté package:mail/ssmtp[]. Exécutez les commandes suivantes en tant que `root`:

[source,shell]
....
# cd /usr/ports/mail/ssmtp
# make install replace clean
....

Une fois installé, package:mail/ssmtp[] peut être configuré avec un fichier de quatre lignes, [.filename]#/usr/local/etc/ssmtp/ssmtp.conf#:

[.programlisting]
....
root=yourrealemail@example.com
mailhub=mail.example.com
rewriteDomain=example.com
hostname=_HOSTNAME_
....

Assurez-vous d'employer votre adresse électronique réelle pour l'utilisateur `root`. Utilisez le relais de courrier électronique sortant de votre FAI à la place de `mail.example.com` (certains FAIs appellent cela le "serveur de courrier sortant" ou le "serveur SMTP").

Assurez-vous également d'avoir désactivé sendmail en fixant `sendmail_enable="NONE"` dans le fichier [.filename]#/etc/rc.conf#.

package:mail/ssmtp[] dispose d'autres options. Consultez le fichier de configuration d'exemple dans le répertoire [.filename]#/usr/local/etc/ssmtp# ou la page de manuel de ssmtp pour quelques exemples et plus d'informations.

Configurer ssmtp de cette manière permettra à toute application tournant sur votre ordinateur et ayant besoin d'envoyer un courrier électronique de fonctionner correctement, tout en n'outrepassant pas la politique de votre FAI ou en ne permettant pas l'utilisation de votre ordinateur comme base arrière pour "spammers".

[[SMTP-dialup]]
== Utiliser le courrier électronique avec une connexion temporaire

Si vous disposez d'une adresse IP statique, vous ne devez rien changer du paramétrage par défaut. Définissez votre nom de machine pour qu'il corresponde à celui qui vous a été assigné pour l'Internet et sendmail s'occupera du reste.

Si votre adresse IP vous est attribuée dynamiquement et que vous utilisez une connexion PPP par modem pour accèder à l'Internet, vous disposez probablement d'une boite aux lettres chez votre fournisseur d'accès. Supposons que le domaine de votre fournisseur d'accès soit `example.net`, que votre nom d'utilisateur soit `user`, que vous avez appelé votre machine `bsd.home`, et que votre fournisseur vous ait demandé d'utiliser la machine `relay.example.net` comme serveur relai de messagerie électronique.

Pour pouvoir rapatrier votre courrier depuis votre boite aux lettres, vous devez installer un agent de rapatriement. L'utilitaire fetchmail est un bon choix car il supporte la plupart des protocoles de messagerie. Ce programme est disponible sous forme de paquetage ou à partir du catalogue des logiciels portés (package:mail/fetchmail[]). La plupart du temps, votre fournisseur d'accès fournit l'accès aux boites aux lettre à l'aide du protocole POP. Si vous utilisez PPP en mode utilisateur, vous pouvez automatiquement récupérer votre courrier quand une connexion Internet est établie avec l'entrée suivante dans le fichier [.filename]#/etc/ppp/ppp.linkup#:

[.programlisting]
....
MYADDR:
!bg su user -c fetchmail
....

Si vous utilisez sendmail (comme montré ci-dessous) pour distribuer le courrier aux comptes non-locaux, vous voudrez probablement que sendmail s'occupe de transmettre les messages en attente dès que votre connexion Internet est établie. Pour cela, ajoutez la commande suivante après la commande `fetchmail` dans le fichier [.filename]#/etc/ppp/ppp.linkup#:

[.programlisting]
....
!bg su user -c "sendmail -q"
....

En supposant que vous avez un compte `user` sur `bsd.home`. Dans le répertoire de l'utilisateur `user` sur `bsd.home`, créez un fichier [.filename]#.fetchmailrc# contenant:

[.programlisting]
....
poll example.net protocol pop3 fetchall pass MySecret
....

Ce fichier ne devrait être lisible que par l'utilisateur `user` car il contient le mot de passe `MySecret`.

Afin de pouvoir envoyer du courrier avec l'entête `from:` correcte, vous devez configurer sendmail pour utiliser l'adresse `user@example.net` plutôt que `user@bsd.home`. Vous pouvez également dire à sendmail d'envoyer le courrier via le serveur `relay.example.net`, permettant une transmission du courrier plus rapide.

Le fichier [.filename]#.mc# suivant devrait suffire:

[.programlisting]
....
VERSIONID(`bsd.home.mc version 1.0')
OSTYPE(bsd4.4)dnl
FEATURE(nouucp)dnl
MAILER(local)dnl
MAILER(smtp)dnl
Cwlocalhost
Cwbsd.home
MASQUERADE_AS(`example.net')dnl
FEATURE(allmasquerade)dnl
FEATURE(masquerade_envelope)dnl
FEATURE(nocanonify)dnl
FEATURE(nodns)dnl
define(`SMART_HOST', `relay.example.net')
Dmbsd.home
define(`confDOMAIN_NAME',`bsd.home')dnl
define(`confDELIVERY_MODE',`deferred')dnl
....

Référez-vous à la section précédente pour des détails sur la conversion de ce fichier [.filename]#.mc# en un fichier [.filename]#sendmail.cf#. N'oubliez pas également de redémarrer sendmail après la mise à jour du fichier [.filename]#sendmail.cf#.

[[SMTP-Auth]]
== Authentification SMTP

Disposer de l'authentification SMTP sur votre serveur de courrier présente un certain nombre d'avantages. L'authentification SMTP peut ajouter une autre couche de sécurité à sendmail, et a l'avantage de donner aux utilisateurs mobiles la possibilité d'utiliser le même serveur de courrier sans avoir besoin de reconfigurer les paramètres de leur client courrier à chaque déplacement.

[.procedure]
====

. Installez package:security/cyrus-sasl[] à partir du catalogue des logiciels portés. Vous pouvez trouver ce logiciel porté dans package:security/cyrus-sasl[]. package:security/cyrus-sasl[] dispose de nombreuses options de compilation possibles, pour la méthode que nous allons utiliser ici, assurez-vous de sélectionner l'option `pwcheck`.
. Après avoir installé package:security/cyrus-sasl[], éditez [.filename]#/usr/local/lib/sasl/Sendmail.conf# (ou créez-le s'il n'existe pas) et ajoutez la ligne suivante:
+
[.programlisting]
....
pwcheck_method: passwd
....
+ 
Cette méthode activera au niveau de sendmail l'authentification par l'intermédiaire de votre base de données FreeBSD [.filename]#passwd#. Cela nous épargne le problème de la création d'un nouvel ensemble de nom d'utilisateur et de mot de passe pour chaque utilisateur ayant besoin de recourir à l'authentification SMTP, et conserve le même nom d'utilisateur et mot de passe pour le courrier.
. Maintenant éditez [.filename]#/etc/make.conf# et ajoutez les lignes suivantes:
+
[.programlisting]
....
SENDMAIL_CFLAGS=-I/usr/local/include/sasl1 -DSASL
SENDMAIL_LDFLAGS=-L/usr/local/lib
SENDMAIL_LDADD=-lsasl
....
+ 
Ces lignes passeront à sendmail les bonnes options de configuration au moment de la compilation pour lier package:cyrus-sasl[]. Assurez-vous que package:cyrus-sasl[] a été installé avant de recompiler sendmail.
. Recompilez sendmail en lançant les commandes suivantes:
+
[source,shell]
....
# cd /usr/src/usr.sbin/sendmail
# make cleandir
# make obj
# make
# make install
....
+ 
La compilation de sendmail ne devrait pas présenter de problèmes si le répertoire [.filename]#/usr/src# n'a pas subi d'énormes changements et si les bibliothèques partagés nécessaires sont disponibles.
. Une fois que sendmail a été compilé et réinstallé, éditez votre fichier [.filename]#/etc/mail/freebsd.mc# (ou tout autre fichier que vous utilisez comme fichier [.filename]#.mc#. De nombreux administrateurs utilisent la sortie de man:hostname[1] comme nom de fichier [.filename]#.mc# par unicité). Ajoutez-y les lignes qui suivents:
+
[.programlisting]
....
dnl set SASL options
TRUST_AUTH_MECH(`GSSAPI DIGEST-MD5 CRAM-MD5 LOGIN')dnl
define(`confAUTH_MECHANISMS', `GSSAPI DIGEST-MD5 CRAM-MD5 LOGIN')dnl
define(`confDEF_AUTH_INFO', `/etc/mail/auth-info')dnl
....
+ 
Ces options configurent les différentes méthodes disponibles pour sendmail pour l'authentification des utilisateurs. Si vous désirez utiliser une méthode autre que pwcheck, veuillez consulter la documentation fournie.
. Enfin, exécutez man:make[1] quand vous êtes dans [.filename]#/etc/mail#. Cela prendra votre nouveau fichier [.filename]#.mc# et créera un fichier [.filename]#.cf# appelé [.filename]#freebsd.cf# (ou selon tout autre nom que vous avez utilisé pour votre fichier [.filename]#.mc#). Ensuite utilisez la commande `make install restart`, qui copiera le fichier en [.filename]#sendmail.cf#, et redémarrera proprement sendmail. Pour plus d'informations sur ce processus, vous devriez vous réferrer au fichier [.filename]#/etc/mail/Makefile#.
====

Si tout s'est bien passé, vous devriez être en mesure d'entrer votre identifiant dans votre programme de courrier et d'envoyer un message de test. Pour plus d'investigation, fixez le `LogLevel` de sendmail à 13 et scrutez [.filename]#/var/log/maillog# à la recherche d'une erreur.

Vous pourrez rajouter les lignes suivantes au fichier [.filename]#/etc/rc.conf# afin de rendre ce service disponible après chaque démarrage du système:

[.programlisting]
....
sasl_pwcheck_enable="YES"
sasl_pwcheck_program="/usr/local/sbin/pwcheck"
....

Cela assurera l'initialisation de SMTP_AUTH, l'authentification SMTP, au démarrage du système.

Pour plus d'informations, veuillez consulter la page de la documentation de sendmail concernant http://www.sendmail.org/~ca/email/auth.html[ l'authentification SMTP].

[[mail-agents]]
== Clients de messagerie

Un client de messagerie ("Mail User Agent"-MUA) est une application qui est utilisée pour envoyer et recevoir du courrier électronique. En outre, au fur et à mesure que le système du courrier électronique "évolue" et devient plus complexe, les MUA deviennent de plus en plus puissants, offrant aux utilisateurs plus de fonctionnalités et de flexibilité. FreeBSD offre le support pour de nombreux clients de messagerie, ils peuvent tous être aisément installés à partir du crossref:ports[ports,catalogue des logiciels portés de FreeBSD]. Les utilisateurs pourront choisir entre des clients de messagerie graphiques comme evolution ou balsa, des clients en mode console tels que mutt, pine ou `mail`, ou encore les interfaces Web utilisées par certaines organisations importantes.

[[mail-command]]
=== mail

man:mail[1] est le client de messagerie ("Mail User Agent"-MUA) par défaut de FreeBSD. C'est un MUA en mode console qui offre toutes les fonctionnalités de base nécessaires pour envoyer et lire son courrier électronique en mode texte, cependant il est limité en ce qui concerne les possibilités de pièces jointes et ne supporte que les boîtes aux lettres locales.

Bien que `mail` ne supporte pas l'intéraction avec les serveurs POP ou IMAP, ces boîtes aux lettres peuvent être téléchargées vers un fichier [.filename]#mbox# local en utilisant une application telle que fetchmail, qui sera abordée plus tard dans ce chapitre (<<mail-fetchmail>>).

Afin d'envoyer et de recevoir du courrier électronique, invoquez simplement la commande `mail` comme le montre l'exemple suivant:

[source,shell]
....
% mail
....

Le contenu de la boîte aux lettres de l'utilisateur dans [.filename]#/var/mail# est automatiquement lu par l'utilitaire `mail`. Si la boîte est vide, l'utilitaire rend la main avec un message indiquant qu'aucun courrier électronique ne peut être trouvé. Une fois que la boîte aux lettres a été lue, l'interface de l'application est lancée, et une liste de messages sera affichée. Les messages sont automatiquement numérotés, comme on peut le voir dans l'exemple suivant:

[source,shell]
....
Mail version 8.1 6/6/93.  Type ? for help.
"/var/mail/marcs": 3 messages 3 new
>N  1 root@localhost        Mon Mar  8 14:05  14/510   "test"
 N  2 root@localhost        Mon Mar  8 14:05  14/509   "user account"
 N  3 root@localhost        Mon Mar  8 14:05  14/509   "sample"
....

Les messages peuvent désormais être lus en utilisant la commande kbd:[t] de `mail`, suivie du numéro du message qui devra être affiché. Dans cet exemple, nous lirons le premier courrier électronique:

[source,shell]
....
% t 1
Message 1:
From root@localhost  Mon Mar  8 14:05:52 2004
X-Original-To: marcs@localhost
Delivered-To: marcs@localhost
To: marcs@localhost
Subject: test
Date: Mon,  8 Mar 2004 14:05:52 +0200 (SAST)
From: root@localhost (Charlie Root)

This is a test message, please reply if you receive it.
....

Comme nous pouvons le constater dans l'exemple ci-dessus, l'appuie sur la touche kbd:[t] fera afficher le message avec les entêtes complètes. Pour afficher à nouveau la liste des messages, la touche kbd:[h] doit être utilisée.

Si le message nécessite une réponse, vous pouvez utiliser `mail` pour cela, en entrant soit la touche kbd:[R], soit la touche kbd:[r]. La touche kbd:[R] demande à `mail` de ne répondre qu'à l'expéditeur du message, alors que kbd:[r] répond à l'expéditeur mais également aux autres destinataires du message. Vous pouvez ajouter à la suite de ces commandes le numéro du courrier auquel vous désirez répondre. Une fois cela effectué, la réponse doit être tapée, et la fin du message doit être indiquée par un kbd:[.] sur une nouvelle ligne. Ci-dessous est présenté un exemple:

[source,shell]
....
% R 1
To: root@localhost
Subject: Re: test

Thank you, I did get your email.
.
EOT
....

Afin d'envoyer un nouveau courrier électronique, la touche kbd:[m] doit être utilisée, suivie de l'adresse électronique du destinataire. Plusieurs destinataires peuvent également être spécifiés en séparant chaque adresse par une kbd:[,]. Le sujet du message peut alors être entré, suivi du corps du message. La fin d'un message doit être indiquée en mettant un kbd:[.] seul sur une nouvelle ligne.

[source,shell]
....
% mail root@localhost
Subject: I mastered mail

Now I can send and receive email using mail ... :)
.
EOT
....

Bien qu'à partir de l'utilitaire `mail`, la commande kbd:[?] puisse être utilisée à tout instant pour afficher l'aide, la page de manuel man:mail[1] devrait être consultée pour plus d'aide sur `mail`.

[NOTE]
====
Comme indiqué précédemment, la commande man:mail[1] à l'origine n'a pas été conçue pour gérer les pièces jointes, et par conséquent ne s'en sort pas très bien à ce niveau. Les MUAs plus récents comme mutt gérent les pièces jointes de manière plus intelligente. Mais si vous souhaitez toujours utiliser `mail`, le logiciel porté package:converters/mpack[] vous sera d'une grande aide.
====

[[mutt-command]]
=== mutt

mutt est un client de messagerie léger mais très puissant, avec de nombreuses fonctionnalités, parmi lesquelles:

* la possibilité de gérer les fils ("threads") de discussions;
* le support PGP pour la signature électronique et le chiffrage de courriers électroniques;
* le support MIME;
* le support du format maildir;
* application hautement configurable et personnalisable.

Toutes ces caractéristiques font de mutt un des clients de messagerie les plus avancés. Consultez http://www.mutt.org[http://www.mutt.org] pour plus d'informations sur mutt.

La version stable de mutt peut être installée en utilisant le logiciel porté package:mail/mutt[], tandis que la version actuellement en développement peut être installée par l'intermédiaire du logiciel porté package:mail/mutt-devel[]. Une fois installé, mutt peut être lancé en tapant la commande suivante:

[source,shell]
....
% mutt
....

mutt lira automatiquement le contenu de la boîte aux lettres de l'utilisateur dans [.filename]#/var/mail# et en affiche le contenu le cas échéant. Si aucun message n'est trouvé dans cette boîte, alors mutt attendra une commande de l'utilisateur. L'exemple ci-dessous montre mutt affichant une liste de messages:

image::mutt1.png[]

Afin de lire un message, sélectionnez-le en utilisant les touches fléchées, et appuyez sur kbd:[Entrée]. Un exemple montrant mutt affichant le contenu d'un message est donné ci-dessous:

image::mutt2.png[]

Comme avec la commande man:mail[1], mutt permet aux utilisateurs de répondre uniquement à l'expéditeur du message comme également à l'ensemble de ses destinataires. Pour répondre uniquement à l'expéditeur du courrier électronique, utilisez le raccourci clavier kbd:[r]. Pour faire une réponse groupée, qui sera envoyée à l'expéditeur comme à tous les destinataires du message, utilisez la touche kbd:[g].

[NOTE]
====
mutt emploie man:vi[1] comme éditeur pour la création et la réponse aux courriers électronique. Cela peut être modifié par l'utilisateur en créant son propre fichier [.filename]#.muttrc# dans leur répertoire personnel et en positionnant la variable `editor`.
====

Pour rédiger un nouveau message, appuyez sur la touche kbd:[m]. Après avoir donné un sujet valide, mutt lancera man:vi[1] et l'intégralité du message pourra être écrite. Une fois le courrier électronique rédigé, sauvegardez et quittez `vi` et mutt réapparaîtra affichant un écran résumant le courrier devant être envoyé. Pour envoyer le message, appuyez sur kbd:[y]. Un exemple de résumé peut être vu ci-dessous:

image::mutt3.png[]

mutt propose également une aide complète, qui peut être consultée à partir de la plupart des menus en appuyant sur la touche kbd:[?]. La ligne située en haut de l'écran affiche également les raccourcis clavier appropriés.

[[pine-command]]
=== pine

pine est destiné aux débutants, mais il dispose également de fonctions avancées.

[WARNING]
====

Plusieurs vulnérabilités exploitables à distance ont été découvertes dans le logiciel pine par le passé, autorisant à un agresseur distant d'exécuter un programme arbitraire en tant qu'utilisateur local du système, en envoyant un courrier électronique particulier. Tous les problèmes _connus_ ont été corrigés, mais le code source de pine est écrit d'une manière assez peu sécurisée et l'officier de sécurité de FreeBSD pense qu'il existe d'autres failles qui ne sont pas encore découvertes. Vous installez donc pine à vos propres risques.
====

La version actuelle de pine peut être installée en utilisant le logiciel porté package:mail/pine4[]. Une fois installé, pine peut être lancé en tapant la commande suivante:

[source,shell]
....
% pine
....

Lors du premier lancement de pine, ce dernier affiche une page de présentation avec une brève introduction, ainsi qu'un message de la part de l'équipe de développement de pine demandant l'envoi d'un courrier électronique anonyme pour leur permettre d'évaluer le nombre d'utilisateurs de leur client de messagerie. Pour envoyer ce courrier anonyme, appuyez sur kbd:[Entrée], ou sinon appuyez sur kbd:[E] pour quitter la présentation sans envoyer de message anonyme. Un exemple de page de présentation peut être vu ci-dessous:

image::pine1.png[]

Le menu principal est ensuite affiché, menu dans lequel il est aisé de naviguer avec les touches fléchées. Ce menu principal fournit les raccourcis pour la rédaction de nouveaux messages, la navigation dans les répertoires de messages, et même la gestion des entrées du carnet d'adresses. Sous le menu principal, les raccourcis clavier correspondants pour effectuer les différentes tâches sont donnés.

Le répertoire ouvert par défaut par pine est [.filename]#inbox#. Pour afficher l'index des messages, appuyez sur kbd:[I], ou sélectionnez l'option [.guimenuitem]#MESSAGE INDEX# comme montré ci-dessous:

image::pine2.png[]

L'index des messages montre les messages dans le répertoire courant, on peut se déplacer dans l'index en utilisant les touches fléchées. Les messages en surbrillance peuvent être lus en appuyant sur la touche kbd:[Enter].

image::pine3.png[]

Dans la capture d'écran ci-dessous, un message d'exemple est affiché par pine. Les raccourcis clavier sont affichés au bas de l'écran. Un exemple de raccourci est la touche kbd:[r], qui demande au programme de répondre au message actuellement à l'écran.

image::pine4.png[]

La rédaction d'une réponse à un courrier électronique avec pine se fait en utilisant l'éditeur pico, qui est installé par défaut avec pine. L'utilitaire pico rend aisé les déplacements dans le message et est plus indulgent avec les novices que man:vi[1] ou man:mail[1]. Une fois la réponse rédigée, le message peut être envoyé en appuyant sur kbd:[Ctrl+X]. pine vous demandera de confirmer votre action.

image::pine5.png[]

Le programme pine peut être personnalisé en utilisant l'option [.guimenuitem]#SETUP# du menu principal. Consultez http://www.washington.edu/pine/[http://www.washington.edu/pine/] pour plus d'information.

[[mail-fetchmail]]
== Utiliser fetchmail

fetchmail est un client IMAP et POP complet qui offre aux utilisateurs le téléchargement automatiquement de leur courrier électronique à partir de serveurs IMAP et POP distants et sa sauvegarde dans des boîtes aux lettres locales; ainsi, le courrier électronique pourra être consulté plus facilement. fetchmail peut être installé en utilisant le logiciel porté package:mail/fetchmail[], et offre diverses fonctionnalités, dont:

* le support des protocoles POP3, APOP, KPOP, IMAP, ETRN et ODMR;
* la capacité de faire suivre le courrier électronique en utilisant SMTP, ce qui autorise le filtrage, le transfert, et la gestion des alias de fonctionner correctement;
* la possibilité de fonctionner en mode "daemon" pour contrôler périodiquement si il y a de nouveaux messages;
* la possibilité de récupérer le courrier de plusieurs boîtes aux lettres et de le transférer en fonction d'une configuration bien précise aux différents utilisateurs locaux.

Bien qu'expliquer l'intégralité des fonctions de fetchmail dépasse le cadre de ce document, certaines fonctions de base seront abordées. L'utilitaire fetchmail nécessite un fichier de configuration nommé [.filename]#.fetchmailrc#, afin de fonctionner correctement. Ce fichier comprend les informations concernant les serveurs ainsi que les accréditations d'accès. En raison du caractère sensible du contenu de ce fichier, il est recommandé de ne le rendre lisible que par l'utilisateur, avec la commande suivante:

[source,shell]
....
% chmod 600 .fetchmailrc
....

Le fichier [.filename]#.fetchmailrc# suivant sert d'exemple pour récupérer le courrier électronique pour un seul utilisateur à partir d'une boîte aux lettres utilisant le protocole POP. Il demande à fetchmail de se connecter à `example.com` en utilisant le nom d'utilisateur `joesoap` et le mot de passe `XXX`. Dans cet exemple on suppose que l'utilisateur `joesoap` est également un utilisateur sur le système local.

[.programlisting]
....
poll example.com protocol pop3 username "joesoap" password "XXX"
....

L'exemple suivant présente la connexion à plusieurs serveurs POP et IMAP et la redirection vers différents utilisateurs locaux quand c'est nécessaire:

[.programlisting]
....
poll example.com proto pop3:
user "joesoap", with password "XXX", is "jsoap" here;
user "andrea", with password "XXXX";
poll example2.net proto imap:
user "john", with password "XXXXX", is "myth" here;
....

L'utilitaire fetchmail peut être exécuté en mode "daemon" en le lançant avec le paramètre `-d`, suivi par l'intervalle de temps (en secondes) que fetchmail doit respecter entre chaque consultation des serveurs listés dans le fichier [.filename]#.fetchmailrc#. L'exemple suivant demandera à fetchmail de récupérer le courrier toutes les 60 secondes:

[source,shell]
....
% fetchmail -d 60
....

Plus d'informations concernant fetchmail peuvent être trouvées sur http://www.catb.org/\~esr/fetchmail/[http://www.catb.org/~esr/fetchmail/].

[[mail-procmail]]
== Utiliser procmail

L'utilitaire procmail est une application extrêmement puissante utilisée pour filtrer le courrier électronique entrant. Il permet aux utilisateurs de définir des "règles" qui seront utilisées sur le courrier entrant pour effectuer des opérations particulières ou pour transférer le courrier vers d'autres boîtes aux lettres et/ou adresses électroniques. procmail peut être installé en utilisant le logiciel porté package:mail/procmail[]. Une fois installé, il peut être intégré dans la plupart des MTAs, consultez la documentation de votre MTA pour plus d'information. Alternativement, procmail peut être intégré en ajoutant la ligne suivante à un fichier [.filename]#.forward# dans le répertoire personnel de l'utilisateur employant les fonctionnalités de procmail:

[.programlisting]
....
"|exec /usr/local/bin/procmail || exit 75"
....

La suite de cette section présentera quelques règles de base pour procmail, avec une brève description de ce qu'elles font. Ces règles, ainsi que d'autres, doivent être ajoutées dans le fichier [.filename]#.procmailrc#, qui doit résider dans le répertoire personnel de l'utilisateur.

La majorité de ces règles peut également être trouvée dans la page de manuel de man:procmailex[5].

Transférer tout courrier en provenance de `user@example.com` vers l'adresse externe `goodmail@example2.com`:

[.programlisting]
....
:0
* ^From.*user@example.com
! goodmail@example2.com
....

Transférer tous les courriers d'une taille inférieure à 1000 octets vers l'adresse externe `goodmail@example2.com`:

[.programlisting]
....
:0
*  1000
! goodmail@example2.com
....

Mettre tout le courrier à destination de `alternate@example.com` dans une boîte aux lettres appelée [.filename]#alternate#:

[.programlisting]
....
:0
* ^TOalternate@example.com
alternate
....

Envoyer tous les courriers avec pour sujet "Spam" vers [.filename]#/dev/null#:

[.programlisting]
....
:0
^Subject:.*Spam
/dev/null
....

Une recette utile pour trier les courriers en provenance des listes de diffusion `FreeBSD.org` et placer chaque liste dans sa propre boîte aux lettres:

[.programlisting]
....
:0
* ^Sender:.owner-freebsd-\/[^@]+@FreeBSD.ORG
{
	LISTNAME=${MATCH}
	:0
	* LISTNAME??^\/[^@]+
	FreeBSD-${MATCH}
}
....
