---
title: Chapitre 7. Multimédia
part: Partie II. Tâches courantes
prev: books/handbook/desktop
next: books/handbook/kernelconfig
showBookMenu: true
weight: 10
path: "/books/handbook/multimedia/"
---

[[multimedia]]
= Multimédia
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 7
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/multimedia/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[multimedia-synopsis]]
== Synopsis

FreeBSD supporte une grande variété de cartes son, vous permettant d'obtenir un son haute fidélité à partir de votre ordinateur. Ceci inclut la possibilité d'enregistrer et de jouer les formats "MPEG Audio Layer 3" (MP3), WAV et Ogg Vorbis aussi bien que de nombreux autres formats. Le catalogue de logiciels portés de FreeBSD contient également des applications vous permettant d'éditer vos enregistrements, rajouter des effets sonores, et contrôler des périphériques MIDI.

Avec un peu d'expérimentation, FreeBSD pourra lire des fichiers vidéo et des DVDs. Le nombre d'applications pour encoder, convertir, et lire divers supports vidéo est plus limité que le nombre d'applications équivalentes dans le domaine du son. Par exemple au moment de l'écriture de ces lignes, il n'existe pas de bonne application d'encodage dans le catalogue des logiciels portés de FreeBSD, qui pourra être utilisée pour convertir d'un format à un autre, comme peut le faire pour le son le programme package:audio/sox[]. Cependant, le paysage logiciel dans ce domaine évolue rapidement.

Ce chapitre décrira les étapes nécessaires pour configurer votre carte son. La configuration et l'installation d'X11 (crossref:x11[x11,Le système X Window]) ont déjà pris soin des problèmes matériel de votre carte vidéo, bien qu'il puisse y avoir quelques réglages à ajuster pour obtenir une meilleure lecture des vidéos.

Après la lecture de ce chapitre, vous connaîtrez:

* Comment configurer votre système afin que votre carte son soit reconnue.
* Les méthodes pour tester le fonctionnement de votre carte.
* Comment faire face aux problèmes de configuration de votre carte son.
* Comment jouer et encoder des MP3s.
* Comment la vidéo est supportée par X11.
* Quelques logiciels portés qui donnent de bon résultats pour lire/encoder de la vidéo.
* Comment lire des DVDs, des fichiers [.filename]#.mpg# et [.filename]#.avi#.
* Comment extraire l'information présente sur des CDs et des DVDs.
* Comment configurer une carte TV.
* Comment configurer un scanner.

Avant de lire ce chapitre, vous devrez:

* Savoir comment configurer et installer un nouveau noyau (crossref:kernelconfig[kernelconfig,Configurer le noyau de FreeBSD]).

[WARNING]
====

Essayer de monter des CDs audio avec la commande man:mount[8] aura pour résultat une erreur, au moins, et une _panique du noyau_, au pire. Ces supports ont des codages spécifiques qui diffèrent du système de fichiers ISO classique.
====

[[sound-setup]]
== Configurer une carte son

[[sound-device]]
=== Configuration du système

Avant que vous commenciez, vous devriez connaître le modèle de carte son que vous avez, la puce qu'elle utilise, et si c'est une carte PCI ou ISA. FreeBSD supporte une grande variété de cartes PCI et ISA. Consultez la liste des périphériques audio supportés des link:{u-rel120-hardware}[notes de compatibilité matériel] pour voir si votre carte est supportée. Ces notes indiqueront également quel pilote supporte votre carte.

Pour utiliser votre carte son, vous devrez charger le pilote de périphérique approprié. Cela peut être fait de deux façons. La plus simple est de charger le module pour votre carte son avec man:kldload[8], ce qui peut être soit fait à partir de la ligne de commande:

[source,shell]
....
# kldload snd_emu10k1
....

soit en ajoutant la ligne appropriée dans le fichier [.filename]#/boot/loader.conf# comme cela:

[.programlisting]
....
snd_emu10k1_load="YES"
....

Ces exemples concernent la carte Creative SoundBlaster(R) Live!. Les autres modules son chargeables sont listés dans [.filename]#/boot/defaults/loader.conf#. Si vous n'êtes pas sûr du pilote à utiliser, vous pouvez tenter de charger le pilote [.filename]#snd_driver#:

[source,shell]
....
# kldload snd_driver
....

C'est un méta-pilote chargeant directement les pilotes les plus courants. Cela accélère la recherche du pilote adapté. Il est également possible de charger l'intégralité des pilotes de cartes son en utilisant le système [.filename]#/boot/loader.conf#.

Si vous voulez connaître le pilote sélectionné lors du chargement du méta-pilote [.filename]#snd_driver#, vous pouvez consulter le fichier [.filename]#/dev/sndstat# à cet effet, et cela à l'aide de la commande `cat /dev/sndstat`.

Une seconde méthode est de compiler le support pour votre carte son en statique dans votre noyau. La section ci-dessous fournit les informations nécessaires pour ajouter le support de votre matériel de cette manière. Pour plus d'informations au sujet de la recompilation de votre noyau, veuillez consulter le crossref:kernelconfig[kernelconfig,Configurer le noyau de FreeBSD].

==== Configurer un noyau sur mesure avec support du son

La première chose à effectuer est d'ajouter au noyau le pilote de périphérique audio générique man:sound[4]; pour cela vous devrez ajouter la ligne suivante au fichier de configuration du noyau:

[.programlisting]
....
device sound
....

Ensuite, vous devez ajouter le support pour votre carte son. Par conséquent, vous devez savoir quel pilote supporte la carte. Consultez la liste des périphériques audio supportés des link:{u-rel120-hardware}[notes de compatibilité matériel] pour déterminer le pilote correct pour votre carte son. Par exemple, une carte son Creative SoundBlaster(R) Live! est supportée par le pilote man:snd_emu10k1[4]. Pour ajouter le support pour cette carte, utilisez ce qui suit:

[.programlisting]
....
device snd_emu10k1
....

Assurez-vous de lire la page de manuel du pilote pour la syntaxe à utiliser. La syntaxe de la configuration du noyau pour chaque pilote de carte son supportée peut être également trouvée dans le fichier [.filename]#/usr/src/sys/conf/NOTES#.

Les cartes son ISA non-PnP pourront nécessiter de fournir au noyau des informations sur le paramétrage de la carte (IRQ, port d'E/S, etc.), comme c'est en général le cas pour toutes les cartes ISA non-PnP. Cela s'effectue par l'intermédiaire du fichier [.filename]#/boot/device.hints#. Au démarrage du système, le chargeur (man:loader[8]) lira ce fichier et passera les paramètres au noyau. Par exemple, une vieille carte ISA non-PnP Creative SoundBlaster(R) 16 utilisera le pilote man:snd_sbc[4] de paire avec `snd_sb16`, on ajoutera alors la ligne suivante au fichier de configuration du noyau:

[.programlisting]
....
device snd_sbc
device snd_sb16
....

avec également ceci dans le fichier [.filename]#/boot/device.hints#:

[.programlisting]
....
hint.sbc.0.at="isa"
hint.sbc.0.port="0x220"
hint.sbc.0.irq="5"
hint.sbc.0.drq="1"
hint.sbc.0.flags="0x15"
....

Dans ce cas, la carte utilise le port d'E/S `0x220` et l'IRQ `5`.

La syntaxe utilisée dans le fichier [.filename]#/boot/device.hints# est abordée dans la page de manuel du pilote man:sound[4] ainsi que celle du pilote spécifique à la carte son.

Les paramètres donnés ci-dessus sont ceux par défaut. Dans certains cas, vous pouvez avoir besoin de modifier l'IRQ ou tout autre paramètre en fonction de votre carte son. Consultez la page de manuel man:snd_sbc[4] pour plus d'informations au sujet de cette carte.

[[sound-testing]]
=== Tester la carte son

Après avoir redémarré avec le noyau modifié, ou après avoir chargé le module nécessaire, la carte son devrait apparaître dans le tampon des messages du système (man:dmesg[8]) d'un manière proche de la suivante:

[source,shell]
....
pcm0: <Intel ICH3 (82801CA)> port 0xdc80-0xdcbf,0xd800-0xd8ff irq 5 at device 31.5 on pci0
pcm0: [GIANT-LOCKED]
pcm0: <Cirrus Logic CS4205 AC97 Codec>
....

L'état de la carte son peut être contrôlée par l'intermédiaire du fichier [.filename]#/dev/sndstat#:

[source,shell]
....
# cat /dev/sndstat
FreeBSD Audio Driver (newpcm)
Installed devices:
pcm0: <Intel ICH3 (82801CA)> at io 0xd800, 0xdc80 irq 5 bufsz 16384
kld snd_ich (1p/2r/0v channels duplex default)
....

Le résultat pourra être différent sur votre système. Si aucun périphérique [.filename]#pcm# n'apparaît, retournez en arrière et revoyez ce qui a été fait précédemment. Contrôlez à nouveau votre fichier de configuration du noyau et vérifiez que vous avez choisi le périphérique correct. Les problèmes courants sont listés dans la <<troubleshooting>>.

Si tout va bien, vous devriez avoir maintenant une carte son qui fonctionne. Si la sortie audio de votre lecteur de CD-ROM ou de DVD-ROM est correctement reliée à votre carte son, vous pouvez introduire un CD dans le lecteur et le jouer avec man:cdcontrol[1]:

[source,shell]
....
% cdcontrol -f /dev/acd0 play 1
....

Diverses applications, comme package:audio/workman[] offrent une meilleure interface. Vous pouvez vouloir installer une application comme package:audio/mpg123[] pour écouter des fichiers audio MP3.

Une autre méthode rapide pour tester la carte est d'envoyer des données au [.filename]#/dev/dsp#, de la manière suivante:

[source,shell]
....
% cat filename  /dev/dsp
....

où _filename_ peut être n'importe quel fichier. Cette ligne de commande devrait produire des sons, confirmant le bon fonctionnement de la carte son.

Les niveaux du mixer de la carte son peuvent être modifiés par la commande man:mixer[8]. Plus de détails peuvent être trouvés dans la page de manuel man:mixer[8].

[[troubleshooting]]
==== Problèmes courants

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Erreur
| Solution

|`sb_dspwr(XX) timed out`
|

Le port d'E/S n'est pas configuré correctement.

|`bad irq XX`
|

L'IRQ sélectionnée est incorrecte. Vérifiez que l'IRQ choisie et l'IRQ de la carte son sont les mêmes.

|`xxx: gus pcm not attached, out of memory`
|

Il n'y a pas suffisamment de mémoire disponible pour utiliser ce périphérique.

|`xxx: can't open /dev/dsp!`
|

Vérifiez avec la commande `fstat \| grep dsp` si une autre application maintient le périphérique ouvert. Souvent à l'origine de ce type de problème on trouve esound et le support son de KDE.
|===

[[sound-multiple-sources]]
=== Utiliser des sources sonores multiples

Il est souvent intéressant de pouvoir jouer simultanément du son à partir de multiples sources, comme lorsque esound ou artsd ne supportent pas le partage du périphérique son avec certaines applications.

FreeBSD vous permet de le faire par l'intermédiaire de _Canaux Sonores Virtuels_, qui peuvent être activés avec la fonction man:sysctl[8]. Les canaux virtuels vous permettent de multiplexer la sortie de votre carte son en mixant le son au niveau du noyau.

Pour configurer le nombre de canaux virtuels, il existe deux paramètres de sysctl qui, si vous avez les privilèges de l'utilisateur `root`, peuvent être configurés comme ceci:

[source,shell]
....
# sysctl hw.snd.pcm0.vchans=4
# sysctl hw.snd.maxautovchans=4
....

L'exemple ci-dessus alloue quatre canaux virtuels, ce qui est un nombre suffisant pour une utilisation classique. `hw.snd.pcm0.vchans` est le nombre de canaux virtuels que possède [.filename]#pcm0#, et est configurable une fois que le périphérique a été attaché au système. `hw.snd.maxautovchans` est le nombre de canaux virtuels alloués à un nouveau périphérique audio quand il est attaché à l'aide de man:kldload[8]. Comme le module [.filename]#pcm# peut être chargé indépendamment des pilotes de périphériques, `hw.snd.maxautovchans` peut stocker combien de canaux virtuels seront alloués à chaque périphérique attaché par la suite.

[NOTE]
====
Vous ne pouvez pas modifier le nombre de canaux virtuels pour un périphérique en cours d'utilisation. Quittez avant tout autre chose les programmes utilisant le périphérique en question, comme les lecteurs de fichiers sonores ou les "daemons" audios.
====

Si vous n'utilisez pas man:devfs[5], vous devrez faire pointer vos applications sur [.filename]#/dev/dsp0#._x_, où _x_ est 0 à 3 si `hw.snd.pcm.0.vchans` est fixé à 4. Sur un système utilisant man:devfs[5], ce qui précède sera automatiquement effectué de façon transparente pour le programme qui réclame le périphérique [.filename]#/dev/dsp0#.

=== Définir les valeurs par défaut du mixeur des différents canaux

Les valeurs par défaut du mixeur des différents canaux sont fixées en dur dans le code source du pilote man:pcm[4]. Il existe plusieurs applications et "daemons" qui vous permettent de fixer les valeurs du mixeur qui seront mémorisées entre chaque invocation, mais ce n'est pas une solution idéale. Il est possible régler les valeurs par défaut au niveau du pilote - ceci se fait en définissant les valeurs adéquates dans le fichier [.filename]#/boot/device.hints#. Par exemple:

[.programlisting]
....
hint.pcm.0.vol="50"
....

Cela fixera le volume du canal à une valeur par défaut de 50; dès que le module man:pcm[4] est chargé.

[[sound-mp3]]
== Fichiers MP3

Les fichiers MP3 (MPEG Layer 3 Audio) donnent un son proche de la qualité d'un CD audio, il n'y a aucune raison pour que votre station de travail FreeBSD ne puisse pas en profiter.

[[mp3-players]]
=== Lecteurs de MP3s

De loin, le plus populaire des lecteurs MP3 pour X11 est XMMS (X Multimedia System). Les thèmes (skins) de Winamp peuvent être utilisés avec XMMS dès lors que l'interface est quasiment identique à celle du Winamp de Nullsoft. XMMS dispose aussi d'un support natif pour modules externes (plug-in).

XMMS peut être installé à partir du catalogue de logiciels portés package:multimedia/xmms[] ou de la version pré-compilée.

L'interface d'XMMS est intuitive, avec une liste de lecture, un égaliseur graphique, et plus. Ceux qui sont familiers avec Winamp trouveront XMMS simple d'utilisation.

Le logiciel porté package:audio/mpg123[] est une alternative, un lecteur de MP3 en ligne de commande.

mpg123 peut être utilisé en spécifiant le périphérique sonore et le fichier MP3 sur la ligne de commande, comme montré ci-dessous:

[source,shell]
....
# mpg123 -a /dev/dsp1.0 Foobar-GreatestHits.mp3
High Performance MPEG 1.0/2.0/2.5 Audio Player for Layer 1, 2 and 3.
Version 0.59r (1999/Jun/15). Written and copyrights by Michael Hipp.
Uses code from various people. See 'README' for more!
THIS SOFTWARE COMES WITH ABSOLUTELY NO WARRANTY! USE AT YOUR OWN RISK!

Playing MPEG stream from Foobar-GreastestHits.mp3 ...
MPEG 1.0 layer III, 128 kbit/s, 44100 Hz joint-stereo
....

`/dev/dsp1.0` devrait être remplacé par le périphérique [.filename]#dsp# correspondant sur votre système.

[[rip-cd]]
=== Extraire les pistes de CDs Audio

Avant d'encoder la totalité d'un CD ou une piste en MP3, les données audio doivent être extraites et transférées sur le disque dur. Cela se fait en copiant les données brutes CDDA (CD Digital Audio) en fichiers WAV.

L'utilitaire `cdda2wav`, qui fait partie de la suite package:sysutils/cdrtools[], est utilisé pour extraire les données audio de CDs et les informations rattachées.

Avec le CD audio dans le lecteur, la commande suivante peut être utilisée (en tant que `root`) pour convertir l'intégralité d'un CD en fichiers WAV (un par piste):

[source,shell]
....
# cdda2wav -D 0,1,0 -B
....

cdda2wav supportera également les lecteurs de CDROM ATAPI (IDE). Pour faire l'extraction à partir d'un lecteur IDE, précisez le nom du périphérique à la place de l'unité SCSI. Par exemple, pour extraite la piste 7 à partir d'un lecteur IDE:

[source,shell]
....
# cdda2wav -D /dev/acd0 -t 7
....

Le `-D _0,1,0_` spécifie le périphérique SCSI [.filename]#0,1,0#, qui correspond à ce qui est donné par la commande `cdrecord -scanbus`.

Pour extraire des pistes individuelles, utilisez l'option `-t` comme ceci:

[source,shell]
....
# cdda2wav -D 0,1,0 -t 7
....

Cet exemple extrait la septième piste du CD audio. Pour extraire un ensemble de pistes, par exemple, de la piste 1 à 7, précisez un intervalle:

[source,shell]
....
# cdda2wav -D 0,1,0 -t 1+7
....

L'utilitaire man:dd[1] peut également être utilisé pour extraire des pistes audios à partir de lecteurs ATAPI, consultez la crossref:disks[duplicating-audiocds,Dupliquer des CDs Audio] pour plus d'informations sur cette possibilité.

[[mp3-encoding]]
=== Encoder des MP3s

De nos jours, l'encodeur mp3 à utiliser est lame. Lame peut être trouvé dans le catalogue de logiciels portés: package:audio/lame[].

En utilisant les fichiers WAV extraits, la commande suivante convertira le fichier [.filename]#audio01.wav# en [.filename]#audio01.mp3#:

[source,shell]
....
# lame -h -b 128 \
--tt "La chanson XY" \
--ta "Artiste XY" \
--tl "Album XY" \
--ty "2001" \
--tc "Extrait et encodé par XY" \
--tg "Genre" \
audio01.wav audio01.mp3
....

128 kbits semble être le taux standard actuel du débit audio utilisé pour les MP3s. Nombreux sont ceux qui préfèrent des taux de haute qualité: 160 ou 192. Plus le débit audio est élevé plus l'espace disque utilisé par le fichier MP3 sera grand mais la qualité sera meilleure. L'option `-h` active le mode "haute qualité, mais un peu plus lent". Les options commençant par `--t` indiquent des balises ID3, qui généralement contiennent les informations sur le morceau, devant être intégrées au fichier MP3. D'autres informations sur l'encodage peuvent être trouvées en consultant la page de manuel de Lame.

[[mp3-decoding]]
=== Décoder des MP3s

Afin de pouvoir graver un CD audio à partir de fichiers MP3, ces derniers doivent être convertis dans le format WAV non compressé. XMMS et mpg123 supportent tous les deux la sortie de fichiers MP3 en format de fichier non compressé.

Ecriture sur le disque avec XMMS:

[.procedure]
====
. Lancez XMMS.
. Clic-droit sur la fenêtre pour faire apparaître le menu d'XMMS.
. Sélectionner `Preference` sous `Options`.
. Changez l'option "Output Plugin" pour "Disk Writer Plugin".
. Appuyez sur `Configure`.
. Entrez (ou choisissez browse) un répertoire où va être écrit le fichier décompressé.
. Chargez le fichier MP3 dans XMMS comme à l'accoutumé, avec le volume à 100% et l'égaliseur (EQ settings) désactivé.
. Appuyez sur `Play` - XMMS devrait se comporter comme s'il jouait le MP3, mais aucun son ne sera audible. Il est en fait en train de "jouer" le MP3 dans un fichier.
. Vérifiez que vous avez rétabli l'option "Output Plugin" à sa valeur de départ afin de pouvoir écouter à nouveau des MP3s.
====

Ecriture sur le disque avec mpg123:

[.procedure]
====
. Lancez `mpg123 -s audio01.mp3 audio01.pcm`
====

XMMS crée un fichier au format WAV, tandis que mpg123 convertit le fichier MP3 en données audio PCM brutes. Ces deux formats peuvent être utilisés avec cdrecord pour créer des CDs audio. Vous devez utiliser des fichiers PCM bruts avec man:burncd[8]. Si vous utilisez des fichiers WAV, vous noterez un petit parasite au début de chaque piste, ce son est l'entête du fichier WAV. Vous pouvez simplement retirer l'entête d'un fichier WAV avec l'utilitaire SoX (il peut être installé à partir du logiciel porté package:audio/sox[] ou de la version pré-compilée):

[source,shell]
....
% sox -t wav -r 44100 -s -w -c 2 track.wav track.raw
....

Lisez la crossref:disks[creating-cds,Création et utilisation de supports optiques (CDs)] pour plus d'informations sur l'utilisation d'un graveur de CD sous FreeBSD.

[[video-playback]]
== Lecture des Vidéos

Les applications pour lire des vidéos sont assez récentes et se développent très rapidement. Soyez patient. Tout ne va pas fonctionner aussi bien que cela pu être le cas avec le son.

Avant que vous ne commenciez, vous devrez connaître le modèle de carte vidéo dont vous disposez ainsi que le circuit intégré qu'elle utilise. Alors qu'Xorg et XFree86(TM) supportent une large variété de cartes vidéo, seul un petit nombre d'entre elles donne de bonnes performances en lecture de vidéos. Pour obtenir la liste des extensions supportées par le serveur X utilisant votre carte employez la commande man:xdpyinfo[1] durant le fonctionnement d'X11.

C'est une bonne idée d'avoir un court fichier MPEG qui pourra être utilisé comme fichier test pour évaluer divers lecteurs et leurs options. Comme certains programmes de lecture de DVD chercheront un support DVD sur [.filename]#/dev/dvd# par défaut, ou ont ce périphérique fixé définitivement dans leur code, vous pourrez trouver utile de créer des liens symboliques vers les périphériques corrects:

[source,shell]
....
# ln -sf /dev/acd0 /dev/dvd
# ln -sf /dev/acd0 /dev/rdvd
....

Notez qu'en raison de la nature du système man:devfs[5], les liens créés à la main comme les précédents ne seront pas conservés si vous redémarrez le système. Afin de créer automatiquement les liens symboliques dès que vous redémarrez votre système, ajoutez les lignes suivantes au fichier [.filename]#/etc/devfs.conf#:

[.programlisting]
....
link acd0 dvd
link acd0 rdvd
....

De plus, le décodage de DVD, qui nécessite de faire appel à des fonctions spéciales du lecteur de DVD, demande d'avoir la permission d'écrire sur les périphériques DVD.

Pour augmenter la mémoire partagée pour l'interface X11, il est recommandé que les valeurs de certaines variables man:sysctl[8] soient augmentées:

[.programlisting]
....
kern.ipc.shmmax=67108864
kern.ipc.shmall=32768
....

[[video-interface]]
=== Déterminer les capacités vidéo

Il y a plusieurs manières possibles pour afficher de la vidéo sous X11. Ce qui fonctionnera vraiment est énormément dépendant du matériel. Chaque méthode décrite ci-dessous donnera différents résultats en fonction du matériel. De plus, le rendu de la vidéo sous X11 est un sujet recevant beaucoup d'attention dernièrement, et avec chaque nouvelle version d'Xorg, ou d'XFree86(TM), il pourra y avoir des améliorations significatives.

Une liste des interfaces vidéo communes:

. X11: sortie X11 classique utilisant de la mémoire partagée.
. XVideo: une extension de l'interface X11 qui supporte la vidéo sur n'importe quelle partie de l'écran contrôlé par X11.
. SDL: "Simple Directmedia Layer" - couche simple d'accès directe au média.
. DGA: "Direct Graphics Access" - accès direct au graphique.
. SVGAlib: couche graphique bas niveau pour la console.

[[video-interface-xvideo]]
==== XVideo

Xorg et XFree86(TM) 4.X disposent d'une extension appelée _XVideo_ (également connue sous les termes Xvideo, Xv, ou xv) qui permet d'afficher directement de la vidéo à travers une accélération spécifique. Cette extension fournit une très bonne qualité de rendu même sur les machines bas de gamme.

Pour vérifier si l'extension fonctionne utilisez `xvinfo`:

[source,shell]
....
% xvinfo
....

XVideo est supporté pour votre carte si le résultat de la commande ressemble à:

[source,shell]
....
X-Video Extension version 2.2
screen #0
  Adaptor #0: "Savage Streams Engine"
    number of ports: 1
    port base: 43
    operations supported: PutImage
    supported visuals:
      depth 16, visualID 0x22
      depth 16, visualID 0x23
    number of attributes: 5
      "XV_COLORKEY" (range 0 to 16777215)
              client settable attribute
              client gettable attribute (current value is 2110)
      "XV_BRIGHTNESS" (range -128 to 127)
              client settable attribute
              client gettable attribute (current value is 0)
      "XV_CONTRAST" (range 0 to 255)
              client settable attribute
              client gettable attribute (current value is 128)
      "XV_SATURATION" (range 0 to 255)
              client settable attribute
              client gettable attribute (current value is 128)
      "XV_HUE" (range -180 to 180)
              client settable attribute
              client gettable attribute (current value is 0)
    maximum XvImage size: 1024 x 1024
    Number of image formats: 7
      id: 0x32595559 (YUY2)
        guid: 59555932-0000-0010-8000-00aa00389b71
        bits per pixel: 16
        number of planes: 1
        type: YUV (packed)
      id: 0x32315659 (YV12)
        guid: 59563132-0000-0010-8000-00aa00389b71
        bits per pixel: 12
        number of planes: 3
        type: YUV (planar)
      id: 0x30323449 (I420)
        guid: 49343230-0000-0010-8000-00aa00389b71
        bits per pixel: 12
        number of planes: 3
        type: YUV (planar)
      id: 0x36315652 (RV16)
        guid: 52563135-0000-0000-0000-000000000000
        bits per pixel: 16
        number of planes: 1
        type: RGB (packed)
        depth: 0
        red, green, blue masks: 0x1f, 0x3e0, 0x7c00
      id: 0x35315652 (RV15)
        guid: 52563136-0000-0000-0000-000000000000
        bits per pixel: 16
        number of planes: 1
        type: RGB (packed)
        depth: 0
        red, green, blue masks: 0x1f, 0x7e0, 0xf800
      id: 0x31313259 (Y211)
        guid: 59323131-0000-0010-8000-00aa00389b71
        bits per pixel: 6
        number of planes: 3
        type: YUV (packed)
      id: 0x0
        guid: 00000000-0000-0000-0000-000000000000
        bits per pixel: 0
        number of planes: 0
        type: RGB (packed)
        depth: 1
        red, green, blue masks: 0x0, 0x0, 0x0
....

Notez également que les formats listés (YUV2, YUV12, etc...) ne sont pas présents dans chaque implémentation d'XVideo et leur absence pourra gêner certains programmes.

Si le résultat ressemble à:

[source,shell]
....
X-Video Extension version 2.2
screen #0
no adaptors present
....

Alors XVideo n'est probablement pas supporté pour votre carte.

Si XVideo n'est pas supporté pour votre carte, cela signifie seulement qu'il sera plus difficile pour votre système d'affichage de répondre aux demandes du rendu vidéo en termes de puissance de calcul. En fonction de votre carte vidéo et de votre processeur, vous pourriez encore obtenir de bons résultats. Vous devriez probablement vous documenter sur les méthodes pour améliorer les performances en lisant la <<video-further-reading>>.

[[video-interface-SDL]]
==== "Simple Directmedia Layer" - couche simple d'accès directe au média

La couche simple d'accès directe au média, SDL, a été prévue pour être une couche de portage entre Microsoft(R) Windows(R), BeOS, et UNIX(R), permettant à des applications "cross-platform" qui font un usage efficace du son et du graphique d'être développées. La couche SDL fournit une abstraction de bas niveau vers le matériel qui peut parfois être plus efficace que l'interface X11.

La bibliothèque SDL peut être trouvée dans package:devel/sdl12[].

[[video-interface-DGA]]
==== "Direct Graphics Access" - accès direct au graphique

L'accès direct au graphique est une extension X11 qui permet à un programme de bypasser le serveur X et d'accéder directement au matériel. Comme il repose sur une copie bas niveau de la mémoire, les programmes l'utilisant doivent être exécutés avec les privilèges de l'utilisateur `root`.

L'extension DGA et ses performances peuvent être testées avec man:dga[1]. Quand `dga` est exécuté, il changera les couleurs de l'affichage à chaque appui sur une touche. Pour quitter, utilisez la touche kbd:[q].

[[video-ports]]
=== Logiciels portés et pré-compilés relatifs à la vidéo

Cette section traite des logiciels disponibles dans le catalogue des logiciels portés de FreeBSD qui peuvent être utilisés pour lire de la vidéo. Les applications vidéos sont un domaine de développement très actif, et les capacités de diverses applications seront sujettes à des divergences avec la description donnée ici.

Premièrement, il est important de savoir que plusieurs des applications vidéos fonctionnant sous FreeBSD ont été développées comme des applications pour Linux. Plusieurs de ces applications sont encore considérées comme étant de qualité bêta. Parmi les problèmes que l'on peut rencontrer avec les applications vidéos sous FreeBSD, nous trouvons:

. Une application ne peut pas lire un fichier produit par une autre application.
. Une application ne peut pas lire un fichier quelle a produit.
. La même application sur deux machines différentes, recompilée sur chaque machine pour la machine elle-même, jouera le fichier différemment.
. Un filtre apparemment insignifiant comme un changement d'échelle de l'image donne de très mauvais résultats en raison d'une routine de changement d'échelle boguée.
. Une application qui plante régulièrement.
. La documentation n'est pas installée avec le logiciel porté et peut être trouvée sur Internet ou dans le répertoire [.filename]#work# du logiciel porté.

Parmin ces applications, nombreuses sont celles qui peuvent présenter des "Linuxismes". Aussi, il y peut y avoir des problèmes résultants de la façon dont certaines bibliothèques standards sont implémentées dans les distributions Linux, ou certaines caractéristiques du noyau Linux qui ont été employées par les auteurs des applications. Ces problèmes ne sont pas toujours remarqués et contournés par les responsables du portage du logiciel ce qui peut mener vers quelques ennuis comme ceux-ci:

. L'utilisation de [.filename]#/proc/cpuinfo# pour détecter les caractéristiques du processeur.
. Une mauvaise utilisation des "threads" qui provoque le blocage de programme au lieu de se terminer complètement.
. Des logiciels habituellement utilisés en conjonction avec l'application ne sont pas encore dans le catalogue des logiciels portés.

Jusqu'ici, les développeurs de ces applications ont été coopératifs avec les responsables des logiciels portés pour minimiser les modifications nécessaires au portage.

[[video-mplayer]]
==== MPlayer

MPlayer est une application pour lire des vidéos récemment et rapidement développée. Les objectifs de l'équipe de MPlayer sont la rapidité et la flexibilité sur Linux et autre UNIX(R). Le projet fut démarré quand le fondateur de l'équipe en eu assez des mauvaises performances en lecture des autres lecteurs disponibles. Certains diront que l'interface graphique a été sacrifiée pour une conception rationalisée. Cependant, une fois que vous avez les options en ligne de commande et les combinaisons de touches en main, cela fonctionne très bien.

[[video-mplayer-building]]
===== Compiler MPlayer

MPlayer réside dans package:multimedia/mplayer[]. MPlayer effectue un certain nombre de contrôle du matériel durant le processus de compilation, il en résulte un binaire qui ne sera pas portable d'un système à l'autre. Ainsi il est important d'utiliser le logiciel porté et de ne pas utiliser un logiciel pré-compilé. En plus, un certain nombre d'options peuvent être spécifiées dans la ligne de commande `make`, comme décrit dans le fichier [.filename]#Makefile# et au départ de la compilation:

[source,shell]
....
# cd /usr/ports/multimedia/mplayer
# make
N - O - T - E

Take a careful look into the Makefile in order
to learn how to tune mplayer towards you personal preferences!
For example,
make WITH_GTK1
builds MPlayer with GTK1-GUI support.
If you want to use the GUI, you can either install
/usr/ports/multimedia/mplayer-skins
or download official skin collections from
http://www.mplayerhq.hu/homepage/dload.html
....

Les options par défaut du logiciel porté devraient être suffisantes pour la plupart des utilisateurs. Cependant si vous avez besoin du codec XviD, vous devez spécifier l'option `WITH_XVID` dans la ligne de commande. Le périphérique DVD par défaut peut également être défini avec l'option `WITH_DVD_DEVICE`, par défaut [.filename]#/dev/acd0# sera utilisé.

Au moment de l'écriture de ces lignes, le logiciel porté de MPlayer compilera sa documentation HTML et deux exécutables, `mplayer` et `mencoder`, qui est un outil pour ré-encoder de la vidéo.

La documentation HTML de MPlayer est très complète. Si le lecteur trouve l'information sur le matériel vidéo et les interfaces manquante dans ce chapitre, la documentation de MPlayer est une alternative très complète. Vous devriez certainement prendre le temps de lire la documentation de MPlayer, si vous êtes à la recherche d'informations sur le support vidéo sous UNIX(R).

[[video-mplayer-using]]
===== Utiliser MPlayer

Chaque utilisateur de MPlayer doit créer un sous-répertoire [.filename]#.mplayer# dans son répertoire d'utilisateur. Pour créer ce sous-répertoire nécessaire, vous pouvez taper ce qui suit:

[source,shell]
....
% cd /usr/ports/multimedia/mplayer
% make install-user
....

Les options de commande de `mplayer` sont données dans la page de manuel. Pour plus de détails il y a la documentation HTML. Dans cette section, nous décrirons que quelques unes des utilisations les plus courantes.

Pour lire à un fichier, comme [.filename]#testfile.avi# en utilisant une des diverses interfaces vidéo utilisez l'option `-vo`:

[source,shell]
....
% mplayer -vo xv testfile.avi
....

[source,shell]
....
% mplayer -vo sdl testfile.avi
....

[source,shell]
....
% mplayer -vo x11 testfile.avi
....

[source,shell]
....
# mplayer -vo dga testfile.avi
....

[source,shell]
....
# mplayer -vo 'sdl:dga' testfile.avi
....

Cela vaut la peine d'essayer toutes ces options, comme leur performance relative dépend de nombreux facteurs et variera de façon significative avec le matériel.

Pour lire un DVD, remplacez [.filename]#testfile.avi# par `dvd://_N_ -dvd-device _DEVICE_` où _N_ est le numéro du titre à jouer et [.filename]#DEVICE# est le fichier spécial de périphérique correspondant au lecteur de DVD. Par exemple, pour jouer le titre 3 depuis [.filename]#/dev/dvd#:

[source,shell]
....
# mplayer -vo xv dvd://3 -dvd-device /dev/dvd
....

[NOTE]
====
Le périphérique DVD par défaut peut être défini lors de la compilation du logiciel porté MPlayer par l'intermédiaire de l'option `WITH_DVD_DEVICE`. Par défaut, ce périphérique est [.filename]#/dev/acd0#. Plus de détails peuvent être trouvés dans le [.filename]#Makefile# du logiciel porté.
====

Pour arrêter, avancer, etc..., consultez les combinaisons de touches, qui sont données en exécutant `mplayer -h` ou lisez la page de manuel.

D'autres options importantes pour la lecture sont: `-fs -zoom` qui active le mode plein écran et `-framedrop` qui aide au niveau des performances.

Pour que la ligne de commande à taper ne devienne pas trop longue, l'utilisateur peut créer un fichier [.filename]#.mplayer/config# et y fixer les options par défaut:

[.programlisting]
....
vo=xv
fs=yes
zoom=yes
....

Enfin, `mplayer` peut être utilisé pour extraire une piste du DVD dans un fichier [.filename]#.vob#. Pour récupérer la seconde piste vidéo d'un DVD, tapez ceci:

[source,shell]
....
# mplayer -dumpstream -dumpfile out.vob dvd://2 -dvd-device /dev/dvd
....

Le fichier de sortie, [.filename]#out.vob#, sera du MPEG et peut être manipulé par les autres logiciels décrits dans cette section.

[[video-mencoder]]
===== mencoder

Avant d'utiliser `mencoder` c'est une bonne idée de vous familiariser avec les options données par la documentation HTML. Il existe une page de manuel, mais elle n'est pas très utile sans la documentation en HTML. Il y a d'innombrables façons d'améliorer la qualité, diminuer le débit binaire, et modifier les formats, et certaines de ces options peuvent faire la différence entre de bonnes et mauvaises performances. Voici quelques exemples pour y arriver. Tout d'abord une simple copie:

[source,shell]
....
% mencoder input.avi -oac copy -ovc copy -o output.avi
....

De mauvaises combinaisons d'options peuvent conduire à des fichiers illisibles même par `mplayer`. Aussi, si vous voulez juste extraire un fichier, restez sur l'option `-dumpfile` de `mplayer`.

Pour convertir [.filename]#input.avi# au format MPEG4 avec un codage audio MPEG3 (package:audio/lame[] est nécessaire):

[source,shell]
....
% mencoder input.avi -oac mp3lame -lameopts br=192 \
	 -ovc lavc -lavcopts vcodec=mpeg4:vhq -o output.avi
....

Ceci a produit un fichier lisible par `mplayer` et `xine`.

[.filename]#input.avi# peut être remplacé par `dvd://1 -dvd-device /dev/dvd` et exécuté en tant que `root` pour ré-encoder directement un titre DVD. Puisque vous êtes susceptible de ne pas être satisfait du résultat la première fois, il est recommandé d'extraire le titre vers un fichier et de travailler sur le fichier.

[[video-xine]]
==== Le lecteur xine

Le lecteur xine est un projet de grande envergure visant non seulement à être une solution vidéo tout-en-un, mais également de produire une bibliothèque de base réutilisable et un exécutable modulaire qui peut être étendu grâce à des greffons. Il est fourni sous forme pré-compilée et de logiciel porté, package:multimedia/xine[].

Le lecteur xine est encore un peu brut, mais c'est clairement un bon début. Dans la pratique, xine demande soit un processeur rapide avec une carte vidéo rapide, soit l'extension XVideo. L'interface graphique est utilisable, mais peu pratique.

Au moment de l'écriture de ces lignes, il n'y a pas de module d'entrée fourni avec xine qui lira les DVDs codés en CSS. Il existe des versions tiers qui ont des modules à cet effet intégrés, mais aucune de ces dernières ne se trouve dans le catalogue des logiciels portés de FreeBSD.

Comparé à MPlayer, xine fait plus pour l'utilisateur, mais au même moment, rend inaccessible à l'utilisateur certains contrôles bien précis. Le lecteur xine se comporte le mieux sur les interfaces XVideo.

Par défaut, le lecteur xine lancera une interface graphique. Les menus peuvent alors être utilisés pour ouvrir un fichier précis:

[source,shell]
....
% xine
....

Alternativement, le lecteur peut être invoqué pour jouer directement un fichier sans l'interface graphique avec la commande:

[source,shell]
....
% xine -g -p mymovie.avi
....

[[video-ports-transcode]]
==== Les utilitaires transcode

Le logiciel transcode n'est pas un lecteur, mais une suite d'outils pour ré-encoder les fichiers audio et vidéo. Avec transcode, on a la capacité de fusionner des fichiers vidéos, réparer les fichiers endommagés, en utilisant les outils en ligne de commande avec des interfaces de flots [.filename]#stdin/stdout#.

Un grand nombre d'options peut être précisé lors de la compilation du logiciel porté package:multimedia/transcode[], nous recommandons d'utiliser la ligne de commande suivante pour compiler transcode:

[source,shell]
....
# make WITH_OPTIMIZED_CFLAGS=yes WITH_LIBA52=yes WITH_LAME=yes WITH_OGG=yes \
WITH_MJPEG=yes -DWITH_XVID=yes
....

Le paramétrage proposé devrait convenir à la plupart des utilisateurs.

Pour illustrer les capacités de `transcode`, voici un exemple montrant comment convertir un fichier DivX en fichier MPEG-1 en standard PAL (VCD PAL):

[source,shell]
....
% transcode -i input.avi -V --export_prof vcd-pal -o output_vcd
% mplex -f 1 -o output_vcd.mpg output_vcd.m1v output_vcd.mpa
....

Le fichier MPEG résultant, [.filename]#output_vcd.mpg#, peut être directement lu avec MPlayer. Vous pourrez même le graver sur un CD pour créer ainsi un Vidéo CD; dans ce cas vous devrez installer et utiliser les programmes package:multimedia/vcdimager[] et package:sysutils/cdrdao[].

Il existe une page de manuel pour `transcode`, mais il est conseillé de consulter également le http://www.transcoding.org/cgi-bin/transcode[wiki de transcode] pour plus d'information et des exemples.

[[video-further-reading]]
=== Lectures supplémentaires

Les différents logiciels vidéo pour FreeBSD se développent rapidement. Il est fort possible que dans un futur proche plusieurs des problèmes abordés ici seront résolus. Entre temps ceux qui veulent tirer partie des possibilités audio/vidéo de FreeBSD devront se débrouiller avec des connaissances extraites de plusieurs FAQs et guides et utiliser différentes applications. Cette section existe pour fournir au lecteur des références sur ces documentations additionnelles.

La http://www.mplayerhq.hu/DOCS/[documentation de MPlayer] est techniquement très instructive. Ces documents devraient probablement être consultés par quiconque désirant obtenir un niveau élevé d'expertise sur la vidéo et UNIX(R). La liste de diffusion de MPlayer est hostile à toute personne qui n'a pas pris la peine de lire la documentation, aussi si vous projetez de leur envoyer des rapports de bogue, lisez la documentation!

Le http://dvd.sourceforge.net/xine-howto/en_GB/html/howto.html[ HOWTO de xine] contient un chapitre sur l'amélioration des performances qui est général à tous les lecteurs de vidéo.

Et enfin, il y a quelques autres applications prometteuses que le lecteur devrait essayer:

* http://avifile.sourceforge.net/[Avifile] qui est également un logiciel porté package:multimedia/avifile[].
* http://www.dtek.chalmers.se/groups/dvd/[Ogle] qui est également un logiciel porté package:multimedia/ogle[].
* http://xtheater.sourceforge.net/[Xtheater]
* package:multimedia/dvdauthor[], un logiciel libre pour la création de DVDs.

[[tvcard]]
== Configuration des cartes TV

=== Introduction

Les cartes TV vous permettent de regarder sur votre ordinateur la télévision par voie hertzienne ou par câble. La plupart d'entre elles acceptent de la vidéo composite par l'intermédiaire de connecteurs RCA ou S-video et certaines de ces cartes disposent d'un tuner radio FM.

FreeBSD founit le support pour les cartes TV PCI utilisant un circuit de capture video Brooktree Bt848/849/878/879 ou Conexant CN-878/Fusion 878a à l'aide du pilote man:bktr[4]. Vous devez également vous assurer que la carte dispose d'un tuner supporté, consultez la page de manuel man:bktr[4] pour une liste des tuners supportés.

=== Ajout du pilote de périphérique

Pour utiliser votre carte, vous devrez charger le pilote man:bktr[4], cela peut être effectué en ajoutant la ligne suivante au fichier [.filename]#/boot/loader.conf#:

[.programlisting]
....
bktr_load="YES"
....

Alternativement, vous pouvez compiler en statique dans le noyau le support pour la carte TV, dans ce cas ajouter les lignes suivantes dans votre fichier de configuration du noyau:

[.programlisting]
....
device	 bktr
device	iicbus
device	iicbb
device	smbus
....

Ces pilotes de périphériques supplémentaires sont nécessaires étant donné que les composants de la carte sont interconnectés via un bus I2C. Compilez et installez, ensuite, un nouveau noyau.

Une fois que le support a été ajouté au système, vous devez redémarrer votre machine. Durant le processus de démarrage, votre carte TV devrait apparaître de cette manière:

[.programlisting]
....
bktr0: BrookTree 848A mem 0xd7000000-0xd7000fff irq 10 at device 10.0 on pci0
iicbb0: I2C bit-banging driver on bti2c0
iicbus0: Philips I2C bus on iicbb0 master-only
iicbus1: Philips I2C bus on iicbb0 master-only
smbus0: System Management Bus on bti2c0
bktr0: Pinnacle/Miro TV, Philips SECAM tuner.
....

Bien évidemment ces messages peuvent varier en fonction de votre matériel. Cependant assurez-vous que le tuner est correctement détecté; il est possible de forcer certains des paramètres détecté à l'aide du système man:sysctl[8] et d'options de configuration du noyau. Par exemple, si vous désirez forcer le tuner pour un tuner Philips SECAM, vous devrez ajouter la ligne suivante au fichier de configuration du noyau:

[.programlisting]
....
options OVERRIDE_TUNER=6
....

ou vous pouvez directement utiliser man:sysctl[8]:

[source,shell]
....
# sysctl hw.bt848.tuner=6
....

Consultez la page de manuel man:bktr[4] et le fichier [.filename]#/usr/src/sys/conf/NOTES# pour plus de détails sur les options disponibles.

=== Applications utiles

Pour utiliser votre carte TV, vous devrez installer une des applications suivantes:

* package:multimedia/fxtv[] qui permet de regarder la télévision et d'enregistrer des images, du son et de la vidéo.
* package:multimedia/xawtv[] est également une application pour regarder la télévision avec les mêmes fonctionnalités que fxtv.
* package:misc/alevt[] décode et affiche les informations Vidéotexte/Télétexte.
* package:audio/xmradio[], un programme pour utiliser le tuner FM fourni avec certaines cartes TV.
* package:audio/wmtune[], une application intégrable dans votre environnement de travail pour gérer les tuners radio.

Plus d'applications sont disponibles dans le catalogue des logiciels portés de FreeBSD.

=== En cas de problème

Si vous rencontrez un quelconque problème avec votre carte TV, vous devriez contrôler tout d'abord que le circuit de capture video et le tuner sont vraiment supportés par le pilote man:bktr[4] et si vous avez utilisé les bonnes options de configuration. Pour plus de support et pour les diverses questions que vous pouvez vous poser à propos de votre carte TV, vous pouvez contacter et utiliser les archives de la liste de diffusion {freebsd-multimedia}.

[[scanners]]
== Scanners

=== Introduction

Sous FreeBSD, l'accès aux scanners est possible grâce à l'APISANE (Scanner Access Now Easy) disponible dans le catalogue des logiciels portés. SANE utilisera également certains pilotes de périphériques FreeBSD pour accéder à la partie matérielle du scanner.

FreeBSD supporte les scanners SCSI et USB. Assurez-vous que votre scanner est supporté par SANE avant d'effectuer une quelconque configuration. SANE dispose d'une liste des http://www.sane-project.org/sane-supported-devices.html[périphériques supportés] qui peut vous informer sur le support et son statut pour un scanner particulier. La page de manuel man:uscanner[4] donne également une liste des scanners USB supportés.

=== Configuration du noyau

Comme mentionné plus haut les interfaces SCSI et USB sont supportées. En fonction de l'interface de votre scanner, différents pilotes de périphérique sont nécessaires.

[[scanners-kernel-usb]]
==== Interface USB

Le noyau [.filename]#GENERIC# inclut par défaut les pilotes nécessaires au support des scanners USB. Si vous décidez d'utiliser un noyau personnalisé, assurez-vous que les lignes suivantes sont présentes dans votre fichier de configuration du noyau:

[.programlisting]
....
device usb
device uhci
device ohci
device uscanner
....

En fonction du contrôleur USB présent sur votre carte mère, vous n'avez besoin que d'une des deux lignes `device uhci` et `device ohci`, cependant avoir ces deux lignes simultanément dans la configuration du noyau est sans risque.

Si vous ne désirez pas recompiler votre noyau et que votre noyau n'est pas le [.filename]#GENERIC#, vous pouvez directement charger le module du pilote man:uscanner[4] à l'aide de la commande man:kldload[8]:

[source,shell]
....
# kldload uscanner
....

Pour charger ce module à chaque démarrage du système, ajoutez la ligne suivante au fichier [.filename]#/boot/loader.conf#:

[.programlisting]
....
uscanner_load="YES"
....

Après avoir redémarré avec le bon noyau, ou après avoir chargé le module nécessaire, branchez votre scanner USB. Une ligne montrant la détection de votre scanner devrait apparaître dans le tampon des messages du système (man:dmesg[8]):

[source,shell]
....
uscanner0: EPSON EPSON Scanner, rev 1.10/3.02, addr 2
....

Ceci nous indique que notre scanner utilise le fichier spécial de périphérique [.filename]#/dev/uscanner0#.

==== Interface SCSI

Si votre scanner dispose d'une interface SCSI, il est important de connaître quelle carte contrôleur SCSI vous utiliserez. En fonction du contrôleur sur la carte, vous devrez adapter votre configuration du noyau. Le noyau [.filename]#GENERIC# supporte les contrôleurs SCSI les plus courants. Assurez-vous d'avoir lu le fichier [.filename]#NOTES# et ajoutez la ligne adéquate dans votre fichier de configuration du noyau. En plus du pilote de votre carte SCSI, vous avez besoin des lignes suivantes dans votre fichier de configuration du noyau:

[.programlisting]
....
device scbus
device pass
....

Une fois que votre noyau a été correctement compilé et installé, vous devriez être en mesure de voir les périphériques au démarrage:

[source,shell]
....
pass2 at aic0 bus 0 target 2 lun 0
pass2: <AGFA SNAPSCAN 600 1.10> Fixed Scanner SCSI-2 device
pass2: 3.300MB/s transfers
....

Si votre scanner n'était pas alimenté au démarrage du système, il est encore possible de forcer sa détection, en en sondant le bus SCSI avec la commande man:camcontrol[8]:

[source,shell]
....
# camcontrol rescan all
Re-scan of bus 0 was successful
Re-scan of bus 1 was successful
Re-scan of bus 2 was successful
Re-scan of bus 3 was successful
....

Ensuite le scanner apparaîtra dans la liste des périphériques SCSI:

[source,shell]
....
# camcontrol devlist
<IBM DDRS-34560 S97B>              at scbus0 target 5 lun 0 (pass0,da0)
<IBM DDRS-34560 S97B>              at scbus0 target 6 lun 0 (pass1,da1)
<AGFA SNAPSCAN 600 1.10>           at scbus1 target 2 lun 0 (pass3)
<PHILIPS CDD3610 CD-R/RW 1.00>     at scbus2 target 0 lun 0 (pass2,cd0)
....

Plus de détails sur les périphériques SCSI sont disponibles dans les pages de manuel man:scsi[4] et man:camcontrol[8].

=== Configuration de SANE

Le système SANE est divisé en deux parties: les "backend"s (package:graphics/sane-backends[]) et les "frontend"s (package:graphics/sane-frontends[]). Les "backend"s fournissent l'accès au scanner. La liste des http://www.sane-project.org/sane-supported-devices.html[périphériques supportés] par SANE indique quel "backend" supportera votre scanner. Il est indispensable de déterminer correctement le "backend" relatif à votre scanner si vous voulez être en mesure d'utiliser votre périphérique. La partie "frontend"s fournie l'interface graphique de numérisation (xscanimage).

La première étape est d'installer le logiciel porté package:graphics/sane-backends[] ou sa version pré-compilée. Ensuite, utilisez la commande `sane-find-scanner` pour contrôler la détection du scanner par l'ensemble SANE:

[source,shell]
....
# sane-find-scanner -q
found SCSI scanner "AGFA SNAPSCAN 600 1.10" at /dev/pass3
....

Le résultat de la commande affichera le type d'interface utilisée par le scanner et le fichier spécial de périphérique utilisé pour attacher le scanner au système. Le fabricant et le modèle peuvent ne pas apparaître, cela n'est pas important.

[NOTE]
====
Certains scanners USB requièrent le chargement préalable d'un "firmware", cela est expliqué dans la page de manuel du "backend" utilisé. Vous devriez également consulter les pages de manuel de man:sane-find-scanner[1] et man:linprocfs[7].
====

Nous devons maintenant vérifier si le scanner sera identifié par un "frontend" de numérisation. Par défaut, les "backend"s SANE sont fournies avec un outil en ligne de commande appelé man:sane[1]. Cette commande vous permet de lister les périphériques et d'effectuer une acquisition d'image à partir de la ligne de commande. L'option `-L` est employée pour afficher les scanners présents sur le système:

[source,shell]
....
# scanimage -L
device `snapscan:/dev/pass3' is a AGFA SNAPSCAN 600 flatbed scanner
....

Aucun résultat, ou un message disant qu'aucun scanner n'a été identifié indiquent que man:sane[1] est incapable d'identifier le scanner. Si cela se produit, vous devrez éditer le fichier de configuration du "backend" du scanner et définir le type de scanner utilisé. Le répertoire [.filename]#/usr/local/etc/sane.d/# contient tous les fichiers de configurations des "backend"s. Ce problème d'identification apparaît essentiellement avec certains scanners USB.

Par exemple, avec le scanner USB utilisé dans la <<scanners-kernel-usb>>, `sane-find-scanner` nous donne l'information suivante:

[source,shell]
....
# sane-find-scanner -q
found USB scanner (UNKNOWN vendor and product) at device /dev/uscanner0
....

Le scanner est correctement détecté, il utilise l'interface USB et est attaché au fichier spécial de périphérique [.filename]#/dev/uscanner0#. Nous pouvons maintenant vérifier si le scanner est correctement identifié:

[source,shell]
....
# scanimage -L

No scanners were identified. If you were expecting something different,
check that the scanner is plugged in, turned on and detected by the
sane-find-scanner tool (if appropriate). Please read the documentation
which came with this software (README, FAQ, manpages).
....

Comme le scanner n'est pas identifié, nous devons éditer le fichier [.filename]#/usr/local/etc/sane.d/epson.conf#. Le scanner utilisé était un EPSON Perfection(R) 1650, nous en déduisons donc que ce scanner utilisera le "backend" `epson`. Assurez-vous de bien lire les commentaires d'aide présents dans les fichiers de configuration des "backend"s. Les modifications à faire sont relativement simples: commentez toutes les lignes concernant une interface différente de celle utilisée par votre scanner (dans notre cas, nous commenterons toutes les lignes débutant par le mot `scsi` étant donné que notre scanner utilise une interface USB), ajoutez ensuite à la fin du fichier une ligne indiquant l'interface et le fichier spécial de périphérique utilisé. Dans ce cas, nous ajoutons la ligne suivante:

[.programlisting]
....
usb /dev/uscanner0
....

Veuillez vous assurer de bien lire les commentaires fournis dans les fichiers de configurations des "backend"s ainsi que les pages de manuel correspondantes pour plus de détails concernant la syntaxe correcte à utiliser. Nous pouvons maintenant vérifier si le scanner est identifié:

[source,shell]
....
# scanimage -L
device `epson:/dev/uscanner0' is a Epson GT-8200 flatbed scanner
....

Notre scanner a été identifié. Ce n'est pas important si la marque et le modèle ne correspondent pas au scanner. L'important est le champ `epson:/dev/uscanner0'`, qui nous donne le "backend" et le fichier spécial de périphérique corrects.

Une fois que la commande `scanimage -L` est en mesure d'identifier le scanner, la configuration est terminée. Le périphérique est prêt à effectuer sa première numérisation.

Bien que man:sane[1] permette d'effectuer une numérisation à partir de la ligne de commande, il est préférable d'utiliser une interface graphique. SANE offre une interface graphique simple mais efficace: xscanimage (package:graphics/sane-frontends[]).

Xsane (package:graphics/xsane[]) est une autre interface graphique de numérisation assez populaire. Ce programme offre des fonctions avancées comme différents mode de numérisation (photocopie, fax, etc.), la correction des couleurs, la numérisation par lots, etc. Ces deux applications sont utilisables comme greffon pour GIMP.

=== Donner l'accès au scanner aux autres utilisateurs

Toutes les opérations précédentes ont été effectuées avec les privilèges `root`. Vous pourrez, cependant, avoir besoin que d'autres utilisateurs puissent accéder au scanner. L'utilisateur devra avoir les permissions de lecture et d'écriture sur le fichier spécial de périphérique [.filename]#/dev/uscanner0# dont le propriétaire est le groupe `operator`. L'ajout de l'utilisateur `joe` au groupe `operator` lui autorisera l'accès au scanner:

[source,shell]
....
# pw groupmod operator -m joe
....

Pour plus de détails, consultez la page de manuel de man:pw[8]. Vous devez également fixer les permissions d'écriture correctes (0660 or 0664) sur le fichier spécial de périphérique [.filename]#/dev/uscanner0#, par défaut le groupe `operator` n'a qu'un accès en lecture. Cela se fait en ajoutant les lignes suivantes au fichier [.filename]#/etc/devfs.rules#:

[.programlisting]
....
[system=5]
add path uscanner0 mode 660
....

Ajoutez ensuite ce qui suit au fichier [.filename]#/etc/rc.conf# et redémarrez la machine:

[.programlisting]
....
devfs_system_ruleset="system"
....

Plus d'information concernant ces lignes peut être trouvée dans la page de manuel man:devfs[8].

[NOTE]
====
Bien sûr, pour des raisons de sécurité, vous devriez réfléchir à deux fois avant d'ajouter un utilisateur à n'importe quel groupe, tout particulièrement au groupe `operator`.
====
