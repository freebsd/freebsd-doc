---
title: Chapitre 8. Configurer le noyau de FreeBSD
part: Partie II. Tâches courantes
prev: books/handbook/multimedia
next: books/handbook/printing
---

[[kernelconfig]]
= Configurer le noyau de FreeBSD
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:source-highlighter: rouge
:experimental:
:skip-front-matter:
:toc-title: Table des matières
:table-caption: Tableau
:example-caption: Exemple
:xrefstyle: basic
:relfileprefix: ../
:outfilesuffix:
:sectnumoffset: 8

ifeval::["{backend}" == "html5"]
:imagesdir: ../../../images/books/handbook/kernelconfig/
endif::[]

ifeval::["{backend}" == "pdf"]
:imagesdir: ../../../../static/images/books/handbook/kernelconfig/
endif::[]

ifeval::["{backend}" == "epub3"]
:imagesdir: ../../../../static/images/books/handbook/kernelconfig/
endif::[]

include::shared/authors.adoc[]
include::shared/releases.adoc[]
include::shared/fr/mailing-lists.adoc[]
include::shared/fr/teams.adoc[]
include::shared/fr/urls.adoc[]

toc::[]

[[kernelconfig-synopsis]]
== Synopsis

Le noyau est le coeur du système d'exploitation FreeBSD. Il est responsable de la gestion de la mémoire, de la mise en application des contrôles de sécurité, du réseau, des accès disque, et bien plus. Bien que FreeBSD devienne de plus en plus configurable dynamiquement, il est toujours nécessaire occasionnellement de reconfigurer et recompiler votre noyau.

Après la lecture de ce chapitre, vous saurez:

* Pourquoi vous pourriez avoir besoin de compiler un noyau sur mesure.
* Comment écrire un fichier de configuration du noyau, ou modifier un fichier de configuration existant.
* Comment utiliser le fichier de configuration du noyau pour créer et recompiler un nouveau noyau.
* Comment installer un nouveau noyau.
* Que faire si quelque chose se passe mal.

Toutes les commandes listées dans les exemples de ce chapitre doivent être exécutées en tant que `root` afin de fonctionner.

[[kernelconfig-custom-kernel]]
== Pourquoi compiler un noyau sur mesure?

Traditionnellement, FreeBSD a eu ce qui s'appelle un noyau "monolithique". Cela signifie que le noyau était un gros programme, supportant une liste figée de périphériques, et si vous vouliez modifier le comportement du noyau alors vous deviez compiler un nouveau noyau, et ensuite redémarrer votre ordinateur avec le nouveau noyau.

Aujourd'hui, FreeBSD s'oriente rapidement vers un modèle où une grande partie des fonctions du noyau est contenue dans des modules qui peuvent être dynamiquement chargés et déchargés si nécessaire. Cela permet au noyau de s'adapter au nouveau matériel devenant soudainement disponible (comme les cartes PCMCIA dans un ordinateur portable), ou pour qu'une nouvelle fonctionnalité qui n'était pas nécessaire lors de la compilation du noyau y soit intégrée. On appelle cela un noyau modulaire.

En dépit de cela, il est encore nécessaire d'effectuer certaines configurations de noyau en statique. Dans certains cas c'est parce que la fonctionnalité est si proche du noyau qu'elle ne peut être rendue dynamiquement chargeable. Dans d'autres cas, cela peut tout simplement venir du fait que personne n'a encore pris le temps d'écrire un module dynamiquement chargeable pour cette fonctionnalité.

Compiler un noyau sur mesure est l'un des plus importants rites de passage que doit endurer tout utilisateur BSD. Cette opération, tout en prenant du temps, apportera de nombreuses améliorations à votre système FreeBSD. A la différence du noyau [.filename]#GENERIC#, qui doit supporter une large gamme de matériels, un noyau sur mesure ne contient que le support pour _votre_ configuration matérielle. Cela a de nombreux avantages, comme:

* Un temps de démarrage plus court. Comme le noyau ne recherchera que le matériel présent sur votre système, le temps nécessaire au démarrage de votre système peut diminuer de façon importante.
* Une utilisation plus faible de la mémoire. Un noyau sur mesure utilise souvent moins de mémoire que le noyau [.filename]#GENERIC#, ce qui est important car le noyau doit toujours résider en mémoire. Pour cette raison, un noyau sur mesure est tout particulièrement utile sur un système dont les ressources mémoire sont limitées.
* Le support de matériels supplémentaires. Un noyau sur mesure vous permet d'intégrer le support pour des périphériques, qui ne sont pas présents dans le noyau [.filename]#GENERIC# comme les cartes son.

[[kernelconfig-building]]
== Compiler et installer un noyau sur mesure

Commençons par passer rapidement en revue le répertoire de configuration du noyau. Tous les chemins d'accès mentionnés seront relatifs au répertoire principal [.filename]#/usr/src/sys#, qui est également accessible via le lien symbolique [.filename]#/sys#. Il comporte un certain nombre de sous-répertoires correspondants à différentes parties du noyau, mais les plus importantes, en ce qui nous concerne, sont [.filename]#arch/conf#, où vous éditerez votre fichier configuration personnalisé, et [.filename]#compile#, qui est l'espace de travail où votre noyau sera compilé. _arch_ représente une des architectures suivante: [.filename]#i386#, soit [.filename]#alpha#, [.filename]#amd64#, [.filename]#ia64#, [.filename]#powerpc#, [.filename]#sparc64#, ou encore [.filename]#pc98# (une branche alternative de développement de l'architecture PC, populaire au Japon). Tout ce qui se trouve dans un répertoire particulier à une architecture est propre uniquement à cette architecture; le reste du code est un code indépendant du type de machine et commun à toutes les plates-formes sur lesquelles FreeBSD pourrait être potentiellement porté. Remarquez l'organisation logique de l'arborescence des répertoires, où chaque périphérique, système de fichiers, et option supportés a son propre sous-répertoire.

Les exemples de ce chapitre supposent que vous utilisez l'architecture i386. Si ce n'est pas votre cas, effectuez les ajustements appropriés au niveau des chemins d'accès pour votre architecture.

[NOTE]
====
S'il n'y a _pas_ de répertoire [.filename]#/usr/src/sys# sur votre système, alors c'est que les sources du noyau n'ont pas été installées. La manière la plus facile de les installer est d'exécuter `sysinstall` en tant que `root`, et sélectionner [.guimenuitem]#Configure#, puis [.guimenuitem]#Distributions#, [.guimenuitem]#src#, puis [.guimenuitem]#base# et [.guimenuitem]#sys#. Si vous avez une aversion envers sysinstall et que vous disposez d'un CDROM "officiel" de FreeBSD, alors vous pouvez installer les sources depuis la ligne de commande:

[source,bash]
....
# mount /cdrom
# mkdir -p /usr/src/sys
# ln -s /usr/src/sys /sys
# cat /cdrom/src/ssys.[a-d]* | tar -xzvf -
# cat /cdrom/src/sbase.[a-d]* | tar -xzvf -
....

====

Ensuite allez dans le répertoire [.filename]#arch/conf# et copiez le fichier de configuration [.filename]#GENERIC# dans un fichier qui portera le nom que vous voulez donner à votre noyau. Par exemple:

[source,bash]
....
# cd /usr/src/sys/i386/conf
# cp GENERIC MONNOYAU
....

Par tradition, c'est un nom en majuscules, et si vous maintenez plusieurs machines FreeBSD avec des configurations matérielles différentes, c'est une bonne idée de lui donner le même nom que la machine. Nous l'appellerons [.filename]#MONNOYAU# pour les besoins de cet exemple.

[TIP]
====

Conserver votre fichier de configuration du noyau directement sous [.filename]#/usr/src# peut être une mauvaise idée. Si vous avez des problèmes il peut être tentant de juste effacer [.filename]#/usr/src# et recommencer à nouveau. Après avoir fait cela ne prends que quelques secondes pour vous rendre compte que vous venez d'effacer votre fichier de configuration du noyau personnalisé. N'éditez pas, non plus, directement le fichier [.filename]#GENERIC#, il peut être écrasé à la prochaine crossref:cutting-edge[updating-upgrading,mise à jour de l'arborescence des sources], et vos modifications seraient perdues.

Vous voudrez peut être conserver votre fichier de configuration du noyau ailleurs et alors créer un lien symbolique vers le fichier dans le répertoire [.filename]#i386#.

Par exemple:

[source,bash]
....
# cd /usr/src/sys/i386/conf
# mkdir /root/noyaux
# cp GENERIC /root/noyaux/MONNOYAU
# ln -s /root/noyaux/MONNOYAU
....

====

Editez maintenant [.filename]#MONNOYAU# avec votre éditeur de texte préféré. Si vous venez tout juste de finir l'installation, le seul éditeur disponible sera probablement vi, qui est trop complexe pour être décrit ici, mais est bien expliqué dans de nombreux ouvrages de la crossref:bibliography[bibliography,bibliographie]. Cependant, FreeBSD offre un éditeur plus simple appelé ee qui, si vous êtes débutant, sera votre éditeur de choix. N'hésitez pas à modifier les commentaires d'entête pour y décrire votre configuration ou les modifications que vous avez apportés par rapport au noyau [.filename]#GENERIC#.

Si vous avez déjà compilé un noyau sur SunOS(TM) ou tout autre système d'exploitation BSD, l'essentiel de fichier vous sera familier. Si vous venez d'un système d'exploitation comme DOS, à l'inverse, le fichier de configuration [.filename]#GENERIC# vous paraîtra inintelligible, lisez alors lentement et attentivement la section sur <<kernelconfig-config,le fichier de configuration>>.

[NOTE]
====
Si vous crossref:cutting-edge[updating-upgrading,synchronisez votre arborescence des sources] avec les toutes dernières sources du projet FreeBSD, assurez-vous de toujours lire le fichier [.filename]#/usr/src/UPDATING# avant d'effectuer une quelconque opération de mise à jour. Ce fichier décrit les problèmes importants ou les domaines demandant une attention particulière dans le code mis à jour. [.filename]#/usr/src/UPDATING# correspond toujours à votre version des sources de FreeBSD, et est donc plus à jour que ce Manuel.
====

Vous devez maintenant compiler le code source du noyau.

[.procedure]
====
*Procedure: Compiler un noya*

. Passez dans le répertoire [.filename]#/usr/src#.
+
[source,bash]
....
# cd /usr/src
....
+
. Compilez le noyau:
+
[source,bash]
....
# make buildkernel KERNCONF=MONNOYAU
....
+
. Installez le nouveau noyau:
+
[source,bash]
....
# make installkernel KERNCONF=MONNOYAU
....
====

[NOTE]
====
Il est indispensable d'avoir l'intégralité des sources du système FreeBSD pour compiler le noyau.
====

[TIP]
====

Par défaut, quand vous compilez un noyau personnalisé, _tous_ les modules seront également recompilés. Si vous désirez mettre à jour un noyau plus rapidement ou compiler que certains modules, vous devez éditer le fichier [.filename]#/etc/make.conf# avant de compiler le noyau:

[.programlisting]
....
MODULES_OVERRIDE = linux acpi sound/sound sound/driver/ds1 ntfs
....

Cette variable définit une liste de modules à compiler à la place de l'intégralité des modules.

[.programlisting]
....
WITHOUT_MODULES = linux acpi sound/sound sound/driver/ds1 ntfs
....

Cette variable définit une liste de modules à exclure du processus de compilation. Pour d'autres variables qui peuvent être intéressantes pour le processus de compilation du noyau, consultez la page de manuel man:make.conf[5].
====

Le nouveau noyau sera copié dans le répertoire [.filename]#/boot/kernel# avec le nom [.filename]#/boot/kernel/kernel# et l'ancien noyau sera renommé en [.filename]#/boot/kernel.old/kernel#. Maintenant, arrêtez le système et redémarrez pour utiliser votre nouveau noyau. Si quelque chose se passe mal, il y a quelques instructions de <<kernelconfig-trouble,dépannage>> à la fin de ce chapitre que vous pourrez trouver utiles. Assurez-vous de lire la section qui explique comment revenir en arrière dans le cas où votre nouveau noyau <<kernelconfig-noboot,ne démarre pas>>.

[NOTE]
====
Les autres fichiers concernant le processus de démarrage, comme le chargeur (man:loader[8]) et la configuration du démarrage sont conservés dans le répertoire [.filename]#/boot#. Les modules tiers et personnalisés peuvent être placés dans [.filename]#/boot/kernel#, bien que les utilisateurs doivent être conscients que garder ses modules synchronisés avec le noyau compilé est très important. Les modules qui ne sont pas destinés à fonctionner avec le noyau compilé peuvent être instables et ne pas donner les résultats escomptés.
====

[[kernelconfig-config]]
== Le fichier de configuration

Le format général du fichier de configuration est assez simple. Chaque ligne est composée d'un mot-clé et d'un ou plusieurs arguments. Pour simplifier, la plupart des lignes ne contiennent qu'un seul argument. Tout ce qui suit le caractère `#` est considéré comme un commentaire et ignoré. Les sections suivantes décrivent chaque mot-clé, dans l'ordre où ils apparaissent dans le fichier [.filename]##GENERIC##. [[kernelconfig-options]] Pour une liste exhaustive des options et périphériques dépendants de l'architecture utilisée, consultez le fichier [.filename]##NOTES## présent dans le même répertoire que le fichier [.filename]##GENERIC##. Pour les options ne dépendant pas de l'architecture, consultez le fichier [.filename]##/usr/src/sys/conf/NOTES##.

[NOTE]
====
Pour compiler un fichier contenant toutes les options possibles, en général pour effectuer des tests, exécutez la commande suivante en tant que `root`:

[source,bash]
....
# cd /usr/src/sys/i386/conf  make LINT
....

====

Ce qui suit est un exemple de fichier de configuration du noyau [.filename]#GENERIC# avec divers commentaires aux endroits nécessaires pour un peu plus de clarté. Cet exemple devrait correspondre de façon très proche à votre copie du fichier [.filename]#/usr/src/sys/i386/conf/GENERIC#. 

[.programlisting]
....
machine		i386
....

C'est l'architecture de la machine. Elle doit être `alpha`, `amd64`, `i386`, `ia64`, `pc98`, `powerpc`, ou encore `sparc64`.

[.programlisting]
....
cpu          I486_CPU
cpu          I586_CPU
cpu          I686_CPU
....

Ce qui précède définit le type de CPU présent dans votre système. Il peut y avoir plusieurs occurrences de la ligne CPU (si, par exemple, vous n'êtes pas sûr de devoir utiliser `I586_CPU` ou `I686_CPU`), cependant, pour un noyau personnalisé, il est mieux de spécifier uniquement le CPU que vous avez. Si vous n'êtes pas sûr du type, vous pouvez lister le fichier [.filename]#/var/run/dmesg.boot# pour visualiser les messages de démarrage.

[.programlisting]
....
ident          GENERIC
....

C'est l'identification du noyau. Vous devriez changer cela pour le nom, quel qu'il soit, que vous donnez à votre noyau, par exemple `MONNOYAU` si vous avez suivi les instructions des exemples précédents. La valeur que vous donnez à la chaîne `ident` s'affichera au démarrage du noyau, il est donc utile de donner au nouveau noyau un nom différent si vous voulez le différencier de votre noyau habituel (e.g., vous voulez compiler un noyau expérimental).

[.programlisting]
....
#To statically compile in device wiring instead of /boot/device.hints
#hints          "GENERIC.hints"         #Default places to look for devices.
....

Le fichier man:device.hints[5] est utilisé pour configurer les paramètres des pilotes de périphériques. Le man:loader[8] recherchera le fichier [.filename]#/boot/device.hints# au démarrage. En utilisant l'option `hints` vous pouvez compiler ces valeurs en statique dans votre noyau. Il n'est alors pas utile de créer de fichier [.filename]#device.hints# dans [.filename]#/boot#.

[.programlisting]
....
makeoptions     DEBUG=-g          #Build kernel with gdb(1) debug symbols
....

Le processus normal de compilation de FreeBSD inclut les informations de débogage lors de la compilation du noyau avec l'option `-g`, qui autorisera les informations de débogage quand le noyau sera passé à man:gcc[1].

[.programlisting]
....
options          SCHED_4BSD         # 4BSD scheduler
....

L'ordonnanceur ("scheduler") traditionnel et par défaut de FreeBSD. Conservez cette ligne.

[.programlisting]
....
options          PREEMPTION         # Enable kernel thread preemption
....

Permet aux processus légers présents dans le noyau d'être devancés par des processus de priorité plus élevée. Cela améliore l'interactivité et permet aux processus d'interruption d'être exécutés le plus tôt possible au lieu d'attendre leur tour.

[.programlisting]
....
options          INET          #InterNETworking
....

Support réseau. Conservez-le, même si vous n'envisagez pas de vous connecter à un réseau. La plupart des programmes utilisent le réseau "en boucle" (i.e., établissent des connexions réseau avec le PC lui-même), cette option est donc quasiment obligatoire.

[.programlisting]
....
options          INET6          #IPv6 communications protocols
....

Ceci active les protocoles de communication IPv6.

[.programlisting]
....
options          FFS          #Berkeley Fast Filesystem
....

C'est le système de fichiers de base sur disque dur. Gardez ces options si vous démarrez depuis le disque dur.

[.programlisting]
....
options          SOFTUPDATES  #Enable FFS Soft Updates support
....

Cette option rajoutera le support des "Soft Updates" dans le noyau, ce qui aidera l'accélération des accès en écriture sur les disques. Même quand cette fonction est fournit par le noyau, elle doit être activée sur chaque disque. Regardez le résultat de la commande man:mount[8] pour voir si les "Soft Updates" sont activées sur les disques de votre système. Si vous ne voyez pas apparaître l'option `soft-updates` alors vous devrez l'activer en utilisant les commandes man:tunefs[8] (pour les systèmes de fichiers existant) ou man:newfs[8] (pour les nouveaux systèmes de fichiers).

[.programlisting]
....
options          UFS_ACL      #Support for access control lists
....

Cette option active le support des listes de contrôle d'accès au système de fichiers (ACL). Elles reposent sur l'utilisation d'attributs étendus et d'UFS2, cette fonctionnalité est décrite dans la crossref:security[fs-acl,Listes de contrôle d'accès au système de fichiers]. Les ACLs sont activées par défaut, et leur support ne devraient pas être retiré du noyau si elles ont été précédemment utilisées sur un système de fichiers, étant donné que cela supprimera les listes de contrôle d'accès changeant alors la façon dont sont protégés les fichiers d'une manière imprévisible.

[.programlisting]
....
options          UFS_DIRHASH  #Improve performance on big directories
....

Cette option inclut certaines fonctions pour accélérer les opérations disque sur de gros répertoires, aux dépens d'employer de la mémoire supplémentaire. Vous conserverez normalement cela pour un gros serveur, ou une station de travail très active, et vous l'enlèverez si vous utilisez FreeBSD sur un petit système où la mémoire prime et la vitesse d'accès disque est moins importante, comme pour un coupe-feu.

[.programlisting]
....
options          MD_ROOT      #MD is a potential root device
....

Cette option active le support pour des disques virtuels en mémoire utilisés comme périphérique racine.

[.programlisting]
....
options          NFSCLIENT         # Network Filesystem Client
options          NFSSERVER         # Network Filesystem Server
options          NFS_ROOT          # NFS usable as /, requires NFSCLIENT
....

Le système de fichiers réseau. A moins que vous n'envisagiez de monter des partitions d'un serveur de fichiers UNIX(R) par l'intermédiaire d'un réseau TCP/IP, vous pouvez mettre en commentaire ces options.

[.programlisting]
....
options          MSDOSFS      #MSDOS Filesystem
....

Le système de fichiers MS-DOS(R). A moins que vous n'envisagiez de monter une partition DOS d'un disque dur au démarrage, vous pouvez sans risque commenter cette option. Le module sera automatiquement chargé la première fois que vous monterez une partition DOS, comme décrit plus haut. Par ailleurs, l'excellent logiciel package:emulators/mtools[] vous permet d'accéder à des disquettes DOS sans avoir besoin de les monter (et ne requiert pas non plus `MSDOSFS`).

[.programlisting]
....
options          CD9660       #ISO 9660 Filesystem
....

Le système de fichiers ISO 9660 pour les CDROMs. Commentez ces options si vous n'avez pas de lecteur de CDROM ou que vous ne montez qu'occasionnellement des CDROMs (il sera chargé dynamiquement dès que vous monterez un CDROM). Les CDROMs audios n'ont pas besoin de ce système de fichiers.

[.programlisting]
....
options          PROCFS            # Process filesystem (requires PSEUDOFS)
....

Le système de fichiers pour les processus. C'est un "pseudo-système" de fichiers monté sur [.filename]#/proc# qui permet à des programmes comme man:ps[1] de vous fournir plus d'informations sur les processus qui tournent sur le système. L'utilisation de `PROCFS` n'est pas nécessaire la plupart du temps, comme la majeur partie des outils de débogage et de monitoring ont été adaptés pour s'exécuter sans `PROCFS`: les nouvelles installations ne monteront pas par défaut ce système de fichiers.

[.programlisting]
....
options          PSEUDOFS     #Pseudo-filesystem framework
....

Les noyaux 6.X faisant usage du système `PROCFS` doivent également inclure le support pour `PSEUDOFS`.

[.programlisting]
....
options          GEOM_GPT          # GUID Partition Tables.
....

Cette option apporte la possibilité d'avoir un grand nombre de partitions sur un seul disque.

[.programlisting]
....
options          COMPAT_43    #Compatible with BSD 4.3 [KEEP THIS!]
....

Compatibilité avec 4.3BSD. Conservez cette option; certains programmes auront un comportement bizarre si vous la commentez.

[.programlisting]
....
options          COMPAT_FREEBSD4     #Compatible with FreeBSD4
....

Cette option est nécessaires aux systèmes i386(TM) et Alpha fonctionnant sous FreeBSD 5.X pour supporter les applications compilées sur d'anciennes version de FreeBSD qui utilisent d'anciennes interfaces d'appel système. Il est recommandé d'utiliser cette option sur tous les systèmes i386(TM) et Alpha susceptibles d'exécuter d'anciennes applications; les plateformes apparues sous FreeBSD 5.0, comme l'ia64 et sparc64, n'ont pas besoin de cette option.

[.programlisting]
....
options          COMPAT_FREEBSD5   # Compatible with FreeBSD5
....

Cette option est nécessaire sous FreeBSD 6.X et versions supérieures pour supporter les applications compilées sous FreeBSD 5.X et qui utilisent les interfaces d'appel système FreeBSD 5.X.

[.programlisting]
....
options          SCSI_DELAY=5000    #Delay (in ms) before probing SCSI
....

Cette option oblige le noyau à attendre 5 secondes avant de rechercher les périphériques SCSI présents sur votre système. Si vous n'avez que des disques IDE, vous pouvez l'ignorer, sinon vous pouvez essayer de diminuer cette valeur, pour accélérer le démarrage du système. Bien sûr, si vous le faites, et que FreeBSD a du mal à reconnaître vos périphériques SCSI, vous devrez l'augmenter à nouveau.

[.programlisting]
....
options          KTRACE              #ktrace(1) support
....

Ceci permet de tracer le processus du noyau, ce qui est utile pour le débogage.

[.programlisting]
....
options          SYSVSHM             #SYSV-style shared memory
....

Cette option implémente la mémoire partagée System V. L'usage le plus courant qui en est fait est l'extension XSHM d'X, dont de nombreux logiciels gourmants en graphique tireront automatiquement parti pour fonctionner plus vite. Si vous utilisez X, vous utiliserez absolument cette option.

[.programlisting]
....
options          SYSVMSG             #SYSV-style message queues
....

Support des messages System V. Cette option n'augmente que de quelques centaines d'octets la taille du noyau.

[.programlisting]
....
options          SYSVSEM             #SYSV-style semaphores
....

Support des sémaphores System V. D'un usage moins courant, mais n'augmente la taille du noyau que de quelques centaines d'octets.

[NOTE]
====
L'option `-p` de la commande man:ipcs[1] donnera la liste des processus utilisant chacun de ces mécanismes System V.
====

[.programlisting]
....
options 	     _KPOSIX_PRIORITY_SCHEDULING # POSIX P1003_1B real-time extensions
....

Extensions temps-réel ajoutées dans la norme POSIX(R) 1993. Certaines applications du catalogue des logiciels portés les utilisent (comme StarOffice(TM)).

[.programlisting]
....
options          KBD_INSTALL_CDEV  # install a CDEV entry in /dev
....

Cette option concerne le clavier. Elle installe une entrée CDEV dans le répertoire [.filename]#/dev#.

[.programlisting]
....
options          ADAPTIVE_GIANT    # Giant mutex is adaptive.
....

"Giant" est le nom d'un mécanisme d'exclusion mutuelle (un "mutex" dormant) qui protège l'accès à un ensemble important de ressources du noyau. Aujourd'hui c'est un goulot d'étranglement des performances inacceptable que l'on est en train de remplacer activement par des verrous qui protègent les ressources individuelles. L'option `ADAPTIVE_GIANT` permet à Giant d'être inclus dans l'ensemble des mutex lancés de manière adaptative. C'est à dire, quand un thread désire verrouiller le mutex Giant, mais que ce dernier est déjà verrouillé par un thread sur un autre CPU, le premier thread continuera à fonctionner et attendra la libération du verrou. Normalement, le thread retournera à l'état dormant et attendra une nouvelle chance de pouvoir s'exécuter. Si vous n'êtes pas sûr, laissez la configuration en l'état.

[.programlisting]
....
device          apic               # I/O APIC
....

Le périphérique apic active l'utilisation de l'E/S APIC pour l'acheminement des interruptions. Le périphérique apic peut être utilisé dans les noyaux UP (monoprocesseur) et SMP, mais est requis pour les noyaux SMP. Ajoutez `options SMP` pour inclure le support pour plusieurs processeurs.

[NOTE]
====
Le périphérique apic n'existe que sur l'architecture i386, cette ligne de configuration ne doit pas être utilisée sur d'autres architectures.
====

[.programlisting]
....
device          eisa
....

Rajoutez cela si vous avez une carte mère EISA. Cela permet l'auto-détection et la configuration de tous les périphériques présents sur le bus EISA.

[.programlisting]
....
device          pci
....

Ajoutez cette option si vous avez une carte mère PCI. Cela permet l'auto-détection des cartes PCI et gère l'interface entre les bus PCI et ISA.

[.programlisting]
....
# Floppy drives
device          fdc
....

C'est le contrôleur de lecteur de disquettes.

[.programlisting]
....
# ATA and ATAPI devices
device          ata
....

Ce pilote supporte tous les périphériques ATA et ATAPI. Vous n'avez besoin que d'une seule ligne `device ata` pour que le noyau détecte tous les périphériques PCI ATA/ATAPI sur les machines modernes.

[.programlisting]
....
device          atadisk                 # ATA disk drives
....

Ceci est requis avec `device ata` pour les disques ATA.

[.programlisting]
....
device          ataraid                 # ATA RAID drives
....

Ceci est nécessaire avec `device ata` pour les disques RAID ATA.

[.programlisting]
....

device          atapicd                 # ATAPI CDROM drives
....

Ceci est nécessaire avec `device ata` pour le support des lecteurs de CDROM ATAPI.

[.programlisting]
....
device          atapifd                 # ATAPI floppy drives
....

Ceci est nécessaire avec `device ata` pour le support des lecteurs de disquettes ATAPI.

[.programlisting]
....
device          atapist                 # ATAPI tape drives
....

Ceci est nécessaire avec `device ata` pour le support des lecteurs de bande ATAPI.

[.programlisting]
....
options         ATA_STATIC_ID           #Static device numbering
....

Cela rend la numérotation des périphériques statique, sans cela l'allocation des numéros de périphériques sera dynamique.

[.programlisting]
....
# SCSI Controllers
device          ahb        # EISA AHA1742 family
device          ahc        # AHA2940 and onboard AIC7xxx devices
options         AHC_REG_PRETTY_PRINT    # Print register bitfields in debug
                                        # output.  Adds ~128k to driver.
device          ahd        # AHA39320/29320 and onboard AIC79xx devices
options         AHD_REG_PRETTY_PRINT    # Print register bitfields in debug
                                        # output.  Adds ~215k to driver.
device          amd        # AMD 53C974 (Teckram DC-390(T))
device          isp        # Qlogic family
#device         ispfw      # Firmware for QLogic HBAs- normally a module
device          mpt        # LSI-Logic MPT-Fusion
#device         ncr        # NCR/Symbios Logic
device          sym        # NCR/Symbios Logic (newer chipsets + those of `ncr')
device          trm        # Tekram DC395U/UW/F DC315U adapters

device          adv        # Advansys SCSI adapters
device          adw        # Advansys wide SCSI adapters
device          aha        # Adaptec 154x SCSI adapters
device          aic        # Adaptec 15[012]x SCSI adapters, AIC-6[23]60.
device          bt         # Buslogic/Mylex MultiMaster SCSI adapters

device          ncv        # NCR 53C500
device          nsp        # Workbit Ninja SCSI-3
device          stg        # TMC 18C30/18C50
....

Contrôleurs SCSI. Mettez en commentaires ceux que vous n'avez pas sur votre système. Si vous n'avez qu'un système IDE, vous pouvez supprimer toutes ces lignes. Les lignes `*_REG_PRETTY_PRINT` sont des options de débogage pour leur pilote respectif.

[.programlisting]
....
# SCSI peripherals
device          scbus      # SCSI bus (required for SCSI)
device          ch         # SCSI media changers
device          da         # Direct Access (disks)
device          sa         # Sequential Access (tape etc)
device          cd         # CD
device          pass       # Passthrough device (direct SCSI access)
device          ses        # SCSI Environmental Services (and SAF-TE)
....

Périphériques SCSI. A nouveau, mettez en commentaires tous ceux que vous n'avez pas, ou si vous n'avez que du matériel IDE, vous pouvez tous les supprimer.

[NOTE]
====
Le pilote USB man:umass[4] et quelques autres pilotes utilisent le sous-système SCSI même si ce ne sont pas de véritables périphériques SCSI. Par conséquent assurez-vous de ne pas retirer le support SCSI si un tel pilote fait partie de la configuration du noyau.
====

[.programlisting]
....
# RAID controllers interfaced to the SCSI subsystem
device          amr        # AMI MegaRAID
device          arcmsr     # Areca SATA II RAID
device          asr        # DPT SmartRAID V, VI and Adaptec SCSI RAID
device          ciss       # Compaq Smart RAID 5*
device          dpt        # DPT Smartcache III, IV - See NOTES for options
device          hptmv      # Highpoint RocketRAID 182x
device          rr232x     # Highpoint RocketRAID 232x
device          iir        # Intel Integrated RAID
device          ips        # IBM (Adaptec) ServeRAID
device          mly        # Mylex AcceleRAID/eXtremeRAID
device          twa        # 3ware 9000 series PATA/SATA RAID

# RAID controllers
device          aac        # Adaptec FSA RAID
device          aacp       # SCSI passthrough for aac (requires CAM)
device          ida        # Compaq Smart RAID
device          mfi        # LSI MegaRAID SAS
device          mlx        # Mylex DAC960 family
device          pst        # Promise Supertrak SX6000
device          twe        # 3ware ATA RAID
....

Contrôleurs RAID supportés. Si vous n'avez aucun de ces derniers dans votre système, vous pouvez les mettre en commentaires ou les supprimer.

[.programlisting]
....
# atkbdc0 controls both the keyboard and the PS/2 mouse
device          atkbdc     # AT keyboard controller
....

Le contrôleur du clavier (`atkbdc`) permet de gérer les E/S du clavier AT et des périphériques de pointage PS/2. Ce contrôleur est nécessaire au pilote de périphérique du clavier (`atkbd`) et celui des périphériques de pointage PS/2 (`psm`).

[.programlisting]
....
device          atkbd      # AT keyboard
....

Le pilote de périphérique `atkbd`, associé au contrôleur `atkbdc`, fournit un accès au clavier AT 84 touches ou au clavier AT étendu qui est connecté au contrôleur de clavier de la machine.

[.programlisting]
....
device          psm        # PS/2 mouse
....

Utilisez ce périphérique si votre souris se branche sur le port PS/2.

[.programlisting]
....
device          kbdmux        # keyboard multiplexer
....

Support de base pour le multiplexage de claviers. Si vous n'avez pas l'intention d'utiliser sur le système plus d'un clavier, vous pouvez supprimer cette ligne sans risque.

[.programlisting]
....
device          vga        # VGA video card driver
....

Pilote de la carte graphique.

[.programlisting]
....

device          splash     # Splash screen and screen saver support
....

Ecran/bannière de démarrage. Les économiseurs d'écran ont également besoin de ce pseudo-périphérique.

[.programlisting]
....
# syscons is the default console driver, resembling an SCO console
device          sc
....

`sc` est le pilote par défaut pour la console, qui ressemble à une console SCO. Comme la plupart des programmes en mode plein-écran accèdent à la console par l'intermédiaire d'une base de données de description des terminaux comme [.filename]#termcap#, cela n'a guère d'importance que vous choisissiez ce pilote ou `vt`, le pilote compatible `VT220`. Quand vous ouvrez une session, positionnez votre variable d'environnement `TERM` à `scoansi` si vous avez des problèmes pour utiliser des programmes en mode plein-écran avec cette console.

[.programlisting]
....
# Enable this for the pcvt (VT220 compatible) console driver
#device          vt
#options         XSERVER          # support for X server on a vt console
#options         FAT_CURSOR       # start with block cursor
....

C'est le pilote de console compatible VT220, et, rétrospectivement, compatible VT100/102. Il fonctionne bien sur certains ordinateurs portables qui sont matériellement incompatibles avec le pilote `sc`. Comme précédemment, positionnez la variable d'environnement `TERM` lorsque que vous ouvrez une session, mais cette fois-ci à `vt100` ou `vt220`. Ce pilote peut aussi s'avérer utile quand vous vous connectez à un grand nombre de machines différentes par le réseau sur lesquelles les entrées pour le périphérique `sc` ne sont souvent pas définies dans leurs fichiers [.filename]#termcap# ou [.filename]#terminfo# - alors que le terminal `vt100` devrait être disponible sur pratiquement toutes les plates-formes.

[.programlisting]
....
device          agp
....

Ajoutez cette option si vous avez une carte AGP dans votre système. Cela activera le support AGP, et l'AGP GART pour les cartes qui ont cette fonction.

[.programlisting]
....
# Power management support (see NOTES for more options)
device          apm
....

"Advanced Power Management support" - gestion avancée de l'énergie. Utile pour les ordinateurs portables, ceci est cependant désactivé par défaut dans le noyau [.filename]#GENERIC# sous FreeBSD 5.X et versions suivantes

[.programlisting]
....
# Add suspend/resume support for the i8254.
device           pmtimer
....

Pilote du périphérique de gestion du temps pour les événements de la gestion de l'énergie, comme l'APM ou l'ACPI.

[.programlisting]
....
# PCCARD (PCMCIA) support
# PCMCIA and cardbus bridge support
device          cbb               # cardbus (yenta) bridge
device          pccard            # PC Card (16-bit) bus
device          cardbus           # CardBus (32-bit) bus
....

Support PCMCIA. Vous en avez besoin si vous utilisez un ordinateur portable.

[.programlisting]
....
# Serial (COM) ports
device          sio               # 8250, 16[45]50 based serial ports
....

Cela représente les ports séries, appelés ports [.filename]#COM# dans le monde MS-DOS(R)/Windows(R).

[NOTE]
====
Si vous avez un modem interne sur le port [.filename]#COM4# et un port série [.filename]#COM2#, vous devrez changer l'IRQ du modem en 2 (pour d'obscures raisons techniques, IRQ 2 = IRQ 9) pour y accéder avec FreeBSD. Si vous avez une carte série multi-ports, consultez la page de manuel de man:sio[4] pour plus d'informations sur les bonnes valeurs à ajouter à votre fichier [.filename]#/boot/device.hints#. Certaines cartes vidéo (notamment celle à base de circuits S3) utilisent des adresses d'E/S sous la forme `0x*2e8`, et comme de nombreuses cartes séries bon marché de décodent pas complètement l'espace d'adresse d'E/S 16 bits, il y a aura des conflits avec ces cartes, rendant le port [.filename]#COM4# pratiquement inutilisable.

Chaque port série doit avoir une IRQ unique (à moins que vous n'utilisiez une carte multi-ports qui autorise le partage d'interruption), donc les IRQs par défaut pour les ports [.filename]#COM3# et [.filename]#COM4# ne peuvent être utilisées.
====

[.programlisting]
....
# Parallel port
device          ppc
....

C'est l'interface parallèle du bus ISA.

[.programlisting]
....
device          ppbus      # Parallel port bus (required)
....

Fournit le support pour le bus du port parallèle.

[.programlisting]
....
device          lpt        # Printer
....

Support pour les imprimantes parallèles.

[NOTE]
====
Les trois lignes précédentes sont nécessaires pour permettre le support des imprimantes parallèles.
====

[.programlisting]
....
device          plip       # TCP/IP over parallel
....

C'est le pilote pour l'interface réseau sur port parallèle.

[.programlisting]
....
device          ppi        # Parallel port interface device
....

Port d'E/S d'usage général ("geek port") + port d'E/S IEEE1284.

[.programlisting]
....
#device         vpo        # Requires scbus and da
....

Ceci est pour le lecteur Zip de Iomega. Les options `scbus` et `da` sont également requises. Les meilleures performances sont obtenues avec les ports configurés dans le mode EPP 1.9.

[.programlisting]
....
#device         puc
....

Décommentez ce périphérique si vous disposez d'une carte PCI série ou parallèle "idiote" qui est supportée par le pilote man:puc[4].

[.programlisting]
....
# PCI Ethernet NICs.
device          de         # DEC/Intel DC21x4x (Tulip)
device          em         # Intel PRO/1000 adapter Gigabit Ethernet Card
device          ixgb       # Intel PRO/10GbE Ethernet Card
device          txp        # 3Com 3cR990 (Typhoon)
device          vx         # 3Com 3c590, 3c595 (Vortex)
....

Divers pilotes de cartes réseaux PCI. Mettez en commentaires ou supprimer les lignes de celles qui ne sont pas présentes sur votre système.

[.programlisting]
....
# PCI Ethernet NICs that use the common MII bus controller code.
# NOTE: Be sure to keep the 'device miibus' line in order to use these NICs!
device          miibus     # MII bus support
....

Le support du bus MII est nécessaire pour certaines cartes Ethernet PCI 10/100, à savoir celles qui utilisent des interfaces compatibles MII ou implémentent une gestion de l'interface opérant comme le bus MII. Ajouter `device miibus` à la configuration du noyau intègre le support pour l'API miibus générique et tous les pilotes d'interfaces PHY, incluant un pilote générique pour les interfaces PHYs qui ne sont pas spécifiquements gérées par un pilote individuel.

[.programlisting]
....
device          bce        # Broadcom BCM5706/BCM5708 Gigabit Ethernet
device          bfe        # Broadcom BCM440x 10/100 Ethernet
device          bge        # Broadcom BCM570xx Gigabit Ethernet
device          dc         # DEC/Intel 21143 and various workalikes
device          fxp        # Intel EtherExpress PRO/100B (82557, 82558)
device          lge        # Level 1 LXT1001 gigabit ethernet
device          msk        # Marvell/SysKonnect Yukon II Gigabit Ethernet
device          nge        # NatSemi DP83820 gigabit ethernet
device          nve        # nVidia nForce MCP on-board Ethernet Networking
device          pcn        # AMD Am79C97x PCI 10/100 (precedence over 'lnc')
device          re         # RealTek 8139C+/8169/8169S/8110S
device          rl         # RealTek 8129/8139
device          sf         # Adaptec AIC-6915 (Starfire)
device          sis        # Silicon Integrated Systems SiS 900/SiS 7016
device          sk         # SysKonnect SK-984x  SK-982x gigabit Ethernet
device          ste        # Sundance ST201 (D-Link DFE-550TX)
device          stge       # Sundance/Tamarack TC9021 gigabit Ethernet
device          ti         # Alteon Networks Tigon I/II gigabit Ethernet
device          tl         # Texas Instruments ThunderLAN
device          tx         # SMC EtherPower II (83c170 EPIC)
device          vge        # VIA VT612x gigabit ethernet
device          vr         # VIA Rhine, Rhine II
device          wb         # Winbond W89C840F
device          xl         # 3Com 3c90x (Boomerang, Cyclone)
....

Pilotes qui utilisent le code du contrôleur du bus MII.

[.programlisting]
....
# ISA Ethernet NICs.  pccard NICs included.
device          cs         # Crystal Semiconductor CS89x0 NIC
# 'device ed' requires 'device miibus'
device          ed         # NE[12]000, SMC Ultra, 3c503, DS8390 cards
device          ex         # Intel EtherExpress Pro/10 and Pro/10+
device          ep         # Etherlink III based cards
device          fe         # Fujitsu MB8696x based cards
device          ie         # EtherExpress 8/16, 3C507, StarLAN 10 etc.
device          lnc        # NE2100, NE32-VL Lance Ethernet cards
device          sn         # SMC's 9000 series of Ethernet chips
device          xe         # Xircom pccard Ethernet

# ISA devices that use the old ISA shims
#device         le
....

Pilotes pour les cartes Ethernet ISA. Consultez le fichier [.filename]#/usr/src/sys/i386/conf/NOTES# pour savoir quelles cartes sont supportées et par quel pilote.

[.programlisting]
....
# Wireless NIC cards
device          wlan            # 802.11 support
....

Support 802.11 générique. Cette ligne est nécessaire pour le réseau sans fil.

[.programlisting]
....
device          wlan_wep        # 802.11 WEP support
device          wlan_ccmp       # 802.11 CCMP support
device          wlan_tkip       # 802.11 TKIP support
....

Support pour le chiffrage pour les périphériques 802.11. Ces lignes sont nécessaires si vous avez l'intention d'utiliser le chiffrage et les protocoles de sécurité 802.11i.

[.programlisting]
....
device          an         # Aironet 4500/4800 802.11 wireless NICs.
device          ath             # Atheros pci/cardbus NIC's
device          ath_hal         # Atheros HAL (Hardware Access Layer)
device          ath_rate_sample # SampleRate tx rate control for ath
device          awi        # BayStack 660 and others
device          ral        # Ralink Technology RT2500 wireless NICs.
device          wi         # WaveLAN/Intersil/Symbol 802.11 wireless NICs.
#device         wl         # Older non 802.11 Wavelan wireless NIC.
....

Support pour diverses cartes réseau sans fil.

[.programlisting]
....
# Pseudo devices
device   loop          # Network loopback
....

C'est l'interface générique en boucle de TCP/IP. Si vous employez telnet ou FTP sur `localhost` (aussi connu en tant qu'adresse `127.0.0.1`) la réponse vous parviendra via ce pseudo-périphérique. Ceci est _obligatoire_.

[.programlisting]
....
device   random        # Entropy device
....

Générateur de nombres aléatoire sécurisé pour les applications de chiffrement.

[.programlisting]
....
device   ether         # Ethernet support
....

`ether` ne sert que si vous avez une carte Ethernet. Cela intègre le code générique pour le protocole Ethernet.

[.programlisting]
....
device   sl            # Kernel SLIP
....

`sl` est le support pour le protocole SLIP. Il a été presque entièrement supplanté par le protocole PPP, plus facile à mettre en oeuvre, mieux adapté aux connexions par modem, et aussi plus puissant.

[.programlisting]
....
device   ppp           # Kernel PPP
....

C'est le support intégré au noyau du protocole PPP pour les connexions par modem. Il y a aussi une version de PPP sous forme de programme utilisateur qui utilise `tun` et offre plus de souplesse et de possibilités comme la connexion à la demande.

[.programlisting]
....
device   tun           # Packet tunnel.
....

Ceci est utilisé par le programme PPP en mode utilisateur. Voyez la section <<userppp,PPP>> de ce manuel pour plus d'informations.

[.programlisting]
....

device   pty           # Pseudo-ttys (telnet etc)
....

C'est un "pseudo-terminal" ou un port simulant une session. Il est utilisé par les sessions `telnet` et `rlogin` entrantes, par xterm, et d'autres applications comme Emacs.

[.programlisting]
....
device   md            # Memory disks
....

Pseudo-périphérique de disque mémoire.

[.programlisting]
....
device   gif     # IPv6 and IPv4 tunneling
....

Ceci implémente l'encapsulation du protocole IPv6 par dessus l'IPv4, l'IPv4 par dessus l'IPv6, l'encapsulation IPv4 par dessus l'IPv4, et IPv6 par dessus IPv6. Le périphérique `gif`"s'auto-duplique", et créera les fichiers spéciaux de périphérique en fonction des besoins.

[.programlisting]
....
device   faith   # IPv6-to-IPv4 relaying (translation)
....

Ce pseudo-périphérique capture les paquets qui lui sont envoyés et les détourne vers le "daemon" de translation IPv4/IPv6.

[.programlisting]
....
# The `bpf' device enables the Berkeley Packet Filter.
# Be aware of the administrative consequences of enabling this!
# Note that 'bpf' is required for DHCP.
device   bpf           # Berkeley packet filter
....

C'est le filtre de paquets de Berkeley. Ce pseudo-périphérique permet de placer les interfaces en mode "promiscuous" (indiscret), pour capturer chaque paquet sur réseau de diffusion (e.g., un réseau Ethernet). Ces paquets peuvent être enregistrés sur le disque et/ou examinés avec le programme man:tcpdump[1].

[NOTE]
====
Le périphérique man:bpf[4] est également utilisé par man:dhclient[8] pour obtenir une adresse IP du routeur par défaut (passerelle) et ainsi de suite. Si vous utilisez DHCP, conservez cette ligne non commentée.
====

[.programlisting]
....
# USB support
device          uhci          # UHCI PCI-USB interface
device          ohci          # OHCI PCI-USB interface
device          ehci          # EHCI PCI-USB interface (USB 2.0)
device          usb           # USB Bus (required)
#device         udbp          # USB Double Bulk Pipe devices
device          ugen          # Generic
device          uhid          # Human Interface Devices
device          ukbd          # Keyboard
device          ulpt          # Printer
device          umass         # Disks/Mass storage - Requires scbus and da
device          ums           # Mouse
device          ural          # Ralink Technology RT2500USB wireless NICs
device          urio          # Diamond Rio 500 MP3 player
device          uscanner      # Scanners
# USB Ethernet, requires mii
device          aue           # ADMtek USB Ethernet
device          axe           # ASIX Electronics USB Ethernet
device          cdce          # Generic USB over Ethernet
device          cue           # CATC USB Ethernet
device          kue           # Kawasaki LSI USB Ethernet
device          rue           # RealTek RTL8150 USB Ethernet
....

Support pour divers périphériques USB.

[.programlisting]
....
# FireWire support
device          firewire      # FireWire bus code
device          sbp           # SCSI over FireWire (Requires scbus and da)
device          fwe           # Ethernet over FireWire (non-standard!)
....

Support pour divers périphériques Firewire.

Pour plus d'informations et pour avoir la liste de périphériques supplémentaires supportés par FreeBSD, voyez le fichier [.filename]#/usr/src/sys/i386/conf/NOTES#.

=== Configurations mémoire importantes (PAE)

Les machines à configuration mémoire importante ont besoin de pouvoir accéder à plus d'espace mémoire utilisateur et noyau que la limite des 4 gigaoctets de l'espace d'adresse noyau+utilisateur ("Kernel Virtual Address"-KVA). En raison de cette limite, Intel a ajouté le support d'adresses physiques sur 36 bits pour l'espace d'adresses dans les familles de microprocesseurs Pentium(R) Pro et suivantes.

L'extension de l'adressage physique-,"Physical Address Extension" (PAE) est une caractéristique des microprocesseurs Intel(R) Pentium(R) Pro et suivants autorisant les configurations mémoires jusqu'à 64 gigaoctets. FreeBSD fournit un support pour cette caratéristique via l'option de configuration du noyau `PAE`, disponible sous toutes les versions actuelles de FreeBSD. En raison des limitations de l'architecture mémoire Intel(R), aucune distinction n'est faite entre la mémoire au-dessus et en-dessous de 4 gigaoctets. La mémoire allouée au-dessus de 4 gigaoctets est simplement ajoutée à l'ensemble de la mémoire disponible.

Pour activer le support PAE dans le noyau, ajoutez simplement la ligne suivante dans votre fichier de configuration du noyau:

[.programlisting]
....
options		PAE
....

[NOTE]
====
Le support PAE sous FreeBSD est uniquement disponible pour les processeurs IA-32 d'Intel(R). Il doit être noté que le support PAE sous FreeBSD n'a pas été énormément testé, et devrait être considéré comme bêta comparé aux autres fonctionnalités stables de FreeBSD.
====

Le support PAE sous FreeBSD a quelques limitations:

* Un processus est incapable d'accéder à plus de 4 gigaoctets d'espace mémoire.
* Les modules KLD ne peuvent être chargés dans un noyau avec PAE activé, en raison des différences entre la structure d'un module et du noyau.
* Les pilotes de périphériques qui n'utilisent pas l'interface man:bus_dma[9] seront à l'origine de corruption de données avec un noyau PAE et ne sont pas recommandés. Pour cette raison, le fichier de configuration du noyau avec support [.filename]#PAE# qui est fourni avec FreeBSD exclut tous les pilotes connus pour ne pas fonctionner avec un noyau avec support PAE.
* Certains paramètres modifiables du système déterminent l'utilisation des ressources mémoire par la quantité de la mémoire physique disponible. De tels paramètres peuvent être inutilement sur-alloués en raison de la grande quantité de mémoire d'un système PAE. Un bon exemple est le "sysctl" `kern.maxvnodes`, qui contrôle le nombre maximal de "vnodes" alloués par le noyau. Il est recommandé d'ajuster ce dernier et les autres paramètres du même genre à des valeurs raisonnables.
* Il pourra être nécessaire d'augmenter l'espace d'adressage virtuel du noyau ("kernel virtual address"-KVA) ou de réduire le montant de la ressource spécifique du noyau qui est fortement utilisée (voir plus haut) afin d'éviter l'épuisement de l'espace KVA. L'option du noyau `KVA_PAGES` peut être employée pour augmenter l'espace KVA.

Pour des considérations de performance et de stabilité, il est recommandé de consulter la page de manuel man:tuning[7]. La page de manuel man:pae[4] contient des informations à jour sur le support PAE sous FreeBSD.

[[kernelconfig-trouble]]
== Si quelque chose se passe mal

Il y a cinq types de problèmes qui peuvent survenir lors de la compilation d'un noyau sur mesure. Ce sont:

La commande `config` échoue:::
Si la commande man:config[8] échoue quand vous lui passez en paramètre la description de votre noyau, vous avez probablement fait une simple erreur quelque part. Heureusement man:config[8] affichera le numéro de la ligne qui lui a posé problème, vous pouvez donc localiser rapidement la ligne contenant l'erreur. Par exemple, si vous avez:
+
[source,bash]
....
config: line 17: syntax error
....
+
Vérifiez que la ligne est correctement écrite, en le comparant avec le noyau [.filename]#GENERIC# ou une autre référence.

La commande `make` échoue:::
Si la commande `make` échoue, cela signale habituellement une erreur dans la description de votre noyau, mais qui n'est pas suffisamment sérieuse pour que la commande man:config[8] la détecte. A nouveau, vérifiez votre fichier de configuration, et si vous n'arrivez toujours pas à résoudre le problème, envoyez un courrier électronique à la {freebsd-questions} en joignant votre fichier de configuration du noyau, le diagnostic devrait être rapide.

Le noyau ne démarre pas:[[kernelconfig-noboot]]::
Si votre nouveau noyau ne démarre pas, ou ne reconnaît pas vos périphériques, ne paniquez pas! Heureusement, FreeBSD dispose d'un excellent mécanisme pour récupérer si le noyau ne fonctionne pas. Sélectionnez simplement le noyau, à partir duquel vous désirez démarrer, à l'invite du chargeur de FreeBSD. Vous pouvez y accéder quand le menu de démarrage apparaît. Sélectionner l'option 6, "Escape to a loader prompt". A l'invite, tapez `unload kernel` et ensuite `boot /boot/kernel.old/kernel`, ou le nom de fichier d'un autre noyau qui pourra démarrer proprement. Quand on reconfigure un noyau, il est toujours bon de conserver à portée de la main un noyau dont on sait qu'il fonctionne.
+
Après avoir démarré avec un noyau en état de marche, vous pouvez revérifier votre fichier de configuration et essayer de recompiler à nouveau votre noyau. Une ressource utile est le fichier [.filename]#/var/log/messages# qui enregistre, entre autres, tous les messages du noyau à chaque démarrage réussi. En outre, la commande man:dmesg[8] affichera les messages du noyau pour le dernier démarrage.
+
[NOTE]
====
Si vous avez des difficultés à compiler un noyau, veillez à conserver un noyau [.filename]#GENERIC#, ou un autre noyau dont vous savez qu'il fonctionne, sous la main, avec un nom différent de sorte qu'il ne soit pas écrasé à la prochaine compilation. Vous ne pouvez pas faire confiance au noyau [.filename]#kernel.old# parce qu'en installant un nouveau noyau, [.filename]#kernel.old# est remplacé par le dernier noyau installé dont il n'est pas certain qu'il soit opérationnel. Aussi, dès que possible, déplacez le noyau opérationnel vers le bon emplacement [.filename]#/boot/kernel# où des commandes comme man:ps[1] pourront ne pas fonctionner correctement. Pour cela, renommez le répertoire contenant le bon noyau:

[source,bash]
....
# mv /boot/kernel /boot/kernel.bad
# mv /boot/kernel.good /boot/kernel
....

====

Le noyau est opérationnel, mais la commande `ps` ne fonctionne plus du tout:::
Si vous avez installé une version du noyau différente de celle avec laquelle ont été compilés les utilitaires système, par exemple, un noyau -CURRENT sur un système -RELEASE, de nombreuses commandes d'affichage de l'état du système comme man:ps[1] and man:vmstat[8] ne fonctionneront plus. Vous devrez crossref:cutting-edge[makeworld,recompiler et installer un système] avec la même version de l'arborescence des sources de celle utilisée pour votre noyau. C'est une des raisons pour lesquelles il n'est pas judicieux d'utiliser des versions différentes du noyau et du reste du système d'exploitation.
