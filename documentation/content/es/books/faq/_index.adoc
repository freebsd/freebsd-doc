---
title: Preguntas Frecuentes para FreeBSD 9.X y 10.X
authors: 
  - author: El proyecto de documentación de FreeBSD
releaseinfo: "$FreeBSD$" 
trademarks: ["freebsd", "ibm", "ieee", "adobe", "intel", "linux", "microsoft", "opengroup", "sun", "netbsd", "general"] 
---

= Preguntas Frecuentes para FreeBSD 9.X y 10.X
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:xrefstyle: basic
:relfileprefix: ../
:outfilesuffix:
:sectnums:
:sectnumlevels: 6
:partnums:
:source-highlighter: rouge
:experimental:
:lang: es
:toc-title: Tabla de contenidos
:part-signifier: Parte
:chapter-signifier: Capítulo
:appendix-caption: Apéndice
:table-caption: Tabla
:figure-caption: Figura
:example-caption: Ejemplo
:rel-numbranch: 3
:rel-head: 13-CURRENT
:rel-head-relx: 13.X
:rel-head-releng: head/
:rel-relx: 12.X
:rel-stable: 12-STABLE
:rel-releng: stable/12/
:rel-relengdate: December 2018
:rel2-relx: 11.X
:rel2-stable: 11-STABLE
:rel2-releng: stable/11/
:rel2-relengdate: October 2016

ifeval::["{backend}" == "html5"]
include::shared/mirrors.adoc[]
include::shared/authors.adoc[]
include::shared/releases.adoc[]
include::shared/es/mailing-lists.adoc[]
include::shared/es/teams.adoc[]
include::shared/es/urls.adoc[]
endif::[]

ifeval::["{backend}" == "pdf"]
include::../../../../shared/mirrors.adoc[]
include::../../../../shared/authors.adoc[]
include::../../../../shared/releases.adoc[]
include::../../../../shared/es/mailing-lists.adoc[]
include::../../../../shared/es/teams.adoc[]
include::../../../../shared/es/urls.adoc[]
endif::[]

ifeval::["{backend}" == "epub3"]
include::../../../../shared/mirrors.adoc[]
include::../../../../shared/authors.adoc[]
include::../../../../shared/releases.adoc[]
include::../../../../shared/es/mailing-lists.adoc[]
include::../../../../shared/es/teams.adoc[]
include::../../../../shared/es/urls.adoc[]
endif::[]

[.abstract-title]
Resumen

Estas son las Preguntas Frencuentes FAQ para FreeBSD en sus versiones 9.__X__ y 10.__X__. Se han realizado muchos esfuerzos para hacer este FAQ lo más informativo posible; si tiene sugerencias sobre como mejorarlo, envíelas a la http://lists.FreeBSD.org/mailman/listinfo/freebsd-doc[lista de correo del proyecto de documentación FreeBSD].

La última versión de esto documento esta siempre disponible desde el link:.[sitio web de FreeBSD]. También puede ser descargada como un solo archivo link:.[HTML] con HTTP o en varios otros formatos desde el link:ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/[servidor FTP de FreeBSD].

'''

toc::[]

== Introducción

=== ¿Qué es FreeBSD?

FreeBSD es un sistema operativo moderno para desktops, laptops, servidores, y sistemas embebidos con con soporte para un gran número de http://www.FreeBSD.org/platforms/[plataformas].

Esta basado en la versión "4.4BSD-Lite" de la U.C. Berkeley, con algunas mejoras de "4.4BSD-Lite2". También esta basado indirectamente en el port que William Jolitz's hizo de "Net/2" de la U.C. Berkeley a i386(TM), conocido como "386BSD", a pesar de que actualmente queda muy poco código de 386BSD.

FreeBSD es usado por compañias, proveedores de internet, investigadores, profesionales de las computadoras, estudiantes y usuarios hogareños alrededor del mundo para su trabajo educación y recreación.

Para información más detallada acerca de FreeBSD, vea el link:{handbook}[manual de FreeBSD].

[[FreeBSD-goals]]
=== ¿Cual es el objetivo del proyecto FreeBSD?

El objetivo del proyecto FreeBSD es proveer un sistema operativo estable y veloz de propósito general que pueda ser usado para cualquier propósito sin ataduras.

=== ¿Tiene alguna restricción la licencia de FreeBSD?

Si. Estas restricciones no controlan como se usa el código, sino como se trata al proyecto FreeBSD en si mismo. La licencia esta disponible en http://www.FreeBSD.org/copyright/freebsd-license/[licencia] y puede ser resumida de la siguiente manera:

* No pretenda haber escrito esto.
* No nos demande si falla.
* No remueva o modifique la licencia.

Muchos de nosotros hemos invertido significativamente en el proyecto y no nos molestaría recibir una pequeña compensación financiera ocasionalmente, pero de ninguna manera insistiremos en ello. Creeemos que nuestra primera y principal "misión" es proveer código a todos los consumidores, para cualquier propósito, de manera que el codigo se utilize de la manera más amplia posible y provea el mayor beneficio posible. Esta, creemos es una de las metas mas fundamentales del software libre, y una que apoyamos entusiastamente.

El código en nuestro arbol de codigo fuente que esta cubierto por la http://www.FreeBSD.org/copyright/COPYING[Licencia Pública General de GNU] o la http://www.FreeBSD.org/copyright/COPYING.LIB[GNU Library General Public License (LGPL)] viene con más restricciones, pero el menos del lado de forzar el acceso al código en lugar de su opuesto. Debido a las complejidades adicionales que pueden evolucionar del uso comercial de software GPL, intentamos reemplazar tal software con alternativas bajo la más permisiva http://www.FreeBSD.org/copyright/freebsd-license/[licencia de FreeBSD] cuando sea posible.

=== ¿Puede FreeBSD reemplazar mi sistema operativo actual?

Para la mayoría de la gente, si. Pero esta pregunta no es tan simple.

La mayoría de la gente no usa realmente un sistema operativo. Usan aplicaciones. Estas aplicaciones son las que realmente utilizan el sistema operativo. FreeBSD fue diseñado para proveer un ambiente robusto y lleno de características para aplicaciones. Soporta una amplia variedad de navegadores web, suites ofimáticas, lectores de correo electrónico, programas gráficos, ambientes de programación, servidores de red, y mucho más. La mayoría de estas aplicaciones puede manejarse a través de http://www.FreeBSD.org/ports/[La colección de Ports].

Si una aplicación solo esta disponible en un sistema operativo, ese sistema operativo no puede ser reemplazado. De todas maneras, hay muchas posibilidades de que haya una aplicación muy similar en FreeBSD. Como un sólido servidor para la oficina o internet o una confiable estación de trabajo, FreeBSD con toda seguridad hara todo lo que usted necesita. Muchos usuarios de computadoras alrededor del mundo, incluyendo novatos y administradores UNIX(TM) experimentados, utilizan FreeBSD como su único sistema operativo de escritorio.

Los usuarios que migren a FreeBSD desde otro ambiente estilo UNIX(TM) encontraran que FreeBSD es similar. Los usuarios de Windows(TM) y Mac OS(TM) pueden estar interesados en utilizar http://www.pcbsd.org/[PC-BSD], una distribución de escritorio basada en FreeBSD. Los usuarios no-UNIX(TM) deberían esperar invertir más tiempo aprendiendo la manera UNIX(TM) de hacer las cosas. Este FAQ y el link:{handbook}[manual de FreeBSD] son excelentes lugares para empezar.

=== ¿Porque se llama FreeBSD?

* Puede ser usado sin cargo, incluso por usuarios comerciales.
* El codigo fuente completo del sistema operativo esta disponible libremente, y se le han impuesto las mínimas restricciones posible a su uso, distribución y incorporación en otras obras (comerciales o no-comerciales).
* Cualquiera que posea una mejora una corrección de errores es libre de enviar su codigo y que este se añada al arbol de codigo fuente (sujeto a una o dos clausulas obvias).

Vale la pena señalar que la palabra "free" se usa de dos maneras aqui: una de ellas significa "sin costo" y la otra significa "haga lo que quiera". Aparte de una o dos cosas que usted _no puede_ hacer con el código de FreeBSD, por ejemplo pretender que lo escribio, puede hacer lo que desee con el mismo.

=== ¿Cuales son las diferencias entre FreeBSD y NetBSD, OpenBSD, y otros sistemas operativos BSD de código abierto?

James Howard escribio una buena explicación de la historia y diferencias entre los varios proyectos, llamada http://www.freebsdworld.gr/freebsd/bsd-family-tree.html[El Arbol Familiar BSD] que se esfuerza en responder esta pregunta. Parte de la información esta desactualizada, pero la parte histórica en particular sigue siendo precisa.

La mayoria de los BSDs comparten codigo y parches, aún hoy en día. Todos estos BSDs tienen un linaje en común.

Los objetivos de diseño de FreeBSD se describen en <<FreeBSD-goals>>. Los objetivos de diseño de los otros BSDs populares pueden resumirse como sigue:

* OpenBSD busca la seguridad del sistema operativo por sobre todo lo demás. El equipo de OpenBSD escribio man:ssh[1] y man:pf[4], ambos han sido porteados a FreeBSD.
* NetBSD apunta a ser facilmente porteado a otras plataformas de hardware.
* DragonFly BSD es un fork de FreeBSD 4.8 que desde entonces desarrollo muchas caracterí­sticas propias interesantes, incluyendo el sistema de archivos HAMMER y soporte para "vkernels" en modo usuario.

=== ¿Cual es la última versión de FreeBSD?

En cualquier punto del desarrollo de FreeBSD puede haber multiples ramas paralelas. Las versiones 10._X_ se hacen a partir de la rama _10-STABLE_, y las versiones 9._X_ se hacen a partir de la rama _9-STABLE_.

Hasta el lanzamiento de 9.0, la serie 9._X_ era la conocida como _-STABLE_. No obstante, a la fecha de lanzar 11._X_, la rama 9._X_ sera designada para un estatus de "soporte extendido" y recibira solo arreglos para problemas importantes, por ejemplo los relacionados con seguridad.

La versión link:ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/i386/10.2-RELEASE/[10.2] es la última versión de la rama _10-STABLE_; fue lanzada en Agosto del 2015. La versión link:ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/9.3-RELEASE/[9.3] es la última versión de la rama _9-STABLE_; fue lanzada en Julio del 2014.

Las versiones se hacen <<release-freq,cada unos cuantos meses>>. Mientras que mucha gente se mantiene más al corriente con las fuentes de FreeBSD (vea las preguntas en <<current,FreeBSD-CURRENT>> y <<stable,FreeBSD-STABLE>>) que eso, hacerlo requiere un compromiso mayor, ya que las fuentes son un blanco en movimiento.

Puede encontrarse más información acerca de las versiones de FreeBSD en la http://www.FreeBSD.org/releng/#release-build[página de Ingenieria de Versiones] y en man:release[7].

=== ¿Qué es FreeBSD-CURRENT?

link:{handbook}#current[FreeBSD-CURRENT] es la versión de desarrollo del sistema operativo, la cual a su debido tiempo se convertira en la nueva rama FreeBSD-STABLE. Como tal, solo sirve de interes a los desarrolladores trabajando en el sistema y entusiastas acérrimos. Vea la link:{handbook}#current[sección reelevante] en el link:{handbook}[manual] para obtener detalles acerca de correr _-CURRENT_.

Los usuarios que no esten familiarizados con FreeBSD no deberían usar FreeBSD-CURRENT. Esta rama suele evolucionar rápidamente y a veces, debido a errores puede ser imposible de compilar. Se espera que la gente que usa FreeBSD-CURRENT sea capaz de analizar, debuggear y reportar problemas.

Las versiones https://www.FreeBSD.org/snapshots/[snapshot] de FreeBSD son hechas basadas en en el estado actual de las ramas _-CURRENT_ y _-STABLE_. Los objetivos detrás de cada version snapshot son:

* Probar la última versión de la instalación del software.
* Darle a la gente que quiera correr _-CURRENT_ o _-STABLE_ pero que no tenga el tiempo o el ancho de banda para seguirlas día a día una forma fácil de correrlas en sus sistemas.
* Preservar un punto de referencia fijo para el código en cuestión, en el caso de que rompamos algo de manera catastrófica más adelante. (Aunque Subversion normalmente previene que algo horrible como este suceda.)
* Asegurar que todas las nuevas características y arreglos que necesiten ser probados, tengan el mayor número posible de potenciales probadores.

No se asegura que un snapshot de _-CURRENT_ pueda considerarse de "calidad para producción" para cualquier propósito. Si se necesita un sistema estable y probado en profundidad, use las versiones completas o snapshots de _-STABLE_.

Las versiones snapshot estan directamente disponibles desde https://www.FreeBSD.org/snapshots/[snapshot].

Los snapshots oficiales se generan regularmente para todas las ramas desarrolladas activamente.

=== ¿Cual es el concepto de FreeBSD-STABLE?

Cuando se lanzo FreeBSD 2.0.5, el desarrollo de FreeBSD se ramifico en dos. Una rama fue llamada link:{handbook}#stable[-STABLE], y otra link:{handbook}#current[-CURRENT]. _FreeBSD-STABLE_ esta pensada para ser usada por proveedores de internet, y otras compañías comerciales para las cuales cambios bruscos o características experimentales son indeseables. Solo recibe arreglos de errores que hayan sido probados en profundidad y otras pequeñas mejoras incrementales. _FreeBSD-CURRENT_, por otra parte ha sido una linea continua desde que se lanzo 2.0 hasta 10.2-RELEASE y más allá. Para información más detallada acerca de las ramas vea "link:{releng}#rel-branch[Ingenieria de lanzamientos de FreeBSD: Creando la Rama de Lanzamiento]", el estado de las ramas y la agenda de lanzamientos futuros puede encontrarse en la página de http://www.FreeBSD.org/releng[Información de ingeniería de lanzamientos].

10.2-STABLE es la rama activamente desarrollada de _-STABLE_. La última versión de la rama 10.2-STABLE es 10.2-RELEASE, la cual fue lanzada en Agosto del 2015.

La rama _11-CURRENT_ es la rama activamente desarrollada de _-CURRENT_ para próxima generación de FreeBSD. Vea <<current,¿Qué es FreeBSD-CURRENT?>> para más información acerca de esta rama.

=== ¿Cuando se hacen los lanzamientos de FreeBSD?

El equipo de ingenieria de lanzamientos mailto:re@FreeBSD.org[re@FreeBSD.org] lanza una versión mayor de FreeBSD cada aproximadamente 18 meses y una nueva versión menor cada aproximadamente 8 meses, en promedio. Las fechas de lanzamiento se anuncian con antelación, de manera que la gente que trabaja en el sistema sabe cuando sus proyectos deben estar terminados y probados. Un período de prueba precede cada lanzamiento, para asegurarse que el agregado de nuevas características no comprometa la estabilidad del lanzamiento. Muchos usuarios ven esta precuación como una de las mejores cosas acerca de FreeBSD, a pesar de que el esperar que las ultimas mejoras lleguen a _-STABLE_ puede ser un poco frustrante.

más información acerca del proceso de ingenieria de lanzamientos (incluyendo una agenda de futuros lanzamientos) puede encontrarse en las páginas de http://www.FreeBSD.org/releng/[ingenieria de lanzamientos] en el sitio de FreeBSD.

Para la gente que quiere o necesita algo de emoción, snapshots binarios se hacen semanalmente, como se dijo más arriba.

=== ¿Quien es responsable por FreeBSD?

Las decisiones clave que tengan que ver con el proyecto FreeBSD, tales como la dirección general del proyecto y quien puede agregar codigo al arbol fuente, son hechas por un https://www.FreeBSD.org/administration/#t-core[equipo central] de 9 personas. Existe un equipo mucho más grande de más de 350 link:{contributors}#staff-committers[committers] que estan autorizados a hacer cambios directamente al árbol de fuentes.

No obstante, la mayoría de los cambios no triviales se discuten por adelantado en las <<mailing,listas de correo>>, y no existen restricciones acerca de quien puede participar en la discusión.

=== ¿Donde puedo obtener FreeBSD?

Cada lanzamiento importante de FreeBSD esta disponible via FTP anónimo desde el link:ftp://ftp.FreeBSD.org/pub/FreeBSD/[ sito FTP de FreeBSD]:

* La última versión _10-STABLE_, 10.2-RELEASE puede encontrarse en el link:ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/i386/10.2-RELEASE/[directorio de 10.2-RELEASE]
* Versiones https://www.FreeBSD.org/snapshots/[Snapshot] se hacen mensualmente para las ramas <<current,-CURRENT>> y <<stable,-STABLE>>, siendo estas útiles unicamente para probadores de vanguardia y desarrolladores.
* La última versión _9-STABLE_, 9.3-RELEASE puede encontrarse en el link:ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/9.3-RELEASE/[directorio 9.3-RELEASE].

Información acerca de como obtener FreeBSD en CD, DVD y otros medios puede encontrarse en link:{handbook}#mirrors/[el manual].

=== ¿Como accedo a la base de datos de reporte de problemas?

La base de datos de reporte de problemas de todos los pedidos de cambio por parte de los usuarios puede consultarse usando nuetra interfaz de https://bugs.FreeBSD.org/search/[consulta] de PR basada en web.

La https://www.FreeBSD.org/support/bugreports/[interfaz basada en web de envio de reporte de problemas] puede ser usada para enviar reportes a través de un navegador web.

Antes de envíar un reporte de problemas, lea link:{problem-reports}[Escribiendo reportes de problemas para FreeBSD], un artículo acerca de como escribir buenos reportes de problemas.

== Documentación y soporte

=== ¿Qué buenos libros hay acerca de FreeBSD?

El proyecto produce un amplio rango de documentación, disponible en linea a través de este link:http://www.FreeBSD.org/docs/[http://www.FreeBSD.org/docs/]. Adicionalmente, <<bibliography,la bibliografía>> al final de este FAQ, y link:{handbook}#bibliography/[la del manual] referencian otros libros recomendados.

=== ¿Esta la documentación disponible en otros formatos, tales como texto plano (ASCII), o PostScript?

Si. La documentación esta disponible en un número de diferentes formatos y esquemas de compresión desde el sitio FTP de FreeBSD, en el directorio link:ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/[/pub/FreeBSD/doc/].

La documentación esta categorizada en un número de manera distintas. Estas incluyen:

* El nombre del documento, tal como `faq`, o `manual`.
* El lenguaje y codificación del documento. Estos estan basados en los nombres de locale encontrados bajo [.filename]#/usr/shared/locale# en un sistema FreeBSD. Los lenguajes y codificaciones actuales son los siguientes:
+
[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Nombre
| Significado

|`en_US.ISO8859-1`
|Inglés (Estados Unidos)

|`bn_BD.ISO10646-1`
|Bengalí o Bangla (Bangladesh)

|`da_DK.ISO8859-1`
|Danés (Dinamarca)

|`de_DE.ISO8859-1`
|Alemán (Alemania)

|`el_GR.ISO8859-7`
|Griego (Grecia)

|`es_ES.ISO8859-1`
|Español (España)

|`fr_FR.ISO8859-1`
|Frances (Francia)

|`hu_HU.ISO8859-2`
|Húngaro (Hungría)

|`it_IT.ISO8859-15`
|Italiano (Italia)

|`ja_JP.eucJP`
|Japonés (Japón, codificación EUC)

|`mn_MN.UTF-8`
|Mongol (Mongolia, codificación UTF-8)

|`nl_NL.ISO8859-1`
|Holandés (Paises Bajos)

|`no_NO.ISO8859-1`
|Noruego (Noruega)

|`pl_PL.ISO8859-2`
|Polaco (Polonia)

|`pt_BR.ISO8859-1`
|Portugues (Brazil)

|`ru_RU.KOI8-R`
|Ruso (Rusia, codificación KOI8-R)

|`sr_YU.ISO8859-2`
|Serbio (Serbia)

|`tr_TR.ISO8859-9`
|Turco (Turquía)

|`zh_CN.UTF-8`
|Chino simplificado (China, codificación UTF-8)

|`zh_TW.UTF-8`
|Chino tradicional (Taiwan, codificación UTF-8)
|===
+
[NOTE]
====
Algunos documentos pueden no estar disponibles en todos los lenguajes.
====

* El formato del documento. Producimos la documentación en varios formatos de salida distintos. Cada formato tiene sus propias ventajas y desventajas. Algunos formatos son mejores para ser leidos en linea, mientras que otros fueron concebidos para ser estéticamente agradables al ser impresos en papel. Tener la documentación disponible en cualquiera de estos formatos asegura que nuestros lectores podran leer las partes en las que estan interesados, tanto en su monitor, como en papel luego de imprimir los documentos. Los formatos actualmente disponibles son:
+
[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Formato
| Significado

|`html-split`
|Colección de pequeños archivos HTML vinculados

|`html`
|Un solo archivo HTML conteniendo el documento entero

|`pdf`
|Formato de documento portátil de Adobe

|`ps`
|PostScript(TM)

|`rtf`
|Formato de Texto Enriquecido de Microsoft(TM)

|`txt`
|Texto plano
|===
+
[NOTE]
====
Los números de página no se actualizan automaticamente al cargar el Formato de Texto Enriquecido en Word. Presione kbd:[Ctrl+A], kbd:[Ctrl+End], kbd:[F9] luego de cargar el documento, para actualizar los números de página.
====

* El esquema de compresión y empaquetado.
.. Donde el formato es `html-split`, los archivos son empaquetados usando man:tar[1]. El archivo [.filename]#.tar# es luego comprimido usando los esquemas de compresión detallados en el siguiente punto.
.. Todos los otros formatos generan un archivo. Por ejemplo, [.filename]#article.pdf#, [.filename]#book.html#, y demás.
+ 
Estos archivos son posteriormente comprimidos usando los esquemas de compresión `zip` o `bz2`. man:tar[1] puede usarse para descomprimir estos archivos.
+ 
Asi la versión PostScript(TM) del manual, comprimida usando `bzip2` sera guardada en un archivo llamado [.filename]#book.ps.bz2# en el directorio [.filename]#handbook/#.

Luego de elegir el formato y mecanismo de compresión, descargue los archivos comprimidos, descomprimalos, y luego copie los documentos apropiados a su lugar.

Por ejemplo, la versión HTML split del FAQ, comprimida usando man:bzip2[1], puede encontrarse en [.filename]#doc/en_US.ISO8859-1/books/faq/book.html-split.tar.bz2#. Para descargar y descomprimir dicho archivo, escriba:

[source,bash]
....
# fetch ftp://ftp.FreeBSD.org/pub/FreeBSD/doc/en_US.ISO8859-1/books/faq/book.html-split.tar.bz2
# tar xvf book.html-split.tar.bz2
....

Si el archivo esta comprimido, tar detectara automaticamente el formato apropiado y lo descomprimira correctamente, resultando en una colección de archivos [.filename]#.html#. El principal se llama [.filename]#index.html#, el cual contiene la tabla de contenidos, material introductorio, y vínculos a las otras partes del documento.

=== ¿Donde encuentro información acerca de las listas de correo de FreeBSD? ¿Qué grupos de noticias de FreeBSD estan disponibles?

Vea la link:{handbook}#eresources-mail[entrada del manual acerca de listas de correo] y la link:{handbook}#eresources-news/[entrada del manual acerca de grupos de noticias].

=== ¿Hay canales de IRC (Internet Relay Chat) de FreeBSD?

Si, la mayoría de las redes IRC hospedan un canal de chat de FreeBSD:

* El canal `#FreeBSDhelp` en http://www.efnet.org/index.php[EFNet] es un canal dedicado a ayudar usuarios de FreeBSD.
* El canal `#FreeBSD` en http://freenode.net/[Freenode] es un canal general de ayuda con muchos usuarios activos en cualquier momento. Las conversaciones suelen salirse de tema a ratos, pero se le da prioridad a usuarios con preguntas acerca de FreeBSD. Otros usuarios pueden ayudar con lo básico, refiriendo al manual cuando sea posible y proveyendo vínculos para aprender más acerca de un tema en particular. Este es un canal donde se habla mayormente ingles, aunque tiene usuarios de todo el mundo. Los hablantes no nativos de inglés deberían intentar formular su pregunta en inglés y luego dirigirse a `##freebsd-lang` cuando sea apropiado.
* El canal `#FreeBSD` en http://www.dal.net/[DALNET] esta disponible en `irc.dal.net` en los Estados Unidos y `irc.eu.dal.net` en Europa.
* El canal `#FreeBSD` en http://www.undernet.org/[UNDERNET] esta disponible en `us.undernet.org` en los Estados Unidos y `eu.undernet.org` en Europa. Dado que es un canal de ayuda, preparese para leer los documentos que se le recomiendan.
* El canal `#FreeBSD` en http://www.rusnet.org.ru/[RUSNET] es un canal en ruso dedicado a ayudar usuarios de FreeBSD. También es un buen lugar para discusiones no técnicas.
* El canal `#bsdchat` en http://freenode.net/[Freenode] es un canal en chino tradicional (codificación UTF-8) dedicado a ayudar usuarios de FreeBSD. Este también es un buen lugar para discusiones no técnicas.

La wiki de FreeBSD tiene una http://wiki.freebsd.org/IrcChannels[buena lista] de canales IRC.

Cada uno de estos canales es distinto y no esta conectado a los otros. Dado que sus estilos de conversacion pueden diferir, intente encontrar uno que se adecue a su estilo de conversación.

=== ¿Existen foros web para discutir acerca de FreeBSD?

Los foros oficiales de FreeBSD estan ubicados en https://forums.FreeBSD.org/[https://forums.FreeBSD.org/].

=== ¿Donde puedo obtener entrenamiento y soporte comercial de FreeBSD?

http://www.ixsystems.com[iXsystems, Inc.], compañia padre de http://www.freebsdmall.com/[FreeBSD Mall], provee http://www.ixsystems.com/bsdsupport[soporte] comercial de software FreeBSD y PC-BSD, en adición a soluciones para el desarrollo y ajuste de FreeBSD.

BSD Certification Group, Inc. PROVEE certificaciones de administración de sistemas para DragonFly BSD, FreeBSD, NetBSD, y OpenBSD. Vea http://www.BSDCertification.org[su sitio] para más información.

Cualquier otra organización que provea entrenamiento y soporte deberá contactar al proyecto para ser listada aquí.

== Instalación

=== ¿Qué plataforma debería descargar? Tengo una CPU Intel con capacidad de 64 Bits, pero solo veo amd64.

amd64 es el término usado por BSD para las arquitectura de x86 compatibles con 64 bits (también conocido como "x86-64" o "x64"). La mayoría de las computadoras modernas deberían usar amd64. El hardware más antiguo debería usar i386. Al instalar en una arquitectura no compatible con x86, elija la plataforma que se aproxime mejor al hardware.

=== ¿Qué archivo descargo para obtener FreeBSD?

En la página http://www.freebsd.org/where/[Obteniendo FreeBSD] elija `[iso]` al lado de la arquitectura que coincide con el hardware.

Cualquiera de los siguientes puede ser usado:

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| archivo
| descripción

|[.filename]#disc1.iso#
|Contiene lo suficiente para instalar FreeBSD y un set de paquetes mínimo.

|[.filename]#dvd1.iso#
|Similar a [.filename]#disc1.iso# pero con paquetes adicionales.

|[.filename]#memstick.img#
|Una imagen arrancable, suficiente para escribir a un dispositivo USB.

|[.filename]#bootonly.iso#
|Una imagen mínima que requiere acceso a la red durante la instalación para instalar completamente FreeBSD.
|===

Los usuarios de pc98 requerirán las siguientes imágenes de disquete: [.filename]#floppies/boot.flp#, [.filename]#floppies/kern1.flp#, [.filename]#floppies/kern2.flp#, y [.filename]#floppies/mfsroot1.flp#. Estas imagenes necesitaran ser escritas a disquetes por herramientas como man:dd[1].

Instrucciones completas acerca de este procedimiento y mas información acerca de problemas de instalación en general puede encontrarse en este la link:{handbook}#bsdinstall/[entra de manual acerca de instalar FreeBSD].

=== ¿Qué debo hacer si la imagen de instalación no arranca?

Esto puede ser ocasionado por no descargar la imagen en modo _binary_ al usarFTP.

Algunos clientes FTP tienen por defecto el modo de transferencia _ascii_ e intentan cambiar cualquier carácter de fin de línea para que use las convenciones del sistema del cliente. Esto con toda probabilidad corromperá la imagen de arranque. Verifique el checksum SHA-256 de la imagen de arranque descargada: si es _exactamente_ la imagen que se encuentra en el servidor, entonces el proceso de descarga es el sospechoso.

Cuando use un cliente de FTP por línea de comandos, escriba _binary_ en la pantalla de comandos FTP luego de conectarse al servidor y antes de comenzar a descargar la imagen.

=== ¿Cuáles son las instrucciones para instalar FreeBSD?

Las instrucciones de instalación pueden encontrarse en link:{handbook}#bsdinstall/[la entrada del manual acerca de instalar FreeBSD].

=== ¿Cuáles son los requisitos mínimos para correr FreeBSD?

FreeBSD requiere una PC 486 o mejor PC, 64 MB o más de RAM, y como mínimo 1.1 GB de espacio en el disco rígido.

=== ¿Como puedo hacer mi propia versión personalizada o disco de instalación?

Medios de instalación personalizados de FreeBSD pueden crearse compilando una versión personalizada. Siga las instrucciones en el artículo de link:{releng}[Ingeniería de Lanzamientos ].

=== ¿Puede Windows coexistir con FreeBSD?

Si Windows(TM) es instalado primero, entonces si. El gestor de arranque de FreeBSD se las arreglara para arrancar tanto Windows(TM) como FreeBSD. Si Windows(TM) es instalado después, sobrescribirá el gestor de arranque. Si esto ocurre, vea la siguiente sección.

=== Otro sistema operativo destruyo mi Gestor de Arranque. ¿Como lo recupero?

Depende del gestor de arranque. El menú de selección de arranque de FreeBSD puede reinstalarse usando man:boot0cfg[8]. Por ejemplo, para restaurar el menu de arranque al disco _ada0_:

[source,bash]
....
# boot0cfg -B ada0
....

El cargador de arranque no interactivo MBR bootloader puede instalarse usando man:gpart[8]:

[source,bash]
....
# gpart bootcode -b /boot/mbr ada0
....

Para situaciones mas complejas, incluyendo discos GPT, véase man:gpart[8].

=== Arranque desde un CD, pero el programa de instalación dice que no encuentra un CD-ROM. ¿Hacia donde fue?

La causa más frecuente de este problema es un lector de CD-ROM mal configurado. Muchas PCs se suministran con el CD-ROM como la unidad esclava en el controlador IDE secundario, sin ningún dispositivo maestro en el controlador. Esto es ilegal en la especificación ATAPI, pero Windows(TM) no sigue la misma al pie de la letra, y el BIOS la ignora al arrancar. Esta es la causa de que el BIOS pudo ver el CD-ROM para arrancar del mismo, pero FreeBSD no puede verlo para completar la instalación.

Reconfigure el sistema de manera que el CD-ROM se encuentre en el dispositivo maestro del controlador al que esta acoplado, o asegúrese de que es el esclavo en un controlador IDE que también tiene un dispositivo maestro.

=== ¿Necesito instalar el código fuente?

En general, no. No hay nada en el sistema base que requiera la presencia del código fuente para operar. Algunos ports como package:sysutils/lsof[], no compilaran a menos que el código este instalado. En particular, si el port compila un modulo de kernel u opera directamente sobre estructuras del kernel, el código fuente debe estar instalado.

=== ¿Necesito compilar un kernel?

Usualmente no. El kernel `GENERIC` incluido contiene los controladores que una computadora ordinaria requiere. man:freebsd-update[8], la herramienta de actualización binaria de FreeBSD, no puede actualizar kernels hechos a medida, otra razón para quedarse con el kernel `GENERIC` cuando sea posible. Para computadoras con una cantidad limitada de RAM, tales como los sistemas embebidos, puede valer la pena compilar una kernel mas pequeño, hecho a medida conteniendo únicamente los controladores requeridos.

=== ¿Debería utilizar contraseñas en DES, Blowfish, o MD5 y como especifico que formato usan mis usuarios?

FreeBSD 9 y posterior usan _SHA512_ por defecto. Las contraseñas en formato DES siguen estando disponibles para mantener compatibilidad con sistemas operativos viejos que usan el formato de contraseñas menos seguro. FreeBSD también soporta los formatos de contraseña Blowfish y MD5. Que formato de contraseña usar para las contraseñas nuevas esta controlado por la capacidad de autenticación `passwd_format` en [.filename]#/etc/login.conf#, la cual toma los valores `des`, `blf` (si estos están disponibles) o `md5`. Vea la página de manual de man:login.conf[5] para más información acerca de capacidades de autenticación.

=== ¿Cuáles son los límites para los sistemas de archivos FFS?

Para sistemas de archivos FFS, el sistema de archivo mas extenso esta limitado en la práctica por la cantidad de memoria requeridad para correr man:fsck[8] en el sistema de archivos. man:fsck[8] requiere un bit por fragmento, lo cual, con el tamaño de fragmentos por defecto de 4 KB es igual a 32 MB de memoria por cada TB de disco. Esto significa que en arquitecturas que limiten los procesos en espacio de usuario a 2 GB (e.j., i386(TM)), el máximo sistema de archivos man:fsck[8]'able es de ~60 TB.

Si no hubiera un límite de memoria de man:fsck[8] en máximo tamaño de archivo sería de 2^64 (bloques) * 32 KB => 16 Exa * 32 KB => 512 ZettaBytes.

El máximo tamaño para un archivo de FFS es aproximadamente 2 PB con el tamaño de bloque por decto de 32 KB. Cada bloque de 32 KB puede apuntar a 4096 bloques. Con bloques triplemente indirectos, el cálculo es 32 KB * 12 + 32 KB * 4096 + 32 KB * 4096^2 + 32 KB * 4096^3. Incrementar el tamaño de bloque a 64 KB incrementara el tamaño máximo de archivo por un factor de 16.

=== ¿Por qué obtengo un mensaje de error, readin failed luego de compilar y arrancar desde un nuevo kernel?

El mundo y kernel están fuera de sincronización. Esto no esta soportado. Asegurese de usar `make buildworld` y `make buildkernel` para actualizar el kernel.

Arranque el sistema especificando el kernel directamente en la segunda fase, presionando cualquier tecla cuando `|` aparezca antes de que arranque el cargador.

=== ¿Hay alguna herramienta para realizar tareas de configuración post-instalación?

Si. bsdconfig provee una buena interfaz para configurar FreeBSD post-instalación.

[[hardware]]
== Compatibilidad de Hardware

[[compatibility-general]]
=== General

==== ¿Quiero obtener hardware para mi sistema FreeBSD. Que modelo/marca/tipo es mejor?

Esto se discute continuamente en las listas de correo de FreeBSD pero es de esperar dado que el hardware cambia con rapidez. Lea las Notas de Hardware para FreeBSD http://www.FreeBSD.org/releases/10.2r/hardware/[10.2] o http://www.FreeBSD.org/releases/9.3r/hardware/[9.3] y busque en los http://www.FreeBSD.org/search/#mailinglists[archivos]de las listas de correo antes de hacer una pregunta acerca del ultimo y mas nuevo hardware. Es posible que una discusión haya tenido lugar la semana pasada.

Antes de comprarse una laptop, verifique los archivos de la http://lists.FreeBSD.org/mailman/listinfo/freebsd-mobile[lista de corroe de laptops de FreeBSD] y http://lists.FreeBSD.org/mailman/listinfo/freebsd-questions[lista de correo de preguntas generales de FreeBSD], o posiblemente una lista de correo específica para un tipo de hardware en particular.

==== ¿Cuáles so los límites para la memoria? ¿Soporta FreeBSD más de 4 GB de memoria (RAM)? ¿Más de 16 GB? ¿Más de 48 GB?

FreeBSD como sistema operativo generalmente soporta tanta memoria física (RAM) como la plataforma en la que se encuentre corriendo. Tenga en mente que diferentes plataformas tienen diferentes límites para la memoria; por ejemplo i386(TM) sin PAE soporta como mucho 4 GB de memoria (y usualmente menos que eso a causa del espacio de direcciones PCI) y i386(TM) con PAE soporta como mucho 64 GB de memoria. En FreeBSD 10, las plataformas AMD64 soportan hasta 4 TB de memoria física.

==== ¿Por qué FreeBSD reporta menos de 4 GB memoria cuando se instala en una máquina i386?

El espacio total direccionable en máquinas i386(TM) es de 32 bits, lo que significa que como mucho 4 GB de memoria son direccionables (pueden ser accedidos). Más aún, en algunas direcciones este rango esta reservado por el hardware para diferentes propósitos, por ejemplo usar y controlar dispositivos PCI, para acceder memoria de video y similares. Por consiguiente, la cantidad total de memoria usable por el sistema operativo para su kernel y aplicaciones esta limitada a significativamente menos que 4 GB. Usualmente, 3.2 GB a 3.7 GB es el máximo de memoria física usable en esta configuración.

Para acceder a más de 3.2 GB a 3.7 GB de memoria instalada (es decir, hasta 4 GB o incluso mas que 4 GB), un ajuste especial llamado PAE debe ser usado. PAE significa Physical Address Extension (Extensión de Memoria Física) y es una manera para que las CPUs x86 de 32 bits puedan direccionar más de 4 GB de memoria. Remapea la memoria que de otra manera sería sobreescrita por reservaciones de memoria por parte del hardware para dispositivos de hardware por encima del rango de 4 GB y lo usa como memoria física adicional (vea man:pae[4]). Usar PAE tiene algunas desventajas; este modo de acceso de memoria es un poco mas lento que el modo normal (sin PAE) y los modulos cargables (vea man:kld[4]) no estan soportados. Esto significa que todos los controladores deben ser compilados en el kernel.

La manera más común de habilitar PAE es compilar un nuevo kernel con el archivo especial de configuración de kernel listo para usarse denominado [.filename]#PAE#, el cual viene configurado para compilar un kernel seguro. Tenga en cuenta que algunas de las entradas en este archivo de configuración de kernel son demasiado conservadoras y algunos controladores marcados como inusables con PAE son perfectamente usables. Una regla práctica es que si el driver es usable en arquitecturas de 64 bits (como AMD64), también es usable con PAE. Al crear un archivo de configuración de kernel personalizado, PAE puede habilitarse agregando la siguiente línea:

[.programlisting]
....
options       PAE
....

PAE no es muy usado hoy en día porque la mayoría del hardware x86 nuevo también soporta correr en modo de 64 bits, conocido como AMD64 o Intel(TM)64. Tiene un espacio de direcciones mucho más extenso y no necesita tales ajustes. FreeBSD soporta AMD64 y es recomendado que se use esta versión de FreeBSD en lugar de la versión de i386(TM) si se necesita usar 4 GB o más de memoria.

[[compatibility-processors]]
=== Arquitecturas y Procesadores

==== ¿Soporta FreeBSD otras arquitecturas aparte de x86?

Si. FreeBSD divide el soporte en múltiples categorías. Las arquitecturas de Categoría 1, tales como i386 o amd64; están totalmente soportadas. Las categorías 2 y 3 están soportadas en una base del mejor esfuerzo. Una explicación completa del sistema de categorías esta disponible en la link:{committers-guide}#archs/[Guia del Committer.]

Una lista completa de arquitecturas soportadas puede encontrarse en la http://www.FreeBSD.org/platforms/[página de plataformas.]

==== ¿Soporta FreeBSD multiprocesamiento simétrico (SMP)?

FreeBSD soporta multiprocesadores simétricos (SMP) en todas las plataformas no embebidas (e.j, i386, amd64, etc.). SMP también esta soportado en kerneles arm y MIPS, aunque algunas CPUs pueden no soportar esto. La implementación de SMP en FreeBSD usa bloqueo de granularidad fina, y la performance escala casi linealmente con el número de CPUs.

man:smp[4] contiene más detalles.

==== ¿Qué es el microcódigo? ¿Como instalo actualizaciones de microcódigo de Intel CPU microcode updates?

El microcódigo es un método de implementar programáticamente instrucciones al nivel de hardware. Esto permite que los errores de CPU se corrigan sin reemplazar el chip de la placa.

Instale package:sysutils/devcpu-data[], luego añada:

[.programlisting]
....
microcode_update_enable="YES"
....

a [.filename]#/etc/rc.conf#

[[compatibility-drives]]
=== Discos duros, unidades de cinta y unidades de CD y DVD

==== ¿Qué tipo de discos duros soporta FreeBSD?

FreeBSD soporta discos EIDE, SATA, SCSI y SAS (con un controlador compatible; vea la siguiente sección), y todos los dispositivos que usen la interfaz original de "Western Digital" (MFM, RLL, ESDI, y por supuesto IDE). Algunos controladores ESDI que usan interfaces propietarias pueden no funcionar: quédese con las interfaces WD1002/3/6/7 y clones.

==== ¿Qué controladores SCSI o SAS están soportados?

Vea la lista completa en las Notas de hardware para FreeBSD http://www.FreeBSD.org/releases/10.2r/hardware/[ 10.2 ] o http://www.FreeBSD.org/releases/9.3r/hardware/[ 9.3 ] .

==== ¿Qué tipo de unidades de cinta están soportadas?

FreeBSD soporta todas las interfaces de cinta SCSI estándar.

==== ¿Soporta FreeBSD cambiadores de cinta?

FreeBSD soporta cambiadores SCSI utilizando el dispositivo man:ch[4] y el comandoman:chio[1]. Los detalles acerca de cómo controlar el cambiador se pueden encontrar en man:chio[1].

Mientras que AMANDA y algunos otros productos entienden acerca de los cambiadores, otras aplicaciones solo saben como mover una cinta de un punto a otro. En este caso, lleve la cuenta de en que ranura esta la cinta actualmente y a que unidad necesita ir nuevamente el dispositivo.

==== ¿Qué dispositivos de CD-ROM y CD-RW están soportados por FreeBSD?

Cualquier unidad SCSI drive connectada a un controlador soportado esta soportada. La mayoría de los CD-ROMs ATAPI compatibles con IDE están soportados.

FreeBSD soporta cualquier CD-R o CD-RW compatible con ATAPI. Vea man:burncd[8] para más detalles.

FreeBSD también soporta cualquier tipo de dispositivos CSI CD-R o CD-RW. Instale el port o paquete de package:sysutils/cdrtools[], y luego use el comando `cdrecord`.

[[compatibility-kbd-mice]]
=== Teclados y Ratones

[[moused]]
==== ¿Es posible usar un ratón por fuera del sistema X Window?

El controlador de consola por defecto, man:syscons[4], provee la habilidad de usar un puntero del ratón en consolas de texto para copiar & pegar texto. Corra el demonio del ratón, man:moused[8], e inicie el puntero del ratón en la consola virtual:

[source,bash]
....
# moused -p /dev/xxxx -t yyyy
# vidcontrol -m on
....

Donde _xxxx_ es el nombre del dispositivo del ratón y _yyyy_ es un tipo de protocolo para el ratón. El demonio del ratón puede automáticamente determinar el protocolo para la mayoría de los ratones, con excepción del los viejos ratones en serie. Especifique el protocolo `auto` para invocar la detección automática. Si la detección automática no funciona, vea la pagina de manual de man:moused[8] para una lista de tipos de protocolo soportados.

Para un ratón PS/2 mouse, aÑADA `moused_enable="YES"` a [.filename]#/etc/rc.conf# para iniciar el demonio del ratón en tiempo de arranque. Adicionalmente, para usar el demonio del ratón en todas las terminales virtuales, en lugar de solo en la consola, añada `allscreens_flags="-m on"` a [.filename]#/etc/rc.conf#.

Cuando el demonio del ratón este corriendo, el acceso al mouse debe ser coordinado entre el demonio del ratón y otros programas tales como X Windows. Vea el FAQ<<x-and-moused,¿Porque mi mouse no funciona con X?>> para más detalles acerca del problema.

==== ¿Como copio y pego texto con un ratón en la consola de texto?

No es posible remover datos usando el ratón. No obstante, es posible copiar y pegar. Una vez que el demonio del ratón este corriendo como se describió en la <<moused,pregunta anterior>>, presión el botón 1 (botón izquierdo)y mueva el ratón para seleccionar una región de texto. Luego presione el botón 2 (botón del medio) y para pegar en la posición del cursor de texto. Presionar el botón 3 (botón derecho) "extenderá" la región de texto seleccionada.

Si el ratón no tiene botón del medio, es posible emular uno o remapear botones utilizando opciones del demonio del ratón. Vea la man:moused[8] pagina del manual para detalles.

==== Mi ratón tiene una reluciente rueda y botones. ¿Puedo usarlos en FreeBSD?

La respuesta a eso es, desafortunadamente, "depende". Estos ratones con características adicionales requieren un controlador especializado en la mayoría de los casos. A menos que el dispositivo del ratón o el programa de usuario tenga soporte especifico para el ratón, el mismo actuara como un ratón normal de dos o tres botones.

Para el posible uso de ruedas en el ambiente X Window, refiérase a <<x-and-wheel,esa sección>>.

==== ¿Como uso la tecla delete en sh y csh?

Para Bourne Shell, agregue las siguientes líneas a [.filename]#~/.shrc#. Vea man:sh[1] y man:editrc[5].

[.programlisting]
....
bind ^? ed-delete-next-char # for console
bind ^[[3~ ed-delete-next-char # for xterm
....

Para C Shell, agregue las siguientes líneas a [.filename]#~/.cshrc#. Vea man:csh[1].

[.programlisting]
....
bindkey ^? delete-char # for console
bindkey ^[[3~ delete-char # for xterm
....

Para más información, vea http://www.ibb.net/\~anne/keyboard.html[esta página].

[[compatibility-other]]
=== Otro Hardware

==== ¿Soluciones para cuando mi tarjeta de audio pcm4 no emite sonidos?

Algunas tarjetas de sonido ajustan su volumen de salida a con cada arranque. Corra el siguiente comando cada vez que la maquina arranque:

[source,bash]
....
# mixer pcm 100 vol 100 cd 100
....

==== ¿Soporta FreeBSD manejo de poder para mi laptop?

FreeBSD soporta las características ACPI que pueden encontrarse en el hardware moderno. Más información puede encontrarse en man:acpi[4].

== Solución de problemas

=== ¿Porque FreeBSD encuentra la cantidad incorrecta de memoria en hardware i386?

La razón más probable es la diferencia entre direcciones de memoria física y direcciones virtuales.

La convención para la mayoría del hardware de PC hardware es usar el área de memoria entre 3.5 GB y 4 GB para un propósito especial (usualmente para PCI). Este espacio de direcciones se usa para acceder a hardware PCI. Como resultado, la memoria real (física) no puede ser accedida en ese espacio de direcciones.

Lo que sucede con la memoria que debería aparecer en ese espacio es dependiente del hardware. Desafortunadamente, algunos equipos no hacen nada y la habilidad de usar los últimos 500 MB de RAM se pierde por completo.

Por suerte, la mayoría de los equipos de hardware remapean la memoria a una locación más alta de manera que pueda seguir siendo usada. No obstante, esto puede causar confusión al ver los mensajes de arranque.

En una versión de 32 bits de FreeBSD, la memoria parece perdida, dado que sera remapeado por encima de los 4 GB, que son imposibles de acceder para un kernel de 32 bits. En este caso, la solución es construir un kernel con PAE habilitado. Vea la entrada acerca de límites de memoria para más información.

En una versión de 64 bits de FreeBSD, o al correr un kernel con PAE habilitado, FreeBSD detectara y remapeara la memoria de manera correcta para que sea usable. Durante el arranque, sin embargo, puede parecer que FreeBSD este detectando más memoria de la que tiene realmente el sistema, debido al remapeo descrito anteriormente. Esto es normal y la memoria disponible sera corregida cuando el proceso de arranque termine.

=== ¿Por que mis programas ocasionalmente terminan con errores Signal 11?

Los errores Signal 11 son causados cuando un proceso intento acceder a una región de memoria cuyo acceso no fue concedido por el sistema operativo. Si algo como esto pasa a intervalos aparentemente aleatorios, comience a investigar la causa.

Estos problemas suele deberse a:

. Si el problema ocurre solo en una aplicación específica, probablemente sea un error en el código.
. Si es un problema con parte del sistema base de FreeBSD, también puede tratarse de código con errores, pero frecuentemente estos problemas suelen encontrarse y arreglarse mucho antes de que nosotros, los lectores usuales del FAQ lleguen a usar esas partes del código (para eso existe -CURRENT).

Probablemente no se trate de un error en FreeBSD si el problema ocurre al compilar un programa, pero la actividad que el compilador realiza cambia en cada iteración.

Por ejemplo, si `make buildworld` falla al intentar compilar [.filename]#ls.c# a [.filename]#ls.o# y, al correr de vuelta, falla en el mismo lugar, esto es una compilación fallida. Pruebe actualizar el código fuente e intentando nuevamente. Si la compilación falla en otro lugar, casi ciertamente es debido al hardware.

En el primer caso, use un debugger, tal como man:gdb[1] para encontrar el punto en el que el programa este intentando acceder a una dirección falsa y arreglarlo.

En el segundo caso, verifique la pieza de hardware que este fallando.

Causas comunes de esto incluyen:

. Los discos duros pueden estar sobrecalentándose: verifique que los ventiladores sigan funcionando, dado que el disco y otro hardware puede estar sobrecalentándose.
. El procesador que esta corriendo se esta sobrecalentando: esto puede ser porque el procesador fue overclockeado, o el ventilador del procesador murió. En cualquier caso, asegúrese de que el hardware este corriendo con la características de fábrica, al menos mientras intenta solucionar este problema. Si no lo esta, reviértalo a las características por defecto.
+ 
Respecto al overclocking ¡Es mucho más barato tener un sistema lento que un sistema que necesita reemplazo! Además la comunidad no responde de manera simpática a problemas en sistemas overclockeados.
. Memoria defectuosa: si varias memorias SIMMS/DIMMS están instaladas, sáquelas todas e intente correr la máquina con cada SIMM o DIMM individualmente para reducir el problema a la DIMM/SIMM problemática o quizás incluso a una combinación.
. Ajustes excesivamente optimistas de la placa madre: las características del BIOS, y algunos jumpers de la placa madre, proveen opciones para ajustar varios timings. Los ajustes por defecto suelen ser suficientes, pero a veces ajustar los estados de espera de la RAM demasiado bajo, o activar la opción "RAM Speed: Turbo" pueden causar comportamiento extraño. Una idea posible es quedarse con los ajustes por defecto del BIOS, luego de haber previamente anotado los ajustes actuales.
. Poder sucio o insuficiente en la placa madre. Remueva las placas I/O , discos rígidos, o CD-ROMs sin usar, o desconecte el cable de encendido de ellos, para ver si el suministro eléctrico puede manejar una carga más pequeña. O intente otro suministro eléctrico, preferentemente uno con más poder. Por ejemplo, si el suministro actual esta registrado a 250 Watts, intente con uno registrado a 300 Watts.

Lea la sección acerca de <<signal11,Signal 11>> para más explicaciones y una discusión acerca de como el software o hardware que verifica la memoria puede no detectar memoria defectuosa. Hay un extenso FAQ acerca de esto en http://www.bitwizard.nl/sig11/[el problema SIG11FAQ].

Finalmente, si nada de esto ayuda, es posible que sea un error en FreeBSD. Siga <<access-pr,estas instrucciones>> para enviar un reporte de errores.

=== Mi sistema falla con Fatal trap 12: page fault in kernel mode, o panic:, y escupe un monton de información. ¿Qué debo hacer?

Los desarrolladores de FreeBSD están interesados en estos errores, pero necesitan mas información que solo el mensaje de error. Copie el mensaje de fallo entero. Luego consulte la sección del FAQ acerca de <<kernel-panic-troubleshooting,fallos de kernel>>, compile un kernel de depuración y obtenga un backtrace. Esto puede sonar difícil, pero no requiere habilidades de programación. Tan solo siga las instrucciones.

=== ¿Cual es el significado del error maxproc limit exceeded by uid %i, please see tuning(7) and login.conf(5)?

El kernel de FreeBSD solo permite que exista un cierto número de procesos en un punto determinado del tiempo. El número esta basado en la variable de man:sysctl[8]`kern.maxusers`. `kern.maxusers` también afecta varios otros límites del kernel, tales como los buffers de red. Si la máquina esta bajo una carga intensiva, incremente `kern.maxusers`. Esto incrementara estos otros límites del sistema, además del número máximo de procesos.

Para ajustar el valor de `kern.maxusers`, vea la sección link:{handbook}#kern-maxfiles[Límites de proceso/archivo] del manual. Mientras que esa sección se refiere a archivos abierto, los mismos límites aplican para los procesos.

Si la máquina tiene una carga ligera pero esta corriendo número muy alto de proceso, ajuste la variable `kern.maxproc` definiendola en [.filename]#/boot/loader.conf#. La variable no se ajustara hasta que el sistema se reinicie. Para más información acerca de ajustar variables, vea man:loader.conf[5]. Si estos procesos están siendo corridos por un solo usuario, ajuste `kern.maxprocperuid` para que sea uno menos que el nuevo valor de `kern.maxproc`. Debe ser al menos uno menos porque hay un programa del sistema, man:init[8], que debe estar corriendo constantemente.

=== ¿Por qué las aplicaciónes de pantalla completa en máquinas remotas se comportan mal?

La máquina remota puede estar ajustando el tipo de la terminal a un valor que no sea `xterm` el cual es requerido por la consola de FreeBSD. Alternativamente el kernel puede contener los valores equivocados para el ancho y alto de la terminal.

Verifique que el valor de la variable de entorno `TERM` sea `xterm`. Si la máquina remota no soporta eso, intente `vt100`.

Corra `stty -a` para verificar que dimensiones cree el kernel que tiene la terminal. Si son incorrectas, pueden cambiarse corriendo `stty rows _RR_ cols _CC_`.

Alternativamente, si la máquina del cliente tiene package:x11/xterm[] instalado, entonces correr `resize` consultara a la terminal las dimensiones correctas y las ajustara.

=== ¿Porque le lleva tanto tiempo a mi computadora conectarse via ssh o telnet?

El síntoma: hay un largo retraso entre el tiempo en que se establece la conexión TCP y el tiempo en el que el software del cliente pide una contraseña (o, en el caso de man:telnet[1], cuando aparece una pantalla de autenticación).

El problema: lo más probable, es que el retraso haya sido causado por el software del servidor intentando resolver la dirección IP del cliente a un nombre de host. Muchos servidores, incluyendo los servidores Telnet y SSH que vienen con FreeBSD, hacen esto para guardar el hostname en un archivo de log para referencias futuras del administrador.

La solución: si el problema ocurre siempre que se conecta la computadora cliente a cualquier servidor, el problema esta en el cliente. Si el problema ocurre solo cuando alguien se conecta a la computadora servidor, el problema esta en el servidor.

Si el problema esta en el cliente, la única solución es reparar el DNS de manera que el servidor pueda resolverla. Si esto ocurre en una red local, considerelo un problema del servidor y siga leyendo. Si esto ocurre en Internet, contacte a su ISP.

Si el problema es con el servidor en una red local, configure el servidor para resolver consultas de dirección a hostname para el rango de direcciones local. Vea man:hosts[5] y man:named[8] para más información. Si esto ocurre en la Internet, el problema puede ser que el resolver local del servidor no esta funcionando correctamente. Para verificar, intente buscar otro host tal como `www.yahoo.com`. Si esto no funciona, ese es el problema.

Luego de una instalación de cero de FreeBSD, también es posible que la información del dominio y servidor de nombres no exista en [.filename]#/etc/resolv.conf#. Esto frecuentemente causara un retraso en SSH, dado que la opción `UseDNS` esta ajustada a `yes` (si) por defecto en [.filename]#/etc/ssh/sshd_config#. Si esto esta causando el problema, llene la información faltante en [.filename]#/etc/resolv.conf# o ajuste `UseDNS` a `no` en [.filename]#sshd_config# como solución temporal.

=== ¿Por qué file: table is full aparece repetidamente en dmesg8?

Este mensaje de error indica que el número de descriptores de archivo disponibles en el sistema se agoto. Vea la subsección link:{handbook}#kern-maxfiles[kern.maxfiles] de la sección link:{handbook}#configtuning-kernel-limits/[Ajustando límites del kernel] del manual para una discusión y una solución.

=== ¿Por qué el reloj de mi computadora tiene el tiempo incorrecto?

La computadora tiene dos o más relojes, y FreeBSD eligió usar el incorrecto.

Corra man:dmesg[8], y verifique las líneas que contengan `Timecounter`. El del valor de calidad más alto que eligio FreeBSD.

[source,bash]
....
# dmesg | grep Timecounter
Timecounter "i8254" frequency 1193182 Hz quality 0
Timecounter "ACPI-fast" frequency 3579545 Hz quality 1000
Timecounter "TSC" frequency 2998570050 Hz quality 800
Timecounters tick every 1.000 msec
....

Confirme esto verificando el man:sysctl[3]`kern.timecounter.hardware`.

[source,bash]
....
# sysctl kern.timecounter.hardware
kern.timecounter.hardware: ACPI-fast
....

Puede tratarse de un timer ACPI roto. La solución más simple es deshabilitar el timer ACPI en [.filename]#/boot/loader.conf#:

[.programlisting]
....
debug.acpi.disabled="timer"
....

O el BIOS puede modificar el reloj TSC quizás para cambiar la velocidad del procesador cuando se agonten las baterías, o al cambiar al modo de ahorro de engería, pero FreeBSD no sabe nada de estos ajustes y parece estar perdiendo o ganando tiempo.

En este ejemplo, el reloj `i8254` también esta disponible, y puede ser seleccionando escribiendo su nombre en el man:sysctl[3]`kern.timecounter.hardware`.

[source,bash]
....
# sysctl kern.timecounter.hardware=i8254
kern.timecounter.hardware: TSC -> i8254
....

La computadora debería empezar a medir el tiempo de manera más correcta a partir de ahora.

Para que este cambio corra automáticamente en tiempo de arranque, agregue la siguiente línea a [.filename]#/etc/sysctl.conf#:

[.programlisting]
....
kern.timecounter.hardware=i8254
....

=== ¿Qué significa el error swap_pager: indefinite wait buffer:?

Esto significa que un proceso esta intentando paginar memoria al disco, y el intento de paginación se colgó intentando acceder al disco por más de 20 segundos. Puede estar causado por bloques defectuosos en el disco rígido, cableado del disco, cables, o cualquier otro tipo de hardware de E/S relacionado. Si el disco en si mismo esta defectuoso, los errores de disco aparecerán en [.filename]#/var/log/messages# y en la salida de `dmesg`. En otro caso, verifique los cables y las conexiones.

=== ¿Qué es un lock order reversal?

El kernel de FreeBSD usa un número de primitivas de sincronización para manejar la contención de ciertos recursos. Cuando múltiples hilos de kernel intentan obtener múltiples primitivas de sincronización, existe el potencial para un interbloqueo, en donde dos hilos obtuvieron cada uno una primitiva y se bloquean eternamente esperando que el otro hilo libere la otra. Este tipo de problema de bloqueo puede evitarse si todos los hilos obtienen las primitivas en el mismo orden.

Un sistema diagnóstico en tiempo de ejecución llamado man:witness[4], habilitado en FreeBSD-CURRENT y deshabilitado por defecto para ramas stable y lanzamientos, detecta el potencial para interbloques debido a errores de bloque, incluyendo errores causados por la obtención de múltiples primitivas de sincronización con un orden diferente de distintas partes del kernel. El framework man:witness[4] intenta detectar este problema mientras ocurre y lo reporta imprimiendo un mensaje en la consola del sistema acerca de un `lock order reversal` (también conocido como LOR).

Es posible obtener falsos positivos, dado que man:witness[4] es conservativo. Un reporte que realmente sea positivo _no_ significa que el sistema sufrió un interbloqueo; en su lugar, debería ser entendido como una advertencia que un interbloqueo podría haber ocurrido en ese lugar.

[NOTE]
====
Los LOR problemáticos tienden a arreglarse rápidamente, asi que verifique la http://lists.FreeBSD.org/mailman/listinfo/freebsd-current[lista de correo de FreeBSD-CURRENT] antes de postear allí.
====

=== ¿Qué significa Called ... with the following non-sleepable locks held?

Significa que una función que puede dormirse fue llamada mientras un mutex (u otra primitiva de sincronización que no duerme) estaba bloqueado.

La razón por la que esto es un error es que los mutexes no fueron concebidos para ser tenidos por largos períodos de tiempo; se supone que solo se tengan para mantener durante períodos cortos de sincronización. Este contrato de programación permite que los controladores de dispositivo usen mutexes para sincronizarse con el resto del kernel durante las interrupciones. Las interrupciones (bajo FreeBSD) pueden no dormirse. Luego es imperativo que ningún subsistema en el kernel se bloquee por un período extendido de tiempo al mantener un mutex.

Para atrapar tales errores, pueden agregarse aserciones al kernel para interactuar con el subsitema man:witness[4] y emitir una alerta o un error fatal (dependiendo de la configuración del sistema) cuando una llamada potencialmente bloqueante es hecha mientras que se mantiene un mutex.

En resumen, estas alertas no son fatales, no obstante errores de coordinación pueden causar efectos indeseables variando desde un mínimo retraso en la respuesta del sistema a un completo bloqueo del mismo.

Para información adicional acerca de los bloqueos en FreeBSD vea man:locking[9].

=== ¿Porque buildworld/installworld termina con el mensaje touch: not found?

Este error no significa que la utilidad man:touch[1] este faltante. En su lugar el error probablemente se debe a que las fechas de los archivos están ajustadas a una fecha futura. Si el reloj CMOS esta ajustado a tiempo local, corra `adjkerntz -i` para ajustar el reloj del kernel al arrancar en modo de un solo usuario.

== Aplicaciones de usuario

=== ¿Cuáles son las aplicaciones de usuario?

Vaya a https://www.FreeBSD.org/ports/[la página de ports] para información acerca de paquetes de software que han sido porteados a FreeBSD. La lista actual contiene más de 24,000 y crece diariamente, vuelva y verifíquela seguido o subscribase a la http://lists.FreeBSD.org/mailman/listinfo/freebsd-announce[lista de anuncios de FreeBSD] para actualizaciones periódicas sobre nuevas entradas.

La mayoría de los ports deberían funcionar en todas las version soportadas de FreeBSD. Los que no lo hacen están marcados específicamente de esta manera. Cada vez que se realiza una versión de FreeBSD, se hace un snapshot del árbol de ports al momento de la versión que se incluye en el directorio [.filename]#ports/#.

FreeBSD soporta paquetes binarios comprimidos para instalar y desinstalar ports fácilmente. Use man:pkg[7] para controlar la instalación de paquetes.

=== ¿Como descargo el árbol de Ports? ¿Debería usar SVN?

Cualquiera de los métodos listados aquí funciona:

* Use portsnap para la mayoría de los casos. Vea link:{handbook}#ports-using/[Usando la colección de Ports] para instrucciones acerca de como usar esta herramienta.
* Use SVN si se necesitan parches personalizados para el árbol de ports. Vea link:{handbook}#svn/[Usando Subversion] para más detalles.
* Use CTM, como se describe en link:{handbook}#ctm/[Usando CTM] para recibir parches por correo electrónico sobre una conexión a internet poco confiable.

=== ¿FreeBSD soporta Java?

Si. Vea https://www.FreeBSD.org/java/[http://www.FreeBSD.org/java/] para más información.

=== ¿Porque no puedo compilar este port en mi máquina 9.X -, o 10.X -STABLE?

Si la versión de FreeBSD instalada se atrasa significativamente de _-CURRENT_ o _-STABLE_, actualice la colección de ports usando las instrucciones en link:{handbook}#ports-using/[Usando la colección de ports]. Si el sistema esta actualizado, alguien puede haber commiteado un cambio al port que funciona para _-CURRENT_ pero que rompió el port para _-STABLE_. https://bugs.FreeBSD.org/submit/[Envíe] un reporte de errores, dado que se supone que la colección de ports funcione tanto para la rama _-CURRENT_ como para _-STABLE_.

=== Acabo de intentar compilar INDEX usando make index y fallo. ¿Porque?

Primero, asegúrese de que la colección de ports esta actualizada. Errores que afecten la compilación de [.filename]#INDEX# de una copia actualizada de la colección de ports tienen alta visibilidad y suelen arreglarse casi inmediatamente.

Hay raras ocurrencias en las que [.filename]#INDEX# no compilara debido a casos extraños que involucren variables `WITH__*_` o `WITHOUT__*_` siendo ajustadas en [.filename]#make.conf#. Si sospecha que este es el caso, intente hacer make de [.filename]#INDEX# con esas variables desactivadas antes de reportar el error a la http://lists.FreeBSD.org/mailman/listinfo/freebsd-ports[lista de correo de ports de FreeBSD ].

=== He actualizado el código fuente ¿Como actualizo mis ports instalados?

FreeBSD no incluye una herramienta para actualizar ports, pero si tiene herramientas para hacer el proceso de actualización un poco más fácil. Herramientas adicionales están disponibles para simplificar el manejo de ports y son descriptas en la sección link:{handbook}#ports-using/[Actualizando ports]en el manual de FreeBSD.

=== ¿Es necesario que recompile todos los ports cada vez que hago una actualización a una versión mayor?

¡Si! Mientras que un sistema reciente correrá con software compilado bajo una versión vieja, hay cosas que pueden fallar al azar o no funcionar una vez que otros ports sean instalados o actualizados.

Cuando el sistema se actualiza, varias librerías compartidas, módulos cargables y otras partes del sistema serán reemplazadas por versiones más nuevas. Las aplicaciones que estén vinculadas contra las version más viejas pueden fallar al iniciar o, en otros casos, fallar al funcionar con propiedad.

Para más información, vea link:{handbook}#freebsdupdate-upgrade[la sección acerca de actualizaciones] en el manual de FreeBSD.

=== ¿Debo recompilar todos los ports cada vez que realizo una actualización a una versión menor?

En general, no. Los desarrolladores de FreeBSD hacen lo posible para garantizar compatibilidad binaria en todas las versiones con el mismo número de versión mayor. Cualquier excepción será documentada en las notas de lanzamiento, y los consejos que se presenten allí deberán ser seguidos.

=== ¿Por qué es /bin/sh tan mínimo? ¿Por qué FreeBSD no usa bash u otro shell?

Mucha gente necesita escribir scripts de shell que sean portables a muchos sistemas. Por eso es que POSIX(TM) especifica el shell y los comandos utilitarios en gran detalle. La mayoría de los scripts están escritors en el shell de Bourne (man:sh[1]), y porque varias interfaces de programación importantes (man:make[1], man:system[3], man:popen[3], y análogos en lenguajes de scripting de alto nivel como Perl y Tcl) son instruidos para usar el shell de Bourne para interpretar comandos. Porque el shell de Bourne es usado frecuentemente y ampliamente, es importante que sea rápido al iniciar, que se comporte de manera determinística, y que tenga una pequeña huella de memoria.

La implementación existente es nuestro mejor esfuerzo para satisfacer simultaneamente el mayor número de requerimientos de este tipo que podamos. Para mantener `/bin/sh` pequeña, no proveemos muchas de las características convenientes que tienen otros shells. Por esto es que otras shells con más características como `bash`, `scsh`, man:tcsh[1], y `zsh` están disponibles. Compare el uso de memoria de estas shell mirando las columnas "VSZ" y "RSS" en el listado del comando `ps -u`.

=== ¿Cómo creo CDs de audio a partir de mis archivos MIDI?

Para crear CDs de audio a partir de archivos MIDI, primero instale package:audio/timidity[] desde ports y luego instale manualmente el set de parches GUS por Eric A. Welsh, disponible en link:http://alleg.sourceforge.net/digmid.html[http://alleg.sourceforge.net/digmid.html]. Luego de que TiMidity++ haya sido instalada con propiedad, los archivos MIDI pueden convertirse a archivos WAV con el siguiente comando:

[source,bash]
....
% timidity -Ow -s 44100 -o /tmp/juke/01.wav 01.mid
....

Los archivos WAV pueden posteriormente convertirse a otros formatos o grabarse en CDs de audio, como se describe en el link:{handbook}#creating-cds/[manual de FreeBSD].

== Configuración del Kernel

[[make-kernel]]
=== Quisiera personalizar mi kernel. ¿Es esto difícil?

¡En absoluto! Vea la link:{handbook}#kernelconfig/[sección del manual acerca de configuración del kernel].

[NOTE]
====
El nuevo [.filename]#kernel# será instalado en el directorio [.filename]#/boot/kernel# junto con sus módulos, mientras que el viejo kernel y sus módulos serán movidos al directorio [.filename]#/boot/kernel.old#. Si ocurre un error en la configuración, simplemente arranque desde la versión anterior del kernel.
====

=== ¿Por qué es mi kernel tan grande?

Los kérneles `GENERIC` que vienen con FreeBSD son compilados en _modo de depuración_. Los kernels que se compilan en modo de depuración contienen datos de depuración en archivos separados que se usan para la depuración. Las versiones de FreeBSD anteriores a 11.0 guardan estos archivos de depuración en el mismo directorio en que se encuentra el kernel , [.filename]#/boot/kernel/#. En FreeBSD 11.0 y posteriores los archivos de depuración se guardan en [.filename]#/usr/lib/debug/boot/kernel/#. Nótese que habrá muy poca o ninguna perdida de desempeño debida al uso de un kernel de depuración, y es útil mantener uno en caso de un pánico del sistema.

Cuando se agote el espacio en disco, hay diferentes opciones para reducir el tamaño de [.filename]#/boot/kernel/# y [.filename]#/usr/lib/debug/#.

Para no instalar los archivos de símbolos, asegúrese de que la siguiente línea exista en [.filename]#/etc/src.conf#:

[.programlisting]
....
WITHOUT_KERNEL_SYMBOLS=yes
....

Para más información vea man:src.conf[5].

Si desea evitar por completo compilar archivos de depuración, asegurese de que se cumpla lo siguiente:

* Esta línea no existe en el archivo de configuración del kernel:
+
[.programlisting]
....
makeoptions DEBUG=-g
....

* No corra man:config[8] con `-g`.

Cualquiera de las opciones anteriores causaran que el kernel se compile en modo de depuración.

Para compilar e instalar solo los módulos especificados, listelos en [.filename]#/etc/make.conf#:

[.programlisting]
....
MODULES_OVERRIDE= accf_http ipfw
....

Reemplaze _accf_httpd ipfw_ con una lista de los módulos que necesita. Solo los módulos listados serán compilados. Esto reduce el tamaño del directorio del kernel y reduce la cantidad de tiempo requerido para compilar el kernel. Para más información, lea [.filename]#/usr/shared/examples/etc/make.conf#.

Los dispositivos innecesarios pueden ser removidos del kernel para reducir aún más su tamaño. Vea <<make-kernel>> para más información.

Para que estas opciones hagan efecto, siga las instrucciones para link:{handbook}#kernelconfig-building/[compilar y instalar] el nuevo kernel.

Para referencias, el kernel de FreeBSD 11 en amd64 ([.filename]#/boot/kernel/kernel#) ocupa aproximadamente approximately 25 MB.

=== ¿Por qué cada kernel que intento construir falla al compilar, incluso GENERIC?

Hay varias causas posibles para este problema:

* El código fuente es diferente del que se usa para compilar el sistema actual que esta corriendo. Al intentar actualizar, lea [.filename]#/usr/src/UPDATING#, prestando atención especial a la sección "COMMON ITEMS" al final.
* El comando `make buildkernel` no se completo de manera exitosa. El objetivo `make buildkernel` depende de archivos generados por el objetivo `make buildworld` para terminar su trabajo correctamente.
* Incluso al compilar <<stable,FreeBSD-STABLE>>, es posible que árbol de código fuente haya sido obtenido en una etapa en la que esta siendo modificado o estaba roto. Solo se garantiza que los lanzamientos sean compilables, aunque <<stable,FreeBSD-STABLE>> compila correctamente la mayor parte del tiempo. Intente re-obtener el árbol de código fuente y vea si el problema desaparece. Intente usar un mirror distinto en casa de que el anterior presente problemas.

=== ¿Qué planificador esta en uso en un sistema en funcionamiento?

El nombre del planificador siendo usado actualmente esta directamente disponible como el valor del sysctl `kern.sched.name`:

[source,bash]
....
% sysctl kern.sched.name
kern.sched.name: ULE
....

=== ¿Qué es kern.sched.quantum?

`kern.sched.quantum` es el máximo número de ticks que puede correr un proceso sin ser apropiado por el planificador de 4BSD.

== Discos, sistemas de archivos y cargadores de arranque

=== ¿Como puedo agregar mi nuevo disco duro a mi sistema FreeBSD?

Vea la sección link:{handbook}#disks-adding/[Añadir discos] en el manual de FreeBSD.

=== ¿Como muevo mi sistema actual a mi nuevo y enorme disco?

La mejor manera es reinstalar el sistema operativo en el nuevo disco, y luego mover los datos. Esto es altamente recomendado al seguir _-STABLE_ por más de un lanzamiento o al actualizar una versión en lugar de instalar una nueva. Instale booteasy en ambos discos con man:boot0cfg[8] y luego arranque en modo dual hasta que este contento con la nueva configuración. Saltéese el próximo párrafo para averiguar como mover los datos luego de hacer esto.

Alternativamente, particiones y marque el nuevo disco con man:sade[8] o man:gpart[8]. Si los discos están formateados con MBR, booteasy puede instalarse en ambos discos con man:boot0cfg[8] de manera que la computadora pueda arrancar en modo dual con el viejo o el nuevo sistema luego de que se haya realizado el copiado.

Una vez configurado el nuevo disco, los datos no pueden simplemente copiarse. En su lugar utilice las herramientas que entiendan los archivos de dispositivos y las banderas del sistema, tales como man:dump[8]. Aunque se recomienda mover los datos mientras se encuentre en modo de un solo usuario, esto no es requerido.

Cuando los discos esten formateados con UFS, nunca use nada excepto man:dump[8] y man:restore[8] para mover el sistema de archivos raíz. Estos comandos también deberían ser usados al mover una única partición a otra partición vacía. La secuencia de pasos para usar `dump` para mover los datos de una partición UFS a una nueva partición es:

[.procedure]
====
. `newfs` a la nueva partición
. `mount` en un punto de montaje temporal.
. `cd` a ese directorio.
. `dump` la vieja partición, concatenando la salida a la nueva.
====

Por ejemplo, para mover [.filename]#/dev/ada1s1a# con [.filename]#/mnt# como punto de montaje temporario, escriba:

[source,bash]
....
# newfs /dev/ada1s1a
# mount /dev/ada1s1a /mnt
# cd /mnt
# dump 0af - / | restore rf -
....

Reorganizar particiones con `dump` lleva un poco más de trabajo. Para combinar una partición como [.filename]#/var# con su padre, cree una nueva partición que sea lo suficientemente grande como para ambas, mueva la partición padre como se describió anteriormente, y luego mueva la partición hija al directorio vacío que creo la primera movida:

[source,bash]
....
# newfs /dev/ada1s1a
# mount /dev/ada1s1a /mnt
# cd /mnt
# dump 0af - / | restore rf -
# cd var
# dump 0af - /var | restore rf -
....

Para separar un directorio de su padre, por ejemplo poniendo [.filename]#/var# en su propia partición cuando no estaba ahi anteriormente, cree ambas particiones, luego monte la partición hija en el directorio apropiado en el punto de montaje temporario, luego mueva la vieja partición:

[source,bash]
....
# newfs /dev/ada1s1a
# newfs /dev/ada1s1d
# mount /dev/ada1s1a /mnt
# mkdir /mnt/var
# mount /dev/ada1s1d /mnt/var
# cd /mnt
# dump 0af - / | restore rf -
....

Las utilidades man:cpio[1] y man:pax[1] también están disponibles para mover datos del usuario. Es sabido que estas utilidades pierden información de las baneras, de modo que úselas con cuidado.

=== ¿Qué particiones pueden usar con seguridad Soft Updates? Escuche que utilizar Soft Updates en / puede causar problemas. ¿Qué sucede con Journaled Soft Updates?

Respuesta corta: Soft Updates pueden por lo general usarse de manera segura en todas las particiones.

Respuesta larga: Soft Updates tiene dos características que pueden ser indeseables en ciertas particiones. Primero, una partición con Soft Updates tiene una pequeña chance de perder datos durante una falla del sistema. La partición no se corrompera dado que los datos simplemente se perderan. Segundo, Soft Updates puede causar faltas de espacio temporales.

Al usar Soft Updates, el kernel puede tomar hasta treinta segundos para escribir los cambios al disco físico. Cuando un archivo grande se borra el archivo aún reside en el disco hasta que el kernel realmente realice el borrado. Esto puede causar una condición de carrera muy simple. Suponga que un archivo grande es borrado y otro archivo grande se crea inmediatamente. El primer archivo grande no ha sido removido aún del disco físico, de modo que el disco puede no tener suficiente espacio para el segundo archivo grande. Esto producirá un error diciendo que la partición no tiene suficiente espacio, aun cuando una gran cantidad de espacio acaba de liberarse. Un par de segundos más tarde, la creación de archivos funciona de manera esperada.

Si un sistema falla luego de que el kernel acepte un gran trozo de datos para escribir a disco, pero antes de que los datos sean realmente escritos, los mismos pueden perderse. El riesgo es extremadamente mínimo, pero generalmente es manejable.

Estos problemas afectan a todas las plataformas que utilicen Soft Updates. ¿Qué significa esto para la partición raíz?

La información vital en la partición raíz cambia de manera muy esporádica. Si el sistema fallo durante la ventana de treinta segundos luego de que se realice este cambio, es posible que se pierdan datos. El riesgo es negligible para la mayoría de las aplicaciones, pero tenga en cuenta que existe. Si el sistema no puede tolerar este riesgo... ¡No use Soft Updates en el sistema de archivos raíz!

[.filename]#/# es tradicionalmente una de las particiones más pequeñas. Si [.filename]#/tmp# esta en [.filename]#/#, puede haber problemas con el espacio intermitente. Realizar un symlink de [.filename]#/tmp# a [.filename]#/var/tmp# resolverá este problema.

Finalmente, man:dump[8] no funciona en modo vivo (-L) en un sistema de archivos, con Journaled Soft Updates (SU+J).

=== ¿Puedo montar otros sistemas de archivos no nativos bajo FreeBSD?

FreeBSD soporta muchos otros sistemas de archivos.

UFS::
Los CD-ROM que usen UFS pueden montarse directamente en FreeBSD. Montar particiones de discos de Digital UNIX y otros sistemas que soporten UFS puede ser más complejo, dependiendo de los detalles acerca del particionado de disco del sistema operativo en cuestión.

ext2/ext3::
FreeBSD soporta particiones `ext2fs` y `ext3fs`. Vea man:ext2fs[5] para más información.

NTFS::
Soporte para NTFS basado en FUSE esta disponible como un port (package:sysutils/fusefs-ntfs[]). Para más información vea http://www.tuxera.com/community/ntfs-3g-manual/[ntfs-3g].

FAT::
FreeBSD incluye un controlador de lectura-escritura FAT. Para más información vea man:mount_msdosfs[8].

ZFS::
FreeBSD incluye un port del controlador de ZFS de Sun(TM). La recomendación actual es solo usarlo en plataformas amd64 platforms con suficiente memoria. Para más información. vea man:zfs[8].

FreeBSD incluye el Network File System NFS y la colección de ports de FreeBSD Ports Collection provee varias aplicaciones de FUSE para soportar muchos otros sistemas de archivos.

=== ¿Como monto una partición DOS secundaria?

Las particiones de DOS secundarias se encuentras luego de _todas_ las particiones primarias. Por ejemplo, si `E` es la segunda partición DOS en el segundo dispositivo SCSI, habrá un dispositivo para "slice 5" en [.filename]#/dev#. Para montarlo corra:

[source,bash]
....
# mount -t msdosfs /dev/da1s5 /dos/e
....

=== ¿Existe un sistema de archivos criptográfico para FreeBSD?

SI, man:gbde[8] y man:geli[8]. Vea la sección link:{handbook}#disks-encrypting[Encriptar particiones de disco] del manual de FreeBSD.

=== ¿Cómo hago para arrancar FreeBSD y Linux usando GRUB?

Para arrancar FreeBSD usando GRUB, y añada lo siguiente a [.filename]#/boot/grub/menu.lst# o [.filename]#/boot/grub/grub.conf#, dependiendo de como sea usado por la distribución de Linux(TM).

[.programlisting]
....
title FreeBSD 9.1
	root (hd0,a)
	kernel /boot/loader
....

Donde _hd0,a_ apunte a la partición raíz del primer disco. Para especificar el número de slice, utilice algo como esto _(hd0,2,a)_. Por defecto, si el número de slice es omitido, GRUB busca la primera dado que tiene la partición `a`.

=== ¿Como arranco FreeBSD y Linux usando BootEasy?

Instale LILO al inicio de la partición de arranque de Linux(TM) en lugar de en el Registro de Arranque Principal Luego podrá arrancar LILO desde BootEasy.

Esto se recomienda al correr Windows(TM) y Linux(TM) dado que hace mucho más simple lograr que Linux(TM) arranque nuevamente si Windows(TM) es reinstalado.

=== ¿Como cambio el indicador de arranque de ??? a algo que tenga más sentido?

Esto no puede lograrse con el cargador de arranque estándar sin reescribirlo. Existen varios otros cargadores de arranque en la categoría [.filename]#sysutils# de la colección de ports.

=== ¿Como utilizo un nuevo disco removible?

Si el disco ya tiene un sistema de archivos en el, use un comando como este:

[source,bash]
....
# mount -t msdosfs /dev/da0s1 /mnt
....

Si el disco solo puede ser usado con sistemas FreeBSD, particionelo con UFS o ZFS. Esto proveerá soporte para nombres de archivo largos, mejoras en performance y estabilidad. Si el disco va a ser usado por otros sistemas operativos, una opción más portable, tal como msdosfs, es preferible.

[source,bash]
....
# dd if=/dev/zero of=/dev/da0 count=2
# gpart create -s GPT /dev/da0
# gpart add -t freebsd-ufs /dev/da0
....

Finalmente, cree un nuevo sistema de archivos:

[source,bash]
....
# newfs /dev/da0p1
....

y móntelo:

[source,bash]
....
# mount /dev/da0s1 /mnt
....

Es una buena idea agregar una línea a [.filename]#/etc/fstab# (vea man:fstab[5]) de manera que pueda simplemente escribir `mount /mnt` en el futuro:

[.programlisting]
....
/dev/da0p1 /mnt ufs rw,noauto 0 0
....

=== ¿Por qué obtengo Incorrect super block al montar un CD?

El tipo de dispositivo a montar debe estar especificado. Esto se describe en la sección del manual acerca de link:{handbook}#mounting-cd[Usar CDs de datos].

=== ¿Por qué obtengo Device not configured al montar un CD?

Esto usualmente significa que no hay CD en el dispositivo, o que el dispositivo no es visible en el bus. Refiérase a la sección link:{handbook}#mounting-cd[Usando CDs de datos] del manual para una discusión detallada de este problema.

=== ¿Por qué todos los caracteres no ingleses en los nombres de archivo se muestran como ? en mis CDs cuando los monto en FreeBSD?

El CD probablemente use la extensión "Joliet" para guardar información acerca de archivos y directorios. Esto se discute en la sección del manual link:{handbook}#mounting-cd[Usando CDs de datos].

=== Un CD grabado bajo FreeBSD no puede ser leído bajo ningún otro sistema operativo. ¿Porque?

Esto significa que un archivo crudo fue grabado al CD, en lugar de crear un sistema de archivos ISO 9660. Dele un vistazo a la sección del manual acerca de link:{handbook}#mounting-cd[Utilizar CDs de datos].

=== ¿Como puedo crear una imagen de un CD de datos?

Esto se dicute en la sección del manual acerca de link:{handbook}#mkisofs[Escribir datos a un sistema de archivos ISO]. Para más información acerca de trabajar con CD-ROMs, vea la link:{handbook}#creating-cds/[sección acerca de crear CDs] en el capítulo de almacenamiento en el manual.

=== ¿Porque no puedo hacer mount a un CD de audio?

Intentar montar un CD de audio producira un error como `cd9660: /dev/acd0c: Invalid argument`. Esto es porque `mount` solo funciona en sistemas de archivos. Los CDs de audio no tienen sistemas de archivos; solo tienen datos. En su lugar, utilice un programa que lea CDs de audio, como el paquete o port de package:audio/xmcd[].

=== ¿Como hago mount a un CD multi-sesión?

Por defecto, man:mount[8] intentara montar la última pista de datos (sesión) a un CD. Para cargar una sesión anterior, use el argumento de linea de comandos `-s`. Vea man:mount_cd9660[8] para ejemplos específicos.

=== ¿Como hago para que los usuarios comunes puedan montar CD-ROMs, DVDs, dispositivos USB, y otros medios removibles?

Como `root` ajuste la variable de sysctl `vfs.usermount` a `1`.

[source,bash]
....
# sysctl vfs.usermount=1
....

Para hacer que esto persista a un reinicio, agregue la línea `vfs.usermount=1` a [.filename]#/etc/sysctl.conf# de modo que se vuelva a ajustar al inicio del sistema.

Los usuarios solo pueden montar dispositivos que tienen permisos para leer. Para permitir que los usuarios monten un dispositivo los permisos deben establecerse en [.filename]#/etc/devfs.conf#.

Por ejemplo, para permitir a los usuarios montar el primer dispositivo de USB añada:

[.programlisting]
....
# Prmitir a todos los usuarios montar un dispositivo USB.
	    own       /dev/da0       root:operator
	    perm      /dev/da0       0666
....

Ahora todos los usuarios pueden montar dispositivos que podrían leer a un directorio propio:

[source,bash]
....
% mkdir ~/my-mount-point
% mount -t msdosfs /dev/da0 ~/my-mount-point
....

Desmontar el dispositivo es fácil:

[source,bash]
....
% umount ~/my-mount-point
....

Habilitar `vfs.usermount`, no obstante, tiene implicaciones de seguridad negativas. Una mejor manera de acceder a medios formateados con MS-DOS(TM) es usar el paquete package:emulators/mtools[] en la colección de ports.

[NOTE]
====
El nombre de dispositivo usado en los ejemplos anteriores debe ser cambiado de acuerdo a la configuración.
====

=== Los comandos du y df muestran diferentes cantidades de espacio en disco disponible. ¿Qué esta pasando?

Esto se debe a como funcionan ambos comandos. `du` atraviesa el árbol de directorio, mide que tan largo es cada archivo, y presenta los totales. `df` únicamente le pregunta al sistema de archivos cuanto espacio tiene disponible. Pueden parecer cosas idénticas, pero un archivo sin una entrada de directorio afectara a `df` pero no a `du`.

Cuando un programa esta usando un archivo, y el mismo es borrado, el archivo no se borra realmente del sistema de archivos hasta que el programa deja de usarlo. El archivo es luego inmediatamente borrado del listado de directorio, de todas formas. Como ejemplo, considere un archivo que sea lo suficientemente grande como para afectar la salida de `du` y `df`. Un archivo que este siendo visto con `more` puede ser borrado sin causar un error. La entrada es borrada del directorio de modo que ningún otro programa o usuario pueda accederla. No obstante, `du` muestra que el archivo no existe dado que ha atravesado el árbol de directorios y el archivo no esta listado. `df` muestra que sigue alli, dado que el sistema de archivos sabe que `more` sigue usando ese espacio. Una vez que la sesión de `more` termine, `du` y `df` estarán de acuerdo.

Esta situación es común en servidores web. Mucha gente crea un servidor web en FreeBSD y ser olvida de rotar los archivos de log. El log de acceso llena [.filename]#/var#. El nuevo administrador borra el archivo, pero el sistema se seguira quejando de que la partición esta llena. Parar y reiniciar el programa del servidor web liberara el archivo, permitiendo que el sistema libere espacio en disco. Para prevenir que esto pase, configure man:newsyslog[8].

Note que Soft Updates puede retrasar la liberación de espacio en el disco y que puede tomar hasta 30 segundos para que el cambio sea visible.

=== ¿Como agrego más espacio swap?

Esta sección link:{handbook}#adding-swap-space/[del manual] describe como hacer esto.

=== ¿Por qué FreeBSD ve mi disco como mas pequeño de lo que el fabricante dice que es?

Los fabricantes de discos calculan gigabytes como un millón de bytes cada uno, mientras que FreeBSD los calcula como 1,073,741,824 bytes cada uno. Esto explica porque, por ejemplo, los mensajes de arranque de FreeBSD reportan un disco que se supone que tenga 80 GB como si tuviera 76,319 MB.

También note que FreeBSD (por defecto) <<disk-more-than-full,reserva>> 8% de espacio del disco.

=== ¿Como es posible para una partición estar más del 100% llena?

Una porción de cada partición UFS (8%, por defecto) esta reservada para su uso por el sistema operativo y el `root` usuario. man:df[1] no cuenta ese espacio al calcular la columna `Capacity` (Capacidad), de modo que puede exceder el 100%. Note que la columna `Blocks` (Bloques) siempre es mayor que la suma de las columnas `Used` (Usado) y `Avail` (Disponibilidad), usualmente por un factor del 8%.

Para más detalles, busque `-m` en man:tunefs[8].

=== ¿Por qué FreeBSD pausa por un largo tiempo al iniciar cuando el sistema tiene gran cantidad de ram?

FreeBSD 10.1 y versiones anteriores hacen una prueba de memoria tempranamente en el proceso de arranque. Cuando el sistema tiene una cantidad pequeña de memoria, la prueba toma un par de segundos. A las computadoras con diez o miles de gigabytes de memoria puede llevarles varios minutos completar el test. El test de memoria puede deshabilitarse añadiendo `hw.memtest.tests=0` a [.filename]#/boot/loader.conf#.

Para más detalles, vea man:loader.conf[5].

== ZFS

=== ¿Cuál es la cantidad mínima de RAM necesaria para correr ZFS?

Se necesita un mínimo de 4GB de RAM para un uso típico, pero la carga de trabajo individual puede variar ampliamente.

=== ¿Qué es el ZIL y cuando se usa?

El ZIL (ZFS intent log) es un log de escritura utilizado para implementar semánticas de commiteo de escritura de posix entre fallos del sistema. Normalmente las escrituras están empaquetadas en grupos de transacción para escribirse al disco al llenarse ("Transaction Group Commit"). No obstante syscalls tales como man:fsync[2] requieren un compromiso de que los datos se escriban a un almacenamiento estable antes de regresar. El ZIL es necesario para escrituras que se reconocieron como realizadas pero que no estan en disco aún como parte de una transacción. Los grupos de transacción tienen una marca de tiempo. En el caso de un fallo la última marca de tiempo válida es encontrada y los datos faltantes se combinan desde el ZIL.

=== ¿Necesito un SSD para el ZIL?

Por defecto, ZFS guarda el ZIL en el pool junto con el resto de los datos. Si una aplicación tiene una gran carga de escritura, guardar el ZIL en un dispositivo separado que tenga un rendimiento de escritura secuencial muy rápido y asincrónico puede mejorar el sistema en general. Para otro tipo de cargas, es poco probable que un SSD represente una gran mejora.

=== ¿Qué es el L2ARC?

El L2ARC es una cache de lectura guardada en un dispositivo rápido tal como un SSD. Esta cache no persiste entre reinicios. Notese que la RAM es usada como primera capa de cache y el L2ARC solo es necesitado si hay RAM insuficiente.

L2ARC necesita espacio en el ARC para indexarlo. De modo que, extrañamente, un conjunto de trabajo que encaja perfectamente en el ARC dejara de encajar perfectamente si el L2ARC se usa porque una parte del ARC esta reteniendo el índice el L2ARC, pasando una parte del conjunto de trabajo al L2ARC que es más lento que la memoria RAM.

=== ¿Es aconsejable habilitar deduplicación?

Generalmente hablando, no.

Deduplicación requiere una cantidad significativa de RAM y puede realentizar los tiempos de acceso del disco para lectura y escritura. A no ser que se estén guardando datos que están altamente duplicados, tales como las maquinas virtuales o respaldos hechos por el usuario, es posible que la dedpulicación haga más mal que bien. Otra consideración es la incapacidad de revertir el estado de deduplicación. Si los datos son escritos al habilitar deduplicación, deshabilitar dedup no causara que los bloques que fueron deduplicados se repliquen hasta que estos vuelvan a ser modificados.

Deduplicación también puede llevar a situaciones inesperadas. En particular, borrar archivos puede volverse mucho más lento.

=== No puedo borrar ni crear archivos en mi pool de ZFS. ¿Como puedo arreglar esto?

Esto puede ocurrir porque el pool esta 100% lleno. ZFS requiere espacio en el disco para escribir los metadatos de transacción. Para restaurar el pool a un estado usable, trunque el archivo a borrar:

[source,bash]
....
% truncate -s 0 archivo-sin-importancia
....

La truncación de archivos funciona porque no se inicia una nueva transacción, en su lugar se crean nuevos bloques de repuesto.

[NOTE]
====
En sistemas con ajustes adicionales al set de datos de ZFS, tales como deduplicación, el espacio puede no estar inmediatamente disponible.
====

=== ¿Soporta ZFS TRIM para discos de estado sólido?

El soporte para TRIM en ZFS fue añadido a FreeBSD 10-CURRENT con la revisión rlink:https://svnweb.freebsd.org/changeset/base/240868[r240868]. El soporte para TRIM en ZFS se agrego a todas las ramas FreeBSD-STABLE en rlink:https://svnweb.freebsd.org/changeset/base/252162[r252162] y rlink:https://svnweb.freebsd.org/changeset/base/251419[r251419], respectivamente.

TRIM esta habilitado por defecto en ZFS, y puede ser deshabilitado agregando esta línea a [.filename]#/etc/sysctl.conf#:

[.programlisting]
....
vfs.zfs.trim_disable=1
....

[NOTE]
====
TRIM en ZFS puede no funcionar con todas las configuraciones, tales como un sistema de archivos ZFS en un dispositivo respaldado con GELI.
====

== Administración del sistema

=== ¿Cuáles son los archivos de configuración para el arranque del sistema?

El archivo de configuración principal es [.filename]#/etc/defaults/rc.conf# el cual se describe en man:rc.conf[5]. Los scripts de arranque del sistema tales como [.filename]#/etc/rc# y [.filename]#/etc/rc.d#, los cuales son descritos en man:rc[8], incluyen este archivo. _¡No edite este archivo!_ En su lugar, para editar una entrada en [.filename]#/etc/defaults/rc.conf#, copie la línea a [.filename]#/etc/rc.conf# y cámbiela allí.

Por ejemplo, para arrancar man:named[8], el servidor de DNS incluido

[source,bash]
....
# echo 'named_enable="YES"' >> /etc/rc.conf
....

Para arrancar servicios locales, coloque los scripts de shell en el directorio [.filename]#/usr/local/etc/rc.d#. Los scripts de shell deben ser ejecutables, el modo de archivo por defecto es `555`.

=== ¿Como agrego fácilmente un usuario?

Use el comando man:adduser[8], o el comando man:pw[8] para situaciones más complicadas.

Para remover el usuario, use el comando man:rmuser[8]o, si es necesario, man:pw[8].

=== ¿Por qué recibo constantemente mensajes del estilo root: not found luego de editar /etc/crontab?

Esto usualmente esta provocado por editar el crontab del sistema. Esta no es la manera correcta de hacer las cosas, dado que el crontab del sistema tiene un formato distinto para los crontabs por usuario. El crontab del sistema tiene un campo extra, especificando como que usuario se debe correr el comando. man:cron[8] asume que este usuario es la primera palabra del comando a ejecutar. Dado que no existe tal comando, aparece este mensaje de error.

Para borrar el contrab extra e incorrecto:

[source,bash]
....
# crontab -r
....

=== ¿Por qué tengo el error you are not in the correct group to su root cuando intento hacer su a root?

Esta es una característica de seguridad. Para hacer `su` a `root`, o cualquier otra cuenta con privilegios de superusuario, la cuenta de usuario debe ser miembra del grupo `wheel`. Si esta característica no estuviera, cualquiera con una cuenta en el sistema que haya adivinado la contraseña de `root` podría ganar acceso de superusuario al sistema.

Para permitir que alguien haga `su` a `root`, póngalo(s) en el grupo `wheel` usando `pw`:

[source,bash]
....
# pw groupmod wheel -m lisa
....

El ejemplo anterior agregara al usuario `lisa` al grupo `wheel`.

=== Cometi un error en rc.conf, u otro archivo de inicio, y ahora no puedo editarlo porque el sistema de archivos es de solo lectura. ¿Qué debo hacer?

Reinicie el sistema usando `boot -s` en el indicador de arranque para entrar en el modo de un solo usuario. Cuando se le pida un nombre de ruta para el shell, presione kbd:[Enter] y corra `mount -urw /` para re-montar el sistema de archivos raíz en modo de lectura/escritura. Quizas también tenga que correr `mount -a -t ufs` para montar el sistema de archivos donde esta definido su editor favorito. Si ese editor esta en un sistema de archivos de red, configure la red manualmente antes de montar sistemas de archivos en red, o use un editor que redia en el sistema de archivos local, como man:ed[1].

Para usar un editor de pantalla completa tal como man:vi[1] o man:emacs[1], corra `export TERM=xterm` en FreeBSD 9.0+ de manera que estos editores puedan cargar correctamente los datos desde la base de datos de man:termcap[5].

Luego de realizar estos pasos, edite [.filename]#/etc/rc.conf# para arreglar el error de sintaxis. El mensaje de error que se muestra inmediatamente luego de los mensajes de arranque del kernel debería indicar que número de línea en el archivo tiene el problema.

=== ¿Por qué tengo problemas para configurar mi impresora?

Vea la link:{handbook}#printing/[entrada del manual acerca de imprimir] para consejos sobre como solucionar el problema.

=== ¿Como puedo corregir los mapeos del teclado para mi sistema?

Vea la sección del manual acerca de link:{handbook}#using-localization/[utilizar localización], específicamente la sección acerca de link:{handbook}#setting-console[configuración de la consola].

=== ¿Por qué no consigo que las quotas de usuario funcionen adecuadamente?

. Es posible que el kernel no este configurado para usar quotas. En este caso, añada la siguiente línea al archivo de configuración de kernel y recompile el kernel:
+
[.programlisting]
....
options QUOTA
....
+ 
Vea la link:{handbook}#quotas/[entrada de manual acerca de quotas] para más detalles.
. No ponga quotas sobre [.filename]#/#.
. Agregue el archivo de quota en el sistema de archivo en que se van a aplicar las quotas:
+
[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Sistema de archivos
| Archivo de quota

|[.filename]#/usr#
|[.filename]#/usr/admin/quotas#

|[.filename]#/home#
|[.filename]#/home/admin/quotas#

|...
|...
|===

=== ¿Soporta FreeBSD primitivas IPC de SystemV?

Si, FreeBSD soporta IPC de tipo System V, incluyendo memoria compartida, mensajes y semáforos, en el kernel [.filename]#GENERIC#. Con un kernel personalizado, el soporte puede cargarse con los módulos de kernel [.filename]#sysvshm.ko#, [.filename]#sysvsem.ko# y [.filename]#sysvmsg.ko#, o habilitado en el kernel por defecto agregando las siguientes líneas al archivo de configuración del kernel:

[.programlisting]
....
options    SYSVSHM          # enable shared memory
options    SYSVSEM          # enable for semaphores
options    SYSVMSG          # enable for messaging
....

Recompile e instale el kernel.

=== ¿Qué otro software de servidor de correo puedo usar en lugar de Sendmail?

El servidor http://www.sendmail.org/[Sendmail] es el software servidor de correo por defecto para FreeBSD, pero puede ser reemplazado con otro MTA instalado desde la colección de ports. Los ports disponibles incluyen package:mail/exim[], package:mail/postfix[], y package:mail/qmail[]. Busque en las listas de correo para discusiones sobre las ventajas y desventajas de los MTAs disponibles.

=== ¡He olvidado la contraseña de root! ¿Qué hago?

¡No se desespere! Reinicie el sistema, escriba `boot -s` en el indicador `Boot:` para entrar en modo de un solo usuario. Cuando se le pregunte que shell usar, presione kbd:[Enter] lo cual mostrara el símbolo `#`. Ingrese `mount -urw /` para remontar el sistema de archivos raíz como lectura/escritura, luego corra `mount -a` para remontar todos los sistemas de archivos. Corra `passwd root` para cambiar la contraseña de `root` luego corra man:exit[1] para continuar con el arranque.

[NOTE]
====
Si todavía se le pide la contraseña de `root` al ingresar en modo de un solo usuario, significa que la consola ha sido marcada como `insegura` en [.filename]#/etc/ttys#. En este caso, se requerirá que arranque desde un disco de instalación de FreeBSD, elija [.guimenuitem]#Live CD# o [.guimenuitem]#Shell# al inicio del proceso de instalación y corra los comandos mencionados anteriormente. Monte la partición específica en este caso y luego haga chroot en ella. Por ejemplo, reemplace `mount -urw /` con `mount /dev/ada0p1 /mnt; chroot /mnt` para un sistema en _ada0p1_.
====

[NOTE]
====
Si la partición raíz no puede ser montada en modo de un solo usuario, es posible que las particiones se encuentren encriptadas y es imposible montarlas sin las llaves de acceso. Para más información vea la sección acerca de discos encriptados en el link:{handbook}#disks-encrypting/[manual] de FreeBSD.
====

=== ¿Como prevengo que ControlAltDelete borre el sistema?

Cuando use man:syscons[4], el controlador por defecto dela consola, compile e instale un nuevo kernel con esta línea en el archivo de configuración:

[.programlisting]
....
options SC_DISABLE_REBOOT
....

Esto también puede hacerse ajustando el siguiente man:sysctl[8] que no requiere un reinicio o una recompilación de kernel:

[source,bash]
....
# sysctl hw.syscons.kbd_reboot=0
....

[NOTE]
====
Los dos métodos anteriores son exclusivos: el man:sysctl[8] no existe si el kernel se compila con `SC_DISABLE_REBOOT`.
====

=== ¿Como reformateo archivos de texto de DOS a archivos UNIX?

Use este comando de man:perl[1]:

[source,bash]
....
% perl -i.bak -npe 's/\r\n/\n/g' file(s)
....

donde _file(s)_ es uno o más archivos a procesar. La modificación se hace en el lugar, con el archivo original guardado con la extensión [.filename]#.bak#.

Alternativamente, use man:tr[1]:

[source,bash]
....
% tr -d '\r' < dos-text-file > unix-file
....

_dos-text-file_ es el archivo que contiene texto de DOS mientras que _unix-file_ contendrá la salida convertida. Esto puede ser un poco más rápido que usar `perl`.

Otra forma de reformatear archivos de texto de DOS es usar el port package:converters/dosunix[] de la colección de ports. Consulte su documentación para más detalles.

=== ¿Como releo /etc/rc.conf y rearranco /etc/rc sin reiniciar?

Vaya al modo de un solo usuario y luego vuelva al modo multiusuario:

[source,bash]
....
# shutdown now
# return
# exit
....

=== ¡Intente actualizar mi sistema al último -STABLE, pero obtuve -BETAx, -RC o -PRERELEASE! ¿Qué esta pasando?

Respuesta corta: es solo un nombre. _RC_ significa "Release Candidate". Esto quiere decir que un lanzamiento es inminente. En FreeBSD, _-PRERELEASE_ típicamente significa el congelamiento de código antes de un lanzamiento. (Para algunos lanzamientos, la etiqueta _-BETA_ fue usada en la misma manera que _-PRERELEASE_.)

Respuesta larga: FreeBSD deriva sus lanzamientos actuales de uno de dos lugares. Las versiones mayores, punto cero, tales como 9.0-RELEASE se ramifican del punto mas adelantado del torrente de desarrollo, comúnmente denominado <<current,-CURRENT>>. Versiones menores, tales como 6.3-RELEASE o 5.2-RELEASE, fueron snapshots de la rama <<stable,-STABLE>> activa. A partir de 4.3-RELEASE, cada versión ahora también tiene su propia rama que puede ser seguida por gente que requiera una velocidad de desarrollo extremadamente conservadora (típicamente solo avisos de seguridad).

Cuando esta a punto de hacerse un lanzamiento, la rama desde la cual sera derivada debe pasar por un cierto proceso. Parte de este proceso es un congelamiento de código. Cuando el mismo se inicia, el nombre de la rama se cambia para reflejar que esta a punto de convertirse en una versión. Por ejemplo, si la rama se solía llamar 6.2-STABLE, su nombre sera cambiado a 6.3-PRERELEASE para indicar el congelamiento de código y remarcar que habrá un testo extra pre-lanzamiento. Las correcciones de errores pueden seguir siendo commiteadas para formar parte del lanzamiento. Cuando el código fuente esta en forma para ser lanzado el nombre sera cambiado a 6.3-RC para indicar que se esta por hacer un lanzamiento a partir del mismo. Una vez en la fase de RC, solo los errores más críticos serán reparados. Una vez que el lanzamiento (6.3-RELEASE en este ejemplo) y la rama de la versión se hayan hecho, la rama sera renombrada a 6.3-STABLE.

Para más información acerca de números de version y varias ramas de Subversion, vea el artículo de link:{releng}[Ingenieria de lanzamientos ].

=== He intentado instalar un nuevo kernel y las chflags1 fallaron. ¿Como soluciono esto?

Respuesta corta: el nivel de seguridad es mayor a 0. Reinicie directamente al modo de un solo usuario para instalar el kernel.

Respuesta larga: FreeBSD deshabilita cambiar las banderas del sistema cuando los niveles de seguridad son mayores a 0. Para verificar el nivel actual de seguridad:

[source,bash]
....
# sysctl kern.securelevel
....

El nivel de seguridad no puede ser bajado en modo multiusuario, de manera que reinicie al modo de un solo usuario para instalar el kernel, o cambie el nivel de seguridad en [.filename]#/etc/rc.conf# y luego reinicie. Vea la pagina de manial de man:init[8] para más detalles acerca de `securelevel`, y vea [.filename]#/etc/defaults/rc.conf# y la página de manual de man:rc.conf[5] para más información acerca de [.filename]#rc.conf#.

=== ¡No puedo cambiar el tiempo en mi sistema por más de un segundo! ¿Como soluciono esto?

Respuesta corta: el sistema esta en un nivel de seguridad mayor a 1. Reinicie directamente a modo de un solo usuario para cambiar la fecha.

Respuesta larga: FreeBSD deshabilita cambiar el tiempo por más de un segundo a niveles de seguridad mayores que 1. Para verificar el nivel de seguridad:

[source,bash]
....
# sysctl kern.securelevel
....

El nivel de seguridad no puede ser reducido en modo multiusuario. Reinicie a modo de un solo usuario para cambiar la fecha o cambie el nivel de seguridad en [.filename]#/etc/rc.conf# y reinicie. Vea la página de manual de man:init[8] para detalles acerca de `securelevel`, y vea [.filename]#/etc/defaults/rc.conf# y la página de manual de man:rc.conf[5] para más información acerca de [.filename]#rc.conf#.

=== ¿Por que rpc.statd esta usando 256 MB de memoria?

No, no hay ningún desbordamiento de memoria, y no esta usando 256 MB de memoria. Para comodidad, `rpc.statd` mapea una cantidad obscena de memoria a su espacio de direcciones. No hay nada horriblemente malo con esto desde un punto de vista técnico; solo desorienta a procesos como man:top[1] y man:ps[1].

man:rpc.statd[8] mapea su archivo de estado (residente en [.filename]#/var#) a su espacio de direcciones; para evitar preocuparse acerca de remapearlo luego cuando necesite crecer, lo mapea con un tamaño generoso. Esto es muy evidente en el código fuente, donde es posible ver que el argumento de longitud de man:mmap[2] es `0x10000000`, o un dieciseisavo del espacio de direcciones en IA32, o exactamente 256 MB.

=== ¿Por qué no puedo borrar la bandera de archivo schg?

El sistema esta corriendo con un securelevel mayor a 0. Baje el securelevel e inténtelo de vuelta. Para mayor información vea <<securelevel,la entrada de FAQ de securelevel>> y la página de manual de man:init[8].

=== ¿Qué es vnlru?

`vnlru` limpia y libera vnodes cuando el sistema llega al límite de `kern.maxvnodes`. Este hilo de kernel esta ocioso, y solo se activa cuando hay una cantidad enorme de RAM y los usuarios están accediendo a miles de archivos pequeños.

=== ¿Qué significan los varios estados de memoria mostrados por top?

* `Active`: páginas recientes estadísticamente usadas.
* `Inactive`: páginas recientes estadísticamente sin uso.
* `Cache`: (la mayor parte del tiempo) páginas que se cuelan del estado inactivo a un estado en donde mantienen sus datos, pero pueden con frecuencia ser inmediatamente reusadas (tanto con su vieja asociación, o reusadas con una nueva asociación). Puede haber ciertas transiciones inmediatas desde el estado `active` a `cache` si se sabe que la página esta limpia (sin modificar), pero esta transición es un asunto de políticas, dependiendo de la elección del algoritmo del mantenedor del sistema de VM.
* `Free`: páginas sin contenido de datos, y que pueden ser usadas inmediatamente en ciertas circunstancias donde las páginas de cache puedan no ser elegibles. Las páginas libres pueden ser reusadas en un estado de proceso o interrupción.
* `Wired`: páginas que están fijas en memoria, usualmente para propósitos del kernel, pero a veces también para su uso especial en los procesos.

Las páginas con frecuencia se escriben a disco (una especie de sincronización de VM) cuando están en el estado inactivo, pero las paginas activas también pueden sincronizarse. Esto depende del rastreo que haga CPU de la disponibilidad del bit de modificación, y en ciertas situaciones puede haber una ventaja para un bloque de páginas de VM al ser sincronizadas, tanto si están activas como inactivas. En la mayoría de los casos comunes, es mejor pensar de la cola inactiva como una cola de páginas relativamente sin usar que pueden o no estar en proceso de ser escritas a disco. La paginas en cache pueden estar ya sincronizadas, no mapeadas, pero disponibles para su uso inmediato por un proceso con su vieja asociación o con una nueva asociación. Las páginas libres están disponibles al nivel de interrupción, pero las páginas en cache o libres pueden ser usadas en el estado de proceso para ser reusadas. Las páginas en cache no se bloquean adecuadamente para estar disponibles al nivel de interrupción.

Hay algunas otras banderas There are some other flags (e.g., busy flag or busy count) que pueden modificar algunas de las reglas descritas.

=== ¿Cuánta memoria libre esta disponible?

Hay varios tipos de "memoria libre". Un tipo es la cantidad de memoria directamente disponible sin paginar nada a disco. Esto es aproximadamente el tamaño de una cola de cache + el tamaño de la cola libre (con un factor de reducción de potencia, dependiendo de como se configure el sistema). Otro tipo de "memoria libre" es la cantidad total de espacio VM. Esto puede ser complejo, pero depende de la cantidad de espacio de intercambio y memoria. Otros tipos de descripciones de "memoria libre" también son posibles, pero es relativamente inútil definirlos, en su lugar es importante asegurarse de mantener el rango de paginación bajo, para evitar que se agote el espacio de intercambio.

=== ¿Qué es /var/empty?

[.filename]#/var/empty# es un directorio que el programa man:sshd[8] usa al realizar la separación de privilegios. El directorio [.filename]#/var/empty# esta vació, su dieño es `root` y tiene la bandera `schg` habilitada. Este directorio no debería ser borrado.

=== Acabo de cambiar /etc/newsyslog.conf. ¿Como puedo verificar si hace lo que yo espero?

Para ver lo que haría man:newsyslog[8], use lo siguiente:

[source,bash]
....
% newsyslog -nrvv
....

=== ¿Mi hora esta mal, como puedo cambiar la zona del tiempo?

Use man:tzsetup[8].

== El sistema X Window y las consolas virtuales

=== ¿Qué es el sistema X Window?

El sistema X Window (comúnmente `X11`) es el sistema de ventanas más ampliamente disponible capaz de correr en UNIX(TM) o sistemas de tipo UNIX(TM), incluyendo FreeBSD. http://www.x.org/wiki/[La X.Org Foundation] administra http://en.wikipedia.org/wiki/X_Window_System_core_protocol[estándares de protocolo de X], con la implementación de referencia actual, versión 11 release 7.7, de modo que las referencias suelen acortarse a `X11`.

Exiten muchas implementaciones disponibles para diferentes arquitecturas y sistemas operativos. Una implementación del código del lado del servidor es conocida propiamente como un `servidor X`.

=== ¿Quiero correr Xorg, como hago esto?

Para instalar Xorg siga uno de los siguientes pasos:

Use el meta-port package:x11/xorg[], que compila e instala todos los componentes de Xorg.

Use package:x11/xorg-minimal[], que compila e instala solo los componentes de Xorg necesarios.

Instale Xorg desde los paquetes de FreeBSD:

[source,bash]
....
 # pkg install xorg
....

Luego de la instalación de Xorg, siga las instrucciones de la sección link:{handbook}#x-config[Configuración de X11] del manual de FreeBSD.

=== He intentado correr X, pero obtengo el error No devices detected. cuando escribo startx. ¿Qué hago ahora?

El sistema probablemente este corriendo en un `securelevel` elevado. No es posible iniciar X en un `securelevel` elevado porque X requiere acceso de escritura a man:io[4]. Para más información vea la página de manual de man:init[8].

Hay dos soluciones a este problema: ponga `securelevel` en cero o corra man:xdm[1] (o un gestor gráfico alternativo) en tiempo de arranque antes de que `securelevel` sea elevado.

Vea <<xdm-boot>> para más información acerca de correr man:xdm[1] en tiempo de arranque.

=== ¿Por qué mi mouse no funciona con X?

Al usar man:syscons[4], el controlador de consola por defecto, FreeBSD puede configurarse para soportar un puntero del mouse en cada pantalla virtual. Para evitar entrar en conflico con X, man:syscons[4] soporta un dispositivo virtual llamado [.filename]#/dev/sysmouse#. Todos los eventos del mouse recibidos del dispositivo real del mouse se escriben al dispositivo man:sysmouse[4] mediante man:moused[8]. Para usar el mouse en una o más consolas virtuales, _and_ use X, vea <<moused>> y configureman:moused[8].

Luego edite [.filename]#/etc/X11/xorg.conf# y asegúrese de que las siguientes líneas existan:

[.programlisting]
....
Section "InputDevice"
   Option          "Protocol" "SysMouse"
   Option          "Device" "/dev/sysmouse"
.....
....

Empezando con la versión 7.4 de Xorg, las secciones `InputDevice` en [.filename]#xorg.conf# son ignoradas en favor de los dispositivos autodetectados. Para restaurar el viejo comportamiento, agregue la siguiente línea a la sección `ServerLayout` o a `ServerFlags`:

[.programlisting]
....
Option "AutoAddDevices" "false"
....

Algunas personas prefieran usar [.filename]#/dev/mouse# bajo X. Para hacer que esto funcione, [.filename]#/dev/mouse# debería estar vinculado a [.filename]#/dev/sysmouse# (vea man:sysmouse[4]) añadiendo la siguiente línea a [.filename]#/etc/devfs.conf# (vea man:devfs.conf[5]):

[.programlisting]
....
link    sysmouse    mouse
....

Este vínculo puede ser creado reiniciando man:devfs[5] con el siguiente comando (como `root`):

[source,bash]
....
# service devfs restart
....

=== Mi mouse tiene una flamante rueda. ¿Puedo usarla en X?

Si, si X se configura para un mouse de 5 botones. Para hacer esto, agregue las líneas `Buttons 5` y `ZAxisMapping 4 5` a la sección "InputDevice" de [.filename]#/etc/X11/xorg.conf#, como se ve en este ejemplo:

[.programlisting]
....
Section "InputDevice"
   Identifier      "Mouse1"
   Driver          "mouse"
   Option          "Protocol" "auto"
   Option          "Device" "/dev/sysmouse"
   Option          "Buttons" "5"
   Option          "ZAxisMapping" "4 5"
EndSection
....

Para usar el mouse en Emacs, también agregue las siguientes líneas a [.filename]#~/.emacs#:

[.programlisting]
....
;; wheel mouse
(global-set-key [mouse-4] 'scroll-down)
(global-set-key [mouse-5] 'scroll-up)
....

=== Mi laptop tiene un touchpad Synaptics. ¿Puedo usarlo en X?

Si, luego de configurar un par de cosas para hacerlo funcionar.

Para usar el controlador de synaptics de Xorg, primero remueva `moused_enable` de [.filename]#rc.conf#.

Para habilitar synaptics, agregue las siguiente línea a [.filename]#/boot/loader.conf#:

[.programlisting]
....
hw.psm.synaptics_support="1"
....

Agregue lo siguiente a [.filename]#/etc/X11/xorg.conf#:

[.programlisting]
....
Section "InputDevice"
Identifier  "Touchpad0"
Driver      "synaptics"
Option      "Protocol" "psm"
Option      "Device" "/dev/psm0"
EndSection
....

Y asegurese de añadir la siguiente línea a la sección "ServerLayout":

[.programlisting]
....
InputDevice    "Touchpad0" "SendCoreEvents"
....

=== ¿Como use pantallas X remotas?

Por razones de seguridad, la configuración por defecto es no permitir que la maquina abra una ventana directamente.

Para habilitar esta característica arranque X con el argumento opcional `-listen_tcp`:

[source,bash]
....
% startx -listen_tcp
....

=== ¿Qué es una consola virtual y como hago más?

Las consolas virtuales proveen varias sesiones simultaneas en una misma máquina sin hacer nada complicado como configurar una red o correr X.

Cuando arranca el sistema, se mostrara un indicador de arranque en el monitor luego de mostrar los mensajes de inicio. Escriba su nombre de usuario y contraseña para comenzar a trabajar en la primera consola virtual.

Para iniciar otra sesion, tal vez para ver documentación para un programa o para leer mail mientras espera que termine una transferencia por FTP, mantenga kbd:[Alt] y presione kbd:[F2]. Esto mostrara el indicador de inicio para la segunda consola virtual. Para volver a la sesión original presione kbd:[Alt+F1].

La instalación por defecto de FreeBSD tiene ocho consolas virtuales habilitadas. kbd:[Alt+F1], kbd:[Alt+F2], kbd:[Alt+F3], y demás iran cambiando entre estas consolas virtuales.

Para habilitar más consolas virtuales, edite [.filename]#/etc/ttys# (vea man:ttys[5]) y añada entradas para [.filename]#ttyv8# hasta [.filename]#ttyvc#, luego del comentario acerca de "terminales virtuales":

[.programlisting]
....
# Edit the existing entry for ttyv8 in /etc/ttys and change
# "off" to "on".
ttyv8   "/usr/libexec/getty Pc"         xterm  on secure
ttyv9   "/usr/libexec/getty Pc"         xterm  on secure
ttyva   "/usr/libexec/getty Pc"         xterm  on secure
ttyvb   "/usr/libexec/getty Pc"         xterm  on secure
....

Cuantas más terminales virtuales, más recursos son usados. Esto puede ser problemático en sistemas con 8 MB de RAM o menos. Considere cambiar `secure` a `insecure`.

[NOTE]
====
Versions de FreeBSD anteriores a 9.0 usaban el tipo de terimnal " cons25", en lugar de " xterm". Use el format de las entradas existentes al añadir entradas a [.filename]#/etc/ttys#.
====

[IMPORTANT]
====
Para correr un servidor X, al menos una terminal virtual debe estar en `off` para que la use. Esto significa que solo once de las teclas Alt-function pueden ser usadas como consolas virtuales de manera que una queda para el servidor X.
====

Por ejemplo, para correr X y once consolas virtuales, la configuración para la terminal 12 debería ser:

[.programlisting]
....
ttyvb   "/usr/libexec/getty Pc"         xterm  off secure
....

La manera más fácil de activar las consolas virtuales es reiniciar.

=== ¿Como accedo a las consolas virtuales desde X? 

Use kbd:[Ctrl+Alt+Fn] para cambiar a una consola virtual. Presione kbd:[Ctrl+Alt+F1] para volver a la primera consola virtual.

Al estar en una consola de texto, use kbd:[Alt+Fn] para moverse entre ellas.

Para volver a la sesión de X, cambie a la consola virtual corriendo X. Si se inicio X desde la línea de comandos usando `startx`, la sesión X se adjuntara a la siguiente consola virtual sin uso, no la consola de texto desde la cual fue invocada. Para ocho terminales virtuales activas, X correra en la novena, de modo que use kbd:[Alt+F9].

[[xdm-boot]]
=== ¿Como arranco XDM al iniciar?

Hay dos escuelas de pensamiento acerca de como arrancar man:xdm[1]. Una escuela arranca `xdm` desde [.filename]#/etc/ttys# (see man:ttys[5]) usando el ejemplo provisto, mientras la otra corre `xdm` desde [.filename]#rc.local# (see man:rc[8]) o desde un script de [.filename]#X# en [.filename]#/usr/local/etc/rc.d#. Ambas son igualmente válidas, y una puede funcionar en situaciones donde la otra no. En ambos casos el resultado es el mismo: X mostrara un indicador de inicio gráfico.

El método man:ttys[5] tiene la ventaja de documentar en que vty iniciara X will y pasar la responsabilidad de reiniciar el servidor X al desloguearse a man:init[8]. El método man:rc[8] hace que sea fácil hacer `kill` a `xdm` si hay un problema arrancando el servidor X.

Si se carga desde man:rc[8], `xdm` debería iniciarse sin argumentos. `xdm` debe arrancar _luego_ de que corra man:getty[8], o de lo contrario `getty` y `xdm` estarán en conflicto, bloqueando la consola. La mejor manera de solucionar esto es hacer que el script duerma por 10 segundos y luego inicie `xdm`.

Al iniciar `xdm` desde [.filename]#/etc/ttys#, aún hay una posibilidad de conflicto entre `xdm` y man:getty[8]. Una manera de evitar esto es añadir el número de `vt` en [.filename]#/usr/local/lib/X11/xdm/Xservers#:

[.programlisting]
....
:0 local /usr/local/bin/X vt4
....

El ejemplo de arriba indicara al servidor X que corra en [.filename]#/dev/ttyv3#. Note que el número es mayor en uno. El servidor X cuenta la vty desde uno, mientras que el kernel de FreeBSD numera la vty desde cero.

=== ¿Porque obtengo Couldn't open console al correr xconsole?

Cuando X se inicia con `startx`, los permisos en [.filename]#/dev/console#_no_ serán cambiados, lo que hace que cosas como `xterm -C` y `xconsole` no funcionen.

Esto es por la manera en que los permisos de consola están configurados por defecto. En un sistema multiusuario, uno no necesariamente quiere que cualquier usuario pueda escribir en la consola del sistema. Para usuarios que se están autenticando directamente en una maquina con una VTY, el archivo man:fbtab[5] existe para resolver tales problemas.

En resumen, asegurese de que una línea no comentada de esta forma se encuentre en [.filename]#/etc/fbtab# (vea man:fbtab[5]):

[.programlisting]
....
/dev/ttyv0 0600 /dev/console
....

Se asegurara que quien sea que escriba un log en [.filename]#/dev/ttyv0# sea el dueño de la consola.

=== ¿Por qué mi mouse PS/2 se comporta mal bajo X?

El mouse y el controlador del mouse pueden haberse dessincronizado. En casos raros, el controlador puede también haber reportado erróneamente errores de sincronización:

[.programlisting]
....
psmintr: out of sync (xxxx != yyyy)
....

Si esto sucede, deshabilite el codigo de verificación de sincronización ajustando las banderas del controlador para el controlador del mouse PS/2 a `0x100`. Esto puede lograrse más fácilmente añadiendo `hint.psm.0.flags="0x100"` a [.filename]#/boot/loader.conf# y reiniciando.

=== ¿Como revierto los botones del mouse?

Escriba `xmodmap -e "pointer = 3 2 1"`. Añada este comando a [.filename]#~/.xinitrc# o [.filename]#~/.xsession# para hacer que esto pase de manera automática.

=== ¿Como instalo una splash screen y donde puedo encontrarlas?

La respuesta detallada a esta pregunta puede encontrarse en la sección link:{handbook}#boot-splash[Splash Screens en tiempo de arranque] del manual de FreeBSD.

=== ¿Puedo usar las teclas Windows en mi teclado en X?

Si. Use man:xmodmap[1] para definir que funciones deben realizar las teclas.

Asumiendo que todos los teclados de windows sean estándares, los códigos de teclas para estas tres teclas son los siguientes:

* 115 -- tecla de kbd:[ Windows], entre las teclas kbd:[Ctrl] izquierdo y kbd:[Alt]
* 116 -- tecla de kbd:[Windows] , a la derecha de kbd:[AltGr]
* 117 -- kbd:[Menu], a la derecha de kbd:[Ctrl] derecha

Para hacer que la tecla kbd:[Windows]izquierda imprima una coma, intente esto.

[source,bash]
....
# xmodmap -e "keycode 115 = comma"
....

Para que los mapeos de teclas de kbd:[Windows] se habiliten automáticamente cada vez que se inicia X, ponga los comandos `xmodmap` en [.filename]#~/.xinitrc# o, preferiblemente, cree un archivo [.filename]#~/.xmodmaprc# e incluya las opciones de `xmodmap`, una por línea, luego añada la siguiente línea a [.filename]#~/.xinitrc#:

[.programlisting]
....
xmodmap $HOME/.xmodmaprc
....

Por ejemplo, para mapear las 3 teclas para que sean kbd:[F13], kbd:[F14], y kbd:[F15], respectivamente. Esto haría relativamente simple mapearlas a funciones útiles dentro de aplicaciones o del gestor de ventanas.

Para hacer esto, coloque lo siguiente en [.filename]#~/.xmodmaprc#.

[.programlisting]
....
keycode 115 = F13
keycode 116 = F14
keycode 117 = F15
....

Para el gestor de escritorio package:x11-wm/fvwm2[], uno podría mapear las teclas de manera que kbd:[F13] iconifique o desiconofique la ventana en la que esta el cursor, kbd:[F14] traiga la ventana en la que esta el cursor al frente o, si ya se encuentra al frente la lleve al fondo, y kbd:[F15] haga surgir el menu principal de Workplace incluso si el cursor no esta en el escritorio, lo cual es útil cuando no hay ninguna parte del escritorio visible.

Las siguientes entradas en [.filename]#~/.fvwmrc# implementan la configuración mencionada:

[.programlisting]
....
Key F13        FTIWS    A        Iconify
Key F14        FTIWS    A        RaiseLower
Key F15        A        A        Menu Workplace Nop
....

=== ¿Como puedo obtener aceleración de hardware 3D para OpenGL?

La disponibilidad de la aceleración 3D depende de la versión de Xorg y el tipo de chip de video. Para un chip nVidia, use los controladores binarios provistos por FreeBSD instalando uno de los siguientes ports:

Las ultimas versiones de tarjetas nVidia estan soportadas por el port package:x11/nvidia-driver[].

Los controladores más viejos están disponibles como package:x11/nvidia-driver-###[]

nVidia provee información detallada acerca de que tarjeta esta soportada por que controlador en su sitio web: http://www.nvidia.com/object/IO_32667.html[http://www.nvidia.com/object/IO_32667.html].

Para Matrox G200/G400, vea el port package:x11-servers/mga_hal[].

Para ATI Rage 128 y Radeon vea man:ati[4], man:r128[4] y man:radeon[4].

== Redes

=== ¿Donde puedo obtener información acerca del arranque sin disco rígido?

"Arranque sin disco rígido" significa que la instalación de FreeBSD se arranca desde la red, y lee los archivos necesarios desde un servidor en lugar del disco rígido. Para más detalles, vea link:{handbook}#network-diskless[la entrada del manual acerca del arranque sin disco rígido].

=== ¿Puede una instalación de FreeBSD usarse como un router dedicado?

Si. Vea la entrada del manual acerca de link:{handbook}#advanced-networking[redes avanzadas], específicamente la sección acerca de link:{handbook}#network-routing[routing y gateways].

=== ¿Puedo conectar mi instalación de Windows a la Internet mediante FreeBSD?

Usualmente, la gente que pregunta esto tiene dos PCs en su casa, una con FreeBSD y una con alguna versión de Windows(TM) la idea es usar la instalación de FreeBSD para conectarse a la Internet y así poder usar Internet desde la instalación de Windows(TM) a través de FreeBSD. Esto es únicamente un caso especial de la pregunta anterior y funciona perfectamente bien.

Los usuarios de dialup deben usar `-nat` y ajustar `gateway_enable` a _YES_ en [.filename]#/etc/rc.conf#. Para más información, vea man:ppp[8] o la link:{handbook}#userppp[entrada del manual acerca de PPP de usuario].

Si la conexión a Internet es sobre Ethernet, use man:natd[8]. Puede encontrarse un tutorial en la sección link:{handbook}#network-natd[natd] del manual.

=== ¿FreeBSD soporta PPP?

Si. man:ppp[8] provee soporte para conexiones entrantes y salientes.

Para más información acerca de como usar esto, vea el link:{handbook}#ppp-and-slip[capítulo del manual acerca de PPP].

=== ¿FreeBSD soporta NAT o Masquerading?

Si. Para instrucciones acerca de como usar NAT sobre una conexión PPP, vea la link:{handbook}#userppp[entrada de manual acerca de PPP]. Para usar NAT sobre otro tipo de conección de red, vea la sección acerca de link:{handbook}#network-natd[natd] en el manual.

=== ¿Como configuro aliases de Ethernet?

Si el alias esta en la misma subred que una dirección ya configurada en la interfaz, agregue `netmask 0xffffffff` a este comando:

[source,bash]
....
# ifconfig ed0 alias 192.0.2.2 netmask 0xffffffff
....

De otro modo, especifique la dirección de red y netmask de la manera usual:

[source,bash]
....
# ifconfig ed0 alias 172.16.141.5 netmask 0xffffff00
....

Puede encontrarse más información en el manual link:{handbook}#configtuning-virtual-hosts[Handbook] de FreeBSD.

=== ¿Por qué no puedo realizar un montado NFS desde una instalación Linux?

Algunas versiones del código NFS de Linux(TM) solo aceptan pedidos de montaje de un puerto privilegiado; intente con el siguiente comando:

[source,bash]
....
# mount -o -P linuxbox:/blah /mnt
....

=== ¿Porque mountd continua diciéndome can't change attributes (que no puedo cambiar atributos) y que tengo una bad exports list (lista de exports mala) en mi servidor NFS de FreeBSD?

El problema mas frecuente es no entender el formato correcto de [.filename]#/etc/exports#. Revise man:exports[5] y la entrada de link:{handbook}#network-nfs[NFS] en el manual, especialmente la sección acerca de link:{handbook}#configuring-nfs[configurar NFS].

=== ¿Como habilito soporte para IP multicast?

Instale el paquete o port package:net/mrouted[] y añada `mrouted_enable="YES"` a [.filename]#/etc/rc.conf# inicie este servicio en tiempo de arranque.

=== ¿Porque tengo que usar FQDN para hosts en mi sitio?

Vea la respuesta en el link:{handbook}#mail-trouble[manual] de FreeBSD.

=== ¿Porque obtengo un error, Permission denied, para todas las operaciones de red?

Si el kernel fue compilado con la opción `IPFIREWALL`, este al tanto de que la política por defecto es bloquear todos los paquetes que no estén explícitamente permitidos.

Si el firewall esta mal configurado, restaure la operabilidad de la red escribiendo lo siguiente como `root`:

[source,bash]
....
# ipfw add 65534 allow all from any to any
....

Considere ajustar `firewall_type="open"` en [.filename]#/etc/rc.conf#.

Para más información acerca de configurar este firewall vea el link:{handbook}#firewalls-ipfw[capítulo del manual].

=== ¿Por qué mi regla fwd de ipfw para redirigir un servicio a otra maquina no funciona?

Posiblemente porque la traducción de direcciones de red (NAT) es necesaria en lugar de simplemente envíar paquetes needed. Una regla "fwd" solo envía paquetes, no cambia realmente los datos adentro del paquete. Considere esta regla:

[source,bash]
....
01000 fwd 10.0.0.1 from any to foo 21
....

Cuando un paquete con una dirección de destino de _foo_ llega a la máquina con esta regla, el paquete es enviado a _10.0.0.1_, pero todavía tiene la dirección de destino de _foo_. La dirección de destino del paquete no se cambia a _10.0.0.1_. La mayoría de las máquinas probablemente tiren un paquete que reciben con una dirección de destino que no sea la propia. Por consiguiente, usar una regla "fwd" no necesariamente funciona de la manera que espera el usuario. Este comportamiento es una característica y no un error.

Va el <<service-redirect,FAQ acerca de redirigir servicios >>, el manual de man:natd[8], o una de las varias utilidades para redirigir puertos en la https://www.FreeBSD.org/ports/[colección de ports] para la manera correcta de hacer esto.

=== ¿Como puedo redirigir pedidos de servicio de una máquina a otra?

FTP y otros pedidos de servicios pueden ser redirigidos con el port o paquete package:sysutils/socket[]. Reemplace la entrada del servicio en [.filename]#/etc/inetd.conf# para llamar a `socket`, como se puede ver en este ejemplo para ftpd:

[.programlisting]
....
ftp stream tcp nowait nobody /usr/local/bin/socket socket ftp.example.com ftp
....

donde _ftp.example.com_ y _ftp_ son el host y el puerto a los que redirigirse, respectivamente.

=== ¿Dónde puedo obtener una herramienta de manejo de ancho de banda?

Hay tres herramientas de manejo de ancho de banda disponibles para FreeBSD. man:dummynet[4] esta integrada en FreeBSD como parte de man:ipfw[4]. http://www.sonycsl.co.jp/person/kjc/programs.html[ALTQ] fue integrada a FreeBSD como parte de man:pf[4]. Bandwidth Manager de http://www.etinc.com/[Emerging Technologies] es un producto comercial.

=== ¿Por qué obtengo /dev/bpf0: device not configured?

La aplicación que esta corriendo requiere Berkeley Packet Filter (man:bpf[4]), pero el mismo fue removido de un kernel personalizado. Agregue esto al archivo de configuración del kernel y compile un nuevo kernel:

[.programlisting]
....
device bpf        # Berkeley Packet Filter
....

=== ¿Como monto un disco desde una máquina con Windows que esta en mi red, de la misma manera que smbmount en Linux?

Use el set de herramientas SMBFS. El mismo incluye un set de modificaciones al kernel y un set de programas de espacio de usuario. Los programas y la información están disponibles como man:mount_smbfs[8] en el sistema base.

=== ¿Por qué aparecen mensajes como: Limiting icmp/open port/closed port response en mis archivos de log?

Este mensaje del kernel indica que alguna actividad esta provocando que envie una gran cantidad de respuestas ICMP o TCP reset (RST). Las respuestas ICMP son con frecuencia generadas como un resultado de intentos de conexiones a puertos UDP sin usar. Los resets de TCP son generados como el resultado de intentos de conexiones a puertos TCP sin abrir. Entre otros, este tipo de actividades puede causar los siguientes mensajes:

* Ataques de denegación de servicio por fuerza bruta (DoS) (en lugar de ataques de un solo paquete que explotan una vulnerabilidad específica).
* Escaneos de puertos que intentan conectar un gran número de puertos (en lugar de solo intentar con un par de puertos bien conocidos).

El primer número en el mensaje indica cuantos paquetes hubiera enviado el kernel si el límite no existiera, y el segundo indica el límite. Este límite se controla usando `net.inet.icmp.icmplim`. Este ejemplo ajusta el límite a `300` paquetes por segundo:

[source,bash]
....
# sysctl net.inet.icmp.icmplim=300
....

Para deshabilitar estos mensajes sin deshabilitar la limitación de la respuesta, use `net.inet.icmp.icmplim_output` para deshabilitar la salida:

[source,bash]
....
# sysctl net.inet.icmp.icmplim_output=0
....

Finalmente, para deshabilitar completamente la limitación de la respuesta, ajuste `net.inet.icmp.icmplim` a `0`. Deshabilitar la limitación de respuesta esta desaconsejado por las razones listadas anteriormente.

=== ¿Qué significan los mensajes de error arp: unknown hardware address format?

Esto significa que algún dispositivo en la Ethernet local esta usando una dirección MAC en un formato que FreeBSD no reconoce. Esto fue probablemente causado por alguien que experimento con una tarjeta Ethernet en otro lugar de la red. Esto puede verse más comúnmente en redes de cable modem modernas. No es dañino, y no debería afectar el rendimiento del sistema en FreeBSD.

=== ¿Por qué sigo obteniendo mensajes como: 192.168.0.10 is on fxp1 but got reply from 00:15:17:67:cf:82 on rl0, y como lo deshabilito?

Porque un paquete esta viniendo de afuera de la red inesperadamente. Para deshabilitarlos, ajuste `net.link.ether.inet.log_arp_wrong_iface` a `0`.

== Seguridad

=== ¿Qué es un sandbox?

"Sandbox"es un término de seguridad. Puede significar dos cosas:

* Un proceso que se coloca adentro de un conjunto de paredes virtuales que están designadas para impedir que alguien que logra explotar el proceso no pueda explotar el ecosistema mayor.
+ 
El proceso que puede correr adentro de estas paredes. Dado que nada de lo que el proceso haga con respecto a ejecutar código puede romper las paredes, una auditoría detallada del código es innecesaria para poder decir ciertas cosas acerca de su seguridad.
+ 
Estas paredes pueden ser un ID de usuario, por ejemplo. Esta es la definición usada en las páginas de manual de man:security[7] y man:named[8].
+ 
Considere el servicio `ntalk`, por ejemplo (vea man:inetd[8]). Este servicio solía correr con ID de usuario `root`. Ahora corre con ID de usuario `tty`. El usuario `tty` es un sandbox designado para hacer más difícil para alguien que ya ha irrumpido en el sistema mediante `ntalk` pueda comprometer el sistema más allá de esa ID de usuario.
* Un proceso que se inserta en una simulación de la máquina. Esto significa que alguien que puede irrumpir en el proceso podría creer que puede irrumpir en la máquina entera pero esta, en efecto solo irrumpiendo en una simulación de esa máquina sin modificar ningún dato real.
+ 
La manera más común de lograr esto es construir un ambiente simulado en un subdirectorio y luego correr el proceso dentro de un chroot en ese directorio de manera que [.filename]#/# para ese proceso sea este directorio, en lugar de la verdadera [.filename]#/# del sistema.
+ 
Otro uso común es montar un sistema de archivos subyacente como de solo lectura y crear una capa de sistema de archivos encima del mismo que provea a un proceso una vista aparentemente de escritura en el sistema de archivos. El proceso puede creer que esta habilitado para escribir esos archivos, pero solo el proceso en cuestión ve los efectos, y otros procesos en el sistema no.
+ 
Se hace un intento de que este tipo de sandbox sea tan transparente que el usuario (o el hacker) no se de cuenta de que esta usándola.

UNIX(TM) implementa dos sandboxes principales. Uno es a nivel proceso, el otro es a nivel userid.

Cada proceso UNIX(TM) esta completamente aislado de cualquier otro proceso UNIX(TM). Un proceso no puede modificar el espacio de direcciones de otro.

Un proceso UNIX(TM) tiene por dueño una userid en particular. Si el ID de susuario no es el usuario `root`, es útil aislar el proceso de procesos adueñados por otros usuarios. El ID de usuario también se usa para aislar datos del disco.

=== ¿Qué es securelevel?

`securelevel` es un mecanismo de seguridad implementado en el kernel. Cuando un securelevel es positivo, el kernel restringe ciertas tareas; ni siquiera el superusuario (`root`) tiene permitido hacerlas. El mecanismo securelevel limita la habilidad de:

* Borrar ciertas banderas de archivo, tales como `schg` (the system immutable flag).
* Escribir a la memoria del kernel mediante [.filename]#/dev/mem# y [.filename]#/dev/kmem#.
* Cargar modulos de kernel.
* Alterar reglas del firewall.

Para verificar el estado del securelevel en un sistema corriendo:

[source,bash]
....
# sysctl -n kern.securelevel
....

La salida contiene el valor actual del securelevel. Si es mayor a 0, al menos algunas de las protecciones de securelevel están habilitadas.

El securelevel de un sistema corriendo no puede ser reducido dado que esto arruinaría su propósito. Si una tarea requiere que el securelevel sea no-positivo, cambie las variables `kern_securelevel` y `kern_securelevel_enable` en [.filename]#/etc/rc.conf# y reinicie.

Para más información acerca de securelevel y lo que hace en particular cada nivel, consulte man:init[8].

[WARNING]
====

Securelevel no es una bala de plata; tiene varias deficiencias conocidas. Muchas veces provee un falso sentido de seguridad.

Uno de sus problemas mas importantes es que para que sea efectivo, todos los archivos usados en el proceso de inicio hasta que se ajuste securelevel deben estar protegidos. Si un atacante puede hacer que el sistema ejecute código antes de que se ajuste el securelevel (lo cual pasa bastante tarde en el proceso de inicio dado que algunas de las cosas que el sistema debe hacer al inicio no pueden hacerse con un securelevel elevado), sus protecciones están invalidadas. Mientras que la tarea de proteger todos los archivos usados en el proceso de inicio no es técnicamente imposible, si esto se logra, el mantenimiento del sistema se volverá una pesadilla dado que una persona tendría que apagar el sistema, o al menos cambiar a modo de un solo usuario, para modificar un archivo de configuración.

Este punto y otros son frecuentemente discutidos en las listas de correo, particularmente la http://lists.FreeBSD.org/mailman/listinfo/freebsd-security[lista de correo de seguridad de FreeBSD]. Busque en los archivos https://www.FreeBSD.org/search/[aqui] para una discusión extensiva. Se prefiere un mecanismo de granularidad más fina.
====

=== BIND (named) esta escuchando en algunos puertos de numero alto. ¿Qué esta pasando?

BIND usa un numero al azar de puertos de número alto para consultas saliente. Las versiones recientes elijen un nuevo puerto UDP al azar para cada consulta. Esto puede causar problemas para algunas configuraciones de red, especialmente si un firewall bloquea paquetes UDP entrantes en puertos particulares. Para pasar ese firewall intente usar las opciones `avoid-v4-udp-ports` y `avoid-v6-udp-ports` para evitar elegir números de puertos al azar en un rango bloqueado.

[WARNING]
====

Si un número de puerto (como el 53) es especificado mediante las opciones `query-source` o `query-source-v6` en [.filename]#/etc/namedb/named.conf#, no se usara la selección al azar de puertos. Se recomienda fuertemente que estas opciones no se usen para especificar números de puerto fijos.
====

Felicitaciones por cierto. ¡Es buena práctica leer la salida de man:sockstat[1]y notar cosas raras!

=== ¡El demonio de Sendmail esta escuchando en el puerto 587 y además en el puerto estándar 25! ¿Qué esta pasando?

Las versiones recientes de Sendmail soportan una característica de envió de correo que corre sobre el puerto 587. Esto no esta soportado universalmente, pero esta creciendo en popularidad.

=== ¿Qué es esta cuenta de toor UID 0 ? ¿He sido comprometido?

No se preocupe. `toor` es una cuenta de superusuario "alternativa", en donde toor es root escrito al revés. Su propósito es ser usada como un shell no estándar de manera que el shell por defecto para `root` no necesite cambiar. Esto es importante dado que los shells que no son parte del sistema base, pero que en su lugar son instalados desde ports o packages, se instalan en [.filename]#/usr/local/bin# el cual, por defecto, reside en un sistema de archivos distinto. SI el shell de `root` esta localizado en [.filename]#/usr/local/bin# y el sistema de archivos conteniendo [.filename]#/usr/local/bin#) no esta montado, `root` no sera capaz de autenticarse para arreglar un problema y tenga que reiniciar al modo de un solo usuario para ingresar a la ruta de un shell.

Alguna gente usa `toor` para tareas diarias de `root` con un shell no estándar, dejando a `root`, con un shell estándar, para modo de un solo usuario o emergencias. Por defecto, un usuario no puede autenticarse usando `toor` dado quen o tiene una contraseña, de modo que autentiquese como `root` e ingrese una contraseña para `toor` antes de usarlo para autenticarse.

== PPP

=== No puedo hacer que ppp8 funcione. ¿Qué estoy haciendo mal?

Primero, lea man:ppp[8] y la link:{handbook}#userppp[sección del manual sobre PPP ]. Para asistir en la solución de problemas, habilite los logs con el siguiente comando:

[.programlisting]
....
set log Phase Chat Connect Carrier lcp ipcp ccp command
....

Este comando debe ser escrito en el indicador de comandos de man:ppp[8]o puede ser ingresado al inicio de la sección `default` en [.filename]#/etc/ppp/ppp.conf#. Asegurese de que [.filename]#/etc/syslog.conf# contenga las líneas mostradas a continuación y que el archivo [.filename]#/var/log/ppp.log# exista:

[.programlisting]
....
!ppp
*.*        /var/log/ppp.log
....

Mucho de lo que esta pasando puede verse en el archivo de log. No se preocupe si no tiene sentido dado que puede tener sentido para alguien más.

=== ¿Por qué ppp8 se cuelga cuando lo corro?

Esto suele ser porque le nombre de host no puede resolverse. La mejor manera de arreglar esto es asegurarse de que [.filename]#/etc/hosts# sea leído primero asegurando que la línea `hosts` este listada primero en [.filename]#/etc/host.conf#. Luego, agregue una entrada en [.filename]#/etc/hosts# para la máquina local. Si no hay una red local, cambie la línea `localhost`:

[.programlisting]
....
127.0.0.1        foo.example.com foo localhost
....

De otra manera, agregue otra entrada para el host. Consulte las paginas de manual relevantes para más detalles.

Cuando termine, verifique que este comando corra exitosamente: `ping -c1 hostname`.

=== ¿Por qué ppp8 no marca en modo -auto?

En primer lugar, verifique que exista una ruta por defecto. Este comando debería mostrar dos entradas:

[.programlisting]
....
Destination        Gateway            Flags     Refs     Use     Netif Expire
default            10.0.0.2           UGSc        0        0      tun0
10.0.0.2           10.0.0.1           UH          0        0      tun0
....

Si una ruta por defecto no se muestra, asegurese de que la línea `HISADDR` haya sido agregada a [.filename]#/etc/ppp/ppp.conf#.

Otra razón para que la línea de la ruta por defecto falte es que se haya añadido una ruta por defecto a [.filename]#/etc/rc.conf# y esta línea no este en [.filename]#/etc/ppp/ppp.conf#:

[.programlisting]
....
delete ALL
....

Si este es el caso, vuelva a la sección link:{handbook}#userppp-final[Configuración final del sistema] del manual.

=== ¿Qué significa No route to host?

Este error suele ocurrir porque la siguiente sección falta en [.filename]#/etc/ppp/ppp.linkup#:

[.programlisting]
....
MYADDR:
  delete ALL
  add 0 0 HISADDR
....

Esto solo es necesario para una dirección de IP dinámica o cuando la dirección del gateway por defecto es desconocida. Cuando se usa modo interactivo, puede escribirse lo siguiente luego de entrar en modo de paquetes. El modo de paquetes esta indicado por las letras PPP en mayúscula en la consola:

[.programlisting]
....
delete ALL
add 0 0 HISADDR
....

Vea la sección sobre link:{handbook}#userppp-dynamicip[PPP y direcciones de IP dinámicas] del manual para más detalles.

=== ¿Por qué mi conexión se corta luego de 3 minutos?

El timeout por defecto de PPP es de 3 minutos. Esto puede ajustarse con la siguiente línea:

[.programlisting]
....
set timeout NNN
....

donde _NNN_ es el número de segundos de inactividad antes que la conexión se cierre. Si _NNN_ es cero, la conexión nunca se cerrara debido a un timeout. Es posible poner este comando en [.filename]#ppp.conf#, o escribirlo en la consola en modo interactivo. También es posible ajustarlo en tiempo real mientras las línea esta activa conectandose a el servidor de socket de ppp usando man:telnet[1] o man:pppctl[8]. Vea la pagina de manual de man:ppp[8] para más detalles.

=== ¿Por qué mi conexión se corta bajo carga intensiva?

Si Link Quality Reporting (LQR) esta configurado, es posible que muchos paquetes LQR se hayan perdido entre el sistema FreeBSD y el peer. man:ppp[8] deduce que por consiguiente la línea debe estar mal, y se desconecta. LQR esta deshabilitado por defecto y puede habilitarse con la siguiente línea:

[.programlisting]
....
enable lqr
....

=== ¿Por qué mi conexión se corta luego de un intervalo al azar de tiempo?

A veces, en una línea de teléfono con mucho ruido, o incluso una línea con llamada en espera habilitada, el modem puede colgar porque incorrectamente piensa que perdió el portador.

Hay un parámetro en la mayoría de los modems para determinar que tan tolerante debe ser a perdidas temporales del portador. Vea el manual del modem para más detalles.

=== ¿Por qué mi conexión se cuelga luego de un intervalo al azar de tiempo?

Mucha gente experiencia conexiones que se cuelgan sin explicación aparente. Lo primero es estable que lado de la conexión esta colgado.

Al usar un modem externo, intente usar man:ping[8] para ver si la luz TD se enciendie cuando se transmiten datos. Si se enciende pero la luz RD no, el problema esta en el otro extremo. Si TD no se enciende, el problema es local. Con un modem interno, use el comando `set server` en [.filename]#ppp.conf#. Cuando el cuelgue ocurra, conéctese a man:ppp[8] usando man:pppctl[8]. Si la conexión a la red súbitamente revive debido a la actividad en el socket de diagnóstico, o si no se conecta pero debido al comando `set socket` tiene éxito en tiempo de inicio, el problema es local. Si puede conectarse pero continúan los cuelgues, habilite los logs locales con `set log local async` y use man:ping[8] desde otra ventana o terminal para hacer uso del link. El log asincrónico another mostrara los datos siendo transmitidos y recibidos en el link. Si los datos salen pero nunca vuelven, el problema es remoto.

Habiendo establecido si el problema es local o remoto, existen dos posibilidades:

* Si el problema es remoto, lea la entrada <<ppp-remote-not-responding>>.
* Si el problema es local, lea la entrada <<ppp-hung>>.

[[ppp-remote-not-responding]]
=== El extremo remoto no responde. ¿Qué hago?

Puede hacerse muy poco acerca de esto. Muchos ISPs se rehúsan a ayudar a los usuarios que no corran Microsoft(TM) OS. Agregue `enable lqr` a [.filename]#/etc/ppp/ppp.conf#, permitiendo man:ppp[8] para detectar el fallo o cuelgue remoto. Esta detección es relativamente lenta y por consiguiente no muy útil.

Primero, intente deshabilitar toda la compresión local agregando lo siguiente a la configuración:

[.programlisting]
....
disable pred1 deflate deflate24 protocomp acfcomp shortseq vj
deny pred1 deflate deflate24 protocomp acfcomp shortseq vj
....

Luego reconectese para asegurarse de que esto no hace la diferencia. Si las cosas mejoran o si el problema se soluciona por completo, determine que ajuste hace la diferencia mediante prueba y error. Esta es información útil para el ISP, aunque puede evidenciar que este no es un sistema Microsoft(TM).

Antes de contactar el ISP, habilite el logueo asincrónico localmente y espere a que la conexión se cuelgue nuevamente. Esto puede usar bastante espacio de disco. La última lectura de datos del puerto puede ser interesante. Usualmente se trata de datos ASCII, y puede incluso describir el problema (`Memory fault`, `Core dumped`).

Si el ISP es servicial, deberían poder habilitar logueo en su extremo, luego cuando la siguiente desconexión ocurra, podrían ser capaces de decir porque su extremo tiene un problema.

[[ppp-hung]]
=== man:ppp[8] se colgó. ¿Qué puedo hacer?

En este caso, recompile man:ppp[8] con información de debug, y luego use man:gdb[1] para obtener un stack trace desde el proceso de ppp que esta parado. Para recompilar la utilidad ppp con información de debug, escriba:

[source,bash]
....
# cd /usr/src/usr.sbin/ppp
# env DEBUG_FLAGS='-g' make clean
# env DEBUG_FLAGS='-g' make install
....

Luego, reinicie ppp y espere a que se cuelgue nuevamente. Cuando la compilación de depuración de ppp se cuelgue, inicie gdb en el proceso que se colgó escribiendo:

[source,bash]
....
# gdb ppp `pgrep ppp`
....

En la consola de gdb, use los comandos `bt` o `where` para obtener un stack trace. Guarde la salida de la sesión de gdb, y "separese" del proceso que esta corriendo escribiendo `quit`.

=== Sigo viendo errores acerca de que la magia es la misma. ¿Qué significan?

Ocasionalmente, justo después de conectare, puede haber mensajes en el log que digan `Magic is same`. A veces, estos mensajes son inofensivos, y a veces un lado u el otro sale. La mayoría de las implementaciones de PPP no pueden sobrevivir a este problema, incluso si el link parace activarse, habrá pedidos de configuración repetidos y reconocimientos de configuración en el archivo de log hasta que man:ppp[8] eventualmente se rinda y cierre la conexión.

Esto normalemente sucede en maquinas del servidor con discos lentos que lancen una man:ppp[8] en el puerto y ejectuen man:ppp[8] desde un script de inicio u otro programa luego de la autenticación. Existen reportes de que esto sucede consistentemente al usar slirp. La razón es que en el tiempo entre que man:getty[8]salga y man:ppp[8] inicie, el man:ppp[8] del lado del cliente comienza a enviar paquetes Line Control Protocol (LCP). Porque ECHO sigue siendo cambiado para el puerto en el servidor, el cliente man:ppp[8] ve estos paquetes "reflejarse" de vuelta.

Una parte de la negociación LCP consiste en establecer un numero mágico para cada lado del link de manera que se puedan detectar "reflexiones". El protocolo dice que cuando el peer intenta negociar el mismo número mágico, debe enviarse un NAK y se debe elegir un nuevo numero mágico. Durante el período en que el puerto del servidor tiene ECHO prendido, el cliente man:ppp[8] envía paquetes LCP, ve el mismo numero mágico en el paquete reflejado y le envía un NAK. También ve el reflejado el NAK (lo que también significa que man:ppp[8] debe cambiar su numero mágico). Esto produce un enorme número de potenciales cambios de números mágicos, todos los cuales se apilan en el buffer del tty del servidor. Tan pronto como man:ppp[8] inicia en el servidor, se satura de cambios de numero mágico y casi inmediatamente decide que intento lo suficiente negociar LCP y termina. Mientras tanto, el cliente, que ha dejado de ver las reflexiones, se vuelve satisfecho justo a tiempo para ver un cuelgue del servidor.

Esto puede evitarse permitiéndole al peer comenzar la negocación con la siguiente línea en [.filename]#ppp.conf#:

[.programlisting]
....
set openmode passive
....

Esto le dice a man:ppp[8] que espere al que el servidor inicie las negociaciones LCP. Algunos servidor pueden no obstante nunca iniciar las negociaciones. En este caso, intente algo como:

[.programlisting]
....
set openmode active 3
....

Esto le dice a man:ppp[8] que sea pasivo por 3 segundos, y luego comience a enviar pedidos LCP. Si el peer comienza a enviar pedidos durante este período, man:ppp[8] responderá inmediatamente en lugar de esperar el período completo de 3 segundos.

=== Las negociaciones LCP continúan hasta que la conexión se cierre. ¿Cuál es el problema?

Eixte actualmente un error de implementación en man:ppp[8] donde no se asocian las respuesta LCP, CCP & IPCP con sus pedidos originales. Como resultado, si una implementación de PPP es más lenta que la del otro lado por 6 segundos o más, el otro lado enviara dos pedidos de configuración LCP adicionales. Esto es fatal.

Considere dos implementaciones, `A` y `B`. `A` comienza a enviar pedidos LCP inmediatamente luego de conectarse y a `B` le lleva 7 segundos iniciar. Cuando `B` inicia, `A` ha enviado 3 REQs LCP. Asumimos que la línea tiene ECHO desactivado, de otra forma veríamos problemas con los números mágicos como vimos en la sección previa. `B` envía una REQ, y luego un ACK al primero de los REQs de `A`. Esto resulta en `A` entrando al estado OPENED y enviando un ACK (del primero) de vuelta a `B`. Mientras tanto, `B` envía de vuelta dos ACKs más en respuesta a las dos REQs adicionales enviadas por `A` antes de que `B` haya iniciado. `B` luego pasa a recibir el primero ACK de `A` y entra al estado OPENED. `A` revice el segundo ACK de `B` y vuelve al estado REQ-SENT, enviando otro REQ (adelantado) de acuerdo con la RFC. Luego recibe el tercer ACK y entra en el estado OPENED. En el entremedio, `B` recibe el REQ adelantado desde `A`, resultando en el mismo revirtiendo al estado ACK-SENT y enviando otro (segundo) REQ y ACK (adelantado) de acuerdo con la RFC. `A` obtiene el REQ, se pone en modoREQ-SENT y envía otra REQ. Inmediatamente recive el siguiente ACK y entra a modo OPENED.

Esto continua hasta que uno de los lados se de cuenta de que no están llegando a ningún lado y termine.

La mejor manera de evitar esto es configurar un lado para ser `passive` -- esto es, hacer que un lado espere al otro para comenzar a negociar. Esto puede hacerse con el siguiente comando:

[.programlisting]
....
set openmode passive
....

Se debe tener cuidado con esta opción. Este comando también puede usarse para limitar la cantidad de tiempo que man:ppp[8] espera a que el peer comienze las negociaciones.

[.programlisting]
....
set stopped N
....

Alternativamente, el siguiente comando (donde _N_ es el número de segundos a esperar antes de iniciar las negociaciones) puede ser usado:

[.programlisting]
....
set openmode active N
....

Verifique la página de manual para detalles.

=== ¿Por qué ppp8 se bloquea cuando intento probarlo en el shell?

Al usar `shell` o `!`, man:ppp[8] ejecuta un shell o los argumentos pasados. El programa ppp esperara a que el comando se complete antes de continuar. Cualquier intento de usar el link de PPP mientras se correr el comando aparecerá como un link paralizado. Esto es porque man:ppp[8] espera a que el comando se complete.

Para ejecutar comandos como este, use `!bg` en su lugar. Esto ejecutara el comando dado en el trasfondo, y man:ppp[8] puede continuar sirviendo el link.

=== ¿Por qué ppp8 sobre un cable de modem nulo nunca termina?

No hay forma de que man:ppp[8] automáticamente determine que una conexión directa fue terminada. Esto es debido a que las líneas usadas en el cable de serie de un modem nulo. Al usar este tipo de conexión, LQR siempre debería ser habilitado con la siguiente línea:

[.programlisting]
....
enable lqr
....

LQR es aceptado por defecto si es negociado por el peer.

=== ¿Por qué ppp8 marca en modo -auto sin razón?

Si man:ppp[8] marca de manera inesperada, determine la causa y ajuste los filtros de marcación para prevenir dicha llamada.

Para determinar la causa, use la próxima línea:

[.programlisting]
....
set log +tcp/ip
....

Esto escribirá un log con todo el trafico de la conexión. La próxima vez que esta línea surja inesperadamente, la razón será logueada con una conveniente estampa temporal a su lado.

Luego, deshabilite el marcado bajo estas circunstancias. Usualmente, este tipo de problema se da debido a las búsquedas de DNS. Para prevenir que las búsquedas de DNS establezcan una conexión (esto _no_ prevendrá que man:ppp[8] pase los paquetes a través de una conexión establecida), use lo siguiente:

[.programlisting]
....
set dfilter 1 deny udp src eq 53
set dfilter 2 deny udp dst eq 53
set dfilter 3 permit 0/0 0/0
....

Esto no siempre es aceptable, dado que romperá las capacidades de demanda de marcado. La mayoría de los programas necesitaran una búsqueda de DNS antes de hacer otras cosas relacionadas con la red.

En el caso del DNS, intente determinar que es lo que esta realmente intentando resolver un nombre de host. La mayoría del tiempo, Sendmail es el culpable. Asegúrese de configurar Sendmail para que no realize ninguna búsqueda de DNS en su archivo de configuración. Vea la sección acerca de link:{handbook}#smtp-dialup[usar email con una conexión de dialup] en el manual de FreeBSD para los detalles. Probablemente también quiera además agregar la siguiente línea a [.filename]#.mc#:

[.programlisting]
....
define(`confDELIVERY_MODE', `d')dnl
....

Esto hara que Sendmail encole todo hasta que se corra la cola, usualmente cada 30 minutos, o hasta que se haga `sendmail -q`, tal vez desde [.filename]#/etc/ppp/ppp.linkup#.

=== ¿Qué significan estos errores de CCP?

Continuo viendo los siguientes errores en mi archivo de log:

[.programlisting]
....
CCP: CcpSendConfigReq
CCP: Received Terminate Ack (1) state = Req-Sent (6)
....

Esto ocurre porque man:ppp[8] esta intentando negociar compresión Predictor1, pero el peer no quiere negociar compresión en absoluto. Los mensajes son inofensivos, pero pueden ser silenciados deshabilitando la compresión:

[.programlisting]
....
disable pred1
....

=== ¿Por qué ppp8 no escribe en el log mi velocidad de conexión?

Para escribir en el log todas las líneas de la conversación de modem, agregue lo siguiente:

[.programlisting]
....
set log +connect
....

Esto hara que man:ppp[8] escriba en el log todo hasta la última cadena "expect" pedida.

Para ver la velocidad de conexión al usar PAP o CHAP, asegúrese de configurar man:ppp[8] para que espere la línea CONNECT entera, usando algo como esto:

[.programlisting]
....
set dial "ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 4 \
  \"\" ATZ OK-ATZ-OK ATDT\\T TIMEOUT 60 CONNECT \\c \\n"
....

Esto obtiene la línea CONNECT, no envía nada, y luego espera una nueva línea, forzando a man:ppp[8] a leer toda la respuesta CONNECT.

=== ¿Por qué ppp8 ignora el carácter \ en mi script de chat?

La utilidad ppp parsea cada línea en sus archivos de configuración de manera que pueda interpretar cadenas como `set phone "123 456 789"` correctamente y darse cuenta de que el número es solo un argumento. Para especificar un carácter `"`, escapeelo utilizando una barra invertida (`\`).

Cuando el interprete de chat parsea cada argumento, reinterpreta el argumento para buscar cualquier secuencia de escape especial tales como `\P` o `\T`. Como resultado de este doble parsea, recuerde usar el número correcto de escapes.

Para realmente envíar un carácter `\`, haga algo como:

[.programlisting]
....
set dial "\"\" ATZ OK-ATZ-OK AT\\\\X OK"
....

Esto resultara en la siguiente secuencia:

[.programlisting]
....
ATZ
OK
AT\X
OK
....

Ó:

[.programlisting]
....
set phone 1234567
set dial "\"\" ATZ OK ATDT\\T"
....

Esto resultara en la siguiente secuencia:

[.programlisting]
....
ATZ
OK
ATDT1234567
....

=== ¿Qué son los errores FCS?

FCS significa Frame Check Secuence (secuencia de verificación de marcos). Cada paquete PPP tiene un checksum asignado para asegurarse que los datos que están siendo recibidos son los datos que se envían. Si el FCS de un paquete entrante es incorrecto, el paquete es tirado y la cuenta de HDLC de FCS se incrementa. Los valores de error de HDLC pueden mostrarse usando el comando `show hdlc`.

Si el link esta mal o el controlador de serie comienza a desechar paquetes, producirá el error de FCS ocasional. Esto no suele ser algo por lo que valga la pena preocuparse, aunque ralentiza los protocolos de compresión substancialmente.

Si el link se paraliza tan pronto como se conecta y produce ung ran numero de errores de FCS, asegurese de que el modem no este usando control de flujo por software (XON/XOFF). Si el link debe usar control de flujo por software, use `set accmap 0x000a0000` para decirle a man:ppp[8] que escapee los caracteres `^Q` y `^S`.

Otra razón para tener demasiados errores de FCS puede ser que el extremo remoto haya dejado de comunicarse con PPP. En este caso, habilite el logueo `async` para determinar si los datos entrantes son de un inicio de sesión o un indicador del shell. Si se trata de un indicador del shell en el textrmo remoto, es posible terminar man:ppp[8] sin desechar la línea usando `close lcp` seguido de `term`) para reconectarse al shell en la máquina remota.

Si nada en el archivo de log indica porque el ink fue terminado, pregúntele al administrador remoto o su ISP porque la sesión termino.

=== Nada de esto ayuda — ¡Estoy desesperado! ¿Qué puedo hacer?

Si todo lo demás falla, envíe los detalles del error, los archivos de configuración, como se esta iniciando man:ppp[8], las partes reelevantes del archivo de log, y la salida de `netstat -rn`, antes y después de conectarse, a la http://lists.FreeBSD.org/mailman/listinfo/freebsd-questions[lista de correo de preguntas generales de FreeBSD].

== Comunicaciones en serie

Esta sección responde preguntas comunes acerca de comunicaciones en serie con FreeBSD. PPP esta cubierto en la sección de <<networking,Redes>>.

=== ¿Qué tarjetas en serie multi-puerto están soportadas por FreeBSD?

Hay una lista de las mismas en el capítulo link:{handbook}#serial[Comunicaciones en serie] del manual.

Las tarjetas multipuertos PCI que estén basadas en 16550 o clones están soportadas sin ningún esfuerzo extra.

Se ha reportado tambíen que algunas tarjetas clon variadas funcionan, especialmente aquellas que dicen ser compatibles con AST.

Vea man:uart[4] and man:sio[4] para obtener más información acerca de configurar tales tarjetas.

=== ¿Como hago que boot: prompt se muestre en la consola de serie?

Vea link:{handbook}#serialconsole-setup[esta sección del manual].

=== ¿Cómo puedo saber si FreeBSD encontró mis puertos en serie o tarjetas de modem?

Mientras el kernel de FreeBSD arranca, verificara los puertos en serie para los que esta configurado el kernel. Vea los mensajes de inicio con atención o corra este comando luego de que el sistema haya arrancado:

[source,bash]
....
% dmesg | grep -E "^sio[0-9]"
sio0: <16550A-compatible COM port> port 0x3f8-0x3ff irq 4 flags 0x10 on acpi0
sio0: type 16550A
sio1: <16550A-compatible COM port> port 0x2f8-0x2ff irq 3 on acpi0
sio1: type 16550A
....

Esta salida de ejemplo muestra dos puertos en serie. El primero esta en IRQ4, en la dirección de puerto `0x3f8`, y tiene un chip de tipo 16550A-type UART. El segundo usa el mismo tipo de chip pero esta en IRQ3 y esta en la dirección de puerto `0x2f8`. Las tarjetas de modem internas también son tratadas como puertos en serie, excepto que siempre tienen un modem adjuntado al puerto.

El kernel [.filename]#GENERIC# incluye soporte para dos puertos en serie usando los mismos ajustes de dirección de puerto e IRQ en el ejemplo anterior. Si estos ajustes no son adecuados para el sistema, o si hay más tarjetas de modem o puertos en serie que los que tiene configurado el kernel, reconfigure usando las instrucciones en <<make-kernel,compilar un kernel>> para más detalles.

=== ¿Como accedo a los puertos en serie en FreeBSD?

El tercer puerto en serie [.filename]#sio2#, o [.filename]#COM3#, esta en [.filename]#/dev/cuad2# para dispositivos de marcado saliente, y en [.filename]#/dev/ttyd2# para dispositivos de marcado entrante. ¿Cuál es la diferencia entre estas dos clases de dispositivos?

Al abrir [.filename]#/dev/ttydX# en modo bloqueante, un proceso esperara a que el correspondiente dispositivo [.filename]#cuadX# se vuelva inactivo, y luego espera a que la línea de detección del portador pase a estar activa. Cuando el dispositivo [.filename]#cuadX# es abierto, se asegura de que el puerto en serie no este ya en uso por el dispositivo [.filename]#ttydX#. Si el puerto esta disponible, se lo roba al dispositivo [.filename]#ttydX#. Además, el dispositivo [.filename]#cuadX# no se preocupa por la detección del portador. Con este esquema y un modem de auto-respuesta, los usuarios remotos pueden autenticarse y los usuarios locales aún pueden marcar fuera con el mismo modem y el sistema se ocupara de todos los conflictos.

=== ¿Como habilito el soporte para una tarjeta en serie multipuertos?

La sección acerca de configuración del kernel provee información acerca de configurar el kernel. Para una tarjeta en serie multipuertos, coloque una línea man:sio[4] por cada puerte en serie en la tarjeta en el archivo man:device.hints[5]. Pero coloque los especificadores IRQ en solo una de las entradas. Todos los puertos en la tarjeta deberían compartir un solo IRQ. Por consistencia, use el último puerto en serie para especificar el IRQ. También especifique la siguiente opción en el archivo de configuración del kernel:

[.programlisting]
....
options COM_MULTIPORT
....

El siguiente ejemplo de [.filename]#/boot/device.hints# es para una tarjeta en serie AST de 4 puertos en IRQ 12:

[.programlisting]
....
hint.sio.4.at="isa"
hint.sio.4.port="0x2a0"
hint.sio.4.flags="0x701"
hint.sio.5.at="isa"
hint.sio.5.port="0x2a8"
hint.sio.5.flags="0x701"
hint.sio.6.at="isa"
hint.sio.6.port="0x2b0"
hint.sio.6.flags="0x701"
hint.sio.7.at="isa"
hint.sio.7.port="0x2b8"
hint.sio.7.flags="0x701"
hint.sio.7.irq="12"
....

Estas banderas indican que el puerto maestro tiene un número menor `7` (`0x700`), y que todos los puertos comparten un IRQ (`0x001`).

=== ¿Puedo ajustar los parámetros en serie por defecto para un port?

Vea la sección link:{handbook}#serial-hw-config[Comunicaciones en serie]en el manual de FreeBSD.

=== ¿Como puedo habilitar inicios de sesión por marcado en mi modem?

Vea la sección acerca de link:{handbook}#dialup[Servicios de marcado] en el manual de FreeBSD.

=== ¿Como puedo conectar una terminal gregaria a mi instalación de FreeBSD?

Esta información puede encontrarse en la sección link:{handbook}#term[Terminales] del manual de FreeBSD.

=== ¿Por qué no puedo correr tip o cu?

Las utilidades man:tip[1] y man:cu[1] incluidas solo pueden acceder el directorio [.filename]#/var/spool/lock# mediante el usuario `uucp` y el grupo `dialer`. Use el grupo `dialer` para controlar quien tiene acceso al modem o sistemas remotos agregando cuentas de usuario a `dialer`.

Alternativamente, todos pueden configurarse para correr man:tip[1] and man:cu[1] escribiendo:

[source,bash]
....
# chmod 4511 /usr/bin/cu
# chmod 4511 /usr/bin/tip
....

== Preguntas varias

=== FreeBSD usa mucho espacio de swap incluso cuando la computadora aún tiene memoria libre. ¿Por qué?

FreeBSD mueve proactivamente las páginas sin usar, enteramente ociosas de la memoria principal a swap para lograr que mas memoria principal este disponible para su uso. Este uso intensivo de sqp se balancea al usar la memoria extra como cache.

Note que mientras que FreeBSD es proactivo en este modo, no decide arbitrariamente hacer swap de páginas cuando el sistema esta verdaderamente ocioso. Por consiguiente, el sistema no habrá pagina completamente a disco luego de dejarlo ocioso por una noche.

=== ¿Por qué top muestra muy poca memoria libre incluso cuando tengo pocos programas corriendo?

La respuesta simple es que la memoria libre es memoria gastada. Cualquier memoria que los programas no alocan activamente es usada en el kernel de FreeBSD como cache de disco. Los valores mostrados por man:top[1] marcados como `Inact`, `Cache`, y `Buf` son datos en cache con diferentes niveles de envejecimiento. Estos datos en cache significan que el sistema no tiene que acceder a un disco lento nuevamente para datos que accedió recientemente, incrementando la performance general. En general, un valor bajo para `Free` en man:top[1] es bueno, asumiendo que no sea _muy_ bajo.

=== ¿Por qué chmod no cambia los permisos en symlinks?

Los symlinks no tienen permisos, y por defecto, man:chmod[1] seguirá los symlinks para cambiar los permisos en el archivo fuente, de ser posible. Para el archivo, [.filename]#foo# co un symlink llamado [.filename]#bar#, este comando siempre tendrá éxito.

[source,bash]
....
% chmod g-w bar
....

Sin embargo, los permisos en [.filename]#bar# no habrán cambiado.

Al cambiar los modos de las jerarquías de archivo que tienen raíz en los archivos en lugar de los archivos mismos, use `-H` o `-L` en conjunto con `-R` para hacer que esto funciona. Vea man:chmod[1] y man:symlink[7] para más información.

[WARNING]
====

`-R` hace una man:chmod[1]_recursivo_. Tenga cuidado con especificar directorios o symlinks a directorios en man:chmod[1]. Para cambiar los permisos de un directorio referenciado por un symlink, use man:chmod[1] sin opciones y agregue una barra ([.filename]#/#) al final del symlink. Por ejemplo, si [.filename]#foo# es un symlink al directorio [.filename]#bar#, para cambiar los permisos de [.filename]#foo# (que en realidad es [.filename]#bar#), haga algo como:

[source,bash]
....
% chmod 555 foo/
....

Con la barra al final, man:chmod[1] seguirá el symlink, [.filename]#foo#, para cambiar los permisos del directorio, [.filename]#bar#.
====

=== ¿Puedo correr binarios de DOS bajo FreeBSD?

Si. Un programa de emulación de DOS, package:emulators/doscmd[], esta disponible en la colección de ports de FreeBSD.

Si doscmd no es suficiente, package:emulators/pcemu[] emula un 8088 y suficientes servicios de BIOS para correr muchas aplicaciones de DOS en modo texto. Requiere el sistema X Window.

La colección de ports también tiene package:emulators/dosbox[]. El foco principal de esta aplicación es emular juegos viejos de DOS usando el sistema de archivos local para los archivos.

=== ¿Qué necesito para traducir un documento de FreeBSD a mi lenguaje nativo?

Vea el link:{fdp-primer}translations[FAQ de Traducciones] en la documentación en el Primer de documentación FreeBSD. 

=== ¿Por qué mi correo a cualquier dirección con el dominio FreeBSD.org rebota?

El sistema de correo de `FreeBSD.org` implementa algunas de las verificaciones de Postfix sobre el correo entrante y rechaza el correo que proviene de relays mal configurados o que parece ser spam. Algunos de los requisitos específicos son:

* La dirección de IP del cliente SMTP debe "resolverse inversamente" a un nombre de host confirmado hacia adelante.
* El nombre de host completo dado en la conversación SMTP (HELO o EHLO) debe resolverse a la dirección IP del cliente.

Otros consejos para ayudar a que el correo llegue incluyen:

* El correo debe ser enviado como texto plano, y los mensajes enviados a las listas de correo no deberían ser más largos que 200KB.
* Evite el cross posting excesivo. Elija _una_ lista de correo que parezca relevante y envíelo allí.

Si tiene problemas con la infraestructura de correo de `FreeBSD.org`, envíe una nota con los detalles a mailto:postmaster@freebsd.org[postmaster@freebsd.org]; Incluya un intervalo de hora/fecha de manera que los logs puedan ser revisados -- y tenga en cuenta que solo mantenemos logs de correo por una semana. (Asegurese de especificar la zona temporal o el offset desde UTC.)

=== ¿Dónde puedo encontrar una cuenta gratis de FreeBSD?

Mientras que FreeBSD no provee acceso abierto a ninguno de sus servidores, otros proveen sistemas UNIX(TM) de acceso abierto. El costo varía y puede que estén disponibles servicios limitados.

http://www.arbornet.org/[Arbornet, Inc], también conocida como _M-Net_, ha estado proveyendo acceso abierto a sistemas UNIX(TM) desde 1983. Empezando con un Altos corriendo System III, el sitio cambio a BSD/OS en 1991. En junio del 2000, el sitio cambio nuevamente a FreeBSD. _M-Net_ puede ser accedido mediante telnet y SSH y provee acceso básico para la suite de software entera de FreeBSD. Sin embargo, el acceso a la red esta limitado a miembros y patrocinadores que donan al sistema, el cual es mantenido por una organización sin fines de lucro. _M-Net_ también provee un sistema de bulletin board y un chat interactivo.

=== ¿Cuál es el nombre del apuesto muchacho de rojo?

No tiene ningún nombre, sencillamente se lo llama "el demonio de BSD". Si insiste en usar un nombre, llamelo "beastie". Note que "beastie" se pronuncia "BSD".

Más información acerca del demonio de BSD esta disponible en su http://www.mckusick.com/beastie/index.html[pagina web].

=== ¿Puedo usar la imagen del demonio de BSD?

Tal vez. El demonio de BSD esta registrado con derechos de autor por Marshall Kirk McKusick. Vea su http://www.mckusick.com/beastie/mainpage/copyright.html[Declaración acerca del uso de la figura del demonio de BSD] para términos de uso detallados.

En resumen, la imagen puede ser usada de una manera respetuosa, para uso personal, mientras que se de el crédito apropiado. Antes de usar el logo comercialmente, contacte a Kirk McKusick mailto:mckusick@FreeBSD.org[mckusick@FreeBSD.org] para obtener permiso.

=== ¿Tienen imágenes del demonio de BSD que pueda usar?

Dibujos en Xfig y eps están disponibles en [.filename]#/usr/shared/examples/BSD_daemon/#.

=== He visto un acrónimo u otro término en las listas de correo y no entiendo que significa. ¿Dónde tendría que buscar?

Vea el link:{handbook}#freebsd-glossary/[glosario de FreeBSD].

=== ¿Por qué debería preocuparme de que color es el cobertizo para bicicletas?

La respuesta verdaderamente corta es que no debería. La respuesta un poco más larga es que solo porque usted es capaz de construir un cobertizo para bicicletas no significa que debería evitar que otros construyan uno solo porque no le gusta el color del que lo quieren pintar. Esta es una metáfora indicando que no necesita discutir sobre cada pequeña característica solo porque tiene el conocimiento para hacerlo. Algunas personas comentaron que la cantidad de ruido generada por un cambio es inversamente proporcional a la complejidad del cambio.

Una respuesta más larga y completa es que luego de una larga discusión acerca de si man:sleep[1] debería tomar argumentos de segundos fraccionales, mailto:phk@FreeBSD.org[phk@FreeBSD.org] posteo un largo mensaje titulado "link:http://www.FreeBSD.org/cgi/getmsg.cgi?fetch=506636+517178+/usr/local/www/db/text/1999/freebsd-hackers/19991003.freebsd-hackers[A bike shed (any color will do) on greener grass...]". Las porciones apropiadas de ese mensaje son citadas más abajo.

Poul-Henning Kamp mailto:phk@FreeBSD.org[phk@FreeBSD.org] en http://lists.FreeBSD.org/mailman/listinfo/freebsd-hackers[freebsd-hackers], October 2, 1999
"¿Qué es esto acerca de un cobertizo de bicicletas?" Me han preguntado algunos.

Es una larga historia, o más bien, una historia vieja pero de hecho es bastante corta. C. Northcote Parkinson escribió un libro a principios de los 1960s, titulado "Parkinson's Law", que contiene muchas revelaciones acerca de la dinámica del management.

_[suprimidos varios comentarios acerca del libro]_

En el ejemplo específico que involucra al cobertizo de bicicletas, el otro componente vital es una planta de energía atómica, supongo que eso ilustra la edad del libro.

Parkinson muestra como puedes ir a la junta directiva y obtener aprobación para construir una planta de energía atómica que cueste varios millones, o incluso un billon, pero si quieres construir un cobertizo para bicicletas te encontraras atrapado en un sinfín de discusiones.

Parkinson explica que esto sucede porque una planta de energía es tan grande, tan cara y tan complicada que la gente no puede comprenderla, y en lugar de intentarlo, suponen que alguien más ya ha verificado todos los detalles antes de haber llegado tan lejos. Richard P. Feynmann da un par de ejemplos interesantes y aplicables ejemplos relacionados con Los Alamos en sus libros.

Un cobertizo de bicicletas es otra cosa. Cualquiera puede construirlo en un fin de semana, y aún tener tiempo para mirar un juego por televisión. De modo que sin importar que tan bien preparada, o que tan razonable sea tu propuesta, alguien aprovechara la oportunidad para mostrar que esta haciendo su trabajo, que esta prestando atención, que esta _presente_.

En Dinamarca lo llamamos "dejar tu huella dactilar". Se trata de privilegio y prestigio personal, se trata de poder apuntar a algún lado y decir "¡Ahi! _Yo_ hice eso."

== Cosas divertidas de FreeBSD

=== ¿Qué tan frío es FreeBSD?

[qanda]
¿Alguien ha hecho alguna prueba de temperatura al correr FreeBSD? Se que linux Linux(TM) es más frío que DOS, pero jamás vi alguna mención a FreeBSD. Parece que sobrecalienta bastante.::

No pero he hecho numerosas pruebas de gusto en voluntarios que tomaron 250 microgramos de LSD-25 administrados previamente. El 35% de los voluntarios dijo que FreeBSD sabe a naranja, mientras que Linux(TM) sabe a humo violeta. Ningún grupo menciono nada acerca de variaciones en la temperatura. Eventualmente debimos desechar los resultados de esta encuesta de todas formas al enterarnos que demasiado voluntarios estaban deambulando fuera del cuarto durante las pruebas, arruinando los resultados. Pensamos que la mayoría de los voluntarios están en Apple ahora, trabajando en su nueva GUI "scratch and sniff". ¡Es un negocio divertido el nuestro!

En serio, FreeBSD usa la instrucción HLT (halt) cuando el sistema esta ocioso, de esta manera reduciendo su consumo de energía y eventualmente el calor que genera. Además, si ha configurado ACPI (Advanced Configuration and Power Interface), entonces FreeBSD también puede poner la CPU en modo de bajo consumo.

=== ¿Quién esta borrando mis bancos de memoria?

[qanda]
¿Hay algo "extraño" que FreeBSD hace al compilar el kernel que pueda causar que la memoria haga un sonido de rasguño? Al compilar (y por un breve momento luego de reconocer el disco floppy en el arranque), un extraño sonido como un arañazo emana de lo que parecen ser los bancos de memoria.::

¡Si! Vera frecuentes referencias a "demonios" en la documentación de BSD y lo que la mayoría de la gente no sabe es que esto se refiere a entidades genuinas e incorpóreas que ahora poseen su computadora. El sonido de arañazos que viene desde su memoria es de hecho un silbido de alta frecuencia intercambiado por los demonios mientras deciden como lidiar con varias tareas administrativas del sistema.

Si el sonido lo empieza a molestar, un buen `fdisk /mbr` desde DOS se librara de ellos, pero no se sorprenda si reaccionan adversamente e intentan detenerlo. De hecho, si en cualquier punto del ejercicio usted escucha la voz satánica de Bill Gates viniendo desde el parlante incorporado... ¡Salga corriendo y no mire hacia atrás! Libre de las influencias de contrapeso de los demonios de BSD, los demonios gemelos de DOS y Windows(TM) suelen poder asegurarse el control total de su máquina y la condenación eterna de su alma. ¿Ahora que lo sabe, dada la oportunidad preferiría acostumbrarse a los sonidos de rasguños, verdad?

=== ¿Cuántos hackers de FreeBSD se necesitan para cambiar un foco de luz?

Mil ciento sesenta y nueve.

Veintitrés para quejarse en -CURRENT que las luces están apagadas;

Cuatro para declarar que es un problema de configuración, y que tales cuestiones pertenecen a -questions;

Tres para envíar PRs acerca de ello, uno de los cuales fue enviado erróneamente bajo doc y consiste solo de "esta oscuro";

Uno para commitear un foco de luz no probado que rompe buildworld, y luego revertirlo cinco minutos después;

Ocho para agredir a los que envíaron el PR por no incluir parches en sus PRs;

Cinco para quejarse de que buildworld esta roto;

Treinta y uno para responder que funciona para ellos, y que deben haber actualizado en un mal momento;

Uno para postear un parche para un nuevo foco de luz a -hackers;

Uno para quejarse de que tuvo parches para esto hace tres años, pero cuando los envío a -CURRENT fueron ignorados, y que tuvo malas experiencias con el sistema de PR; además, el nuevo foco de luz propuesto no es reflexivo.

Treinta y siete para gritar que los focos de luz no pertenecen en el sistema base, que los commiters no tienen derecho a hacer estas cosas sin consultar con la comunidad, y ¡¿QUE ESTA HACIENDO CORE ACERCA DE ESTO?!

Doscientos para quejarse del color del cobertizo de bicicletas.

Tres para señalar que el parche no respeta man:style[9];

Diecisiete para quejarse de que el nuevo foco de luz propuesto esta bajo la GPL;

Quinientos ochenta y seis para iniciar una discusión acerca de las ventajas comparativas de la GPL, la licencia BSD, la licencia MIT, la NPL, y la higiene personal de fundadores no especificados de la FSF;

Siete para mover varias partes del thread a -chat y -advocacy;

Uno para commitear el foco de luz sugerido, aunque brille de manera más tenue que el viejo;

Dos para revertirlo con una furiosa discusión en un mensaje de commit, arguyendo que FreeBSD esta mejor en la oscuridad que con un foco de luz oscuro;

Cuarenta y seis para discutir vociferantemente acerca de la reversión del foco de luz tenue y demandando una declaración por parte de -core;

Once para pedir un foco de luz más pequeño de manera que entre en su Tamagotchi si deciden hacer un port de FreeBSD para esa plataforma;

Setenta y tres para quejarse acerca de SNR en -hackers y -chat y cancelar su subscripción como protesta;

Trece para postear "cancelar subscripción", "¿Como cancelo la subscripción?", o "Por favor sáquenme de la lista", seguidos del pie usual;

Uno para hacer un commit de un foco de luz funcional mientras que todo el mundo esta demasiado ocupado agrediendo a todos los demás como para notarlo;

Treinta y uno para señalar que el nuevo foco de luz seria un 0.364% más brillante si se compila con TenDRA (aunque tendría que ser remodelado en forma cúbica), y que FreeBSD debería cambiar a TenDRA en lugar de usar GCC;

Uno para quejarse de que el nuevo foco de luz no tiene carenados;

Nuevo (incluyendo los que crearon el PR) para preguntar "¿Qué es MFC?";

Cincueta y siete para quejarse acerca de que las luces estuvieron apagadas por dos semanas luego de que se cambio el foco.

_Nik Clayton_ mailto:nik@FreeBSD.org[nik@FreeBSD.org] añade:

_Me estaba riendo bastante con esto._

_Y luego pense, "Un momento ¿No debería haber '1 para documentarlo.' en algún lugar de esa lista?"_

_Y luego me ilumine :-)_

_Thomas Abthorpe_ mailto:tabthorpe@FreeBSD.org[tabthorpe@FreeBSD.org] dice: "Ninguno ¡Los _verdaderos_ hackers de FreeBSD no tienen miedo a la oscuridad!"

=== ¿Donde van los datos escritos a /dev/null?

Va a un disipador de datos especial en la CPU en donde es convertido en calor el cual es ventilado a través del conjunto disipador de calor / ventilador. Esto es por lo que el enfriado de CPU es cada vez más importante; mientras la gente se acostumbra a procesadores más rápidos se vuelven descuidados con sus datos y más y más termina en [.filename]#/dev/null#, sobrecalentando sus CPUs. Si borra [.filename]#/dev/null# (lo cual efectivamente deshabilita el su effectively el disipador de datos de CPU) su CPU podría correr a menos temperatura pero su sistema se volverá rápidamente constipado con todos los datos en exceso y comenzara a comportarse erráticamente. Si tiene una conexión de red rápida puede enfriar su CPU leyendo datos de [.filename]#/dev/random# y enviándolos a algún lugar; sin embargo corre el riesgo de sobrecalentar su conexión de red y [.filename]#/# o hacer enojar a su ISP, dado que la mayoría de los datos terminaran siendo convertidos en calor por su equipo, pero ellos generalmente tienen buena disipación de calor, de modo que si no se sobrepasa estará bien.

_Paul Robinson añade:_

Hay otros métodos. Como todo buen sysadmin sabe, es parte de las prácticas estándares envíar datos a la pantalla de variedad interesante para mantener los pixies y hacer feliz a sus fotos. Los pixies de pantalla (comúnmente mal escritos o renombrados como "pixels") son categorizados por el tipo de sombrero que llevan puesto (rojo, verde o azul) y se esconderán o aparecerán (de esta forma mostrando el color de su sombrero) cuando reciban un pedazo de comida. Las tarjetas de video convierten datos en comida para pixies y se la mandan a los pixies -- cuanto más cara la tarjeta, mejor es la comida, y mejor se comportan los pixies. También necesitan estimulación constante -- por esto es que existen los salvapantallas.

Para llevar más sus sugerencias, podría arrojar datos al azar a la consola, por consiguiente dejando que los pixies lo consuman. Esto hace que no se produzca calor en absoluto, mantiene los pixies felices y se deshace de sus datos realmente rápido, incluso si hace que las cosas se vean un poco desorganizadas en su pantalla.

Accidentalmente, como un ex-administrador de un gran ISP que ha experimentado muchos problemas intentando mantener una temperatura estable en el cuarto de servidores, desaconsejo fuertemente el que la gente envíe datos indeseados a la red. A las hadas que se encargan de el intercambio de paquetes y el ruteo también les molesta.

=== Mi colega esta demasiado tiempo sentada en la computadora. ¿Como puedo hacerle una broma?

Instale package:games/sl[] y espere a que ella se equivoque al escribir `sl` en vez de `ls`.

== Temas avanzados

=== ¿Como puedo aprender más acerca del funcionamiento interno de FreeBSD?

Vea el https://www.FreeBSD.org/doc/en_US.ISO8859-1/books/arch-handbook[Manual de arquitectura de FreeBSD].

Además, la mayor parte del conocimiento general acerca de UNIX(TM)es directamente aplicable a FreeBSD.

=== ¿Cómo puedo contribuir a FreeBSD?

Vea el artículo acerca de link:{contributing}[Contribuir a FreeBSD] para consejos específicos acerca de como hacer esto. ¡La ayuda es más que bienvenida!

=== ¿Qué son snapshots y lanzamientos?

Hay actualmente 3 ramas activas/semi activas en el http://svnweb.FreeBSD.org/base/[repositorio Subversion] de FreeBSD. (Las ramas anteriores cambian muy raramente, que es por lo cual solo hay 3 ramas de desarrollo activas):

* stable/9/ alias _9-STABLE_
* stable/10/ alias _10-STABLE_
* head/ alias _-CURRENT_ alias _11-CURRENT_

`HEAD` no es realmente un tag de rama. Es una constante simbólica para el torrente de desarrollo actual, no ramificado conocido como _-CURRENT_.

En este momento, _-CURRENT_ es el torrente de desarrollo 11._X_; la rama _10-STABLE_, stable/10/, se ramifico de _-CURRENT_ en Enero del 2014 y la rama _9-STABLE_, stable/9/, se ramifico de _-CURRENT_ en Septiembre del 2011.

=== ¿Puedo seguir -CURRENT con una conexión a Internet limitada?

Si, esto puede hacerse _sin_ descargar el árbol de código fuente entero usando la link:{handbook}#ctm[utilidad CTM].

=== He escrito una extensión para el kernel ¿A quien se la envío?

Vea el artículo en link:{contributing}[Contribuyendo a FreeBSD] para aprender como enviar código.

¡Y gracias por haberlo pensado!

=== ¿Como puedo aprovechar al máximo los datos que veo cuando mi kernel tiene un pánico?

Este es un típico pánico de kernel:

[.programlisting]
....
Fatal trap 12: page fault while in kernel mode
fault virtual address   = 0x40
fault code              = supervisor read, page not present
instruction pointer     = 0x8:0xf014a7e5
stack pointer           = 0x10:0xf4ed6f24
frame pointer           = 0x10:0xf4ed6f28
code segment            = base 0x0, limit 0xfffff, type 0x1b
                        = DPL 0, pres 1, def32 1, gran 1
processor eflags        = interrupt enabled, resume, IOPL = 0
current process         = 80 (mount)
interrupt mask          =
trap number             = 12
panic: page fault
....

Este mensaje no es suficiente. Mientras que el valor del puntero de instrucción es importante, también depende de la configuración varía en cada imagen de kernel. Si es un kernel [.filename]#GENERIC# desde uno de los snapshots, es posible que alguien más rastree la función problemática, pero para un kernel personalizado, solo usted puede decirnos donde ocurrió el fallo.

Para proceder:

[.procedure]
====
. Anote el valor del puntero de instrucción. Note que la parte `0x8:` al inicio no es importante en este caso: es la parte `0xf0xxxxxx` la que nos interesa.
. Cuando el sistema reinicie, haga lo siguiente:
+
[source,bash]
....
% nm -n kernel.que.causo.el.panico | grep f0xxxxxx
....
+ 
donde `f0xxxxxx` es el valor del puntero de instrucción. Lo más probable es que no consiga una coincidencia exacta dado que los símbolos en la tabla de símbolos del kernel son para puntos de entrada de las funciones y la dirección del puntero de instrucción estará en algún lugar adentro de una función, no al inicio. Si no consigue una coincidencia exacta, omita el último dígito del valor del puntero de instrucción e inténtelo nuevamente:
+
[source,bash]
....
% nm -n kernel.que.causo.el.panico | grep f0xxxxx
....
+ 
Si eso no arroja ningún resultado, elimine otro dígito. Repita hasta que haya algún tipo de salida. El resultado será una lista de posibles funciones que causaron el pánico. Este es un mecanismo poco exacto para rastrear el punto de fallo, pero es mejor que nada.
====

Sin embargo, la mejor manera de rastrear la causa del pánico es capturando un volcado de fallos, y luego usando man:kgdb[1] para generar un seguimiento de pila sobre el volcado de fallos.

En cualquier caso, el método es este:

[.procedure]
====
. Asegúrese de que la siguiente línea esta incluida en el archivo de configuración del kernel:
+
[.programlisting]
....
makeoptions     DEBUG=-g          # Build kernel with gdb(1) debug symbols
....
+
. Cambie el directorio a [.filename]#/usr/src#:
+
[source,bash]
....
# cd /usr/src
....
+
. Compile el kernel:
+
[source,bash]
....
# make buildkernel KERNCONF=MYKERNEL
....
+
. Espere a que man:make[1] termine de compilar.
+
[source,bash]
....
# make installkernel KERNCONF=MYKERNEL
....
+
. Reinicie.
====

[NOTE]
====
Si `KERNCONF` no esta incluida, el kernel [.filename]#GENERIC# sera compilado e instalado en su lugar.
====

El proceso man:make[1] habrá compilado dos kernels. [.filename]#/usr/obj/usr/src/sys/MYKERNEL/kernel# y [.filename]#/usr/obj/usr/src/sys/MYKERNEL/kernel.debug#. [.filename]#kernel# fue instalado como [.filename]#/boot/kernel/kernel#, mientras que [.filename]#kernel.debug# puede ser usado como la fuente de símbolos de depuración para man:kgdb[1].

Para capturar un volcado de pila, edite [.filename]#/etc/rc.conf# y ajuste `dumpdev` para que apunte a la partición swap o `AUTO`. Esto causara que los scripts de man:rc[8] usen el comando man:dumpon[8] para habilitar vocados de fallos. Este comando también puede correrse manualmente. Luego de un pánico, el volcado de fallos puede recuperarse usando man:savecore[8]; si `dumpdev` esta ajustado en [.filename]#/etc/rc.conf#, los scripts de man:rc[8] correran man:savecore[8] automáticamente y colocaran en volcado de fallos en [.filename]#/var/crash#.

[NOTE]
====
Los volcados de fallos de FreeBSD suelen ser del mismo tamaño que la RAM física. Por consiguiente, asegúrese de que haya suficiente espacio en [.filename]#/var/crash# para contener el volcado. Alternativamente, corra man:savecore[8] manualmente y haga que recupere el volcado de fallos desde otro directorio con más espacio. Es posible limitar el tamaño del volcado de fallos usando `options MAXMEM=N` donde _N_ es el tamaño del uso de memoria de kernel KBs. Por ejemplo, para 1 GB de RAM, limite el uso de memoria del kernel a 128 MB de modo que el tamaño del volcado de fallos sea de 128 MB en lugar de 1 GB.
====

Una vez que se haya recuperado el volcado de fallos, obtenga un seguimiento de pila de esta manera:

[source,bash]
....
% kgdb /usr/obj/usr/src/sys/MYKERNEL/kernel.debug /var/crash/vmcore.0
(kgdb) backtrace
....

Nótese que hay varias pantallas de información. En lo posible, use man:script[1] para capturarlas todas. Usar la imagen unstripped del kernel con todos los símbolos de depuración debería ahora mostrar la línea exacta del codigo fuente del kernel donde ocurrio el pánico. El seguimiento de pila suele leerse desde el fondo hacía arriba para rastrear la secuencia exacta de eventos que llevaron al fallo. man:kgdb[1] puede también usarse para imprimir el contenido de varias variables o estructuras para examinar el estado del sistema en el momento del fallo.

[TIP]
====

Si una segunda computadora esta disponible man:kgdb[1] puede configurarse para realizar la depuración remota, incluyendo ajustar breakpoints y hacer single-stepping en el código del kernel.
====

[NOTE]
====
Si `DDB` esta habilitado y el kernel pasa el depurado, se pueden forzar un pánico y un volcado de fallos escribiendo `panic` en la consola de `ddb`. Esto puede detener el depurador nuevamente durante la fase de pánico. Si lo hace, escriba `continue` y finalizara el volcado de fallos.
====

=== ¿Por qué dlsym() ha dejado de funcionar para ejecutables ELF?

ELF toolchain por defecto no hace que los símbolos definidos a un ejecutable sean visibles al linker dinámico. Consecuentemente `dlsym()` busca en los descriptores obtenidos desde llamadas a `dlopen(NULL, flags)` y no podrá encontrar tales símbolos.

Para buscar, usando `dlsym()`, por símbolos presentes en el ejecutable principal de un proceso, vincule el ejecutable usando la opción `--export-dynamic` para el linker ELF (man:ld[1]).

=== ¿Como puedo incrementar o reducir el espacio de direcciones del kernel en i386?

Por defecto, el espacio de direcciones del kernel es de 1 GB (2 GB ppara PAE) para i386. Al correr un servidor que es intensivo sobre la red o usar ZFS, esto probablemente no sea suficiente.

Agregue la siguiente línea al archivo de configuración del kernel para incrementar el espacio disponible y recompile el kernel:

[.programlisting]
....
options KVA_PAGES=N
....

Para encontrar el valor correcto de _N_, divida el tamaño de espacio de direcciones deseado (en megabytes) por cuatro. (Por ejemplo, `512` para 2 GB.)

== Reconocimientos

Este inocente y pequeño documento de Preguntas Frecuentes ha sido escrito, reescrito, editado, doblado, girado, mutilado, eviscerado, contemplado, confundido, reflexionado, regurgitado, reconstruido, castigado y revitalizado en el curso de la ultima década, por un equipo de cientos si no miles. Repetidamente.

Queremos agradecerles a cada una de las personas responsables, y lo animamos a que link:{contributing}[se les una] para hacer este FAQ aún mejor.

[bibliography]
[[bibliography]]
== Bibliografía

[biblio-unleashed] FreeBSD Unleashed. Michael Urban und Brian Tiemann. Sams. Erste Ausgabe. 992 Seiten. Oktober 2001. ISBN 0-67232-206-4.

[biblio-44sysman] 4.4BSD System Manager's Manual. Computer Systems Research Group, University of California, Berkeley. O'Reilly and Associates. Erste Ausgabe. Juni 1994. 804 Seiten. ISBN 1-56592-080-5.

[biblio-44userman] 4.4BSD User's Reference Manual. Computer Systems Research Group, University of California, Berkeley. O'Reilly and Associates. Erste Ausgabe. Juni 1994. 905 Seiten. ISBN 1-56592-075-9.

[biblio-44suppman] 4.4BSD User's Supplementary Documents. Computer Systems Research Group, University of California, Berkeley. O'Reilly and Associates. Erste Ausgabe. Juni 1994. 712 Seiten. ISBN 1-56592-076-7.

[biblio-44progman] 4.4BSD Programmer's Reference Manual. Computer Systems Research Group, University of California, Berkeley. O'Reilly and Associates. Erste Ausgabe. Juni 1994. 866 Seiten. ISBN 1-56592-078-3.

[biblio-44progsupp] 4.4BSD Programmer's Supplementary Documents. Computer Systems Research Group, University of California, Berkeley. O'Reilly and Associates. Erste Ausgabe. Juni 1994. 596 Seiten. ISBN 1-56592-079-1.

[biblio-44kernel] The Design and Implementation of the 4.4BSD Operating System. M. K. McKusick, Kirk Marshall, Keith Bostic, Michael J Karels und John Quarterman. Addison-Wesley. Reading MA . 1996. ISBN 0-201-54979-4.

[biblio-freebsdkernel] The Design and Implementation of the FreeBSD Operating System. M. K. McKusick und George V. Neville-Neil. Addison-Wesley. Boston MA . 2004. ISBN 0-201-70245-2.

[biblio-nemeth3rd] Unix System Administration Handbook. Evi Nemeth, Garth Snyder, Scott Seebass, Trent R. Hein und John Quarterman. Prentice-Hall. Dritte Ausgabe. 2000. ISBN 0-13-020601-6.

[lehey3rd] The Complete FreeBSD. Greg Lehey. Walnut Creek. Dritte Ausgabe. Juni 1999. 773 Seiten. ISBN 1-57176-246-9.

[McKusick et al, 1994] Berkeley Software Architecture Manual, 4.4BSD Edition. M. K. McKusick, M. J. Karels, S. J. Leffler, W. N. Joy und R. S. Faber. 5:1-42.

[biblio-ja-fbsdpc98] FreeBSD for PC 98'ers (in Japanisch). SHUWA System Co, LTD.. ISBN 4-87966-468-5 C3055 P2900E.

[biblio-ja-fbsd] FreeBSD (in Japanisch). CUTT. ISBN 4-906391-22-2.

[biblio-ja-compintro] Complete Introduction to FreeBSD (in Japanisch). Shoeisha Co., Ltd. ISBN 4-88135-473-6 P3600E.

[biblio-ja-unixstarterkit] Personal UNIX Starter Kit FreeBSD (in Japanisch). ASCII. ISBN 4-7561-1733-3 P3000E.

[biblio-ja-fbsdhb] FreeBSD Handbook (Japanische Übersetzung). ASCII. ISBN 4-7561-1580-2 P3800E.

[biblio-ge-fbsdmitmeth] FreeBSD mit Methode (in Deutsch). Computer und Literature Verlag/Vertrieb Hanser. 1998. ISBN 3-932311-31-0.

[biblio-ja-fbsdinstandutil] FreeBSD install and Utilization Manual (in Japanisch). Mainichi Communications Inc..

[biblio-indo-intserv] Building Internet Server with FreeBSD (in Indonesisch). Elex Media Komputindo. Onno W Purbo, Dodi Maryanto, Syahrial Hubbany und Widjil Widodo.

[biblio-fbsdcorpnetguide] The FreeBSD Corporate Networker's Guide. Addison-Wesley.

[biblio-unixnutshell] UNIX in a Nutshell. O'Reilly & Associates, Inc.. 1990. ISBN 093717520X.

[biblio-cantfindadmin] What You Need To Know When You Can't Find Your Unix System Administrator. O'Reilly & Associates, Inc.. 1995. Linda Mui. ISBN 1-56592-104-6.

[biblio-ja-fbsdusrrefman] FreeBSD User's Reference Manual (Japanische Übersetzung). Mainichi Communications Inc.. Jpman Project, Japan FreeBSD Users Group. 1998. ISBN 4-8399-0088-4 P3800E.

[biblio-newcomeunix] http://unixhelp.ed.ac.uk/[Online Guide for newcomers to the UNIX environment]“. http://www.ed.ac.uk/[Edinburgh University].

[biblio-dnsandbind] DNS and BIND. O'Reilly & Associates, Inc. ISBN 1-56592-512-2. Paul Albitz Albitz und Cricket Liu. 1998. Dritte Ausgabe.

[biblio-sendmail] Sendmail. O'Reilly & Associates, Inc. 1997. Zweite Auflage. Brian Costales. ISBN 1-56592-222-0.

[biblio-esssysadmin] Essential System Administration. Æleen Frisch. Zweite Auflage. O'Reilly & Associates. 1995. ISBN 1-56592-127-5.

[biblio-tcpipnetworkadministration] TCP/IP Network Administration. Craig Hunt. Zweite Auflage. O'Reilly & Associates, Inc. 1997. ISBN 1-56592-322-7.

[biblio-managingnfsandnis] Managing NFS and NIS. Hal Stern. O'Reilly & Associates, Inc. 1991. ISBN 0-937175-75-7.

[biblio-jpmanprojectjfug] http://www.pc.mycom.co.jp/FreeBSD/sam.html[FreeBSD System Administration's Manual]. http://www.jp.freebsd.org/[Jpman Project, Japan FreeBSD Users Group]. http://www.pc.mycom.co.jp/[Mainichi Communications Inc.]. 1998. ISBN 4-8399-0109-0 P3300E.

[biblio-xwinsystoolkit] X Window System Toolkit. Digital Press. Paul Asente. ISBN 1-55558-051-3.

[biblio-carefman] C: A Reference Manual. Prentice Hall. 1995. Vierte Auflage. Samuel P. Harbison und Guy L. Jr. Steele. ISBN 0-13-326224-3.

[biblio-thecproglang] The C Programming Language. Prentice Hall. 1998. Brian Kernighan und Dennis Ritchie. ISBN 0-13-110362-9.

[biblio-portingunixsoft] Porting UNIX Software. Greg Lehey. O'Reilly & Associates, Inc.. 1995. ISBN 1-56592-126-7.

[biblio-thestandardclibrary] The Standard C Library. Prentice Hall. 1992. P. J. Plauger. ISBN 0-13-131509-9.

[biblio-advprogintheunixenv] Advanced Programming in the UNIX Environment. Addison-Wesley. 1992. W. Richard Stevens. ISBN 0-201-56317-7.

[biblio-unixnetprog] UNIX Network Programming. W. Richard Stevens. Prentice Hall. 1998. Zweite Auflage. ISBN 0-13-490012-X.

[biblio-writeserialdriverforunix] Writing Serial Drivers for UNIX. Bill Wells. Dezember 1994. Dr. Dobb's Journal. pp68-71, pp97-99.

[biblio-unixsysarch] UNIX System Architecture. Prentice-Hall, Inc. 1990. Prabhat K. Andleigh. ISBN 0-13-949843-5.

[biblio-portingunixtothe386] Porting UNIX to the 386. William Jolitz. Dr. Dobb's Journal. Januar 1991 - Juli 1992.

[biblio-tcpipillv1theprotocols] TCP/IP Illustrated, Volume 1: The Protocols. W. Richard Stevens. Addison-Wesley. 1996. ISBN 0-201-63346-9.

[biblio-unixsysformodrnarch] Unix Systems for Modern Architectures. Addison-Wesley. Curt Schimmel. 1994. ISBN 0-201-63338-8.

[biblio-tcpipillvol3] TCP/IP Illustrated, Volume 3: TCP for Transactions, HTTP, NNTP and the UNIX Domain Protocols. Addison-Wesley. 1996. W. Richard Stevens. ISBN 0-201-63495-3.

[biblio-unixinternthenewfrontiers] UNIX Internals -- The New Frontiers. Uresh Vahalia. Prentice Hall. 1996. ISBN 0-13-101908-2.

[biblio-tcpipillvol2theimplementation] TCP/IP Illustrated, Volume 2: The Implementation. Gary R. Wright und W. Richard Stevens. 1995. Addison-Wesley. ISBN 0-201-63354-X.

[biblio-firewallsandinternetsecurity] Firewalls and Internet Security: Repelling the Wily Hacker. William R. CHeswick und Steven M. Bellovin. Addison-Wesley. 1995. ISBN 0-201-63357-4.

[biblio-practicalunixsecurity] Practical UNIX Security. Simson Garfinkel und Gene Spafford. 1996. Zweite Auflage. O'Reilly & Associates, Inc. ISBN 1-56592-148-8.

[biblio-pgpprettygoodprivacy] PGP Pretty Good Privacy. Simson Garfinkel. O'Reilly & Associates, Inc. 1995. ISBN 1-56592-098-8.

[biblio-pentiumprocarch] Pentium Processor System Architecture. Don Anderson und Tom Shanley. Addison-Wesley. 1995. Zweite Auflage. ISBN 0-201-40992-5.

[biblio-progguidetothesvgacards] Programmer's Guide to the EGA, VGA, and Super VGA Cards. Richard F. Ferraro. Dritte Ausgabe. Addison-Wesley. 1995. ISBN 0-201-62490-7.

[biblio-80486] 80486 System Architecture. Tom Shanley. Addison-Wesley. 1995. Dritte Ausgabe. ISBN 0-201-40994-1.

[biblio-isasysarch] ISA System Architecture. Tom Shanley. Addison-Wesley. Dritte Ausgabe. 1995. ISBN 0-201-40996-8.

[biblio-pcisysarch] PCI System Architecture. Tom Shanley. Addison-Wesley. 1995. Dritte Ausgabe. ISBN 0-201-40993-3.

[biblio-theundocumentedpc] The Undocumented PC. Frank Van Gilluwe. Addison-Wesley. 1994. ISBN 0-201-62277-7.

[biblio-bellsystemtechnicaljournal] Bell System Technical Journal, Unix Time-Sharing System. American Telephone & Telegraph Company. Juli - August 1978. Vol 57, No 6, Part 2. ISSN0005-8580.

[biblio-commentaryonunix] Lion's Commentary on UNIX. John Lion. ITP Media Group. 1996. Sechste Ausgabe. ISBN 1573980137.

[biblio-newhackerdict] The New Hacker's Dictionary. Eric S. Raymond. MIT Press. 1996. Dritte Ausgabe. ISBN 0-262-68092-0.

[biblio-aqtrcentofunix] A quarter century of UNIX. Peter H. Salus. Addison-Wesley. 1994. ISBN 0-201-54777-5.

[biblio-unixhatershandbook] The UNIX-HATERS Handbook. Steven Strassman, Daniel Weise und Simon Garfinkel. IDG Books Worldwide, Inc. 1994. ISBN 1-56884-203-1.

[biblio-lifewithunix] Life with UNIX - special edition. Don Libes und Sandy Ressler. Prentice-Hall. 1989. ISBN 0-13-536657-7.

[biblio-bsdfamilytree] https://svnweb.freebsd.org/base/head/shared/misc/bsd-family-tree?view=co[The BSD Family Tree]. 1997.

[absolutebsd] Absolute BSD. Michael Lucas. No Starch Press. Juni 2002. ISBN 1-886411-74-3.

[biblio-ccppusersjournal] The C/C++ Users Journal. R&D Publications Inc.. ISSN 1075-2838.

[biblio-sysadminthejournalforunixsysadmins] Sys Admin - The Journal for UNIX System Administrators. Miller Freeman, Inc. ISSN 1061-2688. 
