---
title: Capítulo 7. Multimedia
part: Parte II. Tareas comunes
prev: books/handbook/desktop
next: books/handbook/kernelconfig
showBookMenu: true
weight: 10
path: "/books/handbook/multimedia/"
---

[[multimedia]]
= Multimedia
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 7
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/multimedia/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

== Sinopsis

FreeBSD admite una gran variedad de tarjetas de sonido, lo que permite disfrutar de sonido de alta fidelidad en su sistema. Ésto incluye la posibilidad de grabar y reproducir ficheros de audio tanto en los formatos MPEG Audio Layer 3 (MP3), WAV y Ogg Vorbis, así como muchos otros. La Colección de Ports de FreeBSD contiene también aplicaciones que le permitirán editar audio previamente grabado, añadir efectos y controlar dispositivos MIDI.

Tras unas cuantas pruebas podrá reproducir ficheros de video y DVD en FreeBSD. La cantidad de aplicaciones disponibles para codificar, convertir y reproducir los diversos soportes de video es más limitada que lo que hay disponible para el sonido. Por ejemplo, en el momento de escribir este texto no hay en la Colección de Ports de FreeBSD una buena aplicación que permita pasar datos de un formato a otro, el equivalente a lo que hay en el campo del sonido con package:audio/sox[]. A pesar de eso la situación en este área está cambiando rápidamente.

Este capítulo muestra los pasos necesarios para configurar una tarjeta de sonido. La configuración e instalación de X11 (crossref:x11[x11,El sistema X Window]) habrá solucionado ya todos los problemas que hubiera podido darle su tarjeta gráfica, aunque quizás haya algún pequeño detalle que añadir para mejorar la reproducción.

Tras leer éste capítulo sabrá usted:

* Cómo configurar su sistema de modo que su tarjeta de sonido sea reconocida por el mismo.
* Confirmar el funcionamiento de su tarjeta usando herramientas de muestreo.
* Cómo enfrentarse a problemas de configuración de sonido.
* Cómo reproducir y crear ficheros MP3 y otros.
* Cómo gestiona el video el servidor X.
* Identificar unos cuantos ports para reproducir y codificar video que le darán muy buenos resultados.
* Cómo reproducir DVD y ficheros [.filename]#.mpg# y [.filename]#.avi#.
* Cómo convertir CD y DVD en ficheros de datos.
* Cómo configurar una tarjeta de TV.
* Cómo configurar un escáner de imágenes.

Antes de leer éste capítulo debería:

* Saber configurar e instalar un nuevo kernel (crossref:kernelconfig[kernelconfig,Configuración del kernel de FreeBSD]).

[WARNING]
====

Si intenta montar un cd con man:mount[8] provocará (como mínimo) un error en el sistema, pero puede llegar a provocar un _kernel panic_. Dichos soportes tienen codificaciones especiales sustancialmente diferentes de los típicos sistemas de ficheros ISO.
====

[[sound-setup]]
== Configuración de la tarjeta de sonido

[[sound-device]]
=== Configuración del sistema

Antes de nada tendrá que saber a ciencia cierta el modelo de tarjeta que tiene, qué chip utiliza y si es PCI o ISA. FreeBSD admite una amplia variedad de tarjetas, tanto PCI como ISA. Consulte la lista de dispositivos de sonido que puede usar en FreeBSD en las link:{u-rel120-hardware}[Hardware Notes]. Las «Hardware Notes» le dirán también qué controlador es el que hace funcionar su tarjeta.

Para poder usar su dispositivo de sonido en FreeBSD tiene que cargar el controlador de dispositivo adecuado, cosa que puede hacerse de dos maneras. La forma más fácil es cargar el módulo del kernel correspondiente a su tarjeta de sonido mediante man:kldload[8]. Puede hacerlo en su shell con la siguiente orden

[source,shell]
....
# kldload snd_emu10k1
....

o añadiendo la línea apropiada al fichero [.filename]#/boot/loader.conf#:

[.programlisting]
....
snd_emu10k1_load="YES"
....

Ambos ejemplos son para una tarjeta de sonido Creative SoundBlaster(R) Live!. Encontrará una lista de módulos de sonido que puede cargar del mismo modo en [.filename]#/boot/defaults/loader.conf#. Si no está del todo seguro sobre el controlador que debe usar pruebe con el módulo [.filename]#snd_driver#:

[source,shell]
....
# kldload snd_driver
....

Se trata de un «metacontrolador» que carga en memoria todos los controladores más habituales. De este modo acelerará notablemente el proceso de detectar cuál es el controlador perfecto para su hardware. También puede cargar todos los controladores de sonido desde [.filename]#/boot/loader.conf#.

Si quiere saber qué controlador se corresponde con su tarjeta de sonido una vez cargado el «metadriver» [.filename]#snd_driver# debe comprobar el contenido de [.filename]#/dev/sndstat# mediante la orden `cat /dev/sndstat`.

El segundo método es compilar de forma estática el soporte para su tarjeta de sonido dentro de un kernel personalizado. En la siguiente sección encontrará la información necesaria para añadir a su kernel el soporte que necesita su hardware. Para más información sobre la compilación de un kernel consulte el crossref:kernelconfig[kernelconfig,Configuración del kernel de FreeBSD].

==== Configuración de un kernel personalizado con soporte de sonido

Lo primero que hay que hacer es añadir el controlador del «framework» de sonido man:sound[4] al kernel; tendrá que añadir la siguiente línea a su fichero de configuración del kernel:

[.programlisting]
....
device sound
....

Una vez hecho esto tiene que añadir el soporte para su tarjeta de sonido. Evidentemente tendrá que saber exactamente qué controlador es el que hace funcionar su tarjeta. Consulte la lista de dispositivos de sonido soportados que encontrará en las link:{u-rel120-hardware}[Hardware Notes] y elija el controlador perfecto para su tarjeta. Por ejemplo una una tarjeta de sonido Creative SoundBlaster(R) Live! usará el controlador man:snd_emu10k1[4]. Siguiendo con el ejemplo, si queremos añadir soporte para esta tarjeta agregaremos lo siguiente:

[.programlisting]
....
device snd_emu10k1
....

Por favor, lea la página de manual del controlador si tiene dudas con la sintaxis. La sintaxis específica para la configuración en el kernel de cada tarjeta de sonido soportada existente puede encontrarse también en [.filename]#/usr/src/sys/conf/NOTES#.

Las tarjetas ISA no PnP pueden requerir que se le facilite al kernel la información de la configuración de la tarjeta (IRQ, puerto de E/S, etc). Esto se hace modificando el fichero [.filename]#/boot/device.hints#. Durante el proceso de arranque man:loader[8] leerá este fichero y le pasará los parámetros al kernel. Veamos un ejemplo: una vieja tarjeta Creative SoundBlaster(R) 16 ISA no PnP utilizará el controlador man:snd_sbc[4] junto con `snd_sb16`. En el caso de esta tarjeta habrá que añadir las siguientes líneas al fichero de configuración del kernel

[.programlisting]
....
device snd_sbc
device snd_sb16
....

y añadir lo siguiente a [.filename]#/boot/device.hints#:

[.programlisting]
....
hint.sbc.0.at="isa"
hint.sbc.0.port="0x220"
hint.sbc.0.irq="5"
hint.sbc.0.drq="1"
hint.sbc.0.flags="0x15"
....

La tarjeta del ejemplo usa el puerto de E/S `0x220` I/O port y la IRQ `5`.

La sintaxis a utilizar en [.filename]#/boot/device.hints# se explica en la página de manual de man:sound[4] y en la del controlador en cuestión.

En el ejemplo se muestran los parámetros por omisión. En ciertos casos habrá que usar otra IRQ o usar otros parámetros para hacer funcionar la tarjeta de sonido. Consulte la página de manual de man:snd_sbc[4] para más información sobre esta tarjeta.

[[sound-testing]]
=== Cómo probar su tarjeta de sonido

Una vez que haya reiniciado con su kernel personalizado, o tras cargar el mólo del kernel necesario la tarjeta de sonido aparecerá en el búfer de mensajes del sistema (man:dmesg[8]); deberí ser algo muy parecido a esto:

[source,shell]
....
pcm0: <Intel ICH3 (82801CA)> port 0xdc80-0xdcbf,0xd800-0xd8ff irq 5 at device 31.5 on pci0
pcm0: [GIANT-LOCKED]
pcm0: <Cirrus Logic CS4205 AC97 Codec>
....

Puede comprobar el estado de la tarjeta de sonido en el fichero [.filename]#/dev/sndstat#:

[source,shell]
....
# cat /dev/sndstat
FreeBSD Audio Driver (newpcm)
Installed devices:
pcm0: <Intel ICH3 (82801CA)> at io 0xd800, 0xdc80 irq 5 bufsz 16384
kld snd_ich (1p/2r/0v channels duplex default)
....

El resultado en su sistema seguramente será distinto. Si no aparecen dispositivos [.filename]#pcm# revise todo el proceso a ver dónde está el error. Revise su fichero de configuración del kernel nuevamente y compruebe que eligió el controlador de dispositivo adecuado. Tiene una lista de problemas habituales en la <<troubleshooting>>.

Si todo ha ido bien ya tiene una tarjeta de sonido funcionando en su sistema. Si los pins de salida de sonido de su CD-ROM o DVD-ROM están colocados correctamente puede poner un CD en la unidad y reproducirlo con man:cdcontrol[1].

[source,shell]
....
% cdcontrol -f /dev/acd0 play 1
....

Hay muchas aplicaciones como package:audio/workman[] que le ofrecerán un interfaz más amigable. Si quiere escuchar ficheros MP3 puede instalar, por ejemplo, package:audio/mpg123[].

Hay otra via aún más rápida de probar su tarjeta de sonido. Envíe datos a to [.filename]#/dev/dsp# del siguiente modo:

[source,shell]
....
% cat fichero > /dev/dsp
....

donde [.filename]#fichero# puede ser cualquier fichero. Esta orden producirá ruido, lo que confirmará que la tarjeta de sonido funciona.

Puede manejar los niveles de la tarjeta de sonido con man:mixer[8]. Tiene todos los detalles en la página de manual de man:mixer[8].

[[troubleshooting]]
==== Problemas habituales

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Error
| Solution

|`sb_dspwr(XX) timed out`
|

El puerto de E/S no ha sido configurado correctamente.

|`bad irq XX`
|

No ha elegido correctamente la IRQ. Asegúrese de que la IRQ que ha elegido y la IRQ del sonido son la misma.

|`xxx: gus pcm not attached, out of memory`
|

No queda memoria suficiente en el sistema para poder usar el dispositivo.

|`xxx: can't open /dev/dsp!`
|

Compruebe si hay otra aplicación utilizando (y por tanto ocupando) el dispositivo. Escriba `fstat \| grep dsp`. Los sospechosos habituales son esound y el sistema de sonido de KDE. 
|===

[[sound-multiple-sources]]
=== Cómo utilizar múltiples fuentes de sonido

Disponer de múltiples fuentes de sonido puede ser muy útil, por ejemplo cuando esound o artsd no permiten compartir el dispositivo de sonido con otra aplicación.

FreeBSD permite hacerlo gracias a los _Virtual Sound Channels_ (`canales virtuales de sonido`), que se activan mediante man:sysctl[8]. Los canales virtuales permiten multiplexar la reproducción de sonido de su tarjeta mezclando el sonido en el kernel.

El número de canales virtuales se configura utilizando dos sysctl; como `root` escriba lo siguiente:

[source,shell]
....
# sysctl hw.snd.pcm0.vchans=4
# sysctl hw.snd.maxautovchans=4
....

En el ejemplo anterior se han creado cuatro canales virtuales, una cantidad muy razonable para el uso normal. `hw.snd.pcm0.vchans` es el número de canales virtuales de que dispone [.filename]#pcm0#; puede configurarlo en cuanto el dispositivo sea reconocido por el sistema. `hw.snd.maxautovchans` es el número de canales virtuales que se le asignan a un nuevo dispositivo de audio cuando se conecta al sistema mediante man:kldload[8]. Puesto que el módulo [.filename]#pcm# puede cargarse independientemente de los controladores de hardware `hw.snd.maxautovchans` puede almacenar cuántos canales virtuales tienen asignados los dispositivos que se vayan conectando al sistema.

[NOTE]
====
No es posible modificar el número de canales virtuales de un dispositivo que esté en marcha. Cierre antes todos los programas que estén utilizando el dispositivo, como reproductores de música o dæmons de sonido.
====

Si no usa man:devfs[5] tendrá que configurar sus aplicaciones para que apunten a [.filename]#/dev/dsp0#._x_, donde _x_ es un número entre 0 y 3 si `hw.snd.pcm.0.vchans` tiene un valor de 4 como en el ejemplo anterior. Si se estuviera usando man:devfs[5] en el ejemplo anterior cualquier programa que pidiera [.filename]#/dev/dsp0# sería atendido de forma totalmente transparente.

=== Asignación a los canales de mezcla de valores por omisión

Los valores por defecto de los distintos canales de mezcla están fijados en el código del controlador man:pcm[4]. Hay distintas aplicaciones y dæmons que le permitirán asignar valores al mezclador y que permanezcan entre uso y uso, pero no es una solución demasiado limpia. Puede asignar valores por omisión a las mezclas a nivel de controlador definiendo los valores apropiados en [.filename]#/boot/device.hints#. Veamos un ejemplo:

[.programlisting]
....
hint.pcm.0.vol="50"
....

Esto asignará al canal de volumen un valor por omisión de 50 al cargar el módulo man:pcm[4].

[[sound-mp3]]
== Sonido MP3

El formato MP3 (MPEG Layer 3 Audio) llega casi al nivel de calidad del CD, por lo que no hay motivo por el deba faltar en su escritorio FreeBSD.

[[mp3-players]]
=== Reproductores de MP3

El reproductor de MP3 para X11 más extendido es, de lejos, XMMS (X Multimedia System). Puede usar en él «skins»de Winamp puesto que el interfaz gráfico de XMMS es casi idéntico al de Nullsoft Winamp. XMMS incluye también soporte nativo para «plug-ins».

Puede instalar XMMS como port (package:multimedia/xmms[]) o como package.

La interfaz de XMMS es intuitiva e incluye una lista de reproducción, un ecualizador gráfico y muchas otras cosas. Si está acostumbrado a WinampXMMS le será muy fácil de usar.

El port package:audio/mpg123[] es un reproductor MP3 que se usa desde la shell.

Puede especificarle desde la misma línea de órdenes a mpg123 el dispositivo de sonido que debe usar y el fichero MP3 que debe reproducir. Veamos un ejemplo:

[source,shell]
....
# mpg123 -a /dev/dsp1.0 ASaber-GrandesÉxitos.mp3
High Performance MPEG 1.0/2.0/2.5 Audio Player for Layer 1, 2 and 3.
Version 0.59r (1999/Jun/15). Written and copyrights by Michael Hipp.
Uses code from various people. See 'README' for more!
THIS SOFTWARE COMES WITH ABSOLUTELY NO WARRANTY! USE AT YOUR OWN RISK!

Playing MPEG stream from ASaber-GrandesÉxitos.mp3 ...
MPEG 1.0 layer III, 128 kbit/s, 44100 Hz joint-stereo
....

Sustituya [.filename]#/dev/dsp1.0# por el dispositivo [.filename]#dsp# que haya en su sistema.

[[rip-cd]]
=== Extracción de pistas de sonido de un CD

Antes de convirtir una pista o todo un CD a MP3 la información sonido debe volcarse al disco duro. Esto se hace convirtiendo los datos «raw CDDA» (CD Digital Audio) a ficheros WAV.

La herramienta `cdda2wav`, que forma parte del port package:sysutils/cdrtools[], permite la extracción de información de sonido en CD así como la información asociada a él.

Con el CD en la unidad la siguiente orden (como `root`) un CD entero en ficheros WAV individuales, uno por pista:

[source,shell]
....
# cdda2wav -D 0,1,0 -B
....

cdda2wav soporta unidades CDROM ATAPI (IDE). En el caso de unidades IDE especifique el número de dispositivo en el lugar correspondiente al núro de unidad SCSI. Por ejemplo, para extraer la pista 7 desde una unidad IDE:

[source,shell]
....
# cdda2wav -D /dev/acd0 -t 7
....

La opción `-D _0,1,0_` indica el dispositivo SCSI [.filename]#0,1,0#, que corresponde con la salida de `cdrecord -scanbus`.

Para extraer pistas de forma selectiva use la opción `-t`:

[source,shell]
....
# cdda2wav -D 0,1,0 -t 7
....

Esta opción extrae la séptima pista de un CDROM de sonido. Si quiere extraer un rango de pistas, por ejemplo las pistas de la uno a la siete, declare el rango del siguiente modo:

[source,shell]
....
# cdda2wav -D 0,1,0 -t 1+7
....

La herramienta man:dd[1] le permite también extraer pistas de sonido desde unidades ATAPI; consulte la crossref:disks[duplicating-audiocds,Copiar CD de audio] para más información.

[[mp3-encoding]]
=== Codificación de MP3

Hoy por hoy el codificador de MP3 por antonomasia es lame. Puede encontrar lame en package:audio/lame[].

Partiendo de ficheros WAV previamente extraidos la siguiente orden convierte [.filename]#audio01.wav# en [.filename]#audio01.mp3#:

[source,shell]
....
# lame -h -b 128 \
--tt "Título de copla o cantar" \
--ta "Grupo, solista o coral sinfónica" \
--tl "Título del álbum" \
--ty "2001" \
--tc "Autor de la extracción y paso a MP3" \
--tg "Estilo" \
audio01.wav audio01.mp3
....

Los 128 kbits pasan por se el estándar de ratio de bits de los MP3, aunque puede que usted sea de los que prefieren calidades más altas, 160 o incluso 192. A mayor ratio de bits, más espacio en disco necesitará, aunque la calidad también será mayor. La opción `-h` usa el modo «más calidad pero algo más lento». Las opciones que empiezan por `--t` indican etiquetas ID3, que suelen contener información de la canción que contiene el fichero MP3. Tiene información sobre otras opciones de codificación en la página de manual de lame.

[[mp3-decoding]]
=== Decodificación de MP3

Para grabar un CD de sonido desde ficheros MP3 hay que convertirlos a formato WAV no comprimido. Tanto XMMS como mpg123 soportan la conversión de MP3 a un formato de fichero no comprimido.

Escritura a disco desde XMMS:

[.procedure]
. Arranque XMMS.
. Botón derecho del raón en la ventana para acceder al menú de XMMS.
. Elija `Preferences` en `Options`.
. Cambie el «Output Plugin» a «Disk Writer Plugin».
. Pulse `Configure`.
. Elija un directorio en el que guardar los ficheros descomprimidos.
. Cargue el fichero MP3 en XMMS de la forma habitual, pero asegúrese de tener el volumen al 100% y las opciones de ecualización desactivadas.
. Pulse `Play` - parecerá que XMMS está reproduciendo música pero no sonará nada. Lo que está haciendo es volcar el MP3 a un fichero.
. Recuerde que antes de poder volver a escuchar ficheros MP3 de nuevo tendrá que devolver el «Plugin de salida» por omisión a la posición inicial.

Escritura de la salida estándar en mpg123:

[.procedure]
. Ejecute `mpg123 -s audio01.mp3 > audio01.pcm`

XMMS genera un fichero WAV, mientras que mpg123 convierte MP3 a datos de sonido raw PCM. Puede usar cdrecord con ambos formatos para crear CD de sonido. Tendrá que usar man:burncd[8] para raw PCM. Si lo que tiene son ficheros WAV escuchará un ligero clic al principio de cada pista: se trata de la cabecera del fichero WAV. Puede eliminar esta cabecera mediante SoX (que puede instalar como port desde package:audio/sox[] o si lo prefiere como package):

[source,shell]
....
% sox -t wav -r 44100 -s -w -c 2 pista.wav pista.raw
....

Consulte la crossref:disks[creating-cds,Creación y uso de medios ópticos (CD)] para más información sobre el uso de grabadoras de CD en FreeBSD.

[[video-playback]]
== Reproducción de vídeo

La reproducción de vídeo es un área muy nueva y en la que se producen grandes cambios a gran velocidad. Tenga paciencia. Aquí no va a ser todo tan sencillo como al configurar el sonido.

Antes de comenzar es imprescindible que sepa con certeza cuál es el modelo de su tarjeta gráfica y qué chip usa. Tanto Xorg como XFree86(TM) soportan gran cantidad de tarjetas gráficas, pero de pocas se puede decir que den un buen rendiemiento de reproducción. Puede consultar una lista de extensiones que el servidor X puede hacer funcionar en su tarjeta ejecutando man:xdpyinfo[1] desde una sesión X11.

Le recomendamos que tenga a mano un fichero MPEG no muy grande para usarlo en las pruebas que haga con los diversos reproductores y opciones. Algunos reproductores de DVD buscarán por omisión soportes DVD en [.filename]#/dev/dvd# (algunos incluso tienen fijado en el código el nombre de dicha unidad) seguramente le resultará útil ejecutar los siguientes enlaces simbólicos:

[source,shell]
....
# ln -sf /dev/acd0 /dev/dvd
# ln -sf /dev/acd0 /dev/rdvd
....

Tenga en cuenta que debido al diseño de man:devfs[5] los enlaces creados a mano no sobrevivirán a un reinicio del sistema. Para que así suceda tras cada reinicio debe añadir las siguientes líneas a [.filename]#/etc/devfs.conf#:

[.programlisting]
....
link acd0 dvd
link acd0 rdvd
....

Además, el descifrado de DVD (una tarea que hará necesario llamar a funciones especiales de los DVD-ROM) requiere permisos de escritura en unidades DVD.

Le recomendamos que aumente la memoria compartida del interfaz X11, para lo cual tendrá que incremente los valores asignados a varias man:sysctl[8]:

[.programlisting]
....
kern.ipc.shmmax=67108864
kern.ipc.shmall=32768
....

[[video-interface]]
=== Cómo determinar las características de video

Hay varias formas de reproducir vídeo en X11, pero cuál de ellas sea la que funcione depende en gran medida del hardware que intervenga. Cada uno de los métodos que se describen más son mejores o peores según en qué hardware se ejecute. Además el procesamiento de video en X11 es un asunto que está recibiendo mucha atención últimamente y en cada nueva versión de Xorg y de XFree86(TM) no es extraño encontrar avances significativos.

Veamos una lista de interfaces de vídeo muy comunes:

. X11: salida normal de X11 utilizando memoria compartida.
. XVideo: una extensión del interfaz X11 que permite la reproducción de vídeo en las ventanas de X11.
. SDL: Simple Directmedia Layer.
. DGA: Direct Graphics Access (`acceso directo a gráficos`.
. SVGAlib: capa de consola de gráficos a bajo nivel.

[[video-interface-xvideo]]
==== XVideo

Xorg y XFree86(TM) 4.X tienen una extensión llamada _XVideo_ (también conocida como Xvideo, Xv o xv) que permite reproducir vídeo en ventanas del sistema X11 a través de un tipo de aceleración especial. Dicha extensión ofrece una calidad de reproducción muy alta incluso en máquinas muy cortas de recursos.

Utilice `xvinfo` para saber qué extensión está utilizando:

[source,shell]
....
% xvinfo
....

XVideo is supported for your card if the result looks like:

[source,shell]
....
X-Video Extension version 2.2
screen #0
  Adaptor #0: "Savage Streams Engine"
    number of ports: 1
    port base: 43
    operations supported: PutImage
    supported visuals:
      depth 16, visualID 0x22
      depth 16, visualID 0x23
    number of attributes: 5
      "XV_COLORKEY" (range 0 to 16777215)
              client settable attribute
              client gettable attribute (current value is 2110)
      "XV_BRIGHTNESS" (range -128 to 127)
              client settable attribute
              client gettable attribute (current value is 0)
      "XV_CONTRAST" (range 0 to 255)
              client settable attribute
              client gettable attribute (current value is 128)
      "XV_SATURATION" (range 0 to 255)
              client settable attribute
              client gettable attribute (current value is 128)
      "XV_HUE" (range -180 to 180)
              client settable attribute
              client gettable attribute (current value is 0)
    maximum XvImage size: 1024 x 1024
    Number of image formats: 7
      id: 0x32595559 (YUY2)
        guid: 59555932-0000-0010-8000-00aa00389b71
        bits per pixel: 16
        number of planes: 1
        type: YUV (packed)
      id: 0x32315659 (YV12)
        guid: 59563132-0000-0010-8000-00aa00389b71
        bits per pixel: 12
        number of planes: 3
        type: YUV (planar)
      id: 0x30323449 (I420)
        guid: 49343230-0000-0010-8000-00aa00389b71
        bits per pixel: 12
        number of planes: 3
        type: YUV (planar)
      id: 0x36315652 (RV16)
        guid: 52563135-0000-0000-0000-000000000000
        bits per pixel: 16
        number of planes: 1
        type: RGB (packed)
        depth: 0
        red, green, blue masks: 0x1f, 0x3e0, 0x7c00
      id: 0x35315652 (RV15)
        guid: 52563136-0000-0000-0000-000000000000
        bits per pixel: 16
        number of planes: 1
        type: RGB (packed)
        depth: 0
        red, green, blue masks: 0x1f, 0x7e0, 0xf800
      id: 0x31313259 (Y211)
        guid: 59323131-0000-0010-8000-00aa00389b71
        bits per pixel: 6
        number of planes: 3
        type: YUV (packed)
      id: 0x0
        guid: 00000000-0000-0000-0000-000000000000
        bits per pixel: 0
        number of planes: 0
        type: RGB (packed)
        depth: 1
        red, green, blue masks: 0x0, 0x0, 0x0
....

Tenga en cuenta que los formatos que aparecen en el listado (YUV2, YUV12, etc) no aparecen en todas las implementaciones de de XVideo y su ausencia puede despistar a algunos reproductores.

Si el resultado se parece mucho a esto

[source,shell]
....
X-Video Extension version 2.2
screen #0
no adaptors present
....

lo más probable es que su tarjeta no soporte XVideo.

Si su tarjeta gráfica no soporta XVideo lo único que significa es que para su sistema será más complicado alcanzar los requisitos computacionales necesarios para el procesamiento de vídeo. Dependiendo de la tarjeta gráfica y el procesador que tenga es posible que de todos modos pueda salvar la papeleta. Consulte la sección sobre recursos avanzados en la <<video-further-reading>>.

[[video-interface-SDL]]
==== Simple Directmedia Layer

SDL (Simple Directmedia Layer) se creó pensando en una capa que permitiera aplicaciones fáciles de portar entre las plataformas Microsoft(R) Windows(R), BeOS y UNIX(R) y que permitiera al mismo tiempo un uso eficiente del sonido y el vídeo. La capa SDL ofrece abstracción de hardware a bajo nivel, lo que a veces puee ser más eficiente que la propia interfaz X11.

SDL está en package:devel/sdl12[].

[[video-interface-DGA]]
==== Direct Graphics Access

«Direct Graphics Access» es una extensión de X11 que permite que un programa sortée el servidor X y acceda directamente al «framebuffer». Utiliza memoria de bajo nivel, así es imprescindible que se ejecute como `root`.

Puede probar y analizar el rendimiento de la extensión DGA con man:dga[1]. Al ejecutar `dga` la pantalla cambia de color cada vez que pulsa una tecla. Para salir de la aplicación pulse kbd:[q].

[[video-ports]]
=== Ports y packages relacionados con el vídeo

Esta sección expone el software existente en la Colección de Ports de FreeBSD que puede usar para la reproducción de vídeo. La reproducción de vídeo es un área del desarrollo de software donde hay muchísima actividad, de manera que las características de más de una de las aplicaciones que vamos a describir pueden ser distintas.

Lo primero que hay que conocer es el importante detalle de que la mayoría de las aplicaciones de vídeo que funcionan en FreeBSD se desarrollaron para Linux. Muchas de esas aplicaciones todavía están en versiones beta. Estos son algunos de los problemas que puede encontrarse durante el uso de software de vídeo en FreeBSD:

. Una aplicación no puede reproducir un fichero que ha generado otra aplicación distinta.
. Una aplicación no puede reproducir un fichero que ella misma a generado.
. La misma aplicación ejecutándose en dos máquinas distintas, compilada en cada una de esas máquinas; la reproducción del mismo fichero da resultados diferentes.
. El uso de un filtro aparentemente trivial como es redimensionar una imagen aplicando una escala da como fruto un resultado horroroso debido a que la rutina encargada de aplicarla es defectuosa.
. Que una aplicación de volcados de memoria («core dumps»).
. La documentación no se instala con el port, pero sí que existe en la web o en el directorio [.filename]#work# del port.

La mayoría de estas aplicaciones muestra síntomas evidente de «Linuxismo», es decir, hay problemas derivados del modo en el que se implementan las bibliotecas en las distribuciones de Linux, o del hecho de que ciertas características del kernel de Linux han sido dadas por omnipresentes por los autores de las aplicaciones. Estos problemas no siempre han sido advertidas y solucionadas de algún modo por los responsables de los ports, lo que puede desembocar en problemas como:

. El uso de [.filename]#/proc/cpuinfo# para detectar las características del procesador.
. El uso erróneo de los hilos puede causar que ciertos programas se cuelguen al intentar cerrarse en lugar de cerrarse correctamente.
. Software que aún no está en la Colección de Ports de FreeBSD usado frecuentemente con la aplicación.

Hasta ahora los autores de las aplicaciones han colaborado de buen grado con los responsables de los ports para hacer más sencillo el trabajo de portar estas aplicaciones a FreeBSD.

[[video-mplayer]]
==== MPlayer

MPlayer es un reproductor de vídeo desarrollado muy recientemente y con un desarrollo rapidísimo. Los objetivos del equipo MPlayer son la velocidad y la flexibilidad en Linux y otros sistemas Unix. El proyecto comenzó cuando el fundador del equipo se cansó de padecer el pobre rendimiento de los reproductores de vídeo que había disponibles en ese momento. Hay quien dice que el interfaz gráfico fue sacrificado en pos de un diseño más ligero, aunque una vez que se acostumbre a las opciones desde la línea de órdenes y a los atajos de teclado todo irá como la seda.

[[video-mplayer-building]]
===== Compilación de MPlayer

Encontrará MPlayer en package:multimedia/mplayer[]. MPlayer ejecuta una serie de pruebas de hardware durante el proceso de compilación, dando como resultado un binario que no tiene por qué funcionar en otros sistemas. Recuerde, por tanto, compilar la aplicación como port y no utilice el package binario. Además hay múltiples parámetros que puede pasarle a `make`, tal y como verá al comenzar la compilación:

[source,shell]
....
# cd /usr/ports/multimedia/mplayer
# make
N - O - T - E

Take a careful look into the Makefile in order
to learn how to tune mplayer towards you personal preferences!
For example,
make WITH_GTK1
builds MPlayer with GTK1-GUI support.
If you want to use the GUI, you can either install
/usr/ports/multimedia/mplayer-skins
or download official skin collections from
http://www.mplayerhq.hu/homepage/dload.html
....

Las opciones por omisión del port deberían bastar para la mayoría de los usuarios, aunque si va a necesitar el codec XviD tendrá que especificar `WITH_XVID` en la línea de órdenes. La unidad de DVD por defecto se puede definir con la opción `WITH_DVD_DEVICE` si la opción por omisión, [.filename]#/dev/acd0#, no le sirve.

En el momento de escribir esto el port de MPlayer genera la documentación en formato HTML y dos ejecutables: `mplayer` y `mencoder`, que es una herramienta para recodificar vídeo.

La documentación en HTML de MPlayer es muy informativa. Si el lector no cubre todas sus dudas sobre hardware de vídeo e interfaces con el contenido de este capítulo la documentación de MPlayer es el sitio donde debe buscar. Si quiere más información sobre el soporte de vídeo en UNIX(R) el mejor sitio para consultar es, sin duda alguna, la documentación de MPlayer.

[[video-mplayer-using]]
===== Uso de MPlayer

Los usuarios de MPlayer deben crear un subdirectorio [.filename]#.mplayer# en su «home». Para crear este directorio (necesario para el funcionamiento de la aplicación) teclée lo siguiente:

[source,shell]
....
% cd /usr/ports/multimedia/mplayer
% make install-user
....

Las opciones de `mplayer` para la línea de órdenes se detallan en la página de manual. Si necesita todavía más detalles consulte la documentación en HTML. En esta sección se va a explicar solamente lo más básico.

Para reproducir el fichero [.filename]#ficherodeprueba.avi#, mediante una de las diversas interfaces de vídeo utilice la opción `-vo`:

[source,shell]
....
% mplayer -vo xv ficherodeprueba.avi
....

[source,shell]
....
% mplayer -vo sdl ficherodeprueba.avi
....

[source,shell]
....
% mplayer -vo x11 ficherodeprueba.avi
....

[source,shell]
....
# mplayer -vo dga ficherodeprueba.avi
....

[source,shell]
....
# mplayer -vo 'sdl:dga' ficherodeprueba.avi
....

Merece la pena que pruebe todas, puesto que el rendimiento relativo depende en gran medida de muchos factores y será muy distinto el resultado dependiendo del hardware.

Si quiere reproducir un DVD sustituya [.filename]#ficherodeprueba.avi# por `dvd://_N_ -dvd-device _DISPOSITIVO_`, donde _N_ es el número de título que quiere reproducir y [.filename]#DISPOSITIVO# es el nodo de dispositivo del DVD-ROM. Veamos un ejemplo: para reproducir el título 3 desde [.filename]#/dev/dvd# ejecutaremos:

[source,shell]
....
# mplayer -vo xv dvd://3 -dvd-device /dev/dvd
....

[NOTE]
====
La unidad de DVD por omisión puede definirse durante la compilación del port de MPlayer con la opción `WITH_DVD_DEVICE`. Por defecto apunta a [.filename]#/dev/acd0#. Tiene todos los detalles en el [.filename]#Makefile# del port.
====

Consulte los atajos de teclado para parar la reproducción, ponerla en pausa, etc. consulte la salida de `mplayer -h` o mejor aún lése la página de manual.

Hay otras opciones que le resultarán de interés para la reproducción: `-fs -zoom`, para la reproducción a pantalla completa y `-framedrop`, que mejora el rendimiento.

Para evitar que la línea de órdenes se haga demasiado larga puede crear un fichero [.filename]#.mplayer/config# e introducir en él las opciones que quiera usar desde el arranque de la aplicación:

[.programlisting]
....
vo=xv
fs=yes
zoom=yes
....

Para terminar, puede usar `mplayer` para extraer un título de un DVD a un fichero [.filename]#.vob#. Por ejemplo, si quiere extraer el segundo título de un DVD escriba esto:

[source,shell]
....
# mplayer -dumpstream -dumpfile salida.vob dvd://2 -dvd-device /dev/dvd
....

El fichero de salida, [.filename]#salida.vob#, un MPEG y puede manipularlo con las aplicaciones que se describen en esta sección.

[[video-mencoder]]
===== mencoder

Antes de empezar a usar `mencoder` le recomendamos que se familiarice con las opciones que se detallan en la documentación HTML. Hay también una página de manual, pero no es de mucha utilidad sin la documentación HTML. Hay una ingente cantidad de formas de mejorar la calidad, reducir el ratio de bits y cambiar formatos; alguno de esos pequeños trucos pueden marcar la diferencia entre un buen y un mal rendimiento. Le mostramos un par de ejemplos por los que puede empezar. El primero es una simple copia:

[source,shell]
....
% mencoder entrada.avi -oac copy -ovc copy -o salida.avi
....

Ciertas combinaciones erróneas de opciones en la línea de órdenes pueden dar como fruto un fichero de salida que no puede reproducir ni siquiera el propio `mplayer`, así que si lo que quiere es extraer datos a un fichero siga usando tranquilamente la opción `-dumpfile` de `mplayer`.

Para convertir [.filename]#entrada.avi# con codificación MPEG4 y audio con codificación MPEG3 (necesitará package:audio/lame[]):

[source,shell]
....
% mencoder entrada.avi -oac mp3lame -lameopts br=192 \
	 -ovc lavc -lavcopts vcodec=mpeg4:vhq -o salida.avi
....

El fichero de salida puede verse con `mplayer` y con `xine`.

Si sustituye [.filename]#entrada.avi# por `dvd://1 -dvd-device /dev/dvd` y lo ejecuta como `root` puede recodificar un título de DVD directamente. Es posible que el resultado no sea muy satisfactorio tras los primeros intentos, así que le recomendamos que vuelque el título a un fichero y haga todas las pruebas que necesite sobre ese fichero.

[[video-xine]]
==== El reproductor de vídeo xine

El reproductor de vídeo xine es un ambicioso proyecto que tiene como meta ofrecer no solamente una aplicación de vídeo «todo en uno», sino crear una biblioteca base reutilizable y un ejecutable modular que puede ampliarse mediante «plugins». Existe como package y también como port: package:multimedia/xine[].

El reproductor xine está todavía en mantillas, pero sus primeros pasos están siendo muy interesantes. xine requiere o una CPU rápida o una tarjeta gráfica, o bien soporte para la extensión XVideo. El GUI es intuitivo, aunque un tanto pedestre.

En el momento de escribir esto xine no incorpora ningún módulo de entrada que sirva para reproducir DVD codificados con CSS. Hay versiones compiladas por terceros que tienen módulos que lo permiten, pero ninguna de ellas está en la Colección de Ports de FreeBSD.

Comparado con MPlayerxine deja las cosas más hechas para el usuario, pero al mismo tiempo pone más difícil el control exhaustivo sobre todo lo que pasa. El reproductor xine da un mejor rendimiento en interfaces XVideo.

Por omisión xine arranca con un intefaz gráfico de usuario. Los menús pueden usarse para abrir un fichero en concreto:

[source,shell]
....
% xine
....

También puede invocar la aplicación desde la línea de órdenes para que reproduzca un fichero inmediatamente y sin utilizar el GUI:

[source,shell]
....
% xine -g -p fichero.avi
....

[[video-ports-transcode]]
==== Las herramientas transcode

transcode no es un reproductor, sino una suite de herramientas para recodificar (también se podría usar la palabra «transcodificar», de ahí su nombre) ficheros de sonido y de vídeo. Con transcode es posible fundir ficheros de video y reparar ficheros deteriorados desde la línea de órdenes y en las interfaces de flujo [.filename]#stdin/stdout#.

Puede configurar gran cantidad de opciones en el momento de la compilación de package:multimedia/transcode[]; le recomendamos que use la siguiente línea de órdenes para compilar transcode:

[source,shell]
....
# make WITH_OPTIMIZED_CFLAGS=yes WITH_LIBA52=yes WITH_LAME=yes WITH_OGG=yes \
WITH_MJPEG=yes -DWITH_XVID=yes
....

La configuración que le proponemos deberí satisfacer a la mayoría de los usuarios.

Veamos un ejemplo ilustrativo de las posibilidades de `transcode`: convertir un fichero DivX en un fichero PAL MPEG-1 (PAL VCD):

[source,shell]
....
% transcode -i input.avi -V --export_prof vcd-pal -o output_vcd
% mplex -f 1 -o output_vcd.mpg output_vcd.m1v output_vcd.mpa
....

Puede reproducir el fichero MPEG resultante, [.filename]#output_vcd.mpg#, con MPlayer. Si quiere también puede grabar el fichero en un CD-R y tendrá un VideoCD, aunque para eso tendrá que instalar package:multimedia/vcdimager[] y package:sysutils/cdrdao[].

Consulte la página de manual de `transcode`, pero no olvide consultar también el http://www.transcoding.org/cgi-bin/transcode[wiki de transcode], en el que encontrará más información y muchos ejemplos.

[[video-further-reading]]
=== Lecturas adicionales

El desarrollo de las diversas aplicaciones de vídeo disponibles en FreeBSD avanza rápidamente. Es muy posible que en un futuro cercano la mayoría de los problemas de los que hemos hablado aquí hayan sido resueltos. Mientras tanto quien quiera exprimir las capacidades de FreeBSD en las áreas del sonido y el vídeo tendrán que recopilar la información repartida en varias FAQ y tutoriales y utilizar unos cuantos programas diferentes. En esta sección se le proponen al lector interesado varias fuentes de información adicional.

La http://www.mplayerhq.hu/DOCS/[documentación de MPlayer] contiene una gran cantidad de información técnica. Cualquiera que quiera alcanzar un alto grado de conocimiento en vídeo sobre UNIX(R) debe consultar esa documentación. La lista de correo de MPlayer es sumamente hostil hacia quien no se ha molestado en leer la documentación _antes_ de preguntar, así que si va a enviar informes de errores a esa lista, por favor, _léase la documentación._.

El texto http://dvd.sourceforge.net/xine-howto/en_GB/html/howto.html[ xine HOWTO] contiene un capítulo sobre mejora del rendimiento que afecta a todos los reproductores.

Hay unas cuantas aplicaciones muy prometedoras que el lector debería al menos probar:

* http://avifile.sourceforge.net/[Avifile], que encontrará en los ports:package:multimedia/avifile[].
* http://www.dtek.chalmers.se/groups/dvd/[Ogle], también en la colección de ports: package:multimedia/ogle[].
* http://xtheater.sourceforge.net/[Xtheater]
* package:multimedia/dvdauthor[], una aplicación libre para la producción de contenidos en DVD.

[[tvcard]]
== Configuración de tarjetas de TV

=== Introducción

Las tarjetas de TV le permiten ver en su sistema emisiones de TV tradicionales o incluso por cable. La mayoría aceptan vídeo compuesto mediante RCA o una entrada de S-video; algunas de estas tarjetas incorporan también un sintonizador de radio FM.

FreeBSD puede utilizar tarjetas de TV PCI que tengan el chip Brooktree Bt848/849/878/879 o el chip de captura de vídeo Conexant CN-878/Fusion 878a gracias al controlador man:bktr[4]. Asegúrese de que la tarjeta tiene un sintonizador que esté soportado: consulte la lista de sintonizadores soportados que encontrará en la página de manual de man:bktr[4].

=== Añadir el controlador

Poder usar la tarjeta tendrá que cargar el controlador man:bktr[4]. Una forma de hacerlo es añdir la siguiente línea al fichero [.filename]#/boot/loader.conf#:

[.programlisting]
....
bktr_load="YES"
....

También puede hacerlo compilando estáticamente el soporte para la tarjeta de TV en su kernel; añada las siguientes líneas al fichero de configuración de su kernel:

[.programlisting]
....
device	 bktr
device	iicbus
device	iicbb
device	smbus
....

Es necesario incluir todas esas lineas adicionales porque los componentes de la tarjeta están conectados entre sí por un bus I2C. Hecho esto compile e instale su nuevo kernel.

Una vez añadido el soporte de la tarjeta al sistema tendrá que reiniciar. Durante el arranque deberían aparecer rastros de su tarjeta de TV. Veamos un ejemplo:

[.programlisting]
....
bktr0: <BrookTree 848A> mem 0xd7000000-0xd7000fff irq 10 at device 10.0 on pci0
iicbb0: <I2C bit-banging driver> on bti2c0
iicbus0: <Philips I2C bus> on iicbb0 master-only
iicbus1: <Philips I2C bus> on iicbb0 master-only
smbus0: <System Management Bus> on bti2c0
bktr0: Pinnacle/Miro TV, Philips SECAM tuner.
....

Es obvio que estos mensajes serán distintos según sea el hardware del que se trate. Asegúrese de que el sistema detecta correctamente el sintonizador. Se puede sobreescribir alguno de los parámetros detectados por el sistema mediante MIB man:sysctl[8] y opciones del fichero de configuración del kernel. Si por ejemplo quiere obligar al sintonizador para que se comporte como un Phillips SECAM añada lo siguiente al fichero de configuración de su kernel:

[.programlisting]
....
options OVERRIDE_TUNER=6
....

Puede utilizar directamente man:sysctl[8]:

[source,shell]
....
# sysctl hw.bt848.tuner=6
....

Consulte en man:bktr[4] y en [.filename]#/usr/src/sys/conf/NOTES# si necesita más detalles sobre las opciones disponibles.

=== Aplicaciones útiles

Tendrá que instalar una de estas aplicaciones para poder utilizar su tarjeta de TV:

* package:multimedia/fxtv[] ofrece «TV en una ventana» y captura de imagen/sonido/vídeo.
* package:multimedia/xawtv[]: otra aplicación de TV; ofrece lo mismo que fxtv.
* package:misc/alevt[] decodifica y reproduce videotexto y teletexto.
* package:audio/xmradio[] permite utilizar el sintonizador de radio FM que incorporan algunas tarjetas de TV.
* package:audio/wmtune[], una aplicación de escritorio muy útil para el uso de sintonizadores de radio.

Hay más aplicaciones útiles en la Colección de de Ports de FreeBSD.

=== Solución de problemas

Si tiene algún problema con su tarjeta de TV compruebe en primer lugar que el chip de captura de vídeo y el sintonizador realmente funcionan con el controlador man:bktr[4] y si ha utilizado las opciones de configuración más adecuadas. Si necesita más ayuda o necesita respuestas sobre su tarjeta de TV puede recurrir a la lista de correo {freebsd-multimedia}.

[[scanners]]
== Escáneres de imágenes

=== Introducción

El acceso a escáneres de imágenes en FreeBSD funciona gracias a la APISANE (siglas de «Scanner Access Now Easy», «el acceso a escáneres ahora es fácil»), disponible en la Colección de Ports de FreeBSD. SANE utiliza también ciertos controladores de FreeBSD para acceder al hardware del escáner.

FreeBSD puede utilizar tanto escáneres SCSI como USB. Asegúrese de que el suyo funciona con SANE antes de intentar ningún tipo de configuración. SANE tiene una lista de http://www.sane-project.org/sane-supported-devices.html[dispositivos soportados] donde encontrará información actualizada sobre hasta dónde funciona el escáner y su estatus. La página de manual de man:uscanner[4] incluye una listas de escáneres USB que funcionan con SANE.

=== Configuración del kernel

Como ya se ha dicho tanto los interfaces USB como las SCSI funcionan. Según sea el interfaz de su escáner necesitará un tipo diferente de controlador:

[[scanners-kernel-usb]]
==== Interfaz USB

El kernel [.filename]#GENERIC# incluye por omisión los controladores de dispositivo necesarios para poder usar escáneres USB. Si va a personalizar su kernel asegúrese de que esto está en el fichero de configuración del mismo:

[.programlisting]
....
device usb
device uhci
device ohci
device uscanner
....

Según cual sea el chipset de su placa base tendrá que usar `device uhci` o `device ohci`, aunque si tiene ambos no tendrá problemas por eso.

Si por cualquier motivo no quiere recompilar su kernel y su kernel no es el [.filename]#GENERIC# puede cargar el módulo controlador de dispositivo man:uscanner[4] con man:kldload[8]:

[source,shell]
....
# kldload uscanner
....

Si quiere cargar este módulo cada vez que arranque el sistema debe añadir la siguiente línea a [.filename]#/boot/loader.conf#:

[.programlisting]
....
uscanner_load="YES"
....

Tras reiniciar con el kernel correcto (o una vez que el módulo esté cargado) conecte su escáner USB. Debe aparecer en el «buffer» de mensajes del sistema (man:dmesg[8]) un mensaje una línea como la siguiente:

[source,shell]
....
uscanner0: EPSON EPSON Scanner, rev 1.10/3.02, addr 2
....

La línea del ejemplo muestra que nuestro escáner está utilizando el nodo de dispositivo [.filename]#/dev/uscanner0#.

==== Interfaz SCSI

Si su escáner tiene un interfaz SCSI es importante saber qué controladora SCSI incorpora. El chipset SCSI que tenga influirá en la configuración del kernel que tenga que personalizar. El kernel [.filename]#GENERIC# tiene controladores de dispositivo para las controladoras SCSI más comunes. Consulte el fichero [.filename]#NOTES# y añada la línea correcta al fichero de configuración de su kernel. Tendrá que añadir también la siguiente línea:

[.programlisting]
....
device scbus
device pass
....

Una vez compilado e instalado el kernel correctamente tiene ya que ver sus nuevos dispositivos en el «buffer» de mensajes del sistema:

[source,shell]
....
pass2 at aic0 bus 0 target 2 lun 0
pass2: <AGFA SNAPSCAN 600 1.10> Fixed Scanner SCSI-2 device
pass2: 3.300MB/s transfers
....

Si su escáner estaba apagado durante el arranque puede forzar manualmente la detección si ejecuta una búsqueda de buses SCSI con man:camcontrol[8]:

[source,shell]
....
# camcontrol rescan all
Re-scan of bus 0 was successful
Re-scan of bus 1 was successful
Re-scan of bus 2 was successful
Re-scan of bus 3 was successful
....

El escáner aparecerá en la lista de dispositivos SCSI:

[source,shell]
....
# camcontrol devlist
<IBM DDRS-34560 S97B>              at scbus0 target 5 lun 0 (pass0,da0)
<IBM DDRS-34560 S97B>              at scbus0 target 6 lun 0 (pass1,da1)
<AGFA SNAPSCAN 600 1.10>           at scbus1 target 2 lun 0 (pass3)
<PHILIPS CDD3610 CD-R/RW 1.00>     at scbus2 target 0 lun 0 (pass2,cd0)
....

Tiene todos los detalles sobre los dispositivos SCSI en las páginas de manual de man:scsi[4] y man:camcontrol[8].

=== Configuración de SANE

El sistema SANE se divide en dos partes: los «backends» (package:graphics/sane-backends[]) y los «frontends» (package:graphics/sane-frontends[]). Los «backends» facilitan el acceso al escáner propiamente dicho. La http://www.sane-project.org/sane-supported-devices.html[lista de dispositivos que funcionan con ]SANE le dirá qué «backend» hará funcionar su escáner de imágenes. No hay más remedio que identificar correctamente el «backend» de su escáner para poder usarlo. Los «frontends» ofrecen una interfaz gráfica para escanear (xscanimage).

Lo primero que hay que hacer es instalar el port o package de package:graphics/sane-backends[]. Después ejecute la orden `sane-find-scanner` para comprobar el funcionamiento de la detección de escáneres del sistema SANE:

[source,shell]
....
# sane-find-scanner -q
found SCSI scanner "AGFA SNAPSCAN 600 1.10" at /dev/pass3
....

En la salida de la orden anterior se le mostrará el tipo de interfaz del escáner y el nodo de dispositivo a través del cual el sistema accede a él. Es posible que no aparezcan la marca y el modelo, pero eso no tiene importancia.

[NOTE]
====
Algunos escáneres USB necesitan que les instale un «firmware»; esto se explica en la página de manual del «backend» correspondiente. También debe leer las páginas de manual man:sane-find-scanner[1] y man:linprocfs[7].
====

Ahora hay que comprobar que el «frontend» de escaneo puede identificar el escáner. Por omisión los «backends» de SANE incorporan una herramienta de línea de órdenes llamada man:sane[1], que le mostrará una lista de dispositivos e incluso una captura de imagen desde la shell. La opción `-L` muestra una lista de escáners:

[source,shell]
....
# scanimage -L
device `snapscan:/dev/pass3' is a AGFA SNAPSCAN 600 flatbed scanner
....

Si el software no lanza ningún mensaje, o si el mensaje indica que no se han encontrado escáneres significa que man:sane[1] no puede identificar su escáner. Si este es el caso tendrá que editar el fichero de configuración del «backend»y definir en él el escáner que quiera utilizar. Encontrará todos los ficheros de configuración de los «backends» en el directorio [.filename]#/usr/local/etc/sane.d/#. Este problema con la identificación del hardware es relativamente frecuente con ciertos modelos de escáneres USB.

Por ejemplo, con el escáner que hemos usado en la <<scanners-kernel-usb>> la orden `sane-find-scanner` nos da la siguiente información:

[source,shell]
....
# sane-find-scanner -q
found USB scanner (UNKNOWN vendor and product) at device /dev/uscanner0
....

El escáner ha sido detectado sin problemas, utiliza el interfaz USB y está conectado al nodo de dispositivo [.filename]#/dev/uscanner0# . Ahora comprobaremos que podemos identificar correctamente el escáner:

[source,shell]
....
# scanimage -L

No scanners were identified. If you were expecting something different,
check that the scanner is plugged in, turned on and detected by the
sane-find-scanner tool (if appropriate). Please read the documentation
which came with this software (README, FAQ, manpages).
....

No hemos podido identificar el escáner, así que hemos de editar el fichero [.filename]#/usr/local/etc/sane.d/epson.conf#. Estamos usando el modelo de escáner EPSON Perfection(R) 1650, así que ya sabemos que el escáner utilizará el «backend» `epson`. Lea atentamente los comentarios que hay en los ficheros de configuración de los «backends». Lo que hay que hacer es muy sencillo: basta con comentar las líneas en las que aparecen interfaces que no sean el perfecto para su escáner. En nuestro caso comentaremos todas las líneas que comiencen por `scsi` puesto que nuestro escáner tiene interfaz USB. Después de esto hay que añadir una lína al final del fichero declarando el interfaz y el nodo de dispositivo que se van a usar. En el caso del ejemplo esto es lo que añadimos:

[.programlisting]
....
usb /dev/uscanner0
....

Por favor, lea los comentarios que encontrará en el fichero de configuración del «backend» y la pángina de manual de del «backend» si necesita más información sobre la sintaxis que debe usar. Hecho esto podemos verificar si ya podemos identificar el escáner:

[source,shell]
....
# scanimage -L
device `epson:/dev/uscanner0' is a Epson GT-8200 flatbed scanner
....

Hemos identificado nuestro escáner USB. Ni tiene importancia si la marca y modelo que hemos visto no coinciden con nuestro escáner. Lo único realmente importante es el campo ``epson:/dev/uscanner0'`, que nos da el nombre correcto del «backend» y el nodo de dispositivo correcto.

Una vez que `scanimage -L` llega a ver al escáner hemos terminado con la configuración. El dispositivo está listo para escanear imángenes.

man:sane[1] permite ejecutar una captura de imágen desde la línea de órdenes, pero siempre es mejor utilizar un interfaz gráfico de usuario para estas tareas. SANE ofrece un interfaz gráfico simple pero eficiente: xscanimage (package:graphics/sane-frontends[]).

Otro «frontend» gráfico para escanear que se ha hecho muy popular es Xsane (package:graphics/xsane[]). Este «frontend» tiene características muy avanzadas como varios modos de escaneo (fotocopia, fax, etc.), corrección de color, escaneo de imágenes por lotes, etc. Ambas aplicaciones pueden utilizarse además como «plugins» de GIMP.

=== Dar acceso al escáner a otros usuarios

Todo lo que se ha mostrado en esta sección se ha ejecutado con privilegios de `root`. Lo normal es que haya otros usuarios que tengan que tener acceso al escáner. Un usuario que quiera usar el escáner tiene que tener acceso de lectura y escritura al nodo de dispositivo que usa el escáner. Por ejemplo, nuestro escáner USB utiliza el nodo de dispositivo [.filename]#/dev/uscanner0# propiedad del grupo `operator`. Al añadir al usuario `_joe_` al grupo `operator` éste podrá acceder al escáner:

[source,shell]
....
# pw groupmod operator -m joe
....

Para más información sobre el uso de man:pw[8] lea su página de manual. Tendrá también que configurar correctamente los permisos de escritura (0660 o 0664) en el nodo de dispositivo [.filename]#/dev/uscanner0#; por omisión los miembros del grupo `operator` sólo tienen acceso de lectura en este nodo de dispositivo. Añada las siguientes líneas al fichero lines to the [.filename]#/etc/devfs.rules#:

[.programlisting]
....
[system=5]
add path uscanner0 mode 660
....

Ahora añada lo siguiente a [.filename]#/etc/rc.conf# y reinicie la máquina:

[.programlisting]
....
devfs_system_ruleset="system"
....

Para más información sobre lo que acaba de leer consulte la página de manual de man:devfs[8].

[NOTE]
====
Por seguridad debería pensarse dos veces el hecho mismo de añadir cualquier usuario a un grupo y muy especialmente al grupo `operator`.
====
