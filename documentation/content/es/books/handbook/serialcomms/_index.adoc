---
title: Capítulo 24. Comunicaciones serie
part: Parte IV. Comunicaciones en red
prev: books/handbook/partiv
next: books/handbook/ppp-and-slip
---

[[serialcomms]]
= Comunicaciones serie
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:source-highlighter: rouge
:experimental:
:skip-front-matter:
:toc-title: Tabla de contenidos
:table-caption: Tabla
:figure-caption: Figura
:example-caption: Ejemplo
:xrefstyle: basic
:relfileprefix: ../
:outfilesuffix:
:sectnumoffset: 24

ifeval::["{backend}" == "html5"]
:imagesdir: ../../../images/books/handbook/serialcomms/
endif::[]

ifeval::["{backend}" == "pdf"]
:imagesdir: ../../../../static/images/books/handbook/serialcomms/
endif::[]

ifeval::["{backend}" == "epub3"]
:imagesdir: ../../../../static/images/books/handbook/serialcomms/
endif::[]

include::shared/authors.adoc[]
include::shared/releases.adoc[]
include::shared/es/mailing-lists.adoc[]
include::shared/es/teams.adoc[]
include::shared/es/urls.adoc[]

toc::[]

[[serial-synopsis]]
== Sinopsis

UNIX(R) siempre ha tenido soporte para comunicación serie. De hecho, las primeras máquinas UNIX(R) dependían de líneas serie para tener interacción con el usuario. Las cosas han cambiado mucho desde esos días cuando la "terminal" promedio consistía de una terminal serie de 10-caracteres-por-segundo, impresora y teclado. Este capítulo cubrirá algunas de las maneras en las que FreeBSD utiliza comunicaciones serie.

Despues de leer este capítulo, usted entenderá:

* Como conectar terminales a su sistema FreeBSD.
* Como utilizar un modem para marcar a equipos remotos.
* Como permitir a usuarios remotos entrar a su sistema con un modem.
* Como arrancar su sistema desde una consola serie.

Antes de leer este capítulo usted debería:

* Saber como configurar e instalar un nuevo kernel (crossref:kernelconfig[kernelconfig,Configuración del kernel de FreeBSD]).
* Entender procesos y permisos UNIX(R) (crossref:basics[basics,Conceptos básicos de Unix]).
* Tener acceso al manual técnico para el hardware serie (modem o tarjeta multipuerto) que le gustaría utilizar con FreeBSD.

[[serial]]
== Introducción

[[serial-terminology]]
=== Terminología

bps::
Bits por segundo - la tasa a la cual los datos son transmitidos

DTE::
Data Terminal Equipment (Equipo terminal de datos) - por ejemplo, su computadora

DCE::
Data Communications Equipment (Equipo de comunicación de datos) - su modem

RS-232::
Estándar EIA para hardware de comunicación serie

Cuando se habla de tasa de comunicación de datos, ésta sección no usa el término "baud". Baud se refiere al número de estados de transición eléctricos que pueden realizarse en un periodo de tiempo, mientras que "bps" (bits por segundo) es el término _correcto_ a usar (al menos parece no molestar demasiado a los más aferrados).

[[serial-cables-ports]]
=== Cables y puertos

Para conectar un modem o terminal a su sistema FreeBSD necesitará un puerto serie en su computadora y el cable apropiado para conectar a su dispositivo serie. Si ya está familiarizado con su hardware y el cable que requiere, puede saltarse esta sección.

[[term-cables]]
==== Cables

Existen diferentes tipos de cables serie. Los dos tipos más comunes para nuestros propósitos son cables null-modem y cables RS-232 estándar ("normal"). La documentación de su hardware debería describir el tipo de cable requerido.

[[term-cables-null]]
===== Cables null-modem

Un cable null-modem pasa algunas señales, como "tierra", normalmente, pero cambia otras señales. Por ejemplo, el pin "envío de datos" en un extremo va al pin "recepción de datos" en el otro.

Si le gusta fabricar sus propios cables, puede construir un cable null-modem para utilizar con terminales. Esta tabla muestra los nombres de señal y números de pin en un conector DB-25. 

[.informaltable]
[cols="1,1,1,1,1", frame="none", options="header"]
|===
| Señal
| Pin #
| 
| Pin #
| Señal

|SG
|7
|conecta a
|7
|SG

|TD
|2
|conecta a
|3
|RD

|RD
|3
|conecta to
|2
|TD

|RTS
|4
|conecta a
|5
|CTS

|CTS
|5
|conecta a
|4
|RTS

|DTR
|20
|conecta a
|6
|DSR

|DCD
|8
|
|6
|DSR

|DSR
|6
|conecta a
|20
|DTR
|===

[NOTE]
====
Conectar "Data Set Ready" (DSR) y "Data Carrier Detect" (DCD) intérnamente en la capucha del conector, y entonces a "Data Terminal Ready" (DTR) en la capucha remota.
====

[[term-cables-std]]
===== Cables estándard RS-232C

Un cable serie estándar pasa todas las señales RS-232C normalmente. Esto es, el pin "envío de datos" en un extremo va al pin "envío de datos" en el otro extremo. Este es el tipo de cable a utilizar para conectar un modem a su sistema FreeBSD, y también es apropiado para algunas terminales.

[[term-ports]]
==== Puertos

Puertos serie son los dispositivos a través de los cuales los datos son transferidos entre una computadora FreeBSD y la terminal. Esta sección describe los tipos de puertos que existen y como son referidos en FreeBSD.

[[term-portkinds]]
===== Tipos de puertos

Existen varios tipos de puertos serie. antes de comprar o construir un cable, necesita asegurarse que coincida con los puertos en su terminal y en su sistema FreeBSD.

La mayoría de las terminales tienen puertos DB25. Computadoras personales, incluyendo PCs corriendo FreeBSD, tienen puertos DB25 o DB9. Si tiene una tarjeta multipuertos serie para su PC, tal vez tenga puertos RJ-12 o RJ-45.

Vea la documentación que acompaña su hardware para las especificaciones sobre el tipo de puerto en uso. Una inspección visual del puerto también funciona en la mayoría de los casos.

[[term-portnames]]
===== Nombres de puerto

En FreeBSD, se accesa cada puerto serie a través de una entrada en el directorio [.filename]#/dev#. Existen dos tipos de entradas:

* Puertos de llamada-entrante son llamados [.filename]#/dev/ttydN# donde _N_ es el número de puerto, iniciando desde cero. Generalmente, los puertos de llamada-entrante se utilizan para terminales. Los puertos de llamada-entrante requieren que la línea serie especifique la señal data carrier detect (DCD) para funcionar correctamente.
* Puertos de llamada-saliente son llamados [.filename]#/dev/cuaaN#. Usualmente no se utilizan los puertos de llamada-saliente para terminales, solo para modems. Puede utilizar el puerto de llamada-saliente si el cable serie o la terminal no soporta la señal de carrier detect.

Si tiene conectada una terminal al primer puerto serie ([.filename]#COM1# en MS-DOS(R)), entonces usará [.filename]#/dev/ttyd0# para referirse a la terminal. Si la terminal está en el segundo puerto serie (también conocido como [.filename]#COM2#), utilice [.filename]#/dev/ttyd1#, y así sucesivamente. 

=== Configuración del kernel

FreeBSD soporta cuatro puertos serie por omisión. en el mundo MS-DOS(R) éstos son conocidos como [.filename]#COM1#, [.filename]#COM2#, [.filename]#COM3#, y [.filename]#COM4#. FreeBSD actualmente soporta tarjetas de interfaz serie "tontas", como la BocaBoard 1008 y 2016, así como tarjetas multipuerto más inteligentes como las fabricadas por Digiboard y Stallion Technologies. De cualquier manera, el kernel por omisión solo busca por los puertos COM estándares. 

Para ver si su kernel reconoce cualquiera de sus puertos serie, mire los mensajes mientras el kernel esta arrancando, o utilice el comando `/sbin/dmesg` para repetir los mensajes de arranque del kernel. En particular busque por mensajes que inicien con el caracter `sio`.

[TIP]
====

Para ver solamente los mensajes que contienen la palabra `sio`, use el comando:

[source,bash]
....
# /sbin/dmesg | grep 'sio'
....

====

Por ejemplo, en un sistema con cuatro puertos serie, éstos son los mensajes de arranque del kernel específicos de puerto serie:

[source,bash]
....
sio0 at 0x3f8-0x3ff irq 4 on isa
sio0: type 16550A
sio1 at 0x2f8-0x2ff irq 3 on isa
sio1: type 16550A
sio2 at 0x3e8-0x3ef irq 5 on isa
sio2: type 16550A
sio3 at 0x2e8-0x2ef irq 9 on isa
sio3: type 16550A
....

Si su kernel no reconoce todos sus puertos serie, probablemente necesitará configurar un kernel FreeBSD personalizado para su sistema. Para información detallada sobre configurar su kernel, por favor vea crossref:kernelconfig[kernelconfig,Configuración del kernel de FreeBSD].

Las líneas de dispositivo relevantes para su fichero de configuración del kernel podrín verse de esta manera, para FreeBSD 4.X:

[.programlisting]
....
device		sio0	at isa? port IO_COM1 irq 4
device		sio1	at isa? port IO_COM2 irq 3
device		sio2	at isa? port IO_COM3 irq 5
device		sio3	at isa? port IO_COM4 irq 9
....

y de esta manera, para FreeBSD 5.X:

[.programlisting]
....
device		sio
....

Puede comentar o remover completamente líneas de dispositivos que no tenga en el caso de FreeBSD 4.X; para FreeBSD 5.X tiene que editar su fichero [.filename]#/boot/device.hints# para configurar sus puertos serie. Por favor diríjase a la página de manual man:sio[4] para mayor información sobre puertos serie y configuración de tarjetas multipuertos. Tenga cuidado si está utilizando un fichero de configuración que fué usado anteriomente para una versión diferente de FreeBSD porque las banderas de dispositivo y la sintaxis han cambiado entre versiones.

[NOTE]
====
`port IO_COM1` es una substitución para `port 0x3f8`, `IO_COM2` es `0x2f8`, `IO_COM3` es `0x3e8`, y `IO_COM4` es `0x2e8`, las cuales son direcciones de puerto comunes para sus respectivos puertos serie; interrupciones 4,3,5 y 9 son peticiones comunes de líneas de interrupción. Note también que puertos serie regulares _no pueden_ compartir interrupciones en PCs con bus ISA (las tarjetas multipuerto tienen electrónicos que les permiten a los 16550A's compartir una o dos líneas de peticiones de interrupción).
====

=== Archivos especiales de dispositivo

La mayoría de dispositivos en el kernel son accesados a través de "ficheros especiales de dispositivo", los cuales están localizados en el directorio [.filename]#/dev#. Los dispositivos [.filename]#sio# son accesados a través de los dispositivos [.filename]#/dev/ttydN# (dial-in) y [.filename]#/dev/cuaaN# (call-out). FreeBSD provee también dispositivos de inicialización ([.filename]#/dev/ttyidN# y [.filename]#/dev/cuaiaN#) y dispositivos de bloqueo ([.filename]#/dev/ttyldN# y [.filename]#/dev/cualaN#). Los dispotivos de inicialización son utilizados para inicializar los parámetros de comunicación de puerto cada vez que un puerto es abierto, como `crtscts` para modems que utilizan señalización `RTS/CTS` para control de flujo. Los dispositivos de bloqueo son utilizados para bloquear banderas en puertos y prevenir que usuarios o programas cambien ciertos parámetros; vea las páginas de manual man:termios[4], man:sio[4], y man:stty[1] para información de las propiedades de terminales, bloqueo e inicialización de dispositivos y aplicación de opciones de terminal, respectivamente.

==== Creando ficheros de dispositivo especiales

[NOTE]
====
FreeBSD 5.0 incluye el sistema de ficheros man:devfs[5] el cual crea automáticamente nodos de dispositivos según se necesiten. si está corriendo una versión de FreeBSD con `devfs` habilitado entonces puede saltarse esta sección.
====

Un script de shell llamado `MAKEDEV` en el directorio [.filename]#/dev# administra los ficheros especiales de dispositivo. Para utilizar `MAKEDEV` para crear un fichero especial de dispositivo dial-up para [.filename]#COM1# (port 0), `cd` a [.filename]#/dev# y ejecute el comando `MAKEDEV ttyd0`. De la misma manera, para crear ficheros especiales de dispositivo para [.filename]#COM2# (port 1), utilice `MAKEDEV ttyd1`.

`MAKEDEV` no crea solamente el fichero especial de dispositivo [.filename]#/dev/ttydN# también crea los nodos [.filename]#/dev/cuaaN#, [.filename]#/dev/cuaiaN#, [.filename]#/dev/cualaN#, [.filename]#/dev/ttyldN#, y [.filename]#/dev/ttyidN#.

Despues de crear ficheros especiales de dispositivo nuevos, asegúrese de revisar los permisos en los ficheros (especialmente los ficheros [.filename]#/dev/cua*#) para asegurarse que solamente los usuarios que deben tener acceso a esos ficheros especiales de dispositivo puedan leer y escribir en ellos - probablemente no desee permitir al usuario promedio utilizar sus modems para marcar al exterior. Los permisos por omisión en los ficheros [.filename]#/dev/cua*# deberían ser suficientes: 

[source,bash]
....
crw-rw----    1 uucp     dialer    28, 129 Feb 15 14:38 /dev/cuaa1
crw-rw----    1 uucp     dialer    28, 161 Feb 15 14:38 /dev/cuaia1
crw-rw----    1 uucp     dialer    28, 193 Feb 15 14:38 /dev/cuala1
....

Estos permisos permiten al usuario `uucp` y usuarios en el grupo `dialer` utilizar dispositivos call-out.

[[serial-hw-config]]
=== Configuración de puerto serie

El dispositivo [.filename]#ttydN# (o [.filename]#cuaaN#) es el dispositivo regular que usted deseará abrir para sus aplicaciones. Cuando un proceso abre el dispositivo, tendrá un conjunto por omisión de propiedades de terminal E/S. Puede ver estas propiedades con el comando

[source,bash]
....
# stty -a -f /dev/ttyd1
....

Cuando cambia las propiedades de este dispositivo, las propiedades son efectivas hasta que el dispositivo es cerrado. Cuando es reabierto regresa a las propiedades por omisión. Para realizar cambios al conjunto por omisión, usted puede abrir y ajustar las propiedades del dispositivo de "estado inicial" . Por ejemplo, para activar el modo `CLOCAL`, comunicación de 8 bits y control de flujo `XON/XOFF` por omisión para [.filename]#ttyd5#, teclée:

[source,bash]
....
# stty -f /dev/ttyid5 clocal cs8 ixon ixoff
....

La inicialización para todo el sistema de los dispositivos serie es controlada en [.filename]#/etc/rc.serial#. Este fichero afecta las propiedades por omisión de dispositivos serie.

Para prevenir que ciertas propiedades sean cambiadas por una aplicación, haga ajustes al dispositivo "bloquear estado". Por ejemplo, para confinar la velocidad en [.filename]#ttyd5# a 57600 bps, teclée:

[source,bash]
....
# stty -f /dev/ttyld5 57600
....

Ahora, una aplicación que abra [.filename]#ttyd5# y trate de cambiar la velocidad del puerto se mantendrá con 57600 bps.

Naturalmente, debería crear los dispositivos de estado inicial y bloqueo de estado escribible únicamente para la cuenta `root` .

[[term]]
== Terminales

Las terminales proveen una manera conveniente y de bajo coste de accesar su sistema FreeBSD cuando no se encuentra en la consola de la computadora o en una red conectada. Esta sección describe como utilizar terminales con FreeBSD.

[[term-uses]]
=== Usos y tipos de terminales

Los sistemas originales UNIX(R) no tenín consolas. En su lugar la gente se firmaba y corría programas a través de terminales conectadas a los puertos serie de la computadora. Es bastante similar a usar un modem y un programa de terminal para marcar hacia un sistema remoto para hacer trabajo en modo texto.

Las PCs actuales tienen consolas con gráficos de alta calidad, pero la habilidad para establecer una sesión en un puerto serie todavía existe en casi cualquier sistema operativo UNIX(R) al día de hoy; FreeBSD no es la excepción. Utilizando una terminal conectada a un puerto serie libre, usted puede accesar y correr cualquier programa de texto que podría correr normalmente en la consola o en una ventana `xterm` en el sistema X Window.

Para el usuario corporativo, se pueden conectar muchas terminales a un sistema FreeBSD y ponerlas en los escritorios de sus empleados. Para un usuario casero, una computadora de reserva, como una IBM PC más antigua o una Macintosh(R), puede ser una terminal cableada a una computadora más poderosa corriendo FreeBSD. Puede convertir lo que de otra manera sería una computadora de un solo usuario en un poderoso sistema de usuarios múltiples. 

Para FreeBSD, existen tres clases de terminales:

* <<term-dumb,Terminales tontas>>
* <<term-pcs,PCs actuando como terminales>>
* <<term-x,Terminales X>>

Las subsecciones siguientes describen cada tipo.

[[term-dumb]]
==== Terminales tontas

Terminales tontas son piezas de hardware especializadas que le permiten conectar a computadoras a través de líneas serie. Son llamadas "tontas" porque solo tienen poder computacional suficiente para desplegar, enviar y recibir texto. No puede ejecutar ningún programa en ellas. Es la computadora a la cual se conectan la que tiene todo el poder para correr editores de texto, compiladores, correo electrónico, juegos, y demás.

Existen cientos de tipos de terminales tontas hechas por muchos fabricantes, incluyendo VT-100 de Digital Equipment Corporation y WY-75 de Wyse. Cualquier tipo funcionará con FreeBSD. Algunas terminales superiores pueden incluso desplegar gráficos, pero solo ciertos paquetes de software pueden tomar ventaja de estas funciones avanzadas.

Las terminales tontas son populares en ambientes de trabajo donde los trabajadores no necesitan acceso a aplicaciones gráficas como las que provee el sistema X Window.

[[term-pcs]]
==== PCs actuando como terminales

Si una <<term-dumb,terminal tonta>> tiene apenas la habilidad para desplegar, enviar y recibir texto, entonces ciertamente cualquier computadora personal de reserva puede ser una terminal tonta. Todo lo que necesita es el cable apropiado y algún software de _emulación de terminal_ para correr en la computadora.

Tal configuración es popular en hogares. Por ejemplo, si su consorte se encuentra ocupado trabajando en la consola de su sistema FreeBSD, usted puede realizar algún trabajo en modo texto al mismo tiempo desde una computadora personal menos poderosa conectada como una terminal al sistema FreeBSD.

[[term-x]]
==== Terminales X

Las terminales X son el tipo más sofisticado de terminal disponible. En lugar de conectar a un puerto serie, usualmente se conectan a una red como Ethernet. En lugar de ser relegadas a aplicaciones de modo texto pueden desplegar aplicaciones X.

Hemos introducido terminales X solo por complementar. Sin embargo, este capítulo _no_ cubre instalación, configuración o uso de terminales X.

[[term-config]]
=== Configuración

Esta sección describe lo que necesita para configurar en su sistema FreeBSD y permitirle habilitar sesiones de entrada en una terminal. Asume que ya tiene configurado su kernel para soportar el puerto serie al cual la terminal está conectada-y que la tiene conectada.

Recuerde del crossref:boot[boot,El proceso de arranque en FreeBSD] que el proceso `init` es responsable del control e inicialización de todos los procesos al inicio del sistema. Una de las tareas ejecutadas por `init` es leer el fichero [.filename]#/etc/ttys# e iniciar un proceso `getty` en las terminales disponibles. El proceso `getty` es responsable de leer un nombre de entrada e iniciar el programa `login` .

Así, para configurar terminales para su sistema FreeBSD los siguientes pasos deben hacerse como `root`:

[.procedure]
====
. Agregue una línea a [.filename]#/etc/ttys# para la entrada en el directorio [.filename]#/dev# para el puerto serie si todavía no se encuentra ahí.
. Especifique que `/usr/libexec/getty` sea ejecutado en el puerto, y especifique el tipo apropiado de _getty_ desde el fichero [.filename]#/etc/gettytab# .
. Especifique el tipo de terminal por omisión.
. Ponga el puerto a "on."
. Especifique si el puerto debe ser o no "seguro."
. Obligue a `init` a releer el fichero [.filename]#/etc/ttys# .
====

Como un paso opcional, tal vez desee crear un tipo _getty_ personalizado para utilizar en el paso 2 mediante una entrada en [.filename]#/etc/gettytab#. Este capítulo no explica como realizarlo; por lo que se le exhorta a leer las páginas de manual man:gettytab[5] y man:getty[8] para mayor información.

[[term-etcttys]]
==== Agregando una entrada a [.filename]#/etc/ttys#

El fichero [.filename]#/etc/ttys# lista todos los puertos en su sistema FreeBSD donde quiere permitir logins. Por ejemplo, la primera consola virtual [.filename]#ttyv0# tiene una entrada en este fichero. Puede firmarse en la consola utilizando esta entrada. Este fichero también contiene entradas para las otras consolas virtuales, puertos serie y pseudo-ttys. Para una terminal conectada por cable, solo liste la entrada [.filename]#/dev# del puerto serie sin la parte de [.filename]#/dev# (por ejemplo, [.filename]#/dev/ttyv0# debería estar listado como [.filename]#ttyv0#).

Una instalación por omisión de FreeBSD incluye un fichero [.filename]#/etc/ttys# con soporte para los primeros cuatro puertos serie: [.filename]#ttyd0# hasta [.filename]#ttyd3#. Si está conectando una terminal a uno de esos puertos, no necesita agregar otra entrada.

[[ex-etc-ttys]]
.Agregando entradas de terminal a [.filename]#/etc/ttys#
[example]
====
Suponga que quisiéramos conectar dos terminales al sistema: una Wyse-50 y una vieja IBM PC 286 corriendo el software de terminal Procomm emulando una terminal VT-100. Conectamos la Wyse al segundo puerto serie y la 286 al sexto puerto serie (un puerto en una tarjeta multipuerto serie). Las entradas correspondiente en el fichero [.filename]#/etc/ttys# se verían como esto:

[.programlisting]
....
ttyd1  "/usr/libexec/getty std.38400"  wy50  on  insecure
ttyd5   "/usr/libexec/getty std.19200"  vt100  on  insecure
....

* El primer campo normalmente especifica el nombre de fichero especial de la terminal como es hallado en [.filename]#/dev#.

* El segundo campo es el comando a ejecutar por esta línea, el cual es usualmente man:getty[8]. `getty` inicializa y abre la línea, establece la velocidad, pregunta por un nombre de usuario y entonces ejecuta el programa man:login[1] .El programa `getty` acepta un parámetro (opcional) en su línea de comando, el tipo _getty_. Un tipo _getty_ configura características en la línea de terminal, como tasa de bps y paridad. El programa `getty` lee estas características desde el fichero [.filename]#/etc/gettytab#.El fichero [.filename]#/etc/gettytab# contiene muchas entradas para líneas de terminal viejas y nuevas. En la mayoría de los casos, las entradas que empiezan con el texto `std` funcionarán para terminales conectadas físicamente. Estas entradas ignoran la paridad. Existe una entrada `std` por cada tasa de bps de 110 a 115200. Por supuesto puede agregar sus propias entradas a este fichero. La página de manual man:gettytab[5] provee mayor información.Al establecer el tipo _getty_ en el fichero [.filename]#/etc/ttys#, asegúrese que las propiedades de comunicaciones en la terminal concuerden.Para nuestro ejemplo, la Wyse-50 no usa paridad y conecta a 38400 bps. La 286 PC no usa paridad y conecta a 19200 bps.

* El tercer campo es el tipo de terminal usualmente conectado a esa línea tty. Para puertos dial-up, `unknown` o `dialup` son usados típicamente en este campo puesto que los usuarios pueden marcar prácticamente con cualquier tipo de terminal o de software. Para terminales conectadas físicamente, el tipo de terminal no cambia, así que puede poner un tipo de terminal real del fichero de base de datos man:termcap[5] en este campo.Para nuestro ejemplo, la Wyse-50 utiliza el tipo de terminal real mientras que la PC 286 corriendo Procomm será puesta a emular una VT-100. 

* El cuarto campo especifica si el puerto debe habilitarse. Poniendo `on` aquí provocará que el proceso `init` inicie el programa en el segundo campo, `getty`. Si pone `off` en este campo, no habrá `getty`, y por consecuencia ningun login en el puerto.

* El último campo es utilizado para especificar si el puerto es seguro. Marcar un puerto como seguro significa que se confía en él lo suficiente para permitir que la cuenta `root` (o cualquier cuenta con un ID de usuario 0) se firme desde ese puerto. Los puertos inseguros no permiten entradas de `root`. En un puerto inseguro, los usuarios deben firmarse desde cuentas sin privilegios y entonces utilizar man:su[1] o un mecanismo similar para acceder a privilegios de superusuario.Es altamente recomendable que utilize "insecure" incluso para terminales que se encuentran detrás de puertas con llave. Es muy sencillo entrar y usar `su` si necesita privilegios de superusuario.
====

[[term-hup]]
==== Forzar `init` a que relea [.filename]#/etc/ttys#

Despues de realizar los cambios necesarios al fichero [.filename]#/etc/ttys# debería mandar una señal SIGHUP (hangup) al proceso `init` para forzarlo a releer su fichero de configuración. Por ejemplo:

[source,bash]
....
# kill -HUP 1
....

[NOTE]
====
`init` siempre es el primer proceso que corre en un sistema, por lo tanto siempre tendrá el PID 1.
====

Si todo está puesto correctamente, todos los cables en su lugar, y las terminales están encendidas, entonces un proceso `getty` debe estar corriendo en cada terminal y debería ver prompts de entrada en sus terminales en este punto.

[[term-debug]]
=== Determinando errores en su conexión

Incluso con la más meticulosa etención al detalle, algo puede salir mal mientras se configura una terminal. Esta es una lista de síntomas y algunos arreglos sugeridos.

==== No aparece prompt de login

Asegúrese que la terminal está conectada y encendida, asegúrese que se encuentra ejecutando un software de emulación de terminal en el puerto serie correcto.

Asegúrese que el cable está conectado firmemente tanto a la terminal como a la computadora FreeBSD. Asegúrese que es el tipo correcto de cable.

Asegúrese que la terminal y FreeBSD concuerdan en la tasa de bps y propiedades de paridad. Si tiene una terminal de desplegado de video, asegúrese que los controles de contraste y brillo estén encendidos. Si es una terminal de impresión, asegúrese que papel y tinta se encuentren en forma.

Asegúrese que un proceso `getty` esté corriendo y sirviendo la terminal. Por ejemplo, para obtener una lista de procesos `getty` con `ps`, teclée:

[source,bash]
....
# ps -axww|grep getty
....

Debería ver una entrada para la terminal. Por ejemplo, el siguiente desplegado muestra que un `getty` está corriendo en el segundo puerto serie `ttyd1` y está utilizando la entrada `std.38400` en [.filename]#/etc/gettytab#:

[source,bash]
....
22189  d1  Is+    0:00.03 /usr/libexec/getty std.38400 ttyd1
....

Si no hay un proceso `getty` corriendo, asegúrese que tiene habilitado el puerto en [.filename]#/etc/ttys#. Recuerde también ejecutar `kill -HUP 1` despues de modificar el fichero [.filename]#ttys#.

Si el proceso `getty` está corriendo pero la terminal todavía no despliega un prompt de login, o si despliega un prompt pero no le permite escribir, su terminal o cable tal vez no soporte inicialización por hardware. Trate cambiar la entrada en [.filename]#/etc/ttys# de `std.38400` a `3wire.38400` recuerde correr `kill -HUP 1` despues de modificar [.filename]#/etc/ttys#. La entrada `3wire` es similar a `std`, pero ignora la inicialización por harware. Tal vez necesite reducir la tasa de baudios o habilitar control de flujo por software cuando utilice `3wire` para prevenir desbordamientos de buffer.

==== Si aparece basura en lugar de un prompt de login

Asegúrese que la terminal y FreeBSD concuerdan en la tasa de bps y propiedades de paridad. Revise los procesos `getty` para asegurarse que el tipo correcto de _getty_ está en uso. Si no es así, edite [.filename]#/etc/ttys# y ejecute `kill -HUP 1`.

==== Los caracteres aparecen doble; las contraseñas aparecen cuando se escriben

Cambie la terminal (o el software de emulación de terminal) de "half duplex" o "local echo" a "full duplex."

[[dialup]]
== Servicio dial-in

Configurar su sistema FreeBSD para servicio dial-in es muy similar a conectar terminales excepto que en lugar de lidiar con terminales se hace con modems.

=== Modems externos vs. internos

Los modems externos parecen ser más convenientes para dial-up, debido a que los modems externos con frecuencia pueden ser configurados semi permanentemente vía parámetros almacenados en RAM no volatil y usualmente proveen indicadores luminosos que despliegan el estado de señales importantes RS-232. Luces parpadeantes impresionan a los visitantes, pero las luces son también útiles para ver si un modem se encuentra operando adecuádamente.

Los modems internos usualmente carecen de RAM no volatil, entonces su configuración puede estar limitada a especificar DIP switches. Si su modem interno cuenta con algún indicador luminoso de señales, es probablemente dificil observar las luces cuando el sistema está cubierto y en su lugar.

==== Modems y cables

Si se encuentra utilizando un modem externo, entonces necesitará por supuesto un cable adecuado. Un cable serie estándar RS-232C debe ser suficiente mientras todas las señales normales sean cableadas:

* Transmitted Data (TD)
* Received Data (RD)
* Request to Send (RTS)
* Clear to Send (CTS)
* Data Set Ready (DSR)
* Data Terminal Ready (DTR)
* Carrier Detect (CD)
* Signal Ground (SG)

FreeBSD necesita las señales RTS y CTS para control de flujo a velocidades mayores a 2400 bps, la señal CD para detectar cuando una llamada ha sido respondida o la línea ha sido colgada, y la señal DTR para reiniciar el modem despues de completar una sesión. Algunos cables son hechos sin incluir todas las señales necesarias, así que si tiene problemas, como cuando una sesión no finaliza cuando la línea es colgada, tal vez el problema se deba al cable.

Como otros sistemas operativos tipo UNIX(R), FreeBSD utiliza las señales de hardware para saber cuando una llamada ha sido contestada o una línea ha sido colgada y poder colgar y reiniciar el modem despues de una llamada. FreeBSD evita enviar comandos al modem o esperar por reportes de estado del modem. Si está familiarizado con la conexión de modems una PC funcionando como BBS, tal ves esto parezca extraño.

=== Consideraciones de interfaces serie

FreeBSD soporta interfaces de comunicación NS8250-, NS16450-, NS16550-, y NS16550A-basado en EIA RS-232C (CCITT V.24). Los dispositivos 8250 y 16450 tienen buffers de un solo caracter. El dispositivo 16550 brinda un buffer de 16 caracteres, el cual permite un mejor desempeño del sistema. (Errores en 16550 simple impiden el uso del buffer de 16 caracteres, así que utilice 16550A si es posible). Debido a que los dispositivos de buffer de un solo caracter requieren más trabajo del sistema operativo que los dispotivos de buffer de 16 caracteres, las tarjetas de interfaz serie basadas en 16550A son mayormente preferidas. Si el sistema tiene muchos puertos serie activos o tendrá una carga elevada, las tarjetas basadas en 16550A son mejores para comunicaciones con baja tasa de error.

=== Revisión rápida

Como con las terminales, `init` engendra un proceso `getty` para cada puerto serie configurado para conexiones dial-in. Por ejemplo, si un modem está conectado a [.filename]#/dev/ttyd0#, el comando `ps ax` podría mostrar esto:

[source,bash]
....
4850 ??  I      0:00.09 /usr/libexec/getty V19200 ttyd0
....

Cuando un usuario marca la línea del modem y el modem conecta, la línea CD (Carrier Detect) es reportada por el modem. El kernel nota que se ha detectado una portadora y completa la apertura de `getty` del puerto. `getty` manda un prompt `login:` a la velocidad inicial de línea especificada. `getty` observa si se reciben caracteres válidos, y, en una configuración típica, si encuentra basura (probablemente debido a que la velocidad de conexión del modem es diferente a la velocidad de `getty`), `getty` trata de ajustar la velocidad de la línea hasta que recibe caracteres razonables.

Despues que el usuario entra su nombre de login, `getty` ejecuta [.filename]#/usr/bin/login#, que completa la entrada preguntando por la contraseña del usuario y entonces inicia el shell del usuario.

=== Archivos de configuración

Existen tres ficheros de configuración del sistema en el directorio [.filename]#/etc# que probablemente necesitará editar para permitir acceso de dial-up a su sistema FreeBSD. El primero, [.filename]#/etc/gettytab#, contiene información de configuración para el daemon [.filename]#/usr/libexec/getty#. El segundo, [.filename]#/etc/ttys# contiene información que le dice a [.filename]#/sbin/init# que dispositivos [.filename]#tty# deben tener procesos `getty` corriendo. Por último, puede incluir comandos de inicialización de puerto en el script [.filename]#/etc/rc.serial#.

Existen dos escuelas de pensamiento en relación a modems dial-up en UNIX(R). Un grupo gusta de configurar sus modems y sistemas para que sin importar a que velocidad un usuario remoto marque, la interfaz local RS-232 computadora-a-modem corra a una velocidad fija. El beneficio de esta configuración es que el usuario remoto siempre obtiene un prompt de login del sistema inmediátamente. La desventaja es que el sistema no sabe cual es la tasa de datos verdadera del usuario, así que programas a pantalla completa como Emacs no ajustarán sus métodos de dibujado de pantalla para mejorar sus respuestas en conexiones más lentas.

La otra escuela configura sus modems de interfaz RS-232 para variar su velocidad basado en la velocidad de conexión del usuario remoto. Por ejemplo, conexiones V.32bis (14.4 Kbps) al modem podrían hacer al modem correr su interfaz RS-232 a 19.2 Kbps, mientras que conexiones 2400 bps hacen correr la interfaz RS-232 del modem a 2400 bps. Debido a que `getty` no entiende el reporte de velocidad de conexión de cualquier modem, `getty` brinda un mensaje `login:` a una velocidad inicial y observa los caracteres que regresan en respuesta. Si el usuario recibe basura, se asume que sabe que debe presionar la tecla kbd:[Enter] hasta que reciba un prompt reconocible. Si la tasa de datos no concuerda, `getty` trata todo lo que el usuario escriba como "basura", trata yendo a la siguiente velocidad y brinda el prompt `login:` de nuevo. Este procedimiento puede continuar hasta el cansancio, pero normalmente solo toma un teclazo o dos antes que el usuario reciba un prompt correcto. Obviamente, esta secuencia de login no parece tan limpia como el anterior método de "velocidad fija", pero un usuario en una conexión de velocidad baja podría recibir una respuesta interactiva mejor desde programas a pantalla completa.

Esta sección tratará de dar información de configuración balanceada, pero está cargada hacia tener la tasa de datos del modem siguiendo la tasa de conexión.

==== [.filename]#/etc/gettytab#

[.filename]#/etc/gettytab# es un fichero tipo man:termcap[5] de información de configuración para man:getty[8]. Por favor vea la página de manual man:gettytab[5] para información completa del formato del fichero y la lista de capacidades.

===== Configuración de velocidad fija

Si está fijando la tasa de comunicación de datos de su modem a una velocidad particular, probablemente no necesitará ningún cambio a [.filename]#/etc/gettytab#.

===== Configuración de velocidad concordante

Necesitará crear una entrada en [.filename]#/etc/gettytab# para darle información a `getty` acerca de las velocidades que desea usar para su modem. Si tiene un modem 2400 bps, puede probablemente utilizar la entrada existente `D2400`.

[.programlisting]
....
#
# Fast dialup terminals, 2400/1200/300 rotary (can start either way)
#
D2400|d2400|Fast-Dial-2400:\
        :nx=D1200:tc=2400-baud:
3|D1200|Fast-Dial-1200:\
        :nx=D300:tc=1200-baud:
5|D300|Fast-Dial-300:\
        :nx=D2400:tc=300-baud:
....

Si tiene un modem de mayor velocidad, probablemente necesite agregar una entrada en [.filename]#/etc/gettytab#; aquí está una entrada que puede utilizar para un modem 14.4 Kbps con una velociad de interfaz máxima de 19.2 Kbps:

[.programlisting]
....
#
# Additions for a V.32bis Modem
#
um|V300|High Speed Modem at 300,8-bit:\
        :nx=V19200:tc=std.300:
un|V1200|High Speed Modem at 1200,8-bit:\
        :nx=V300:tc=std.1200:
uo|V2400|High Speed Modem at 2400,8-bit:\
        :nx=V1200:tc=std.2400:
up|V9600|High Speed Modem at 9600,8-bit:\
        :nx=V2400:tc=std.9600:
uq|V19200|High Speed Modem at 19200,8-bit:\
        :nx=V9600:tc=std.19200:
....

esto resultará en una conexión de 8 bits, sin paridad.

El ejemplo de arriba inicia la tasa de comunicaciones a 19.2 Kbps (para conexiones V.32bis), entonces cicla a través de 9600 bps (para V.32), 2400 bps, 1200 bps, 300 bps, y de vuelta a 19.2 Kbps. El ciclado de la tasa de comunicaciones es implementado con la capacidad `nx=` ("siguiente tabla"). Cada una de las líneas usa una entrada `tc=` ("continuación de tabla") para recoger el resto de las propiedades "estándar" para una tasa de datos en particular.

Si tiene un modem 28.8 Kbps y/o quiere tomar ventaja de la compresión en un modem 14.4 Kbps, necesita utilizar una tasa de comunicaciones mayor a 19.2 Kbps. Aquí hay un ejemplo de una entrada [.filename]#gettytab# iniciando a 57.6 Kbps:

[.programlisting]
....
#
# Additions for a V.32bis or V.34 Modem
# Starting at 57.6 Kbps
#
vm|VH300|Very High Speed Modem at 300,8-bit:\
        :nx=VH57600:tc=std.300:
vn|VH1200|Very High Speed Modem at 1200,8-bit:\
        :nx=VH300:tc=std.1200:
vo|VH2400|Very High Speed Modem at 2400,8-bit:\
        :nx=VH1200:tc=std.2400:
vp|VH9600|Very High Speed Modem at 9600,8-bit:\
        :nx=VH2400:tc=std.9600:
vq|VH57600|Very High Speed Modem at 57600,8-bit:\
        :nx=VH9600:tc=std.57600:
....

Si tiene un CPU lento o un sistema muy cargado y no tiene puertos serie basados en 16550A, tal vez reciba errores en `sio` "silo" a 57.6 Kbps.

[[dialup-ttys]]
==== [.filename]#/etc/ttys#

La configuración del fichero [.filename]#/etc/ttys# fué cubierto en <<ex-etc-ttys>>. La configuración para modems es similar pero debemos pasar un argumento diferente a `getty` y especificar un tipo diferente de terminal. El formato general tanto para configuración de velocidad fija y velocidad concordante es:

[.programlisting]
....
ttyd0   "/usr/libexec/getty xxx"   dialup on
....

El primer componente de la línea de arriba es el fichero de dispositivo especial para esta entrada - `ttyd0` significa que [.filename]#/dev/ttyd0# es el fichero que `getty` estará vigilando. El segundo componente `"/usr/libexec/getty xxx"` (_xxx_ será reemplazado por la capacidad inicial de [.filename]#gettytab#) es el proceso que `init` ejecutará en el dispositivo. El tercer componente, `dialup`, es el tipo de terminal por omisión. El cuarto parámetro, `on`, le indica a `init` que la línea es operacional. Puede existir un quinto parámetro, `secure`, pero solo debería ser utilizado para terminales que estén físicamente seguras (como la consola del sistema).

El tipo de terminal por omisión (`dialup` en el ejemplo de arriba) puede depender de preferencias locales. `dialup` es el tipo de terminal tradicional por omisión en líneas dial-up para que los usuarios puedan personalizar sus scripts de login para reconocer cuando la terminal es `dialup` y ajustar sus tipos de terminal automáticamente. De toda maneras, el autor encuentra más sencillo especificar en su sitio `vt102` como el tipo de terminal por omisión, puesto que los usuarios solo utilizan emulación VT102 en sus sistemas remotos.

Despues de realizar los cambios a [.filename]#/etc/ttys#, puede enviar al proceso `init` una señal HUP para que relea el fichero. Puede utilizar el comando 

[source,bash]
....
# kill -HUP 1
....
para mandar la señal. Si esta es su primera vez instalando el sistema, tal vez quiera esperar hasta que su(s) modem(s) estén configurados y conectados correctamente antes de señalizar a `init`.

===== Configuración de velocidad fija

Para una configuración de velocidad fija, su entrada [.filename]#ttys# necesita tener una entrada de velocidad fija provista en `getty`. Para un modem cuya velocidad de puerto está fijada en 19.2 Kbps, la entrada [.filename]#ttys# podría verse así:

[.programlisting]
....
ttyd0   "/usr/libexec/getty std.19200"   dialup on
....

Si su modem está fijado a un velocidad de datos diferente, sustituya el valor apropiado por `std.velocidad` en lugar de `std.19200`. Asegúrese de usar un tipo válido listado en [.filename]#/etc/gettytab#.

===== Configuración de velocidad concordante

En una configuración de velocidad concordante su entrada [.filename]#ttys# necesita referenciar el inicio de la entrada "auto-baud" (sic) en [.filename]#/etc/gettytab#. Por ejemplo, si agregó la entrada sugerida arriba para un modem con velocidad concordante que inicia a 19.2 Kbps (la entrada [.filename]#gettytab# conteniendo el punto de inicio `V19200`), su entrada [.filename]#ttys# podría verse como esta:

[.programlisting]
....
ttyd0   "/usr/libexec/getty V19200"   dialup on
....

==== [.filename]#/etc/rc.serial#

Modems de alta velocidad, como V.32, V.32bis, y V.34, necesitan usar control de flujo por hardware ([.filename]#RTS/CTS#). Puede agregar comandos `stty` a [.filename]#/etc/rc.serial# para activar la bandera de control de flujo por hardware en el kernel de FreeBSD para los puertos del modem.

Por ejemplo para activar la bandera `termios crtscts` de dispositivos de inicialización dial-in y dial-out en el puerto serie #1 ([.filename]##COM2##), las siguientes líneas pueden agregarse a [.filename]##/etc/rc.serial##:

[.programlisting]
....
# Serial port initial configuration
stty -f /dev/ttyid1 crtscts
stty -f /dev/cuaia1 crtscts
....

=== Propiedades del modem

Si tiene un modem cuyos parámetros pueden ser activados permanentemente en RAM no volatil, necesitará utilizar un programa de terminal (como Telix en MS-DOS(R) o `tip` en FreeBSD) para activar los parámetros. Conecte al modem usando la misma velocidad de comunicación como velocidad inicial que `getty` usará y configure la RAM no volatil del modem para que concuerde con estos requerimientos:

* CD activado cuando esté conectado
* DTR activado para operación; tirar DTR cuelga la línea y reinicia el modem
* CTS control de flujo de datos transmitidos
* Deshabilitar control de flujo XON/XOFF
* RTS control de flujo de datos recibidos
* Modo silencioso (sin códigos resultantes)
* Sin eco de comandos

Por favor lea la documentación de su modem para saber que comandos y/o switches DIP necesita proporcionarle.

Pro ejemplo, para activar los parámetros de arriba en un modem U.S. Robotics(R) Sportster(R) 14,400 externo, uno podría dar estos comandos al modem:

[.programlisting]
....
ATZ
ATC1D2H1I0R2W
....

Tal vez quiera también tomar esta oportunidad para ajustar otras propiedades en el modem, como si utilizará compresión V.42bis y/o MNP5.

El modem U.S. Robotics(R) Sportster(R) 14,400 externo también posee switches DIP que necesitan activarse; para otros modems, tal vez pueda utilizar estas propiedades como un ejemplo:

* Switch 1: ARRIBA - DTR Normal
* Switch 2: N/A (Códigos resultantes verbales/Códigos resultantes numéricos)
* Switch 3: ARRIBA - Suprimir códigos resultantes
* Switch 4: ABAJO - No eco, comandos offline
* Switch 5: ARRIBA - Auto respuesta
* Switch 6: ARRIBA - Detección de señal Normal
* Switch 7: ARRIBA - Cargar valores NVRAM por omisión
* Switch 8: N/A (Modo inteligente/Modo tonto)

Códigos resultantes deberían ser deshabilitados o suprimidos para modems dial-up para evitar problemas que pueden ocurrir si `getty` erroneamente ofrece un prompt `login:` a un modem que se encuentra en modo de comandos y el modem hace eco del comando o regresa un código resultante. Esta secuencia puede resultar en una conversación larga y tonta entre `getty` y el modem.

==== Configuración de velocidad fija

Para una configuración de velocidad fija necesitará configurar el modem para mantener una tasa de datos constante modem-a-computadora independiente de la tasa de comunicaciones. En un modem U.S. Robotics(R) Sportster(R) 14,400 externo estos comandos fijarán la tasa de datos modem-a-computadora a la velocidad utilizada para pasar los comandos:

[.programlisting]
....
ATZ
ATB1W
....

==== Configuración de velocidad concordante

Para una configuración de velocidad variable necesitará configurar su modem para ajustar la tasa de datos de su puerto serie para que coincida con la tasa de llamada entrante. En un modem U.S. Robotics(R) Sportster(R) 14,400 externo estos comandos fijarán la tasa de corrección de errores de datos a la velocidad usada para pasar los comandos, pero le permite a la tasa del puerto serie variar para conexiones que no corrigen errores:

[.programlisting]
....
ATZ
ATB2W
....

==== Revisando la configuración del modem

La mayoría de los modems de alta velocidad brindan comandos para ver los parámetros actuales de operación del modem en un modo entendible para humanos. En el modem U.S. Robotics(R) Sportster(R) 14,400 externo, el comando `ATI5` despliega los parámetros que están almacenados en la RAM no volatil. Para ver los parámetros reales de operación del modem (influenciado por los parámetros de los switches DIP del modem), utilice el comando `ATZ` y entonces `ATI4`.

Si tiene una marca diferente de modem, revise el manual de su modem para ver como checar doblemente los parámetros de configuración de su modem.

=== Determinando errores

Aquí hay unos cuantos pasos que puede seguir para revisar en sus sistema el modem dial-up.

==== Revisando el sistema FreeBSD

Conecte su modem a su sistema FreeBSD, arranque el sistema, y, si su modem tiene luces de indicación de estado, mire si el indicador DTR del modem enciende cuando el prompt `login:` aparece en la consola del sistema - si enciende, eso debería significar que FreeBSD ha iniciado un proceso `getty` en el puerto de comunicaciones apropiado y está esperando a que el modem acepte la llamada.

Si el indicador DTR no enciende, entre al sistema FreeBSD a travás de la consola y ponga un `ps ax` para ver si FreeBSD está tratando de correr un proceso `getty` en el puerto correcto. Debería ver líneas como estas entre los procesos desplegados:

[source,bash]
....
  114 ??  I      0:00.10 /usr/libexec/getty V19200 ttyd0
  115 ??  I      0:00.10 /usr/libexec/getty V19200 ttyd1
....

Si ve algo diferente, como esto:

[source,bash]
....
  114 d0  I      0:00.10 /usr/libexec/getty V19200 ttyd0
....

y el modem no ha aceptado una llamada todavía, esto significa que `getty` ha completado su apertura en el puerto de comunicaciones. Esto puede indicar un problema con el cableado o un modem mal configurado, debido a que `getty` no podría abrir el puerto de comunicaciones hasta que un CD (detección de señal) sea afirmado por el modem.

si no ve ningún proceso `getty` esperando para abrir el puerto [.filename]#ttydN# deseado, revise de nuevo sus entradas en [.filename]#/etc/ttys# para ver si existe algún error ahí. También revise el fichero de log [.filename]#/var/log/messages# para ver si existe algún mensaje de `init` o de `getty` relacionados a cualquier problema. Si existe cualquier mensaje, revise nuevamente los ficheros de configuración [.filename]#/etc/ttys# y [.filename]#/etc/gettytab#, así como los ficheros especiales de dispositivo [.filename]#/dev/ttydN#, por cualquier error, entradas faltantes, o ficheros especiales de dispositivo faltantes.

==== Trate de llamar

Trate de llamar al sistema; asegúrese de usar 8 bits, sin paridad, y 1 bit de parada en el sistema remoto. Si no obtiene un prompt inmediatamente, o recibe basura, trate presionando kbd:[Enter] una vez por segundo. Si continua sin ver un prompt de `login:` despues de un tiempo, trate enviando un `BREAK`. Si está usando un modem de alta velocidad para realizar la marcación, trate marcando de nuevo despues de fijar la velociad de interfaz del modem (por medio de `ATB1` en un modem U.S. Robotics(R) Sportster(R), por ejemplo).

Si todavía no puede obtener un prompt de `login:`, revise [.filename]#/etc/gettytab# de nuevo y revise nuevamente que

* El nombre de capacidad inicial especificado en [.filename]#/etc/ttys# para la línea coincida con un nombre de una capacidad en [.filename]#/etc/gettytab#
* Cada entrada `nx=` coincida con otro nombre de capacidad de [.filename]#gettytab#
* Cada entrada `tc=` coincida con otro nombre de capacidad de [.filename]#gettytab#

Si marca pero el modem en el sistema FreeBSD no contesta, asegúrese que el modem está configurado para contestar el teléfono cuando DTR sea detectado. Si el modem parece estar configurado correctamente, verifique que DTR sea detectado revisando las luces indicadoras del modem (si tiene alguna).

Si ha revisado todo varias veces y todavía no funciona, tome un descanso y regrese a eso depues. Si todavía continua sin funcionar, tal vez puede mandar un correo electrónico a {freebsd-questions} describiendo su modem y su problema, y las buenas personas en la lista tratarán de ayudarle.

[[dialout]]
== Servicio dial-out

Los siguientes son tips para que su equipo pueda conectarse a otra computadora mediante el modem. Esto es apropiado para establecer una sesión de terminal con un equipo remoto.

Esto es útil para entrar a una BBS.

Este tipo de conexión puede ser extremadamente útil para obtener un fichero del Internet si tiene problemas con PPP. Si necesita mandar por FTP algo y PPP no funciona, utilice la sesión de terminal para mandarlo por FTP. Entonces use zmodem para transferirlo a su máquina.

=== ¿Mi modem Hayes no está soportado, que puedo hacer?

En realidad, la página de manual para `tip` no está actualizada. Existe un marcador Hayes genérico incluido. Solo utilice `at=hayes` en su fichero [.filename]#/etc/remote#.

El controlador Hayes no es lo suficientemente inteligente para reconocer algunas de las funciones avanzadas de nuevos modems como `BUSY`, `NO DIALTONE`, o `CONNECT 115200` y solamente se confundirá. Debería apagar esos mensajes cuando utilice `tip` (usando `ATX0W`).

También, la pausa de marcado para `tip` es de 60 segundos. Su modem debe utilizar un poco menos, o de otra manera tip pensará que existe un problema de comunicación. Trate con `ATS7=45W`.

[NOTE]
====
Así como se envía, `tip` todavía no soporta modems Hayes completamente. La solución es editar el fichero [.filename]#tipconf.h# en el directorio [.filename]#/usr/src/usr.bin/tip/tip#. Obviamente necesita las fuentes de la distribución para hacer esto.

Edite la línea `#define HAYES 0` a `#define HAYES 1`. Entonces haga un `make` y `make install`. Todo funciona bien despues de eso.
====

[[direct-at]]
=== ¿Como se espera que yo entre estos comandos AT?

Haga lo que se llama una entrada "directa" en su fichero [.filename]#/etc/remote#. Por ejemplo, si su modem está conectado al primer puerto serie, [.filename]#/dev/cuaa0#, entonces ponga la siguiente línea:

[.programlisting]
....
cuaa0:dv=/dev/cuaa0:br#19200:pa=none
....

Utilice la tasa más alta de bps que su modem soporte en la capacidad br. Entonces, escriba `tip cuaa0` y estará conectado a su modem.

Si no existe un fichero [.filename]#/dev/cuaa0# en su sistema, haga esto:

[source,bash]
....
# cd /dev
# sh MAKEDEV cuaa0
....

O use `cu` como `root` con el siguiente comando:

[source,bash]
....
# cu -lline -sspeed
....

_line_ es el puerto serie (ejem.[.filename]#/dev/cuaa0#) y _speed_ es la velocidad (ejem.`57600`). Cuando termine de meter los comandos AT presione kbd:[~.] para salir.

=== ¡El signo `@` para la capacidad pn no funciona!

El signo `@` en la capacidad número de teléfono le dice a tip que busque en [.filename]#/etc/phones# por un número de teléfono. Pero el signo `@` también es un caracter especial en ficheros de capacidad como [.filename]#/etc/remote#. Escápelo con una diagonal invertida:

[.programlisting]
....
pn=\@
....

=== Como puede marcar un número de teléfono. en la línea de comando?

Ponga lo que se llama una entrada "generica" en su fichero [.filename]#/etc/remote#. Por ejemplo:

[.programlisting]
....
tip115200|Dial any phone number at 115200 bps:\
        :dv=/dev/cuaa0:br#115200:at=hayes:pa=none:du:
tip57600|Dial any phone number at 57600 bps:\
        :dv=/dev/cuaa0:br#57600:at=hayes:pa=none:du:
....

Entonces puede hacer cosas como:

[source,bash]
....
# tip -115200 5551234
....

Si prefiere `cu` y no `tip`, use una entrada `cu`:

[.programlisting]
....
cu115200|Use cu to dial any number at 115200bps:\
        :dv=/dev/cuaa1:br#57600:at=hayes:pa=none:du:
....

y escriba:

[source,bash]
....
# cu 5551234 -s 115200
....

=== ¿Tengo que teclear la tasa de bps cada vez que haga eso?

Ponga una entrada para `tip1200` o `cu1200`, pero utilice cualquier tasa bps que sea apropiada con la capacidad br. `tip` piensa que una buena opción por omisión es 1200 bps es por eso que busca una entrada `tip1200`. Aunque no tiene que usar 1200 bps.

=== Acceso a un número de equipos a través de un servidor de terminales

en lugar de esperar hasta que esté conectado y teclear `CONNECT host` cada vez, use la capacidad de tip `cm`. Por ejemplo, estas entradas en [.filename]#/etc/remote#:

[.programlisting]
....
pain|pain.deep13.com|Forrester's machine:\
        :cm=CONNECT pain\n:tc=deep13:
muffin|muffin.deep13.com|Frank's machine:\
        :cm=CONNECT muffin\n:tc=deep13:
deep13:Gizmonics Institute terminal server:\
        :dv=/dev/cuaa2:br#38400:at=hayes:du:pa=none:pn=5551234:
....

Le permitirá teclear `tip pain` o `tip muffin` para conectar a los equipos pain o muffin, y `tip deep13` para accesar al servidor de terminales.

=== ¿Puede Tip tratar más de una línea para cada sitio?

Eso es a menudo un problema donde una universidad tiene varias líneas de modems y varios miles de estudiantes tratando de usarlas.

Haga una entrada para su universidad en [.filename]#/etc/remote# y use `@` para la capacidad `pn` :

[.programlisting]
....
big-university:\
        :pn=\@:tc=dialout
dialout:\
        :dv=/dev/cuaa3:br#9600:at=courier:du:pa=none:
....

Entonces liste los números de teléfonos para la universidad en [.filename]#/etc/phones#:

[.programlisting]
....
big-university 5551111
big-university 5551112
big-university 5551113
big-university 5551114
....

`tip` tratará cada uno en el orden listado, entonces se rendirá. Si quiere seguir tratando, ejecute `tip` en un ciclo while.

=== ¿Porqué tengo que presionar kbd:[Ctrl+P] dos veces para mandar un kbd:[Ctrl+P] ?

kbd:[Ctrl+P] es el caracter de "forzado" por omisión, usado para decirle a `tip` que el siguiente caracter es un dato literal. Puede establecer el caracter de forzado a cualquier otro caracter con el escape `~s`, el cual significa "establecer una variable."

Escriba `~sforce=single-char` seguido por una nueva línea. _single-char_ es cualquier caracter. Si no especifica _single-char_, entonces el caracter de forzado es el caracter nulo, el cual puede obtener tecleando kbd:[Ctrl+2] o kbd:[Ctrl+Espacio]. Un buén valor para _single-char_ es kbd:[Shift+Ctrl+6], es cual solamente es usado en algunos servidores de terminales.

Puede hacer que el caracter de forzado sea cualquiera que usted quiera especificando lo siguiente en su fichero [.filename]#$HOME/.tiprc#:

[.programlisting]
....
force=single-char
....

=== ¿¿De repente todo lo que escribo está en mayúsculas??

Debe haber presionado kbd:[Ctrl+A], el"caracter de mayúsculas" de `tip` especialmente diseñado para personas con teclas caps-lock dañadas. Use `~s` como se ve arriba y establezca la variable `raisechar` a algo razonable. De hecho, puede establecerla a la misma del caracter de forzado, si nunca espera utilizar ninguna de estas funciones.

Aquí hay un ejemplo de fichero .tiprc perfecto para usuarios de Emacs que necesitan teclear kbd:[Ctrl+2] y kbd:[Ctrl+A] con frecuencia:

[.programlisting]
....
force=^^
raisechar=^^
....

El ^^ es kbd:[Shift+Ctrl+6].

=== ¿Como puedo realizar transferencias de ficheros con `tip`?

Si esta hablando con otro sistema UNIX(R), puede mandar y recibir ficheros con `~p` (put) y `~t` (take). Estos comandos ejecutan `cat` y `echo` en el sistema remoto para aceptar y envíar ficheros. La sintaxis es:
`~p` fichero-local [ fichero-remoto ]
`~t` fichero-remoto [ fichero-local ]

No existe revisión de errores, así que probablemente debería usar otro protocolo, como zmodem.

=== ¿Como puedo ejecutar zmodem con `tip`?

Para recibir ficheros, inicie el programa de envío en el extremo remoto. Entonces escriba `~C rz` para empezar a recibirlos localmente.

Para enviar ficheros, inicie el programa de recepción el extremo remoto. Entonces escriba `~C sz files` para enviarlos al sistema remoto.

[[serialconsole-setup]]
== Configurando la consola serie

[[serialconsole-intro]]
=== Introducción

FreeBSD tiene la habilidad de arrancar en un sistema con solo una terminal tonta como consola. Tal configuración podría ser útil para dos clases de gente: administradores de sistema que quieran instalar FreeBSD en máquinas que no tienen teclado o monitor conectado, y desarrolladores que quieran corregir errores en el kernel o controladores de dispositivos.

Como se describe en crossref:boot[boot,El proceso de arranque en FreeBSD], FreeBSD emplea un sistema de arranque de tres estados. Los primeros dos estados se encuentran en el código del bloque de arranque el cual es almacenado al principio del slice en el disco de arranque. El bloque de arranque entonces cargará y ejecutará el cargador de arranque ([.filename]#/boot/loader#) como la tercera etapa de código.

Para poder configurar la consola serie debe configurar el código del bloque de arranque, el código del cargador de arranque y el kernel.

[[serialconsole-howto-fast]]
=== Configuracióm de consola serie, versión breve

Esta sección asume que está usando la configuración por omisión y solo quiere una rápida revisión de la configuración de la consola serie.

[.procedure]
====
. Conecte el cable serie a COM1 y la terminal controladora.
. Para ver todos los mensajes de arranque en la consola serie escriba el siguiente comando mientras está firmado como superusuario:
+
[source,bash]
....
# echo 'console="comconsole"' >> /boot/loader.conf
....
+
. Edite [.filename]#/etc/ttys# y cambie `dialup` a `vt100` para la entrada `ttyd0`. De otra manera una contraseña no será requerida para conectar por medio de la consola serie, resultando en un agujero de seguridad potencial.
. Reinicie el sistema para ver si los cambios tuvieron efecto.
====

Si una configuración diferente es requerida, una explicación mas detallada existe en <<serialconsole-howto>>.

[[serialconsole-howto]]
=== Configuración de la consola serie

[.procedure]
====

. Prepare un cable serie.
+ 
Necesitará ya sea un cable null-modem o un cable serie estándar y un adaptador null-modem. Vea <<serial-cables-ports>> para una discusión sobre cables serie.
. Desconecte su teclado.
+ 
La mayoría de sistemas PC buscan el teclado durante la autoprueba de encendido (POST) y generarán un error si el teclado no es detectado. Algunas máquinas se quejan fuerte sobre la falta de un teclado y no continuarán arrancando hasta que este contectado.
+ 
Si su computadora se queja con este error, pero arranca de todos modos, entonces no tiene que hacer nada especial. (Algunas máquinas con BIOS Phoenix instalado solo mostrarán `Keyboard failed` y continuarán arrancando normalmente.)
+ 
Si su computadora se niega a arrancar sin un teclado conectado, entonces tendrá que configurar el BIOS para que ignore este error (si es posible). Consulte el manual de su tarjeta madre para los detalles de como hacer esto.
+
[TIP]
======

Poniendo el teclado como "No instalado" en el BIOS _no_ significa que no podá usar su teclado. Todo lo que hace es decirle al BIOS que no busque un teclado al momento de encender, asi no se quejará si el teclado no se encuentra conectado. Puede dejar el teclado conectado incluso si esta bandera está puesta a "No instalado" y el teclado todaía funcionará.
======
+
[NOTE]
======
Si su sistema tiene un ratón PS/2(R) es muy probable que también tenga que desconectar su ratón junto con el teclado. Esto se debe a que los ratones PS/2(R) comparten algún hardware con el teclado y dejandolo conectado puede ocasionar que el sistema piense que el teclado sigue conectado. Se dice que un sistema Gateway 2000 Pentium 90 MHz con un AMI BIOS se comporta de esta manera. En general, esto no representa un problema puesto que el ratón no es muy útil sin el teclado de todas maneras.
======

. Conecte una terminal tonta a [.filename]#COM1# ([.filename]#sio0#).
+ 
Si no tiene una terminal tonta, puede utilizar una PC/XT vieja con un programa de modem, o el puerto serie en otro equipo UNIX(R). Si no tiene un [.filename]#COM1# ([.filename]#sio0#), consiga uno. En este momento, no existe manera de seleccionar un puerto diferente a [.filename]#COM1# para los bloques de arranque sin recompilar los bloques de arranque. Si ya está utilizando [.filename]#COM1# para otro dispositivo, necesitará remover temporalmente ese dispositivo e instalar un nuevo bloque de arranque y kernel una vez que tenga a FreeBSD arriba y funcionando. (Se asume que [.filename]#COM1# estará disponible en un fichero/computadora/servidor de terminales de todas maneras; si realmente necesita [.filename]#COM1# para algo más (y no puede cambiar ese algo a [.filename]#COM2# ([.filename]#sio1#)), entonces probablemente no debería de molestarse con todo esto en primer lugar.)
. Asegúrese de que el fichero de configuración de su kernel tenga las banderas apropiadas activadas para [.filename]#COM1# ([.filename]#sio0#).
+ 
Las banderas relevantes son:
+
`0x10`:::
Habilita el soporte de consola para esta unidad. Las otras banderas de consola son ignoradas a menos que ésta está activada. Actualmente, al menos una unidad puede tener soporte de consola; la primera (en orden de configuración) con esta bandera activada es preferida. Esta opción por si sola no hará del puerto serie una consola. Active la siguiente bandera o utilice la opción `-h` descrita abajo, junto con esta bandera.

`0x20`:::
Obliga a esta unidad a ser la consola (a menos que exista otra consola de mayor prioridad), sin importar la opción `-h` discutida abajo. Esta bandera reemplaza la opción `COMCONSOLE` en las versiones 2._X_ de FreeBSD. La bandera `0x20` debe ser utilizada junto con la bandera `0x10`.

`0x40`:::
Reserva esta unidad (en conjunto con `0x10`) y hace esta unidad no disponible para acceso normal. No debería activar esta bandera en la unidad de puerto serie la cual desee utilizar como la consola serie. El único uso de esta bandera es designar la unidad para corección de errore remota del kernel. Revise "El manual del desarrollador" para mayor información sobre corrección de errores remotamente.
+
[NOTE]
======
En FreeBSD 4.0 o posterior la semántica de la bandera `0x40` es ligeramente diferente y existe otra bandera para especificar un puerto serie para corrección de errores remotamente. 
======
+ 
Ejemplo:
+
[.programlisting]
....
device sio0 at isa? port IO_COM1 flags 0x10 irq 4
....
+ 
Vea la página de manual man:sio[4] para más detalles.
+ 
Si las banderas no fueron activadas, necesita correr UserConfig (en una consola diferente) o recompilar el kernel.
. Cree [.filename]#boot.config# en el directorio raíz de la partición `a` del disco de arranque.
+ 
Este fichero instruirá al código del bloque de arranque como le gustaría arrancar el sistema. Para activar la consola serie, necesita una o más de las siguientes opciones- si quiere opciones múltiples inclúyalas todas en la misma línea:
+
`-h`:::
Cambia entre consola interna y serie. Puede usar esto para cambiar los dispositivos de consola. Por ejemplo, si arranca desde la consola interna (video), puede utilizar `-h` para dirigir el cargador de arranque y el kernel a que usen el puerto serie como su dispositivo de consola. Alternativamente, si arranca desde el puerto serie, puede utilizar `-h` para decirle al cargador de arranque y al kernel que usen el video como consola.

`-D`:::
Cambia entre configuración de consola simple y dual. En la configuración simple la consola será ya sea la consola interna (video) o el puerto serie, dependiendo del estado de la opción `-h` de arriba. En la configuración de consola dual, el video y el puerto serie se convertirán en la consola al mismo tiempo, sin importar del estado de la opción `-h`. De todas maneras, note que la configuración de consola dual toma efecto solamente mientras el bloque de arranca está corriendo. Una vez que el cargador de arranque toma el control, la consola especificada por la opción `-h` se convierte en la única consola.

`-P`:::
Hace que el bloque de arranque busque el teclado. Si no se encuentra un teclado, la opción `-D` y `-h` son activadas automátivamente.
+
[NOTE]
======
Debido a problemas de espacio en la versión actual del bloque de arranque, la opción `-P` es capaz de detectar unicamente teclados extendidos. Teclados con menos de 101 teclas (y carentes de teclas F11 y F12) no pueden ser detectados. Algunos teclados en laptops puede que no sean correctamente encontrados debido a esta limitación. Si este es el caso con su sistema, debe abandonar el uso de la opción `-P`. Desafortunádamente no hay una solución para este problema.
======
+ 
Utilice ya sea la opción `-P` para seleccionar la consola automáticamente, o la opción `-h` para activar la consola serie.
+ 
Puede incluir otras opciones descritas en man:boot[8] también.
+ 
Las opciones, excepto por `-P`, serán pasadas al cargador de arranque ([.filename]#/boot/loader#). El cargador de arranque determinará si el video interno o el puerto serie debería convertirse en la consola examinando el estado de la opción `-h` solamente. Esto significa que si especifica la opción `-D` pero no la opción `-h` en [.filename]#/boot.config#, puede utilizar el puerto serie como consola solamente durante el bloque de arranque; el cargador de arranque usará el video interno como consola.
. Arranque la máquina.
+ 
Cuando inicia su equipo FreeBSD, los bloques de arranque mostrarán los contenidos de [.filename]#/boot.config# a la consola. Por ejemplo:
+
[source,bash]
....
/boot.config: -P
Keyboard: no
....
+ 
La segunda línea aparece solamente si pone `-P` en [.filename]#/boot.config# e indica la presencia/ausencia del teclado. Estos mensajes van a la consola serie o a la interna, o a ambas, dependiendo de la opción en [.filename]#/boot.config#.
+
[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Opciones
| Mensaje va a

|ninguna
|consola interna

|`-h`
|consola serie

|`-D`
|consola serie e interna

|`-Dh`
|consola serie e interna

|`-P`, teclado presente
|consola interna

|`-P`, teclado ausente
|consola serie
|===
+ 
Despues de los mensajes de arriba, existirá una pausa pequeña antes que los bloques de arranque continuen cargando el cargador de arranque y antes de que cualquier mensaje posterior sea impreso en la consola. Bajo ciertas circunstancias, no necesita interrumpir los bloques de arranque, pero tal vez quiera hacerlo para asegurarse que las cosas están configuradas corréctamente.
+ 
Presione cualquier tecla, diferente a kbd:[Enter], en la consola para interrumpir el proceso de arranque. Los bloques de arranque entonces esperarán una entrada para determinar como continuar. Debe ver algo como esto:
+
[source,bash]
....
FreeBSD/i386 BOOT
Default: 0:ad(0,a)/boot/loader
boot:
....
+ 
Verifique que el mensaje de arriba aparece en la consola serie o en la interna o en ambas, de acuerdo a las opciones que puso en [.filename]#/boot.config#. Si el mensaje aparece en la consola correcta, presione kbd:[Enter] para continuar el proceso de arranque.
+ 
Si quiere usar la consola serie pero no ve el prompt en la terminal serie, algo está mal con su configuración. Mientras tanto, entre `-h` y presione Enter/Return (si es posible) para decirle al bloque de arranque (y entonces al cargador de arranque y al kernel) que elija el puerto serie como consola. Una vez que el sistema arranque, regrese y revise que fué lo que estuvo mal.
====

Despues que el cargador de arranque ha cargado y usted se encuentra en la tercera etapa del proceso de arranque todavía puede cambiar entre la consola interna y la consola serie activando las variables de entorno apropiadas en el cargador de arranque. Vea <<serialconsole-loader>>.

[[serialconsole-summary]]
=== Resumen

aquí está el resumen de varias configuraciones discutidas en esta sección y la consola seleccionada eventualmente.

==== Caso 1: Activó las banderas a 0x10 para [.filename]#sio0#

[.programlisting]
....
device sio0 at isa? port IO_COM1 flags 0x10 irq 4
....

[.informaltable]
[cols="1,1,1,1", frame="none", options="header"]
|===
| Opciones en /boot.config
| Consola durante bloques de arranque
| Consola durante cargador de arranque
| Consola en kernel

|ninguna
|interna
|interna
|interna

|`-h`
|serie
|serie
|serie

|`-D`
|serie e interna
|interna
|interna

|`-Dh`
|serie e interna
|serie
|serie

|`-P`, teclado presente
|interna
|interna
|interna

|`-P`, teclado ausente
|serie e interna
|serie
|serie
|===

==== Caso 2: Activó las banderas a 0x30 para sio0

[.programlisting]
....
device sio0 at isa? port IO_COM1 flags 0x30 irq 4
....

[.informaltable]
[cols="1,1,1,1", frame="none", options="header"]
|===
| Opciones en /boot.config
| Consola durante bloques de arranque
| Consola durante cargador de arranque
| Consola en kernel

|ninguna
|interna
|interna
|serie

|`-h`
|serie
|serie
|serie

|`-D`
|serie e interna
|interna
|serie

|`-Dh`
|serie e interna
|serie
|serie

|`-P`, teclado presente
|interna
|interna
|serie

|`-P`, teclado ausente
|serie e interna
|serie
|serie
|===

[[serialconsole-tips]]
=== Consejos para la consola serie

==== Configurando un velocidad de puerto serie más rápida

Por omisión, la configuración del puerto serie es: 9600 baud, 8 bits, sin paridad, y 1 bit de parada. Si desea cambiar la velocidad, necesita recompilar al menos los bloques de arranque. Agregue la siguiente línea a [.filename]#/etc/make.conf# y compile nuevos bloques de arranque:

[.programlisting]
....
BOOT_COMCONSOLE_SPEED=19200
....

Vea <<serialconsole-com2>> para instrucciones detalladas sonre construir e instalar nuevos bloques de arranque.

Si la consola serie está configurada de alguna otra manera que arrancando con `-h`, o si la consola serie usada por el kernel es diferente de la usada por los bloques de arranque, entonces también debe agregar la siguiente opción al fichero de configuración del kernel y compilar un nuevo kernel:

[.programlisting]
....
options CONSPEED=19200
....

[[serialconsole-com2]]
==== Usando puertos serie para consola diferentes a [.filename]#sio0#

Utilizar un puerto serie diferente a [.filename]#sio0# como consola requiere cierta recompilación. Si quiere usar otro puerto serie por la razón que sea, recompile los bloques de arranque, el cargador de arranque y el kernel como sigue.

[.procedure]
====

. Consiga las fuentes del kernel. (Vea crossref:cutting-edge[cutting-edge,Lo último de lo último])
. Edite [.filename]#/etc/make.conf# y ponga `BOOT_COMCONSOLE_PORT` a la dirección del puerto que quiera usar (0x3F8, 0x2F8, 0x3E8 o 0x2E8). Solamente de [.filename]#sio0# hasta [.filename]#sio3# ([.filename]#COM1# hasta [.filename]#COM4#) pueden usarse; tarjetas multipuertos serie no funcionarán. No se necesita especificar interrupción.
. Cree un fichero personalizado de configuración de kernel y agrege las banderas apropiadas para el puerto serie que desee utilizar. Por ejemplo, si desea hacer de [.filename]#sio1# ([.filename]#COM2#) la consola:
+
[.programlisting]
....
device sio1 at isa? port IO_COM2 flags 0x10 irq 3
....
+ 
o
+
[.programlisting]
....
device sio1 at isa? port IO_COM2 flags 0x30 irq 3
....
+ 
Las banderas de consola para otros puertos serie no deben activarse.
. Recompile e instale los bloques de arranque y el cargador de arranque:
+
[source,bash]
....
# cd /sys/boot
# make clean
# make
# make install
....
+
. Reconstruya e instale el kernel.
. Escriba los bloques de arranque al disco de arranque con man:disklabel[8] y arranque desde el nuevo kernel.
====

[[serialconsole-ddb]]
==== Accesando DDB Debugger desde la línea serie

Si desea entrar al modo kernel debugger desde una consola serie (útil para diagnósticos remotos, !pero también peligroso si genera un BREAK ilegítimo en el puerto serie!) entonces debe compilar con las siguientes opciones:

[.programlisting]
....
options BREAK_TO_DEBUGGER
options DDB
....

==== Obteniendo un prompt de login en la consola serie

Aunque esto no es requerido, tal vez quiera obtener un prompt de _login_ a través de una línea serie, ahora que puede ver los mensajes de arranque y puede entrar a una sesión en modo kernel debug a través de la consola serie. Aquí está como hacerlo.

Abra el fichero [.filename]#/etc/ttys# con un editor y localice las líneas:

[.programlisting]
....
ttyd0 "/usr/libexec/getty std.9600" unknown off secure
ttyd1 "/usr/libexec/getty std.9600" unknown off secure
ttyd2 "/usr/libexec/getty std.9600" unknown off secure
ttyd3 "/usr/libexec/getty std.9600" unknown off secure
....

`ttyd0` hasta `ttyd3` corresponde a [.filename]#COM1# hasta [.filename]#COM4#. Cambie `off` a `on` para el puerto deseado. Si ha cambiado la velocidad del puerto serie, necesita cambiar `std.9600` para que concuerde con los parámetros actuales, ej. `std.19200`.

Tal vez tambien desee cambiar el tipo de terminal de `unknown` al tipo actual de su terminal serie.

Despues de editar el fichero, debe hacer un `kill -HUP 1` para que este cambio surta efecto.

[[serialconsole-loader]]
=== Cambiando la consola desde el cargador de arranque

Secciones anteriores describieron como instalar la consola serie manipulando el bloque de arranque. Esta sección muestra que puede especificar la consola especificando algunos comandos y variables de entorno en el cargador de arranque. Como el cargador de arranque es invocado en la tercera etapa del proceso de arranque, despues del bloque de arranque, las propiedades en el cargador de arranque sobreescribirán las del bloque de arranque.

==== Instalando la consola serie

Puede facilmente especificarle al cargador de arranque y al kernel que utilicen la consola serie escribiendo solamente una línea en [.filename]#/boot/loader.rc#:

[.programlisting]
....
set console="comconsole"
....

Esto tendrá efecto sin importar las opciones del bloque de arranque discutidas en la sección previa.

Es mejor que ponga la línea de arriba como la primera línea en [.filename]#/boot/loader.rc# para ver los mensajes de arranque en la consola serie tan pronto como sea posible.

De igual manera, puede especificar la consola interna como:

[.programlisting]
....
set console="vidconsole"
....

Si no activa la variable de entorno `console`, el cargador de arranque, y por consecuencia el kernel, utilizarán cualquier consola que esté indicada por la opción `-h` en el bloque de arranque.

En versiones 3.2 o posteriores, puede especificar la consola en [.filename]#/boot/loader.conf.local# o [.filename]#/boot/loader.conf#, en lugar de [.filename]#/boot/loader.rc#. En este método su [.filename]#/boot/loader.rc# debe verse como:

[.programlisting]
....
include /boot/loader.4th
start
....

Entonces, puede crear [.filename]#/boot/loader.conf.local# y ponerle la siguiente línea.

[.programlisting]
....
console=comconsole
....

o

[.programlisting]
....
console=vidconsole
....

Vea man:loader.conf[5] para mayor información.

[NOTE]
====
Hasta el momento, el cargador de arranque no tiene una opción equivalente a la opción `-P` del bloque de arranque, y no existe una manera de seleccionar automáticamente la consola interna y la consola serie basandose en la presencia del teclado.
====

==== Utilizando un puerto serie para la consola diferente a [.filename]#sio0#

Necesita recompilar el cargador de arranque para usar un puerto serie diferente a [.filename]#sio0# para la consola serie. Siga el procedimiento descrito en <<serialconsole-com2>>.

[[serialconsole-caveats]]
=== Advertencias

La idea aquí es permitir a las personas configurar servidores dedicados que no requieran hardware de gráficos o teclados conectados. Desafortunádamente, mientras la mayoría de los sistemas le permitirán arrancar sin un teclado, existen bastantes que no le permitirán arrancar sin un adaptador de gráficos. Máquinas con BIOS AMI pueden configurarse para arrancar sin adaptadores de gráficos instalados cambiando simplemente la opción "graphics adapter" en la configuración del CMOS a "Not installed."

De cualquier manera, muchas máquinas no soportan esta opción y se negarán a arrancar si no tiene algún hardware de gráficos instalado en el sistema. Con estas máquinas, debe dejar algún tipo de tarjeta gráfica instalada, (incluso si solamente es una tarjeta mono barata) aunque no tendrá que conectarle un monitor. También puede tratar instalando un BIOS AMI.
