---
title: Hoofdstuk 31. Geavanceerde netwerken
part: Deel IV. Netwerkcommunicatie
prev: books/handbook/firewalls
next: books/handbook/partv
---

[[advanced-networking]]
= Geavanceerde netwerken
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:source-highlighter: rouge
:experimental:
:skip-front-matter:
:toc-title: Inhoudsopgave
:table-caption: Tabel
:figure-caption: Afbeelding
:example-caption: Voorbeeld
:xrefstyle: basic
:relfileprefix: ../
:outfilesuffix:
:sectnumoffset: 31

ifeval::["{backend}" == "html5"]
:imagesdir: ../../../../images/books/handbook/advanced-networking/
endif::[]

ifeval::["{backend}" == "pdf"]
:imagesdir: ../../../../static/images/books/handbook/advanced-networking/
endif::[]

ifeval::["{backend}" == "epub3"]
:imagesdir: ../../../../static/images/books/handbook/advanced-networking/
endif::[]

include::shared/authors.adoc[]
include::shared/releases.adoc[]
include::shared/nl/mailing-lists.adoc[]
include::shared/nl/teams.adoc[]
include::shared/nl/urls.adoc[]

toc::[]

[[advanced-networking-synopsis]]
== Samenvatting

Dit hoofdstuk zal een aantal onderwerpen over geavanceerde netwerken behandelen.

Na het lezen van dit hoofdstuk is bekend:

* De beginselen van gateways en routes.
* Hoe IEEE(R) 802.11- en Bluetooth(R)-apparaten te installeren.
* Hoe FreeBSD als een bridge te laten werken.
* Hoe een schijfloze machine vanaf het netwerk op te starten.
* Hoe opstarten met netwerk-PXE en een NFS-root-bestandssysteem te installeren.
* Hoe Network Address Translation te installeren.
* Hoe IPv6 op een FreeBSD-machine te installeren.
* Hoe ATM in te stellen.
* Hoe de mogelijkheden van CARP, het Common Address Redundancy Protocol, aan te zetten en te benutten.

Voordat dit hoofdstuk gelezen wordt, dient de lezer:

* De beginselen van de scripts in [.filename]#/etc/rc# te begrijpen.
* Bekend te zijn met basisnetwerktermen.
* Te weten hoe een nieuwe FreeBSD-kernel in te stellen en te installeren (crossref:kernelconfig[kernelconfig,De FreeBSD-kernel instellen]).
* Te weten hoe aanvullende software van derde partijen te installeren (crossref:ports[ports,Applicaties installeren. pakketten en ports]).

[[network-routing]]
== Gateways en routes

Indien een machine een andere machine over een netwerk wil vinden, dient er een mechanisme te zijn dat beschrijft hoe van de ene naar de andere machine te gaan. Dit wordt _routen_ genoemd. Een "route" is een gedefinieerd adressenpaar: een "bestemming" en een "gateway". Het paar geeft aan dat door deze _gateway_ gecommuniceerd moet worden om bij deze _bestemming_ aan te komen. Er zijn drie soorten bestemmingen: individuele host, subnetten en "standaard". De "standaardroute" wordt gebruikt indien geen van de andere routes van toepassing zijn. Verderop wordt verder op standaardroutes ingegaan. Er zijn ook drie soorten gateways: individuele hosts, interfaces (ook wel "verbindingen " genoemd), en Ethernet-hardware-adressen (MAC-adressen).

=== Een voorbeeld

Om de verschillende aspecten van routen te illustreren, wordt het volgende voorbeeld van `netstat` gebruikt:

[source,bash]
....
% netstat -r
Routing tables

Destination      Gateway            Flags     Refs     Use     Netif Expire

default          outside-gw         UGSc       37      418      ppp0
localhost        localhost          UH          0      181       lo0
test0            0:e0:b5:36:cf:4f   UHLW        5    63288       ed0     77
10.20.30.255     link#1             UHLW        1     2421
example.com      link#1             UC          0        0
host1            0:e0:a8:37:8:1e    UHLW        3     4601       lo0
host2            0:e0:a8:37:8:1e    UHLW        0        5       lo0 =>
host2.example.com link#1             UC          0        0
224              link#1             UC          0        0
....

De eerste twee regels geven de standaardroute (die behandeld wordt in de <<network-routing-default,volgende sectie>>) en de `localhost`-route aan.

De interface (kolom `Netif`) dat deze routeertabel aangeeft om voor `localhost` te gebruiken is [.filename]#lo0#, ook bekend als het teruglusapparaat. Dit geeft aan dat alle verkeer voor deze bestemming intern gehouden moet worden, in plaats van het over het LAN te sturen, aangezien het alleen aankomt op de plaats waar het verzonden werd.

Het volgende dat opvalt zijn de adressen die beginnen met `0:e0:`. Dit zijn Ethernet-hardware adressen, ook bekend als MAC-adressen. FreeBSD zal automatisch elke host (`test0` in het voorbeeld) op het lokale Ethernet identificeren en een route voor die host toevoegen, direct van deze host over de Ethernet-interface, [.filename]#ed0#. Er is ook een timeout (kolom `Expire`) met deze routesoort geassocieerd, die gebruikt wordt indien er binnen een bepaalde tijd geen bericht komt van de host. Indien dit gebeurt, wordt de route naar deze host automatisch verwijderd. Deze hosts worden geïdentificeerd door middel van een mechanisme dat bekend staat als RIP (Routing Information Protocol), dat routes naar lokale hosts bepaald door middel van een kortste-pad algoritme.

FreeBSD zal ook subnetroutes voor het lokale subnet toevoegen (`10.20.30.255` is het broadcast-adres voor het subnet `10.20.30`, en `example.com` is de domeinnaam die bij dat subnet hoort). De aanduiding `link#1` verwijst naar de eerste Ethernetkaart in de machine. Merk op dat voor hen geen aanvullende interface is gespecificeerd.

Voor beide groepen (lokale netwerkhosts en lokale subnetten) worden de routes automatisch ingesteld door een daemon genaamd routed. Indien dit niet draait, zullen alleen routes die statisch gedefinieerd (i.e., expliciet vermeld zijn) bestaan.

De regel met `host1` verwijst naar deze host, het kent deze door het Ethernetadres. Aangezien het de zendende host is, weet FreeBSD dat het de teruglus-interface ([.filename]#lo0#) moet gebruiken, in plaats van het over de Ethernet-interface te verzenden.

De twee regels met `host2` geven een voorbeeld van wat er gebeurt als een alias met man:ifconfig[8] gebruikt wordt (in de sectie over Ethernet staan redenen waarom dit gedaan wordt). Het symbool `=>` na de interface [.filename]#lo0# zegt dat niet alleen de teruglus gebruikt wordt (aangezien dit adres ook verwijst naar de lokale host), maar specifiek dat dit een alias is. Zulke routes verschijnen alleen op de hosts die de alias ondersteunen; alle andere hosts op het lokale netwerk vermelden simpelweg een regel met `link#1` voor zulke routes.

De laatste regel (bestemming subnet `224`) heeft te maken met multicasten, wat in een andere sectie besproken wordt.

Als laatste staan in de kolom `Flags` verschillende attributen. Hieronder staat een korte tabel met enkele van deze vlaggen en hun betekenis:

[.informaltable]
[cols="1,1", frame="none"]
|===

|U
|Up: De route is actief.

|H
|Host: De bestemming van de route is een enkele host.

|G
|Gateway: Stuur alles voor deze bestemming door naar dit verre systeem, dat zoekt daar uit waar het verder naar te sturen.

|S
|Statisch: Deze route was handmatig ingesteld, dus niet automatisch door het systeem aangemaakt.

|C
|Kloon: Maakt op basis van deze route een nieuwe route aan voor machines waarmee verbinding wordt gemaakt. Dit soort routes wordt gewoonlijk in lokale netwerken gebruikt.

|W
|WasGekloond: Geeft aan dat een route automatisch was ingesteld gebaseerd op een LAN (kloon)-route.

|L
|Verbinding: De route maakt gebruik van verwijzingen naar Ethernet-hardware.
|===

[[network-routing-default]]
=== Standaardroutes

Wanneer het lokale systeem een verbinding met een verre host moet maken, controleert het de routeertabel op reeds bekende paden. Indien de verre host binnen een subnet valt waarvan bekend is hoe het bereikt kan worden (gekloonde routes), controleert het systeem of het met de daarbij behorende interface verbinding kan maken.

Indien alle bekende paden falen, heeft het systeem één laatste mogelijkheid: de "standaardroute". Deze route is een speciaal soort gateway-route (gewoonlijk de enig aanwezige in het systeem) en is altijd gemarkeerd met een `c` in het vlaggenveld. Voor hosts op een LAN staat deze gateway ingesteld op de machine die een directe verbinding met de buitenwereld heeft (via een PPP-verbinding, DSL, kabelmodem, T1, of een ander netwerkinterface).

Indien de standaardroute wordt ingesteld voor een machine die zelf als gateway naar de buitenwereld werkt, zal de standaardroute de gateway-machine van de internetprovider zijn.

Hieronder volgt een voorbeeld van standaardroutes. Dit is een veelgebruikte opstelling:

image::net-routing.png[]

De hosts `Lokaal1` en `Lokaal2` staan op deze site. `Lokaal1` is verbonden met een internetprovider via een inbel-PPP-verbinding. Deze PPP-server is door een LAN verbonden met een andere gateway-computer door een externe interface naar de Internet-feed van de internetprovider.

De standaardroutes voor de machines zijn:

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Host
| Standaard gateway
| Interface

|Lokaal2
|Lokaal1
|Ethernet

|Lokaal1
|T1-GW
|PPP
|===

Een veelvoorkomende vraag is "Waarom (of hoe) moet worden ingesteld dat `T1-GW` de standaard gateway is voor `Lokaal1`, in plaats van de server van de internetprovider waarmee het verbonden is?".

Onthoud dat, aangezien de PPP-interface een adres gebruikt op het lokale netwerk van de internetprovider voor deze kant van de verbinding, routes voor alle andere machines op het lokale netwerk van de internetprovider automatisch aangemaakt worden. Daarom is het al bekend hoe de machine `T1-GW` bereikt kan worden, dus is de tussenstap dat het verkeer eerst naar de server van de internetprovider gestuurd wordt niet nodig.

Het is gebruikelijk om het adres `X.X.X.1` te gebruiken als het gateway-adres voor het lokale netwerk. Dus (gebruikmakend van hetzelfde voorbeeld), indien de lokale klasse-C adresruimte `10.20.30` was en de internetprovider `10.9.9` gebruikte, zouden de standaardroutes als volgt zijn:

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Host
| Standaardroute

|Lokaal2 (10.20.30.2)
|Lokaal1 (10.20.30.1)

|Lokaal1 (10.20.30.1, 10.9.9.30)
|T1-GW (10.9.9.1)
|===

De standaardroute kan eenvoudig in [.filename]#/etc/rc.conf# gedefinieerd worden. In dit voorbeeld werd de volgende regel aan [.filename]#/etc/rc.conf# van `Lokaal2` toegevoegd:

[.programlisting]
....
defaultrouter="10.20.30.1"
....

Het is ook mogelijk dit met het commando man:route[8] direct vanaf de opdrachtregel te doen:

[source,bash]
....
# route add default 10.20.30.1
....

Voor meer informatie over het handmatig manipuleren van netwerkrouteertabellen kan de hulppagina man:route[8] geraadpleegd worden.

[[network-dual-homed-hosts]]
=== Dual Homed machines

Er is nog één andere soort opstelling die behandeld dient te worden, en dat is een host die in twee verschillende netwerken zit. Technisch gezien telt elke machine die als gateway dienst doet (in bovenstaand voorbeeld door een PPP-verbinding te gebruiken) als een dual-homed host. Maar de term wordt echt alleen gebruikt om naar een machine te verwijzen die in twee LAN's zit.

In het ene geval heeft de machine twee Ethernetkaarten, waarbij elke kaart een adres op de gescheiden subnetten heeft. Een alternatief is dat de machine slechts één Ethernetkaart heeft en gebruikt maakt van man:ifconfig[8] aliasing. Het eerste wordt gebruikt indien er twee fysiek gescheiden Ethernet-netwerken in gebruik zijn, het laatste indien er één fysiek netwerksegment is, maar er twee logisch gescheiden subnetten zijn.

In beide gevallen worden er routeertabellen aangemaakt zodat elk subnet weet dat deze machine de gedefinieerde gateway (ingaande route) naar het andere subnet is. Deze opstelling, waarbij de machine dienst doet als router tussen de twee subnetten, wordt vaak gebruikt voor het implementeren van pakketfilters of firewall-beveiliging in één of beide richtingen.

Om deze machine daadwerkelijk pakketten te laten forwarden tussen de twee interfaces, moet aan FreeBSD verteld worden dat het deze mogelijkheid aan moet zetten. In de volgende sectie staan meer details over hoe dit te doen.

[[network-dedicated-router]]
=== Een router bouwen

Een netwerkrouter is simpelweg een systeem dat pakketten van de ene naar de andere interface doorstuurt. Internetstandaarden en goede ontwerppraktijken verhinderen het FreeBSD Project dit standaard in FreeBSD aan te zetten. Deze mogelijkheid kan worden aangezet door de volgende variabele in man:rc.conf[5] op `YES` in te stellen:

[.programlisting]
....
gateway_enable="YES"	# Op YES instellen indien deze host een gateway is
....

Deze optie stelt de man:sysctl[8] variabele `net.inet.ip.forwarding` in op `1`. Indien het nodig is om het routen tijdelijk te stoppen, kan deze variabele tijdelijk op `0` worden teruggezet.

De nieuwe router heeft routes nodig om te weten waar het het verkeer naar toe moet sturen. Voor een eenvoudig netwerk kunnen statische routes gebruikt worden. FreeBSD wordt met het standaard BSD routeer-daemon man:routed[8] geleverd, dat RIP (zowel versie 1 en versie 2) en IRDP spreekt. Ondersteuning voor BGP v4, OSPF v2, en andere slimme routeerprotocollen is beschikbaar via het pakket package:net/zebra[]. Ook zijn commerciële producten als GateD(R) beschikbaar voor complexere netwerkrouteer-oplossingen.

[[network-static-routes]]
=== Statische routes opzetten

==== Handmatige configuratie

Er wordt van het volgende netwerk uitgegaan:

image::static-routes.png[]

In dit scenario is `RouterA` een FreeBSD-machine die dienst doet als router naar de rest van het Internet. Het heeft een standaardroute ingesteld op `10.0.0.1`, dat het in staat stelt om verbindingen met de buitenwereld te maken. Er wordt aangenomen dat `RouterB` reeds juist is ingesteld en dat het weet hoe het waar naar toe moet gaan. (In dit plaatje is dit simpel. Voeg een standaardroute op `RouterB` toe door `192.168.1.1` als gateway te gebruiken.)

De routeertabel voor `RouterA` zou er ongeveer als volgt uitzien:

[source,bash]
....
% netstat -nr
Routing tables

Internet:
Destination        Gateway            Flags    Refs      Use  Netif  Expire
default            10.0.0.1           UGS         0    49378    xl0
127.0.0.1          127.0.0.1          UH          0        6    lo0
10.0.0.0/24          link#1             UC          0        0    xl0
192.168.1.0/24       link#2             UC          0        0    xl1
....

Met de huidige routeertabel is `RouterA` niet in staat om Intern Net 2 te bereiken. Het heeft geen route voor `192.168.2.0/24`. Een manier om dit te verhelpen is om de route handmatig toe te voegen. Het volgende commando voegt het netwerk Intern Net 2 toe aan de routeertabel van `RouterA` door `192.168.1.2` als de volgende hop te gebruiken:

[source,bash]
....
# route add -net 192.168.2.0/24 192.168.1.2
....

Nu kan `RouterA` elke host op het netwerk `192.168.2.0/24` bereiken.

==== Persistente configuratie

Bovenstaand voorbeeld is perfect voor het instellen van een statische route op een draaiend systeem. Een probleem is dat de routeerinformatie verdwijnt indien de FreeBSD-machine opnieuw wordt opgestart. Aanvullende statische routes kunnen in [.filename]#/etc/rc.conf# opgenomen worden:

[.programlisting]
....
# Voeg Intern Net 2 als een statische route toe
static_routes="internnet2"
route_internnet2="-net 192.168.2.0/24 192.168.1.2"
....

De instellingsvariabele `static_routes` is een lijst van strings gescheiden door een spatie. Elke string verwijst naar een routenaam. Bovenstaand voorbeeld heeft slechts één string in `static_routes`. Dit is de string _internnet2_. Vervolgens wordt een instellingsvariabele `route_internnet2` toegevoegd waarin alle instellingsparameters staan die aan het commando man:route[8] moeten worden doorgegeven. Voor bovenstaand voorbeeld zou het volgende commando zijn gebruikt:

[source,bash]
....
# route add -net 192.168.2.0/24 192.168.1.2
....

Dus is `"-net 192.168.2.0/24 192.168.1.2"` nodig.

Zoals hierboven is vermeld is het mogelijk om meerdere strings in `static_routes` te hebben. Dit maakt het mogelijk om meerdere statische routes aan te maken. De volgende regels geven een voorbeeld van het toevoegen van statische routes voor de netwerken `192.168.0.0/24` en `192.168.1.0/24` op een denkbeeldige router:

[.programlisting]
....
static_routes="net1 net2"
route_net1="-net 192.168.0.0/24 192.168.0.1"
route_net2="-net 192.168.1.0/24 192.168.1.1"
....

[[network-routing-propagation]]
=== Routes propageren

Er is al gesproken over hoe routes naar de buitenwereld te definiëren, maar niet over hoe de buitenwereld ons kan vinden.

Het is al bekend dat routeertabellen aangemaakt kunnen worden zodat al het verkeer voor een bepaalde adresruimte (in ons voorbeeld een klasse-C subnet) naar een bepaalde host op dat netwerk gezonden kan worden, dat de ingaande pakketten doorgeeft.

Wanneer een adresruimte aan een site wordt toegewezen, stelt de serviceprovider al hun routeertabellen zodanig in dat al het verkeer voor het bijhorende subnet naar de PPP-verbinding van de site gezonden wordt. Maar hoe weten sites door het land heen hoe naar de internetprovider van deze site te versturen?

Er bestaat een systeem (dat veel lijkt op de gedistribueerde DNS-informatie) dat alle toegewezen adresruimtes bijhoudt, en hun verbindingspunt met de Internet Backbone definieert. De "Backbone" zijn de grote kabels die Internetverkeer door het land en over de wereld sturen. Elke backbone-machine heeft een kopie van een master-verzameling van tabellen, die verkeer voor een bepaald netwerk naar een bepaalde backbone-carrier sturen, en van daaruit naar een keten van serviceproviders totdat het netwerk van de site bereikt is.

Het is de taak van de serviceprovider om bij de backbone-sites aan te geven dat zij het verbindingspunt (en dus het ingaande pad) zijn voor de site. Dit staat bekend als routepropagatie.

[[network-routing-troubleshooting]]
=== Problemen oplossen

Soms is er een probleem met routepropagatie en kunnen sommige sites geen verbinding maken. Misschien is het nuttigste commando om proberen uit te zoeken waar het routen misgaat man:traceroute[8]. Het is ook nuttig als er geen verbinding mogelijk lijkt met een verre machine (dus als man:ping[8] faalt).

Het commando man:traceroute[8] wordt gedraaid met de naam van de verre host waarmee geprobeerd wordt te verbinden. Het laat de gateway-hosts zien langs het gepoogde pad, dat uiteindelijk de doelhost bereikt, of wegens een gebrek aan verbinding afgebroken wordt.

Raadpleeg voor meer informatie de hulppagina voor man:traceroute[8].

[[network-routing-multicast]]
=== Multicast routen

FreeBSD ondersteunt zowel multicast-applicaties als multicast routen van huis uit. Voor multicast-applicaties is geen speciale configuratie van FreeBSD nodig; applicaties draaien over het algemeen als geleverd. Voor multicast routen dient ondersteuning in de kernel gecompileerd te worden:

[.programlisting]
....
options MROUTING
....

Ook dient de multicast-routeer-daemon man:mrouted[8] ingesteld worden zodat het tunnels en DVMRP via [.filename]#/etc/mrouted.conf# aanmaakt. Kijk voor meer details over multicast-instellingen in de hulppagina voor man:mrouted[8].

[NOTE]
====
De man:mrouted[8] multicast-routeer-daemon implementeert het multicast-routeer-protocol DVRMP welke in veel multicast-installaties grotendeels is vervangen door man:pim[4]. man:mrouted[8] en de gerelateerde man:map-mbone[8] en man:mrinfo[8] gereedschappen zijn beschikbaar in de FreeBSD Ports Collectie als package:net/mrouted[].
====

[[network-wireless]]
== Draadloze netwerken

=== De beginselen van draadloos netwerken

De meeste draadloze netwerken zijn op de IEEE(R) 802.11 standaarden gebaseerd. Een eenvoudig draadloos netwerk bestaat uit meerdere stations die met radio's communiceren die in de 2,4GHz of de 5GHz band uitzenden (alhoewel dit regionaal varieert en het ook verandert om communicatie in de 2,3GHz en de 4,9GHz banden mogelijk te maken).

802.11-netwerken zijn op twee manieren georganiseerd: in _infrastructuurmodus_ treedt één station als meester op, alle andere stations associëren met dit station; dit netwerk staat bekend als een BSS en het meesterstation heet een toegangspunt (AP). In een BSS gaat alle communicatie via het AP; zelfs als een station met een ander draadloos station wil communiceren gaan de boodschappen door het AP. In de tweede netwerkvorm is er geen meester en communiceren de stations direct. Deze netwerkvorm is een IBSS en staat gewoonlijk bekend als een _ad-hoc netwerk_.

802.11 netwerken begonnen in de 2,4GHz band waarbij gebruik werd gemaakt van protocollen die door de IEEE(R) 802.11 en 802.11b standaarden worden gedefinieerd. Deze specificaties omvatten de werkfrequenties, karakteristieken van de MAC-lagen waaronder frame- en zendsnelheden (communicatie kan met verschillende snelheden plaatsvinden). Later definieerde de 802.11a-standaard het werken in de 5GHz band, inclusief andere mechanismen voor signalering en hogere zendsnelheden. Nog later werd de 802.11g-standaard gedefinieerd om gebruik te kunnen maken van de signalerings- en zendmechanismen van 802.11a in de 2,4GHz band zodanig dat het met terugwerkende kracht werkt op 802.11b-netwerken.

Afgezien van de onderliggende zendtechnieken beschikken 802.11-netwerken over een verscheidenheid aan beveiligingstechnieken. De originele 802.11-specificaties definieerden een eenvoudig beveiligingsprotocol genaamd WEP. Dit protocol maakt gebruik van een vaste, van te voren gedeelde sleutel en het cryptografische algoritme RC4 om de gegevens die over het netwerk verstuurd worden te coderen. Alle stations dienen dezelfde sleutel te gebruiken om te kunnen communiceren. Het is bewezen dat dit mechanisme eenvoudig te kraken is en wordt nu, afgezien om voorbijgaande gebruikers te ontmoedigen het netwerk te gebruiken, nog zelden gebruikt. De huidige beveiligingsmethoden worden gegeven door de IEEE(R) 802.11i specificatie dat nieuwe cryptografische algoritmen en een aanvullend protocol om stations aan een toegangspunt te authenticeren en om sleutels voor gegevenscommunicatie uit te wisselen definieert. Verder worden cryptografische sleutels periodiek ververst en zijn er mechanismen om indringpogingen te detecteren (en om indringpogingen tegen te gaan). Een andere specificatie van een veelgebruikt beveiligingsprotocol in draadloze netwerken is WPA. Dit was een voorloper op 802.11i en gedefinieerd door een industriegroep als een tussenmaatregel terwijl er gewacht werd op de ratificatie van 802.11i. WPA specificeert een deel van de eisen van 802.11i en is ontworpen voor implementatie op verouderde hardware. In het bijzonder vereist WPA alleen de TKIP-sleutel die van de originele WEP-sleutel is afgeleid. 802.11i staat het gebruik van TKIP toe maar vereist ook ondersteuning voor een sterkere sleutel, AES-CCM, om gegevens te versleutelen. (De AES-sleutel was niet nodig in WPA omdat het rekenkundig te kostbaar werd geacht voor implementatie op verouderde hardware.)

Afgezien van de bovenstaande protocolstandaarden is de andere belangrijke standaard waarvan bewustzijn belangrijk is 802.11e. Deze standaard definieert het opstellen van multimediatoepassingen zoals gestroomde video en voice over IP (VoIP) binnen een 802.11-netwerk. Net als 802.11i heeft ook 802.11e een voorgaande specificatie genaamd WME (later hernoemd tot WMM) die door een industriegroep is gedefinieerd als een deelverzameling van 802.11e die nu kan worden gebruikt om multimediatoepassingen mogelijk te maken terwijl er gewacht wordt op de uiteindelijke ratificatie van 802.11e. Het belangrijkste om over 802.11e en WME/WMM te weten is dat ze gepriotiseerd verkeersgebruik van een draadloos netwerk mogelijk maken door middel van Quality of Service (QoS) protocollen en protocollen voor verbeterde mediatoegang. Een juiste implementatie van deze protocollen maken snelle gegevensbursts en gepriotiseerde verkeersstromen mogelijk.

FreeBSD ondersteunt netwerken die met 802.11a, 802.11b, en 802.11g werken. Ook worden de veiligheidsprotocollen WPA en 802.11i ondersteund (samen met 11a, 11b, of 11g) en QoS en de verkeerspriorisatieprotocollen die nodig zijn voor de protocollen WME/WMM worden voor een beperkte verzameling draadloze apparatuur ondersteund.

[[network-wireless-basic]]
=== Basisinstallatie

==== Kernelinstellingen

Om van een draadloos netwerk gebruik te maken is het nodig om een draadloze netwerkkaart te hebben en om de kernel met de juiste ondersteuning voor draadloze netwerken in te stellen. Het laatste is verdeeld in meerdere modulen zodat alleen de software ingesteld hoeft te worden die daadwerkelijk gebruikt zal worden.

Ten eerste is een draadloos netwerkapparaat nodig. De meestgebruikte apparaten zijn degenen die onderdelen van Atheros gebruiken. Deze apparaten worden ondersteund door het stuurprogramma man:ath[4] en voor hen dient de volgende regel aan [.filename]#/boot/loader.conf# toegevoegd te worden:

[.programlisting]
....
if_ath_load="YES"
....

Het stuurprogramma voor Atheros is opgedeeld in drie verschillende delen: het eigenlijke stuurprogramma (man:ath[4]), de ondersteuningslaag voor de hardware die chip-specifieke functies afhandelt (man:ath_hal[4]), en een algoritme om de snelheid om frames te verzenden te kiezen uit een reeks mogelijke waarden (hier ath_rate_sample). Indien deze ondersteuning als kernelmodules wordt geladen, zullen de afhankelijkheden automatisch afgehandeld worden. Voor andere apparaten dan die van Atheros dient de module voor dat stuurprogramma geladen te worden; bijvoorbeeld:

[.programlisting]
....
if_wi_load="YES"
....

voor apparaten die op onderdelen van Intersil Prism zijn gebaseerd (stuurprogramma man:wi[4]).

[NOTE]
====
In de rest van dit document zal een man:ath[4] apparaat gebruikt worden, de naam van het apparaat in de voorbeelden dient aangepast te worden aan de lokale installatie. Een lijst van beschikbare draadloze stuurprogramma's en ondersteunde adapters staat in de FreeBSD Hardware Notes. Kopieën hiervan voor verschillende uitgaven en architecturen zijn beschikbaar op de http://www.FreeBSD.org/releases/[Uitgave Informatie] pagina van de FreeBSD website. Indien er geen origineel stuurprogramma voor het draadloze apparaat bestaat, is het mogelijk om te proberen om direct het stuurprogramma van Windows(R) proberen te gebruiken met behulp van de stuurprogramma-wrapper crossref:config[config-network-ndis,NDIS].
====

Daarvoor zijn ook de modules nodig die cryptografische ondersteuning implementeren voor de te gebruiken veiligheidsprotocollen. Het is de bedoeling dat ze dynamisch door de module man:wlan[4] worden geladen maar momenteel dienen ze handmatig ingesteld te worden. De volgende modules zijn beschikbaar: man:wlan_wep[4], man:wlan_ccmp[4], en man:wlan_tkip[4]. Zowel de stuurprogramma's man:wlan_ccmp[4] en man:wlan_tkip[4] zijn alleen nodig indien het veiligheidsprotocol WPA en/of 802.11i gebruikt wordt. Indien het netwerk encryptieloos dient te zijn, is de ondersteuning van man:wlan_wep[4] niet nodig. Om deze modules tijdens het opstarten te laden, dienen de volgende regels aan [.filename]#/boot/loader.conf# toegevoegd te worden:

[.programlisting]
....
wlan_wep_load="YES"
wlan_ccmp_load="YES"
wlan_tkip_load="YES"
....

Nadat deze informatie aan het instellingenbestand om het systeem op te starten (i.e., [.filename]#/boot/loader.conf#) is toegevoegd, is het noodzakelijk om de FreeBSD-computer opnieuw op te starten. Indien het ongewenst is om de computer nu opnieuw op te starten, kunnen de modules ook handmatig worden geladen door man:kldload[8] te gebruiken.

[NOTE]
====
Indien het gebruik van modules ongewenst is, kunnen deze stuurprogramma's in de kernel worden gecompileerd door de volgende regels aan het kernelinstellingenbestand toe te voegen:

[.programlisting]
....
device wlan              # 802.11 ondersteuning
device wlan_wep          # 802.11 WEP-ondersteuning
device wlan_ccmp         # 802.11 CCMP-ondersteuning
device wlan_tkip         # 802.11 TKIP-ondersteuning
device wlan_amrr	 # AMRR controle-algoritme voor zendsnelheid
device ath	         # Atheros PCI/Cardbus netwerkkaarten
device ath_hal		 # Ondersteuning voor PCI/cardbus chips
options AH_SUPPORT_AR5146 # zet AR5146 tx/rx descriptors aan
device ath_rate_sample   # SampleRate verzendsnelheid-controle voor ath
....

Met deze informatie in het kernelinstellingenbestand kan de kernel opnieuw gecompileerd en de FreeBSD-computer opnieuw opgestart worden.
====

Wanneer het systeem draait, is het mogelijk om enige informatie over de draadloze apparaten in de opstartboodschappen te vinden, zoals:

[source,bash]
....
ath0: <Atheros 5212> mem 0x88000000-0x8800ffff irq 11 at device 0.0 on cardbus1
ath0: [ITHREAD]
ath0: AR2413 mac 7.9 RF2413 phy 4.5
....

=== Infrastructuurmodus

De infrastructuur- of BSS-modus is de modus die normaliter gebruikt wordt. In deze modus zijn een aantal draadloze toegangspunten verbonden met een bedraad netwerk. Elk draadloos netwerk heeft een eigen naam, deze naam wordt de SSID van het netwerk genoemd. Draadloze cliënten verbinden zich met de draadloze toegangspunten.

==== FreeBSD cliënten

===== Hoe toegangspunten te vinden

Voor het scannen van netwerken wordt het commando `ifconfig` gebruikt. Het kan even duren voordat dit verzoek is afgehandeld aangezien het systeem op elke beschikbare draadloze frequentie naar toegangspunten moet zoeken. Alleen de super-gebruiker kan zo'n scan opzetten:

[source,bash]
....
# ifconfig wlan0 create wlandev ath0
# ifconfig wlan0 up scan
SSID/MESH ID  BSSID              CHAN RATE   S:N     INT CAPS
dlinkap       00:13:46:49:41:76   11   54M -90:96 100 EPS  WPA WME
freebsdap     00:11:95:c3:0d:ac    1   54M -83:96 100 EPS  WPA
....

[NOTE]
====
De interface dient als up te worden gemarkeerd voordat het scannen begint. Voor verdere scans is het niet nodig om de interface als up te markeren.
====

De uitvoer van een scanverzoek vermeld elk gevonden BSS/IBSS-netwerk. Naast de naam van het netwerk, `SSID`, staat het `BSSID`, wat het MAC-adres van het toegangspunt is. Het veld `CAPS` identificeert het type van elk netwerk en de mogelijkheden van de stations die daar werkzaam zijn:

.Station Capability Codes
[cols="1,1", frame="none", options="header"]
|===
| Capability Code
| Betekenis

|`E`
|Uitgebreide dienstenverzameling (ESS). Geeft aan dat het station deel uitmaakt van een infrastructuurnetwerk (in tegenstelling tot een IBSS-/ ad-hoc-netwerk).

|`I`
|IBSS-/ad-hoc-netwerk. Geeft aan dat het station deel uitmaakt van een ad-hoc-netwerk (in tegenstelling tot een ESS-netwerk).

|`P`
|Privacy. Vertrouwelijkheid is vereist voor alle gegevensframes die binnen het BSS worden uitgewisseld. Dit betekent dat dit BSS eist dat het station cryptografische middelen als WEP, TKIP of AES-CCMP dient te gebruiken om de gegevensframes die met anderen worden uitgewisseld te versleutelen en te ontsleutelen.

|`S`
|Korte preambule. Geeft aan dat het netwerk korte preambules gebruikt (gedefinieerd in 802.11b Hoge Snelheid/DSSS PHY, korte preambule gebruikt een 56-bits synchronisatieveld in tegenstelling tot een 128-bits dat bij lange preambules wordt gebruikt).

|`s`
|Korte slottijd. Geeft aan dat het 802.11g-netwerk een korte slottijd gebruikt omdat er geen verouderde (802.11b) stations aanwezig zijn.
|===

Het is ook mogelijk om de huidige lijst van bekende netwerken weer te geven met:

[source,bash]
....
# ifconfig scan0 list scan
....

Deze informatie kan automatisch bijgewerkt worden door de adapter of handmatig met een `scan` verzoek. Oude gegevens worden automatisch uit de cache verwijderd, dus kan deze lijst na verloop van tijd korter worden tenzij er meer scanverzoeken gedaan worden.

===== Basisinstellingen

Deze sectie geeft een eenvoudig voorbeeld hoe de draadloze netwerkadapter in FreeBSD zonder encryptie aan de praat te krijgen. Nadat deze concepten bekend zijn, wordt het sterk aangeraden om <<network-wireless-wpa,WPA>> te gebruiken om de draadloze netwerken op te zetten.

Er zijn drie basisstappen om een draadloos netwerk in te stellen: een toegangspunt kiezen, het station authenticeren, en een IP-adres instellen. De volgende secties behandelen elk een stap.

====== Een toegangspunt kiezen

In de meeste gevallen is het voldoende om het systeem een toegangspunt gebaseerd op de ingebouwde heuristieken te laten kiezen. Dit is het standaardgedrag wanneer een interface als up wordt gemarkeerd of als een interface wordt ingesteld door het te noemen in [.filename]#/etc/rc.conf#, bijvoorbeeld:

[.programlisting]
....
wlans_ath0="wlan0"
ifconfig_wlan0="DHCP"
....

Indien er meerdere toegangspunten zijn en het gewenst is om een specifieke te kiezen, kan dit met het SSID:

[.programlisting]
....
wlans_ath0="wlan0"
ifconfig_wlan0="ssid uw_ssid_hier DHCP"
....

In een omgeving waar meerdere toegangspunten hetzelfde SSID hebben (vaak gedaan om roamen eenvoudiger te maken) kan het nodig zijn om met één specifiek apparaat te associëren. In dit geval kan ook het BSSID van het toegangspunt gespecificeerd worden (het SSID kan ook weggelaten worden):

[.programlisting]
....
wlans_ath0="wlan0"
ifconfig_wlan0="ssid uw_ssid_hier bssid xx:xx:xx:xx:xx:xx DHCP
....

Er zijn andere manieren om de keuze van een toegangspunt te beperken zoals het beperken van het aantal frequenties waarop het systeem scant. Dit kan handig zijn bij multi-band-netwerkkaarten aangezien het scannen van alle mogelijke kanalen tijdrovend kan zijn. Om de werking tot een specifieke band te beperken kan de parameter `mode` gebruikt worden; bijvoorbeeld:

[.programlisting]
....
wlans_ath0="wlan0"
ifconfig_wlan0="mode 11g ssid uw_ssid_hier DHCP"
....

zal de kaart forceren om te werken in 802.11g welke alleen voor 2,4GHz frequenties is gedefinieerd dus de 5GHz kanalen blijven buiten beschouwing. Andere manieren om dit te doen zijn de parameter `channel`, om bewerkingen op één specifieke frequentie vast te zetten, en de parameter `chanlist`, om een lijst van te scannen kanalen te specificeren. Meer informatie over deze parameters kan in de hulppagina man:ifconfig[8] gevonden worden.

====== Authenticatie

Nadat er een toegangspunt is gekozen moet het station zich authenticeren voordat het gegevens kan versturen. Authenticatie kan op verschillende manieren gebeuren. Het meest gebruikte schema wordt open authenticatie genoemd en staat doe dat elk station aan het netwerk deelneemt en communiceert. Deze manier van authenticatie dient gebruikt te worden voor testdoeleinden tijdens het voor de eerste keer opzetten van een draadloos netwerk. Andere schema's vereisen dat cryptografische overeenkomsten voltooid worden voordat gegevensverkeer kan stromen; ofwel door vooraf gedeelde sleutels of geheimen te gebruiken, of door complexere schema's te gebruiken welke achterliggende diensten zoals RADIUS betrekken. De meeste gebruikers zullen open authenticatie gebruiken welke de standaardinstelling is. De dan meest voorkomende opstelling is WPA-PSK, ook bekend als WPA Personal, welke <<network-wireless-wpa-wpa-psk,hieronder>> beschreven is.

[NOTE]
====
Indien er een Apple(R) AirPort(R) Extreme basisstation als toegangspunt wordt gebruikt kan het nodig zijn om gedeelde-sleutel-authenticatie samen met een WEP-sleutel in te stellen. Dit kan gedaan worden in het bestand [.filename]#/etc/rc.conf# of door het programma man:wpa_supplicant[8] te gebruiken. Indien er een enkel AirPort(R) basisstation wordt gebruikt kan de toegang met zoiets als het volgende worden ingesteld:

[.programlisting]
....
wlans_ath0="wlan0"
ifconfig_wlan0="authmode shared wepmode on weptxkey 1 wepkey 01234567 DHCP"
....

Over het algemeen dient authenticatie via gedeelde sleutels worden voorkomen omdat het materiaal van de WEP-sleutel op een zeer afgedwongen manier gebruikt wordt wat het zelfs gemakkelijker maakt om de sleutel te kraken. Indien WEP gebruikt moet worden (bijvoorbeeld voor compatibiliteit met verouderde apparaten) is het beter om WEP met `open` authenticatie te gebruiken. Meer informatie met betrekking tot WEP kan gevonden worden in <<network-wireless-wep>>.
====

====== Een IP-adres verkrijgen met DHCP

Nadat het toegangspunt is gekozen en de parameters voor de authenticatie zijn ingesteld, dient er een IP-adres ter communicatie verkregen worden. In de meeste gevallen wordt het draadloze IP-adres verkregen via DHCP. Om dat te bereiken, dient [.filename]#/etc/rc.conf# bewerkt te worden en `DHCP` aan de instellingen voor het apparaat toegevoegd te worden zoals in de verschillende bovenstaande voorbeelden is laten zien:

[.programlisting]
....
wlans_ath0="wlan0"
ifconfig_wlan0="DHCP"
....

Op dit moment kan de draadloze interface geactiveerd worden:

[source,bash]
....
# service netif start
....

Wanneer de interface draait, kan `ifconfig` gebruikt worden om de status van de interface [.filename]#ath0# te zien:

[source,bash]
....
# ifconfig wlan0
wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500
        ether 00:11:95:d5:43:62
	inet 192.168.1.00 netmask 0xffffff00 broadcast 192.168.1.255
        media: IEEE 802.11 Wireless Ethernet OFDM/54Mbps mode 11g
        status: associated
        ssid dlinkap channel 11 (2462 Mhz 11g) bssid 00:13:46:49:41:76
	country US ecm authmode OPEN privacy OFF txpower 21.5 bmiss 7
	scanvalid 60 bgscan bgscanintvl 300 bgscanidle 250 roam:rssi 7
	roam:rate 5 protmode CTS wme burst
....

Het `status: associated` betekent dat er verbinding is met een draadloos netwerk (in dit geval met het netwerk `dlinkap`). Het gedeelte `bssid 00:13:46:49:41:76` is het MAC-adres van het toegangspunt; de gedeelte met `authmode` vertelt dat de communicatie niet versleuteld is.

====== Statisch IP-adres

In het geval dat het niet mogelijk is om een IP-adres van een DHCP-server te krijgen, kan er een vast IP-adres worden ingesteld. Vervang het sleutelwoord `DHCP` van hierboven met de adresinformatie. Zorg ervoor dat de andere parameters voor het selecteren van een toegangspunt behouden blijven:

[.programlisting]
....
wlans_ath0="wlan0"
ifconfig_wlan0="inet 192.168.1.100 netmask 255.255.255.0 ssid uw_ssid_hier"
....

[[network-wireless-wpa]]
===== WPA

WPA (Wi-Fi Protected Access) is een beveiligingsprotocol dat samen met 802.11-netwerken wordt gebruikt om het gebrek aan degelijke authenticatie en de zwakte van <<network-wireless-wep,WEP>> te benadrukken. WPA verbetert het 802.1X-authenticatieprotocol en gebruikt een sleutel gekozen uit meerdere in plaats van WEP voor gegevensintegriteit. De enige sleutel welke WPA vereist is TKIP (Temporary Key Integrity Protocol). TKIP is een sleutel dat de basis-RC4-sleutel welke door WEP wordt gebruikt uitbreidt door integriteitscontroles, knoeidetectie, en maatregelen om op elke gedetecteerde inbraak te reageren toe te voegen. TKIP is ontworpen om op verouderde hardware met enkel wijzigingen in software te draaien; het representeert een compromis dat de veiligheid verbetert maar nog steeds niet geheel immuun is tegen aanvallen. WPA specificeert ook de sleutel AES-CCMP als een alternatief voor TKIP welke te verkiezen is indien mogelijk; voor deze specificatie wordt gewoonlijk de term WPA2 (of RSN) gebruikt.

WPA definieert protocollen voor authenticatie en versleuteling. Authenticatie gebeurt het meeste door één van deze twee technieken te gebruiken: door 802.1X en een achterliggende authenticatiedienst zoals RADIUS, of door een minimale overeenkomst tussen het station en het toegangspunt door een van te voren gedeeld geheim te gebruiken. Het eerste wordt vaak WPA Enterprise genoemd en het laatste staat bekend als WPA Personal. Aangezien de meeste mensen geen achterliggende RADIUS-server voor hun draadloos netwerk zullen opzetten, is WPA-PSK veruit de meest gebruikte configuratie voor WPA.

Het beheer van de draadloze verbinding en de authenticatie (sleutelonderhandeling of authenticatie met een server) gebeurt met het gereedschap man:wpa_supplicant[8]. Dit programma vereist dat er een instellingenbestand, [.filename]#/etc/wpa_supplicant.conf#, draait. Meer informatie over dit bestand kan in de hulppagina man:wpa_supplicant.conf[5] worden gevonden.

[[network-wireless-wpa-wpa-psk]]
====== WPA-PSK

WPA-PSK, ook bekend als WPA-Personal, is gebaseerd op een vooraf gedeelde sleutel (PSK) gegenereerd vanuit een gegeven wachtwoord die gebruikt zal worden als de hoofdsleutel in het draadloze netwerk. Dit betekent dat alle draadloze gebruikers dezelfde sleutel zullen delen. WPA-PSK is bedoeld voor kleine netwerken waar het gebruik van een authenticatieserver niet mogelijk of gewenst is.

[WARNING]
====

Gebruik altijd sterke wachtwoorden welke voldoende lang zijn en opgebouwd zijn uit een grote tekenverzameling zodat ze niet gemakkelijk worden geraden of aangevallen.
====

De eerste stap is het instellen van het bestand [.filename]#/etc/wpa_supplicant.conf# met het SSID en de vooraf gedeelde sleutel van het netwerk:

[.programlisting]
....
network={
  ssid="freebsdap"
  psk="freebsdmall"
}
....

Daarna zal in [.filename]#/etc/rc.conf# worden aangegeven dat de draadloze configuratie met WPA zal gebeuren en dat het IP-adres met DHCP zal worden verkregen:

[.programlisting]
....
wlans_ath0="wlan0"
ifconfig_wlan0="WPA DHCP"
....

Hierna kan de interface geactiveerd worden:

[source,bash]
....
# service netif start
Starting wpa_supplicant.
DHCPDISCOVER on wlan0 to 255.255.255.255 port 67 interval 5
DHCPDISCOVER on wlan0 to 255.255.255.255 port 67 interval 6
DHCPOFFER from 192.168.0.1
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPACK from 192.168.0.1
bound to 192.168.0.254 -- renewal in 300 seconds.
wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL
....

Ook kan gepoogd worden dit handmatig in te stellen door hetzelfde [.filename]#/etc/wpa_supplicant.conf# als <<network-wireless-wpa-wpa-psk,hierboven>> te gebruiken, en dit te draaien:

[source,bash]
....
# wpa_supplicant -i wlan0 -c /etc/wpa_supplicant.conf
Trying to associate with 00:11:95:c3:0d:ac (SSID='freebsdap' freq=2412 MHz)
Associated with 00:11:95:c3:0d:ac
WPA: Key negotiation completed with 00:11:95:c3:0d:ac [PTK=CCMP GTK=CCMP]
CTRL-EVENT-CONNECTED - Connection to 00:11:95:c3:0d:ac completed (auth) [id=0 idstr=]
....

De volgende stap is het lanceren van het commando `dhclient` om een IP-adres van de DHCP-server te krijgen:

[source,bash]
....
# dhclient wlan0
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPACK from 192.168.0.1
bound to 192.168.0.254 -- renewal in 300 seconds.
# ifconfig wlan0
wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON defxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL
....

[NOTE]
====
[.filename]#/etc/rc.conf# heeft een regel `ifconfig_wlan0` met de tekst `DHCP` (zoals `ifconfig_wlan0="DHCP"`), `dhclient` zal automatisch gestart worden nadat `wpa_supplicant` geassocieerd is met het toegangspunt.
====

Als DHCP niet mogelijk of gewenst is, kan een statisch IP-adres worden ingesteld nadat `wpa_supplicant` het station heeft geauthenticeerd:

[source,bash]
....
# ifconfig wlan0 inet 192.168.0.100 netmask 255.255.255.0
# ifconfig wlan0
wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.100 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL
....

Indien DHCP niet wordt gebruikt, dienen ook de standaard gateway en de naamserver handmatig ingesteld te worden:

[source,bash]
....
# route add default uw_standaard_router
# echo "nameserver uw_DNS_server" >> /etc/resolv.conf
....

[[network-wireless-wpa-eap-tls]]
====== WPA met EAP-TLS

De tweede manier om WPA te gebruiken is met een achterliggende 802.1X-authenticatieserver. In dit geval wordt het WPA-Enterprise genoemd om het verschil met het minder veilige WPA-Personal met de vooraf gedeelde sleutel aan te duiden. Authenticatie is in WPA-Enterprise gebaseerd op EAP (Extensible Authentication Protocol).

EAP wordt niet met een encryptiemethode geleverd. In plaats daarvan was het besloten om EAP in een versleutelde tunnel te omsluiten. Er bestaan vele EAP-authenticatiemethodes, de meest voorkomende zijn EAP-TLS, EAP-TTLS, en EAP-PEAP.

EAP-TLS (EAP met Transport Layer Security) is een zeer goed ondersteund authenticatieprotocol in de draadloze wereld aangezien het de eerste EAP-methode was die gecertificeerd werd door de http://www.wi-fi.org[Wi-Fi alliantie]. EAP-TLS vereist dat er drie certificaten draaien: het CA-certificaat (geïnstalleerd op alle machines), het servercertificaat voor de authenticatieserver, en een cliëntcertificaat voor elke draadloze cliënt. Bij deze EAP-methode authenticeren zowel de authenticatieserver als de draadloze cliënt elkaar door hun respectievelijke certificaten te laten zien, en ze controleren dat deze certificaten zijn getekend door de certificatenauthoriteit (CA) van de organisatie.

Zoals voorheen gebeurt het instellen via [.filename]#/etc/wpa_supplicant.conf#:

[.programlisting]
....
network={
  ssid="freebsdap" <.>
  proto=RSN  <.>
  key_mgmt=WPA-EAP <.>
  eap=TLS <.>
  identity="loader" <.>
  ca_cert="/etc/certs/cacert.pem" <.>
  client_cert="/etc/certs/clientcert.pem" <.>
  private_key="/etc/certs/clientkey.pem" <.>
  private_key_passwd="freebsdmallclient" <.>
}
....

<.> Dit veld geeft de naam van het netwerk (SSID) aan.

<.> Hier wordt het RSN (IEEE(R) 802.11i) protocol gebruikt, ofwel WPA2.

<.> De regel `key_mgmt` verwijst naar het gebruikte sleutelbeheerprotocol. In dit geval is het WPA dat EAP-authenticatie gebruikt: `WPA-EAP`.

<.> In dit veld wordt de EAP-methode voor de verbinding genoemd.

<.> Het veld `identity` bevat de identiteitsstring voor EAP.

<.> Het veld `ca_cert` geeft de padnaam van het CA-certificaatbestand aan. Dit bestand is nodig om het servercertificaat te controleren.

<.> De regel `client_cert` geeft de padnaam van het cliëntcertificaatbestand aan. Dit certificaat is uniek voor elke draadloze cliënt van het netwerk.

<.> Het veld `private_key` is de padnaam naar het bestand dat de privésleutel van het cliëntcertificaat bevat.

<.> Het veld `private_key_passwd` bevat het wachtwoord voor de privésleutel.

Voeg vervolgens de volgende regels toe aan [.filename]#/etc/rc.conf#:

[.programlisting]
....
wlans_ath0="wlan0"
ifconfig_wlan0="WPA DHCP"
....

De volgende stap is het activeren van de interface:

[source,bash]
....
# service netif start
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPACK from 192.168.0.20
bound to 192.168.0.254 -- renewal in 300 seconds.
wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL
....

Zoals eerder is laten zien, is het ook mogelijk om de interface handmatig te activeren met zowel de commando's `wpa_supplicant` en `ifconfig`.

[[network-wireless-wpa-eap-ttls]]
====== WPA met EAP-TTLS

Bij EAP-TLS hebben zowel de authenticatieserver als de cliënt een certificaat nodig, met EAP-TTLS (EAP-Tunneled Transport Layer Security) is een cliëntcertificaat optioneel. Deze methode komt in de buurt van wat sommige beveiligde websites doen, waar de webserver een veilige SSL-tunnel kan aanmaken zelfs als de bezoekers geen certificaten aan de cliëntkant hebben. EAP-TTLS zal de versleutelde TLS-tunnel gebruiken voor het veilig transporteren van de authenticatiegegevens.

De instellingen worden gedaan via het bestand [.filename]#/etc/wpa_supplicant.conf#:

[.programlisting]
....
network={
  ssid="freebsdap"
  proto=RSN
  key_mgmt=WPA-EAP
  eap=TTLS <.>
  identity="test" <.>
  password="test" <.>
  ca_cert="/etc/certs/cacert.pem" <.>
  phase2="auth=MD5" <.>
}
....

<.> Dit veld noemt de EAP-methode voor de verbinding.

<.> Het veld `identity` bevat de identiteitsstring voor EAP-authenticatie binnen de versleutelde TLS-tunnel.

<.> Het veld `password` bevat het wachtwoord voor de EAP-authenticatie.

<.> Het veld `ca_cert` wijst naar de padnaam van het CA-certificaatbestand. Dit bestand is nodig om het servercertificaat te controleren.

<.> Dit veld noemt de gebruikte authenticatiemethode in de versleutelde TLS-tunnel. In dit geval is EAP met MD5-Challenge gebruikt. De "binnenste authenticatie"-fase wordt vaak "phase2" genoemd.

Ook dienen de volgende regels toegevoegd te worden aan [.filename]#/etc/rc.conf#:

[.programlisting]
....
wlans_ath0="wlan0"
ifconfig_ath0="WPA DHCP"
....

De volgende stap is het activeren van de interface:

[source,bash]
....
# service netif start
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 21
DHCPACK from 192.168.0.20
bound to 192.168.0.254 -- renewal in 300 seconds.
wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet autoselect DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 Mhz) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL
....

[[network-wireless-wpa-eap-peap]]
====== WPA met EAP-PEAP

[NOTE]
====
PEAPv0/EAP-MSCHAPv2 is de meest gebruikelijke PEAP-methode. In de rest van dit document wordt de term PEAP gebruikt om naar die methode te verwijzen.
====

PEAP (Beveiligd EAP) is ontworpen als een alternatief voor EAP-TTLS, en is de meest gebruikte EAP-standaard na EAP-TLS. Met andere woorden, als u een netwerk met verschillende besturingssystemen heeft, zou PEAP de meest ondersteunde standaard moeten zijn na EAP-TLS.

PEAP is soortgelijk aan EAP-TTLS: het gebruikt een server-side certificaat om de cliënten te authenticeren door een beveiligde TLS-tunnel tussen de cliënt en de authenticatieserver aan te maken, welke de uitwisseling van de authenticatie-informatie beschermt. Vanuit een beveiligingsoogpunt gezien is het verschil tussen EAP-TTLS en PEAP dat PEAP-authenticatie de gebruikersnaam onversleuteld uitzendt, alleen het wachtwoord wordt in de beveiligde TLS-tunnel verzonden. EAP-TTLS gebruikt de TLS-tunnel voor zowel de gebruikersnaam als het wachtwoord.

Het bestand [.filename]#/etc/wpa_supplicant.conf# dient gewijzigd te worden om de EAP-PEAP-gerelateerde instellingen toe te voegen:

[.programlisting]
....
network={
  ssid="freebsdap"
  proto=RSN
  key_mgmt=WPA-EAP
  eap=PEAP <.>
  identity="test" <.>
  password="test" <.>
  ca_cert="/etc/certs/cacert.pem" <.>
  phase1="peaplabel=0" <.>
  phase2="auth=MSCHAPV2" <.>
}
....

<.> Dit veld noemt de EAP-methode voor de verbinding.

<.> Het veld `identity` bevat de identiteitsstring voor EAP-authenticatie binnen de versleutelde TLS-tunnel.

<.> Het veld `password` bevat het wachtwoord voor de EAP-authenticatie.

<.> Het veld `ca_cert` wijst naar de padnaam van het CA-certificaatbestand. Dit bestand is nodig om het servercertificaat te controleren.

<.> Dit veld bevat de parameters voor de eerste fase van authenticatie (de TLS-tunnel). Afhankelijk van de gebruikte authenticatieserver moet er een specifiek label voor authenticatie worden opgegeven. In de meeste gevallen zal het label "client EAP encryption" zijn welke ingesteld is door `peaplabel=0` te gebruiken. Meer informatie kan in de hulppagina man:wpa_supplicant.conf[5] gevonden worden.

<.> Dit veld noemt het authenticatieprotocol dat in de versleutelde TLS-tunnel gebruikt wordt. In het geval van PEAP is dit `auth=MSCHAPV2`.

Het volgende dient te worden toegevoegd aan [.filename]#/etc/rc.conf#:

[.programlisting]
....
wlans_ath0="wlan0"
ifconfig_wlan0="WPA DHCP"
....

Hierna kan de interface worden geactiveerd:

[source,bash]
....
# service netif start
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 21
DHCPACK from 192.168.0.20
bound to 192.168.0.254 -- renewal in 300 seconds.
wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet autoselect DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 Mhz) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL
....

[[network-wireless-wep]]
===== WEP

WEP (Wired Equivalent Privacy) maakt deel uit van de oorspronkelijke 802.11 standaard. Er is geen authenticatiemechanisme, slechts een zwakke vorm van toegangscontrole, en het is gemakkelijk te kraken.

WEP kan worden opgezet met `ifconfig`:

[source,bash]
....
# ifconfig wlan0 create wlandev ath0
# ifconfig wlan0 inet 192.168.1.100 netmask 255.255.255.0 \
	    ssid mijn_net wepmode on weptxkey 3 wepkey 3:0x3456789012
....

* De `weptxkey` geeft aan welke WEP-sleutel zal worden gebruikt tijdens het verzenden. Hier wordt de derde sleutel gebruikt. Dit dient overeen te komen met de instelling in het toegangspunt. Probeer, indien onbekend is welke sleutel door het toegangspunt wordt gebruikt, `1` (i.e., de eerste sleutel) voor deze waarde te gebruiken.
* De `wepkey` selecteert één van de WEP-sleutels in. Het dient in het formaat _index:sleutel_ te zijn. Sleutel `1` wordt als standaard gebruikt; de index hoeft alleen ingesteld te worden als we een andere dan de eerste sleutel gebruiken.
+
[NOTE]
====
De `0x3456789012` dient vervangen te worden door de sleutel die ingesteld is voor gebruik met het toegangspunt.
====

Het wordt aangeraden om de hulppagina man:ifconfig[8] te lezen voor verdere informatie.

De faciliteit `wpa_supplicant` kan ook gebruikt worden om de draadloze interface in te stellen voor WEP. Het bovenstaande voorbeeld kan worden ingesteld door de volgende regels toe te voegen aan [.filename]#/etc/wpa_supplicant.conf#:

[.programlisting]
....
network={
  ssid="mijn_net"
  key_mgmt=NONE
  wep_key3=3456789012
  wep_tx_keyidx=3
}
....

Daarna:

[source,bash]
....
# wpa_supplicant -i wlan0 -c /etc/wpa_supplicant.conf
Trying to associate with 00:13:46:49:41:76 (SSID='dlinkap' freq=2437 MHz)
Associated with 00:13:46:49:41:76
....

=== Ad-hoc-modus

IBSS-modus, ook ad-hoc-modus genoemd, is ontworpen voor point-to-point-verbindingen. Om bijvoorbeeld een ad-hoc-netwerk tussen de machine `A` en de machine `B` op te zetten, is het slechts nodig om twee IP-adressen en een SSID te kiezen.

Op machine `A`:

[source,bash]
....
# ifconfig wlan0 create wlandev ath0 wlanmode adhoc
# ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap
  wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500
	  ether 00:11:95:c3:0d:ac
	  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g <adhoc>
	  status: running
	  ssid freebsdap channel 2 (2417 Mhz 11g) bssid 02:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
	  protmode CTS wme burst
....

De parameter `adhoc` geeft aan dat de interface in de IBSS-modus draait.

Op `B` zal het mogelijk moeten zijn om `A` te detecteren:

[source,bash]
....
# ifconfig wlan0 create wlandev ath0 wlanmode adhoc
# ifconfig wlan0 up scan
  SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS
  reebsdap       02:11:95:c3:0d:ac    2   54M -64:-96  100 IS   WME
....

De `I` in de uitvoer bevestigt dat machine `A` in ad-hoc-modus verkeert. Het is slechts nodig om `B` met een ander IP-adres in te stellen:

[source,bash]
....
# ifconfig wlan0 inet 192.168.0.2 netmask 255.255.255.0 ssid freebsdap
# ifconfig wlan0 ssid freebsdap mediaopt adhoc inet 192.168.0.2 netmask 255.255.255.0
# ifconfig wlan0
  wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500
	  ether 00:11:95:d5:43:62
	  inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g <adhoc>
	  status: running
	  ssid freebsdap channel 2 (2417 Mhz 11g) bssid 02:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
	  protmode CTS wme burst
....

Zowel `A` als `B` zijn nu klaar om informatie uit te wisselen.

[[network-wireless-ap]]
=== FreeBSD Host Toegangspunten

FreeBSD kan als toegangspunt (AP) functioneren wat de noodzaak om een hardwarematig AP te kopen of een ad-hoc-netwerk te draaien wegneemt. Dit kan bijzonder nuttig zijn indien de FreeBSD-machine als gateway naar een ander netwerk (bijvoorbeeld het Internet) functioneert.

[[network-wireless-ap-basic]]
==== Basisinstellingen

Voordat de FreeBSD-machine als een AP wordt ingesteld, dient de kernel te worden ingesteld met de juiste ondersteuning voor draadloos netwerken voor de draadloze kaart. Ook dient er ondersteuning voor de te gebruiken beveiligingsprotocollen te worden toegevoegd. Meer details staan in <<network-wireless-basic>>.

[NOTE]
====
Momenteel staan de NDIS-stuurprogrammawrapper en de stuurprogramma's van Windows(R) het werken als AP niet toe. Alleen originele draadloze FreeBSD-stuurprogramma's ondersteunen AP-modus.
====

Wanneer de ondersteuning voor draadloos netwerken is geladen, kan gecontroleerd worden of het draadloze apparaat de hostgebaseerde toegangspuntmodus ondersteunt (ook bekend als hostap-modus):

[source,bash]
....
# ifconfig wlan0 create wlandev ath0
# ifconfig wlan0 list caps
drivercaps=6f85edc1<STA,FF,TURBOP,IBSS,HOSTAP,AHDEMO,TXPMGT,SHSLOT,SHPREAMBLE,MONITOR,MBSS,WPA1,WPA2,BURST,WME,WDS,BGSCAN,TXFRAG>
cryptocaps=1f<WEP,TKIP,AES,AES_CCM,TKIPMIC>
....

Deze uitvoer geeft de mogelijkheden van de kaart weer, het woord `HOSTAP` bevestigt dat deze draadloze kaart als toegangspunt kan functioneren. Ook worden verschillende ondersteunde versleutelmethoden genoemd: WEP, TKIP, AES, enzovoorts. Deze informatie is belangrijk om te weten welke beveiligingsprotocollen gebruikt kunnen worden op het toegangspunt.

Het draadloze apparaat kan enkel in hostap-modus worden gezet tijdens het creeëren van het netwerk pseudo-device dus een vooraf aangemaakt apparaat moet eerst verwijderd worden:

[source,bash]
....
# ifconfig wlan0 destroy
....

waarna deze opnieuw aangemaakt kan worden met de juiste parameters:

[source,bash]
....
# ifconfig wlan0 create wlandev ath0 wlanmode hostap
# ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap mode 11g channel 1
....

Gebruik nogmaals `ifconfig` om de status van de interface [.filename]#wlan0# te zien:

[source,bash]
....
# ifconfig wlan0
  wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500
	  ether 00:11:95:c3:0d:ac
	  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
	  status: running
	  ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
	  protmode CTS wme burst dtimperiod 1 -dfs
....

De parameter `hostap` geeft aan dat de interface in hostgebaseerde toegangspuntmodus draait.

Het instellen van de interface kan automatisch tijdens het opstarten gedaan worden door de volgende regels aan [.filename]#/etc/rc.conf# toe te voegen:

[.programlisting]
....
wlans_ath0="wlan0"
create_args_wlan0="wlanmode hostap"
ifconfig_wlan0="inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap mode 11g channel 1"
....

==== Hostgebaseerde toegangspunt zonder authenticatie of versleuteling

Hoewel het niet aangeraden wordt om een AP zonder enige vorm van authenticatie of encryptie te draaien, is dit een eenvoudige manier om te controleren of het AP werkt. Deze configuratie is ook belangrijk voor het debuggen van problemen met cliënten.

Nadat het AP is ingesteld als eerder is laten zien, is het mogelijk om van een andere draadloze machine een scan te beginnen om het AP te vinden:

[source,bash]
....
# ifconfig wlan0 create wlandev ath0
# ifconfig wlan0 up scan
SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS
freebsdap       00:11:95:c3:0d:ac    1   54M -66:-96  100 ES   WME
....

De cliëntmachine heeft het AP gevonden en kan ermee geassocieerd worden:

[source,bash]
....
# ifconfig ath0 ssid freebsdap inet 192.168.0.2 netmask 255.255.255.0
  ifconfig wlan0
  wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500
	  ether 00:11:95:d5:43:62
	  inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet OFDM/54Mbps mode 11g
	  status: associated
	  ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy OFF txpower 21.5 bmiss 7
	  scanvalid 60 bgscan bgscanintvl 300 bgscanidle 250 roam:rssi 7
	  roam:rate 5 protmode CTS wme burst
....

==== WPA hostgebaseerde toegangspunt

Deze sectie zal zich richten op opzetten van een FreeBSD toegangspunt dat het beveiligingsprotocol WPA gebruikt. Meer details over WPA en het instellen van op WPA gebaseerde draadloze cliënten kan gevonden worden in <<network-wireless-wpa>>.

De daemon hostapd wordt gebruikt om cliëntauthenticatie en sleutelbeheer op het toegangspunt met WPA af te handelen.

In het volgende zullen alle instellingsbewerkingen worden uitgevoerd op de FreeBSD-machine die als AP dienst doet. Wanneer het AP correct werkt, zou hostapd automatisch tijdens het opstarten aangezet moeten worden met de volgende regel in [.filename]#/etc/rc.conf#:

[.programlisting]
....
hostapd_enable="YES"
....

Zorg ervoor dat voordat geprobeerd wordt om hostapd in te stellen, de basisinstellingen die in <<network-wireless-ap-basic>> zijn geïntroduceerd zijn uitgevoerd.

===== WPA-PSK

WPA-PSK is bedoeld voor kleine netwerken waar het gebruik van een achterliggende authenticatieserver niet mogelijk of gewenst is.

Het instellen wordt gedaan in het bestand [.filename]#/etc/hostapd.conf#:

[.programlisting]
....
interface=wlan0 <.>
debug=1 <.>
ctrl_interface=/var/run/hostapd <.>
ctrl_interface_group=wheel <.>
ssid=freebsdap <.>
wpa=1 <.>
wpa_passphrase=freebsdmall <.>
wpa_key_mgmt=WPA-PSK <.>
wpa_pairwise=CCMP TKIP <.>
....

<.> Dit veld geeft aan welke draadloze interface voor het toegangspunt wordt gebruikt.

<.> Dit veld stelt het verbositeitsniveau in dat tijdens het draaien van hostapd wordt gebruikt. Een waarde van `1` vertegenwoordigt het minimale niveau.

<.> Het veld `ctrl_interface` geeft de padnaam van de door hostapd gebruikte map om de domeinsocketbestanden voor communicatie met externe programma's zoals man:hostapd_cli[8] in op te slaan. Hier wordt de standaardwaarde gebruikt.

<.> De regel `ctrl_interface_group` stelt de groep in (hier is het de groep `wheel`) die toegang heeft tot de controle interfacebestanden.

<.> Het veld `wpa` maakt WPA mogelijk en specificeert welk WPA-authenticatieprotocol nodig zal zijn. De waarde `1` stelt het AP in op WPA-PSK.

<.> Het veld `wpa_passphrase` bevat het ASCII-wachtwoord voor de WPA-authenticatie.

<.> De regel `wpa_key_mgmt` verwijst naar het gebruikte sleutelbeheerprotocol. In dit geval is dat WPA-PSK.

<.> Het veld `wpa_pairwise` geeft aan welke versleutelingsalgoritmes door het toegangspunt worden geaccepteerd. Hier worden zowel de versleuteling TKIP (WPA) en CCMP (WPA2) geaccepteerd. De versleuteling CCMP is een alternatief voor TKIP en wordt sterk aangeraden indien mogelijk; TKIP dient alleen gebruikt te worden voor stations die geen CCMP aankunnen.

De volgende stap is het starten van hostapd:

[source,bash]
....
# service hostapd forcestart
....

[source,bash]
....
# ifconfig wlan0
  wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 2290
	  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255dddd
	  inet6 fe80::211:95ff:fec3:dac%ath0 prefixlen 64 scopeid 0x4
	  ether 00:11:95:c3:0d:ac
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g <hostap>
	  status: associated
	  ssid freebsdap channel 1 bssid 00:11:95:c3:0d:ac
	  authmode WPA2/802.11i privacy MIXED deftxkey 2 TKIP 2:128-bit txpowmax 36 protmode CTS dtimperiod 1 bintval 100
....

Het toegangspunt draait nu, de cliënten kunnen er nu mee worden geassocieerd, zie <<network-wireless-wpa>> voor meer details. Het is mogelijk om de stations die met het AP geassocieerd zijn te zien door het commando `ifconfig wlan0 list` te gebruiken.

==== WEP hostgebaseerd toegangspunt

Het wordt niet aangeraden om WEP te gebruiken om een toegangspunt op te zetten aangezien er geen authenticatiemechanisme is en het gemakkelijk is te kraken. Sommige verouderde draadloze kaarten ondersteunen alleen WEP als een beveiligingsprotocol, met deze kaarten is het alleen mogelijk om een AP zonder authenticatie of encryptie of een AP dat het WEP-protocol gebruikt op te zetten.

Het draadloze apparaat kan nu in hostap-modus worden gezet en ingesteld worden met het juiste SSID en IP-adres:

[source,bash]
....
# ifconfig wlan0 create wlandev ath0 wlanmode hostap
# ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 \
  ssid freebsdap wepmode on weptxkey 3 wepkey 3:0x3456789012 mode 11g
....

* Het `weptxkey` geeft aan welke WEP-sleutel tijdens het zenden zal worden gebruikt. Hier wordt de derde sleutel gebruikt (merk op dat de nummering van de sleutels bij `1` begint). Deze parameter moet gespecificeerd worden om de gegevens daadwerkelijk te versleutelen.
* Het `wepkey` geeft aan dat de geselecteerde WEP-sleutel wordt ingesteld. Het dient in het formaat _index:key_ te zijn, indien de index niet is gegeven, wordt sleutel `1` gebruikt. Dus indien een andere sleutel dan de eerste wordt gebruikt dient de index te worden ingesteld.

Weer wordt `ifconfig` gebruikt om de status van de interface [.filename]#wlan0# te zien:

[source,bash]
....
# ifconfig wlan0
  wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500
	  ether 00:11:95:c3:0d:ac
	  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g <hostap>
	  status: running
	  ssid freebsdap channel 4 (2427 Mhz 11g) bssid 00:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy ON deftxkey 3 wepkey 3:40-bit
	  txpower 21.5 scanvalid 60 protmode CTS wme burst dtimperiod 1 -dfs
....

Vanaf een andere draadloze machine is het mogelijk om een scan te beginnen om het AP te vinden:

[source,bash]
....
# ifconfig wlan0 create wlandev ath0
# ifconfig wlan0 up scan
SSID            BSSID              CHAN RATE  S:N   INT CAPS
freebsdap       00:11:95:c3:0d:ac    1   54M 22:1   100 EPS
....

De cliëntmachine heeft het toegangspunt gevonden en kan ermee geassocieerd worden door de juiste parameters (sleutel, enz.) te gebruiken, zie <<network-wireless-wep>> voor meer details.

=== Zowel de bekabelde als de draadloze verbinding gebruiken

Een bekabelde verbinding biedt betere prestaties en betrouwbaarheid, terwijl een draadloze verbinding meer flexibiliteit en mobiliteit biedt; laptop-gebruikers zullen dit willen combineren en naadloos tussen de twee overschakelen.

In FreeBSD is het mogelijk om twee of meer netwerkinterfaces te combineren in een "failover"-opstelling, dit houdt in dat de meest geprefereerde en best beschikbare verbinding van een groep van netwerkinterfaces wordt gebruikt, en het besturingssysteem automatisch te laten overschakelen wanneer de status van de verbinding verandert.

Link-aggregatie en failover worden behandeld in <<network-aggregation>>, een voorbeeld voor het gebruik van zowel een bekabelde als een draadloze verbinding wordt gegeven in <<networking-lagg-wired-and-wireless>>.

=== Problemen verhelpen

Indien er problemen met het draadloos netwerk zijn, zijn er een aantal stappen die genomen kunnen worden om het probleem te helpen verhelpen.

* Indien het toegangspunt niet vermeld wordt tijdens het scannen, controleer dan of het draadloze apparaat niet is ingesteld op een beperkt aantal kanalen.
* Indien het niet mogelijk is om met een toegangspunt te associëren, controleer dan of de instellingen van het station overeenkomen met die van het toegangspunt. Dit omvat het authenticatieschema en de beveiligingsprotocollen. Versimpel de configuratie zoveel mogelijk. Indien een beveiligingsprotocol als WPA of WEP wordt gebruikt, stel het toegangspunt dan in voor open authenticatie en geen beveiliging en kijk of er verkeer door kan.
* Wanneer er met het toegangspunt geassocieerd kan worden, stel dan een diagnose over alle beveiligingsinstellingen met eenvoudige gereedschappen zoals man:ping[8].
+ 
`wpa_supplicant` biedt veel ondersteuning voor debuggen; probeer het handmatig te draaien met de optie `-dd` en controleer de systeemlogs.
* Er zijn ook veel debug-gereedschappen op lagere niveaus. Het is mogelijk om debugberichten in de laag die het 802.11 protocol ondersteunt aan te zetten door het programma `wlandebug` te gebruiken dat gevonden wordt in [.filename]#/usr/src/tools/tools/net80211#. Bijvoorbeeld:
+
[source,bash]
....
# wlandebug -i ath0 +scan+auth+debug+assoc
  net.wlan.0.debug: 0 => 0xc80000<assoc,auth,scan>
....
+ 
kan worden gebruikt om consoleberichten aan te zetten die te maken hebben met het scannen van toegangspunten en het uitvoeren van 802.11 handshakes die nodig zijn om communicatie te regelen.
+ 
Er worden ook veel nuttige statistieken door de 802.11 laag bijgehouden; het gereedschap `wlanstats` geeft deze informatie weer. Deze statistieken zouden alle fouten die door de 802.11 laag zijn geïdentificeerd moeten identificeren. Let erop dat sommige fouten worden geïdentificeerd in de apparaatstuurprogramma's die onder de 802.11 laag liggen zodat ze niet verschijnen. Voor het diagnosticeren van apparaatspecifieke problemen dient de documentatie van het stuurprogramma geraadpleegd te worden.

Indien de bovenstaande informatie niet helpt om het probleem te verhelderen, stuur dan een probleemrapport op inclusief de uitvoer van de bovenstaande gereedschappen.

[[network-bluetooth]]
== Bluetooth

=== Introductie

Bluetooth is een draadloze technologie om persoonlijke netwerken aan te maken die in de vrije 2,4GHz-band werken binnen een straal van 10 meter. Deze netwerken worden gewoonlijk ad-hoc gevormd en bestaan uit draagbare apparaten zoals mobiele telefoons, handhelds en laptops. In tegenstelling tot die andere populaire draadloze techniek, Wi-Fi, biedt Bluetooth een hoger niveau van serviceprofielen, zoals FTP-achtige bestandsservers, pushing van bestanden, stemtransport, emulatie van seriële lijnen, en meer.

De Bluetooth stack is in FreeBSD geïmplementeerd door gebruik te maken van het Netgraph-raamwerk (zie man:netgraph[4]). Veel van de Bluetooth USB-dongles worden ondersteund door het stuurprogramma man:ng_ubt[4]. Apparaten gebaseerd op de Broadcom BCM2033 chip worden ondersteund door de stuurprogramma's man:ubtbcmfw[4] en man:ng_ubt[4]. De 3Com Bluetooth PC Card 3CRWB60-A wordt ondersteund door het stuurprogramma man:ng_bt3c[4]. Seriële en op UART gebaseerde Bluetooth-apparaten worden ondersteund via man:sio[4], man:ng_h4[4], en man:hcseriald[8]. Deze sectie beschrijft het gebruik van de USB Bluetooth-dongle.

=== Het apparaat inprikken

Standaard zijn stuurprogramma's voor Bluetooth-apparaten beschikbaar als kernelmodules. Voordat een apparaat wordt aangekoppeld, dient het stuurprogramma in de kernel geladen te worden:

[source,bash]
....
# kldload ng_ubt
....

Indien het Bluetooth-apparaat tijdens het opstarten van het systeem in het systeem aanwezig is, kan de module vanuit [.filename]#/boot/loader.conf# geladen worden:

[.programlisting]
....
ng_ubt_load="YES"
....

Prik de USB-dongle in. Uitvoer vergelijkbaar aan de onderstaande zal op de console (of in syslog) verschijnen:

[source,bash]
....
ubt0: vendor 0x0a12 product 0x0001, rev 1.10/5.25, addr 2
ubt0: Interface 0 endpoints: interrupt=0x81, bulk-in=0x82, bulk-out=0x2
ubt0: Interface 1 (alt.config 5) endpoints: isoc-in=0x83, isoc-out=0x3,
      wMaxPacketSize=49, nframes=6, buffer size=294
....

man:service[8] wordt gebruikt om de Bluetooth-stack te starten en te stoppen. Het is een goed idee om de stack te stoppen voordat het apparaat wordt losgekoppeld, maar het is (gewoonlijk) niet fataal. Tijdens het starten van de stack verschijnt er uitvoer vergelijkbaar met de onderstaande:

[source,bash]
....
# service bluetooth start ubt0
BD_ADDR: 00:02:72:00:d4:1a
Features: 0xff 0xff 0xf 00 00 00 00 00
<3-Slot> <5-Slot> <Encryption> <Slot offset>
<Timing accuracy> <Switch> <Hold mode> <Sniff mode>
<Park mode> <RSSI> <Channel quality> <SCO link>
<HV2 packets> <HV3 packets> <u-law log> <A-law log> <CVSD>
<Paging scheme> <Power control> <Transparent SCO data>
Max. ACL packet size: 192 bytes
Number of ACL packets: 8
Max. SCO packet size: 64 bytes
Number of SCO packets: 8
....

=== Host Controller Interface (HCI)

Het Host Controller Interface (HCI) biedt een opdrachtinterface naar de controller van de basisband en de verbindingsbeheerder, en toegang tot hardwarestatus en controleregisters. Deze interface biedt een uniforme manier om de mogelijkheden van de basisband van Bluetooth te benaderen. De HCI-laag op de gastheer wisselt gegevens en opdrachten uit met de HCI-firmware in de Bluetooth-hardware. Het stuurprogramma voor de Host Controller Transport Layer (i.e., de fysieke bus) biedt aan beide HCI-lagen de mogelijkheid om informatie met elkaar uit te wisselen.

Voor een enkel Bluetooth-apparaat wordt een enkele Netgraph knoop van het type _hci_ aangemaakt. De HCI-knoop is normaliter verbonden met de knoop van het Bluetooth-apparaatstuurprogramma (naar beneden toe) en de L2CAP-knoop (naar boven toe). Alle HCI-bewerkingen dienen te worden uitgevoerd op de HCI-knoop en niet op de knoop van het apparaatstuurprogramma. De standaardnaam voor de HCI-knoop is "devicehci". Kijk voor meer details in de hulppagina man:ng_hci[4].

Eén van de meest voorkomende taken is het ontdekken van Bluetooth-apparaten binnen radiobereik. Deze bewerking wordt _ondervragen_ genoemd. Ondervragen en andere HCI-gerelateerde bewerkingen worden uitgevoerd met het programma man:hccontrol[8]. Het onderstaande voorbeeld laat zien hoe kan worden uitgezocht welke Bluetooth-apparaten zich binnen het bereik bevinden. De lijst met apparaten zou binnen enkele seconden moeten binnenkomen. Bedenk dat een apparaat op afstand alleen antwoord op de ondervraging zal geven indien het in _ontdekbare_ modus staat.

[source,bash]
....
% hccontrol -n ubt0hci inquiry
Inquiry result, num_responses=1
Inquiry result #0
       BD_ADDR: 00:80:37:29:19:a4
       Page Scan Rep. Mode: 0x1
       Page Scan Period Mode: 00
       Page Scan Mode: 00
       Class: 52:02:04
       Clock offset: 0x78ef
Inquiry complete. Status: No error [00]
....

`BD_ADDR` is een uniek adres van een Bluetooth-apparaat, vergelijkbaar met een MAC-adres van een netwerkkaart. Dit adres is nodig voor verdere communicatie met een apparaat. Het is mogelijk om een menselijk leesbare naam aan een BD_ADDR toe te kennen. Het bestand [.filename]#/etc/bluetooth/hosts# bevat informatie over de bekende Bluetooth-gastheren. Het volgende voorbeeld laat zien hoe de menselijk leesbare naam dat aan het apparaat op afstand was toegekend te verkrijgen is:

[source,bash]
....
% hccontrol -n ubt0hci remote_name_request 00:80:37:29:19:a4
BD_ADDR: 00:80:37:29:19:a4
Name: Pav's T39
....

Tijdens het uitvoeren van een ondervraging op een Bluetooth-apparaat op afstand zal het de computer als "uw.gastheer.naam (ubt0)" vinden. De naam die aan het lokale apparaat is toegekend, kan altijd gewijzigd worden.

Het Bluetooth-systeem biedt een punt-naar-punt-verbinding (slechts twee Bluetooth-eenheden betrokken), of een punt-naar-veelpunt-verbinding. Bij een punt-naar-veelpunt-verbinding wordt de verbinding met meerdere Bluetooth-apparaten gedeeld. Het volgende voorbeeld laat zien hoe de lijst met actieve basisbandverbindingen voor het lokale apparaat te verkrijgen is:

[source,bash]
....
% hccontrol -n ubt0hci read_connection_list
Remote BD_ADDR    Handle Type Mode Role Encrypt Pending Queue State
00:80:37:29:19:a4     41  ACL    0 MAST    NONE       0     0 OPEN
....

Een _verbindingshandvat_ is nuttig indien het beëindigen van de basisbandverbinding noodzakelijk is. Normaalgesproken is het niet nodig om dit handmatig te doen. De stack zal automatisch niet-actieve basisbandverbindingen beëindigen.

[source,bash]
....
# hccontrol -n ubt0hci disconnect 41
Connection handle: 41
Reason: Connection terminated by local host [0x16]
....

Raadpleeg `hccontrol help` voor een volledige lijst van beschikbare HCI-opdrachten. Voor de meeste HCI-opdrachten zijn geen beheerdersrechten nodig.

=== Logical Link Control and Adaptation Protocol (L2CAP)

Het Logical Link Control and Adaptation Protocol (L2CAP) biedt verbindingsgeoriënteerde en verbindingsloze gegevensdiensten met mogelijkheden om protocollen te multiplexen en mogelijkheden voor segmentatie/herassemblage voor protocollen in hogere lagen. L2CAP staat toe dat protocollen en toepassingen in hogere lagen L2CAP-gegevenspakketten met een maximale lengte van 64 kB te verzenden en ontvangen.

L2CAP is op het concept van _kanalen_ gebaseerd. Een kanaal is een logische verbinding bovenop een basisbandverbinding. Elk kanaal is op een veel-op-één manier aan een enkel protocol gebonden. Aan hetzelfde protocol kunnen meerdere kanalen worden gebonden, maar één kanaal kan niet aan meerdere protocollen worden gebonden. Elk L2CAP-pakket dat op een kanaal wordt ontvangen, wordt naar het juiste hogere protocol doorgestuurd. Meerdere kanalen kunnen dezelfde basisbandverbinding delen.

Voor elk Bluetooth-apparaat wordt een enkele Netgraph-knoop van het soort _l2cap_ aangemaakt. De L2CAP-knoop is normaalgesproken verbonden met de Bluetooth HCI-knoop (naar beneden toe) en de knopen van de stopcontacten voor Bluetooth (naar boven toe). De standaardnaam voor de L2CAP-knoop is "devicel2cap". Zie voor meer details de hulppagina man:ng_l2cap[4].

Een nuttig commando is man:l2ping[8], dat gebruikt kan worden om andere apparaten te pingen. Sommige Bluetooth-implementaties geven niet alle verzonden gegevens terug, dus is `0 bytes` normaal in het volgende voorbeeld.

[source,bash]
....
# l2ping -a 00:80:37:29:19:a4
0 bytes from 0:80:37:29:19:a4 seq_no=0 time=48.633 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=1 time=37.551 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=2 time=28.324 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=3 time=46.150 ms result=0
....

Met het programma man:l2control[8] kunnen verschillende bewerkingen op L2CAP-knopen worden uitgevoerd. Dit voorbeeld laat zien hoe de lijst met logische verbindingen (kanalen) en de lijst met basisbandverbindingen voor het lokale apparaat verkregen kunnen worden:

[source,bash]
....
% l2control -a 00:02:72:00:d4:1a read_channel_list
L2CAP channels:
Remote BD_ADDR     SCID/ DCID   PSM  IMTU/ OMTU State
00:07:e0:00:0b:ca    66/   64     3   132/  672 OPEN
% l2control -a 00:02:72:00:d4:1a read_connection_list
L2CAP connections:
Remote BD_ADDR    Handle Flags Pending State
00:07:e0:00:0b:ca     41 O           0 OPEN
....

Een ander diagnostisch programma is man:btsockstat[1]. Het heeft ongeveer hetzelfde doel als man:netstat[1], maar dan voor Bluetooth-netwerkgerelateerde gegevensstructuren. Het onderstaande voorbeeld laat dezelfde logische verbinding zien als die van man:l2control[8] hierboven.

[source,bash]
....
% btsockstat
Active L2CAP sockets
PCB      Recv-Q Send-Q Local address/PSM       Foreign address   CID   State
c2afe900      0      0 00:02:72:00:d4:1a/3     00:07:e0:00:0b:ca 66    OPEN
Active RFCOMM sessions
L2PCB    PCB      Flag MTU   Out-Q DLCs State
c2afe900 c2b53380 1    127   0     Yes  OPEN
Active RFCOMM sockets
PCB      Recv-Q Send-Q Local address     Foreign address   Chan DLCI State
c2e8bc80      0    250 00:02:72:00:d4:1a 00:07:e0:00:0b:ca 3    6    OPEN
....

=== Het RFCOMM-protocol

Het RFCOMM-protocol biedt emulatie van seriële poorten over het L2CAP-protocol. Het protocol is gebaseerd op de ETSI-standaard TS 07.10. RFCOMM is een eenvoudig transportprotocol, met aanvullende voorzieningen om de 9 circuits van RS-232- (EIATIA-232-E-) seriële poorten te emuleren. Het RFCOMM-protocol ondersteunt tot 60 gelijktijdige verbindingen (RFCOMM-kanalen) tussen twee Bluetooth-apparaten.

Het is de bedoeling van RFCOMM dat in een volledig communicatiepad twee toepassingen op verschillende apparaten draaien (de eindpunten van de communicatie) met daartussen een communicatiesegment. RFCOMM is bedoeld om de toepassingen te beheren die gebruik maken van de seriële poorten van de apparaten waarop ze zijn geïnstalleerd. Het communicatiesegment is een directe Bluetooth-verbinding van het ene apparaat naar het andere.

RFCOMM houdt zich alleen bezig met de verbinding tussen twee apparaten bij directe verbindingen, of tussen het apparaat en een modem in het geval van een netwerk. RFCOMM kan andere opstellingen ondersteunen, zoals modules die via draadloze Bluetooth-technologie communiceren aan de ene kant, en een draadinterface aanbieden aan de andere kant.

In FreeBSD is het RFCOMM-protocol in de laag van de Bluetooth-stopcontacten geïmplementeerd.

=== Het paren van apparaten

Standaard is Bluetooth-communicatie niet geauthenticeerd en kan elk apparaat met elk ander apparaat praten. Een Bluetooth-apparaat (bijvoorbeeld een mobiele telefoon) kan ervoor kiezen dat voor bepaalde diensten authenticatie nodig is (bijvoorbeeld voor de inbeldienst). Bluetooth-authenticatie geschied normaalgesproken met _PIN-codes_. Een PIN-code is een ACII-reeks van maximaal 16 tekens lang. De gebruiker dient dezelfde PIN-code op beide apparaten in te voeren. Nadat de gebruiker de PIN-code heeft ingevoerd, zullen beide apparaten een _verbindingssleutel_ aanmaken. Hierna kan de verbindingssleutel òfwel in de apparaten zelf, òfwel in een permanente opslag worden opgeslagen. De volgende keer zullen beide apparaten de van tevoren aangemaakte verbindingssleutel gebruiken. Bovenstaande procedure wordt _paren_ genoemd. Merk op dat indien een apparaat de verbindingssleutel verliest, het paren moet worden herhaald.

De daemon man:hcsecd[8] is verantwoordelijk voor het behandelen van alle verzoeken voor Bluetooth-authenticatie. Het standaard instellingenbestand is [.filename]#/etc/bluetooth/hcsecd.conf#. Een voorbeeldsectie voor een mobiele telefoon waarvan de PIN-code willekeurig op "1234" is hieronder beschreven:

[.programlisting]
....
device {
	bgaddr	00:80:37:29:19:a4;
	name	"Pav's T39";
	key	nokey;
	pin	"1234";
      }
....

Er is geen limiet voor PIN-codes (behalve de lengte). Voor sommige apparaten (bijvoorbeeld Bluetooth-headsets) kan de PIN-code vast zijn ingebouwd. De schakelaar `-d` dwingt de daemon man:hcsecd[8] om op de voorgrond te blijven, zodat het gemakkelijk is om te zien wat er gebeurt. Stel het andere apparaat in om paarverzoeken te ontvangen en initialiseer de Bluetooth-verbinding naar het andere apparaat. Het apparaat moet zeggen dat het paarverzoek geaccepteerd is en om de PIN-code vragen. Geef dezelfde PIN-code op als in [.filename]#hcsecd.conf#. Nu zijn de PC en het andere apparaat gepaard. Als alternatief kan paren op het andere apparaat worden geïnitialiseerd.

De volgende regel kan aan het bestand [.filename]#/etc/rc.conf# worden toegevoegd om hcsecd automatisch met het systeem op te starten:

[.programlisting]
....
hcsecd_enable="YES"
....

Het volgende is een voorbeeld van de uitvoer van de daemon hcsecd:

[.programlisting]
....
hcsecd[16484]: Got Link_Key_Request event from 'ubt0hci', remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name 'Pav's T39', link key doesn't exist
hcsecd[16484]: Sending Link_Key_Negative_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Got PIN_Code_Request event from 'ubt0hci', remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name 'Pav's T39', PIN code exists
hcsecd[16484]: Sending PIN_Code_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4
....

=== Service Discovery Protocol (SDP)

Het Service Discovery Protocol (SDP) biedt voor cliënttoepassingen de mogelijkheid om diensten te ontdekken die door servertoepassingen worden aangeboden alsook de kenmerken van deze diensten. De kenmerken van een dienst omvatten de soort of klasse van de aangeboden dienst en de informatie over het mechanisme of protocol dat nodig is om de dienst te gebruiken.

SDP omvat communicatie tussen een SDP-server en een SDP-cliënt. De server houdt een lijst van dienstenregistraties bij die de eigenschappen van de diensten beschrijven die met de server geassocieerd zijn. Elke dienstregistratie bevat informatie over een enkele dienst. Een cliënt kan informatie over een dienstregistratie opvragen die door de SDP-server wordt bijgehouden door een SDP-verzoek in te dienen. Indien de cliënt, of een toepassing die met de cliënt geassocieerd is, besluit om de dienst te gebruiken, moet het een aparte verbinding naar de aanbieder van de dienst openen om de dienst te gebruiken. SDP biedt een mechanisme om diensten en hun attributen te ontdekken, maar het biedt geen mechanisme om die diensten te gebruiken.

Normaalgesproken zoekt een SDP-cliënt naar diensten naar aanleiding van enkele gewenste eigenschappen van die diensten. Soms is het echter wenselijk om te ontdekken welke soorten diensten door de dienstregistraties van een SDP-server worden beschreven zonder enige voorkennis van deze diensten. Dit kijken naar alle aangeboden diensten wordt _browsen_ genoemd.

De Bluetooth SDP-server man:sdpd[8] en de opdrachtregelcliënt man:sdpcontrol[8] zitten in de standaard FreeBSD-installatie. Het volgende voorbeeld laat zien hoe een SDP-browse query uit te voeren.

[source,bash]
....
% sdpcontrol -a 00:01:03:fc:6e:ec browse
Record Handle: 00000000
Service Class ID List:
        Service Discovery Server (0x1000)
Protocol Descriptor List:
        L2CAP (0x0100)
                Protocol specific parameter #1: u/int/uuid16 1
                Protocol specific parameter #2: u/int/uuid16 1

Record Handle: 0x00000001
Service Class ID List:
        Browse Group Descriptor (0x1001)

Record Handle: 0x00000002
Service Class ID List:
        LAN Access Using PPP (0x1102)
Protocol Descriptor List:
        L2CAP (0x0100)
        RFCOMM (0x0003)
                Protocol specific parameter #1: u/int8/bool 1
Bluetooth Profile Descriptor List:
        LAN Access Using PPP (0x1102) ver. 1.0
....

... enzovoorts. Merk op dat elke dienst een lijst met attributen heeft (bijvoorbeeld een RFCOMM-kanaal). Afhankelijk van de dienst kan het nodig zijn om een aantekening van sommige attributen te maken. Sommige Bluetooth-implementaties ondersteunen dienst-browsen niet en zullen een lege lijst teruggeven. In dit geval is het mogelijk om naar de specifieke dienst te zoeken. Het onderstaande voorbeeld laat zien hoe naar de dienst OBEX Object Push (OPUSH) gezocht kan worden:

[source,bash]
....
% sdpcontrol -a 00:01:03:fc:6e:ec search OPUSH
....

Het aanbieden van diensten op FreeBSD aan Bluetooth-cliënten wordt gedaan met de server man:sdpd[8]. De volgende regel kan aan het bestand [.filename]#/etc/rc.conf# worden toegevoegd:

[.programlisting]
....
sdpd_enable="YES"
....

Het daemon sdpd kan worden gestart met:

[source,bash]
....
# service sdpd start
....

De plaatselijke servertoepassing die Bluetooth-diensten wil aanbieden aan verre cliënten zal de dienst registreren bij de plaatselijke SDP-daemon. Een voorbeeld van zo'n toepassing is man:rfcomm_pppd[8]. Nadat het gestart is zal het de Bluetooth LAN-dienst bij de plaatselijke SDP-daemon registreren.

De lijst met diensten die bij de plaatselijke SDP-server zijn geregistreerd kan worden opgevraagd door te SDP-browsen via het plaatselijke controlekanaal:

[source,bash]
....
# sdpcontrol -l browse
....

=== Dial-Up Networking (DUN) en netwerktoegang met PPP (LAN) profielen

Het inbelnetwerk (DUN) profiel wordt het meeste gebruikt met modems en mobiele telefoons. De volgende scenario's worden in dit profiel behandeld:

* het gebruik van een mobiele telefoon of modem door een computer als een draadloze modem voor het verbinden met een inbelserver voor Internet-toegang, of voor andere inbeldiensten;
* het gebruik van een mobiele telefoon of modem door een computer om gegevensoproepen te ontvangen.

Het profiel voor netwerktoegang met PPP (LAN) kan in de volgende situaties gebruikt worden:

* LAN-toegang voor een enkel Bluetooth-apparaat;
* LAN-toegang voor meerdere Bluetooth-apparaten;
* PC naar PC (door PPP-netwerken over een seriële kabel te emuleren).

Op FreeBSD zijn beide profielen geïmplementeerd met man:ppp[8] en man:rfcomm_pppd[8] - een wrapper die een RFCOMM Bluetooth-verbinding omzet in iets waar PPP mee overweg kan. Voordat een profiel gebruikt kan worden, dient een nieuw PPP-label in het bestand [.filename]#/etc/ppp/ppp.conf# te worden aangemaakt. Raadpleeg de hulppagina man:rfcomm_pppd[8] voor voorbeelden.

In het volgende voorbeeld zal man:rfcomm_pppd[8] gebruikt worden om RFCOMM-verbinding met een ver apparaat met BD_ADDR 00:80:37:29:19:a4 op een DUN RFCOMM-kanaal te maken. Het eigenlijke RFCOMM-kanaalnummer wordt via SDP van het verre apparaat verkregen. Het is mogelijk om het RFCOMM-kanaal handmatig op te geven, en in dat geval zal man:rfcomm_pppd[8] het SDP-verzoek niet uitvoeren. Gebruik man:sdpcontrol[8] om het RFCOMM-kanaal op het verre apparaat te achterhalen.

[source,bash]
....
# rfcomm_pppd -a 00:80:37:29:19:a4 -c -C dun -l rfcomm-dialup
....

Om netwerktoegang met PPP (LAN) aan te bieden moet de server man:sdpd[8] draaien. Er dient een nieuwe regel voor LAN-cliënten in het bestand [.filename]#/etc/ppp/ppp.conf# aangemaakt te worden. Raadpleeg de hulppagina man:rfcomm_pppd[8] voor voorbeelden. Tenslotte dient de RFCOMM PPP-server op een geldig RFCOMM-kanaal gestart te worden. De RFCOMM PPP-server zal automatisch de Bluetooth LAN-dienst bij de plaatselijke SDP-daemon registreren. Het volgende voorbeeld laat zien hoe een RFCOMM PPP-server te starten:

[source,bash]
....
# rfcomm_pppd -s -C 7 -l rfcomm-server
....

=== Het OBEX Object Push (OPUSH) profiel

OBEX is een veelgebruikt protocol voor eenvoudige bestandsoverdrachten tussen mobiele apparaten. Het primaire gebruik is infraroodcommunicatie, waar het wordt gebruikt voor generieke bestandsoverdrachten tussen notebooks of PDA's, en om visitekaarten en kalenderregels tussen mobiele telefoons en andere apparaten met PIM-toepassingen over te dragen.

De OBEX-server en clieënt zijn geïmplenteerd als een pakket van derde partij, obexapp, dat beschikbaar is als de port package:comms/obexapp[].

De OBEX-cliënt wordt gebruikt om objecten naar en/of van de OBEX-server te duwen/trekken. Een object kan bijvoorbeeld een visitekaart of een afspraak zijn. De OBEX-cliënt kan het RFCOMM-kanaalnummer van het verre apparaat via SDP opvragen. Dit kan gedaan worden door de dienstnaam in plaats van het RFCOMM-kanaalnummer op te geven. De ondersteunde dienstnamen zijn: IrMC, FTRN, en OPUSH. Het is mogelijk om het RFCOMM-kanaal als een nummer op te geven. Het onderstaande is een voorbeeld van een OBEX-sessie, waar een apparaatinformatie-object van de mobiele telefoon wordt getrokken, en een nieuw object (een visitekaart) in de gids van de telefoon wordt geduwd:

[source,bash]
....
% obexapp -a 00:80:37:29:19:a4 -C IrMC
obex> get telecom/devinfo.txt devinfo-t39.txt
Success, response: OK, Success (0x20)
obex> put new.vcf
Success, response: OK, Success (0x20)
obex> di
Success, response: OK, Success (0x20)
....

Om de dienst OBEX Object Push aan te bieden, moet de server man:sdpd[8] draaien. Er moet een hoofdmap worden aangemaakt waarin alle binnenkomende objecten worden opgeslagen. Het standaardpad naar de hoofdmap is [.filename]#/var/spool/obex#. Tenslotte moet de OBEX-server op een geldig RFCOMM-kanaal worden gestart. De OBEX-server zal automatisch de dienst OBEX Object Push bij de plaatselijke SDP-daemon registeren. Het onderstaande voorbeeld laat zien hoe de OBEX-server gestart wordt:

[source,bash]
....
# obexapp -s -C 10
....

=== Serial Port Profile (SPP)

Het Seriële Poort Profiel (SPP) zorgt ervoor dat Bluetooth-apparaten RS232 (of gelijkwaardige) seriële kabels kunnen emuleren. Het scenario dat dit profiel behandelt zorgt ervoor dat oude toepassingen Bluetooth kunnen gebruiken als vervanging van kabels, door gebruik te maken van een virtuele seriële poort.

Het programma man:rfcomm_sppd[1] implementeert het Seriële Poort profiel. Een pseudo-tty wordt gebruikt als abstractie voor een virtuele seriële poort. Onderstaand voorbeeld laat zien hoe met een Seriële Poortdienst voor verre apparaten te verbinden. Merk op dat het niet nodig is om een RFCOMM-kanaal te kiezen - man:rfcomm_sppd[1] kan het via SDP van het verre apparaat verkrijgen. Dit kan worden overruled door een RFCOMM-kanaal op de opdrachtregel te specificeren.

[source,bash]
....
# rfcomm_sppd -a 00:07:E0:00:0B:CA -t /dev/ttyp6
rfcomm_sppd[94692]: Starting on /dev/ttyp6...
....

Als er een verbinding is, kan de pseudo-tty als seriële poort worden gebruikt:

[source,bash]
....
# cu -l ttyp6
....

=== Problemen oplossen

==== Een apparaat op afstand kan geen verbinding maken

Sommige oudere Bluetooth-apparaten ondersteunen het wisselen van rol niet. Standaard probeert FreeBSD, wanneer het een nieuwe verbinding accepteert, een rolwisseling uit te voeren en meester te worden. Apparaten die dit niet ondersteunen zullen niet kunnen verbinden. Merk op dat van rol wordt gewisseld wanneer een nieuwe verbinding wordt gemaakt, dus het is niet mogelijk om het verre apparaat te vragen of het rolwisseling ondersteunt. Er is een HCI-optie om rolwisselen aan de plaatselijke kant uit te zetten:

[source,bash]
....
# hccontrol -n ubt0hci write_node_role_switch 0
....

==== Er gaat iets mis, kan ik precies zien wat er gebeurt?

Ja, dit is mogelijk. Gebruik het pakket hcidump, dat beschikbaar is als de port package:comms/hcidump[]. Het gereedschap hcidump is vergelijkbaar met man:tcpdump[1]. Het kan gebruikt worden om de inhoud van Bluetooth-pakketten op de terminal te laten zien en om de Bluetooth-pakketten naar een bestand te schrijven.

[[network-bridging]]
== Bridging

=== Introductie

Soms is het handig om één fysiek netwerk (zoals een Ethernet-segment) in twee gescheiden netwerksegmenten te verdelen zonder de noodzaak om een IP-subnet aan te maken en een router te gebruiken om de segmenten met elkaar te verbinden. Een apparaat dat twee netwerken op deze manier met elkaar verbindt wordt een "bridge (brug)" genoemd. Een FreeBSD-systeem met twee netwerkkaarten kan als bridge dienen.

De bridge werkt door de adressen van de MAC-laag (Ethernetadressen) van de apparaten op elke netwerkinterface te leren. Het stuurt alleen verkeer tussen twee netwerken door indien de bron en het doel zich op verschillende netwerken bevinden.

In vele opzichten is een bridge als een Ethernet-switch met erg weinig poorten.

=== Situaties waarin bridging juist is

Er zijn vandaag de dag veel situaties waarin een bridge gebruikt wordt.

==== Netwerken verbinden

Het basisgebruik van een bridge is het met elkaar verbinden van twee of meer netwerksegmenten. Er zijn vele redenen om een hostgebaseerde bridge te gebruiken in plaats van simpele netwerkapparaten zoals kabelbeperkingen, firewalling of het verbinden van pseudonetwerken zoals een interface van een virtuële machine. Een bridge kan ook een draadloze interface die in hostap-modus draait met een bedraad netwerk verbinden en als een toegangspunt dienen.

==== Filtering/Bandbreedtebeheersende firewall

Een gebruikelijke situatie dient zich voor wanneer de functionaliteit van een firewall nodig is zonder routing of network address translation (NAT).

Een voorbeeld is een klein bedrijf dat via DSL of ISDN met hun internetprovider verbonden is. Dit bedrijf heeft 13 wereldwijd bereikbare IP-adressen van de internetprovider en 10 PC's op hun netwerk. In deze situatie is een firewall die op een router gebaseerd is lastig wegens subnet-problemen.

Een firewall die op een bridge gebaseerd is kan ingesteld en net na de DSL- of ISDN-router geplaatst worden zonder dat er problemen met IP-nummers optreden.

==== Netwerktap

Een bridge kan twee netwerksegmenten verbinden en kan gebruikt worden om alle Ethernetframes die tussen dezen voorbijkomen te inspecteren. Dit kan òfwel vanuit het gebruik van man:bpf[4]/man:tcpdump[1] op de bridge-interface òfwel door een kopie van alle frames naar een extra interface (overspanpoort) te versturen.

==== Laag 2 VPN

Twee Ethernetnetwerken kunnen over een IP-verbinding verbonden worden door de netwerken naar een EtherIP-tunnel te bridgen of met een oplossing gebaseerd po man:tap[4] zoals OpenVPN.

==== Laag 2 Redundancy

Een netwerk kan met meerdere verbindingen verbonden worden en het Spanning Tree Protocol gebruiken om overbodige paden te blokkeren. Een Ethernetnetwerk kan alleen juist functioneren indien er slechts één actief pad bestaat tussen twee apparaten, Spanning Tree zal lussen detecteren en de overbodige verbindingen in een geblokkeerde toestand zetten. Indien een van de actieve verbindingen faalt zal het protocol een andere boom berekenen en een van de geblokkeerde paden weer activeren om de verbindingen naar alle punten in het netwerk te herstellen.

=== De kernel instellen

Deze sectie behandelt de bridges geïmplementeerd met man:if_bridge[4], een stuurprogramma dat bridges met netgraph implementeert is ook beschikbaar, zie voor meer informatie de hulppagina man:ng_bridge[4].

Het bridge-stuurprogramma is een kernelmodule en zal automatisch door man:ifconfig[8] worden geladen wanneer er een bridge-interface wordt aangemaakt. Het is mogelijk om de bridge in de kernel te compileren door `device if_bridge` aan het kernelinstellingenbestand toe te voegen.

Pakketfiltering kan met elk firewall-pakket worden gebruikt dat via het raamwerk man:pfil[9] aankoppelt. De firewall kan als een module worden geladen of in de kernel worden gecompileerd.

De bridge kan als met man:altq[4] of man:dummynet[4] als een verkeersregelaar worden gebruikt.

=== De bridge inschakelen

De bridge wordt aangemaakt door interfaces te klonen. Om een bridge aan te maken wordt man:ifconfig[8] gebruikt, indien het bridge-stuurprogramma niet in de kernel aanwezig is zal het automatisch worden geladen.

[source,bash]
....
# ifconfig bridge create
# ifconfig bridge0
bridge0: flags=8802<BROADCAST,SIMPLEX,MULTICAST> metric 0 mtu 1500
        ether 96:3d:4b:f1:79:7a
        id 00:00:00:00:00:00 priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 timeout 1200
        root id 00:00:00:00:00:00 priority 0 ifcost 0 port 0
....

Een bridge-interface is aangemaakt en er is automatisch een random gegenereerd Ethernetadres aan toegekend. De parameters `maxaddr` en `timeout` bepalen hoeveel MAC-adressen de bridge in de doorstuurtabel houdt en hoeveel seconden voordat elke regel wordt verwijderd nadat het voor het laatst gezien is. De andere parameters bepalen hoe Spanning Tree werkt.

Voeg de netwerkinterfaces die lid zijn aan de bridge toe. Om de bridge pakketten te laten doorsturen dienen alle lidinterfaces en de bridge actief te zijn:

[source,bash]
....
# ifconfig bridge0 addm fxp0 addm fxp1 up
# ifconfig fxp0 up
# ifconfig fxp1 up
....

De bridge stuurt nu Ethernet-frames door tussen [.filename]#fxp0# en [.filename]#fxp1#. De overeenkomstige configuratie in [.filename]#/etc/rc.conf# zodat de bridge tijdens het opstarten wordt aangemaakt is:

[.programlisting]
....
cloned_interfaces="bridge0"
ifconfig_bridge0="addm fxp0 addm fxp1 up"
ifconfig_fxp0="up"
ifconfig_fxp1="up"
....

Indien de bridge-gastheer een IP-adres nodig heeft dan is de juiste plaats om dit in te stellen op de bridge-interface zelf in plaats van op een van de lidinterfaces. Dit kan statisch of via DHCP worden ingesteld:

[source,bash]
....
# ifconfig bridge0 inet 192.168.0.1/24
....

Het is ook mogelijk om een IPv6-adres aan een bridge-interface toe te kennen.

=== Firewalls gebruiken

Wanneer pakketten worden gefilterd, zullen gebridgede pakketten het filter inbound op de vertrekkende interface passeren, op de bridge-interface en outbound op de bestemde interface. Elke stap kan uitgezet worden. Wanneer de richting van het pakketverkeer belangrijk is, kan de firewall het beste op de lidinterfaces draaien en niet op de bridge zelf.

De bridge heeft verschillende aanpasbare instellingen voor het doorlaten van non-IP- en ARP-pakketten, en een laag 2 firewall met IPFW. Zie man:if_bridge[4] voor meer informatie.

=== Opspannende boom

Het bridge-stuurprogramma implementeert het Rapid Spanning Tree Protocol (RSTP of 802.1w) met terugwaartse compatibiliteit met het verouderde Spanning Tree Protocol (STP). Spanning Tree wordt gebruikt om lussen in een netwerktopologie te detecteren en verwijderen. RSTP biedt snellere convergentie naar een opspannende boom dan het verouderde STP, het protocol wisselt informatie met naburige switches uit om snel naar forwarding over te gaan zonder lussen te creëren. FreeBSD ondersteunt RSTP en STP als opties, waarbij RSTP de standaard is.

Spanning Tree kan op lidinterfaces worden geactiveerd met het commando `stp`. Voor een bridge met [.filename]#fxp0# en [.filename]#fxp1# alle huidige interfaces, wordt STP met het volgende geactiveerd:

[source,bash]
....
# ifconfig bridge0 stp fxp0 stp fxp1
bridge0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500
        ether d6:cf:d5:a0:94:6d
        id 00:01:02:4b:d4:50 priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 timeout 1200
        root id 00:01:02:4b:d4:50 priority 32768 ifcost 0 port 0
        member: fxp0 flags=1c7<LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP>
                port 3 priority 128 path cost 200000 proto rstp
                role designated state forwarding
        member: fxp1 flags=1c7<LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP>
                port 4 priority 128 path cost 200000 proto rstp
                role designated state forwarding
....

De bridge heeft spanning tree ID `00:01:02:4b:d4:50` en prioriteit `32768`. Aangezien het `root id` hetzelfde is geeft dit aan dat dit de hoofdbridge voor de boom is.

Een andere bridge in het netwerk heeft spanning tree ook geactiveerd:

[source,bash]
....
bridge0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500
        ether 96:3d:4b:f1:79:7a
        id 00:13:d4:9a:06:7a priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 timeout 1200
        root id 00:01:02:4b:d4:50 priority 32768 ifcost 400000 port 4
        member: fxp0 flags=1c7<LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP>
                port 4 priority 128 path cost 200000 proto rstp
                role root state forwarding
        member: fxp1 flags=1c7<LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP>
                port 5 priority 128 path cost 200000 proto rstp
                role designated state forwarding
....

De reegl `root id 00:01:02:4b:d4:50 priority 32768 ifcost 400000 port 4` geeft aan dat de hoofdbridge `00:01:02:4b:d4:50` is zoals boven en dat de padkosten `400000` zijn vanaf deze bridge, het pad naar de hoofdbridge gaat via `port 4` welke [.filename]#fxp0# is.

=== Geavanceerd bridgen

==== Verkeersstromen reconstrueren

De bridge ondersteunt monitormodus, waarin de pakketten worden verwijderd nadat ze door man:bpf[4] zijn verwerkt, en ze niet verder verwerkt of doorgestuurd worden. Dit kan worden gebruikt om de invoer van twee of meer interfaces naar een enkele man:bpf[4]-stroom te multiplexen. Dit is nuttig voor het reconstrueren van het verkeer voor netwerktaps welke de RX/TX-signalen over twee verschillende interfaces uitzenden.

Om de invoer van vier netwerkinterfaces als één stroom te lezen:

[source,bash]
....
# ifconfig bridge0 addm fxp0 addmfxp1 addm fxp2 addm fxp3 monitor up
# tcpdump -i bridge0
....

==== SPAN poorten

Van elk Ethernet-frame dat door de bridge wordt ontvangen wordt er een kopie naar de aangewezen SPAN-poort verstuurd. Het aantal geconfigureerde SPAN-poorten op een bridge is onbeperkt, indien een interface aangewezen is als SPAN-poort kan het niet ook als gewone bridgepoort gebruikt worden. Dit is het nuttigste voor het passief afluisteren van een gebridged netwerk op een andere host die met een van de SPAN-poorten van de bridge verbonden is.

Om een kopie van alle frames naar de interface [.filename]#fxp4# te versturen:

[source,bash]
....
# ifconfig bridge0 span fxp4
....

==== Privé-interfaces

Een privé-interface stuurt geen verkeer door naar poorten die niet ook een privé-interface zijn. Het verkeer wordt onvoorwaardelijk geblokkeerd, dus worden er geen Ethernetframes doorgestuurd, inclusief ARP. Indien verkeer selectief dient te worden geblokkeerd dient er in plaats hiervan een firewall gebruikt te worden.

==== Klevende interfaces

Indien een lidinterface van een bridge als klevend is gemarkeerd worden dynamisch geleerde adresregels als statisch behandelt wanneer ze in de doorstuurcache komen. Klevende interfaces vallen nooit uit de cache en worden nooit vervangen, zelfs niet als het adres op een andere interface wordt gezien. Dit biedt het voordeel van statische adresregels zonder dat de doorstuurtabel van te voren gevuld hoeft te worden, cliënten die geleerd zijn op een bepaald segment van de bridge kunnen niet roamen naar een ander segment.

Een ander voorbeeld voor het gebruik van klevende adressen zou het combineren van de bridge met VLANs zijn om een router te creëren waar klantnetwerken geïsoleerd zijn zonder dat IP-adresruimte verspild wordt. Neem aan dat `KlantA` op `vlan100` zit en `KlantB` op `vlan101`. De bridge heeft het adres `192.168.0.1` en is tevens een internet-router.

[source,bash]
....
# ifconfig bridge0 addm vlan100 sticky vlan100 addm vlan101 sticky vlan101
# ifconfig bridge0 inet 192.168.0.1/24
....

Beide cliënten zien `192.168.0.1` als hun standaard gateway en aangezien de bridge-cache kleverig is kunnen ze niet het MAC-adres van de andere klant spoofen om hun verkeer op te vangen.

Alle communicatie tussen de VLANs kan geblokkeerd worden door het gebruik van privé-interfaces (of een firewall):

[source,bash]
....
# ifconfig bridge0 private vlan100 private vlan101
....

De klanten zijn compleet geïsoleerd van elkaar, het volledige `/24` adresruimte kan zonder subnetten toegewezen worden.

==== Adresbeperkingen

Het aantal unieke bron-MAC-adressen achter een interface kan beperkt zijn. Wanneer de limiet bereikt is worden pakketten met een onbekend bronadres gedropt totdat een bestaande ingang in de host-cache vervalt of wordt verwijderd.

Het volgende voorbeeld stelt het maximum aantal Ethernetapparaten voor `KlantA` op `vlan100` in op 10.

[source,bash]
....
# ifconfig bridge0 ifmaxaddr vlan100 10
....

==== SNMP-monitoring

De bridge-interface en STP-parameters kunnen gemonitord worden via het SNMP-daemon dat met het basis FreeBSD-systeem wordt meegeleverd. De geëxporteerde bridge-MIBs houden zich aan de standaarden van de IETF zodat elke SNMP-cliënt of monitorpakket kan worden gebruikt om de gegevens te verzamelen.

Op de bridge-machine dient de regel `begemotSnmpdModulePath."bridge" = "/usr/lib/snmp_bridge.so"` van [.filename]#/etc/snmp.config# geactiveerd te worden en het daemon bsnmpd gestart te worden. Andere instellingen zoals gemeenschapsnamen en toegangslijsten dienen eventueel aangepast te worden. Zie man:bsnmpd[1] en man:snmp_bridge[3] voor meer informatie.

Het volgende voorbeeld gebruikt de software Net-SNMP (package:net-mgmt/net-snmp[] om een bridge te ondervragen, de port package:net-mgmt/bsnmptools[] kan ook worden gebruikt. Voeg de volgende regels toe aan [.filename]#$HOME/.snmp/snmp.conf# op de SNMP-cliënt-host om de MIB-definities van de bridge in Net-SNMP te importeren:

[.programlisting]
....
mibdirs +/usr/shared/snmp/mibs
mibs +BRIDGE-MIB:RSTP-MIB:BEGEMOT-MIB:BEGEMOT-BRIDGE-MIB
....

Om een enkele bridge via de IETF BRIDGE-MIB (RFC4188) te monitoren:

[source,bash]
....
% snmpwalk -v 2c -c public bridge1.example.com mib-2.dot1dBridge
BRIDGE-MIB::dot1dBaseBridgeAddress.0 = STRING: 66:fb:9b:6e:5c:44
BRIDGE-MIB::dot1dBaseNumPorts.0 = INTEGER: 1 ports
BRIDGE-MIB::dot1dStpTimeSinceTopologyChange.0 = Timeticks: (189959) 0:31:39.59 centi-seconds
BRIDGE-MIB::dot1dStpTopChanges.0 = Counter32: 2
BRIDGE-MIB::dot1dStpDesignatedRoot.0 = Hex-STRING: 80 00 00 01 02 4B D4 50
...
BRIDGE-MIB::dot1dStpPortState.3 = INTEGER: forwarding(5)
BRIDGE-MIB::dot1dStpPortEnable.3 = INTEGER: enabled(1)
BRIDGE-MIB::dot1dStpPortPathCost.3 = INTEGER: 200000
BRIDGE-MIB::dot1dStpPortDesignatedRoot.3 = Hex-STRING: 80 00 00 01 02 4B D4 50
BRIDGE-MIB::dot1dStpPortDesignatedCost.3 = INTEGER: 0
BRIDGE-MIB::dot1dStpPortDesignatedBridge.3 = Hex-STRING: 80 00 00 01 02 4B D4 50
BRIDGE-MIB::dot1dStpPortDesignatedPort.3 = Hex-STRING: 03 80
BRIDGE-MIB::dot1dStpPortForwardTransitions.3 = Counter32: 1
RSTP-MIB::dot1dStpVersion.0 = INTEGER: rstp(2)
....

De waarde `dot1dStpTopChanges.0` is twee wat betekent dat de topologie van de STP-bridge twee maal veranderd is, een topologieverandering houdt in dat één of meerdere links in het netwerk zijn veranderd of hebben gefaald en dat er een nieuwe boom is berekend. De waarde `dot1dStpTimeSinceTopologyChange.0` laat zien wanneer dit gebeurde.

Om meerdere bridge-interfaces te monitoren kan men het privé BEGEMOT-BRIDGE-MIB gebruiken:

[source,bash]
....
% snmpwalk -v 2c -c public bridge1.example.com
enterprises.fokus.begemot.begemotBridge
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseName."bridge0" = STRING: bridge0
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseName."bridge2" = STRING: bridge2
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseAddress."bridge0" = STRING: e:ce:3b:5a:9e:13
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseAddress."bridge2" = STRING: 12:5e:4d:74:d:fc
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseNumPorts."bridge0" = INTEGER: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseNumPorts."bridge2" = INTEGER: 1
...
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTimeSinceTopologyChange."bridge0" = Timeticks: (116927) 0:19:29.27 centi-seconds
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTimeSinceTopologyChange."bridge2" = Timeticks: (82773) 0:13:47.73 centi-seconds
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTopChanges."bridge0" = Counter32: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTopChanges."bridge2" = Counter32: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeStpDesignatedRoot."bridge0" = Hex-STRING: 80 00 00 40 95 30 5E 31
BEGEMOT-BRIDGE-MIB::begemotBridgeStpDesignatedRoot."bridge2" = Hex-STRING: 80 00 00 50 8B B8 C6 A9
....

Om de bridge-interface die via de subboom `mib-2.dot1dBridge` wordt gemonitord te veranderen:

[source,bash]
....
% snmpset -v 2c -c private bridge1.example.com
BEGEMOT-BRIDGE-MIB::begemotBridgeDefaultBridgeIf.0 s bridge2
....

[[network-aggregation]]
== Verbindingsaggregatie en failover

=== Introductie

De interface man:lagg[4] maakt het mogelijk om meerdere netwerkinterfaces te aggregeren in één virtueel interface voor het bieden van fout-tolerante en zeer snelle verbindingen.

=== Werkmodi

Failover::
Zendt en ontvangt verkeer alleen door de meesterpoort. Wanneer de meesterpoort niet beschikbaar is, wordt de volgende actieve poort gebruikt. De eerste toegevoegde interface is de meesterpoort; alle interfaces die hierna zijn toegevoegd worden gebruikt als failover-apparaten. Als failover naar een niet-meesterpoort plaatsvindt, dan wordt de originele poort de meester wanneer deze weer beschikbaar wordt.

Cisco(R) Fast EtherChannel(R)::
Cisco(R) Fast EtherChannel(R) (FEC), is een statische installatie en onderhandelt niet over aggregatie met de peer noch wisselt het frames uit om de verbinding te monitoren. Indien de switch LACP ondersteunt dient dat gebruikt te worden.
+
FEC balanceert uitgaand verkeer over de actieve poorten gebaseerd op gehashde informatie over protocolheaders en accepteert inkomend verkeer van elke actieve poort. De hash bevat het Ethernet bron- en doeladres, en indien beschikbaar, de VLAN-tag, en de IPv4/IPv6 bron- en doeladressen.

LACP::
Het IEEE(R) 802.3ad Link Aggregation Control Protocol (LACP) en het Marker Protocol. LACP onderhandelt met de peer over een verzameling aggregeerbare verbindingen in één of meerdere Link Aggregated Groups (LAG). Elke LAG is opgebouwd uit poorten die dezelfde snelheid hebben, ingesteld op full-duplex werking. Het verkeer zal over de poorten in de LAG gebalanceerd worden met de hoogste totaalsnelheid, in de meeste gevallen zal er slechts één LAG zijn die alle poorten bevat. Wanneer er fysieke verbindingen veranderen, zal Link Aggregation snel naar een nieuwe opstelling convergeren.
+
LACP balanceert uitgaand verkeer over de actieve poorten gebaseerd op gehashde informatie over protocolheaders en accepteert inkomend verkeer van elke actieve poort. De hash bevat het Ethernet bron- en doeladres, en indien beschikbaar, de VLAN-tag, en de IPv4/IPv6 bron- en doeladressen.

Loadbalance::
Dit is een alias van de _FEC_ modus.

Round-Robin::
Distribueert uitgaand verkeer door middel van een round-robin scheduler over alle actieve poorten en accepteert inkomend verkeer van elke actieve poort. Deze modus schendt Ethernet frame-ordering en dient met zorg gebruikt te worden.

=== Voorbeelden

[[networking-lacp-aggregation-cisco]]
.LACP-aggregatie met een Cisco(R) switch
[example]
====
Dit voorbeeld verbindt twee interfaces op een FreeBSD-machine met de switch als een enkele loadgebalanceerde en fout-tolerante verbinding. Er kunnen meer interfaces worden toegevoegd om de doorvoer en fouttolerantie te verhogen. Aangezien frame-ordering verplicht is op Ethernetverbindingen stroomt al het verkeer tussen twee stations altijd over dezelfde fysieke verbinding zodat de maximum snelheid beperkt wordt tot die van één interface. Het verzendalgoritme probeert zoveel mogelijk informatie te gebruiken voor het onderscheiden van verschillende verkeersstromen en deze over de beschikbare interfaces te balanceren.

Voeg op de Cisco(R) switch de interfaces _FastEthernet0/1_ en _FastEthernet0/2_ aan de kanaalgroep _1_ toe:

[source,bash]
....
interface FastEthernet0/1
 channel-group 1 mode active
 channel-protocol lacp
!
interface FastEthernet0/2
 channel-group 1 mode active
 channel-protocol lacp
....

Maak de man:lagg[4]-interface aan met _fxp0_ en _fxp1_ en activeer de interface met IP-adres _10.0.0.3/24_:

[source,bash]
....
# ifconfig fxp0 up
# ifconfig fxp1 up
# ifconfig lagg0 create
# ifconfig lagg0 up laggproto lacp laggport fxp0 laggport fxp1 10.0.0.3/24
....

Bekijk de interfacestatus van ifconfig:

[source,bash]
....
# ifconfig lagg0
....

Poorten die als _ACTIVE_ zijn gemarkeerd zijn lid van de actieve aggregatiegroep waarover onderhandeld is met de verre switch en waarover verkeer zal worden verzonden en ontvangen. Gebruik de uitgebreide uitvoer van man:ifconfig[8] om de LAG-identifiers te bekijken.

[source,bash]
....
lagg0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500
        options=8<VLAN_MTU>
        ether 00:05:5d:71:8d:b8
        media: Ethernet autoselect
        status: active
        laggproto lacp
        laggport: fxp1 flags=1c<ACTIVE,COLLECTING,DISTRIBUTING>
        laggport: fxp0 flags=1c<ACTIVE,COLLECTING,DISTRIBUTING>
....

Gebruik, om de toestand van de poorten op de switch te bekijken, `show lacp neighbor`.

[source,bash]
....
switch# show lacp neighbor
Flags:  S - Device is requesting Slow LACPDUs
        F - Device is requesting Fast LACPDUs
        A - Device is in Active mode       P - Device is in Passive mode

Channel group 1 neighbors

Partner's information:

                  LACP port                        Oper    Port     Port
Port      Flags   Priority  Dev ID         Age     Key     Number   State
Fa0/1     SA      32768     0005.5d71.8db8  29s    0x146   0x3      0x3D
Fa0/2     SA      32768     0005.5d71.8db8  29s    0x146   0x4      0x3D
....

Gebruik voor meer detail het commando `show lacp neighbor detail`.

Voeg de volgende regels aan [.filename]#/etc/rc.conf# toe om deze informatie na het opnieuw starten te behouden:

[.programlisting]
....
ifconfig_fxp0="up"
ifconfig_fxp1="up"
cloned_interfaces="lagg0"
ifconfig_lagg0="laggproto lacp laggport fxp0 laggport fxp1 10.0.0.3/24"
....

====

[[networking-lagg-failover]]
.Failover-modus
[example]
====
Failover-modus kan worden gebruikt om op een secondaire interface over te schakelen wanneer de verbinding op de meesterinterface verloren is. Activeer de onderliggende fysieke interface. Creëer de interface `lagg0`, met _fxp0_ als de meesterinterface en _fxp1_ als de secondaire interface en ken er IP-adres _10.0.0.15/24_ aan toe:

[source,bash]
....
# ifconfig fxp0 up
# ifconfig fxp1 up
# ifconfig lagg0 create
# ifconfig lagg0 up laggproto failover laggport fxp0 laggport fxp1 10.0.0.15/24
....

De interface zal er ongeveer als volgt uitzien, de grote verschillen zullen het MAC-adres en de apparaatnamen zijn:

[source,bash]
....
# ifconfig lagg0
lagg0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500
        options=8<VLAN_MTU>
        ether 00:05:5d:71:8d:b8
        inet 10.0.0.15 netmask 0xffffff00 broadcast 10.0.0.255
        media: Ethernet autoselect
        status: active
        laggproto failover
        laggport: fxp1 flags=0<>
        laggport: fxp0 flags=5<MASTER,ACTIVE>
....

Het verkeer zal worden verzonden en ontvangen op _fxp0_. Indien de verbinding op _fxp0_ verloren is, zal _fxp1_ de actieve verbinding worden. Indien de verbinding op de meesterinterface hersteld is, zal het weer de actieve verbinding worden.

Voeg de volgende regels aan [.filename]#/etc/rc.conf# toe om deze informatie na het opnieuw starten te behouden:

[.programlisting]
....
ifconfig_fxp0="up"
ifconfig_fxp1="up"
cloned_interfaces="lagg0"
ifconfig_lagg0="laggproto lacp laggport fxp0 laggport fxp1 10.0.0.15/24"
....

====

[[networking-lagg-wired-and-wireless]]
.Failover-modus tussen bekabelde en draadloze interfaces
[example]
====
Voor laptop-gebruikers is het normaliter wenselijk om het draadloze interface als secundair interface te gebruiken indien het bekabelde interface niet beschikbaar is. Met man:lagg[4] is het mogelijk om één IP-adres te gebruiken en het bekabelde interface voor zowel prestatie als veiligheid te prefereren terwijl de mogelijkheid behouden blijft om de draadloze verbinding te gebruiken.

In deze opstelling dient het MAC-adres van het onderliggende draadloze interface overschreven te worden om met dat van man:lagg[4] overeen te komen, welke afkomstig is van het primaire interface dat wordt gebruikt, het bekabelde interface.

In deze opstelling wordt het bekabelde interface, _bge0_ als meester gebruikt, en het draadloze interface, _wlan0_, als het failover-interface. _wlan0_ was aangemaakt vanuit _iwn0_ voor welke het MAC-adres van de bekabelde verbinding zal worden gebruikt. De eerste stap is om het MAC-adres van het bekabelde interface te verkrijgen:

[source,bash]
....
#  ifconfig bge0
bge0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500
      options=19b<RXCSUM,TXCSUM,VLAN_MTU,VLAN_HWTAGGING,VLAN_HWCSUM,TSO4>
      ether 00:21:70:da:ae:37
      inet6 fe80::221:70ff:feda:ae37%bge0 prefixlen 64 scopeid 0x2
      nd6 options=29<PERFORMNUD,IFDISABLED,AUTO_LINKLOCAL>
      media: Ethernet autoselect (1000baseT <full-duplex>)
      status: active
....

_bge0_ kan vervangen worden door het eigenlijke interface, er zal een andere regel met `ether` verschijnen, dit is het MAC-adres van het bekabelde interface. Om het onderliggende draadloze interface, _iwn0_ te wijzigen:

[source,bash]
....
# ifconfig iwn0 ether 00:21:70:da:ae:37
....

Activeer het draadloze interface maar geef er nog geen IP-adres aan:

[source,bash]
....
# ifconfig wlan0 create wlandev iwn0 ssid mijn_router up
....

Activeer de interface _bge0_. Maak het man:lagg[4]-interface aan met _bge0_ als meester, en met failover naar _wlan0_ indien nodig:

[source,bash]
....
# ifconfig bge0 up
# ifconfig lagg0 create
# ifconfig lagg0 up laggproto failover laggport bge0 laggport wlan0
....

Het interface zal er ongeveer als volgt uitzien, de grootste verschillen zullen het MAC-adres en de apparaatnamen zijn:

[source,bash]
....
# ifconfig lagg0
lagg0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500
      options=8<VLAN_MTU>
      ether 00:21:70:da:ae:37
      media: Ethernet autoselect
      status: active
      laggproto failover
      laggport: wlan0 flags=0<>
      laggport: bge0 flags=5<MASTER,ACTIVE>
....

Start vervolgens de DHCP-cliënt om een IP-adres te verkrijgen:

[source,bash]
....
# dhclient lagg0
....

Om deze configuratie bij het opstarten te behouden, kan het volgende aan [.filename]#/etc/rc.conf# worden toegevoegd:

[.programlisting]
....
ifconfig_bge0="up"
ifconfig_iwn0="ether 00:21:70:da:ae:37"
wlans_iwn0="wlan0"
ifconfig_wlan0="WPA"
cloned_interfaces="lagg0"
ifconfig_lagg0="laggproto failover laggport bge0 laggport wlan0 DHCP"
....

====

[[network-diskless]]
== Schijfloos werken

Een FreeBSD-machine kan over het netwerk opstarten en zonder een plaatselijke schijf werken, door gebruik te maken van bestandssystemen die van een NFS-server aangekoppeld worden. Er zijn geen systeemwijzigingen nodig anders dan de standaard instellingenbestanden. Dit soort systemen is relatief eenvoudig op te zetten omdat alle noodzakelijke elementen al aanwezig zijn:

* Er zijn minstens twee manieren om de kernel over het netwerk te laden:

** PXE: De Intel(R) Preboot eXecution Environment is een vorm een smart boot ROM dat in sommige netwerkkaarten en moederborden is ingebouwd. Bekijk de hulppagina man:pxeboot[8] voor meer informatie.
** De poort Etherboot (package:net/etherboot[]) maakt code aan dat naar een ROM geschreven kan worden en dat kernels over het netwerk opstart. De code kan òfwel naar een opstart-PROM op een netwerkkaart geflashed worden, òfwel van een floppy (of harde) schijf geladen worden, òfwel van een draaiend MS-DOS(R) systeem geladen worden. Vele netwerkkaarten worden ondersteund.

* Een voorbeeldscript ([.filename]#/usr/shared/examples/diskless/clone_root#) vergemakkelijkt het aanmaken en beheren van het root bestandssysteem van het werkstation op de server. Het kan nodig zijn dat het script wat aangepast moet worden, maar het zorgt voor een snelle start.
* Er bestaan standaardbestanden voor het opstarten van het systeem in [.filename]#/etc# om een systeemstart zonder schijf te detecteren en te ondersteunen.
* Het gebruik van een wisselbestand, indien nodig, kan worden gedaan naar òfwel een NFS bestand òfwel naar een plaatselijke schijf.

Er zijn vele manieren om een schijfloos werkstation op te zetten. Hierbij zijn veel elementen betrokken, en vele kunnen aan de eigen smaak worden aangepast. Het volgende beschrijft variaties met betrekking tot het installeren van een compleet systeem, waarbij de nadruk ligt op de eenvoud en de compatibiliteit met de standaard opstartscripts van FreeBSD. Het beschreven systeem heeft de volgende eigenschappen:

* De schijfloze werkstations gebruiken een gedeeld bestandssysteem voor [.filename]#/#, dat alleen gelezen kan worden, en een gedeeld bestandssysteem voor [.filename]#/usr#, dat eveneens alleen gelezen kan worden.
+ 
Het root-bestandssysteem is een kopie van een standaard root-bestandssysteem voor FreeBSD (typisch van een server), waarbij enkele instellingenbestanden zijn overschreven door versies die specifiek zijn voor een schijfloos systeem of, mogelijk, door het werkstation horen waar ze bij horen.
+ 
De delen van het root-bestandssysteem die beschrijfbaar moeten zijn, zijn overdekt met man:md[4] bestandssystemen. Alle veranderingen gaan verloren indien het systeem opnieuw wordt opgestart.
* De kernel is overgedragen en òfwel met Etherboot òfwel met PXE geladen, aangezien sommige situaties het gebruik van één van de methodes kan eisen.

[CAUTION]
====

Het systeem zoals hierboven beschreven is onveilig. Het dient in een beschermd gebied van een netwerk te functioneren, en niet vertrouwd te worden door andere hosts.
====

Alle informatie in deze sectie is getest met FreeBSD 5.2.1-RELEASE.

=== Achtergrondinformatie

Het installeren van schijfloze werkstations is zowel vrij rechttoe-rechtaan als foutgevoelig. Deze fouten zijn soms moeilijk vast te stellen wegens een aantal redenen. Bijvoorbeeld:

* Opties die tijdens het compileren zijn opgegeven kunnen verschillend gedrag tonen tijdens het draaien.
* Foutmeldingen zijn vaak cryptisch of geheel afwezig.

Op dit gebied is het bezit van wat achtergrondkennis over de gebruikte mechanismen zeer nuttig om mogelijke problemen op te lossen.

Voor een succesvol opstarten dienen verschillende handelingen uitgevoerd te worden:

* De machine moet een aantal initiële parameters zoals het IP-adres, de bestandsnaam van de executable, de naam van de server, en het root-pad verkrijgen. Dit wordt gedaan door gebruik te maken van de DHCP of BOOTP protocollen. DHCP is een compatible uitbreiding van BOOTP, het gebruikt dezelfde poorten en het pakketformaat heeft dezelfde basis.
+ 
Het is mogelijk om een systeem in te stellen zodat het alleen BOOTP gebruikt. Het serverprogramma man:bootpd[8] wordt met het basissysteem van FreeBSD meegeleverd.
+ 
DHCP biedt echter een aantal voordelen boven BOOTP (fijnere instellingenbestanden, mogelijkheid om PXE te gebruiken, en vele anderen die niet direct verband houden met schijfloos werken), er zal hoofdzakelijk een opstelling met DHCP worden beschreven, met analoge voorbeelden voor man:bootpd[8] indien mogelijk. De voorbeeldopstelling zal het softwarepakket van ISC DHCP gebruiken (versie 3.0.1.r12 was geïnstalleerd op de testserver).
* De machine moet één of meerdere programma's naar het plaatselijke geheugen versturen. Eén van TFTP of NFS wordt gebruikt. De keuze tussen TFTP en NFS is op verschillende plaatsen een optie tijdens het compileren. Een veelgemaakte fout is het opgeven van bestandsnamen voor het verkeerde protocol: TFTP verstuurd typisch alle bestanden vanuit één map op de server, en verwacht dat alle bestandsnamen relatief aan deze map zijn; NFS verwacht absolute bestandspaden.
* De mogelijke tussentijdse opstartprogramma's en de kernel dienen geïnitialiseerd en uitgevoerd te worden. Er zijn enkele belangrijke variaties op dit gebied:

** PXE zal man:pxeboot[8] laden, wat een aangepaste versie is van de lader voor stage drie van FreeBSD. man:loader[8] zal de meeste parameters verkrijgen die noodzakelijk zijn om het systeem op te starten, en zal ze in de kernelomgeving laten staan voordat het de controle overdraagt. Het is in dit geval mogelijk om een [.filename]#GENERIC# kernel te gebruiken.
** Etherboot zal met minder voorbereiding direct de kernel laden. Hiervoor is het noodzakelijk om een kernel met specifieke opties te bouwen.
+ 
PXE en Etherboot werken beide even goed; echter, omdat kernels normaalgesproken meer werk overlaten aan man:loader[8], is PXE de te verkiezen methode.
+ 
Indien het BIOS en de netwerkkaarten PXE ondersteunen, dient dat waarschijnlijk gebruikt te worden.
* Tenslotte: de machine heeft toegang tot de bestandssystemen nodig. NFS wordt in alle gevallen gebruikt.

Zie ook de hulppagina man:diskless[8].

=== Installatie-instructies

==== Instellen met behulp van ISC DHCP

De ISC DHCP server kan zowel verzoeken voor BOOTP als DHCP beantwoorden.

ISC DHCP 4.2 maakt geen deel uit van het basissysteem. Eerst dient de poort package:net/isc-dhcp42-server[] of het corresponderende pakket geïnstalleerd te worden.

Wanneer ISC DHCP is geïnstalleerd, heeft het een instellingenbestand nodig om te draaien (normaliter [.filename]#/usr/local/etc/dhcpd.conf# genoemd). Hieronder volgt een voorbeeld met commentaar, waarbij host `margaux` gebruik maakt van Etherboot en `corbieres` gebruik maakt van PXE:

[.programlisting]
....
default-lease-time 600;
max-lease-time 7200;
authoritative;

option domain-name "example.com";
option domain-name-servers 192.168.4.1;
option routers 192.168.4.1;

subnet 192.168.4.0 netmask 255.255.255.0 {
  use-host-decl-names on; <.>
  option subnet-mask 255.255.255.0;
  option broadcast-address 192.168.4.255;

  host margaux {
    hardware ethernet 01:23:45:67:89:ab;
    fixed-address margaux.example.com;
    next-server 192.168.4.4; <.>
    filename "/data/misc/kernel.diskless"; <.>
    option root-path "192.168.4.4:/data/misc/diskless"; <.>
  }
  host corbieres {
    hardware ethernet 00:02:b3:27:62:df;
    fixed-address corbieres.example.com;
    next-server 192.168.4.4;
    filename "pxeboot";
    option root-path "192.168.4.4:/data/misc/diskless";
  }
}
....

<.> Deze optie vertelt dhcpd om de waarde die in de verklaringen voor `host` staan te versturen als de hostnaam voor de schijfloze host. Een andere mogelijkheid is om `option host-name margaux` binnen de verklaringen voor `host` op te nemen.

<.> De aanwijzing `next-server` bepaalt de TFTP of NFS server die gebruikt moet worden voor het laden van het lader- of kernelbestand (standaard wordt dezelfde host als voor de DHCP-server gebruikt).

<.> De aanwijzing `filename` bepaalt het bestand dat Etherboot of PXE gebruikt voor de volgende uitvoerstap. Het dient gespecificeerd te worden volgens de gebruikte verzendmethode. Voor Etherboot kan tijdens het compileren worden opgegeven of het NFS of TFTP moet gebruiken. De FreeBSD-poort stelt standaard NFS in. PXE gebruikt TFTP, vandaar dat hier een relatieve bestandsnaam wordt gebruikt (dit kan afhangen van de instellingen van de TFTP-server, maar het is de gewoonte). Verder geldt dat PXE [.filename]#pxeboot# en niet de kernel laadt. Er zijn andere interessante mogelijkheden, zoals het laden van [.filename]#pxeboot# vanuit de map [.filename]#/boot# van een FreeBSD CD-ROM (aangezien man:pxeboot[8] de [.filename]#GENERIC# kernel kan laden, bestaat de mogelijkheid om PXE te gebruiken om van een CDROM op afstand op te starten.

<.> De optie `root-path` definieert het pad naar het root-bestandssysteem, in de gebruikelijke notatie van NFS. Indien PXE gebruikt wordt, is het mogelijk om het IP-adres van de host weg te laten zolang de kerneloptie BOOTP niet geactiveerd is. De NFS-server is dan dezelfde als die van TFTP.

==== Configuratie door gebruik van BOOTP

Hieronder staan de equivalente instellingen voor bootpd (gereduceerd tot één cliënt). Dit staat in [.filename]#/etc/bootptab#.

Merk op dat Etherboot gecompileerd dient te worden met de afwijkende optie `NO_DHCP_SUPPORT` om BOOTP te gebruiken, en dat PXEDHCP _nodig heeft_. Het enige duidelijke voordeel van bootpd is dat het in het basissysteem zit.

[.programlisting]
....
.def100:\
  :hn:ht=1:sa=192.168.4.4:vm=rfc1048:\
  :sm=255.255.255.0:\
  :ds=192.168.4.1:\
  :gw=192.168.4.1:\
  :hd="/tftpboot":\
  :bf="/kernel.diskless":\
  :rp="192.168.4.4:/data/misc/diskless":

margaux:ha=0123456789ab:tc=.def100
....

==== Een opstartprogramma voorbereiden met Etherboot

De http://etherboot.sourceforge.net[website van Etherboot] bevat http://etherboot.sourceforge.net/doc/html/userman/t1.html[ uitgebreide documentatie] die over het algemeen is bedoeld voor Linux-systemen, maar die desalniettemin bruikbare informatie bevat. Het volgende geeft een samenvatting over hoe Etherboot op een FreeBSD-systeem te gebruiken.

Ten eerste dient het pakket of de poort package:net/etherboot[] geïnstalleerd te worden.

De instellingen van Etherboot (i.e., om TFTP in plaats van NFS te gebruiken) kunnen gewijzigd worden door het bestand [.filename]#Config# in de bronmap van Etherboot te bewerken.

Hieronder zal een opstartdiskette gebruikt worden. Raadpleeg voor andere methoden (PROM, of een MS-DOS(R)-programma) de documentatie van Etherboot.

Om een opstartdiskette te maken, dient er een diskette in het diskettestation van de machine aanwezig te zijn waarop Etherboot is geïnstalleerd, daarna dient er naar de map [.filename]#src# in de mapboom van Etherboot gegaan te worden, en het volgende ingetypt te worden:

[source,bash]
....
# gmake bin32/apparaatsoort.fd0
....

_apparaatsoort_ hangt af van het soort Ethernetkaart dat in het schijfloze werkstation aanwezig is. Raadpleeg het bestand [.filename]#NIC# in dezelfde map om het juiste _apparaatsoort_ te bepalen.

==== Opstarten met PXE

Standaard laadt de lader man:pxeboot[8] de kernel via NFS. Het kan zodanig gecompileerd worden dat het TFTP gebruikt door de optie `LOADER_TFTP_SUPPORT` in [.filename]#/etc/make.conf# te specificeren. Raadpleeg het commentaar in [.filename]#/usr/shared/examples/etc/make.conf# voor instructies.

Er zijn nog twee andere opties voor [.filename]#make.conf# die nuttig kunnen zijn bij het opzetten van een schijfloze machine die als seriële console gebruikt wordt: `BOOT_PXELDR_PROBE_KEYBOARD`, en `BOOT_PXELDR_ALWAYS_SERIAL`.

Om PXE bij het opstarten van de machine te gebruiken, is het gewoonlijk nodig om de optie `Boot from network` in het BIOS te selecteren, of om een functietoets tijdens de initialisatie van de PC in te typen.

==== De TFTP en NFS servers instellen

Indien PXE of Etherboot gebruikt wordt, welke is ingesteld om TFTP te gebruiken, is het nodig om tftpd op de bestandsserver aan te zetten:

[.procedure]
====

. Maak een map aan van waaruit tftpd de bestanden serveert, bijvoorbeeld [.filename]#/tftpboot#.
. Voeg deze regel toe aan [.filename]#/etc/inetd.conf#:
+
[.programlisting]
....
tftp	dgram	udp	wait	root	/usr/libexec/tftpd	tftpd -l -s /tftpboot
....
+
[NOTE]
======
Het schijnt dat sommige versies van PXE de TCP-versie van TFTP vereisen. In dit geval dient een tweede regel toegevoegd te worden, waarbij `dgram udp` door `stream tcp` vervangen wordt.
======
+
. inetd dient de instellingenbestanden opnieuw te lezen. De regel `inetd_enable="YES"` dient in het bestand [.filename]#/etc/rc.conf# aanwezig te zijn voor de juiste werking van deze opdracht:
+
[source,bash]
....
# service inetd restart
....
====

De map [.filename]#tftpboot# kan overal op de server geplaatst worden. De plaats dient zowel in [.filename]#inetd.conf# als in [.filename]#dhcpd.conf# ingesteld te worden.

In alle gevallen dient er ook voor gezorgd te worden dat NFS aanstaat en dat het juiste bestandssysteem op de NFS-server geëxporteerd wordt.

[.procedure]
====

. Voeg het volgende toe aan [.filename]#/etc/rc.conf#:
+
[.programlisting]
....
nfs_server_enable="YES"
....
+
. Exporteer het bestandssysteem waar de schijfloze root-map zich bevindt door het volgende aan [.filename]#/etc/exports# toe te voegen (pas het aankoppelpunt van het volume aan en vervang _margaux corbieres_ door de namen van de schijfloze werkstations):
+
[.programlisting]
....
/data/misc -alldirs -ro margaux corbieres
....
+
. mountd dient het instellingenbestand opnieuw te lezen. Indien het nodig was om NFS in [.filename]#/etc/rc.conf# tijdens de eerste stap aan te zetten, is het waarschijnlijk gewenst om in plaats hiervan opnieuw op te starten.
+
[source,bash]
....
# service mountd restart
....
====

==== Een schijfloze kernel bouwen

Indien Etherboot gebruikt wordt, is het nodig om een kernelinstellingenbestand voor de schijfloze cliënt met de volgende opties (naast de gebruikelijke) aan te maken:

[.programlisting]
....
options	BOOTP		# Gebruik BOOTP om het IP-adres en de hostnaam te verkrijgen
options	BOOTP_NFSROOT	# NFS-mount het root-bestandssysteem door gebruik te maken van de informatie van BOOTP
....

Het kan ook gewenst zijn om `BOOTP_NFSV3`, `BOOT_COMPAT`, en `BOOTP_WIRED_TO` te gebruiken (raadpleeg hiervoor [.filename]#NOTES#).

De namen van deze opties zijn historisch en enigszins misleidend aangezien ze eigenlijk onverschillig gebruik van DHCP en BOOTP in de kernel mogelijk maken (het is ook mogelijk om strikt gebruik van BOOTP of DHCP te forceren).

De kernel dient gebouwd te worden (zie crossref:kernelconfig[kernelconfig,De FreeBSD-kernel instellen]) en gekopieerd te worden naar de plaats die in [.filename]#dhcpd.conf# is aangegeven.

[NOTE]
====
Indien PXE gebruikt wordt, is het bouwen van een kernel met bovenstaande opties niet strikt noodzakelijk (maar wel aangeraden). Door deze opties aan te zetten zullen er meer verzoeken voor DHCP tijdens het opstarten van de kernel verstuurd worden, met in sommige speciale gevallen een klein risico op inconsistentie tussen de nieuwe waarden en degenen die door man:pxeboot[8] zijn ontvangen. Het voordeel van het gebruik van deze opties is dat de hostnaam als een bijverschijnsel wordt ingesteld. In de andere gevallen dient de hostnaam op een andere manier ingesteld te worden, bijvoorbeeld in een cliënt-specifiek bestand [.filename]#rc.conf#.
====

[NOTE]
====
Om laadbaar te zijn met Etherboot, dienen de apparaataanwijzingen in de kernel gecompileerd te worden. Normaalgesproken wordt hiervoor de volgende optie in het instellingenbestand gebruikt (zie het instellingencommentaarbestand [.filename]#NOTES#):

[.programlisting]
....
hints		"GENERIC.hints"
....

====

==== Het root-bestandssysteem voorbereiden

Er dient een root-bestandssysteem voor de schijfloze werkstations op de plaats die als `root-path` in [.filename]#dhcpd.conf# staat aangegeven aangemaakt te worden.

===== `make world` gebruiken om het root-bestandssysteem te bevolken

Deze methode is snel en installeert een compleet maagdelijk systeem (niet alleen het root-bestandssysteem) in `DESTDIR`. Hiervoor dient slechts het volgende script uitgevoerd te worden:

[.programlisting]
....
#!/bin/sh
export DESTDIR=/data/misc/diskless
mkdir -p ${DESTDIR}
cd /usr/src; make buildworld && make buildkernel
make installworld && make installkernel
cd /usr/src/etc; make distribution
....

Nadat dit gedaan is, kunnen [.filename]#/etc/rc.conf# en [.filename]#/etc/fstab# die in `DESTDIR` geplaatst zijn naar behoefte worden aangepast.

==== Swapruimte instellen

Indien nodig kan een wisselbestand dat zich op de server bevindt via NFS worden benaderd.

===== Swapruimte via NFS

De kernel biedt geen ondersteuning om swapruimte via NFS tijdens het opstarten aan te zetten. De swapruimte moet door de opstartscripts worden aangezet, door een beschrijfbaar bestandssysteem aan te koppelen en een wisselbestand aan te maken en aan te zetten. De volgende opdracht maakt een wisselbestand van de juiste grootte aan:

[source,bash]
....
# dd if=/dev/zero of=/pad/naar/wisselbestand bs=1k count=1 oseek=100000
....

Om het aan te zetten dient de volgende regel aan [.filename]#/etc/rc.conf# te worden toegevoegd:

[.programlisting]
....
swapfile=/pad/naar/wisselbestand
....

==== Diverse problemen

===== Draaien met een alleen-lezen [.filename]#/usr#

Indien het schijfloze werkstation is ingesteld om X te draaien, is het nodig om het instellingenbestand van XDM te wijzigen, dat standaard het foutenlogboek in [.filename]#/usr# plaatst.

===== Gebruik maken van een niet-FreeBSD-server

Indien de server voor het root-bestandssysteem geen FreeBSD draait, is het nodig om het root-bestandssysteem op een FreeBSD-machine aan te maken, en het daarna naar de bestemming te kopiëren, door gebruik te maken van `tar` of `cpio`.

In deze situatie zijn er af en toe problemen met de speciale bestanden in [.filename]#/dev#, vanwege verschillen in de groottes van grote/kleine integers. Een oplossing voor dit probleem is om een map van de niet-FreeBSD-server te exporteren, deze map op een FreeBSD-machine aan te koppelen, en man:devfs[5] te gebruiken om de apparaatknooppunten transparant voor de gebruiker toe te wijzen.

[[network-pxe-nfs]]
== Met PXE en een NFS-root-bestandssysteem opstarten

Het Preboot eXecution Environment (PXE) van Intel(R) maakt het mogelijk om het besturingssysteem over het netwerk op te starten. Ondersteuning voor PXE wordt normaliter aangeboden in het BIOS van moderne moederborden, waar het kan worden aangezet in de instellingen van het BIOS wat opstarten over het netwerk mogelijk maakt. Een volledig werkende PXE-opstelling vereist ook correct geconfigureerde DHCP- en TFTP-servers.

Wanneer de gastheercomputer opstart, krijgt het informatie over DHCP over waar de intiële bootloader staat via TFTP. Nadat de gastheercomputer deze informatie heeft ontvangen, downloadt het de bootloader via TFTP en voert het vervolgens de bootloader uit. Dit is gedocumenteerd in sectie 2.2.1 van de http://download.intel.com/design/archives/wfm/downloads/pxespec.pdf[Preboot Execution Environment (PXE) Specification]. In FreeBSD is de bootloader die tijdens het PXE-proces wordt opgehaald [.filename]#/boot/pxeboot#. Terwijl [.filename]#/boot/pxeboot# wordt uitgevoerd, wordt de kernel van FreeBSD geladen en wordt er verder gegaan met de rest van de opstartprocedure van FreeBSD. Kijk voor meer informatie over het opstartproces van FreeBSD in crossref:boot[boot,Het FreeBSD opstartproces].

=== De `chroot`-omgeving voor het NFS-root-bestandssysteem instellen

[.procedure]
====

. Kies een map uit voor een installatie van FreeBSD die over NFS aangekoppeld kan worden. Bijvoorbeeld een map als [.filename]#/b/tftpboot/FreeBSD/install#.
+
[source,bash]
....
# export NFSROOTDIR=/b/tftpboot/FreeBSD/install
# mkdir -p ${NFSROOTDIR}
....
+
. Stel de NFS-server in door de instructies in crossref:network-servers[network-configuring-nfs,NFS instellen] op te volgen.
. Exporteer de map via NFS door het volgende aan [.filename]#/etc/exports# toe te voegen:
+
[.programlisting]
....
/b -ro -alldirs
....
+
. Herstart de NFS-server:
+
[source,bash]
....
# service nfsd restart
....
+
. Stel man:inetd[8] in door de stappen zoals in crossref:network-servers[network-inetd-settings,Instellingen] beschreven op te volgen.
. Voeg de volgende regel toe aan [.filename]#/etc/inetd.conf#:
+
[.programlisting]
....
tftp dgram udp wait root /usr/libexec/tftpd tftpd -l -s /b/tftpboot
....
+
. Herstart inetd:
+
[source,bash]
....
# service inetd restart
....
+
. <<makeworld,Herbouw de kernel en userland van FreeBSD>>:
+
[source,bash]
....
# cd /usr/src
# make buildworld
# make buildkernel
....
+
. Installeer FreeBSD in de map die over NFS is aangekoppeld:
+
[source,bash]
....
# make installworld DESTDIR=${NFSROOTDIR}
# make installkernel DESTDIR=${NFSROOTDIR}
# make distribution DESTDIR=${NFSROOTDIR}
....
+
. Test dat de TFTP-server werkt en dat het de bootloader dat via PXE verkregen zal worden kan downloaden:
+
[source,bash]
....
# tftp localhost
tftp> get FreeBSD/install/boot/pxeboot
Received 264951 bytes in 0.1 seconds
....
+
. Voeg een regel aan [.filename]#${NFSROOTDIR}/etc/fstab# toe om het root-bestandssysteem over NFS aan te koppelen:
+
[.programlisting]
....
# Device                                            Mountpoint    FSType   Options  Dump Pass
mijnhost.example.com:/b/tftpboot/FreeBSD/install      /         nfs      ro        0    0
....
+ 
Vervang _mijnhost.example.com_ door de hostnaam of het IP-adres van uw NFS-server. In dit voorbeeld wordt het root-bestandssysteem als alleen-lezen aangekoppeld om te voorkomen dat NFS-cliënten per ongeluk de inhoud van het root-bestandssysteem wissen.
. Stel het root-wachtwoord in voor de man:chroot[8]-omgeving.
+
[source,bash]
....
# chroot ${NFSROOTDIR}
# passwd
....
+ 
Dit stelt het root-wachtwoord in voor cliëntmachines die over PXE opstarten.
. Maak root-logins over SSH mogelijk voor cliëntmachines die met PXE opstarten door [.filename]#${NFSROOTDIR}/etc/ssh/sshd_config# te bewerken en de optie `PermitRootLogin` aan te zetten. Dit is gedocumenteerd in man:sshd_config[5].
. Pas andere wijzigingen toe aan de man:chroot[8]-omgeving in ${NFSROOTDIR}. Deze wijzigingen zouden het toevoegen van pakketten met man:pkg_add[1], het bewerken van het wachtwoordbestand met man:vipw[8] of het bewerken van man:amd.conf[8]-projecties voor automatisch aankoppelen kunnen zijn. Bijvoorbeeld:
+
[source,bash]
....
# chroot ${NFSROOTDIR}
# pkg_add -r bash
....
====

=== Geheugenbestandssystemen die gebruikt worden door [.filename]#/etc/rc.initdiskless# configureren

Als u vanaf een NFS-rootvolume opstart, detecteert [.filename]#/etc/rc# dat u over NFS opstartte en draait het het script [.filename]#/etc/rc.initdiskless#. Lees het commentaar in dit script om te begrijpen wat er gebeurt. Het is nodig om [.filename]#/etc# en [.filename]#/var# geheugen-backed te maken omdat deze mappen schrijfbaar moeten zijn, maar de NFS-rootmap is alleen-lezen.

[source,bash]
....
# chroot ${NFSROOTDIR}
# mkdir -p conf/base
# tar -c -v -f conf/base/etc.cpio.gz --format cpio --gzip etc
# tar -c -v -f conf/base/var.cpio.gz --format cpio --gzip var
....

Wanneer het systeem opstart, zullen er geheugen-bestandssystemen voor [.filename]#/etc# en [.filename]#/var# worden aangemaakt en aangekoppeld, en zal de inhoud van de [.filename]#cpio.gz#-bestanden er naartoe worden gekopieerd.

[[network-pxe-setting-up-dhcp]]
=== Een DHCP-server prepareren

PXE heeft een geprepareerde TFTP-server en DHCP-server nodig. De DHCP-server hoeft niet per së dezelfde machine te zijn als de TFTP-server, maar het dient bereikbaar te zijn in uw netwerk.

[.procedure]
====

. Installeer de DHCP-server door de instructies op te volgen zoals beschreven in crossref:network-servers[network-dhcp-server,Een DHCP-server installeren en instellen]. Zorg ervoor dat [.filename]#/etc/rc.conf# en [.filename]#/usr/local/etc/dhcpd.conf# correct zijn geconfigureerd.
. Stel in [.filename]#/usr/local/etc/dhcpd.conf#`next-server`, `filename` en `option root-path` in om het IP-adres van uw TFTP-server, het pad naar [.filename]#/boot/pxeboot# en het pad naar het NFS-root-bestandssysteem op te geven. Hier is een voorbeeld van de instellingen voor [.filename]#dhcpd.conf#:
+
[.programlisting]
....
subnet 192.168.0.0 netmask 255.255.255.0 {
   range 192.168.0.2 192.168.0.3 ;
   option subnet-mask 255.255.255.0 ;
   option routers 192.168.0.1 ;
   option broadcast-address 192.168.0.255 ;
   option domain-name-server 192.168.35.35, 192.168.35.36 ;
   option domain-name "example.com";

   # IP-adres van TFTP server
   next-server 192.168.0.1 ;

   # pad van bootloader verkregen via TFTP
   filename "FreeBSD/install/boot/pxeboot" ;

   # pxeboot bootloader zal proberen om deze map te NFS-mounten voor root-FS
   option root-path "192.168.0.1:/b/tftpboot/FreeBSD/install/" ;
}
....
====

=== De PXE-cliënt configureren en verbindingsproblemen opsporen

[.procedure]
====

. Ga naar het BIOS-configuratiemenu wanneer de cliëntmachine opstart. Stel het BIOS zo in dat het van het netwerk opstart. Indien alle vorige configuratiestappen correct zijn, zou alles "gewoon" moeten werken.
. Gebruik de poort package:net/wireshark[] om netwerkverkeer met betrekking tot het PXE-opstartproces te debuggen, wat geïllustreerd is in onderstaand diagram. In <<network-pxe-setting-up-dhcp>> is een voorbeeldconfiguratie gegeven waarbij de DHCP-, TFTP- en NFS-servers op dezelfde machine staan. Deze servers kunnen echter op verschillende machines staan.
+
.PXE-opstartproces met NFS-root-mount
image::pxe-nfs.png[]
+
. Controleer dat het bestand [.filename]#pxeboot# via TFTP kan worden verkregen. Kijk op uw TFTP-server in [.filename]#/var/log/xferlog# om er zeker van de zijn dat het bestand [.filename]#pxeboot# van de juiste locatie is opgehaald. Om de configuratie met bovenstaande [.filename]#dhcpd.conf# te testen:
+
[source,bash]
....
# tftp 192.168.0.1
tftp> get FreeBSD/install/boot/pxeboot
Received 264951 bytes in 0.1 seconds
....
+ 
Lees man:tftpd[8] en man:tftp[1]. De `BUGS` secties in deze pagina's documenteren enkele beperkingen van TFTP.
. Controleer dat het root-bestandssysteem via NFS kan worden aangekoppeld. Om de configuratie met bovenstaande [.filename]#dhcpd.conf# te testen:
+
[source,bash]
....
# mount -t nfs 192.168.0.1:/b/tftpboot/FreeBSD/install /mnt
....
+
. Lees de code in [.filename]#src/sys/boot/i386/libi386/pxe.c# om te begrijpen hoe de [.filename]#pxeboot#-lader variabelen als `boot.nfsroot.server` en `boot.nfsroot.path` instelt. Deze variabelen worden vervolgens gebruikt in de root-aankoppelcode voor diskvrij NFS in [.filename]#src/sys/nfsclient/nfs_diskless.c#.
. Lees man:pxeboot[8] en man:loader[8].
====

[[network-isdn]]
== ISDN

Een goede bron voor informatie over de technologie van en hardware over ISDN is http://www.alumni.caltech.edu/~dank/isdn/[Dan Kegel's ISDN Page].

Hieronder staat een snelle eenvoudige handleiding voor ISDN:

* Indien u in Europa leeft is het raadzaam om de sectie over ISDN-kaarten te bestuderen.
* Indien het plan is om ISDN hoofdzakelijk te gebruiken om via een niet-toegewijde inbellijn een verbinding met het Internet te maken, zijn Terminal Adapters wellicht een optie. Dit biedt de meeste flexibiliteit, en de minste problemen bij het wisselen van providers.
* Indien twee LANs met elkaar verbonden worden, of indien er een toegewijde ISDN-verbinding wordt gebruikt om met het Internet te verbinden, is het gebruik van een zelfstandige router/bridge te overwegen.

Financiële kosten zijn een belangrijke factor in de uiteindelijke oplossing. De volgende opties zijn gesorteerd in volgorde van oplopende kosten.

[[network-isdn-cards]]
=== ISDN-kaarten

De ISDN-implementatie in FreeBSD biedt alleen ondersteuning voor de DSS1/Q.931 (of Euro-ISDN) standaard indien passieve kaarten gebruikt worden. Sommige actieve kaarten worden ondersteund indien de firmware ook ondersteuning voor andere signaleringsprotocollen biedt; dit omvat ook de eerst ondersteunde Primary Rate (PRI) ISDN-kaart.

De isdn4bsd-software biedt de mogelijkheid om met andere ISDN-routers te verbinden door òfwel IP over rauwe HDLC òfwel synchrone PPP te gebruiken: òfwel via kernel-PPP met `isppp`, een aangepast stuurprogramma voor man:sppp[4], òfwel via het gebruikersprogramma man:ppp[8]. Door het gebruikersprogramma man:ppp[8] te gebruiken, is het combineren van twee of meer ISDN B-kanalen mogelijk. Ook zijn een toepassing die de telefoon beantwoordt en vele gereedschappen zoals een 300 Baud-modem in software beschikbaar.

Een groeiend aantal ISDN-kaarten voor de PC wordt door FreeBSD ondersteund en volgens de rapportages wordt het succesvol in heel Europa en in vele andere delen van de wereld gebruikt.

De ondersteunde passieve ISDN-kaarten zijn meestal uitgerust met de Infineon (voormalig Siemens) ISAC/HSCX/IPAC ISDN-chipsets, maar ook worden ISDN-kaarten ondersteund met chips van Cologne Chip (alleen ISA-bus), PCI-kaarten met Winbond W6692-chips, enkele kaarten met combinaties van Tiger300/320/ISAC chipsets en enkele kaarten die gebaseerd zijn op fabrikantspecifieke chipsets zoals de AVM Fritz!Card PCI V.1.0 en de AVM Fritz!Card PnP.

Momenteel zijn de actieve ISDN-kaarten die ondersteund worden de AVM B1 (ISA en PCI) BRI-kaarten en de AVM T1 PCI PRI-kaarten.

Kijk voor documentatie over isdn4bsd op de http://www.freebsd-support.de/i4b/[homepage van isdn4bsd], welke ook verwijzingen naar tips, errata, en veel meer documentatie zoals het http://people.FreeBSD.org/~hm/[isdn4bsd handboek] bevat.

Indien er interesse is om ondersteuning voor een ander ISDN-protocol, een momenteel niet-ondersteunde ISDN-kaart voor de PC, of een andere verbetering voor isdn4bsd toe te voegen, dient er contact opgenomen te worden met {hm}.

Voor vragen over het installeren, instellen, en problemen met isdn4bsd oplossen is er een mailinglijst, link:{freebsd-isdn-url}[freebsd-isdn], beschikbaar.

=== ISDN Terminal Adapters

Terminal adapters (TA) zijn voor ISDN wat modems voor gewone telefoonlijnen zijn.

De meeste TA's gebruiken de standaard opdrachtenverzameling van de Hayes-modem, en kunnen direct als vervanging van een modem gebruikt worden.

Een TA zal als een gewoon modem werken behalve dat de verbindings- en doorvoersnelheden veel hoger zullen zijn dan van het oude modem. Het is noodzakelijk om crossref:ppp-and-slip[ppp,PPP] precies hetzelfde als voor het modem in te stellen. Zorg ervoor dat de seriële snelheid zo hoog mogelijk wordt ingesteld.

Het grootste voordeel van met een TA met een internetprovider te verbinden is de mogelijkheid tot dynamisch PPP. Aangezien IP-adresruimte steeds schaarser wordt, zijn de meeste providers niet meer bereid om een statisch IP te geven. De meeste zelfstandige routers zijn niet in staat tot dynamische IP-toewijzing.

TA's zijn geheel afhankelijk van het PPP-daemon dat gedraaid wordt voor hun mogelijkheden en stabiliteit van de verbinding. Dit maakt het mogelijk om gemakkelijk om op een FreeBSD-machine van een modem naar ISDN over te gaan, indien PPP reeds is ingesteld. Echter, dezelfde problemen die er waren met het PPP-programma zullen blijven voorkomen.

Indien maximale stabiliteit gewenst is, dient de kernel crossref:ppp-and-slip[ppp,PPP]-, niet de crossref:ppp-and-slip[userppp,gebruikers-PPP]-optie gebruikt te worden.

Van de volgende TA's is bekend dat ze met FreeBSD werken:

* Motorola BitSurfer en BitSurfer Pro
* Adtran

De meeste andere TA's zullen waarschijnlijk ook werken, TA-verkopers proberen er zeker van te zijn dat hun product het meeste van de AT-opdrachtverzameling van het standaardmodem accepteert.

Het echte probleem met externe TA's is dat, net zoals bij modems, een goede seriële kaart in de computer nodig is.

Voor een goed begrip van seriële apparaten dient de tutorial link:{serial-uart}[FreeBSD Serial Hardware] en de verschillen tussen asynchrone en synchrone seriële poorten gelezen te worden.

Een TA die op een standaard seriële poort (asynchroon) van een PC draait beperkt de snelheid tot 115.2 Kbps, zelfs als er een 128 Kbps-verbinding beschikbaar is. Om de volledige 128 Kbps waartoe ISDN in staat is te gebruiken, dient de TA op een synchrone seriële kaart overgeplaatst te worden.

Het kopen van een interne TA voorkomt het probleem van synchroon/asynchroon niet. Interne TA's hebben simpelweg een seriële poortchip van een standaard PC ingebouwd. Dit ontlast de gebruiker alleen van het kopen van nog een seriële kabel en het vinden van nog een leeg elektronisch uitbreidingsslot.

Een synchrone kaart met een TA is minstens zo snel als een zelfstandige router, en wanneer het door een eenvoudige 386 met FreeBSD erop wordt aangestuurd, waarschijnlijk flexibeler.

De keuze tussen synchrone kaart/TA en zelfstandige router is grotendeels religieus. Hierover zijn wat discussies in de mailinglijsten gevoerd. Het wordt aangeraden om de link:https://www.FreeBSD.org/search/[archieven] te doorzoeken voor de volledige discussie.

=== Zelfstandige ISDN bridges/routers

ISDN-bridges of -routers zijn in het geheel niet specifiek voor FreeBSD of enig ander besturingssysteem. Raadpleeg voor een volledigere beschrijving van de technologie van routing en bridging een referentieboek over netwerken.

In deze sectie zullen de termen router en bridge door elkaar worden gebruikt.

Aangezien de prijzen van eenvoudige ISDN-routers/-bridges zakken, zal dit waarschijnlijk een steeds populairdere keuze worden. Een ISDN-router is en kleine doos die direct in het plaatselijke Ethernetnetwerk geprikt wordt, en zijn eigen verbinding met de andere bridge/router beheert. Het heeft ingebouwde software om via PPP en andere populaire protocollen te communiceren.

Een router staat veel snellere doorvoer dan een standaard-TA toe, aangezien het een volledig synchrone ISDN-verbinding zal gebruiken.

Het grootste probleem met ISDN-routers en -bridges is dat samenwerking tussen fabrikanten nog steeds een probleem kan zijn. Indien er plannen zijn om met een internetprovider te verbinden, is het raadzaam de wensen met hen te bespreken.

Indien er gepland is om twee LAN-segmenten met elkaar te verbinden, zoals het thuis-LAN en het kantoor-LAN, is dit de eenvoudigste en onderhoudarmste oplossing. Aangezien de apparatuur voor beide kanten van de verbinding wordt gekocht is het zeker dat de verbinding zal werken.

De volgende installatie kan worden gebruikt om bijvoorbeeld een thuiscomputer of een netwerk van een afdelingskantoor met een netwerk van het hoofdkantoor te verbinden:

.Netwerk van afdelingskantoor of thuis
[example]
====
Het netwerk gebruikt een topologie gebaseerd op een bus met een 10 base 2 Ethernet ("thinnet"). Verbind indien nodig de router met de netwerkkabel met een AUI/10BT transceiver.

image::isdn-bus.png[10 Base 2 Ethernet]

Wanneer het thuis-/afdelingskantoornetwerk uit slechts één computer bestaat kan een twisted-pair crossover-kabel gebruikt worden om direct met de zelfstandige router te verbinden.
====

.Hoofdkantoor- of ander LAN
[example]
====
Het netwerk gebruikt een stertopologie met 10 base T Ethernet ("Twisted Pair").

image::isdn-twisted-pair.png[ISDN Netwerkdiagram]

====

Een groot voordeel van de meeste routers/bridges is dat ze _gelijktijdig_ 2 _gescheiden onafhankelijke_ PPP-verbindingen met 2 gescheiden sites toestaan. Dit wordt door de meeste TA's niet ondersteund, behalve voor specifieke (gewoonlijk dure) modellen die twee seriële poorten hebben. Dit dient niet met kanaalbinding, MPP, etcetera verward te worden.

Dit kan een erg handige eigenschap zijn indien, bijvoorbeeld, er een toegewijde ISDN-verbinding op kantoor is en het gewenst is om deze af te tappen, maar een andere ISDN-lijn op het werk ongewenst is. Een router op kantoor kan een toegewijde B-kanaal verbinding (64 Kbps) met het Internet beheren en het andere B-kanaal voor een gescheiden gegevensverbinding gebruiken. Het tweede B-kanaal kan voor inbellen, uitbellen, of dynamisch binden (MPP, etcetera) gebruikt worden met het eerste B-kanaal voor meer bandbreedte.

Een Ethernet-bridge staat ook toe om meer dan alleen IP-verkeer te verzenden. Het is ook mogelijk om IPX/SPX of enig ander protocol te gebruiken.

[[network-natd]]
== Network Address Translation

[[network-natoverview]]
=== Overzicht

Het Network Address Translation daemon van FreeBSD, in het algemeen bekend als man:natd[8], is een daemon dat rauwe binnenkomende IP-pakketten accepteert, de bron naar die van de plaatselijke machine verandert en de pakketten terug in de uitgaande IP-pakketstroom injecteert. man:natd[8] doet dit door het IP-adres en de poort van de bron zo te veranderen dat wanneer de gegevens weer ontvangen worden, het in staat is om de originele plaats van de gegevens te achterhalen en ze door te sturen naar de originele aanvrager.

NAT wordt het meest gebruikt wat in het algemeen bekend is als het delen van een Internetverbinding.

[[network-natsetup]]
=== Installatie

Wegens de krimpende IP-ruimte in IPv4, en het groeiend aantal gebruikers van consumentenlijnen op hoge snelheid zoals kabel of DSL, hebben steeds meer mensen een oplossing als het delen van een Internetverbinding nodig. Vanwege de mogelijkheid om meerdere computers online te verbinden door één verbinding en IP-adres is man:natd[8] een redelijke keuze.

In de meeste gevallen heeft een gebruiker een machine verbonden met een kabel- of DSL-lijn met één IP-adres en is het gewenst om deze ene verbonden computer te gebruiken om Internettoegang aan meerdere computers over een LAN te geven.

Hiervoor dient de FreeBSD-machine op het Internet dienst doen als gateway. Deze gateway-machine heeft twee NICs nodig - één voor de verbinding met de Internetrouter, de andere voor de verbinding met het LAN. Alle machines op het LAN zijn verbonden door een hub of switch.

[NOTE]
====
Er zijn vele manieren om een LAN via een FreeBSD-gateway met het Internet te verbinden. Dit voorbeeld behandelt slechts een gateway met tenminste twee NICs.
====

image::natd.png[Netwerkschema]

Dit soort installaties wordt in het algemeen gebruikt om een Internetverbinding te delen. Eén van de LAN-machines is verbonden met het Internet. De rest van de machines hebben internettoegang via die "gateway"-machine.

[[network-natdloaderconfiguration]]
=== Bootloader-configuratie

De mogelijkheden van de kernel voor network address translation met man:natd[8] staan niet aan in [.filename]#GENERIC#, maar ze kunnen worden voorgeladen tijdens het opstarten door enkele opties aan [.filename]#/boot/loader.conf# toe te voegen:

[.programlisting]
....
ipfw_load="YES"
ipdivert_load="YES"
....

Ook moet de tunable `net.inet.ip.fw.default_to_accept` op `1` worden gezet:

[.programlisting]
....
net.inet.ip.fw.default_to_accept="1"
....

[NOTE]
====
Het is een goed idee om deze optie aan te zetten tijdens de eerste pogingen om een firewall en NAT gateway te installeren. Op deze manier zal het standaardbeleid van man:ipfw[8] `allow ip from any to any` zijn in plaats van het minder vrije `deny ip from any to any`, en zal het iets moeilijker zijn om buitengesloten te worden net na het opnieuw opstarten van het systeem.
====

[[network-natdkernconfiguration]]
=== Kernelconfiguratie

Wanneer modules geen optie zijn of wanneer het gewenst is om alle benodigde mogelijkheden in de draaiende kernel te bouwen, dienen de volgende opties in het kernelinstellingenbestand aanwezig te zijn:

[.programlisting]
....
options IPFIREWALL
options IPDIVERT
....

De volgende opties kunnen ook van pas komen:

[.programlisting]
....
options IPFIREWALL_DEFAULT_TO_ACCEPT
options IPFIREWALL_VERBOSE
....

[[network-natdsystemconfiguration]]
=== Systeeminstellingen voor het opstarten

Om de firewall en NAT tijdens het opstarten aan te zetten, moet het volgende in [.filename]#/etc/rc.conf# staan:

[.programlisting]
....
gateway_enable="YES" <.>
firewall_enable="YES" <.>
firewall_type="OPEN" <.>
natd_enable="YES"
natd_interface="fxp0" <.>
natd_flags="" <.>
....

<.> Stelt de machine in om dienst te doen als gateway. Het draaien van `sysctl net.inet.ip.forwarding=1` heeft hetzelfde effect.

<.> Activeert de firewall-regels in [.filename]#/etc/rc.firewall# tijdens het opstarten.

<.> Dit specificeert een vooraf gedefinieerde verzameling van firewall-regels die alles binnenlaat. Raadpleeg [.filename]#/etc/rc.firewall# voor aanvullende types.

<.> Geeft aan welke interface te gebruiken om pakketten naar door te sturen (de interface die met het Internet verbonden is).

<.> Alle aanvullende instelopties die tijdens het opstarten aan man:natd[8] worden doorgegeven.

Het gedefinieerd hebben van de bovenstaande opties in [.filename]#/etc/rc.conf# zal `natd -interface fxp0` draaien tijdens het opstarten. Dit kan ook handmatig worden gedraaid.

[NOTE]
====
Het is ook mogelijk om een instellingenbestand voor man:natd[8] te gebruiken als er teveel opties zijn om door te geven. In dit geval dient het instellingenbestand te worden gedefinieerd door de volgende regel aan [.filename]#/etc/rc.conf# toe te voegen:

[.programlisting]
....
natd_flags="-f /etc/natd.conf"
....

Het bestand [.filename]#/etc/natd.conf# zal een lijst met instelopties bevatten, één per regel. Het geval in de volgende sectie bijvoorbeeld zal het volgende bestand gebruiken:

[.programlisting]
....
redirect_port tcp 192.168.0.2:6667 6667
redirect_port tcpc 192.168.0.3:80 80
....

Raadpleeg voor meer informatie over het instellingenbestand het gedeelte over de optie `-f` van de hulppagina man:natd[8].
====

Elke machine en interface achter het LAN dient een IP-adres in de privé-netwerkruimte toegewezen te krijgen zoals gedefinieerd in link:ftp://ftp.isi.edu/in-notes/rfc1918.txt[RFC 1918] en een standaard gateway van het interne IP-adres van de natd-machine hebben.

Bijvoorbeeld, cliënt `A` en `B` achter het LAN hebben IP-adressen `192.168.0.2` en `192.168.0.3`, terwijl de LAN-interface van de natd-machine IP-adres `192.168.0.1` heeft. De standaard gateway van cliënt `A` en `B` dient ingesteld te worden op die van de natd-machine, `192.168.0.1`. Voor de externe, of Internet-interface van de natd-machine zijn geen speciale wijzigingen nodig om man:natd[8] te laten werken.

[[network-natdport-redirection]]
=== Poorten omleiden

Het nadeel van man:natd[8] is dat de LAN-cliënten niet vanaf het Internet toegankelijk zijn. Cliënten op het LAN kunnen uitgaande verbinden naar de wereld maken maar kunnen geen inkomende verbindingen ontvangen. Dit vormt een probleem wanneer geprobeerd wordt om Internetdiensten op een van de LAN-cliëntmachines te draaien. Een eenvoudige om dit te omzeilen is om bepaalde Internetpoorten op de natd-machine om te leiden naar een LAN-cliënt.

Bijvoorbeeld, er draait een IRC-server op cliënt `A`, en er draait een webserver op cliënt `B`. Om dit goed te laten werken, dienen verbindingen die worden ontvangen op poorten 6667 (IRC) en 80 (web) te worden omgeleid naar de respectievelijke machines.

De optie `-redirect_port` dient aan man:natd[8] met de juiste opties te worden doorgegeven. De syntaxis is als volgt:

[.programlisting]
....
     -redirect_port proto doelIP:doelPOORT[-doelPOORT]
                 [aliasIP:]aliasPOORT[-aliasPOORT]
                 [verIP[:verrePOORT[-verrePOORT]]]
....

In het bovenstaand voorbeeld dienen de argumenten te zijn:

[.programlisting]
....
     -redirect_port tcp 192.168.0.2:6667 6667
-redirectport tcp 192.168.0.3:80 80
....

Dit zal de juiste _tcp_-poorten naar de LAN-cliënt-machines omleiden.

Het argument `-redirect_port` kan worden gebruikt om poortbereiken over individuele poorten aan te geven. Bijvoorbeeld, _tcp 192.168.0.2:2000-3000 2000-3000_ zal alle verbindingen die op poorten 2000 tot 3000 worden ontvangen omleiden naar poorten 2000 tot 3000 op cliënt `A`.

Deze opties kunnen worden gebruikt wanneer man:natd[8] direct wordt gedraaid, wanneer ze zijn geplaatst in de optie `natd_flags=""` van [.filename]#/etc/rc.conf#, of wanneer ze via een instellingenbestand worden doorgegeven.

Raadpleeg voor meer instelopties man:natd[8].

[[network-natdaddress-redirection]]
=== Adressen omleiden

Adressen omleiden is handig wanneer er verschillende IP-adressen beschikbaar zijn, maar ze op één machine moeten zitten. Hiermee kan man:natd[8] aan elke LAN-cliënt een eigen extern IP-adres toewijzen. Vervolgens overschrijft man:natd[8] de uitgaande pakketten van de LAN-cliënten met het juiste IP-adres en leidt het al het binnenkomende verkeer op dat ene IP-adres terug naar de specifieke LAN-cliënt. Dit staat ook bekend als statisch NAT. Bijvoorbeeld, de IP-adressen `128.1.1.1`, `128.1.1.2`, en `1281.2..3` behoren toe aan de natd gateway-machine. `128.1.1.1` kan gebruikt worden als het externe IP-adres van de natd gateway-machine, terwijl `128.1.1.2` en `128.1.1.3` terug worden gestuurd naar de LAN-cliënten `A` en `B`.

De syntaxis van `-redirect_address` is als volgt:

[.programlisting]
....
-redirect_address lokaalIP publiekIP
....

[.informaltable]
[cols="1,1", frame="none"]
|===

|lokaalIP
|Het interne IP-adres van de LAN-cliënt.

|publiekIP
|Het externe IP-adres overeenkomend met de LAN-cliënt.
|===

In het voorbeeld zou dit argument zijn:

[.programlisting]
....
-redirect_address 192.168.0.2 128.1.1.2
-redirect_address 192.168.0.3 128.1.1.3
....

Net zoals `-redirect_port` worden ook deze argumenten geplaatst in de optie `natd_flags=""` van [.filename]#/etc/rc.conf#, of doorgegeven via een instellingenbestand. Met adresomleiding is het omleiden van poorten niet nodig aangezien alle gegevens die op een bepaald IP-adres worden ontvangen worden omgeleidt.

Het externe IP-adres op de natd machine dient actief en naar een externe interface gealiased te zijn. In man:rc.conf[5] staat hoe dit te doen.

[[network-ipv6]]
== IPv6

IPv6 (ook bekend als IPng "IP next generation") is de nieuwe versie van het welbekende IP-protocol (ook bekend als IPv4). Net zoals de andere huidige *BSD-systemen, bevat FreeBSD de referentie-implementatie van KAME IPv6. Het FreeBSD-systeem wordt dus geleverd met alles wat nodig is om met IPv6 te experimenteren. Deze sectie richt zich op het ingesteld en draaiend krijgen van IPv6.

In de vroege jaren 1990 werden mensen zich bewust van de snel krimpende adresruimte van IPv4. De uitbreidingssnelheid van het Internet baarde twee grote zorgen:

* Geen adresruimte meer. Tegenwoordig is dit niet zo'n probleem meer aangezien RFC1918 voor privé-adresruimte (`10.0.0.0/8`, `172.16.0.0/12`, en `192.168.0.0/16`) en Network Address Translation (NAT) worden gebruikt.
* De regels in de routeertabellen werden te groot. Dit is tegenwoordig nog steeds een probleem.

IPv6 behandelt deze en vele andere zaken:

* 128-bits adresruimte. Met andere woorden, er zijn theoretisch 340.282.366.920.938.463.463.374.607.431.768.211.456 adressen beschikbaar. Dit betekent dat er ongeveer 6,67 * 10^27 IPv6-adressen per vierkante meter op onze planeet beschikbaar zijn.
* Routers zullen alleen netwerkaggregatie-adressen in hun routeertabellen opslaan en dus de gemiddelde ruimte van een routeertabel verkleinen tot 8192 regels.

IPv6 heeft ook vele andere nuttige eigenschappen zoals:

* Automatische adresconfiguratie (http://www.ietf.org/rfc/rfc2462.txt[RFC2462])
* Anycast-adressen ("ééen-van-velen")
* Verplichte multicast-adressen
* IPsec (IP security)
* Versimpelde structuur van de headers
* Mobiele IP
* Overgangsmechanismen voor IPv6 naar IPv4

Bekijk voor meer informatie:

* IPv6-overzicht op http://playground.sun.com/pub/ipng/html/ipng-main.html[playground.sun.com]
* http://www.kame.net[KAME.net]

=== Achtergrond over IPv6 adressen

Er zijn verschillende soorten IPv6-adressen: unicast, anycast, en multicast.

Unicast-adressen zijn de bekende adressen. Een pakket dat naar een unicast-adres wordt verzonden arriveert precies op de interface dat bij dat adres hoort.

Anycast-adressen zijn syntactisch niet van unicast-adressen te onderscheiden maar ze adresseren een groep interfaces. Een pakket dat bestemd is voor een anycast-adres zal bij de dichtstbijzijnde interface arriveren (in router-metrieken). Anycast-adressen mogen alleen door routers worden gebruikt.

Multicast-adressen identificeren een groep interfaces. Een pakket dat bestemd is voor en multicast-adres zal bij alle interfaces die bij de multicast-groep horen arriveren.

[NOTE]
====
Het broadcast-adres van IPv4 (gewoonlijk `xxx.xxx.xxx.255`) wordt in IPv6 met multicast-adressen uitgedrukt.
====

.Gereserveerde IPv6-adressen
[cols="1,1,1,1", frame="none", options="header"]
|===
| IPv6-adres
| Prefixlengte (bits)
| Beschrijving
| Opmerkingen

|`::`
|128 bits
|niet gespecificeerd
|cf. `0.0.0.0` in IPv4

|`::1`
|128 bits
|teruglusadres
|cf. `127.0.0.1` in IPv4

|`::00:xx:xx:xx:xx`
|96 bits
|ingebouwd IPv4
|De laagste 32 bits zijn het IPv4-adres. Ook "IPv4 compatibel IPv6-adres" genoemd.

|`::ff:xx:xx:xx:xx`
|96 bits
|IPv4-afgebeeld IPv6-adres
|De laagste 32 bits zijn het IPv4-adres. Voor hosts die geen IPv6 ondersteunen.

|`fe80::` - `feb::`
|10 bits
|link-lokaal
|cf. teruglusadres in IPv4

|`fec0::` - `fef::`
|10 bits
|site-lokaal
|

|`ff::`
|8 bits
|multicast
|

|`001` (base 2)
|3 bits
|globale unicast
|Alle globale unicast-adressen worden vanuit deze pool toegewezen. De eerste 3 bits zijn "001".
|===

=== IPv6-adressen lezen

De canonieke vorm wordt weergegeven als: `x:x:x:x:x:x:x:x`, waarbij elke "x" een 16-bits hexadecimale waarde is. Bijvoorbeeld `FEBC:A574:382B:23C1:AA49:4592:4EFE:9982`

Vaak bevat een adres lange deelstrings van allen nullen, daarom kan per adres één zo'n deelstring worden afgekort als "::". Ook kunnen maximaal drie voorlopende "0"'s per hexadecimaal viertal worden weggelaten. Bijvoorbeeld, `fe80::1` komt overeen met de canonieke vorm `fe80:0000:0000:0000:0000:0000:0000:0001`.

Een derde vorm is het schrijven van de laatste 32 bits in de bekende (decimale) IPv4-stijl met punten "." als scheidingstekens. Bijvoorbeeld, `2002::10.0.0.1` komt overeen met de (hexadecimale) canonieke representatie `2002:0000:0000:0000:0000:0000:0a00:0001` wat weer hetzelfde is als `2002::a00:1`.

Op dit punt dient de lezer het volgende te begrijpen:

[source,bash]
....
# ifconfig
....

[.programlisting]
....
rl0: flags=8943<UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST> mtu 1500
        inet 10.0.0.10 netmask 0xffffff00 broadcast 10.0.0.255
        inet6 fe80::200:21ff:fe03:8e1%rl0 prefixlen 64 scopeid 0x1
        ether 00:00:21:03:08:e1
	media: Ethernet autoselect (100baseTX )
        status: active
....

`fe80::200:21ff:fe03:8e1%rl0` is een automatisch ingesteld link-lokaal adres. Het is als deel van de automatische instelling vanuit het MAC-adres aangemaakt.

Kijk voor verdere informatie over de structuur van IPv6-adressen op http://www.ietf.org/rfc/rfc3513.txt[RFC3513].

=== Verbinding krijgen

Er zijn momenteel vier manieren om met andere IPv6-hosts en -netwerken te verbinden:

* Neem contact op met de Internetprovider om te zien of ze al IPv6 aanbieden.
* http://www.sixxs.net[SixXS] biedt wereldwijd tunnels met eindpunten aan.
* Tunnelen via 6-naar-4 (http:///www.ietf.org/rfc/rfc3608.txt[RFC3068])
* Gebruik de poort package:net/freenet6[] indien er een inbelverbinding wordt gebruikt.

=== DNS in de IPv6-wereld

Er waren twee soorten DNS-records voor IPv6. De IETF heeft A6-records overbodig verklaard. AAAA-records zijn nu de standaard.

AAAA-records gebruiken gaat rechttoe-rechtaan. Wijs de hostnaam toe aan het nieuwe IPv6-adres dat net ontvangen is door het volgende aan de DNS-bestand voor primaire zones toe te voegen:

[.programlisting]
....
MIJNHOSTNAAM          AAAA    MIJNIPv6ADRES
....

Vraag het aan de DNS-provider indien de DNS-zones niet zelf worden geserveerd. De huidige versies van bind (versie 8.3 en 9) en package:dns/djbdns[] (met de IPv6-patch) ondersteunen AAAA-records.

=== De benodigde wijzigingen doorvoeren in [.filename]#/etc/rc.conf#

==== IPv6-cliëntinstellingen

Deze instellingen helpen bij het configureren van een machine in het LAN die als cliënt in plaats van router dienst zal doen. Om man:rtsol[8] automatisch de interface tijdens het opstarten te laten configureren op FreeBSD 9._X_ en nieuwer dient het volgende aan [.filename]#rc.conf# toegevoegd te worden:

[.programlisting]
....
ipv6_prefer="YES"
....

Voeg voor FreeBSD 8._X_ en ouder het volgende toe:

[.programlisting]
....
ipv6_enable="YES"
....

Voeg het volgende toe om statisch een IP-adres zoals `2001:471:1f11:251:290:27ff:fee0:2093` aan de interface [.filename]#fxp0# toe te voegen voor FreeBSD 9._X_:

[.programlisting]
....
ifconfig_fxp0_ipv6="2001:471:1f11:251:290:27ff:fee0:2093 prefixlen 64"
....

[NOTE]
====
Zorg ervoor dat _prefixlen 64_ wordt vervangen door de juiste waarde voor het subnet van de computer.
====

Voeg voor FreeBSD 8._X_ het volgende toe:

[.programlisting]
....
ipv6_ifconfig_fxp0="2001:471:1f11:251:290:27ff:fee0:2093"
....

Voeg het volgende aan [.filename]#/etc/rc.conf# toe om een standaardrouter `2001:471:1f11:251::1` toe te wijzen:

[.programlisting]
....
ipv6_defaultrouter="2001:471:1f11:251::1"
....

==== IPv6 router/gateway instellingen

Deze paragraaf helpt bij het opvolgen van de aanwijzingen die de tunnelprovider heeft gegeven en ze om te zetten in instellingen die blijven na een herstart. Om de tunnel tijdens het opstarten te herstellen kan het volgende in [.filename]#/etc/rc.conf# gebruikt worden:

Noem de generieke tunnelinterfaces die zullen worden ingesteld, bijvoorbeeld [.filename]#gif0#:

[.programlisting]
....
gif_interfaces="gif0"
....

Om de interface met een lokaal eindpunt _MIJN_IPv4_ADRES_ in te stellen naar een ver eindpunt _VER_IPv4_ADRES_:

[.programlisting]
....
gifconfig_gif0="MIJN_IPv4_ADRES VER_IPv4_ADRES"
....

Voeg het volgende toe om het IPv6-adres dat is toegewezen als het eindpunt van de IPv6-tunnel te gebruiken voor FreeBSD 9._X_ en nieuwer:

[.programlisting]
....
ifconfig_gif0_ipv6="inet6 MIJN_TOEGEWEZEN_IPv6_TUNNEL_EINDPUNT_ADRES"
....

Voeg voor FreeBSD 8._X_ en eerder het volgende toe:

[.programlisting]
....
ipv6_ifconfig_gif0="MIJN_TOEGEWEZEN_IPv6_TUNNEL_EINDPUNT_ADRES"
....

Nu hoeft alleen de standaardroute voor IPv6 ingesteld te worden. Dit is de andere kant van de IPv6-tunnel:

[.programlisting]
....
ipv6_defaultrouter="MIJN_IPv6_VER_TUNNEL_EINDPUNT_ADRES"
....

==== IPv6-tunnelinstellingen

Indien de server gebruikt wordt om IPv6 tussen de rest van het netwerk en de wereld te routen, is ook de volgende instelling in [.filename]#/etc/rc.conf# nodig:

[.programlisting]
....
ipv6_gateway_enable="YES"
....

=== Routeradvertentie en automatische hostconfiguratie

Deze sectie helpt bij het instellen van man:rtadvd[8] om de standaard IPv6-route te adverteren.

Het volgende is nodig in [.filename]#/etc/rc.conf# om man:rtadvd[8] aan te zetten:

[.programlisting]
....
rtadvd_enable="YES"
....

Het is belangrijk om de interface te specificeren waarop het IPv6-routerverzoek plaatsvindt. Om bijvoorbeeld man:rtadvd[8] te vertellen om [.filename]#fxp0# te gebruiken:

[.programlisting]
....
rtadvd_interfaces="fxp0"
....

Nu dient het instellingenbestand [.filename]#/etc/rtadvd.conf# aangemaakt te worden. Hier is een voorbeeld:

[.programlisting]
....
fxp0:\
	:addrs#1:addr="2001:471:1f11:246::":prefixlen#64:tc=ether:
....

Vervang [.filename]#fxp0# door de interface die gebruikt gaat worden.

Vervang vervolgens `2001:471:1f11:246::` met de prefix van uw toewijzing.

Indien een `/64` subnet is toegewezen, hoeft er verder niets veranderd te worden. In andere gevallen dient de juiste waarde voor `prefixlen#` gebruikt te worden.

[[network-atm]]
== Asynchronous Transfer Mode (ATM)

=== Klassiek IP configureren over ATM (PVCs)

Klassiek IP over ATM (CLIP) is de eenvoudigste methode om Asynchronous Transfer Mode (ATM) met IP te gebruiken. Het kan met geswitchte verbindingen (SVCs) en met permanente verbindingen (PVCs) gebruikt worden. Deze sectie beschrijft hoe een netwerk gebaseerd op PVCs op te zetten.

==== Volledig geschakelde configuraties

De eerste methode om een CLIP met PVCs op te zetten is om elke machine met elke andere machine in het netwerk te verbinden via een toegewijde PVC. Hoewel dit eenvoudig te configureren is, wordt het onpraktisch voor een groter aantal machines. Dit netwerk gaat ervan uit dat er vier machines in het netwerk zijn, allen verbonden met het ATM netwerk met een ATM adapterkaart. De eerste stap is het plannen van de IP-adressen en de ATM verbindingen tussen de machines. Het volgende wordt gebruikt:

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Host
| IP-adres

|`hostA`
|`192.168.173.1`

|`hostB`
|`192.168.173.2`

|`hostC`
|`192.168.173.3`

|`hostD`
|`192.168.173.4`
|===

Om een volledig geschakeld net te bouwen is er een ATM-verbinding nodig tussen elk paar machines:

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Machines
| VPI.VCI koppel

|`hostA` - `hostB`
|0.100

|`hostA` - `hostC`
|0.101

|`hostA` - `hostD`
|0.102

|`hostB` - `hostC`
|0.103

|`hostB` - `hostD`
|0.104

|`hostC` - `hostD`
|0.105
|===

De VPI- en VCI-waarde kunnen aan beide kanten van de verbinding verschillen, maar voor de eenvoud wordt aangenomen dat ze hetzelfde zijn. Vervolgens dienen de ATM-interfaces op elke host geconfigureerd te worden:

[source,bash]
....
hostA# ifconfig hatm0 192.168.173.1 up
hostB# ifconfig hatm0 192.168.173.2 up
hostC# ifconfig hatm0 192.168.173.3 up
hostD# ifconfig hatm0 192.168.173.4 up
....

aannemende dat de ATM-interface op alle hosts [.filename]#hatm0# is. Nu dienen de PVCs op `hostA` geconfigureerd te worden (er wordt aangenomen dat ze reeds op de ATM-switches zijn geconfigureerd, raadpleeg de handleiding van de switch hoe dit te doen).

[source,bash]
....
hostA# atmconfig natm add 192.168.173.2 hatm0 0 100 llc/snap ubr
hostA# atmconfig natm add 192.168.173.3 hatm0 0 101 llc/snap ubr
hostA# atmconfig natm add 192.168.173.4 hatm0 0 102 llc/snap ubr

hostB# atmconfig natm add 192.168.173.1 hatm0 0 100 llc/snap ubr
hostB# atmconfig natm add 192.168.173.3 hatm0 0 103 llc/snap ubr
hostB# atmconfig natm add 192.168.173.4 hatm0 0 104 llc/snap ubr

hostC# atmconfig natm add 192.168.173.1 hatm0 0 101 llc/snap ubr
hostC# atmconfig natm add 192.168.173.2 hatm0 0 103 llc/snap ubr
hostC# atmconfig natm add 192.168.173.4 hatm0 0 105 llc/snap ubr

hostD# atmconfig natm add 192.168.173.1 hatm0 0 102 llc/snap ubr
hostD# atmconfig natm add 192.168.173.2 hatm0 0 104 llc/snap ubr
hostD# atmconfig natm add 192.168.173.3 hatm0 0 105 llc/snap ubr
....

Uiteraard kunnen ook andere verkeerscontracten dan UBR worden gebruikt indien de ATM-adapter die ondersteunt. In dit geval wordt de naam van het verkeerscontract gevolgd door de parameters van het verkeer. Hulp voor het gereedschap man:atmconfig[8] kan verkregen worden met:

[source,bash]
....
# atmconfig help natm add
....

of in de hulppagina man:atmconfig[8].

Dezelfde configuratie kan ook bereikt worden via [.filename]#/etc/rc.conf#. Voor `hostA` wordt dit:

[.programlisting]
....
network_interfaces="lo0 hatm0"
ifconfig_hatm0="inet 192.168.173.1 up"
natm_static_routes="hostB hostC hostD"
route_hostB="192.168.173.2 hatm0 0 100 llc/snap ubr"
route_hostC="192.168.173.3 hatm0 0 101 llc/snap ubr"
route_hostD="192.168.173.4 hatm0 0 102 llc/snap ubr"
....

De huidige toestand van alle CLIP routes kan worden verkregen met:

[source,bash]
....
hostA# atmconfig natm show
....

[[carp]]
== Common Address Redundancy Protocol (CARP)

Het Common Address Redundancy Protocol, of CARP, staat toe dat meerdere hosts hetzelfde IP-adres gebruiken. In sommige opstellingen wordt dit gebruikt voor beschikbaarheid of loadbalancing. Hosts kunnen ook gescheiden IP-adressen gebruiken, zoals in het voorbeeld dat hier is gegeven.

Om ondersteuning voor CARP aan te zetten, dient de FreeBSD-kernel herbouwd zoals beschreven in crossref:kernelconfig[kernelconfig,De FreeBSD-kernel instellen] met de volgende optie:

[.programlisting]
....
device	carp
....

Als alternatief kan de [.filename]#if_carp.ko# module geladen worden tijdens het opstarten. Voeg de volgende regel toe aan [.filename]#/boot/loader.conf#:

[.programlisting]
....
if_carp_load="YES"
....

De functionaliteit van CARP zou nu beschikbaar moeten zijn en kan met verschillende `sysctl`-OIDs worden bijgesteld:

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| OID
| Beschrijving

|`net.inet.carp.allow`
|Accepteer inkomende CARP pakketten. Staat standaard aan.

|`net.inet.carp.preempt`
|Deze optie zet alle CARP interfaces down op de host wanneer er een down gaat. Staat standaard uit.

|`net.inet.carp.log`
|De waarde `0` zet alle logging uit. De waarde `1` zet het loggen van slechte CARP-pakketten aan. Waardes hoger dan `1` zet het loggen van toestandsveranderingen van de CARP interfaces aan. De standaardwaarde is `1`.

|`net.inet.carp.arpbalance`
|Balanceer lokaal netwerkverkeer met ARP. Staat standaard uit.

|`net.inet.carp.suppress_preempt`
|Een alleen-lezen OID die de toestand van preëmptie-onderdrukking weergeeft. Preëmptie kan worden onderdrukt wanneer de verbinding op een interface afwezig is. De waarde `0` betekent dat preëmptie niet onderdrukt is. Elk probleem verhoogt deze OID.
|===

De CARP-apparaten zelf kunnen met het commando `ifconfig` worden aangemaakt:

[source,bash]
....
# ifconfig carp0 create
....

In een echte omgeving hebben deze interfaces unieke identificatienummers, bekend als een VHID, nodig. Dit VHID of Virtual Host Identification zal worden gebruikt om de hosts op het netwerk te onderscheiden.

=== CARP gebruiken voor serverbeschikbaarheid

Eén gebruik van CARP, zoals boven aangegeven, is serverbeschikbaarheid. Dit voorbeeld geeft failover-ondersteuning voor drie hosts, met allemaal een uniek IP-adres en dezelfde webinhoud. Deze machines zullen samen met een Round Robin DNS configuratie dienst doen. De failover-machine zal twee aanvullende CARP-interfaces hebben, één voor elk van de IP's van de contentservers. Wanneer er een storing optreedt, zou de failover-server het IP-adres van de falende machine moeten oppikken. Dit betekent dat de storing geheel onmerkbaar zou moeten zijn voor de gebruiker. De failover-server heeft dezelfde inhoud en diensten nodig als de andere contentservers waarvoor het moet invallen.

De twee machines dienen identiek geconfigureerd te worden op de gegeven hostnamen en VHIDs na. Dit voorbeeld noemt deze machines respectievelijk `hosta.example.org` en `hostb.example.org`. Ten eerste dienen de benodigde regels voor een CARP-configuratie aan [.filename]#rc.conf# te worden toegevoegd. Voor `hosta.example.org` dient het bestand [.filename]#rc.conf# de volgende regels te bevatten:

[.programlisting]
....
hostname="hosta.example.org"
ifconfig_fxp0="inet 192.168.1.3 netmask 255.255.255.0"
cloned_interfaces="carp0"
ifconfig_carp0="vhid 1 pass testpass 192.168.1.50/24"
....

Op `hostb.example.org` dienen de volgende regels in [.filename]#rc.conf# te staan:

[.programlisting]
....
hostname="hostb.example.org"
ifconfig_fxp0="inet 192.168.1.4 netmask 255.255.255.0"
cloned_interfaces="carp0"
ifconfig_carp0="vhid 2 pass testpass 192.168.1.51/24"
....

[NOTE]
====
Het is erg belangrijk dat de wachtwoorden die met de optie `pass` aan `ifconfig` gegeven zijn, identiek zijn. De [.filename]#carp# apparaten zullen alleen luisteren naar en advertenties accepteren van machines met het juiste wachtwoord. Het VHID dient ook verschillend te zijn voor elke machine.
====

De derde machine, `provider.example.org`, dient voorbereidt te worden op het afhandelen van failover van beide hosts. Deze machine heeft twee [.filename]#carp# apparaten nodig, één om elke host af te handelen. De juiste instelregels voor [.filename]#rc.conf# zullen ongeveer gelijk zijn aan de volgende:

[.programlisting]
....
hostname="provider.example.org"
ifconfig_fxp0="inet 192.168.1.5 netmask 255.255.255.0"
cloned_interfaces="carp0 carp1"
ifconfig_carp0="vhid 1 advskew 100 pass testpass 192.168.1.50/24"
ifconfig_carp1="vhid 2 advskew 100 pass testpass 192.168.1.51/24"
....

Met twee [.filename]#carp# apparaten is `provider.example.org` in staat om het IP-adres van de andere machine op te pikken wanneer de ene niet meer antwoordt.

[NOTE]
====
De standaard FreeBSD-kernel _kan_ preëmptie geactiveerd hebben. In dat geval hoeft `provider.example.org` het IP-adres niet terug te geven aan de originele contentserver. In dit geval kan het nodig zijn dat een beheerder handmatig het IP terug aan de meester moet geven. Het volgende commando dient op `provider.example.org` gegeven te worden:

[source,bash]
....
# ifconfig carp0 down && ifconfig carp0 up
....

Dit dient gedaan te worden op de [.filename]#carp# interface die met de juiste host overeenkomt.
====

Op dit moment dient CARP volledig actief en beschikbaar voor testen te zijn. Voor het testen dienen òfwel het netwerken herstart te worden, òf de machines dienen opnieuw opgestart te worden.

Meer informatie is altijd beschikbaar in de hulppagina man:carp[4]
