---
title: Hoofdstuk 8. Multimedia
part: Deel II. Algemene taken
prev: books/handbook/desktop
next: books/handbook/kernelconfig
---

[[multimedia]]
= Multimedia
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:source-highlighter: rouge
:experimental:
:skip-front-matter:
:toc-title: Inhoudsopgave
:table-caption: Tabel
:figure-caption: Afbeelding
:example-caption: Voorbeeld
:xrefstyle: basic
:relfileprefix: ../
:outfilesuffix:
:sectnumoffset: 8

ifeval::["{backend}" == "html5"]
:imagesdir: ../../../images/books/handbook/multimedia/
endif::[]

ifeval::["{backend}" == "pdf"]
:imagesdir: ../../../../static/images/books/handbook/multimedia/
endif::[]

ifeval::["{backend}" == "epub3"]
:imagesdir: ../../../../static/images/books/handbook/multimedia/
endif::[]

include::shared/authors.adoc[]
include::shared/releases.adoc[]
include::shared/nl/mailing-lists.adoc[]
include::shared/nl/teams.adoc[]
include::shared/nl/urls.adoc[]

toc::[]

[[multimedia-synopsis]]
== Overzicht

FreeBSD ondersteunt een breed bereik aan geluidskaarten, waardoor het mogelijk is van geluid van hoge kwaliteit op een computer te genieten. Hieronder vallen mogelijkheden om geluid op te nemen en af te spelen in de MPEG Audio Layer 3 (MP3), WAV en Ogg Vorbis formaten en vele andere formaten. De FreeBSD Portscollectie bevat ook programma's waarmee opgenomen audio bewerkt kan worden, waarmee geluidseffecten toegevoegd kunnen worden en aangesloten MIDI apparaten bestuurd kunnen worden.

Met wat experimenteren kunnen met FreeBSD videobestanden en DVD's afgespeeld worden. Er zijn minder programma's om video te encoderen, te converteren en af te spelen dan er zijn voor audio. Op het moment van schrijven is er bijvoorbeeld geen goed hercoderingsprogramma in de FreeBSD Portscollectie beschikbaar wat gebruikt kan worden om tussen formaten onderling te converteren, zoals mogelijk is met package:audio/sox[]. De software in dit landschap is echter sterk aan verandering onderhevig.

In dit hoofdstuk worden de stappen beschreven die uitgevoerd moeten worden om een geluidskaart in te stellen. Bij de installatie en instelling van X11 (crossref:x11[x11,Het X Window systeem]) is al beschreven hoe videokaarten ingesteld kunnen worden, hoewel er nog wel een aantal mogelijkheden zijn om het afspelen te verbeteren.

Na het lezen van dit hoofdstuk weet de lezer:

* Hoe een systeem zo in te stellen dat een geluidskaart wordt herkend;
* Hoe getest kan worden of een kaart werkt;
* Hoe problemen op te lossen met betrekking tot geluidsinstellingen;
* Hoe MP3's en andere audio af te spelen en te maken;
* Hoe video wordt ondersteund door de X server;
* Welke video speler/encoderports goede resultaten geven;
* Hoe DVD's, [.filename]#.mpg# en [.filename]#.avi# bestanden af te spelen;
* Hoe de inhoud van CD's en DVD's naar bestanden geript kan worden;
* Hoe een TV-kaart in te stellen;
* Hoe een scanner in te stellen.

Er wordt aangenomen dat de lezer van dit hoofdstuk:

* Weet hoe een nieuwe kernel in te stellen en te installeren (crossref:kernelconfig[kernelconfig,De FreeBSD-kernel instellen]).

[WARNING]
====

Het proberen aan te koppelen van audio-CD's met man:mount[8] resulteert in ieder geval in een foutmelding en in het ergste geval tot een _kernel panic_. Dat type media heeft een formaat dat afwijkt van het gebruikelijke ISO-bestandssysteem.
====

[[sound-setup]]
== Geluidskaart installeren

[[sound-device]]
=== Systeem instellen

Alvorens te beginnen is het van belang te weten welk model een geluidskaart is, welke chip erop wordt gebruikt en of het een PCI of ISA kaart is. FreeBSD ondersteunt vele PCI en ISA kaarten. De ondersteunde audio-apparaten staan in een lijst in de link:{u-rel120-hardware}[Hardware Notes]. In de Hardware Notes staat ook beschreven welk stuurprogramma uw kaart ondersteunt.

Om een geluidsapparaat te gebruiken dient het juiste apparaatstuurprogramma geladen te worden. Dit kan op twee manieren. De meest eenvoudige manier is simpelweg een kernelmodule te laden voor de gewenste geluidskaart met man:kldload[8]. Dit kan vanaf de commandoregel:

[source,bash]
....
# kldload snd_emu10k1
....

Of door als volgt de juiste regel toe te voegen aan [.filename]#/boot/loader.conf#:

[.programlisting]
....
snd_emu10k1_load="YES"
....

De bovenstaande voorbeelden zijn voor een Creative SoundBlaster(R) Live! geluidskaart. De overige beschikbare laadbare geluidsmodules staan beschreven in [.filename]#/boot/defaults/loader.conf#. Als niet compleet duidelijk is welk stuurprogramma gebruikt dient te worden, dan kan het met de module [.filename]#snd_driver# geprobeerd worden:

[source,bash]
....
# kldload snd_driver
....

Dit is een metastuurprogramma, dat in één keer de meest voorkomende apparaatstuurprogramma's laadt. Hiermee kan het zoeken naar het juiste stuurprogramma versneld worden. Het is ook mogelijk om alle geluidsstuurprogramma's te laden via de optie [.filename]#/boot/loader.conf#.

Om uit te vinden welk stuurprogramma na het laden van het metastuurprogramma [.filename]#snd_driver# wordt geladen kan de inhoud van het bestand [.filename]#/dev/sndstat# nagekeken worden met `cat /dev/sndstat`.

Een tweede mogelijkheid is ondersteuning voor een geluidskaart statisch in de kernel te compileren. In de onderstaande paragrafen staat meer informatie over hoe op die manier ondersteuning voor hardware toegevoegd kan worden. Meer informatie over het hercompileren van een kernel staat in crossref:kernelconfig[kernelconfig,De FreeBSD-kernel instellen].

==== Aangepaste kernel maken met geluidsondersteuning

Eerst moet het stuurprogramma voor het audioraamwerk man:sound[4] aan de kernel toegevoegd worden. Daarvoor dient het volgende te worden opgenomen in het bestand met kernelinstellingen:

[.programlisting]
....
device sound
....

Daarna kan ondersteuning voor de specifieke geluidskaart toegevoegd worden. Daarvoor moet bekend zijn welk stuurprogramma de kaart ondersteunt. Dit kan opgezocht worden in de lijst met ondersteunde audio-apparaten in de link:{u-rel120-hardware}[Hardware Notes], waar de correcte stuurprogramma's voor geluidskaarten beschreven staan. Zo wordt een Creative SoundBlaster(R) Live! geluidskaart bijvoorbeeld ondersteund door het stuurprogramma man:snd_emu10k1[4]. Ondersteuning voor deze kaart kan als volgt worden toegevoegd:

[.programlisting]
....
device snd_emu10k1
....

In de hulppagina voor een stuurprogramma staat welke syntaxis gebruikt kan worden. De expliciete syntaxis voor de kernelinstellingen voor elk ondersteund geluidsstuurprogramma staat ook in [.filename]#/usr/src/sys/conf/NOTES#.

Voor niet-PnP ISA-geluidskaarten kan het nodig zijn dat de kernel informatie gegeven moet worden over de instellingen van de kaart (IRQ, I/O poort, enzovoort), zoals dat geldt voor alle niet-PnP ISA-kaarten. Dit kan via het bestand [.filename]#/boot/device.hints#. Bij het starten van een systeem leest de man:loader[8] dat bestand uit en geeft de instellingen door aan de kernel. Zo gebruikt een oude Creative SoundBlaster(R) 16 ISA niet-PnP-kaart het stuurprogramma man:snd_sbc[4] samen met `snd_sb16` en dient de volgende regel toegevoegd te worden aan het kernelinstellingenbestand:

[.programlisting]
....
device snd_sbc
device snd_sb16
....

Daarnaast moet het volgende worden toegevoegd aan [.filename]#/boot/device.hints#:

[.programlisting]
....
hint.sbc.0.at="isa"
hint.sbc.0.port="0x220"
hint.sbc.0.irq="5"
hint.sbc.0.drq="1"
hint.sbc.0.flags="0x15"
....

In dit geval gebruikt de kaart I/O poort `0x220` en IRQ `5`.

De gebruikte syntaxis voor [.filename]#/boot/device.hints# staat beschreven in de hulppagina man:sound[4] en de hulppagina voor het gevraagde stuurprogramma.

De bovenstaande instellingen zijn de standaardinstellingen. In sommige gevallen moeten IRQ of andere instellingen gewijzigd worden om een apparaat juist te laten werken. In man:snd_sbc[4] staat meer informatie over deze kaart.

[[sound-testing]]
=== Geluidskaart testen

Na het herstarten met de aangepaste kernel of na het laden van de benodigde module, hoort de geluidskaart ongeveer als volgt te verschijnen in de systeemberichtbuffer (man:dmesg[8]):

[source,bash]
....
pcm0: <Intel ICH3 (82801CA)> port 0xdc80-0xdcbf,0xd800-0xd8ff irq 5 at device 31.5 on pci0
pcm0: [GIANT-LOCKED]
pcm0: <Cirrus Logic CS4205 AC97 Codec>
....

De status van de geluidskaart kan gecontroleerd worden via het bestand [.filename]#/dev/sndstat#:

[source,bash]
....
# cat /dev/sndstat
FreeBSD Audio Driver (newpcm)
Installed devices:
pcm0: <Intel ICH3 (82801CA)> at io 0xd800, 0xdc80 irq 5 bufsz 16384
kld snd_ich (1p/2r/0v channels duplex default)
....

De uitvoer kan per systeem wat verschillen. Als er geen apparaten [.filename]#pcm# genoemd worden, dienen eerdere stappen herzien te worden. Bekijk nogmaals de instellingen van de kernel en bevestig dat het juiste apparaatstuurprogramma was gekozen. Veel voorkomende problemen staan beschreven in <<troubleshooting>>.

Als het goed is werkt de geluidskaart nu. Als pinnen voor audio-out van de CD-ROM- of DVD-ROM-drive juist zijn aangesloten op de geluidskaart, dan kan er een CD in de drive gestopt worden en kan deze met man:cdcontrol[1] afgespeeld worden:

[source,bash]
....
% cdcontrol -f /dev/acd0 play 1
....

Applicaties als package:audio/workman[] kunnen een vriendelijker interface bieden. Wellicht is het handig om een applicatie als package:audio/mpg123[] te installeren om naar MP3 audiobestanden te luisteren.

Een snelle manier om de kaart te testen is het als volgt sturen van gegevens naar [.filename]#/dev/dsp#:

[source,bash]
....
% cat bestandsnaam > /dev/dsp
....

[.filename]#bestandsnaam# kan ieder bestand zijn. Deze commandoregel hoort wat ruis te maken, waardoor wordt bevestigd dat de geluidskaart echt werkt.

[NOTE]
====
De appparaat nodes [.filename]#/dev/dsp*# worden automatisch aangemaakt wanneer dat nodig is. Als deze niet worden gebruikt, bestaan ze niet en zullen ze niet terugkomen in de terugkoppeling van man:ls[1].
====

Niveaus voor de geluidskaartmixer kunnen aangepast worden met het commando man:mixer[8]. Er staan meer details in man:mixer[8].

[[troubleshooting]]
==== Bekende problemen

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Fout
| Oplossing

|`sb_dspwr(XX) timed out`
|De I/O poort is niet correct ingesteld.

|`bad irq XX`
|Het IRQ is niet correct ingesteld. Zorg dat het ingestelde IRQ en het IRQ voor het geluid hetzelfde zijn.

|`xxx: gus pcm not attached, out of memory`
|Er is niet genoeg geheugen beschikbaar om het apparaat te gebruiken.

|`xxx: can't open /dev/dsp!`
|Controleer `fstat \| grep dsp` of een ander programma het apparaat geopend heeft. Bekende probleemgevallen zijn esound en KDE's geluidsondersteuning.
|===

Een ander euvel is dat moderne grafische kaarten voor het gebruik van HDMI en dergelijken vaak zijn uitgerust met hun eigen geluidsstuurprogramma. Dit geluidsapparaat wordt soms opgesomd voor het eigenlijke geluidskaart en daardoor wordt deze niet gebruikt als het standaard afspeelapparaat. Om te zien of dit het geval is, kan dmesg worden gedraaid en gezocht worden naar `pcm`. De uitvoer ziet er ongeveer als volgt uit:

[.programlisting]
....
...
hdac0: HDA Driver Revision: 20100226_0142
hdac1: HDA Driver Revision: 20100226_0142
hdac0: HDA Codec #0: NVidia (Unknown)
hdac0: HDA Codec #1: NVidia (Unknown)
hdac0: HDA Codec #2: NVidia (Unknown)
hdac0: HDA Codec #3: NVidia (Unknown)
pcm0: <HDA NVidia (Unknown) PCM #0 DisplayPort> at cad 0 nid 1 on hdac0
pcm1: <HDA NVidia (Unknown) PCM #0 DisplayPort> at cad 1 nid 1 on hdac0
pcm2: <HDA NVidia (Unknown) PCM #0 DisplayPort> at cad 2 nid 1 on hdac0
pcm3: <HDA NVidia (Unknown) PCM #0 DisplayPort> at cad 3 nid 1 on hdac0
hdac1: HDA Codec #2: Realtek ALC889
pcm4: <HDA Realtek ALC889 PCM #0 Analog> at cad 2 nid 1 on hdac1
pcm5: <HDA Realtek ALC889 PCM #1 Analog> at cad 2 nid 1 on hdac1
pcm6: <HDA Realtek ALC889 PCM #2 Digital> at cad 2 nid 1 on hdac1
pcm7: <HDA Realtek ALC889 PCM #3 Digital> at cad 2 nid 1 on hdac1
...
....

Hier is de grafische kaart (`NVidia`) opgesomd voor de geluidskaart (`Realtek ALC889`). Om de geluidskaart als standaard afspeelapparaat te gebruiken, dient `hw.snd.default_unit` veranderd te worden in de eenheid dat voor afspelen gebruikt moet worden:

[source,bash]
....
# sysctl hw.snd.default_unit=n
....

Hier is `n` het nummer van het geluidsapparaat wat gebruikt dient te worden, in dit voorbeeld `4`. U kunt deze verandering permanent maken door de volgende regel aan [.filename]#/etc/sysctl.conf# toe te voegen:

[.programlisting]
....
hw.snd.default_unit=4
....

[[sound-multiple-sources]]
=== Meerdere geluidsbronnen gebruiken

Het is vaak wenselijk om meerdere geluidsbronnen tegelijkertijd af te kunnen spelen, zoals wanneer esound of artsd het delen van een geluidsapparaat met een andere applicatie niet ondersteunen.

Met FreeBSD kan dit met _Virtuele Geluidskanalen_, die aangezet kunnen worden met de faciliteit man:sysctl[8]. Met virtuele kanalen kunnen het afspelen van een geluidskaart gemultiplext worden door het geluid in de kernel te mixen.

Het aantal virtuele kanalen kan met drie sysctl knoppen als `root` als volgt ingesteld worden:

[source,bash]
....
# sysctl dev.pcm.0.play.vchans=4
# sysctl dev.pcm.0.rec.vchans=4
# sysctl hw.snd.maxautovchans=4
....

In het bovenstaande voorbeeld worden vier virtuele kanalen toegewezen, wat in het dagelijks gebruik voldoende is. Zowel `dev.pcm.0.play.vchans=4` als `dev.pcm.0.rec.vchans=4` zijn het aantal virtuele kanalen dat [.filename]#pcm0# heeft voor afspelen en opnemen, en zijn instelbaar als een apparaat is aangesloten. In `hw.snd.maxautovchans` staat het aantal virtuele kanalen dat aan een nieuw audio-apparaat wordt gegeven als het wordt aangesloten met man:kldload[8]. Omdat de module [.filename]#pcm# onafhankelijk van de hardware stuurprogramma's geladen kan worden, kan in `hw.snd.maxautovchans` opgeslagen worden hoeveel virtuele kanalen apparaten die later worden aangesloten krijgen. Voor meer informatie wordt naar man:pcm[4] verwezen.

[NOTE]
====
Het aantal virtuele kanalen voor een apparaat kan niet gewijzigd worden als het in gebruik is. Sluit eerst alle programma's die het apparaat gebruiken, zoals muziekspelers of geluidsdaemons.
====

Het juiste [.filename]#pcm# apparaat zal automatisch en transparant gealloceerd worden voor programma's die [.filename]#/dev/dsp0# aanroepen.

=== Standaardwaarden voor mixerkanalen instellen

De standaardwaarden voor de mixerkanalen zijn ingesteld in de broncode van het stuurprogramma man:pcm[4]. Er zijn vele applicaties en daemons waarmee waarden voor de mixer ingesteld en onthouden kunnen worden en iedere keer bij het starten weer kunnen worden ingesteld, maar dit is geen nette oplossing. Het is mogelijk om de standaardwaarden in te stellen op het niveau van het stuurprogramma - dit wordt bereikt door de gewenste waarden in te stellen in [.filename]#/boot/device.hints#, bijvoorbeeld:

[.programlisting]
....
hint.pcm.0.vol="50"
....

Met de bovenstaande instelling wordt het volume van een kanaal standaard op 50 ingesteld bij het laden van de module man:pcm[4].

[[sound-mp3]]
== MP3 audio

Met MP3 (MPEG Layer 3 Audio) kan geluid bijna in CD-kwaliteit weergegeven worden en dus is er een goede reden om dit vooral niet na te laten op een FreeBSD werkstation.

[[mp3-players]]
=== MP3 spelers

Verreweg de meest populaire X11 MP3 speler is XMMS (X Multimedia Systeem). In XMMS kunnen Winamp skins gebruikt worden, omdat de GUI vrijwel gelijk is aan die van Nullsoft's Winamp. XMMS heeft ook een eigen plug-in ondersteuning.

XMMS kan geïnstalleerd worden via de package:multimedia/xmms[] port of pakket.

De interface van XMMS is intuïtief met een afspeellijst, grafische equalizer en meer. Gebruikers die bekend zijn met Winamp vinden XMMS vast eenvoudig te gebruiken.

De port package:audio/mpg123[] is een alternatieve MP3-speler die gebruik maakt van de commandoregel.

mpg123 werkt door het geluidsapparaat en het MP3-bestand aan te geven op de commandoregel. Aangenomen dat uw audio-apparaat [.filename]#/dev/dsp1.0# is en u het MP3-bestand _Foobar-GreatestHits.mp3_ wilt afspelen, zou u het volgende opgeven:

[source,bash]
....
# mpg123 -a /dev/dsp1.0 Foobar-GreatestHits.mp3
High Performance MPEG 1.0/2.0/2.5 Audio Player for Layer 1, 2 and 3.
Version 0.59r (1999/Jun/15). Written and copyrights by Michael Hipp.
Uses code from various people. See 'README' for more!
THIS SOFTWARE COMES WITH ABSOLUTELY NO WARRANTY! USE AT YOUR OWN RISK!

Playing MPEG stream from Foobar-GreatestHits.mp3 ...
MPEG 1.0 layer III, 128 kbit/s, 44100 Hz joint-stereo
....

[[rip-cd]]
=== CD audio tracks rippen

Voordat een CD of een CD track naar MP3 ge-encodeerd kan worden moeten de audiogegevens naar de harde schijf geript worden. Dit gaat door de ruwe CDDA (CD Digital Audio) gegevens naar WAV-bestanden te kopiëren.

Het hulpprogramma `cdda2wav`, dat onderdeel is van de suite package:sysutils/cdrtools[], kan gebruikt worden om audio-informatie en de daarbij behorende informatie van CD's te rippen.

Als de audio CD in de drive zit, kan het volgende commando als `root` uitgevoerd worden om een hele CD naar individuele (per track) WAV-bestanden te rippen:

[source,bash]
....
# cdda2wav -D 0,1,0 -B
....

cdda2wav ondersteunt ATAPI (IDE) CD-ROM-drives. Om van een IDE drive te rippen, dient de apparaatnaam aangegeven te worden in plaats van de SCSI eenheidsnummers. Om bijvoorbeeld track 7 van een IDE drive te rippen:

[source,bash]
....
# cdda2wav -D /dev/acd0 -t 7
....

De optie `-D _0,1,0_` geeft het SCSI apparaat [.filename]#0,1,0# aan, dat overeenkomt met de uitvoer van `cdrecord -scanbus`.

Om individuele tracks te rippen kan gebruik gemaakt worden van de optie `-t`:

[source,bash]
....
# cdda2wav -D 0,1,0 -t 7
....

In het bovenstaande voorbeeld wordt track 7 van de audio CD geript. Om een reeks tracks te rippen, bijvoorbeeld van 1 tot 7, kan een reeks opgegeven worden:

[source,bash]
....
# cdda2wav -D 0,1,0 -t 1+7
....

Ook het hulpprogramma man:dd[1] kan gebruikt worden om audio tracks van ATAPI drives af te halen. Deze mogelijkheid wordt beschreven in crossref:disks[duplicating-audiocds,Audio-CD's dupliceren].

[[mp3-encoding]]
=== MP3's encoderen

Tegenwoordig is _de_ MP3 encoder lame. Lame staat in package:audio/lame[] in de portsstructuur.

Met de geripte WAV-bestanden converteert het volgende commando [.filename]#audio01.wav# naar [.filename]#audio01.mp3#:

[source,bash]
....
# lame -h -b 192 \
--tt "Foo Titel" \
--ta "FooBar Artiest" \
--tl "FooBar Album" \
--ty "2005" \
--tc "Geript en encoded door Foo" \
--tg "Genre" \
audio01.wav audio01.mp3
....

192 kbits lijkt de standaard bitrate voor MP3 te zijn. Het is ook mogelijk 128 of 160 of andere bitrates te gebruiken. Hoe hoger de bitrate, hoe meer schijfruimte de uiteindelijke MP3-bestanden gebruiken, maar ook de kwaliteit wordt dan hoger. Met de optie `-h` wordt de modus "hogere kwaliteit, maar iets langzamer" ingeschakeld. Met de opties vanaf `--t` worden de ID3 tags ingegeven, die meestal informatie over een nummer bevatten en onderdeel uitmaken van het MP3-bestand. In de hulppagina voor lame staan nog meer opties die gebruikt kunnen worden bij het encoderen beschreven.

[[mp3-decoding]]
=== MP3's decoderen

Om een CD te kunnen branden van MP3's, moeten ze omgezet worden naar een niet gecomprimeerd WAV-formaat. Zowel XMMS als mpg123 ondersteunen de uitvoer van MP3 naar een niet gecomprimeerd bestandsformaat.

Naar schijf schrijven met XMMS:

[.procedure]
====
. Start XMMS;
. Klik rechts op het venster om het XMMS menu te zien;
. Selecteer `Preference` onder `Options`;
. Wijzig de Output Plugin naar "Disk Writer Plugin";
. Klik `Configure`;
. Voer een map in (of kies "browse") waar de ongecomprimeerde bestanden naar toe geschreven moeten worden;
. Laad de MP3-bestanden zoals gewoonlijk in XMMS, met het volume op 100% en de EQ instellingen uitgeschakeld;
. Klik `Play`. XMMS lijkt nu de MP3 af te spelen, maar er is geen muziek te horen. Nu wordt feitelijk de MP3 afgespeeld naar een bestand;
. Zorg ervoor dat de standaard Output Plugin wordt teruggezet naar hoe de instellingen waren om weer naar MP3's te kunnen luisteren.
====

Schrijven naar stdout vanuit mpg123:

[.procedure]
====
. Voer `mpg123 -s audio01.mp3 > audio01.pcm` uit.
====

XMMS schrijft een bestand in het WAV-formaat, terwijl mpg123 de MP3 converteert naar ruwe PCM audio data. Beide formaten kunnen gebruikt worden met cdrecord om audio CD's te maken. Met man:burncd[8] moeten ruwe PCM-bestanden gebruikt worden. Als er WAV-bestanden worden gebruikt, is er een tikgeluid te horen bij het begin van iedere track. Dit is het geluid van de kop van ieder WAV-bestand. Met het hulpprogramma SoX kan de kop van WAV-bestanden verwijderd worden. Dit programma kan geïnstalleerd worden met de port of pakket package:audio/sox[]

[source,bash]
....
% sox -t wav -r 44100 -s -w -c 2 track.wav track.raw
....

In crossref:disks[creating-cds,Optische media (CD's) aanmaken en gebruiken] staat meer informatie over het gebruiken van een CD-brander in FreeBSD.

[[video-playback]]
== Video afspelen

Video afspelen is een relatief nieuwe en zich snel ontwikkelende richting voor applicaties. In tegenstelling tot voor audio werkt alles hier niet zo soepel.

Voor er wordt begonnen is het van belang te weten welk model videokaart zich in een systeem bevindt en welke chip die gebruikt. Hoewel Xorg vele videokaarten ondersteunt, zijn er veel minder geschikt om goed video mee af te spelen. Er kan een lijst met ondersteunde extensies getoond worden voor X server met de gebruikte videokaart door het commando man:xdpyinfo[1] uit te voeren terwijl X11 draait.

Het is verstandig een kort MPEG-bestand beschikbaar te hebben dat gebruikt kan worden als testbestand voor het evalueren van de spelers en hun opties. Omdat sommige DVD-spelers standaard zoeken naar DVD media in [.filename]#/dev/dvd# of deze apparaatnaam standaard in de broncode hebben staan, is het wellicht verstandig om een symbolische link te maken naar de juiste apparaten:

[source,bash]
....
# ln -sf /dev/acd0 /dev/dvd
# ln -sf /dev/acd0 /dev/rdvd
....

Vanwege de werking van man:devfs[5], blijven handmatig aangemaakte links niet bestaan als een systeem wordt herstart. Om automatisch symbolische links aan te laten maken als een systeem start, kunnen de volgende regels toegevoegd worden aan [.filename]#/etc/devfs.conf#:

[.programlisting]
....
link acd0 dvd
link acd0 rdvd
....

Daarnaast zijn voor het decoderen van DVD, waarvoor bijzondere DVD-ROM functies aangeroepen worden, schrijfrechten op de DVD-apparaten nodig.

Om de gedeeld-geheugeninterface van X11 te verbeteren, wordt aangeraden dat een aantal variabelen van man:sysctl[8] worden verhoogd:

[.programlisting]
....
kern.ipc.shmmax=67108864
kern.ipc.shmall=32768
....

[[video-interface]]
=== Videomogelijkheden vaststellen

Er zijn een aantal methoden om video weer te geven onder X11. Welke echt werkt, is voornamelijk afhankelijk van de gebruikte hardware. Iedere hieronder beschreven methode geeft andere resultaten op andere hardware. De laatste tijd krijgt het renderen van video in X11 veel aandacht en bij iedere versie van Xorg kan er een aanzienlijke verbetering zijn.

Een lijst van veel gebruikte video-interfaces:

. X11: normale X11 uitvoer met gebruikmaking van gedeeld geheugen;
. XVideo: een uitbreiding op de X11 interface die video in een door X11 getekend object ondersteunt;
. SDL: de Simple Directmedia Layer;
. DGA: de Direct Graphics Access;
. SVGAlib: low level console grafische laag.

[[video-interface-xvideo]]
==== XVideo

Xorg kent een uitbreiding _XVideo_, ook bekend als Xvideo, Xv of xv, waarmee video direct weergegeven kan worden in getekende objecten door een speciale versneller. Deze uitbreiding geeft een goede afspeelkwaliteit, zelfs op machines met mindere specificaties.

Of de uitbreiding actief is, kan gecontroleerd worden met het commando `xvinfo`:

[source,bash]
....
% xvinfo
....

XVideo wordt ondersteund als de uitvoer er ongeveer als volgt uitziet:

[source,bash]
....
X-Video Extension version 2.2
screen #0
  Adaptor #0: "Savage Streams Engine"
    number of ports: 1
    port base: 43
    operations supported: PutImage
    supported visuals:
      depth 16, visualID 0x22
      depth 16, visualID 0x23
    number of attributes: 5
      "XV_COLORKEY" (range 0 to 16777215)
              client settable attribute
              client gettable attribute (current value is 2110)
      "XV_BRIGHTNESS" (range -128 to 127)
              client settable attribute
              client gettable attribute (current value is 0)
      "XV_CONTRAST" (range 0 to 255)
              client settable attribute
              client gettable attribute (current value is 128)
      "XV_SATURATION" (range 0 to 255)
              client settable attribute
              client gettable attribute (current value is 128)
      "XV_HUE" (range -180 to 180)
              client settable attribute
              client gettable attribute (current value is 0)
    maximum XvImage size: 1024 x 1024
    Number of image formats: 7
      id: 0x32595559 (YUY2)
        guid: 59555932-0000-0010-8000-00aa00389b71
        bits per pixel: 16
        number of planes: 1
        type: YUV (packed)
      id: 0x32315659 (YV12)
        guid: 59563132-0000-0010-8000-00aa00389b71
        bits per pixel: 12
        number of planes: 3
        type: YUV (planar)
      id: 0x30323449 (I420)
        guid: 49343230-0000-0010-8000-00aa00389b71
        bits per pixel: 12
        number of planes: 3
        type: YUV (planar)
      id: 0x36315652 (RV16)
        guid: 52563135-0000-0000-0000-000000000000
        bits per pixel: 16
        number of planes: 1
        type: RGB (packed)
        depth: 0
        red, green, blue masks: 0x1f, 0x3e0, 0x7c00
      id: 0x35315652 (RV15)
        guid: 52563136-0000-0000-0000-000000000000
        bits per pixel: 16
        number of planes: 1
        type: RGB (packed)
        depth: 0
        red, green, blue masks: 0x1f, 0x7e0, 0xf800
      id: 0x31313259 (Y211)
        guid: 59323131-0000-0010-8000-00aa00389b71
        bits per pixel: 6
        number of planes: 3
        type: YUV (packed)
      id: 0x0
        guid: 00000000-0000-0000-0000-000000000000
        bits per pixel: 0
        number of planes: 0
        type: RGB (packed)
        depth: 1
        red, green, blue masks: 0x0, 0x0, 0x0
....

[NOTE]
====
Sommige van de weergegeven formaten (YUV2, YUV12, enzovoort) zijn niet in iedere implementaties van XVideo beschikbaar en hun afwezigheid kan sommige spelers hinderen.
====

Als het resultaat er als hieronder uitziet, is er geen ondersteuning voor XVideo aanwezig op de videokaart in een systeem:

[source,bash]
....
X-Video Extension version 2.2
screen #0
no adaptors present
....

Als XVideo voor een kaart niet wordt ondersteund, dan betekent dat alleen dat het lastiger wordt om op een beeldscherm aan de vereisten voor het renderen van video te voldoen. Afhankelijk van de videokaart en de processor kan het toch nog mogelijk zijn om acceptabele prestaties neer te zetten. In <<video-further-reading>> staan verwijzingen naar leesvoer over mogelijkheden voor het verbeteren van prestaties.

[[video-interface-SDL]]
==== Eenvoudige Directmedia Laag

De Eenvoudige Directmedia Laag (Simple Directmedia Layer), SDL, is een porting-laag voor vele besturingssystemen waardoor cross-platform toepassingen kunnen worden ontwikkeld die efficiënt gebruik maken van geluid en beelden. De SDL laag biedt een abstractie op laag niveau naar de hardware die soms efficiënter kan zijn dan de X11 interface.

De SDL staat in package:devel/sdl12[].

[[video-interface-DGA]]
==== Directe Grafische Toegang

Directe Grafische Toegang (Direct Graphics Access) is een X11 uitbreiding die een programma in staat stelt voorbij te gaan aan de X server en de framebuffer direct kan wijzigen. Omdat hij afhankelijk is van geheugenmapping op een laag niveau om dit delen uit te voeren, moeten programma's die er gebruik van maken als `root` draaien.

De DGA uitbreiding kan getest en gebenchmarkt worden met man:dga[1]. Als `dga` draait, verandert het de kleuren op een scherm als er een toets wordt ingedrukt. Om te stoppen kan de toets kbd:[q] gebruikt worden.

[[video-ports]]
=== Ports en pakketten met video

In dit onderdeel wordt de software die vanuit de FreeBSD Portscollectie beschikbaar is voor het afspelen van video beschreven. Het afspelen van video is een tak van softwareontwikkeling die erg in beweging is en de mogelijkheden van de verschillende applicaties verschillen zeer waarschijnlijk van wat hier is beschreven.

Als eerste is het belangrijk om te weten dat veel applicaties die met video te maken hebben en op FreeBSD draaien ontwikkeld zijn als Linux(R) applicaties. Veel van die applicaties zijn op het moment van schrijven van beta-kwaliteit. Problemen die te verwachten zijn bij het gebruik van de beschreven videopakketten op FreeBSD zijn:

. Een applicatie kan geen bestanden afspelen die zijn gemaakt met een andere applicatie;
. Een applicatie kan geen bestanden afspelen die met de applicatie zelf zijn gemaakt;
. Dezelfde applicatie, op twee verschillende machines gebouwd, speelt hetzelfde bestand op twee machines anders af;
. Een ogenschijnlijk triviale filter, zoals het herschalen van beeldgrootte, kan resulteren in vreselijk vervelende artefacten door fouten in de routine voor het herschalen;
. Een applicatie dumpt zijn core regelmatig;
. Documentatie wordt niet geïnstalleerd bij de port en staat op het web of in de map [.filename]#work# van de port.

Veel van deze applicaties kunnen ook "Linux-ismes" vertonen. Zo kunnen er bijvoorbeeld problemen ontstaan door de wijze waarop standaard bibliotheken zijn geïmplementeerd in de Linux(R) distributies of een aantal van de mogelijkheden van de Linux(R)-kernel, waarvan door de makers van de applicatie wordt aangenomen dat ze aanwezig zijn. Dit soort problemen zijn niet altijd zichtbaar en er wordt ook omheen gewerkt door de beheerders van ports, wat tot de volgende mogelijke problemen kan leiden:

. Het gebruik van [.filename]#/proc/cpuinfo# om processorkarakteristieken uit te lezen;
. Het verkeerd gebruiken van threads, waardoor een programma hangt als het klaar is, in plaats van dat het echt eindigt;
. Software die nog niet in de FreeBSD Portscollectie zit en vaak gebruikt wordt samen met een applicatie die daar wel onderdeel van uitmaakt.

Tot nu toe is gebleken dat de ontwikkelaars van applicaties wel coöperatief waren met de beheerders van ports om zo het aantal work-arounds dat nodig was voor het overzetten tot een minimum te beperken.

[[video-mplayer]]
==== MPlayer

MPlayer is een zich snel ontwikkelende videospeler. De doelen van het MPlayer-team zijn snelheid en flexibiliteit onder Linux(R) en andere Unices. Het project is gestart toen de oprichter van het team genoeg had van de slechte afspeelprestaties van de destijds beschikbare spelers. Er zijn mensen die zeggen dat het grafische ontwerp is opgeofferd voor het stroomlijnen van het ontwerp, maar het blijkt dat, als een gebruiker gewend is aan de commandoregelopties en de toetsencommando's, de applicatie erg goed werkt.

[[video-mplayer-building]]
===== MPlayer bouwen

MPlayer staat in package:multimedia/mplayer[]. MPlayer voert een aantal hardwarecontroles uit tijdens het bouwen, wat resulteert in een binair bestand dat niet van het ene naar het andere systeem verplaatst kan worden. Daarom is het van belang dat het uit de ports wordt gebouwd en niet als binair pakket wordt geïnstalleerd. Daarnaast staan er ook nog opties die vanaf de `make` commandoregel meegegeven kunnen worden beschreven in de [.filename]#Makefile# en aan het begin van de build:

[source,bash]
....
# cd /usr/ports/multimedia/mplayer
# make
N - O - T - E

Take a careful look into the Makefile in order
to learn how to tune mplayer towards you personal preferences!
For example,
make WITH_GTK1
builds MPlayer with GTK1-GUI support.
If you want to use the GUI, you can either install
/usr/ports/multimedia/mplayer-skins
or download official skin collections from
http://www.mplayerhq.hu/homepage/dload.html
....

De standaard portopties zijn voor de meeste gebruikers voldoende. Maar als bijvoorbeeld de XviD codec nodig is, dan moet de optie `WITH_XVID` op de commandoregel meegegeven worden. Het standaard DVD-apparaat kan ook gedefinieerd worden met de optie `WITH_DVD_DEVICE`, waarbij standaard [.filename]#/dev/acd0# wordt gebruikt.

Op het moment van schrijven wordt de MPlayer port gebouwd met de HTML documentatie en twee uitvoerbare bestanden, `mplayer` en `mencoder`, wat een hulpmiddel is voor het opnieuw encoderen van video.

De HTML documentatie voor MPlayer is erg informatief. Als de lezer vindt dat er informatie over videohardware en interfaces in dit hoofdstuk mist, dan is de documentatie van MPlayer een zeer grondige aanvulling. Het is de moeite waard de tijd te nemen om de documentatie van MPlayer te lezen, als meer informatie over de ondersteuning van video in UNIX(R) welkom is.

[[video-mplayer-using]]
===== MPlayer gebruiken

Iedere gebruiker van MPlayer dient een submap [.filename]#.mplayer# in zijn thuismap te hebben. Die kan als volgt gemaakt worden:

[source,bash]
....
% cd /usr/ports/multimedia/mplayer
% make install-user
....

De commando-opties voor `mplayer` staan in de hulppagina. Nog meer details staan in de HTML documentatie. In dit onderdeel worden slechts een aantal gebruiksmogelijkheden beschreven.

Om een bestand als [.filename]#testbestand.avi# af te spelen met een van de beschikbare video-interfaces, kan de optie `-vo` gebruikt worden:

[source,bash]
....
% mplayer -vo xv testbestand.avi
....

[source,bash]
....
% mplayer -vo sdl testbestand.avi
....

[source,bash]
....
% mplayer -vo x11 testbestand.avi
....

[source,bash]
....
# mplayer -vo dga testbestand.avi
....

[source,bash]
....
# mplayer -vo 'sdl:dga' testbestand.avi
....

Het is de moeite waard alle bovenstaande opties uit te proberen omdat hun relatieve prestatie afhangt van vele factoren die aanzienlijk verschillen tussen hardware.

Om een DVD af te spelen dient [.filename]#testbestand.avi# vervangen te worden door `dvd://_N_ -dvd-device _APPARAAT_` waar _N_ het titelnummer is dat afgespeeld moeten worden en [.filename]#APPARAAT# het apparaatknooppunt is voor de DVD-ROM. Om bijvoorbeeld titel 3 van [.filename]#/dev/dvd# af te spelen:

[source,bash]
....
# mplayer -vo xv dvd://3 -dvd-device /dev/dvd
....

[NOTE]
====
Het standaard DVD-apparaat kan ingesteld worden bij het bouwen van de MPlayer port met de optie `WITH_DVD_DEVICE`. Standaard is dit apparaat [.filename]#/dev/acd0#. Meer details staan in de [.filename]#Makefile# van de port.
====

Om te stoppen, pauzeren, verder te spoelen, enzovoort, kunnen de toetsendefinities gebruikt worden, die in te zien zijn door `mplayer -h` uit te voeren of de hulppagina te lezen.

Overige belangrijke opties voor het afspelen zijn: `-fs -zoom`, waarmee het volledige scherm wordt gebruikt, en `-framedrop`, die prestatieverhogend werkt.

Om ervoor te zorgen dat de commandoregels niet te lang worden, kan het bestand [.filename]#.mplayer/config# met voorkeursinstellingen gemaakt worden:

[.programlisting]
....
vo=xv
fs=yes
zoom=yes
....

Tenslotte kan `mplayer` gebruikt worden om een DVD naar een bestand van het type [.filename]#.vob# te rippen. Om de tweede titel van een DVD de dumpen kan het volgende commando gebruikt worden:

[source,bash]
....
# mplayer -dumpstream -dumpfile out.vob dvd://2 -dvd-device /dev/dvd
....

Het uitvoerbestand [.filename]#out.vob#, is van het type MPEG en kan bewerkt worden met andere in dit onderdeel besproken programma's.

[[video-mencoder]]
===== `mencoder`

Voordat `mencoder` wordt gebruikt, is het verstandig de opties uit de HTML-documentatie te bekijken. Er is een hulppagina, maar die is niet echt bruikbaar zonder de HTML-documentatie. Er zijn ontelbare mogelijkheden om de kwaliteit te verhogen, de bitrate te verlagen en formaten te wijzigen en een aantal van die truuks maken het verschil tussen goede en slechte prestaties. Hieronder staan een aantal voorbeelden beschreven. Eerst een eenvoudige kopie:

[source,bash]
....
% mencoder invoer.avi -oac copy -ovc copy -o uitvoer.avi
....

Verkeerde combinaties van commandoregelopties kunnen resulteren in uitvoerbestanden die zelfs niet af te spelen zijn door `mplayer`. Daarom wordt aangeraden om het bij de optie `-dumpfile` in `mplayer` te houden als het alleen maar nodig is een bestand te rippen.

Om [.filename]#invoer.avi# te converteren naar de MPEG4-codec met MPEG3-audio encodering (package:audio/lame[] is verplicht):

[source,bash]
....
% mencoder invoer.avi -oac mp3lame -lameopts br=192 \
-ovc lavc -lavcopts vcodec=mpeg4:vhq -o utvoer.avi
....

Hiermee wordt uitvoer gemaakt die af te spelen is met `mplayer` en `xine`.

[.filename]#invoer.avi# kan worden vervangen door `dvd://1 -dvd-device /dev/dvd` en als `root` gedraaid worden om een DVD-titel direct te hercoderen. Omdat het waarschijnlijk is dat de eerste experimenten niet direct tevredenstellend zijn, wordt aangeraden een titel eerst naar een bestand te dumpen en dat als werkbestand te gebruiken.

[[video-xine]]
==== xine videospeler

De xine videospeler is een project met een brede scope, dat niet alleen tracht een allesomvattende video-oplossing te bieden, maar ook probeert een herbruikbare basisbibliotheek en een modulair uitvoerbaar bestand te maken dat uitgebreid kan worden met plug-ins. Het kan als pakket en port geïnstalleerd worden uit package:multimedia/xine[].

De xine speler heeft nog wat ruwe randjes, maar is zeker goed van start gegaan. In de praktijk heeft xine een snelle CPU met een snelle videokaart of ondersteuning voor de XVideo extensie nodig. De GUI is bruikbaar, maar wat onhandig.

Op het moment van schrijven wordt er geen invoermodule bij xine geleverd waarmee CSS gecodeerde DVD's afgespeeld kunnen worden. Er zijn er die door andere partijen zijn gebouwd die dat type modules wel hebben, maar die zijn niet beschikbaar in de FreeBSD Portscollectie.

Vergeleken met MPlayer, doet xine meer voor de gebruiker, maar tegelijkertijd neemt het wat van de fijnafstellingsmogelijkheden weg. De videospeler xine werkt het beste op XVideo-interfaces.

Standaard start de xine speler op in een grafische gebruikersinterface. Via het menu kan een specifiek bestand geopend worden:

[source,bash]
....
% xine
....

Het is ook mogelijk om zonder de GUI direct een bestand af te laten spelen:

[source,bash]
....
% xine -g -p mijnfilm.avi
....

[[video-ports-transcode]]
==== transcode hulpprogramma's

De software transcode is geen speler, maar een verzameling hulpprogramma's voor het hercoderen van video- en audiobestanden. Met transcode wordt het mogelijk om videobestanden samen te voegen, kapotte bestanden te repareren en commandoregelprogramma's te gebruiken met [.filename]#stdin/stdout# stream interfaces.

Tijdens het bouwen van de port package:multimedia/transcode[] kan een groot aantal opties opgegeven worden en de volgende commandoregel wordt geadviseerd om transcode te bouwen:

[source,bash]
....
# make WITH_OPTIMIZED_CFLAGS=yes WITH_LIBA52=yes WITH_LAME=yes WITH_OGG=yes \
WITH_MJPEG=yes -DWITH_XVID=yes
....

De geadviseerde instellingen zijn toereikend voor de meeste gebruikers.

Om de mogelijkheden van `transcode` te illustreren volgt nu een voorbeeld van hoe een DivX-bestand om te zetten in een PAL MPEG-1-bestand (PAL VCD):

[source,bash]
....
% transcode -i invoer.avi -V --export_prof vcd-pal -o uitvoer_vcd
% mplex -f 1 -o uitvoer_vcd.mpg uitvoer_vcd.m1v uitvoer_vcd.mpa
....

Het resulterende MPEG-bestand, [.filename]#uitvoer_vcd.mpg#, is klaar om afgespeeld te worden met MPlayer. Het kan ook op een CD-R gebrand worden om er een Video-CD mee te maken. In dat geval is het nodig om de programma's package:multimedia/vcdimager[] en package:sysutils/cdrdao[] te installeren.

Er is een hulppagina voor `transcode`, maar kijk ook op http://www.transcoding.org/cgi-bin/transcode[transcode wiki] voor meer informatie en voorbeelden.

Als de twee vergeleken worden, draait `transcode` aanzienlijk langzamer dan `mencoder`, maar is de kans wel groter dat er een bestand uit komt dat op de meeste spelers afgespeeld kan worden. MPEG-bestanden die met `transcode` zijn gemaakt, zijn bijvoorbeeld al afgespeeld op Windows Media(R) Player en Apple's Quicktime(R).

[[video-further-reading]]
=== Verder lezen

De beschikbare videosoftware pakketten voor FreeBSD zijn fors in ontwikkeling. Het is goed mogelijk dat in de nabije toekomst de meeste problemen die hier aan de kaak zijn gesteld, zijn opgelost. Intussen kunnen zij die het hoogst haalbare uit de A/V mogelijkheden voor FreeBSD willen halen, dat het beste doen door wat beschikbaar is bij elkaar te scharrelen uit de beschikbare FAQ's and tutorials en meerdere programma's gebruiken. Het doel van deze paragraaf is de lezer wat richting te geven op dat vlak.

De http://www.mplayerhq.hu/DOCS/[MPlayer documentatie] is technisch erg informatief. Deze documenten kunnen het beste bekeken worden door iemand die veel kennis wil opdoen over video in UNIX(R). Op de MPlayer mailinglijst wordt het niet op prijs gesteld als iemand de documentatie niet heeft gelezen, dus het is verstandig RTFM in gedachten te houden alvorens bug rapportages naar ze te mailen.

De http://dvd.sourceforge.net/xine-howto/en_GB/html/howto.html[xine HOWTO] bevat een hoofdstuk over het verbeteren van prestaties, dat op alle spelers van toepassing is.

Tenslotte zijn er nog een aantal veelbelovende applicaties die het proberen waard zijn:

* http://avifile.sourceforge.net/[Avifile] bestaat ook als port: package:multimedia/avifile[];
* http://www.dtek.chalmers.se/groups/dvd/[Ogle] is er ook als port: package:multimedia/ogle[];
* http://xtheater.sourceforge.net/[Xtheater];
* package:multimedia/dvdauthor[], een open source pakket voor authoring van DVD content.

[[tvcard]]
== TV-kaarten installeren

=== Inleiding

Met TV-kaarten is het mogelijk om naar (kabel)uitzendingen te kijken op een computer. Op de meeste kaarten kan composiet video aangeleverd worden via een RCA of S-video input en sommige kaarten hebben ook een FM tuner.

FreeBSD biedt ondersteuning voor PCI-gebaseerde TV-kaarten met een Brooktree Bt848/849/878/879 of een Conexant CN-878/Fusion 878a Video Capture Chip met het stuurprogramma man:bktr[4]. Het is van belang dat er op de kaart ook een ondersteunde tuner zit. Hiervoor kan man:bktr[4] geraadpleegd worden, waarin een lijst met ondersteunde tuners staat.

=== Stuurprogramma toevoegen

Voordat de kaart gebruikt kan worden, dient het stuurprogramma man:bktr[4] geladen te worden. Dit kan door de volgende regel aan [.filename]#/boot/loader.conf# toe te voegen:

[.programlisting]
....
bktr_load="YES"
....

Daarnaast is het ook mogelijk om statisch ondersteuning voor de TV-kaart in de kernel te compileren. Dan dient de volgende regel toegevoegd te worden aan de kernelinstellingen:

[.programlisting]
....
device	 bktr
device	iicbus
device	iicbb
device	smbus
....

De extra stuurprogramma's zijn nodig omdat de kaartcomponenten verbonden zijn via een I2C bus. Met deze instellingen kan een nieuwe kernel gebouwd en geïnstalleerd worden.

Als een systeem eenmaal ondersteuning biedt, hoort de TV-kaart ongeveer als volgt bij een herstart getoond te worden:

[.programlisting]
....
bktr0: <BrookTree 848A> mem 0xd7000000-0xd7000fff irq 10 at device 10.0 on pci0
iicbb0: <I2C bit-banging driver> on bti2c0
iicbus0: <Philips I2C bus> on iicbb0 master-only
iicbus1: <Philips I2C bus> on iicbb0 master-only
smbus0: <System Management Bus> on bti2c0
bktr0: Pinnacle/Miro TV, Philips SECAM tuner.
....

Deze berichten kunnen afwijken, afhankelijk van de gebruikte hardware. Het is van belang te controleren of de tuner juist herkend wordt; er kunnen nog een aantal instellingen gemaakt worden voor parameters met man:sysctl[8] MIB's en in het kernelinstellingenbestand. Om bijvoorbeeld het gebruik van een Philips SECAM tuner te forceren, kan de volgende regel aan het bestand met kernelinstellingen worden toegevoegd:

[.programlisting]
....
options OVERRIDE_TUNER=6
....

Dit kan ook via een instelling van man:sysctl[8]:

[source,bash]
....
# sysctl hw.bt848.tuner=6
....

In de hulppagina voor man:bktr[4] en [.filename]#/usr/src/sys/conf/NOTES# staan meer details over de beschikbare opties.

=== Handige programma's

Om een TV-kaart te gebruiken, dient een van de volgende applicaties geïnstalleerd te worden:

* package:multimedia/fxtv[] biedt TV-in-een-window en beeld/audio/videocapture mogelijkheden;
* package:multimedia/xawtv[] is ook een TV applicatie met dezelfde mogelijkheden als fxtv;
* package:misc/alevt[] decodeert Videotext/Teletext en kan deze weergeven;
* package:audio/xmradio[], een applicatie om de FM-tuner die bij sommige TV-kaarten zit te gebruiken;
* package:audio/wmtune[], een handige bureaubladapplicatie voor radiotuners.

Er zijn nog meer applicaties beschikbaar in de Portscollectie.

=== Problemen oplossen

Bij problemen met een TV-kaart dient eerst gecontroleerd te worden of de videocapture chip en de tuner echt ondersteund worden door het stuurprogramma man:bktr[4] en of de juiste instellingen worden gebruikt. Voor meer ondersteuning en vragen over een specifieke TV-kaart is het aan te raden de archieven van de {freebsd-multimedia} mailinglijst te raadplegen of er contact mee op te nemen.

[[mythtv]]
== MythTV

MythTV is een open-source PVR software project.

Het staat in de Linux(R)-wereld bekend als een complexe toepassing met veel afhankelijkheden, en daarom moeilijk om te installeren. De Portscollectie van FreeBSD versimpelt veel van het proces, maar sommige componenten moeten handmatig worden geïnstalleerd. Deze sectie is bedoeld om te helpen en te begeleiden in het installeren van MythTV.

=== Hardware

MythTV is ontworpen om V4L te gebruiken om invoerapparatuur voor video zoals encoders en tuners te benaderen. Momenteel werkt MythTV het beste met USB DVB-S/C/T kaarten die ondersteund worden door package:multimedia/webcamd[] omdat webcamd een gebruikerstoepassing levert voor V4L. Elke DVB-kaart die ondersteund wordt door webcamd zou met MythTV moeten werken, een lijst van kaarten waarvan hun werking bekend is kan http://wiki.freebsd.org/WebcamCompat[hier] gevonden worden. Er zijn ook stuurprogramma's bekend voor Hauppauge-kaarten in de pakketten package:multimedia/pvr250[] en package:multimedia/pvrxxx[], maar deze leveren een niet-standaard interface met hun stuurprogramma dat niet werkt met versies van MythTV nieuwer dan 0.23.

http://wiki.freebsd.org/HTPC[HTPC] bevat een lijst van alle beschikbare stuurprogramma's voor DVB.

=== Afhankelijkheden

Doordat MythTV flexibel en modulair is, staat het de gebruiker toe om de voorkant en de achterkant op verschillende machines te hebben.

Voor de voorkant is package:multimedia/mythtv-frontend[] nodig, alsook een X-server welke in package:x11/xorg[] beschikbaar is. Idealiter beschikt de voorkant-computer ook over een videokaart die XvMC ondersteunt en optioneel over een afstandsbediening die compatibel is met LIRC.

Voor de achterkant is package:multimedia/mythtv[] nodig, alsook een MySQL(TM) database en optioneel een tuner en opslag voor opnames. Het MySQL(TM) pakket zou automatisch als een afhankelijkheid geïnstalleerd moeten worden tijdens de installatie van package:multimedia/mythtv[].

=== MythTV installeren

Gebruik de volgende stappen om MythTV te installeren. Installeer als eerste MythTV van de FreeBSD Portscollectie:

[source,bash]
....
# cd /usr/ports/multimedia/mythtv
# make install
....

Installeer de database voor MythTV:

[source,bash]
....
# mysql -uroot -p < /usr/local/shared/mythtv/database/mc.sql
....

Configureer de achterkant:

[source,bash]
....
# mythtv-setup
....

Start de achterkant:

[source,bash]
....
# echo 'mythbackend_enable="YES"' >> /etc/rc.conf
# service mythbackend start
....

[[scanners]]
== Scanners

=== Inleiding

In FreeBSD is toegang tot scanners mogelijk met SANE (Scanner Access Now Easy) API uit de FreeBSD Portscollectie. SANE gebruikt ook een aantal FreeBSD apparaatstuurprogramma's om toegang te krijgen tot de hardware van de scanner.

FreeBSD ondersteunt SCSI en USB scanners. Het is van belang te controleren of een scanner door SANE wordt ondersteund voordat er instellingen worden gemaakt. SANE heeft een lijst met http://www.sane-project.org/sane-supported-devices.html[ondersteunde apparaten] waarin gekeken kan worden of een scanner wordt ondersteund en wat de status voor ondersteuning is.

=== Kernel instellen

Zoals hierboven al is aangegeven, worden zowel SCSI als USB-scanners ondersteund. Afhankelijk van de gebruikte scannerinterface zijn verschillende apparaatstuurprogramma's nodig.

[[scanners-kernel-usb]]
==== USB-interface

In de [.filename]#GENERIC# kernel zitten standaard de apparaatstuurprogramma's die nodig zijn voor ondersteuning van USB-scanners. In het geval wordt besloten tot het maken van een aangepaste kernel, dan dienen de volgende regels in het kernelinstellingenbestand te worden opgenomen:

[.programlisting]
....
device usb
device uhci
device ohci
device uscanner
device ehci
....

Na een herstart met de juiste kernel kan de USB-scanner aangesloten worden. Een regel die de detectie van uw scanner aangeeft zou in de berichtenbuffer van het systeem (man:dmesg[8]) moeten verschijnen:

[source,bash]
....
ugen0.2: <EPSON> at usbus0
....

Deze berichten geven aan dat de scanner [.filename]#/dev/ugen0.2# als apparaatknooppunt gebruikt. Voor dit voorbeeld was een EPSON Perfection(R) 1650 USB-scanner gebruikt.

==== SCSI interface

Als een scanner een SCSI interface heeft, is het belangrijk te weten welk SCSI controllerbord gebruikt gaat worden. Afhankelijk van de gebruikte SCSI chipset, dient het bestand met kernelinstellingen aangepast te worden. De [.filename]#GENERIC# kernel ondersteunt de meest voorkomende SCSI controllers. In het bestand [.filename]#NOTES# is de juiste instelling te vinden die toegevoegd moet worden aan het bestand met kernelinstellingen. Naast het toevoegen van het juiste SCSI-adapter stuurprogramma, dienen ook de volgende regels opgenomen te worden in het kernelinstellingenbestand:

[.programlisting]
....
device scbus
device pass
....

Als de kernel juist gecompileerd en geïnstalleerd is, horen de apparaten tijdens het opstarten zichtbaar te zijn in de systeemberichtbuffer:

[source,bash]
....
pass2 at aic0 bus 0 target 2 lun 0
pass2: <AGFA SNAPSCAN 600 1.10> Fixed Scanner SCSI-2 device
pass2: 3.300MB/s transfers
....

Als een scanner niet aan staat tijdens het opstarten, is het nog mogelijk handmatig detectie te forceren door de SCSI-bus te laten scannen met man:camcontrol[8]:

[source,bash]
....
# camcontrol rescan all
Re-scan of bus 0 was successful
Re-scan of bus 1 was successful
Re-scan of bus 2 was successful
Re-scan of bus 3 was successful
....

In het bovenstaande geval zal de scanner ongeveer als volgt verschijnen in de lijst met SCSI-apparaten:

[source,bash]
....
# camcontrol devlist
<IBM DDRS-34560 S97B>              at scbus0 target 5 lun 0 (pass0,da0)
<IBM DDRS-34560 S97B>              at scbus0 target 6 lun 0 (pass1,da1)
<AGFA SNAPSCAN 600 1.10>           at scbus1 target 2 lun 0 (pass3)
<PHILIPS CDD3610 CD-R/RW 1.00>     at scbus2 target 0 lun 0 (pass2,cd0)
....

Meer details over SCSI-apparaten staan in de hulppagina's voor man:scsi[4] en man:camcontrol[8].

=== SANE instellen

Het SANE systeem is opgesplitst in twee delen: de backends (package:graphics/sane-backends[]) en de frontends (package:graphics/sane-frontends[]). Het deel met de backends zorgt voor de toegang tot de scanner zelf. In de lijst met door SANE http://www.sane-project.org/sane-supported-devices.html[ondersteunde apparaten] staat welk backend welke scanner(s) ondersteunt. Het is echt nodig het juiste backend vast te stellen, omdat het anders bijzonder lastig wordt een scanner aan de praat te krijgen. Het deel met frontends levert een grafische scaninterface (xscanimage).

De eerste stap is om de port of het pakket package:graphics/sane-backends[] te installeren. Daarna kan met het commando `sane-find-scanner` gecontroleerd worden welke scanner er door het SANE systeem is gedetecteerd:

[source,bash]
....
# sane-find-scanner -q
found SCSI scanner "AGFA SNAPSCAN 600 1.10" at /dev/pass3
....

In de uitvoer is te lezen welk type interface en welk apparaatknooppunt worden gebruikt om de scanner met een systeem te verbinden. Het merk en het model worden wellicht niet getoond, maar dat is ook niet echt van belang.

[NOTE]
====
Sommige USB-scanners verlangen dat er firmware wordt geladen. Dit wordt uitgelegd in de hulppagina van het backend. Het is ook van belang man:sane-find-scanner[1] en man:linprocfs[7] te lezen.
====

Hierna kan gecontroleerd worden of de scanner ook te zien is voor een scanner-frontend. Er zit bij de SANE backends een standaard hulpprogramma man:sane[1]. Met dit commando kunnen de apparaten zichtbaar gemaakt worden en kan vanaf de commandoregel gescand worden. Met de optie `-L` kunnen de scannerapparaten getoond worden:

[source,bash]
....
# scanimage -L
device `snapscan:/dev/pass3' is a AGFA SNAPSCAN 600 flatbed scanner
....

Of, met bijvoorbeeld de USB-scanner die in <<scanners-kernel-usb>> wordt gebruikt:

[source,bash]
....
# scanimage -L
device 'epson2:libusb:/dev/usb:/dev/ugen0.2' is a Epson GT-8200 flatbed scanner
....

Deze uitvoer komt van een FreeBSD 8.X systeem, het item `'epson2:libusb:/dev/usb:/dev/ugen0.2'` geeft de naam van het backend (`epson2`) en het apparaatknooppunt (`/dev/ugen0.2`) dat door onze scanner wordt gebruikt.

[NOTE]
====
De afwezigheid van uitvoer of een bericht dat aangeeft dat er geen scanners zijn aangetroffen, betekent dat man:sane[1] niet in staat is een scanner te identificeren. Als dit gebeurt, dient het instellingenbestand voor het backend aangepast te worden en dient daar de juiste instelling gemaakt te worden. De map [.filename]#/usr/local/etc/sane.d/# bevat alle bestanden met instellingen voor de backends. Het is bekend dat dit identificatieprobleem optreedt bij bepaalde USB-scanners.

De USB-scanner die in <<scanners-kernel-usb>> wordt gebruikt, wordt in FreeBSD 8.X prima gedetecteerd en werkt daar, maar in eerdere versies van FreeBSD (waar man:uscanner[4] wordt gebruikt) toont het de volgende informatie met `sane-find-scanner`:

[source,bash]
....
# sane-find-scanner -q
found USB scanner (UNKNOWN vendor and product) at device /dev/uscanner0
....

De bovenstaande uitvoer geeft aan dat de scanner juist is gedetecteerd, dat het de USB-interface gebruikt en is aangesloten op het apparaatknooppunt [.filename]#/dev/uscanner0#. Nu kan gecontroleerd worden of de scanner juist wordt geïdentificeerd:

[source,bash]
....
# scanimage -L

No scanners were identified. If you were expecting something different,
check that the scanner is plugged in, turned on and detected by the
sane-find-scanner tool (if appropriate). Please read the documentation
which came with this software (README, FAQ, manpages).
....

Omdat in het bovenstaande voorbeeld de scanner niet wordt geïdentificeerd, dient het bestand [.filename]#/usr/local/etc/sane.d/epson2.conf# gewijzigd te worden. De gebruikte scanner is een EPSON Perfection(R) 1650, dus in dit geval dient voor de scanner het backend `epson2` gebruikt te worden. Het is van belang om het commentaar in de instellingenbestanden van de backends te lezen. Het aanpassen van regels is eenvoudig: plaats een commentaarkarakter voor alle regels voor andere interfaces dan die nodig zijn weg (in dit geval worden alle regels die beginnen met het woord `scsi` uitgeschakeld, omdat er een USB-interface wordt gebruiken), en dan kan onderaan het bestand een regel met de gebruikte interface en apparaatknooppunt geplaatst worden:

[.programlisting]
....
usb /dev/uscanner0
....

Het is aan te raden de opmerkingen te lezen in het bestand met instellingen voor het backend en ook de hulppagina, omdat daarin meer details en de correcte syntaxis te vinden zijn. Nu kan gecontroleerd worden of de scanner wèl juist wordt geïdentificeerd:

[source,bash]
....
# scanimage -L
device `epson:/dev/uscanner0' is a Epson GT-8200 flatbed scanner
....

De USB-scanner is geïdentificeerd. Het is niet belangrijk dat het merk en model niet overeenkomen met de scanner. Het belangrijkste is het veld ``epson:/dev/uscanner0'`, dat de juiste benamingen voor het backend en het apparaatknooppunt aangeeft.
====

Als `scanimage -L` in staat is een scanner goed te zien, dan zijn de instellingen compleet. Er kan nu met het apparaat gescand worden.

Hoewel man:sane[1] in staat is om vanaf de commandoregel te scannen, is het aan te raden beelden te scannen vanuit de grafische gebruikersinterface. SANE heeft een eenvoudige, maar efficiënte grafische interface: xscanimage (package:graphics/sane-frontends[]).

Xsane (package:graphics/xsane[]) is een ander populair grafisch scanfrontend, dat geavanceerde mogelijkheden biedt, zoals meerdere scanmodi (fotokopie, fax, enzovoort), kleurcorrectie, batchscannen, enzovoort. Beide applicaties zijn als plug-in voor GIMP te gebruiken.

=== Andere gebruikers toegang tot de scanner geven

Alle voorgaande taken zijn uitgevoerd met `root` rechten, maar het is wellicht ook nodig dat andere gebruikers de scanner kunnen gebruiken. Dan heeft een gebruiker lees- en schrijfrechten nodig op de apparaatknooppunt voor een scanner. Onze USB-scanner gebruikt bijvoorbeeld apparaatknooppunt [.filename]#/dev/ugen0.2# wat in feite slechts een symbolische koppeling is naar het echte apparaatknooppunt genaamd [.filename]#/dev/usb/0.2.0# (een blik op de inhoud van de map [.filename]#/dev# bevestigt dit). Zowel de symbolische koppeling als het apparaatknooppunt zijn van respectievelijk de groepen `wheel` en `operator`. Door de gebruiker `_joe_` aan deze groepen toe te voegen kan hij de scanner zien, maar vanwege duidelijke veiligheidsredenen dient het toevoegen van een gebruiker aan elke groep met zorg te gebeuren, vooral aan de groep `wheel`. Een betere oplossing is om een specifieke groep aan te maken voor het gebruik van USB-apparaten en de scanner toegankelijk te maken voor leden van deze groep.

We zullen dus bijvoorbeeld een groep genaamd `_usb_` gebruiken. De eerste stap is het aanmaken van deze groep met behulp van het commando man:pw[8]:

[source,bash]
....
# pw groupadd usb
....

Hierna moeten we de symbolische koppeling [.filename]#/dev/ugen0.2# aanmaken en het apparaatknooppunt [.filename]#/dev/usb/0.2.0# met de juiste schrijfpermissies toegankelijk maken voor de groep `usb` (`0660` of `0664`), omdat standaard alleen de eigenaar van deze bestanden (`root`) ernaar kan schrijven. Dit alles wordt gedaan door de volgende regels aan [.filename]#/etc/devfs.rules# toe te voegen:

[.programlisting]
....
[system=5]
add path ugen0.2 mode 0660 group usb
add path usb/0.2.0 mode 0666 group usb
....

Nu dienen er alleen nog gebruikers aan de groep `_usb_` toegevoegd te worden om toegang tot de scanner toe te staan:

[source,bash]
....
# pw groupmod usb -m joe
....

Lees voor meer details de handleidingpagina van man:pw[8].
