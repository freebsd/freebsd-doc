---
title: Hoofdstuk 19. Opslag
part: Deel III. Systeembeheer
prev: books/handbook/audit
next: books/handbook/geom
---

[[disks]]
= Opslag
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:source-highlighter: rouge
:experimental:
:skip-front-matter:
:toc-title: Inhoudsopgave
:table-caption: Tabel
:figure-caption: Afbeelding
:example-caption: Voorbeeld
:xrefstyle: basic
:relfileprefix: ../
:outfilesuffix:
:sectnumoffset: 19

ifeval::["{backend}" == "html5"]
:imagesdir: ../../../images/books/handbook/disks/
endif::[]

ifeval::["{backend}" == "pdf"]
:imagesdir: ../../../../static/images/books/handbook/disks/
endif::[]

ifeval::["{backend}" == "epub3"]
:imagesdir: ../../../../static/images/books/handbook/disks/
endif::[]

include::shared/authors.adoc[]
include::shared/releases.adoc[]
include::shared/nl/mailing-lists.adoc[]
include::shared/nl/teams.adoc[]
include::shared/nl/urls.adoc[]

toc::[]

[[disks-synopsis]]
== Overzicht

Dit hoofdstuk behandelt het gebruik van schijven in FreeBSD. Dit omvat geheugenschijven, schijven die met het netwerk verbonden zijn, SCSI/IDE-opslagapparaten en apparaten die gebruik maken van de USB-interface.

Na het lezen van dit hoofdstuk weet de lezer:

* Welke terminologie FreeBSD gebruikt om de gegevensindeling op een fysieke schijf te beschrijven (partities en slices);
* Hoe aanvullende harde schijven aan een systeem toe te voegen;
* Hoe FreeBSD in te stellen om het gebruik te laten maken van USB-opslagapparaten;
* Hoe virtuële bestandssystemen, zoals geheugenschijven, aan te maken;
* Hoe quota te gebruiken om het schijfgebruik te beperken;
* Hoe schijven te versleutelen om ze tegen inbrekers te beschermen;
* Hoe vanuit FreeBSD CD's en DVD's aan te maken en te branden;
* Wat de verschillende mogelijkheden zijn voor opslagmedia voor back-ups;
* Hoe back-upprogramma's te gebruiken die beschikbaar zijn in FreeBSD;
* Hoe een back-up naar diskettes te maken;
* Wat bestandssysteem snapshots zijn en hoe ze efficiënt te gebruiken.

Aangeraden voorkennis:

* Hoe een nieuwe FreeBSD-kernel in te stellen en te installeren (crossref:kernelconfig[kernelconfig,De FreeBSD-kernel instellen]).

[[disks-naming]]
== Apparaatnamen

De volgende lijst noemt de fysieke opslagapparaten die in FreeBSD ondersteund worden, samen met de bijhorende namen.

[[disk-naming-physical-table]]
.Naamconventies voor fysieke Schijven
[cols="1,1", frame="none", options="header"]
|===
| Type medium
| Apparaatnaam medium

|IDE harde schijven
|`ad`

|IDE CD-ROM-stations
|`acd`

|SCSI harde schijven en USB-apparaten voor massa-opslag
|`da`

|SCSI CD-ROM-schijven
|`cd`

|Overige niet-standaard-CD-ROM-stations
|`mcd` voor Mitsumi CD-ROM en `scd` voor Sony CD-ROM apparaten.

|Diskettestations
|`fd`

|SCSI bandstations
|`sa`

|IDE bandstations
|`ast`

|Flashdrives
|`fla` voor DiskOnChip(R) flashapparaten

|RAID-schijven
|`aacd` voor Adaptec(R) AdvancedRAID, `mlxd` en `mlyd` voor Mylex(R), `amrd` voor AMI MegaRAID(R), `idad` voor Compaq Smart RAID, `twed` voor 3ware(R) RAID.
|===

[[disks-adding]]
== Schijven toevoegen

De volgende sectie beschrijft hoe een nieuwe SCSI schijf aan een machine toe te voegen die slechts een enkele drive heeft. Ten eerste dient de computer uitgeschakeld te worden en dient de schijf volgens de instructies van de computer, controller en schijffabrikant geïnstalleerd te worden. Wegens de grote variéteiten om dit soort procedures uit te voeren, vallen de details buiten het bereik van dit document.

Er dient als gebruiker `root` ingelogd te worden. Nadat de schijf is toegevoegd, dient [.filename]#/var/run/dmesg.boot# bekeken te worden om er zeker van te zijn dat de nieuwe schijf is gevonden. Volgens het voorbeeld heet de nieuw toegevoegde schijf [.filename]#da1# en die wordt aangekoppeld op [.filename]#/1# (als er een IDE-schijf wordt toegevoegd, is de apparaatnaam [.filename]#ad1#).

FreeBSD draait op IBM-PC-compatibele computers. Daarom moet het rekening houden met de PC-BIOS-partities. Deze wijken af van de traditionele BSD-partities. Een PC-schijf bevat tot vier ingangen voor BIOS-partities. Indien de schijf geheel aan FreeBSD wordt gewijd, kan de _toegewijde_-modus gebruikt worden. In het andere geval moet FreeBSD binnen één van de vier PC-BIOS-partities draaien. De PC-BIOS-partities worden door FreeBSD _slices_ genoemd om ze niet met de traditionele BSD-partities te verwarren. Slices kunnen ook op een schijf worden gebruikt die toegewijd is aan FreeBSD, maar in een computer zit die ook andere besturingssystemen heeft geïnstalleerd. Dit is een goede manier om verwarring met het programma `fdisk` van andere, niet-FreeBSD besturingssystemen te voorkomen.

Als er met slices gewerkt wordt, wordt de schijf toegevoegd als [.filename]#/dev/da1s1e#. Dit moet worden gelezen als: SCSI-schijf, eenheid 1 (tweede SCSI-schijf), slice 1 (PC-BIOS-partitie 1) en BSD-partitie [.filename]#e#. Als de schijf toegewijd is, wordt deze simpelweg als [.filename]#/dev/da1e# toegevoegd.

Omdat 32-bit-integers worden gebruikt om het aantal sectoren op te slaan, is man:bsdlabel[8] beperkt tot 2^32-1 sectoren per schijf, wat meestal neerkomt op 2 TB. Het programma man:fdisk[8] staat geen hogere startsector toe dan 2^32-1 en geen grotere lengte dan 2^32-1, meestal worden hiermee partities tot 2 TB begrensd en schijven tot 4 TB. Het formaat van man:sunlabel[8] is beperkt tot 2^32-1 sectoren per partitie en 8 partities per schijf, in totaal dus 16 TB. Voor grotere schijven kan man:gpart[8] worden gebruikt om GPT-partities aan te maken. GPT heeft het bijkomende voordeel dat het niet tot 4 slices beperkt is.

=== man:sysinstall[8] gebruiken

[.procedure]
====

. Navigeren door sysinstall
+ 
`sysinstall` kan gebruikt worden om een nieuwe schijf te partitioneren en te labelen met eenvoudig te gebruiken menu's. Hiervoor dient òfwel als gebruiker `root` ingelogd te zijn, òfwel gebruik te worden gemaakt van `su`. Draai `sysinstall` en ga naar het menu `Configure`. Scroll binnen het `FreeBSD Configuration Menu` naar beneden en kies de optie `Fdisk`.
. fdisk partitie-bewerker
+ 
Eenmaal binnen fdisk kan op kbd:[A] gedrukt worden om de gehele schijf voor FreeBSD te gebruiken. Wanneer gevraagd wordt of het systeem compatibel dient te blijven met mogelijk toekomstige besturingssystemen, dient met `YES` geantwoord te worden. Met kbd:[W] kunnen de veranderingen naar de schijf worden geschreven. Nu dient de FDISK-bewerker verlaten te worden door op kbd:[Q] te drukken. Vervolgens wordt er een vraag gesteld over het "Master Boot Record". Omdat er een schijf aan een reeds draaiend systeem wordt toegevoegd, dient hier `None` gekozen te worden.
. Schijflabelbewerker
+ 
Vervolgens dient sysinstall verlaten en opnieuw gestart te worden. Volg bovenstaande aanwijzingen, maar kies deze keer voor de optie `Label`. Dit geeft toegang tot de `Disk Label Editor`. Hier worden de traditionele BSD-partities aangemaakt. Een schijf kan tot acht partities bevatten, gelabeld `a-h`. Enkele partitielabels hebben een speciale functie. De partitie `a` wordt gebruikt voor de rootpartitie ([.filename]#/#). Alleen de systeemschijf (bijvoorbeeld de schijf van waaruit opgestart wordt) moet een partitie `a` hebben. De partitie `b` wordt voor swappartities gebruikt, en het is mogelijk om vele schijven met swappartities te hebben. De partitie `c` adresseert de gehele schijf in toegewijde modus, of de gehele FreeBSD-slice in slice-modus. De andere partities zijn voor algemeen gebruik.
+ 
sysinstall's Labelbewerker heeft een voorkeur voor de partitie `e` voor niet-root-niet-swap-partities. Binnen de Labelbewerker dient een enkel bestandssysteem te worden aangemaakt door op kbd:[C] te drukken. Kies `FS` wanneer gevraagd wordt of dit een FS (file system) of swap wordt, en geef een koppelpunt in (bijvoorbeeld [.filename]#/mnt#). Wanneer een schijf in post-installatie-modus wordt toegevoegd, maakt sysinstall geen ingangen aan in [.filename]#/etc/fstab#, dus dan is het opgegeven koppelpunt niet van belang.
+ 
Nu kan het nieuwe label naar de schijf worden geschreven en er een bestandssysteem op aangemaakt worden. Dit kan gedaan worden door op kbd:[W] te drukken. Fouten van sysinstall dat de nieuwe partitie niet aankoppeld kon worden kunnen genegeerd worden. De Labelbewerker en sysinstall kunnen nu volledig verlaten worden.
. Afronden
+ 
De laatste stap bestaat uit het bewerken van [.filename]#/etc/fstab# om hier een regel voor de nieuwe schijf aan toe te voegen.
====

=== Het gebruik van opdrachtregelgereedschappen

==== Het gebruik van slices

Deze installatie zorgt ervoor dat de schijf correct samenwerkt met andere besturingssystemen die eventueel op de computer zijn geïnstalleerd en dat de `fdisk`-gereedschappen van andere besturingssystemen niet verward raken. Het wordt aangeraden om deze methode te gebruiken voor de installatie van nieuwe schijven. Gebruik de `toegewijde` modus alleen als hier een goede reden voor bestaat!

[source,bash]
....
# dd if=/dev/zero of/dev/da1 bs=1k count=1
# fdisk -BI da1 # Initialiseer de nieuwe schijf.
# bsdlabel -B -w da1s1 auto # Label de schijf.
# bsdlabel -e da1s1 # Bewerk de zojuist aangemaakte schijflabel en voeg partities toe.
# mkdir -p /1
# newfs /dev/da1s1e # Herhaal dit voor alle aangemaakte partities.
# mount /dev/da1s1e /1 # Mount de partitie(s).
# vi /etc/fstab # Voeg de juiste regel(s) aan /etc/fstab toe.
....

Vervang voor een IDE-schijf [.filename]#da# door [.filename]#ad#.

==== Toegewijd

Indien de nieuwe schijf niet met een ander besturingssysteem gedeeld wordt, kan de `toegewijde` modus gebruikt worden. Denk eraan dat deze modus besturingssystemen van Microsoft kan verwarren. Ze richten echter geen schade aan. IBM's OS/2(R) "fatsoeneert" echter partities die het niet begrijpt.

[source,bash]
....
# dd if=/dev/zero of=/dev/da1 bs=1k count=1
# bsdlabel -Bw da1 auto
# bsdlabel -e da1 # Maak de `e'-partitie aan.
# newfs /dev/da1e
# mkdir -p /1
# vi /etc/fstab # Voeg een regel voor /dev/da1e toe.
# mount /1
....

Een alternatieve methode is:

[source,bash]
....
# dd if=/dev/zero of=/dev/da1 count=2
# bsdlabel /dev/da1 | bsdlabel -BR da1 /dev/stdin
# newfs /dev/da1e
# mkdir -p /1 # Voeg een regel voor /dev/da1e toe.
# mount /1
....

[[raid]]
== RAID

[[raid-soft]]
=== Software RAID

[[ccd]]
==== Concatenated Disk Driver (CCD) instellingen

Bij het kiezen van een medium voor massa-opslag zijn de belangrijkste afwegingen snelheid, betrouwbaarheid en kosten. Het komt zelden voor dat alle drie in balans zijn. Normaalgesproken is een snel, betrouwbaar apparaat voor massa-opslag duur en kosten sparen gaat ten koste van òfwel snelheid òfwel betrouwbaarheid.

Bij het ontwerpen van het onderstaande systeem werd primair op de kosten gelet, gevolgd door snelheid en als laatste betrouwbaarheid. De overdrachtsnelheid van gegevens wordt voor dit systeem uiteindelijk beperkt door het netwerk. En hoewel betrouwbaarheid erg belangrijk is, wordt onderstaande CCD-schijf gebruikt voor het serven van on-line gegevens die reeds volledig op CD-R's zijn geback-upt en eenvoudig vervangen kunnen worden.

De eerste stap in het kiezen van een massa-opslagoplossing is het bepalen van de eigen benodigdheden. Indien snelheid belangrijker is dan betrouwbaarheid of kosten, wijkt de oplossing af van het systeem dat in deze sectie wordt beschreven.

[[ccd-installhw]]
===== Hardware installeren

Als aanvulling op de IDE systeemschijf zijn drie Western Digital IDE-schijven van 30 GB, 5400 RPM vanuit de kern van de onderstaande CCD-schijf aanwezig, die ongeveer 90 GB aan on-line opslag bieden. Ideaal gezien heeft iedere IDE-schijf een eigen IDE-controller en kabel, maar om de kosten te minimaliseren zijn geen aanvullende IDE-kabels gebruikt. In plaats hiervan zijn de schijven zodanig met jumpers ingesteld dat elke IDE-controller één master en één slave heeft.

Tijdens het opnieuw opstarten werd het systeem-BIOS zodanig ingesteld dat het automatisch de aangekoppelde schijven detecteerde. Het was belangrijker dat FreeBSD ze tijdens het opnieuw opstarten herkende:

[.programlisting]
....
ad0: 19574MB <WDC WD205BA> [39770/16/63] at ata0-master UDMA33
ad1: 29333MB <WDC WD307AA> [59598/16/63] at ata0-slave UDMA33
ad2: 29333MB <WDC WD307AA> [59598/16/63] at ata1-master UDMA33
ad3: 29333MB <WDC WD307AA> [59598/16/63] at ata1-slave UDMA33
....

[NOTE]
====
Indien FreeBSD niet alle schijven detecteert, moet gecontroleerd worden of de jumpers juist zijn ingesteld. De meeste IDE-schijven hebben ook een jumper voor "Cable Select". Dit is _niet_ de jumper voor de master/slave-instelling. Voor hulp met het identificeren van de juiste jumper dient de documentatie van de schijf geraadpleegd te worden.
====

[[ccd-setup]]
===== CCD installeren

Het stuurprogramma man:ccd[4] biedt de mogelijkheid om meerdere identieke schijven aaneen te rijgen tot één logisch bestandssysteem. Om gebruik te kunnen maken van man:ccd[4] is een kernel met ingebouwde ondersteuning voor man:ccd[4] nodig. De volgende regel dient toegevoegd te worden aan het kernelinstellingenbestand en de kernel dient opnieuw gebouwd en geïnstalleerd te worden:

[.programlisting]
....
device  ccd
....

Om man:ccd[4] te installeren dient eerst man:bsdlabel[8] gebruikt te worden om de schijven te labelen:

[.programlisting]
....
bsdlabel -w -ad1 auto
bsdlabel -w ad2 auto
bsdlabel -w ad3 auto
....

Bovenstaande maakt een schijflabel aan voor [.filename]#ad1c#, [.filename]#ad2c# en [.filename]#ad3c# die de gehele schijf beslaat.

Vervolgens dient het labeltype van de schijf veranderd te worden. Voor het bewerken van de schijven kan man:bsdlabel[8] gebruikt worden:

[.programlisting]
....
bsdlabel -e ad1
bsdlabel -e ad2
bsdlabel -e ad3
....

Dit zorgt ervoor dat het huidige schijflabel van elke schijf met de tekstverwerker wordt geopend die door de omgevingsvariabele `EDITOR` wordt gespecificeerd, vaak man:vi[1].

Een ongewijzigd schijflabel ziet er ongeveer als volgt uit:

[.programlisting]
....
8 partitions:
# size	offset	fstype	[fsize	bsize bps/cpg]
c: 60074784 0 unused  0	0 0 # (Cyl. 0 - 59597)
....

Er dient een nieuwe partitie `e` toegevoegd te worden die door man:ccd[4] gebruikt kan worden. Deze kan gewoonlijk van partitie `c` overgenomen worden, maar het `fstype _moet_ 4.2BSD` zijn. Het schijflabel ziet er nu ongeveer als volgt uit:

[.programlisting]
....
8 partitions:
# size	offset	fstype	[fsize	bsize bps/cpg]
c:  60074784  0	unused	0 0 0 # (Cyl. 0 - 59597)
e:  60074784  0	4.2BSD	0 0 0 #	(Cyl. 0 - 59597)
....

[[ccd-buildingfs]]
===== Bestandssysteem aanmaken

Nu alle schijven gelabeld zijn, moet de man:ccd[4] gebouwd worden. Om dit te doen, dient man:ccdconfig[8] gebruikt te worden met opties die ongeveer gelijk zijn aan de volgende:

[.programlisting]
....
ccdconfig ccd0 32 0 /dev/ad1e /dev/ad2e /dev/ad3e
....

Hieronder staat het gebruik en de betekenis van elke optie:

* Het eerste argument is het in te stellen apparaat, in dit geval [.filename]#/dev/ccd0c#. Het gedeelte [.filename]#/dev/# is optioneel.
* De interleave voor het bestandssysteem. De interleave definiëert de grootte van een stripe in schijfblokken, elk schijfblok is normaalgesproken 512 bytes groot. Een interleave van 32 is dus 16.384 bytes groot.
* Vlaggen voor man:ccdconfig[8]. Indien het gewenst is om schijfspiegeling aan te zetten, kan er hier een vlag voor gespecificeerd worden. Deze opstelling biedt geen spiegeling voor man:ccd[4], dus is die op 0 (nul) ingesteld.
* De laatste argumenten voor man:ccdconfig[8] zijn de apparaten die in de rij geplaatst dienen te worden. Voor elk apparaat dient de complete padnaam gebruikt te worden.

Nadat man:ccdconfig[8] gedraaid is, is de man:ccd[4] ingesteld. Er kan een bestandssysteem worden geïnstalleerd. Er kan in man:newfs[8] worden gekeken voor opties, of het draaien van het onderstaande commando is ook toereikend:

[.programlisting]
....
newfs /dev/ccd0c
....

[[ccd-auto]]
===== Alles automatisch maken

In het algemeen is het wenselijk om de man:ccd[4] telkens te mouten wanneer er opnieuw opgestart wordt. Dit dient eerst ingesteld te worden. Met het volgende commando worden de huidige instellingen naar [.filename]#/etc/ccd.conf# geschreven:

[.programlisting]
....
ccdconfig -g > /etc/ccd.conf
....

Tijdens het opstarten draait het script `/etc/rc ccdconfig -C` indien [.filename]#/etc/ccd.conf# bestaat. Dit stelt automatisch de man:ccd[4] in, zodat die kan worden aangekoppeld.

[NOTE]
====
Indien er in enkele-gebruiker-modus wordt opgestart, dient het volgende commando te worden uitgevoerd om de rij in te stellen voordat de man:ccd[4] aangekoppeld kan worden:

[.programlisting]
....
ccdconfig -C
....

====

Om de man:ccd[4] automatisch aan te koppelen, kan er een regel voor de man:ccd[4] in [.filename]#/etc/fstab# geplaatst worden, zodat die tijdens het opstarten aangekoppeld wordt:

[.programlisting]
....
/dev/ccd0c  /media  ufs rw  2	2
....

[[vinum]]
==== Volumebeheerder Vinum

De volumebeheerder Vinum is een blokstuurprogramma dat virtuele schijven implementeert. Het isoleert schijfhardware van de blokapparaat-interface en projecteert gegevens op een manier die de flexibiliteit, prestatie en betrouwbaarheid verhoogt in vergelijking met de traditionele slice-blik op schijfopslag. man:vinum[4] implementeert de modellen RAID-0, RAID-1 en RAID-5, zowel individueel als als combinatie.

[[raid-hard]]
=== Hardwarematige RAID

FreeBSD ondersteunt ook een verscheidenheid aan hardwarematige RAID-stuurprogramma's. Deze apparaten besturen een RAID-deelsysteem zonder dat er FreeBSD-specifieke software nodig is om de rij te beheren.

Door gebruik te maken van een BIOS die op de kaart aanwezig is, beheert de kaart de meeste schijfbewerkingen zelf. Nu volgt een korte beschrijving van een opzet waarbij een Promise IDE-stuurprogramma is gebruikt. Wanneer deze kaart geïnstalleerd en het systeem opgestart is, beeldt het een prompt af waarbij om informatie wordt gevraagd. De instructies dienen opgevolgd te worden om bij het instelscherm van de kaart te komen. Van hieruit kunnen alle aangekoppelde schijven gecombineerd worden. Nadat dit gedaan is, zien de schijven er voor FreeBSD als één enkele schijf uit. Andere RAID-niveaus kunnen overeenkomstig ingesteld worden.

=== ATA RAID1-rijen opnieuw bouwen

Met FreeBSD is het mogelijk om een defecte schijf in een rij te vervangen terwijl de computer aanstaat ("hot replace"). Hiervoor dient de schijf vóór het opnieuw opstarten vervangen te zijn.

Waarschijnlijk is zoiets als het volgende in [.filename]#/var/log/messages# of in de uitvoer van man:dmesg[8] te zien:

[.programlisting]
....
ad6 on monster1 suffered a hard error.
ad6: READ command timeout tag=0 serv=0 - resetting
ad6: trying fallback to PIO mode
ata3: resetting devices .. done
ad6: hard error reading fsbn 1116119 of 0-7 (ad6 bn 1116119; cn 1107 tn 4 sn 11)\\
status=59 error=40
ar0: WARNING - mirror lost
....

Meer informatie kan met behulp van man:atacontrol[8] gezocht worden:

[source,bash]
....
# atacontrol list
ATA channel 0:
	Master:      no device present
	Slave:   acd0 <HL-DT-ST CD-ROM GCR-8520B/1.00> ATA/ATAPI rev 0

ATA channel 1:
	Master:      no device present
	Slave:       no device present

ATA channel 2:
	Master:  ad4 <MAXTOR 6L080J4/A93.0500> ATA/ATAPI rev 5
	Slave:       no device present

ATA channel 3:
	Master:  ad6 <MAXTOR 6L080J4/A93.0500> ATA/ATAPI rev 5
	Slave:       no device present

# atacontrol status ar0
ar0: ATA RAID1 subdisks: ad4 ad6 status: DEGRADED
....

[.procedure]
====

. Ontkoppel eerst het ata kanaal met de falende schijf zodat deze veilig kan worden verwijderd:
+
[source,bash]
....
# atacontrol detach ata3
....
+
. Vervang de schijf.
. Koppel het ata kanaal opnieuw aan:
+
[source,bash]
....
# atacontrol attach ata3
Master:  ad6 <MAXTOR 6L080J4/A93.0500> ATA/ATAPI rev 5
Slave:   no device present
....
+
. Voeg de nieuwe schijf toe aan de rij als reserve:
+
[source,bash]
....
# atacontrol addspare ar0 ad6
....
+
. De rij dient nu opnieuw opgebouwd te worden:
+
[source,bash]
....
# atacontrol rebuild ar0
....
+
. Het is mogelijk de voortgang te volgen met het volgende commando:
+
[source,bash]
....
# dmesg | tail -10
[uitvoer verwijderd]
ad6: removed from configuration
ad6: deleted from ar0 disk1
ad6: inserted into ar0 disk1 as spare

# atacontrol status ar0
ar0: ATA RAID1 subdisks: ad4 ad6 status: REBUILDING 0% completed
....
+
. Nu moet er gewacht worden tot de bewerking voltooid is.
====

[[usb-disks]]
== USB-opslagapparaten

Veel externe opslagoplossingen gebruiken tegenwoordig de Universele Seriële Bus (USB): harde schijven, USB-duimdrives, CD-R-branders, etc. FreeBSD biedt voor al dit soort apparaten ondersteuning.

=== Instellen

Het stuurprogramma man:umass[4] biedt de ondersteuning voor USB-opslagapparaten. Indien de kernel [.filename]#GENERIC# wordt gebruikt, hoeft er niets aan de instellingen gewijzigd te worden. Als er een eigen kernel wordt gebruikt, dienen de volgende regels in het kernelinstellingenbestand aanwezig zijn:

[.programlisting]
....
device scbus
device da
device pass
device uhci
device ohci
device ehci
device usb
device umass
....

Het stuurprogramma man:umass[4] gebruikt het subsysteem SCSI om toegang te krijgen tot de USB-opslagapparaten. Het USB-apparaat wordt door het systeem als een SCSI-apparaat gezien. Afhankelijk van de chipset op het moederbord is slechts òf `device uhci` òf `device ohci` nodig voor ondersteuning van USB 1.X. Het kan echter geen kwaad om ze beiden in het kernelinstellingenbestand te hebben. Ondersteuning voor USB 2.0 wordt geleverd door het stuurprogramma man:ehci[4] (de regel met `device ehci`). Indien er regels zijn toegevoegd dient de kernel opnieuw gecompileerd en geïnstalleerd te worden.

[NOTE]
====
Indien het USB-apparaat een CD-R- of DVD-brander is, dient het SCSI CD-ROM-stuurprogramma man:cd[4] met de volgende regel aan de kernel toegevoegd te worden:

[.programlisting]
....
device cd
....

Aangezien de brander als een SCSI-schijf gezien wordt, dient het stuurprogramma man:atapicam[4] niet in de kernelinstellingen gebruikt te worden.
====

=== Instellingen testen

De instellingen zijn klaar om getest te worden: het USB-apparaat dient aangesloten te worden en in de buffer voor systeemmeldingen (man:dmesg[8]) dient het stuurprogramma ongeveer als volgt te verschijnen:

[source,bash]
....
umass0: USB Solid state disk, rev 1.10/1.00, addr 2
GEOM: create disk da0 dp=0xc2d74850
da0 at umass-sim0 bus 0 target 0 lun 0
da0: <Generic Traveling Disk 1.11> Removable Direct Access SCSI-2 device
da0: 1.000MB/s transfers
da0: 126MB (258048 512 byte sectors: 64H 32S/T 126C)
....

Uiteraard kunnen het merk, de apparaatnode ([.filename]#da0#) en andere details verschillen naar gelang de instelling.

Aangezien het USB-apparaat als een SCSI-apparaat gezien wordt, kan het commando `camcontrol` gebruikt worden om de USB-opslagapparaten weer te geven die aan het systeem gekoppeld zijn:

[source,bash]
....
# camcontrol devlist
<Generic Traveling Disk 1.11>      at scbus0 target 0 lun 0 (da0,pass0)
....

Indien er een bestandssysteem op de schijf aanwezig is, kan dat aangekoppeld worden. <<disks-adding>> biedt indien nodig hulp bij het formatteren en aanmaken van partities op de USB-drive.

[WARNING]
====

Door het toestaan dat gewone gebruikers verschillende media kunnen koppelen door bijvoorbeeld het aanzetten van `vfs.usermount` zoals hieronder beschreven, zou niet als veilig beschoud moeten worden uit een beveiligings oogpunt. Veel bestandssystemen in FreeBSD zijn niet geschreven om beveiliging te bieden tegen kwaadaardige apparaten.
====

Om het apparaat koppelbaar te maken voor de gewone gebruiker moeten er een aantal stappen ondernomen worden. Als eerste moeten de apparaten die gecreeerd worden wanneer het USB opslag- medium wordt toegevoegd toegankelijk zijn voor de gebruiker. Een oplossing is om alle gebruikers die deze rechten nodig hebben toe te voegen aan de `operator` groep. Dit kan gedaan worden met man:pw[8]. Daarna moet het voor de `operator` groep mogelijk zijn te lezen en te schrijven naar de gecreeerde apparaten. Dit kan bewerkstelligd worden door de volgende regels toe te voegen aan [.filename]#/etc/devfs.rules#:

[.programlisting]
....
[localrules=5]
add path 'da*' mode 0660 group operator
....

[NOTE]
====
Als er SCSI schijven in het systeem aanwezig zijn moet dit anders aangepakt worden. Stel dat het systeem reeds over de volgende schijven beschikt [.filename]#da0# tot en met [.filename]#da2#, verander de regel dan in het volgende:

[.programlisting]
....
add path 'da[3-9]*' mode 0660 group operator
....

Dit sluit de reeds bestaande schijven buiten van toegang door de operator groep.
====

Erna moet ook de nieuwe ruleset voor man:devfs.rules[5] ingeschakeld worden door middel van [.filename]#/etc/rc.conf#:

[.programlisting]
....
devfs_system_ruleset="localrules"
....

Hierna moet de kernel worden geconfigureerd zodat gewone gebruikers rechten krijgen om bestandssystemen te koppelen. De makkelijkste manier is door de volgende regel toe te voegen aan [.filename]#/etc/sysctl.conf#:

[.programlisting]
....
vfs.usermount=1
....

Let op, deze wijziging wordt pas actief na de volgende start van het systeem. Als alternatief kan ook man:sysctl[8] gebruikt worden om deze variabele te zetten.

De laatste stap is het creëeren van de map waar het bestandssysteem gekoppeld wordt. Deze map moet eigendom zijn van de gebruiker die het bestandssysteem gaat koppelen. Een manier om dat te bewerkstelligen is door met de gebruiker `root` een submap aan te maken die eigendom is van de gebruiker als [.filename]#/mntgebruikersnaam# (verander _gebruikersnaam_ door de loginnaam van de daadwerkelijke gebruiker en _gebruikersgroep_ door de primaire groep van de gebruiker):

[source,bash]
....
# mkdir /mnt/gebruikersnaam
# chown gebruikersnaam:gebruikersgroep /mnt/gebruikersnaam
....

Stel dat er vervolgens een USB-stick ingeplugged wordt en er een [.filename]#/dev/da0s1# aangemaakt wordt. Omdat deze apparaten meestal voorgeformatteerd met een FAT-bestandssysteem komen, kan deze als volgende gekoppeld worden:

[source,bash]
....
% mount -t msdosfs -o -m=644,-M=755 /dev/da0s1 /mnt/gebruikersnaam
....

Indien het apparaat losgekoppeld wordt (nadat de schijf afgekoppeld is), dient in de buffer voor systeemmeldingen iets als het volgende te zien te zijn:

[source,bash]
....
umass0: at uhub0 port 1 (addr2) disconnected
(da0:umass-sim0:0:0:0): lost device
(da0:umass-sim0:0:0:0): removing device entry
GEOM: destroy disk da0 dp=0xc2d74850
umass0: detached
....

=== Referenties

Naast de onderdelen <<disks-adding,Schijven toevoegen>> en crossref:basics[mount-unmount,Bestandssystemen aan- en afkoppelen], kunnen de volgende hulppagina's ook nuttig zijn: man:umass[4], man:camcontrol[8] en man:usbconfig[8] voor FreeBSD 8.X of man:usbdevs[8] voor eerdere versies van FreeBSD.

[[creating-cds]]
== Optische media (CD's) aanmaken en gebruiken

=== Inleiding

CD's hebben een aantal eigenschappen waardoor ze verschillen van conventionele schijven. Initieel zijn ze door de gebruiker niet beschrijfbaar. Ze zijn zó ontworpen dat ze continu, zonder vertragingen van het verplaatsen van de kop tussen tracks, gelezen kunnen worden. Ze zijn ook veel gemakkelijker tussen twee systemen te verplaatsen dan gelijksoortige media in hun tijd waren.

CD's hebben tracks, maar die verwijzen naar secties van gegevens die continu gelezen dienen te worden en niet naar fysieke eigenschappen van de schijf. Om een CD op FreeBSD te produceren, dienen de gegevensbestanden waaruit de tracks op de CD gaan bestaan te worden voorbereid, waarna de tracks op de CD worden geschreven.

Het bestandssysteem ISO 9660 is ontworpen om met deze verschillen om te gaan. Helaas codeert het bestandssysteemgrenzen die destijds gebruikelijk waren. Gelukkig biedt het een uitbreidingsmechanisme dat correct geschreven CD's toestaat om deze grenzen te overschrijden en nog steeds te werken met systemen die deze uitbreidingen niet ondersteunen.

De port package:sysutils/cdrtools[] bevat man:mkisofs[8], een programma dat gebruikt kan worden om een gegevensbestand aan te maken dat een ISO 9660-bestandssysteem bevat. Het bevat opties die verschillende uitbreidingen ondersteunen en wordt hieronder beschreven.

Het gereedschap om de CD te branden hangt af van het feit of de CD-brander ATAPI of iets anders is. ATAPI CD-branders gebruiken het programma `burncd` dat deel uitmaakt van het basissysteem. SCSI en USB CD-branders dienen `cdrecord` van de port package:sysutils/cdrtools[] te gebruiken. Het is ook mogelijk om `cdrecord` en andere gereedschappen voor SCSI-drives op ATAPI-hardware te gebruiken door middel van de <<atapicam,module ATAPI/CAM>>.

Indien CD-brandsoftware met een grafische gebruikersinterface gewenst is, is X-CD-Roast of K3b  een mogelijkheid. Deze gereedschappen zijn beschikbaar als package of vanuit de ports package:sysutils/xcdroast[] en package:sysutils/k3b[]. X-CD-Roast en K3b hebben de <<atapicam,module ATAPI/CAM>> met ATAPI-hardware nodig.

[[mkisofs]]
=== mkisofs

Het programma man:mkisofs[8], dat deel uitmaakt van de port package:sysutils/cdrtools[], maakt een ISO 9660-bestandssysteem aan dat een beeld is van een boomstructuur in de UNIX(R) bestandssysteem-namespace. De eenvoudigste gebruiksvorm is:

[source,bash]
....
# mkisofs -o beeldbestand.iso /pad/naar/boomstructuur
....

Dit commando maakt een _beeldbestand.iso_ aan dat een ISO 9660-bestandssysteem bevat dat een kopie is van de boomstructuur in _/pad/naar/boomstructuur_. Tijdens het proces beeldt het bestandsnamen af op namen die aan de beperkingen van het standaard ISO 9660-bestandssysteem voldoen en sluit het bestanden uit die namen hebben die niet karakteristiek zijn voor ISO-bestandssystemen.

Er is een aantal opties beschikbaar om over deze beperkingen heen te komen. In het bijzonder zet `-R` de Rock Ridge-uitbreidingen aan die gangbaar zijn voor UNIX(R) systemen, zet `-J` de Rock Ridge-uitbreidingen aan die gebruikt worden op Microsoft-systemen en `-hfs` kan gebruikt worden om HFS-bestandssystemen aan te maken die door Mac OS(R) gebruikt worden.

Voor CD's die alleen op FreeBSD-systemen gebruikt gaan worden, kan `-U` gebruikt worden om alle restricties op bestandsnamen uit te zetten. Indien het met `-R` gebruikt wordt, maakt het een bestandssysteembeeld aan dat identiek is aan de FreeBSD-boomstructuur van waaruit begonnen is, alhoewel het mogelijk is dat het zich op aantal manieren niet aan de ISO 9660-standaard houdt.

De laatste optie voor algemeen gebruik is `-b`. Deze wordt gebruikt om de plaats van het opstartbeeld aan te geven om een "El Torito" opstartbare CD te maken. Deze optie heeft een argument nodig, namelijk het pad naar een opstartbeeld dat het begin van de boomstructuur die naar de CD geschreven wordt voorstelt. Gewoonlijk maakt man:mkisofs[8] een ISO-beeld aan in de zogenaamde "diskette-emulatie"-modus en verwacht het dus dat het beeldbestand exact 1200, 1440 of 2880 KB groot is. Sommige bootloaders, zoals degene die door de distributieschijven van FreeBSD wordt gebruikt, gebruiken de emulatiemodus niet. In dat geval dient de optie `-no-emul-boot` gebruikt te worden. Dus indien [.filename]#/tmp/myboot# een opstartbaar FreeBSD-systeem met het beeldbestand in [.filename]#/tmp/myboot/boot/cdboot# bevat, kan het beeld van een ISO 9660-bestandssysteem als volgt in [.filename]#/tmp/bootable.iso# aangemaakt worden:

[source,bash]
....
# mkisofs -R -no-emul-boot -b boot/cdboot -o /tmp/bootable.iso /tmp/myboot
....

Als dit gedaan is en [.filename]#md# in de kernel is ingesteld, kan het bestandssysteem gekoppeld worden:

[source,bash]
....
# mdconfig -a -t vnode -f /tmp/bootable.iso -u 0
# mount -t cd9660 /dev/md0 /mnt
....

Nu kan gecontroleerd worden of [.filename]#/mnt# en [.filename]#/tmp/myboot# identiek zijn.

Er zijn vele andere opties die met man:mkisofs[8] gebruikt kunnen worden om het gedrag af te stemmen. In het bijzonder wijzigingen aan een ISO 9660-structuur en het aanmaken van Joliet- en HFS-schijven. Details staan in man:mkisofs[8].

[[burncd]]
=== burncd

Indien er een ATAPI CD-brander aanwezig is, kan het commando `burncd` gebruikt worden om een ISO-beeld naar een CD te branden. `burncd` maakt deel uit van het basissysteem en is geïnstalleerd als [.filename]#/usr/sbin/burncd#. Het gebruik is erg eenvoudig, aangezien het weinig opties heeft.

[source,bash]
....
# burncd -f cd-apparaat gegevens beeldbestand.iso fixate
....

Het bovenstaande commando brandt een kopie van _beeldbestand.iso_ naar _cd-apparaat_. Het standaardapparaat is [.filename]#/dev/acd0#. Opties om de schrijfsnelheid in te stellen, de CD na het branden uit te werpen en geluidsgegevens te schrijven staan in man:burncd[8].

[[cdrecord]]
=== cdrecord

Indien er geen ATAPI CD-brander aanwezig is, dient `cdrecord` gebruikt te worden om CD's te branden. `cdrecord` maakt geen deel uit van het basissysteem. Het dient òfwel vanuit de port in package:sysutils/cdrtools[] òfwel als package geïnstalleerd te worden. Veranderingen in het basissysteem kunnen ervoor zorgen dat binaire versies van dit programma falen, wat mogelijk tot een "coaster" leidt. Daarom dient òfwel de port bijgewerkt te worden als het systeem wordt bijgewerkt, òwel, als crossref:cutting-edge[stable,-STABLE gevolgd] wordt, dient de port bijgewerkt te worden wanneer er een nieuwe versie beschikbaar komt.

Hoewel `cdrecord` vele opties heeft, is het gebruik voor gewone situaties nog eenvoudiger dan dat van `burncd`. Een ISO 9660-beeld kan gebrand worden met:

[source,bash]
....
# cdrecord dev=device beeldbestand.iso
....

Het lastige gedeelte in het gebruik van `cdrecord` is het vinden van de juiste `dev`. Om de juiste instelling te vinden, kan de vlag `-scanbus` van `cdrecord` gebruikt worden, wat resultaten zoals de onderstaande kan geven:

[source,bash]
....
# cdrecord -scanbus
Cdrecord-Clone  2.01 (i386-unknown-freebsd7.0) Copyright (C) 1995-2004 Jörg Schilling
Using libscg version 'schily-0.1'
scsibus0:
        0,0,0     0) 'SEAGATE ' 'ST39236LW       ' '0004' Disk
        0,1,0     1) 'SEAGATE ' 'ST39173W        ' '5958' Disk
        0,2,0     2) *
        0,3,0     3) 'iomega  ' 'jaz 1GB         ' 'J.86' Removable Disk
        0,4,0     4) 'NEC     ' 'CD-ROM DRIVE:466' '1.26' Removable CD-ROM
        0,5,0     5) *
        0,6,0     6) *
        0,7,0     7) *
scsibus1:
        1,0,0   100) *
        1,1,0   101) *
        1,2,0   102) *
        1,3,0   103) *
        1,4,0   104) *
        1,5,0   105) 'YAMAHA  ' 'CRW4260         ' '1.0q' Removable CD-ROM
        1,6,0   106) 'ARTEC   ' 'AM12S           ' '1.06' Scanner
        1,7,0   107) *
....

Dit geeft de gepaste `dev`-waarden voor de apparaten in de lijst. De CD-brander dient gezocht te worden, waarna de drie getallen gescheiden door komma's gebruikt kunnen worden als de waarde voor `dev`. In dit geval is het CD-RW-apparaat 1,5,0, dus is de juiste invoer `dev=1,5,0`. Er zijn eenvoudigere manieren om deze waarde te specificeren. In man:cdrecord[1] staan meer details. Hier staat ook informatie over geluidstracks, de snelheid instellen en meer.

[[duplicating-audiocds]]
=== Audio-CD's dupliceren

Een audio-CD kan gedupliceerd worden door de geluidsgegevens van de CD naar een serie bestanden te schrijven en deze bestanden daarna naar een lege CD te schrijven. Het proces verschilt licht tussen ATAPI- en SCSI-drives.

[.procedure]
====
*Procedure: SCSI-drives*

. Onttrek `cdda2wav` de audio:
+
[source,bash]
....
% cdda2wav -vall -D2,0 -B -Owav
....
+
. Schrijf met `cdrecord` de [.filename]#.wav#-bestanden:
+
[source,bash]
....
% cdrecord -v dev=2,0 -dao -useinfo *.wav
....
+ 
Controleer of _2,0_ juist is opgegeven, zoals beschreven in <<cdrecord>>.
====

[.procedure]
====
*Procedure: ATAPI-drives*

[NOTE]
======
Met behulp van de <<atapicam,ATAPI/CAM module>> kan `cdda2wav` ook gebruikt worden voor ATAPI-drives. Dit gereedschap is vaak een betere keuze voor de meeste gebruikers (jitter-correctie, endianness-zaken, etc.) dan de methode die hieronder wordt voorgesteld.
======

. Het ATAPI CD-stuurprogramma maakt elke track beschikbaar als [.filename]#/dev/acddtnn#, waarin _d_ het stationsnummer is en _nn_ het tracknummer is in twee decimale cijfers, dat indien nodig vooraf wordt gegaan door een nul. Dus is de eerste track op de eerste schijf [.filename]#/dev/acd0t01#, de tweede [.filename]#/dev/acd0t02#, de derde [.filename]#/dev/acd0t03#, enzovoort.
+ 
Controleer of de juiste bestanden in [.filename]#/dev# bestaan. Als de benodigde namen er niet bijstaan, forceer het systeem dan om opnieuw te kijken:
+
[source,bash]
....
# dd if=/dev/acd0 of=/dev/null count=1
....
+
. De track kan met man:dd[1] onttrokken worden. Bij het onttrekken van de bestanden dient een specifieke blokgrootte gebruikt te worden.
+
[source,bash]
....
# dd if=/dev/acd0t01 of=track1.cdr bs=2352
#dd if=/dev/acd0t02 of=track2.cdr bs=2352
...
....
+
. Brand de onttrokken bestanden met `burncd`. Er dient opgegeven te worden dat het geluidsbestanden zijn en dat `burncd` de schijf moet fixeren wanneer na afronding van het proces.
+
[source,bash]
....
# burncd -f /dev/acd0 audio track1.cdr track2.cdr ... fixate
....
====

[[imaging-cd]]
=== Gegevens-CD's dupliceren

Een gegevens-CD kan gekopieerd worden naar een beeldbestand dat functioneel gelijk is aan het beeldbestand dat met man:mkisofs[8] gemaakt is en het kan gebruikt worden om elke gegevens-CD te dupliceren. Het hier gegeven voorbeeld neemt aan dat het CD-ROM-apparaat [.filename]#acd0# is.

[source,bash]
....
# dd if=/dev/acd0 of=bestand.iso bs=2048
....

Nu het beeld beschikbaar is, kan het naar CD geschreven worden zoals hierboven beschreven.

[[mounting-cd]]
=== Gegevens-CD's gebruiken

Nu er een standaard gegevens-CD-ROM is aangemaakt moet deze waarschijnlijk aangekoppeld worden om de gegevens die er op staan te lezen. Normaalgesproken neemt man:mount[8] aan dat een bestandssysteem van het soort `ufs` is. Als zoiets als onderstaande geprobeerd wordt komt er een klacht over `Incorrect super block` en wordt er niet aangekoppeld:

[source,bash]
....
# mount /dev/cd0 /mnt
....

De CD-ROM bevat geen `UFS`-bestandssysteem, dus pogingen om zo aan te koppelen mislukken. Er dient aan man:mount[8] verteld te worden dat het bestandssysteem van het soort `ISO9660` is en dan werkt alles. Dit kan door de optie `-t cd9660` van man:mount[8] op te geven. Het CD-ROM-apparaat [.filename]#/dev/cd0# onder [.filename]#/mnt# aankoppelen kan zo:

[source,bash]
....
# mount -t cd9660 /dev/cd0 /mnt
....

De apparaatnaam (in dit voorbeeld [.filename]#/dev/cd0#) kan afwijken, afhankelijk van de interface die de CD-ROM gebruikt. Verder voert de optie `-t cd9660` gewoon man:mount_cd9660[8] uit. Bovenstaand voorbeeld kan verkort worden tot:

[source,bash]
....
# mount_cd9660 /dev/cd0 /mnt
....

Het is in het algemeen mogelijk om gegevens-CD-ROMs van elke fabrikant op deze manier te gebruiken. Schijven met bepaalde uitbreidingen op ISO 9660 kunnen zich echter vreemd gedragen. Joliet-schijven bijvoorbeeld, slaan alle bestandsnamen op in twee-byte Unicode-karakters. De FreeBSD-kernel spreekt geen Unicode, maar het FreeBSD CD9660 stuurprogramma is in staat om Unicode karakters direct te converteren. Als er niet-Engelse karakters verschijnen als vraagtekens, moet de lokale karakterset gedefinieerd worden met de `-C` optie. Zie de man:mount_cd9660[8] handleiding voor meer informatie.

[NOTE]
====
Om in staat te zijn om de karakter conversie te doen met behulp van de `-C` optie, heeft de kernel de [.filename]#cd9660_iconv.ko# module nodig. Deze kan ingeladen worden door het volgende toe te voegen aan [.filename]#/boot/loader.conf#:

[.programlisting]
....
cd9660_iconv_load="YES"
....

en daarna de machine te herstarten of door de module direct in te laden met man:kldload[8].
====

Zo nu en dan kan `Device not configured` verschijnen als geprobeerd wordt om een CD-ROM aan te koppelen. Dit betekent meestal dat het CD-ROM-station denkt dat er geen schijf in de lade ligt of dat het station niet zichtbaar is op de bus. Omdat het enkele seconden kan duren voordat een CD-ROM-station doorheeft dat er een CD-ROM in ligt, is geduld geboden.

Soms wordt een SCSI CD-ROM gemist omdat het station niet genoeg tijd had om antwoord te geven op de busreset. Indien er een SCSI CD-ROM aanwezig is, dient de volgende optie aan de kernelinstellingen toegevoegd te worden en de crossref:kernelconfig[kernelconfig-building,kernel opnieuw gebouwd] te worden.

[.programlisting]
....
options SCSI_DELAY=15000
....

Dit zorgt ervoor dat de SCSI-bus 15 seconden pauzeert tijdens het opstarten opdat het CD-ROM-station elke gelegenheid krijgt om de busreset te beantwoorden.

[[rawdata-cd]]
=== Rauwe gegevens-CD's branden

Een bestand kan direct naar CD geschreven worden zonder een ISO 9660-bestandssysteem aan te maken. Sommige mensen doen dit voor back-updoeleinden. Dit gaat sneller dan een standaard-CD branden:

[source,bash]
....
# burncd -f /dev/acd1 -s 12 gegevens archief.tar.gz fixate
....

Om de gegevens terug te halen die op zo'n CD gebrand zijn, is het noodzakelijk om gegevens van de rauwe apparaatnode te lezen:

[source,bash]
....
# tar xzvf /dev/acd1
....

Het is niet mogelijk om deze schijf aan te koppelen zoals dat voor een normale CD-ROM gedaan wordt. Zo'n CD-ROM kan onder geen enkel besturingssysteem, behalve FreeBSD, gelezen worden. Om de CD aan te kunnen koppelen of gegevens te delen met een ander besturingssysteem, dient man:mkisofs[8] gebruikt te worden, zoals boven beschreven is.

[[atapicam]]
=== Het ATAPI/CAM-stuurprogramma gebruiken

Dit stuurprogramma stelt ATAPI-apparaten (CD-ROM, CD-RW, DVD-stations, enzovoort) in staat om vanuit het SCSI-subsysteem benaderd te worden en maakt daarmee het gebruik van applicaties zoals package:sysutils/cdrdao[] of man:cdrecord[1] mogelijk.

Om dit stuurprogramma te gebruiken, is het noodzakelijk om de volgende regel aan het [.filename]#/boot/loader.conf# bestand toe te voegen:

[.programlisting]
....
atapicam_load="YES"
....

om daarna de machine opnieuw op te starten.

[NOTE]
====
Als het noodzakelijk is om man:atapicam[4] statisch toe te voegen aan de kernel moet de volgende regel worden toegevoegd aan het kernelinstellingenbestand:

[.programlisting]
....
device atapicam
....

Ook zijn de volgende regels in het kernelinstellingenbestand nodig, die meestal wel aanwezig zijn:

[.programlisting]
....
device ata
device scbus
device cd
device pass
....

Hierna dient de nieuwe kernel opnieuw gebouwd en geïnstalleerd te worden en dient de machine opnieuw gestart te worden.
====

Tijdens het opstartproces dient de brander als volgt te verschijnen:

[source,bash]
....
acd0: CD-RW <MATSHITA CD-RW/DVD-ROM UJDA740> at ata1-master PIO4
cd0 at ata1 bus 0 target 0 lun 0
cd0: <MATSHITA CD-RW/DVD UJDA740 1.00> Removable CD-ROM SCSI-0 device
cd0: 16.000MB/s transfers
cd0: Attempt to query device size failed: NOT READY, Medium not present - tray closed
....

Het station is nu toegankelijk via de apparaatnaam [.filename]#/dev/cd0#. Om bijvoorbeeld een CD-ROM op [.filename]#/mnt# aan te koppelen:

[source,bash]
....
# mount -t cd9660 /dev/cd0 /mnt
....

Als `root` kan het volgende commando gegeven worden om het SCSI-adres van de brander te verkrijgen:

[source,bash]
....
# camcontrol devlist
<MATSHITA CD-RW/DVD UJDA740 1.00> at scbus1 target 0 lun 0 (pass0,cd0)
....

Dus `1,0,0` is het SCSI-adres dat met man:cdrecord[1] en andere SCSI-toepassingen gebruikt dient te worden.

Meer informatie over het ATAPI/CAM en het SCSI-systeem staat in de hulppagina's van man:atapicam[4] en man:cam[4].

[[creating-dvds]]
== Optische media (DVD's) aanmaken en gebruiken

=== Inleiding

Vergeleken met de CD behoort de DVD de tot de volgende generatie van optische media-opslagtechnologie. De DVD kan meer gegevens bevatten dan enige CD en is tegenwoordig de standaard voor videopublicatie.

Er kunnen vijf fysieke opneembare formaten gedefinieerd worden die opneembare DVD heten:

* DVD-R: dit was het eerst beschikbare opneembare DVD-formaat. De DVD-R-standaard is gedefinieerd door het http://www.dvdforum.com/forum.shtml[DVD Forum]. Dit formaat is voor eenmalig schrijven.
* DVD-RW: dit is de herschrijfbare versie van de DVD-R-standaard. Een DVD-RW kan tot ongeveer 1.000 maal herschreven worden.
* DVD-RAM: dit is ook een herschrijfbaar formaat dat door het DVD Forum ondersteund wordt. Een DVD-RAM kan gezien worden als een verwisselbare harde schijf. Dit medium is echter niet uitwisselbaar met de meeste DVD-ROM-stations en DVD-Video-spelers. Slechts enkele DVD-schrijvers ondersteunen het DVD-RAM-formaat. Lees <<creating-dvd-ram>> voor meer informatie over het gebruik van DVD-RAM.
* DVD+RW: dit is het herschrijfbare formaat dat is gedefinieerd door de http://www.dvdrw.com/[DVD+RW Alliance]. Een DVD+RW kan tot ongeveer 1.000 maal herschreven worden.
* DVD+R: dit formaat is de eenmalig beschrijfbare versie van het DVD+RW-formaat.

Een enkellaags opneembare DVD kan maximaal 4.700.000.000 bytes bevatten, wat eigenlijk 4,38 GB of 4.485 MB is (1 kB is 1024 bytes).

[NOTE]
====
Er dient onderscheid gemaakt te worden tussen het fysieke medium en de toepassing. Een DVD-Video bijvoorbeeld is een specifiek bestandsschema dat op elk fysiek opneembaar DVD-medium geschreven kan worden: DVD-R, DVD+R, DVD-RW, enzovoort. Voordat het mediumtype gekozen wordt, dient het zeker te zijn dat zowel de brander als de DVD-Video-speler (een onafhankelijke speler of een DVD-ROM-station in een computer) overweg kunnen met het overwogen medium.
====

=== Instellingen

Het programma man:growisofs[1] wordt gebruikt om DVD's op te nemen. Dit commando is deel van de dvd+rw-tools gereedschappen (package:sysutils/dvd+rw-tools[]). dvd+rw-tools ondersteunt alle types DVD-media.

Deze gereedschappen gebruiken het SCSI-subsysteem om toegang tot de apparaten te krijgen, daarvoor moet <<atapicam,ondersteuning voor ATAPI/CAM>> aan de kernel toegevoegd worden. Indien de brander de USB-interface gebruikt, is deze toevoeging nutteloos en dient <<usb-disks>> gelezen te worden voor meer details over het instellen van USB-apparaten.

De DMA-toegang voor ATAPI-apparaten dient ook aangezet te worden door de volgende regel aan het bestand [.filename]#/boot/loader.conf# toe te voegen:

[.programlisting]
....
hw.ata.atapi_dma="1"
....

Voordat de dvd+rw-tools gebruikt kunnen worden, dienen de http://fy.chalmers.se/~appro/linux/DVD+RW/hcn.html[ dvd+rw-tools' hardware compatibility notes] geraadpleegd te worden voor enige informatie die betrekking heeft op de DVD-brander.

[NOTE]
====
Indien een grafische gebruikersinterface gewenst is, is K3b (package:sysutils/k3b[]), die een gebruikersvriendelijke interface biedt voor man:growisofs[1] en vele andere brandprogramma's, het bekijken waard.
====

=== Gegevens-DVD's branden

Het commando man:growisofs[1] is een frontend voor <<mkisofs,mkisofs>>. Het roept man:mkisofs[8] aan om het bestandssysteemoverzicht aan te maken en het schrijft naar de DVD. Hierdoor is het niet nodig om een beeld van de gegevens aan te maken voordat met branden begonnen wordt.

Om de gegevens uit de map [.filename]#/pad/naar/gegevens# op een DVD+R of een DVD-R te branden:

[source,bash]
....
# growisofs -dvd-compat -Z /dev/cd0 -J -R /pad/naar/gegevens
....

De opties `-J -R` worden doorgegeven aan man:mkisofs[8] voor het aanmaken van het bestandssysteem (in dit geval een ISO 9660-bestandssysteem met Joliet en Rock Ridge uitbreidingen). Meer details staan in de hulppagina man:mkisofs[8].

De optie `-Z` wordt gebruikt voor het opnemen van de eerste sessie, ook bij meerdere sessies. Het DVD-apparaat, _/dev/cd0_, dient aan de hand van de instellingen aangepast te worden. De parameter `-dvd-compat` sluit de schijf zodat er niets aan de opname toegevoegd kan worden. Dit zou als tegenprestatie betere uitwisselbaarheid met DVD-ROM-stations moeten geven.

Het is ook mogelijk om een vooraf gemastered beeld te branden, om bijvoorbeeld het beeld _beeldbestand.iso_ te branden:

[source,bash]
....
# growisofs -dvd-compat -Z /dev/cd0=beeldbestand.iso
....

De schrijfsnelheid moet automatisch gedetecteerd en ingesteld worden, afhankelijk van het medium en het gebruikte station. Om de schrijfsnelheid te forceren, dient de parameter `-speed=` gebruikt te worden. Meer informatie staat in de hulppagina man:growisofs[1].

[NOTE]
====
Om bestanden groter dan 4,38GB in de compilatie op te nemen dient een UDF/ISO-9660 hybride bestandssysteem aangemaakt te worden door de aanvullende parameter `-udf -iso-level 3` aan man:mkisofs[8] en alle gerelateerde programma's (i.e., man:growisofs[1]) door te geven. Dit is alleen nodig als een ISO beeldbestand wordt aangemaakt, of als bestanden direct naar een schijf worden geschreven. Schijven die op deze manier zijn aangemaakt moeten als een UDF-bestandssysteem worden aangekoppeld met het hulpmiddel man:mount_udf[8], zodat het alleen bruikbaar is op een besturingssysteem dat zich van UDF bewust is, anders zal het lijken of er corrupte bestanden op staan.

Om zo'n ISO-bestand aan te maken:

[source,bash]
....
% mkisofs -R -J -udf -iso-level 3 -o beeldbestand.iso /pad/naar/gegevens
....

Om de bestanden direct naar een schijf te schrijven:

[source,bash]
....
# growisofs -dvd-compat -udf -iso-level 3 -Z /dev/cd0 -J -R /pad/naar/gegevens
....

Wanneer u een ISO-beeld heeft dat al grote bestanden bevat, zijn er geen extra opties nodig om met man:growisofs[1] het beeld naar een schijf te schrijven.

Zorg er ook voor dat u een actuele versie van package:sysutils/cdrtools[] heeft (welke man:mkisofs[8] bevat), aangezien oudere versies geen ondersteuning voor grote bestanden bieden. Als u problemen tegenkomt, gebruik dan de ontwikkelversie, package:sysutils/cdrtools-devel[] en lees de handleidingpagina man:mkisofs[8].
====

=== DVD-Video branden

Een DVD-Video is een specifiek bestandsschema dat gebaseerd is op de ISO 9660 en de micro-UDF (M-UDF) specificaties. DVD-Video heeft ook een specifieke hiërarchie voor de gegevensstructuur, de reden waarom een speciaal programma zoals package:multimedia/dvdauthor[] nodig is om de DVD te schrijven.

Indien er reeds een beeld van het bestandssysteem van de DVD-Video beschikbaar is, kan het zoals elk ander beeld gebrand worden. In de vorige sectie staat een voorbeeld. Als het resultaat voor de inhoud voor de DVD bijvoorbeeld in de map [.filename]#/pad/naar/video# staat, kan de DVD-Video als volgt gebrand worden:

[source,bash]
....
# growisofs -Z /dev/cd0 -dvd-video /pad/naar/video
....

De optie `-dvd-video` wordt doorgegeven aan man:mkisofs[8] en geeft het opdracht om een bestandssysteemschema voor een DVD-Video aan te maken. Verder impliceert de optie `-dvd-video` de optie `-dvd-compat` van man:growisofs[1].

=== DVD+RW gebruiken

In tegenstelling tot een CD-RW dient een nieuwe DVD+RW voor het eerste gebruik geformatteerd te worden. Het programma man:growisofs[1] regelt dit automatisch als nodig. Dit is de _aanbevolen_ manier. Het is ook mogelijk om `dvd+rw-format` te gebruiken om een DVD+RW te formatteren:

[source,bash]
....
# dvd+rw-format /dev/cd0
....

Deze operatie hoeft slechts één maal uitgevoerd te worden. Onthoud dat alleen nieuwe DVD+RW-media geformatteerd dienen te worden. Daarna is het mogelijk om de DVD+RW op dezelfde manier te branden zoals in bovenstaande secties staat vermeldt.

Om nieuwe gegevens op een DVD+RW te branden (een geheel nieuw bestandssysteem branden, niet wat gegevens toevoegen), is het niet nodig om deze te wissen. Het is voldoende om de vorige opname te overschrijven (tijdens het aanmaken van een initiële sessie), zoals hieronder:

[source,bash]
....
# growisofs -Z /dev/cd0 -J -R /pad/naar/nieuwe gegevens
....

Het DVD+RW-formaat biedt de mogelijkheid om eenvoudig nieuwe gegevens aan een vorige opname toe te voegen. De operatie bestaat uit het samenvoegen van een nieuwe sessie en de bestaande. Het is geen multisessie-schrijven. man:growisofs[1] laat het ISO 9660-bestandssysteem dat aanwezig is op het medium _groeien_.

Om gegevens aan de vorige DVD+RW toe te voegen:

[source,bash]
....
# growisofs -M /dev/cd0 -J -R /pad/naar/volgende gegevens
....

Dezelfde opties van man:mkisofs[8] die gebruikt werden om de initiële sessie te branden, dienen gebruikt te worden tijdens schrijfsessies.

[NOTE]
====
De optie `-dvd-compat` kan gebruikt worden als betere uitwisselbaarheid met DVD-ROM-stations gewenst is. In het geval van een DVD+RW verhindert dit het toevoegen van gegevens niet.
====

Om het medium te wissen:

[source,bash]
....
# growisofs -Z /dev/cd0=/dev/zero
....

=== DVD-RW gebruiken

Een DVD-RW accepteert twee schijfformaten: de incrementele sequentiële en beperkt overschrijven. Standaard zijn DVD-RW-schijven in het sequentiële formaat.

Een nieuwe DVD-RW kan direct beschreven worden zonder deze te formatteren. Een gebruikte DVD-RW in sequentieel formaat dient echter gewist te worden voordat het mogelijk is om een nieuwe initiële sessie te schrijven.

Om een DVD-RW in sequentiële toestand te wissen, dient het volgende gedaan te worden:

[source,bash]
....
# dvd+rw-format -blank=full /dev/cd0
....

[NOTE]
====
Volledig wissen (`-blank=full`) neemt ongeveer één uur in beslag op een 1x-medium. Het is mogelijk om snel te wissen door gebruik te maken van de optie `blank` als de DVD-RW in Disk-At-Once-modus (DAO) wordt opgenomen. Om de DVD-RW in DAO-modus te branden:

[source,bash]
....
# growisofs -use-the-force-luke=dao -Z /dev/cd0=beeldbestand.iso
....

De optie `-use-the-force-luke=dao` is niet nodig aangezien man:growisofs[1] probeert om minimale (snel gewiste) media te detecteren en gebruik te maken van DAO-schrijven.

Eigenlijk moet beperkt overschrijven gebruikt worden met elke DVD-RW. Dit formaat is flexibeler dan het standaard incrementeel sequentiële.
====

Om gegevens op een sequentiële DVD-RW te schrijven, worden dezelfde instructies gebruikt als voor de andere DVD-formaten:

[source,bash]
....
# growisofs -Z /dev/cd0 -J -R /pad/naar/gegevens
....

Om wat gegevens aan de vorige opname toe te voegen, dient de optie `-M` van man:growisofs[1] gebruikt te worden. Als echter gegevens aan een DVD-RW in incrementeel sequentiële modus worden toegevoegd, wordt een nieuwe sessie op de schijf aangemaakt wat resulteert in een multisessie schijf.

Een DVD-RW in het beperkt overschrijven formaat hoeft niet gewist te worden vóór een nieuwe initiële sessie. Het is voldoende om de schijf te overschrijven met de optie `-Z`, wat analoog is aan het geval van de DVD+RW. Het is ook mogelijk om een bestaand ISO 9660-bestandssysteem te laten groeien op soortgelijke wijze als voor een DVD+RW met de optie `-M`. Het resultaat is een enkelsessie DVD.

Om een DVD-RW in het beperkt overschrijven-formaat te zetten:

[source,bash]
....
# dvd+rw-format /dev/cd0
....

Om terug te gaan naar het sequentiële formaat:

[source,bash]
....
# dvd+rw-format -blank=full /dev/cd0
....

=== Multisessie

Multisessie DVD's worden door zeer weinig DVD-ROM-stations geaccepteerd en meestal lezen ze hopelijk tenminste de eerste sessie. DVD+R, DVD-R en DVD-RW kunnen in het sequentiële formaat meerdere sessies accepteren. Het idee van meerdere sessies bestaat niet voor de formaten DVD+RW en DVD-RW in beperkt overschrijven.

Om een nieuwe sessie achter een initiële (niet-gesloten) sessie op een DVD+R, DVD-R of DVD-RW in sequentieel formaat toe te voegen:

[source,bash]
....
# growisofs -M /dev/cd0 -J -R /pad/naar/volgende gegevens
....

Het gebruik van dit commando met een DVD+RW of een DVD-RW in beperkt overschrijven-formaat voegt gegevens toe door de nieuwe sessie samen te voegen met de bestaande. Dit leidt tot een enkelsessie schijf. Deze manier kan gebruikt worden om gegevens achter een initiële sessie aan deze media toe te voegen.

[NOTE]
====
Op deze media wordt wat ruimte gebruikt tussen elke sessie om het einde en begin van de sessies aan te geven. Daarom dienen sessies met grote hoeveelheden gegevens toegevoegd te worden om de mediaruimte te optimaliseren. Het aantal sessies is beperkt tot 154 voor een DVD+R, ongeveer 2000 voor een DVD-R en 127 voor een dubbellaags DVD+R.
====

=== Meer informatie

Om meer informatie over een DVD te verkrijgen kan het commando `dvd+rw-mediainfo /dev/cd0` met de schijf in het station gebruikt worden.

Meer informatie over dvd+rw-tools staat in de hulppagina man:growisofs[1], op de http://fy.chalmers.se/~appro/linux/DVD+RW/[dvd+rw-tools website] en in de archieven van de http://lists.debian.org/cdwrite/[cdwrite mailing list].

[NOTE]
====
De uitvoer van `dvd+rw-mediainfo` met betrekking tot de resulterende opname of het medium met problemen is verplicht voor elk probleemrapport. Zonder deze uitvoer volgt geen hulp.
====

[[creating-dvd-ram]]
=== DVD-RAM gebruiken

==== Configuratie

DVD-RAM schrijvers komen met of een SCSI of een ATAPI interface. DMA toegang voor ATAPI apparaten moet worden ingeschakeld, wat gedaan kan worden door de volgende regel toe te voegen aan [.filename]#/boot/loader.conf#:

[.programlisting]
....
hw.ata.atapi_dma="1"
....

==== Voorbereiden van het medium

Zoals vermeld in de introductie van dit hoofdstuk kan DVD-RAM gezien worden als een verwijderbare harde schijf. Zoals elke andere harde schijf moet de DVD-RAM "voorbereid" worden voor het eerste gebruik. In het voorbeeld wordt alle beschikbare ruimte gebruikt voor een standaard UFS2 bestandssysteem:

[source,bash]
....
# dd if=/dev/zero of=/dev/acd0 bs=2k count=1
# bsdlabel -Bw acd0
# newfs /dev/acd0
....

Het DVD apparaat, [.filename]#acd0# moet worden gewijzigd naar gelang de configuratie.

==== Het medium gebruiken

Zodra de voorgaande operaties uitgevoerd zijn op de DVD-RAM kan het gekoppeld worden net als een normale harde schijf:

[source,bash]
....
# mount /dev/acd0 /mnt
....

Hierna zal de DVD-RAM zowel lees- als beschrijfbaar zijn.

[[floppies]]
== Diskettes aanmaken en gebruiken

Soms is het opslaan van gegevens op een diskette nuttig, bijvoorbeeld als er geen andere verwijderbare opslagmedia beschikbaar zijn of als kleine hoeveelheden gegevens naar een andere computer moeten worden overgedragen.

In deze sectie wordt beschreven hoe diskettes in FreeBSD gebruikt dienen te worden. Hier worden hoofdzakelijk het formatteren en gebruik van 3,5 inch DOS-diskettes behandeld, maar de concepten zijn vergelijkbaar voor andere disketteformaten.

=== Diskettes formatteren

==== Het apparaat

Diskettes worden benaderd door ingangen in [.filename]#/dev# net zoals andere apparaten. Om een rauwe floppy te benaderen gebruikt u [.filename]#/dev/fdN#.

==== Formatteren

Een diskette dient op laag niveau geformatteerd te worden voordat deze kan worden gebruikt. Dit wordt meestal door de fabrikant gedaan, maar formatteren is een goede manier om de integriteit van het medium te controleren. Hoewel het mogelijk is om grotere (of kleinere) schijfgroottes te forceren, zijn de meeste diskettes ontworpen voor 1440kB.

Een diskette kan op laag niveau geformatteerd worden met man:fdformat[1]. Dit gereedschap verwacht de apparaatnaam als parameter.

Op basis van eventuele foutmeldingen kan bepaald worden of een schijf goed of slecht is.

===== Formatteren van floppies

Voor het formatteren van de diskette dienen de apparaten [.filename]#/dev/fdN# gebruikt te worden. Nadat een 3,5 inch diskette in het station is gestoken:

[source,bash]
....
# /usr/sbin/fdformat -f 1440 /dev/fd0
....

=== Schijflabels

Nadat de diskette op laag niveau is geformatteerd, dient er schijflabel aan gekoppeld te worden. Dit schijflabel wordt later vernietigd, maar het systeem heeft het nodig om later de grootte en de geometrie van de schijf te bepalen.

Het nieuwe schijflabel neemt de gehele schijf over en bevat alle benodigde informatie over de geometrie van de diskette. De geometriewaarden van het schijflabel staan vermeld in [.filename]#/etc/disktab#.

Nu kan man:bsdlabel[8] als volgt gedraaid worden:

[source,bash]
....
# /sbin/bsdlabel -B -w /dev/fd0 fd1440
....

=== Bestandssystemen

Nu is de diskette klaar om op hoog niveau geformatteerd te worden. Hiermee wordt een nieuw bestandssysteem opgezet, wat FreeBSD in staat stelt om naar de schijf te lezen en te schrijven. Nadat het nieuwe bestandssysteem is aangemaakt, wordt het schijflabel vernietigd, dus om de schijf te herformatteren is het noodzakelijk om het schijflabel opnieuw aan te maken.

Het bestandssysteem voor diskettes kan zowel UFS als FAT zijn. FAT is over het algemeen een betere keuze voor diskettes.

Om een nieuw bestandssysteem op de diskettes te zetten:

[source,bash]
....
# /sbin/newfs_msdos /dev/fd0
....

De schijf is nu klaar voor gebruik.

=== Diskettes gebruiken

Om de diskette te gebruiken kan man:mount_msdosfs[8] gebruikt worden om het medium aan te koppelen. Ook kan package:emulators/mtools[] uit de Portscollectie worden gebruikt.

[[backups-tapebackups]]
== Gegevensbanden aanmaken en gebruiken

Bandtechnologie is zich blijven ontwikkelen maar het is minder waarschijnlijk dat het in moderne systemen wordt gebruikt. Moderne back-upsystemen neigen om offsite gecombineerd met technologieën voor plaatselijke verwisselbare schijfstations te gebruiken. FreeBSD zal nog steeds elk bandstation dat SCSI gebruikt zoals LTO en oudere apparaten zoals DAT ondersteunen. Er is ook beperkte ondersteuning voor SATA- en USB-bandstations.

[[tapes-sa0]]
=== Seriële toegang met man:sa[4]

FreeBSD gebruikt het stuurprogramma man:sa[4], dat [.filename]#/dev/sa0#, [.filename]#/dev/nsa0# en [.filename]#/dev/esa0# aanbiedt. Voor normaal gebruik is alleen [.filename]#/dev/sa0# nodig. [.filename]#/dev/nsa0# is fysiek hetzelfde apparaat als [.filename]#/dev/sa0# maar spoelt de band niet terug nadat een bestand is geschreven. Dit maakt het mogelijk om meer dan één bestand naar een band te schrijven. [.filename]#/dev/esa0# werpt, indien van toepassing, de band uit nadat het apparaat is gesloten.

=== Het bandstation met man:mt[1] beheren

man:mt[1] is het hulpmiddel van FreeBSD om andere bewerkingen op het bandstation uit te voeren, zoals bestanden op een band doorzoeken of controlepunten naar de band schrijven.

Als voorbeeld kunnen de eerste drie bestanden op een band bewaard worden door ze over te slaan voordat een nieuw bestand wordt geschreven:

[source,bash]
....
# mt -f /dev/nsa0 fsf 3
....

=== man:tar[1] gebruiken om back-ups op banden te lezen en schrijven

man:tar[1] gebruiken om een enkel bestand naar band te schrijven:

[source,bash]
....
# tar cvf /dev/sa0 bestand
....

Bestanden vanuit een man:tar[1]-archief op band naar de huidige map herstellen:

[source,bash]
....
# tar xvf /dev/sa0
....

=== man:dump[8] en man:restore[8] gebruiken om back-ups aan te maken en te herstellen

Een eenvoudige back-up van [.filename]#/usr# maken met man:dump[8]:

[source,bash]
....
# dump -0aL -b64 -f /dev/nsa0 /usr
....

Interactief bestanden van een man:dump[8]-bestand vanaf band naar de huidige map herstellen:

[source,bash]
....
# restore -i -f /dev/nsa0
....

=== Andere bandsoftware

Er zijn programma's op hoger niveau beschikbaar om het back-uppen naar banden eenvoudiger te maken. De populairste zijn AMANDA en Bacula. Deze programma's hebben als doel om back-uppen eenvoudiger en aangenamer te maken, of om complexe back-ups van meerdere machines te automatiseren. De Portscollectie bevat deze beide en andere toepassingen om met banden te werken.

[[backups-floppybackups]]
== Naar diskettes back-uppen

[[floppies-using]]
=== Kunnen diskettes gebruikt worden om gegevens te back-uppen?

Diskettes zijn niet bepaald een geschikt medium om back-ups mee te maken, omdat:

* Het medium onbetrouwbaar is, in het bijzonder op de langere termijn;
* Het back-uppen en terugzetten erg traag is;
* Diskettes een zeer beperkte capaciteit hebben. De tijden dat een hele harde schijf naar een tiental diskettes kon worden geback-upped zijn allang verstreken.

Maar als er geen andere manier beschikbaar is om de gegevens te back-uppen, is een back-up naar diskettes beter dan helemaal geen back-up.

Gebruikte diskettes moet van goede kwaliteit zijn. Diskettes die al jaren op kantoor rondgeslingerd hebben, zijn een slechte keuze. In het ideale geval dienen nieuwe diskettes van een reputabele fabrikant gebruikt te worden.

[[floppies-creating]]
=== Hoe de gegevens naar diskettes back-uppen?

Het beste kan naar diskettes worden geback-upped door gebruik te maken van man:tar[1] met de optie `-M` (meerdere volumes), die back-ups over meerdere diskettes ondersteunt.

Om alle bestanden in de huidige map en de submappen te back-uppen (als `root`):

[source,bash]
....
# tar Mcvf /dev/fd0 *
....

Als de eerste diskette vol is, vraagt man:tar[1] om het volgende volume. Omdat man:tar[1] media-onafhankelijk is, refereert het aan volumes, in deze context diskettes.

[source,bash]
....
Prepare volume #2 for /dev/fd0 and hit return:
....

Dit wordt herhaald (met oplopend volumenummer) totdat alle gespecificeerde bestanden zijn geback-upped.

[[floppies-compress]]
=== Kunnen back-ups gecomprimeerd worden?

Helaas staat man:tar[1] het gebruik van de optie `-z` niet toe voor archieven over meerdere volumes. Het is uiteraard mogelijk om alle bestanden met man:gzip[1] te comprimeren, ze met man:tar[1] op diskettes te zetten en ze daarna met man:gunzip[1] weer te decomprimeren!

[[floppies-restoring]]
=== Hoe worden de back-ups teruggezet?

Om een volledige archief terug te zetten:

[source,bash]
....
# tar Mxvf /dev/fd0
....

Er zijn twee manieren om alleen specifieke bestanden terug te zetten. Ten eerste kan met de eerste diskette begonnen worden:

[source,bash]
....
# tar Mxvf /dev/fd0 bestandsnaam
....

Het programma man:tar[1] vraagt om de vervolgdiskettes totdat het benodigde bestand is gevonden.

Als alternatief kan, als bekend is op welke diskette het bestand staat, de betreffende diskette worden ingestoken en bovenstaand commando gebruikt worden. Als het eerste bestand op de diskette een vervolg is van de vorige diskette, waarschuwt man:tar[1] dat het bestand niet teruggezet kan worden, zelfs als hier niet om gevraagd is!

[[backup-strategies]]
== Back-up strategieën

Het eerste wat nodig is voor het ontwepken van een back-upplan, is er voor te zorgen dat de volgende mogelijke problemen worden ondervangen:

* Schijffalen
* Per ongeluk verwijderde bestanden
* Willekeurige bestandscorruptie
* Complete machinevernietiging (door bijvoorbeeld brand), inclusief de vernietiging van lokaal beschikbare back-ups.

Het is goed mogelijk dat een aantal systemen het best geholpen zijn door voor al deze problemen een andere techniek te gebruiken. Behalve voor volledig persoonlijke systemen met niet echt belangrijke gegevens, is het zelfs onwaarschijnlijk dat één techniek alle mogelijke problemen kan afvangen.

Een aantal technieken in de gereedschapskist zijn:

* Archiveren van een heel systeem op een back-up die niet lokaal wordt bewaard. Dit biedt bescherming tegen alle hierboven beschreven problemen, maar het is langzaam en onhandig om er een restore van te maken. Het is mogelijk om lokaal een kopie aan te houden en/of online, maar dan zijn er nog steeds onhandigheden, in het bijzonder voor restores voor gebruikers met beperkte rechten.
* Snapshots van bestandssystemen. Dit werkt eigenlijk alleen in het geval bestanden per ongelijk verwijderd worden, maar het kan in dat geval _erg_ handig zijn en het werkt snel en eenvoudig.
* Een kopie maken van hele bestandssystemen en/of schijven (bijvoorbeeld een periodieke man:rsync[1] van een hele machine). Dit is in het algemeen het meest bruikbaar in netwerken met specifieke eisen. Voor algemene bescherming tegen het falen van een schijf, is het meestal minder geschikt dan RAID. Voor het herstellen van per ongeluk verwijderde bestanden is het vergelijkbaar aan UFS snapshots, maar dat hangt af van persoonlijke voorkeuren.
* RAID. Minimaliseert of voorkomt downtijd als een schijf faalt. Dit ten koste van het vaker hebben van schijven die falen (omdat er meer van zijn), maar wel met een veel lagere urgentie.
* Controleren van fingerprints van bestanden. Het hulpprogramma man:mtree[8] kan hier bij helpen. Hoewel dit geen back-uptechniek is, zorgt het er wel voor dat kan worden opgemerkt wanneer back-ups geraadpleegd moeten worden. Dit is in het bijzonder belangrijk voor offline back-ups en de fingerprints horen periodiek gecontroleerd te worden.

Het is makkelijk om met nog meer technieken op de proppen te komen, waaronder veel variaties op de bovengenoemde. Bijzondere eisen leiden vaak tot bijzondere oplossingen. Het back-uppen van een draaiende database vereist bijvoorbeeld een methode die toegespitst is op de gebruikte database software als tussenstap. Het is van groot belang om te onderkennen tegen welke gevaren er bescherming dient te zijn en hoe daarmee om te gaan.

[[backup-basics]]
== Back-upbeginselen

De drie grote back-upprogramma's zijn man:dump[8], man:tar[1] en man:cpio[1].

=== Dump en Restore

De traditionele back-upprogramma's voor UNIX(R) zijn `dump` en `restore`. Deze zien het station als een verzameling van schijfblokken, onder de abstracties van bestanden, koppelingen en mappen die door de bestandssystemen worden aangemaakt. In tegenstelling tot andere back-upprogramma's, verzorgt `dump` een back-up van een compleet bestandssysteem op een apparaat. Het is niet in staat om slechts een gedeelte van een bestandssysteem of een mapstructuur die meer dan één bestandssysteem in beslag neemt te back-uppen. Het commando `dump` schrijft geen bestanden en mappen naar band, maar de rauwe gegevensblokken waaruit de bestanden en mappen bestaan. Wanneer het gebruikt wordt om gegevens te extraheren, slaat `restore` tijdelijke bestanden standaard op in [.filename]#/tmp/# - als u werkt vanaf een herstelschijf met een kleine map [.filename]#/tmp#, moet u wellicht de omgevingsvariabele `TMPDIR` op een map met meer vrije ruimte instellen zodat de restore kan slagen.

[NOTE]
====
Indien `dump` op een hoofdmap wordt gebruikt, wordt er geen back-up gemaakt van [.filename]#/home#, [.filename]#/usr# of van de vele andere mappen, aangezien dit typisch koppelpunten voor andere bestandssystemen of symbolische koppelingen binnen deze bestandssystemen zijn.
====

`dump` bevat eigenaardigheden die uit de begintijd in Versie 6 van AT&T UNIX(R) (circa 1975) zijn overgebleven. De standaardparameters zijn geschikt voor banden met 9 sporen (6.250 bpi), niet voor de media met hoge dichtheid die vandaag beschikbaar zijn (tot 62.182 ftpi). Deze standaardwaarden dienen op de opdrachtregel overschreven te worden om de capaciteit van de huidige bandstations te benutten.

Het is ook mogelijk om gegevens met `rdump` en `rrestore` over een netwerk naar een bandstation dat aan een andere computer gekoppeld is te back-uppen. Beide programma's maken gebruik van man:rcmd[3] en man:ruserok[3] om toegang tot het bandstation op afstand te krijgen. De gebruiker die de back-up uitvoert moet vermeld staat in het bestand [.filename]#.rhosts# op de computer op afstand. De argumenten die aan `rdump` en `rrestore` gegeven worden dienen geschikt te zijn voor gebruik op de computer op afstand. Als `rdump` gebruikt wordt om een dump te maken van een FreeBSD computer naar een Exabyte-bandstation dat met een Sun-computer genaamd `komodo` verbonden is:

[source,bash]
....
# /sbin/rdump 0dsbfu 54000 13000 126 komodo:/dev/nsa8 /dev/da0a 2>&1
....

Let op: er kleven veiligheidsbezwaren aan het toestaan van authenticatie met [.filename]#.rhosts#. De situatie dient goed geëvalueerd te worden.

Het is ook mogelijk om `dump` en `restore` op een veiligere manier via `ssh` te gebruiken.

.Het gebruik van `dump` via ssh
[example]
====

[source,bash]
....
# /sbin/dump -0uan -f - /usr | gzip -2 | ssh -c blowfish \
	  doelgebruiker@doelmachine.example.com dd of=/mijngrotebestanden/dump-usr-10.gz
....

====

Ook kan de ingebouwde manier van `dump` gebruikt worden, door de omgevingsvariabele `RSH` in te stellen:

.Het gebruik van `dump` via ssh met ingestelde `RSH`
[example]
====

[source,bash]
....
# env RSH=/usr/bin/ssh /sbin/dump -0uan -f doelgebruiker@doelmachine.example.com:/dev/sa0 /usr
....

====

=== `tar`

man:tar[1] stamt ook uit de tijd van Versie 6 van AT&T UNIX(R) (circa 1975). Het werkt samen met het bestandssysteem. `tar` schrijft bestanden en mappen naar band en ondersteunt niet het volledige scala aan opties dat beschikbaar is met man:cpio[1], maar `tar` heeft niet de ongebruikelijke opdrachtpijplijn nodig die `cpio` gebruikt.

Om `tar` toe te passen op een Exabyte-bandstation die met een Sun genaamd `komodo` verbonden is:

[source,bash]
....
# tar cf - . | rsh komodo dd of=tape-device obs=20b
....

Indien de veiligheid van back-uppen over een netwerk een punt is, dient gebruik te worden gemaakt van het commando `ssh` en niet van `rsh`.

=== `cpio`

man:cpio[1] is het originele UNIX(R) bandprogramma voor magnetische media om bestanden uit te wisselen. `cpio` heeft opties (naast vele anderen) om byte-swapping uit te voeren, een aantal verschillende archiefformaten te schrijven en de gegevens over een pijplijn naar andere programma's te voeren. Deze laatste optie maakt `cpio` een uitstekende keuze voor installatiemedia. `cpio` weet niet hoe het door een mapstructuur moet lopen. Er dient een lijst met bestanden door [.filename]#stdin# aangeleverd te worden.

`cpio` biedt geen ondersteuning voor back-ups over het netwerk. Er kan gebruik worden gemaakt van een pijplijn en `rsh` om de gegevens naar een banddrive op afstand te sturen.

[source,bash]
....
# for f in maplijst;  do
find $f >> back-up.lijst
done
# cpio -v -o --format=newc < back-up.lijst | ssh gebruiker@host "cat > back-upapparaat"
....

Hier is _maplijst_ een lijst van de mappen waarvan een back-up gemaakt dient te worden, _gebruiker_@_host_ de gebruiker/hostnaam-combinatie die de back-ups uitvoert, en _back-upapparaat_ het apparaat waar de back-ups naar toe geschreven te worden (bijvoorbeeld [.filename]#/dev/nsa0#).

=== `pax`

man:pax[1] is het antwoord van IEEE en POSIX(R) op `tar` en `cpio`. In de loop der jaren zijn de verscheidene versies van `tar` en `cpio` licht incompatibel geworden. Dus in plaats van dit uit te vechten en ze volledig te standaardiseren, heeft POSIX(R) een nieuw archiveringsprogramma gemaakt. `pax` poogt om veel van de verscheidene formaten van `cpio` en `tar` te lezen en te schrijven, met daarbij nog nieuwe, eigen formaten. De commandoverzameling lijkt meer op die van `cpio` dan op die van `tar`.

[[backups-programs-amanda]]
=== Amanda

Amanda (Advanced Maryland Network Disk Archiver) is een client/server-back-upsysteem, in plaats van een enkel programma. Een Amanda server back-upt elk aantal computers dat een Amanda client en een netwerkverbinding met de Amanda server heeft naar een enkel bandstation. Een veelvoorkomend probleem bij bedrijven met een groot aantal schijven is dat de tijd die nodig is om de gegevens direct naar band te back-uppen langer is dan de tijd die voor de taak gereserveerd is. Amanda lost dit probleem op. Amanda kan gebruik maken van een "tussenschijf" om verschillende bestandssystemen tegelijkertijd te back-uppen. Amanda maakt "archiefverzamelingen" aan, een groep banden die gedurende een tijd gebruikt wordt om volledige back-ups te maken van alle bestandssystemen die in het instellingenbestand van Amanda vermeld staan. De "archiefverzameling" bevat ook incrementele (of differentiële) back-ups van alle bestandssystemen. Voor het herstellen van een beschadigd bestandssysteem zijn de meest recente volledige back-up en de incrementele back-ups nodig.

Het instellingenbestand biedt verfijnde controle over de back-ups en het netwerkverkeer door Amanda. Amanda kan elk bovenstaand back-upprogramma gebruiken om de gegevens naar de band te schijven. Amanda is òf als port òf als package beschikbaar.

=== Nietsdoen

"Nietsdoen" is geen computerprogramma, maar de de meest gebruikte back-upstrategie. Er zijn geen initiële kosten. Er is geen back-upschema om te volgen. Zeg gewoon nee. Als er iets met gegevens gebeurt, lach erom en leef ermee!

Als tijd en gegevens weinig tot niets waard zijn, is "Nietsdoen" het meest geschikte back-upprogramma. Maar wees bedacht, UNIX(R) is een nuttig stuk gereedschap en er is zo maar binnen zes maanden een verzameling bestanden die wèl van waarde is.

"Nietsdoen" is de juiste back-upmethode voor [.filename]#/usr/obj# en andere mapstructuren die zo opnieuw aangemaakt kunnen worden. Een voorbeeld zijn de bestanden waaruit de HTML- of PostScript(R) versie van dit Handboek bestaan. Deze documentformaten zijn vanuit XML-invoerbestanden aangemaakt. Het back-uppen van de HTML- of PostScript(R) bestanden is niet nodig. Van de XML-bestanden dient regelmatig een back-up gemaakt te worden.

=== Welk back-upprogramma is het beste?

man:dump[8]. _Punt uit._. Elizabeth D. Zwicky heeft stresstesten op alle hierboven besproken back-upprogramma's uitgevoerd. De heldere keuze voor het behouden van alle gegevens en alle eigenaardigheden van UNIX(R) bestandssystemen is `dump`. Elizabeth heeft bestandssystemen aangemaakt met een grote verscheidenheid aan ongewone omstandigheden (en enkele minder ongebruikelijke) en heeft elk programma getest door een back-up van die bestandssystemen uit te voeren en ze te herstellen. De eigenaardigheden omvatten bestanden met gaten, bestanden met gaten en een blok nullen, bestanden met vreemde tekens in hun namen, onleesbare en onschrijfbare bestanden, apparaten, bestanden waarvan de grootte verandert tijdens het back-uppen, bestanden die aangemaakt/verwijderd worden tijdens het back-uppen en meer. Ze presenteerde de resultaten op LISA V in oktober 1991. Zie http://www.coredumps.de/doc/dump/zwicky/testdump.doc.html[torture-testing Backup and Archive Programs].

=== Noodterugzetprocedure

==== Vóór de ramp

Er zijn slechts vier stappen om te volgen bij het voorbereiden op elke ramp die voor kan komen.

Het schijflabel van elke schijf dient afgedrukt te worden (bijvoorbeeld met `bsdlabel da0 | lpr`), de bestandssysteemtabel ([.filename]#/etc/fstab#) en alle opstartboodschappen, alles in tweevoud.

Ten tweede dient een "livefs" CD-ROM gebrandt te worden. Deze CD-ROM biedt ondersteuning voor het opstarten in een FreeBSD "livefs" reddingsmodus die gebruiker in staat stelt om vele taken uit te voeren zoals het draaien van man:dump[8], man:restore[8], man:fdisk[8], man:bsdlabel[8], man:newfs[8] en meer. Een livefs CD-beeld voor FreeBSD/i386 {rel112-current}-RELEASE is beschikbaar op link:ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/ISO-IMAGES/{rel112-current}/FreeBSD-{rel112-current}-RELEASE-i386-livefs.iso[ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/ISO-IMAGES/{rel112-current}/FreeBSD-{rel112-current}-RELEASE-i386-livefs.iso].

[NOTE]
====
Livefs CD-beelden zijn niet beschikbaar voor FreeBSD {rel120-current}-RELEASE en nieuwer. Naast de beelden voor CDROM-installaties kunnen ook beelden voor flash-drive-installaties gebruikt worden om een systeem te redden. Het "memstick"-beelden voor FreeBSD/i386 {rel120-current}-RELEASE is beschikbaar op link:ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/i386/ISO-IMAGES/{rel120-current}/FreeBSD-{rel120-current}-RELEASE-i386-memstick.img[ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/i386/ISO-IMAGES/{rel120-current}/FreeBSD-{rel120-current}-RELEASE-i386-memstick.img].
====

Ten derde dienen regelmatig back-upbanden aangemaakt te worden. Alle veranderingen die na de laatste back-up zijn gemaakt kunnen onherroepelijk verloren zijn gegaan. De back-upbanden dienen beveiligd te worden tegen overschrijven.

Ten vierde dienen de "livefs" CD-ROM die in stap twee gemaakt is en de back-upbanden getest te worden. Van de handelingen dienen aantekeningen gemaakt te worden. De aantekeningen, de CD-ROM, de afdrukken en de back-upbanden dienen gezamenlijk bewaard te worden. Tijdens het herstellen kunnen de notities ervoor zorgen dat de back-upbanden vernietigd worden. Hoe? In plaats van `tar xvf /dev/sa0` kan per ongeluk `tar cvf /dev/sa0` worden ingetypt, waardoor de back-upband overschreven wordt.

Als extra veiligheidsmaatregel dienen telkens een "livefs" CD-ROM en twee back-upbanden gemaakt te worden. Eén van deze banden dient op een plaats op afstand bewaard te worden. Zo'n plaats is NIET de kelder van het zelfde kantoorgebouw. Een aantal bedrijven in het World Trade Center heeft deze les op de harde manier geleerd. Zo'n plaats dient fysiek gescheiden te zijn van de computers en de schijven door een significante afstand.

==== Na de ramp

De hamvraag is: heeft de hardware het overleefd? Er zijn regelmatig back-ups gemaakt, dus zorgen over de software zijn niet nodig.

Indien hardware beschadigd is, dienen kapotte onderdelen vervangen te worden voordat gepoogd wordt om een computer te gebruiken.

Plaats de "livefs" CD-ROM in de CD-ROM drive indien de hardware in orde is en start de computer op. Het originele installatiemenu wordt op het scherm getoond. Kies het land van toepassing en kies daarna [.guimenuitem]#Fixit -- Repair mode with CDROM/DVD/floppy# en kies het item [.guimenuitem]#CDROM/DVD -- Use the live filesystem CDROM/DVD#. `restore` en de andere benodigde programma's staan in [.filename]#/mnt2/rescue#.

Herstel elk bestandssysteem apart.

Probeer de rootpartitie van de eerste schijf aan te koppelen (bijvoorbeeld `mount /dev/da0a /mnt`). Als het schijflabel beschadigd is, gebruik dan `bsdlabel` om de schijf opnieuw te partitioneren en te labelen zodat deze overeenkomt met het afgedrukte en bewaarde label. Gebruik voor het opnieuw aanmaken van de bestandssystemen `newfs`. Koppel de rootpartitie van de schijf opnieuw aan voor lezen en schrijven (`mount -u -o rw /mnt`). Gebruik voor het herstellen van de gegevens van dit bestandssysteem het back-upprogramma en de back-upbanden (bijvoorbeeld `restore vrf /dev/sa0`). Koppel nu het bestandssysteem af (bijvoorbeeld `umount /mnt`). Herhaal dit voor elk beschadigd bestandssysteem.

Back-up de gegevens naar nieuwe banden als het systeem weer draait. De omstandigheden die verantwoordelijk waren voor de crash of het gegevensverlies kunnen weer voorkomen. Nu een extra uur investeren, kan later grote zorgen besparen.

[[disks-virtual]]
== Netwerk-, geheugen-, en bestandsgebaseerde bestandssystemen

Naast de schijven die fysiek in de computer zitten, diskettes, CD's, harde schijven, enzovoort, worden er ook andere vormen van schijven door FreeBSD begrepen: de _virtuele schijven_.

Dit omvat netwerkbestandssystemen zoals het crossref:network-servers[network-nfs,Network File System] en Coda, geheugengebaseerde bestandssystemen en bestandsgebaseerde bestandssystemen.

Nagelang de gebruikte versie van FreeBSD, zijn er andere gereedschappen voor het aanmaken en gebruiken van bestandsgebaseerde en geheugengebaseerde bestandssystemen.

[NOTE]
====
Gebruik man:devfs[8] om de apparaatnodes transparant voor de gebruiker toe te wijzen.
====

[[disks-mdconfig]]
=== Bestandsgebaseerd bestandssysteem

Met man:mdconfig[8] kunnen geheugenschijven, man:md[4], ingesteld worden en aangezet worden. Om man:mdconfig[8] te gebruiken, moet de module man:md[4] geladen worden of ondersteuning aan het kernelinstellingenbestand toegevoegd worden:

[.programlisting]
....
device md
....

Het commando man:mdconfig[8] ondersteunt drie types geheugen-gebaseerde virtuele schijven: geheugenschijven die met man:malloc[9] toegewezen zijn, geheugenschijven die een bestand als basis gebruiken en geheugenschijven die swapruimte als basis gebruiken. Een mogelijk gebruik is het aankoppelen van een beeld van een diskette of CD dat in een bestand bewaard wordt.

Om een bestaand beeld van een bestandssysteem aan te koppelen:

.`mdconfig` gebruiken om een bestaand beeld van een bestandssysteem aan te koppelen
[example]
====

[source,bash]
....
# mdconfig -a -t vnode -f schijfbeeld -u 0
# mount /dev/md0 /mnt
....

====

Om een nieuw beeld van een bestandssysteem aan te maken met man:mdconfig[8]:

.Nieuwe bestandsgebaseerde schijf aanmaken met `mdconfig`
[example]
====

[source,bash]
....
# dd if=/dev/zero of=nieuwbeeld bs=1k count=5k
5120+0 records in
5120+0 records out
# mdconfig -a -t vnode -f nieuwbeeld -u 0
# bsdlabel -w md0 auto
# newfs md0a
/dev/md0a: 5.0MB (10240 sectors) block size 16384, fragment size 2048
	using 4 cylinder groups of 1.25MB, 80 blks, 192 inodes.
super-block backups (for fsck -b #) at:
 160, 2720, 5280, 7840
# mount /dev/md0a /mnt
# df /mnt
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md0a       4710    4  4330     0%    /mnt
....

====

Indien het eenheidsnummer niet met de optie `-u` gespecificeerd wordt, gebruikt man:mdconfig[8] de automatische toewijzing van man:md[4] om een ongebruikt apparaat te selecteren. De naam van het toegewezen apparaat wordt op stdout weergegeven als [.filename]#md4#. Meer details staan in de hulppagina van man:mdconfig[8].

Het commando man:mdconfig[8] is erg nuttig, hoewel het veel opdrachten vergt om een bestandsgebaseerd bestandssysteem aan te maken. FreeBSD wordt met man:mdmfs[8] geleverd. Dit programma stelt een man:md[4]-schijf in door gebruik te maken van man:mdconfig[8], zet er een bestandssysteem op door gebruik te maken van man:newfs[8] en koppel het aan door gebruik te maken van man:mount[8]. Om hetzelfde bestandssysteembeeld als hierboven aan te maken en aan te koppelen:

.Instellen en aankoppelen van een bestandsgebaseerde schijf met `mdmfs`
[example]
====

[source,bash]
....
# dd if=/dev/zero of=nieuwbeeld bs=1k count=5k
5120+0 records in
5120+0 records out
# mdmfs -F nieuwbeeld -s 5m md0 /mnt
# df /mnt
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md0        4718    4  4338     0%    /mnt
....

====

Als de optie `md` zonder eenheidsnummer gebruikt wordt, gebruikt man:mdmfs[8] de automatische toewijzing van man:md[4] om automatisch een ongebruikt apparaat te selecteren. Meer details staan in de hulppagina van man:mdmfs[8].

[[disks-md-freebsd5]]
=== Geheugengebaseerd bestandssysteem

Voor een geheugen gebaseerd bestands systeem moet normaal gesproken "wisselbestand geheugen" gebruikt worden. Gebruik maken van wisselbestand geheugen wil niet perse zeggen dat de geheugen schijf direct in het wisselbestand gezet wordt, maar dat het bestand naar het wisselbestand geschreven kan worden indien nodig. Het is ook mogelijk om man:malloc[9] gebaseerde geheugen schijven te maken, maar door hiervan gebruik te maken kan het gebeuren dat het systeem crashed als de kernel uit het geheugen loopt.

.Nieuwe geheugengebaseerde schijf aanmaken met `mdconfig`
[example]
====

[source,bash]
....
# mdconfig -a -t swap -s 5m -u 1
# newfs -U md1
/dev/md1: 5.0MB (10240 sectors) block size 16384, fragment size 2048
	using 4 cylinder groups of 1.27MB, 81 blks, 192 inodes.
	with soft updates
super-block backups (for fsck -b #) at:
 160, 2752, 5344, 7936
# mount /dev/md1 /mnt
# df /mnt
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md1        4718    4  4338     0%    /mnt
....

====

.Nieuwe geheugengebaseerde schijf aanmaken met `mdmfs`
[example]
====

[source,bash]
....
# mdmfs -s 5m md2 /mnt
# df /mnt
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md2        4846    2  4458     0%    /mnt
....

====

=== Geheugenschijf van het systeem afkoppelen

Als een geheugen- of bestandsgebaseerd bestandssysteem niet gebruikt wordt, dienen alle bronnen aan het systeem vrijgegeven te worden. Koppel als eerste het bestandssysteem af, gebruikt daarna man:mdconfig[8] om de schijf van een systeem los te koppelen en de bronnen vrij te geven.

Om bijvoorbeeld alle bronnen die door [.filename]#/dev/md4# gebruikt worden los te koppelen en vrij te geven:

[source,bash]
....
# mdconfig -d -u 4
....

Het is mogelijk om de informatie over ingestelde man:md[4] apparaten weer te geven door gebruik te maken van `mdconfig -l`.

[[snapshots]]
== Snapshots van bestandssystemen

FreeBSD biedt een mogelijkheid om samen met crossref:cutting-edge[soft-updates,Soft Updates]: snapshots van bestandssystemen.

Snapshots bieden de mogelijkheid om beelden van een gespecificeerd bestandssysteem te maken en ze als bestand te behandelen. Snapshotbestanden moeten aangemaakt worden in het bestandssysteem waarop de handeling wordt uitgevoerd en er mogen niet meer dan 20 snapshots per bestandssysteem worden aangemaakt. Actieve snapshots worden opgeslagen in het superblok zodat ze persistent zijn met afkoppel- en heraankoppelbewerkingen en met het opnieuw opstarten van het systeem. Als een snapshot niet langer nodig is, kan het met het standaardcommando man:rm[1] worden verwijderd. Snapshots kunnen in elke volgorde verwijderd worden, alhoewel misschien niet alle gebruikte ruimte teruggewonnen wordt omdat sommige vrijgegeven blokken mogelijk door een ander snapshot geclaimd worden.

De onveranderlijke bestandsvlag `snapshot` wordt door man:mksnap_ffs[8] ingesteld nadat het snapshotbestand initieel is aangemaakt. Het commando man:unlink[1] maakt een uitzondering voor snapshotbestanden aangezien het toestaat dat ze verwijderd worden.

Snapshotbestanden worden aangemaakt met man:mount[8]. Om een snapshot van [.filename]#/var# in het bestand [.filename]#/var/snapshot/snap# te plaatsen:

[source,bash]
....
# mount -o -o snapshot /var/snapshot/snap /var
....

Als alternatief kan man:mksnap_ffs[8] gebruikt worden om een snapshot aan te maken:

[source,bash]
....
# mksnap_ffs /var /var/snapshot/snap
....

Snapshotbestanden kunnen gezocht worden op een bestandssysteem (bijvoorbeeld [.filename]#/var#) door gebruik te maken van het commando man:find[1]:

[source,bash]
....
# find /var -flags snapshot
....

Nadat een snapshot is aangemaakt, kan het voor een aantal dingen gebruikt worden:

* Sommige systeembeheerders gebruiken een snapshotbestand voor back-updoeleinden, omdat het snapshot naar CD's of band overgezet kan worden;
* De bestandssysteem integriteit controle, man:fsck[8] kan gebruikt worden op het snapshot. Ervan uitgaande dat het bestandssysteem schoon was toen het werd aangekoppeld, zou dit altijd een schoon (en onveranderlijk) resultaat moeten opleveren. Dit is in principe wat het man:fsck[8]-achtergrondsproces doet;
* Het commando man:dump[8] draaien op het snapshot. Er wordt een dump teruggegeven die consistent is met het bestandssysteem en tijdsstempel van het snapshot. man:dump[8] kan ook in één commando een snapshot maken, een dumpbeeld aanmaken en daarna het snapshot verwijderen door gebruik te maken van de vlag `-L`;
* Het snapshot kan met man:mount[8] als bevroren beeld van het bestandssysteem worden aangekoppeld. Om het snapshot [.filename]#/var/snapshot/snap# aan te koppelen:
+

[source,bash]
....
# mdconfig -a -t vnode -f /var/snapshot/snap -u 4
# mount -r /dev/md4 /mnt
....

Het is nu mogelijk om door de structuur van het bevroren bestandssysteem [.filename]#/var# te lopen dat aangekoppeld is op [.filename]#/mnt#. Alles zal initieel in dezelfde toestand verkeren als op het moment dat het snapshot werd aangemaakt. De enige uitzondering hierop is dat eerdere snapshots als bestanden met lengte nul verschijnen. Als een snapshot niet meer nodig is, kan het als volgt afgekoppeld worden:

[source,bash]
....
# umount /mnt
# mdconfig -d -u 4
....

Meer informatie over `softupdates` en snapshots van bestandssystemen, inclusief technische documenten, staat op de website van Marshall Kirk McKusick op http://www.mckusick.com/[http://www.mckusick.com/].

[[quotas]]
== Bestandssysteemquota

Quota zijn een optionele mogelijkheid van het besturingssysteem om de hoeveelheid schijfruimte en/of het aantal bestanden dat gebruikers of leden van een groep per bestandssysteem mogen gebruiken te beperken. Dit wordt het meeste gebruikt op timesharing-systemen waar het wenselijk is om het aantal bronnen dat elke gebruiker of groep van gebruikers mag gebruiken te beperken. Dit voorkomt dat één gebruiker of groep van gebruikers alle beschikbare schijfruimte in beslag neemt.

=== Schijfquota inschakelen

Controleer alvorens te proberen om schijfquota te gebruiken of quota ingesteld zijn in de kernel. Dit gebeurt door het toevoegen van de volgende regel aan het kernelinstellingenbestand:

[.programlisting]
....
options QUOTA
....

De standaardkernel [.filename]#GENERIC# heeft deze optie niet aanstaan, dus is het nodig om een eigen kernel in te stellen, te bouwen en te installeren om gebruik te kunnen maken van schijfquota. Meer informatie over het instellen van de kernel staat in crossref:kernelconfig[kernelconfig,De FreeBSD-kernel instellen].

Vervolgens dienen schijfquota aangezet te worden in [.filename]#/etc/rc.conf#. Op FreeBSD 7.X en eerder wordt deze regel toegevoegd:

[.programlisting]
....
enable_quotas="YES"
....

Voeg op FreeBSD 8.0-RELEASE en nieuwer in plaats daarvan deze regel toe:

[.programlisting]
....
quota_enable="YES"
....

Voor fijnere controle over de opstartquota zijn extra instellingsvariabelen beschikbaar. Normaalgesproken wordt de integriteit van de quota van elk bestandssysteem tijdens het opstarten door man:quotacheck[8] gecontroleerd. man:quotacheck[8] verzekert dat de gegevens in de quotadatabase een juiste afspiegeling vormen van de gegevens op het bestandssysteem. Dit proces neemt erg veel tijd in beslag en beïnvloedt de tijd die een systeem nodig heeft om op te starten significant. Om deze stap over te slaan, bestaat een variabele in [.filename]#/etc/rc.conf#:

[.programlisting]
....
check_quotas="NO"
....

Als laatste dient [.filename]#/etc/fstab# bewerkt te worden om schijfquota per bestandssysteem aan te zetten. Hier kunnen gebruiker- of groepquota of beide worden aangezet voor alle bestandssystemen.

Om quota per gebruiker op een bestandssysteem aan te zetten, dient de optie `userquota` aan het optieveld toegevoegd te worden aan de regel in [.filename]#/etc/fstab# voor het bestandssysteem waar quota worden aangezet. Bijvoorbeeld:

[.programlisting]
....
/dev/da1s2g   /home    ufs rw,userquota 1 2
....

Analoog, om groepquota aan te zetten, dient de optie `groupquota` in plaats van `userquota` gebruikt te worden. Om zowel gebruikers- als groepsquota aan te zetten, dient de regel als volgt veranderd te worden:

[.programlisting]
....
/dev/da1s2g   /home    ufs rw,userquota,groupquota 1 2
....

Standaard worden de quotabestanden opgeslagen in de hoofdmap van het bestandssysteem onder de namen [.filename]#quota.user# en [.filename]#quota.group# voor respectievelijk gebruikers- en groepsquota. Meer informatie staat in man:fstab[5]. Alhoewel de hulppagina man:fstab[5] vermeld dat een alternatieve plaats voor de quotabestanden gespecificeerd kan worden, wordt dit niet aangeraden omdat de verschillende quotagereedschappen dit niet juist schijnen af te handelen.

Hier aangekomen dient het systeem opnieuw opgestart te worden met de nieuwe kernel. [.filename]#/etc/rc# voert automatisch de juiste commando's uit om de initiële quotabestanden aan te maken voor alle quota die in [.filename]#/etc/fstab# zijn aangezet. Het is dus niet nodig om handmatig quotabestanden met lengte nul aan te maken.

Tijdens normale bewerkingen moet het niet nodig zijn om de commando's man:quotacheck[8], man:quotaon[8] of man:quotaoff[8] handmatig te draaien. Lees wel de betreffende hulppagina's om bekend te raken met de werking ervan.

=== Quotalimieten instellen

Indien het systeem ingesteld voor gebruik van quota, controleer dan of ze echt aanstaan. Een eenvoudige manier om dit te doen is de volgende:

[source,bash]
....
# quota -v
....

Er hoort een eenregelige samenvatting te verschijnen over het schijfgebruik en de huidige quotalimieten voor elk bestandssysteem waarop quota aanstaan.

Nu kunnen quotalimieten toegewezen worden met man:edquota[8].

Er zijn verschillende opties om grenzen te stellen aan de hoeveelheid schijfruimte die een gebruiker of groep mag toewijzen en het aantal bestanden dat ze mogen aanmaken. Toewijzingen kunnen begrensd worden met betrekking tot schijfruimte (blokquota) of het aantal bestanden (inode-quota) of een combinatie van beide. Elk van deze limieten is op zijn beurt weer opgesplitst in twee categoriën: harde en zachte limieten.

Een harde limiet mag niet overschreden worden. Indien een gebruiker de harde limiet bereikt, mag deze geen verdere toewijzingen maken op het betreffende bestandssysteem. Indien een gebruiker bijvoorbeeld een harde limiet heeft van 500 kB op een bestandssysteem en er 490 kB van gebruikt, kan deze nog slechts 10 kB toewijzen. Een poging om 11 kB toe te wijzen zal mislukken.

Zachte limieten kunnen voor een beperkte tijd overschreden worden. Deze periode staat bekend als de gratieperiode, die standaard een week bedraagt. Als een gebruiker de zachte limiet langer dan de gratieperiode overschrijdt, verandert de zachte limiet in een harde limiet en zijn er geen verdere toewijzingen toegestaan. Als de gebruiker onder de zachte limiet komt, wordt de gratieperiode opnieuw ingesteld.

Het volgende is een voorbeeld van een mogelijk gebruik van man:edquota[8]. Als het commando man:edquota[8] gestart wordt, wordt de tekstverwerker opgestart die door de omgevingsvariabele `EDITOR` gespecificeerd is, of de tekstverwerker vi als de variabele `EDITOR` niet is ingesteld. Nu kunnen de quotalimieten bewerkt worden.

[source,bash]
....
# edquota -u test
....

[.programlisting]
....
Quotas for user test:
/usr: kbytes in use: 65, limits (soft = 50, hard = 75)
        inodes in use: 7, limits (soft = 50, hard = 60)
/usr/var: kbytes in use: 0, limits (soft = 50, hard = 75)
        inodes in use: 0, limits (soft = 50, hard = 60)
....

Normaalgesproken worden er twee regels weergegeven voor elk bestandssysteem waarvoor quota gelden: één regel voor de bloklimieten, en één voor de inode-limieten. Om de quotalimieten te veranderen dient de waarde ervan veranderd te worden. Om bijvoorbeeld de bloklimiet van een gebruiker te veranderen van een zachte limiet van 50 en een harde limiet van 75 in een zachte limiet van 500 en een harde limiet van 600, dient het volgende veranderd te worden:

[.programlisting]
....
/usr: kbytes in use: 65, limits (soft = 50, hard = 75)
....

In:

[.programlisting]
....
/usr: kbytes in use: 65, limits (soft = 500, hard = 600)
....

De nieuwe quotalimieten gelden zodra de tekstverwerker verlaten wordt.

Soms is het gewenst om quotalimieten in te stellen op een aantal UID's. Dit kan gedaan worden door de optie `-p` van man:edquota[8] te gebruiken. Wijs eerst de gewenste quotalimiet aan een gebruiker toe en draai daarna `edquota -p protogebruiker beginuid-einduid`. Indien bijvoorbeeld gebruiker `test` de gewenste quotalimieten heeft, kan het volgende commando gebruikt worden om deze quotalimieten te dupliceren voor UID's 10.000 tot en met 19.999:

[source,bash]
....
# edquota -p test 10000-19999
....

Meer informatie staat in de hulppagina voor man:edquota[8].

=== Quotalimieten en schijfgebruik controleren

Zowel man:quota[1] als man:repquota[8] kunnen gebruikt worden om de quotalimieten en het schijfgebruik te controleren. Het commando man:quota[1] kan gebruikt worden om de quota van zowel individuele gebruikers als groepen en het schijfgebruik te controleren. Een gebruiker mag alleen de eigen quota en de quota van een groep waarvan deze lid is controleren. Alleen de beheerder mag alle gebruikers- en groepsquota bekijken. Het commando man:repquota[8] kan gebruikt worden om een overzicht te krijgen van alle quota en gebruik van bestandssystemen waarvan quota aanstaan.

Het volgende is een mogelijke uitvoer van het commando `quota -v` voor een gebruiker die quotalimieten heeft op twee bestandssystemen.

[.programlisting]
....
Disk quotas for user test (uid 1002):
     Filesystem  usage    quota   limit   grace   files   quota   limit   grace
           /usr      65*     50      75   5days       7      50      60
       /usr/var       0      50      75               0      50      60
....

Voor het bestandssysteem [.filename]#/usr# in bovenstaand voorbeeld overschrijdt deze gebruiker de zachte limiet van 50 kB momenteel met 15 kB en heeft deze 5 dagen van de gratieperiode over. De asterisk, `*` geeft aan dat de gebruiker momenteel de quotalimiet overschrijdt.

Normaalgesproken worden bestandssystemen waarvan de gebruiker geen schijfruimte gebruikt niet weergegeven in de uitvoer van man:quota[1], zelfs niet als er de gebruiker een quotalimiet heeft voor dat bestandssysteem. De optie `-v` geeft deze bestandssystemen weer, zoals het bestandssysteem [.filename]#/usr/var# in bovenstaand voorbeeld.

=== Quota over NFS

Quota worden afgedwongen door het quota-subsysteem op de NFS-server. De daemon man:rpc.rquotad[8] stelt quota-informatie beschikbaar aan het commando man:quota[1] op de NFS-cliënts, wat de gebruikers op deze machines in staat stelt hun quota-statistieken in te zien.

`rpc.rquotad` dient als volgt in [.filename]#/etc/inetd.conf# aangezet te worden:

[.programlisting]
....
rquotad/1      dgram rpc/udp wait root /usr/libexec/rpc.rquotad rpc.rquotad
....

Vervolgens dient `inetd` opnieuw gestart te worden:

[source,bash]
....
# service inetd restart
....

[[disks-encrypting]]
== Schijfpartities versleutelen

FreeBSD biedt uitstekende on-line bescherming tegen onbevoegde gegevenstoegang. Bestandsrechten en Mandatory Access Control (MAC) (zie crossref:mac[mac,Verplichte Toegangscontrole (MAC)]) helpen voorkomen dat onbevoegde derde partijen toegang tot de gegevens krijgen als het besturingssysteem actief is en de computer aanstaat. De door het besturingssysteem afgedwongen rechten zijn echter niet relevant als een aanvaller fysieke toegang tot een computer heeft en deze de harde schijf van de computer in een ander systeem kan plaatsen om de gevoelige gegevens te kopiëren en te analyseren.

Afgezien van hoe een aanvaller in het bezit van een harde schijf of een uitgezette computer gekomen is, kan GEOM Based Disk Encryption (gbde) de gegevens op het bestandssysteem van de computer zelfs tegen hooggemotiveerde aanvallers met aanzienlijke middelen beschermen. In tegenstelling tot lastige versleutelmethoden die alleen losse bestanden versleutelen, versleutelt gbde gehele bestandssystemen op een transparante manier. De harde schijf komt nooit in aanraking met klare tekst.

Los van hoe een aanvaller in het bezit van een harde schijf of een uitgezette computer gekomen is, kunnen de cryptografische subsystemen GEOM Based Disk Encryption (gbde) en `geli` in FreeBSD gegevens op bestandssystemen van een computer beschermen tegen zelfs de meer gemotiveerde belagers die ook nog eens adequate middelen hebben. Anders dan met lastige versleutelingsmethoden die alleen individuele bestanden versleutelen, versleutelen `gbde` en `geli` transparant complete bestandssystemen. Er komt nooit platte tekst op een harde schijf.

=== Schijven versleutelen met gbde

[.procedure]
====

. Word `root`
+ 
Het instellen van gbde vereist beheerdersrechten.
+
[source,bash]
....
% su -
Password:
....
+
. Voeg ondersteuning voor man:gbde[4] aan het kernelinstellingenbestand toe
+ 
Voeg de volgende regel toe aan het kernelinstellingenbestand:
+ 
`options GEOM_BDE`
+ 
Herbouw de kernel opnieuw zoals beschreven in crossref:kernelconfig[kernelconfig,De FreeBSD-kernel instellen].
+ 
Start op met de nieuwe kernel.
. Een alternatief voor het hercompileren van de kernel is door gebruik te maken van man:kldload[8] om man:gbde[4] te laden:
+
[source,bash]
....
# kldload geom_bde
....
====

==== Versleutelde harde schijf voorbereiden

In het volgende voorbeeld wordt aangenomen dat er een nieuwe harde schijf aan het systeem wordt toegevoegd die een enkele versleutelde partitie zal bevatten. Deze partitie wordt aangekoppeld als [.filename]#/private#. gbde kan ook gebruikt worden om [.filename]#/home# en [.filename]#/var/mail# te versleutelen, maar daarvoor zijn complexere instructies nodig die buiten het bereik van deze inleiding vallen.

[.procedure]
====

. Voeg een nieuwe harde schijf toe
+ 
Voeg de nieuwe harde schijf toe zoals beschreven in <<disks-adding>>. In dit voorbeeld is een nieuwe harde schijfpartitie toegevoegd als [.filename]#/dev/ad4s1c#. De apparaten [.filename]#/dev/ad0s1*# stellen bestaande standaard FreeBSD partities van het voorbeeldsysteem voor.
+
[source,bash]
....
# ls /dev/ad*
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4
....
+
. Maak een map aan voor gbde lockbestanden
+
[source,bash]
....
# mkdir /etc/gbde
....
+ 
Het lockbestand voor gbde bevat informatie die gbde nodig heeft om toegang te krijgen tot versleutelde partities. Zonder toegang tot de lockbestand is gbde niet in staat om de gegevens die op de versleutelde partitie staan te ontsleutelen zonder aanzienlijke handmatige tussenkomst die niet door de software ondersteund wordt. Elke versleutelde partitie gebruikt een ander lockbestand.
. Initialiseer de gbde-partitie
+ 
Een gbde-partitie dient geïnitialiseerd te worden voordat deze kan worden gebruikt. Deze initialisatie dient slechts eenmalig uitgevoerd te worden:
+
[source,bash]
....
# gbde init /dev/ad4s1c -i -L /etc/gbde/ad4s1c.lock
....
+ 
man:gbde[8] opent een tekstverwerker om verschillende instellingen in een sjabloon te kunnen instellen. Stel de sector_size in op 2048 als UFS of UFS2 wordt gebruikt:
+
[.programlisting]
....
# $FreeBSD: src/sbin/gbde/template.txt,v 1.1 2002/10/20 11:16:13 phk Exp $
#
# Sector size is the smallest unit of data which can be read or written.
# Making it too small decreases performance and decreases available space.
# Making it too large may prevent filesystems from working.  512 is the
# minimum and always safe.  For UFS, use the fragment size
#
sector_size	=	2048
[...]
....
+ 
man:gbde[8] vraagt twee keer om de wachtwoordzin voor het beveiligen van de gegevens. De wachtwoordzin dient beide keren hetzelfde te zijn. De mogelijkheid van gbde om de gegevens te beveiligen is geheel afhankelijk de gekozen wachtwoordzin. 
+ 
Het commando `gbde init` maakt een lockbestand aan voor de gbde-partitie die in dit voorbeeld is opgeslagen als [.filename]#/etc/gbde/ad4s1c.lock#. gdbde slotbestanden moeten eindigen op ".lock" om correct door het opstartscript [.filename]#/etc/rc.d/gbde# gedetecteerd te worden.
+
[CAUTION]
======

gbde lockbestanden _moeten_ samen met de inhoud van versleutelde partities geback-upped worden. Hoewel het verwijderen van een lockbestand op zich een gedreven aanvaller er niet van weerhoudt een gbde partitie te ontsleutelen, is de wettige eigenaar zonder het lockbestand niet in staat om de gegevens op de versleutelde partitie te benaderen zonder een aanzienlijke hoeveelheid werk die in het geheel niet ondersteund wordt door man:gbde[8] of de ontwerper ervan.
======
+
. Koppel de versleutelde partitie aan de kernel
+
[source,bash]
....
# gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c.lock
....
+ 
Er wordt om de wachtwoordzin gevraagd die gekozen is tijdens de initialisatie van de versleutelde partitie. Het nieuwe versleutelde apparaat verschijnt in [.filename]#/dev# als [.filename]#/dev/apparaatnaam.bde#:
+
[source,bash]
....
# ls /dev/ad*
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4        /dev/ad4s1c.bde
....
+
. Maak een bestandssysteem op het versleutelde apparaat
+ 
Nu het versleutelde apparaat aan de kernel gekoppeld is, kan een bestandssysteem op het apparaat aangemaakt worden. Met man:newfs[8] kan een bestandssysteem op het versleutelde apparaat aangemaakt wordne. Aangezien het veel sneller is om een nieuw UFS2 bestandssysteem te initialiseren dan om een oud UFS1 bestandssysteem te initialiseren, is het aan te raden om man:newfs[8] met de optie `-O2` te gebruiken.
+
[source,bash]
....
# newfs -U -O2 /dev/ad4s1c.bde
....
+
[NOTE]
======
Voer man:newfs[8] uit op een aangekoppelde gbde-partitie die geïndificeerd wordt door de uitbreiding [.filename]#*.bde# op de apparaatnaam.
======
+
. Mount de versleutelde partitie
+ 
Maak een koppelpunt voor het versleutelde bestandssysteem aan:
+
[source,bash]
....
# mkdir /private
....
+ 
Mount het versleutelde bestandssysteem:
+
[source,bash]
....
# mount /dev/ad4s1c.bde /private
....
+
. Controleer of het versleutelde bestandssysteem beschikbaar is
+ 
Het versleutelde bestandssysteem is nu zichtbaar met man:df[1] en gebruiksklaar:
+
[source,bash]
....
% df -H
Filesystem        Size   Used  Avail Capacity  Mounted on
/dev/ad0s1a      1037M    72M   883M     8%    /
/devfs            1.0K   1.0K     0B   100%    /dev
/dev/ad0s1f       8.1G    55K   7.5G     0%    /home
/dev/ad0s1e      1037M   1.1M   953M     0%    /tmp
/dev/ad0s1d       6.1G   1.9G   3.7G    35%    /usr
/dev/ad4s1c.bde   150G   4.1K   138G     0%    /private
....
====

==== Bestaande versleutelde bestandssystemen aankoppelen

Elke keer nadat het systeem is opgestart dient elk versleuteld bestandssysteem opnieuw aan de kernel gekoppeld te worden, op fouten gecontroleerd te worden, en aangekoppeld te worden voordat de bestandssystemen gebruikt kunnen worden. De benodigde commando's dienen als de gebruiker `root` uitgevoerd te worden.

[.procedure]
====

. Koppel de gbde-partitie aan de kernel
+
[source,bash]
....
# gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c.lock
....
+ 
Er wordt om de wachtwoordzin gevraagd die gekozen is tijdens de initialisatie van de versleutelde gbde-partitie.
. Controleer het bestandssysteem op fouten
+ 
Aangezien het nog niet mogelijk is om versleutelde bestandssystemen op te nemen in [.filename]#/etc/fstab# voor automatische controle, dienen de bestandssystemen voordat ze aangekoppeld worden handmatig op fouten gecontroleerd te worden door man:fsck[8] uit te voeren:
+
[source,bash]
....
# fsck -p -t ffs /dev/ad4s1c.bde
....
+
. Mount het versleutelde bestandssysteem
+
[source,bash]
....
# mount /dev/ad4s1c.bde /private
....
+ 
Het versleutelde bestandssysteem is nu klaar voor gebruik.
====

===== Versleutelde partities automatisch aankoppelen

Het is mogelijk om een script aan te maken om automatisch een versleutelde partitie aan te koppelen, op fouten te controleren en aan te koppelen, maar vanwege veiligheidsredenen dient het script niet het wachtwoord voor man:gbde[8] te bevatten. In plaats hiervan wordt het aangeraden om zulke scripts handmatig uit te voeren en het wachtwoord via de console of man:ssh[1] te geven.

Als alternatief, wordt er een [.filename]#rc.d# script bijgeleverd. De argumenten kunnen via man:rc.conf[5] doorgegeven worden. Bijvoorbeeld:

[.programlisting]
....
gbde_autoattach_all="YES"
gbde_devices="ad4s1c"
gbde_lockdir="/etc/gbde"
....

Hierdoor is het noodzakelijk dat de wachtwoordzin voor gbde bij het starten wordt ingegeven. Na het invoeren van de juiste wachtwoordzin wordt de met gbde versleutelde partitie automatisch aangekoppeld. Dit kan erg handig zijn bij het gebruik van gbde op notebooks.

==== Door gbde gebruikte cryptografische beschermingen

man:gbde[8] versleutelt de sectorlading door gebruik te maken van 128-bit AES in CBC-modus. Elke sector op de schijf wordt met een andere AES-sleutel versleuteld. Meer informatie over het cryptografische ontwerp van gbde, inclusief de methode die gebruikt wordt om de sectorsleutels van de door de gebruiker gegeven wachtwoordzin af te leiden, staan in man:gbde[4].

==== Compatibiliteitspunten

man:sysinstall[8] is niet compatibel met apparaten die met gbde versleuteld zijn. Alle [.filename]#*.bde# apparaten moeten van de kernel ontkoppeld worden voordat man:sysinstall[8] gebruikt wordt om te voorkomen dat het crasht tijdens het initiële zoeken naar apparaten. Om het versleutelde apparaat dat in dit voorbeeld gebruikt wordt te ontkoppelen:

[source,bash]
....
# gbde detach /dev/ad4s1c
....

=== Schijfversleuteling met `geli`

Een alternatieve cryptografische GEOM klassie is beschikbaar - `geli`. Deze wordt op het moment ontwikkeld door {pjd}. `geli` verschilt van `gbde` in de mogelijkheden en in het gebruik van een andere methode voor het versleutelen.

De meest belangrijke mogelijkheden van man:geli[8] zijn:

* Gebruikt het man:crypto[9] framework; als cryptografische hardware aanwezig is, gebruikt `geli` die automatisch;
* Ondersteunt meedere cryptografische algoritmen. Op dit moment AES, Blowfish en 3DES;
* Staat toe dat de root-partitie wordt versleuteld. De wachtwoordzin die wordt gebruikt om de root-partitie te versleutelen wordt opgevraagd tijdens het starten van een systeem;
* Staat het gebruik van twee onafhankelijke sleutels toe, bijvoorbeeld een "sleutel" en een "bedrijfssleutel");
* `geli` is snel; het werkt met sector-naar-sector versleuteling;
* Ondersteunt back-up en restore van Master Keys. Als een gebruiker sleutels moet vernietigen, is het mogelijk weer toegang te krijgen tot de gegevens door sleutels uit een back-up te halen;
* Ondersteunt het koppelen van een schijf met een willekeurige, eenmalige sleutel. Handig voor swap-partities en tijdelijke bestandssystemen.

Meer mogelijkheden van `geli` staan beschreven in de handleiding van man:geli[8].

De volgende stappen beschrijven hoe ondersteuning voor `geli` in de FreeBSD-kernel ingeschakeld kan worden en hoe een nieuwe `geli` versleutelingsvoorziening gemaakt kan worden.

Het is noodzakelijk super-user rechten te hebben omdat de kernel wordt aangepast.

[.procedure]
====

. Toevoegen van `geli`-ondersteuning
+ 
Voeg de volgende regels toe aan het bestand met kernelinstellingen:
+
[.programlisting]
....
options GEOM_ELI
device crypto
....
+ 
Herbouw de kernel zoals beschreven is in crossref:kernelconfig[kernelconfig,De FreeBSD-kernel instellen].
+ 
De `geli`-module kan ook bij het opstarten geladen worden. Voeg de volgende regel toe aan [.filename]#/boot/loader.conf#:
+
[.programlisting]
....
geom_eli_load="YES"
....
+ 
Nu hoort man:geli[8] door de kernel ondersteund te worden.
. Een Master Key genereren
+ 
Het volgende voorbeeld beschrijft hoe een sleutelbestand te maken, dat wordt gebruikt als onderdeel van de Master Key voor de versleutelde dienst die wordt aangekoppeld onder [.filename]#/private#. Het sleutelbestand zorgt voor wat willekeurige gegevens die worden gebruikt om de Master Key te versleutelen. De Master Key wordt ook door een wachtwoordzin beschermd. De sectorgrootte van de dienst wordt 4 kB. Ook wordt beschreven hoe de `geli`-dienst te koppelen, er een bestandsysteem op te maken, dat aan te koppelen, hoe ermee te werken en tenslotte hoe te ontkoppelen.
+ 
Het wordt aangeraden een grotere sectorgrootte in te stellen (zoals 4 kB) voor betere prestaties.
+ 
De Master Key wordt beschermd door een wachtwoordzin en de gegevensbron voor het sleutelbestand wordt [.filename]#/dev/random#. De sectorgrootte van [.filename]#/dev/da2.eli#, die als dienst wordt aangeduid, wordt 4 kB.
+
[source,bash]
....
# dd if=/dev/random of=/root/da2.key bs=64 count=1
# geli init -s 4096 -K /root/da2.key /dev/da2
Enter new passphrase:
Reenter new passphrase:
....
+ 
Het is niet verplicht om zowel een wachtwoordzijn als een sleutelbestand te gebruiken. De methodes kunnen onafhankelijk van elkaar gebruikt worden.
+ 
Als een sleutelbestand wordt opgegeven als "-", wordt de standaardinvoer gebruikt. In het onderstaande voorbeeld wordt aangegeven hoe meer dan een sleutelbestand kan worden gebruikt.
+
[source,bash]
....
# cat sleutelbestand1 sleutelbestand2 sleutelbestand3 | geli init -K - /dev/da2
....
+
. De dienst koppelen met de gemaakte sleutel
+
[source,bash]
....
# geli attach -k /root/da2.key /dev/da2
Enter passphrase:
....
+ 
Het nieuwe platte tekst-apparaat wordt [.filename]#/dev/da2.eli# genoemd.
+
[source,bash]
....
# ls /dev/da2*
/dev/da2  /dev/da2.eli
....
+
. Het nieuwe bestandssysteem maken
+
[source,bash]
....
# dd if=/dev/random of=/dev/da2.eli bs=1m
# newfs /dev/da2.eli
# mount /dev/da2.eli /private
....
+ 
Het versleutelde bestandssysteem moet nu zichtbaar zijn voor man:df[1] en beschikbaar zijn voor gebruik:
+
[source,bash]
....
# df -H
Filesystem     Size   Used  Avail Capacity  Mounted on
/dev/ad0s1a    248M    89M   139M    38%    /
/devfs         1.0K   1.0K     0B   100%    /dev
/dev/ad0s1f    7.7G   2.3G   4.9G    32%    /usr
/dev/ad0s1d    989M   1.5M   909M     0%    /tmp
/dev/ad0s1e    3.9G   1.3G   2.3G    35%    /var
/dev/da2.eli   150G   4.1K   138G     0%    /private
....
+
. De dienst afkoppelen
+ 
Als het werk met de versleutelde partitie is afgehandeld en de [.filename]#/private#-partitie niet langer nodig is, dan is het verstandig te overwegen de met `geli` versleutelde partitie af te koppelen van het bestandssysteem en de kernel.
+
[source,bash]
....
# umount /private
# geli detach da2.eli
....
====

Meer informatie over man:geli[8] staat in de handleiding.

==== Gebruik maken van het [.filename]#geli# [.filename]#rc.d# script.

Bij `geli` hoort een [.filename]#rc.d# script dat gebruikt kan worden om het gebruik van `geli` te vereenvoudigen. Een voorbeeld van hoe `geli` met man:rc.conf[5] ingesteld kan worden volgt:

[.programlisting]
....
geli_devices="da2"
geli_da2_flags="-p -k /root/da2.key"
....

Hiermee wordt [.filename]#/dev/da2# ingesteld als `geli`-dienst met Master Key-bestand [.filename]#/root/da2.key# en `geli` gebruikt geen wachtwoordzin als de dienst wordt gekoppeld (dit kan alleen gebruikt worden als `-P` is meegegeven tijdens de `geli init` fase van `geli`). Een systeem ontkoppelt de `geli`-dienst van de kernel voordat het afsluit.

Meer informatie over het instellen van rc.d staat in het onderdeel over crossref:config[configtuning-rcd,rc.d].

[[swap-encrypting]]
== Het versleutelen van de wisselbestand ruimte

Het versleutelen van de wisselbestand ruimte is gemakkelijk met FreeBSD te configureren. Afhankelijk van welke versie er gebruikt wordt zijn er verschillende configuratie opties en instellingen mogelijk. De man:gbde[8] en man:geli[8] programma's kunnen gebruikt worden voor het versleutelen van het wisselbestand. Beide systemen maken gebruik van het [.filename]#encswap# crossref:config[configtuning-rcd,rc.d] script.

De vorige sectie, <<disks-encrypting,Schijfpartities versleutelen>>, biedt een korte discussie over de verschillende versleutel systemen.

=== Waarom moet het wisselbestand versleuteld worden?

Net als met het versleutelen van harde schijven, wordt het versleutelen van het wisselbestand gebruikt om gevoelige data te beschermen. Stelt u eens een applicatie voor dat omgaat het wachtwoorden. Zolang deze wachtwoorden in het fysieke geheugen blijven is er niets aan de hand. Echter zodra deze verplaatst worden naar het wisselbestand om ruimte te maken voor andere applicaties, kan het gebeuren dat de wachtwoorden onbeschermd op de harde schijf geschreven worden, waardoor het makkelijk te achterhalen is voor iemand die kwaad wilt. Het versleutelen van het wisselbestand biedt hierin een mogelijke uitkomst.

=== Voorbereiding

[NOTE]
====
Tot het einde van deze sectie zal [.filename]#ad0s1b# het wisselbestand bevatten.
====

Tot op dit moment is het wisselbestand niet versleuteld. Het is mogelijk dat er reeds wachtwoorden of andere gevoelige data onbeschermd op de harde schijf geschreven zijn. Om dit te corrigeren, moet de data op de swap partitie overschreven worden met willekeurige data:

[source,bash]
....
# dd if=/dev/random of=/dev/ad0s1b bs=1m
....

=== Versleutelen van het wisselbestand met man:gbde[8]

Er moet gebruik gemaakt worden van het `.bde` achtervoegsel aan het apparaat in de respectievelijke [.filename]#/etc/fstab#-regel betreffende het wisselbestand:

[.programlisting]
....
# Device		Mountpoint	FStype	Options		Dump	Pass#
/dev/ad0s1b.bde		none		swap	sw		0	0
....

=== Versleutelen van het wisselbestand met man:geli[8]

Het opzetten van man:geli[8] voor het versleutelen van het wisselbestand is hetzelfde als dat van man:gbde[8]. Hier moet echter gebruik gemaakt worden van het `.eli` achtervoegsel aan het apparaat in de respectievelijke [.filename]#/etc/fstab# wisselbestand regel:

[.programlisting]
....
# Device		Mountpoint	FStype	Options		Dump	Pass#
/dev/ad0s1b.eli		none		swap	sw		0	0
....

man:geli[8] maakt standaard gebruik van het AES algoritme met een sleutellengte van 128 bits.

Optioneel kunnen deze standaardwaarden worden aangepast door gebruik te maken van de `geli_swap_flags` optie in [.filename]#/etc/rc.conf#. De volgende regel verteld het [.filename]#encswap# rc.d bestand om een man:geli[8] wisselbestand te maken met het Blowfish algoritme met een sleutel lengte van 128 bit, een sectorgrootte van 4 kilobytes en met de optie "ontkoppelen nadat de laatste afsluiting" gezet:

[.programlisting]
....
geli_swap_flags="-e blowfish -l 128 -s 4096 -d"
....

Zie de uitleg over het `onetime` commando in de man:geli[8] handleiding voor een lijst van mogelijke opties.

=== Controleren of het werkt

Zodra het systeem opnieuw opgestart is kan gekeken worden of alles nog goed werkt door gebruik te maken van het `swapinfo` commando.

Als gebruik gemaakt wordt van man:gbde[8]:

[source,bash]
....
% swapinfo
Device          1K-blocks     Used    Avail Capacity
/dev/ad0s1b.bde    542720        0   542720     0%
....

Als gebruik gemaakt wordt van man:geli[8]:

[source,bash]
....
% swapinfo
Device          1K-blocks     Used    Avail Capacity
/dev/ad0s1b.eli    542720        0   542720     0%
....

[[disks-hast]]
== Highly Available Storage (HAST)

=== Overzicht

Hoge beschikbaarheid is een van de hoofdzaken in serieuze zakelijke toepassingen en hoog beschikbare opslag is een sleutelonderdeel in zulke omgevingen. Hoog beschikbare opslag, of HAST, werd ontwikkeld door {pjd} als een raamwerk dat transparante opslag van dezelfde gegevens toestaat over fysiek gescheiden machines die verbonden zijn door een TCP/IP-netwerk. HAST kan gezien worden als een netwerkgebaseerde RAID1 (spiegel) en is vergelijkbaar met het DRBD(R) opslagsysteem bekend van het GNU/Linux(R) platform. In combinatie met andere eigenschappen voor hoge beschikbaarheid van FreeBSD zoals CARP maakt HAST het mogelijk om een opslagcluster met hoge beschikbaarheid te bouwen dat resistent is tegen falende hardware.

Na het lezen van deze sectie weet u:

* Wat HAST is, hoe het werkt en welke mogelijkheden het biedt.
* Hoe HAST op FreeBSD te op te zetten en te gebruiken.
* Hoe CARP en man:devd[8] te integreren om een robuust opslagsysteem te bouwen.

Voor het lezen van deze sectie dient u:

* De beginselen van UNIX(R) en FreeBSD te begrijpen (crossref:basics[basics,UNIX® beginselen]).
* Te weten hoe de netwerkinterfaces en andere kerndeelsystemen van FreeBSD in te stellen (crossref:config[config-tuning,Instellingen en optimalisatie]).
* Netwerken op FreeBSD goed te begrijpen (crossref:partiv[network-communication,Netwerkcommunicatie]).
* FreeBSD 8.1-RELEASE of nieuwer te gebruiken.

Het HAST-project werd gesponsord door The FreeBSD Foundation met ondersteuning van http://www.omc.net/[OMCnet Internet Service GmbH] en http://www.transip.nl/[TransIP BV].

=== Eigenschappen van HAST

De belangrijkste eigenschappen van HAST zijn:

* Het kan gebruikt worden om I/O-fouten op lokale harde schijven te maskeren.
* Agnostisch qua bestandssysteem, dus het werkt met elk bestandssysteem dat door FreeBSD wordt ondersteund.
* Efficiënte en snelle hersynchronisatie, alleen de blokken die zijn veranderd toen een knooppunt uitstond worden gesynchroniseerd.
* Het kan gebruikt worden in reeds uitgerolde omgevingen om aanvullende redundantie toe te voegen.
* Samen met CARP, Heartbeat of andere gereedschappen kan het worden gebruikt om een robuust en duurzaam opslagsysteem te bouwen.

=== Werking van HAST

Omdat HAST synchrone replicatie op blokniveau van elk opslagmedium naar verscheidene machines biedt, heeft het tenminste twee knooppunten (fysieke machines) nodig - het `primaire` (ook bekend als `meester`) knooppunt en het `secundaire` (`slaaf`) knooppunt. Tezamen worden deze twee machines een cluster genoemd.

[NOTE]
====
HAST is momenteel beperkt tot een totaal van twee clusterknooppunten.
====

Aangezien HAST in een primaire-secundaire configuratie werkt, kan er op elk moment slechts één van de clusterknooppunten actief zijn. Het `primaire` knooppunt, ookwel `actief`, is degene die alle I/O-verzoeken aan apparaten die door HAST worden beheerd afhandelt. Het `secundaire` knooppunt wordt dan automatisch gesynchroniseerd vanuit het `primaire` knooppunt.

De fysieke componenten van het HAST-systeem zijn:

* lokale schijf (op primair knooppunt)
* schijf op verre machine (secundair knooppunt)

HAST werkt synchroon op blokniveau, wat het transparant maakt voor bestandssystemen en toepassingen. HAST biedt reguliere GEOM-aanbieders aan in [.filename]#/dev/hast/# voor zowel andere gereedschappen als toepassingen, er is dus geen verschil tussen het gebruik van apparaten die door HAST worden geleverd en rauwe schijven, partities, etc.

Elke bewerking met betrekking tot schrijven, verwijderen of spoelen wordt naar de plaatselijke schijf en over TCP/IP naar de verre schijf gestuurd. Elke leesbewerking wordt gedaan door de plaatselijke schijf, tenzij de plaatselijke schijf niet actueel is of er een I/O-fout optreed. In zulke gevallen wordt de leesbewerking naar het secundaire knooppunt gestuurd.

==== Synchronisatie- en replicatiemodi

HAST probeert om een snel herstel van fouten te leveren. Om deze reden is het heel belangrijk om de synchronisatietijd te verkorten nadat een knooppunt is hersteld van een uitval. Om een snelle synchronisatie te leveren, beheert HAST op de schijf een bitmap van gebruikte extents en synchroniseert het die alleen tijdens een reguliere synchronisatie (met uitzondering van de initiëe synchronisatie).

Er zijn vele manieren om synchronisatie af te handelen. HAST implementeert meerdere replicatiemodi om verschillende synchronisatiemethodes af te handelen:

* _memsync_: rapporteer een schrijfbewerking als voltooid wanneer de plaatselijke schrijfbewerking klaar is en wanneer het verre knooppunt de gegevensaankomst bevestigt, maar voordat het de gegevens daadwerkelijk heeft opgeslagen. De gegevens op het verre knooppunt zullen meteen na het versturen van de bevestiging worden opgeslagen. Deze modus is bedoeld om latency te verminderen en nog steeds een zeer goede betrouwbaarheid te bieden. De replicatiemodus _memsync_ is momenteel niet geïmplementeerd.
* _fullsync_: rapporteer een schrijfbewerking als voltooid wanneer zowel de plaatselijke en de verre schrijfbewerking voltooid zijn. Dit is de veiligste en traagste replicatiemodus. Dit is de standaardmodus.
* _async_: rapporteer de schrijfbewerking als voltooid wanneer de plaatselijke schrijfbewerking klaar is. Dit is de snelste en gevaarlijkste replicatiemodus. Het dient gebruikt te worden wanneer er naar een ver knooppunt wordt gerepliceerd en de latency te hoog is voor andere modi. De replicatiemodus _async_ is momenteel niet geïmplementeerd.

[WARNING]
====

Momenteel wordt alleen de replicatiemodus _fullsync_ ondersteund.
====

=== HAST-configuratie

HAST heeft ondersteuning voor `GEOM_GATE` nodig om te kunnen functioneren. De kernel `GENERIC` bevat standaard _geen_ `GEOM_GATE`, de laadbare module [.filename]#geom_gate.ko# is echter beschikbaar in de standaardinstallatie van FreeBSD. Zorg ervoor dat deze module beschikbaar is voor afgeslankte systemen. Het is ook mogelijk om ondersteuning voor `GEOM_GATE` statisch in de kernel te bouwen, door deze regel aan het kernelconfiguratiebestand toe te voegen:

[.programlisting]
....
options	GEOM_GATE
....

Het HAST-raamwerk bestaat vanuit het besturingssysteem gezien uit verschillende delen:

* het daemon man:hastd[8] dat verantwoordelijk is voor de gegevenssynchronisatie,
* het beheerprogramma man:hastctl[8] voor de gebruikers,
* het configuratiebestand man:hast.conf[5].

Het volgende voorbeeld beschrijft hoe twee knooppunten in een `meester`-`slaaf` / `primaire`-`secundaire` opstelling te configureren door HAST te gebruiken om de gegevens tussen de twee te repliceren. De knooppunten worden `hasta` met IP-adres _172.16.0.1_ en `hastb` met IP-adres _172.16.0.2_ genoemd. Beide knooppunten hebben een toegewijde harde schijf [.filename]#/dev/ad6# van dezelfde grootte om met HAST te werken. De HAST-pool (soms ook een hulpbron genoemd, i.e., de GEOM-aanbieder in [.filename]#/dev/hast/#) wordt [.filename]#test# genoemd.

Het bestand [.filename]#/etc/hast.conf# regelt de configuratie van HAST. Dit bestand dient hetzelfde te zijn op beide knooppunten. Het volgende is de eenvoudigste configuratie die mogelijk is:

[.programlisting]
....
resource test {
	on hasta {
		local /dev/ad6
		remote 172.16.0.2
	}
	on hastb {
		local /dev/ad6
		remote 172.16.0.1
	}
}
....

Raadpleeg voor geavanceerdere configuraties de handleidingpagina man:hast.conf[5].

[TIP]
====

Het is ook mogelijk om hostnamen in de regels met `remote` te gebruiken. Zorg er in dat geval voor dat deze hosts vindbaar zijn, bijvoorbeeld doordat ze zijn gedefinieerd in het bestand [.filename]#/etc/hosts# of anders in het plaatselijke DNS.
====

Nu de configuratie op beide knooppunten aanwezig is, kan de HAST-pool aangemaakt worden . Voer deze commando's op beide knooppunten uit om de initiële metagegevens op de plaatselijke schijf te plaatsen en het man:hastd[8]-daemon te starten:

[source,bash]
....
# hastctl create test
# service hastd onestart
....

[NOTE]
====
Het is _niet_ mogelijk om GEOM-aanbieders met een bestaand bestandssysteem te gebruiken (i.e., een bestaande opslag omzetten naar een door HAST beheerde pool), omdat deze procedure wat metagegevens op de aanbieder moet opslaan en er daarvoor niet genoeg beschikbare ruimte is.
====

De rol van een HAST-knooppunt (`primair` of `secundair`) wordt uitgekozen door een beheerder of software zoals Heartbeat dat het gereedschap man:hastctl[8] gebruikt. Voer het volgende commando uit op het primaire knooppunt ( `hasta`):

[source,bash]
....
# hastctl role primary test
....

Voer dit soortgelijke commando uit op het secundaire knooppunt ( `hastb`):

[source,bash]
....
# hastctl role secondary test
....

[CAUTION]
====

De situatie dat de knooppunten niet met elkaar kunnen communiceren en beide geconfigureerd zijn als primaire knooppunten; wordt `split-brain` genoemd. Volg de stappen zoals beschreven in <<disks-hast-sb>> om deze situatie op te lossen.
====

Verifieer met het gereedschap man:hastctl[8] het resultaat op elk knooppunt:

[source,bash]
....
# hastctl status test
....

De belangrijke tekst is de regel met `status` dat voor alle knooppunten `complete` dient te bevatten. Als het `degraded` bevat, is er iets verkeerd gegaan. Op dat moment is de synchronisatie tussen de knooppunten al begonnen. De synchronisatie is compleet wanneer `hastctl status` 0 bytes aan `dirty` extents rapporteert.

De volgende stap is het aanmaken van een bestandssysteem op de GEOM-aanbieder [.filename]#/dev/hast/test# en het aan te koppelen. Dit moet op het `primaire` knooppunt gebeuren, aangezien [.filename]#/dev/hast/test# alleen op het `primaire` knooppunt verschijnt. Het aanmaken van het bestandssysteem kan afhankelijk van de grootte van de harde schijf enkele minuten duren:

[source,bash]
....
# newfs -U /dev/hast/test
# mkdir /hast/test
# mount /dev/hast/test /hast/test
....

Wanneer het HAST-raamwerk correct is geconfigureerd, betreft de laatste stap het ervoor zorgen dat HAST automatisch tijdens het opstarten wordt gestart. Voeg deze regel toe aan het bestand [.filename]#/etc/rc.conf#:

[.programlisting]
....
hastd_enable="YES"
....

==== Failover-configuratie

Het doel van dit voorbeeld is om een robuust opslagsysteem te bouwen dat resistent is tegen het falen van alle knooppunten. Het scenario is dat een `primair` knooppunt van het cluster faalt. Als dit gebeurt, dan neemt het `secundaire` knooppunt het feilloos over, controleert het het bestandssysteem en koppelt het het bestandssysteem aan, en gaat het verder zonder dat er een bit aan gegevens ontbreekt.

Om dit voor elkaar te krijgen, is er een andere eigenschap die beschikbaar is op FreeBSD dat voorziet in automatische failover van de IP-laag - CARP. CARP (Common Address Redundancy Protocol) maakt het mogelijk dat meerdere hosts in hetzelfde netwerksegment een IP-adres delen. Stel CARP in op beide knooppunten van het cluster volgens de documentatie die beschikbaar is in crossref:advanced-networking[carp,Common Address Redundancy Protocol (CARP)]. Nadat de opzet voltooid is, heeft elk knooppunt een eigen interface [.filename]#carp0# met een gedeeld IP-adres _172.16.0.254_. Het primaire HAST-knooppunt van het cluster moet het meester-CARP-knooppunt zijn.

De HAST-pool die in de vorige sectie is gemaakt is nu klaar om geëxporteerd te worden naar de andere hosts op het netwerk. Dit kan gedaan worden door het te exporteren over NFS, Samba, etc., door gebruik te maken van het gedeelde IP-adres _172.16.0.254_. Het enige overgebleven probleem is een automatische failover in het geval dat het primaire knooppunt het begeeft.

Als een CARP-interface aan- of uitgaat, genereert FreeBSD een man:devd[8]-gebeurtenis, wat het mogelijk maakt om toestandsveranderingen op de CARP-interfaces in de gaten te houden. Een toestandsverandering op het CARP-interface geeft aan dat een van de knooppunten het begaf of weer online kwam. Deze toestandsveranderingen maken het mogelijk om een script te draaien dat automatisch de HAST-failover afhandelt.

Voeg, om toestandsverandering op de CARP-interfaces af te vangen, het volgende toe aan het bestand [.filename]#/etc/devd.conf# op elk knooppunt:

[.programlisting]
....
notify 30 {
	match "system" "IFNET";
	match "subsystem" "carp0";
	match "type" "LINK_UP";
	action "/usr/local/sbin/carp-hast-switch master";
};

notify 30 {
	match "system" "IFNET";
	match "subsystem" "carp0";
	match "type" "LINK_DOWN";
	action "/usr/local/sbin/carp-hast-switch slave";
};
....

Herstart man:devd[8] op beide knooppunten om de nieuwe configuratie te laten gelden:

[source,bash]
....
# service devd restart
....

Als het interface [.filename]#carp0# aan of uit gaat (i.e., de toestand van het interface verandert), genereert het systeem een notificatie wat het subsysteem man:devd[8] in staat stelt om een willekeurig script te draaien, in dit geval [.filename]#/usr/local/sbin/carp-hast-switch#. Dit is het script dat de automatische failover afhandelt. Raadpleeg de handleidingpagina man:devd.conf[5] voor verdere uitleg over de bovenstaande configuratie van man:devd[8].

Dit zou een voorbeeld van zo'n script kunnen zijn:

[.programlisting]
....
#!/bin/sh
# Origineel script door Freddie Cash <fjwcash@gmail.com>
# Gewijzigd door Michael W. Lucas <mwlucas@BlackHelicopters.org>
# en Viktor Petersson <vpetersson@wireload.net>

# De namen van de HAST-hulpbronnen, zoals vermeld in /etc/hast.conf
resources="test"

# vertraging voor het aankoppelen van de HAST-hulpbron na het worden van meester
# doe een gok
delay=3

# logging
log="local0.debug"
name="carp-hast"

# einde van gebruiker-instelbare dingen

case "$1" in
	master)
		logger -p $log -t $name "Omschakelen naar primaire aanbieder voor ${resources}."
		sleep ${delay}

		# Wacht totdat de "hastd secondary" processen zijn gestopt
		for disk in ${resources}; do
			while $( pgrep -lf "hastd: ${disk} \(secondary\)" > /dev/null 2>&1 ); do
				sleep 1
			done

			# Verwissel de rol voor elke schijf
			hastctl role primary ${disk}
			if [ $? -ne 0 ]; then
				logger -p $log -t $name "Omschakelen van rol naar primair voor hulpbron ${disk} mislukt."
				exit 1
			fi
		done

		# Wacht totdat de apparaten /dev/hast/* verschijnen
		for disk in ${resources}; do
			for I in $( jot 60 ); do
				[ -c "/dev/hast/${disk}" ] && break
				sleep 0.5
			done

			if [ ! -c "/dev/hast/${disk}" ]; then
				logger -p $log -t $name "GEOM-aanbieder /dev/hast/${disk} is niet verschenen."
				exit 1
			fi
		done

		logger -p $log -t $name "Rollen van HAST-hulpbronnen ${resources} omgeschakeld naar primair."

		logger -p $log -t $name "Schijven aankoppelen."
		for disk in ${resources}; do
			mkdir -p /hast/${disk}
			fsck -p -y -t ufs /dev/hast/${disk}
			mount /dev/hast/${disk} /hast/${disk}
		done

	;;

	slave)
		logger -p $log -t $name "Omschakelen naar secundaire aanbieder voor ${resources}."

		# Schakel de rollen van de HAST-hulpbronnen om
		for disk in ${resources}; do
			if ! mount | grep -q "^/dev/hast/${disk} on "
			then
			else
				umount -f /hast/${disk}
			fi
			sleep $delay
			hastctl role secondary ${disk} 2>&1
			if [ $? -ne 0 ]; then
				logger -p $log -t $name "Omschakelen van rol naar secundair voor hulpbron ${disk} mislukt."
				exit 1
			fi
			logger -p $log -t $name "Rol van hulpbron ${disk} omgeschakeld naar secundair."
		done
	;;
esac
....

In een notendop neemt het script deze acties wanneer een knooppunt `meester` / `primair` wordt:

* De HAST-pools opwaarderen naar primair op een gegeven knooppunt.
* Het bestandssysteem onder de HAST-pool controleren.
* De pools op een juiste plaats aankoppelen.

Wanneer een knooppunt `back-up` / `secundair` wordt:

* De HAST-pools afkoppelen.
* De HAST-pools degraderen naar secundair.

[CAUTION]
====

Houd in gedachte dat dit slechts een voorbeeldscript is om aan te tonen dat alles werkt. Het behandeld niet alle mogelijke situaties en kan op elke manier worden uitgebreid of veranderd, het kan bijvoorbeeld benodigde diensten starten en stoppen.
====

[TIP]
====

Voor dit voorbeeld hebben we een standaard UFS-bestandssysteem gebruikt. Om de tijd die nodig is voor herstel te verkorten, kan een bestandssysteem met UFS-journalling of ZFS worden gebruikt.
====

Meer gedetailleerde informatie met aanvullende voorbeelden kunnen gevonden worden op de http://wiki.FreeBSD.org/HAST[HAST Wiki]-pagina.

=== Problemen oplossen

==== Algemene tips om problemen op te lossen

HAST zou over het algemeen zonder problemen moeten werken. Net als met elk ander software-product zijn er momenten waarop het anders werkt dan het zou moeten. De oorzaken van de problemen kunnen verschillen, maar de vuistregel is om ervoor te zorgen dat de klokken zijn gesynchroniseerd op alle knooppunten in het cluster.

Wanneer problemen met HAST worden verholpen, dient het debug-niveau van man:hastd[8] verhoogd te worden door het daemon man:hastd[8] met het argument `-d` op te starten. Merk op dat dit argument meerdere malen kan worden opgegeven om het debug-niveau nog verder op te hogen. Op deze manier kan veel nuttige informatie worden vergaard. Overweeg ook om het argument `-F` te gebruiken, dat het daemon man:hastd[8] in de voorgrond zal starten.

[[disks-hast-sb]]
==== Herstellen van de Split-brain-conditie

`Split-brain` treedt op waneer de knooppunten van het cluster niet met elkaar kunnen communiceren, en beide als primair zijn geconfigureerd. Dit is een gevaarlijke situatie omdat het beide knooppunten in staat stelt om incompatibele veranderingen aan de gegevens te maken. Dit probleem dient handmatig door de systeembeheerder te worden gecorrigeerd.

De beheerder moet besluiten welk knooppunt de belangrijkere veranderingen bevat (of ze handmatig samenvoegen) en HAST een volledige synchronisatie op het knooppunt dat de kapotte gegevens heeft laten uitvoeren. Voer hiervoor deze commando's uit op het knooppunt dat opnieuw gesynchroniseerd moet worden:

[source,bash]
....
# hastctl role init <resource>
# hastctl create <resource>
# hastctl role secondary <resource>
....
