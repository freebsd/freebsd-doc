---
title: Hoofdstuk 15. Beveiliging
part: Deel III. Systeembeheer
prev: books/handbook/users
next: books/handbook/jails
showBookMenu: true
weight: 19
path: "/books/handbook/security/"
---

[[security]]
= Beveiliging
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 15
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/security/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[security-synopsis]]
== Overzicht

Dit hoofdstuk biedt een basisinleiding in systeembeveiligingsconcepten, een aantal goede basisregels en een paar gevorderde onderwerpen binnen FreeBSD. Veel van de onderwerpen die worden behandeld kunnen ook worden toegepast op systemen en Internet in het algemeen. Het Internet is niet langer een "vriendelijke" omgeving waar iedereen een goede buur wil zijn. Het beveiligen van een systeem is onontbeerlijk als gegevens, intellectueel eigendom, tijd en wat dan ook uit de handen van hackers en dergelijke gehouden moeten worden.

FreeBSD biedt veel hulpmiddelen en mechanismen om te zorgen voor de integriteit en veiligheid van een systeem en netwerk.

Na het lezen van dit hoofdstuk weet de lezer:

* Van basis systeembeveiligingsconcepten in relatie tot FreeBSD.
* Meer over verschillende versleutelingsmechanismen die beschikbaar zijn in FreeBSD zoals DES en MD5.
* Hoe eenmalige wachtwoordautenticatie opgezet kan worden.
* Hoe TCP Wrappers in te stellen voor gebruik met inetd.
* Hoe Kerberos5 op FreeBSD opgezet kan worden.
* Hoe IPsec wordt ingesteld en hoe een VPN op te zetten tussen FreeBSD en Microsoft(R) Windows(R) machines.
* Hoe OpenSSH, FreeBSD's SSH implementatie, in te stellen en te gebruiken.
* Wat bestandssysteem-ACLs zijn en hoe die te gebruiken;
* Hoe het hulpprogramma Portaudit gebruikt kan worden om softwarepakketten uit de Portscollectie te auditen.
* Hoe om te gaan met publicaties van FreeBSD beveiligingswaarschuwingen.
* Iets van procesaccounting en hoe dat is in te schakelen in FreeBSD.

Er wordt aangenomen dat de lezer van dit hoofdstuk:

* Basisbegrip heeft van FreeBSD en Internetconcepten.

In dit boek worden nog meer onderwerpen met betrekking tot beveiliging beschreven. Zo wordt bijvoorbeeld Verplichte Toegangscontrole (Mandatory Access Control) besproken in crossref:mac[mac,Mandatory Access Control] en Internet Firewalls in crossref:firewalls[firewalls,Firewalls].

[[security-intro]]
== Introductie

Beveiliging is een taak die begint en eindigt bij de systeembeheerder. Hoewel alle BSD UNIX(R) meergebruikerssystemen enige inherente beveiliging kennen, is het bouwen en onderhouden van additionele beveiligingsmechanismen om de gebruikers "eerlijk" te houden waarschijnlijk een van de zwaarste taken voor de systeembeheerder. Machines zijn zo veilig als ze gemaakt worden en beveiligingsoverwegingen staan altijd op gespannen voet met de wens om gebruiksvriendelijkheid. UNIX(R) systemen zijn in het algemeen in staat tot het tegelijkertijd uitvoeren van een enorm aantal processen en veel van die processen acteren als server - daarmee wordt bedoeld dat externe entiteiten er verbindingen mee kunnen maken en ertegen kunnen praten. Nu de minicomputers en mainframes van gisteren de desktops van vandaag zijn en computers onderdeel zijn van netwerken en internetwerken, wordt beveiliging nog belangrijker.

Systeembeveiliging heeft ook te maken met het omgaan met verschillende vormen van aanvallen, zoals een poging om een systeem te crashen of op een andere manier onstabiel te maken, zonder te proberen de `root` account aan te vallen ("break root"). Aandachtspunten voor beveiliging kunnen opgesplitst worden in categorieën:

. Ontzeggen van dienst aanvallen ("Denial of Service").
. Gebruikersaccounts compromitteren.
. `root` compromitteren via toegankelijke servers.
. `root` compromitteren via gebruikersaccounts.
. Achterdeur creëren ("Backdoor").

Een ontzegging van dienst (DoS) aanval is een techniek die de machine middelen ontneemt. In het algemeen zijn DoS aanvallen brute kracht mechanismen die proberen de machine te crashen of op een andere manier onbruikbaar te maken door de machine of de netwerkcode te overvragen. Sommige DoS aanvallen proberen misbruik te maken van bugs in de netwerkcode om een machine met een enkel pakket te crashen. Zoiets kan alleen gerepareerd worden door een aanpassing aan de kernel te maken. Aanvallen op servers kunnen vaak hersteld worden door op de juiste wijze opties in stellen om de belasting van servers te limiteren in ongunstige omstandigheden. Omgaan met brute kracht aanvallen is lastiger. Zo is een aanval met gefingeerde pakketten ("spoofed-packet") vrijwel niet te stoppen, behalve dan door het systeem van Internet los te koppelen. Misschien gaat de machine er niet door plat, maar het kan wel een volledige Internetverbinding verzadigen.

Een gecompromitteerde gebruikersaccount komt nog veel vaker voor dan een DoS aanval. Veel systeembeheerders draaien nog steeds standaard telnetd, rlogind, rshd en ftpd servers op hun machines. Deze servers communiceren standaard niet over beveiligde verbindingen. Het resultaat is dat als er een redelijk grote gebruikersgroep is, er altijd wel van een of meer van de gebruikers die van afstand op dat systeem aanmelden (wat toch de meest normale en makkelijke manier is om op een systeem aan te melden) het wachtwoord is afgeluisterd ("sniffed"). Een oplettende systeembeheerder analyseert zijn logboekbestanden om te zoeken naar verdachte bronadressen, zelfs als het om succesvolle aanmeldpogingen gaat.

Uitgangspunt moet altijd zijn dat als een aanvaller toegang heeft tot een gebruikersaccount, de aanvaller de `root` account kan compromitteren. In werkelijkheid is het wel zo dat voor een systeem dat goed beveiligd is en goed wordt onderhouden, toegang tot een gebruikersaccount niet automatisch betekent dat de aanvaller ook `root` privileges kan krijgen. Het is van belang dit onderscheid te maken, omdat een aanvaller zonder toegang tot `root` in het algemeen zijn sporen niet kan wissen en op z'n best wat kan rommelen met bestanden van de gebruiker of de machine kan crashen. Gecompromitteerde gebruikersaccounts zijn vrij normaal omdat gebruikers normaliter niet de voorzorgsmaatregelen nemen die systeembeheerders nemen.

Systeembeheerders moeten onthouden dat er in potentie heel veel manieren zijn om toegang tot `root` te krijgen. Een aanvaller zou het `root` wachtwoord kunnen kennen, een bug kunnen ontdekken in een dienst die onder `root` draait en daar via een netwerkverbinding op in kunnen breken of een aanvaller zou een probleem kennen met een suid-root programma dat de aanvaller in staat stelt `root` te worden als hij eenmaal toegang heeft tot een gebruikersaccount. Als een aanvaller een manier heeft gevonden om `root` te worden op een machine, dan hoeft hij misschien geen achterdeur ("backdoor") te installeren. Veel bekende manieren die zijn gevonden om `root` te worden, en weer zijn afgesloten, vereisen veel werk van de aanvaller om zijn rommel achter zich op te ruimen, dus de meeste aanvallers installeren een achterdeur. Een achterdeur biedt de aanvaller een manier om makkelijk opnieuw `root` toegang tot het systeem te krijgen, maar dit geeft de slimme systeembeheerder ook een makkelijke manier om de inbraak te ontdekken. Het onmogelijk maken een achterdeur te installeren zou best wel eens nadelig kunnen zijn voor beveiliging, omdat hiermee nog niet het gat gedicht is waardoor er in eerste instantie is ingebroken.

Beveiligingsmaatregelen moeten altijd geïmplementeerd worden in een meerlagenmodel en worden als volgt gecategoriseerd:

. Beveiligen van `root` en medewerkersaccounts.
. Beveiligen van `root` - servers onder `root` en suid-/sgid-binaire bestanden.
. Beveiligen van gebruikersaccounts.
. Beveiligen van het wachtwoordbestand.
. Beveiligen van de kern van de kernel, ruwe apparaten en bestandssystemen.
. Snel detecteren van ongeoorloofde wijzigingen aan het systeem.
. Paranoia.

In het volgende onderdeel van dit hoofdstuk gaan we dieper in op de bovenstaande punten.

[[securing-freebsd]]
== FreeBSD beveiligen

[NOTE]
.Commando versus protocol
====
In dit hele document gebruiken we vette tekst om te verwijzen naar een commando of applicatie en een `monospaced` lettertype om te verwijzen naar specifieke commando's. Protocollen staan vermeld in een normaal lettertype. Dit typografische onderscheid is zinvol omdat bijvoorbeeld ssh zowel een protocol als een commando is.
====

In de volgende onderdelen behandelen we de methodes uit de <<security-intro,vorige paragraaf>> om een FreeBSD-systeem te beveiligen.

[[securing-root-and-staff]]
=== Beveiligen van `root` en medewerkersaccounts.

Om te beginnen: doe geen moeite om medewerkersaccounts te beveiligen als de `root` account niet beveiligd is. Op de meeste systemen heeft de `root` account een wachtwoord. Als eerste moet aangenomen worden dat dit wachtwoord _altijd_ gecompromitteerd is. Dit betekent niet dat het wachtwoord verwijderd moet worden. Het wachtwoord is namelijk bijna altijd nodig voor toegang via het console van de machine. Het betekent wel dat het niet mogelijk gemaakt moet worden om het wachtwoord te gebruiken buiten het console om en mogelijk zelfs niet via het man:su[1] commando. Pty's moeten bijvoorbeeld gemarkeerd staan als onveilig ("insecure") in het bestand [.filename]#/etc/ttys# zodat direct aanmelden met `root` via `telnet` of `rlogin` niet wordt toegestaan. Als andere aanmelddiensten zoals sshd gebruikt worden, dan hoort direct aanmelden via `root` uitgeschakeld staat. Dit kan door het bestand [.filename]#/etc/ssh/sshd_config# te bewerken en ervoor te zorgen dat `PermitRootLogin` op `no` staat. Dit moet gebeuren voor iedere methode van toegang - diensten zoals FTP worden vaak over het hoofd gezien. Het direct aanmelden van `root` hoort alleen te mogen via het systeemconsole.

Natuurlijk moet een systeembeheerder de mogelijkheid hebben om `root` te worden. Daarvoor kunnen een paar gaatjes geprikt worden. Maar dan moet ervoor gezorgd worden dat er voor deze gaatjes extra aanmelden met een wachtwoord nodig is. Eén manier om `root` toegankelijk te maken is door het toevoegen van de juiste medewerkersaccounts aan de `wheel` groep (in [.filename]#/etc/group#). De medewerkers die lid zijn van de groep `wheel` mogen `su`-en naar `root`. Maak medewerkers nooit "native" lid van de groep `wheel` door ze in de groep `wheel` te plaatsen in [.filename]#/etc/group#. Medewerkersaccounts horen lid te zijn van de groep `staff` en horen dan pas toegevoegd te worden aan de groep `wheel` in het bestand [.filename]#/etc/group#. Alleen medewerkers die ook echt toegang tot `root` nodig hebben horen in de groep `wheel` geplaatst te worden. Het is ook mogelijk, door een autenticatiemethode als Kerberos te gebruiken, om het bestand [.filename]#.k5login# van Kerberos in de `root` account te gebruiken om een man:ksu[1] naar `root` toe te staan zonder ook maar iemand lid te maken van de groep `wheel`. Dit is misschien wel een betere oplossing, omdat het `wheel`-mechanisme het nog steeds mogelijk maakt voor een inbreker `root` te breken als de inbreker een wachtwoordbestand te pakken heeft gekregen en toegang kan krijgen tot één van de medewerkersaccounts. Hoewel het instellen van het `wheel`-mechanisme beter is dan niets, is het niet per se de meest veilige optie.

Om een account volledig op slot te zetten, dient het commando man:pw[8] gebruikt te worden:

[source,shell]
....
# pw lock staff
....

Dit voorkomt dat de gebruiker zich aanmeldt via enig mechanisme, inclusief man:ssh[1].

Een andere manier om toegang tot accounts te blokkeren is om het versleutelde wachtwoord door een enkel "`*`"-karakter te vervangen. Dit karakter zal nooit overeenkomen met het versleutelde wachtwoord en dus gebruikerstoegang blokkeren. Het volgende medewerkersaccount bijvoorbeeld:

[.programlisting]
....
foobar:R9DT/Fa1/LV9U:1000:1000::0:0:Foo Bar:/home/foobar:/usr/local/bin/tcsh
....

zou veranderd moeten worden in:

[.programlisting]
....
foobar:*:1000:1000::0:0:Foo Bar:/home/foobar:/usr/local/bin/tcsh
....

Dit voorkomt dat de gebruiker `foobar` zich aanmeldt met conventionele methoden. Deze methode om toegang te beperken werkt niet op sites die Kerberos gebruiken of in situaties waarin de gebruiker met man:ssh[1] sleutels heeft geïnstalleerd.

Deze beveiligingsmechanismen hebben ook als uitgangspunt dat vanaf een zwaarder beveiligde machine wordt aangemeld op een minder beveiligd systeem. Als een hoofdserver bijvoorbeeld allerlei servers draait, zou het werkstation er geen moeten draaien. Om een werkstation redelijk veilig te laten zijn, dienen er zo min mogelijk servers op te draaien, bij voorkeur zelfs geen en er zou een schermbeveiliging met wachtwoordbeveiliging op moeten draaien. Maar als een aanvaller fysieke toegang heeft tot een werkstation, dan kan hij elke beveiliging die erop is aangebracht omzeilen. Dit probleem dient echt overwogen te worden, net als het feit dat de meeste aanvallen van een afstand plaatsvinden, via het netwerk, door mensen die geen fysieke toegang hebben tot werkstations of servers.

Het gebruik van iets als Kerberos geeft de mogelijkheid om het wachtwoord van de account van een medewerker buiten gebruik te stellen of te wijzigen op één plaats, waarbij het meteen actief is op alle machines waarop die medewerker een account heeft. Als de account van een medewerker gecompromitteerd raakt, moet vooral de mogelijkheid om per direct het wachtwoord voor machines te kunnen aanpassen niet onderschat worden. Met afzonderlijke wachtwoorden kan het veranderen van wachtwoorden op N systemen een puinhoop worden. Met Kerberos kunnen ook wachtwoordrestricties opgelegd worden: het is niet alleen mogelijk om een Kerberos "ticket" na een bepaalde tijd te laten verlopen, maar het Kerberos systeem kan afdwingen dat de gebruiker na een bepaalde tijd een nieuw wachtwoord kiest (na bijvoorbeeld een maand).

=== Beveiligen van `root` - servers onder `root` en suid-/sgid-binaire bestanden

Een voorzichtige systeembeheerder draait alleen die servers die nodig zijn, niets meer, niets minder. Bedenk dat servers van derde partijen vaak de meeste neiging hebben tot het vertonen van bugs. Zo staat bijvoorbeeld het draaien van een oude versie van imapd of popper gelijk aan het weggeven van de `root` account aan de hele wereld. Draai nooit een server die niet zorgvuldig is onderzocht. Veel servers hoeven niet te draaien als `root`. Zo kunnen de ntalk, comsat en finger daemons bijvoorbeeld draaien in speciale gebruikerszandbakken ("_sandboxes_"). Een zandbak is niet perfect, tenzij er heel veel moeite gedaan wordt, maar de meerlagenbenadering blijft bestaan: als iemand via een server die in een zandbak draait weet in te breken, dan moeten ze eerst nog uit de zandbak komen. Hoe groter het aantal lagen is waar een inbreker doorheen moet, hoe kleiner de kans op succes is. `root` gaten zijn historisch gezien aanwezig geweest in vrijwel iedere server die ooit als `root` gedraaid heeft, inclusief de basisservers van een systeem. Op een machine waarop mensen alleen aanmelden via sshd en nooit via telnetd of rshd of rlogind dienen die servers uitgeschakeld te worden!

FreeBSD draait ntalkd, comsat en finger tegenwoordig standaard in een zandbak. Een ander programma dat misschien beter in een zandbak kan draaien is man:named[8]. In [.filename]#/etc/defaults/rc.conf# staat als commentaar welke parameters er nodig zijn om named in een zandbak te draaien. Afhankelijk van of het een nieuwe systeeminstallatie of het bijwerken van een bestaand systeem betreft, worden de speciale gebruikersaccounts die bij die zandbakken horen misschien niet geïnstalleerd. Een voorzichtige systeembeheerder onderzoekt en implementeert zandbakken voor servers waar dat ook maar mogelijk is.

Er zijn een aantal diensten die vooral niet in een zandbak draaien: sendmail, popper, imapd, ftpd en andere. Voor sommige servers zijn alternatieven, maar dat kost misschien meer tijd dan er te besteden is (gemak dient de mens). Het kan voorkomen dat deze servers als `root` moeten draaien en dat er vertrouwd moet worden op andere mechanismen om een inbraak via die servers te detecteren.

De andere grote mogelijkheid voor `root` gaten in een systeem zijn de suid-root en sgid-binaire bestanden die geïnstalleerd zijn op een systeem. Veel van die bestanden, zoals rlogin, staan in [.filename]#/bin#, [.filename]#/sbin#, [.filename]#/usr/bin# of [.filename]#/usr/sbin#. Hoewel het niet 100% veilig is, mag aangenomen worden dat de suid- en sgid-binaire bestanden van een standaardsysteem redelijk veilig zijn. Toch worden er nog wel eens `root` gaten gevonden in deze bestanden. Zo is er in 1998 een `root` gat gevonden in `Xlib` waardoor xterm (die normaliter suid is) kwetsbaar bleek. Een voorzichtige systeembeheerder kiest voor "better to be safe than sorry" door de suid-bestanden die alleen medewerkers hoeven uit te voeren aan een speciale groep toe te wijzen en de suid-bestanden die niemand gebruikt te lozen (`chmod 000`). Een server zonder monitor heeft normaal gezien xterm niet nodig. Sgid-bestanden kunnen bijna net zo gevaarlijk zijn. Als een inbreker een sgid-kmem stuk kan krijgen, dan kan hij wellicht [.filename]#/dev/kmem# lezen en dus het gecodeerde wachtwoordbestand, waardoor mogelijk ieder account met een wachtwoord besmet is. Een inbreker toegang tot de groep `kmem` kan krijgen, zou bijvoorbeeld mee kunnen kijken met de toetsaanslagen die ingegeven worden via de pty's, inclusief die pty's die gebruikt worden door gebruikers die via beveiligde methodes aanmelden. Een inbreker die toegang krijgt tot de groep `tty` kan naar bijna alle tty's van gebruikers schrijven. Als een gebruiker een terminalprogramma of een terminalemulator met een toetsenbordsimulatieoptie draait, dan kan de inbreker in potentie een gegevensstroom genereren die ervoor zorgt dat de terminal van de gebruiker een commando echot, dat dan wordt uitgevoerd door die gebruiker.

[[secure-users]]
=== Beveiligen van gebruikersaccounts

Gebruikersaccounts zijn gewoonlijk het meest lastig om te beveiligen. Hoewel er allerlei draconische maatregelen genomen kunnen worden met betrekking tot de medewerkers en hun wachtwoorden "weggesterd" kunnen worden, gaat dat waarschijnlijk niet lukken met de gewone gebruikersaccounts. Als er toch voldoende vrijheid is, dan prijst de beheerder zich gelukkig en is het misschien toch mogelijk de accounts voldoende te beveiligen. Als die vrijheid er niet is, dan moeten die accounts gewoon netter gemonitord worden. Het gebruik van ssh en Kerberos voor gebruikersaccounts is problematischer vanwege het extra beheer en de ondersteuning, maar nog steeds een prima oplossing in vergelijking met een versleuteld wachtwoordbestand.

=== Beveiligen van het wachtwoordbestand

De enige echte oplossing is zoveel mogelijk wachtwoorden wegsterren en ssh of Kerberos gebruiken voor toegang tot die accounts. Hoewel een gecodeerd wachtwoordbestand ([.filename]#/etc/spwd.db#) alleen gelezen kan worden door `root`, is het wel mogelijk dat een inbreker leestoegang krijgt tot dat bestand zonder dat de aanvaller root-schrijftoegang krijgt.

Beveiligingsscripts moeten altijd controleren op en rapporteren over wijzigingen in het wachtwoordbestand (zie ook <<security-integrity,Bestandsintegriteit Controleren>> hieronder).

=== Beveiligen van de kern van de kernel, ruwe apparaten en bestandssystemen

Als een aanvaller toegang krijgt tot `root` dan kan hij ongeveer alles, maar er zijn een paar slimmigheidjes. Zo hebben bijvoorbeeld de meeste moderne kernels een ingebouwd pakketsnuffelstuurprogramma ("packet sniffing"). Bij FreeBSD is dat het [.filename]#bpf# apparaat. Een inbreker zal in het algemeen proberen een pakketsnuffelaar te draaien op een gecompromitteerde machine. De inbreker hoeft deze mogelijkheid niet te hebben en bij de meeste systemen is het niet verplicht het [.filename]#bpf# apparaat mee te compileren.

Maar zelfs als het [.filename]#bpf# apparaat is uitgeschakeld, dan zijn er nog [.filename]#/dev/mem# en [.filename]#/dev/kmem#. De inbreker kan namelijk nog schrijven naar ruwe schrijfapparaten. En er is ook nog een optie in de kernel die modulelader ("module loader") heet, man:kldload[8]. Een ondernemende inbreker kan een KLD-module gebruiken om zijn eigen [.filename]#bpf#-apparaat of een ander snuffelapparaat te installeren in een draaiende kernel. Om deze problemen te voorkomen, moet de kernel op een hoger veiligheidsniveau draaien, ten minste securelevel 1.

Het veiligheidsniveau van de kernel kan op een aantal manieren worden ingesteld. De eenvoudigste manier om het veiligheidsniveau van een draaiende kernel te verhogen is met `sysctl` op de kernelvariabele `kern.securelevel`:

[source,shell]
....
# sysctl kern.securelevel=1
....

Standaard start de kernel van FreeBSD op met een veiligheidsniveau van -1. Het veiligheidsniveau blijft -1 tenzij het is veranderd, òfwel door de beheerder òfwel door man:init[8] vanwege een instelling in de opstartscripts. Het veiligheidsniveau kan tijdens het opstarten van het systeem verhoogd worden door de variabele `kern_securelevel_enable` op `YES` te zetten in het bestand [.filename]#/etc/rc.conf#, en de waarde van de variabele `kern_securelevel` op het gewenste veiligheidsniveau in te stellen.

Het standaard veiligheidsniveau van een FreeBSD-systeem direct nadat de opstartscripts zijn uitgevoerd is -1. Dit wordt "onveilige modus" genoemd omdat de onveranderlijke bestandsvlag uitgezet kan worden, er van/naar alle apparaten mag worden gelezen en geschreven, enzovoorts.

Als eenmaal het veiligheidsniveau op 1 of een hogere waarde is ingesteld, worden de alleen-toevoegen en onveranderlijke bestanden gehonoreerd, deze kunnen niet worden uitgezet, en wordt toegang tot rauwe apparaten ontzegd. Hogere niveaus beperken nog meer bewerkingen. Lees, voor een volledige beschrijving van het effect van de verschillende veiligheidsniveaus, de handleidingpagina man:security[7].

[NOTE]
====
Het ophogen van het veiligheidsniveau naar 1 of hoger kan enkele problemen met X11 (toegang tot [.filename]#/dev/io# zal worden geblokkeerd), of met de installatie van FreeBSD wanneer die vanaf de broncode is gebouwd (het gedeelte `installword` van het proces moet tijdelijk de alleen-toevoegen en onveranderlijke vlaggen van sommige bestanden uitzetten), en met enkele andere gevallen veroorzaken. Soms, zoals het geval is met X11, is het mogelijk om dit te omzeilen door man:xdm[1] behoorlijk vroeg in het opstartproces te starten, wanneer het veiligheidsniveau nog laag genoeg is. Omzeilmethoden zoals deze zijn misschien niet voor alle veiligheidsniveaus of voor alle beperkingen die ze opleggen mogelijk. Wat vooruit plannen is een goed idee. Het is belangrijk om de beperkingen die door elk veiligheidsniveau worden opgelegd te begrijpen omdat ze het gebruiksgemak van het systeem sterk verminderen. Het vergemakkelijkt ook het kiezen van eens standaardinstelling en voorkomt allerlei verassingen.
====

Als het veiligheidsniveau van de kernel naar 1 of hoger wordt verhoogd, kan het nuttig zijn om de vlag `schg` aan te zetten voor kritieke opstartprogramma's, mappen, en scriptbestanden (i.e., alles dat gedraaid wordt tot het punt waar het veiligheidsniveau wordt ingesteld). Dit kan overdreven zijn, en het bijwerken van het systeem is veel moeilijker wanneer het op een hoog veiligheidsniveau werkt. Een minder beperkend compromis is om het systeem op een hoger veiligheidsniveau te draaien maar het aanzetten van de vlag `schg` voor elk systeembestand en -map onder de zon over te slaan. Een andere mogelijkheid is om [.filename]#/# en [.filename]#/usr# simpelweg als alleen-lezen aan te koppelen. Het dient opgemerkt te worden dat het te draconisch zijn over wat is toegestaan het belangrijke detecteren van een inbraak kan verhinderen.

[[security-integrity]]
=== Bestandsintegriteit controleren: binaire bestanden, instellingenbestanden, enzovoort

Als puntje bij paaltje komt kan de kern van een systeem maar tot een bepaald punt beveiligd worden zonder dat het minder prettig werken wordt. Zo werk het zetten van de `schg` bit met `chflags` op de meeste bestanden in [.filename]#/# en [.filename]#/usr# waarschijnlijk averechts, omdat, hoewel de bestanden beschermd zijn, ook het venster waarin detectie plaats kan vinden is gesloten. De laatste laag van beveiliging is waarschijnlijk de meest belangrijke: detectie. Alle overige beveiliging is vrijwel waardeloos (of nog erger: geeft een vals gevoel van beveiliging) als een mogelijke inbraak niet gedetecteerd kan worden. Een belangrijk doel van het meerlagenmodel is het vertragen van een aanvaller, nog meer dan hem te stoppen, om hem op heterdaad te kunnen betrappen.

De beste manier om te zoeken naar een inbraak is zoeken naar gewijzigde, ontbrekende of onverwachte bestanden. De beste manier om te zoeken naar gewijzigde bestanden is vanaf een ander (vaak gecentraliseerd) systeem met beperkte toegang. Met zelfgeschreven scripts op dat extra beveiligde systeem met beperkte toegang is een beheerder vrijwel onzichtbaar voor mogelijke aanvallers en dat is belangrijk. Om het nut te maximaliseren moeten in het algemeen dat systeem met beperkte toegang best veel rechten gegeven worden op de andere machines in het netwerk, vaak via een alleen-lezen NFS-export van de andere machines naar het systeem met beperkte toegang of door ssh sleutelparen in te stellen om het systeem met beperkte toegang een ssh verbinding te laten maken met de andere machines. Buiten het netwerkverkeer, is NFS de minst zichtbare methode. Hierdoor kunnen de bestandssystemen op alle cliëntmachines vrijwel ongezien gemonitord worden. Als de server met beperkte toegang verbonden is met de cliëntmachines via een switch, dan is de NFS-methode vaak de beste keus. Als de server met beperkte toegang met de andere machines is verbonden via een hub of door meerdere routers, dan is de NFS-methode wellicht niet veilig genoeg (vanuit een netwerk standpunt) en kan beter ssh gebruikt worden, ondanks de audit-sporen die ssh achterlaat.

Als de machine met beperkte toegang eenmaal minstens leestoegang heeft tot een cliëntsysteem dat het moet gaan monitoren, dan moeten scripts gemaakt worden om dat monitoren ook echt uit te voeren. Uitgaande van een NFS-koppeling, kunnen de scripts gebruik maken van eenvoudige systeem hulpprogramma's als man:find[1] en man:md5[1]. We adviseren minstens één keer per dag een md5 te maken van alle bestanden op de cliëntmachine en van instellingenbestanden als in [.filename]#/etc# en [.filename]#/usr/local/etc# zelfs vaker. Als er verschillen worden aangetroffen ten opzichte van de basis md5 informatie op het systeem met beperkte toegang, dan hoort het script te gillen om een beheerder die het moet gaan uitzoeken. Een goed beveiligingsscript controleert ook op onverwachte suid-bestanden en op nieuwe en verwijderde bestanden op systeempartities als [.filename]#/# en [.filename]#/usr#.

Als ssh in plaats van NFS wordt gebruikt, dan is het schrijven van het script lastiger. Dan moeten de scripts met `scp` naar de cliënt verplaatst worden om ze uit te voeren, waardoor ze zichtbaar worden. Voor de veiligheid dienen ook de binaire bestanden die het script gebruikt, zoals man:find[1], gekopieerd te worden. De ssh-cliënt op de cliënt zou al gecompromitteerd kunnen zijn. Het is misschien noodzakelijk ssh te gebruiken over onveilige verbindingen, maar dat maakt alles een stuk lastiger.

Een goed beveiligingsscript voert ook controles uit op de instellingenbestanden van gebruikers en medewerkers: [.filename]#.rhosts#, [.filename]#.shosts#, [.filename]#.ssh/authorized_keys#, enzovoort. Dat zijn bestanden die buiten het bereik van de `MD5`-controle vallen.

Als gebruikers veel schijfruimte hebben, dan kan het te lang duren om alle bestanden op deze partitie te controleren. In dat geval is het verstandig de koppelvlaggen zo in te stellen dat suid-binaire bestanden op die partities niet zijn toegestaan. Zie daarvoor de optie `nosuid` (zie man:mount[8]). Die partities moeten wel toch nog minstens eens per week doorzocht worden, omdat het doel van deze beveiligingslaag het ontdekken van een inbraakpoging is, of die nu succesvol is of niet.

Procesverantwoording (zie man:accton[8]) kost relatief gezien weinig en kan bijdragen aan een evaluatie mechanisme voor na inbraken. Het is erg handig om uit te zoeken hoe iemand precies heeft ingebroken op het systeem, mits het bestand nog onbeschadigd is na de inbraak.

Tenslotte horen beveiligingsscripts de logboekbestanden te verwerken en de logboekbestanden zelf horen zo veilig mogelijk tot stand te komen. "remote syslog" kan erg zinvol zijn. Een aanvaller zal proberen zijn sporen uit te wissen en logboekbestanden zijn van groot belang voor een systeembeheerder als het gaat om uitzoeken wanneer en hoe er is ingebroken. Een manier om logboekbestanden veilig te stellen is door het systeemconsole via een seriële poort aan te sluiten op een veilige machine en zo informatie te verzamelen.

=== Paranoia

Een beetje paranoia is niet verkeerd. Eigenlijk kan de systeembeheerder zoveel beveiligingsopties inschakelen als hij wil, als deze maar geen impact hebben op het gebruiksgemak en de beveiligingsopties die _wel_ impact hebben op het gebruiksgemak kunnen ingeschakeld worden als daar zorgvuldig mee wordt omgegaan. Nog belangrijker is misschien dat er een juiste combinatie wordt gevonden. Als de aanbevelingen uit dit document woord voor woord worden opgevolgd, dan worden daarmee de methodes aan een toekomstige aanvaller verraden, die ook toegang heeft tot dit document.

=== Ontzeggen van Dienst aanvallen

In deze paragraaf worden Ontzeggen van Dienst aanvallen ("Denial of Service" of DoS) behandeld. Een DoS-aanval wordt meestal uitgevoerd als pakketaanval. Hoewel er weinig gedaan kan worden tegen de huidige aanvallen met gefingeerde pakketten die een netwerk kunnen verzadigen, kan de schade geminimaliseerd worden door ervoor te zorgen dat servers er niet door plat gaan door:

. Limiteren van server forks.
. Limiteren van springplank ("springboard") aanvallen (ICMP response aanvallen, ping broadcast, etc.).
. De Kernel Route Cache overloaden.

Een veelvoorkomende DoS-aanval is om een server aan te vallen door het zoveel kindprocessen aan te laten maken dat het hostsysteem uiteindelijk geen bestandsdescriptors, geheugen enzovoort meer heeft en het dan opgeeft. inetd (zie man:inetd[8]) kent een aantal instellingen om dit type aanval af te zwakken. Hoewel het mogelijk is ervoor te zorgen dat een machine niet plat gaat, is het in het algemeen niet mogelijk te voorkomen dat de dienstverlening door de aanval wordt verstoord. Meer is te lezen in de handleiding van inetd en het advies is in het bijzonder aandacht aan de `-c`, `-C` en `-R` opties te besteden. Aanvallen met gefingeerde IP adressen omzeilen de `-C` optie naar inetd, dus in het algemeen moet een combinatie van opties gebruikt worden. Sommige op zichzelf staande servers hebben parameters waarmee het aantal forks gelimiteerd kan worden.

Sendmail heeft de optie `-OMaxDaemonChildren` die veel beter blijkt te werken dan het gebruik van de opties van Sendmail waarmee de werklast gelimiteerd kan worden. De parameter `MaxDaemonChildren` moet zodanig ingesteld worden dat als sendmail start; deze hoog genoeg is om de te verwachten belasting aan te kunnen, maar niet zo hoog is dat de computer het aantal instanties van Sendmails niet aankan zonder plat te gaan. Het is ook verstandig om Sendmail in de wachtrijmodus (`-ODeliveryMode=queued`) te draaien en de daemon (`sendmail -bd`) los te koppelen van de verwerking van de wachtrij (`sendmail -q15m`). Als de verwerking van wachtrij real-time moet, kunnen de tussenpozen voor verwerking verkort worden door deze bijvoorbeeld op `-q1m` in te stellen, maar dan is een redelijke instelling van `MaxDaemonChildren` van belang om _die_ Sendmail te beschermen tegen trapsgewijze fouten.

Syslogd kan direct aangevallen worden en het is sterk aan te raden de `-s` optie te gebruiken waar dat ook maar mogelijk is en anders de `-a` optie.

Er dient voorzichtig omgesprongen te worden met diensten die terugverbinden zoals TCP Wrapper's reverse-identd die direct aangevallen kan worden. In het algemeen is het hierom onverstandig gebruik te maken van de reverse-ident optie van TCP Wrapper.

Het is een goed idee om interne diensten af te schermen voor toegang van buitenaf door ze te firewallen op de routers aan de rand van een netwerk ("border routers"). Dit heeft als achtergrond dat verzadigingsaanvallen voorkomen van buiten het LAN voorkomen kunnen worden. Daarmee wordt geen aanval op `root` via het netwerk en die diensten daaraan voorkomen. Er dient altijd een exclusieve firewall te zijn, dat wil zeggen "firewall alles _behalve_ poorten A, B, C, D en M-Z". Zo worden alle lage poorten gefirewalled behalve die voor specifieke diensten als named (als er een primary is voor een zone), ntalkd, sendmail en andere diensten die vanaf Internet toegankelijk moeten zijn. Als de firewall andersom wordt ingesteld, als een inclusieve of tolerante firewall, dan is de kans groot dat er wordt vergeten een aantal diensten af te "sluiten" of dat er een nieuwe interne dienst wordt toegevoegd en de firewall niet wordt bijgewerkt. Er kan nog steeds voor gekozen worden de hoge poorten open te zetten, zodat een tolerante situatie ontstaat, zonder de lage poorten open te stellen. FreeBSD biedt ook de mogelijkheid een reeks poortnummers die gebruikt worden voor dynamische verbindingen in te stellen via de verscheidene `net.inet.ip.portrange``sysctl`s (`sysctl -a | fgrep portrange`), waardoor ook de complexiteit van de firewall instellingen kan vereenvoudigen. Zo kan bijvoorbeeld een normaal begin tot eindbereik ingesteld worden van 4000 tot 5000 en een hoog poortbereik van 49152 tot 65535. Daarna kan alles onder 4000 op de firewall geblokkeerd worden (met uitzondering van bepaalde poorten die vanaf Internet bereikbaar moeten zijn natuurlijk).

Een andere veelvoorkomende DoS-aanval is de springplankaanval: een server zo aanvallen dat de respons van die server de server zelf, het lokale netwerk of een andere machine overbelast. De meest voorkomende aanval van dit type is de _ICMP ping broadcast aanval_. De aanvaller fingeert ping-pakketten die naar het broadcast-adres van het LAN worden gezonden met als bron het IP-adres van de machine die hij eigenlijk aan wil vallen. Als de routers aan de rand van het netwerk niet zijn ingesteld om een ping-pakketten aan een broadcast-adres te blokkeren, dan kan het LAN genoeg antwoorden produceren om de verbinding van het slachtoffer (het gefingeerde bronadres) te verzadigen, zeker als de aanvaller hetzelfde doet met tientallen andere netwerken. Broadcastaanvallen met een volume van meer dan 120 megabit zijn al voorgekomen. Een tweede springplankaanval is er een tegen het ICMP-foutmeldingssysteem. Door een pakket te maken waarop een ICMP-foutmelding komt, kan een aanvaller de inkomende verbinding van een server verzadigen en de uitgaande verbinding laten verzadigen met ICMP-foutmeldingen. Dit type aanval kan een server ook laten crashen door te zorgen dat het geheugen ervan vol zit, zeker als de server de ICMP-antwoorden niet zo snel kwijt kan als dat het ze genereert. Gebruik de sysctl-variabele `net.inet.icmp.icmplim` om deze aanvallen te beperken. De laatste belangrijke klasse springplankaanvallen hangt samen met een aantal interne diensten van inetd zoals de UDP-echodienst. Een aanvaller fingeert eenvoudigweg een UDP-pakket met als bronadres de echopoort van Server A en als bestemming de echopoort van Server B, waar Server A en B allebei op een LAN staan. Die twee servers gaan dat pakket dan heen en weer kaatsen. Een aanvaller kan beide servers overbelasten door een aantal van deze pakketten te injecteren. Soortgelijke problemen kunnen ontstaan met de poort chargen. Een competente systeembeheerder zal al deze interne inetd testdiensten uitschakelen.

Gefingeerde pakketten kunnen ook gebruikt worden om de kernel route cache te overbelasten. Raadpleeg daarvoor de `net.inet.ip.rtexpire`, `rtminexpire` en `rtmaxcache``sysctl` parameters. Een aanval met gefingeerde pakketten met een willekeurig bron-IP zorgt ervoor dat de kernel een tijdelijke gecachede route maakt in de routetabel, die uitgelezen kan worden met `netstat -rna | fgrep W3`. Deze routes hebben een levensduur van ongeveer 1600 seconden. Als de kernel merkt dat de gecachede routetabel te groot is geworden, dan wordt `rtexpire` dynamisch verkleind, maar deze waarde wordt nooit lager dan `rtminexpire`. Er zijn twee problemen:

. De kernel reageert niet snel genoeg als een laag belaste server wordt aangevallen.
. `rtminexpire` is niet laag genoeg om de kernel de aanval te laten overleven.

Als servers verbonden zijn met het Internet via een E3 of sneller, dan is het verstandig om handmatig `rtexpire` en `rtminexpire` aan te passen via man:sysctl[8]. Als de een van de parameters op nul wordt gezet, dan crasht de machine. Het instellen van beide waarden op 2 seconden is voldoende om de routetabel tegen een aanval te beschermen.

=== Aandachtspunten voor toegang met Kerberos en SSH

Er zijn een aantal aandachtspunten die in acht genomen moeten worden als Kerberos of ssh gebruikt worden. Kerberos 5 is een prima autenticatieprotocol, maar er zitten bugs in de Kerberos-versies van telnet en rlogin waardoor ze niet geschikt zijn voor binair verkeer. Kerberos codeert standaard de sessie niet, tenzij de optie `-x` wordt gebruikt. ssh codeert standaard wel alles.

Ssh werkt prima, maar het stuurt coderingssleutels standaard door. Dit betekent dat als gegeven een veilig werkstation met sleutels die toegang geven tot de rest van het systeem en ssh wordt gebruikt om verbinding te maken met een onveilige machine, die sleutels gebruikt kunnen worden. De sleutels zelf zijn niet bekend, maar ssh stelt een doorstuurpoort in zolang als een gebruikers aangemeld blijft. Als de aanvaller `root`toegang heeft op de onveilige machine, dan kan hij die poort gebruiken om toegang te krijgen tot alle machines waar de sleutels van de gebruiker toegang toe geven.

Het advies is ssh in combinatie met Kerberos te gebruiken voor het aanmelden door medewerkers wanneer dat ook maar mogelijk is. Ssh kan gecompileerd worden met Kerberos-ondersteuning. Dit vermindert de kans op blootstelling van ssh-sleutels en beschermt tegelijkertijd de wachtwoorden met Kerberos. Ssh-sleutels zouden alleen gebruikt moeten worden voor geautomatiseerde taken vanaf veilige machines (iets waar Kerberos ongeschikt voor is). Het advies is om het doorsturen van sleutels uit te schakelen in de ssh-instellingen of om de `from=IP/DOMAIN` optie te gebruiken die ssh in staat stelt het bestand [.filename]#authorized_keys# te gebruiken om de sleutel alleen bruikbaar te maken voor entiteiten die zich aanmelden vanaf vooraf aangewezen machines.

[[crypt]]
== DES, Blowfish, MD5, SHA256, SHA512 en crypt

Iedere gebruiker op een UNIX(R) systeem heeft een wachtwoord bij zijn account. Het lijkt voor de hand liggend dat deze wachtwoorden alleen bekend horen te zijn bij de gebruiker en het eigenlijke besturingssysteem. Om deze wachtwoorden geheim te houden, zijn ze gecodeerd in een "eenweg hash" ("one-way hash"), wat betekent dat ze eenvoudig gecodeerd kunnen worden maar niet gedecodeerd. Met andere woorden, wat net gesteld werd is helemaal niet waar: het besturingssysteem kent het _echte_ wachtwoord niet. De enige manier om een wachtwoord in "platte tekst" te verkrijgen, is door er met brute kracht naar te zoeken in alle mogelijke wachtwoorden.

Helaas was DES, de Data Encryption Standard, de enige manier om wachtwoorden veilig te coderen toen UNIX(R) ontstond. Dit was geen probleem voor gebruikers in de VS, maar omdat de broncode van DES niet geëxporteerd mocht worden moest FreeBSD een manier vinden om zowel te gehoorzamen aan de wetten van de Verenigde Staten als aansluiting te houden bij alle andere varianten van UNIX(R) die nog steeds DES gebruikten.

De oplossing werd gevonden in het splitsen van de coderingsbibliotheken zodat gebruikers in de Verenigde Staten de DES-bibliotheken konden installeren en gebruiken en internationale gebruikers een coderingsmethode konden gebruiken die geëxporteerd mocht worden. Zo is het gekomen dat FreeBSD MD5 is gaan gebruiken als coderingsmethode. Van MD5 wordt aangenomen dat het veiliger is dan DES, dus de mogelijkheid om DES te installeren is vooral beschikbaar om aansluiting te kunnen houden.

=== Het crypt-mechanisme herkennen

Op dit moment ondersteunt de bibliotheek DES, MD5, Blowfish, SHA256 en SHA512 hashfuncties. Standaard gebruikt FreeBSD 9.1 en nieuwer SHA512 om wachtwoorden te coderen. Oudere versies gebruiken standaard MD5.

Het is vrij makkelijk om uit te vinden welke coderingsmethode FreeBSD op een bepaald moment gebruikt. De gecodeerde wachtwoorden in [.filename]#/etc/master.passwd# bekijken is een manier. Wachtwoorden die gecodeerd zijn met MD5 zijn langer dan wanneer ze gecodeerd zijn met DES-hash. Daarnaast beginnen ze met de karakters `$1$`. Wachtwoorden die beginnen met `$2a$` zijn gecodeerd met de Blowfish hashfunctie. DES-wachtwoordstrings hebben geen bijzondere kenmerken, maar ze zijn korter dan MD5 wachtwoorden en gecodeerd in een 64-karakter alfabet waar geen `$` karakter in zit. Een relatief korte string die niet begint met een dollar teken is dus waarschijnlijk een DES-wachtwoord. Zowel SHA256 als SHA512 beginnen met de tekens `$6$`.

Het wachtwoordformaat voor nieuwe wachtwoorden wordt ingesteld met de `passwd_format` aanmeldinstelling in [.filename]#/etc/login.conf# waar `des`, `md5`, `blf`, `sha256` of `sha512` in mag staan. Zie de man:login.conf[5] handleiding voor meer informatie over aanmeldinstellingen.

[[one-time-passwords]]
== Eenmalige wachtwoorden

Standaard biedt FreeBSD ondersteuning voor OPIE (Eenmalige Wachtwoorden in Alles - "One-time Passwords In Everything"), wat standaard een MD5-hash gebruikt.

Hier worden drie verschillende soorten wachtwoorden besproken. De eerste is het normale UNIX(R) of Kerberos wachtwoord. Dit heet het "UNIX(R) wachtwoord". Het tweede type is een eenmalig wachtwoord dat wordt gemaakt met het OPIE-programma man:opiekey[1] en dat wordt geaccepteerd door man:opiepasswd[1] en de aanmeldprocedure. Dit heet het "eenmalige wachtwoord". Het laatste type wachtwoord is het wachtwoord dat wordt opgegeven aan het programma `opiekey` (en soms aan het programma `opiepasswd`) dat gebruikt wordt om eenmalige wachtwoorden te maken. Dit type heet "geheim wachtwoord" of gewoon een "wachtwoord" zonder toevoeging.

Het geheime wachtwoord heeft niets te maken met het UNIX(R) wachtwoord; ze kunnen hetzelfde zijn, dat wordt afgeraden. OPIE geheime wachtwoorden kennen niet de beperking van 8 karakters zoals de oude UNIX(R) wachtwoorden.  Ze mogen onbeperkt lang zijn. Wachtwoorden van een zes of zeven woorden lange zin zijn niet ongewoon. Voor het overgrote deel werkt het OPIE-systeem volledig onafhankelijk van het UNIX(R) wachtwoordsysteem.

Buiten het wachtwoord zijn er nog twee stukjes gegevens die van belang zijn voor OPIE. Het eerste wordt "zaad" ("seed") of "sleutel" ("key") genoemd en bestaat uit twee letters en vijf cijfers. Het tweede stukje gegevens heet de "iteratieteller", een nummer tussen 1 en 100. OPIE maakt een eenmalig wachtwoord door het zaad en het geheime wachtwoord aaneen te schakelen en daarop het door de iteratieteller aangegeven keren MD5-hash toe te passen. Daarna wordt het resultaat omgezet in zes korte Engelse woorden. Deze zes woorden zijn een eenmalige wachtwoord. Het autenticatiesysteem (hoofdzakelijk PAM) houdt bij welk eenmalig wachtwoord het laatst is gebruikt en de gebruiker wordt geautenticeerd als de hash van het door de gebruiker ingegeven wachtwoord gelijk is aan het vorige wachtwoord. Omdat er een eenweg hash wordt gebruikt, is het onmogelijk om toekomstige eenmalige wachtwoorden te maken als iemand toch een eenmalig wachtwoord heeft afgevangen. De iteratieteller wordt verlaagd na iedere succesvolle aanmelding om de gebruiker en het aanmeldprogramma synchroon te houden. Als de iteratieteller op 1 staat, moet OPIE opnieuw ingesteld worden.

Er zijn enkele programma's bij ieder systeem betrokken die hieronder worden besproken. Het programma `opiekey` heeft een iteratieteller, zaad en een geheim wachtwoord nodig en maakt dan een eenmalig wachtwoord of een lijst van opeenvolgende eenmalige wachtwoorden. Het programma `opiepasswd` wordt gebruikt om OPIE te initialiseren en om wachtwoorden, iteratietellers en zaad te wijzigen. Het accepteert zowel wachtwoordzinnen als een iteratieteller, zaad en een eenmalig wachtwoord. Het programma `opieinfo` bekijkt de relevante bestanden waarin de eigenschappen staan ([.filename]#/etc/opiekeys#) en toont de huidige iteratieteller en zaad van de gebruiker die het commando uitvoert.

Nu worden vier verschillende acties besproken. Bij de eerste wordt `opiepasswd` gebruikt in een beveiligde verbinding om voor het eerst eenmalige wachtwoorden in te stellen of om een wachtwoord of zaad aan te passen. Bij de tweede wordt `opiepasswd` gebruikt over een onbeveiligde verbinding samen met `opiekey` over een beveiligde verbinding om hetzelfde te bereiken. In een derde scenario wordt `opiekey` gebruikt om aan te melden over een onveilige verbinding. Het vierde scenario behandelt het gebruik van `opiekey` om een aantal sleutels aan te maken die opgeschreven of afgedrukt kunnen worden, zodat ze meegenomen kunnen worden naar een plaats van waar geen enkele veilige verbinding opgezet kan worden.

=== Veilige verbinding initialiseren

Gebruik het commando `opiepasswd` om OPIE voor de eerste keer te initialiseren:

[source,shell]
....
% opiepasswd -c
[grimreaper] ~ $ opiepasswd -f -c
Adding unfurl:
Only use this method from the console; NEVER from remote. If you are using
telnet, xterm, or a dial-in, type ^C now or exit with no password.
Then run opiepasswd without the -c parameter.
Using MD5 to compute responses.
Enter new secret pass phrase:
Again new secret pass phrase:

ID unfurl OTP key is 499 to4268
MOS MALL GOAT ARM AVID COED
....

Als `Enter new secret pass phrase:` of `Enter secret password:` op het scherm verschijnt, dient een wachtwoord of wachtwoordzin ingevoerd te worden. Dit is dus niet het aanmeldwachtwoord is, maar dit wordt gebruikt om eenmalige wachtwoorden te maken. De "ID" regel geeft de parameters van het verzoek weer: de aanmeldnaam, de iteratieteller en zaad. Bij het aanmelden kent het systeem deze parameters en worden deze weergegeven zodat ze niet onthouden hoeven te worden. Op de laatste regel staat het eenmalige wachtwoord dat overeenkomt met die parameters en het geheime wachtwoord. Als de gebruiker direct opnieuw zou aanmelden, zou hij dat eenmalige wachtwoord moeten gebruiken.

=== Onveilige verbinding initialiseren

Om een wachtwoord te initialiseren of te wijzigen over een onveilige verbinding, moet er al ergens een veilige verbinding bestaan waar de gebruiker `opiekey` kan uitvoeren. Dit kan een shellprompt zijn op een machine die vertrouwd wordt. De gebruiker moet ook een iteratieteller verzinnen (100 is wellicht een prima getal) en een eigen zaad bedenken of er een laten fabriceren. Over de onveilige verbinding (naar de machine die de gebruiker wil initialiseren) wordt het commando `opiepasswd` gebruikt:

[source,shell]
....
% opiepasswd

Updating unfurl:
You need the response from an OTP generator.
Old secret pass phrase:
	otp-md5 498 to4268 ext
	Response: GAME GAG WELT OUT DOWN CHAT
New secret pass phrase:
	otp-md5 499 to4269
	Response: LINE PAP MILK NELL BUOY TROY

ID mark OTP key is 499 gr4269
LINE PAP MILK NELL BUOY TROY
....

Druk op kbd:[Return] om het standaardzaad te accepteren. Voor een toegangswachtwoord wordt ingevoerd, dient eerst gewisseld te worden naar de veilige verbinding en dienen dezelfde parameters ingegeven te worden:

[source,shell]
....
% opiekey 498 to4268
Using the MD5 algorithm to compute response.
Reminder: Don't use opiekey from telnet or dial-in sessions.
Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT
....

In de onveilige verbinding wordt nu het eenmalige wachtwoord in het relevante programma gekopieerd.

=== Een enkel eenmalig wachtwoord maken

Als OPIE eenmaal is ingesteld staat er bij het aanmelden iets als het volgende:

[source,shell]
....
% telnet example.com
Trying 10.0.0.1...
Connected to example.com
Escape character is '^]'.

FreeBSD/i386 (example.com) (ttypa)

login: <gebruikersnaam>
otp-md5 498 gr4269 ext
Password: 
....

NB: de OPIE-prompt heeft een handige optie (die hier niet te zien is): als er op kbd:[Return] wordt gedrukt bij de wachtwoordregel, wordt de echo aangezet, zodat de invoer zichtbaar is. Dit is erg handig als er met de hand een wachtwoord wordt ingegeven, zoals wanneer het wordt ingevoerd vanaf een afdruk.

Nu moet het eenmalige wachtwoord gemaakt worden om het aanmeldprompt mee te antwoorden. Dit moet gedaan worden op een vertrouwd systeem waarop `opiekey` beschikbaar is. Er zijn ook versies voor MS-DOS(R), Windows(R) en Mac OS(R). Voor het commando moet zowel de iteratieteller als het zaad ingeven worden op de commandoregel. Deze kan zo overgenomen worden vanaf het aanmeldprompt op de machine waarop de gebruiker zich wil aanmelden.

Op het vertrouwde systeem:

[source,shell]
....
% opiekey 498 to4268
Using the MD5 algorithm to compute response.
Reminder: Don't use opiekey from telnet or dial-in sessions.
Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT
....

Nu het eenmalige wachtwoord er is, kan het aanmelden doorgang vinden.

=== Meerdere eenmalige wachtwoorden maken

Soms moet een gebruiker ergens naar toe gaan waar er geen toegang is tot een vertrouwde machine of een beveiligde verbinding. In dat geval is het mogelijk om met het commando `opiekey` een aantal eenmalige wachtwoorden te maken om uit te printen en mee te nemen:

[source,shell]
....
% opiekey -n 5 30 zz99999
Using the MD5 algorithm to compute response.
Reminder: Don't use opiekey from telnet or dial-in sessions.
Enter secret pass phrase: <geheim wachtwoord>
26: JOAN BORE FOSS DES NAY QUIT
27: LATE BIAS SLAY FOLK MUCH TRIG
28: SALT TIN ANTI LOON NEAL USE
29: RIO ODIN GO BYE FURY TIC
30: GREW JIVE SAN GIRD BOIL PHI
....

Met `-n 5` worden vijf opeenvolgende sleutels aangevraagd, `30` geeft aan wat het laatste iteratiegetal moet zijn. Deze wachtwoorden worden weergegeven in _omgekeerde_ volgorde voor gebruik. Als de gebruiker echt paranoïde bent kan hij ze opschrijven of hij kan er ook voor kiezen ze af te drukken met `lpr`. Op iedere regel staat dus de iteratieteller en het eenmalige wachtwoord, maar misschien is het toch handig om ze na gebruik af te strepen.

=== Gebruik van UNIX(R) wachtwoorden beperken

Met OPIE kan paal en perk gesteld worden aan het gebruik van UNIX(R) wachtwoorden op basis van het IP-adres van een aanmeldsessie. Dat kan met het bestand [.filename]#/etc/opieaccess# dat standaard aanwezig is. Bij man:opieaccess[5] staat meer informatie over dit bestand en welke beveiligingsoverwegingen bestaan bij het gebruik.

Hieronder een voorbeeld voor een [.filename]#opieaccess# bestand:

[.programlisting]
....
permit 192.168.0.0 255.255.0.0
....

In deze regel (`permit Internet`) staat dat gebruikers met een bron IP adres (wat gefingeerd kan worden) dat past binnen de aangegeven waarde en masker altijd UNIX(R) wachtwoorden mogen gebruiken.

Als geen van de regels uit [.filename]#opieaccess# van toepassing is, worden standaard pogingen zonder OPIE geweigerd.

[[tcpwrappers]]
== TCP Wrappers

Iedereen die bekend is met man:inetd[8] heeft waarschijnlijk wel eens van TCP Wrappers gehoord. Maar slechts weinigen lijken volledig te begrijpen hoe ze in een netwerkomgeving toegepast kunnen worden. Het schijnt dat iedereen een firewall wil hebben om netwerkverbindingen af te handelen. Ondanks dat een firewall veel kan, zijn er toch dingen die het niet kan, zoals tekst terugsturen naar de bron van een verbinding. De TCP Wrappers software kan dat en nog veel meer. In dit onderdeel worden de mogelijkheden van TCP Wrappers besproken en, waar dat van toepassing is, worden ook voorbeelden voor implementatie gegeven.

De TCP Wrappers software vergroot de mogelijkheden van inetd door de mogelijkheid al zijn serverdaemons te controleren. Met deze methode is het mogelijk om te loggen, berichten te zenden naar verbindingen, een daemon toe te staan alleen interne verbindingen te accepteren, etc. Hoewel een aantal van deze mogelijkheden ook ingesteld kunnen worden met een firewall, geeft deze manier niet alleen een extra laag beveiliging, maar gaat dit ook verder dan wat een firewall kan bieden.

De toegevoegde waarde van TCP Wrappers is niet dat het een goede firewall vervangt. TCP Wrappers kunnen samen met een firewall en andere beveiligingsinstellingen gebruikt worden om een extra laag van beveiliging voor het systeem te bieden.

Omdat dit een uitbreiding is op de instellingen van inetd, wordt aangenomen dat de lezer het onderdeel crossref:network-servers[network-inetd,inetd configuratie] heeft gelezen.

[NOTE]
====
Hoewel programma's die onder man:inetd[8] draaien niet echt "daemons" zijn, heten ze traditioneel wel zo. Deze term wordt hier dus ook gebruikt.
====

=== Voor het eerst instellen

De enige voorwaarde voor het gebruiken van TCP Wrappers in FreeBSD is ervoor te zorgen dat de server inetd gestart wordt vanuit [.filename]#rc.conf# met de optie `-Ww`; dit is de standaardinstelling. Er wordt vanuit gegaan dat [.filename]#/etc/hosts.allow# juist is ingesteld, maar als dat niet zo is, dan zal man:syslogd[8] dat melden.

[NOTE]
====
In tegenstelling tot bij andere implementaties van TCP Wrappers is het gebruik van [.filename]#hosts.deny# niet langer mogelijk. Alle instellingen moeten in [.filename]#/etc/hosts.allow# staan.
====

In de meest eenvoudige instelling worden verbindingen naar daemons toegestaan of geweigerd afhankelijk van de opties in [.filename]#/etc/hosts.allow#. De standaardinstelling in FreeBSD is verbindingen toe te staan naar iedere daemon die met inetd is gestart. Na de basisinstelling wordt aangegeven hoe dit gewijzigd kan worden.

De basisinstelling heeft meestal de vorm `daemon : adres : actie`. `daemon` is de daemonnaam die `inetd` heeft gestart. Het `adres` kan een geldige hostnaam, een IP-adres of een IPv6-adres tussen blokhaken ([ ]) zijn. Het veld `actie` kan `allow` of `deny` zijn, afhankelijk van of toegang toegestaan of geweigerd moet worden. De instellingen werken zo dat ze worden doorlopen van onder naar boven om te kijken welke regel als eerste van toepassing is. Als een regel van toepassing is gevonden, dan stop het zoekproces.

Er zijn nog andere mogelijkheden, maar die worden elders toegelicht. Een eenvoudige instelling kan al van met deze informatie worden gemaakt. Om bijvoorbeeld POP3 verbindingen toe te staan via de package:mail/qpopper[] daemon, zouden de volgende instellingen moeten worden toegevoegd aan [.filename]#hosts.allow#:

[.programlisting]
....
# Deze regel is nodig voor POP3-verbindingen
qpopper : ALL : allow
....

Nadat deze regel is toegevoegd moet inetd herstart worden door gebruik te maken van man:service[8]:

[source,shell]
....
# service inetd restart
....

=== Gevorderde instellingen

TCP Wrappers hebben ook gevorderde instellingen. Daarmee komt meer controle over de wijze waarop er met verbindingen wordt omgegaan. Soms is het een goed idee om commentaar te sturen naar bepaalde hosts of daemonverbindingen. In andere gevallen moet misschien iets in een logboekbestand geschreven worden of een email naar de beheerder gestuurd worden. Dit kan allemaal met instellingen die `wildcards`, uitbreidingskarakters (expansion characters) en het uitvoeren van externe commando's heten. De volgende twee paragrafen beschrijven deze mogelijkheden.

==== Externe commando's

Stel dat zich de situatie voordoet waar een verbinding geweigerd moet worden, maar er een reden gestuurd moet worden naar het individu dat die verbinding probeerde op te zetten. Hoe gaat dat? Dat is mogelijk door gebruik te maken van de optie `twist`. Als er een poging tot verbinding wordt gedaan, wordt er met `twist` een shellcommando of script uitgevoerd. Er staat al een voorbeeld in [.filename]#hosts.allow#:

[.programlisting]
....
# De andere daemons zijn beschermd.
ALL : ALL \
	: severity auth.info \
	: twist /bin/echo "You are not welcome to use %d from %h."
....

Dit voorbeeld geeft aan dat het bericht "You are not allowed to use `daemon` from `hostname`." wordt teruggestuurd voor iedere daemon die niet al is ingesteld in het toegangsbestand. Het is erg handig om een antwoord terug te sturen naar degene die een verbinding op heeft willen zetten meteen nadat een tot stand gekomen verbinding is verbroken. Let wel dat alle berichten die gezonden worden _moeten_ staan tussen `"` karakters. Hier zijn geen uitzonderingen op.

[WARNING]
====

Het is mogelijk een ontzegging van dienst aanval uit te voeren op de server als een aanvaller, of een groep aanvallers, deze daemons kan overstromen met verzoeken om verbindingen te maken.
====

Het is ook mogelijk hier de optie `spawn` te gebruiken. Net als `twist` weigert de optie `spawn` impliciet de verbinding en kan het gebruikt worden om shellcommando's of scripts uit te voeren. Anders dan bij `twist` stuurt `spawn` geen bericht aan degene die de verbinding wilde maken. Zie bijvoorbeeld de volgende instelling:

[.programlisting]
....
# Geen verbindingen van example.com:
ALL : .example.com \
	: spawn (/bin/echo %a from %h attempted to access %d >> \
	  /var/log/connections.log) \
	: deny
....

Hiermee worden alle verbindingen van het domein `*.example.com` geweigerd. Tegelijkertijd worden ook hostnaam, IP adres en de daemon waarmee verbinding werd gemaakt naar [.filename]#/var/log/connections.log# geschreven.

Naast de vervangingskarakters die al zijn toegelicht, zoals `%a`, bestaan er nog een paar andere. In de handleiding van man:hosts_access[5] staat een volledige lijst.

==== Wildcardopties

Tot nu toe is in ieder voorbeeld `ALL` gebruikt. Er bestaan nog andere opties waarmee de mogelijkheden nog verder gaan. Zo kan `ALL` gebruikt worden om van toepassing te zijn op iedere instantie van een daemon, domein of een IP adres. Een andere wildcard die gebruikt kan worden is `PARANOID`. Daarmee wordt iedere host die een IP-adres geeft dat gefingeerd kan zijn aangeduid. Met andere woorden: `PARANOID` kan gebruikt worden om een actie aan te geven als er een IP-adres gebruikt wordt dat verschilt van de hostnaam. Het volgende voorbeeld kan wat verheldering brengen:

[.programlisting]
....
# Weiger mogelijke gespoofte verzoeken aan sendmail:
sendmail : PARANOID : deny
....

In het voorgaande voorbeeld worden alle verbindingsverzoeken aan `sendmail` met een IP-adres dat verschilt van de hostnaam geweigerd.

[CAUTION]
====

Het gebruik van de wildcard `PARANOID` kan nogal wat schade aanrichten als de cliënt of de server kapotte DNS-instellingen heeft. Voorzichtigheid van de beheerder is geboden.
====

De handleiding van man:hosts_access[5] geeft meer uitleg over wildcards en de mogelijkheden die ze bieden.

Voordat de bovenstaande instellingen werken, dient de eerste regels in [.filename]#hosts.allow# als commentaar gemarkeerd te worden.

[[kerberos5]]
== Kerberos5

Kerberos is een netwerkdienst, protocol en systeem waarmee gebruikers zich kunnen aanmelden met behulp van een dienst op een veilige server. Diensten als op een andere server aanmelden, op afstand kopiëren, veilig tussen systemen kopiëren en andere taken met een hoog risico worden aanmerkelijk veiliger en beter controleerbaar.

Kerberos kan omschrijven worden als identiteitbevestigend proxy systeem. Het kan ook omschreven worden als een vertrouwd autenticatiesysteem van een derde partij. Kerberos vervult maar één taak: het veilig autenticeren van gebruikers op het netwerk. Het vervult geen autorisatietaken (wat gebruikers mogen) en controleert ook niets (wat gebruikers hebben gedaan). Nadat een cliënt en server Kerberos hebben gebruikt om hun identiteit vast te stellen kunnen ze ook al hun communicatie coderen om hun privacy en gegevensintegriteit te garanderen.

Daarom wordt het sterk aangeraden om Kerberos samen met andere beveiligingsmechanismen te gebruiken die autorisatie en controlemogelijkheden bieden.

De aanwijzingen die nu volgen kunnen gebruikt worden als werkinstructie om Kerberos in te stellen zoals dat wordt meegeleverd met FreeBSD. Een complete beschrijving staat in de handleiding.

Voor demonstratie van de installatie van Kerberos wordt gebruik gemaakt van de volgende naamgeving:

* Het DNS domein ("zone") is example.org.
* De Kerberos wereld is EXAMPLE.ORG.

[NOTE]
====
Het advies is voor installaties van Kerberos echte domeinnamen te gebruiken, zelfs als het alleen intern wordt gebruikt. Hiermee worden DNS problemen voorkomen is een goede samenwerking met andere Kerberos werelden verzekerd.
====

=== Geschiedenis

Kerberos is ontworpen door MIT als oplossing voor netwerkbeveiligingsproblemen. Het Kerberos protocol gebruikt sterke codering zodat een cliënt zijn identiteit kan bewijzen aan een server (en andersom) over een onveilige netwerkverbinding.

Kerberos is zowel de naam van een netwerkautorisatieprotocol als een bijvoeglijk naamwoord om de programma's te beschrijven die gebruik maken van het programma (zoals Kerberos telnet). De huidige versie van het protocol is versie 5 en is beschreven in RFC 1510.

Er zijn een aantal vrij beschikbare implementaties van dit protocol beschikbaar voor veel systemen. Het Massachusetts Institute of Technology (MIT), waar Kerberos ooit is ontwikkeld, ontwikkelt nog steeds door aan hun Kerberos pakket. Het wordt in de VS veel gebruikt als coderingspakket en daarom wordt het ook geraakt door de exportwetgeving van de VS. Kerberos van MIT is beschikbaar als port (package:security/krb5[]). Heimdal Kerberos is een andere implementatie van versie 5 die expliciet buiten de VS is ontwikkeld om de exportwetgeving de omzeilen (en wordt daarom vaak gebruikt in niet-commerciële UNIX(R) varianten). De Heimdal Kerberos distributie is beschikbaar als port (package:security/heimdal[]) en er zit een minimale installatie in de basisinstallatie van FreeBSD.

Om het grootst mogelijke publiek te bereiken gaan deze instructies ervan uit dat de Heimdal distributie die bij FreeBSD zit wordt gebruikt.

=== Opzetten van een Heimdal KDC

Het Sleutel Distributie Centrum (KDC, voluit "Key Distribution Center") is de gecentraliseerde autenticatiedienst die Kerberos levert. Het is de computer die Kerberos tickets uitgeeft. Het KDC wordt "vertrouwd" door alle andere computer in de Kerberos wereld en daarom dient er een strenger beveiligingsregime op van kracht te zijn.

Hoewel het draaien van de Kerberos dienst erg weinig van een systeem vraagt, wordt het wel aangeraden om een machine in te richten exclusief voor het KDC om beveiligingsredenen.

Het opzetten van een KDC begint met de controle of de instellingen in [.filename]#/etc/rc.conf# juist zijn om te functioneren als KDC (misschien moeten paden veranderd worden voor een eigen systeem):

[.programlisting]
....
kerberos5_server_enable="YES"
kadmind5_server_enable="YES"
....

Daarna wordt het Kerberos-instellingenbestand [.filename]#/etc/krb5.conf# aangemaakt:

[.programlisting]
....
[libdefaults]
    default_realm = EXAMPLE.ORG
[realms]
    EXAMPLE.ORG = {
        kdc = kerberos.example.org
        admin_server = kerberos.example.org
    }
[domain_realm]
    .example.org = EXAMPLE.ORG
....

[.filename]#/etc/krb5.conf# gaat ervan uit dat de KDC de volledig gekwalificeerde hostnaam `kerberos.example.org` heeft. Als de KDC een andere hostnaam heeft, moet er nog een CNAME (alias) toegevoegd aan de zonefile.

[NOTE]
====
Voor grotere netwerken met een juist ingestelde BINDDNS server kan het bovenstaande voorbeeld ingekort worden tot:

[.programlisting]
....
[libdefaults]
      default_realm = EXAMPLE.ORG
....

Door de volgende regels toe te voegen aan het zonebestand voor `example.org`:

[.programlisting]
....
_kerberos._udp      IN  SRV     01 00 88 kerberos.example.org.
_kerberos._tcp      IN  SRV     01 00 88 kerberos.example.org.
_kpasswd._udp       IN  SRV     01 00 464 kerberos.example.org.
_kerberos-adm._tcp  IN  SRV     01 00 749 kerberos.example.org.
_kerberos           IN  TXT     EXAMPLE.ORG
....

====

[NOTE]
====
Om cliënten de Kerberos-diensten te kunnen laten vinden, _moet_ er een volledig ingestelde [.filename]#/etc/krb5.conf# zijn of een minimaal ingestelde [.filename]#/etc/krb5.conf#_en_ een correct ingestelde DNS-server.
====

Nu wordt de Kerberos database aangemaakt. Deze database bevat de sleutels voor alle principals en zijn versleuteld met een hoofdwachtwoord. Dit wachtwoord hoeft niet onthouden te worden omdat het wordt opgeslagen in ([.filename]#/var/heimdal/m-key#). De hoofdsleutel wordt aangemaakt door `kstash` te starten en een wachtwoord in te voeren.

Als de hoofdsleutel is gemaakt, kan de database ingeschakeld worden met `kadmin` met de optie `-l` (die staat voor "local"). Deze optie geeft `kadmin` de opdracht om de databasebestanden direct te wijzigingen in plaats van via de `kadmind` netwerkdienst. Hiermee wordt het kip-ei-probleem opgelost waarbij een verbinding wordt gemaakt met de database voordat hij bestaat. Op het prompt van `kadmin` kan met `init` de database met de werelden aangemaakt worden.

Tenslotte, nog steeds in `kadmin`, kan de eerste principal gemaakt worden met `add`. De standaardopties voor de principal worden nu aangehouden. Deze kunnen later altijd nog gewijzigd worden met `modify`. Met het commando `?` kunnen alle beschikbare mogelijkheden getoond worden.

Hieronder een sessie waarin een voorbeelddatabase wordt aangemaakt:

[source,shell]
....
# kstash
Master key: xxxxxxxx
Verifying password - Master key: xxxxxxxx

# kadmin -l
kadmin> init EXAMPLE.ORG
Realm max ticket life [unlimited]:
kadmin> add tillman
Max ticket life [unlimited]:
Max renewable life [unlimited]:
Attributes []:
Password: xxxxxxxx
Verifying password - Password: xxxxxxxx
....

Nu kan de KDC dienst gestart worden met `service kerberos start` en `service kadmind start`. Op dit moment draait er nog geen enkele daemon die gebruik maakt van Kerberos. Bevestiging dat KDC draait is te krijgen door een ticket te vragen en dat uit te lezen voor de principal (gebruiker) die zojuist is aangemaakt vanaf de commandoregel van het KDC zelf:

[source,shell]
....
% kinit tillman
tillman@EXAMPLE.ORG's Password:

% klist
Credentials cache: FILE:/tmp/krb5cc_500
	Principal: tillman@EXAMPLE.ORG

  Issued           Expires          Principal
Aug 27 15:37:58  Aug 28 01:37:58  krbtgt/EXAMPLE.ORG@EXAMPLE.ORG
....

Het ticket kan worden ingenomen wanneer u klaar bent:

[source,shell]
....
% kdestroy
....

=== Kerberos inschakelen op een server met Heimdal diensten

Als eerste is een kopie van het instellingenbestand van Kerberos nodig, [.filename]#/etc/krb5.conf#. Dit bestand kan eenvoudigweg op een veilige manier (met netwerkprogramma's als man:scp[1], of fysiek via een floppy) naar de cliëntcomputer gekopieerd worden vanaf de KDC.

Hierna is het [.filename]#/etc/krb5.keytab# nodig. Dit is het belangrijkste verschil tussen een server die een daemons met Kerberos aanbiedt en een werkstation: de server heeft het bestand [.filename]#keytab# nodig. Dit bestand bevat de hostsleutel van de server waardoor het werkstation en de KDC elkaars identiteit kunnen bevestigen. Dit bestand dient veilig overgebracht te worden omdat de beveiliging van de server doorbroken kan worden als de sleutel openbaar wordt gemaakt. Dit betekent expliciet dat overdracht via een protocol dat platte tekst gebruikt, bijvoorbeeld FTP, een slecht idee is.

Meestal wordt [.filename]#keytab# naar de server gebracht met `kadmin`. Dat werkt handig omdat ook de host principal (het KDC onderdeel van [.filename]#krb5.keytab#) aangemaakt moet worden met `kadmin`.

Let wel op dat er al een ticket moet zijn en dat dit ticket de `kadmin` interface moet mogen gebruiken in [.filename]#kadmind.acl#. Zie "Beheer op Afstand" in de Heimdal informatiepagina's (`info heimdal`) voor details over het ontwerpen van toegangscontrole. Als `kadmin` via het netwerk geen toegang mag hebben, dan kan ook op een veilige verbinding gemaakt worden met de KDC (via het lokale console, man:ssh[1] of Kerberos man:telnet[1]) zodat alles lokaal uitgevoerd kan worden met `kadmin -l`.

Na het installeren van [.filename]#/etc/krb5.conf# kan `kadmin` van de Kerberos server gebruikt worden. Met `add --random-key` kan de host principal toegevoegd worden en met `ext` kan de host principal van de server naar zijn eigen keytab getrokken worden. Bijvoorbeeld:

[source,shell]
....
# kadmin
kadmin> add --random-key host/myserver.example.org
Max ticket life [unlimited]:
Max renewable life [unlimited]:
Attributes []:
kadmin> ext host/myserver.example.org
kadmin> exit
....

Let op: `ext` slaat de sleutel standaard op in [.filename]#/etc/krb5.keytab#.

Als `kadmind` niet beschikbaar is op de KDC (wellicht om beveiligingsredenen) en er via het netwerk dus geen toegang is tot `kadmin`, dan kan de host principal (`host/myserver.EXAMPLE.ORG`) ook direct aan de KDC toegevoegd worden en daarna in een tijdelijk bestand gezet worden. Het volgende kan gebruikt worden om te voorkomen dat [.filename]#/etc/krb5.keytab# op de KDC) wordt overschreven:

[source,shell]
....
# kadmin
kadmin> ext --keytab=/tmp/example.keytab host/myserver.example.org
kadmin> exit
....

Hierna kan de keytab veilig gekopieerd worden naar de server (met `scp` of een floppy). Geef een niet-standaard naam op voor de keytab om te voorkomen dat de keytab op de KDC wordt overschreven.

Nu kan de server communiceren met de KDC (vanweg [.filename]#krb5.conf#) en zijn identiteit bewijzen (vanwege [.filename]#krb5.keytab#). Nu is de server klaar om er een aantal Kerberos diensten op te activeren. In dit voorbeeld wordt de dienst `telnet` geactiveerd door de volgende regel in [.filename]#/etc/inetd.conf# te zetten en dan man:inetd[8] te herstarten met `service inetd restart`:

[.programlisting]
....
telnet    stream  tcp     nowait  root    /usr/libexec/telnetd  telnetd -a user
....

Het belangrijkste is dat de typering `-a` (van autenticatie) op user staat. Meer details zijn in man:telnetd[8] te vinden.

=== Kerberos activeren op een cliënt met Heimdal

Het opzetten van een cliëntcomputer is eigenlijk kinderlijk eenvoudig. Wat betreft de Kerberos instelling is alleen het Kerberos instellingenbestand ([.filename]#/etc/krb5.conf#) nodig. Dat kan eenvoudigweg naar de cliëntcomputer gekopieerd worden vanaf de KDC.

Test de cliënt met `kinit`, `klist` en `kdestroy` vanaf de cliënt om een ticket te krijgen, te bekijken en daarna te verwijderen voor de principal die hierboven is aangemaakt. Nu moeten ook Kerberos applicaties gebruikt kunnen worden om verbindingen te maken met servers waarop Kerberos is geactiveerd. Als dat niet lukt en het verkrijgen van een ticket is wel mogelijk, dan ligt dat hoogstwaarschijnlijk aan de server en niet aan de cliënt of de KDC.

Bij het testen van een applicatie als `telnet` kan het beste een pakketsnuffelaar (bijvoorbeeld man:tcpdump[1]) gebruikt worden om te bevestigen dat een wachtwoord niet als tekst wordt verzonden. Gebruik `telnet` met de optie `-x`. Dan wordt de complete gegevensstroom versleuteld (vergelijkbaar met `ssh`).

Er worden standaard ook andere Kerberos applicaties op de cliënt geïnstalleerd. Hier komt de "minimalistische" natuur van de basisinstallatie van Heimdal boven drijven: `telnet` is de enige dienst waarvoor Kerberos geactiveerd is.

De port Heimdal voegt een aantal ontbrekende cliëntapplicaties toe: versies met ondersteuning voor Kerberos van `ftp`, `rsh`, `rcp`, `rlogin` en een paar minder gebruikelijke programma's. De MIT port bevat ook een volledig gamma aan Kerberos cliëntapplicaties.

=== Instellingenbestanden voor gebruikers: [.filename]#.k5login# en [.filename]#.k5users#

Voor gebruikers binnen een wereld wijst hun Kerberos principal (bv. `tillman@EXAMPLE.ORG`) gewoonlijk naar een lokale gebruikersaccount (bijvoorbeeld een lokale account met de naam `tillman`). Voor cliëntapplicaties als `telnet` is gewoonlijk geen gebruikersnaam of principal nodig.

Soms moet iemand zonder bijpassende Kerberos principal toch toegang hebben tot een lokale gebruikersaccount. `tillman@EXAMPLE.ORG` zou bijvoorbeeld toegang nodig kunnen hebben tot de lokale gebruikersaccount `webdevelopers`. Andere principals zouden die toegang wellicht ook nodig kunnen hebben.

De bestanden [.filename]#.k5login# en [.filename]#.k5users# uit de gebruikersmap kunnen op eenzelfde manier gebruikt worden als [.filename]#.hosts# en [.filename]#.rhosts#. Zo wordt het voorgaande probleem opgelost. Als bijvoorbeeld een [.filename]#.k5login# met de volgende inhoud:

[source,shell]
....
tillman@example.org
jdoe@example.org
....

in de thuismap van de lokale gebruiker `webdevelopers` gezet wordt dan zouden beide principals toegang hebben tot die account zonder dat ze een wachtwoord hoeven te delen.

We raden aan de handleidingen voor deze commando's te lezen. Let op dat de `ksu` handleiding [.filename]#.k5users# behandelt.

=== Kerberos tips, trucs en problemen oplossen

* Als de Heimdal of MITKerberos port wordt gebruikt dan dient de `PATH` omgevingsvariabele de Kerberos versies van de cliëntapplicaties te tonen voor de systeemversies.
* Hebben alle computers in de wereld hun tijd gesynchroniseerd? Als dat niet zo is, dan slaagt de autenticatie wellicht niet. crossref:network-servers[network-ntp,Tijd synchroniseren met NTP] beschrijft hoe klokken met NTP gesynchroniseerd kunnen worden.
* MIT en Heimdal werken prima samen. Dit geldt niet voor `kadmin` omdat daarvoor geen protocolstandaard is.
* Als een hostnaam wordt gewijzigd, dan moet ook de `host/` principal aangepast en de keytab. Dit geldt ook voor bijzondere instellingen in de keytab zoals de `www/` principal voor package:www/mod_auth_kerb[] van Apache.
* Alle hosts in een wereld moeten oplosbaar (resolvable) zijn (zowel vooruit als achteruit) in de DNS (of tenminste in [.filename]#/etc/hosts#). CNAMEs werken wel, maar de A en PTR records moeten juist en actief zijn. De foutmelding is niet erg duidelijk: `Kerberos5 refuses authentication because Read req failed: Key table entry not found`.
* Sommige besturingssystemen van cliënten voor een KDC zetten wellicht geen setuid `root` voor `ksu`. Dit betekent dat `ksu` niet werkt. Dat is vanuit beveiligingsoogpunt een prima idee, maar wel lastig. Dit is dus geen KDC-fout.
* Als met MITKerberos een principal een ticket moet krijgen dat langer geldig is dan de standaard van tien uur, dan moet `modify_principal` in `kadmin` gebruikt worden om de maximale geldigheidsduur (maxlife) van zowel de principal waar het om gaat als de `krbtgt` principal aan te passen. Dan kan de principal `kinit``-l` gebruiken om een ticket met een langere levensduur aan te vragen.
+
[NOTE]
====
Als een pakketsnuffelaar op de KDC draait bij om te helpen bij het oplossen van problemen en dan `kinit` vanaf een werkstation wordt gestart, dan wordt zichtbaar dat de TGT meteen wordt verstuurd als `kinit` start, zelfs nog voor het wachtwoord! De reden hiervoor is dat de Kerberos server vrijelijk een TGT (Ticket Granting Ticket) verstuurt op iedere niet geautoriseerd verzoek. Maar iedere TGT is versleuteld met een sleutel die is afgeleid van het wachtwoord van de gebruiker. Als een gebruiker zijn wachtwoord ingeeft, wordt dat dus niet naar de KDC gezonden, maar ontcijfert het de TGT die `kinit` al heeft ontvangen. Als de ontcijfering resulteert in een geldige ticket met een geldige tijdstempel, dan heeft de gebruiker geldige Kerberos rechten. Deze rechten bevatten ook een sessiesleutel voor het opzetten van beveiligde communicatie met de Kerberos server in de toekomst en de eigenlijke ticket-granting ticket, die is versleuteld met de sleutel van de Kerberos server zelf. Deze tweede laag van versleuteling is niet bekend voor de gebruiker, maar het stelt de Kerberos server in staat om de juistheid van iedere TGT te bevestigen.
====
+
* Als tickets worden gebruik die lang geldig zijn (bv. een week) en OpenSSH wordt gebruikt om een verbinding te maken met de machine waarop het ticket staat, zorg er dan voor dat de Kerberos optie `TicketCleanup` op `no` staat in [.filename]#sshd_config# want anders worden tickets verwijderd bij afmelden.
* Hostprincipals kunnen ook een langere levensduur hebben. Als een gebruikers principal een levensduur van een week heeft, maar de host waar de verbinding mee gemaakt wordt heeft een levensduur van negen uur, dan heb staat er een verlopen host principal in de cache en dan werkt een en ander niet zoals verwacht.
* Een [.filename]#krb5.dict# bestand om het gebruik van bepaalde slechte wachtwoorden te voorkomen (dit wordt kort behandeld in de handleiding voor `kadmind`) heeft alleen betrekking op principals waar een wachtwoordbeleid voor geldt. De opmaak van [.filename]#krb5.dict# is eenvoudig: een rij tekens per regel. Een symbolische link maken naar [.filename]#/usr/shared/dict/words# is misschien handig.

=== Verschillen met de MIT port

Het belangrijkste verschil tussen de MIT en Heimdal installatie heeft betrekking op `kadmin`, dat een andere (maar gelijkwaardige) set commando's kent en een andere protocol gebruikt. Dit betekent nogal wat als een KDCMIT is, omdat dan de `kadmin` van Heimdal niet gebruikt kan worden om de KDC vanaf afstand te beheren (dat geldt trouwens ook vice versa).

De cliëntapplicaties kunnen ook commandoregelopties gebruiken die een beetje verschillen, maar waarmee wel hetzelfde wordt bereikt. We raden aan de instructies op de MITKerberos website (http://web.mit.edu/Kerberos/www/[http://web.mit.edu/Kerberos/www/]) te volgen. Wees voorzichtig met paden: de MIT-port installeert standaard in [.filename]#/usr/local/# en dus kunnen de "normale" systeemapplicaties gestart worden in plaats van die van MIT als de `PATH` omgevingsvariabele de systeemmappen als eerste weergeeft.

[NOTE]
====
Als de MITpackage:security/krb5[] port die bij FreeBSD zit wordt gebruikt, dan zorgt het lezen van [.filename]#/usr/local/shared/doc/krb5/README.FreeBSD# dat bij de port wordt geïnstalleerd voor een beter begrip over waarom het aanmelden via `telnetd` en `klogind` soms wat vreemd verloopt. Als belangrijkste wijzen we erop dat het bij het corrigeren van "onjuiste rechten op het cachebestand" noodzakelijk is dat het binaire bestand `login.krb5` wordt gebruikt voor autenticatie zodat het op de juiste wijze eigenaarschap kan wijzigen voor de doorgegeven rechten.
====

Het bestand [.filename]#rc.conf# moet ook gewijzigd worden zodat het de volgende configuratie bevat:

[.programlisting]
....
kerberos5_server="/usr/local/sbin/krb5kdc"
kadmind5_server="/usr/local/sbin/kadmind"
kerberos5_server_enable="YES"
kadmind5_server_enable="YES"
....

Dit is gedaan omdat de applicaties voor MIT-Kerberos binairen in de hiërarchie [.filename]#/usr/local# installeren.

=== Beperkingen in Kerberos

==== Kerberos is een alles of niets aanpak

Iedere ingeschakelde dienst op het netwerk moet aangepast worden om met Kerberos te werken (of op een andere manier beschermd zijn tegen netwerkaanvallen), want anders kunnen gebruikersrechten worden gestolen en herbruikt. Een voorbeeld hier van is het inschakelen van Kerberos voor alle shells op afstand (via `rsh` en `telnet` bijvoorbeeld), maar de POP3 mailserver die wachtwoorden als platte tekst verzend ongemoeid laten.

==== Kerberos is bedoeld voor werkstations met een gebruiker

In een meergebruikersomgeving is Kerberos minder veilig. Dit komt doordat de tickets worden opgeslagen in de map [.filename]#/tmp#, waar gelezen kan worden door alle gebruikers. Als een gebruiker een computer deelt met andere gebruikers op hetzelfde moment (dus multi-user), dan is het mogelijk dat een ticket van een gebruiker wordt gestolen (gekopieerd) door een andere gebruiker.

Dit kan voorkomen worden met de commandoregeloptie "`-c` bestandsnaam" of (bij voorkeur) de omgevingsvariabele `KRB5CCNAME`, maar dat wordt zelden gedaan. In principe kan het opslaan van een ticket in de thuismap van een gebruiker in combinatie met eenvoudige bestandsrechten dit probleem verhelpen.

==== De KDC is een single point of failure

Zoals het is ontworpen, moet de KDC zo goed mogelijk beveiligd zijn, omdat de hoofdwachtwoorddatabase erop staat. De KDC hoort geen enkele andere dienst aan te bieden en moet ook fysiek afgeschermd worden. Het gevaar is groot, omdat Kerberos alle wachtwoorden versleutelt met dezelfde sleutel (de "master" sleutel) die als een bestand op de KDC staat.

Toch is een gecompromitteerde mastersleutel niet zo'n groot probleem als wellicht wordt verondersteld. De mastersleutel wordt alleen gebruikt om de Kerberos database te versleutelen en als zaad voor de generator van willekeurige nummers. Zo lang als de toegang tot de KDC is beveiligd, kan een aanvaller niet echt iets doen met de mastersleutel.

Als de KDC niet beschikbaar is (misschien door een ontzeggen van dienst aanval of netwerkproblemen) kunnen de netwerkdiensten niet gebruikt worden omdat er geen autenticatie uitgevoerd kan worden; een recept voor een ontzeggen van dienst aanval. Dit risico kan omzeild worden door meerdere KDC's (één master en één of meer slaven) en een zorgvuldige implementatie van secundaire of fall-back autenticatie. PAM is hier uitermate geschikt voor.

==== Tekortkomingen van Kerberos

Kerberos stelt gebruikers, hosts en diensten in staat om elkaar te autenticeren. Maar het heeft geen mechanisme om de KDC te autenticeren aan de gebruikers, hosts of diensten. Dit betekent dat bijvoorbeeld een vervalste `kinit` alle gebruikersnamen en wachtwoorden zou kunnen afluisteren. Iets als package:security/tripwire[] of andere controle-instrumenten voor de integriteit van bestandssystemen kunnen hier verlichting brengen.

=== Bronnen en verdere informatie

* http://www.faqs.org/faqs/Kerberos-faq/general/preamble.html[ De Kerberos FAQ] (Engels)
* http://web.mit.edu/Kerberos/www/dialogue.html[Een Autenticatiesysteem Ontwerpen: een Dialoog in Vier Scenes] (Engels)
* http://www.ietf.org/rfc/rfc1510.txt?number=1510[ RFC 1510, De Kerberos Netwerk Authenticatie Dienst (V5)] (Engels)
* http://web.mit.edu/Kerberos/www/[MIT Kerberos homepage]
* http://www.pdc.kth.se/heimdal/[Heimdal Kerberos homepage]

[[openssl]]
== OpenSSL

Een toepassing die bij FreeBSD zit die veel gebruikers over het hoofd zien is OpenSSL. OpenSSL biedt een versleutelde transportlaag bovenop de normale communicatielaag. Daardoor biedt het de mogelijkheid met veel netwerktoepassingen en diensten verweven te raken.

Een aantal toepassingen van OpenSSL zijn versleutelde autenticatie van mailcliënten, webgebaseerde transacties als creditcardbetalingen en nog veel meer. Veel ports zoals package:www/apache22[] en package:mail/claws-mail[] bieden tijdens het compileren ondersteuning om OpenSSL in te bouwen.

[NOTE]
====
In de meeste gevallen zal de Portscollectie proberen de port package:security/openssl[] te bouwen, tenzij de make variabele `WITH_OPENSSL_BASE` expliciet naar "yes" is gezet.
====

De versie van OpenSSL die bij FreeBSD zit ondersteunt Secure Sockets Layer v2/v3 (SSLv2/SSLv3), Transport Layer Security v1 (TLSv1) netwerkbeveiligingsprotocollen en kan gebruikt worden als generieke versleutelingsbibliotheek.

[NOTE]
====
Hoewel OpenSSL ondersteuning biedt voor het IDEA algoritme, is dat standaard uitgeschakeld in verband met patenten in de Verenigde Staten. Om het te gebruiken dient de licentie gelezen te worden en, als de restricties aanvaardbaar zijn, dient de make-variabele `MAKE_IDEA` ingesteld te worden in [.filename]#make.conf#.
====

Een van de meest gebruikte toepassingen van OpenSSL is het leveren van certificaten voor gebruik met softwaretoepassingen. Deze certificaten verzekeren dat de eigenschappen van een bedrijf of individu geldig zijn en niet vervalst. Als het certificaat in kwestie niet geldig verklaard is door een van de "Certificate Authorities" of CA's, dan komt er een waarschuwing. Een Certificate Authority is een bedrijf, zoals http://www.verisign.com[VeriSign], dat certificaten ondertekent zodat de eigenschappen van een bedrijf of individu geldig verklaard kunnen worden. Dit proces kost geld en het is zeker geen voorwaarde voor het gebruik van certificaten. Het stelt wel de meer paranoïde gebruikers gerust.

=== Certificaten maken

Voor het maken van certificaten is het volgende commando beschikbaar:

[source,shell]
....
# openssl req -new -nodes -out req.pem -keyout cert.pem
Generating a 1024 bit RSA private key
................
.......................................
writing new private key to 'cert.pem'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [AU]:US
State or Province Name (full name) [Some-State]:PA
Locality Name (eg, city) []:Pittsburgh
Organization Name (eg, company) [Internet Widgits Pty Ltd]:My Company
Organizational Unit Name (eg, section) []:Systems Administrator
Common Name (eg, YOUR name) []:localhost.example.org
Email Address []:trhodes@FreeBSD.org

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:SOME PASSWORD
An optional company name []:Another Name
....

Let op dat het antwoord direct na "Common Name" een domeinnaam weergeeft. De prompt wil dat er een servernaam wordt ingegeven voor het verificatieproces. Het plaatsen van iets anders dan een domeinnaam zorgt ervoor dat het certificaat waardeloos wordt. Er zijn ook andere opties als verloopdatum, andere versleutelingsalgoritmes, etc, beschikbaar. Een volledige lijst is na te lezen in de handleiding van man:openssl[1].

Er horen nu twee bestanden te staan in de map waarin het voorgaande commando is uitgevoerd. Het certificaatverzoek, [.filename]#req.pem#, kan naar een certificaat autoriteit gestuurd worden die de bijgevoegde gegevens kan valideren, het verzoek kan tekenen en het certificaat kan retourneren. Het tweede bestand heet [.filename]#cert.pem# en is de geheime sleutel voor het certificaat. Deze dient zorgvuldig beschermd te worden. Als de geheime sleutel in de handen van anderen valt kan die gebruikt worden om de identiteit van de eigenaar (of server) aan te nemen.

In gevallen waar ondertekening door een CA niet vereist is, kan een zelfondertekend certificaat gemaakt worden. Maak als eerste de RSA sleutel:

[source,shell]
....
# openssl dsaparam -rand -genkey -out myRSA.key 1024
....

Hierna kan de CA sleutel gemaakt worden:

[source,shell]
....
# openssl gendsa -des3 -out myca.key myRSA.key
....

Deze sleutel kan gebruikt worden om een certificaat te maken:

[source,shell]
....
# openssl req -new -x509 -days 365 -key myca.key -out new.crt
....

Er zouden nu twee bestanden bijgekomen moeten zijn in de map: een certificaatautoriteit ondertekeningsbestand [.filename]#myca.key# en [.filename]#new.crt#, het certificaat zelf. Deze moeten in een map geplaatst worden, bij voorkeur onder [.filename]#/etc# waar alleen `root` kan lezen. De rechten 0700 zijn hier prima en die kunnen ingesteld worden met `chmod`.

=== Certificaten gebruiken: een voorbeeld

En wat kunnen deze bestanden? Een prima toepassing zou het versleutelen van verbindingen naar de SendmailMTA kunnen zijn. Daardoor zouden gebruikers niet langer platte tekst hoeven te autenticeren om mail te sturen via de lokale MTA.

[NOTE]
====
Dit is niet de best denkbare toepassing omdat sommige MUA's de gebruiker een foutmelding geven als ze het certificaat niet lokaal geïnstalleerd hebben. De documentatie bij de software geeft meer informatie over het installeren van certificaten.
====

De volgende regels moeten opgenomen worden in het lokale [.filename]#.mc# bestand:

[.programlisting]
....
dnl SSL Options
define(`confCACERT_PATH',`/etc/certs')dnl
define(`confCACERT',`/etc/certs/new.crt')dnl
define(`confSERVER_CERT',`/etc/certs/new.crt')dnl
define(`confSERVER_KEY',`/etc/certs/myca.key')dnl
define(`confTLS_SRV_OPTIONS', `V')dnl
....

[.filename]#/etc/certs/# is de map die gebruikt wordt voor het lokaal opslaan van certificaten en sleutels. De laatste voorwaarde het is opnieuw aanmaken van het lokale [.filename]#.cf# bestand. Dit gaat door eenvoudigweg `make install` te typen in de map [.filename]#/etc/mail#. Laat dat volgen door `make install` waardoor de daemon Sendmail herstart zou moeten worden.

Als alles goed is gegaan, dan staan er geen foutmeldingen [.filename]#/var/log/maillog# en is Sendmail zichtbaar in de proceslijst.

Maak als eenvoudige test een verbinding met de mailserver met man:telnet[1]:

[source,shell]
....
# telnet example.com 25
Trying 192.0.34.166...
Connected to example.com.
Escape character is '^]'.
220 example.com ESMTP Sendmail 8.12.10/8.12.10; Tue, 31 Aug 2004 03:41:22 -0400 (EDT)
ehlo example.com
250-example.com Hello example.com [192.0.34.166], pleased to meet you
250-ENHANCEDSTATUSCODES
250-PIPELINING
250-8BITMIME
250-SIZE
250-DSN
250-ETRN
250-AUTH LOGIN PLAIN
250-STARTTLS
250-DELIVERBY
250 HELP
quit
221 2.0.0 example.com closing connection
Connection closed by foreign host.
....

Als de regel "STARTTLS" verschijnt in de uitvoer dan werkt alles correct.

[[ipsec]]
== VPN via IPsec

Een VPN opzetten met FreeBSD gateways tussen twee netwerken die gescheiden zijn door Internet.

=== IPsec begrijpen

Deze paragraaf is een gids in het proces van het opzetten van IPsec. Voordat IPsec opgezet kan worden dient de lezer bekend te zijn met de concepten die nodig zijn om een aangepaste kernel te bouwen (zie crossref:kernelconfig[kernelconfig,De FreeBSD-kernel instellen]).

_IPsec_ is een protocol dat bovenop de Internet Protocol (IP) laag ligt. Hiermee kunnen twee of meer host op een veilige manier communiceren (vandaar de naam). De FreeBSD IPsec "netwerk wachtrij (stack)" is gebaseerd op de http://www.kame.net/[KAME]-implementatie, die zowel de protocolfamilies IPv4 als de IPv6 ondersteunt.

IPsec bestaat uit twee subprotocollen:

* _Encapsulated Security Payload (ESP)_ beschermt de IP-pakketdata tegen inmenging door een derde partij door de inhoud te versleutelen met symmetrische versleutelingsalgoritmes (zoals Blowfish en 3DES).
* _Authentication Header (AH)_ beschermt de IP-pakketkop tegen inmenging door een derde partij en spoofing door een cryptografische checksum te berekenen en de IP-pakketkopvelden te hashen met een veilige hashfunctie. Hierna wordt een extra kop ingevoegd die de hash bevat zodat de informatie in het pakket geautenticeerd kan worden.

ESP en AH kunnen samen of apart gebruikt worden, afhankelijk van de omgeving.

IPsec kan gebruikt worden om het verkeer tussen twee hosts direct te versleutelen (dat heet _Transport Mode_) of door "virtuele tunnels" te bouwen tussen twee subnetten die gebruikt kunnen worden voor veilige communicatie tussen twee bedrijfsnetwerken (dat heet _Tunnel Mode_). De laatste versie staat beter bekend als _Virtual Private Network (VPN)_. In man:ipsec[4] staat gedetailleerde informatie over het IPsec subsysteem in FreeBSD.

Voor ondersteuning voor IPsec in de kernel zijn de volgende opties nodig in het kernelinstellingenbestand:

[source,shell]
....
options   IPSEC        IP-beveiliging
device    crypto
....

Als er ook fouten in IPsec (debugging) verwijderd moeten kunnen worden, dan is de volgende optie ook nodig:

[source,shell]
....
options   IPSEC_DEBUG  debug voor IP-beveiliging
....

=== Het probleem

Er bestaat geen standaard voor wat een VPN is. VPN's kunnen opgezet worden met behulp van een aantal verschillende technologieën die allemaal hun eigen voor- en nadelen hebben. Dit onderdeel bevat een scenario en de strategieën die gebruikt kunnen worden voor het implementeren van een VPN in iedere situatie.

=== Het scenario: twee netwerken, de ene thuisgebaseerd en de andere bedrijfgebaseerd. Beide zijn verbonden met het Internet, en er wordt van verwacht dat ze zich via dit VPN als één gedragen.

Dit is het uitgangspunt:

* Er zijn tenminste twee locaties
* Beide locaties gebruiken IP
* Beide locaties hebben een Internetverbinding via een gateway waarop FreeBSD draait.
* De gateway op ieder netwerk heeft tenminste één publiek IP-adres.
* De interne adressen van de twee netwerken mogen publieke of private IP-adressen zijn, dat maakt niet uit. Ze mogen alleen niet botsen; bijvoorbeeld: ze mogen niet beide `192.168.1.x` gebruiken.

=== IPsec configureren op FreeBSD

Om te beginnen moet de port package:security/ipsec-tools[] geïnstalleerd zijn vanuit de Portscollectie. Dit softwarepakket van een derde partij biedt een aantal applicaties die helpen de configuratie te ondersteunen.

De volgende benodigdheid is om twee man:gif[4] pseudo-apparaten aan te maken om de pakketten te tunnelen en beide netwerken in staat stellen om op een juiste wijze te communiceren. Draai als `root` de volgende commando's, waarbij de items _intern_ en _extern_ met de echte interne en externe gateways:

[source,shell]
....
# ifconfig gif0 create
....

[source,shell]
....
# ifconfig gif0 intern1 intern2
....

[source,shell]
....
# ifconfig gif0 tunnel extern1 extern2
....

Het publieke IP van het LAN van de onderneming is bijvoorbeeld `172.16.5.4` en het heeft een privaat IP`10.246.38.1`. Het publieke IP van het LAN van huis is `192.168.1.12` met een intern privaat IP`10.0.0.5`.

Dit kan verwarrend lijken, dus bekijk de volgende voorbeeld van het commando man:ifconfig[8]:

[.programlisting]
....
Gateway 1:

gif0: flags=8051 mtu 1280
tunnel inet 172.16.5.4 --> 192.168.1.12
inet6 fe80::2e0:81ff:fe02:5881%gif0 prefixlen 64 scopeid 0x6
inet 10.246.38.1 --> 10.0.0.5 netmask 0xffffff00

Gateway 2:

gif0: flags=8051 mtu 1280
tunnel inet 192.168.1.12 --> 172.16.5.4
inet 10.0.0.5 --> 10.246.38.1 netmask 0xffffff00
inet6 fe80::250:bfff:fe3a:c1f%gif0 prefixlen 64 scopeid 0x4
....

Eenmaal compleet zouden beide private IP's bereikbaar moeten zijn met het commando man:ping[8] zoals de volgende uitvoer suggereert:

[.programlisting]
....
priv-net# ping 10.0.0.5
PING 10.0.0.5 (10.0.0.5): 56 data bytes
64 bytes from 10.0.0.5: icmp_seq=0 ttl=64 time=42.786 ms
64 bytes from 10.0.0.5: icmp_seq=1 ttl=64 time=19.255 ms
64 bytes from 10.0.0.5: icmp_seq=2 ttl=64 time=20.440 ms
64 bytes from 10.0.0.5: icmp_seq=3 ttl=64 time=21.036 ms
--- 10.0.0.5 ping statistics ---
4 packets transmitted, 4 packets received, 0% packet loss
round-trip min/avg/max/stddev = 19.255/25.879/42.786/9.782 ms

corp-net# ping 10.246.38.1
PING 10.246.38.1 (10.246.38.1): 56 data bytes
64 bytes from 10.246.38.1: icmp_seq=0 ttl=64 time=28.106 ms
64 bytes from 10.246.38.1: icmp_seq=1 ttl=64 time=42.917 ms
64 bytes from 10.246.38.1: icmp_seq=2 ttl=64 time=127.525 ms
64 bytes from 10.246.38.1: icmp_seq=3 ttl=64 time=119.896 ms
64 bytes from 10.246.38.1: icmp_seq=4 ttl=64 time=154.524 ms
--- 10.246.38.1 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 28.106/94.594/154.524/49.814 ms
....

Zoals verwacht hebben beide kanten de mogelijkheid om ICMP-pakketten te verzenden en te ontvangen van de privaat geconfigureerde adressen. Vervolgens dient aan beide gateways verteld te worden hoe pakketten te routeren om op de juiste wijze verkeer van een van de netwerken te versturen. Het volgende commando doet dit:

[source,shell]
....
# corp-net# route add 10.0.0.0 10.0.0.5 255.255.255.0
....

[source,shell]
....
# corp-net# route add net 10.0.0.0: gateway 10.0.0.5
....

[source,shell]
....
# priv-net# route add 10.246.38.0 10.246.38.1 255.255.255.0
....

[source,shell]
....
# priv-net# route add host 10.246.38.0: gateway 10.246.38.1
....

Op dit moment dienen interne machines bereikbaar te zijn vanuit elke gateway alsook als vanuit machines achter de gateways. Dit is eenvoudig te zien aan het volgende voorbeeld:

[.programlisting]
....
corp-net# ping 10.0.0.8
PING 10.0.0.8 (10.0.0.8): 56 data bytes
64 bytes from 10.0.0.8: icmp_seq=0 ttl=63 time=92.391 ms
64 bytes from 10.0.0.8: icmp_seq=1 ttl=63 time=21.870 ms
64 bytes from 10.0.0.8: icmp_seq=2 ttl=63 time=198.022 ms
64 bytes from 10.0.0.8: icmp_seq=3 ttl=63 time=22.241 ms
64 bytes from 10.0.0.8: icmp_seq=4 ttl=63 time=174.705 ms
--- 10.0.0.8 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 21.870/101.846/198.022/74.001 ms

priv-net# ping 10.246.38.107
PING 10.246.38.1 (10.246.38.107): 56 data bytes
64 bytes from 10.246.38.107: icmp_seq=0 ttl=64 time=53.491 ms
64 bytes from 10.246.38.107: icmp_seq=1 ttl=64 time=23.395 ms
64 bytes from 10.246.38.107: icmp_seq=2 ttl=64 time=23.865 ms
64 bytes from 10.246.38.107: icmp_seq=3 ttl=64 time=21.145 ms
64 bytes from 10.246.38.107: icmp_seq=4 ttl=64 time=36.708 ms
--- 10.246.38.107 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 21.145/31.721/53.491/12.179 ms
....

De tunnels opzetten is het eenvoudige deel. Het configureren van een veilige verbinding is een veel diepgaander proces. De volgende configuratie gebruikt vooraf gedeelde (PSK) RSA-sleutels. Afgezien van de IP-adressen zijn beide bestanden [.filename]#/usr/local/etc/racoon/racoon.conf# identiek en zien ze er ongeveer als volgt uit:

[.programlisting]
....
path    pre_shared_key  "/usr/lcoal/etc/racoon/psk.txt"; # plaats van bestand vooraf gedeelde sleutels
log     debug;  # verbositeitsinstelling van loggen: op 'notify' zetten als testen en debuggen klaar is

padding # opties moeten niet veranderd worden
{
        maximum_length  20;
        randomize       off;
        strict_check    off;
        exclusive_tail  off;
}

timer   # timingopties, veranderen indien nodig
{
        counter         5;
        interval        20 sec;
        persend         1;
#       natt_keepalive  15 sec;
        phase1          30 sec;
        phase2          15 sec;
}

listen  # adres [poort] waarop racoon luistert
{
        isakmp          172.16.5.4 [500];
        isakmp_natt     172.16.5.4 [4500];
}

remote  192.168.1.12 [500]
{
        exchange_mode   main,aggressive;
        doi             ipsec_doi;
        situation       identity_only;
        my_identifier   address 172.16.5.4;
        peers_identifier        address 192.168.1.12;
        lifetime        time 8 hour;
        passive         off;
        proposal_check  obey;
#       nat_traversal   off;
        generate_policy off;

                        proposal {
                                encryption_algorithm    blowfish;
                                hash_algorithm          md5;
                                authentication_method   pre_shared_key;
                                lifetime time           30 sec;
                                dh_group                1;
                        }
}

sainfo  (address 10.246.38.0/24 any address 10.0.0.0/24 any)   # adres $netwerk/$netmasker $type adres $netwerk/$netmasker $type ( $type is any of esp)
{
        pfs_group       1;
        lifetime        time    3600 sec;
        encryption_algorithm    blowfish,3des,des;
        authentication_algorithm        hmac_md5,hmac_sha1;
        compression_algorithm   deflate;
}
....

Het uitleggen van elke beschikbare optie, samen met diegenen in deze voorbeelden valt buiten het bereik van dit document. De configuratiehandleiding van racoon staat vol relevante informatie.

De SPD-beleiden moeten geconfigureerd worden zodat FreeBSD en racoon in staat zijn om netwerkverkeer tussen hosts te versleutelen en te ontsleutelen.

Deze taak kan met een eenvoudig shellscript zoals het volgende dat op de gateway van de onderneming staat worden uitgevoerd. Dit bestand wordt gebruikt tijdens de systeeminitialisatie en dient bewaard te worden als [.filename]#/usr/local/etc/racoon/setkey.conf#.

[.programlisting]
....
flush;
spdflush;
# Naar het thuisnetwerk
spdadd 10.246.38.0/24 10.0.0.0/24 any -P out ipsec esp/tunnel/172.16.5.4-192.168.1.12/use;
spdadd 10.0.0.0/24 10.246.38.0/24 any -P in esp/tunnel/192.168.1.12-172.16.5.4/use;
....

Eenmaal aanwezig kan racoon op beide gateways gestart worden met het volgende commando:

[source,shell]
....
# /usr/local/sbin/racoon -F -f /usr/local/etc/racoon/racoon.conf -l /var/log/racoon.log
....

De uitvoer moet ongeveer gelijk zijn aan de volgende:

[.programlisting]
....
corp-net# /usr/local/sbin/racoon -F -f /usr/local/etc/racoon/racoon.conf
Foreground mode.
2006-01-30 01:35:47: INFO: begin Identity Protection mode.
2006-01-30 01:35:48: INFO: received Vendor ID: KAME/racoon
2006-01-30 01:35:55: INFO: received Vendor ID: KAME/racoon
2006-01-30 01:36:04: INFO: ISAKMP-SA established 172.16.5.4[500]-192.168.1.12[500] spi:623b9b3bd2492452:7deab82d54ff704a
2006-01-30 01:36:05: INFO: initiate new phase 2 negotiation: 172.16.5.4[0]192.168.1.12[0]
2006-01-30 01:36:09: INFO: IPsec-SA established: ESP/Tunnel 192.168.1.12[0]->172.16.5.4[0] spi=28496098(0x1b2d0e2)
2006-01-30 01:36:09: INFO: IPsec-SA established: ESP/Tunnel 172.16.5.4[0]->192.168.1.2[0] spi=47784998(0x2d92426)
2006-01-30 01:36:13: INFO: respond new phase 2 negotiation: 172.16.5.4[0]192.168.1.12[0]
2006-01-30 01:36:18: INFO: IPsec-SA established: ESP/Tunnel 192.168.1.12[0]->172.16.5.4[0] spi=124397467(0x76a279b)
2006-01-30 01:36:18: INFO: IPsec-SA established: ESP/Tunnel 172.16.5.4[0]->192.168.1.12[0] spi=175852902(0xa7b4d66)
....

Om er zeker van te zijn dat de tunnel correct werkt, dient naar een ander console geschakeld te worden en man:tcpdump[1] gebruikt te worden om hiermee het netwerkverkeer te bekijken. Vervang `em0` door de netwerkinterfacekaart indien nodig.

[source,shell]
....
# tcpdump -i em0 host 172.16.5.4 and dst 192.168.1.12
....

Gegevens lijkend op de volgende zouden op het console moeten verschijnen. Indien niet, dan is er iets aan de hand, en is het nodig om de teruggegeven gegevens te debuggen.

[.programlisting]
....
01:47:32.021683 IP corporatenetwork.com > 192.168.1.12.privatenetwork.com: ESP(spi=0x02acbf9f,seq=0xa)
01:47:33.022442 IP corporatenetwork.com > 192.168.1.12.privatenetwork.com: ESP(spi=0x02acbf9f,seq=0xb)
01:47:34.024218 IP corporatenetwork.com > 192.168.1.12.privatenetwork.com: ESP(spi=0x02acbf9f,seq=0xc)
....

Op dit punt zouden beide netwerken beschikbaar moeten zijn en deel lijken van hetzelfde netwerk. Waarschijnlijk zijn beide netwerken beschermt door een firewall, zoals het hoort. Om verkeer tussen hen toe te staan, moeten er regels worden toegevoegd om pakketten heen en terug door te laten. Voeg voor de firewall man:ipfw[8] de volgende regels toe aan het instellingenbestand van de firewall:

[.programlisting]
....
ipfw add 00201 allow log esp from any to any
ipfw add 00202 allow log ah from any to any
ipfw add 00203 allow log ipencap from any to any
ipfw add 00204 allow log udp from any 500 to any
....

[NOTE]
====
Afhankelijk van de huidige hostconfiguratie dienen de regelnummers gewijzigd te worden.
====

Voor gebruikers van man:pf[4] of man:ipf[8] zouden de volgende regels moeten volstaan:

[.programlisting]
....
pass in quick proto esp form any to any
pass in quick proto ah from any to any
pass in quick proto ipencap from any to any
pass in quick proto udp form any port = 500 to any port = 500
pass in quick on gif0 from any to any
pass out quick proto esp from any to any
pass out quick proto ah from any to any
pass out quick ptoto ipencap from any to any
pass out quick proto udp from any port = 500 to any port = 500
pass out quick on gif0 from any to any
....

Ter afsluiting, voeg de volgende regels toe aan [.filename]#/etc/rc.conf# om de machine toe te staan om ondersteuning voor het VPN te starten tijdens de systeeminitialisatie:

[.programlisting]
....
ipsec_enable="YES"
ipsec_program="/usr/local/sbin/setkey"
ipsec_file="/usr/local/etc/racoon/setkey.conf" # staat toe om spd-beleiden tijdens het opstarten op te zetten
racoon_enable="yes"
....

[[openssh]]
== OpenSSH

OpenSSH is een groep netwerkverbindingsprogramma's waarmee computers via het netwerk veilig benaderd kunnen worden. Het kan ingezet worden als een directe vervanger van `rlogin`, `rsh`, `rcp` en `telnet`. Daarnaast kunnen TCP/IP-verbindingen veilig getunneld of geforward worden door SSH. OpenSSH versleutelt al het verkeer om afluisteren, het stelen van een verbinding en andere netwerkaanvallen effectief te voorkomen.

OpenSSH wordt onderhouden door het OpenBSD project en is gebaseerd op SSH v1.2.12 met alle recente bugfixes en updates. Het is compatibel met beide protocollen SSH 1 en 2.

=== Voordelen van gebruik van OpenSSH

Als gewoonlijk man:telnet[1] of man:rlogin[1] wordt gebruikt, wordt de data in platte tekst en niet versleuteld verzonden. Netwerksnuffelaars die ergens tussen de cliënt en de server meeluisteren, kunnen een gebruikersnaam en wachtwoord stelen en zien welke gegevens er worden overgezonden tijdens een sessie. OpenSSH biedt een verscheidenheid aan autenticatie en versleutelingsmethoden die het voorgaande voorkomen.

=== sshd inschakelen

De sshd is een optie die wordt aangeboden tijdens een `Standard`-installatie van FreeBSD. sshd is ingeschakeld als de volgende regel voorkomt in [.filename]#rc.conf#:

[.programlisting]
....
sshd_enable="YES"
....

Hierdoor wordt man:sshd[8] geladen, het daemonprogramma voor OpenSSH, als het systeem de volgende keer opstart. Als alternatief is het mogelijk om man:rc[8] te gebruiken om OpenSSH te starten:

[source,shell]
....
# service sshd start
....

=== SSH-cliënt

man:ssh[1] werkt net zoals man:rlogin[1].

[source,shell]
....
# ssh user@example.com
Host key not found from the list of known hosts.
Are you sure you want to continue connecting (yes/no)? yes
Host 'example.com' added to the list of known hosts.
user@example.com's password: *******
....

Het aanmelden gaat nu net zoals het zou gaan als wanneer er een sessie gestart zou worden met `rlogin` of `telnet`. SSH maakt gebruik van een systeem met vingerafdrukken als sleutels voor het vaststellen met welke server verbinding wordt gemaakt op het moment dat de cliënt verbinding zoekt. De gebruiker krijgt alleen de eerste keer dat verbinding wordt gezocht met de server een vraag waarop `yes` geantwoord dient te worden. Bij volgende pogingen om aan te melden wordt de vingerafdruksleutel vergeleken met de sleutel die is opgeslagen. De SSH-cliënt alarmeert de gebruiker als de opgeslagen vingerafdruk sleutel anders is dan de sleutel die de server meldt. De vingerafdrukken worden opgeslagen in [.filename]#~/.ssh/known_hosts# of in [.filename]#~/.ssh/known_hosts2# voor SSH v2 vingerafdrukken.

Recente OpenSSH servers staan standaard ingesteld om alleen SSH v2 connecties toe te staan. De cliënt gebruikt versie 2 als dat mogelijk is en valt anders terug op versie 1. De cliënt kan ook gedwongen worden om een van de twee protocollen te gebruiken door de optie `-1` of `-2` voor respectievelijk versie 1 en versie 2 aan te geven. De mogelijkheid versie 1 te gebruiken blijft in de cliënt bestaan om compatibiliteit met oudere versies te behouden.

=== Veilig kopiëren

Het commando man:scp[1] (secure copy) werkt gelijk aan man:rcp[1]. Het kopieert een bestand van of naar een andere machine, maar doet dat veilig.

[source,shell]
....
#  scp user@example.com:/COPYRIGHT COPYRIGHT
user@example.com's password: *******
COPYRIGHT            100% |*****************************|  4735
00:00
#
....

Omdat de vingerafdruk al is opgeslagen voor deze host in het vorige voorbeeld, is die al geverifieerd als man:scp[1] gebruik wordt.

De argumenten die aan man:scp[1] gegeven worden zijn vrijwel gelijk aan die voor man:cp[1] met het bestand of de bestanden als het eerste argument en de bestemming als het tweede. Omdat het bestand over het netwerk gaat, door SSH, hebben een of meer van de bestandsargumenten de vorm `user@host:<path_to_remote_file>`.

=== Instellen

Het instellingenbestand dat voor het hele systeem geldt voor zowel de OpenSSH daemon als cliënt staat in de map [.filename]#/etc/ssh#.

[.filename]#ssh_config# bevat de instellingen voor de cliënt en [.filename]#sshd_config# bevat ze voor de daemon.

Daarnaast bieden het `sshd_program` (standaard [.filename]#/usr/sbin/sshd#) en `sshd_flags`[.filename]#rc.conf# opties nog meer mogelijkheden voor instellingen.

[[security-ssh-keygen]]
=== ssh-keygen

In plaats van het gebruik van wachtwoorden kan man:ssh-keygen[1] gebruikt worden om DSA en RSA sleutels te maken om een gebruiker te autenticeren:

[source,shell]
....
% ssh-keygen -t dsa
Generating public/private dsa key pair.
Enter file in which to save the key (/home/user/.ssh/id_dsa):
Created directory '/home/user/.ssh'.
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /home/user/.ssh/id_dsa.
Your public key has been saved in /home/user/.ssh/id_dsa.pub.
The key fingerprint is:
bb:48:db:f2:93:57:80:b6:aa:bc:f5:d5:ba:8f:79:17 user@host.example.com
....

man:ssh-keygen[1] maakt een publiek en privaat sleutelpaar aan dat gebruikt kan worden voor autenticatie. De private sleutel staat opgeslagen in [.filename]#~/.ssh/id_dsa# of [.filename]#~/.ssh/id_rsa# en de publieke sleutel staat in [.filename]#~/.ssh/id_dsa.pub# of [.filename]#~/.ssh/id_rsa.pub# voor respectievelijk sleuteltypen DSA en RSA. De publieke sleutel moet voor beide RSA- of DSA-sleutels in het bestand [.filename]#~/.ssh/authorized_keys# van de andere machine staan om dit te laten werken.

Nu is het mogelijk een verbinding te maken met een andere machine die gebaseerd is op SSH sleutels in plaats van op wachtwoorden.

Als er een wachtwoordzin is gebruikt bij man:ssh-keygen[1] dan wordt de gebruiker iedere keer dat de private sleutel wordt gebruikt een wachtwoord gevraagd. man:ssh-agent[1] kan het ongemak van steeds opnieuw een lange wachtwoordzin moeten ingeven verlichten en wordt beschreven in het onderdeel <<security-ssh-agent>>.

[WARNING]
====

Afhankelijk van de gebruikte versie van OpenSSH kunnen opties en bestanden verschillen. Het is verstandig de handleiding man:ssh-keygen[1] te raadplegen.
====

[[security-ssh-agent]]
=== ssh-agent en ssh-add

De hulpprogramma's man:ssh-agent[1] en man:ssh-add[1] bieden de mogelijkheid om SSH in het geheugen te laden zodat niet iedere keer de wachtwoordzin ingegeven hoeft te worden.

Het hulpprogramma man:ssh-agent[1] handelt de autenticatie af voor de geheime sleutels die erin geladen zijn. man:ssh-agent[1] wordt gebruikt om andere programma's te starten. Bij eenvoudig gebruik kan er een shell mee gestart worden of meer complex een schermbeheerprogramma.

Voordat man:ssh-agent[1] in een shell gebruikt kan worden dient het eerst gestart te worden met een shell als argument. Daarna kan de identiteit toegevoegd worden daar man:ssh-add[1] aan te roepen en de wachtwoordzin voor de geheime sleutel op te geven. Als deze stappen zijn voltooid kan een gebruiker met man:ssh[1] naar iedere host waar de corresponderende publieke sleutel is geïnstalleerd:

[source,shell]
....
% ssh-agent csh
% ssh-add
Enter passphrase for /home/user/.ssh/id_dsa:
Identity added: /home/user/.ssh/id_dsa (/home/user/.ssh/id_dsa)
%
....

Om man:ssh-agent[1] te gebruiken in X11 dient er een verwijzing naar man:ssh-agent[1] in [.filename]#~/.xinitrc# te staan. Dan zijn de diensten van man:ssh-agent[1] beschikbaar voor alle programma's die in X11 gestart worden. Een [.filename]#~/.xinitrc# zou er als volgt uit kunnen zien:

[.programlisting]
....
exec ssh-agent startxfce4
....

Hiermee wordt man:ssh-agent[1] gestart die op zijn beurt XFCE start, iedere keer dat X11 start. Als dat is gebeurd en X11 is herstart zodat de wijzigingen actief zijn, dan kan eenvoudigweg man:ssh-add[1] gestart worden om alle beschikbare SSH sleutels te laden.

[[security-ssh-tunneling]]
=== SSH tunnels

OpenSSH kan een tunnel maken waarin een ander protocol ingepakt kan worden zodat er een versleutelde sessie ontstaat.

Het volgende commando geeft man:ssh[1] aan dat er een tunnel voor telnet gemaakt moet worden:

[source,shell]
....
% ssh -2 -N -f -L 5023:localhost:23 user@foo.example.com
%
....

Aan het `ssh` commando worden de volgende opties meegegeven:

`-2`::
Dit dwingt `ssh` om versie 2 van het protocol te gebruiken. Gebruik van deze optie wordt afgeraden als er verbinding wordt gemaakt met oudere SSH servers.

`-N`::
Dit geeft aan dat er geen commando volgt, maar dat er een tunnel opgezet moet worden. Als deze optie niet aanwezig was, zou `ssh` een normale sessie starten.

`-f`::
Dit dwingt `ssh` om in de achtergrond te draaien.

`-L`::
Dit geeft aan dat de lokaal een tunnel wordt gemaakt in de vorm _lokale_poort:netwerk_host:netwerk_poort_.

`user@foo.example.com`::
Wijst naar een gebruiker op de SSH server op het netwerk.

Een SSH tunnel werkt doordat een luistersocket wordt gemaakt op `localhost` op de aangegeven poort. Die stuurt dan iedere ontvangen verbinding op de lokale host/poort via de SSH verbinding door naar de aangegeven host en poort op het netwerk.

In het voorbeeld wordt poort _5023_ op `localhost` doorgestuurd naar poort _23_ op `localhost` van de machine op het netwerk. Omdat `_23_` telnet is, zou dit een veilige telnet verbinding opleveren door een SSH tunnel.

Dit kan gebruikt worden om ieder willekeurig onveilig TCP protocol in te pakken als SMTP, POP3, FTP, etc.

.SSH gebruiken om een veilige tunnel te maken voor SMTP
[example]
====

[source,shell]
....
% ssh -2 -N -f -L 5025:localhost:25 user@mailserver.example.com
user@mailserver.example.com's password: *****
% telnet localhost 5025
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
220 mailserver.example.com ESMTP
....
Dit kan samen met een man:ssh-keygen[1] en extra gebruikersaccounts gebruikt worden om een min of meer naadloze en eenvoudige SSH tunnelomgeving te maken. In plaats van wachtwoorden kunnen sleutels gebruikt worden en de tunnels kunnen in de omgeving van een aparte gebruiker draaien.
====

==== Praktische voorbeelden van een SSH tunnel

===== Veilige toegang tot een POP3 server

Op het werk staat een SSH server die verbindingen van buitenaf toestaat. Op hetzelfde netwerk op kantoor staat een mailserver waarop POP3 draait. Het netwerk of het netwerkpad tussen de locatie op Internet en kantoor is wellicht niet helemaal te vertrouwen. Om deze reden dient de mailserver op een veilige manier benaderd te worden. De oplossing is een SSH verbinding opzetten naar de SSH server op kantoor en dan door de tunnel heen een verbinding opzetten met de mailserver.

[source,shell]
....
% ssh -2 -N -f -L 2110:mail.example.com:110 user@ssh-server.example.com
user@ssh-server.example.com's password:
% ******
....

Als de tunnel eenmaal draait, dan kan de mailcliënt naar `localhost` poort 2110 gewezen worden. Alle verbinding naar die poort worden veilig doorgestuurd door de tunnel naar `mail.example.com`.

===== Een draconische firewall omzeilen

Sommige netwerkbeheerders stellen draconische firewallregels op en filteren niet alleen inkomende verbindingen, maar ook uitgaande. Meestal mag dan alleen maar verbinding gemaakt worden met andere machines op poorten 22 en 80 voor SSH en websurfen.

Soms wil een gebruiker dan toch toegang krijgen tot andere (wellicht niet netwerkgerelateerde) diensten, zoals een Ogg Vorbis server om muziek te streamen. Als die Ogg Vorbis server streamt op een andere poort dan 22 of 80, dan kan deze niet bereikt worden.

De oplossing ligt in het opzetten van een SSH verbinding naar een machine buiten de firewall en die tunnel te gebruiken om bij de Ogg Vorbis server te komen.

[source,shell]
....
% ssh -2 -N -f -L 2110:mail.example.com:110 user@ssh-server.example.com
user@ssh-server.example.com's password: ******
....

De streamingcliënt kan nu gewezen worden naar `localhost` poort 8888 vanwaar er wordt doorverwezen naar `music.example.com` poort 8000 en zo wordt de firewall succesvol ontwerken.

=== De optie `AllowUsers`

Vaak is het verstandig om beperkingen aan te brengen op het gebied van welke gebruikers kunnen aanmelden en van waar. De optie `AllowUsers` biedt deze mogelijkheid. Om bijvoorbeeld alleen `root` toe te staan zich aan te melden van `192.168.1.32`, kan iets als de volgende regel worden opgenomen in het bestand [.filename]#/etc/ssh/sshd_config#:

[.programlisting]
....
AllowUsers root@192.168.1.32
....

Om de gebruiker `admin` het recht te geven zich van overal aan te melden hoeft alleen de gebruikersnaam vermeld te worden:

[.programlisting]
....
AllowUsers admin
....

Meerdere gebruikers met rechten of beperkingen horen op dezelfde regel te staan:

[.programlisting]
....
AllowUsers root@192.168.1.32 admin
....

[NOTE]
====
Het is van belang dat iedere gebruiker die zich moet kunnen aanmelden wordt genoemd. De overige gebruikers worden buitengesloten.
====

Nadat er wijzigingen zijn gemaakt aan [.filename]#/etc/ssh/sshd_config# dienen de bestanden in man:sshd[8] geladen te worden:

[source,shell]
....
# service sshd reload
....

=== Meer informatie

http://www.openssh.com/[OpenSSH]

man:ssh[1] man:scp[1] man:ssh-keygen[1] man:ssh-agent[1] man:ssh-add[1] man:ssh_config[5]

man:sshd[8] man:sftp-server[8] man:sshd_config[5]

[[fs-acl]]
== Bestandssysteem toegangscontrolelijsten (ACLs)

In combinatie met verbeteringen als snapshots, biedt FreeBSD de veiligheid van Toegangscontrolelijsten voor Bestandssystemen (Access Control Lists, ACLs).

Met toegangscontrolelijsten wordt het standaard UNIX(R) rechtenmodel uitgebreid op een zeer verenigbare (POSIX(R).1e) manier. Deze methodes stellen een beheerder in staat om gebruik te maken en voordeel te halen uit een geraffineerder beveiligingsmodel.

Om ondersteuning voor ACLs voor bestandssystemen in te schakelen dient het volgende in de kernel gecompileerd te worden:

[.programlisting]
....
options UFS_ACL
....

Als deze optie niet aanwezig is, dan wordt er een waarschuwing weergegeven als er wordt geprobeerd een bestandssysteem aan te koppelen dat gebruik maakt van ACLs. Deze optie is al geactiveerd in de [.filename]#GENERIC# kernel. ACLs zijn afhankelijk van uitgebreide attributen die zijn ingeschakeld op het bestandssysteem. Uitgebreide attributen worden standaard ondersteund in het volgende generatie UNIX(R) bestandssysteem UFS2.

[NOTE]
====
Er is meer administratieve rompslomp nodig om uitgebreide attributen in te stellen op UFS1 dan op UFS2. De prestaties van uitgebreide attributen zijn op UFS2 ook veel beter. Daarom wordt UFS2 ook meestal aangeraden boven UFS1 bij het gebruik van toegangscontrolelijsten.
====

ACLs worden ingeschakeld door de beheersvlag `acls` op het moment van aankoppelen. Dit kan ook in [.filename]#/etc/fstab# staan. De vlag op het moment van aankoppelen kan ook automatisch gezet worden op een persistente wijze met man:tunefs[8] door een superblok in de bestandssysteemkop te wijzigen. In het algemeen wordt de voorkeur gegeven aan de vlag in het superblok om een aantal redenen:

* De ACLs vlag op het moment van aankoppelen kan niet gewijzigd worden bij opnieuw aankoppelen (man:mount[8] `-u`), maar alleen door een volledige man:umount[8] en een verse man:mount[8]. Dit betekent dat ACLs niet ingeschakeld kunnen worden op root-bestandssysteem na het opstarten. Het betekent ook dat de aard van een bestandssysteem niet veranderd kan worden als het eenmaal in gebruik is.
* Het inschakelen van de superblokvlag zorgt ervoor dat het bestandssysteem altijd wordt aangekoppeld met de ACLs ingeschakeld, zelfs als het niet in [.filename]#fstab# staat of als de apparaten van plaats veranderen. Hiermee wordt voorkomen dat het bestandssysteem wordt gebruikt zonder dat ACLs ingeschakeld zijn, wat ervoor zou kunnen zorgen dat ACLs onjuist worden toegepast wat weer kan zorgen voor beveiligingsproblemen.

[NOTE]
====
Wellicht wordt het mogelijk om de ACLs via de vlag in te schakelen zonder een compleet verse man:mount[8], maar de ontwikkelaars vinden het wenselijk om het per ongeluk zonder ACLs aankoppelen te ontmoedigen, omdat er bijzonder vervelende gevolgen kunnen zijn als ACLs worden ingeschakeld, daarna worden uitgezet en weer worden ingeschakeld zonder dat de uitgebreide attributen worden geschoond. In het algemeen geldt dat als ACLs eenmaal zijn ingeschakeld voor een bestandssysteem, ze niet meer uitgeschakeld moeten worden, omdat de resulterende bestandsbescherming wellicht niet compatibel is met dat wat gebruikers van het systeem nodig hebben en het opnieuw aanzetten van ACLs kan leiden tot het opnieuw koppelen van voorheen bestaande ACLs aan bestanden waarvoor de toegangsrechten sindsdien zijn aangepast, wat kan leiden tot onverwachte situaties.
====

Bestandssystemen waarvoor ACLs zijn ingeschakeld worden weergegeven met een `+` (plus) teken als de toegangsrechten worden bekeken:

[.programlisting]
....
drwx------  2 robert  robert  512 Dec 27 11:54 private
drwxrwx---+ 2 robert  robert  512 Dec 23 10:57 directory1
drwxrwx---+ 2 robert  robert  512 Dec 22 10:20 directory2
drwxrwx---+ 2 robert  robert  512 Dec 27 11:57 directory3
drwxr-xr-x  2 robert  robert  512 Nov 10 11:54 public_html
....

Hierboven is te zien dat mappen [.filename]#directory1#, [.filename]#directory2# en [.filename]#directory3# allemaal gebruik maken van ACLs. De map [.filename]#public_html# doet dat niet.

=== Gebruik maken van ACLs

De ACLs van het bestandssysteem kunnen bekeken worden met het hulpprogramma man:getfacl[1]. Om de ACL op het bestand [.filename]#test# te bekijken zou het volgende commando nodig zijn:

[source,shell]
....
% getfacl test
#file:test
#owner:1001
#group:1001
user::rw-
group::r--
other::r--
....

Om de ACL op dit bestand te wijzigen wordt het hulpprogramma man:setfacl[1] als volgt gebruikt:

[source,shell]
....
% setfacl -k test
....

De vlag `-k` verwijdert alle bestaande ACLs van een bestand of bestandssysteem. De methode die de voorkeur geniet is `-b` gebruiken omdat die optie de basisvelden die nodig zijn voor het laten werken van de ACLs laat staan.

[source,shell]
....
% setfacl -m u:trhodes:rwx,group:web:r--,o::--- test
....

Bij het commando hierboven, werd de optie `-m` gebruikt om de standaard ACL aan te passen. Omdat er geen voorgedefinieerde instellingen waren, die waren verwijderd door het commando daarvoor, werden nu de standaardinstellingen hersteld en de rechten die werden aangegeven toegevoegd. Let op dat bij het toevoegen van een gebruiker of een groep die niet bekend is op het systeem een foutmelding `Invalid argument` wordt geschreven naar [.filename]#stdout#.

[[security-portaudit]]
== Monitoren van beveiligingsproblemen met andere software

In de afgelopen jaren zijn er in de beveiligingswereld veel vorderingen gemaakt op het gebied van inzicht in kwetsbaarheden. Als er software naast het besturingssysteem wordt geïnstalleerd en ingesteld neemt op vrijwel ieder besturingssysteem het risico op inbraak toe.

Inzicht in kwetsbaarheid is een vitale factor in beveiliging en hoewel FreeBSD waarschuwingen publiceert voor het basissysteem, gaat het publiceren van waarschuwingen voor alle overige software de scope van het FreeBSD Project te buiten. Er is een manier om inzicht te krijgen in de kwetsbaarheden voor additionele software en als beheerder gewaarschuwd te worden. Voor dit doel bestaat het FreeBSD hulpprogramma Portaudit.

De port package:ports-mgmt/portaudit[] zoekt naar bekende beveiligingsproblemen in een database die wordt bijgewerkt en onderhouden door het FreeBSD Security Team en portontwikkelaars.

Voordat Portaudit gebruikt kan worden dient het geïnstalleerd te worden uit de Portscollectie:

[source,shell]
....
# cd /usr/ports/ports-mgmt/portaudit && make install clean
....

Tijdens het installatieproces worden de instellingenbestanden voor man:periodic[8] bijgewerkt, waardoor Portaudit uitvoer in de dagelijkse security runs meekomt. Het is van belang dat de emails die aan de emailaccount van `root` worden gezonden en uit de dagelijkse beveiligingsronde komen ook echt worden gelezen. Er zijn geen verdere instellingen nodig.

Na de installatie kan de beheerder de database bijwerken en bekende kwetsbaarheden in geïnstalleerde pakketten bekijken met het volgende commando:

[source,shell]
....
# portaudit -Fda
....

[NOTE]
====
De database wordt automatisch bijgewerkt tijdens de man:periodic[8] run; dus het voorgaande commando is volledig optioneel. Het is alleen nodig om de volgende voorbeelden na te kunnen doen.
====

De software de uit de Portscollectie is geïnstalleerd kan op elk moment door een beheerder ge-audit worden met:

[source,shell]
....
# portaudit -a
....

Portaudit zal iets als het volgende produceren voor kwetsbare pakketten:

[.programlisting]
....
Affected package: cups-base-1.1.22.0_1
Type of problem: cups-base -- HPGL buffer overflow vulnerability.
Reference: <http://www.FreeBSD.org/ports/portaudit/40a3bca2-6809-11d9-a9e7-0001020eed82.html>

1 problem(s) in your installed packages found.

You are advised to update or deinstall the affected package(s) immediately.
....

Door met een webbrowser naar de aangegeven URL te gaan kan een beheerder meer informatie over de bewust kwetsbaarheid krijgen, waaronder de versies die het betreft, volgens de FreeBSD Port versie en andere websites waarop beveiligingswaarschuwingen te lezen zijn.

In het kort is Portaudit een krachtig hulpprogramma dat bijzonder handig is als het wordt gekoppeld aan het gebruik van de port Portupgrade.

[[security-advisories]]
== FreeBSD beveiligingswaarschuwingen

Net als veel andere kwalitatief goede productiebesturingssystemen publiceert FreeBSD "Beveiligingswaarschuwingen". Deze waarschuwingen worden meestal pas naar de beveiligingslijst gemaild en gedocumenteerd in de Errata als de van toepassing zijnde uitgaven gepatcht zijn. In deze paragraaf wordt toegelicht wat een waarschuwing is, hoe die te begrijpen en welke maatregelen er genomen moeten worden om een systeem bij te werken.

=== Hoe ziet een waarschuwing eruit?

De FreeBSD beveiligingswaarschuwingen zien er ongeveer uit als die hieronder die van de {freebsd-security-notifications} mailinglijst komt.

[.programlisting]
....
=============================================================================
FreeBSD-SA-XX:XX.UTIL                                     Security Advisory
                                                          The FreeBSD Project

Topic:          denial of service due to some problem <.>

Category:       core <.>
Module:         sys <.>
Announced:      2003-09-23 <.>
Credits:        Person <.>
Affects:        All releases of FreeBSD <.>
                FreeBSD 4-STABLE prior to the correction date
Corrected:      2003-09-23 16:42:59 UTC (RELENG_4, 4.9-PRERELEASE)
                2003-09-23 20:08:42 UTC (RELENG_5_1, 5.1-RELEASE-p6)
                2003-09-23 20:07:06 UTC (RELENG_5_0, 5.0-RELEASE-p15)
                2003-09-23 16:44:58 UTC (RELENG_4_8, 4.8-RELEASE-p8)
                2003-09-23 16:47:34 UTC (RELENG_4_7, 4.7-RELEASE-p18)
                2003-09-23 16:49:46 UTC (RELENG_4_6, 4.6-RELEASE-p21)
                2003-09-23 16:51:24 UTC (RELENG_4_5, 4.5-RELEASE-p33)
                2003-09-23 16:52:45 UTC (RELENG_4_4, 4.4-RELEASE-p43)
                2003-09-23 16:54:39 UTC (RELENG_4_3, 4.3-RELEASE-p39) <.>
CVE Name:   CVE-XXXX-XXXX <.>

For general information regarding FreeBSD Security Advisories,
including descriptions of the fields above, security branches, and the
following sections, please visit
http://www.FreeBSD.org/security/.

I.   Background <.>

II.  Problem Description <.>

III. Impact <.>

IV.  Workaround <.>

V.   Solution <.>

VI.  Correction details <.>

VII. References <.>
....

<.> Het veld `Topic` geeft aan wat precies het probleem is. Het is eigenlijk een inleiding op de beveiligingswaarschuwing en geeft aan welke programma kwetsbaar is.

<.> Het veld `Category` geeft aan welk onderdeel van het systeem kwetsbaar is. Dat kan een van de onderdelen `core`, `contrib` of `ports` zijn. De categorie `core` betekent dat de een kerncomponent van het FreeBSD besturingssysteem kwetsbaar is. De categorie `contrib` betekent dat software die toegevoegd is aan het FreeBSD Project kwetsbaar is, zoals sendmail. Tenslotte geeft de categorie `ports` aan dat een optionele component uit de Portscollectie kwetsbaar is.

<.> Het veld `Module` geeft aan waar de component zich bevindt, bijvoorbeeld `sys`. In dit voorbeeld wordt het duidelijk dat de module `sys` kwetsbaar is. Hier gaat het dus om een kwetsbaar component die gebruikt wordt in de kernel.

<.> Het veld `Announced` geeft aan wanneer de beveiligingswaarschuwing gepubliceerd of aangekondigd is. Dit betekent dat het beveiligingsteam heeft bevestigd dat het probleem bestaat en dat er een patch is gecommit in het depot met de broncode van FreeBSD.

<.> In het veld `Credits` wordt iemand of een organisatie bedankt die de kwetsbaarheid heeft ontdekt en gerapporteerd.

<.> Het veld `Affects` geeft aan welke uitgaven van FreeBSD door deze kwetsbaarheid worden getroffen. Voor de kernel kan snel gekeken worden naar de uitvoer van `ident` voor de betreffende bestanden om te bepalen welke revisie ze hebben. Voor ports is het versienummer te zien in [.filename]#/var/db/pkg#. Als het systeem niet gelijk op loopt met het FreeBSD Subversion-depot en dagelijks herbouwd wordt, dan is de kans groot dat het systeem kwetsbaar is.

<.> Het veld `Corrected` geeft de datum, tijd en tijdzone aan en de uitgave die is aangepast.

<.> Gereserveerd voor de identificatie-informatie die gebruikt wordt om kwetsbaarheden in het Common Vulnerabilities Database System op te zoeken.

<.> Het veld `Background` geeft meer informatie over wat er precies aan de hand is. Meestal staat hier waarom het programma aanwezig is in FreeBSD, waar het voor gebruikt wordt en hoe het programma is ontstaan.

<.> Het veld `Problem Description` geeft gedetailleerde toelichting op het beveiligingsprobleem. Hier kan informatie bij staat over programmacode die fouten bevat of zelfs hoe het programma gebruikt kan worden om een beveiligingsgat te openen.

<.> Het veld `Impact` beschrijft welke invloed het probleem kan hebben op het systeem. Dit kan bijvoorbeeld een ontzegging van dienst aanval zijn, gebruikers extra rechten geven of het verkrijgen van supergebruiker toegang voor de aanvaller zijn.

<.> Het veld `Workaround` geeft aan hoe het mogelijk is het probleem te omzeilen (workaround) in het geval systeembeheerders niet in staat zijn om het systeem bij te werken. Dit zou te maken kunnen hebben met de tijd, beschikbaarheid van het netwerk en een hele lijst met andere redenen. Hoe dan ook, beveiliging dient serieus genomen te worden en een systeem dat kwetsbaar is moet bijgewerkt worden of het gat in de beveiliging moet gedicht worden met de alternatieve oplossing.

<.> Het veld `Solution` geeft instructies over hoe een systeem aangepast kan worden. Dit is een werkinstructie die getest en gecontroleerd is om een systeem aan te passen en weer veilig werkend te krijgen.

<.> In het veld `Correction Details` staan de Subversion-takken of uitgavenamen, met de punten veranderd in een liggend streepje. Er staat ook welke revisienummer de aangetaste bestanden binnen een tak hebben.

<.> In het veld `References` wordt gewoonlijk verwezen naar andere bronnen. Dit kunnen web-URLs, boeken, mailinglijsten en nieuwsgroepen zijn.

[[security-accounting]]
== Procesaccounting

Procesaccounting is een beveiligingsmethode die een beheerder in staat stelt om in de gaten te houden welke systeembronnen worden gebruikt, hoe ze over gebruikers verdeeld zijn, systeemmonitoring biedt en op minimalistische wijze het gebruik van commando's door gebruikers volgt.

Deze methode heeft voordelen en nadelen. Eén van de positieve punten is dat een inbraak gevolgd kan worden tot het moment waarop die zich voordeed. Nadelen zijn de grootte van de logboeken die door procesaccounting worden gegenereerd en de schijfruimte die dat kost. In dit onderdeel wordt een beheerder de basis van procesaccounting getoond.

=== Procesaccounting inschakelen en gebruiken

Voordat procesaccounting gebruikt kan worden dient het te worden ingeschakeld met de volgende commando's:

[source,shell]
....
# touch /var/account/acct
# accton /var/account/acct
# echo 'accounting_enable="YES"' >> /etc/rc.conf
....

Eenmaal ingeschakeld begint accounting met het bijhouden van CPU statistieken, commando's, enzovoort. Alle accounting logboeken worden in een niet leesbaar formaat bijgehouden en zijn uit te lezen met man:sa[8]. Bij het uitvoeren zonder opties, toont `sa` informatie gerelateerd aan het aantal aanroepen per gebruiker, de totale tijd in minuten die is verstreken, de totale CPU- en gebruikerstijd in minuten, gemiddeld aantal I/O operaties, enzovoort.

Informatie over uitgevoerde commando's kan bekeken worden met man:lastcomm[1]. Zo kan met `lastcomm` bijvoorbeeld weergegeven worden welke commando's door gebruikers op een specifieke man:ttys[5] zijn uitgevoerd:

[source,shell]
....
# lastcomm ls trhodes ttyp1
....

Het bovenstaande commando toont ieder bekend gebruikt van `ls` door de gebruiker `trhodes` op terminal `ttyp1`.

Veel andere handige opties staan beschreven in man:lastcomm[1], man:acct[5] en man:sa[8].
