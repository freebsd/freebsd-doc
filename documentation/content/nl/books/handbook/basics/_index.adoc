---
title: Hoofdstuk 4. UNIX® beginselen
part: Deel I. Beginnen
prev: books/handbook/bsdinstall
next: books/handbook/ports
---

[[basics]]
= UNIX(R) beginselen
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:source-highlighter: rouge
:experimental:
:skip-front-matter:
:toc-title: Inhoudsopgave
:table-caption: Tabel
:figure-caption: Afbeelding
:example-caption: Voorbeeld
:xrefstyle: basic
:relfileprefix: ../
:outfilesuffix:
:sectnumoffset: 4

ifeval::["{backend}" == "html5"]
:imagesdir: ../../../../images/books/handbook/basics/
endif::[]

ifeval::["{backend}" == "pdf"]
:imagesdir: ../../../../static/images/books/handbook/basics/
endif::[]

ifeval::["{backend}" == "epub3"]
:imagesdir: ../../../../static/images/books/handbook/basics/
endif::[]

include::shared/authors.adoc[]
include::shared/releases.adoc[]
include::shared/nl/mailing-lists.adoc[]
include::shared/nl/teams.adoc[]
include::shared/nl/urls.adoc[]

toc::[]

[[basics-synopsis]]
== Overzicht

Het volgende hoofdstuk behandelt de basiscommando's en functionaliteit van het FreeBSD besturingssysteem. Veel van dit materiaal is relevant voor elk UNIX(R) achtig besturingssysteem. Als de lezer reeds bekend is met het materiaal, hoeft dit hoofdstuk niet gelezen te worden. Lezer die nog niet eerder met FreeBSD te maken hebben gehad wordt aangeraden door te lezen.

Na het lezen van dit hoofdstuk weet de lezer:

* Hoe "virtuele consoles" in FreeBSD gebruikt kunnen worden;
* Hoe UNIX(R) bestandspermissies werken en hoe bestandsvlaggen in FreeBSD werken;
* Hoe het standaard FreeBSD bestandssysteem eruit ziet;
* Hoe een FreeBSD harde schijf is ingedeeld;
* Hoe bestandssystemen gekoppeld en ontkoppeld worden;
* Wat processen, daemons en signalen zijn;
* Wat een shell is en hoe de standaard omgevingsvariabelen veranderd kunnen worden;
* Hoe elementaire tekstverwerkers te gebruiken;
* Wat apparaten en apparaatkoppelpunten zijn;
* Welk binair formaat FreeBSD gebruikt;
* Hoe handleidingen te gebruiken meer informatie.

[[consoles]]
== Virtuele consoles en terminals

FreeBSD kan op diverse manieren gebruikt worden. Één van deze manieren is het typen van commando's in een tekstterminal. Veel van de flexibiliteit en kracht van een UNIX(R) besturingssysteem is gemakkelijk beschikbaar als je FreeBSD op deze manier gebruikt. Dit onderdeel beschrijft wat "terminals " en "consoles" zijn en hoe je deze kan gebruiken in FreeBSD.

[[consoles-intro]]
=== De console

Als FreeBSD niet is ingesteld om automatisch een grafische omgeving te starten tijdens het opstarten, geeft het systeem een login prompt als het gestart is. Dit gebeurt direct nadat de startscripts klaar zijn. Er wordt iets als het volgende getoond:

[source,bash]
....
Additional ABI support:.
Local package initialization:.
Additional TCP options:.

Fri Sep 20 13:01:06 EEST 2002

FreeBSD/i386 (pc3.example.org) (ttyv0)

login:
....

De meldingen op het scherm kunnen wellicht iets anders zijn op een systeem, maar het zal iets soortgelijks zijn. De laatste twee regels zijn de regels waar het nu over gaat. De voorlaatste regel toont:

[.programlisting]
....
FreeBSD/i386 (pc3.example.org) (ttyv0)
....

Deze regel bevat enkele informatie over het systeem dat net gestart is: dit is een "FreeBSD" console, draaiend op een Intel of soortgelijke processor op de x86 architectuur.  De naam van de machine (elke UNIX(R) machine heeft een naam) is `pc3.example.org` en dit is de console van het systeem, de [.filename]#ttyv0# terminal.

De laatste regel is altijd:

[.programlisting]
....
login:
....

Dit is het deel waar een "gebruikersnaam" ingevuld moet worden om aan te melden op FreeBSD. Het volgende deel beschrijft hoe dat werkt.

[[consoles-login]]
=== Aanmelden op FreeBSD

FreeBSD is een multi-user en multi-processing systeem. Dit is de formele beschrijving die meestal gegeven wordt aan een systeem dat gebruikt wordt door meerdere personen die gelijktijdig verschillende programma's draaien op één enkele machine.

Elk multi-user systeem heeft een manier nodig om een "gebruiker" van alle andere gebruikers te kunnen onderscheiden. In FreeBSD (en alle andere UNIX(R) achtige besturingssystemen), wordt dit bereikt door te eisen dat elke gebruiker moet "aanmelden" op het systeem voordat hij/zij programma's kan draaien. Elke gebruiker heeft een unieke naam (de "gebruikersnaam") en een persoonlijke, geheime sleutel (het "wachtwoord"). FreeBSD vraagt om deze twee gegevens voordat het een gebruiker toegestaat om programma's te draaien.

Direct nadat FreeBSD is opgestart en de opstartscripts  afgerond zijn, wordt een prompt getoond dat vraagt om een geldige aanmeldnaam op te geven.

[source,bash]
....
login:
....

In dit voorbeeld wordt aangenomen de gebruikersnaam `john` is. Als na deze prompt `john` wordt getype en op kbd:[Enter] wordt gedrukt, verschijnt hierna een prompt om het " wachtwoord" in te voeren:

[source,bash]
....
login: john
Password:
....

Nu kan `john`'s wachtwoord ingevoerd worden en op kbd:[Enter] gedrukt worden. Het wachtwoord wordt _niet getoond_! Daarover hoeft geen zorg te bestaan. Het is voldoende om te zeggen dat dit om veiligheidsredenen gedaan wordt.

Als het juiste wachtwoord is ingegeven, is er aangemeld bij op FreeBSD en in het systeem klaar om alle beschikbare commando's uit te voeren.

Na het aanmelden is de MOTD of het bericht van de dag zichtbaar, gevolgd door een commandoprompt (een `#`, `$` of een `%` karakter). Dit geeft aan dat er succesvol is aangemeld op FreeBSD.

[[consoles-virtual]]
=== Meerdere consoles

UNIX(R) programma's draaien in één console is prima, maar FreeBSD kan veel programma's tegelijk draaien. Om maar één console te hebben waar commando's ingetypt kunnen worden zou zonde zijn van een besturingssysteem als FreeBSD waar meerdere programma's tegelijkertijd op kunnen draaien. Hier kunnen "virtuele consoles" van pas komen.

FreeBSD kan ingesteld worden om verschillende virtuele consoles te tonen. Met toetscombinaties kan van de ene console naar de gewisseld worden. Elke console heeft zijn eigen uitvoerkanaal, en FreeBSD zorgt ervoor dat alle toetsenbordinvoer en monitoruitvoer goed wordt gezet als er van de ene console naar de volgende wordt gewisseld.

In FreeBSD kunnen speciale toetscombinaties gebruikt worden om te wisselen naar een ander virtueel console.  In FreeBSD kan kbd:[Alt+F1], kbd:[Alt+F2] tot en met kbd:[Alt+F8] gebruikt worden om te wisselen naar een ander virtueel console.

Als wordt gewisseld van de ene naar de andere console zorgt FreeBSD dat de uitvoer bewaard blijft. Het resultaat is een "illusie" van het hebben van meerdere schermen en toetsenborden die gebruikt kunnen worden om commando's in te voeren om FreeBSD te laten draaien. De programma's die in de ene virtuele console draaien, stoppen niet als de console niet zichtbaar is. Ze blijven doordraaien als naar een andere virtuele console wordt gewisseld.

[[consoles-ttys]]
=== Het bestand [.filename]#/etc/ttys#

De standaardinstelling van FreeBSD start op met acht virtuele consoles. Dit is echter geen vaste waarde en een installatie kan eenvoudig aangepast worden, zodat het systeem gestart wordt met meer of minder virtuele consoles. De hoeveelheid en instellingen van de virtuele consoles worden ingesteld in [.filename]#/etc/ttys#.

[.filename]#/etc/ttys# kan gebruikt worden om virtuele consoles in te stellen. Elke niet-commentaar regel in dit bestand (regels die niet beginnen met een `#` karakter) bevat instellingen voor een terminal of virtuele console. De standaardversie van dit bestand die meegeleverd wordt met FreeBSD stelt negen virtuele consoles in en activeert er acht. Dit zijn de regels die beginnen met `ttyv`:

[.programlisting]
....
# naam  getty                             type    status           commentaar
#
ttyv0   "/usr/libexec/getty Pc"         cons25  on  secure
# Virtual terminals
ttyv1   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv2   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv3   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv4   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv5   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv6   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv7   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv8   "/usr/X11R6/bin/xdm -nodaemon"  xterm   off secure
....

Een uitgebreide beschrijving van elke kolom in dit bestand en alle mogelijke opties voor virtuele consoles staan in de man:ttys[5] hulppagina gebruiken.

[[consoles-singleuser]]
=== Single-user console

In crossref:boot[boot-singleuser,Single-user modus] staat een gedetailleerde beschrijving van de "single-user modus". Het is belanrijk te melden dat er in single-user modus maar één console is. Er zijn geen virtuele consoles beschikbaar. De instellingen van de single-user modus console staan ook in [.filename]#/etc/ttys#. De regel begint met `console`:

[.programlisting]
....
# name  getty                             type    status           commentaar
#
# Als een console gemarkeerd is als "insecure", zal het init script om het root-wachtwoord
# vragen wanneer het in single-user mode komt.
console none                              unknown off secure
....

[NOTE]
====
Zoals het commentaar boven de `console` regel aangeeft, kan in deze regel het woord `secure` gewijzigd worden in `insecure`. In dat geval vraagt FreeBSD bij het opstarten in single-user modus nog steeds om een `root`-wachtwoord.

_Pas op als dit wordt veranderd in `_insecure_`_. Als het wachtwoord van de gebruiker `root` zoek is, wordt het opstarten in single-user modus lastig. Het is nog steeds mogelijk, maar het kan vrij moeilijk zijn voor iemand die FreeBSD niet zo goed kent met betrekking tot het opstarten en de programma's die daarbij gebruikt worden.
====

[[consoles-vidcontrol]]
=== Het wijzigen van de console video mode

De FreeBSD standaard video mode kan worden gewijzigd in 1024x768, 1280x1024, of een van de vele andere formaten die ondersteund worden door de grafische kaart en monitor. Laad de module `VESA` om gebruik te maken van de verschillende video modes:

[source,bash]
....
# kldload vesa
....

Kijk daarna welke video modes er ondersteund worden door de hardware door gebruik te maken van de man:vidcontrol[1] applicatie. Om een overzicht te krijgen van de ondersteunde video modes moet het volgende ingevoerd worden:

[source,bash]
....
# vidcontrol -i mode
....

Het resultaat van dit commando is een lijst van video modes welke ondersteund worden door de hardware. Hierna kan de nieuwe video mode gekozen worden door dit aan te geven aan man:vidcontrol[1]:

[source,bash]
....
# vidcontrol MODE_279
....

Als de nieuwe video mode acceptabel is, kan dit permanent ingesteld worden door het volgende in [.filename]#/etc/rc.conf# te zetten:

[.programlisting]
....
allscreens_flags="MODE_279"
....

[[permissions]]
== Rechten

FreeBSD, direct afgeleid van BSD UNIX(R), is gebaseerd op verschillende belangrijke UNIX(R) concepten. Het meest bekende is dat FreeBSD een multi-user systeem is. Het systeem kan meerdere gebruikers behandelen die tegelijkertijd totaal verschillende dingen doen. Het systeem is verantwoordelijk voor het netjes delen en beheren voor aanvragen voor hardware, randapparatuur, geheugen en cpu tijd tussen elke gebruiker.

Omdat het systeem in staat is om meerdere gebruikers te ondersteunen, heeft alles wat door het systeem beheerd wordt een set van rechten die aangeeft wie mag lezen, schrijven en de bron mag uitvoeren. Deze rechten zijn opgeslagen in drie octetten, die weer in drie stukjes onderverdeeld zijn: één voor de eigenaar van het bestand, één voor de groep waar het bestand toe behoort en één voor de overigen. De numerieke weergave werkt als volgt:

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Waarde
| Recht
| Maprecht

|0
|Niet lezen, niet schrijven, niet uitvoeren
|`---`

|1
|Niet lezen, niet schrijven, uitvoeren
|`--x`

|2
|Niet lezen, schrijven, niet uitvoeren
|`-w-`

|3
|Niet lezen, schrijven, uitvoeren
|`-wx`

|4
|Lezen, niet schrijven, niet uitvoeren
|`r--`

|5
|Lezen, niet schrijven, uitvoeren
|`r-x`

|6
|Lezen, schrijven, niet uitvoeren
|`rw-`

|7
|Lezen, schrijven, uitvoeren
|`rwx`
|===

De `-l` optie kan gebruikt worden met man:ls[1] om een lange lijst met de inhoud van een map te zien die een kolom heeft met informatie over bestandsrechten voor de eigenaar, groep en de rest. `ls -l` in een willekeurige map kan het volgende laten zien:

[source,bash]
....
% ls -l
total 530
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 myfile
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 otherfile
-rw-r--r--  1 root  wheel    7680 Sep  5 12:31 email.txt
...
....

Zo ziet de eerste kolom van `ls -l` eruit:

[source,bash]
....
-rw-r--r--
....

Het eerste (meest linkse) karakter geeft aan of dit een reguliere bestand is, een map, een speciaal karakter component(!), een socket of een andere pseudo-file component(!). In dit geval betekent de `-` dat het een regulier bestand is. De volgende drie karakters, `rw-` in dit voorbeeld, geven de rechten voor de eigenaar van het bestand. De drie karakters `r--` erna geven de rechten van voor de groep van het bestand. De overige drie karakters `r--` tonen de rechten voor alle overige gebruikers. Een streepje betekent dat de rechten uitgeschakeld zijn. In het geval van dit bestand zijn de rechten zo ingesteld dat de eigenaar kan lezen en schrijven naar het bestand, de groep het bestand kan lezen, en alle overige gebruikers kunnen ook het bestand lezen. Volgens de tabel hierboven worden de rechten `644`, waar de cijfers de drie stukjes van de rechten aangeven.

Dit is allemaal leuk en aardig, maar hoe controleert het systeem dan rechten voor apparaten? FreeBSD behandelt de meeste hardware apparaten als bestanden die door programma's kunnen worden geopend en gelezen, en waar data naar toe kan worden geschreven, net zoals elk ander bestand. Deze speciale apparaat bestanden worden bewaard in de map [.filename]#/dev#.

Mappen worden ook behandeld als bestanden. Ze hebben lees, schrijf en uitvoerbare rechten. De uitvoerbare vlag voor een map heeft een klein verschil qua betekenis dan die voor gewone bestanden. Als een map als uitvoerbaar gemarkeerd is, betekent het dat erin gekeken mag worden. Het is dus mogelijk om te wisselen naar de map met `cd` (wissel van map). Dit betekent ook dat in de map bestanden benaderd kunnen worden waarvan de naam bekend is. Dit is natuurlijk afhankelijk van de rechten op het bestand zelf.

In het bijzonder, om een lijst van de map te kunnen maken, moet een gebruiker leesrechten op de map hebben. Om een bestand te verwijderen zijn de naam van het bestand en schrijf _en_ uitvoerrechten op de map nodig waarin het bestand zich bevindt.

Er zijn meer rechtenvlaggen, maar die worden slechts gebruikt in speciale gevallen, zoals bij setuid binaries en sticky mappen. Meer informatie over bestandsrechten en hoe die aangepast kunnen worden staat in man:chmod[1].

=== Symbolische rechten

Symbolische rechten, soms ook wel symbolische expressies, gebruiken karakters in plaats van octale getallen om rechten aan bestanden en mappen te geven. Symbolische expressies gebruiken de volgende opbouw: (wie) (actie) (permissies), waar de volgende waardes beschikbaar zijn:

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| Optie
| Letter
| Vertegenwoordigt

|(wie)
|u
|Gebruiker

|(wie)
|g
|Groepseigenaar

|(wie)
|o
|Overigen

|(wie)
|a
|Iedereen ("wereld")

|(actie)
|+
|Rechten toevoegen

|(actie)
|-
|Rechten verwijderen

|(actie)
|=
|Stel deze rechten in

|(recht)
|r
|Lezen

|(recht)
|w
|Schrijven

|(recht)
|x
|Uitvoeren

|(recht)
|t
|Sticky bit

|(recht)
|s
|Verander UID of GID
|===

Deze waardes worden gebruikt met man:chmod[1], net zoals eerder, alleen nu met letters. Het volgende commando kan gebruikt worden om de overige gebruikers toegang tot _BESTAND_ te ontzeggen:

[source,bash]
....
% chmod go= BESTAND
....

Er kan een door komma's gescheiden lijst geleverd worden als meer dan één wijziging aan een bestand moet worden uitgevoerd. Het volgende commando past de rechten voor de groep en de "wereld" aan door de schrijfrechten te ontnemen om daarna iedereen uitvoerrechten te geven:

[source,bash]
....
% chmod go-w,a+x BESTAND
....

=== FreeBSD bestandsvlaggen

Naast de bestandsrechten die hiervoor zijn besproken, biedt FreeBSD ondersteuning voor "bestandsvlaggen." Deze vlaggen bieden een aanvullend beveiligingsniveau en controle over bestanden, maar niet over mappen.

Bestandsvlaggen voegen een extra niveau van controle over bestanden, waardoor verzekerd kan worden dat in sommige gevallen zelfs `root` een bestand niet kan verwijderen of wijzigen.

Bestandsvlaggen worden gewijzigd met het hulpprogramma man:chflags[1], dat een eenvoudige interface heeft. Om bijvoorbeeld de systeemvlag niet verwijderdbaar in te stellen op het bestand [.filename]#file1#:

[source,bash]
....
# chflags sunlink file1
....

Om de vlag niet verwijderbaar weer te verwijderen kan het voorgaande commando met "no" voor `sunlink` worden uitgevoerd:

[source,bash]
....
# chflags nosunlink file1
....

Om de vlaggen op een bestand te bekijken, kan het man:ls[1] commando met de vlaggen `-lo` gebruikt worden:

[source,bash]
....
# ls -lo file1
....

De uitvoer hoort er ongeveer als volgt uit te zien:

[.programlisting]
....
-rw-r--r--  1 trhodes  trhodes  sunlnk 0 Mar  1 05:54 file1
....

Een aantal vlaggen kan alleen ingesteld of verwijderd worden door de gebruiker `root`. In andere gevallen kan de eigenaar van een bestand vlaggen instellen. Meer informatie voor beheerders staat in man:chflags[1] en man:chflags[2].

=== De `setuid`-, `setgid`-, en `klevende` toestemmingen

Buiten de toestemmingen die reeds besproken zijn, zijn er nog drie specifieke instellingen waarvan alle beheerders kennis dienen te hebben. Dit zijn de `setuid`-, `setgid`-, en `sticky` toestemmingen.

Deze instellingen zijn belangrijk voor sommige UNIX(R)-bewerkingen omdat ze functionaliteit bieden die normaliter niet aan normale gebruikers wordt gegeven. Om ze te begrijpen, dient ook het verschil tussen de echte gebruikers-ID en de effectieve gebruikers-ID opgemerkt te worden.

De echte gebruikers-ID is de UID die het proces start of bezit. De effectieve UID is de gebruikers-ID waaronder het proces draait. Bijvoorbeeld, het gereedschap man:passwd[1] draait met de echte gebruikers-ID van de gebruiker die het wachtwoord verandert; echter, om de database met wachtwoorden te manipuleren, draait het met de effectieve ID van de gebruiker `root`. Dit is wat normale gebruikers in staat stelt om hun wachtwoorden te veranderen zonder een fout `Permission Denied` te zien.

[NOTE]
====
De man:mount[8]-optie `nosuid` zorgt ervoor dat deze binairen zwijgend falen. Dit houdt in dat ze niet worden uitgevoerd zonder ooit de gebruiker op de hoogte te stellen. Deze optie is ook niet geheel betrouwbaar aangezien een `nosuid`-wrapper dit volgens de handleidingpagina man:mount[8] kan omzeilen.
====

De setuid-toestemming kan aangezet worden door het cijfer vier (4) voor een toestemmingenverzameling te plaatsen zoals te zien is in het volgende voorbeeld:

[source,bash]
....
# chmod 4755 suidvoorbeeld.sh
....

De toestemmingen op het bestand [.filename]#suidvoorbeeld.sh# dienen er nu als volgt uit te zien:

[.programlisting]
....
-rwsr-xr-x   1 trhodes  trhodes    63 Aug 29 06:36 suidvoorbeeld.sh
....

Het zou in dit voorbeeld te zien moeten zijn dat een `s` nu deel is van de toestemmingenverzameling bestemd voor de bestandseigenaar, en de uitvoerbare bit vervangt. Dit staat gereedschappen toe die verhoogde toestemmingen nodig hebben, zoals `passwd`.

Open twee terminals om dit in real-time te zien. Start op het ene het proces `passwd` als een normale gebruiker. Controleer de procestabel terwijl het op een nieuw wachtwoord wacht en kijk naar de gebruikersinformatie van het commando `passwd`.

In terminal A:

[source,bash]
....
Changing local password for trhodes
Old Password:
....

In terminal B:

[source,bash]
....
# ps aux | grep passwd
....

[source,bash]
....
trhodes  5232  0.0  0.2  3420  1608   0  R+    2:10AM   0:00.00 grep passwd
root     5211  0.0  0.2  3620  1724   2  I+    2:09AM   0:00.01
....

Zoals boven vermeld, wordt `passwd` door een normale gebruiker gedraaid, maar gebruikt het de effectieve UID van `root`.

De `setgid`-toestemming voert dezelfde functie uit als de `setuid`-toestemming; behalve dat het de groepsinstellingen verandert. Wanneer een applicatie of gereedschap met deze instelling wordt gedraaid, krijgt het de toestemmingen gebaseerd op de groep die het bestand bezit, niet op de gebruiker die het proces startte.

Om de `setgid`-toestemming op een bestand aan te zetten, dient een voorlopende twee (2) aan het commando `chmod` gegeven te worden zoals in het volgende voorbeeld:

[source,bash]
....
# chmod 2755 sgidvoorbeeld.sh
....

De nieuwe instelling kan zoals hierboven bekeken worden, merk op dat de `s` nu in het veld bestemd voor de instellingen van de groepstoestemmingen staat:

[.programlisting]
....
-rwxr-sr-x   1 trhodes  trhodes    44 Aug 31 01:49 sgidvoorbeeld.sh
....

[NOTE]
====
In deze voorbeelden zal het shellscript niet met een andere EUID of effectief gebruikers-ID draaien, zelfs al is het shellscript uitvoerbaar. Dit is omdat shellscripts geen toegang hebben tot de man:setuid[2]-systeemaanroepen.
====

De eerste twee speciale toestemmingsbits die we besproken hebben (de toestemmingsbits `setuid` en `setgid`) kunnen de systeemveiligheid verlagen, door verhoogde toestemmingen toe te staan. Er is een derde bit voor speciale toestemmingen die de veiligheid van een systeem kan verhogen: de `klevende bit`.

De `klevende bit`, wanneer deze op een map is ingesteld, staat alleen het verwijderen van bestanden toe door de eigenaar van die bestanden. Deze toestemmingenverzameling is nuttig om het verwijderen van bestanden in publieke mappen, zoals [.filename]#/tmp#, door gebruikers die het bestand niet bezitten te voorkomen. Zet een één (1) voor de toestemming om deze toestemming te gebruiken. Bijvoorbeeld:

[source,bash]
....
# chmod 1777 /tmp
....

Het effect kan nu met het commando `ls` bekeken worden:

[source,bash]
....
# ls -al / | grep tmp
....

[source,bash]
....
drwxrwxrwt  10 root  wheel         512 Aug 31 01:49 tmp
....

De toestemming `klevende bit` is te onderscheiden met de `t` aan het einde van de verzameling.

[[dirstructure]]
== Mappenstructuur

De FreeBSD mappenstructuur is erg belangrijk om het systeem goed te leren kennen. Het belangrijkste concept om greep op te krijgen is die van de rootmap, "/". Deze map is de eerste die gekoppeld wordt tijdens het opstarten en bevat het basissysteem dat nodig is om het besturingssysteem gereed te maken voor multi-user taken. De rootmap bevat ook koppelpunten voor elk ander bestandssysteem dat misschien gekoppeld wordt.

Een koppelpunt is een map waar extra bestandssystemen aan het een bestandssysteem gekoppeld kunnen worden (meestal het root bestandssysteem). Dit wordt beschreven in <<disk-organization>>. Standaard koppelpunten zijn [.filename]#/usr#, [.filename]#/var#, [.filename]#/tmp#, [.filename]#/mnt# en [.filename]#/cdrom#. Naar deze mappen wordt meestal verwezen in [.filename]#/etc/fstab#, een tabel met bestandssystemen en koppelpunten ter referentie voor het systeem. De meeste bestandssystemen in [.filename]#/etc/fstab# worden automatisch gekoppeld tijdens het opstarten door het script man:rc[8], behalve als de optie `noauto` gedefinieerd is. Details staan beschreven in <<disks-fstab>>.

Een complete beschrijving over het bestandssysteem staat in man:hier[7]. Hier wordt volstaan met een overzicht van de voorkomende mappen.

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Map
| Omschrijving

|[.filename]#/#
|Rootmap van het bestandssysteem.

|[.filename]#/bin/#
|Gebruikersapplicaties, belangrijk voor zowel single user als multi-user omgevingen.

|[.filename]#/boot/#
|Programma's en instellingenbestanden die gebruikt worden tijdens het opstarten van het besturingssysteem.

|[.filename]#/boot/defaults/#
|Bestanden met standaardinstellingen voor opstarten;, zie man:loader.conf[5].

|[.filename]#/dev/#
|Apparaatnodes;, zie man:intro[4].

|[.filename]#/etc/#
|Bestanden met systeeminstellingen en scripts.

|[.filename]#/etc/defaults/#
|Bestanden met standaard systeeminstellingen;, zie man:rc[8].

|[.filename]#/etc/mail/#
|Instellingenbestanden voor mail transport programma's zoals man:sendmail[8].

|[.filename]#/etc/namedb/#
|Instellingenbestanden voor `named`, zie man:named[8].

|[.filename]#/etc/periodic/#
|Scripts die dagelijks, wekelijks en maandelijks via man:cron[8] worden uitgevoerd, zie man:periodic[8].

|[.filename]#/etc/ppp/#
|Instellingenbestanden voor `ppp`, zie man:ppp[8].

|[.filename]#/mnt/#
|Lege map, veel gebruikt door systeembeheerders als tijdelijk koppelpunt voor opslagruimtes.

|[.filename]#/proc/#
|Process bestandssysteem;, zie man:procfs[5] en man:mount_procfs[8].

|[.filename]#/rescue/#
|Statisch gelinkte programma's voor noodherstel, zie man:rescue[8].

|[.filename]#/root/#
|Thuismap van de gebruiker `root`.

|[.filename]#/sbin/#
|Systeemprogramma's en administratieprogramma's belangrijk voor zowel single-user en multi-user omgevingen.

|[.filename]#/tmp/#
|Tijdelijke bestanden. De inhoud van [.filename]#/tmp# blijft meestal NIET bewaard na een herstart. Er wordt vaak een geheugengebaseerd bestandssysteem gekoppeld op [.filename]#/tmp#. Dit kan geautomatiseerd worden met de tmpmfs-gerelateerde variabelen van man:rc.conf[5] (of met een regel in [.filename]#/etc/fstab#). Zie man:mdmfs[8].

|[.filename]#/usr/#
|Hier bevindt zich het leeuwendeel van alle hulpprogramma's en gewone programma's.

|[.filename]#/usr/bin/#
|Standaard programma's, programmeertools.

|[.filename]#/usr/include/#
|Standaard C invoegbestanden.

|[.filename]#/usr/lib/#
|Functiebibliotheken.

|[.filename]#/usr/libdata/#
|Diverse databestanden voor hulpprogramma's.

|[.filename]#/usr/libexec/#
|Systeemdaemons en systeemhulpprogramma's (uitgevoerd door andere programma's).

|[.filename]#/usr/local/#
|Lokale programma's, bibliotheken, etc. Wordt ook gebruikt als standaard locatie voor de FreeBSD ports. Binnen [.filename]#/usr/local#, wordt de algemene layout bepaald door man:hier[7], dat ook voor [.filename]#/usr# wordt gebruikt. Uitzonderingen is de map man, die direct onder [.filename]#/usr/local# ligt in plaats van onder [.filename]#/usr/local/share#, en de documentatie voor ports is te vinden in [.filename]#share/doc/port#.

|[.filename]#/usr/obj/#
|Architectuur afhankelijke doelstructuur voor resultaten van de bouw van [.filename]#/usr/src#.

|[.filename]#/usr/ports/#
|De FreeBSD Portscollectie (optioneel).

|[.filename]#/usr/sbin/#
|Systeemdaemons en systeemhulpprogramma's (uitgevoerd door gebruikers).

|[.filename]#/usr/shared/#
|Architectuur onafhankelijke bestanden.

|[.filename]#/usr/src/#
|BSD en/of lokale broncodebestanden.

|[.filename]#/usr/X11R6/#
|Uitvoerbare bestanden en bibliotheken, etc, voor de X11R6 distributie (optioneel).

|[.filename]#/var/#
|Multifunctionele logboek-, tijdelijke, transparante en spool bestanden.

|[.filename]#/var/log/#
|Diverse logboekbestanden van het systeem.

|[.filename]#/var/mail/#
|Postbusbestanden van gebruikers.

|[.filename]#/var/spool/#
|Diverse printer- en mailsysteemspoolingmappen.

|[.filename]#/var/tmp/#
|Tijdelijke bestanden die bewaard worden bij een herstart van het systeem.

|[.filename]#/var/yp/#
|NIS maps.
|===

[[disk-organization]]
== Organisatie van schijven

De kleinste vorm van organisatie die FreeBSD gebruikt om bestanden te vinden is de bestandsnaam. Bestandsnamen zijn hoofdlettergevoelig, wat betekent dat [.filename]#readme.txt# en [.filename]#README.TXT# twee verschillende bestanden zijn. FreeBSD gebruikt de extensie niet ([.filename]#.txt#) van een bestand om te bepalen of het bestand een programma, een document of een vorm van data is.

Bestanden worden bewaard in mappen. Een map kan leeg zijn of honderden bestanden bevatten. Een map kan ook andere mappen bevatten, wat het mogelijk maakt om een hiërarchie van mappen te maken. Dit maakt het veel makkelijker om data te organiseren.

Bestanden en mappen worden aangegeven door het bestand of de map aan te geven, gevolgd door een voorwaardse slash, `/`, gevolgd door andere mapnamen die nodig zijn. Als map [.filename]#foo# de map [.filename]#bar# bevat, die op zijn beurt het bestand [.filename]#readme.txt# bevat, dan wordt de volledige naam of _pad_ naar het bestand [.filename]#foo/bar/readme.txt#.

Mappen en bestanden worden bewaard op een bestandssysteem. Elk bestandssysteem bevat precies één map op het hoogste niveau die _de rootmap_ van het bestandssysteem heet. Deze rootmap kan op zijn beurt andere mappen bevatten.

Tot zover is dit waarschijnlijk hetzelfde als voor elk ander besturingssysteem. Er zijn een paar verschillen. MS-DOS(R) gebruikt bijvoorbeeld een `\` om bestanden en mappen te scheiden, terwijl Mac OS(R) gebruik maakt van `:`.

FreeBSD gebruikt geen schijfletters, of andere schijfnamen in het pad. FreeBSD gebruikt geen [.filename]#c:/foo/bar/readme.txt#.

Eén bestandssysteem wordt aangewezen als _root_ bestandssysteem, waar naar wordt verwezen met `/`. Elk ander bestandssysteem wordt daarna _gekoppeld_ onder het root bestandssysteem. Hoeveel schijven er ook aan een FreeBSD systeem hangen, het lijkt alsof elke map zich op dezelfde schijf bevindt.

Stel er zijn drie bestandssystemen met de namen `A`,`B` en `C`. Elk bestandssysteem heeft één root map die twee andere mappen bevat, `A1` en `A2` (zo ook voor de andere twee: `B1`, `B2`, `C1` en `C2`).

`A` wordt het root besturingsysteem. Met `ls`, dat de inhoud van de map kan tonen, zijn de twee mappen `A1` en `A2` te zien. De mappenstructuur ziet er als volgend uit:

image::example-dir1.png[]

Een bestandssysteem moet gekoppeld worden in een map op een ander bestandssysteem. Als nu bestandssysteem `B` wordt gekoppeld onder de map `A1` vervangt `B``A1` en zien de koppelingen in `B` er als volgt uit:

image::example-dir2.png[]

Elk bestand dat in de mappen `B1` en `B2` aanwezig is, kan benaderd worden met het pad [.filename]#/A1/B1# of [.filename]#/A1/B2#. Elk bestand dat in [.filename]#/A1# stond is tijdelijk verborgen en komt tevoorschijn als `B`is _ontkoppeld_van A.

Als `B` gekoppeld is onder `A2` ziet de diagram er als volgt uit:

image::example-dir3.png[]

en de paden zouden dan respectievelijk [.filename]#/A2/B1# en [.filename]#/A2/B2# zijn.

Bestandssystemen kunnen op elkaar worden gekoppeld. Doorgaand op het vorige voorbeeld kan het bestandssysteem `C` gekoppeld worden bovenop de map `B1` in het bestandssysteem `B`. Dit resulteert in:

image::example-dir4.png[]

Of `C` kan direct onder het bestandssysteem `A` gekoppeld worden, onder de map `A1`:

image::example-dir5.png[]

Hoewel het niet gelijk is, lijkt het op het gebruik van `join` in MS-DOS(R).

Beginnende gebruikers hoeven zich hier gewoonlijk niet mee bezig te houden. Normaal gesproken worden bestandssystemen gemaakt als FreeBSD wordt geïnstalleerd en er wordt besloten waar ze gekoppeld worden. Meestal worden ze ook niet gewijzigd tot er een nieuwe schijf aan een systeem wordt toegevoegd.

Het is mogelijk om één groot root bestandssysteem te hebben en geen andere. Deze benadering heeft voordelen en nadelen.

.Voordelen van meerdere bestandssystemen
* Verschillende bestandssystemen kunnen verschillende _mount opties_ hebben. Met een goede voorbereiding kan het root bestandssysteem bijvoorbeeld als alleen-lezen gekoppeld worden, waardoor het onmogelijk wordt om per ongeluk kritische bestanden te verwijderen of te bewerken. Het scheiden van andere bestandssystemen die beschrijfbaar zijn door gebruikers, zoals [.filename]#/home# van andere bestandssystemen stelt de beheerder in staat om ze _nosuid_ te koppelen. Deze optie voorkomt dat _suid_/_guid_ bits op uitvoerbare bestanden effectief gebruikt kunnen worden, waardoor de beveiliging mogelijk beter wordt.
* FreeBSD optimaliseert automatisch de layout van bestanden op een bestandssysteem, afhankelijk van hoe het bestandssysteem wordt gebruikt. Een bestandsysteem dat veel bestanden bevat waar regelmatig naar geschreven wordt, wordt anders geoptimaliseerd dan een bestandssysteem dat minder maar grotere bestanden bevat. Door het gebruik van één groot bestandssysteem werkt deze optimalisatie niet.
* FreeBSD's bestandssystemen zijn erg robuust als er bijvoorbeeld een stroomstoring is, hoewel een stroomstoring op een kritiek moment nog steeds kan leiden tot schade aan de structuur van het bestandssysteem. Door het verdelen van data over meerdere bestandssystemen, is de kans groter dat het systeem nog opstart, wat terugzetten van een back-up makkelijker maakt als dat nodig is.

.Voordeel van één bestandssysteem
* Bestandssystemen hebben een vaste grootte. Als bij de installatie van FreeBSD een bestandssysteem wordt gemaakt, is het later mogelijk dat de partitie groter gemaakt moet worden. Dit is niet zo makkelijk zonder een back-up, het opnieuw maken van het bestandssysteem met gewijzigde grootte en het terugzetten van de geback-upte gegevens.
+
[IMPORTANT]
====
FreeBSD heeft man:growfs[8] waarmee de grootte van het bestandssysteem is aan te passen terwijl het draait.
====

Bestandssystemen worden opgeslagen in partities. Dit betekent niet hetzelfde als de algemene betekenis van de term partitie (bijvoorbeeld, MS-DOS(R) partitie), vanwege FreeBSD's UNIX(R) achtergrond. Elke partitie wordt geïdentificeerd door een letter van `a` tot en met `h`. Elke partitie kan slechts één bestandssysteem hebben, wat betekent dat bestandssystem vaak omschreven worden aan de hand van hun koppelpunt in de bestandssysteem hiërarchie of de letter van de partitie waar ze in opgeslagen zijn.

FreeBSD gebruikt ook schijfruimte voor _wisselbestanden_. Wisselbestanden geven FreeBSD _virtueel geheugen_. Dit geeft de computer de mogelijkheid om net te doen alsof er veel meer geheugen in de machine aanwezig is dan werkelijk het geval is. Als FreeBSD geen geheugen meer heeft, verplaatst het data die op dat moment niet gebruikt wordt naar de wisselbestanden en plaatst het terug als het wel nodig is (en zet iets anders in ruil daarvoor terug).

Aan sommige partities zijn bepaalde conventies gekoppeld.

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Partitie
| Conventie

|`a`
|Bevat meestal het root bestandssysteem

|`b`
|Bevat meestal de swapruimte

|`c`
|Heeft meestal dezelfde grootte als de hele harde schijf. Dit geeft hulpprogramma's de mogelijkheid om op een complete schijf te werken (voor bijvoorbeeld een bad block scanner) om te werken op de `c` partitie. Meest wordt hierop dan ook geen bestandssysteem gecreeërd.

|`d`
|Partitie `d` had vroeger een speciale betekenis, maar die is verdwenen. `d` zou nu kunnen werken als een normale partitie.
|===

Elke partitie die een bestandssysteem bevat is opgeslagen in wat FreeBSD noemt een _slice_. Slice is FreeBSD's term voor wat meeste mensen partities noemen. Dit komt wederom door FreeBSD's UNIX(R) achtergrond. Slices zijn genummerd van 1 tot en met 4.

Slicenummers volgen de apparaatnamen, voorafgegaan door een `s` die begint bij 1. Dus "da0_s1_" is de eerste slice op de eerste SCSI drive. Er kunnen maximaal vier fysieke slices op een schijf staan, maar er kunnen logische slices in fysieke slices van het correcte type staan. Deze uitgebreide slices zijn genummerd vanaf 5. Dus "ad0_s5_" is de eerste uitgebreide slice op de eerste IDE schijf. Deze apparaten worden gebruikt door bestandssystemen waarvan verwacht wordt dat ze een slice in beslag nemen.

Slices, "gevaarlijk toegewijde" (dangerously dedicated) fysieke drivers en andere drives bevatten _partities_, die worden weergegeven door letters vanaf `a` tot `h`. Deze letter wordt achter de apparaatnaam geplakt. Dus "da0_a_" is de a partitie op de eerste da drive, die "gevaarlijk toegewijd" is. "ad1s3_e_" is de vijfde partitie op de derde slice van de tweede IDE schijf.

Elke schijf op het systeem wordt geïdentificeerd. Een schijfnaam start met een code die het type aangeeft en dan een nummer dat aangeeft welke schijf het is. In tegenstelling tot bij slices, start het nummeren van schijven bij 0. Standaardcodes staan beschreven in <<basics-dev-codes>>.

Bij een referentie aan een partitie verwacht FreeBSD ook dat de slice en schijf refereert naar die partitie en als naar een slice wordt verwezen moet ook de schijfnaam genoemd worden. Dit kan door de schijfnaam, `s`, het slice nummer en de partitieletter aan te geven. Voorbeelden staan in <<basics-disk-slice-part>>.

In <<basics-concept-disk-model>> staat een conceptmodel van een schijflayout die een en ander verduidelijkt.

Voordat FreeBSD geïnstalleerd kan worden moeten eerst de schijfslices gemaakt worden en daarna moeten de partities op de slices voor FreeBSD gemaakt worden. Daarna wordt op elke partitie het bestandssysteem (of wisselbestand) gemaakt en als laatste wordt besloten waar het filesysteem gekoppeld wordt.
[[basics-dev-codes]]
.Schijf apparaatcodes
[cols="1,1", frame="none", options="header"]
|===
| Code
| Betekenis

|[.filename]#ad#
|ATAPI (IDE) schijf

|[.filename]#da#
|SCSI directe toegang schijf

|[.filename]#acd#
|ATAPI (IDE) CDROM

|[.filename]#cd#
|SCSI CDROM

|[.filename]#fd#
|Floppydisk
|===

[[basics-disk-slice-part]]
.Voorbeeld schijf-, slice- en partitienamen
[example]
====
[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Name
| Betekenis

|`ad0s1a`
|De eerste partitie (`a`) op de eerste slice (`s1`) op de eerste IDE schijf (`ad0`).

|`da1s2e`
|De vijfde partitie (`e`) op de tweede slice (`s1`) op de tweede SCSI schijf (`da1`).
|===
====

[[basics-concept-disk-model]]
.Conceptmodel van een schijf
[example]
====
Het onderstaande diagram geeft aan hoe FreeBSD de eerste IDE schijf in het systeem ziet. Stel dat de schijf 4 GB groot is en dat deze twee 2 GB slices (MS-DOS(R) partities) bevat. De eerste slice bevat een MS-DOS(R) schijf, [.filename]#C:# en de tweede slice bevat een FreeBSD installatie. Deze FreeBSD installatie heeft drie partities en een partitie met een wisselbestand.

De drie partities hebben elk een bestandssysteem. Partitie `a` wordt gebruikt voor het root bestandssysteem, `e` voor de map [.filename]#/var# en `f` voor de map [.filename]#/usr#.

image::disk-layout.png[]

====

[[mount-unmount]]
== Het koppelen en ontkoppelen van bestandssystemen

Het bestandssysteem wordt het best weergegeven als een boom, met de stam als [.filename]#/#. [.filename]#/dev#, [.filename]#/usr# en de andere map in root zijn takken die weer hun eigen takken kunnen hebben, zoals [.filename]#/usr/local#, etc.

Er zijn verschillende redenen om sommige van deze mappen op aparte bestandssystemen te plaatsen. [.filename]#/var# bevat de mappen [.filename]#log/#, [.filename]#spool/# en verschillende types tijdelijke bestanden en kan volraken. Het laten vollopen van het root bestandssysteem is geen goed idee, dus het splitsen van [.filename]#/var# van [.filename]#/# is vaak de favoriet.

Een andere vaak voorkomende reden om bepaalde mapbomen op aparte bestandssystemen te plaatsen, is om ze op verschillende fysieke schrijven te zetten of gescheiden virtuele schijven zoals gemounte crossref:network-servers[network-nfs,Netwerk bestandssystemen] of cd-rom drives.

[[disks-fstab]]
=== Het bestand [.filename]#fstab#

Tijdens het crossref:boot[boot,opstartproces], worden bestandssystemen die vermeld staan in [.filename]#/etc/fstab# automatisch gekoppeld (tenzij ze vermeld staan met `noauto`).

[.filename]#/etc/fstab# bevat een lijst van regels die aan het volgende formaat voldoen:

[.programlisting]
....
apparaat        /koppelpunt fstype     opties      dumpfreq     passno
....

`apparaat`::
Een apparaatnaam (die moet bestaan) zoals uitgelegd in crossref:disks[disks-naming,Apparaatnamen].

`koppelpunt`::
Een map (die moet bestaan) waarop het bestandssysteem gekoppeld moet worden.

`fstype`::
Het bestandssysteem type dat aan man:mount[8] gegeven wordt. Het standaard FreeBSD bestandssysteem is `ufs`.

`opties`::
Dit is of `rw` voor lezen en schrijven bestandssytemen, of `ro` voor alleen lezen, gevolgd door elke andere optie die mogelijk nodig is. Een standaard optie is `noauto` voor bestandssystemen die niet automatisch gekoppeld worden tijdens het opstarten. Andere opties staan in man:mount[8].

`dumpfreq`::
Dit wordt gebruikt door man:dump[8] om te bepalen welke bestandssystemen gedumpt moeten worden. Als het veld niet is ingevuld, wordt aangenomen dat er een nul staat.

`passno`::
Dit bepaalt in welke volgorde bestandssystemen gecontroleerd moeten worden. Bestandssystemen die overgeslagen moeten worden moeten hun `passno` waarde op nul hebben staan. Voor het root bestandssysteem (dat voor alle andere gecontroleerd moet worden) moet `passno` op één staan en `passno` waarden voor andere bestandssystemen moeten een waarde hebben groter dan één. Als bestandssysteem dezelfde `passno` waarde hebben probeert man:fsck[8] deze bestandssystemen tegelijkertijd te controleren.

In man:fstab[5] staat meer informatie over de opmaak van [.filename]#/etc/fstab# en de mogelijke opties.

[[disks-mount]]
=== Het commando `mount`

man:mount[8] wordt gebruikt om bestandsystemen te koppelen.

De meest eenvoudige vorm is:

[source,bash]
....
# mount apparaat koppelpunt
....

Alle opties voor het commando staat in man:mount[8], maar de meest voorkomende zijn:

.Mountopties
`-a`::
Mount alle bestandssystemen die in [.filename]#/etc/fstab# staan, behalve die gemarkeerd staan als "noauto", uitgesloten zijn door de optie `-t` of die al gekoppeld zijn.

`-d`::
Doe alles behalve het echt aanroepen van de systeemopdracht `mount`. Deze optie is handig in samen met de optie `-v` om te bepalen wat man:mount[8] eigenlijk probeert te doen.

`-f`::
Forceert het koppelen van een niet schoon bestandssysteem (gevaarlijk) of forceert het innemen van schrijftoegang als de koppelstatus van een bestandssysteem wijzigt van lezen en schrijven naar alleen lezen.

`-r`::
Mount het bestandssysteem alleen lezen. Dit is identiek aan de optie `ro` voor de optie `-o`.

`-t` _fstype_::
Mount het opgegeven bestandssysteem als het opgegeven type bestandssysteem of koppelt alleen bestandssystemen van het aangegeven type als ook de optie `-a` is opgegeven.
+
"ufs" is het standaard bestandssysteem.

`-u`::
Werk koppel opties van het bestandssysteem bij.

`-v`::
Geef uitgebreide informatie (verbose).

`-w`::
Mount het bestandssysteem lezen en schrijven.

De optie `-o` accepteert een door komma's gescheiden lijst van opties, waaronder de volgende:

noexec::
Sta geen uitvoerbare bestanden toe op dit bestandssysteem. Ook dit is een nuttige veiligheidsoptie.

nosuid::
Interpreteer geen setuid of setgid opties op het bestandssysteem. Ook dit is een nuttige veiligheidsoptie.

[[disks-umount]]
=== Het commando `umount`

man:umount[8] heeft een koppelpunt, een apparaatnaam, `-a` of `-A` als parameter.

Alle vormen kunnen de optie `-f` hebben om een bestandsysteem te forceren te ontkoppelen en de optie `-v` voor uitgebreide informatie. De optie `-f` is meestal geen goed idee. Forceren dat een bestandssysteem ontkoppeld wordt kan de computer laten crashen of data op het bestandssysteem beschadigen.

De opties `-a` en `-A` worden gebruikt om alle bestandssystemen te unmounten, mogelijk nader gespecificeerd door de optie `-t` met daarachter op welke typen bestandssystemen het betrekking heeft. Voor de optie `-A` geldt dat deze niet probeert het root bestandssysteem te ontkoppelen.

[[basics-processes]]
== Processen

FreeBSD is een multi-tasking besturingssysteem. Dit betekent dat het lijkt alsof er meer dan één proces tegelijkertijd draait. Elk programma dat draait wordt een _proces_ genoemd. Elk commando dat wordt uitgevoerd start op zijn minst één nieuw proces en er zijn systeemprocessen die continu draaien om het systeem functioneel te houden.

Elk proces wordt geïdentificeerd door een nummer dat _process ID_ of _PID_ heet, en net zoals bij bestanden heeft elk proces één eigenaar en groep. De eigenaars- en groepsinformatie wordt gebruikt om te bepalen welke bestanden en apparaten het proces mag openen, waarbij gebruik wordt gemaakt van de bestandsrechten die eerder zijn behandeld. Veel processen hebben ook een ouderproces (parent process). Een ouderproces is een proces dat het nieuwe proces heeft gestart. Als commando's in een shell worden ingevoerd, start de shell een proces en elk commando dat draait is ook een proces. De uitzondering hierop is het speciale proces man:init[8]. `init` is altijd het eerste proces, dus het PID is altijd 1. `init` wordt automatisch gestart door de kernel als FreeBSD opstart.

Twee commando's die erg handig zijn om te zien welke processen er draaien zijn man:ps[1] en man:top[1]. `ps` wordt gebruikt om een statische lijst op te vragen van de processen die op het moment van uitvoeren draaien en kan hun PID, geheugengebruik, de startende commandoregel, enzovoort, tonen. `top` geeft alle draaiende processen weer en werkt de status elke paar seconden bij zodat interactief wordt weergegeven wat een computer aan het doen is.

Standaard laat `ps` alleen zien welke commando's draaien waarvan de gebruiker die het uitvoert de eigenaar is:

[source,bash]
....
% ps
  PID  TT  STAT      TIME COMMAND
  298  p0  Ss     0:01.10 tcsh
 7078  p0  S      2:40.88 xemacs mdoc.xsl (xemacs-21.1.14)
37393  p0  I      0:03.11 xemacs freebsd.dsl (xemacs-21.1.14)
48630  p0  S      2:50.89 /usr/local/lib/netscape-linux/navigator-linux-4.77.bi
48730  p0  IW     0:00.00 (dns helper) (navigator-linux-)
72210  p0  R+     0:00.00 ps
  390  p1  Is     0:01.14 tcsh
 7059  p2  Is+    1:36.18 /usr/local/bin/mutt -y
 6688  p3  IWs    0:00.00 tcsh
10735  p4  IWs    0:00.00 tcsh
20256  p5  IWs    0:00.00 tcsh
  262  v0  IWs    0:00.00 -tcsh (tcsh)
  270  v0  IW+    0:00.00 /bin/sh /usr/X11R6/bin/startx -- -bpp 16
  280  v0  IW+    0:00.00 xinit /home/nik/.xinitrc -- -bpp 16
  284  v0  IW     0:00.00 /bin/sh /home/nik/.xinitrc
  285  v0  S      0:38.45 /usr/X11R6/bin/sawfish
....

In het bovenstaande voorbeeld is de uitvoer van man:ps[1] georganiseerd in een aantal kolommen. `PID` is het proces ID. PIDs worden toegekend vanaf 1 en lopen op tot 99999. Als ze allemaal zijn gebruikt, worden ze hergebruikt. (een PID wordt niet hergebruikt als deze reeds in gebruik is). De `TT` kolom toont de tty vanwaar het programma draait en wordt nu buiten beschouwing gelaten. `STAT` toont de huidige staat van het programma en ook deze kolom wordt buiten beschouwing gelaten. `TIME` is de hoeveelheid tijd die het programma gedraaid heeft op de CPU. Dit is meestal niet de verstreken tijd vanaf het moment dat het programma is gestart. Veel programma's wachten omdat er alleen gebruik wordt gemaakt van de CPU als er iets voor het programma te doen is. Als laatste is `COMMAND` de commandoregel die gebruikt is om het programma te starten.

man:ps[1] ondersteunt een aantal opties die de informatie wijzigen die wordt weergegeven. Één van de meest nuttige combinaties is `auxww`. De optie `a` toont informatie over alle draaiende processen, niet alleen die van de gebruiker die is aangemeld. De optie `u` toont de gebruikersnaam van de proceseigenaar, evenals geheugengebruik. De optie `x` toont informatie over daemonprocessen en met de optie `ww` laat man:ps[1] de volledige commandoregel zien voor elk proces, in plaats van een mogelijk afgekorte regel omdat die te lang is om op het scherm te passsen.

De uitvoer van man:top[1] is hetzelfde:

[source,bash]
....
% top
last pid: 72257;  load averages:  0.13,  0.09,  0.03    up 0+13:38:33  22:39:10
47 processes:  1 running, 46 sleeping
CPU states: 12.6% user,  0.0% nice,  7.8% system,  0.0% interrupt, 79.7% idle
Mem: 36M Active, 5256K Inact, 13M Wired, 6312K Cache, 15M Buf, 408K Free
Swap: 256M Total, 38M Used, 217M Free, 15% Inuse

  PID USERNAME PRI NICE  SIZE    RES STATE    TIME   WCPU    CPU COMMAND
72257 nik	28   0  1960K  1044K RUN      0:00 14.86%  1.42% top
 7078 nik	2   0 15280K 10960K select   2:54  0.88%  0.88% xemacs-21.1.14
  281 nik	2   0 18636K  7112K select   5:36  0.73%  0.73% XF86_SVGA
  296 nik	2   0  3240K  1644K select   0:12  0.05%  0.05% xterm
48630 nik	2   0 29816K  9148K select   3:18  0.00%  0.00% navigator-linu
  175 root	2   0   924K   252K select   1:41  0.00%  0.00% syslogd
 7059 nik	2   0  7260K  4644K poll     1:38  0.00%  0.00% mutt
...
....

De uitvoer is gesplitst in twee secties. De kop (de eerste vijf regels) toont het laatst uitgegeven PID, de gemiddelde systeembelasting (hoe druk is een systeem), de uptime van het systeem (tijd verstreken sinds laatste reboot) en de huidige tijd. De andere cijfers in de kop tonen hoeveel processen er draaien (in dit geval 47) , hoeveel geheugen en swap er gebruikt wordt en hoeveel processortijd het systeem besteed aan verschillende taakgroepen.

Daaronder staat een serie van kolommen die soortgelijke informatie bevatten als de uitvoer van man:ps[1]. Zo zijn het PID, de gebruikersnaam, de hoeveelheid processortijd en het commando dat gebruikt is om het proces te starten te zien. man:top[1] laat standaard ook zien hoeveel geheugen er gebruikt wordt door een proces. Dit staat in twee kolommen waarbij in de eerste kolom het maximale geheugengebruik wordt getoond en in de tweede kolom het huidige geheugengebruik. Maximale gebruik is de hoeveelheid geheugen die het proces nodig had in de tijd dat het bestaat en het residente gebruik is hoeveel er op het moment van weergeven gebruikt wordt. In dit voorbeeld is zichtbaar dat man:getenv[3] bijna 30 MB RAM nodig had, maar op het moment van uitvoeren 9 MB verbruikt.

man:top[1] werkt het beeld automatisch iedere twee seconden bij. Dat kan gewijzigd worden met de optie `s`.

[[basics-daemons]]
== Daemons, signalen en het stoppen van processen

Als een gebruiker een editor draait is het makkelijk om de editor te besturen, te vertellen om bestanden te openen, etc. Dit kan omdat de editor de mogelijkheden geeft om dat te doen en omdat de editor gekoppeld is aan een _terminal_. Sommige programma's zijn niet ontworpen om te draaien met continue gebruikersinvoer, dus als zij de kans krijgen ontkoppelen zij zich van de terminal. Een webserver reageert bijvoorbeeld de hele dag op webaanvragen en heeft eigenlijk geen input van een lokale gebruiker nodig. Programma's die email van locatie naar locatie transporteren zijn een ander voorbeeld.

Deze programma's heten _daemons_. Daemons waren karakters in de Griekste mythologie, goed noch slecht, ze waren dienende geesten die op grote schaal nuttige dingen deden voor de mensheid. Net zoals de huidige webservers en mailservers nuttige dingen doen. Dit is waarom de mascotte voor BSD al lang een vrolijk kijkende daemon met puntoren en een drietand is.

Er is een overeenkomst om programma's die meestal draaien als daemon te voorzien van het achtervoegsel "d". BIND is de Berkeley Internet Name Domain (het echte programma heet `named`), de Apache webserver heet `httpd`, de printerspooldriver heet `lpd`, etc. Deze overeenkomst geldt niet altijd. De hoofd maildaemon voor Sendmail heet bijvoorbeeld `sendmail` en niet `maild`.

Soms is communicatie met een daemon nodig. Een manier om dit te doen is het versturen van een signaal (_signals_). Er zijn een verschillende signalen. Sommige hebben een specifieke bedoeling, andere worden geïntrepeteerd door de applicatie. In de documentatie van de applicatie staat hoe de applicatie signalen intrepeteert. Er kan alleen een signaal naar een proces gezonden worden waar de uitvoerende gebruiker eigenaar van is. Als met man:kill[1] of man:kill[2] een signaal naar een proces van een andere gebruiker wordt gestuurd, wordt de toegang geweigerd. De enige uitzondering hierop is de `root` gebruiker, die signalen naar processen van alle gebruikers kan sturen.

FreeBSD stuurt soms ook signalen naar applicaties. Als een applicatie slecht geschreven is en hij probeert geheugen te benaderen waar hij niet naartoe mag, stuurt FreeBSD het proces een _Segmentation Violation_ signaal (`SIGSEGV`). Als een applicatie de systeemaanroep man:alarm[3] heeft gebruikt om na een bepaalde periode een alarm te ontvangen, wordt er een Alarm signaal heen gestuurd (`SIGALRM`), etc.

Twee signalen kunnen gebruikt worden om een proces te stoppen: `SIGTERM` en `SIGKILL`. `SIGTERM` is de nette manier om een proces te killen. Het proces kan het signaal _afvangen_, begrijpen dat de eigenaar wil dat het wordt afgesloten, wellicht logboekbestanden sluiten die geopend zijn en alle onderhanden activiteiten afhandelen. In een aantal gevallen kan een proces `SIGTERM` negeren: als het midden in een taak zit die niet beëindigd kan worden.

`SIGKILL` mag niet worden genegeerd door een proces. Dit is het "Wat je ook aan het doen bent, stop er nu mee" signaal. Na een `SIGKILL` stopt FreeBSD het proces meteen. 

Andere veelgebruikte signalen zijn `SIGHUP`, `SIGUSR1` en `SIGUSR2`. Dit zijn algemeen bruikbare signalen en verschillende applicaties zullen verschillend reageren als ze verstuurd worden.

Stel dat het bestand met instellingen voor de webserver is aangepast. Dan moet aan de webserver verteld worden dat die de instellingen opnieuw moet lezen. Hiervoor zou `httpd` gestopt en gestart kunnen worden, maar dit resulteert in een korte onderbreking van de webserverdienst, wat ongewenst kan zijn. De meeste daemons zijn geschreven om te reageren op het `SIGHUP` signaal door het opnieuw inlezen van het instellingenbestand. Dus in plaats van het stoppen en herstarten van `httpd` kan het `SIGHUP` signaal gezonden worden. Omdat er geen standaard manier is om op deze signalen te reageren, reageren verschillende daemons anders. Het is verstandig eerst de documentatie van de daemon in kwestie te lezen.

Zoals onderstaand voorbeeld laat zien, worden signalen door man:kill[1] verzonden.

[.procedure]
====
*Procedure: Het versturen van een signaal naar een proces*

Dit voorbeeld toont hoe een signaal naar man:inetd[8] wordt verstuurd. Het bestand met instellingen voor `inetd` is [.filename]#/etc/inetd.conf# en `inetd` leest dit bestand opnieuw in als er een `SIGHUP` wordt verstuurd.

. Eerst moet het proces ID worden opgezocht van het proces waar een signaal naar verzonden moeten worden. Dit kan door man:pgrep[1] te gebruiken.
+
[source,bash]
....
% pgrep -l inetd
198  inetd -wW
....
+ 
Dus het PID van man:inetd[8] is 198.
. Met man:kill[1] kan het signaal verzonden worden. Omdat man:inetd[8] wordt gedraaid door `root` moet man:su[1] gebruikt worden om `root` te worden.
+
[source,bash]
....
% su
Password:
# /bin/kill -s HUP 198
....
+ 
Zoals zovaak met UNIX(R) commando's, geeft man:kill[1] geen uitvoer als het succesvol uitgevoerd is. Als een signaal wordt verzonden naar een proces waarvan de gebruiker niet zelf de eigenaar is, dan is de melding: `kill: _PID_: Operation not permitted`. Als het PID verkeerd wordt ingevuld, wordt het signaal naar het verkeerde proces verzonden, wat slecht kan zijn, of, als de gebruiker geluk heeft, wordt het verzonden naar een PID dat momenteel niet in gebruik is, waarop de foutmelding `kill: _PID_: No such process` verschijnt.
+
[NOTE]
.Waarom `/bin/kill` gebruiken?
======
Veel shells leveren `kill` als ingebouwd commando. Dat betekent dat de shell het signaal direct verstuurt in plaats van door het starten van [.filename]#/bin/kill#. Dit kan erg nuttig zijn, maar verschillende shells hebben een verschillende opdrachtregel voor het specificeren van de naam van het signaal dat verstuurd moet worden. In plaats van ze allemaal te leren, is het eenvoudiger om gewoon `/bin/kill PID` te gebruiken.
======
====

Andere signalen versturen werkt bijna hetzelfde door `TERM` of `KILL` op de commandoregel te vervangen door wat nodig is.

[IMPORTANT]
====
Het stoppen van willekeurige processen op een systeem is meestal een slecht idee. In het bijzonder bij man:init[8] met proces ID 1. Het draaien van `/bin/kill -s KILL 1` is een snelle manier om een systeem uit te zetten. Argumenten die aan man:kill[1] worden meegegeven moeten _altijd_ twee keer gecontroleerd worden _voordat_ op kbd:[Enter] gedrukt wordt.
====

[[shells]]
== Shells

In FreeBSD wordt een groot deel van het alledaagse werk gedaan vanuit een omgeving met een commandoregel die shell heet. De grootste taak van een shell is om commando's van het invoerkanaal op te vangen en deze uit te voeren. Veel shells hebben ook functies ingebouwd om mee te helpen om alledaagse taken zoals bestandsbeheer, bestandsglobbing, bestanden wijzigen vanaf de commandoregel, commandomacro's schrijven en uitvoeren en omgevingsvariabelen instellen en wijzigen. FreeBSD heeft een aantal shells bijgeleverd zoals `sh`, de Bourne Shell en `tcsh`, de verbeterde C-shell. Er zijn veel andere shells beschikbaar in de FreeBSD Portscollectie zoals `zsh` en `bash`.

Welke shell gebruiken? Dit is een kwestie van smaak. Een C-programmeur voelt zich misschien prettiger bij een C-achtige shell, zoals `tcsh`. Een voormalig Linux(R) gebruiker of iemand die niet veel ervaring heeft met een UNIX(R) commandoregel interface wil misschien `bash` proberen. Elke shell heeft zijn eigen unieke eigenschappen die wel of niet werken voor een bepaalde gebruiker.

Een standaard optie in een shell is bestandsnaam completie. Door het intikken van de eerste paar letters van een commando of bestandsnaam, kan de shell opdracht gegeven worden om automatisch de rest het commando of bestandsnaam toe te voegen met de kbd:[Tab] toets op het toetsenbord. Stel dat er twee bestanden zijn met de namen [.filename]#foobar# en [.filename]#foo.bar# en [.filename]#foo.bar# moet verwijderd worden. Dan kan op het toetsenbord `rm fo[Tab].[Tab]` ingevoerd worden.

De shell geeft `rm foo[BEEP].bar` weer.

De [BEEP] geeft aan dat de shell in staat was om de bestandsnaam te completeren omdat er meer dan één soortgelijk bestand was. [.filename]#foobar# en [.filename]#foo.bar# beginnen met `fo`, maar het was in staat om het af te maken tot `foo`. Na het invoeren van een `.` en daarna kbd:[Tab], is de shell in staat om de rest van de bestandsnaam aan te vullen.

Een andere optie van de shell is het gebruik van omgevingsvariabelen. Omgevingsvariabelen zijn variabele sleutelparen die opgeslagen zijn in de omgevingsruimte van een shell. Deze ruimte kan uitgelezen worden door elk programma dat door de shell wordt uitgevoerd en bevat dus veel programmainstellingen. Hieronder staat een lijst van standaard omgevingsvariabelen en wat ze betekenen:

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Variabele
| Omschrijving

|`USER`
|Gebruikersnaam van de gebruiker die is aangemeld.

|`PATH`
|Een lijst van mappen, gescheiden door een `:` voor het zoeken naar binaire bestanden.

|`DISPLAY`
|Netwerknaam van het X11 scherm om verbinding mee te maken, indien beschikbaar.

|`SHELL`
|De huidige shell.

|`TERM`
|De naam van de huidige gebruikersterminal. Gebruikt om de mogelijkheden van de terminal te bepalen.

|`TERMCAP`
|Databaseregel met terminal escape codes voor het uitvoeren van diverse terminalfuncties.

|`OSTYPE`
|Type besturingssysteem, bijvoorbeeld FreeBSD.

|`MACHTYPE`
|De CPU architectuur waar het systeem op draait.

|`EDITOR`
|De teksteditor waar de gebruiker de voorkeur aan geeft.

|`PAGER`
|De tekstpager waar de gebruiker de voorkeur aan geeft.

|`MANPATH`
|Lijst van mappen gescheiden door een `:` voor het zoeken naar handleidingen.
|===

Het instellen van omgevingsvariabelen verschilt van shell tot shell. In de C-achtige shells zoals `tcsh` en `csh` moet `setenv` gebruikt worden om omgevingsvariabelen in te stellen. In Bourne-shells zoals `sh` en `bash` moet `export` gebruikt worden om de omgevingsvariabelen in te stellen. Om bijvoorbeeld de omgevingsvariabele `EDITOR` te wijzigen naar [.filename]#/usr/local/bin/emacs# onder `csh` of `tcsh` moet het volgende gedaan worden:

[source,bash]
....
% setenv EDITOR /usr/local/bin/emacs
....

In Bourne shells is dat:

[source,bash]
....
% export EDITOR="/usr/local/bin/emacs"
....

Met de meeste shells kunnen de omgevingsvariabelen ook weergegeven worden door een `$` karakter voor de variabelenaam te plaatsen op de commandoregel. `echo $TERM` zou weergeven wat er in `$TERM` gezet is, omdat de shell `$TERM` uitbreid en het resultaat doorgeeft aan `echo`.

Shells kennen veel speciale karakters, die meta-karakters heten, als speciale weergaves van data. De meest voorkomende is het karakter `*` karakter, dat elk karakter in een bestandsnaam voorstelt. Deze speciale meta-karakters kunnen gebruikt worden om bestandsnaamglobbing te doen. Door bijvoorbeeld `echo *` in te voeren, is het resultaat bijna hetzelfde als door het uitvoeren van `ls`, omdat de shell alle bestanden die van toepassing zijn aan echo geeft om ze daarna te tonen.

Om te voorkomen dat de shell deze speciale tekens verwerkt, kunnen ze uitgeschakeld worden door er het backslash karakter (`\`) voor te plaatsen. `echo $TERM` print de inhoud van TERM naar het scherm. `echo \$TERM` print $TERM zoals het geschreven is.

[[changing-shells]]
=== Shell wijzigen

De makkelijkste manier om de shell te wijzigen is door het `chsh` commando te gebruiken. Door `chsh` te starten wordt de editor gestart die in de `EDITOR` omgevingsvariable staat. Als deze niet is ingesteld, wordt vi gestart. In de editor kan de regel waarop "Shell:" staat gewijzigd worden.

Aan `chsh` kan ook de optie `-s` meegegeven worden. Dit stelt de shell in, zonder dat een editor gebruikt hoeft te worden. Als de shell bijvoorbeeld gewijzigd moet worden in `bash`, kan dat als volgt:

[source,bash]
....
% chsh -s /usr/local/bin/bash
....

[NOTE]
====
De te gebruiken shell _moet_ geregistreerd zijn in [.filename]#/etc/shells#. Als een shell uit de crossref:ports[ports,Portscollectie] is geïnstalleerd, is dit meestal automatisch gebeurd. Als de shell met de hand is geïnstalleerd moet het onderstaande gedaan worden.

Als bijvoorbeeld `bash` met de hand geïnstalleerd is in [.filename]#/usr/local/bin#, dient het onderstaande te gebeuren:

[source,bash]
....
# echo "/usr/local/bin/bash" >> /etc/shells
....

Hierna kan `chsh` weer gedraaid worden.
====

[[editors]]
== Teksteditors

Een groot deel van de instellingen in FreeBSD wordt gemaakt door het bewerken van tekstbestanden. Hierdoor is het een goed idee om bekend te zijn met een tekstverwerker. FreeBSD heeft er een paar in het basissysteem en veel anderen zijn beschikbaar via de Portscollectie.

De makkelijkste en simpelste editor om te leren is de editor ee, wat "easy editor" betekent. Om ee te starten, moet op de commandoregel `ee bestandsnaam` ingevoerd worden, waar _bestandsnaam_ de naam is van het bestand dat bewerkt moet worden. Om bijvoorbeeld [.filename]#/etc/rc.conf# te bewerken, wordt `ee /etc/rc.conf` ingegeven. Eenmaal in `ee` worden alle manipulatie commando's die de editor heeft weergegeven aan de bovenkant van het scherm. Het karakter dakje `^` staat voor de toets kbd:[CTRL] op het toetsenbord, dus `^e` vormt de toetscombinatie kbd:[Ctrl+e]. Om uit ee te komen wordt op de toets kbd:[Esc] gedrukt en daar kan gekozen worden om de editor te verlaten. De editor vraagt dan of de wijzigingen bewaard moeten worden als het bestand veranderd is.

FreeBSD heeft ook uitgebreidere tekstverwerkers, zoals vi, in het basissysteem en andere editors als Emacs en vim maken onderdeel uit van de FreeBSD Portscollectie (package:editors/emacs[] en package:editors/vim[]). Deze editors leveren veel meer functionaliteit en kracht maar zijn lastiger om te leren. Als echter veel met tekstverwerking gedaan wordt, is het leren van een krachtige editor als vim of Emacs verstandig omdat deze uiteindelijk veel tijd kan besparen.

Veel applicaties die bestanden wijzigen of getypte invoer nodig hebben zullen automatisch een tekstverwerker openen. Om de tekstverwerker te wijzigen die standaard wordt gebruikt, stelt u de omgevingsvariabele `EDITOR` in. Zie de sectie <<shells,shells>> voor meer details.

[[basics-devices]]
== Apparaten en apparaatnodes

Apparaat is een term die meestal wordt gebruikt voor hardwareonderdelen in een systeem, zoals schijven, printers grafische kaarten en toetsenborden. Als FreeBSD opstart laat het vooral zien welke apparaten gedetecteerd worden. Deze opstartmeldingen kunnen nagekeken worden door het bestand [.filename]#/var/run/dmesg.boot# te bekijken.

[.filename]#acd0# is bijvoorbeeld de eerste IDE cd-rom drive, terwijl [.filename]#kbd0# staat voor het toetsenbord.

Veel van deze apparaten moeten in een UNIX(R) besturingssysteem benaderd worden via speciale bestanden die apparaatnodes heten en te vinden zijn in de map [.filename]#/dev#.

=== Apparaatnodes maken

Als een nieuw apparaat wordt toegevoegd aan een systeem of als ondersteuning voor extra apparaten wordt gecompileerd, dan moeten er misschien nieuwe apparaat nodes aangemaakt worden.

==== `DEVFS` (apparaatbestandssysteem - DEVice File System)

Het apparaatbestandssysteem of `DEVFS`, levert toegang tot de apparaatruimte van de kernel in het globale bestandssysteem. In plaats van dat het nodig is om apparaatnodes te maken en te wijzigen, doet `DEVFS` dit.

In man:devfs[5] staat meer informatie.

[[binary-formats]]
== Binaire formaten

Om te kunnen begrijpen waarom FreeBSD gebruik maakt van het man:elf[5] formaat, is het belangrijk op de hoogte zijn van de drie "dominante" uitvoerbare formaten voor UNIX(R):

* man:a.out[5]
+ 
Het oudste en "klassieke" UNIX(R) object formaat. Het gebruikt een korte en compacte kop met een magisch nummer aan het begin dat veel gebruikt wordt om het formaat aan te geven (man:a.out[5] geeft meer details). Het bevat drie laadbare segmenten: .tekst, .data en .bss, een symbolentabel en een stringtabel.
* COFF
+ 
Het SVR3 object formaat. De kop bestaat uit een sectietabel, dus er kunnen meer dan alleen .tekst, .data, en .bss secties zijn.
* man:elf[5]
+ 
De opvolger van COFF, heeft meerdere secties en 32-bit of 64-bit als mogelijke waarden. Één nadeel: ELF was ook ontworpen met de aanname dat er maar één ABI per systeemarchitectuur zou zijn. Deze aanname is eigenlijk redelijk incorrect, zelfs niet in de commerciële SYSV wereld (die op zijn minst drie ABIs heeft: SRV4, Solaris en SCO).
+ 
FreeBSD probeert om dit probleem heen te werken door een hulpprogramma te leveren voor het _brandmerken_ van een bekend ELF uitvoerbaar bestand met informatie over de ABI waar hij mee kan werken. In man:brandelf[1] staat meer informatie.

FreeBSD komt uit het "klassieke" kamp en gebruikt het man:a.out[5] formaat, een technologie die zich bewezen heeft door meerdere generaties van BSD versies heen, tot het begin van de 3.X versies. Alhoewel het al mogelijk was om ELF programma's en kernels te bouwen en te draaien op een FreeBSD systeem , verzette FreeBSD zich eerst tegen de druk om over te schakelen naar ELF als standaard formaat. Waarom? Toen het Linux(R) kamp hun pijnlijke wissel maakte naar ELF, was dat niet zozeer om van het [.filename]#a.out# formaat af te komen, maar meer omdat van het op de inflexibele jump-tabel gebaseerde gedeelde bibliotheekmechanisme af te komen, die het maken van gedeelde bibliotheken erg moeilijk maakte voor bedrijven en ontwikkelaars. Omdat de ELF hulprogramma's een oplossing voor het gedeelde bibliotheek probleem waren en algemeen gezien werden als een "stap vooruit", werd de migratie geaccepteerd als noodzakelijk kwaad en werd de wissel uitgevoerd. Het gedeelde bibliotheek mechanisme van FreeBSD is meer gebaseerd op het gedeelde bibliotheek mechanisme van Sun's SunOS(TM) en daardoor erg makkelijk te gebruiken.

Waarom zijn er zoveel verschillende formaten?

In het duistere donkere verleden was er simpele hardware. Deze simpele hardware ondersteunde een simpel klein systeem. [.filename]#a.out# was volledig adequaat voor de taak om binaire bestanden op dat simpele systeem te vertegenwoordigen (een PDP-11). Toen mensen UNIX(R) van deze machine gingen porten, behielden ze het [.filename]#a.out# formaat omdat het voldeed voor de vroege ports van UNIX(R) naar architecturen als Motorola 68k, VAXen, enzovoort.

Toen besloot een slimme hardware engineer dat als hij de software kon forceren om wat simpele truckjes te doen, hij in staat was om een paar onderdelen van het ontwerp af te schaven, waardoor zijn processorcore sneller kon draaien. Terwijl men probeerde om het met deze nieuwe vorm van hardware te laten werken (vandaag de dag beter bekend als RISC), was [.filename]#a.out# te beperkt voor deze hardware. Dus werden er vele formaten ontworpen om betere prestaties te krijgen uit deze hardware dan het simpele formaat [.filename]#a.out# kon leveren. Toen werden COFF, ECOFF en een paar andere duistere formaten uitgevonden en werden de limieten verkend, waarna men besloot om zich te richten op ELF.

Daarnaast werden programma's groter en bleven schijven (en fysiek geheugen) relatief klein, zodat het concept van een gedeelde bibliotheek werd geboren. Het VM systeem werd ook meer verfijnd. Terwijl al deze verbeteringen bereikt werden door het [.filename]#a.out# formaat, werd het nut met elke nieuwe eigenschap verder uitgerekt. Daarnaast wilde men dingen dynamisch laden tijdens het starten of delen weggooien nadat het programma zijn intiële code had gedraaid om te blijven hangen in het hoofdgeheugen en in de wisselbestanden. Talen werden verder verfijnd en men wilde dat code automatisch werd aangeroepen voor main. Er werden veel hacks gedaan in het [.filename]#a.out# formaat om alles mogelijk te maken en dit werkte ook enige tijd. Na verloop van tijd was [.filename]#a.out# niet meer in staat om alle problemen te adresseren zonder toenemende overhead in code en complexibiliteit. Hoewel ELF veel van deze problemem verhielp, was het moeilijk om te wisselen naar een systeem dat compleet anders werkte. Dus moest ELF wachten totdat het pijnlijker was om [.filename]#a.out# te behouden dan het te migreren naar ELF.

Met het verstrijken van de tijd, werden de bouwprogramma's die FreeBSD heeft afgeleid van hun bouwprogramma's (vooral de assembler en de loader) ontwikkeld in twee parallel lopende takken. De FreeBSD tree voegde gedeelde bibliotheken toe en heeft wat bugs opgelost. De mensen van GNU die deze programma's hebben geschreven, hebben ze herschreven en simpelere ondersteuning toegevoegd voor het bouwen van cross-compilers, waarbij verschillende formaten zo nodig ingevoegd konden worden, enzovoort. Omdat veel mensen cross-compilers wilden bouwen die gericht waren op FreeBSD, hadden die pech, omdat de oudere broncode van FreeBSD voor as en ld niet opgewassen was tegen deze taak. De nieuwe GNU programmaketen (binutils) ondersteunt cross-compiling, ELF, gedeelde bibliotheken, C++ extensies, enzovoort. Daarnaast leveren veel leverancierds ELF binaire bestanden en is het goed voor FreeBSD om het te draaien.

ELF heeft meer expressiemogelijkheden dan [.filename]#a.out# en geeft meer uitbreidingsmogelijkheden aan het basissysteem. De ELF hulpprogramma's worden beter onderhouden en geven de mogelijkheid tot ondersteuning voor cross compilatie, wat voor veel mensen belangrijk is. ELF is misschien iets trager dan [.filename]#a.out#, maar het meten daarvan kan vrij lastig zijn. Er zijn ook ontelbare verschillen tussen de twee in hoe ze pages opslaan, initiële code verwerken, enzovoort. Geen van allen zijn ze erg belangrijk, maar er zijn verschillen. Na verloop van tijd verdwijnt de ondersteuning voor [.filename]#a.out# uit de [.filename]#GENERIC# kernel en uiteindelijk ook helemaal uit de kernel als de noodzaak voor [.filename]#a.out# gebaseerde programma's voorbij is.

[[basics-more-information]]
== Meer informatie

[[basics-man]]
=== Handleidingen

De meest uitvoerige documentatie van FreeBSD is geschreven in de vorm van handleidingen. Bijna elk programma op het systeem heeft een kleine handleiding die uitlegt wat de basisopties en verschillende argumenten doen. Deze handleidingen bekeken worden met `man`. Het gebruik van `man` gaat als volgt:

[source,bash]
....
% man commando
....

`commando` is de naam van het commando waar meer informatie over getoond moet worden. Om bijvoorbeeld meer informatie weer te geven over `ls` kan het volgende uitgevoerd worden:

[source,bash]
....
% man ls
....

De handleidingen zijn opgedeeld in genummerde onderdelen:

. Gebruikerscommando's.
. Systeemaanroepen en foutnummernummers.
. Functies in de C bibliotheken.
. Apparaatdrivers.
. Bestandsindelingen.
. Spelletjes en andere afleidingen.
. Diverse informatie.
. Systeemonderhoud en commando's
. Kernelontwikkelaars.

In sommige gevallen kan een bepaald onderwerp vaker voorkomen in een onderdeel van de handleidingen. Er is bijvoorbeeld een gebruikerscommando `chmod` en een systeemaanroep `chmod()`. In deze gevallen kan `man` aangegeven worden welke documentatie weer te geven door het specificeren van het onderdeel:

[source,bash]
....
% man 1 chmod
....

Dit geeft de handleiding van het gebruikerscommando `chmod` weer. Verwijzingen naar een bepaald onderdeel van de handleiding worden traditioneel tussen haakjes geplaatst: man:chmod[1] verwijst naar het commando `chmod` en man:chmod[2] verwijst naar de systeemaanroep.

Dit werkt prima als de naam van het commando bekend is en alleen informatie nodig is over hoe het commando gebruikt kan worden, maar wat als de naam van het commando niet bekend is? Dan kan `man` gebruikt worden om naar trefwoorden te zoeken in de commandobeschrijvingen door de optie `-k` te gebruiken:

[source,bash]
....
% man -k mail
....

Met dit commando wordt een overzicht getoond met commando's die het trefwoord "mail" in hun omschrijving hebben. Dit is gelijk aan het commando `apropos`.

Dus om meer informatie over spannende commando's met een onbekende functie in [.filename]#/usr/bin# te krijgen is het volgende commando voldoende:

[source,bash]
....
% cd /usr/bin
% man -f *
....

Het onderstaande commando resulteert in hetzelfde:

[source,bash]
....
% cd /usr/bin
% whatis *
....

[[basics-info]]
=== Gnu infobestanden

FreeBSD heeft veel applicaties en hulpmiddelen die gemaakt zijn door de Free Software Foundation (FSF). Als extraatje voor de documentatie hebben deze programma's uitgebreidere html bestanden die `info`bestanden heten, die uitgelezen kunnen worden met `info` of, als emacs is geïnstalleerd, de infomodus van emacs.

man:info[1] wordt als volgt gebruikt:

[source,bash]
....
% info
....

`h` geeft een korte beschrijving en `?` toont een kort commando-overzicht.
