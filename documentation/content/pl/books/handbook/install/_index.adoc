---
title: Rozdział 2. Instalacja FreeBSD
part: Część I. Pierwsze kroki
prev: books/handbook/introduction
next: books/handbook/basics
---

[[install]]
= Instalacja FreeBSD
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:source-highlighter: rouge
:experimental:
:skip-front-matter:
:toc-title: Spis treści
:table-caption: Tabela
:figure-caption: Rysunek
:example-caption: Przykład
:xrefstyle: basic
:relfileprefix: ../
:outfilesuffix:
:sectnumoffset: 2

ifeval::["{backend}" == "html5"]
:imagesdir: ../../../../images/books/handbook/install/
endif::[]

ifeval::["{backend}" == "pdf"]
:imagesdir: ../../../../static/images/books/handbook/install/
endif::[]

ifeval::["{backend}" == "epub3"]
:imagesdir: ../../../../static/images/books/handbook/install/
endif::[]

include::shared/authors.adoc[]
include::shared/releases.adoc[]
include::shared/pl/mailing-lists.adoc[]
include::shared/pl/urls.adoc[]
include::shared/pl/teams.adoc[]

toc::[]

[[install-synopsis]]
== Streszczenie

Wraz z FreeBSD rozpowszechniany jest prosty w użyciu program instalacyjny, działający w trybie tekstowym, o nazwie sysinstall. Jest on domyślnym programem instalacyjnym FreeBSD, jednakże dystrybutorzy systemu mogą zastąpić go własnym odpowiednikiem. W niniejszym rozdziale zawarto opis instalacji FreeBSD przy pomocy sysinstall.

Po przeczytaniu rozdziału będziemy wiedzieć:

* W jaki sposób tworzy się dyskietki instalacyjne FreeBSD.
* Jak FreeBSD odwołuje się do dysku i jak go dzieli.
* Jak uruchamia się sysinstall.
* Jakie pytania zadaje sysinstall, o co w nich chodzi i jak na nie odpowiedzieć.

Przed przeczytaniem rozdziału powinniśmy:

* Zapoznać się z listą obsługiwanego sprzętu dołączoną do instalowanej wersji FreeBSD, by upewnić się, że posiadany sprzęt będzie działać.

[NOTE]
====
Opis instalacji dotyczy generalnie komputerów opartych na architekturze i386(TM) ("zgodny z PC"). W stosownych przypadkach podawane będą informacje odnoszące się do innych platform (na przykład Alpha). Pomimo starań o utrzymanie niniejszego opisu aktualnym, możliwe jest zaistnienie drobnych różnic pomiędzy instalatorem a zawartością tego rozdziału. Zaleca się, aby traktować niniejszy teksty jako ogólny przewodnik, niż raczej dosłowny podręcznik instalacji.
====

[[install-pre]]
== Czynności wstępne

[[install-inventory]]
=== Rozpoznanie komponentów komputera

Przed instalacją FreeBSD powinniśmy zapoznać się z komponentami naszego komputera. W czasie instalacji FreeBSD pokaże listę urządzeń (dyski, karty sieciowe, napędy CD-ROM, itd.) wraz z informacjami o producentach i numerach modeli. FreeBSD postara się także ustalić prawidłową konfigurację każdego z nich, m.in. ustawienia przerwań IRQ i portów we/wy. Ze względu na "kaprysy" pecetowego sprzętu może się okazać, że konfiguracja wykryta przez FreeBSD nie jest w pełni prawidłowa i trzeba będzie samodzielnie ją poprawić.

Jeżeli na komputerze jest już zainstalowany inny system operacyjny, na przykład Windows(R) lub Linux, warto jest skorzystać z dostępnych w nim narzędzi do sprawdzenia bieżącej konfiguracji sprzętowej. Kiedy zupełnie nie wiadomo jak skonfigurowana powinna być dana karta, wymagane informacje mogą znajdować się bezpośrednio na niej samej. Często spotykane numery przerwań IRQ to 3, 5 i 7, a adresy portów we/wy są zwykle zapisywane w postaci liczb szesnastkowych, na przykład 0x330.

Zalecamy by zebrane informacje wydrukować lub zapisać na kartce przed rozpoczęciem instalacji FreeBSD. Można je zestawić w postaci tabeli, np.:

.Przykładowa lista urządzeń
[cols="1,1,1,1", frame="none", options="header"]
|===
| Nazwa urządzenia
| IRQ
| Port(y) we/wy
| Uwagi

|Pierwszy dysk twardy
|brak
|brak
|40 GB, firmy Seagate, IDE 1 master

|CDROM
|brak
|brak
|IDE 1 slave

|Drugi dysk twardy
|brak
|brak
|20 GB, firmy IBM, IDE 2 master

|Kontroler IDE
|14
|0x1f0
|

|Karta sieciowa
|brak
|brak
|Intel(R) 10/100

|Modem
|brak
|brak
|3Com(R) 56K faxmodem na COM1

|...
|===

=== Przygotowanie kopii danych

Jeśli komputer, na którym będzie przeprowadzana instalacja zawiera cenne dane, powinniśmy koniecznie przygotować ich kopię zapasową, oraz sprawdzić stan tychże kopii przed instalacją FreeBSD. Podczas instalacji kilkakrotnie pojawi się prośba o potwierdzenie przed zapisaniem czegokolwiek na dysku, jednak gdy już się to rozpocznie, nie będzie możliwości odwrotu.

[[install-where]]
=== Wybór miejsca dla FreeBSD

Jeżeli masz zamiar przeznaczyć cały dysk na FreeBSD, to omawiane poniżej zagadnienia nie będą cię dotyczyć - możesz pominąć tę część.

W przypadku, gdy zamierzamy zainstalować FreeBSD obok innych systemów operacyjnych, warto zapoznać się z podstawowymi informacjami o sposobie przechowywania danych na dysku.

[[install-where-i386]]
==== Układ dysku w systemach i386(TM)

Dysk komputera typu PC można podzielić na oddzielne porcje, zwane _partycjami_. Komputery PC potrafią obsłużyć maksymalnie cztery partycje na jednym dysku. Partycje te nazywane są _partycjami podstawowymi_. W celu ominięcia tego ograniczenia i umożliwienia stworzenia większej liczby partycji, wymyślono nowy typ partycji - _partycje rozszerzone_. Na dysku może znajdować się tylko jedna taka partycja. Natomiast wewnątrz niej można utworzyć specjalne partycje, zwane _partycjami logicznymi_.

Wszystkie partycje posiadają własny _identyfikator partycji_, tj. numer określający typ przechowywanych na niej danych. Partycje FreeBSD oznaczone są identyfikatorem `165`.

Każdy ze stosowanych systemów operacyjnych identyfikuje partycje w określony sposób. Dla przykładu, DOS i jego następcy, w tym Windows(R), przypisują każdej partycji podstawowej i logicznej _literę dysku_, zaczynając od [.filename]#C:#.

FreeBSD musi być zainstalowane na partycji podstawowej. Wszystkie własne dane, w tym pliki tworzone przez użytkowników, może przechowywać na jednej partycji. Jednakże, jeśli masz do dyspozycji kilka dysków, możesz utworzyć partycję FreeBSD na każdym z nich bądź jedynie na wybranych. Tym nie mniej na potrzeb instalacji wymagane jest posiadanie jednej partycji. Może to być świeżo utworzona, pusta partycja, lub też partycja zawierająca dane, które nie są już potrzebne.

W przypadku, gdy wszystkie dostępne partycje na dysku są już wykorzystywane, będziesz musiał zwolnić jedną z nich, korzystając z narzędzi dostępnych w wykorzystywanym systemie operacyjnym (np. `fdisk` w DOS lub Windows(R)).

Jeśli dysponujesz wolną partycją, możesz ją wykorzystać. Może się jednak okazać, że zajdzie potrzeba zmniejszenia rozmiarów niektórych z pozostałych partycji.

Minimalna instalacja FreeBSD zajmuje jedynie 100 MB miejsca na dysku. Jest to jednakże _bardzo_ minimalna instalacja, praktycznie nie pozostawiająca miejsca na pliki użytkowników. Zdecydowanie bardziej realnym minimum jest 250 MB, o ile nie planujemy wykorzystania środowiska graficznego, bądź co najmniej 350 MB z graficznym interfejsem. Instalowanie wielu dodatkowych programów wymaga więcej wolnego miejsca na dysku.

W celu przygotowania miejsca dla FreeBSD można wykorzystać narzędzia komercyjne pokroju PartitionMagic(R) bądź darmowe jak GParted. Dwa darmowe programy służące do tego samego celu, tj. FIPS i PResizer, dostępne są na płycie CD w katalogu [.filename]#tools#. W tym samym katalogu znajduje się również ich dokumentacja. Zarówno FIPS, PResizer jak i PartitionMagic(R) potrafią rozszerzać partycje typu FAT16 i FAT32 - wykorzystywane w MS-DOS(R) aż po Windows(R) ME. System plików NTFS potrafią obsługiwać PartitionMagic(R) i GParted.

[WARNING]
====

Niewłaściwe korzystanie z tych narzędzi może doprowadzić do utraty danych. Przed ich zastosowaniem należy się upewnić, że przygotowaliśmy aktualne kopie zapasowe.
====

.Wykorzystanie niezmienionej istniejącej partycji
[example]
====
Przyjmijmy, że mamy do dyspozycji komputer wyposażony w dysk o pojemności 4 GB, z zainstalowanym systemem Windows(R). Dysk jest podzielony na dwie części oznaczone literami [.filename]#C:# i [.filename]#D:#, o rozmiarze 2 GB każda. Na [.filename]#C:# mamy 1 GB danych, a na [.filename]#D:# 0,5 GB danych.

Mamy więc dysk o dwóch partycjach, z których każda oznaczona jest literą dysku. Możemy skopiować dane z [.filename]#D:# na [.filename]#C:#, dzięki czemu druga partycja stanie się wolna i będzie można zainstalować na niej FreeBSD.
====

.Zmniejszenie istniejącej partycji
[example]
====
Przyjmijmy tym razem, że na dysku o pojemności 4 GB zainstalowany jest system Windows(R) na jednej dużej partycji. Partycja dostępna jest jako dysk [.filename]#C:# o rozmiarze 4 GB. Mamy na nim 1,5 GB danych i chcielibyśmy udostępnić dla FreeBSD 2 GB.

Możemy wybrać jedno z poniższych rozwiązań:

. Przygotować kopię danych, następnie na nowo zainstalować Windows(R), tworząc podczas instalacji partycję o rozmiarze 2 GB.
. Skorzystać z jednego ze wspomnianych wcześniej narzędzi, np. PartitionMagic(R), w celu zmniejszenia rozmiaru partycji Windows(R).

====

==== Układ dysku Alpha

W przypadku architektury Alpha na FreeBSD trzeba będzie przeznaczyć cały dysk. Nie ma obecnie możliwości wspólnego korzystania z dysku przez kilka systemów operacyjnych. W zależności od konkretnego modelu komputera Alpha, możemy wykorzystać dysk SCSI lub IDE, o ile komputer umożliwia załadowanie z niego systemu operacyjnego.

Zgodnie z konwencją stosowaną w podręcznikach Digital / Compaq wszystkie polecenia SRM pisane są wielkimi literami. SRM nie rozróżnia małych i dużych liter.

By wyświetlić nazwy i rodzaje zainstalowanych w komputerze dysków, posługujemy się poleceniem `SHOW DEVICE` w konsoli SRM:

[source,bash]
....
>>>SHOW DEVICE
dka0.0.0.4.0               DKA0           TOSHIBA CD-ROM XM-57  3476
dkc0.0.0.1009.0            DKC0                       RZ1BB-BS  0658
dkc100.1.0.1009.0          DKC100             SEAGATE ST34501W  0015
dva0.0.0.0.1               DVA0
ewa0.0.0.3.0               EWA0              00-00-F8-75-6D-01
pkc0.7.0.1009.0            PKC0                  SCSI Bus ID 7  5.27
pqa0.0.0.4.0               PQA0                       PCI EIDE
pqb0.0.1.4.0               PQB0                       PCI EIDE
....

Powyższy przykład pochodzi z komputera Digital Personal Workstation 433au i pokazuje trzy dyski. Pierwszym z nich jest CDROM opisany nazwą [.filename]#DKA0#, natomiast dwa pozostałe to twarde dyski o nazwach [.filename]#DKC0# i [.filename]#DKC100#.

Dyski o nazwach typu [.filename]#DKx# są dyskami SCSI. Dla przykładu [.filename]#DKA100# oznacza dysk SCSI o identyfikatorze 1 na pierwszej szynie SCSI (A), natomiast [.filename]#DKC300# oznacza dysk o identyfikatorze 3 na trzeciej szynie SCSI (C). Nazwa [.filename]#PKx# oznacza kontroler SCSI. Jak pokazuje przykład z `SHOW DEVICE`, napędy CDROM SCSI traktowane są tak samo jak dyski twarde SCSI.

Nazwy dysków IDE mają postać [.filename]#DQx#, a nazwa [.filename]#PQx# oznacza kontroler IDE.

=== Zbieranie informacji o konfiguracji sieci

Jeśli podczas instalacji będziemy korzystać z połączenia z siecią (np. FreeBSD instalowane będzie z serwera FTP lub serwera NFS), będziemy musieli znać konfigurację sieci. W trakcie instalacji pojawi się prośba o wpisanie tej konfiguracji, by umożliwić FreeBSD połączenie się z siecią i kontynuowanie instalacji.

==== Połączenie z siecią Ethernet lub przez modem kablowy/DSL

W przypadku komputera podłączonego do sieci Ethernet lub połączonego z Internetem przez modem kablowy lub DSL, potrzebne będą następujące informacje:

. Adres IP
. Adres IP domyśnej bramy
. Nazwa stacji
. Adresy IP serwerów DNS
. Maska podsieci

Informacje te możemy uzyskać od administratora systemu lub dostawcy usług sieciowych. Może się okazać, że konfiguracja odbywa się automatycznie, przy użyciu _DHCP_. Jeśli tak jest, należy o tym fakcie pamiętać.

==== Połączenie przez modem

Instalacja FreeBSD przez Internet możliwa jest także w przypadku połączenia modemowego, jednakże będzie to trwało bardzo długo.

Niezbędne informacje:

. Numer telefonu do dostawcy usług internetowych
. Numer portu COM, do którego podłączony jest modem
. Nazwa użytkownika i hasło konta u dostawcy usług

=== Sprawdzenie erraty FreeBSD

W pracy nad FreeBSD podejmowane są wszelkie starania, aby każde wydanie FreeBSD było jak najbardziej niezawodne, jednakże od czasu do czasu zdarzają się błędy. W pewnych bardzo rzadkich przypadkach mogą mieć one wpływ na proces instalacji systemu. Błędy te po wykryciu i naprawieniu są opisywane w erracie zamieszczonej na stronie http://www.FreeBSD.org/releases/{rel120-current}r/errata/[FreeBSD Errata] (ang.). Przed instalacją warto jest sprawdzić, czy w erracie nie wspomniano o problemach, które mogą zakłócić instalację.

Informacje o wszystkich wydaniach systemu, jak również erraty do każdego z nich, znaleźć można na link:https://www.FreeBSD.org/[stronie WWW FreeBSD] w części poświęconej link:https://www.FreeBSD.org/releases/[wydaniom].

=== Pozyskanie plików instalacyjnych FreeBSD

Pliki potrzebne do rozpoczęcia instalacji systemu mogą pochodzić z jednego z wymienionych poniżej źródeł:

.Nośniki lokalne
* Płyta CDROM lub DVD
* Partycja DOS-owa na tym samym komputerze
* Pamięć taśmowa QIC lub SCSI
* Dyskietki

.Sieć
* Serwer FTP, także przez firewall lub proxy HTTP, zależnie od potrzeb
* Serwer NFS
* Dedykowane połączenie równoległe lub szeregowe

Posiadając FreeBSD na CD lub DVD, mamy już wszystko, co potrzeba, możemy zatem przejść do następnej części (<<install-floppies>>).

Jeśli nie mamy plików instalacyjnych FreeBSD, <<install-diff-media>> zawiera opis instalacji FreeBSD z dowolnego z wymienionych wcześniej źródeł. Następnie powróćmy do <<install-floppies>>.

[[install-floppies]]
=== Przygotowanie dyskietek do instalacji

Instalacja FreeBSD rozpoczyna się uruchomieniem programu instalacyjnego podczas startu komputera - nie jest to program, który można uruchomić w innym systemie operacyjnym. Zwykle przy uruchamianiu komputera ładowany jest system zainstalowany na dysku twardym, jednak można także uruchomić system z dyskietki "startowej". Do tego celu może także posłużyć CDROM, jeśli komputer daje taką możliwość.

[TIP]
====

Jeśli posiadamy FreeBSD na płytach CDROM lub DVD (kupionych lub przygotowanych samodzielnie), a nasz komputer pozwala na uruchomienie z płyty (zwykle dzięki ustawieniu opcji BIOS-u zwanej "Boot Order" lub podobnej), możemy nie czytać niniejszej części. Płyty CDROM i DVD zawierające FreeBSD mogą być użyte jako dyski startowe bez dodatkowego przygotowania.
====

By utworzyć zestaw dyskietek startowych, należy:

[.procedure]
====
. Zdobyć obrazy dyskietek startowych
+ 
Dyskietki startowe znaleźć można wśród plików instalacyjnych w katalogu [.filename]#floppies/# bądź pobrać z serwera `ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/<arch>/<version>-RELEASE/floppies/` zamieniając odpowiednio _<arch>_ i _<wersja>_ właściwą architekturą naszego sprzętu i wybraną wersją FreeBSD. Przykładowo, obrazy dyskietek dla FreeBSD {rel120-current}-RELEASE na architekturę i386(TM) dostępne są pod adresem link:ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/{rel120-current}-RELEASE/floppies/[ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/{rel120-current}-RELEASE/floppies/].
+ 
Obrazy dyskietek mają rozszerzenie [.filename]#.flp#. Katalog [.filename]#floppies/# zawiera kilka różnych obrazów, a to, które z nich będą potrzebne, zależy od wersji FreeBSD, która będzie instalowana, a czasem również od sprzętu na którym system ma być zainstalowany. Z reguły potrzebne będą trzy dyskietki [.filename]#boot.flp#, [.filename]#kern1.flp# i [.filename]#kern2.flp#. Warto jednak dla pewności przeczytać znajdujący się w tym samym katalogu plik [.filename]#README.TXT#.
+
[NOTE]
======
Systemy gałęzi 5.X starsze od FreeBSD 5.3 mogą wymagać dodatkowych sterowników urządzeń. Znaleźć je można w obrazie dyskietki [.filename]#drivers.flp#.
======
+
[IMPORTANT]
======
Pobierając pliki przez FTP należy koniecznie używać _trybu binarnego_. Wiadomo jest, że w niektórych przeglądarkach stosowany jest tryb _tekstowy_ (zwany też _ASCII_), przez co dyskietki startowe mogą się okazać niezdatne do użycia.
======
+
. Przygotować dyskietki startowe
+ 
Dla każdego pliku z obrazem przygotowujemy jedną dyskietkę. Dyskietki nie mogą być w jakikolwiek sposób uszkodzone. Najprostszym sposobem samodzielnego sprawdzenia, czy dyskietka nie jest wadliwa, jest jej sformatowanie. Nie powinniśmy ufać dyskietkom formatowanym fabrycznie. Narzędzie formatujące dostępne w systemie Windows(R) nie poinformuje o istnieniu uszkodzonych bloków, po prostu oznaczy je jako "uszkodzone" i zignoruje. Zaleca się używanie fabrycznie nowych dyskietek.
+
[IMPORTANT]
======
Gdy podczas instalacji FreeBSD program instalacyjny wskaże błąd, zastygnie lub zachowa się w dziwny sposób, jednymi z pierwszych podejrzanych powinny być dyskietki. Trzeba wówczas nagrać pliki obrazów na inne dyskietki i spróbować ponownie.
======
+
. Nagrać pliki obrazów na dyskietki
+ 
Pliki [.filename]#.flp# nie są zwyczajnymi plikami, które można nagrać na dyskietkę. Są natomiast obrazami całkowitej zawartości dyskietek. Oznacza to, że _nie można_ zapisać tych plików po prostu kopiując z jednego dysku na drugi. Skorzystamy ze specjalnego oprogramowania, by bezpośrednio zapisać obrazy na dyskietkach.
+ 
Jeśli dyskietki nagrywamy na komputerze z MS-DOS(R)/Windows(R), to możemy skorzystać z dołączonego do FreeBSD narzędzia `fdimage`.
+ 
W przypadku, gdy wykorzystujemy obrazy dyskietek z płyty CDROM dostępnego jako dysk [.filename]#E:#, posłużymy się poleceniem:
+
[source,bash]
....
E:\> tools\fdimage floppies\kern.flp A:
....
+ 
Powtarzamy je dla każdego z plików [.filename]#.flp#, za każdym razem zmieniając dyskietkę. Najlepiej jest też napisać na dyskietce nazwę skopiowanego na nią pliku. Powyższe polecenie może potrzebować pewnych modyfikacji, w zależności od miejsca, w którym znajdują się pliki [.filename]#.flp#. Jeżeli nie dysponujemy płytą CD, możemy pobrać `fdimage` z link:ftp://ftp.FreeBSD.org/pub/FreeBSD/tools/[katalogu tools] na serwerze FTP FreeBSD.
+ 
Jeżeli natomiast dyskietki nagrywamy w systemie uniksowym (na przykład w innym FreeBSD), do zapisania plików obrazów na dyskietkach możemy wykorzystać polecenie man:dd[1]. We FreeBSD wpisalibyśmy:
+
[source,bash]
....
# dd if=kern.flp of=/dev/fd0
....
+ 
W systemie FreeBSD [.filename]#/dev/fd0# odpowiada pierwszej stacji dyskietek (napędowi [.filename]#A:#). [.filename]#/dev/fd1# odpowiadałoby [.filename]#B:# i tak dalej. W innych odmianach systemów UNIX(R) mogą być stosowane inne nazwy stacji dyskietek, konieczne może więc być zapoznanie się z dokumentacją danego systemu.
====

W tej chwili jesteśmy już przygotowani do instalacji FreeBSD.

[[install-start]]
== Rozpoczęcie instalacji

[IMPORTANT]
====
Z założenia, podczas instalacji dane na dysku (lub dyskach) nie ulegną żadnym zmianom przed pojawieniem się następującego komunikatu:

....
Last Chance: Are you SURE you want continue the installation?

If you're running this on a disk with data you wish to save then WE
STRONGLY ENCOURAGE YOU TO MAKE PROPER BACKUPS before proceeding!

We can take no responsibility for lost disk contents!
....

Instalację można przerwać w dowolnej chwili przed powyższym ostrzeżeniem, mając pewność, że dane na dysku pozostają nietknięte. Jeśli będziemy się obawiać, że coś niewłaściwie skonfigurowaliśmy, możemy po prostu wyłączyć komputer i nic złego się nie stanie.
====

[[install-starting]]
=== Uruchomienie komputera

[[install-starting-i386]]
==== Uruchomienie i386(TM)

[.procedure]
====
. Na początku komputer powinien być wyłączony.
. Włączamy komputer. Po chwili powinna pojawić się możliwość przejścia do menu systemowego, lub BIOS-u, najczęściej poprzez naciśnięcie klawisza kbd:[F2], kbd:[F10], kbd:[Del] bądź kbd:[Alt+S]. Wciskamy odpowiedni klawisz zgodnie z informacją na ekranie. Niekiedy komputer podczas uruchamiania pokazuje jakiś obrazek. Zwykle wciskając kbd:[Esc] możemy pozbyć się obrazka, aby mieć możliwość przeczytania komunikatów.
. Wśród opcji odnajdujemy tę, która decyduje o kolejności ładowania systemu z poszczególnych urządzeń. Zwykle ma ona postać listy urządzeń, takich jak `Floppy`, `CDROM`, `First Hard Disk`, itd.
+ 
Jeżeli wcześniej przygotowaliśmy dyskietki startowe, wybieramy stację dyskietek. Jeśli natomiast korzystamy z płyty CD, wybieramy właśnie CDROM. Wątpliwości możemy rozstrzygnąć zaglądając do instrukcji dołączonej do komputera i jego płyty głównej.
+ 
Wprowadzone zmiany muszą być zapisane przed opuszczeniem menu systemowego. Komputer powinien ponownie się uruchomić.
. Jeżeli korzystamy z dyskietek startowych, o których traktuje <<install-floppies>>, to jedna z nich będzie pierwszą dyskietką startową, najprawdopodobniej będzie to dyskietka zawierająca [.filename]#kern.flp#. Ją właśnie wkładamy do stacji.
+ 
W przypadku korzystania z płyty CD wystarczy po prostu włączyć komputer i włożyć płytę do napędu.
+ 
Jeżeli komputer uruchomi się jak zwykle i załaduje już zainstalowany system operacyjny, może to oznaczać, że:
.. Dyskietka lub płyta zostały włożone za późno. Powinniśmy spróbować uruchomić komputer bez wyjmowania dyskietki bądź płyty.
.. Zmiany w ustawieniach BIOS-u nie zadziałały prawidłowo. Spróbujmy wprowadzić je ponownie, aż do osiągnięcia zamierzonego efektu.
.. Nasza wersja BIOS-u nie pozwala na uruchomienie systemu z wybranego nośnika.
+
. Rozpocznie się ładowanie FreeBSD. Podczas ładowania z płyty CD pojawi się tekst podobny do poniższego (pominięto informacje o wersji)::
+
[source,bash]
....
Verifying DMI Pool Data ........
Boot from ATAPI CD-ROM :
 1. FD 2.88MB  System Type-(00)
Uncompressing ... done

BTX loader 1.00 BTX version is 1.01
Console: internal video/keyboard
BIOS drive A: is disk0
BIOS drive B: is disk1
BIOS drive C: is disk2
BIOS drive D: is disk3
BIOS 639kB/261120kB available memory

FreeBSD/i386 bootstrap loader, Revision 0.8

/kernel text=0x277391 data=0x3268c+0x332a8 |

|
Hit [Enter] to boot immediately, or any other key for command prompt.
Booting [kernel] in 9 seconds... _
....
+ 
Natomiast ładując z dyskietki, zobaczymy tekst w rodzaju (pominięto informacje o wersji):
+
[source,bash]
....
Verifying DMI Pool Data ........

BTX loader 1.00  BTX version is 1.01
Console: internal video/keyboard
BIOS drive A: is disk0
BIOS drive C: is disk1
BIOS 639kB/261120kB available memory

FreeBSD/i386 bootstrap loader, Revision 0.8

/kernel text=0x277391 data=0x3268c+0x332a8 |

Please insert MFS root floppy and press enter:
....
+ 
Postępując zgodnie z instrukcją na ekranie, wyjmujemy dyskietkę [.filename]#kern.flp#, wkładamy [.filename]#mfsroot.flp# i naciskamy kbd:[Enter]. We FreeBSD 5.3 i późniejszych dostępne są również inne dyskietki opisane w <<install-floppies,poprzednim podrozdziale>>. Należy uruchomić system z pierwszej dyskietki, następnie wkładać kolejne zgodnie z pojawiającymi się komunikatami.
. Niezależnie, czy uruchamiamy komputer z dyskietki czy z płyty, podczas ładowania ujrzymy komunikat:
+
[source,bash]
....
Hit [Enter] to boot immediately, or any other key for command prompt.
Booting [kernel] in 9 seconds... _
....
+ 
Albo czekamy dziesięć sekund, albo wciskamy kbd:[Enter].
====

==== Uruchomienie Alpha

[.procedure]
====
. Na początku komputer powinien być wyłączony.
. Włączamy komputer i czekamy na znak zachęty boot monitora.
. Jeżeli korzystamy z dyskietek startowych opisanych w <<install-floppies>>, to jedna z nich będzie pierwszą dyskietką startową, najprawdopodobniej będzie to dyskietka zawierająca [.filename]#kern.flp#. Ją właśnie wkładamy do stacji i wpisujemy następujące polecenie, aby uruchomić komputer z dyskietki (zmieniając nazwę napędu dyskietek, jeżeli będzie to konieczne):
+
[source,bash]
....
>>>BOOT DVA0 -FLAGS '' -FILE ''
....
+ 
W przypadku korzystania z płyty CD, wkładamy ją do napędu i rozpoczynamy instalację wpisując następujące polecenie (wstawiając inną nazwę napędu CDROM, jeżeli będzie to konieczne):
+
[source,bash]
....
>>>BOOT DKA0 -FLAGS '' -FILE ''
....
+
. Rozpocznie się ładowanie FreeBSD. Podczas ładowania z dyskietki, zobaczymy tekst w rodzaju:
+
[source,bash]
....
Please insert MFS root floppy and press enter:
....
+ 
Postępując zgodnie z instrukcją na ekranie, wyjmujemy dyskietkę [.filename]#kern.flp#, wkładamy [.filename]#mfsroot.flp# i naciskamy kbd:[Enter].
. Niezależnie, czy uruchamiamy komputer z dyskietki czy z płyty, podczas ładowania ujrzymy komunikat:
+
[source,bash]
....
Hit [Enter] to boot immediately, or any other key for command prompt.
Booting [kernel] in 9 seconds... _
....
+ 
Czekamy dziesięć sekund, albo wciskamy kbd:[Enter]. Przejdziemy do menu konfiguracyjnego jądra.
====

[[view-probe]]
=== Przeglądanie wyników rozpoznania urządzeń

Kilkaset ostatnio wyświetlonych na ekranie linii jest zapisywanych i można je przeglądać.

By przejrzeć bufor, naciskamy kbd:[Scroll Lock]. Włączamy w ten sposób tryb przewijania ekranu. Można teraz przeglądać wyniki rozpoznania urządzeń przy użyciu klawiszy kursora, lub kbd:[PageUp] i kbd:[PageDown]. Tryb przewijania wyłącza się wciskając ponownie kbd:[Scroll Lock].

Zróbmy to, aby przejrzeć tekst, który został przewinięty poza ekran, gdy jądro dokonywało rozpoznawania urządzeń. Tekst będzie mieć treść podobną do przedstawionej na <<install-dev-probe>>, jednakże dokładna treść zależy od zainstalowanych w komputerze urządzeń.

[[install-dev-probe]]
.Przykład wyników rozpoznania urządzeń
[source,bash]
....
avail memory = 253050880 (247120K bytes)
Preloaded elf kernel "kernel" at 0xc0817000.
Preloaded mfs_root "/mfsroot" at 0xc0817084.
md0: Preloaded image </mfsroot> 4423680 bytes at 0xc03ddcd4

md1: Malloc disk
Using $PIR table, 4 entries at 0xc00fde60
npx0: <math processor> on motherboard
npx0: INT 16 interface
pcib0: <Host to PCI bridge> on motherboard
pci0: <PCI bus> on pcib0
pcib1:<VIA 82C598MVP (Apollo MVP3) PCI-PCI (AGP) bridge> at device 1.0 on pci0
pci1: <PCI bus> on pcib1
pci1: <Matrox MGA G200 AGP graphics accelerator> at 0.0 irq 11
isab0: <VIA 82C586 PCI-ISA bridge> at device 7.0 on pci0
isa0: <iSA bus> on isab0
atapci0: <VIA 82C586 ATA33 controller> port 0xe000-0xe00f at device 7.1 on pci0
ata0: at 0x1f0 irq 14 on atapci0
ata1: at 0x170 irq 15 on atapci0
uhci0 <VIA 83C572 USB controller> port 0xe400-0xe41f irq 10 at device 7.2 on pci
0
usb0: <VIA 83572 USB controller> on uhci0
usb0: USB revision 1.0
uhub0: VIA UHCI root hub, class 9/0, rev 1.00/1.00, addr1
uhub0: 2 ports with 2 removable, self powered
pci0: <unknown card> (vendor=0x1106, dev=0x3040) at 7.3
dc0: <ADMtek AN985 10/100BaseTX> port 0xe800-0xe8ff mem 0xdb000000-0xeb0003ff ir
q 11 at device 8.0 on pci0
dc0: Ethernet address: 00:04:5a:74:6b:b5
miibus0: <MII bus> on dc0
ukphy0: <Generic IEEE 802.3u media interface> on miibus0
ukphy0: 10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
ed0: <NE2000 PCI Ethernet (RealTek 8029)> port 0xec00-0xec1f irq 9 at device 10.
0 on pci0
ed0 address 52:54:05:de:73:1b, type NE2000 (16 bit)
isa0: too many dependant configs (8)
isa0: unexpected small tag 14
orm0: <Option ROM> at iomem 0xc0000-0xc7fff on isa0
fdc0: <NEC 72065B or clone> at port 0x3f0-0x3f5,0x3f7 irq 6 drq2 on isa0
fdc0: FIFO enabled, 8 bytes threshold
fd0: <1440-KB 3.5" drive> on fdc0 drive 0
atkbdc0: <Keyboard controller (i8042)> at port 0x60,0x64 on isa0
atkbd0: <AT Keyboard> flags 0x1 irq1 on atkbdc0
kbd0 at atkbd0
psm0: <PS/2 Mouse> irq 12 on atkbdc0
psm0: model Generic PS/@ mouse, device ID 0
vga0: <Generic ISA VGA> at port 0x3c0-0x3df iomem 0xa0000-0xbffff on isa0
sc0: <System console> at flags 0x100 on isa0
sc0: VGA <16 virtual consoles, flags=0x300>
sio0 at port 0x3f8-0x3ff irq 4 flags 0x10 on isa0
sio0: type 16550A
sio1 at port 0x2f8-0x2ff irq 3 on isa0
sio1: type 16550A
ppc0: <Parallel port> at port 0x378-0x37f irq 7 on isa0
pppc0: SMC-like chipset (ECP/EPP/PS2/NIBBLE) in COMPATIBLE mode
ppc0: FIFO with 16/16/15 bytes threshold
plip0: <PLIP network interface> on ppbus0
ad0: 8063MB <IBM-DHEA-38451> [16383/16/63] at ata0-master UDMA33
acd0: CD-RW <LITE-ON LTR-1210B> at ata1-slave PIO4
Mounting root from ufs:/dev/md0c
/stand/sysinstall running as init on vty0
....

Warto jest uważnie przejrzeć wyniki, by mieć pewność, że wszystkie spodziewane urządzenia zostały wykryte. Brak urządzenia na liście oznacza, że nie zostało ono wykryte. Jeśli sterownik wymagał skonfigurowania IRQ i adresu portu, to powinniśmy sprawdzić, czy prawidłowo je wpisaliśmy.

Jeśli trzeba będzie zmienić ustawienia rozpoznawania urządzeń, możemy łatwo opuścić program sysinstall i zacząć od nowa. Dzięki temu można również lepiej poznać cały proces.

[[sysinstall-exit]]
.Wyjście z sysinstall
image::sysinstall-exit.png[]

Korzystając z klawiszy kursora, wybieramy z głównego menu [.guimenuitem]#Exit Install#. Ukaże się następujący komunikat:

[source,bash]
....
                      User Confirmation Requested
         Are you sure you wish to exit? The system will reboot
           (be sure to remove any floppies from the drives).

                            [ Yes ]    No
....

Instalacja ponownie zacznie się od początku, jeśli wybierzemy btn:[yes], pozostawiając płytę CD w napędzie.

Jeśli instalujemy z dyskietek, przed ponownym uruchomieniem komputera powinniśmy wyjąć dyskietkę [.filename]#mfsroot.flp# i włożyć [.filename]#kern.flp#.

[[using-sysinstall]]
== Wprowadzenie do sysinstall

Sysinstall jest aplikacją instalacyjną przygotowaną w ramach Projektu FreeBSD. Jest to program konsolowy podzielony na szereg pomniejszych menu i ekranów, służących do konfiguracji i zarządzania procesem instalacji.

Menu sysinstall obsługiwane jest klawiszami kursora, klawiszem kbd:[Enter], kbd:[Spacją] i innymi. Dokładny opis działania poszczególnych klawiszy znaleźć można w części poświęconej posługiwaniu się sysinstall.

Dostęp do tych informacji możliwy jest poprzez podświetlenie pozycji [.guimenuitem]#Usage# i wybranie przycisku btn:[Select], a następnie wciśnięcie klawisza kbd:[Enter], zgodnie z <<sysinstall-main3>>.

Wyświetlone zostaną zostaną wskazówki odnośnie posługiwania się systemem menu. Po ich przeczytaniu powrót do głównego menu możliwy jest poprzez naciśnięcie klawisza kbd:[Enter].

[[sysinstall-main3]]
.Wyświetlenie z głównego menu instrukcji obsługi sysinstall
image::main1.png[]

[[select-doc]]
=== Menu dokumentacji

Korzystając z klawiszy kursora, w głównym menu wybieramy [.guimenuitem]#Doc# i wciskamy kbd:[Enter].

[[main-doc]]
.Wybór menu dokumentacji
image::main-doc.png[]

Spowoduje to wyświetlenie menu dokumentacji.

[[docmenu1]]
.Menu dokumentacji sysinstall
image::docmenu1.png[]

Warto przeczytać dostępne tu dokumenty.

By wyświetlić konkretny dokument, wybieramy go klawiszami kursora, a następnie wciskamy kbd:[Enter]. Po przeczytaniu klawiszem kbd:[Enter] możemy powrócić do menu dokumentacji.

Do głównego menu instalacji powracamy wybierając klawiszami kursora [.guimenuitem]#Exit#, a następnie wciskając kbd:[Enter].

[[keymap]]
=== Menu mapowania klawiatury

Aby zmienić mapowanie klawiatury klawiszami kursora wybieramy z menu pozycję [.guimenuitem]#Keymap# i wciskamy kbd:[Enter]. Zmiana mapowania klawiatury wymagana jest jedynie gdy używamy klawiatury innej niż standardowej amerykańskiej.

[[sysinstall-keymap]]
.Główne menu sysinstall
image::main-keymap.png[]

Wyboru mapowania klawiatury dokonujemy poprzez wskazanie odpowiedniej pozycji z listy przy pomocy klawiszy kursora, oraz wciśnięcie kbd:[Spacji]. Ponowne naciśnięcie kbd:[Spacji] cofa wybór. Po wybraniu odpowiedniego mapowania wskazujemy klawiszami kursora btn:[OK] i wciskamy kbd:[Enter].

Na poniższym rysunku przedstawiona jest tylko część listy. Wybranie btn:[Cancel] spowoduje przyjęcie domyślnego mapowania klawiatury i powrót do głównego menu.

[[sysinstall-keymap-menu]]
.Menu mapowania klawiatury
image::keymap.png[]

[[viewsetoptions]]
=== Ekran opcji instalacji

Wybieramy [.guimenuitem]#Options# i naciskamy kbd:[Enter].

[[sysinstall-options]]
.Główne menu sysinstall
image::main-options.png[]

[[options]]
.Opcje sysinstall
image::options.png[]

Wartości domyślne są zwykle odpowiednie dla większości użytkowników i nie ma potrzeby ich zmiany. Nazwa wydania może być inna w zależności od instalowanej wersji systemu.

Po wybraniu jednej z opcji, na dole ekranu ukaże się jej opis podświetlony na niebiesko. Opcja [.guimenuitem]#Use Defaults# (użyj domyślnych) przywraca wszystkim opcjom wartości domyślne.

Naciskając kbd:[F1] przechodzimy do ekranu pomocy, gdzie możemy przeczytać o poszczególnych opcjach.

Naciskając kbd:[Q] powracamy do głównego menu.

[[start-install]]
=== Rozpoczęcie instalacji standardowej

Instalacja standardowa zalecana jest dla wszystkich zaczynających swą przygodę z FreeBSD, bądź w ogóle z systemem UNIX(R). Klawiszami kursora wybieramy [.guimenuitem]#Standard# i wciskamy kbd:[Enter].

[[sysinstall-standard]]
.Rozpoczęcie instalacji standardowej
image::main-std.png[]

[[install-steps]]
== Przydział miejsca na dysku

Zaczynamy od przydzielenia FreeBSD przestrzeni dyskowej, oraz oznaczenia tej przestrzeni w taki sposób, by sysinstall mógł ją przygotować. Do tego potrzebna nam będzie wiedza na temat sposobu, w jaki FreeBSD znajduje informacje zapisane na dysku.

[[install-drive-bios-numbering]]
=== Kolejność dysków w BIOS-ie

Przed instalacją i konfiguracją FreeBSD powinniśmy zapoznać się z pewnym ważnym zagadnieniem, szczególnie istotnym dla posiadaczy dwóch lub więcej twardych dysków.

W komputerze typu PC wyposażonym w zależny od BIOS-u system operacyjny, jak na przykład MS-DOS(R) lub Microsoft(R) Windows(R), BIOS może zmienić rzeczywistą kolejność dysków, a system operacyjny tę zmianę zaakceptuje. Dzięki temu system może zostać uruchomiony z dysku innego niż tzw. "primary master". Jest to szczególnie wygodne dla tych użytkowników, którzy za najprostszą i najtańszą metodę tworzenia kopii zapasowej uważają kupno identycznego drugiego twardego dysku i kopiowanie zawartości pierwszego dysku przy użyciu Ghost lub XCOPY. W przypadku uszkodzenia pierwszego dysku, ataku wirusa lub awarii systemu operacyjnego, dane mogą być z łatwością odzyskane poprzez zamianę logicznej kolejności dysków w BIOS-ie. To tak, jakby zamienić przewody dysków, ale bez konieczności otwierania obudowy.

Droższe maszyny wyposażone w kontrolery SCSI mają często rozszerzenia BIOS-u pozwalające zamieniać kolejność dysków SCSI na podobnej zasadzie, obsługując do siedmiu dysków.

Użytkowników przyzwyczajonych do korzystania z tego typu rozwiązań może spotkać niespodzianka, gdy we FreeBSD rezultaty odbiegają od oczekiwań. FreeBSD nie korzysta z BIOS-u, jak również nie zna "logicznej kolejności dysków BIOS-u". W efekcie może to prowadzić do kłopotliwych sytuacji, szczególnie wtedy, gdy dyski są identyczne pod względem geometrii, oraz zawierają takie same dane.

Planując używanie FreeBSD, powinniśmy ustawić w BIOS-ie rzeczywistą kolejność dysków przed instalacją systemu, i tę kolejność pozostawić. Jeśli chcemy koniecznie zamienić dyski, to możemy to zrobić sprzętowo, otwierając obudowę i zamieniając odpowiednie zworki i przewody.

****
Bolek ma przygotować dla Lolka komputer z FreeBSD. Bolek montuje jeden dysk SCSI jako urządzenie SCSI zero, i instaluje na nim FreeBSD.

Lolek zaczyna korzystać z systemu, ale po kilku dniach zauważa, że dysk SCSI zgłasza liczne błędy, więc zawiadamia o tym Bolka.

Po kolejnych kilku dniach Bolek postanawia rozwiązać problem, więc bierze ze "składzika" taki sam dysk SCSI. Kontrola powierzchni dysku wykazuje, że dysk działa prawidłowo, więc Bolek podłącza go jako czwarte urządzenie SCSI i wykonuje kopię dysku zerowego na dysk czwarty. Ponieważ dysk jest podłączony i działa jak należy, Bolek stwierdza, że można zacząć go używać, więc wykorzystując możliwości BIOS-u SCSI zmienia kolejność dysków w taki sposób, by system uruchamiany był z czwartego urządzenia SCSI. FreeBSD uruchamia się i działa jak należy.

Lolek korzysta z systemu przez jakiś czas, następnie wspólnie z Bolkiem postanawiają spróbować czegoś nowego - zainstalować nowszą wersję FreeBSD. Bolek wymontowuje dysk SCSI zero, ponieważ działał kiepsko, i zastępuje go kolejnym identycznym dyskiem ze "składzika". Bolek instaluje nową wersję FreeBSD na nowym dysku SCSI korzystając z czarodziejskich dyskietek instalacyjnych Lolka. Instalacja przebiega prawidłowo.

Lolek używa nowej wersji FreeBSD przez parę dni i stwierdza, że można zacząć korzystać z niej w pracy. Wcześniej jednak trzeba będzie skopiować wszystkie dane ze starej wersji. Lolek podłącza więc czwarty dysk SCSI (najświeższą kopię starej wersji FreeBSD). Lolek stwierdza jednak z niepokojem, że na dysku nie ma śladu po jego cennych danych.

Gdzie się one podziały?

Gdy Bolek sporządził kopię dysku zerowego na dysku czwartym, dysk czwarty stał się "klonem". Zmieniając kolejność dysków w BIOS-ie SCSI aby móc uruchamiać system z dysku czwartego, Bolek sam siebie wprowadzał w błąd. FreeBSD wciąż działało na dysku zerowym. Zmiana w BIOS-ie powoduje, że część kodu uruchamiającego FreeBSD jest rzeczywiście ładowana z dysku wskazanego w BIOS-ie, lecz kiedy pałeczkę przejmują sterowniki jądra FreeBSD, kolejność dysków BIOS-u przestaje obowiązywać, a FreeBSD przechodzi z powrotem na rzeczywistą kolejność. W opowiadanej historyjce system nadal działał na dysku zerowym, i tam właśnie znajdowały się cenne dane Lolka, a nie na dysku czwartym. Choć wydawało się, że system działa na dysku czwartym, było to tylko złudzenie.

Z przyjemnością oznajmiamy, iż ani jeden bajt cennych danych nie zginął ani nie został w inny sposób skrzywdzony podczas naszych badań nad opisanym zjawiskiem. Stary dysk SCSI zero został odnaleziony i cenne dane wróciły do Lolka (Bolek z kolei przekonał się, że niczego nie można być pewnym).

W opowieści udział wzięły dyski SCSI, jednakże w przypadku dysków IDE sytuacja wyglądałaby tak samo.
****

[[main-fdisk]]
=== Tworzenie segmentów za pomocą programu FDisk

[NOTE]
====
Dokonywane tutaj zmiany nie zostaną zapisane na dysku. Jeżeli będziemy podejrzewać, że coś zrobiliśmy źle, możemy wybrać w menu wyjście z programu sysinstall i spróbować jeszcze raz od początku, bądź wcisnąć kbd:[U] by skorzystać z opcji [.guimenuitem]#Undo# (cofnij). W ostateczności, jeżeli całkiem stracimy orientację, możemy po prostu wyłączyć komputer.
====

Po wybraniu standardowej instalacji w sysinstall zostanie wyświetlony następujący komunikat:

[source,bash]
....
                                 Message
 In the next menu, you will need to set up a DOS-style ("fdisk")
 partitioning scheme for your hard disk. If you simply wish to devote
 all disk space to FreeBSD (overwriting anything else that might be on
 the disk(s) selected) then use the (A)ll command to select the default
 partitioning scheme followed by a (Q)uit. If you wish to allocate only
 free space to FreeBSD, move to a partition marked "unused" and use the
 (C)reate command.
                                [  OK  ]

                      [ Press enter or space ]
....

Zgodnie z poleceniem naciskamy kbd:[Enter]. Zobaczymy teraz listę twardych dysków znalezionych przez jądro podczas rozpoznawania urządzeń. <<sysinstall-fdisk-drive1>> przedstawia przykład komputera z dwoma dyskami IDE, o nazwach [.filename]#ad0# i [.filename]#ad2#.

[[sysinstall-fdisk-drive1]]
.Wybór dysku FDisk-a
image::fdisk-drive1.png[]

Można się zastanawiać, dlaczego na liście brakuje [.filename]#ad1#. Co spowodowało, że został pominięty?

Przyjmijmy przykładowo, że mamy dwa dyski IDE, jeden jako master na pierwszym kontrolerze IDE, drugi jako master na drugim kontrolerze IDE. Gdyby we FreeBSD zostały one ponumerowane w takiej kolejności, w jakiej zostały wykryte, czyli [.filename]#ad0# i [.filename]#ad1#, wszystko działałoby jak należy.

Gdybyśmy jednak zainstalowali potem jeszcze jeden dysk, jako slave na pierwszym kontrolerze IDE, to ten właśnie dysk zostałby nowym [.filename]#ad1#, a wcześniejszy [.filename]#ad1# zmieniłby się w [.filename]#ad2#. Ponieważ systemy plików odnajdywane są według nazw urządzeń (np. [.filename]#ad1s1a#), mogłoby się nagle okazać, że niektóre systemy plików nie działają poprawnie. Aby to poprawić, musielibyśmy zmienić konfigurację systemu.

Aby zapobiec takim sytuacjom, jądro FreeBSD może być skonfigurowane tak, by przydzielać dyskom IDE numery zgodne z ich rzeczywistym umiejscowieniem, niezależnie od kolejności wykrywania. Tym sposobem dysk podłączony jako master na drugim kontrolerze IDE _zawsze_ będzie mieć nazwę [.filename]#ad2#, nawet w sytuacji, gdy [.filename]#ad0# i [.filename]#ad1# nie są w ogóle obecne.

Jądro FreeBSD domyślnie skonfigurowane jest właśnie w ten sposób, dlatego też na ekranie mamy [.filename]#ad0# i [.filename]#ad2#. Komputer, z którego ten rysunek pochodzi, miał dwa dyski IDE podłączone jako master do obu kontrolerów IDE, nie miał natomiast dysków podłączonych jako slave.

Wybieramy dysk, na którym chcemy zainstalować FreeBSD i wybieramy btn:[OK]. Zostanie uruchomiony FDisk, pokazując na ekranie obraz podobny do <<sysinstall-fdisk1>>.

Ekran FDisk-a podzielony jest na trzy części.

Część pierwsza, obejmująca pierwsze dwie linie ekranu, zawiera informacje o wybranym dysku, w tym jego oznaczenie we FreeBSD, geometrię oraz całkowity rozmiar dysku.k.

Druga część pokazuje informacje o istniejących na dysku segmentach: gdzie się one zaczynają oraz kończą, jaki jest ich rozmiar, jaka nazwa została im nadana przez FreeBSD ich opis oraz typ. Na rysunku przykładowym widać dwa niewielkie nieużywane segmenty, obecne ze względu na stosowany w architekturze PC podział dysku. Prócz tego widać duży segment FAT, który prawie na pewno jest dyskiem [.filename]#C:# w MS-DOS(R) / Windows(R), oraz segment rozszerzony, zawierający być może dyski MS-DOS(R) / Windows(R) oznaczone kolejnymi literami.

W trzeciej części znajduje się lista dostępnych w FDisk-u poleceń.

[[sysinstall-fdisk1]]
.Układ partycji w FDisk-u przed zmianami
image::fdisk-edit1.png[]

Dalej postępować będziemy w zależności od tego, jak chcemy podzielić nasz dysk na segmenty.

Jeżeli chcemy, by FreeBSD zajęło cały dysk (co wiąże się z usunięciem z niego wszelkich innych danych, gdy potwierdzimy to w sysinstall na późniejszym etapie instalacji), naciskamy kbd:[A], co odpowiada opcji [.guimenuitem]#Use Entire Disk# (wykorzystaj cały dysk). Istniejące segmenty zostaną usunięte, a w ich miejsce pojawi się mały obszar opisany jako `unused` (nieużywany; znów jest to następstwem pecetowego układu dysku), oraz duży segment przeznaczony dla FreeBSD. Jeżeli decydujemy się na tę opcję, powinniśmy w następnej kolejności wskazać nowoutworzony segment FreeBSD przy użyciu klawiszy kursora i wcisnąć kbd:[S], by umożliwić ładowanie systemu z tego segmentu. Ekran będzie wyglądać podobnie do przedstawionego na <<sysinstall-fdisk2>>. Zwróćmy uwagę na literę `A` w kolumnie Flags, oznacza ona, że segment jest _aktywny_ i będzie z niego ładowany system.

Jeśli chcemy usunąć istniejący segment by zwolnić miejsce dla FreeBSD, wskazujemy segment korzystając z klawiszy kursora i naciskamy kbd:[D]. Następnie możemy nacisnąć kbd:[C] i w odpowiedzi na pytanie o rozmiar segmentu, który chcemy utworzyć, wpisać odpowiednią wartość i wcisnąć kbd:[Enter]. Wartość domyślna stanowi największy możliwy rozmiar segmentu, czyli np. wolną przestrzeń na dysku bądź całą pojemność dysku twardego.

Wolne miejsce dla FreeBSD mogliśmy także przygotować wcześniej (na przykład przy użyciu programu PartitionMagic(R)), w takim wypadku po prostu wciskamy kbd:[C] by utworzyć nowy segment. W tym przypadku również zostaniemy zapytani o rozmiar segmentu, który zamierzamy stworzyć.

[[sysinstall-fdisk2]]
.Partycja w FDisk-u obejmująca cały dysk
image::fdisk-edit2.png[]

Na koniec naciskamy kbd:[Q]. Dokonane zmiany zostaną zapamiętane przez sysinstall, ale nie będą jeszcze zapisane na dysku.

[[bootmgr]]
=== Instalacja programu ładującego

W kolejnym kroku instalacji będziemy mieć możliwość zainstalowania programu ładującego (ang. boot manager). Mówiąc ogólnie, powinniśmy instalować program ładujący FreeBSD jeżeli:

* Mamy dwa lub więcej dysków, a FreeBSD instalujemy na dysku innym niż pierwszy.
* Instalujemy FreeBSD obok innego systemu operacyjnego na tym samym dysku, i chcemy mieć możliwość wybrania systemu operacyjnego podczas uruchamiania komputera.

Jeśli FreeBSD będzie jedynym systemem operacyjnym na danym komputerze i zostanie zainstalowany na pierwszym dysku twardym, wówczas wystarczy wykorzystać [.guimenuitem]#Standardowy# program ładujący. Natomiast jeśli wykorzystujemy już inny program potrafiący uruchomić FreeBSD powinnyśmy wybrać opcję [.guimenuitem]#None# (żaden).

Dokonany wybór potwierdzamy naciskając kbd:[Enter].

[[sysinstall-bootmgr]]
.Wybór programu ładującego w sysinstall
image::boot-mgr.png[]

Ekran pomocy, wyświetlany po naciśnięciu kbd:[F1], opisuje problemy z jakimi można się spotkać, gdy planuje się mieć kilka systemów operacyjnych na jednym dysku.

=== Tworzenie segmentów na innym dysku

Jeżeli mamy więcej dysków, po wyborze programu ładującego ponownie ukaże się ekran wyboru dysku. Chcąc zainstalować FreeBSD na kilku dyskach, wybieramy tutaj kolejny dysk i ponownie korzystając z programu FDisk tworzymy na nim segmenty.

[IMPORTANT]
====
Jeśli instalujemy FreeBSD na innym dysku niż pierwszy, wówczas program ładujący FreeBSD musi zostać zainstalowany na obydwu dyskach.
====

[[sysinstall-fdisk-drive2]]
.Zakończenie wyboru dysku
image::fdisk-drive2.png[]

Klawisz kbd:[Tab] przełącza pomiędzy ostatnio wybranym dyskiem oraz przyciskami btn:[OK], i btn:[Cancel].

Wciskamy kbd:[Tab] jeden raz, by wybrać btn:[OK], następnie naciskamy kbd:[Enter] aby przejść do kolejnego etapu instalacji.

[[bsdlabeleditor]]
=== Tworzenie partycji z wykorzystaniem Disklabel

W nowoutworzonych segmentach musimy stworzyć kilka partycji. Pamiętajmy, że każda partycja oznaczona jest literą od `a` do `h`, a partycje `b`, `c` i `d` rządzą się specjalnymi zasadami, których należy przestrzegać.

Niektóre aplikacje mogą skorzystać na stosowaniu określonych schematów podziału na partycje, szczególnie, gdy partycje rozłożone są na kilku dyskach. Na razie jednak, ponieważ jest to nasza pierwsza instalacja FreeBSD, nie powinniśmy zbytnio przejmować się podziałem dysku na partycje. Ważniejszym jest, byśmy zainstalowali FreeBSD i zaczęli się uczyć, jak go używać. Kiedy już nabierzemy pewnej wprawy, możemy zainstalować system ponownie i zmienić sposób podziału na partycje.

Poniższy schemat przedstawia cztery partycje - jedną dla przestrzeni wymiany, oraz trzy dla systemów plików.

.Układ partycji pierwszego dysku
[cols="1,1,1,1", frame="none", options="header"]
|===
| Partycja
| System plików
| Rozmiar
| Opis

|`a`
|[.filename]#/#
|100 MB
|Będzie to główny system plików. Wszystkie inne systemy plików będą zamontowane gdzieś wewnątrz niego. 100 MB jest dość rozsądnym rozmiarem dla tego celu. Nie będzie tu przechowywane zbyt wiele danych, zwykle po instalacji FreeBSD umieszcza tu około 40 MB danych. Pozostałe miejsce jest dla danych tymczasowych, oraz służy jako zapas, gdyby kolejne wersje FreeBSD potrzebowały więcej miejsca w [.filename]#/#.

|`b`
|brak
|2-3 x RAM
|

Partycja ta służy jako przestrzeń wymiany. Wybór jej odpowiedniego rozmiaru nie jest sprawą banalną. Możemy przyjąć, że przestrzeń wymiany powinna być dwu- lub trzykrotnie większa niż ilość pamięci fizycznej (RAM). Prócz tego powinniśmy mieć co najmniej 64 MB przestrzeni wymiany, więc jeżeli nasz komputer ma mniej niż 32 MB pamięci, ustawmy rozmiar przestrzeni wymiany na 64 MB.

 Jeśli dysponujemy kilkoma dyskami, możemy na każdym z nich umieścić przestrzeń wymiany. FreeBSD będzie w procesie wymiany wykorzystywać każdy z dysków, dzięki czemu wymiana będzie się odbywać szybciej. W takim przypadku przyjmujemy całkowity rozmiar potrzebnej przestrzeni wymiany (np. 128 MB) i dzielimy go przez liczbę posiadanych dysków (np. dwa dyski), otrzymując w wyniku rozmiar przestrzeni wymiany dla jednego dysku. W naszym przykładzie będzie to 64 MB na każdy dysk.

|`e`
|[.filename]#/var#
|50 MB
|W katalogu [.filename]#/var# przechowywane są pliki o zmiennych rozmiarach; pliki dzienników systemowych i inne pliki administracyjne. Podczas codziennej pracy FreeBSD na wielu z tych plików dokonywane są częste operacje odczytu lub zapisu. Dzięki umieszczeniu ich w oddzielnym systemie plików FreeBSD może dokonać optymalizacji dostępu do nich, nie wywierając jednocześnie wpływu na inne pliki, do których dostęp przebiega inaczej.

|`f`
|[.filename]#/usr#
|Reszta dysku
|Inne pliki będą zwykle przechowywane w katalogu [.filename]#/usr# i jego podkatalogach.
|===

Jeżeli instalujemy FreeBSD na dwóch lub więcej dyskach, musimy utworzyć partycje także w innych przygotowanych segmentach. Najłatwiej jest po prostu przygotować na każdym z kolejnych dysków dwie partycje, jedną na przestrzeń wymiany, drugą na system plików.

.Układ partycji dla kolejnych dysków
[cols="1,1,1,1", frame="none", options="header"]
|===
| Partycja
| System plików
| Rozmiar
| Opis

|`b`
|brak
|Patrz: opis
|Jak już powiedzieliśmy, przestrzeń wymiany możemy dzielić między kilka dysków. Mimo, iż mamy do dyspozycji partycję `a`, zgodnie z obowiązującą konwencją przestrzeń wymiany powinna znajdować się na partycji `b`.

|`e`
|/dysk__n__
|Reszta dysku
|Pozostała część dysku zajmowana jest przez jedną dużą partycję. Mogłaby to z powodzeniem być partycja `a`, zamiast `e`. Przyjęto jednak, że partycja `a` zarezerwowana jest dla głównego systemu plików ([.filename]#/#). Nie ma przymusu stosowania tej zasady, jednak sysinstall jej przestrzega, dobrze więc jest ją stosować dla zachowania porządku podczas instalacji. System plików możemy zamontować w dowolnym miejscu, w przykładzie zaproponowano [.filename]#/dyskn#, gdzie _n_ jest kolejnym numerem każdego dysku. Można jednak wybrać inne nazewnictwo według uznania..
|===

Po podjęciu decyzji jak ma wyglądać układ partycji, pora wprowadzić go w życie używając sysinstall. Na ekranie ukaże się następujący komunikat:

[source,bash]
....
                                 Message
 Now, you need to create BSD partitions inside of the fdisk
 partition(s) just created. If you have a reasonable amount of disk
 space (200MB or more) and don't have any special requirements, simply
 use the (A)uto command to allocate space automatically. If you have
 more specific needs or just don't care for the layout chosen by
 (A)uto, press F1 for more information on manual layout.

                                [  OK  ]
                          [ Press enter or space ]
....

Naciskamy kbd:[Enter] by przejść do edytora partycji FreeBSD, zwanego Disklabel.

<<sysinstall-label>> przedstawia ekran zaraz po uruchomieniu Disklabel. Jest on podzielony na trzy części.

W kilku pierwszych wierszach widoczna jest nazwa wybranego aktualnie dysku, oraz nazwa segmentu, w którym tworzymy partycje (Disklabel używa tutaj nazwy `Partition name`, czyli nazwa partycji, a nie nazwa segmentu). Jest tu również zawarta informacja o rozmiarze wolnej przestrzeni wewnątrz segmentu, czyli przestrzeni nie przydzielonej jeszcze partycjom.

Środek ekranu zajmuje lista utworzonych partycji, wraz z nazwami przechowywanych na nich systemów plików, ich rozmiarami oraz pewnymi opcjami związanymi z tworzeniem systemu plików.

W dolnej części przedstawiona jest lista dostępnych w Disklabel poleceń.

[[sysinstall-label]]
.Edytor Disklabel
image::disklabel-ed1.png[]

Disklabel potrafi automatycznie utworzyć partycje i nadać im domyślne rozmiary. Wypróbujmy tę możliwość naciskając kbd:[A]. Na ekranie ukaże się obraz podobny do <<sysinstall-label2>>. Ustawienia automatyczne mogą być właściwe lub nie, w zależności od rozmiaru dysku. Nie ma to jednak większego znaczenia, ponieważ nie trzeba ich koniecznie akceptować.

[NOTE]
====
Katalog [.filename]#/tmp# jest domyślnie umieszczany na własnej partycji, zamiast być częścią partycji [.filename]#/#. Dzięki temu można uniknąć zapełnienia partycji [.filename]#/# plikami tymczasowymi.
====

[[sysinstall-label2]]
.Edytor disklabel z automatycznymi ustawieniami
image::disklabel-auto.png[]

By usunąć zaproponowane partycje i zastąpić je utworzonymi własnoręcznie, wybieramy klawiszami kursora pierwszą partycję i naciskamy kbd:[D]. Tak samo postępujemy z pozostałymi partycjami.

Teraz, aby stworzyć pierwszą partycję (`a`, zamontowaną jako [.filename]#/#), wybieramy informacje o dysku w górnej części ekranu i wciskamy kbd:[C]. Pojawi się okienko z pytaniem o rozmiar nowej partycji (<<sysinstall-label-add>>). Wybrany rozmiar podać możemy w blokach, albo w wygodniejszej formie w postaci liczby megabajtów, gigabajtów lub cylindrów, odpowiednio z przyrostkiem `M`, `G` lub `C`.

[NOTE]
====
Począwszy od FreeBSD 5.X użytkownicy mogą: wybrać system plików UFS2 (domyślny system we FreeBSD 5.1 i późniejszych) wykorzystując opcję `Custom Newfs` (kbd:[Z]), tworzyć partycje za pomocą `Auto Defaults` i modyfikować przy pomocy `Custom Newfs` bądź dodać opcję `-O 2` podczas normalnego procesu tworzenia partycji. Wykorzystując opcję `Custom Newfs` musimy pamiętać by dodać flagę `-U` (SoftUpdates)!
====

[[sysinstall-label-add]]
.Wolne miejsce dla głównej partycji
image::disklabel-root1.png[]

Wybierając domyślnie zaproponowany rozmiar utworzymy partycję obejmującą pozostałe miejsce w segmencie. Jeżeli zamierzamy stworzyć partycje o takich rozmiarach, jak wcześniej opisywaliśmy, wówczas kasujemy zaproponowaną wartość klawiszem kbd:[Backspace], i wpisujemy 64M, <<sysinstall-label-add2>>. Następnie wybieramy btn:[OK].

[[sysinstall-label-add2]]
.Zmiana rozmiaru głównej partycji
image::disklabel-root2.png[]

Po wybraniu rozmiaru partycji pojawi się pytanie, czy partycja zawierać będzie system plików, czy przestrzeń wymiany. Okienko z tym pytaniem pokazane jest na <<sysinstall-label-type>>. Pierwsza partycja zawierać będzie system plików, wybieramy więc [.guimenuitem]#FS# i naciskamy kbd:[Enter].

[[sysinstall-label-type]]
.Wybór typu głównej partycji
image::disklabel-fs.png[]

Ponieważ na partycji znajdować się będzie system plików, Disklabel musi wiedzieć, gdzie będzie on zamontowany. <<sysinstall-label-mount>> przedstawia okienko z prośbą o podanie tej informacji. Główny system plików montowany jest jako [.filename]#/#, wpisujemy więc [.filename]#/# i wciskamy kbd:[Enter].

[[sysinstall-label-mount]]
.Wybór miejsca montowania głównego systemu plików
image::disklabel-root3.png[]

Na ekranie pojawi się informacja o nowo utworzonej partycji. Powinniśmy teraz powtórzyć całą procedurę dla kolejnych partycji. Tworząc partycję wymiany nie będziemy pytani o miejsce jej zamontowania, ponieważ partycje wymiany nie są montowane. Gdy będziemy tworzyć ostatnią partycję, [.filename]#/usr#, możemy przyjąć proponowany rozmiar domyślny, aby przeznaczyć na tę partycję resztę segmentu.

Ostatecznie ekran edytora Disklabel będzie wyglądać podobnie do <<sysinstall-label4>>, choć wybrane przez nas wartości mogą być inne. By zakończyć pracę z Disklabel, wciskamy kbd:[Q].

[[sysinstall-label4]]
.Edytor Disklabel
image::disklabel-ed2.png[]

[[install-choosing]]
== Wybór składników instalacji

[[distset]]
=== Wybór zestawu komponentów

Decyzja o tym, jaki zestaw komponentów zainstalujemy, zależy w dużej mierze od planowanych zastosowań systemu i ilości wolnego miejsca na dysku. Dostępne warianty pozwalają zarówno na instalację najmniejszej konfiguracji, jak i na instalację wszystkiego. Początkujący użytkownicy systemów UNIX(R) i FreeBSD powinni wybrać jeden z przygotowanych wariantów. Dla bardziej doświadczonych użytkowników istnieje możliwość ułożenia własnego zestawu komponentów.

Więcej informacji o zestawach komponentów i ich zawartości możemy uzyskać naciskając kbd:[F1]. Po przejrzeniu tych informacji naciskamy kbd:[Enter], aby powrócić do menu wyboru komponentów.

Jeśli planujemy korzystać z graficznego interfejsu użytkownika powinniśmy wybrać jeden z zestawów o nazwie rozpoczynającej się literą `X`. Po instalacji zajmiemy się konfigurowaniem serwera graficznego i wyborem menedżera okien. Szczegółowe informacje na ten temat zawiera rozdział crossref:x11[x11,System okien X].

To, która wersja systemu X11 jest domyślnie instalowana, zależy od instalowanej wersji FreeBSD. Wydania wcześniejsze od 5.3 domyślnie instalują XFree86(TM) 4.X. Natomiast FreeBSD 5.3 i późniejsze instalują Xorg.

Jeżeli planujemy samodzielne kompilowanie jądra, powinniśmy wybrać wariant zawierający kod źródłowy. crossref:kernelconfig[kernelconfig,Konfiguracja jądra FreeBSD] zawiera informacje, dlaczego powinno się budować niestandardowe jądro i jak to zrobić.

Oczywiście najbardziej wszechstronny jest system zawierający wszystkie komponenty. Jeśli mamy wystarczająco dużo miejsca na dysku, wybieramy klawiszami kursora [.guimenuitem]#All#, <<distribution-set1>>, i naciskamy kbd:[Enter]. Jeżeli jednak miejsca na dysku mogłoby nie wystarczyć, wybierzmy wariant najlepiej odpowiadający obecnym potrzebom. Kolejne komponenty mogą być dodawane po zainstalowaniu systemu.

[[distribution-set1]]
.Wybór komponentów
image::dist-set.png[]

[[portscol]]
=== Instalacja kolekcji portów

Po wyborze komponentów będziemy mieć możliwość zainstalowania kolekcji portów FreeBSD. Kolekcja portów umożliwia łatwe i wygodne instalowanie oprogramowania. Nie zawiera ona kodów źródłowych programów. W skład kolekcji portów wchodzą pliki umożliwiające automatyczne pobieranie programów, oraz ich kompilowanie i instalowanie. crossref:ports[ports,Instalacja programów. pakiety i porty] opisuje sposób korzystanie z kolekcji portów.

Program instalacyjny nie sprawdza, czy mamy odpowiednio dużo wolnego miejsca na dysku. Kolekcję portów powinniśmy instalować tylko pod warunkiem, że miejsca faktycznie wystarczy. We FreeBSD {rel120-current} kolekcja zajmuje około {ports-size}.

[source,bash]
....
                         User Confirmation Requested
 Would you like to install the FreeBSD ports collection?

 This will give you ready access to over 24,000 ported software packages,
 at a cost of around 500 MB of disk space when "clean" and possibly much
 more than that if a lot of the distribution tarballs are loaded
 (unless you have the extra CDs from a FreeBSD CD/DVD distribution
 available and can mount it on /cdrom, in which case this is far less
 of a problem).

 The Ports Collection is a very valuable resource and well worth having
 on your /usr partition, so it is advisable to say Yes to this option.

 For more information on the Ports Collection & the latest ports,
 visit:
     http://www.FreeBSD.org/ports

                              [ Yes ]     No
....

Klawiszami kursora wybieramy btn:[yes], aby zainstalować kolekcję portów, lub btn:[no], by z niej zrezygnować. Wybór zatwierdzamy klawiszem kbd:[Enter]. Ponownie pojawi się menu wyboru komponentów.

[[distribution-set2]]
.Zatwierdzenie wybranych komponentów
image::dist-set2.png[]

Jeżeli odpowiadają nam wybrane komponenty, przy pomocy klawiszy kursora wybieramy [.guimenuitem]#Exit#, zaznaczamy btn:[OK] i naciskamy kbd:[Enter], przechodząc do kolejnego etapu instalacji.

[[install-media]]
== Wybór nośnika instalacji

W przypadku, gdy instalujemy z płyty CD bądź DVD, klawiszami kursora wybieramy pozycję [.guimenuitem]#Install from a FreeBSD CD/DVD# (instalacja z CD/DVD). Upewniwszy się, że zaznaczone jest btn:[OK], naciskamy kbd:[Enter] przechodząc do następnego etapu instalacji.

Jeżeli stosujemy inną metodę instalacji, wybieramy odpowiednią pozycję i postępujemy zgodnie ze wskazówkami.

Klawiszem kbd:[F1] możemy włączyć pomoc. Do menu wyboru nośnika powracamy naciskając kbd:[Enter].

[[choose-media]]
.Wybór nośnika instalacji
image::media.png[]

[NOTE]
.Tryby instalacji przez FTP
====
Można wybrać jeden z trzech trybów instalacji przez FTP: aktywne FTP, pasywne FTP lub pośrednio przez HTTP proxy.

Aktywne FTP: [.guimenuitem]#Install from an FTP server#::
Wybór tego wariantu spowoduje, że przesyłanie danych przez FTP odbywać się będzie w trybie "aktywnym". Nie zadziała to w przypadku transmisji przez zaporę ogniową, ale będzie współpracować ze starszymi serwerami FTP nie obsługującymi trybu pasywnego. Jeśli połączenie pasywne (wybierane domyślnie) nie zadziała, spróbujmy aktywnego!

Pasywne FTP: [.guimenuitem]#Install from an FTP server through a firewall#::
Opcja ta informuje sysinstall, że przesyłanie danych przez FTP odbywać się będzie w trybie "pasywnym". Pozwoli to na połączenie poprzez zaporę ogniową, która nie zezwala na połączenia z zewnątrz z portami o przypadkowych numerach. 

FTP przez proxy HTTP: [.guimenuitem]#Install from an FTP server through a http proxy#::
Ten wariant instruuje sysinstall do wykorzystania protokołu HTTP (podobnie jak przeglądarka stron WWW) do połączenia się z serwerem proxy pośredniczącym w transmisji przez FTP. Serwer pośredniczący przetwarza żądania i przesyła je do serwera FTP. Dzięki temu możliwe jest połączenie poprzez zaporę ogniową nie zezwalającą na żadne połączenia FTP, oferującą jednak HTTP proxy. W takiej sytuacji, poza adresem serwera FTP, będziemy musieli podać także adres serwera proxy.

Korzystając z pośredniczącego serwera FTP proxy, zwykle podajemy nazwę serwera docelowego jako część nazwy użytkownika, po znaku "@". Serwer proxy "udaje" wówczas serwer docelowy. Załóżmy, dla przykładu, że chcemy zainstalować system z `ftp.FreeBSD.org`, za pośrednictwem serwera proxy FTP `foo.example.com`, nasłuchującego na porcie 1024.

W takiej sytuacji przechodzimy do menu opcji, jako nazwę użytkownika FTP wpisujemy `ftp@ftp.FreeBSD.org`, a jako hasło podajemy nasz adres email. Jako nośnik instalacji wybieramy FTP (lub pasywne FTP, jeżeli umożliwia to serwer proxy), a jako URL wpisujemy `ftp://foo.example.com:1234/pub/FreeBSD`.

Ze względu na to, że [.filename]#/pub/FreeBSD# z `ftp.FreeBSD.org` jest udostępnione na serwerze proxy `foo.example.com`, możemy właśnie z _tego_ serwera dokonać instalacji (ponieważ zajmie się on pobraniem odpowiednich plików z `ftp.FreeBSD.org`).
====

[[install-final-warning]]
== Przystąpienie do instalacji

Możemy teraz rozpocząć właściwą instalację, a zarazem mamy ostatnią szansę na rezygnację z instalacji bez zmiany zawartości dysku twardego.

[source,bash]
....
                       User Confirmation Requested
 Last Chance! Are you SURE you want to continue the installation?

 If you're running this on a disk with data you wish to save then WE
 STRONGLY ENCOURAGE YOU TO MAKE PROPER BACKUPS before proceeding!

 We can take no responsibility for lost disk contents!

                             [ Yes ]    No
....

Wybieramy btn:[yes] i wciskamy kbd:[Enter], by rozpocząć instalację.

Czas trwania instalacji zależy od wybranych komponentów, używanego nośnika instalacji oraz prędkości komputera. Szereg komunikatów informować będzie o przebiegu procesu instalacji.

Po zakończeniu instalacji wyświetlony zostanie następujący komunikat:

[source,bash]
....
                               Message

Congratulations! You now have FreeBSD installed on your system.

We will now move on to the final configuration questions.
For any option you do not wish to configure, simply select No.

If you wish to re-enter this utility after the system is up, you may
do so by typing: /stand/sysinstall .

                                 [ OK ]

                      [  Press enter to continue  ]
....

Po naciśnięciu klawisza kbd:[Enter] zajmiemy się przygotowaniem wstępnej konfiguracji systemu.

Jeśli wybierzemy btn:[no] i naciśniemy kbd:[Enter] instalacja zostanie przerwana, bez dokonywania jakichkolwiek zmian. Pojawi się komunikat o treści:

[source,bash]
....
                                Message
Installation complete with some errors.  You may wish to scroll
through the debugging messages on VTY1 with the scroll-lock feature.
You can also choose "No" at the next prompt and go back into the
installation menus to retry whichever operations have failed.

                                 [ OK ]
....

Powyższy komunikat pojawia się, ponieważ nic nie zostało zainstalowane. Naciskając kbd:[Enter] możemy powrócić do głównego menu i opuścić program instalacyjny.

[[install-post]]
== Po instalacji

Po pomyślnie zakończonej instalacji zajmiemy się wstępną konfiguracją systemu. Wszelkich zmian w ustawieniach możemy dokonać przed uruchomieniem nowo zainstalowanego systemu FreeBSD lub też po zakończeniu instalacji, korzystając z `sysinstall` (we FreeBSD starszych niż 5.2 `/stand/sysinstall`) i jego opcji [.guimenuitem]#Configure#.

[[inst-network-dev]]
=== Konfiguracja urządzeń sieciowych

Jeśli wcześniej skonfigurowaliśmy PPP na potrzeby instalacji przez FTP, konfiguracja urządzeń sieciowych zostanie pominięta. Będziemy mogli zająć się nią później.

Szczegółowe informacje na temat sieci lokalnych (LAN) oraz konfiguracji FreeBSD w roli bramy lub rutera znaleźć można w rozdziale crossref:advanced-networking[advanced-networking,Zaawansowana konfiguracja sieciowa].

[source,bash]
....
                      User Confirmation Requested
   Would you like to configure any Ethernet or SLIP/PPP network devices?

                             [ Yes ]   No
....

Jeśli chcemy skonfigurować urządzenie sieciowe, wybieramy btn:[yes] i wciskamy kbd:[Enter]. W przeciwnym wypadku wybieramy btn:[no].

[[ed-config1]]
.Wybór karty Ethernet
image::ed0-conf.png[]

Klawiszami kursora wybieramy interfejs, który będziemy konfigurować i wciskamy kbd:[Enter].

[source,bash]
....
                      User Confirmation Requested
       Do you want to try IPv6 configuration of the interface?

                              Yes   [ No ]
....

Dla przykładu, w sieci lokalnej w zupełności wystarcza obecny protokół Internetu (IPv4), wybieramy więc klawiszami kursora btn:[no] i naciskamy kbd:[Enter].

Jeśli chcemy wypróbować nowy protokół Internetu (IPv6), wybieramy btn:[yes] i naciskamy kbd:[Enter]. Przez chwilę będzie się odbywać poszukiwanie serwerów RA.

[source,bash]
....
                             User Confirmation Requested
        Do you want to try DHCP configuration of the interface?

                              Yes   [ No ]
....

Jeżeli nie wykorzystujemy DHCP (Dynamic Host Configuration Protocol), wybieramy klawiszami kursora btn:[no] i wciskamy kbd:[Enter].

Wybranie btn:[yes] spowoduje uruchomienie dhclient i jeśli wszystko przebiegnie prawidłowo, konfiguracja sieci zostanie rozpoznana automatycznie. crossref:network-servers[network-dhcp,Automatic Network Configuration (DHCP)] zawiera szczegółowe informacje na ten temat.

Przedstawiony poniżej ekran konfiguracji sieci (Network Configuration) przedstawia konfigurację karty sieciowej komputera, który będzie służył jako brama w sieci lokalnej.

[[ed-config2]]
.Konfiguracja interfejsu ed0
image::ed0-conf2.png[]

Klawiszem kbd:[Tab] wybieramy poszczególne pola, w których wpisujemy odpowiednie informacje:

Host (stacja)::
Pełna nazwa stacji, w powyższym przykładzie `k6-2.example.com`.

Domain (domena)::
Nazwa domeny, do której należy stacja, w przykładzie jest to `example.com`.

IPv4 Gateway (brama IPv4)::
Adres IP stacji przekazującej pakiety do odbiorców spoza sieci lokalnej. Musi być podany, jeśli komputer jest węzłem w sieci. Jeżeli komputer pełni rolę bramy do Internetu w sieci lokalnej, pole to należy _pozostawić puste_.

Name server (serwer nazw)::
Adres IP lokalnego serwera DNS. W przykładowej sieci lokalnej nie ma serwera DNS, wpisany więc został adres serwera DNS dostawcy Internetu (`208.163.10.2`).

IPv4 address (adres IPv4)::
W przykładzie temu interfejsowi przypisano adres `192.168.0.1`.

Netmask (maska podsieci)::
W sieci lokalnej użyty został dla przykładu blok adresów klasy C (`192.168.0.0` - `192.168.0.255`). Maska podsieci jest maską sieci klasy C (`255.255.255.0`).

Extra options to ifconfig (dodatkowe opcje dla ifconfig)::
Tu wpisywane są dodatkowe opcje dla `ifconfig` charakterystyczne dla interfejsu. W pokazanym przykładzie nie było takowych opcji.

Gdy konfiguracja będzie gotowa, klawiszem kbd:[Tab] wybieramy btn:[OK] i naciskamy kbd:[Enter].

[source,bash]
....
                      User Confirmation Requested
        Would you like to Bring Up the ed0 interface right now?

                             [ Yes ]   No
....

Jeśli wybierzemy btn:[yes] i wciśniemy kbd:[Enter], komputer zostanie aktywowany do pracy w sieci.

[[gateway]]
=== Konfiguracja bramy

[source,bash]
....
                       User Confirmation Requested
       Do you want this machine to function as a network gateway?

                              [ Yes ]    No
....

Jeśli komputer będzie w sieci lokalnej pełnić rolę bramy, czyli będzie przekazywać pakiety pomiędzy innymi komputerami, wybieramy opcję btn:[yes] i naciskamy kbd:[Enter]. Jeżeli natomiast komputer będzie węzłem w sieci, wybieramy btn:[no] i również wciskamy kbd:[Enter].

[[inetd-services]]
=== Konfiguracja usług internetowych

[source,bash]
....
                      User Confirmation Requested
Do you want to configure inetd and the network services that it provides?

                               Yes   [ No ]
....

Wybranie btn:[no] spowoduje, że wiele usług (jak np. telnetd) będą wyłączone. Oznacza to, że zdalni użytkownicy nie będą mogli połączyć się z naszym komputerem za pomocą telnetu. Użytkownicy lokalni będą natomiast mogli łączyć się z odległymi komputerami korzystając z telnetu.

Usługi możemy włączyć po zainstalowaniu systemu, aby to zrobić, modyfikujemy plik [.filename]#/etc/inetd.conf# za pomocą edytora tekstu. Więcej informacji znaleźć można w Sekcji 25.2.1. crossref:network-servers[network-inetd-overview,Overview].

Jeśli wolelibyśmy skonfigurować usługi internetowe podczas instalacji, wybieramy btn:[yes]. Zostaniemy poproszeni o dodatkowe potwierdzenie:

[source,bash]
....
                      User Confirmation Requested
The Internet Super Server (inetd) allows a number of simple Internet
services to be enabled, including finger, ftp and telnetd.  Enabling
these services may increase risk of security problems by increasing
the exposure of your system.

With this in mind, do you wish to enable inetd?

                             [ Yes ]   No
....

Wybieramy btn:[yes], by przejść dalej.

[source,bash]
....
                      User Confirmation Requested
inetd(8) relies on its configuration file, /etc/inetd.conf, to determine
which of its Internet services will be available.  The default FreeBSD
inetd.conf(5) leaves all services disabled by default, so they must be
specifically enabled in the configuration file before they will
function, even once inetd(8) is enabled.  Note that services for
IPv6 must be separately enabled from IPv4 services.

Select [Yes] now to invoke an editor on /etc/inetd.conf, or [No] to
use the current settings.

                             [ Yes ]   No
....

Wybranie btn:[yes] pozwoli na włączanie poszczególnych usług poprzez usunięcie znaku `#` na początku właściwego wiersza.

[[inetd-edit]]
.Modyfikacja [.filename]#inetd.conf#
image::edit-inetd-conf.png[]

Gdy włączymy wybrane usługi, naciskamy kbd:[Esc] by przejść do menu, w którym będziemy mogli zakończyć modyfikowanie pliku i zapisać zmiany.

[[ftpanon]]
=== Anonimowe FTP

[source,bash]
....
                      User Confirmation Requested
 Do you want to have anonymous FTP access to this machine?

                              Yes    [ No ]
....

[[deny-anon]]
==== Wyłączenie anonimowego FTP

Wybranie zaznaczonego domyślnie btn:[no] pozwoli na dostęp do komputera poprzez FTP tylko tym użytkownikom, którzy mają własne konta chronione hasłem.

[[ftpallow]]
==== Włączenie anonimowego FTP

Włączenie anonimowego FTP oznacza, że każdy będzie mógł uzyskać dostęp do komputera. Zanim się na to zdecydujemy, powinniśmy być świadomi niebezpieczeństwa, które się z tym wiąże. crossref:security[security,Security] zawiera więcej informacji na temat bezpieczeństwa.

Aby włączyć anonimowe FTP, klawiszami kursora wybieramy btn:[yes] i naciskamy kbd:[Enter]. Ekran będzie wyglądać jak na poniższym rysunku (lub podobnie):

[[anon-ftp2]]
.Domyślne ustawienia anonimowego FTP
image::ftp-anon1.png[]

Możemy nacisnąć kbd:[F1], by uzyskać pomoc:

[source,bash]
....
This screen allows you to configure the anonymous FTP user.

The following configuration values are editable:

UID:     The user ID you wish to assign to the anonymous FTP user.
         All files uploaded will be owned by this ID.

Group:   Which group you wish the anonymous FTP user to be in.

Comment: String describing this user in /etc/passwd

FTP Root Directory:

        Where files available for anonymous FTP will be kept.

Upload subdirectory:

        Where files uploaded by anonymous FTP users will go.
....

Główny katalog ftp jest domyślnie umieszczany w [.filename]#/var#. Jeżeli nie mamy tam wystarczająco dużo miejsca dla przewidywanych potrzeb FTP, możemy wybrać w zamian katalog [.filename]#/usr#, jako główny katalog FTP (FTP Root Directory) wpisując [.filename]#/usr/ftp#.

Po wybraniu odpowiadających nam ustawień naciskamy kbd:[Enter].

[source,bash]
....
                          User Confirmation Requested
         Create a welcome message file for anonymous FTP users?

                              [ Yes ]    No
....

Jeżeli wybierzemy btn:[yes] i wciśniemy kbd:[Enter], automatycznie zostanie uruchomiony edytor, w którym będziemy mogli napisać komunikat powitalny dla użytkowników anonimowego FTP.

[[anon-ftp4]]
.Edycja komunikatu powitalnego FTP
image::ftp-anon2.png[]

Używanym tutaj edytorem tekstu jest `ee`. Postępując zgodnie z przedstawionymi na ekranie wskazówkami możemy wprowadzić treść komunikatu, lub też możemy zrobić to później, korzystając z dowolnego edytora. W tym celu warto jest zapisać nazwę i lokalizację pliku pokazywaną na dole ekranu.

Gdy naciśniemy kbd:[Esc] pokazane zostanie menu z domyślnie zaznaczoną opcją [.guimenuitem]#a) leave editor#. (opuszczenie edytora). Wybieramy ją naciskając kbd:[Enter]. Ponowne naciśnięcie kbd:[Enter] spowoduje zapisanie zmian jeśli jakichś dokonaliśmy.

[[nfsconf]]
=== Konfiguracja sieciowych usług plikowych

Sieciowe usługi plikowe (Network File Services - NFS) pozwalają na współdzielony dostęp do plików przez sieć. Komputer możemy skonfigurować jako serwer, klient, lub oba naraz. Więcej informacji na ten temat można znaleźć w crossref:network-servers[network-nfs,Network File System (NFS)].

[[nsf-server-options]]
==== Serwer NFS

[source,bash]
....
                       User Confirmation Requested
 Do you want to configure this machine as an NFS server?

                              Yes    [ No ]
....

Jeśli nie zamierzamy korzystać z serwera NFS, wybieramy btn:[no] i wciskamy kbd:[Enter].

W przeciwnym wypadku, gdy wybierzemy btn:[yes], zostanie pokazany komunikat o konieczności stworzenia pliku [.filename]#exports#.

[source,bash]
....
                               Message
Operating as an NFS server means that you must first configure an
/etc/exports file to indicate which hosts are allowed certain kinds of
access to your local filesystems.
Press [Enter] now to invoke an editor on /etc/exports
                               [ OK ]
....

Naciskamy kbd:[Enter]. Zostanie uruchomiony edytor tekstu, w którym będziemy mogli przygotować plik [.filename]#exports#.

[[nfs-server-edit]]
.Edycja pliku [.filename]#exports#
image::nfs-server-edit.png[]

Zgodnie ze wskazówkami dopisujemy udostępniane systemy plików. Możemy także zrobić to później, korzystając z preferowanego przez nas edytora tekstu. W tym celu warto zapisać sobie pokazywaną na dole ekranu nazwę i lokalizację pliku.

Gdy naciśniemy kbd:[Esc], pokazane zostanie menu z domyślnie zaznaczoną opcją [.guimenuitem]#a) leave editor# (opuszczenie edytora). Wybieramy ją naciskając kbd:[Enter].

[[nfs-client-options]]
==== Klient NFS

Instalacja klienta NFS pozwoli naszemu komputerowi łączyć się z serwerami NFS.

[source,bash]
....
                       User Confirmation Requested
 Do you want to configure this machine as an NFS client?

                              Yes   [ No ]
....

Wybieramy klawiszami kursora btn:[yes] lub btn:[no] zależenie od podjętej decyzji, po czym naciskamy kbd:[Enter].

[[securityprofile]]
=== Profil zabezpieczeń

"Profil zabezpieczeń" to zestaw opcji konfiguracyjnych, mający zapewnić określony poziom bezpieczeństwa poprzez włączenie i wyłączenie pewnych programów i ustawień. Im surowszy profil zabezpieczeń, tym mniej programów będzie domyślnie uruchamianych. Odpowiada to jednej z podstawowych zasad bezpieczeństwa: należy wyłączać wszystko, co nie musi być włączone.

Pamiętajmy, że profil zabezpieczeń to tylko domyślne ustawienia. Poszczególne programy można włączać i wyłączać już po zainstalowaniu FreeBSD, poprzez modyfikację lub dodanie odpowiednich wpisów w pliku [.filename]#/etc/rc.conf#. Dalsze informacje na ten temat znaleźć można w dokumentacji systemowej man:rc.conf[5].

Poniższa tabela pokazuje, jaki jest efekt stosowania każdego z profili zabezpieczeń. Kolumny odpowiadają profilom, które można wybrać, natomiast w kolejnych wierszach wymienione są poszczególne programy lub funkcje włączone lub wyłączone w danym profilu.

.Dostępne profile zabezpieczeń
[cols="1,1,1", options="header"]
|===
| 
| Extreme
| Medium

|man:sendmail[8]
|NIE
|TAK

|man:sshd[8]
|NIE
|TAK

|man:portmap[8]
|NIE
|MOŻE (Portmapper jest włączony, jeśli na wcześniejszym etapie instalacji komputer został skonfigurowany jako klient lub serwer NFS.) 

|serwer NFS
|NIE
|TAK

|man:securelevel[8]
|TAK (Wybierając profil zabezpieczeń, który powoduje ustawienie securelevel na "Extreme" lub "High", powinniśmy pamiętać o konsekwencjach. Warto przeczytać dokumentację systemową man:init[8] i zwrócić szczególną uwagę na znaczenie poziomów bezpieczeństwa, by uniknąć późniejszych kłopotów!) 
|NIE
|===

[source,bash]
....
                       User Confirmation Requested
 Do you want to select a default security profile for this host (select
 No for "medium" security)?

                            [ Yes ]    No
....

Jeżeli wybierzemy btn:[no] i naciśniemy kbd:[Enter], zostanie ustawiony średni profil zabezpieczeń.

Chcąc wybrać inny profil zabezpieczeń, wybieramy btn:[yes] i wciskamy kbd:[Enter].

[[security-profile]]
.Opcje profilu zabezpieczeń
image::security.png[]

Aby uzyskać pomoc, wciskamy kbd:[F1]. Naciskając kbd:[Enter] wracamy do menu.

Klawiszami kursora wybieramy [.guimenuitem]#Medium#, chyba, że jesteśmy pewni, że będziemy potrzebować innego poziomu bezpieczeństwa. Wskazujemy następnie btn:[OK] i wciskamy kbd:[Enter].

Zostanie wyświetlony komunikat potwierdzający wybór profilu zabezpieczeń.

[source,bash]
....
                                 Message

Moderate security settings have been selected.

Sendmail and SSHd have been enabled, securelevels are
disabled, and NFS server setting have been left intact.
PLEASE NIETE that this still does not save you from having
to properly secure your system in other ways or exercise
due diligence in your administration, this simply picks
a standard set of out-of-box defaults to start with.

To change any of these settings later, edit /etc/rc.conf

                                  [OK]
....

[source,bash]
....
                                 Message

Extreme security settings have been selected.

Sendmail, SSHd, and NFS services have been disabled, and
securelevels have been enabled.
PLEASE NIETE that this still does not save you from having
to properly secure your system in other ways or exercise
due diligence in your administration, this simply picks
a more secure set of out-of-box defaults to start with.

To change any of these settings later, edit /etc/rc.conf

                                  [OK]
....

Naciskamy kbd:[Enter], aby przejść do kolejnego etapu konfiguracji.

[WARNING]
====

Profil zabezpieczeń nie jest cudownym lekarstwem! Nawet, jeśli wybraliśmy najbardziej bezpieczny profil, musimy na bieżąco interesować się sprawami bezpieczeństwa systemu, czytając poświęcone im listy dyskusyjne (crossref:eresources[eresources-mail,Mailing Lists]),, stosując dobre hasła i przestrzegając ogólnych zasad bezpieczeństwa. Profil jest tylko wygodnym sposobem na przygotowanie podstawowych zabezpieczeń.
====

[[console]]
=== Ustawienia konsoli systemowej

Kilka opcji służy do konfiguracji konsoli systemowej.

[source,bash]
....
                      User Confirmation Requested
       Would you like to customize your system console settings?

                              [ Yes ]  No
....

Aby zobaczyć i zmienić ustawienia, wybieramy btn:[yes] i wciskamy kbd:[Enter].

[[saver-options]]
.Opcje konfiguracji konsoli systemowej
image::console-saver1.png[]

Często stosowaną opcją jest wygaszacz ekranu (screen saver). Klawiszami kursora wybieramy [.guimenuitem]#Saver# i naciskamy kbd:[Enter].

[[saver-select]]
.Opcje wygaszacza ekranu
image::console-saver2.png[]

Za pomocą klawiszy kursora wybieramy odpowiadający nam wygaszacz i wciskamy kbd:[Enter]. Ponownie pojawi się menu konfiguracji konsoli systemowej.

Przyjmowany domyślnie przedział czasu wynosi 300 sekund. Aby go zmienić, ponownie wybieramy [.guimenuitem]#Saver#. W menu opcji wygaszacza ekranu klawiszami kursora wybieramy [.guimenuitem]#Timeout# i naciskamy kbd:[Enter]. Pojawi się okienko:

[[saver-timeout]]
.Limit czasu wygaszacza ekranu
image::console-saver3.png[]

Wartość możemy zmienić, po czym wybieramy btn:[OK] i wciskamy kbd:[Enter], by wrócić do menu konfiguracji konsoli.

[[saver-exit]]
.Zakończenie konfiguracji konsoli
image::console-saver4.png[]

Wybieramy [.guimenuitem]#Exit# i naciskamy kbd:[Enter], przechodząc do kolejnego etapu konfiguracji.

[[timezone]]
=== Ustawienia strefy czasowej

Dzięki ustawieniu strefy czasowej komputer będzie mógł automatycznie ustawiać zegar w przypadku zmiany czasu, jak również będzie prawidłowo wykonywać inne czynności związane ze strefą czasową.

W przykładzie mamy do czynienia z komputerem znajdującym się we wschodniej strefie czasowej Stanów Zjednoczonych. Rzeczywiste ustawienia będą zależeć od naszego położenia geograficznego.

[source,bash]
....
                      User Confirmation Requested
          Would you like to set this machine's time zone now?

                            [ Yes ]   No
....

By ustawić strefę czasową, wybieramy btn:[yes] i naciskamy kbd:[Enter].

[source,bash]
....
                       User Confirmation Requested
 Is this machine's CMOS clock set to UTC? If it is set to local time
 or you don't know, please choose NIE here!

                              Yes   [ No ]
....

Wybieramy btn:[yes] lub btn:[no], w zależności od ustawienia zegara komputera, następnie wciskamy kbd:[Enter].

[[set-timezone-region]]
.Wybór regionu geograficznego
image::timezone1.png[]

Klawiszami kursora wybieramy odpowiedni region, po czym naciskamy kbd:[Enter].

[[set-timezone-country]]
.Wybór kraju
image::timezone2.png[]

Przy użyciu klawiszy kursora wybieramy odpowiedni kraj i naciskamy kbd:[Enter].

[[set-timezone-locality]]
.Wybór strefy czasowej
image::timezone3.png[]

Klawiszami kursora wybieramy właściwą strefę czasową i wciskamy kbd:[Enter].

[source,bash]
....
                            Confirmation
            Does the abbreviation 'EDT' look reasonable?

                            [ Yes ]   No
....

Zostaniemy zapytani, czy skrót nazwy strefy czasowej jest prawidłowy. Jeśli tak, naciskamy kbd:[Enter] i przechodzimy do kolejnego etapu konfiguracji.

[[linuxcomp]]
=== Kompatybilność z Linuksem

[source,bash]
....
                      User Confirmation Requested
          Would you like to enable Linux binary compatibility?

                            [ Yes ]   No
....

Wybranie btn:[yes] i naciśnięcie kbd:[Enter] pozwoli uruchamiać programy linuksowe we FreeBSD. Program instalacyjny dołączy pakiety obsługujące kompatybilność z Linuksem.

Jeśli instalujemy system przez FTP, komputer będzie potrzebować łączności z Internetem. Może się zdarzyć, że na serwerze ftp będzie brakowało pewnych składników, na przykład obsługujących kompatybilność z Linuksem. Można je jednak zainstalować później.

[[mouse]]
=== Ustawienia myszki

Posługując się 3-przyciskową myszką będziemy mogli wycinać i wklejać tekst na konsoli i w uruchamianych programach. Jeśli nasza myszka ma dwa przyciski, po instalacji zajrzyjmy do dokumentacji systemowej man:moused[8], gdzie opisana została emulacja trzech przycisków. W naszym przykładzie konfigurujemy myszkę nie podłączoną przez USB (np. przez złącze PS/2 lub port COM)::

[source,bash]
....
                      User Confirmation Requested
         Does this system have a non-USB mouse attached to it?

                            [ Yes ]    No 
....

Wybieramy btn:[no], jeśli myszka podłączona jest przez USB, lub btn:[yes] w przeciwnym wypadku i naciskamy kbd:[Enter].

[[mouse-protocol]]
.Opcja wyboru protokołu myszki
image::mouse1.png[]

Klawiszami kursora wskazujemy [.guimenuitem]#Type# i naciskamy kbd:[Enter].

[[set-mouse-protocol]]
.Wybór protokołu myszki
image::mouse2.png[]

Myszka używana w przykładzie jest typu PS/2, wybrano więc domyślną opcję [.guimenuitem]#Auto#. Inny protokół wybieramy wskazując odpowiednią opcję klawiszami kursora. Upewniwszy się, że btn:[OK] jest zaznaczone, naciskamy kbd:[Enter] i wracamy do poprzedniego menu.

[[config-mouse-port]]
.Konfiguracja portu myszki
image::mouse3.png[]

Za pomocą klawiszy kursora wybieramy [.guimenuitem]#Port# i wciskamy kbd:[Enter].

[[set-mouse-port]]
.Wybór portu myszki
image::mouse4.png[]

Ponieważ przykładowa myszka jest typu PS/2, zaznaczona została domyślna opcja [.guimenuitem]#PS/2#. Klawiszami kursora możemy wybrać port, następnie naciskamy kbd:[Enter].

[[test-daemon]]
.Włączenie demona myszki
image::mouse5.png[]

Na koniec wybieramy [.guimenuitem]#Enable# i naciskamy kbd:[Enter] by włączyć demona myszki i go przetestować.

[[test-mouse-daemon]]
.Testowanie demona myszki
image::mouse6.png[]

Następnie musimy poruszyć myszką i sprawdzić czy kursor porusza się we właściwy sposób po ekranie. Jeśli tak to wybieramy btn:[yes] i wciskamy kbd:[Enter]. Jeśli nie myszka nie została właściwie skonfigurowana - wybieramy btn:[no] i próbujemy innych ustawień myszy.

Wybieramy [.guimenuitem]#Exit# i wciskamy kbd:[Enter], by zakończyć ten etap konfiguracji.

[[network-services]]
=== Konfiguracja dodatkowych usług sieciowych

Konfiguracja usług sieciowych może być nużącym zadaniem dla początkujących użytkowników, szczególnie jeśli brak im wiedzy w tym zakresie. Możliwość pracy w sieci - także w Internecie - jest kluczowym elementem wszystkich współczesnych systemów operacyjnych, w tym również FreeBSD. Stąd też jest bardzo pomocnym mieć pojęcie o możliwościach pracy w sieci jakie oferuje FreeBSD. Poznanie tych jego możliwości już w trakcie instalacji pozwoli użytkownikom zrozumieć różne aspekty funkcjonowania usług sieciowych.

Usługi sieciowe są programami potrafiącymi przyjmować dane z dowolnej lokalizacji w sieci. Dlatego właśnie dokładanych jest wiele starań, by zagwarantować, że programy te nie uczynią nic "szkodliwego". Niestety, programiści nie są doskonali. W przeszłości zdarzały się sytuacje, w których atakujący wykorzystywali błędy w oprogramowaniu by wyrządzić szkodę systemowi. Stąd też jest bardzo istotnym by włączać tylko te usługi sieciowe, które są nam potrzebne. Jeśli nie jesteśmy pewni, najlepiej jest nie włączać danej usługi nim nie dowiemy się czy rzeczywiście jej potrzebujemy. Zawsze możemy ją aktywować później uruchamiając ponownie sysinstall bądź edytując plik [.filename]#/etc/rc.conf#.

Wybranie opcji menu:Networking[] spowoduje wyświetlenie menu zbliżonego do poniższego:

[[network-configuration]]
.Najwyższy poziom konfiguracji sieci
image::net-config-menu1.png[]

Pierwszą z dostępnych opcji - [.guimenuitem]#Interfaces# - opisuje bliżej <<inst-network-dev>>, dlatego też możemy ją teraz pominąć.

Wybór opcji [.guimenuitem]#AMD# włączy wsparcie dla narzędzia automatycznego montowania BSD (ang. Automatic Mount Utility). Opcja ta najczęściej jest wykorzystywana z protokołem NFS (patrz poniżej) do automatycznego montowania zdalnych systemów plików. Nie wymaga dodatkowej konfiguracji.

Kolejną opcją jest [.guimenuitem]#AMD Flags#. Po jej wybraniu pojawi się menu, gdzie należy wprowadzić specyficzne flagi AMD. Menu zawiera już domyślne wartości:

[source,bash]
....
-a /.amd_mnt -l syslog /host /etc/amd.map /net /etc/amd.map
....

Flaga `-a` określa domyślny punkt montowania, w tym wypadku [.filename]#/.amd_mnt#. Flaga `-l` definiuje domyślny plik [.filename]#log# dziennika systemowego; jeśli w systemie wykorzystywany jest demon `syslogd`, wówczas wszystkie komunikaty będą wysyłane właśnie do niego. Katalog [.filename]#/host# jest wykorzystywany do montowania systemów plików wyeksportowanych ze zdalnej maszyny, podczas gdy katalog [.filename]#/net# do montowania systemów plików z adresu IP. Plik [.filename]#/etc/amd.map# zawiera domyślne wartości flag dla zasobów eksportowanych przez AMD.

Wybór opcji [.guimenuitem]#Anon FTP# zezwala na anonimowe połączenia FTP, tym samym tworząc z naszego komputera anonimowy serwer FTP. Należy mieć jednak świadomość niebezpieczeństw jakie pociąga za sobą taka konfiguracja. Po wybraniu tej opcji pojawi się kolejne okienko wyjaśniające związane z nią niebezpieczeństwa oraz umożliwiające szczegółową konfigurację.

Menu [.guimenuitem]#Gateway# pozwala skonfigurować naszą maszynę jako bramę, co zostało opisane wcześniej. Może być również wykorzystane do wyłączenia tej opcji jeśli przypadkowo została ona aktywowana w trakcie instalacji.

Opcja [.guimenuitem]#Inetd# pozwala skonfigurować bądź całkowicie wyłączyć demonona man:inetd[8], który również został opisany wcześniej.

Opcja [.guimenuitem]#Mail# wykorzystywana jest do konfiguracji domyślnego systemowego serwera poczty MTA (ang. Mail Transfer Agent). Wybór tej opcji spowoduje wyświetlenie następującego menu:

[[mta-selection]]
.Wybór domyślnego MTA
image::mta-main.png[]

W menu tym mamy możliwość wyboru, który MTA zostanie zainstalowany jako domyślny. W praktyce MTA nie jest niczym więcej jak serwerem, który dostarcza pocztę elektroniczną do użytkowników lokalnego systemu bądź wysyła ją do Internetu.

Wybór opcji [.guimenuitem]#Sendmail# spowoduje instalację popularnego serwera sendmail. Serwer ten jest domyślnym serwerem we FreeBSD. Opcja [.guimenuitem]#Sendmail local# również spowoduje wybór sendmail jako domyślnego MTA, jednakże bez możliwości odbierania poczty przychodzącej z Internetu. Pozostałe opcje [.guimenuitem]#Postfix# i [.guimenuitem]#Exim# dają efekt analogiczny do [.guimenuitem]#Sendmail# - obydwa rozwiązania dostarczają pocztę. Tym nie mniej, niektórzy użytkownicy preferują te serwery jako alternatywę dla MTAsendmail.

Po wybraniu MTA, bądź pominięciu tego kroku, pojawi się ponownie okno konfiguracji sieci z kolejną opcją: [.guimenuitem]#NFS client#.

Opcja [.guimenuitem]#NFS client# pozwala skonfigurować system do komunikacji z serwerem za pomocą NFS. Serwer NFS udostępnia systemy plików innym maszynom w sieci za pomocą protokołu NFS. Jeśli nasza maszyna nie będzie pracowała w sieci można tą opcję pominąć. System może później wymagać dalszej konfiguracji. crossref:network-servers[network-nfs,Network File System (NFS)] zawiera szczegółowe informacje o konfiguracji klienta i serwera NFS.

Poniżej znajduje się opcja [.guimenuitem]#NFS server# umożliwiająca skonfigurowanie systemu jako serwer NFS. Dodatkowo konfiguruje ona wymagane parametry dla usług RPC. RPC koordynuje połączenia pomiędzy maszynami i programami.

Kolejna opcja to [.guimenuitem]#Ntpdate#, odpowiadająca za synchronizację czasu systemowego. Po wybraniu jej pojawi się następujące menu:

[[Ntpdate-config]]
.Konfiguracja ntpdate
image::ntp-config.png[]

Z menu wybieramy najbliższy nam serwer. Wybór pobliskiego serwera gwarantuje dokładniejszą synchronizację czasu, z uwagi na fakt, że w komunikacji z bardziej oddalony serwerem mogą występować większe opóźnienia.

Kolejnym elementem jest wybór PCNFSD. Opcja ta zainstaluje package:net/pcnfsd[] z Kolekcji portów. Jest to przydatne narzędzie umożliwiające uwierzytelnianie NFS systemom operacyjnym, które same nie potrafią się uwierzytelnić, jak np. MS-DOS(R).

Przewijając w dół pojawią się kolejne opcje:

[[Network-configuration-cont]]
.Najniższy poziom konfiguracji sieci
image::net-config-menu2.png[]

Programy man:rpcbind[8], man:rpc.statd[8] i man:rpc.lockd[8] wykorzystywane są przy połączeniach RPC (Remote Procedure Call). `rpcbind` zarządza komunikacją pomiędzy serwerem NFS i klientami, tym samym jest wymagany do poprawnego funkcjonowania serwera NFS. Demon rpc.statd wykorzystywany jest do komunikacji z innymi demonami rpc.statd w sieci, w celu monitorowania stanu maszyn, na których one pracują. Uzyskane w ten sposób informacje przechowywane są z reguły w pliku [.filename]#/var/db/statd.status#. Kolejnym elementem jest [.guimenuitem]#rpc.lockd#, który udostępnia usługi blokowania plików. Z reguły, wykorzystywany jest w parze z rpc.statd do śledzenia, które maszyny wymagają blokowania i jak często. O ile dwie ostatnie usługi są idealne do debugowania, nie są one wymagane do poprawnego działania serwera NFS.

Kolejnym elementem na liście jest demon rutowania - [.guimenuitem]#Routed#. man:routed[8] zarządza tablicami rutingu sieci, wyszukuje rutery multicast i udostępnia na żądanie kopię tablic rutingu każdej maszynie w sieci. Wykorzystywany jest on z reguły na komputerach pracujących jako bramy dla sieci lokalnej. Po jego wybraniu pojawi się dodatkowe menu, w którym należy określić jego domyślną lokalizację. Wartość domyślna jest zdefiniowana i zostanie wybrana po naciśnięciu klawisza kbd:[Enter]. Następnie pojawi się kolejne menu, tym razem w celu ustawienia flag. Domyślną jest `-q` i powinna pojawić się na ekranie.

Kolejną opcją jest [.guimenuitem]#Rwhod#, której wybór włączy demona man:rwhod[8] w trakcie uruchamiania systemu. `rwhod` jest narzędziem, które regularnie rozsyła w sieci komunikaty systemowe bądź - w trybie "konsumenta" - zbiera je. Więcej informacji dostępnych jest w podręcznikach systemowych man:ruptime[1] i man:rwho[1].

Przedostatnim elementem na liście jest demon man:sshd[8]. Jest to serwer OpenSSH, którego wykorzystanie jest zalecane w zamiast telnetu czy serwerów FTP. Serwer sshd jest wykorzystywany do zestawiania bezpiecznego połączenia pomiędzy dwoma maszynami wykorzystując połączenia szyfrowane.

Ostatnią na liście jest opcja Rozszerzeń TCP ([.guimenuitem]#TCP Extensions#). Włączenie jej umożliwia korzystanie z rozszerzeń TCP zdefiniowanych w RFC 1323 i RFC 1644. O ile na wielu komputerach pozwoli to na przyspieszenie komunikacji, o tyle może również spowodować odrzucanie niektórych połączeń. Stosowanie tej opcji nie jest zalecane dla serwerów, chodź może się okazać korzystne dla stacji roboczych.

Skończywszy konfigurację usług sieciowych możemy przewinąć do samej góry ekranu, do opcji [.guimenuitem]#Exit# i przejść do kolejnej części konfiguracji.

[[x-server]]
=== Konfiguracja serwera X

[NOTE]
====
Począwszy od wersji FreeBSD 5.3-RELEASE, opcje konfiguracji serwera X zostały usunięte z sysinstall. Serwer X musimy zainstalować i skonfigurować po skończonej instalacji systemu. crossref:x11[x11,System okien X] zawiera szczegółowe informacje odnośnie instalacji i konfiguracji serwera X. Jeśli nie instalujemy wersji wcześniejszej niż FreeBSD 5.3-RELEASE, możemy pomiąć tą sekcję.
====

Chcąc korzystać z graficznego interfejsu użytkownika w rodzaju KDE, GNIEME lub innego, trzeba skonfigurować serwer X.

[NOTE]
====
By uruchomić XFree86(TM) z poziomu użytkownika innego niż `root`, należy zainstalować package:x11/wrapper[]. Jest on instalowany domyślnie we FreeBSD 4.7 i późniejszych. W przypadku wcześniejszych wersji można go zainstalować z menu wyboru pakietów.
====

Aby sprawdzić, czy nasza karta graficzna jest obsługiwana, możemy zajrzeć na stronę WWW http://www.xfree86.org/[XFree86(TM)].

[source,bash]
....
                      User Confirmation Requested
        Would you like to configure your X server at this time?

                            [ Yes ]   No
....

[WARNING]
====

Należy koniecznie znać dane techniczne monitora i karty graficznej. Nieprawidłowe ustawienia mogą spowodować uszkodzenie sprzętu. Jeśli nie dysponujemy tymi danymi, wybierzmy btn:[no] i przystąpmy do konfiguracji serwera X po zainstalowaniu systemu, gdy już zaopatrzymy się w niezbędne dane. Do tego celu możemy wykorzystać `sysinstall` (`/stand/sysinstall` we FreeBSD starszych niż 5.2), wybierając [.guimenuitem]#Configure#, a następnie [.guimenuitem]#XFree86#. 
====

Jeśli mamy dane techniczne karty graficznej i monitora, wybieramy btn:[yes] i wciskamy kbd:[Enter], rozpoczynając konfigurację serwera X.

[[xserver2]]
.Wybór metody konfiguracji
image::xf86setup.png[]

Serwer X można konfigurować na kilka sposobów. Wybieramy jedną z metod przy pomocy klawiszy kursora i naciskamy kbd:[Enter]. Pamiętajmy o uważnym czytaniu wszelkich poleceń pojawiających się na ekranie.

Wybór xf86cfg i xf86cfg -textmode może spowodować, że ekran stanie się ciemny, a uruchomienie może zająć kilka sekund. Bądźmy cierpliwi.

W poniższym przykładzie przedstawione będzie korzystanie z programu konfiguracyjnego xf86config. Wybierane przez nas opcje zależeć będą od wyposażenia naszego komputera, będą się więc zapewne różnić od opcji pokazanych w przykładzie:

[source,bash]
....
                                Message
 You have configured and been running the mouse daemon.
 Choose "/dev/sysmouse" as the mouse port and "SysMouse" or
 "MouseSystems" as the mouse protocol in the X configuration utility.

                                 [ OK ]

                      [ Press enter to continue ]
....

Komunikat ten informuje o wykryciu skonfigurowanego wcześniej demona myszki. Naciskamy kbd:[Enter], by przejść dalej.

Po uruchomieniu, xf86config wyświetli krótkie wprowadzenie:

[source,bash]
....
This program will create a basic XF86Config file, based on menu selections you
make.

The XF86Config file usually resides in /usr/X11R6/etc/X11 or /etc/X11. A sample
XF86Config file is supplied with XFree86; it is configured for a standard
VGA card and monitor with 640x480 resolution. This program will ask for a
pathname when it is ready to write the file.

You can either take the sample XF86Config as a base and edit it for your
configuration, or let this program produce a base XF86Config file for your
configuration and fine-tune it.

Before continuing with this program, make sure you know what video card
you have, and preferably also the chipset it uses and the amount of video
memory on your video card. SuperProbe may be able to help with this.

Press enter to continue, or ctrl-c to abort.
....

Po naciśnięciu kbd:[Enter] przejdziemy do konfiguracji myszki. Pamiętajmy, by uważnie czytać polecenia i wybrać właściwy protokół myszki "Mouse Systems" i port myszki [.filename]#/dev/sysmouse#, nawet jeśli w przykładzie wybierana jest myszka PS/2.

[source,bash]
....
First specify a mouse protocol type. Choose one from the following list:

 1.  Microsoft compatible (2-button protocol)
 2.  Mouse Systems (3-button protocol) & FreeBSD moused protocol
 3.  Bus Mouse
 4.  PS/2 Mouse
 5.  Logitech Mouse (serial, old type, Logitech protocol)
 6.  Logitech MouseMan (Microsoft compatible)
 7.  MM Series
 8.  MM HitTablet
 9.  Microsoft IntelliMouse

If you have a two-button mouse, it is most likely of type 1, and if you have
a three-button mouse, it can probably support both protocol 1 and 2. There are
two main varieties of the latter type: mice with a switch to select the
protocol, and mice that default to 1 and require a button to be held at
boot-time to select protocol 2. Some mice can be convinced to do 2 by sending
a special sequence to the serial port (see the ClearDTR/ClearRTS options).

Enter a protocol number: 2

You have selected a Mouse Systems protocol mouse. If your mouse is normally
in Microsoft-compatible mode, enabling the ClearDTR and ClearRTS options
may cause it to switch to Mouse Systems mode when the server starts.

Please answer the following question with either 'y' or 'n'.
Do you want to enable ClearDTR and ClearRTS? n

You have selected a three-button mouse protocol. It is recommended that you
do not enable Emulate3Buttons, unless the third button doesn't work.

Please answer the following question with either 'y' or 'n'.
Do you want to enable Emulate3Buttons? y

Now give the full device name that the mouse is connected to, for example
/dev/tty00. Just pressing enter will use the default, /dev/mouse.
On FreeBSD, the default is /dev/sysmouse.

Mouse device: /dev/sysmouse
....

Kolejnym krokiem jest konfiguracja klawiatury. W przykładzie wybrana została typowa klawiatura o 101 klawiszach. Jako wariant nazwy możemy wybrać dowolną nazwę, lub po prostu nacisnąć kbd:[Enter], akceptując proponowaną nazwę domyślną.

[source,bash]
....
Please select one of the following keyboard types that is the better
description of your keyboard. If nothing really matches,
choose 1 (Generic 101-key PC)

  1  Generic 101-key PC
  2  Generic 102-key (Intl) PC
  3  Generic 104-key PC
  4  Generic 105-key (Intl) PC
  5  Dell 101-key PC
  6  Everex STEPnote
  7  Keytronic FlexPro
  8  Microsoft Natural
  9  Northgate OmniKey 101
 10  Winbook Model XP5
 11  Japanese 106-key
 12  PC-98xx Series
 13  Brazilian ABNT2
 14  HP Internet
 15  Logitech iTouch
 16  Logitech Cordless Desktop Pro
 17  Logitech Internet Keyboard
 18  Logitech Internet Navigator Keyboard
 19  Compaq Internet
 20  Microsoft Natural Pro
 21  Genius Comfy KB-16M
 22  IBM Rapid Access
 23  IBM Rapid Access II
 24  Chicony Internet Keyboard
 25  Dell Internet Keyboard

Enter a number to choose the keyboard.

1

Please select the layout corresponding to your keyboard

  1  U.S. English
  2  U.S. English w/ ISO9995-3
  3  U.S. English w/ deadkeys
  4  Albanian
  5  Arabic
  6  Armenian
  7  Azerbaidjani
  8  Belarusian
  9  Belgian
 10  Bengali
 11  Brazilian
 12  Bulgarian
 13  Burmese
 14  Canadian
 15  Croatian
 16  Czech
 17  Czech (qwerty)
 18  Danish

Enter a number to choose the country.
Press enter for the next page

1

Please enter a variant name for 'us' layout. Or just press enter
for default variant

us

Please answer the following question with either 'y' or 'n'.
Do you want to select additional XKB options (group switcher,
group indicator, etc.)? n
....

Następnie przystępujemy do konfiguracji monitora. Pamiętajmy, by nie przekroczyć dopuszczalnych wartości częstotliwości, ponieważ może to spowodować uszkodzenie monitora. W razie jakichkolwiek wątpliwości, odłóżmy konfigurację monitora do czasu, gdy będziemy już mieć niezbędne informacje.

[source,bash]
....
Now we want to set the specifications of the monitor. The two critical
parameters are the vertical refresh rate, which is the rate at which the
whole screen is refreshed, and most importantly the horizontal sync rate,
which is the rate at which scanlines are displayed.

The valid range for horizontal sync and vertical sync should be documented
in the manual of your monitor. If in doubt, check the monitor database
/usr/X11R6/lib/X11/doc/Monitors to see if your monitor is there.

Press enter to continue, or ctrl-c to abort.

You must indicate the horizontal sync range of your monitor. You can either
select one of the predefined ranges below that correspond to industry-
standard monitor types, or give a specific range.

It is VERY IMPORTANT that you do not specify a monitor type with a horizontal
sync range that is beyond the capabilities of your monitor. If in doubt,
choose a conservative setting.

    hsync in kHz; monitor type with characteristic modes
 1  31.5; Standard VGA, 640x480 @ 60 Hz
 2  31.5 - 35.1; Super VGA, 800x600 @ 56 Hz
 3  31.5, 35.5; 8514 Compatible, 1024x768 @ 87 Hz interlaced (no 800x600)
 4  31.5, 35.15, 35.5; Super VGA, 1024x768 @ 87 Hz interlaced, 800x600 @ 56 Hz
 5  31.5 - 37.9; Extended Super VGA, 800x600 @ 60 Hz, 640x480 @ 72 Hz
 6  31.5 - 48.5; Non-Interlaced SVGA, 1024x768 @ 60 Hz, 800x600 @ 72 Hz
 7  31.5 - 57.0; High Frequency SVGA, 1024x768 @ 70 Hz
 8  31.5 - 64.3; Monitor that can do 1280x1024 @ 60 Hz
 9  31.5 - 79.0; Monitor that can do 1280x1024 @ 74 Hz
10  31.5 - 82.0; Monitor that can do 1280x1024 @ 76 Hz
11  Enter your own horizontal sync range

Enter your choice (1-11): 6

You must indicate the vertical sync range of your monitor. You can either
select one of the predefined ranges below that correspond to industry-
standard monitor types, or give a specific range. For interlaced modes,
the number that counts is the high one (e.g. 87 Hz rather than 43 Hz).

 1  50-70
 2  50-90
 3  50-100
 4  40-150
 5  Enter your own vertical sync range

Enter your choice: 2

You must now enter a few identification/description strings, namely an
identifier, a vendor name, and a model name. Just pressing enter will fill
in default names.

The strings are free-form, spaces are allowed.
Enter an identifier for your monitor definition: Hitachi
....

W kolejnym etapie wybieramy z listy sterownik karty graficznej. Jeśli przewijając listę niechcący ominiemy naszą kartę, naciskajmy dalej kbd:[Enter], a lista zostanie powtórzona. W przykładzie pokazujemy tylko fragment listy:

[source,bash]
....
Now we must configure video card specific settings. At this point you can
choose to make a selection out of a database of video card definitions.
Because there can be variation in Ramdacs and clock generators even
between cards of the same model, it is not sensible to blindly copy
the settings (e.g. a Device section). For this reason, after you make a
selection, you will still be asked about the components of the card, with
the settings from the chosen database entry presented as a strong hint.

The database entries include information about the chipset, what driver to
run, the Ramdac and ClockChip, and comments that will be included in the
Device section. However, a lot of definitions only hint about what driver
to run (based on the chipset the card uses) and are untested.

If you can't find your card in the database, there's nothing to worry about.
You should only choose a database entry that is exactly the same model as
your card; choosing one that looks similar is just a bad idea (e.g. a
GemStone Snail 64 may be as different from a GemStone Snail 64+ in terms of
hardware as can be).

Do you want to look at the card database? y

288  Matrox Millennium G200 8MB                        mgag200
289  Matrox Millennium G200 SD 16MB                    mgag200
290  Matrox Millennium G200 SD 4MB                     mgag200
291  Matrox Millennium G200 SD 8MB                     mgag200
292  Matrox Millennium G400                            mgag400
293  Matrox Millennium II 16MB                         mga2164w
294  Matrox Millennium II 4MB                          mga2164w
295  Matrox Millennium II 8MB                          mga2164w
296  Matrox Mystique                                   mga1064sg
297  Matrox Mystique G200 16MB                         mgag200
298  Matrox Mystique G200 4MB                          mgag200
299  Matrox Mystique G200 8MB                          mgag200
300  Matrox Productiva G100 4MB                        mgag100
301  Matrox Productiva G100 8MB                        mgag100
302  MediaGX                                           mediagx
303  MediaVision Proaxcel 128                          ET6000
304  Mirage Z-128                                      ET6000
305  Miro CRYSTAL VRX                                  Verite 1000

Enter a number to choose the corresponding card definition.
Press enter for the next page, q to continue configuration.

288

Your selected card definition:

Identifier: Matrox Millennium G200 8MB
Chipset:    mgag200
Driver:     mga
Do NIET probe clocks or use any Clocks line.

Press enter to continue, or ctrl-c to abort.

Now you must give information about your video card. This will be used for
the "Device" section of your video card in XF86Config.

You must indicate how much video memory you have. It is probably a good
idea to use the same approximate amount as that detected by the server you
intend to use. If you encounter problems that are due to the used server
not supporting the amount memory you have (e.g. ATI Mach64 is limited to
1024K with the SVGA server), specify the maximum amount supported by the
server.

How much video memory do you have on your video card:

 1  256K
 2  512K
 3  1024K
 4  2048K
 5  4096K
 6  Other

Enter your choice: 6

Amount of video memory in Kbytes: 8192

You must now enter a few identification/description strings, namely an
identifier, a vendor name, and a model name. Just pressing enter will fill
in default names (possibly from a card definition).

Your card definition is Matrox Millennium G200 8MB.

The strings are free-form, spaces are allowed.
Enter an identifier for your video card definition:
....

Następnie wybieramy tryby graficzne dla preferowanych rozdzielczości. Najczęściej używane są tryby 640x480, 800x600 i 1024x768, wybór zależy jednak od możliwości karty graficznej, rozmiarów monitora i oczekiwanej wygody pracy. Gdy będziemy wybierać głębię koloru, wybierzmy najwyższą wartość, którą obsługuje karta.

[source,bash]
....
For each depth, a list of modes (resolutions) is defined. The default
resolution that the server will start-up with will be the first listed
mode that can be supported by the monitor and card.
Currently it is set to:

"640x480" "800x600" "1024x768" "1280x1024" for 8-bit
"640x480" "800x600" "1024x768" "1280x1024" for 16-bit
"640x480" "800x600" "1024x768" "1280x1024" for 24-bit

Modes that cannot be supported due to monitor or clock constraints will
be automatically skipped by the server.

 1  Change the modes for 8-bit (256 colors)
 2  Change the modes for 16-bit (32K/64K colors)
 3  Change the modes for 24-bit (24-bit color)
 4  The modes are OK, continue.

Enter your choice: 2

Select modes from the following list:

 1  "640x400"
 2  "640x480"
 3  "800x600"
 4  "1024x768"
 5  "1280x1024"
 6  "320x200"
 7  "320x240"
 8  "400x300"
 9  "1152x864"
 a  "1600x1200"
 b  "1800x1400"
 c  "512x384"

Please type the digits corresponding to the modes that you want to select.
For example, 432 selects "1024x768" "800x600" "640x480", with a
default mode of 1024x768.

Which modes? 432

You can have a virtual screen (desktop), which is screen area that is larger
than the physical screen and which is panned by moving the mouse to the edge
of the screen. If you don't want virtual desktop at a certain resolution,
you cannot have modes listed that are larger. Each color depth can have a
differently-sized virtual screen

Please answer the following question with either 'y' or 'n'.
Do you want a virtual screen that is larger than the physical screen? n

For each depth, a list of modes (resolutions) is defined. The default
resolution that the server will start-up with will be the first listed
mode that can be supported by the monitor and card.
Currently it is set to:

"640x480" "800x600" "1024x768" "1280x1024" for 8-bit
"1024x768" "800x600" "640x480" for 16-bit
"640x480" "800x600" "1024x768" "1280x1024" for 24-bit

Modes that cannot be supported due to monitor or clock constraints will
be automatically skipped by the server.

 1  Change the modes for 8-bit (256 colors)
 2  Change the modes for 16-bit (32K/64K colors)
 3  Change the modes for 24-bit (24-bit color)
 4  The modes are OK, continue.

Enter your choice: 4

Please specify which color depth you want to use by default:

  1  1 bit (monochrome)
  2  4 bits (16 colors)
  3  8 bits (256 colors)
  4  16 bits (65536 colors)
  5  24 bits (16 million colors)

Enter a number to choose the default depth.

4
....

Przygotowaną konfigurację należy zachować. Upewnijmy się, że konfiguracja zostanie zapisana w pliku o nazwie [.filename]#/etc/X11/XF86Config#.

[source,bash]
....
I am going to write the XF86Config file now. Make sure you don't accidently
overwrite a previously configured one.

Shall I write it to /etc/X11/XF86Config? y
....

Jeśli z jakichś przyczyn konfiguracja nie powiedzie się, możemy zacząć ją od początku, wybierając btn:[yes], gdy pojawi się następujący komunikat:

[source,bash]
....
          User Confirmation Requested
The XFree86 configuration process seems to have
failed.  Would you like to try again?

             [ Yes ]         No
....

Jeżeli konfiguracja XFree86(TM) sprawia problemy, wybierzmy btn:[no] i naciśnijmy kbd:[Enter], by kontynuować instalację. Po jej zakończeniu będziemy mogli uruchomić program konfiguracyjny poleceniem `xf86cfg -textmode` lub `xf86config`, wydanym jako `root`. crossref:x11[x11,System okien X] prezentuje inną metodę konfiguracji XFree86(TM) . Jeśli zdecydujemy się pominąć na razie konfigurację XFree86(TM), kolejnym krokiem będzie wybór pakietów.

Domyślnie serwer X może zostać unicestwiony kombinacją klawiszy kbd:[Ctrl+Alt+Backspace]. Możemy z niej skorzystać, jeśli coś jest nie w porządku z ustawieniami serwera i chcemy uniknąć uszkodzenia sprzętu.

Podczas pracy serwera X można zmieniać tryb graficzny, używając kombinacji klawiszy kbd:[Ctrl+Alt+\+] lub kbd:[Ctrl+Alt+-].

Po zakończeniu instalacji można wyregulować wysokość, szerokość i położenie obrazu przy użyciu xvidtune, po uruchomieniu XFree86(TM).

Zwracajmy uwagę na ostrzeżenia o możliwości uszkodzenia sprzętu poprzez niewłaściwe ustawienia. Nie róbmy niczego, czego nie jesteśmy pewni. Zamiast używać xvidtune, możemy dostroić ekran X Window korzystając z regulatorów monitora. Mogą się pojawić pewne różnice w wyświetlaniu obrazu przy powraceniu do trybu tekstowego, lepsze to jednak niż uszkodzenie sprzętu.

Przed dokonaniem jakichkolwiek zmian zapoznajmy się z dokumentacją man:xvidtune[1].

Jeżeli konfiguracja XFree86(TM) przebiegła pomyślnie, przejdziemy do kolejnego etapu, w którym wybierzemy menedżera okien.

[[default-desktop]]
=== Wybór menedżera okien

[NOTE]
====
Począwszy od wersji FreeBSD 5.3-RELEASE, opcje wyboru środowiska graficznego zostały usunięte z sysinstall. Musimy je skonfigurować po skończonej instalacji systemu. crossref:x11[x11,System okien X] zawiera szczegółowe informacje odnośnie instalacji i konfiguracji środowiska graficznego. Jeśli nie instalujemy wersji wcześniejszej niż FreeBSD 5.3-RELEASE, możemy pomiąć tą sekcję.
====

Dostepnych jest wiele różnych menedżerów okien, poczynając od najprostszych, zapewniających jedynie podstawowe funkcje, do rozbudowanych środowisk wyposażonych w pokaźny zestaw oprogramowania. Niektórym wystarczy nieznaczna przestrzeń na dysku i niewiele pamięci, inne natomiast mogą mieć znacznie większe wymagania. Dobrze jest wypróbować kilka różnych menedżerów i wybrać spośród nich ten, który najbardziej nam odpowiada. Są one dostępne w Kolekcji portów lub w postaci pakietów, można je więc instalować po zainstalowaniu systemu.

Możemy wybrać jeden z popularnych menedżerów okien i zainstalować go jako domyślny. Dzięki temu będziemy mieć możliwość uruchomienia go zaraz po zakończeniu instalacji.

[[x-desktop]]
.Wybór domyślnego menedżera okien
image::desktop.png[]

Klawiszami kursora wybieramy jedną z opcji i wciskamy kbd:[Enter]. Wybrany menedżer okien zostanie zainstalowany.

[[packages]]
=== Instalacja pakietów

Pakiety to skompilowane programy, które można w łatwy sposób instalować.

W poniższym przykładzie pokazana jest instalacja jednego pakietu. Możemy oczywiście zainstalować więcej pakietów. Gdy system będzie już zainstalowany, kolejne pakiety będzie można dodawać przy użyciu `sysinstall` (`/stand/sysinstall` w wersjach FreeBSD wcześniejszych niż 5.2).

[source,bash]
....
                     User Confirmation Requested
 The FreeBSD package collection is a collection of hundreds of
 ready-to-run applications, from text editors to games to WEB servers
 and more. Would you like to browse the collection now?

                            [ Yes ]   No
....

Jeśli wybierzemy btn:[yes] i naciśniemy kbd:[Enter], przejdziemy do ekranu wyboru pakietów:

[[package-category]]
.Wybór kategorii pakietów
image::pkg-cat.png[]

W danej chwili dostępne do instalacji są jedynie pakiety z bieżącego nośnika.

Możemy wybrać jedną z kategorii pakietów albo [.guimenuitem]#All#, by wyświetlone zostały wszystkie dostępne pakiety. Wybraną opcję wskazujemy przy użyciu klawiszy kursora i wciskamy kbd:[Enter].

Pokazana zostanie lista pakietów dostępnych w wybranej kategorii:

[[package-select]]
.Wybór pakietów
image::pkg-sel.png[]

Dla przykładu zaznaczona została powłoka bash. Możemy wybrać tyle pakietów, ile nam się podoba, zaznaczając każdy z nich kbd:[Space]. Krótki opis pakietu wyświetlany jest w lewym dolnym rogu ekranu.

Klawiszem kbd:[Tab] możemy przełączać się między ostatnio wybranym pakietem, przyciskami btn:[OK] i btn:[Cancel].

Po zaznaczeniu wszystkich wybranych pakietów naciskamy kbd:[Tab], by zaznaczyć btn:[OK] i naciskamy kbd:[Enter], powracając w ten sposób do menu wyboru pakietów.

Do przełączania się między btn:[OK] i btn:[Cancel] mogą również służyć klawisze kursora. Za ich pomocą możemy wybrać btn:[OK], a następnie nacisnąć kbd:[Enter], by wrócić do menu wyboru pakietów.

[[package-install]]
.Rozpoczęcie instalacji pakietów
image::pkg-install.png[]

Klawiszami kursora i kbd:[Tab] wybieramy btn:[Install] i wciskamy kbd:[Enter]. Pojawi się prośba o potwierdzenie chęci zainstalowania pakietów:

[[package-install-confirm]]
.Potwierdzenie instalacji pakietów
image::pkg-confirm.png[]

Gdy wybierzemy btn:[OK] i naciśniemy kbd:[Enter], rozpocznie się instalacja pakietów. Aż do jej zakończenia będą pokazywane komunikaty o przebiegu instalacji. Jeżeli pojawią się informacje o jakichkolwiek problemach, zanotujmy je.

Po zainstalowaniu pakietów wracamy do konfiguracji systemu. Nawet jeśli nie wybraliśmy żadnych pakietów i chcemy wrócić do końcowej konfiguracji wybieramy opcję btn:[Install].

[[addusers]]
=== Dodawanie użytkowników i grup

Powinniśmy założyć przynajmniej jedno konto użytkownika, by móc korzystać z systemu nie będąc zalogowanym jako `root`. Główna partycja jest zwykle niewielka, więc korzystanie z aplikacji jako `root` może ją szybko zapełnić. Inny powód wymieniony został w poniższym komunikacie:

[source,bash]
....
                     User Confirmation Requested
 Would you like to add any initial user accounts to the system? Adding
 at least one account for yourself at this stage is suggested since
 working as the "root" user is dangerous (it is easy to do things which
 adversely affect the entire system).

                            [ Yes ]   No
....

Wybieramy btn:[yes] i naciskamy kbd:[Enter], by dodać użytkownika.

[[add-user2]]
.Dodawanie użytkownika
image::adduser1.png[]

Klawiszamy kursora wybieramy [.guimenuitem]#User# (użytkownik) i wciskamy kbd:[Enter].

[[add-user3]]
.Dane nowego użytkownika
image::adduser2.png[]

Kolejne pola wybieramy klawiszem kbd:[Tab]. W dolnej części ekranu pojawiać się będą następujące opisy, pomocne przy wprowadzaniu poszczególnych danych:

Login ID::
Nazwa nowego użytkownika (obowiązkowa).

UID::
Numer będący identyfikatorem użytkownika (wypełniany automatycznie, jeśli pole pozostanie puste).

Group::
Nazwa podstawowej grupy użytkownika (wybierana automatycznie, jeśli pole pozostanie puste).

Password::
Hasło użytkownika (wpisujmy je uważnie!).

Full name::
Nazwisko użytkownika (komentarz).

Member groups::
Grupy, których członkiem będzie użytkownik (czyli dostanie ich uprawnienia).

Home directory::
Domowy katalog użytkownika (wpisywany automatycznie, jeśli pole pozostanie puste).

Login shell::
Powłoka uruchamiana po zalogowaniu się (wybierana automatycznie, jeśli pole pozostanie puste, np. [.filename]#/bin/sh#).

W przykładzie powłoka została zmieniona z [.filename]#/bin/sh# na [.filename]#/usr/local/bin/bash#, aby korzystać z powłoki bash zainstalowanej wcześniej jako pakiet. Nie wpisujmy tu powłoki, która nie istnieje, gdyż uniemożliwi to zalogowanie się. Najpopularniejszą powłoką w świecie BSD jest powłoka C, czyli [.filename]#/bin/tcsh#.

Użytkownik został dopisany do grupy `wheel`, dzięki czemu będzie mógł uzyskiwać uprawnienia użytkownika `root`.

Gdy skończymy, wybieramy btn:[OK]. Ponownie pojawi się menu zarządzania użytkownikami i grupami:

[[add-user4]]
.Wyjście z menu zarządzania użytkownikami i grupami
image::adduser3.png[]

W podobny sposób możemy od razu utworzyć dodatkowe grupy, jeśli zajdzie taka potrzeba. Gdy system będzie już zainstalowany, będziemy mogli dodawać grupy przy użyciu `sysinstall` (`/stand/sysinstall` w wersjach FreeBSD starszych niż 5.2).

Gdy skończymy dodawanie użytkowników wybieramy klawiszami kursora [.guimenuitem]#Exit# i wciskamy kbd:[Enter], by kontynuować instalację.

[[rootpass]]
=== Hasło użytkownika `root`

[source,bash]
....
                        Message
 Now you must set the system manager's password.
 This is the password you'll use to log in as "root".

                         [ OK ]

               [ Press enter to continue ]
....

Wciskamy kbd:[Enter], aby ustawić hasło ``root``a.

Hasło musi być prawidłowo podane dwukrotnie. Rzecz jasna, powinniśmy zadbać o to, by łatwo odnaleźć hasło, gdy zdarzy się nam je zapomnieć. Zwróćmy uwagę, że w trakcie wpisywania hasła nie pojawią się żadne znaki, nawet gwiazdki.

[source,bash]
....
Changing local password for root.
New password :
Retype new password :
....

Po pomyślnym wprowadzeniu hasła przejdziemy do kolejnego etapu instalacji.

[[exit-inst]]
=== Zakończenie instalacji

Jeżeli będziemy chcieli skonfigurować dodatkowe urządzenia sieciowe, lub wprowadzić inne zmiany w konfiguracji systemu, możemy to zrobić w tym właśnie momencie, lub też po zakończeniu instalacji za pośrednictwem `sysinstall` (`/stand/sysinstall` w wersjach FreeBSD wcześniejszych niż 5.2).

[source,bash]
....
                     User Confirmation Requested
 Visit the general configuration menu for a chance to set any last
 options?

                              Yes   [ No ]
....

Wybieramy klawiszami kursora btn:[no] i wciskamy kbd:[Enter], by powrócić do głównego menu instalacji.

[[final-main]]
.Zakończenie instalacji
image::mainexit.png[]

Przy pomocy klawiszy kursora wybieramy btn:[X Exit Install] i naciskamy kbd:[Enter]. Pojawi się prośba o potwierdzenie chęci zakończenia instalacji:

[source,bash]
....
                     User Confirmation Requested
 Are you sure you wish to exit? The system will reboot (be sure to
 remove any floppies from the drives).

                            [ Yes ]   No
....

Wybieramy btn:[yes]. Jeżeli uruchamialiśmy komputer z dyskietki, wyjmujemy ją. Napęd CDROM będzie zablokowany aż do chwili, gdy komputer zacznie się ponownie uruchamiać. Wtedy napęd zostanie odblokowany i będzie można wyjąć z niego płytę (szybko).

Komputer zostanie ponownie uruchomiony. Zwróćmy uwagę na ewentualne komunikaty o błędach.

[[freebsdboot]]
=== Uruchamianie FreeBSD

[[freebsdboot-i386]]
==== Uruchamianie FreeBSD na komputerach i386(TM)

Jeżeli wszystko przebiegło prawidłowo, na ekranie zobaczymy serię kolejno pojawiających się komunikatów, a na koniec będziemy mogli się zalogować. Komunikaty możemy przeczytać naciskając kbd:[Scroll-Lock], następnie przewijając ekran klawiszami kbd:[PgUp] i kbd:[PgDn]. Ponownie naciskając kbd:[Scroll-Lock] powracamy do komunikatu logowania.

Być może nie będziemy mogli zobaczyć wszystkich komunikatów (ograniczony rozmiar bufora), jednak można je przejrzeć po zalogowaniu się, wpisując `dmesg` w linii poleceń.

Zalogujmy się, wpisując nazwę użytkownika i hasło wybrane podczas instalacji (w naszym przykładzie `rpratt`). Jako `root` powinniśmy logować się tylko wtedy, gdy jest to konieczne.

Typowe komunikaty pokazywane podczas uruchamiania systemu (pominięto informacje o wersji):

[source,bash]
....
Copyright (c) 1992-2002 The FreeBSD Project.
Copyright (c) 1979, 1980, 1983, 1986, 1988, 1989, 1991, 1992, 1993, 1994
        The Regents of the University of California. All rights reserved.

Timecounter "i8254"  frequency 1193182 Hz
CPU: AMD-K6(tm) 3D processor (300.68-MHz 586-class CPU)
  Origin = "AuthenticAMD"  Id = 0x580  Stepping = 0
  Features=0x8001bf<FPU,VME,DE,PSE,TSC,MSR,MCE,CX8,MMX>
  AMD Features=0x80000800<SYSCALL,3DNow!>
real memory  = 268435456 (262144K bytes)
config> di sn0
config> di lnc0
config> di le0
config> di ie0
config> di fe0
config> di cs0
config> di bt0
config> di aic0
config> di aha0
config> di adv0
config> q
avail memory = 256311296 (250304K bytes)
Preloaded elf kernel "kernel" at 0xc0491000.
Preloaded userconfig_script "/boot/kernel.conf" at 0xc049109c.
md0: Malloc disk
Using $PIR table, 4 entries at 0xc00fde60
npx0: <math processor> on motherboard
npx0: INT 16 interface
pcib0: <Host to PCI bridge> on motherboard
pci0: <PCI bus> on pcib0
pcib1: <VIA 82C598MVP (Apollo MVP3) PCI-PCI (AGP) bridge> at device 1.0 on pci0
pci1: <PCI bus> on pcib1
pci1: <Matrox MGA G200 AGP graphics accelerator> at 0.0 irq 11
isab0: <VIA 82C586 PCI-ISA bridge> at device 7.0 on pci0
isa0: <ISA bus> on isab0
atapci0: <VIA 82C586 ATA33 controller> port 0xe000-0xe00f at device 7.1 on pci0
ata0: at 0x1f0 irq 14 on atapci0
ata1: at 0x170 irq 15 on atapci0
uhci0: <VIA 83C572 USB controller> port 0xe400-0xe41f irq 10 at device 7.2 on pci0
usb0: <VIA 83C572 USB controller> on uhci0
usb0: USB revision 1.0
uhub0: VIA UHCI root hub, class 9/0, rev 1.00/1.00, addr 1
uhub0: 2 ports with 2 removable, self powered
chip1: <VIA 82C586B ACPI interface> at device 7.3 on pci0
ed0: <NE2000 PCI Ethernet (RealTek 8029)> port 0xe800-0xe81f irq 9 at
device 10.0 on pci0
ed0: address 52:54:05:de:73:1b, type NE2000 (16 bit)
isa0: too many dependant configs (8)
isa0: unexpected small tag 14
fdc0: <NEC 72065B or clone> at port 0x3f0-0x3f5,0x3f7 irq 6 drq 2 on isa0
fdc0: FIFO enabled, 8 bytes threshold
fd0: <1440-KB 3.5" drive> on fdc0 drive 0
atkbdc0: <keyboard controller (i8042)> at port 0x60-0x64 on isa0
atkbd0: <AT Keyboard> flags 0x1 irq 1 on atkbdc0
kbd0 at atkbd0
psm0: <PS/2 Mouse> irq 12 on atkbdc0
psm0: model Generic PS/2 mouse, device ID 0
vga0: <Generic ISA VGA> at port 0x3c0-0x3df iomem 0xa0000-0xbffff on isa0
sc0: <System console> at flags 0x1 on isa0
sc0: VGA <16 virtual consoles, flags=0x300>
sio0 at port 0x3f8-0x3ff irq 4 flags 0x10 on isa0
sio0: type 16550A
sio1 at port 0x2f8-0x2ff irq 3 on isa0
sio1: type 16550A
ppc0: <Parallel port> at port 0x378-0x37f irq 7 on isa0
ppc0: SMC-like chipset (ECP/EPP/PS2/NIBBLE) in COMPATIBLE mode
ppc0: FIFO with 16/16/15 bytes threshold
ppbus0: IEEE1284 device found /NIBBLE
Probing for PnP devices on ppbus0:
plip0: <PLIP network interface> on ppbus0
lpt0: <Printer> on ppbus0
lpt0: Interrupt-driven port
ppi0: <Parallel I/O> on ppbus0
ad0: 8063MB <IBM-DHEA-38451> [16383/16/63] at ata0-master using UDMA33
ad2: 8063MB <IBM-DHEA-38451> [16383/16/63] at ata1-master using UDMA33
acd0: CDROM <DELTA OTC-H101/ST3 F/W by OIPD> at ata0-slave using PIO4
Mounting root from ufs:/dev/ad0s1a
swapon: adding /dev/ad0s1b as swap device
Automatic boot in progress...
/dev/ad0s1a: FILESYSTEM CLEAN; SKIPPING CHECKS
/dev/ad0s1a: clean, 48752 free (552 frags, 6025 blocks, 0.9% fragmentation)
/dev/ad0s1f: FILESYSTEM CLEAN; SKIPPING CHECKS
/dev/ad0s1f: clean, 128997 free (21 frags, 16122 blocks, 0.0% fragmentation)
/dev/ad0s1g: FILESYSTEM CLEAN; SKIPPING CHECKS
/dev/ad0s1g: clean, 3036299 free (43175 frags, 374073 blocks, 1.3% fragmentation)
/dev/ad0s1e: filesystem CLEAN; SKIPPING CHECKS
/dev/ad0s1e: clean, 128193 free (17 frags, 16022 blocks, 0.0% fragmentation)
Doing initial network setup: hostname.
ed0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500
        inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
        inet6 fe80::5054::5ff::fede:731b%ed0 prefixlen 64 tentative scopeid 0x1
        ether 52:54:05:de:73:1b
lo0: flags=8049<UP,LOOPBACK,RUNNING,MULTICAST> mtu 16384
        inet6 fe80::1%lo0 prefixlen 64 scopeid 0x8
        inet6 ::1 prefixlen 128
        inet 127.0.0.1 netmask 0xff000000
Additional routing options: IP gateway=TAK TCP keepalive=TAK
routing daemons:.
additional daemons: syslogd.
Doing additional network setup:.
Starting final network daemons: creating ssh RSA host key
Generating public/private rsa1 key pair.
Your identification has been saved in /etc/ssh/ssh_host_key.
Your public key has been saved in /etc/ssh/ssh_host_key.pub.
The key fingerprint is:
cd:76:89:16:69:0e:d0:6e:f8:66:d0:07:26:3c:7e:2d root@k6-2.example.com
 creating ssh DSA host key
Generating public/private dsa key pair.
Your identification has been saved in /etc/ssh/ssh_host_dsa_key.
Your public key has been saved in /etc/ssh/ssh_host_dsa_key.pub.
The key fingerprint is:
f9:a1:a9:47:c4:ad:f9:8d:52:b8:b8:ff:8c:ad:2d:e6 root@k6-2.example.com.
setting ELF ldconfig path: /usr/lib /usr/lib/compat /usr/X11R6/lib
/usr/local/lib
a.out ldconfig path: /usr/lib/aout /usr/lib/compat/aout /usr/X11R6/lib/aout
starting standard daemons: inetd cron sshd usbd sendmail.
Initial rc.i386 initialization:.
rc.i386 configuring syscons: blank_time screensaver moused.
Additional ABI support: linux.
Local package initialization:.
Additional TCP options:.

FreeBSD/i386 (k6-2.example.com) (ttyv0)

login: rpratt
Password:
....

Generowanie kluczy RSA i DSA na niezbyt szybkich komputerach może zająć nieco czasu. Dzieje się to tylko podczas pierwszego uruchomienia nowo zainstalowanego systemu. Następne ładowanie systemu będzie już odbywać się szybciej.

Jeśli skonfigurowaliśmy serwer X i wybraliśmy menedżera okien, możemy uruchomić go wpisując `startx` w linii poleceń.

==== Uruchamianie FreeBSD na komputerach Alpha

Po zakończeniu instalacji będziemy mogli uruchomić FreeBSD, wpisując następujące polecenie w konsoli SRM:

[source,bash]
....
>>>BOOT DKC0
....

Nakazuje ono oprogramowaniu sprzętowemu uruchomić system z określonego dysku. By FreeBSD było automatycznie uruchamiane przy włączeniu komputera, wpisujemy poniższe polecenia:

[source,bash]
....
>>> SET BOOT_OSFLAGS A
>>> SET BOOT_FILE ''
>>> SET BOOTDEF_DEV DKC0
>>> SET AUTO_ACTION BOOT
....

Komunikaty pokazywane podczas ładowania systemu będą podobne (choć nie identyczne) do komunikatów pokazywanych na i386(TM).

[[shutdown]]
=== Wyłączanie FreeBSD

Właściwe wyłączenie systemu operacyjnego jest istotną sprawą. Nie należy po prostu wyłączać komputera. Powinniśmy najpierw uzyskać prawa administratora, wpisując w linii poleceń `su` i podając hasło ``root``a; może to zrobić tylko użytkownik należący do grupy `wheel`. Możemy także po prostu zalogować się jako `root`. Następnie wydajemy polecenie `shutdown -h now`.

[source,bash]
....
The operating system has halted.
Please press any key to reboot.
....

Po takim wyłączeniu systemu i pojawieniu się komunikatu "Please press any key to reboot" (Naciśnij dowolny klawisz by ponownie uruchomić system), można już wyłączyć komputer. Naciśnięcie dowolnego klawisza spowoduje ponownie uruchomienie systemu.

Inny sposobem ponownego uruchomienia systemu jest kombinacja klawiszy kbd:[Ctrl+Alt+Del], jednak w normalnych warunkach korzystanie z niej nie jest zalecane.

[[install-supported-hardware]]
== Obsługiwany sprzęt

W obecnej chwili FreeBSD działa na komputerach z magistralami ISA, VLB, EISA i PCI wyposażonych w procesory Intel, AMD, Cyrix lub NexGen "x86", jak również na komputerach z procesorem Compaq Alpha. Obsługiwane są także dyski IDE i ESDI, rozmaite kontrolery SCSI, karty PCMCIA, urządzenia USB oraz karty sieciowe i szeregowe. FreeBSD pracuje także z szyną microchannel (MCA) firmy IBM.

Lista obsługiwanych urządzeń dołączona jest do każdego wydania FreeBSD w dokumencie FreeBSD Hardware Notes. Można go zwykle znaleźć w pliku [.filename]#HARDWARE.TXT#, umieszczonym bezpośrednio w głównym katalogu płyty CDROM lub na serwerze FTP, bądź w menu dokumentacji sysinstall. Na liście zebrano urządzenia, które poprawnie współpracują z FreeBSD. Kopie tej listy dla różnych wydań systemu i różnych architektur można także znaleźć na podstronie http://www.FreeBSD.org/releases/[Release Information] na stronie WWW FreeBSD.

[[install-trouble]]
== Rozwiązywanie problemów

W tej części opisujemy, jak radzić sobie z podstawowymi problemami spotykanymi podczas instalacji. W kilku pytaniach i odpowiedziach omawiamy także możliwość uruchamiania FreeBSD i MS-DOS(R) na tym samym komputerze.

=== Co robić, gdy coś pójdzie nie tak

Ze względu na rozmaite ograniczenia architektury PC, rozpoznawanie urządzeń może niekiedy sprawiać problemy. Można jednak spróbować sobie z nimi poradzić

Zapoznajmy się z dokumentem Hardware Notes, by mieć pewność, że nasze urządzenia są obsługiwane przez FreeBSD.

Jeśli wciąż występują problemy, mimo, że nasz sprzęt jest obsługiwany, powinniśmy ponownie uruchomić komputer i wybrać opcję wizualnej konfiguracji jądra (visual kernel configuration). Będziemy mieć możliwość przejrzenia naszych urządzeń i podania systemowi informacji o nich. Jądro uruchamiane z dyskietki startowej zakłada, że większość urządzeń skonfigurowanych jest z fabrycznymi ustawieniami IRQ, portów we/wy i kanałów DMA. Jeśli konfiguracja naszego sprzętu jest odmienna, zapewne będziemy musieli poinformować o tym FreeBSD, odpowiednio modyfikując konfigurację.

Może się zdarzyć, że próba rozpoznania urządzenia nieistniejącego spowoduje kłopoty z późniejszym rozpoznawaniem urządzeń rzeczywiście zainstalowanych w komputerze. W takim wypadku powinniśmy wyłączyć sterowniki powodujące konflikty.

[NOTE]
====
Pewnych problemów z instalacją można uniknąć dzięki instalacji nowszego oprogramowania sprzętowego (ang. firmware) urządzenia, zwykle płyty głównej. Oprogramowanie sprzętowe płyty głównej znane jest pod nazwą BIOS. Większość producentów płyt głównych lub komputerów umieszcza informacje o nowych wersjach oprogramowania na swoich stronach WWW.

Producenci zwykle stanowczo odradzają instalowanie nowego BIOS-u, oprócz sytuacji, w których jest to uzasadnione, na przykład w przypadku wykrycia poważnego błędu. Instalacja nowszej wersji _może_ się nie udać, powodując trwałe uszkodzenie układu BIOS.
====

[WARNING]
====

Nie należy wyłączać sterowników potrzebnych podczas instalacji, na przykład sterownika ekranu ([.filename]#sc0#). Jeżeli po zakończeniu konfiguracji jądra instalacja w tajemniczy sposób zastyga lub przerywa pracę, zapewne usunęliśmy lub zmodyfikowaliśmy coś, co nie powinno być ruszane. Musimy ponownie uruchomić komputer i spróbować jeszcze raz.
====

Podczas konfiguracji możemy:

* Przejrzeć listę sterowników zainstalowanych w jądrze.
* Wyłączyć sterowniki urządzeń, których nie ma w komputerze.
* Zmienić ustawienia IRQ, DRQ i portów we/wy używanych przez sterowniki.

Po dostosowaniu konfiguracji jądra do naszego sprzętu, wpisujemy `Q`, by ponownie uruchomić komputer z nowymi ustawieniami. Zmiany konfiguracji są trwałe i będą obowiązywać również po zakończeniu instalacji, nie będzie więc trzeba konfigurować jądra na nowo przy każdym uruchamianiu systemu. Jest jednak bardzo prawdopodobne, że będziemy chcieli zbudować crossref:kernelconfig[kernelconfig,niestandardowe jądro].

=== Jak poradzić sobie z istniejącymi partycjami MS-DOS(R)

Wielu użytkowników instaluje FreeBSD na komputerach PC z systemem operacyjnym z rodziny Microsoft(R). Specjalnie dla tych użytkowników przygotowany został program FIPS. Narzędzie to znajduje się na płycie instalacyjnej w katalogu\ [.filename]#tools#. Można je również pobrać z wielu crossref:mirrors[mirrors,serwerów lustrzanych FreeBSD].

FIPS umożliwia podzielenie istniejącej partycji MS-DOS(R) na dwie części, zachowując pierwotną partycję i pozwalając na instalację FreeBSD na wolnej drugiej częsci. Wpierw należy wykonać defragmentację partycji MS-DOS(R) za pomocą dostępnego w Windows(R) narzędzia (w Eksploratorze nacisnąć prawym przyciskiem myszki na dysku twardym, następnie wybrać opcję defragmentacji dysku), albo Norton Disk Tools. Następnie należy uruchomić FIPS. Program zapyta o potrzebne mu informacje. Potem można ponownie uruchomić komputer i zainstalować FreeBSD na nowym wolnym segmencie. W menu [.guimenuitem]#Distributions# można dowiedzieć się, ile miejsca na dysku będzie w przybliżeniu potrzebne.

Jest także bardzo użyteczny program firmy PowerQuest (http://www.powerquest.com/[http://www.powerquest.com]), o nazwie PartitionMagic(R). Ma on znacznie większe możliwości niż FIPS i stosowanie go jest zalecane, jeśli planuje się częste instalowanie i usuwanie systemów operacyjnych. Nie jest on jednak za darmo; jeśli FreeBSD ma być zainstalowane raz na dobre, FIPS zapewne w zupełności wystarczy.

=== Wykorzystanie systemów plików MS-DOS(R) i Windows(R)

W chwili obecnej FreeBSD nie obsługuje systemów plików skompresowanych za pomocą programu Double Space(TM). Tym samym musimy wpierw rozkompresować system plików nim FreeBSD będzie mógł odczytać zapisane w nim dane. Można do tego wykorzystać Agenta kompresji z menu [.guimenuitem]#Start#> [.guimenuitem]#Programy# > [.guimenuitem]#Narzędzia systemowe#.

FreeBSD obsługuje systemy plików MS-DOS(R). By je zamontować należy wykorzystać polecenie man:mount_msdosfs[8] z odpowiednimi parametrami. Typowa forma polecenia wygląda następująco:

[source,bash]
....
# mount_msdosfs /dev/ad0s1 /mnt
....

W tym przykładzie system plików MS-DOS(R) zlokalizowany jest na pierwszej partycji pierwszego dysku twardego. By sprawdzić jak jest w naszym przypadku należy sprawdzić wynik poleceń `dmesg` oraz `mount`. Powinno to pozwolić nam zorientować się w układzie partycji na dysku.

[NOTE]
====
Rozszerzone partycje MS-DOS(R) odwzorowywane są na końcu pozostałych "segmentów" we FreeBSD. Przykładowo, pierwsza partycja MS-DOS(R) może znajdować sie na [.filename]#/dev/ad0s1#, partycja FreeBSD na [.filename]#/dev/ad0s2#, natomiast rozszerzona partycja MS-DOS(R) na [.filename]#/dev/ad0s3#. Może to być mylące na początku.
====

Analogicznie można montować partycje NTFS wykorzystując polecenie man:mount_ntfs[8].

=== Pytania użytkowników komputerów Alpha

Oto niektóre z najczęściej zadawanych pytań dotyczących instalowania FreeBSD na komputerach Alpha.

==== Czy mogę ładować system z konsoli ARC ARC lub Alpha BIOS Alpha BIOS?

Nie. FreeBSD, podobnie jak Compaq Tru64 i VMS, może być ładowany tylko z konsoli SRM.

==== Pomocy, brakuje mi miejsca na dysku! Czy muszę wszystko skasować?

Niestety tak.

==== Czy można montować systemy plików Compaq Tru64 lub VMS?

Nie, przynajmniej na razie.

[[install-advanced]]
== Instalacja zaawansowana

W tej części omówiona została instalacja FreeBSD w sytuacjach wyjątkowych.

[[headless-install]]
=== Instalacja FreeBSD na komputerze bez monitora lub klawiatury

Ten rodzaj instalacji zwany jest "instalacją bez głowy", ponieważ komputer, na którym FreeBSD będzie instalowane nie ma podłączonego monitora, lub nawet nie ma wyjścia VGA. Jak to możliwe? Dzięki konsoli szeregowej. W roli konsoli szeregowej używa się zwykle innego komputera, który pełni rolę ekranu i klawiatury dla pozbawionego tych urządzeń komputera. By zainstalować system tą metodą, musimy przygotować dyskietki instalacyjne zgodnie z opisem w <<install-floppies>>.

By zmodyfikować dyskietki do pracy z konsolą szeregową należy wykonać następujące kroki:

[.procedure]
====

. Włączenie konsoli szeregowej na dyskietce startowej
+ 
Jeśli spróbowalibyśmy uruchomić komputer korzystając z utworzonych właśnie dyskietek startowych, zostałaby uruchomiona zwykła instalacja FreeBSD. My jednak chcemy, by podczas instalacji używana była konsola szeregowa. By to skonfigurować, montujemy dyskietkę [.filename]#kern.flp# we FreeBSD przy użyciu polecenia man:mount[8].
+
[source,bash]
....
# mount /dev/fd0 /mnt
....
+ 
Po zamontowaniu dyskietki, wchodzimy do katalogu [.filename]#/mnt#:
+
[source,bash]
....
# cd /mnt
....
+ 
Teraz włączymy na dyskietce konsolę szeregową. Musimy stworzyć plik [.filename]#boot.config# zawierający wiersz `/boot/loader -h`. Jego zadaniem jest po prostu nakazanie programowi ładującemu system, by używał konsoli szeregowej.
+
[source,bash]
....
# echo "/boot/loader -h" > boot.config
....
+ 
Po prawidłowym skonfigurowaniu dyskietki odmontowujemy ją poleceniem man:umount[8]:
+
[source,bash]
....
# cd /
# umount /mnt
....
+ 
Możemy wyjąć dyskietkę ze stacji dyskietek.
. Podłączenie kabla null-modem
+ 
Dwa komputery łączymy crossref:serialcomms[term-cables-null,kablem null-modem]. Po prostu podłączamy kabel do portów szeregowych w jednym i drugim komputerze. _Zwykły kabel szeregowy nie nadaje się do tego celu_, potrzebny jest kabel null-modem, ponieważ jego przewody są odpowiednio skrzyżowane.
. Uruchomienie instalacji
+ 
Możemy już uruchomić instalację. Do stacji dyskietek "bezgłowego" komputera, na którym ma być zainstalowane FreeBSD, wkładamy dyskietkę [.filename]#kern.flp# i włączamy komputer.
. Połączenie z "bezgłowym" komputerem
+ 
Z komputerem łączymy się korzystając z man:cu[1]:
+
[source,bash]
....
# cu -l /dev/cuaa0
....
====

Gotowe! Powinniśmy być w stanie kontrolować "bezgłowy" komputer poprzez sesję `cu`. Zostaniemy poproszeni o włożenie dyskietki [.filename]#mfsroot.flp#, nastepnie o wybranie typu terminala. Wybieramy kolorową konsolę FreeBSD (FreeBSD color console) i kontynuujemy instalację.

[[install-diff-media]]
== Przygotowanie własnego nośnika instalacji

[NOTE]
====
Dla uproszczenia, w niniejszej części "dysk FreeBSD" oznaczać będzie płytę CDROM lub DVD z FreeBSD, który zakupiliśmy lub przygotowaliśmy samodzielnie.
====

Może się zdarzyć sytuacja, w której będziemy musieli przygotować własny nośnik lub źródło dla instalacji FreeBSD. Może to być nośnik fizyczny, na przykład taśma, albo inne źródło z którego sysinstall będzie mógł pobrać pliki, na przykład lokalny serwer FTP lub partycja MS-DOS(R).

Oto przykład:

* Mamy wiele komputerów w sieci lokalnej i jeden dysk FreeBSD. Chcemy przygotować lokalny serwer FTP z zawartością dysku FreeBSD, aby komputery mogły z niego korzystać zamiast łączyć się z Internetem.
* Mamy dysk FreeBSD, jednak FreeBSD nie obsługuje naszego napędu CD/DVD. Napęd jest natomiast prawidłowo obsługiwany w MS-DOS(R)/Windows(R). Chcemy skopiować pliki instalacyjne FreeBSD na partycję DOS i wykorzystać ją do zainstalowania FreeBSD.
* Komputer, na którym chcemy zainstalować system nie ma napędu CD/DVD ani karty sieciowej. Jest inny komputer, który ma napęd CD/DVD lub kartę sieciową i możemy połączyć się z nim kablem szeregowym lub równoległym.
* Chcemy przygotować taśmę, przy pomocy której będzie można zainstalować FreeBSD.

[[install-cdrom]]
=== Przygotowanie płyty instalacyjnej

W ramach każdego wydania systemu Projekt FreeBSD udostępnia pięć obrazów płyt CD ("obrazów ISO"). Jeśli dysponujemy nagrywarką CD, możemy je nagrać ("wypalić") na płytach, otrzymując zestaw płyt, które mogą posłużyć do zainstalowania systemu. Jest to najprostszy sposób instalacji FreeBSD w przypadku, gdy mamy nagrywarkę i tanie połączenie z Internetem.

[.procedure]
====
. Pobranie obrazów ISO
+ 
Obrazy ISO każdego z wydań systemu można pobrać z [.filename]#ftp://ftp.FreeBSD.org/pub/FreeBSD/ISO-IMAGES-arch/version# lub z najbliższego serwera lustrzanego. W miejscu _arch_ i _version_ wstawiamy odpowiednią nazwę architektury i wersję.
+ 
Wspomniany katalog zawiera zwykle następujące obrazy:
+
.Nazwy obrazów ISO dla FreeBSD 4._X_ i ich znaczenie
[cols="1,1", frame="none", options="header"]
|===
| Nazwa pliku
| Zawartość

|[.filename]#version-RELEASE-arch-miniinst.iso#
|Wszystko, co jest potrzebne do zainstalowania FreeBSD.

|[.filename]#version-RELEASE-arch-disc1.iso#
|Wszystko, co jest potrzebne do zainstalowania FreeBSD, i tyle dodatkowych pakietów, ile zmieściło się na płycie.

|[.filename]#version-RELEASE-arch-disc2.iso#
|"Żywy system plików", używany wraz z dostępną w sysinstall funkcją "Repair" (naprawa). Kopia drzewa CVS FreeBSD. Dodatkowe pakiety o charakterze niezależnym.
|===
+
.Nazwy obrazów ISO dla FreeBSD 5._X_ i ich znaczenie
[cols="1,1", frame="none", options="header"]
|===
| Nazwa pliku
| Zawartość

|[.filename]#version-RELEASE-arch-bootonly.iso#
|Wszystko co jest niezbędne by uruchomić jądro FreeBSD i rozpocząć instalację. Pliki instalacyjne zostaną probrane z serwera FTP bądź innego źródła.

|[.filename]#version-RELEASE-arch-miniinst.iso#
|Wszystko, co jest potrzebne do zainstalowania FreeBSD.

|[.filename]#version-RELEASE-arch-disc1.iso#
|Wszystko co jest potrzebne by zainstalować FreeBSD jako "żywy system plików" używany wraz z dostępną w sysinstall funkcją "Repair" (naprawa).

|[.filename]#version-RELEASE-arch-disc2.iso#
|Dokumentacja FreeBSD i tyle dodatkowych pakietów, ile zmieściło się na płycie.
|===
+ 
_Musimy_ pobrać albo obraz ISO mini, albo obraz pierwszej płyty. Nie ma sensu pobierać obydwu, ponieważ obraz pierwszej płyty zawiera wszystko to, co obraz mini.
+
[NOTE]
======
Obraz ISO mini dostępny jest tylko dla wydań starszych niż FreeBSD 5.4-RELEASE.
======
+ 
Z obrazu ISO miniinst warto jest skorzystać, gdy mamy niedrogi dostęp do Internetu. Za jego pomocą możemy zainstalować FreeBSD, natomiast niezależne oprogramowanie instalujemy przez Internet, przy pomocy systemu portów i pakietów (patrz: crossref:ports[ports,Instalacja programów. pakiety i porty]).
+ 
Płytę pierwszą wybieramy wtedy, gdy oprócz zainstalowania systemu chcemy skorzystać z zestawu wybranych pakietów oprogramowania.
+ 
Pozostałe płyty są przydatne, lecz nie niezbędne, szczególnie, gdy dysponujemy szybkim dostępem do Internetu.
. Nagranie płyt CD
+ 
Pliki obrazów należy nagrać na płyty. Jeśli zamierzamy robić to w systemie FreeBSD, informacje na ten temat znajdziemy w crossref:disks[creating-cds,Creating and Using Optical Media (CDs)] (w szczególności crossref:disks[burncd,burncd] oraz crossref:disks[cdrecord,cdrecord]).
+ 
Jeżeli płyty nagrywać będziemy w innym systemie, do tego celu możemy posłużyć się dowolnymi dostępnymi programami obsługującymi nagrywarkę płyt CD. ISO jest standardowym formatem obrazu płyt obsługiwanym w wielu aplikacjach nagrywających.
====

[NOTE]
====
Zainteresowanych przygotowaniem własnych wydań FreeBSD odsyłamy do artykułu link:{releng}[Release Engineering](ang.).
====

[[install-ftp]]
=== Przygotowanie lokalnego serwera FTP z dyskiem FreeBSD

Układ plików na dysku FreeBSD jest taki sam, jak układ plików na serwerze FTP. Dzięki temu łatwo możemy przygotować lokalny serwer FTP, który może być wykorzystany przez inne komputery w sieci do instalacji FreeBSD.

[.procedure]
====
. Na komputerze, który będzie służyć jako serwer FTP, umieszczamy CDROM w napędzie i montujemy go w katalogu [.filename]#/cdrom#.
+
[source,bash]
....
# mount /cdrom
....
+
. Zakładamy konto dla anonimowego użytkownika FTP w [.filename]#/etc/passwd#. Plik [.filename]#/etc/passwd# modyfikujemy przy użyciu man:vipw[8]. Dodajemy następujący wiersz:
+
[.programlisting]
....
ftp:*:99:99::0:0:FTP:/cdrom:/nonexistent
....
+
. Na koniec upewniamy się, że usługa FTP jest włączona w [.filename]#/etc/inetd.conf#.
====

Od tej chwili każdy, kto jest w stanie nawiązać połączenie z naszym komputerem, może podczas instalacji FreeBSD wybrać jako źródło serwer FTP, w menu wyboru serwera FTP wybrać opcję "Other" (inny) i wpisać `ftp://nasz.komputer`.

[NOTE]
====
Jeśli nośnik, z którego uruchamiamy instalator (najczęściej dyskietka), nie pochodzi z dokładnie tej samej wersji co pliki na naszym serwerze FTP, to sysinstall nie pozwoli nam kontynuować instalacji. By pominąć tą blokadę należy w menu menu:Options[] zmienić nazwę dystrybucji na [.guimenuitem]#any#.
====

[WARNING]
====

Ta metoda może być z powodzeniem stosowana na komputerze w sieci lokalnej, chronionym przez zaporę ogniową. Udostępnianie serwera FTP innym użytkownikom Internetu (a nie tylko sieci lokalnej) naraża nasz komputer na ataki włamywaczy i inne problemy. Decydując się na to należy koniecznie przestrzegać zasad bezpieczeństwa.
====

=== Przygotowywanie dyskietek instalacyjnych

Jeżeli koniecznie chcemy instalować system z dyskietek (co _nie jest_ zalecane), na przykład z powodu nieobsługiwanego urządzenia lub po prostu z zamiłowania do utrudnień, musimy najpierw przygotować dyskietki instalacyjne.

Będziemy potrzebować co najmniej tylu dyskietek 1.44 MB lub 1.2 MB, by zmieściły się na nich wszystkie pliki z katalogu [.filename]#bin# (binarne pliki dystrybucyjne). Jeśli dyskietki przygotowujemy w DOS-ie, to _muszą_ one być sformatowane przy pomocy DOS-owego polecenia `FORMAT`. W Windows(R) do sformatowania dyskietek możemy użyć Explorera (klikamy prawym przyciskiem myszy na stacji [.filename]#A:# i wybieramy "Format").

_Nie ufajmy_ dyskietkom sformatowanym fabrycznie. Dla pewności sformatujmy je jeszcze raz samodzielnie. W przeszłości wiele problemów zgłaszanych przez użytkowników spowodowanych było korzystaniem z nieprawidłowo sformatowanych dyskietek, dlatego też zwracamy na to uwagę.

Jeżeli do przygotowania dyskietek służy nam komputer z FreeBSD, również powinniśmy je sformatować. Dyskietki nie muszą być formatowane w DOS-owym systemie plików. Możemy utworzyć na nich system plików UFS, za pomocą poleceń `bsdlabel` i `newfs`, wywołanych w następujący sposób (na przykładzie dyskietek 3.5" 1.44 MB):

[source,bash]
....
# fdformat -f 1440 fd0.1440
# bsdlabel -w -r fd0.1440 floppy3
# newfs -t 2 -u 18 -l 1 -i 65536 /dev/fd0
....

[NOTE]
====
W przypadku dyskietek 5.25" 1.2 MB, wpisalibyśmy odpowiednio `fd0.1200` i `floppy5`.
====

Po takiej operacji dyskietki będzie można zamontować i zapisywać na nich dane tak samo, jak na innych systemach plików.

Po sformatowaniu dyskietek należy skopiować na nie pliki. Pliki dystrybucyjne podzielone są na kawałki o wygodnych rozmiarach, tak aby pięć z nich mieściło się na typowej dyskietce 1.44 MB. Umieśćmy na każdej z dyskietek tyle plików, ile się zmieści, aż wszystkie pliki dystrybucyjne znajdą się na dyskietkach. Pliki powinny być umieszczone w odpowiednim katalogu na dyskietce, np.: [.filename]#a:\bin\bin.aa#, [.filename]#a:\bin\bin.ab#, itd.

Podczas instalacji, gdy pojawi się ekran wyboru nośnika (Media), wybieramy [.guimenuitem]#Floppy# (dyskietki). Dalej poprowadzi nas program instalacyjny.

[[install-msdos]]
=== Instalacja z partycji MS-DOS(R)

By można było zainstalować FreeBSD z partycji MS-DOS(R), kopiujemy pliki dystrybucyjne do katalogu [.filename]#freebsd# w głównym katalogu partycji - na przykład [.filename]#c:\freebsd#. Wewnątrz tego katalogu musi być częściowo zachowana struktura katalogów płyty CDROM lub serwera FTP, jeśli więc kopiujemy pliki z płyty CD, dobrze jest skorzystać z DOS-owego polecenia `xcopy`. Dla przykładu, poniższe polecenia przygotują minimalną instalację FreeBSD:

[source,bash]
....
C:\> md c:\freebsd
C:\> xcopy e:\bin c:\freebsd\bin\ /s
C:\> xcopy e:\manpages c:\freebsd\manpages\ /s
....

W przykładzie założyliśmy, że miejsce dla FreeBSD mamy na dysku [.filename]#C:#, a napęd CDROM dostępny jest jako dysk [.filename]#E:#.

Jeśli nie dysponujemy napędem CDROM, pliki dystrybucyjne możemy pobrać z link:ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/{rel120-current}-RELEASE/[ftp.FreeBSD.org]. Każdy zestaw plików umieszczony jest w oddzielnym katalogu; na przykład zestaw _base_ znajduje się w katalogu link:ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/i386/{rel120-current}-RELEASE/base/[{rel120-current}/base/].

Zestawy plików, które chcemy instalować z partycji MS-DOS(R) (i dla których jest na niej odpowiednio dużo wolnego miejsca), umieszczamy w katalogu [.filename]#c:\freebsd#. Na potrzeby instalacji minimalnej wystarczy zestaw `BIN`.

=== Przygotowanie taśmy instalacyjnej

Instalacja z taśmy jest jedną z najprostszych metod, obok instalacji przez FTP i instalacji z płyty CD. Program instalacyjny zakłada, że taśma po prostu zawiera pliki w postaci archiwum tar. Interesujące nas pliki dystrybucyjne archiwizujemy na taśmie:

[source,bash]
....
# cd /freebsd/distdir
# tar cvf /dev/rwt0 dist1 ... dist2
....

Przeprowadzając instalację powinniśmy upewnić się, że dysponujemy odpowiednią ilością wolnego miejsca w jakimś katalogu tymczasowym (będziemy mieć możliwość wyboru tego katalogu), by pomieścić _pełną_ zawartość przygotowanej wcześniej taśmy. Ze względu na to, że dostęp do danych na taśmie nie jest swobodny, taki rodzaj instalacji będzie wymagać dość sporej przestrzeni tymczasowej. Można założyć, że potrzeba będzie tyle przestrzeni, ile zajmują dane zapisane na taśmie.

[NOTE]
====
Rozpoczynając instalację pamiętajmy, by taśma była umieszczona w napędzie _przed_ uruchomieniem komputera z dyskietki startowej. W przeciwnym razie napęd taśmowy może nie zostać wykryty podczas rozpoznawania urządzeń.
====

=== Przed instalacją przez sieć

Są trzy możliwości instalacji przez sieć: port szeregowy (SLIP lub PPP), port równoległy (PLIP (kabel laplink)) lub Ethernet (typowa karta sieciowa Ethernet (także PCMCIA)).

Obsługa protokołu SLIP jest dosyć prymitywna i ogranicza się do bezpośrednich połączeń, jak choćby kabel łączący komputer przenośny z innym komputerem. Połączenie musi być bezpośrednie, ponieważ instalacja za pośrednictwem SLIP nie umożliwia dzwonienia; jest to możliwe w przypadku PPP, dlatego też powinno się używać PPP zamiast SLIP, o ile to możliwe.

Jeżeli korzystamy z modemu, to PPP jest najprawdopodobniej jedyną możliwością. Zawczasu przygotujmy sobie informacje od dostawcy usług sieciowych, ponieważ będą nam one potrzebne na wczesnym etapie instalacji.

Jeśli łącząc się z dostawcą usług sieciowych używamy PAP lub CHAP (innymi słowy, jeśli w Windows(R) możemy uzyskać połączenie bez korzystania ze skryptu), wówczas wystarczy, że w linii poleceń ppp wpiszemy `dial`. W przeciwnym razie będziemy musieli połączyć się z dostawcą usług sieciowych za pomocą "poleceń AT", zależnych od typu modemu, gdyż do dyspozycji będziemy mieć jedynie uproszczony emulator terminala. Więcej informacji znajdziemy w poświęconych user-ppp częściach crossref:ppp-and-slip[userppp,Podręcznika] i link:{faq}#ppp/[FAQ]. Jeśli wystąpią problemy, możemy posłużyć się poleceniem `set log local ...`, by komunikaty były pokazywane na ekranie.

Jeżeli dysponujemy bezpośrednim połączeniem z innym komputerem z FreeBSD (w wersji 2.0-R lub późniejszej), wówczas mamy również możliwość instalacji przez port równoległy. Prędkość transmisji danych portem równoległym jest zwykle znacznie wyższa niż prędkość przesyłania portem szeregowym (do 50 kilobajtów/sekundę), dzięki czemu instalacja przebiega szybciej.

Najszybszym wariantem instalacji poprzez sieć jest wykorzystanie karty sieciowej Ethernet. FreeBSD obsługuje większość popularnych kart sieciowych; lista obsługiwanych kart (wraz z ich ustawieniami) znajduje się w dokumencie Hardware Notes, dołączonym do każdego wydania FreeBSD. Jeżeli korzystamy z karty sieciowej PCMCIA, pamiętajmy o tym, by była ona włożona _przed_ włączeniem komputera. Niestety, jak dotąd FreeBSD nie obsługuje wkładania kart PCMCIA w trakcie instalacji.

Będziemy musieli znać nasz adres IP, maskę podsieci, oraz nazwę naszego komputera. Jeśli instalujemy za pośrednictwem PPP i nie mamy statycznego adresu IP, nie musimy się przejmować, gdyż adres IP może być przydzielony dynamicznie przez dostawcę usług. Administrator sieci może nam podpowiedzieć, jakie parametry podać podczas konfiguracji sieci. Jeśli do połączeń z innymi stacjami będziemy używać ich nazw, a nie adresów IP, to dodatkowo będziemy musieli znać adres serwera nazw i prawdopodobnie adres bramy (w przypadku PPP jest to adres IP dostawcy). Jeżeli mamy zamiar instalować za pośrednictwem FTP i proxy HTTP, będzie nam ponadto potrzebny adres proxy. Skontaktujmy się z administratorem sieci lub dostawcą usług sieciowych _przed_ rozpoczęciem instalacji, jeśli nie znamy któregoś z wymienionych powyżej adresów.

==== Przed instalacją przez NFS

Instalacja przez NFS jest raczej mało skomplikowana. Wystarczy po prostu skopiować wybrane pliki dystrybucyjne na serwer, następnie podczas instalacji wybrać NFS jako nośnik i wskazać serwer.

Jeżeli serwer wymaga stosowania "uprzywilejowanego portu" (zwykle jest tak w przypadku stacji roboczych Sun), musimy to zaznaczyć w menu menu:Options[] (opcja `NFS Secure`), zanim rozpoczniemy instalację.

Jeśli nasza karta sieciowa jest niezbyt dobrej jakości i nie grzeszy prędkością, możemy włączyć opcję `NFS Slow`.

Instalacja przez NFS wymaga, by serwer obsługiwał montowanie podkatalogów, na przykład jeśli katalog dystrybucyjny FreeBSD {rel120-current} znajduje się w: [.filename]#ziggy:/usr/archive/stuff/FreeBSD#, to serwer `ziggy` musi umożliwiać bezpośrednie montowanie katalogu [.filename]#/usr/archive/stuff/FreeBSD#, a nie tylko [.filename]#/usr#, lub [.filename]#/usr/archive/stuff#.

We FreeBSD w pliku [.filename]#/etc/exports# możliwość montowania podkatalogów włącza się opcją `-alldirs`. W innych serwerach NFS może być inaczej. Jeśli otrzymujemy od serwera komunikaty o treści "permission denied" (odmowa dostępu), prawdopodobnie jest to spowodowane właśnie nieprawidłowym ustawieniem wspomnianej opcji.
