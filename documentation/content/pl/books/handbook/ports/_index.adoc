---
title: "Rozdział 4. Instalacja programów: pakiety i porty"
part: Część I. Pierwsze kroki
prev: books/handbook/basics
next: books/handbook/x11
showBookMenu: true
weight: 6
path: "/books/handbook/ports/"
---

[[ports]]
= Instalacja programów: pakiety i porty
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 4
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/ports/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[ports-synopsis]]
== Streszczenie

System FreeBSD rozprowadzany jest wraz z bogatą kolekcją narzędzi systemowych. Tym nie mniej, stanowi to absolutne minimum. Szybko pojawia się bowiem potrzeba zainstalowania dodatkowego oprogramowania, by móc rozpocząć prawdziwą pracę z systemem. FreeBSD dostarcza dwóch dopełniających się metod instalacji oprogramowania: kolekcję portów FreeBSD (kompilacja programów ze źródeł) i system pakietów (instalacja z gotowych binariów). Każda z tych metod może zostać wykorzystana do instalacji najnowszych wersji ulubionego oprogramowania z lokalnych nośników bądź bezpośrednio z sieci.

Przeczytawszy ten rozdział dowiemy się:

* Jak instalować oprogramowanie innych producentów dostarczane w postaci binarnej.
* Jak kompilować oprogramowanie innych producentów z wykorzystaniem kolekcji portów.
* Jak usunąć poprzednio zainstalowane pakiety bądź porty.
* Jak zmienić domyślne wartości wykorzystywane przy kompilacji portów.
* Jak odnaleźć właściwe oprogramowanie.
* Jak zaktualizować wykorzystywane aplikacje.

[[ports-overview]]
== Omówienie instalacji oprogramowania

Osoby, które już wcześniej pracowały z systemami UNIX(R) wiedzą, że typowy proces instalacji oprogramowania sprowadza się mniej więcej do następujących punktów:

[.procedure]
====
. Pobranie programu, który może być rozprowadzany w postaci kodu źródłowego bądź binarnej.
. Rozpakowania programu z formatu w jakim jest rozprowadzany (najczęściej jest to plik tar skompresowany za pomocą man:compress[1], man:gzip[1] lub man:bzip2[1]).
. Odnalezienie dokumentacji (najczęściej plik [.filename]#INSTALL# lub [.filename]#README# bądź pliki w podkatalogu [.filename]#doc/#) i zapoznanie się z instrukcjami instalacji programu.
. Kompilacja programu, jeśli rozprowadzany jest w postaci źródłowej. Może to wymagać również wykonania dodatkowych czynności, jak np. edycji pliku [.filename]#Makefile# bądź uruchomienia skryptu `configure`.
. Weryfikacja i instalacja aplikacji.
====

Wszystko to przy założeniu, że w między czasie nie pojawiły się żadne trudności. Instalacja oprogramowania, które nie było przygotowywane z myślą o FreeBSD może wymagać nawet modyfikacji kodu źródłowego nim zacznie poprawnie funkcjonować.

Oczywiście, we FreeBSD można instalować oprogramowanie "tradycyjnym" sposobem. Jednakże system ten posiada dwa rozwiązania, które potrafią zaoszczędzić mnóstwo czasu i trudu: pakiety i porty. W chwili pisania tego tekstu, dostępnych za pomocą tych systemów jest przeszło {numports} aplikacji.

Dla każdego programu dostępny jest do pobrania pojedynczy pakiet, który zawiera skompilowane kopie plików aplikacji, zarówno plików uruchomieniowych jak i konfiguracyjnych czy dokumentacji. Pobranym plikiem można manipulować za pomocą poleceń man:pkg_add[1], man:pkg_delete[1], man:pkg_info[1], itp. Nowe programy można instalować za pomocą zaledwie jednego polecenia.

Port natomiast, jest zbiorem plików mających za zadanie zautomatyzować proces kompilacji danego programu z kodu źródłowego.

O ile typowa kompilacja programu składa się z wielu czynności wykonywanych przez użytkownika, o tyle pliki składające się na port zawierają dostateczną ilość informacji aby pozwolić systemowi zrobić to za nas. Wystarczy wprowadzić kilka prostych poleceń a system automatycznie pobierze kod źródłowy programu, rozpakuje, nałoży łatki, skompiluje i zainstaluje za nas.

Ponadto system portów może również posłużyć do przygotowania pakietów, którymi następnie można manipulować za pomocą `pkg_add` i innymi poleceniami zarządzających pakietami.

Obydwa systemy potrafią analizować _zależności_ występujące pomiędzy aplikacjami. Załóżmy, że chcemy zainstalować program, który zależy od pewnej biblioteki. Zarówno program jak i biblioteka dostępne są w systemach portów i pakietów FreeBSD. Niezależnie od tego czy wykorzystamy polecenie `pkg_add` czy porty, by zainstalować program, to obydwa systemy spostrzegą, że biblioteka nie została zainstalowana i automatycznie zainstalują najpierw bibliotekę.

Można by się zastanawiać dlaczego FreeBSD wykorzystuje obydwa systemy, skoro ich działanie jest tak bardzo podobne. Tak pakiety jak i porty posiadają pewne zalety. Który system wykorzystamy zależy od naszych własnych upodobań.

.Zalety pakietów
* Skompresowany plik pakietu zajmuje z reguły mniej miejsca niż skompresowany plik zawierający kod źródłowy.
* Instalacja pakietów nie wymaga dodatkowej kompilacji. W przypadku dużych aplikacji, jak np. Mozilla, KDE czy GNOME może to być istotne. Szczególnie gdy pracuje się na dość wolnej maszynie.
* Stosowanie pakietów nie wymaga żadnej wiedzy o procesie kompilowania oprogramowania w systemie FreeBSD.

.Zalety portów
* Pakiety są z reguły kompilowane z dość typowymi opcjami, ponieważ powinny być przydatne do wykorzystania na maksymalnej liczbie komputerów. Instalując programy z portów mamy możliwość "podkręcenia" opcji kompilacji, by (przykładowo) skompilować program zoptymalizowany dla procesorów Pentium IV lub Athlon.
* Niektóre aplikacje posiadają pewne opcje kompilacji związane z zadaniami, które maja realizować. Przykładowo Apache może zostać skompilowany z wieloma różnorodnymi opcjami. Kompilując go z portów nie musimy zgadzać się na domyślne opcje mogąc samemu dokonać wyboru.
+ 
W niektórych przypadkach dostępnych jest kilka pakietów tej samej aplikacji skompilowanych z różnymi parametrami. Na przykład program Ghostscript dostępny jest jako pakiet [.filename]#ghostscript# oraz [.filename]#ghostscript-nox11#, zależnie od tego czy mamy zainstalowany serwer X11. O ile tego typu rozwiązania są teoretycznie możliwe do zrealizowania w systemie pakietów, o tyle staje się to praktycznie niemożliwe gdy aplikacja posiada więcej niż kilka różnych opcji kompilacji.
* Warunki licencji niektórych aplikacji zabraniają rozprowadzania w postaci binarnej. Muszą być zatem rozprowadzane jako kod źródłowy.
* Niektórzy nie ufają pakietom binarnym. W przypadku kodu źródłowego można (przynajmniej w teorii) przejrzeć go i samemu poszukać potencjalnych luk.
* Jeśli posiadamy własne łaty będziemy potrzebowali kodu źródłowego aby je nanieść do programu.
* Jeszcze inni po prostu lubią mieć pod ręką kod źródłowy, by móc go poczytać gdy się nudzą, zmodyfikować czy zapożyczyć pewne rozwiązania (o ile pozwala na to licencja), itd.

Najlepszym sposobem śledzenia zmian dokonywanych w systemie portów jest zapisanie się na {freebsd-ports} oraz {freebsd-ports-bugs}.

[WARNING]
====

Przed instalacją jakiejkolwiek aplikacji należy sprawdzić na stronie http://vuxml.freebsd.org/[http://vuxml.freebsd.org/] czy w danym programie istnieją luki związane bezpieczeństwem.

Alternatywnie możemy zainstalować package:security/portaudit[], który automatycznie sprawdza wszystkie instalowane programy pod względem znanych luk bezpieczeństwa; weryfikowane są również porty przed kompilacją. W między czasie można wykorzystać polecenie `portaudit -F -a`, by sprawdzić zainstalowane już pakiety.
====

Pozostała część niniejszego rozdziału ma za zadanie wyjaśnić jak z wykorzystaniem systemu pakietów i portów instalować w systemie FreeBSD oprogramowanie innych producentów.

[[ports-finding-applications]]
== Odnalezienie programu dla siebie

Nim przystąpimy do instalacji programów musimy wiedzieć co chcemy zainstalować i jak się nazywa.

Lista dostępnych we FreeBSD programów rośnie cały czas. Na szczęście jest wiele sposobów na odnalezienie tego czego szukamy:

* Na stronie internetowej FreeBSD pod adresem link:https://www.FreeBSD.org/ports/[http://www.FreeBSD.org/ports/] znajduje jest aktualna lista dostępnych programów. Listę można dowolnie przeszukiwać według kilku kryteriów, np. nazwy (jeśli ją znamy). Możliwe jest również przejrzenie spisu wszystkich aplikacji znajdujących się w danej kategorii.
* Dzięki stronie FreshPorts (http://www.FreshPorts.org/[http://www.FreshPorts.org/]) prowadzonej przez Dana Langille'a możliwe jest bieżące śledzenie zmian aplikacji w drzewie portów. Witryna umożliwia otrzymywanie informacji drogą emailową o zmianach w wybranych portach.
* Jeśli nie znamy nazwy programu, który chcemy zainstalować, warto poszukać go na stronach pokroju FreshMeat (http://www.freshmeat.net/[http://www.freshmeat.net/]) a następnie sprawdzić na stronie FreeBSD czy został przygotowany odpowiedni port.
* Jeśli znamy dokładną nazwę portu a chcemy sprawdzić z jakiej pochodzi kategorii, można skorzystać z polecenia man:whereis[1]. Wystarczy wpisać `whereis plik`, gdzie _plik_ jest nazwą programu, którego poszukujemy. Otrzymany wynik będzie postaci:
+
[source,shell]
....
# whereis lsof
lsof: /usr/ports/sysutils/lsof
....
+ 
Przykład ten informuje nas, że program `lsof` (narzędzie systemowe) znajduje się w katalogu [.filename]#/usr/ports/sysutils/lsof#.
* Jeszcze innym sposobem na odnalezienie danego portu jest wykorzystanie mechanizmu przeszukiwania kolekcji portów. By skorzystać z tej funkcji należy przejść do katalogu [.filename]#/usr/ports#. Następnie wpisać `make search name=nazwa-programu`, gdzie _program-name_ jest nazwą poszukiwanej aplikacji. Przykładowo, szukając `lsof`:
+
[source,shell]
....
# cd /usr/ports
# make search name=lsof
Port:   lsof-4.56.4
Path:   /usr/ports/sysutils/lsof
Info:   Lists information about open files (similar to fstat(1))
Maint:  obrien@FreeBSD.org
Index:  sysutils
B-deps:
R-deps: 
....
+ 
Część wyniku, która nas interesuje to wiersz zaczynający się od "Path:", a określający lokalizację portu. Pozostałe z uzyskanych w ten sposób informacji nie zostaną tutaj opisane, gdyż nie są potrzebne do instalacji programu.
+ 
Szersze przeszukanie kolekcji portów możliwe jest wykorzystując `make search key=zwrot`, gdzie _zwrot_ jest dowolnym wyrazem. Opcja ta przeszukuje nazwy portów, komentarze, opisy i listy zależności. Może być wykorzystana do odnalezienia portów związanych z danym zagadnieniem gdy nie znamy nazwy poszukiwanego programu.
+ 
W obydwu przypadkach nie są rozróżniane małe i duże litery w poszukiwanym ciągu. Szukając zatem "LSOF" oraz "lsof" otrzymamy takie same wyniki.

[[packages-using]]
== Korzystanie z systemu pakietów

=== Instalacja pakietów

Programu man:pkg_add[1] można użyć do instalacji programów zarówno z dysku lokalnego, jak i z sieci.

.Ręczne pobranie pakietu i instalacja lokalna
[example]
====

[source,shell]
....
# ftp -a ftp2.FreeBSD.org
Connected to ftp2.FreeBSD.org.
220 ftp2.FreeBSD.org FTP server (Version 6.00LS) ready.
331 Guest login ok, send your email address as password.
230-
230-     This machine is in Vienna, VA, USA, hosted by Verio.
230-         Questions? E-mail freebsd@vienna.verio.net.
230-
230-
230 Guest login ok, access restrictions apply.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp> cd /pub/FreeBSD/ports/packages/sysutils/
250 CWD command successful.
ftp> get lsof-4.56.4.tgz
local: lsof-4.56.4.tgz remote: lsof-4.56.4.tgz
200 PORT command successful.
150 Opening BINARY mode data connection for 'lsof-4.56.4.tgz' (92375 bytes).
100% |**************************************************| 92375       00:00 ETA
226 Transfer complete.
92375 bytes received in 5.60 seconds (16.11 KB/s)
ftp> exit
# pkg_add lsof-4.56.4.tgz
....

====

Jeśli nie posiadamy lokalnego źródła programów (np na płytach CD FreeBSD), będzie Ci prawdopodobnie łatwiej użyć komendy man:pkg_add[1] z opcją `-r`. Spowoduje to, że program samodzielnie określi odpowiednią wersję oprogramowania dla naszej wersji systemu. Następnie pobierze odpowiedni plik z sieci oraz go zainstaluje.

[source,shell]
....
# pkg_add -r lsof
....

W powyższym przykładzie program pobierze właściwy pakiet i zainstaluje go bez jakiejkolwiek dalszej ingerencji użytkownika. Jeśli chcemy wskazać programowi alternatywny serwer lustrzany, należy odpowiednio zdefiniować zmienną środowiskową `PACKAGESITE`. Program man:pkg_add[1] do pobierania plików z serwerów wykorzystuje man:fetch[3], który z kolei wykorzystuje różnorodne zmienne środowiskowe, m.in. `FTP_PASSIVE_MODE`, `FTP_PROXY` oraz `FTP_PASSWORD`. Może się okazać, że będziemy musieli zdefiniować niektóre z nich jeśli nasz komputer znajduje się za zaporą ogniową, bądź musi korzystać z serwera pośredniczącego FTP/HTTP proxy. Więcej informacji znaleźć można w podręczniku systemowym programu man:fetch[3]. Warto zauważyć, iż w powyższym przykładzie jako nazwę pakietu podano jedynie `lsof` zamiast `lsof-4.56.4`. Przy zdalnym pobieraniu pakietów nie należy podawać numeru wersji pakietu. Program man:pkg_add[1] automatycznie pobierze najnowszą wersję aplikacji.

[NOTE]
====
Program man:pkg_add[1] pobierze najnowszą wersję aplikacji jedynie, gdy wykorzystujemy FreeBSD-CURRENT albo FreeBSD-STABLE. W przypadku -RELEASE pobrana zostanie wersja pakietu zbudowana dla danego wydania. Ograniczenie to można obejść modyfikując zmienną środowiskową `PACKAGESITE`. Na przykład, jeśli korzystamy z FreeBSD 5.4-RELEASE domyślnie man:pkg_add[1] będzie pobierał pakiety z `ftp://ftp.freebsd.org/pub/FreeBSD/ports/i386/packages-5.4-release/Latest/`. By zmusić go do pobierania pakietów zbudowanych dla FreeBSD 5-STABLE należy zmodyfikować zmienną `PACKAGESITE` by wskazywała na `ftp://ftp.freebsd.org/pub/FreeBSD/ports/i386/packages-5-stable/Latest/`.
====

Pakiety rozpowszechniane są w formacie [.filename]#.tgz# oraz [.filename]#.tbz#. Możemy je pobrać z link:ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/packages/[ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/packages/], w Polsce z link:ftp://ftp.pl.FreeBSD.org/pub/FreeBSD/ports/packages/[ftp://ftp.pl.FreeBSD.org/pub/FreeBSD/ports/packages/], bądź odnaleźć na płytach CDROM FreeBSD. Każda płyta z cztero płytowej dystrybucji (także PowerPak'a itp) zawiera pakiety w katalogu [.filename]#/packages#. Struktura katalogu podobna jest do drzewa portów [.filename]#/usr/ports#. Każda kategoria ma swój własny katalog, ponadto każdy pakiet może zostać odnaleziony w katalogu [.filename]#All# (Wszystkie).

Struktura katalogów pakietów jest identyczna względem struktury katalogów portów. Porty i pakiety kooperują za sobą, tworząc wspólnie cały system pakietów/portów.

=== Zarządzanie pakietami

Narzędziem służącym do przedstawienia informacji o zainstalowanych pakietach oraz wyświetlającym ich krótki opis jest man:pkg_info[1].

[source,shell]
....
# pkg_info
cvsup-16.1          A general network file distribution system optimized for CV
docbook-1.2         Meta-port for the different versions of the DocBook DTD
...
....

Program man:pkg_version[1] jest natomiast narzędziem, które podsumowuje wersje wszystkich zainstalowanych pakietów. Porównuje je następnie z tymi które znajdują się w drzewie portów.

[source,shell]
....
# pkg_version
cvsup                       =
docbook                     =
...
....

Symbol w drugiej kolumnie określa wiek zainstalowanej wersji oprogramowania względem wersji odnalezionej w portach.

[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| Symbol
| Znaczenie

|=
|Wersja odnaleziona w portach jest identyczna.

|<
|Wersja jest starsza, niż ta odnaleziona w portach.

|>
|Zainstalowana wersja jest nowsza, niż znaleziona w portach. (Prawdopodobnie lokalne drzewo portów nie zostało zaktualizowane.)

|?
|Zainstalowany pakiet nie może zostać odnaleziony w drzewie portów. (Może to mieć miejsce np. w sytuacji gdy zainstalowany port został usunięty z kolekcji portów, bądź zmienił nazwę.)

|*
|Istnieje wiele wersji tego programu.
|===

=== Usuwanie pakietów

Aby usunąć uprzednio zainstalowane oprogramowanie użyj man:pkg_delete[1].

[source,shell]
....
# pkg_delete xchat-1.7.1
....

=== Dodatkowe informacje

Wszystkie informacje o pakietach znajdują się w katalogu [.filename]#/var/db/pkg#. Lista zainstalowanych plików, a także opis każdej paczki można odnaleźć właśnie w tym katalogu. 

[[ports-using]]
== Korzystanie z kolekcji portów

Poniższy podrozdział dostarcza podstawowych informacji z zakresu używania kolekcji portów, w stopniu umożliwiającym instalowanie lub odinstalowywanie programów z własnego systemu. Szczegółowy opis parametrów polecenia `make` i zmiennych środowiskowych dostępny jest w podręczniku systemowym man:ports[7].

[[ports-tree]]
=== Pozyskanie kolekcji portów

Zanim zainstalujemy jakikolwiek port, musimy pobrać kolekcję portów, która w zasadzie jest zestawem plików [.filename]#Makefiles#, łat i opisowych. Kolekcja znajduje się w katalogu [.filename]#/usr/ports#.

W trakcie instalacji FreeBSD, sysinstall zapytał czy chcemy zainstalować kolekcję portów. Jeśli wybraliśmy nie, poniższe instrukcje pomogą nam własnoręcznie zainstalować kolekcję portów:

[.procedure]
====
*Procedure: Metoda CVSup*

Jest to prosta i szybka metoda pobrania kolekcji portów wykorzystująca system CVSup. Więcej informacji o CVSup dostępnych jest w podrozdziale crossref:mirrors[cvsup,Korzystanie z CVSup].

Bardzo ważnym jest, aby upewnić się, że katalog [.filename]#/usr/ports# jest pusty nim po raz pierwszy uruchomimy CVSup! Jeśli posiadamy już kolekcję portów pozyskaną z innego źródła CVSup nie usunie nieużywanych plików łat.

. Zainstaluj pakiet package:net/cvsup-without-gui[]:
+
[source,shell]
....
# pkg_add -r cvsup-without-gui
....
+ 
Więcej informacji w podrozdziale crossref:mirrors[cvsup-install,Instalacja CVSup] (crossref:mirrors[cvsup-install,Installation]).
. Uruchom `cvsup`:
+
[source,shell]
....
# cvsup -L 2 -h cvsup.FreeBSD.org /usr/shared/examples/cvsup/ports-supfile
....
+ 
Warto zastąpić _cvsup.FreeBSD.org_ adresem serwera CVSup zlokalizowanego bliżej nas. Kompletna lista serwerów lustrzanych dostępna jest w podrozdziale crossref:mirrors[cvsup-mirrors,Serwery lustrzane CVSup] (crossref:mirrors[cvsup-mirrors,CVSup Sites]).
+
[NOTE]
======
Można wykorzystać własny plik [.filename]#ports-supfile#, by np. uniknąć konieczności podawania adresu serwera CVSup z linii poleceń.

[.procedure]
.. W takim wypadku, jako użytkownik `root`, skopiuj plik [.filename]#/usr/shared/examples/cvsup/ports-supfile# do innego katalogu, np. [.filename]#/root# bądź własnego katalogu domowego.
.. Zmodyfikuj plik [.filename]#ports-supfile#.
.. Zmień wpis _CHANGE_THIS.FreeBSD.org_na adres wybranego serwera lustrzanego CVSup. Kompletna lista serwerów lustrzanych dostępna jest w podrozdziale crossref:mirrors[cvsup-mirrors,Serwery lustrzane CVSup] (crossref:mirrors[cvsup-mirrors,CVSup Sites]).
.. Teraz uruchom `cvsup` używając polecenia::
+
[source,shell]
....
# cvsup -L 2 /root/ports-supfile
....

======
+
. Późniejsze wpisanie polecenia man:cvsup[1] spowoduje sprawdzenie zmian dokonanych w kolekcji portów i aktualizację lokalnej wersji. Nie spowoduje to natomiast automatycznie ponownego skompilowania wykorzystywanych przez nas portów.
====

[.procedure]
====
*Procedure: Metoda Portsnap*

Portsnap jest alternatywnym systemem dystrybucji kolekcji portów. Po raz pierwszy został dołączony do FreeBSD 6.0. W starszych wersjach może zostać zainstalowany z pakietu package:sysutils/portsnap[]:

[source,shell]
....
# pkg_add -r portsnap
....

Szczegółowe informacje o możliwościach programu dostępne są w podrozdziale crossref:mirrors[portsnap,Korzystanie z Portsnap].

. Ten punkt możemy pominąć jeśli posiadamy FreeBSD 6.1-RELEASE bądź najnowszą wersję programu Portsnap. Przy pierwszym uruchomieniu programu man:portsnap[8] zostanie automatycznie utworzony katalog [.filename]#/usr/ports#. W starszych wersjach programu wymagane jest własnoręczne utworzenie katalogu:
+
[source,shell]
....
# mkdir /usr/ports
....
+
. Pobierz skompresowaną migawkę kolekcji portów do katalogu [.filename]#/var/db/portsnap#. Można następnie zakończyć połączenie z Internetem, jeśli jest taka potrzeba.
+
[source,shell]
....
# portsnap fetch
....
+
. Jeśli uruchamiany Portsnap po raz pierwszy należy rozpakować migawkę do katalogu [.filename]#/usr/ports#: 
+
[source,shell]
....
# portsnap extract
....
+ 
Jeśli posiadamy już kolekcję portów w [.filename]#/usr/ports# i jedynie ją aktualizujemy, wpisujemy polecenie:
+
[source,shell]
....
# portsnap update
....
====

[.procedure]
====
*Procedure: Metoda sysinstall*

Metoda ta instaluje kolekcję portów z lokalnego nośnika posługując się programem sysinstall. Zainstalowana zostanie kopia kolekcji z dnia, w którym przygotowana została dana wersja FreeBSD. Jeśli dysponujemy połączeniem z Internetem powinniśmy zawsze stosować jedną z metod opisanych powyżej.

. Uruchom `sysinstall` jako użytkownik `root` (`/stand/sysinstall` w wersjach FreeBSD starszych niż 5.2):
+
[source,shell]
....
# sysinstall
....
+
. Przejdź w dół, wybierz [.guimenuitem]#Configure#, i naciśnij kbd:[Enter].
. Przejdź w dół, wybierz [.guimenuitem]#Distributions# i naciśnij kbd:[Enter].
. Przejdź w dół do opcji [.guimenuitem]#ports# i naciśnij kbd:[Spację].
. Przejdź do góry do opcji [.guimenuitem]#Exit# i naciśnij kbd:[Enter].
. Ustaw wybrany przez siebie typ medium instalacji, jak np. płytę CDROM, serwer FTP, itd.
. Przejdź do góry do opcji [.guimenuitem]#Exit# i naciśnij kbd:[Enter].
. Naciśni kbd:[X] by wyjść z programu sysinstall.
====

[[ports-skeleton]]
=== Instalacja Portów

Pierwsza rzecz o jakiej należy wspomnieć omawiając kolekcję portów, jest "szkielet". Mówiąc w skrócie, szkielet portu jest minimalnym zestawem plików, które informują FreeBSD, jak poprawnie skompilować i zainstalować program. Każdy szkielet portu zawiera:

* Plik [.filename]#Makefile#. Plik ten zawiera różne dane określające jak skompilować aplikację oraz gdzie ją zainstalować w systemie.
* Plik [.filename]#distinfo# Plik ten zawiera informacje dotyczące plików, które muszą zostać pobrane, by skompilować port. Ponadto zawiera sumy kontrolne, na podstawie których man:md5[1] potrafi sprawdzić, czy pliki nie uległy uszkodzeniu w trakcie pobierania z sieci.
* Katalog [.filename]#files#, który zawiera łaty pozwalające skompilować i zainstalować program w naszym systemie FreeBSD. Łaty są małymi plikami, w których określone są zmiany dotyczące konkretnych plików. Są to pliki tekstowe i po prostu mówią "Usuń linię 10" lub "Zmień linię 26 na to: ...". Łatki są także znane jako "diffs" (ang. skrót od różnice) ponieważ są generowane przez program man:diff[1].
+ 
Ten katalog może zawierać także inne pliki używane do kompilacji portu.
* Plik opisu [.filename]#pkg-descr#. Jest to bardziej szczegółowy, nierzadko wieloliniowy opis programu.
* Plik listy [.filename]#pkg-plist#. Jest to lista wszystkich plików, które zostaną zainstalowane przez port. Jest to także lista plików, które należy usunąć w przypadku odinstalowywania.

Niekiedy porty zawierają również inne pliki, jak na przykład [.filename]#pkg-message# (message-wiadomość). System portów używa tych plików w specjalnych sytuacjach. Jeśli potrzebujesz więcej informacji na temat tych plików i portów w ogóle, zajrzyj do podręcznika extref:{porters-handbook}[FreeBSD Porter's Handbook].

Jak już raz powiedziano, porty zawierają instrukcje odnośnie kompilacji programów z kodu źródłowego. Jednakże nie zawierają one samego kodu. Kod pobrać można z płyty CD bądź z Internetu. Rozprowadzany może być w dowolnej postaci jaką wybierze sobie jego producent, przy czym najczęściej jest to spakowany plik tar skompresowany dodatkowo gzipem. Kod źródłowy programu nazywany jest "distfile". Poniżej przedstawione zostały dwie metody instalacji portów we FreeBSD.

[NOTE]
====
By móc zainstalować port musimy być zalogowania jako użytkownik `root`.
====

[WARNING]
====

Przed instalacją jakiegokolwiek portu należy upewnić się, że dysponujemy aktualną kolekcją portów oraz sprawdzić potencjalne luki bezpieczeństwa związane z danym portem na stronie http://vuxml.freebsd.org/[http://vuxml.freebsd.org/].

Istnieje możliwość zautomatyzowania procesu weryfikacji potencjalnych luk bezpieczeństwa przed instalacją portu. Do tego celu można wykorzystać program portaudit, dostępny również w kolekcji portów (package:security/portaudit[]). Wydanie polecenia `portaudit -F` przed instalacją nowego portu spowoduje pobranie aktualnej bazy luk bezpieczeństwa. Możliwe jest również wykonywanie regularnych aktualizacji bazy i rewizji zainstalowanego oprogramowania w trakcie codziennego przeglądu bezpieczeństwa systemu. Więcej informacji dostępnych jest na stronach podręcznika systemowego man:portaudit[1] i man:periodic[8].
====

Sposób funkcjonowania kolekcji portów wiąże się z założeniem, że posiadamy połączenie z Internetem. Jeśli nie, będziemy musieli ręcznie pobierać kod źródłowy "distfile" i umieszczać w katalogu [.filename]#/usr/ports/distfiles# dla każdego instalowanego portu.

By rozpocząć instalację należy przejść do katalogu wybranego portu:

[source,shell]
....
# cd /usr/ports/sysutils/lsof
....

Wewnątrz katalogu [.filename]#lsof# znajduje się szkielet portu. Następnym krokiem jest kompilacja programu, co sprowadza się do wpisania polecenia `make`. Efekt działania polecenia powinien być zbliżony do:

[source,shell]
....
# make
>> lsof_4.57D.freebsd.tar.gz doesn't seem to exist in /usr/ports/distfiles/.
>> Attempting to fetch from ftp://lsof.itap.purdue.edu/pub/tools/unix/lsof/.
===>  Extracting for lsof-4.57
...
[extraction output snipped]
...
>> Checksum OK for lsof_4.57D.freebsd.tar.gz.
===>  Patching for lsof-4.57
===>  Applying FreeBSD patches for lsof-4.57
===>  Configuring for lsof-4.57
...
[configure output snipped]
...
===>  Building for lsof-4.57
...
[compilation output snipped]
...
#
....

Po skończeniu kompilacji powracamy do linii poleceń. Kolejnym krokiem jest instalacja portu poprzez wpisanie polecenia `make` wraz ze słowem `install`:

[source,shell]
....
# make install
===>  Installing for lsof-4.57
...
[installation output snipped]
...
===>   Generating temporary packing list
===>   Compressing manual pages for lsof-4.57
===>   Registering installation for lsof-4.57
===>  SECURITY NOTE:
      This port has installed the following binaries which execute with
      increased privileges.
#
....

Gdy ponownie powrócimy do linii poleceń, powinniśmy być już w stanie uruchomić właśnie zainstalowaną aplikację. Ostrzeżenie jakie pojawi się na ekranie związane jest z faktem, że lsof jest programem pracującym ze zwiększonymi przywilejami. W trakcie kompilacji i instalacji portów powinniśmy zwracać uwagę na wszystkie pojawiające się ostrzeżenia.

Dobrym pomysłem, jest również usunięcie podkatalogu zawierającego wszystkie tymczasowe pliki wykorzystywane w trakcie kompilacji. Nie tylko dlatego, że niepotrzebnie zajmuje miejsce na dysku, ale również dlatego, że może być przyczyną problemów podczas aktualizacji programu do nowszej wersji.

[source,shell]
....
# make clean
===>  Cleaning for lsof-4.57
#
....

[NOTE]
====
Można sobie oszczędzić dwóch naddatkowych kroków wpisując od razu `make install clean` zamiast trzech osobnych poleceń `make`, `make install` oraz `make clean`.
====

[NOTE]
====
Niektóre powłoki utrzymują bufor listy poleceń z katalogów znajdujących się w zmiennej środowiskowej `PATH`. Ma to za zadanie przyśpieszyć wyszukiwanie plików binarnych tychże poleceń. Jeśli korzystamy z jednej z takich właśnie powłok może okazać się niezbędnym wydać polecenie `rehash` po instalacji portu, nim będziemy mogli wykorzystać nowo zainstalowany program. Polecenie to dostępne jest przy wykorzystaniu powłoki typu `tcsh`. Natomiast dla powłoki typu `sh` odpowiednikiem jest `hash -r`. Więcej informacji dostępnych jest w dokumentacji powłoki.
====

Niektóre wydawnictwa na płytach DVD-ROM, jak np. FreeBSD Toolkit z http://www.freebsdmall.com/[FreeBSD Mall], zawierają źródła distfile. Mogą być one wykorzystane z kolekcją portów. Wystarczy zamontować płytę DVD w [.filename]#/cdrom#. Jeśli natomiast używamy innego punktu montowania dla płyt musimy zmodyfikować zmienną `CD_MOUNTPTS` by wskazywała na właściwe miejsce. Niezbędne źródła distfile zostaną automatycznie wykorzystane jeśli znajdują się na płycie.

[NOTE]
====
Mimo wszystko należy mieć w pamięci, że licencje nielicznych portów nie zezwalają na załączenie ich na płycie CD-ROM. Może to być np. z powodu konieczności wcześniejszej rejestracji przed pobraniem źródeł bądź ich redystrybucja nie jest dozwolona. Jeśli chcemy zainstalować port, który nie znajduje się na płycie CD musimy mieć połączenie z Internetem.
====

System portów do pobierania plików wykorzystuje program man:fetch[1], który z kolei potrafi korzystać z wielu zmiennych środowiskowych, m.in. `FTP_PASSIVE_MODE`, `FTP_PROXY` czy `FTP_PASSWORD`. Jeśli znajdujemy się za zaporą ogniową, bądź musimy korzystać z serwera pośredniczącego FTP/HTTP proxy, może się okazać, że będziemy musieli ustawić niektóre z tych zmiennych. Kompletna lista wykorzystywanych zmiennych dostępna jest w podręczniku systemowym man:fetch[3].

Dla użytkowników nie mogących być cały czas połączonych z Internetem dostępne jest polecenie `make fetch`. Wystarczy wpisać to polecenie znajdując się w głównym katalogu drzewa portów ([.filename]#/usr/ports#) a wymagane pliki zostaną automatycznie pobrane. Polecenie to będzie również funkcjonować w podkatalogach, np. [.filename]#/usr/ports/net#. Jednakże, w takiej sytuacji _nie_ zostaną automatycznie pobrane źródła bibliotek, od których zależy dany port. Zamieniając parametr `fetch` na `fetch-recursive` spowodujemy pobranie również źródeł wszystkich portów, od których zależy instalowany program.

[NOTE]
====
Możliwe jest kompilowanie każdego portu z osobna w danej kategorii, bądź wszystkich na raz poprzez polecenie `make` wykonane, analogicznie do `make fetch`, w głównym katalogu kategorii. Jednakże jest to niebezpieczna metoda, gdyż niektóre porty nie mogą jednocześnie funkcjonować w systemie, bądź mogą zainstalować różne pliki o tej samej nazwie.
====

W naprawdę żadkich przypadkach, użytkownicy mogą pozyskać pliki distfile z innego źródła niż `MASTER_SITES` (miejsce skąd je pobiera system portów). Opcję `MASTER_SITES` można zastąpić za pomocą następującego polecenia:

[source,shell]
....
# cd /usr/ports/directory
# make MASTER_SITE_OVERRIDE= \
ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/distfiles/ fetch
....

W tym przykładzie zastąpiliśmy opcję `MASTER_SITES` adresem `ftp.FreeBSD.org/pub/FreeBSD/ports/distfiles/`.

[NOTE]
====
Niektóre porty umożliwiają (a nawet wymagają) podanie pewnych opcji kompilacji, które mogą włączyć bądź wyłączyć nie potrzebne części aplikacji, pewne opcje bezpieczeństwa i inne parametry. Z przychodzących na myśl tego typu programów to package:www/mozilla[], package:security/gpgme[] oraz package:mail/sylpheed-claws[]. Za każdym razem gdy dostępne będą tego typu opcje wyświetlony zostanie komunikat.
====

==== Ignorowanie domyślnych katalogów portów

Czasami okazuje się być przydatne (a nawet wymagane) by skorzystać z innych katalogów tymczasowych i docelowych. Domyślne katalogi można zastąpić wykorzystując zmienne `WRKDIRPREFIX` i `PREFIX`. Na przykład:

[source,shell]
....
# make WRKDIRPREFIX=/usr/home/example/ports install
....

spowoduje skompilowanie portu w katalogu [.filename]#/usr/home/example/ports# i instalację w podkatalogach [.filename]#/usr/local#.

[source,shell]
....
# make PREFIX=/usr/home/example/local install
....

spowoduje natomiast kompilację w katalogu [.filename]#/usr/ports# oraz instalację w podkatalogach [.filename]#/usr/home/example/local#.

I oczywiście,

[source,shell]
....
# make WRKDIRPREFIX=../ports PREFIX=../local install
....

spowoduje połącznie obydwu powyższych ustawień (jest to za długie by całkowicie zmieściło się na stronie, ale powinno dać ogólne wyobrażenie).

Alternatywnie, obydwie zmienne mogą być również określone jako zmienne środowiskowe. Informacje o definiowaniu zmiennych środowiskowych dostępne są w podręczniku systemowym naszej powłoki.

==== Jak poradzić sobie z `imake`

Niektóre porty wykorzystujące `imake` (część Systemu okien X) nie współpracują ze zmienną `PREFIX` i mimo wszystko będą instalowały programy w [.filename]#/usr/X11R6#. Podobnie niektóre z portów napisanych w języku Perl ignorują zmienną `PREFIX` i instalują programy w głównym drzewie Perla. Zmuszenie tych portów do współpracy ze zmienną `PREFIX` jest niezmiernie trudne, albo wręcz niemożliwe.

[[ports-removing]]
=== Usuwanie zainstalowanych portów

Teraz, gdy wiesz już jak instalować porty, zastanawiasz się prawdopodobnie jak je usuwać, na przykład w wypadku, gdy zainstalowaliśmy port, ale okazało się jednak, że to nie był ten którego szukaliśmy. W ramach przykładu usuniemy port, który instalowaliśmy poprzednio (dla tych którzy nie uważają, był to `lsof`). Podobnie jak w przypadku pakietów (szerzej opisane w podrozdziale traktującym o <<packages-using,pakietach>>), również porty usuwane są za pomocą polecenia man:pkg_delete[1]:

[source,shell]
....
# pkg_delete lsof-4.57
....

[[ports-upgrading]]
=== Aktualizacja portów

Na wstępie musimy wyświetlić zdezaktualizowane porty w kolekcji. Wykorzystamy do tego polecenie man:pkg_version[1]:

[source,shell]
....
# pkg_version -v
....

[[ports-file-updating]]
==== [.filename]#/usr/ports/UPDATING#

Po zaktualizowaniu kolekcji, a przed próbą aktualizacji jakichkolwiek portów, należy zapoznać się z zawartością pliku [.filename]#/usr/ports/UPDATING#. Plik ten opisuje różne zagadnienia i dodatkowe kroki, na które można natknąć się i będzie trzeba wykonać podczas aktualizacji, np. zmiany formatu plików czy zmiany w lokalizacji plików konfiguracyjnych.

Jeśli opis w pliku [.filename]#UPDATING# mówi coś innego niż ten tekst, należy zastosować się do opisu.

[[portupgrade]]
==== Aktualizacja portów z wykorzystaniem programu Portupgrade

Program portupgrade został zaprojektowany by ułatwić aktualizację zainstalowanych w systemie portów. Dostępny jest z portu package:sysutils/portupgrade[]. Jego instalacja przebiega dokładnie tak samo, jak każdego innego portu, wykorzystując polecenie `make install clean` command:

[source,shell]
....
# cd /usr/ports/sysutils/portupgrade
# make install clean
....

Przeskanujmy następnie listę zainstalowanych portów za pomocą polecenia `pkgdb -F` i usuńmy wszystkie niezgodności jakie nam zwróci skanowanie. Regularne skanowanie przed każdą aktualizacją jest zdecydowanie dobrym pomysłem.

Wydanie polecenia `portupgrade -a` spowoduje, że program portupgrade rozpocznie aktualizację wszystkich przedawnionych portów zainstalowanych w naszym systemie. Parametr `-i` pozwoli przejść w tryb interaktywny, gdzie będziemy musieli potwierdzić aktualizację każdego portu.

[source,shell]
....
# portupgrade -ai
....

By zaktualizować jedynie wybraną aplikację zamiast wszystkich portów należy wykorzystać polecenie `portupgrade nazwa_programu`. Opcja `-R` oznacza, że portupgrade powinien najpierw zaktualizować wszystkie porty, od których zależy dany program.

[source,shell]
....
# portupgrade -R firefox
....

By do instalacji wykorzystać pakiety zamiast portów należy dodać parametr `-P`. Wówczas portupgrade przeszuka katalogi zawarte w zmiennej `PKG_PATH`. Jeśli pakiet nie zostanie odnaleziony lokalnie zostanie pobrany z Internetu. Jeśli nie będzie możliwe żadne z powyższych, wówczas portupgrade wykorzysta do aktualizacji porty. By temu zapobiec należy zastosować parametr `-PP`.

[source,shell]
....
# portupgrade -PR gnome2
....

Aby pobrać jedynie pliki źródłowe distfiles (bądź pakiety, gdy wykorzystamy opcję `-P`) bez kompilacji czy instalacji czegokolwiek należy użyć parametru `-F`. Więcej informacji dostępnych jest w man:portupgrade[1].

[[portmanager]]
==== Aktualizacja portów z wykorzystaniem programu Portmanager

Kolejnym narzędziem ułatwiającym aktualizację zainstalowanych portów jest Portmanager, dostępny z portu package:sysutils/portmanager[]:

[source,shell]
....
# cd /usr/ports/sysutils/portmanager
# make install clean
....

Wszystkie zainstalowane porty mogą zostać zaktualizowane za pomocą polecenia:

[source,shell]
....
# portmanager -u
....

Wykorzystując parametr `-ui` przechodzimy w tryb interaktywny, gdzie będziemy pytani o potwierdzenie każdej operacji wykonywanej przez Portmanager. Program ten może być z równym powodzeniem wykorzystywany do instalacji nowych portów w systemie. W przeciwieństwie do polecenia `make install clean` program Portmanager zaktualizuje wszystkie zależności nim skompiluje i zainstaluje wybrany port.

[source,shell]
....
# portmanager x11/gnome2
....

Gdy wystąpią problemy z zależnościami wybranego portu można wykorzystać Portmanagera, by ponownie skompilował je we właściwej kolejności. Na koniec zostanie również ponownie skompilowany port stwarzający problemy.

[source,shell]
....
# portmanager graphics/gimp -f
....

Więcej informacji dostępnych jest na stronach podręcznika systemowego Portmanagera.

[[ports-disk-space]]
=== Porty i przestrzeń na dysku

Korzystanie z kolekcji portów z czasem odbije się na wolnym miejscu na dysku. Dlatego też zawsze po skompilowaniu i zainstalowaniu programu z portu powinniśmy pamiętać o usunięciu tymczasowych katalogów roboczych (ang. [.filename]#work# directories) wykorzystując do tego polecenie `make clean`. Całą kolekcję natomiast można oczyścić wpisujące polecenie:

[source,shell]
....
# portsclean -C
....

Z czasem uzbiera nam się wiele katalogów [.filename]#distfiles#, które będą jedynie zajmować przestrzeń na dysku. Możemy je ręcznie usuwać bądź posłużyć się następującym poleceniem, by usunąć wszystkie katalogi distfiles nie powiązane aktualnie z żadnym portem:

[source,shell]
....
# portsclean -D
....

Badź, by usunąć wszystkie katalogi disftiles, do których nie odnosi się żaden z aktualnie zainstalowanych portów w naszym systemie:

[source,shell]
....
# portsclean -DD
....

[NOTE]
====
Program `portsclean` jest częścią pakietu portupgrade.
====

Pamiętajmy również o usuwaniu instalowanych portów gdy już ich nie potrzebujemy. Przydatne narzędzie pozwalające zautomatyzować te czynności znajduje się w package:sysutils/pkg_cutleaves[].

[[ports-nextsteps]]
== Czynności po-instalacyjne

Po zainstalowaniu nowego programu z reguły chcemy zapoznać się z dostarczoną z nim dokumentacją, zmodyfikować wymagane pliki konfiguracyjne, upewnić się, że program (jeśli jest to demon) będzie uruchamiany w trakcie ładowania systemu, itp.

Oczywiście, szczegółowe kroki jakie należy podjąć konfigurując każdą aplikację będą różne. Tym nie mniej, jeśli właśnie zainstalowaliśmy nowy program i zastanawiamy się "Co dalej?" poniższe uwagi mogą okazać się pomocne:

* Za pomocą man:pkg_info[1] możemy sprawdzić gdzie i jakie pliki zostały zainstalowane. Na przykład, jeśli zainstalowaliśmy wersję 1.0.0 pakietu FooPackage, polecenie
+
[source,shell]
....
# pkg_info -L foopackage-1.0.0 | less
....
+ 
wyświetli nam wszystkie pliki zainstalowane z pakietu. Szczególną uwagę warto zwrócić na pliki zainstalowane w katalogach: [.filename]#man/# zawierającym strony podręcznika systemowego, [.filename]#etc/# zawierającym pliki konfiguracyjne, oraz [.filename]#doc/#, gdzie znajdować się będzie dużo obszerniejsza dokumentacja.
+ 
Jeśli nie jesteśmy pewni, którą wersją programu zainstalowaliśmy, polecenie
+
[source,shell]
....
# pkg_info | grep -i foopackage
....
+ 
wyświetli wszystkie zainstalowane pakiety zawierające _foopackage_ w nazwie. Oczywiście _foopackage_ należy zastąpić nazwą poszukiwanego pakietu.
* Gdy już udało się ustalić jakie strony podręcznika systemowego zostały zainstalowane przez dany pakiet, można je przeczytać za pomocą polecenia man:man[1]. Warto również obejrzeć przykładowe pliki konfiguracyjne i wszelką dodatkową dokumentację.
* Jeśli dana aplikacja posiada własną witrynę internetową warto jest również tam poszukać dodatkowej dokumentacji czy odpowiedzi na często zadawane pytania (FAQ). Jeśli nie znamy właściwego adresu internetowego może być on podany w wyniku polecenia
+
[source,shell]
....
# pkg_info foopackage-1.0.0
....
+ 
Wiersz `WWW:`, jeśli w ogóle jest podany, powinien zawierać informacje o adresie witryny.
* Programy, które powinny być uruchamiane podczas ładowania systemu (np. serwery internetowe) z reguły instalują przykładowy skrypt w [.filename]#/usr/local/etc/rc.d#. Powinniśmy sprawdzić zawartość tego skryptu oraz w razie potrzeby zmodyfikować go bądź zmienić nazwę. Szczegółowe informacje dostępne są w podrozdziale crossref:config[configtuning-starting-services,Uruchamianie usług].

[[ports-broken]]
== Jak radzić sobie ze źle przygotowanymi portami

Jeśli natknęliśmy się na port, który z jakichś powodów nie działa na naszym komputerze, możemy zrobić kilka następujących rzeczy:

. Sprawdzić w link:https://www.FreeBSD.org/support/#gnats[bazie danych zgłoszonych problemów] czy jest przygotowywana poprawka dla danego portu. Jeśli tak, może uda się nam zastosować tę poprawkę.
. Poprosić o pomoc opiekuna danego portu. Adres email opiekuna można znaleźć przeglądająć plik [.filename]#Makefile# w katalogu portu bądź wpisująć polecenie `make maintainer`. Wysyłając wiadomość pamiętajmy o zawarciu informacji o nazwie i wersji portu (najlepiej jest zawrzeć cały wiersz z pliku [.filename]#Makefile# zaczynający się od `$FreeBSD:`), oraz opis błędu i wynik działania programu w momencie zaistnienia błędu.
+
[NOTE]
====
Niektóre porty nie są przygotowywane przez pojedyncze osoby, ale raczej przez extref:{mailing-list-faq}[grupy dyskusyjne]. Wiele adresów takich grup, choć nie wszystkie, ma postać mailto:freebsd-listname@FreeBSD.org[freebsd-listname@FreeBSD.org]. Należy mieć również to na uwadze formułując swoje pytania.

Porty przygotowywane przez mailto:freebsd-ports@FreeBSD.org[freebsd-ports@FreeBSD.org] w rzeczywistości nie posiadają żadnego konkretnego opiekuna, ani grupy opiekunów. Poprawki i pomoc dla takich portów przygotowują osoby zapisane na tę listę dyskusyjną. Nowi ochotnicy są zawsze mile widziani!
====
+ 
W przypadku braku odpowiedzi można również przesłać zgłoszenie błędu poprzez man:send-pr[1] (szczegóły w artykule extref:{problem-reports}[Writing FreeBSD Problem Reports]).
. Naprawić błąd samemu! Podręcznik extref:{porters-handbook}[Porter's Handbook] (ang.) zawiera szczegółowe informacje o strukturze "Portów", dzięki czemu można samemu naprawić błąd lub przygotować własny port!
. Pobrać pakiet z najbliższego serwera FTP. "Główne" repozytorium pakietów znajduje się na serwerze `ftp.FreeBSD.org` w katalogu link:ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/packages/[packages]. Tym nie mniej warto jest najpierw odszukać http://mirrorlist.FreeBSD.org/[lokalny serwer lustrzany]. Szanse na to, że gotowe pakiety będą działać poprawnie są większe niż w przypadku kompilowania programów. Pakiety można zainstalować za pomocą programu man:pkg_add[1].
