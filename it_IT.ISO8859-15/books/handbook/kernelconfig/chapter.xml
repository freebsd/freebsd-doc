<?xml version="1.0" encoding="iso-8859-15"?>
<!--
     The FreeBSD Documentation Project

     $FreeBSD$
     Original revision: 1.176
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="kernelconfig">
  <info><title>Configurazione del Kernel di FreeBSD</title>
    <authorgroup>
      <author><personname><firstname>Jim</firstname><surname>Mock</surname></personname><contrib>Modificato e rivisto da </contrib></author>
    </authorgroup>

    <authorgroup>
      <author><personname><firstname>Jake</firstname><surname>Hamby</surname></personname><contrib>Grazie al contributo originale di </contrib></author>
    </authorgroup>
  </info>

  

  <sect1 xml:id="kernelconfig-synopsis">
    <title>Synopsis</title>

    <indexterm>
      <primary>kernel</primary>
      <secondary>compilare un kernel custom</secondary>
    </indexterm>

    <para>Il kernel è una componente fondamentale del sistema
      operativo &os;.  È responsabile di gestire la memoria,
      applicare controlli di sicurezza, gestire la rete, accesso
      ai dischi e molto altro.  Anche se sempre più parti di
      &os; diventano configurabili dinamicamente, è ancora
      necessario talvolta riconfigurare e ricompilare il kernel.</para>

    <para>Dopo aver letto questo capitolo, saprai:</para>

    <itemizedlist>
      <listitem>
        <para>Perchè potresti aver bisogno di
          ricompilare un kernel.</para>
      </listitem>

      <listitem>
        <para>Come scrivere un file di configurazione del kernel,
          o come alterarne uno esistente.</para>
      </listitem>

      <listitem>
        <para>Come usare il file di configurazione del kernel
          per creare un nuovo kernel.</para>
      </listitem>

      <listitem>
        <para>Come installare il nuovo kernel.</para>
      </listitem>

      <listitem>
        <para>Come fare del troubleshooting se qualcosa
          va storto.</para>
      </listitem>
    </itemizedlist>

    <para>Tutti i comandi elencati in questo capitolo negli esempi
      dovrebbero essere eseguiti come <systemitem class="username">root</systemitem>
      affinchè abbiano successo.</para>
  </sect1>

  <sect1 xml:id="kernelconfig-custom-kernel">
    <title>Perchè creare un kernel custom?</title>

    <para>Tradizionalmente, &os; ha sempre avuto quello che si chiama
      un kernel <quote>monolitico</quote>.  Questo significa che
      il kernel era un programma di grandi dimensioni, supportava una
      lista fissa di device, e se tu avessi voluto cambiare il
      comportamento del kernel avresti dovuto compilarne uno nuovo,
      quindi fare il reboot del tuo computer per caricare il
      nuovo kernel.</para>

    <para>Oggi come oggi, &os; si sta muovendo rapidamente verso un
      modello dove gran parte delle funzionalità del kernel
      sono contenute in moduli che possono essere caricati
      e scaricati dal kernel a seconda delle necessità.
      Questo permette al kernel di adattarsi a nuovo hardware
      appena questo diventa disponibile (come ad esempio
      le carte PCMCIA in un laptop), oppure fa sì che
      nuove funzionalità siano portate nel kernel,
      funzionalità che non erano necessarie quando il kernel
      fu compilato inizialmente.  Questo è noto come kernel
      modulare.</para>

    <para>Nonostante questo, è ancora necessario portare
      avanti delle compilazioni statiche del kernel.  In alcuni
      casi questo è necessario perchè la
      funzionalità è così legata al kernel che
      non può essere resa caricabile dinamicamente.
      In altri casi può essere necessario semplicemente perchè
      nessuno si è ancora preso il tempo di scrivere un modulo
      caricabile dinamicamente per quella funzionalità.</para>

    <para>Compilare un kernel custom è uno dei più comuni riti
      di passaggio che quasi ogni utente BSD deve superare.  Questo
      processo, anche se è dispendioso di tempo, offrirà
      molti benefici al tuo sistema &os;.  A differenza del kernel
      <filename>GENERIC</filename>, che deve supportare un
      gran numero di dispositivi hardware, un kernel custom contiene
      supporto solo per l'hardware del <emphasis>tuo</emphasis> PC.
      Questo presenta dei vantaggi, fra cui:</para>

    <itemizedlist>
      <listitem>
        <para>Tempo di boot più veloce.  Dato che il kernel
          cercherà di riconoscere solo l'hardware che hai sul
          tuo sistema, il tempo che ci vuole al tuo sistema per fare boot
          diminuirà drammaticamente.</para>
      </listitem>

      <listitem>
        <para>Minore uso della memoria.  Un kernel custom spesso
          usa meno memoria del kernel <filename>GENERIC</filename>,
          il che è importante dato che il kernel deve sempre
          essere presente nella memoria reale.  Per questo motivo
          un kernel custom è particolarmente utile su sistemi
          con poca RAM.</para>
      </listitem>

      <listitem>
        <para>Supporto per hardware addizionale.  Un kernel custom
          ti permette di aggiungere supporto per device che non sono
          presenti nel kernel <filename>GENERIC</filename>, come ad
          esempio sound card.</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 xml:id="kernelconfig-building">
    <title>Compilare ed installare un Kernel Custom</title>

    <indexterm>
      <primary>kernel</primary>
      <secondary>compilare / installare</secondary>
    </indexterm>

    <para>Per prima cosa, facciamo un breve giro nella directory
      di compilazione del kernel.  Tutte le directory menzionate
      saranno relative alla directory principale
      <filename>/usr/src/sys</filename>, che è accessibile
      attraverso il path <filename>/sys</filename>.  Ci sono
      un certo numero di sottodirectory qua che rappresentano
      parti differenti del kernel, ma la più importante
      per i nostri scopi è
      <filename>arch/conf</filename>,
      dove editerai il tuo file
      di configurazione del kernel, e <filename>compile</filename>,
      che è l'area di passaggio dove il tuo kernel sarè
      compilato.  <replaceable>arch</replaceable> rappresenta uno
      fra <filename>i386</filename>, <filename>alpha</filename>,
      <filename>amd64</filename>, <filename>ia64</filename>,
      <filename>powerpc</filename>, <filename>sparc64</filename>,
      o <filename>pc98</filename> (un tipo di sviluppo alternativo
      di hardware PC in Giappone).  Tutto ciò che è
      all'interno di particolare directory di architettura ha a che fare
      solo con quell'architettura; il resto è codice
      indipendente dalla macchina, comune a tutte le piattaforme
      sulle quali &os; potrebbe potenzialmente essere portato.
      Nota l'organizzazione logica della struttura dele directory,
      con ogni device supportato, file system e opzioni nelle proprie
      sottodirectory.</para>

    <para>Questo capitolo assume che tu stia usando la architettura
      i386 negli esempi.  Se questo non è il caso, fai gli appropriati
      aggiustamenti per correggere i percorsi alla tua architettura.</para>

    <note>
      <para>Se <emphasis>non</emphasis> c'è una directory
        <filename>/usr/src/sys</filename> sul tuo sistema,
        significa che i sorgenti del kernel non sono stati installati.
        Il modo più semplice per farlo è eseguire
        <command>sysinstall</command>
        come <systemitem class="username">root</systemitem>, scegliendo
        <guimenuitem>Configure</guimenuitem>, poi
        <guimenuitem>Distributions</guimenuitem>, poi
        <guimenuitem>src</guimenuitem>, poi <guimenuitem>base</guimenuitem>
        e <guimenuitem>sys</guimenuitem>.  Se hai un'avversione
        verso <application>sysinstall</application> e hai accesso
        ad un CDROM <quote>ufficiale</quote> &os;, allora puoi installare
        i sorgenti dalla linea di comando:</para>

      <screen>&prompt.root; <userinput>mount /cdrom</userinput>
&prompt.root; <userinput>mkdir -p /usr/src/sys</userinput>
&prompt.root; <userinput>ln -s /usr/src/sys /sys</userinput>
&prompt.root; <userinput>cat /cdrom/src/ssys.[a-d]* | tar -xzvf -</userinput>
&prompt.root; <userinput>cat /cdrom/src/sbase.[a-d]* | tar -xzvf -</userinput></screen>
    </note>

    <para>Quindi, entra nella directory
      <filename>arch/conf</filename>
      e copia il file di configurazione del kernel con il nome
      che vuoi dare al kernel.  Ad esempio:</para>

    <screen>&prompt.root; <userinput>cd /usr/src/sys/i386/conf</userinput>
&prompt.root; <userinput>cp GENERIC MYKERNEL</userinput></screen>

    <para>Tradizionalmente, questo nome è tutto in lettere
      maiuscole e, se stai mantenendo molte macchine &os; con hardware
      differente, è una buona idea dargli il nome della macchina.
      Noi lo chiamemeremo <filename>MYKERNEL</filename> a titolo di
      esempio.</para>

    <tip>
      <para>Conservare il tuo file di configurazione del kernel
        direttamente sotto <filename>/usr/src</filename> può
        essere una cattiva idea.  Se stai incontrando problemi
        puoi essere tentato di cancellare <filename>/usr/src
        </filename> e partire da zero.  Dopo averlo fatto,
        di solito ci vogliono pochi secondi per realizzare
        che hai appena cancellato il tuo file di configurazione del
        kernel.  Inoltre, non editare <filename>GENERIC</filename>
        direttamente, dato che potrebbe essere sovrascritto
        la prossima volta che <link linkend="cutting-edge">
        aggiorni i tuoi sorgenti</link>, e le tue modifiche
        andranno perse.</para>

      <para>Piuttosto tieni il tuo file di configurazione
        del kernel da qualche altra parte, e crea un link simbolico
        al file nella directory <filename>i386
        </filename>.</para>

      <para>Ad esempio:</para>

      <screen>&prompt.root; <userinput>cd /usr/src/sys/i386/conf</userinput>
&prompt.root; <userinput>mkdir /root/kernels</userinput>
&prompt.root; <userinput>cp GENERIC /root/kernels/MYKERNEL</userinput>
&prompt.root; <userinput>ln -s /root/kernels/MYKERNEL</userinput></screen>
    </tip>

    <para>Ora edita <filename>MYKERNEL</filename> con il tuo
      editor favorito.  Se stai partendo da zero, il solo editor
      disponibile sa&grave; probabilmente <application>vi</application>,
      che è troppo complesso per essere spiegato in questa sede,
      ma è trattato estesamente in molti libri nella
      <link linkend="bibliography">bibliografia</link>.  Comunque,
      &os; offre un semplice editor chiamato <application>ee
      </application> che, se sei un principiante, dovrebbe essere
      il tuo editor favorito.  Sentiti libero di cambiare le linee
      di commento in cima al file di configurazione per riflettere
      le tue configurazioni o i cambiamenti che hai fatto rispetto a
      <filename>GENERIC</filename>.</para>

    <indexterm><primary>SunOS</primary></indexterm>

    <para>Se hai compilato un kernel sotto &sunos; o qualche altro
      sistema BSD, gran parte di questo file ti sarà noto.
      Se stai arrivando da qualche altro sistema operativo tipo
      DOS, d'altro canto, il file di configurazione
      <filename>GENERIC</filename> ti potrebbe sembrare troppo
      complesso, così è meglio che segui le descrizioni
      della sezione <link linkend="kernelconfig-config">File di
      Configurazione</link> attentamente.</para>

    <note>
      <para>Se tu <link linkend="cutting-edge">sincronizzi il tuo albero dei sorgenti
        </link> con i più recenti sorgenti del progetto  &os;,
        accertati sempre di controllare il file
        <filename>/usr/src/UPDATING</filename> prima di eseguire
        una qualsiasi operazione di aggiornamento.
        <filename>/usr/src/UPDATING</filename> viene aggiornato
        con ogni versione dei sorgenti di &os;, e quindi è
        più aggiornato di questo manuale.</para>
    </note>

    <para>A questo punto devi compilare i sorgenti del kernel.</para>

    <procedure>
      <title>Compilare il Kernel</title>

      <step>
        <para>Entra nella directory <filename>/usr/src</filename>:</para>

        <screen>&prompt.root; <userinput>cd /usr/src</userinput></screen>
      </step>

      <step>
        <para>Compila il kernel:</para>

        <screen>&prompt.root; <userinput>make buildkernel KERNCONF=MYKERNEL</userinput></screen>
      </step>

      <step>
        <para>Installa il nuovo kernel:</para>

        <screen>&prompt.root; <userinput>make installkernel KERNCONF=MYKERNEL</userinput></screen>
      </step>
    </procedure>

    <note>
      <para>Si richede la presenza dell'intera struttura dei sorgenti
        di &os; per compilare il kernel.
      </para>
    </note>

    <tip>
      <para>Di default, quando compili un kernel custom, anche
        <emphasis>tutti</emphasis> i moduli del kernel sono
        ricompilati.  Se vuoi aggiornare il kernel in modo spiccio
        o se vuoi compilare solo alcuni moduli, dovresti editare
        <filename>/etc/make.conf</filename> prima di iniziare
        la compilazione del kernel:</para>

      <programlisting>MODULES_OVERRIDE = linux acpi sound/sound sound/driver/ds1 ntfs</programlisting>

      <para>Questa variabile contiene una lista dei moduli che saranno
        ricompilati.</para>

      <programlisting>WITHOUT_MODULES = linux acpi sound/sound sound/driver/ds1 ntfs</programlisting>

      <para>Questa variabile contiene una lista dei moduli che saranno
        esclusi dal processo di compilazione.  Per altre variabili che potresti
        trovare utili per il processo di compilazione del kernel, consulta la
        pagina man &man.make.conf.5;.</para>
    </tip>

    <indexterm>
      <primary><filename>/boot/kernel.old</filename></primary>
    </indexterm>

    <para>Il nuovo kernel sarà copiato nella directory
      <filename>/boot/kernel</filename>
      come <filename>/boot/kernel/kernel</filename> e il kernel
      precedente sarà copiato in <filename>
      /boot/kernel.old/kernel</filename>.  Ora, riavvia il sistema
      e riparti per usare il tuo nuovo kernel.  Se qualcosa
      va storto, ci sono alcune istruzioni di
      <link linkend="kernelconfig-trouble">troubleshooting</link>
      alla fine del capitolo che puoi trovare utili.
      Accertati di leggere la sezione in cui si spiega
      cosa fare in caso il tuo nuovo kernel
      <link linkend="kernelconfig-noboot">non faccia il boot</link>.</para>

    <note>
      <para>Altri file relativi al processo di boot, come il boot
        &man.loader.8; e la configurazione sono conservati in
        <filename>/boot/</filename>.  Moduli di terze parti o custom
        possono essere piazzati in <filename>/boot/kernel/
        </filename>, anche se gli utenti dovrebbero avere conoscenza
        del fatto che tenere i moduli sincronizzati col kernel compilato
        è molto importante.  I moduli non creati per
        interagire col kernel compilato possono risultare in
        instabilità o comportamenti anomali.</para>
    </note>
  </sect1>

  <sect1 xml:id="kernelconfig-config">
    <info><title>Il File di Configurazione</title>
      <authorgroup>
        <author><personname><firstname>Joel</firstname><surname>Dahl</surname></personname><contrib>Modificato per &os; 6.X da </contrib></author>
      </authorgroup>
    </info>

    

    <indexterm>
      <primary>kernel</primary>
      <secondary>NOTES</secondary>
    </indexterm>
    <indexterm>
      <primary>NOTES</primary>
    </indexterm>
    <indexterm>
      <primary>kernel</primary>
      <secondary>file di configurazione</secondary>
    </indexterm>

    <para>Il formato generale di un file di configurazione è
      abbastanza semplice.  Ogni linea contiene una parola chiave
      ed uno o più argomenti.  Per semplicità, la maggior
      parte delle linee contiene solo un argomento.  Tutto quello
      che segue un <literal>#</literal> è considerato un
      commento ed ignorato.  Le seguenti sezioni descrivono
      ogni parola chiave, nell'ordine di presenza in
      <filename>GENERIC</filename>.
      <anchor xml:id="kernelconfig-options"/>Per una lista esaustiva
      delle opzioni dipendenti dall'architettura e dei devices,
      leggi il file <filename>NOTES</filename> nella stessa directory
      del file <filename>GENERIC</filename>.  Per opzioni
      indipendenti dall'architettura, leggi
      <filename>/usr/src/sys/conf/NOTES</filename>.</para>

    <note>
      <para>Per creare un file che contenga tutte le opzioni
        disponibili, ad esempio per usi di testing,
        esegui il seguente comando come <systemitem class="username">root</systemitem>:</para>

      <screen>&prompt.root; <userinput>cd /usr/src/sys/i386/conf &amp;&amp; make LINT</userinput></screen>
    </note>

    <indexterm>
      <primary>kernel</primary>
      <secondary>configuration file</secondary>
    </indexterm>

    <para>Il seguente è un esempio del file di configurazione
      del kernel <filename>GENERIC</filename> con vari commenti
      addizionali ove necessari ai fini della chiarezza.  Questo esempio
      dovrebbe corrispondere abbastanza da vicino alla tua copia in
      <filename>/usr/src/sys/i386/conf/GENERIC</filename>.
    </para>

    <indexterm>
      <primary>opzioni  del kernel</primary>
      <secondary>macchina</secondary>
    </indexterm>

    <programlisting>machine   i386</programlisting>

    <para>Questa è la architettura della macchina.  Deve essere
      una fra <literal>alpha</literal>, <literal>amd64</literal>,
      <literal>i386</literal>, <literal>ia64</literal>,
      <literal>pc98</literal>, <literal>powerpc</literal>, o
      <literal>sparc64</literal>.</para>

    <indexterm>
      <primary>opzioni del kernel</primary>
      <secondary>cpu</secondary>
    </indexterm>

    <programlisting>cpu          I486_CPU
cpu          I586_CPU
cpu          I686_CPU</programlisting>

    <para>Quanto riportato sopra specifica il tipo di CPU che hai nella
      tua macchina.  Puoi avere molte istanze di linee di CPU (se, per
      esempio, non sei sicuro se devi usare la
      <literal>I586_CPU</literal> o la <literal>I686_CPU</literal>),
      ma per un kernel custom è meglio specificare solo la CPU
      che hai.  Se non sei sicuro di quale sia il tipo della tua CPU,
      controlla il file <filename>/var/run/dmesg.boot</filename> per leggere
      i messaggi di boot.</para>

    <indexterm>
      <primary>opzioni del kernel</primary>
      <secondary>ident</secondary>
    </indexterm>

    <programlisting>ident          GENERIC</programlisting>

    <para>Questo è l'identificativo del kernel.  Dovresti cambiarlo
      nel nome che hai dato al kernel, ad esempio <literal>MYKERNEL</literal>
      se hai seguito le istruzioni degli esempi precedenti.  Il valore che poni
      nella stringa <literal>ident</literal>, sarà emesso a video
      quando fai il boot del kernel, così è utile dare al
      nuovo kernel un nome differente se vuoi tenerlo separato dal tuo kernel
      usuale (ad esempio se vuoi creare un kernel sperimentale).</para>

    <programlisting>#To statically compile in device wiring instead of /boot/device.hints
#hints          "GENERIC.hints"         # Default places to look for devices.</programlisting>

    <para>L'opzione &man.device.hints.5; è
      usato per configurare le opzioni dei device driver.  La posizione
      di default che &man.loader.8; cercherà al momento del boot
      è <filename>/boot/device.hints</filename>.  Usando l'opzione
      <literal>hints</literal> puoi compilare queste direttive direttamente
       nel kernel.  Se fai così non c'è bisogno di creare
       un file <filename>device.hints</filename> in <filename>/boot</filename>.</para>

    <programlisting>makeoptions     DEBUG=-g          # Build kernel with gdb(1) debug symbols</programlisting>

    <para>Il processo normale di compilazione di &os; include
      informazioni di debugging quando si compila il kernel
      con l'opzione <option>-g</option>, che abilita il debugging
      quando passato a &man.gcc.1;.</para>

    <programlisting>options          SCHED_4BSD         # 4BSD scheduler</programlisting>

    <para>Lo schedulatore tradizionale per &os;.  Tienilo.
    </para>

    <programlisting>options          PREEMPTION         # Enable kernel thread preemption</programlisting>

    <para>Permette ai thread del kernel di essere interrotti
      da altri thread a priorità più alta.
      Aiuta con l'interattività e permette ai thread
      degli interrupt di essere eseguiti prima rispetto invece che attendere.
    </para>

    <programlisting>options          INET              # InterNETworking</programlisting>

    <para>Supporto per la rete.  Lascia questa opzione, anche se non intendi
      connettere il computer ad una rete.  La maggior parte dei programmi
      richiedono almeno rete di loopback (ad esempio fare connessioni di rete
      dal tuo pc al tuo pc stesso), così questa opzione in sostanza è
      obbligatoria.</para>

    <programlisting>options          INET6             # IPv6 communications protocols</programlisting>

    <para>Questo abilita il protocollo di comunicazione IPv6.</para>

    <programlisting>options          FFS               # Berkeley Fast Filesystem</programlisting>

    <para>Questo è il file system di dischi di base.  Lascialo nel kernel
      se fai il boot da hard disk.</para>

    <programlisting>options          SOFTUPDATES       # Enable FFS Soft Updates support</programlisting>

    <para>Questa opzione abilita le Soft Updates nel kernel, aiuterà
      a velocizzare accesso di scrittura ai dischi.  Anche quando questa
      funzionalità è fornita dal kernel, deve essere
      attivata per dischi specifici.  Rileggi l'output da &man.mount.8;
      per vedere se Soft Updates sono abilitate per i tuoi dischi di sistema.
      Se non vedi l'opzione <literal>soft-updates</literal> potrai
      abilitarla usando &man.tunefs.8; (per file system già
      esistenti) o &man.newfs.8; (per nuovi file system).</para>

    <programlisting>options          UFS_ACL           # Support for access control lists</programlisting>

    <para>Questa opzione abilita supporto
      nel kernel per le liste di controllo di accesso.  Questo poggia sull'uso
      degli attributi estesi e <acronym>UFS2</acronym>, questa opzione viene
      descritta in dettaglio in <xref linkend="security"/>.  <acronym>ACL</acronym>
      sono abilitate di default e non dovrebbero essere disabilitate nel kernel
      se sono state usate precedentemente su un file system, dato che questo
      rimuoverà le liste di controllo di accesso, cambiando il modo
      in cui i file sono protetti in modo non predicibile.</para>

    <programlisting>options          UFS_DIRHASH       # Improve performance on big directories</programlisting>

    <para>Quest'opzione include funzionalità per accelerare
      operazioni sui dischi su larghe directory, a costo di uso
      di memoria.  Lo dovresti tenere per un server molto trafficato
      o workstation interattive, e rimuoverlo se stai usando
      &os; su piccoli sistemi dove la memoria è scarsa e
      l'accesso ai dischi è meno importante, come un firewall.</para>

    <programlisting>options          MD_ROOT           # MD is a potential root device</programlisting>

    <para>Questa opzione abilita il supporto per un disco virtuale
      basato sulla memoria da usare come device di root.</para>

    <indexterm>
      <primary>opzioni del kernel</primary>
      <secondary>NFS</secondary>
    </indexterm>
    <indexterm>
      <primary>opzioni del kernel</primary>
      <secondary>NFS_ROOT</secondary>
    </indexterm>

    <programlisting>options          NFSCLIENT         # Network Filesystem Client
options          NFSSERVER         # Network Filesystem Server
options          NFS_ROOT          # NFS usable as /, requires NFSCLIENT</programlisting>

    <para>Il file system di rete.  A meno che tu non intenda montare
      partizioni da un file server &unix; sopra TCP/IP, puoi commentare
      queste righe.</para>

    <indexterm>
      <primary>opzioni del kernel</primary>
      <secondary>MSDOSFS</secondary>
    </indexterm>

    <programlisting>options          MSDOSFS           # MSDOS Filesystem</programlisting>

    <para>Il filesystem &ms-dos;.  A meno che non intendi montare un
      disco formattato DOS al momento del boot, puoi tranquilamente
      commentare queste opzioni.  Sarà automaticamente caricato
      la prima volta che monti una partizione DOS, come descritto in seguito.
      Inoltre, l'eccellente software <package>emulators/mtools</package>
      ti permette di accedere a floppy DOS senza dover montarli e smontarli
      (e non richiede assolutamente <literal>MSDOSFS</literal>).</para>

    <programlisting>options          CD9660            # ISO 9660 Filesystem</programlisting>

    <para>Il file system ISO 9660 per CDROM.  Commentalo se non hai
      un drive CDROM o monti CD di dati solo occasionalmente (dato
      che sarà caricato dinamicamente la prima volta che monti
      un CD di dati).  CD audio non necessitano di questo file system.</para>

    <programlisting>options          PROCFS            # Process filesystem (requires PSUEDOFS)</programlisting>

    <para>Il file system dei processi.  Questo è un <quote>fittizio</quote>
      file system montato su <filename>/proc</filename> che permette
      a programmi come &man.ps.1; di darti maggiori informazioni
      su quali processi sono in esecuzione.  L'uso di <literal>PROCFS</literal> non è richiesto
      nella maggior parte dei casi, dato che la maggior parte
      dei tool di debugging e di monitoring è stato adattato per
      funzionare senza <literal>PROCFS</literal>: la procedura di
      installazione non monterà questo file system
      di default.</para>

    <programlisting>options          PSEUDOFS          # Pseudo-filesystem framework</programlisting>

      <para>I  kernel 6.X che fanno uso del filesystem <literal>PROCFS</literal>
        devono anche includere supporto per <literal>PSEUDOFS</literal>.</para>

    <programlisting>options          GEOM_GPT          # GUID Partition Tables.</programlisting>

    <para>Questa opzione fornisce la possibilità di avere
      un gran numero di partizioni su un singolo disco.</para>

    <programlisting>options          COMPAT_43         # Compatible with BSD 4.3 [KEEP THIS!]</programlisting>

    <para>Compatibilità con 4.3BSD.  Lasciala; alcuni programmi
      si comporteranno in maniera strana se la commenti.</para>

    <programlisting>options          COMPAT_FREEBSD4   # Compatible with &os;4</programlisting>

    <para>Questa opzione è richiesta su &os;&nbsp;5.X su sistemi
      &i386; e Alpha per supportare applicazioni compilate su versioni
      precedenti di &os; che usano vecchie interfacce di system call.
      Si raccomanda che questa opzione sia usata su tutte le &i386;
      ed Alpha che possano eseguire vecchie applicazioni; piattaforme
      che hanno ottenuto supporto solo dall 5.X, come ia64 e &sparc64;
      non richiedono questa opzione.</para>

    <programlisting>options          COMPAT_FREEBSD5   # Compatible with &os;5</programlisting>

    <para>Questa opzione è richiesta per &os;&nbsp;6.X e superiori per
      supportare applicazioni compilate su os;&nbsp;5.X che fanno uso di chiamate di sistema
      di &os;&nbsp;5.X.</para>

    <programlisting>options          SCSI_DELAY=5000  # Delay (in ms) before probing SCSI</programlisting>

    <para>Questa opzione fa sì che il kernel faccia una pausa
      di 5 secondi prima di controllare ogni device SCSI sul tuo sistema.
      Se hai solo dischi IDE, puoi ignorarla, altrimenti potresti
      voler diminuire il numero per accelerare
      il boot.  Ovviamente, se fai ciò e &os; ha problemi
      a riconoscere i tuoi device SCSI, dovrai alzarla di nuovo.</para>

    <programlisting>options          KTRACE            # ktrace(1) support</programlisting>

    <para>Questo abilita il tracciamento dei processi nel kernel,
      che è utile per il debugging.</para>

    <programlisting>options          SYSVSHM           # SYSV-style shared memory</programlisting>

    <para>Questa opzione fornisce memoria condivisa di tipo System&nbsp;V.
      L'uso più comune di questa opzione è l'estensione
      XSHM in X, grazie alla quale molti programmi ad alta
      intensità grafica ne trarranno vantaggio per maggior
      velocità.  Se usi X, vorrai sicuramente includere questa opzione.
    </para>

    <programlisting>options          SYSVMSG           # SYSV-style message queues</programlisting>

    <para>Supporto per messaggi stile System&nbsp;V.  Questa opzione aggiunge
      solo poche centinaia di byte al kernel.</para>

    <programlisting>options          SYSVSEM           # SYSV-style semaphores</programlisting>

    <para>Supporto per semafori stile System&nbsp;V.  Usato meno di frequente
      ma aggiunge solo poche centinaia di byte al kernel.</para>

    <note>
      <para>L'opzione <option>-p</option> del comando &man.ipcs.1; mostrerà
        ogni processo che usa uno di queste opzione System&nbsp;V.</para>
    </note>

    <programlisting>options        _KPOSIX_PRIORITY_SCHEDULING # POSIX P1003_1B real-time extensions</programlisting>

    <para>Estensioni real-time aggiunte al &posix; 1993.  Alcune
      applicazioni nella collezione dei Ports usano questa opzione
      (come <application>&staroffice;</application>).</para>

    <programlisting>options          KBD_INSTALL_CDEV  # install a CDEV entry in /dev</programlisting>

    <para>Questa opzione è relativa ala tastiera.  Aggiunge una entry CDEV
      nella directory <filename>/dev</filename>.</para>

    <programlisting>options          ADAPTIVE_GIANT    # Giant mutex is adaptive.</programlisting>

    <para>Giant è il nome di un meccanismo di esclusione reciproca
      (uno sleep mutex) che protegge gran parte delle risorse del kernel.
      Al giorno d'oggi è un inaccettabile rallentamento delle performance
      che si sta attivamente sostituendo con locks che proteggono risorse
      individuali.  L'opzione <literal>ADAPTIVE_GIANT</literal> fa sì
      che Giant sia incluso nell'insieme dei mutex da scegliere.  Cioè
      quando un thread vuole fare un lock sul mutex Giant, ma è già
      bloccato da un thread su un'altra CPU, il primo thread continuerà
      a girare ed aspetterà che il lock sia rilasciato.  Normalmente
      invece, il thread tornerebbe a dormire e aspetterà la sua prossima
      occasione per girare.  Se non sei sicuro, lascialo dentro.</para>

    <indexterm>
      <primary>kernel options</primary>
      <secondary>SMP</secondary>
    </indexterm>

    <programlisting>device          apic               # I/O APIC</programlisting>

    <para>Il device apic abilita l'uso dell'APIC I/O per inviare
      gli interrupt.  Il device apic può essere usato sia su kernel
      UP che su SMP, ma è richiesto per kernel SMP.  Aggiungi
      <literal>option SMP</literal> per includere supporto per processori
      multipli.</para>

    <note>
      <para>Il dispositivo apic esiste sono per l'architettura i386, questa
        riga di configurazione non deve essere usata per altre
        architetture.</para>
    </note>

    <programlisting>device          eisa</programlisting>

    <para>Includilo se hai una motherboard EISA.  Questo abilita
      supporto per l'auto-rilevazione e configurazione per tutti i device
      sul bus EISA.</para>

    <programlisting>device          pci</programlisting>

    <para>Includilo se hai una motherboard PCI.  Questo abilita
      l'auto-rilevazione delle carte PCI e operazioni di gateway
      dal bus PCI al bus ISA.</para>

    <programlisting># Floppy drives
device          fdc</programlisting>

    <para>Questo abilita il supporto al controller del floppy drive.</para>

    <programlisting># ATA and ATAPI devices
device          ata</programlisting>

    <para>Questo driver supporta tutti i device ATA e ATAPI.  Hai bisogno
      solo di una linea <literal>device ata</literal> per il kernel
      affinchè rilevi tutti i device PCI ATA/ATAPI su macchine moderne.</para>

    <programlisting>device          atadisk                 # ATA disk drives</programlisting>

    <para>Questo è necessario assieme a <literal>device ata</literal>
      per disk drive ATA.</para>

    <programlisting>device          ataraid                 # ATA RAID drives</programlisting>

    <para>Questo è necessario assieme a <literal>device ata</literal> per drive
      ATA RAID.</para>

    <programlisting><anchor xml:id="kernelconfig-atapi"/>
device          atapicd                 # ATAPI CDROM drives</programlisting>

    <para>Questo è necessario assieme a <literal>device ata</literal> per
      drive CDROM ATAPI.</para>

    <programlisting>device          atapifd                 # ATAPI floppy drives</programlisting>

    <para>Questo è necessario assieme a <literal>device ata</literal> per
      drive floppy ATAPI.</para>

    <programlisting>device          atapist                 # ATAPI tape drives</programlisting>

    <para>Questo è necessario assieme a <literal>device ata</literal> per
      drive tape ATAPI.</para>

    <programlisting>options         ATA_STATIC_ID           # Static device numbering</programlisting>

    <para>Questo rende il numero di controller statico; senza questo
      i numeri di device sono allocati dinamicamente.</para>

    <programlisting># SCSI Controllers
device          ahb        # EISA AHA1742 family
device          ahc        # AHA2940 and onboard AIC7xxx devices
options         AHC_REG_PRETTY_PRINT    # Print register bitfields in debug
                                        # output.  Adds ~128k to driver.
device          ahd        # AHA39320/29320 and onboard AIC79xx devices
options         AHD_REG_PRETTY_PRINT    # Print register bitfields in debug
                                        # output.  Adds ~215k to driver.
device          amd        # AMD 53C974 (Teckram DC-390(T))
device          isp        # Qlogic family
#device         ispfw      # Firmware for QLogic HBAs- normally a module
device          mpt        # LSI-Logic MPT-Fusion
#device         ncr        # NCR/Symbios Logic
device          sym        # NCR/Symbios Logic (newer chipsets + those of `ncr')
device          trm        # Tekram DC395U/UW/F DC315U adapters

device          adv        # Advansys SCSI adapters
device          adw        # Advansys wide SCSI adapters
device          aha        # Adaptec 154x SCSI adapters
device          aic        # Adaptec 15[012]x SCSI adapters, AIC-6[23]60.
device          bt         # Buslogic/Mylex MultiMaster SCSI adapters

device          ncv        # NCR 53C500
device          nsp        # Workbit Ninja SCSI-3
device          stg        # TMC 18C30/18C50</programlisting>

    <para>Controller SCSI.  Commentali tutti se non ne hai nessuno
      sul tuo sistema.  Se hai un sistema solo IDE, puoi rimuoverli
      tutti.  Le righe <literal>*_REG_PRETTY_PRINT</literal> sono opzioni
      di debug per i loro rispettivi dispositivi.</para>

    <programlisting># SCSI peripherals
device          scbus      # SCSI bus (required for SCSI)
device          ch         # SCSI media changers
device          da         # Direct Access (disks)
device          sa         # Sequential Access (tape etc)
device          cd         # CD
device          pass       # Passthrough device (direct SCSI access)
device          ses        # SCSI Environmental Services (and SAF-TE)</programlisting>

    <para>Periferiche SCSI.  Ancora, commentali se non ne hai nessuna
      o se il tuo sistema è solo IDE.</para>

    <note>
      <para>Il driver USB &man.umass.4; e pochi altri driver usano
        il sottosistema SCSI anche se non sono veri device SCSI.
        Quindi accertati di non rimuovere il supporto a SCSI,
        se qualche driver del genere è incluso nella tua
        configurazione del kernel.</para>
    </note>

    <programlisting># RAID controllers interfaced to the SCSI subsystem
device          amr        # AMI MegaRAID
device          arcmsr     # Areca SATA II RAID
device          asr        # DPT SmartRAID V, VI and Adaptec SCSI RAID
device          ciss       # Compaq Smart RAID 5*
device          dpt        # DPT Smartcache III, IV - See NOTES for options
device          hptmv      # Highpoint RocketRAID 182x
device          rr232x     # Highpoint RocketRAID 232x
device          iir        # Intel Integrated RAID
device          ips        # IBM (Adaptec) ServeRAID
device          mly        # Mylex AcceleRAID/eXtremeRAID
device          twa        # 3ware 9000 series PATA/SATA RAID

# RAID controllers
device          aac        # Adaptec FSA RAID
device          aacp       # SCSI passthrough for aac (requires CAM)
device          ida        # Compaq Smart RAID
device          mfi        # LSI MegaRAID SAS
device          mlx        # Mylex DAC960 family
device          pst        # Promise Supertrak SX6000
device          twe        # 3ware ATA RAID</programlisting>

    <para>Controller RAID supportati.  Se non ne hai nessuno,
      puoi commentarli o rimuoverli.</para>

    <programlisting># atkbdc0 controls both the keyboard and the PS/2 mouse
device          atkbdc     # AT keyboard controller</programlisting>

    <para>Il controller della tastiera (<literal>atkbdc</literal>) fornisce
      servizi I/O per la tastiera AT ed il device PS/2.  Questo controller
      è richiesto dal driver della tastiera
      (<literal>atkbd</literal>) e dal driver del dispositivo di puntamento
      PS/2 (<literal>psm</literal>).</para>

    <programlisting>device          atkbd      # AT keyboard</programlisting>

    <para>Il driver <literal>atkbd</literal> assieme al controller
      <literal>atkbdc</literal>, fornisce accesso alla tastiera AT 84
       o la tastiera AT migliorata che è connesso al controller
       della tastiera AT.</para>

    <programlisting>device          psm        # PS/2 mouse</programlisting>

    <para>Usa questo device se il tuo mouse si inserisce nella porta
      PS/2.</para>

    <programlisting>device          kbdmux        # keyboard multiplexer</programlisting>

    <para>Supporto base per il multiplexing della tastiera.
      Se non hai intenzione di usare più di una tastiera sul sistema,
      puoi tranquillamente rimuovere quella riga.</para>

    <para>Supporto base per il multiplexing della tastiera.</para>

    <programlisting>device          vga        # VGA video card driver</programlisting>

    <para>Il driver della video card.</para>

    <programlisting># splash screen/screen saver
device          splash     # Splash screen and screen saver support</programlisting>

    <para>Schermata slapsh all'avvio! Anche gli screensaver lo
      richiedono.</para>

    <programlisting># syscons is the default console driver, resembling an SCO console
device          sc</programlisting>

    <para><literal>sc</literal> è il driver di default della console,
      assomiglia ad una console SCO.  Dato che molti programmi a schermo
      intero accedono alla console attraverso una libreria di database di
      terminali come <filename>termcap</filename>, non dovrebbe fare differenza
      se usi questo o <literal>vt</literal>, il driver compatibile con una
      console <literal>VT220</literal>.  Quando ti logghi, imposta la tua
      variabile d'ambiente <envar>TERM</envar> a <literal>scoansi</literal> se
      programmi a schermo intero hanno problemi a girare sotto questa
      console.</para>

    <programlisting># Enable this for the pcvt (VT220 compatible) console driver
#device          vt
#options         XSERVER          # support for X server on a vt console
#options         FAT_CURSOR       # start with block cursor</programlisting>

    <para>Questo è un driver di console compatibile con VT-220,
      compatibile all'indietro con VT100/102.  Funziona bene su alcuni laptop
      che hanno incompatibilità hardware con <literal>sc</literal>.
      Inoltre imposta la tua variabile <envar>TERM</envar> a
      <literal>vt100</literal> o <literal>vt220</literal> quando ti logghi.
      Questo driver può essere utile quando ci si connette
      ad un grande numero di macchine diverse sulla rete,
      dove le entry <filename>termcap</filename> o
      <filename>terminfo</filename> per il device <literal>sc</literal>
      spesso non sono disponibili &mdash; <literal>vt100</literal>
      dovrebbe essere disponibile virtualmente su ogni piattaforma.</para>

    <programlisting>device          agp</programlisting>

    <para>Includilo se hai una scheda AGP nel tuo sistema.  Questo
      abiliterà il supporto per AGP, e AGP GART per le motherboard
      che hanno queste caratteristiche.</para>

    <indexterm>
      <primary>APM</primary>
    </indexterm>

    <programlisting># Power management support (see NOTES for more options)
#device          apm</programlisting>

    <para>Supporto Advanced Power Management.  Utile per laptop,
      anche se in &os; 5.X e successivo questo è disabilitato
      in <filename>GENERIC</filename> di default.</para>

    <programlisting># Add suspend/resume support for the i8254.
device           pmtimer</programlisting>

    <para>Device driver per eventi di power management, come APM
      ed ACPI.</para>

    <programlisting># PCCARD (PCMCIA) support
# PCMCIA and cardbus bridge support
device          cbb               # cardbus (yenta) bridge
device          pccard            # PC Card (16-bit) bus
device          cardbus           # CardBus (32-bit) bus</programlisting>

    <para>Supporto PCMCIA.  Includilo se usi un laptop.</para>

    <programlisting># Serial (COM) ports
device          sio               # 8250, 16[45]50 based serial ports</programlisting>

    <para>Queste sono le porte seriali chiamate
      <filename>COM</filename> nel mondo &ms-dos;/&windows;.</para>

    <note>
      <para>Se hai un modem interno sulla <filename>COM4</filename>
        ed una porta seriale sulla <filename>COM2</filename>, dovrai
        cambiare l'IRQ del modem a 2 (per ragioni tecniche oscure
        IRQ 2=IRQ 9) affinchè tu ci possa accedere da &os;.
        Se hai una carta seriale multiporta, controlla la pagina di manuale
        per &man.sio.4; per maggiori informazioni sui valori corretti
        da aggiungere al tuo <filename>/boot/device.hints</filename>.
        Alcune video card (in particolare quelle basate su chip S3)
        usano indirizzi IO della forma <literal>0x*2e8</literal> e dato che
        molte carte seriali non codificano l'intero spazio degli indirizzi
        IO a 16 bit, hanno conflitti con queste carte, rendendo la porta
        <literal>COM4</literal> praticamente non disponibile.</para>

      <para>Ogni porta seriale deve avere un IRQ unico (a meno che non stia usando
        una delle carte multicard dove sono supportati interrupt condivisi),
        così gli IRQ di default per <filename>COM3</filename> e
        <filename>COM4</filename> non possono essere usati.</para>
    </note>

    <programlisting># Parallel port
device          ppc</programlisting>

    <para>Questo è l'interfaccia al bus ISA parallelo.</para>

    <programlisting>device          ppbus      # Parallel port bus (required)</programlisting>

    <para>Fornisce supporto per il bus della porta parallela.</para>

    <programlisting>device          lpt        # Printer</programlisting>

    <para>Supporto per la stampante a porta parallela.</para>

    <note>
      <para>Tutte quest tre sono necessarie per abilitare supporto
        alla stampante parallela.</para>
    </note>

    <programlisting>device          plip       # TCP/IP over parallel</programlisting>

    <para>Questo è il driver della interfaccia di rete parallela.</para>

    <programlisting>device          ppi        # Parallel port interface device</programlisting>

    <para>L'I/O a scopo generico (<quote>geek port</quote>) + IEEE1284
      I/O.</para>

    <programlisting>#device         vpo        # Requires scbus and da</programlisting>

    <indexterm><primary>zip drive</primary></indexterm>

    <para>Questo è per uno IOMEGA zip drive.  Richiede
      supporto <literal>scbus</literal> e <literal>da</literal>.  La migliore
      performance è raggiunta con porte in modo EPP 1.9.</para>

    <programlisting>#device         puc</programlisting>

    <para>Scommenta questo device se ha una seriale <quote>dumb</quote>
      o carta PCI parallela che è supportata dal driver glue
      &man.puc.4;.</para>

    <programlisting># PCI Ethernet NICs.
device          de         # DEC/Intel DC21x4x (<quote>Tulip</quote>)
device          em         # Intel PRO/1000 adapter Gigabit Ethernet Card
device          ixgb       # Intel PRO/10GbE Ethernet Card
device          txp        # 3Com 3cR990 (<quote>Typhoon</quote>)
device          vx         # 3Com 3c590, 3c595 (<quote>Vortex</quote>)</programlisting>

    <para>Vari driver di schede di rete PCI.  Commentalo o rimuovilo
      se nessuno di questi è presente nel tuo sistema.</para>

    <programlisting># PCI Ethernet NICs that use the common MII bus controller code.
# NOTE: Be sure to keep the 'device miibus' line in order to use these NICs!
device          miibus     # MII bus support</programlisting>

    <para>Supporto bus MII è richiesto per alcune NIC Ethernet 10/100 PCI,
      in particolare quelle che usano transricevitori compatibili con MII
      o implementano interfacce di controllo che operano su MII.  Aggiungere
      <literal>device miibus</literal> al kernel porta con sè il supporto
      per la generica API miibus e tutti i driver PHY, incluso un
      generico per PHY che non è specificamente gestito da driver
      individuali.</para>

    <programlisting>device          bce        # Broadcom BCM5706/BCM5708 Gigabit Ethernet
device          bfe        # Broadcom BCM440x 10/100 Ethernet
device          bge        # Broadcom BCM570xx Gigabit Ethernet
device          dc         # DEC/Intel 21143 and various workalikes
device          fxp        # Intel EtherExpress PRO/100B (82557, 82558)
device          lge        # Level 1 LXT1001 gigabit ethernet
device          msk        # Marvell/SysKonnect Yukon II Gigabit Ethernet
device          nge        # NatSemi DP83820 gigabit ethernet
device          nve        # nVidia nForce MCP on-board Ethernet Networking
device          pcn        # AMD Am79C97x PCI 10/100 (precedence over 'lnc')
device          re         # RealTek 8139C+/8169/8169S/8110S
device          rl         # RealTek 8129/8139
device          sf         # Adaptec AIC-6915 (<quote>Starfire</quote>)
device          sis        # Silicon Integrated Systems SiS 900/SiS 7016
device          sk         # SysKonnect SK-984x &amp; SK-982x gigabit Ethernet
device          ste        # Sundance ST201 (D-Link DFE-550TX)
device          stge       # Sundance/Tamarack TC9021 gigabit Ethernet
device          ti         # Alteon Networks Tigon I/II gigabit Ethernet
device          tl         # Texas Instruments ThunderLAN
device          tx         # SMC EtherPower II (83c170 <quote>EPIC</quote>)
device          vge        # VIA VT612x gigabit ethernet
device          vr         # VIA Rhine, Rhine II
device          wb         # Winbond W89C840F
device          xl         # 3Com 3c90x (<quote>Boomerang</quote>, <quote>Cyclone</quote>)</programlisting>

    <para>Driver che usano il codice del controller MII.</para>

    <programlisting># ISA Ethernet NICs.  pccard NICs included.
device          cs         # Crystal Semiconductor CS89x0 NIC
# 'device ed' requires 'device miibus'
device          ed         # NE[12]000, SMC Ultra, 3c503, DS8390 cards
device          ex         # Intel EtherExpress Pro/10 and Pro/10+
device          ep         # Etherlink III based cards
device          fe         # Fujitsu MB8696x based cards
device          ie         # EtherExpress 8/16, 3C507, StarLAN 10 etc.
device          lnc        # NE2100, NE32-VL Lance Ethernet cards
device          sn         # SMC's 9000 series of Ethernet chips
device          xe         # Xircom pccard Ethernet

# ISA devices that use the old ISA shims
#device         le</programlisting>

    <para>Driver ISA Ethernet.  Vedi
      <filename>/usr/src/sys/i386/conf/NOTES</filename>
      per dettagli su quali carte siano supportate da quali driver.</para>

    <programlisting># Wireless NIC cards
device          wlan            # 802.11 support</programlisting>

    <para>Supporto generico al 802.11.  Questa riga è richiesta per
      la rete wireless.</para>

    <programlisting>device          wlan_wep        # 802.11 WEP support
device          wlan_ccmp       # 802.11 CCMP support
device          wlan_tkip       # 802.11 TKIP support</programlisting>

    <para>Supporto di crittografia per i dispositivi 802.11.
      Queste righe sono necessarie se intenti usare la codificazione
      e i protocolli di sicurezza 802.11i.</para>

    <programlisting>device          an         # Aironet 4500/4800 802.11 wireless NICs.
device          ath             # Atheros pci/cardbus NIC's
device          ath_hal         # Atheros HAL (Hardware Access Layer)
device          ath_rate_sample # SampleRate tx rate control for ath
device          awi        # BayStack 660 and others
device          ral        # Ralink Technology RT2500 wireless NICs.
device          wi         # WaveLAN/Intersil/Symbol 802.11 wireless NICs.
#device         wl         # Older non 802.11 Wavelan wireless NIC.</programlisting>

    <para>Supporto per varie carte wireless.</para>

    <programlisting># Pseudo devices
device   loop          # Network loopback</programlisting>

    <para>Questo è il generico device loopback per TCP/IP.  Se fai telnet
      o FTP a <systemitem>localhost</systemitem> (anche conosciuto come
      <systemitem class="ipaddress">127.0.0.1</systemitem>) la connessione ritornerà
      alla tua stessa macchina attraverso questo device.  Questo è
      <emphasis>obbligatorio</emphasis>.</para>

    <programlisting>device   random        # Entropy device</programlisting>

    <para>Generatore casuale sicuro di numeri random.</para>

    <programlisting>device   ether         # Ethernet support</programlisting>

    <para><literal>ether</literal> è necessario solo se hai una
      carta Ethernet.  Include un codice di protocollo Ethernet.</para>

    <programlisting>device   sl            # Kernel SLIP</programlisting>

    <para><literal>sl</literal> è per supporto slip.  È stato
      interamente soppiantato da PPP, che è più semplice da
      installare, più adatto per connessioni modem-to-modem e più
      potente.</para>

    <programlisting>device   ppp           # Kernel PPP</programlisting>

    <para>Questo è per supporto kernel PPP per connessioni dial-up.
      C'è anche una versione di PPP implementata come applicazione
      userland che usa <literal>tun</literal> e offre più flessibilità
      e caratteristiche aggiuntive come dialing a domanda.</para>

    <programlisting>device   tun           # Packet tunnel.</programlisting>

    <para>Questo è usato per software userland PPP.
      Vedi la sezione
      <link linkend="userppp">PPP</link> di questo libro per maggiori
      informazioni.</para>

    <programlisting><anchor xml:id="kernelconfig-ptys"/>
device   pty           # Pseudo-ttys (telnet etc)</programlisting>

    <para>Questo è uno <quote>pseudo-terminal</quote> o porta di login
      simulato.  È usato da sessioni <command>telnet</command> e
      <command>rlogin</command>, <application>xterm</application> e qualche altra
      applicazione come <application>Emacs</application>.</para>

    <programlisting>device   md            # Memory <quote>disks</quote></programlisting>

    <para>Pseudo-device di disco di memoria.</para>

    <programlisting>device   gif           # IPv6 and IPv4 tunneling</programlisting>

    <para>Questo implementa il tunneling IPv6 su IPv4, IPv4 su IPv6,
      IPv4 su IPv4 e IPv6 su IPv6.  Il device
      <literal>gif</literal> è <quote>autoclonante</quote>,
      e creerà gli altri node come richiesto.
    </para>

    <programlisting>device   faith         # IPv6-to-IPv4 relaying (translation)</programlisting>

    <para>Questo pseudo-device cattura i pacchetti che sono inviati a lui
      e li distoglie verso il demone di traslazione IPv4/IPv6.
    </para>

    <programlisting># The `bpf' device enables the Berkeley Packet Filter.
# Be aware of the administrative consequences of enabling this!
# Note that 'bpf' is required for DHCP.
device   bpf           # Berkeley packet filter</programlisting>

    <para>Questo è il Berkeley Packet Filter.  Questo pseduo-device
      permette alle interfacce di rete di essere configurate
      in modo promiscuo, catturando ogni pacchetto su una rete broadcast
      (ad esempio una Ethernet).  Questi pacchetti possono essere
      catturati su disco e o esaminati con il programma
      &man.tcpdump.1;.</para>

    <note>
      <para>Il device &man.bpf.4; è anche usato da
        &man.dhclient.8; per ottenere l'indirizzo IP del default router
        (gateway) eccetera.  Se usi DHCP, lascia questa riga
        scommentata.</para>
    </note>

    <programlisting># USB support
device          uhci          # UHCI PCI-&gt;USB interface
device          ohci          # OHCI PCI-&gt;USB interface
device          ehci          # EHCI PCI-&gt;USB interface (USB 2.0)
device          usb           # USB Bus (required)
#device         udbp          # USB Double Bulk Pipe devices
device          ugen          # Generic
device          uhid          # <quote>Human Interface Devices</quote>
device          ukbd          # Keyboard
device          ulpt          # Printer
device          umass         # Disks/Mass storage - Requires scbus and da
device          ums           # Mouse
device          ural          # Ralink Technology RT2500USB wireless NICs
device          urio          # Diamond Rio 500 MP3 player
device          uscanner      # Scanners
# USB Ethernet, requires mii
device          aue           # ADMtek USB Ethernet
device          axe           # ASIX Electronics USB Ethernet
device          cdce          # Generic USB over Ethernet
device          cue           # CATC USB Ethernet
device          kue           # Kawasaki LSI USB Ethernet
device          rue           # RealTek RTL8150 USB Ethernet</programlisting>

    <para>Supporto per vari device USB.</para>

    <programlisting># FireWire support
device          firewire      # FireWire bus code
device          sbp           # SCSI over FireWire (Requires scbus and da)
device          fwe           # Ethernet over FireWire (non-standard!)</programlisting>

    <para>Supporto per vari device FireWire.</para>

    <para>Per maggiori informazioni e device addizionali supportati
      da &os;, controlla
      <filename>/usr/src/sys/i386/conf/NOTES</filename>.</para>

      <sect2>
        <title>Configurazioni a Memoria Estesa (<acronym>PAE</acronym>)</title>

        <indexterm>
          <primary>Physical Address Extensions
          (<acronym>PAE</acronym>)</primary>
          <secondary>memoria estesa</secondary>
        </indexterm>

        <para>Macchine con configurazione a memoria estesa richiedono più
          di 4 gigabyte di limite nello spazio degli indirizzi Virtuale
          User+Kernel (<acronym>KVA</acronym>).  A causa di questa limitazione,
          Intel ha aggiunto supporto per lo spazio degli indirizzi fisico
          a 36-bit nel &pentium; Pro e linee successive di CPU.</para>

        <para>La caratteristica di
          Physical Address Extension (<acronym>PAE</acronym>)
          dell' &intel; &pentium; Pro e CPU successive permette
          configurazioni della memoria fino a 64 gigabyte.
          &os; fornisce supporto per questa caratteristica attraverso
          l'opzione di configurazione del kernel <option>PAE</option>,
          disponibile in tutte le versioni correnti di &os;.
          A causa della limitazione della architettura
          della memoria Intel, nessuna distinzione è
          fatta per memorie sopra o sotto i 4 gigabyte.  Memoria allocata
          oltre i 4 gigabyte è semplicemente aggiunta al pool
          della memoria disponibile.</para>

        <para>Per abilitare il supporto <acronym>PAE</acronym> nel
          kernel, aggiungi semplicemente la seguente linea nel tuo
          file di configurazione del kernel:</para>

        <programlisting>options       PAE</programlisting>

        <note>
          <para>Il supporto <acronym>PAE</acronym> in &os;
            è disponibile solo per processori &intel; IA-32.
            Bisogna notare inoltre che il supporto <acronym>PAE</acronym>
            non ha ricevuto test esteso, e dovrebbe essere considerato
            di qualità beta rispetto alle altre carateristiche
            stabili di &os;.</para>
        </note>

        <para>Il supporto per <acronym>PAE</acronym> in &os; ha qualche limitazione:</para>

        <itemizedlist>
          <listitem>
            <para>Un processo non è in grado di accedere
              a più di 4 gigabte di spazio VM.</para>
          </listitem>

          <listitem>
            <para>I moduli <acronym>KLD</acronym> non possono essere caricati
              in un kernel con abilitato <acronym>PAE</acronym>, a causa
              delle differenze nell'ambiente di compilazione di un modulo
              e del kernel.</para>
          </listitem>

          <listitem>
            <para>Device driver che non usano l'interfaccia
              &man.bus.dma.9; causeranno corruzione dei dati
              in un kernel abilitato <acronym>PAE</acronym>, e non
              se ne raccomanda l'uso.  Per questo motivo,
              viene fornito un file di configurazione del kernel <filename>PAE</filename>,
              che esclude tutti i driver per i quali
              non è stato testato il funzionamento in un kernel
              abilitato <acronym>PAE</acronym>.</para>
          </listitem>

          <listitem>
            <para>Alcuni parametri che possono essere settati determinano
              l'uso delle risorse di memoria a partire dalla quantità
              di memoria fisica disponibile.  Questi parametri
              possono allocare troppo spazio rispetto alle necessità
              a causa della dimensione della memoria di un sistema
              <acronym>PAE</acronym>.  Un esempio simile è
              il sysctl <option>kern.maxvnodes</option>, che controlla
              il massimo numero di vnodes permessi nel kernel.  È
              concesso di aggiustare questo ed altri parametri ad un
              valore ragionevole.</para>
          </listitem>

          <listitem>
            <para>Può essere necessario aumentare lo spazio degli
              indirizzi di memoria virtuale del kernel (<acronym>KVA</acronym>)
              o ridurre la quantità di risorse specifiche che sono
              pesantemente usate (vedi oltre) per evitare
              esaurimenti di <acronym>KVA</acronym>.  L'opzione del kernel
              <acronym>KVA_PAGES</acronym> può essere usata per
              aumentare lo spazio <acronym>KVA</acronym>.</para>
          </listitem>
        </itemizedlist>

        <para>Per motivi di stabilità e di performance,
          si consiglia di consultare le pagine di manuale &man.tuning.7;.
          La pagina di manuale &man.pae.4; contiene informazioni
          aggiornate sul supporto <acronym>PAE</acronym>.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="kernelconfig-trouble">
    <title>Se Qualcosa Va Male</title>

    <para>Ci sono cinque categorie di problemi che si possono
      presentare quando si crea un nuovo kernel.  Sono:</para>

    <variablelist>
      <varlistentry>
        <term><command>config</command> fallisce:</term>

        <listitem>
          <para>Se il comando &man.config.8; fallisce quando
            gli passi la descrizione del tuo kernel, hai fatto
            probabilmente un semplice errore da qualche parte.
            Fortunatamente &man.config.8; scriverà il numero della linea
            che ha dato errore, così puoi facilmente trovare
            la linea errata.  Ad esempio, se vedi:</para>

        <screen>config: line 17: syntax error</screen>

        <para>Accertati che la parola chiave
            sia scritta correttamente confrontandola con quella
            del kernel <filename>GENERIC</filename> o un altro
            riferimento.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><command>make</command> fallisce:</term>

        <listitem>
          <para>Se il comando <command>make</command> fallisce, di solito
            segnala un errore nella descrizione del kernel che non è
            abbastanza grave per &man.config.8;.  Ancora, controlla la tua configurazione
            e se ancora non riesci a risolvere il problema, invia una mail
            a &a.questions; con la tua configurazione del kernel, e dovrebbe
            essere diagnosticato velocemente.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Il kernel non fa il boot:<anchor xml:id="kernelconfig-noboot"/></term>

        <listitem>
          <para>Se il tuo kernel non fa il boot, o fallisce nel
            riconoscimento dei tuoi device, non andare in panico!
            Fortunatamente &os; ha un ottimo meccanismo per
            ricominciare in questo caso.  Semplicemente scegli il kernel
            da cui vuoi fare il boot dal boot loader &os;.  Puoi accedere ad esso
            quando appare il menu del boot.
            Seleziona l'opzione <quote>Escape to a loader prompt</quote>,
            la numero sei.  Al prompt digita
            <command>unload kernel</command> e poi digita
            <command>boot /boot/kernel.old/kernel</command>
            o il nome del file di un altro kernel da cui puoi bootare
            correttamente.  Quando configuri un kernel, è sempre
            una buona idea tenere un kernel che si sa che funzioni
            a portata di mano.</para>

          <para>Dopo aver fatto il boot con un kernel funzionante
            puoi controllare il tuo file di configurazione e cercare
            di ricompilarlo.  Una risorsa utile è il file
            <filename>/var/log/messages</filename> che, fra le altre cose,
            registra tutti messaggi del kernel da ogni boot riuscito.
            Inoltre, il comando &man.dmesg.8; scriverà i messaggi
            del kernel dall'ultimo boot.</para>

          <note>
            <para>Se hai problemi a compilare un kernel, accertati di
              tenere un kernel <filename>GENERIC</filename>, o qualche
              altro kernel che sai che funzioni a portata di mano,con un
              nome diverso cosichè non sia cancellato dalla successiva
              compilazione.  Non puoi affidarti su <filename>kernel.old</filename>
              perchè quando installi un nuovo kernel, <filename>kernel.old
              </filename> viene cancellato dall'ultimo kernel installato, che poteva
              essere non funzionanante.  Inoltre, appena possibile, sposta il
              kernel funzionanante nella directory corretta <filename>
              /boot/kernel</filename> o comandi come &man.ps.1; potrebbero non
              funzionare bene.  Per farlo, semplicemente rinomina la directory
              contenente il kernel funzionante:</para>

            <screen>&prompt.root; <userinput>mv /boot/kernel /boot/kernel.bad</userinput>
              &prompt.root; <userinput>mv /boot/kernel.good /boot/kernel</userinput></screen>

          </note>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Il kernel funziona, ma &man.ps.1; non funziona più.</term>

        <listitem>
          <para>Se hai installato una versione del kernel differente
            da quella delle utilities di sistema, per esempio un kernel -CURRENT
            ed un sistema -RELEASE, molti comandi di stato del sistema
            come &man.ps.1; e &man.vmstat.8; non funzioneranno più.
            Dovresti <link linkend="makeworld">ricompilare ed installare
            world</link> con la stessa versione dei sorgenti del tuo kernel.
            Questa è una ragione per non usare una versione del kernel
            diversa dal sistema operativo.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </sect1>
</chapter>
