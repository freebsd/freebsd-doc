<!--
     The FreeBSD Documentation Project

     $FreeBSD$
     Original revision: 1.156
-->

<chapter id="kernelconfig">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Jim</firstname>

	<surname>Mock</surname>

	<contrib>Modificato e rivisto da </contrib>
      </author>
    </authorgroup>

    <authorgroup>
      <author>
	<firstname>Jake</firstname>

	<surname>Hamby</surname>

	<contrib>Grazie al contributo originale di </contrib>
      </author>
    </authorgroup>
  </chapterinfo>

  <title>Configurare il Kernel FreeBSD</title>

  <sect1 id="kernelconfig-synopsis">
    <title>Synopsis</title>

    <indexterm>
      <primary>kernel</primary>
      <secondary>compilare un kernel custom</secondary>
    </indexterm>

    <para>Il kernel &egrave; una componente fondamentale del sistema
      operativo &os;.  &Egrave; responsabile di gestire la memoria,
      applicare controlli di sicurezza, gestire la rete, accesso
      ai dischi e molto altro.  Anche se sempre pi&ugrave; parti di
      &os; diventano configurabili dinamicamente, &egrave; ancora
      necessario talvolta riconfigurare e ricompilare il kernel.</para>

    <para>Dopo aver letto questo capitolo, saprai:</para>

    <itemizedlist>
      <listitem>
	<para>Perch&egrave; potresti aver bisogno di 
          ricompilare un kernel.</para>
      </listitem>

      <listitem>
	<para>Come scrivere un file di configurazione del kernel,
          o come alterarne uno esistente.</para>
      </listitem>

      <listitem>
	<para>Come usare il file di configurazione del kernel
          per creare un nuovo kernel.</para>
      </listitem>

      <listitem>
	<para>Come installare il nuovo kernel.</para>
      </listitem>

      <listitem>
	<para>Come creare dei file in <filename>/dev</filename> di cui
          potresti aver bisogno.</para>
      </listitem>

      <listitem>
	<para>Come fare del troubleshooting se qualcosa
          va storto.</para>
      </listitem>
    </itemizedlist>

    <para>Tutti i comandi elencati in questo capitolo negli esempi
      dovrebbero essere eseguiti come <username>root</username>
      affinch&egrave; abbiano successo.</para>
  </sect1>

  <sect1 id="kernelconfig-custom-kernel">
    <title>Perch&egrave; creare un kernel custom?</title>

    <para>Tradizionalmente, &os; ha sempre avuto quello che si chiama
      un kernel <quote>monolitico</quote>.  Questo significa che
      il kernel era un programma di grandi dimensioni, supportava una
      lista fissa di device, e se tu avessi voluto cambiare il
      comportamento del kernel avresti dovuto compilarne uno nuovo,
      quindi fare il reboot del tuo computer per caricare il 
      nuovo kernel.</para>

    <para>Oggi come oggi, &os; si sta muovendo rapidamente verso un 
      modello dove gran parte delle funzionalit&agrave; del kernel
      sono contenute in moduli che possono essere caricati
      e scaricati dal kernel a seconda delle necessit&agrave;.
      Questo permette al kernel di adattarsi a nuovo hardware
      appena questo diventa disponibile (come ad esempio
      le carte PCMCIA in un laptop), oppure fa s&igrave; che
      nuove funzionalit&agrave; siano portate nel kernel, 
      funzionalit&agrave; che non erano necessarie quando il kernel
      fu compilato inizialmente.  Questo &egrave; noto come kernel
      modulare.</para>

    <para>Nonostante questo, &egrave; ancora necessario portare
      avanti delle compilazioni statiche del kernel.  In alcuni
      casi questo &egrave; necessario perch&egrave; la
      funzionalit&agrave; &egrave; cos&igrave; legata al kernel che
      non pu&ograve; essere resa caricabile dinamicamente.
      In altri casi pu&ograve; essere necessario semplicemente perch&egrave;
      nessuno si &egrave; ancora preso il tempo di scrivere un modulo
      caricabile dinamicamente per quella funzionalit&agrave;.</para>

    <para>Compilare un kernel custom &egrave; uno dei pi&ugrave; comuni riti
      di passaggio che quasi ogni utente BSD deve superare.  Questo
      processo, anche se &egrave; dispendioso di tempo, offrir&agrave;
      molti benefici al tuo sistema &os;.  A differenza del kernel
      <filename>GENERIC</filename>, che deve supportare un
      gran numero di dispositivi hardware, un kernel custom contiene
      supporto solo per l'hardware del <emphasis>tuo</emphasis> PC.
      Questo presenta dei vantaggi, fra cui:</para>

    <itemizedlist>
      <listitem>
	<para>Tempo di boot pi&ugrave; veloce.  Dato che il kernel
        cercher&agrave; di riconoscere solo l'hardware che hai sul 
        tuo sistema, il tempo che ci vuole al tuo sistema per fare boot
        diminuir&agrave; drammaticamente.</para>
      </listitem>

      <listitem>
	<para>Minore uso della memoria.  Un kernel custom spesso
          usa meno memoria del kernel <filename>GENERIC</filename>,
          il che &egrave; importante dato che il kernel deve sempre
          essere presente nella memoria reale.  Per questo motivo
          un kernel custom &egrave; particolarmente utile su sistemi
          con poca RAM.</para>
      </listitem>

      <listitem>
	<para>Supporto per hardware addizionale.  Un kernel custom
          ti permette di aggiungere supporto per device che non sono
          presenti nel kernel <filename>GENERIC</filename>, come ad
          esempio sound card.</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="kernelconfig-building">
    <title>Compilare ed installare un Kernel Custom</title>
    <indexterm>
      <primary>kernel</primary>
      <secondary>compilare / installare</secondary>
    </indexterm>

    <para>Per prima cosa, facciamo un breve giro nella directory
      di compilazione del kernel.  Tutte le directory menzionate
      saranno relative alla directory principale
      <filename>/usr/src/sys</filename>, che &egrave; accessibile
      attraverso il path <filename>/sys</filename>.  Ci sono
      un certo numero di sottodirectory qua che rappresentano
      parti differenti del kernel, ma la pi&ugrave; importante
      per i nostri scopi &egrave; 
      <filename><replaceable>arch</replaceable>/conf</filename>, 
      dove editerai il tuo file
      di configurazione del kernel, e <filename>compile</filename>,
      che &egrave; l'area di passaggio dove il tuo kernel sar&egrave;
      compilato.  <replaceable>arch</replaceable> rappresenta uno
      fra <filename>i386</filename>, <filename>alpha</filename>,
      <filename>amd64</filename>, <filename>ia64</filename>,
      <filename>powerpc</filename>, <filename>sparc64</filename>,
      o <filename>pc98</filename> (un tipo di sviluppo alternativo
      di hardware PC in Giappone).  Tutto ci&ograve; che &egrave;
      all'interno di particolare directory di architettura ha a che fare
      solo con quell'architettura; il resto &egrave; codice
      indipendente dalla macchina, comune a tutte le piattaforme
      sulle quali &os; potrebbe potenzialmente essere portato.
      Nota l'organizzazione logica della struttura dele directory,
      con ogni device supportato, file system e opzioni nelle proprie
      sottodirectory.  Versioni di &os; precedenti alla 5.X supportano
      solo le architetture <filename>i386</filename>, <filename>
      alpha</filename> e <filename>pc98</filename>.</para>

    <para>Questo capitolo assume che tu stia usando la architettura
      i386 negli esempi.  Se questo non &egrave; il caso, fai gli appropriati
      aggiustamenti per correggere i percorsi alla tua architettura.</para>

    <note>
      <para>Se <emphasis>non</emphasis> c'&egrave; una directory
        <filename>/usr/src/sys</filename> sul tuo sistema,
        significa che i sorgenti del kernel non sono stati installati.
        Il modo pi&ugrave; semplice per farlo &egrave; eseguire
        <command>sysinstall</command> (<command>/stand/sysinstall
        </command> su &os; di versione precedente alla 5.2)
        come <username>root</username>, scegliendo
        <guimenuitem>Configure</guimenuitem>, poi
        <guimenuitem>Distributions</guimenuitem>, poi
        <guimenuitem>src</guimenuitem>, poi
        <guimenuitem>sys</guimenuitem>.  Se hai un'avversione
        verso <application>sysinstall</application> e hai accesso
        ad un CDROM <quote>ufficiale</quote> &os;, allora puoi installare
        i sorgenti dalla linea di comando:</para>

      <screen>&prompt.root; <userinput>mount /cdrom</userinput>
&prompt.root; <userinput>mkdir -p /usr/src/sys</userinput>
&prompt.root; <userinput>ln -s /usr/src/sys /sys</userinput>
&prompt.root; <userinput>cat /cdrom/src/ssys.[a-d]* | tar -xzvf -</userinput></screen>
    </note>

    <para>Quindi, entra nella directory
      <filename><replaceable>arch</replaceable>/conf</filename>
      e copia il file di configurazione del kernel con il nome
      che vuoi dare al kernel.  Ad esempio:</para>

    <screen>&prompt.root; <userinput>cd /usr/src/sys/<replaceable>i386</replaceable>/conf</userinput>
&prompt.root; <userinput>cp GENERIC MYKERNEL</userinput></screen>

    <para>Tradizionalmente, questo nome &egrave; tutto in lettere
      maiuscole e, se stai mantenendo molte macchine &os; con hardware
      differente, &egrave; una buona idea dargli il nome della macchina.
      Noi lo chiamemeremo <filename>MYKERNEL</filename> a titolo di
      esempio.</para>

    <tip>
      <para>Conservare il tuo file di configurazione del kernel
        direttamente sotto <filename>/usr/src</filename> pu&ograve;
        essere una cattiva idea.  Se stai incontrando problemi
        puoi essere tentato di cancellare <filename>/usr/src
        </filename> e partire da zero.  Dopo averlo fatto,
        di solito ci vogliono pochi secondi per realizzare
        che hai appena cancellato il tuo file di configurazione del
        kernel.  Inoltre, non editare <filename>GENERIC</filename>
        direttamente, dato che potrebbe essere sovrascritto
        la prossima volta che <link linkend="cutting-edge">
        aggiorni i tuoi sorgenti</link>, e le tue modifiche
        andranno perse.</para>

      <para>Piuttosto tieni il tuo file di configurazione
        del kernel da qualche altra parte, e crea un link simbolico
        al file nella directory <filename><replaceable>i386
        </replaceable></filename>.</para>

      <para>Ad esempio:</para>

      <screen>&prompt.root; <userinput>cd /usr/src/sys/<replaceable>i386</replaceable>/conf</userinput>
&prompt.root; <userinput>mkdir /root/kernels</userinput>
&prompt.root; <userinput>cp GENERIC /root/kernels/<replaceable>MYKERNEL</replaceable></userinput>	
&prompt.root; <userinput>ln -s /root/kernels/<replaceable>MYKERNEL</replaceable></userinput></screen>
    </tip>

    <para>Ora edita <filename>MYKERNEL</filename> con il tuo
      editor favorito.  Se stai partendo da zero, il solo editor
      disponibile sa&grave; probabilmente <application>vi</application>,
      che &egrave; troppo complesso per essere spiegato in questa sede,
      ma &egrave; trattato estesamente in molti libri nella
      <link linkend="bibliography">bibliografia</link>.  Comunque,
      &os; offre un semplice editor chiamato <application>ee
      </application> che, se sei un principiante, dovrebbe essere
      il tuo editor favorito.  Sentiti libero di cambiare le linee
      di commento in cima al file di configurazione per riflettere
      le tue configurazioni o i cambiamenti che hai fatto rispetto a
      <filename>GENERIC</filename>.</para>
    <indexterm><primary>SunOS</primary></indexterm>

    <para>Se hai compilato un kernel sotto &sunos; o qualche altro
      sistema BSD, gran parte di questo file ti sar&agrave; noto.
      Se stai arrivando da qualche altro sistema operativo tipo
      DOS, d'altro canto, il file di configurazione
      <filename>GENERIC</filename> ti potrebbe sembrare troppo 
      complesso, cos&igrave; &egrave; meglio che segui le descrizioni
      della sezione <link linkend="kernelconfig-config">File di
      Configurazione</link> attentamente.</para>

    <note>
      <para>Se tu <link
        linkend="cutting-edge">sincronizzi il tuo albero dei sorgenti
        </link> con i pi&ugrave; recenti sorgenti del progetto  &os;,
        accertati sempre di controllare il file
        <filename>/usr/src/UPDATING</filename> prima di eseguire
        una qualsiasi operazione di aggiornamento.
        <filename>/usr/src/UPDATING</filename> viene aggiornato
        con ogni versione dei sorgenti di &os;, e quindi &egrave;
        pi&ugrave; aggiornato di questo manuale.</para>
    </note>

    <para>A questo punto devi compilare i sorgenti del kernel.  Ci sono
      due procedure per farlo, e quella che devi usare dipende dal motivo
      per cui stai ricompilando il kernel e dalla versione di &os;
      che stai usando.</para>

    <itemizedlist>
      <listitem>
	<para>Se hai installato <emphasis>solo</emphasis> il codice
          sorgente del kernel, usa la procedura 1.</para>
      </listitem>

      <listitem>
	<para>Se stai eseguendo una versione di &os; precedente alla 4.0,
          e <emphasis>non</emphasis> stai facendo un upgrade a
          &os;&nbsp;4.0 o successivo usando la procedura
          <command>make buildoworld</command>, usa la procedura 1.
        </para>
      </listitem>

      <listitem>
	<para>Se stai compilando un nuovo kernel senza aver aggiornato i
          sorgenti (eventualmente solo per aggiungere una nuova
          opzione, come ad esempio <literal>IPFIREWALL</literal>)
          puoi usare una qualunque procedura.</para>
      </listitem>

      <listitem>
	<para>Se stai ricompilando il kernel come parte del processo
          <command>make buildworld</command>, usa la procedura 2.
        </para>
      </listitem>
    </itemizedlist>
    
    <indexterm>
      <primary><command>cvsup</command></primary>
    </indexterm>
    <indexterm><primary>CTM</primary></indexterm>
    <indexterm>
      <primary>CVS</primary>
      <secondary>anonymous</secondary>
    </indexterm>

    <para>Se <emphasis>non</emphasis> hai aggiornato i tuoi sorgenti
      dall'ultima volta che hai completato con successo un ciclo
      <maketarget>buildworld</maketarget>-<maketarget>installworld</maketarget>
      (non hai eseguito <application>CVSup</application>,
      <application>CTM</application> o usato
      <application>anoncvs</application>), allora &egrave; sicuro
      usare la sequenza <command>config</command>, <command>
      make depend</command>, <command>make</command>, <command>
      make install</command>.
    </para>

    <procedure>
      <title>Procedura 1.  Compilare il Kernel nel 
        Modo <quote>Tradizionale</quote></title>
      
      <step>
	<para>Esegui &man.config.8; per generare il nuovo sorgente 
          del kernel.</para>
	
	<screen>&prompt.root; <userinput>/usr/sbin/config <replaceable>MYKERNEL</replaceable></userinput></screen>
      </step>

      <step>
	<para>Vai nella directory di compilazione.  &man.config.8; scriver&agrave;
          il nome di questa directory dopo essere stato eseguito
          come sopra.</para>

	<screen>&prompt.root; <userinput>cd ../compile/<replaceable>MYKERNEL</replaceable></userinput></screen>

	<para>Per versioni di &os; precedenti all 5.X, segui queste istruzioni:</para>

	<screen>&prompt.root; <userinput>cd ../../compile/<replaceable>MYKERNEL</replaceable></userinput></screen>
      </step>

      <step>
	<para>Compila il kernel.</para>
	
	<screen>&prompt.root; <userinput>make depend</userinput>
&prompt.root; <userinput>make</userinput></screen>
      </step>

      <step>
	<para>Installa il nuovo kernel.</para>
	
	<screen>&prompt.root; <userinput>make install</userinput></screen>
      </step>
    </procedure>

    <procedure>
      <title>Procedura 2.  Compilatre il Kernel nel <quote>Nuovo</quote>
	Modo</title>
      
      <step>
	<para>Entra nella directory <filename>/usr/src</filename>.</para>
	
	<screen>&prompt.root; <userinput>cd /usr/src</userinput></screen>
      </step>

      <step>
	<para>Compila il kernel.</para>
	
	<screen>&prompt.root; <userinput>make buildkernel KERNCONF=<replaceable>MYKERNEL</replaceable></userinput></screen>
      </step>

      <step>
	<para>Installa il nuovo kernel.</para>

	<screen>&prompt.root; <userinput>make installkernel KERNCONF=<replaceable>MYKERNEL</replaceable></userinput></screen>
      </step>
    </procedure>
    
    <note>
      <para>In &os;&nbsp;4.2 e precedente, devi sostituire
        <literal>KERNCONF=</literal> con <literal>KERNEL=</literal>.
        4.2-STABLE scaricato prima del 2 Febbraio 2001 non
        riconosce <literal>KERNCONF=</literal>.</para>
    </note>

    <indexterm>
      <primary><filename class="directory">/boot/kernel.old</filename></primary>
    </indexterm> 

    <para>Il nuovo kernel sar&agrave; copiato nella directory 
      <filename class="directory">/boot/kernel</filename>
      come <filename>/boot/kernel/kernel</filename> e il kernel
      precedente sar&agrave; copiato in <filename>
      /boot/kernel.old/kernel</filename>.  Ora, riavvia il sistema
      e riparti per usare il tuo nuovo kernel.  Se qualcosa
      va storto, ci sono alcune istruzioni di 
      <link linkend="kernelconfig-trouble">troubleshooting</link>
      alla fine del capitolo che puoi trovare utili.
      Accertati di leggere la sezione in cui si spiega
      cosa fare in caso il tuo nuovo kernel
      <link linkend="kernelconfig-noboot">non faccia il boot</link>.</para>

    <note>
      <para>In &os; 4.X e precedenti, i kernel sono installati
        in <filename>/kernel</filename>, i moduli in
        <filename class="directory">/modules</filename> e si
        tiene il backup dei vecchi kernel in
        <filename>/kernel.old</filename>.
        Altri file relativi al processo di boot, come il boot
        &man.loader.8; e la configurazione sono conservati in
        <filename>/boot</filename>.  Moduli di terze parti o custom
        possono essere piazzati in <filename class="directory">/modules
        </filename>, anche se gli utenti dovrebbero avere conoscenza
        del fatto che tenere i moduli sincronizzati col kernel compilato
        &egrave; molto importante.  I moduli non creati per
        interagire col kernel compilato possono risultare in
        instabilit&agrave; o comportamenti anomali.</para>
    </note>

    <note>
      <para>Se hai aggiunto un qualsiasi device (come una sound card)
        e stai usando &os;&nbsp;4.X o versioni precedenti, pu&ograve;
        darsi che tu debba aggiungere qualche nodo di device alla
        tua directory <filename class="directory">/dev</filename>
        prima che tu la possa usare.  Per maggiori informazioni,
        dai un'occhiata alla sezione <link linkend="kernelconfig-nodes">
        Crea Nodi di Device</link> pi&ugrave; avanti in questo capitolo.</para>
    </note>
  </sect1>

  <sect1 id="kernelconfig-config">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Joel</firstname>
	  <surname>Dahl</surname>
	  <contrib>Modificato per &os; 5.X by </contrib>
	  <!-- August 2004, PR docs/70674 -->
	</author>
	<!--  <editor><othername role="freefall login">ceri</othername></editor> -->
      </authorgroup>
    </sect1info>
    <title>Il File di Configurazione</title>
    <indexterm>
      <primary>kernel</primary>
      <secondary>NOTES</secondary>
    </indexterm>
    <indexterm>
      <primary>kernel</primary>
      <secondary>LINT</secondary>
    </indexterm>
    <indexterm><primary>NOTES</primary></indexterm>
    <indexterm><primary>LINT</primary></indexterm>
    <indexterm>
      <primary>kernel</primary>
      <secondary>file di configurazione</secondary>
    </indexterm>

    <para>Il formato generale di un file di configurazione &egrave;
      abbastanza semplice.  Ogni linea contiene una parola chiave
      ed uno o pi&ugrave; argomenti.  Per semplicit&agrave;, la maggior
      parte delle linee contiene solo un argomento.  Tutto quello
      che segue un <literal>#</literal> &egrave; considerato un
      commento ed ignorato.  Le seguenti sezioni descrivono ogni
      parola chiave, generalmente nell'ordine in cui sono elencate
      in <filename>GENERIC</filename>, anche se alcune parole chiave
      sono state raggruppate assieme in una singola sezione
      (come ad esempio Networking) anche se in effetti sono sparse
      attraverso tutto il file <filename>GENERIC</filename>.
      <anchor id="kernelconfig-options">Per una lista esaustiva
      delle opzioni dipendenti dall'architettura e dei devices,
      leggi il file <filename>NOTES</filename> nella stessa directory
      del file <filename>GENERIC</filename>.  Per opzioni
      indipendenti dall'architettura, leggi
      <filename>/usr/src/sys/conf/NOTES</filename>.</para>

    <note>
      <para><filename>NOTES</filename> non esiste in &os;&nbsp;4.X.
        In queste versioni, fai riferimento a <filename>LINT</filename>
        per una spiegazione dettagliata di opzioni e devices
        nel file <filename>GENERIC</filename>.  <filename>LINT</filename>
        serviva a due cose in 4.X: a fornire indicazioni per scegliere
        le opzioni del kernel quando se ne compilava uno nuovo, ed a fornire
        una configurazione del kernel con il maggior numero possibile
        di opzioni abilitate su valori non default.  La ragione dietro 
        ci&ograve; &egrave; che una simile configurazione aiutava 
        (ed ancora adesso aiuta) molto il test del nuovo codice
        ed i cambiamenti al codice esistente, che potrebbero causare
        conflitti con altre parti del kernel.  Comunque, l'ambiente
        di configurazione del kernel ha subito alcuni cambiamenti
        quando si &egrave; passati al 5.X; un esempio &egrave; il fatto
        che le opzioni di configurazione dei driver sono state spostate
        in un file <literal>hints</literal> cosicch&egrave; possano essere
        cambiate e caricate dinamicamente al momento del boot,
        e <filename>LINT</filename> non le contiene pi&ugrave;.
        Per questo ed altri motivi il file <filename>LINT</filename>
        &egrave; stato rinominato <filename>NOTES</filename> e 
        ha mantenuto principalmente la sua prima ragione di esistenza:
        documentare le opzioni disponibili per convenienza dell'utente.
        </para>
        
      <para>In &os; 5.X e versioni successive, puoi ancora generare un
        <filename>LINT</filename> funzionante per la compilazione
        digitando:</para>

      <screen>&prompt.root; <userinput>cd /usr/src/sys/<replaceable>i386</replaceable>/conf && make LINT</userinput></screen>
    </note>

    <indexterm>
      <primary>kernel</primary>
      <secondary>configuration file</secondary>
    </indexterm>

    <para>Il seguente &egrave; un esempio del file di configurazione 
      del kernel <filename>GENERIC</filename> con vari commenti
      addizionali ove necessari ai fini della chiarezza.  Questo esempio
      dovrebbe corrispondere abbastanza da vicino alla tua copia in
      <filename>/usr/src/sys/<replaceable>i386</replaceable>/conf/GENERIC</filename>.
    </para>

    <programlisting>#
# GENERIC -- Generic kernel configuration file for &os;/i386
#
# For more information on this file, please read the handbook section on
# Kernel Configuration Files:
#
#    http://www.&os;.org/doc/en_US.ISO8859-1/books/handbook/kernelconfig-config.html
#
# The handbook is also available locally in /usr/share/doc/handbook
# if you've installed the doc distribution, otherwise always see the
# &os; World Wide Web server (http://www.FreeBSD.org/) for the
# latest information.
#
# An exhaustive list of options and more detailed explanations of the
# device lines is also present in the ../../conf/NOTES and NOTES files. 
# If you are in doubt as to the purpose or necessity of a line, check first 
# in NOTES.
#
# &dollar;FreeBSD: /repoman/r/ncvs/src/sys/i386/conf/GENERIC,v 1.413 2004/08/11 01:34:18 rwatson Exp &dollar;</programlisting>

    <para>Le seguenti sono parole chiave obbligatorie in
      <emphasis>ogni</emphasis> kernel che compili:</para>
    <indexterm>
      <primary>opzioni  del kernel</primary>
      <secondary>macchina</secondary>
    </indexterm>

    <programlisting>machine		i386</programlisting>

    <para>Questa &egrave la architettura della macchina.  Deve essere
      una fra <literal>alpha</literal>, <literal>amd64</literal>,
      <literal>i386</literal>, <literal>ia64</literal>,
      <literal>pc98</literal>, <literal>powerpc</literal>, o
      <literal>sparc64</literal>.</para>

    <indexterm>
      <primary>opzioni del kernel</primary>
      <secondary>cpu</secondary>
    </indexterm>
    <programlisting>cpu          I486_CPU
cpu          I586_CPU
cpu          I686_CPU</programlisting>

    <para>Quanto riportato sopra specifica il tipo di CPU che hai nella
      tua macchina.  Puoi avere molte istanze di linee di CPU (se, per
      esempio, non sei sicuro se devi usare la
      <literal>I586_CPU</literal> o la <literal>I686_CPU</literal>),
      ma per un kernel custom &egrave; meglio specificare solo la CPU
      che hai.  Se non sei sicuro di quale sia il tipo della tua CPU,
      controlla il file <filename>/var/run/dmesg.boot</filename> per leggere
      i messaggi di boot.</para>

    <indexterm>
      <primary>opzioni del kernel</primary>
      <secondary>cpu type</secondary>
    </indexterm>
    <para>Supporto per la <literal>I386_CPU</literal> &egrave; ancora fornito
      nei sorgenti di &os;, ma &egrave; disabilitato di default sia in
      -STABLE che in -CURRENT.  Questo significa che per installare &os;
      con una cpu di classe 386, adesso hai le seguenti opzioni:</para>

    <itemizedlist>
      <listitem>
        <para>Installa una versione &os; precedente e ricompila dai sorgenti
          come descritta in <xref linkend="kernelconfig-building">.</para>
      </listitem>

      <listitem>
        <para>Compila i programmi utente e il kernel su una nuova macchina ed
          installa sul 386 usando i file precompilati in
          <filename>/usr/obj</filename> (vedi per dettagli
          <xref linkend="small-lan">).</para>
      </listitem>

      <listitem>
        <para>Creati la tua versione di &os; che includa supporto
          per <literal>I386_CPU</literal> nei kernel del CD-ROM
          di istallazione.</para>
      </listitem>
    </itemizedlist>

    <para>La prima di queste opzioni &egrave; probabilmente la pi&ugrave;
      semplice, ma avrai bisogno di molto spazio su disco, che su una macchina
      386 pu&ograve; essere difficile avere.</para>

    <indexterm>
      <primary>opzioni del kernel</primary>
      <secondary>ident</secondary>
    </indexterm>

    <programlisting>ident          GENERIC</programlisting>

    <para>Questo &egrave; l'identificativo del kernel.  Dovresti cambiarlo
      nel nome che hai dato al kernel, ad esempio <literal>MYKERNEL</literal>
      se hai seguito le istruzioni degli esempi precedenti.  Il valore che poni
      nella stringa <literal>ident</literal>, sar&agrave; emesso a video
      quando fai il boot del kernel, cos&igrave; &egrave; utile dare al
      nuovo kernel un nome differente se vuoi tenerlo separato dal tuo kernel
      usuale (ad esempio se vuoi creare un kernel sperimentale).</para>
    <indexterm>
      <primary>opzioni del kernel</primary>
      <secondary>maxusers</secondary>
    </indexterm>

    <programlisting>maxusers          <replaceable>n</replaceable></programlisting>

    <para>L'opzione <literal>maxusers</literal> imposta la dimensione
      di molte importanti tabelle di sistema.  Questo numero si suppone sia
      all'incirca uguale al numero di utenti connessi simultaneamente sulla
      tua macchina.</para>

    <para>A partire da &os;&nbsp;4.5, il sistema far&agrave; un auto tuning
      di questa impostazione se tu la poni a <literal>0</literal><footnote>
        <para>L'algoritmo di auto tuning imposta <literal>maxusers</literal>
          uguale alla quantit&agrave; di memoria sul tuo sistema, con un minimo
          di 32 ed un massimo di 384</para></footnote>
      Su &os;&nbsp;5.X e successivi, <literal>maxusers</literal> avr&agrave; di default
      il valore <literal>0</literal> se non specificato.  Se stai usando una versione
      di &os; precedente della 4.5, o vuoi gestirlo manualmente, poni un
      valore di <literal>maxusers</literal> almeno uguale a 4, specialmente se
      stai usando lo X Windows System o compili software.  La ragione &egrave;
      che la pi&ugrave; importante tabella dimensionata a partire da <literal>
      maxusers</literal> &egrave; quella del massimo numero di processi, che &egrave;
      creata di dimensione <literal>20 + 16 * maxusers</literal>, cos&igrave;
      se imposti <literal>maxusers</literal> a 1, puoi avere solo 36 processi
      simultanei, inclusi i 18 circa che il sistema avvia al momento del boot
      ed i 15 circa che probabilmente vorrai avviare quando usi l'X
      Windows System.  Anche una semplice operazione come leggere una pagina
      di manuale avvier&agrave; nove processi per filtrare, decomprimere e visionare
      la pagina.  Impostare <literal>maxusers</literal> a 64 ti consentir&agrave;
      di avere fino a 1044 processi simultanei, che dovrebbero essere abbastanza
      per qualsiasi uso.  Se comunque incontri il temuto errore <errortype>
      proc table full</errortype> quando cerchi di avviare un altro programma
      o stai usando un server con molti utenti simultanei (come
      <hostid role="fqdn">ftp.FreeBSD.org</hostid>), puoi sempre aumentare
      il numero e ricompilare.</para>

    <note>
      <para><literal>maxusers</literal> <emphasis>non</emphasis>
        limita il numero di utenti che possono loggarsi nella tua macchina.
        Semplicemente imposta molte tabella di sistema a dimensioni ragionevoli
        rispetto al massimo numero di utenti che tu potresti avere sul tuo sistema
        e quanti processi staranno girando.  Una parola chiave che invece
        <emphasis>limita</emphasis> il numero di login remoti
        simultanei e X terminal windows &egrave; <link linkend="kernelconfig-ptys">
        <literal>pseudo-device pty 16</literal></link>.  Con &os;&nbsp;5.X,
        non devi preoccuparti di questo numero dato che il driver &man.pty.4;
        &egrave; <quote>auto-cloning</quote>; tu semplicemente usi la linea
        <literal>device pty</literal> nel tuo file di configurazione.</para>
    </note>
    
    <programlisting># Floating point support - do not disable.
device          npx</programlisting>
    
    <para><literal>npx</literal> &egrave; l'interfaccia all'unit&agrave;
      matematica a virgola mobile in &os;, che &egrave; o il
      coprocessore hardware o l'emulatore software matematico.
      Questo <emphasis>non</emphasis> &egrave; opzionale.</para>

    <programlisting># Pseudo devices
device   loop          # Network loopback</programlisting>

    <para>Questo &egrave; il generico device loopback per TCP/IP.  Se fai telnet
      o FTP a <hostid>localhost</hostid> (anche conosciuto come
      <hostid role="ipaddr">127.0.0.1</hostid>) la connessione ritorner&agrave;
      alla tua stessa macchina attraverso questo device.  Questo &egrave;
      <emphasis>obbligatorio</emphasis>.  Sotto &os;&nbsp;4.X devi usare
      la linea <literal>pseudo-device loop</literal>.</para>

    <para>Tutto ci&ograve; che segue &egrave; pi&ugrave; o meno opzionale.
      Leggi le note sotto o a fianco di ogni opzione per maggiori
      informazioni.</para>

    <programlisting>#To statically compile in device wiring instead of /boot/device.hints
#hints          "GENERIC.hints"         # Default places to look for devices.</programlisting>

    <para>In &os; 5.X e versioni successive il &man.device.hints.5; &egrave;
      usato per configurare le opzioni dei device driver.  La posizione
      di default che &man.loader.8; cercher&agrave; al momento del boot
      &egrave; <filename>/boot/device.hints</filename>.  Usando l'opzione
      <literal>hints</literal> puoi compilare queste direttive direttamente
       nel kernel.  Se fai cos&igrave; non c'&egrave; bisogno di creare
       un file <filename>device.hints</filename> in <filename>/boot</filename>.</para>

    <programlisting>#makeoptions     DEBUG=-g          # Build kernel with gdb(1) debug symbols</programlisting>

    <para>Il processo normale di compilazione di &os; non include
      informazioni di debugging quando si compila il kernel e
      toglie la maggior parte dei simboli dopo che il kernel risultante
      &egrave; stato linkato, per risparmiare spazio nella directory
      di installazione.  Se hai intenzione di fare test con il kernel
      nella branch -CURRENT o sviluppare cambiamenti per il kernel di
      &os;, puoi voler scommentare questa linea.  Abiliter&agrave;
      l'uso dell'opzione <option>-g</option> che abilita informazioni
      di debugging quando passato a &man.gcc.1;.  Lo stesso pu&ograve;
      essere ottenuto dall'opzione di &man.config.8; <option>-g</option>,
      se stai usando il modo tradizionale per compilare i tuoi kernel
      (consulta <xref linkend="kernelconfig-building"> per maggiori informazioni).
    </para>

    <programlisting>options          SCHED_4BSD         # 4BSD scheduler</programlisting>

    <para>Lo schedulatore tradizionale per &os;.  A seconda del tuo carico 
      di sistema, puoi ottenere miglioramenti nella performance usando
      il nuovo schedulatore ULE per &os; che &egrave; stato disegnato apposta
      per sistemi SMP, ma funziona bene anche su sistemi UP.  Se desideri
      provarlo, sostituisci <literal>SCHED_4BSD</literal> con
      <literal>SCHED_ULE</literal> nel tuo file di configurazione.</para>

    <programlisting>options          INET              # InterNETworking</programlisting>

    <para>Supporto per la rete.  Lascia questa opzione, anche se non intendi
      connettere il computer ad una rete.  La maggior parte dei programmi
      richiedono almeno rete di loopback (ad esempio fare connessioni di rete
      dal tuo pc al tuo pc stesso), cos&igrave; questa opzione in sostanza &egrave;
      obbligatoria.</para>

    <programlisting>options          INET6             # IPv6 communications protocols</programlisting>

    <para>Questo abilita il protocollo di comunicazione IPv6.</para>

    <programlisting>options          FFS               # Berkeley Fast Filesystem</programlisting>

    <para>Questo &egrave; il file system di dischi di base.  Lascialo nel kernel
      se fai il boot da hard disk.</para>

    <programlisting>options          SOFTUPDATES       # Enable FFS Soft Updates support</programlisting>

    <para>Questa opzione abilita le Soft Updates nel kernel, aiuter&agrave;
      a velocizzare accesso di scrittura ai dischi.  Anche quando questa
      funzionalit&agrave; &egrave; fornita dal kernel, deve essere
      attivata per dischi specifici.  Rileggi l'output da &man.mount.8;
      per vedere se Soft Updates sono abilitate per i tuoi dischi di sistema.
      Se non vedi l'opzione <literal>soft-updates</literal> potrai
      abilitarla usando &man.tunefs.8; (per file system gi&agrave;
      esistenti) o &man.newfs.8; (per nuovi file system).</para>

    <programlisting>options          UFS_ACL           # Support for access control lists</programlisting>

    <para>Questa opzione, presente solo in &os;&nbsp;5.X abilita supporto
      nel kernel per le liste di controllo di accesso.  Questo poggia sull'uso
      degli attributi estesi e <acronym>UFS2</acronym>, questa opzione viene
      descritta in dettaglio in <xref linkend="security">.  <acronym>ACL</acronym>
      sono abilitate di default e non dovrebbero essere disabilitate nel kernel
      se sono state usate precedentemente su un file system, dato che questo
      rimuover&agrave; le liste di controllo di accesso, cambiando il modo
      in cui i file sono protetti in modo non predicibile.</para>

    <programlisting>options          UFS_DIRHASH       # Improve performance on big directories</programlisting>

    <para>Quest'opzione include funzionalit&agrave; per accelerare
      operazioni sui dischi su larghe directory, a costo di uso
      di memoria.  Lo dovresti tenere per un server molto trafficato
      o workstation interattive, e rimuoverlo se stai usando
      &os; su piccoli sistemi dove la memoria &egrave; scarsa e
      l'accesso ai dischi &egrave; meno importante, come un firewall.</para>

    <programlisting>options          MD_ROOT           # MD is a potential root device</programlisting>

    <para>Questa opzione abilita il supporto per un disco virtuale
      basato sulla memoria da usare come device di root.</para>

    <indexterm>
      <primary>opzioni del kernel</primary>
      <secondary>NFS</secondary>
    </indexterm>
    <indexterm>
      <primary>opzioni del kernel</primary>
      <secondary>NFS_ROOT</secondary>
    </indexterm>
    <programlisting>options          NFSCLIENT         # Network Filesystem Client
options          NFSSERVER         # Network Filesystem Server
options          NFS_ROOT          # NFS usable as /, requires NFSCLIENT</programlisting>

    <para>Il file system di rete.  A meno che tu non intenda montare
      partizioni da un file server &unix; sopra TCP/IP, puoi commentare
      queste righe.</para>

    <indexterm>
      <primary>opzioni del kernel</primary>
      <secondary>MSDOSFS</secondary>
    </indexterm>
    <programlisting>options          MSDOSFS           # MSDOS Filesystem</programlisting>

    <para>Il filesystem &ms-dos;.  A meno che non intendi montare un
      disco formattato DOS al momento del boot, puoi tranquilamente
      commentare queste opzioni.  Sar&agrave; automaticamente caricato
      la prima volta che monti una partizione DOS, come descritto in seguito.
      Inoltre, l'eccellente software <filename role="package">emulators/mtools</filename>
      ti permette di accedere a floppy DOS senza dover montarli e smontarli
      (e non richiede assolutamente <literal>MSDOSFS</literal>).</para>

    <programlisting>options          CD9660            # ISO 9660 Filesystem</programlisting>

    <para>Il file system ISO 9660 per CDROM.  Commentalo se non hai
      un drive CDROM o monti CD di dati solo occasionalmente (dato
      che sar&agrave; caricato dinamicamente la prima volta che monti
      un CD di dati).  CD audio non necessitano di questo file system.</para>

    <programlisting>options          PROCFS            # Process filesystem</programlisting>

    <para>Il file system dei processi.  Questo &egrave; un <quote>fittizio</quote>
      file system montato su <filename>/proc</filename> che permette
      a programmi come &man.ps.1; di darti maggiori informazioni
      su quali processi sono in esecuzione.  Su &os; 5.X e successivi,
      l'uso di <literal>PROCFS</literal> non &egrave; richiesto
      nella maggior parte dei casi, dato che la maggior parte
      dei tool di debugging e di monitoring &egrave; stato adattato per
      funzionare senza <literal>PROCFS</literal>: a differenza di &os;
      4.X, le nuove installazioni di &os; 5.X non monteranno il file system
      dei processi di default.  Inoltre, i kernel 6.X-CURRENT che usano
      <literal>PROCFS</literal> devono anche includere il supporto
      per lo <literal>PSEUDOFS</literal>:</para>

    <programlisting>options          PSEUDOFS          # Pseudo-filesystem framework</programlisting>

    <para><literal>PSEUDOFS</literal> non &egrave; disponibile in &os; 4.X.</para>

    <programlisting>options          GEOM_GPT          # GUID Partition Tables.</programlisting>

    <para>Questa opzione fornisce la possibilit&agrave; di avere
      un gran numero di partizioni su un singolo disco.</para>

    <programlisting>options          COMPAT_43         # Compatible with BSD 4.3 [KEEP THIS!]</programlisting>

    <para>Compatibilit&agrave; con 4.3BSD.  Lasciala; alcuni programmi
      si comporteranno in maniera strana se la commenti.</para>

    <programlisting>options          COMPAT_FREEBSD4   # Compatible with &os;4</programlisting>

    <para>Questa opzione &egrave; richiesta su &os;&nbsp;5.X su sistemi
      &i386; e Alpha per supportare applicazioni compilate su versioni
      precedenti di &os; che usano vecchie interfacce di system call.
      Si raccomanda che questa opzione sia usata su tutte le &i386;
      ed Alpha che possano eseguire vecchie applicazioni; piattaforme
      che hanno ottenuto supporto solo dall 5.X, come ia64 e &sparc64;
      non richiedono questa opzione.</para>

    <programlisting>options          SCSI_DELAY=15000  # Delay (in ms) before probing SCSI</programlisting>

    <para>Questa opzione fa s&igrave; che il kernel faccia una pausa
      di 15 secondi prima di controllare ogni device SCSI sul tuo sistema.
      Se hai solo dischi IDE, puoi ignorarla, altrimenti potresti
      voler diminuire il numero, forse a 5 secondi, per accelerare
      il boot.  Ovviamente, se fai ci&ograve; e &os; ha problemi
      a riconoscere i tuoi device SCSI, dovrai alzarla di nuovo.</para>

    <programlisting>options          KTRACE            # ktrace(1) support</programlisting>

    <para>Questo abilita il tracciamento dei processi nel kernel,
      che &egrave; utile per il debugging.</para>

    <programlisting>options          SYSVSHM           # SYSV-style shared memory</programlisting>

    <para>Questa opzione fornisce memoria condivisa di tipo System&nbsp;V.
      L'uso pi&ugrave; comune di questa opzione &egrave; l'estensione
      XSHM in X, grazie alla quale molti programmi ad alta 
      intensit&agrave; grafica ne trarranno vantaggio per maggior
      velocit&agrave;.  Se usi X, vorrai sicuramente includere questa opzione.
    </para>

    <programlisting>options          SYSVMSG           # SYSV-style message queues</programlisting>

    <para>Supporto per messaggi stile System&nbsp;V.  Questa opzione aggiunge
      solo poche centinaia di byte al kernel.</para>

    <programlisting>options          SYSVSEM           # SYSV-style semaphores</programlisting>

    <para>Supporto per semafori stile System&nbsp;V.  Usato meno di frequente
      ma aggiunge solo poche centinaia di byte al kernel.</para>

    <note>
      <para>L'opzione <option>-p</option> del comando &man.ipcs.1; mostrer&agrave;
        ogni processo che usa uno di queste opzione System&nbsp;V.</para>
    </note>

    <programlisting>options 	     _KPOSIX_PRIORITY_SCHEDULING # POSIX P1003_1B real-time extensions</programlisting>

    <para>Estensioni real-time aggiunte al &posix; 1993.  Alcune
      applicazioni nella collezione dei Ports usano questa opzione
      (come <application>&staroffice;</application>).</para>

    <programlisting>options          KBD_INSTALL_CDEV  # install a CDEV entry in /dev</programlisting>

    <para>Questa opzione &egrave; relativa ala tastiera.  Aggiunge una entry CDEV
      nella directory <filename>/dev</filename>.</para>

    <programlisting>options          AHC_REG_PRETTY_PRINT     # Print register bitfields in debug
                                          # output.  Adds ~128k to driver.
options          AHD_REG_PRETTY_PRINT     # Print register bitfields in debug
                                          # output.  Adds ~215k to driver.</programlisting>

    <para>Questo aiuta a debuggare scrivendo pi&ugrave; semplici definizioni
      dei registri per faciltare la lettura.</para>

    <programlisting>options          ADAPTIVE_GIANT    # Giant mutex is adaptive.</programlisting>

    <para>Giant &egrave; il nome di un meccanismo di esclusione reciproca
      (uno sleep mutex) che protegge gran parte delle risorse del kernel.
      Al giorno d'oggi &egrave; un inaccettabile rallentamento delle performance
      che si sta attivamente sostituendo con locks che proteggono risorse
      individuali.  L'opzione <literal>ADAPTIVE_GIANT</literal> fa s&igrave;
      che Giant sia incluso nell'insieme dei mutex da scegliere.  Cio&egrave;
      quando un thread vuole fare un lock sul mutex Giant, ma &egrave; gi&agrave; 
      bloccato da un thread su un'altra CPU, il primo thread continuer&agrave;
      a girare ed aspetter&agrave; che il lock sia rilasciato.  Normalmente
      invece, il thread tornerebbe a dormire e aspetter&agrave; la sua prossima
      occasione per girare.  Se non sei sicuro, lascialo dentro.</para>

    <indexterm>
      <primary>kernel options</primary>
      <secondary>SMP</secondary>
    </indexterm>
    <programlisting>device          apic               # I/O APIC</programlisting>

    <para>Il device apic abilita l'uso dell'APIC I/O per inviare
      gli interrupt.  Il device apic pu&ograve; essere usato sia su kernel
      UP che su SMP, ma &egrave; richiesto per kernel SMP.  Aggiungi
      <literal>option SMP</literal> per includere supporto per processori
      multipli.</para>

    <programlisting>device          isa</programlisting>

    <para>Tutti i PC supportati da &os; hanno uno di questi.  Non rimuoverlo
      anche se non hai slot ISA.  Se hai un sistema IBM PS/2
      (Micro Channel Architecture), &os; fornisce solo supporto
      limitato al giorno d'oggi.  Per maggiori informazioni sul supporto
      MCA, consulta <filename>/usr/src/sys/i386/conf/NOTES</filename>.</para>

    <programlisting>device          eisa</programlisting>

    <para>Includilo se hai una motherboard EISA.  Questo abilita
      supporto per l'auto-rilevazione e configurazione per tutti i device
      sul bus EISA.</para>

    <programlisting>device          pci</programlisting>

    <para>Includilo se hai una motherboard PCI.  Questo abilita
      l'auto-rilevazione delle carte PCI e operazioni di gateway
      dal bus PCI al bus ISA.</para>

    <programlisting># Floppy drives
device          fdc</programlisting>

    <para>Questo abilita il supporto al controller del floppy drive.</para>

    <programlisting># ATA and ATAPI devices
device          ata</programlisting>

    <para>Questo driver supporta tutti i device ATA e ATAPI.  Hai bisogno
      solo di una linea <literal>device ata</literal> per il kernel
      affinch&egrave; rilevi tutti i device PCI ATA/ATAPI su macchine moderne.</para>

    <programlisting>device          atadisk                 # ATA disk drives</programlisting>

    <para>Questo &egrave; necessario assieme a <literal>device ata</literal>
      per disk drive ATA.</para>

    <programlisting>device          ataraid                 # ATA RAID drives</programlisting>

    <para>Questo &egrave; necessario assieme a <literal>device ata</literal> per drive
      ATA RAID.</para>

    <programlisting><anchor id="kernelconfig-atapi">
device          atapicd                 # ATAPI CDROM drives</programlisting>

    <para>Questo &egrave; necessario assieme a <literal>device ata</literal> per
      drive CDROM ATAPI.</para>

    <programlisting>device          atapifd                 # ATAPI floppy drives</programlisting>

    <para>Questo &egrave; necessario assieme a <literal>device ata</literal> per
      drive floppy ATAPI.</para>

    <programlisting>device          atapist                 # ATAPI tape drives</programlisting>

    <para>Questo &egrave; necessario assieme a <literal>device ata</literal> per
      drive tape ATAPI.</para>

    <programlisting>options         ATA_STATIC_ID           # Static device numbering</programlisting>

    <para>Questo rende il numero di controller statico; senza questo
      i numeri di device sono allocati dinamicamente.</para>

    <programlisting># SCSI Controllers
device          ahb        # EISA AHA1742 family
device          ahc        # AHA2940 and onboard AIC7xxx devices
device          ahd        # AHA39320/29320 and onboard AIC79xx devices
device          amd        # AMD 53C974 (Teckram DC-390(T))
device          isp        # Qlogic family
device          mpt        # LSI-Logic MPT-Fusion
#device         ncr        # NCR/Symbios Logic
device          sym        # NCR/Symbios Logic (newer chipsets)
device          trm        # Tekram DC395U/UW/F DC315U adapters

device          adv        # Advansys SCSI adapters
device          adw        # Advansys wide SCSI adapters
device          aha        # Adaptec 154x SCSI adapters
device          aic        # Adaptec 15[012]x SCSI adapters, AIC-6[23]60.
device          bt         # Buslogic/Mylex MultiMaster SCSI adapters

device          ncv        # NCR 53C500
device          nsp        # Workbit Ninja SCSI-3
device          stg        # TMC 18C30/18C50</programlisting>

    <para>Controller SCSI.  Commentali tutti se non ne hai nessuno
      sul tuo sistema.  Se hai un sistema solo IDE, puoi rimuoverli
      tutti.</para>

    <programlisting># SCSI peripherals
device          scbus      # SCSI bus (required for SCSI)
device          ch         # SCSI media changers
device          da         # Direct Access (disks)
device          sa         # Sequential Access (tape etc)
device          cd         # CD
device          pass       # Passthrough device (direct SCSI access)
device          ses        # SCSI Environmental Services (and SAF-TE)</programlisting>

    <para>Periferiche SCSI.  Ancora, commentali se non ne hai nessuna
      o se il tuo sistema &egrave; solo IDE.</para>

    <note>
      <para>Il driver USB &man.umass.4; e pochi altri driver usano
        il sottosistema SCSI anche se non sono veri device SCSI.
        Quindi accertati di non rimuovere il supporto a SCSI,
        se qualche driver del genere &egrave; incluso nella tua
        configurazione del kernel.</para>
    </note>

    <programlisting># RAID controllers interfaced to the SCSI subsystem
device          amr        # AMI MegaRAID
device          arcmsr     # Areca SATA II RAID
device          asr        # DPT SmartRAID V, VI and Adaptec SCSI RAID
device          ciss       # Compaq Smart RAID 5*
device          dpt        # DPT Smartcache III, IV - See NOTES for options
device          hptmv      # Highpoint RocketRAID 182x
device          iir        # Intel Integrated RAID
device          ips        # IBM (Adaptec) ServeRAID
device          mly        # Mylex AcceleRAID/eXtremeRAID
device          twa        # 3ware 9000 series PATA/SATA RAID

# RAID controllers
device          aac        # Adaptec FSA RAID
device          aacp       # SCSI passthrough for aac (requires CAM)
device          ida        # Compaq Smart RAID
device          mlx        # Mylex DAC960 family
device          pst        # Promise Supertrak SX6000
device          twe        # 3ware ATA RAID</programlisting>

    <para>Controller RAID supportati.  Se non ne hai nessuno,
      puoi commentarli o rimuoverli.</para>

    <programlisting># atkbdc0 controls both the keyboard and the PS/2 mouse
device          atkbdc     # AT keyboard controller</programlisting>

    <para>Il controller della tastiera (<literal>atkbdc</literal>) fornisce
      servizi I/O per la tastiera AT ed il device PS/2.  Questo controller
      &egrave; richiesto dal driver della tastiera
      (<literal>atkbd</literal>) e dal driver del dispositivo di puntamento
      PS/2 (<literal>psm</literal>).</para>

    <programlisting>device          atkbd      # AT keyboard</programlisting>

    <para>Il driver <literal>atkbd</literal> assieme al controller
      <literal>atkbdc</literal>, fornisce accesso alla tastiera AT 84
       o la tastiera AT migliorata che &egrave; connesso al controller
       della tastiera AT.</para>

    <programlisting>device          psm        # PS/2 mouse</programlisting>

    <para>Usa questo device se il tuo mouse si inserisce nella porta
      PS/2.</para>

    <programlisting>device          vga        # VGA video card driver</programlisting>

    <para>Il driver della video card.</para>

    <programlisting># splash screen/screen saver
device          splash     # Splash screen and screen saver support</programlisting>

    <para>Schermata slapsh all'avvio! Anche gli screensaver lo richiedono.
      Usa la linea <literal>pseudo-device splash</literal> con &os;&nbsp;4.X.</para>

    <programlisting># syscons is the default console driver, resembling an SCO console
device          sc</programlisting>

    <para><literal>sc</literal> &egrave; il driver di default della console,
      assomiglia ad una console SCO.  Dato che molti programmi a schermo 
      intero accedono alla console attraverso una libreria di database di terminali
      come <filename>termcap</filename>, non dovrebbe fare differenza se usi questo
      o <literal>vt</literal>, il driver compatibile con una console
      <literal>VT220</literal>.  Quando ti logghi, imposta la tua variabile
      d'ambiente <envar>TERM</envar> a <literal>scoansi</literal> se programmi
      a schermo intero hanno problemi a girare sotto questa console.</para>

    <programlisting># Enable this for the pcvt (VT220 compatible) console driver
#device          vt
#options         XSERVER          # support for X server on a vt console
#options         FAT_CURSOR       # start with block cursor</programlisting>

    <para>Questo &egrave; un driver di console compatibile con VT-220,
      compatibile all'indietro con VT100/102.  Funziona bene su alcuni laptop
      che hanno incompatibilit&agrave; hardware con <literal>sc</literal>.
      Inoltre imposta la tua variabile <envar>TERM</envar> a <literal>vt100</literal>
      o <literal>vt220</literal> quando ti logghi.  Questo driver pu&ograve;
      essere utile quando ci si connette ad un grande numero di macchine
      diverse sulla rete, dove le entry <filename>termcap</filename> o
      <filename>terminfo</filename> per il device <literal>sc</literal>
      spesso non sono disponibili &mdash; <literal>vt100</literal>
      dovrebbe essere disponibile virtualmente su ogni piattaforma.</para>

    <programlisting>device          agp</programlisting>

    <para>Includilo se hai una scheda AGP nel tuo sistema.  Questo
      abiliter&agrave; il supporto per AGP, e AGP GARTS per motherboards
      che hanno queste caratteristiche.</para>

    <indexterm>
      <primary>APM</primary>
    </indexterm>

    <programlisting># Power management support (see NOTES for more options)
#device          apm</programlisting>

    <para>Supporto Advanced Power Management.  Utile per laptop,
      anche se in &os; 5.X e successivo questo &egrave; disabilitato
      in <filename>GENERIC</filename> di default.</para>

    <programlisting># Add suspend/resume support for the i8254.
device           pmtimer</programlisting>

    <para>Device driver per eventi di power management, come APM
      ed ACPI.</para>

    <programlisting># PCCARD (PCMCIA) support
# PCMCIA and cardbus bridge support
device          cbb               # cardbus (yenta) bridge
device          pccard            # PC Card (16-bit) bus
device          cardbus           # CardBus (32-bit) bus</programlisting>

    <para>Supporto PCMCIA.  Includilo se usi un laptop.</para>

    <programlisting># Serial (COM) ports
device          sio               # 8250, 16[45]50 based serial ports</programlisting>

    <para>Queste sono le porte seriali chiamate
      <devicename>COM</devicename> nel mondo &ms-dos;/&windows;.</para>

    <note>
      <para>Se hai un modem interno sulla <devicename>COM4</devicename>
        ed una porta seriale sulla <devicename>COM2</devicename>, dovrai
        cambiare l'IRQ del modem a 2 (per ragioni tecniche oscure
        IRQ 2=IRQ 9) affinch&egrave; tu ci possa accedere da &os;.
        Se hai una carta seriale multiporta, controlla la pagina di manuale
        per &man.sio.4; per maggiori informazioni sui valori corretti
        da aggiungere al tuo <filename>/boot/device.hints</filename>.
        Alcune video card (in particolare quelle basate su chip S3)
        usano indirizzi IO della forma <literal>0x*2e8</literal> e dato che
        molte carte seriali non codificano l'intero spazio degli indirizzi
        IO a 16 bit, hanno conflitti con queste carte, rendendo la porta
        <literal>COM4</literal> praticamente non disponibile.</para>
         
      <para>Ogni porta seriale deve avere un IRQ unico (a meno che non stia usando
        una delle carte multicard dove sono supportati interrupt condivisi),
        cos&igrave; gli IRQ di default per <devicename>COM3</devicename> e
        <devicename>COM4</devicename> non possono essere usati.</para>
    </note>

    <programlisting># Parallel port
device          ppc</programlisting>

    <para>Questo &egrave; l'interfaccia al bus ISA parallelo.</para>

    <programlisting>device          ppbus      # Parallel port bus (required)</programlisting>

    <para>Fornisce supporto per il bus della porta parallela.</para>

    <programlisting>device          lpt        # Printer</programlisting>

    <para>Supporto per la stampante a porta parallela.</para>

    <note>
      <para>Tutte quest tre sono necessarie per abilitare supporto
        alla stampante parallela.</para>
    </note>

    <programlisting>device          plip       # TCP/IP over parallel</programlisting>

    <para>Questo &egrave; il driver della interfaccia di rete parallela.</para>

    <programlisting>device          ppi        # Parallel port interface device</programlisting>

    <para>L'I/O a scopo generico (<quote>geek port</quote>) + IEEE1284
      I/O.</para>

    <programlisting>#device         vpo        # Requires scbus and da</programlisting>

    <indexterm><primary>zip drive</primary></indexterm>
    <para>Questo &egrave; per uno IOMEGA zip drive.  Richiede
      supporto <literal>scbus</literal> e <literal>da</literal>.  La migliore
      performance &egrave; raggiunta con porte in modo EPP 1.9.</para>

    <programlisting>#device         puc</programlisting>

    <para>Scommenta questo device se ha una seriale <quote>dumb</quote>
      o carta PCI parallela che &egrave; supportata dal driver glue
      &man.puc.4;.</para>

    <programlisting># PCI Ethernet NICs.
device          de         # DEC/Intel DC21x4x (<quote>Tulip</quote>)
device          em         # Intel PRO/1000 adapter Gigabit Ethernet Card
device          ixgb       # Intel PRO/10GbE Ethernet Card
device          txp        # 3Com 3cR990 (<quote>Typhoon</quote>)
device          vx         # 3Com 3c590, 3c595 (<quote>Vortex</quote>)</programlisting>

    <para>Vari driver di schede di rete PCI.  Commentalo o rimuovilo
      se nessuno di questi &egrave; presente nel tuo sistema.</para>

    <programlisting># PCI Ethernet NICs that use the common MII bus controller code.
# NOTE: Be sure to keep the 'device miibus' line in order to use these NICs!
device          miibus     # MII bus support</programlisting>

    <para>Supporto bus MII &egrave; richiesto per alcune NIC Ethernet 10/100 PCI,
      in particolare quelle che usano transricevitori compatibili con MII
      o implementano interfacce di controllo che operano su MII.  Aggiungere
      <literal>device miibus</literal> al kernel porta con s&egrave; il supporto
      per la generica API miibus e tutti i driver PHY, incluso un
      generico per PHY che non &egrave; specificamente gestito da driver
      individuali.</para>

    <programlisting>device          bfe        # Broadcom BCM440x 10/100 Ethernet
device          bge        # Broadcom BCM570xx Gigabit Ethernet
device          dc         # DEC/Intel 21143 and various workalikes
device          fxp        # Intel EtherExpress PRO/100B (82557, 82558)
device          lge        # Level 1 LXT1001 gigabit ethernet
device          nge        # NatSemi DP83820 gigabit ethernet
device          pcn        # AMD Am79C97x PCI 10/100 (precedence over 'lnc')
device          re         # RealTek 8139C+/8169/8169S/8110S
device          rl         # RealTek 8129/8139
device          sf         # Adaptec AIC-6915 (<quote>Starfire</quote>)
device          sis        # Silicon Integrated Systems SiS 900/SiS 7016
device          sk         # SysKonnect SK-984x & SK-982x gigabit Ethernet
device          ste        # Sundance ST201 (D-Link DFE-550TX)
device          ti         # Alteon Networks Tigon I/II gigabit Ethernet
device          tl         # Texas Instruments ThunderLAN
device          tx         # SMC EtherPower II (83c170 <quote>EPIC</quote>)
device          vge        # VIA VT612x gigabit ethernet
device          vr         # VIA Rhine, Rhine II
device          wb         # Winbond W89C840F
device          xl         # 3Com 3c90x (<quote>Boomerang</quote>, <quote>Cyclone</quote>)</programlisting>

    <para>Driver che usano il codice del controller MII.</para>

    <programlisting># ISA Ethernet NICs.  pccard NICs included.
device          cs         # Crystal Semiconductor CS89x0 NIC
# 'device ed' requires 'device miibus'
device          ed         # NE[12]000, SMC Ultra, 3c503, DS8390 cards
device          ex         # Intel EtherExpress Pro/10 and Pro/10+
device          ep         # Etherlink III based cards
device          fe         # Fujitsu MB8696x based cards
device          ie         # EtherExpress 8/16, 3C507, StarLAN 10 etc.
device          lnc        # NE2100, NE32-VL Lance Ethernet cards
device          sn         # SMC's 9000 series of Ethernet chips
device          xe         # Xircom pccard Ethernet

# ISA devices that use the old ISA shims
#device         le</programlisting>

    <para>Driver ISA Ethernet.  Vedi
      <filename>/usr/src/sys/<replaceable>i386</replaceable>/conf/NOTES</filename> 
      per dettagli su quali carte siano supportate da quali driver.</para>

    <programlisting># Wireless NIC cards
device          wlan       # 802.11 support
device          an         # Aironet 4500/4800 802.11 wireless NICs.
device          awi        # BayStack 660 and others
device          wi         # WaveLAN/Intersil/Symbol 802.11 wireless NICs.
#device         wl         # Older non 802.11 Wavelan wireless NIC.</programlisting>

    <para>Supporto per varie carte wireless.</para>

    <programlisting>device   mem           # Memory and kernel memory devices</programlisting>

    <para>I device della memoria di sistema.</para>

    <programlisting>device   io            # I/O device</programlisting>

    <para>Questa opzione permette ad un processo di guadagnare privilegi I/O.
      &Egrave; utile per scrivere programmi user land che possono gestire
      hardware direttamente.  &Egrave; richiesto per eseguire il
      X Window System.</para>

    <programlisting>device   random        # Entropy device</programlisting>

    <para>Generatore casuale sicuro di numeri random.</para>

    <programlisting>device   ether         # Ethernet support</programlisting>

    <para><literal>ether</literal> &egrave; necessario solo se hai una
      carta Ethernet.  Include un codice di protocollo Ethernet.  Sotto
      &os;&nbsp;4.X usa la linea <literal>pseudo-device ether</literal>.</para>

    <programlisting>device   sl            # Kernel SLIP</programlisting>

    <para><literal>sl</literal> &egrave; per supporto slip.  &Egrave; stato
      interamente soppiantato da PPP, che &egrave; pi&ugrave; semplice da installare,
      pi&ugrave; adatto per connessioni modem-to-modem e pi&ugrave; potente.
      Con &os;&nbsp;4.X usa la linea <literal>pseudo-device sl</literal>.</para>

    <programlisting>device   ppp           # Kernel PPP</programlisting>

    <para>Questo &egrave; per supporto kernel PPP per connessioni dial-up.
      C'&egrave; anche una versione di PPP implementata come applicazione
      userland che usa <literal>tun</literal> e offre pi&ugrave; flessibilit&agrave;
      e caratteristiche aggiuntive come dialing a domanda.  Con &os;&nbsp; 4.X
      usa la linea <literal>pseudo-device ppp</literal>.</para>

    <programlisting>device   tun           # Packet tunnel.</programlisting>

    <para>Questo &egrave; usato per software userland PPP.
      Vedi la sezione
      <link linkend="userppp">PPP</link> di questo libro per maggiori informazioni.
      Con &os;&nbsp;4.X usa la linea <literal>pseudo-device tun</literal>.</para>

    <programlisting><anchor id="kernelconfig-ptys">
device   pty           # Pseudo-ttys (telnet etc)</programlisting>

    <para>Questo &egrave; uno <quote>pseudo-terminal</quote> o porta di login
      simulato.  &Egrave; usato da sessioni <command>telnet</command> e
      <command>rlogin</command>, <application>xterm</application> e qualche altra
      applicazione come <application>Emacs</application>.</para>

    <note><para>Sotto &os;&nbsp;4.X, devi
      usare la linea <literal>pseudo-device pty<replaceable>
      numero</replaceable></literal>.  Il <replaceable>numero
      </replaceable> dopo <literal>pty</literal> indica il numero 
      di <literal>pty</literal> da creare.  Se necessiti di pi&ugrave;
      dei 16 login simultanei di default con <application>xterm</application>
      e/o login remote, accertati di incrementare questo numero
      di conseguenza, fino ad un massimo di 256.</para></note>

    <programlisting>device   md            # Memory <quote>disks</quote></programlisting>

    <para>Disco di memoria pseudo-device.  Con &os;&nbsp;4.X usa la linea
      <literal>pseudo-device md</literal>.</para>

    <programlisting>device   gif           # IPv6 and IPv4 tunneling</programlisting>

    <para>Questo implementa il tunneling IPv6 su IPv4, IPv4 su IPv6,
      IPv4 su IPv4 e IPv6 su IPv6.  A partire da &os;&nbsp;4.4 il device
      <literal>gif</literal> &egrave; <quote>autoclonante</quote>,
      e tu dovresti usare la linea <literal>pseudo-device gif</literal>.
      Versioni precedenti di &os;&nbsp;4.X richiedono un numero, ad esempio
      <literal>pseudo-device gif 4</literal>.</para>

    <programlisting>device   faith         # IPv6-to-IPv4 relaying (translation)</programlisting>

    <para>Questo pseudo-device cattura i pacchetti che sono inviati a lui
      e li distoglie dal demone di traslazione IPv4/IPv6.  Con
      &os;&nbsp;4.X usa la linea
      <literal>pseudo-device faith 1</literal>.</para>

    <programlisting># The `bpf' device enables the Berkeley Packet Filter.
# Be aware of the administrative consequences of enabling this!
# Note that 'bpf' is required for DHCP.
device   bpf           # Berkeley packet filter</programlisting>

    <para>Questo &egrave; il Berkeley Packet Filter.  Questo pseduo-device
      permette alle interfacce di rete di essere configurate
      in modo promiscuo, catturando ogni pacchetto su una rete broadcast
      (ad esempio una Ethernet).  Questi pacchetti possono essere
      catturati su disco e o esaminati con il programma
      &man.tcpdump.1;.  Con &os;&nbsp;4.X usa la linea
      <literal>pseudo-device bpf</literal>.</para>

    <note>
      <para>Il device &man.bpf.4; &egrave; anche usato da
        &man.dhclient.8; per ottenere l'indirizzo IP del default router
        (gateway) eccetera.  Se usi DHCP, lascia questa riga
        scommentata.</para>
    </note>

    <programlisting># USB support
device          uhci          # UHCI PCI-&gt;USB interface
device          ohci          # OHCI PCI-&gt;USB interface
#device         ehci          # EHCI PCI-&gt;USB interface (USB 2.0)
device          usb           # USB Bus (required)
#device         udbp          # USB Double Bulk Pipe devices
device          ugen          # Generic
device          uhid          # <quote>Human Interface Devices</quote>
device          ukbd          # Keyboard
device          ulpt          # Printer
device          umass         # Disks/Mass storage - Requires scbus and da
device          ums           # Mouse
device          urio          # Diamond Rio 500 MP3 player
device          uscanner      # Scanners
# USB Ethernet, requires mii
device          aue           # ADMtek USB Ethernet
device          axe           # ASIX Electronics USB Ethernet
device          cdce          # Generic USB over Ethernet
device          cue           # CATC USB Ethernet
device          kue           # Kawasaki LSI USB Ethernet
device          rue           # RealTek RTL8150 USB Ethernet</programlisting>

    <para>Supporto per vari device USB.</para>

    <programlisting># FireWire support
device          firewire      # FireWire bus code
device          sbp           # SCSI over FireWire (Requires scbus and da)
device          fwe           # Ethernet over FireWire (non-standard!)</programlisting>

    <para>Supporto per vari device FireWire.</para>

    <para>Per maggiori informazioni e device addizionali supportati
      da &os;, controlla
      <filename>/usr/src/sys/<replaceable>i386</replaceable>/conf/NOTES</filename>.</para>

      <sect2>
        <title>Configurazioni a Memoria Estesa (<acronym>PAE</acronym>)</title>
	<indexterm>
	  <primary>Physical Address Extensions
	    (<acronym>PAE</acronym>)</primary>
	  <secondary>memoria estesa</secondary>
	</indexterm>

	<para>Macchine con configurazione a memoria estesa richiedono pi&ugrave;
          di 4 gigabyte di limite nello spazio degli indirizzi Virtuale
          User+Kernel (<acronym>KVA</acronym>).  A causa di questa limitazione,
          Intel ha aggiunto supporto per lo spazio degli indirizzi fisico
          a 36-bit nel &pentium; Pro e linee successive di CPU.</para>
	
	<para>La caratteristica di
          Physical Address Extension (<acronym>PAE</acronym>)
          dell' &intel; &pentium; Pro e CPU successive permette
          configurazioni della memoria fino a 64 gigabyte.
          &os; fornisce supporto per questa caratteristica attraverso
          l'opzione di configurazione del kernel <option>PAE</option>,
          disponibile nella serie 4.X di &os; a partire da
          4.9-RELEASE e nella serie 5.X di &os; a partire da
          5.1-RELEASE.  A causa della limitazione della architettura
          della memoria Intel, nessuna distinzione &egrave;
          fatta per memorie sopra o sotto i 4 gigabyte.  Memoria allocata
          oltre i 4 gigabyte &egrave; semplicemente aggiunta al pool
          della memoria disponibile.</para>

	<para>Per abilitare il supporto <acronym>PAE</acronym> nel
          kernel, aggiungi semplicemente la seguente linea nel tuo
          file di configurazione del kernel:</para>
	
	<programlisting>options		    PAE</programlisting>

	<note>
	  <para>Il supporto <acronym>PAE</acronym> in &os;
            &egrave; disponibile solo per processori &intel; IA-32.
            Bisogna notare inoltre che il supporto <acronym>PAE</acronym>
            non ha ricevuto test esteso, e dovrebbe essere considerato
            di qualit&agrave; beta rispetto alle altre carateristiche
            stabili di &os;.</para>
	</note>

	<para>Il supporto per <acronym>PAE</acronym> in &os; ha qualche limitazione:</para>
	
	<itemizedlist>
	  <listitem>
	    <para>Un processo non &egrave; in grado di accedere
              a pi&ugrave; di 4 gigabte di spazio VM.</para>
	  </listitem>

	  <listitem>
	    <para>I moduli <acronym>KLD</acronym> non possono essere caricati
              in un kernel con abilitato <acronym>PAE</acronym>, a causa
              delle differenze nell'ambiente di compilazione di un modulo
              e del kernel.</para>
	  </listitem>

	  <listitem>
	    <para>Device driver che non usano l'interfaccia
              &man.bus.dma.9; causeranno corruzione dei dati
              in un kernel abilitato <acronym>PAE</acronym>, e non 
              se ne raccomanda l'uso.  Per questo motivo, il
              file di configurazione del kernel <filename>PAE</filename>
              fornito in &os; 5.X esclude tutti i driver per i quali
              non &egrave; stato testato il funzionamento in un kernel
              abilitato <acronym>PAE</acronym>.</para>
	  </listitem>

	  <listitem>
	    <para>Alcuni parametri che possono essere settati determinano
              l'uso delle risorse di memoria a partire dalla quantit&agrave;
              di memoria fisica disponibile.  Questi parametri
              possono allocare troppo spazio rispetto alle necessit&agrave;
              a causa della dimensione della memoria di un sistema
              <acronym>PAE</acronym>.  Un esempio simile &egrave;
              il sysctl <option>kern.maxvnodes</option>, che controlla
              il massimo numero di vnodes permessi nel kernel.  &Egrave;
              concesso di aggiustare questo ed altri parametri ad un
              valore ragionevole.</para>
	  </listitem>

	  <listitem>
	    <para>Pu&ograve; essere necessario aumentare lo spazio degli 
              indirizzi di memoria virtuale del kernel (<acronym>KVA</acronym>)
              o ridurre la quantit&agrave; di risorse specifiche che sono
              pesantemente usate (vedi oltre) per evitare
              esaurimenti di <acronym>KVA</acronym>.  L'opzione del kernel
              <acronym>KVA_PAGES</acronym> pu&ograve; essere usata per
              aumentare lo spazio <acronym>KVA</acronym>.</para>
	  </listitem>
	</itemizedlist>

	<para>Per motivi di stabilit&agrave; e di performance,
          si consiglia di consultare le pagine di manuale &man.tuning.7;.
          La pagina di manuale &man.pae.4; contiene informazioni
          aggiornate sul supporto <acronym>PAE</acronym>.</para>
    </sect2>
  </sect1>

  <sect1 id="kernelconfig-nodes">
    <title>Creare Nodi di Device</title>

    <indexterm><primary>device nodes</primary></indexterm>
    <indexterm>
      <primary><command>MAKEDEV</command></primary>
    </indexterm>

    <para><emphasis>Se stai usando &os;&nbsp;5.0 o successivo
      puoi tranquillamente saltare questa sezione.  Queste versioni
      usano &man.devfs.5; per allocare nodi di device in modo
      trasparente per l'utente.</emphasis></para>

    <para>Quasi ogni device nel kernel ha un file <quote>nodo</quote>
      nella directory <filename>/dev</filename>.  Questi nodi sembrano
      file regolari, ma sono in effetti entry speciali nel kernel
      che i programmi usano per accedere al device.  Lo script di shell
      <filename>/dev/MAKEDEV</filename>, che &egrave; eseguito
      quando installi per la prima volta il sistema operativo,
      crea quasi tutti i nodi supportati.  Comunque, non li crea
      <emphasis>tutti</emphasis>, cos&igrave; quando aggiungi
      supporto per un nuovo device, vale la pena di accertarsi che
      i device appropriati siano in questa directory, e, se non presenti
      aggiungerli.  Qua c'&egrave; un semplice esempio:</para>

    <para>Supponi di aggiungere supporto al kernel per IDE CD-ROM.  La linea da
      aggiungere &egrave;:</para>

    <programlisting>device acd0</programlisting>

    <para>Questo significa che dovresti cercare alcune entry che iniziano
      con <filename>acd0</filename> nella directory <filename>/dev</filename>,
      preferibilmente seguito da una lettera, come <literal>c</literal>,
      o preceduto dalla lettera <literal>r</literal>, che significa device
      <quote>raw</quote>.  Si scopre che questi file non sono presenti,
      cos&igrave; devi entrare nella directory <filename>/dev</filename>
      e digitare:</para>

    <indexterm>
      <primary><command>MAKEDEV</command></primary></indexterm>
    <screen>&prompt.root; <userinput>sh MAKEDEV acd0</userinput></screen>

    <para>Quando questo script termina, scoprirai che ci sono ora
      delle entry <filename>acd0c</filename> e <filename>racd0c</filename>
      in <filename>/dev</filename> cos&igrave; scoprirai che ha eseguito
      corretto.</para>

    <para>Per le sound card, i seguenti comandi creano le entry appropriati:</para>

    <screen>&prompt.root; <userinput>sh MAKEDEV snd0</userinput></screen>

    <note>
      <para>Quando crei nodi di device per device come sound card, se altre
        persone hanno accesso alla tua macchina, pu&ograve; essere desiderabile
        proteggere i device da accesso esterno aggiungendoli al file
        <filename>/etc/fbtab</filename>.  Vedi &man.fbtab.5; per maggiori
        informazioni.</para>
    </note>

    <para>Segui queste semplici procedure per ogni altro
      device non-<filename>GENERIC</filename> che non ha entry.</para>

    <note>
      <para>Tutti i controller SCSI usano lo stesso insieme
        di entry <filename>/dev</filename>, cos&igrave; non
        devi crearli.  Inoltre, schede di rete e pseudo-device
        SLIP/PPP non hanno entry in <filename>/dev</filename> del tutto,
        cos&igrave; non devi preoccuparti nemmeno di queste.</para>
    </note>
  </sect1>

  <sect1 id="kernelconfig-trouble">
    <title>Se Qualcosa Va Male</title>

    <para>Ci sono cinque categorie di problemi che si possono
      presentare quando si crea un nuovo kernel.  Sono:</para>

    <variablelist>
      <varlistentry>
	<term><command>config</command> fallisce:</term>

	<listitem>
	  <para>Se il comando &man.config.8; fallisce quando
            gli passi la descrizione del tuo kernel, hai fatto
            probabilmente un semplice errore da qualche parte.
            Fortunatamente &man.config.8; scriver&agrave; il numero della linea
            che ha dato errore, cos&igrave; puoi facilmente trovare
            la linea errata.  Ad esempio, se vedi:</para>

	  <screen>config: line 17: syntax error</screen>

	  <para>Accertati che la parola chiave
            sia scritta correttamente confrontandola con quella
            del kernel <filename>GENERIC</filename> o un altro
            riferimento.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>make</command> fallisce:</term>

	<listitem>
	  <para>Se il comando <command>make</command> fallisce, di solito
            segnala un errore nella descrizione del kernel che non &egrave;
            abbastanza grave per &man.config.8;.  Ancora, controlla la tua configurazione
            e se ancora non riesci a risolvere il problema, invia una mail
            a &a.questions; con la tua configurazione del kernel, e dovrebbe
            essere diagnosticato velocemente.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>L'installazione del kernel fallisce:</term>
	
	<listitem>
	  <para>Se il kernel &egrave; stato compilato correttamente,
            ma non si riesce ad installarlo (i comandi <command>
            make install</command> o <command>make installkernel</command> falliscono),
            la prima cosa da controllare &egrave; se il tuo sistema sta
            girando in securelevel 1 o pi&ugrave; alto (vedi &man.init.8;).
            L'installazione del kernel cerca di rimuovere il flag immutabile
            dal tuo kernel e impostare il flag immutabile su quello nuovo.
            Dato che securelevel 1 o pi&ugrave; alto impediscono di
            togliere i flag immutabili su ogni flag di sistema, l'installazione
            del kernel deve essere eseguita a securelevel 0 o pi&ugrave; bassa.</para>

	  <para>Quanto sopra si applica a &os; 4.X e versioni precedenti.
            &os; 5.X, con le versioni nuove, non imposta il flag immutabile
            del kernel ed un fallimento nell'installazione del kernel
            probabilmente indica un problema pi&ugrave; profondo.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>Il kernel non fa il boot:<anchor
	  id="kernelconfig-noboot"></term>

	<listitem>
	  <para>Se il tuo kernel non fa il boot, o fallisce nel
            riconoscimento dei tuoi device, non andare in panico!
            Fortunatamente &os; ha un ottimo meccanismo per
            ricominciare in questo caso.  Semplicemente scegli il kernel
            da cui vuoi fare il boot dal boot loader &os;.  Puoi accedere ad esso
            quando il sistema fa il conto alla rovescia da 10 al menu di boot.
            Premi un tasto qualsiasi tranne <keycap>Enter</keycap>, digita
            <command>unload</command> e poi digita 
            <command>boot /boot/<replaceable>kernel.old</replaceable>/kernel</command>
            o il nome del file di un altro kernel da cui puoi bootare
            correttamente.  Quando configuri un kernel, &egrave; sempre
            una buona idea tenere un kernel che si sa che funzioni
            a portata di mano.</para>

	  <para>Dopo aver fatto il boot con un kernel funzionante
            puoi controllare il tuo file di configurazione e cercare
            di ricompilarlo.  Una risorsa utile &egrave; il file
            <filename>/var/log/messages</filename> che, fra le altre cose,
            registra tutti messaggi del kernel da ogni boot riuscito.
            Inoltre, il comando &man.dmesg.8; scriver&agrave; i messaggi
            del kernel dall'ultimo boot.</para>

	  <note>
	    <para>Se hai problemi a compilare un kernel, accertati di
              tenere un kernel <filename>GENERIC</filename>, o qualche
              altro kernel che sai che funzioni a portata di mano,con un
              nome diverso cosich&egrave; non sia cancellato dalla successiva
              compilazione.  Non puoi affidarti su <filename>kernel.old</filename>
              perch&egrave; quando installi un nuovo kernel, <filename>kernel.old
              </filename> viene cancellato dall'ultimo kernel installato, che poteva
              essere non funzionanante.  Inoltre, appena possibile, sposta il
              kernel funzionanante nella directory corretta <filename class="directory">
              /boot/kernel</filename> o comandi come &man.ps.1; potrebbero non
              funzionare bene.  Per farlo, semplicemente rinomina la directory
              contenente il kernel funzionante:</para>

            <screen>&prompt.root; <userinput>mv /boot/kernel /boot/kernel.bad</userinput>
              &prompt.root; <userinput>mv /boot/<replaceable>kernel.good</replaceable> /boot/kernel</userinput></screen>           

	    <para>Per versioni di &os; precedenti alla 5.X, il comando corretto
              per <quote>sbloccare</quote> il file del kernel che
              <command>make</command> installa (per muovere un altro kernel
              di nuovo nella stessa directory) &egrave;:</para>

	    <screen>&prompt.root; <userinput>chflags noschg /kernel</userinput></screen>

	    <para>Se scopri che non puoi farlo, stai probabilmente
              girando a &man.securelevel.8; maggiore di zero.  Edita
              <literal>kern_securelevel</literal> in
              <filename>/etc/rc.conf</filename> e impostalo a <literal>-1</literal>
              , poi fai il reboot.  Puoi cambiarlo al suo valore precedente,
              quando sei soddisfatto del tuo nuovo kernel.</para>

	    <para>E, se vuoi <quote>bloccare</quote> il tuo nuovo kernel
              nella sua posizione, o qualsiasi altro file analogo,
              cosicch&egrave; non posssa essere spostato o alterato:</para>

	    <screen>&prompt.root; <userinput>chflags schg /kernel</userinput></screen>
	  </note>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>Il kernel funziona, ma &man.ps.1; non funziona pi&ugrave;.</term>

	<listitem>
	  <para>Se hai installato una versione del kernel differente
            da quella delle utilities di sistema, per esempio un kernel 5.X
            ed un sistema 4.X, molti comandi di stato del sistema
            come &man.ps.1; e &man.vmstat.8; non funzioneranno pi&ugrave;.
            Dovresti <link linkend="makeworld">ricompilare ed installare
            world</link> con la stessa versione dei sorgenti del tuo kernel.
            Questa &egrave; una ragione per non usare una versione del kernel
            diversa dal sistema operativo.</para>
	</listitem>
      </varlistentry>
    </variablelist>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->

