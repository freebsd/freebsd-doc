<!--
     The FreeBSD Italian Documentation Project

     $FreeBSD$
     Original revision: 1.228
-->

<chapter id="config-tuning">
  <chapterinfo>
    <authorgroup>
      <author>
        <firstname>Chern</firstname>

        <surname>Lee</surname>

        <contrib>Scritto da </contrib>
      </author>
    </authorgroup>

    <authorgroup>
      <author>
        <firstname>Mike</firstname>

        <surname>Smith</surname>

        <contrib>Basato su un tutorial scritto da </contrib>
      </author>
    </authorgroup>

    <authorgroup>
      <author>
        <firstname>Matt</firstname>

        <surname>Dillon</surname>

        <contrib>Basato anche su tuning(7) scritto da </contrib>
      </author>
    </authorgroup>
  </chapterinfo>

  <title>Configurazione e Messa a Punto</title>

  <sect1 id="config-synopsis">
    <title>Sinossi</title>

    <indexterm><primary>configurazione di sistema</primary></indexterm>
    <indexterm><primary>ottimizzazione di sistema</primary></indexterm>

    <para>Uno degli aspetti importanti di &os; &egrave; la configurazione del
      sistema.  Una corretta configurazione del sistema aiuter&agrave; a
      prevenire mal di testa durante futuri aggiornamenti.  Questo capitolo
      spiegher&agrave; molti dei processi di configurazione di &os;, inclusi
      alcuni parametri che possono essere impostati per ottimizzare un sistema
      &os;.</para>

    <para>Dopo aver letto questo capitolo, saprai:</para>

    <itemizedlist>
      <listitem>
        <para>Come lavorare in maniera efficiente con i file system e le
          partizioni di swap.</para>
      </listitem>

      <listitem>
        <para>Le basi dei sistemi di configurazione <filename>rc.conf</filename>
          e di avvio <filename>/usr/local/etc/rc.d</filename>.</para>
      </listitem>

      <listitem>
        <para>Come configurare e provare una scheda di rete.</para>
      </listitem>

      <listitem>
        <para>Come configurare host virtuali sui dispositivi di rete.</para>
      </listitem>

      <listitem>
        <para>Come usare i vari file di configurazione in
          <filename>/etc</filename>.</para>
      </listitem>

      <listitem>
        <para>Come mettere a punto &os; usando le variabili
          <command>sysctl</command>.</para>
      </listitem>

      <listitem>
        <para>Come ottimizzare la prestazioni del disco e modificare le
          limitazioni del kernel.</para>
      </listitem>
    </itemizedlist>

    <para>Prima di leggere questo capitolo, dovresti:</para>

    <itemizedlist>
      <listitem>
        <para>Comprendere le basi di &unix; e di &os; (<xref
            linkend="basics">).</para>
      </listitem>

      <listitem>
        <para>Avere dimestichezza nella configurazione/compilazione
          del kernel (<xref linkend="kernelconfig">).</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="configtuning-initial">
    <title>Configurazione Iniziale</title>

    <sect2>
      <title>Disposizione delle Partizioni</title>

      <indexterm><primary>disposizione delle partizioni</primary></indexterm>
      <indexterm><primary><filename>/etc</filename></primary></indexterm>
      <indexterm><primary><filename>/var</filename></primary></indexterm>
      <indexterm><primary><filename>/usr</filename></primary></indexterm>

      <sect3>
        <title>Partizioni di Base</title>

        <para>Nel disegnare il tuo file system con &man.bsdlabel.8; o
          &man.sysinstall.8;, ricorda che i dischi rigidi possono trasferire
          dati ad un ritmo maggiore dalle tracce esterne rispetto a quelle
          interne.  Quindi i file system pi&ugrave; piccoli e con un gran
          numero di accessi dovrebbero essere pi&ugrave; vicini alla parte
          esterna del disco, mentre le partizioni pi&ugrave; ampie, come
          <filename>/usr</filename>, dovrebbero essere posizionate verso
          l'interno.  &Egrave; una buona idea creare le partizioni in un ordine
          simile al seguente: root, swap, <filename>/var</filename>,
          <filename>/usr</filename>.</para>

        <para>Le dimensioni della partizione <filename>/var</filename>
          riflettono l'uso che intendi fare della macchina.
          <filename>/var</filename> viene usata per mantenere le
          caselle di posta, i file di log, e gli spool della stampante.  Le
          caselle di posta e file di log potrebbero crescere in
          maniera imprevedibile in relazione al numero di utenti presenti sul
          tuo sistema e da quanto a lungo manterrai i file di log.  La
          maggior parte degli utenti non avr&agrave; mai bisogno di un gigabyte,
          ma ricorda che <filename>/var/tmp</filename>
          deve essere abbastanza ampia da contenere tutti i pacchetti.</para>

        <para>La partizione <filename>/usr</filename> contiene molti
          dei file richiesti per far funzionare il sistema, la collezioni dei
          &man.ports.7; (raccomandata) e il codice sorgente (opzionale).
          Entrambi sono opzionali al momento dell'installazione.
          Almeno 2 gigabyte sono raccomandati per questa partizione.</para>

        <para>Quando decidi le dimensioni delle partizioni, tieni a mente le
          richieste di spazio.  Esaurire lo spazio in una partizione mentre ne
          usi poco in un'altra pu&ograve; essere molto fastidioso.</para>

        <note>
          <para>Alcuni utenti hanno scoperto che il dimensionamento
            <literal>auto-predefinito</literal> di &man.sysinstall.8; a volte
            crea partizioni <filename>/var</filename> o <filename>/</filename>
            pi&ugrave; piccole del necessario.  Partiziona saggiamente e
            generosamente.</para>
        </note>
      </sect3>

      <sect3 id="swap-design">
        <title>Partizione di Swap</title>

        <indexterm><primary>dimensionamento dello swap</primary></indexterm>
        <indexterm><primary>partizione di swap</primary></indexterm>

        <para>Come regola generale, la partizione di swap dovrebbe essere
          tipicamente il doppio della quantit&agrave; di memoria principale
          (RAM).  Ad esempio, se la macchina avesse 128&nbsp;megabyte di
          memoria, il file di swap dovrebbe essere di 256&nbsp;megabyte.
          Sistemi con meno memoria potrebbero funzionare meglio con uno swap
          maggiore.  Meno di 256&nbsp;megabyte di swap non &egrave; raccomandato
          e dovresti pensare ad una espansione della memoria.
          Gli algoritmi di paginazione sono ottimizzati per funzionare
          al meglio quando la partizione di swap &egrave; almeno due volte la
          dimensione della memoria principale.
          Configurare uno swap troppo piccolo potrebbe portare ad una
          inefficienza nel codice di scansione della VM e potrebbe creare
          problemi in seguito, nel caso di aggiunta di memoria alla
          macchina.</para>

        <para>Su sistemi pi&ugrave; grandi con dischi SCSI multipli
          (o dischi IDE multipli collegati a diversi controller) &egrave;
          consigliabile che ci sia uno swap per ogni disco (fino a
          quattro dischi).  Le partizioni di swap dovrebbero avere
          approssimativamente le stesse dimensioni.
          Il kernel pu&ograve; gestire dimensioni arbitrarie ma internamente le
          strutture dati scalano meglio fino a quattro volte la dimensione della
          partizione di swap pi&ugrave; ampia.  Avere partizioni di swap con
          dimensioni simili permetter&agrave; al kernel di distribuire al meglio
          lo spazio di swap tra i dischi.  Partizioni di swap grandi vanno bene,
          anche se non vengono usate molto.  Potrebbe essere pi&ugrave; semplice
          recuperare il sistema da un programma impazzito prima di essere
          costretti a riavviare.</para>
      </sect3>

      <sect3>
        <title>Perch&egrave; Partizionare?</title>

        <para>Molti utenti pensano che un'unica grande partizione vada bene, ma
          ci sono molte ragioni per cui questa &egrave; una cattiva idea.
          Primo, ogni partizione ha differenti caratteristiche
          operative e separarle permette ai file system di ottimizzare se stessi
          di conseguenza.  Ad esempio, le partizioni root e
          <filename>/usr</filename> sono per lo pi&ugrave; usate in lettura,
          senza molte operazioni di scrittura.  Un sacco di
          letture e scritture potrebbero esserci in <filename>/var</filename> e
          <filename>/var/tmp</filename>.</para>

        <para>Partizionando in maniera appropriata il sistema, la
          frammentazione introdotta nelle partizioni pi&ugrave; piccole,
          con pi&ugrave; carico in scrittura, non incider&agrave; sulle
          partizioni per lo pi&ugrave; di lettura.
          Mantenere le partizioni con maggiore carico in scrittura
          vicine al bordo del disco aumenter&agrave; le prestazioni di I/O
          nelle partizioni dove ne hai pi&ugrave; bisogno.  Ora, sebbene
          potresti avere bisogno di prestazioni di I/O anche nelle partizioni
          pi&ugrave; ampie, spostarle verso il bordo del disco non
          porterebbe nessun miglioramento significativo delle prestazioni, al
          contrario dello spostamento di <filename>/var</filename> all'esterno.
          Infine, ci sono problemi riguardanti la sicurezza.
          Una piccola, simpatica partizione di root che &egrave; essenzialmente
          di sola lettura ha ottime possibilit&agrave; di sopravvivere intatta a
          un brutto crash.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="configtuning-core-configuration">
    <title>Configurazione Principale</title>

    <indexterm>
      <primary>i file rc</primary>
      <secondary><filename>rc.conf</filename></secondary>
    </indexterm>

    <para>Il posto principale per le informazioni di configurazione del sistema
      &egrave; in <filename>/etc/rc.conf</filename>.  Questo file contiene
      un'ampia gamma di informazioni di configurazione, usate principalmente
      all'avvio della macchina per la configurazione del sistema.
      Il suo nome &egrave; autoesplicativo; si tratta di informazioni
      di configurazione per i file <filename>rc*</filename>.</para>

    <para>Un amministratore dovrebbe aggiungere dei campi nel file
      <filename>rc.conf</filename> per cambiare le impostazioni
      predefinite di <filename>/etc/defaults/rc.conf</filename>.
      Il file predefinito non dovrebbe essere semplicemente copiato in
      <filename>/etc</filename> - esso contiene valori di default, non esempi.
      Tutti i cambiamenti specifici del sistema dovrebbero essere effettuati
      nel file <filename>rc.conf</filename> stesso.</para>

    <para>Nelle applicazioni cluster possono essere adottate differenti
      strategie per separare le configurazioni generali da quelle specifiche del
      sistema in maniera da mantenere basso l'impegno di amministrazione.
      L'approccio raccomandato &egrave; di porre le configurazioni generali in
      un altro file, ad esempio <filename>/etc/rc.conf.site</filename>, e poi
      includerlo in <filename>/etc/rc.conf</filename>, che conterr&agrave; solo
      le informazioni specifiche del sistema.</para>

    <para>Visto che <filename>rc.conf</filename> viene letto da &man.sh.1;
      &egrave; semplice farlo.  Ad esempio:</para>

    <itemizedlist>
      <listitem>
        <para>rc.conf:</para>

        <programlisting>        . /etc/rc.conf.site
        hostname="node15.example.com"
        network_interfaces="fxp0 lo0"
        ifconfig_fxp0="inet 10.1.1.1"</programlisting>
      </listitem>

      <listitem>
        <para>rc.conf.site:</para>

        <programlisting>        defaultrouter="10.1.1.254"
        saver="daemon"
        blanktime="100"</programlisting>
      </listitem>
    </itemizedlist>

    <para>Il file <filename>rc.conf.site</filename> potr&agrave; poi essere
      distribuito su ogni sistema usando <command>rsync</command> o un programma
      simile, mentre il file <filename>rc.conf</filename> rimarr&agrave;
      unico.</para>

    <para>L'aggiornamento del sistema tramite &man.sysinstall.8;
      o <command>make world</command> non sovrascriver&agrave; il file
      <filename>rc.conf</filename>, quindi le configurazioni del sistema non
      andranno perse.</para>
  </sect1>

  <sect1 id="configtuning-appconfig">
    <title>Configurazione delle Applicazioni</title>

    <para>Tipicamente, le applicazioni installate hanno i propri file di
      configurazione, con la loro sintassi, ecc.  &Egrave; importante che questi
      file siano tenuti separati dal sistema di base, in maniera da essere
      facilmente individuati e gestiti dagli strumenti di gestione dei
      pacchetti.</para>

    <indexterm><primary>/usr/local/etc</primary></indexterm>

    <para>In genere, questi file vengono installati in
      <filename>/usr/local/etc</filename>.  Nel caso in cui un'applicazione
      abbia un grande numero di file di configurazione, verr&agrave; creata una
      sottodirectory per contenerli.</para>

    <para>Normalmente, quando viene installato un pacchetto, vengono installati
      anche file di configurazione d'esempio.  In genere questi vengono
      identificati da un suffisso <filename>.default</filename>.  Se non ci sono
      file di configurazione esistenti per l'applicazione, verranno creati
      copiando i file <filename>.default</filename>.</para>

    <para>Ad esempio, considera il contenuto della directory
      <filename>/usr/local/etc/apache</filename>:</para>

    <literallayout class="monospaced">-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf
-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf.default
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf.default
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic.default
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types.default
-rw-r--r--  1 root  wheel   7980 May 20  1998 srm.conf
-rw-r--r--  1 root  wheel   7933 May 20  1998 srm.conf.default</literallayout>

    <para>Le differenze nelle dimensioni dei file mostrano che solo
      <filename>srm.conf</filename> &egrave; stato modificato.
      Una successiva installazione di <application>Apache</application> dai port
      non sovrascriver&agrave; questo file modificato.</para>
  </sect1>

  <sect1 id="configtuning-starting-services">
    <sect1info>
      <authorgroup>
        <author>
        <firstname>Tom</firstname>

        <surname>Rhodes</surname>

        <contrib>Contributo di </contrib>
        </author>
      </authorgroup>
    </sect1info>

    <title>Avvio dei Servizi</title>

    <indexterm><primary>servizi</primary></indexterm>

    <para>Molti utenti scelgono di installare software di terze parti
      in &os; attraverso la collezione dei port.  Nell magior parte dei
      casi potrebbe essere necessario configurare il software
      in un modo tale che sia avviato all'inizializzazione
      di sistema.  Servizi, come
      <filename role="package">mail/postfix</filename>
      o <filename role="package">www/apache13</filename> sono solo due fra
      i molti pacchetti software che possono essere avviati durante
      l'inizializzazione di sistema.  Questa sezione spiega le procedure
      disponibili per avviare software di terze parti.</para>

    <para>In &os;, molti servizi inclusi, come &man.cron.8;, sono
      avviati attraverso gli script di startup.  Questi script possono
      differire a seconda della verione di &os; o del produttore; comunque
      il pi&ugrave; importante aspetto da considerare &egrave; che la
      configurazione di startup pu&ograve; essere gestita tramite semplici
      script di inizializzazione.</para>

    <para>Prima dell'avvento di <filename>rc.d</filename>, gli
      applicativi lasciavano un semplice
      script di avvio nella directory <filename
        class="directory">/usr/local/etc/rc.d</filename> che sarebbe stato poi
      letto dagli script di inizializzazione di sistema.  Questi script
      sarebbero poi eseguiti durante la fase di avvio del
      sistema.</para>

    <para>Mentre molti individui hanno speso ore cercando di integrare
      il vecchio stile di configurazione nel nuovo sistema, resta il fatto
      che qualche utility di terze parti necessita ancora di uno script
      semplicemente lasciato nella succitata directory.  Le sottili differenze
      negli script dipendono dal fatto se <filename>rc.d</filename> sia
      usato o meno.  Prima
      di &os;&nbsp;5.1 viene usato il vecchio metodo di configurazione
      ed in quasi tutti i casi uno script di nuovo tipo funzionerebbe
      perfettamente.</para>

    <para>Mentre ogni script deve rispettare alcuni requisiti minimi,
      il pi&ugrave; delle volte questi requisiti sono indipendenti
      dalla versioni di &os;.  Ogni script deve avere una estensione
      <filename>.sh</filename> appesa alla fine ed ogni script deve essere
      eseguibile dal sistema.  L'ultima richiesta pu&ograve; essere soddisfatta
      usando il comando <command>chmod</command> e impostando i permessi
      a <literal>755</literal>.  Ci dovrebbe essere, come minimo,
      un'opzione per fare lo <literal>start</literal> dell'applicativo
      ed un'opzione per farne lo <literal>stop</literal>.</para>

    <para>Il pi&ugrave; semplice script di avvio probabilmente sembrerebbe
      simile al seguente:</para>

    <programlisting>#!/bin/sh
echo -n ' utility'

case "$1" in
start)
        /usr/local/bin/utility
        ;;
stop)
        kill -9 `cat /var/run/utility.pid`
        ;;
*)
        echo "Usage: `basename $0` {start|stop}" &gt;&2
        exit 64
        ;;
esac

exit 0</programlisting>

    <para>Questo script fornisce un'opzione <literal>stop</literal>
      e <literal>start</literal> per l'applicazione a cui ci riferiamo
      semplicemente come <literal>utility</literal>.</para>

    <para>Potrebbe essere avviata manualmente con:</para>

    <screen>&prompt.root; <userinput><filename>/usr/local/etc/rc.d/utility.sh</filename> start</userinput></screen>

    <para>Mentre non tutto il software di terze parti richiede la linea
      in <filename>rc.conf</filename>, quasi ogni giorno un nuovo port
      viene modificato per accettare questa configurazione.  Controlla
      l'output finale dell'installazione per maggiori informazioni su un
      applicativo specifico.  Ci sar&agrave; del software di terze parti
      che fornisce script di avvio che permettono all'applicativo di
      essere usato con <filename>rc.d</filename>; tuttavia, questo
      sar&agrave; discusso nella successiva sezione.</para>

    <sect2>
      <title>Configurazione Estesa degli Applicativi</title>

      <para>Ora che &os; include <filename>rc.d</filename>, la
        configurazione dell'avvio degli applicativi &egrave;
        diventata pi&ugrave; semplice, e pi&ugrave; flessibile.
        Usando le parole chiave discusse nella sezione <link
          linkend="configtuning-rcd">rc.d</link>, gli applicativi ora possono
        essere configurati dopo certi altri servizi come ad esempio il
        <acronym>DNS</acronym>; possono permettere che siano passati flag extra
        nel codice attraverso <filename>rc.conf</filename> al posto
        di flag statici negli script di avvio, e molto altro.
        Uno script basilare potrebbe assomigliare al seguente:</para>

      <programlisting>#!/bin/sh
#
# PROVIDE: utility
# REQUIRE: DAEMON
# KEYWORD: shutdown

. /etc/rc.subr

name=utility
rcvar=utility_enable

command="/usr/local/sbin/utility"

load_rc_config $name

#
# DO NOT CHANGE THESE DEFAULT VALUES HERE
# SET THEM IN THE /etc/rc.conf FILE
#
utility_enable=${utility_enable-"NO"}
pidfile=${utility_pidfile-"/var/run/utility.pid"}

run_rc_command "$1"</programlisting>

    <para>Questo script assicurer&agrave; che
      <application>utility</application> partir&agrave; dopo
      il servizio <literal>daemon</literal>.
      Fornisce inoltre un metodo per settare e tracciare il
      <acronym>PID</acronym>, o il file dell'<acronym>ID</acronym> di
      processo.</para>

    <para>Questa applicazione potrebbe avere le seguenti linee piazzate
      in <filename>/etc/rc.conf</filename>:</para>

    <programlisting>utility_enable="YES"</programlisting>

    <para>Questo metodo permette inoltre una semplice
      manipolazione degli argomenti di linea di comando, incluse
      le funzioni di default definite in <filename>/etc/rc.subr</filename>,
      compatibilit&agrave; con l'utility &man.rcorder.8; e fornisce una
      pi&ugrave; semplice configurazione attraverso il file
      <filename>rc.conf</filename>.</para>

    <sect2>
      <title>Usare i Servizi per Avviare i Servizi</title>

      <para>Altri servizi, come i demoni <acronym>POP</acronym>3,
        <acronym>IMAP</acronym>, etc. potrebbero essere avviati
        usando &man.inetd.8;.  Questo implica l'installazione del servizio
        dalla collezione dei port e l'aggiunta di una linea di
        configurazione al file <filename>/etc/inetd.conf</filename>
        o togliendo dei commenti in una delle linee di configurazione
        del file stesso.
        L'uso di <application>inetd</application> e la
        sua configurazione &egrave;
        descritto in dettaglio nella sezione
        <link linkend="network-inetd">inetd</link>.</para>

      <para>In alcuni casi, potrebbe essere pi&ugrave; plausibile usare
        il demone &man.cron.8; per avviare i servizi di sistema.  Questo
        approccio ha alcuni vantaggi poich&egrave; <command>cron</command>
        esegue questi processi come l'utente proprietario del file
        <filename>crontab</filename>.  Questo permette ad utenti regolari
        di avviare e mantenere alcuni applicativi.</para>

      <para>Il comando <command>cron</command> fornisce una caratteristica unica,
        <literal>@reboot</literal>, che potrebbe essere usato al posto della
        specifica del tempo.  Questo far&agrave; s&igrave; che il job sia
        eseguito quando &man.cron.8; &egrave; avviato, normalmente durante
        l'inizializzazione di sistema.</para>
    </sect2>
  </sect1>

  <sect1 id="configtuning-cron">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Tom</firstname>

          <surname>Rhodes</surname>

          <contrib>Contributo di </contrib>
       </author>
      </authorgroup>
    </sect1info>

    <title>Configurare l'Utility <command>cron</command> </title>

    <indexterm>
      <primary>cron</primary>
      <secondary>configurazione</secondary>
    </indexterm>

    <para>Uno dei comandi pi&ugrave; utili presenti in &os; &egrave;
      &man.cron.8;.
      L'utility <command>cron</command> viene eseguita in background
      e controlla costantemente
      il file <filename>/etc/crontab</filename>.  <command>cron</command>
      controlla anche la directory <filename>/var/cron/tabs</filename>,
      alla ricerca di nuovi file <filename>crontab</filename>.  Questi file
      <filename>crontab</filename> contengono informazioni sulle
      specifiche funzioni che ci si aspetta vengano
      compiute da <command>cron</command> a determinati intervalli
      temporali.</para>

    <para>L'utility <command>cron</command> usa due differenti
      tipi di file di configurazione, il crontab di sistema ed il crontab
      utente.  La sola differenza fra questi due file &egrave; nel sesto campo.
      Nel crontab di sistema, il sesto campo &egrave; il nome dell'utente
      sotto il quale viene eseguito il comando.  Questo d&agrave; al crontab
      di sistema la capacit&agrave; di eseguire comandi come ogni utente.
      Nel crontab utente, il sesto campo &egrave; il comando da eseguire,
      e tutti i comandi vengono eseguiti come l'utente che ha creato il crontab;
      questa &egrave; un'importante caratteristica di sicurezza.</para>

    <note>
      <para>I crontab utenti permettono ad utenti individuali di schedulare
        task senza i privilegi di <username>root</username>.  I comandi
        in un crontab utente vengono eseguiti con i permessi dell'utente
        che posseggono il file crontab.</para>

      <para>L'utente <username>root</username> pu&ograve; possedere
        il crontab proprio come ogni altro utente.  Qui c'&egrave; una
        differenza rispetto a <filename>/etc/crontab</filename> (il crontab
        di sistema).  Per via del crontab di sistema, di solito non c'&egrave;
        bisogno di creare un crontab per <username>root</username>.</para>
    </note>

    <para>Diamo un'occhiata al file <filename>/etc/crontab</filename>
     (il crontab di sistema):</para>

    <programlisting># /etc/crontab - il crontab di root per &os;
#
# &dollar;&os;: src/etc/crontab,v 1.32 2002/11/22 16:13:39 tom Exp &dollar;
# <co id="co-comments">
#
SHELL=/bin/sh
PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin <co id="co-env">
HOME=/var/log
#
#
#minute    hour    mday    month   wday    who command <co id="co-field-descr">
#
#
*/5    *   *   *   *   root    /usr/libexec/atrun <co id="co-main">
</programlisting>

    <calloutlist>
      <callout arearefs="co-comments">
        <para>Come in molti file di configurazione di
          &os;, il carattere <literal>#</literal>
          rappresenta un commento.  Un commento pu&ograve; essere posto nel
          file come una nota su cosa si desidera fare con un certo comando.
          I commenti non possono essere nella stessa linea di un comando
          o saranno interpretati come parte di un comando; devono trovarsi su
          una linea a s&egrave;.  Le linee vuote vengono ignorate.</para>
      </callout>

      <callout arearefs="co-env">
        <para>Anzitutto, deve essere definito l'ambiente. I segni di uguale
          (<literal>=</literal>) vengono usati per definire ogni impostazione
          dell'ambiente, come viene fatto in questo esempio per
          <envar>SHELL</envar>, <envar>PATH</envar>, e <envar>HOME</envar>.
          Se la linea relativa alla shell viene omessa, <command>cron</command>
          user&agrave; quella di default, che &egrave;
          <command>sh</command>.  Se si omette la variabile
          <option>PATH</option>, non verr&agrave; usato nessun default e le
          locazioni dei file dovranno essere assolute.  Se viene omessa
          <option>HOME</option>, <command>cron</command>
          user&agrave; la home directory dello user che lo ha richiamato.</para>
      </callout>

      <callout arearefs="co-field-descr">
        <para>Questa linea definisce un totale di sette campi.  Qui sono
          elencati i valori <literal>minute</literal>, <literal>hour</literal>,
          <literal>mday</literal>, <literal>month</literal>,
          <literal>wday</literal>, <literal>who</literal>, e
          <literal>command</literal>.  Questi nomi sono pi&ugrave; o meno
          autoesplicativi.  <literal>minute</literal> &egrave; il tempo in
          minuti al quale dovr&agrave; essere eseguito il comando.
          <literal>hour</literal> &egrave; uguale, ma per le ore.
          <literal>mday</literal> rappresenta il giorno del mese.
          <literal>month</literal> &egrave; simile ad <literal>hour</literal>
          e <literal>minute</literal>, ma rappresenta il mese.
          L'opzione <literal>wday</literal> rappresenta il
          giorno della settimana.  Tutti questi campi devono avere un valore
          numerico, e seguire l'orario di ventiquattro ore.  Il campo
          <literal>who</literal> &egrave; speciale, ed esiste solo nel file
          <filename>/etc/crontab</filename>.
          Questo campo specifica l'utente con il quale deve essere eseguito
          il comando.  Quando un utente installa il suo file
          <filename>crontab</filename>, non avr&agrave; a disposizione questa
          opzione. Infine, viene elencata l'opzione <literal>command</literal>.
          Questo &egrave; l'ultimo campo, e naturalmente indica il comando che
          deve essere eseguito.</para>
      </callout>

      <callout arearefs="co-main">
        <para>Quest'ultima linea definir&agrave; i valori discussi prima.
          Notate che abbiamo un <literal>*/5</literal>, seguito da parecchi
          caratteri <literal>*</literal>.  Questi caratteri <literal>*</literal>
          significano <quote>dalla prima all'ultima volta</quote>,
          e possono essere interpretati come
          <emphasis>ogni</emphasis> volta.  Dunque, basandosi su questa linea,
          sembra che il comando <command>atrun</command> debba essere invocato
          da <username>root</username> ogni cinque minuti, prescindendo da quale
          giorno o mese sia.  Per maggiori informazioni sul comando
          <command>atrun</command>,
          vedere la pagina di manuale &man.atrun.8;.</para>

        <para>I comandi possono essere richiamati con qualsiasi numero di
          flag; i comandi che si estendono per pi&ugrave; righe potrebbero
          per&ograve; avere bisogno di essere spezzati
          con il carattere di continuazione
          <quote>\</quote>.</para>
      </callout>
    </calloutlist>

    <para>Questa &egrave; l'impostazione di base per ogni file
      <filename>crontab</filename>, anche se c'&egrave; qualcosa di
      particolare in questo.
      Il sesto campo, dove abbiamo specificato il nome utente,
      esiste solo nel file di sistema <filename>/etc/crontab</filename>.
      Questo campo dovrebbe venire omesso nei <filename>crontab</filename>
      dei vari utenti.</para>

    <sect2 id="configtuning-installcrontab">
      <title>Installare un Crontab</title>

      <important>
        <para>Non devi usare la procedura descritta qui
          per editare/installare il crontab di sistema.  Semplicemente
          usa il tuo editor favorito: l'utility <command>cron</command>
          noter&agrave; che il file &egrave; cambiato e immediatamente
          inizier&agrave; ad usare la versione aggiornata.  Vedi
          <ulink
            url="&url.books.faq;/admin.html#ROOT-NOT-FOUND-CRON-ERRORS">queste
            FAQ</ulink> per maggiori informazioni.</para>
      </important>

      <para>Per installare un <filename>crontab</filename>
        appena scritto, prima usa il tuo editor preferito
        per creare un file nel formato corretto, e poi
        usa l'utility <command>crontab</command>.  L'uso
        pi&ugrave; corretto &egrave;:</para>

      <screen>&prompt.user; <userinput>crontab crontab-file</userinput></screen>

      <para>In questo esempio, <filename>crontab-file</filename>
        &egrave; il nome di un file <filename>crontab</filename> che era stato
        creato in precedenza.</para>

      <para>C'&egrave; anche un'opzione per elencare i file
        <filename>crontab</filename> gi&agrave; installati: passate
        semplicemente <option>-l</option> a <command>crontab</command> e date
        un'occhiata all'output.</para>

      <para>Per gli utenti che desiderino scrivere il proprio file crontab
        da zero, senza usare un template, &egrave; disponibile
        <command>crontab -e</command>.
        Questa opzione permetter&agrave; loro di invocare l'editor
        prescelto su un file vuoto.  Quando il file verr&agrave; salvato,
        esso verr&agrave; automaticamente installato
        dal comando <command>crontab</command>.</para>

      <para>Se successivamente vuoi rimuovere il tuo
        <filename>crontab</filename>
        completamente, usa <command>crontab</command>
        con l'opzione <option>-r</option>.</para>
    </sect2>
  </sect1>

  <sect1 id="configtuning-rcd">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Tom</firstname>

          <surname>Rhodes</surname>

          <contrib>Contributo di </contrib>
        </author>
      </authorgroup>
    </sect1info>

    <title>Usare rc con &os;</title>

    <para>Nel 2002 &os; ha integrato il sistema di inizializzazione
      <filename>rc.d</filename> di NetBSD.
      Gli utenti dovrebbero aver notato i file elencati nella cartella
      <filename>/etc/rc.d</filename>.  Molti di questi file
      sono  servizi di base che possono essere controllati
      con opzioni <option>start</option>, <option>stop</option>,
      e <option>restart</option>.
      Ad esempio, &man.sshd.8; pu&ograve; essere riavviato
      con il comando seguente:</para>

    <screen>&prompt.root; <userinput>/etc/rc.d/sshd restart</userinput></screen>

    <para>Questa procedura &egrave; simile a quella per altri
      servizi.  Naturalmente, i servizi in genere vengono avviati
      automaticamente in fase di avvio secondo quanto specificato in
      &man.rc.conf.5;.  Ad esempio, per abilitare il demone per il
      NAT (Network Address Translation) all'avvio basta aggiungere la linea
      seguente a <filename>/etc/rc.conf</filename>:</para>

    <programlisting>natd_enable="YES"</programlisting>

    <para>Se esiste gi&agrave; una linea  <option>natd_enable="NO"</option>,
      allora basta cambiare il valore da <option>NO</option> a
      <option>YES</option>.  Gli script rc caricheranno automaticamente
      ogni altro servizio durante il riavvio seguente, come
      descritto pi&ugrave; avanti.</para>

    <para>Poich&egrave; il sistema di <filename>rc.d</filename>
      &egrave; inteso prevalentemente per avviare/bloccare i servizi al
      momento dell'accensione/spegnimento, le opzioni standard
      <option>start</option>, <option>stop</option> e <option>restart</option>
      avranno il comportamento appropriato solo se&egrave; stata impostata
      la variabile appropriata in <filename>/etc/rc.conf</filename>.
      Ad esempio il comando precedente <command>sshd restart</command>
      funzioner&agrave; solo se in <filename>/etc/rc.conf</filename>
      &egrave; stata impostata l'opzione  <varname>sshd_enable</varname>
      a <option>YES</option>.  Per avviare
      (<option>start</option>), fermare (<option>stop</option>) o
      riavviare (<option>restart</option>) un servizio, ignorandole impostazioni
      in  <filename>/etc/rc.conf</filename>, i comandi devono avere il prefisso
      <quote>one</quote>.  Ad esempio per riavviare
      <command>sshd</command> trascurando le impostazioni esistenti in
      <filename>/etc/rc.conf</filename>, impartite il comando seguente:</para>

    <screen>&prompt.root; <userinput>/etc/rc.d/sshd onerestart</userinput></screen>

    <para>&Egrave; semplice controllare se un servizio &egrave; stato abilitato
      in <filename>/etc/rc.conf</filename> eseguendo lo script appropriato in
      <filename>rc.d</filename> con l'opzione
      <option>rcvar</option>.  Dunque, un amministratore pu&ograve;
      controllare che
      <command>sshd</command> sia effettivamente abilitato in
      <filename>/etc/rc.conf</filename> eseguendo:</para>

    <screen>&prompt.root; <userinput>/etc/rc.d/sshd rcvar</userinput>
# sshd
$sshd_enable=YES</screen>

    <note>
      <para>La seconda linea (<literal># sshd</literal>) &egrave; l'output
         del comando
         <command>sshd</command>; non una console di
         <username>root</username>.</para>
    </note>

    <para>Per determinare se un servizio &egrave; attivo,
      &egrave; disponibile l'opzione
      <option>status</option>.  Ad esempio per
      verificare che <command>sshd</command> sia effettivamente avviato:</para>

    <screen>&prompt.root; <userinput>/etc/rc.d/sshd status</userinput>
sshd is running as pid 433.</screen>

    <para>In alcuni case &egrave; anche possibile effettuare il
      <option>reload</option> di un servizio.
      Questo tenter&agrave; di inviare un segnale al servizio,
      per fargli ricaricare il suo file di configurazione.  Nella maggior
      parte dei casi si tratter&agrave; del segnale
      <literal>SIGHUP</literal>.
      Il supporto per questa caratteristica non &egrave; garantito per
      tutti i servizi.</para>

    <para>La struttura di <filename>rc.d</filename> non viene
      usata solo per i servizi di rete, ma contribuisce anche per
      buona parte all'inizializzazione del sistema.
      Ad esempio, considerate il file
      <filename>bgfsck</filename>.  Quando lo script viene
      eseguito, esso stamper&agrave; il seguente messaggio:</para>

    <screen>Starting background file system checks in 60 seconds.</screen>

    <para>Dunque questo file viene usato per il controllo del
      file system in background,
      che avviene solo durante l'inizializzazione del sistema.</para>

    <para>Molti servizi di sistema dipendono da altri servizi per
      poter funzionare in maniera appropriata.  Ad esempio, il NIS ed altri
      servizi basati sulle RPC potrebbero non funzionare in assenza
      di <command>rpcbind</command> (portmapper).  Per risolvere il problema,
      nei commenti all'inizio di ogni script di avvio ci sono
      informazioni sulle dipendenze ed altri metadati.  Il programma
      &man.rcorder.8; viene poi utilizzato per effettuare il
      parsing di questi commenti durante l'inizializzazione di sistema e per
      determinare l'ordine con il quale questi servizi devono essere avviati
      per avere le proprie dipendenze soddisfatte.
      In cima ad ogni file di avvio possono essere incluse le seguenti
      parole:</para>

    <itemizedlist>
      <listitem>
        <para>PROVIDE: Specifica i servizi forniti dal file.</para>
      </listitem>

      <listitem>
        <para>REQUIRE: Elenca i servizi richiesti per far
          funzionare correttamente questo servizio.  Questo file verr&agrave;
          eseguito <emphasis>dopo</emphasis>
          i tali servizi.</para>
      </listitem>

      <listitem>
        <para>BEFORE: Elenca i servizi che dipendono da questo.
          Questo file verr&agrave; lanciato  <emphasis>prima</emphasis>
          dei servizi specificati.</para>
      </listitem>
    </itemizedlist>

    <para>Usando questo metodo, un amministratore pu&ograve; controllare
      facilmente i servizi di sistema senza il fastidio dei
      <quote>runlevel</quote> come
      alcuni altri sistemi operativi &unix;.</para>

    <para>Informazioni addizionali sul sistema
      <filename>rc.d</filename> possono essere trovate
      nelle pagine man di
      &man.rc.8;  e &man.rc.subr.8;.  Se sei interessato
      a scrivere un tuo script <filename>rc.d</filename> o
      a migliorarne uno esisente, ti pu&ograve; essere utile
      <ulink url="&url.articles.rc-scripting">questo
      articolo</ulink>.</para>
  </sect1>

  <sect1 id="config-network-setup">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Marc</firstname>

          <surname>Fonvieille</surname>

          <contrib>Contributo di </contrib>
        </author>
      </authorgroup>
    </sect1info>

    <title>Configurazione delle Interfacce di Rete</title>

    <indexterm>
      <primary>scheda di rete</primary>
      <secondary>configurazione</secondary>
    </indexterm>

    <para>Al giorno d'oggi non riusciamo a pensare ad un computer senza pensare
      ad una connessione di rete.  Aggiungere e configurare una scheda di rete
      &egrave; un compito comune per ogni amministratore di &os;.</para>

    <sect2>
      <title>Individuazione del Driver Corretto</title>

      <indexterm>
        <primary>schede di rete</primary>
        <secondary>driver</secondary>
      </indexterm>

      <para>Prima di cominciare, dovresti conoscere il modello della scheda di
        rete che possiedi, il chip che usa, e se si tratta di una scheda PCI o
        ISA.  &os; supporta un'ampia variet&agrave; sia di schede PCI che
        ISA.  Verifica l'Hardware Compatibility List della tua release per
        vedere se la scheda &egrave; supportata.</para>

      <para>Una volta sicuro che la tua scheda sia supportata, hai bisogno di
        determinare il driver appropriato per la scheda.  I file
        <filename>/usr/src/conf/NOTES</filename> e
        <filename>/usr/src/sys/<replaceable>arch</replaceable>/conf/NOTES</filename>
        ti forniranno un elenco di driver per le interfacce di rete con alcune
        informazioni su chipset/schede supportate.  Se hai dubbi su quale sia
        il driver corretto, leggi la pagina man del driver.
        La pagina man fornir&agrave; ulteriori informazioni sull'hardware
        supportato ed anche sui possibili problemi che potrebbero
        capitare.</para>

      <para>Se sei in possesso di una scheda comune, la maggior parte delle
        volte non dovrai cercare molto per trovare un driver.  I driver per le
        schede di reti comuni sono presenti nel kernel
        <filename>GENERIC</filename>, quindi la tua scheda dovrebbe presentarsi
        durante l'avvio, in questo modo:</para>

      <screen>dc0: &lt;82c169 PNIC 10/100BaseTX&gt; port 0xa000-0xa0ff mem 0xd3800000-0xd38
000ff irq 15 at device 11.0 on pci0
dc0: Ethernet address: 00:a0:cc:da:da:da
miibus0: &lt;MII bus&gt; on dc0
ukphy0: &lt;Generic IEEE 802.3u media interface&gt; on miibus0
ukphy0:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
dc1: &lt;82c169 PNIC 10/100BaseTX&gt; port 0x9800-0x98ff mem 0xd3000000-0xd30
000ff irq 11 at device 12.0 on pci0
dc1: Ethernet address: 00:a0:cc:da:da:db
miibus1: &lt;MII bus&gt; on dc1
ukphy1: &lt;Generic IEEE 802.3u media interface&gt; on miibus1
ukphy1:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto</screen>

      <para>In questo esempio, vediamo che nel sistema sono presenti due schede
        che usano il driver &man.dc.4;.</para>

      <para>Se il driver per la tua NIC non &egrave; presente in
        <filename>GENERIC</filename>, dovrai caricare i driver appropriati
        per usare la tua NIC.  Questo dovr&agrave; essere fatto in
        uno di questi due modi:</para>

      <itemizedlist>
        <listitem>
          <para>Il modo pi&ugrave; semplice &egrave; caricare un modulo
            del kernel con &man.kldload.8; o caricarlo automaticamente
            al momento del boot aggiungendo le linee appropriate
            a <filename>/boot/loader.conf</filename>.  Non tutti i driver NIC
            sono disponibili come moduli; esempi notevoli di driver
            per i quali non esistono moduli sono schede ISA.</para>
        </listitem>

        <listitem>
          <para>Alternativamente, puoi compilare staticamente il supporto
            per la tua scheda nel kernel.  Controlla
            <filename>/usr/src/sys/conf/NOTES</filename>,
            <filename>/usr/src/sys/<replaceable>arch</replaceable>/conf/NOTES</filename>
            e la pagina di manuale del driver per sapere cosa aggiungere
            nel tuo file di configurazione del kernel.  Per maggiori
            informazioni sul modo di ricompilare il kernel, per favore consulta il
            <xref linkend="kernelconfig">.  Se la tua scheda era riconosciuta
            al boot dal tuo kernel (<filename>GENERIC</filename>) non devi
            ricompilare un nuovo kernel.</para>
        </listitem>
      </itemizedlist>

      <sect3 id="config-network-ndis">
  <title>Usare driver NDIS &windows;</title>

  <indexterm><primary>NDIS</primary></indexterm>
  <indexterm><primary>NDISulator</primary></indexterm>
  <indexterm><primary>&windows; drivers</primary></indexterm>
  <indexterm><primary>Microsoft Windows</primary></indexterm>
  <indexterm><primary>Microsoft Windows</primary>
      <secondary>device drivers</secondary></indexterm>
  <indexterm><primary>KLD (oggetti del kernel caricabili)</primary></indexterm>
<!-- We should probably omit the expanded name, and add a <see> entry
for it.  Whatever is done must also be done to the same indexterm in
linuxemu/chapter.sgml -->

  <para>Sfortunatamente, ci sono ancora molti venditori
          di hardware che non forniscono specifiche dei loro
          driver alla comunit&agrave; open source perch&egrave;
          ritengono che tale informazione sia un segreto commerciale.
          Conseguentemente, gli sviluppatori di &os; e di altri sistemi
          operativi hanno due scelte: sviluppare i driver con un lungo
          ed arduo processo di reverse engineering o usare i driver binari
          disponibili per le piattaforme &microsoft.windows;.  La maggior
          parte degli sviluppatori, inclusi quelli coinvolti in &os;, ha preso
          la seconda strada.</para>

  <para>Grazie al contributo di Bill Paul (wpaul), a partire
          da &os;&nbsp;5.3-RELEASE c'&egrave; supporto <quote>nativo</quote>
          per Network Driver Interface Specification (NDIS).
          Il NDISulator di &os; (anche noto come Progetto Evil)
          prende un driver binario per &windows; e sostanzialmente
          crea un inganno fingendo di eseguirlo in &windows;.  Poich&egrave;
          il driver &man.ndis.4; sta usando un binario &windows;, &egrave;
          usabile solo su sistemi &i386; e amd64.</para>

  <note>
    <para>Il driver &man.ndis.4; &egrave; designato per supportare
            principalmente device PCI, CardBus e PCMCIA, i device USB non
            sono ancora supportati.</para>
  </note>

  <para>Per usare il NDISulator, hai bisogno sostanzialmente
          di tre cose:</para>

  <orderedlist>
   <listitem>
    <para>Sorgenti del kernel</para>
   </listitem>
   <listitem>
    <para>binari dei driver di &windowsxp;
      (estensione <filename>.SYS</filename>)</para>
   </listitem>
   <listitem>
    <para>file di configurazione dei driver per &windowsxp;
      (estensione <filename>.INF</filename>)</para>
   </listitem>
  </orderedlist>

  <para>Localizza i file per la tua carta specifica.
          Generalmente, posso essere trovati nel CD incluso o sui siti web
          dei venditori.  Nei seguenti esempi, useremo
    <filename>W32DRIVER.SYS</filename> e
    <filename>W32DRIVER.INF</filename>.</para>

  <note>
    <para>Non puoi usare un driver &windows;/i386
            con &os;/amd64, devi trovare un driver &windows;/amd64
            per farlo funzionare correttamente.</para>
  </note>

  <para>Il prossimo passo &egrave; compilare il binario
          del driver in un modulo caricabile dal kernel.
          Per fare questo, come <username>root</username>, usa
          &man.ndisgen.8;:</para>

  <screen>&prompt.root; <userinput>ndisgen <replaceable>/path/to/W32DRIVER.INF</replaceable> <replaceable>/path/to/W32DRIVER.SYS</replaceable></userinput></screen>

  <para>L'utility &man.ndisgen.8; &egrave; interattiva e chieder&agrave;
          altre informazioni di cui necessita; produrr&agrave; un modulo
          del kernel nella presente directory che pu&ograve; essere caricato
          in questo modo:</para>

  <screen>&prompt.root; <userinput>kldload <replaceable>./W32DRIVER.ko</replaceable></userinput></screen>

  <para>In aggiunta al modulo del kernel generato,
          devi caricare i moduli <filename>ndis.ko</filename> e
          <filename>if_ndis.ko</filename>.
          Questo dovrebbe avvenire automaticamente quando uno carica
          un modulo che dipende da &man.ndis.4;.  Se vuoi caricarli
          manualmente, usa il seguente comando:</para>

  <screen>&prompt.root; <userinput>kldload ndis</userinput>
&prompt.root; <userinput>kldload if_ndis</userinput></screen>

  <para>Il primo comando carica il wrapper del driver
          miniport NDIS, il secondo carica l'interfaccia di rete
          in questione.</para>

  <para>Ora controlla &man.dmesg.8; per vedere se c'era qualche errore
          durante il caricamento.  Se tutto &egrave; andato bene,
          dovresti ottenere dell'output che somiglia a questo:</para>

  <screen>ndis0: &lt;Wireless-G PCI Adapter&gt; mem 0xf4100000-0xf4101fff irq 3 at device 8.0 on pci1
ndis0: NDIS API version: 5.0
ndis0: Ethernet address: 0a:b1:2c:d3:4e:f5
ndis0: 11b rates: 1Mbps 2Mbps 5.5Mbps 11Mbps
ndis0: 11g rates: 6Mbps 9Mbps 12Mbps 18Mbps 36Mbps 48Mbps 54Mbps</screen>

  <para>D'ora in poi, puoi trattare il device
          <devicename>ndis0</devicename> come ogni altra
          scheda di rete (ad esempio <devicename>dc0</devicename>).</para>

  <para>Puoi configurare il sistema perch&eacute; carichi
          il modulo NDIS al momento del boot nello stesso modo
          di ogni altro modulo.  Per prima cosa, copia il modulo generato
          <filename>W32DRIVER.ko</filename>, nella directory
          <filename class="directory">/boot/modules</filename>.
          Quindi, aggiungi le seguenti linee a <filename>/boot/loader.conf</filename>:</para>

  <programlisting>W32DRIVER_load="YES"</programlisting>
      </sect3>
    </sect2>

    <sect2>
      <title>Configurazione della Scheda di Rete</title>

      <indexterm>
        <primary>schede di rete</primary>
        <secondary>configurazione</secondary>
      </indexterm>

      <para>Una volta che il driver giusto per la scheda di rete &egrave; stato
        caricato, la scheda ha bisogno di essere configurata.  Come molte altre
        cose, la scheda di rete potrebbe essere gi&agrave; stata configurata al
        momento dell'installazione tramite
        <application>sysinstall</application>.</para>

      <para>Per mostrare la configurazione delle interfacce di rete sul tuo
        sistema, immetti il seguente comando:</para>

<screen>&prompt.user; <userinput>ifconfig</userinput>
dc0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet 192.168.1.3 netmask 0xffffff00 broadcast 192.168.1.255
        ether 00:a0:cc:da:da:da
        media: Ethernet autoselect (100baseTX &lt;full-duplex&gt;)
        status: active
dc1: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet 10.0.0.1 netmask 0xffffff00 broadcast 10.0.0.255
        ether 00:a0:cc:da:da:db
        media: Ethernet 10baseT/UTP
        status: no carrier
lp0: flags=8810&lt;POINTOPOINT,SIMPLEX,MULTICAST&gt; mtu 1500
lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 16384
        inet 127.0.0.1 netmask 0xff000000
tun0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1500</screen>

      <note>
        <para>Vecchie versioni di &os; potrebbero richiedere l'opzione
          <option>-a</option> dopo &man.ifconfig.8;, per maggiori
          dettagli sulla sintassi corretta di &man.ifconfig.8;, fai riferimento
          alla pagina man.  Nota anche che le voci relative all'IPv6
          (<literal>inet6</literal> ecc.) sono state omesse in questo
          esempio.</para>
      </note>

      <para>In questo esempio, vengono mostrati i seguenti dispositivi:</para>

      <itemizedlist>
        <listitem>
          <para><devicename>dc0</devicename>: La prima interfaccia
            Ethernet</para>
        </listitem>

        <listitem>
          <para><devicename>dc1</devicename>: La seconda interfaccia
            Ethernet</para>
        </listitem>

        <listitem>
          <para><devicename>lp0</devicename>: L'interfaccia della porta
            parallela</para>
        </listitem>

        <listitem>
          <para><devicename>lo0</devicename>: Il dispositivo di loopback</para>
        </listitem>

        <listitem>
          <para><devicename>tun0</devicename>: Il dispositivo tunnel usato da
            <application>ppp</application></para>
        </listitem>
      </itemizedlist>

      <para>&os; usa il nome del driver seguito dall'ordine nel quale
        la scheda &egrave; stata rilevata all'avvio del kernel per dare un nome
        alla scheda di rete.  Ad esempio <devicename>sis2</devicename> sarebbe
        la terza scheda di rete nel sistema che usa il driver
        &man.sis.4;.</para>

      <para>In questo esempio, il dispositivo <devicename>dc0</devicename>
        &egrave; attivo.  Gli indicatori chiave sono:</para>

      <orderedlist>
        <listitem>
          <para><literal>UP</literal> significa che la scheda &egrave; pronta e
            configurata.</para>
        </listitem>

        <listitem>
          <para>La scheda ha un indirizzo Internet (<literal>inet</literal>)
            (in questo caso <hostid role="ipaddr">192.168.1.3</hostid>).</para>
        </listitem>

        <listitem>
          <para>Ha una maschera di sotto-rete valida
            (<literal>netmask</literal>; <hostid
              role="netmask">0xffffff00</hostid> &egrave; lo stesso di
              <hostid role="netmask">255.255.255.0</hostid>).</para>
        </listitem>

        <listitem>
          <para>Ha un indirizzo di broadcast valido (in questo caso,
            <hostid role="ipaddr">192.168.1.255</hostid>).</para>
        </listitem>

        <listitem>
          <para>L'indirizzo MAC della scheda (<literal>ether</literal>)
            &egrave; <hostid role="mac">00:a0:cc:da:da:da</hostid>.</para>
        </listitem>

        <listitem>
          <para>La selezione del mezzo fisico &egrave; in modalit&agrave;
            auto selezione (<literal>media: Ethernet autoselect (100baseTX
            &lt;full-duplex&gt;)</literal>).  Vediamo che
            <devicename>dc1</devicename> &egrave; stata configurata con un mezzo
            fisico <literal>10baseT/UTP</literal>.  Per ulteriori informazioni
            sui tipi di mezzi disponibili per un driver, fai riferimento alla
            sua pagina man.</para>
        </listitem>

        <listitem>
          <para>Lo stato del collegamento (<literal>status</literal>)
            &egrave; <literal>active</literal>, ovvero &egrave; stata rilevata
            la portante.  Per <devicename>dc1</devicename>, vediamo
            <literal>status: no carrier</literal>.  Questo &egrave; normale
            quando un cavo Ethernet non &egrave; stato inserito nella
            scheda.</para>
        </listitem>
      </orderedlist>

      <para>Se l'output di &man.ifconfig.8; avesse mostrato qualcosa di simile
        a:</para>

      <screen>dc0: flags=8843&lt;BROADCAST,SIMPLEX,MULTICAST&gt; mtu 1500
                ether 00:a0:cc:da:da:da</screen>

      <para>ci&ograve; avrebbe indicato che la scheda non era stata ben
        configurata.</para>

      <para>Per configurare la tua scheda, avrai bisogno dei privilegi
        di <username>root</username>.  La configurazione della scheda di rete
        pu&ograve; essere effettuata da riga di comando con &man.ifconfig.8;, ma
        avresti bisogno di farlo ad ogni riavvio del sistema.  Il file
        <filename>/etc/rc.conf</filename> &egrave; il posto giusto dove scrivere
        la configurazione della scheda di rete.</para>

      <para>Apri <filename>/etc/rc.conf</filename> con il tuo editor preferito.
        Avrai bisogno di aggiungere una riga per ogni scheda di rete presente
        nel sistema, ad esempio nel nostro caso, abbiamo aggiunto queste
        linee:</para>

      <programlisting>ifconfig_dc0="inet 192.168.1.3 netmask 255.255.255.0"
ifconfig_dc1="inet 10.0.0.1 netmask 255.255.255.0 media 10baseT/UTP"</programlisting>

      <para>Dovrai sostituire <devicename>dc0</devicename>,
        <devicename>dc1</devicename>, e cos&igrave; via, con i dispositivi
        corretti per la tua scheda, e gli indirizzi con quelli appropriati.
        Dovresti leggere le pagine man del driver e di &man.ifconfig.8; per
        maggiori dettagli sulle opzioni permesse ed anche la pagina man di
        &man.rc.conf.5; per maggiori informazioni sulla sintassi di
        <filename>/etc/rc.conf</filename>.</para>

      <para>Se hai configurato la rete durante l'installazione, alcune
        linee relative alle schede di rete potrebbero essere gi&agrave;
        presenti.  Controlla due volte <filename>/etc/rc.conf</filename> prima
        di aggiungere ogni linea.</para>

      <para>Avrai anche bisogno di modificare il file
        <filename>/etc/hosts</filename> per aggiungere i nomi e gli IP
        delle varie macchine della LAN, se non sono gi&agrave; l&igrave;.
        Per maggiori informazioni, fai riferimento a &man.hosts.5;
        ed a <filename>/usr/share/examples/etc/hosts</filename>.</para>
    </sect2>

    <sect2>
      <title>Verifica e Risoluzione dei Problemi</title>

      <para>Una volta che hai effettuato i cambiamenti necessari a
        <filename>/etc/rc.conf</filename>, dovresti riavviare la macchina.
        Ci&ograve; far&agrave; s&igrave; che i cambiamenti alle interfacce
        vengano applicati, e verificher&agrave; che il sistema si riavvii senza
        nessun errore di configurazione.</para>

      <para>Una volta che il sistema &egrave; stato riavviato, dovresti testare
        le interfacce di rete.</para>

      <sect3>
        <title>Test della Scheda Ethernet</title>

        <indexterm>
          <primary>schede di rete</primary>
          <secondary>test</secondary>
        </indexterm>

        <para>Per verificare che una scheda Ethernet sia configurata
          correttamente, si devono provare due cose.  Prima, effettuare un ping
          verso l'interfaccia stessa, e poi un ping verso un'altra macchina
          sulla LAN.</para>

        <para>Prima proviamo l'interfaccia:</para>

        <screen>&prompt.user; <userinput>ping -c5 192.168.1.3</userinput>
PING 192.168.1.3 (192.168.1.3): 56 data bytes
64 bytes from 192.168.1.3: icmp_seq=0 ttl=64 time=0.082 ms
64 bytes from 192.168.1.3: icmp_seq=1 ttl=64 time=0.074 ms
64 bytes from 192.168.1.3: icmp_seq=2 ttl=64 time=0.076 ms
64 bytes from 192.168.1.3: icmp_seq=3 ttl=64 time=0.108 ms
64 bytes from 192.168.1.3: icmp_seq=4 ttl=64 time=0.076 ms

--- 192.168.1.3 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.074/0.083/0.108/0.013 ms</screen>

        <para>Ora dobbiamo effettuare un ping verso un'altra macchina della
          LAN:</para>

        <screen>&prompt.user; <userinput>ping -c5 192.168.1.2</userinput>
PING 192.168.1.2 (192.168.1.2): 56 data bytes
64 bytes from 192.168.1.2: icmp_seq=0 ttl=64 time=0.726 ms
64 bytes from 192.168.1.2: icmp_seq=1 ttl=64 time=0.766 ms
64 bytes from 192.168.1.2: icmp_seq=2 ttl=64 time=0.700 ms
64 bytes from 192.168.1.2: icmp_seq=3 ttl=64 time=0.747 ms
64 bytes from 192.168.1.2: icmp_seq=4 ttl=64 time=0.704 ms

--- 192.168.1.2 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.700/0.729/0.766/0.025 ms</screen>

        <para>Puoi usare il nome della macchina invece di
          <hostid role="ipaddr">192.168.1.2</hostid> se hai sistemato il file
          <filename>/etc/hosts</filename>.</para>
      </sect3>

      <sect3>
        <title>Risoluzione dei Problemi</title>

        <indexterm>
          <primary>schede di rete</primary>
          <secondary>risoluzione dei problemi</secondary>
        </indexterm>

        <para>Risolvere i problemi delle varie configurazioni hardware e
          software &egrave; sempre una faticaccia, ma &egrave; una fatica che
          pu&ograve; essere diminuita controllando da subito le cose semplici.
          Avete collegato il cavo di rete?  Avete configurato i servizi di rete?
          Avete configurato il firewall correttamente?
          La scheda di rete che state usando &egrave; supportata da &os;?
          Controllate sempre le note sul vostro hardware prima di
          inviare un bug report.  Aggiornate la vostra versione di &os;
          all'ultima versione STABLE disponibile.  Controllate
          gli archivi delle mailing list, o magari cercate su Internet.</para>

        <para>Se la scheda funziona, ma le prestazioni sono scadenti, potrebbe
          esservi utile la lettura della pagina man &man.tuning.7;.  Potreste
          anche verificare la vostra configurazione della rete,
          poich&egrave; una configurazione
          scorretta pu&ograve; essere la causa di connessioni lente.</para>

        <para>Alcuni utenti riscontrano dei <errorname>device
            timeouts</errorname>, il che &egrave; normale per alcune
          schede.  Se questi continuano, o se sono fastidiosi,
          potreste voler ricontrollare che non ci
          siano conflitti con altri dispositivi.  Controllate due volte
          la connessione di rete.  Forse dovreste procurarvi un'altra
          scheda.</para>

        <para>Alcune volte, gli utenti notano alcuni errori
          <errorname>watchdog timeout</errorname>.
          La prima cosa da fare &egrave; controllare il cavo di rete.
          Alcune schede di rete richiedono uno slot PCI che supporti il Bus
          Mastering.  Su alcune vecchie schede madri, ci&ograve; &egrave;
          permesso solo per uno slot PCI (tipicamente lo slot 0).  Controllate
          la documentazione della scheda di rete  e della scheda madre
          per determinare se possa essere quello il problema.</para>

        <para>Messaggi <errorname>No route to host</errorname> vengono generati
          se il sistema non &egrave; in grado di effettuare il routing
          di un pacchetto verso una certa destinazione.
          Ci&ograve; pu&ograve; accadere se non &egrave; specificata
          una route di default, o se il cavo &egrave;
          scollegato.  Controllate l'output di <command>netstat
            -rn</command> ed assicuratevi che ci sia una route valida per l'host
          che state cercando di raggiungere.  Se non c'&egrave;, leggete il <xref
            linkend="advanced-networking">.</para>

        <para>I messaggi d'errore <errorname>ping: sendto:
            Permission denied</errorname>
          sono spessi causati da un firewall mal configurato.
          Se <command>ipfw</command> &egrave; abilitato nel kernel ma
          non ci sono regole definite, allora la politica di default &egrave; di
          negare tutto il traffico,
          comprese le richieste di ping!  Leggete il <xref
            linkend="firewalls"> per maggiori informazioni.</para>

        <para>Talvolta le prestazioni della scheda di rete sono
          scadenti, o sotto la media.
          In questi casi &egrave; preferibile cambiare la selezione
          del media da <literal>autoselect</literal> ad una
          selezione corretta.
          Anche se questo sistema funziona con la maggior parte dell'hardware,
          potrebbe non risolvere il problema per tutti.
          Ancora una volta, controllate tutte le impostazioni di rete,
          e leggete la pagina man &man.tuning.7; .</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="configtuning-virtual-hosts">
    <title>Host Virtuali</title>

    <indexterm><primary>host virtuali</primary></indexterm>
    <indexterm><primary>alias IP</primary></indexterm>

    <para>Un uso piuttosto comune di &os; &egrave; come hosting di siti
      virtuali, dove un solo server appare alla rete come molti server distinti.
      Ci&ograve; viene effettuato assegnando indirizzi di rete multipli ad una
      sola interfaccia.</para>

    <para>Una data interfaccia di rete ha un solo indirizzo
      <quote>reale</quote>, e pu&ograve; avere un numero qualsiasi di indirizzi
      <quote>alias</quote>.  Questi alias vengono normalmente aggiunti mettendo
      dei campi alias in <filename>/etc/rc.conf</filename>.</para>

    <para>Un campo alias per l'interfaccia <devicename>fxp0</devicename>
      appare cos&igrave;:</para>

    <programlisting>ifconfig_fxp0_alias0="inet xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx"</programlisting>

    <para>Nota che il campo alias deve iniziare con <literal>alias0</literal> e
      aumentare in ordine, (ad esempio, <literal>_alias1</literal>,
      <literal>_alias2</literal>, e cos&igrave; via).  Il processo di
      configurazione si fermer&agrave; al primo numero mancante.</para>

    <para>Il calcolo delle maschere di sotto-rete degli alias &egrave;
      importante, ma, fortunatamente, &egrave; anche abbastanza semplice.
      Per una data interfaccia, deve esserci un indirizzo che rappresenta
      correttamente la maschera di sotto-rete.
      Ogni altro indirizzo che ricada in questa rete deve avere una maschera di
      sotto-rete con tutti <literal>1</literal> (espressi
      come <hostid role="netmask">255.255.255.255</hostid> o
      <hostid role="netmask">0xffffffff</hostid>).</para>

    <para>Ad esempio, considera il caso in cui l'interfaccia
      <devicename>fxp0</devicename> sia connessa a due reti, la rete <hostid
        role="ipaddr">10.1.1.0</hostid> con maschera di sotto-rete
      <hostid role="netmask">255.255.255.0</hostid> e la rete
      <hostid role="ipaddr">202.0.75.16</hostid> con maschera di
      sotto-rete <hostid role="netmask">255.255.255.240</hostid>.
      Vogliamo che il sistema sia
      visibile come <hostid role="ipaddr">10.1.1.1</hostid> fino a
      <hostid role="ipaddr">10.1.1.5</hostid> e come
      <hostid role="ipaddr">202.0.75.17</hostid> fino a
      <hostid role="ipaddr">202.0.75.20</hostid>.
      Come notato sopra, solo il primo indirizzo in un dato range
      di sotto-rete (in questo caso, <hostid role="ipaddr">10.0.1.1</hostid> e
      <hostid role="ipaddr">202.0.75.17</hostid>) dovrebbe
      avere una vera netmask; tutto il resto (
      <hostid role="ipaddr">10.1.1.2</hostid> fino a
      <hostid role="ipaddr">10.1.1.5</hostid> e
      <hostid role="ipaddr">202.0.75.18</hostid> fino a
      <hostid role="ipaddr">202.0.75.20</hostid>) dovrebbe
      essere configurato con una netmask di
      <hostid role="netmask">255.255.255.255</hostid>.</para>

    <para>Le seguenti righe configurano il dispositivo correttamente per questo
      scopo:</para>

    <programlisting> ifconfig_fxp0="inet 10.1.1.1 netmask 255.255.255.0"
 ifconfig_fxp0_alias0="inet 10.1.1.2 netmask 255.255.255.255"
 ifconfig_fxp0_alias1="inet 10.1.1.3 netmask 255.255.255.255"
 ifconfig_fxp0_alias2="inet 10.1.1.4 netmask 255.255.255.255"
 ifconfig_fxp0_alias3="inet 10.1.1.5 netmask 255.255.255.255"
 ifconfig_fxp0_alias4="inet 202.0.75.17 netmask 255.255.255.240"
 ifconfig_fxp0_alias5="inet 202.0.75.18 netmask 255.255.255.255"
 ifconfig_fxp0_alias6="inet 202.0.75.19 netmask 255.255.255.255"
 ifconfig_fxp0_alias7="inet 202.0.75.20 netmask 255.255.255.255"</programlisting>
  </sect1>

  <sect1 id="configtuning-configfiles">
    <title>File di Configurazione</title>

    <sect2>
      <title>Struttura di <filename>/etc</filename></title>

      <para>Ci sono molte directory nelle quali vengono tenute le informazioni
        di configurazione.  Tra queste ci sono:</para>

      <informaltable frame="none" pgwide="1">
        <tgroup cols="2">
          <colspec colwidth="1*">

          <colspec colwidth="2*">

          <tbody>
            <row>
              <entry><filename>/etc</filename></entry>

              <entry>Informazioni generiche sulla configurazione del sistema;
                questi dati sono specifici del sistema.</entry>
            </row>

            <row>
              <entry><filename>/etc/defaults</filename></entry>

              <entry>Versioni di default dei file di configurazione del
                sistema.</entry>
            </row>

            <row>
              <entry><filename>/etc/mail</filename></entry>

              <entry>Configurazioni extra di &man.sendmail.8;, o file di
                configurazione di altri MTA.</entry>
            </row>

            <row>
              <entry><filename>/etc/ppp</filename></entry>

              <entry>Configurazione ppp sia per i programmi a livello utente che
                a livello kernel.</entry>
            </row>

            <row>
              <entry><filename>/etc/namedb</filename></entry>

              <entry>Posizione predefinita per i dati di &man.named.8;.
                Normalmente qui si trova <filename>named.conf</filename> insieme
                ai file di zona.</entry>
            </row>

            <row>
              <entry><filename>/usr/local/etc</filename></entry>

              <entry>File di configurazione per le applicazioni installate.
                Pu&ograve; contenere sottodirectory.</entry>
            </row>

            <row>
              <entry><filename>/usr/local/etc/rc.d</filename></entry>

              <entry>Script start/stop per i programmi installati.</entry>
            </row>

            <row>
              <entry><filename>/var/db</filename></entry>

              <entry>File di dati specifici del sistema generati
                automaticamente, come il database dei package, il database di
                locate, e cos&igrave; via.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </sect2>

    <sect2>
      <title>Nomi degli Host</title>

      <indexterm><primary>nomi degli host</primary></indexterm>
      <indexterm><primary>DNS</primary></indexterm>

      <sect3>
        <title><filename>/etc/resolv.conf</filename></title>

        <indexterm>
          <primary><filename>resolv.conf</filename></primary>
        </indexterm>

        <para><filename>/etc/resolv.conf</filename> detta il modo in cui il
          sistema di risoluzione dei nomi di &os; accede al DNS
          (Internet Domain Name System).</para>

        <para>I campi pi&ugrave; comuni in <filename>resolv.conf</filename>
          sono:</para>

        <informaltable frame="none" pgwide="1">
          <tgroup cols="2">
            <colspec colwidth="1*">

            <colspec colwidth="2*">

            <tbody>
              <row>
                <entry><literal>nameserver</literal></entry>

                <entry>L'indirizzo IP di un name server al quale dovr&agrave;
                  rivolgersi il sistema di risoluzione.  I server vengono
                  interrogati nell'ordine in cui sono elencati, fino a un
                  massimo di tre.</entry>
              </row>

              <row>
                <entry><literal>search</literal></entry>

                <entry>Lista di ricerca per i nomi degli host.  Normalmente
                  questo viene determinato dal dominio dell'host locale.</entry>
              </row>

              <row>
                <entry><literal>domain</literal></entry>

                <entry>Il nome del dominio locale.</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>Un <filename>resolv.conf</filename> tipico:</para>

        <programlisting>search example.com
nameserver 147.11.1.11
nameserver 147.11.100.30</programlisting>

        <note>
          <para>Si dovrebbe usare solo una tra le due opzioni
            <literal>search</literal> e <literal>domain</literal>.</para>
        </note>

        <para>Se stai usando DHCP, &man.dhclient.8; generalmente
          sovrascriver&agrave; <filename>resolv.conf</filename> con le
          informazioni ricevute dal server DHCP.</para>
      </sect3>

      <sect3>
        <title><filename>/etc/hosts</filename></title>

        <indexterm><primary>hosts</primary></indexterm>

        <para><filename>/etc/hosts</filename> &egrave; un semplice database
          testuale, reminiscenza della vecchia rete Internet.
          Esso lavora in congiunzione con DNS e NIS fornendo una mappatura da
          nome a indirizzo IP.  Computer locali connessi ad una LAN possono
          essere messi in questo file per una gestione semplice dei nomi, invece
          di mettere su un server &man.named.8;.
          Inoltre, <filename>/etc/hosts</filename> pu&ograve; essere usato per
          fornire un registro locale dei nomi di Internet, riducendo la
          necessit&agrave; di effettuare richieste esternamente per i nomi ad
          accesso frequente.</para>

        <programlisting># &dollar;&os;&dollar;
#
# Host Database
# Questo file dovrebbe contenere gli indirizzi e gli alias
# per gli host locali che condividono questo file.
# In presenza di DNS o NIS, questo file potrebbe non essere consultato affatto;
# guarda /etc/nsswitch.conf per l'ordine di risoluzione.
#
#
::1                     localhost localhost.my.domain myname.my.domain
127.0.0.1               localhost localhost.my.domain myname.my.domain

#
# Rete immaginaria.
#10.0.0.2               myname.my.domain myname
#10.0.0.3               myfriend.my.domain myfriend
#
# In accordo all'RFC 1918, puoi usare le seguenti classi di IP per reti private
# che non verranno mai connesse ad Internet:
#
#       10.0.0.0        -   10.255.255.255
#       172.16.0.0      -   172.31.255.255
#       192.168.0.0     -   192.168.255.255
#
# In caso volessi essere in grado di collegarti ad Internet, avrai bisogno
# di veri numeri ufficiali assegnati.  PER FAVORE PER FAVORE PER FAVORE
# non tentare di inventarti i numeri della tua rete ma fattene assegnare
# uno dal tuo provider (se ne hai uno) o dall'Internet Registry (ftp su
# rs.internic.net, directory `/templates').
#</programlisting>

        <para><filename>/etc/hosts</filename> accetta il semplicissimo
          formato:</para>

        <programlisting>[Indirizzo Internet ] [nome host ufficiale] [alias1] [alias2] ...</programlisting>

        <para>Ad esempio:</para>

        <programlisting>10.0.0.1 myRealHostname.example.com myRealHostname foobar1 foobar2</programlisting>

        <para>Consulta &man.hosts.5; per maggiori informazioni.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Configurazione dei File di Log</title>

      <indexterm><primary>file di log</primary></indexterm>

      <sect3>
        <title><filename>syslog.conf</filename></title>

        <indexterm><primary>syslog.conf</primary></indexterm>

        <para><filename>syslog.conf</filename> &egrave; il file di
          configurazione per il programma &man.syslogd.8;.  Indica quale tipo di
          messaggi <command>syslog</command> verranno scritti su ogni file di
          log.</para>

        <programlisting># &dollar;&os;&dollar;
#
#       Gli spazi SONO validi separatori dei campi in questo file. Ad ogni modo,
#       altri sistemi *nix-like insistono ancora nell'usare tab come separatori
#       di campo. Se condividi questo file tra pi&ugrave; sistemi, potresti
#       voler usare solo dei tab come separatori.
#       Consulta la pagina man di syslog.conf(5).
*.err;kern.debug;auth.notice;mail.crit          /dev/console
*.notice;kern.debug;lpr.info;mail.crit;news.err /var/log/messages
security.*                                      /var/log/security
mail.info                                       /var/log/maillog
lpr.info                                        /var/log/lpd-errs
cron.*                                          /var/log/cron
*.err                                           root
*.notice;news.err                               root
*.alert                                         root
*.emerg                                         *
# togli il commento a questo per loggare tutte le scritture su /dev/console
# in /var/log/console.log
#console.info                                   /var/log/console.log
# togli il commento a questo per abilitare il logging di tutti i messaggi di log
# su /var/log/all.log
#*.*                                            /var/log/all.log
# togli il commento a questo per abilitare il logging su un host remoto di nome
# loghost
#*.*                                            @loghost
# togli i commenti a questi se hai inn in funzione
# news.crit                                     /var/log/news/news.crit
# news.err                                      /var/log/news/news.err
# news.notice                                   /var/log/news/news.notice
!startslip
*.*                                             /var/log/slip.log
!ppp
*.*                                             /var/log/ppp.log</programlisting>

        <para>Consulta la pagina man di &man.syslog.conf.5; per maggiori
          informazioni.</para>
      </sect3>

      <sect3>
        <title><filename>newsyslog.conf</filename></title>

        <indexterm><primary>newsyslog.conf</primary></indexterm>

        <para><filename>newsyslog.conf</filename> &egrave; il file di
          configurazione di &man.newsyslog.8;, un programma che normalmente
          viene eseguito da &man.cron.8;. &man.newsyslog.8; determina quando i
          file di log richiedono un'archiviazione o un riordinamento.
          <filename>logfile</filename> viene rinominato in
          <filename>logfile.0</filename>, <filename>logfile.0</filename> in
          <filename>logfile.1</filename> e cos&igrave; via.
          Alternativamente, i file potranno essere archiviati in formato
          &man.gzip.1;, e quindi diventeranno:
          <filename>logfile.0.gz</filename>, <filename>logfile.1.gz</filename>,
          e cos&igrave; via.</para>

        <para><filename>newsyslog.conf</filename> indica quali file di log
          devono essere gestiti, quanti devono essere mantenuti, e quando devono
          essere toccati.  I file di log possono essere riordinati e/o
          archiviati quando raggiungono una certa dimensione, o a una certa
          data/ora periodica.</para>

        <programlisting># file di configurazione per newsyslog
# &dollar;&os;&dollar;
#
# filename          [owner:group]    mode count size when [ZB] [/pid_file] [sig_num]
/var/log/cron                           600  3     100  *     Z
/var/log/amd.log                        644  7     100  *     Z
/var/log/kerberos.log                   644  7     100  *     Z
/var/log/lpd-errs                       644  7     100  *     Z
/var/log/maillog                        644  7     *    @T00  Z
/var/log/sendmail.st                    644  10    *    168   B
/var/log/messages                       644  5     100  *     Z
/var/log/all.log                        600  7     *    @T00  Z
/var/log/slip.log                       600  3     100  *     Z
/var/log/ppp.log                        600  3     100  *     Z
/var/log/security                       600  10    100  *     Z
/var/log/wtmp                           644  3     *    @01T05 B
/var/log/daily.log                      640  7     *    @T00  Z
/var/log/weekly.log                     640  5     1    $W6D0 Z
/var/log/monthly.log                    640  12    *    $M1D0 Z
/var/log/console.log                    640  5     100  *     Z</programlisting>

        <para>Consulta la pagina man di &man.newsyslog.8; per maggiori
          informazioni.</para>
      </sect3>
    </sect2>

    <sect2 id="configtuning-sysctlconf">
      <title><filename>sysctl.conf</filename></title>

      <indexterm><primary>sysctl.conf</primary></indexterm>
      <indexterm><primary>sysctl</primary></indexterm>

      <para><filename>sysctl.conf</filename> assomiglia molto a
        <filename>rc.conf</filename>.  I valori vengono impostati nella forma
        <literal>variabile=valore</literal>.  I valori specificati vengono
        impostati dopo che il sistema &egrave; entrato in modalit&agrave;
        multiutente.  Non tutte le variabili sono gestibili in questo
        modo.</para>

      <para>Per disabilitare il log sulle uscite dei processi per segnale
        fatale ed impedire agli utenti di vedere che i processi sono avviati
        con altre utenze, puoi settare in <filename>sysctl.conf</filename>
        la riga seguente:</para>

      <programlisting># Do not log fatal signal exits (e.g. sig 11)
kern.logsigexit=0

# Prevent users from seeing information about processes that
# are being run under another UID.
security.bsd.see_other_uids=0</programlisting>
    </sect2>
  </sect1>

  <sect1 id="configtuning-sysctl">
    <title>Messa a Punto con sysctl</title>

    <indexterm><primary>sysctl</primary></indexterm>
    <indexterm>
      <primary>tuning</primary>
      <secondary>con sysctl</secondary>
    </indexterm>

    <para>&man.sysctl.8; &egrave; un'interfaccia che permette di effettuare
      cambiamenti ad un sistema &os; gi&agrave; attivo.  Questo include molte
      opzioni avanzate dello stack TCP/IP e del sistema di memoria virtuale che
      possono permettere di migliorare drammaticamente le prestazioni ad un
      sistemista che abbia esperienza.  Pi&ugrave; di cinquecento variabili di
      sistema possono essere lette e modificate usando &man.sysctl.8;.</para>

    <para>In sostanza, &man.sysctl.8; serve a due cose: a leggere e a modificare
      le impostazioni di sistema.</para>

    <para>Per visualizzare tutte le variabili leggibili:</para>

    <screen>&prompt.user; <userinput>sysctl -a</userinput></screen>

    <para>Per leggere una particolare variabile, ad esempio,
      <varname>kern.maxproc</varname>:</para>

    <screen>&prompt.user; <userinput>sysctl kern.maxproc</userinput>
kern.maxproc: 1044</screen>

    <para>Per impostare una particolare variabile, usa l'intuitiva sintassi
      <replaceable>variabile</replaceable>=<replaceable>valore</replaceable>:</para>

    <screen>&prompt.root; <userinput>sysctl kern.maxfiles=5000</userinput>
kern.maxfiles: 2088 -&gt; 5000</screen>

    <para>I valori validi per le variabili di sysctl sono generalmente o
      stringhe, o numeri, o valori booleani (un valore booleano pu&ograve;
      valere <literal>1</literal> per s&igrave; o <literal>0</literal> per
      no).</para>

    <para>Se vuoi settare in modo automatico alcune variabile ad ogni
      avvio della macchina, usa il file <filename>/etc/sysctl.conf</filename>.
      Per maggiori informazioni guarda la pagina man
      di &man.sysctl.conf.5; e la
      <xref linkend="configtuning-sysctlconf">.</para>

    <sect2 id="sysctl-readonly">
      <sect2info>
        <authorgroup>
          <author>
            <firstname>Tom</firstname>

            <surname>Rhodes</surname>

            <contrib>Contributo di </contrib>
          </author>
        </authorgroup>
      </sect2info>

      <title>&man.sysctl.8; in sola lettura</title>

      <para>In alcuni casi pu&ograve; essere desiderabile modificare i valori di
        &man.sysctl.8; in sola lettura.  Anche se questo talvolta &egrave;
        inevitabile, pu&ograve; essere fatto solo con un riavvio.</para>

      <para>Ad esempio in alcuni modelli di laptop il dispositivo
        &man.cardbus.4; non effettuer&agrave; il controllo sugli intervalli di
        memoria, e fallir&agrave; con errori che assomigliano a questi:</para>

      <screen>cbb0: Could not map register memory
device_probe_and_attach: cbb0 attach returned 12</screen>

      <para>Casi come il precedente richiedono tipicamente la modifica di alcuni
        valori predefiniti di &man.sysctl.8; che sono impostati come sola
        lettura.  Per superare queste situazioni
        un utente pu&ograve; mettere degli <quote>OID</quote> di &man.sysctl.8;
        nel proprio <filename>/boot/loader.conf.local</filename>.  I valori
        predefiniti sono indicati nel file
        <filename>/boot/defaults/loader.conf</filename>.</para>

      <para>Per risolvere i problemi menzionati qui sopra sar&agrave; necessario
        modificare <option>hw.pci.allow_unsupported_io_range=1</option> nel file
        suddetto.  Ora &man.cardbus.4; funzioner&agrave; correttamente.</para>
    </sect2>
  </sect1>

  <sect1 id="configtuning-disk">
    <title>Messa a Punto dei Dischi</title>

    <sect2>
      <title>Variabili Sysctl</title>

      <sect3>
        <title><varname>vfs.vmiodirenable</varname></title>

        <indexterm>
          <primary><varname>vfs.vmiodirenable</varname></primary>
        </indexterm>

        <para>La variabile sysctl <varname>vfs.vmiodirenable</varname>
          pu&ograve; essere impostata a 0 (inattivo) o 1 (attivo); di default
          &egrave; 1.  Questa variabile controlla il modo in cui le directory
          vengono messe nella cache dal sistema.  La maggior parte delle
          directory sono piccole, e usano solo un singolo frammento
          (tipicamente 1&nbsp;K) nel file system e meno (tipicamente
          512&nbsp;byte) nella cache.
          Con questa variabile impostata a 0, il buffer manterr&agrave; soltanto
          un numero fissato di directory nella cache anche se hai una
          quantit&agrave; enorme di memoria.
          Attivando questa sysctl si permette al buffer di usare la VM Page
          Cache per immagazzinare le directory, rendendo disponibile tutta la
          memoria disponibile per il caching delle directory.  In ogni caso, la
          minima quantit&agrave; di memoria usata per memorizzare una directory
          sar&agrave; la dimensione della pagina fisica (in genere 4&nbsp;K)
          invece di 512&nbsp;byte.
          Noi consigliamo di attivare questa opzione se si hanno in
          esecuzione dei servizi che manipolano un grosso numero file.  Servizi
          di questo tipo sono le cache web, i grandi sistemi di posta, e quelli
          di news.  Attivare questa opzione in generale non ridurr&agrave; le
          prestazioni nonostante la memoria sprecata, ma dovresti sperimentare
          tu stesso per verificare.</para>
      </sect3>

      <sect3>
        <title><varname>vfs.write_behind</varname></title>

        <indexterm>
          <primary><varname>vfs.write_behind</varname></primary>
        </indexterm>

        <para>La variabile sysctl <varname>vfs.write_behind</varname>
          ha il valore predefinito di <literal>1</literal> (attivo).
          Essa dice al file system
          di effettuare le scritture sul media quando vengono raccolti
          cluster completi, il che accade tipicamente
          quando si scrivono grossi file sequenziali.  L'idea &egrave; di
          evitare la saturazione del buffer cache con buffer
          <quote>sporchi</quote> quando le prestazioni dell'I/O non ne
          trarrebbero giovamento.  Ad ogni modo, questo pu&ograve; causare uno
          stallo dei processi, ed in alcune circostanze potreste desiderare di
          disabilitarlo.</para>
      </sect3>

      <sect3>
        <title><varname>vfs.hirunningspace</varname></title>

        <indexterm>
          <primary><varname>vfs.hirunningspace</varname></primary>
        </indexterm>

        <para>La variabile sysctl <varname>vfs.hirunningspace</varname>
          determina quanto grande deve essere la coda I/O  in tutti i controller
          dei dischi nel sistema in un dato momento.  Il valore predefinito in
          genere &egrave; sufficiente ma su macchine con molti dischi
          potreste voler aumentarlo a quattro o cinque
          <emphasis>megabyte</emphasis>.
          Notate che impostandolo ad un valore troppo alto (superando i limiti
          della cache) potreste avere delle performance peggiori.
          Non impostate un valore troppo alto arbitrariamente!
          Valori pi&ugrave; alti aumentano la latenza nelle letture
          contemporanee.</para>

        <para>Ci sono altre sysctl relative alla buffer-cache ed alle cache
          delle pagine VM.  Non vi consigliamo di cambiare questi valori,
          il sistema di VM fa gi&agrave; un ottimo lavoro
          di messa a punto automatica.</para>
      </sect3>

      <sect3>
        <title><varname>vm.swap_idle_enabled</varname></title>

        <indexterm>
          <primary><varname>vm.swap_idle_enabled</varname></primary>
        </indexterm>

        <para>La variabile sysctl <varname>vm.swap_idle_enabled</varname>
          &egrave; utile in grossi sistemi multiutente dove si hanno molti
          utenti che entrano ed escono lasciando molti processi inattivi.
          Questi sistemi tendono a generare un grande pressione sulle riserve
          di memoria libera.  Attivando questa caratteristica e manipolando
          l'isteresi di swap (in secondi di inattivit&agrave;) tramite
          <varname>vm.swap_idle_threshold1</varname> e
          <varname>vm.swap_idle_threshold2</varname> potete abbassare
          la priorit&agrave; delle pagine di memoria associate con i processi
          inattivi pi&ugrave; velocemente che con il normale algoritmo di
          paginazione.
          Ci&ograve; d&agrave; una mano al demone di paginazione.  Non attivate
          questa opzione a meno che non ne abbiate bisogno,
          poich&egrave; il compromesso che state accettando &egrave;
          essenzialmente di pre-paginare la memoria in anticipo piuttosto che
          in ritardo, consumando dunque pi&ugrave;
          swap e banda di trasmissione verso il disco.  In un piccolo sistema
          questa opzione avr&agrave; un effetto ridotto
          ma in un grosso sistema che &egrave; gi&agrave; sottoposto a un
          moderato carico di paginazione questa opzione permette al sistema VM
          di spostare facilmente interi processi dentro e fuori la
          memoria.</para>
      </sect3>

      <sect3>
        <title><varname>hw.ata.wc</varname></title>

        <indexterm><primary><varname>hw.ata.wc</varname></primary></indexterm>

        <para>&os;&nbsp;4.3 ha giocato un p&ograve; con l'idea di disattivare il
          caching IDE in scrittura.  Questo ha ridotto la larghezza di banda in
          scrittura verso i dischi IDE ma &egrave; stato considerato necessario
          a causa di gravi problemi di consistenza dei dati introdotti dai
          venditori di dischi rigidi.  Il problema &egrave; che il disco IDE
          rimane inattivo dopo che una scrittura &egrave; stata completata.  Con
          il caching in scrittura attivo, i dischi IDE non scrivono soltanto i
          dati sui dischi in maniera disordinata, ma talvolta rimandano la
          scrittura indefinitamente sotto carichi di lavoro del disco pesanti.
          Un crash o un calo di tensione possono condurre a seri problemi di
          corruzione del file system.  L'impostazione predefinita di &os; fu
          cambiata in favore della sicurezza.  Sfortunatamente, il risultato
          &egrave; stato una perdita di prestazioni talmente tremenda che
          abbiamo dovuto reinserire il caching in scrittura di default dopo
          quella release.  Dovresti verificare il valore di default sul tuo
          sistema osservando la variabile sysctl <varname>hw.ata.wc</varname>.
          Se il caching IDE in scrittura &egrave; disattivato, potete attivarlo
          reimpostando la variabile del kernel a 1.  Questo dovrebbe essere
          effettuato dal boot loader all'avvio.  Tentare di effettuare questo
          cambiamento dopo che il kernel &egrave; stato avviato non avr&agrave;
          nessun effetto.</para>

        <para>Per maggiori informazioni, guarda &man.ata.4;.</para>
      </sect3>


      <sect3>
        <title><option>SCSI_DELAY</option>
          (<varname>kern.cam.scsi_delay</varname>)</title>

        <indexterm>
          <primary><varname>kern.cam.scsi_delay</varname></primary>
        </indexterm>
        <indexterm>
          <primary><option>kernel options</option></primary>
          <secondary><literal>SCSI_DELAY</literal></secondary>
        </indexterm>

        <para>La configurazione del kernel <option>SCSI_DELAY</option>
          pu&ograve; ridurre il tempo di avvio del sistema.  I valori di default
          sono piuttosto alti e possono essere responsabili
          anche di <literal>15</literal> secondi di ritardo
          nel processo di avvio.  Ridurre il valore a <literal>5</literal>
          secondi funziona in molti casi (specialmente con i dispositivi
          moderni).  Nuove versioni di &os; (5.0 e superiori) dovrebbero essere
          in  grado di usare <varname>kern.cam.scsi_delay</varname>
          come un'opzione da boot.  Quest'ultima e l'opzione di
          configurazione del kernel accettano valori in
          <emphasis>millisecondi</emphasis> , e
          <emphasis>non</emphasis> in <emphasis>secondi</emphasis>.</para>
      </sect3>
    </sect2>

    <sect2 id="soft-updates">
      <title>Soft Update</title>

      <indexterm><primary>Soft Update</primary></indexterm>
      <indexterm><primary>tunefs</primary></indexterm>

      <para>Il programma &man.tunefs.8; pu&ograve; essere usato per mettere a
        punto con accuratezza un file system.  Questo programma ha molte opzioni
        differenti, ma per ora noi ci preoccuperemo solo di attivare e
        disattivare i Soft Update, che verr&agrave; effettuato tramite:</para>

      <screen>&prompt.root; <userinput>tunefs -n enable /filesystem</userinput>
&prompt.root; <userinput>tunefs -n disable /filesystem</userinput></screen>

      <para>Un file system non potr&agrave; essere modificato con &man.tunefs.8;
        mentre &egrave; montato.  Un buon momento per attivare i Soft Update
        &egrave; prima che le partizioni siano montate, in modalit&agrave;
        singolo utente.</para>

      <para>I Soft Update migliorano drasticamente le prestazioni dei
        meta-dati, principalmente la creazione e la cancellazione di file,
        attraverso l'uso di una memoria cache.  Consigliamo di attivare i Soft
        Update su tutti i file system.  Ci sono due lati negativi relativi ai
        Soft Update dei quali dovresti essere a conoscenza: primo, i Soft
        Update garantiscono la consistenza del file system in caso di crash ma
        &egrave; pi&ugrave; che probabile che passino molti secondi (anche un
        minuto!) prima che venga aggiornato fisicamente il disco.  Se il
        sistema va in crash potresti perdere molto pi&ugrave; lavoro in questo
        modo.  Secondo, i Soft Update rallentano la liberazione dei blocchi
        liberi del file system.  Se hai un file system (come il file system
        root) che &egrave; quasi pieno, la realizzazione di un grosso
        aggiornamento, come un <command>make installworld</command>, potrebbe
        essere causa di un superamento dei limiti di spazio del file system e
        di un fallimento dell'aggiornamento.</para>

      <sect3>
        <title>Maggiori Dettagli sui Soft Update</title>

        <indexterm>
          <primary>Soft Updates</primary>
          <secondary>dettagli</secondary>
        </indexterm>

        <para>Ci sono due approcci tradizionalmente nella scrittura dei
          meta-dati del file system su disco.  (Gli aggiornamenti dei meta-dati
          sono aggiornamenti ai dati che non sono contenuto, come gli inode o
          le directory.)</para>

        <para>Storicamente, il comportamento predefinito era di scrivere gli
          aggiornamenti dei meta-dati in maniera sincrona.  Se una directory
          veniva modificata, il sistema attendeva finch&egrave; il cambiamento
          venisse effettivamente scritto su disco.  I buffer con i dati dei file
          (i contenuti dei file) venivano passati attraverso la cache e salvati
          su disco in seguito, in maniera asincrona.  Il vantaggio di questa
          implementazione &egrave; che avviene in maniera sicura.  Se si
          verifica un problema durante un aggiornamento, i meta-dati sono sempre
          in uno stato consistente.  Un file viene creato completamente o non
          viene creato affatto.  Se i blocchi dati di un file non sono riusciti
          ad uscire dalla cache e arrivare al disco prima del crash,
          &man.fsck.8; &egrave; in grado di capirlo e riparare il file system
          impostando a zero la lunghezza del file.  Inoltre, l'implementazione
          &egrave; chiara e semplice.  Lo svantaggio &egrave; che i cambiamenti
          dei meta-dati sono lenti.  Un <command>rm -r</command>, ad esempio,
          tocca tutti i file in una directory consecutivamente, ma ogni
          cambiamento della directory (la cancellazione del file) verr&agrave;
          scritto su disco in maniera sincrona.  Questo include gli
          aggiornamenti alla directory stessa, alla tabella degli inode, e
          magari anche ai blocchi indiretti allocati dal file.  Simili
          considerazioni si applicano nell'elenco di grosse gerarchie
          (<command>tar -x</command>).</para>

        <para>Il secondo caso &egrave; l'aggiornamento asincrono dei meta-dati.
          Questo &egrave; il comportamento predefinito per Linux/ext2fs e
          <command>mount -o async</command> per *BSD/ufs.  Anche tutti gli
          aggiornamenti dei meta-dati vengono semplicemente fatti passare
          attraverso la cache, cio&egrave; vengono mescolati con gli
          aggiornamenti dei dati contenuti nel file.  Il vantaggio di questa
          implementazione &egrave; che non c'&egrave; bisogno di attendere che
          ogni aggiornamento dei meta-dati venga scritto su disco, dunque tutte
          le operazioni che causano enormi quantit&agrave; di aggiornamenti dei
          meta-dati lavorano molto pi&ugrave; velocemente che nel caso sincrono.
          Inoltre, l'implementazione &egrave; ancora semplice e chiara, dunque
          c'&egrave; un basso rischio che si annidino dei bug nel codice.
          Lo svantaggio &egrave; che non c'&egrave; nessuna garanzia di uno
          stato consistente del file system.  Se si verifica un problema durante
          un'operazione che ha aggiornato grandi quantit&agrave; di meta-dati
          (ad esempio un abbassamento di tensione, o qualcuno che preme il tasto
          reset), il file system verr&agrave; lasciato in uno stato
          imprevedibile.  Non c'&egrave; opportunit&agrave; di esaminare lo
          stato del file system quando il sistema viene riavviato; i blocchi
          dati di un file potrebbero essere gi&agrave; stati scritti sul disco
          mentre gli aggiornamenti della tabella degli inode o la directory
          associata non lo sono.
          &Egrave; praticamente impossibile implementare un
          <command>fsck</command> che sia in grado di ripulire il caos
          risultante (perch&egrave; i dati necessari non sono disponibili sul
          disco).  Se il file system &egrave; stato danneggiato pi&ugrave; del
          riparabile, la sola scelta &egrave; di usare &man.newfs.8;
          per ricrearlo e recuperarlo da un backup.</para>

        <para>La soluzione comune di questo problema era implementare
          <emphasis>la registrazione delle regioni sporche</emphasis>, a cui
          spesso si fa riferimento come <emphasis>journaling</emphasis>, anche
          se questo termine non viene usato coerentemente e talvolta viene
          applicato ad altre forme di logging delle transazioni.  Gli
          aggiornamenti dei meta-dati sono ancora scritti in maniera sincrona,
          ma solo in una piccola regione del disco.  In seguito vengono spostati
          nella posizione appropriata.  Poich&egrave; l'area di registrazione
          &egrave; una piccola regione contigua sul disco, non ci sono lunghe
          distanze da percorrere per le testine del disco, anche durante le
          operazioni pesanti, dunque queste operazioni sono pi&ugrave; veloci
          degli aggiornamenti sincroni.  Inoltre la complessit&agrave;
          dell'implementazione &egrave; piuttosto limitata, dunque il rischio
          che si presentino dei bug &egrave; basso.  Uno svantaggio &egrave; che
          tutti i meta-dati vengono scritti due volte (una volta nella regione
          di logging ed un'altra nella posizione appropriata) e quindi per un
          lavoro normale si pu&ograve; avere un <quote>peggioramento</quote>
          delle prestazioni.  D'altro canto, in caso di crash, tutte le
          operazioni sui meta-dati in sospeso possono essere velocemente
          annullate o recuperate dall'area di registrazione quando il sistema
          &egrave; di nuovo attivo, e come risultato si ha un avvio veloce del
          file system.</para>

        <para>Kirk McKusick, lo sviluppatore del Berkeley FFS, ha risolto questo
          problema con i Soft Update: tutti gli aggiornamenti dei meta-dati
          vengono tenuti in memoria e vengono scritti su disco in sequenza
          ordinata (<quote>aggiornamenti ordinati dei meta-dati</quote>).
          Ci&ograve; porta all'effetto che, in caso di operazioni pesanti sui
          meta-dati, gli ultimi aggiornamenti ad un elemento
          <quote>recuperano</quote> i precedenti se questi sono ancora in
          memoria e non sono gi&agrave; stati scritti su disco.  Dunque tutte le
          operazioni, diciamo su una directory, vengono effettuate
          principalmente in memoria prima che l'aggiornamento sia scritto su
          disco (i blocchi dei dati vengono ordinati in relazione alla loro
          posizione, in modo che non vengano scritti su disco prima dei loro
          meta-dati).  Se il sistema va in crash, ci&ograve; causa un implicito
          <quote>riavvolgimento del log</quote>: tutte le operazioni che non
          hanno ancora trovato posto sul disco appariranno come mai effettuate.
          Viene mantenuto uno stato consistente del file system che sar&agrave;
          quello di 30 o 60 secondi prima.  L'algoritmo usato garantisce anche
          che tutte le risorse in uso siano marcate come tali nelle appropriate
          tabelle di bit: blocchi e inode.  Dopo un crash, il solo errore di
          allocazione &egrave; che vengono marcate come <quote>usate</quote>
          anche risorse che sono effettivamente <quote>libere</quote>.
          &man.fsck.8; riconosce questa situazione, e libera le risorse che non
          sono pi&ugrave; in uso.  Non c'&egrave; pericolo nell'ignorare lo
          stato di <emphasis>sporcizia</emphasis> del file system dopo un crash
          montandolo di forza con <command>mount -f</command>.  Per poter
          liberare le risorse che potrebbero essere non usate, &man.fsck.8;
          ha bisogno di essere avviato in seguito.  Questa &egrave; l'idea di un
          <emphasis>fsck in background</emphasis>: all'avvio del sistema, viene
          registrata solo una <emphasis>immagine</emphasis> del file system.
          <command>fsck</command> pu&ograve; essere eseguito in seguito.  Tutti
          i file system possono essere montati <quote>sporchi</quote>, quindi il
          processo di avvio del sistema procede in modalit&agrave; multiutente.
          In seguito, <command>fsck</command> viene avviato in background su
          tutti i file system dove &egrave; necessario, per liberare le risorse
          che potrebbero essere inutilizzate.  (I file system che non usano i
          Soft Updates hanno ancora bisogno del solito <command>fsck</command>,
          comunque.)</para>

        <para>Il vantaggio &egrave; che le operazioni sui meta-dati sono veloci
          quasi come gli aggiornamenti asincroni (cio&egrave; pi&ugrave; veloci
          che con il <emphasis>logging</emphasis>, che deve scrivere i meta-dati
          due volte).  Gli svantaggi sono nella complessit&agrave; del codice
          (che implica un maggiore rischio di trovare bug in un'area molto
          sensibile, essendo legata alla perdita dei dati degli utenti),
          ed un consumo di memoria maggiore.  Inoltre ci sono alcune
          idiosincrasie alle quali ci si deve abituare.
          Dopo un crash, lo stato del file system appare in qualche modo
          <quote>vecchio</quote>.  In situazioni dove l'approccio
          sincrono avrebbe causato la permanenza di alcuni file di lunghezza
          zero dopo un <command>fsck</command>, questi file non esistono affatto
          con un file system con Soft Update, perch&egrave; n&egrave; i
          meta-dati n&egrave; i contenuti dei file sono mai stati scritti su
          disco.  Lo spazio su disco non viene rilasciato finch&egrave; gli
          aggiornamenti non sono stati scritti su disco, il che pu&ograve;
          avvenire qualche tempo dopo che &egrave; stato eseguito
          <command>rm</command>.  Questo potrebbe causare problemi durante
          l'installazione di grandi quantit&agrave; di dati su un file system
          che non avesse abbastanza spazio per contenere tutti i file due
          volte.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="configtuning-kernel-limits">
    <title>Messa a Punto dei Limiti del Kernel</title>

    <indexterm>
      <primary>messa a punto</primary>
      <secondary>limiti del kernel </secondary>
    </indexterm>

    <sect2 id="file-process-limits">
      <title>Limiti dei File/Processi</title>

      <sect3 id="kern-maxfiles">
        <title><varname>kern.maxfiles</varname></title>

        <indexterm>
          <primary><varname>kern.maxfiles</varname></primary>
        </indexterm>

        <para><varname>kern.maxfiles</varname> pu&ograve; essere aumentato o
          abbassato a seconda dei requisiti del tuo sistema.  Questa variabile
          indica il numero massimo di descrittori di file sul tuo sistema.
          Quando la tabella dei descrittori di file &egrave; piena,
          apparir&agrave; ripetutamente la scritta <errorname>file: table is
            full</errorname> nel buffer dei messaggi di sistema, che pu&ograve;
          essere visualizzato con il comando <command>dmesg</command>.</para>

        <para>Ogni file, socket, o fifo aperta usa un descrittore di file.
          Un server di produzione di larga scala pu&ograve; richiedere
          facilmente molte migliaia di descrittori di file, in relazione al tipo
          e al numero di servizi in esecuzione insieme.</para>

        <para>Nelle vecchie release di &os;, il valore predefinito
          di <varname>kern.maxfile</varname> viene
          dettato dall'opzione <option>maxusers</option> nel file di
          configurazione del kernel.  <varname>kern.maxfiles</varname> cresce
          proporzionalmente al valore di <option>maxusers</option>.  Quando si
          compila un kernel personalizzato, &egrave; una buona idea impostare
          questa opzione di configurazione del kernel in base agli usi del
          proprio sistema.  Da questo numero, dipendono molti dei limiti
          predefiniti del kernel.  Anche se una macchina in produzione potrebbe
          non avere effettivamente 256 utenti connessi contemporaneamente, le
          risorse necessarie potrebbero essere simili a quelle di un server web
          su larga scala.</para>

        <para>A partire da FreeBSD 4.5, <varname>kern.maxusers</varname>
          &egrave; automaticamente dimensionato sulla base della memoria
          disponibile nel sistema, e pu&ograve; essere determinato a run-time
          leggendo il valore del sysctl read-only <varname>kern.maxusers</varname>.
          Alcuni siti richiedono valori minori o maggiori di <varname>kern.maxusers</varname>
          e questo pu&ograve; essere impostato come un parametro modificabile
          dal loader; valori di 64, 128 o 256 non sono fuori dal comune.
          Non raccomandiamo di andare oltre i 256 a meno che non si necessiti
          di un numero esagerato di file descriptor; molti dei valori modificati
          nel loro default da <varname>kern.maxusers</varname> possono essere
          singolarmente sovrascritti a boot-time o a run-time in
          <filename>/boot/loader.conf</filename> (leggi la pagina di manuale
          &man.loader.conf.5; o il file <filename>/boot/defaults/loader.conf</filename>
          per alcuni suggerimenti) o come descritto altrove in questo documento.
          Sistemi precedenti a FreeBSD&nbsp;4.4 devono invece impostare questo valore
          attraverso l'opzione di &man.config.8; <option>maxusers</option>.</para>

        <para>Nelle release precedenti, il sistema setter&agrave;
          in modo automatico <literal>maxusers</literal> se lo imposti a
          <literal>0</literal><footnote>
          <para>L'algoritmo di impostazione automatica setta
          <literal>maxusers</literal> pari alla quantit&agrave; della
          memoria del sistema, con un minimo di 32, fino a un massimo
          di 384.</para></footnote>.
          Quando usi quest'opzione, impostalo
          almeno a 4, specialmente se stai usando il sistema a finestre X o se
          compili software.  Questo &egrave; dovuto al fatto che la tabella
          pi&ugrave; importante settata da <literal>maxusers</literal> &egrave;
          quella relativa al numero massimo di processi, risultato di
          <literal>20 + 16 * maxusers</literal>, e quindi se setti
          <literal>maxusers</literal> a 1, puoi avere solo 36 processi in modo
          simultaneo, inclusi i 18 o pi&ugrave; di avvio del sistema e i 15
          o pi&ugrave; che verranno creati all'avvio del sistema a finestre X.
          Perfino una semplice attivit&agrave; come la lettura di una pagina
          man avvia fino a 9 processi per filtrare, decomprimere, e visualizzare
          la pagina.  Settando <literal>maxusers</literal> a 64 avrai fino a
          1044 processi simultanei, che dovrebbero essere sufficienti per quasi
          tutti gli utenti.  Ad ogni modo, se vedi il temuto errore
          <errortype>proc table full</errortype> quando tenti di avviare
          un programma, o se stai usando un server con molti utenti simultanei
          (come <hostid role="fqdn">ftp.FreeBSD.org</hostid>), puoi sempre
          incrementare il numero e ricompilare.</para>

        <note>
          <para><literal>maxusers</literal> <emphasis>non</emphasis>
            limita il numero degli utenti che possono loggarsi sulla tua
            macchina.  Semplicemente setta la dimensione di alcune tabelle
            a un valore ragionevole considerando il numero massimo di
            utenti che probabilmente avrai sul tuo sistema e quanti
            processi ognuno di loro avranno in esecuzione.  Un'opzione
            che limita il numero di login remoti simultanei e di terminali
            windows &egrave; <link
              linkend="kernelconfig-ptys"><literal>pseudo-device pty
              16</literal></link>.  Con &os;&nbsp;5.X, non ti devi
            preoccupare di questo numero poich&egrave; il driver
            &man.pty.4; &egrave; <quote>auto-cloning</quote>; semplicemente
            usa la linea <literal>device pty</literal> nel tuo file di
            configurazione.</para>
        </note>
      </sect3>

      <sect3>
        <title><varname>kern.ipc.somaxconn</varname></title>

        <indexterm>
          <primary><varname>kern.ipc.somaxconn</varname></primary>
        </indexterm>

        <para>La variabile sysctl <varname>kern.ipc.somaxconn</varname>
          limita la dimensione della coda in ascolto per le connessioni TCP.
          Il valore predefinito &egrave; di <literal>128</literal>,
          generalmente troppo basso per una gestione robusta di nuove
          connessioni in ambienti come i web server molto carichi.  Per tali
          ambienti, &egrave; consigliato aumentare questo valore a
          <literal>1024</literal> o maggiore.  Il demone di servizio pu&ograve;
          a sua volta limitare la dimensione della coda (e.g. &man.sendmail.8;,
          o <application>Apache</application>) ma spesso avr&agrave; una
          direttiva nel proprio file di configurazione per correggere la
          dimensione della coda.  Grosse code di ascolto aiutano anche ad
          evitare attacchi di tipo Denial of Service
          (<abbrev>DoS</abbrev>).</para>
      </sect3>
    </sect2>

    <sect2 id="nmbclusters">
      <title>Limiti di Rete</title>

      <para>L'opzione di configurazione del kernel <option>NMBCLUSTERS</option>
        decide la quantit&agrave; di Mbuf di rete disponibili al sistema.
        Un server molto trafficato con un numero basso di Mbuf
        ostacolerebbe le possibilit&agrave; di &os;.  Ogni cluster
        rappresenta approssimativamente 2&nbsp;K di memoria, dunque un valore di
        1024 rappresenta 2 megabyte di memoria del kernel riservata per i
        buffer di rete.
        Pu&ograve; essere effettuato un semplice calcolo per capire
        quanti ne siano necessari.  Se hai un web server che arriva al massimo
        a 1000 connessioni simultanee, ed ogni connessione consuma un buffer di
        16&nbsp;K in ricezione e un altro di 16&nbsp;K in trasmissione, avrai
        bisogno approssimativamente di 32&nbsp;MB di buffer di rete per coprire
        il web server.
        Una buona regola generale &egrave; di moltiplicare per 2, dunque
        2x32&nbsp;MB&nbsp;/&nbsp;2&nbsp;KB&nbsp;=
        64&nbsp;MB&nbsp;/&nbsp;2&nbsp;KB&nbsp;= 32768.
        Consigliamo valori compresi  tra
        4096 e 32768 per macchine con grandi quantit&agrave; di memoria.
        In nessun caso dovreste specificare un valore alto arbitrario
        per questo parametro, poich&egrave; potrebbe portare ad un crash
        all'avvio.  L'opzione <option>-m</option> di
        &man.netstat.1; pu&ograve; essere usata per osservare l'uso della
        rete.</para>

      <para>L'opzione del loader
        <varname>kern.ipc.nmbclusters</varname> pu&ograve; essere usata per
        impostare questi valori all'avvio.  Solo versioni vecchie di &os;
        richiedono l'uso dell'opzione <option>NMBCLUSTERS</option> come
        configurazione del kernel (&man.config.8;).</para>

      <para>Per server sotto carico che fanno un uso massiccio della chiamata
        di sistema &man.sendfile.2;, potrebbe essere necessario
        aumentare il numero di buffer &man.sendfile.2; tramite l'opzione di
        configurazione del kernel <option>NSFBUFS</option> o impostando il suo
        valore in <filename>/boot/loader.conf</filename>
        (vedere &man.loader.8; per maggiori dettagli).  Un indicatore comune
        che questo parametro deve essere corretto &egrave; la comparsa di
        processi nello stato <errorname>sfbufa</errorname>.  La variabile sysctl
        <varname>kern.ipc.nsfbufs</varname> &egrave; solo un riferimento
        read-only alla variabile configurata nel kernel.  Questo parametro
        aumenta nominalmente con <varname>kern.maxusers</varname>,
        in ogni caso potrebbe essere necessario effettuare piccole correzioni
        per farli concordare.</para>

      <important>
        <para>Anche se un socket &egrave; stato segnalato come non-bloccante,
          richiamando &man.sendfile.2; su di esso si potrebbe avere un blocco
          della chiamata &man.sendfile.2; fino a quando non sono disponibili
          delle <literal>struct sf_buf</literal>.</para>
      </important>

      <sect3>
        <title><varname>net.inet.ip.portrange.*</varname></title>

        <indexterm><primary>net.inet.ip.portrange.*</primary></indexterm>

        <para>La variabili sysctl <varname>net.inet.ip.portrange.*</varname>
          controllano i numeri di porta automaticamente assegnate a socket TCP
          ed UDP.  Ci sono tre intervalli: uno basso, uno predefinito,
          ed uno alto.  La maggior parte dei programmi usa l'intervallo
          predefinito che &egrave; controllato da
          <varname>net.inet.ip.portrange.first</varname> e
          <varname>net.inet.ip.portrange.last</varname>, che hanno valori
          predefiniti di 1024 e 5000.  Questi intervalli sono usati per le
          connessioni in uscita, ed &egrave; possibile che il sistema esaurisca
          le porte in alcune circostanze.  Ci&ograve; accade per lo pi&ugrave;
          quando avete un web proxy molto carico.  L'intervallo di porte
          non &egrave; un problema quando si usano server che abbiano
          per lo pi&ugrave; connessioni in ingresso, come i normali
          web server, o un numero limitato di connessioni in
          uscita, come i relay di posta.  Per situazioni
          nelle quali potreste terminare le porte, &egrave; consigliato
          aumentare leggermente <varname>net.inet.ip.portrange.last</varname>.
          Un valore di <literal>10000</literal>, <literal>20000</literal> o
          <literal>30000</literal> pu&ograve; essere ragionevole.
          Dovreste anche considerare gli effetti relativi ad un firewall
          nel cambiare il range di porte.  Alcuni
          firewall potrebbero bloccare grandi intervalli di porte (tipicamente
          le porte basse) ed aspettarsi che i sistemi usino porte pi&ugrave;
          alte per le connessioni in uscita &mdash; per questa ragione si
          consiglia di non abbassare il valore di
          <varname>net.inet.ip.portrange.first</varname>.</para>
      </sect3>

      <sect3>
        <title>Prodotto del Ritardo di Banda TCP</title>

        <indexterm>
          <primary>limite del Prodotto del Ritardo di Banda TCP</primary>
          <secondary><varname>net.inet.tcp.inflight.enable</varname></secondary>
        </indexterm>

        <para>Il limite del Prodotto del Ritardo di Banda TCP &egrave; simile a
          TCP/Vegas in NetBSD.  Pu&ograve;
          essere abilitato impostando la variabile sysctl
          <varname>net.inet.tcp.inflight_enable</varname>
          ad <literal>1</literal>.  Il sistema tenter&agrave; di
          calcolare il prodotto del ritardo di banda per ogni connessione
          e limiter&agrave; l'ammontare di dati accodati per la trasmissione su
          rete al livello migliore per garantire il massimo throughput.</para>

        <para>Questa funzionalit&agrave; &egrave; utile quando si inviano dati
          su modem multipli, su Ethernet Gigabit, o su collegamenti WAN ad alta
          velocit&agrave; (o qualsiasi altro  collegamento con un alto prodotto
          a banda di ritardo), in particolar modo se state usando anche il
          window scaling o se avete configurato una finestra TCP molto ampia.
          Se abilitate questa opzione, dovreste anche assicurarvi di impostare
          a <literal>0</literal> <varname>net.inet.tcp.inflight_debug</varname>
          (per disabilitare il debugging), e per un uso di produzione
          pu&ograve; essere utile impostare
          <varname>net.inet.tcp.inflight_min</varname> ad almeno
          <literal>6144</literal>.  Notate comunque che
          impostando dei livelli minimi alti pu&ograve; in pratica disabilitare
          la limitazione di banda, su alcuni tipi di collegamento.
          La funzionalit&agrave; di limitazione della banda riduce la
          quantit&agrave; di dati creati in rotte intermedie
          e fa circolare le code di pacchetti cos&igrave; come riduce la
          quantit&agrave; di dati creati nella coda di interfaccia dell'host
          locale.  Con meno pacchetti accodati, le connessioni interattive,
          specialmente sopra modem lenti, opereranno con lenti
          <emphasis>Round Trip Times</emphasis> (tempi di andata e ritorno).
          Comunque, nota che questa feature ha effetto solo sulla trasmissione
          dati (uploading / lato server).  Non ha effetto sulla ricezione
          (downloading).</para>

        <para>Modificare <varname>net.inet.tcp.inflight.stab</varname> non
          &egrave; raccomandato.
          Questo parametro &egrave; di default a 20, rappresentando
          2 pacchetti massimi aggiunti al ritardo del prodotto della banda
          della finestra.  La finestra addizionale &egrave; richiesta per
          stabilizzare l'algoritmo e migliorare la risposta alle condizioni che
          cambiano ma pu&ograve; risultare in tempi lunghi sui ping
          sopra link lenti (anche se molto pi&ugrave; lento di quello che
          otterresti senza l'algoritmo di inflight).  In questi casi, puoi voler
          ridurre questo parametro a 15, 10 o 5; e puoi anche ridurre
          <varname>net.inet.tcp.inflight.min</varname> (per esempio, a 3500)
          per ottenere l'effetto desiderato.  Ridurre questi parametri
          dovrebbe essere fatto solo come ultima spiaggia.</para>

      </sect3>
    </sect2>

    <sect2>
      <title>Memoria Virtuale</title>

      <sect3>
        <title><varname>kern.maxvnodes</varname></title>

        <para>Un vnode &egrave; la rappresentazione di un file o una directory.
          Aumentare il numero di vnodi disponibili sul sistema
          operativo aumenter&agrave; l'I/O di disco.  Normalmente questo viene
          gestito dal sistema operativo e non deve essere cambiato.
          In pochi casi dove l'I/O di disco
          &egrave; un collo di bottiglia ed il sistema sta finendo i suoi vnodi,
          questo parametro sar&agrave; aumentato.  L'aumento di RAM libera ed
          inattiva sar&agrave; tenuto in conto.</para>

        <para>Per vedere il numero corrente di vnodi in uso:</para>

        <screen>&prompt.root; <userinput>sysctl vfs.numvnodes</userinput>
vfs.numvnodes: 91349</screen>

        <para>Per vedere il numero massimo di vnodi:</para>

        <screen>&prompt.root; <userinput>sysctl kern.maxvnodes</userinput>
kern.maxvnodes: 100000</screen>

        <para>Se l'uso del nodo corrente &egrave; vicino alla fine,
          aumentare <varname>kern.maxvnodes</varname> di un valore di 1.000
          &egrave; probabilmente una buona idea.  Tenete un occhio sul numero
          di <varname>vfs.numvnodes</varname>.  Se scala al massimo,
          <varname>kern.maxvnodes</varname> dovr&agrave; essere incrementato
          ancora.  Dovrebbe essere visibile con &man.top.1;
          uno spostamento nell'uso della memoria.  Molta memoria dovrebbe essere
          attiva.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="adding-swap-space">
    <title>Aggiunta di Spazio di Swap</title>

    <para>Non importa con quanta cura pianifichi tutto, a volte un sistema non
      funziona come ti aspetti.  Se ti trovi ad avere bisogno di maggiore spazio
      di swap, &egrave; abbastanza semplice aggiungerlo.  Ci sono tre modi per
      aumentare lo spazio di swap: aggiungere un nuovo disco rigido, abilitare
      lo swap su NFS, e creare un file di swap su una partizione
      esistente.</para>

    <para>Per informazioni su come criptare lo spazio di swap, quali opzioni
      esistono e perch&egrave; dovrebbe essere fatto, vedere la
      sezione swap-encrypting del Manuale.</para>

    <sect2 id="new-drive-swap">
      <title>Swap su un Nuovo Disco Rigido</title>

      <para>Il modo migliore per aggiungere dello swap, ovviamente, &egrave;
        usare questa come scusa per aggiungere un altro disco rigido.  Puoi
        sempre aggiungere un nuovo disco, dopo tutto.  Se puoi fare cos&igrave;,
        vai a rileggere la discussione sullo spazio di swap nella <xref
          linkend="configtuning-initial"> del
        Manuale per alcuni suggerimenti su come organizzare al meglio lo spazio
        di swap.</para>
    </sect2>

    <sect2 id="nfs-swap">
      <title>Swap su NFS</title>

      <para>Lo swap su NFS &egrave; consigliato solo se non hai un disco locale
        su cui realizzare lo swap.  Lo swap via
        NFS &egrave; limitato dalla larghezza di banda disponibile sulla rete e
        aggiunge ulteriore lavoro per il server NFS.</para>
    </sect2>

    <sect2 id="create-swapfile">
      <title>File di Swap</title>

      <para>Puoi creare un file delle dimensioni specifiche per usarlo come file
        di swap.  In questo nostro esempio useremo un file di 64MB chiamato
        <filename>/usr/swap0</filename>.  Puoi usare qualsiasi nome vuoi,
        ovviamente.</para>

      <example>
        <title>Creare un file di Swap su &os;</title>

        <orderedlist>
          <listitem><para>Accertati che il tuo file di configurazione
            del kernel includa il memory disk driver (&man.md.4;).
            &Egrave; di default nel kernel <filename>GENERIC</filename>.</para>

          <programlisting>device   md   # Memory "disks"</programlisting>
          </listitem>

          <listitem><para>Crea un file di swap
            (<filename>/usr/swap0</filename>):</para>

            <screen>&prompt.root; <userinput>dd if=/dev/zero of=/usr/swap0 bs=1024k count=64</userinput></screen>
          </listitem>

          <listitem>
            <para>Imposta i permessi appropriati su
              (<filename>/usr/swap0</filename>):</para>

            <screen>&prompt.root; <userinput>chmod 0600 /usr/swap0</userinput></screen>
          </listitem>

          <listitem>
            <para>Riavvia la macchina o per abilitare il file di swap immediatamente
              scrivi:</para>

            <screen>&prompt.root; <userinput>mdconfig -a -t vnode -f /usr/swap0 -u 0 &amp;&amp; swapon /dev/md0</userinput></screen>
          </listitem>
        </orderedlist>
      </example>
    </sect2>
  </sect1>

  <sect1 id="acpi-overview">
    <sect1info>
      <authorgroup>
         <author>
           <firstname>Hiten</firstname>

           <surname>Pandya</surname>

           <contrib>Scritto da </contrib>
         </author>

         <author>
           <firstname>Tom</firstname>

           <surname>Rhodes</surname>
         </author>
      </authorgroup>
    </sect1info>

    <title>Gestione dell'Energia e delle Risorse</title>

    <para>&Egrave; importante utilizzare le risorse hardware
      in maniera efficiente.  Prima che <acronym>ACPI</acronym>
      fosse introdotto era difficile e per nulla flessibile per il
      sistema operativo gestire l'energia e le propriet&agrave;
      termiche del sistema.  L'hardware era controllato dal
      <acronym>BIOS</acronym> e quindi l'utente aveva meno controllo
      e visibilit&agrave; per il settaggio della gestione dell'energia.
      Una configurazione limitata era disponibile tramite
      <emphasis>Advanced Power Management (APM)</emphasis>.
      La gestione dell'energia e delle risorse &egrave; uno dei concetti
      fondamentali di un moderno sistema operativo.  Per esempio, puoi
      far s&igrave; che un sistema operativo faccia il monitoraggio dei limiti
      di sistema (e possibilmente ti avvisi) in caso la temperatura del sistema
      cresca in maniera incontrollata.</para>

    <para>In questa sezione del Manuale di &os;, ti forniremo informazioni
      esaustive circa <acronym>ACPI</acronym>.  Alla fine saranno forniti
      maggiori riferimenti per ulteriori letture.</para>

    <sect2 id="acpi-intro">
      <title>Cos'&egrave; ACPI?</title>

      <indexterm>
        <primary>ACPI</primary>
      </indexterm>
      <indexterm>
        <primary>APM</primary>
      </indexterm>

      <para><acronym>ACPI</acronym> (Advanced Configuration and Power Interface)
        &egrave; uno standard scritto da un gruppo di venditori per fornire
        un'interfaccia standard per risorse hardware e gestione
        dell'energia (da qui il nome).  &Egrave; un elemento
        centrale nella <emphasis>configurazione diretta del sistema
          operativo e nella gestione dell'energia</emphasis>, ad esempio:
        fornisce pi&ugrave; controllo e flessibilit&agrave;
        al sistema operativo (<acronym>OS</acronym>).
        I sistemi moderni <quote>stressano</quote> i limiti
        delle interfacce correnti Plug and Play,
        prima della introduzione
        di <acronym>ACPI</acronym>.  <acronym>ACPI</acronym> &egrave;
        il diretto successore di <acronym>APM</acronym> (Advanced
        Power Management).</para>
    </sect2>

    <sect2 id="acpi-old-spec">
      <title>Riassunto della Gestione Avanzata dell'Energia (APM)</title>

      <para>La tecnologia <emphasis>Advanced Power Management (APM)</emphasis>
        controlla l'uso dell'energia di un sistema basandosi sulla sua
        attivit&agrave;.  Il BIOS APM &egrave; fornito dal venditore del sistema
        ed &egrave; specifico alla piattaforma hardware.  Un driver APM nell'OS
        media l'accesso all'<emphasis>Interfaccia Software APM</emphasis> che
        permette la gestione dei livelli di energia.  APM dovrebbe essere
        usato per sistemi prodotti nel o prima dell'anno 2000.</para>

      <para>Ci sono quattro problemi maggiori in APM.  Primo,
        la gestione dell'energia &egrave; fatta dal BIOS (specifico
        del venditore) e l'OS non ne ha conoscenza.  Un esempio
        di questo &egrave; quando l'utente imposta i valori di pausa
        per un disco nell'APM BIOS, che quando vengono ecceduti, il BIOS
        rallenta il disco, senza il consenso dell'OS.  Secondo, la logica
        di APM &egrave; integrata nel BIOS, e opera al di fuori lo scopo
        dell'OS.  Questo significa
        che gli utenti possono riparare  i problemi nel loro BIOS APM
        facendo un flash di una nuova memoria nel ROM; il che &egrave;
        una procedura molto difficile con il pericolo potenziale
        di lasciare il sistema in uno stato irrecuperabile se fallisce.
        Terzo, APM &egrave; una tecnologia specifica del venditore
        il che significa che c'&egrave; un sacco di duplicazione degli
        sforzi e bachi trovati nel BIOS di un venditore
        che non possono essere risolti in altri.  In ultima analisi,
        il BIOS APM non ha abbastanza spazio per implementare una politica
        sofisticata, o una che pu&ograve; adattarsi molto bene
        allo scopo della macchina.</para>

      <para><emphasis>Plug and Play BIOS (PNPBIOS)</emphasis> era inaffidabile
        in molte situazioni.  PNPBIOS era una tecnologia a 16 bit, cos&igrave;
        il sistema operativo doveva usare l'emulazione a 16 bit per
        <quote>interfacciarsi</quote> con i metodi PNPBIOS.</para>

      <para>Il driver <acronym>APM</acronym> di &os; &egrave; documentato
        nella pagina di manuale &man.apm.4;.</para>
    </sect2>

    <sect2 id="acpi-config">
      <title>Configurare <acronym>ACPI</acronym></title>

      <para>Il driver <filename>acpi.ko</filename> &egrave; caricato
        di default all'avvio dal &man.loader.8; e
        <emphasis>non</emphasis> dovrebbe essere compilato nel kernel.
        Il ragionamento dietro a questo &egrave; che &egrave; pi&ugrave;
        facile lavorare coi moduli, ad esempio se si passa ad un altro
        <filename>acpi.ko</filename> senza fare un rebuild del kernel.
        Questo ha il vantaggio di rendere il testing pi&ugrave; facile.
        Un altro motivo &egrave; che avviare <acronym>ACPI</acronym>
        dopo che un sistema &egrave; stato riavviato spesso non funziona
        bene.  Se incontri dei problemi, puoi disabilitare completamente
        <acronym>ACPI</acronym>.  Questo driver non dovrebbe e non
        pu&ograve; essere scaricato perch&egrave; il bus di sistema
        lo usa per diverse interazioni hardware.
        <acronym>ACPI</acronym> pu&ograve; essere disabilitato
        settando <literal>hint.acpi.0.disabled="1"</literal> in
        <filename>/boot/loader.conf</filename> o al prompt del
        &man.loader.8;.</para>

      <note>
        <para><acronym>ACPI</acronym> ed <acronym>APM</acronym> non
          possono coesistere e dovrebbero essere usati separatamente.
          L'ultimo ad essere caricato terminer&agrave; se il driver nota che
          l'altro &egrave; gi&agrave; in funzione.</para>
      </note>

      <para><acronym>ACPI</acronym> pu&ograve; essere usato per
        mettere il sistema in modalit&agrave;
        sleep con &man.acpiconf.8;, l'opzione <option>-s</option> ed un'opzione
        <option>1-5</option>.  La maggior parte degli utenti avranno bisogno
        solo di <literal>1</literal> o <literal>3</literal> (sospensione della
        RAM).  L'opzione <literal>5</literal>
        far&agrave; un morbido shutdown che &egrave; la stessa azione
        di:</para>

      <screen>&prompt.root; <userinput>halt -p</userinput></screen>

      <para>Sono disponibili altre opzioni via &man.sysctl.8;.
        Controlla la pagina man di &man.acpi.4; e &man.acpiconf.8;
        per maggiori informazioni.</para>
    </sect2>
  </sect1>

  <sect1 id="ACPI-debug">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Nate</firstname>

          <surname>Lawson</surname>

          <contrib>Scritto da </contrib>
        </author>
      </authorgroup>

      <authorgroup>
        <author>
          <firstname>Peter</firstname>

          <surname>Schultz</surname>

          <contrib>Contributo di </contrib>
        </author>

        <author>
          <firstname>Tom</firstname>

          <surname>Rhodes</surname>
        </author>
      </authorgroup>
    </sect1info>

    <title>Usare e Debuggare <acronym>ACPI</acronym> di &os;</title>

    <indexterm>
      <primary>ACPI</primary>
      <secondary>problemi</secondary>
    </indexterm>

    <para><acronym>ACPI</acronym> &egrave; un modo fondamentalmente
      nuovo di utilizzare dispositivi, gestire le risorse elettriche,
      e fornire accesso standardizzato all'hardware gestito
      precedentemente dal <acronym>BIOS</acronym>.  Si stanno facendo
      progressi per far funzionare <acronym>ACPI</acronym> su tutti i
      sistemi, ma continuano ad apparire bachi nel codice
      del <firstterm>Linguaggio Macchina <acronym>ACPI</acronym></firstterm>
      (<acronym>AML</acronym>), incompletezza
      nel sottosistema kernel di &os;, e bachi nell'interprete
      <acronym>ACPI-CA</acronym> di &intel;.</para>

    <para>Questo documento &egrave; creato per aiutarti ad assistere
      i manutentori di <acronym>ACPI</acronym> di &os; nell'identificare
      le cause primarie dei problemi che riscontri e debuggare e sviluppare
      una soluzione.  Grazie per l'attenzione e speriamo di poter
      risolvere i problemi del tuo sistema.</para>

    <sect2 id="ACPI-submitdebug">
      <title>Fornire Informazione di Debug</title>

      <note>
        <para>Prima di sottomettere un problema, accertati di
          avere in esecuzione l'ultima versione del
          <acronym>BIOS</acronym> e, se disponibile,
          la versione del firmware del controller integrato.</para>
      </note>

      <para>Per quelli di voi che vogliono sottomettere un problema
        subito, per favore inviate la seguente informazione a
        <ulink url="mailto:freebsd-acpi@FreeBSD.org">
          freebsd-acpi@FreeBSD.org</ulink>:</para>

      <itemizedlist>
        <listitem>
          <para>Descrizione del comportamento affetto da bachi, inclusi
            il tipo di sistema ed il modello e tutto quello che fa
            s&igrave; che il baco appaia.  Inoltre, per favore
            annotati il pi&ugrave; accuratamente possibile quando
            il baco &egrave; iniziato ad apparire se &egrave; nuovo per
            il tuo sistema.</para>

        <listitem>
          <para>L'output del comando &man.dmesg.8; dopo
            <command>boot -v</command>, incluso ogni messaggio di errore
            generato dal tuo sistema mentre investigavi questo baco.</para>
        </listitem>

        <listitem>
          <para>L'output del comando &man.dmesg.8; dopo
            <command>boot -v</command> con <acronym>ACPI</acronym>
            disabilitato, se disabitarlo ti aiuta a rimettere
            a posto il sistema.</para>
        </listitem>

        <listitem>
          <para>L'output di <command>sysctl hw.acpi</command>.
            Anche questo &egrave; un buon modo di figurarti
            quali caratteristiche il tuo sistema offre.</para>
        </listitem>

        <listitem>
          <para><acronym>URL</acronym> dove il tuo
            <firstterm><acronym>ACPI</acronym> Source Language</firstterm>
            (<acronym>ASL</acronym>) risiede.  <emphasis>Non</emphasis>
            inviare la <acronym>ASL</acronym> direttamente
            alla lista dato che pu&ograve; essere molto grande.  Generate
            una copia della vostra <acronym>ASL</acronym> eseguendo
            questo comando:</para>

          <screen>&prompt.root; <userinput>acpidump -dt &gt; <replaceable>name</replaceable>-<replaceable>system</replaceable>.asl</userinput></screen>

          <para>(Sostituite <replaceable>name</replaceable>
            con la vostra login ed il modello/manifattura
            del <replaceable>sistema</replaceable>.  Ad esempio
            <filename>njl-FooCoo6000.asl</filename>)</para>
        </listitem>
      </itemizedlist>

      <para>Molti degli sviluppatori seguono la &a.current; ma per favore
        sottomettete i vostri problemi a &a.acpi.name; per essere sicuri
        che siano visti.  Per favore siate pazienti, abbiamo tutti
        lavori full-time altrove.  Se i vostri bachi non sono
        chiarissimi, vi chiederemo di sottomettere un <acronym>PR</acronym>
        attraverso &man.send-pr.1;.  Quando si invia
        un <acronym>PR</acronym>, per favore includete le stesse informazioni
        sopracitate.  Questo aiuter&agrave; a tracciare il problema e
        risolverlo.
        Non inviare un <acronym>PR</acronym> senza prima inviare una email
        a &a.acpi.name;, dato che noi usiamo <acronym>PR</acronym>
        come promemoria di problemi esistenti, non come meccanismo
        di reporting.  &Egrave; probabile che i vostri problemi siano
        stati riportati da qualcun altro prima.</para>
    </sect2>

    <sect2 id="ACPI-background">
      <title>Background</title>

      <indexterm>
        <primary>ACPI</primary>
      </indexterm>

      <para><acronym>ACPI</acronym> &egrave; presente su tutti i computer
        moderni che conformi all'architettura ia32(x86),
        ia64 (Itanium), e amd64 (AMD).  L'intero standard ha molte
        caratteristiche che includono la gestione della
        performance della <acronym>CPU</acronym>, il controllo dei piani
        energetici, delle zone termiche, delle batterie del sistema, controller
        incorporati, ed enumerazione dei bus.  Molti sistemi implementano
        meno dello standard completo.  Per esempio, un sistema desktop
        di solito implementa le parti di enumerazione dei bus mentre
        un laptop potrebbe avere il raffreddamento ed anche il supporto
        alla gestione della batteria.  I laptop hanno anche
        sospensioni e riavvii, con la loro complessit&agrave;
        associata.</para>

      <para>Un sistema <acronym>ACPI</acronym>-compliant ha molte
        componenti.  Il <acronym>BIOS</acronym> ed i venditori
        di chipset forniscono varie tabelle fisse in memoria
        (ad esempio <acronym>FADT</acronym>) che specificano cose
        come la mappa <acronym>APIC</acronym> (usata per
        <acronym>SMP</acronym>), i registri di configurazione, e semplici
        valori di configurazione.  Inoltre viene fornita una tabella
        di codici di byte
        (la <firstterm>Differentiated System Description Table</firstterm>
        <acronym>DSDT</acronym>)
        per specificare uno spazio dei nomi ad albero
        di dispositivi e metodi.</para>

     <para>Il driver <acronym>ACPI</acronym> deve fare il
       parse delle tabelle fisse, implementare un interprete
       per il codice di byte, e modificare i device driver ed
       il kernel per accettare informazioni dal sottosistema
       <acronym>ACPI</acronym>.  Per &os;, &intel; ha fornito
       un interprete (<acronym>ACPI-CA</acronym>) che &egrave;
       condiviso fra Linux e NetBSD.  Il path al codice
       sorgente <acronym>ACPI-CA</acronym> &egrave;
       <filename class="directory">src/sys/contrib/dev/acpica</filename>.
       Il codice che permette ad <acronym>ACPI-CA</acronym> di lavorare
       con &os; &egrave; in <filename>src/sys/dev/acpica/Osd</filename>.
       Finalmente, i driver che implementano vari dispositivi
       <acronym>ACPI</acronym> si trovano in
       <filename class="directory">src/sys/dev/acpica</filename>.</para>
    </sect2>

    <sect2 id="ACPI-comprob">
      <title>Problemi Comuni</title>

      <indexterm>
        <primary>ACPI</primary>
        <secondary>problemi</secondary>
      </indexterm>

      <para>Affinc&egrave; <acronym>ACPI</acronym> funzioni
        correttamente tutte le parti devono funzionare correttamente.
        Ci sono alcuni problemi comuni, in ordine di frequenza
        di apparizione, ed alcuni possibili workaround o mezzi
        per aggiustarli.</para>

      <sect3>
        <title>Questioni di Mouse</title>

        <para>In alcuni casi, ripartire dopo una operazione di
          sospensione, fa s&igrave; che il mouse non riparta.
          Un noto workaround &egrave; aggiungere
          <literal>hint.psm.0.flags="0x3000"</literal>
          al file <filename>/boot/loader.conf</filename>.
          Se questo non funziona allora per favore considera
          l'invio di un report del baco come descritto
          in precedenza.</para>
      </sect3>

      <sect3>
        <title>Sospensione/Riavvio</title>

        <para><acronym>ACPI</acronym> ha tre stati di sospensione
          <acronym>RAM</acronym> (<acronym>STR</acronym>),
          <literal>S1</literal>-<literal>S3</literal> ed un
          stato di sospensione disco (<literal>STD</literal>),
          chiamato <literal>S4</literal>.  <literal>S5</literal>
          &egrave; il <quote>soft off</quote> ed &egrave;
          il normale stato in cui il tuo sistema
          si trova quando &egrave; collegato ma non acceso.
          <literal>S4</literal> pu&ograve; essere implementato
          in due modi separati.  <literal>S4</literal>
          <acronym>BIOS</acronym> &egrave; una
          sospensione <acronym>BIOS</acronym>-assistita
          da disco.  <literal>S4</literal><acronym>OS</acronym>
          &egrave; implementato direttamente
          dal sistema operativo.</para>

        <para>Inizia a controllare
          <command>sysctl hw.acpi</command> per
          le entry relative alla sospensione.
          Questi sono i risultati per un Thinkpad:</para>

        <screen>hw.acpi.supported_sleep_state: S3 S4 S5
hw.acpi.s4bios: 0</screen>

        <para>Questo significa che possiamo usare
          <command>acpiconf -s</command> per testare
          <literal>S3</literal>, <literal>S4</literal><acronym>OS</acronym>,
          <literal>S5</literal>.  Se <option>s4bios</option>
          fosse stato uno (<literal>1</literal>), avremmo supporto a
          <literal>S4</literal><acronym>BIOS</acronym>
          invece di <literal>S4</literal><acronym>OS</acronym>.</para>

       <para>Quando si testa la sospensione/riavvio, inizia con
         <literal>S1</literal>, se supportato.
         &Egrave; pi&ugrave; probabile che funzioni questo stato
         dato che non richiede molto supporto dal driver.
         Nessuno ha implementato <literal>S2</literal>,
         ma se tu lo hai, &egrave; simile a <literal>S1</literal>.
         La prossima cosa da provare &egrave; <literal>S3</literal>.
         Questo &egrave; lo stato pi&ugrave; profondo
         <acronym>STR</acronym> e richiede molto supporto
         dal driver per reinizializzare il tuo hardware.
         Se hai problemi a riavviarlo, sentiti libero
         di segnalarlo  via mail alla lista &a.acpi.name; ma non
         aspettarti che il problema sia risolto dato che ci
         sono molti driver/hardware che hanno bisogno
         di test e di lavoro aggiuntivo.</para>

       <para>Per aiutare ad isolare il problema, rimuovi quanti
         pi&ugrave; driver possibile dal tuo kernel.  Se funziona,
         puoi scoprire quale driver causa il problema
         caricando dei driver fino a che il problema si
         ripresenta.  Tipicamente i driver binari come
         <filename>nvidia.ko</filename>, i driver di display
         di X11, e <acronym>USB</acronym> avranno la maggior parte
         dei problemi mentre interfacce Ethernet funzioneranno bene.
         Se puoi caricare/scaricare driver correttamente, puoi
         automatizzare questo piazzando i comandi appropriati
         in <filename>/etc/rc.suspend</filename> e
         <filename>/etc/rc.resume</filename>.  C'&egrave;
         un esempio commentato su come caricare e scaricare un driver.
         Prova a impostare <option>hw.acpi.reset_video</option> a zero
         (<literal>0</literal>) se il tuo display &egrave; confuso
         dopo il riavvio.  Prova a impostare valori pi&ugrave; lunghi
         o corti per <option>hw.acpi.sleep_delay</option> per
         vedere se aiuta.</para>

       <para>Un'altra cosa da provare &egrave; caricare una distribuzione
         Linux recente con supporto <acronym>ACPI</acronym> e testare
         il loro supporto sospensione/riavvio sullo stesso hardware.
         Se funziona su Linux, &egrave; probabile che sia un problema
         driver relativo a &os; e restringere il campo di indagine su quale
         driver causi il problema pu&ograve; aiutare a risolvere
         il problema.  Notate che i manutentori di <acronym>ACPI</acronym>
         non mantengono altri driver (ad esempio suono, <acronym>ATA</acronym>,
         etc.) cos&igrave; ogni lavoro fatto sull'identificazione
         del problema del driver dovrebbe alla fine essere risolto dalla lista
         &a.current.name; e inviato via mail al manutentore del driver.
         Se ti senti avventuroso, vai avanti e inizia a porre qualche
         &man.printf.3; in un driver che d&agrave; problemi per tracciare
         in quale driver nella sua funzione di resume vada in palla.</para>

       <para>Alla fine, cerca di disabilitare <acronym>ACPI</acronym> ed
         ad abilitare <acronym>APM</acronym> invece.  Se la sospensione ed il
         riavvio funziona con <acronym>APM</acronym>, &egrave; meglio che tu
         continui con <acronym>APM</acronym>, specialmente su hardware vecchio
         (pre-2000).  Ci vuole un p&ograve; di tempo per i venditori per
         ottenere un supporto corretto all'<acronym>ACPI</acronym> e
         l'hardware pi&ugrave; vecchio &egrave; pi&ugrave; probabile che abbia
         problemi <acronym>BIOS</acronym> con <acronym>ACPI</acronym>.</para>
      </sect3>

      <sect3>
        <title>Blocco del Sistema (temporanea o permanente)</title>

        <para>La maggior parte dei blocchisono causati da interrupt
          persi o da una tempesta di interrupt.  I chipset hanno un sacco
          di problemi su come il <acronym>BIOS</acronym> configuri gli
          interrupt prima del boot, la correttezza delle tabelle
          <acronym>ACPI</acronym> (<acronym>MADT</acronym>) ed il routing del
          <firstterm>System Control Interrupt</firstterm>
          (<acronym>SCI</acronym>).</para>

        <indexterm><primary>tempesta di interrupt</primary></indexterm>

        <para>Le tempeste di interrupt possono essere distinte
          da interrupt persi controllando l'output di
          <command>vmstat -i</command> e guardando alla linea che
          riguarda <literal>acpi0</literal>.  Se il contatore
          sta avanzando pi&ugrave; di un paio di secondi per volta,
          hai una tempesta di interrupt.  Se il sistema si blocca,
          cerca di di entrare in <acronym>DDB</acronym>
          (<keycombo action="simul"><keycap>CTRL</keycap>
          <keycap>ALT</keycap><keycap>ESC</keycap></keycombo> sulla
          console) e digita <literal>show interrupts</literal>.</para>

        <indexterm>
          <primary>APIC</primary>
          <secondary>disabilitare</secondary>
        </indexterm>

        <para>Il modo migliore in caso di problemi di interrupt &egrave;
          provare a disabilitare il supporto <acronym>APIC</acronym>
          con <literal>hint.apic.0.disabled="1"</literal> in
          <filename>loader.conf</filename>.</para>
      </sect3>

      <sect3>
        <title>Panici</title>

        <para>I panici sono relativamente rari per <acronym>ACPI</acronym>
          e sono il primo problema ad essere
          corretto.  Il primo passo da fare &egrave; riprodurre
          il panico (se possibile) ed ottenere un backtrace.  Segui
          l'avvertimento per abilitare <literal>options DDB</literal>
          e imposta una console seriale (vedi la <xref
            linkend="serialconsole-ddb">)
          o imposta una partizione di &man.dump.8;.  Puoi ottenere
          un backtrace in <acronym>DDB</acronym> con <literal>tr</literal>.
          Se hai scritto a mano il backtrace, accertati di ottenere
          le ultime cinque (5) e le prime cinque (5) linee nella
          traccia.</para>

        <para>Poi, prova ad isolare il problema facendo boot con
          <acronym>ACPI</acronym> disabilitato.  Se funziona, puoi
          isolare il sottosistema <acronym>ACPI</acronym> usando vari valori
          di <option>debug.acpi.disable</option>.  Leggi la pagina di
          manuale di &man.acpi.4; per alcuni esempi.</para>
      </sect3>

      <sect3>
        <title>Riavvii di sistema dopo Sospensioni o Spegnimenti</title>

        <para>Prima, cerca di impostare
          <literal>hw.acpi.disable_on_poweroff="0"</literal> in
          &man.loader.conf.5;.
          Questo fa s&igrave; che <acronym>ACPI</acronym> abbia disabilitato
          alcuni eventi durante il processo di shutdown.  Alcuni sistemi
          hanno bisogno di impostare questo valore a <literal>1</literal>
          (il default) per la stessa ragione.  Questo di solito aggiusta
          il problema di un sistema che si accende spontaneamente dopo
          una sospensione o uno spegnimento.</para>
      </sect3>

      <sect3>
        <title>Altri problemi</title>

        <para>Se hai altri problemi con <acronym>ACPI</acronym>
          (lavorare con un docking station, dispositivi non trovati, ecc.),
          per favore invia via mail una descrizione anche alla mailing list;
          comunque, alcune di queste questioni possono essere correlate
          a parti del sottosistema <acronym>ACPI</acronym> cos&igrave;
          pu&ograve; volerci un p&ograve; prima che siano implementate.
          Per favore sii paziente e preparato a testare le patch
          che ti vengono inviate.</para>
      </sect3>
    </sect2>

    <sect2 id="ACPI-aslanddump">
      <title><acronym>ASL</acronym>, <command>acpidump</command>, e
        <acronym>IASL</acronym></title>

      <indexterm>
        <primary>ACPI</primary>
        <secondary>ASL</secondary>
      </indexterm>

      <para>Il pi&ugrave; comune problema &egrave; il <acronym>BIOS</acronym>
        di venditori che forniscono bytecode incorretto (o addirittura
        con bachi).  Questo si deduce usualmente da messaggi del kernel come
        questo:</para>

      <screen>ACPI-1287: *** Error: Method execution failed [\\_SB_.PCI0.LPC0.FIGD._STA] \\
(Node 0xc3f6d160), AE_NOT_FOUND</screen>

      <para>Spesso puoi risolvere questi problemi aggiornando il tuo
        <acronym>BIOS</acronym> all'ultima versione.  La maggior parte
        dei messaggi di console non indica nulla di notevole, ma se hai
        altri problemi come lo stato della batteria non funzionante, questi sono
        un buon inizio per iniziare a cercare problemi in
        <acronym>AML</acronym>.
        Il bytecode, noto come <acronym>AML</acronym>, &egrave; compilato da
        un insieme di codici sorgenti chiamato <acronym>ASL</acronym>.
        L'<acronym>AML</acronym>, &egrave; trovato nella
        tabella nota come come <acronym>DSDT</acronym>.  Per trovare una
        copia del tuo <acronym>ASL</acronym> usa &man.acpidump.8;.  Dovresti
        usare entrambe le opzioni <option>-t</option> (mostra i
        contenuti della tabella fissa) e la <option>-d</option> (disassembla
        <acronym>AML</acronym> ad <acronym>ASL</acronym>).
        Vedi la sezione <link linkend="ACPI-submitdebug">Fornire
          Informazione di Debug</link> per un esempio della sintassi.</para>

      <para>Il tuo primo controllo che puoi fare &egrave; ricompilare
        il tuo <acronym>ASL</acronym> per controllare errori.
        Possono essere ignorati i 'warning' ma gli errori sono
        bachi che impediranno all'<acronym>ACPI</acronym> di
        funzionare correttamente.  Per ricompilare il tuo
        <acronym>ASL</acronym>, usa il comando seguente:</para>

      <screen>&prompt.root; <userinput>iasl your.asl</userinput></screen>
    </sect2>

    <sect2 id="ACPI-fixasl">
      <title>Aggiustare il tuo <acronym>ASL</acronym></title>

      <indexterm>
        <primary>ACPI</primary>
        <secondary>ASL</secondary>
      </indexterm>

      <para>Alla lunga, il nostro obiettivo &egrave; avere
        <acronym>ACPI</acronym> che funzioni per tutti senza intervento.  A
        questo punto, comunque stiamo ancora sviluppando workaround per errori
        comuni fatti dal venditore del <acronym>BIOS</acronym>.
        L'interprete &microsoft; (<filename>acpi.sys</filename> e
        <filename>acpiec.sys</filename>) non &egrave; strettamente conforme
        agli standard, e cos&igrave; molti venditori
        <acronym>BIOS</acronym> che testano solo <acronym>ACPI</acronym>
        sotto &windows; non aggiustano mai il loro <acronym>ASL</acronym>.
        Vogliamo continuare a identificare e documentare esattamente
        quali comportamenti non standard sono concessi dall'interprete
        &microsoft; e replicarlo cosicch&egrave; &os; pu&ograve;
        funzionare senza forzare gli utenti ad usare <acronym>ASL</acronym>.
        Come workaround e per aiutarci ad identificare il comportamento
        puoi fissare la <acronym>ASL</acronym> manualmente.
        Se questo funziona per favore invia un &man.diff.1;
        del vecchio e del nuovo <acronym>ASL</acronym>,
        cosicch&egrave; possiamo lavorare attorno al
        comportamento bacato di <acronym>ACPI-CA</acronym> e cos&igrave;
        rimettere a posto il necessario.</para>

      <indexterm>
        <primary>ACPI</primary>
        <secondary>messaggi di errore</secondary>
      </indexterm>

      <para>Qui c'&egrave; una lista di messaggi di errori comuni,
        le loro cause e come fissarli:</para>

      <sect3>
        <title>Dipendenze OS</title>

        <para>Alcuni <acronym>AML</acronym> assumono che il mondo
          consiste di varie versioni &windows;.  Puoi far s&igrave; che
          &os; simuli qualsiasi <acronym>OS</acronym> per vedere se questo
          risolve il problema che hai.  Un modo facile per sovrascrivere
          questo &egrave; porre <literal>hw.acpi.osname="Windows 2001"</literal>
          in <filename>/boot/loader.conf</filename> o altre stringhe simili
          che trovi nella <acronym>ASL</acronym>.</para>
      </sect3>

      <sect3>
        <title>Valori di Ritorno Mancanti</title>

        <para>Alcuni metodi non ritornano esplicitamente un valore
          come i requisiti standard.  Mentre <acronym>ACPI-CA</acronym>
          non gestisce questo, &os; ha un workaround che permette
          di ritornare i valori implicitamente.  Puoi anche aggiungere
          espliciti Valori di Ritorno dove si richiede se sai quale
          valore dovrebbe essere ritornato.  Per forzare
          <command>iasl</command> a compilare l'<acronym>ASL</acronym>
          usa il flag <option>-f</option>.</para>
      </sect3>

      <sect3>
        <title>Sovrascrivere il Default <acronym>AML</acronym></title>

        <para>Dopo che personalizzi il tuo <filename>your.asl</filename>,
          potresti volerlo compilare, esegui:</para>

        <screen>&prompt.root; <userinput>iasl your.asl</userinput></screen>

        <para>Puoi aggiungere il flag <option>-f</option> per forzare
          la creazione dell'<acronym>AML</acronym>, anche se ci
          sono errori durante la compilazione.  Ricorda che alcuni
          errori (ad esempio valori di Ritorno mancanti) sono
          automaticamente riaggiustati dall'interprete.</para>

        <para><filename>DSDT.aml</filename> &egrave; il nome del file
          di default del comando <command>iasl</command>.
          Puoi caricare questo invece della copia
          difettosa del tuo <acronym>BIOS</acronym> (che &egrave;
          ancora presente in memoria) editando il file
          <filename>/boot/loader.conf</filename> come segue:</para>

        <programlisting>acpi_dsdt_load="YES"
acpi_dsdt_name="/boot/DSDT.aml"</programlisting>

        <para>Assicurati di copiare il tuo file <filename>DSDT.aml</filename>
          nella directory <filename class="directory">/boot</filename>.</para>
      </sect3>
    </sect2>

    <sect2 id="ACPI-debugpoint">
      <title>Ottenere Output di Debug da <acronym>ACPI</acronym></title>

      <indexterm>
        <primary>ACPI</primary>
        <secondary>problemi</secondary>
      </indexterm>
      <indexterm>
        <primary>ACPI</primary>
        <secondary>debug</secondary>
      </indexterm>

      <para>Il driver <acronym>ACPI</acronym> ha una facility di debug
        molto utile.  Permette di specificare un insieme di
        sottosistemi come anche un livello di verbosit&agrave;.
        I sottosistemi che desideri debuggare sono specificati
        come <quote>strati</quote> e sono divisi in componenti
        <acronym>ACPI-CA</acronym> (ACPI_ALL_COMPONENTS)
        e supporto hardware <acronym>ACPI</acronym> (ACPI_ALL_DRIVERS).
        La verbosit&agrave; dell'output di debug &egrave; specificata
        come <quote>livello</quote> e varia da ACPI_LV_ERROR (riporta solo
        gli errori) ad ACIP_LV_VERBOSE (tutto).  Il <quote>livello</quote>
        &egrave; una bitmask che fa s&igrave; che molte opzioni
        possano essere impostate una alla volta, separate da spazi.
        In pratica, puoi usare una console seriale per loggare
        l'output se &egrave; cos&igrave; lungo da riempire
        il buffer di messaggi della console.  Una lista completa
        degli strati individuali e dei livelli &egrave; disponibile nella pagina
        man &man.acpi.4;.</para>

      <para>L'output di debug non &egrave; abilitato di default.
        Per abilitarlo, aggiungi <literal>options ACPI_DEBUG</literal>
        al tuo file di configurazione del kernel se <acronym>ACPI</acronym>
        &egrave; compilato nel kernel.  Puoi aggiungere
        <literal>ACPI_DEBUG=1</literal> al tuo
        <filename>/etc/make.conf</filename> per abilitarlo in modo globale.
        Se &egrave; un modulo, puoi ricompilare soltanto il tuo modulo
        <filename>acpi.ko</filename> come segue:</para>

      <screen>&prompt.root; <userinput>cd /sys/modules/acpi/acpi
&amp;&amp; make clean &amp;&amp;
make ACPI_DEBUG=1</userinput></screen>

      <para>Installa <filename>acpi.ko</filename> in
        <filename class="directory">/boot/kernel</filename>
        ed aggiungi il tuo livello desiderato e gli strati
        in <filename>loader.conf</filename>.
        Questo esempio abilita i messaggi per tutti i
        componenti <acronym>ACPI-CA</acronym> e tutti i driver
        hardware <acronym>ACPI</acronym> (<acronym>CPU</acronym>,
        <acronym>LID</acronym>, etc.).  Produrr&agrave; solo
        messaggi di errore, i meno verbosi.</para>

      <programlisting>debug.acpi.layer="ACPI_ALL_COMPONENENTS ACPI_ALL_DRIVERS"
debug.acpi.level="ACPI_LV_ERROR"</programlisting>

      <para>Se l'informazione che vuoi ottenere &egrave; prodotta da
        un evento specifico (ad esempio, una sospensione ed un riavvio),
        puoi tralasciare i cambiamenti di <filename>loader.conf</filename>
        ed invece usare <command>sysctl</command> per specificare lo
        strato ed il livello dopo il boot e preparare il tuo sistema
        per l'evento specifico.  I <command>sysctl</command> sono nominati
        allo stesso modo dei parametri in
        <filename>loader.conf</filename>.</para>
    </sect2>

    <sect2 id="ACPI-References">
      <title>Riferimenti</title>

      <para>Maggiori informazioni su <acronym>ACPI</acronym> possono essere
        trovate nei seguenti posti:</para>

      <itemizedlist>
        <listitem>
          <para>La &a.acpi;</para>
        </listitem>

        <listitem>
          <para>Gli archivi della mailing list <acronym>ACPI</acronym>
            <ulink
              url="http://lists.freebsd.org/pipermail/freebsd-acpi/"></ulink></para>
        </listitem>

        <listitem>
          <para>I vecchi archivi della mailing list <acronym>ACPI</acronym>
            <ulink url="http://home.jp.FreeBSD.org/mail-list/acpi-jp/"></ulink></para>
        </listitem>

        <listitem>
          <para>La specificazione <acronym>ACPI</acronym> 2.0
            <ulink url="http://acpi.info/spec.htm"></ulink></para>
        </listitem>

        <listitem>
          <para>Le pagine man di &os;: &man.acpi.4;,
            &man.acpi.thermal.4;, &man.acpidump.8;, &man.iasl.8;,
            &man.acpidb.8;</para>
        </listitem>

        <listitem>
          <para><ulink
              url="http://www.cpqlinux.com/acpi-howto.html#fix_broken_dsdt">
            Le risorse di debugging di <acronym>DSDT</acronym></ulink>.
            (Usa Compaq come esempio ma &egrave; sempre utile.)</para>
        </listitem>
      </itemizedlist>
    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
