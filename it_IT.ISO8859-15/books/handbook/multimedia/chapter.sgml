<!--
     The FreeBSD Italian Documentation Project

     $FreeBSD$
     Original revision: 1.110
-->

<chapter id="multimedia">
  <chapterinfo>
    <authorgroup>
      <author>
        <firstname>Ross</firstname>

        <surname>Lippert</surname>

        <contrib>Scritto da </contrib>
      </author>
    </authorgroup>
  </chapterinfo>

  <title>Multimedia</title>

  <sect1 id="multimedia-synopsis">
    <title>Sinossi</title>

    <para>FreeBSD supporta una grande variet&agrave; di schede audio,
      permettendoti di apprezzare un output di alta fedelt&agrave; dal tuo
      computer.  Questo include l'abilit&agrave; di registrare e riprodurre
      suoni nei formati MPEG Audio Layer 3 (MP3), WAV, ed Ogg Vorbis cos&igrave;
      come in molti altri formati.  La FreeBSD Ports Collection contiene inoltre
      applicazioni che ti permettono di modificare l'audio registrato,
      aggiungere effetti sonori, e controllare i dispositivi MIDI
      collegati.</para>

    <para>Con un po' di buona volont&agrave; nello sperimentare, FreeBSD
      pu&ograve; supportare la riproduzione di file video e DVD.  Il numero di
      applicazioni per codificare, convertire, e riprodurre i vari formati
      video &egrave; pi&ugrave; limitato del numero delle applicazioni audio.
      Per esempio nel momento in cui sto scrivendo, non esiste nella FreeBSD
      Ports Collection una buona applicazione per ricodificare, che
      potrebbe essere usata per la conversione tra diversi formati, come
      c'&egrave; con <filename role="package">audio/sox</filename>.  Tuttavia,
      il panorama software in quest'area sta rapidamente cambiando.</para>

    <para>Questo capitolo descriver&agrave; i passi necessari per configurare la
      tua scheda audio.  La configurazione e l'installazione di X11
      (<xref linkend="x11">) si sono gi&agrave; prese cura dei problemi
      hardware della tua scheda video, sebbene ci possano essere delle
      ottimizzazioni da applicare per una migliore riproduzione.</para>

    <para>Dopo aver letto questo capitolo, saprai:</para>

    <itemizedlist>
      <listitem>
        <para>Come configurare il sistema in modo che la scheda audio venga
          riconosciuta.</para>
      </listitem>

      <listitem>
        <para>Metodi per verificare che la tua scheda funzioni, usando
          applicazioni di esempio.</para>
      </listitem>

      <listitem>
        <para>Come risolvere i problemi di configurazione audio.</para>
      </listitem>

      <listitem>
        <para>Come riprodurre e codificare file MP3.</para>
      </listitem>

      <listitem>
        <para>Come sono supportate le applicazioni video dal server X.</para>
      </listitem>

      <listitem>
        <para>Alcuni port per riprodurre/codificare filmati che danno buoni
          risultati.</para>
      </listitem>

      <listitem>
        <para>Come riprodurre i DVD e i file <filename>.mpg</filename> e
          <filename>.avi</filename>.</para>
      </listitem>

      <listitem>
        <para>Come estrarre le informazioni da CD e DVD su file.</para>
      </listitem>

      <listitem>
        <para>Come configurare una scheda TV.</para>
      </listitem>

      <listitem>
        <para>Come configurare uno scanner di immagini.</para>
      </listitem>
    </itemizedlist>

    <para>Prima di leggere questo capitolo, dovresti:</para>

    <itemizedlist>
      <listitem>
        <para>Sapere come configurare e installare un nuovo
          kernel (<xref linkend="kernelconfig">).</para>
      </listitem>
    </itemizedlist>

    <warning>
      <para>Provare a montare CD audio con il comando
        &man.mount.8; produrr&agrave; un errore, come minimo, o un
        <emphasis>kernel panic</emphasis>, alla peggio.  Questi formati hanno
        codifiche particolari che differiscono dal comune file system
        ISO.</para>
    </warning>
  </sect1>

  <sect1 id="sound-setup">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Moses</firstname>

          <surname>Moore</surname>

          <contrib>Contributo di </contrib>
        </author>
      </authorgroup>

      <authorgroup>
        <author>
          <firstname>Marc</firstname>

          <surname>Forvieille</surname>

          <contrib>Arricchito per &os;&nbsp;5.X da </contrib>
        </author>
      </authorgroup>
    </sect1info>

    <title>Configurazione della Scheda Audio</title>

    <sect2 id="sound-device">
      <title>Configurare il Sistema</title>

      <indexterm><primary>PCI</primary></indexterm>
      <indexterm><primary>ISA</primary></indexterm>
      <indexterm><primary>schede audio</primary></indexterm>

      <para>Prima di iniziare, dovresti conoscere il modello della scheda che
        possiedi, il chip che utilizza, e se &egrave; una scheda PCI o ISA.
        FreeBSD supporta diverse schede PCI e ISA.  Verifica la lista dei
        dispositivi audio supportati nell' <ulink
          url="&rel.current.hardware;">Hardware Notes</ulink> per vedere se
        la tua scheda &egrave; supportata.  Inoltre tale documento ti
        indicher&agrave; quale driver supporta la tua scheda.</para>

      <indexterm>
        <primary>kernel</primary>
        <secondary>configurazione</secondary>
      </indexterm>

      <para>Per usare il tuo dispositivo audio, dovrai caricare i driver
        corretti.  Il caricamento del driver del dispositivo pu&ograve; essere
        fatto in due modi.  Il metodo pi&ugrave; semplice consiste semplicemente
        nel caricare un modulo nel kernel per la tua scheda audio con
        &man.kldload.8; che pu&ograve; essere fatto sia da linea di
        comando:</para>

      <screen>&prompt.root; <userinput>kldload snd_emu10k1</userinput></screen>

      <para>sia aggiungendo la riga appropriata al file
        <filename>/boot/defaults/loader.conf</filename> come questa:</para>

      <programlisting>snd_emu10k1_load="YES"</programlisting>

      <para>Questi esempi sono per la scheda audio Creative &soundblaster;
        Live!.  Altri moduli sonori disponibili sono elencati in
        <filename>/boot/loader.conf</filename>.  Se hai dei dubbi su quale
        driver usare, potresti provare a caricare il modulo
        <filename>snd_driver</filename>:</para>

      <screen>&prompt.root; <userinput>kldload snd_driver</userinput></screen>

      <para>Questo &egrave; un metadriver che carica i driver dei dispositivi
        audio pi&ugrave; comuni in un solo colpo.  Ci&ograve; permette di
        trovare velocemente il driver corretto.  &Egrave; anche possibile
        caricare tutti i driver audio attraverso il file
        <filename>/boot/loader.conf</filename>.</para>

      <para>Se desideri scoprire il driver selezionato per la tua scheda audio
        dopo aver caricato il metadriver <filename>snd_driver</filename>,
        puoi verificare il file <filename>/dev/sndstat</filename> con il
        comando <command>cat /dev/sndstat</command>.</para>

      <note>
        <para>Con &os;&nbsp;4.X, per caricare tutti i driver audio, devi
          caricare il modulo <filename>snd</filename> invece di
          <filename>snd_driver</filename>.</para>
      </note>

      <para>Un altro metodo &egrave; quello di compilare staticamente il
        supporto per la tua scheda audio nel kernel.  La sezione seguente
        fornisce le informazioni di cui hai bisogno per aggiungere il supporto
        al tuo hardware in questo metodo.  Per informazioni aggiuntive su
        come ricompilare il kernel, guarda il <xref
          linkend="kernelconfig">.</para>

      <sect3>
        <title>Configurare un Kernel Custom con il Supporto Audio</title>

        <para>La prima cosa da fare &egrave; aggiungere al kernel il driver
          audio generico &man.sound.4;, e per fare ci&ograve; devi aggiungere
          la seguente riga al tuo file di configurazione del kernel:</para>

        <programlisting>device sound</programlisting>

        <para>Con &os;&nbsp;4.X la riga da aggiungere &egrave; questa:</para>

        <programlisting>device pcm</programlisting>

        <para>Ora dobbiamo aggiungere il supporto per la nostra scheda audio.
          Di conseguenza abbiamo la necessit&agrave; di conoscere quale driver
          supporta la nostra scheda.  Controlla la lista dei dispositivi
          audio supportati nell'<ulink
            url="&rel.current.hardware;">Hardware Notes</ulink>, per
          determinare il driver corretto per la tua scheda sonora.  Per
          esempio, la scheda &soundblaster; Live! della  Creative &egrave;
          supportata dal driver &man.snd.emu10k1.4;.  Per aggiungere il
          supporto per questa scheda, usiamo la seguente riga:</para>

        <programlisting>device "snd_emu10k1"</programlisting>

        <para>Per conoscere la corretta sintassi da usare assicurati di
          leggere la pagina man del driver.  Inoltre, nel file
          <filename>/usr/src/sys/conf/NOTES</filename>
          (<filename>/usr/src/sys/i386/conf/LINT</filename> per
          &os;&nbsp;4.X) puoi trovare informazioni riguardanti la sintassi dei
          driver audio da usare nel file di configurazione del kernel.</para>

        <para>Schede ISA non-PnP possono obbligarti a fornire al kernel
          informazioni su alcuni settaggi della scheda audio (IRQ, porta di I/O,
          etc).  Questo pu&ograve; essere realizzato attraverso il file
          <filename>/boot/device.hints</filename>.  All'avvio del sistema,
          il &man.loader.8; legger&agrave; questo file e passer&agrave;
          i settaggi al kernel.  Per esempio, una vecchia scheda audio
          &soundblaster; 16 ISA non-PnP della Creative user&agrave; il driver
          &man.snd.sbc.4;, con la seguente riga nel file di configurazione del
          kernel:</para>

        <programlisting>device snd_sbc</programlisting>

        <para>e in aggiunta nel <filename>/boot/device.hints</filename>:</para>

        <programlisting>hint.sbc.0.at="isa"
hint.sbc.0.port="0x220"
hint.sbc.0.irq="5"
hint.sbc.0.drq="1"
hint.sbc.0.flags="0x15"</programlisting>

        <para>In questo caso, la scheda usa la porta di I/O
          <literal>0x220</literal> e l'IRQ <literal>5</literal>.</para>

        <para>La sintassi usata nel file <filename>/boot/device.hints</filename>
          &egrave; spiegata nella pagina man del driver audio.  Con
          &os;&nbsp;4.X, questi settaggi sono inseriti direttamente nel
          file di configurazione del kernel.  Nel caso della nostra scheda
          ISA presa in esame, dovremo usare questa riga:</para>

        <programlisting>device sbc0 at isa? port 0x220 irq 5 drq 1 flags 0x15</programlisting>

        <para>Il settaggi qui sopra sono quelli di default.  In alcuni casi,
          potresti avere la necesit&agrave; di modificare l'IRQ o altri
          parametri per far funzionare la tua scheda audio.  Guarda la pagina
          man di &man.snd.sbc.4; per maggiori dettagli su questo driver.</para>

        <note>
          <para>Con &os;&nbsp;4.X, alcuni sistemi con dispositivi audio
            incorporati nella scheda madre potrebbero richiedere le seguenti
            opzioni nel file di configurazione del kernel:</para>

          <programlisting>options PNPBIOS</programlisting>
        </note>
      </sect3>
    </sect2>

    <sect2 id="sound-testing">
      <title>Collaudo della Scheda Audio</title>

      <para>Dopo aver riavviato con il nuovo kernel, o dopo aver caricato il
        modulo richiesto, la scheda audio dovrebbe apparire nel tuo buffer
        dei messaggi (&man.dmesg.8;) in modo simile a quanto segue:</para>

      <screen>pcm0: &lt;Intel ICH3 (82801CA)&gt; port 0xdc80-0xdcbf,0xd800-0xd8ff irq 5 at device 31.5 on pci0
pcm0: [GIANT-LOCKED]
pcm0: &lt;Cirrus Logic CS4205 AC97 Codec&gt;</screen>

      <para>Lo stato della scheda audio pu&ograve; essere verificato leggendo
        il file <filename>/dev/sndstat</filename>:</para>

      <screen>&prompt.root; <userinput>cat /dev/sndstat</userinput>
FreeBSD Audio Driver (newpcm)
Installed devices:
pcm0: &lt;Intel ICH3 (82801CA)&gt; at io 0xd800, 0xdc80 irq 5 bufsz 16384
kld snd_ich (1p/2r/0v channels duplex default)</screen>

      <para>L'output del tuo sistema potrebbe essere diverso.  Se nessun
        dispositivo <devicename>pcm</devicename> viene visualizzato, rivedi
        ci&ograve; che &egrave; stato fatto di recente.  Ricontrolla ancora
        una volta il tuo file di configurazione del kernel e assicurati di
        aver scelto il driver corretto.  Alcuni problemi comuni sono elencati
        nella <xref linkend="troubleshooting">.</para>

      <para>Se tutto va bene, ora dovresti avere una scheda audio funzionante.
        Se il tuo drive CD-ROM o DVD-ROM &egrave; collegato correttamente alla
        scheda audio, puoi inserire un CD nel drive e riprodurlo con
        &man.cdcontrol.1;:</para>

      <screen>&prompt.user; <userinput>cdcontrol -f /dev/acd0 play 1</userinput></screen>

      <para>Varie applicazioni, come <filename
          role="package">audio/workman</filename> possono offrire una migliore
        interfaccia.  Potresti voler installare una applicazione come
        <filename role="package">audio/mpg123</filename> per ascoltare i file
        audio MP3.  Ecco un modo veloce per controllare se la scheda trasmette
        dati al nodo <filename>/dev/dsp</filename>:</para>

      <screen>&prompt.user; <userinput>cat <replaceable>filename</replaceable> &gt; /dev/dsp</userinput></screen>

      <para>dove <replaceable>filename</replaceable> pu&ograve; essere
        qualsiasi file.  Questo comando dovrebbe produrre del rumore, confermando
        che la scheda sonora sta lavorando.</para>

      <note>
        <para>Gli utenti di &os;&nbsp;4.X hanno bisogno di creare un nodo
          del dispositivo per la scheda audio prima di poterlo usare.  Se la
          scheda mostrata nel buffer dei messaggi &egrave;
          <devicename>pcm0</devicename>, devi eseguire il seguente comando
          da <username>root</username>:</para>

        <screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>sh MAKEDEV snd0</userinput></screen>

        <para>Se il rilevamento della scheda ha ritornato
          <devicename>pcm1</devicename>, segui le stesse fasi come indicato
          qui sopra, rimpiazzando <devicename>snd0</devicename> con
          <devicename>snd1</devicename>.</para>

        <para><command>MAKEDEV</command> creer&agrave; un gruppo di nodi
          dei dispositivi che saranno usati dalle varie applicazioni
          audio.</para>
      </note>

      <para>I livelli del mixer della scheda possono essere modificati
        attraverso il comando &man.mixer.8;.  Maggiori dettagli possono essere
        trovati nella pagina man &man.mixer.8;.</para>

      <sect3 id="troubleshooting">
        <title>Problemi Comuni</title>

        <indexterm><primary>dispositivi</primary></indexterm>
        <indexterm><primary>porta di I/O</primary></indexterm>
        <indexterm><primary>IRQ</primary></indexterm>
        <indexterm><primary>DSP</primary></indexterm>

        <informaltable frame="none" pgwide="1">
          <tgroup cols="2">
            <thead>
              <row>
                <entry>Errore</entry>

                <entry>Soluzione</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><errorname>unsupported subdevice XX</errorname></entry>

                <entry><para>Non &egrave; stato creato correttamente qualche
                    dispositivo.  Ripeti i precedenti passi.</para></entry>
              </row>

              <row>
                <entry><errorname>sb_dspwr(XX) timed out</errorname></entry>

                <entry><para>Non &egrave; stata impostata correttamente la porta
                    di I/O.</para></entry>
              </row>

              <row>
                <entry><errorname>bad irq XX</errorname></entry>

                <entry><para>&Egrave; stato configurato erroneamente l'IRQ.
                    Assicurati che l'IRQ impostato e quello della scheda siano
                    gli stessi.</para></entry>
              </row>

              <row>
                <entry><errorname>xxx: gus pcm not attached, out of
                    memory</errorname></entry>

                <entry><para>Non c'&egrave; abbastanza memoria disponibile per
                    usare il dispositivo.</para></entry>
              </row>

              <row>
                <entry><errorname>xxx: can't open /dev/dsp!</errorname></entry>

                <entry><para>Controlla con <command>fstat | grep dsp</command>
                    se un'altra applicazione sta usando il dispositivo.
                    <application>Esound</application> e il supporto audio di
                    <application>KDE</application> sono famosi per creare
                    problemi.</para></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </sect3>
    </sect2>

    <sect2 id="sound-multiple-sources">
      <sect2info>
        <authorgroup>
          <author>
            <firstname>Munish</firstname>

            <surname>Chopra</surname>

            <contrib>Contributo di </contrib>
          </author>
        </authorgroup>
      </sect2info>

      <title>Utilizzo di Sorgenti Audio Multiple</title>

      <para>&Egrave; spesso desiderabile avere pi&ugrave; sorgenti di audio che
        siano in grado di suonare contemporaneamente, per esempio quando
        <application>esound</application> o <application>artsd</application> non
        supportano la condivisione del dispositivo audio con una certa
        applicazione.</para>

      <para>FreeBSD ti permette di fare questo attraverso i <emphasis>Virtual
          Sound Channels</emphasis>, che possono essere impostati con
        &man.sysctl.8;.  I canali virtuali permettono di multiplexare i canali
        di riproduzione della tua scheda audio mixando l'audio nel
        kernel.</para>

      <para>Per impostare il numero dei canali virtuali, ci sono due variabili
        sysctl che, se sei l'utente <username>root</username>, possono essere
        impostate cos&igrave;:</para>

      <screen>&prompt.root; <userinput>sysctl hw.snd.pcm0.vchans=4</userinput>
&prompt.root; <userinput>sysctl hw.snd.maxautovchans=4</userinput></screen>

      <para>L'esempio qui sopra alloca quattro canali virtuali, che &egrave; un
        numero adatto all'uso di ogni giorno.
        <varname>hw.snd.pcm0.vchans</varname> &egrave; il numero dei canali
        virtuali che ha <devicename>pcm0</devicename>, ed &egrave; configurabile
        una volta che il dispositivo &egrave; collegato.
        <literal>hw.snd.maxautovchans</literal> &egrave; il numero dei canali
        virtuali che vengono dati a un nuovo dispositivo audio quando viene
        collegato tramite &man.kldload.8;.  Visto che il modulo
        <devicename>pcm</devicename> pu&ograve; essere caricato
        indipendentemente dai driver dell'hardware,
        <varname>hw.snd.maxautovchans</varname> pu&ograve; contenere tanti
        canali virtuali quanti ne verranno allocati successivamente ad ogni
        dispositivo collegato.</para>

      <note>
        <para>Non puoi cambiare il numero di canali virtuali per un
          dispositivo mentre questo &egrave; in uso.  Chiudi tutti
          i programmi che stanno usando quel dispositivo, come player
          di musica o demoni del suono.</para>
      </note>

      <para>Se non stai usando &man.devfs.5;, dovrai indirizzare la tua
        applicazione su
        <filename>/dev/dsp0</filename>.<replaceable>x</replaceable>, dove
        <replaceable>x</replaceable> va da 0 a 3 se
        <varname>hw.snd.pcm.0.vchans</varname> &egrave; impostato a 4 come nel
        precedente esempio.  Su un sistema che usa &man.devfs.5;, questo
        verr&agrave; fatto automaticamente in modo trasparente per
        l'utente.</para>
    </sect2>

    <sect2>
      <sect2info>
        <authorgroup>
          <author>
            <firstname>Josef</firstname>

            <surname>El-Rayes</surname>

            <contrib>Contributo di </contrib>
          </author>
        </authorgroup>
      </sect2info>

      <title>Settare i Valori di Default per i Canali del Mixer</title>

      <para>I valori di default per i diversi canali del mixer sono rigidamente
        codificati nel codice sorgente del driver &man.pcm.4;.  Ci sono svariate
        applicazioni e demoni che permettono in automatico di settare il mixer
        a valori prestabili, ma questa non &egrave; una soluzione pulita, noi
        vogliamo avere dei valori di default a livello del driver.  Questo
        &egrave; realizzabile definendo i valori desiderati nel file
        <filename>/boot/device.hints</filename>.  Ad esempio:</para>

      <programlisting>hint.pcm.0.vol="100"</programlisting>

      <para>Questo imposter&agrave; il canale volume a un valore di default
        di 100, non appena il modulo &man.pcm.4; sar&agrave; caricato.</para>

      <note>
        <para>Solamente supportato da &os; 5.3-RELEASE e superiori.</para>
      </note>
    </sect2>
  </sect1>

  <sect1 id="sound-mp3">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Chern</firstname>

          <surname>Lee</surname>

          <contrib>Contributo di </contrib>
        </author>
      </authorgroup>
    </sect1info>

    <title>Audio MP3</title>

    <para>Il formato MP3 (Audio MPEG Livello 3) raggiunge una qualit&agrave;
      audio vicina a quella dei CD, non lasciandoti motivi per non utilizzarlo
      sulla tua workstation FreeBSD.</para>

    <sect2 id="mp3-players">
      <title>Lettori MP3</title>

      <para>Da tempo, il pi&ugrave; famoso lettore MP3 per X11 &egrave;
        <application>XMMS</application> (X Multimedia System).  Le skin per
        <application>Winamp</application> possono essere usate con
        <application>XMMS</application> visto che la GUI &egrave; praticamente
        identica a quella di <application>Winamp</application> della Nullsoft.
        <application>XMMS</application> ha inoltre supporto nativo ai
        plug-in.</para>

      <para><application>XMMS</application> pu&ograve; essere installato dal
        port o dal package <filename
          role="package">multimedia/xmms</filename>.</para>

      <para>L'interfaccia di <application>XMMS</application> &egrave; intuitiva,
        comprende una lista di brani da eseguire, un equalizzatore grafico, ed
        altro.  Coloro che sono familiari con <application>Winamp</application>
        troveranno <application>XMMS</application> semplice da usare.</para>

      <para>Il port <filename role="package">audio/mpg123</filename> &egrave;
        un lettore MP3 alternativo, da riga di comando.</para>

      <para><application>mpg123</application> pu&ograve; essere eseguito
        specificando il dispositivo audio e il nome del file MP3 sulla riga di
        comando, come mostrato qui sotto:</para>

      <screen>&prompt.root; <userinput>mpg123 -a <replaceable>/dev/dsp1.0</replaceable> Foobar-GreatestHits.mp3</userinput>
High Performance MPEG 1.0/2.0/2.5 Audio Player for Layer 1, 2 and 3.
Version 0.59r (1999/Jun/15). Written and copyrights by Michael Hipp.
Uses code from various people. See 'README' for more!
THIS SOFTWARE COMES WITH ABSOLUTELY NO WARRANTY! USE AT YOUR OWN RISK!





Playing MPEG stream from Foobar-GreatestHits.mp3 ...
MPEG 1.0 layer III, 128 kbit/s, 44100 Hz joint-stereo</screen>

      <para><literal>/dev/dsp1.0</literal> deve essere sostituito con il
        dispositivo <devicename>dsp</devicename> presente sul tuo
        sistema.</para>
    </sect2>

    <sect2 id="rip-cd">
      <title>Estrazione delle Tracce Audio dei CD</title>

      <para>Prima di codificare un CD o una traccia di CD in MP3, i dati audio
        sul CD devono essere estratti sul disco fisso.  Questo avviene copiando
        direttamente i dati CDDA (CD Digital Audio) in file WAV.</para>

      <para>Il tool <command>cdda2wav</command>, che fa parte della suite
        <filename role="package">sysutils/cdrtools</filename>, viene usato per
        estrarre le informazioni audio dai CD e i dati associati.</para>

      <para>Mentre il CD audio &egrave; nel lettore, pu&ograve; essere eseguito
        il seguente comando (come <username>root</username>) per estrarre un
        intero CD in singoli (per traccia) file WAV:</para>

      <screen>&prompt.root; <userinput>cdda2wav -D <replaceable>0,1,0</replaceable> -B</userinput></screen>

      <para><application>cdda2wav</application> supporta anche i lettori CDROM
        ATAPI (IDE).  Per estrarre da un lettore IDE, specifica il nome del
        dispositivo al posto nel numero dell'unit&agrave; SCSI.  Ad esempio, per
        estrarre la traccia 7 dal lettore IDE:</para>

      <screen>&prompt.root; <userinput>cdda2wav -D <replaceable>/dev/acd0a</replaceable> -t 7</userinput></screen>

      <para>Il <option>-D <replaceable>0,1,0</replaceable></option>
        indica il dispositivo SCSI <devicename>0,1,0</devicename>, che
        corrisponde all'output di <command>cdrecord -scanbus</command>.</para>

      <para>Per estrarre tracce singole, usa l'opzione <option>-t</option> come
        mostrato:</para>

      <screen>&prompt.root; <userinput>cdda2wav -D <replaceable>0,1,0</replaceable> -t 7</userinput></screen>

      <para>Questo esempio estrae la settima traccia del CD audio.  Per estrarre
        una serie di tracce, per esempio dalla traccia uno alla sette, specifica
        un intervallo:</para>

      <screen>&prompt.root; <userinput>cdda2wav -D <replaceable>0,1,0</replaceable> -t 1+7</userinput></screen>

      <para>L'utility &man.dd.1; pu&ograve; anche essere usata per estrarre le
        tracce audio dai drive ATAPI, leggi <xref
          linkend="duplicating-audiocds"> per maggiori informazioni su questa
        possibilit&agrave;.</para>
    </sect2>

    <sect2 id="mp3-encoding">
      <title>Codifica in MP3</title>

      <para>Al giorno d'oggi, il programma di codifica in mp3 da scegliere
        &egrave; <application>lame</application>.
        <application>Lame</application> pu&ograve; essere trovato in <filename
          role="package">audio/lame</filename> nell'albero dei port.</para>

      <para>Usando i file WAV estratti, il seguente comando convertir&agrave;
        <filename>audio01.wav</filename> in
        <filename>audio01.mp3</filename>:</para>

      <screen>&prompt.root; <userinput>lame -h -b <replaceable>128</replaceable> \
--tt "<replaceable>Titolo</replaceable>" \
--ta "<replaceable>Artista</replaceable>" \
--tl "<replaceable>Album</replaceable>" \
--ty "<replaceable>2002</replaceable>" \
--tc "<replaceable>Estratto e codificato da Blah</replaceable>" \
--tg "<replaceable>Genere</replaceable>" \
<replaceable>audio01.wav audio01.mp3</replaceable></userinput></screen>

      <para>128&nbsp;kbits sembra essere il bitrate standard in uso per gli MP3.
        Molti preferiscono la qualit&agrave; maggiore dei 160, o 192.
        Pi&ugrave; alto &egrave; il bitrate, pi&ugrave; spazio consumer&agrave;
        l'MP3 risultante--ma la qualit&agrave; sar&agrave; maggiore.  L'opzione
        <option>-h</option> attiva il modo <quote>qualit&agrave; migliore ma un
        po' pi&ugrave; lento"</quote>.  Le opzioni che iniziano con
        <option>--t</option> indicano i tag ID3, che solitamente contengono le
        informazioni sulla canzone, da inserire all'interno del file MP3.
        Ulteriori opzioni di codifica possono essere trovate consultando la
        pagina man di lame.</para>
    </sect2>

    <sect2 id="mp3-decoding">
      <title>Decodifica da MP3</title>

      <para>Per masterizzare un CD audio partendo dagli MP3, questi ultimi
        devono essere convertiti in un formato WAV non compresso.  Sia
        <application>XMMS</application> che <application>mpg123</application>
        supportano l'output di un MP3 in un formato non compresso.</para>

      <para>Scrittura su Disco con <application>XMMS</application>:</para>

      <procedure>
        <step>
          <para>Avvia <application>XMMS</application>.</para>
        </step>

        <step>
          <para>Clicca con il tasto destro sulla finestra per far comparire il
            menu di <application>XMMS</application>.</para>
        </step>

        <step>
          <para>Seleziona <literal>Preference</literal> sotto
            <literal>Options</literal>.</para>
        </step>

        <step>
          <para>Cambia l'Output Plugin in <quote>Disk Writer
              Plugin</quote>.</para>
        </step>

        <step>
          <para>Premi <literal>Configure</literal>.</para>
        </step>

        <step>
          <para>Inserisci (o scegli browse) la directory in cui salvare i file
            decompressi.</para>
        </step>

        <step>
          <para>Carica il file MP3 in <application>XMMS</application> come al
            solito, con il volume al 100% e le impostazioni dell'equalizzatore
            disattivate.</para>
        </step>

        <step>
          <para>Premi <literal>Play</literal> &mdash;
            <application>XMMS</application> apparir&agrave; come se stesse
            riproducendo l'MP3, ma non si sentir&agrave; nessuna musica.  Sta
            riproducendo la musica su un file.</para>
        </step>

        <step>
          <para>Assicurati di reimpostare l'Output Plugin di default come prima
            per ascoltare nuovamente gli MP3.</para>
        </step>
      </procedure>

      <para>Scrittura su stdout con <application>mpg123</application>:</para>

      <procedure>
        <step>
          <para>Esegui <command>mpg123 -s <replaceable>audio01.mp3</replaceable>
            &gt; audio01.pcm</command></para>
        </step>
      </procedure>

      <para><application>XMMS</application> scrive un file nel formato WAV,
        mentre <application>mpg123</application> converte l'MP3 direttamente in
        dati audio PCM.  Entrambi questi formati possono essere usati con
        <application>cdrecord</application> per creare CD audio.
        Devi utilizzare PCM con &man.burncd.8;.  Se usi file WAV, noterai un
        breve ticchettio all'inizio di ogni traccia, questo suono &egrave;
        l'intestazione del file WAV.  Puoi semplicemente rimuovere
        l'intestazione del file WAV con l'utility <application>SoX</application>
        (pu&ograve; essere installata dal port o dal package <filename
          role="package">audio/sox</filename>):</para>

      <screen>&prompt.user; <userinput>sox -t wav -r 44100 -s -w -c 2 <replaceable>track.wav track.raw</replaceable></userinput></screen>

      <para>Leggi <xref linkend="creating-cds"> per ulteriori informazioni su
        come usare un masterizzatore con FreeBSD.</para>
    </sect2>
  </sect1>

  <sect1 id="video-playback">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Ross</firstname>

          <surname>Lippert</surname>

          <contrib>Contributo di </contrib>
        </author>
      </authorgroup>
    </sect1info>

    <title>Riproduzione Video</title>

    <para>La riproduzione video &egrave; un'area applicativa molto recente e
      in rapido sviluppo.  Sii paziente.  Non tutto funzioner&agrave;
      cos&igrave; facilmente come &egrave; stato per l'audio.</para>

    <para>Prima di iniziare, dovresti conoscere il modello della scheda video
      che possiedi e il chip che usa.  Sebbene
      <application>&xorg;</application> e <application>&xfree86;</application>
      supportino una vasta variet&agrave; di schede video, poche offrono buone
      prestazioni in riproduzione.  Per ottenere una lista di estensioni
      supportate dall'X server con la tua scheda usa il comando
      &man.xdpyinfo.1; mentre X11 sta girando.</para>

    <para>&Egrave; una buona idea avere un piccolo file MPEG che possa essere
      trattato come un file di test per la valutazione di vari riproduttori e
      opzioni.  Visto che alcuni riproduttori di DVD cercheranno di default i
      DVD in <filename>/dev/dvd</filename>, o hanno questo nome di dispositivo
      codificato permanentemente al loro interno, potresti trovare utile creare
      dei link simbolici al dispositivo corretto:</para>

    <screen>&prompt.root; <userinput>ln -sf /dev/acd0 /dev/dvd</userinput>
&prompt.root; <userinput>ln -sf /dev/acd0 /dev/rdvd</userinput></screen>

    <para>Nota che, data la natura del &man.devfs.5;, i collegamenti creati a
      mano come questi non rimarranno se riavvii il sistema.  Per creare i
      collegamenti simbolici automaticamente quando avvii il sistema, aggiungi
      le seguenti righe in <filename>/etc/devfs.conf</filename>:</para>

    <programlisting>link acd0 dvd
link acd0 rdvd</programlisting>

    <para>Su FreeBSD&nbsp;5.X, che usa &man.devfs.5; c'&egrave; un insieme di
      link raccomandati leggermente diverso:</para>

    <screen>&prompt.root; <userinput>ln -sf /dev/acd0c /dev/dvd</userinput>
&prompt.root; <userinput>ln -sf /dev/acd0c /dev/rdvd</userinput></screen>

    <para>In aggiunta, la decrittazione dei DVD, che richiede l'invocazione
      di speciali funzioni dei DVD-ROM, richiede il permesso in scrittura sui
      dispositivi DVD.</para>

    <indexterm>
      <primary>opzioni del kernel</primary>
      <secondary>CPU_ENABLE_SSE</secondary>
    </indexterm>
    <indexterm>
      <primary>opzioni del kernel</primary>
      <secondary>USER_LDT</secondary>
    </indexterm>

    <para>Alcuni dei port discussi si basano sulle seguenti opzioni del kernel
      per compilarsi correttamente.  Prima di provare a compilarli, aggiungi
      queste opzioni al file di configurazione del kernel, compila un nuovo
      kernel, e riavvia:</para>

    <programlisting>option CPU_ENABLE_SSE
option USER_LDT</programlisting>

    <note>
      <para><literal>option USER_LDT</literal> non esiste su
        &os;&nbsp;5.X.</para>
    </note>

    <para>Per migliorare l'interfaccia della memoria condivisa di X11, &egrave;
      consigliabile incrementare i valori di alcune variabili
      &man.sysctl.8;:</para>

    <programlisting>kern.ipc.shmmax=67108864
kern.ipc.shmall=32768</programlisting>

    <sect2 id="video-interface">
      <title>Determinazione delle Capacit&agrave; Video</title>

      <indexterm><primary>XVideo</primary></indexterm>
      <indexterm><primary>SDL</primary></indexterm>
      <indexterm><primary>DGA</primary></indexterm>

      <para>Ci sono molti modi possibili per visualizzare immagini e filmati con
        X11.  Quello che funzioner&agrave; meglio in pratica dipende in gran
        parte dal tuo hardware.  Ogni metodo descritto qui sotto avr&agrave; una
        qualit&agrave; variabile su hardware differente.  In secondo luogo, il
        rendering video in X11 &egrave; un argomento che sta ricevendo un sacco
        di attenzione ultimamente, e con ogni nuova versione di
        <application>&xorg;</application>, o di
        <application>&xfree86;</application> ci possono essere notevoli
        miglioramenti.</para>

      <para>Una lista di interfacce video comuni:</para>

      <orderedlist>
        <listitem>
          <para>X11: normale output di X11 che usa la memoria condivisa.</para>
        </listitem>

        <listitem>
          <para>XVideo: un'estensione all'interfaccia X11 che supporta grafica
            e filmati in ogni oggetto X11 disegnabile.</para>
        </listitem>

        <listitem>
          <para>SDL: Simple Directmedia Layer.</para>
        </listitem>

        <listitem>
          <para>DGA: Direct Graphics Access.</para>
        </listitem>

        <listitem>
          <para>SVGAlib: interfaccia di basso livello per la grafica da
            console.</para>
        </listitem>
      </orderedlist>

      <sect3 id="video-interface-xvideo">
        <title>XVideo</title>

        <para><application>&xorg;</application> e <application>&xfree86;
            4.X</application> hanno un'estensione chiamata
          <emphasis>XVideo</emphasis> (aka Xvideo, aka Xv, aka xv) che permette
          di visualizzare grafica e filmati direttamente negli oggetti
          disegnabili attraverso una speciale accelerazione.
          Questa estensione fornisce una riproduzione di ottima qualit&agrave;
          anche su macchine poco potenti.</para>

        <para>Per controllare se l'estensione sta girando, usa
          <command>xvinfo</command>:</para>

        <screen>&prompt.user; <userinput>xvinfo</userinput></screen>

        <para>XVideo &egrave; supportato dalla tua scheda se il risultato
          &egrave; simile a:</para>

        <screen>X-Video Extension version 2.2
screen #0
  Adaptor #0: "Savage Streams Engine"
    number of ports: 1
    port base: 43
    operations supported: PutImage
    supported visuals:
      depth 16, visualID 0x22
      depth 16, visualID 0x23
    number of attributes: 5
      "XV_COLORKEY" (range 0 to 16777215)
              client settable attribute
              client gettable attribute (current value is 2110)
      "XV_BRIGHTNESS" (range -128 to 127)
              client settable attribute
              client gettable attribute (current value is 0)
      "XV_CONTRAST" (range 0 to 255)
              client settable attribute
              client gettable attribute (current value is 128)
      "XV_SATURATION" (range 0 to 255)
              client settable attribute
              client gettable attribute (current value is 128)
      "XV_HUE" (range -180 to 180)
              client settable attribute
              client gettable attribute (current value is 0)
    maximum XvImage size: 1024 x 1024
    Number of image formats: 7
      id: 0x32595559 (YUY2)
        guid: 59555932-0000-0010-8000-00aa00389b71
        bits per pixel: 16
        number of planes: 1
        type: YUV (packed)
      id: 0x32315659 (YV12)
        guid: 59563132-0000-0010-8000-00aa00389b71
        bits per pixel: 12
        number of planes: 3
        type: YUV (planar)
      id: 0x30323449 (I420)
        guid: 49343230-0000-0010-8000-00aa00389b71
        bits per pixel: 12
        number of planes: 3
        type: YUV (planar)
      id: 0x36315652 (RV16)
        guid: 52563135-0000-0000-0000-000000000000
        bits per pixel: 16
        number of planes: 1
        type: RGB (packed)
        depth: 0
        red, green, blue masks: 0x1f, 0x3e0, 0x7c00
      id: 0x35315652 (RV15)
        guid: 52563136-0000-0000-0000-000000000000
        bits per pixel: 16
        number of planes: 1
        type: RGB (packed)
        depth: 0
        red, green, blue masks: 0x1f, 0x7e0, 0xf800
      id: 0x31313259 (Y211)
        guid: 59323131-0000-0010-8000-00aa00389b71
        bits per pixel: 6
        number of planes: 3
        type: YUV (packed)
      id: 0x0
        guid: 00000000-0000-0000-0000-000000000000
        bits per pixel: 0
        number of planes: 0
        type: RGB (packed)
        depth: 1
        red, green, blue masks: 0x0, 0x0, 0x0</screen>

        <para>Inoltre tieni presente che i formati elencati (YUV2, YUV12, ecc)
          non sono presenti in tutte le implementazioni di XVideo e la loro
          assenza pu&ograve; ostacolare alcuni programmi.</para>

        <para>Se il risultato &egrave;:</para>

        <screen>X-Video Extension version 2.2
screen #0
no adaptors present</screen>

        <para>Allora XVideo probabilmente non &egrave; supportato per la tua
          scheda.</para>

        <para>Se XVideo non &egrave; supportato per la tua scheda, questo vuol
          dire solamente che sar&agrave; pi&ugrave; difficile soddisfare le
          richieste computazionali per il rendering video.  A seconda della tua
          scheda video e del tuo processore, comunque, potresti essere ancora in
          grado di avere un'esperienza soddisfacente.  Dovrai probabilmente
          dare un occhio ai modi per migliorare le prestazioni nella lettura
          avanzata <xref linkend="video-further-reading">.</para>
      </sect3>

      <sect3 id="video-interface-SDL">
        <title>Simple Directmedia Layer</title>

        <para>Il Simple Directmedia Layer, SDL, vuole essere un'interfaccia di
          portabilit&agrave; tra &microsoft; Windows, BeOS, e &unix;, che possa
          permettere di sviluppare applicazioni multi-piattaforma che facciano
          buon uso di suoni e grafica.  L'interfaccia SDL fornisce una
          astrazione di basso livello all'hardware che pu&ograve; a volte
          essere pi&ugrave; efficiente dell'interfaccia X11.</para>

        <para>L'SDL pu&ograve; essere trovata in <filename
            role="package">devel/sdl12</filename>.</para>
      </sect3>

      <sect3 id="video-interface-DGA">
        <title>Direct Graphics Access</title>

        <para>Direct Graphics Access &egrave; un'estensione di X11
          che permette a un programma di evitare il server X ed alterare
          direttamente il buffer video.  Siccome si basa su una mappatura
          di memoria a basso livello per effettuare questa condivisione,
          i programmi che la usano devono essere avviati da
          <username>root</username>.</para>

        <para>L'estensione DGA pu&ograve; essere testata con &man.dga.1;.
          Quando <command>dga</command> &egrave; in esecuzione, cambia i colori
          del display ogni volta che viene premuto un tasto.  Per uscire, premi
          <keycap>q</keycap>.</para>
      </sect3>
    </sect2>

    <sect2 id="video-ports">
      <title>Port e Package che Riguardano il Video</title>

      <indexterm><primary>port video</primary></indexterm>
      <indexterm><primary>package video</primary></indexterm>

      <para>In questa sezione si discuter&agrave; del software disponibile
        nella FreeBSD Port Collection che possono essere usati per
        la riproduzione video.  La sezione software sulla riproduzione video
        &egrave; in continuo sviluppo, per cui le caratteristiche delle varie
        applicazioni sono destinate a differire dalla descrizione che
        segue.</para>

      <para>In primo luogo, &egrave; importante sapere che molte delle
        applicazioni video che girano su FreeBSD sono stati sviluppate come
        applicazioni Linux.  Molte di queste applicazioni sono ancora in fase
        beta.  Alcuni dei problemi che puoi incontrare con i package video su
        FreeBSD comprendono:</para>

      <orderedlist>
        <listitem>
          <para>Un'applicazione non riesce a riprodurre un file generato
            da un'altra applicazione.</para>
        </listitem>

        <listitem>
          <para>Un'applicazione non riesce a riprodurre un file che lei
            stessa ha prodotto.</para>
        </listitem>

        <listitem>
          <para>Lo stesso applicativo posto su due computer diversi,
            ricompilato su ognuno dei due computer, riproduce lo stesso
            file in modo diverso.</para>
        </listitem>

        <listitem>
          <para>Da un filtro apparentemente banale quale il ridimensionamento
            di un'immagine si ottenga un pessimo risultato derivato da una
            routine di ridimensionamento bacata.</para>
        </listitem>

        <listitem>
          <para>Un'applicazione che genera frequentemente file
            <quote>core</quote>.</para>
        </listitem>

        <listitem>
          <para>La documentazione non viene installata con il port e pu&ograve;
            essere trovata sul web o nella directory <filename
              class="directory">work</filename> del port.</para>
        </listitem>
      </orderedlist>

      <para>Molte di queste applicazioni possono anche esibire
        <quote>Linuxismi</quote>. Ovvero, ci possono essere problemi risultanti
        dal modo in cui le librerie standard sono state implementate nelle
        distribuzioni Linux, o alcune modifiche al
        kernel di Linux che sono state apportate dagli autori delle
        applicazioni.  Questi problemi possono non essere stati
        notati e aggirati dal mantainer del port, e possono
        portare comunque a problemi come questi:</para>

      <orderedlist>
        <listitem>
          <para>L'uso di <filename>/proc/cpuinfo</filename> per riconoscere
            le caratteristiche del processore.</para>
        </listitem>

        <listitem>
          <para>Un uso errato dei thread che pu&ograve; portare un programma
            a bloccare la propria esecuzione piuttosto che terminare
            correttamente.</para>
        </listitem>

        <listitem>
          <para>Software non ancora presente nella collezione dei port di
            FreeBSD che &egrave; comunemente usato unitamente
            all'applicazione.</para>
        </listitem>
      </orderedlist>

      <para>A questo punto, gli sviluppatori di queste applicazioni sono stati
        collaborativi con i maintainer dei port al fine di minimizzare la
        ricerca di soluzioni necessarie al processo di porting.</para>

      <sect3 id="video-mplayer">
        <title>MPlayer</title>

        <para><application>MPlayer</application> &egrave; stata sviluppata di
          recente ed &egrave; un player in rapida evoluzione.  Gli obbiettivi
          degli sviluppatori di <application>MPlayer</application> sono la
          velocit&agrave; e la flessibilit&agrave; su Linux e le altre famiglie
          di &unix;.  Il progetto &egrave; partito non appena il fondatore del
          gruppo si stanc&ograve; delle prestazioni degli altri riproduttori.
          C'&egrave; chi dice che l'interfaccia grafica sia stata sacrificata
          per un design essenziale.  Tuttavia, una volta che si sono imparate
          perfettamente le opzioni da riga di comando e le scorciatoie,
          funziona decisamente bene.</para>

        <sect4 id="video-mplayer-building">
          <title>Compilazione di MPlayer</title>

          <indexterm>
            <primary>MPlayer</primary>
            <secondary>compilazione</secondary>
          </indexterm>

          <para><application>MPlayer</application> &egrave; reperibile
            sotto <filename role="package">multimedia/mplayer</filename>.
            <application>MPlayer</application>
            effettua una serie di controlli sull'hardware durante il
            processo di compilazione, che ha come risultato un binario
            che non potr&agrave; essere considerato portabile da una
            piattaforma ad un'altra.  Questo &egrave; il motivo per cui
            risulta importante compilarlo usando il port piuttosto che
            il pacchetto contenente il binario.
            Inoltre, ulteriori opzioni possono essere specificate nella riga di
            comando di <command>make</command>, come descritto nel
            <filename>Makefile</filename> e all'inizio della
            compilazione.</para>

          <screen>&prompt.root; <userinput>cd /usr/ports/multimedia/mplayer</userinput>
&prompt.root; <userinput>make</userinput>
N - O - T - E
Take a careful look into the Makefile in order
to learn how to tune mplayer towards you personal preferences!
for example,
make WITH_GTK1
builds MPlayer with GTK1-GUI support.
if you want to use the GUI, you can either install
/usr/ports/multimedia/mplayer-skins
or download official skin collections from
http://www.mplayerhq.hu/homepage/dload.html</screen>

          <para>Le opzioni di default del port dovrebbero essere sufficienti
            per la maggior parte degli utenti.  Tuttavia, se hai bisogno del
            codec XviD, devi specificare l'opzione <makevar>WITH_XVID</makevar>
            nella riga di comando.  Inoltre puoi definire il dispositivo
            DVD di default con l'opzione <makevar>WITH_DVD_DEVICE</makevar>,
            altrimenti sar&agrave; utilizzato di default
            <filename>/dev/acd0</filename>.</para>

          <para>Al momento, il port <application>MPlayer</application>
            creer&agrave; la sua documentazione in HTML e due eseguibili
            <command>mplayer</command>, e <command>mencoder</command>,
            che &egrave; uno strumento per la ri-codifica video.</para>

          <para>La documentazione HTML di <application>MPlayer</application>
            &egrave; molto istruttiva.
            Qualora il lettore trovasse le informazioni sull'hardware e le
            interfacce video in questo capitolo scarne, la documentazione di
            <application>MPlayer</application> risulta essere un ottimo
            supplemento.
            Se si stanno cercando informazioni riguardo il supporto video sotto
            &unix;, sarebbe utile trovare il tempo di leggere in modo preciso
            la documentazione di <application>MPlayer</application>.</para>
        </sect4>

        <sect4 id="video-mplayer-using">
          <title>Utilizzo di MPlayer</title>

          <indexterm>
            <primary>MPlayer</primary>
            <secondary>utilizzo</secondary>
          </indexterm>

          <para>Ogni utente che voglia usare <application>MPlayer</application>
            deve creare la directory <filename>.mplayer</filename> sotto
            la propria home.  Per creare questa directory necessaria, puoi
            digitare il seguente comando:</para>

          <screen>&prompt.user; <userinput>cd /usr/ports/multimedia/mplayer</userinput>
&prompt.user; <userinput>make install-user</userinput></screen>

          <para>Le opzioni del comando <command>mplayer</command> sono elencate
            nella pagina del manuale.  Per qualunque altro dettaglio consulta
            la documentazione HTML.  In questa sezione, descriveremo solamente
            alcuni degli usi pi&ugrave; comuni.</para>

          <para>Per riprodurre un file, ad esempio
            <filename><replaceable>testfile.avi</replaceable></filename>, usando
            una delle varie interfacce video usa l'opzione
            <option>-vo</option>:</para>

          <screen>&prompt.user; <userinput>mplayer -vo xv testfile.avi</userinput></screen>

          <screen>&prompt.user; <userinput>mplayer -vo sdl testfile.avi</userinput></screen>

          <screen>&prompt.user; <userinput>mplayer -vo x11 testfile.avi</userinput></screen>

          <screen>&prompt.root; <userinput>mplayer -vo dga testfile.avi</userinput></screen>

          <screen>&prompt.root; <userinput>mplayer -vo 'sdl:dga' testfile.avi</userinput></screen>

          <para>&Egrave; utile provare tutte queste opzioni, considerando che le
            prestazioni dipendono da svariati fattori e variano in modo
            considerevole a seconda dell'hardware.</para>

          <para>Per riprodurre un DVD, sostituisci
            <filename>testfile.avi</filename> con l'opzione
            <option>dvd://<replaceable>N</replaceable> -dvd-device
              <replaceable>DISPOSITIVO</replaceable></option> dove
            <replaceable>N</replaceable> corrisponde al numero del titolo da
            riprodurre
            e <filename><replaceable>DISPOSITIVO</replaceable></filename> al
            dispositivo che identifica il DVD-ROM.  Per esempio, per riprodurre
            il terzo titolo da <filename>/dev/dvd</filename>:</para>

          <screen>&prompt.root; <userinput>mplayer -vo xv dvd://3 -dvd-device /dev/dvd</userinput></screen>

          <note>
            <para>Il dispositivo DVD di default pu&ograve; essere definito
              durante la compilazione del port
              <application>MPlayer</application> tramite l'opzione
              <makevar>WITH_DVD_DEVICE</makevar>.  Di default, questo
              dispositivo &egrave; <filename>/dev/acd0</filename>.  Maggiori
              dettagli posso essere trovati nel <filename>Makefile</filename>
              del port.</para>
          </note>

          <para>Per interrompere, mettere in pausa, andare avanti e cos&igrave;
            via, leggi l'elenco delle associazioni dei tasti, che
            vengono elencati eseguendo <command>mplayer -h</command> o
            consulta la pagina man.</para>

          <para>Ulteriori opzioni utili per la riproduzione sono:
            <option>-fs -zoom</option> che abilita la modalit&agrave; schermo
            intero e <option>-framedrop</option> che aiuta le
            prestazioni.</para>

          <para>Perch&egrave; la riga di comando di mplayer non diventi
            eccessivamente lunga, l'utente pu&ograve; creare il file
            <filename>.mplayer/config</filename> ed impostare l&igrave; i
            valori predefiniti:</para>

          <programlisting>vo=xv
fs=yes
zoom=yes</programlisting>

          <para>In ultimo, &egrave; possibile usare <command>mplayer</command>
            per estrarre una traccia DVD in un file <filename>.vob</filename>.
            Per estrarre la seconda traccia dal DVD, digita questo:</para>

          <screen>&prompt.root; <userinput>mplayer -dumpstream -dumpfile out.vob dvd://2 -dvd-device /dev/dvd</userinput></screen>

          <para>Il file ottenuto, <filename>out.vob</filename>, sar&agrave;
            in formato MPEG e potr&agrave; manipolato da un'altro programma
            descritto in questa sezione.</para>
        </sect4>

        <sect4 id="video-mencoder">
          <title>mencoder</title>

          <indexterm><primary>mencoder</primary></indexterm>

          <para>Prima di usare <command>mencoder</command> &egrave; una buona
            idea familiarizzare con le opzioni contenute nella
            documentazione HTML.  Esiste anche una pagina man, ma non
            &egrave; utile senza la documentazione HTML.  Esiste un numero
            considerevole di modi per migliorare la qualit&agrave;, un
            bitrate pi&ugrave; basso, cambiare codifica ed alcuni di
            questi trucchi pu&ograve; fare la differenza tra prestazioni
            pi&ugrave; o meno accettabili.  Di seguito un paio di esempi per
            cominciare.  Prima di tutto, una semplice copia:</para>

          <screen>&prompt.user; <userinput>mencoder input.avi -oac copy -ovc copy -o output.avi</userinput></screen>

          <para>Combinazioni errate di opzioni da riga di comando possono
            portare a file di output irriproducibili perfino con
            <command>mplayer</command>.
            Di conseguenza, se si vuole semplicemente estrarre una traccia,
            usare l'opzione <option>-dumpfile</option> eseguendo
            in <command>mplayer</command>.</para>

          <para>Per convertire il file <filename>input.avi</filename>
            in formato MPEG4 con l'audio codificato in MPEG3 (&egrave;
            necessario <filename role="package">audio/lame</filename>):</para>

          <screen>&prompt.user; <userinput>mencoder input.avi -oac mp3lame -lameopts br=192 \
  -ovc lavc -lavcopts vcodec=mpeg4:vhq -o output.avi</userinput></screen>

          <para>Questo comando ha creato un file riproducibile con
            <command>mplayer</command> e <command>xine</command>.</para>

          <para>Il parametro <filename>input.avi</filename> pu&ograve;
            essere sostituito con <option>dvd://1 -dvd-device /dev/dvd</option>
            ed eseguire il comando come <username>root</username> per
            ricodificare il capitolo DVD direttamente.  Poich&egrave;
            si sar&agrave; certamente poco soddisfatti del risultato la prima
            volta, &egrave; consigliato eseguire il dump del capitolo
            e lavorare direttamente sul file.</para>
        </sect4>
      </sect3>

      <sect3 id="video-xine">
        <title>Il Riproduttore Video xine</title>

        <para>Il riproduttore video <application>xine</application> &egrave; un
          progetto dagli ampi obiettivi e non solo l'essere una soluzione
          unica per la riproduzione, ma anche una libreria di base
          riutilizzabile ed un eseguibile modulare che possa essere
          esteso con i plugin.  &Egrave; disponibile sia come pacchetto che
          come port, sotto <filename
            role="package">multimedia/xine</filename>.</para>

        <para><application>xine</application>
          &egrave; ancora un p&ograve; rozzo, ma &egrave; chiaramente un buon
          inizio.
          In pratica, <application>xine</application> necessita sia di una
          CPU veloce che di una scheda video veloce o il supporto per
          l'estensione XVideo.  L'interfaccia grafica &egrave; utilizzabile,
          ma ancora mal disegnata.</para>

        <para>Allo stato attuale, non ci sono moduli distribuiti con
          <application>xine</application> che possano riprodurre DVD
          codificati in CSS.  Esistono distribuzioni di terze parti che
          hanno moduli di questo genere gi&agrave; compilati, ma nessuno
          di questi esiste nella FreeBSD Ports Collection.</para>

        <para>Comparato con <application>MPlayer</application>,
          <application>xine</application> offre maggiori caratteristiche
          all'utente ma, allo stesso tempo, non rende disponibile
          all'utente un controllo pi&ugrave; accurato.  Il riproduttore video
          <application>xine</application> funziona molto meglio sulle interfacce
          XVideo.</para>

        <para>Di default, <application>xine</application> si avvier&agrave; con
          un'interfaccia grafica.  Si possono quindi usare i menu per aprire
          per aprire un file specifico:</para>

        <screen>&prompt.user; <userinput>xine</userinput></screen>

        <para>Alternativamente, pu&ograve; essere invocato per aprire
          direttamente un file senza l'interfaccia grafica, con il
          comando:</para>

        <screen>&prompt.user; <userinput>xine -g -p mymovie.avi</userinput></screen>
      </sect3>

      <sect3 id="video-ports-transcode">
        <title>Le Utility transcode</title>

        <para>Il software <application>transcode</application> non &egrave; un
          riproduttore, piuttosto un insieme di strumenti per ricodificare file
          <filename>.avi</filename> e <filename>.mpg</filename>.  Con
          <application>transcode</application>, si ha la possibilit&agrave; di
          unire file video, riparare file corrotti ed utilizzare strumenti
          da riga di comando con interfaccie che utilizzano i flussi
          <filename>stdin/stdout</filename>.</para>

        <para>Cos&igrave; come <application>MPlayer</application>, anche
          <application>transcode</application> &egrave; un software in
          fase sperimentale che deve essere compilato usando il port
          <filename role="package">multimedia/transcode</filename>.  Sono
          disponibili parecchie opzioni da passare a <command>make</command>.
          Si consiglia:</para>

        <screen>&prompt.root; <userinput>make WITH_LIBMPEG2=yes</userinput></screen>

        <para>Se hai intenzione di installare <filename
            role="package">multimedia/avifile</filename>, allora aggiungi
           l'opzione <literal>WITH_AVIFILE</literal> alla riga di comando di
           <command>make</command>, cos&igrave; come di seguito:</para>

        <screen>&prompt.root; <userinput>make WITH_AVIFILE=yes WITH_LIBMPEG2=yes</userinput></screen>

        <para>Ecco due esempi di come usare <command>transcode</command>
          per la conversione video che produce un output ridimensionato.
          Il primo, codifica il risultato come un file openDIVX AVI,
          mentre il secondo codifica nel formato MPEG, pi&ugrave;
          portabile.</para>

        <screen>&prompt.user; <userinput>transcode -i input.vob -x vob -V -Z 320x240 \
-y opendivx -N 0x55 -o output.avi</userinput></screen>

        <screen>&prompt.user; <userinput>transcode -i input.vob -x vob -V -Z 320x240 \
-y mpeg -N 0x55 -o output.tmp</userinput>
&prompt.user; <userinput>tcmplex -o output.mpg -i output.tmp.m1v -p output.tmp.mpa -m 1</userinput></screen>

        <para>Esiste una pagina man per <command>transcode</command>,
          ma c'&egrave; poca documentazione sulle utility <command>tc*</command>
          (come per esempio <command>tcmplex</command>) che vengono installate.
          Tuttavia, l'opzione a riga di comando <option>-h</option> pu&ograve;
          sempre essere usata per avere delle brevi istruzioni d'uso del
          comando.</para>

        <para>In confronto, <command>transcode</command> gira molto
          pi&ugrave; lentamente rispetto a <command>mencoder</command>, ma
          risulta essere un'ottima alternativa per produrre file in
          formati pi&ugrave; vari.
          Si sa che gli MPEG creati con <command>transcode</command> funzionano
          con <application>&windows.media; Player</application> ed Apple
          <application>&quicktime;</application>, ad esempio.</para>
      </sect3>
    </sect2>

    <sect2 id="video-further-reading">
      <title>Ulteriori Letture</title>

      <para>I vari package di applicazioni video per FreeBSD si stanno
        evolvendo rapidamente.  &Egrave; abbastanza possibile che in un futuro
        vicino molti dei problemi discussi qui saranno risolti.  Nel frattempo,
        chiunque voglia ottenere il massimo dalle
        capacit&agrave; A/V di FreeBSD, dovr&agrave; unire alla meglio la
        conoscenza che deriva dalle svariate FAQ e guide con l'uso di queste
        poche applicazioni.  Questa sezione esiste per fornire al lettore
        indicazioni a queste informazioni aggiuntive.</para>

      <para>La <ulink url="http://www.mplayerhq.hu/DOCS/">Documentazione
          di MPlayer</ulink> &egrave; molto istruttiva sul piano tecnico.
        Questa documentazione, probabilmente, dovr&agrave; essere consultata
        da chiunque voglia ottenere un alto grado di conoscenza del video
        sotto &unix;.  La mailing list di <application>MPlayer</application>
        risulta abbastanza ostile a chiunque non si sia preoccupato di
        leggere la documentazione, se si ha intenzione di segnalar loro un
        bug, RTFM.</para>

      <para>L'<ulink
          url="http://dvd.sourceforge.net/xine-howto/en_GB/html/howto.html">HOWTO
          di xine</ulink> contiene un capitolo su come aumentare le prestazioni
        che &egrave; comune a tutti i riproduttori.</para>

      <para>In ultimo, ci sono alcuni applicativi promettenti che il
        lettore pu&ograve; provare:</para>

      <itemizedlist>
        <listitem>
          <para><ulink
              url="http://avifile.sourceforge.net/">Avifile</ulink> che
            &egrave; anche un port <filename
              role="package">multimedia/avifile</filename>.</para>
        </listitem>

        <listitem>
          <para><ulink
              url="http://www.dtek.chalmers.se/groups/dvd/">Ogle</ulink>
            che &egrave; anche un port <filename
              role="package">multimedia/ogle</filename>.</para>
        </listitem>

        <listitem>
          <para><ulink
              url="http://xtheater.sourceforge.net/">Xtheater</ulink></para>
        </listitem>

        <listitem>
          <para><filename
              role="package">multimedia/dvdauthor</filename>, un package open
            source per la creazione di DVD.</para>
        </listitem>
      </itemizedlist>
    </sect2>
  </sect1>

  <sect1 id="tvcard">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Josef</firstname>

          <surname>El-Rayes</surname>

          <contrib>Contributo originale di </contrib>
        </author>
      </authorgroup>

      <authorgroup>
        <author>
          <firstname>Marc</firstname>

          <surname>Fonvieille</surname>

          <contrib>Ampliato e adattato da </contrib>
        </author>
      </authorgroup>
    </sect1info>

    <title>Configurazione delle Schede TV</title>

    <indexterm><primary>schede TV</primary></indexterm>

    <sect2>
      <title>Introduzione</title>

      <para>Le schede TV permettono di visualizzare la TV via onde radio o via
        cavo sul tuo computer.  La maggior parte di queste accettano in input
        video composito tramite connettori RCA o S-video e alcune di queste
        schede hanno un sintonizzatore radio FM.</para>

      <para>&os; fornisce supporto per le schede TV su bus PCI che usano un
        chip di acquisizione video Brooktree Bt848/849/878/879 o Conexant
        CN-878/Fusion 878a tramite il driver &man.bktr.4;. Devi anche
        assicurarti che la scheda abbia un sintonizzatore supportato, consulta
        la pagina man di &man.bktr.4; per una lista dei sintonizzatori
        supportati.</para>
    </sect2>

    <sect2>
      <title>Aggiunta del Driver</title>

      <para>Per usare la scheda, devi caricare il driver &man.bktr.4;, e questo
        pu&ograve; essere fatto aggiungendo la seguente riga al file
        <filename>/boot/loader.conf</filename> in questo modo:</para>

      <programlisting>bktr_load="YES"</programlisting>

      <para>Alternativamente, puoi compilare staticamente il supporto per la
        scheda TV nel tuo kernel, in questo caso aggiungi le seguenti righe
        alla configurazione del tuo kernel:</para>

      <programlisting>device    bktr
device iicbus
device iicbb
device smbus</programlisting>

      <para>Questi driver aggiuntivi sono necessari poich&eacute; le
        componenti della scheda sono interconnesse tramite un bus I2C.
        Quindi compila ed installa un nuovo kernel.</para>

      <para>Una volta che hai aggiunto il supporto al tuo sistema, devi
        riavviare la macchina.  Durante il processo di avvio, la tua scheda TV
        dovrebbe apparire, come in questo esempio:</para>

      <programlisting>bktr0: &lt;BrookTree 848A&gt; mem 0xd7000000-0xd7000fff irq 10 at device 10.0 on pci0
iicbb0: &lt;I2C bit-banging driver&gt; on bti2c0
iicbus0: &lt;Philips I2C bus&gt; on iicbb0 master-only
iicbus1: &lt;Philips I2C bus&gt; on iicbb0 master-only
smbus0: &lt;System Management Bus&gt; on bti2c0
bktr0: Pinnacle/Miro TV, Philips SECAM tuner.</programlisting>

      <para>Ovviamente questi messaggi possono differire a seconda
        dell'hardware.  Tuttavia dovresti controllare se il sintonizzatore
        viene rilevato correttamente; &egrave; sempre possibile modificare
        alcuni dei parametri rilevati tramite le MIB di &man.sysctl.8; e le
        opzioni nel file di configurazione del kernel.  Ad esempio, se vuoi
        imporre che il sintonizzatore sia un Philips SECAM, dovresti aggiungere
        la riga seguente al file di configurazione del kernel:</para>

      <programlisting>options OVERRIDE_TUNER=6</programlisting>

      <para>o puoi usare direttamente &man.sysctl.8;:</para>

      <screen>&prompt.root; <userinput>sysctl hw.bt848.tuner=6</userinput></screen>

      <para>Guarda la pagina man di &man.bktr.4; e il file
        <filename>/usr/src/sys/conf/NOTES</filename> per maggiori dettagli
        sulle opzioni disponibili.  (Se sei sotto &os;&nbsp;4.X, sostituisci
        <filename>/usr/src/sys/conf/NOTES</filename> con
        <filename>/usr/src/sys/i386/conf/LINT</filename>.)</para>
    </sect2>

    <sect2>
      <title>Applicazioni Utili</title>

      <para>Per usare la tua scheda TV devi installare una delle seguenti
        applicazioni:</para>

      <itemizedlist>
        <listitem>
          <para><filename role="package">multimedia/fxtv</filename>
            fornisce capacit&agrave; di TV-in-una-finestra e acquisizione di
            immagini/audio/video.</para>
        </listitem>

        <listitem>
          <para><filename role="package">multimedia/xawtv</filename>
            &egrave; anch'esso un'applicazione TV, con le stesse caratteristiche
            di <application>fxtv</application>.</para>
        </listitem>

        <listitem>
          <para><filename role="package">misc/alevt</filename> decodifica e
            visualizza Videotext/Teletext.</para>
        </listitem>

        <listitem>
          <para><filename role="package">audio/xmradio</filename>,
            un'applicazione per usare il sintonizzatore radio FM che hanno
            alcune schede TV.</para>
        </listitem>

        <listitem>
          <para><filename role="package">audio/wmtune</filename>,
            un'applicazione desktop maneggevole per i sintonizzatori
            radio.</para>
        </listitem>
      </itemizedlist>

      <para>Altre applicazioni sono disponibili nella &os; Ports
        Collection.</para>
    </sect2>

    <sect2>
      <title>Risoluzione dei Problemi</title>

      <para>Se incontri qualche problema con la tua scheda TV, dovresti
        verificare dapprima se il chip di acquisizione video e il
        sintonizzatore sono realmente supportati dal driver &man.bktr.4; e se
        hai usato le corrette opzioni di configurazione.  Per maggiore supporto
        e varie domande sulla tua scheda video potresti voler leggere ed
        usare gli archivi della mailing list &a.multimedia.name;.</para>
    </sect2>
  </sect1>

  <sect1 id="scanners">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Marc</firstname>

          <surname>Fonvieille</surname>

          <contrib>Scritto da </contrib>
        </author>
      </authorgroup>
    </sect1info>

    <title>Scanner di immagini</title>

    <indexterm><primary>scanner di immagini</primary></indexterm>

    <sect2>
      <title>Introduzione</title>

      <para>&os;, come altri sistemi operativi moderni, permette di usare
        scanner di immagini.  Un accesso standardizzato agli scanner
        &egrave; fornito dalle <acronym role="Interfaccia di Programmazione
          dell'Applicazione">API</acronym> di <application>SANE</application>
        (Scanner Access Now Easy) disponibili nella collezione dei port di &os;.
        <application>SANE</application> usa anche alcuni driver dei dispositivi
        di &os; per accedere all'hardware dello scanner.</para>

      <para>&os; supporta sia scanner SCSI che USB.  Verifica che
        il tuo scanner sia supportato da <application>SANE</application>
        prima di effettuare ogni configurazione.
        <application>SANE</application> ha una lista di <ulink
          url="http://sane-project.org/sane-supported-devices.html">dispositivi
        supportati</ulink>, che pu&ograve; fornire informazioni riguardo il
        supporto per uno scanner ed il suo stato.  La pagina man
        &man.uscanner.4; fornisce una lista di scanner USB supportati.</para>
    </sect2>

    <sect2>
      <title>Configurazione del Kernel</title>

      <para>Come gi&agrave; menzionato, sono supportati sia scanner USB che
        SCSI.  A seconda dell'interfaccia del tuo scanner, sono richiesti
        diversi driver dei dispositivi.</para>

      <sect3 id="scanners-kernel-usb">
        <title>Interfaccia USB</title>

        <para>Il kernel <filename>GENERIC</filename> di default include i
          driver dei dispositivi necessari per il funzionamento degli scanner
          USB.  In caso tu voglia usare un kernel custom, accertati che le linee
          seguenti siano presenti nel tuo file di configurazione del
          kernel:</para>

        <programlisting>device usb
device uhci
device ohci
device uscanner</programlisting>

        <para>A seconda del tipo di chipset USB sulla tua scheda madre,
          hai bisogno solo di una fra le opzioni <literal>device uhci</literal>
          e <literal>device ohci</literal>, comunque avere entrambe le linee nel
          proprio file di configurazione del kernel non crea problemi.</para>

        <para>Se non intendi ricompilare un kernel custom ed il tuo
          kernel non &egrave; il <filename>GENERIC</filename>, puoi
          direttamente caricare il modulo del driver del dispositivo di
          &man.uscanner.4; con il comando &man.kldload.8;:</para>

        <screen>&prompt.root; <userinput>kldload uscanner</userinput></screen>

        <para>Per caricare il modulo ad ogni avvio di sistema, aggiungi la
          seguente linea al file <filename>/boot/loader.conf</filename>:</para>

        <programlisting>uscanner_load="YES"</programlisting>

        <para>Dopo aver riavviato con il kernel corretto, o dopo aver caricato
          il modulo necessario, attacca il tuo scanner USB.  Lo scanner dovrebbe
          apparire nel buffer dei messaggi di sistema (&man.dmesg.8;) in modo
          simile a quanto segue:</para>

        <screen>uscanner0: EPSON EPSON Scanner, rev 1.10/3.02, addr 2</screen>

        <para>Questo mostra che il nostro scanner usa il nodo del dispositivo
          <filename>/dev/uscanner0</filename>.</para>

        <note>
          <para>Su &os;&nbsp;4.X, il demone USB (&man.usbd.8;) deve
            essere in esecuzione per poter vedere i dispositivi USB.  Per
            abilitarlo, aggiungi <literal>usbd_enable="YES"</literal> al tuo
            file <filename>/etc/rc.conf</filename> e riavvia la macchina.</para>
        </note>
      </sect3>

      <sect3>
        <title>Interfaccia SCSI</title>

        <para>Se il tuo scanner possiede un'interfaccia SCSI, &egrave;
          importante sapere quale controller SCSI usi.  A seconda del chipset
          SCSI usato, dovrai modificare il tuo file di configurazione
          del kernel.  Il kernel <filename>GENERIC</filename> supporta
          i pi&ugrave; comuni controller SCSI.  Accertati di leggere il file di
          <filename>NOTES</filename> (<filename>LINT</filename> sotto
          &os;&nbsp;4.X) e aggiungi la linea corretta al tuo file di
          configurazione del kernel.  Oltre al driver dell'interfaccia SCSI,
          devi avere le seguenti linee nel tuo file di configurazione
          del kernel:</para>

        <programlisting>device scbus
device pass</programlisting>

        <para>Una volta che il kernel &egrave; stato correttamente compilato,
          dovresti vedere i dispositivi nel buffer dei messaggi di sistema,
          al momento del boot:</para>

        <screen>pass2 at aic0 bus 0 target 2 lun 0
pass2: &lt;AGFA SNAPSCAN 600 1.10&gt; Fixed Scanner SCSI-2 device
pass2: 3.300MB/s transfers</screen>

        <para>Se il tuo scanner non era acceso al momento dell'avvio, &egrave;
          ancora possibile forzare manualmente il riconoscimento attraverso uno
          scan del bus SCSI con il comando &man.camcontrol.8;:</para>

        <screen>&prompt.root; <userinput>camcontrol rescan all</userinput>
Re-scan of bus 0 was successful
Re-scan of bus 1 was successful
Re-scan of bus 2 was successful
Re-scan of bus 3 was successful</screen>

        <para>A questo punto lo scanner apparir&agrave; nella lista
          dei device SCSI:</para>

        <screen>&prompt.root; <userinput>camcontrol devlist</userinput>
&lt;IBM DDRS-34560 S97B&gt;              at scbus0 target 5 lun 0 (pass0,da0)
&lt;IBM DDRS-34560 S97B&gt;              at scbus0 target 6 lun 0 (pass1,da1)
&lt;AGFA SNAPSCAN 600 1.10&gt;           at scbus1 target 2 lun 0 (pass3)
&lt;PHILIPS CDD3610 CD-R/RW 1.00&gt;     at scbus2 target 0 lun 0 (pass2,cd0)</screen>

        <para>Ulteriori dettagli sui dispositivi SCSI sono
          disponibili nelle pagine man &man.scsi.4; e &man.camcontrol.8;.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Configurazione di SANE</title>

      <para>Il sistema <application>SANE</application> &egrave;
        diviso in due parti: il backend (<filename
          role="package">graphics/sane-backends</filename>) ed il frontend
        (<filename role="package">graphics/sane-frontends</filename>).
        La parte backend fornisce accesso allo scanner.  La lista dei
        <ulink
          url="http://sane-project.org/sane-supported-devices.html">dispositivi
          supportati</ulink> da <application>SANE</application> specifica quale
        backend supporta il tuo scanner di immagini.  &Egrave; necessario
        determinare il corretto backend per il tuo scanner se intendi usare il
        tuo dispositivo.  La parte frontend fornisce l'interfaccia grafica
        allo scanning (<application>xscanimage</application>).</para>

      <para>La prima cosa da fare &egrave; installare il port o il pacchetto
        <filename role="package">graphics/sane-backends</filename>.
        Quindi, usa il comando <command>sane-find-scanner</command>
        per verificare il riconoscimento dello scanner da parte
        del sistema <application>SANE</application>:</para>

      <screen>&prompt.root; <userinput>sane-find-scanner -q</userinput>
found SCSI scanner "AGFA SNAPSCAN 600 1.10" at /dev/pass3</screen>

      <para>L'output mostrer&agrave; il tipo di interfaccia dello
        scanner ed il nodo del dispositivo usato per connettere lo scanner
        al sistema.  La marca ed il nome del modello potrebbero
        non comparire, non &egrave; importante.</para>

      <note>
        <para>Alcuni scanner USB richiedono il caricamento di un firmware,
          ci&ograve; &egrave; spiegato nella pagina man del backend.  &Egrave;
          utile anche leggere le pagine man di &man.sane-find-scanner.1; e di
          &man.sane.7;.</para>
      </note>

      <para>Adesso dobbiamo verificare se lo scanner sar&agrave; identificato
        da un frontend di scanning.  Di default, il backend di
        <application>SANE</application> fornisce un programma da linea di
        comando chiamato &man.scanimage.1;.  Questo comando ti permette di
        elencare i dispositivi ed effettuare un'acquisizione di immagini da
        linea di comando.  L'opzione <option>-L</option> &egrave; usata per
        ottenere una lista di scanner:</para>

      <screen>&prompt.root; <userinput>scanimage -L</userinput>
device `snapscan:/dev/pass3' is a AGFA SNAPSCAN 600 flatbed scanner</screen>

      <para>Nessun output o un messaggio che dice che nessuno scanner
        &egrave; stato identificato indica che &man.scanimage.1; non &egrave;
        in grado di identificare lo scanner.  Se ci&ograve; succede, dovrai
        editare il file di configurazione del backend ed indicare il driver
        del dispositivo usato dallo scanner.  La directory <filename
          class="directory">/usr/local/etc/sane.d/</filename> contiene tutti i
        file di configurazione del backend.  Questo problema di identificazione
        avviene con alcuni scanner USB.</para>

      <para>Ad esempio, usando <xref linkend="scanners-kernel-usb">,
        <command>sane-find-scanner</command> su uno scanner USB otteniamo
        la seguente informazione:</para>

      <screen>&prompt.root; <userinput>sane-find-scanner -q</userinput>
found USB scanner (UNKNOWN vendor and product) at device
/dev/uscanner0</screen>

      <para>Lo scanner &egrave; stato riconosciuto correttamente, usa
        l'interfaccia USB ed &egrave; attaccato al nodo del dispositivo
        <filename>/dev/uscanner0</filename>.  Ora possiamo testare
        se lo scanner &egrave; correttamente identificato:</para>

      <screen>&prompt.root; <userinput>scanimage -L</userinput>

Nessun scanner &egrave; stato identificato. Se ti aspettavi qualcosa di diverso,
verifica che lo scanner sia collegato, accendilo e avvia il tool di
riconoscimento degli scanner di sane (se adatto). Per cortesia leggi la
documentazione fornita con questo software (README, FAQ, pagine man).</screen>

      <para>Dato che lo scanner non &egrave; stato identificato, dovremo editare
        il file <filename>/usr/local/etc/sane.d/epson.conf</filename>.
        Il modello di scanner usato &egrave; l'&epson.perfection; 1650,
        cos&igrave; sappiamo che user&agrave; il backend
        <literal>epson</literal>.  Accertati di leggere i commenti di aiuto nei
        file di configurazione del backend.  Le modifiche alle linee sono
        abbastanza semplici: commenta tutte le linee che hanno un'interfaccia
        non adatta al tuo scanner (nel nostro caso, commenteremo tutte le linee
        che iniziano con la parola <literal>scsi</literal> dato che il nostro
        scanner usa l'interfaccia USB), quindi aggiungi alla fine del
        file una linea che specifica l'interfaccia ed il nodo di dispositivo
        usato.  In questo caso, aggiungiamo la seguente linea:</para>

      <programlisting>usb /dev/uscanner0</programlisting>

      <para>Sei invitato a leggere i commenti presenti nel file di
        configurazione del backend cos&igrave; come le pagine man del backend
        per pi&ugrave; dettagli e per la corretta sintassi da usare.  Ora
        possiamo verificare se lo scanner &egrave; identificato:</para>

      <screen>&prompt.root; <userinput>scanimage -L</userinput>
device `epson:/dev/uscanner0' is a Epson GT-8200 flatbed scanner</screen>

      <para>Il nostro scanner USB &egrave; stato riconosciuto.
        Non &egrave; importante se la marca ed il modello non coincidono.
        Il punto principale a cui prestare attenzione &egrave; il campo
        <literal>`epson:/dev/uscanner0'</literal>, che ci d&agrave; il
        corretto nome del backend ed il corretto nodo del dispositvo.</para>

      <para>Una volta che il comando <command>scanimage -L</command>
        &egrave; in grado di vedere lo scanner, la configurazione
        &egrave; completa.  Il dispositivo ora &egrave; in grado di
        scannerizzare.</para>

      <para>Mentre &man.scanimage.1; ci permette di effettuare
        l'acquisizione di un'immagine dalla linea di comando, &egrave;
        preferibile usare un'interfaccia grafica per effettuare
        scansioni di immagini.  <application>SANE</application>
        offre una semplice ma efficace interfaccia grafica:
        <application>xscanimage</application> (<filename
          role="package">graphics/sane-frontends</filename>).</para>

      <para><application>Xsane</application> (<filename
          role="package">graphics/xsane</filename>) &egrave; un altro comune
        frontend grafico di scanning.  Questo frontend offre caratteristiche
        avanzate come varie tecniche di scanning (fotocopia, fax, etc.),
        correzione del colore, scans multipli, etc.  Entrambe queste
        applicazioni sono fruibili come plugin di
        <application>GIMP</application>.</para>
    </sect2>

    <sect2>
      <title>Permettere Accesso allo Scanner ad Altri Utenti</title>

      <para>Tutte le operazioni precedenti sono state compiute
        con privilegi di <username>root</username>.  Tuttavia potresti aver
        bisogno che altri utenti abbiano accesso allo scanner.  L'utente
        necessiter&agrave; permessi di lettura e scrittura sul nodo di
        dispositivo usato dallo scanner.  Per esempio, il nostro scanner USB
        usa il nodo di dispositivo <filename>/dev/uscanner0</filename> che
        appartiene al gruppo <groupname>operator</groupname>.  Aggiungendo
        l'utente <username>joe</username> al gruppo
        <groupname>operator</groupname> gli permetter&agrave; di usare lo
        scanner:</para>

      <screen>&prompt.root; <userinput>pw groupmod operator -m <replaceable>joe</replaceable></userinput></screen>

      <para>Per maggiori informazioni consulta la pagina man di &man.pw.8;.
        Inoltre devi settare corretamente i permessi di scrittura (0660 o 0664)
        per il nodo del dispositivo <filename>/dev/uscanner0</filename>; di 
        default il gruppo <groupname>operator</groupname> pu&ograve; solo
        leggere questo nodo di dispositivo.  Tale operazione pu&ograve; essere
        realizzata aggiungendo la seguente riga al file
        <filename>/etc/devfs.rules</filename>:</para>

      <programlisting>[system=5]
add path uscanner0 mode 660</programlisting>

      <para>Quindi aggiungi la seguente riga al file
        <filename>/etc/rc.conf</filename> e riavvia la macchina:</para>

      <programlisting>devfs_system_ruleset="system"</programlisting>

      <para>Ulteriori informazioni riguardo queste righe possono essere trovate
        nella pagina man di &man.devfs.8;.  Con &os;&nbsp;4.X, il gruppo 
        <groupname>operator</groupname> ha, di default, i permessi di lettura 
        e di scrittura per il nodo di dispositivo
        <filename>/dev/uscanner0</filename>.</para>

      <note>
        <para>Chiaramente, per ragioni di sicurezza, dovresti pensarci due
          volte prima di aggiungere un utente a qualsiasi gruppo, specialmente
          al gruppo <groupname>operator</groupname>.</para>
      </note>
    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
