<?xml version="1.0" encoding="iso-8859-15"?>
<!--
     The FreeBSD Italian Documentation Project

     $FreeBSD$
     Original revision: 1.108
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="serialcomms">
  <title>Comunicazioni Seriali</title>

  <sect1 xml:id="serial-synopsis">
    <title>Sinossi</title>

    <indexterm><primary>comunicazioni seriali</primary></indexterm>

    <para>&unix; ha sempre avuto un supporto per le  comunicazioni seriali.
      In effetti, le prime vere macchine &unix; si appoggiavano a linee seriali
      per l'input e l'output da e verso l'utente.  Le cose sono cambiate molto
      dai giorni in cui un <quote>terminale</quote> consisteva in una stampante
      da 10 caratteri al secondo o in una tastiera.
      Questo capitolo coprirà alcuni dei modi nei quali
      FreeBSD usa le comunicazioni seriali.</para>

    <para>Dopo aver letto questo capitolo, saprai:</para>

    <itemizedlist>
      <listitem>
        <para>Come connettere terminali al tuo sistema FreeBSD.</para>
      </listitem>

      <listitem>
        <para>Come usare un modem per collegarti telefonicamente
          ad una macchina remota.</para>
      </listitem>

      <listitem>
        <para>Come permettere a utenti remoti di effettuare
          login sul tuo sistema via modem.</para>
      </listitem>

      <listitem>
        <para>Come avviare il tuo sistema da una console seriale.</para>
      </listitem>
    </itemizedlist>

    <para>Prima di leggere questo capitolo, dovresti:</para>

    <itemizedlist>
      <listitem>
        <para>Sapere come configurare ed installare un nuovo kernel
          (<xref linkend="kernelconfig"/>).</para>
      </listitem>

      <listitem>
        <para>Comprendere i permessi ed i processi &unix;
          (<xref linkend="basics"/>).</para>
      </listitem>

      <listitem>
        <para>Avere accesso al manuale tecnico per l'hardware seriale
          (modem o scheda multiporta) che vuoi usare con FreeBSD.</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 xml:id="serial">
    <title>Introduzione</title>

    <sect2 xml:id="serial-terminology">
      <title>Terminologia</title>

      <variablelist>
        <varlistentry>
          <term>bps</term>

          <listitem>
	    <indexterm><primary>bit per secondo</primary></indexterm>

            <para>Bits per Second (Bit per Secondo) &mdash; la frequenza alla
              quale vengono trasmessi i dati</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>DTE</term>

          <listitem>
	    <indexterm><primary>DTE</primary></indexterm>

            <para>Data Terminal Equipment (Attrezzatura per il Terminale Dati)
              &mdash; ad esempio, il tuo computer</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>DCE</term>

          <listitem>
	    <indexterm><primary>DCE</primary></indexterm>

            <para>Data Communications Equipment (Attrezzatura per le
              Comunicazioni Dati) &mdash; il tuo modem</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>RS-232</term>

          <listitem>
	    <indexterm><primary>cavi RS-232C</primary></indexterm>

            <para>Standard EIA per le comunicazioni tra hardware seriale</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>Nel parlare della velocità di comunicazione, questa
        sezione non usa il termine <quote>baud</quote>.  Il baud si riferisce
        al numero di transizioni degli stati elettrici che possono essere
        effettuati in un periodo di tempo, mentre i <quote>bps</quote>
        (bit per secondo) sono il termine <emphasis>corretto</emphasis> da usare
        (o almeno non sembra irritare troppo i perfezionisti).</para>
    </sect2>

    <sect2 xml:id="serial-cables-ports">
      <title>Cavi e Porte</title>

      <para>Per collegare un modem o un terminale alla tua macchina FreeBSD,
        avrai bisogno di una porta seriale sul tuo computer e del cavo
        appropriato per il tuo dispositivo seriale.  Se sei già pratico
        con l'hardware ed i cavi necessari, puoi saltare tranquillamente questa
        sezione.</para>

      <sect3 xml:id="term-cables">
        <title>Cavi</title>

        <para>Ci sono parecchi tipi diversi di cavi seriali.  I due
          tipi più comuni per i nostri scopi sono i cavi null-modem
          ed i cavi standard (<quote>dritti</quote>) RS-232.
          La documentazione per il tuo hardware dovrebbe descrivere il tipo
          di cavi necessari.</para>

        <sect4 xml:id="term-cables-null">
          <title>Cavi null-modem</title>

          <indexterm><primary>cavo null-modem</primary></indexterm>

          <para>Un cavo null-modem porta segnali dritti, come il
            <quote>Segnale di Massa</quote>, e segnali incrociati.  Per
            esempio, il pin di <quote>Trasmissione Dati</quote> su un capo
            è il pin di <quote>Ricezione Dati</quote> sull'altro
            capo.</para>

          <para>Puoi costruirti un cavo null-modem da usare con
            i terminali (es., se vuoi una migliore qualità).
            Questa tabella mostra i
            <link linkend="serialcomms-signal-names">segnali</link>
            dell'RS-232C e i numeri dei pin su un connettore DB-25.
            Nota che lo standard richiede il segnale dritto sul pin 1
            chiamato <emphasis>Massa di Protezione</emphasis>,
            anche se questo è spesso omesso.  Alcuni terminali
            funzionano usando solo i pin 2, 3 e 7, mentre altri richiedono
            configurazioni diverse come mostrate negli esempi qui sotto.</para>

          <table frame="none" pgwide="1">
            <title>Cavo Null-Modem DB-25 / DB-25</title>

            <tgroup cols="5">
              <thead>
                <row>
                  <entry align="left">Segnale</entry>

                  <entry align="left">Pin #</entry>

                  <entry/>

                  <entry align="left">Pin #</entry>

                  <entry align="left">Segnale</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>SG</entry>

                  <entry>7</entry>

                  <entry>si connette a</entry>

                  <entry>7</entry>

                  <entry>SG</entry>
                </row>

                <row>
                  <entry>TD</entry>

                  <entry>2</entry>

                  <entry>si connette a</entry>

                  <entry>3</entry>

                  <entry>RD</entry>
                </row>

                <row>
                  <entry>RD</entry>

                  <entry>3</entry>

                  <entry>si connette a</entry>

                  <entry>2</entry>

                  <entry>TD</entry>
                </row>

                <row>
                  <entry>RTS</entry>

                  <entry>4</entry>

                  <entry>si connette a</entry>

                  <entry>5</entry>

                  <entry>CTS</entry>
                </row>

                <row>
                  <entry>CTS</entry>

                  <entry>5</entry>

                  <entry>si connette a</entry>

                  <entry>4</entry>

                  <entry>RTS</entry>
                </row>

                <row>
                  <entry>DTR</entry>

                  <entry>20</entry>

                  <entry>si connette a</entry>

                  <entry>6</entry>

                  <entry>DSR</entry>
                </row>

                <row>
                  <entry>DTR</entry>

                  <entry>20</entry>

                  <entry>si connesso a</entry>

                  <entry>8</entry>

                  <entry>DCD</entry>
                </row>

                <row>
                  <entry>DSR</entry>

                  <entry>6</entry>

                  <entry>si connette a</entry>

                  <entry>20</entry>

                  <entry>DTR</entry>
                </row>

                <row>
                  <entry>DCD</entry>

                  <entry>8</entry>

                  <entry>si connette a</entry>

                  <entry>20</entry>

                  <entry>DTR</entry>
                </row>
              </tbody>
            </tgroup>
          </table>

          <para>Ecco altri due comuni schemi.</para>

          <table frame="none" pgwide="1">
            <title>Cavo Null-Modem DB-9 / DB-9</title>

            <tgroup cols="5">
              <thead>
                <row>
                  <entry align="left">Segnale</entry>

                  <entry align="left">Pin #</entry>

                  <entry/>

                  <entry align="left">Pin #</entry>

                  <entry align="left">Segnale</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>RD</entry>

                  <entry>2</entry>

                  <entry>si connette a</entry>

                  <entry>3</entry>

                  <entry>TD</entry>
                </row>

                <row>
                  <entry>TD</entry>

                  <entry>3</entry>

                  <entry>si connette a</entry>

                  <entry>2</entry>

                  <entry>RD</entry>
                </row>

                <row>
                  <entry>DTR</entry>

                  <entry>4</entry>

                  <entry>si connette a</entry>

                  <entry>6</entry>

                  <entry>DSR</entry>
                </row>

                <row>
                  <entry>DTR</entry>

                  <entry>4</entry>

                  <entry>si connette a</entry>

                  <entry>1</entry>

                  <entry>DCD</entry>
                </row>

                <row>
                  <entry>SG</entry>

                  <entry>5</entry>

                  <entry>si connette a</entry>

                  <entry>5</entry>

                  <entry>SG</entry>
                </row>

                <row>
                  <entry>DSR</entry>

                  <entry>6</entry>

                  <entry>si connette a</entry>

                  <entry>4</entry>

                  <entry>DTR</entry>
                </row>

                <row>
                  <entry>DCD</entry>

                  <entry>1</entry>

                  <entry>si connette a</entry>

                  <entry>4</entry>

                  <entry>DTR</entry>
                </row>

                <row>
                  <entry>RTS</entry>

                  <entry>7</entry>

                  <entry>si connette a</entry>

                  <entry>8</entry>

                  <entry>CTS</entry>
                </row>

                <row>
                  <entry>CTS</entry>

                  <entry>8</entry>

                  <entry>si connette a</entry>

                  <entry>7</entry>

                  <entry>RTS</entry>
                </row>
              </tbody>
            </tgroup>
          </table>

          <table frame="none" pgwide="1">
            <title>Cavo Null-Modem DB-9 / DB-25</title>

            <tgroup cols="5">
              <thead>
                <row>
                  <entry align="left">Segnale</entry>

                  <entry align="left">Pin #</entry>

                  <entry/>

                  <entry align="left">Pin #</entry>

                  <entry align="left">Segnale</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>RD</entry>

                  <entry>2</entry>

                  <entry>si connette a</entry>

                  <entry>2</entry>

                  <entry>TD</entry>
                </row>

                <row>
                  <entry>TD</entry>

                  <entry>3</entry>

                  <entry>si connette a</entry>

                  <entry>3</entry>

                  <entry>RD</entry>
                </row>

                <row>
                  <entry>DTR</entry>

                  <entry>4</entry>

                  <entry>si connette a</entry>

                  <entry>6</entry>

                  <entry>DSR</entry>
                </row>

                <row>
                  <entry>DTR</entry>

                  <entry>4</entry>

                  <entry>si connette a</entry>

                  <entry>8</entry>

                  <entry>DCD</entry>
                </row>

                <row>
                  <entry>SG</entry>

                  <entry>5</entry>

                  <entry>si connette a</entry>

                  <entry>7</entry>

                  <entry>SG</entry>
                </row>

                <row>
                  <entry>DSR</entry>

                  <entry>6</entry>

                  <entry>si connette a</entry>

                  <entry>20</entry>

                  <entry>DTR</entry>
                </row>

                <row>
                  <entry>DCD</entry>

                  <entry>1</entry>

                  <entry>si connette a</entry>

                  <entry>20</entry>

                  <entry>DTR</entry>
                </row>

                <row>
                  <entry>RTS</entry>

                  <entry>7</entry>

                  <entry>si connette a</entry>

                  <entry>5</entry>

                  <entry>CTS</entry>
                </row>

                <row>
                 <entry>CTS</entry>

                  <entry>8</entry>

                  <entry>si connette a</entry>

                  <entry>4</entry>

                  <entry>RTS</entry>
                </row>
              </tbody>
            </tgroup>
          </table>

          <note>
            <para>Quando un pin di un capo si connette a una coppia di pin
              dell'altro capo, questo è solitamente fatto ponendo
              un cavetto tra la coppia di pin nel loro connettore e
              collegando questi con un altro cavo al singolo pin dell'altro
              capo.</para>
          </note>

          <para>Queste sembrano essere le implementazioni più
            popolari.  In altre varianti (spiegate nel libro
            <emphasis>RS-232 Made Easy</emphasis>) SG è connesso a SG, TD
            a RD, RTS e CTS a DCD, DTR a DSR, e vice-versa.</para>
        </sect4>

        <sect4 xml:id="term-cables-std">
          <title>Cavi Standard RS-232C</title>

          <indexterm><primary>cavi RS-232C</primary></indexterm>

          <para>Un cavo seriale standard ha tutti i segnali RS-232C diritti.
            Cioè, il pin di <quote>Trasmissione Dati</quote> su un capo
            del cavo va nel pin di <quote>Trasmissione Dati</quote> sull'altro
            capo.  Questo è il tipo di cavo da usare per collegare un
            modem al tuo sistema FreeBSD, ed è anche appropriato per
            alcuni terminali.</para>
        </sect4>
      </sect3>

      <sect3 xml:id="term-ports">
        <title>Porte</title>

        <para>Le porte seriali sono i dispositivi attraverso i quali vengono
          trasferiti i dati tra il computer FreeBSD ed il terminale.  Questa
          sezione descrive il tipo di porte che esistono e come vengono indicate
          in FreeBSD.</para>

        <sect4 xml:id="term-portkinds">
          <title>Tipi di Porte</title>

          <para>Esistono parecchi tipi di porte seriali.  Prima di comprare o
            costruire un cavo, avrai bisogno di assicurarti che sia adatto alle
            porte sul terminale e sul sistema FreeBSD.</para>

          <para>La maggior parte dei terminali avrà porte DB-25.
            I personal computer, compresi i PC con FreeBSD, avranno porte DB-25
            o DB-9.  Se hai una scheda seriale multiporta nel tuo PC, potresti
            avere porte RJ-12 o RJ-45.</para>

          <para>Guarda la documentazione fornita con l'hardware per
            le specifiche del tipo di porta usata.  Spesso basta anche
            un'ispezione visiva della porta.</para>
        </sect4>

        <sect4 xml:id="term-portnames">
          <title>Nomi delle Porte</title>

          <para>In FreeBSD, si accede ad ogni porta seriale attraverso una voce
            nella directory <filename>/dev</filename>.  Ci sono due differenti
            tipi di voci:</para>

          <itemizedlist>
            <listitem>
              <para>Le porte di ingresso vengono dette
                <filename>/dev/ttydN</filename>
                dove <replaceable>N</replaceable> è il numero di porta,
                cominciando da zero.  Generalmente, puoi usare la porta di
                ingresso per i terminali.  Le porte di ingresso richiedono che
                la linea fornisca un segnale detto data carrier detect (DCD) per
                funzionare correttamente.</para>
            </listitem>

            <listitem>
              <para>Le porte di uscita vengono dette
                <filename>/dev/cuadN</filename>.
                In genere non si usano porte di uscita per i terminali, ma solo
                per i modem.  Puoi usare la porta di uscita se il cavo seriale
                o il terminale non supportano il segnale di carrier
                detect.</para>

              <note>
                <para>Le porte di uscita sono chiamate
                  <filename>/dev/cuaaN</filename> in
                  &os;&nbsp;5.X e precedenti.</para>
              </note>
            </listitem>
          </itemizedlist>

          <para>Se hai connesso un terminale sulla prima porta seriale
            (<filename>COM1</filename> in &ms-dos;), allora userai
            <filename>/dev/ttyd0</filename> per riferirti al terminale.  Se il
            terminale è sulla seconda porta seriale (anche nota come
            <filename>COM2</filename>), usa
            <filename>/dev/ttyd1</filename>, e così via.</para>
        </sect4>
      </sect3>
    </sect2>

    <sect2>
      <title>Configurazione del Kernel</title>

      <para>FreeBSD supporta quattro porte seriali di default.  Nel mondo
        &ms-dos;, queste sono note come  <filename>COM1</filename>,
        <filename>COM2</filename>, <filename>COM3</filename>, e
        <filename>COM4</filename>.  FreeBSD attualmente supporta
        schede d'interfaccia seriale multiporta <quote>stupide</quote>,
        come le BocaBoard 1008 e 2016, così come le schede multiporta
        intelligenti come quelle fatte dalla Digiboard
        e dalla Stallion Technologies.  Ad ogni modo, il kernel di default
        usa solo le porte COM standard.</para>

      <para>Per vedere se il tuo kernel riconosce una delle tue porte seriali,
        guarda i messaggi mentre il kernel viene avviato, o usa il comando
        <command>/sbin/dmesg</command> per far scorrere di nuovo i
        messaggi di avvio del kernel.  In particolare, cerca dei messaggi
        che inizino con i caratteri <literal>sio</literal>.</para>

      <tip>
        <para>Per vedere solo i messaggi che hanno la parola
          <literal>sio</literal>, usa il comando:</para>

        <screen>&prompt.root; <userinput>/sbin/dmesg | grep 'sio'</userinput></screen>
      </tip>

      <para>Ad esempio, su un sistema con quattro porte seriali, questi sono
        i messaggi dati dall'avvio del kernel specifici delle porte
        seriali:</para>

      <screen>sio0 at 0x3f8-0x3ff irq 4 on isa
sio0: type 16550A
sio1 at 0x2f8-0x2ff irq 3 on isa
sio1: type 16550A
sio2 at 0x3e8-0x3ef irq 5 on isa
sio2: type 16550A
sio3 at 0x2e8-0x2ef irq 9 on isa
sio3: type 16550A</screen>

      <para>Se il tuo kernel non riconosce tutte le tue porte seriali,
        probabilmente devi configurare il kernel sistemando il
        file <filename>/boot/device.hints</filename>.  Inoltre puoi
        commentare o rimuovere completamente le righe dei dispositivi
        che non hai.</para>

      <para>Su &os;&nbsp;4.X devi editare il tuo file di configurazione del
        kernel.  Per informazioni dettagliate sulla configurazione del
        kernel, guarda <xref linkend="kernelconfig"/>.  Le righe dei
        dispositivi interessati dovrebbero essere simili a queste:</para>

      <programlisting>device            sio0    at isa? port IO_COM1 irq 4
device          sio1    at isa? port IO_COM2 irq 3
device          sio2    at isa? port IO_COM3 irq 5
device          sio3    at isa? port IO_COM4 irq 9</programlisting>

      <para>Guarda la pagina man di &man.sio.4;
        per informazioni aggiuntive sulla configurazione delle porte seriali e
        delle schede multiporta.
        Stai attento se stai usando un file di configurazione
        già usato per una versione differente di FreeBSD, poiché
        i flag dei dispositivi e la sintassi sono cambiati tra una versione e
        l'altra.</para>

      <note>
        <para><literal>port IO_COM1</literal> è una sostituzione per
          <literal>port 0x3f8</literal>, <literal>IO_COM2</literal> è
          <literal>0x2f8</literal>, <literal>IO_COM3</literal> è
          <literal>0x3e8</literal>, e <literal>IO_COM4</literal> è
          <literal>0x2e8</literal>, che sono indirizzi comuni per le rispettive
          porte seriali; gli interrupt 4, 3, 5, e 9 sono linee di richiesta di
          interrupt piuttosto comuni.  Da notare anche che le normali porte
          seriali <emphasis>non possono</emphasis> condividere degli interrupt
          sui bus ISA dei PC (le schede multiporta hanno dell'elettronica
          integrata che permette a tutte le 16550A sulla scheda di condividere
          uno o due linee di richiesta dell'interrupt).</para>
      </note>
    </sect2>

    <sect2>
      <title>File Speciali di Dispositivo</title>

      <para>Alla maggior parte dei dispositivi nel kernel si accede attraverso
        <quote>file speciali di dispositivo</quote>, che si trovano
        nella directory <filename>/dev</filename>.  Ai dispositivi
        <filename>sio</filename> si accede attraverso i
        <filename>/dev/ttydN</filename>
        (ingresso) e <filename>/dev/cuadN</filename>
        (uscita).  FreeBSD fornisce anche dei dispositivi di inizializzazione
        (<filename>/dev/ttydN.init</filename> e
        <filename>/dev/cuadN.init</filename> su
        &os;&nbsp;6.X,
        <filename>/dev/ttyidN</filename> e
        <filename>/dev/cuaidN</filename> su
        &os;&nbsp;5.X e precedenti) e
        dispositivi di blocco
        (<filename>/dev/ttydN.lock</filename> e
        <filename>/dev/cuadN.lock</filename> su
        &os;&nbsp;6.X,
        <filename>/dev/ttyldN</filename> e
        <filename>/dev/cualdN</filename> su
        &os;&nbsp;5.X e precedenti).  I
        dispositivi di inizializzazione vengono usati per inizializzare
        i parametri delle porte di comunicazione ogni volta che una porta
        viene aperta, come <literal>crtscts</literal> per i modem che usano
        le segnalazioni <literal>RTS/CTS</literal> per il controllo di flusso.
        I dispositivi di blocco vengono usati per fissare i flag sulle porte
        ed evitare che altri utenti o programmi cambino certi parametri;
        guarda le pagine man di &man.termios.4;, &man.sio.4;, e &man.stty.1;
        per maggiori informazioni sulle impostazioni dei terminali, sui
        dispositivi di blocco ed inizializzazione, e sull'impostazione delle
        opzioni del terminale, rispettivamente.</para>

      <sect3>
        <title>Creazione dei File Speciali di Dispositivo</title>

        <note>
          <para>FreeBSD&nbsp;5.0 include il file system &man.devfs.5;
            che crea automaticamente nodi per i dispositivi necessari.
            Se stai usando una versione di FreeBSD con il
            <literal>devfs</literal> abilitato puoi saltare tranquillamente
            questa sezione.</para>
        </note>

        <para>Uno script di shell di nome <command>MAKEDEV</command> nella
          directory <filename>/dev</filename> gestisce i file di dispositivo.
          Per usare <command>MAKEDEV</command> nella creazione del
          file di dispositivo per <filename>COM1</filename> (porta 0),
          fai <command>cd</command> su <filename>/dev</filename> e dai il
          comando <command>MAKEDEV ttyd0</command>.  Allo stesso modo, per
          creare il file di dispositivo per <filename>COM2</filename>
          (porta 1), usa <command>MAKEDEV ttyd1</command>.</para>

        <para><command>MAKEDEV</command> non crea solo i file speciali
          <filename>/dev/ttydN</filename>,
          ma anche i nodi
          <filename>/dev/cuaaN</filename>,
          <filename>/dev/cuaiaN</filename>,
          <filename>/dev/cualaN</filename>,
          <filename>/dev/ttyldN</filename>, e
          <filename>/dev/ttyidN</filename>.</para>

        <para>Dopo aver creato i nuovi file di dispositivo, fa attenzione nel
          controllare i permessi sui file (specialmente sui file
          <filename>/dev/cua*</filename>) per assicurarti che solo gli
          utenti che dovrebbero effettivamente avere accesso a questi
          dispositivi possano leggerli e
          scriverli &mdash; magari non vorrai permettere al tuo utente medio
          di usare il tuo modem per chiamare verso l'esterno.  I permessi
          predefiniti su
          <filename>/dev/cua*</filename> dovrebbero essere adatti:</para>

        <screen>crw-rw----    1 uucp     dialer    28, 129 Feb 15 14:38 /dev/cuaa1
crw-rw----    1 uucp     dialer    28, 161 Feb 15 14:38 /dev/cuaia1
crw-rw----    1 uucp     dialer    28, 193 Feb 15 14:38 /dev/cuala1</screen>

        <para>Questi permessi permettono all'utente <systemitem class="username">uucp</systemitem> e
          agli utenti nel gruppo <systemitem class="username">dialer</systemitem> di usare i
          dispositivi di uscita.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="serial-hw-config">
      <title>Configurazione della Porta Seriale</title>

    <indexterm><primary><filename>ttyd</filename></primary></indexterm>
    <indexterm><primary><filename>cuad</filename></primary></indexterm>

    <para>Il dispositivo
      <filename>ttydN</filename> (o
      <filename>cuadN</filename>) è il
      normale dispositivo che si apre per le proprie applicazioni.
      Quando un processo apre il dispositivo, avrà un insieme di
      impostazioni di I/O predefinite per il terminale.
      Puoi visualizzare queste impostazioni con il comando:</para>

    <screen>&prompt.root; <userinput>stty -a -f /dev/ttyd1</userinput></screen>

    <para>Quando cambi le impostazioni per questo dispositivo, queste rimangono
      efficaci finché il dispositivo non viene chiuso.  Quando viene
      riaperto, ritorna all'insieme di default.  Per effettuare dei cambiamenti
      all'insieme predefinito, modifica le impostazioni per il dispositivo di
      <quote>stato iniziale</quote>.  Ad esempio,
      per attivare di default modalità <option>CLOCAL</option>,
      comunicazione a 8 bit, e controllo di flusso <option>XON/XOFF</option> per
      <filename>ttyd5</filename>, scrivi:</para>

    <screen>&prompt.root; <userinput>stty -f /dev/ttyd5.init clocal cs8 ixon ixoff</userinput></screen>

    <indexterm>
      <primary>file rc</primary>
      <secondary><filename>rc.serial</filename></secondary>
    </indexterm>

    <para>Le inizializzazioni di sistema per i dispositivi seriali sono
      controllate in <filename>/etc/rc.d/serial</filename>.  Questo file
      influisce sui valori predefiniti dei dispositivi seriali.</para>

    <note>
      <para>Su &os;&nbsp;4.X, l'inizializzazione globale dei
        dispositivi seriali è controllata in
        <filename>/etc/rc.serial</filename>.</para>
    </note>

    <para>Per evitare cambiamenti da parte di qualche applicazione,
      modifica il dispositivo di <quote>blocco dello stato</quote>.
      Ad esempio, per bloccare la velocità di
      <filename>ttyd5</filename> a 57600&nbsp;bps, scrivi:</para>

    <screen>&prompt.root; <userinput>stty -f /dev/ttyd5.lock 57600</userinput></screen>

    <para>Ora, un applicazione che apra <filename>ttyd5</filename> e cerchi
      di cambiare la velocità della porta resterà bloccata a
      57600&nbsp;bps.</para>

    <indexterm><primary><command>MAKEDEV</command></primary></indexterm>

    <para>Naturalmente, dovresti rendere i dispositivi di stato iniziale e stato
      di blocco scrivibili solo da <systemitem class="username">root</systemitem>.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="term">
    <info><title>Terminali</title>
      <authorgroup>
        <author><personname><firstname>Sean</firstname><surname>Kelly</surname></personname><contrib>Contributo di </contrib></author>
      </authorgroup>
    </info>

    

    <indexterm><primary>terminali</primary></indexterm>

    <para>I terminali forniscono un sistema di accesso conveniente ed a basso
      costo al tuo sistema FreeBSD quando non sei davanti alla console del
      computer o connesso ad una rete.  Questa sezione descrive l'uso dei
      terminali con FreeBSD.</para>

    <sect2 xml:id="term-uses">
      <title>Uso e Tipi di Terminali</title>

      <para>I sistemi &unix; originali non avevano console.  Invece, la gente
        effettuava il login ed avviava programmi attraverso terminali connessi
        alle porte seriali del computer.  Ciò era abbastanza simile
        all'uso di modem e programmi terminale per collegarsi telefonicamente
        ad un sistema remoto e lavorare da riga di comando.</para>

      <para>I PC di oggi hanno console capaci di grafica di alta qualità,
        ma l'abilità di stabilire una sessione di login su una porta
        seriale esiste ancora in quasi ogni sistema operativo in stile &unix; di
        oggi; FreeBSD non fa eccezione.
        Usando un terminale attaccato ad una porta seriale inutilizzata, puoi
        effettuare il login ed eseguire qualsiasi programma testuale che
        potresti lanciare normalmente dalla console o da una finestra
        <command>xterm</command> in X Window.</para>

      <para>Un utente aziendale può connettere molti terminali ad un
        sistema FreeBSD e porli sulle scrivanie dei propri impiegati.  Un utente
        casalingo può usare qualcosa come un vecchio PC IBM o un
        &macintosh; come terminale connesso a un computer più potente che
        faccia girare FreeBSD.
        Puoi anche trasformare quello che sarebbe un computer singolo utente in
        un potente sistema per utenti multipli.</para>

      <para>Per FreeBSD, esistono tre tipi di terminali:</para>

      <itemizedlist>
        <listitem>
          <para><link linkend="term-dumb">terminali <quote>stupidi</quote></link></para>
        </listitem>

        <listitem>
          <para><link linkend="term-pcs">PC che interpretano
            terminali</link></para>
        </listitem>

        <listitem>
          <para><link linkend="term-x">terminali X</link></para>
        </listitem>
      </itemizedlist>

      <para>Le sottosezioni rimanenti descrivono ognuno di questi tipi.</para>

      <sect3 xml:id="term-dumb">
        <title>Terminali <quote>Stupidi</quote></title>

        <para>Questi terminali sono oggetti hardware specializzati che
          permettono di connettere dei computer tramite linee seriali.
          Essi vengono detti <quote>stupidi</quote> poiché hanno solo la
          potenza di calcolo necessaria per mostrare, inviare, e ricevere testo.
          Non potete eseguire nessun programma su di essi.
          È il computer al quale vi collegate che ha la potenza
          per eseguire editor di testo, compilatori, email, giochi, e
          così via.</para>

        <para>Ci sono centinaia di tipi di terminali di questo tipo, venduti
          da molti produttori, incluso il VT-100 della Digital Equipment
          Corporation e il WY-75 della Wyse.  Quasi tutti funzioneranno con
          FreeBSD.  Alcuni terminali di alto livello possono anche mostrare
          della grafica, ma solo alcuni
          pacchetti software possono avvalersi di queste caratteristiche.</para>

        <para>I terminali stupidi sono popolari negli ambienti di lavoro nei
          quali i lavoratori non hanno bisogno di accedere ad applicazioni
          grafiche come quelle fornite dal sistema X Window.</para>
      </sect3>

      <sect3 xml:id="term-pcs">
        <title>PC che Emulano Terminali</title>

        <para>Se un <link linkend="term-dumb">terminale stupido</link> ha appena
          le capacità per mostrare, inviare, e ricevere testo, allora di
          certo un qualunque personal computer può funzionare come un
          terminale stupido.
          Tutto ciò di cui hai bisogno è il cavo appropriato ed un
          qualche programma per l'<emphasis>emulazione di terminale</emphasis>
          sul tuo computer.</para>

        <para>Una simile configurazione è comune in molte case.  Ad
          esempio, se il tuo
          coniuge sta lavorando alla console del sistema FreeBSD, tu puoi fare
          del lavoro testuale allo stesso momento da un PC meno potente
          connesso come terminale al sistema FreeBSD.</para>
      </sect3>

      <sect3 xml:id="term-x">
        <title>Terminali X</title>

        <para>I terminali X sono i terminali più sofisticati tra quelli
          disponibili.  Invece di collegarsi alla porta seriale, in genere
          ci si collega ad essi tramite un rete come Ethernet.  Invece di essere
          relegati alle applicazioni testuali, essi possono mostrare
          applicazioni X.</para>

        <para>Introduciamo i terminali X solo per una questione di completezza.
          Ad ogni modo, questo capitolo <emphasis>non</emphasis> affronta in
          modo completo l'installazione, la configurazione, o l'uso dei
          terminali X.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="term-config">
      <title>Configurazione</title>

      <para>Questa sezione descrive quello che hai bisogno di configurare sul
        tuo sistema FreeBSD per abilitare una sessione di login via terminale.
        Si assume che tu abbia già configurato il kernel con il supporto
        per la porta seriale alla quale è connesso il terminale &mdash;
        e che questo sia già connesso.</para>

      <para>Dovresti ricordare dal <xref linkend="boot"/> che il processo
        <command>init</command> è responsabile del controllo di tutti i
        processi e dell'inizializzazione del sistema all'avvio.  Uno dei compiti
        svolti da <command>init</command> è la lettura del file
        <filename>/etc/ttys</filename> e l'avvio di un processo
        <command>getty</command> sui terminali disponibili.
        Il processo <command>getty</command> è responsabile della lettura
        di un nome di login e dell'avvio del programma
        <command>login</command>.</para>

      <para>Dunque, per configurare i terminali per il tuo sistema FreeBSD
        devono essere effettuati come <systemitem class="username">root</systemitem> i seguenti
        passi:</para>

      <procedure>
        <step>
          <para>Aggiungi una linea a <filename>/etc/ttys</filename> relativa al
            file in <filename>/dev</filename> per la porta seriale, se non
            è già presente.</para>
        </step>

        <step>
          <para>Specifica che <command>/usr/libexec/getty</command> deve essere
            eseguito sulla porta, e specifica il tipo appropriato di
            <replaceable>getty</replaceable> dal file
            <filename>/etc/gettytab</filename>.</para>
        </step>

        <step>
          <para>Specifica il tipo di terminale predefinito.</para>
        </step>

        <step>
          <para>Imposta la porta su <quote>on</quote>.</para>
        </step>

        <step>
          <para>Specifica se la porta deve essere
            <quote>sicura</quote>.</para>
        </step>

        <step>
          <para>Forza <command>init</command> alla rilettura del file
            <filename>/etc/ttys</filename>.</para>
        </step>
      </procedure>

      <para>Come passo opzionale, potresti desiderare di creare un tipo di
        <replaceable>getty</replaceable> personale da usare nel secondo passo
        aggiungendo una linea in <filename>/etc/gettytab</filename>.  Questo
        capitolo non spiega come fare ciò; sei incoraggiato a leggere le
        pagine man di &man.gettytab.5; e &man.getty.8; per maggiori
        informazioni.</para>

      <sect3 xml:id="term-etcttys">
        <title>Aggiunta di un Elemento in <filename>/etc/ttys</filename></title>

        <para>Il file <filename>/etc/ttys</filename> elenca tutte le porte
          del tuo sistema FreeBSD dalle quali vuoi permettere un login.
          Ad esempio, la prima console virtuale <filename>ttyv0</filename>
          è elencata in questo file.  Si può accedere al sistema
          dalla console grazie a questa voce.  Questo file contiene anche delle
          voci per altre console virtuali, porte seriali, e pseudo-tty.  Per un
          terminale connesso fisicamente, basta copiare l'elenco delle porte
          seriali in <filename>/dev</filename>
          senza la parte <filename>/dev</filename> (ad esempio,
          <filename>/dev/ttyv0</filename> verrà scritta come
          <filename>ttyv0</filename>).</para>

        <para>Un'installazione predefinita di FreeBSD include un file
          <filename>/etc/ttys</filename> con supporto per le prime
          quattro porte seriali: da <filename>ttyd0</filename> a
          <filename>ttyd3</filename>.  Se vuoi collegare un terminale
          a una di queste porte, non hai bisogno di aggiungere un'altra
          voce.</para>

        <example xml:id="ex-etc-ttys">
          <title>Aggiunta di Voci per Altri Terminali a
            <filename>/etc/ttys</filename></title>

          <para>Supponiamo che si vogliano collegare due terminali ad un
            sistema: un Wyse-50 ed un vecchio PC IBM 286 con
            <application>Procomm</application> come programma di emulazione di
            terminale VT-100.  Colleghiamo il Wyse alla seconda porta seriale
            ed il 286 alla sesta (una porta su scheda seriale multiporta).
            Le voci corrispondenti nel file <filename>/etc/ttys</filename>
            apparirebbero così:</para>

          <programlisting>ttyd1<co xml:id="co-ttys-line1col1"/>  "/usr/libexec/getty std.38400"<co xml:id="co-ttys-line1col2"/>  wy50<co xml:id="co-ttys-line1col3"/>  on<co xml:id="co-ttys-line1col4"/>  insecure<co xml:id="co-ttys-line1col5"/>
ttyd5   "/usr/libexec/getty std.19200"  vt100  on  insecure</programlisting>

          <calloutlist>
            <callout arearefs="co-ttys-line1col1">
              <para>Il primo campo in genere specifica il nome del file
              speciale per il terminale, come si trova in
              <filename>/dev</filename>.</para>
            </callout>

            <callout arearefs="co-ttys-line1col2">
              <para>Il secondo campo è il comando da eseguire per questa
                linea, generalmente &man.getty.8;.
                <command>getty</command> inizializza ed apre la linea,
                imposta la velocità, richiede all'utente un nome di login
                e poi esegue il programma &man.login.1;.</para>

              <para>Il programma <command>getty</command> accetta un parametro
                (opzionale) da riga di comando, il tipo di
                <replaceable>getty</replaceable>.  Un tipo di
                <replaceable>getty</replaceable> configura le caratteristiche
                della linea del terminale, come la frequenza di bit per secondo
                e la parità.  Il programma <command>getty</command> legge
                questa caratteristiche dal file
                <filename>/etc/gettytab</filename>.</para>

              <para>Il file <filename>/etc/gettytab</filename>
                contiene molte voci per le linee di terminale sia vecchie che
                nuove. In quasi tutti i casi, le voci che cominciano per
                <literal>std</literal> funzioneranno con i terminali connessi
                fisicamente. Queste voci ignorano la parità.
                C'è una voce <literal>std</literal> per ogni frequenza di
                bps da 110 a 115200.  Naturalmente, puoi aggiungere le tue
                voci a questo file.  La pagina man di &man.gettytab.5;
                fornisce maggiori informazioni.</para>

              <para>Nell'impostare il tipo di <replaceable>getty</replaceable>
                nel file <filename>/etc/ttys</filename>, assicurati
                che le impostazioni di comunicazione sul terminale
                corrispondano.</para>

              <para>Nel nostro esempio, il Wyse-50 non usa parità e si
                connette a 38400&nbsp;bps.  Il PC&nbsp;286 non usa parità
                e si connette a 19200&nbsp;bps.</para>
            </callout>

            <callout arearefs="co-ttys-line1col3">
              <para>Il terzo campo è il tipo di terminale generalmente
                collegato alla linea tty.  Per le porte dial-up, viene usato
                tipicamente <literal>unknown</literal> o
                <literal>dialup</literal> poiché gli utenti possono
                collegarsi con praticamente qualunque tipo di terminale o
                programma.
                Per i terminali connessi direttamente, il tipo di terminale
                non cambia, quindi puoi mettere un vero tipo di terminale
                preso dal file database di &man.termcap.5; in questo
                campo.</para>

              <para>Per il nostro esempio, il Wyse-50 usa il tipo
                per il vero terminale mentre il PC 286 con
                <application>Procomm</application> in esecuzione
                verrà impostato per emulare un VT-100.</para>
            </callout>

            <callout arearefs="co-ttys-line1col4">
              <para>Il quarto campo specifica se la porta deve essere abilitata.
                Scrivere <literal>on</literal> qui farà sì che il
                processo <command>init</command> avvii il programma nel secondo
                campo, <command>getty</command>.  Se metti
                <literal>off</literal> in questo campo, non ci sarà
                nessun <command>getty</command>, e dunque nessun login sulla
                porta.</para>
            </callout>

            <callout arearefs="co-ttys-line1col5">
              <para>Il campo finale è usato per specificare se la porta
                è sicura.
                Segnare una porta come sicura significa
                confidare nel fatto che non ci sia rischio nel permettere
                all'account di <systemitem class="username">root</systemitem> (o ad un altro con
                user ID uguale a 0) di effettuare il login da quella porta.
                Porte insicure non permettono il login a
                <systemitem class="username">root</systemitem>.
                Su una porta insicura, gli utenti devono effettuare
                un login con accesso non privilegiato, e poi usare &man.su.1; o
                un meccanismo simile per ottenere privilegi superiori.</para>

              <para>È fortemente consigliato l'uso di
                <quote>insecure</quote> anche per i terminali che si trovano
                dietro porte chiuse a chiave.
                È abbastanza semplice effettuare il login e usare
                <command>su</command> se si ha bisogno di privilegi da
                superutente.</para>
            </callout>
          </calloutlist>
        </example>
      </sect3>

      <sect3 xml:id="term-hup">
        <title>Come Forzare <command>init</command> a Rileggere
          <filename>/etc/ttys</filename></title>

        <para>Dopo aver effettuato i cambiamenti necessari al file
          <filename>/etc/ttys</filename> si deve mandare un segnale SIGHUP
          (hangup) al processo <command>init</command> affinché sia
          costretto a rileggere il suo file di configurazione.
          Ad esempio:</para>

        <screen>&prompt.root; <userinput>kill -HUP 1</userinput></screen>

        <note>
          <para><command>init</command> è sempre il primo processo
            eseguito su un sistema dunque avrà sempre PID 1.</para>
        </note>

        <para>Se tutto è stato impostato correttamente, tutti i cavi sono
          collegati, ed i terminali sono accesi, allora un processo
          <command>getty</command> dovrebbe essere in esecuzione su ogni
          terminale e a questo punto dovresti vedere dei prompt per il login sui
          tuoi terminali.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="term-debug">
      <title>Risoluzione dei Problemi di Connessione</title>

      <para>Anche con la più meticolosa attenzione ai dettagli, qualcosa
        potrebbe comunque andare storto nell'impostazione di un terminale.
        Questa è una lista dei sintomi e di alcuni suggerimenti per
        risolverli.</para>

      <sect3>
        <title>Non Appare Nessun Prompt per il Login</title>

        <para>Assicurati che il terminale sia connesso e acceso.
          Se è un personal computer che funziona da terminale,
          assicurati che il programma di emulazione di terminale sia attivo
          sulla porta seriale giusta.</para>

        <para>Assicurati che il cavo sia ben connesso sia al terminale che
          al computer FreeBSD.  Assicurati che sia il giusto tipo di
          cavo.</para>

        <para>Assicurati che il terminale e FreeBSD siano concordi sul
          valore di bps e sulle impostazioni di parità.  Se hai un
          terminale con un display video, assicurati
          che il contrasto e la luminosità siano giusti.  Se è
          un terminale di stampa, assicurati che ci siano carta e inchiostro
          sufficienti.</para>

        <para>Assicurati che il processo <command>getty</command> sia attivo
          per quel terminale.  Ad esempio, per avere una lista dei processi
          <command>getty</command> con <command>ps</command>, scrivi:</para>

        <screen>&prompt.root; <userinput>ps -axww | grep getty</userinput></screen>

        <para>dovresti vedere una voce per il terminale.  Ad esempio,
          la schermata seguente mostra che
          <command>getty</command> è in esecuzione sulla seconda
          porta seriale <literal>ttyd1</literal> e sta usando la voce
          <literal>std.38400</literal> in
          <filename>/etc/gettytab</filename>:</para>

        <screen>22189  d1  Is+    0:00.03 /usr/libexec/getty std.38400 ttyd1</screen>

        <para>Se non c'è nessun processo <command>getty</command> in
          esecuzione, assicurati di aver abilitato la porta in
          <filename>/etc/ttys</filename>.
          Ricordati anche di eseguire <command>kill -HUP 1</command>
          dopo aver modificato il file <filename>ttys</filename>.</para>

        <para>Se il processo <command>getty</command> è attivo ma
          il terminale non mostra ancora un prompt di login,
          o se mostra un prompt ma non ti permette di digitare nulla,
          il tuo terminale o il tuo cavo potrebbero non supportare la
          transazione hardware.  Prova a cambiare il valore in
          <filename>/etc/ttys</filename> da <literal>std.38400</literal> a
          <literal>3wire.38400</literal> (e ricordati di dare un
          <command>kill -HUP 1</command> dopo aver modificato
          <filename>/etc/ttys</filename>).
          La voce <literal>3wire</literal> è simile a
          <literal>std</literal>, ma ignora l'handshake hardware.
          Potresti aver bisogno di ridurre i baud o
          di abilitare un controllo di flusso software usando
          <literal>3wire</literal> per evitare dei buffer
          overflow.</para>
      </sect3>

      <sect3>
        <title>Compaiono Caratteri Strani Invece di un Prompt di Login</title>

        <para>Assicurati che il terminale e FreeBSD siano concordi sui bps
          e sulle impostazioni di parità.  Verifica i processi
          <command>getty</command> per assicurarti che sia in funzione il
          tipo corretto di <replaceable>getty</replaceable>.
          Se non è così,
          modifica <filename>/etc/ttys</filename> ed esegui <command>kill
            -HUP 1</command>.</para>
      </sect3>

      <sect3>
        <title>I Caratteri Appaiono Duplicati; la Password Viene Visualizzata
          Quando la Scrivo</title>

        <para>Cambia l'impostazione del terminale (o del programma di
          emulazione) da <quote>half duplex</quote> o
          <quote>local echo</quote> a <quote>full duplex</quote>.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="dialup">
    <info><title>Servizio di Ricezione Chiamate</title>
      <authorgroup>
        <author><personname><firstname>Guy</firstname><surname>Helmer</surname></personname><contrib>Contributo di </contrib></author>
      </authorgroup>

      <authorgroup>
        <author><personname><firstname>Sean</firstname><surname>Kelly</surname></personname><contrib>Aggiunte di </contrib></author>
      </authorgroup>
    </info>

    

    <indexterm><primary>servizio di ricezione chiamate</primary></indexterm>

    <para>La configurazione del sistema FreeBSD per il servizio di ricezione
      chiamate è molto simile alla connessione di terminali tranne per il
      fatto che si ha a che fare con dei modem invece che con dei
      terminali.</para>

    <sect2>
      <title>Modem Esterni contro Modem Interni</title>

      <para>I modem esterni sembrerebbero migliori per chiamare,
        poiché i modem esterni spesso possono essere configurati in
        maniera semipermanente tramite dei parametri immagazzinati in RAM non
        volatile e generalmente forniscono degli indicatori luminosi che
        mostrano lo stato degli importanti segnali RS-232.  Le lucine
        lampeggianti impressionano gli ospiti, ma sono anche molto
        utili per vedere se un modem sta funzionando in maniera
        appropriata.</para>

      <para>I modem interni in genere mancano della RAM non-volatile, quindi
        la loro configurazione può essere limitata solo impostando i DIP
        switch.  Se il tuo modem interno ha delle luci indicatrici di
        segnale, probabilmente è difficile vederle quando il case del
        sistema è al suo posto.</para>

      <sect3>
        <title>Modem e Cavi</title>

        <indexterm><primary>modem</primary></indexterm>

        <para>Se stai usando un modem esterno, allora avrai bisogno
          del cavo appropriato.  Un cavo seriale standard RS-232C
          dovrebbe essere sufficiente, posto che tutti i normali segnali siano
          connessi:</para>

        <table frame="none" pgwide="1" xml:id="serialcomms-signal-names">
          <title>Nomi dei Segnali</title>

          <tgroup cols="2">
            <thead>
              <row>
                <entry align="left">Acronimi</entry>

                <entry align="left">Nomi</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><acronym>RD</acronym></entry>

                <entry>Ricezione Dati</entry>
              </row>

              <row>
                <entry><acronym>TD</acronym></entry>

                <entry>Trasmissione Dati</entry>
              </row>

              <row>
                <entry><acronym>DTR</acronym></entry>

                <entry>Terminale di Dati Disponibile</entry>
              </row>

              <row>
                <entry><acronym>DSR</acronym></entry>

                <entry>Pronto alla Trasmissione</entry>
              </row>

              <row>
                <entry><acronym>DCD</acronym></entry>

                <entry>Data Carrier Detect (scopre il Segnale di Linea
                  di Ricezione di RS-232)</entry>
              </row>

              <row>
                <entry><acronym>SG</acronym></entry>

                <entry>Segnale di Massa</entry>
              </row>

              <row>
                <entry><acronym>RTS</acronym></entry>

                <entry>Richiesta alla Trasmissione</entry>
              </row>

              <row>
                <entry><acronym>CTS</acronym></entry>

                <entry>Disponibile all'Invio</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>FreeBSD necessita dei segnali <acronym>RTS</acronym> e
          <acronym>CTS</acronym> per il controllo di flusso a velocità
          superiori a 2400&nbsp;bps, del segnale <acronym>CD</acronym> per
          identificare quando c'è stata una risposta alla chiamata o
          quando una linea è stata scollegata, e del
          segnale <acronym>DTR</acronym> per dare il reset al modem dopo che una
          sessione è terminata.  Alcuni cavi sono connessi senza alcuni
          dei segnali necessari, dunque se hai dei problemi, come una sessione
          di login che non scompare quando la linea è sconnessa, potresti
          avere un problema col cavo.</para>

        <para>Come altri sistemi operativi &unix;, FreeBSD usa i segnali
          hardware per scoprire quando una chiamata è stata accettata
          o quando una linea è stata scollegata e per scollegare e
          resettare il modem dopo una chiamata.
          FreeBSD evita di mandare comandi al modem
          o di leggere i valori riportati dal modem.  Se hai familiarità
          con la connessione dei modem a BBS di PC, questo potrebbe sembrarti
          scomodo.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Considerazioni sull'Interfaccia Seriale</title>

      <para>FreeBSD supporta interfacce di comunicazione EIA RS-232C
        (CCITT V.24) basate su NS8250, NS16450, NS16550, e NS16550A.
        I dispositivi 8250 e 16450 hanno buffer di un singolo carattere.
        Il dispositivo 16550 fornisce un buffer di 16 caratteri, che permette
        prestazioni del sistema migliori.  (Dei bug nel normale 16550
        impediscono l'uso del buffer di 16 caratteri, quindi usate 16550A se
        possibile).
        A causa del buffer a singolo carattere questi dispositivi richiedono
        un lavoro maggiore da parte del sistema operativo rispetto ai
        dispositivi a 16 caratteri di buffer, le schede d'interfaccia seriale
        basate su 16550A sono preferibili.  Se il sistema ha molte porte
        seriali attive o dovrà sopportare un grosso carico, le schede
        basate su 16550A sono migliori per comunicazioni a basso tasso
        d'errore.</para>
    </sect2>

    <sect2>
      <title>Breve Panoramica</title>

      <indexterm><primary>getty</primary></indexterm>

      <para>Come con i terminali, <command>init</command> lancia un processo
        <command>getty</command> per ogni porta seriale configurata
        per connessioni in ingresso.  Ad esempio, se un modem è connesso
        a <filename>/dev/ttyd0</filename>, il comando
        <command>ps ax</command> mostrerà questo:</para>

      <screen> 4850 ??  I      0:00.09 /usr/libexec/getty V19200 ttyd0</screen>

      <para>Quando un utente chiama la linea del modem e questo si collega, il
        modem riporterà la linea <acronym>CD</acronym> (Carrier Detect).
        Il kernel nota che la portante è stata rilevata e completa
        l'apertura della porta con <command>getty</command>.
        <command>getty</command> invia un prompt <prompt>login:</prompt> alla
        velocità iniziale di linea specificata.
        <command>getty</command> aspetta per verificare che vengano ricevuti
        caratteri legittimi, e, in una tipica configurazione, se trova dei
        caratteri strani (probabilmente perché la velocità del
        modem è differente da quella di
        <command>getty</command>), <command>getty</command> cerca
        di calibrare la velocità di linea fino a ricevere dei caratteri
        ragionevoli.</para>

      <indexterm>
        <primary><command>/usr/bin/login</command></primary>
      </indexterm>

      <para>Dopo che l'utente ha inserito il suo nome di login,
        <command>getty</command> esegue
        <filename>/usr/bin/login</filename>, che completa il login
        richiedendo la password per l'utente ed avviandone la shell.</para>
    </sect2>

    <sect2>
      <title>File di Configurazione</title>

      <para>Ci sono tre file di configurazione di sistema nella directory
        <filename>/etc</filename> che avrai probabilmente bisogno di modificare
        per permettere chiamate in ingresso sul tuo sistema FreeBSD.  Il primo,
        <filename>/etc/gettytab</filename>, contiene le informazioni di
        configurazione per il demone <filename>/usr/libexec/getty</filename>.
        Il secondo, <filename>/etc/ttys</filename> contiene le informazioni che
        dicono a <filename>/sbin/init</filename> quali dispositivi
        <filename>tty</filename> devono avere processi <command>getty</command>
        in esecuzione.
        Infine, si possono mettere comandi di inizializzazione nello script
        <filename>/etc/rc.d/serial</filename>.</para>

      <para>Ci sono due scuole di pensiero riguardo i modem su &unix;.
        Un gruppo preferisce configurare i propri modem in maniera che
        qualunque sia la velocità con la quale un utente remoto si
        collega, l'interfaccia locale RS-232 computer-modem funzioni ad una
        velocità fissa.
        Il beneficio di questa configurazione è che l'utente
        remoto vede sempre un prompt di login immediato.
        Il lato negativo è che il sistema non sa quale sia la vera
        velocità di trasmissione
        dati di un utente, quindi programmi a tutto schermo come Emacs
        non modificheranno i loro metodi di rappresentazione dello schermo per
        ottimizzare la risposta su connessioni lente.</para>

      <para>L'altra scuola di pensiero configura le proprie interfacce RS-232
        verso il modem per variare la propria velocità rispetto a quella
        di connessione dell'utente remoto.
        Ad esempio, le connessioni V.32bis (14.4&nbsp;Kbps) faranno sì
        che il modem faccia funzionare la propria interfaccia RS-232 a
        19.2&nbsp;Kbps, mentre le connessioni a 2400&nbsp;bps faranno sì
        che funzioni a 2400&nbsp;bps.
        Poiché <command>getty</command> non comprende nessun valore
        restituito dal modem riguardo la velocità di connessione,
        <command>getty</command> darà un messaggio
        <prompt>login:</prompt> ad una velocità iniziale fissata e
        aspetterà i caratteri in risposta.  Se l'utente vede caratteri
        strani, si assume che sappia che dovrà premere
        <keycode>Invio</keycode> finché non vedrà un prompt
        riconoscibile.  Se le frequenze di trasmissione non concordano,
        <command>getty</command> vedrà tutto ciò che l'utente
        preme come <quote>spazzatura</quote>, cercherà di passare alla
        velocità seguente e invierà
        il prompt <prompt>login:</prompt> di nuovo.  Questa procedura
        potrebbe continuare ad nauseam, ma normalmente ci vogliono solo una o
        due pressioni sui tasti prima che l'utente veda un buon prompt.
        Ovviamente, questa
        sequenza di login non è pulita come la precedente a
        <quote>velocità fissata</quote>, ma un utente su una
        connessione a bassa velocità dovrebbe ricevere una risposta
        interattiva migliore da programmi a tutto schermo.</para>

      <para>Questa sezione cercherà di fornire informazioni di
        configurazione bilanciate, ma è indirizzata verso l'approccio di
        avere la frequenza di trasmissione del modem
        che segue la velocità della connessione.</para>

      <sect3>
        <title><filename>/etc/gettytab</filename></title>

        <indexterm>
          <primary><filename>/etc/gettytab</filename></primary>
        </indexterm>

        <para><filename>/etc/gettytab</filename> è un file di
          configurazione sul modello di &man.termcap.5; per &man.getty.8;.
          Si prega di vedere la pagina man di &man.gettytab.5; per le
          informazioni complete sul formato del file
          e la lista delle sue possibilità.</para>

        <sect4>
          <title>Configurazione a Velocità Fissa</title>

          <para>Se stai fissando la frequenza di comunicazione del modem  ad
            una velocità particolare, probabilmente non avrai bisogno di
            effettuare nessun cambiamento a
            <filename>/etc/gettytab</filename>.</para>
        </sect4>

        <sect4>
          <title>Configurazione a Velocità Concordata</title>

          <para>C'è bisogno di impostare una voce in
            <filename>/etc/gettytab</filename> per dare a
            <command>getty</command> le informazioni sulla velocità che
            si vuole usare per il modem.  Se si possiede un modem a
            2400&nbsp;bps, probabilmente è possibile usare
            la voce <literal>D2400</literal> già esistente.</para>

          <programlisting>#
# Terminali chiamanti veloci, a rotazione 2400/1200/300
# (può impostarsi in tutti i modi)
#
D2400|d2400|Fast-Dial-2400:\
        :nx=D1200:tc=2400-baud:
3|D1200|Fast-Dial-1200:\
        :nx=D300:tc=1200-baud:
5|D300|Fast-Dial-300:\
        :nx=D2400:tc=300-baud:</programlisting>

          <para>Se si possiede un modem con velocità maggiore,
            probabilmente sarà necessario
            aggiungere una voce in <filename>/etc/gettytab</filename>; qui
            c'è un esempio per modem a 14.4&nbsp;Kbps modem con una
            velocità massima d'interfaccia di 19.2&nbsp;Kbps:</para>

          <programlisting>#
# Aggiunte per un modem V.32bis
#
um|V300|High Speed Modem at 300,8-bit:\
        :nx=V19200:tc=std.300:
un|V1200|High Speed Modem at 1200,8-bit:\
        :nx=V300:tc=std.1200:
uo|V2400|High Speed Modem at 2400,8-bit:\
        :nx=V1200:tc=std.2400:
up|V9600|High Speed Modem at 9600,8-bit:\
        :nx=V2400:tc=std.9600:
uq|V19200|High Speed Modem at 19200,8-bit:\
        :nx=V9600:tc=std.19200:</programlisting>

          <para>Questo risulterà in una connessione a 8-bit, senza
            parità.</para>

          <para>L'esempio precedente avvia la comunicazione a 19.2&nbsp;Kbps
            (per una connessione V.32bis), poi cicla tra 9600&nbsp;bps (per
            V.32), 2400&nbsp;bps, 1200&nbsp;bps, 300&nbsp;bps, e poi ancora a
            19.2&nbsp;Kbps.
            Il ciclo sulle frequenze di comunicazione è implementato con
            <literal>nx=</literal> (<quote>next table</quote>).
            Ogni linea usa una voce <literal>tc=</literal> (<quote>table
            continuation</quote>) per continuare a leggere le impostazioni
            <quote>standard</quote> per una frequenza particolare.</para>

          <para>Se hai un modem a 28.8&nbsp;Kbps e/o vuoi avvantaggiarti della
            compressione su un modem a 14.4&nbsp;Kbps, hai bisogno di usare una
            frequenza di comunicazione più alta di 19.2&nbsp;Kbps.  Qui
            c'è un esempio di voce per <filename>gettytab</filename> che
            imposta la velocità a 57.6&nbsp;Kbps:</para>

          <programlisting>#
# Aggiunte per modem  V.32bis o V.34 Modem
# Impostazione a 57.6 Kbps
#
vm|VH300|Very High Speed Modem at 300,8-bit:\
        :nx=VH57600:tc=std.300:
vn|VH1200|Very High Speed Modem at 1200,8-bit:\
        :nx=VH300:tc=std.1200:
vo|VH2400|Very High Speed Modem at 2400,8-bit:\
        :nx=VH1200:tc=std.2400:
vp|VH9600|Very High Speed Modem at 9600,8-bit:\
        :nx=VH2400:tc=std.9600:
vq|VH57600|Very High Speed Modem at 57600,8-bit:\
        :nx=VH9600:tc=std.57600:</programlisting>

          <para>Se hai una CPU lenta o un carico di sistema pesante e non hai
            porte seriale 16550A, potresti ricevere errori
            <errorname>sio</errorname> <quote>silo</quote> a
            57.6&nbsp;Kbps.</para>
        </sect4>
      </sect3>

      <sect3 xml:id="dialup-ttys">
        <title><filename>/etc/ttys</filename></title>

        <indexterm><primary><filename>/etc/ttys</filename></primary></indexterm>

        <para>La configurazione del file <filename>/etc/ttys</filename>
          è stata affrontata nella <xref linkend="ex-etc-ttys"/>.
          La configurazione dei modem è simile ma dobbiamo passare
          un argomento differente a <command>getty</command> e specificare un
          tipo di terminale differente.  Il formato generale per la
          configurazione sia a velocità fissata che per quella
          concordata è:</para>

        <programlisting>ttyd0   "/usr/libexec/getty <replaceable>xxx</replaceable>"   dialup on</programlisting>

        <para>Il primo elemento nella linea precedente è il file di
          dispositivo per questa voce &mdash; <literal>ttyd0</literal> significa
          che <filename>/dev/ttyd0</filename> è il file che verrà
          tenuto d'occhio da <command>getty</command>.  Il secondo elemento,
          <literal>"/usr/libexec/getty xxx"</literal>
          (<replaceable>xxx</replaceable> verrà rimpiazzato dalla
          capacità iniziale di <filename>gettytab</filename>) è
          il processo che  <command>init</command> eseguirà sul
          dispositivo.  Il terzo elemento, <literal>dialup</literal>, è
          il tipo predefinito di terminale.  Il quarto parametro,
          <literal>on</literal>, indica a <command>init</command> che quella
          linea è operativa.  Potrebbe esserci un quinto parametro,
          <literal>secure</literal>, ma dovrebbe essere usato solo per i
          terminali che siano fisicamente sicuri (come la console di
          sistema).</para>

        <para>Il tipo di terminale predefinito (<literal>dialup</literal>
          nell'esempio precedente) potrebbe dipendere dalle preferenze locali.
          <literal>dialup</literal> è il terminale tradizionale
          predefinito sulle linee di ingresso in maniera che gli utenti possano
          personalizzare i loro script di login per notare quando il terminale
          è <literal>dialup</literal> e modificare
          automaticamente il loro tipo di terminale.  Ad ogni modo, l'autore
          ritiene più semplice specificare <literal>vt102</literal> come
          tipo di terminale predefinito, poiché l'utente può usare
          semplicemente un'emulazione VT102 sul suo sistema remoto.</para>

        <para>Dopo aver effettuato i cambiamenti a
          <filename>/etc/ttys</filename>, puoi inviare un segnale
          <acronym>HUP</acronym> a <command>init</command> per fargli
          rileggere il file.  Puoi usare il comando
          <screen>&prompt.root; <userinput>kill -HUP 1</userinput></screen>
          per inviare il segnale.  Se questa è la prima volta che cambi
          le impostazioni del sistema, puoi aspettare finché il modem non
          sia configurato in maniera appropriata e connesso, prima di inviare il
          segnale a <command>init</command>.</para>

        <sect4>
          <title>Configurazione a Velocità Fissa</title>

          <para>Per una configurazione a velocità fissa, la voce
            in <filename>ttys</filename> ha bisogno di una voce che gestisca la
            velocità fissa anche per <command>getty</command>.
            Per un modem la cui velocità sulla porta
            sia bloccata a 19.2&nbsp;Kbps, la voce in <filename>ttys</filename>
            potrebbe essere così:</para>

          <programlisting>ttyd0   "/usr/libexec/getty std.19200"   dialup on</programlisting>

          <para>Se il tuo modem è bloccato su una frequenza di
            trasmissione differente, sostituisci il valore appropriato per
            <literal>std.velocità</literal>
            al posto di <literal>std.19200</literal>.  Assicurati di usare
            un tipo valido elencato in
            <filename>/etc/gettytab</filename>.</para>
        </sect4>

        <sect4>
          <title>Configurazione a Velocità Concordata</title>

          <para>In una configurazione a velocità concordata, la voce in
            <filename>ttys</filename> deve fare riferimento alla voce
            iniziale <quote>auto-baud</quote> (sic) in
            <filename>/etc/gettytab</filename>.  Ad esempio, se hai aggiunto la
            riga suggerita precedentemente per un modem con velocità
            variabile che inizi a 19.2 Kbps (la riga in
            <filename>gettytab</filename> contenente
            il punto d'avvio <literal>V19200</literal>), la riga in
            <filename>ttys</filename> potrebbe essere questa:</para>

          <programlisting>ttyd0   "/usr/libexec/getty V19200"   dialup on</programlisting>
        </sect4>
      </sect3>

      <sect3>
        <title><filename>/etc/rc.d/serial</filename></title>

        <indexterm>
          <primary>file rc</primary>
          <secondary><filename>rc.serial</filename></secondary>
        </indexterm>

        <para>I modem ad alta velocità, come i V.32, i V.32bis, e i V.34,
          necessitano di un controllo di flusso hardware
          (<literal>RTS/CTS</literal>).
          Puoi aggiungere dei comandi <command>stty</command> al file
          <filename>/etc/rc.d/serial</filename> per impostare i
          flag di controllo di flusso nel kernel FreeBSD per le porte del
          modem.</para>

        <para>Ad esempio per impostare il flag <literal>termios</literal>
          <varname>crtscts</varname> sui dispositivi di inizializzazione
          di ingresso e uscita della porta seriale numero 1
          (<filename>COM2</filename>), si possono aggiungere le
          seguenti linee a <filename>/etc/rc.d/serial</filename>:</para>

        <programlisting># Configurazione iniziale della porta seriale
stty -f /dev/ttyd1.init crtscts
stty -f /dev/cuad1.init crtscts</programlisting>
      </sect3>
    </sect2>

    <sect2>
      <title>Impostazioni del Modem</title>

      <para>Se hai uno di quei modem i cui parametri possono essere impostati in
        maniera permanente in RAM non volatile, avrai bisogno di usare un
        programma terminale (come Telix su &ms-dos; o <command>tip</command>
        sotto FreeBSD) per impostare i parametri.  Collegati al modem usando le
        stesse velocità iniziali e di comunicazione
        che userebbe <command>getty</command> e configura la RAM non volatile
        secondo queste necessità:</para>

      <itemizedlist>
        <listitem>
          <para><acronym>CD</acronym> attivo per la connessione</para>
        </listitem>

        <listitem>
          <para><acronym>DTR</acronym> attivo per l'operazione; l'assenza del
            DTR porta allo scollegamento della linea e al reset del modem</para>
        </listitem>

        <listitem>
          <para><acronym>CTS</acronym> controllo di flusso dei dati
            trasmessi</para>
        </listitem>

        <listitem>
          <para>Disabilita il controllo di flusso
            <acronym>XON/XOFF</acronym></para>
        </listitem>

        <listitem>
          <para><acronym>RTS</acronym> controllo di flusso dei dati
            ricevuti</para>
        </listitem>

        <listitem>
          <para>Modalità silenziosa (nessun codice di risposta)</para>
        </listitem>

        <listitem>
          <para>Nessun echo dei comandi</para>
        </listitem>
      </itemizedlist>

      <para>Leggi la documentazione del tuo modem per capire quali
        comandi e/o impostazioni per i DIP switch sia necessario
        fornirgli.</para>

      <para>Ad esempio, per impostare i parametri precedenti su un &usrobotics;
        &sportster; 14.400 esterno, si potrebbero dare questi comandi
        al modem:</para>

      <programlisting>ATZ
AT&amp;C1&amp;D2&amp;H1&amp;I0&amp;R2&amp;W</programlisting>

      <para>Potresti anche sfruttare questa opportunità per raffinare
        le impostazioni del modem, ad esempio per decidere se dovrà usare
        V.42bis e/o la compressione MNP5.</para>

      <para>Il modem esterno &usrobotics; &sportster; 14.400 ha anche dei DIP
        switch che devono essere impostati; per altri modem, forse potrai usare
        queste impostazioni come esempio:</para>

      <itemizedlist>
        <listitem>
          <para>Switch 1: SU &mdash; DTR Normale</para>
        </listitem>

        <listitem>
          <para>Switch 2: N/D (Codici di Risposta Verbali/Codici di Risposta
            Numerici</para>
        </listitem>

        <listitem>
          <para>Switch 3: SU &mdash; Sopprime i Codici di Risposta</para>
        </listitem>

        <listitem>
          <para>Switch 4: GIÙ &mdash; Nessun echo, comandi offline </para>
        </listitem>

        <listitem>
          <para>Switch 5: SU &mdash; Auto risposta</para>
        </listitem>

        <listitem>
          <para>Switch 6: SU &mdash; Carrier Detect Normale</para>
        </listitem>

        <listitem>
          <para>Switch 7: SU &mdash; Carica i valori predefiniti
            dall'NVRAM</para>
        </listitem>

        <listitem>
          <para>Switch 8: N/D (Modalità intelligente/modalità
            stupida)</para>
        </listitem>
      </itemizedlist>

      <para>I codici di risposta dovrebbero essere disabilitati/soppressi per i
        modem chiamanti per evitare i problemi che possono capitare
        se <command>getty</command> dà incidentalmente un prompt
        <prompt>login:</prompt> ad un modem che si trova in modalità
        di comando ed il modem restituisce l'eco del comando o un codice di
        risposta.  Questa sequenza può portare ad una lunga, stupida
        conversazione tra <command>getty</command> ed il modem.</para>

      <sect3>
        <title>Configurazione a Velocità Fissa</title>

        <para>Per una configurazione a velocità fissa, avrai bisogno di
          configurare il modem affinché mantenga una frequenza dati
          da modem a computer indipendente dalla frequenza di comunicazione.
          Su un modem esterno &usrobotics; &sportster; 14.400
          questi comandi bloccheranno la velocità dati tra modem e
          computer alla velocità con la quale i comandi sono stati
          inviati:</para>

        <programlisting>ATZ
AT&amp;B1&amp;W</programlisting>
      </sect3>

      <sect3>
        <title>Configurazione a Velocità Concordata</title>

        <para>Per una configurazione a velocità concordata, sarà
          necessario configurare il modem affinché modifichi la frequenza
          dei dati della porta seriale relativamente alla velocità di
          arrivo.  Su un modem esterno &usrobotics; &sportster; 14.400, questi
          comandi causeranno il blocco della frequenza di trasmissione dati con
          correzione d'errore del modem sulla velocità con il quale
          è stato inviato il comando, ma permetteranno variazioni della
          velocità della porta seriale per le connessioni senza
          correzione d'errore:</para>

        <programlisting>ATZ
AT&amp;B2&amp;W</programlisting>
      </sect3>

      <sect3>
        <title>Verifica della Configurazione del Modem</title>

        <para>La maggior parte dei modem ad alta velocità fornisce
          comandi per verificare i parametri funzionali usati dal modem in
          maniera più o meno comprensibile.
          Sui modem esterni &usrobotics; &sportster; 14.400, il comando
          <command>ATI5</command> mostra le impostazioni che sono immagazzinate
          nella RAM non volatile.  Per vedere i veri parametri operativi del
          modem (così come vengono influenzati dai DIP switch del modem),
          usa i comandi <command>ATZ</command> e <command>ATI4</command>.</para>

        <para>Se hai modem di marche differenti, verifica il manuale del tuo
          modem per vedere come sia possibile un ulteriore controllo sui
          parametri di configurazione del modem.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Risoluzione dei Problemi</title>

      <para>Questi sono un po' di passi che è possibile seguire per
        verificare il funzionamento del modem sul tuo sistema.</para>

      <sect3>
        <title>Verifica del Sistema FreeBSD</title>

        <para>Collega il modem al sistema FreeBSD, avvia il sistema, e,
          se il tuo modem ha luci di indicazione dello stato, guarda se la luce
          <acronym>DTR</acronym> del modem si accende quando appare il prompt
          <prompt>login:</prompt> sulla console del sistema
          &mdash; se si accende, dovrebbe significare che FreeBSD ha avviato
          un processo <command>getty</command> sulla porta di comunicazione
          appropriata e sta aspettando una chiamata dal modem.</para>

        <para>Se l'indicatore <acronym>DTR</acronym> non lampeggia, effettua il
          login sul sistema FreeBSD dalla console e dai il comando <command>ps
            ax</command> per verificare se FreeBSD sta cercando di eseguire un
          processo <command>getty</command> sulla porta corretta.  Dovresti
          vedere linee come queste tra i processi mostrati:</para>

        <screen>  114 ??  I      0:00.10 /usr/libexec/getty V19200 ttyd0
  115 ??  I      0:00.10 /usr/libexec/getty V19200 ttyd1</screen>

        <para>Se vedi qualcosa di diverso, come questo:</para>

        <screen>  114 d0  I      0:00.10 /usr/libexec/getty V19200 ttyd0</screen>

        <para>ed il modem non ha ancora accettato chiamate, ciò
          significa che <command>getty</command> ha completato l'apertura della
          porta di comunicazione.
          Questo potrebbe indicare un problema nei cavi o un modem
          mal configurato, poiché <command>getty</command> non dovrebbe
          completare l'apertura della porta fino al rilevamento del segnale
          <acronym>CD</acronym> (carrier detect).</para>

        <para>Se non vedi nessun processo <command>getty</command> in attesa
          sulla porta <filename>ttydN</filename>
          scelta, ricontrolla le voci in <filename>/etc/ttys</filename> per
          vedere se ci sono errori lì.  Inoltre, controlla il file di log
          <filename>/var/log/messages</filename> per vedere se ci sono messaggi
          di <command>init</command> o <command>getty</command>
          riguardo i loro problemi.  Se ci sono messaggi, ri-ricontrolla i file
          di configurazione <filename>/etc/ttys</filename> e
          <filename>/etc/gettytab</filename>, ed anche i file speciali di
          dispositivo <filename>/dev/ttydN</filename>, cercando ogni errore,
          voce mancante, o file di dispositivo mancante.</para>
      </sect3>

      <sect3>
        <title>Tentativo di Connessione in Ingresso</title>

        <para>Cerca di collegarti dall'esterno al sistema; assicurati di usare 8
          bit, nessuna parità, e 1 bit di stop sul sistema remoto.  Se
          non ottieni un prompt, o vengono visualizzati caratteri strani, prova
          a premere <keycode>Invio</keycode> circa una volta per secondo.
          Se dopo un po' ancora non vedi un prompt <prompt>login:</prompt>,
          prova inviare un'<command>INTERRUZIONE</command>.  Se stai usando un
          modem ad alta velocità per effettuare la chiamata, prova a
          richiamare dopo aver bloccato la velocità dell'interfaccia del
          modem (tramite <command>AT&amp;B1</command> su un &usrobotics;
          &sportster;, ad esempio).</para>

        <para>Se ancora non ottieni alcun prompt <prompt>login:</prompt>,
          verifica <filename>/etc/gettytab</filename> ancora e ricontrolla
          che:</para>

        <itemizedlist>
          <listitem>
            <para>La capacità iniziale specificata in
              <filename>/etc/ttys</filename> per quella linea corrisponda a
              quella in <filename>/etc/gettytab</filename></para>
          </listitem>

          <listitem>
            <para>Ogni campo <literal>nx=</literal> corrisponda ad un
              valore in <filename>gettytab</filename></para>
          </listitem>

          <listitem>
            <para>Ogni campo  <literal>tc=</literal> corrisponda a un altro nome
              di capacità in <filename>gettytab</filename></para>
          </listitem>
        </itemizedlist>

        <para>Se chiami ma il modem su FreeBSD non risponde,
          assicurati che il modem sia configurato per rispondere alla chiamata
          quando viene fornito un segnale <acronym>DTR</acronym>.  Se il modem
          sembra essere configurato correttamente, verifica che la linea
          <acronym>DTR</acronym> sia attiva controllando
          gli indicatori luminosi del modem (se ne ha).</para>

        <para>Se hai già controllato tutto quanto più volte ed
          ancora non funziona, fai una pausa e riprova in seguito.  Se ancora
          non funziona puoi provare a inviare un messaggio di posta elettronica
          alla &a.questions; descrivendo il tuo modem ed il tuo problema, e i
          bravi ragazzi della lista cercheranno di darti una mano.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="dialout">
    <title>Servizio di Effettuazione Chiamate</title>

    <indexterm><primary>servizio di effettuazione chiamate</primary></indexterm>

    <para>I seguenti sono consigli per far sì che la tua macchina sia in
      grado di connettersi tramite modem ad un altro computer.  Questo è
      appropriato per stabilire una sessione terminale con un host
      remoto.</para>

    <para>Questo è utile per collegarsi ad una BBS.</para>

    <para>Questo tipo di connessione può essere estremamente utile per
      ottenere un file da Internet se hai problemi con il PPP.  Se hai
      bisogno di usare l'FTP ed il PPP non funziona, usa la sessione terminale
      per eseguire l'FTP.
      Poi usa zmodem per trasferire il file sulla tua macchina.</para>

    <sect2>
      <title>Il Mio Modem Hayes Stock Non È Supportato, Cosa Posso
        Fare?</title>

      <para>Effettivamente, la pagina man di <command>tip</command>
        è un po' datata.
        C'è un compositore Hayes generico già integrato. Usa
        semplicemente <literal>at=hayes</literal> nel tuo
        <filename>/etc/remote</filename> file.</para>

      <para>Il driver Hayes non è abbastanza intelligente da riconoscere
        alcune delle caratteristiche avanzate dei nuovi modem&mdash;messaggi
        come <literal>BUSY</literal>, <literal>NO DIALTONE</literal>, o
        <literal>CONNECT 115200</literal> lo confonderanno e basta.  Dovrai
        disattivare questi messaggi quando usate <command>tip</command> (usando
        <command>ATX0&amp;W</command>).</para>

      <para>Inoltre, il timeout di composizione per <command>tip</command>
        è di 60 secondi.
        Il tuo modem dovrebbe usare qualcosa di meno, altrimenti tip
        penserà che ci sia un problema di comunicazione.  Prova
        <command>ATS7=45&amp;W</command>.</para>

      <note>
        <para>Come viene fornito, <command>tip</command> non supporta ancora
          i modem Hayes completamente.  La soluzione è modificare il file
          <filename>tipconf.h</filename> nella directory
          <filename>/usr/src/usr.bin/tip/tip</filename>.  Ovviamente avrai
          bisogno della distribuzione con i sorgenti per fare ciò.</para>

        <para>Modifica la linea <literal>#define HAYES 0</literal> a
          <literal>#define HAYES 1</literal>.  Poi dai i comandi
          <command>make</command> e <command>make install</command>.
          Tutto funziona bene dopo aver fatto questo.</para>
      </note>
    </sect2>

    <sect2 xml:id="direct-at">
      <title>Come Dovrei Inserire Questi Comandi AT?</title>

      <indexterm><primary><filename>/etc/remote</filename></primary></indexterm>

      <para>Inserisci quella che viene definita una voce <quote>diretta</quote>
        nel file <filename>/etc/remote</filename>.  Ad esempio, se il tuo modem
        è collegato alla prima porta seriale,
        <filename>/dev/cuad0</filename>, allora inserisci la riga
        seguente:</para>

      <programlisting>cuad0:dv=/dev/cuad0:br#19200:pa=none</programlisting>

      <para>Usa la frequenza di bps più alta supportata dal tuo modem per
        il valore di br.  Poi, digita <command>tip cuad0</command> e verrai
        connesso al tuo modem.</para>

      <para>O usa <command>cu</command> come <systemitem class="username">root</systemitem> con il
        seguente comando:</para>

      <screen>&prompt.root; <userinput>cu -llinea -s velocità</userinput></screen>

      <para><replaceable>linea</replaceable> è la porta seriale
        (es. <filename>/dev/cuad0</filename>) e
        <replaceable>velocità</replaceable> è la velocità
        (es. <literal>57600</literal>).  Quando hai finito di inserire i comandi
        AT premi <keycap>~.</keycap> per uscire.</para>
    </sect2>

    <sect2>
      <title>Il Simbolo <literal>@</literal> per il Valore pn Non
        Funziona!</title>

      <para>Il simbolo <literal>@</literal> come valore del numero telefonico
        dice a tip di andare a cercare un numero telefonico in
        <filename>/etc/phones</filename>.
        Ma il segno <literal>@</literal> è anche un carattere speciale
        nei file come <filename>/etc/remote</filename>.  Devi farne l'escape con
        un backslash:</para>

      <programlisting>pn=\@</programlisting>
    </sect2>

    <sect2>
      <title>Come Posso Chiamare Un Numero Telefonico Da Riga di
        Comando?</title>

      <para>Metti una cosiddetta voce <quote>generica</quote> in
        <filename>/etc/remote</filename>.  Ad Esempio:</para>

      <programlisting>tip115200|Chiama un qualunque numero a 115200 bps:\
        :dv=/dev/cuad0:br#115200:at=hayes:pa=none:du:
tip57600|Chiama un qualunque numero a 57600 bps:\
        :dv=/dev/cuad0:br#57600:at=hayes:pa=none:du:</programlisting>

      <para>Poi puoi fare una cosa simile:</para>

      <screen>&prompt.root; <userinput>tip -115200 5551234</userinput></screen>

      <para>Se preferisci <command>cu</command> a <command>tip</command>,
        usa una voce generica per <literal>cu</literal>:</para>

      <programlisting>cu115200|Usa cu per chiamare un numero qualsiasi a 115200bps:\
        :dv=/dev/cuad1:br#57600:at=hayes:pa=none:du:</programlisting>

      <para>e digita:</para>

      <screen>&prompt.root; <userinput>cu 5551234 -s 115200</userinput></screen>
    </sect2>

    <sect2>
      <title>Devo Digitare La Frequenza di bps Ogni Volta Che lo Faccio?</title>

      <para>Metti una voce per <literal>tip1200</literal> o
        <literal>cu1200</literal>, ma vai avanti e inserisci una qualunque
        frequenza di bps appropriata per il valore di br.
        <command>tip</command> pensa che un buon valore predefinito sia
        1200&nbsp;bps, motivo per cui cerca una voce per
        <literal>tip1200</literal>.
        Non sei obbligato a usare 1200&nbsp;bps, comunque.</para>
    </sect2>

    <sect2>
      <title>Accedo ad un Grande Numero di Host attraverso un Server di
        Terminali</title>

      <para>Invece di aspettare fino ad essere connesso e poi digitare
        <command>CONNECT &lt;host&gt;</command> ogni volta, usa la
        funzionalità <literal>cm</literal> di tip.  Ad esempio, queste
        voci in <filename>/etc/remote</filename>:</para>

      <programlisting>pain|pain.deep13.com|La macchina di Forrester:\
        :cm=CONNECT pain\n:tc=deep13:
muffin|muffin.deep13.com|La macchina di Frank:\
        :cm=CONNECT muffin\n:tc=deep13:
deep13:Server di terminali del Gizmonics Institute:\
        :dv=/dev/cuad2:br#38400:at=hayes:du:pa=none:pn=5551234:</programlisting>

      <para>ti permetteranno di digitare <command>tip pain</command> o
        <command>tip muffin</command> per collegarti agli host pain o muffin, e
        <command>tip deep13</command> per il server di terminali.</para>
    </sect2>

    <sect2>
      <title>Tip Può Provare Più di una Linea per ogni
        Sito?</title>

      <para>Questo è spesso un problema quando una università ha
        molte linee di modem e molte migliaia di studenti cercano di
        usarle.</para>

      <para>Inserisci una voce per la tua università in
        <filename>/etc/remote</filename> e usa <literal>@</literal> per il
        campo <literal>pn</literal>:</para>

      <programlisting>big-university:\
        :pn=\@:tc=dialout
dialout:\
        :dv=/dev/cuad3:br#9600:at=courier:du:pa=none:</programlisting>

      <para>Poi, elenca i numeri di telefono dell'università in
        <filename>/etc/phones</filename>:</para>

      <programlisting>big-university 5551111
big-university 5551112
big-university 5551113
big-university 5551114</programlisting>

      <para><command>tip</command> proverà ognuno di questi secondo
        l'ordine, poi smetterà.  Se vuoi continuare a riprovare, esegui
        <command>tip</command> in un ciclo while.</para>
    </sect2>

    <sect2>
      <title>Perché Devo Premere <keycombo action="simul">
          <keycap>Ctrl</keycap>
          <keycap>P</keycap>
        </keycombo> Due Volte per Inviare Un Solo <keycombo action="simul">
          <keycap>Ctrl</keycap>
          <keycap>P</keycap>
        </keycombo>?</title>

      <para><keycombo action="simul">
          <keycap>Ctrl</keycap>
          <keycap>P</keycap>
        </keycombo> è il carattere predefinito per
        <quote>forzare</quote>, usato per dire a <command>tip</command> che il
        prossimo carattere è un dato letterale.  Puoi impostare il
        carattere per forzare a qualsiasi altro carattere con il comando di
        escape <command>~s</command>, che significa <quote>imposta una
          variabile</quote>.</para>

      <para>Digita
        <command>~sforce=singolo-carattere</command>
        seguito da un ritorno a capo.
        <replaceable>singolo-carattere</replaceable> è un
        qualsiasi carattere singolo.  Se non date nessun
        <replaceable>singolo-carattere</replaceable>, allora il carattere per
        forzare sarà il carattere nullo, che è possibile ottenere
        premendo <keycombo action="simul">
          <keycap>Ctrl</keycap>
          <keycap>2</keycap>
        </keycombo> o <keycombo action="simul">
          <keycap>Ctrl</keycap>
          <keycap>Spazio</keycap>
        </keycombo>.
        Un valore abbastanza buono per il
        <replaceable>singolo-carattere</replaceable> è
        <keycombo action="simul">
          <keycap>Shift</keycap>
          <keycap>Ctrl</keycap>
          <keycap>6</keycap>
        </keycombo>, che è usato solo da alcuni server di
        terminali.</para>

      <para>Potete far sì che il carattere per forzare sia un qualsiasi
        carattere vogliate specificando la riga seguente nel file
        <filename>&#36;HOME/.tiprc</filename>:</para>

      <programlisting>force=&lt;singolo-carattere&gt;</programlisting>
    </sect2>

    <sect2>
      <title>Improvvisamente Tutto Quello che Digito È in
      Maiuscolo??</title>

      <para>Devi aver premuto <keycombo action="simul">
          <keycap>Ctrl</keycap>
          <keycap>A</keycap>
        </keycombo>, il <quote>raise character</quote>, di
        <command>tip</command> progettato specificamente per le persone con il
        tasto caps-lock rotto.  Usa <command>~s</command> come mostrato prima
        per impostare la variabile <literal>raisechar</literal> a qualcosa di
        ragionevole.  In pratica, puoi impostarla allo stesso valore del
        carattere per forzare, se pensi di non usare mai queste due
        caratteristiche.</para>

      <para>Qui c'è un file .tiprc di esempio per gli utenti
        <application>Emacs</application> che hanno bisogno di premere
        <keycombo action="simul">
          <keycap>Ctrl</keycap>
          <keycap>2</keycap>
        </keycombo> e <keycombo action="simul">
          <keycap>Ctrl</keycap>
          <keycap>A</keycap>
        </keycombo> molto spesso:</para>

      <programlisting>force=^^
raisechar=^^</programlisting>

      <para>Il carattere ^^ è
        <keycombo action="simul">
          <keycap>Shift</keycap>
          <keycap>Ctrl</keycap>
          <keycap>6</keycap>
        </keycombo>.</para>
    </sect2>

    <sect2>
      <title>Come Posso Trasferire File con <command>tip</command>?</title>

      <para>Se stai parlando ad altri sistemi &unix;, puoi mandare e ricevere
        file con <command>~p</command> (put) e
        <command>~t</command> (take).  Questi comandi eseguono
        <command>cat</command> ed <command>echo</command> sul sistema remoto
        per accettare e inviare file.  La sintassi è:</para>

      <cmdsynopsis>
        <command>~p</command>
        <arg choice="plain">file-locale</arg>
        <arg choice="opt">file-remoto</arg>
      </cmdsynopsis>

      <cmdsynopsis>
        <command>~t</command>
        <arg choice="plain">file-remoto</arg>
        <arg choice="opt">file-locale</arg>
      </cmdsynopsis>

      <para>non c'è controllo d'errore, quindi probabilmente dovresti
        usare un altro protocollo, come zmodem.</para>
    </sect2>

    <sect2>
      <title>Come Posso Eseguire zmodem con <command>tip</command>?</title>

      <para>Per ricevere file, avvia il programma di invio sul lato remoto.
        Poi, digita <command>~C rz</command> per iniziare a ricevere in
        locale.</para>

      <para>Per inviare file, avvia il programma di ricezione sul lato remoto.
        Poi, digita <command>~C sz files</command>
        per inviarli sul sistema remoto.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="serialconsole-setup">
    <info><title>Impostazione della Console Seriale</title>
      <authorgroup>
        <author><personname><firstname>Kazutaka</firstname><surname>YOKOTA</surname></personname><contrib>Contributo di </contrib></author>
      </authorgroup>

      <authorgroup>
        <author><personname><firstname>Bill</firstname><surname>Paul</surname></personname><contrib>Basato su un documento di </contrib></author>
      </authorgroup>
    </info>

    

    <indexterm><primary>console seriale</primary></indexterm>

    <sect2 xml:id="serialconsole-intro">
      <title>Introduzione</title>

      <para>FreeBSD ha la capacità di avviare un sistema con soltanto un
        terminale stupido su porta seriale come console.  Una configurazione
        simile dovrebbe essere utile per due tipi di persone:  amministratori di
        sistema che desiderano installare FreeBSD su macchine che non hanno
        tastiera o monitor connesso, e sviluppatori che vogliono effettuare il
        debug del kernel o dei driver.</para>

      <para>Come descritto nel <xref linkend="boot"/>, FreeBSD implementa un
        avviamento composto da tre stadi.  I primi due stadi sono
        nel blocco di avvio che viene immagazzinato all'inizio
        della slice di FreeBSD sul disco d'avvio.  Il blocco di avvio
        poi carica ed avvia il loader (<filename>/boot/loader</filename>)
        come terzo stadio.</para>

      <para>Per poter impostare la console seriale devi configurare il codice
        del blocco di avvio, il codice del loader ed il kernel.</para>
    </sect2>

    <sect2 xml:id="serialconsole-howto-fast">
      <title>Configurazione della Console Seriale, Versione Essenziale</title>

      <para>Questa sezione presuppone che stai usando una configurazione
        di default e vuoi solamente una veloce panoramica su come abilitare
        una console seriale.</para>

      <procedure>
        <step>
          <para>Connetti il cavo seriale alla COM1 e al terminale.</para>
        </step>

        <step>
          <para>Per vedere tutti i messaggi di boot sulla console seriale,
            dai il comando seguente mentre sei loggato come superuser:</para>

          <screen>&prompt.root; echo 'console="comconsole"' &gt;&gt; /boot/loader.conf</screen>
        </step>

        <step>
          <para>Modifica il file <filename>/etc/ttys</filename> e cambia
            <literal>off</literal> in <literal>on</literal> e
            <literal>dialup</literal> in <literal>vt100</literal> per l'entry
            <literal>ttyd0</literal>.  Altrimenti non verrà chiesta la
            password per connettersi via console seriale, con il risultato di
            creare un potenziale buco di sicurezza.</para>
        </step>

        <step>
           <para>Riavvia il sistema per vedere se i cambiamenti
             funzionano.</para>
        </step>
      </procedure>

      <para>Se si necessita di una diversa configurazione, esiste una spiegazione
        maggiormente dettagliata nella sezione <xref linkend="serialconsole-howto"/>.</para>
    </sect2>

    <sect2 xml:id="serialconsole-howto">
      <title>Configurazione della Console Seriale</title>

      <procedure>
        <step>
          <para>Preparazione di un cavo seriale.</para>

          <indexterm><primary>cavo null-modem</primary></indexterm>

          <para>Avrai bisogno di un cavo null-modem o di un cavo seriale
            standard ed un adattatore null-modem.  Guarda
            <xref linkend="serial-cables-ports"/> per una discussione
            sui cavi seriali.</para>
        </step>

        <step>
          <para>Scollegamento della tastiera.</para>

          <para>La maggior parte dei sistemi PC verifica la presenza di una
            tastiera durante il Power-On Self-Test (POST) e dà un errore
            se la tastiera non viene rilevata.  Alcune macchine si lamentano
            parecchio per la mancanza della tastiera e non proseguono l'avvio
            finché non viene collegata.</para>

          <para>Se il tuo computer si lamenta per questo errore,
            ma si avvia lo stesso, allora non devi fare nulla di speciale.
            (Alcune macchine con BIOS Phoenix semplicemente dicono
            <errorname>Keyboard failed</errorname> e continuano ad avviarsi
            normalmente).</para>

          <para>Se il tuo computer rifiuta di avviarsi senza la tastiera
            allora dovrai configurare il BIOS affinché ignori questo
            errore (se possibile).  Consulta il manuale della tua scheda madre
            per maggiori dettagli su come fare ciò.</para>

          <tip>
            <para>Imposta la tastiera su <quote>Non installata</quote> nel
              setup del BIOS.  Sarai ancora in grado di
              usare la tastiera.  Tutto quel che fa è dire al BIOS
              di non verificare la presenza di una tastiera all'accensione.
              Il tuo BIOS non dovrebbe segnalare che la tastiera non
              è collegata.
              Puoi lasciare la tastiera collegata anche con questa opzione
              impostata a <quote>Non installata</quote> e la tastiera
              funzionerà lo stesso.</para>
          </tip>

          <note>
            <para>Se il tuo sistema ha un mouse &ps2;, le possibilità di
              dover scollegare il mouse allo stesso modo della tastiera
              sono alte.
              Questo perché i mouse &ps2; condividono dell'hardware
              con la tastiera e lasciando il mouse collegato potresti
              ingannare la verifica della tastiera facendogli credere
              che sia ancora presente.  Si dice che il sistema
              Gateway 2000 Pentium 90&nbsp;MHz con BIOS AMI funzioni
              così.
              In generale, questo non è un problema perché il
              mouse non è comunque particolarmente utile senza la
              tastiera.</para>
          </note>
        </step>

        <step>
          <para>Collegamento di un terminale stupido alla
            <filename>COM1</filename>
            (<filename>sio0</filename>).</para>

          <para>Se non possiedi un terminale stupido, puoi usare un
            vecchio PC/XT con un programma per modem, o la porta seriale di un
            altra macchina &unix;.  Se non hai una <filename>COM1</filename>
            (<filename>sio0</filename>), trovane una.
            Attualmente, non c'è altro modo di scegliere
            una porta diversa dalla <filename>COM1</filename>
            per i blocco di avvio senza doverlo ricompilare.  Se stai
            già usando la <filename>COM1</filename> per un altro
            dispositivo, dovrai rimuoverlo temporaneamente ed
            installare un nuovo blocco di avvio ed un nuovo kernel
            una volta che FreeBSD sia funzionante.  (Si assume che la
            <filename>COM1</filename> sia sempre disponibile
            su un server di file/calcolo/terminali; se davvero hai bisogno
            della <filename>COM1</filename> per qualcos'altro
            (e non puoi passare quel qualcosa alla
            <filename>COM2</filename> (<filename>sio1</filename>)),
            allora probabilmente non dovresti nemmeno avere a che fare con
            tutto questo in primo luogo).</para>
        </step>

        <step>
          <para>Assicurati che il file di configurazione del tuo kernel abbia
            i parametri appropriati impostati per la
            <filename>COM1</filename>
            (<filename>sio0</filename>).</para>

          <para>I parametri rilevanti sono:</para>

          <variablelist>
            <varlistentry>
              <term><literal>0x10</literal></term>

              <listitem>
                <para>Abilita il supporto alla console per questa unità.
                  Gli altri parametri di console sono ignorati se non è
                  fissato questo.
                  Attualmente, al massimo un'unità può avere il
                  supporto alla console;  verrà preferita la prima
                  (secondo l'ordine nel file di configurazione) con questo
                  parametro.
                  Questa opzione non renderà la porta seriale la
                  console.
                  Imposta il parametro seguente o usa l'opzione
                  <option>-h</option> descritta più in basso, insieme a
                  questa impostazione.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><literal>0x20</literal></term>

              <listitem>
                <para>Forza questa unità ad essere la console (a meno che
                  sia presente un'altra console con priorità più
                  alta), trascurando l'opzione <option>-h</option> discussa
                  precedentemente.  Il parametro
                  <literal>0x20</literal> deve essere usato insieme al
                  <option>0x10</option>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><literal>0x40</literal></term>

              <listitem>
                <para>Riserva questa unità (insieme a
                  <literal>0x10</literal>) e rende l'unità indisponibile
                  per l'accesso normale.  Non dovresti impostare questo
                  parametro sull'unità della porta seriale che desideri
                  usare come console seriale.  L'unico uso di questo parametro
                  è per designare l'unità per il debug remoto
                  del kernel.  Guarda il <link xlink:href="&url.books.developers-handbook;/index.html">Developer's
                    Handbook</link> per maggiori informazioni sul
                  debugging remoto.</para>

                <note>
                  <para>In FreeBSD&nbsp;4.0 o successivo, la semantica del
                    parametro <literal>0x40</literal> è leggermente
                    differente e c'è un altro parametro per specificare
                    una porta seriale per il debug remoto.</para>
                </note>
              </listitem>
            </varlistentry>
          </variablelist>

          <para>Esempio:</para>

          <programlisting>device sio0 at isa? port IO_COM1 flags 0x10 irq 4</programlisting>

          <para>Guarda la pagina man &man.sio.4; per maggiori dettagli.</para>

          <para>Se i parametri non sono stati impostati, sarà necessario
            eseguire UserConfig (su una console differente) o ricompilare il
            kernel.</para>
        </step>

        <step>
          <para>Creazione di <filename>boot.config</filename> nella directory
            radice della partizione <literal>a</literal> nel disco di
            avvio.</para>

          <para>Questo file istruirà il codice del blocco di avvio su
            come vuoi avviare il sistema.  Per poter attivare la console
            seriale, avrai bisogno di una o più delle seguenti
            opzioni&mdash;se vuoi opzioni multiple, includile tutte sulla
            stessa linea:</para>

          <variablelist>
            <varlistentry>
              <term><option>-h</option></term>

              <listitem>
                <para>Passa dalla console interna a quella seriale.  Puoi usarla
                  per cambiare i dispositivi console.  Ad esempio, se avvii
                  dalla console interna (video), puoi usare
                  <option>-h</option> per dirigere il loader ed il kernel
                  in modo che usino la porta seriale come dispositivo per la
                  console.  Alternativamente, se avvii da porta seriale, puoi
                  usare l'opzione <option>-h</option> per dire al loader ed al
                  kernel di usare lo schermo come console.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><option>-D</option></term>

              <listitem>
                <para>Passa da una configurazione singola a una duplice.  Nella
                  configurazione singola la console sarà o quella interna
                  (il display video) o la porta seriale, a seconda dello
                  stato dell'opzione <option>-h</option> già descritta.
                  Nella configurazione duplice, sia il display video che la
                  porta seriale diventeranno la console allo stesso momento,
                  senza curarsi dello stato dell'opzione <option>-h</option>.
                  Ad ogni modo, nota che questa configurazione duplice ha
                  effetto solo durante l'esecuzione del blocco di avvio.
                  Una volta che il loader ha assunto il controllo, la console
                  specificata da <option>-h</option> diventa l'unica.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term><option>-P</option></term>

              <listitem>
                <para>Fa sì che il blocco di avvio verifichi la presenza
                  della tastiera.  Se non ne viene rilevata nessuna, le opzioni
                  <option>-D</option> e <option>-h</option>
                  vengono impostate automaticamente.</para>

                <note>
                  <para>A causa delle costrizioni relative allo spazio
                    nelle versioni attuali del blocco di avvio, l'opzione
                    <option>-P</option> è in grado di riconoscere solo le
                    tastiere estese.  Le tastiere con meno di 101 tasti (e senza
                    i tasti F11 e F12) potrebbero non essere rilevate.
                    Le tastiere su alcuni computer portatili potrebbero
                    non essere rilevate a causa di questa limitazione.
                    Se questo è il caso del tuo sistema,
                    devi abbandonare l'opzione <option>-P</option>.
                    Sfortunatamente non c'è nessun metodo per aggirare
                    questo problema.</para>
                </note>
              </listitem>
            </varlistentry>
          </variablelist>

          <para>Usa l'opzione <option>-P</option> per selezionare
            la console automaticamente, o l'opzione <option>-h</option> per
            attivare la console seriale.</para>

          <para>Puoi includere altre opzioni come descritte in
            &man.boot.8;.</para>

          <para>Le opzioni, eccetto <option>-P</option>, verranno passate al
            loader (<filename>/boot/loader</filename>).  Il loader
            determinerà quale tra il video interno o la console seriale
            debba diventare la console esaminando lo stato dell'opzione
            <option>-h</option>.  Ciò significa che se specifichi
            l'opzione <option>-D</option> ma non la <option>-h</option>
            in <filename>/boot.config</filename>, puoi usare la porta seriale
            come console soltanto durante l'esecuzione del blocco di avvio; il
            loader userà il video interno come console.</para>
        </step>

        <step>
          <para>Avviamento della macchina.</para>

          <para>Quando avvii la tua macchina FreeBSD, il blocco di avvio
            scriverà il contenuto di <filename>/boot.config</filename>
            sulla console.  Ad esempio:</para>

          <screen>/boot.config: -P
Keyboard: no</screen>

          <para>La seconda linea appare solo se metti l'opzione
            <option>-P</option> in <filename>/boot.config</filename> ed indichi
            la presenza/assenza della tastiera.  Questo messaggio va alla
            console seriale o a quella interna, o a entrambe, a seconda
            dell'opzione in <filename>/boot.config</filename>.</para>

          <informaltable frame="none" pgwide="1">
            <tgroup cols="2">
              <thead>
                <row>
                  <entry align="left">Opzioni</entry>

                  <entry align="left">I messaggi vanno a</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>nessuna</entry>

                  <entry>console interna</entry>
                </row>

                <row>
                  <entry><option>-h</option></entry>

                  <entry>console seriale</entry>
                </row>

                <row>
                  <entry><option>-D</option></entry>

                  <entry>console seriale ed interna</entry>
                </row>

                <row>
                  <entry><option>-Dh</option></entry>

                  <entry>console seriale ed interna</entry>
                </row>

                <row>
                  <entry><option>-P</option>, tastiera presente</entry>

                  <entry>console interna</entry>
                </row>

                <row>
                  <entry><option>-P</option>, tastiera assente</entry>

                  <entry>console seriale</entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>

          <para>Dopo i messaggi precedenti, ci sarà una piccola pausa
            prima che il blocco di avvio continui nel caricamento del loader e
            prima che ulteriori messaggi vengano scritti sulla console.
            In circostanze normali, non hai necessità di interrompere il
            blocco di avvio, ma potresti volerlo fare per verificare che tutto
            sia impostato correttamente.</para>

          <para>Premi un tasto qualsiasi, differente da
            <keycode>Invio</keycode>, alla console per interrompere il processo
            di avvio.  Il blocco di avvio aspetterà ulteriori azioni.
            Dovresti vedere qualcosa del genere:</para>

          <screen>&gt;&gt; FreeBSD/i386 BOOT
Default: 0:ad(0,a)/boot/loader
boot:</screen>

          <para>Verifica se il messaggio precedente appare sulla console seriale
            o su quella interna o su entrambe, secondo le opzioni poste in
            <filename>/boot.config</filename>.  Se il messaggio appare nella
            console corretta, premi <keycode>Invio</keycode> per continuare il
            processo di avvio.</para>

          <para>Se vuoi la console seriale ma non riesci a vedere il prompt sul
            terminale seriale, qualcosa è sbagliato nelle tue
            impostazioni.  Nel frattempo, scrivi <option>-h</option> e premi
            Invio (se possibile) per dire al blocco di avvio (e al loader e al
            kernel) di scegliere la porta seriale per la console.  Una volta
            che il sistema è attivo, torna indietro e verifica cosa
            è andato storto.</para>
        </step>
      </procedure>

      <para>Dopo che il loader è stato caricato e ti trovi nel terzo
        stadio del processo di avvio puoi ancora passare dalla console interna
        alla console seriale impostando le variabili d'ambiente appropriate nel
        loader.  Guarda la <xref linkend="serialconsole-loader"/>.</para>
    </sect2>

    <sect2 xml:id="serialconsole-summary">
      <title>Sommario</title>

      <para>Qui c'è il sommario delle varie impostazioni discusse in
        questa sezione e la console eventualmente selezionata.</para>

      <sect3>
        <title>Caso 1: Imposti il Flag 0x10 per
          <filename>sio0</filename></title>

        <programlisting>device sio0 at isa? port IO_COM1 flags 0x10 irq 4</programlisting>

        <informaltable frame="none" pgwide="1">
          <tgroup cols="4">
            <thead>
              <row>
                <entry align="left">Opzioni in /boot.config</entry>

                <entry align="left">Console durante i blocco di avvio</entry>

                <entry align="left">Console durante il loader</entry>

                <entry align="left">Console nel kernel</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>niente</entry>

                <entry>interna</entry>

                <entry>interna</entry>

                <entry>interna</entry>
              </row>

              <row>
                <entry><option>-h</option></entry>

                <entry>seriale</entry>

                <entry>seriale</entry>

                <entry>seriale</entry>
              </row>

              <row>
                <entry><option>-D</option></entry>

                <entry>seriale ed interna</entry>

                <entry>interna</entry>

                <entry>interna</entry>
              </row>

              <row>
                <entry><option>-Dh</option></entry>

                <entry>seriale ed interna</entry>

                <entry>seriale</entry>

                <entry>seriale</entry>
              </row>

              <row>
                <entry><option>-P</option>, tastiera presente</entry>

                <entry>interna</entry>

                <entry>interna</entry>

                <entry>interna</entry>
              </row>

              <row>
                <entry><option>-P</option>, tastiera assente</entry>

                <entry>seriale ed interna</entry>

                <entry>seriale</entry>

                <entry>seriale</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </sect3>

      <sect3>
        <title>Caso 2: Imposti il Flag 0x30 per sio0</title>

        <programlisting>device sio0 at isa? port IO_COM1 flags 0x30 irq 4</programlisting>

        <informaltable frame="none" pgwide="1">
          <tgroup cols="4">
            <thead>
              <row>
                <entry align="left">Opzioni in /boot.config</entry>

                <entry align="left">Console durante i blocco di avvio</entry>

                <entry align="left">Console durante il loader</entry>

                <entry align="left">Console nel kernel</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>niente</entry>

                <entry>interna</entry>

                <entry>interna</entry>

                <entry>seriale</entry>
              </row>

              <row>
                <entry><option>-h</option></entry>

                <entry>seriale</entry>

                <entry>seriale</entry>

                <entry>seriale</entry>
              </row>

              <row>
                <entry><option>-D</option></entry>

                <entry>seriale ed interna</entry>

                <entry>interna</entry>

                <entry>seriale</entry>
              </row>

              <row>
                <entry><option>-Dh</option></entry>

                <entry>seriale ed interna</entry>

                <entry>seriale</entry>

                <entry>seriale</entry>
              </row>

              <row>
                <entry><option>-P</option>, tastiera presente</entry>

                <entry>interna</entry>

                <entry>interna</entry>

                <entry>seriale</entry>
              </row>

              <row>
                <entry><option>-P</option>, tastiera assente</entry>

                <entry>seriale ed interna</entry>

                <entry>seriale</entry>

                <entry>seriale</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </sect3>
    </sect2>

    <sect2 xml:id="serialconsole-tips">
      <title>Consigli per una Console Seriale</title>

      <sect3>
        <title>Impostazione di una Velocità Maggiore della Porta
          Seriale</title>

        <para>Di default, le impostazioni della porta seriale sono: 9600 baud, 8
          bit, nessuna parità, ed 1 bit di stop.  Se desideri cambiare
          la velocità, avrai bisogno di ricompilare almeno il blocco di
          avvio.  Aggiungi la linea seguente a
          <filename>/etc/make.conf</filename> e compila il nuovo blocco di
          avvio:</para>

        <programlisting>BOOT_COMCONSOLE_SPEED=19200</programlisting>

        <para>Guarda <xref linkend="serialconsole-com2"/> per istruzioni
          dettagliate su come costruire e installare nuovi blocchi di
          avvio.</para>

        <para>Se la console seriale è configurata in qualche altra
          maniera invece di essere selezionata all'avvio con
          <option>-h</option>, o se la console seriale usata dal kernel
          è differente da quella usata dal blocco di avvio, allora
          dovrai aggiungere anche le opzioni seguenti al file di
          configurazione del kernel e compilare un nuovo kernel:</para>

        <programlisting>options CONSPEED=19200</programlisting>
      </sect3>

      <sect3 xml:id="serialconsole-com2">
        <title>Utilizzo di una Porta Seriale Differente da
          <filename>sio0</filename> per la Console</title>

        <para>Usare una porta seriale differente da
          <filename>sio0</filename> come
          console richiede un po' di ricompilazione.  Se vuoi usare un'altra
          porta seriale per qualche motivo, ricompila il blocco di avvio, il
          loader ed il kernel come segue.</para>

        <procedure>
          <step>
            <para>Ottieni i sorgenti del kernel.  (Guarda il <xref linkend="cutting-edge"/>)</para>
          </step>

          <step>
            <para>Modifica <filename>/etc/make.conf</filename> e imposta
              <literal>BOOT_COMCONSOLE_PORT</literal> all'indirizzo della
              porta che vuoi usare (0x3F8, 0x2F8, 0x3E8 o 0x2E8).  Solo
              i dispositivi da <filename>sio0</filename> a
              <filename>sio3</filename> (<filename>COM1</filename>
              a <filename>COM4</filename>) possono essere usati; le schede
              seriali multiporta non funzioneranno.  Non sono necessarie
              impostazioni per gli interrupt.</para>
          </step>

          <step>
            <para>Crea un file di configurazione del kernel personalizzato e
              aggiungi i flag appropriati per la porta seriale che intendi
              usare.
              Ad esempio, se vuoi fare di <filename>sio1</filename>
              (<filename>COM2</filename>) la console:</para>

            <programlisting>device sio1 at isa? port IO_COM2 flags 0x10 irq 3</programlisting>

            <para>o</para>

            <programlisting>device sio1 at isa? port IO_COM2 flags 0x30 irq 3</programlisting>

            <para>I flag di console per le altre porte seriali non dovrebbero
              essere impostati.</para>
          </step>

          <step>
            <para>Ricompila ed installa il blocco di avvio ed il loader:</para>

            <screen>&prompt.root; <userinput>cd /sys/boot</userinput>
&prompt.root; <userinput>make clean</userinput>
&prompt.root; <userinput>make</userinput>
&prompt.root; <userinput>make install</userinput></screen>
          </step>

          <step>
            <para>Ricompila ed installa il kernel.</para>
          </step>

          <step>
            <para>Scrivi il blocco di avvio sul disco di avvio con
              &man.disklabel.8; ed avvia con il nuovo kernel.</para>
          </step>
        </procedure>
      </sect3>

      <sect3 xml:id="serialconsole-ddb">
        <title>Accesso al Debugger DDB dalla Linea Seriale</title>

        <para>Se desideri entrare nel debugger del kernel dalla console seriale
          (utile per diagnostiche remote, ma anche molto pericoloso se generi
          un BREAK spurio sulla porta seriale!) allora dovrai compilare
          il tuo kernel con le opzioni seguenti:</para>

        <programlisting>options BREAK_TO_DEBUGGER
options DDB</programlisting>
      </sect3>

      <sect3>
        <title>Come Ottenere un Prompt di Login sulla Console Seriale</title>

        <para>Anche se questo non è necessario, potresti desiderare un
          prompt di <emphasis>login</emphasis> sulla linea seriale, ora
          che puoi vedere i messaggi di avvio e puoi accedere a sessioni di
          debug del kernel attraverso la console seriale.
          Qui è spiegato come fare.</para>

        <para>Apri il file <filename>/etc/ttys</filename> con un editor
          e trova queste linee:</para>

      <programlisting>ttyd0 "/usr/libexec/getty std.9600" unknown off secure
ttyd1 "/usr/libexec/getty std.9600" unknown off secure
ttyd2 "/usr/libexec/getty std.9600" unknown off secure
ttyd3 "/usr/libexec/getty std.9600" unknown off secure</programlisting>

        <para>I dispositivi da <literal>ttyd0</literal> a
          <literal>ttyd3</literal>
          corrispondono a <filename>COM1</filename> fino a
          <filename>COM4</filename>.  Cambia <literal>off</literal> a
          <literal>on</literal> per la porta desiderata.  Se hai cambiato la
          velocità della porta seriale, dovrai cambiare
          <literal>std.9600</literal> affinché corrisponda
          all'impostazione corrente, ad es. <literal>std.19200</literal>.</para>

        <para>Potresti anche desiderare cambiare il tipo di terminale da
          <literal>unknown</literal> al tipo effettivo del tuo terminale
          seriale.</para>

        <para>Dopo avere modificato il file, devi dare un <command>kill -HUP
            1</command> affinché i cambiamenti abbiano effetto.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="serialconsole-loader">
      <title>Cambiamento della Console dal Loader</title>

      <para>Le sezioni precedenti hanno descritto come impostare la console
        seriale lavorando sul blocco di avvio.  Questa sezione mostra come
        specificare a console inserendo alcuni comandi ed alcune variabili
        di ambiente nel loader.  Quando il loader verrà invocato al terzo
        stadio del processo di avvio, dopo il blocco di avvio, le impostazioni
        nel loader prenderanno il posto di quelle nel blocco di avvio.</para>

      <sect3>
        <title>Impostazione della Console Seriale</title>

        <para>Puoi facilmente specificare al loader ed al kernel di usare
          la console seriale scrivendo una sola riga in
          <filename>/boot/loader.rc</filename>:</para>

        <programlisting>set console="comconsole"</programlisting>

        <para>Ciò sarà efficace in ogni caso, qualunque siano le
          impostazioni nel blocco di avvio discusse nella sezione
          precedente.</para>

        <para>Sarebbe meglio mettere la linea precedente come prima linea
          di <filename>/boot/loader.rc</filename> in modo da vedere
          i messaggi sulla console seriale il prima possibile.</para>

        <para>Altrimenti, puoi specificare la console interna come:</para>

        <programlisting>set console="vidconsole"</programlisting>

        <para>Se non imposti la variabile di ambiente
         <envar>console</envar> del loader, quest'ultimo, e
          conseguentemente anche il kernel, useranno
          una console qualunque indicata dall'opzione
          <option>-h</option> nel blocco di avvio.</para>

        <para>Nelle versioni 3.2 o successive, è possibile specificare
          la console in
          <filename>/boot/loader.conf.local</filename> o
          <filename>/boot/loader.conf</filename>, piuttosto che in
          <filename>/boot/loader.rc</filename>.  Con questo metodo il tuo
          <filename>/boot/loader.rc</filename> dovrebbe apparire
          così:</para>

        <programlisting>include /boot/loader.4th
start</programlisting>

        <para>Poi, crea <filename>/boot/loader.conf.local</filename>  ed
          aggiungi lì la linea seguente.</para>

        <programlisting>console=comconsole</programlisting>

        <para>o</para>

        <programlisting>console=vidconsole</programlisting>

        <para>Guarda &man.loader.conf.5; per maggiori informazioni.</para>

        <note>
          <para>Al momento il loader non ha un'opzione equivalente alla
            <option>-P</option> del blocco di avvio, e non c'è
            possibilità di scegliere automaticamente la console interna e
            la console seriale basandosi sulla presenza di una tastiera.</para>
        </note>
      </sect3>

      <sect3>
        <title>Utilizzo di una Porta Seriale Diversa da
          <filename>sio0</filename> per la Console</title>

        <para>Sarà necessario ricompilare il loader per usare una
          porta seriale differente da <filename>sio0</filename> per la
          console seriale.  Segui la procedura descritta nella <xref linkend="serialconsole-com2"/>.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="serialconsole-caveats">
      <title>Avvertimento</title>

      <para>L'idea di tutto questo è di permettere alla gente di mettere
        su server dedicati che non abbiano bisogno di hardware grafico o di
        tastiere.  Sfortunatamente, mentre la maggior parte dei sistemi
        ti permetteranno di avviare senza tastiera, ce ne sono alcuni che
        non ti permetteranno di partire senza un adattatore grafico.
        Le macchine con BIOS AMI possono essere configurate per partire senza
        adattatori grafici cambiando semplicemente il valore di <quote>graphics
          adapter</quote> nella configurazione CMOS a <quote>Not
          installed</quote>.</para>

      <para>Ad ogni modo, molte macchine non supportano questa opzione e si
        rifiuteranno di avviarsi se non si ha hardware grafico nel sistema.
        Con queste macchine, avrai bisogno di lasciare un qualche tipo di scheda
        grafica attaccata, (anche una scheda monocromatica di recupero) sebbene
        non avrai necessità di collegare un monitor.
        Potresti anche tentare di installare un BIOS AMI.</para>
    </sect2>
  </sect1>
</chapter>
