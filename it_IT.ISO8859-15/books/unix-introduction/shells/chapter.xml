<?xml version="1.0" encoding="iso-8859-15"?>
<!--
     The FreeBSD Italian Documentation Project

     $FreeBSD$
-->

<chapter id="shells">
  <title>Shell</title>

  <para>La shell, che sta tra l'utente e il sistema operativo, opera come un
    interprete di comandi.  Legge l'input dal terminale e traduce i comandi in
    azioni, azioni che vengono intraprese dal sistema.  La shell è simile
    al <emphasis>command.com</emphasis> in DOS.  Una volta effettuato il login
    nel sistema, viene assegnata la shell di default.  La shell, al suo avvio,
    legge i suoi file di inizializzazione e può settare alcune
    variabili di ambiente, i path di ricerca dei comandi, gli alias dei comandi
    ed eseguire qualche comando specificato in questi file.</para>

  <para>La prima shell è stata la shell Bourne, &man.sh.1;.  Ogni
    piattaforma Unix dispone della shell Bourne o di una shell Bourne
    compatibile.  Questa shell ha molte buone caratteristiche per controllare
    l'input e l'output, ma non è molto adatta all'utente interattivo.
    Per andare incontro a quest'ultimo è stata scritta la shell C,
    &man.csh.1;, presente ora in molti, ma non tutti, i sistemi Unix.
    Questa shell usa una sorta di sintassi C, il linguaggio con cui Unix
    è stato scritto, ma ha molte scomode implementazioni
    dell'input/output.  La shell C ha il controllo dei job, quindi può
    mandare un job eseguito in background (<quote>sotto shell</quote>) in
    foreground (<quote>in shell corrente</quote>).  Inoltre ha la funzione di
    history (storia dei comandi) che permette di modificare e ripetere comandi
    eseguiti precedentemente.</para>

  <para>Il prompt di default per la shell Bourne è <emphasis>$</emphasis>
    (o &prompt.root; per l'utente root).  Il prompt di default per la shell C
    è &prompt.user;.</para>

  <para>Sono disponibili in rete molte altre shell.  Quasi tutte sono basate
    sulla shell &man.sh.1; o &man.csh.1; con estensioni per fornire il controllo
    dei job alla shell &man.sh.1;, permettere di manipolare il modo di
    esecuzione dei comandi su linea di comando, cercare attraverso i comandi
    eseguiti precedentemente, fornire il completamento dei nomi dei comandi,
    prompt personalizzati, ecc.  Alcune delle seguenti shell maggiormente
    conosciute potrebbero essere sul proprio amato sistema Unix: la shell korn,
    <command>ksh</command>, di David Korn e la shell Bourne Again, &man.bash.1;,
    dal progetto GNU Free Software Foundations, entrambe basate su &man.sh.1;,
    la shell T-C, &man.tcsh.1; e l'estensione della shell C,
    <command>cshe</command>, entrambe bastate su &man.csh.1;.  In seguito si
    descriveranno alcune delle caratteristiche di &man.sh.1; e &man.csh.1;,
    così per iniziare.</para>

  <sect1 id="shells-built-in-comm">
    <title>Comandi built-in</title>

    <para>La shell ha alcuni comandi <emphasis>built-in</emphasis>, chiamati
      anche comandi nativi.  Questi comandi sono eseguiti direttamente dalla
      shell e non chiamano nessun altro programma per essere eseguiti.  Questi
      comandi built-in possono essere diversi tra le varie shell.</para>

    <sect2 id="shells-built-in-comm-sh">
      <title>Sh</title>

      <para>Per la shell Bourne alcuni dei comandi built-in più
        comunemente usati sono:</para>

      <informaltable frame="none">
        <tgroup cols="2">
          <colspec colwidth="1in"/>

          <tbody>
            <row>
              <entry><command>:</command></entry>

              <entry>comando null</entry>
            </row>

            <row>
              <entry><command>.</command></entry>

              <entry>prende (legge ed esegue) i comandi da un file</entry>
            </row>

            <row>
              <entry><command>case</command></entry>

              <entry>condizionale case</entry>
            </row>

            <row>
              <entry><command>cd</command></entry>

              <entry>cambia la directory di lavoro (<literal>$HOME</literal> di
                default)</entry>
            </row>

            <row>
              <entry><command>echo</command></entry>

              <entry>scrive una stringa su standard output</entry>
            </row>

            <row>
              <entry><command>eval</command></entry>

              <entry>valuta l'argomento specificato e ritorna il risultato alla
                shell</entry>
            </row>

            <row>
              <entry><command>exec</command></entry>

              <entry>esegue il comando specificato rimpiazzando la shell
                corrente</entry>
            </row>

            <row>
              <entry><command>exit</command></entry>

              <entry>esce dalla shell corrente</entry>
            </row>

            <row>
              <entry><command>export</command></entry>

              <entry>condivide le variabili di ambiente specificate con le
                successive shell</entry>
            </row>

            <row>
              <entry><command>for</command></entry>

              <entry>condizionale di ciclo for</entry>
            </row>

            <row>
              <entry><command>if</command></entry>

              <entry>condizionale if</entry>
            </row>

            <row>
              <entry><command>pwd</command></entry>

              <entry>mostra la directory di lavoro corrente</entry>
            </row>

            <row>
              <entry><command>read</command></entry>

              <entry>legge una linea di input da standard input</entry>
            </row>

            <row>
              <entry><command>set</command></entry>

              <entry>setta le variabili di shell</entry>
            </row>

            <row>
              <entry><command>test</command></entry>

              <entry>valuta un'espressione come vera o falsa</entry>
            </row>

            <row>
              <entry><command>trap</command></entry>

              <entry>intrappola un tipo di segnale ed esegue comandi</entry>
            </row>

            <row>
              <entry><command>umask</command></entry>

              <entry>setta la maschera di default relativa ai permessi da
                impostare per i nuovi file</entry>
            </row>

            <row>
              <entry><command>unset</command></entry>

              <entry>resetta le variabili di shell</entry>
            </row>

            <row>
              <entry><command>wait</command></entry>

              <entry>attente che un specifico processo termini</entry>
            </row>

            <row>
              <entry><command>while</command></entry>

              <entry>condizionale di ciclo while</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </sect2>

    <sect2 id="shells-built-in-comm-csh">
      <title>Csh</title>

      <para>Per la shell C i comandi built-in maggiormente usati sono:</para>

      <informaltable frame="none">
        <tgroup cols="2">
          <colspec colwidth="1.5in"/>

          <tbody>
            <row>
              <entry><command>alias</command></entry>

              <entry>assegna un nome a una funzione</entry>
            </row>

            <row>
              <entry><command>bg</command></entry>

              <entry>mette un job in background</entry>
            </row>

            <row>
              <entry><command>cd</command></entry>

              <entry>cambia la directory di lavoro corrente</entry>
            </row>

            <row>
              <entry><command>echo</command></entry>

              <entry>scrive una stringa su standard output</entry>
            </row>

            <row>
              <entry><command>eval</command></entry>

              <entry>valuta gli argomenti specificati e ritorna il risultato
                alla shell</entry>
            </row>

            <row>
              <entry><command>exec</command></entry>

              <entry>esegue il comando specificato rimpiazzando la shell
                corrente</entry>
            </row>

            <row>
              <entry><command>exit</command></entry>

              <entry>esce dalla shell corrente</entry>
            </row>

            <row>
              <entry><command>fg</command></entry>

              <entry>porta un job in foreground</entry>
            </row>

            <row>
              <entry><command>foreach</command></entry>

              <entry>condizionale di ciclo for</entry>
            </row>

            <row>
              <entry><command>glob</command></entry>

              <entry>crea un'espansione dei nomi di file su una lista senza
                tenere conto del carattere di escape \</entry>
            </row>

            <row>
              <entry><command>history</command></entry>

              <entry>stampa la storia dei comandi della shell</entry>
            </row>

            <row>
              <entry><command>if</command></entry>

              <entry>condizionale if</entry>
            </row>

            <row>
              <entry><command>jobs</command></entry>

              <entry>mostra o controlla i job attivi</entry>
            </row>

            <row>
              <entry><command>kill</command></entry>

              <entry>termina un processo specifico</entry>
            </row>

            <row>
              <entry><command>limit</command></entry>

              <entry>setta dei limiti sulle risorse di sistema</entry>
            </row>

            <row>
              <entry><command>logout</command></entry>

              <entry>termina la shell di login</entry>
            </row>

            <row>
              <entry><command>nice
                  <replaceable>comando</replaceable></command></entry>

              <entry>abbassa la priorità di schedulazione del
                comando specificato</entry>
            </row>

            <row>
              <entry><command>nohup
                  <replaceable>comando</replaceable></command></entry>

              <entry>non termina il comando specificato quando la shell
                esce</entry>
            </row>

            <row>
              <entry><command>popd</command></entry>

              <entry>estrae un record dallo stack delle directory e ritorna
                nella directory estratta</entry>
            </row>

            <row>
              <entry><command>pushd</command></entry>

              <entry>cambia nella nuova directory specificata e aggiunge quella
                corrente nello stack delle directory</entry>
            </row>

            <row>
              <entry><command>rehash</command></entry>

              <entry>ricrea la tabella hash dei percorsi (path) per i file
                eseguibili</entry>
            </row>

            <row>
              <entry><command>repeat</command></entry>

              <entry>ripete un comando il numero di volte specificato</entry>
            </row>

            <row>
              <entry><command>set</command></entry>

              <entry>setta una variabile di shell</entry>
            </row>

            <row>
              <entry><command>setenv</command></entry>

              <entry>setta una variabile di ambiente per la shell corrente e per
                quelle successive</entry>
            </row>

            <row>
              <entry><command>source</command></entry>

              <entry>prende (legge ed esegue) comandi da un file</entry>
            </row>

            <row>
              <entry><command>stop</command></entry>

              <entry>ferma uno specifico job in background</entry>
            </row>

            <row>
              <entry><command>switch</command></entry>

              <entry>condizionale switch</entry>
            </row>

            <row>
              <entry><command>umask</command></entry>

              <entry>setta la maschera di default relativa ai permessi da
                impostare per i nuovi file</entry>
            </row>

            <row>
              <entry><command>unalias</command></entry>

              <entry>rimuove il nome alias specificato</entry>
            </row>

            <row>
              <entry><command>unset</command></entry>

              <entry>resetta le variabile di shell</entry>
            </row>

            <row>
              <entry><command>unsetenv</command></entry>

              <entry>resetta le variabili di ambiente</entry>
            </row>

            <row>
              <entry><command>wait</command></entry>

              <entry>attente la terminazione di tutti i processi in
                background</entry>
            </row>

            <row>
              <entry><command>while</command></entry>

              <entry>condizionale di ciclo while</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </sect2>
  </sect1>

  <sect1 id="shells-env-var">
    <title>Variabili di ambiente</title>

    <para>Le variabili di ambiente sono usate per fornire informazioni ai
      programmi che si utilizzano.  Si possono avere sia <emphasis>variabili
        globali di ambiente</emphasis> sia <emphasis>variabili locali di
        shell</emphasis>.  Le variabili globali di ambiente sono inizializzate
      attraverso la propria shell di login e i nuovi programmi e le nuove shell
      ereditano l'ambiente della shell genitore.  Le variabili locali di shell
      sono usate solamente dalla shell corrente e non sono passate ad altri
      processi.  Un processo figlio non può passare una variabile al suo
      processo padre.</para>

    <para>Le variabili di ambiente correnti sono visualizzabili con i comandi
      &man.env.1; o &man.printenv.1;.  Alcune comuni variabili sono:</para>

    <informaltable frame="none">
      <tgroup cols="2">
        <colspec colwidth="1.5in"/>

        <tbody>
          <row>
            <entry><literal>DISPLAY</literal></entry>

            <entry>Il display grafico da usare, esempio
              <literal>nyssa:0.0</literal></entry>
          </row>

          <row>
            <entry><literal>EDITOR</literal></entry>

            <entry>Il path (percorso) del proprio editor di default, esempio
              <filename>/usr/bin/vi</filename></entry>
          </row>

          <row>
            <entry><literal>GROUP</literal></entry>

            <entry>Il proprio gruppo di login, esempio
              <username>staff</username></entry>
          </row>

          <row>
            <entry><literal>HOME</literal></entry>

            <entry>Il path della propria home directory, esempio
              <filename>/home/frank</filename></entry>
          </row>

          <row>
            <entry><literal>HOST</literal></entry>

            <entry>Il nome host del proprio sistema, esempio
              <hostid role="hostname">nyssa</hostid></entry>
          </row>

          <row>
            <entry><literal>IFS</literal></entry>

            <entry>I separatori di campo interni, generalmente alcuni spazi
              bianchi (tab, spazio e new-line di default)</entry>
          </row>

          <row>
            <entry><literal>LOGNAME</literal></entry>

            <entry>Il nome del proprio login, esempio
              <username>frank</username></entry>
          </row>

          <row>
            <entry><literal>PATH</literal></entry>

            <entry>I path per ricercare i comandi, esempio
              <filename>/usr/bin:/usr/ucb:/usr/local/bin</filename></entry>
          </row>

          <row>
            <entry><literal>PS1</literal></entry>

            <entry>La stringa del prompt primario, solamente shell Bourne
              (<emphasis>$</emphasis> di default)</entry>
          </row>

          <row>
            <entry><literal>PS2</literal></entry>

            <entry>La stringa del prompt secondario, solamente shell Bourne
              (&gt; di default)</entry>
          </row>

          <row>
            <entry><literal>SHELL</literal></entry>

            <entry>La propria shell di login, esempio
              <filename>/usr/bin/csh</filename></entry>
          </row>

          <row>
            <entry><literal>TERM</literal></entry>

            <entry>Il proprio tipo di terminale, esempio
              <literal>xterm</literal></entry>
          </row>

          <row>
            <entry><literal>USER</literal></entry>

            <entry>Il proprio username, esempio
              <username>frank</username></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <para>Molte variabili di ambiente sono inizializzate automaticamente quando
      si effettua il login.  Queste possono essere modificate e si possono
      definire altre variabili nei propri file di inizializzazione o in
      qualunque momento all'interno della shell.  Alcune variabili che è
      possibile si voglia cambiare sono <literal>PATH</literal> e
      <literal>DISPLAY</literal>.  La variabile <literal>PATH</literal>
      specifica le directory nelle quali saranno automaticamente cercati i
      comandi richiesti.  Alcuni esempi sono nello script di inizializzazione
      di shell mostrato più avanti.</para>

    <para>Per la shell C si può settare una <emphasis>variabile globale
      di ambiente</emphasis> con un comando simile a quello usato per
      visualizzare le variabili:</para>

    <screen>&prompt.user; <userinput>setenv <replaceable>NOME valore</replaceable></userinput></screen>

    <para>e per la shell Bourne:</para>

    <screen>$ <userinput><replaceable>NOME</replaceable>=<replaceable>valore</replaceable>; export <replaceable>NOME</replaceable></userinput></screen>

    <para>Si possono elencare le proprie variabili globali di ambiente con i
      comandi &man.env.1; o &man.printenv.1;.  Si possono resettare queste
      variabili con i comandi <command>unsetenv</command> (shell C) o
      <command>unset</command> (shell Bourne).</para>

    <para>Per settare una <emphasis>variabile locale di shell</emphasis> in
      shell C si usa il comando <command>set</command> con la sintassi seguente.
      Senza opzioni <command>set</command> mostra tutte le variabili
      locali.</para>

    <screen>&prompt.user; <userinput>set <replaceable>nome</replaceable>=<replaceable>valore</replaceable></userinput></screen>

    <para>Per la shell Bourne si setta una variabile locale di shell
      con:</para>

    <screen>$ <userinput><replaceable>nome</replaceable>=<replaceable>valore</replaceable></userinput></screen>

    <para>Il valore corrente di una variabile è accessibile attraverso le
      notazioni <literal>$<replaceable>nome</replaceable></literal> o
      <literal>${<replaceable>nome</replaceable>}</literal>.</para>
  </sect1>

  <sect1 id="shells-sh">
    <title>La shell Bourne, sh</title>

    <para>La shell &man.sh.1; usa il file di inizializzazione
      <filename>.profile</filename> posto nella home directory dell'utente.
      Inoltre può esserci un file di inizializzazione globale del
      sistema, esempio <filename>/etc/profile</filename>.  In tal caso, il file
      globale del sistema sarà eseguito prima di quello locale.</para>

    <para>Un semplice file <filename>.profile</filename> potrebbe essere come
      il seguente:</para>

    <programlisting>
PATH=/usr/bin:/usr/ucb:/usr/local/bin:.         # setta il PATH
export PATH                   # rende disponibile PATH per le sotto-shell
# setta il prompt
PS1="{`hostname` `whoami`} "     # setta il prompt, $ di default
# funzioni
ls() { /bin/ls -sbF "$@";}
ll() { ls -al "$@";}
# setta il tipo di terminale
stty erase ^H              # setta Control-H come tasto di cancellazione
eval `tset -Q -s -m ':?xterm'` # richiede il tipo di terminale, presupponendo
                               # xterm
#
umask 077</programlisting>

    <para>Ogni volta che si incontra il simbolo #, il resto di quella linea
      viene trattato come un commento.  Nella variabile <literal>PATH</literal>
      ogni directory è separata da due punti (:) e il punto
      (<filename>.</filename>) specifica che la directory corrente è nel
      proprio path.  Se il punto non è nel proprio path, lo stesso
      diventa un semplice elemento per eseguire un programma nella directory
      corrente:</para>

    <para><command>./<replaceable>programma</replaceable></command></para>

    <para>Non è una buona idea avere il punto (<filename>.</filename>)
      nel proprio <literal>PATH</literal>, in modo tale da non eseguire
      inavvertitamente un programma senza averne l'intenzione quando si usa il
      comando <command>cd</command> per spostarsi in differenti
      directory.</para>

    <para>Una variabile settata in <filename>.profile</filename> rimane valida
      solo nel contesto della shell di login, a meno che la si esporti con
      <command>export</command> o si esegua <filename>.profile</filename> in
      un'altra shell.  Nell'esempio precedente <literal>PATH</literal> viene
      esportato per le sotto-shell.  Si può eseguire un file con il
      comando built-int <command>.</command> di &man.sh.1;, esempio:</para>

    <para><command>. ./.profile</command></para>

    <para>Si possono creare proprie funzioni.  Nell'esempio precedente la
      funzione <command>ll</command>, risultato di <command>ls -al</command>,
      lavora su un specifico file o directory.</para>

    <para>Con &man.stty.1; il carattere di cancellazione viene settato a
      <keycombo action="simul">
        <keycap>Control</keycap>
        <keycap>H</keycap>
      </keycombo>, che è usualmente il tasto di
      <keycap>Backspace</keycap>.</para>

    <para>Il comando &man.tset.1; richiede il tipo di terminale e assume questo
      a <literal>xterm</literal> se si conferma con invio
      <keycap>&lt;CR&gt;</keycap>.  Questo comando è eseguito con un
      comando built-in di shell, <command>eval</command>, che prende il
      risultato del comando &man.tset.1; e lo usa come argomento per la shell.
      In questo caso l'opzione <option>-s</option> di &man.tset.1; setta
      le variabili <literal>TERM</literal> e <literal>TERMCAP</literal> e le
      esporta.</para>

    <para>L'ultima linea nell'esempio richiama il comando
      <command>umask</command>, facendo in modo che i file e le directory create
      non abbiano i permessi di lettura-scrittura-esecuzione per l'utenza
      <emphasis>gruppo</emphasis> e <emphasis>altri</emphasis>.</para>

    <para>Per altre informazioni su &man.sh.1;, digitare
      <command>man sh</command> al prompt di shell.</para>
  </sect1>

  <sect1 id="shells-csh">
    <title>La shell C, csh</title>

    <para>La shell C, &man.csh.1;, usa i file di inizializzazione
      <filename>.cshrc</filename> e <filename>.login</filename>.  Alcune
      versioni usano un file di inizializzazione globale del sistema, ad
      esempio <filename>/etc/csh.login</filename>.  Il proprio file
      <filename>.login</filename> è eseguito solamente quando si effettua
      il login.  Il proprio file <filename>.cshrc</filename> è eseguito
      ogni volta in cui si avvia una shell &man.csh.1;, incluso quando si
      effettua il login.  Questo file ha molte caratteristiche simili al file
      <filename>.profile</filename>, ma un differente modo di composizione.
      Qui si usano i comandi <command>set</command> o <command>setenv</command>
      per inizializzare una variabile, dove <command>set</command> viene usato
      per definire una variabile solo per la shell corrente, mentre
      <command>setenv</command> definisce una variabile per la shell corrente e
      per le altre sotto-shell.  Le variabili di ambiente
      <literal>USER</literal>, <literal>TERM</literal> e <literal>PATH</literal>
      sono automaticamente importate ed esportate dalle variabili
      <literal>user</literal>, <literal>term</literal> e <literal>path</literal>
      della shell &man.csh.1;.  Quindi <command>setenv</command> non è
      necessario per queste variabili.  La shell C usa il simbolo ~ per indicare
      la directory home dell'utente in un path, come in
      <filename>~/.cshrc</filename> o per specificare una directory di login di
      un altro utente, come in
      <filename>~<replaceable>username</replaceable>/.cshrc</filename>.</para>

    <para>Alcune variabili predefinite usate dalla shell C sono:</para>

    <informaltable frame="none">
      <tgroup cols="2">
        <colspec colwidth="1.5in"/>

        <tbody>
          <row>
            <entry><literal>argv</literal></entry>

            <entry>La lista degli argomenti della shell corrente</entry>
          </row>

          <row>
            <entry><literal>cwd</literal></entry>

            <entry>La directory di lavoro corrente</entry>
          </row>

          <row>
            <entry><literal>history</literal></entry>

            <entry>Imposta la dimensione della lista di history (storia) da
              memorizzare</entry>
          </row>

          <row>
            <entry><literal>home</literal></entry>

            <entry>La directory home dell'utente, visualizzabile con
              <literal>$HOME</literal></entry>
          </row>

          <row>
            <entry><literal>ignoreeof</literal></entry>

            <entry>Quando viene settata, EOF (<keycombo action="simul">
                <keycap>Ctrl</keycap>
                <keycap>D</keycap>
              </keycombo>) viene ignorato dal terminale</entry>
          </row>

          <row>
            <entry><literal>noclobber</literal></entry>

            <entry>Quando viene settata si impedisce di redirigere l'output per
              sovrascrivere file esistenti</entry>
          </row>

          <row>
            <entry><literal>noglob</literal></entry>

            <entry>Quando viene settata si impedisce l'espansione dei nomi di
              file all'interno di un confronto con uno schema wild card</entry>
          </row>

          <row>
            <entry><literal>path</literal></entry>

            <entry>I path di ricerca dei comandi, visualizzabile con
              <literal>$PATH</literal></entry>
          </row>

          <row>
            <entry><literal>prompt</literal></entry>

            <entry>Setta il prompt della linea di comando (&prompt.user; di
              default)</entry>
          </row>

          <row>
            <entry><literal>savehist</literal></entry>

            <entry>Numero di volte (di login) che bisogna mantenere memorizzata
              la lista di history nel file <filename>.history</filename></entry>
          </row>

          <row>
            <entry><literal>shell</literal></entry>

            <entry>Il path name completo della shell corrente, visualizzabile
              con <literal>$SHELL</literal></entry>
          </row>

          <row>
            <entry><literal>status</literal></entry>

            <entry>Il codice di stato di uscita dell'ultimo comando
              (0=uscita normale, 1=comando fallito)</entry>
          </row>

          <row>
            <entry><literal>term</literal></entry>

            <entry>Il proprio tipo di terminale, visualizzabile con
              <literal>$TERM</literal></entry>
          </row>

          <row>
            <entry><literal>user</literal></entry>

            <entry>Il proprio nome utente, username, visualizzabile con
              <literal>$USER</literal></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <para>Un semplice file <filename>.cshrc</filename> potrebbe essere come il
      seguente:</para>

    <programlisting>
set path=(/usr/bin /usr/ucb /usr/local/bin ~/bin . ) # setta il path
set prompt = "{`hostname` `whoami` !} "   # setta il promt primario ;
                                          # % di default
set noclobber                  # non redirige l'output su file esistenti
set ignoreeof                      #ignora EOF (Ctrl+D) in questa shell
set history=100 savehist=50   # mantiene una lista history di comandi e la
                              # memorizza tra vari (50) login
# alias
alias h history                    # alias h per history
alias ls "/usr/bin/ls -sbF"        # alias ls per ls -sbF
alias ll ls -al              # alias ll per ls -sbFal (combina queste
                             # opzioni con quelle di ls sopra citate)
alias cd 'cd \!*;pwd'        # alias cd per stampare la directory di lavoro
                             # corrente dopo aver cambiato directory
umask 077</programlisting>

    <para>Alcune nuove caratteristiche che non sono state viste nel
      file <filename>.profile</filename> (shell &man.sh.1;) sono
      <literal>noclobber</literal>, <literal>ignoreeof</literal> e
      <literal>history</literal>.  <literal>Noclobber</literal> indica che
      l'output non può essere rediretto su un file esistente, mentre
      <literal>ignoreeof</literal> specifica  che EOF (
      <keycombo action="simul">
        <keycap>Ctrl</keycap>
        <keycap>D</keycap>
      </keycombo>) non causa l'uscita dalla shell di login o l'uscita dal
      sistema.</para>

    <para>Con la caratteristica di <emphasis>history</emphasis> si possono
      richiamare comandi eseguiti precedentemente e rieseguirli, eventualmente
      con dei cambiamenti.</para>

    <para>Un <emphasis>alias</emphasis> permette di usare uno specifico nome
      <emphasis>alias</emphasis> al posto del comando completo.  Nell'esempio
      precedente, il risultato di digitare <command>ls</command> sarà
      quello di eseguire <command>/usr/bin/ls -sbF</command>.  Si può
      verificare quale comando <command>ls</command> è nel proprio path
      con il comando &man.which.1;, ad esempio:</para>

    <screen>&prompt.user; <userinput>which ls</userinput>
ls:     alias di /usr/bin/ls -sbF</screen>

    <para>Un semplice file <filename>.login</filename> potrebbe essere come il
      seguente:</para>

    <programlisting># .login
stty erase ^H      # setta Control+H come tasto di eliminazione
set noglob     # impedisce un confronto con uno schema wild card
eval `tset -Q -s -m ':?xterm'`  # chiede il tipo di terminale presupponendo
                                # xterm
unset noglob       # riabilita un confronto con uno schema wild card</programlisting>

    <para>Abilitando e disabilitando <literal>noglob</literal> intorno a
      &man.tset.1; si impedisce di confondere il tipo di terminale con
      qualche espansione dei nomi di file in un confronto con uno schema
      (pattern) wild card.</para>

    <para>Se si effettuano cambiamenti al proprio file di inizializzazione,
      questi possono essere attivati eseguendo il file modificato.  Per la shell
      &man.csh.1; questo è possibile attraverso il comando
      built-in <command>source</command>, esempio:</para>

    <para><command>source .cshrc</command></para>

    <para>Per altre informazioni circa la shell &man.csh.1; digitare
      <command>man csh</command> al prompt di shell.</para>
  </sect1>

  <sect1 id="shells-job-control">
    <title>Controllo dei job</title>

    <para>Con la shell C, &man.csh.1; e molte altre nuove shell, incluse alcune
      nuove shell Bourne, si possono mettere i job in background apporrendo
      <emphasis>&amp;</emphasis> al comando, così come succede per la
      shell &man.sh.1;.  Questo può anche essere fatto, una volta
      sottoposto il comando, digitando <keycombo action="simul">
        <keycap>Control</keycap>
        <keycap>Z</keycap>
      </keycombo> per sospendere il job e quindi <command>bg</command> per
      metterlo in background.  Per riportarlo in foreground si digita
      <command>fg</command>.</para>

    <para>Si possono avere molti job eseguiti in background.  Quando questi sono
      in background, non sono connessi alla tastiera per l'input, ma possono
      tuttavia mostrare l'output nel terminale, sparpagliandolo con qualsiasi
      cosa ci sia digitata o mostrata attraverso il job corrente.  Si può
      avere la necessità di redirigere I/O in o da un file per un job in
      background.  La propria tastiera è solamente connessa al corrente
      job in foreground.</para>

    <para>Il comando built-in <command>jobs</command> permette di elencare i
      propri job in background.  Si può usare il comando &man.kill.1; per
      terminare un job in background.  In questi comandi, con la notazione
      <emphasis>%<replaceable>n</replaceable></emphasis> ci si riferisce
      all'<replaceable>n-esimo</replaceable> job in background, rimpiazzando
      <replaceable>n</replaceable> con il numero di job proveniente dall'output
      di <command>jobs</command>.  Quindi si termina il secondo job in
      background con <command>kill %2</command> e si riprende il terzo job in
      foreground con <command>fg %3</command>.</para>
  </sect1>

  <sect1 id="shells-history">
    <title>History</title>

    <para>La shell C, la shell Korn e molte altre shell avanzate, mantengono
      informazioni sui comandi che sono stati eseguiti in shell.  La
      quantità di storia memorizzabile dipende dalla shell utilizzata.
      Qui si descriveranno le caratteristiche di history della shell C.</para>

    <para>Si possono usare le variabili <literal>history</literal> e
      <literal>savehist</literal> per settare rispettivamente quanti comandi
      della shell corrente memorizzare e per quanti login mantenerli.
      Si può inserire in <filename>.cshrc</filename> la seguente linea
      per memorizzare 100 comandi della shell corrente fino a 50 prossimi
      login.</para>

    <para><command>set history=100 savehist=50</command></para>

    <para>La shell mantiene traccia della storia dei comandi tra un login e
        l'altro memorizzandola nel file <filename>~/.history</filename>.</para>

    <para>Si può usare il comando built-in <command>history</command> per
      richiamare i comandi eseguiti precedentemente, ad esempio per stampare gli
      ultimi 10:</para>

    <screen>&prompt.user; <userinput>history 10</userinput>
52 cd workshop
53 ls
54 cd Unix_intro
55 ls
56 pwd
57 date
58 w
59 alias
60 history
61 history 10</screen>

    <para>Si può ripetere l'ultimo comando digitando
      <command>!!</command>:</para>

    <screen>&prompt.user; <userinput>!!</userinput>
53 ls
54 cd Unix_intro
55 ls
56 pwd
57 date
58 w
59 alias
60 history
61 history 10
62 history 10</screen>

    <para>Si può ripetere un comando numerato introducendo il numero con
      un <command>!</command>, esempio:</para>

    <screen>&prompt.user; <userinput>!57</userinput>
date
Tue Apr 9 09:55:31 EDT 1996</screen>

    <para>Si può ripetere un comando che inizia con qualche stringa,
      introducendo la parte iniziale univoca della stringa con un
      <command>!</command>, esempio:</para>

    <screen>&prompt.user; <userinput>!da</userinput>
date
Tue Apr 9 09:55:31 EDT 1996</screen>

    <para>Quando la shell valuta la linea di comando verifica subito la
      sostituzione di history prima di interpretare qualche altra cosa.  Per
      usare uno di questi caratteri speciali in un comando di shell è
      necessario usare un escape, o effettuare un quoting, apporrendo un \ prima
      del carattere, esempio \!.  I caratteri di sostituzione di history sono
      sintetizzati nella tabella seguente:</para>

    <table frame="all" id="shells-table-history-sob">
      <title>Comandi di sostituzione di history per la shell C</title>

      <tgroup cols="2">
        <colspec colwidth="1.5in"/>

        <thead>
          <row>
            <entry align="center">Comando</entry>

            <entry align="center">Funzione sostitutiva</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><command>!!</command></entry>

            <entry>ripete l'ultimo comando</entry>
          </row>

          <row>
            <entry><command>!<replaceable>n</replaceable></command></entry>

            <entry>ripete il comando numero <replaceable>n</replaceable></entry>
          </row>

          <row>
            <entry><command>!-<replaceable>n</replaceable></command></entry>

            <entry>ripete l'<replaceable>n-esimo</replaceable> comando partendo
              dall'ultimo</entry>
          </row>

          <row>
            <entry><command>!<replaceable>str</replaceable></command></entry>

            <entry>ripete il comando che inizia con la stringa
              <replaceable>str</replaceable></entry>
          </row>

          <row>
            <entry><command>!?<replaceable>str</replaceable>?</command></entry>

            <entry>ripete il comando con all'interno
              <replaceable>str</replaceable></entry>
          </row>

          <row>
            <entry><command>!?<replaceable>str</replaceable>?%</command></entry>

            <entry>seleziona il primo argomento che ha
              <replaceable>str</replaceable> all'interno</entry>
          </row>

          <row>
            <entry><command>!:</command></entry>

            <entry>ripete l'ultimo comando, generalmente usato con una
              modifica</entry>
          </row>

          <row>
            <entry><command>!:<replaceable>n</replaceable></command></entry>

            <entry>seleziona l'<replaceable>n-esimo</replaceable> argomento
              dell'ultimo comando (n=0 è il nome del comando)</entry>
          </row>

          <row>
            <entry><command>!:<replaceable>n</replaceable>-<replaceable>m</replaceable></command></entry>

            <entry>seleziona gli argomenti tra
              l'<replaceable>n-esimo</replaceable> e
              l'<replaceable>m-esimo</replaceable> argomento dell'ultimo
              comando</entry>
          </row>

          <row>
            <entry><command>!^</command></entry>

            <entry>seleziona il primo argomento dell'ultimo comando (come
              <command>!:1</command>)</entry>
          </row>

          <row>
            <entry><command>!$</command></entry>

            <entry>seleziona l'ultimo argomento dell'ultimo comando</entry>
          </row>

          <row>
            <entry><command>!*</command></entry>

            <entry>seleziona tutti gli argomenti del precedente comando</entry>
          </row>

          <row>
            <entry><command>!:<replaceable>n</replaceable>*</command></entry>

            <entry>seleziona gli argomenti
              dall'<replaceable>n-esimo</replaceable> all'ultimo, incluso, del
              precedente comando</entry>
          </row>

          <row>
            <entry><command>!:<replaceable>n</replaceable>-</command></entry>

            <entry>seleziona gli argomenti
              dall'<replaceable>n-esimo</replaceable> all'ultimo, escluso, del
              precedente comando</entry>
          </row>

          <row>
            <entry><command>^<replaceable>str1</replaceable>^<replaceable>str2</replaceable>^</command></entry>

            <entry>rimpiazza <replaceable>str1</replaceable> con
              <replaceable>str2</replaceable> nella prima occorrenza nel
              precedente comando</entry>
          </row>

          <row>
            <entry><command>!<replaceable>n</replaceable>:s/<replaceable>str1</replaceable>/<replaceable>str2</replaceable>/</command></entry>

            <entry>sostituisce <replaceable>str1</replaceable> con
              <replaceable>str2</replaceable> nella prima occorrenza
              nell'<replaceable>n-esimo</replaceable> comando, finendo con una
              sostituzione globale <emphasis>g</emphasis>
            </entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para>Altre informazioni sono descritte nelle <emphasis>pagine
        man</emphasis>.</para>
  </sect1>

  <sect1 id="shells-change">
    <title>Cambiare la propria shell</title>

    <para>Per cambiare la propria shell si usano generalmente i comandi
      &man.chsh.1; o <command>passwd -e</command>.  Il flag di opzione, qui
      <option>-e</option>, può cambiare da sistema a sistema
      (<option>-s</option> su sistemi basati su BSD), quindi verificare le
      proprie <emphasis>pagine man</emphasis> sul proprio sistema per un
      uso corretto.  Alcune volte questa caratteristica è disabilitata.
      Se non si riesce a cambiare la propria shell contattare il proprio
      amministratore di sistema (System Administrator).</para>

    <para>La nuova shell deve essere un path name assoluto di una valida shell
      sul sistema.  Le shell disponibili variano da sistema a sistema.  Inoltre
      il path name assoluto della shell può cambiare.  Normalmente, per
      la shell Bourne e la shell C sono standard e sono:</para>

    <para><filename>/bin/sh</filename></para>

    <para><filename>/bin/csh</filename></para>

    <para>Alcuni sistemi hanno anche la shell Korn standard normalmente
      in:</para>

    <para><filename>/bin/ksh</filename></para>

    <para>Altre shell, che sono poco popolari e non distribuite normalmente
      dal venditore di OS, sono &man.bash.1; e &man.tcsh.1;.  Queste potrebbero
      essere situate in <filename>/bin</filename> o in una directory locale,
      esempio <filename>/usr/local/bin</filename> o
      <filename>/opt/local/bin</filename>.  Se si sceglie una shell non standard
      del OS, ci si deve assicurare che quella shell e tutte le shell di login
      disponibili sul sistema siano elencate nel file
      <filename>/etc/shells</filename>.  Se questo file esiste e la propria
      shell non è elencata in esso, il demone per il trasferimento di
      file, &man.ftpd.8;, ti impedirà una connessione ftp su questa
      macchina.  Se tale file non esiste, solamente account con shell
      <quote>standard</quote> possono connettersi via &man.ftp.1;.</para>

    <para>Si può sempre provare una shell prima di settarla come la
      propria shell di default.  Per fare questo si deve digitare il nome della
      shell che si desidera utilizzare, come qualsiasi altro comando.</para>
  </sect1>
</chapter>
