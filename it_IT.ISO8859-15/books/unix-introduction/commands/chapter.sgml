<!--
     The FreeBSD Italian Documentation Project

     $FreeBSD$
-->

<chapter id="commands">
  <title>Altri comandi utili</title>

  <sect1 id="commands-work-files">
    <title>Lavorare con i file</title>

    <para>Questa sezione descrive alcuni comandi che possono risultare utili
      nell'esaminare e manipolare il contenuto dei propri file.</para>

    <table frame="all" id="commands-table-utilities-files">
      <title>Utilit&agrave; file</title>

      <tgroup cols="2">
        <colspec colwidth="3in">

        <thead>
          <row>
            <entry align="center">Comando/Sintassi</entry>

            <entry align="center">Cosa fa</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><command>cmp [<replaceable>opzioni</replaceable>]
                <replaceable>file1 file2</replaceable></command></entry>

            <entry>confronta due file e mostra dove avvengono le differenze
              (file di testo e file binari)</entry>
          </row>

          <row>
            <entry><command>cut [<replaceable>opzioni</replaceable>]
                [<replaceable>file</replaceable>]</command></entry>

            <entry>taglia specifici campi/caratteri dalle linee di un
              file</entry>
          </row>

          <row>
            <entry><command>diff [<replaceable>opzioni</replaceable>]
                <replaceable>file1 file2</replaceable></command></entry>

            <entry>confronta due file e mostra le differenze
              (solamente file di testo)</entry>
          </row>

          <row>
            <entry><command>file [<replaceable>opzioni</replaceable>]
                <replaceable>file</replaceable></command></entry>

            <entry>classifica il tipo di file</entry>
          </row>

          <row>
            <entry><command>find <replaceable>directory</replaceable>
                [<replaceable>opzioni</replaceable>]
                [<replaceable>azioni</replaceable>]</command></entry>

            <entry>cerca file basandosi sul tipo o su uno schema</entry>
          </row>

          <row>
            <entry><command>ln [<replaceable>opzioni</replaceable>]
                <replaceable>sorgente</replaceable>
                <replaceable>destinazione</replaceable></command></entry>

            <entry>crea un link (collegamento) a
              <filename><replaceable>sorgente</replaceable></filename> chiamato
              <filename><replaceable>destinazione</replaceable></filename></entry>
          </row>

          <row>
            <entry><command>paste [<replaceable>opzioni</replaceable>]
                <replaceable>file</replaceable></command></entry>

            <entry>aggiunge campi all'interno di un file</entry>
          </row>

          <row>
            <entry><command>sort [<replaceable>opzioni</replaceable>]
                <replaceable>file</replaceable></command></entry>

            <entry>riordina le linee di un file in accordo con le opzioni
              specificate</entry>
          </row>

          <row>
            <entry><command>strings [<replaceable>opzioni</replaceable>]
                <replaceable>file</replaceable></command></entry>

            <entry>riporta sequenze di 4 o pi&ugrave; caratteri stampabili
              terminati con &lt;NL&gt; o &lt;NULL&gt;.  Normalmente utilizzato
              per ricercare stringhe ASCII in file binari.</entry>
          </row>

          <row>
            <entry><command>tee [<replaceable>opzioni</replaceable>]
                <replaceable>file</replaceable></command></entry>

            <entry>copia standard output in uno o pi&ugrave; file</entry>
          </row>

          <row>
            <entry><command>touch [<replaceable>opzioni</replaceable>]
                [<replaceable>data/ora</replaceable>]
                <replaceable>file</replaceable></command></entry>

            <entry>crea un file vuoto o aggiorna la data di accesso di un file
              esistente</entry>
          </row>

          <row>
            <entry><command>tr [<replaceable>opzioni</replaceable>]
                <replaceable>stringa1 stringa2</replaceable></command></entry>

            <entry>traduce i caratteri di <replaceable>stringa1</replaceable>
              provenienti da standard input in quelli di
              <replaceable>stringa2</replaceable> per standard output</entry>
          </row>

          <row>
            <entry><command>uniq [<replaceable>opzioni</replaceable>]
                <replaceable>file</replaceable></command></entry>

            <entry>rimuove le linee ripetute in un file</entry>
          </row>

          <row>
            <entry><command>wc [<replaceable>opzioni</replaceable>]
                [<replaceable>file</replaceable>]</command></entry>

            <entry>mostra il numero di parole (o di caratteri o di linee) di
              un file</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <sect2 id="commands-work-files-cmp">
      <title>cmp - confronta contenuti di file</title>

      <para>Il comando &man.cmp.1; confronta due file, e (senza opzioni) riporta
        la posizione della loro prima differenza.  Pu&ograve; trattare confronti
        sia tra file ASCII sia tra file binari.  Il comando compie una
        comparazione byte-per-byte.</para>

      <para><emphasis>Sintassi</emphasis></para>

      <para><command>cmp [<replaceable>opzioni</replaceable>]
          <replaceable>file1 file2</replaceable>
          [<replaceable>salto1</replaceable>]
          [<replaceable>salto2</replaceable>]</command></para>

      <para>I numeri di <emphasis>salto</emphasis> sono i numeri di byte da
        saltare in ogni file prima di iniziare il confronto.</para>

      <para><emphasis>Opzioni generali</emphasis></para>

      <informaltable frame="none">
        <tgroup cols="2">
          <colspec colwidth="0.5in">

          <tbody>
            <row>
              <entry><option>-l</option></entry>

              <entry>riporta ogni differenza</entry>
            </row>

            <row>
              <entry><option>-s</option></entry>

              <entry>riporta solamente un valore di uscita, non le differenze
                tra i byte</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para><emphasis>Esempi:</emphasis></para>

      <para>Dati i file <filename>mon.logins</filename> e
        <filename>tues.logins</filename>:</para>

      <programlisting>ageorge         ageorge
bsmith          cbetts
cbetts          jchen
jchen           jdoe
jmarsch         jmarsch
lkeres          lkeres
mschmidt        proy
sphillip        sphillip
wyepp           wyepp</programlisting>

      <para>Il confronto dei due file produce:</para>

      <screen>&prompt.user; <userinput>cmp mon.logins tues.logins</userinput>
mon.logins tues.logins differ: char 9, line 2</screen>

      <para>Di default il comando riporta solamente la prima differenza
        trovata.</para>

      <para>Questo comando &egrave; utile nel determinare quale versione di un
        file dovrebbe essere mantenuta quando c'&egrave; pi&ugrave; di una
        versione dello stesso file.</para>
    </sect2>

    <sect2 id="commands-work-files-diff">
      <title>diff - differenze tra file</title>

      <para>Il comando &man.diff.1; confronta due file, due directory,
        ecc., e riporta tutte le differenze tra i due.  Questo comando tratta
        solamente file ASCII.  Il suo formato di output &egrave; stato
        progettato per fornire i cambiamenti necessari per convertire il primo
        file nel secondo.</para>

      <para><emphasis>Sintassi</emphasis></para>

      <para><command>diff [<replaceable>opzioni</replaceable>]
          <replaceable>file1 file2</replaceable></command></para>

      <para><emphasis>Opzioni generali</emphasis></para>

      <informaltable frame="none">
        <tgroup cols="2">
          <colspec colwidth="0.5in">

          <tbody>
            <row>
              <entry><option>-b</option></entry>

              <entry>ignora spazi contigui</entry>
            </row>

            <row>
              <entry><option>-i</option></entry>

              <entry>ignora la differenza tra lettere minuscole e
                maiuscole</entry>
            </row>

            <row>
              <entry><option>-w</option></entry>

              <entry>ignora i caratteri di spazio e tab</entry>
            </row>

            <row>
              <entry><option>-e</option></entry>

              <entry>produce un formato di output da utilizzare con l'editor
                &man.ed.1;</entry>
            </row>

            <row>
              <entry><option>-r</option></entry>

              <entry>esegue &man.diff.1; ricorsivamente attraverso le
                sotto-directory</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para><emphasis>Esempi:</emphasis></para>

      <para>Per i file sopra citati <filename>mon.logins</filename> e
        <filename>tues.logins</filename>, le loro differenze sono:</para>

      <screen>&prompt.user; <userinput>diff mon.logins tues.logins</userinput>
2d1
< bsmith
4a4
> jdoe
7c7
< mschmidt
---
> proy</screen>

      <para>Notare che l'output mostra sia l'elenco delle differenze sia in
        quale file queste esistono.  Le linee del primo file sono precedute da
        &lt; e quelle del secondo file sono precedute da &gt;.</para>
    </sect2>

    <sect2 id="commands-work-files-cut">
      <title>cut - seleziona parte di una linea di un file</title>

      <para>Il comando &man.cut.1; permette di estrarre una parte di
        un file che verr&agrave; utilizzata per un altro scopo.</para>

      <para><emphasis>Sintassi</emphasis></para>

      <para><command>cut [<replaceable>opzioni</replaceable>]
          <replaceable>file</replaceable></command></para>

      <para><emphasis>Opzioni generali</emphasis></para>

      <informaltable frame="none">
        <tgroup cols="2">
          <colspec colwidth="2in">

          <tbody>
            <row>
              <entry><option>-c
                  <replaceable>lista_caratteri</replaceable></option></entry>

              <entry>posizioni dei caratteri da selezionare (il primo carattere
                &egrave; in posizione 1)</entry>
            </row>

            <row>
              <entry><option>-d
                  <replaceable>delimitatore</replaceable></option></entry>

              <entry>delimitatore di campo (tab di default)</entry>
            </row>

            <row>
              <entry><option>-f
                  <replaceable>lista_campi</replaceable></option></entry>

              <entry>campi da selezionare (il primo campo &egrave; 1)</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>Sia la lista dei caratteri che quella dei campi possono contenere
        numeri (in ordine crescente) separati da virgole o da spazi bianchi e
        possono contenere un trattino (-) per indicare un range.  La mancanza di
        un numero prima del trattino (esempio -5) o dopo il trattino
        (esempio 5-), specifica rispettivamente un range completo che inizia con
        il primo carattere o campo, o finisce con l'ultimo carattere o campo.
        I caratteri bianchi di separazione di lista devono essere chiusi tra
        caratteri di quoting.  I campi di delimitazione possono essere chiusi
        tra quoting se hanno un significato speciale di shell, ad esempio quando
        specificano un carattere di tab o spazio.</para>

      <para><emphasis>Esempi:</emphasis></para>

      <para>In questi esempi si user&agrave; il file
        <filename>users</filename>:</para>

      <programlisting>jdoe    John Doe        4/15/96
lsmith  Laura Smith     3/12/96
pchen   Paul Chen       1/5/96
jhsu    Jake Hsu        4/17/96
sphilip Sue Phillip     4/2/96</programlisting>

      <para>Se si desidera solo lo username e il nome reale dell'utente, il
        comando &man.cut.1; pu&ograve; essere usato per ottenere solamente
        queste informazioni:</para>

      <screen>&prompt.user; <userinput>cut -f 1,2 users</userinput>
jdoe    John Doe
lsmith  Laura Smith
pchen   Paul Chen
jhsu    Jake Hsu
sphilip Sue Phillip</screen>

      <para>Il comando &man.cut.1; pu&ograve; essere usato con altre opzioni.
        L'opzione <option>-c</option> permette di selezionare caratteri.  Per
        selezionare i primi 4 caratteri:</para>

      <screen>&prompt.user; <userinput>cut -c 1-4 users</userinput></screen>

      <para>che produrr&agrave;:</para>

      <screen>jdoe
lsmi
pche
jhsu
sphi</screen>

      <para>in questo modo si selezionano solamente i primi 4 caratteri di ogni
        linea.</para>
    </sect2>

    <sect2 id="commands-work-files-paste">
      <title>paste - fusione di file</title>

      <para>Il comando &man.paste.1; permette di combinare insieme due
        file.  In una fusione, il delimitatore di default tra le colonne
        &egrave; un tab, ma le opzioni permettono di usare altri
        delimitatori.</para>

      <para><emphasis>Sintassi</emphasis></para>

      <para><command>paste [<replaceable>opzioni</replaceable>]
          <replaceable>file1 file2</replaceable></command></para>

      <para><emphasis>Opzioni generali</emphasis></para>

      <informaltable frame="none">
        <tgroup cols="2">
          <colspec colwidth="1in">

          <tbody>
            <row>
              <entry><option>-d
                  <replaceable>lista</replaceable></option></entry>

              <entry>elenco dei caratteri di delimitazione</entry>
            </row>

            <row>
              <entry><option>-s</option></entry>

              <entry>concatena linee</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>L'elenco dei <emphasis>delimitatori</emphasis> pu&ograve;
        comprendere singoli caratteri come una virgola, una stringa quotata,
        uno spazio o alcune delle seguenti sequenze di escape:</para>

      <informaltable frame="none">
        <tgroup cols="2">
          <colspec colwidth="0.5in">

          <tbody>
            <row>
              <entry>\n</entry>

              <entry>carattere newline</entry>
            </row>

            <row>
              <entry>\t</entry>

              <entry>carattere tab</entry>
            </row>

            <row>
              <entry>\\</entry>

              <entry>carattere backslash</entry>
            </row>

            <row>
              <entry>\0</entry>

              <entry>stringa vuota (carattere non-null)</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>Pu&ograve; essere necessario quotare i delimitatori che hanno
        significati speciali di shell.</para>

      <para>Un trattino (-) al posto di un nome di file viene usato per
        indicare che quel campo dovrebbe venire da standard input.</para>

      <para><emphasis>Esempi:</emphasis></para>

      <para>Dato il file <filename>users</filename>:</para>

      <programlisting>jdoe    John Doe        4/15/96
lsmith  Laura Smith     3/12/96
pchen   Paul Chen       1/5/96
jhsu    Jake Hsu        4/17/96
sphilip Sue Phillip     4/2/96</programlisting>

      <para>e il file <filename>phone</filename>:</para>

      <programlisting>John Doe        555-6634
Laura Smith     555-3382
Paul Chen       555-0987
Jake Hsu        555-1235
Sue Phillip     555-7623</programlisting>

      <para>il comando &man.paste.1; pu&ograve; essere usato in combinazione
        con il comando &man.cut.1; per creare un nuovo file,
        <filename>listing</filename>, che include per tutti gli utenti lo
        username, il nome reale, l'ultimo login e il numero di telefono.
        Prima si estraggono i numeri di telefono all'interno del file temporaneo
        <filename>temp.file</filename>:</para>

      <screen>&prompt.user; <userinput>cut -f2 phone > temp.file</userinput>
555-6634
555-3382
555-0987
555-1235
555-7623</screen>

      <para>Il risultato pu&ograve; essere incollato alla fine di ogni linea di
        <filename>users</filename> e quindi rediretto nel nuovo file,
        <filename>listing</filename>:</para>

      <screen>&prompt.user; <userinput>paste users temp.file > listing</userinput>
jdoe    John Doe        4/15/96         237-6634
lsmith  Laura Smith     3/12/96         878-3382
pchen   Paul Chen       1/5/96          888-0987
jhsu    Jake Hsu        4/17/96         545-1235
sphilip Sue Phillip     4/2/96          656-7623</screen>

      <para>Tutto questo pu&ograve; anche essere realizzato su una linea senza
        il file temporaneo, con lo stesso risultato:</para>

      <screen>&prompt.user; <userinput>cut -f2 phone | paste users - > listing</userinput></screen>

      <para>In questo caso il trattino (-) funge come sostituto per il campo di
        input (indica cio&egrave; l'output del comando &man.cut.1;).</para>
    </sect2>

    <sect2 id="commands-work-files-touch">
      <title>touch - crea un file</title>

      <para>Il comando &man.touch.1; pu&ograve; essere usato per creare un nuovo
        (vuoto) file o per aggiornare l'ultima data/ora di accesso di un
        file esistente.  Il comando viene usato primariamente quando uno script
        richiede la pre-esistenza di un file (ad esempio per appendere delle
        informazioni) o quando uno script controlla l'ultima data/ora in cui una
        funzione &egrave; stata realizzata.</para>

      <para><emphasis>Sintassi</emphasis></para>

      <para><command>touch [<replaceable>opzioni</replaceable>]
          [<replaceable>data/ora1</replaceable>]
          <replaceable>file</replaceable></command></para>

      <para><command>touch [<replaceable>opzioni</replaceable>]
          [-t <replaceable>data/ora2</replaceable>]
          <replaceable>file</replaceable></command></para>

      <para><emphasis>Opzioni generali</emphasis></para>

      <informaltable frame="none">
        <tgroup cols="2">
          <colspec colwidth="1.3in">

          <tbody>
            <row>
              <entry><option>-a</option></entry>

              <entry>cambia la data/ora di accesso al file
                (solamente SVR4)</entry>
            </row>

            <row>
              <entry><option>-c</option></entry>

              <entry>non crea il file se non esiste</entry>
            </row>

            <row>
              <entry><option>-f</option></entry>

              <entry>forza l'azione, nonostante i permessi di lettura/scrittura
                del file</entry>
            </row>

            <row>
              <entry><option>-m</option></entry>

              <entry>cambia la data/ora di modifica del file
                (solamente SVR4)</entry>
            </row>

            <row>
              <entry><option>-t
                  <replaceable>data/ora2</replaceable></option></entry>

              <entry>usa la data/ora2 specificata, non la data/ora corrente
                (solamente SVR4)</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>Quando si usa l'opzione <option>-t
          <replaceable>data/ora2</replaceable></option>, deve essere nella
        forma:</para>

      <para>[[<replaceable>CC</replaceable>]<replaceable>YY</replaceable>]
        <replaceable>MMDDhhmm</replaceable>[.<replaceable>SS</replaceable>]</para>

      <para>dove:</para>

      <informaltable frame="none">
        <tgroup cols="2">
          <colspec colwidth="0.5in">

          <tbody>
            <row>
              <entry><replaceable>CC</replaceable></entry>

              <entry>prime due cifre dell'anno</entry>
            </row>

            <row>
              <entry><replaceable>YY</replaceable></entry>

              <entry>seconde due cifre dell'anno</entry>
            </row>

            <row>
              <entry><replaceable>MM</replaceable></entry>

              <entry>mese, 01-12</entry>
            </row>

            <row>
              <entry><replaceable>DD</replaceable></entry>

              <entry>giorno del mese, 01-31</entry>
            </row>

            <row>
              <entry><replaceable>hh</replaceable></entry>

              <entry>ora del giorno, 00-23</entry>
            </row>

            <row>
              <entry><replaceable>mm</replaceable></entry>

              <entry>minuti, 00-59</entry>
            </row>

            <row>
              <entry><replaceable>SS</replaceable></entry>

              <entry>secondi, 00-59</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>Il formato dell'opzione
        <option><replaceable>data/ora1</replaceable></option> &egrave;:</para>

      <para><option><replaceable>MMDDhhmm</replaceable>[<replaceable>YY</replaceable>]</option></para>

      <para>dove questi simboli hanno gli stessi significati dei simboli
        mostrati in precedenza.</para>

      <para>La data non pu&ograve; essere settata prima del 1969 o dopo il 18
        Gennaio 2038 (dipende dalle versione del sistema operativo Unix).</para>

      <para><emphasis>Esempi:</emphasis></para>

      <para>Per creare un file:</para>

      <screen>&prompt.user; <userinput>touch <replaceable>filename</replaceable></userinput></screen>
    </sect2>

    <sect2 id="commands-work-files-wc">
      <title>wc - conta le parole in un file</title>

      <para>&man.wc.1; sta per <quote>conta parole</quote>; il comando
        pu&ograve; essere usato per contare il numero di linee, di caratteri o
        di parole in un file.</para>

      <para><emphasis>Sintassi</emphasis></para>

      <para><command>wc [<replaceable>opzioni</replaceable>]
          <replaceable>file</replaceable></command></para>

      <para><emphasis>Opzioni generali</emphasis></para>

      <informaltable frame="none">
        <tgroup cols="2">
          <colspec colwidth="0.5in">

          <tbody>
            <row>
              <entry><option>-c</option></entry>

              <entry>conta byte</entry>
            </row>

            <row>
              <entry><option>-m</option></entry>

              <entry>conta caratteri (SVR4)</entry>
            </row>

            <row>
              <entry><option>-l</option></entry>

              <entry>conta linee</entry>
            </row>

            <row>
              <entry><option>-w</option></entry>

              <entry>conta parole</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>Se nessuna opzione viene specificata, l'opzione di default &egrave;
        <option>-lwc</option>.</para>

      <para><emphasis>Esempi:</emphasis></para>

      <para>Dato il file <filename>users</filename>:</para>

      <programlisting>jdoe    John Doe        4/15/96
lsmith  Laura Smith     3/12/96
pchen   Paul Chen       1/5/96
jhsu    Jake Hsu        4/17/96
sphilip Sue Phillip     4/2/96</programlisting>

      <para>il risultato dell'uso del comando &man.wc.1; su tale file &egrave;
        il seguente:</para>

      <screen>&prompt.user; <userinput>wc users</userinput>
5 20 121 users</screen>

      <para>Il primo numero indica il numero di linee nel file, il secondo
        indica il numero di parole e il terzo numero indica il numero di
        caratteri.</para>

      <para>Usando il comando &man.wc.1; con una delle opzioni sopra citate
        (<option>-l</option> per linee; <option>-w</option> per parole  o
        <option>-c</option> per caratteri) si ottiene come risultato solo
        una delle precedenti informazioni.  Per esempio,
        <command>wc -l users</command> produce il risultato seguente:</para>

      <screen>5 users</screen>
    </sect2>

    <sect2 id="commands-work-files-ln">
      <title>ln - crea un link a un altro file</title>

      <para>Il comando &man.ln.1; crea un <quote>link</quote> (collegamento) o
        un modo aggiuntivo per accedere (o attribuisce un nome addizionale) a un
        altro file.</para>

      <para><emphasis>Sintassi</emphasis></para>

      <para><command>ln [<replaceable>opzioni</replaceable>]
          <replaceable>sorgente</replaceable>
          [<replaceable>destinazione</replaceable>]</command></para>

      <para>Se non specificata, la
        <filename><replaceable>destinazione</replaceable></filename> di default
        &egrave; un file dello stesso nome di
        <filename><replaceable>sorgente</replaceable></filename> posto nella
        directory di lavoro corrente.</para>

      <para><emphasis>Opzioni generali</emphasis></para>

      <informaltable frame="none">
        <tgroup cols="2">
          <colspec colwidth="0.5in">

          <tbody>
            <row>
              <entry><option>-f</option></entry>

              <entry>forza un link nonostante i permessi della
                destinazione; non riporta errori (solamente SVR4 )</entry>
            </row>

            <row>
              <entry><option>-s</option></entry>

              <entry>crea un link simbolico</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para><emphasis>Esempi:</emphasis></para>

      <para>Un <emphasis>link simbolico</emphasis> viene usato per creare un
        nuovo percorso a un altro file o directory.  Per esempio, se un gruppo
        di utenti &egrave; abituato ad usare un comando chiamato
        <command>chkmag</command>, ma il comando &egrave; stato riscritto e il
        nuovo nome &egrave; <command>chkit</command>, creando un link simbolico
        gli utenti eseguiranno automaticamente <command>chkit</command> quando
        digitano il comando <command>chkmag</command>, eliminando la transizione
        per il nuovo comando.</para>

      <para>Un link simbolico pu&ograve; essere creato nel modo seguente:</para>

      <screen>&prompt.user; <userinput>ln -s chkit chkmag</userinput></screen>

      <para>Ora il lungo listato per questi due file &egrave; il
        seguente:</para>

      <screen>16 -rwxr-x--- 1 lindadb acs 15927 Apr 23 04:10 chkit
1  lrwxrwxrwx 1 lindadb acs 5     Apr 23 04:11 chkmag -> chkit</screen>

      <para>Notare che mentre i permessi di <command>chkmag</command> sono
        aperti a tutti, poich&egrave; &egrave; linkato a
        <command>chkit</command>, le caratteristiche dei permessi, del gruppo e
        del proprietario di <command>chkit</command> saranno rispettate quando
        <command>chkmag</command> viene invocato.</para>

      <para>Con un link simbolico, il link pu&ograve; esistere senza che il file
        o la directory a cui &egrave; collegato esista.</para>

      <para>Un <emphasis>hard link</emphasis> pu&ograve; solamente essere creato
        per un altro file sullo stesso file system, ma non per una directory
        (eccetto per il super-user).  Un hard link crea un nuovo elemento di
        directory puntante allo stesso inode del file originale.  Il file
        linkato deve esistere prima che l'hard link possa essere creato.
        Il file non sar&agrave; cancellato fino a quando tutti gli hard link
        saranno rimossi.  Per linkare i due file precedenti tramite un hard
        link:</para>

      <screen>&prompt.user; <userinput>ln chkit chkmag</userinput></screen>

      <para>Quindi un lungo listato mostra che il numero di
        <emphasis>inode</emphasis> (742) &egrave; lo stesso per entrambi i
        file:</para>

      <screen>&prompt.user; <userinput>ls -il chkit chkmag</userinput>
742 -rwxr-x--- 2 lindadb acs 15927 Apr 23 04:10 chkit
742 -rwxr-x--- 2 lindadb acs 15927 Apr 23 04:10 chkmag</screen>
    </sect2>

    <sect2 id="commands-work-files-sort">
      <title>sort - ordina il contenuto di un file</title>

      <para>Il comando &man.sort.1; viene usato per ordinare le linee
        di un file.  Si possono usare diverse opzioni per stabilire il modo di
        ordinamento e su quali campi ordinare il file.  Senza opzioni,
        &man.sort.1; confronta intere linee di un file e produce un ordinamento
        ASCII (prima i numeri, lettere maiuscole e quindi lettere
        minuscole).</para>

      <para><emphasis>Sintassi</emphasis></para>

      <para><command>sort [<replaceable>opzioni</replaceable>]
          [+<replaceable>pos1</replaceable> [-<replaceable>pos2</replaceable>]]
          <replaceable>file</replaceable></command></para>

      <para><emphasis>Opzioni generali</emphasis></para>

      <informaltable frame="none">
        <tgroup cols="2">
          <colspec colwidth="1.5in">

          <tbody>
            <row>
              <entry><option>-b</option></entry>

              <entry>ignora gli spazi bianchi iniziali (spazi e tab) quando si
                stabiliscono i carattere di inizio e di fine per la chiave di
                ordinamento</entry>
            </row>

            <row>
              <entry><option>-d</option></entry>

              <entry>ordinamento a dizionario, sono rilevanti solamente le
                lettere, le cifre, spazi e tab</entry>
            </row>

            <row>
              <entry><option>-f</option></entry>

              <entry>uguaglia lettere maiuscole e minuscole</entry>
            </row>

            <row>
              <entry><option>-k
                  <replaceable>chiave</replaceable></option></entry>

              <entry>ordinamento su chiavi specifiche (non disponibile su tutti
                i sistemi)</entry>
            </row>

            <row>
              <entry><option>-i</option></entry>

              <entry>ignora i caratteri non stampabili</entry>
            </row>

            <row>
              <entry><option>-n</option></entry>

              <entry>ordinamento numerico</entry>
            </row>

            <row>
              <entry><option>-o
                  <replaceable>outfile</replaceable></option></entry>

              <entry>file di output</entry>
            </row>

            <row>
              <entry><option>-r</option></entry>

              <entry>ribalta l'ordine</entry>
            </row>

            <row>
              <entry><option>-t <replaceable>car</replaceable></option></entry>

              <entry>usa <replaceable>car</replaceable> come il carattere di
                separatore di campo</entry>
            </row>

            <row>
              <entry><option>-u</option></entry>

              <entry>unico; trascura multiple copie di linee uguali
                (dopo l'ordinamento)</entry>
            </row>

            <row>
              <entry><option>+<replaceable>pos1</replaceable>
                  [-<replaceable>pos2</replaceable>]</option></entry>

              <entry>(vecchio stile) fornisce funzionalit&agrave; simili
                all'opzione <option>-k
                  <replaceable>chiave</replaceable></option>.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>Per gli elementi di <emphasis>posizione</emphasis>
        (<option>+/-</option>), <replaceable>pos1</replaceable> &egrave; il
        numero di parola di inizio, iniziando  da <emphasis>0</emphasis> e
        <replaceable>pos2</replaceable> &egrave; il numero di parola di fine.
        Quando -<replaceable>pos2</replaceable> non &egrave; specificato, il
        campo di ordinamento continua fino alla fine del file.  Sia
        <replaceable>pos1</replaceable> che <replaceable>pos2</replaceable>
        possono essere specificati nella forma
        <replaceable>w</replaceable>.<replaceable>c</replaceable>, dove
        <replaceable>w</replaceable> &egrave; il numero di parola e
        <replaceable>c</replaceable> &egrave; il carattere all'interno della
        parola.  Per <emphasis>c 0</emphasis> si specifica il delimitatore che
        precede il primo carattere e <emphasis>1</emphasis> &egrave; il primo
        carattere della parola.  Questi elementi possono essere seguiti da un
        tipo di modificatore, esempio <emphasis>n</emphasis> per numerico,
        <emphasis>b</emphasis> per saltare gli spazi bianchi ,ecc.</para>

      <para>Il campo <replaceable>chiave</replaceable> dell'opzione
        <option>-k</option> ha la seguente sintassi:</para>

      <para><replaceable>campo_inizio</replaceable>
        [<replaceable>tipo</replaceable>]
        [ ,<replaceable>campo_fine</replaceable>
        [<replaceable>tipo</replaceable>] ]</para>

      <para>dove:</para>

      <informaltable frame="none">
        <tgroup cols="2">
          <colspec colwidth="2.5in">

          <tbody>
            <row>
              <entry><replaceable>campo_inizio, campo_fine</replaceable></entry>

              <entry>definiscono le chiavi per restringere l'ordinamento su una
                porzione di linea</entry>
            </row>

            <row>
              <entry><replaceable>tipo</replaceable></entry>

              <entry>modifica l'ordinamento: validi modificatori sono dati dai
                singoli caratteri (bdfiMnr) derivanti dalle simili opzioni di
                ordinamento, ad esempio un tipo <emphasis>b</emphasis> equivale
                a <option>-b</option>, ma applicato solamente nello specifico
                campo di azione</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para><emphasis>Esempi:</emphasis></para>

      <para>Dato il file <filename>users</filename>:</para>

      <programlisting>jdoe    John Doe        4/15/96
lsmith  Laura Smith     3/12/96
pchen   Paul Chen       1/5/96
jhsu    Jake Hsu        4/17/96
sphilip Sue Phillip     4/2/96</programlisting>

      <para>ordinando con &man.sort.1; gli utenti si produce:</para>

      <programlisting>jdoe    John Doe        4/15/96
jhsu    Jake Hsu        4/17/96
lsmith  Laura Smith     3/12/96
pchen   Paul Chen       1/5/96
sphilip Sue Phillip     4/2/96</programlisting>

      <para>Se, tuttavia, si desidera un elenco in ordine di nome, si usa
        l'opzione per specificare su quale campo ordinare (i campi sono numerati
        partendo da 0):</para>

      <screen>&prompt.user; <userinput>sort +2 users</userinput>
pchen   Paul Chen       1/5/96
jdoe    John Doe        4/15/96
jhsu    Jake Hsu        4/17/96
sphilip Sue Phillip     4/2/96
lsmith  Laura Smith     3/12/96</screen>

      <para>Per ribaltare l'ordine:</para>

      <screen>&prompt.user; <userinput>sort -r users</userinput>
sphilip Sue Phillip     4/2/96
pchen   Paul Chen       1/5/96
lsmith  Laura Smith     3/12/96
jhsu    Jake Hsu        4/17/96
jdoe    John Doe        4/15/96</screen>

      <para>Un'opzione particolarmente utile di ordinamento &egrave; l'opzione
        <option>-u</option>, che elimina gli elementi duplicati nel file mentre
        si ordina il file.  Per esempio, il file
        <filename>todays.logins</filename>:</para>

      <programlisting>sphillip
jchen
jdoe
lkeres
jmarsch
ageorge
lkeres
proy
jchen</programlisting>

      <para>mostra una lista di ogni username che ha effettuato il login nel
        sistema in giornata.  Se si vuole conoscere quanti unici utenti abbiano
        effettuato il login nel sistema in giornata, usando &man.sort.1;
        con l'opzione <option>-u</option>, la lista conterr&agrave; ciascun
        utente una volta sola.  (Il comando pu&ograve; essere mandato in pipe a
        <command>wc -l</command> per ottenere direttamente il numero):</para>

      <screen>&prompt.user; <userinput>sort -u todays.logins</userinput>
ageorge
jchen
jdoe
jmarsch
lkeres
proy
sphillip</screen>
    </sect2>

    <sect2 id="commands-work-files-tee">
      <title>tee - copia l'output di un comando</title>

      <para>Il comando &man.tee.1; manda lo standard input nel file
        specificato e anche nello standard output.  Viene spesso usato in una
        pipe di comandi.</para>

      <para><emphasis>Sintassi</emphasis></para>

      <para><command>tee [<replaceable>opzioni</replaceable>]
          [<replaceable>file</replaceable>]</command></para>

      <para><emphasis>Opzioni generali</emphasis></para>

      <informaltable frame="none">
        <tgroup cols="2">
          <colspec colwidth="0.5in">

          <tbody>
            <row>
              <entry><option>-a</option></entry>

              <entry>appende l'output ai file</entry>
            </row>

            <row>
              <entry><option>-i</option></entry>

              <entry>ignora gli interrupt</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para><emphasis>Esempi:</emphasis></para>

      <para>In questo primo esempio l'output di &man.who.1; &egrave;
        visualizzato sullo schermo e memorizzato nel file
        <filename>users.file</filename>:</para>

      <screen>brigadier: condron [55]> <userinput>who | tee users.file</userinput>
condron ttyp0 Apr 22 14:10 (lcondron-pc.acs.)
frank   ttyp1 Apr 22 16:19 (nyssa)
condron ttyp9 Apr 22 15:52 (lcondron-mac.acs)</screen>

      <screen>brigadier: condron [56]> <userinput>cat users.file</userinput>
condron ttyp0 Apr 22 14:10 (lcondron-pc.acs.)
frank   ttyp1 Apr 22 16:19 (nyssa)
condron ttyp9 Apr 22 15:52 (lcondron-mac.acs)</screen>

      <para>Nel prossimo esempio l'output di &man.who.1; viene mandato nei file
        <filename>users.a</filename> e <filename>users.b</filename>.
        Viene anche mandato in pipe con il comando &man.wc.1;, che riporta il
        numero di linee.</para>

      <screen>brigadier: condron [57]> <userinput>who | tee users.a users.b | wc -l</userinput>
3</screen>

      <screen>brigadier: condron [58]> <userinput>cat users.a</userinput>
condron ttyp0 Apr 22 14:10 (lcondron-pc.acs.)
frank   ttyp1 Apr 22 16:19 (nyssa)
condron ttyp9 Apr 22 15:52 (lcondron-mac.acs)</screen>

      <para>Nell'esempio seguente un listato lungo di directory viene mandato
        nel file <filename>files.long</filename>.  Inoltre viene messo in pipe
        con il comando &man.grep.1; che riporta quali file sono stati modificati
        in Agosto.</para>

      <screen>brigadier: condron [60]> <userinput>ls -l | tee files.long |grep Aug</userinput>
1 drwxr-sr-x 2 condron 512  Aug 8 1995 News/
2 -rw-r--r-- 1 condron 1076 Aug 8 1995 magnus.cshrc
2 -rw-r--r-- 1 condron 1252 Aug 8 1995 magnus.login</screen>

      <screen>brigadier: condron [63]> <userinput>cat files.long</userinput>
total 34
2 -rw-r--r-- 1 condron 1253 Oct 10 1995 #.login#
1 drwx------ 2 condron 512  Oct 17 1995  Mail/
1 drwxr-sr-x 2 condron 512  Aug 8  1995  News/
5 -rw-r--r-- 1 condron 4299 Apr 21 00:18 editors.txt
2 -rw-r--r-- 1 condron 1076 Aug 8  1995  magnus.cshrc
2 -rw-r--r-- 1 condron 1252 Aug 8  1995  magnus.login
7 -rw-r--r-- 1 condron 6436 Apr 21 23:50 resources.txt
4 -rw-r--r-- 1 condron 3094 Apr 18 18:24 telnet.ftp
1 drwxr-sr-x 2 condron 512  Apr 21 23:56 uc/
1 -rw-r--r-- 1 condron 1002 Apr 22 00:14 uniq.tee.txt
1 -rw-r--r-- 1 condron 1001 Apr 20 15:05 uniq.tee.txt~
7 -rw-r--r-- 1 condron 6194 Apr 15 20:18 Unixgrep.txt</screen>
    </sect2>

    <sect2 id="commands-work-files-uniq">
      <title>uniq - rimuove linee duplicate</title>

      <para>Il comando &man.uniq.1; filtra le linee adiacenti duplicate in un
        file.</para>

      <para><emphasis>Sintassi</emphasis></para>

      <para><command>uniq [<replaceable>opzioni</replaceable>]
          [+|-<replaceable>n</replaceable>] <replaceable>file</replaceable>
          [<replaceable>nuovo.file</replaceable>]</command></para>

      <para><emphasis>Opzioni generali</emphasis></para>

      <informaltable frame="none">
        <tgroup cols="2">
          <colspec colwidth="1in">

          <tbody>
            <row>
              <entry><option>-d</option></entry>

              <entry>solo una copia delle linee ripetute</entry>
            </row>

            <row>
              <entry><option>-u</option></entry>

              <entry>seleziona solamente le linee non ripetute</entry>
            </row>

            <row>
              <entry><option>+<replaceable>n</replaceable></option></entry>

              <entry>ignora i primi <replaceable>n</replaceable>
                caratteri</entry>
            </row>

            <row>
              <entry><option>-s <replaceable>n</replaceable></option></entry>

              <entry>come sopra (solamente SVR4)</entry>
            </row>

            <row>
              <entry><option>-<replaceable>n</replaceable></option></entry>

              <entry>salta i primi <replaceable>n</replaceable> campi, spazi
                inclusi (spazi e tab)</entry>
            </row>

            <row>
              <entry><option>-f
                  <replaceable>campi</replaceable></option></entry>

              <entry>come sopra (solamente SVR4)</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para><emphasis>Esempi:</emphasis></para>

      <para>Si consideri il seguente file e l'esempio, dove
        &man.uniq.1; rimuove la quarta linea da <filename>file</filename>
        e mette il risultato nel file <filename>nuovo.file</filename>.</para>

      <screen>{Unix prompt 1} <userinput>cat file</userinput>
1 2 3 6
4 5 3 6
7 8 9 0
7 8 9 0</screen>

      <screen>{Unix prompt 2} <userinput>uniq file nuovo.file</userinput></screen>

      <screen>{Unix prompt 3} <userinput>cat nuovo.file</userinput>
1 2 3 6
4 5 3 6
7 8 9 0</screen>

      <para>Qui sotto, l'opzione <option>-<replaceable>n</replaceable></option>
        del comando &man.uniq.1; viene usata per saltare i primi 2 campi
        nel file e per filtrare le linee di uscita che sono duplicate dal terzo
        campo in avanti.</para>

      <screen>{Unix prompt 4} <userinput>uniq -2 file</userinput>
1 2 3 6
7 8 9 0</screen>
    </sect2>

    <sect2 id="commands-work-files-strings">
      <title>strings - cerca stringhe ASCII</title>

      <para>Per cercare stringhe ASCII, stampabili, in un file binario si usa il
        comando &man.strings.1;.  Questo comando ricerca sequenze di quattro o
        pi&ugrave; caratteri ASCII terminanti con un carattere newline o
        con un carattere null.  &man.strings.1; risulta utile per ricercare nomi
        di file e possibili messaggi di errore all'interno di un programma
        compilato, di cui non si ha il codice sorgente.</para>

      <para><emphasis>Sintassi</emphasis></para>

      <para><command>strings [<replaceable>opzioni</replaceable>]
          <replaceable>file</replaceable></command></para>

      <para><emphasis>Opzioni generali</emphasis></para>

      <informaltable frame="none">
        <tgroup cols="2">
          <colspec colwidth="1in">

          <tbody>
            <row>
              <entry><option>-n
                  <replaceable>numero</replaceable></option></entry>

              <entry>usa <replaceable>numero</replaceable> come la minima
                lunghezza della stringa, piuttosto di 4 (solamente SVR4)</entry>
            </row>

            <row>
              <entry><option>-</option><replaceable>numero</replaceable></entry>

              <entry>come sopra</entry>
            </row>

            <row>
              <entry><option>-t
                  <replaceable>formato</replaceable></option></entry>

              <entry>fa precedere alla stringa l'offset di byte dall'inizio del
                file; <replaceable>formato</replaceable> pu&ograve; essere:
                <emphasis>d</emphasis> = decimale, <emphasis>o</emphasis> =
                ottale <emphasis>x</emphasis> = esadecimale (solamente
                SVR4)</entry>
            </row>

            <row>
              <entry><option>-o</option></entry>

              <entry>fa precedere alla stringa l'offset di byte in decimale
                (solamente BSD)</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para><emphasis>Esempi:</emphasis></para>

      <screen>&prompt.user; <userinput>strings /bin/cut</userinput>
SUNW_OST_OSCMD
nessun delimitatore specificato
delimitatore non valido
b:c:d:f:ns
cut: -n pu&ograve; solo essere usato con -b
cut: -d pu&ograve; solo essere usato con -f
cut: -s pu&ograve; solo essere usato con -f
nessuna lista specificata
cut: %s non si riesce ad aprire
il range specificato non &egrave; valido
troppi range specificati
i range devono essere crescenti
carattere non valido nel range
Errore interno nel processare l'input
carattere multibyte non valido
incapace di allocare memoria sufficiente
incapace di allocare memoria sufficiente
cut:
uso: cut -b lista [-n] [filename ...]
     cut -c lista [filename ...]
     cut -f lista [-d delim] [-s] [filename]</screen>
    </sect2>

    <sect2 id="commands-work-files-file">
      <title>file - mostra il tipo di file</title>

      <para>Il comando &man.file.1; esamina il file specificato e cerca di
        determinare che tipo di file esso sia.  Questo viene fatto leggendo i
        primi byte del file e confrontandoli con la tabella
        <filename>/etc/magic</filename>.  Il comando &man.file.1;
        pu&ograve; determinare file di testo ASCII, file formattati tar, file
        compressi, ecc.</para>

      <para><emphasis>Sintassi</emphasis></para>

      <para><command>file [<replaceable>opzioni</replaceable>]
          [-m <replaceable>file_magico</replaceable>]
          [-f <replaceable>lista_file</replaceable>]
          <replaceable>file</replaceable></command></para>

      <para><emphasis>Opzioni generali</emphasis></para>

      <informaltable frame="none">
        <tgroup cols="2">
          <colspec colwidth="1.5in">

          <tbody>
            <row>
              <entry><option>-c</option></entry>

              <entry>verifica il file magico per eventuali errori nel
                formato</entry>
            </row>

            <row>
              <entry><option>-f
                  <replaceable>lista_file</replaceable></option></entry>

              <entry><filename><replaceable>lista_file</replaceable></filename>
                contiene la lista dei file da esaminare</entry>
            </row>

            <row>
              <entry><option>-h</option></entry>

              <entry>non segue i link simbolici (solamente SVR4)</entry>
            </row>

            <row>
              <entry><option>-L</option></entry>

              <entry>segue i link simbolici (solamente BSD)</entry>
            </row>

            <row>
              <entry><option>-m
                  <replaceable>file_magico</replaceable></option></entry>

              <entry>usa
                <filename><replaceable>file_magico</replaceable></filename>
                come il file magico al posto di
                <filename>/etc/magic</filename></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para><emphasis>Esempi:</emphasis></para>

      <para>Vengono elencati qui sotto gli output del comando
        <command>file <replaceable>filename</replaceable></command> per alcuni
        file significativi.</para>

      <screen>/etc/magic:             File di testo ascii
/usr/local/bin/gzip:    Eseguibile paginato SPARC Sun linkato dinamicamente
/usr/bin/cut:           Eseguibile MSB a 32 bit ELF per SPARC versione 1, linkato dinamicamente, stripped
source.tar:             Archivio tar USTAR
source.tar.Z:           Blocchi di dati compressi 16 bit</screen>
    </sect2>

    <sect2 id="commands-work-files-tr">
      <title>tr - traduce caratteri</title>

      <para>Il comando &man.tr.1; traduce caratteri da &man.stdin.4; a
        &man.stdout.4;.</para>

      <para><emphasis>Sintassi</emphasis></para>

      <para><command>tr [<replaceable>opzioni</replaceable>]
          <replaceable>stringa1</replaceable>
          [<replaceable>stringa2</replaceable>]</command></para>

      <para>Con nessuna opzione i caratteri di
        <replaceable>stringa1</replaceable> sono tradotti nei caratteri di
        <replaceable>stringa2</replaceable>, carattere per carattere,
        nell'ordine degli array di stringa.  Il primo carattere di
        <replaceable>stringa1</replaceable> viene tradotto nel primo carattere
        di <replaceable>stringa2</replaceable>, ecc.</para>

      <para>Un range di caratteri in una stringa viene specificato con un
        trattino tra il carattere superiore e quello inferiore del range, ad
        esempio per specificare tutte le lettere alfabetiche minuscole si usa
        <emphasis>[a-z]</emphasis>.</para>

      <para>Ripetizioni di caratteri in <replaceable>stringa2</replaceable>
        possono essere rappresentate con la notazione
        <emphasis>[<replaceable>x</replaceable>*<replaceable>n</replaceable>]</emphasis>,
        dove il carattere <replaceable>x</replaceable> viene ripetuto
        <replaceable>n</replaceable> volte.  Se <replaceable>n</replaceable>
        &egrave; <emphasis>0</emphasis> o assente, il carattere
        <replaceable>x</replaceable> viene assunto come valida corrispondenza
        richiesta in <replaceable>stringa1</replaceable>.</para>

      <para>I caratteri possono includere le notazioni
        <emphasis>\<replaceable>ottale</replaceable></emphasis> (BSD e SVR4) e
        <emphasis>\<replaceable>carattere</replaceable></emphasis> (solamente
        SVR4).  Qui <emphasis><replaceable>ottale</replaceable></emphasis> viene
        sostituito da una, due o tre cifre di interi ottali che codificano un
        carattere ASCII e
        <emphasis><replaceable>carattere</replaceable></emphasis> pu&ograve;
        essere uno di questi:</para>

      <informaltable frame="none">
        <tgroup cols="2">
          <colspec colwidth="0.5in">

          <tbody>
            <row>
              <entry><emphasis>b</emphasis></entry>

              <entry>back space</entry>
            </row>

            <row>
              <entry><emphasis>f</emphasis></entry>

              <entry>form feed</entry>
            </row>

            <row>
              <entry><emphasis>n</emphasis></entry>

              <entry>newline</entry>
            </row>

            <row>
              <entry><emphasis>r</emphasis></entry>

              <entry>return</entry>
            </row>

            <row>
              <entry><emphasis>t</emphasis></entry>

              <entry>tab</entry>
            </row>

            <row>
              <entry><emphasis>v</emphasis></entry>

              <entry>tab verticale</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>La versione SVR4 di &man.tr.1; permette l'operando
        :<replaceable>classe</replaceable>: nel campo stringa dove
        <replaceable>classe</replaceable> pu&ograve; assumere uno dei seguenti
        valori di classificazione carattere:</para>

      <informaltable frame="none">
        <tgroup cols="2">
          <colspec colwidth="1in">

          <tbody>
            <row>
              <entry><emphasis>alpha</emphasis></entry>

              <entry>caratteri alfabetici</entry>
            </row>

            <row>
              <entry><emphasis>lower</emphasis></entry>

              <entry>caratteri alfabetici minuscoli</entry>
            </row>

            <row>
              <entry><emphasis>upper</emphasis></entry>

              <entry>caratteri alfabetici maiuscoli</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para><emphasis>Opzioni generali</emphasis></para>

      <informaltable frame="none">
        <tgroup cols="2">
          <colspec colwidth="0.5in">

          <tbody>
            <row>
              <entry><option>-c</option></entry>

              <entry>completa il set di caratteri in
                <replaceable>stringa1</replaceable></entry>
            </row>

            <row>
              <entry><option>-d</option></entry>

              <entry>cancella i caratteri in
                <replaceable>stringa1</replaceable></entry>
            </row>

            <row>
              <entry><option>-s</option></entry>

              <entry>modifica una stringa di caratteri ripetuti in
                <replaceable>stringa1</replaceable> in caratteri singoli</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para><emphasis>Esempi:</emphasis></para>

      <para>L'esempio seguente usa come file di input una lista di libri di
        P. G. Wodehouse Jeeves & Wooster.</para>

      <programlisting>The Inimitable Jeeves [1923]    The Mating Season [1949]
Carry On, Jeeves [1925]         Ring for Jeeves [1953]
Very Good, Jeeves [1930]        Jeeves and the Feudal Spirit [1954]
Thank You, Jeeves [1934]        Jeeves in the Offing [1960]
Right Ho, Jeeves [1934]         Stiff Upper Lip, Jeeves [1963]
The Code of the Woosters [1938] Much Obliged, Jeeves [1971]
Joy in the Morning [1946]       Aunts Aren't Gentlemen [1974]</programlisting>

      <para>Per tradurre tutte le lettere alfabetiche minuscole in maiuscole si
        possono usare:</para>

      <para><command>tr '[a-z]' '[A-Z]'</command></para>

      <para>oppure</para>

      <para><command>tr '[:lower:]' '[:upper:]'</command></para>

      <para>Affinch&egrave; &man.tr.1; legga da &man.stdin.4; si usa &man.cat.1;
        in pipe con &man.tr.1;, cos&igrave;:</para>

      <screen>&prompt.user; <userinput>cat wodehouse | tr '[a-z]' '[A-Z]'</userinput>
THE INIMITABLE JEEVES [1923]    THE MATING SEASON [1949]
CARRY ON, JEEVES [1925]         RING FOR JEEVES [1953]
VERY GOOD, JEEVES [1930]        JEEVES AND THE FEUDAL SPIRIT [1954]
THANK YOU, JEEVES [1934]        JEEVES IN THE OFFING [1960]
RIGHT HO, JEEVES [1934]         STIFF UPPER LIP, JEEVES [1963]
THE CODE OF THE WOOSTERS [1938] MUCH OBLIGED, JEEVES [1971]
JOY IN THE MORNING [1946]       AUNTS AREN'T GENTLEMEN [1974]</screen>

      <para>Ora si cancellano tutti i numeri con:</para>

      <screen>&prompt.user; <userinput>cat wodehouse | tr -d '[0-9]'</userinput>
The Inimitable Jeeves []        The Mating Season []
Carry On, Jeeves []             Ring for Jeeves []
Very Good, Jeeves []            Jeeves and the Feudal Spirit []
Thank You, Jeeves []            Jeeves in the Offing []
Right Ho, Jeeves []             Stiff Upper Lip, Jeeves []
The Code of the Woosters []     Much Obliged, Jeeves []
Joy in the Morning []           Aunts Aren't Gentlemen []</screen>

      <para>Per trattenere tutte le occorrenze multiple dei caratteri e, r
        e f:</para>

      <screen>&prompt.user; <userinput>cat wodehouse | tr -s 'erf'</userinput>
The Inimitable Jeves [1923]     The Mating Season [1949]
Cary On, Jeves [1925]           Ring for Jeves [1953]
Very Good, Jeves [1930]         Jeves and the Feudal Spirit [1954]
Thank You, Jeves [1934]         Jeves in the Ofing [1960]
Right Ho, Jeves [1934]          Stif Upper Lip, Jeves [1963]
The Code of the Woosters [1938] Much Obliged, Jeves [1971]
Joy in the Morning [1946]       Aunts Aren't Gentlemen [1974]</screen>
    </sect2>

    <sect2 id="commands-work-files-find">
      <title>find - cerca file</title>

      <para>Il comando &man.find.1; pu&ograve; cercare file in modo
        ricorsivo nell'albero di directory indicato, confrontando il tipo di
        file o lo schema specificato.  &man.find.1; pu&ograve; quindi elencare i
        file o eseguire arbitrari comandi in base ai risultati.</para>

      <para><emphasis>Sintassi</emphasis></para>

      <para><command>find <replaceable>directory</replaceable>
          [<replaceable>opzioni di ricerca</replaceable>]
          [<replaceable>azioni</replaceable>]</command></para>

      <para><emphasis>Opzioni generali</emphasis></para>

      <para>Per l'opzione del tempo di ricerca, la notazione in giorni,
        <emphasis>n</emphasis> &egrave;:</para>

      <informaltable frame="none">
        <tgroup cols="2">
          <colspec colwidth="0.5in">

          <tbody>
            <row>
              <entry><option>+<replaceable>n</replaceable></option></entry>

              <entry>pi&ugrave; di <replaceable>n</replaceable> giorni</entry>
            </row>

            <row>
              <entry><replaceable>n</replaceable></entry>

              <entry>esattamente <replaceable>n</replaceable> giorni</entry>
            </row>

            <row>
              <entry><option>-<replaceable>n</replaceable></option></entry>

              <entry>meno di <replaceable>n</replaceable> giorni</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>Alcune caratteristiche dei file che &man.find.1; pu&ograve;
        ricercare sono:</para>

      <para>la <emphasis>data</emphasis> dell'ultimo accesso o dell'ultima
        modifica al file:</para>

      <informaltable frame="none">
        <tgroup cols="2">
          <colspec colwidth="1.5in">

          <tbody>
            <row>
              <entry align="center"><option>-atime
                <replaceable>n</replaceable></option></entry>

              <entry>data di accesso, vero se l'accesso &egrave; di
                <replaceable>n</replaceable> giorni f&agrave;</entry>
            </row>

            <row>
              <entry align="center"><option>-ctime
                <replaceable>n</replaceable></option></entry>

              <entry>data di cambiamento, vero se lo stato del file &egrave;
                stato modificato <replaceable>n</replaceable> giorni
                f&agrave;</entry>
            </row>

            <row>
              <entry align="center"><option>-mtime
                <replaceable>n</replaceable></option></entry>

              <entry>data di modifica, vero se i dati del file sono stati
                modificati <replaceable>n</replaceable> giorni f&agrave;</entry>
            </row>

            <row>
              <entry><option>-newer
                  <replaceable>filename</replaceable></option></entry>

              <entry>vero se pi&ugrave; recente del file specificato</entry>
            </row>

            <row>
              <entry><option>-type
                  <replaceable>tipo</replaceable></option></entry>

              <entry><emphasis>tipo</emphasis> di <emphasis>file</emphasis>,
                dove <replaceable>tipo</replaceable> pu&ograve; essere:</entry>
            </row>

            <row>
              <entry align="center"><emphasis>b</emphasis></entry>

              <entry>file speciale a blocchi</entry>
            </row>

            <row>
              <entry align="center"><emphasis>c</emphasis></entry>

              <entry>file speciale a caratteri</entry>
            </row>

            <row>
              <entry align="center"><emphasis>d</emphasis></entry>

              <entry>directory</entry>
            </row>

            <row>
              <entry align="center"><emphasis>l</emphasis></entry>

              <entry>link simbolico</entry>
            </row>

            <row>
              <entry align="center"><emphasis>p</emphasis></entry>

              <entry>file pipe (fifo)</entry>
            </row>

            <row>
              <entry align="center"><emphasis>f</emphasis></entry>

              <entry>file regolare</entry>
            </row>

            <row>
              <entry><option>-fstype
                  <replaceable>tipo</replaceable></option></entry>

              <entry><emphasis>tipo</emphasis> di <emphasis>file
                system</emphasis>, dove <replaceable>tipo</replaceable>
                pu&ograve; essere un valido tipo di file system, esempio
                <emphasis>ufs</emphasis> (Unix File System) e
                <emphasis>nfs</emphasis> (Network File System)</entry>
            </row>

            <row>
              <entry><option>-user
                  <replaceable>username</replaceable></option></entry>

              <entry>vero se il file appartiene all'utente specificato</entry>
            </row>

            <row>
              <entry><option>-group
                  <replaceable>groupname</replaceable></option></entry>

              <entry>vero se il file appartiene al gruppo specificato</entry>
            </row>

            <row>
              <entry><option>-perm
                  [-]<replaceable>modi</replaceable></option></entry>

              <entry>permessi del file, dove <replaceable>modi</replaceable>
                &egrave; la modalit&agrave; ottale usata dal comando
                &man.chmod.1;.  Quando <replaceable>modi</replaceable> &egrave;
                preceduto da un segno meno, solamente i bit che sono specificati
                vengono confrontati.</entry>
            </row>

            <row>
              <entry><option>-exec
                  <replaceable>comando</replaceable></option></entry>

              <entry>esegue il comando specificato.  La fine del comando viene
                indicata con un escape e punto e virgola (\;).  L'argomento del
                comando, {}, sostituisce il path name corrente.</entry>
            </row>

            <row>
              <entry><option>-name
                  <replaceable>filename</replaceable></option></entry>

              <entry>vero se il nome del file &egrave; quello specificato.
                Confronti con schemi wild card sono permessi se il
                meta-carattere viene messo in escape per la shell con un
                backslash (\)</entry>
            </row>

            <row>
              <entry><option>-ls</option></entry>

              <entry>sempre vero.  Stampa una lista lunga del path name
                corrente</entry>
            </row>

            <row>
              <entry><option>-print</option></entry>

              <entry>stampa i path name trovati (default per SVR4, non per
                BSD)</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>Sono permesse espressioni complesse.  Le espressioni devono essere
        raggruppate tra parentesi (mettendo in escape le parentesi con un
        backslash per impedire alla shell di interpretarle).  Il simbolo di
        esclamazione (!) pu&ograve; essere usato per <emphasis>negare</emphasis>
        un'espressione.  Gli operatori: <option>-a</option>
        (<emphasis>and</emphasis>) e <option>-o</option>
        (<emphasis>or</emphasis>) vengono usati per raggruppare
        espressioni.</para>

      <para><emphasis>Esempi:</emphasis></para>

      <para>&man.find.1; pu&ograve; ricercare in modo ricorsivo attraverso
        sotto-directory, ma per lo scopo di questi esempi saranno usati i
        seguenti file:</para>

      <screen>14 -rw-r--r-- 1 frank staff  6682 Feb  5 10:04 library
 6 -r--r----- 1 frank staff  3034 Mar 16  1995 netfile
34 -rw-r--r-- 1 frank staff 17351 Feb  5 10:04 standard
 2 -rwxr-xr-x 1 frank staff   386 Apr 26 09:51 tr25*</screen>

      <para>Per trovare tutti i file pi&ugrave; recenti del file
        <filename>library</filename>:</para>

      <screen>&prompt.user; <userinput>find . -newer library -print</userinput>
./tr25
./standard</screen>

      <para>Per trovare tutti i file con i permessi di lettura o esecuzione per
        l'utenza altri e quindi modificare gli stessi in modo da
        disabilitarli:</para>

      <screen>&prompt.user; <userinput>find . \( -perm -004 -o -perm -001 \) -exec chmod o-rx {} \; -exec ls -al {} \;</userinput>
-rw-r----- 1 frank staff  6682 Feb  5 10:04 ./library
-rwxr-x--- 1 frank staff   386 Apr 26 09:51 ./tr25
-rw-r----- 1 frank staff 17351 Feb  5 10:04 ./standard</screen>

      <para>Nell'esempio precedente le parentesi e i punti e virgola sono messi
        in escape con un backslash per impedire alla shell di interpretarli.
        Le parentesi graffe sono automaticamente rimpiazzate dai risultati della
        precedente ricerca e il punto e virgola chiude il comando.</para>

      <para>Si possono ricercare alcuni nomi di file contenenti la stringa
        <quote>ar</quote> con:</para>

      <screen>&prompt.user; <userinput>find . -name \*ar\* -ls</userinput>
326584  7 -rw-r----- 1 frank staff  6682 Feb 5 10:04 ./library
326585 17 -rw-r----- 1 frank staff 17351 Feb 5 10:04 ./standard</screen>

      <para>dove l'opzione <option>-ls</option> mostra un listato lungo, numeri
        di inode inclusi.</para>
    </sect2>
  </sect1>

  <sect1 id="commands-file-arch-comp-conv">
    <title>Archiviazione, compressione e conversione di file</title>

    <table frame="all" id="commands-table-file-arch-comp-conv">
      <title>Comandi di archiviazione, compressione e conversione di
        file</title>

      <tgroup cols="2">
        <colspec colwidth="4in">

        <thead>
          <row>
            <entry align="center">Comando/Sintassi</entry>

            <entry align="center">Cosa fa</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><command>compress/uncompress/zcat
                [<replaceable>opzioni</replaceable>]
                <replaceable>file</replaceable>[.Z]</command></entry>

            <entry>comprime o decomprime un file.  I file compressi sono
              memorizzati con l'estensione <filename>.Z</filename></entry>
          </row>

          <row>
            <entry><command>dd [if=<replaceable>infile</replaceable>]
                [of=<replaceable>outfile</replaceable>]
                [operando=<replaceable>valore</replaceable>]</command></entry>

            <entry>copia un file, converte tra ASCII e EBCDIC o scambia
              l'ordine dei byte, come specificato</entry>
          </row>

          <row>
            <entry><command>gzip/gunzip/zcat
                [<replaceable>opzioni</replaceable>]
                <replaceable>file</replaceable>[.gz]</command></entry>

            <entry>comprime o decomprime un file.  I file compressi sono
              memorizzati con l'estensione <filename>.gz</filename></entry>
          </row>

          <row>
            <entry><command>od [<replaceable>opzioni</replaceable>]
                <replaceable>file</replaceable></command></entry>

            <entry>effettua un dump di un file binario in ottale, in ASCII, in
              esadecimale, in decimale o in modo carattere.</entry>
          </row>

          <row>
            <entry><command>tar [<replaceable>opzioni</replaceable>]
                [<replaceable>file</replaceable>]</command></entry>

            <entry>archivio a nastro - riferirsi alle pagine man per i dettagli
              su come creare, visualizzare ed estrarre un archivio di file.  I
              file tar possono essere memorizzati su nastro o su disco.</entry>
          </row>

          <row>
            <entry><command>uudecode
                [<replaceable>file</replaceable>]</command></entry>

            <entry>decodifica un file uuencoded, ricreando il file
              originale</entry>
          </row>

          <row>
            <entry><command>uuencode [<replaceable>file</replaceable>]
                <replaceable>nuovo_nome</replaceable></command></entry>

            <entry>codifica un file binario in ASCII 7-bit; utile quando lo si
              invia tramite email, per poi essere decodificato come
              <filename><replaceable>nuovo_nome</replaceable></filename> alla
              destinazione</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <sect2 id="commands-file-arch-comp-conv-compress-uncompress">
      <title>Compressione di file</title>

      <para>Il comando &man.compress.1; viene usato per ridurre lo spazio di
        disco utilizzato da un file.  Quando un file &egrave; stato compresso
        usando il comando &man.compress.1;, il suffisso <filename>.Z</filename>
        viene appeso al nome del file.  I permessi, la data di accesso e di
        modifica del file originale vengono preservati.  Il comando
        &man.uncompress.1; restituisce il file originale compresso con
        &man.compress.1;.</para>

      <para><emphasis>Sintassi</emphasis></para>

      <para><command>compress [<replaceable>opzioni</replaceable>]
          [<replaceable>file</replaceable>]</command></para>

      <para><command>uncompress [<replaceable>opzioni</replaceable>]
          [<replaceable>file</replaceable>.Z]</command></para>

      <para><command>zcat [<replaceable>file</replaceable>.Z]</command></para>

      <para><emphasis>Opzioni generali</emphasis></para>

      <informaltable frame="none">
        <tgroup cols="2">
          <colspec colwidth="0.5in">

          <tbody>
            <row>
              <entry><option>-c</option></entry>

              <entry>scrive su standard output e non crea o modifica alcun
                file</entry>
            </row>

            <row>
              <entry><option>-f</option></entry>

              <entry>forza la compressione del file, anche se questa non riduce
                la dimensione del file o se il file destinazione
                (<filename><replaceable>file</replaceable>.Z</filename>) esiste
                gi&agrave;.</entry>
            </row>

            <row>
              <entry><option>-v</option></entry>

              <entry>verbose.  Riporta la percentuale di riduzione del
                file.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>&man.zcat.1; scrive su standard output.  Equivale a
        <command>uncompress -c</command>.</para>

      <para><emphasis>Esempi:</emphasis></para>

      <para>Dati i file:</para>

      <screen>96 -rw-r--r-- 1 lindadb acs 45452 Apr 24 09:13 logins.beauty
184 -rw-r--r-- 1 lindadb acs 90957 Apr 24 09:13 logins.bottom
152 -rw-r--r-- 1 lindadb acs 75218 Apr 24 09:13 logins.photon
168 -rw-r--r-- 1 lindadb acs 85970 Apr 24 09:13 logins.top</screen>

      <para>Questi possono essere compressi con:</para>

      <screen>&prompt.user; <userinput>compress logins.*</userinput></screen>

      <para>che crea i file:</para>

      <screen>24 -rw-r--r-- 1 lindadb acs  8486 Apr 24 09:13 logins.beauty.Z
40 -rw-r--r-- 1 lindadb acs 16407 Apr 24 09:13 logins.bottom.Z
24 -rw-r--r-- 1 lindadb acs 10909 Apr 24 09:13 logins.photon.Z
32 -rw-r--r-- 1 lindadb acs 16049 Apr 24 09:13 logins.top.Z</screen>

      <para>I file originali sono persi.</para>

      <para>Per visualizzare un file compresso, viene usato il comando
        &man.zcat.1;:</para>

      <screen>&prompt.user; <userinput>zcat logins.beauty.Z | head</userinput>
beauty:01/22/94:#total logins,4338:#different UIDs,2290
beauty:01/23/94:#total logins,1864:#different UIDs,1074
beauty:01/24/94:#total logins,2317:#different UIDs,1242
beauty:01/25/94:#total logins,3673:#different UIDs,2215
beauty:01/26/94:#total logins,3532:#different UIDs,2216
beauty:01/27/94:#total logins,3096:#different UIDs,1984
beauty:01/28/94:#total logins,3724:#different UIDs,2212
beauty:01/29/94:#total logins,3460:#different UIDs,2161
beauty:01/30/94:#total logins,1408:#different UIDs,922
beauty:01/31/94:#total logins,2175:#different UIDs,1194</screen>

      <para>Una visualizzazione del file utilizzando un altro comando al posto
        di &man.zcat.1; pu&ograve; produrre un difficile risultato
        binario.</para>

      <para>Il comando &man.uncompress.1; viene usato per far ritornare il file
        compresso nel suo formato originale:</para>

      <screen>&prompt.user; <userinput>uncompress logins.*.Z ; ls -als logins.*</userinput>
 96 -rw-r--r-- 1 lindadb acs 45452 Apr 24 09:13 logins.beauty
184 -rw-r--r-- 1 lindadb acs 90957 Apr 24 09:13 logins.bottom
152 -rw-r--r-- 1 lindadb acs 75218 Apr 24 09:13 logins.photon
168 -rw-r--r-- 1 lindadb acs 85970 Apr 24 09:13 logins.top</screen>

      <para>In aggiunta alle utility standard di Unix &man.compress.1;,
        &man.uncompress.1;, &man.zcat.1; ci sono un set di utility
        <emphasis>GNU</emphasis> liberamente disponibili.  Queste creano
        persino un miglior lavoro di compressione utilizzando un algoritmo
        pi&ugrave; efficiente.  I programmi GNU che forniscono
        funzionalit&agrave; simili ai precedenti sono spesso installati
        rispettivamente come &man.gzip.1;, &man.gunzip.1; e &man.zcat.1;.
        I nomi dei file compressi con &man.gzip.1; hanno l'estensione
        <filename>.z</filename> o <filename>.gz</filename>.  Il software GNU
        pu&ograve; essere ottenuto via ftp anonimo: <ulink
          url="ftp://ftp.gnu.org/pub/gnu"><hostid
          role="fqdn">ftp://ftp.gnu.org/pub/gnu</hostid></ulink>.</para>
    </sect2>

    <sect2 id="commands-file-arch-comp-conv-tar">
      <title>tar - archivio di file</title>

      <para>Il comando &man.tar.1; raggruppa file in un dispositivo o in un file
        per scopi di archiviazione.  Il comando &man.tar.1; non comprime i file,
        rende solamente pi&ugrave; maneggevole una grande quantit&agrave; di
        file.</para>

      <para><emphasis>Sintassi</emphasis></para>

      <para><command>tar [<replaceable>opzioni</replaceable>]
          [<replaceable>directory file</replaceable>]</command></para>

      <para><emphasis>Opzioni generali</emphasis></para>

      <informaltable frame="none">
        <tgroup cols="2">
          <colspec colwidth="0.5in">

          <tbody>
            <row>
              <entry><option>c</option></entry>

              <entry>crea un archivio (inizia scrivendo all'inizio del
                file)</entry>
            </row>

            <row>
              <entry><option>t</option></entry>

              <entry>visualizza il contenuto</entry>
            </row>

            <row>
              <entry><option>x</option></entry>

              <entry>estrae da un archivio</entry>
            </row>

            <row>
              <entry><option>v</option></entry>

              <entry>verbose</entry>
            </row>

            <row>
              <entry><option>f</option></entry>

              <entry>nome del file di archivio</entry>
            </row>

            <row>
              <entry><option>b</option></entry>

              <entry>dimensione del blocco di archivio</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>&man.tar.1;, in generale, accetta le sue opzioni sia facendole
        precedere da un trattino (-) sia senza trattino.  Il file di archivio
        pu&ograve; essere un file su disco, un dispositivo a nastro o
        standard input/output.  L'ultimo modo viene rappresentato tramite un
        trattino.</para>

      <para><emphasis>Esempi:</emphasis></para>

      <para>Dati i file di dimensioni seguenti:</para>

      <screen>45 logs.beauty
89 logs.bottom
74 logs.photon
84 logs.top</screen>

      <para>&man.tar.1; pu&ograve; combinare questi in un solo file,
        <filename>logfile.tar</filename>:</para>

      <screen>&prompt.user; <userinput>tar -cf logfile.tar logs.* ; ls -s logfile.tar</userinput>
304 logfile.tar</screen>

      <para>In Internet, molti siti di archivio FTP anonimi memorizzano i loro
        pacchetti in formati tar compressi, quindi i file finiscono in
        <filename>.tar.Z</filename> o <filename>.tar.gz</filename>.  Per
        estrarre i file da uno di questi file archivio si pu&ograve; prima
        decomprimerlo, o usare l'appropriato comando &man.zcat.1; e mandare in
        pipe il risultato a &man.tar.1;, esempio:</para>

      <screen>&prompt.user; <userinput>zcat <replaceable>archive</replaceable>.tar.Z | tar -xvf -</userinput></screen>

      <para>dove il trattino alla fine del comando &man.tar.1; indica che il
        file &egrave; preso da &man.stdin.4;.</para>
    </sect2>

    <sect2 id="commands-file-arch-comp-conv-uuencode-uudecode">
      <title>uuencode/uudecode - codifica/decodifica un file</title>

      <para>Per codificare un file binario in ASCII 7-bit si usa il comando
        &man.uuencode.1;.  Per decodificare il file ASCII 7-bit in binario
        si usa il comando &man.uudecode.1;.  Il suffisso
        <quote><emphasis>uu</emphasis></quote> nei nomi deriva dal fatto che
        questi comandi fanno parte del set di comandi Unix-to-Unix CoPy (UUCP).
        I comandi &man.uuencode.1; e &man.uudecode.1; sono generalmente usati
        quando si mandano file binari via e-mail.  Con l'e-mail non c'&egrave;
        garanzia che file binari 8-bit siano trasferiti correttamente.  Quindi
        per garantire una corretta consegna si pu&ograve; codificare il file
        binario, sia direttamente su linea di comando, includendo il file
        codificato, sia indirettamente, lasciando al proprio programma di posta
        MIME questo lavoro.  In modo simile, l'utente decodifica il file
        ricevuto.</para>

      <para><emphasis>Sintassi</emphasis></para>

      <para><command>uuencode [<replaceable>file_sorgente</replaceable>]
          <replaceable>pathname_per_uudecode</replaceable>
          [> <replaceable>nuovo_file</replaceable>]</command></para>

      <para><command>uudecode [-p]
          <replaceable>file_uuencode</replaceable></command></para>

      <para><emphasis>Opzioni generali</emphasis></para>

      <informaltable frame="none">
        <tgroup cols="2">
          <colspec colwidth="0.5in">

          <tbody>
            <row>
              <entry><option>-p</option></entry>

              <entry>manda l'output su standard output piuttosto che nel file di
                default</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para><emphasis>Esempi:</emphasis></para>

      <para>La prima linea di un file codificato con &man.uuencode.1; include i
        <emphasis>permessi</emphasis> e il <emphasis>nome</emphasis> del file
        originale che &man.uudecode.1; utilizzer&agrave; quando
        decodificher&agrave; il file codificato.  Il file inizia e finisce
        rispettivamente con le parole chiavi <emphasis>begin</emphasis> e
        <emphasis>end</emphasis>, esempio:</para>

      <programlisting>begin 555 binary_filename

M?T5,1@$" 0 " ( ! %"W #0 5"< T "
M!0 H !4 % 8 T $ - "@ H 4 P
M -0 !$ ! ! ! %"
M%P !0A< % $ $ 4(8 -"& W& W% < 0
M @ !0B T(@ )@ !P O=7-R+VQI8B]L9"YS
M;RXQ ?< 'Y VP "O !VP )8 &6 !G0
M %[ U0 %G !3 ;< #Q %Q !
MEP :P !_ '@ !PP (P
M N0 =H _0 $D Y < #F /L
M01 $' $ & ! P #0A@ 4(8
M" ! 0 !E !@ , T(@ %"( )@ $
M 0 ( ;@ $ ' -"N !0K@ /H
M $ # ', ! P #1J 4:@ #8 !
M !Y 0 , TH %* !=X 0
M@ @ # -/X !3^ "E, $ (4 !
M 4_> )0 0 ". P
; %0 P )@ $

end</programlisting>
    </sect2>

    <sect2 id="commands-file-arch-comp-conv-dd">
      <title>dd - copia di blocchi e conversione</title>

      <para>Il comando &man.dd.1; permette di copiare dati da dispositivi
        grezzi, come dischi o nastri, specificando la dimensione dei blocchi
        di input e di output.  &man.dd.1; era originariamente conosciuto
        come il programma di copia disco-a-disco.  Inoltre con &man.dd.1;
        si possono convertire file in differenti formati, per esempio da EBCDIC
        a ASCII, cambiare l'ordine dei byte, ecc.</para>

      <para><emphasis>Sintassi</emphasis></para>

      <para><command>dd [if=<replaceable>dispositivo_input</replaceable>]
          [of=<replaceable>dispositivo_output</replaceable>]
          [operando=<replaceable>valore</replaceable>]</command></para>

      <para><emphasis>Opzioni generali</emphasis></para>

      <informaltable frame="none">
        <tgroup cols="2">
          <colspec colwidth="2in">

          <tbody>
            <row>
              <entry><option>if=<replaceable>dispositivo_input</replaceable></option></entry>

              <entry>il dispositivo o file di input</entry>
            </row>

            <row>
              <entry><option>of=<replaceable>dispositivo_output</replaceable></option></entry>

              <entry>il dispositivo o file di output</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>Se i dispositivi di input o di output non sono specificati, si
        assume come default rispettivamente lo standard input e lo standard
        output.</para>

      <para>Gli operandi possono essere:</para>

      <informaltable frame="none">
        <tgroup cols="2">
          <colspec colwidth="2in">

          <tbody>
            <row>
              <entry><option>ibs=<replaceable>n</replaceable></option></entry>

              <entry>dimensione del blocco di input (blocchi da 512 byte di
                default)</entry>
            </row>

            <row>
              <entry><option>obs=<replaceable>n</replaceable></option></entry>

              <entry>dimensione del blocco di output (blocchi da 512 byte di
                default)</entry>
            </row>

            <row>
              <entry><option>bs=<replaceable>n</replaceable></option></entry>

              <entry>setta entrambe le dimensioni dei blocchi di input e di
                output</entry>
            </row>

            <row>
              <entry><option>files=<replaceable>n</replaceable></option></entry>

              <entry>copia <replaceable>n</replaceable> file di input</entry>
            </row>

            <row>
              <entry><option>skip=<replaceable>n</replaceable></option></entry>

              <entry>salta <replaceable>n</replaceable> blocchi di input prima
                di iniziare la copia</entry>
            </row>

            <row>
              <entry><option>count=<replaceable>n</replaceable></option></entry>

              <entry>copia solamente <replaceable>n</replaceable> blocchi di
                input</entry>
            </row>

            <row>
              <entry><option>conv=<replaceable>valore</replaceable>[,<replaceable>valore</replaceable>]</option></entry>

              <entry>dove <replaceable>valore</replaceable> pu&ograve;
                essere:</entry>
            </row>

            <row>
              <entry align="center"><option>ascii</option></entry>

              <entry>converte da EBCDIC a ASCII</entry>
            </row>

            <row>
              <entry align="center"><option>ebcdic</option></entry>

              <entry>converte da ASCII a EBCDIC</entry>
            </row>

            <row>
              <entry align="center"><option>lcase</option></entry>

              <entry>converte i caratteri maiuscoli in minuscoli</entry>
            </row>

            <row>
              <entry align="center"><option>ucase</option></entry>

              <entry>converte i caratteri minuscoli in maiuscoli</entry>
            </row>

            <row>
              <entry align="center"><option>swab</option></entry>

              <entry>scambia ogni coppia di byte dei dati di input</entry>
            </row>

            <row>
              <entry align="center"><option>noerror</option></entry>

              <entry>non ferma il processo su un errore in input</entry>
            </row>

            <row>
              <entry align="center"><option>sync</option></entry>

              <entry>riempie ogni blocco di input alla dimensione di
                <option>ibs</option>, apporrendo byte nulli se
                necessario</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>La dimensione dei blocchi viene specificata in byte e pu&ograve;
        finire in <emphasis>k</emphasis>, <emphasis>b</emphasis> o
        <emphasis>w</emphasis> per indicare rispettivamente 1024 (kilo), 512
        (blocco) o 2 (parola) byte.</para>

      <para><emphasis>Esempi:</emphasis></para>

      <para>Per copiare un file da un dispositivo a nastro in un altro:</para>

      <screen>&prompt.user; <userinput>dd if=/dev/rmt/0 of=/dev/rmt/1</userinput>
20+0 records in
20+0 records out</screen>

      <para>Per copiare file posti in un dispositivo a nastro, scritti su una
        macchina big endian con una dimensione di 20 blocchi, in file su
        una machina little endian che ha un nastro inserito nel suo dispositivo,
        si ha la necessit&agrave; di scambiare le coppie di byte, in questo
        modo:</para>

      <screen>&prompt.user; <userinput>dd if=/dev/rmt/0 of=new_file ibs=20b conv=swab</userinput>
1072+0 records in
21440+0 records out</screen>

      <para>A completamento dell'operazione, &man.dd.1; riporta il numero dei
        blocchi totali e dei blocchi parziali per entrambi i file di
        input e di output.</para>
    </sect2>

    <sect2 id="commands-file-arch-comp-conv-od">
      <title>od - dump ottale di un file</title>

      <para>Il comando &man.od.1; effettua un dump di un file su &man.stdout.4;
        in differenti formati, incluso l'ottale, il decimale, virgola mobile,
        esadecimale e formato carattere.</para>

      <para><emphasis>Sintassi</emphasis></para>

      <para><command>od [<replaceable>opzioni</replaceable>]
          <replaceable>file</replaceable></command></para>

      <para><emphasis>Opzioni generali</emphasis></para>

      <informaltable frame="none">
        <tgroup cols="2">
          <colspec colwidth="1in">

          <tbody>
            <row>
              <entry><option>-b</option></entry>

              <entry>dump ottale</entry>
            </row>

            <row>
              <entry><option>-d</option>|<option>-D</option></entry>

              <entry>dump decimale (-d) o decimale esteso (-D)</entry>
            </row>

            <row>
              <entry><option>-s</option>|<option>-S</option></entry>

              <entry>dump decimale marcato (-s) o decimale marcato esteso
                (-S)</entry>
            </row>

            <row>
              <entry><option>-f</option>|<option>-F</option></entry>

              <entry>dump in virgola mobile (-f) o virgola mobile estesa
                (double) (-F)</entry>
            </row>

            <row>
              <entry><option>-x</option>|<option>-X</option></entry>

              <entry>dump esadecimale (-x) o esadecimale esteso (-X)</entry>
            </row>

            <row>
              <entry><option>-c</option>|<option>-C</option></entry>

              <entry>dump in formato carattere (byte singolo) o carattere esteso
                (carattere singolo o multi-byte, a seconda dai settaggi
                locali)</entry>
            </row>

            <row>
              <entry><option>-v</option></entry>

              <entry>modalit&agrave; verbose</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para><emphasis>Esempi:</emphasis></para>

      <para>Per dare un'occhiata all'attuale contenuto del seguente file, un
        elenco di romanzi di Wodehouse Lord Emsworth:</para>

      <programlisting>Something Fresh [1915]                  Uncle Dynamite [1948]
Leave it to Psmith [1923]               Pigs Have Wings [1952]
Summer Lightning [1929]                 Cocktail Time [1958]
Heavy Weather [1933]                    Service with a Smile [1961]
Blandings Castle and Elsewhere [1935]   Galahad at Blandings [1965]
Uncle Fred in the Springtime [1939]     A Pelican at Blandings [1969]
Full Moon [1947]                        Sunset at Blandings [1977]</programlisting>

      <para>si pu&ograve; usare:</para>

      <screen>&prompt.user; <userinput>od -c wodehouse</userinput>
0000000 S o m e t h i n g   F r e s h
0000020 [ 1 9 1 5 ] \t U n c l e   D y n
0000040 a m i t e   [ 1 9 4 8 ] \n L e a
0000060 v e   i t   t o   P s m i t h
0000100 [ 1 9 2 3 ] \t P i g s   H a v e
0000120   W i n g s   [ 1 9 5 2 ] \n S u
0000140 m m e r   L i g h t n i n g   [
0000160 1 9 2 9 ] \t C o c k t a i l   T
0000200 i m e   [ 1 9 5 8 ] \n H e a v y
0000220   W e a t h e r   [ 1 9 3 3 ] \t
0000240 S e r v i c e   w i t h a   S
0000260 m i l e   [ 1 9 6 1 ] \n B l a n
0000300 d i n g s   C a s t l e   a n d
0000320   E l s e w h e r e   [ 1 9 3 5
0000340 ] \t G a l a h a d   a t   B l a
0000360 n d i n g s   [ 1 9 6 5 ] \n U n
0000400 c l e   F r e d   i n   t h e
0000420 S p r i n g t i m e   [ 1 9 3 9
0000440 ] \t A   P e l i c a n   a t   B
0000460 l a n d i n g s   [ 1 9 6 9 ] \n
0000500 F u l l   M o o n   [ 1 9 4 7 ]
0000520 \t S u n s e t   a t   B l a n d
0000540 i n g s   [ 1 9 7 7 ] \n
0000554</screen>
    </sect2>
  </sect1>

  <sect1 id="commands-remote-connections">
    <title>Connessioni remote</title>

    <table frame="all" id="commands-table-remote-connections">
      <title>Comandi per connessioni remote</title>

      <tgroup cols="2">
        <colspec colwidth="3in">

        <thead>
          <row>
            <entry align="center">Comando/Sintassi</entry>

            <entry align="center">Cosa fa</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><command>finger [<replaceable>opzioni</replaceable>]
                <replaceable>user</replaceable>[@<replaceable>nomehost</replaceable>]</command></entry>

            <entry>riporta informazioni sugli utenti delle macchine locali
              e remote</entry>
          </row>

          <row>
            <entry><command>ftp [<replaceable>opzioni</replaceable>]
                <replaceable>host</replaceable></command></entry>

            <entry>trasferisce file utilizzando il protocollo di trasferimento
              di file</entry>
          </row>

          <row>
            <entry><command>rcp [<replaceable>opzioni</replaceable>]
                <replaceable>nomehost</replaceable></command></entry>

            <entry>copia file in remoto dalla macchina corrente in un'altra
              macchina</entry>
          </row>

          <row>
            <entry><command>rlogin [<replaceable>opzioni</replaceable>]
                <replaceable>nomehost</replaceable></command></entry>

            <entry>effettua il login in remoto su un'altra macchina</entry>
          </row>

          <row>
            <entry><command>rsh [<replaceable>opzioni</replaceable>]
                <replaceable>nomehost</replaceable></command></entry>

            <entry>shell remota da eseguire su un'altra macchina</entry>
          </row>

          <row>
            <entry><command>telnet [<replaceable>host</replaceable>
                [<replaceable>porta</replaceable>]]</command></entry>

            <entry>comunica con un altro host utilizzando il protocollo
              telnet</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <sect2 id="commands-remote-connections-telnet-ftp">
      <title>TELNET e FTP - protocollo di login remoto e di trasferimento di
        file</title>

      <para><emphasis>TELNET</emphasis> e <emphasis>FTP</emphasis> sono
        protocolli del livello applicazione di Internet.  Le specifiche dei
        protocolli FTP e TELNET sono state realizzate da molte organizzazioni,
        incluso il Centro Nazionale per le Applicazioni di Supercomputer (NCSA),
        molti altri domini pubblici e organizzazioni collaborative.</para>

      <para>I programmi che implementano il protocollo
        <emphasis>TELNET</emphasis> sono usualmente chiamati
        <application>telnet</application>, ma non sempre.  Alcune notevoli
        eccezioni sono <command>tn3270</command>, <command>WinQVT</command> e
        <command>QWS3271</command>, che implementano comunque il protocollo
        TELNET.  TELNET viene usato per effettuare il login remoto su un
        altro computer in Internet.</para>

      <para>I programmi che implementano il protocollo <emphasis>FTP</emphasis>
        sono usualmente chiamati <application>ftp</application>, ma esistono
        anche delle eccezioni.  Il programma chiamato <command>Fetch</command>,
        distribuito dalla Dartmouth College, <command>WS_FTP</command>, scritto
        e distribuito da John Junod e <command>Ftptool</command>, scritto da
        Mike Sullivan, sono implementazioni del protocollo FTP con
        un'interfaccia utente grafica.  Esiste una versione migliore di FTP,
        <command>ncftp</command> che ha caratteristiche aggiuntive, scritto da
        Mike Gleason.  Comunque, l'implementazione del protocollo FTP viene
        spesso inclusa nei programmi che implementano TELNET, come quello
        distribuito dalla NCSA.  FTP viene usato per trasferire file tra
        computer su Internet.</para>

      <para>&man.rlogin.1; &egrave; un servizio di login remoto che
        &egrave; stato in passato un'esclusiva dello Unix BSD 4.3 di Berkeley.
        Essenzialmente, offre le stesse funzionalit&agrave; di &man.telnet.1;,
        eccetto che &man.rlogin.1; lascia passare al computer remoto le
        informazioni dell'ambiente di login dell'utente.  Le macchine possono
        essere configurate per permettere connessioni da fidati host senza
        richiedere la password dell'utente.  Una versione pi&ugrave; sicura di
        questo protocollo &egrave; la Sicura SHell
        <application>SSH</application>, software scritto da Tatu Ylonen e
        disponibile via: <ulink
          url="ftp://ftp.net.ohio-state.edu/pub/security/ssh"><hostid
            role="fqdn">ftp://ftp.net.ohio-state.edu/pub/security/ssh</hostid></ulink>.</para>

      <para>Da un prompt Unix, questi programmi possono essere invocati
        digitando il comando (nome del comando) e il nome (Internet) della
        macchina remota alla quale ci si vuole connettere.  Inoltre si possono
        specificare diverse opzioni per questi comandi, come mostrato di
        seguito.</para>

      <para><emphasis>Sintassi</emphasis></para>

      <para><command>telnet [<replaceable>opzioni</replaceable>]
          [<replaceable>host_remoto</replaceable>
          [<replaceable>porta</replaceable>]]</command></para>

      <para><command>tn3270 [<replaceable>opzioni</replaceable>]
          [<replaceable>host_remoto</replaceable>
          [<replaceable>porta</replaceable>]]</command></para>

      <para><command>ftp [<replaceable>opzioni</replaceable>]
          [<replaceable>host_remoto</replaceable>]</command></para>

      <para><emphasis>Opzioni generali</emphasis></para>

      <informaltable frame="none">
        <tgroup cols="3">
          <colspec colwidth="1in">
          <colspec colwidth="1in">

          <thead>
            <row>
              <entry>ftp</entry>

              <entry>telnet</entry>

              <entry>Azione</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><option>-d</option></entry>

              <entry></entry>

              <entry>abilit&agrave; la modalit&agrave; di debugging</entry>
            </row>

            <row>
              <entry></entry>

              <entry><option>-d</option></entry>

              <entry>come sopra (solamente SVR4)</entry>
            </row>

            <row>
              <entry><option>-i</option></entry>

              <entry></entry>

              <entry>disabilita il prompt interattivo</entry>
            </row>

            <row>
              <entry><option>-n</option></entry>

              <entry></entry>

              <entry>non tenta un auto-login su una connessione</entry>
            </row>

            <row>
              <entry><option>-v</option></entry>

              <entry></entry>

              <entry>modalit&agrave; verbose</entry>
            </row>

            <row>
              <entry></entry>

              <entry><option>-l <replaceable>user</replaceable></option></entry>

              <entry>si connette all'host remoto con il nome utente specificato
                (solamente SVR4)</entry>
            </row>

            <row>
              <entry></entry>

              <entry><option>-8</option></entry>

              <entry>percorso dati 8-bit (solamente SVR4)</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>&man.telnet.1; e <command>tn3270</command> hanno un'opzione per
        specificare il numero di porta a cui connettersi sull'host remoto.  Per
        entrambi i comandi, il numero di porta di default &egrave; 23,
        la porta telnet.  Altre porte vengono usate per il debugging dei servizi
        di rete e per ragioni speciali.</para>

      <para><emphasis>Esempi:</emphasis></para>

      <screen>&prompt.user; <userinput>telnet oscar.us.ohio-state.edu</userinput></screen>

      <screen>&prompt.user; <userinput>tn3270 ohstmvsa.acs.ohio-state.edu</userinput></screen>

      <screen>&prompt.user; <userinput>ftp magnus.acs.ohio-state.edu</userinput></screen>

      <para>La macchina remota richieder&agrave; di identificarsi tramite login
        e password.  Spesso, le macchine organizzate come archivi di
        software o di informazioni, permettono connessioni ftp anonime.  Ci si
        collega tramite &man.ftp.1; alla macchina remota e si effettua il
        login come <username>anonymous</username> (il login
        <username>ftp</username> &egrave; equivalente su molte macchine)
        cio&egrave;, quando viene richiesto il login si digita
        <username>anonymous</username> (di solito per la password si inserisce
        il proprio indirizzo email o qualsiasi altra cosa).</para>

      <para>Una volta che si &egrave; correttamente collegati a un computer
        remoto tramite &man.telnet.1; e &man.rlogin.1; (e assumendo che sia
        stata assegnata l'emulazione del terminale) si potr&agrave; utilizzare
        la macchina come al solito.</para>

      <para>Una volta che si &egrave; correttamente collegati ad un computer
        remoto tramite &man.ftp.1;, si pu&ograve; trasferire un file in quel
        computer con il comando <command>put</command> o prenderlo da quel
        computer con il comando <command>get</command>.  La sintassi &egrave; la
        seguente:</para>

      <para><command>put <replaceable>nome-file-locale
          nome-file-remoto</replaceable></command></para>

      <para><command>get <replaceable>nome-file-locale
          nome-file-remoto</replaceable></command></para>

      <para>Sono disponibili altri comandi per &man.ftp.1;, a seconda della
        specifica implementazione dell'FTP locale e remoto.  Il comando
        <command>help</command> visualizza un elenco di comandi disponibili.
        Il comando <command>help</command> pu&ograve; visualizzare lo scopo di
        un comando specifico.  Esempi di validi comandi sono mostrati di
        seguito:</para>

      <informaltable frame="none">
        <tgroup cols="2">
          <colspec colwidth="1.5in">

          <tbody>
            <row>
              <entry><command>help</command></entry>

              <entry>mostra un elenco di comandi disponibili</entry>
            </row>

            <row>
              <entry><command>help mget</command></entry>

              <entry>mostra lo scopo del comando <command>mget</command>
                (prendere file multipli)</entry>
            </row>

            <row>
              <entry><command>pwd</command></entry>

              <entry>mostra la corrente directory di lavoro</entry>
            </row>

            <row>
              <entry><command>ls</command> o <command>dir</command></entry>

              <entry>elenca il contenuto delle directory</entry>
            </row>

            <row>
              <entry><command>cd</command></entry>

              <entry>cambia directory</entry>
            </row>

            <row>
              <entry><command>lcd</command></entry>

              <entry>cambia la directory locale</entry>
            </row>

            <row>
              <entry><command>open</command></entry>

              <entry>specifica la macchina alla quale si vuole
                connettersi</entry>
            </row>

            <row>
              <entry><command>user</command></entry>

              <entry>specifica il proprio id di login (nel caso che non venga
                richiesto direttamente)</entry>
            </row>

            <row>
              <entry><command>quit</command></entry>

              <entry>esce dal programma FTP</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </sect2>

    <sect2 id="commands-remote-connections-finger">
      <title>finger - restituisce informazioni riguardo gli utenti</title>

      <para>Il comando &man.finger.1; mostra il file <filename>.plan</filename>
        di un utente specifico o riporta chi &egrave; attualmente
        <quote>loggato</quote> su una specifica macchina.  L'utente deve
        permettere i permessi di lettura generale sul file
        <filename>.plan</filename>.</para>

      <para><emphasis>Sintassi</emphasis></para>

      <para><command>finger [<replaceable>opzioni</replaceable>]
          [<replaceable>user</replaceable>[@<replaceable>nomehost</replaceable>]]</command></para>

      <para><emphasis>Opzioni generali</emphasis></para>

      <informaltable frame="none">
        <tgroup cols="2">
          <colspec colwidth="0.5in">

          <tbody>
            <row>
              <entry><option>-l</option></entry>

              <entry>forza il formato lungo di output</entry>
            </row>

            <row>
              <entry><option>-m</option></entry>

              <entry>ottiene solo lo username, non il nome e cognome
                reali</entry>
            </row>

            <row>
              <entry><option>-s</option></entry>

              <entry>forza il formato corto di output</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para><emphasis>Esempi:</emphasis></para>

      <screen>brigadier:condron [77]> <userinput>finger workshop@nyssa</userinput>
Questo &egrave; un esempio di file .plan per l'id workshop di nyssa.
Questo id &egrave; stato usato in questa settimana da Frank Fiamingo, Linda
DeBula, e Linda Condron, mentre insegnavano ad usare una nuova versione
di Unix workshop sviluppata per l'UTS.

Sperando di aver insegnato qualcosa.
Frank, Linda, & Linda</screen>

      <screen>brigadier: condron [77]> <userinput>finger</userinput>
Login     Name                TTY     Idle    When        Where

condron   Linda S Condron     p0              Sun 18:13   lcondron-mac.acs
frank     Frank G. Fiamingo   p1              Mon 16:19   nyssa</screen>
    </sect2>

    <sect2 id="commands-remote-connections-">
      <title>Comandi remoti</title>

      <para>Alcune macchine Unix possono essere collegate tra loro per formare
        una rete locale (LAN).  In questo caso succede spesso che un utente di
        una macchina possieda validi accessi di login su molte altre macchine
        della rete locale.  Per questo tipo di utente sono disponibili comandi
        Unix che forniscono una certa praticit&agrave; nel realizzare certe
        operazioni comuni.  Poich&egrave; questi comandi si focalizzano su
        comunicazioni con host remoti nella rete locale (o in Internet), i nomi
        dei comandi iniziano con la lettera <emphasis>r</emphasis>:
        &man.rlogin.1;, &man.rsh.1; e &man.rcp.1;.  La possibilit&agrave; di
        accesso remoto tramite questi comandi &egrave; sostenuta (opzionalmente)
        attraverso il file <filename>~/.rhosts</filename> di ogni singolo utente
        e dal file generale di sistema <filename>/etc/hosts.equiv</filename>.
        Per ragioni di sicurezza questi possono essere limitati ad alcuni
        host.</para>

      <para>Il comando &man.rlogin.1; permette un accesso di login remoto
        su un altro host della rete locale. &man.rlogin.1; passa
        informazioni all'host remoto circa l'ambiente locale, incluso il valore
        della variabile d'ambiente <literal>TERM</literal>.</para>

      <para>Il comando &man.rsh.1; fornisce la possibilit&agrave; di invocare
        una shell Unix su un host remoto della rete locale con lo scopo di
        eseguirci comandi di shell.  Questa capacit&agrave; &egrave; simile alla
        funzione shell escape disponibile generalmente all'interno di un
        software di sistema Unix come editor ed email.</para>

      <para>Il comando &man.rcp.1; fornisce la possibilit&agrave; di
        copiare file dall'host locale ad un host remoto della rete
        locale.</para>

      <para><emphasis>Sintassi</emphasis></para>

      <para><command>rlogin [-l <replaceable>username</replaceable>]
          <replaceable>host_remoto</replaceable></command></para>

      <para><command>rsh [-l <replaceable>username</replaceable>]
          <replaceable>host_remoto</replaceable>
          [<replaceable>comando</replaceable>]</command></para>

      <para><command>rcp
          [[<replaceable>user1</replaceable>]@<replaceable>host1</replaceable>:]<replaceable>file_sorgente</replaceable>
          [[<replaceable>user2</replaceable>]@<replaceable>host2</replaceable>:]<replaceable>file_destinazione</replaceable></command></para>

      <para>dove le parti tra parentesi ([]) sono opzionali.
        &man.rcp.1; non richiede password, quindi si deve avere il
        permesso per eseguire comandi remoti su una specifica macchina.</para>

      <para><emphasis>Opzioni generali</emphasis></para>

      <informaltable frame="none">
        <tgroup cols="2">
          <colspec colwidth="1.5in">

          <tbody>
            <row>
              <entry><option>-l
                  <replaceable>username</replaceable></option></entry>

              <entry>si connette all' host remoto con il nome utente specificato
                (&man.rlogin.1; & &man.rsh.1;)</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>Il file <filename>.rhosts</filename>, se esiste nella directory home
        dell'utente sull'host remoto, permette l'accesso tramite &man.rlogin.1;,
        &man.rsh.1; e &man.rcp.1; agli host remoti senza richiedere la password
        per tale account.  Il file <filename>.rhosts</filename> contiene un
        record per ogni coppia host remoto-username con il quale il proprietario
        del file <filename>.rhosts</filename> desidera connettersi.  Ogni record
        nel file <filename>.rhosts</filename> &egrave; della forma:</para>

      <para><replaceable>host_remoto utente_remoto</replaceable></para>

      <para>dove l'elenco
        <username><replaceable>utente_remoto</replaceable></username> &egrave;
        opzionale.  Per esempio, se Heather Jones vuole essere in grado di
        connettersi alla <hostid role="hostname">macchina1</hostid> (dove il suo
        username &egrave; <username>heather</username>) dalla
        <hostid role="hostname">macchina2</hostid> (dove il suo username
        &egrave; <username>jones</username>) o dalla
        <hostid role="hostname">macchina3</hostid> (dove il suo username
        &egrave; <username>heather</username>, lo stesso della
        <hostid role="hostname">macchina1</hostid>), lei potrebbe creare un file
        <filename>.rhosts</filename> nella sua home directory sulla
        <hostid role="hostname">macchina1</hostid>.  Il contenuto di questo file
        potrebbe essere:</para>

      <programlisting>macchina2 jones
macchina3

-oppure-

macchina2 jones
macchina3 heather</programlisting>

      <para>Su alcuni sistemi il file <filename>/etc/hosts.equiv</filename>
        presta lo stesso scopo per tutti gli utenti, al di fuori del super-user.
        Cos&igrave; un file <filename>/etc/hosts.equiv</filename>
        contenente:</para>

      <para><replaceable>macchina_remota</replaceable></para>

      <para>permette agli utenti provenienti da <hostid
          role="hostname"><replaceable>macchina_remota</replaceable></hostid>
        che hanno gli stessi username della macchina corrente, di
        connettersi a quest'ultima senza la necessita' di inserire la
        password.</para>

      <para>Un file <filename>/etc/hosts.equiv</filename> che contiene:</para>

      <para><replaceable>macchina_remota utente_remoto</replaceable></para>

      <para>permette a
        <username><replaceable>utente_remoto</replaceable></username> su <hostid
          role="hostname"><replaceable>macchina_remota</replaceable></hostid>
        di connettersi alla macchina corrente allo stesso modo dell'utente
        locale, tranne che per il super-user.</para>

      <para>I file <filename>/etc/hosts.equiv</filename> e
        <filename>~/.rhosts</filename> vanno usati con cautela.</para>

      <para>Le versioni dei programmi &man.rcp.1;, &man.rsh.1; e &man.rlogin.1;
        basati sulla Secure SHell (<application>SSH</application>) sono
        liberamente disponibili e forniscono molta pi&ugrave; sicurezza.</para>
    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "book" "chapter")
     End:
-->