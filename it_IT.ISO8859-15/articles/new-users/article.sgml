<!--
     The FreeBSD Italian Documentation Project

     $FreeBSD$
     Original revision: 1.41
-->

<!DOCTYPE article PUBLIC "-//FreeBSD//DTD DocBook V4.1-Based Extension//EN" [
<!ENTITY % man PUBLIC "-//FreeBSD//ENTITIES DocBook Manual Page Entities//EN">
%man;
<!ENTITY % freebsd PUBLIC "-//FreeBSD//ENTITIES DocBook Miscellaneous FreeBSD Entities//EN">
%freebsd;
<!ENTITY % it-trademarks PUBLIC "-//FreeBSD//ENTITIES DocBook Trademark Entities//IT">
%it-trademarks;
<!ENTITY % trademarks PUBLIC "-//FreeBSD//ENTITIES DocBook Trademark Entities//EN">
%trademarks;
<!ENTITY % mailing-lists PUBLIC "-//FreeBSD//ENTITIES DocBook Mailing List Entities//IT">
%mailing-lists;
<!ENTITY % translators PUBLIC "-//FreeBSD//ENTITIES DocBook Translator Entities//IT">
%translators;
]>

<article lang="it">
  <articleinfo>
    <title>Per chi &egrave; alle Prime Armi sia con FreeBSD che con
      &unix;</title>

    <authorgroup>
      <author>
        <firstname>Annelise</firstname>

        <surname>Anderson</surname>

        <affiliation>
          <address><email>andrsn@andrsn.stanford.edu</email></address>
        </affiliation>
      </author>
    </authorgroup>

    <pubdate>15 Agosto 1997</pubdate>

    <legalnotice id="trademarks" role="trademarks">
      &tm-attrib.freebsd;
      &tm-attrib.ibm;
      &tm-attrib.microsoft;
      &tm-attrib.netscape;
      &tm-attrib.opengroup;
      &tm-attrib.general;
    </legalnotice>

    <abstract>
      <para>Congratulazioni per aver installato FreeBSD! Questa introduzione
        &eacute; per chi &eacute; alle prime armi con FreeBSD
        <emphasis>e</emphasis> &unix;&mdash;perci&ograve; comincia dalle basi.
        Stai certamente usando la versione 2.0.5 o una pi&ugrave; recente di
        &os; distribuita da &os;.org, il tuo sistema ha (per il momento) un
        solo utente (te stesso)&mdash;e sei probabilmente abbastanza bravo
        con DOS/&windows; o &os2;.</para>

      &trans.it.max;
    </abstract>
  </articleinfo>

  <sect1>
    <title>Entrare ed Uscire dal Sistema</title>

    <para>Entra (quando vedi <prompt>login:</prompt>) come l'utente che
      hai creato durante l'installazione oppure come
      <username>root</username>.  (La tua installazione di FreeBSD dovrebbe
      gi&agrave; avere un account di <username>root</username>; che pu&ograve;
      andare ovunque e fare qualsiasi cosa, anche cancellare file essenziali,
      perci&ograve; stai attento!)  I simboli &prompt.user; e &prompt.root;
      che incontrerai pi&ugrave; avanti simboleggiano il prompt (i tuoi
      potrebbero essere differenti), dove &prompt.user; indica un utente
      ordinario e &prompt.root; indica <username>root</username>.</para>

    <para>Per uscire (e ritrovarsi con un nuovo prompt <prompt>login:</prompt>)
      scrivi</para>

    <informalexample>
      <screen>&prompt.root; <userinput>exit</userinput></screen>
    </informalexample>

    <para>tante volte quanto serve. S&igrave;, premi
      <keysym>invio</keysym> dopo ogni comando, e ricordati che &unix; fa
      distinzione tra maiuscole e minuscole&mdash;perci&ograve;
      <command>exit</command>, non <command>EXIT</command>.</para>

    <para>Per spegnere il computer digita</para>

    <informalexample>
      <screen>&prompt.root; <userinput>/sbin/shutdown -h now</userinput></screen>
    </informalexample>

    <para>O per riavviarlo digita</para>

    <informalexample>
      <screen>&prompt.root; <userinput>/sbin/shutdown -r now</userinput></screen>
    </informalexample>

    <para>oppure</para>

    <informalexample>
      <screen>&prompt.root; <userinput>/sbin/reboot</userinput></screen>
    </informalexample>

    <para>Puoi anche riavviarlo premendo
      <keycombo><keycap>Ctrl</keycap><keycap>Alt</keycap><keycap>Canc</keycap></keycombo>.
      Lasciagli un po' di tempo per compiere il suo lavoro.  Questo equivale a
      <command>/sbin/reboot</command> nelle versioni pi&ugrave; recenti di
      FreeBSD ed &egrave; molto meglio che premere il bottone di reset.
      Non vorrai mica reinstallare tutto da capo, vero?</para>
  </sect1>

  <sect1>
    <title>Aggiungere un Utente con Privilegi di Root</title>

    <para>Se non hai creato un utente durante l'installazione e quindi
      sei entrato nel sistema come <username>root</username>, dovresti
      probabilmente crearne uno ora tramite</para>

    <informalexample>
      <screen>&prompt.root; <userinput>adduser</userinput></screen>
    </informalexample>

    <para>La prima volta che aggiungi un utente, il sistema dovrebbe chiederti
      di inserire delle impostazioni di default da applicare.  Potresti volere
      come shell &man.csh.1; invece di &man.sh.1;, se ti viene consigliato
      <command>sh</command> come default.  Altrimenti premi solo invio
      per accettare i valori proposti.  Questi dati vengono salvati in
      <filename>/etc/adduser.conf</filename>, un file modificabile
      successivamente a mano.</para>

    <para>Supponiamo che tu voglia creare l'utente <username>jack</username> di
      nome reale <emphasis>Jack Benimble</emphasis>.  Assegna a
      <username>jack</username> una password per ragioni di sicurezza (anche i
      bambini che gironzolano per casa potrebbero mettere le mani sulla
      tastiera).  Quando ti viene chiesto se vuoi invitare
      <username>jack</username> in un altro gruppo, digita
      <groupname>wheel</groupname></para>

    <informalexample>
      <screen>Login group is ``jack''. Invite jack into other groups: <userinput>wheel</userinput></screen>
    </informalexample>

    <para>Questo ti permetter&agrave; di entrare come l'utente
      <username>jack</username> e usare il comando &man.su.1;
      per diventare <username>root</username>.  A quel punto non sarai
      pi&ugrave; preso in giro per essere entrato direttamente come
      <username>root</username>.</para>

    <para>Puoi uscire da <command>adduser</command> in qualsiasi momento
      premendo <keycombo><keycap>Ctrl</keycap><keycap>C</keycap></keycombo>,
      e alla fine avrai l'opportunit&agrave; di approvare il nuovo utente oppure
      premere <keycap>n</keycap> per non farlo.  Potresti voler creare un
      secondo utente cosicch&eacute; quando andrai a modificare i file
      di <username>jack</username> avrai un'ancora di salvezza in caso qualcosa
      vada male.</para>

    <para>Una volta fatto questo, usa <command>exit</command> per tornare al
      prompt di login ed entrare come <username>jack</username>.
      In generale &egrave; meglio cercare di lavorare da utente normale
      in modo da non avere il potere&mdash;e il rischio&mdash;di
      <username>root</username>.</para>

    <para>Se hai gi&agrave; creato un utente e vuoi che quell'utente sia in
      grado di usare <command>su</command> per diventare
      <username>root</username>, puoi entrare come <username>root</username> e
      modificare il file <filename>/etc/group</filename>, aggiungendo
      <username>jack</username> alla prima linea (il gruppo
      <groupname>wheel</groupname>).  Ma prima devi fare pratica con
      &man.vi.1;, l'editor di testo&mdash;oppure usa il pi&ugrave; semplice
      &man.ee.1;, installato sulle recenti versioni di FreeBSD.</para>

    <para>Per cancellare un utente, usa il comando
      <command>rmuser</command>.</para>
  </sect1>

  <sect1>
    <title>Diamoci un'occhiata in giro</title>

    <para>Una volta avuto accesso come utente normale, guardati in giro e prova
      alcuni dei comandi che ti daranno accesso alle fonti di aiuto e di
      informazioni su FreeBSD.</para>

    <para>Ecco qui una lista di comandi e le loro funzioni:</para>

    <variablelist>
      <varlistentry>
        <term><command>id</command></term>

        <listitem>
          <para>Ti dice chi sei!</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><command>pwd</command></term>

        <listitem>
          <para>Ti mostra dove sei&mdash;la directory in cui stai
            lavorando.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><command>ls</command></term>

        <listitem>
          <para>Ti mostra una lista dei file contenuti nella directory.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><command>ls <option>-F</option></command></term>

        <listitem>
          <para>Ti mostra un elenco dei file contenuti nella directory ponendo
            <literal>*</literal> dopo i file eseguibili,
            <literal>/</literal> dopo le directory, e
            <literal>@</literal> dopo i collegamenti simbolici.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><command>ls <option>-l</option></command></term>

        <listitem>
          <para>Mostra un elenco di file nel formato lungo&mdash;grandezza,
            data, permessi.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><command>ls <option>-a</option></command></term>

        <listitem>
          <para>Mostra una lista dei file nascosti, cio&egrave; con un
            <quote>punto</quote> davanti al nome, insieme agli altri.
            Se sei <username>root</username>, i file <quote>puntati</quote>
            vengono mostrati anche senza l'opzione <option>-a</option>.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><command>cd</command></term>

        <listitem>
          <para>Cambia la directory di lavoro.  <command>cd
              <parameter>..</parameter></command> torna alla directory
            superiore; nota lo spazio dopo <command>cd</command>.  <command>cd
              <parameter>/usr/local</parameter></command> va nella directory
            specificata.  <command>cd <parameter>~</parameter></command> va
            nella directory home dell'utente collegato in quel
            momento&mdash;per esempio, <filename>/usr/home/jack</filename>.
            Prova <command>cd <parameter>/cdrom</parameter></command>, e poi
            <command>ls</command>, per scoprire se il tuo CDROM &egrave;
            montato e funziona.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><command>view
            <replaceable>nomefile</replaceable></command></term>

        <listitem>
          <para>Mostra il contenuto del file (chiamato
            <replaceable>nomefile</replaceable>) senza modificarlo.
            Prova <command>view
            <parameter>/etc/fstab</parameter></command>.
            Digita <command>:q</command> per uscire.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><command>cat <replaceable>nomefile</replaceable></command></term>

        <listitem>
          <para>Mostra <replaceable>nomefile</replaceable> sullo schermo.
            Se &egrave; troppo lungo e ne puoi vedere solo la fine,
            premi <keycap>BlocScorr</keycap> e usa
            <keycap>freccia-su</keycap> per muoverti in alto; puoi usare
            <keycap>BlocScorr</keycap> anche con le pagine man.  Premi ancora
            <keycap>BlocScorr</keycap> per uscire dallo scorrimento.  Potresti
            provare <command>cat</command> con alcuni dei file
            nascosti presenti nella tua directory home&mdash;<command>cat
              <parameter>.cshrc</parameter></command>, <command>cat
              <parameter>.login</parameter></command>, <command>cat
              <parameter>.profile</parameter></command>.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>Noterai degli alias in <filename>.cshrc</filename> per
      alcuni dei comandi <command>ls</command> (sono molto
      convenienti).  Puoi creare degli altri alias modificando
      <filename>.cshrc</filename>.  Puoi far s&igrave; che questi alias
      diventino disponibili a tutti gli utenti mettendoli nel file
      di configurazione generale di <command>csh</command>,
      <filename>/etc/csh.cshrc</filename>.</para>
  </sect1>

  <sect1>
    <title>Ottenere Aiuto e Informazioni</title>

    <para>Ecco alcune risorse utili per ottenere aiuto.
      <replaceable>Testo</replaceable> &egrave; qualcosa che puoi
      digitare a tuo piacere&mdash;normalmente si tratta di un comando
      o del nome di un file.</para>

    <variablelist>
      <varlistentry>
        <term><command>apropos
            <replaceable>testo</replaceable></command></term>

        <listitem>
          <para>Tutto ci&ograve; che contiene la stringa
            <replaceable>testo</replaceable> nel <database>database
              whatis</database>.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><command>man
            <replaceable>testo</replaceable></command></term>

        <listitem>
          <para>Mostra la pagina man di <replaceable>testo</replaceable>,
            la maggior risorsa di documentazione per i sistemi Un*x.
            <command>man <parameter>ls</parameter></command> ti dir&agrave;
            tutti i modi possibili per usare il comando <command>ls</command>.
            Premi <keycap>Invio</keycap> per muoverti nel testo,
            <keycombo><keycap>Ctrl</keycap><keycap>B</keycap></keycombo>
            per andare indietro di una pagina,
            <keycombo><keycap>Ctrl</keycap><keycap>F</keycap></keycombo>
            per andare avanti, <keycap>q</keycap> oppure
            <keycombo><keycap>Ctrl</keycap><keycap>C</keycap></keycombo>
            per uscire.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><command>which
            <replaceable>testo</replaceable></command></term>

        <listitem>
          <para>Ti dice dove si trova il comando
            <replaceable>testo</replaceable> nel path dell'utente.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><command>locate
            <replaceable>testo</replaceable></command></term>

        <listitem>
          <para>Ti dice tutte le directory nei path dell'utente in cui si trova
            il comando <replaceable>testo</replaceable>.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><command>whatis
            <replaceable>testo</replaceable></command></term>

        <listitem>
          <para>Ti dice che cosa fa il comando
            <replaceable>testo</replaceable> e la sua pagina man.
            Digitando <command>whatis *</command> ti verranno presentate tutte
            le pagine man associate agli eseguibili presenti nella directory
            corrente.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><command>whereis
            <replaceable>testo</replaceable></command></term>

        <listitem>
          <para>Trova il file <replaceable>testo</replaceable>, dandoti il suo
            percorso completo.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>Potresti voler provare ad usare <command>whatis</command> con
      alcuni comandi utili come <command>cat</command>,
      <command>more</command>, <command>grep</command>,
      <command>mv</command>, <command>find</command>,
      <command>tar</command>, <command>chmod</command>,
      <command>chown</command>, <command>date</command>, e
      <command>script</command>.  <command>more</command> ti permette
      di leggere una pagina alla volta come in DOS, ad esempio, <command>ls -l |
        more</command> oppure <command>more
        <replaceable>nomefile</replaceable></command>.
      <literal>*</literal> ha valore assoluto&mdash;per esempio, <command>ls
        w*</command> mostra tutti i file che cominciano con
      <literal>w</literal>.</para>

    <para>Per caso alcuni di questi comandi non funzionano correttamente?  Sia
      &man.locate.1;, sia &man.whatis.1; dipendono da
      un database che viene ricostruito settimanalmente.  Se la tua macchina
      non sar&agrave; lasciata accesa per il fine settimana (usando FreeBSD),
      pu&ograve; darsi che tu voglia usare i comandi per la manutenzione
      giornaliera, settimanale, e mensile ogni tanto.  Falli partire come
      <username>root</username> e lascia loro il tempo di finire il lavoro
      prima di farne partire un altro.</para>

    <informalexample>
      <screen>&prompt.root; <userinput>periodic daily</userinput>
<lineannotation>output tralasciato</lineannotation>
&prompt.root; <userinput>periodic weekly</userinput>
<lineannotation>output tralasciato</lineannotation>
&prompt.root; <userinput>periodic monthly</userinput>
<lineannotation>output tralasciato</lineannotation></screen>
    </informalexample>

    <para>Se ti stufi di aspettare, premi
      <keycombo><keycap>Alt</keycap><keycap>F2</keycap></keycombo> per
      avere un'altra <firstterm>console virtuale</firstterm>, e poterti loggare
      nuovamente.  Dopotutto &egrave; un sistema multi-utente, e multi-tasking.
      Probabilmente questi comandi produrranno dei messaggi sullo
      schermo quando lavorano; puoi digitare
      <command>clear</command> per pulire lo schermo.
      Quando hanno finito, dovresti dare un'occhiata a
      <filename>/var/mail/root</filename> e
      <filename>/var/log/messages</filename>.</para>

    <para>Usare tali comandi fa parte dell'amministrazione di
      sistema&mdash;e come utente singolo di un sistema &unix;,
      sei tu l'amministratore del sistema.  Praticamente l'unica cosa
      per la quale &egrave; necessario che tu sia <username>root</username>
      &egrave; l'amministrazione.  Queste responsabilit&agrave; non vengono
      trattate bene nemmeno in quei grossi libri su &unix;, che sembrano
      dedicare troppo spazio all'uso dei menu nei windows manager.  Potresti
      voler leggere uno dei pi&ugrave; interessanti libri sull'amministrazione
      di sistema, come <citetitle>UNIX System Administration
        Handbook</citetitle> di Evi Nemeth et.al. (Prentice-Hall, 1995,
      ISBN 0-13-15051-7)&mdash;la seconda edizione con la copertina rossa;
      oppure <citetitle>Essential System Administration</citetitle> di
      &AElig;leen Frisch (O'Reilly &amp; Associates, 2002, ISBN 0-596-00343-9).
      Io ho usato quello di Nemeth.</para>
  </sect1>

  <sect1>
    <title>Modificare File di Testo</title>

    <para>Per poter configurare il tuo sistema, devi modificare dei file.  Molti
      di questi saranno in <filename>/etc</filename>; e avrai bisogno
      del comando <command>su</command> per diventare <username>root</username>
      e poter cos&igrave; modificarli.  Puoi usare il semplice editor
      <command>ee</command>, ma alla lunga risulta pi&ugrave; utile imparare
      <command>vi</command>.  C'&eacute; un eccellente tutorial su
      <command>vi</command> in
      <filename>/usr/src/contrib/nvi/docs/tutorial</filename> se hai installato
      i sorgenti di sistema.</para>

    <para>Prima di modificare un file, dovresti farne una copia.
      Supponiamo tu voglia modificare <filename>/etc/rc.conf</filename>.  Puoi
      semplicemente usare <command>cd /etc</command> per andare in
      <filename>/etc</filename> e fare:</para>

    <informalexample>
      <screen>&prompt.root; <userinput>cp rc.conf rc.conf.orig</userinput></screen>
    </informalexample>

    <para>Questo copier&agrave; <filename>rc.conf</filename> in
      <filename>rc.conf.orig</filename>, e potrai successivamente copiare
      <filename>rc.conf.orig</filename> in
      <filename>rc.conf</filename> per tornare all'originale.  Ma ancora meglio
      sar&agrave; spostare (rinominare) il file per poi ricopiarlo con il nome
      originale:</para>

    <informalexample>
      <screen>&prompt.root; <userinput>mv rc.conf rc.conf.orig</userinput>
&prompt.root; <userinput>cp rc.conf.orig rc.conf</userinput></screen>
    </informalexample>

    <para>perch&eacute; il comando <command>mv</command> mantiene
      la data e il proprietario originali del file.  Puoi ora modificare
      <filename>rc.conf</filename>.  Se vuoi tornare all'originale,
      potresti fare <userinput>mv rc.conf rc.conf.myedit</userinput>
      (assumendo che vuoi tenere la versione modificata) e
      quindi fare</para>

    <informalexample>
      <screen>&prompt.root; <userinput>mv rc.conf.orig rc.conf</userinput></screen>
    </informalexample>

    <para>per tornare allo stato iniziale.</para>

    <para>Per modificare un file, digita</para>

    <informalexample>
      <screen>&prompt.root; <userinput>vi <replaceable>nomefile</replaceable></userinput></screen>
    </informalexample>

    <para>Muoviti nel testo con i tasti freccia.
      <keycap>Esc</keycap> mette <command>vi</command>
      in modalit&agrave; comando.  Ecco qui alcuni dei comandi:</para>

    <variablelist>
      <varlistentry>
        <term><command>x</command></term>

        <listitem>
          <para>cancella la lettera su cui si trova il cursore</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><command>dd</command></term>

        <listitem>
          <para>cancella l'intera riga (anche se va a capo sullo schermo)</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><command>i</command></term>

        <listitem>
          <para>inserisci del testo nella posizione del cursore</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><command>a</command></term>

        <listitem>
          <para>inserisci del testo dopo il cursore</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>Quando digiti <command>i</command> o <command>a</command>,
      puoi inserire del testo.  <command>Esc</command> ti riporta in
      modalit&agrave; comando dove puoi digitare</para>

    <variablelist>
      <varlistentry>
        <term><command>:w</command></term>

        <listitem>
          <para>per salvare le modifiche sul disco e continuare a
            modificare il file</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><command>:wq</command></term>

        <listitem>
          <para>per salvare le modifiche e uscire</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><command>:q!</command></term>

        <listitem>
          <para>per uscire senza salvare le modifiche</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><command>/<replaceable>testo</replaceable></command></term>

        <listitem>
          <para>per spostare il cursore su <replaceable>testo</replaceable>;
            <command>/<keycap>Invio</keycap></command>
            per trovare la prossima occorrenza di
            <replaceable>testo</replaceable>.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><command>G</command></term>

        <listitem>
          <para>per andare alla fine del file</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><command><replaceable>n</replaceable>G</command></term>

        <listitem>
          <para>per andare alla riga <replaceable>n</replaceable> del
            file, dove <replaceable>n</replaceable> &egrave; un numero</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><keycombo><keycap>Ctrl</keycap><keycap>L</keycap></keycombo></term>

        <listitem>
          <para>per ridisegnare lo schermo</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><keycombo><keycap>Ctrl</keycap><keycap>b</keycap></keycombo> e
          <keycombo><keycap>Ctrl</keycap><keycap>f</keycap></keycombo></term>

        <listitem>
          <para>vai avanti e indietro di una pagina, come succede con
            <command>more</command> e <command>view</command>.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>Fai un po' di pratica con <command>vi</command> nella tua directory
      home creando un nuovo file digitando <command>vi
        <replaceable>nomefile</replaceable></command> e aggiungendo
      e cancellando del testo, salvando il file, e riaprendolo di nuovo.
      <command>vi</command> &egrave; pieno di sorprese perch&eacute; &egrave;
      abbastanza complesso, e ti capiter&agrave; di digitare un comando che
      far&agrave; di sicuro qualcosa che non ti aspetti.  (Alcune persone
      preferiscono <command>vi</command>&mdash;&egrave; pi&ugrave; potente
      dell'EDIT del DOS&mdash;scopri il comando <command>:r</command>)
      Usa <keycap>Esc</keycap> una o pi&ugrave; volte per essere sicuro di
      essere in modalit&agrave; comando e continua da l&igrave; quando hai dei
      problemi, salva spesso con <command>:w</command>, e usa
      <command>:q!</command> per uscire e ricominciare (dal tuo ultimo
      <command>:w</command>) quando ne hai bisogno.</para>

    <para>Ora puoi usare <command>cd</command> per andare in
      <filename>/etc</filename>, <command>su</command> per diventare
      <username>root</username>, <command>vi</command> per modificare il file
      <filename>/etc/group</filename>, e aggiungere un utente al gruppo
      <groupname>wheel</groupname> cosicch&eacute; possa avere privilegi di
      <username>root</username>.  Aggiungi solo una virgola e il nome di login
      dell'utente alla fine della prima riga del file, premi
      <keycap>Esc</keycap>, e usa <command>:wq</command> per salvare
      il file su disco e uscire.  La modifica ha effetto immediato.  (Non hai
      lasciato uno spazio dopo la virgola, vero?)</para>
  </sect1>

  <sect1>
    <title>Stampa di File da DOS</title>

    <para>A questo punto la tua stampante non funzioner&agrave; ancora sotto
      FreeBSD, ecco quindi un sistema per creare un file da una pagina man,
      metterlo su un floppy, e quindi stamparlo da DOS.  Supponiamo che tu
      voglia leggere attentamente come cambiare i permessi sui file (abbastanza
      importante). Puoi usare <command>man chmod</command> per leggere come
      fare. Il comando</para>

    <informalexample>
      <screen>&prompt.user; <userinput>man chmod | col -b &gt; chmod.txt</userinput></screen>
    </informalexample>

    <para>toglier&agrave; gli elementi di formattazione e mander&agrave; il
      tutto sul file <filename>chmod.txt</filename> al posto di mostrare il
      contenuto sullo schermo.  Ora metti un dischetto formattato DOS nel
      lettore, digita <command>su</command> per diventare
      <username>root</username>, e scrivi</para>

    <informalexample>
      <screen>&prompt.root; <userinput>/sbin/mount -t msdos /dev/fd0 /mnt</userinput></screen>
    </informalexample>

    <para>per montare il floppy su <filename>/mnt</filename>.</para>

    <para>Ora (non hai pi&ugrave; bisogno di essere <username>root</username>,
      e puoi digitare <command>exit</command> per tornare ad essere l'utente
      <username>jack</username>) puoi andare nella directory in cui hai creato
      <filename>chmod.txt</filename> e copiare il file sul floppy
      digitando:</para>

    <informalexample>
      <screen>&prompt.user; <userinput>cp chmod.txt /mnt</userinput></screen>
    </informalexample>

    <para>e usare <command>ls /mnt</command> per vedere il
      contenuto di <filename>/mnt</filename>, che dovrebbe contenere il file
      <filename>chmod.txt</filename>.</para>

    <para>In particolare potresti voler creare un file con l'output di
      <filename>/sbin/dmesg</filename> digitando</para>

    <informalexample>
      <screen>&prompt.user; <userinput>/sbin/dmesg &gt; dmesg.txt</userinput></screen>
    </informalexample>

    <para>e copiare <filename>dmesg.txt</filename> sul floppy.
      <command>/sbin/dmesg</command> &egrave; il file di log di avvio, ed
      &egrave; importante comprenderlo perch&eacute; ti mostra cosa ha trovato
      FreeBSD all'avvio.  Se poni delle domande sulla &a.questions;
      o su un gruppo USENET&mdash;del tipo <quote>FreeBSD non trova il mio drive
        per i nastri, che cosa faccio?</quote>&mdash;la gente vorr&agrave;
      sapere cosa mostra il tuo <command>dmesg</command>.</para>

    <para>Ora devi smontare il floppy (da <username>root</username>) per poter
      togliere il disco</para>

    <informalexample>
      <screen>&prompt.root; <userinput>/sbin/umount /mnt</userinput></screen>
    </informalexample>

    <para>e riavviare per tornare in DOS.  Copia questo file in una
      directory DOS, richiamali con l'EDIT del DOS, Notepad o Wordpad di
      &windows;, o un editor di testi, fai una piccola modifica in modo che
      il file debba essere salvato, e stampa come faresti da DOS o
      &windows;.  Spera che funzioni!  Le pagine man vengono meglio se
      stampate con il comando DOS <command>print</command>.  (Copiare i file
      da FreeBSD su una partizione DOS montata &egrave; ancora in alcuni casi
      rischioso.)</para>

    <para>Far funzionare la stampante sotto FreeBSD consiste nel creare
      un opportuno elemento in <filename>/etc/printcap</filename> e
      creare una directory di spool corrispondente in
      <filename>/var/spool/output</filename>.  Se la tua stampante &egrave; su
      <hardware>lpt0</hardware> (ci&ograve; che DOS chiama
      <hardware>LPT1</hardware>), devi solo andare in
      <filename>/var/spool/output</filename> e (da <username>root</username>)
      creare la directory <filename>lpd</filename> digitando: <command>mkdir
        lpd</command>, se non &egrave; gi&agrave; presente.  A quel punto la
      stampante dovrebbe rispondere quando il sistema parte, e
      <command>lp</command> o <command>lpr</command> dovrebbero mandare un
      file alla stampante.  Che il file venga stampato o meno &egrave; solo
      questione di configurazione, che &egrave; discussa nel <ulink
        URL="../../books/handbook/index.html">Manuale di FreeBSD</ulink>.</para>
  </sect1>

  <sect1>
    <title>Altri Comandi Utili</title>

    <variablelist>
      <varlistentry>
        <term><command>df</command></term>

        <listitem>
          <para>mostra lo spazio disponibile e tutte le partizioni
            montate.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><command>ps aux</command></term>

        <listitem>
          <para>mostra i processi in esecuzione.  <command>ps ax</command>
            &egrave; una forma contratta.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><command>rm <replaceable>nomefile</replaceable></command></term>

        <listitem>
          <para>cancella <replaceable>nomefile</replaceable>.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><command>rm -R <replaceable>dir</replaceable></command></term>

        <listitem>
          <para>cancella la directory <replaceable>dir</replaceable> e tutte le
            sottodirectory&mdash;attenzione!</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><command>ls -R</command></term>

        <listitem>
          <para>mostra il contenuto della directory e delle sue
            sottodirectory; io usavo una variante, <command>ls -AFR &gt;
              where.txt</command>, per avere una lista dei file in
            <filename>/</filename> e (separatamente)
            <filename>/usr</filename> prima che scoprissi dei metodi migliori
            per cercare i file.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><command>passwd</command></term>

        <listitem>
          <para>per cambiare la password dell'utente (o di
            <username>root</username>)</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><command>man hier</command></term>

        <listitem>
          <para>pagina man sul file system di &unix;</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>Usa <command>find</command> per trovare <filename>nomefile</filename>
      in <filename>/usr</filename> o nelle sue sottodirectory digitando</para>

    <informalexample>
      <screen>&prompt.user; <userinput>find /usr -name "<replaceable>nomefile</replaceable>"</userinput></screen>
    </informalexample>

    <para>Puoi usare <literal>*</literal> come identificatore universale in
      <parameter>"<replaceable>nomefile</replaceable>"</parameter>
      (che dovrebbe essere tra virgolette).  Se dici a
      <command>find</command> di cercare in <filename>/</filename>
      anzich&eacute; <filename>/usr</filename> cercher&agrave; il/i file su
      tutti i file system montati, inclusi i CDROM e le partizioni DOS.</para>

    <para>Un libro eccellente che tratta i comandi e le utility di &unix;
      &egrave; <citetitle>Unix for the Impatient</citetitle> di Abrahams &amp;
      Larson (2nd ed., Addison-Wesley, 1996).
      Ci sono anche un sacco di informazioni su &unix; su Internet.</para>
  </sect1>

  <sect1>
    <title>Prossimi Passi</title>

    <para>Dovresti ora avere gli strumenti necessari per girare nel sistema e
      modificare i file, cos&igrave; da poter rendere tutto funzionante.  Ci
      sono un sacco di informazioni nel Manuale di FreeBSD (che &egrave;
      probabilmente sul tuo disco rigido) e sul <ulink
      URL="../../../../index.html">sito web di FreeBSD</ulink>.  Una
      grande scelta di package e port &egrave; presente sul CDROM cos&igrave;
      come sul sito web.  Il manuale ti spiega come usarli
      (prendi il package se esiste, con <command>pkg_add
      /cdrom/packages/All/<replaceable>nomepackage</replaceable></command>,
      dove <replaceable>nomepackage</replaceable> &egrave; il nome del file del
      package).  Il CDROM ha una lista di package e di port
      con delle brevi descrizioni in <filename>cdrom/packages/index</filename>,
      <filename>cdrom/packages/index.txt</filename>, e
      <filename>cdrom/ports/index</filename>, e con descrizioni pi&ugrave; ampie
      in <filename>/cdrom/ports/*/*/pkg/DESCR</filename>, dove
      <literal>*</literal> rappresenta rispettivamente sottodirectory di tipi di
      programmi e nomi di programmi.</para>

    <para>Se trovi il manuale troppo difficile su come installare i port dal
      CDROM (con il sistema di <command>lndir</command> e altro), ecco come
      funziona normalmente:</para>

    <para>Trova il port che vuoi, supponiamo <command>kermit</command>.
      Ci sar&agrave; una directory per lui sul CDROM.  Copia la
      sottodirectory in <filename>/usr/local</filename> (un buon posto
      perch&eacute; il software che aggiungi sia disponibile a tutti gli utenti)
      con:</para>

    <informalexample>
      <screen>&prompt.root; <userinput>cp -R /cdrom/ports/comm/kermit /usr/local</userinput></screen>
    </informalexample>

    <para>Questo dovrebbe portarti ad avere la sottodirectory
      <filename>/usr/local/kermit</filename> che contiene tutti i file
      presenti nella sottodirectory <command>kermit</command> del CDROM.</para>

    <para>Ora, crea la directory
      <filename>/usr/ports/distfiles</filename> se non esiste ancora,
      usando <command>mkdir</command>.  Poi controlla
      <filename>/cdrom/ports/distfiles</filename> cercando un file
      con il nome che indica che si tratta del port esatto.  Copia quel file in
      <filename>/usr/ports/distfiles</filename>; nelle versioni pi&ugrave;
      recenti puoi saltare questo passo, perch&eacute; FreeBSD lo far&agrave;
      per te.  Nel caso di <command>kermit</command>, non c'&egrave; nessun
      distfile.</para>

    <para>Quindi entra con <command>cd</command> nella sottodirectory di
      <filename>/usr/local/kermit</filename> che contiene il file
      <filename>Makefile</filename>.  Digita</para>

    <informalexample>
      <screen>&prompt.root; <userinput>make all install</userinput></screen>
    </informalexample>

    <para>Durante questo processo il port user&agrave; FTP per scaricare
      i file compressi che non ha trovato sul CDROM o in
      <filename>/usr/ports/distfiles</filename>.  Se la tua connessione
      non funziona ancora e non c'&egrave; nessun file per il port in
      <filename>/cdrom/ports/distfiles</filename>, dovrai
      recuperare il distfile usando un'altra macchina e poi copiarlo in
      <filename>/usr/ports/distfiles</filename> da un dischetto o dalla
      partizione DOS.  Leggi <filename>Makefile</filename> (usando
      <command>cat</command> o <command>more</command> oppure
      <command>view</command>) per scoprire dove andare (il sito principale
      di distribuzione) per trovare il file e conoscere il suo nome.  Il nome
      verr&agrave; troncato quando scaricato da DOS, e dopo averlo trasferito
      in <filename>/usr/ports/distfiles</filename> dovrai
      rinominarlo (usando il comando <command>mv</command>) nel suo
      nome originale cosicch&eacute; possa essere trovato.  (Usa il
      trasferimento di file binario!)
      Quindi torna in <filename>/usr/local/kermit</filename>, trova la
      directory contenente <filename>Makefile</filename>, e digita
      <command>make all install</command>.</para>

    <para>Un'altra cosa che pu&ograve; succedere quando si installa un port o un
      package &egrave; che questi abbiano bisogno di un altro programma.  Se
      l'installazione si ferma con un messaggio <errorname>can't find
        unzip</errorname> o simile, potresti dover installare il
      package o il port di unzip prima di proseguire.</para>

    <para>Una volta installato, digita <command>rehash</command> per far
      s&igrave; che FreeBSD rilegga i file contenuti nel path e sappia quali
      sono presenti.
      (Se trovi un sacco di messaggi <errorname>path not found</errorname>
      quando usi <command>whereis</command> o which, dovresti
      fare delle aggiunte all'elenco delle directory nel
      file <filename>.cshrc</filename> nella tua directory home.
      L'elenco dei path in &unix; fa la stessa
      cosa che fa in DOS, tranne che la directory corrente (di
      default) non si trova nel path per ragioni di sicurezza; se il comando
      che vuoi eseguire &egrave; nella directory in cui ti trovi, devi digitare
      <filename>./</filename> prima del nome del comando; niente
      spazio dopo la barra.)</para>

    <para>Potresti volere la versione pi&ugrave; recente di &netscape;
      dal loro <ulink URL="ftp://ftp.netscape.com/">sito FTP</ulink>.
      (&netscape; necessita dell'X Window System.)  Ora c'&eacute; una versione
      per FreeBSD, quindi d&agrave; un'occhiata in giro.  Usa solo
      <command>gunzip <replaceable>nomefile</replaceable></command> e
      <command>tar xvf <replaceable>nomefile</replaceable></command> sul file,
      sposta il binario in <filename>/usr/local/bin</filename> o qualche altro
      posto in cui vengono tenuti i binari, esegui <command>rehash</command>, e
      quindi aggiungi le seguenti linee a <filename>.cshrc</filename> in tutte
      le directory home degli utenti oppure (pi&ugrave; semplicemente) in
      <filename>/etc/csh.cshrc</filename>, il file di configurazione globale di
      <command>csh</command>:</para>

    <informalexample>
      <programlisting>setenv XKEYSYMDB /usr/X11R6/lib/X11/XKeysymDB
setenv XNLSPATH /usr/X11R6/lib/X11/nls</programlisting>
    </informalexample>

    <para>Questo assume che il file <filename>XKeysymDB</filename>
      e la directory <filename>nls</filename> siano in
      <filename>/usr/X11R6/lib/X11</filename>; se non lo sono, trovale
      e mettile l&igrave;.</para>

    <para>Se hai originariamente installato &netscape; dal CDROM (o via
      FTP), non sostituire <filename>/usr/local/bin/netscape</filename>
      con il nuovo binario di netscape; questo &egrave; solo uno script di shell
      che imposta le variabili di ambiente per te.  Rinomina invece
      il nuovo binario in <filename>netscape.bin</filename> e rimpiazza il
      vecchio binario, che dovrebbe essere
      <filename>/usr/local/netscape/netscape</filename>.</para>
  </sect1>

  <sect1>
    <title>Il tuo Ambiente di Lavoro</title>

    <para>La shell &egrave; la parte pi&ugrave; importante del tuo ambiente
      di lavoro.  In DOS, la shell &egrave; solitamente command.com.  La shell
      &egrave; ci&ograve; che interpreta i comandi che digiti sulla linea di
      comando, e quindi comunica con il resto del sistema operativo.
      Puoi anche scrivere script di shell, che sono come i file batch di
      DOS: una serie di comandi che devono essere eseguiti senza il tuo
      intervento.</para>

    <para>Due shell vengono normalmente installate con FreeBSD:
      <command>csh</command> e <command>sh</command>.
      <command>csh</command> &egrave; buona per lavoro da linea di comando, ma
      gli script dovrebbero essere scritti usando <command>sh</command> (o
      <command>bash</command>).  Puoi scoprire che shell hai
      digitando <command>echo $SHELL</command>.</para>

    <para><command>csh</command> &egrave; una buona shell, ma
      <command>tcsh</command> fa tutto ci&ograve; che <command>csh</command>
      fa e anche altro.  Ti permette di richiamare i comandi usando
      le frecce e ti permette di modificarli.  Ha l'auto-completamento dei nomi
      di file con tab (<command>csh</command> usa <keycap>Esc</keycap>), e
      ti permette di tornare alla directory in cui eri digitando
      <command>cd -</command>.  &Egrave; anche pi&ugrave; semplice alterare il
      prompt con <command>tcsh</command>.  Ti rende la vita pi&ugrave;
      facile.</para>

    <para>Ecco tre semplici passi per installare una nuova shell:</para>

    <procedure>
      <step>
        <para>Installa la shell tramite port o package, come faresti
          con un qualsiasi altro port o package.  Usa
          <command>rehash</command> e <command>which tcsh</command>
          (assumendo che tu stia installando <command>tcsh</command>) per
          essere sicuro di averla installata.</para>
      </step>

      <step>
        <para>Da <username>root</username>, modifica
          <filename>/etc/shells</filename>, aggiungendo una riga nel file per
          la nuova shell, in questo caso
          <filename>/usr/local/bin/tcsh</filename>, e salva il file.
          (Alcuni port lo fanno per te.)</para>
      </step>

      <step>
        <para>Usa il comando <command>chsh</command> per cambiare
          permanentemente la tua shell in <command>tcsh</command>, o digita
          <command>tcsh</command> al prompt per cambiare la shell senza
          dover uscire dal sistema per poi rientrare.</para>
      </step>
    </procedure>

    <note>
      <para>Pu&ograve; essere pericoloso cambiare la shell di
        <username>root</username> in qualcosa di diverso da
        <command>sh</command> o <command>csh</command> su versioni pi&ugrave;
        recenti di FreeBSD e di &unix;; potresti non avere una shell
        funzionante se il sistema entra in modalit&agrave; singolo utente.
        La soluzione &egrave; usare <command>su -m</command> per diventare
        <username>root</username>, che ti d&agrave; <command>tcsh</command> come
        shell di <username>root</username>, poich&eacute; la shell &egrave;
        parte del tuo ambiente.  Puoi rendere tutto ci&ograve; permanente
        aggiungendo al tuo <filename>.tcshrc</filename> un alias con:</para>
        <programlisting>alias su su -m</programlisting>
    </note>

    <para>Quando <command>tcsh</command> parte, legge i file
      <filename>/etc/csh.cshrc</filename> e
      <filename>/etc/csh.login</filename>, come farebbe
      <command>csh</command>.  Legger&agrave; anche il file
      <filename>.login</filename> nella tua directory home ed anche
      <filename>.cshrc</filename>, a meno che tu non abbia un file
      <filename>.tcshrc</filename>.  Puoi crearlo copiando
      <filename>.cshrc</filename> in <filename>.tcshrc</filename>.</para>

    <para>Ora che hai installato <command>tcsh</command>, puoi sistemare
      il tuo prompt.  Puoi trovare i dettagli nella pagina man di
      <command>tcsh</command>, ma ecco qui una linea da mettere nel tuo
      <filename>.tcshrc</filename> che ti dir&agrave; quanti comandi hai
      digitato, che ore sono, e in che directory
      ti trovi.  Produce anche un <literal>></literal> se sei un
      utente normale e un <literal>#</literal> se sei <username>root</username>,
      ma <command>tcsh</command> lo farebbe in ogni caso:</para>

    <para>set prompt = "%h %t %~ %# "</para>

    <para>Questa dovrebbe andare nella stessa posizione della linea di
      prompt corrente se ce n'&egrave; una, o sotto "if($?prompt) then" in caso
      contrario.  Commenta la vecchia riga; cos&igrave; potrai tornare a quella
      vecchia se la preferirai.  Non dimenticare gli spazi e le virgolette.
      Puoi far rileggere <filename>.tcshrc</filename> digitando
      <command>source .tcshrc</command>.</para>

    <para>Puoi avere una lista delle variabili di sistema che sono state
      impostate digitando <command>env</command> al prompt.
      Il risultato ti mostrer&agrave; il tuo editor di default, il pager, e il
      tipo di terminale, tra le altre possibili variabili.  Un comando
      utile se ti connetti al sistema da una postazione remota e non riesci ad
      eseguire un programma perch&eacute; il terminale non ne &egrave; capace
      &egrave; <command>setenv TERM vt100</command>.</para>
  </sect1>

  <sect1>
    <title>Altro</title>

    <para>Da <command>tcsh</command> puoi smontare il CDROM con
      <command>/sbin/umount /cdrom</command>, toglilo dal lettore,
      inseriscine un altro, e montalo con
      <command>/sbin/mount_cd9660 /dev/cd0a /cdrom</command> assumendo che
      <hardware>cd0a</hardware> sia il nome di dispositivo del tuo lettore di
      CDROM.  La versione pi&ugrave; recente di FreeBSD ti permette di montare
      il CDROM solo con <command>/sbin/mount /cdrom</command>.</para>

    <para>Usare il <quote>live file system</quote>&mdash;il secondo cd del set
      di FreeBSD&mdash;&egrave;
      utile se hai poco spazio a disposizione.  Ci&ograve; che si trova
      sul live file system cambia da release a release.  Potresti
      provare ad eseguire dei giochi dal CDROM.  Questo comporta l'uso di
      <command>lndir</command>, che viene installato con l'X Window
      System, per dire ai programmi dove trovare i file necessari, poich&eacute;
      questi si trovano nel file system <filename>/cdrom</filename>
      anzich&eacute; <filename>/usr</filename> e le sue
      sottodirectory, che &egrave; dove dovrebbero essere.  Leggi
      <command>man lndir</command> per avere pi&ugrave; informazioni.</para>
  </sect1>

  <sect1>
    <title>I Commenti sono Benvenuti</title>

    <para>Se usi questa guida, sarei interessata a sapere dove non &egrave;
      chiara, ci&ograve; che &egrave; stato tralasciato e che vorresti venisse
      incluso, e sapere se tutto ci&ograve; &egrave; stato utile.  I miei
      ringraziamenti vanno a Eugene W. Stark, professore di informatica a
      SUNY-Stony Brook, e John Fieber per i suoi utili commenti.</para>

    <para>Annelise Anderson, <email>andrsn@andrsn.stanford.edu</email></para>

    <para>Per questioni legate alla traduzione, o se avete commenti da poter
      esprimere solo in italiano, non esitate a contattarmi.  Come per l'autrice
      originale, ogni genere di commenti &egrave; ben accetto.</para>

    <para>Massimiliano Stucchi, <email>stucchi@willystudios.com</email></para>
  </sect1>
</article>
