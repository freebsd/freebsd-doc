<!--
     The FreeBSD Documentation Project
     The FreeBSD Chinese Documentation Project

     Original Revision: 1.164
     $FreeBSD$
-->

<chapter id="kernelconfig">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Jim</firstname>
	<surname>Mock</surname>
	<contrib>Updated and restructured by </contrib>
	<!-- Mar 2000 -->
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Jake</firstname>
	<surname>Hamby</surname>
	<contrib>Originally contributed by </contrib>
	<!-- 6 Oct 1995 -->
      </author>
    </authorgroup>
  </chapterinfo>

  <title>配置FreeBSD的内核</title>

  <sect1 id="kernelconfig-synopsis">
    <title>概述</title>

    <indexterm>
      <primary>内核</primary>
      <secondary>建立一个定制的内核</secondary>
    </indexterm>

    <para>内核是 &os; 操作系统的核心。 它负责管理内存、 执行安全控制、
    网络、 磁盘访问等等。 尽管 &os; 可以动态修改的现在已经越来越多，
    但有时您还是需要重新配置和编译您的内核。</para>

    <para>读完这章，您将了解：</para>

    <itemizedlist>
      <listitem>
	<para>为什么需要建立定制的内核。</para>
      </listitem>

      <listitem>
	<para>如何编写内核配置文件，或修改已存在的配置文件。</para>
      </listitem>

      <listitem>
	<para>如何使用内核配置文件创建和联编新的内核。</para>
      </listitem>

      <listitem>
	<para>如何安装新内核。</para>
      </listitem>

      <listitem>
	<para>如何在 <filename>/dev</filename> 中创建设备节点。</para>
      </listitem>

      <listitem>
	<para>如何出现问题怎么办。</para>
      </listitem>
    </itemizedlist>

    <para>这一章给出的命令应该以 <username>root</username> 身份执行，
      否则可能会不成功。</para>
  </sect1>

  <sect1 id="kernelconfig-custom-kernel">
    <title>为什么需要建立定制的内核?</title>

    <para>过去， &os; 采用称作 <quote>单片式</quote> 的内核。
      这句话的意思是说内核是一个大的程序， 支持固定的设备，
      如果您希望改变内核的行为则必须编译一个新的，
      并重新启动计算机来引导它。</para>

    <para>今天， &os; 已经迅速地转移到了一个新的模型，
      其重要特征是内核功能可以由能够根据需要动态加载和卸载的模块来提供。
      这是的内核能够迅速地适应硬件的调整 (例如笔记本电脑的 PCMICA)，
      或为内核增加在最初编译它时所不具备的新的功能。
      这一模式成为模块化内核。</para>

    <para>尽管如此， 一些功能仍然需要静态地连编进内核。
      一些情况是因为这些功能于内核的结合十分紧密，
      而不可能将它们做成可以动态加载的。
      另一种情况是因为没有人有时间来编写实现那个功能的可以动态加载的内核模块。</para>

    <para>建造定制的内核是几乎每一个 BSD 用户所必须经历的一关。
      尽管这项工作可能比较耗时， 但它能够为使用 &os; 系统带来很多好处。
      与必须支持大量各式硬件的 <filename>GENERIC</filename>
      内核不同， 定制的内核可以只包含对于
      <emphasis>您的</emphasis> PC 硬件的支持。
      这有很多好处， 例如：</para>

    <itemizedlist>
      <listitem>
	<para>更快地启动。 因为内核只需要检测您系统上的硬件，
	启动时所花费的时间将大大缩短。</para>
      </listitem>

      <listitem>
	<para>使用更少的内存。 定制的内核通常会比
	  <filename>GENERIC</filename> 内核使用更少的内存，
	  由于内核必须时刻处于物理内存中， 因此这就显得更加重要。
	  基于这样的原因， 对于内存较小的系统来说，
	  定制内核将发挥更大的作用。</para>
      </listitem>

      <listitem>
	<para>支持更多的硬件。 定制的内核允许您增加类似声卡这样的
	  <filename>GENERIC</filename> 内核没有提供内建支持的硬件。</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="kernelconfig-building">
    <title>建立并安装一个定制的内核</title>
    <indexterm>
      <primary>内核</primary>
      <secondary>建立/安装</secondary>
    </indexterm>

    <para>首先对内核构建目录做一个快速的浏览。
      这里所提到的所有目录都在
      <filename>/usr/src/sys</filename> 目录中； 也可以通过
      <filename>/sys</filename> 来访问它。
      这里的众多子目录包含了内核的不同部分，
      但对我们所要完成的任务最重要的目录是
      <filename><replaceable>arch</replaceable>/conf</filename>，
      您将在这里编辑定制的内核配置； 以及
      <filename>compile</filename>， 编译过程中的文件将放置在这里。
      <replaceable>arch</replaceable> 表示
      <filename>i386</filename>、 <filename>alpha</filename>、
      <filename>amd64</filename>、 <filename>ia64</filename>、
      <filename>powerpc</filename>、 <filename>sparc64</filename>， 或
      <filename>pc98</filename> (在日本比较流行的另一种
      PC 硬件开发分支)。 在特定硬件架构目录中的文件只和特定的硬件有关；
      而其余代码则是与机器无关的， 则所有已经或将要移植并运行 &os;
      的平台上都共享这些代码。
      文件目录是按照逻辑组织的， 所支持的硬件设备、
      文件系统， 以及可选的组件通常都在它们自己的目录中。
      5.X 版之前的 &os; 只支持
      <filename>i386</filename>、 <filename>alpha</filename>
      和 <filename>pc98</filename> 这三种硬件架构。</para>

    <para>这一章提供的例子假定您使用 i386 架构的计算机。
      如果您的情况不是这样， 只需对目录名作相应的调整即可。</para>

    <note>
      <para>如果您的系统中 <emphasis>没有</emphasis>
	<filename>/usr/src/sys</filename> 这样一个目录，
	则说明没有安装内核源代码。 安装它最简单的方法是通过以 root 身份运行
	<command>sysinstall</command> (对于 &os; 5.2
	之前的版本， 则是 <command>/stand/sysinstall</command>)， 选择
	<guimenuitem>Configure</guimenuitem>， 然后
	<guimenuitem>Distributions</guimenuitem>， 然后
	<guimenuitem>src</guimenuitem>，
	<guimenuitem>sys</guimenuitem>。 如果您不喜欢
	<application>sysinstall</application> 并且可以使用
	<quote>官方的</quote> &os; CDROM， 则也可以通过命令行来安装：</para>

      <screen>&prompt.root; <userinput>mount /cdrom</userinput>
&prompt.root; <userinput>mkdir -p /usr/src/sys</userinput>
&prompt.root; <userinput>ln -s /usr/src/sys /sys</userinput>
&prompt.root; <userinput>cat /cdrom/src/ssys.[a-d]* | tar -xzvf -</userinput></screen>
</note>

    <para>接下来， 进入 <filename><replaceable>arch</replaceable>/conf</filename>
	目录下面， 复制 <filename>GENERIC</filename> 配置文件，
	并给这个文件起一个容易辨认的名称， 它就是您的内核名称。例如：</para>
    <screen>&prompt.root; <userinput>cd /usr/src/sys/<replaceable>i386</replaceable>/conf</userinput>
&prompt.root; <userinput>cp GENERIC MYKERNEL</userinput></screen>

    <para>通常，这个名称是大写的，如果您正维护着多台不同硬件的&os;机器，
    以您机器的域名来命名是非常好的主意。我们把它命名为<filename>MYKERNEL</filename>就是这个原因。
    </para>

    <tip>
      <para>将您的内核配置文件直接保存在
	<filename>/usr/src</filename> 可能不是一个好主意。
	如果您遇到问题， 删掉
	<filename>/usr/src</filename> 并重新开始很可能是一个诱人的选择。
	一旦开始做这件事，
	您可能几秒钟之后才会意识到您同时会删除定制的内核配置文件。
	另外， 也不要直接编辑 <filename>GENERIC</filename>，
	因为下次您
	<link linkend="cutting-edge">更新代码</link> 时它会被覆盖，
	而您的修改也就随之丢失了。</para>

      <para>您也可以考虑把内核配置文件放到别的地方，
	然后再到 <filename><replaceable>i386</replaceable></filename>
	目录中创建一个指向它的符号链接。</para>

      <para>例如：</para>

      <screen>&prompt.root; <userinput>cd /usr/src/sys/<replaceable>i386</replaceable>/conf</userinput>
&prompt.root; <userinput>mkdir /root/kernels</userinput>
&prompt.root; <userinput>cp GENERIC /root/kernels/<replaceable>MYKERNEL</replaceable></userinput>	
&prompt.root; <userinput>ln -s /root/kernels/<replaceable>MYKERNEL</replaceable></userinput></screen>
    </tip>

    <note>
      <para>必须以 <username>root</username> 身份执行这些和接下来命令，
	否则就会得到 <errortype>permission denied</errortype> 的错误提示。
      </para>
    </note>

    <para>现在就可以用您喜欢的文本编辑器来编辑 <filename>MYKERNEL</filename> 了。
      如果您刚刚开始使用 FreeBSD， 唯一可用的编辑器很可能是
      <application>vi</application>， 它的使用比较复杂， 限于篇幅，
      这里不予介绍， 您可以在 <link
      linkend="bibliography">参考书目</link> 一章中找到很多相关书籍。
      不过， &os; 也提供了一个更好用的编辑器，
      它叫做 <application>ee</application>， 对于新手来说，
      这很可能是一个不错的选择。
      您可以修改配置文件中的注释以反映您的配置，
      或其他与 <filename>GENERIC</filename> 不同的地方。</para>
    <indexterm><primary>SunOS</primary></indexterm>

    <para>如果您在&sunos;或者其他BSD系统下定制过内核，那这个文件中的绝大部分将对您非常熟悉。
     如果您使用的是诸如DOS这样的系统，那<filename>GENERIC</filename>配置文件看起来就非常困难，
     所以在下面的 <link linkend="kernelconfig-config">配置文件</link>章节将慢慢地、仔细地进行介绍。
      </para>

    <note>
      <para>如果您和 &os; project 进行了 <link
        linkend="cutting-edge">代码同步</link>，
        则一定要在进行任何更新之前查看
        <filename>/usr/src/UPDATING</filename>。
        这个文件中描述了更新过的代码中出现的重大问题或需要注意的地方。
        <filename>/usr/src/UPDATING</filename> 总是和您的
        &os; 源代码对应， 因此能够提供比手册更具时效性的新内容。</para>
    </note>

    <para>现在应该编译内核的源代码了。 一共有两种方法来完成这项工作，
      使用哪一种取决于您为什么要重新编译内核， 以及所运行的 &os;
      版本。</para>

    <itemizedlist>
      <listitem>
	<para>如果您<emphasis>只</emphasis>安装内核源代码，使用方法1。
	</para>
      </listitem>

      <listitem>
	<para> 如果您在没有升级源代码的情况下编译一个新内核（也许您只想为内核添加一个新的选项，
	如<literal>IPFIREWALL</literal>），可以使用任何一种方法。
	  </para>
      </listitem>

      <listitem>
	<para>如果您打算把重新构建内核作为
          <command>make buildworld</command> 过程的一部分来进行， 则应使用方法 2。
        </para>
      </listitem>
    </itemizedlist>
    
    <indexterm>
      <primary><command>cvsup</command></primary>
    </indexterm>
    <indexterm><primary>CTM</primary></indexterm>
    <indexterm>
      <primary>CVS</primary>
      <secondary>匿名</secondary>
    </indexterm>

    <para>如果从上次成功地完成 <maketarget>buildworld</maketarget>-<maketarget>installworld</maketarget>
      以来您还 <emphasis>没有</emphasis> 升级过代码
      (也就是没有运行 <application>CVSup</application>、
      <application>CTM</application>， 或使用
      <application>anoncvs</application>)， 则可以放心使用
      <command>config</command>、 <command>make depend</command>、
      <command>make</command>、 <command>make install</command>。
    </para>

    <procedure>
      <title>方法1. 用<quote>传统</quote>方法建立一个内核</title>
      
      <step>
	<para>运行&man.config.8;来产生内核源代码。</para>
	
	<screen>&prompt.root; <userinput>/usr/sbin/config <replaceable>MYKERNEL</replaceable></userinput></screen>
      </step>

      <step>
	<para>进入编译内核的目录。 &man.config.8; 将在像上面一样显示执行它所在的目录的名字。</para>

	<screen>&prompt.root; <userinput>cd ../compile/<replaceable>MYKERNEL</replaceable></userinput></screen>

	<para>对于 &os; 5.0 以及更早的版本， 使用下面的形式：</para>

	<screen>&prompt.root; <userinput>cd ../../compile/<replaceable>MYKERNEL</replaceable></userinput></screen>
      </step>

      <step>
	<para>编译内核。</para>
	
	<screen>&prompt.root; <userinput>make depend</userinput>
&prompt.root; <userinput>make</userinput></screen>
      </step>

      <step>
	<para>安装新内核。</para>
	
	<screen>&prompt.root; <userinput>make install</userinput></screen>
      </step>
    </procedure>

    <procedure>
      <title>方法2. 用<quote>新的</quote>方法建立一个内核</title>
      
      <step>
	<para>切换到<filename>/usr/src</filename> 目录。</para>
	
	<screen>&prompt.root; <userinput>cd /usr/src</userinput></screen>
      </step>

      <step>
	<para>编译内核。</para>
	
	<screen>&prompt.root; <userinput>make buildkernel KERNCONF=<replaceable>MYKERNEL</replaceable></userinput></screen>
      </step>

      <step>
	<para>安装新内核。</para>

	<screen>&prompt.root; <userinput>make installkernel KERNCONF=<replaceable>MYKERNEL</replaceable></userinput></screen>
      </step>
    </procedure>
    
    <note>
      <para>使用这种方法构建内核， 需要完整的源代码。
	如果您只安装了内核的源代码， 就只能使用前面所介绍的传统方法了。</para>
    </note>

    <tip>
      <para>默认情况下， 在联编您所定制的内核时，
	<emphasis>全部</emphasis> 内核模块也会同时参与构建。
	如果您希望更快地升级内核， 或者只希望联编您所需要的模块，
	则应在联编之前编辑 <filename>/etc/make.conf</filename>：</para>

      <programlisting>MODULES_OVERRIDE = linux acpi sound/sound sound/driver/ds1 ntfs</programlisting>

      <para>这个变量的内容是所希望构建的模块列表。
	如果希望了解更多与构建内核有关的变量， 请参见 &man.make.conf.5;
	联机手册。</para>
    </tip>

    <indexterm>
      <primary><filename class="directory">/boot/kernel.old</filename></primary>
    </indexterm> 

    <para>新内核将会被复制到 <filename
        class="directory">/boot/kernel</filename> 目录中成为
      <filename>/boot/kernel/kernel</filename> 而旧的则被移到
      <filename>/boot/kernel.old/kernel</filename>。
      现在关闭系统， 然后用新的内核启动计算机。 如果出现问题，
      后面的一些 <link linkend="kernelconfig-trouble">故障排除方法</link>
      将帮您摆脱困境。 如果您的内核 <link
      linkend="kernelconfig-noboot">无法启动</link>， 请参考那一节。</para>

    <note>
      <para>其他与启动过程相关的文件， 如
	&man.loader.8; 及其配置， 则放在
	<filename>/boot</filename>。 第三方或定制的模块也可以放在
	<filename class="directory">/boot/kernel</filename>，
	不过应该注意保持模块和内核的同步时很重要的，
	否则会导致不稳定和错误。</para>
    </note>
  </sect1>

  <sect1 id="kernelconfig-config">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Joel</firstname>
	  <surname>Dahl</surname>
	  <contrib>Updated for &os; 5.X by </contrib>
	  <!-- August 2004, PR docs/70674 -->
	</author>
	<!--  <editor><othername role="freefall login">ceri</othername></editor> -->
      </authorgroup>
    </sect1info>
    <title>配置文件</title>
    <indexterm>
      <primary>内核</primary>
      <secondary>NOTES</secondary>
    </indexterm>
    <indexterm><primary>NOTES</primary></indexterm>
    <indexterm>
      <primary>内核</primary>
      <secondary>配置文件</secondary>
    </indexterm>

    <para>配置文件的格式是非常简单的。
      每一行都包括一个关键词， 以及一个或多个参数。
      实际上， 绝大多数行都只包括一个参数。
      在 <literal>#</literal> 之后的内容会被认为是注释而忽略掉。
      接下来几节, 将以 <filename>GENERIC</filename> 中的顺序介绍所有关键字。
      <anchor
      id="kernelconfig-options"> 如果需要与平台有关的选项和设备的详细列表，
      请参考与 <filename>GENERIC</filename> 在同一个目录中的那个<filename>NOTES</filename>，
      而平台无关的选项， 则可以在
      <filename>/usr/src/sys/conf/NOTES</filename>
      找到。</para>

    <note>
      <para>如果您需要一份包含所有选项的文件，
	例如用于测试目的， 则应以 <username>root</username> 身份执行下列命令：</para>

      <screen>&prompt.root; <userinput>cd /usr/src/sys/<replaceable>i386</replaceable>/conf &amp;&amp; make LINT</userinput></screen>
    </note>

    <indexterm>
      <primary>内核</primary>
      <secondary>配置文件</secondary>
    </indexterm>

    <para>下面是一个 <filename>GENERIC</filename>
      内核配置文件的例子， 它包括了一些需要解释的注释。
      这个例子应该和您复制的
      <filename>/usr/src/sys/<replaceable>i386</replaceable>/conf/GENERIC</filename>
      非常接近。</para>

    <indexterm>
      <primary>内核选项</primary>
      <secondary>机器</secondary>
    </indexterm>

    <programlisting>machine		i386</programlisting>

    <para>这是机器的架构， 他只能是
      <literal>alpha</literal>, <literal>amd64</literal>,
      <literal>i386</literal>, <literal>ia64</literal>,
      <literal>pc98</literal>, <literal>powerpc</literal>, 或
      <literal>sparc64</literal> 中的一种。</para>

    <indexterm>
      <primary>内核选项</primary>
      <secondary>cpu</secondary>
    </indexterm>
    <programlisting>cpu          I486_CPU
cpu          I586_CPU
cpu          I686_CPU</programlisting>

    <para>上面的选项指定了您系统中所使用的 CPU 类型。
      您可以使用多个 CPU 类型 (例如，
      您不确定是应该指定
      <literal>I586_CPU</literal> 或 <literal>I686_CPU</literal>)。
      然而对于定制的内核， 最好能够只指定您使用的那种 CPU。
      如果您对于自己使用的 CPU 类型没有把握， 可以通过查看
      <filename>/var/run/dmesg.boot</filename> 中的启动信息来了解。</para>

    <indexterm>
      <primary>内核选项</primary>
      <secondary>cpu类型</secondary>
    </indexterm>
    <para>在&os;的内核里面仍然支持<literal>I386_CPU</literal>，但是在-STABLE和
      -CURRENT里面缺省已经被禁用了。这就意味着安装&os;在386-class的cpu， 
      一般有下面几种情况：</para>

    <itemizedlist>
      <listitem>
        <para>安装一个老的&os; release并且按照<xref linkend="kernelconfig-building">从源码重建系统.</para>
      </listitem>

      <listitem>
        <para>在一个新的机器上构建用户和内核程序，然后用已经编译好的<filename>/usr/obj</filename>下的文件
	安装到386的机器上(详细情况看<xref linkend="small-lan">)。</para>
      </listitem>

      <listitem>
        <para>定制您自己的 &os; 发行版本， 其中的安装光盘包含
          <literal>I386_CPU</literal> 支持。</para>
      </listitem>
    </itemizedlist>

    <para>第一种情况可能是最容易的， 但您需要大量的磁盘空间，
      而 386-级别拥有这种配置的计算机可能很难找到。</para>

    <indexterm>
      <primary>内核选项</primary>
      <secondary>ident</secondary>
    </indexterm>

    <programlisting>ident          GENERIC</programlisting>

    <para>这是内核的名字。 您应该取一个自己的名字，
      例如取名叫 <literal>MYKERNEL</literal>，
      如果您一直在按照前面的说明做的话。
      您放在
      <literal>ident</literal> 后面的字符串在启动内核时会显示出来，
      因此如果希望能够容易区分常用的内核和刚刚定制的内核，
      就应该采取不同的名字 (例如， 您想定制一个试验性的内核)。</para>

    <programlisting>#To statically compile in device wiring instead of /boot/device.hints
#hints          "GENERIC.hints"         # Default places to look for devices.</programlisting>

    <para>&man.device.hints.5; 可以用来配置设备驱动选项。
      在启动的时候 &man.loader.8; 将会检查缺省位置 <filename>/boot/devicehints</filename>。 
      使用 <literal>hints</literal> 选项您就可以把这些 hints 静态编译进内核。
      这样就没有必要在
      <filename>/boot</filename>下创建<filename>devicehints</filename>。</para>

    <!-- XXX: Add a comment here that explains when compiling hints into
      the kernel is a good idea and why. -->

    <programlisting>#makeoptions     DEBUG=-g          # Build kernel with gdb(1) debug symbols</programlisting>

    <para>一般的 &os; 构建过程并不包括调试信息，
      在构建内核时， 绝大多数符号会在最终的内核连接之后剔除出去，
      以节省安装时所需的空间。 如果您打算测试 -CURRENT 分支的内核，
      或开发您自己的 &os; 内核功能， 则可能会需要去掉这一行的注释。
      这将启用 <option>-g</option> 选项， 它会在 &man.gcc.1;
      中打开调试信息。 如果您使用 <quote>传统</quote>
      方法来构建内核， 也可以通过 &man.config.8; 的
      <option>-g</option> 选项来达到同样的目的
      (参见 <xref linkend="kernelconfig-building">
      了解进一步的信息)。</para>

    <programlisting>options          SCHED_4BSD         # 4BSD scheduler</programlisting>

    <para>这是 &os; 的传统调度器。 取决于您系统的工作负荷，
      使用新的 ULE 调度器通常可以获得更好的性能。 它是专门为
      &os; 在 SMP 上运行而设计的调度器， 但在 UP
      系统上也能工作得很好。 如果您想试验这个功能，
      则应把配置文件中的 <literal>SCHED_4BSD</literal>
      改为 <literal>SCHED_ULE</literal>。</para>

    <programlisting>options          INET              # InterNETworking</programlisting>

    <para>网络支持，即使您不打算连网，也请保留它，大部分的程序至少需要回环网络（就是和本机进行网络连接），所以强烈要求保留它。
    </para>

    <programlisting>options          INET6             # IPv6 communications protocols</programlisting>

    <para>这将打开IPv6连接协议。</para>

    <programlisting>options          FFS               # Berkeley Fast Filesystem</programlisting>

    <para>这是最基本的硬盘文件系统，如果打算从本地硬盘启动，请保留它。</para>

    <programlisting>options          SOFTUPDATES       # Enable FFS Soft Updates support</programlisting>

    <para>这个选项会启用内核中的 Soft Updates 支持，
      它会显著地提高磁盘的写入速度。 尽管这项功能是由内核直接提供的，
      但仍然需要在每个磁盘上启用它。 请检查 &man.mount.8; 的输出，
      以了解您系统中的磁盘上是否已经启用了 Soft Updates。
      如果没有看到 <literal>soft-updates</literal> 选项，
      则需要使用 &man.tunefs.8; (对于暨存系统)
      或 &man.newfs.8; (对于新系统) 命令来激活它。</para>

    <programlisting>options          UFS_ACL           # Support for access control lists</programlisting>

    <para>这个选项只能在 &os;&nbsp;5.X 和更高版本中使用，
      它将启用内核中的访问控制表的支持。
      这依赖于扩展属性以及 <acronym>UFS2</acronym>，
      以及在 <xref linkend="fs-acl"> 中所介绍的那些特性。
      <acronym>ACL</acronym> 默认是启用的，
      并且如果已经在文件系统上使用了这一特性，
      就不应再关掉它， 因为这会去掉文件的访问控制表，
      并以不可预期的方式改变受保护的文件的访问方式。</para>

    <programlisting>options          UFS_DIRHASH       # Improve performance on big directories</programlisting>

    <para>通过使用额外的内存，这个选项可以加速在大目录上的磁盘操作。
    您应该在大型服务器和频繁使用的工作站上打开这个选项，而在磁盘操作不是很重要的
    小型系统上关闭它，比如防火墙。</para>

    <programlisting>options          MD_ROOT           # MD is a potential root device</programlisting>

    <para>这个选项将打开以基于内存的虚拟磁盘作为根设备的支持。</para>

    <indexterm>
      <primary>内核选项</primary>
      <secondary>NFS</secondary>
    </indexterm>
    <indexterm>
      <primary>内核选项</primary>
      <secondary>NFS_ROOT</secondary>
    </indexterm>
    <programlisting>options          NFSCLIENT         # Network Filesystem Client
options          NFSSERVER         # Network Filesystem Server
options          NFS_ROOT          # NFS usable as /, requires NFSCLIENT</programlisting>

    <para>网络文件系统。 如果您不打算通过 TCP/IP 挂接
      &unix; 文件服务器的分区， 就可以注释掉它。</para>

    <indexterm>
      <primary>内核选项</primary>
      <secondary>MSDOSFS</secondary>
    </indexterm>
    <programlisting>options          MSDOSFS           # MSDOS Filesystem</programlisting>

    <para>&ms-dos; 文件系统。 只要您不打算在启动时挂接由 DOS 格式化的硬盘分区，
      就可以把它注释掉。
      如前面所介绍的那样， 在您第一次挂接 DOS 分区时，
      内核会自动加载需要的模块。 此外，
      <filename role="package">emulators/mtools</filename>
      软件提供了一个很方便的功能，
      通过它您可以直接访问 DOS 软盘而无需挂接或卸下它们
      (而且也完全不需要 <literal>MSDOSFS</literal>)。</para>

    <programlisting>options          CD9660            # ISO 9660 Filesystem</programlisting>

    <para>用于 CDROM 的 ISO 9660 文件系统。 如果没有 CDROM
      驱动器或很少挂接光盘数据 (因为在首次使用数据 CD 时会自动加载)，
      就可以把它注释掉。 音乐 CD 并不需要这个选项。</para>

    <programlisting>options          PROCFS            # Process filesystem</programlisting>

    <para>进程文件系统。 这是一个挂接在 <filename>/proc</filename>
      的一个 <quote>假扮的</quote> 文件系统， 其作用是允许类似 &man.ps.1;
      这样的程序给出正在运行的进程的进一步信息。 多数情况下，
      并不需要使用 <literal>PROCFS</literal>， 因为绝大多数调试和监控工具，
      已经进行了一系列修改， 使之不再依赖
      <literal>PROCFS</literal>： 默认安装的系统中并不会挂接这一文件系统。
      此外， 在 6.X-STABLE 内核中，
      如果希望使用 <literal>PROCFS</literal>，
      就必须加入 <literal>PSEUDOFS</literal> 的支持：</para>

    <programlisting>options          PSEUDOFS          # Pseudo-filesystem framework</programlisting>

    <programlisting>options          GEOM_GPT          # GUID Partition Tables.</programlisting>

    <para>这个选项提供了在磁盘上使用大量的分区的能力。</para>

    <programlisting>options          COMPAT_43         # Compatible with BSD 4.3 [KEEP THIS!]</programlisting>

    <para>使系统兼容4.3BSD。不要去掉这一行，不然有些程序将无法正常运行。
    </para>

    <programlisting>options          COMPAT_FREEBSD4   # Compatible with &os;4</programlisting>

    <para>为了支持在旧版本的&os;下编译的程序，该选项在&os;&nbsp;5.X &i386;和Alpha systems下需要打开。
    最好在所有的&i386;和Alpha systems下打开这个选项，因为可能要运行老应用程序。
    在5.X才开始支持的平台，比如ia64和&sparc64;，就不需要这个选项。</para>

    <programlisting>options          SCSI_DELAY=15000  # Delay (in ms) before probing SCSI</programlisting>

    <para>这将让内核在探测每个 SCSI 设备之前等待 15 秒。
      如果您只有 IDE 硬盘驱动器， 则可以不管它，
      反之您可能会想降低这个数值， 可能减少到 5 秒，
      以加速启动过程。 当然， 如果您这么做之后
      &os; 在识别您的 SCSI 设备时遇到问题，
      则您还需要再把它改回去。</para>

    <programlisting>options          KTRACE            # ktrace(1) support</programlisting>

    <para>这个选项打开内核进程跟踪，在调试时很有用。
    </para>

    <programlisting>options          SYSVSHM           # SYSV-style shared memory</programlisting>

    <para>提供System&nbsp;V共享内存(SHM)的支持，最常用到SHM的应该是X Window的XSHM延伸，
    不少绘图相关程序会自动使用SHM来提供额外的速度。如果您要使用X Window，您最好加入这个选项。
    </para>

    <programlisting>options          SYSVMSG           # SYSV-style message queues</programlisting>

    <para>支持 System&nbsp;V 消息。 这只会在内核中增加数百字节的空间占用。</para>

    <programlisting>options          SYSVSEM           # SYSV-style semaphores</programlisting>

    <para>支持System&nbsp;V 信号量， 不常用到， 但只在kernel中占用几百个字节的空间。</para>

    <note>
      <para>&man.ipcs.1; 命令的 <option>-p</option> 选项可以显示出任何用到这些
	System&nbsp;V 机制的进程。</para>
    </note>

    <programlisting>options 	     _KPOSIX_PRIORITY_SCHEDULING # POSIX P1003_1B real-time extensions</programlisting>

    <para>在 1993 年 &posix; 添加的实时扩展。 在 Ports Collection 中某些应用程序会用到这些
    （比如<application>&staroffice;</application>）。
    </para>

    <programlisting>options          KBD_INSTALL_CDEV  # install a CDEV entry in /dev</programlisting>

    <para>这个选项与键盘有关。 它在 <filename>/dev</filename>
      中安装一个 CDEV 项。</para>

    <programlisting>options          AHC_REG_PRETTY_PRINT     # Print register bitfields in debug
                                          # output.  Adds ~128k to driver.
options          AHD_REG_PRETTY_PRINT     # Print register bitfields in debug
                                          # output.  Adds ~215k to driver.</programlisting>

    <para>这个选项主要用于帮助调试， 它能够给出更容易阅读的寄存器数值。</para>

    <programlisting>options          ADAPTIVE_GIANT    # Giant mutex is adaptive.</programlisting>

    <para>内核全局锁 (Giant) 是一种互斥机制 (休眠互斥体) 的名字，
      它用于保护许多内核资源。 现在， 这已经成为了一种无法接受的性能瓶颈，
      它已经被越来越多地使用保护单个资源的锁代替。
      <literal>ADAPTIVE_GIANT</literal> 选项将使得内核全局锁作为一种自适应自旋锁。
      这意味着， 当有线程希望锁住内核全局锁互斥体， 但互斥体已经被另一个 CPU
      上的线程锁住的时候， 它将继续运行， 直到那个线程释放锁为止。
      一般情况下， 另一个线程将进入休眠状态并等待下一次调度。
      如果您不确定是否应该这样做的话， 一般应该打开它。</para>

    <indexterm>
      <primary>内核选项</primary>
      <secondary>SMP</secondary>
    </indexterm>
    <programlisting>device          apic               # I/O APIC</programlisting>

    <para>apic 设备将启用使用 I/O APIC 作为中断发送设备的能力。
      apic 设备可以被 UP 和 SMP 内核使用， 但 SMP 内核必须使用它。
      要支持多处理器， 还需要加上 <literal>options SMP</literal>。</para>

    <programlisting>device          isa</programlisting>

    <para>所有为 &os; 所支持的 PC 都需要这个设置，
      即使没有 ISA 插槽也是一样。 如果您使用
      IBM PS/2 (微通道架构) 的计算机， &os; 目前只能提供有限的支持。
      要了解关于 MCA 支持的详情， 请参考
      <filename>/usr/src/sys/i386/conf/NOTES</filename>。</para>

    <programlisting>device          eisa</programlisting>

    <para>如果您的主机板上有EISA总线，加入这个设置。使用这个选项可以自动扫描并设置所有连接在EISA总线上的设备。</para>

    <programlisting>device          pci</programlisting>

    <para>如果您的主板有PCI总线，就加入这个选项。使用这个选项可以自动扫描PCI卡，并在PCI到ISA之间建立通路。</para>

    <programlisting># Floppy drives
device          fdc</programlisting>

    <para>这是软驱控制器。</para>

    <programlisting># ATA and ATAPI devices
device          ata</programlisting>

    <para>这个驱动器支持所有ATA和ATAPI设备。您只要在内核中加入<literal>device ata</literal>选项，
    就可以让内核支持现代计算机上的所有PCI ATA/ATAPI设备。
    </para>

    <programlisting>device          atadisk                 # ATA disk drives</programlisting>

    <para>这个是ATAPI 磁盘驱动器所必须的。</para>

    <programlisting>device          ataraid                 # ATA RAID drives</programlisting>

    <para>这个选项需要 <literal>device ata</literal>， 它用于 ATA
      RAID 驱动。</para>

    <programlisting><anchor id="kernelconfig-atapi">
device          atapicd                 # ATAPI CDROM drives</programlisting>

    <para>这个是ATAPI CDROM驱动器所必须的。</para>

    <programlisting>device          atapifd                 # ATAPI floppy drives</programlisting>

    <para>这个是ATAPI 磁盘驱动器所必须的。</para>

    <programlisting>device          atapist                 # ATAPI tape drives</programlisting>

    <para>这个是ATAPI 磁带机驱动器所必须的.</para>

    <programlisting>options         ATA_STATIC_ID           # Static device numbering</programlisting>

    <para>这指定对控制器使用其静态的编号； 如果没有这个选项，
      则会动态地分配设备的编号。</para>

    <programlisting># SCSI Controllers
device          ahb        # EISA AHA1742 family
device          ahc        # AHA2940 and onboard AIC7xxx devices
device          ahd        # AHA39320/29320 and onboard AIC79xx devices
device          amd        # AMD 53C974 (Teckram DC-390(T))
device          isp        # Qlogic family
device          mpt        # LSI-Logic MPT-Fusion
#device         ncr        # NCR/Symbios Logic
device          sym        # NCR/Symbios Logic (newer chipsets)
device          trm        # Tekram DC395U/UW/F DC315U adapters

device          adv        # Advansys SCSI adapters
device          adw        # Advansys wide SCSI adapters
device          aha        # Adaptec 154x SCSI adapters
device          aic        # Adaptec 15[012]x SCSI adapters, AIC-6[23]60.
device          bt         # Buslogic/Mylex MultiMaster SCSI adapters

device          ncv        # NCR 53C500
device          nsp        # Workbit Ninja SCSI-3
device          stg        # TMC 18C30/18C50</programlisting>

    <para>SCSI控制器。可以注释掉您系统中没有的设备。如果您只有IDE设备，您可以把这些一起删掉。</para>

    <programlisting># SCSI peripherals
device          scbus      # SCSI bus (required for SCSI)
device          ch         # SCSI media changers
device          da         # Direct Access (disks)
device          sa         # Sequential Access (tape etc)
device          cd         # CD
device          pass       # Passthrough device (direct SCSI access)
device          ses        # SCSI Environmental Services (and SAF-TE)</programlisting>

    <para>SSCSI外围设备。也可以像上面一样操作。</para>

    <note>
      <para>目前系统提供的 USB &man.umass.4; 以及少量其它驱动使用了
	SCSI 子系统， 尽管它们并不是真的 SCSI 设备。
	因此， 如果在内核配置使用了这类驱动程序， 请务必不要删除
	SCSI 支持。</para>
    </note>

    <programlisting># RAID controllers interfaced to the SCSI subsystem
device          amr        # AMI MegaRAID
device          arcmsr     # Areca SATA II RAID
device          asr        # DPT SmartRAID V, VI and Adaptec SCSI RAID
device          ciss       # Compaq Smart RAID 5*
device          dpt        # DPT Smartcache III, IV - See NOTES for options
device          hptmv      # Highpoint RocketRAID 182x
device          iir        # Intel Integrated RAID
device          ips        # IBM (Adaptec) ServeRAID
device          mly        # Mylex AcceleRAID/eXtremeRAID
device          twa        # 3ware 9000 series PATA/SATA RAID

# RAID controllers
device          aac        # Adaptec FSA RAID
device          aacp       # SCSI passthrough for aac (requires CAM)
device          ida        # Compaq Smart RAID
device          mlx        # Mylex DAC960 family
device          pst        # Promise Supertrak SX6000
device          twe        # 3ware ATA RAID</programlisting>

    <para>支持RAID控制器。如果您没有这些，可以把它们注释掉或是删掉。</para>

    <programlisting># atkbdc0 controls both the keyboard and the PS/2 mouse
device          atkbdc     # AT keyboard controller</programlisting>

    <para>键盘控制器（<literal>atkbdc</literal>）提供AT键盘输入以及PS/2指针设备的I/O服务。
    键盘驱动程序（<literal>atkbd</literal>）与PS/2鼠标驱动程序（<literal>psm</literal>）需要这个控制器，所以不要删除它。
    </para>

    <programlisting>device          atkbd      # AT keyboard</programlisting>

    <para><literal>atkbd</literal>驱动程序，与<literal>atkbdc</literal>控制器一起使用，
    提供连接到AT键盘控制器的AT 84键盘与AT加强型键盘的访问服务。
   </para>

    <programlisting>device          psm        # PS/2 mouse</programlisting>

    <para>如果您的鼠标连接到PS/2鼠标端口，就使用这个设备驱动程序。</para>

    <programlisting>device          vga        # VGA video card driver</programlisting>

    <para>显卡驱动。</para>

    <programlisting># splash screen/screen saver
device          splash     # Splash screen and screen saver support</programlisting>

    <para>启动时的 splash 画面！ 屏幕保护程序也需要这一选项。</para>

    <programlisting># syscons is the default console driver, resembling an SCO console
device          sc</programlisting>

    <para><literal>sc</literal> 是默认的控制台驱动程序， 类似 SCO 控制台。
      由于绝大部分全屏幕程序都通过类似
      <filename>termcap</filename> 这样的终端数据库函数库赖访问控制台，
      因此无论您使用这个或与 <literal>VT220</literal> 兼容的
      <literal>vt</literal> 都没有什么关系。
      如果您在运行这种控制台时使用全屏幕程序时发生问题， 请在登录之后将
      <envar>TERM</envar> 变量设置为 <literal>scoansi</literal>。</para>

    <programlisting># Enable this for the pcvt (VT220 compatible) console driver
#device          vt
#options         XSERVER          # support for X server on a vt console
#options         FAT_CURSOR       # start with block cursor</programlisting>

    <para>这是一个兼容 VT220 的控制台驱动， 它同时能够向下兼容
      VT100/102。 在同 <literal>sc</literal>
      硬件不兼容的一些笔记本上它能够运行的很好。
      当然， 登录系统时请把
      <envar>TERM</envar> 变量设置为 <literal>vt100</literal> 或
      <literal>vt220</literal>。
      此驱动在连接网络上大量不同的机器时也被证明非常有用，
      因为此时 <filename>termcap</filename> 或
      <filename>terminfo</filename> 通常没有可用的
      <literal>sc</literal> 设备 &mdash; 而 <literal>vt100</literal>
      则几乎每种平台都支持。</para>

    <programlisting>device          agp</programlisting>

    <para>如果您的机器使用 AGP 卡， 请把上面一行加入配置。
      这将启用 AGP， 以及某些卡上的 AGP GART 支持。</para>

    <programlisting># Floating point support - do not disable.
device          npx</programlisting>

    <para><literal>npx</literal> 是 &os; 中浮点运算单元的接口，
      用于支持硬件的浮点运算协处理器， 以及软件仿真程序。
      这个设置 <emphasis>不是</emphasis>
      可有可无的。</para>

    <indexterm>
      <primary>APM</primary>
    </indexterm>

    <programlisting># 电源管理支持 (参见 NOTES 了解更多选项)
#device          apm</programlisting>

    <para>高级电源管理支持。 对笔记本有用，
      不过在 &os; 5.X 和更高版本中的
      <filename>GENERIC</filename> 里默认禁用。</para>

    <programlisting># 增加 i8254 的 挂起/恢复 支持。
device           pmtimer</programlisting>

    <para>用于电源管理事件， 例如 APM 和 ACPI 的时钟设备驱动。</para>

    <programlisting># PCCARD (PCMCIA) support
# PCMCIA and cardbus bridge support
device          cbb               # cardbus (yenta) bridge
device          pccard            # PC Card (16-bit) bus
device          cardbus           # CardBus (32-bit) bus</programlisting>

    <para>PCMCIA支持。如果您使用膝上型计算机，您需要这个。</para>

    <programlisting># Serial (COM) ports
device          sio               # 8250, 16[45]50 based serial ports</programlisting>

    <para>这些串口在 &ms-dos;/&windows; 的世界中称为
      <devicename>COM</devicename> 口。</para>

    <note>
      <para>如果使用内置式的调制解调器， 并占用 <devicename>COM4</devicename>
	而您另有一个串口在 <devicename>COM2</devicename>， 则必须把调制解调器的
	IRQ 改为 2 (由于晦涩的技术原因，
	IRQ2 = IRQ 9) 才能够在 &os; 中访问它。
	如果有多口的串口卡， 请参考 &man.sio.4; 以了解需要在
	<filename>/boot/device.hints</filename> 中进行的设置。
	某些显卡 (特别是基于 S3 芯片的卡) 使用形如 <literal>0x*2e8</literal>
	的 IO 地址， 而许多廉价的串口卡不能够正确地对 16-位
	IO 地址空间进行解码， 因此它们会产生冲突，
	并造成 <devicename>COM4</devicename> 实际上无法使用。</para>

      <para>每一个串口都需要有一个唯一的 IRQ (除非您使用支持中断分享的串口卡)，
        因此默认的 <devicename>COM3</devicename>
	和 <devicename>COM4</devicename> IRQ 是不能使用的。</para>
    </note>

    <programlisting># Parallel port
device          ppc</programlisting>

    <para>ISA-bus并行接口。</para>

    <programlisting>device          ppbus      # Parallel port bus (required)</programlisting>

    <para>提供并行总线的支持。</para>

    <programlisting>device          lpt        # Printer</programlisting>

    <para>提供并口打印机的支持。</para>

    <note>
      <para>要使用并口打印机，就必须同时加入上面三行设置。</para>
    </note>

    <programlisting>device          plip       # TCP/IP over parallel</programlisting>

    <para>这是针对并行网络接口的驱动器。</para>

    <programlisting>device          ppi        # Parallel port interface device</programlisting>

    <para>普通用途的I/O (<quote>geek port</quote>) + IEEE1284 I/O.</para>

    <programlisting>#device         vpo        # Requires scbus and da</programlisting>

    <indexterm><primary>zip drive</primary></indexterm>
    <para>这是针对Iomega Zip驱动器的。它要求<literal>scbus</literal>和<literal>da</literal>的支持。
    最好的执行效果是工作在EPP 1.9模式。
    </para>

    <programlisting>#device         puc</programlisting>

    <para>如果您有由 &man.puc.4; 支持的 <quote>哑</quote>
      串行或并行 PCI 卡， 则应去掉这一行的注释。</para>

    <programlisting># PCI Ethernet NICs.
device          de         # DEC/Intel DC21x4x (<quote>Tulip</quote>)
device          em         # Intel PRO/1000 adapter Gigabit Ethernet Card
device          ixgb       # Intel PRO/10GbE Ethernet Card
device          txp        # 3Com 3cR990 (<quote>Typhoon</quote>)
device          vx         # 3Com 3c590, 3c595 (<quote>Vortex</quote>)</programlisting>

    <para>多种PCI网卡驱动器。注释或删除您系统中没有的设备.</para>

    <programlisting># PCI Ethernet NICs that use the common MII bus controller code.
# NOTE: Be sure to keep the 'device miibus' line in order to use these NICs!
device          miibus     # MII bus support</programlisting>

    <para>MII总线支持对于一些PCI 10/100 Ethernet NIC来说是必需的。
    </para>

    <programlisting>device          bfe        # Broadcom BCM440x 10/100 Ethernet
device          bge        # Broadcom BCM570xx Gigabit Ethernet
device          dc         # DEC/Intel 21143 and various workalikes
device          fxp        # Intel EtherExpress PRO/100B (82557, 82558)
device          lge        # Level 1 LXT1001 gigabit ethernet
device          nge        # NatSemi DP83820 gigabit ethernet
device          pcn        # AMD Am79C97x PCI 10/100 (precedence over 'lnc')
device          re         # RealTek 8139C+/8169/8169S/8110S
device          rl         # RealTek 8129/8139
device          sf         # Adaptec AIC-6915 (<quote>Starfire</quote>)
device          sis        # Silicon Integrated Systems SiS 900/SiS 7016
device          sk         # SysKonnect SK-984x &amp; SK-982x gigabit Ethernet
device          ste        # Sundance ST201 (D-Link DFE-550TX)
device          ti         # Alteon Networks Tigon I/II gigabit Ethernet
device          tl         # Texas Instruments ThunderLAN
device          tx         # SMC EtherPower II (83c170 <quote>EPIC</quote>)
device          vge        # VIA VT612x gigabit ethernet
device          vr         # VIA Rhine, Rhine II
device          wb         # Winbond W89C840F
device          xl         # 3Com 3c90x (<quote>Boomerang</quote>, <quote>Cyclone</quote>)</programlisting>

    <para>使用MII总线控制器代码的驱动器。</para>

    <programlisting># ISA Ethernet NICs.  pccard NICs included.
device          cs         # Crystal Semiconductor CS89x0 NIC
# 'device ed' requires 'device miibus'
device          ed         # NE[12]000, SMC Ultra, 3c503, DS8390 cards
device          ex         # Intel EtherExpress Pro/10 and Pro/10+
device          ep         # Etherlink III based cards
device          fe         # Fujitsu MB8696x based cards
device          ie         # EtherExpress 8/16, 3C507, StarLAN 10 etc.
device          lnc        # NE2100, NE32-VL Lance Ethernet cards
device          sn         # SMC's 9000 series of Ethernet chips
device          xe         # Xircom pccard Ethernet

# ISA devices that use the old ISA shims
#device         le</programlisting>

    <para>ISA 以太网卡驱动。 参见
      <filename>/usr/src/sys/<replaceable>i386</replaceable>/conf/NOTES</filename>
      以了解关于哪个驱动程序能够驱动您的网卡的细节。</para>

    <programlisting># Wireless NIC cards
device          wlan       # 802.11 support
device          an         # Aironet 4500/4800 802.11 wireless NICs.
device          awi        # BayStack 660 and others
device          wi         # WaveLAN/Intersil/Symbol 802.11 wireless NICs.
#device         wl         # Older non 802.11 Wavelan wireless NIC.</programlisting>

    <para>用以支持多种无线网卡。</para>

    <programlisting># Pseudo devices
device   loop          # Network loopback</programlisting>

    <para>这是 TCP/IP 的通用回环设备。 如果您 telnet
      或 FTP 到 <hostid>localhost</hostid> (也就是 <hostid
      role="ipaddr">127.0.0.1</hostid>) 则将通过这个设备回到本机。
      这个设备是 <emphasis>必需的</emphasis>。</para>

    <programlisting>device   mem           # Memory and kernel memory devices</programlisting>

    <para>The system memory devices.</para>

    <programlisting>device   io            # I/O device</programlisting>

    <para>This option allows a process to gain I/O privileges. This is
      useful in order to write userland programs that can handle hardware
      directly.  This is required to run the X Window system.</para>

    <programlisting>device   random        # Entropy device</programlisting>

    <para>Cryptographically secure random number generator.</para>

    <programlisting>device   ether         # Ethernet support</programlisting>

    <para><literal>ether</literal> 只有在使用以太网卡时才需要。
      它包含了通用的以太网协议代码。</para>

    <programlisting>device   sl            # Kernel SLIP</programlisting>

    <para><literal>sl</literal> 用以提供 SLIP 支持。
      目前它几乎已经完全被 PPP 取代了， 因为后者更容易配置，
      而且更适合调制解调器之间的连接， 并提供了更强大的功能。</para>

    <programlisting>device   ppp           # Kernel PPP</programlisting>

    <para>这一选项用以提供内核级的 PPP 支持， 用于拨号连接。
      也有以用户模式运行的 PPP 实现， 使用
      <literal>tun</literal> 并提供包括按需拨号在内的更为灵活的功能。</para>

    <programlisting>device   tun           # Packet tunnel.</programlisting>

    <para>它会被用户模式的 PPP 软件用到。
      参考本书的 <link linkend="userppp">PPP</link> 以了解更多的细节。</para>

    <programlisting><anchor id="kernelconfig-ptys">
device   pty           # Pseudo-ttys (telnet etc)</programlisting>

    <para>这是一个 <quote>pseudo-terminal</quote> 或模拟登入端口。
      它用来接收连入的 <command>telnet</command> 以及
      <command>rlogin</command> 会话、
      <application>xterm</application>， 以及一些其它程序如
      <application>Emacs</application> 等。</para>

    <programlisting>device   md            # Memory <quote>disks</quote></programlisting>

    <para>内存盘伪设备。</para>

    <programlisting>device   gif           # IPv6 and IPv4 tunneling</programlisting>

    <para>它实现了在 IPv4 上的 IPv6 隧道、 IPv6 上的 IPv4 隧道、
      IPv4 上的 IPv4 隧道、 以及IPv6 上的 IPv6隧道。
      <literal>gif</literal> 设备是
      <quote>自动克隆</quote> 的， 它会根据需要自动创建设备节点。</para>

    <programlisting>device   faith         # IPv6-to-IPv4 relaying (translation)</programlisting>

    <para>这个伪设备能捕捉发给它的数据包，并把它们转发给
      IPv4/IPv6 翻译服务程序。</para>

    <programlisting># The `bpf' device enables the Berkeley Packet Filter.
# Be aware of the administrative consequences of enabling this!
# Note that 'bpf' is required for DHCP.
device   bpf           # Berkeley packet filter</programlisting>

    <para>这是 Berkeley 包过滤器。这个伪设备允许网络接口被置于混杂模式，
      从而，截获广播网 (例如，以太网) 上的每一个数据包。
      截获的数据报可以保存到磁盘上，也可以使用 &man.tcpdump.1; 程序来分析。</para>

    <note>
      <para>&man.bpf.4; 设备也被用于
	&man.dhclient.8; 来获取默认路由器(网关)的 IP 地址。如果使用DHCP，就不要注释掉这行。</para>
    </note>

    <programlisting># USB support
device          uhci          # UHCI PCI-&gt;USB interface
device          ohci          # OHCI PCI-&gt;USB interface
#device         ehci          # EHCI PCI-&gt;USB interface (USB 2.0)
device          usb           # USB Bus (required)
#device         udbp          # USB Double Bulk Pipe devices
device          ugen          # Generic
device          uhid          # <quote>Human Interface Devices</quote>
device          ukbd          # Keyboard
device          ulpt          # Printer
device          umass         # Disks/Mass storage - Requires scbus and da
device          ums           # Mouse
device          urio          # Diamond Rio 500 MP3 player
device          uscanner      # Scanners
# USB Ethernet, requires mii
device          aue           # ADMtek USB Ethernet
device          axe           # ASIX Electronics USB Ethernet
device          cdce          # Generic USB over Ethernet
device          cue           # CATC USB Ethernet
device          kue           # Kawasaki LSI USB Ethernet
device          rue           # RealTek RTL8150 USB Ethernet</programlisting>

    <para>支持各类 USB 设备。</para>

    <programlisting># FireWire support
device          firewire      # FireWire bus code
device          sbp           # SCSI over FireWire (Requires scbus and da)
device          fwe           # Ethernet over FireWire (non-standard!)</programlisting>

    <para>支持各类火线设备。</para>

    <para>要了解 &os; 所支持的设备的其他情况， 请参考
      <filename>/usr/src/sys/<replaceable>i386</replaceable>/conf/NOTES</filename>。</para>

      <sect2>
        <title>大内存支持(<acronym>PAE</acronym>)</title>
	<indexterm>
	  <primary>物理地址扩展
	    (<acronym>PAE</acronym>)</primary>
	  <secondary>大内存</secondary>
	</indexterm>

	<para>大内存配置的机器需要超过４GB的虚拟地址。
	因为4GB的限制，Intel在&pentium;及后续的CPUs上增加了36位物理地址的支持。
	</para>
	
	<para>物理地址扩展 (<acronym>PAE</acronym>) 是
	  &intel; &pentium; Pro和后续的 CPU 提供的一种允许将内存地址扩展到 64GB
	  的功能， &os; 的所有最新版本均支持此功能， 并通过
	  <option>PAE</option> 选项来启用这个能力。 因为Intel架构的限制，
	  高于或低于 4GB 都没有什么区别，
	  超过 4GB 的内存分配只是简单地添加到可用内存池中。</para>

	<para>为了让内核支持<acronym>PAE</acronym>，只要增加下面这一行到配置文件：</para>
	
	<programlisting>options		    PAE</programlisting>

	<note>
	  <para><acronym>PAE</acronym>在&os;里面现在只能支持 &intel; IA-32处理器。
	  同时，还应该注意，&os;的<acronym>PAE</acronym>支持没有经过广泛的测试，
	  和其他稳定的特性相比只能当作是beta版。</para>
	</note>

	<para><acronym>PAE</acronym>在&os;下有如下的一些限制：</para>
	
	<itemizedlist>
	  <listitem>
	    <para>进程不能接触大于4GB的VM空间。</para>
	  </listitem>

	  <listitem>
	    <para><acronym>KLD</acronym> 模块不能加载到一个打开了<acronym>PAE</acronym>支持的内核里面，
	    这是因为内核模块和内核的建立框架不一样。</para>
	  </listitem>

	  <listitem>
	    <para>没有使用 &man.bus.dma.9; 接口的设备驱动程序在打开了
	      <acronym>PAE</acronym> 支持的内核中会导致数据损坏。
	      因为这个原因， <filename>PAE</filename> 内核配置文件
	      会把所有在打开了 <acronym>PAE</acronym>
	      的内核上不能工作的驱动程序排除在外。</para>
	  </listitem>

	  <listitem>
	    <para>一些系统打开了探测系统内存资源使用能力的功能，因为打开了
	    <acronym>PAE</acronym>支持，这些功能可能会被覆盖掉。
	      其中一个例子就是内核参数<option>kern.maxvnodes</option>，它是控制
	      内核能使用的最大vnodes数目的，建议重新调整它及其他类似参数到合适的值。</para>
	  </listitem>

	  <listitem>
	    <para>为了避免<acronym>KVA</acronym>的消耗，很有必要增加系统的内核虚拟地址，
	    或者减少很耗系统资源的内核选项的总量（看上面）。<option>KVA_PAGES</option>选项
	    可以用来增加<acronym>KVA</acronym>空间。
	    </para>
	  </listitem>
	</itemizedlist>

	<para>为了稳定和高性能，建议查看&man.tuning.7;手册页。&man.pae.4;手册页包含
	&os;'s<acronym>PAE</acronym>支持的最新信息。
        </para>
    </sect2>
  </sect1>

  <sect1 id="kernelconfig-trouble">
    <title>如果出现问题怎么办</title>

    <para>在定制一个内核时，可能会出现五种问题。它们是：</para>

    <variablelist>
      <varlistentry>
	<term><command>config</command>失败：</term>

	<listitem>
	  <para>如果 &man.config.8; 在给出您的内核描述时失败，
	    则可能在某些地方引入了一处小的错误。
	    幸运的是， &man.config.8; 会显示出它遇到问题的行号，
	    这样您就能够迅速地定位错误。 例如， 如果您看到：</para>

	  <screen>config: line 17: syntax error</screen>

	  <para>可以通过与 <filename>GENERIC</filename> 或其他参考资料对比，
	    来确定这里的关键词是否拼写正确。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><command>make</command>失败：</term>

	<listitem>
	  <para>如果 <command>make</command> 命令失败，
	    它通常表示内核描述中发生了 &man.config.8; 无法找出的的错误。
	    同样地， 仔细检查您的配置， 如果仍然不能解决问题，
	    发一封邮件到 &a.questions; 并附上您的内核配置，
	    则问题应该很快就能解决。</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>内核无法启动：<anchor
	  id="kernelconfig-noboot"></term>

	<listitem>
	  <para>如果您的内核无法启动， 或不识别您的设备， 千万别慌！
	    非常幸运的是， &os; 有一个很好的机制帮助您从不兼容的内核恢复。
	    在 &os; 启动加载器那里简单地选择一下要启动的内核就可以了。
	    当系统在引导菜单的 10 秒倒计时时进入它， 方法是选择 <quote>Escape to a loader
	    prompt</quote> 选项， 其编号为 6。 输入
	    <command>unload kernel</command>， 然后输入
	    <command>boot /boot/<replaceable>kernel.old</replaceable>/kernel</command>，
            或者其他任何一个可以正确引导的内核即可。
            当重新配置内核时， 保持一个已经证明能够正常启动的内核永远是一个好习惯。</para>

	  <para>当使用好的内核启动之后您可以检查配置文件并重新尝试编译它。
	    比较有用的资源是 <filename>/var/log/messages</filename> 文件，
	    它会记录每次成功启动所产生的所有内核消息。
	    此外， &man.dmesg.8; 命令也会显示这次启动时产生的内核消息。</para>

	  <note>
	    <para>如果在编译内核时遇到麻烦， 请务必保留一个
	      <filename>GENERIC</filename> 或已知可用的其他内核，
	      并命名为别的名字以免在下次启动时被覆盖。
	      不要依赖 <filename>kernel.old</filename>
	      因为在安装新内核时， <filename>kernel.old</filename>
	      会被上次安装的那个可能不正常的内核覆盖掉。
	      另外， 尽快把可用的内核挪到
	      <filename class="directory">/boot/kernel</filename>
	      否则类似 &man.ps.1; 这样的命令可能无法正常工作。
	      为了完成这一点， 需要修改目录的名字：</para>

	    <screen>&prompt.root; <userinput>mv /boot/kernel /boot/kernel.bad</userinput>
&prompt.root; <userinput>mv /boot/<replaceable>kernel.good</replaceable> /boot/kernel</userinput></screen>

	  </note>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>内核工作，但是&man.ps.1;根本不工作:</term>

	<listitem>
	  <para>如果您安装了一个与系统中内建工具版本不同的内核，
	    例如在 -STABLE 系统上安装了 -CURRENT 的内核， 许多用于检查系统状态的工具如
	    &man.ps.1; 和 &man.vmstat.8; 都将无法正常使用。
	    您应该 <link linkend="makeworld">重新编译一个和内核版本一致的系统</link>。
	    这也是为什么一般不鼓励使用与系统其他部分版本不同的内核的一个主要原因。</para>
	</listitem>
      </varlistentry>
    </variablelist>
  </sect1>
</chapter>

<!-- 
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
