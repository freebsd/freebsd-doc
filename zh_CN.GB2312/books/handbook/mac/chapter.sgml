<!--
     The FreeBSD Documentation Project
     The FreeBSD Simplified Chinese Project

     Original Revision: 1.47
     $FreeBSD$
-->

<chapter id="mac">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Tom</firstname>
	<surname>Rhodes</surname>
	<contrib>Written by </contrib>
      </author>
    </authorgroup>
  </chapterinfo>

  <title>集权式访问控制</title>

  <sect1 id="mac-synopsis">
    <title>概要</title>

    <indexterm><primary>MAC</primary></indexterm>
    <indexterm>
      <primary>集权式访问控制</primary>
      <see>MAC</see>
    </indexterm>

    <para>&os;&nbsp;5.X 在 &posix;.1e 草案的基础上引入了 TrustedBSD
      项目提供的新的安全性扩展。 新安全机制中最重要的两个，
      是文件系统访问控制列表 (<acronym>ACL</acronym>)
      和集权式访问控制 (<acronym>MAC</acronym>) 机制。
      集权式访问控制允许加载新的访问控制模块， 并借此实施新的安全策略，
      其中一部分为一个很小的系统子集提供保护并加强特定的服务，
      其他的则对所有的主体和对象提供全面的标签式安全保护。
      定义中有关集权的部分源于如下事实，
      控制的实现由管理员和系统作出，
      而不像全权式访问控制 (<acronym>DAC</acronym>, &os;
      中的标准文件以及 System V <acronym>IPC</acronym> 权限)
      那样是按照用户意愿进行的。</para>

    <para>本章将集中讲述集权式访问控制框架 (MAC 框架)
      以及一套用以实施多种安全策略的插件式的安全策略模块。</para>

    <para>阅读本章之后， 您将了解：</para>

    <itemizedlist>
      <listitem>
	<para>目前 &os; 中具有哪些 <acronym>MAC</acronym> 安全策略模块，
	  以及与之相关的机制。</para>
      </listitem>

      <listitem>
	<para><acronym>MAC</acronym> 安全策略模块将实施何种策略，
	  以及标签式与非标签式策略之间的差异。</para>
      </listitem>

      <listitem>
	<para>如何高效地配置系统令使其使用 <acronym>MAC</acronym> 框架。</para>
      </listitem>

      <listitem>
	<para>如何配置 <acronym>MAC</acronym> 框架所提供的不同的安全策略模块。</para>
      </listitem>

      <listitem>
        <para>如何用 <acronym>MAC</acronym> 框架构建更为安全的环境，
	  并举例说明。</para>
      </listitem>

      <listitem>
	<para>如何测试 <acronym>MAC</acronym> 配置以确保正确构建了框架。</para>
      </listitem>
    </itemizedlist>

    <para>阅读本章之前， 您应该：</para>

    <itemizedlist>
      <listitem>
	<para>了解 &unix; 和 &os; 的基础 (<xref linkend="basics">)。</para>
      </listitem>

      <listitem>
	<para>熟悉内核配置/编译 (<xref linkend="kernelconfig">) 的基础。</para>
      </listitem>

      <listitem>
	<para>对安全及其如何与 &os; 相配合有些了解； (<xref linkend="security">)。</para>
      </listitem>
    </itemizedlist>

    <warning>
      <para>对本章信息的不当使用可能导致丧失系统访问权， 激怒用户，
	或者无法访问 X11 提供的特性。 更重要的是， <acronym>MAC</acronym>
	不能用于彻底保护一个系统。 <acronym>MAC</acronym> 框架仅用于增强现有安全策略；
	如果没有健全的安全条例以及定期的安全检查，
	系统将永远不会绝对安全。</para>

      <para>此外还需要注意的是， 本章中所包含的例子仅仅是例子。
	我们并不建议在一个生产用系统上进行这些特别的设置。
        实施各种安全策略模块需要谨慎的考虑，
        因为那些并不完全理解所有机制如何工作的人，
        可能会发现需要对整个系统中很多的文件或目录进行重新配置。</para>
    </warning>

    <sect2>
      <title>未涉及的内容</title>

      <para>本章涵盖了与 <acronym>MAC</acronym> 框架有关的诸多方面的安全问题；
        尽管如此， 本章将不涉及新 <acronym>MAC</acronym> 安全策略模块的开发成果。
        <acronym>MAC</acronym> 框架中所包含的一部分安全策略模块，
        具有一些用于测试及新模块开发的特定属性，
        其中包括 &man.mac.test.4;、 &man.mac.stub.4;
        以及 &man.mac.none.4;。
        关于这些安全策略模块及其提供的众多机制的详细信息，请参阅联机手册中的内容。</para>
    </sect2>
  </sect1>

  <sect1 id="mac-inline-glossary">
    <title>本章出现的重要术语</title>

    <para>在阅读本章之前， 有些关键术语需要解释，
      希望能藉此扫清可能出现的疑惑， 并避免在文中对新术语、
      新信息进行生硬的介绍。</para>

    <itemizedlist>
      <listitem>
	<para><emphasis>区间</emphasis>： 区间，
	  是指一组被划分或隔离的程序和数据， 其中，
	  用户被明确地赋予了访问特定系统组件的权限。 同时，
	  区间也能够表达分组， 例如工作组、 部门、 项目， 或话题。
	  可以通过使用区间来实施 need-to-know 安全策略。</para>
      </listitem>

      <listitem>
	<para><emphasis>完整性</emphasis>： 作为一个关键概念，
	  完整性是数据可信性的一种程度。
          若数据的完整性提高， 则数据的可信性相应提高。</para>
      </listitem>

      <listitem>
	<para><emphasis>标签</emphasis>： 标签是一种可应用于文件、
	  目录或系统其他对象的安全属性， 它也可以被认为是一种机密性印鉴。
	  当一个文件被施以标签时， 其标签会描述这一文件的安全参数，
          并只允许拥有相似安全性设置的文件、 用户、 资源等访问该文件。
          标签值的涵义及解释取决于相应的策略配置：
          某些策略会将标签当作对某一对象的完整性和保密性的表述，
          而其它一些策略则会用标签保存访问规则。</para>
      </listitem>

      <listitem>
	<para><emphasis>程度</emphasis>： 对某种安全属性加强或削弱的设定。
          若程度增加， 其安全性也相应增加。</para>
      </listitem>

      <listitem>
	<para><emphasis>多重标签 (multilabel)</emphasis>： <option>multilabel</option>
	  属性是一个文件系统选项。 该选项可在单用户模式下通过
	  &man.tunefs.8; 程序进行设置。 可以在引导时使用的 &man.fstab.5;
	  文件中， 也可在创建新文件系统时进行配置。
	  该选项将允许管理员对不同对象施以不同的 <acronym>MAC</acronym> 标签。
          该选项仅适用于支持标签的安全策略模块。</para>
      </listitem>

      <listitem>
	<para><emphasis>对象</emphasis>： 对象或系统对象是一种实体，
	  信息随 <emphasis>主体</emphasis> 的导向在对象内部流动。
	  对象包括目录、 文件、 区段、 监视器、 键盘、 存储器、
	  磁存储器、 打印机及其它数据存储/转移设备。
	  基本上， 一个对象就是一个数据容器或一种系统资源。
	  对 <emphasis>对象</emphasis> 的访问实际上意味着对数据的访问。</para>
      </listitem>

      <listitem>
	<para><emphasis>策略</emphasis>： 一套用以规定如何达成目标的规则。
          <emphasis>策略</emphasis> 一般用以描述如何对特定对象进行操作。
          本章将在<emphasis>安全策略</emphasis>的范畴内讨论<emphasis>策略</emphasis>，
          一套用以控制数据和信息流并规定其访问者的规则，就是其中一例。</para>
      </listitem>

      <listitem>
	<para><emphasis>敏感性</emphasis>： 通常在讨论
	  <acronym>MLS</acronym> 时使用。
	  敏感性程度曾被用来描述数据应该有何等的重要或机密。
          若敏感性程度增加， 则保密的重要性或数据的机密性相应增强。</para>
      </listitem>

      <listitem>
	<para><emphasis>单一标签</emphasis>：
	  整个文件系统使用一个标签对数据流实施访问控制， 叫做单一标签。
          当文件系统使用此设置时， 即无论何时当 <option>多重标签</option>
          选项未被设定时， 所有文件都将遵守相同标签设定。</para>
      </listitem>

      <listitem>
	<para><emphasis>主体</emphasis>： 主体就是引起信息在两个
	  <emphasis>对象</emphasis>间流动的任意活动实体，
	  比如用户， 用户处理器， 系统进程等。
	  在 &os; 中， 主体几乎总是代表用户活跃在某一进程中的一个线程。</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="mac-initial">
    <title>关于 MAC 的说明</title>

    <para>在掌握了所有新术语之后， 我们从整体上来考虑 <acronym>MAC</acronym>
      是如何加强系统安全性的。 <acronym>MAC</acronym>
      框架提供的众多安全策略模块可以用来保护网络及文件系统，
      也可以禁止用户访问某些特定的端口、 套接字及其它对象。
      将策略模块组合在一起以构建一个拥有多层次安全性的环境，
      也许是其最佳的使用方式， 这可以通过一次性加载多个安全策略模块来实现。
      在多层次安全环境中， 多重策略模块可以有效地控制安全性，
      这一点与加强式策略不同。
      加强式策略一般加强仅具有某些特殊用途的系统对象的安全性。
      相比之下， 多重策略的唯一不足是需要系统管理员先期设置好参数，
      如多重文件系统安全标志、每一位用户的网络访问权限等等。</para>

    <para>与框架长久的效果相比， 这些不足之处微乎其微。
      例如， 为某种特殊配置选择其所需策略的能力， 会使整体性能下降，
      但减少对无用策略的支持却可以提高系统整体性能，
      同时还可以为选择提供弹性空间。 好的应用应该考虑到整体的安全性要求，
      并有效地实施框架提供的众多安全策略模块。</para>

    <para>这样一个使用 <acronym>MAC</acronym> 特性的系统，
      至少要保证不允许用户任意更改安全属性； 所有的用户实用工具、
      程序以及脚本， 必须在所选安全策略模块提供的访问规则的约束下工作；
      并且系统管理员应掌握 <acronym>MAC</acronym> 访问规则的一切控制权。</para>

    <para>细心选择正确的安全策略模块是系统管理员专有的职责。
      某些环境也许需要限制网络的访问控制权，
      在这种情况下， 使用 &man.mac.portacl.4;、 &man.mac.ifoff.4; 乃至
      &man.mac.biba.4; 安全策略模块都会是不错的开始； 在其他情况下，
      系统对象也许需要严格的机密性， 像 &man.mac.bsdextended.4; 和
      &man.mac.mls.4; 这样的安全策略模块就是为此而设。</para>

    <para>对安全策略模块的决定可依据网络配置进行，
      也许只有特定的用户才应该被允许使用由 &man.ssh.1;
      提供的程序以访问网络或互联网， &man.mac.portacl.4;
      安全策略模块应该成为这种情况下的选择。 但对文件系统又该作些什么呢？
      是由特定的用户或群组来确定某些目录的访问权限，
      抑或是将特定对象设为保密以限制用户或组件访问特定文件？</para>

    <para>在文件系统的例子中， 也许访问对象的权限对某些用户是保密的，
      但对其他则不是。 比如， 一个庞大的开发团队，
      也许会被分成许多由几人组成的小组， A 项目中的开发人员可能不被允许访问
      B 项目开发人员创作的对象， 但同时他们还需要访问由 C
      项目开发人员创作的对象， 这正符合上述情形。 使用由
      <acronym>MAC</acronym> 框架提供的不同策略， 用户就可以被分成这种小组，
      然后被赋予适当区域的访问权， 由此， 我们就不用担心信息泄漏的问题了。</para>

    <para>因此， 每一种安全策略模块都有其处理系统整体安全问题的独特方法。
      对安全策略模块的选择应在对安全策略深思熟虑的基础之上进行。 很多情况下，
      整体安全策略需要重新修正并在系统上实施。 理解 <acronym>MAC</acronym>
      框架提供的不同安全策略模块会帮助管理员就其面临的情形选择最佳的策略模块。</para>

    <para>&os; 的默认内核并不包含 <acronym>MAC</acronym> 框架选项， 因此，
      在尝试使用本章中的例子或信息之前， 您应该添加以下内核选项：</para>

    <programlisting>options	MAC</programlisting>

    <para>此外， 内核还需要重新编译并且重新安装。</para>

    <caution>
      <para>尽管有关 <acronym>MAC</acronym>
	的许多联机手册中都声明它们可以被编译到内核中，
        但对这些策略模块的使用仍可能导致锁死系统的网络及其他功能。
        使用 <acronym>MAC</acronym> 就像使用防火墙一样，
        因此必须要小心防止将系统完全锁死。 在使用 <acronym>MAC</acronym> 时，
        应该考虑是否能够回退到之前的配置， 在远程进行配置更应加倍小心。</para>
    </caution>
  </sect1>

  <sect1 id="mac-understandlabel">
    <title>理解 MAC 标签</title>

    <para><acronym>MAC</acronym> 标签是一种安全属性，
      它可以被应用于整个系统中的主体和对象。</para>

    <para>配置标签时， 用户必须能够确切理解其所进行的操作。
      对象所具有的属性取决于被加载的策略模块，
      不同策略模块解释其属性的方式也差别很大。
      由于缺乏理解或无法了解其间联系而导致的配置不当，
      会引起意想不到的， 也许是不愿看到的系统异常。</para>

    <para>对象上的安全标签是由安全策略模块决定的安全访问控制的一部分。
      在某些策略模块中， 标签本身所包含的所有信息足以使其作出决策，
      而在其它一些安全策略模块中， 标签则可能被作为一个庞大规则体系的一部分进行处理。</para>

    <para>举例来说， 在文件上设定 <literal>biba/low</literal> 标签，
      意味着此标签隶属 Biba 策略模块， 其值为 <quote>low</quote>。</para>

    <para>某些在 &os; 中支持标签特性的策略会提供三个预定义的标签，
      分别是 low、 high 及 equal 标签。
      尽管这些标签在不同安全策略模块中会对访问控制采取不同措施，
      但有一点是可以肯定的， 那就是 low 标签表示最低限度的设定，
      equal 标签会将主体或对象设定为被禁用的或不受影响的，
      high 标签则会应用 Biba 及 <acronym>MLS</acronym>
      安全策略模块中允许的最高级别的设定。</para>

    <para>在单一标签文件系统的环境中， 同一对象上只会应用一个标签，
      于是， 一套访问权限将被应用于整个系统， 这也是很多环境所全部需要的。
      另一些应用场景中， 我们需要将多重标签应用于文件系统的对象或主体，
      如此一来， 就需要使用  &man.tunefs.8;
      的 <option>multilabel</option> 选项。</para>

    <para>在使用 Biba 和 <acronym>MLS</acronym> 时可以配置数值标签，
      以精确地标示分级控制的中的程度。
      数值的程度可以用来划分或将信息按组分类，
      从而只允许同程度或更高程度的组对齐进行访问。</para>

    <para>多数情况下， 管理员将仅对整个文件系统设定单一标签。</para>

    <para><emphasis>等一下， 这看起来很像 <acronym>DAC</acronym>！
      但我认为 <acronym>MAC</acronym> 确实只将控制权赋予了管理员。 </emphasis>
      此声明依然有效。 在某种程度上， <username>root</username> 是实施控制的用户，
      他配置安全策略模块以使用户们被分配到适当的类别/访问 levels 中。
      唉， 很多安全策略模块同样可以限制 <username>root</username> 用户。
      对于对象的基本控制可能会下放给群组， 但 <username>root</username>
      用户随时可以废除或更改这些设定。
      这就是如 Biba 及 <acronym>MLS</acronym>
      这样一些安全策略模块所包含的 hierarchal/clearance 模型。</para>

    <sect2>
      <title>配置标签</title>

      <para>实际上， 有关标签式安全策略模块配置的各种问题都是用基础系统组件实现的。
        这些命令为对象和主体配置以及配置的实施和验证提供了一个简便的接口。</para>

      <para>所有的配置都应该通过 &man.setfmac.8; 及 &man.setpmac.8; 组件实施。
        <command>setfmac</command> 命令是用来对系统对象设置
        <acronym>MAC</acronym> 标签的， 而 <command>setpmac</command>
        则是用来对系统主体设置标签的。 例如：</para>

      <screen>&prompt.root; <userinput>setfmac biba/high test</userinput></screen>

      <para>若以上命令不发生错误则会直接返回命令提示符，
	只有当发生错误时， 这些命令才会给出提示， 这和
        &man.chmod.1; 和 &man.chown.8; 命令类似。
        某些情况下， 以上命令产生的错误可能是
        <errorname>Permission denied</errorname>，
        一般在受限对象上设置或修改设置时会产生此错误。
        <footnote><para>其它情况也能导致不同的执行失败。
        例如， 文件可能并不隶属于尝试重标签该文件的用户，
        对象可能不存在或着是只读的。 文件的某一属性、
        进程的某一属性或新的自定义标签值的某一属性，
        将使集权式策略不允许进程重标签文件。 例如：
        低完整性的用户试图修改高完整性文件的标签，
        或者低完整性的用户试图将低完整性文件的标签改为高完整性标签。</para></footnote>
        系统管理员可使用以下命令解决此问题：</para>

      <screen>&prompt.root; <userinput>setfmac biba/high test</userinput>
<errorname>Permission denied</errorname>
&prompt.root; <userinput>setpmac biba/low setfmac biba/high test</userinput>
&prompt.root; <userinput>getfmac test</userinput>
test: biba/high</screen>

      <para>如上所示， 通过 <command>setpmac</command>
	对被调用的进程赋予不同的标签， 以覆盖安全策略模块的设置。
        <command>getpmac</command> 组件通常用于当前运行的进程，
        如 <application>sendmail</application>：
        尽管其使用进程编号来替代命令， 其逻辑是相同的。
        如果用户试图对其无法访问的文件进行操作， 根据所加载的安全策略模块的规则，
        函数 <function>mac_set_link</function>
        将会给出 <errorname>Operation not permitted</errorname> 的错误提示。</para>

      <sect3>
	<title>一般标签类型</title>

	<para>&man.mac.biba.4;、 &man.mac.mls.4; 及 &man.mac.lomac.4;
	  策略模块提供了设定简单标签的功能， 其值应该是 high、 equal 及 low
	  之一。 以下是对这些标签功能的简单描述：</para>

	<itemizedlist>
	  <listitem>
	    <para><literal>low</literal>
	      标签被认为是主体或对象所具有的最低层次的标签设定。
              对主体或对象采用此设定， 将阻止其访问标签为 high 的对象或主体。</para>
	  </listitem>

	  <listitem>
	    <para><literal>equal</literal> 标签只能被用于不希望受策略控制的对象上。</para>
	  </listitem>

	  <listitem>
	    <para><literal>high</literal> 标签对对象或主体采用可能的最高设定。</para>
	  </listitem>
	</itemizedlist>

	<para>至于每个策略模块， 每种设定都会产生不同的信息流指令。
          阅读联机手册中相关的章节将进一步阐明这些一般标签配置的特点。</para>

        <sect4>
	  <title>标签高级配置</title>

	  <para>如下所示， 用于 <literal>比较： 区间+ 区间</literal> 的数值等级数：</para>

	  <programlisting>biba/10:2+3+6(5:2+3-20:2+3+4+5+6)</programlisting>

	  <para>可被解释为： </para>

	  <para><quote>Biba 策略标签</quote>/<quote>等级10</quote>
	    ： <quote>区间 2、 3及6</quote>：
	    (<quote>等级5 ...</quote>)</para>

	  <para>本例中， 第一个等级将被认为是 <quote>有效区间</quote> 的
	    <quote>有效等级</quote>， 第二个等级是低级等级，
	    最后一个则是高级等级。 大多数配置中不会使用这些设置，
	    实际上， 它们是为更高级的配置准备的。</para>

	  <para>当把它们应用在系统对象上时， 则只有当前的等级/区间，
	    因为它们反映可以实施访问控制的系统中可用的范围， 以及网络接口。</para>

	  <para>等级和区间， 可以用来在一对主体和对象之间建立一种称为
	    <quote>支配</quote> 的关系， 这中关系可能是主体支配对象，
	    对象支配主体， 互不支配或互相支配。
	    <quote>互相支配</quote> 这种情况会在两个标签相等时发生。
	    由于 Biba 的信息流特性， 您可以设置一系列区间，
	    <quote>need to know</quote>， 这可能发生于项目之间，
	    而对象也由其对应的区间。 用户可以使用
	    <command>su</command> 和 <command>setpmac</command>
	    来将他们的权限进一步细分， 以便在没有限制的区间里访问对象。</para>

	</sect4>
      </sect3>

      <sect3>
	<title>用户和标签设置</title>

	<para>用户本身也需要设置标签，
	  以使其文件和进程能够正确地与系统上定义的安全策略互动，
          这是通过使用登录分级在文件 <filename>login.conf</filename>
          中配置的。 每个使用标签的策略模块都会进行用户分级设定。</para>

	<para>以下是一个使用所有策略模块的例子：</para>

	<programlisting>default:\
	:copyright=/etc/COPYRIGHT:\
	:welcome=/etc/motd:\
	:setenv=MAIL=/var/mail/$,BLOCKSIZE=K:\
	:path=~/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin:\
	:manpath=/usr/share/man /usr/local/man:\
	:nologin=/usr/sbin/nologin:\
	:cputime=1h30m:\
	:datasize=8M:\
	:vmemoryuse=100M:\
	:stacksize=2M:\
	:memorylocked=4M:\
	:memoryuse=8M:\
	:filesize=8M:\
	:coredumpsize=8M:\
	:openfiles=24:\
	:maxproc=32:\
	:priority=0:\
	:requirehome:\
	:passwordtime=91d:\
	:umask=022:\
	:ignoretime@:\
	:label=partition/13,mls/5,biba/10(5-15),lomac10[2]:</programlisting>

	<para><literal>label</literal> 选项用以设定用户分级默认标签，
	  该标签将由 <acronym>MAC</acronym> 执行。
	  用户绝不会被允许更改该值， 因此其从用户的观点看不是可选的。
          当然， 在真实情况的配置中， 管理员不会希望启用所有策略模块。
	  我们建议您在实施以上配置之前阅读本章的其余部分。</para>

	<note>
	  <para>用户也许会在首次登录后更改其标签，
            尽管如此， 这仅仅是策略的主观局限性。
            上面的例子告诉 Biba 策略， 进程的最小完整性是为5，
            最大完整性为15， 默认且有效的标签为10。
            进程将以10的完整性运行直至其决定更改标签，
            这可能是由于用户使用了 setpmac 命令
            (该操作将在登录时被 Biba 限制在一定用户范围之内)。</para>
	</note>

	<para>在所有情况下， 修改 <filename>login.conf</filename> 之后，
          都必须使用 <command>cap_mkdb</command> 重编译登录分级 capability 数据库，
          这在接下来的例子和讨论中就会有所体现。</para>

	<para>很多站点可能拥有数目可观的用户需要不同的用户分级，
	  注意到这点是大有裨益的。 深入来说就是需要事先做好计划，
	  因为管理起来可能十分困难。</para>

	<para>在 &os 以后的版本中， 将包含一种将用户映射到标签的新方式，
          尽管如此， 这也要到 &os;&nbsp;5.3 之后的某个时间才能实现。</para>
      </sect3>

      <sect3>
	<title>网络接口和标签设定</title>

	<para>也可以在网络接口上配置标签， 以控制进出网络的数据流。
	  在所有情况下， 策略都会以适应对象的方式运作。 例如， 在
	  <literal>biba</literal> 中设置为高的用户，
	  就不能访问标记为低的网络接口。</para>

	<para><option>maclabel</option> 可以作为
	  <command>ifconfig</command> 的参数用于设置网络接口的
	  <acronym>MAC</acronym> 标签。 例如：</para>

	<screen>&prompt.root; <userinput>ifconfig bge0 maclabel biba/equal</userinput></screen>

	<para>将在 &man.bge.4; 接口上设置 <literal>biba/equal</literal> 的
	  <acronym>MAC</acronym> 标签。 当使用类似
	  <literal>biba/high(low-high)</literal> 这样的标签时，
	  整个标签应使用引号括起来； 否则将发生错误。</para>

	<para>每一个支持标签的策略模块都提供了用于在网络接口上禁用该
	  <acronym>MAC</acronym> 标签的系统控制变量。 将标签设置为
	  <option>equal</option> 的效果与此类似。
	  请参见 <command>sysctl</command> 的输出、 策略模块的联机手册，
	  或本章接下来的内容， 以了解更进一步的详情。</para>
      </sect3>
    </sect2>

    <sect2>
      <title>用单一标签还是多重标签？</title>
<!-- Stopped here with my edits -->
      <para>默认情况下， 系统采用的是
	<option>singlelabel</option> 选项。 但这对管理员意味着什么呢？
	两种策略之间存在很多的不同之处， 它们在系统安全模型的灵活性方面，
	提供了不同的选择。</para>

      <para><option>singlelabel</option> 只允许在每个 subject
	或对象上使用一个标签， 如 <literal>biba/high</literal>。
	这降低了管理的开销， 但也同时降低了支持标签的策略的灵活性。
	许多管理员可能更希望在安全策略中使用 <option>multilabel</option>。</para>

      <para><option>multilabel</option> 选项允许每一个 subject
	或对象拥有各自独立的 <acronym>MAC</acronym> 标签，
	起作用与标准的、 只允许整个分区上使用一个的
	<option>singlelabel</option> 选项类似。 <option>multilabel</option>
	和 <option>single</option> 标签选项只有对实现了标签功能的那些策略，
	如 Biba、 Lomac、
	<acronym>MLS</acronym> 以及 <acronym>SEBSD</acronym>
	才有意义。</para>
    
      <para>很多情况下是不需要设置 <option>multilabel</option> 的。
	考虑下列情形和安全模型：</para>

      <itemizedlist>
	<listitem>
	  <para>使用了 <acronym>MAC</acronym> 以及许多混合策略的 &os;
	    web-服务器。</para>
	</listitem>

	<listitem>
	  <para>这台机器上的整个系统中只需要一个标签， 即
	    <literal>biba/high</literal>。 此处的文件系统并不需要
	    <option>multilabel</option> 选项，
	    因为有效的 label 只有一个。</para>
	</listitem>

	<listitem>
	  <para>因为这台机器将作为 Web 服务器使用，
	    因此应该以 <literal>biba/low</literal> 运行 Web 服务，
	    以杜绝向上写。 Biba 策略以及它如何运作将在稍后予以讨论，
	    因此， 如果您感觉前面的说明难以理解的话， 请继续阅读下面的内容，
	    再回来阅读这些内容就会有较为清晰的认识了。 服务器可以使用设置为
	    <literal>biba/low</literal> 的单独的分区，
	    用于保持其运行环境的状态。 这个例子中还省略了许多内容，
	    例如， 如何为数据配置访问限制、 参数配置和用户的设置；
	    它只是为前述的内容提供一个简单的例子。</para>
	</listitem>
      </itemizedlist>

      <para>如果打算使用非标签式策略，
	就不需要 <option>multilabel</option> 选项了。
	这些策略包括 <literal>seeotheruids</literal>、
	<literal>portacl</literal> 和 <literal>partition</literal>。</para>

      <para>另一个需要注意的事情是， 在分区上使用
	<option>multilabel</option> 并建立基于 <option>multilabel</option>
	可能会提高系统管理的开销， 因为文件系统中的所有对象都需要指定标签。
	这包括对目录、文件， 甚至设备节点。</para>

      <para>接下来的命令将在需要使用多个标签的文件系统上设置
	<option>multilabel</option>。 这一操作只能在单用户模式下完成：</para>

      <screen>&prompt.root; <userinput>tunefs -l enable /</userinput></screen>

      <para>交换区不需要如此配置。</para>

      <note>
	<para>某些用户可能会在根分区上配置
	  <option>multilabel</option> 标志时遇到困难。
	  如果发生这样的情况， 请复查本章的
	  <xref linkend="mac-troubleshoot">。</para>
      </note>
    </sect2>

    <sect2>
      <title>用系统控制变量控制 MAC</title>

      <para>即使在没有加载任何模块的时候，
        也仍然有一些可以通过 <command>sysctl</command> 接口来控制的
        <acronym>MAC</acronym> 特性。 这些系统控制变量将在下面予以描述，
        在所有的例子中， 数字一 (1) 都表示启用， 而数字零 (0)
        则表示禁用：</para>

      <itemizedlist>
	<listitem>
	  <para><literal>security.mac.enforce_fs</literal>
	    表示在文件系统上启用 <acronym>MAC</acronym>
	    策略。</para>
	</listitem>

	<listitem>
	  <para><literal>security.mac.enforce_kld</literal>
	    表示启用动态内核连接器 (参见
	    &man.kld.4;) 上的 <acronym>MAC</acronym> 内核连接策略。</para>
	</listitem>

	<listitem>
	  <para><literal>security.mac.enforce_network</literal>
	    表示启用 <acronym>MAC</acronym> 网络策略。</para>
	</listitem>

	<listitem>
	  <para><literal>security.mac.enforce_pipe</literal>
	    表示启用 <acronym>MAC</acronym> 管道策略。</para>
	</listitem>

	<listitem>
	  <para><literal>security.mac.enforce_process</literal>
	    表示启用使用进程间通讯机制的进程上的 <acronym>MAC</acronym>
	    策略。</para>
	</listitem>

	<listitem>
	  <para><literal>security.mac.enforce_socket</literal>
	    表示启用 socket 上的 <acronym>MAC</acronym> 策略
	    (参见 &man.socket.2; 联机手册)。</para>
	</listitem>

	<listitem>
	  <para><literal>security.mac.enforce_system</literal>
	    表示启用系统活动， 如记账和重新启动的 <acronym>MAC</acronym> 策略。</para>
	</listitem>

	<listitem>
	  <para><literal>security.mac.enforce_vm</literal>
	    表示启用虚拟内存系统上的 <acronym>MAC</acronym> 策略。</para>
	</listitem>
      </itemizedlist>

      <note>
	<para>每个策略或 <acronym>MAC</acronym>
	  选项都支持通过系统控制变量来进行调整。 这些选项通常都位于
	  <literal>security.mac.&lt;策略名&gt;</literal> 的树状结构之下。
	  要查看所有的 <acronym>MAC</acronym> 系统控制变量，
	  可以使用下述命令：</para>

	<screen>&prompt.root; <userinput>sysctl -da | grep mac</userinput></screen>
      </note>

      <para>前面的所有基本
	<acronym>MAC</acronym> 策略默认都会启用。
	如果编入内核的模块被过分锁死， 则可能无法与局域网或 Internet
	进行通讯， 或发生其他严重问题。
	这也是为什么不完全鼓励将这些模块编入内核的原因。
	尽管这样做并不妨碍通过使用 <command>sysctl</command> 来禁用这些策略，
	但以模块方式加载可以让管理员更容易地切换是否使用策略，
	而不需要构建和重新安装一套新系统。</para>
    </sect2>
  </sect1>

  <sect1 id="mac-modules">
    <title>模块配置</title>

    <para>在 <acronym>MAC</acronym> 框架中的每个模块，
      都可以像前述那样连编入内核， 或作为运行时内核模块加载。
      推荐的用法， 是通过在
      <filename>/boot/loader.conf</filename> 加入适当的设置，
      以便在系统启动时的初始化操作过程中加载这些模块。</para>

    <para>接下来的一些小节， 将讨论许多
      <acronym>MAC</acronym> 模块， 并简单介绍它们的功能。
      此外， 这一章还将介绍一些具体环境中的用例。
      某些模块支持一种称为标签 (labeling) 的用法，
      它可以通过使用类似 <quote>允许做这个而不允许做那个</quote>
      的标签来实现访问控制。 标签配置文件可以控制允许的文件访问方式、
      网络通讯， 以及许多其他权限。 在前一节中，
      我们已经展示了文件系统中如何通过 <option>multilabel</option>
      标志来启用基于文件或分区的访问控制的方法。</para>

    <para>单标签配置在整个系统中只强制一个标签的限制，
      这也是 <command>tunefs</command> 选项为什么是
      <option>multilabel</option> 的原因。</para>

    <sect2 id="mac-seeotheruids">
      <title>MAC seeotheruids 模块</title>

      <indexterm>
        <primary>MAC 其他 UID 可见策略</primary>
      </indexterm>
      <para>模块名： <filename>mac_seeotheruids.ko</filename></para>

      <para>对应的内核配置：
        <literal>options MAC_SEEOTHERUIDS</literal></para>

      <para>引导选项：
	<literal>mac_seeotheruids_load="YES"</literal></para>

      <para>&man.mac.seeotheruids.4; 模块模仿并扩展了
	<literal>security.bsd.see_other_uids</literal> 和
	<literal>security.bsd.see_other_gids</literal>
	<command>sysctl</command> 变量。 这一模块并不需要预先配置标签，
	它能够透明地与其他模块协同工作。</para>

      <para>加载模块之后， 下列
	<command>sysctl</command> 变量可以用来控制其功能：</para>

      <itemizedlist>
	<listitem>
	  <para><literal>security.mac.seeotheruids.enabled</literal>
	    将启用模块的功能， 并使用默认的配置。
	    这些默认设置将阻止用户看到其他用户的进程和 socket。</para>
	</listitem>

	<listitem>
	  <para>
	    <literal>security.mac.seeotheruids.specificgid_enabled</literal>
	    将允许特定的组从这一策略中和面。 要将某些组排除在这一策略之外， 可以用
	    <literal>security.mac.seeotheruids.specificgid=<replaceable>XXX</replaceable></literal>
	    <command>sysctl</command> 变量。 前述例子中，
	    <replaceable>XXX</replaceable> 应替换为希望不受限的组 ID 的数值形式。</para>
	</listitem>

	<listitem>
	  <para>
	    <literal>security.mac.seeotheruids.primarygroup_enabled</literal>
	    可以用来将特定的主要组排除在策略之外。 使用这一变量时， 不能同时设置
	    <literal>security.mac.seeotheruids.specificgid_enabled</literal>。</para>
	</listitem>
      </itemizedlist>
    </sect2>
  </sect1>

  <sect1 id="mac-bsdextended">
    <title>MAC bsdextended 模块</title>

    <indexterm>
    <primary>MAC</primary>
      <secondary>文件系统防火墙策略</secondary>
    </indexterm>
    <para>模块名： <filename>mac_bsdextended.ko</filename></para>

    <para>对应的内核配置：
      <literal>options MAC_BSDEXTENDED</literal></para>

    <para>引导选项：
      <literal>mac_bsdextended_load="YES"</literal></para>

    <para>&man.mac.bsdextended.4; 模块能够强制文件系统防火墙策略。
      这一模块的策略提供了标准文件系统权限模型的一种扩展，
      使得管理员能够建立一种类似防火墙的规则集，
      以文件系统层次结构中的保护文件、 实用程序，以及目录。</para>

    <para>这类策略可以通过工具 &man.ugidfw.8; 工具来创建，
      其语法类似 &man.ipfw.8;。 此外还可以通过使用
      &man.libugidfw.3; 库来开发其他的工具。</para>

    <para>当使用这一模块模块时应极其小心；
      不正确的使用将导致文件系统的某些部分无法访问。</para>

    <sect2>
      <title>例子</title>

      <para>在加载了 &man.mac.bsdextended.4; 模块之后，
	下列命令可以用来列出当前的规则配置：</para>

      <screen>&prompt.root; <userinput>ugidfw list</userinput>
0 slots, 0 rules</screen>

      <para>如希望的那样， 目前还没有定义任何规则。 这意味着一切都还可以访问。
	要创建一个阻止所有用户， 而保持
	<username>root</username> 不受影响的规则，
	只需运行下面的命令：</para>

      <screen>&prompt.root; <userinput>ugidfw add subject not uid root new object not uid root mode n</userinput></screen>

      <note>
	<para>在 &os;&nbsp;5.3 之前的版本中，
	  <parameter>add</parameter> 参数并不存在。
	  此时应使用 <parameter>set</parameter> 来代替它。
	  请参见下面的命令例子。</para></note>

      <para>这本身可能是一个很糟糕的主意，
	因为它会阻止所有用户执行哪怕最简单的命令， 例如
	<command>ls</command>。 更富于爱心的规则可能是：</para>

      <screen>&prompt.root; <userinput>ugidfw set 2 subject uid <replaceable>user1</replaceable> object uid <replaceable>user2</replaceable> mode n</userinput>
&prompt.root; <userinput>ugidfw set 3 subject uid <replaceable>user1</replaceable> object gid <replaceable>user2</replaceable> mode n</userinput></screen>

      <para>这将阻止任何 <username>user1</username>
	对 <username><replaceable>user2</replaceable></username>
	的主目录的全部访问， 包括目录列表。</para>

      <para><username>user1</username> 可以用
	<option>not uid <replaceable>user2</replaceable></option>
	代替。 这将同样的强制访问控制实施在所有用户， 而不是单个用户上。</para>

      <note>
	<para><username>root</username> 用户不会受到这些变动的影响。</para>
      </note>

      <para>我们已经给出了
	&man.mac.bsdextended.4; 模块如何帮助加强文件系统的大致介绍。
	要了解更进一步的信息， 请参见
	&man.mac.bsdextended.4; 和 &man.ugidfw.8; 联机手册。</para>
    </sect2>
  </sect1>

  <sect1 id="mac-ifoff">
    <title>MAC ifoff 模块</title>

    <indexterm>
      <primary>MAC 接口屏蔽策略</primary>
    </indexterm>
    <para>模块名： <filename>mac_ifoff.ko</filename></para>

    <para>对应的内核配置：
      <literal>options MAC_IFOFF</literal></para>

    <para>引导选项： <literal>mac_ifoff_load="YES"</literal></para>

    <para>&man.mac.ifoff.4; 模块完全是为了立即禁止网络接口，
      以及阻止在系统初启时启用网络接口而设计的。
      它不需要再系统中配置任何标签， 也不依赖于其他 <acronym>MAC</acronym> 模块。</para>

    <para>绝大多数特性都可以通过调整下面的
      <command>sysctl</command> 来加以控制。</para>

    <itemizedlist>
      <listitem>
	<para><literal>security.mac.ifoff.lo_enabled</literal> 表示
	  启用/禁用 环回接口 (&man.lo.4;)
	  上的全部流量。</para>
      </listitem>

      <listitem>
	<para><literal>security.mac.ifoff.bpfrecv_enabled</literal> 表示
	  启用/禁用 伯克利包过滤器 (&man.bpf.4;) 接口上的全部流量。</para>
      </listitem>

      <listitem>
	<para><literal>security.mac.ifoff.other_enabled</literal> 将在所有其他接口
	  启用/禁用 网络。</para>
      </listitem>
    </itemizedlist>

    <para>最为常用的 &man.mac.ifoff.4;
      用法之一是在不允许引导过程中出现网络流量的环境中监视网络。
      另一个建议的用法是撰写一个使用
      <filename role="package">security/aide</filename> 的脚本，
      以便自动地在受保护的目录中发现新的或修改过的文件时切断网络。</para>
  </sect1>

  <sect1 id="mac-portacl">
    <title>MAC portacl 模块</title>

    <indexterm>
      <primary>MAC 端口访问控制表策略</primary>
    </indexterm>
    <para>模块名： <filename>mac_portacl.ko</filename></para>

    <para>对应的内核配置：
      <literal>MAC_PORTACL</literal></para>

    <para>引导选项： <literal>mac_portacl_load="YES"</literal></para>

    <para>&man.mac.portacl.4; 模块可以用来通过一系列 <command>sysctl</command>
      变量来限制绑定本地的 <acronym>TCP</acronym> 和 <acronym>UDP</acronym>
      端口。 本质上 &man.mac.portacl.4; 使得
      非-<username>root</username> 用户能够绑定到它所指定的特权端口，
      也就是那些编号小于 1024 的端口。</para>

    <para>在加载之后， 这个模块将在所有的 socket 上启用
      <acronym>MAC</acronym> 策略。 可以调整下列一些配置：</para>

    <itemizedlist>
      <listitem>
	<para><literal>security.mac.portacl.enabled</literal> 将完全
	  启用/禁用 策略。 <footnote><para>由于一个
	  bug， <literal>security.mac.portacl.enabled</literal>
	  <command>sysctl</command> 变量在
	  &os;&nbsp;5.2.1 和更早版本上并不起作用。</para></footnote></para>
      </listitem>

      <listitem>
	<para><literal>security.mac.portacl.port_high</literal>
	  将设置为 &man.mac.portacl.4; 所保护的最高端口号。</para>
      </listitem>

      <listitem>
	<para><literal>security.mac.portacl.suser_exempt</literal>
	  如果设置为非零值， 表示将
	  <username>root</username> 用户排除在策略之外。</para>
      </listitem>

      <listitem>
	<para><literal>security.mac.portacl.rules</literal>
	  将指定实际的 mac_portacl 策略； 请参见下文。</para>
      </listitem>
    </itemizedlist>

    <para>实际的 <literal>mac_portacl</literal> 策略，
      是在 <literal>security.mac.portacl.rules</literal>
      sysctl 所指定的一个下列形式的字符串：
      <literal>rule[,rule,...]</literal> 其中可以给出任意多个规则。
      每一个规则的形式都是：
      <literal>idtype:id:protocol:port</literal>。 这里的
      <parameter>idtype</parameter> 参数可以是
      <literal>uid</literal> 或 <literal>gid</literal>，
      分别表示将 <parameter>id</parameter> 参数解释为用户 id 或组 id。
      <parameter>protocol</parameter> 参数可以用来确定希望应用到
      <acronym>TCP</acronym> 或
      <acronym>UDP</acronym> 协议上， 方法是把这一参数设置为
      <literal>tcp</literal> 或 <literal>udp</literal>。 最后的
      <parameter>port</parameter>
      参数则给出了所指定的用户或组能够绑定的端口号。</para>

    <note>
      <para>由于规则集会直接由内核加以解释， 因此只能以数字形式表示用户 ID、
	组 ID， 以及端口等参数。 换言之， 您不能使用用户、 组，
	或端口服务的名字来指定它们。</para>
    </note>

    <para>默认情况下， 在 类-&unix; 系统中， 编号小于 1024
      的端口只能为特权进程使用或绑定， 也就是那些以 <username>root</username>
      身份运行的进程。 为了让
      &man.mac.portacl.4; 能够允许非特权进程绑定低于 1024 的端口，
      就必须首先禁用标准的 &unix; 限制。 这可以通过把 &man.sysctl.8;
      变量 <literal>net.inet.ip.portrange.reservedlow</literal> 和
      <literal>net.inet.ip.portrange.reservedhigh</literal>
      设置为 0 来实现。</para>

    <para>请参见下面的例子， 或 &man.mac.portacl.4; 联机手册中的说明，
      以了解进一步的信息。</para>

    <sect2>
      <title>例子</title>

      <para>下面的例子更好地展示了前面讨论的内容：</para>

      <screen>&prompt.root; <userinput>sysctl security.mac.portacl.port_high=1023</userinput>
&prompt.root; <userinput>sysctl net.inet.ip.portrange.reservedlow=0 net.inet.ip.portrange.reservedhigh=0</userinput></screen>

      <para>首先我们需要设置使 &man.mac.portacl.4; 管理标准的特权端口，
	并禁用普通的 &unix; 绑定限制。</para>

      <screen>&prompt.root; <userinput>sysctl security.mac.portacl.suser_exempt=1</userinput></screen>

      <para>您的 <username>root</username> 用户不应因此策略而失去特权，　因此请把
	<literal>security.mac.portacl.suser_exempt</literal> 设置为一个非零的值。
	现在您已经成功地配置了　&man.mac.portacl.4; 模块，
	并使其默认与 类-&unix; 系统一样运行了。</para>

      <screen>&prompt.root; <userinput>sysctl security.mac.portacl.rules=uid:80:tcp:80</userinput></screen>

      <para>允许 <acronym>UID</acronym> 为 80 的用户 (正常情况下，
	应该是 <username>www</username> 用户) 绑定到 80 端口。
	这样 <username>www</username> 用户就能够运行 web 服务器， 而不需要使用
	<username>root</username> 权限了。</para>

      <screen>&prompt.root; <userinput>sysctl security.mac.portacl.rules=uid:1001:tcp:110,uid:1001:tcp:995</userinput></screen>

      <para>允许 <acronym>UID</acronym> 为
	1001 的用户绑定 <acronym>TCP</acronym> 端口 110
	(<quote>pop3</quote>) 和 995 (<quote>pop3s</quote>)。
	这样用户就能够启动接受来发到 110 和 995 的连接请求的服务了。</para>
    </sect2>
  </sect1>

  <sect1 id="mac-labelingpolicies">
    <title>包含标签功能的 MAC 策略</title>

    <para>接下来的几节中， 将讨论使用标签的 <acronym>MAC</acronym>
      策略。</para>

    <para>这一章从此处开始将集中于对
      &man.mac.biba.4;、 &man.mac.lomac.4;、
      &man.mac.partition.4;， 以及 &man.mac.mls.4; 的介绍。</para>

    <note>
      <para>此处提供的仅仅是示范的配置， 不应用于在实际的生产环境中实施。
        这份文档的目标是在展示配置写法的同时， 以实例的形式，
        对如何实施和进行测试予以介绍。</para>
    </note>

    <para>要让配置正确工作， 首先需要进行一些准备工作。</para>

    <sect2 id="mac-prep">
      <title>准备使用标签策略</title>

      <para>下述修改需要在
	<filename>login.conf</filename> 文件上实施：</para>

      <itemizedlist>
	<listitem>
	  <para>需要增加一个 <literal>insecure</literal> 级， 或其他类似类型的分级。
	    这里， <literal>insecure</literal> 级并不是必需的，
	    只是作为例子加以展示； 不同的配置完全可以使用其他的分级名称。</para>
	</listitem>

	<listitem>
	  <para><literal>insecure</literal> 级应包含下列配置和定义。
	    其中的许多内容都可以根据需要修改，
	    但定义了默认标签的行都是必需的， 您应留下它们。</para>

	  <programlisting>insecure:\
	:copyright=/etc/COPYRIGHT:\
	:welcome=/etc/motd:\
	:setenv=MAIL=/var/mail/$,BLOCKSIZE=K:\
	:path=~/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin:\
	:manpath=/usr/share/man /usr/local/man:\
	:nologin=/usr/sbin/nologin:\
	:cputime=1h30m:\
	:datasize=8M:\
	:vmemoryuse=100M:\
	:stacksize=2M:\
	:memorylocked=4M:\
	:memoryuse=8M:\
	:filesize=8M:\
	:coredumpsize=8M:\
	:openfiles=24:\
	:maxproc=32:\
	:priority=0:\
	:requirehome:\
	:passwordtime=91d:\
	:umask=022:\
	:ignoretime@:\
	:label=partition/13,mls/5,biba/low:</programlisting>

	  <para>需要在
	    &man.login.conf.5; 上执行 &man.cap.mkdb.1; 之后，
	    用户才能够切换到新的分级。</para>

	  <para><username>root</username> 用户也应出现在某个登录级中；
	    否则， <username>root</username> 执行每一个命令的时候，
	    都需要使用 <command>setpmac</command>。</para>

	  <warning>
	    <para>重建 <filename>login.conf</filename>
	      数据库可能会导致 daemon 级在稍后发生某些错误。
	      简单地去掉注释掉 daemon 的注释符并重建数据库，
	      会有助于消除这类问题。</para>
	  </warning>
	</listitem>

	<listitem>
	  <para>确保将要使用
	    <acronym>MAC</acronym> 标签的所有分区， 都能够支持
	    <option>multilabel</option>。 我们必须这样做，
	    因为这里的很多例子中都包含了不同的、 用于测试目的的标签。
	    作为预防性措施之一， 您应复查
	    <command>mount</command> 命令的输出结果。</para>
	</listitem>

	<listitem>
	  <para>把将被应用更高级别的安全机制的那些用户转到新的用户 class 中。
	    运行 &man.pw.8;
	    或 &man.vipw.8; 可以完成这样的任务。</para>
	</listitem>
      </itemizedlist>
    </sect2>
  </sect1>

  <sect1 id="mac-partition">
    <title>MAC partition (分区) 模块</title>

    <indexterm>
      <primary>MAC 进程分区策略</primary>
    </indexterm>
    <para>模块名： <filename>mac_partition.ko</filename></para>

    <para>对应的内核配置：
      <literal>options MAC_PARTITION</literal></para>

    <para>引导选项：
      <literal>mac_partition_load="YES"</literal></para>

    <para>&man.mac.partition.4; 策略将把进程基于其
      <acronym>MAC</acronym> 标签放到特定的 <quote>partitions</quote>
      (分区) 中。 这是一种特殊类型的 &man.jail.8;，
      但对两者进行比较意义不大。</para>

    <para>这个模块应加到
      &man.loader.conf.5; 文件中， 以便在启动过程中启用这些规则。</para>

    <para>绝大多数这一策略的配置是通过 &man.setpmac.8; 工具来完成的，
      它将在后面介绍。 这个策略可以使用下面的 <command>sysctl</command>：</para>

    <itemizedlist>
      <listitem>
	<para><literal>security.mac.partition.enabled</literal>
	  将启用强制的 <acronym>MAC</acronym> 进程
	  partitions。</para>
      </listitem>
    </itemizedlist>

    <para>当启用了这个规则时， 用户将只被允许看到他们自己的进程，
      而无法使用某些工具。 例如， 在前面提到的
      <literal>insecure</literal> class 中的用户，
      将无法使用 <command>top</command> 命令，
      以及其他必需生成进程的命令。</para>

    <para>要设置或删除 partition 标签中的工具， 需要使用
      <command>setpmac</command>：</para>

    <screen>&prompt.root; <userinput>setpmac partition/13 top</userinput></screen>

    <para>这将把 <command>top</command> 命令加入到 <literal>insecure</literal> class
      中的用户的标签集。 注意， 所有由 <literal>insecure</literal> class
      中的用户产生的进程， 仍然会留在
      <literal>partition/13</literal> 标签中。</para>

    <sect2>
      <title>例子</title>

      <para>下面的命令将显示 partition 标签以及进程列表：</para>

      <screen>&prompt.root; <userinput>ps Zax</userinput></screen>

      <para>接下来的这个命令将允许察看其他用户的进程 partition 标签，
	以及那个用户正在运行的进程：</para>

      <screen>&prompt.root; <userinput>ps -ZU trhodes</userinput></screen>

      <note>
	<para>除非加载了 &man.mac.seeotheruids.4; 策略，
	  否则用户就看不到 <username>root</username> 的标签。</para>
      </note>

      <para>非常手工化的实现， 可能会在 <filename>/etc/rc.conf</filename>
	中禁用所有的服务， 并用脚本来按不同的标签来启动它们。</para>

      <note>
	<para>下面的几个策略支持基于所给出的三种标签的完整性设定。
	  这些选项， 连同它们的限制， 在模块的联机手册中进行了进一步介绍。</para>
      </note>
    </sect2>
  </sect1>

  <sect1 id="mac-mls">
    <title>MAC Multi-Level 安全模块</title>

    <indexterm>
      <primary>MAC Multi-Level 安全策略</primary>
    </indexterm>
    <para>模块名： <filename>mac_mls.ko</filename></para>

    <para>对应的内核配置：
      <literal>options MAC_MLS</literal></para>

    <para>引导选项： <literal>mac_mls_load="YES"</literal></para>

    <para>&man.mac.mls.4; 策略，
      通过严格控制信息流向来控制系统中主体和对象的访问。</para>

    <para>在 <acronym>MLS</acronym> 环境中，
      <quote>clearance</quote>(透明度) 级别会在每一个主体或对象标签上进行设置，
      连同对应的区间。 由于这些透明度或敏感度可以有六千多个层次，
      因此为每一个主体或对象进行配置将是一件让任何系统管理员都感到头疼的任务。
      所幸的是， 这个策略中已经包含了三个
      <quote>立即可用的</quote> 标签。</para>

    <para>这些标签是 <literal>mls/low</literal>、
      <literal>mls/equal</literal> 以及 <literal>mls/high</literal>。
      由于这些标签已经在联机手册中进行了介绍， 这里只给出简要的说明：</para>

    <itemizedlist>
      <listitem>
	<para><literal>mls/low</literal> 标签包含了最低配置，
	  从而允许其他对象支配它。 任何标记为 <literal>mls/low</literal>
	  的对象将是地透明度的， 从而不允许访问更高级别的信息。
	  此外， 这个标签也阻止拥有较高透明度的对象向其写入或传递信息。</para>
      </listitem>

      <listitem>
	<para><literal>mls/equal</literal> 标签应放到不希望使用这一策略的对象上。</para>
      </listitem>

      <listitem>
	<para><literal>mls/high</literal> 标签是允许的最高级别透明度。
	  指定了这个标签的对象将支配系统中的其他对象； 但是，
	  它们将不允许向较低级别的对象泄露信息。</para>
      </listitem>
    </itemizedlist>

    <para><acronym>MLS</acronym> 提供了：</para>

    <itemizedlist>
      <listitem>
	<para>提供了一些非层次分类的层次安全模型；</para>
      </listitem>

      <listitem>
	<para>固定规则： 不允许向上读， 不允许向下写
	  (主体可以读取同级或较低级别的对象， 但不能读取高级别的。
	  类似地， 主体可以向同级或较高级写， 而不能向下写)；</para>
      </listitem>

      <listitem>
	<para>保密 (防止不适当的数据透露)；</para>
      </listitem>

      <listitem>
	<para>系统设计的基础要点， 是在多个敏感级别之间并行地处理数据
	  (而不泄露秘密的和机密的信息)。</para>
      </listitem>
    </itemizedlist>

    <para>下列 <command>sysctl</command> 可以用来配置特殊服务和接口：</para>

    <itemizedlist>
      <listitem>
	<para><literal>security.mac.mls.enabled</literal> 用来启用/禁用
	  <acronym>MLS</acronym> 策略。</para>
      </listitem>

      <listitem>
	<para><literal>security.mac.mls.ptys_equal</literal>
	  将所有的 &man.pty.4; 设备标记为 <literal>mls/equal</literal>。</para>
      </listitem>

      <listitem>
	<para><literal>security.mac.mls.revocation_enabled</literal>
	  可以用来在标签转为较低 grade 时撤销对象访问权。</para>
      </listitem>

      <listitem>
	<para><literal>security.mac.mls.max_compartments</literal>
	  可以用来设置对象的最大区间层次； 基本上，
	  这也就是系统中所允许的最大区间数。</para>
      </listitem>
    </itemizedlist>

    <para>要管理 <acronym>MLS</acronym> 标签， 可以使用
      &man.setfmac.8; 命令。 要在对象上指定标签，
      需要使用下面的命令：</para>

    <screen>&prompt.root; <userinput>setfmac mls/5 test</userinput></screen>

    <para>下述命令用于取得文件
      <filename>test</filename> 上的 <acronym>MLS</acronym> 标签：</para>

    <screen>&prompt.root; <userinput>getfmac test</userinput></screen>

    <para>这是 <acronym>MLS</acronym> 策略特性的一个摘要。
      另一种方法是建立一个主策略文件，
      把它放到 <filename class="directory">/etc</filename>，
      指定 <acronym>MLS</acronym> 策略信息，
      并作为 <command>setfmac</command> 命令的输入。
      这一方法将在其他策略之后进行介绍。</para>

    <para>观察： 拥有较低 clearance 的对象不能够观察较高 clearance 的进程。
      基本的策略是在每一个不应被读取的对象上应用 <literal>mls/high</literal>，
      即使需要在其上进行写操作。 在每所有不应被写的对象上应用
      <literal>mls/low</literal>， 即使需要在其上进行度操作。
      最后， 在其他对象上应用
      <literal>mls/equal</literal>。 所有标记为
      <literal>insecure</literal> 的用户应被设置为
      <literal>mls/low</literal>。</para>
  </sect1>

  <sect1 id="mac-biba">
    <title>MAC Biba 模块</title>

    <indexterm>
      <primary>MAC Biba 完整性策略</primary>
    </indexterm>
    <para>模块名： <filename>mac_biba.ko</filename></para>

    <para>对应的内核配置： <literal>options MAC_BIBA</literal></para>

    <para>引导选项： <literal>mac_biba_load="YES"</literal></para>

    <para>&man.mac.biba.4; 模块将加载 <acronym>MAC</acronym>
      Biba 策略。 这个策略与
      <acronym>MLS</acronym> 策略非常类似，
      只是信息流的规则有些相反的地方。
      通俗地说， 这就是防止敏感信息向下传播， 而 <acronym>MLS</acronym>
      策略则是防止敏感信息的向上传播； 因而，
      这一节的许多内容都可以同时应用于两种策略。</para>

    <para>在 Biba 环境中， <quote>integrity</quote> (完整性) 标签，
      将设置在每一个 subject 或对象上。 这些标签是按照层次级别建立的。
      如果对象或 subject 的级别被提升， 其完整性也随之提升。</para>

    <para>被支持的标签是 <literal>biba/low</literal>，
      <literal>biba/equal</literal> 以及 <literal>biba/high</literal>；
      解释如下：</para>

    <itemizedlist>
      <listitem>
	<para><literal>biba/low</literal> 标签被认为是对象或 subject
	  所能拥有的最低完整性级别。 在对象或 subject 上设置它，
	  将阻止其在更高级别对象或 subject 的写操作，
	  虽然读仍被允许。</para>
      </listitem>

      <listitem>
	<para><literal>biba/equal</literal>
	  标签只应在那些希望排除在策略之外的对象上设置。</para>
      </listitem>

      <listitem>
	<para><literal>biba/high</literal> 允许向较低标签的对象上写，
	  但不允许读那些对象。
	  推荐在那些可能影响整个系统完整性的对象上设置这个标签。</para>
      </listitem>
    </itemizedlist>

    <para>Biba 提供了：</para>

    <itemizedlist>
      <listitem>
	<para>层次式的完整性级别， 并提供了一组非层次式的完整性分类；</para>
      </listitem>

      <listitem>
	<para>固定规则： 不允许向上写， 不允许向下读 (与
	  <acronym>MLS</acronym> 相反)。 subject 可以在它自己和较低的级别写，
	  但不能向更高级别实施写操作。 类似地， subject 也可以读在其自己的，
	  或更高级别的对象， 但不能读取较低级别的对象；</para>
      </listitem>

      <listitem>
	<para>完整性 (防止对数据进行不正确的修改)；</para>
      </listitem>

      <listitem>
	<para>完整性级别 (而不是 MLS 的敏感度级别)。</para>
      </listitem>
    </itemizedlist>

    <para>下列 <command>sysctl</command> 可以用于维护 Biba 策略。</para>

    <itemizedlist>
      <listitem>
	<para><literal>security.mac.biba.enabled</literal>
	  可以用来在机器上启用/禁用是否实施 Biba 策略。</para>
      </listitem>

      <listitem>
	<para><literal>security.mac.biba.ptys_equal</literal>
	  可以用来在 &man.pty.4; 设备上禁用 Biba 策略。</para>
      </listitem>

      <listitem>
	<para><literal>security.mac.biba.revocation_enabled</literal>
	  将在支配 subject 发生变化时强制撤销对对象的访问权。</para>
      </listitem>
    </itemizedlist>

    <para>要操作系统对象上的 Biba 策略，
      需要使用 <command>setfmac</command> 和 <command>getfmac</command>
      命令：</para>

    <screen>&prompt.root; <userinput>setfmac biba/low test</userinput>
&prompt.root; <userinput>getfmac test</userinput>
test: biba/low</screen>

    <para>观察： 较低完整性级别的 subject 不能向较高完整性级别的 subject 写；
      较高完整性级别的 subject 也不能观察或读取较低完整性级别的对象。</para>
  </sect1>

  <sect1 id="mac-lomac">
    <title>MAC LOMAC 模块</title>

    <indexterm>
      <primary>MAC LOMAC</primary>
    </indexterm>
    <para>模块名： <filename>mac_lomac.ko</filename></para>

    <para>对应的内核配置： <literal>options MAC_LOMAC</literal></para>
    <para>引导选项： <literal>mac_lomac_load="YES"</literal></para>

    <para>和 <acronym>MAC</acronym> Biba 策略不同，
      &man.mac.lomac.4; 策略只允许在降低了完整性级别之后，
      才允许在不破坏完整性规则的前提下访问较低完整性级别的对象。</para>

    <para><acronym>MAC</acronym> 版本的 Low-watermark
      完整性策略不应与较早的 &man.lomac.4; 实现相混淆，
      除了使用浮动的标签来支持 subject 通过辅助级别 compartment 降级之外，
      其工作方式与 Biba 大体相似。 这一词要的
      compartment 以 <literal>[auxgrade]</literal> 的形式出现。
      当指定包含辅助级别的 lomac 策略时，
      其形式应类似于： <literal>lomac/10[2]</literal>
      这里数字二 (2) 就是辅助级别。</para>

    <para><acronym>MAC</acronym> LOMAC 策略依赖于系统对象上存在普适的标签，
      这样就允许 subject 来从较低完整性级别的对象读取， 并对 subject
      的标签降级， 以防止其在之后写高完整性级别的对象。 这就是前面讨论的
      <literal>[auxgrade]</literal> 选项， 因此这个策略能够提供更大的兼容性，
      而所需要的初始配置也要比 Biba 少。</para>

    <sect2>
      <title>例子</title>

      <para>与 Biba 和 <acronym>MLS</acronym> 策略类似；
	<command>setfmac</command> 和 <command>setpmac</command>
	工具可以用来在系统对象上放置标签：</para>

      <screen>&prompt.root; <userinput>setfmac /usr/home/trhodes lomac/high[low]</userinput>
&prompt.root; <userinput>getfmac /usr/home/trhodes</userinput> lomac/high[low]</screen>

      <para>注意， 这里的辅助级别是 <literal>low</literal>，
	这一特性只由 <acronym>MAC</acronym>
	LOMAC 策略提供。</para>
    </sect2>
  </sect1>

  <sect1 id="mac-implementing">
    <title>通过使用 MAC 来实现安全的环境</title>

    <indexterm>
      <primary>MAC 实现举例</primary>
    </indexterm>

    <para>下面给出了通过多种 <acronym>MAC</acronym> 模块，
      并正确地配置策略来实现安全环境的例子。 这只是一个测试，
      因此不应被看作四海一家的解决之道。 仅仅实现一个策略，
      而忽略它不能解决任何问题， 并可能在生产环境中产生灾难性的后果。</para>

    <para>在开始这些操作之前， 必须在每一个文件系统上设置
      <literal>multilabel</literal> 选项，
      这些操作在这一章开始的部分进行了介绍。 不完成这些操作，
      将导致错误的结果。</para>

    <sect2>
      <title>创建一个 insecure (不安全) 用户 Class</title>

      <para>首先是在 <filename>/etc/login.conf</filename>
	文件中加入一个新的用户 class：</para>

      <programlisting>insecure:\
:copyright=/etc/COPYRIGHT:\
:welcome=/etc/motd:\
:setenv=MAIL=/var/mail/$,BLOCKSIZE=K:\
:path=~/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin
:manpath=/usr/share/man /usr/local/man:\
:nologin=/usr/sbin/nologin:\
:cputime=1h30m:\
:datasize=8M:\
:vmemoryuse=100M:\
:stacksize=2M:\
:memorylocked=4M:\
:memoryuse=8M:\
:filesize=8M:\
:coredumpsize=8M:\
:openfiles=24:\
:maxproc=32:\
:priority=0:\
:requirehome:\
:passwordtime=91d:\
:umask=022:\
:ignoretime@:\
:label=partition/13,mls/5:</programlisting>

      <para>并在 default 用户 class 中加入：</para>

      <programlisting>:label=mls/equal,biba/equal,partition/15:</programlisting>

      <para>一旦完成上述操作， 就需要运行下面的命令来重建数据库：</para>

      <screen>&prompt.root; <userinput>cap_mkdb /etc/login.conf</userinput></screen>
    </sect2>

    <sect2>
      <title>配合正确的模块启动</title>

      <para>在 <filename>/boot/loader.conf</filename> 中加入下面的配置，
	以保证系统初始化过程中加载那些模块：</para>

      <programlisting>mac_biba_load="YES"
mac_mls_load="YES"
mac_seeotheruids_load="YES"
mac_partition_load="YES"</programlisting>
    </sect2>

    <sect2>
      <title>将所有用户设置为不安全的</title>

      <para>所有非 <username>root</username> 或系统的用户，
	现在需要一个登录 class。 登录 class 是必须的，
	否则这些用户将被禁止使用类似 &man.vi.1; 这样的命令。
	下面的 <command>sh</command> 脚本应能完成这个工作：</para>

      <screen>&prompt.root; <userinput>for x in `awk -F: '($3 >= 1001) && ($3 != 65534) { print $1 }' \</userinput>
	<userinput>/etc/passwd`; do pw usermod $x -L insecure; done;</userinput></screen>

      <para>改完后， 需要在 <filename>/etc/master.passwd</filename> 上运行
	<command>cap_mkdb</command> 命令。</para>
    </sect2>

    <sect2>
      <title>完成配置</title>

      <para>现在需要创建一个 contexts 文件；
	下面的例子来自 Robert Watson 的策略示例， 应放到
	<filename>/etc/policy.contexts</filename> 中。</para>

      <programlisting># 这是系统中的默认 BIBA/MLS 策略。

.*                              biba/high,mls/high
/sbin/dhclient                  biba/high(low),mls/high(low)
/dev(/.*)?                      biba/equal,mls/equal
# This is not an exhaustive list of all "privileged" devices.
/dev/mdctl                      biba/high,mls/high
/dev/pci                        biba/high,mls/high
/dev/k?mem                      biba/high,mls/high
/dev/io                         biba/high,mls/high
/dev/agp.*                      biba/high,mls/high
(/var)?/tmp(/.*)?               biba/equal,mls/equal
/tmp/\.X11-unix                 biba/high(equal),mls/high(equal)
/tmp/\.X11-unix/.*              biba/equal,mls/equal
/proc(/.*)?                     biba/equal,mls/equal
/mnt.*                          biba/low,mls/low
(/usr)?/home                    biba/high(low),mls/high(low)
(/usr)?/home/.*                 biba/low,mls/low
/var/mail(/.*)?                 biba/low,mls/low
/var/spool/mqueue(/.*)?         biba/low,mls/low
(/mnt)?/cdrom(/.*)?             biba/high,mls/high
(/usr)?/home/(ftp|samba)(/.*)?  biba/high,mls/high
/var/log/sendmail\.st           biba/low,mls/low
/var/run/utmp                   biba/equal,mls/equal
/var/log/(lastlog|wtmp)         biba/equal,mls/equal</programlisting>

      <para>这个策略将通过在信息的上下行流上，
	根据左边列出的工具和目录实施限制来强制安全。</para>

      <para>可以通过下面的命令将其读入我们的系统：</para>

      <screen>&prompt.root; <userinput>setfsmac -ef /etc/policy.contexts /</userinput>
&prompt.root; <userinput>setfsmac -ef /etc/policy.contexts /usr</userinput></screen>

      <note>
	<para>上述文件系统布局， 可能随环境而略有不同。</para>
      </note>

      <para>在 <filename>/etc/mac.conf</filename> 文件中的 main
	小节需要进行下面的修改：</para>

      <programlisting>default_labels file ?biba,?mls
default_labels ifnet ?biba,?mls
default_labels process ?biba,?mls,?partition
default_labels socket ?biba,?mls</programlisting>
    </sect2>

    <sect2>
      <title>对配置进行测试</title>

      <indexterm>
	<primary>MAC 配置测试</primary>
      </indexterm>

      <para>使用 <command>adduser</command> 命令来增加用户，
	并把这个用户放到 <literal>insecure</literal>
	class 中， 以用于测试。</para>

      <para>下面的例子中混合了
	<username>root</username> 和普通用户 tests 的测试结果，
	并使用提示符来区别它们。</para>

      <sect3>
	<title>基本的标签测试</title>

	<screen>&prompt.user; <userinput>getpmac</userinput>
biba/15(15-15),mls/15(15-15),partition/15
&prompt.root; <userinput>setpmac partition/15,mls/equal top</userinput></screen>

	<note>
	  <para>在启动其他 top 进程之前应该首先杀掉我们的这个 top 进程。</para>
	</note>
      </sect3>

      <sect3>
	<title>MAC Seeotheruids 测试</title>

	<screen>&prompt.user; <userinput>ps Zax</userinput>
biba/15(15-15),mls/15(15-15),partition/15  1096 #C:  S      0:00.03 -su (bash)
biba/15(15-15),mls/15(15-15),partition/15  1101 #C:  R+     0:00.01 ps Zax</screen>

	<para>我们应该看不到其他用户的进程。</para>
      </sect3>

      <sect3>
	<title>MAC Partition 测试</title>

	<para>为其他测试禁用 <acronym>MAC</acronym>
	  <literal>seeotheruids</literal> 策略：</para>

	<screen>&prompt.root; <userinput>sysctl security.mac.seeotheruids.enabled=0</userinput>
&prompt.user; <userinput>ps Zax</userinput>
LABEL                                                   PID  TT  STAT      TIME COMMAND
  biba/equal(low-high),mls/equal(low-high),partition/15  1122 #C:  S+     0:00.02 top
  biba/15(15-15),mls/15(15-15),partition/15              1096 #C:  S      0:00.05 -su (bash)
  biba/15(15-15),mls/15(15-15),partition/15              1123 #C:  R+     0:00.01 ps Zax</screen>

	<para>现在所有的用户都应能够看到他们的 partition 中的所有进程了。</para>
      </sect3>

      <sect3>
	<title>测试 Biba 和 MLS 标签</title>

	<screen>&prompt.root; <userinput>setpmac partition/15,mls/equal,biba/high\(high-high\) top</userinput>
&prompt.user; <userinput>ps Zax</userinput>
LABEL                                                   PID  TT  STAT    TIME   COMMAND
  biba/high(high-high),mls/equal(low-high),partition/15   1251 #C:  S+     0:00.02 top
  biba/15(15-15),mls/15(15-15),partition/15               1096 #C:  S      0:00.06 -su (bash)
  biba/15(15-15),mls/15(15-15),partition/15               1157 #C:  R+     0:00.00 ps Zax</screen>

	<para>Biba 策略允许我们读取标签为较高标签的对象。</para>

	<screen>&prompt.root; <userinput>setpmac partition/15,mls/equal,biba/low top</userinput>
&prompt.user; <userinput>ps Zax</userinput>
LABEL                                       PID  TT  STAT      TIME COMMAND
  biba/15(15-15),mls/15(15-15),partition/15  1096 #C:  S      0:00.07 -su (bash)
  biba/15(15-15),mls/15(15-15),partition/15  1226 #C:  R+     0:00.01 ps Zax</screen>

	<para>Biba 策略不允许读取低标签的对象；
	  但 <acronym>MLS</acronym> 允许此类操作。</para>

	<screen>&prompt.user; <userinput>ifconfig bge0 | grep maclabel</userinput>
maclabel biba/low(low-low),mls/low(low-low)
&prompt.user; <userinput>ping -c 1 192.0.34.166</userinput>
PING 192.0.34.166 (192.0.34.166): 56 data bytes
ping: sendto: Permission denied</screen>

	<para>由于这个原因， 用户将无法 ping
	  <hostid role="domainname">example.com</hostid>
	  或其他主机。</para>

	<para>要防止发生这类错误， 需要运行下面的命令：</para>

	<screen>&prompt.root; <userinput>sysctl security.mac.biba.trust_all_interfaces=1</userinput></screen>

	<para>这将把默认的接口标签置为不安全模式，
	  这样就不会强制使用 Biba 策略了。</para>

	<screen>&prompt.root; <userinput>ifconfig bge0 maclabel biba/equal\(low-high\),mls/equal\(low-high\)</userinput>
&prompt.user; <userinput>ping -c 1 192.0.34.166</userinput>
PING 192.0.34.166 (192.0.34.166): 56 data bytes
64 bytes from 192.0.34.166: icmp_seq=0 ttl=50 time=204.455 ms
--- 192.0.34.166 ping statistics ---
1 packets transmitted, 1 packets received, 0% packet loss
round-trip min/avg/max/stddev = 204.455/204.455/204.455/0.000 ms</screen>

	<para>通过设置更为正确的标签， 我们就能够发出
	  <command>ping</command> 请求了。</para>

	<para>现在建立几个文件来测试一下读写操作：</para>

	<screen>&prompt.root; <userinput>touch test1 test2 test3 test4 test5</userinput>
&prompt.root; <userinput>getfmac test1</userinput>
test1: biba/equal,mls/equal
&prompt.root; <userinput>setfmac biba/low test1 test2; setfmac biba/high test4 test5; \
  setfmac mls/low test1 test3; setfmac mls/high test2 test4</userinput>
&prompt.root; <userinput>setfmac mls/equal,biba/equal test3 && getfmac test?</userinput>
test1: biba/low,mls/low
test2: biba/low,mls/high
test3: biba/equal,mls/equal
test4: biba/high,mls/high
test5: biba/high,mls/equal
&prompt.root; <userinput>chown testuser:testuser test?</userinput></screen>

	<para>所有这些文件应属于
	  <username>testuser</username> 用户。
	  现在测试一下读操作：</para>

	<screen>&prompt.user; <userinput>ls</userinput>
test1   test2   test3   test4   test5
&prompt.user; <userinput>ls test?</userinput>
ls: test1: Permission denied
ls: test2: Permission denied
ls: test4: Permission denied
test3   test5</screen>

	<para>没有允许我们 observe pairs； 例如：
	  <literal>(biba/low,mls/low)</literal>，
	  <literal>(biba/low,mls/high)</literal> 以及
	  <literal>(biba/high,mls/high)</literal>。
	  因此， 很显然读操作应该被拒绝。
	  现在测试一下写操作：</para>

	<screen>&prompt.user; <userinput>for i in `echo test*`; do echo 1 > $i; done</userinput>
-su: test1: Permission denied
-su: test4: Permission denied
-su: test5: Permission denied</screen>

	<para>和读操作的尝试类似， write pairs 不应允许这类操作； 例如：
	  <literal>(biba/low,mls/high)</literal> 和
	  <literal>(biba/equal,mls/equal)</literal>。</para>

	<screen>&prompt.user; <userinput>cat test?</userinput>
cat: test1: Permission denied
cat: test2: Permission denied
1
cat: test4: Permission denied</screen>

	<para>现在以 <username>root</username> 身份进行：</para>

	<screen>&prompt.root; <userinput>cat test2</userinput>
1</screen>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="MAC-examplehttpd">
    <title>另一个例子： 使用 MAC 来约束 Web 服务器</title>

      <para>将配置一个独立的位置来保存 web 数据，
	并只允许特定的用户来访问。 这样，
	拥有 <literal>biba/high</literal> 的进程就能够访问 web 数据了。</para>

      <para>首先需要创建一个用于保存 web 数据的目录：</para>

      <screen>&prompt.root; <userinput>mkdir /usr/home/cvs</userinput></screen>

      <para>接下来使用 <command>cvs</command> 来对其进行初始化：</para>

      <screen>&prompt.root; <userinput>cvs -d /usr/home/cvs init</userinput></screen>

      <para>第一件事是启用 <literal>biba</literal>
	策略， 因此应把 <literal>mac_biba_enable="YES"</literal>
	加入到 <filename>/boot/loader.conf</filename>。
	当然， 这样做的前提是在内核中启用了 <acronym>MAC</acronym> 支持。</para>

      <para>从现在开始， 整个系统中的所有对象，
	都会默认设置为 <literal>biba/high</literal>。</para>

      <para>必须在 <filename>login.conf</filename> 中的 default (默认) 用户
	class 上进行下列修改：</para>

      <programlisting>:ignoretime@:\
	:umask=022:\
	:label=biba/high:</programlisting>

      <para>现在每个用户都需要放到 default class 中；
	类似下面的命令：</para>

      <screen>&prompt.root; <userinput>for x in `awk -F: '($3 >= 1001) && ($3 != 65534) { print $1 }' \</userinput>
	<userinput>/etc/passwd`; do pw usermod $x -L default; done;</userinput></screen>

      <para>可以很快地完成这个工作。</para>

      <para>接下来建立另一个 class， web， 它是 default 的一个副本，
	但将标签设置为 <literal>biba/low</literal>。</para>

      <para>建立一个用于在 <application>cvs</application> 中的主 web
	库的数据上工作的用户。 这个用户必须被放到我们新建立的那个登录
	class， <username>web</username> 中。</para>

      <para>由于所有地方的默认值都是 <literal>biba/high</literal>，
	因此库也是一样的。 web 数据必须同样地被用户读写；
	然而， 由于我们的 web 服务器将要提供
	<literal>biba/high</literal> 用户需要访问的数据，
	因此必须将所有这些数据降级。</para>

      <para>完成这些事情的最好工具是 &man.sh.1; 和
	&man.cron.8;， 它们已经由 &os; 提供了。
	下面的脚本将完成全部所需的工作：</para>

      <programlisting>PATH=/bin:/usr/bin:/usr/local/bin; export PATH;
CVSROOT=/home/repo; export CVSROOT;
cd /home/web;
cvs -qR checkout -P htdocs;
exit;</programlisting>

      <note>
	<para>很多时候， <command>cvs</command>
	  Id tag 必须放到 web 站点的数据文件中。</para>
      </note>

      <para>现在可以把这个脚本放到
	<username>web</username> 的主目录中， 并增加下面的
	&man.crontab.1; 项：</para>

      <programlisting># Check out the web data as biba/low every twelve hours:
0       */12       *       *       *       web    /home/web/checkout.sh</programlisting>

      <para>这样， 这台机器上每十二小时都会检出一次
	<acronym>HTML</acronym> 源代码。</para>

      <para>Web 服务器的默认启动方式也必须进行修改，
	以便以 <literal>biba/low</literal> 来启动服务。
	这可以通过对
	<filename>/usr/local/etc/rc.d/apache.sh</filename>
	脚本进行下面的修改来完成：</para>

      <programlisting>command="setpmac biba/low /usr/local/sbin/httpd"</programlisting>

      <para><application>Apache</application> 配置必须进行修改，
	以便在 <literal>biba/low</literal> 策略下工作。
	因为这时软件必须配置为在设置了 <literal>biba/low</literal>
	的目录中记录日志， 否则将返回 <errorname>access denied</errorname>
	错误。</para>

      <note>
	<para>完全按照上面的例子进行配置的话，
	  <literal>docroot</literal> 应被设置为
	  <filename>/home/web/htdocs</filename>； 否则，
	  <application>Apache</application>
	  将无法查找其提供文档的目录。</para>
      </note>

      <para>同时， 也需要修改一些其他的配置变量，
	包括 <acronym>PID</acronym> 文件，
	<literal>Scoreboardfile</literal>，
	<literal>DocumentRoot</literal>、 日志文件的位置，
	以及其他需要写权限的配置。
	使用 <literal>biba</literal>  时，
	所有发生在 <emphasis>没有</emphasis> 配置为
	<literal>biba/low</literal> 的写操作都会失败。</para>
<!--
PROBLEM: CAN THIS WORK?  OR SHOULD IT BE start_precmd?  More testing need here.
-->
  </sect1>

<!--
XXX

  <sect1 id="mac-examplesandbox">
    <title>An Example of a MAC Sandbox</title>

    <para>An example of placing users in a sandbox using
      <acronym>MAC</acronym> should go here.</para>
  </sect1>
-->

  <sect1 id="mac-troubleshoot">
    <title>MAC 框架的故障排除</title>

    <indexterm>
      <primary>MAC 故障排除</primary>
    </indexterm>

    <para>在开发过程中， 有一些用户报告了正常配置下出现的问题。
      其中的一些问题如下所示：</para>

    <sect2>
      <title>无法在 <filename>/</filename> 上启用
	<option>multilabel</option> 选项</title>

      <para><option>multilabel</option> 标志在根 (<filename>/</filename>)
	分区上没有保持启用状态！</para>


      <para>看起来每五十个用户中就有一个遇到这样的问题，
	当然， 在我们的初始配置过程中也出现过这样的问题。
	更进一步的观察使得我相信这个所谓的
	<quote>bug</quote> 是由于文档中不确切的描述，
	或对其产生的误解造成的。 无论它是因为什么引发的，
	下面的步骤应该能够解决此问题：</para>

      <procedure>
	<step>
	  <para>编辑 <filename>/etc/fstab</filename> 并将根分区设置为
	    <option>ro</option>， 表示只读。</para>
	</step>

	<step>
	  <para>重新启动并进入单用户模式。</para>
	</step>

	<step>
	  <para>在 <filename>/</filename> 上运行
	    <command>tunefs</command> <option>-l enable</option></para>
	</step>

	<step>
	  <para>重新启动并进入正常的模式。</para>
	</step>

	<step>
	  <para>运行 <command>mount</command> <option>-urw</option>
	  <filename>/</filename> 并把 <filename>/etc/fstab</filename>
	  中的 <option>ro</option> 改回 <option>rw</option>，
	  然后再次重新启动。</para>
	</step>

	<step>
	  <para>再次检查来自
	  <command>mount</command> 的输出， 已确认根文件系统上正确地设置了
	  <option>multilabel</option>。</para>
	</step>
     </procedure>
    </sect2>

    <sect2>
      <title>在 <acronym>MAC</acronym> 之后无法启动 X11 了</title>

      <para>在使用 <acronym>MAC</acronym> 建立安全的环境之后， 就无法启动
	X 了！</para>

      <para>这可能是由于 <acronym>MAC</acronym>
	<literal>partition</literal> 策略， 或者对某个
	<acronym>MAC</acronym> 标签策略进行了错误的配置导致的。
	要调试这个问题， 请尝试：</para>

      <procedure>
	<step>
	  <para>检查错误信息； 如果用户是在
	    <literal>insecure</literal> class 中， 则
	    <literal>partition</literal> 策略就可能导致问题。
	    尝试将用户的 class 重新改为
	    <literal>default</literal> class，
	    并使用 <command>cap_mkdb</command> 命令重建数据库。
	    如果这无法解决问题， 则进入第二步。</para>
	</step>

	<step>
	  <para>仔细检查标签策略。 确认针对有问题的用户的策略是正确的， 特别是
	    X11 应用， 以及 <filename class="directory">/dev</filename>
	    项。</para>
	</step>

	<step>
	  <para>如果这些都无法解决问题， 将出错消息和对您的环境的描述，
	    发送到 <ulink url="http://www.TrustedBSD.org">TrustedBSD</ulink>
	    网站上的 TrustedBSD 讨论邮件列表，
	    或者 &a.questions; 邮件列表。</para>
	</step>
      </procedure>
    </sect2>

    <sect2>
      <title>Error: &man..secure.path.3; cannot stat <filename>.login_conf</filename></title>

      <para>当我试图从 <username>root</username>
	切换到其同中的其他用户时， 出现了错误提示
	<errorname>_secure_path: unable to state .login_conf</errorname>。</para>

      <para>这个提示通常在用户拥有高于它将要成为的那个用户的
	标签设定时出现。 例如， 如果系统上的一个用户
	<username>joe</username> 拥有默认的
	<option>biba/low</option> 标签， 而 <username>root</username> 用户拥有
	<option>biba/high</option>， 它也就不能查看
	<username>joe</username> 的主目录，
	无论 <username>root</username> 是否使用了
	<command>su</command> 来成为 <username>joe</username>。
	这种情况下， Biba 完整性模型，
	就不会允许 <username>root</username> 查看在较低完整性级别中的对象。</para>
    </sect2>

    <sect2>
      <title><username>root</username> 用户名被破坏了！</title>

      <para>在普通模式， 甚至是单用户模式中，
	<username>root</username> 不被识别。
	<command>whoami</command> 命令返回了 0 (零) 而
	<command>su</command> 则提示 <errorname>who are you?</errorname>。
	到底发生了什么？</para>

      <para>标签策略被禁用可能会导致这样的问题，
	无论是通过 &man.sysctl.8; 或是卸载了策略模块。
	如果打算禁用策略， 或者临时禁用它，
	则登录性能数据库需要重新配置，
	在其中删除 <option>label</option> 选项。
	仔细检查 <filename>login.conf</filename>
	以确保所有的 <option>label</option> 选项都已经删除， 然后使用
	<command>cap_mkdb</command> 命令来重建数据库。</para>
    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
