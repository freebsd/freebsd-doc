<!--
     The FreeBSD Documentation Project
     The FreeBSD Simplified Chinese Project

     Original Revision: 1.241
     $FreeBSD$
-->

<chapter id="disks">
  <title>存储</title>

  <sect1 id="disks-synopsis">
    <title>概述</title>


    <para>这章介绍了 FreeBSD 中磁盘的使用方法。包括内存盘，
    网络附属磁盘和标准的 SCSI/IDE 存储设备，以及使用 USB 的设备。</para>

    <para>读完这章，您将了解到：</para>
    <itemizedlist>
      <listitem><para>FreeBSD 中用来描述硬盘上数据组织的术语 (partitions and slices)。</para>
      </listitem>
      <listitem><para>如何在您的系统上增加硬盘。</para>
      </listitem>
      <listitem>
	<para>如何配置 &os; 来使用 USB 存储设备。</para>
      </listitem>
      <listitem><para>如何设置虚拟文件系统，例如内存磁盘。</para></listitem>
      <listitem>
	<para>如何使用配额来限制磁盘空间的使用。</para>
      </listitem>
      <listitem>
	<para>如何增加磁盘安全来预防功击。</para>
      </listitem>
      <listitem>
	<para>如何刻录 CD 和 DVD 。</para>
      </listitem>
      <listitem>
        <para>用于备份的多种存储媒介。</para>
      </listitem>
      <listitem>
        <para>如何在 FreeBSD 上使用备份程序。</para>
      </listitem>
      <listitem>
        <para>如何备份到软磁盘。</para>
      </listitem>
      <listitem>
        <para>文件系统快照是什么， 以及如何有效地使用它们。</para>
      </listitem>
    </itemizedlist>

    <para>在读这章之前，您应该：</para>

    <itemizedlist>
      <listitem>
        <para>知道怎样去配置和安装新的 FreeBSD 内核
          (<xref linkend="kernelconfig">).</para>
      </listitem>
    </itemizedlist>

  </sect1>

  <sect1 id="disks-naming">
    <title>设备命名</title>

    <para>下面是在 FreeBSD 上被支持的物理存储设备和它们被分配的设备名。</para>

    <table id="disk-naming-physical-table" frame="none">
      <title>物理磁盘命名规则</title>

      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>驱动器类型</entry>
	    <entry>驱动设备命名</entry>
	  </row>
	</thead>
	<tbody>
	  <row>
	    <entry>IDE hard drives</entry>
	    <entry><literal>ad</literal></entry>
	  </row>
	  <row>
	    <entry>IDE CDROM drives</entry>
	    <entry><literal>acd</literal></entry>
	  </row>
	  <row>
	    <entry>SCSI hard drives and USB Mass storage devices</entry>
	    <entry><literal>da</literal></entry>
	  </row>
	  <row>
	    <entry>SCSI CDROM drives</entry>
	    <entry><literal>cd</literal></entry>
	  </row>
	  <row>
	    <entry>Assorted non-standard CDROM drives</entry>
	    <entry><literal>mcd</literal> for Mitsumi CD-ROM,
	      <literal>scd</literal> for Sony CD-ROM,
	      <literal>matcd</literal> for Matsushita/Panasonic CD-ROM
		<footnote>
		  <para>&man.matcd.4; 驱动已经在 2002 年 10 月 5 日从
		    FreeBSD&nbsp;4.X 分支删去， FreeBSD&nbsp;5.0
		    和之后的版本不再包含此驱动。</para>
		</footnote>
	    </entry>
	  </row>
	  <row>
	    <entry>Floppy drives</entry>
	    <entry><literal>fd</literal></entry>
	  </row>
	  <row>
	    <entry>SCSI tape drives</entry>
	    <entry><literal>sa</literal></entry>
            </row>
	  <row>
	    <entry>IDE tape drives</entry>
	    <entry><literal>ast</literal></entry>
	  </row>
	  <row>
	    <entry>Flash drives</entry>
	    <entry><literal>fla</literal> for &diskonchip; Flash device</entry>
	  </row>
	  <row>
	    <entry>RAID drives</entry>
	    <entry><literal>aacd</literal> for &adaptec; AdvancedRAID,
	      <literal>mlxd</literal> and <literal>mlyd</literal>
	      for &mylex;,
	      <literal>amrd</literal> for AMI &megaraid;,
	      <literal>idad</literal> for Compaq Smart RAID,
	      <literal>twed</literal> for &tm.3ware; RAID.</entry>
	  </row>
	</tbody>
      </tgroup>
    </table>
  </sect1>

  <sect1 id="disks-adding">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>David</firstname>
	  <surname>O'Brien</surname>
	  <contrib>Originally contributed by </contrib>
	</author>
      </authorgroup>
      <!-- 26 Apr 1998 -->
    </sect1info>

    <title>添加磁盘</title>

    <indexterm>
      <primary>磁盘</primary>
      <secondary>添加</secondary>
    </indexterm>

    <para>假设我们要给一台只有一个磁盘的机器增加一个新的 SCSI 磁盘。首先
    需要关掉计算机，然后按操作规程来安装驱动器，控制器和驱动程序。由于
    各厂家生产的产品各不相同，具体的安装细节不在此文档介绍之内。</para>

    <para>以 <username>root</username> 用户登录。安装完驱动后，检查一下
    <filename>/var/run/dmesg.boot</filename> 有没有找到新的磁盘。在我们
    的例子中新增加的磁盘就是 <devicename>da1</devicename>，我们从
      <filename>/1</filename> 挂上它。 (如果您正添加一个 IDE 驱动器，在
      4.0 版以前的系统里是 <devicename>wd1</devicename>，以后的版本的系
      统里是 <devicename>ad1</devicename> )。</para>

    <indexterm><primary>
    partitions</primary></indexterm>
    <indexterm><primary>slices</primary></indexterm>
    <indexterm>
      <primary><command>fdisk</command></primary>
    </indexterm>

    <para>因为 FreeBSD 运行在 IBM-PC 兼容机上，它必须遵循 PC BIOS 分区
    规范。这与传统的 BSD 分区是不同的。一个 PC 的磁盘最高只能有四个 BIOS
    主分区。如果磁盘只安装 FreeBSD 您可以使用 <emphasis>dedicated</emphasis> 
    模式。另外， FreeBSD 必须安装在 PC BIOS 支持的分区内。FreeBSD 把分区叫作
     <emphasis>slices</emphasis> 这可能会把人搞糊涂。您也可以在只安装
     FreeBSD 的磁盘上使用 slices，也可以在安装有其它操作系统的磁盘上使用
     slices。这不会影响其它操作系统的 <command>fdisk</command> 分区工具。
      </para>

    <para>在 slice 方式表示下，驱动器被添加到 <filename>/dev/da1s1e</filename>。
    可以读作：SCSI 磁盘，编号为 1 (第二个SCSI 磁盘)， slice 1 (PC BIOS 分区 1)，
      的 BSD 分区 <filename>e</filename> 。在有些例子中，也可以简化为
      <filename>/dev/da1e</filename>。</para>

    <para>由于 &man.bsdlabel.8; (在 &os;&nbsp;4.X 中叫做 &man.disklabel.8;)
      使用 32-位 的整数来表示扇区号， 因此在多数情况下它的表现力限于每个磁盘
      2^32-1 个扇区或 2TB。 &man.fdisk.8; 格式允许的起始扇区号不能高于
      2^32-1 而分区长度也不能大于 2^32-1， 通常情况下这限制了分区大小最大为
      2TB 而磁盘大小则是 4TB。 &man.sunlabel.8; 格式的限制是每个分区
      2^32-1 个扇区， 但允许 8 个分区因此最大支持 16TB 的磁盘。
      要使用更大的分区， 则应使用 &man.gpt.8;。</para>

    <sect2>
      <title>使用 &man.sysinstall.8;</title>
      <indexterm>
        <primary><application>sysinstall</application></primary>
        <secondary>adding disks</secondary>
      </indexterm>
      <indexterm>
	<primary>su</primary>
      </indexterm>
      <procedure>
	<step>
	  <title>使用 <application>Sysinstall</application></title>

	  <para>您可以使用 <command>sysinstall</command> 命令
	    (在 &os; 5.2 之前是 <command>/stand/sysinstall</command>)，
	    选择它的使用菜单来分区和标记一个新的磁盘。需要有 root 权限，
	    或者直接使用 <username>root</username> 账户登录或者使用
	    <command>su</command> 命令来切换到根用户。运行
	    <command>sysinstall</command> ，然后选择
	    <literal>Configure</literal> 菜单。在
	    <literal>FreeBSD Configuration Menu</literal> 下，上下滚动，
	    选择 <literal>Fdisk</literal> 条目。</para>
	</step>

	<step>
	  <title><application>fdisk</application> 分区编辑器</title>
	  <para>进入 <application>fdisk</application> 分区编辑器后，选择
	  <userinput>A</userinput> ，FreeBSD 将使用全部的磁盘。当被告知
	  <quote>remain cooperative with any future possible operating
	     systems</quote>时，回答 <literal>YES</literal>。使用
	     <userinput>W</userinput> 保存刚才的修改。现在使用 <userinput>q</userinput>
	     退出 FDISK 编辑器。下面会看到有关 <quote>主引导区</quote>
	     的信息。 现在您已经在运行的系统上添加了一个磁盘，
	     因此应该选择 <literal>None</literal>。</para>
	</step>

	<step>
	  <title>Disk Label 编辑器</title>
	  <indexterm><primary>BSD partitions</primary></indexterm>

	  <para>接下来，您应该退出 <application>sysinstall</application>
            并且再次启动它，并按照上面的步骤直接进入
             <literal>Label</literal> 选项。进入 <literal>磁盘标签编辑器</literal>。
             这就是您要创建的 BSD 分区。一个磁盘最多可以有 8 个分区，标记为
	    <literal>a-h</literal>。有几个分区标签有特殊的用途。
	    <literal>a</literal> 分区被用来作为根分区(<filename>/</filename>)。
	    系统磁盘（例如：从那儿启动的分区）必须有一个 <literal>a</literal>
	    分区。<literal>b</literal> 分区被用作交换分区，可以用很多磁盘用作交
	    换分区。 <literal>c</literal> 分区代表整个硬盘，或在 FreeBSD slice
	    模式下代表整个 slice。其它分区作为一般分区来使用。</para>

	  <para><application>sysinstall</application> 的标签编辑器用 <literal>e</literal>
	    表示非 root 和非 swap 分区。在标签编辑器中，可以使用键入<userinput>C</userinput>
	    创建一个文件系统。当提示这是否是一个 FS（文件系统）或 swap 时，选择
	    <literal>FS</literal>，然后给出一个加载点（如： <filename>/mnt</filename>）。
	    当在 post-install 模式时添加一个磁盘， <application>sysinstall</application>
	    不会在 <filename>/etc/fstab</filename> 中创建记录，所以是否指定加载点并不重要。
	    </para>

	  <para>现在已经准备把新标签写到磁盘上，然后创建一个文件系统，可以按下
	    <userinput>W</userinput>。出现任何错误都会不能创建新的分区。可以退出标签编辑
	    器然后重新执行 <application>sysinstall</application> 。</para>
	</step>

	<step>
	  <title>完成</title>

	  <para>下面一步就是编辑 <filename>/etc/fstab</filename>，为您的磁盘添加一个新
	    记录。</para>
	</step>
      </procedure>
    </sect2>

    <sect2>
      <title>使用命令行工具</title>

      <sect3>
	<title>使用 Slices</title>

	<para>这步安装将允许磁盘与可能安装在您计算机上的其它操作系统一起
	  正确工作，而不会搞乱其它操作系统的分区。推荐使用这种方法来安装
	  新磁盘，除非您有更好的理由再使用 <literal>dedicated</literal> 
	  模式！</para>

	<screen>&prompt.root; <userinput>dd if=/dev/zero of=/dev/da1 bs=1k count=1</userinput>
&prompt.root; <userinput>fdisk -BI da1</userinput> #初始化新磁盘
&prompt.root; <userinput>disklabel -B -w -r da1s1 auto</userinput> #加上标签
&prompt.root; <userinput>disklabel -e da1s1</userinput> # 现在编辑您刚才创建的磁盘分区
&prompt.root; <userinput>mkdir -p /1</userinput>
&prompt.root; <userinput>newfs /dev/da1s1e</userinput> # 为您创建的每个分区重复这个操作
&prompt.root; <userinput>mount /dev/da1s1e /1</userinput> # 挂上分区
&prompt.root; <userinput>vi /etc/fstab</userinput> # 完成之后，添加合适的记录到您的 <filename>/etc/fstab</filename>文件。</screen>

	<para>如果有一个 IDE 磁盘，记得要用 <filename>ad</filename>
	  来替换 <filename>da</filename>，4.X 以前的系统要用 <filename>wd</filename>。</para>
      </sect3>

      <sect3>
	<title>专用模式</title>
	<indexterm><primary>OS/2</primary></indexterm>

	<para>如果您并没有安装其它的操作系统，可以使用 <literal>dedicated</literal> 
	  模式。记住这种模式可能会弄乱 Microsoft 的操作系统，但不会对它进行破坏。
	  它不识别找到的 IBM &os2 的 <quote>appropriate</quote> 分区。</para>

	<screen>&prompt.root; <userinput>dd if=/dev/zero of=/dev/da1 bs=1k count=1</userinput>
&prompt.root; <userinput>disklabel -Brw da1 auto</userinput>
&prompt.root; <userinput>disklabel -e da1</userinput>				# 创建 `e' 分区
&prompt.root; <userinput>newfs -d0 /dev/da1e</userinput>
&prompt.root; <userinput>mkdir -p /1</userinput>
&prompt.root; <userinput>vi /etc/fstab</userinput>				# 为 /dev/da1e添加一个记录
&prompt.root; <userinput>mount /1</userinput></screen>

	<para>另一种方法：</para>

	<screen>&prompt.root; <userinput>dd if=/dev/zero of=/dev/da1 count=2</userinput>
&prompt.root; <userinput>disklabel /dev/da1 | disklabel -BrR da1 /dev/stdin</userinput>
&prompt.root; <userinput>newfs /dev/da1e</userinput>
&prompt.root; <userinput>mkdir -p /1</userinput>
&prompt.root; <userinput>vi /etc/fstab</userinput>					# 为 /dev/da1e添加一个记录
&prompt.root; <userinput>mount /1</userinput></screen>

	<note><para>从 &os;&nbsp;5.1-RELEASE 版本开始， &man.bsdlabel.8; 程序代替了
	  老版本的 &man.disklabel.8; 程序。&man.bsdlabel.8; 中大量过时的选项
	  和参数也被取消。在上面的例子中选项 <option>-r</option> 可以使用
	  &man.bsdlabel.8;程序来删除。更多的信息，请参考 &man.bsdlabel.8; 手册页。
	  </para></note>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="raid">
    <title>RAID</title>

    <sect2 id="raid-soft">
      <title>软件 RAID</title>

      <sect3 id="ccd">
	<sect3info>
	  <authorgroup>
	    <author>
	      <firstname>Christopher</firstname>
	      <surname>Shumway</surname>
	      <contrib>Original work by </contrib>
	    </author>
	  </authorgroup>
	  <authorgroup>
	    <author>
	      <firstname>Jim</firstname>
	      <surname>Brown</surname>
	      <contrib>Revised by </contrib>
	    </author>
	  </authorgroup>
	</sect3info>

<indexterm><primary>RAID</primary><secondary>software</secondary></indexterm>
<indexterm>
  <primary>RAID</primary><secondary>CCD</secondary>
</indexterm>

	<title>连接磁盘驱动器配置 (CCD) </title>
	<para>选择一个大容量存储比较好的解决方案，最重要的因素是产品的速度、
	  性能和成本。通常这三者不可能都满足;要获得比较快和可靠的大容量存储
	  设备，就比较昂贵。但如果将成本降下来，那它的速度或可靠性就会打折扣。
	  </para>

          <para>在设计下面描述的系统时，价格被选为最重要的因素，接下来是速度
            和性能。这人系统的数据传输速度及大的取决于网络。性能也非常重要，
            CCD 驱动器上的所有数据都被备份到了 CD-R 盘，可以很容易的对数据进行恢复。
            </para>  

          <para>在选择一个大容量的存储解决方案时，第一步是要设计您自己的需求。
            如果您的需求更偏重于速度和性能，那么您的解决方案将就不同于上面的设计。
          </para>

	<sect4 id="ccd-installhw">
	  <title>安装硬件</title>

	  <para>除了 IDE 系统磁盘外，还有三个 Western Digital 30GB、5400 RPM
	    的 IDE 磁盘构成了大约 90G 的连接磁盘驱动存储空间。最好是每个 IDE 硬盘
	    都使用一个自己的 IDE 控制器和数据线，为了降低成本，没有使用更多的
	    IDE 控制器，取而代之配置跳线使每个 IDE 控制器都拥有一个主盘和一个
	    从盘。</para>

	  <para>重启动后，系统 BIOS 被配置成自动检测硬盘。FreeBSD 检测到它们：</para>

	  <programlisting>ad0: 19574MB &lt;WDC WD205BA&gt; [39770/16/63] at ata0-master UDMA33
ad1: 29333MB &lt;WDC WD307AA&gt; [59598/16/63] at ata0-slave UDMA33
ad2: 29333MB &lt;WDC WD307AA&gt; [59598/16/63] at ata1-master UDMA33
ad3: 29333MB &lt;WDC WD307AA&gt; [59598/16/63] at ata1-slave UDMA33</programlisting>

 	  <note><para>如果 FreeBSD 没有检测到它们，请确定它们的跳线是否设置
 	    正确。大多数 IDE 磁盘有一个 <quote>Cable Select</quote> 跳线。这个
 	     <emphasis>不是</emphasis> 设置 master/slave 硬盘的跳线。查阅文档
 	     信息来确定正确的跳线设置。</para></note>
 
 	  <para>接下来考虑的是，如何创建文件系统。应该好好研究一下 &man.vinum.8; (<xref
 	    linkend="vinum-vinum">)和 &man.ccd.4; 两种方式，在这里我们选择 &man.ccd.4;
 	    </para>
	</sect4>

	<sect4 id="ccd-setup">
	  <title>安装 CCD</title>

 	  <para>&man.ccd.4; 允许用户将几个相同的的磁盘通过一个逻辑文件系统
 	    连接起来。要使用 &man.ccd.4;，您需要在内核中配置 &man.ccd.4; 
 	    支持选项。把这行加入到内核配置文件中，然后重建内核：</para>

	  <programlisting>pseudo-device   ccd     4</programlisting>

	  <para>在 5.X 和以后的版本中，您必须使用下面的行来代替：</para>

	  <programlisting>device   ccd</programlisting>

	  <note><para>在 FreeBSD&nbsp;5.X 里，不必指定一系统的 &man.ccd.4; 设备，
	    &man.ccd.4; 设备将自动按需要创建新的 &mdash; 设备。</para></note>

	  <para>&man.ccd.4; 在FreeBSD 3.0 或以后的版本中也可以作为一个内核模块
	    来加载</para>

 	  <para>要安装 &man.ccd.4;, 首先需要使用 &man.disklabel.8; 来编辑硬盘：</para>

	  <programlisting>disklabel -r -w ad1 auto
disklabel -r -w ad2 auto
disklabel -r -w ad3 auto</programlisting>

 	  <para>这儿把整个硬盘创建成 <devicename>ad1c</devicename>, <devicename>ad2c</devicename> 
 	  和 <devicename>ad3c</devicename> 。</para>

	  <note><para>从 &os;&nbsp;5.1-RELEASE 开始， &man.bsdlabel.8; 程序代替
	    了老版本的 &man.disklabel.8; 程序。&man.bsdlabel.8; 中大量过时的选项
	    和参数也被取消; 在上面的例子中，选项 <option>-r</option> 应该被删掉。
	    更的信息可以参考 &man.bsdlabel.8; 手册。</para></note>

 	  <para>下一步是改变 disklable 的类型。也可以使用 &man.disklabel.8; 来编辑：
 	    </para>

	  <programlisting>disklabel -e ad1
disklabel -e ad2
disklabel -e ad3</programlisting>

 	  <para>这儿在每个已经设置了 <envar>EDITOR</envar> 环境变量的磁盘上打开了
 	    disklable，在我我例子中使用的是 &man.vi.1;。</para>

	  <para>可以看到：</para>

	  <programlisting>8 partitions:
#        size   offset    fstype   [fsize bsize bps/cpg]
  c: 60074784        0    unused        0     0     0   # (Cyl.    0 - 59597)</programlisting>

 	  <para>添加一个新的 <literal>e</literal> 分区给 &man.ccd.4; 用。这可以是
 	    <literal>c</literal> 分区的一个拷贝，但 <option>fstype</option> <emphasis>必须</emphasis>
 	    是 <userinput>4.2BSD</userinput>。做完之后，您会看到一面这些：</para>

	  <programlisting>8 partitions:
#        size   offset    fstype   [fsize bsize bps/cpg]
  c: 60074784        0    unused        0     0     0   # (Cyl.    0 - 59597)
  e: 60074784        0    4.2BSD        0     0     0   # (Cyl.    0 - 59597)</programlisting>

	</sect4>

	<sect4 id="ccd-buildingfs">
	  <title>建立文件系统</title>

            <para><devicename>ccd0c</devicename> 的设备节点可能不存在，所以要
              创建它，执行下面的命令：</para>

	  <programlisting>cd /dev
sh MAKEDEV ccd0</programlisting>

	  <note><para>在 FreeBSD 5.0 中，&man.devfs.5; 将自动管理在 <filename>/dev</filename>,
	    里的设备结点，所以没有必要使用 <command>MAKEDEV</command> 命令。</para></note>

	  <para>现在已给每个磁盘都加上了标签，下面需要建立 &man.ccd.4;。要这样做，
	    需要使用 &man.ccdconfig.8; 工具，同时要提供类似下面的选项：</para>

	    <programlisting>ccdconfig ccd0<co id="co-ccd-dev"> 32<co id="co-ccd-interleave"> 0<co id="co-ccd-flags"> /dev/ad1e<co id="co-ccd-devs"> /dev/ad2e /dev/ad3e</programlisting>

	  <para>每个选项的意义和用法如下所示：</para>

          <calloutlist>
            <callout arearefs="co-ccd-dev">
	    <para>配置设备的第一个参数，在这是 <filename>/dev/ccd0c</filename>。
	      <filename>/dev/</filename> 部分是任选项。</para>
            </callout>

            <callout arearefs="co-ccd-interleave">

	    <para>下一个参数是文件系统的插入页(interleave)。插入页定义了一个
	      磁盘块中一个分段或条带(stripe)的大小，通常是 512 个字节。所以一个为
	      32 的插入页将是 16,384 字节。</para>
            </callout>

            <callout arearefs="co-ccd-flags">
	    <para>插入页为 &man.ccdconfig.8; 附带了标记。如果您要启用驱动器镜像，
	      需要在这儿指定它。在这个配置中没有做 &man.ccd.4; 的镜像，所以把它
	      设为 0 (zero)。</para>
            </callout>

            <callout arearefs="co-ccd-devs">
	    <para> &man.ccdconfig.8; 的最后配置是设备的排列问题。使用完整的设备
	      路径名。</para>
            </callout>
          </calloutlist>


	  <para>运行 &man.ccdconfig.8; 后 &man.ccd.4; 就配置好了。现在要创建文件
	    系统了，参考 &man.newfs.8; 选项，执行下同的命令： </para>

	  <programlisting>newfs /dev/ccd0c</programlisting>


	</sect4>

	<sect4 id="ccd-auto">
	  <title>自动创建</title>

	  <para>最后，要挂上 &man.ccd.4; ，需要先配置它。把当前的配置文件写入
	    <filename>/etc/ccd.conf</filename> 中，使用下面的命令：</para>

	  <programlisting>ccdconfig -g &gt; /etc/ccd.conf</programlisting>

	  <para>当重新启动系统时，如果 <filename>/etc/ccd.conf</filename> 存在，
	    脚本 <command>/etc/rc</command> 就运行 <command>ccdconfig -C</command>。
	    这样就能自动配置 &man.ccd.4; 以到它能被挂上。</para>

	  <note><para>如果启动进入了单用户模式，在 &man.mount.8; 上 &man.ccd.4;
	    之前，需要执行下面的命令来配置队列：</para>

	  <programlisting>ccdconfig -C</programlisting>
          </note>

	  <para>要自动挂接 &man.ccd.4;,需要为 &man.ccd.4; 在
	    <filename>/etc/fstab</filename> 中配置一个记录，以便在启动时它能被挂上。
	    如下所示：</para>

	  <programlisting>/dev/ccd0c              /media       ufs     rw      2       2</programlisting>
	</sect4>
      </sect3>

      <sect3 id="vinum">
	<title> Vinum 卷管理</title>

<indexterm><primary>RAID</primary><secondary>software</secondary></indexterm>
<indexterm>
  <primary>RAID</primary>
  <secondary>Vinum</secondary>
</indexterm>

	<para>Vinum 卷管理是一个实现虚拟磁盘的块驱动设备工具。它使磁盘从
	  块设备的接口和数据映射中独立出来。与传统的存储设备相比，增加了
	  灵活性、性能和可靠性。 &man.vinum.8; 实现了 RAID-0、RAID-1 和 
	  RAID-5 三种模式，它们即可以独立使用，也可组合使用。</para>

	<para>参考 <xref linkend="vinum-vinum"> 得到更多 &man.vinum.8;
	  的信息。</para>
      </sect3>
    </sect2>

    <sect2 id="raid-hard">
      <title>硬件 RAID</title>

      <indexterm>
	<primary>RAID</primary>
	<secondary>hardware</secondary>
      </indexterm>

      <para>FreeBSD 支持很多硬件 <acronym>RAID</acronym> 控制器。
        这些硬件不需要 FreeBSD 指定软件来管理 <acronym>RAID</acronym> 系统。
        </para>

      <para>使用 <acronym>BIOS</acronym> 支持的硬件，一般情况下这些硬件可以自行操作。
	下面是一个简明的描述设置一个 Promise <acronym>IDE</acronym> <acronym>RAID</acronym> 控制器。
	当硬件设备装好且系统重启后，屏幕上显示一个询问信息。接着进入硬件设置屏幕。在这里，
	您可以把所有的磁盘联合在一起使用。这样 FreeBSD 将磁盘看作一个驱动器。其它
	级别的 <acronym>RAID</acronym> 也可以相应的进行设置。
      </para>
    </sect2>

    <sect2>
      <title>重建 ATA RAID1 阵列</title>

      <para>FreeBSD 允许您热插拔阵列中损坏的磁盘。
	在您重新启动系统之前请注意这一点。</para>

      <para>您可能会在 <filename>/var/log/messages</filename> 或者在 &man.dmesg.8;
	的输出中看到类似下面这些的内容：</para>

      <programlisting>ad6 on monster1 suffered a hard error.
ad6: READ command timeout tag=0 serv=0 - resetting
ad6: trying fallback to PIO mode
ata3: resetting devices .. done
ad6: hard error reading fsbn 1116119 of 0-7 (ad6 bn 1116119; cn 1107 tn 4 sn 11)\\
status=59 error=40
ar0: WARNING - mirror lost</programlisting>

      <para>使用 &man.atacontrol.8;，查看更多的信息：</para>

      <screen>&prompt.root; <userinput>atacontrol list</userinput>
ATA channel 0:
	Master:      no device present
	Slave:   acd0 &lt;HL-DT-ST CD-ROM GCR-8520B/1.00&gt; ATA/ATAPI rev 0

ATA channel 1:
	Master:      no device present
	Slave:       no device present

ATA channel 2:
	Master:  ad4 &lt;MAXTOR 6L080J4/A93.0500&gt; ATA/ATAPI rev 5
	Slave:       no device present

ATA channel 3:
	Master:  ad6 &lt;MAXTOR 6L080J4/A93.0500&gt; ATA/ATAPI rev 5
	Slave:       no device present

&prompt.root; <userinput>atacontrol status ar0</userinput>
ar0: ATA RAID1 subdisks: ad4 ad6 status: DEGRADED</screen>

      <procedure>
	<step>
	  <para>您首先需要将磁盘从阵列中移除以便您可以
	    安全的拆除它：</para>

	  <screen>&prompt.root; <userinput>atacontrol detach 3</userinput></screen>
	</step>

	<step>
	  <para>换上磁盘</para>
	</step>

	<step>
	  <para>把磁盘作为备用磁盘安装：</para>

	  <screen>&prompt.root; <userinput>atacontrol attach 3</userinput>
Master:  ad6 &lt;MAXTOR 6L080J4/A93.0500&gt; ATA/ATAPI rev 5
Slave:   no device present</screen>
	</step>

	<step>
	  <para>重建阵列：</para>

	  <screen>&prompt.root; <userinput>atacontrol rebuild ar0</userinput></screen>
	</step>

	<step>
	  <para>rebuild 命令挂起直到完成。然而，可以打开另一个终端
	  (使用 <keycombo action="simul"><keycap>Alt</keycap> <keycap>F<replaceable>n</replaceable></keycap></keycombo>)
          通过下面的命令来检查进程：</para>

	  <screen>&prompt.root; <userinput>dmesg | tail -10</userinput>
[output removed]
ad6: removed from configuration
ad6: deleted from ar0 disk1
ad6: inserted into ar0 disk1 as spare

&prompt.root; <userinput>atacontrol status ar0</userinput>
ar0: ATA RAID1 subdisks: ad4 ad6 status: REBUILDING 0% completed</screen>
	</step>

	<step>
	  <para>等待操作完成。</para>
	</step>
      </procedure>
    </sect2>
  </sect1>

  <sect1 id="usb-disks">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Marc</firstname>
	  <surname>Fonvieille</surname>
	  <contrib>Contributed by </contrib>
	</author>
      </authorgroup>
      <!-- Jul 2004 -->
    </sect1info>

    <title>USB 存储设备</title>
    <indexterm>
      <primary>USB</primary>
      <secondary>disks</secondary>
    </indexterm>

    <para>到目前为止，有许多外部外部存储解决方案，
    例如：通用串行总线 (USB)：硬盘、USB thumbdrives、CD-R burners
    等等。 &os; 为这些设备提供了支持。</para>

    <sect2>
      <title>配置</title>

      <para> USB 大容量存储设备驱动，在 &man.umass.4;,
	中提供了对 USB 存储设备的支持。如果您使用
	<filename>GENERIC</filename> 内核，您不必要改变配置文件里的任何内容。
	如果您使用了定制的内核，就要确定下面的行出现在您的内核配置文件里：</para>

      <programlisting>device scbus
device da
device pass
device uhci
device ohci
device usb
device umass</programlisting>

      <para> &man.umass.4; 驱动程序使用 SCSI 子系统来访问 USB 存储设备，
	您的 USB 设备将被系统看成为一个 SCSI 设备。依靠您主板上的 USB 芯片，
	您只须选择 <literal>device
	uhci</literal> 或 <literal>device ohci</literal> 二者之一即可，
	但是两者都加入内核配置文件当中也没有坏外。
	不要忘了如果您加入了上面的几行要重新编译和安装内核。</para>

      <note>
	<para>如果您的 USB 设备是一个 CD-R 或 DVD 刻录机， SCSI CD-ROM
	  驱动程序， &man.cd.4;, 就必须加入内核中通过下面这行：</para>

	<programlisting>device cd</programlisting>

	<para>因为刻录机被看作一个 SCSI 设备drive, 驱动程序
	  &man.atapicam.4; 不应该在内核配置文件中使用。</para>
      </note>

      <para>从 &os;&nbsp; 5.X 开始， 对 USB 2.0 控制器提供了内建的支持；
	这一特性也被加入到了 &os;&nbsp;4.10-RELEASE 和其后的 4.X 版本。
	要获取对 USB 2.0 的支持， 您需要在内核的编译配置中加入：</para>

      <programlisting>device ehci</programlisting>

      <para>注意， 如果需要 USB 1.X 的支持， 您仍需要使用
	&man.uhci.4; 和 &man.ohci.4; 驱动程序。</para>

      <note>
	<para>在 &os;&nbsp;4.X 上， USB daemon (&man.usbd.8;) 必须能够
	  检测到正在运行的一些 USB 设备。为了启用它，
	  添加 <literal>usbd_enable="YES"</literal> 到您的
	  <filename>/etc/rc.conf</filename> 文件里，然后重新启动
	  计算机。</para>
      </note>
    </sect2>

    <sect2>
      <title>测试配置</title>

      <para>配置好后准备进行测试：插入您的 USB 设备，
	在系统信息中 (&man.dmesg.8;), 应该会出现像下面的设备：</para>

      <screen>umass0: USB Solid state disk, rev 1.10/1.00, addr 2
GEOM: create disk da0 dp=0xc2d74850
da0 at umass-sim0 bus 0 target 0 lun 0
da0: &lt;Generic Traveling Disk 1.11&gt; Removable Direct Access SCSI-2 device
da0: 1.000MB/s transfers
da0: 126MB (258048 512 byte sectors: 64H 32S/T 126C)</screen>

      <para>当然啦，商标，设备标识
	(<devicename>da0</devicename>) 和其它的细节信息会根据您的配置不同
	而有所不同。</para>

      <para>因为 USB 设备被看作 SCSI 设备中的一个，
	<command>camcontrol</command> 命令也能够用来列出
	USB 存储设备和系统的关联：</para>

      <screen>&prompt.root; <userinput>camcontrol devlist</userinput>
&lt;Generic Traveling Disk 1.11&gt;      at scbus0 target 0 lun 0 (da0,pass0)</screen>

      <para>如果设备要作成文件系统，您应该能够挂接它。
	 <xref linkend="disks-adding"> 将帮助您格式化和创建分区在
	 USB 设备上，如果您需要。</para>

      <para>如果您要去摘下设备 (在此这前磁盘必须被 unmount)，
	在系统信息中您能够看到下面的信息：</para>

      <screen>umass0: at uhub0 port 1 (addr 2) disconnected
(da0:umass-sim0:0:0:0): lost device
(da0:umass-sim0:0:0:0): removing device entry
GEOM: destroy disk da0 dp=0xc2d74850
umass0: detached</screen>
    </sect2>

    <sect2>
      <title>深入阅读</title>

      <para>除了 <link linkend="disks-adding">Adding
	Disks</link> 和 <link linkend="mount-unmount">Mounting and
	Unmounting File Systems</link> 章之外，阅读
	 &man.umass.4;,	&man.camcontrol.8;, 和 &man.usbdevs.8;
	 也是很有益的。</para>
    </sect2>
  </sect1>

  <sect1 id="creating-cds">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Mike</firstname>
	  <surname>Meyer</surname>
	  <contrib>Contributed by </contrib>
	  <!-- mwm@mired.org -->
	</author>
      </authorgroup>
      <!-- Apr 2001 -->
    </sect1info>

    <title>创建和使用光学介质(CD)</title>
    <indexterm>
      <primary>CDROMs</primary>
      <secondary>creating</secondary>
    </indexterm>

    <sect2>
      <title>介绍</title>

      <para>CD 与普通的磁盘相比有很多不同的特性。最初它们是不能被用户写入的。
        由于没有磁头和磁道移动时的延迟，所以它们可以连续的进行读取。
        方便的在两个系统之间进行数据的传输，比起相同大小的存储介质来说。</para>

      <para>CD 有磁道，这关系到数据读取时的连续性而不是物理磁盘的性能。
	要在 FreeBSD 中制作一个 CD，您要准备好要写到 CD 上的数据文件，
	然后根据每个 tracks 写入到 CD。</para>

      <indexterm><primary>ISO 9660</primary></indexterm>
      <indexterm>
        <primary>文件系统</primary>
        <secondary>ISO 9660</secondary>
      </indexterm>
      <para>ISO 9660 文件系统被设计用来处理这些差异。它通常不会对文件系统作限制。
        幸运的是，它提供了一个可扩展机制允许在制作 CD 时越越这些限制，
        而同时在不支持这些扩展的系统上仍旧能够进行工作。</para>

      <indexterm>
        <primary><filename role="package">sysutils/cdrtools</filename></primary>
      </indexterm>
      <para><filename role="package">sysutils/</filename>
	port 包括了 &man.mkisofs.8;， 这是一个可以用来生成包含 ISO 9660 文件系统的数据文件的程序。
	他也提供了对于一些扩展的支持选项，下面将详细介绍。</para>

      <indexterm>
        <primary>CD burner</primary>
        <secondary>ATAPI</secondary>
      </indexterm>
      <para>使用哪个工具来刻录 CD 依赖于 CD 刻录机是 ATAPI 还是其它类型的。ATAPI CD
        刻录器使用 <command><link linkend="burncd">burncd</link></command> 
        程序，可以在基本系统中找到。SCSI 和 USB CD 刻录机使用
	<command><link linkend="cdrecord">cdrecord</link></command> 程序，可以
	在 <filename role="package">sysutils/cdrtools</filename> port中找到。</para>

      <para><command>burncd</command> 程序受到一系列支持设备的限制。如果想知道
        设备是否被支持，可以查看
	<ulink url="http://www.freebsd.dk/ata/">支持的 CD-R/RW
	  驱动器</ulink> 列表。</para>

      <note>
      <indexterm>
	<primary>CD burner</primary>
	<secondary>ATAPI/CAM driver</secondary>
      </indexterm>
	<para>如果您运行的是 &os;&nbsp;5.X、&os;&nbsp;4.8-RELEASE 或更高版本，
	  它将可能使用 <command><link linkend="cdrecord">cdrecord</link></command>
	  和其它工作在一个 ATAPI 硬件 <link linkend="atapicam">ATAPI/CAM module</link>
	  为 SCSI 设备。</para>
      </note>

      <para>如果您想使用一个图形界面的 CD 刻录软件，
	您可以参考一下
	<application>X-CD-Roast</application> 或
	<application>K3b</application>。这些工具作为安装包可以从
	<filename
	role="package">sysutils/xcdroast</filename> 和 <filename
	role="package">sysutils/k3b</filename> ports 得到。
	<application>X-CD-Roast</application> 和
	<application>K3b</application> 需要 <link
	linkend="atapicam">ATAPI/CAM module</link> 和 ATAPI
	硬件。</para>
    </sect2>

    <sect2 id="mkisofs">
      <title>mkisofs</title>

      <para>&man.mkisofs.8; 程序作为
	<filename role="package">sysutils/cdrtools</filename> port 的一部分，
        将生成 ISO 9660 文件系统，其中包含 &unix; 命名空间中的文件名。
	最简单的用法是：</para>

      <screen>&prompt.root; <userinput>mkisofs -o <replaceable>imagefile.iso</replaceable> <replaceable>/path/to/tree</replaceable></userinput></screen>

      <indexterm>
        <primary>文件系统</primary>
        <secondary>ISO 9660</secondary>
      </indexterm>
      <para>这个命令将创建一个包含 ISO9660 文件系统的 <replaceable>imagefile.iso</replaceable>
        文件，它是目录树 <replaceable>/path/to/tree</replaceable> 的一个拷贝。在处理过程中，
        它将文件名称映射为标准的 ISO9660 文件系统的文件名，将排除那些不典型的 ISO 文件系统的
        文件。</para>

      <indexterm>
        <primary>文件系统</primary>
        <secondary>HFS</secondary>
      </indexterm>
      <indexterm>
        <primary>文件系统</primary>
        <secondary>Joliet</secondary>
      </indexterm>
      <para>有很多选项能够用来克服那些限制。特别的，<option>-R</option> 选项能够启用
        Rock Ridge 扩展一般的 &unix; 系统，<option>-J</option> 选项能启用用于
        Microsoft 系统的 Joliet 扩展，<option>-hfs</option> 选项能用来创建用于
        &macos; 系统的 HFS 文件系统。</para>

      <para>对于那些即将要在 FreeBSD 系统中使用 CD 的人来说，<option>-U</option> 
        选项能用来消除所有文件名的限制。当使用 <option>-R</option> 选项时，它会产生一个
        文件系统映像，它与您从那儿启动 FreeBSD 树是一样的，虽然它在许多方面也违反了
         ISO 9660 的标准。</para>

      <indexterm>
        <primary>CDROMs</primary>
        <secondary>创建启动光盘</secondary>
      </indexterm>
      <para>最后一个常用的选项是 <option>-b</option>。
	它用来指定启动映像的位置， 用以生成
	<quote>El Torito</quote> 启动 CD。 这个选项使用一个参数，
	用以指定将写入 CD 的目录的根。 默认情况下， &man.mkisofs.8;
	会以常说的 <quote>软盘模拟</quote> 方式来创建 ISO，
	因此它希望引导影响的尺寸恰好是 1200， 1440 或
	2880&nbsp;KB。 某些引导加载器， 例如
	FreeBSD 发行版磁盘， 并不使用模拟模式； 这种情况下，
	需要使用 <option>-no-emul-boot</option> 选项。 因此， 如果
	<filename>/tmp/myboot</filename> 是一个包含了在
	<filename>/tmp/myboot/boot/cdboot</filename> 的可引导的
	FreeBSD 系统， 您就可以使用下面的命令在
	<filename>/tmp/bootable.iso</filename> 生成 ISO 9660 文件系统：</para>

      <screen>&prompt.root; <userinput>mkisofs -R -no-emul-boot -b boot/cdboot -o /tmp/bootable.iso /tmp/myboot</userinput></screen>

      <para>如果内核中已经配置了 <devicename>vn</devicename>
	(FreeBSD&nbsp;4.X), 或 <devicename>md</devicename>
	(FreeBSD&nbsp;5.X)，就可以挂上文件系统：</para>

      <screen>&prompt.root; <userinput>vnconfig -e vn0c /tmp/bootable.iso</userinput>
&prompt.root; <userinput>mount -t cd9660 /dev/vn0c /mnt</userinput></screen>

      <para>在 FreeBSD&nbsp;4.X, 和 FreeBSD&nbsp;5.X 中：</para>

      <screen>&prompt.root; <userinput>mdconfig -a -t vnode -f /tmp/bootable.iso -u 0</userinput>
&prompt.root; <userinput>mount -t cd9660 /dev/md0 /mnt</userinput></screen>

      <para>可以发现 <filename>/mnt</filename> 和 <filename>/tmp/myboot</filename> 
        是一样的。</para>

      <para>还可以使用 &man.mkisofs.8;
        的其它选项来调整它的行为。特别是修改 ISO 9660 的划分格式，创建 Joliet
        和 HFS 格式的磁盘。查看 &man.mkisofs.8; 手册页得到更多的帮助。</para>
    </sect2>

    <sect2 id="burncd">
      <title>burncd</title>
      <indexterm>
        <primary>CDROMs</primary>
        <secondary>burning</secondary>
      </indexterm>
      <para>如果用的是 ATAPE 的 CD 刻录机，可以使用 <command>burncd</command> 
      　命令来记录您的 CD ISO 映像文件。 <command>burncd</command> 命令是基本
      　系统的一部分，中以使用 <filename>/usr/sbin/burncd</filename> 来安装。
      　用法如下：</para>

      <screen>&prompt.root; <userinput>burncd -f <replaceable>cddevice</replaceable> data <replaceable>imagefile.iso</replaceable> fixate</userinput></screen>

      <para>在 <replaceable>cddevice</replaceable> 上刻录一份
	<replaceable>imagefile.iso</replaceable> 的副本。
	默认的设备是
	<filename>/dev/acd0</filename> (在 &os;&nbsp;4.X 下则是
	<filename>/dev/acd0c</filename>)。
	请参考 &man.burncd.8; 以了解设置写入速度的参数，如何在刻录完成之后自动弹出CD，以及刻录音频数据。</para>
    </sect2>

    <sect2 id="cdrecord">
      <title>cdrecord</title>

      <para>如果没有一个 ATAPI CD 刻录机，必须使用 <command>cdrecord</command> 
        来刻录您的 CD 。 <command>cdrecord</command> 不是基本系统的一部分;必须
        从 <filename role="package">sysutils/cdrtools</filename> 或适当的
        package 安装它。基本系统的变化可能会引起这个程序的错误。可能是由
        <quote>coaster</quote> 引起的。当升级系统时，同时需要升级 port ，或者
        如果已升级到 <link linkend="stable">tracking -STABLE</link> ，那么使用
        新版本时也要升级 port。</para>

      <para><command>cdrecord</command> 有许多选项，基本用法与 <command>burncd</command>
        相似。刻录一个 ISO 9660 映像文件只需这样做：</para>

      <screen>&prompt.root; <userinput>cdrecord dev=<replaceable>device</replaceable> <replaceable>imagefile.iso</replaceable></userinput></screen>

      <para>使用 <command>cdrecord</command> 的比较巧妙的方法是找到使用的
	 <option>dev</option> 。要找到正确的设置，可以使用 <command>cdrecord</command>
	 的 <option>-scanbus</option> 标记，这会产生这样的结果：</para>
      <indexterm>
        <primary>CDROMs</primary>
        <secondary>burning</secondary>
      </indexterm>
      <screen>&prompt.root; <userinput>cdrecord -scanbus</userinput>
Cdrecord 1.9 (i386-unknown-freebsd4.2) Copyright (C) 1995-2000 J&ouml;rg Schilling
Using libscg version 'schily-0.1'
scsibus0:
        0,0,0     0) 'SEAGATE ' 'ST39236LW       ' '0004' Disk
        0,1,0     1) 'SEAGATE ' 'ST39173W        ' '5958' Disk
        0,2,0     2) *
        0,3,0     3) 'iomega  ' 'jaz 1GB         ' 'J.86' Removable Disk
        0,4,0     4) 'NEC     ' 'CD-ROM DRIVE:466' '1.26' Removable CD-ROM
        0,5,0     5) *
        0,6,0     6) *
        0,7,0     7) *
scsibus1:
        1,0,0   100) *
        1,1,0   101) *
        1,2,0   102) *
        1,3,0   103) *
        1,4,0   104) *
        1,5,0   105) 'YAMAHA  ' 'CRW4260         ' '1.0q' Removable CD-ROM
        1,6,0   106) 'ARTEC   ' 'AM12S           ' '1.06' Scanner
        1,7,0   107) *</screen>

      <para>这个列表列出了设备的的适当的 <option>dev</option> 值。找到您的
        CD burner ,使用三个用逗号分隔的数值来表示 <option>dev</option>.在
        这个例子中，CRW 是 <option>dev=1,5,0</option>，所以正确的输入应是
        dev=1,5,0 。有一个很容易的方法可以指定这个值;看看 &man.cdrecord.1; 
        的介绍了解有关音轨，控制速度和其他的东西。</para>
    </sect2>

    <sect2 id="duplicating-audiocds">
      <title>复制音频 CD</title>

      <para>您可以这样复制 CD，把 CD 上面的音频数据解压缩出一系列的文件，
      再把这些文件写到一张空白 CD 上。
	这个过程对于 ATAPI 和 SCSI 驱动器来说有些微的不同。
	</para>

      <procedure>
	<title>SCSI 驱动器</title>

	<step>
	  <para>使用 <command>cdda2wav</command> 来解压缩音频。</para>

	  <screen>&prompt.user; <userinput>cdda2wav -v255 -D2,0 -B -Owav</userinput></screen>
	</step>

	<step>
	  <para>使用 <command>cdrecord</command> 来写
	    <filename>.wav</filename> 文件。</para>

	  <screen>&prompt.user; <userinput>cdrecord -v dev=<replaceable>2,0</replaceable> -dao -useinfo  *.wav</userinput></screen>

	  <para>确保 <replaceable>2,0</replaceable> 被适当地设置了，
	    具体方法在 <xref linkend="cdrecord"> 中有所描述。</para>
	</step>
      </procedure>

      <procedure>
	<title>ATAPI 驱动器</title>

	<step>
	  <para>ATAPI CD 驱动用
	    <filename>/dev/acd<replaceable>d</replaceable>t<replaceable>nn</replaceable></filename>表示每个轨道，
	    这里 <replaceable>d</replaceable> 是驱动器号，
	    <replaceable>nn</replaceable> 是轨道号，由两位小数位组成，省略前缀零。
	    所以第一个盘片上的第一个轨道就是
	    <filename>/dev/acd0t01</filename>，第二个就是
	    <filename>/dev/acd0t02</filename>，第三个就是
	    <filename>/dev/acd0t03</filename>，等等。</para>

	  <para>确保在 <filename>/dev</filename> 中存在合适的文件。
	    </para>

	  <screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>sh MAKEDEV acd0t99</userinput></screen>

	  <note><para>在 FreeBSD 5.0 中，&man.devfs.5; 会为您自动创建
	    并管理 <filename>/dev</filename> 中的节点，
	    所以不再需要使用
	    <command>MAKEDEV</command>。</para></note>
	</step>

	<step>
	  <para>使用 &man.dd.1; 解压缩每个轨道。当解压缩文件的时候您也必须使用
	    一个特殊的块大小。</para>

	  <screen>&prompt.root; <userinput>dd if=/dev/acd0t01 of=track1.cdr bs=2352</userinput>
&prompt.root; <userinput>dd if=/dev/acd0t02 of=track2.cdr bs=2352</userinput>
...
</screen>
	</step>

	<step>
	  <para>使用
	    <command>burncd</command> 把解压缩的文件刻录到光盘上。您必须指定
	    这些文件是音频文件，这样 <command>burncd</command> 会在刻录完成时
	    结束光盘。</para>

	  <screen>&prompt.root; <userinput>burncd -f <replaceable>/dev/acd0</replaceable> audio track1.cdr track2.cdr <replaceable>...</replaceable> fixate</userinput></screen>
	</step>
      </procedure>
    </sect2>

    <sect2 id="imaging-cd">
      <title>复制数据 CD</title>

      <para>您可以把数据 CD 复制成一个与之等价的镜像文件，
	镜像文件可以使用
        &man.mkisofs.8; 创建，您可以使用这个工具复制
	任何数据 CD。这里给出的例子假定您的 CDROM
	设备 <devicename>acd0</devicename>。代替您
	正确的 CDROM 设备。在 &os;&nbsp;4.X 下面，字符 <literal>c</literal> 必须被附加到
	设备名的结尾处来指明是整个分区，
	或者对于 CDROM，指明是整个光盘。</para>

      <screen>&prompt.root; <userinput>dd if=/dev/acd0 of=file.iso bs=2048</userinput></screen>

      <para>现在您有一个镜像文件了，您可以像上面描述的那样把它刻录成 CD。
	</para>
    </sect2>

    <sect2 id="mounting-cd">
      <title>使用数据 CD</title>

      <para>现在您已经创建了一张标准的数据 CDROM，您或许想要
	挂载来读取上面的设备。
	默认情况下，&man.mount.8; 假定文件系统是
	<literal>ufs</literal> 类型的。如果您尝试下面的命令：</para>

      <screen>&prompt.root; <userinput>mount /dev/cd0 /mnt</userinput></screen>

      <para>您会得到一条 <errorname>Incorrect super
	  block</errorname> 的错误信息，没有挂载成功。CDROM 不是
	  <literal>UFS</literal> 文件系统，所以试图这样挂载它是
	  是不行的。您需要告诉 &man.mount.8;
	  文件系统是 <literal>ISO9660</literal> 类型的，这样
	  就可以了。只需要指定 &man.mount.8; 的
	  <option>-t cd9660</option> 选项。例如，
	  如果您想要挂载 CDROM 设备，
	  <filename>/dev/cd0</filename> 到
	  <filename>/mnt</filename> 目录，您需要执行：</para>

          <screen>&prompt.root; <userinput>mount -t cd9660 /dev/cd0 /mnt</userinput></screen>

      <para>注意您的设备名
	(在这个例子中是 <filename>/dev/cd0</filename>)可能
	有所不同，取决于您的 CDROM 使用的接口。另外，
	<option>-t cd9660</option> 选项等同于执行
	&man.mount.cd9660.8;。上面的例子可以缩短
	为：</para>

<screen>&prompt.root; <userinput>mount_cd9660 /dev/cd0 /mnt</userinput></screen>

      <para>用这种方法您基本可以使用任何买到的数据 CDROM。
	然而某些有 ISO 9660 扩展的光盘可能会行为古怪。
	例如，joliet 光盘用两个字节的 unicode 字符存储所有的文件名。
	FreeBSD 内核还不能识别
	unicode (重要！)，所以非英语字符被做了有问题的标记。
	(如果您正在运行 FreeBSD 4.3 或者以后的版本，
	CD9660 驱动包含了加载合适的 unicode 换算表的方法。
	一些常用编码的模块可以通过
	<filename role="package">sysutils/cd9660_unicode</filename> port 来安装。)</para>

      <para>有时候，当您试图挂载 CDROM 的时候，会得到一条 <errorname>Device not
	configured</errorname> 的错误信息。这通常
	表明 CDROM 驱动认为托盘里没有光盘，
	或者驱动器在总线上不可见。
	需要几秒钟时间等待 CDROM 驱动器辨别已经接到反馈的信息，
	请耐心等待。</para>

      <para>有时候，SCSI CDROM 可能会找不到，因为没有足够的
	时间来应答总线的 reset 信号。如果您有一个 SCSI
	CDROM 请将下面的选项添加到您的内核
	配置文件并<link linkend="kernelconfig-building">重建您的内核</link>。</para>

      <programlisting>options SCSI_DELAY=15000</programlisting>

      <para>这个告诉您的 SCSI 总线启动时暂停 15 秒钟，
	给您的 CDROM 驱动器足够的机会来应答
	总线 reset 信号。</para>
    </sect2>

    <sect2 id="rawdata-cd">
      <title>刻录原始数据 CD</title>

      <para>您可以选择把一个文件目录刻录到 CD 上而不用
	创建 ISO 9660 文件系统。有些人这么做是为了备份的
	目的。这个运行的比刻录一个标准 CD 速度要快的多：</para>

      <screen>&prompt.root; <userinput>burncd -f /dev/acd1 -s 12 data archive.tar.gz fixate</userinput></screen>

      <para>要重新找回这样刻录到 CD 上的数据，
	  您必须从原始设备节点读取数据：</para>

      <screen>&prompt.root; <userinput>tar xzvf /dev/acd1</userinput></screen>

      <para>您不能像挂载一个通常的 CDROM 一样挂载这张光盘。
	  这样的 CDROM 也不能在除了 FreeBSD 之外的任何操作系统上读出。
	  如果您想要可以挂载 CD，或者
	  和另一种操作系统共享数据，您必须像上面描述的那样使用
	  &man.mkisofs.8;。</para>
    </sect2>

    <sect2 id="atapicam">
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Marc</firstname>
	    <surname>Fonvieille</surname>
	    <contrib>Contributed by </contrib>
	  </author>
	</authorgroup>
      </sect2info>

      <indexterm>
	<primary>CD burner</primary>
	<secondary>ATAPI/CAM driver</secondary>
      </indexterm>
      <title>使用 ATAPI/CAM 驱动</title>

      <para>这个驱动允许 ATAPI 设备(CD-ROM, CD-RW, DVD
	驱动器等...)通过 SCSI 子系统访问，
	这样允许使用像 <filename
	role="package">sysutils/cdrdao</filename> 或者
	&man.cdrecord.1; 这样的程序。</para>

      <para>要使用这个驱动， 您需要把下面几行添加到您的内核配置文件中：</para>

      <programlisting>device atapicam</programlisting>

      <para>此外还需要在内核配置文件中加入：</para>

      <programlisting>device ata
device scbus
device cd
device pass</programlisting>

      <para>这些应该已经有了。</para>

      <para>然后重建，安装您的新内核，重新启动机器。
	在启动过程中，您的刻录机会被识别，
	就像这样：</para>

      <screen>acd0: CD-RW &lt;MATSHITA CD-RW/DVD-ROM UJDA740&gt; at ata1-master PIO4
cd0 at ata1 bus 0 target 0 lun 0
cd0: &lt;MATSHITA CDRW/DVD UJDA740 1.00&gt; Removable CD-ROM SCSI-0 device
cd0: 16.000MB/s transfers
cd0: Attempt to query device size failed: NOT READY, Medium not present - tray closed</screen>

      <para>驱动器现在可以通过
	<filename>/dev/cd0</filename> 设备名访问了，例如要
	挂载 CD-ROM 到 <filename>/mnt</filename>，只需要键入下面的
	命令：</para>

      <screen>&prompt.root; <userinput>mount -t cd9660 <replaceable>/dev/cd0</replaceable> /mnt</userinput></screen>

      <para>作为 <username>root</username>，您可以运行下面的
	命令来得到刻录机的 SCSI 地址：</para>

      <screen>&prompt.root; <userinput>camcontrol devlist</userinput>
&lt;MATSHITA CDRW/DVD UJDA740 1.00&gt;   at scbus1 target 0 lun 0 (pass0,cd0)</screen>

      <para>这样 <literal>1,0,0</literal> 就是 SCSI 地址了，可以被
	&man.cdrecord.1; 和其他的 SCSI 程序使用。</para>

      <para>有关 ATAPI/CAM 和 SCSI 系统的更多信息，
	可以参阅 &man.atapicam.4; 和 &man.cam.4; 手册
	页。</para>
    </sect2>
  </sect1>

  <sect1 id="creating-dvds">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Marc</firstname>
	  <surname>Fonvieille</surname>
	  <contrib>Contributed by </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <firstname>Andy</firstname>
	  <surname>Polyakov</surname>
	  <contrib>With inputs from </contrib>
	</author>
      </authorgroup>
      <!-- Feb 2004 -->
    </sect1info>

    <title>创建和使用光学介质(DVD)</title>
    <indexterm>
      <primary>DVD</primary>
      <secondary>burning</secondary>
    </indexterm>

    <sect2>
      <title>介绍</title>

      <para>和 CD 相比，DVD 是下一代光学存储介质技术。
	DVD 可以容纳比任何 CD 更多的数据，已经成为现今视频出版业的标准。</para>

      <para>我们称作可记录 DVD 的有五种物理记录格式：</para>

      <itemizedlist>
	<listitem>
	  <para>DVD-R：这是第一种可用的 DVD 可记录格式。
	    DVD-R 标准由 <ulink
	    url="http://www.dvdforum.com/forum.shtml">DVD Forum</ulink> 定义。
	    这种格式是一次可写的。</para>
	</listitem>

	<listitem>
	  <para>DVD-RW：这是 DVD-R 标准的可覆写版本。
	    一张 DVD-RW 可以被覆写大约 1000
	    次。</para>
	</listitem>

	<listitem>
	  <para>DVD-RAM：这也是一种被 DVD Forum 所支持的可覆写格式。
	    DVD-RAM 可以被看作一种可移动硬盘。
	    然而，这种介质和大部分
	    DVD-ROM 驱动器以及 DVD-Video 播放器不兼容；
	    只有少数 DVD 刻录机支持 DVD-RAM。</para>
	</listitem>

	<listitem>
	  <para>DVD+RW：这是一种由
	    <ulink url="http://www.dvdrw.com/">DVD+RW
	    Alliance</ulink> 定义的可覆写格式。一张 DVD+RW 可以被覆写大约 1000
	    次。</para>
	</listitem>

	<listitem>
	  <para>DVD+R：这种格式是 DVD+RW 格式的一次可写变种。</para>
	</listitem>
      </itemizedlist>

      <para>一张单层的可记录 DVD 可以存储
	4,700,000,000&nbsp; 字节，相当于 4.38&nbsp;GB 或者说
	4485&nbsp;MB (1 千字节等于 1024 字节)。</para>

      <note>
	<para>必须说明一下物理介质与应用程序的分歧。
	  例如 DVD-Video 是一种特殊的文件系统，
	  可以被覆写到任何可记录的 DVD 物理介质上：
	  DVD-R、DVD+R、DVD-RW 等等。在选择介质类型之前，
	  您一定要确认刻录机和
	  DVD-Video 播放器 (一种单独的播放器或者计算机上的 DVD-ROM 驱动器)
	  是和这种介质兼容的。</para></note>
    </sect2>

    <sect2>
      <title>配置</title>

      <para>&man.growisofs.1; 将被用来实施 DVD
	刻录。 这个命令是
	<application>dvd+rw-tools</application> 工具集 (<filename
	role="package">sysutils/dvd+rw-tools</filename>) 的一部分。
	<application>dvd+rw-tools</application> 支持所有的 DVD 介质类型。</para>

      <para>这些工具将使用 SCSI 子系统来访问设备，因此
	<link linkend="atapicam">ATAPI/CAM 支持</link> 必须加入内核。
	如果您的刻录机采用 USB 接口则不需要这么做，请参考
	<xref linkend="usb-disks"> 来了解 USB
	设备配置的进一步详情。</para>

      <para>此外，还需要启用 ATAPI 设备的 DMA 支持。 这一工作可以通过在
	<filename>/boot/loader.conf</filename> 文件中加入下面的行来完成：</para>

      <programlisting>hw.ata.atapi_dma="1"</programlisting>

      <para>试图使用
	<application>dvd+rw-tools</application> 之前您应该参考
	<ulink
	url="http://fy.chalmers.se/~appro/linux/DVD+RW/hcn.html">dvd+rw-tools
	硬件兼容性列表</ulink> 是否有与您的 DVD 刻录机有关的信息。</para>

      <note>
	<para>如果您想要一个图形化的用户界面，您应该看一看
	  <application>K3b</application> (<filename
	  role="package">sysutils/k3b</filename>)，它提供了
	  &man.growisofs.1; 的一个友好界面和许多其他刻录工具。</para>
      </note>
    </sect2>

    <sect2>
      <title>刻录数据 DVD</title>

      <para>&man.growisofs.1; 命令是 <link
	linkend="mkisofs">mkisofs</link> 的前端，它会调用
	&man.mkisofs.8; 来创建文件系统布局，完成到 DVD 上的刻录。
	这意味着您不需要在刻录之前创建数据映像。</para>

      <para>要把 <filename
	class="directory">/path/to/data</filename> 目录的数据刻录到 DVD+R
	或者 DVD-R 上面，使用下面的命令：</para>

      <screen>&prompt.root; <userinput>growisofs -dvd-compat -Z <replaceable>/dev/cd0</replaceable> -J -R <replaceable>/path/to/data</replaceable></userinput></screen>

      <para><option>-J -R</option> 选项传递给
	&man.mkisofs.8; 用于文件系统创建(这种情况下：
	带有 joliet 和 Rock Ridge 扩展的 ISO 9660 文件系统)，
	参考 &man.mkisofs.8; 手册页了解更多细节。</para>

      <para>选项 <option>-Z</option> 用来在任何情况下初始刻录会话：
	不管多会话与否。
	DVD 设备，<replaceable>/dev/cd0</replaceable>，
	必须依照您的配置做出改变。
	<option>-dvd-compat</option> 参数会结束光盘，
	光盘成为不可附加的。这会提供更多的和
	DVD-ROM 驱动器的介质兼容性。</para>

      <para>也可以刻录成一个 pre-mastered 映像, 
	例如记录一个映像文件
	<replaceable>imagefile.iso</replaceable>, 我们可以运行：</para>

      <screen>&prompt.root; <userinput>growisofs -dvd-compat -Z <replaceable>/dev/cd0</replaceable>=<replaceable>imagefile.iso</replaceable></userinput></screen>

      <para>刻录的速度可以被检测到并自动进行调整，
	根据介质和驱动器的使用情况。如果您想强制改变速度，
	可以使用 <option>-speed=</option>
	参数。更多的信息，请看 &man.growisofs.1;
	联机手册。</para>
    </sect2>

    <indexterm>
      <primary>DVD</primary>
      <secondary>DVD-Video</secondary>
    </indexterm>

    <sect2>
      <title>刻录 DVD-Video</title>

      <para> DVD-Video 是一个特殊的基于 ISO 9660
	和 micro-UDF (M-UDF) 规范的文件系统。DVD-Video 
	也呈现了一个特殊的数据体系结构，
	这就是为什么您需要一个特殊的程序像 <filename
	role="package">multimedia/dvdauthor</filename> 来制作
	DVD 的原因。</para>

      <para>如果您已经有了 DVD-Video 文件系统的映像，
	就可以以同样的方式制作另一个映像，可以参看前面章节的例子。
	如果您想制作 DVD 并想放在特定的目录中，如在目录
	<filename class="directory">/path/to/video</filename> 中，
	可以使用下面的命令来刻录 DVD-Video：</para>

      <screen>&prompt.root; <userinput>growisofs -Z <replaceable>/dev/cd0</replaceable> -dvd-video <replaceable>/path/to/video</replaceable></userinput></screen>

      <para> <option>-dvd-video</option> 选项将传递给
	&man.mkisofs.8; 并指示它创建一个 DVD-Video 文件系统布局。
	除此之外。 <option>-dvd-video</option> 选项也包含了
	<option>-dvd-compat</option> &man.growisofs.1;
	选项。</para>
    </sect2>

    <indexterm>
      <primary>DVD</primary>
      <secondary>DVD+RW</secondary>
    </indexterm>

    <sect2>
      <title>使用 DVD+RW</title>

      <para>不像 CD-RW, 一个空白的 DVD+RW 在每一次使用前必须先格式化。
	 &man.growisofs.1; 程序将会适时的自动对其进行适当的处理，
	这是 <emphasis>recommended</emphasis> 的方式。您也可以使用
	<command>dvd+rw-format</command> 来对 DVD+RW 进行格式化：</para>

      <screen>&prompt.root; <userinput>dvd+rw-format <replaceable>/dev/cd0</replaceable></userinput></screen>

      <para>您只需要执行这样的操作一次，牢记只有空白的
	DVD+RW 介质才需要格式化。您可以以前面章节同样的方式来刻录
	DVD+RW。</para>

      <para>如果您想刻录新的数据 (刻录一个新的完整的文件系统
	而不仅仅是追加一些数据) 到 DVD+RW，您不必再将其格式化成空白盘，
	您只须要直接覆盖掉以前的记录即可。
	(执行一个新的初始化对话), 像这样：</para>

      <screen>&prompt.root; <userinput>growisofs -Z <replaceable>/dev/cd0</replaceable> -J -R <replaceable>/path/to/newdata</replaceable></userinput></screen>

      <para>DVD+RW 格式化程序为简单的向以前的记录追加数据提供了可能性。
	这个操作有一个新的会话和一个已经存在的会话合并而成。
	它不需要多个写会话过程，
	 &man.growisofs.1; 将在介质上 <emphasis>增加</emphasis> 
	ISO 9660 文件系统。</para>

      <para>例如，我们想追加一些数据到到我们以前的
	DVD+RW 上，我们可以使用下面的命令：</para>

      <screen>&prompt.root; <userinput>growisofs -M <replaceable>/dev/cd0</replaceable> -J -R <replaceable>/path/to/nextdata</replaceable></userinput></screen>

      <para>我们用来刻录初始会话的同样的 &man.mkisofs.8; 
      选项会在以后的写操作中使用。</para>

      <note>
	<para>如果您想获得与 DVD-ROM 驱动更好的兼容性，可以使用 <option>-dvd-compat</option>
	  选项。在 DVD+RW 这种情况下，将不能预防您添加数据。</para>
      </note>

      <para>如果出于某种原因您真的想要空白介质盘，
	可以执行下面的命令：</para>

      <screen>&prompt.root; <userinput>growisofs -Z <replaceable>/dev/cd0</replaceable>=<replaceable>/dev/zero</replaceable></userinput></screen>
    </sect2>

    <indexterm>
      <primary>DVD</primary>
      <secondary>DVD-RW</secondary>
    </indexterm>

    <sect2>
      <title>使用 DVD-RW</title>

      <para> DVD-RW 接受两种光盘格式：增补顺序写入和受限式覆写。默认的
	DVD-RW 盘是顺序写入格式。</para>

      <para>空白的 DVD-RW 能够直接进行刻录而不需要格式化操作，
	然而非空的顺序写入格式的 DVD-RW 需要格式化才能写入新的初始区段。</para>

      <para>要格式化一张 DVD-RW 为顺序写入模式，运行：</para>

      <screen>&prompt.root; <userinput>dvd+rw-format -blank=full <replaceable>/dev/cd0</replaceable></userinput></screen>

      <note>
	<para>一次完全的格式化 (<option>-blank=full</option>)
	  在 1x 倍速的介质上将会花费大约 1 个小时。快速格式化可以使用
	  <option>-blank</option> 选项来进行，如果
	  DVD-RW 要以 Disk-At-Once (DAO) 模式刻录的话。要以
	  DAO 模式刻录 DVD-RW，使用命令：</para>

	<screen>&prompt.root; <userinput>growisofs -use-the-force-luke=dao -Z <replaceable>/dev/cd0</replaceable>=<replaceable>imagefile.iso</replaceable></userinput></screen>

	<para><option>-use-the-force-luke=dao</option> 选项不是必需的，
	  因为 &man.growisofs.1; 试图最低限度的检测 (快速格式化) 介质并进行
	  DAO 写入。</para>

	<para>事实上对于任何 DVD-RW 都应该使用受限式覆写模式，
	  这种格式比默认的增补顺序写入更加灵活。</para>
      </note>

      <para>在一张顺序 DVD-RW 上写入数据，使用和其他 DVD 格式相同的说明：</para>

      <screen>&prompt.root; <userinput>growisofs -Z <replaceable>/dev/cd0</replaceable> -J -R <replaceable>/path/to/data</replaceable></userinput></screen>

      <para>如果您想在您以前的刻录上附加数据，您必须使用
	&man.growisofs.1; 的 <option>-M</option> 选项。然而，
	如果您在一张增补顺序写入模式的 DVD-RW 上附加数据，
	将会在盘上创建一个新的区段，结果就是一张多区段光盘。</para>

      <para>受限式覆写格式的 DVD-RW 在新的初始化区段前不需要格式化，
	您只是要用 <option>-Z</option> 选项覆写光盘，这和
	DVD+RW 的情形是相似的。也可以用和 DVD+RW 同样方式的
	<option>-M</option> 选项把现存的 ISO 9660 文件系统写入光盘。
	结果会是一张单区段 DVD。</para>

      <para>要把 DVD-RW 置于受限式覆写格式，
	必须使用下面的命令：</para>

      <screen>&prompt.root; <userinput>dvd+rw-format <replaceable>/dev/cd0</replaceable></userinput></screen>

      <para>更改回顺序写入模式使用：</para>

      <screen>&prompt.root; <userinput>dvd+rw-format -blank=full <replaceable>/dev/cd0</replaceable></userinput></screen>
    </sect2>

    <sect2>
      <title>多区段</title>

      <para>几乎没有哪个 DVD-ROM 驱动器支持多区段
	DVD，它们大多数时候都只读取第一个区段。
	顺序写入格式的 DVD+R、DVD-R 和 DVD-RW 可以支持多区段，
	DVD+RW 和 DVD-RW 受限式覆写格式不存在多区段的概念。</para>

      <para>在 DVD+R、DVD-R 或者 DVD-RW 的顺序写入格式下，
	一次初始化 (未关闭) 区段之后使用下面的命令，
	将会在光盘上添加一个新的区段：</para>

      <screen>&prompt.root; <userinput>growisofs -M <replaceable>/dev/cd0</replaceable> -J -R <replaceable>/path/to/nextdata</replaceable></userinput></screen>

      <para>对 DVD+RW 或者 DVD-RW 在受限式覆写模式下使用这条命令，
	会合并新区段到存在的区段中来附加数据。
	结果就是一张单区段光盘。
	这是在这些介质上用于在最初的写操作之后添加数据的方式。</para>

      <note>
	<para>介质上的一些空间用于区段之间区段的开始与结束。
	  因此，应该用大量的数据添加区段来优化介质空间。
	  对于 DVD+R 来说区段的数量限制为 154，
	  对于 DVD-R 来说大约是 2000，对于双层 DVD+R 来说是 127。</para>
      </note>
    </sect2>

    <sect2>
      <title>更多的信息</title>
      
      <para>要获得更多的关于 DVD 的信息
	<command>dvd+rw-mediainfo
	<replaceable>/dev/cd0</replaceable></command> 命令可以运行来获得
	更多的信息。</para>

      <para>更多的关于
	<application>dvd+rw-tools</application> 的信息可以在
	&man.growisofs.1; 手册页找到，在 <ulink
	url="http://fy.chalmers.se/~appro/linux/DVD+RW/">dvd+rw-tools
	web site</ulink> 和 <ulink
	url="http://lists.debian.org/cdwrite/">cdwrite mailing
	list</ulink> 联接中也可找到。</para>

      <note>
	<para> <command>dvd+rw-mediainfo</command> 命令的输出结果记录或
	  媒体的问题被做成问题报告。没有这些输出，对你的帮助将会十分困难。</para>
      </note>
    </sect2>
  </sect1>

  <sect1 id="floppies">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Julio</firstname>
	  <surname>Merino</surname>
	  <contrib>Original work by </contrib>
	</author>
      </authorgroup>
      <!-- 24 Dec 2001 -->
      <authorgroup>
	<author>
	  <firstname>Martin</firstname>
	  <surname>Karlsson</surname>
	  <contrib>Rewritten by </contrib>
	</author>
      </authorgroup>
      <!-- 27 Apr 2003 -->
    </sect1info>

    <title>创建和使用软盘</title>

    <para>把数据存储在软盘上有时也是十分有用的。
      例如，当没有其它可靠的存储介质或要传递少量的数据到其它的
      计算机。</para>

    <para>这一章将介绍怎样在 FreeBSD 上使用软盘。
      在使用 DOS 3.5 英寸软盘时首要要涉及的就是格式化，
      但其概念与其它的软盘格式化极为类似。</para>

    <sect2>
      <title>格式化软盘</title>

      <sect3>
	<title>设备</title>

	<para>软盘的访问像其它设备一样是通过在
	  <filename>/dev</filename> 中的条目来实现的。
	  访问 raw 软盘在 4.X 和更早的版本，使用
	  <filename>/dev/fd<replaceable>N</replaceable></filename>,
	  这里 <replaceable>N</replaceable> 标识设备号，通常为 0 ,
          或 <filename>/dev/fd<replaceable>NX</replaceable></filename>,
	  这里 <replaceable>X</replaceable> 标识为一个字符。</para>

	<para>在 5.0 或更新的版本中，简单的使用
	  <filename>/dev/fd<replaceable>N</replaceable></filename>。</para>

	<sect4>
	  <title>4.X 以及更早版本的磁盘大小</title>

	  <para>也有 <filename>/dev/fd<replaceable>N</replaceable>.<replaceable>size</replaceable></filename>
	    这样的设备，这里 <replaceable>size</replaceable> 代表软盘的含量以 KB 为单位。
	    这个条目用在低级格式化时来确定磁盘的大小。下面的例子就是 1440kB </para>

	  <para>有时这些条目必须在 <filename>/dev</filename> 目录中进行重建。
	    可以这样做：</para>

	  <screen>&prompt.root; <userinput>cd /dev && ./MAKEDEV "fd*"</userinput></screen>
	</sect4>

	<sect4>
	  <title>5.0 以及更新版本的磁盘大小</title>

	  <para>在 5.0 版本中， &man.devfs.5; 将自动管理在
	    <filename>/dev</filename> 目录中的设备，所以不摧荐使用
	    <command>MAKEDEV</command> 命令。</para>

	  <para>如果期望得到确定大小的磁盘可以给 &man.fdformat.1; 传递
	     <option>-f</option> 参数。支持的大小列在
	  &man.fdcontrol.8; 中，但是建议和工作状态最好的 1440kB 。</para>
	</sect4>
      </sect3>

      <sect3>
	<title>格式化</title>

	<para>一张软盘在使用这前必须先被低级格式化。
	  通常卖主已经做过了，但格式化是检测介质完整性的一种好方法。
	  尽管这有可能会强取大量（或少量）的硬盘大小，但
	  大部分磁盘都能被格式化设计为 1440kB 。</para>

	<para>低级格式化软盘你需要使用
	  &man.fdformat.1; 命令。这个程序需要设备名作为参数。</para>

	  <para>要留意一切错误信息，这些信息能够帮助你确定
	    磁盘的好与坏。</para>

	<sect4>
	  <title>在 4.X 以及更早版本中格式化</title>

	  <para>使用
	    <filename>/dev/fd<replaceable>N</replaceable>.<replaceable>size</replaceable></filename>
	    设备来格式化软盘。插入一张新的 3.5 英寸的软盘在你的设备里：</para>

	  <screen>&prompt.root; <userinput>/usr/sbin/fdformat /dev/fd0.1440</userinput></screen>

	</sect4>

	<sect4>
	  <title>在 5.0 以及更新版本中格式化</title>

	  <para>使用
	    <filename>/dev/fd<replaceable>N</replaceable></filename>
	    设备来格式化软盘。插入一张新的 3.5 英寸的软盘在你的设备中：</para>

	  <screen>&prompt.root; <userinput>/usr/sbin/fdformat -f 1440 /dev/fd0</userinput></screen>

	</sect4>
      </sect3>
    </sect2>



    <sect2>
      <title>磁盘标签</title>

      <para>经过低级格式化后，你需要给它分配一个标签。
	这个磁盘标签以后会被消毁，但是系统却需要它来确定硬盘的大小。</para>

      <para>新的磁盘标签将会接管整个磁盘，会包括所有合适的关于软盘的 geometry 信息。
	磁盘标签的  geometry 值列在
	<filename>/etc/disktab</filename>中。</para>

      <para>你能够使用 &man.disklabel.8; 像下面这样：</para>

      <screen>&prompt.root; <userinput>/sbin/disklabel -B -r -w /dev/fd0 fd1440</userinput></screen>

      <note><para>从 &os;&nbsp;5.1-RELEASE, 开始 &man.bsdlabel.8;
	程序代替了旧版本的 &man.disklabel.8; 程序。随着
	&man.bsdlabel.8; 一起许多陈旧的选项和参数也被清除了；
	在上面的例子中，选项
	<option>-r</option> 将被去掉。要想得到更多的信息，
	请参考 &man.bsdlabel.8; 手册页。</para></note>

    </sect2>

    <sect2>
      <title>文件系统</title>

      <para>现在对软盘进行高级格式化。
	这会在它上面安置一个新的文件系统，可使 FreeBSD 来对它进行读写。
	在创建完新的文件系统后，磁盘标签将被消毁，所以如果你想重新格式化磁盘，
	你必须重新创建磁盘标签。</para>

      <para>软盘的文件系统可以选择 UFS 或 FAT 。
	 FAT 是通常情况下软盘比较好的选择。</para>

      <para>要制作新的文件系统在软盘上，可以使用下面的命令：</para>

      <screen>&prompt.root; <userinput>/sbin/newfs_msdos /dev/fd0</userinput></screen>

      <para>现在磁盘已经可以进行读取和使用。</para>
    </sect2>


    <sect2>
      <title>使用软盘</title>

      <para>要使用软盘，需要先使用 &man.mount.msdos.8; (在
	4.X 和更早的版本中) 或 &man.mount.msdosfs.8; (在 5.0 或更新
	的版本中)。也可以使用在 ports collection 
	中的<filename role="package">emulators/mtools</filename> 程序。</para>
    </sect2>
  </sect1>

  <sect1 id="backups-tapebackups">
    <title>用磁带机备份</title>

    <indexterm><primary>tape media</primary></indexterm>
    <para>主流的磁带机有 4mm, 8mm, QIC, mini-cartridge 和 DLT。</para>

    <sect2 id="backups-tapebackups-4mm">
      <title>4mm (DDS: Digital Data Storage)</title>

      <indexterm>
        <primary>tape media</primary>
	<secondary>DDS (4mm) tapes</secondary>
      </indexterm>
      <indexterm>
        <primary>tape media</primary>
	<secondary>QIC tapes</secondary>
      </indexterm>
      <para>4mm 磁带机取代了 QIC 而成为工作站备份数据在设备面停止了 QIC 设备
        的生产。 4mm 的驱动器更加小和安静，但对于数据保存的可信度仍不及 8mm 
        驱动器。它要比 8mm 的便宜和小得多 (3 x 2 x 0.5 inches, 76 x 51
	x 12 mm) 。和 8mm 的一样，读写关的寿命都不长，因为它们同样使用螺旋式
	的方式来读写。</para>

      <para>数据传输的速度约在 ~150&nbsp;kB/s, 到 ~500&nbsp;kB/s 之间，可存储
        空间从 1.3&nbsp;GB 到 2.0&nbsp;GB 之间，硬件压缩可使空间加倍。磁带库
        单元可以有 6 台磁带机，120 个磁带匣，以自动切换的方式使用同一个磁带柜，
        磁带库的容量可达 240&nbsp;GB 。</para>

      <para>DDS-3 标准现在支持的磁带机容量最高可达到 12&nbsp;GB (或压缩的 24&nbsp;GB )。</para>

      <para>4mm 和 8mm 同样都使用螺旋式读写的方式，所有螺旋式读写的优点及缺点，
        都可以在 4mm 和 8mm 磁带机上看到。</para>

      <para>磁带在经过 2,000 次的使用或 100 次的全部备份后，就该退休了。</para>
    </sect2>

    <sect2 id="backups-tapebackups-8mm">
      <title>8mm (Exabyte)</title>
      <indexterm>
        <primary>tape media</primary>
	<secondary>Exabyte (8mm) tapes</secondary>
      </indexterm>

      <para>8mm 磁带机是最常见的 SCSI 磁带机，也是磁带交换的最佳选择。几乎每个
        工作站都有一台 2&nbsp;GB 8mm 磁带机。8mm 磁带机可信度高、方便、安静。
        卡匣小 (4.8 x 3.3 x 0.6 inches; 122 x 84 x 15 mm)而且不贵。8mm 磁带机
        的下边是一个短短的读写头，而读写头的寿命取决于磁带经过读写头时，相对高
        速运动情况。</para>

      <para>数据传输速度约在 250&nbsp;kB/s 到 500&nbsp;kB/s 之间，可存储的空间从
        300&nbsp;MB 到 7&nbsp;GB，硬件压缩可使空间加倍。磁带库单元可以有 6 台磁
        带机，120 个磁带匣，以自动切换的方式使用同一个磁带柜，磁带库的容量可达
        840+&nbsp;GB。</para>

      <para>Exabyte <quote>Mammoth</quote> 模型支持 12&nbsp;GB 的容量在一个磁带
        上(压缩后可达 24&nbsp;GB )相当于普通磁带的二倍。</para>

      <para>数据是使用螺旋式读写的方式记录在磁带上的，读写头和磁带约相差 6 度，
        磁带以 270 度缠绕着轴，并抵住读写头，轴适时地旋转，使得磁带具有高密度，
        从一端到另一端并可使磁道紧密地分布。</para>
    </sect2>

    <sect2 id="backups-tapebackups-qic">
      <title>QIC</title>
      <indexterm>
        <primary>tape media</primary>
	<secondary>QIC-150</secondary>
      </indexterm>

      <para>QIC-150 磁带和磁带机可能是最常见的磁带机和介质了。
	QIC 磁带机是最便宜的 <quote>正规</quote> 备份设备。
	它的缺点在于介质的价格较高。 QIC 磁带要比 8mm 或 4mm 磁带贵，
	每 GB 的数据存储价格可能最高高出 5 倍。 但是，
	如果您的需求能够为半打磁带所满足的话， 那么 QIC
	可能是明智之选。 QIC 是
	<emphasis>最</emphasis> 常见的磁带机。 每个站点都会有某种密度的 QIC。
	这有时是一种麻烦， QIC 有为数众多的密度，
	但在外观上相似 (有时一样) 的磁带。 QIC 磁带机噪音很大。
	它们在寻址以及读写时都会发出声音。 QIC 磁带的规格有 (6 x 4 x 0.7 英寸； 152 x
	102 x 17 毫米)。</para>

      <para>数据传输的速度介于 150&nbsp;kB/s 到 500&nbsp;kB/s 之间，可存储的空间
        从 40&nbsp;MB 到 15&nbsp;GB。较新的 QIC 磁带机具有硬件压缩的功能。 QIC 
        的使用率愈来愈低，渐渐被 DAT 所取代。</para>

      <para>数据以磁道的方式记录在磁带上，磁道数及磁道的宽度会根据容量而有所不同。
        通常新的磁带机具有的向后兼容的读取功能（通常也具备写入的功能）。对于数据
        的安全性，QIC 具有不错的评价。</para>

      <para>磁带机在经过 5,000 次的使用后，就该退休了。</para>
    </sect2>

    <sect2 id="backups-tapebackups-dlt">
      <title>DLT</title>
      <indexterm>
        <primary>tape media</primary>
	<secondary>DLT</secondary>
      </indexterm>

      <para>在这一章列出的磁带机中 DLT 具有最快的数据传输率。 1/2" (12.5mm) 的
        磁带包含在单轴的磁带匣 (4 x 4 x 1 inches; 100 x 100 x 25 mm)中。磁带匣
        的一边是一个旋转匣道，通过匣道的开合，可以让磁带卷动。磁带匣内只有一个
        轴，而本章中所提到的其他磁带匣都是有两个轴的（9磁道磁带机例外）。</para>

      <para>数据传输的速度约 1.5&nbsp;MB/s，是 4mm, 8mm, 或 QIC 磁带机的三倍。
        可存储的空间从 10&nbsp;GB 到 20&nbsp;GB，具有磁带机数据库。磁带机数据库
        单元可以有 1 to 20 台磁带机，5 到 900 个磁带匣，磁带机数据库的容量可达
        50&nbsp;GB 到 9&nbsp;TB 。</para>

      <para>如果要压缩的话，DLT 型 IV 格式的磁带机最高可支持 70&nbsp;GB 的存储
        容量。</para>

      <para>数据存储在平行于磁带运行方向的磁道上（就像 QIC 磁带），一次写入两个
        磁道。读写头的寿命相当长，每当磁带停止前进，磁带与读写头之间没有相对运动。</para>
    </sect2>

    <sect2>
      <title id="backups-tapebackups-ait">AIT</title>
      <indexterm>
        <primary>tape media</primary>
	<secondary>AIT</secondary>
      </indexterm>

      <para>AIT 是 Sony 开发的一种新格式，每个磁带最高可以存储 50&nbsp;GB。磁带
        机使用内存芯片来保存磁带上的索引内容。这个索引能够被磁带机驱动器快速阅读
        来搜索磁带机上文件所处的位置，而不像其他的磁带机需要花几分钟的时间才能找
        到文件。像 <application>SAMS:Alexandria</application> 这样的软件：能够操
        作四十或者更多的 AIT 磁带库，直接使用内存芯片来进行通信把内容显示在屏幕上，
        以决定把什么文件备份到哪个磁带上，加载和恢复数据。</para>

      <para>像这样的库成本大概在 $20,000 美元左右，零售市场可能还要贵一点。</para>
    </sect2>

    <sect2>
      <title>第一次使用新的磁带机</title>

      <para>当在一块完全空白的磁带上尝试定入数据时，会得到类似下面这样的错误信息：</para>

      <screen>sa0(ncr1:4:0): NOT READY asc:4,1
sa0(ncr1:4:0):  Logical unit is in process of becoming ready</screen>

      <para>信息指出这块磁带没有块编号 (block 编号为 0)。在 QIC-525 之后的所有 QIC 
        磁带，都采用 QIC-525 标准，必须写入一个	Identifier Block 。对于这种问题，
        有以下两种解决的办法：

      <itemizedlist>
	<listitem>
	  <para>用<command>mt fsf 1</command> 可以让磁带机对磁带写入 Identifier Block 。</para>
	</listitem>

	<listitem>
	  <para>使用面板上的按钮磁带。</para>

	  <para>再插入一次，并存储 <command>dump</command> 数据到磁带上。</para>

	  <para>这时<command>dump</command> 将传回 <errorname>DUMP: End of tape
	    detected</errorname> ，然后您会得到这样的错误信息： <errorname>HARDWARE
	    FAILURE info:280 asc:80,96</errorname>。</para>

	  <para>这时用 <command>mt rewind</command> 来倒转磁带。</para>

	  <para>磁带操作的后续操作就完成了。</para>
	</listitem>
      </itemizedlist>

    </sect2>
  </sect1>

  <sect1 id="backups-floppybackups">
    <title>用软盘备份</title>

    <sect2 id="floppies-using">
      <title>能够使用软盘来备份数据吗</title>
      <indexterm><primary>backup floppies</primary></indexterm>
      <indexterm><primary>floppy disks</primary></indexterm>

      <para>软磁盘通常是用来备份的设备中不太合适的设备：</para>

      <itemizedlist>
	<listitem>
	  <para>这种设备不太可靠，特别是长期使用。</para>
	</listitem>

	<listitem>
	  <para>备份和恢复都很慢</para>
	</listitem>

	<listitem>
	  <para>它们只有非常有限的存储容量。</para>
	</listitem>
      </itemizedlist>

      <para>然而，如果没有其它的备份数据的方法，那软盘备份总比没有备份要好。</para>

      <para>如果必须使用软盘的话，必须确保盘片的质量。软盘在办公室中使用已经有许多
        年了。最好使用一些名牌厂商的产品以确保质量。</para>
    </sect2>

    <sect2 id="floppies-creating">
      <title>如何备份数据到软盘</title>

      <para>最好的备份数据到软盘的方法是使用 &man.tar.1; 程序加上 <option>-M</option> 选项，
        它可以允许数据备份到多张软盘上。</para>

      <para>要备份当前目录中所有的文件可以使用这个命令 (需要有 <username>root</username>权限)：</para>

      <screen>&prompt.root; <userinput>tar Mcvf /dev/fd0 *</userinput></screen>

      <para>当第一张盘满的时候， &man.tar.1; 会指示您插入下一张盘，插入第二张盘之后就按回车。</para>

      <screen>Prepare volume #2 for /dev/fd0 and hit return:</screen>

      <para>这个步骤可能需要重复很多次，直到这些文件备份完成为止。</para>
    </sect2>

    <sect2 id="floppies-compress">
      <title>可以压缩备份吗</title>
      <indexterm>
        <primary><command>tar</command></primary>
      </indexterm>
      <indexterm>
        <primary><command>gzip</command></primary>
      </indexterm>
      <indexterm><primary>compression</primary></indexterm>

      <para>不幸的是，&man.tar.1; 在为多卷文件作备份时是不允许使用 <option>-z</option> 
        选项的。当然，可以用 &man.gzip.1; 压缩所有的文件，把它们打包到磁盘，以后在用
	&man.gunzip.1; 解开。</para>
    </sect2>

    <sect2 id="floppies-restoring">
      <title>如何恢复备份</title>

      <para>要恢复所有文件：</para>

      <screen>&prompt.root; <userinput>tar Mxvf /dev/fd0</userinput></screen>

      <para>有两种方法来恢复软盘中的个别文件。首先，就要用第一张软盘启动：</para>

      <screen>&prompt.root; <userinput>tar Mxvf /dev/fd0 <replaceable>filename</replaceable></userinput></screen>

      <para>&man.tar.1; 程序会提示您插入后面的软盘，直到它找到所需要的文件。</para>

      <para>如果您知道哪个文件在哪个盘上，您就可以插入那张盘，然后使用上同同样的命令。
        如果软盘上的第一个文件与前面的文件是连续的，那 &man.tar.1; 命令会警告您它无法
        恢复，即使您不要求它这样做。</para>
    </sect2>
  </sect1>

  <sect1 id="backup-basics">
    <title>备份程序</title>

    <para>有三个主要的备份程序 &man.dump.8;、&man.tar.1; 和 &man.cpio.1;。</para>

    <sect2>
      <title>Dump 和 Restore</title>
      <indexterm>
        <primary>备份软件</primary>
	<secondary>dump / restore</secondary>
      </indexterm>
      <indexterm><primary><command>dump</command></primary></indexterm>
      <indexterm><primary><command>restore</command></primary></indexterm>

      <para><command>dump</command> 和 <command>restore</command> 是 &unix;
        传统的备份程序。它以 block 而不是以文件为单位来备份数据、链接或目录。
         <command>dump</command> 备份的是设备上的整个文件系统，不能只备份一
         一个文件系统的部分或是用到两个以上文件系统的目录树。
          <command>dump</command> 不会写文件和目录到磁带机，而是写入包含文件
          和目录的原始数据块。</para>

      <note><para>如果在您的 root 目录使用 <command>dump</command> ，将不需要
        备份 <filename>/home</filename>、<filename>/usr</filename> 或其他目录，
        因为这些是典型的其他文件系统或符号连接到那些文件系统的加载点。</para></note>

      <para><command>dump</command> 是最早出现于 AT&amp;T UNIX 的 Version 6 (约 1975)。
        默认的参数适用于 9-track 磁带(6250 bpi)，所以如果要用高密度的磁带（最高可达
        62,182 ftpi），就不能用默认的参数，而要另外指定参数。这些默认值必须在命令行被
        修改以更好地利用当前磁带机的功能。</para>

      <indexterm><primary><filename>.rhosts</filename></primary></indexterm>
      <para><command>rdump</command> 和 <command>rrestore</command> 可以通过网络在另一
        台计算机的磁带机上备份数据。这两个程序都是依靠 &man.rcmd.3; 和
        &man.ruserok.3; 来访问远程的磁带机。因此，运行备份的用户必须要有远程
        主机的 <filename>.rhosts</filename> 访问权。<command>rdump</command> 和 
        <command>rrestore</command> 的参数必须适用于远程主机（例如，当您从 FreeBSD 连到
        一台 SUN 工作站 knomodo 去使用磁带机时，使用：</para>

      <screen>&prompt.root; <userinput>/sbin/rdump 0dsbfu 54000 13000 126 komodo:/dev/nsa8 /dev/da0a 2>&amp;1</userinput></screen>

      <para>要注意的是：必须检查您在使用 <filename>.rhosts</filename> 时的安全情况。</para>

      <para>也可以通过使用 <command>ssh</command> 用一个更安全的方式来使用 <command>dump</command> 
        和 <command>restore</command> 。</para>

      <example>
	<title>通过 <application>ssh</application> 使用 <command>dump</command> </title>

	<screen>&prompt.root; <userinput>/sbin/dump -0uan -f - /usr | gzip -2 | ssh -c blowfish \
          targetuser@targetmachine.example.com dd of=/mybigfiles/dump-usr-l0.gz</userinput></screen>

      </example>

      <para>或使用 <command>dump</command>　的 built-in 方法，
        设置环境变量 <envar>RSH</envar>：</para>

      <example>
	<title>通过设置 <application>ssh</application> 环境变量 <envar>RSH</envar> 使用 <command>dump</command> </title>

	<screen>&prompt.root; <userinput>RSH=/usr/bin/ssh /sbin/dump -0uan -f targetuser@targetmachine.example.com:/dev/sa0 /usr</userinput></screen>

      </example>

    </sect2>

    <sect2>
      <title><command>tar</command></title>
      <indexterm>
        <primary>备份软件</primary>
        <secondary><command>tar</command></secondary>
      </indexterm>

      <para>&man.tar.1; 也同样是在第 6 版 AT&amp;T UNIX
	(大约是 1975 前后) 出现的。 <command>tar</command> 对文件系统直接操作；
	其作用是把文件和目录写入磁带。 <command>tar</command> 并不支持
	&man.cpio.1; 所提供的全部功能， 但也不需要 <command>cpio</command>
	所需要使用的诡异的命令行管道。</para>

      <indexterm><primary><command>tar</command></primary></indexterm>

      <para>在 FreeBSD 5.3 和更高版本中， 同时提供了 GNU <command>tar</command>
        和默认的 <command>bsdtar</command>。
        GNU 的版本可以通过 <command>gtar</command> 来使用。 它通过与
        <command>rdump</command> 一样的语法来支持远程设备。
        要 <command>tar</command> 到连接在名为
        <hostid>komodo</hostid> 的 Sun 机器上的
        Exabyte 磁带机， 可以使用：</para>

      <screen>&prompt.root; <userinput>/usr/bin/gtar cf komodo:/dev/nsa8 . 2>&amp;1</userinput></screen>

      <para>您也可以让
	<command>bsdtar</command> 通过管道和
	<command>rsh</command> 将数据发送到远程的磁带机上。</para>

      <screen>&prompt.root; <userinput>tar cf - . | rsh <replaceable>hostname</replaceable> dd of=<replaceable>tape-device</replaceable> obs=20b</userinput></screen>

      <para>如果您担心通过网络备份会有安全问题，应当使用 <command>ssh</command> ，
        而不是 <command>rsh</command>。</para>
    </sect2>

    <sect2>
      <title><command>cpio</command></title>
      <indexterm>
        <primary>backup software</primary>
        <secondary><command>cpio</command></secondary>
      </indexterm>

      <para>&man.cpio.1; 是 &unix; 最早用来作文件交换的磁带机程序。它有执行字节
        交换的选项，可以用几种不同的格式写入，并且可以将数据用管道传给其他程序。
         <command>cpio</command> 没办法自动查找目录树内的文件列表，必须通过标准
         输入 <filename>stdin</filename> 来指定。</para>
      <indexterm><primary><command>cpio</command></primary></indexterm>

      <para><command>cpio</command> 不支持通过网络的备份方式。可以使用 pipeline 和
       <command>rsh</command> 来传送数据给远程的磁带机。</para>

      <screen>&prompt.root; <userinput>for f in <replaceable>directory_list; do</replaceable></userinput>
<userinput>find $f >> backup.list</userinput>
<userinput>done</userinput>
&prompt.root; <userinput>cpio -v -o --format=newc < backup.list | ssh <replaceable>user</replaceable>@<replaceable>host</replaceable> "cat > <replaceable>backup_device</replaceable>"</userinput></screen>

      <para>这里的 <replaceable>directory_list</replaceable> 是要备份的目录列表，
      	<replaceable>user</replaceable>@<replaceable>host</replaceable> 结合了将
      	要执行备份的用户名和主机名，<replaceable>backup_device</replaceable> 是写
      	入备份的设备（如 <filename>/dev/nsa0</filename>）。</para>
    </sect2>

    <sect2>
      <title><command>pax</command></title>
      <indexterm>
        <primary>backup software</primary>
        <secondary><command>pax</command></secondary>
      </indexterm>
      <indexterm><primary><command>pax</command></primary></indexterm>
      <indexterm><primary>POSIX</primary></indexterm>
      <indexterm><primary>IEEE</primary></indexterm>

      <para>&man.pax.1; 是符合 IEEE/&posix; 标准的程序。多年来各种不同版本
        的 <command>tar</command> 和 <command>cpio</command> 间有些不兼容。
        为了防止这种情况，并使其标准化，&posix; 出了这套新的工具程序。
         <command>pax</command> 尝试可以读写各种 <command>cpio</command>
	和 <command>tar</command> 的格式，并可以自己增加新的格式。它的命令
	集比 <command>tar</command> 更接近 <command>cpio</command>。</para>
    </sect2>

    <sect2 id="backups-programs-amanda">
      <title><application>Amanda</application></title>
      <indexterm>
        <primary>backup software</primary>
        <secondary><application>Amanda</application></secondary>
      </indexterm>
      <indexterm><primary><application>Amanda</application></primary></indexterm>

      <!-- Remove link until <port> tag is available -->
      <para><application>Amanda</application> (Advanced Maryland
        Network Disk Archiver) 并非单一的程序，而是一个客户机/服务器模式的备份系统
        。一台 <application>Amanda</application> 服务器可以备份任意数量执行
        <application>Amanda</application> 的客户机或是将连上 <application>Amanda</application> 
        服务器的计算机上的数据备份到一台磁带机上。一个常见的问题是，数据写入磁带机的时间将超
        过取行数据的时间，而 <application>Amanda</application> 解决了这个问题。它使用一个
         <quote>holding disk</quote> 来同时备份几个文件系统。 <application>Amanda</application>
         建立 <quote>archive sets</quote> 的一组磁带，用来备份在 <application>Amanda</application>
         的配置文件中所列出的完整的文件系统。</para>

      <para> <application>Amanda</application> 配置文件提供完整的备份控制及
        <application>Amanda</application> 产生的网络传输。 <application>Amanda</application> 
        可以使用上述任何一个设备程序来向磁带写入数据。<application>Amanda</application> 
        可以从 port 或 package 取得，它并非系统默认安装的。</para>
      </sect2>

    <sect2>
      <title>Do Nothing 备份策略</title>

      <para><quote>Do nothing</quote> 不是一个程序，而是被广泛使用的备份策略。
        不需要预算，不需要备份的计划表，全部都不用。如果您的数据发生了什么问题，
        忽略它！</para>

      <para>如果您的时间和数据不值得您做这些事，那么 <quote>Do nothing</quote> 
        将是最好的备份程序。要注意的是，&unix; 是相当好用的工具，您可能在几个月
        内，就发现您已经收集了不少对您来说相当具有价值的文件和程序。</para>

      <para><quote>Do nothing</quote> 对于像 <filename>/usr/obj</filename> 和其他
        可由您的计算机产生的文件来说，是最好的方法。例如这本手册包含有 HTML 或 
        &postscript; 格式的文件。这些文档格式是从 SGML 输入文件创建的。创建 HTML
        或 &postscript; 格式的文件的备份就没有必要了。只要经常备份 SGML 文件就够了。</para>
    </sect2>

    <sect2>
      <title>哪个备份程序最好？</title>
      <indexterm>
        <primary>LISA</primary>
      </indexterm>

      <para>在&man.dump.8; <emphasis>时期</emphasis> Elizabeth D. Zwicky
        测试了所有以上列出的备份程序。在各种各样怪异的文件系统中，
         <command>dump</command> 是您明智的选择。Elizabeth 建立起各种各样、
         奇怪或常见的文件系统，并用各种备份程序，测试在各种文件系统上备份
         及恢复数据。这些怪异之处包括：具有 holes 和一个 nulls block 的文件，
         文件名具有有趣字符，无法读写的文件及设备，在备份时改变文件大小，在
         备份时建立或删除的文件。她将结果刑在： LISA V in Oct. 1991.
	See <ulink
	  url="http://berdmann.dyndns.org/zwicky/testdump.doc.html">torture-testing
	  Backup and Archive Programs</ulink>.</para>
    </sect2>

    <sect2>
      <title>应急恢复程序</title>

      <sect3>
	<title>在出现灾难前</title>

	<para>在遇到灾难前，只需要执行以下四个步骤：</para>
	<indexterm>
    <primary><command>disklabel</command></primary>
  </indexterm>

	<para>第一，打出您的每个磁盘驱动器的磁盘标签(例如：
	   <command>disklabel da0 | lpr</command>)，文件系统表，
	  (<filename>/etc/fstab</filename>) ，以及所有启动信息，并将每个拷贝
	  两份。</para>

	<indexterm><primary>fix-it floppies</primary></indexterm>
	<para>第二，确定遇到的情况时，用来启动及修复的软盘
	  (<filename>boot.flp</filename> 和 <filename>fixit.flp</filename>)
	  具有您所有的设备代号。最简单的方法是用软盘启动，然后检查启动信息，
	  如果设备都被列出，并且可以正常使用，就可以跳到第三步。</para>

	<para>否则，必须建立两张传统的可启动软盘，并包含：
	  <command>fdisk</command>, <command>disklabel</command>,
	  <command>newfs</command>, <command>mount</command>, 以及所有使用的
	  备份程序。这些程序必须被静态的连接。如果使用的是 <command>dump</command>，
	  那么这张软盘就必须包含 <command>restore</command>。</para>

	<para>第三，定期将数据备份到磁带。任何在上次备份后的改变都无法恢复。记得将
	  磁盘写保护。</para>

	<para>第四，测试在第二步所建立的软盘及备份的磁带，将过程记录下来，并和这张
	  可启动的软盘和磁带放在一起。也许您在恢复时会想要，而这份记录将防止您破坏
	  您的磁带 (怎么说呢？因为您可能将 <command>tar xvf /dev/sa0</command> 打成
	   <command>tar cvf /dev/sa0</command> 而重写了备份磁带)。</para>

	<para>为了安全，您可以每次都做两份备份磁带及一张启动磁盘，并将其中
	  一份备份磁带存放在其它地方。其它地方不是指同一栋办公大楼的地下室
	  (世贸中心的一些公司应该学到了一些教训)，而是真的要让人的磁带离您
	  的的计算机远远的。</para>

	<example>
	  <title>一个建立启动磁盘的 shell 脚本例子：</title>

	<programlisting><![ CDATA [#!/bin/sh
#
# create a restore floppy
#
# format the floppy
#
PATH=/bin:/sbin:/usr/sbin:/usr/bin

fdformat -q fd0
if [ $? -ne 0 ]
then
	 echo "Bad floppy, please use a new one"
	 exit 1
fi

# place boot blocks on the floppy
#
disklabel -w -B /dev/fd0c fd1440

#
# newfs the one and only partition
#
newfs -t 2 -u 18 -l 1 -c 40 -i 5120 -m 5 -o space /dev/fd0a

#
# mount the new floppy
#
mount /dev/fd0a /mnt

#
# create required directories
#
mkdir /mnt/dev
mkdir /mnt/bin
mkdir /mnt/sbin
mkdir /mnt/etc
mkdir /mnt/root
mkdir /mnt/mnt			# for the root partition
mkdir /mnt/tmp
mkdir /mnt/var

#
# populate the directories
#
if [ ! -x /sys/compile/MINI/kernel ]
then
	 cat << EOM
The MINI kernel does not exist, please create one.
Here is an example config file:
#
# MINI -- A kernel to get FreeBSD onto a disk.
#
machine         "i386"
cpu             "I486_CPU"
ident           MINI
maxusers        5

options         INET                    # needed for _tcp _icmpstat _ipstat
                                        #            _udpstat _tcpstat _udb
options         FFS                     #Berkeley Fast File System
options         FAT_CURSOR              #block cursor in syscons or pccons
options         SCSI_DELAY=15           #Be pessimistic about Joe SCSI device
options         NCONS=2                 #1 virtual consoles
options         USERCONFIG              #Allow user configuration with -c XXX

config          kernel	root on da0 swap on da0 and da1 dumps on da0

device          isa0
device          pci0

device          fdc0	at isa? port "IO_FD1" bio irq 6 drq 2 vector fdintr
device          fd0	at fdc0 drive 0

device          ncr0

device          scbus0

device          sc0	at isa? port "IO_KBD" tty irq 1 vector scintr
device          npx0	at isa? port "IO_NPX" irq 13 vector npxintr

device          da0
device          da1
device          da2

device          sa0

pseudo-device   loop            # required by INET
pseudo-device   gzip            # Exec gzipped a.out's
EOM
	 exit 1
fi

cp -f /sys/compile/MINI/kernel /mnt

gzip -c -best /sbin/init > /mnt/sbin/init
gzip -c -best /sbin/fsck > /mnt/sbin/fsck
gzip -c -best /sbin/mount > /mnt/sbin/mount
gzip -c -best /sbin/halt > /mnt/sbin/halt
gzip -c -best /sbin/restore > /mnt/sbin/restore

gzip -c -best /bin/sh > /mnt/bin/sh
gzip -c -best /bin/sync > /mnt/bin/sync

cp /root/.profile /mnt/root

cp -f /dev/MAKEDEV /mnt/dev
chmod 755 /mnt/dev/MAKEDEV

chmod 500 /mnt/sbin/init
chmod 555 /mnt/sbin/fsck /mnt/sbin/mount /mnt/sbin/halt
chmod 555 /mnt/bin/sh /mnt/bin/sync
chmod 6555 /mnt/sbin/restore

#
# create the devices nodes
#
cd /mnt/dev
./MAKEDEV std
./MAKEDEV da0
./MAKEDEV da1
./MAKEDEV da2
./MAKEDEV sa0
./MAKEDEV pty0
cd /

#
# create minimum file system table
#
cat > /mnt/etc/fstab <<EOM
/dev/fd0a    /    ufs    rw  1  1
EOM

#
# create minimum passwd file
#
cat > /mnt/etc/passwd <<EOM
root:*:0:0:Charlie &:/root:/bin/sh
EOM

cat > /mnt/etc/master.passwd <<EOM
root::0:0::0:0:Charlie &:/root:/bin/sh
EOM

chmod 600 /mnt/etc/master.passwd
chmod 644 /mnt/etc/passwd
/usr/sbin/pwd_mkdb -d/mnt/etc /mnt/etc/master.passwd

#
# umount the floppy and inform the user
#
/sbin/umount /mnt
echo "The floppy has been unmounted and is now ready."]]></programlisting>

        </example>

      </sect3>

      <sect3>
	<title>出现灾难后</title>

	<para>关键问题是： 您的硬件是否幸免于难？
	  由于已经做好了定期的备份工作， 旖旎并不需要担心软件的问题。</para>

	<para>如果硬件已经损毁， 这些部分应该在尝试使用计算机之前换掉。</para>

	<para>如果硬件还能用， 检查一下您的软盘。 如果使用定制的引导软盘，
	  启动单用户模式 (在 <prompt>boot:</prompt> 提示后输入
	  <literal>-s</literal>)。 跳过下面一段。</para>

	<para>如果您使用 <filename>boot.flp</filename> 和
	  <filename>fixit.flp</filename> 软盘， 请继续阅读。 将
	  <filename>boot.flp</filename>
	  软盘插到计算机的第一个软驱并启动机器。 此时，
	  最初的安装菜单将显示在屏幕上。
	  选择 <literal>Fixit--Repair mode with CDROM or floppy.</literal>
	  选项。 在得到提示后插入
	  <filename>fixit.flp</filename> 。
	  <command>restore</command> 以及其他需要的程序，
	  可以在 <filename class="directory">/mnt2/rescue</filename>
	  (对于 &os; 5.2 之前的版本， 则是
	  <filename class="directory">/mnt2/stand</filename>)。</para>

	<para>分别恢复每一个文件系统</para>

	<indexterm>
    <primary><command>mount</command></primary>
  </indexterm>
	<indexterm><primary>root partition</primary></indexterm>
	<indexterm>
    <primary><command>disklabel</command></primary>
  </indexterm>
	<indexterm>
    <primary><command>newfs</command></primary>
  </indexterm>
	<para>试着 <command>mount</command> 上您的第一个磁盘的 root 分区(例如： <command>mount /dev/da0a
	    /mnt</command>)。假如这个磁盘标签已经损坏，使用 <command>disklabel</command> 
	    来重新分割并分配磁盘标签（利用您以前保留下来的数据）。使用 <command>newfs</command> 
	    来建立文件系统，并重新挂上软盘读写的 root 分区 (<command>mount -u -o rw
	    /mnt</command>)。然后使用备份程序及备份磁带来修复文件系统 (例如： <command>restore vrf
	    /dev/sa0</command>)。最后 Unmount 这个文件系统 (例如： <command>umount
	    /mnt</command>)。对于每个损坏的文件系统都重复一次。</para>

	<para>当您的系统正常启动后，将您的数据备份到新的磁带。任何造成数据丢失的
	  的灾难都可能再次发生。现在花一些时间，也许可以使您免于下次的灾难。</para>
      </sect3>

<![ %not.published; [

      <sect3>
	<title>* I Did Not Prepare for the Disaster, What Now?</title>

	<para></para>
      </sect3>
]]>

    </sect2>
  </sect1>

  <sect1 id="disks-virtual">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Marc</firstname>
	  <surname>Fonvieille</surname>
	  <contrib>Reorganized and enhanced by </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>网络、内存和 File-Backed 文件系统</title>
    <indexterm><primary>virtual disks</primary></indexterm>
    <indexterm>
      <primary>磁盘</primary>
      <secondary>虚拟</secondary>
    </indexterm>

    <para>除了你的物理磁盘以外，插入你计算机的：
      软盘 CDs，硬盘驱动器，等等；其它磁盘格式是不被
       FreeBSD - <firstterm>virtual
      disks</firstterm>支持的。</para>

    <indexterm><primary>NFS</primary></indexterm>
    <indexterm><primary>Coda</primary></indexterm>
    <indexterm>
      <primary>disks</primary>
      <secondary>memory</secondary>
    </indexterm>
    <para>这还包括网络文件系统，例如 <link
	linkend="network-nfs">Network File System</link> 和 Coda, 基于内存的
      文件系统和后备文件系统。</para>

    <para>按照你运行的 FreeBSD 版本，你可以使用不同的工具来创建和使用
      后备文件系统和内存文件系统。</para>

    <note>
      <para>FreeBSD&nbsp;4.X 用户可以使用 &man.MAKEDEV.8;
	来创建需要的设备。 FreeBSD&nbsp;5.0 和更新的版本使用
	&man.devfs.5; 来创建设备节点，对用户来说是透明的。</para>
    </note>

    <sect2 id="disks-vnconfig">
      <title>FreeBSD&nbsp;4.X 下的 File-Backed 文件系统</title>
      <indexterm>
        <primary>磁盘</primary>
        <secondary>file-backed (4.X)</secondary>
      </indexterm>

      <para>应用程序 &man.vnconfig.8; 可以配置和启用 vnode 伪磁盘设备。
	一个 <firstterm>vnode</firstterm> 代表一个文件。这就意味
	使用 &man.vnconfig.8; 可以用来创建和操作一个文件系统。
	也可以在文件中挂接一个软盘或 CD 映像。</para>

      <para>要使用 &man.vnconfig.8;，你需要在内核配置文件中 &man.vn.4; 的支持：</para>

      <programlisting>pseudo-device vn</programlisting>

      <para>挂接一个存在的文件系统映像：</para>

      <example>
	<title>使用 vnconfig 来挂接一个存在的文件系统映像在
	   FreeBSD&nbsp;4.X 系统上。</title>

	<screen>&prompt.root; <userinput>vnconfig vn<replaceable>0</replaceable> <replaceable>diskimage</replaceable></userinput>
&prompt.root; <userinput>mount /dev/vn<replaceable>0</replaceable>c <replaceable>/mnt</replaceable></userinput></screen>
      </example>

      <para>使用 &man.vnconfig.8; 创建一个新的文件系统映像：</para>

      <example>
	<title>使用 <command>vnconfig</command> 创建新的文件后援磁盘</title>

	<screen>&prompt.root; <userinput>dd if=/dev/zero of=<replaceable>newimage</replaceable> bs=1k count=<replaceable>5</replaceable>k</userinput>
5120+0 records in
5120+0 records out
&prompt.root; <userinput>vnconfig -s labels -c vn<replaceable>0</replaceable> <replaceable>newimage</replaceable></userinput>
&prompt.root; <userinput>disklabel -r -w vn<replaceable>0</replaceable> auto</userinput>
&prompt.root; <userinput>newfs vn<replaceable>0</replaceable>c</userinput>
Warning: 2048 sector(s) in last cylinder unallocated
/dev/vn0c:     10240 sectors in 3 cylinders of 1 tracks, 4096 sectors
        5.0MB in 1 cyl groups (16 c/g, 32.00MB/g, 1280 i/g)
super-block backups (for fsck -b #) at:
 32
&prompt.root; <userinput>mount /dev/vn<replaceable>0</replaceable>c <replaceable>/mnt</replaceable></userinput>
&prompt.root; <userinput>df <replaceable>/mnt</replaceable></userinput>
Filesystem  1K-blocks     Used    Avail Capacity  Mounted on
/dev/vn0c        4927        1     4532     0%    /mnt</screen>
      </example>
    </sect2>

    <sect2 id="disks-mdconfig">
      <title>FreeBSD&nbsp;5.X 下的 File-Backed 文件系统</title>
      <indexterm>
        <primary>磁盘</primary>
        <secondary>file-backed (5.X)</secondary>
      </indexterm>

      <para>在 FreeBSD&nbsp;5.X 系统中使用应用程序 &man.mdconfig.8; 
      　被用来配置和启用内存磁盘，&man.md.4;，使用
	&man.mdconfig.8;你需要在你的内核配置文件中添加 &man.md.4; 模块来支持它：</para>

      <programlisting>device md</programlisting>

      <para> &man.mdconfig.8; 命令支持三种类型的内存后备虚拟磁盘：
	使用 &man.malloc.9;，来分配内存磁盘，内存磁盘作为文件或作为
	备用的交换分区。一种使用方式是在文件中来挂接一个软盘和
	 CD 映像。</para>

      <para>挂接一个存在的文件系统映像：</para>

      <example>
	<title>在 FreeBSD&nbsp;5.X 中使用 <command>mdconfig</command> 命令来挂接一个存在的文件系统映像。</title>

	<screen>&prompt.root; <userinput>mdconfig -a -t vnode -f <replaceable>diskimage</replaceable> -u <replaceable>0</replaceable></userinput>
&prompt.root; <userinput>mount /dev/md<replaceable>0</replaceable> <replaceable>/mnt</replaceable></userinput></screen>
      </example>

      <para>使用 &man.mdconfig.8; 来创建一个新的文件系统映像:</para>

      <example>
	<title>使用 <command>mdconfig</command> 创建一个新的文件后援磁盘</title>

	<screen>&prompt.root; <userinput>dd if=/dev/zero of=<replaceable>newimage</replaceable> bs=1k count=<replaceable>5</replaceable>k</userinput>
5120+0 records in
5120+0 records out
&prompt.root; <userinput>mdconfig -a -t vnode -f <replaceable>newimage</replaceable> -u <replaceable>0</replaceable></userinput>
&prompt.root; <userinput>disklabel -r -w md<replaceable>0</replaceable> auto</userinput>
&prompt.root; <userinput>newfs md<replaceable>0</replaceable>c</userinput>
/dev/md0c: 5.0MB (10240 sectors) block size 16384, fragment size 2048
	using 4 cylinder groups of 1.27MB, 81 blks, 256 inodes.
super-block backups (for fsck -b #) at:
 32, 2624, 5216, 7808
&prompt.root; <userinput>mount /dev/md<replaceable>0</replaceable>c <replaceable>/mnt</replaceable></userinput>
&prompt.root; <userinput>df <replaceable>/mnt</replaceable></userinput>
Filesystem  1K-blocks     Used    Avail Capacity  Mounted on
/dev/md0c        4846        2     4458     0%    /mnt</screen>
      </example>

      <para>如果你没有使用 <option>-u</option> 选项指定一个单位号
	 &man.mdconfig.8; 将使用
	&man.md.4; 自动为它选择一个未使用的设备。
	分配给它的单位名将被输出到标准输出设备像
	<devicename>md4</devicename>。想得到更多的关于
	&man.mdconfig.8; 的信息请参考手册页。</para>

      <note><para>从 &os;&nbsp;5.1-RELEASE 开始， &man.bsdlabel.8;
	程序代替了旧版的 &man.disklabel.8; 程序。相应的
	&man.bsdlabel.8; 中的许多陈旧的选项和参数也被取消；
	在上面的例子中选项
	<option>-r</option> 应该被删掉。想获得更多的信息，
	请参考 &man.bsdlabel.8; 的手册页。</para></note>

      <para>应用程序 &man.mdconfig.8; 是非常有作的，然而它
	需要许多命令行来创建一个 file-backed 文件系统。
	FreeBSD&nbsp;5.0 也提供了一个被称作 &man.mdmfs.8; 的工具，
	这个程序配置一个 &man.md.4; 磁盘使用
	&man.mdconfig.8;，在它上面安装一个 UFS 文件系统使用
	&man.newfs.8;，挂接它使用 &man.mount.8;。例如，
	如果你想创建和挂接像上面一样的文件系统映像，
	简单的执行下面的步骤：</para>

      <example>
	<title>使用 <command>mdmfs</command> 命令配置和挂接一个 File-Backed 磁盘</title>
	<screen>&prompt.root; <userinput>dd if=/dev/zero of=<replaceable>newimage</replaceable> bs=1k count=<replaceable>5</replaceable>k</userinput>
5120+0 records in
5120+0 records out
&prompt.root; <userinput>mdmfs -F <replaceable>newimage</replaceable> -s <replaceable>5</replaceable>m md<replaceable>0</replaceable> <replaceable>/mnt</replaceable></userinput>
&prompt.root; <userinput>df <replaceable>/mnt</replaceable></userinput>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md0        4846    2  4458     0%    /mnt</screen>
      </example>

      <para>如果你使用没有加单位号的 <option>md</option> 选项，
	&man.mdmfs.8; 将使用 &man.md.4; 的自动单位号特性来自动为其
	选择一个未使用的设备。更详细的
	 &man.mdmfs.8;，请参考手册页。</para>

    </sect2>

    <sect2 id="disks-md-freebsd4">
      <title>FreeBSD&nbsp;4.X 下的内存后备式文件系统</title>
      <indexterm>
        <primary>磁盘</primary>
        <secondary>内存文件系统(4.X)</secondary>
      </indexterm>

      <para> &man.md.4; 驱动程序是一个简单有效的手段用来创建
	内存文件系统在 FreeBSD&nbsp;4.X 系统上。&man.malloc.9; 被
	用来分配内存。</para>

      <para>简单的获得一个文件系统你需要准备，例如：
	 &man.vnconfig.8;</para>

      <example>
	<title>FreeBSD&nbsp;4.X 下的 md 内存磁盘</title>

	<screen>&prompt.root; <userinput>dd if=<replaceable>newimage</replaceable> of=/dev/md<replaceable>0</replaceable></userinput>
5120+0 records in
5120+0 records out
&prompt.root; <userinput>mount /dev/md<replaceable>0c</replaceable> <replaceable>/mnt</replaceable></userinput>
&prompt.root; <userinput>df <replaceable>/mnt</replaceable></userinput>
Filesystem  1K-blocks     Used    Avail Capacity  Mounted on
/dev/md0c        4927        1     4532     0%    /mnt</screen>
      </example>

      <para>更多的详情，请参考 &man.md.4; 手册页。</para>
    </sect2>

    <sect2 id="disks-md-freebsd5">
      <title>FreeBSD&nbsp;5.X 下的内存后备式文件系统</title>
      <indexterm>
        <primary>磁盘</primary>
        <secondary>内存文件系统(5.X)</secondary>
      </indexterm>

      <para>同样的工具也可以用来创建内存后备式文件系统：
	 &man.mdconfig.8; 或 &man.mdmfs.8;。内存后备文件系统的
	内存分配要使用 &man.malloc.9; 来完成。</para>

      <example>
	<title>用 <command>mdconfig</command>
	  创建一个新的内存后备磁盘</title>

	<screen>&prompt.root; <userinput>mdconfig -a -t malloc -s <replaceable>5</replaceable>m -u <replaceable>1</replaceable></userinput>
&prompt.root; <userinput>newfs -U md<replaceable>1</replaceable></userinput>
/dev/md1: 5.0MB (10240 sectors) block size 16384, fragment size 2048
	using 4 cylinder groups of 1.27MB, 81 blks, 256 inodes.
	with soft updates
super-block backups (for fsck -b #) at:
 32, 2624, 5216, 7808
&prompt.root; <userinput>mount /dev/md<replaceable>1</replaceable> <replaceable>/mnt</replaceable></userinput>
&prompt.root; <userinput>df <replaceable>/mnt</replaceable></userinput>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md1        4846    2  4458     0%    /mnt</screen>
      </example>

      <example>
	<title>用 <command>mdmfs</command>
	  创建一个新的内存后备磁盘</title>
	<screen>&prompt.root; <userinput>mdmfs -M -s <replaceable>5</replaceable>m md<replaceable>2</replaceable> <replaceable>/mnt</replaceable></userinput>
&prompt.root; <userinput>df <replaceable>/mnt</replaceable></userinput>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md2        4846    2  4458     0%    /mnt</screen>
      </example>

      <para>代替使用一个 &man.malloc.9; 后备文件系统，可以使用
	 swap，正确的替换使用 <option>swap</option> 替换
	<option>malloc</option> 在命令行
	 &man.mdconfig.8; 中。&man.mdmfs.8; 程序默认
	 (没有 <option>-M</option> 选项) 创建一个 swap-based
	磁盘。更多的详情，请参考 &man.mdconfig.8;
	和 &man.mdmfs.8; 手册页。</para>
    </sect2>

    <sect2>
      <title>从系统中移除内存盘</title>
      <indexterm>
        <primary>磁盘</primary>
        <secondary>移除内存盘</secondary>
      </indexterm>

      <para>当一个内存后备式文件系统不再使用时，你应该释放掉系统的资源。
	每一件要做的事情就是摘掉文件系统，然后使用
	&man.mdconfig.8; 把磁盘从系统中分离出来释放看资源。</para>

      <para>例如分离和释放所有的资源使用
	<filename>/dev/md4</filename> 命令：</para>

      <screen>&prompt.root; <userinput>mdconfig -d -u <replaceable>4</replaceable></userinput></screen>

      <para><command>mdconfig -l</command> 命令可以列出关于配置
	&man.md.4; 设备的信息。</para>

      <para>在 FreeBSD&nbsp;4.X 系统中，&man.vnconfig.8; 命令用来分离设备。
	例如分离所有的资源使用 <filename>/dev/vn4</filename> 命令：</para>

      <screen>&prompt.root; <userinput>vnconfig -u vn<replaceable>4</replaceable></userinput></screen>


    </sect2>
  </sect1>

  <sect1 id="snapshots">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Contributed by </contrib>
	</author>
      </authorgroup>
      <!-- 15 JUL 2002 -->
    </sect1info>

    <title>文件系统快照</title>

    <indexterm>
      <primary>文件系统</primary>
      <secondary>快照</secondary>
    </indexterm>

      <para>FreeBSD&nbsp;5.0 提供了一个和 <link linkend="soft-updates">Soft Updates</link>
	关联的新功能: 文件系统快照</para>

      <para>快照允许用户创建指定文件系统的映像，并把它们当做一个文件来对待。
	快照文件必须在文件系统正在使用时创建，一个用户对每个文件系统创建的
	快照不能大于20个。活动的快照文件被记录在超级块中，所以它们可以在系统
	启动的时候一块进行挂接后摘掉。当一个快照不再需要时，可以使用标准的
	 &man.rm.1; 使用来使其删除。快照可以以任何顺序进行移除，但所有使用
	的快照不可能同时进行移除，因为其它的快照将有可能互相引用一些块。</para>

      <para>不可改的 <option>snapshot</option> 文件标志，
      是由 &man.mksnap.ffs.8; 在完成创建快照文件时设置的。
	&man.unlink.1; 命令是一个特例， 以允许删除快照文件。</para>

      <para>快照可以通过 &man.mount.8; 命令创建。 将文件系统
	 <filename>/var</filename> 的快照放到
	<filename>/var/snapshot/snap</filename> 可以使用下面的命令：</para>

<screen>&prompt.root; <userinput>mount -u -o snapshot /var/snapshot/snap /var</userinput></screen>

      <para>作为选择，你也可以使用 &man.mksnap.ffs.8; 来创建一个快照：</para>
<screen>&prompt.root; <userinput>mksnap_ffs /var /var/snapshot/snap</userinput></screen>

      <para>可以查找文件系统中的快照文件 (例如 <filename>/var</filename>)，
        方法是使用 &man.find.1; 命令：</para>
<screen>&prompt.root; <userinput>find /var -flags snapshot</userinput></screen>

      <para>当快照文件被创建好后，可以用于下面一些目的：</para>

      <itemizedlist>
	<listitem>
	  <para>有些管理员用文件快照来进行备份，
	    因为快照可以被转移到 CD 或磁带上。</para>
	</listitem>

	<listitem>
	  <para>检查文件系统的完整性， &man.fsck.8; 可以用来检查快照文件。
	    假设文件系统在挂接后前是一致的，
	    则会得到一致的结果 (不做修改)。
	    这是由 &man.fsck.8; 进程在后台完成的。</para>
	</listitem>

	<listitem>
	  <para>在快照上运行 &man.dump.8; 程序。
	    dump 将返回包含文件系统和快照的时间戳。&man.dump.8;
	    也能够抓取快照，使用 <option>-L</option>
	    标志可以首先创建快照， 完成 dump 映像之后再自动删除它。</para>
	</listitem>

	<listitem>
	  <para>用 &man.mount.8; 来挂接快照作为文件系统的一个冻结的镜像。
	    要 &man.mount.8; 快照
	    <filename>/var/snapshot/snap</filename> 运行：</para>

<screen>&prompt.root; <userinput>mdconfig -a -t vnode -f /var/snapshot/snap -u 4</userinput>
&prompt.root; <userinput>mount -r /dev/md4 /mnt</userinput></screen>

	</listitem>
      </itemizedlist>

      <para>现在你就可以看到挂接在 <filename>/mnt</filename> 目录下的 <filename>/var</filename>
	文件系统的快照。 每一样东西都保存的像它创建时的状态一样。
	唯一例外的是更早的快照文件将表现为长度为 0 的文件。
	用完快照文件之后可以把它卸下，使用：</para>

<screen>&prompt.root; <userinput>umount /mnt</userinput>
&prompt.root; <userinput>mdconfig -d -u 4</userinput></screen>

      <para>想了解更多关于 <option>softupdates</option> 和
	文件系统快照的信息， 包括技术说明， 可以访问
	Marshall Kirk McKusick 的 WWW 站点
	<ulink url="http://www.mckusick.com/"></ulink>。</para>
  </sect1>

  <sect1 id="quotas">
    <title>文件系统配额</title>
    <indexterm>
      <primary>accounting</primary>
      <secondary>disk space</secondary>
    </indexterm>
    <indexterm><primary>disk quotas</primary></indexterm>

    <para>配额是操作系统的一个可选择的属性，它允许限制用户使用的磁盘空间大小或是
      使用的文件数量。这可以防止某个用户占用所有的磁盘空间。</para>

    <sect2>
      <title>配置系统来启用磁盘配额</title>

      <para>在决定使用磁盘配额前，确信磁盘配额已经在内核中配置好了。只要在在内核
        中配置文件中添加下面一行就行了：</para>

      <programlisting>options QUOTA</programlisting>

      <para>在默认情况下 <filename>GENERIC</filename> 内核是不会启用这个功能的，
        所以必须配置、重建和安装一个定制的内核。请参考 FreeBSD 内核配置
	 <xref linkend="kernelconfig"> 这章了解更多有关内核配置的信息。</para>

      <para>接下来，需要在 <filename>/etc/rc.conf</filename> 中启用磁盘配额。可以
        通过添加下面这行来完成：</para>

      <programlisting>enable_quotas="YES"</programlisting>
      <indexterm>
        <primary>disk quotas</primary>
        <secondary>checking</secondary>
      </indexterm>
      <para>为了更好的控制配额时的启动，还有另外一个可配置的变量。通常
        启动时，集成在每个文件系统上的配额会被配额检查程序
        &man.quotacheck.8; 自动检查。配额检查功能能够确保在配额数据库中
        的数据正确地反映了文件系统的数
        据情况。这是一个很耗时间的处理进程，它会影响系统的启动时间。如果
        想跳过这一步，可以在文件  <filename>/etc/rc.conf</filename> 加入
        下面这一行来达到目的：</para>

      <programlisting>check_quotas="NO"</programlisting>

      <para>最后，要编辑 <filename>/etc/fstab</filename> 文件，以在每一个
        文件系统基础上雇用磁盘配额。这是启用用户和组配额，或同时启用用户
        和组配额的地方。</para>

      <para>要在一个文件系统上启用每个用户的配额，可以在 <filename>/etc/fstab</filename>
        里添加 <option>userquota</option> 选项在要雇用配额文件的系统上。例如：</para>

      <programlisting>/dev/da1s2g   /home    ufs rw,userquota 1 2</programlisting>

      <para>同样的，要启用组配额，使用 <option>groupquota</option> 选项来代替
        <option>userquota</option> 选项。要同时启用用户和组配额，可以这样做：</para>

      <programlisting>/dev/da1s2g    /home    ufs rw,userquota,groupquota 1 2</programlisting>

      <para>默认情况下，配额文件是存放在文件系统的以 <filename>quota.user</filename> 
        和 <filename>quota.group</filename> 命名的根目录下。可以查看 &man.fstab.5; 
        联机手册了解更多信息。即使联机手册 &man.fstab.5; 说中以为配额文件指定其他
        的位置，这里并不推荐这样做，因为不同的配额工具不一定遵循这样的规则。</para>

      <para>到这儿，可以用新内核重新启动系统。 <filename>/etc/rc</filename> 将自动
        运行适当的命令来创建最初的配额文件，所以并不需要手动来创建任何零长度的配额
        文件。</para>

      <para>在通常的操作过程中，并不要求手动运行 &man.quotacheck.8;、
	&man.quotaon.8;, 或 &man.quotaoff.8; 命令，然而可能需要阅读与他们的操作
	相似的联机手册。</para>
    </sect2>

    <sect2>
      <title>设置配额限制</title>
      <indexterm>
        <primary>disk quotas</primary>
        <secondary>limits</secondary>
      </indexterm>

      <para>一旦您配置好了启用配额的系统，可以检查一下它们是真的有用。
        可以这样做：</para>

      <screen>&prompt.root; <userinput>quota -v</userinput></screen>

      <para>您应该能够看到一行当前正在使用的每个文件系统启用的磁盘配额
        使用情况的摘要信息。</para>

      <para>现在可以使用 &man.edquota.8; 命令准备启用配额限制。</para>

      <para>有几个有关如何强制限制用户或组可以分配到的磁盘空间大小的选项。
        您可以限制磁盘存储块的配额， 或文件的数量， 甚至同时限制两者。
        这些限制最终可分为两类： 硬限制和软限制。</para>

      <indexterm><primary>硬性限制</primary></indexterm>
      <para>硬性限制是一种不能越过的限制。 一旦用户达到了系统指定的硬性限制，
	他就无法在对应的文件系统分配到更多的资源。
	例如， 如果文件系统上分给用户的硬性限制是
	500 KB， 而现在已经用掉了 490 KB，
	那么这个用户最多还能再分配 10 KB 的空间。
	换言之， 如果这时试图再分配 11 KB， 则会失败。</para>

      <indexterm><primary>软性限制</primary></indexterm>
      <para>软限制可以被有时间限制性地被越过。这段时间可以被理解为允许限期，
        默认是一个星期。如果一个用户延缓时间太长的话，软限制将会变成硬限制，
        根本就不允许再继续占用磁盘配额。当用户因到软限制以下时，允许延期将
        重新开始计算。</para>

      <para>下面是一个运行 &man.edquota.8; 时看到的例子。当 &man.edquota.8; 
        命令被调用时，会被转移进 <envar>EDITOR</envar> 环境变量指派的编辑
        器中，允许编辑配额限制。如果环境变量没有设置，默认在
         <application>vi</application> 编辑器上进行。</para>

      <screen>&prompt.root; <userinput>edquota -u test</userinput></screen>

      <programlisting>Quotas for user test:
/usr: kbytes in use: 65, limits (soft = 50, hard = 75)
        inodes in use: 7, limits (soft = 50, hard = 60)
/usr/var: kbytes in use: 0, limits (soft = 50, hard = 75)
        inodes in use: 0, limits (soft = 50, hard = 60)</programlisting>

      <para>在每一个启用了磁盘配额的文件系统上，通常会看到两行。一行是
         block 限制，另一行是 inode 限制。简单地改变要修改的配额限制的值。
         例如，提高这个用户软限制的数值到 500 ，硬限制到 600 ：</para>

      <programlisting>/usr: kbytes in use: 65, limits (soft = 50, hard = 75)</programlisting>

      <para>to:</para>

      <programlisting>/usr: kbytes in use: 65, limits (soft = 500, hard = 600)</programlisting>

      <para>当离开编辑器的时候，新的配额限制设置将会被保存。</para>

      <para>有时，在 UIDs 的范围上设置配额限制是非常必要的。这可以通过在
         &man.edquota.8; 命令后面加上 <option>-p</option> 选项来完成。首先，
         给用户分配所需要的配额限制，然后运行命令
	<command>edquota -p protouser startuid-enduid</command>。例如，如果
	用户 <username>test</username> 已经有了所需要的配额限制，下面的命令
	可以被用来复制那些  UIDs 为10,000 到 19,999 的配额限制：</para>

      <screen>&prompt.root; <userinput>edquota -p test 10000-19999</userinput></screen>

      <para>更多细节请参考 &man.edquota.8; 手册页。</para>
    </sect2>

    <sect2>
      <title>检查配额限制和磁盘使用</title>
      <indexterm>
        <primary>disk quotas</primary>
        <secondary>checking</secondary>
      </indexterm>

      <para>即可以使用 &man.quota.1; 也可以使用	&man.repquota.8; 命令来检查
        配额限制和磁盘使用情况。 &man.quota.1; 命令能够检查单个用户和组的配置
        使用情况。只有超级用户才可以检查其它用户的配额和磁盘使用情况。
	&man.repquota.8; 命令可以用来了解所有配额和磁盘的使用情况。</para>

      <para>下面是一个使用 <command>quota -v</command> 命令后的输出情况：</para>

      <programlisting>Disk quotas for user test (uid 1002):
     Filesystem  usage    quota   limit   grace   files   quota   limit   grace
           /usr      65*     50      75   5days       7      50      60
       /usr/var       0      50      75               0      50      60</programlisting>

      <indexterm><primary>宽限期</primary></indexterm>
      <para>前面以 <filename>/usr</filename> 作为例子。
	此用户目前已经比软限制 50 KB 超出了 15 KB，
	还剩下 5 天的宽限期。 请注意，
	星号 <literal>*</literal> 说明用户已经超出了其配额限制。</para>

      <para>通常， 如果用户没有使用文件系统上的磁盘空间， 就不会在
	&man.quota.1; 命令的输出中显示， 即使已经为那个用户指定了配额。
	而使用 <option>-v</option> 选项则会显示它们， 例如前面例子中的
	<filename>/usr/var</filename>。</para>
    </sect2>

    <sect2>
      <title>通过 NFS 使用磁盘配额</title>
      <indexterm><primary>NFS</primary></indexterm>

      <para>配额能够在 NFS 服务器上被配额子系统强迫使用。在 NFS 客房端，
	&man.rpc.rquotad.8; 命令可以使用 quota 信息用于 &man.quota.1; 
	命令，可以允许用户察看它们的 quota 统计信息。</para>

      <para>可以这样在 <filename>/etc/inetd.conf</filename> 中启用
       <command>rpc.rquotad</command>：</para>

      <programlisting>rquotad/1      dgram rpc/udp wait root /usr/libexec/rpc.rquotad rpc.rquotad</programlisting>

      <para>现在重启 <command>inetd</command>：</para>

      <screen>&prompt.root; <userinput>kill -HUP `cat /var/run/inetd.pid`</userinput></screen>
    </sect2>
  </sect1>


  <sect1 id="disks-encrypting">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Lucky</firstname>
	  <surname>Green</surname>
	  <contrib>Contributed by </contrib>
	  <affiliation>
	    <address><email>shamrock@cypherpunks.to</email></address>
	  </affiliation>
	</author>
      </authorgroup>
      <!-- 11 MARCH 2003 -->
    </sect1info>

    <title>加密磁盘分区</title>
    <indexterm>
      <primary>disks</primary>
      <secondary>encrypting</secondary></indexterm>

    <para>FreeBSD 提供了极好的数据保护措施，防止未受权的数据访问。
      文件权限和强制访问控制(MAC)(看 <xref linkend="mac">)
      可以帮助预防在操作系统处于运行状态和计算机加电时未受权的第三方访问数据。
      但是，和操作系统强制受权不相关的是，如果黑客有物理上访问计算机的可能，
      那他就可以简单的把计算机的硬件安装到另一个系统上拷贝出敏感的数据。</para>

    <para>不管怎样，黑客都有可能取得并获取停机时的硬件，
      <application>GEOM 基于磁盘的加密 (gbde)</application>
      能够保护在计算机文件系统上的数据并防止黑客得到重要的信息。
      不像 cumbersome 加密方法只加密个别的文件，
      <application>gbde</application> 透明的加密整个文件系统。
      整个硬盘都是加密过的非明文数据。</para>

    <sect2>
      <title>在内核中启用 gbde</title>

      <procedure>
	<step>
	  <title>成为 <username>root</username></title>

	  <para>配置 <application>gbde</application>
	    需要超级用户的权力。</para>

	  <screen>&prompt.user; <userinput>su -</userinput>
Password:</screen>
	</step>

	<step>
	  <title>验证操作系统的版本</title>

	  <para>&man.gbde.4; 需要 FreeBSD 5.0 或更高的版本。</para>

	  <screen>&prompt.root; <userinput>uname -r</userinput>
5.0-RELEASE</screen>
	</step>

	<step>
	  <title>在内核配置文件中添加对 &man.gbde.4; 的支持</title>

	  <para>使用您喜欢的文本编辑器，
	    在内核配置文件中添加下面一行：</para>

	  <para><literal>options GEOM_BDE</literal></para>

	  <para>配置，编译，安装 FreeBSD 内核，
	    这个过程在 <xref
	    linkend="kernelconfig"> 中有详细描述。</para>

	  <para>重新引导进入新的内核。</para>
	</step>
      </procedure>
    </sect2>


    <sect2>
      <title>准备加密整个硬盘</title>

      <para>下面这个例子假设您添加了一个新的硬盘在您的系统并将拥有一个单独的加密分区。
	这个分区将挂接在 <filename>/private</filename>目录下。
	<application>gbde</application> 也可以用来加密
	<filename>/home</filename> 和 <filename>/var/mail</filename>，
	但是这需要更多的复杂命令来执行。</para>

      <procedure>
	<step>
	  <title>添加新的硬盘</title>

	  <para>添加新的硬盘到系统中可以查看在 <xref
	    linkend="disks-adding"> 中的说明。
	    这个例子的目的是说明一个新的硬盘分区已经添加到系统中如：
	    <filename>/dev/ad4s1c</filename>。在例子中
	    <filename>/dev/ad0s1<replaceable>*</replaceable></filename>
	    设备代表系统中存在的标准 FreeBSD 分区。</para>

	  <screen>&prompt.root; <userinput>ls /dev/ad*</userinput>
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4</screen>
	</step>

	<step>
	  <title>创建一个目录来保存 gbde Lock 文件</title>

	  <screen>&prompt.root; <userinput>mkdir /etc/gbde</userinput></screen>

	  <para><application>gbde</application> lock 文件包含了
	    <application>gbde</application> 需要访问的加密分区的信息。
	    没有 lock 文件，
	    <application>gbde</application> 将不能解密包含在加密分区上的数据。
	    每个加密分区使用一个独立的 lock 文件。</para>
	</step>

	<step>
	  <title>初始化 gbde 分区</title>

	  <para>一个 <application>gbde</application> 分区在使用前必须被初始化，
	    这个初始化过程只需要执行一次：</para>

	  <screen>&prompt.root; <userinput>gbde init /dev/ad4s1c -i -L /etc/gbde/ad4s1c</userinput></screen>

	  <para>&man.gbde.8; 将打开您的编辑器，
	    提示您去设置在一个模板文件中的配置变量。
	    使用 UFS1 或 UFS2，设置扇区大小为 2048：</para>

	  <programlisting>$<!-- This is not the space you are looking
for-->FreeBSD: src/sbin/gbde/template.txt,v 1.1 2002/10/20 11:16:13 phk Exp $
#
# Sector size is the smallest unit of data which can be read or written.
# Making it too small decreases performance and decreases available space.
# Making it too large may prevent filesystems from working.  512 is the
# minimum and always safe.  For UFS, use the fragment size
#
sector_size     =       2048
[...]
</programlisting>

	  <para>&man.gbde.8; 将让您输入两次用来加密数据的密钥短语。
	    两次输入的密钥必须相同。
	    <application>gbde</application>
	    保护您数据的能力依靠您选择输入的密钥的质量。
	  <footnote>
          <para>这个提示教您怎样选择一个安全易记的密钥短语，
	    请看 <ulink
	    url="http://world.std.com/~reinhold/diceware.html">Diceware
	    Passphrase</ulink> 网站。</para></footnote></para>

	  <para><command>gbde init</command> 命令为您的
	    <application>gbde</application> 分区创建了一个 lock 文件，
	    在这个例子中存储在
	    <filename>/etc/gbde/ad4s1c</filename>中。</para>

	  <caution>
	    <para><application>gbde</application> lock
	      文件<emphasis>必须</emphasis>和加密分区上的内容一块备份。
	      当一个 lock 文件被独自删除时，
	      不能确定一个
	      <application>gbde</application> 分区上的数据被解密过。
	      没有 lock 文件，
	      就是合法的磁盘所有者不经过大量细致的工作也将不能访问经过加密分区上的数据，
	      这是 &man.gbde.8; 在设计时整体上不支持。</para>
	  </caution>
	</step>

	<step>
	  <title>把加密分区和内核进行关联</title>

	  <screen>&prompt.root; <userinput>gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c</userinput></screen>

	  <para>在加密分区的初始化过程中您将被要求提供一个密码短语。
	    新的加密设备将在
	    <filename>/dev</filename> 中显示为
	    <filename>/dev/device_name.bde</filename>：</para>

	  <screen>&prompt.root; <userinput>ls /dev/ad*</userinput>
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4        /dev/ad4s1c.bde</screen>
	</step>

	<step>
	  <title>在加密设备上创建文件系统</title>

	  <para>当加密设备和内核进行关联后，
	    您就可以使用 &man.newfs.8; 在此设备上创建文件系统，
	    使用 &man.newfs.8; 来初始化一个 UFS2
	    文件系统比初始化一个 UFS1 文件系统还要快，摧荐使用
	    <option>-O2</option> 选项。</para>

	  <note><para><option>-O2</option> 选项在 &os;&nbsp;5.1-RELEASE
	  或更新的版本中是默认的选项。</para></note>

	  <screen>&prompt.root; <userinput>newfs -U -O2 /dev/ad4s1c.bde</userinput></screen>

	  <note>
	    <para>&man.newfs.8; 命令必须在一个
	      <application>gbde</application> 分区上执行，
	      这个分区通过一个存在的
	      <filename><replaceable>*</replaceable>.bde</filename>
	      设备名进行标识。</para>
	  </note>
	</step>

	<step>
	  <title>挂接加密分区</title>

	  <para>为加密文件系统创建一个挂接点。</para>

	  <screen>&prompt.root; <userinput>mkdir /private</userinput></screen>

	  <para>挂接加密文件系统。</para>

	  <screen>&prompt.root; <userinput>mount /dev/ad4s1c.bde /private</userinput></screen>
	</step>

	<step>
	  <title>校验加密文件系统是否有效</title>

	  <para>加密的文件系统现在对于
	    &man.df.1; 应该可见并可以使用。</para>

	  <screen>&prompt.user; <userinput>df -H</userinput>
Filesystem        Size   Used  Avail Capacity  Mounted on
/dev/ad0s1a      1037M    72M   883M     8%    /
/devfs            1.0K   1.0K     0B   100%    /dev
/dev/ad0s1f       8.1G    55K   7.5G     0%    /home
/dev/ad0s1e      1037M   1.1M   953M     0%    /tmp
/dev/ad0s1d       6.1G   1.9G   3.7G    35%    /usr
/dev/ad4s1c.bde   150G   4.1K   138G     0%    /private</screen>
	</step>
      </procedure>
    </sect2>

    <sect2>
      <title>挂接已经存在的加密文件系统</title>

      <para>每次系统启动后，
	在使用加密文件系统前必须和内核重新进行关联，
	校验错误和再次挂接。使用的命令必须由
	<username>root</username>用户来执行。</para>

      <procedure>
	<step>
	  <title>关联 gbde 分区到内核</title>

	  <screen>&prompt.root; <userinput>gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c</userinput></screen>

	  <para>您将被要求提供您在初始化加密
	    gbde 分区的过程中选定的密码短语。</para>
	</step>

	<step>
	  <title>校验文件系统错误</title>

	  <para>加密文件系统不能列在
	    <filename>/etc/fstab</filename> 文件中进行自动加载，
	    在加载前必须手动运行 &man.fsck.8;
	    命令对文件系统进行错误检测。</para>

	  <screen>&prompt.root; <userinput>fsck -p -t ffs /dev/ad4s1c.bde</userinput></screen>
	</step>

	<step>
	  <title>挂接加密文件系统</title>

	  <screen>&prompt.root; <userinput>mount /dev/ad4s1c.bde /private</userinput></screen>

	  <para>加密后的文件系统现在可以有效使用。</para>
	</step>
      </procedure>

      <sect3>
	<title>自动挂接加密文件系统</title>

	<para>可以创建一个脚本来自动进行关联、检测、和挂接一个加密分区，
	  但是为了安全起见，脚本程序中不应该包含 &man.gbde.8; 密码。
	  取而代之，摧荐这样的脚本要手工来运行，
	  在要求提供密码时可以通过控制台或 &man.ssh.1;。</para>
      </sect3>
    </sect2>

      <sect2>
	<title>用 gbde 进行加密保护</title>

	<para>&man.gbde.8; 在 CBC 模式上使用 128-bit AES 对扇区进行加密，
	  每个扇区在硬盘上的加密都使用不同的 AES 密钥。
	  想了解更多的信息关于 <application>gbde</application>
	  的设计，包括每个扇区的密钥是怎样从用户提供的密钥短语产生的，
	  请看 &man.gbde.4;。</para>
      </sect2>

      <sect2>
	<title>兼容性问题</title>

	<para>&man.sysinstall.8; 是和
	  <application>gbde</application> 加密设备不兼容的。
	  在启动 &man.sysinstall.8; 时必须将
	  <devicename><replaceable>*</replaceable>.bde</devicename>
	  设备和内核进行分离，否则在初始化探测设备时将引起冲突。
	  与加密设备进行分离在我们的例子中使用如下的命令：</para>
	<screen>&prompt.root; <userinput>gbde detach /dev/ad4s1c</userinput></screen>

      <para>也应该注意，作为 &man.vinum.4; 不能使用 &man.geom.4; 子系统，
	您不能同时使用
	<application>gbde</application> 和
	<application>vinum</application> 卷。</para>
      </sect2>

  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
