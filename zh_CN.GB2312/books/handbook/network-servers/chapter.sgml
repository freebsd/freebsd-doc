<!--
     The FreeBSD Documentation Project
     The FreeBSD Simplified Chinese Project

     Original Revision: 1.69
     $FreeBSD$
-->

<chapter id="network-servers">
  <chapterinfo>
    <authorgroup>
      <author>
        <firstname>Murray</firstname>
	<surname>Stokely</surname>
	<contrib>Reorganized by </contrib>
      </author>
    </authorgroup>
    <!-- 23 July 2004 -->
  </chapterinfo>

  <title>网络服务器</title>

  <sect1 id="network-servers-synopsis">
    <title>概要</title>

    <para>本章将覆盖某些在 &unix; 系统上常用的网络服务。话题将会涉及
      如何安装、配置、测试和维护多种不同类型的网络服务。本章节中将提
      供大量配置文件的样例，期望能够对您有所裨益。</para>

    <para>在读完本章之后，您将会知道：</para>

    <itemizedlist>

      <listitem>
	<para>如何管理 <application>inetd</application>。</para>
      </listitem>

      <listitem>
	<para>如何设置运行一个网络文件系统。</para>
      </listitem>

      <listitem>
	<para>如何配置一个网络信息服务器以共享用户帐号。</para>
      </listitem>

      <listitem>
	<para>如何通过DHCP自动配置网络。</para>
      </listitem>

      <listitem>
	<para>如何配置一个域名服务器。</para>
      </listitem>

      <listitem>
	<para>如何设置<application>Apache</application> HTTP 服务器。</para>
      </listitem>

      <listitem>
	<para>如何设置文件传输（FTP）服务器。</para>
      </listitem>

      <listitem>
	<para>如何使用<application>Samba</application>为 &windows; 
		客户端设置文件和打印服务。</para>
      </listitem>

      <listitem>
	<para>如何同步时间和日期，以及如何设置使用NTP协议的时间服务器。</para>
      </listitem>

    </itemizedlist>

    <para>在阅读此章节之前，您应当：</para>

    <itemizedlist>
      <listitem>
	<para>理解有关<filename>/etc/rc</filename>中脚本的基本知识。</para>
      </listitem>

      <listitem>
	<para>熟悉基本网络术语。</para>
      </listitem>

      <listitem>
      <para>懂得如何安装额外的第三方软件（<xref linkend="ports">）。</para>
      </listitem>

    </itemizedlist>
  </sect1>

  <sect1 id="network-inetd">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Chern</firstname>
          <surname>Lee</surname>
          <contrib>Contributed by </contrib>
        </author>
      </authorgroup>
    </sect1info>

    <title> <application>inetd</application> <quote>超级服务器</quote></title>

    <sect2 id="network-inetd-overview">
      <title>总览</title>

      <para>&man.inetd.8; 被叫做 <quote>超级 Internet
	服务器</quote>， 因为它能够管理许多不同的服务程序的连接。
	当 <application>inetd</application> 接到连入的连接时，
	它就会判断连接所需要启动的服务程序， 并运行它们，
	然后将连接转交给这些服务程序 (在启动程序时，
	这些程序的标准输入、输出和错误输出描述符被替换为连入的连接)。
	与一个一个地运行单独的服务程序相比，
	只启动一个 <application>inetd</application> 能够削减平均的系统负荷。</para>

      <para>一般说来， <application>inetd</application>
	会被用来启动其他服务程序。 但一些非常简单的协议，
	例如 <application>chargen</application>、
	<application>auth</application>， 以及
	<application>daytime</application>，
	则会由它自行处理。</para>

      <para>这一节将介绍如何通过命令行选项， 以及配置文件
	<filename>/etc/inetd.conf</filename> 来配置
	<application>inetd</application> 的一些基本知识。</para>
    </sect2>

    <sect2 id="network-inetd-settings">
      <title>设置</title>

      <para><application>inetd</application> 通过 <filename>/etc/rc.conf</filename>
  系统进行初始化。<literal>inetd_enable</literal> 选项默认被设定为
	<literal>NO</literal>，不过可以通过<application>sysinstall</application>打开，
	如果选用中等安全的模板。在<filename>/etc/rc.conf</filename>中设定:
	<programlisting>inetd_enable="YES"</programlisting> 或
	<programlisting>inetd_enable="NO"</programlisting> 
	可以激活或者禁止<application>inetd</application>在启动时加载。</para>

      <para>此外，可以通过<literal>inetd_flags</literal>把不同的
  命令行参数传给<application>inetd</application>。</para>
  </sect2>

    <sect2 id="network-inetd-cmdline">
      <title>命令行选项</title>

      <para><application>inetd</application> 语法:</para>

      <para><option>     inetd [-d] [-l] [-w] [-W] [-c maximum] [-C rate] [-a address | hostname]
           [-p filename] [-R rate] [configuration file]</option></para>

      <variablelist>
	<varlistentry>
	  <term>-d</term>

	  <listitem>
	    <para>打开调试选项。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-l</term>

	  <listitem>
	    <para>记录成功的连接</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-w</term>

	  <listitem>
	    <para>为外部服务打开TCP Wrapping（默认）。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-W</term>

	  <listitem>
	    <para>为<application>inetd</application>的内置服务打开TCP Wrapping （默认）。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-c maximum</term>

	  <listitem>
	    <para>指定单个服务的最大并发访问数量，默认为不限。
	      也可以在此服务的具体配置里面通过<option>max-child</option>改掉。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-C rate</term>

	  <listitem>
	    <para>指定单个服务一分钟内能被单个IP地址调用的最大次数，
	      默认不限。也可以在此服务的具体配置里面通过<option>max-connections-per-ip-per-minute</option>
	      改掉。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-R rate</term>

	  <listitem>
	    <para>指定单个服务一分钟内能被调用的最大次数，默认为256。
	      设为0 则允许不限次数调用。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-a</term>

	  <listitem>
	    <para>指定绑定的IP地址。此外，可以使用主机名，这样系统就
	      可以根据主机名对应的IPV4或者IPV6来选择绑定地址。通常当
	      <application>inetd</application> 在 &man.jail.8; 中运行
	      的时候指定主机名，这种情况下主机名来自 &man.jail.8; 环
	      境变量</para>

	    <para>当使用主机名方式时，如果IPV4和IPV6都会被绑定到服务，
	      那么，需要在<filename>/etc/inetd.conf</filename>.中为该服务
	      的每个对应协议添加一条记录。比如，一个TCP服务需要两条记录，
	      一条使用<literal>tcp4</literal>，另一条使用<literal>tcp6</literal>。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>-p</term>

	  <listitem>
	    <para>指定用来存放进程ID的文件。</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>以上选项在<filename>/etc/rc.conf</filename>中将可以
      被<literal>inetd_flags</literal>开关传递给<application>inetd</application>。
	 		默认情况下，<literal>inetd_flags</literal> 被置为
			<literal>-wW</literal>，也既是对<application>inetd</application>的内置或外部服务打开TCP wrapping.
			对于新手，通常不用去动这些参数，就算它们出现在<filename>/etc/rc.conf</filename>里头。</para>

      <note>
	<para>对<application>inetd</application>而言，所谓外部服务是当
		连接请求到来时，被调用并接受连接，启动于inetd之外的守护进程。
		反之，内置服务则是那些<application>inetd</application>自己可
		以完全处理的了。</para>
      </note>

    </sect2>

    <sect2 id="network-inetd-conf">
      <title><filename>inetd.conf</filename></title>

      <para><application>inetd</application>的配置通过
      <filename>/etc/inetd.conf</filename>文件进行控制。</para>

      <para>当
	<filename>/etc/inetd.conf</filename>内容发生改变，可以
	对<application>inetd</application>进程发送一个HangUP信号，以强制
	<application>inetd</application>重新读取配置文件，如下所示：</para>

      <example id="network-inetd-hangup">
	<title>对 <application>inetd</application>发送HangUP信号</title>

	<screen>&prompt.root; <userinput>kill -HUP `cat /var/run/inetd.pid`</userinput></screen>
      </example>

      <para>配置文件中的每一行都是一个独立服务。如果要注释掉该服务，可以在行首加上
	<quote>#</quote>。<filename>/etc/inetd.conf</filename>的格式如下：</para>

      <programlisting>service-name
socket-type
protocol
{wait|nowait}[/max-child[/max-connections-per-ip-per-minute]]
user[:group][/login-class]
server-program
server-program-arguments</programlisting>

      <para><application>ftpd</application>使用IPv4的例子：</para>

      <programlisting>ftp     stream  tcp     nowait  root    /usr/libexec/ftpd       ftpd -l</programlisting>

      <variablelist>
	<varlistentry>
	  <term>service-name</term>

	  <listitem>
	    <para>指明各个服务的服务名。其服务名必须与<filename>/etc/services</filename>中列出的一致。
	      这将决定<application>inetd</application>会监听哪个port。
	      一旦有新的服务需要添加，必须先在<filename>/etc/services</filename>里面添加。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>socket-type</term>

	  <listitem>
	    <para>可以是<literal>stream</literal>、<literal>dgram</literal>、<literal>raw</literal>或者
	      <literal>seqpacket</literal>。 <literal>stream</literal>
	      用在基于连接的，TCP 服务；而<literal>dgram</literal>被用于服务用于<acronym>UDP</acronym>传输协议。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>protocol</term>

	  <listitem>
	    <para>下列之一：</para>

	    <informaltable frame="none" pgwide="1">
	      <tgroup cols="2">
		<thead>
		  <row>
		    <entry>协议</entry>
		    <entry>说明</entry>
		  </row>
		</thead>
		<tbody>
		  <row>
		    <entry>tcp， tcp4</entry>
		    <entry>TCP IPv4</entry>
		  </row>
		  <row>
		    <entry>udp， udp4</entry>
		    <entry>UDP IPv4</entry>
		  </row>
		  <row>
		    <entry>tcp6</entry>
		    <entry>TCP IPv6</entry>
		  </row>
		  <row>
		    <entry>udp6</entry>
		    <entry>UDP IPv6</entry>
		  </row>
		  <row>
		    <entry>tcp46</entry>
		    <entry>Both TCP IPv4 and v6</entry>
		  </row>
		  <row>
		    <entry>udp46</entry>
		    <entry>Both UDP IPv4 and v6</entry>
		  </row>
		</tbody>
	      </tgroup>
	    </informaltable>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>{wait|nowait}[/max-child[/max-connections-per-ip-per-minute]]</term>

	  <listitem>
	    <para><option>wait|nowait</option> 指明从<application>inetd</application>
	    	里头调用的服务是否可以自己处理socket.
	      <option>dgram</option>socket类型必须使用<option>wait</option>，
	      而stream socket daemons， 由于通常使用多线程方式，应当使用
	      <option>nowait</option>.  <option>wait</option> 通常usually
	      把多个socket丢给单个服务进程， 而<option>nowait</option> 则
	      会为每个新的socket生成一个子进程。</para>

	    <para>使用<option>max-child</option>选项可以设定针对服务，
	      <application>inetd</application>可以派生出来的最大子进程数量。
	      如果某特定服务需要限定最高10个实例，把<literal>/10</literal>
	      放到<option>nowait</option>后头就可以了。</para>

	    <para>在<option>max-child</option>之外，还有一个开关可以限制
	      来自同一个地方，针对某个服务的最大连接数。这个开关就是：
	      <option>max-connections-per-ip-per-minute</option>。
	      比如，设定该值为10就可以限定单个IP地址去向某服务的连接最大
	      为每分钟十个。这个对于防止有意或者无意的资源耗尽或者拒绝服
	      务（DoS）颇有用处。</para>

	    <para>在这部分，必须选择<option>wait</option>或
	      <option>nowait</option>。
	      <option>max-child</option>和
	      <option>max-connections-per-ip-per-minute</option> 则为可有可无。</para>

	    <para>一个stream-type多线程的服务，如果没有
	      <option>max-child</option>或者
	      <option>max-connections-per-ip-per-minute</option>需要，
	      一般使用: <literal>nowait</literal>。</para>

	    <para>同样的服务，如果需要限制最大连接数，则如下：
	    <literal>nowait/10</literal>。</para>

	    <para>此外，如果要限制每分钟单个IP来访连接为20个，同时最多
	    派生10个进程，可以如下：
	      <literal>nowait/10/20</literal>。</para>

	    <para>以上开关都默认被使用在<application>fingerd</application>服务上面，
	      如下所示：</para>

	    <programlisting>finger stream  tcp     nowait/3/10 nobody /usr/libexec/fingerd fingerd -s</programlisting>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>user</term>

	  <listitem>
	    <para>该开关指定服务将以什么用户身份运行。一般而言，服务运行身份是
	      <username>root</username>。基于安全目的，可以看到有些服务以
	      <username>daemon</username>身份，或者是最小特权的
	      <username>nobody</username>身份运行。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>server-program</term>

	  <listitem>
	    <para>当连接到来时，执行服务程序的全路径。如果服务是由
	    <application>inetd</application>内置提供的，以<option>internal</option>代替。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>server-program-arguments</term>

	  <listitem>
	    <para>当<option>server-program</option>调用到时，该开关
	    的值通过<literal>argv[0]</literal>通过传递给服务而工作。
	    如果命令行为：<command>mydaemon -d</command>，则
	      <literal>mydaemon -d</literal>为<option>server-program-arguments</option>
	      开关的值。同样的，如果服务是由<application>inetd</application>
	      内置提供的，这里还是
	      <option>internal</option>。</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 id="network-inetd-security">
      <title>Security</title>

      <para>随安装时候选择的安全模式不同，部分<application>inetd</application>的服务
      会被设为默认打开。如果没有确实的需要，禁止它们！只要在<filename>/etc/inetd.conf</filename>里头
      需要禁止的服务前头加上<quote>#</quote>，然后<link linkend="network-inetd-hangup">
      对inetd发送hangup信号</link>。某些服务，比如<application>fingerd</application>，
      由于对攻击者提供太多信息，可能对任何人都应该禁止。</para>

      <para>某些服务在安全上没有考虑，并且有一些连接超时检测设得很长或没有检测机制。
      这回允许攻击者慢慢地发送连接，这样可以导致可用资源的消耗。在某些服务上面加上
      <option>max-connections-per-ip-per-minute</option>和<option>max-child</option>
      的限制似乎不错。</para>

      <para>默认情况下，TCP wrapping 是打开的。参考
	&man.hosts.access.5; 手册，以获得更多关于在各种<application>inetd</application>
	调用的服务上设置TCP限制的信息。</para>
    </sect2>

    <sect2 id="network-inetd-misc">
      <title>杂项</title>

      <para><application>daytime</application>，
	<application>time</application>，
	<application>echo</application>，
	<application>discard</application>，
	<application>chargen</application>， 和
	<application>auth</application> 都是<application>inetd</application>内置的服务。</para>

      <para><application>auth</application>服务提供
	identity （<application>ident</application>，
	<application>identd</application>）网络服务，并且某种程度上可配置。</para>

      <para>参考 &man.inetd.8; 手册获得更多信息。</para>
    </sect2>
  </sect1>

  <sect1 id="network-nfs">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Tom</firstname>
          <surname>Rhodes</surname>
          <contrib>Reorganized and enhanced by </contrib>
        </author>
      </authorgroup>
      <authorgroup>
        <author>
          <firstname>Bill</firstname>
      	  <surname>Swingle</surname>
	  <contrib>Written by </contrib>
        </author>
      </authorgroup>
    </sect1info>
    <title>网络文件系统（NFS）</title>

    <indexterm><primary>NFS</primary></indexterm>
    <para>网络文件系统是FreeBSD支持的文件系统中的一种，也被称为<acronym role="Network
      File System">NFS</acronym>.  <acronym role="Network File
      System">NFS</acronym>允许一个系统在网络上与它人共享目录和文件。通过使用<acronym
      role="Network File System">NFS</acronym>，用户和程序可以象访问本地文件
      一样访问远端系统上的文件。</para>

    <para>以下是<acronym>NFS</acronym>最显而易见的好处：</para>

    <itemizedlist>
      <listitem>
	<para>本地工作站使用更少的磁盘空间，因为通常的数据可以存放在一
	台机器上而且可以通过网络访问到。</para>
      </listitem>

      <listitem>
	<para>用户不必在每个网络上机器里头都有一个home目录。Home目录
	  可以被放在<acronym>NFS</acronym>服务器上并且在网络上处处可用。
	  </para>
      </listitem>

      <listitem>
	<para>诸如软驱，CDROM，和 &iomegazip; 之类的存储设备可以在网络上面被别的机器使用。
	  这可以减少整个网络上的可移动介质设备的数量。</para>
      </listitem>
    </itemizedlist>

    <sect2>
      <title><acronym>NFS</acronym>是如何工作的</title>

      <para><acronym>NFS</acronym> 至少包括两个主要的部分： 一台服务器，
        以及至少一台客户机， 客户机远程地访问保存在服务器上的数据。
        要让这一切运转起来， 需要配置并运行几个程序。</para>

      <note><para>在 &os;&nbsp;4.X 中， <application>portmap</application>
	工具将发挥后续版本中
	<application>rpcbind</application> 工具的作用。 因此，
	在 &os;&nbsp;4.X 中， 您可能需要把后续例子中的
	<application>rpcbind</application> 改成
	<application>portmap</application> 以便使用。</para></note>

      <para>服务器必须运行以下服务：</para>
      <indexterm>
        <primary>NFS</primary>
        <secondary>server</secondary>
      </indexterm>
      <indexterm>
        <primary>文件服务器</primary>
        <secondary>UNIX 客户机</secondary>
      </indexterm>

      <indexterm>
	<primary><application>rpcbind</application></primary>
      </indexterm>
      <indexterm>
        <primary><application>portmap</application></primary>
      </indexterm>
      <indexterm>
        <primary><application>mountd</application></primary>
      </indexterm>
      <indexterm>
        <primary><application>nfsd</application></primary>
      </indexterm>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <colspec colwidth="1*">
	  <colspec colwidth="3*">

	  <thead>
	    <row>
	      <entry>服务</entry>
	      <entry>描述</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry><application>nfsd</application></entry>
	      <entry><acronym>NFS</acronym>，为来自<acronym>NFS</acronym>客户端的
	      请求服务。</entry>
	    </row>
	    <row>
	      <entry><application>mountd</application></entry>
	      <entry><acronym>NFS</acronym>挂载服务，处理&man.nfsd.8;递交过来的请求。</entry>
	    </row>
	    <row>
	      <entry><application>rpcbind</application></entry>
	      <entry> 此服务允许
	      <acronym>NFS</acronym> 客户程序查询正在被 <acronym>NFS</acronym> 服务使用的端口。</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>客户端同样运行一些进程，比如
        <application>nfsiod</application>。
        <application>nfsiod</application>处理来自<acronym>NFS</acronym>的请求。
        这是可选的，而且可以提高性能，对于普通和正确的操作来说并不是必须的。
        参考&man.nfsiod.8;手册获得更多信息。
      </para>
    </sect2>

    <sect2 id="network-configuring-nfs">
      <title>配置<acronym>NFS</acronym></title>
      <indexterm>
        <primary>NFS</primary>
        <secondary>configuration</secondary>
      </indexterm>

      <para><acronym>NFS</acronym>的配置过程相对简单。这个过程只需要
      对<filename>/etc/rc.conf</filename>文件作一些简单修改。</para>

      <para>在<acronym>NFS</acronym>服务器这端，确认<filename>/etc/rc.conf</filename>
      文件里头以下开关都配上了:</para>

      <programlisting>rpcbind_enable="YES"
nfs_server_enable="YES"
mountd_flags="-r"</programlisting>

      <para>只要<acronym>NFS</acronym>服务被置为enable，<application>mountd</application>
      就能自动运行。</para>

      <para>在客户端一侧，确认下面这个开关出现在
        <filename>/etc/rc.conf</filename>里头:</para>

      <programlisting>nfs_client_enable="YES"</programlisting>

      <para><filename>/etc/exports</filename>文件指定了哪个文件系统
      <acronym>NFS</acronym>应该输出（有时被称为<quote>共享</quote>）。
      <filename>/etc/exports</filename>里面每行指定一个输出的文件系统和
      哪些机器可以访问该文件系统。在指定机器访问权限的同时，访问选项
      开关也可以被指定。有很多开关可以被用在这个文件里头，不过不会在这
      里详细谈。您可以通过阅读&man.exports.5; 手册来发现这些开关。</para>

      <para>以下是一些<filename>/etc/exports</filename>的例子：</para>

      <indexterm>
        <primary>NFS</primary>
        <secondary>export examples</secondary>
      </indexterm>

      <para>紧接着的这个例子说明了如何输出一个文件系统，尽管具体设定和您
      的环境以及网络配置有关。作为实例，为了输出<filename>/cdrom</filename>
      到三个的例子机器，它们有同样域名（因此他们的域名不大对）或者在您的
      <filename>/etc/hosts</filename>文件里头有记录。<option>-ro</option>
      标志将被输出的文件系统置为只读。由于这个标志，远程系统将无法在被输出
      的文件系统上写入任何变动。</para>

      <programlisting>/cdrom -ro host1 host2 host3</programlisting>

      <para>下面的例子可以输出<filename>/home</filename>给三个以IP地址方式表示的主机。
	对于在没有配置<acronym>DNS</acronym>服务器的私有网络里头，这很有用。
	此外，the <filename>/etc/hosts</filename> 文件也可以用以配置主机名；参看 &man.hosts.5; 。
	<option>-alldirs</option> 标记允许子目录被作为挂载点。
	也就是说，客户端可以根据需要挂载需要的目录。 </para>

      <programlisting>/home  -alldirs  10.0.0.2 10.0.0.3 10.0.0.4</programlisting>

      <para>下面几行输出 <filename>/a</filename> ，以便两个来自不同域的客户端可以访问文件系统。
	<option>-maproot=root</option> 标记授权远端系统上的
	<username>root</username> 用户在被输出的文件系统上以<username>root</username>身份进行读写。
	如果没有特别指定 <literal>-maproot=root</literal> 标记，
	则即使用户在远端系统上是 <username>root</username> 身份，
	也不能修改被输出文件系统上的文件。 </para>

      <programlisting>/a  -maproot=root  host.example.com box.example.org</programlisting>

      <para> 为了能够访问到被输出的文件系统，客户端必须被授权。
      请确认客户端在您的 <filename>/etc/exports</filename> 被列出。 </para>

      <para>在 <filename>/etc/exports</filename> 里头，每一行里面，输出信息和文件系统一一对应。
  一个远程主机每次只能对应一个文件系统。而且只能有一个默认入口。比如，假设
	<filename>/usr</filename> 是独立的文件系统。这个 <filename>/etc/exports</filename> 就是无效的：</para>

      <programlisting># Invalid when /usr is one file system
/usr/src   client
/usr/ports client</programlisting>

      <para>一个文件系统，<filename>/usr</filename>， 有两行指定输出到同一主机，
   <hostid>client</hostid>.
       解决这一问题的正确的格式是：</para>

      <programlisting>/usr/src /usr/ports  client</programlisting>

      <para>The properties of one filesystem exported to a given host
	must all occur on one line.  Lines without a client specified
	are treated as a single host.  This limits how you can export
	filesystems, but for most people this is not an issue.</para>

      <para>下面是一个有效输出列表的例子，
	<filename>/usr</filename> and <filename>/exports</filename>
	是本地文件系统：</para>

      <programlisting># Export src and ports to client01 and client02, but only
# client01 has root privileges on it
/usr/src /usr/ports -maproot=root    client01
/usr/src /usr/ports               client02
# The client machines have root and can mount anywhere
# on /exports. Anyone in the world can mount /exports/obj read-only
/exports -alldirs -maproot=root      client01 client02
/exports/obj -ro</programlisting>

      <para>一旦修改 <filename>/etc/exports</filename> 了之后，
      为了让变动生效，您必须重启 <application>mountd</application>。
      可以通过对<command>mountd</command> 进程发送HUP信号重启：</para>

      <screen>&prompt.root; <userinput>kill -HUP `cat /var/run/mountd.pid`</userinput></screen>

      <para>另外，系统重启动可以让FreeBSD把一切都弄好。尽管如此，重启不是必须的。
        以 <username>root</username> 身份执行下面的命令可以搞定一切。</para>

      <para>在 <acronym>NFS</acronym> 服务器端：</para>

      <screen>&prompt.root; <userinput>rpcbind</userinput>
&prompt.root; <userinput>nfsd -u -t -n 4</userinput>
&prompt.root; <userinput>mountd -r</userinput></screen>

      <para>在 <acronym>NFS</acronym> 客户端：</para>

      <screen>&prompt.root; <userinput>nfsiod -n 4</userinput></screen>

      <para>现在每件事情都应该就绪，以备挂载一个远端文件系统。 在这些例子里头，
      服务器名字将是：<hostid>server</hostid> ，而客户端的名字将是： <hostid>client</hostid>。
      如果您只打算临时挂载一个远端文件系统或者只是打算作测试配置正确与否，
      只要在客户端以 <username>root</username> 身份执行下面的命令：</para>
      <indexterm>
        <primary>NFS</primary>
        <secondary>mounting</secondary>
      </indexterm>
      <screen>&prompt.root; <userinput>mount server:/home /mnt</userinput></screen>

      <para>这条命令会把服务端的 <filename>/home</filename> 目录挂载到客户端的 <filename>/mnt</filename> 上。
      如果配置正确，您应该可以进入客户端的 <filename>/mnt</filename> 目录并且看到所有服务端的文件。 </para>

      <para>如果您打算让系统每次在重启动的时候都自动挂载远端的文件系统，把那个文件系统加到
	<filename>/etc/fstab</filename> 文件里头去。下面是例子：</para>

      <programlisting>server:/home	/mnt	nfs	rw	0	0</programlisting>

      <para> &man.fstab.5; 手册里有所有可用的开关。</para>
    </sect2>

    <sect2>
      <title>实际应用</title>

      <para><acronym>NFS</acronym> 有很多实际应用。下面是比较常见的一些：</para>

      <indexterm>
        <primary>NFS</primary>
        <secondary>uses</secondary>
      </indexterm>
      <itemizedlist>
        <listitem>
	  <para>多个机器共享一台CDROM或者其他设备。这对于在多台机器中安装软件来说更加便宜跟方便。
	   </para>
	</listitem>

	<listitem>
	  <para>在大型网络中，配置一台中心 <acronym>NFS</acronym> 服务器用来放置所有用户的home目录可能会带来便利。
	    这些目录能被输出到网络以便用户不管在哪台工作站上登录，总能得到相同的home目录。
	    </para>
	</listitem>

	<listitem>
	  <para>几台机器可以有通用的<filename>/usr/ports/distfiles</filename> 目录。
          这样的话，当您需要在几台机器上安装port时，您可以无需在每台设备上下载而快速访问源码。
           </para>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2 id="network-amd">
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Wylie</firstname>
	    <surname>Stilwell</surname>
	    <contrib>Contributed by </contrib>
	  </author>
	</authorgroup>
	<authorgroup>
	  <author>
	    <firstname>Chern</firstname>
	    <surname>Lee</surname>
	    <contrib>Rewritten by </contrib>
	  </author>
	</authorgroup>
      </sect2info>
      <title>通过 <application>amd</application> 自动地挂接</title>

      <indexterm><primary>amd</primary></indexterm>
      <indexterm><primary>自动挂接服务</primary></indexterm>

      <para>&man.amd.8; (自动挂接服务) 能够自动地在访问时挂接远程的文件系统。
	如果文件系统在一段时间之内没有活动， 则会被
	<application>amd</application> 自动卸下。 通过使用
	<application>amd</application>， 能够提供一个持久挂接以外的选择，
	而后者往往需要列入
        <filename>/etc/fstab</filename>。</para>

      <para><application>amd</application> 通过将自己以 NFS 服务器的形式，
	附加到 <filename>/host</filename> 和
	<filename>/net</filename> 目录上来工作。
	当访问这些目录中的文件时， <application>amd</application>
	将查找相应的远程挂接点， 并自动地挂接。
	<filename>/net</filename> 用于挂接远程 IP 地址上导出的文件系统，
	而 <filename>/host</filename> 则用于挂接远程主机名上的文件系统。</para>

      <para>访问
	<filename>/host/foobar/usr</filename> 中的文件， 相当于告诉
	<application>amd</application> 尝试挂接在主机
	<hostid>foobar</hostid> 上导出的
	<filename>/usr</filename>。</para>

      <example>
	<title>通过 <application>amd</application> 来挂接导出的文件系统</title>

	<para>您可以通过使用 <command>showmount</command>
	  命令来查看远程主机上导出的文件系统。 例如，
	  要查看 <hostid>foobar</hostid> 上导出的文件系统， 可以用：</para>

	<screen>&prompt.user; <userinput>showmount -e foobar</userinput>
Exports list on foobar:
/usr                               10.10.10.0
/a                                 10.10.10.0
&prompt.user; <userinput>cd /host/foobar/usr</userinput></screen>
      </example>

      <para>如同在前面例子中所看到的， <command>showmount</command> 显示了导出的
	<filename>/usr</filename>。 当进入
	<filename>/host/foobar/usr</filename> 这个目录时， <application>amd</application>
	将尝试解析主机名 <hostid>foobar</hostid>
	并自动地挂接需要的文件系统导出。</para>

      <para><application>amd</application> 可以通过启动脚本来启动， 方法是在
	<filename>/etc/rc.conf</filename> 中加入：</para>

      <programlisting>amd_enable="YES"</programlisting>

      <para>除此之外， 还可以给
      <application>amd</application> 通过
      <varname>amd_flags</varname> 选项来传递额外的参数。 默认情况下，
      <varname>amd_flags</varname> 为：</para>

      <programlisting>amd_flags="-a /.amd_mnt -l syslog /host /etc/amd.map /net /etc/amd.map"</programlisting>

      <para><filename>/etc/amd.map</filename>
	文件定义了挂接导出文件系统时所使用的默认选项。
	<filename>/etc/amd.conf</filename> 文件， 则定义了更多关于
	<application>amd</application> 的高级功能选项。</para>

      <para>请参考 &man.amd.8; 和 &man.amd.conf.5; 联机手册，
	以了解进一步的情况。</para>
    </sect2>

    <sect2 id="network-nfs-integration">
      <sect2info>
        <authorgroup>
          <author>
            <firstname>John</firstname>
            <surname>Lind</surname>
            <contrib>Contributed by </contrib>
          </author>
        </authorgroup>
      </sect2info>
      <title>与其他系统集成时的常见问题</title>

      <para>某些特定的 ISA PC 系统上的以太网适配器上有一些限制，
	这些限制可能会导致严重的网络问题， 特别是与 NFS 配合使用时。
	这些问题并非 FreeBSD 所特有的， 但 FreeBSD 系统会受到这些问题的影响。</para>

      <para>这样的问题， 几乎总是在当 (FreeBSD) PC 系统与高性能的工作站，
	例如 Silicon Graphics, Inc., 和 Sun Microsystems, Inc. 的工作站联网时发生。
	NFS 挂接能够正常工作， 而且一些操作也可能成功，
	但服务器会很快变得对客户机不太理会，
	虽然对其他客户机的请求仍然能够正常处理。
	这种情况通常发生在客户端， 无论它是一个 FreeBSD 系统或是终端。
	在许多系统上， 一旦发生了这样的问题， 通常没办法正常地关闭客户机。
	唯一的办法通常是让终端复位， 因为这一 NFS 状况没有办法被解决。</para>

      <para>尽管 <quote>正确的</quote> 解决办法， 是为
	FreeBSD 系统配备一块高性能的、 适用的以太网适配器，
	然而也有办法绕过问题并得到相对满意的结果。
	如果 FreeBSD 系统是
	<emphasis>服务器</emphasis>， 则在客户机挂接时， 应该指定
	<option>-w=1024</option>。 如果
	FreeBSD 系统是 <emphasis>客户机</emphasis>，
	则应加入 <option>-r=1024</option> 参数。 这些选项可以通过在对应的
	<filename>fstab</filename> 的第四个字段加入，
	以便让客户机能够自动地挂接， 或者通过 &man.mount.8; 的
	<option>-o</option> 参数在手工挂接时指定。</para>

      <para>还需要注意的是另一个问题， 有时会被误认为是和上面一样的问题。
	这个问题多见于 NFS 服务器和客户机在不同的网络上时。 如果是这种情况， 一定要
	<emphasis>确定</emphasis> 您的路由器确实把必需的 <acronym>UDP</acronym>
	信息路由到了目的地， 否则您将什么也做不了。</para>

      <para>下面的例子中， <hostid>fastws</hostid> 是主机
	(接口) 的名字， 它是一台高性能的终端， 而
	<hostid>freebox</hostid> 是另一台主机 (接口) 的名字，
	它是一个使用较低性能的以太网适配器的 FreeBSD 系统。 同时，
	<filename>/sharedfs</filename> 将被导出成为 NFS
	文件系统 (参见 &man.exports.5;)， 而
	<filename>/project</filename>
	将是客户机上挂接这一导出文件系统的挂接点。 所有的应用场景中，
	请注意附加选项， 例如 <option>hard</option> 或
	<option>soft</option> 以及 <option>bg</option> 可能是您的应用所需要的。</para>

      <para>关于 FreeBSD 系统 (<hostid>freebox</hostid>)
	作为客户机的示范 <filename>/etc/fstab</filename> 文件， 见于
	<hostid>freebox</hostid> 之上：</para>

      <programlisting>fastws:/sharedfs /project nfs rw,-r=1024 0 0</programlisting>

      <para>在 <hostid>freebox</hostid> 上手工挂接：</para>

      <screen>&prompt.root; <userinput>mount -t nfs -o -r=1024 fastws:/sharedfs /project</userinput></screen>

      <para>以 FreeBSD 系统作为服务器的例子， 是 <hostid>fastws</hostid> 上的
	<filename>/etc/fstab</filename>：</para>

      <programlisting>freebox:/sharedfs /project nfs rw,-w=1024 0 0</programlisting>

      <para>在 <hostid>fastws</hostid> 上手工挂接的命令是：</para>

      <screen>&prompt.root; <userinput>mount -t nfs -o -w=1024 freebox:/sharedfs /project</userinput></screen>

      <para>几乎所有的 16-位 以太网控制器，
	都能够在没有上述读写尺寸限制的情况下正常工作。</para>

      <para>对于那些关心到底是什么问题的人， 下面是失败如何发生的解释，
	同时这也说明了为什么这是一个无法恢复的问题。 典型情况下，
	NFS 会使用一个 <quote>块</quote> 为单位进行操作， 其尺寸是
	8&nbsp;K (虽然它可能会将操作分成更小尺寸的分片)。
	由于最大的以太网包尺寸大约是 1500&nbsp;字节，
	因此 NFS <quote>块</quote> 会分成多个以太网包，
	虽然在更高层的代码看来它仍然是一个完整的单元，
	并在接收方重新组装， 作为一个整体来
	<emphasis>确认</emphasis>。 高性能的工作站，
	可以将构成 NFS 单元的包迅速发出， 其节奏会快到标准允许的最大限度。
	在容量较小的卡上， 后来的包会冲掉同一单元内的较早的包，
	因而整个单元无法被重建或确认。 其结果是，
	工作站将超时并重试， 但仍然是完整的 8&nbsp;K 单元，
	这一过程将无休止地重复下去。</para>

      <para>如果将单元尺寸限制在以太网包尺寸之下，
	我们就能够确保每一个以太网包都能够被独立地接收和确认，
	从而避免了上面的死锁情形。</para>

      <para>溢出在高性能工作站将数据库投向 PC 系统时仍会发生，
	但在更好的网卡上， 能够保证这类溢出不会在每一个 NFS
	<quote>单元</quote> 上都发生。 当出现溢出时，
	被影响的单元被重传， 因而此时有很大的机会它将被正确接收、
	重组， 并确认。</para>
    </sect2>
  </sect1>

  <sect1 id="network-nis">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Bill</firstname>
      	  <surname>Swingle</surname>
	  <contrib>Written by </contrib>
         </author>
      </authorgroup>
      <authorgroup>
	<author>
	  <firstname>Eric</firstname>
	  <surname>Ogren</surname>
	  <contrib>Enhanced by </contrib>
	</author>
	<author>
	  <firstname>Udo</firstname>
	  <surname>Erdelhoff</surname>
	</author>
      </authorgroup>
    </sect1info>
    <title>网络信息服务 (NIS/YP)</title>

    <sect2>
      <title>它是什么？</title>
      <indexterm><primary>NIS</primary></indexterm>
      <indexterm><primary>Solaris</primary></indexterm>
      <indexterm><primary>HP-UX</primary></indexterm>
      <indexterm><primary>AIX</primary></indexterm>
      <indexterm><primary>Linux</primary></indexterm>
      <indexterm><primary>NetBSD</primary></indexterm>
      <indexterm><primary>OpenBSD</primary></indexterm>

      <para><acronym role="Network Information System">NIS</acronym>，
        表示网络信息服务 (Network Information Services)，
        最初由 Sun Microsystems 开发， 用于 &unix;
        (最初是 &sunos;) 系统的集中管理。 目前，
        它基本上已经成为了业界标准； 所有主流的类 &unix; 系统
        (&solaris;, HP-UX, &aix;, Linux, NetBSD, OpenBSD, FreeBSD,
        等等) 都支持 <acronym role="Network Information
        System">NIS</acronym>。</para>

      <indexterm><primary>黄页 (yellow pages)</primary><see>NIS</see></indexterm>

      <para><acronym role="Network Information System">NIS</acronym>
	也就是人们所熟知的黄页(Yellow Pages)， 但由于商标的问题，
	Sun 将其改名为现在的名字。 旧的术语 (以及 yp)，
	仍然经常可以看到， 并被广泛使用。</para>

      <indexterm>
        <primary>NIS</primary>
        <secondary>域</secondary>
      </indexterm>

      <para>这是一个基于 RPC 的客户机/服务器系统，
	它允许在一个 NIS 域中的一组机器共享一系列配置文件。
	这样， 系统管理员就可以配置只包含最基本配置数据的 NIS 客户机系统，
	并在单点上增加、 删除或修改配置数据。</para>

      <indexterm><primary>Windows NT</primary></indexterm>

      <para>尽管实现的内部细节截然不同， 这和 &windowsnt; 域系统非常类似，
        以至于可以将两者的基本功能相互类比。</para>
    </sect2>

    <sect2>
      <title>您应该知道的术语和进程</title>

      <para>有一系列术语和重要的用户进程将在您在 FreeBSD
        上实现 NIS 时用到， 无论是在创建
        NIS 服务器， 或作为 NIS 客户机：</para>

      <indexterm>
	<primary><application>rpcbind</application></primary>
      </indexterm>
      <indexterm>
	<primary><application>portmap</application></primary>
      </indexterm>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	<colspec colwidth="1*">
	<colspec colwidth="3*">

	  <thead>
	    <row>
	      <entry>术语</entry>
	      <entry>说明</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>NIS 域名</entry>

	      <entry>NIS 主服务器和所有其客户机
		(包括从服务器) 会使用同一 NIS 域名。
		和 &windowsnt; 域名类似， NIS 域名与
		<acronym>DNS</acronym> 无关。</entry>
	    </row>
	    <row>
	      <entry><application>rpcbind</application></entry>

	      <entry>必须运行这个程序， 才能够启用
		<acronym>RPC</acronym> (远程过程调用， NIS
		用到的一种网络协议)。 如果没有运行
		<application>rpcbind</application>，
		则没有办法运行 NIS 服务器，
		或作为 NIS 客户机 (对于 &os;&nbsp;4.X，
		<application>portmap</application> 完成
		<application>rpcbind</application> 的功能)。</entry>
	    </row>
	    <row>
	      <entry><application>ypbind</application></entry>

	      <entry><quote>绑定(bind)</quote> NIS 客户机到它的 NIS
		服务器上。 这样， 它将从系统中获取 NIS 域名，
		并使用 <acronym>RPC</acronym> 连接到服务器上。
		<application>ypbind</application> 是 NIS 环境中，
		客户机-服务器通讯的核心； 如果客户机上的
		<application>ypbind</application> 死掉的话， 它将无法访问
		NIS 服务器。</entry>
	    </row>
	    <row>
	      <entry><application>ypserv</application></entry>
	      <entry>只应在 NIS 服务器上运行它； 这是 NIS 的服务器进程。
		如果 &man.ypserv.8; 死掉的话，
		则服务器将不再具有响应 NIS 请求的能力 (此时，
		如果有从服务器的话， 则会接管操作)。 有一些 NIS
		的实现 (但不是 FreeBSD 的这个) 的客户机上，
		如果之前用过一个服务器， 而那台服务器死掉的话，
		并不尝试重新连接到另一个服务器。 通常，
		发生这种情况时， 唯一的办法就是重新启动服务器进程
		(或者， 甚至重新启动服务器) 或客户机上的
		<application>ypbind</application> 进程。
	      </entry>
	    </row>
	    <row>
	      <entry><application>rpc.yppasswdd</application></entry>
	      <entry>另一个只应在
		NIS 主服务器上运行的进程； 这是一个服务程序，
		其作用是允许 NIS 客户机改变它们的 NIS 口令。
		如果没有运行这个服务， 用户将必须登录到 NIS
		主服务器上， 并在那里修改口令。</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
      <!-- XXX Missing: rpc.ypxfrd (not important, though) May only run
      on the master -->

    </sect2>

    <sect2>
      <title>它是如何工作的？</title>

      <para>在 NIS 环境中， 有三种类型的主机：
	主服务器， 从服务器， 以及客户机。
	服务器的作用是充当主机配置信息的中央数据库。
	主服务器上保存着这些信息的权威副本，
	而从服务器则是保存这些信息的冗余副本。
	客户机依赖于服务器向它们提供这些信息。</para>

      <para>许多文件的信息可以通过这种方式来共享。
	通常情况下， <filename>master.passwd</filename>、
	<filename>group</filename>， 以及 <filename>hosts</filename>
	是通过 NIS 分发的。 无论什么时候，
	如果客户机上的某个进程请求这些本应在本地的文件中的资料的时候，
	它都会向所绑定的 NIS 服务器发出请求， 而不使用本地的版本。</para>

      <sect3>
        <title>机器类型</title>

        <itemizedlist>
	  <indexterm>
	    <primary>NIS</primary>
	    <secondary>主服务器</secondary>
	  </indexterm>
          <listitem>
            <para>一台 <emphasis>NIS 主服务器</emphasis>。
              这台服务器， 和 &windowsnt; 域控制器类似，
              会维护所有 NIS 客户机所使用的文件。 <filename>passwd</filename>，
              <filename>group</filename>， 以及许多其他 NIS
              客户机所使用的文件， 都被存放到主服务器上。</para>

            <note><para>可以将一台 NIS 主服务器用在多个 NIS 域中。
              然而， 本书不打算对这种配置进行介绍，
              因为这种配置， 通常只出现在小规模的 NIS 环境中。</para></note>
          </listitem>
	  <indexterm>
	    <primary>NIS</primary>
	    <secondary>从服务器</secondary>
	  </indexterm>
          <listitem>
            <para><emphasis>NIS 从服务器</emphasis>。 这一概念，
              与 &windowsnt; 的备份域控制器类似。 NIS 从服务器，
              用于维护 NIS 主服务器的数据文件副本。
              NIS 从服务器提供了一种冗余，
              这在许多重要的环境中是必需的。 此外，
              它也帮助减轻了主服务器的负荷： NIS
              客户机总是挂接到最先响应它们的 NIS 服务器上，
              而这也包括来自从服务器的响应。</para>
          </listitem>
	  <indexterm>
	    <primary>NIS</primary>
	    <secondary>客户机</secondary>
	  </indexterm>
          <listitem>
            <para><emphasis>NIS 客户机</emphasis>。 NIS 客户机，
              和多数 &windowsnt; 工作站类似， 通过
              NIS 服务器 (或对于 &windowsnt; 工作站， 则是
              &windowsnt; 域控制器) 来完成登录时的身份验证过程。</para>
          </listitem>
        </itemizedlist>
      </sect3>
    </sect2>

    <sect2>
      <title>使用 NIS/YP</title>

      <para>这一节将通过实例介绍如何配置 NIS 环境。</para>

      <note><para>这一节假定您正运行的是
        FreeBSD&nbsp;3.3 或更高版本。 这里给出的方法
        <emphasis>或许</emphasis> 可以在 FreeBSD
        3.0 以上的其他版本上使用， 但不保证。</para></note>


      <sect3>
        <title>规划</title>

        <para>假定您正在管理大学中的一个小型实验室。 在这个实验室中，
          有 15 台 FreeBSD 机器， 目前尚没有集中的管理点；
          每一台机器上有自己的
          <filename>/etc/passwd</filename> 和
          <filename>/etc/master.passwd</filename>。
          这些文件通过人工干预的方法来保持与其他机器上版本的同步；
          目前， 如果您在实验室中增加一个用户， 将不得不在所有 15
          台机器上手工执行 <command>adduser</command> 命令。
          毋庸置疑， 这一现状必须改变，
          因此您决定将整个实验室转为使用 NIS，
          并使用两台机器作为服务器。</para>

        <para>因此， 实验室的配置应该是这样的：</para>

        <informaltable frame="none" pgwide="1">
          <tgroup cols="3">
            <thead>
              <row>
                <entry>机器名</entry>
                <entry>IP 地址</entry>
                <entry>机器的角色</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry><hostid>ellington</hostid></entry>
                <entry><hostid role="ipaddr">10.0.0.2</hostid></entry>
                <entry>NIS 主服务器</entry>
              </row>
              <row>
                <entry><hostid>coltrane</hostid></entry>
                <entry><hostid role="ipaddr">10.0.0.3</hostid></entry>
                <entry>NIS 从服务器</entry>
              </row>
              <row>
                <entry><hostid>basie</hostid></entry>
                <entry><hostid role="ipaddr">10.0.0.4</hostid></entry>
                <entry>教员工作站</entry>
              </row>
              <row>
                <entry><hostid>bird</hostid></entry>
                <entry><hostid role="ipaddr">10.0.0.5</hostid></entry>
                <entry>客户机</entry>
              </row>
              <row>
                <entry><hostid>cli[1-11]</hostid></entry>
                <entry><hostid role="ipaddr">10.0.0.[6-17]</hostid></entry>
                <entry>其他客户机</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>如果您是首次配置 NIS， 仔细思考如何进行规划就十分重要。
	  无论您的网络的大小如何， 都必须进行几个决策。</para>

        <sect4>
          <title>选择 NIS 域名</title>

	  <indexterm>
	    <primary>NIS</primary>
	    <secondary>域名</secondary>
	  </indexterm>
          <para>这可能不是您过去使用的 <quote>域名(domainname)</quote>.
	    它的规范的叫法， 应该是
	    <quote>NIS 域名</quote>。 当客户机广播对此信息的请求时，
	    它会将 NIS 域的名字作为请求的一部分发出。 这样，
	    统一网络上的多个服务器， 就能够知道谁应该回应请求。
	    您可以把 NIS 域名想象成以某种方式相关的一组主机的名字。</para>

	  <para>一些机构会选择使用它们的 Internet
	    域名来作为 NIS 域名。 并不推荐这样做， 因为在调试网络问题时，
	    这可能会导致不必要的困扰。 NIS 域名应该是在您网络上唯一的，
	    并且有助于了解它所描述的到底是哪一组机器。 例如对于 Acme
	    公司的美工部门， 可以考虑使用
	    <quote>acme-art</quote> 这样的 NIS 域名。
	    在这个例子中， 您使用的域名是
	    <literal>test-domain</literal>。</para>

	  <indexterm><primary>SunOS</primary></indexterm>
          <para>然而， 某些操作系统 (最著名的是 &sunos;)
          会使用其 NIS 域名作为 Internet 域名。
          如果您的网络上存在包含这类限制的机器， 就
          <emphasis>必须</emphasis> 使用 Internet 域名来作为您的 NIS 域名。</para>
        </sect4>

        <sect4>
          <title>服务器的物理要求</title>

	  <para>选择 NIS 服务器时， 需要时刻牢记一些东西。
	    NIS 的一个不太好的特性就是其客户机对于服务器的依赖程度。
	    如果客户机无法与其 NIS 域的服务器联系，
	    则这台机器通常会陷于不可用的状态。 缺少用户和组信息，
	    会使绝大多数系统进入短暂的冻结状态。 基于这样的考虑，
	    您需要选择一台不经常重新启动， 或用于开发的机器来承担其责任。
	    如果您的网络不太忙， 也可以使用运行着其他服务的机器来安放 NIS
	    服务， 只是需要注意， 一旦 NIS 服务器不可用， 则
	    <emphasis>所有</emphasis> 的 NIS 客户机都会受到影响。</para>
        </sect4>
      </sect3>

      <sect3>
        <title>NIS 服务器</title>

	<para>所有的 NIS 信息的正规版本，
	  都被保存在一台单独的称作 NIS 主服务器的机器上。
	  用于保存这些信息的数据库， 称为 NIS 映射(map)。
	  在 FreeBSD 中， 这些映射被保存在
	  <filename>/var/yp/[domainname]</filename> 里， 其中
	  <filename>[domainname]</filename> 是提供服务的 NIS
	  域的名字。 一台 NIS 服务器， 可以同时支持多个域，
	  因此可以建立很多这样的目录， 所支撑一个域对应一个。
	  每一个域都会有一组独立的映射。</para>

	<para>NIS 主和从服务器， 通过 <command>ypserv</command>
	  服务程序来处理所有的 NIS 请求。
	  <command>ypserv</command> 有责任接收来自 NIS 客户机的请求，
	  翻译请求的域， 并将名字映射为相关的数据库文件的路径，
	  然后将来自数据库的数据传回客户机。</para>

        <sect4>
	  <title>配置 NIS 主服务器</title>
	  <indexterm>
	    <primary>NIS</primary>
	    <secondary>服务器配置</secondary>
	  </indexterm>
	  <para>配置主 NIS 服务器相对而言十分的简单，
	    而其具体步骤则取决于您的需要。 FreeBSD
	    提供了一步到位的 NIS 支持。 您需要做的全部事情， 只是在
	    <filename>/etc/rc.conf</filename> 中加入一些配置，
	    其他工作会由 FreeBSD 完成。</para>

          <procedure>
            <step>
              <para><programlisting>nisdomainname="test-domain"</programlisting>
                这一行将在网络启动 (例如重新启动) 时， 把 NIS 域名配置为
                <literal>test-domain</literal>。</para>
            </step>
            <step>
              <para><programlisting>nis_server_enable="YES"</programlisting>
                这将要求 FreeBSD 在网络子系统启动之后立即启动
                NIS 服务进程。</para>
            </step>
            <step>
              <para><programlisting>nis_yppasswdd_enable="YES"</programlisting>
                这将启用 <command>rpc.yppasswdd</command>
                服务程序， 如前面提到的，
                它允许用户在客户机上修改自己的 NIS 口令。</para>
            </step>
          </procedure>

          <note>
            <para>随 NIS 配置的不同， 可能还需要增加其他一些项目。 请参见 <link
              linkend="network-nis-server-is-client">关于 NIS 服务器同时充当 NIS
              客户机</link> 这一节， 以了解进一步的情况。</para>
          </note>

          <para>现在， 所需要做的最后的工作是以超级用户身份执行
            <command>/etc/netstart</command> 命令。 这将依据
            <filename>/etc/rc.conf</filename>
            为您配置好所有的东西。</para>
        </sect4>

        <sect4>
          <title>初始化 NIS 映射</title>
          <indexterm>
            <primary>NIS</primary>
            <secondary>映射</secondary>
          </indexterm>
          <para><emphasis>NIS 映射</emphasis> 是一些数据库文件，
            它们位于 <filename>/var/yp</filename> 目录中。
            这些文件基本上都是根据 NIS 主服务器的 <filename>/etc</filename>
            目录自动生成的， 唯一的例外是：
            <filename>/etc/master.passwd</filename> 文件。 一般来说，
            您会有非常充分的理由不将 <username>root</username>
            以及其他管理帐号的口令发到所有 NIS 域上的服务器上。
            因此， 在开始初始化 NIS 映射之前， 我们应该：</para>

          <screen>&prompt.root; <userinput>cp /etc/master.passwd /var/yp/master.passwd</userinput>
&prompt.root; <userinput>cd /var/yp</userinput>
&prompt.root; <userinput>vi master.passwd</userinput></screen>

          <para>这里， 删除掉和系统有关的帐号对应的项 (<username>bin</username>、
            <username>tty</username>、 <username>kmem</username>、
            <username>games</username>， 等等)，
            以及其他不希望被扩散到 NIS 客户机的帐号
            (例如 <username>root</username> 和任何其他 UID 0
            (超级用户) 的帐号)。</para>

          <note><para>确认
            <filename>/var/yp/master.passwd</filename> 这个文件是同组，其他
            以及其他用户不可读的 (模式 600)！ 如果需要的话， 用
            <command>chmod</command> 命令来改它。</para></note>

	  <indexterm><primary>Tru64 UNIX</primary></indexterm>

          <para>完成这些工作之后， 就可以初始化
            NIS 映射了！ FreeBSD 提供了一个名为
            <command>ypinit</command> 的脚本来帮助您完成这项工作 (详细信息，
            请见其联机手册)。 请注意， 这个脚本在绝大多数 &unix;
            操作系统上都可以找到， 但并不是所有操作系统的都提供。
            在 Digital UNIX/Compaq Tru64 UNIX 上它的名字是
            <command>ypsetup</command>。 由于我们正在生成的是 NIS
            主服务器的映射， 因此应该使用  <command>ypinit</command> 的
            <option>-m</option> 参数。 如果已经完成了上述步骤，
            要生成 NIS 映射， 只需执行：</para>

          <screen>ellington&prompt.root; <userinput>ypinit -m test-domain</userinput>
Server Type: MASTER Domain: test-domain
Creating an YP server will require that you answer a few questions.
Questions will all be asked at the beginning of the procedure.
Do you want this procedure to quit on non-fatal errors? [y/n: n] <userinput>n</userinput>
Ok, please remember to go back and redo manually whatever fails.
If you don't, something might not work.
At this point, we have to construct a list of this domains YP servers.
rod.darktech.org is already known as master server.
Please continue to add any slave servers, one per line. When you are
done with the list, type a &lt;control D&gt;.
master server   :  ellington
next host to add:  <userinput>coltrane</userinput>
next host to add:  <userinput>^D</userinput>
The current list of NIS servers looks like this:
ellington
coltrane
Is this correct?  [y/n: y] <userinput>y</userinput>

[..output from map generation..]

NIS Map update completed.
ellington has been setup as an YP master server without any errors.</screen>

          <para><command>ypinit</command> 应该会根据
            <filename>/var/yp/Makefile.dist</filename> 来创建
            <filename>/var/yp/Makefile</filename> 文件。
            创建完之后， 这个文件会假定您正在操作只有 FreeBSD
            及其德单服务器 NIS 环境。 由于 <literal>test-domain</literal>
            还有一个从服务器， 您必须编辑
            <filename>/var/yp/Makefile</filename>：</para>

          <screen>ellington&prompt.root; <userinput>vi /var/yp/Makefile</userinput></screen>

	  <para>应该能够看到这样一行， 其内容是</para>

	  <programlisting>NOPUSH = "True"</programlisting>

	  <para>(如果还没有注释掉的话)。</para>
        </sect4>

        <sect4>
	  <title>配置 NIS 从服务器</title>
	  <indexterm>
	    <primary>NIS</primary>
	    <secondary>从服务器</secondary>
	  </indexterm>
	  <para>配置 NIS 从服务器， 甚至比配置主服务器还要简单。
	    登录到从服务器上， 并按照前面的方法，
            编辑 <filename>/etc/rc.conf</filename> 文件。 唯一的区别是，
            在运行 <command>ypinit</command> 时需要使用
            <option>-s</option> 参数。
            这里的 <option>-s</option> 选项， 同时要求提供 NIS
            主服务器的名字， 因此我们的命令行应该是：</para>

  <screen>coltrane&prompt.root; <userinput>ypinit -s ellington test-domain</userinput>

Server Type: SLAVE Domain: test-domain Master: ellington

Creating an YP server will require that you answer a few questions.
Questions will all be asked at the beginning of the procedure.

Do you want this procedure to quit on non-fatal errors? [y/n: n]  <userinput>n</userinput>

Ok, please remember to go back and redo manually whatever fails.
If you don't, something might not work.
There will be no further questions. The remainder of the procedure
should take a few minutes, to copy the databases from ellington.
Transferring netgroup...
ypxfr: Exiting: Map successfully transferred
Transferring netgroup.byuser...
ypxfr: Exiting: Map successfully transferred
Transferring netgroup.byhost...
ypxfr: Exiting: Map successfully transferred
Transferring master.passwd.byuid...
ypxfr: Exiting: Map successfully transferred
Transferring passwd.byuid...
ypxfr: Exiting: Map successfully transferred
Transferring passwd.byname...
ypxfr: Exiting: Map successfully transferred
Transferring group.bygid...
ypxfr: Exiting: Map successfully transferred
Transferring group.byname...
ypxfr: Exiting: Map successfully transferred
Transferring services.byname...
ypxfr: Exiting: Map successfully transferred
Transferring rpc.bynumber...
ypxfr: Exiting: Map successfully transferred
Transferring rpc.byname...
ypxfr: Exiting: Map successfully transferred
Transferring protocols.byname...
ypxfr: Exiting: Map successfully transferred
Transferring master.passwd.byname...
ypxfr: Exiting: Map successfully transferred
Transferring networks.byname...
ypxfr: Exiting: Map successfully transferred
Transferring networks.byaddr...
ypxfr: Exiting: Map successfully transferred
Transferring netid.byname...
ypxfr: Exiting: Map successfully transferred
Transferring hosts.byaddr...
ypxfr: Exiting: Map successfully transferred
Transferring protocols.bynumber...
ypxfr: Exiting: Map successfully transferred
Transferring ypservers...
ypxfr: Exiting: Map successfully transferred
Transferring hosts.byname...
ypxfr: Exiting: Map successfully transferred

coltrane has been setup as an YP slave server without any errors.
Don't forget to update map ypservers on ellington.</screen>

	  <para>现在应该会有一个叫做
	    <filename>/var/yp/test-domain</filename> 的目录。
	    在这个目录中， 应该保存 NIS 主服务器上的映射的副本。
	    接下来需要确定这些文件都及时地同步更新了。 在从服务器上， 下面的
	    <filename>/etc/crontab</filename> 项将帮助您确保这一点：</para>

	  <programlisting>20      *       *       *       *       root   /usr/libexec/ypxfr passwd.byname
21      *       *       *       *       root   /usr/libexec/ypxfr passwd.byuid</programlisting>

	  <para>这两行将强制从服务器将映射与主服务器同步。
	    由于主服务器会场时确保所有其 NIS 映射的变动都与从服务器知会，
	    因此这些项并不是绝对必需的， 尽管如此，
	    强制更新能够保证这些对依赖于服务器的系统至关重要的口令信息及时地同步，
	    同时， 在繁忙的网络上， 有时也会出现映射同步更新不完全的情况。</para>

          <para>现在， 在从服务器上执行 <command>/etc/netstart</command>，
            就可以启动 NIS 服务了。</para>
	</sect4>
      </sect3>

      <sect3>
        <title>NIS 客户机</title>

	<para>NIS 客户机会通过
	  <command>ypbind</command> 服务程序来与特定的 NIS
	  服务器建立一种称作绑定的联系。
	  <command>ypbind</command> 会检查系统的默认域
	  (这是通过 <command>domainname</command> 命令来设置的)，
	  并开始在本地网络上广播 RPC 请求。 这些请求会指定
	  <command>ypbind</command> 尝试绑定的域名。
	  如果已经配置了服务器， 并且这些服务器接到了广播， 它将回应
	  <command>ypbind</command>， 后者则记录服务器的地址。
	  如果有多个可用的服务器 (例如一个主服务器， 加上多个从服务器)，
	  <command>ypbind</command> 将使用第一个响应的地址。
	  从这一时刻开始， 客户机会把所有的 NIS 请求直接发给那个服务器。
	  <command>ypbind</command> 偶尔会 <quote>ping</quote>
	  服务器以确认其仍然在正常运行。 如果在合理的时间内没有得到响应， 则
	  <command>ypbind</command> 会把域标记为未绑定， 并再次发起广播，
	  以期找到另一台服务器。</para>

	<sect4>
	  <title>设置 NIS 客户机</title>
	  <indexterm>
	    <primary>NIS</primary>
	    <secondary>客户机配置</secondary>
	  </indexterm>
	  <para>配置一台 FreeBSD 机器作为 NIS 客户机是非常简单的。</para>

	  <procedure>
	    <step>
	      <para>编辑 <filename>/etc/rc.conf</filename> 文件，
                并在其中加上下面几行， 以设置 NIS 域名，
                并在网络启动时启动 <command>ypbind</command>：</para>

	      <programlisting>nisdomainname="test-domain"
nis_client_enable="YES"</programlisting>
	    </step>

	    <step>
	      <para>要从 NIS 服务器导入所有的口令项，
		需要从您的
		<filename>/etc/master.passwd</filename> 文件中删除所有用户，
		并使用
		<command>vipw</command> 在这个文件的最后一行加入：</para>

	      <programlisting>+:::::::::</programlisting>

	      <note>
		<para>这一行将让 NFS 服务器的口令映射中的帐号能够登录。
		  也有很多修改这一行来配置 NIS 客户机的办法。
		  请参见稍后的 <link linkend="network-netgroups">netgroups
		  小节</link> 以了解进一步的情况。
                  要了解更多信息， 可以参阅 O'Reilly 的
		  <literal>Managing NFS and NIS</literal> 这本书。</para>
	      </note>

              <note>
                <para>需要至少保留一个本地帐号 (也就是不通过 NIS 导入) 在您的
                  <filename>/etc/master.passwd</filename> 文件中，
                  而这个帐号应该是
                  <groupname>wheel</groupname> 组的成员。 如果 NIS 发生不测，
                  这个帐号可以用来远程登录，
                  成为 <username>root</username>， 并修正问题。</para>
              </note>
            </step>

	    <step>
	      <para>要从 NIS 服务器上导入组信息， 需要在
		<filename>/etc/group</filename> 文件末尾加入：</para>

	      <programlisting>+:*::</programlisting>
	    </step>
	  </procedure>

	  <para>完成这些步骤之后， 就应该可以通过运行
	    <command>ypcat passwd</command> 来看到 NIS 服务器的口令映射了。</para>
	</sect4>
      </sect3>
    </sect2>

    <sect2>
      <title>NIS 的安全性</title>

      <para>基本上， 任何远程用户都可以发起一个 RPC 到
	&man.ypserv.8; 并获得您的 NIS 映射的内容，
	如果远程用户了解您的域名的话。
	要避免这类未经授权的访问， &man.ypserv.8;
	支持一个称为 <quote>securenets</quote> 的特性，
	用以将访问限制在一组特定的机器上。 在启动过程中，
	&man.ypserv.8; 会尝试从
	<filename>/var/yp/securenets</filename>
	中加载 securenet 信息。</para>

      <note>
	<para>这个路径随
	  <option>-p</option> 参数改变。 这个文件包含了一些项，
	  每一项中包含了一个网络标识和子网掩码， 中间用空格分开。
	  以 <quote>#</quote> 开头的行会被认为是注释。
	  示范的 securenets 文件如下所示：</para>
      </note>

      <programlisting># allow connections from local host -- mandatory
127.0.0.1     255.255.255.255
# allow connections from any host
# on the 192.168.128.0 network
192.168.128.0 255.255.255.0
# allow connections from any host
# between 10.0.0.0 to 10.0.15.255
# this includes the machines in the testlab
10.0.0.0      255.255.240.0</programlisting>

      <para>如果 &man.ypserv.8; 接到了来自匹配上述任一规则的地址的请求，
	则它会正常处理请求。 反之， 则请求将被忽略， 并记录一条警告信息。 如果
	<filename>/var/yp/securenets</filename> 文件不存在， 则
	<command>ypserv</command> 会允许来自任意主机的请求。</para>

      <para><command>ypserv</command> 程序也支持
	Wietse Venema 的 <application>TCP Wrapper</application> 软件包。
	这样， 管理员就能够使用
	<application>TCP Wrapper</application> 的配置文件来代替
	<filename>/var/yp/securenets</filename> 完成访问控制。</para>

      <note>
        <para>尽管这两种访问控制机制都能够提供某种程度的安全，
          但是， 和特权端口检查一样，
          它们无法避免 <quote>IP 伪造</quote> 攻击。 您的防火墙应该阻止所有与
          NIS 有关的访问。</para>

        <para>使用 <filename>/var/yp/securenets</filename> 的服务器，
          可能会无法为某些使用陈旧的 TCP/IP 实现的 NIS 客户机服务。
          这些实现可能会在广播时， 将主机位都设置为 0，
          或在计算广播地址时忽略子网掩码。
          尽管这些问题可以通过修改客户机的配置来解决，
          其他一些问题也可能导致不得不淘汰那些客户机系统，
          或者不使用 <filename>/var/yp/securenets</filename>。</para>

        <para>在使用陈旧的 TCP/IP 实现的系统上，
	  使用 <filename>/var/yp/securenets</filename> 是一个非常糟糕的做法，
	  因为这将导致您的网络上的 NIS 丧失大部分功能。</para>

	<indexterm><primary>TCP Wrappers</primary></indexterm>
        <para>使用 <application>TCP Wrapper</application>
          软件包， 会导致您的 NIS 服务器的响应延迟增加。
          而增加的延迟， 则可能会导致客户端程序超时，
          特别是在繁忙的网络或者很慢的
          NIS 服务器上。 如果您的某个客户机因此而产生一些异常，
          则应将这些客户机变为 NIS 从服务器，
          并强制其绑定自己。</para>
      </note>
    </sect2>

    <sect2>
      <title>不允许某些用户登录</title>

      <para>在我们的实验室中， <hostid>basie</hostid> 这台机器，
        是一台教员专用的工作站。 我们不希望将这台机器拿出 NIS 域，
        而主 NIS 服务器上的 <filename>passwd</filename> 文件，
        则同时包含了教员和学生的帐号。 这时应该怎么做？</para>

      <para>有一种办法来禁止特定的用户登录机器， 即使他们身处 NIS 数据库之中。
        要完成这一工作， 只需要在客户机的 <filename>/etc/master.passwd</filename>
        文件中加入一些
        <literal>-<replaceable>username</replaceable></literal> 这样的项，
        其中， <replaceable>username</replaceable> 是希望禁止登录的用户名。
        一般推荐使用 <command>vipw</command> 来完成这个工作，
        因为 <command>vipw</command> 会对您在 <filename>/etc/master.passwd</filename>
        文件上所作的修改进行合法性检查，
        并在编辑结束时重新构建口令数据库。 例如， 如果希望禁止用户
        <username>bill</username> 登录
        <hostid>basie</hostid>， 我们应该：</para>

        <screen>basie&prompt.root; <userinput>vipw</userinput>
<userinput>[在末尾加入 -bill， 并退出]</userinput>
vipw: rebuilding the database...
vipw: done

basie&prompt.root; <userinput>cat /etc/master.passwd</userinput>

root:[password]:0:0::0:0:The super-user:/root:/bin/csh
toor:[password]:0:0::0:0:The other super-user:/root:/bin/sh
daemon:*:1:1::0:0:Owner of many system processes:/root:/sbin/nologin
operator:*:2:5::0:0:System &:/:/sbin/nologin
bin:*:3:7::0:0:Binaries Commands and Source,,,:/:/sbin/nologin
tty:*:4:65533::0:0:Tty Sandbox:/:/sbin/nologin
kmem:*:5:65533::0:0:KMem Sandbox:/:/sbin/nologin
games:*:7:13::0:0:Games pseudo-user:/usr/games:/sbin/nologin
news:*:8:8::0:0:News Subsystem:/:/sbin/nologin
man:*:9:9::0:0:Mister Man Pages:/usr/share/man:/sbin/nologin
bind:*:53:53::0:0:Bind Sandbox:/:/sbin/nologin
uucp:*:66:66::0:0:UUCP pseudo-user:/var/spool/uucppublic:/usr/libexec/uucp/uucico
xten:*:67:67::0:0:X-10 daemon:/usr/local/xten:/sbin/nologin
pop:*:68:6::0:0:Post Office Owner:/nonexistent:/sbin/nologin
nobody:*:65534:65534::0:0:Unprivileged user:/nonexistent:/sbin/nologin
+:::::::::
-bill

basie&prompt.root;</screen>
    </sect2>

    <sect2 id="network-netgroups">
      <sect2info>
        <authorgroup>
          <author>
            <firstname>Udo</firstname>
            <surname>Erdelhoff</surname>
            <contrib>Contributed by </contrib>
          </author>
        </authorgroup>
      </sect2info>

      <title>使用 Netgroups</title>
      <indexterm><primary>netgroups</primary></indexterm>

      <para>前一节介绍的方法，
        在您需要为非常少的用户和/或机器进行特殊的规则配置时还算凑合。
        在更大的网络上， 您
        <emphasis>一定会</emphasis> 忘记禁止某些用户登录到敏感的机器上，
        或者， 甚至必须单独地修改每一台机器的配置， 因而丢掉了 NIS 最重要的优越性：
        <emphasis>集中式</emphasis> 管理。</para>

      <para>NIS 开发人员为这个问题提供的解决方案， 被称作
        <emphasis>netgroups</emphasis>。 它们的作用和语义，
        基本上可以等同于 &unix; 文件系统上使用的组。
        主要的区别是它们没有数字化的 ID， 以及可以在 netgroup
        中同时包含用户和其他 netgroup。</para>

      <para>Netgroups 被设计用来处理大的、 复杂的包含数百用户和机器的网络。
        一方面， 在您不得不处理这类情形时， 这是一个很有用的东西。
        而另一方面， 它的复杂性又使得通过非常简单的例子很难解释 netgroup
        到底是什么。 这一节的其余部分的例子将展示这个问题。</para>

      <para>假设您在实验室中成功地部署 NIS 引起了上司的兴趣。
        您接下来的任务是将 NIS 域扩展， 以覆盖校园中的一些其他的机器。
        下面两个表哥中包括了新用户和新机器， 及其简要说明。</para>

      <informaltable frame="none" pgwide="1">
        <tgroup cols="2">
          <thead>
            <row>
              <entry>用户名</entry>
              <entry>说明</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><username>alpha</username>, <username>beta</username></entry>
              <entry>IT 部门的普通雇员</entry>
            </row>

            <row>
              <entry><username>charlie</username>, <username>delta</username></entry>
              <entry>IT 部门的学徒</entry>
            </row>

            <row>
              <entry><username>echo</username>, <username>foxtrott</username>, <username>golf</username>, ...</entry>
              <entry>普通雇员</entry>
            </row>

            <row>
              <entry><username>able</username>, <username>baker</username>, ...</entry>
              <entry>目前的实习生</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <informaltable frame="none" pgwide="1">
        <tgroup cols="2">
          <thead>
            <row>
              <entry>机器名</entry>
              <entry>说明</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <!--  Names taken from "Good Omens" by Neil Gaiman and Terry
                    Pratchett.  Many thanks for a brilliant book.  -->

              <entry><hostid>war</hostid>, <hostid>death</hostid>,
              <hostid>famine</hostid>,
              <hostid>pollution</hostid></entry>
              <entry>最重要的服务器。 只有 IT
                部门的雇员才允许登录这些机器。</entry>
            </row>
            <row>
              <!-- gluttony was omitted because it was too fat -->

              <entry><hostid>pride</hostid>, <hostid>greed</hostid>,
              <hostid>envy</hostid>, <hostid>wrath</hostid>,
              <hostid>lust</hostid>, <hostid>sloth</hostid></entry>
              <entry>不太重要的服务器， 所有 IT 部门的成员，
              都可以登录这些机器。</entry>
            </row>

            <row>
              <entry><hostid>one</hostid>, <hostid>two</hostid>,
                <hostid>three</hostid>, <hostid>four</hostid>,
                ...</entry>

              <entry>普通工作站。 只有
                <emphasis>真正的</emphasis> 雇员才允许登录这些机器。</entry>
            </row>

            <row>
              <entry><hostid>trashcan</hostid></entry>
              <entry>一台不包含关键数据的旧机器。
                即使是实习生， 也允许登录它。</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>如果您尝试通过一个一个地阻止用户来实现这些限制，
        就需要在每一个系统的 <filename>passwd</filename> 文件中，
        为每一个不允许登录该系统的用户添加对应的
        <literal>-<replaceable>user</replaceable></literal> 行。
        如果忘记了任何一个， 就可能会造成问题。 在进行初始配置时，
        正确地配置也许不是什么问题， 但随着日复一日地添加新用户，
        <emphasis>总有一天</emphasis> 您会忘记为新用户添加某个行。
        毕竟， Murphy 是一个乐观的人。</para>

      <para>使用 netgroups 来处理这一状况可以带来许多好处。
        不需要单独地处理每一个用户； 您可以赋予用户一个或多个 netgroups
        身份， 并允许或禁止某一个 netgroup 的所有成员登录。
        如果添加了新的机器， 只需要定义 netgroup 的登录限制。
        如果增加了新用户， 也只需要将用户加入一个或多个 netgroup。
        这些变化是相互独立的： 不再需要 <quote>对每一个用户和机器执行
        ……</quote>。 如果您的 NIS 配置经过了谨慎的规划，
        就只需要修改一个中央的配置文件， 就能够允许或禁止访问某台机器的权限了。</para>

      <para>第一步是初始化 NIS 映射
        netgroup。 FreeBSD 的 &man.ypinit.8; 默认情况下并不创建这个映射，
        但它的 NIS 实现能够在创建这个映射之后立即对其提供支持。
        要创建空映射， 简单地输入</para>

      <screen>ellington&prompt.root; <userinput>vi /var/yp/netgroup</userinput></screen>

      <para>并开始增加内容。 在我们的例子中， 至少需要四个 nergruop：
         IT 雇员， IT 学徒， 普通雇员和实习生。</para>

      <programlisting>IT_EMP  (,alpha,test-domain)    (,beta,test-domain)
IT_APP  (,charlie,test-domain)  (,delta,test-domain)
USERS   (,echo,test-domain)     (,foxtrott,test-domain) \
        (,golf,test-domain)
INTERNS (,able,test-domain)     (,baker,test-domain)</programlisting>

      <para><literal>IT_EMP</literal>, <literal>IT_APP</literal> 等等，
        是 netgroup 的名字。 每一个括号中的组中，
        都有一些用户帐号。 组中的三个字段是：</para>

      <orderedlist>
        <listitem>
          <para>在哪些机器上能够使用这些项。 如果不指定主机名，
            则项在所有机器上都有效。 如果指定了主机，
            则很容易造成混淆。</para>
        </listitem>

        <listitem>
          <para>属于这个 netgroup 的帐号。</para>
        </listitem>

        <listitem>
          <para>帐号的 NIS 域。 您可以从其他 NIS
            域中把帐号导入到您的 netgroup 中，
            如果您管理多个 NIS 域的话。</para>
        </listitem>
      </orderedlist>

      <para>每一个字段都可以包括通配符。 参见
        &man.netgroup.5; 了解更多细节。</para>

      <note>
        <indexterm><primary>netgroups</primary></indexterm>
        <para>Netgroup 的名字一般来说不应超过 8 个字符，
          特别是当您的 NIS 域中有机器打算运行其它操作系统的时候。
          名字是区分大小写的； 使用大写字母作为 netgroup 的名字，
          能够让您更容易地区分用户、 机器和 netgroup 的名字。</para>

        <para>某些 NIS 客户程序 (FreeBSD 以外的那些) 可能无法处理含有大量项的
          netgroup。 例如， 某些早期版本的 &sunos; 会在 netgroup
          中包含多于 15 个 <emphasis>项</emphasis> 时出现问题。
          要绕过这个问题， 可以创建多个 子netgroup，每一个中包含少于 15 个用户，
          以及一个包含所有 子netgroup 的真正的 netgroup：</para>

        <programlisting>BIGGRP1  (,joe1,domain)  (,joe2,domain)  (,joe3,domain) [...]
BIGGRP2  (,joe16,domain)  (,joe17,domain) [...]
BIGGRP3  (,joe31,domain)  (,joe32,domain)
BIGGROUP  BIGGRP1 BIGGRP2 BIGGRP3</programlisting>

        <para>如果需要超过 225 个用户， 可以继续重复上面的过程。</para>
      </note>

      <para>激活并分发新的 NIS 映射非常简单：</para>

      <screen>ellington&prompt.root; <userinput>cd /var/yp</userinput>
ellington&prompt.root; <userinput>make</userinput></screen>

      <para>这个操作会生成三个 NIS 映射， 即
        <filename>netgroup</filename>、
        <filename>netgroup.byhost</filename> 和
        <filename>netgroup.byuser</filename>。 用 &man.ypcat.1;
        可以检查这些 NIS 映射是否可用了：</para>

      <screen>ellington&prompt.user; <userinput>ypcat -k netgroup</userinput>
ellington&prompt.user; <userinput>ypcat -k netgroup.byhost</userinput>
ellington&prompt.user; <userinput>ypcat -k netgroup.byuser</userinput></screen>

      <para>第一个命令的输出，
        应该与 <filename>/var/yp/netgroup</filename> 的内容相近。
        第二个命令， 如果没有指定本机专有的 netgroup，
        则应该没有输出。 第三个命令，
        则用于显示某个用户对应的 netgroup 列表。</para>

      <para>客户机的设置也很简单。 要配置服务器
        <hostid>war</hostid>， 只需进入
        &man.vipw.8; 并把</para>

      <programlisting>+:::::::::</programlisting>

      <para>改为</para>

      <programlisting>+@IT_EMP:::::::::</programlisting>

      <para>现在， 只有 netgroup
        <literal>IT_EMP</literal> 中定义的用户会被导入到
        <hostid>war</hostid> 的口令数据库中，
        因此只有这些用户能够登录。</para>

      <para>不过， 这个限制也会作用于 shell 的
	<literal>~</literal>， 以及所有在用户名和数字用户 ID
	之间实施转换的函数的功能。 换言之， <command>cd
	~<replaceable>user</replaceable></command> 将不会正常工作， 而
	<command>ls -l</command> 也将显示数字的 ID 而不是用户名，
	并且 <command>find . -user joe -print</command>
	将失败， 并给出 <errorname>No such user</errorname> 的错误信息。
	要修正这个问题， 您需要导入所有的用户项， 而
	<emphasis>不允许他们登录服务器</emphasis>。</para>

      <para>这可以通过在
        <filename>/etc/master.passwd</filename> 加入另一行来完成。
        这行的内容是：</para>

      <para><literal>+:::::::::/sbin/nologin</literal>， 意思是
        <quote>导入所有的项， 但导入项的 shell 则替换为
        <filename>/sbin/nologin</filename></quote>。
        通过在 <filename>/etc/master.passwd</filename>
        中增加默认值， 可以替换掉
        <literal>passwd</literal> 中的任意字段。</para>

      <!-- Been there, done that, got the scars to prove it - ue -->
      <warning>
        <para>务必确认
        <literal>+:::::::::/sbin/nologin</literal> 这一行出现在
        <literal>+@IT_EMP:::::::::</literal> 之后。
        否则， 所有从 NIS 导入的用户帐号将以 <filename>/sbin/nologin</filename>
        作为登录 shell。</para>
      </warning>

      <para>完成上面的修改之后， 在 IT 部门有了新员工时，
        只需修改一个 NIS 映射就足够了。 您也可以用类似的方法，
        在不太重要的服务器上， 把先前本地版本的 <filename>/etc/master.passwd</filename>
        中的 <literal>+:::::::::</literal> 改为：</para>

      <programlisting>+@IT_EMP:::::::::
+@IT_APP:::::::::
+:::::::::/sbin/nologin</programlisting>

      <para>相关的用于普通工作站的配置则应是：</para>

      <programlisting>+@IT_EMP:::::::::
+@USERS:::::::::
+:::::::::/sbin/nologin</programlisting>

      <para>一切平安无事， 直到数周后， 有一天策略发生了变化：
        IT 部门也开始招收实习生了。 IT 实习生允许使用普通的终端，
        以及不太重要的服务器； 而 IT 学徒， 则可以登录主服务器。
        您增加了新的 netgroup <literal>IT_INTERN</literal>， 以及新的 IT
        IT 实习生到这个 netgroup 并开始修改每一台机器上的配置……
        老话说得好： <quote>牵一发， 动全身</quote>。</para>

      <para>NIS 通过 netgroup 来建立 netgroup 的能力，
        正可以避免这样的情形。 一种可能的方法是建立基于角色的 netgroup。
        例如， 您可以创建称为
        <literal>BIGSRV</literal> 的 netgroup， 用于定义最重要的服务器上的登录限制，
        以及另一个成为 <literal>SMALLSRV</literal> 的 netgroup，
        用以定义次重要的服务器， 以及第三个， 用于普通工作站的 netgroup
        <literal>USERBOX</literal>。 这三个 netgroup 中的每一个，
        都包含了允许登录到这些机器上的所有 netgroup。
        您的 NIS 映射中的新项如下所示：</para>

      <programlisting>BIGSRV    IT_EMP  IT_APP
SMALLSRV  IT_EMP  IT_APP  ITINTERN
USERBOX   IT_EMP  ITINTERN USERS</programlisting>

      <para>这种定义登录限制的方法，
        在您能够将机器分组并加以限制的时候可以工作的相当好。
        不行的是， 这是种例外， 而非规律。 多数时候，
        需要按机器去定义登录限制。</para>

      <para>与机器相关的 netgroup 定义， 是处理上述策略改动的另一种可能的方法。
        此时， 每台机器的 <filename>/etc/master.passwd</filename> 中，
        都包含两个 <quote>+</quote> 开头的行。 第一个用于添加允许登录的 netgroup
        帐号， 而第二个则用于增加其它帐号， 并把 shell
        设置为 <filename>/sbin/nologin</filename>。 使用 <quote>全大写</quote>
        的机器名作为 netgroup 名是个好主意。 换言之， 这些行应该类似于：</para>

      <programlisting>+@<replaceable>BOXNAME</replaceable>:::::::::
+:::::::::/sbin/nologin</programlisting>

      <para>一旦在所有机器上都完成了这样的修改， 就再也不需要修改本地的
        <filename>/etc/master.passwd</filename> 了。
        所有未来的修改都可以在 NIS 映射中进行。 这里是一个例子，
        其中展示了在这一应用情景中所需要的 netgroup 映射，
        以及其它一些常用的技巧：</para>

      <programlisting># Define groups of users first
IT_EMP    (,alpha,test-domain)    (,beta,test-domain)
IT_APP    (,charlie,test-domain)  (,delta,test-domain)
DEPT1     (,echo,test-domain)     (,foxtrott,test-domain)
DEPT2     (,golf,test-domain)     (,hotel,test-domain)
DEPT3     (,india,test-domain)    (,juliet,test-domain)
ITINTERN  (,kilo,test-domain)     (,lima,test-domain)
D_INTERNS (,able,test-domain)     (,baker,test-domain)
#
# Now, define some groups based on roles
USERS     DEPT1   DEPT2     DEPT3
BIGSRV    IT_EMP  IT_APP
SMALLSRV  IT_EMP  IT_APP    ITINTERN
USERBOX   IT_EMP  ITINTERN  USERS
#
# And a groups for a special tasks
# Allow echo and golf to access our anti-virus-machine
SECURITY  IT_EMP  (,echo,test-domain)  (,golf,test-domain)
#
# machine-based netgroups
# Our main servers
WAR       BIGSRV
FAMINE    BIGSRV
# User india needs access to this server
POLLUTION  BIGSRV  (,india,test-domain)
#
# This one is really important and needs more access restrictions
DEATH     IT_EMP
#
# The anti-virus-machine mentioned above
ONE       SECURITY
#
# Restrict a machine to a single user
TWO       (,hotel,test-domain)
# [...more groups to follow]</programlisting>

      <para>如果您正使用某种数据库来管理帐号，
        应该可以使用您的数据库的报告工具来创建映射的第一部分。
        这样， 新用户就自动地可以访问这些机器了。</para>

      <para>最后的提醒： 使用基于机器的 netgroup 并不是普适的。
        如果正在为学生实验室部署数十台甚至上百台同样的机器，
        您应该使用基于角色的 netgroup， 而不是基于机器的 netgroup，
        以便把 NIS 映射的尺寸保持在一个合理的范围内。</para>
    </sect2>

    <sect2>
      <title>需要牢记的事项</title>

      <para>这里是一些其它在使用 NIS 环境时需要注意的地方。</para>

      <itemizedlist>
        <listitem>
          <para>每次需要在实验室中增加新用户时，
            必须 <emphasis>只</emphasis> 在 NIS 服务器上加入用户，
            而且 <emphasis>一定要记得重建 NIS 映射</emphasis>。
            如果您忘记了这样做， 新用户将无法登录除 NIS
            主服务器之外的任何其它机器。 例如， 如果要在实验室增加新用户
            <username>jsmith</username>， 我们需要：</para>

          <screen>&prompt.root; <userinput>pw useradd jsmith</userinput>
&prompt.root; <userinput>cd /var/yp</userinput>
&prompt.root; <userinput>make test-domain</userinput></screen>

          <para>也可以运行 <command>adduser jsmith</command> 而不是
            <command>pw useradd jsmith</command>.</para>
        </listitem>
        <listitem>
          <para><emphasis>将管理用的帐号排除在
            NIS 映射之外</emphasis>。 一般来说，
            您不希望这些管理帐号和口令被扩散到那些包含不应使用它们的用户的机器上。</para>
        </listitem>
        <listitem>
          <para><emphasis>确保 NIS 主和从服务器的安全，
            并尽可能减少其停机时间</emphasis>。
            如果有人攻入或简单地关闭这些机器，
            则整个实验室的任也就无法登录了。</para>

          <para>这是集中式管理系统中最薄弱的环节。
            如果没有保护好 NIS 服务器， 您就有大批愤怒的用户需要对付了！</para>
        </listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>NIS v1 兼容性</title>

      <para>FreeBSD 的 <application>ypserv</application> 提供了某些为 NIS v1
	客户提供服务的支持能力。 FreeBSD 的 NIS 实现，
	只使用 NIS v2 协议， 但其它实现可能会包含 v1 协议，
	以提供对旧系统的向下兼容能力。 随这些系统提供的
	<application>ypbind</application> 服务将首先尝试绑定 NIS v1
	服务器， 即使它们并不真的需要它 (有些甚至可能会一直广播搜索请求，
	即使已经从某台 v2 服务器得到了回应也是如此)。
	注意， 尽管支持一般的客户机调用， 这个版本的
	<application>ypserv</application> 并不能处理 v1 的映射传送请求；
	因而， 它就不能与较早的支持 v1 协议的 NIS 服务器配合使用，
	无论是作为主服务器还是从服务器。 幸运的是，
	现今应该已经没有仍然在用的这样的服务器了。</para>
    </sect2>

    <sect2 id="network-nis-server-is-client">
      <title>同时作为 NIS 客户机的 NIS 服务器</title>

      <para>在多服务器域的环境中， 如果服务器同时作为 NIS 客户， 在运行
	<application>ypserv</application> 时要特别小心。
	一般来说， 强制服务器绑定自己要比允许它们广播绑定请求要好，
	因为这种情况下它们可能会相互绑定。 某些怪异的故障，
	很可能是由于某一台服务器停机， 而其它服务器都依赖其服务所导致的。
	最终， 所有的客户机都会超时并绑定到其它服务器，
	但这个延迟可能会相当可观，
	而且恢复之后仍然存在再次发生此类问题的隐患。</para>

      <para>您可以强制一台机器绑定到特定的服务器， 这是通过
	<command>ypbind</command> 的 <option>-S</option>
	参数来完成的。 如果不希望每次启动 NIS 服务器时都手工完成这项工作，
	可以在 <filename>/etc/rc.conf</filename> 中加入：</para>

      <programlisting>nis_client_enable="YES"	# run client stuff as well
nis_client_flags="-S <replaceable>NIS domain</replaceable>,<replaceable>server</replaceable>"</programlisting>

      <para>参见 &man.ypbind.8; 以了解更多情况。</para>
    </sect2>

    <sect2>
      <title>口令格式</title>
      <indexterm>
        <primary>NIS</primary>
	<secondary>口令格式</secondary>
      </indexterm>
      <para>在实现 NIS 时， 口令格式的兼容性问题是一种最为常见的问题。
	假如您的 NIS 服务器使用 DES 加密口令， 则它只能支持使用 DES
	的客户机。 例如， 如果您的网络上有
	&solaris; NIS 客户机， 则几乎肯定需要使用 DES 加密口令。</para>

      <para>要检查您的服务器和客户机使用的口令格式，
	需要查看 <filename>/etc/login.conf</filename>。
	如果主机被配置为使用 DES 加密的口令， 则
	<literal>default</literal> class 将包含类似这样的项：</para>

      <programlisting>default:\
	:passwd_format=des:\
	:copyright=/etc/COPYRIGHT:\
	[Further entries elided]</programlisting>

      <para>其他一些可能的 <literal>passwd_format</literal>
	包括 <literal>blf</literal> 和 <literal>md5</literal>
	(分别对应于 Blowfish 和 MD5 加密口令)。</para>

      <para>如果修改了
	<filename>/etc/login.conf</filename>， 就必须重建登录性能数据库，
	这是通过以
	<username>root</username> 身份运行下面的程序来完成的：</para>

      <screen>&prompt.root; <userinput>cap_mkdb /etc/login.conf</userinput></screen>

      <note><para>已经在
	<filename>/etc/master.passwd</filename> 中的口令的格式不会被更新，
	直到用户在登录性能数据库重建
	<emphasis>之后</emphasis> 首次修改口令为止。</para></note>

      <para>接下来， 为了确保所有的口令都按照您选择的格式加密了，
	还需要检查 <filename>/etc/auth.conf</filename>
	中 <literal>crypt_default</literal> 给出的优先选择的口令格式。
	要完成此工作， 将您选择的格式放到列表的第一项。 例如，
	当使用 DES 加密的口令时， 对应项应为：</para>

      <programlisting>crypt_default	=	des blf md5</programlisting>

      <para>在每一台基于 &os; 的 NIS 服务器和客户机上完成上述工作之后，
	就可以肯定您的网络上它们都在使用同样的口令格式了。 如果在 NIS
	客户机上做身份验证时发生问题， 这也是第一个可能出现问题的地方。
	注意： 如果您希望在混合的网络上部署 NIS 服务器，
	可能就需要在所有系统上都使用 DES，
	因为这是所有系统都能够支持的最低限度的公共标准。</para>
    </sect2>
  </sect1>

  <sect1 id="network-dhcp">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Greg</firstname>
      	  <surname>Sutter</surname>
	  <contrib>Written by </contrib>
        </author>
      </authorgroup>
    </sect1info>
    <title>网络自动配置 (DHCP)</title>

    <sect2>
      <title>什么是 DHCP？</title>
      <indexterm>
        <primary>动态主机配置协议</primary>
        <see>DHCP</see>
      </indexterm>
      <indexterm>
        <primary>Internet Software Consortium (ISC)</primary>
      </indexterm>

      <para>DHCP， 动态主机配置协议， 是一种让系统得以连接到网络上，
        并获取所需要的配置参数手段。 FreeBSD 6.0 之前的版本，
	采用的是 ISC (Internet Software
	Consortium) 的 DHCP 客户端 (&man.dhclient.8;) 实现。
	更高版本使用的则是来自 OpenBSD&nbsp;3.7
	的 OpenBSD <command>dhclient</command>。
	这里提供的所有关于 <command>dhclient</command> 的信息，
	都是以 ISC 或 OpenBSD DHCP 客户端程序为准的。 DHCP
	服务器是 ISC 软件包的一部分。</para>
    </sect2>

    <sect2>
      <title>这一节都介绍哪些内容</title>

      <para>这一节描述了 ISC 和 DHCP 系统中的客户端，
	以及和 ISC DHCP 系统中的服务器端的组件。
	客户端程序， <command>dhclient</command>，
	是随 FreeBSD 作为它的一部分提供的； 而服务器部分，
	则可以通过 <filename
	role="package">net/isc-dhcp3-server</filename> port 得到。
	&man.dhclient.8;、 &man.dhcp-options.5;、 以及
	&man.dhclient.conf.5; 联机手册， 加上下面所介绍的参考文献，
	都是非常有用的资源。</para>
    </sect2>

    <sect2>
      <title>它如何工作</title>
      <indexterm><primary>UDP</primary></indexterm>
      <para>当 DHCP 客户程序， <command>dhclient</command>
	在客户机上运行时， 它会开始广播请求配置信息的消息。 默认情况下，
	这些请求是在 UDP 端口 68 上。 服务器通过 UDP 67
	给出响应， 向客户机提供一个 IP 地址， 以及其他有关的配置参数，
	例如子网掩码、 路由器， 以及 DNS 服务器。
	所有这些信息都会以 DHCP
	<quote>lease</quote> 的形式给出， 并且只在一段特定的时间内有效
	(这是由 DHCP 服务器的维护者配置的)。 这样，
	那些已经断开网络的客户机使用的陈旧的 IP 地址就能被自动地回收了。</para>

      <para>DHCP 客户程序可以从服务器端获取大量的信息。
        关于能获得的信息的详细列表， 请参考
        &man.dhcp-options.5;。</para>
    </sect2>

    <sect2>
      <title>FreeBSD 集成</title>

      <para>FreeBSD 完全地集成了 ISC 或 OpenBSD 的 DHCP 客户端，
        <command>dhclient</command> (取决于您运行的 &os; 版本)。
        DHCP 客户端被安装程序直接支持，
        并且是基本系统的一部分。
        这使得您不再需要去了解那些已经运行了 DHCP 服务器的网络的具体配置参数。
        从 FreeBSD 3.2 开始， 每一个发行版中均包含 <command>dhclient</command>。</para>
        <indexterm>
          <primary><application>sysinstall</application></primary>
        </indexterm>

        <para><application>sysinstall</application> 能够支持 DHCP。 在
          <application>sysinstall</application> 中配置网络接口时，
          它询问的第二个问题便是： <quote>Do you want to try DHCP configuration of
          the interface? (您是否希望在此接口上尝试 DHCP 配置?)</quote>。
          如果做肯定的回答， 则将运行 <command>dhclient</command>，
          一旦成功， 则将自动地填写网络配置信息。</para>

        <para>要在系统启动时使用 DHCP， 您必须做两件事：</para>
        <indexterm>
          <primary>DHCP</primary>
          <secondary>需求</secondary>
        </indexterm>
	<itemizedlist>
	  <listitem>
            <para>您的内核中， 必须包含 <devicename>bpf</devicename>
	      设备。 如果需要这样做， 需要将
	      <literal>device bpf</literal> (对于 &os;&nbsp;4.X
	      来说， 则应该是 <literal>pseudo-device
	      bpf</literal>) 添加到内核的编译配置文件中， 并重新编译内核。
	      要了解关于编译内核的进一步信息， 请参见 <xref
	      linkend="kernelconfig">。</para> <para><devicename>bpf</devicename>
	      设备已经是 FreeBSD 发行版中默认的 <filename>GENERIC</filename>
	      内核的一部分了，， 因此如果您没有对内核进行定制，
	      则不用创建一份新的内核配置文件， DHCP 就能工作了。</para>
	    <note>
	      <para>对于那些安全意识很强的人来说，
	        您应该知道 <devicename>bpf</devicename>
	        也是包侦听工具能够正确工作的条件之一 (当然，
	        它们还需要以
		<username>root</username> 身份运行才行)。 <devicename>bpf</devicename>
		<emphasis>是</emphasis> 使用 DHCP 所必须的，
		但如果您对安全非常敏感，
		则很可能会有理由不把 <devicename>bpf</devicename>
		加入到您的内核配置中， 直到您真的需要使用 DHCP
		为止。</para>
	    </note>
	  </listitem>
          <listitem>
            <para>编辑您的 <filename>/etc/rc.conf</filename> 并加入下面的设置：</para>

            <programlisting>ifconfig_fxp0="DHCP"</programlisting>

            <note>
              <para>务必将 <literal>fxp0</literal>
                替换为您希望自动配置的网络接口的名字， 您可以在
		 <xref linkend="config-network-setup"> 找到更进一步的介绍。</para>
            </note>

            <para>如果您希望使用另一位置的
              <command>dhclient</command>，
              或者需要给 <command>dhclient</command> 传递其他参数，
              还可以添加下面的配置 (根据需要进行修改)：</para>

            <programlisting>dhcp_program="/sbin/dhclient"
dhcp_flags=""</programlisting>
          </listitem>
        </itemizedlist>

        <indexterm>
          <primary>DHCP</primary>
          <secondary>服务器</secondary>
        </indexterm>
        <para>DHCP 服务器， <application>dhcpd</application>，
          是作为 <filename
          role="package">net/isc-dhcp3-server</filename> port 的一部分提供的。
          这个 port 包括了 ISC DHCP 服务器及其文档。</para>
    </sect2>

    <sect2>
      <title>文件</title>
      <indexterm>
        <primary>DHCP</primary>
        <secondary>配置文件</secondary>
      </indexterm>
      <itemizedlist>
        <listitem><para><filename>/etc/dhclient.conf</filename></para>
          <para><command>dhclient</command> 需要一个配置文件，
            <filename>/etc/dhclient.conf</filename>。 一般说来，
            这个文件中只包括注释， 而默认值基本上都是合理的。
            这个配置文件在 &man.dhclient.conf.5; 联机手册中进行了进一步的阐述。</para>
        </listitem>

        <listitem><para><filename>/sbin/dhclient</filename></para>
          <para><command>dhclient</command> 是一个静态连编的，
            它被安装到 <filename>/sbin</filename> 中。 &man.dhclient.8;
            联机手册给出了关于
            <command>dhclient</command> 的进一步细节。</para>
        </listitem>

        <listitem><para><filename>/sbin/dhclient-script</filename></para>
          <para><command>dhclient-script</command> 是一个 FreeBSD 专用的
            DHCP 客户端配置脚本。 在
            &man.dhclient-script.8; 中对它进行了描述，
            但一般来说， 用户不需要对其进行任何修改，
            就能够让一切正常运转了。</para>
        </listitem>

        <listitem><para><filename>/var/db/dhclient.leases</filename></para>
          <para>DHCP 客户程序会维护一个数据库来保存有效的 lease，
            它们被以日志的形式保存到这个文件中。 &man.dhclient.leases.5;
            给出了更为细致的介绍。</para>
        </listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>进阶读物</title>

      <para>DHCP 协议的完整描述是
        <ulink url="http://www.freesoft.org/CIE/RFC/2131/">RFC 2131</ulink>。
        关于它的其他信息资源的站点
        <ulink url="http://www.dhcp.org/"></ulink>
        也提供了详尽的资料。</para>
    </sect2>

    <sect2 id="network-dhcp-server">
	<title>安装和配置 DHCP 服务器</title>

	<sect3>
	  <title>这一章包含哪些内容</title>

	  <para>这一章提供了关于如何在 FreeBSD 系统上使用 ISC
	    (Internet 软件协会) 的 DHCP 实现套件来架设 DHCP 服务器的信息。</para>

	  <para>DHCP 套件中的服务器部分并没有作为 FreeBSD 的一部分来提供，
	    因此您需要安装
	    <filename role="package">net/isc-dhcp3-server</filename>
	    port 才能提供这个服务。 请参见 <xref linkend="ports">
	    以了解关于如何使用 Ports Collection 的进一步详情。</para>
	</sect3>

	<sect3>
	  <title>安装 DHCP 服务器</title>
	  <indexterm>
	    <primary>DHCP</primary>
	    <secondary>安装</secondary>
	  </indexterm>
	  <para>为了在您的 FreeBSD 系统上进行配置以便作为 DHCP 服务器来使用，
	    需要把 &man.bpf.4; 设备编译进内核。 要完成这项工作， 需要将
	    <literal>device bpf</literal> (如果使用 &os;&nbsp;4.X 的话， 则写作
	    <literal>pseudo-device bpf</literal>) 加入到您的内核配置文件中，
	    并重新联编内核。 要得到关于如何联编内核的进一步信息， 请参见
	    <xref linkend="kernelconfig">。</para>

	  <para><devicename>bpf</devicename> 设备是 FreeBSD 所附带的
	    <filename>GENERIC</filename> 内核中已经联入的组件，
	    因此您并不需要为了让 DHCP 正常工作而特地定制内核。</para>

	    <note>
	      <para>如果您有较强的安全意识， 应该注意
	        <devicename>bpf</devicename> 同时也是让听包程序能够正确工作的设备
		(尽管这类程序仍然需要以特权用户身份运行)。
		<devicename>bpf</devicename>
		<emphasis>是</emphasis> 使用 DHCP 所必需的，
		但如果您对安全非常敏感， 您可能会不希望将
		<devicename>bpf</devicename> 放进内核，
		直到您真的认为 DHCP 是必需的为止。</para>
	    </note>

	  <para>接下来要做的是编辑示范的
	    <filename>dhcpd.conf</filename>， 它由
	    <filename role="package">net/isc-dhcp3-server</filename> port
	    安装。 默认情况下， 它的名字应该是
	    <filename>/usr/local/etc/dhcpd.conf.sample</filename>，
	    在开始修改之前， 您需要把它复制为
	    <filename>/usr/local/etc/dhcpd.conf</filename>。</para>
	</sect3>

	<sect3>
	  <title>配置 DHCP 服务器</title>
	  <indexterm>
	    <primary>DHCP</primary>
	    <secondary>dhcpd.conf</secondary>
	  </indexterm>
	  <para><filename>dhcpd.conf</filename> 包含了一系列关于子网和主机的定义，
	    下面的例子可以帮助您理解它：</para>

	  <programlisting>option domain-name "example.com";<co id="domain-name">
option domain-name-servers 192.168.4.100;<co id="domain-name-servers">
option subnet-mask 255.255.255.0;<co id="subnet-mask">

default-lease-time 3600;<co id="default-lease-time">
max-lease-time 86400;<co id="max-lease-time">
ddns-update-style none;<co id="ddns-update-style">

subnet 192.168.4.0 netmask 255.255.255.0 {
  range 192.168.4.129 192.168.4.254;<co id="range">
  option routers 192.168.4.1;<co id="routers">
}

host mailhost {
  hardware ethernet 02:03:04:05:06:07;<co id="hardware">
  fixed-address mailhost.example.com;<co id="fixed-address">
}</programlisting>

	  <calloutlist>
	    <callout arearefs="domain-name">
	      <para>这个选项指定了提供给客户机作为默认搜索域的域名。 请参考
		&man.resolv.conf.5; 以了解关于这一概念的详情。</para>
	    </callout>

	    <callout arearefs="domain-name-servers">
	      <para>这个选项用于指定一组客户机使用的 DNS 服务器，
		它们之间以逗号分隔。</para>
	    </callout>

	    <callout arearefs="subnet-mask">
	      <para>提供给客户机的子网掩码。</para>
	    </callout>

	    <callout arearefs="default-lease-time">
	      <para>客户机可以请求租约的有效期， 而如果没有，
		则服务器将指定一个租约有效期， 也就是这个值 (单位是秒)。</para>
	    </callout>

	    <callout arearefs="max-lease-time">
	      <para>这是服务器允许租出地址的最大时长。
		如果客户机请求了更长的租期， 则它将得到一个地址，
		但其租期仅限于 <literal>max-lease-time</literal> 秒。</para>
	    </callout>

	    <callout arearefs="ddns-update-style">
	      <para>这个选项用于指定 DHCP 服务器在一个地址被接受或释放时是否应对应尝试更新
		DNS。 在 ISC 实现中， 这一选项是 <emphasis>必须指定的</emphasis>。</para>
	    </callout>

	    <callout arearefs="range">
	      <para>指定地址池中可以用来分配给客户机的 IP 地址范围。
		在这个范围之间， 以及其边界的 IP 地址将分配给客户机。</para>
	    </callout>

	    <callout arearefs="routers">
	      <para>定义客户机的默认网关。</para>
	    </callout>

	    <callout arearefs="hardware">
	      <para>主机的硬件 MAC 地址 (这样 DHCP
		服务器就能够在接到请求时知道请求的主机身份)。</para>
	    </callout>

	    <callout arearefs="fixed-address">
	      <para>指定总是得到同一 IP 地址的主机。
		请注意在此处使用主机名是对的， 因为 DHCP 
		服务器会在返回租借地址信息之前自行解析主机名。</para>
	    </callout>
	  </calloutlist>

	  <para>一旦您撰写完
	    <filename>dhcpd.conf</filename>， 就可以用下面的命令来启动服务：</para>

	  <screen>&prompt.root; <userinput>/usr/local/etc/rc.d/isc-dhcpd.sh start</userinput></screen>

	  <para>如果未来您需要修改服务器的配置， 请务必牢记发送
	    <literal>SIGHUP</literal> 信号给
	    <application>dhcpd</application> 并 <emphasis>不会</emphasis>
	    导致配置文件的重新加载， 而这在其他服务程序中则是比较普遍的约定。
	    您需要发送 <literal>SIGTERM</literal> 信号来停止进程，
	    然后使用上面的命令来重新启动它。</para>
	</sect3>

	<sect3>
	  <title>文件</title>
	  <indexterm>
	    <primary>DHCP</primary>
	    <secondary>配置文件</secondary>
	  </indexterm>
	  <itemizedlist>
	    <listitem><para><filename>/usr/local/sbin/dhcpd</filename></para>
	      <para><application>dhcpd</application> 是静态连接的， 并安装到
		<filename>/usr/local/sbin</filename> 中。 随 port 安装的
		&man.dhcpd.8; 联机手册提供了关于
		<application>dhcpd</application> 更为详尽的信息。</para>
	    </listitem>

	    <listitem><para><filename>/usr/local/etc/dhcpd.conf</filename></para>
	      <para><application>dhcpd</application> 需要配置文件，
		即 <filename>/usr/local/etc/dhcpd.conf</filename>
		才能够向客户机提供服务。 这个文件需要包括应提供给客户机的所有信息，
		以及关于服务器运行的其他信息。 此配置文件的详细描述可以在随 port
		安装的 &man.dhcpd.conf.5; 联机手册上找到。</para>
	    </listitem>

	    <listitem><para><filename>/var/db/dhcpd.leases</filename></para>
	      <para>DHCP 服务器会维护一个它签发的租用地址数据库，
		并保存在这个文件中， 这个文件是以日志的形式保存的。
		随 port 安装的
		&man.dhcpd.leases.5; 联机手册提供了更详细的描述。</para>
	    </listitem>

	    <listitem><para><filename>/usr/local/sbin/dhcrelay</filename></para>
	      <para><application>dhcrelay</application> 在更为复杂的环境中，
		可以用来支持使用 DHCP 服务器转发请求给另一个独立网络上的
		DHCP 服务器。 如果您需要这个功能， 需要安装 <filename
		role="package">net/isc-dhcp3-relay</filename> port。
		&man.dhcrelay.8; 联机手册提供了更为详尽的介绍。</para>
	    </listitem>
	  </itemizedlist>
	</sect3>

      </sect2>

  </sect1>

  <sect1 id="network-dns">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Chern</firstname>
          <surname>Lee</surname>
          <contrib>Contributed by </contrib>
        </author>
      </authorgroup>
    </sect1info>
    <title>域名系统 (DNS)</title>

    <sect2>
      <title>纵览</title>
      <indexterm><primary>BIND</primary></indexterm>

      <para>FreeBSD 在默认情况下使用一个版本的 BIND (Berkeley
        Internet Name Domain)， 这是目前最为流行的 DNS 协议实现。
        DNS 是一种协议， 可以通过它将域名同 IP 地址相互对应。
        例如， 查询 <hostid role="fqdn">www.FreeBSD.org</hostid>
        将得到 FreeBSD Project 的 web 服务器的 IP 地址， 而查询 <hostid
        role="fqdn">ftp.FreeBSD.org</hostid> 则将得到响应的 FTP 机器的
        IP 地址。 类似地， 也可以做相反的事情。 查询 IP
        地址可以得到其主机名。 当然， 完成 DNS
        查询并不需要在系统中运行域名服务器。
      </para>

      <indexterm><primary>DNS</primary></indexterm>
      <para>DNS 在 Internet 上通过一组略显复杂的权威根域名服务器来组织，
        它的其余部分则由较小规模的域名服务器组成，
        这些服务器提供少量的域名解析服务， 并对域名信息进行缓存。
      </para>

      <para>
        这份文档介绍的是 BIND 8.x， 因为它是 &os; 中使用的稳定版本。
	&os;&nbsp;5.3 以及更高版本则包含了
	<acronym>BIND</acronym>9 及其配置的说明可以在这一章的后一部分找到。
	使用 &os;&nbsp;5.2 以及更早版本的用户，
	可以通过 <filename role="package">net/bind9</filename> port
	来安装 <acronym>BIND</acronym>9。</para>

      <para>
        RFC1034 和 RFC1035 定义了 DNS 协议。
      </para>

      <para>
        目前， BIND 由
        Internet Software Consortium <ulink url="http://www.isc.org/"></ulink>
        维护。
      </para>
    </sect2>

    <sect2>
      <title>术语</title>

      <para>要理解这份文档， 需要首先了解一些相关的 DNS 术语。</para>

      <indexterm><primary>解析器 (resolver)</primary></indexterm>
      <indexterm><primary>反向 DNS (reverse DNS)</primary></indexterm>
      <indexterm><primary>根域 (root zone)</primary></indexterm>
      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <colspec colwidth="1*">
	  <colspec colwidth="3*">

	  <thead>
	    <row>
	      <entry>术语</entry>
	      <entry>定义</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>正向 DNS (Forward DNS)</entry>
	      <entry>将域名映射到 IP 地址</entry>
	    </row>

	    <row>
	      <entry>原点 (Origin)</entry>
	      <entry>表示特定域文件所在的域</entry>
	    </row>

	    <row>
	      <entry><application>named</application>, BIND, 域名服务器(name server)</entry>
	      <entry>在 FreeBSD 中 BIND 域名服务器软件包的常见叫法</entry>
	    </row>

	    <row>
	      <entry>解析器 (Resolver)</entry>
	      <entry>计算机用以向域名服务器查询域名信息的一个系统进程</entry>
	    </row>

	    <row>
	      <entry>反向 DNS (Reverse DNS)</entry>
	      <entry>与正向 DNS 相对； 将 IP 地址映射为主机名</entry>
	    </row>

	    <row>
	      <entry>根域</entry>

	      <entry>Internet 域层次的起点。 所有的域都在根域之下，
		类似文件系统中， 文件都在根目录之下那样。</entry>
	    </row>

	    <row>
	      <entry>域 (Zone)</entry>
	      <entry>独立的域， 子域， 或者由同一机构管理的 DNS 的一部分。</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <indexterm>
	<primary>域</primary>
	<secondary>例子</secondary>
      </indexterm>

      <para>域的例子：
      </para>
      <itemizedlist>
        <listitem>
          <para><hostid>.</hostid> 是根域。</para>
        </listitem>
        <listitem>
          <para><hostid>org.</hostid> 是一个根域下的域。</para>
        </listitem>
        <listitem>
          <para><hostid role="domainname">example.org.</hostid> 是
          <hostid>org.</hostid> 之下的域。</para>
        </listitem>
        <listitem>
          <para><hostid role="domainname">foo.example.org.</hostid> 是
            <hostid role="domainname">example.org.</hostid> 域的子域。</para>
        </listitem>
        <listitem>
          <para>
            <hostid>1.2.3.in-addr.arpa</hostid> 是用于表达 <hostid
	    role="ipaddr">3.2.1.*</hostid> IP 地址空间之下所有
	    IP 地址的域。
          </para>
        </listitem>
      </itemizedlist>

      <para>如您所见， 域名中最细节的部分在它的左边。
        举例来说， <hostid
        role="domainname">example.org.</hostid> 要比
        <hostid>org.</hostid> 更小， 就像 <hostid>org.</hostid>
        要比根域更小一样。 主机名的格局和文件系统类似：
        <filename>/dev</filename> 目录在根目录中， 等等。</para>


    </sect2>

    <sect2>
      <title>运行域名服务器的理由</title>

      <para>域名服务器通常会有两种形式： 权威域名服务器，
	以及缓存域名服务器。</para>

      <para>下列情况需要有权威域名服务器：</para>

      <itemizedlist>
	<listitem>
	  <para>想要向全世界提供 DNS 信息，
	    并对请求给出权威应答。</para>
	</listitem>
	<listitem>
	  <para>注册了类似 <hostid role="domainname">example.org</hostid>
	    的域， 而需要将 IP 指定到其下的主机名上。</para>
	</listitem>
	<listitem>
	  <para>某个 IP 地址块需要反向 DNS 项 (IP 到主机名)。</para>
	</listitem>
	<listitem>
	  <para>需要备份服务器， 或常说的从 (slave) 服务器，
	    在主服务器出现问题或无法访问时来应答查询请求。</para>
	  </listitem>
      </itemizedlist>

      <para>下列情况需要有缓存域名服务器：</para>

      <itemizedlist>
	<listitem>
	  <para>本地的 DNS 服务器能够缓存，
	    并比直接向外界的域名服务器请求更快地得到应答。</para>
	</listitem>
	<listitem>
	  <para>减少所需的总体网络流量 (DNS
	    流量通常占全部 Internet 流量的 5% 或更多)。</para>
	</listitem>
      </itemizedlist>

      <para>当有人查询 <hostid
	role="fqdn">www.FreeBSD.org</hostid> 时，解析器通常会向上级
	ISP 的域名服务器发出请求， 并获得回应。 如果有本地的缓存 DNS
	服务器， 查询只有在第一次被缓存 DNS 服务器发到外部世界。
	其他的查询不会发向局域网外， 因为它们已经有在本地的缓存了。</para>

    </sect2>

    <sect2>
      <title>DNS 如何运作</title>
      <para>在 FreeBSD 中， BIND 服务程序被称为
	<application>named</application>， 其原因显而易见。</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>文件</entry>
	      <entry>描述</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><application>named</application></entry>
	      <entry>BIND 服务程序</entry>
	    </row>

	    <row>
	      <entry><command>ndc</command></entry>
	      <entry>域名服务控制程序</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/namedb</filename></entry>
	      <entry>BIND 存放域名信息的位置</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/namedb/named.conf</filename></entry>
	      <entry>域名服务配置文件</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>
        域文件通常被放在
        <filename>/etc/namedb</filename>
        目录中， 它们包含域名服务器所提供的 DNS 域的信息。
      </para>
    </sect2>

    <sect2>
      <title>启动 BIND</title>
      <indexterm>
        <primary>BIND</primary>
	<secondary>启动</secondary>
      </indexterm>
      <para>
        由于 BIND 会在默认情况下安装， 因此配置它相对而言很简单。
      </para>
      <para>
        要确保 <application>named</application> 服务程序在引导时被自动启动，
         把下面的行加到 <filename>/etc/rc.conf</filename> 中：
      </para>
      <programlisting>named_enable="YES"</programlisting>
      <para>要手工启动服务 (在完成配置之后)：</para>
      <screen>&prompt.root; <userinput>ndc start</userinput></screen>
    </sect2>

    <sect2>
      <title>配置文件</title>
      <indexterm>
        <primary>BIND</primary>
	<secondary>配置文件</secondary>
      </indexterm>
      <sect3>
        <title>使用 <command>make-localhost</command></title>
        <para>一定要：
        </para>
        <screen>&prompt.root; <userinput>cd /etc/namedb</userinput>
&prompt.root; <userinput>sh make-localhost</userinput></screen>
        <para>以便创建正确的本地 DNS 反向解析域文件
          <filename>/etc/namedb/master/localhost.rev</filename>.
        </para>
      </sect3>

      <sect3>
        <title><filename>/etc/namedb/named.conf</filename></title>

        <programlisting>// &dollar;FreeBSD$
//
// Refer to the named(8) manual page for details.  If you are ever going
// to setup a primary server, make sure you've understood the hairy
// details of how DNS is working.  Even with simple mistakes, you can
// break connectivity for affected parties, or cause huge amount of
// useless Internet traffic.

options {
        directory "/etc/namedb";

// In addition to the "forwarders" clause, you can force your name
// server to never initiate queries of its own, but always ask its
// forwarders only, by enabling the following line:
//
//      forward only;

// If you've got a DNS server around at your upstream provider, enter
// its IP address here, and enable the line below.  This will make you
// benefit from its cache, thus reduce overall DNS traffic in the
Internet.
/*
        forwarders {
                127.0.0.1;
        };
*/</programlisting>

        <para>
	  如注视所说， 要从上级的缓存中受益， 可以在此处启用
          <literal>forwarders</literal>。 在一般情况下， 域名服务器会逐级地查询
          Internet 来找到特定的域名服务器， 直到得到答案为止。
          启用这个将让它首先查询上级域名服务器 (或另外提供的域名服务器)，
          从而从它们的缓存中得到结果。 如果上级域名服务器的负载很重，
          在更快的域名服务器上启用它将有助于改善服务品质。
        </para>

	<warning><para><hostid role="ipaddr">127.0.0.1</hostid>
            <emphasis>不会</emphasis> 正常工作。
            一定要把地址改为您上级服务器的 IP 地址。</para>
        </warning>

        <programlisting>        /*
         * If there is a firewall between you and name servers you want
         * to talk to, you might need to uncomment the query-source
         * directive below.  Previous versions of BIND always asked
         * questions using port 53, but BIND 8.1 uses an unprivileged
         * port by default.
         */
        // query-source address * port 53;

        /*
         * If running in a sandbox, you may have to specify a different
         * location for the dumpfile.
         */
        // dump-file "s/named_dump.db";
};

// Note: the following will be supported in a future release.
/*
host { any; } {
        topology {
                127.0.0.0/8;
        };
};
*/

// Setting up secondaries is way easier and the rough picture for this
// is explained below.
//
// If you enable a local name server, don't forget to enter 127.0.0.1
// into your /etc/resolv.conf so this server will be queried first.
// Also, make sure to enable it in /etc/rc.conf.

zone "." {
        type hint;
        file "named.root";
};

zone "0.0.127.IN-ADDR.ARPA" {
        type master;
        file "localhost.rev";
};

zone
"0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.IP6.INT" {
        type master;
        file "localhost.rev";
};

// NB: Do not use the IP addresses below, they are faked, and only
// serve demonstration/documentation purposes!
//
// Example secondary config entries.  It can be convenient to become
// a secondary at least for the zone where your own domain is in.  Ask
// your network administrator for the IP address of the responsible
// primary.
//
// Never forget to include the reverse lookup (IN-ADDR.ARPA) zone!
// (This is the first bytes of the respective IP address, in reverse
// order, with ".IN-ADDR.ARPA" appended.)
//
// Before starting to setup a primary zone, better make sure you fully
// understand how DNS and BIND works, however.  There are sometimes
// unobvious pitfalls.  Setting up a secondary is comparably simpler.
//
// NB: Don't blindly enable the examples below. :-)  Use actual names
// and addresses instead.
//
// NOTE!!! FreeBSD runs BIND in a sandbox (see named_flags in rc.conf).
// The directory containing the secondary zones must be write accessible
// to BIND.  The following sequence is suggested:
//
//      mkdir /etc/namedb/s
//      chown bind:bind /etc/namedb/s
//      chmod 750 /etc/namedb/s</programlisting>

	<para>For more information on running BIND in a sandbox, see
	  <link linkend="network-named-sandbox">Running named in a sandbox</link>.
	</para>

	<programlisting>/*
zone "example.com" {
        type slave;
        file "s/example.com.bak";
        masters {
                192.168.1.1;
        };
};

zone "0.168.192.in-addr.arpa" {
        type slave;
        file "s/0.168.192.in-addr.arpa.bak";
        masters {
                192.168.1.1;
        };
};
*/</programlisting>
        <para>在 <filename>named.conf</filename> 中， 这是一些转发用的从域以及反向域的例子。</para>

        <para>对于每一个新域， 域对应的项必须加到
	  <filename>named.conf</filename> 中。</para>

        <para>例如， 最简单的用于
	  <hostid role="domainname">example.org</hostid> 域的条目类似下面的样子：</para>

        <programlisting>zone "example.org" {
	type master;
	file "example.org";
};</programlisting>

	<para>这是一个主域， 它由 <option>type</option> 语句标识出来，
	  而信息则在
	  <filename>/etc/namedb/example.org</filename> 域文件中，
	  这是由 <option>file</option> 语句指定的。</para>

        <programlisting>zone "example.org" {
	type slave;
	file "example.org";
};</programlisting>

        <para>在从域的例子中， 域的信息从该域的某个主服务器传送过来，
	  并保存在指定的文件中。 如果主服务器死掉了或不可达，
	  从域名服务器将使用这些传过来的域信息， 从而完成应答。</para>
      </sect3>

      <sect3>
        <title>域信息文件</title>
        <para>
          以下是一个用于 <hostid
	  role="domainname">example.org</hostid> 域的主域文件 (保存为
	  <filename>/etc/namedb/example.org</filename>)：
        </para>

        <programlisting>$TTL 3600

example.org. IN SOA ns1.example.org. admin.example.org. (
                        5               ; Serial
                        10800           ; Refresh
                        3600            ; Retry
                        604800          ; Expire
                        86400 )         ; Minimum TTL

; DNS Servers
@       IN NS           ns1.example.org.
@       IN NS           ns2.example.org.

; Machine Names
localhost       IN A    127.0.0.1
ns1             IN A    3.2.1.2
ns2             IN A    3.2.1.3
mail            IN A    3.2.1.10
@               IN A    3.2.1.30

; Aliases
www             IN CNAME        @

; MX Record
@               IN MX   10      mail.example.org.</programlisting>

        <para>
          请注意以 <quote>.</quote> 结尾的主机名是全称主机名， 而结尾没有
          <quote>.</quote> 的则是相对于原点的主机名。 例如，
          <literal>www</literal> 将被转换为
          <literal>www.<replaceable>原点</replaceable></literal>.
          在这个假想的域信息文件中， 我们的原点是
          <hostid>example.org.</hostid>， 因此 <literal>www</literal>
          将被当作 <hostid>www.example.org.</hostid>。
        </para>

        <para>
          域信息文件的格式如下：
        </para>
        <programlisting>记录名          IN 记录类型     值</programlisting>

	<indexterm>
	  <primary>DNS</primary>
	  <secondary>记录</secondary>
	</indexterm>
        <para>
          最常用的 DNS 记录：
        </para>

	<variablelist>
	  <varlistentry>
	    <term>SOA</term>

	    <listitem><para>域权威开始</para></listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>NS</term>

	    <listitem><para>权威域名服务器</para></listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>A</term>

	    <listitem><para>主机地址</para></listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>CNAME</term>

	    <listitem><para>别名对应的正规名称</para></listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>MX</term>

	    <listitem><para>邮件传递服务器</para></listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>PTR</term>

	    <listitem><para>域名指针 (用于反向 DNS)
	      </para></listitem>
	  </varlistentry>
	</variablelist>

        <programlisting>
example.org. IN SOA ns1.example.org. admin.example.org. (
                        5               ; Serial
                        10800           ; Refresh after 3 hours
                        3600            ; Retry after 1 hour
                        604800          ; Expire after 1 week
                        86400 )         ; Minimum TTL of 1 day</programlisting>



	<variablelist>
	  <varlistentry>
	    <term><hostid role="domainname">example.org.</hostid></term>

	    <listitem><para>域名， 同时也是这个域信息文件的原点。</para></listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><hostid role="fqdn">ns1.example.org.</hostid></term>

	    <listitem><para>该域的主/权威域名服务器。</para></listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><literal>admin.example.org.</literal></term>

	    <listitem><para>此域的负责人的电子邮件地址，
		其中 <quote>@</quote> 被换掉了。
          (<email>admin@example.org</email> 对应
		<literal>admin.example.org</literal>)</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><literal>5</literal></term>

	      <listitem><para>文件的序号。 每次修改域文件时都必须增加这个数字。
		  现今， 许多管理员会考虑使用
		  <literal>yyyymmddrr</literal> 这样的格式来表示序号。
		  <literal>2001041002</literal> 通常表示上次修改于
		  04/10/2001， 而后面的
		  <literal>02</literal> 则表示在那天的第几次修改。
		  序号非常重要， 它用于通知从域服务器更新数据。</para>
	      </listitem>
	  </varlistentry>
	</variablelist>

        <programlisting>
@       IN NS           ns1.example.org.</programlisting>

        <para>
          这是一个 NS 项。 每个准备提供权威应答的服务器都必须有一个对应项。
	  这里的 <literal>@</literal> 表示
	  <hostid role="domainname">example.org.</hostid>。
	  <literal>@</literal> 会被理解为原点。
        </para>

        <programlisting>
localhost       IN A    127.0.0.1
ns1             IN A    3.2.1.2
ns2             IN A    3.2.1.3
mail            IN A    3.2.1.10
@               IN A    3.2.1.30</programlisting>

        <para>
          A 记录代表及其名。 如上面看到的，
          <hostid role="fqdn">ns1.example.org</hostid> 将解析为
          <hostid role="ipaddr">3.2.1.2</hostid>。 在此再次使用了原点符，
          <literal>@</literal>， 它表示
          <hostid role="domainname">example.org</hostid> 应解析为
          <hostid role="ipaddr">3.2.1.30</hostid>。
        </para>

        <programlisting>
www             IN CNAME        @</programlisting>

        <para>
          正规名记录通常用于对某台机器的别名给出对应的正式名字。
          在这个例子中， <hostid>www</hostid> 是名字为原点， 或者说
          <hostid role="domainname">example.org</hostid>
          (<hostid role="ipaddr">3.2.1.30</hostid>) 那台机器的别名。
          CNAMEs 可以用来提供主机的别名， 或将同一名字在多台机器上作轮询。
        </para>

	<indexterm>
	  <primary>MX 记录</primary>
	</indexterm>

        <programlisting>
@               IN MX   10      mail.example.org.</programlisting>

        <para>
          MX 记录表示哪个邮件服务器负责接收发到这个域的邮件。
          <hostid role="fqdn">mail.example.org</hostid> 是邮件服务器的主机名，
          而 10 则是它的优先级。
        </para>

        <para>
          可以有多台邮件服务器， 其优先级分别是 3, 2,
          1。 向 <hostid
          role="domainname">example.org</hostid> 进行投递的邮件服务器首先会尝试优先级最高
          (数字最小) 的 MX， 然后是较低优先级的， 等等， 直到成功地投递了邮件为止。
        </para>

        <para>
          对于 in-addr.arpa 域名信息文件 (反向 DNS)， 使用了同样的格式，
          只是 PTR 项代替了 A 或 CNAME 的位置。
        </para>

        <programlisting>$TTL 3600

1.2.3.in-addr.arpa. IN SOA ns1.example.org. admin.example.org. (
                        5               ; Serial
                        10800           ; Refresh
                        3600            ; Retry
                        604800          ; Expire
                        3600 )          ; Minimum

@       IN NS   ns1.example.org.
@       IN NS   ns2.example.org.

2       IN PTR  ns1.example.org.
3       IN PTR  ns2.example.org.
10      IN PTR  mail.example.org.
30      IN PTR  example.org.</programlisting>

        <para>这个文件给出了上述假想域中 IP 地址到域名的映射关系。</para>
      </sect3>
    </sect2>

    <sect2>
      <title>缓存域名服务器</title>
      <indexterm>
        <primary>BIND</primary>
        <secondary>缓存域名服务器</secondary>
      </indexterm>

      <para>缓存域名服务器是对任何域都不提供权威解析的域名服务器。
        它自己简单地完成查询， 并记住这些查询以备后续使用。
        要建立这样的服务器， 只需像平时一样配置一个域名服务器，
        而不配置域就可以了。</para>
    </sect2>

    <sect2 id="network-named-sandbox">
      <title>在沙盒中运行 <application>named</application></title>
      <indexterm>
        <primary>BIND</primary>
        <secondary>在沙盒中运行</secondary>
      </indexterm>

      <indexterm>
        <primary><command>chroot</command></primary>
      </indexterm>
      <para>要更安全地运行 &man.named.8;， 应该以非特权用户来运行它，
	并配置为 &man.chroot.8; 到一个沙盒目录中。
	这使得 <application>named</application> 服务无法访问任何沙盒外面的东西。
	假如 <application>named</application> 被攻破，
	这将减少它所能带来的破坏。 默认情况下， FreeBSD 提供了名为
	<groupname>bind</groupname> 的用户和组来完成这样的目的。</para>

      <note><para>许多人建议不这样做， 而
	<application>named</application> 配置为 <command>chroot</command>，
	您应该在一个 &man.jail.8; 中运行 <application>named</application>。
	这一节并不涵盖这种情形。</para>
      </note>

      <para>由于 <application>named</application> 没有办法访问沙盒外面的任何东西
	(例如共享库， 日志 socket 等等)， 您需要做许多事情来让
	<application>named</application> 正常工作。 下面的清单假定沙盒是
	<filename>/etc/namedb</filename> 而您没有事先改过这个目录中的内容。
	以 <username>root</username> 的身份完成下列步骤：</para>

      <itemizedlist>
	<listitem>
	  <para>创建 <application>named</application>
	    需要访问的所有目录：</para>

	  <screen>&prompt.root; <userinput>cd /etc/namedb</userinput>
&prompt.root; <userinput>mkdir -p bin dev etc var/tmp var/run master slave</userinput>
&prompt.root; <userinput>chown bind:bind slave var/*</userinput><co id="chown-slave"></screen>



	  <calloutlist>
	    <callout arearefs="chown-slave">
	      <para><application>named</application> 只需要写这些目录，
		这也是我们赋予它的全部权限。</para>
	    </callout>
	  </calloutlist>
	</listitem>

	<listitem>
	  <para>重新组织基本的域和配置文件：</para>
	  <screen>&prompt.root; <userinput>cp /etc/localtime etc</userinput><co id="localtime">
&prompt.root; <userinput>mv named.conf etc && ln -sf etc/named.conf</userinput>
&prompt.root; <userinput>mv named.root master</userinput>
<!-- I don't like this next bit -->
&prompt.root; <userinput>sh make-localhost</userinput>
&prompt.root; <userinput>cat > master/named.localhost
$ORIGIN localhost.
$TTL 6h
@	IN	SOA	localhost. postmaster.localhost. (
			1	; serial
			3600	; refresh
			1800	; retry
			604800	; expiration
			3600 )	; minimum
	IN	NS	localhost.
	IN	A		127.0.0.1
^D</userinput></screen>

	  <calloutlist>
	    <callout arearefs="localtime">
	      <para>这使得 <application>named</application> 能够将正确的时间传递给
		&man.syslogd.8;。</para>
	    </callout>
	  </calloutlist>
	</listitem>

	<listitem>

        <indexterm><primary>syslog</primary></indexterm>
        <indexterm><primary>日志文件</primary>
	  <secondary>named</secondary></indexterm>

	  <para>如果您在运行 &os; 在 4.9-RELEASE 之前的版本， 需要联编一个静态连接的
	    <application>named-xfer</application>， 并将其复制到沙盒中：</para>

	      <screen>&prompt.root; <userinput>cd /usr/src/lib/libisc</userinput>
&prompt.root; <userinput>make cleandir && make cleandir && make depend && make all</userinput>
&prompt.root; <userinput>cd /usr/src/lib/libbind</userinput>
&prompt.root; <userinput>make cleandir && make cleandir && make depend && make all</userinput>
&prompt.root; <userinput>cd /usr/src/libexec/named-xfer</userinput>
&prompt.root; <userinput>make cleandir && make cleandir && make depend && make NOSHARED=yes all</userinput>
&prompt.root; <userinput>cp named-xfer /etc/namedb/bin && chmod 555 /etc/namedb/bin/named-xfer</userinput><co id="clean-cruft"></screen>

	  <para>在把静态连接的
	    <command>named-xfer</command> 装好之后需要清理一下，
	    以免将过时的库或程序留在您的源代码副本中：</para>

	  <screen>&prompt.root; <userinput>cd /usr/src/lib/libisc</userinput>
&prompt.root; <userinput>make cleandir</userinput>
&prompt.root; <userinput>cd /usr/src/lib/libbind</userinput>
&prompt.root; <userinput>make cleandir</userinput>
&prompt.root; <userinput>cd /usr/src/libexec/named-xfer</userinput>
&prompt.root; <userinput>make cleandir</userinput></screen>

	  <calloutlist>
	    <callout arearefs="clean-cruft">
	      <para>据说这一步有时会失败。 如果您遇到这样的问题， 执行下面的命令：</para>

	      <screen>&prompt.root; <userinput>cd /usr/src && make cleandir && make cleandir</userinput></screen>

	      <para>并删除 <filename>/usr/obj</filename> 目录：</para>

	      <screen>&prompt.root; <userinput>rm -fr /usr/obj && mkdir /usr/obj</userinput></screen>

		<para>这将把任何 <quote>垃圾</quote> 从您的源代码目录中删除，
		  而后续工作将得以正常进行。</para>
	    </callout>
	  </calloutlist>

	  <para>如果您运行 &os; 的 4.9-RELEASE 或更新的版本， 则默认情况下
	    <filename>/usr/libexec</filename> 中的 <command>named-xfer</command>
	    副本已经是静态连接的了。 您可以简单地把它用 &man.cp.1; 复制到沙盒中。</para>
	</listitem>

	<listitem>
	  <para>做一个 <application>named</application>
	    能够看到并写入的 <filename>dev/null</filename>：</para>

	  <screen>&prompt.root; <userinput>cd /etc/namedb/dev && mknod null c 2 2</userinput>
&prompt.root; <userinput>chmod 666 null</userinput></screen>
	</listitem>

	<listitem>
	  <para>将 <filename>/var/run/ndc</filename> 符号链接到
	    <filename>/etc/namedb/var/run/ndc</filename>：</para>

	  <screen>&prompt.root; <userinput>ln -sf /etc/namedb/var/run/ndc /var/run/ndc</userinput></screen>

	  <note>
	    <para>这个非常简单的措施有效地避免了您每次都必须指定
	      <option>-c</option> 参数来启动 &man.ndc.8; 的麻烦。 由于
	      <filename>/var/run</filename> 中的内容会在启动时被删除，
	      把上述命令加入到
	      <username>root</username> 的 &man.crontab.5; 中， 并指定
	      <option>@reboot</option> 选项会很有用。</para>
	  </note>

	</listitem>

	<listitem>

        <indexterm><primary>syslog</primary></indexterm>
        <indexterm><primary>日志文件</primary>
	  <secondary>named</secondary></indexterm>

	  <para>配置 &man.syslogd.8; 来创建一个 <application>named</application>
	    可以写的 <devicename>log</devicename> socket。 要完成它， 需要将
	    <literal>-l /etc/namedb/dev/log</literal> 加到
	    <filename>/etc/rc.conf</filename> 的
	    <varname>syslogd_flags</varname> 变量中。</para>
	</listitem>

	<listitem>

          <indexterm><primary><command>chroot</command></primary></indexterm>

	  <para>启动 <application>named</application> 并让它自动地把自己
	    <command>chroot</command> 到沙盒中， 方法是把下面的内容加到
	    <filename>/etc/rc.conf</filename>：</para>

	  <programlisting>named_enable="YES"
named_flags="-u bind -g bind -t /etc/namedb /etc/named.conf"</programlisting>

	  <note>
	    <para>请注意配置文件
	    <replaceable>/etc/named.conf</replaceable> 是以
	    <emphasis>相对于沙盒</emphasis> 的完整路径来指定的，
	    例如上面那一行， 文件所在的目录实际上是
	    <filename>/etc/namedb/etc/named.conf</filename>。</para>
	  </note>
	</listitem>
      </itemizedlist>

      <para>下一步是编辑
	<filename>/etc/namedb/etc/named.conf</filename> 让
	<application>named</application> 直到需要加载哪些域，
	以及它们在磁盘上的位置。 您可以用注释掉的那个例子
	(没有明确地注释掉的哪些和不在沙盒中运行 DNS 服务器时的配置无异)：</para>

	<programlisting>options {
        directory "/";<co id="directory">
        named-xfer "/bin/named-xfer";<co id="named-xfer">
        version "";		// Don't reveal BIND version
        query-source address * port 53;
};
// ndc control socket
controls {
        unix "/var/run/ndc" perm 0600 owner 0 group 0;
};
// Zones follow:
zone "localhost" IN {
        type master;
        file "master/named.localhost";<co id="master">
        allow-transfer { localhost; };
        notify no;
};
zone "0.0.127.in-addr.arpa" IN {
        type master;
        file "master/localhost.rev";
        allow-transfer { localhost; };
        notify no;
};
zone "0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.int" {
	type master;
	file "master/localhost-v6.rev";
	allow-transfer { localhost; };
	notify no;
};
zone "." IN {
        type hint;
        file "master/named.root";
};
zone "private.example.net" in {
        type master;
        file "master/private.example.net.db";
	allow-transfer { 192.168.10.0/24; };
};
zone "10.168.192.in-addr.arpa" in {
        type slave;
        masters { 192.168.10.2; };
        file "slave/192.168.10.db";<co id="slave">
};</programlisting>

      <calloutlist>
	<callout arearefs="directory">
	  <para>
	    <literal>directory</literal> 语句被指定为
	    <filename>/</filename>， 因为所有的
	    <application>named</application> 需要在这个文件中
	    (这相当于在 <quote>普通</quote> 模式下运行时的
	    <filename>/etc/namedb</filename>)。</para>
	</callout>

	<callout arearefs="named-xfer">
	  <para>指定到 <command>named-xfer</command> 执行文件的完整路径 (相对
	    <application>named</application> 的参照系)。 这是必须的步骤，
	    因为 <application>named</application> 在默认情况下会从
	    <filename>/usr/libexec</filename> 查找 <command>named-xfer</command>。</para>
	</callout>
	<callout arearefs="master"><para>指定文件名 (相对于前面的
	  <literal>directory</literal> 语句指定的目录)， 
	  <application>named</application> 将在这里查找域信息文件。</para>
	</callout>
	<callout arearefs="slave"><para>指定文件名 (相对于前面的
	    <literal>directory</literal> 语句指定的目录)， 
	    <application>named</application> 将在这里写入成功地从主服务器拿到的域信息文件副本。
	    这使为什么我们在前面的步骤中将 <filename>slave</filename> 的属主改为
	    <groupname>bind</groupname> 的原因。</para>
	</callout>
      </calloutlist>

      <para>完成这些配置之后， 您可以重新启动服务器， 或重启
	&man.syslogd.8; 服务并启动 &man.named.8;， 以确认
	<varname>syslogd_flags</varname> 和
	<varname>named_flags</varname> 的新值生效了。
	现在您应该已经在沙盒中运行 <application>named</application> 了!</para>

    </sect2>

    <sect2>
      <title>安全</title>

      <para>尽管 BIND 是最为常用的 DNS 实现， 但它总是有一些安全问题。
        时常会有人发现一些可能的甚至可以利用的安全漏洞。
      </para>

      <para>
        经常阅读 <ulink
        url="http://www.cert.org/">CERT</ulink> 的安全公告并订阅
	&a.security-notifications; 会是一个帮助您时刻了解最新
        Internet 和 FreeBSD 安全问题的好习惯。
      </para>

      <tip><para>如果出现了问题， 将代码升级到最新版本并重新联编
        <application>named</application> 不会带来任何麻烦。</para></tip>
    </sect2>

    <sect2>
      <title>进一步阅读</title>

      <para>BIND/<application>named</application> 联机手册：
      &man.ndc.8; &man.named.8; &man.named.conf.5;</para>

      <itemizedlist>
	<listitem>
	  <para><ulink
	      url="http://www.isc.org/products/BIND/">官方的 ISC BIND
	      页面</ulink></para>
	</listitem>

	<listitem>
	  <para><ulink
	  url="http://www.nominum.com/getOpenSourceResource.php?id=6">
	  BIND FAQ</ulink></para>
	</listitem>

	<listitem>
	  <para><ulink url="http://www.oreilly.com/catalog/dns4/">O'Reilly
         DNS 和 BIND 第4版</ulink></para>
	</listitem>

	<listitem>
	  <para><ulink
	      url="ftp://ftp.isi.edu/in-notes/rfc1034.txt">RFC1034
	      - 域名 - 概念和工具</ulink></para>
	</listitem>

	<listitem>
	  <para><ulink
	      url="ftp://ftp.isi.edu/in-notes/rfc1035.txt">RFC1035
	      - 域名 - 实现及其标准</ulink></para>
	</listitem>
      </itemizedlist>
    </sect2>
  </sect1>

  <sect1 id="network-bind9">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>撰写者 </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title><acronym>BIND</acronym>9 和 &os;</title>

<!-- This section is here to get users up with BIND9 configurations!  It
  does not cover the terminology, theoretical discussion (why run a name
  server) or the further reading which is still in the previous section.
  I did things this way to avoid repetition of content and obviously we
  cannot just remove the previous section since other supported releases
  use it.  When the previous section is removed then those comments
  should be moved here.  // Tom Rhodes -->

    <indexterm><primary>bind9</primary>
      <secondary>安装</secondary></indexterm>

    <para>随着 &os;&nbsp;5.3 版本的发布，
      <acronym>BIND</acronym>9 <acronym>DNS</acronym>
      服务软件正式成为了发行版本的一部分。 新的安全特性，文件布局，
      以及自动的 &man.chroot.8; 配置也加入进来。 这一节分成两部分，
      第一部分讨论了新增特性以及如何配置它们； 后一部分则讲述了升级过程，
      帮助用户迁移到 &os;&nbsp;5.3。 从现在起， 服务器将被简单地写作
      &man.named.8; 或 <acronym>BIND</acronym>。
      这一节跳过了前一节所介绍的那些术语， 以及一些理论上的讨论；
      因此， 建议您在继续阅读之前首先看一看前面的章节。</para>

    <para>目前， <application>named</application> 的配置文件存放在
      <filename class="directory">/var/named/etc/namedb/</filename>，
      在使用之前需要进行一些修改。 这也是进行绝大多数相关配置的地方。</para>

    <sect2>
      <title>主域的配置</title>

      <para>要配置主域， 应首先进入
	<filename class="directory">/var/named/etc/namedb/</filename>
	并执行下面的命令：</para>

      <screen>&prompt.root; <userinput>sh make-localhost</userinput></screen>

      <para>如果一切正常， 则在
	<filename class="directory">master</filename> 目录中将出现两个新文件。
	它们的名字应该是用于本地域名解析的 <filename>localhost.rev</filename>，
	以及用于 <acronym>IPv6</acronym> 配置的
	<filename>localhost-v6.rev</filename>。 作为默认的配置文件，
	关于它们的配置已经在 <filename>named.conf</filename> 文件中定义了。</para>
    </sect2>

    <sect2>
      <title>从域的配置</title>

      <para>可以通过配置从域来提供额外的域或子域的解析。
	多数情况下， <filename>master/localhost.rev</filename>
	文件可以直接复制到 <filename class="directory">slave</filename>
	目录中并进行修改。 此后，
	这些文件应该加入到 <filename>named.conf</filename>， 类似下面的
	<hostid role="domainname">example.com</hostid>
	配置：</para>

      <programlisting>zone "example.com" {
        type slave;
        file "slave/example.com";
        masters {
                10.0.0.1;
        };
};

zone "0.168.192.in-addr.arpa" {
        type slave;
        file "slave/0.168.192.in-addr.arpa";
        masters {
                10.0.0.1;
        };
};</programlisting>

      <para>请注意在这个例子中， 主服务器的
	<acronym>IP</acronym> 地址指明了我们要从哪里把域传过来；
	那台服务器本身并不一定要作为对外的
	<acronym>DNS</acronym> 服务器来用。</para>
    </sect2>

    <sect2>
      <title>系统的初始配置</title>

      <para>为了让 <application>named</application> 服务能够在系统启动时自动加载，
	需要把下面的选项加到 <filename>rc.conf</filename> 文件中：</para>

      <programlisting>named_enable="YES"</programlisting>

      <para>尽管还有其他的一些可用选项， 这是运行域名服务器所需要的最小配置。
	请参考 &man.rc.conf.5; 联机手册了解更多的选项。 如果不需要继续在
	<filename>rc.conf</filename> 文件中进行其他配置了，
	就可以通过下面的命令行来启动 <application>named</application>：</para>

      <screen>&prompt.root; <userinput>/etc/rc.d/named start</userinput></screen>
    </sect2>

    <sect2>
      <title><acronym>BIND</acronym>9 的安全</title>

      <para>尽管 &os; 会自动地将 <application>named</application>
	放到一个 &man.chroot.8; 环境中，
	您仍然可以采取一些更为严密的措施来防止潜在的针对
	<acronym>DNS</acronym> 服务的攻击。</para>

      <sect3>
	<title>查询访问控制表</title>

	<para>查询访问控制表可以用来限制对于域的查询。
	  这些配置通过在 <literal>acl</literal> 语句中列出的
	  <acronym>IP</acronym> 地址来发挥作用。 要允许一个子网查询
	  example.org 中的主机， 可以做下面的定义：</para>

	<programlisting>acl "example.com" {
        192.168.0.0/24;
};

zone "example.com" {
        type slave;
        file "slave/example.com";
        masters {
                10.0.0.1;
        };
	allow-query { example.com; };
};

zone "0.168.192.in-addr.arpa" {
        type slave;
        file "slave/0.168.192.in-addr.arpa";
        masters {
                10.0.0.1;
        };
	allow-query { example.com; };
};</programlisting>
      </sect3>

      <sect3>
	<title>限制版本查询</title>

	<para>允许查询 <acronym>DNS</acronym> 服务的版本，
	  可能会给攻击者敞开方便之门。
	  心存恶意的用户能够利用这一信息找到存在已知漏洞的服务器，
	  并利用这些漏洞来实施攻击。</para>

	<warning>
	  <para>配置伪造的版本号并不能阻止服务器被使用已知的攻击手段进行攻击。
	    唯一能够确保安全的办法是将服务器升级到没有已知问题的版本。</para>
	</warning>

	<para>伪造的版本号可以通过 <filename>named.conf</filename> 的
	  <literal>options</literal> 小节来指定：</para>

	<programlisting>options {
        directory       "/etc/namedb";
        pid-file        "/var/run/named/pid";
        dump-file       "/var/dump/named_dump.db";
        statistics-file "/var/stats/named.stats";
        version		"None of your business";
};</programlisting>
      </sect3>

<!-- Here is where I stopped for now
      <sect3>
        <title>Authentication</title>

	<para> ... </para>

-->
    </sect2>
  </sect1>

  <sect1 id="network-apache">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Murray</firstname>
	  <surname>Stokely</surname>
	  <contrib>Contributed by </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Apache HTTP 服务器</title>

    <indexterm><primary>web 服务器</primary>
      <secondary>配置</secondary></indexterm>
    <indexterm><primary>Apache</primary></indexterm>

    <sect2>
      <title>纵览</title>

      <para>&os; 被用于运行许多全球最为繁忙的 web 站点。
        大多数 Internet 上的 web 服务器，
        都使用 <application>Apache HTTP 服务器</application>。
        <application>Apache</application> 软件包可以在您的 FreeBSD
        安装盘上找到。 如果没有在首次安装时附带安装
        <application>Apache</application>， 则可以通过 <filename
        role="package">www/apache13</filename> 或 <filename
        role="package">www/apache2</filename> port 来安装。</para>

      <para>一旦成功地安装了 <application>Apache</application>，
        就必须对其进行配置。</para>

      <note><para>这一节介绍了 1.3.X 版本的
        <application>Apache HTTP 服务器</application> 的配置，
        因为它是随 &os; 一同使用的最多的版本。
        <application>Apache</application>&nbsp;2.X 引入了很多新技术，
        但在此并不讨论。 要了解关于 <application>Apache</application>&nbsp;2.X
        的更多资料， 请参见 <ulink
        url="http://httpd.apache.org/"></ulink>。</para></note>

    </sect2>

    <sect2>
      <title>配置</title>

      <indexterm><primary>Apache</primary>
	<secondary>配置文件</secondary></indexterm>

      <para>主要的 <application>Apache HTTP Server</application> 配置文件，
	在 &os; 上会安装为
	<filename>/usr/local/etc/apache/httpd.conf</filename>。
	这是一个典型的 &unix; 文本配置文件， 它使用 <literal>#</literal>
	作为注释符。 关于全部配置选项的详尽介绍超出了本书的范围，
	这里将只介绍最常被修改的那些。</para>

      <variablelist>
	<varlistentry>
	  <term><literal>ServerRoot "/usr/local"</literal></term>

	  <listitem>
	    <para>这指定了 <application>Apache</application>
	    安装的顶级目录。 执行文件被放到服务器根目录 (server root) 的
	    <filename class="directory">bin</filename> 和
	    <filename class="directory">sbin</filename> 子目录中，
	    而配置文件则位于
	    <filename class="directory">etc/apache</filename>。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>ServerAdmin you@your.address</literal></term>

	  <listitem>
	    <para>这个地址是在服务器发生问题时应发送电子邮件的地址，
	      它会出现在服务器生成的页面上， 例如错误页面。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>ServerName www.example.com</literal></term>

	  <listitem>
	    <para><literal>ServerName</literal> 允许您配置发送回客户端的主机名，
	      如果您的服务器被用户以别的名字访问 (例如， 使用 <hostid>www</hostid>
	      而不是主机本身的真实名字)。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>DocumentRoot "/usr/local/www/data"</literal></term>

	  <listitem>
	    <para><literal>DocumentRoot</literal>： 这个目录是您的文档所在的目录。
	      默认情况下， 所有的请求都会从这个位置去获取，
	      但也可以通过符号连接和别名指定其它的位置。</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>在修改配置之前备份
	<application>Apache</application> 的配置文件永远是一个好习惯。
	一旦对初始配置满意了， 就可以开始运行 <application>Apache</application> 了。</para>

<!-- sect3 for performance tuning directives?  maxservers minservers -->
<!-- etc..?? -->

<!-- Advanced configuration section.

Performance tuning directives.

Log file format -->

    </sect2>

    <sect2>
      <title>运行 <application>Apache</application></title>

      <indexterm><primary>Apache</primary>
	<secondary>启动和停止</secondary></indexterm>

      <para>与许多其它网络服务不同， <application>Apache</application> 并不依赖
        <application>inetd</application> 超级服务器来运行。
        一般情况下会把它配置为一个独立的服务器， 以期在客户的 web
        浏览器连入 HTTP 请求时， 能够获得更好的性能。 它提供了一个 shell
        脚本来使启动、 停止和重新启动服务器变得尽可能地简单。
        首次启动 <application>Apache</application>，
        只需执行：</para>

      <screen>&prompt.root; <userinput>/usr/local/sbin/apachectl start</userinput></screen>

      <para>可以在任何时候使用下面的命令来停止服务：</para>

      <screen>&prompt.root; <userinput>/usr/local/sbin/apachectl stop</userinput></screen>

      <para>当由于某种原因修改了配置文件之后， 需要重启服务器：</para>

      <screen>&prompt.root; <userinput>/usr/local/sbin/apachectl restart</userinput></screen>

      <para>要在重启 <application>Apache</application> 服务器时不中断当前的连接，
	则应运行：</para>

      <screen>&prompt.root; <userinput>/usr/local/sbin/apachectl graceful</userinput></screen>

      <para>更多的信息， 可以在
	&man.apachectl.8; 联机手册中找到。</para>

      <para>要在系统启动时启动 <application>Apache</application>， 则应在
        <filename>/etc/rc.conf</filename> 中加入：</para>

      <programlisting>apache_enable="YES"</programlisting>

      <para>如果您希望在系统引导时启动 <application>Apache</application>
	<command>httpd</command> 程序并指定其它一些选项，
	则可以把下面的行加到
	<filename>rc.conf</filename>：</para>

      <programlisting>apache_flags=""</programlisting>

      <para>现在 web 服务器就开始运行了， 您可以使用 web 浏览器打开
        <literal>http://localhost/</literal>。 默认显示的 web 页面是
        <filename>/usr/local/www/data/index.html</filename>。</para>

    </sect2>

    <sect2>
      <title>虚拟主机</title>

      <para><application>Apache</application> 支持两种不同类型的虚拟主机。
	第一种方法是基于名字的虚拟主机。 基于名字的虚拟主机使用客户机发来的
	HTTP/1.1 头来辨别主机名。 这使得不同的域得以共享同一个 IP 地址。</para>

      <para>要配置 <application>Apache</application> 来使用基于名字的虚拟主机，
        需要把类似下面的项加到您的 <filename>httpd.conf</filename> 中：</para>

      <programlisting>NameVirtualHost *</programlisting>

      <para>如果您的 web 服务器的名字是 <hostid role="fqdn">www.domain.tld</hostid>，
        而您希望建立一个
        <hostid role="fqdn">www.someotherdomain.tld</hostid> 的虚拟域，
        则应在
        <filename>httpd.conf</filename> 中加入：</para>

      <screen>&lt;VirtualHost *&gt;
ServerName www.domain.tld
DocumentRoot /www/domain.tld
&lt;/VirtualHost&gt;

&lt;VirtualHost *&gt;
ServerName www.someotherdomain.tld
DocumentRoot /www/someotherdomain.tld
&lt;/VirtualHost&gt;</screen>

      <para>您需要把上面的地址和文档路径改为所使用的那些。</para>

      <para>要了解关于虚拟主机的更多信息，
        请参考官方的 <application>Apache</application> 文档， 这些文档可以在 <ulink
        url="http://httpd.apache.org/docs/vhosts/"></ulink> 找到。</para>

    </sect2>

    <sect2>
      <title>Apache 模块</title>

      <indexterm><primary>Apache</primary>
	<secondary>模块</secondary></indexterm>

      <para>有许多不同的 <application>Apache</application> 模块，
        它们可以在基本的服务器基础上提供许多附加的功能。 FreeBSD 的
        Ports Collection 为安装
        <application>Apache</application>
        和常用的附加模块提供了非常方便的方法。</para>

      <sect3>
        <title>mod_ssl</title>

	<indexterm><primary>web 服务器</primary>
          <secondary>安全</secondary></indexterm>
	<indexterm><primary>SSL</primary></indexterm>
	<indexterm><primary>密码学</primary></indexterm>

        <para><application>mod_ssl</application> 这个模块使用 OpenSSL 库，
          来提供通过 安全套接字层 (SSL v2/v3) 和 传输层安全 (TLS v1)
          协议的强加密能力。
          这个模块提供了从某一受信的证书签署机构申请签名证书所需的所有工具，
          您可以藉此在 &os; 上运行安全的 web 服务器。</para>

	<para>如果您未曾安装
	  <application>Apache</application>， 也可以直接安装一份包含了
	  <application>mod_ssl</application> 的版本的
	  <application>Apache</application>
	  1.3.X， 其方法是通过 <filename
	  role="package">www/apache13-modssl</filename> port 来进行。 SSL
	  支持已经作为 <application>Apache</application>&nbsp;2.X 的一部分提供，
	  您可以通过
	  <filename role="package">www/apache2</filename> port 来安装后者。</para>

<!-- XXX add more information about configuring mod_ssl here. -->
<!-- Generating keys, getting the key signed, setting up your secure -->
<!-- web server! -->
      </sect3>

      <sect3>
        <title>mod_perl</title>

	<indexterm><primary>Perl</primary></indexterm>

        <para><application>Apache</application>/Perl 集成计划， 将 Perl
	  程序设计语言的强大功能， 与 <application>Apache
	  HTTP 服务器</application> 紧密地结合到了一起。
	  通过 <application>mod_perl</application> 模块，
	  可以完全使用 Perl 来撰写 <application>Apache</application> 模块。
	  此外， 服务器中嵌入的持久性解释器， 消除了由于启动外部的解释器为 Perl
	  脚本的启动所造成的性能损失。</para>

	<para>如果您还没有安装
	  <application>Apache</application>，
	  也可以通过 <filename
	  role="package">www/apache13-modperl</filename> port 来安装包含了
	  <application>mod_perl</application> 的 <application>Apache</application>
	  版本。</para>
      </sect3>

      <sect3>
	<sect3info>
	  <authorgroup>
	    <author>
	      <firstname>Tom</firstname>
	      <surname>Rhodes</surname>
	      <contrib>Written by </contrib>
	    </author>
	  </authorgroup>
	</sect3info>
        <title>PHP</title>

	<indexterm><primary>PHP</primary></indexterm>

        <para>在过去的几年中， 更多的企业开始转向
	  Internet， 以期扩大它们的收入和影响。 这也使得交互式
	  web 内容的需求日益增长。 尽管某些公司， 例如 &microsoft;，
	  在它们的商业产品中引入了一些解决方案，
	  但开放源代码团体也给出了自己的答案。 这其中，
	  使用的最为广泛的就是 <acronym>PHP</acronym>。</para>

	<para>PHP， 也成为 <quote>Hypertext Preprocessor</quote>，
	  是一种通用的脚本语言， 并且特别适合于 Web 开发。
	  它能够很容易地嵌入到
	  <acronym>HTML</acronym> 之中， 其语法接近于 C、 &java;、
	  以及 Perl， 以期让 web 开发人员能够迅速地写出动态生成的
	  web 页面。</para>

	<para>要获得 <application>Apache</application> web
	  服务器的 <acronym>PHP</acronym>5 支持， 可以从安装
	  <filename role="package">www/mod_php5</filename>
	  port 开始。</para>

	<para>这样， 将安装并配置用于支持动态 web 应用所需要的模块。
	  请再次检查， 以确认在
	  <filename>/usr/local/etc/apache/httpd.conf</filename>
	  中添加了下面的配置：</para>

	<programlisting>LoadModule php5_module        libexec/apache/libphp5.so
AddModule mod_php5.c
    &lt;IfModule mod_php5.c&gt;
        DirectoryIndex index.php index.html
    &lt;/IfModule&gt;
    
    &lt;IfModule mod_php5.c&gt;
        AddType application/x-httpd-php .php
        AddType application/x-httpd-php-source .phps
    &lt;/IfModule&gt;</programlisting>

	<para>准备停当， 简单地使用
	  <command>apachectl</command> 命令完成一次优雅的 (graceful)
	  服务重启：</para>

	<screen>&prompt.root; <userinput>apachectl graceful</userinput></screen>

	<para>在 &os; 中的 <acronym>PHP</acronym> 支持是极端模块化的。
	  如果需要安装某个扩展， 管理员只需安装相应的 port，
	  并像上面所建议的那样重新启动 <application>Apache</application>
	  就可以了。</para>

	<para>例如， 要将对于
	  <application>MySQL</application> 数据库服务器的支持加入
	  <acronym>PHP</acronym>5， 只需简单地安装
	  <filename role="package">databases/php5-mysql</filename>
	  并执行下面的命令：</para>

	<screen>&prompt.root; <userinput>apachectl graceful</userinput></screen>

	<para>这样， 就启用了 <acronym>PHP</acronym>
	  的 <application>MySQL</application> 支持。</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="network-ftp">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Murray</firstname>
	  <surname>Stokely</surname>
	  <contrib>Contributed by </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>文件传输协议 (FTP)</title>

    <indexterm><primary>FTP 服务器</primary></indexterm>

    <sect2>
      <title>纵览</title>

      <para>文件传输协议 (FTP) 为用户提供了一个简单的， 与 <acronym
	role="File Transfer Protocol">FTP</acronym> 服务器交换文件的方法。 &os;
	系统中包含了 <acronym role="File Transfer Protocol">FTP</acronym>
	服务软件， <application>ftpd</application>。 这使得在 &os;
	上建立和管理 <acronym
	role="File Transfer Protocol">FTP</acronym> 服务器变得非常简单。</para>
    </sect2>

    <sect2>
      <title>配置</title>

      <para>最重要的配置步骤是决定允许哪些帐号访问 FTP 服务器。
	一般的 &os; 系统包含了一系列系统帐号分别用于执行不同的服务程序，
	但未知的用户不应被允许登录并使用这些帐号。
	<filename>/etc/ftpusers</filename> 文件中， 列出了不允许通过
	FTP 访问的用户。 默认情况下， 这包含了前述的系统帐号，
	但也可以在这里加入其它不应通过 FTP 访问的用户。</para>

      <para>您可能会希望限制通过 FTP 登录的某些用户，
	而不是完全阻止他们使用 FTP。 这可以通过 <filename>/etc/ftpchroot</filename>
	文件来完成。 这一文件列出了希望对 FTP 访问进行限制的用户和组的表。
	而在 &man.ftpchroot.5; 联机手册中， 已经对此进行了详尽的介绍，
	故而不再赘述。</para>

      <indexterm>
	<primary>FTP</primary>
	<secondary>匿名</secondary>
      </indexterm>

      <para>如果您想要在服务器上启用匿名的 FTP 访问， 则必须建立一个名为
	<username>ftp</username> 的 &os; 用户。 这样， 用户就可以使用
	<username>ftp</username> 或 <username>anonymous</username>
	和任意的口令 (习惯上， 应该是以那个用户的邮件地址作为口令)
	来登录和访问您的 FTP 服务器。 FTP 服务器将在匿名用户登录时调用
	&man.chroot.2;， 以便将其访问限制在
	<username>ftp</username> 用户的主目录中。</para>

      <para>有两个文本文件可以用来指定显示在 FTP 客户程序中的欢迎文字。
	<filename>/etc/ftpwelcome</filename> 文件中的内容将在用户连接上之后，
	在登录提示之前显示。 在成功的登录之后， 将显示
	<filename>/etc/ftpmotd</filename> 文件中的内容。
	请注意后者是相对于登录环境的， 因此对于匿名用户而言，
	将显示 <filename>~ftp/etc/ftpmotd</filename>。</para>

      <para>一旦正确地配置了 FTP 服务器，
        就必须在 <filename>/etc/inetd.conf</filename> 中启用它。
        这里需要做的全部工作就是将注释符
        <quote>#</quote> 从已有的
        <application>ftpd</application> 行之前去掉：</para>

      <programlisting>ftp	stream	tcp	nowait	root	/usr/libexec/ftpd	ftpd -l</programlisting>

      <para>如 <xref linkend="network-inetd-hangup"> 所介绍的那样，
        修改这个文件之后， 需要向 <application>inetd</application> 发送
        HangUP 信号。</para>

      <para>现在可以通过输入下面的命令来登录您的 FTP 服务器了：</para>

      <screen>&prompt.user; <userinput>ftp localhost</userinput></screen>

    </sect2>

    <sect2>
      <title>维护</title>

      <indexterm><primary>syslog</primary></indexterm>
      <indexterm><primary>日志文件</primary>
	<secondary>FTP</secondary></indexterm>

      <para><application>ftpd</application> 服务程序使用
        &man.syslog.3; 来记录消息。 默认情况下，
        系统日志将把和 FTP 相关的消息记录到
        <filename>/var/log/xferlog</filename> 文件中。 FTP 日志的位置，
        可以通过修改
        <filename>/etc/syslog.conf</filename> 中如下所示的行来修改：</para>

      <programlisting>ftp.info      /var/log/xferlog</programlisting>

      <indexterm>
	<primary>FTP</primary>
	<secondary>匿名</secondary>
      </indexterm>

      <para>一定要小心对待在匿名 FTP 服务器中可能遇到的潜在问题。
        一般而言， 允许匿名用户上传文件应三思。 您可能发现自己的 FTP
        站点成为了交易未经授权的商业软件的论坛， 或发生更糟糕的情况。
        如果不需要匿名的 FTP 上传， 可以在文件上配置权限，
        使得您能够在其它匿名用户能够下载这些文件之前复查它们。</para>

    </sect2>
  </sect1>

  <sect1 id="network-samba">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Murray</firstname>
	  <surname>Stokely</surname>
	  <contrib>Contributed by </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>为 &microsoft.windows; 客户机提供文件和打印服务 (Samba)</title>

    <indexterm><primary>Samba 服务器</primary></indexterm>
    <indexterm><primary>Microsoft Windows</primary></indexterm>
    <indexterm>
      <primary>文件服务器</primary>
      <secondary>Windows 客户机</secondary>
    </indexterm>
    <indexterm>
      <primary>打印服务器</primary>
      <secondary>Windows 客户机</secondary>
    </indexterm>

    <sect2>
      <title>纵览</title>

      <para><application>Samba</application> 是一个流行的开远软件包，
        它提供了针对 &microsoft.windows; 客户机的文件和打印服务。
        这类客户机可以连接并使用 FreeBSD 系统上的文件空间，
        就如同使用本地的磁盘一样， 或者像使用本地打印机一样使用
        FreeBSD 上的打印机。</para>

      <para><application>Samba</application> 软件包可以在您的 FreeBSD
        安装盘上找到。 如果您没有在初次安装 FreeBSD
        时安装 <application>Samba</application>， 则可以通过 <filename
        role="package">net/samba3</filename> port 或 package 来安装。</para>

<!-- mention LDAP, Active Directory, WinBIND, ACL, Quotas, PAM, .. -->

    </sect2>

    <sect2>
      <title>配置</title>

      <para>默认的 <application>Samba</application> 配置文件会以
        <filename>/usr/local/etc/smb.conf.default</filename> 的名字安装。
        这个文件必须复制为
        <filename>/usr/local/etc/smb.conf</filename> 并进行定制，
        才能开始使用 <application>Samba</application>。</para>

      <para><filename>smb.conf</filename> 文件中包含了
        <application>Samba</application> 的运行时配置信息，
        例如对于打印机的定义， 以及希望共享给 &windows;
        客户机的 <quote>共享文件系统</quote>。
        <application>Samba</application> 软件包包含了一个称为
        <application>swat</application> 的 web 管理工具，
        后者提供了配置 <filename>smb.conf</filename> 文件的简单方法。</para>

      <sect3>
	<title>使用 Samba Web 管理工具 (SWAT)</title>

	<para>Samba Web 管理工具 (SWAT) 是一个通过
	  <application>inetd</application> 运行的服务程序。 因此，
	  需要把 <filename>/etc/inetd.conf</filename> 中下面几行的注释去掉，
	  才能够使用 <application>swat</application>
	  来配置 <application>Samba</application>：</para>

	<programlisting>swat   stream  tcp     nowait/400      root    /usr/local/sbin/swat</programlisting>
        <para>如同 <xref linkend="network-inetd-hangup"> 中介绍的那样，
          修改配置文件之后， 需要向 <application>inetd</application> 发送
          HangUP 信号。</para>

	<para>一旦在 <filename>inetd.conf</filename> 中启用了
	  <application>swat</application>， 就可以用浏览器访问
	  connect to <ulink url="http://localhost:901"></ulink> 了。
	  您将首先使用系统的 <username>root</username>
	  帐号登录。</para>

<!-- XXX screenshots go here, loader is creating them -->

	<para>只要成功地登录进了
	  <application>Samba</application> 配置页面，
	  就可以浏览系统的文档， 或从
	  <guimenu>Globals</guimenu>(全局) 选项卡开始配置了。
	  <guimenu>Globals</guimenu> 小节对应于 <literal>[global]</literal>
	  小节中的变量， 前者位于
	  <filename>/usr/local/etc/smb.conf</filename> 中。</para>
      </sect3>

      <sect3>
	<title>全局配置</title>

	<para>无论是使用 <application>swat</application>，
	  还是直接编辑 <filename>/usr/local/etc/smb.conf</filename>，
	  通常首先要配置的 <application>Samba</application>
	  选项都是：</para>

        <variablelist>
	  <varlistentry>
	    <term><literal>workgroup</literal></term>

	    <listitem>
	      <para>NT 域名或工作组名，
	        其他计算机将通过这些名字来找到服务器。</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><literal>netbios name</literal></term>
	    <indexterm><primary>NetBIOS</primary></indexterm>

	    <listitem>
	      <para>这个选项用于设置 <application>Samba</application> 服务器的
		NetBIOS 名字。 默认情况下， 这是所在主机的 DNS 名字的第一部分。</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><literal>server string</literal></term>

	    <listitem>
	      <para>这个选项用于设置通过 <command>net view</command>
		命令， 以及某些其他网络工具可以查看到的关于服务器的说明性文字。</para>
	    </listitem>
	  </varlistentry>
        </variablelist>
      </sect3>

      <sect3>
	<title>安全配置</title>

	<para>在
	  <filename>/usr/local/etc/smb.conf</filename> 中的两个最重要的配置，
	  是选定的安全模型， 以及客户机上用户的口令存放后端。
	  下面的语句控制这些选项：</para>

        <variablelist>
	  <varlistentry>
	    <term><literal>security</literal></term>

	    <listitem>
	      <para>最常见的选项形式是
	        <literal>security = share</literal> 和 <literal>security
	        = user</literal>。 如果您的客户机使用用户名，
	        并且这些用户名与您的 &os; 机器一致，
	        一般应选择用户级 (user) 安全。 这是默认的安全策略，
	        它要求客户机首先登录， 然后才能访问共享的资源。</para>

	      <para>如果采用共享级 (share) 安全，
	        则客户机不需要用有效的用户名和口令登录服务器，
	        就能够连接共享的资源。 这是较早版本的
	        <application>Samba</application> 中的默认值。</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><literal>passdb backend</literal></term>

	    <indexterm><primary>NIS+</primary></indexterm>
	    <indexterm><primary>LDAP</primary></indexterm>
	    <indexterm><primary>SQL 数据库</primary></indexterm>

	    <listitem>
	      <para><application>Samba</application> 提供了若干种不同的验证后端模型。
	        您可以通过 LDAP、 NIS+、 SQL 数据库， 或经过修改的口令文件，
	        来完成客户端的身份验证。 默认的验证模式是
	        <literal>smbpasswd</literal>， 这也是本章将介绍的全部内容。</para>
	    </listitem>
	  </varlistentry>
	</variablelist>

	<para>假设您使用的是默认的 <literal>smbpasswd</literal>
	  后端， 则必须首先创建一个
	  <filename>/usr/local/private/smbpasswd</filename> 文件，
	  来允许 <application>Samba</application> 对客户进行身份验证。
	  如果您打算让所有的 &unix; 用户帐号都能够从 &windows;
	  客户机上登录， 可以使用下面的命令：</para>

	<screen>&prompt.root; <userinput>grep -v "^#" /etc/passwd | make_smbpasswd &gt; /usr/local/private/smbpasswd</userinput>
&prompt.root; <userinput>chmod 600 /usr/local/private/smbpasswd</userinput></screen>

	<para>请参见 <application>Samba</application> 的文档，
	  以了解关于配置选项的进一步信息。 按照前面给出的描述，
	  您应该已经可以启动
	  <application>Samba</application> 了。</para>
      </sect3>

    </sect2>
    <sect2>
      <title>启动 <application>Samba</application></title>

      <para>要在系统引导时启动 <application>Samba</application>，
        将下面的配置加入
        <filename>/etc/rc.conf</filename>：</para>

      <programlisting>samba_enable="YES"</programlisting>

      <para>现在可以在任何时候通过下面的命令来启动
        <application>Samba</application> 了：</para>

      <screen>&prompt.root; <userinput>/usr/local/etc/rc.d/samba.sh start</userinput>
Starting SAMBA: removing stale tdbs :
Starting nmbd.
Starting smbd.</screen>

      <para><application>Samba</application> 事实上包含了三个相互独立的服务程序。
        您应该能够看到
        <application>nmbd</application> 和 <application>smbd</application>
        两个服务程序都是通过 <filename>samba.sh</filename> 脚本启动的。 如果在
        <filename>smb.conf</filename> 中启用了 winbind 名字解析服务，
        则应该可以看到 <application>winbindd</application>
        服务被启动起来。</para>

      <para>可以在任何时候通过下面的命令来停止运行
        <application>Samba</application>：</para>

      <screen>&prompt.root; <userinput>/usr/local/etc/rc.d/samba.sh stop</userinput></screen>

      <para><application>Samba</application> 是一个复杂的软件包，
        它提供了用于与 &microsoft.windows; 网络进行集成的各式各样的功能。
        要了解关于这里所介绍的基本安装以外的其它功能，
        请访问 <ulink url="http://www.samba.org"></ulink>。</para>
    </sect2>

  </sect1>

  <sect1 id="network-ntp">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Hukins</surname>
	  <contrib>Contributed by </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>通过 NTP 进行时钟同步</title>

    <indexterm><primary>NTP</primary></indexterm>

    <sect2>
      <title>纵览</title>

      <para>随着时间的推移， 计算机的时钟会倾向于漂移。
	网络时间协议 (NTP) 是一种确保您的时钟保持准确的方法。</para>

      <para>许多 Internet 服务依赖于， 或极大地受益于本地计算机时钟的准确性。
	例如， web 服务器可能会接收到一个请求，
	要求如果文件在某一时刻之后修改过才发送它。
	在局域网环境中， 共享文件的计算机之间的时钟是否同步至关重要，
	因为这样才能使时间戳保持一致。 类似 &man.cron.8;
	这样的程序， 也依赖于正确的系统时钟， 才能够准确地执行操作。</para>

      <indexterm>
	<primary>NTP</primary>
	<secondary>ntpd</secondary>
      </indexterm>
      <para>FreeBSD 附带了 &man.ntpd.8; <acronym role="Network
	Time Protocol">NTP</acronym> 服务器，
	它可以用于查询其它的 <acronym role="Network Time Protocol">NTP</acronym>
	服务器， 并配置本地计算机的时钟， 或者为其它机器提供服务。</para>
    </sect2>

    <sect2>
      <title>选择合适的 NTP 服务器</title>

      <indexterm>
	<primary>NTP</primary>
	<secondary>选择服务器</secondary>
      </indexterm>

      <para>为了同步您的系统时钟，
	需要首先找到至少一个 <acronym role="Network Time
	Protocol">NTP</acronym> 服务器以供使用。 网络管理员，
	或 ISP 都可能会提供用于这样目的的 NTP
	服务器&mdash;请查看他们的文档以了解是否是这样。
	另外， 也有一个在线的 <ulink
	url="http://ntp.isc.org/bin/view/Servers/WebHome">公开的
	NTP 服务器列表</ulink>， 您可以从中选一个较近的 NTP 服务器。
	请确认您选择的服务器的访问策略， 如果需要的话，
	申请一下所需的许可。</para>

      <para>选择多个相互不连接的 NTP 服务器是一个好主意，
	这样在某个服务器不可达， 或者时钟不可靠时就可以有别的选择。
	这是因为， &man.ntpd.8;
	会智能地选择它收到的响应&mdash;它会更倾向于使用可靠的服务器。</para>
    </sect2>

    <sect2>
      <title>配置您的机器</title>

      <indexterm>
	<primary>NTP</primary>
	<secondary>配置</secondary>
      </indexterm>

      <sect3>
	<title>基本配置</title>
	<indexterm><primary>ntpdate</primary></indexterm>

	<para>如果只想在系统启动时同步时钟，
	  则可以使用 &man.ntpdate.8;。 对于经常重新启动，
	  并且不需要经常同步的桌面系统来说这比较适合，
	  但绝大多数机器都应该运行 &man.ntpd.8;。</para>

	<para>在引导时使用 &man.ntpdate.8; 来配合运行 &man.ntpd.8;
	  也是一个好主意。 &man.ntpd.8; 渐进地修正时钟，
	  而 &man.ntpdate.8; 则直接设置时钟，
	  无论机器的当前时间和正确时间有多大的偏差。</para>

	<para>要启用引导时的 &man.ntpdate.8;， 需要把
	  <literal>ntpdate_enable="YES"</literal> 加到
	  <filename>/etc/rc.conf</filename> 中。 此外，
	  还需要通过 <varname>ntpdate_flags</varname>
	  来设置同步的服务器和选项，
	  它们将传递给 &man.ntpdate.8;。</para>
      </sect3>

      <sect3>
	<indexterm>
	  <primary>NTP</primary>
	  <secondary>ntp.conf</secondary>
	</indexterm>

	<title>一般配置</title>

	<para>NTP 是通过
	  <filename>/etc/ntp.conf</filename> 文件来进行配置的，
	  其格式在 &man.ntp.conf.5; 中进行了描述。
	  下面是一个例子：</para>

	<programlisting>server ntplocal.example.com prefer
server timeserver.example.org
server ntp2a.example.net

driftfile /var/db/ntp.drift</programlisting>

	<para>这里， <literal>server</literal> 选项指定了使用哪一个服务器，
	  每一个服务器都列为移行。 如果某一台服务器上指定了 <literal>prefer</literal>
	  (偏好) 参数， 如上面的 <hostid
	  role="fqdn">ntplocal.example.com</hostid>，
	  则会优先选择这个服务器。
	  如果偏好的服务器和其他服务器的响应存在显著的差别，
	  则丢弃它的响应， 否则将使用来自它的响应，
	  而不理会其他服务器。 一般来说，
	  <literal>prefer</literal> 参数应该标注在非常精确的 NTP
	  时源， 例如那些包含特殊的时间监控硬件的服务器上。</para>

	<para>而 <literal>driftfile</literal> 选项，
	  则指定了用来保存系统时钟频率偏差的文件。
	  &man.ntpd.8; 程序使用它来自动地补偿时钟的自然漂移，
	  从而使时钟即使在切断了外来时源的情况下，
	  仍能保持相当的准确度。</para>

	<para>另外， <literal>driftfile</literal>
	  选项也保存上一次响应所使用的 NTP 服务器的信息。
	  这个文件包含了 NTP 的内部信息， 它不应被任何其他进程修改。</para>
      </sect3>

      <sect3>
	<title>控制您的服务器的访问</title>

	<para>默认情况下， NTP 服务器可以被整个 Internet 上的主机访问。
	  如果在 <filename>/etc/ntp.conf</filename> 中指定 <literal>restrict</literal>
	  参数， 则可以控制允许哪些机器访问您的服务器。</para>

	<para>如果希望拒绝所有的机器访问您的 NTP
	  服务器， 只需在
	  <filename>/etc/ntp.conf</filename> 中加入：</para>

        <programlisting>restrict default ignore</programlisting>

        <para>如果只希望子网内的机器通过您的服务器同步时钟，
	  而不允许它们配置为服务器， 或作为同步时钟的节点来时用，
	  则加入</para>

        <programlisting>restrict 192.168.1.0 mask 255.255.255.0 nomodify notrap</programlisting>

	<para>这里， 需要把 <hostid role="ipaddr">192.168.1.0</hostid> 改为您网络上的
	  IP 地址， 并把 <hostid
	  role="netmask">255.255.255.0</hostid> 改为您的子网掩码。</para>

	<para><filename>/etc/ntp.conf</filename> 可能包含多个
	  <literal>restrict</literal> 选项。 要了解进一步的细节，
	  请参见 &man.ntp.conf.5; 的
	  <literal>Access Control Support</literal>(访问控制支持)
	  小节。</para>
      </sect3>
    </sect2>

    <sect2>
      <title>运行 NTP 服务器</title>

      <para>要让 NTP 服务器在系统启动时随之开启，
	需要把 <literal>ntpd_enable="YES"</literal> 加入到
	<filename>/etc/rc.conf</filename> 中。
	如果希望向 &man.ntpd.8; 传递更多参数， 需要编辑
	<filename>/etc/rc.conf</filename> 中的
	<varname>ntpd_flags</varname>。</para>

      <para>要在不重新启动机器的前提下启动服务器， 需要手工运行
	<command>ntpd</command>， 并带上
	<filename>/etc/rc.conf</filename>
	中的 <varname>ntpd_flags</varname> 所指定的参数。
	例如：</para>

      <screen>&prompt.root; <userinput>ntpd -p /var/run/ntpd.pid</userinput></screen>

      <note>
	<para>在 &os;&nbsp;4.X 中，
	  需要把上述参数中的 <literal>ntpd</literal>
	  改为 <literal>xntpd</literal>。</para></note>
    </sect2>

    <sect2>
      <title>在临时性的 Internet 连接上使用 ntpd</title>

      <para>&man.ntpd.8; 程序的正常工作并不需要永久性的 Internet 连接。
	然而， 如果您的临时性连接是配置为按需拨号的，
	那么防止 NTP 通讯频繁触发拨号， 或保持连接就有必要了。
	如果您使用用户级 PPP， 可以使用 <literal>filter</literal>
	语句， 在 <filename>/etc/ppp/ppp.conf</filename> 中进行必要的设置。
	例如：</para>

      <programlisting> set filter dial 0 deny udp src eq 123
 # Prevent NTP traffic from initiating dial out
 set filter dial 1 permit 0 0
 set filter alive 0 deny udp src eq 123
 # Prevent incoming NTP traffic from keeping the connection open
 set filter alive 1 deny udp dst eq 123
 # Prevent outgoing NTP traffic from keeping the connection open
 set filter alive 2 permit 0/0 0/0</programlisting>

      <para>要了解进一步的信息， 请参考 &man.ppp.8; 的 <literal>PACKET
	FILTERING</literal>(包过滤) 小节， 以及
	<filename>/usr/share/examples/ppp/</filename> 中的例子。</para>

      <note>
	<para>某些 Internet 访问提供商会阻止低编号的端口，
	  这会导致 NTP 无法正常工作， 因为响应无法到达您的机器。</para>
      </note>
    </sect2>

    <sect2>
      <title>进一步的信息</title>

      <para>关于 NTP 服务器的文档， 可以在
	<filename>/usr/share/doc/ntp/</filename> 找到 HTML
	格式的版本。</para>
    </sect2>
  </sect1>

</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
<!--  LocalWords:  config mnt www -->
