<!--
     The FreeBSD Documentation Project
     The FreeBSD Simplified Chinese Documentation Project

     Original Revision: 1.243
     $FreeBSD$
-->

<chapter id="ports">
  <title>安装应用程序: Packages 和 Ports</title>

  <sect1 id="ports-synopsis">
    <title>概述</title>

    <indexterm><primary>ports</primary></indexterm>
    <indexterm><primary>packages</primary></indexterm>
    <para>FreeBSD 捆绑了很多系统工具作为基本系统的一部分。然而，在实际工作中，
      您可能仍需要安装额外的第三方应用程序。 FreeBSD
      提供了两种安装第三方应用程序的方法： FreeBSD Ports Collection 和二进制软件包
      (package)。 无论用哪种方式， 您都可以从本地媒体 (设备)
      或直接通过网络来安装您喜欢的最新版本的应用程序。</para>

    <para>读完这章，您将了解到:</para>

    <itemizedlist>
      <listitem>
	<para>如何安装第三方的二进制软件包。</para>
      </listitem>
      <listitem>
	<para>如何从Ports Collection安装第三方软件。</para>
      </listitem>
      <listitem>
	<para>如何删除先前安装的软件包。</para>
      </listitem>
      <listitem>
	<para>如何改动Ports Collection里面的一些参数，定制软件使用。</para>
      </listitem>
      <listitem>
	<para>如何找到您需要的软件包。</para>
      </listitem>
      <listitem>
	<para>如何升级您的ports。</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="ports-overview">
    <title>软件安装预览</title>

    <para>如果您以前使用过 &unix; 系统，那典型的第三方软件安装的步骤是像下面描述的：</para>

    <procedure>
      <step>
	<para>下载这个软件，软件的发行版可能是源代码格式，或是一个二进制包。</para>
      </step>

      <step>
	<para>解开软件(其中代表性的是用 &man.compress.1;, &man.gzip.1;, 或
	  &man.bzip2.1; 压缩过的tar包)。</para>
      </step>

      <step>
	<para>阅读相关文档，了解如何安装。 (多半一个文件名是<filename>INSTALL</filename>或<filename>README</filename>，
	  或在<filename>doc/</filename> 目录下的一些文档)</para>
      </step>

      <step>
	<para>如果软件是以源代码形式发布的，那就需要编译它。可能需要编辑一个
	  <filename>Makefile</filename>文件, 或运行
	  <command>configure</command>脚本，和其他的一些工作。</para>
      </step>

      <step>
	<para>测试和安装软件。</para>
      </step>
    </procedure>

    <para>如果一切顺利的话，就这么简单。如果您在安装一个软件包时发生一些错误，
      您可能需要编辑一下它的代码，以使它能正常工作。</para>

    <para>您可以继续使用 <quote>传统的</quote>方式安装软件。 然而， FreeBSD
      提供了两种技术： packages 和 ports。 就在写这篇文章的时候，
      已经有超过 &os.numports; 个第三方的应用程序可以使用了。</para>

    <para>对于任意一个应用程序包，是一个可以下载的FreeBSD package文件。这个
      FreeBSD package包含了编译好的的副本， 还有一些配置文件或文档。
      一个下载的包文件可以用 FreeBSD 的包管理命令来操作， 例如
      &man.pkg.add.1;，&man.pkg.delete.1;, &man.pkg.info.1; 等等。
      可以使用一个简单的命令安装一个新的应用程序。</para>

    <para>一个FreeBSD的port是一个可以自动从源代码编译成应用程序的文件集合。</para>

    <para>记住，如果您自己来编译的话，需要执行很多步的操作 (解压， 补丁， 编译，
      安装)。 这些整理 port 的文件集合包含了系统需要完成这个工作的必需信息。
      您可以运行一些简单的命令， 那些源代码就可以自动地下载， 解开， 打补丁，
      编译， 直至安装完成。</para>

    <para>实际上，ports 系统也能做出被 <command>pkg_add</command>
      的程序包和不久就要讲到的其他包管理命令来安装的软件包。</para>

    <para>Packages 和 ports 是互相 <emphasis>依赖</emphasis> 的。
      假设您想安装一个依赖于已经安装的特定库的应用程序。
      应用程序和那个库都已经应用于 FreeBSD ports 和 packages。
      如果您使用 <command></command> 命令或 ports 系统来添加应用程序，
      两个都必须注意库是否被安装， 如果没有， 它会自动先安装库。</para>

    <para>这里给出的两种技术是很相似的，您可能会奇怪为什么 FreeBSD
      会弄出这两种技术。 其实， packages 和 ports 都有它们自己的长处，
      使用哪一种完全取决于您自己的喜好。</para>

    <itemizedlist>
      <title>Package的优点</title>
      
      <listitem>
	<para>一个压缩的 package 通常要比一个压缩的包含源代码的应用程序小得多。</para>
      </listitem>

      <listitem>
	<para>package 不需要进行额外的编译。 对于大型应用程序如
	  <application>Mozilla</application>， <application>KDE</application> 或
	  <application>GNOME</application> 来说这显得尤为重要，
	  特别是在您的系统资源比较差的情况下。</para>
      </listitem>

      <listitem>
	<para>package不需要您知道如何在FreeBSD上编译软件的详细过程。</para>
      </listitem>
    </itemizedlist>

    <itemizedlist>
      <title>Ports 的优点</title>
      
      <listitem>
	<para>package 在编译时通常使用比较保守的选项，
	  这是为了保证它们能够运行在大多数的系统上。 通过从 port 安装，
	  您可以细微调整编译选项来产生适合于处理器的代码 (针对于 Pentium IV
	  或 AMD 的 Athlon CPU)。</para>
      </listitem>

      <listitem>
	<para>一些软件包已经把与它们相关的能做和不能做的事情的选项都编译进去了。
	  例如， <application>Apache</application> 可能就配置了很多的选项。
	  从 port 中安装时， 您不一定要接受默认的选项， 可以自己来设置。</para>

	<para>在一些例子中，一个软件有不同的配置存在多个package。 例如，
	  <application>Ghostscript</application>存在
	  <filename>ghostscript</filename> package 和
	  <filename>ghostscript-nox11</filename> package两个配置package，
	  这取决于您是否安装了X11服务器。 这样的调整对package是可能的，
	  但如果一个应用程序有超过一个或两个不同的编译时间选项时， 就不行了。</para>
      </listitem>

      <listitem>
	<para>一些软件的许可条件禁止采用二进制形式发行。 它们必须带上源代码。</para>
      </listitem>

      <listitem>
	<para>一些人不信任二进制发行形式。 至少有了源代码， (理论上)
	  可以亲自阅读它，寻找潜在的问题。</para>
      </listitem>

      <listitem>
	<para>如果您要自己对软件打补丁，您就需要有源代码。</para>
      </listitem>

      <listitem>
	<para>一些人喜欢整天围着源代码转， 所以他们喜欢亲自阅读源代码，
	  修改源代码等等。</para>
      </listitem>
    </itemizedlist>

    <para>保持更新 ports， 订阅邮件列表 &a.ports; 和递交错误报告 &a.ports-bugs;。</para>

    <warning>
      <para>安装任何应用程序之前， 应首先检查 <ulink
	url="http://vuxml.freebsd.org/"></ulink>
	上是否有关于您所安装的应用程序的安全问题报告。</para>

      <para>您也可以安装 <filename
	role="package">security/portaudit</filename>，
	它能够自动地检查已经安装的应用程序的漏洞；
	此外， 在您安装程序之前它也会首先检查是否存在已知的漏洞。
	另外， 您也可以使用 <command>portaudit
	-F -a</command> 这个命令在安装了某个软件包之后作出检查。</para>
    </warning>

    <para>这章的其余部分将介绍如何使用packages和ports来安装和管理第三方软件。</para>
  </sect1>

  <sect1 id="ports-finding-applications">
    <title>寻找您要的应用程序</title>

    <para>在您安装任何应用程序之前，需要知道您需要什么，那个应用程序叫什么。</para>

    <para>FreeBSD中可用的应用程序正在不断地增长着。幸运的是，
      有许多方法可以找到您所需要的程序:</para>

    <itemizedlist>
      <listitem>
	<para>FreeBSD站点上有一个可以搜索到的当前所有可用的应用程序列表，在 <ulink
	  url="&url.base;/ports/index.html">http://www.FreeBSD.org/ports/</ulink>。
	  它分很多种类，您既可以通过程序的名称来搜索，
	  也可以在分类中列出所有可用的应用程序 (如果您知道名字)，
	  也可以在分类中列出所有可用的应用程序。</para>
      </listitem>

      <indexterm><primary>FreshPorts</primary></indexterm>

      <listitem>
	<para>Dan Langille 维护着网站 FreshPorts，在 <ulink
	  url="http://www.FreshPorts.org/"></ulink>。 FreshPort时刻 <quote>追踪</quote>
	  着在 ports 中应用程序的变化。当有任何程序被升级时，他们就会发 email 提醒您。</para>
      </listitem>

      <indexterm><primary>FreshMeat</primary></indexterm>

      <listitem>
	<para>I如果您不知道您想要的应用程序的名字，可以通过 (<ulink
	  url="http://www.freshmeat.net/"></ulink>) 网站来查找，
	  如果找到了应用程序， 您可以回 FreeBSD 的主站去看一下这个应用程序是否已经被
	  port 进去了。
	</para>
      </listitem>

      <listitem>
	<para>如果您知道一个port的准确名字， 但需要知道在哪个类别里面能找到它，您可以使用
        &man.whereis.1; 这个命令。简单地输入 <command>whereis
        <replaceable>file</replaceable></command>，
        <replaceable>file</replaceable> 就是您想安装的程序名字。
        如果系统找到了它， 您将被告知在它在哪里， 例如:</para>

      <screen>&prompt.root; <userinput>whereis lsof</userinput>
lsof: /usr/ports/sysutils/lsof</screen>

      <para>结果告诉我们这个命令<command>lsof</command> (一个系统配置程序)可以在
	<filename>/usr/ports/sysutils/lsof</filename>目录中找到。</para></listitem>

      <listitem>
	<para>还有另外的一个寻找您需要的port的方法--是用ports collecton
	内嵌的搜索机制。要使用这个搜索, 您需要先到
        <filename>/usr/ports</filename>目录下面。 在那个目录里面，
        运行<command>make search
        name=<replaceable>program-name</replaceable></command>，
        <replaceable>program-name</replaceable> 就是您想寻找的程序名字。
        举个例子， 如果您想找 <command>lsof</command>：</para>

      <screen>&prompt.root; <userinput>cd /usr/ports</userinput>
&prompt.root; <userinput>make search name=lsof</userinput>
Port:   lsof-4.56.4
Path:   /usr/ports/sysutils/lsof
Info:   Lists information about open files (similar to fstat(1))
Maint:  obrien@FreeBSD.org
Index:  sysutils
B-deps: 
R-deps: </screen>

      <para>在输出的内容里面您要特别注意包含 <quote>Path:</quote>
        的这行将告诉您在哪里可以找到这个 port。 如果要安装此 port，
        那其他输出的信息不是必须的， 但是还是显示输出了。</para>

      <para>为了更深入的搜索，您还可以用 <command>make
       search key=<replaceable>string</replaceable></command>，
       <replaceable>string</replaceable>就是您想搜索的部分内容。
       它将搜索port的名字、 注释， 描述和从属关系，
       如果您不知道您想搜索的程序名字，
       可以利用它搜索一些关键主题来找到您需要的。</para>

      <para>上面说的这些方法， 搜索的关键字没有大小写区分的。
       搜索 <quote>LSOF</quote>的结果将和搜索<quote>lsof</quote>的结果一样。</para>
      </listitem>

    </itemizedlist>
  </sect1>

  <sect1 id="packages-using">
    <sect1info>    
      <authorgroup>
        <author>
          <firstname>Chern</firstname>
	  <surname>Lee</surname>
	  <contrib>Contributed by </contrib>
        </author>
      </authorgroup>
    <!-- 30 Mar 2001 -->
    </sect1info>

    <title>使用Packages系统</title>

    <sect2>
      <title>一个package的安装</title>
      <indexterm>
        <primary>packages</primary>
        <secondary>installing</secondary>
      </indexterm>
    
      <indexterm>
        <primary><command>pkg_add</command></primary>
      </indexterm>
      <para>您可以用 &man.pkg.add.1;
	这个命令从本地文件或网络上的服务器来安装一个 FreeBSD 软件包。</para>

      <example>
        <title>在本地手动下载一个package,并安装它</title>

        <screen>&prompt.root; <userinput>ftp -a <replaceable>ftp2.FreeBSD.org</replaceable></userinput>
Connected to ftp2.FreeBSD.org.
220 ftp2.FreeBSD.org FTP server (Version 6.00LS) ready.
331 Guest login ok, send your email address as password.
230-
230-     This machine is in Vienna, VA, USA, hosted by Verio.
230-         Questions? E-mail freebsd@vienna.verio.net.
230-
230-
230 Guest login ok, access restrictions apply.
Remote system type is UNIX.
Using binary mode to transfer files.
<prompt>ftp></prompt> <userinput>cd /pub/FreeBSD/ports/packages/sysutils/</userinput>
250 CWD command successful.
<prompt>ftp></prompt> <userinput>get lsof-4.56.4.tgz</userinput>
local: lsof-4.56.4.tgz remote: lsof-4.56.4.tgz
200 PORT command successful.
150 Opening BINARY mode data connection for 'lsof-4.56.4.tgz' (92375 bytes).
100% |**************************************************| 92375       00:00 ETA
226 Transfer complete.
92375 bytes received in 5.60 seconds (16.11 KB/s)
<prompt>ftp></prompt> <userinput>exit</userinput>
&prompt.root; <userinput>pkg_add <replaceable>lsof-4.56.4.tgz</replaceable></userinput></screen>
      </example>

      <para>如果您没有本地package的安装盘 (如 FreeBSD CD-ROM)，
        可以执行 &man.pkg.add.1; 命令并加上 <option>-r</option> 选项。
        这将迫使程序自动决定目标文件的正确格式和版本，
        然后自动从一个 FTP 站点寻找和安装 package。</para>

      <indexterm>
        <primary><command>pkg_add</command></primary></indexterm>
      <screen>&prompt.root; <userinput>pkg_add -r <replaceable>lsof</replaceable></userinput></screen>

      <para>上面的例子将下载正确的package， 而不需要用户的干预就可以安装。
        如果您想指定 FreeBSD package 的镜像站点， 替换主站点， 您必须新设置
        <envar>PACKAGESITE</envar> 这个环境变量， 覆盖原来的设置。
        &man.pkg.add.1; 使用 &man.fetch.3; 下载文件， 可以使用多种环境变量，
        包含 <envar>FTP_PASSIVE_MODE</envar>、 <envar>FTP_PROXY</envar>，
        和 <envar>FTP_PASSWORD</envar>。 如果您使用 FTP/HTTP
        代理或在防火墙后面， 您可能需要设置这些环境变量。
        详细的列表请参考 &man.fetch.3;。上述例子中用 <literal>lsof</literal>
        替代了 <literal>lsof-4.56.4</literal>。 当使用远程安装 Package
        的时候软件名字不需要包含版本号。 &man.pkg.add.1;
        将自动的找到这个软件最新的版本。</para>

      <note>
	<para>如果您使用 &os.current; 或 &os.stable;版本的FreeBSD， &man.pkg.add.1;
	  将下载您的应用软件的最新版本。 如果您使用 -RELEASE 版本的
	  FreeBSD, 它将会获得与您的版本相应的软件包版本。
	  您可以通过修改环境变量 <envar>PACKAGESITE</envar>
	  来改变这一行为。 例如， 如果您运行 &os;&nbsp;5.4-RELEASE
	  系统， 默认情况下 &man.pkg.add.1; 将尝试从
	  <literal>ftp://ftp.freebsd.org/pub/FreeBSD/ports/i386/packages-5.4-release/Latest/</literal>
	  下载预编译的软件包。 如果您希望强制 &man.pkg.add.1; 下载
	  &os;&nbsp;5-STABLE 的软件包， 则可以将 <envar>PACKAGESITE</envar>
	  设置为
	  <literal>ftp://ftp.freebsd.org/pub/FreeBSD/ports/i386/packages-5-stable/Latest/</literal>。
	</para>
      </note>

      <para>软件包采用 <filename>.tgz</filename> 和 <filename>.tbz</filename>
          两种格式。您可以在 <ulink
          url="ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/packages/"></ulink>
          下面或从 FreeBSD 的发行光盘找到， 它在每一个 4CD 的 FreeBSD 发行版的
          <filename>/packages</filename>目录中。 软件包的设计规划与
          <filename>/usr/ports</filename> 树一致。 每个分类都有自己的目录，
          所有的软件包可以在目录 <filename>All</filename>中找到。
      </para>

      <para>软件包系统的目录结构与ports的设计规划一致； 它们共同构成了整个 package/port。
      </para>

    </sect2>

    <sect2>
      <title>软件包的管理</title>

      <indexterm>
        <primary>packages</primary>
        <secondary>managing</secondary>
      </indexterm>
      <para>&man.pkg.info.1; 是用于列出已安装的所有软件包列表和描述的程序。
      </para>

      <indexterm>
        <primary><command>pkg_info</command></primary>
      </indexterm>
      <screen>&prompt.root; <userinput>pkg_info</userinput>
cvsup-16.1          A general network file distribution system optimized for CV
docbook-1.2         Meta-port for the different versions of the DocBook DTD
...</screen>
      <para>&man.pkg.version.1;是一个用来统计所有安装的软件包版本的工具。
        它可以用来比较本地 package 的版本与 ports 目录中的当前版本是否一致。
      </para> 
      <indexterm>
        <primary><command>pkg_version</command></primary>
      </indexterm>
        <screen>&prompt.root; <userinput>pkg_version</userinput>
cvsup                       =
docbook                     =
...</screen>

      <para>在第二列的符号指出了安装版本的相关时间和本地ports目录树中可用的版本。</para>

      <informaltable frame="none" pgwide="1">
        <tgroup cols="2">
	  <thead>
            <row>
              <entry>符号</entry>
              <entry>含义</entry>
            </row>
          </thead>

 	  <tbody>
  	    <row>
	    <entry>=</entry> <entry>在本地ports树中与已安装的软件包版本相匹配。</entry>
  	    </row>
 
        <row><entry>&lt;</entry>
	<entry>已安装的版本要比在ports树中的版本旧。</entry>
	</row>

        <row><entry>&gt;</entry><entry>已安装的版本要比在ports树中的版本新
          (本地的port树可能没有更新)。</entry></row>

        <row><entry>?</entry><entry> 已安装的软件包无法在ports索引中找到。
          (可能发生这种事情，举个例子， 您早先安装的一个 port 从 port
          树中移出或改名了)</entry></row>

        <row><entry>*</entry><entry>软件包有很多版本。</entry></row>

	</tbody>
	</tgroup>
    </informaltable>
    </sect2>

    <sect2>
      <title>删除一个软件包</title>
      <indexterm>
        <primary><command>pkg_delete</command></primary>
      </indexterm>
      <indexterm>
        <primary>packages</primary>
        <secondary>deleting</secondary>
      </indexterm>
      <para>要删除先前安装的软件package，只要使用&man.pkg.delete.1; 工具。
	
      </para>

      <screen>&prompt.root; <userinput>pkg_delete <replaceable>xchat-1.7.1</replaceable></userinput></screen>
    </sect2>

    <sect2>
      <title>其它</title>
      <para>所有已安装的 package 信息都保存在 <filename>/var/db/pkg</filename>
        目录下。 安装文件的列表和每个 package
        的内容和描述都能在这个目录的相关文件中找到。
      </para>
    </sect2>
  </sect1>
  
  <sect1 id="ports-using">
    <title>使用Ports Collection</title>

    <para>下面的章节提供了使用Ports Collection来安装或卸载程序的基本用法。</para>

    <sect2 id="ports-tree">
      <title>获得Ports Collection</title>

      <para>在您能使用 ports 之前， 您必须先获得 Ports Collection &mdash;
	本质上是 <filename>/usr/ports</filename> 目录下的一堆
	<filename>Makefile</filename>、 补丁和描述文件。
      </para>

      <para>在您安装 FreeBSD 系统的时候， <application>sysinstall</application>
	会询问您是否需要安装 Ports Collection。 如果您选择 no，
	那您可以用下面的指令来安装 Ports Collection：</para>

      <procedure>
	<title>Sysinstall 方式</title>

	<para>这种方式使用 <application>sysinstall</application>
	  再次手动安装Ports Collection。</para>

	<step>
	  <para>以 <username>root</username> 用户身份， 运行
	    <command>sysinstall</command>
	    (对于 &os; 5.2 之前的版本， 应该是
	    <command>/stand/sysinstall</command>)， 如下所示：</para>

	  <screen>&prompt.root; <userinput>sysinstall</userinput></screen>
	</step>

	<step>
	  <para>选择 <guimenuitem>Configure</guimenuitem>， 按 <keycap>Enter</keycap>。</para>
	</step>

	<step>
	  <para>选择 <guimenuitem>Distributions</guimenuitem>， 按 <keycap>Enter</keycap>。</para>
	</step>

	<step>
	  <para>选择 <guimenuitem>ports</guimenuitem>， 按 <keycap>Space</keycap>。</para>
	</step>

	<step>
	  <para>选择 <guimenuitem>Exit</guimenuitem>， 按 <keycap>Enter</keycap>。</para>
	</step>

	<step>
	  <para>选择您的安装介质，就像CDROM，FTP，等等</para>
	</step>

	<step>
	  <para>选择 <guimenuitem>Exit</guimenuitem> 并按 <keycap>Enter</keycap>。</para>
	</step>

	<step>
	  <para>按 <keycap>X</keycap> 键退出 <application>sysinstall</application>。</para>
	</step>
      </procedure>

      <para>您可以使用 <application>CVSup</application>，这个程序让您获得和更新
	Ports Collection。 <application>CVSup</application> 需要使用
	<filename>/usr/share/examples/cvsup/ports-supfile</filename> 这个配置文件。
	如果您想获得关于 <application>CVSup</application> 这个应用程序的更多信息，
	请看 <link linkend="cvsup">使用 CVSup</link> (<xref linkend="cvsup">) 和本文。</para>

      <procedure>
	<title>CVSup 方法</title>

	<para>使用 <application>CVSup</application> 获得 Ports Collection，
	  是一个非常快捷的方法。 如果您想保持您的 ports 树的最新状态，
	  或了解更多关于 <application>CVSup</application>
	  的内容， 您可以阅读刚才提及的内容。</para>

	<step>
	  <para>安装 <filename
	    role="package">net/cvsup-without-gui</filename> 软件包：</para>

	  <screen>&prompt.root; <userinput>pkg_add -r cvsup-without-gui</userinput></screen>

	  <para>请参见 <link
	      linkend="cvsup-install">如何安装 CVSup</link> (<xref
	      linkend="cvsup-install">) 以了解更多细节。</para>
	</step>

	<step>
	  <para>运行 <command>cvsup</command>：</para>

	  <screen>&prompt.root; <userinput>cvsup -L 2 -h <replaceable>cvsup.FreeBSD.org</replaceable> /usr/share/examples/cvsup/ports-supfile</userinput></screen>

	  <para>将
	    <replaceable>cvsup.FreeBSD.org</replaceable> 改为离您较近的
	    <application>CVSup</application> 服务器。 请参见
	    <link linkend="cvsup-mirrors">CVSup 镜像</link> (<xref
	    linkend="cvsup-mirrors">) 中的镜像站点完整列表。</para>

	  <note>
	    <para>有时可能希望使用自己的
	      <filename>ports-supfile</filename>， 比如说，
	      不想每次都通过命令行来指定所使用的 <application>CVSup</application>
	      服务器。</para>

	    <procedure>
	      <step>
		<para>这种情况下， 需要以 <username>root</username> 身份将
		  <filename>/usr/share/examples/cvsup/ports-supfile</filename>
		  复制到新的位置， 例如
		  <filename>/root</filename> 或您的主目录。</para>
	      </step>

	      <step>
		<para>编辑 <filename>ports-supfile</filename>。</para>
	      </step>

	      <step>
		<para>把
		  <replaceable>CHANGE_THIS.FreeBSD.org</replaceable>
		  修改成离您较近的 <application>CVSup</application> 服务器。
		  可以参考 <link linkend="cvsup-mirrors">CVSup
		  镜像</link> (<xref linkend="cvsup-mirrors">)
		  中的镜像站点完整列表。</para>
	      </step>

	      <step>
		<para>接下来按如下的方式运行 <command>cvsup</command>：</para>

		<screen>&prompt.root; <userinput>cvsup -L 2 <replaceable>/root/ports-supfile</replaceable></userinput></screen>
	      </step>
	    </procedure>
	  </note>
	</step>

	<step>
	  <para>此后运行 &man.cvsup.1; 命令将下载最近所进行的改动，
	    并将它们应用到您的 Ports Collection 上，
	    不过这一过程并不重新联编您系统上的 ports。</para>
	</step>
      </procedure>
    </sect2>

    <sect2 id="ports-skeleton">
      <title>安装 Ports</title>

      <indexterm>
        <primary>ports</primary>
        <secondary>安装</secondary>
      </indexterm>
      <para>当提到 Ports Collection 时，
        第一个要说明的就是何谓 <quote>skeleton</quote>。 简单地说，
        port skeleton 是让一个程序在 FreeBSD
        上简洁地编译并安装的所需文件的最小组合。 每个 port skeleton 包含：</para>

      <itemizedlist>
	<listitem>
	  <para>一个 <filename>Makefile</filename>。 <filename>Makefile</filename>
	    包括好几个部分， 指出应用程序是如何编译以及将被安装在系统的哪些地方。
	  </para>
	</listitem>

	<listitem>
	  <para>一个 <filename>distinfo</filename> 文件。这个文件包括这些信息：
	    这些文件用来对下载后的文件校验和进行检查， 使用 &man.md5.1;
	    来确保在下载过程中文件没有被破坏。
	</para>
	</listitem>
	
	<listitem>
	  <para>一个 <filename>files</filename> 目录。 这个目录包括在
	    FreeBSD 系统上编译和安装程序需要用到的补丁。
	    这些补丁基本上都是些小文件， 指出特定文件作了哪些修正。
	    它们都是纯文本的的格式，基本上是这样的
	    <quote>删除第 10 行</quote> 或
	    <quote>将第 26 行改为这样 ...</quote>，
	    补丁文件也被称作 <quote>diffs</quote>，
	    他们由 &man.diff.1; 程序生成。
	 </para>

	  <para>这个目录也包含了在编译 port 时要用到的其它文件。</para>
	</listitem>

	<listitem>
	  <para>一个 <filename>pkg-descr</filename> 文件。
	    这是一个提供更多细节，有软件的多行描述。</para>
	</listitem>
	
	<listitem>
	  <para>一个 <filename>pkg-plist</filename> 文件。
	    这是即将被安装的所有文件的列表。它告诉 ports
	    系统在卸载时需要删除哪些文件。</para>
	</listitem>
      </itemizedlist>

      <para>一些ports还有些其它的文件， 例如
        <filename>pkg-message</filename>。 ports
        系统在一些特殊情况下会用到这些文件。
        如果您想知道这些文件更多的细节以及 ports 的概要， 请参阅
        <ulink url="&url.books.porters-handbook;/index.html">FreeBSD Porter's Handbook</ulink>。</para>

      <para>port里面包含着如何编译源代码的指令， 但不包含真正的源代码。 您可以在网上或
        CD-ROM 上获得源代码。 源代码可能被开发者发布成任何格式。
        一般来说应该是一个被 tar 和 gzip 过的文件，
        或者是被一些其他的工具压缩或未压缩的文件。
        ports中这个程序源代码标示文件叫 <quote>distfile</quote>，
        安装 &os; port的方法还不止这两种。</para>

      <note>
        <para>您必须使用 <username>root</username> 用户登录后安装 ports。</para>
      </note>

      <warning>
	<para>在安装任何 port 之前， 应该首先确保已经更新到了最新的
	  Ports Collection， 并检查 <ulink
	  url="http://vuxml.freebsd.org/"></ulink> 中是否有与那个
	  port 有关的安全问题。</para>

	<para>在安装应用程序之前， 可以使用
	  <application>portaudit</application> 来自动地检查是否存在已知的安全问题。
	  这个工具同样可以在
	  Ports Collection (<filename
	  role="package">security/portaudit</filename>) 中找到。
	  在安装新的 port 之前， 可以考虑先运行一下
	  <command>portaudit -F</command> 来抓取最新的漏洞数据库。
	  在每天的周期性系统安全检察时， 数据库会被自动更新，
	  并且会在这之后实施安全审计。
	  欲了解进一步的情况，请参阅 &man.portaudit.1; 和 &man.periodic.8;。</para>
      </warning>

      <sect3 id="ports-cd">
        <title>从光盘安装 Ports</title>

        <indexterm>
          <primary>ports</primary>
          <secondary>从 CD-ROM 安装</secondary>
        </indexterm>
        <para>FreeBSD 项目发行的官方光盘文件不再包含 distfiles。
	  他们提供了许多更多的更好的使用编译好的软件包。
	  如果您从 <ulink
	  url="http://www.freebsdmall.com/">FreeBSD Mall</ulink> 购买了像
	  FreeBSD PowerPak 这样的光盘产品， 里面就包含了distfiles。
	  下面的章节假设您已经有了一张FreeBSD的安装光盘。
	</para>

        <para>将 FreeBSD CD-ROM 放进驱动器。 将其挂接到
	  <filename>/cdrom</filename>。 (如果您使用了与此不同的挂接点，
	  请设置 <makevar>CD_MOUNTPTS</makevar> make 变量)。
	  首先， 进入要安装的 port 所在的目录：</para>

        <screen>&prompt.root; <userinput>cd /usr/ports/sysutils/lsof</userinput></screen>

        <para>一旦进入了 <filename>lsof</filename> 的目录，您将会看到这个port的结构。
	  下一步就是 make，或说 <quote>联编</quote> 这个 port。
	  只需在命令行简单地输入 <command>make</command> 命令就可轻松完成这一工作。
	  做好之后，您可以看到下面的信息：</para>

        <screen>&prompt.root; <userinput>make</userinput>
&gt;&gt; lsof_4.57D.freebsd.tar.gz doesn't seem to exist in /usr/ports/distfiles/.
&gt;&gt; Attempting to fetch from file:/cdrom/ports/distfiles/.
===&gt;  Extracting for lsof-4.57
...
[extraction output snipped]
...
&gt;&gt; Checksum OK for lsof_4.57D.freebsd.tar.gz.
===&gt;  Patching for lsof-4.57
===&gt;  Applying FreeBSD patches for lsof-4.57
===&gt;  Configuring for lsof-4.57
...
[configure output snipped]
...
===&gt;  Building for lsof-4.57
...
[compilation output snipped]
...
&prompt.root;</screen>

        <para>注意，一旦编译完成，您就会回到命令行。 下一步安装 port，
	  要安装它只需要在 <command>make</command> 命令后跟上一个单词
	  <command>install</command> 即可：</para>

        <screen>&prompt.root; <userinput>make install</userinput>
===&gt;  Installing for lsof-4.57
...
[installation output snipped]
...
===&gt;   Generating temporary packing list
===&gt;   Compressing manual pages for lsof-4.57
===&gt;   Registering installation for lsof-4.57
===&gt;  SECURITY NOTE: 
      This port has installed the following binaries which execute with
      increased privileges.
&prompt.root;</screen>

        <para>一旦您返回到提示符，您就可以运行您刚刚安装的程序了。因为
	  <command>lsof</command> 是一个赋予特殊权限的程序，
	  因此显示了一个安全警告。 在编译和安装 ports 的时候，
	  您应该留意任何出现的警告。</para>

        <note>
          <para>您可以运行一个命令 <command>make
            install</command> 来替换 <command>make</command> 和
	    <command>make install</command>这两个分离的步骤。</para>
	</note>

	<note>
	  <para>一些 shell 会缓存环境变量
	    <envar>PATH</envar> 中指定的目录里的可执行文件，
	    以加速查找它们的速度。 如果您使用的是这类 shell，
	    在安装 port 之后可能需要执行 <command>rehash</command>
	    命令， 然后才能运行新安装的那些命令。
	    这个命令可以在类似
	    <command>tcsh</command> 的 shell 中使用。 对于类似
	    <command>sh</command> 或 <filename
	    role="package">shells/bash</filename> 的 shell，
	    对应的命令是 <command>hash -r</command>。
	    请参见您的 shell 的文档以了解进一步的情况。</para>
	</note>

        <note>
          <para>有一小部分的 port 由于许可协议的问题不允许包含在光盘内。
	    可能是因为在下载前需要注册一些信息或不允许再发布， 或者其他理由。
	    如果您想安装的 port 不在光盘中， 为此您将需要在线操作来安装
	    (请看 <link linkend="ports-inet">下一章节</link>)。</para>
	</note>
      </sect3>

      <sect3 id="ports-inet">
      <title>从互联网安装Port</title>

        <para>作为最后一节, 本节假定您有一个可用的互联网连接。 如果您没有，
	  您需要察看上一章节<link  linkend="ports-cd">从光盘安装</link>，
	  或者手工将 distfile 放到 <filename>/usr/ports/distfiles</filename>
	</para>

        <para>实际上从互联网安装 port 和从光盘安装差不多，
	  不同的是从互联网下载distfile，而不是从光盘读取。</para>

        <para>相关步骤是一样的：</para>

        <screen>&prompt.root; <userinput>make install</userinput>
&gt;&gt; lsof_4.57D.freebsd.tar.gz doesn't seem to exist in /usr/ports/distfiles/.
&gt;&gt; Attempting to fetch from ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/distfiles/.
Receiving lsof_4.57D.freebsd.tar.gz (439860 bytes): 100%
439860 bytes transferred in 18.0 seconds (23.90 kBps)
===&gt;  Extracting for lsof-4.57
...
[extraction output snipped]
...
&gt;&gt; Checksum OK for lsof_4.57D.freebsd.tar.gz.
===&gt;  Patching for lsof-4.57
===&gt;  Applying FreeBSD patches for lsof-4.57
===&gt;  Configuring for lsof-4.57
...
[configure output snipped]
...
===&gt;  Building for lsof-4.57
...
[compilation output snipped]
...
===&gt;  Installing for lsof-4.57
...
[installation output snipped]
...
===&gt;   Generating temporary packing list
===&gt;   Compressing manual pages for lsof-4.57
===&gt;   Registering installation for lsof-4.57
===&gt;  SECURITY NOTE: 
      This port has installed the following binaries which execute with
      increased privileges.
&prompt.root;</screen>

        <para>就像您看到的， 唯一区别是有一行告知您系统正在从哪里获得 port 的
	  distfile 的信息。</para>

	<para>ports 系统使用 &man.fetch.1; 去下载文件， 它有很多可以设置的环境变量，
	  其中包括 <envar>FTP_PASSIVE_MODE</envar>、 <envar>FTP_PROXY</envar>，
	  和 <envar>FTP_PASSWORD</envar>。 如果您在防火墙之后，或使用 FTP/HTTP代理，
	  您就可能需要设置它们。 完整的说明请看 &man.fetch.3;。</para>

	<para>当使用者不是所有时间都能连接上网络， 则可以利用 <command>make
	  <maketarget>fetch</maketarget></command>。 您只要在顶层目录
	  (<filename>/usr/ports</filename>) 下运行这个命令，
	  所有需要的文件都将被下载。 这个命令也同样可以在下级类别目录中使用，
	  例如： <filename>/usr/ports/net</filename>。
	  注意， 如果一个port有一些依赖的库或其他 port， 它将 <emphasis>不</emphasis>
	  下载这些依赖的 port 的 distfile 文件， 如果您想获取所有依赖的
	  port 的所有 distfile， 请用 <maketarget>fetch-recursive</maketarget>
	  命令代替 <maketarget>fetch</maketarget>命令。</para>

	<note><para>您可以在一个类别或在顶级目录编译所有的 port， 或者使用上述提到的
	  <command>make <makevar>fetch</makevar></command>命令。 这样是非常危险的，
	  因为有一些port不能并存。 或者有另一种可能， 一些port会安装两个不同的文件，
	  但是却是相同的文件名。</para></note>

	<para>在一些罕见的例子中， 用户可能需要在除了 <makevar>MASTER_SITES</makevar>
	  以外的一个站点(本地已经下载下来的文件)去获得一个文件包。
	  您可以用以下命令不使用 <makevar>MASTER_SITES</makevar>:
  </para>

	<screen>&prompt.root; <userinput>cd /usr/ports/<replaceable>directory</replaceable></userinput>
&prompt.root; <userinput>make MASTER_SITE_OVERRIDE= \
ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/distfiles/ fetch</userinput></screen>

	<para>在这个例子中，我们把
	  <makevar>MASTER_SITES</makevar>这个选项改为了 <hostid
	  role="fqdn">ftp.FreeBSD.org/pub/FreeBSD/ports/distfiles/</hostid>。</para>

	<note><para>一些 port 允许 (或甚至要求) 您指定编译选项来
	  启用/禁用 应用程序中非必需的功能， 一些安全选项，
	  以及其他可以订制的内容。 具有代表性的包括
	  <filename role="package">www/mozilla</filename>、 <filename
	  role="package">security/gpgme</filename>、 以及 <filename
	  role="package">mail/sylpheed-claws</filename>。
	  如果存在这样的选项， 通常会在编译时给出提示。</para></note>
      </sect3>

      <sect3>
        <title>改变默认的 Ports 目录</title>

	<para>一些时候使用不同的 distfiles 和 ports 目录可能很有用
	  (甚至是必要的)。 可以用
	  <makevar>PORTSDIR</makevar> 和 <makevar>PREFIX</makevar>
	  来改变默认的目录。 例如：</para>

	<screen>&prompt.root; <userinput>make PORTSDIR=/usr/home/example/ports install</userinput></screen>

	<para>将把编译
	    <filename>/usr/home/example/ports</filename> 中的 port 并把所有的文件安装到
	    <filename>/usr/local</filename>。</para>

	<screen>&prompt.root; <userinput>make PREFIX=/usr/home/example/local install</userinput></screen>

	<para>将在 <filename>/usr/ports</filename> 编译它并安装到
	  <filename>/usr/home/example/local</filename>。</para>

	<para>当然，</para>

	<screen>&prompt.root; <userinput>make PORTSDIR=../ports PREFIX=../local install</userinput></screen>

	<para>将包含两种设置 (没有办法在这一页把它写完，
	  但您应该已经知道怎么回事了)。</para>

	<para>另外， 这些变量也可以作为环境变量来设置。
	  请参考您的 shell 的联机手册上关于如何设置环境变量的说明。</para>
      </sect3>

      <sect3>
	<title>处理 <command>imake</command></title>

	<para>一些 port 使用 <command>imake</command> (这是
	  X Window 系统的一部分) 不能正常地配合
	  <makevar>PREFIX</makevar>， 它们会坚持把文件安装到
	  <filename>/usr/X11R6</filename> 下面。
	  类似地， 一些 Perl port 会忽略 <makevar>PREFIX</makevar>
	  并把文件安装到 Perl 的目录中。
	  让这些 port 尊重
	  <makevar>PREFIX</makevar> 是困难甚至是不可能的事情。</para>

      </sect3>
    </sect2>

    <sect2 id="ports-removing">
      <title>卸载已经安装的 Ports</title>

      <indexterm>
        <primary>ports</primary>
        <secondary>卸载</secondary>
      </indexterm>
      <para>现在您已经知道如何安装 port， 您可能很想知道如何卸载它们，
        例如您安装了一个之后才意识到装错了。
	我们将卸载前面的例子中安装的那个
	(也就是	<command>lsof</command>， 如果您没有注意过的话)。
        和安装 port 时类似， 第一件事是进入 port 的目录，
	<filename>/usr/ports/sysutils/lsof</filename>。
	之后您就可以卸载 <command>lsof</command> 了。
	这可以通过命令 <command>make deinstall</command> 来完成：</para>

      <screen>&prompt.root; <userinput>cd /usr/ports/sysutils/lsof</userinput>
&prompt.root; <userinput>make deinstall</userinput>
===&gt;  Deinstalling for lsof-4.57</screen>

      <para>这个过程足够地简单。 现在已经从系统上卸载了
	<command>lsof</command>。
        如果您想重新安装它， 可以在
	<filename>/usr/ports/sysutils/lsof</filename> 目录中运行
	<command>make reinstall</command> 来达到目的。</para>

      <para><command>make deinstall</command> 以及 <command>make
        reinstall</command> 在您执行过
        <command>make clean</command> 之后就不能用了。
        如果您在清理目录之后还想删除 port，
        可以用 <link linkend="packages-using">使用手册中的
        Package 相关章节</link> 中介绍的 &man.pkg.delete.1;
        来完成。</para>
    </sect2>

    <sect2 id="ports-disk-space">
      <title>Ports 与磁盘空间</title>

      <indexterm>
        <primary>ports</primary>
        <secondary>磁盘空间</secondary>
      </indexterm>
      <para>使用 Ports Collection 显然会逐渐地吃掉您的磁盘空间。
	由于 ports tree 趋于不断增大， 在构建和安装软件之后，
	您应该通过使用 <command>make
	<makevar>clean</makevar></command>
	来清理包含临时文件的 <filename class="directory">work</filename>
	目录。 这一命令会删除 <filename class="directory">work</filename>，
	因为在您构建并安装完之后它就没用了。 如果已经安装或不再需要，
	您也可以从 <filename class="directory">distfiles</filename> 目录中删除源代码包。</para>

      <para>一些用户还通过把一些不需要的 port 分类放入
	<filename>refuse</filename> 文件来避免下载它们。 这样在运行
	<application>CVSup</application> 时就不会下载这些分类中的文件了。
	关于 <filename>refuse</filename> 的详情请参考 <xref
	linkend="cvsup-refuse-file">。</para>
    </sect2>

    <sect2 id="ports-upgrading">
      <title>升级 Ports</title>

      <indexterm>
	<primary>portupgrade</primary>
      </indexterm>
      <indexterm>
	<primary>ports</primary>
	<secondary>升级</secondary>
      </indexterm>
      <note>
	<para>一旦您更新了 Ports Collection， 在开始升级之前，
	  应该首先检查一下
	  <filename>/usr/ports/UPDATING</filename> 文件。
	  它描述了在升级时可能遇到的问题， 以及因应的步骤。</para>
      </note>

      <para>保持 ports 最新可能是一件乏味的工作。 例如，
	为了更新 port 您需要进入它的目录， 编译， 卸载旧的，
	然后安装新的， 并在之后进行清理。 考虑一下对五个 port
	做这样的升级， 很乏味是不是？ 这是系统管理员需要处理的一大难题，
	而我们现在有了一些能够帮助我们做这件事的工具。
	例如 <filename role="package">sysutils/portupgrade</filename>
	就能够帮助您完成所有这一切！ 只需像其他 port 一样用
	<command>make <makevar>install
	clean</makevar></command> 来安装它就可以了。</para>

      <para>接下来需要通过 <command>pkgdb -F</command>
	命令来创建一个数据库。 这将读取已经安装的 port 并创建一个数据库文件到
	<filename>/var/db/pkg</filename> 目录中。
	接下来执行 <command>portupgrade
	-a</command>， 它会读取这个数据库以及 ports 的
	<filename>INDEX</filename> 文件。 最后，
	<application>portupgrade</application> 将开始下载， 编译，
	备份， 安装并清理更新了的 ports。
	<application>portupgrade</application> 包含了许多的选项，
	最重要的那些将在下面说明。</para>

      <para>如果您只想升级某个具体的应用程序而不是数据库中的记录的所有程序，
	则使用 <command>portupgrade
	<replaceable>pkgname</replaceable></command>，
	如果您认为 <application>portupgrade</application>
	应该升级所有基于那个 port 的软件，
	则需要指定 <option>-r</option>； 而如果使用
	<option>-R</option> 则它用到的所有包也会被升级。</para>

      <para>要使用预编译的 package 而不是 ports 来进行安装， 需要指定
	<option>-P</option>。 如果指定了这个选项，
	<application>portupgrade</application>
	会搜索 <envar>PKG_PATH</envar> 中指定的本地目录，
	如果没有找到， 则从远程站点下载。 如果本地没有找到，
	而且远程站点也没有成功地下载预编译包， 则
	<application>portupgrade</application> 将使用 ports。
	要禁止使用 port， 可以指定 <option>-PP</option>。</para>

      <para>如果只想下载 distfiles (或者， 如果指定了 <option>-P</option>
	的话， 是 packages) 而不想构建或安装任何东西，
	可以使用 <option>-F</option>。
	要了解更多细节， 请参考 &man.portupgrade.1;。</para>

      <note>
	<para>规律性地更新 package 数据库非常重要。 您可以使用
	  <command>pkgdb -F</command> 来修复不一致， 特别是当
	  <application>portupgrade</application> 要求您这么做的时候。 当
	  <application>portupgrade</application> 正在更新数据库时请不要打断它，
	  因为这将做的结果将是不一致的数据库。</para>
      </note>

      <para>还有一些其他工具能够完成类似的以及其他一些任务， 请查看
	<filename>ports/sysutils</filename> 目录中是否有您需要的。</para>
    </sect2>
  </sect1>

  <sect1 id="ports-nextsteps">
    <title>安装之后的待办事宜
</title>

    <para>通常，您通过port安装完一个软件后,可以阅读它带的一些文档(如果它包含文档的话)，
    或需要编辑它的配置文件，来确保这个软件的运行，
    或在机器启动的时候启动(如果它是一个服务的话)，等等。</para>

    <para>对于不同的软件有着不同的配置步骤。不管怎样，
    如果您装好了一个软件，但是不知道下一步怎么办的时候，
    这些小技巧可能可以帮助您:</para>

    <itemizedlist>
      <listitem>
	<para>使用 &man.pkg.info.1; 命令，它能找到安装了哪些文件，以及装在哪里。
	举个例子，如果您安装了 FooPackage version 1.0.0, 那么这个命令</para>

	<screen>&prompt.root; <userinput>pkg_info -L foopackage-1.0.0 | less</userinput></screen>

	<para>将显示这个软件包安装的所有文件，您要特别注意在<filename>man/</filename>目录里面的文件，
	它们可能是手册，<filename>etc/</filename>目录里面的配置文件，以及 <filename>doc/</filename>目录下面更多的文档。</para>

	<para>如果您不确定已经安装好的软件版本，您可以使用这样的命令</para>

	<screen>&prompt.root; <userinput>pkg_info | grep -i <replaceable>foopackage</replaceable></userinput></screen>

	<para>它将会找到所有已安装的软件包名字中包含<replaceable>foopackage</replaceable>
	  的软件包。 对于其他的查找， 您只需要在命令行中替换
	  <replaceable>foopackage</replaceable>。</para>
      </listitem>

      <listitem>
	<para>一旦一些软件手册已被您确认安装，您可以使用 &man.man.1;  查看它。
	  同样的，如果有的话，您还可以完整的查看一边配置文件的示例，以及任何额外的文档。</para>
      </listitem>

      <listitem>
	<para>如果应用软件有网站, 您还可以从网站上找到文档，常见问题的解答，或其他更多。
	  如果您不知道它们的网站地址，请使用下面的命令</para>

	<screen>&prompt.root; <userinput>pkg_info <replaceable>foopackage-1.0.0</replaceable></userinput></screen>
	
	<para>一个 <literal>WWW:</literal> 行, 如果它存在，
	  它将提供一个这个应用程序的网站URL.</para>
      </listitem>

      <listitem>
	<para>Ports 如果需要在服务器启动时运行(就像互联网服务器)，
	  它通常会把一个脚本的样例放入
	  <filename>/usr/local/etc/rc.d</filename> 目录。为了保证正确性，
	  您可以查看这个脚本， 并编辑或更改这个脚本的名字。 详情请看<link
	  linkend="configtuning-starting-services">启动服务</link>。</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="ports-broken">
    <title>如何处理坏掉的 Ports</title>

      <para>如果您发现某个 port 无法正常工作，
        有几件事值得尝试， 包括：</para>

      <orderedlist>
        <listitem>
	  <para>修好它！  <ulink
	    url="&url.books.porters-handbook;/index.html">Porter
	    手册</ulink> 中包括了关于
	    <quote>Ports</quote> 基础设施的详细信息，
	    它们能够帮助您修好有问题的 port 甚至提交自己的 port！</para>
	</listitem>

	<listitem>
	  <para><emphasis>通过电子邮件</emphasis> &mdash; 抱怨！
	    首先发邮件给 port 的维护人员 (maintainer)。 使用
	    <command>make maintainer</command> 或阅读
	    <filename>Makefile</filename> 都可以找到维护人员的电子邮件地址。
	    请记得把 port 的名字和版本写在邮件里
	    (<filename>Makefile</filename> 中的
	    <literal>&dollar;FreeBSD:</literal>这一行) 并把错误输出的头几行发给 maintainer。
	    如果维护人员没有回应您的邮件， 则可以使用 &man.send-pr.1;
	    来提交问题报告。</para>
	</listitem>

	<listitem>
	  <para>从较近的 FTP 站点下载一个编译好的安装包。
	    <quote>中央的</quote> package collection 在 <hostid
	    role="fqdn">ftp.FreeBSD.org</hostid> 的 <ulink
	    url="ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/packages/">packages
	    目录中</ulink>， 但 <emphasis>在此之前</emphasis>
	    一定记得先看看本地镜像上是否已经有了！
	    通常情况下这些安装包都可以直接使用，
	    而且应该比自行编译快一些。
	    安装过程本身可以通过 &man.pkg.add.1; 来完成。</para>
	</listitem>
      </orderedlist>
  </sect1>

</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
