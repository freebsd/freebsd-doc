<!--
     The FreeBSD Documentation Project
     The FreeBSD Simplified Chinese Documentation Project

     Original Revision: 1.292
     $FreeBSD$
-->

<chapter id="ports">
  <title>安装应用程序: Packages 和 Ports</title>

  <sect1 id="ports-synopsis">
    <title>概述</title>

    <indexterm><primary>ports</primary></indexterm>
    <indexterm><primary>packages</primary></indexterm>
    <para>FreeBSD 将许多系统工具捆绑作为基本系统的一部分。 然而，
      要完成实际的工作， 可能还需要安装更多的第三方应用。 FreeBSD 提供了两种补充的技术，
      用以在您的系统中安装第三方软件： FreeBSD Ports 套件 (用于从源代码安装)，
      以及 packages (用以从预编译的二进制版本安装)。
      这两种方法都可以用于从本地介质， 或从网上直接安装您喜欢的应用程序的最新版本。</para>

    <para>读完这章，您将了解到:</para>

    <itemizedlist>
      <listitem>
	<para>如何安装第三方的二进制软件包。</para>
      </listitem>
      <listitem>
	<para>如何使用 ports 套件从源代码构建第三方软件。</para>
      </listitem>
      <listitem>
	<para>如何删除先前安装的软件包。</para>
      </listitem>
      <listitem>
	<para>如何改动Ports Collection里面的一些参数，定制软件使用。</para>
      </listitem>
      <listitem>
	<para>如何找到您需要的软件包。</para>
      </listitem>
      <listitem>
	<para>如何升级您的应用软件。</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="ports-overview">
    <title>软件安装预览</title>

    <para>如果您以前使用过 &unix; 系统，那典型的第三方软件安装的步骤是像下面描述的：</para>

    <procedure>
      <step>
	<para>下载这个软件，软件的发行版可能是源代码格式，或是一个二进制包。</para>
      </step>

      <step>
	<para>解开软件(其中代表性的是用 &man.compress.1;, &man.gzip.1;, 或
	  &man.bzip2.1; 压缩过的tar包)。</para>
      </step>

      <step>
	<para>阅读相关文档，了解如何安装。 (多半一个文件名是<filename>INSTALL</filename>或<filename>README</filename>，
	  或在<filename>doc/</filename> 目录下的一些文档)</para>
      </step>

      <step>
	<para>如果软件是以源代码形式发布的，那就需要编译它。可能需要编辑一个
	  <filename>Makefile</filename>文件, 或运行
	  <command>configure</command>脚本，和其他的一些工作。</para>
      </step>

      <step>
	<para>测试和安装软件。</para>
      </step>
    </procedure>

    <para>如果一切顺利的话，就这么简单。如果您在安装一个软件包时发生一些错误，
      您可能需要编辑一下它的代码，以使它能正常工作。</para>

    <para>您可以继续使用 <quote>传统的</quote>方式安装软件。 然而， FreeBSD
      提供了两种技术： packages 和 ports。 就在写这篇文章的时候，
      已经有超过 &os.numports; 个第三方的应用程序可以使用了。</para>

    <para>对于任意一个应用程序包，是一个可以下载的FreeBSD package文件。这个
      FreeBSD package包含了编译好的的副本， 还有一些配置文件或文档。
      一个下载的包文件可以用 FreeBSD 的包管理命令来操作， 例如
      &man.pkg.add.1;，&man.pkg.delete.1;, &man.pkg.info.1; 等等。
      可以使用一个简单的命令安装一个新的应用程序。</para>

    <para>一个FreeBSD的port是一个可以自动从源代码编译成应用程序的文件集合。</para>

    <para>记住，如果您自己来编译的话，需要执行很多步的操作 (解压， 补丁， 编译，
      安装)。 这些整理 port 的文件集合包含了系统需要完成这个工作的必需信息。
      您可以运行一些简单的命令， 那些源代码就可以自动地下载， 解开， 打补丁，
      编译， 直至安装完成。</para>

    <para>实际上，ports 系统也能做出被 <command>pkg_add</command>
      的程序包和不久就要讲到的其他包管理命令来安装的软件包。</para>

    <para>Packages 和 ports 是互相 <emphasis>依赖</emphasis> 的。
      假设您想安装一个依赖于已经安装的特定库的应用程序。
      应用程序和那个库都已经应用于 FreeBSD ports 和 packages。
      如果您使用 <command></command> 命令或 ports 系统来添加应用程序，
      两个都必须注意库是否被安装， 如果没有， 它会自动先安装库。</para>

    <para>这里给出的两种技术是很相似的，您可能会奇怪为什么 FreeBSD
      会弄出这两种技术。 其实， packages 和 ports 都有它们自己的长处，
      使用哪一种完全取决于您自己的喜好。</para>

    <itemizedlist>
      <title>Package Benefits</title>

      <listitem>
	<para>一个压缩的 package 通常要比一个压缩的包含源代码的应用程序小得多。</para>
      </listitem>

      <listitem>
	<para>package 不需要进行额外的编译。 对于大型应用程序如
	  <application>Mozilla</application>， <application>KDE</application> 或
	  <application>GNOME</application> 来说这显得尤为重要，
	  特别是在您的系统资源比较差的情况下。</para>
      </listitem>

      <listitem>
	<para>package不需要您知道如何在FreeBSD上编译软件的详细过程。</para>
      </listitem>
    </itemizedlist>

    <itemizedlist>
      <title>Ports Benefits</title>

      <listitem>
	<para>package 在编译时通常使用比较保守的选项，
	  这是为了保证它们能够运行在大多数的系统上。 通过从 port 安装，
	  您可以细微调整编译选项来产生适合于处理器的代码 (针对于 Pentium 4
	  或 AMD 的 Athlon CPU)。</para>
      </listitem>

      <listitem>
	<para>一些软件包已经把与它们相关的能做和不能做的事情的选项都编译进去了。
	  例如， <application>Apache</application> 可能就配置了很多的选项。
	  从 port 中安装时， 您不一定要接受默认的选项， 可以自己来设置。</para>

	<para>在一些例子中，一个软件有不同的配置存在多个package。 例如，
	  <application>Ghostscript</application>存在
	  <filename>ghostscript</filename> package 和
	  <filename>ghostscript-nox11</filename> package两个配置package，
	  这取决于您是否安装了X11服务器。 这样的调整对package是可能的，
	  但如果一个应用程序有超过一个或两个不同的编译时间选项时， 就不行了。</para>
      </listitem>

      <listitem>
	<para>一些软件的许可条件禁止采用二进制形式发行。 它们必须带上源代码。</para>
      </listitem>

      <listitem>
	<para>一些人不信任二进制发行形式。 至少有了源代码， (理论上)
	  可以亲自阅读它，寻找潜在的问题。</para>
      </listitem>

      <listitem>
	<para>如果您要自己对软件打补丁，您就需要有源代码。</para>
      </listitem>

      <listitem>
	<para>一些人喜欢整天围着源代码转， 所以他们喜欢亲自阅读源代码，
	  修改源代码等等。</para>
      </listitem>
    </itemizedlist>

    <para>保持更新 ports， 订阅邮件列表 &a.ports; 和递交错误报告 &a.ports-bugs;。</para>

    <warning>
      <para>安装任何应用程序之前， 应首先检查 <ulink
	url="http://vuxml.freebsd.org/"></ulink>
	上是否有关于您所安装的应用程序的安全问题报告。</para>

      <para>您也可以安装 <filename
	role="package">ports-mgmt/portaudit</filename>，
	它能够自动地检查已经安装的应用程序的漏洞；
	此外， 在您安装程序之前它也会首先检查是否存在已知的漏洞。
	另外， 您也可以使用 <command>portaudit
	-F -a</command> 这个命令在安装了某个软件包之后作出检查。</para>
    </warning>

    <para>这章的其余部分将介绍在 FreeBSD 上如何使用 packages 和 ports 来安装和管理第三方软件。</para>
  </sect1>

  <sect1 id="ports-finding-applications">
    <title>寻找您要的应用程序</title>

    <para>在您安装任何应用程序之前，需要知道您需要什么，那个应用程序叫什么。</para>

    <para>FreeBSD中可用的应用程序正在不断地增长着。幸运的是，
      有许多方法可以找到您所需要的程序:</para>

    <itemizedlist>
      <listitem>
	<para>FreeBSD站点上有一个可以搜索到的当前所有可用的应用程序列表，在 <ulink
	  url="&url.base;/ports/index.html">http://www.FreeBSD.org/ports/</ulink>。
	  它分很多种类，您既可以通过程序的名称来搜索(如果您知道名字)，
	  也可以在分类中列出所有可用的应用程序。</para>
      </listitem>

      <indexterm><primary>FreshPorts</primary></indexterm>

      <listitem>
	<para>Dan Langille 维护着网站 FreshPorts，在 <ulink
	  url="http://www.FreshPorts.org/"></ulink>。 FreshPort时刻 <quote>追踪</quote>
	  着在 ports 中应用程序的变化。当有任何程序被升级时，他们就会发 email 提醒您。</para>
      </listitem>

      <indexterm><primary>FreshMeat</primary></indexterm>

      <listitem>
	<para>如果您不知道您想要的应用程序的名字，可以通过 (<ulink
	  url="http://www.freshmeat.net/"></ulink>) 网站来查找，
	  如果找到了应用程序， 您可以回 FreeBSD 的主站去看一下这个应用程序是否已经被
	  port 进去了。
	</para>
      </listitem>

      <listitem>
	<para>如果您知道一个port的准确名字， 但需要知道在哪个类别里面能找到它，您可以使用
        &man.whereis.1; 这个命令。简单地输入 <command>whereis
        <replaceable>file</replaceable></command>，
        <replaceable>file</replaceable> 就是您想安装的程序名字。
        如果系统找到了它， 您将被告知在它在哪里， 例如:</para>

      <screen>&prompt.root; <userinput>whereis lsof</userinput>
lsof: /usr/ports/sysutils/lsof</screen>

      <para>结果告诉我们这个命令<command>lsof</command> (一个系统配置程序)可以在
	<filename>/usr/ports/sysutils/lsof</filename>目录中找到。</para></listitem>

      <listitem>
	<para>你可以使用简单的 &man.echo.1; 
	  语句来查找某个 port 是否存在于 ports 树中。
	  例如：</para>

	<screen>&prompt.root; <userinput>echo /usr/ports/*/*lsof*</userinput>
/usr/ports/sysutils/lsof</screen>

	<para>Note that this will return any matched files downloaded into the
	  <filename class="directory">/usr/ports/distfiles</filename>
	  directory.</para>
	<para>请注意这条命令将会返回下载到
	  <filename class="directory">/usr/ports/distfiles</filename>
	  目录中所有符合条件的文件。</para>
      </listitem>

      <listitem>
	<para>还有另外的一个寻找您需要的port的方法--是用ports collecton
	内嵌的搜索机制。要使用这个搜索, 您需要先到
        <filename>/usr/ports</filename>目录下面。 在那个目录里面，
        运行<command>make <maketarget>search</maketarget>
        name=<replaceable>program-name</replaceable></command>，
        <replaceable>program-name</replaceable> 就是您想寻找的程序名字。
        举个例子， 如果您想找 <command>lsof</command>：</para>

      <screen>&prompt.root; <userinput>cd /usr/ports</userinput>
&prompt.root; <userinput>make search name=lsof</userinput>
Port:   lsof-4.56.4
Path:   /usr/ports/sysutils/lsof
Info:   Lists information about open files (similar to fstat(1))
Maint:  obrien@FreeBSD.org
Index:  sysutils
B-deps: 
R-deps: </screen>

      <para>在输出的内容里面您要特别注意包含 <quote>Path:</quote>
        的这行将告诉您在哪里可以找到这个 port。 如果要安装此 port，
        那其他输出的信息不是必须的， 但是还是显示输出了。</para>

      <para>为了更深入的搜索，您还可以用 <command>make
       <maketarget>search</maketarget> key=<replaceable>string</replaceable></command>，
       <replaceable>string</replaceable>就是您想搜索的部分内容。
       它将搜索port的名字、 注释， 描述和从属关系，
       如果您不知道您想搜索的程序名字，
       可以利用它搜索一些关键主题来找到您需要的。</para>

      <para>上面说的这些方法， 搜索的关键字没有大小写区分的。
       搜索 <quote>LSOF</quote>的结果将和搜索<quote>lsof</quote>的结果一样。</para>
      </listitem>

    </itemizedlist>
  </sect1>

  <sect1 id="packages-using">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Chern</firstname>
	  <surname>Lee</surname>
	  <contrib>Contributed by </contrib>
        </author>
      </authorgroup>
    <!-- 30 Mar 2001 -->
    </sect1info>

    <title>使用 Package 系统</title>

    <para>在 FreeBSD 系统上有几种不同的工具用来管理 package：</para>

    <itemizedlist>
      <listitem><para><command>sysinstall</command> 工具可以在正在运行的系统上运行，
        以完成安装、 删除和列出可用的以及已经安装的预编译软件包的任务。 如欲了解进一步信息，
	请参阅 <xref
        linkend="packages">。</para></listitem>
      <listitem><para>这一节余下的部分将介绍用于管理预编译软件包的命令行工具。</para></listitem>
    </itemizedlist>

    <sect2>
      <title>一个 package 的安装</title>
      <indexterm>
        <primary>packages</primary>
        <secondary>installing</secondary>
      </indexterm>

      <indexterm>
        <primary><command>pkg_add</command></primary>
      </indexterm>
      <para>您可以用 &man.pkg.add.1;
	这个命令从本地文件或网络上的服务器来安装一个 FreeBSD 软件包。</para>

      <example>
        <title>在本地手动下载一个package,并安装它</title>

        <screen>&prompt.root; <userinput>ftp -a <replaceable>ftp2.FreeBSD.org</replaceable></userinput>
Connected to ftp2.FreeBSD.org.
220 ftp2.FreeBSD.org FTP server (Version 6.00LS) ready.
331 Guest login ok, send your email address as password.
230-
230-     This machine is in Vienna, VA, USA, hosted by Verio.
230-         Questions? E-mail freebsd@vienna.verio.net.
230-
230-
230 Guest login ok, access restrictions apply.
Remote system type is UNIX.
Using binary mode to transfer files.
<prompt>ftp></prompt> <userinput>cd /pub/FreeBSD/ports/packages/sysutils/</userinput>
250 CWD command successful.
<prompt>ftp></prompt> <userinput>get lsof-4.56.4.tgz</userinput>
local: lsof-4.56.4.tgz remote: lsof-4.56.4.tgz
200 PORT command successful.
150 Opening BINARY mode data connection for 'lsof-4.56.4.tgz' (92375 bytes).
100% |**************************************************| 92375       00:00 ETA
226 Transfer complete.
92375 bytes received in 5.60 seconds (16.11 KB/s)
<prompt>ftp></prompt> <userinput>exit</userinput>
&prompt.root; <userinput>pkg_add <replaceable>lsof-4.56.4.tgz</replaceable></userinput></screen>
      </example>

      <para>如果您没有本地package的安装盘 (如 FreeBSD CD-ROM)，
        可以执行 &man.pkg.add.1; 命令并加上 <option>-r</option> 选项。
        这将迫使程序自动决定目标文件的正确格式和版本，
        然后自动从一个 FTP 站点寻找和安装 package。</para>

      <indexterm>
        <primary><command>pkg_add</command></primary></indexterm>
      <screen>&prompt.root; <userinput>pkg_add -r <replaceable>lsof</replaceable></userinput></screen>

      <para>上面的例子将下载正确的package， 而不需要用户的干预就可以安装。
        如果您想指定 FreeBSD package 的镜像站点， 替换主站点， 就必须相应地设置
        <envar>PACKAGESITE</envar> 这个环境变量， 覆盖原来的设置。
        &man.pkg.add.1; 使用 &man.fetch.3; 下载文件， 可以使用多种环境变量，
        包含 <envar>FTP_PASSIVE_MODE</envar>、 <envar>FTP_PROXY</envar>，
        和 <envar>FTP_PASSWORD</envar>。 如果您使用 FTP/HTTP
        代理或在防火墙后面， 您可能需要设置这些环境变量。
        详细的列表请参考 &man.fetch.3;。上述例子中用 <literal>lsof</literal>
        替代了 <literal>lsof-4.56.4</literal>。 当使用远程安装 Package
        的时候软件名字不需要包含版本号。 &man.pkg.add.1;
        将自动的找到这个软件最新的版本。</para>

      <note>
	<para>如果您使用 &os.current; 或 &os.stable;版本的FreeBSD， &man.pkg.add.1;
	  将下载您的应用软件的最新版本。 如果您使用 -RELEASE 版本的
	  FreeBSD, 它将会获得与您的版本相应的软件包版本。
	  您可以通过修改环境变量 <envar>PACKAGESITE</envar>
	  来改变这一行为。 例如， 如果您运行 &os;&nbsp;8.1-RELEASE
	  系统， 默认情况下 &man.pkg.add.1; 将尝试从
	  <literal>ftp://ftp.freebsd.org/pub/FreeBSD/ports/i386/packages-8.1-release/Latest/</literal>
	  下载预编译的软件包。 如果您希望强制 &man.pkg.add.1; 下载
	  &os;&nbsp;8-STABLE 的软件包， 则可以将 <envar>PACKAGESITE</envar>
	  设置为
	  <literal>ftp://ftp.freebsd.org/pub/FreeBSD/ports/i386/packages-8-stable/Latest/</literal>。
	</para>
      </note>

      <para>软件包采用 <filename>.tgz</filename> 和 <filename>.tbz</filename>
          两种格式。您可以在 <ulink
          url="ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/packages/"></ulink>
          下面或从 FreeBSD 的发行光盘找到， 它在每一个 4CD 的 FreeBSD 发行版的
          <filename>/packages</filename>目录中。 软件包的设计规划与
          <filename>/usr/ports</filename> 树一致。 每个分类都有自己的目录，
          所有的软件包可以在目录 <filename>All</filename>中找到。
      </para>

      <para>软件包系统的目录结构与ports的设计规划一致； 它们共同构成了整个 package/port。
      </para>

    </sect2>

    <sect2>
      <title>软件包的管理</title>

      <indexterm>
        <primary>packages</primary>
        <secondary>managing</secondary>
      </indexterm>
      <para>&man.pkg.info.1; 是用于列出已安装的所有软件包列表和描述的程序。
      </para>

      <indexterm>
        <primary><command>pkg_info</command></primary>
      </indexterm>
      <screen>&prompt.root; <userinput>pkg_info</userinput>
cvsup-16.1          A general network file distribution system optimized for CV
docbook-1.2         Meta-port for the different versions of the DocBook DTD
...</screen>
      <para>&man.pkg.version.1;是一个用来统计所有安装的软件包版本的工具。
        它可以用来比较本地 package 的版本与 ports 目录中的当前版本是否一致。
      </para> 
      <indexterm>
        <primary><command>pkg_version</command></primary>
      </indexterm>
        <screen>&prompt.root; <userinput>pkg_version</userinput>
cvsup                       =
docbook                     =
...</screen>

      <para>在第二列的符号指出了安装版本的相关时间和本地ports目录树中可用的版本。</para>

      <informaltable frame="none" pgwide="1">
        <tgroup cols="2">
	  <thead>
            <row>
              <entry>符号</entry>
              <entry>含义</entry>
            </row>
          </thead>

 	  <tbody>
  	    <row>
	    <entry>=</entry> <entry>在本地ports树中与已安装的软件包版本相匹配。</entry>
  	    </row>

        <row><entry>&lt;</entry>
	<entry>已安装的版本要比在ports树中的版本旧。</entry>
	</row>

        <row><entry>&gt;</entry><entry>已安装的版本要比在ports树中的版本新
          (本地的port树可能没有更新)。</entry></row>

        <row><entry>?</entry><entry> 已安装的软件包无法在ports索引中找到。
          (可能发生这种事情，举个例子， 您早先安装的一个 port 从 port
          树中移出或改名了)</entry></row>

        <row><entry>*</entry><entry>软件包有很多版本。</entry></row>

	<row><entry>!</entry><entry>已安装的软件包在索引中存有记录，
	    但是由于某些原因 <command>pkg_version</command>
	    无法比较已安装的软件包与索引中相对应的版本号。</entry></row>

	</tbody>
	</tgroup>
    </informaltable>
    </sect2>

    <sect2>
      <title>删除一个软件包</title>
      <indexterm>
        <primary><command>pkg_delete</command></primary>
      </indexterm>
      <indexterm>
        <primary>packages</primary>
        <secondary>deleting</secondary>
      </indexterm>
      <para>要删除先前安装的软件package，只要使用&man.pkg.delete.1; 工具。
	
      </para>

      <screen>&prompt.root; <userinput>pkg_delete <replaceable>xchat-1.7.1</replaceable></userinput></screen>

      <para>需要注意的是， &man.pkg.delete.1; 需要提供完整的包名； 如果您只是指定了类似
	<replaceable>xchat</replaceable> 而不是
	<replaceable>xchat-1.7.1</replaceable> 这样的名字， 则它将拒绝执行操作。
	不过， 您可以使用 &man.pkg.version.1; 来了解安装的 package 的版本。
	除此之外， 也可以使用通配符：</para>

      <screen>&prompt.root; <userinput>pkg_delete <replaceable>xchat\*</replaceable></userinput></screen>

      <para>这时， 所有名字以
	<literal>xchat</literal> 开头的 package 都会被删掉。</para>
    </sect2>

    <sect2>
      <title>其它</title>
      <para>所有已安装的 package 信息都保存在 <filename>/var/db/pkg</filename>
        目录下。 安装文件的列表和每个 package
        的内容和描述都能在这个目录的相关文件中找到。
      </para>
    </sect2>
  </sect1>

  <sect1 id="ports-using">
    <title>使用Ports Collection</title>

    <para>下面的几个小节中， 给出了关于如何使用
      Ports 套件来在您的系统中安装或卸载程序的介绍。 关于可用的 <command>make</command>
      targets 以及环境变量的介绍， 可以在 &man.ports.7; 中找到。</para>

    <sect2 id="ports-tree">
      <title>获得Ports Collection</title>

      <para>在您能使用 ports 之前， 您必须先获得 Ports Collection &mdash;
	本质上是 <filename>/usr/ports</filename> 目录下的一堆
	<filename>Makefile</filename>、 补丁和描述文件。
      </para>

      <para>在您安装 FreeBSD 系统的时候， <application>sysinstall</application>
	会询问您是否需要安装 Ports Collection。 如果您选择 no，
	那您可以用下面的指令来安装 Ports Collection：</para>

      <procedure>
	<title>CVSup 方法</title>

	<para>保持您本地 Ports 套件最新的一种快捷的方法，
	  是使用 <application>CVSup</application> 协议来进行更新。
	  如果您希望了解更多关于 <application>CVSup</application> 的细节， 请参见
	  <link linkend="cvsup">使用 CVSup</link>。</para>

	<note>
	  <para>在 &os; 系统里对 <application>CVSup</application>
	    的实现叫作 <application>csup</application>。</para>
	</note>

	<para>在首次运行 <application>csup</application> 之前，
	  务必确认 <filename class="directory">/usr/ports</filename>
	  是空的！ 如果您之前已经用其他地方安装了一份 Ports 套件，
	  则 <application>csup</application>
	  可能不会自动删除已经在上游服务器上删除掉的补丁文件。</para>

	<step>
	  <para>运行 <command>csup</command>:</para>

	  <screen>&prompt.root; <userinput>csup -L 2 -h <replaceable>cvsup.FreeBSD.org</replaceable> /usr/share/examples/cvsup/ports-supfile</userinput></screen>

	  <para>将
	    <replaceable>cvsup.FreeBSD.org</replaceable> 改为离您较近的
	    <application>CVSup</application> 服务器。 请参见
	    <link linkend="cvsup-mirrors">CVSup 镜像</link> (<xref
	    linkend="cvsup-mirrors">) 中的镜像站点完整列表。</para>

	  <note>
	    <para>有时可能希望使用自己的
	      <filename>ports-supfile</filename>， 比如说，
	      不想每次都通过命令行来指定所使用的 <application>CVSup</application>
	      服务器。</para>

	    <procedure>
	      <step>
		<para>这种情况下， 需要以 <username>root</username> 身份将
		  <filename>/usr/share/examples/cvsup/ports-supfile</filename>
		  复制到新的位置， 例如
		  <filename>/root</filename> 或您的主目录。</para>
	      </step>

	      <step>
		<para>编辑 <filename>ports-supfile</filename>。</para>
	      </step>

	      <step>
		<para>把
		  <replaceable>CHANGE_THIS.FreeBSD.org</replaceable>
		  修改成离您较近的 <application>CVSup</application> 服务器。
		  可以参考 <link linkend="cvsup-mirrors">CVSup
		  镜像</link> (<xref linkend="cvsup-mirrors">)
		  中的镜像站点完整列表。</para>
	      </step>

	      <step>
		<para>接下来按如下的方式运行 <command>csup</command>：</para>

		<screen>&prompt.root; <userinput>csup -L 2 <replaceable>/root/ports-supfile</replaceable></userinput></screen>
	      </step>
	    </procedure>
	  </note>
	</step>

	<step>
	  <para>此后运行 &man.csup.1; 命令将下载最近所进行的改动，
	    并将它们应用到您的 Ports Collection 上，
	    不过这一过程并不重新联编您系统上的 ports。</para>
	</step>
      </procedure>

      <procedure>
	<title>Portsnap 方式</title>

	<para><application>Portsnap</application> 是用于发布 Ports 套件的另一套系统。
	  请参阅 <link linkend="updating-upgrading-portsnap">使用 Portsnap</link>
	  以了解关于 <application>Portsnap</application>
	  功能更详细的介绍。</para>

	<step>
	  <para>下载压缩的 Ports 套件快照到
	    <filename class="directory">/var/db/portsnap</filename>。
	    您可以根据需要在这之后关闭 Internet 连接。</para>

	  <screen>&prompt.root; <userinput>portsnap fetch</userinput></screen>
	</step>

	<step>
	  <para>假如您是首次运行 <application>Portsnap</application>，
	    则需要将快照释放到 <filename
	    class="directory">/usr/ports</filename>：
	  </para>

	  <screen>&prompt.root; <userinput>portsnap extract</userinput></screen>

	  <para>如果您已经有装好的 <filename
	    class="directory">/usr/ports</filename> 而您只想更新，
	    则应执行下面的命令：</para>

	  <screen>&prompt.root; <userinput>portsnap update</userinput></screen>
	</step>

      </procedure>

      <procedure>
	<title>Sysinstall 方式</title>

	<para>这种方法需要使用 <application>sysinstall</application>
	  从安装介质上安装 Ports 套件。 注意， 安装的将是发布发行版时的旧版 Ports
	  套件。 如果您能访问 Internet， 应使用前面介绍的方法之一。</para>

	<step>
	  <para>以 <username>root</username> 身份运行
	    <command>sysinstall</command>：</para>

	  <screen>&prompt.root; <userinput>sysinstall</userinput></screen>
	</step>

	<step>
	  <para>用光标向下选择 <guimenuitem>Configure</guimenuitem>，
	    并按 <keycap>Enter</keycap>。</para>
	</step>

	<step>
	  <para>向下并选择
	    <guimenuitem>Distributions</guimenuitem>， 按
	    <keycap>Enter</keycap>。</para>
	</step>

	<step>
	  <para>选择 <guimenuitem>ports</guimenuitem>， 并按
	    <keycap>Space</keycap>。</para>
	</step>

	<step>
	  <para>选择 <guimenuitem>Exit</guimenuitem>， 并按
	    <keycap>Enter</keycap>。</para>
	</step>

	<step>
	  <para>选择所希望的安装介质， 例如 CDROM、
	    FTP， 等等。</para>
	</step>

	<step>
	  <para>选择 <guimenuitem>Exit</guimenuitem> 并按
	    <keycap>Enter</keycap>。</para>
	</step>

	<step>
	  <para>按 <keycap>X</keycap> 退出
	    <application>sysinstall</application>。</para>
	</step>
      </procedure>
    </sect2>

    <sect2 id="ports-skeleton">
      <title>安装 Ports</title>

      <indexterm>
        <primary>ports</primary>
        <secondary>安装</secondary>
      </indexterm>
      <para>当提到 Ports Collection 时，
        第一个要说明的就是何谓 <quote>skeleton</quote>。 简单地说，
        port skeleton 是让一个程序在 FreeBSD
        上简洁地编译并安装的所需文件的最小组合。 每个 port skeleton 包含：</para>

      <itemizedlist>
	<listitem>
	  <para>一个 <filename>Makefile</filename>。 <filename>Makefile</filename>
	    包括好几个部分， 指出应用程序是如何编译以及将被安装在系统的哪些地方。
	  </para>
	</listitem>

	<listitem>
	  <para>一个 <filename>distinfo</filename> 文件。这个文件包括这些信息：
	    这些文件用来对下载后的文件校验和进行检查
	    (使用 &man.sha256.1;)，
	    来确保在下载过程中文件没有被破坏。
	</para>
	</listitem>

	<listitem>
	  <para>一个 <filename>files</filename> 目录。 这个目录包括在
	    FreeBSD 系统上编译和安装程序需要用到的补丁。
	    这些补丁基本上都是些小文件， 指出特定文件作了哪些修正。
	    它们都是纯文本的的格式，基本上是这样的
	    <quote>删除第 10 行</quote> 或
	    <quote>将第 26 行改为这样 ...</quote>，
	    补丁文件也被称作 <quote>diffs</quote>，
	    他们由 &man.diff.1; 程序生成。
	 </para>

	  <para>这个目录也包含了在编译 port 时要用到的其它文件。</para>
	</listitem>

	<listitem>
	  <para>一个 <filename>pkg-descr</filename> 文件。
	    这是一个提供更多细节，有软件的多行描述。</para>
	</listitem>

	<listitem>
	  <para>一个 <filename>pkg-plist</filename> 文件。
	    这是即将被安装的所有文件的列表。它告诉 ports
	    系统在卸载时需要删除哪些文件。</para>
	</listitem>
      </itemizedlist>

      <para>一些ports还有些其它的文件， 例如
        <filename>pkg-message</filename>。 ports
        系统在一些特殊情况下会用到这些文件。
        如果您想知道这些文件更多的细节以及 ports 的概要， 请参阅
        <ulink url="&url.books.porters-handbook;/index.html">FreeBSD Porter's Handbook</ulink>。</para>

      <para>port里面包含着如何编译源代码的指令， 但不包含真正的源代码。 您可以在网上或
        CD-ROM 上获得源代码。 源代码可能被开发者发布成任何格式。
        一般来说应该是一个被 tar 和 gzip 过的文件，
        或者是被一些其他的工具压缩或未压缩的文件。
        ports中这个程序源代码标示文件叫 <quote>distfile</quote>，
        安装 &os; port的方法还不止这两种。</para>

      <note>
        <para>您必须使用 <username>root</username> 用户登录后安装 ports。</para>
      </note>

      <warning>
	<para>在安装任何 port 之前， 应该首先确保已经更新到了最新的
	  Ports Collection， 并检查 <ulink
	  url="http://vuxml.freebsd.org/"></ulink> 中是否有与那个
	  port 有关的安全问题。</para>

	<para>在安装应用程序之前， 可以使用
	  <application>portaudit</application> 来自动地检查是否存在已知的安全问题。
	  这个工具同样可以在
	  Ports Collection (<filename
	  role="package">ports-mgmt/portaudit</filename>) 中找到。
	  在安装新的 port 之前， 可以考虑先运行一下
	  <command>portaudit -F</command> 来抓取最新的漏洞数据库。
	  在每天的周期性系统安全检察时， 数据库会被自动更新，
	  并且会在这之后实施安全审计。
	  欲了解进一步的情况，请参阅 &man.portaudit.1; 和 &man.periodic.8;。</para>
      </warning>

      <para>Ports 套件假定您有可用的
	Internet 连接。 如果您没有， 则需要将
	distfile 手工放到 <filename>/usr/ports/distfiles</filename>
	中。</para>

	<para>要开始操作， 首先进入要安装 port 的目录：</para>

        <screen>&prompt.root; <userinput>cd /usr/ports/sysutils/lsof</userinput></screen>

        <para>一旦进入了 <filename>lsof</filename> 的目录，您将会看到这个port的结构。
	  下一步就是 make，或说 <quote>联编</quote> 这个 port。
	  只需在命令行简单地输入 <command>make</command> 命令就可轻松完成这一工作。
	  做好之后，您可以看到下面的信息：</para>

        <screen>&prompt.root; <userinput>make</userinput>
&gt;&gt; lsof_4.57D.freebsd.tar.gz doesn't seem to exist in /usr/ports/distfiles/.
&gt;&gt; Attempting to fetch from ftp://lsof.itap.purdue.edu/pub/tools/unix/lsof/.
===&gt;  Extracting for lsof-4.57
...
[extraction output snipped]
...
&gt;&gt; Checksum OK for lsof_4.57D.freebsd.tar.gz.
===&gt;  Patching for lsof-4.57
===&gt;  Applying FreeBSD patches for lsof-4.57
===&gt;  Configuring for lsof-4.57
...
[configure output snipped]
...
===&gt;  Building for lsof-4.57
...
[compilation output snipped]
...
&prompt.root;</screen>

        <para>注意，一旦编译完成，您就会回到命令行。 下一步安装 port，
	  要安装它只需要在 <command>make</command> 命令后跟上一个单词
	  <maketarget>install</maketarget> 即可：</para>

        <screen>&prompt.root; <userinput>make install</userinput>
===&gt;  Installing for lsof-4.57
...
[installation output snipped]
...
===&gt;   Generating temporary packing list
===&gt;   Compressing manual pages for lsof-4.57
===&gt;   Registering installation for lsof-4.57
===&gt;  SECURITY NOTE:
      This port has installed the following binaries which execute with
      increased privileges.
&prompt.root;</screen>

        <para>一旦您返回到提示符，您就可以运行您刚刚安装的程序了。因为
	  <command>lsof</command> 是一个赋予特殊权限的程序，
	  因此显示了一个安全警告。 在编译和安装 ports 的时候，
	  您应该留意任何出现的警告。</para>

	<para>删除工作目录是个好主意，
	  这个目录中包含了全部在编译过程中用到的临时文件。
	  这些文件不仅会占用宝贵的磁盘空间， 而且可能会给升级新版本的 port
	  时带来麻烦。</para>

	<screen>&prompt.root; <userinput>make clean</userinput>
===&gt;  Cleaning for lsof-4.57
&prompt.root;</screen>

        <note>
          <para>使用 <command>make
	    <maketarget>install clean</maketarget></command>
	    可以一步完成 <command>make</command>、
	    <command>make <maketarget>install</maketarget></command> 和
	    <command>make <maketarget>clean</maketarget></command>
	    这三个分开的步骤的工作。</para>
	</note>

	<note>
	  <para>一些 shell 会缓存环境变量
	    <envar>PATH</envar> 中指定的目录里的可执行文件，
	    以加速查找它们的速度。 如果您使用的是这类 shell，
	    在安装 port 之后可能需要执行 <command>rehash</command>
	    命令， 然后才能运行新安装的那些命令。
	    这个命令可以在类似
	    <command>tcsh</command> 的 shell 中使用。 对于类似
	    <command>sh</command> 的 shell，
	    对应的命令是 <command>hash -r</command>。
	    请参见您的 shell 的文档以了解进一步的情况。</para>
	</note>

	<para>某些第三方 DVD-ROM 产品， 如 <ulink url="http://www.freebsdmall.com/">FreeBSD
	  Mall</ulink> 的 FreeBSD Toolkit 中包含了 distfiles。
	  这些文件可以与 Ports 套件配合使用。
	  将 DVD-ROM 挂接到 <filename>/cdrom</filename>。
	  如果您使用不同的挂接点， 则应设置 make 变量 <makevar>CD_MOUNTPTS</makevar>。
	  如果盘上有需要的 distfiles， 则会自动使用。</para>

	<note>
	  <para>请注意， 少数 ports 并不允许通过 CD-ROM 发行。
	    这可能是由于下载之前需要填写注册表格，
	    或者不允许再次发布， 或者有一些其它原因。
	    如果您希望安装在 CD-ROM 上没有的 port，
	    就需要在线操作了。</para>
	</note>

	<para>ports 系统使用 &man.fetch.1; 去下载文件， 它有很多可以设置的环境变量，
	  其中包括 <envar>FTP_PASSIVE_MODE</envar>、 <envar>FTP_PROXY</envar>，
	  和 <envar>FTP_PASSWORD</envar>。 如果您在防火墙之后，或使用 FTP/HTTP代理，
	  您就可能需要设置它们。 完整的说明请看 &man.fetch.3;。</para>

	<para>当使用者不是所有时间都能连接上网络， 则可以利用 <command>make
	  <maketarget>fetch</maketarget></command>。 您只要在顶层目录
	  (<filename>/usr/ports</filename>) 下运行这个命令，
	  所有需要的文件都将被下载。 这个命令也同样可以在下级类别目录中使用，
	  例如： <filename>/usr/ports/net</filename>。
	  注意， 如果一个port有一些依赖的库或其他 port， 它将 <emphasis>不</emphasis>
	  下载这些依赖的 port 的 distfile 文件， 如果您想获取所有依赖的
	  port 的所有 distfile， 请用 <maketarget>fetch-recursive</maketarget>
	  命令代替 <maketarget>fetch</maketarget>命令。</para>

	<note><para>您可以在一个类别或在顶级目录编译所有的 port， 或者使用上述提到的
	  <command>make <maketarget>fetch</maketarget></command>命令。 这样是非常危险的，
	  因为有一些port不能并存。 或者有另一种可能， 一些port会安装两个不同的文件，
	  但是却是相同的文件名。</para></note>

	<para>在一些罕见的例子中， 用户可能需要在除了 <makevar>MASTER_SITES</makevar>
	  以外的一个站点(本地已经下载下来的文件)去获得一个文件包。
	  您可以用以下命令不使用 <makevar>MASTER_SITES</makevar>:
  </para>

	<screen>&prompt.root; <userinput>cd /usr/ports/<replaceable>directory</replaceable></userinput>
&prompt.root; <userinput>make MASTER_SITE_OVERRIDE= \
ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/distfiles/ fetch</userinput></screen>

	<para>在这个例子中，我们把
	  <makevar>MASTER_SITES</makevar>这个选项改为了 <hostid
	  role="fqdn">ftp.FreeBSD.org/pub/FreeBSD/ports/distfiles/</hostid>。</para>

	<note><para>一些 port 允许 (或甚至要求) 您指定编译选项来
	  启用/禁用 应用程序中非必需的功能， 一些安全选项，
	  以及其他可以订制的内容。 具有代表性的包括
	  <filename role="package">www/mozilla</filename>、 <filename
	  role="package">security/gpgme</filename>、 以及 <filename
	  role="package">mail/sylpheed-claws</filename>。
	  如果存在这样的选项， 通常会在编译时给出提示。</para></note>

      <sect3>
        <title>改变默认的 Ports 目录</title>

	<para>有时， 使用不同的工作临时目录和目标目录可能很有用
	  (甚至是必要的)。 可以用
	  <makevar>WRKDIRPREFIX</makevar> 和 <makevar>PREFIX</makevar>
	  这两个变量来改变默认的目录。 例如：</para>

	<screen>&prompt.root; <userinput>make WRKDIRPREFIX=/usr/home/example/ports install</userinput></screen>

	<para>将在 <filename>/usr/home/example/ports</filename>
	  中编译 port 并把所有的文件安装到
	  <filename>/usr/local</filename>。</para>

	<screen>&prompt.root; <userinput>make PREFIX=/usr/home/example/local install</userinput></screen>

	<para>将在 <filename>/usr/ports</filename> 编译它并安装到
	  <filename>/usr/home/example/local</filename>。</para>

	<para>当然，</para>

	<screen>&prompt.root; <userinput>make WRKDIRPREFIX=../ports PREFIX=../local install</userinput></screen>

	<para>将包含两种设置 (没有办法在这一页把它写完，
	  但您应该已经知道怎么回事了)。</para>

	<para>另外， 这些变量也可以作为环境变量来设置。
	  请参考您的 shell 的联机手册上关于如何设置环境变量的说明。</para>
      </sect3>

      <sect3>
	<title>处理 <command>imake</command></title>

	<para>一些 port 使用 <command>imake</command> (这是
	  X Window 系统的一部分) 不能正常地配合
	  <makevar>PREFIX</makevar>， 它们会坚持把文件安装到
	  <filename>/usr/X11R6</filename> 下面。
	  类似地， 一些 Perl port 会忽略 <makevar>PREFIX</makevar>
	  并把文件安装到 Perl 的目录中。
	  让这些 port 尊重
	  <makevar>PREFIX</makevar> 是困难甚至是不可能的事情。</para>

      </sect3>

      <sect3>
	<title>重新配置 Ports</title>

	<para>当你在编译某些 ports 的时候，可能会弹出一个基于 ncurses 
	  的菜单来让你来选择一些编译选项。 通常用户都希望能够在一个 port
	  被编译安装了以后还能再次访问这份菜单以添加删除或修改这些选项。
	  实际上有很多方法来做这件事情。 一个方法进入那个 port 的目录后键入
	  <command>make</command> <maketarget>config</maketarget>，
	  之后便会再次显示出菜单和已选择的项目。 另一个方法是用
	  <command>make</command> <maketarget>showconfig</maketarget>，
	  这会给你显示出所有的配置选项。还有一个方法是执行
	  <command>make</command> <maketarget>rmconfig</maketarget>，
	  这将删除所有已选择的项目。 有关这些选项更详细的内容请参阅
	  &man.ports.7;。</para>
      </sect3>
    </sect2>

    <sect2 id="ports-removing">
      <title>卸载已经安装的 Ports</title>

      <indexterm>
        <primary>ports</primary>
        <secondary>卸载</secondary>
      </indexterm>
      <para>现在您已经了解了如何安装 ports， 并希望进一步了解如何卸载，
        特别是在错误地安装了某个 port 之后。我们将卸载前面例子
	(假如您没有注意的话， 是 <command>lsof</command>)
	中安装的 port。 Ports 可以同 packages 以完全相同的方式 (在 <link
	linkend="packages-using">Packages 一节</link> 中进行了介绍) 卸载，
	方法是使用 &man.pkg.delete.1; 命令：</para>

      <screen>&prompt.root; <userinput>pkg_delete lsof-4.57</userinput></screen>

    </sect2>

    <sect2 id="ports-upgrading">
      <title>升级 Ports</title>

      <indexterm>
	<primary>ports</primary>
	<secondary>升级</secondary>
      </indexterm>
      <para>首先， 使用 &man.pkg.version.1; 命令来列出 Ports Collection
	中提供了更新版本的那些 port：</para>

      <screen>&prompt.root; <userinput>pkg_version -v</userinput></screen>

      <sect3 id="ports-file-updating">
	<title><filename>/usr/ports/UPDATING</filename></title>

	<para>在您更新了 Ports 套件之后， 在升级 port 之前， 应查看
	  <filename>/usr/ports/UPDATING</filename>。
	  这个文件中介绍了在升级时用户应注意的问题，
	  以及一些可能需要进行的操作。 这可能包括更改文件格式、
	  配置文件位置的变动， 以及与先前版本的兼容性等等。</para>

	<para>如果 <filename>UPDATING</filename> 与本书中介绍的内容不同，
	  请以 <filename>UPDATING</filename> 为准。</para>
      </sect3>

      <sect3 id="portupgrade">
	<title>使用 Portupgrade 来更新 Ports</title>

	<indexterm>
	  <primary>portupgrade</primary>
	</indexterm>

      <para><application>portupgrade</application> 工具是设计来简化升级已安装的 port 的操作的。
	它通过 <filename
	role="package">ports-mgmt/portupgrade</filename> port 来提供。
	您可以像其它 port 那样， 使用 <command>make <maketarget>install
	clean</maketarget></command> 命令来安装它：</para>

      <screen>&prompt.root; <userinput>cd /usr/ports/ports-mgmt/portupgrade</userinput>
&prompt.root; <userinput>make install clean</userinput></screen>

      <para>使用 <command>pkgdb
	-F</command> 命令来扫描已安装的 port 的列表，
	并修正其所报告的不一致。 在每次升级之前， 有规律地执行它是个好主意。</para>

      <para>运行 <command>portupgrade -a</command> 时，
	<application>portupgrade</application> 将开始并升级系统中所安装的所有过时的 ports。
	如果您希望在每个升级操作时得到确认， 应指定 <option>-i</option>
	参数。</para>

      <screen>&prompt.root; <userinput>portupgrade -ai</userinput></screen>

      <para>如果您只希望升级某个特定的应用程序， 而非全部可用的 port，
	应使用 <command>portupgrade
	<replaceable>pkgname</replaceable></command>。
	如果 <application>portupgrade</application> 应首先升级指定应用程序的话，
	则应指定 <option>-R</option> 参数。</para>

      <screen>&prompt.root; <userinput>portupgrade -R firefox</userinput></screen>

      <para>要使用预编译的 package 而不是 ports 来进行安装， 需要指定
	<option>-P</option>。 如果指定了这个选项，
	<application>portupgrade</application>
	会搜索 <envar>PKG_PATH</envar> 中指定的本地目录，
	如果没有找到， 则从远程站点下载。 如果本地没有找到，
	而且远程站点也没有成功地下载预编译包， 则
	<application>portupgrade</application> 将使用 ports。
	要禁止使用 port， 可以指定 <option>-PP</option>。</para>

      <screen>&prompt.root; <userinput>portupgrade -PP gnome2</userinput></screen>

      <para>如果只想下载 distfiles (或者， 如果指定了 <option>-P</option>
	的话， 是 packages) 而不想构建或安装任何东西，
	可以使用 <option>-F</option>。
	要了解更多细节， 请参考 &man.portupgrade.1;。</para>
      </sect3>

      <sect3 id="portmanager">
	<title>使用 Portmanager 来升级 Ports</title>

	<indexterm>
	  <primary>portmanager</primary>
	</indexterm>

	<para><application>Portmanager</application> 是另一个用以简化已安装 port
	  升级操作的工具。 它可以通过
	  <filename role="package">ports-mgmt/portmanager</filename> port 安装：</para>

	<screen>&prompt.root; <userinput>cd <filename class="directory">/usr/ports/ports-mgmt/portmanager</filename></userinput>
&prompt.root; <userinput>make install clean</userinput></screen>

	<para>可以通过这个简单的命令来升级所有已安装的 port：</para>

	<screen>&prompt.root; <userinput>portmanager -u</userinput></screen>

	<para>如果希望 <application>Portmanager</application>
	  在进行每步操作之前都给出提示， 应使用 <option>-ui</option> 参数。
	  <application>Portmanager</application> 也可以用来在系统中安装新的 ports。
	  与通常的 <command>make <maketarget>install clean</maketarget></command>
	  命令不同，它会在联编和安装您所选择的 port 之前升级所有依赖包。</para>

	<screen>&prompt.root; <userinput>portmanager <replaceable>x11/gnome2</replaceable></userinput></screen>

	<para>如果关于所选 port 的依赖有任何问题，
	  可以用 <application>Portmanager</application> 来以正确的顺序重新构建它们。
	  完成之后， 有问题的 port 也将被重新构建。</para>

	<screen>&prompt.root; <userinput>portmanager <replaceable>graphics/gimp</replaceable> -f</userinput></screen>

	<para>要了解更多信息， 请参见 &man.portmanager.1;。</para>
      </sect3>

      <sect3 id="portmaster">
	<title>使用 Portmaster 升级 Ports</title>

	<indexterm>
	  <primary>portmaster</primary>
	</indexterm>

	<para><application>Portmaster</application>
	  是另外一个用来升级已安装的 ports 的工具。
	  <application>Portmaster</application> 被设计成尽可能使用
	  <quote>基本</quote> 系统中能找到的工具
	  （它不依赖于其他的 ports） 和
	  <filename class="directory">/var/db/pkg/</filename>
	  中的信息来检测出需要升级的 ports。你可以在
	  <filename role="package">ports-mgmt/portmaster</filename>
	  找到它：</para>

	<screen>&prompt.root; <userinput>cd <filename class="directory">/usr/ports/ports-mgmt/portmaster</filename></userinput>
&prompt.root; <userinput>make install clean</userinput></screen>

	<para><application>Portmaster</application> groups ports into four
	  categories:</para>
	<para><application>Portmaster</application> 把 ports
	  分成4类：</para>

	<itemizedlist>
	  <listitem>
	    <para>Root ports (不依赖其他的 ports，也不被依赖)</para>
	    </listitem>
	  <listitem>
	    <para>Trunk ports (不依赖其他的 ports，但是被其他的 ports 依赖)</para>
	    </listitem>
	  <listitem>
	    <para>Branch ports (依赖于其他的 ports，同时也被依赖)</para>
	    </listitem>
	  <listitem>
	    <para>Leaf ports (依赖于其他的 ports，但不被依赖)</para>
	    </listitem>
	</itemizedlist>

	<para>你可以使用 <option>-L</option>
	选项列出所有已安装的 ports 和查找存在更新的 ports：</para>

<screen>&prompt.root; <userinput>portmaster -L</userinput>
===>>> Root ports (No dependencies, not depended on)
===>>> ispell-3.2.06_18
===>>> screen-4.0.3
        ===>>> New version available: screen-4.0.3_1
===>>> tcpflow-0.21_1
===>>> 7 root ports
...
===>>> Branch ports (Have dependencies, are depended on)
===>>> apache-2.2.3
        ===>>> New version available: apache-2.2.8
...
===>>> Leaf ports (Have dependencies, not depended on)
===>>> automake-1.9.6_2
===>>> bash-3.1.17
        ===>>> New version available: bash-3.2.33
...
===>>> 32 leaf ports

===>>> 137 total installed ports
        ===>>> 83 have new versions available
</screen>

	<para>可以使用这个简单的命令升级所有已安装的 ports：</para>

	<screen>&prompt.root; <userinput>portmaster -a</userinput></screen>

	<note><para><application>Portmaster</application> 默认在删除一个现有的
	    port 前会做一个备份包。如果新的版本能够被成功安装，
	    <application>Portmaster</application> 将删除备份。
	    使用 <option>-b</option> 后 <application>Portmaster</application>
	    便不会自动删除备份。加上 <option>-i</option> 选项之后
	    <application>Portmaster</application> 将进入互动模式，
	    在升级每个 port 以前提示你给予确认。</para></note>

	<para>如果你在升级的过程中发现了错误，你可以使用
	  <option>-f</option> 选项升级/重新编译所有的 ports：</para>

	<screen>&prompt.root; <userinput>portmaster -af</userinput></screen>

	<para>同样你也可以使用 <application>Portmaster</application>
	  往系统里安装新的 ports，升级所有的依赖关系之后并安装新的
	  port：</para

	<screen>&prompt.root; <userinput>portmaster <replaceable>shells/bash</replaceable></userinput></screen>

	<para>更多的详细信息请参阅 &man.portmaster.8;</para>
      </sect3>
    </sect2>

    <sect2 id="ports-disk-space">
      <title>Ports 和磁盘空间</title>

      <indexterm>
	<primary>ports</primary>
	<secondary>disk-space</secondary>
      </indexterm>
      <para>使用 Ports 套件会最终用完磁盘空间。
	在通过 ports 联编和安装软件之后，您应记得清理临时的
	<filename class="directory">work</filename> 目录，
	其方法是使用 <command>make <maketarget>clean</maketarget></command>
	命令。 您可以使用下面的命令来清理整个 Ports 套件：</para>

      <screen>&prompt.root; <userinput>portsclean -C</userinput></screen>

      <para>随着时间的推移， 您可能会在
	<filename class="directory">distfiles</filename> 目录中积累下大量源代码文件。
	您可以手工删除这些文件， 也可以使用下面的命令来删除所有 port
	都不引用的文件：</para>

      <screen>&prompt.root; <userinput>portsclean -D</userinput></screen>

      <para>除此之外， 也可以用下列命令删去目前安装的 port 没有使用的源码包文件：</para>

      <screen>&prompt.root; <userinput>portsclean -DD</userinput></screen>

      <note>
	<para>这个 <command>portsclean</command> 工具是
	  <application>portupgrade</application> 套件的一部分。</para>
      </note>

      <para>不要忘记删除那些已经安装， 但已不再使用的 ports。
	用于自动完成这种工作的一个好工具是
	<filename role="package">ports-mgmt/pkg_cutleaves</filename> port。</para>
    </sect2>

  </sect1>

  <sect1 id="ports-nextsteps">
    <title>安装之后还要做点什么？</title>

    <para>通常，您通过port安装完一个软件后,可以阅读它带的一些文档(如果它包含文档的话)，
    或需要编辑它的配置文件，来确保这个软件的运行，
    或在机器启动的时候启动(如果它是一个服务的话)，等等。</para>

    <para>对于不同的软件有着不同的配置步骤。不管怎样，
    如果您装好了一个软件，但是不知道下一步怎么办的时候，
    这些小技巧可能可以帮助您:</para>

    <itemizedlist>
      <listitem>
	<para>使用 &man.pkg.info.1; 命令，它能找到安装了哪些文件，以及装在哪里。
	举个例子，如果您安装了 FooPackage version 1.0.0, 那么这个命令</para>

	<screen>&prompt.root; <userinput>pkg_info -L foopackage-1.0.0 | less</userinput></screen>

	<para>将显示这个软件包安装的所有文件，您要特别注意在<filename>man/</filename>目录里面的文件，
	它们可能是手册，<filename>etc/</filename>目录里面的配置文件，以及 <filename>doc/</filename>目录下面更多的文档。</para>

	<para>如果您不确定已经安装好的软件版本，您可以使用这样的命令</para>

	<screen>&prompt.root; <userinput>pkg_info | grep -i <replaceable>foopackage</replaceable></userinput></screen>

	<para>它将会找到所有已安装的软件包名字中包含<replaceable>foopackage</replaceable>
	  的软件包。 对于其他的查找， 您只需要在命令行中替换
	  <replaceable>foopackage</replaceable>。</para>
      </listitem>

      <listitem>
	<para>一旦一些软件手册已被您确认安装，您可以使用 &man.man.1;  查看它。
	  同样的，如果有的话，您还可以完整的查看一遍配置文件的示例，以及任何额外的文档。</para>
      </listitem>

      <listitem>
	<para>如果应用软件有网站, 您还可以从网站上找到文档，常见问题的解答，或其他更多。
	  如果您不知道它们的网站地址，请使用下面的命令</para>

	<screen>&prompt.root; <userinput>pkg_info <replaceable>foopackage-1.0.0</replaceable></userinput></screen>
	
	<para>一个 <literal>WWW:</literal> 行, 如果它存在，
	  它将提供一个这个应用程序的网站URL.</para>
      </listitem>

      <listitem>
	<para>Ports 如果需要在服务器启动时运行(就像互联网服务器)，
	  它通常会把一个脚本的样例放入
	  <filename>/usr/local/etc/rc.d</filename> 目录。为了保证正确性，
	  您可以查看这个脚本， 并编辑或更改这个脚本的名字。 详情请看<link
	  linkend="configtuning-starting-services">启动服务</link>。</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="ports-broken">
    <title>如何处理坏掉的 Ports</title>

      <para>如果您发现某个 port 无法正常工作，
        有几件事值得尝试， 包括：</para>

      <orderedlist>
	<listitem>
	  <para>在 <ulink url="&url.base;/support.html#gnats">问题报告数据库</ulink>
	    中查找是否有尚未提交的修正。 如果有， 可以使用所提议的修正。</para>
	</listitem>

	<listitem>
	  <para>要求 port 的监护人 (maintainer) 提供帮助。 输入
	    <command>make <maketarget>maintainer</maketarget></command>
	    或阅读 <filename>Makefile</filename>
	    查找监护人的电子邮件地址。 请记得把 port 的名字和版本写在邮件里
	    (<filename>Makefile</filename> 中的
	    <literal>&dollar;FreeBSD:</literal>这一行)
	    并把错误输出的头几行发给 maintainer。</para>

	  <note>
	    <para>某些 ports 并非一个人维护， 而是写了一个 <ulink
	      url="&url.articles.mailing-list-faq;/article.html">邮件列表</ulink>。
	      许多， 但并非所有 port， 使用类似
	      <email role="nolink">freebsd-listname@FreeBSD.org</email> 这样的地址。
	      请在提出问题时考虑这一点。</para>

	    <para>特别地， 由
	      <email role="nolink">ports@FreeBSD.org</email> 监护的 port，
	      实际上并没有人维护。 订阅这个邮件列表的人们会感谢您提供的修正和支持。
	      我们一直都需要更多志愿者！</para>
	  </note>

	  <para>如果您没有得到回应，
	    则可以使用 &man.send-pr.1; 来提交问题报告 (请参见 <ulink
	    url="&url.articles.problem-reports;/article.html">如何撰写
	    FreeBSD 问题报告</ulink>)。</para>
	</listitem>

        <listitem>
	  <para>修正它！ <ulink
	    url="&url.books.porters-handbook;/index.html">Porter
	    手册</ulink> 中提供了关于
	    <quote>Ports</quote> 基础设施的详细信息，
	    通过了解这些内容， 您就能修正偶然坏掉的 port，
	    或甚至提交自己的 port 了！</para>
	</listitem>

	<listitem>
	  <para>从较近的 FTP 站点下载一个编译好的安装包。
	    <quote>中央的</quote> package collection 在 <hostid
	    role="fqdn">ftp.FreeBSD.org</hostid> 的 <ulink
	    url="ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/packages/">packages
	    目录中</ulink>， 但 <emphasis>在此之前</emphasis>
	    请 <emphasis>事先</emphasis> 检查一下是否存在较近的 <link
	    linkend="mirrors-ftp">镜像网站</link>！
	    通常情况下这些安装包都可以直接使用，
	    而且应该比自行编译快一些。
	    安装过程本身可以通过 &man.pkg.add.1; 来完成。</para>
	</listitem>
      </orderedlist>
  </sect1>

</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
