<!-- $Id: ports.sgml,v 1.18 1998-11-22 15:05:41 motoyuki Exp $ -->
<!-- The FreeBSD Japanese Documentation Project -->
<!-- Original revision: 1.33 -->

<chapt><heading>アプリケーションのインストール : ports コレクション <label id="ports"></heading>

<p><em>原作: &a.jraynard;.</em>
<p><em>訳: &a.masaki;, &a.saeki;.<newline>
11 November 1996.</em>

FreeBSD の ports コレクションを利用すると, 最小限の労力で
非常に幅広くのアプリケーションのコンパイルとインストールがおこなえます. 

<p> やってみたことのある方はよくご存知でしょうが, オープンな規格とは
全くの誇大広告であって, あるプログラムを異なるバージョンの Unix 上で
動作させることは退屈で手間のかかる仕事です. 
求めているプログラムが自分のシステムでうまくコンパイルでき, 
正しいところにインストールできて, 完璧に動作するとしたらとてもラッキーです. 
しかし, あいにくこれは滅多にないことなのです. 
ほとんどのプログラムについて, あなたは髪を掻きむしることになるでしょうし, 
かなりのプログラムでは, 白髪混じりの頭になってしまったり, あるいは慢性の
脱毛症にすら なってしまうかもしれません... 

<p> いくつかのソフトウェアディストリビューションでは, 設定用のスクリプトを
配布することでこの問題を解決しようとしています. 
これらのスクリプトの中には非常に精巧なものもありますが, 残念ながら, 
中にはこれまで聞いたこともないようなシステムの名前をしゃあしゃあと
言い放ったうえに, まるでシステムレベルの Unix プログラミングに関する
最終試験のような, たくさんの質問をしてくる場合があります. 
 (例えば, 「このシステムの gethitlist 関数は fromboz への const ポインタを
返しますか? それとも const fromboz へのポインタを返しますか?」, 
「このシステムには Foonix スタイルの, 容認できない例外処理をおこなう
ルーチンがありますか? もしもないとしたら, それはなぜですか?」) 

<p> 幸いなことに, ports コレクションがあれば, これらのきつい作業はすべて
完了しています. 'make install' とタイプするだけで, 動作するプログラムを
入手することができるのです. 

<sect><heading> なぜ ports コレクションを作ったのか?</heading>

<p>FreeBSD の基本システムは, 非常に多くのツールやユーティリティから
構成されています. しかし, よく使われるプログラムのうち多くのものが, 
この基本システムには含まれていません. その理由は:-

<enum>
<item> ある Lisp ベースのエディタのように, それがないと生きていけないと
言う人もいれば, ディスクの無駄だと言う人もいるようなプログラム. 

<item> 基本システムに組み込むには特殊すぎるプログラム. 
 (CAD やデータベースなど.) 

<item> 「時間のある時に, ちょっと見ておかなければ」というような類の, 
それがシステムに含まれていないことが致命的とは言えないプログラム. 
 (おそらく, 何らかの言語などでしょう.) 

<item>FreeBSD のような真面目なオペレーティングシステムの一部として
供給するには遊びが過ぎるようなプログラム. ;-)

<item> たくさんのプログラムを基本システムに組み込んだとしても, もっともっと
組み込みたいという要求が出てくるので, どこかで制限を引かなくてはならないため. 
 (そうしなければ FreeBSD の配布物は, とてつもなく膨大になってしまうでしょう.) 
</enum>

<p> すべての人が自分のお気に入りのプログラムを手作業で移植しなければ
ならないとしたら,  (途方もない膨大な作業の繰り返しをさておいたとしても) 
それは明らかに不合理な話です. 
そこで, FreeBSD プロジェクトでは, 標準のツールを使って移植のプロセスを
自動化する巧妙な方法を考え出しました. 

<p> なお, これは単純ながら非常に柔軟なツールを組み合わせることで, 
非常に強力な働きをさせるという「Unix 流」の作業の優れた実例です. 

<sect><heading>ports コレクションはどのように動くのでしょうか?</heading>
<p>
インターネットでは通常, <ref id="ports:tarball" name="tarball"> の形で
プログラムが配布されています. これは, Makefile とソースコードで構成され, 
普通は何らかの説明書 (あいにく, いつもわかりやすく書かれているとは
限りませんが) が付属しています. 
ことによるとコンフィグレーションスクリプトも含まれているかもしれません. 
<p>
標準的な手順では, FTP で tarball を入手して, 適当なディレクトリで展開します. 
次に説明書を読んで, 必要な変更をおこないます. そして, 設定スクリプトを実行し, 
標準の make コマンドを使ってソースのコンパイルとインストールをおこないます. 
<p>
FreeBSD の ports も tarball の仕組みを利用していますが, これはユーザが
苦労して作業することを期待したものではなく, どのようにすれば FreeBSD 上で
そのプログラムが動くようになるかという「ノウハウ」を <ref id="ports:skeleton" 
name="スケルトン"> を使用して収めているものです. 
スケルトンは, カスタマイズ済みの <ref id="ports:makefile" name="Makefile"> も
提供していますので, ほとんどすべての ports は同じ手順でインストールすることが
できます. 
<p>
もしあなたが (<htmlurl url="file://localhost/usr/ports/devel/ElectricFence" 
name="あなたの FreeBSD システム"> または 
<htmlurl url="ftp://ftp.freebsd.org/pub/FreeBSD/ports/devel/ElectricFence" 
name="FTP サイト"> にある) ports スケルトンを見ていて, そこに潜んでいる
あらゆる種類の先端的なロケット工学的なものを見つけられると期待していると, 
つまらなそうなファイルやディレクトリがそこにあるだけなのを見て, 
がっかりするかもしれません. 
 (ports を手に入れる方法については, すぐに <ref id="ports:getting" 
name="FreeBSD ports コレクションの入手方法"> の節でお話します.) 

<p>「一体どうしたらいいんだ? ここにはソースコードが ないじゃないか?」
というあなたの叫びが聞こえるようです. 

<p> 心配いりません. おとなしく読んでいけば, すべてが (たぶん) 明らかに
なるでしょう. 
試しに ports をインストールして, 何が起きるのかを見てみましょう. 
ここではサンプルとして開発者向けの便利なツール, `ElectricFence' を選択します. 
このスケルトンを選んだ理由は, 他の ports に比べても素直で理解しやすく
書かれているからです. 

<em>Note</em> 自宅で試してみる場合には, root になる必要があるでしょう. 

<verb>
 # cd /usr/ports/devel/ElectricFence
# make install
>> Checksum OK for ElectricFence-2.0.5.tar.gz.
===>  Extracting for ElectricFence-2.0.5
===>  Patching for ElectricFence-2.0.5
===>  Applying FreeBSD patches for ElectricFence-2.0.5
===>  Configuring for ElectricFence-2.0.5
===>  Building for ElectricFence-2.0.5
[大量のメッセージをコンパイラが出力します...]
===>  Installing for ElectricFence-2.0.5
===>  Warning: your umask is "0002".
      If this is not desired, set it to an appropriate value
      and install this port again by ``make reinstall''.
install -c -o bin -g bin -m 444 /usr/ports/devel/ElectricFence/work/ElectricFence-2.0.5/libefence.a /usr/local/lib
install -c -o bin -g bin -m 444 /usr/ports/devel/ElectricFence/work/ElectricFence-2.0.5/libefence.3 /usr/local/man/man3
===>   Compressing manual pages for ElectricFence-2.0.5
===>  Registering installation for ElectricFence-2.0.5
</verb>

<p> ここではあなたが混乱しないように, コンパイル時の出力を
すべて取り除いてあります. 
<p>もしもあなた自身で実行されたら, 最初にこのような
出力結果が得られるはずです:-

<label id="ports:fetch">
<verb>
# make install
>> ElectricFence-2.0.5.tar.gz doesn't seem to exist on this system.
>> Attempting to fetch from ftp://ftp.doc.ic.ac.uk/Mirrors/sunsite.unc.edu/pub/Linux/devel/lang/c/.
</verb>

<p> `make' プログラムは, あなたの手元にソースコードがないことを検出し, 
処理を続けられるようにソースを FTP でダウンロードしようとします. 
この例では, あらかじめ手動でソースコードを用意してあったので, 
持ってくる必要はありませんでした. 

<p>  では, 続けて `make' プログラムが何をしているのか見てみましょう. 

<enum>
<item> ソースコード <ref id="ports:tarball" name="tarball"> のありかを
確認します. 
手元にファイルが存在しなければ, FTP サイトから入手しようとします. 

<item><ref id="ports:checksum" name="チェックサム"> テストを実行して, 
その tarball が事故か何かで途中で切れていたり, ASCII モードで
ダウンロードされていたり, 転送中にニュートリノによって傷められたりして
改変されたりしていないかどうかを確認します. 

<item>tarball を一時的な作業用ディレクトリに展開します. 

<item>FreeBSD 上でコンパイルしたり, 動作させるのに必要な
すべての <ref id="ports:patch" name="パッチ"> をソースコードに当てます. 

<item> 構築のために必要なコンフィグレーションスクリプトを実行します. 
コンフィグレーションスクリプトの質問には正確に答えてください. 

<item> (いよいよ!) ソースコードをコンパイルします. 

<item> 実行形式のプログラム, マニュアル, その他のサポートファイルを, 
システムのプログラムと混ざってしまわないように /usr/local 以下に
インストールします. ports はすべて同じ場所にインストールされ, 
システムのあちこちにばらまかれることはありません. 

<item> インストール結果はデータベースに登録されます. これにより, 
インストールしたプログラムがもしも気に入らなかったときも, システムから
すべての痕跡をきれいに <ref id="ports:remove" name="消去"> することができます. 

</enum>

<p> 以上のステップが make の出力と一致しているかどうか確認してください. 
今まで確認していなかったのなら, 今からするようにしてください! 

<sect<heading>FreeBSD ports コレクションの入手 <label id="ports:getting"></heading>
<p>
あるプログラムの FreeBSD port を入手するには二つの方法があります. 
ひとつは <ref id="ports:cd" name="FreeBSD CD-ROM"> を使う方法で, 
もうひとつは <ref id="ports:inet"name="インターネット接続"> を使う方法です. 

<sect1><heading>CD-ROM からコンパイルする <label id="ports:cd"></heading>
<p>
<em /FreeBSD/ CD-ROM がドライブに入っており, 
/cdrom にマウントされていると仮定すると (マウントポイントが
/cdrom である必要があります), ただ普通に実行するだけで
ports を構築できるようになり, 
tarball をネットワーク経由でダウンロードするのではなく
file:/cdrom/ports/distfiles/ からさがすようになります (そこにあればの話ですが).

<p>
ライセンスの制限により, いくつかの ports でオリジナルのソースコードを 
CD-ROM に入れることができなかったものがあることに注意してください. この場合, 
<ref id="ports:inet" name="インターネット経由で ports をコンパイルする"> の
節を参照してください. 

<sect1><heading> インターネット経由で ports をコンパイルする <label id="ports:inet"></heading>
<p>
CD-ROM を持っていなかったり, その ports の最新バージョンを確実に入手したい
場合は, その ports の <ref id="ports:skeleton" name="スケルトン"> を
ダウンロードする必要があります. ところで, これは落し穴が
たくさんある作業に見えるかもしれませんが, 実際には非常に簡単です. 
<p>
初めに、あなたの動かしている FreeBSD がリリースバージョンなら
<htmlurl url="http://www.freebsd.org/ports/" name="ports ページ">で
その FreeBSD 用の ``アップグレードキット''を手にいれてください.
このパッケージには, 最新の ports をコンパイルするのに必要な,
リリース以降に更新されたファイルが含まれています.
<p>
FreeBSD の FTP サーバーがその場で
<ref id="ports:tarball" name="tarball"> を作成できることを利用して
スケルトンを入手すると非常に便利です.
ここでは例として databases ディレクトリにある 
gnats プログラムを使って説明します. (角型かっこの中の文はコメントなので, 
実際に実行する場合には, これをタイプしないでください!):-

<verb>
 # cd /usr/ports
 # mkdir databases
 # cd databases
 # ftp ftp.freebsd.org
 [ユーザ名 `ftp' でログインし, パスワードを要求されたら, あなたの電子メール
アドレスを入力してください. バイナリモードを (イメージモードと呼ばれることも
あります) 使うのをお忘れなく!] 
 > cd /pub/FreeBSD/ports/databases
 > get gnats.tar		[gnats スケルトンの tarballs を取得] 
 > quit
 # tar xf gnats.tar		[gnats スケルトンの展開]
 # cd gnats
 # make install			[gnats の構築とインストール]
</verb>

さて何が起きるでしょうか? FTP サイトにいつも通りに接続して, データベースの
サブディレクトリに移動します. `get gnats.tar' とコマンドを入力すると, 
FTP サイトでは gnats ディレクトリを <ref id="ports:tarball" 
name="tarred"> にしてくれるのです. 
<p>
gnats スケルトンを展開したら, gnats ディレクトリへ移動して ports を構築します. 
<ref id="ports:fetch" name="すでに"> 説明したように, make の過程で
手元にソースコードがないことを検出すると, ソースコードを取得してから
展開し, パッチ当てと構築をおこないます. 
<p>
それでは, 少し冒険をしてみましょう. 一つの ports スケルトンを
取得するかわりに, たとえば ports コレクションの中のデータベースの
スケルトンをすべて, サブディレクトリ全体を取得してみましょう. 
やり方はほとんど同じです:-

<verb>
 # cd /usr/ports
 # ftp ftp.freebsd.org
 [ユーザ名 `ftp' でログインし, パスワードを要求されたら, あなたの電子メール
アドレスを入力してください. バイナリモードを (イメージモードと呼ばれることも
あります) 使うのをお忘れなく!] 
 > cd /pub/FreeBSD/ports
 > get databases.tar		[データベースディレクトリの tarballs を取得] 
 > quit
 # tar xf databases.tar		[すべてのスケルトンを展開] 
 # cd databases
 # make install			[データベース ports 全部の構築とインストール] 
</verb>

わずかばかりの簡単なコマンドで, この FreeBSD マシン上にデータベース
プログラムを一揃い手に入れてしまいました! 一つの ports スケルトンを取ってきて
それを構築する場合との違いは, すべてのディレクトリを一度に取得して, 
全部を一度にコンパイルしたということだけです. かなり感動的だと思いませんか? 
<p>
たくさんの ports をインストールする
つもりなら, おそらくすべての ports ディレクトリをダウンロードしておく
価値があるでしょう. 

<sect><heading> スケルトン <label id="ports:skeleton"></heading>
<p>
スケルトン (訳注: skeleton とは骸骨のことです) とは, 締め切りを守るため, 
食事をするのを忘れるほど仕事にのめり込んだハッカーたちのなれの果ての
ことでしょうか? FreeBSD の屋根裏に潜む, なにか気持ちの悪いものでしょうか? 
いいえ, ここでスケルトンの意味するところは, ports の魔術を実現するのに
必要とされるすべてのものを提供する最小の骨組みのことです. 

<sect1><heading>Makefile<label id="ports:makefile"></heading>
<p>
スケルトンのもっとも重要な要素は Makefile です. Makefile は ports を
どのようにコンパイルし, インストールをおこなうかを指示する
いろいろな命令を含んでいます. 以下に ElectricFence の Makefile を示します:-

<verb>
# New ports collection makefile for:  Electric Fence
# Version required:	2.0.5
# Date created: 	13 November 1997
# Whom:			jraynard
#
# $Id: ports.sgml,v 1.18 1998-11-22 15:05:41 motoyuki Exp $
#

DISTNAME=	ElectricFence-2.0.5
CATEGORIES=	devel
MASTER_SITES=	${MASTER_SITE_SUNSITE}
MASTER_SITE_SUBDIR=	devel/lang/c

MAINTAINER=	jraynard@freebsd.org

MAN3=		libefence.3

do-install:
	${INSTALL_DATA} ${WRKSRC}/libefence.a ${PREFIX}/lib
	${INSTALL_MAN} ${WRKSRC}/libefence.3 ${PREFIX}/man/man3

.include <bsd.port.mk>
</verb>

&quot;#&quot; で始まる行は, 人間のためのコメント行です. 
 (ほとんどの Unix のスクリプトと同じですね.) 
<p>
`DISTNAME&quot; は <ref id="ports:tarball" name="tarball">
の名前から拡張子を取ったものです. 
<p>
`CATEGORIES&quot; はこのプログラムの種類を示します. 
この場合, 開発者向けのユーティリティということになります. 
完全なリストはこのハンドブックの <ref id="porting:categories" name="カテゴリ">
をみてください.
<p>
`MASTER_SITES&quot; はマスタ FTP サイトの URL です. もしローカルシステムに 
<ref id="ports:tarball" name="tarball"> がない場合には, ここから取得します. 
これは信頼できると考えられているサイトで, 通常はそのプログラムを
インターネット上で公式に配布しているサイトです. 
 (そのソフトウェアがインターネット上で「公式に」配布されているとしたら) 
<p>
`MAINTAINER&quot; は, 例えば新しいバージョンのプログラムが出た場合に, 
必要であればスケルトンの更新をおこなう保守担当者の電子メールアドレスです. 
<p>
次の数行はとりあえず飛ばします. 
<verb>
 .include <bsd.port.mk> 
</verb>
この行は, この ports に必要なその他の命令やコマンドは `bsd.port.mk&quot; に
入っているということを示しています. これらはすべての ports で共通のものなので, 
それぞれの Makefile に書いておく必要はありません. そのため単一の標準ファイルに
まとめられているのです. 
<p>
ここでは Makefile がどう働くかを詳細に調査するのが目的ではありませんので, 
``MAN3'' で始まる行は, インストールの後に ElectricFence のマニュアルを
圧縮するために使用される, と言っておくだけで充分でしょう. 
これにより, 貴重なディスクスペースが保護されているわけです. 
オリジナルの port では ``install'' ターゲットが用意されていないので, 
``do-install'' からの 3 行が この ports によって生成されたファイルを
正しい場所に置くために使用されます. 

<sect1><heading>files ディレクトリ </heading>
<p>
ports のチェックサム算出には MD5 アルゴリズムを使用しているので, 
この <ref id="ports:checksum" name="チェックサム"> を含んでいる
ファイルは  &quot;md5&quot; と呼ばれます. 
ちょっと混乱するかもしれませんが, このファイルは &quot;files&quot; という
名前のディレクトリに置かれています. 
<p>
このディレクトリは, ports に必要だけれども, 他のどこにも属さない
雑多なファイルも含んでいます. 

<sect1><heading>patches ディレクトリ </heading>
<p>
このディレクトリには, FreeBSD ですべてを正常に動作させるのに
必要な <ref id="ports:patch" name="パッチ"> が含まれています. 

<sect1><heading>pkg ディレクトリ </heading>
<p>
このディレクトリには, 非常に役立つ三つのファイルが含まれています:-
<itemize>
<item>
COMMENT - プログラムについての 1 行の説明. 

<item>
DESCR - より詳細な説明. 

<item>
PLIST - プログラムのインストール時に作成される, すべてのファイルのリスト. 
</itemize>

<sect><heading>ports が動かないのですが、どうしたらよいでしょう<label id="ports:troubleshooting"></heading>

<p>おやおや. では, 次の四つのどれかをやってみてください:

<enum>
<item> 自分で修正する. ports の仕組みに関する技術的な詳細については, 
   <ref id="porting" name="アプリケーションの移殖方法">をご覧ください. 

<item> 苦情をいう. これは電子メールで * だけ * にしてください! 
   このようなメールの宛先は &a.ports; です. 
   なお, 必ず port の名前やバージョン, その port のソースや distfile(s) を
   どこから入手したか, どんなエラーが発生したのかを書いておいてください. 

<item> 忘れてしまう. これはほとんどの場合最も簡単な方法です. 
   ports のプログラムのうち必要不可欠な物はごくわずかです. 

<item> FTP サイトからコンパイル済みのパッケージを入手する. 
   マスターパッケージコレクションは FreeBSD の FTP サイトの
   <htmlurl url="ftp://ftp.FreeBSD.org/pub/FreeBSD/packages/" 
   name="パッケージディレクトリ"> に置いてありますが, 
   まずあなたの近くのローカルミラーサイトを確認してください! 

   ソースからのコンパイルに挑戦するよりも, パッケージを使うほうが
   (全体的に見て) ずっと確実に動作するでしょうし, 
   より手っ取り早い方法でもあります. 
   システムにパッケージをインストールするには, <tt>pkg_add(1)</tt> 
   を使ってください. 

</enum>

<sect><heading> 質問と回答集 </heading>
<p>
<itemize>
<item>
Q. 私はモデムについての議論をしているのかと思っていました??! 
<p>
A.なるほど, あなたはきっとコンピュータの背面についている
シリアルポートのことだと思ってしまったのでしょう. 
あるバージョンの Unixから別のバージョンの Unix へとプログラムを
移殖することを `porting' というのですが, ここで我たちは `porting' の結果
という意味で `port' を使っています. 
(コンピュータに関わる人々の悪しき習慣として, ひとつの同じ言葉を複数の
まったく違う意味として使うことがあるのです.) 

<item>
Q. 私は, 標準以外のプログラムのインストールには packages を使うと
思っていたのですが. 
<p>
A. そのとおり. 通常は packages が最も手早くて簡単な方法です. 

<item>
Q. それではどうして面倒な ports があるのですか? 
<p>
A. いくつかの理由があります:-

<enum>
<item> いくつかのソフトウェアのライセンス条件には, 
バイナリではなくソースコードでの配布を求めているものがあります. 

<item> バイナリ配布を信用していない人もいます. 少なくともソースコード
があれば, ソースコードを読んで, (理論的には) 潜在的な問題点を自分で
見つけ出すこともできるはずです. 

<item> ローカルなパッチを入手した場合, それを自分で追加するために
ソースコードが必要になります. 

<item> プログラムがいかにコンパイルされるべきかについて, 
あなたはパッケージを作った人とは異なる見解を持っているかもしれません. 
どんな最適化オプションをつけるべきかとか, デバッグバージョンを作ってから
それを strip するべきだとか, いや, そうするべきでない, などなど, 
確固たる見解を持っている人もいるでしょう. 

<item> ソースコードを手元に置いておきたい人たちもいます. 
彼らは, 退屈したときに眺めたり, あちこち解析してみたり, ソースコードを
借用したり (もちろん, ライセンスが許せばの話ですが) するのです. 

<item> あなたがソースコードを持っていなければ, それはソフトウェアとは
言えませんね! ;-)
</enum>

<item><label id="ports:patch">
Q. パッチとは何ですか? 
<p>
A. パッチとは, あるバージョンから他のバージョンへどのように変更するかを
示す, (通常は) 小さなファイルです. 「23 行目を削除」, 「468 行目の後に
これらの 2 行を追加」, または「197 行目をこのように変更」というような
内容を含んでいます. 
これは, `diff' という名前のプログラムで生成されます. 

<item><label id="ports:tarball">
Q. tarball とは一体何ですか? 
<p>
A. .tar または .tar.gz という拡張子を持つファイルです. 
(.tar.Z のようなバリエーションも
ありますし, DOS のファイルシステム用に .tgz と短縮される場合もあります.) 
<p>
これは基本的に, 一つのファイルに固めた (.tar) ディレクトリツリーです. 
圧縮されている (.gz) 場合もあります. 
これは元々 <em /T/ape <em /AR/chives (訳注: テープアーカイブ) 
 (このため `tar' という名前なのです) で使われていたものなのですが, 
インターネット上でプログラムのソースコードを配布するために
広く使われている方法です. 
<p>
これらのファイルの中身を見たり, 展開したりすることもできます. 
FreeBSD の基本システムに付属する Unix 標準の tar コマンドを使ってみると
次のようになります:-

<verb>
 tar tvzf foobar.tar.gz		# foobar.tar.gz の内容を見る
 tar xzvf foobar.tar.gz		# カレントディレクトリに内容を展開する
 tar tvf foobar.tar		# foobar.tar の内容を見る
 tar xvf foobar.tar		# カレントディレクトリに内容を展開する
</verb>

<item><label id="ports:checksum">
Q. チェックサムとは何ですか? 
<p>
A. これは, チェックしたいファイル中のすべてのデータを加えて生成した
数値です. 何か文字が書き換わっていたら, チェックサムが一致しなくなります. 
そのため, 単純な比較だけで違いを見つけることができるのです. 
 (実際には, 文字の位置が入れ替わるなどの, 単純な加算ではわからない問題も
見つけることができる複雑な方法で計算されています.) 

<item>
Q. 私は, <ref id="ports:cd" name="CD-ROM から ports をコンパイルする">
にしたがって ports をインストールしていました. 
kermit をインストールしようとするまではうまくいっていました:-

<verb>
 # make install
 >> cku190.tar.gz doesn't seem to exist on this system.
 >> Attempting to fetch from ftp://kermit.columbia.edu/kermit/archives/.
</verb>

なぜ cku190.tar.gz が見つからないのでしょうか? 
不良品の CD-ROM を買ってしまったのでしょうか? 
<p>
A. Kermit の権利を持つチームは, 私たちの CDROM に kermit の tarball を
入れることを許可しませんでした. 申し分けありませんが, 手動でファイルを
入手してください. 
このようなエラーメッセージが出たのは, あなたがそのときインターネットに
接続していなかったためです. あらかじめ上記のサイトのいずれかからファイルを
ダウンロードしておけば, プロセスを再開することができます. 
 (ダウンロードの際には, あなたに最も近いサイトを選ぶようにしてください. 
そうすれば, 時間とインターネットの帯域の節約になります) 

<item>
Q. kermit の tarball を入手しましたが, /usr/ports/distfiles に
ファイルを置こうとすると, 書き込み権がないというエラーがでます. 
<p>
A. ports のしくみは /usr/ports/distfiles から tarball を探します. 
しかし, これは read-only の CD-ROM へのシンボリックリンクなので, 
ここにファイルを置くことはできません. 
次のようにすれば, 他の場所を探すよう ports に指示することができます. 
<verb>
 DISTDIR=/where/you/put/it make install
</verb>

<item>
Q. ports では, すべてを /usr/ports に置いたときだけ動作するのでしょうか? 
システムの管理者によると, 私の個人的なファイルは
/u/people/guests/wurzburger に入れなければならないのですが, 
これでは うまくいかないように思います. 
<p>
A. PORTSDIR 変数と PREFIX 変数を変更することで, 違うディレクトリを
使用することができます. 例えば, 

<verb>
 make PORTSDIR=/u/people/guests/wurzburger/ports install
</verb>

とすると, ports は /u/people/guests/wurzburger/ports でコンパイルされ, 
すべて /usr/local 以下にインストールされます. 

<verb> 
 make PREFIX=/u/people/guests/wurzburger/local install
</verb>
 
この場合, コンパイルは /usr/ports でおこない, 
/u/people/guests/wurzburger/local にインストールします. 
もちろん, 以下のように両者を組み合わせることも可能です. 

<verb>
 make PORTSDIR=.../ports PREFIX=.../local install
</verb>

 (省略せずに記述したら, このページに収めるには長すぎるのですが, 
考え方は理解していただけたと思います)
<p>
もし ports をインストールするたびに, これらを毎回タイプするのが
気に入らないのであれば, (正直に言って, 誰もそう思わないでしょう) 
これらを環境変数にセットしてしまうという手があります. 

<item>
Q. 私は, FreeBSD の CD-ROM を持っていませんが, 私はすべての tarball を
私のシステムに置いておきたいのです. そうすれば, 私は ports をインストール
するたびに, 毎回ダウンロードが終わるのを待たなくてすむでしょう. 
これを一度におこなう簡単な方法はありませんか? 

<p>
A. ports コレクション全体の tarball を持ってくるには, 次のようにしてください. 

<verb>
 # cd /usr/ports
 # make fetch
</verb>

ports の下のディレクトリひとつの tarball を持ってくるには, 次のように
してください. 

<verb>
 # cd /usr/ports/directory
 # make fetch
</verb>

ports をひとつだけ持ってくる方法は, きっと既にご存知だと思います. 

<item>
Q. マスタ FTP サイトから tarball を持ってくるより, 近くにある FreeBSD の
ミラーサイトから持ってきた方が速いはずです. MASTER_SITES に書かれている
サイト以外から持ってくるように ports に指示する方法はありませんか? 
<p>
A. もちろんあります. 例えば ftp.FreeBSD.ORG が MASTER_SITES に書かれている
サイトより近いとしたら, 以下のようにしてください. 
<verb>
 # cd /usr/ports/directory
 # make MASTER_SITE_OVERRIDE=ftp://ftp.FreeBSD.ORG/pub/FreeBSD/distfiles/ fetch
</verb>

<item>
Q. ダウンロードをする前に, どんなファイルが必要なのか知りたいのですが. 
<p>
A. 'make fetch-list' とすると, ports に必要なファイルの一覧を表示できます. 

<item>
Q. ports のコンパイルを途中で止める方法はありますか? 
私はインストールをする前にいろいろとソースコードを解析したいのですが, 
毎回 control-C を打たなければならないのが少し面倒です. 
<p>
A. 'make extract' を実行すると, ファイル転送とソースコードの展開まで
おこなったところで停止します. 

<item>
Q. 自分で ports を作ろうとしています. 私の作ったパッチが
正しく処理できることを確認できるように, コンパイルを止めたいのです. 
パッチのための 'make extract' のようなものはありませんか? 
<p>
A. あります. 'make patch' があなたのお望みのものです. 
おそらく PATCH_DEBUG オプションも同様に お役に立つことでしょう. 
ところで, あなたの努力に感謝いたします!! 

<item>
Q. あるコンパイルオプションはバグの原因になるという話を聞きました. 
本当なのでしょうか? どうやったら正しい設定で ports をコンパイルできますか? 
<p>
A. 本当です. gcc の バージョン 2.6.3 (FreeBSDの 2.1.0 と 2.1.5 に付属している
バージョン) では, -O2 オプションを -fno-strength-reduce オプションなしで
使うと, バグのあるコードを出力します (ほとんどの ports は -O2 オプションを
使いません). コンバイラオプションは次のように定義 <em/ すべき / です. 

<verb>
 make CFLAGS='-O2 -fno-strength-reduce' install
</verb>

これを /etc/make.conf に書いておくこともできますが, 残念なことに
すべての ports がこの指定を尊重してくれる
訳ではありません. もっとも確実なのは 'make configure' を実行し, 
ソースディレクトリの Makefile を見て手で修整することですが, ソースが
多くのサブディレクトリにわかれていて, 各々に Makefile がある場合は
大変な仕事になります. 

<item>
Q. ports がたくさんありすぎて, 私の欲しいものがなかなか見つけられません. 
どんな ports が使えるのか, リストはどこかにありませんか? 
<p>
A. /usr/ports の中にある INDEX ファイルを見てみましょう. 
あるキーワードで ports コレクションを検索したければ, それも可能です. 
たとえば, 以下のようにすればプログラミング言語 LISP に関連した ports を
見つけることができます: 

<verb>
 cd /usr/ports
 make search key=lisp
</verb>

<item>
Q. 'foo' ports をインストールしたいのですが, それのコンパイルは
すぐに停止して, 'bar' ports のコンパイルが始まってしまいます. 一体どうして? 
<p>
A. 'foo' ports が, 'bar' ports の提供する何らかの機能を必要としているからです. 
例えば 'foo' が画像を使うとすると, 'bar' は画像処理に必要な
ライブラリを持っている, などです. 
または, 'bar' は 'foo' をコンパイルするのに必要なツールなのかもしれません. 

<item><label id="ports:remove"> 
Q. ports から grizzle プログラムをインストールしましたが, まったく
ディスクスペースの浪費です. 削除したいのですが, すべてのファイルが
どこへインストールされたのかわかりません. 何か手がかりはありませんか? 
<p>
A. 大丈夫, 次のようにしてください. 

<verb>
 pkg_delete grizzle-6.5
</verb>
<item>

Q. ちょっと待ってください. 削除しようとするコマンドのバージョン番号を
知っていなくてはならないのでしょうか? あなたは, 私がバージョン番号を
覚えていることを本気で当てにしているのでしょうか? 
<p>
A. そんなことはありません. バージョン番号は次のようにすればわかります. 

<verb>
 pkg_info -a | grep grizzle
</verb>

そうすると次のように表示されます:-

<verb>
 Information for grizzle-6.5:
 grizzle-6.5 - the combined piano tutorial, LOGO interpreter and shoot 'em up arcade game.
</verb>

<item>
Q. ディスク容量のことなのですが, ports のディレクトリは非常に膨大な容量を
使うように見えます. 残しておいた方がよいのでしょうか? 削除してしまっても
よいのでしょうか? 

<p>
A. はい. インストールが首尾よく終わり, もうソースコードが必要でないと思うなら, 
それらを残しておく理由はないでしょう. 一番よい方法は, 次の通りです. 

<verb>
 # cd /usr/ports
 # make clean
</verb>

これは, すべての ports のサブディレクトリを調べ, 
各 ports のスケルトン以外の削除をおこないます. 

<item>
Q. これを試してみたのですが, tarball や ports で使われたファイルが 
distfiles ディレクトリに残っています. これも削除してしまっても大丈夫ですか? 
<p>
A.  はい. それを使った作業が終わったのであれば, 削除してしまっても大丈夫です. 

<item>
Q. 私はとてもとてもたくさんのプログラムを楽しみたいのです. 
一度にすべての ports をインストールする方法はありませんか? 
<p>
A. 次のようにしてください. 

<verb>
 # cd /usr/ports
 # make install
</verb>

<item>
Q. やってみました. 時間がとてもかかるだろうと思ったので, そのまま実行を
続けさせて, 私は寝ました. 翌朝コンピュータを見てみると, 三つ半の ports しか
処理が終わっていませんでした. なにか悪かったのでしょうか? 
<p>
A. これは ports の中には私たちの決められないこと (例えば, あなたが A4 の
用紙に印刷したいのか, US レターサイズの用紙に印刷したいのかなど) について
質問してくるものがあるからです. それらの質問には手動で答える必要があります. 

<item>
Q.  私は一日中モニタの前に座って過ごしたりしたくないのですが. 
何かよいアイデアはありませんか? 
<p>
A. では, あなたが寝に / 仕事に / 公園にいく前に以下を実行してください:-

<verb>
 # cd /usr/ports
 # make -DBATCH install
</verb>

これでユーザの入力を要求しないすべての ports をインストールします. 
そして, 戻ってきてから, 次のように実行してください. 

<verb>
 # cd /usr/ports
 # make -DIS_INTERACTIVE install
</verb>

そして, 残りの作業を実行してください. 

<item>
Q. 私たちは ports コレクションにある frobble を使っています. 
ですが, 私たちの必要に応じて ports を変更したところがあるのです. 
自分でパッケージを作って, それを私たちのサイトのまわりに
簡単に配布できるような方法がありますか? 
<p>
A. もちろんあります. 変更点をパッチにする方法は知っていますよね:-

<verb>
 # cd /usr/ports/somewhere/frobble
 # make extract
 # cd work/frobble-2.8
 [あなたのパッチを当ててください]
 # cd ../..
 # make package
</verb>

<item>
Q. この ports の技術は本当に賢いですね. どのようにして動いているのか
私はどうしても知りたいと思います. その秘密は何ですか? 
<p>
A. 秘密は一切ありません. 
<htmlurl url="file://localhost/usr/share/mk/" name="Makefiles ディレクトリ">
にある bsd.ports.mk と bsd.ports.subdir.mk ファイルを見るだけです. 
 (注: 複雑なシェルスクリプトを嫌う読者は, このリンクを追いかけないほうが
よいでしょう.) 
</itemize>

&porting;
