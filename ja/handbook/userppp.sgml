<!-- $Id: userppp.sgml,v 1.15 1998-08-15 05:19:02 hanai Exp $ -->
<!-- The FreeBSD Japanese Documentation Project -->
<!-- Original revision: 1.30 -->

<sect>ユーザ ppp の設定<label id="userppp">

<!--  この FAQ あるいは手引は, <em>ユーザレベル ppp</em> または
   単に <em>ppp</em> としても知られている ppp を, 
   あなたの FreeBSD 2.0.5 (以降) で動くようにすることを目的としています. 

<p>また, ユーザ ppp を PPP サーバとして使う方法の概略についても述べています. 

<p>このドキュメントは もともと Nik Clayton によって書かれたものですが, 
   現在では何年にもわたる共同作業の成果となっています. 

-->

<p>ユーザ ppp は FreeBSD 2.0.5-RELEASE において, 
   既存のカーネル実装版の PPP に加えて導入されました. 
   それでは, これまでの pppd との違い, すなわち
   この新しい PPP が追加された理由とは いったい何なのでしょうか? 
   マニュアルから引用してみます: 

<quote>
   これはユーザプロセス PPP ソフトウェアパッケージです. 
   通常, PPP は (例えば pppd でそうなっているように) カーネルの一部として
   実装されていますので, デバッグや動作の変更が少々困難です. 
   しかし, この実装では, PPP はトンネルデバイスドライバ (tun) の
   助けにより, ユーザプロセスとして実装されています. 
</quote>

  本質として, これは常に PPP デーモンを実行しておかなくても, 
  必要な時に ppp プログラムを実行できるということを意味します. 
  このプログラムはカーネルとのデータ送受のために一般のトンネルデバイスを
  使うことができるため, PPP インターフェースをカーネルに組み込んでおく
  必要がありません. 

  以降では, ユーザ ppp と pppd のような他の PPP クライアント/サーバ
  ソフトウェアとを区別する必要が無い場合には, ユーザ ppp を単に ppp とだけ
  呼びます. 特に断らない限り, このセクションのすべてのコマンドは root 権限で
  実行する必要があります. 

  バージョン 2 の ppp では, 数多くの機能強化がおこなわれています. 
  どのバージョンの ppp がインストールされているのかを調べるには, 
  引数なしで ppp を起動し, プロンプトが表示されたら <tt>show version</tt> と
  タイプしてください. 
  最新版の ppp にアップグレードするのは, (どのバージョンの FreeBSD においても) 
  難しいことではありません. <url url="http://www.Awfulhak.org/ppp.html" 
  name="www.Awfulhak.org"> から最新版のアーカイブをダウンロードしてください. 

<sect1><heading>スタートの前に</heading>

<p>このドキュメントでは, あなたが
   およそ以下のような状況にあると仮定しています: 

   PPP 接続の使えるインターネットサービスプロバイダ (ISP) のアカウントを
   持っている. さらに, 接続済みのモデム (またはその他のデバイス) があり, 
   プロバイダとの接続が可能なように正しく設定されている. 

   以下の情報を手に入れておく必要があるでしょう: 

<itemize>
   <item><p>プロバイダの電話番号.

   <item><p>ログイン名とパスワード. これは通常の unix 形式のログイン名と
            パスワードの組という場合もありますし, PPP PAP や CHAP の
            ログイン名とパスワードの組という場合もあります. 

   <item><p>一つ以上のネームサーバの IP アドレス. 通常, プロバイダから
            IP アドレスを二つ指示されているはずです. 
            自分でネームサーバを立ち上げている場合を除き, バージョン 1.X の 
            ppp を使用している場合には, この情報は<bf>絶対に</bf>必要です. 
            バージョン 2 の ppp からは, ネームサーバアドレスの自動設定機能が
            追加されています. この機能をプロバイダ側でもサポートしていれば, 
            ppp の設定ファイルに <tt>enable dns</tt> と書いておくことで 
            ppp がネームサーバアドレスの設定をおこなうようになります. 
</itemize>

  プロバイダからは以下の情報が提供されているはずですが, 
  どうしても必要というわけではありません: 

<itemize>
   <item><p>プロバイダのゲートウェイの IP アドレス. 
            ゲートウェイとは, あなたがそこに接続をおこなって, 
            <tt>デフォルトルート</tt>として設定することになるマシンです. 
            プロバイダがこのアドレスを明示していないとしても, 最初は
            適当に設定しておいて, 接続時にプロバイダの PPP サーバから
            正しいアドレスを教えてもらうことができます. 
         <p>このアドレスは, 以降 <tt>HISADDR</tt> と呼ぶことにします. 

   <item><p>プロバイダのネットマスク設定. プロバイダが明示していないとしても, 
            ネットマスクとして 255.255.255.0 を使用しておけば問題ありません. 

   <item><p>もしプロバイダから固定の IP アドレスとホスト名の割り当てを
            受けていれば, その情報を指定しておくこともできます. 
            割り当てを受けていなければ, 接続先から適切な IP アドレスを
            指定してもらいます. 
</itemize>

   もし, 必要な情報が不足していれば, プロバイダに連絡を取って
   確認しておいてください. 

<sect1><heading>ppp 対応カーネルの構築</heading>

<p>説明でも述べているように, ``ppp'' はカーネルの ``tun'' デバイスを使います. 
   そのため, このデバイスがカーネルに組み込まれているかどうかを
   確認しておかなくてはいけません. 

   これを確認するには, カーネルコンパイルディレクトリ
   (<tt>/sys/i386/conf</tt> または <tt>/sys/pc98/conf</tt>) に移動して, 
   カーネルコンフィグレーションファイルを調べます. 
   以下の行がどこかに含まれている必要があります. 

<tscreen><verb>
   pseudo-device tun 1
</verb></tscreen>

   元々の GENERIC カーネルは標準でこれを含んでいますので, 
   カスタムカーネルをインストールしているのではなかったり, 
   /sys ディレクトリが存在しないのであれば, 何も変更する必要はありません. 
   <p>この行がカーネルコンフィグレーションファイルに含まれていなかったり, 
   tun デバイスが一つでは足りない場合 (例えば, 同時に 16 本の
   ダイアルアップ PPP 接続を処理できるサーバを立ち上げるとしたら, 
   ``1'' のかわりに ``16'' を指定する必要があるでしょう), この行を追加して
   カーネルの再コンパイルとインストールをおこなう必要があります. 
   それからこの新しいカーネルを使ってブートしてください. 
   カーネルコンフィグレーションの詳細については, 
   <ref id="kernelconfig" name="FreeBSD カーネルのコンフィグレーション">
   を参照してください. 

<p>以下のコマンドを実行することで, 現在のカーネルにトンネルデバイスが
   いくつ組み込まれているかを調べることができます: 

<tscreen><verb>
   # ifconfig -a
   tun0: flags=8051<UP,POINTOPOINT,RUNNING,MULTICAST> mtu 1500
           inet 200.10.100.1 --> 203.10.100.24 netmask 0xffffffff
   tun1: flags=8050<POINTOPOINT,RUNNING,MULTICAST> mtu 576
   tun2: flags=8051<UP,POINTOPOINT,RUNNING,MULTICAST> mtu 1500
           inet 203.10.100.1 --> 203.10.100.20 netmask 0xffffffff
   tun3: flags=8010<POINTOPOINT,MULTICAST> mtu 1500
</verb></tscreen>

   この例ではトンネルデバイスが四つ存在し, そのうち二つに設定が
   おこなわれ, 使用中であることがわかります. 
   上の例で RUNNING フラグがオンになっているものがありますが, これは 
   そのインターフェースが何かに使用されていることを示しているだけである 
   ということに注意してください. つまり, RUNNING になっていない
   インターフェースがあったとしても, それはエラーではありません. 

<p>トンネルデバイスがカーネルに組み込まれておらず, 何らかの理由で
   カーネルの再構築ができない場合でも, 方法がないわけではありません. 
   動的にデバイスをロードすることができるはずです. 詳細については 
   modload(8) や lkm(4) など, 適切なマニュアルを参照してください. 

<p>この機会にファイアウォールも設定しておきたいと思っているのであれば, 
   詳細については<ref id="firewalls" name="ファイアウォール">セクションを
   参照してください. 

<sect1><heading>tun デバイスの確認</heading>

<p>ほとんどのユーザは ``tun'' デバイス (tun0) が一つあれば充分でしょう. 
   より多くのデバイスを使う場合 (すなわち, カーネルコンフィグレーション
   ファイルで tun 疑似デバイスの行に `1' 以外の数値を指定している場合), 
   以下で ``tun0'' と書かれている部分をすべて, あなたが使うデバイスの番号に
   あわせて読みかえてください. 

   tun0 デバイスが正しく作成されていることを確認する最も簡単な方法は, 
   それを作り直すことです. そのためには, 以下のコマンドを実行します: 

<tscreen><verb>
   # cd /dev
   # ./MAKEDEV tun0
</verb></tscreen>

<p>カーネルに 16 個のトンネルデバイスを組み込んだのであれば, 
   tun0 だけでなく他の tun デバイスも作成しておく必要があるでしょう: 

<tscreen><verb>
   # cd /dev
   # ./MAKEDEV tun15
</verb></tscreen>

<p>また, カーネルが正しく設定されているかどうかを調べるために
   以下のコマンドを実行して, このような出力が得られることを確認します: 

<tscreen><verb>
   $ ifconfig tun0
   tun0: flags=8050<POINTOPOINT,RUNNING,MULTICAST> mtu 1500
   $ 
</verb></tscreen>

   まだ RUNNING フラグがセットされていない場合もあります. 
   その時は以下のような出力が得られるでしょう: 

<tscreen><verb>
   $ ifconfig tun0
   tun0: flags=8010<POINTOPOINT,MULTICAST> mtu 1500
   $ 
</verb></tscreen>

<sect1><heading>名前の解決に関する設定</heading>

<p>リゾルバ (resolver) はシステムの一部分で, IP アドレスとホスト名との
   変換をおこないます. IP アドレスとホスト名を対応させるためのマップを, 
   二つの場所のうちの一つから探すように設定できます. 
   一つめは <tt>/etc/hosts</tt> (<tt>man 5 hosts</tt>) と呼ばれるファイルです. 
   二つめはインターネット ドメインネームサービス (DNS) と呼ばれる
   分散データベースですが, これに関する議論は このドキュメントで扱う範囲を
   越えていますので, これについての説明はおこないません. 

<p>このセクションではリゾルバの設定方法について簡単に説明します. 

<p>リゾルバは名前のマッピングをおこなうシステムコールの集合体です. ただし
   どこからマッピング情報を見つけるのかは, 最初に指示しておく必要があります. 
   これは まず <tt>/etc/host.conf</tt> ファイルを編集することでおこないます. 
   混乱の元になりますので, このファイルを <tt>/etc/hosts.conf</tt> と
   呼んだりしては<bf>いけません</bf> (余分な ``s'' がついていますね). 

<sect2><heading>/etc/host.conf ファイルの編集</heading>

<p>このファイルには 以下の 2 行が (この順番で) 書かれているはずです: 

<tscreen><verb>
   hosts
   bind
</verb></tscreen>

   これは, 最初に <tt>/etc/hosts</tt> ファイルを調べ, そこで目的の名前が
   見つけられなかった場合に DNS を引きにいくようリゾルバに指示します. 

<sect2><heading>/etc/hosts(5) ファイルの編集</heading>

<p>このファイルはローカルネットワーク上に存在するマシンの IP アドレスと
   ホスト名を含んでいるはずです. 最低でも ppp を動作させるマシンのエントリが
   含まれている必要があります. そのマシンのホスト名が foo.bar.com で, 
   IP アドレスが 10.0.0.1 であると仮定すると, <tt>/etc/hosts</tt> は
   以下の行を含んでいなければいけません: 

<tscreen><verb>
   127.0.0.1    localhost
   10.0.0.1     foo.bar.com	       foo
</verb></tscreen>

   一つめの行は ``localhost'' を現在のマシンの別名として定義しています. 
   マシン固有の IP アドレスが何であっても, この行の IP アドレスは
   常に 127.0.0.1 でなければいけません. 二つめの行はホスト名 ``foo.bar.com'' 
   (と, その省略形 ``foo'') を IP アドレス 10.0.0.1 にマップします. 

   もしプロバイダから固定の IP アドレスとホスト名を割り当てられて
   いるのであれば, それを 10.0.0.1 エントリのかわりに使ってください. 

<sect2><heading>/etc/resolv.conf ファイルの編集</heading>

<p><tt>/etc/resolv.conf</tt> はリゾルバの振舞いを指定します. 
   もし自前の DNS サーバを走らせているのなら, このファイルは空のままに
   しておくこともできます. 通常は, 以下のように書いておく必要があるでしょう: 

<tscreen><verb>
   nameserver x.x.x.x
   nameserver y.y.y.y
   domain bar.com
</verb></tscreen>
   
   <tt>x.x.x.x</tt> と <tt>y.y.y.y</tt> はプロバイダから指示されたアドレスで, 
   接続するプロバイダが提供している「ネームサーバ」を すべて書いてください. 
   ``domain'' に指定するのは このマシンのデフォルトのドメイン名で, おそらく
   書かなくても問題は無いでしょう. このファイルの各エントリの詳細については, 
   resolv.conf のマニュアルページを参照してください. 

<p>バージョン 2 以降の ppp を使用している場合には, 
   ``enable dns'' コマンドを使用してネームサーバのアドレスを
   プロバイダに問い合わせるように指示することができます. 
   上の指定とは異なるアドレスをプロバイダが指定してきた場合 
   (または <tt>/etc/resolv.conf</tt> でネームサーバが指定されていない場合), 
   ppp はプロバイダが指定したアドレスで resolv.conf を書きかえます. 

<sect1><heading>ppp の設定</heading>

<p>ユーザ ppp と pppd (カーネルレベルの PPP 実装) は
   どちらも <tt>/etc/ppp</tt> ディレクトリに置かれた設定ファイルを使います. 
   ここには設定ファイルのサンプルが用意されていて, ユーザ ppp の設定を
   おこなう際に大変参考になりますので, 削除したりしないでください. 

<p>ppp の設定をするためには, 必要に応じていくつかのファイルを編集する必要が
  あります. 書き込む内容は, プロバイダが静的に IP アドレスを割り当てる 
  (つまり, 固定の IP アドレスを一つ与えられて, 常にそれを使う) か, 
  または動的に IP アドレスを割り当てる (つまり, PPP セッションごとに 
  IP アドレスが変化する可能性がある) かということに ある程度依存します. 

<sect2><heading>静的 IP アドレスによる PPP 接続<label id="userppp:staticIP">
       </heading>

<p>まず <tt>/etc/ppp/ppp.conf</tt> という設定ファイルを作成する必要があります. 
   これは以下の例とほとんど同じようなものになるでしょう. ``:'' で終る行は 
   1 カラム目から始め, その他の行はスペースまたはタブで以下の例のように
   段をつける (インデントする) 必要があることに注意してください. 

<tscreen><verb>
1     default:
2       set device /dev/cuaa0
3       set speed 115200
4       set dial "ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 5 \"\" ATE1Q0 OK-AT-OK
\\dATDT\\T TIMEOUT 40 CONNECT"
5     provider:
6       set phone "(0123) 456 7890"
7       set login "TIMEOUT 10 \"\" \"\" gin:--gin: foo word: bar col: ppp"
8       set timeout 300
9       set ifaddr x.x.x.x y.y.y.y 255.255.255.0 0.0.0.0
10      add default HISADDR
11      enable dns
</verb></tscreen>
   ファイルでは行番号を取り除いておいてください. 
   これは解説の際に参照する行を示すためにつけたものです. 

<descrip>
<tag/Line 1:/  デフォルトエントリを指定します. このエントリ中のコマンドは
               ppp が起動された際に自動的に実行されます. 

<tag/Line 2:/  モデムが接続されているデバイスを指定します. 
               COM1: は <tt>/dev/cuaa0</tt> に, 
               COM2: は <tt>/dev/cuaa1</tt> になります. 

<tag/Line 3:/  通信速度 (DTE 速度) を指定します. もし 115200 が使えない
               (最近のモデムなら大抵使えるはずですが) 場合には, 
               かわりに 38400 を指定してみてください. 

<tag/Line 4:/  ダイアルスクリプトを指定します. 
               ユーザ ppp は <tt>chat(8)</tt> 言語に似た, 受信待ち文字列と
               送信文字列の対からなるスクリプトを使用します. 
               この言語の機能に関しては, マニュアルページを参照してください. 

<tag/Line 5:/  接続するプロバイダの名前 ``provider'' を
               エントリ名として指定します. 

<tag/Line 6:/  このプロバイダの電話番号を指定します. 複数の電話番号を 
               ``:'' や ``|'' で区切って指定することができます. 
               これら区切り文字の違いについては, ppp のマニュアルページに
               詳しく書かれています. 
               要約すると, 毎回違う番号に かけたいのであれば ``:'' を使います. 
               常に まず先頭の番号にかけてみて, つながらない時にだけ 
               2 番目以降の番号に かけたいのであれば ``|'' を使います. 
               例に示されているように, 常に電話番号全体を引用符で
               くくって (クォートして) おきます. 

<tag/Line 7:/  ダイアルスクリプトと同様に, ログインスクリプトも 
               chat 言語風の記述をおこないます. 
               この例は, 以下のようなログインセッションを使用する
               プロバイダのためのものです: 

<tscreen><verb>
   J. Random Provider
   login: foo
   password: bar
   protocol: ppp
</verb></tscreen>

               このスクリプトは必要に応じて書きかえなければならないでしょう. 
               初めてスクリプトを書く時には, 予想した通りに
               処理が進んだかどうかを確認するため, ``chat'' ログを
               とるようにしておいた方が良いでしょう. 
            <p>PAP や CHAP を使用する場合には, ここでログインすることは 
               ありませんから, ログイン文字列は空白のままにしておくべきです. 
               詳細については <ref id="userppp:PAPnCHAP"
               name="PAP および CHAP による認証">を参照してください. 

<tag/Line 8:/  デフォルトの接続タイムアウト時間を (秒数で) 指定します. 
               この例では, 300 秒間 通信がおこなわれなければ
               自動的に接続を切るように指定しています. 
               タイムアウトさせたくない場合には, この値を 0 に設定します. 

<tag/Line 9:/  インターフェースのアドレスを指定します. 文字列 x.x.x.x は
               プロバイダに割り当てられた IP アドレスで置きかえてください. 
               文字列 y.y.y.y はプロバイダから指示されたゲートウェイ 
               (接続先となるマシン) の IP アドレスで置きかえてください. 
               プロバイダがゲートウェイのアドレスを指示していない場合は, 
               <tt>10.0.0.2/0</tt> を使用しておいてください. 
               もし「仮の」アドレスを使用する必要がある場合には, 
               <ref id="userppp:dynamicIP" 
               name="動的 IP アドレスによる PPP 接続">に関する指示に従って, 
               <tt>/etc/ppp/ppp.linkup</tt> にエントリを作成していることを
               確認してください. 
               この行が省略されている場合, ppp を <tt>-auto</tt> モードで
               動作させることはできません. 

<tag/Line 10:/ プロバイダのゲートウェイへの経路をデフォルトルートとして
               追加します. 特殊文字列 <tt>HISADDR</tt> は, 9 行目で指定された
               ゲートウェイのアドレスで置きかえられます. 
               <tt>HISADDR</tt> は 9 行目までは初期化されていませんので, 
               その行よりも後でしか使えないことに注意してください. 

<tag/Line 11:/ ネームサーバのアドレスが正しいかどうかを確認するため, 
               プロバイダに問い合わせをおこなうよう ppp に指示します. 
               プロバイダがこの機能をサポートしていれば, ppp は
               <tt>/etc/resolv.conf</tt> のネームサーバエントリを
               正しいアドレスに更新することができます. 
</descrip>

<p>静的な IP アドレスを持っていて, 接続が完了する前にルーティングテーブルの
   エントリが正しく設定されているのであれば, <tt>ppp.linkup</tt> に
   エントリを追加する必要はありません. 
   しかし, この場合でもエントリを追加して, 接続が完了した時点で
   プログラムを呼び出したいことがあるかもしれません. 
   これについては後ほど sendmail を例として説明します. 

<p>これらの設定ファイルのサンプルが <tt>/etc/ppp</tt> ディレクトリに
   置かれています. 

<sect2><heading>動的 IP アドレスによる PPP 接続<label id="userppp:dynamicIP">
       </heading>

<p>プロバイダが静的な IP アドレスの割り当てをおこなっていない場合, 
   <tt>ppp</tt> が相手側のホスト (ゲートウェイ) と交渉して, 
   こちら側と相手側のアドレスを決めるように設定することができます. 
   これは, 起動時には「仮の」アドレスを使っておいて, 
   接続後に IP コンフィグレーション プロトコル (IPCP) を使用して
   ppp が IP アドレスを正しく設定できるようにすることで実現されます. 
   <ref id="userppp:staticIP" name="静的 IP アドレスによる PPP 接続">に
   以下の変更を加える以外は, <tt>ppp.conf</tt> の設定は同じです: 

<tscreen><verb>
9       set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.0 0.0.0.0
</verb></tscreen>

   繰り返しますが, 行番号は取り除いておいてください. 
   これは解説の際に参照する行を示すためにつけたものです. 
   なお, 少なくともスペース 1 個分の段づけ (インデント) が必要です. 

<descrip>
<tag/Line 9:/  ``/'' 文字の後ろの数字は, アドレス交渉の際に固定しておきたい
               ビットの数です. 場合によっては, もっと適切な IP アドレスを
               指定しておきたいこともあるかもしれませんが, 
               ほとんどの場合には 上の例の通りで問題ありません. 

               最後の引数 (<tt>0.0.0.0</tt>) は, アドレスの交渉の際に 
               <tt>10.0.0.1</tt> ではなく <tt>0.0.0.0</tt> を使用するよう
               ppp に指示するためのものです. 
               <tt>set ifaddr</tt> コマンドの最初の引数として
               <tt>0.0.0.0/0</tt> を指定してはいけません. 
               さもないと, <tt>-auto</tt> モードで動作させる際に
               初期経路を設定することができなくなります. 
</descrip>

<p>バージョン 1.X の ppp を使用する場合, <tt>/etc/ppp/ppp.linkup</tt> にも
   エントリを作成しておく必要があります. 
   <tt>ppp.linkup</tt> は接続が確立された後に使用されます. この時点では, 
   ppp は<bf>実際に</bf>どの IP アドレスを使うべきなのか わかっているはずです. 
   以下のエントリは存在する仮の経路を削除し, 正しい経路を作成します: 

<tscreen><verb>
1     provider:
2       delete ALL
3       add default HISADDR
</verb></tscreen>

<descrip>
<tag/Line 1:/ 接続を確立する際に, ppp は以下のルールに従って 
              <tt>ppp.linkup</tt> のエントリを検索します: 
              まず <tt>ppp.conf</tt> で使用されたのと同じラベルを探します. 
              もし見つからなければ, ゲートウェイの IP アドレスのエントリを
              探します. このエントリは 4 オクテットの IP アドレス形式の
              ラベルです. それでも まだエントリが見つからなければ, 
              <tt>MYADDR</tt> エントリを探します. 

<tag/Line 2:/ この行は, 使用する tun インターフェースに関する既存の経路を 
              (ダイレクトルートのエントリを除き) すべて削除するよう 
              ppp に指示します. 

<tag/Line 3:/ この行は <tt>HISADDR</tt> への経路をデフォルトルートとして
              追加するように ppp に指示します. <tt>HISADDR</tt> IPCP で
              決定されたゲートウェイの IP アドレスで置きかえられます. 
</descrip>

<p>詳細なサンプルについては, <tt>/etc/ppp/ppp.conf.sample</tt> ファイル中の 
   pmdemand エントリと <tt>/etc/ppp/ppp.linkup.sample</tt> を参照してください. 

<p>バージョン 2 の ppp から ``sticky routes'' が導入されました. 
   <tt>MYADDR</tt> や <tt>HISADDR</tt> を含む <tt>add</tt> コマンドと 
   <tt>delete</tt> コマンドを記憶して, <tt>MYADDR</tt> や <tt>HISADDR</tt> の
   アドレスが変化した際には経路の再設定をおこないます. 
   したがって, これらのコマンドを <tt>ppp.linkup</tt> に
   繰り返し記述する必要は無くなりました. 

<sect2><heading>かかってきた電話を ppp で受けるには</heading>

<p>このセクションでは ppp をサーバとして設定する方法について説明します. 

<p>かかってきた電話を <tt>ppp</tt> が受けるように設定する際に, 
   そのマシンが LAN に接続されているのであれば, 
   パケットを LAN に転送するかどうかを決定する必要があります. 
   転送をおこなう場合には, その LAN のサブネットから IP アドレスを
   ppp クライアントに割り当て, 以下のコマンドを指定するのが良いでしょう. 

<tscreen><verb>
    enable proxy
</verb></tscreen>

   また, <tt>/etc/rc.conf</tt> に以下のオプションが指定してあることを
   確認しておいてください. (以前のバージョンの FreeBSD では, 
   このファイルは <tt>/etc/sysconfig</tt> と呼ばれていました): 

<tscreen><verb>
    gateway_enable=YES
</verb></tscreen>

<sect3><heading>どの getty を使いますか?</heading>

<p>getty でダイアルアップサービスをおこなう場合の優れた解説が <ref id="dialup" 
   name="FreeBSD でダイアルアップサービスをおこなうための設定">にあります. 

<p>getty に代わるものとしては, 
   <url url="http://www.leo.org/~doering/mgetty/index.html" name="mgetty">
   があります. これは getty をより柔軟にしたもので, 
   ダイアルアップ回線での使用を意図して設計されています. 

<p>mgetty を使う場合の利点は, mgetty が積極的にモデムと<em>通信する</em>
   ということです. つまり, もし <tt>/etc/ttys</tt> でポートを閉じている場合, 
   モデムは電話をとらなくなります. 

<p>最近のバージョンの mgetty (0.99beta 以降) では, PPP ストリームの
   自動検出もサポートされています. これにより, クライアント側で
   スクリプトを準備しなくてもサーバにアクセスすることができます. 

<p>mgetty に関する, より詳細な情報については <ref id="userppp:mgetty" 
   name="Mgetty と AutoPPP"> を参照してください. 

<sect3><heading>ppp の実行許可</heading>

<p>ppp は通常, ID 0 のユーザ (root) として動作しなければいけませんが, 
   以下で説明するように, ppp を通常のユーザとしてサーバモードで実行させたい
   場合には, そのユーザを <tt>/etc/group</tt> の <tt>network</tt> グループに
   追加して, ppp を実行する許可を与えておかなければいけません. 

<p>また, そのユーザが設定ファイル内の目的のエントリにアクセスできるように, 
   以下のように <tt>allow</tt> コマンドで許可を与えておく必要があります: 

<tscreen><verb>
    allow users fred mary
</verb></tscreen>

   このコマンドがデフォルトエントリに書かれている場合には, 指定されたユーザは 
   すべてのエントリをアクセスできるようになります. 

<sect3><heading>動的 IP ユーザのための ppp シェルの設定</heading>

<p><tt>/etc/ppp/ppp-shell</tt> という名前で, 以下のような内容のファイルを
   作成します: 

<tscreen><verb>
   #!/bin/sh
   IDENT=`echo $0 | sed -e 's/^.*-\(.*\)$/\1/'`
   CALLEDAS="$IDENT"
   TTY=`tty`

   if [ x$IDENT = xdialup ]; then
       IDENT=`basename $TTY`
   fi

   echo "PPP for $CALLEDAS on $TTY"
   echo "Starting PPP for $IDENT"

   exec /usr/sbin/ppp -direct $IDENT
</verb></tscreen>

<p>このスクリプトには実行可能属性をつけておきます. 
   次に, 以下のコマンドを実行し, <tt>ppp-dialup</tt> という名前で
   このスクリプトへのリンクを作成します: 

<tscreen><verb>
   # ln -s ppp-shell /etc/ppp/ppp-dialup
</verb></tscreen>

<p>すべてのダイアルアップ ppp ユーザのログイン<em>シェル</em>として
   このスクリプトを使用します. 以下は pchilds というユーザ名の
   ダイアルアップユーザを <tt>/etc/password</tt> へ登録した場合の例です. 
   (パスワードファイルを直接エディタで編集したりせず, 
   <tt>vipw</tt> を使ってください) 

<tscreen><verb>
   pchilds:*:1011:300:Peter Childs PPP:/home/ppp:/etc/ppp/ppp-dialup
</verb></tscreen>

<p>任意のユーザが読むことのできる, <tt>/home/ppp</tt> ディレクトリを
   作成します. <tt>/etc/motd</tt> が表示されないようにするため, 
   このディレクトリには以下のように大きさが 0 バイトのファイルを
   作成しておきます. 

<tscreen><verb>
   -r--r--r--   1 root     wheel           0 May 27 02:23 .hushlogin
   -r--r--r--   1 root     wheel           0 May 27 02:22 .rhosts
</verb></tscreen>

<sect3><heading>静的 IP ユーザのための PPP シェルの設定</heading>

<p>上記と同じように <tt>ppp-shell</tt> ファイルを作成し, 
   静的な IP アドレスを割り当てるアカウントそれぞれについて
   <tt>ppp-shell</tt> へのシンボリックリンクを作成します. 

<p>例えば, クラス C ネットワークの経路制御を必要とする, 
   三人のダイアルアップユーザ fred, sam, mary がいるとすると, 
   以下のコマンドを実行することになります: 

<tscreen><verb>
   # ln -s /etc/ppp/ppp-shell /etc/ppp/ppp-fred
   # ln -s /etc/ppp/ppp-shell /etc/ppp/ppp-sam
   # ln -s /etc/ppp/ppp-shell /etc/ppp/ppp-mary
</verb></tscreen>

<p>これらのユーザのダイアルアップアカウントでは, 上で作成した
   それぞれのシンボリックリンクをログインシェルとして設定しておきます. 
   (つまり, ユーザ mary のログインシェルは <tt>/etc/ppp/ppp-mary</tt> に
   なります). 

<sect3><heading>動的 IP ユーザのための ppp.conf の設定</heading>

<p><tt>/etc/ppp/ppp.conf</tt> ファイルは, 大体以下のような内容になるでしょう: 

<tscreen><verb>
   default:
    set debug phase lcp chat
    set timeout 0

   ttyd0: 
    set ifaddr 203.14.100.1 203.14.100.20 255.255.255.255
    enable proxy

   ttyd1:
    set ifaddr 203.14.100.1 203.14.100.21 255.255.255.255
    enable proxy
</verb></tscreen>
 
<p>上の例のように段をつける (インデントする) 必要があることに注意してください. 

<p><tt>default:</tt> エントリはセッションごとにロードされます. 
   <tt>/etc/ttys</tt> で有効にしてある各ダイアルアップ回線ごとに一つ, 
   上記の <tt>ttyd0:</tt> のようなエントリを作成します. 
   各行の相手側アドレスとして, それぞれ別の IP アドレスを 
   動的 IP ユーザのための IP アドレスのプールから割り当てておく必要があります. 

<sect3><heading>静的 IP ユーザのための ppp.conf の設定</heading>

<p>上のサンプルの <tt>/etc/ppp/ppp.conf</tt> の内容に加えて, 
   静的に IP を割り当てられたダイアルアップユーザ
   それぞれのためのエントリを追加する必要があります. 
   ここでも fred, sam, mary の例を使うことにしましょう. 
 
<tscreen><verb>
   fred:
    set ifaddr 203.14.100.1 203.14.101.1 255.255.255.255
 
   sam:
    set ifaddr 203.14.100.1 203.14.102.1 255.255.255.255
 
   mary:
    set ifaddr 203.14.100.1 203.14.103.1 255.255.255.255
</verb></tscreen> 

<p>必要であれば, それぞれの静的 IP ユーザに対する経路制御情報も
   <tt>/etc/ppp/ppp.linkup</tt> ファイルに書いておくべきでしょう. 
   以下の例ではクライアントの PPP リンクを経由する, 
   クラス C の <tt>203.14.101.0</tt> ネットワークへの経路を追加しています. 

<tscreen><verb>
   fred:
    add 203.14.101.0 netmask 255.255.255.0 HISADDR
 
   sam:
    add 203.14.102.0 netmask 255.255.255.0 HISADDR
 
   mary:
    add 203.14.103.0 netmask 255.255.255.0 HISADDR
</verb></tscreen> 

<sect3><heading>mgetty, AutoPPP, マイクロソフト拡張の詳細</heading>

<sect4><heading>Mgetty と AutoPPP<label id="userppp:mgetty">
       </heading>

<p>AUTO_PPP オプションつきでコンパイルした mgetty を使えば, mgetty が
   PPP 接続の LCP フェーズを検出して, 自動的に PPP シェルを起動するように
   設定することができます. 
   しかし この場合, デフォルトの login/password シーケンスは発生しないので, 
   ユーザの認証は PAP または CHAP を使っておこなう必要があります. 

<p>このセクションでは, ユーザ (あなた) が問題なく
   AUTO_PPP オプションつきの mgetty (v0.99beta またはそれ以降) の設定, 
   コンパイル, インストールができているものと仮定しています. 
 
<p><tt>/usr/local/etc/mgetty+sendfax/login.config</tt> ファイルが
   以下の行を含んでいることを確認してください: 
 
<tscreen><verb>
   /AutoPPP/ -     -       /etc/ppp/ppp-pap-dialup
</verb></tscreen>
 
<p>これにより, PPP 接続を検出したら mgetty が <tt>ppp-pap-dialup</tt> 
   スクリプトを実行するようになります. 
 
<p><tt>/etc/ppp/ppp-pap-dialup</tt> という名前で, 以下のような内容のファイルを
   作成します (このファイルには実行可能属性をつけておく必要があります): 

<tscreen><verb>
   #!/bin/sh
   exec /usr/sbin/ppp -direct pap
</verb></tscreen>   

<p>さらに, かかってきた電話すべてを自分で扱うエントリを 
   <tt>/etc/ppp/ppp.conf</tt> に作成します:

<tscreen><verb>
   pap:
    enable pap
    set ifaddr 203.14.100.1 203.14.100.20-203.14.100.40
    enable proxy
</verb></tscreen>

<p>この方法でログインする それぞれのユーザは, PAP によるユーザ認証を
   おこなうために <tt>/etc/ppp/ppp.secret</tt> ファイルにユーザ名とパスワードを
   書いておくか, または <tt>/etc/password</tt> ファイルを使うように, 

<tscreen><verb>
  enable passwdauth
</verb></tscreen>

   オプションを (/etc/ppp/ppp.conf に) 追加しておく必要があるでしょう. 

<p>ユーザに静的な IP アドレスを割り当てる場合には, そのアドレスを 
   <tt>/etc/ppp/ppp.secret</tt> の第三引数として指定することができます. 
   サンプルについては, <tt>/etc/ppp/ppp.secret.sample</tt> を参照してください. 

<sect4><heading>マイクロソフト拡張</heading>

<p>クライアントからの要求に応じて, ppp が DNS や NetBIOS ネームサーバの
   アドレスを通知するように設定をおこなうこともできます. 

<p>バージョン 1.X の ppp で これらの拡張機能を有効にするには, 以下の行を 
   <tt>/etc/ppp/ppp.conf</tt> の適切なセクションに追加する必要があるでしょう. 

<tscreen><verb>
    enable msext
    set ns 203.14.100.1 203.14.100.2
    set nbns 203.14.100.5
</verb></tscreen>  

   バージョン 2 以降の ppp では, 以下のようになります: 

<tscreen><verb>
    accept dns
    set dns 203.14.100.1 203.14.100.2
    set nbns 203.14.100.5
</verb></tscreen>  

<p>これにより, クライアントはプライマリとセカンダリのネームサーバアドレス
   および NetBIOS ネームサーバホストを知ることができます. 

<p>バージョン 2 以降の ppp では, ``set dns'' の行を省略した場合には 
   <tt>/etc/resolv.conf</tt> に書かれているネームサーバのアドレスを使用します. 

<sect2><heading>PAP および CHAP による認証<label id="userppp:PAPnCHAP">
       </heading>

<p>いくつかのプロバイダでは、PAP または CHAP のいずれかの認証メカニズムを
   使用して接続時の認証をおこなうようにシステムを設定しています. 
   この場合, プロバイダは接続の際に <tt>login:</tt> プロンプトを送信せず, 
   最初から PPP で通信を始めようとするでしょう. 

   PAP ではパスワードがそのまま送られてしまうため, CHAP に比べると安全性が
   低くなりますが, このパスワードはシリアル回線のみを通して送られます. 
   そのため, クラッカーが「盗み聞き」する余地は多くないので, 通常ここの
   セキュリティは問題にはなりません. 

   <ref id="userppp:staticIP" name="静的 IP アドレスによる PPP 接続">または
   <ref id="userppp:dynamicIP" name="動的 IP アドレスによる PPP 接続">の
   セクションに戻って, 以下の変更をおこないます: 

<tscreen><verb>
7       set login
.....
12      set authname MyUserName
13      set authkey MyPassword
</verb></tscreen>

   これまでと同様に, 行番号は取り除いておいてください. 
   これは解説の際に参照する行を示すためにつけたものです. 
   なお, 少なくともスペース 1 個分の段づけ (インデント) が必要です. 

<descrip>
<tag/Line 7:/  PAP または CHAP を使用する場合, 通常 プロバイダはサーバへの
               ログインを必要としません. そのため, "set login" 文字列を
               無効にしておかなければいけません. 

<tag/Line 12:/ この行は PAP/CHAP ユーザ名を指定します. <tt>MyUserName</tt> に
               正しい値を入れておく必要があります. 
<tag/Line 13:/ この行は PAP/CHAP パスワードを指定します. <tt>MyPassword</tt> に
               正しい値を入れておく必要があります. 
               PAP と CHAP はデフォルトで両方とも受け付けられるようになって
               いますが, PAP や CHAP を使用するという意思を明示するために, 
<tscreen><verb>
15      accept PAP
</verb></tscreen>
               または
<tscreen><verb>
15      accept CHAP
</verb></tscreen>
               という行を追加しておくのも良いでしょう. 
</descrip>

<sect2><heading>動作中の ppp の設定変更</heading>

<p>適切な診断ポートが設定されている場合には, バックグラウンドで動作中の 
   ppp プログラムと通信することができます. 
   この設定をおこなうためには, 以下の行を設定ファイルに追加しておきます: 

<tscreen><verb>
        set server /var/run/ppp-tun%d DiagnosticPassword 0177
</verb></tscreen>
 
   これにより, ppp は指定された unix ドメインのソケットをモニタして, 
   クライアントから正しいパスワードを受け取った後にアクセスを許可します. 
   このソケット名に含まれる %d は, この ppp が使用している tun デバイスの
   デバイス番号で置きかえられます. 

<p>一旦ソケットの設定が終了したら, スクリプト中で <tt>pppctl(8)</tt> を
   使用して, 動作中の ppp を操作することができるでしょう. 

<sect1><heading>システムの最終設定<label id="userppp:final">
       </heading>

<p>これで ppp の設定は終りました. 
   しかし ppp を動かす前に, まだ少し必要なことがあります. 
   それらの設定は, すべて <tt>/etc/rc.conf</tt> ファイルを
   編集することでおこないます. 
   (このファイルは以前には <tt>/etc/sysconfig</tt> と呼ばれていました) 

   このファイルを上から順に設定していきます. 
   まずは ``hostname='' の行が設定されていることを確認します. 
   例えば以下のように: 

<tscreen><verb>
   hostname=foo.bar.com
</verb></tscreen>

<p>もしプロバイダが静的な IP アドレスとホスト名を割り当てているのなら, 
   ホスト名としてそれを使うのが おそらくベストでしょう. 

<p>次に network_interfaces 変数を調べます. 必要に応じて (on demand) 
   プロバイダにダイアルするようにシステムを設定したい場合には, 
   tun0 デバイスがこのリストに追加されていることを確認しておきます. 
   それ以外の場合には, tun0 デバイスをリストから削除しておきます. 

<tscreen><verb>
   network_interfaces="lo0 tun0"
   ifconfig_tun0=
</verb></tscreen>

   <tt>ifconfig_tun0</tt> 変数が空で, /etc/start_if.tun0 という名前の
   ファイルが作成されていなければならない ということに注意してください. 
   このファイルの内容は以下のようになります. 

<tscreen><verb>
   ppp -auto mysystem
</verb></tscreen>

   このスクリプトはネットワークの設定時に実行され, 
   ppp デーモンを自動モードで立ち上げます. 
   このマシンがもし LAN のゲートウェイであれば, 
   <tt>-alias</tt> スイッチも使用したいと思うかもしれません. 
   詳細に関しては, マニュアルページを参照してください. 


<p>以下のようにルータプログラムを ``NO'' に設定します. 

<tscreen><verb>
   router_enable=NO            (/etc/rc.conf)
   router=NO                   (/etc/sysconfig)
</verb></tscreen>

   <tt>routed</tt> は, ppp が作成したデフォルトのルーティングテーブル
   エントリを削除してしまう場合がありますので, 
   (初期設定では起動されるようになっている) <tt>routed</tt> デーモンが
   起動されないようにしておくことが重要です. 

<p>``sendmail_flags'' 行が ``-q'' オプションを含まないように
   設定しておいた方がよいでしょう. さもないと, sendmail が
   アドレスを調べようとして発信をおこなってしまう場合があります. 
   以下のような設定で良いでしょう: 

<tscreen><verb>
   sendmail_flags="-bd"
</verb></tscreen>

   この結果, PPP リンクを立ち上げた時には
   いつでも以下のコマンドを実行して, キューにたまっているメールを
   sendmail に送信させる作業が必要になるでしょう. 

<tscreen><verb>
   # /usr/sbin/sendmail -q
</verb></tscreen>

<p>ppp.linkup 中で <tt>!bg</tt> コマンドを使用することで, これを自動的に
   おこなうこともできます: 

<tscreen><verb>
1     provider:
2       delete ALL
3       add 0 0 HISADDR
4       !bg sendmail -bd -q30m
</verb></tscreen>


<p>こうするのが嫌であれば, SMTP トラフィックをブロックするように
   "dfilter" を設定しておくこともできます. 
   詳細についてはサンプルファイルを参照してください. 

<p>後はマシンをリブートするだけです. 

<p>リブートが終ったら, 

<tscreen><verb>
   # ppp
</verb></tscreen>

   コマンドを実行し, 続いて PPP セッションを開始させるために
   ``dial provider'' と入力することもできますし, 
   (start_if.tun0 スクリプトを作成していない場合に), 
   外部へのトラフィックが発生した時に, ppp が自動的に
   セッションを確立してくれるようにしたいのであれば, 
   以下のコマンドを実行することもできます. 

<tscreen><verb>
   # ppp -auto provider
</verb></tscreen>

<sect1><heading>まとめ</heading>

<p>要約すると, 初めて ppp を設定する際には, 以下のステップが不可欠です: 

<p>クライアント側:

<itemize>
   <item>カーネルに tun デバイスが組み込まれていることを確認. 
   <item><tt>/dev</tt> ディレクトリに tunX デバイスファイルが
         存在することを確認. 
   <item><tt>/etc/ppp/ppp.conf</tt> にエントリを作成. 
         ほとんどのプロバイダでは, <tt>pmdemand</tt> の例で充分でしょう. 
   <item>動的 IP アドレスを使用するなら, <tt>/etc/ppp/ppp.linkup</tt> に
         エントリを作成. 
   <item><tt>/etc/rc.conf</tt> (または <tt>sysconfig</tt>) ファイルを更新. 
   <item>必要に応じてダイヤル (demand dialing) したいのであれば, 
         start_if.tun0 スクリプトを作成. 
</itemize>

<p>サーバ側:
<itemize>
   <item>カーネルに tun デバイスが組み込まれていることを確認. 
   <item><tt>/dev</tt> ディレクトリに tunX デバイスファイルが
         存在することを確認. 
   <item>(vipw(8) コマンドを使って) /etc/passwd にエントリを作成. 
   <item>このユーザのホームディレクトリに
         ``ppp -direct direct-server'' か何かを実行するプロファイルを作成. 
   <item><tt>/etc/ppp/ppp.conf</tt> にエントリを作成. 
         <tt>direct-server</tt> の例で充分でしょう. 
   <item><tt>/etc/ppp/ppp.linkup</tt> にエントリを作成. 
   <item><tt>/etc/rc.conf</tt> (または <tt>sysconfig</tt>) ファイルを更新. 
</itemize>

<sect1><heading>謝辞</heading>

<p>ハンドブックの このセクションは, 1998 年 8 月 10 日 (月) に 
   &a.brian によって更新されました. 

<p>以下の人々による情報提供, 批評そして提案に感謝します: 

<p>&a.nik
<p>&a.dirkvangulik
<p>&a.pjc
