<!-- $Id: x.sgml,v 1.1.1.1 1997-11-17 15:49:00 max Exp $ -->
<!-- The FreeBSD Japanese Documentation Project -->
<!-- Original revision: 1.1 --> 

  <sect>
    <heading>X Window System と仮想コンソール<label id="x"></heading>
    <p><em>訳: &a.motoyuki;.<newline>13 November 1997.</em>

    <sect1>
      <heading>X を動かしたいのですが, どうすればいいのですか?</heading>

      <p>もっとも簡単な方法は (訳注: FreeBSD の) インストールの際に
      X を動かすことを指定するだけです.

      <p>それから <htmlurl url=
      "http://www.freebsd.org/cgi/man.cgi?manpath=xfree86&amp;query=xf86config"
      name="xf86config">
      ツールのドキュメントを読んでこれに従ってください.
      このツールはあなたのグラフィックカードやマウスなどに合わせて
      XFree86(tm) の設定を行うのを助けてくれます.

      <p>Xaccel サーバーについて調べてみるのもいいでしょう.
      これはとても納得のいく価格で販売されています. 詳しくは
      <ref id="xig" name="Xi Graphics について"> をご覧ください.

    <sect1>
      <heading>私のマウスはなぜ X で動かないのでしょうか?</heading>

      <p>syscons (デフォルトのコンソールドライバ) を使っているのであれば,
      それぞれの仮想スクリーンでマウスポインターをサポートするように
      FreeBSD を設定できます. X でのマウスの衝突を避けるために, syscons は
      ``<tt>/dev/sysmouse</tt>'' という仮想デバイスをサポートしています.
      本物のマウスデバイスから入力された全てのマウスのイベントは sysmouse
      デバイスへ MouseSystems プロトコルで出力されます.
      一つ以上の仮想コンソールと X の <bf/両方で/ マウスを使いたい場合,
      以下のように設定することをお勧めします:

      <verb>
        /etc/rc.conf:
          moused_type=ps/2            # 実際のマウスのタイプ
          moused_port=/dev/psm0       # 実際のマウスポート
          moused_flags=

        /etc/XF86Config
          Section Pointer
              Protocol "MouseSystems"
              Device   "/dev/sysmouse"
              .....
      </verb>

      <p>X で ``<tt>/dev/mouse</tt>'' を使うのを好む人もいます.
      この場合は, ``<tt>/dev/mouse</tt>'' を
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?sysmouse"
      name="/dev/sysmouse">
      にリンクしてください:

      <verb>
        # cd /dev
        # rm -f mouse
        # ln -s sysmouse mouse
      </verb>

    <sect1>
      <heading>X のメニューやダイアログボックスがうまく動きません.</heading>

      <p>Num Lock キーをオフにしてください. 

      <p>Num Lock キーがデフォルトでブート時にオンになる場合は, 
      <tt/XF86config/ ファイルの ``<tt/Keyboard/'' セクションに
      以下の行を加えてもいいでしょう. 

      <verb>
        # Let the server do the NumLock processing.  This should only be
        # required when using pre-R6 clients
            ServerNumLock
      </verb>

      訳注: この問題は XFree86 3.2 以降では解決しています. 

    <sect1>
      <heading>仮想コンソールとは何ですか? どうやったら使えますか?</heading>

      <p>仮想コンソールは, 簡単にいうと, ネットワークや X
      を動かすなどの複雑なことをおこなわずに, いくつかのセッションを
      同時におこなうことを可能にします. 

      <p>システムのスタート時には, ブートメッセージが出た後に login 
      プロンプトが表示されます. そこで login ネームとパスワードを
      入力すると 1 番目の仮想コンソール上で仕事 (あるいは遊び) を
      始めることができます.
 
      <p>他のセッションを始めたい場合もあるでしょう. それは動かしている
      プログラムのドキュメントを見たり, FTP の転送が終わるまで待つ間
      メールを読もうとしたりすることかもしれません.
      Alt-F2 を押す (Alt キーを押しながら F2 キーを押す) と 2 番目の
      「仮想コンソール」で login プロンプトが待機していることが
      わかります. 最初のセッションに戻りたいときは Alt-F1 を押します. 

      <p>標準の FreeBSDインストールでは 3 枚の仮想コンソールが
      有効になっていて, Alt-F1, Alt-F2, Alt-F3 で仮想コンソール間の
      切替えをおこないます. 

      より多くの仮想コンソールを有効にするには, <htmlurl 
      url="http://www.freebsd.org/cgi/man.cgi?ttys" name="/etc/ttys">
      を編集して ``Virtual terminals'' のコメント行の後に ``<tt/ttyv4/''
      から ``<tt/ttyvc/'' の手前までのエントリを加えます
      (以下の例は先頭には空白は入りません) :
 
      <verb>
        # /etc/ttys には ttyv3 がありますので 
        # "off" を "on" に変更します. 
        ttyv3   "/usr/libexec/getty Pc"         cons25  on secure
        ttyv4   "/usr/libexec/getty Pc"         cons25  on secure
        ttyv5   "/usr/libexec/getty Pc"         cons25  on secure
        ttyv6   "/usr/libexec/getty Pc"         cons25  on secure
        ttyv7   "/usr/libexec/getty Pc"         cons25  on secure
        ttyv8   "/usr/libexec/getty Pc"         cons25  on secure
        ttyv9   "/usr/libexec/getty Pc"         cons25  on secure
        ttyva   "/usr/libexec/getty Pc"         cons25  on secure
        ttyvb   "/usr/libexec/getty Pc"         cons25  on secure
      </verb> 

      <p>多くするか少なくするかはあなたの自由です. より多くの仮想
      ターミナルを使うとより多くのリソースを使うことになります.
      8MB 以下のメモリしかない場合はこれは重要な問題です.
      もし必要があれば ``<tt/secure/'' を ``<tt/insecure/''
      に変更してください. 
 
      <p><bf/重要/ X を使いたいのであれば, 最低一つの仮想ターミナル
      (のエントリ) を使わずに残しておくか, off にしておく必要があります.
      つまり, 12 個の Alt-ファンクションキー全てでログインプロンプトを
      出したいのならば不運にも X は使えない, ということです. 
      同じマシンで X サーバーも動かしたいのならば 11 個しか使えません.

      <p>仮想コンソールを無効にするもっとも簡単な方法はコンソールを
      off にすることです. 例えば 12 個全てのターミナルを割り当てている
      状態で X を動かしたいときは仮想ターミナル 12 を変更します:

      <verb>
        ttyvb   "/usr/libexec/getty Pc"         cons25  on secure
      </verb>

      <p>これを次のように変更します:

      <verb>
        ttyvb   "/usr/libexec/getty Pc"         cons25  off secure
      </verb>

      <p>キーボードにファンクションキーが 10 個しかないのであれば
      次のように設定します. 

      <verb>
        ttyv9   "/usr/libexec/getty Pc"         cons25  off secure
        ttyva   "/usr/libexec/getty Pc"         cons25  off secure
        ttyvb   "/usr/libexec/getty Pc"         cons25  off secure
      </verb>

      <p>(これらの行を消すだけでもいいです.)
 
      <p><htmlurl 
      url="http://www.freebsd.org/cgi/man.cgi?ttys" name="/etc/ttys">
      を編集したら次は十分な数の仮想ターミナルデバイスを
      作らなくてはなりません. もっとも簡単な方法を示します:

      <verb>
        # cd /dev
        # ./MAKEDEV vty12                 # For 12 devices
      </verb>

      <p>さて, 仮想コンソールを有効にするのにもっとも簡単 (そして確実) 
      な方法はリブートすることです. しかし, リブートしたくない場合は,
      X ウィンドウシステムを終了させて次の内容を実行します 
      (<tt/root/ 権限で) :

      <verb>
        kill -HUP 1
      </verb>

      <p>重要な点はこのコマンドを実行する前に X ウィンドウシステムを
      完全に終了させておくことです. もしそうしないと kill コマンドを
      実行した後にシステムはおそらくハングアップするでしょう. 

    <sect1>
      <heading>X から仮想コンソールに切替えるにはどうすればよいのですか? </heading>

      <p>コンソールが X の表示をしている場合は, Ctrl-Alt-F1 などを使って
      仮想コンソールの切替えをおこなうことができます. ただし, X
      から離れて仮想ターミナルへ移っている時は Alt-ファンクションキーを
      使って他の仮想ターミナルへ切替えたり X へ戻ったりします. 
      コントロールキーは押さないでください. Ctrl-Alt-ファンクションキーの
      組合せは X から仮想ターミナルに移る時だけ利用してください.
      コントロールキーを押してしまうと ``control-lock'' モードになり
      テキストコンソールが止まってしまいます. コントロールキーを押して
      回復させてください. 

      <p>訳注: X に戻るには 3枚の仮想コンソールが有効になっている場合は
      Alt-F4 です. 有効な仮想コンソールの数 +1 のファンクションキーの
      位置に X が割り当てられます. 

    <sect1>
      <heading>XDM を<tt>/etc/ttys</tt>ファイルから起動させるにはどうしますか?</heading>

      <p><htmlurl url=
      "http://www.freebsd.org/cgi/man.cgi?manpath=xfree86&amp;query=xdm"
      name="xdm"> を
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?ttys"
      name="/etc/ttys"> から起動するのはよい方法ではありません.
      なぜこのようなことが README ファイルなどにあるのかよくわかりません. 

      <p><htmlurl url="http://www.freebsd.org/cgi/man.cgi?rc"
      name="rc.local"> から起動させ, どのように実行されるか明記して
      おいてください. それが <tt/rc.local/ の最後の処理であれば, 
      後ろに ``<tt/sleep 1/'' をおいて <tt/rc/ シェルが終了する前に
      きちんとデーモンになるようにします. 

      <p><tt/xdm/ は引数を持たずに実行されるでしょう (つまりデーモン
      として起動されます).

      <bf/注:/ 古いバージョンの FAQ では 
      <tt>/usr/X11R6/lib/X11/xdm/Xservers</tt> ファイルに X の使う
      <tt/vt/ を加えるように書いてあります. これは必要ありません:
      X は最初に見つけた利用可能な <tt/vt/ を使います. 

    <sect1>
      <heading>xconsole を動かそうとすると ``Couldn't open console'' とエラーが出ます. </heading>

      <p><htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?manpath=xfree86&amp;query=X"
      name="X"> を
      <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?manpath=xfree86&amp;query=startx"
      name="startx"> で起動しますと, /dev/console のパーミッションは
      <tt /変更ができない/ ようになっていますので,
      <htmlurl
      url="http://www.freebsd.org/cgi/man.cgi?manpath=xfree86&amp;query=xterm"
      name="xterm -C"> や
      <htmlurl url=
      "http://www.freebsd.org/cgi/man.cgi?manpath=xfree86&amp;query=xconsole"
      name="xconsole"> は動きません. 
    
      <p>これはコンソールのパーミッションが標準ではそのように
      設定されているからです. マルチユーザシステムでは, ユーザの誰もが
      システムコンソールに書き込むことが可能である必要は必ずしもありません.
      VTY を使い 直接マシンにログインするユーザのために,
      このような問題を解決するために
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?fbtab"
      name="fbtab"> というファイルがあります. 

      <p>要点を述べると, 次のような形式の行を
      <htmlurl url="http://www.freebsd.org/cgi/man.cgi?fbtab"
      name="fbtab"> に加えます. 

      <verb>
	/dev/ttyv0 0600 /dev/console
      </verb>

      <p>そうすると, <tt>/dev/ttyv0</tt> からログインしたユーザが
      コンソールを所有することになるでしょう. 


    <sect1>
      <heading>私の PS/2 マウスは X ウィンドウシステム上でうまく動きません. </heading>

      <p>あなたのマウスとマウスドライバがうまく同期していないようです. 
      X から仮想ターミナルへ切替えて X へ戻ると再同期するかもしれません.
      この問題がよく起きるようであれば, カーネルコンフィグレーション
      ファイルに次のオプションを書いてカーネルを再構成してみてください. 

      <verb>
        options PSM_CHECKSYNC
      </verb>

      <p>もし, カーネルの再構築をおこなったことがないのであれば
      <ref id="make-kernel" name="カーネルを作る">のセクションを
      見てください. 

      <p>このオプションにより, マウスとドライバの同期の問題の起きる
      可能性は少なくなるでしょう. もしそれでもこの問題が起きるようであれば,
      マウスとドライバが再同期するまでマウスボタンのどれかを
      押し続けてください. 

      <p>このオプションは残念ながら, すべてのシステムで働くわけではなく
      また, ``tap'' の特色を持つ ALPS GlidePoint デバイスを PS/2
      マウスポートにつないだ場合は無効です. 

  </sect>

