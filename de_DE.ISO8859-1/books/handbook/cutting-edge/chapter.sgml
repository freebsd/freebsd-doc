<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde: de-docproj/books/handbook/cutting-edge/chapter.sgml,v 1.108 2011/09/03 15:50:07 bcr Exp $
     basiert auf: 1.255
-->

<chapter id="updating-upgrading">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Jim</firstname>
	<surname>Mock</surname>
	<contrib>Umstrukturiert und aktualisiert von </contrib>
      </author>
      <!-- Mar 2000 -->
    </authorgroup>

    <authorgroup>
      <author>
	<firstname>Jordan</firstname>
	<surname>Hubbard</surname>
	<contrib>Im Original von </contrib>
      </author>
      <author>
	<firstname>Poul-Henning</firstname>
	<surname>Kamp</surname>
      </author>
      <author>
	<firstname>John</firstname>
	<surname>Polstra</surname>
      </author>
      <author>
	<firstname>Nik</firstname>
	<surname>Clayton</surname>
      </author>
    </authorgroup>

    <!-- with feedback from various others -->
    <authorgroup>
      <author>
	<firstname>Martin</firstname>
	<surname>Heinen</surname>
	<contrib>&Uuml;bersetzt von </contrib>
      </author>
    </authorgroup>
  </chapterinfo>

  <title>&os; aktualisieren</title>

  <sect1 id="updating-upgrading-synopsis">
    <title>&Uuml;bersicht</title>

    <para>&os; wird zwischen einzelnen Releases st&auml;ndig weiter
      entwickelt.  Manche Leute bevorzugen die offiziellen Release-Versionen,
      w&auml;hrend andere wiederum lieber auf dem aktuellen Stand der
      Entwicklung bleiben m&ouml;chten.  Wie dem auch sei, sogar offizielle
      Release-Versionen werden oft mit Sicherheitsaktualisierungen und
      anderen kritischen Fehlerbereinigungen versorgt.  Unabh&auml;ngig von
      der eingesetzten Version bringt &os; alle n&ouml;tigen Werkzeuge mit,
      um ihr System aktuell zu halten und es innerhalb verschiedener
      Versionen zu aktualisieren.  Dieses Kapitel hilft Ihnen bei der
      Entscheidung, ob Sie mit dem Entwicklungssystem Schritt halten oder
      ein Release verwenden wollen.  Die zugrundeliegenden Werkzeuge um
      Ihr System aktuell zu halten werden ebenfalls vorgestellt.</para>

    <para>Nachdem Sie dieses Kapitel gelesen haben, werden Sie</para>

    <itemizedlist>
      <listitem>
	<para>wissen, welche Werkzeuge verwendet werden k&ouml;nnen, um das
	  System und die Port-Sammlung zu aktualisieren.</para>
      </listitem>

      <listitem>
	<para>wissen, wie Sie Ihr System mit
          <application>freebsd-update</application>,
          <application>CVSup</application>,
          <application>CVS</application> oder
          <application>CTM</application>
          aktualisieren.</para>
      </listitem>

      <listitem>
	<para>wissen, wie man das aktuell installierte System mit einer
	  urspr&uuml;nglichen Version vergleicht.</para>
      </listitem>

      <listitem>
	<para>wissen, wie Sie ihre Dokumentation mit
	  <application>CVSup</application> oder Dokumentations-Ports
          <!-- oder <application>Docsnap</application> -->
	  aktuell halten k&ouml;nnen.</para>
      </listitem>

      <listitem>
	<para>den Unterschied zwischen den beiden Entwicklungszweigen
	  &os.stable; und &os.current; kennen.</para>
      </listitem>

      <listitem>
	<para>Wissen, wie Sie das komplette Basissystem mit <command>make
	  buildworld</command> neu bauen und installieren.</para>
      </listitem>
    </itemizedlist>

    <para>Bevor Sie dieses Kapitel lesen, sollten Sie</para>

    <itemizedlist>
      <listitem>
	<para>Ihr Netzwerk richtig konfiguriert haben
	  (<xref linkend="advanced-networking">) und</para>
      </listitem>

      <listitem>
	<para>wissen, wie Sie Software Dritter installieren
	  (<xref linkend="ports">).</para>
      </listitem>
    </itemizedlist>

    <note>
      <para>Im gesamten Kapitel wird der Befehl <command>cvsup</command>
        verwendet, um die &os; Quellen zu beziehen und zu aktualisieren.  Um es
        zu verwenden, ben&ouml;tigen Sie einen Port oder ein Paket wie
        <filename role="package">net/cvsup</filename> (falls Sie den
        graphischen <command>cvsup</command>-Client nicht ben&ouml;tigen,
        k&ouml;nnen Sie auch nur den Port
        <filename>net/cvsup-without-gui</filename> installieren).
	Alternativ k&ouml;nnen Sie auch &man.csup.1; verwenden, das bereits
	Teil des Basissystems ist.</para>
    </note>
  </sect1>

  <sect1 id="updating-upgrading-freebsdupdate">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Tom</firstname>
          <surname>Rhodes</surname>
          <contrib>Geschrieben von </contrib>
        </author>
      </authorgroup>

      <authorgroup>
        <author>
          <firstname>Colin</firstname>
          <surname>Percival</surname>
          <contrib>Basierend auf bereitgestellten Mitschriften von </contrib>
        </author>
      </authorgroup>

      <authorgroup>
        <author>
          <firstname>Benedict</firstname>
          <surname>Reuschling</surname>
          <contrib>&Uuml;bersetzt von </contrib>
        </author>
      </authorgroup>
    </sect1info>
    <title>&os;-Update</title>

    <indexterm><primary>Updating and Upgrading</primary></indexterm>
    <indexterm>
      <primary>freebsd-update</primary>
      <see>updating-upgrading</see>
    </indexterm>

    <para>Das Einspielen von Sicherheitsaktualisierungen ist ein wichtiger
      Bestandteil bei der Wartung von Computersoftware, besonders wenn es um
      das Betriebssystem geht.  F&uuml;r lange Zeit war dieser Prozess unter
      &os; nicht einfach.  Fehlerbehebungen mussten auf den Quellcode
      angewendet werden, danach wurde der Code zu neuen Bin&auml;rdateien
      &uuml;bersetzt und schliesslich mussten diese Dateien neu installiert
      werden.</para>

    <para>Das ist seit l&auml;ngerem nicht mehr der Fall, da &os; jetzt ein
       Werkzeug namens <command>freebsd-update</command> enth&auml;lt.  Dieses
       Werkzeug bringt zwei getrennte Funktionen mit sich.   Die erste Funktion
       erm&ouml;glicht die Anwendung von Sicherheitsaktualisierungen im
       Bin&auml;rformat auf das &os; Basissystem, ohne dieses neu zu
       &uuml;bersetzen und zu installieren.  Die zweite Funktion
       unterst&uuml;tzt Aktualisierungen zwischen Haupt- und
       Unterversionen.</para>

    <note>
      <para>Bin&auml;re Aktualisierungen sind f&uuml;r alle Architekturen und
        Releases verf&uuml;gbar, die aktuell vom &os; Security Team betreut
        werden.  Vor
        der Aktualisierung auf eine neue Release-Version sollten die aktuellen
        Ank&uuml;ndigungen zu dem Release gelesen werden, da diese wichtige
        Informationen zu der gew&uuml;nschten Version enthalten.  Diese
        Ank&uuml;ndigungen finden Sie unter dem folgenden Link: <ulink
        url="http://www.FreeBSD.org/releases/"></ulink>.</para>
    </note>

    <para>Wenn eine <command>crontab</command> existiert, welche die
      Eigenschaften von <command>freebsd-update</command> verwendet, muss diese
      deaktiviert werden, bevor die folgende Aktion gestartet wird.</para>

    <sect2 id="freebsdupdate-config-file">
      <title>Die Konfigurationsdatei</title>

      <para>Manche Anwender m&ouml;chten sicherlich Einstellungen in der
        Standard-Konfigurationsdatei unter
        <filename>/etc/freebsd-update.conf</filename> vornehmen, um
        bessere Kontrolle &uuml;ber den
        gesamten Prozess zu besitzen.  Die Optionen sind sehr gut dokumentiert,
        jedoch ben&ouml;tigen die folgenden ein paar zus&auml;tzliche
        Erkl&auml;rungen:</para>

      <programlisting># Components of the base system which should be kept updated.
Components src world kernel</programlisting>

      <para>Dieser Parameter kontrolliert, welche Teile von &os; auf dem
        aktuellen Stand gehalten werden sollen.  Die Voreinstellung ist es, den
        Quellcode zu aktualisieren, das gesamte Basissystem sowie den Kernel.
        Die Komponenten sind die gleichen wie w&auml;hrend der Installation,
        also w&uuml;rde beispielsweise das hinzuf&uuml;gen von
        <literal>world/games</literal> an dieser Stelle es erlauben,
        Aktualisierungen f&uuml;r Spiele anzuwenden.
        Die Verwendung von <literal>src/bin</literal> erlaubt es, den
        Quellcode in <filename class="directory">src/bin</filename> aktuell zu
        halten.</para>

      <para>Die beste Einstellung ist, diese Option so zu belassen, da eine
        &Auml;nderung es bedingt, dass man als Benutzer jede Komponente
        auflisten muss, die aktualisiert werden soll.  Dies k&ouml;nnte
        katastrophale Folgen nach sich ziehen, da der Quellcode und die
        Bin&auml;rdateien dadurch nicht mehr synchron w&auml;ren.</para>

      <programlisting># Paths which start with anything matching an entry in an IgnorePaths
# statement will be ignored.
IgnorePaths</programlisting>

      <para>F&uuml;gen Sie Pfade wie <filename
        class="directory">/bin</filename> oder <filename
        class="directory">/sbin</filename> hinzu, um diese speziellen
        Verzeichnisse w&auml;hrend des Aktualisierungsprozesses unber&uuml;hrt
        zu lassen.  Diese Option kann verwendet werden, um zu verhindern, dass
        <command>freebsd-update</command> lokale &Auml;nderungen
        &uuml;berschreibt.</para>

      <programlisting># Paths which start with anything matching an entry in an UpdateIfUnmodified
# statement will only be updated if the contents of the file have not been
# modified by the user (unless changes are merged; see below).
UpdateIfUnmodified /etc/ /var/ /root/ /.cshrc /.profile</programlisting>

      <para>Aktualisieren Sie Konfigurationsdateien in den angegebenen
        Verzeichnissen nur, wenn diese nicht ge&auml;ndert wurden.  Jegliche
        &Auml;derung, die der Benutzer daran vorgenommen hat, wird die
        automatische Aktualisierung dieser Dateien ung&uuml;ltig machen.
        Es gibt eine weitere Option <literal>KeepModifiedMetadata</literal>,
        die <command>freebsd-update</command> instruiert, die &Auml;nderungen
        w&auml;hrend der Zusammenf&uuml;hrung zu speichern.</para>

      <programlisting># When upgrading to a new &os; release, files which match MergeChanges
# will have any local changes merged into the version from the new release.
MergeChanges /etc/ /var/named/etc/</programlisting>

      <para>Eine Liste von Verzeichnissen mit Konfigurationsdateien, in denen
        <command>freebsd-update</command> Zusammenf&uuml;hrungen versuchen
        soll.  Dieser Verschmelzungsprozess von Dateien ist eine Serie von
        &man.diff.1;-Korrekturen, &auml;hnlich wie &man.mergemaster.8; mit
        weniger Optionen. Die &Auml;nderungen werden entweder akzeptiert,
        &ouml;ffnen einen Editor oder <command>freebsd-update</command> bricht
        ab.  Wenn Sie im Zweifel sind, sichern Sie das <filename
        class="directory">/etc</filename> Verzeichnis und akzeptieren einfach
        die &Auml;nderungen. Lesen Sie <xref linkend="mergemaster">, um
        Informationen &uuml;ber das <command>mergemaster</command>-Kommando
        zu erhalten.</para>

      <programlisting># Directory in which to store downloaded updates and temporary
# files used by &os; Update.
# WorkDir /var/db/freebsd-update</programlisting>

      <para>In diesem Verzeichnis werden alle Korrekturen und tempor&auml;ren
        Dateien abgelegt.  F&uuml;r F&auml;lle in denen der Anwender eine
        Versionsaktualisierung vornimmt, sollte diesem Verzeichnis mindestens
        ein Gigabyte Festplattenspeicher zur Verf&uuml;gung stehen.</para>

      <programlisting># When upgrading between releases, should the list of Components be
# read strictly (StrictComponents yes) or merely as a list of components
# which *might* be installed of which &os; Update should figure out
# which actually are installed and upgrade those (StrictComponents no)?
# StrictComponents no</programlisting>

      <para>Wenn dies auf <literal>yes</literal> gesetzt ist, wird
        <command>freebsd-update</command> annehmen, dass die
        <literal>Components</literal>-Liste vollst&auml;ndig ist und nicht
        versuchen, &Auml;nderungen ausserhalb dieser Liste zu t&auml;tigen.
        Tats&auml;chlich wird <command>freebsd-update</command> versuchen, jede
        Datei zu aktualisieren, die zu der <literal>Components</literal>-Liste
        geh&ouml;hrt.</para>
    </sect2>

    <sect2 id="freebsdupdate-security-patches">
      <title>Sicherheitsaktualisierungen</title>

      <para>Sicherheitsaktualisierungen sind auf einer entfernten Maschine
        abgelegt und k&ouml;nnen durch das folgende Kommando heruntergeladen
        und installiert werden:</para>

      <screen>&prompt.root; <userinput>freebsd-update fetch</userinput>
&prompt.root; <userinput>freebsd-update install</userinput></screen>

      <para>Wenn irgendeine &Auml;nderung auf den Kernel angewendet wurde
        ben&ouml;tigt das System einen Neustart.  Wenn alles gut verlaufen ist,
        sollte das System aktualisiert sein und
        <command>freebsd-update</command> kann als n&auml;chtlicher
        &man.cron.8;-Job ablaufen.  Ein Eintrag in der Datei
        <filename>/etc/crontab</filename> ist f&uuml;r diese Aufgabe
        ausreichend:</para>

      <programlisting>@daily                                  root    freebsd-update cron</programlisting>

      <para>Dieser Eintrag besagt, dass einmal am Tag
        <command>freebsd-update</command> ausgef&uuml;hrt wird.  Auf diese
        Weise kann <command>freebsd-update</command> nur durch die Verwendung
        des <option>cron</option>-Arguments pr&uuml;fen, ob Aktualisierungen
        vorliegen.  Wenn Korrekturen existieren, werden diese automatisch auf
        die lokale Festplatte heruntergeladen, aber nicht eingespielt.  Der
        <username>root</username>-Benutzer bekommt eine Nachricht, damit dieser
        die Korrekturen manuell installiert.</para>

      <para>Sollte irgendetwas schief gelaufen sein, kann
        <command>freebsd-update</command> den letzten Satz von &Auml;nderungen
        mit dem folgenden Befehl zur&uuml;ckrollen:</para>

      <screen>&prompt.root; <userinput>freebsd-update rollback</userinput></screen>

      <para>Sobald dieser Vorgang abgeschlossen ist, sollte das System neu
        gestartet werden, wenn der Kernel oder ein beliebiges Kernelmodul
        ge&auml;ndert wurde.  Dies erm&ouml;glicht es &os;, die neuen
        Bin&auml;rdateien in den Hauptspeicher zu laden.</para>

      <para>Das <command>freebsd-update</command>-Werkzeug kann nur den
        <filename>GENERIC</filename>-Kernel automatisch aktualisieren.  Wenn
        ein selbstkonfigurierter Kernel verwendet wird, muss dieser neu
        erstellt und installiert werden, nachdem
        <command>freebsd-update</command> den Rest der Aktualisierungen
        durchgef&uuml;hrt hat.  Allerdings wird
        <command>freebsd-update</command> den
        <filename>GENERIC</filename>-Kernel in <filename
        class="directory">/boot/GENERIC</filename> erkennen und aktualisieren
        (falls dieser existiert), sogar dann, wenn dies nicht der
        aktuell verwendete Kernel des Systems ist.</para>

      <note>
        <para>Es ist eine gute Idee, immer eine Kopie des
          <filename>GENERIC</filename>-Kernels in <filename
          class="directory">/boot/GENERIC</filename> aufzubewahren.  Das wird
          bei der Diagnose von verschiedenen Problemen eine grosse Hilfe sein,
          sowie bei der Durchf&uuml;hrung von Versionsaktualisierungen mit
          <command>freebsd-update</command>, wie in <xref
          linkend="freebsdupdate-upgrade"> beschrieben ist.</para>
      </note>

      <para>Solange die Standardkonfiguration in
        <filename>/etc/freebsd-update.conf</filename> nicht ge&auml;ndert
        wurde, wird <command>freebsd-update</command> die aktualisierten
        Quellcodedateien des Kernels zusammen mit dem Rest der Neuerungen
        installieren.  Die erneute &Uuml;bersetzung und Installation ihres
        neuen, selbstkonfigurierten Kernels kann dann auf die &uuml;bliche
        Art und Weise durchgef&uuml;hrt werden.</para>

      <note>
        <para>Die Aktualisierungen, die &uuml;ber
          <command>freebsd-update</command> verteilt werden, betreffen nicht
          immer den Kernel.  Es ist nicht notwendig, den selbstkonfigurierten
          Kernel neu zu erstellen, wenn die Kernelquellen nicht durch die
          Ausf&uuml;hrung von <command>freebsd-update install</command>
          ge&auml;ndert wurden.  Allerdings wird
          <command>freebsd-update</command> auf alle F&auml;lle die Datei
          <filename>/usr/src/sys/conf/newvers.sh</filename> aktualisieren.
          Der aktuelle Patch-Level (angegeben durch die
          <literal>-p</literal>-Nummer, die von dem Kommando <command>uname
          -r</command> ausgegeben wird) wird aus dieser Datei ausgelesen.
          Die Neuinstallation des selbstkonfigurierten Kernels, selbst wenn
          sich daran nichts ge&auml;dert hat, erlaubt es &man.uname.1;, den
          aktuellen Patch-Level des Systems korrekt wiederzugeben.  Dies ist
          besonders hilfreich, wenn mehrere Systeme gewartet werden, da es
          eine schnelle Einsch&auml;tzung der installierten Aktualisierungen in
          jedem einzelnen System erm&ouml;glicht.</para>
      </note>
    </sect2>

    <sect2 id="freebsdupdate-upgrade">
      <title>Aktualisierungen an Haupt- und Unterversionen</title>

      <para>Dieser Prozess entfernt alte Objekt-Dateien und Bibliotheken, was
        dazu f&uuml;hrt, dass die meisten Anwendungen von Drittherstellern
        nicht mehr funktionieren.  Es wird empfohlen, dass alle installierten
        Ports entweder entfernt und neu installiert oder zu einem sp&auml;teren
        Zeitpunkt mittels <filename
        role="package">ports-mgmt/portupgrade</filename> aktualisiert werden.
        Die meisten Anwender werden wahrscheinlich einen Testlauf mittels des
        folgenden Kommandos durchf&uuml;hren wollen:</para>

      <screen>&prompt.root; <userinput>portupgrade -af</userinput></screen>

      <para>Dies sorgt daf&uuml;r, dass alles korrekt neu installiert wird.
        Beachten Sie, dass das Setzen der
        <makevar>BATCH</makevar>-Umgebungsvariable auf <literal>yes</literal>
        w&auml;hrend dieses Prozesses auf jede Eingabe mit
        <literal>ja</literal> antwortet, was es nicht mehr notwendig macht,
        manuell eingreifen zu m&uuml;ssen.</para>

      <para>Wenn ein selbstkonfigurierter Kernel verwendet wird, ist der
        Aktualisierungsprozess ein kleines bisschen aufw&auml;ndiger.  Eine
        Kopie des <filename>GENERIC</filename>-Kernels wir ben&ouml;tigt und
        sollte in <filename class="directory">/boot/GENERIC</filename> abgelegt
        sein.  Wenn der <filename>GENERIC</filename>-Kernel nicht bereits im
        System vorhanden ist, kann dieser &uuml;ber eine der folgenden Methoden
        bezogen werden:</para>

      <itemizedlist>
        <listitem>
          <para>Wenn ein eigener Kernel genau einmal gebaut wurde, ist der
            Kernel im Verzeichnis <filename
            class="directory">/boot/kernel.old</filename> in Wirklichkeit der
            <filename>GENERIC</filename>-Kernel.  Benennen Sie einfach dieses
            Verzeichnis in <filename
            class="directory">/boot/GENERIC</filename> um.</para>
        </listitem>

        <listitem>
          <para>Angenommen, direkter Zugriff auf die Maschine ist m&ouml;glich,
            so kann eine Kopie des <filename>GENERIC</filename>-Kernels von den
            CD-ROM-Medien installiert werden.  Legen Sie die Installations-CD
            ein und benutzen Sie die folgenden Befehle:</para>

          <screen>&prompt.root; <userinput>mount /cdrom</userinput>
&prompt.root; <userinput>cd /cdrom/<replaceable>X.Y-RELEASE</replaceable>/kernels</userinput>
&prompt.root; <userinput>./install.sh GENERIC</userinput></screen>

         <para>Ersetzen Sie <filename
           class="directory"><replaceable>X.Y-RELEASE</replaceable></filename>
           mit der richtigen Version der Ver&ouml;ffentlichung, die Sie
           verwenden.  Der <filename>GENERIC</filename>-Kernel wird
           standardm&auml;ssig in <filename
           class="directory">/boot/GENERIC</filename> installiert.</para>
        </listitem>

        <listitem>
          <para>Falls alle obigen Schritte fehlschlagen, kann der
            <filename>GENERIC</filename>-Kernel folgendermassen aus den Quellen
            neu gebaut und installiert werden:</para>

          <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>env DESTDIR=/boot/GENERIC make kernel</userinput>
&prompt.root; <userinput>mv /boot/GENERIC/boot/kernel/* /boot/GENERIC</userinput>
&prompt.root; <userinput>rm -rf /boot/GENERIC/boot</userinput></screen>

          <para>Damit dieser Kernel als <filename>GENERIC</filename>-Kernel von
            <command>freebsd-update</command> erkannt wird, darf die
            <filename>GENERIC</filename>-Konfigurationsdatei in keinster Weise
            ge&auml;ndert worden sein.  Es wird ebenfalls empfohlen, dass
            dieser ohne irgendwelche speziellen Optionen erstellt wird
            (bevorzugt mit einer leeren
            <filename>/etc/make.conf</filename>).</para>
        </listitem>
      </itemizedlist>

      <para>Der Neustart in den <filename>GENERIC</filename>-Kernel ist zu
        diesem Zeitpunkt nicht notwendig.</para>

      <para>Aktualisierungen an Haupt- und Unterversionen k&ouml;nnen
        durchgef&uuml;hrt werden, wenn man <command>freebsd-update</command>
        eine Release-Version als Ziel &uuml;bergibt.  Beispielsweise wird das
        folgende Kommando das System auf &os;&nbsp;8.1 aktualisieren:</para>

      <screen>&prompt.root; <userinput>freebsd-update -r 8.1-RELEASE upgrade</userinput></screen>

      <para>Nachdem das Kommando empfangen wurde, &uuml;berpr&uuml;ft
        <command>freebsd-update</command> die Konfigurationsdatei und das
        aktuelle System, um die n&ouml;tigen Informationen f&uuml;r die
        Systemaktualisierung zu sammeln.  Eine Bildschirmausgabe wird anzeigen,
        welche Komponenten erkannt und welche nicht erkannt wurden.
        Zum Beispiel:</para>

      <screen>Looking up update.FreeBSD.org mirrors... 1 mirrors found.
Fetching metadata signature for 8.0-RELEASE from update1.FreeBSD.org... done.
Fetching metadata index... done.
Inspecting system... done.

The following components of FreeBSD seem to be installed:
kernel/smp src/base src/bin src/contrib src/crypto src/etc src/games
src/gnu src/include src/krb5 src/lib src/libexec src/release src/rescue
src/sbin src/secure src/share src/sys src/tools src/ubin src/usbin
world/base world/info world/lib32 world/manpages

The following components of FreeBSD do not seem to be installed:
kernel/generic world/catpages world/dict world/doc world/games
world/proflibs

Does this look reasonable (y/n)? y</screen>

      <para>An diesem Punkt wird <command>freebsd-update</command> versuchen,
        alle notwendigen Dateien f&uuml;r die Aktualisierung herunter zu laden.
        In manchen F&auml;llen wird der Benutzer mit Fragen konfrontiert, um
        festzustellen, was installiert werden soll oder auf welche Art und
        Weise fortgesetzt werden soll.</para>

      <para>Wenn ein selbstkonfigurierter Kernel benutzt wird, produziert der
        vorherige Schritt eine Warnung &auml;hnlich zu der folgenden:</para>

      <screen>WARNING: This system is running a "<replaceable>MYKERNEL</replaceable>" kernel, which is not a
kernel configuration distributed as part of FreeBSD 8.0-RELEASE.
This kernel will not be updated: you MUST update the kernel manually
before running "/usr/sbin/freebsd-update install"</screen>

      <para>Diese Warnung kann an dieser Stelle problemlos ignoriert
        werden.  Der aktualisierte <filename>GENERIC</filename>-Kernel wird als
        ein Zwischenschritt im Aktualisierungsprozess verwendet.</para>

      <para>Nachdem alle Korrekturen auf das lokale System heruntergeladen
        wurden, werden diese nun eingespielt.  Dieser Prozess kann eine gewisse
        Zeit in Anspruch nehmen, abh&auml;ngig von der Geschwindigkeit und
        Auslastung der Maschine.  Konfigurationsdateien werden ebenfalls
        zusammengef&uuml;gt - dieser Teil der Prozedur ben&ouml;tigt einige
        Benutzereingaben, da eine Datei m&ouml;glicherweise von Hand
        zusammengefasst werden muss oder ein Editor erscheint auf dem
        Bildschirm zum manuellen bearbeiten.  Die Ergebnisse von jeder
        erfolgreichen Zusammenfassung werden dem Benutzer angezeigt,
        w&auml;hrend der Prozess weiterl&auml;uft.  Eine fehlgeschlagene oder
        ignorierte Zusammenfassung wird den Prozess sofort beenden.  Benutzer
        sollten eine Sicherung von <filename class="directory">/etc</filename>
        anlegen und wichtige Dateien sp&auml;ter manuell vereinen,
        beispielsweise <filename>master.passwd</filename> oder
        <filename>group</filename>.</para>

      <note>
        <para>Das System ist noch nicht ver&auml;ndert worden, alle Korrekturen
          und Vereinigungen sind in einem anderen Verzeichnis vorgenommen
          worden.  Wenn alle Korrekturen erfolgreich eingespielt, alle
          Konfigurationsdateien zusammengef&uuml;gt wurden und es den Anschein
          hat, dass der Prozess problemlos verlaufen wird, m&uuml;ssen die
          &Auml;nderungen vom Anwender noch angewendet werden.</para>
      </note>

      <para>Sobald dieser Prozess abgeschlossen ist, k&ouml;nnen die
        Aktualisierungen &uuml;ber das folgende Kommando auf die Platte
        geschrieben werden:</para>

      <screen>&prompt.root; <userinput>freebsd-update install</userinput></screen>

      <para>Der Kernel und die Module werden zuerst aktualisiert.  Zu diesem
        Zeitpunkt muss die Maschine neu gestartet werden.  Wenn das System
        einen selbstkonfigurierten Kernel verwendet, benutzen Sie das
        &man.nextboot.8;-Kommando, um den Kernel f&uuml;r den n&auml;chsten
        Neustart auf <filename class="directory">/boot/GENERIC</filename> zu
        setzen (welcher aktualisiert wurde):</para>

      <screen>&prompt.root; <userinput>nextboot -k GENERIC</userinput></screen>

      <warning>
        <para>Bevor mit dem <filename>GENERIC</filename>-Kernel das System neu
          gestartet wird, vergewissern Sie sich, dass alle notwendigen Treiber
          f&uuml;r ihr System enthalten sind, um korrekt zu starten (und
          schliessen Sie ihn ans Netzwerk an, falls auf die Maschine, die
          aktualisiert wird, von der Ferne aus zugegriffen wird).  Achten Sie
          besonders darauf, dass wenn der vorherige selbstkonfigurierte Kernel
          Funktionalit&auml;t beinhaltet, die von Kernelmodulen zur
          Verf&uuml;gung gestellt wurde, dass diese tempor&auml;r in den
          <filename>GENERIC</filename>-Kernel &uuml;ber die Datei
          <filename>/boot/loader.conf</filename> &uuml;bernommen werden.
          Sie sollten ebenfalls nicht ben&ouml;tigte Dienste, eingeh&auml;ngte
          Platten, verbundene Netzlaufwerke, usw. deaktivieren, bis der
          Aktualisierungsprozess abgeschlossen ist.</para>
      </warning>

      <para>Die Maschine sollte nun mit dem aktualisierten Kernel neu
        gestartet werden:</para>

      <screen>&prompt.root; <userinput>shutdown -r now</userinput></screen>

      <para>Sobald das System wieder hochgefahren wurde, muss
        <command>freebsd-update</command> erneut gestartet werden.  Der Zustand
        des Prozesses wurde zuvor gesichert und deshalb wird
        <command>freebsd-update</command> nicht von vorne beginnen, jedoch alle
        alten Shared-Libraries und Objektdateien l&ouml;schen.  Um zu diesem
        Zustand zu gelangen, setzen Sie das folgende Kommando ab:</para>

      <screen>&prompt.root; <userinput>freebsd-update install</userinput></screen>

      <note>
        <para>Abh&auml;ngig davon, ob irgendwelche Bibliotheksversionen
          erh&ouml;ht wurden, kann es sein, dass nur zwei Installationsphasen
          anstatt drei durchlaufen werden.</para>
      </note>

      <para>Nun muss alle Drittanbieter-Software neu erstellt und neu
        installiert werden.  Dies ist notwendig, da die installierte Software
        m&ouml;glicherweise Abh&auml;ngigkeiten zu Bibliotheken enth&auml;lt,
        die w&auml;hrend der Aktualisierung entfernt wurden.  Der <filename
        role="package">ports-mgmt/portupgrade</filename>-Befehl kann verwendet
        werden, um diesen Vorgang zu automatisieren.  Die folgenden Kommandos
        k&ouml;nnen verwendet werden, um diesen Prozess zu starten:</para>

      <screen>&prompt.root; <userinput>portupgrade -f ruby</userinput>
&prompt.root; <userinput>rm /var/db/pkg/pkgdb.db</userinput>
&prompt.root; <userinput>portupgrade -f ruby18-bdb</userinput>
&prompt.root; <userinput>rm /var/db/pkg/pkgdb.db /usr/ports/INDEX-*.db</userinput>
&prompt.root; <userinput>portupgrade -af</userinput></screen>

      <para>Sobald dies abgeschlossen ist, beenden Sie den
        Aktualisierungsprozess mit einem letzten Aufruf von
        <command>freebsd-update</command>.  Geben Sie den folgenden Befehl ein,
        um alle losen Enden des Aktualisierungsprozesses miteinander zu
        verkn&uuml;pfen:</para>

      <screen>&prompt.root; <userinput>freebsd-update install</userinput></screen>

      <para>Wenn der <filename>GENERIC</filename>-Kernel tempor&auml;r
        Verwendung fand, ist dies der richtige Zeitpunkt, einen neuen,
        selbstkonfigurierten Kernel zu bauen und &uuml;ber die &uuml;bliche
        Methode zu installieren.</para>

      <para>Booten Sie anschliessend die Maschine in die neue &os;-Version.
        Der Prozess ist damit abgeschlossen.</para>
    </sect2>

    <sect2 id="freebsdupdate-system-comparison">
      <title>Vergleich des Systemzustands</title>

      <para>Das <command>freebsd-update</command>-Werkzeug kann verwendet
        werden, um den Zustand der installierten &os;-Version gegen&uuml;ber
        einer bekannten und funktionierenden Kopie zu vergleichen.  Diese
        Option vergleicht die aktuelle Version von Systemwerkzeugen,
        Bibliotheken und Konfigurationsdateien.  Um diesen Vergleich zu
        starten, geben Sie den folgenden Befehl ein:</para>

      <screen>&prompt.root; <userinput>freebsd-update IDS &gt;&gt; outfile.ids</userinput></screen>

      <warning>
        <para>Obwohl der Befehlsname <acronym>IDS</acronym> lautet, sollte er
          in keiner Weise als Ersatz f&uuml;r ein Intrusion Detection System
          wie <filename role="package">security/snort</filename> angesehen
          werden.  Da <command>freebsd-update</command> seine Daten auf Platte
          ablegt, ist die M&ouml;glichkeit von Verf&auml;lschungen
          offensichtlich.  Obwohl diese M&ouml;glichkeit durch die Verwendung
          von <varname>kern.securelevel</varname> oder die Ablage von
          <command>freebsd-update</command> auf einem Nur-Lese Dateisystem,
          wenn es gerade nicht gebraucht wird, einged&auml;mmt werden kann,
          besteht eine bessere L&ouml;sung darin, das System gegen ein
          gesichertes Medium, wie eine <acronym>DVD</acronym> oder einen
          externen, separat aufbewahrten
          <acronym>USB</acronym>-Plattenspeicher, zu vergleichen.</para>
      </warning>

      <para>Das System wird jetzt untersucht und eine Liste von Dateien
        ausgegeben, zusammen mit deren &man.sha256.1;-Hashwerten, sowohl der
        von der Release-Version bekannte Wert als auch der des aktuell
        installierten Systems.  Das ist der Grund daf&uuml;r, warum die Ausgabe
        an die Datei <filename>outfile.ids</filename> geschickt wurde.  Es
        scrollt zu schnell vorbei, um diese mit den Augen zu vergleichen und
        bald wird auch der Konsolenpuffer damit &uuml;berf&uuml;llt.</para>

      <para>Diese Zeilen sind dazu noch extrem lang, aber das Ausgabeformat
        kann sehr einfach verarbeitet werden. Um beispielsweise eine Liste von
        allen Dateien zu erhalten, die sich vom aktuellen Release
        unterscheiden, geben Sie das folgende Kommando ein:</para>

      <screen>&prompt.root; <userinput>cat outfile.ids | awk '{ print $1 }' | more</userinput>
/etc/master.passwd
/etc/motd
/etc/passwd
/etc/pf.conf</screen>

      <para>Diese Ausgabe wurde abgeschnitten, es existieren noch viel mehr
        Dateien dazu.  Manche dieser Dateien besitzen ganz
        selbstverst&auml;ndliche Ver&auml;nderungen,
        <filename>/etc/passwd</filename> wurde beispielsweise ge&auml;ndert,
        um Benutzer zum System hinzuzuf&uuml;gen.  In manchen F&auml;llen kann
        es anderen Dateien wie Kernelmodule geben, welche sich ge&auml;ndert
        haben, weil <command>freebsd-update</command> diese aktualisiert hat.
        Um bestimmte Dateien oder Verzeichnisse auszuschliessen, h&auml;ngen
        Sie diese an die <literal>IDSIgnorePaths</literal>-Option in
        <filename>/etc/freebsd-update.conf</filename> an.</para>

      <para>Diese Vorgehensweise kann als Teil einer ausgekl&uuml;gelten
        Aktualisierungsmethode benutzt werden, unabh&auml;ngig von der zuvor
        angesprochenen Variante.</para>
    </sect2>
  </sect1>

  <sect1 id="updating-upgrading-portsnap">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Geschrieben von </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <firstname>Colin</firstname>
	  <surname>Percival</surname>
	  <contrib>Basierend auf bereitgestellten Mitschriften von </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <firstname>Benedict</firstname>
	  <surname>Reuschling</surname>
	  <contrib>&Uuml;bersetzt von </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Portsnap: Ein Werkzeug zur Aktualisierung der Ports-Sammlung</title>

    <indexterm><primary>Updating and Upgrading</primary></indexterm>
    <indexterm>
      <primary>Portsnap</primary>
      <see>Updating and Upgrading</see>
    </indexterm>

    <para>Das Basissystem von &os; enth&auml;lt auch ein Programm zum
      Aktualisieren der Ports-Sammlung: das &man.portsnap.8; Werkzeug.  Wenn
      es ausgef&uuml;hrt wird, verbindet es sich mit einem entfernten Rechner,
      &uuml;berpr&uuml;ft den Sicherungsschl&uuml;ssel und l&auml;dt eine neue
      Kopie der Ports-Sammlung herunter.  Der Schl&uuml;ssel wird dazu
      verwendet, um die Integrit&auml;t aller heruntergeladenen Dateien zu
      pr&uuml;fen und um sicherzustellen, dass diese unterwegs nicht
      ver&auml;ndert wurden.  Um die aktuellsten Dateien der Ports-Sammlung
      herunter zu laden, geben Sie das folgende Kommando ein:</para>

    <screen>&prompt.root; <userinput>portsnap fetch</userinput>
Looking up portsnap.FreeBSD.org mirrors... 3 mirrors found.
Fetching snapshot tag from portsnap1.FreeBSD.org... done.
Fetching snapshot metadata... done.
Updating from Wed Aug  6 18:00:22 EDT 2008 to Sat Aug 30 20:24:11 EDT 2008.
Fetching 3 metadata patches.. done.
Applying metadata patches... done.
Fetching 3 metadata files... done.
Fetching 90 patches.....10....20....30....40....50....60....70....80....90. done.
Applying patches... done.
Fetching 133 new ports or files... done.</screen>

    <para>Dieses Beispiel zeigt, dass &man.portsnap.8; mehrere Korrekturen
      f&uuml;r die aktuellen Ports-Daten gefunden und verifiziert hat.  Es
      zeigt auch, dass das Programm zuvor schon einmal gestartet wurde.
      W&auml;re es das erste Mal, w&uuml;rde nur die Ports-Sammlung
      heruntergeladen werden.</para>

    <para>Wenn &man.portsnap.8; erfolgreich die
      <command>fetch</command>-Operation abgeschlossen hat, befinden sich die
      Ports-Sammlung und die dazugeh&ouml;rigen Korrekturen auf dem lokalen
      System, welches die &Uuml;berpr&uuml;fung bestanden hat.  Wenn Sie
      <command>portsnap</command> das erste Mal ausgef&uuml;hrt haben,
      m&uuml;ssen Sie den Befehl <literal>portsnap extract</literal>
      verwenden, um die Ports-Sammlung zu installieren:</para>

    <screen>&prompt.root; <userinput>portsnap extract</userinput>
/usr/ports/.cvsignore
/usr/ports/CHANGES
/usr/ports/COPYRIGHT
/usr/ports/GIDs
/usr/ports/KNOBS
/usr/ports/LEGAL
/usr/ports/MOVED
/usr/ports/Makefile
/usr/ports/Mk/bsd.apache.mk
/usr/ports/Mk/bsd.autotools.mk
/usr/ports/Mk/bsd.cmake.mk
<replaceable>...</replaceable></screen>

    <para>Um Ihre bereits installierte Ports-Sammlung zu aktualisieren,
      verwenden Sie hingegen den Parameter <literal>update</literal>:</para>

    <screen>&prompt.root; <userinput>portsnap update</userinput></screen>

    <para>Der Prozess ist jetzt abgeschlossen und Anwendungen k&ouml;nnen
      mittels der aktuellen Ports-Sammlung installiert oder aktualisiert
      werden.</para>

    <para>Die Operationen <literal>fetch</literal> und
      <literal>extract</literal> oder <literal>update</literal> k&ouml;nnen
      auch nacheinander ausgef&uuml;hrt werden, wie im folgenden Beispiel
      gezeigt:</para>

    <screen>&prompt.root; <userinput>portsnap fetch update</userinput></screen>

    <para>Dieser Befehl l&auml;dt die aktuelle Version der Ports-Sammlung
      herunter und aktualisiert anschlie&szlig;end Ihre lokale Version
      im Verzeichnis <filename class="directory">/usr/ports</filename>.</para>
  </sect1>

  <sect1 id="updating-upgrading-documentation">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Benedict</firstname>
	  <surname>Reuschling</surname>
	  <contrib>&Uuml;bersetzt von </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Aktualisieren der Dokumentationssammlung</title>

    <indexterm><primary>Updating and Upgrading</primary></indexterm>

    <indexterm>
      <primary>Documentation</primary>
      <see>Updating and Upgrading</see>
    </indexterm>

    <para>Neben dem Basissystem und der Ports-Sammlung ist die Dokumentation
      ein wichtiger Bestandteil des &os; Betriebssystems.  Obwohl eine aktuelle
      Version der &os; Dokumentation jederzeit auf der <ulink
      url="http://www.freebsd.org/doc/">&os; Webseite</ulink> verf&uuml;gbar
      ist, verf&uuml;gen manche Benutzer nur &uuml;ber eine langsame oder
      &uuml;berhaupt keine Netzwerkverbindung. Gl&uuml;cklicherweise gibt es
      mehrere M&ouml;glichkeiten, die Dokumentation, welche mit jeder Version
      ausgeliefert wird, zu aktualisieren, indem eine lokale Kopie der
      aktuellen &os;-Dokumentationssammlung verwendet wird.</para>

    <sect2 id="csup-doc">
      <title>Verwenden von CVSup um die Dokumentation zu aktualisieren</title>

      <para>Die Quellen und die installierte Kopie der &os; Dokumentation
        kann mittels <application>CVSup</application> aktualisiert werden,
        indem ein &auml;hnlicher Mechanismus angewendet wird, wie derjenige
        f&uuml;r die Betriebssystemquellen (vergleichen Sie mit <xref
        linkend="makeworld">).  Dieser Abschnitt beschreibt:</para>

      <itemizedlist>
	<listitem>
	  <para>Wie die Dokumentations-Werkzeugsammlung installiert wird,
	    welche die Werkzeuge enth&auml;lt, die n&ouml;tig sind, um die
	    &os; Dokumentation aus den Quellen neu zu erstellen.</para>
	</listitem>

	<listitem>
	  <para>Wie man eine Kopie der Dokumentationsquellen nach <filename
	    class="directory">/usr/doc</filename> herunterl&auml;dt, unter
	    Verwendung von <application>CVSup</application>.</para>
	</listitem>

	<listitem>
	  <para>Wie man die &os; Dokumentation aus den Quellen baut und unter
	    <filename class="directory">/usr/share/doc</filename>
	    installiert.</para>
	</listitem>

	<listitem>
	  <para>Manche der Optionen zum Erstellen, die vom System zum Bauen der
	    Dokumentation unterst&uuml;tzt werden, z.B. die Optionen welche nur
	    ein paar der unterschiedlichen Sprach&uuml;bersetzungen der
	    Dokumentation erstellen oder die Optionen, die ein bestimmtes
	    Ausgabeformat ausw&auml;hlen.</para>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2 id="installing-documentation-toolchain">
      <title>CVSup und die Werkzeugsammlung der Dokumentation
        installieren</title>

      <para>Die &os; Dokumentation aus dem Quellen zu erstellen ben&ouml;tigt
        eine ziemlich grosse Anzahl an Werkzeugen.  Diese Werkzeuge sind nicht
        Teil des &os; Basissystems, da sie eine grosse Menge an Plattenplatz
        verbrauchen und nicht von allen &os;-Anwendern ben&ouml;tigt werden.
        Sie sind nur f&uuml;r diejenigen Benutzer notwendig, die aktiv an neuer
        Dokumentation f&uuml; &os; schreiben oder h&auml;ufig ihre
        Dokumentation aus den Quellen bauen lassen.</para>

      <para>Alle ben&ouml;tigten Werkzeuge sind als Teil der Ports-Sammlung
        verf&uuml;gbar.  Der Port <filename
        role="package">textproc/docproj</filename> dient als Masterport, der
        vom &os; Documentation Project entwickelt wurde, um die initiale
        Installation und zuk&uuml;nftige Aktualisierungen dieser Werkzeuge zu
        vereinfachen.</para>

      <note>
	<para>Wenn Sie die Dokumentation nicht als &postscript; oder PDF
	  ben&ouml;tigen, k&ouml;nnen Sie alternativ die Installation des
	  <filename role="package">textproc/docproj-nojadetex</filename>-Ports
	  in Erw&auml;gung ziehen.  Diese Version der
	  Dokumentations-Werkzeugsammlung enth&auml;lt alles ausser das
	  <application>teTeX</application>-Textsatzsystem.
	  <application>teTeX</application> ist eine sehr grosse Sammlung an
	  Werkzeugen, deshalb ist es vern&uuml;nftig, deren Installation
	  auszulassen, wenn die Ausgabe von PDF nicht unbedingt gebraucht
	  wird.</para>
      </note>

      <para>F&uuml;r weitere Informationen &uuml;ber das Installieren und
        Verwenden von <application>CVSup</application>, lesen Sie <link
	  linkend="cvsup">CVSup verwenden</link>.</para>
    </sect2>

    <sect2 id="updating-documentation-sources">
      <title>Die Dokumentationsquellen aktualisieren</title>

      <para>Das Programm <application>CVSup</application> kann eine saubere
        Kopie der Dokumentationsquellen holen, indem es die Datei
        <filename>/usr/share/examples/cvsup/doc-supfile</filename> als
        Konfigurationsvorlage verwendet.  Der Standard-Host zum Aktualisieren
        ist auf einen Platzhalterwert im <filename>doc-supfile</filename>
        gesetzt, aber &man.cvsup.1; akzeptiert auch einen Hostnamen &uuml;ber
        die Kommandozeile. Somit k&ouml;nnen die Dokumentationsquellen von
        einem der <application>CVSup</application>-Server geholt werden, indem
        man eingibt:</para>

      <screen>&prompt.root; <userinput>cvsup -h <replaceable>cvsup.FreeBSD.org</replaceable> -g -L 2 <filename>/usr/share/examples/cvsup/doc-supfile</filename></userinput></screen>

      <para>&Auml;ndern Sie <replaceable>cvsup.FreeBSD.org</replaceable> auf
        den Ihnen am n&auml;chsten gelegenen
        <application>CVSup</application>-Server.  Eine vollst&auml;ndige Liste
        von Spiegelservern finden Sie unter <xref
        linkend="cvsup-mirrors">.</para>

      <para>Es dauert eine Weile, wenn die Dokumentationsquellen das allererste
        Mal heruntergeladen werden. Lassen Sie es laufen, bis es fertig
        ist.</para>

      <para>Zuk&uuml;nftige Aktualisierungen der Dokumentationsquellen
        k&ouml;nnen Sie &uuml;ber den gleichen Befehl bekommen.  Das Programm
        <application>CVSup</application> l&auml;dt und kopiert nur diejenigen
        Aktualisierungen herunter, die seit seinem letzten Aufruf hinzugekommen
        sind.  Deshalb sollte jeder weitere Aufruf von
        <application>CVSup</application> nach dem Ersten wesentlich schneller
        abgeschlossen sein.</para>

      <para>Nachdem die Quellen einmal ausgecheckt wurden, besteht ein anderer
        Weg, die Dokumentation zu aktualisieren, darin, das
        <filename>Makefile</filename> im Verzeichnis <filename
        class="directory">/usr/doc</filename> anzupassen.  Durch setzen von
        <makevar>SUP_UPDATE</makevar>, <makevar>SUPHOST</makevar> und
        <makevar>DOCSUPFILE</makevar> in der Datei
        <filename>/etc/make.conf</filename> ist es jetzt m&ouml;glich,
        folgendes zu tun:</para>

      <screen>&prompt.root; <userinput>cd /usr/doc</userinput>
&prompt.root; <userinput>make update</userinput></screen>

      <para>Ein typischer Satz dieser &man.make.1;-Optionen f&uuml;r
        <filename>/etc/make.conf</filename> ist:</para>

      <programlisting>SUP_UPDATE= yes
SUPHOST?= cvsup.freebsd.org
DOCSUPFILE?= /usr/share/examples/cvsup/doc-supfile</programlisting>

      <note>
	<para>Das Setzen des Werts von <makevar>SUPHOST</makevar> und
	  <makevar>DOCSUPFILE</makevar> auf <literal>?=</literal> erlaubt es,
	  diese in der Kommandozeile von make zu &uuml;berschreiben.  Diese
	  Methode wird empfohlen, um Optionen zu <filename>make.conf</filename>
	  hinzuzuf&uuml;gen, um zu verhinden, dass man die Datei jedes Mal
	  bearbeiten muss, um einen anderen Wert f&uuml;r die Option
	  auszuprobieren.</para>
      </note>
    </sect2>

    <sect2 id="updating-documentation-options">
      <title>Einstellbare Optionen der Dokumentationsquellen</title>

      <para>Das System zum aktualisieren und erstellen der &os;-Dokumentation
        unterst&uuml;tzt ein paar Optionen, welche den Prozess der
        Aktualisierung von Teilen der Dokumentation oder einer bestimmten
        &Uuml;bersetzung erleichtert.  Diese Optionen lassen sich entweder
        systemweit in der Datei <filename>/etc/make.conf</filename> setzen,
        oder als Kommandozeilenoptionen, die dem &man.make.1;-Werkzeug
        &uuml;bergeben werden.</para>

      <para>Die folgenden Optionen sind ein paar davon:</para>

      <variablelist>
	<varlistentry>
	  <term><makevar>DOC_LANG</makevar></term>

	  <listitem>
	    <para>Eine Liste von Sprachen und Kodierungen, die gebaut und
	      installiert werden sollen, z.B.
	      <literal>en_US.ISO8859-1</literal>, um nur die englische
	      Dokumentation zu erhalten.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><makevar>FORMATS</makevar></term>

	  <listitem>
	    <para>Ein einzelnes Format oder eine Liste von Ausgabeformaten, das
	      gebaut werden soll. Momentan werden <literal>html</literal>,
	      <literal>html-split</literal>, <literal>txt</literal>,
	      <literal>ps</literal>, <literal>pdf</literal>,
	      und <literal>rtf</literal> unterst&uuml;tzt.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><makevar>SUPHOST</makevar></term>

	  <listitem>
	    <para>Der Hostname des <application>CVSup</application>-Servers,
	      der verwendet werden soll, um Aktualisierungen zu holen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><makevar>DOCDIR</makevar></term>

	  <listitem>
	    <para>Wohin die Dokumentation installiert werden soll.  Der
	      Standardpfad ist <filename
	      class="directory">/usr/share/doc</filename>.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>F&uuml;r weitere make-Variablen, die als systemweite Optionen
        in &os; unterst&uuml;tzt werden, lesen Sie &man.make.conf.5;.</para>

      <para>F&uuml;r weitere make-Variablen, die vom System zum Erstellen der
        &os;-Dokumentation unterst&uuml;tzt werden, lesen Sie die <ulink
        url="&url.doc.langbase;/books/fdp-primer">Fibel f&uuml;r neue
        Mitarbeiter des &os;-Dokumentationsprojekts</ulink>.</para>
    </sect2>

    <sect2 id="updating-installed-documentation">
      <title>Die &os;-Dokumentation aus den Quellen installieren</title>

      <para>Wenn ein aktueller Schnappschuss der Dokumentationsquellen nach
        <filename class="directory">/usr/doc</filename> heruntergeladen wurde,
        ist alles bereit f&uuml;r eine Aktualisierung der bestehenden
        Dokumentation.</para>

      <para>Eine komplette Aktualisierung aller Sprachoptionen, definiert durch
        die <makevar>DOC_LANG</makevar> Makefile-Option, kann durch folgende
        Eingabe erreicht werden:</para>

      <screen>&prompt.root; <userinput>cd /usr/doc</userinput>
&prompt.root; <userinput>make install clean</userinput></screen>

      <para>Wenn <filename>make.conf</filename> mit den richtigen Optionen
        <makevar>DOCSUPFILE</makevar>, <makevar>SUPHOST</makevar> und
        <makevar>SUP_UPDATE</makevar> eingerichtet wurde, kann der
        Installationsschritt mit einer Aktualisierung der Dokumentationsquellen
        kombiniert werden, indem man eingibt:</para>

      <screen>&prompt.root; <userinput>cd /usr/doc</userinput>
&prompt.root; <userinput>make update install clean</userinput></screen>

      <para>Wenn nur eine Aktualisierung einer bestimmten Sprache
        gew&uuml;nscht wird, kann &man.make.1; in einem sprachspezifischen
        Unterverzeichnis von <filename class="directory">/usr/doc</filename>
        aufgerufen werden, z.B.:</para>

      <screen>&prompt.root; <userinput>cd /usr/doc/en_US.ISO8859-1</userinput>
&prompt.root; <userinput>make update install clean</userinput></screen>

      <para>Die zu installierenden Ausgabeformate k&ouml;nnen durch das Setzen
        der make-Variablen <makevar>FORMATS</makevar> angegeben werden,
        z.B.:</para>

      <screen>&prompt.root; <userinput>cd /usr/doc</userinput>
&prompt.root; <userinput>make FORMATS='html html-split' install clean</userinput></screen>
    </sect2>

    <sect2 id="doc-ports">
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Marc</firstname>
	    <surname>Fonvieille</surname>
	    <contrib>Basierend auf der Arbeit von </contrib>
	  </author>
	</authorgroup>
      </sect2info>

      <title>Verwendung von Dokumentations-Ports</title>

      <indexterm><primary>Updating and Upgrading</primary></indexterm>

      <indexterm>
	<primary>documentation package</primary>
	<see>Updating and Upgrading</see>
      </indexterm>

      <para>Im vorherigen Abschnitt wurde eine Methode gezeigt, wie die
        &os;-Dokumentation aus den Quellen gebaut werden kann.  Allerdings sind
        quellbasierte Aktualisierungen m&ouml;glicherweise nicht f&uuml;r alle
        &os;-Systeme geeignet oder praktikabel. Das Erstellen der
        Dokumentationsquellen ben&ouml;tigt eine grosse Anzahl an Werkzeugen,
        Programmen und Hilfsmitteln, die <emphasis>documentation
        toolchain</emphasis>, ein gewisser Grad an Vertrautheit mit
        <application>CVS</application> und ausgecheckte Quellen von einem
        Repository, sowie ein paar manuelle Schritte, um diese ausgecheckten
        Quellen zu bauen.  In diesem Abschnitt wird eine alternative Art und
        Weise vorgestellt, wie man die installierte Kopie der
        &os;-Dokumentation aktualisieren kann.  Diese Methode verwendet die
        Ports-Sammlung und erlaubt es:</para>

      <itemizedlist>
	<listitem>
	  <para>vorgefertige Schnappsch&uuml;sse der Dokumentation herunter zu
	    laden und zu installieren, ohne vorher irgendetwas lokal zu
	    erstellen (dadurch ist es nicht mehr notwenig, den kompletten
	    Werkzeugkasten der Dokumentation zu installieren).</para>
	</listitem>

	<listitem>
	  <para>die Dokumentationsquellen herunterzuladen und durch das
	    Ports-System erstellen zu lassen (was die Schritte zum Auschecken
	    und Erstellen etwas erleichtert).</para>
	</listitem>
      </itemizedlist>

      <para>Diese beiden Methoden der Aktualisierung der &os;-Dokumentation
        werden durch eine Menge von <emphasis>Dokumentations-Ports</emphasis>
        unterst&uuml;tzt, die von &a.doceng; monatlich aktualisiert wird.
        Diese sind in der Ports-Sammlung unter der virtuellen Kategorie, <ulink
        url="http://www.freshports.org/docs/">docs</ulink> genannt,
        gelistet.</para>

      <sect3 id="doc-ports-install-make">
	<title>Erstellen und Installieren von Dokumentations-Ports</title>

	<para>Die Dokumentations-Ports nutzen das Ports-System, um das
	  Erstellen von Dokumentation wesentlich einfacher zu machen.  Es
	  automatisiert den Prozess des Auscheckens der Dokumentationsquellen,
	  aufrufen von &man.make.1; mit den passenden Umgebungsvariablen und
	  Kommandozeilenoptionen und macht die Installation und Deinstallation
	  von Dokumentation so einfach wie die Installation von jedem anderen
	  Port oder Paket.</para>

	<note>
	  <para>Als zus&auml;tzliche Eigenschaft zeichnen sie eine
	    Abh&auml;ngigkeit zum
	    <emphasis>Dokumentations-Werkzeugsatz</emphasis> auf, wenn die
	    Dokumentations-Ports lokal erstellt werden, weshalb dieser auch
	    automatisch mitinstalliert wird.</para>
	</note>

	<para>Die Dokumentations-Ports sind wie folgt organisiert:</para>

	<itemizedlist>
	  <listitem>
	    <para>Es existiert ein <quote>Master-Port</quote>, <filename
	      role="package">misc/freebsd-doc-en</filename>, in dem alle
	      Dateien zu den Dokumentations-Ports abgelegt sind.  Es dient als
	      Basis f&uuml;r alle Dokumentations-Ports.  Als Voreinstellung
	      wird nur die englische Dokumentation gebaut.</para>
	  </listitem>

	  <listitem>
	    <para>Es gibt einen <quote>Alles-in-Einem-Port</quote>, <filename
	      role="package">misc/freebsd-doc-all</filename>, welcher die
	      komplette Dokumentation in allen verf&uuml;gbaren Sprachen
	      erstellt und installiert.</para>
	  </listitem>

	  <listitem>
	    <para>Schliesslich gibt es noch einen sogenannten <quote>slave
	      port</quote> f&&uml;r jede &Uuml;bersetzung, z.B.: <filename
	      role="package">misc/freebsd-doc-hu</filename> f&uuml;r
	      Dokumentation in ungarischer Sprache.  All diese ben&ouml;tigen
	      den Master-Port und installieren die &uuml;bersetzte
	      Dokumentation in der entsprechenden Sprache.</para>
	  </listitem>
	</itemizedlist>

	<para>Um einen Dokumentations-Port aus den Quellen zu installieren,
	  geben Sie das folgende Kommando (als <username>root</username>)
	  ein:</para>

	<screen>&prompt.root; <userinput>cd /usr/ports/misc/freebsd-doc-en</userinput>
&prompt.root; <userinput>make install clean</userinput></screen>

	<para>Auf diese Weise wird die englische Dokumentation gebaut und als
	  getrenntes <acronym>HTML</acronym>-Format im Verzeichnis <filename
	  class="directory">/usr/local/share/doc/freebsd</filename> installiert
	  (genau wie unter <ulink url="http://www.FreeBSD.org"></ulink> zu
	  finden).</para>

	<sect4 id="doc-ports-options">
	  <title>Gebr&auml;uchliche Schalter und Optionen</title>

	  <para>Es gibt viele Optionen, um das Standarderhalten der
	    Dokumentations-Ports zu ver&auml;ndern.  Im Folgenden sind nur ein
	    paar davon aufgef&uuml;hrt:</para>

	  <variablelist>
	    <varlistentry>
	      <term><makevar>WITH_HTML</makevar></term>

	      <listitem>
		<para>Erlaubt das Erstellen im HTML-Format: eine einzige
		  HTML-Datei pro Dokument.  Die formatierte Dokumentation wird
		  als Datei mit dem Namen <filename>article.html</filename>
		  gespeichert, oder, je nachdem, als
		  <filename>book.html</filename>, zuzu&uuml;glich der
		  Bilder.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><makevar>WITH_PDF</makevar></term>

	      <listitem>
		<para>Erlaubt das Erstellen von &adobe; Portable Document
		  Format, f&uuml;r die Verwendung mit &adobe; &acrobat.reader;,
		  <application>Ghostscript</application> oder anderen
		  PDF-Betrachtern.  Die formatierte Dokumentation wird als Datei
		  mit dem Namen <filename>article.pdf</filename> oder, soweit
		  angemessen, als <filename>book.pdf</filename>
		  gespeichert.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><makevar>DOCBASE</makevar></term>

	      <listitem>
		<para>Wohin die Dokumentation installiert werden soll.  Der
		  Standardpfad ist <filename
		  class="directory">/usr/local/share/doc/freebsd</filename>.</para>

		<note>
		  <para>Beachten Sie, dass sich der Standardpfad von dem
		    Verzeichnis unterscheidet, das von der
		    <application>CVSup</application>-Methode verwendet wird.
		    Das liegt daran, dass ein Port installiert wird und diese
		    &uuml;berlicherweise im Verzeichnis <filename
		    class="directory">/usr/local</filename> abgelegt werden.
		    Durch setzen der <makevar>PREFIX</makevar>-Variablen kann
		    dieses Verhalten ge&auml;ndert werden.</para>
		</note>
	      </listitem>
	    </varlistentry>
	  </variablelist>

	  <para>Es folgt ein kurzes Beispiel, wie die Variablen verwendet
	    werden, um die oben erw&auml;hnte ungarische Dokumentation als
	    Portable Document Format zu installieren:</para>

	  <screen>&prompt.root; cd /usr/ports/misc/freebsd-doc-hu
&prompt.root; make -DWITH_PDF DOCBASE=share/doc/freebsd/hu install clean</screen>
	</sect4>
      </sect3>

      <sect3 id="doc-ports-install-package">
	<title>Verwendung von Dokumentations-Paketen</title>

	<para>Das Erstellen der Dokumentations-Ports aus den Quellen, wie im
	  vorherigen Abschnitt beschrieben, ben&ouml;tigt die lokale
	  Installation der Dokumentations-Werkzeugsammlung und ein wenig
	  Festplattenspeicher f&uuml;r das Bauen der Ports.  Sollten die
	  Ressourcen zum Bauen der Dokumentations-Werkzeugsammlung nicht zur
	  Verf&uuml;gung stehen, oder weil das erstellen zuviel Plattenplatz
	  ben&ouml;tigen w&uuml;rde, ist es trotzdem m&ouml;glich, bereits
	  zuvor gebaute Schnappsch&uuml;sse der Dokumentations-Ports zu
	  installieren.</para>

	<para>&a.doceng; erstellt monatliche Schnappsch&uuml;sse der
	  Dokumentations-Pakete von &os;.  Diese Bin&auml;rpakete k&ouml;nnen
	  mit jedem der mitgelieferten Paketwerkzeuge installiert werden,
	  beispielsweise &man.pkg.add.1;, &man.pkg.delete.1; und so
	  weiter.</para>

	<note>
	  <para>Wenn Bin&auml;rpakete zu Einsatz kommen, wird die
            &os;-Dokumentation in <emphasis>allen</emphasis> verf&uuml;gbaren
            Formaten in der gegebenen Sprache installiert.</para>
	</note>

	<para>Zum Beispiel installiert das folgende Kommando das aktuelle,
	  vorgefertigte Paket der ungarischen Dokumentation:</para>

	<screen>&prompt.root; <userinput>pkg_add -r hu-freebsd-doc</userinput></screen>

	<note>
	  <para>Pakete haben das folgende Namensformat, welches sich von dem
	    Namen des dazugeh&ouml;rigen Ports unterscheidet:
	    <literal><replaceable>lang</replaceable>-freebsd-doc</literal>.
	    <replaceable>lang</replaceable> entspricht hier der Kurzform des
	    Sprachcodes, z.B. <literal>hu</literal> f&uuml;r Ungarisch, oder
	    <literal>zh_cn</literal> f&uuml;r vereinfachtes Chinesisch.</para>
	</note>
      </sect3>

      <sect3 id="doc-ports-update">
	<title>Dokumentations-Ports aktualisieren</title>

	<para>Um einen zuvor installierten Dokumentations-Port zu aktualisieren,
	  kann jedes Werkzeug, das auch zum Aktualisieren von Ports verwendet
	  wird, eingesetzt werden.  Beispielsweise aktualisiert das folgende
	  Kommando die installierte ungarische Dokumentation mittels des
	  Programms <filename
	  role="package">ports-mgmt/portupgrade</filename> indem nur Pakete
	  verwendet werden sollen:</para>

	<screen>&prompt.root; <userinput>portupgrade -PP hu-freebsd-doc</userinput></screen>
      </sect3>
    </sect2>

<!-- FIXME: Waiting for a working docsnap server... -->
<![ IGNORE [
    <sect2 id="docsnap">
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Pav</firstname>
	    <surname>Lucistnik</surname>
	    <contrib>Based on information provided by </contrib>
	  </author>
	</authorgroup>
      </sect2info>

      <title>Using Docsnap</title>

      <indexterm><primary>Updating and Upgrading</primary></indexterm>

      <indexterm>
	<primary>Docsnap</primary>
	<see>Updating and Upgrading</see>
      </indexterm>

      <para><application>Docsnap</application> is an &man.rsync.1;
	repository for updating installed &os; Documentation in a
	relatively easy and fast way.  A
	<quote><application>Docsnap</application> server</quote> tracks
	the documentation sources, and builds them in HTML format every
	hour.  The <filename role="package">textproc/docproj</filename>
	is unneeded with <application>Docsnap</application> as only
	patches to the built documentation exist.</para>

      <para>The only requirement for using this technique is
	the <filename role="package">net/rsync</filename> port or
	package.  To add it, use the following command:</para>

      <screen>&prompt.root; <userinput>pkg_add -r rsync</userinput></screen>

      <note>
	<para><application>Docsnap</application> has been originally
	  developed for updating documentation installed
	  to <filename class="directory">/usr/share/doc</filename>, but
	  the following examples could be adapted for other directories
	  as well.  For user directories, it does not require
	  <username>root</username> privileges.</para>
      </note>

      <para>To update the documentation set, issue the following
	command:</para>

      <screen>&prompt.root; <userinput>rsync -rltvz <replaceable>docsnap.sk.FreeBSD.org</replaceable>::docsnap <replaceable>/usr/share/doc</replaceable></userinput></screen>

      <note>
	<para>There is only one <application>Docsnap</application>
	  server at the moment;
	  the <hostid>docsnap.sk.FreeBSD.org</hostid> shown
	  above.</para>
      </note>

      <para>Do not use the <option>--delete</option> flag here as there
	are some items installed
	into <filename class="directory">/usr/share/doc</filename>
	during <command>make installworld</command>, which would
	accidentally be removed.  To clean up, use this command
	instead:</para>

      <screen>&prompt.root; <userinput>rsync -rltvz --delete <replaceable>docsnap.sk.FreeBSD.org</replaceable>::docsnap/??_??\.\* <replaceable>/usr/share/doc</replaceable></userinput></screen>

      <para>If a subset of documentation needs to be updated, for
	example, the English documentation only, the following command
	should be used:</para>

      <screen>&prompt.root; <userinput>rsync -rltvz <replaceable>docsnap.sk.FreeBSD.org</replaceable>::docsnap/en_US.ISO8859-1 <replaceable>/usr/share/doc</replaceable></userinput></screen>
    </sect2>
]]>
  </sect1>

  <sect1 id="current-stable">
    <title>Einem Entwicklungszweig folgen</title>
    <indexterm><primary>-CURRENT</primary></indexterm>
    <indexterm><primary>-STABLE</primary></indexterm>

    <para>FreeBSD besitzt zwei Entwicklungszweige: &os.current; und
      &os.stable;.  Dieser Abschnitt beschreibt beide Zweige und
      erl&auml;utert, wie Sie Ihr System auf dem aktuellen Stand
      eines Zweiges halten.  Zuerst wird &os.current; vorgestellt, dann
      &os.stable;.</para>

    <sect2 id="current">
      <title>&os.current;</title>

      <para>Beachten Sie im Folgenden, dass &os.current; die Spitze
        der Entwicklung von &os; ist.  Benutzer von &os.current; sollten
	&uuml;ber sehr gute technische F&auml;higkeiten verf&uuml;gen und
	in der Lage sein, schwierige Probleme alleine zu l&ouml;sen.  Wenn
	&os; neu f&uuml;r Sie ist, &uuml;berlegen Sie sich genau, ob Sie
	&os.current; benutzen wollen.</para>

      <sect3>
	<title>Was ist &os.current;?</title>
	<indexterm><primary>Snapshot</primary></indexterm>

	<para>&os.current; besteht aus den neuesten Quellen des
	  FreeBSD-Systems.  Es enth&auml;lt Sachen, an denen gerade
	  gearbeitet wird, experimentelle &Auml;nderungen und
	  &Uuml;bergangsmechanismen, die im n&auml;chsten offiziellen
	  Release der Software enthalten sein k&ouml;nnen oder nicht.
	  Obwohl &os.current; t&auml;glich von vielen Entwicklern gebaut
	  wird, gibt es Zeitr&auml;ume, in denen sich das System nicht
	  bauen l&auml;sst.  Diese Probleme werden so schnell wie
	  m&ouml;glich gel&ouml;st, aber ob Sie mit &os.current;
	  Schiffbruch erleiden oder die gew&uuml;nschten Verbesserungen
	  erhalten, kann von dem Zeitpunkt abh&auml;ngen, an dem Sie sich
	  den Quelltext besorgt haben!</para>
      </sect3>

      <sect3>
	<title>Wer braucht &os.current;?</title>

	<para>&os.current; wird haupts&auml;chlich f&uuml;r 3
	  Interessengruppen zur Verf&uuml;gung gestellt:</para>

	<orderedlist>
	  <listitem>
	    <para>Entwickler, die an einem Teil des Quellbaums arbeiten und
	      daher &uuml;ber die aktuellen Quellen verf&uuml;gen
	      m&uuml;ssen.</para>
	  </listitem>

	  <listitem>
	    <para>Tester, die bereit sind, Zeit in das L&ouml;sen von
	      Problemen zu investieren und sicherstellen, dass
	      &os.current; so stabil wie m&ouml;glich bleibt.  Weiterhin
	      Leute, die Vorschl&auml;ge zu &Auml;nderungen oder der
	      generellen Entwicklung von &os; machen und Patches
	      bereitstellen, um diese Vorschl&auml;ge zu realisieren.</para>
	  </listitem>

	  <listitem>
	    <para>F&uuml;r Leute, die die Entwicklung im Auge behalten
	      wollen, oder die Quellen zu Referenzzwecken (zum Beispiel
	      darin lesen, aber nicht verwenden) benutzen wollen.  Auch diese
	      Gruppe macht Vorschl&auml;ge oder steuert Quellcode
	      bei.</para>
	  </listitem>
	</orderedlist>
      </sect3>

      <sect3>
	<title>Was &os.current; <emphasis>nicht</emphasis> ist!</title>

	<orderedlist>
	  <listitem>
	    <para>Der schnellste Weg, neue Sachen vor dem offiziellen
	      Release auszuprobieren.  Bedenken Sie, dass der erste,
	      der die neuen Sachen ausprobiert, auch der erste ist, der die
	      neuen Fehler findet.</para>
	  </listitem>

	  <listitem>
	    <para>Ein schneller Weg, um an Fehlerbehebungen (engl.
	      <foreignphrase>bug fixes</foreignphrase>) zu kommen.  Jede
	      Version von &os.current; f&uuml;hrt mit gleicher
	      Wahrscheinlichkeit neue Fehler ein, mit der sie alte
	      behebt.</para>
	  </listitem>

	  <listitem>
	    <para>In irgendeiner Form <quote>offiziell
	        unterst&uuml;tzt</quote>.  Wir tun unser Bestes, um Leuten
	      aus den drei <quote>legitimen</quote> Benutzergruppen von
	      &os.current; zu helfen, aber wir <emphasis>haben einfach nicht
	      die Zeit</emphasis>, technische Unterst&uuml;tzung zu
	      erbringen.  Das kommt nicht daher, dass wir kleinliche,
	      gemeine Leute sind, die anderen nicht helfen wollen (wenn
	      wir das w&auml;ren, w&uuml;rden wir &os; nicht machen), wir
	      k&ouml;nnen einfach nicht jeden Tag Hunderte Nachrichten
	      beantworten <emphasis>und</emphasis> an &os; arbeiten!  Vor
	      die Wahl gestellt, &os; zu verbessern oder jede Menge Fragen
	      zu experimentellem Code zu beantworten, haben sich die
	      Entwickler f&uuml;r ersteres entschieden.</para>
	  </listitem>
	</orderedlist>
      </sect3>

      <sect3>
	<title>Benutzen von &os.current;</title>

	<indexterm>
	  <primary>-CURRENT</primary>
	  <secondary>benutzen</secondary>
	</indexterm>
	<orderedlist>
	  <listitem>
	    <para>Es ist <emphasis>essentiell</emphasis>, die Mailinglisten
	      &a.current.name; und &a.svn-src-head.name; zu lesen.  Wenn Sie
	      <emphasis>&a.current.name;</emphasis> nicht lesen, verpassen Sie
	      die Kommentare anderer &uuml;ber den momentanen Zustand des
	      Systems und rennen demzufolge in viele bekannte Probleme, die
	      schon gel&ouml;st sind.  Noch kritischer ist, dass Sie wichtige
	      Bekanntmachungen verpassen, die erhebliche Auswirkungen
	      auf die Stabilit&auml;t Ihres Systems haben k&ouml;nnen.</para>

	    <para>In der &a.svn-src-head.name; Mailingliste sehen Sie zu jeder
	      &Auml;nderung das Commit-Log, das Informationen zu
	      m&ouml;glichen Seiteneffekten enth&auml;lt.</para>

	    <para>Um diese Listen zu abonnieren (oder zu lesen)
	      besuchen Sie bitte die Seite &a.mailman.lists.link;.
	      Weitere Informationen erhalten Sie, wenn Sie dort
	      auf die gew&uuml;nschte Liste klicken.  Wenn Sie daran
	      interessiert sind, die &Auml;nderungen am gesamten Quellbaum
	      mit zu verfolgen, schlagen wir vor, die Liste
	      &a.svn-src-all.name; zu abonnieren.</para>
	  </listitem>

	  <listitem>
	    <para>Beschaffen Sie sich die Quellen von einem
	      <link linkend="mirrors">&os;-Spiegel</link>.  Sie haben
	      dazu zwei M&ouml;glichkeiten:</para>

	    <orderedlist>
              <indexterm>
                <primary><command>cvsup</command></primary>
              </indexterm>
              <indexterm>
                <primary><command>cron</command></primary>
              </indexterm>
              <indexterm>
	        <primary>-CURRENT</primary>
		<secondary>mit <application>CVSup</application>
		  synchronisieren</secondary>
	      </indexterm>

	      <listitem>
		<para>Benutzen Sie das Programm
		  <link linkend="cvsup">cvsup</link>
		  mit der Datei <filename>standard-supfile</filename>
		  aus dem Verzeichnis
		  <filename>/usr/share/examples/cvsup</filename>.
		  Dies ist die empfohlene Methode, da Sie die ganzen
		  Quellen nur einmal herunterladen und danach nur noch
		  &Auml;nderungen beziehen.  Viele lassen
		  <command>cvsup</command> aus <command>cron</command>
		  heraus laufen, um ihre Quellen automatisch auf Stand
		  zu bringen.  Sie m&uuml;ssen die obige Sup-Datei
		  anpassen und <link linkend="cvsup">cvsup</link>
		  in Ihrer Umgebung konfigurieren.</para>

		<note>
		  <para>Die <filename>standard-supfile</filename>-Beispieldatei
		    ist daf&uuml;r vorgesehen, einen bestimmten
		    Sicherheitszweig zu verfolgen und nicht &os.current;.  Sie
		    m&uuml;ssen diese Datei bearbeiten und die folgende
		    Zeile:</para>

		  <programlisting>*default release=cvs tag=RELENG_<replaceable>X</replaceable>_<replaceable>Y</replaceable></programlisting>

                  <para>durch diese ersetzen:</para>

                  <programlisting>*default release=cvs tag=.</programlisting>

                  <para>Lesen Sie den Abschnitt &uuml;ber <link
                    linkend="cvs-tags">CVS Tags</link> im Handbuch, um eine
                    genaue Beschreibung von verwendbaren Tags zu
                    erhalten.</para>
		</note>
	      </listitem>

              <indexterm>
	        <primary>-CURRENT</primary>
		<secondary>mit CTM synchronisieren</secondary>
	      </indexterm>
	      <listitem>
		<para><application><link linkend="ctm">CTM</link></application>
		  kommt in Frage, wenn Sie
		  &uuml;ber eine schlechte Internet-Anbindung (hoher Preis
		  oder nur E-Mail Zugriff) verf&uuml;gen.  Der Umgang mit
		  <application>CTM</application> ist allerdings recht
		  m&uuml;hsam und Sie k&ouml;nnen besch&auml;digte Dateien
		  erhalten.  Daher wird es selten benutzt, was wiederum
		  dazu f&uuml;hrt, dass es &uuml;ber l&auml;ngere Zeit
		  nicht funktioniert.  Wir empfehlen jedem mit einem
		  9600&nbsp;bps oder schnellerem Modem,
		  <application><link linkend="cvsup">CVSup</link></application>
		  zu benutzen.</para>
	      </listitem>
	    </orderedlist>
	  </listitem>

	  <listitem>
	    <para>Wenn Sie die Quellen einsetzen und nicht nur darin
	      lesen wollen, besorgen Sie sich bitte die
	      <emphasis>kompletten</emphasis> Quellen von &os.current; und
	      nicht nur ausgesuchte Teile.  Der Grund hierf&uuml;r ist,
	      dass die verschiedenen Teile der Quellen voneinander
	      abh&auml;ngen.  Es ist ziemlich sicher, dass Sie in
	      Schwierigkeiten geraten, wenn Sie versuchen, nur einen Teil
	      der Quellen zu &uuml;bersetzen.</para>

	    <indexterm>
	      <primary>-CURRENT</primary>
	      <secondary>&uuml;bersetzen</secondary>
	    </indexterm>

	    <para>Sehen Sie sich das <filename>Makefile</filename> in
	      <filename>/usr/src</filename> genau an, bevor Sie
	      &os.current; &uuml;bersetzen.  Wenn Sie
	      &os; das erste Mal aktualisieren, sollten Sie sowohl
	      <link linkend="makeworld">einen Kernel als auch das
		System neu installieren</link>.
	      Lesen Sie bitte die Mailingliste &a.current;
	      und <filename>/usr/src/UPDATING</filename>, um &uuml;ber
	      &Auml;nderungen im Installationsverfahren, die manchmal
	      vor der Einf&uuml;hrung eines neuen Releases notwendig sind,
	      informiert zu sein.</para>
	  </listitem>

	  <listitem>
	    <para>Seien Sie aktiv!  Wenn Sie &os.current; laufen lassen,
	      wollen wir wissen, was Sie dar&uuml;ber denken, besonders
	      wenn Sie Verbesserungsvorschl&auml;ge oder Fehlerbehebungen
	      haben.  Verbesserungsvorschl&auml;ge, die Code enthalten,
	      werden &uuml;brigens begeistert entgegengenommen.</para>
	  </listitem>
	</orderedlist>
      </sect3>
    </sect2>

    <sect2 id="stable">
      <title>&os.stable;</title>

      <sect3>
	<title>Was ist &os.stable;?</title>
	<indexterm><primary>-STABLE</primary></indexterm>

	<para>&os.stable; ist der Entwicklungszweig, auf dem Releases
	  erstellt werden.  Dieser Zweig &auml;ndert sich langsamer als
	  &os.current; und alle &Auml;nderungen hier sollten zuvor in
	  &os.current; ausgetestet sein.  Beachten Sie, dass dies
	  <emphasis>immer noch</emphasis> ein Entwicklungszweig ist und
	  daher zu jedem Zeitpunkt die Quellen von &os.stable; verwendbar
	  sein k&ouml;nnen oder nicht.  &os.stable; ist Teil des
	  Entwicklungsprozesses und nicht f&uuml;r Endanwender
	  gedacht.</para>
      </sect3>

      <sect3>
	<title>Wer braucht &os.stable;?</title>

	<para>Wenn Sie den FreeBSD-Entwicklungsprozess, besonders im
	  Hinblick auf das n&auml;chste Release, verfolgen oder
	  dazu beitragen wollen, sollten Sie erw&auml;gen, &os.stable; zu
	  benutzen.</para>

	<para>Auch wenn sicherheitsrelevante Fehlerbehebungen in den
	  &os.stable; Zweig einflie&szlig;en, m&uuml;ssen Sie deswegen
	  noch lange nicht &os.stable; verfolgen.  Jeder der FreeBSD
	  Sicherheitshinweise beschreibt f&uuml;r jedes betroffene Release,
	  <footnote><para>Das stimmt nicht ganz.  Obwohl wir alte FreeBSD
	    Releases f&uuml;r einige Jahre unterst&uuml;tzen, k&ouml;nnen
	    wir sie nicht ewig unterst&uuml;tzen.  Eine vollst&auml;ndige
	    Beschreibung der Sicherheitspolitik f&uuml;r alte FreeBSD
	    Releases entnehmen Sie bitte <ulink
	    url="&url.base;/security/">http://www.FreeBSD.org/security/</ulink>.</para>
	  </footnote>
	  wie sie einen sicherheitsrelevanten Fehler beheben.
	  Wenn Sie den Entwicklungszweig aus Sicherheitsgr&uuml;nden
	  verfolgen wollen, bedenken Sie, dass Sie neben
	  Fehlerbehebungen auch eine Vielzahl unerw&uuml;nschter
	  &Auml;nderungen erhalten werden.</para>

	<para>Obwohl wir versuchen sicherzustellen, dass der
	  &os.stable; Zweig sich jederzeit &uuml;bersetzen l&auml;sst
	  und l&auml;uft, k&ouml;nnen wir daf&uuml;r keine Garantie
	  &uuml;bernehmen.  Auch wenn Neuentwicklungen in &os.current;
	  stattfinden, ist es jedoch so, dass mehr Leute
	  &os.stable; benutzen als &os.current; und es daher unvermeidlich
	  ist, dass Fehler und Grenzf&auml;lle erst in &os.stable;
	  auffallen.</para>

	<para>Aus diesen Gr&uuml;nden empfehlen wir Ihnen
	  <emphasis>nicht</emphasis>, blindlings &os.stable; zu benutzen.
	  Es ist wichtig, dass Sie &os.stable; zuerst sorgf&auml;ltig
	  in einer Testumgebung austesten, bevor Sie Ihre Produktion
	  auf &os.stable; migrieren.</para>

	<para>Wenn Sie dies nicht leisten k&ouml;nnen, empfehlen wir Ihnen,
	  das aktuelle FreeBSD-Release zu verwenden.  Benutzen Sie dann den
	  bin&auml;ren Update-Mechanismus, um auf neue Releases
	  zu migrieren.</para>
      </sect3>

      <sect3>
	<title>Benutzen von &os.stable;</title>

	<indexterm>
	  <primary>-STABLE</primary>
	  <secondary>benutzen</secondary>
	</indexterm>
	<orderedlist>
	  <listitem>
	    <para>Lesen Sie Mailingliste &a.stable.name;, damit Sie &uuml;ber
	      Abh&auml;ngigkeiten beim Bau von &os.stable; und Sachen, die
	      besondere Aufmerksamkeit erfordern, informiert sind.
	      Umstrittene Fehlerbehebungen oder &Auml;nderungen werden von
	      den Entwicklern auf dieser Liste bekannt gegeben.  Dies
	      erlaubt es den Benutzern, Einw&auml;nde gegen die
	      vorgeschlagenen &Auml;nderungen vorzubringen.</para>

	    <para>Abonnieren Sie die passende
	      <application>SVN</application>-Liste f&uuml;r den jeweiligen
	      Branch, den Sie verfolgen.  Wenn Sie beispielsweise den Zweig
	      7-STABLE verfolgen, lesen Sie die &a.svn-src-stable-7.name;.
	      Dort sehen Sie zu jeder &Auml;nderung das Commit-Log, das
	      Informationen zu m&ouml;glichen Seiteneffekten
	      enth&auml;lt.</para>

	    <para>Um diese Listen oder andere Listen zu abonnieren
	      besuchen Sie bitte die Seite &a.mailman.lists.link;.
	      Weitere Informationen erhalten Sie, wenn Sie dort
	      auf die gew&uuml;nschte Liste klicken.  Wenn Sie daran
	      interessiert sind, &Auml;nderungen am gesamten Quellbaum zu
	      verfolgen, dann empfehlen wir, dass Sie &a.svn-src-all.name;
	      abonnieren.</para>
	  </listitem>

	  <listitem>
	    <para>Wenn Sie ein neues System installieren und dazu einen
	      der monatlich aus &os.stable; erzeugten Snapshots verwenden
	      wollen, sollten Sie zuerst die <ulink
	      url="&url.base;/../snapshots/">Snapshot Website</ulink> auf
	      aktuelle Informationen &uuml;berpr&uuml;fen.  Alternativ
	      k&ouml;nnen Sie auch das neueste &os.stable;-Release von
	      den <link linkend="mirrors">Spiegeln</link> beziehen
	      und Ihr System nach den folgenden Anweisungen
	      aktualisieren.</para>

	    <para>Wenn Sie schon ein &auml;lteres Release von &os;
	      und das System mit dem Quellcode aktualisieren wollen,
	      benutzen Sie einen der <link
	        linkend="mirrors">&os;-Spiegel</link>.  Sie haben
	      dazu zwei M&ouml;glichkeiten:</para>

	    <orderedlist>
	      <indexterm>
		<primary><command>cvsup</command></primary>
	      </indexterm>
	      <indexterm>
		<primary><command>cron</command></primary>
	      </indexterm>
	      <indexterm>
	        <primary>-STABLE</primary>
		<secondary>mit <application>CVSup</application>
		  synchronisieren</secondary>
	      </indexterm>
	      <listitem>
		<para>Benutzen Sie das Programm
		  <link linkend="cvsup">cvsup</link>
		  mit der Datei <filename>stable-supfile</filename>
		  aus dem Verzeichnis
		  <filename>/usr/share/examples/cvsup</filename>.
		  Dies ist die empfohlene Methode, da Sie die ganzen
		  Quellen nur einmal herunterladen und danach nur noch
		  &Auml;nderungen beziehen.  Viele lassen
		  <command>cvsup</command> aus <command>cron</command>
		  heraus laufen, um ihre Quellen automatisch auf Stand
		  zu bringen.  Sie m&uuml;ssen das oben erw&auml;hnte
		  <filename>supfile</filename> anpassen und <link
		    linkend="cvsup">cvsup</link> konfigurieren.</para>
	      </listitem>

	      <indexterm>
	        <primary>-STABLE</primary>
		<secondary>mit CTM synchronisieren</secondary>
	      </indexterm>
	      <listitem>
		<para>Benutzen Sie <application><link linkend="ctm">
		    CTM</link></application>.  Wenn Sie &uuml;ber
		  keine schnelle und billige Internet-Anbindung
		  verf&uuml;gen, sollten Sie diese Methode in Betracht
		  ziehen.</para>
	      </listitem>
	   </orderedlist>
	 </listitem>

	  <listitem>
	    <para>Benutzen Sie <command>cvsup</command> oder
	      <command>ftp</command>, wenn Sie schnellen Zugriff auf die
	      Quellen brauchen und die Bandbreite keine Rolle spielt,
	      andernfalls benutzen Sie
	      <application>CTM</application>.</para>
	  </listitem>

	  <indexterm>
	    <primary>-STABLE</primary>
	    <secondary>&uuml;bersetzen</secondary>
	  </indexterm>
	  <listitem>
	    <para>Bevor Sie &os.stable; &uuml;bersetzen, sollten Sie sich
	      das <filename>Makefile</filename> in
	      <filename>/usr/src</filename> genau anschauen.  Wenn Sie
	      &os; das erste Mal aktualisieren, sollten Sie sowohl
	      <link linkend="makeworld">einen Kernel als auch das
		System neu installieren</link>.
	      Lesen Sie bitte die Mailingliste &a.stable;
	      und <filename>/usr/src/UPDATING</filename>, um &uuml;ber
	      &Auml;nderungen im Installationsverfahren, die manchmal
	      vor der Einf&uuml;hrung eines neuen Releases notwendig sind,
	      informiert zu sein.</para>
	  </listitem>
	</orderedlist>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="synching">
    <title>Synchronisation der Quellen</title>

    <para>Sie k&ouml;nnen eine Internet-Verbindung (oder E-Mail) dazu
      nutzen, Teile von &os;, wie die Quellen zu einzelnen Projekten, oder
      das Gesamtsystem, aktuell zu halten.  Dazu bieten wir die Dienste
      <link linkend="anoncvs">AnonymousCVS</link>,
      <link linkend="cvsup">CVSup</link> und
      <link linkend="ctm">CTM</link> an.</para>

    <warning>
      <para>Obwohl es m&ouml;glich ist, nur Teile des Quellbaums zu
        aktualisieren, ist die einzige unterst&uuml;tze Migrationsprozedur,
	den kompletten Quellbaum zu aktualisieren und alles, das
	hei&szlig;t das Userland (z.B. alle Programme in
	<filename>/bin</filename> und <filename>/sbin</filename>) und die
	Kernelquellen, neu zu &uuml;bersetzen.  Wenn Sie nur einen Teil der
	Quellen, zum Beispiel nur den Kernel oder nur die Programme aus dem
	Userland, aktualisieren, werden Sie oft Probleme haben, die von
	&Uuml;bersetzungsfehlern &uuml;ber Kernel-Panics bis hin zu
	Besch&auml;digungen Ihrer Daten reichen k&ouml;nnen.</para>
    </warning>

    <indexterm>
      <primary>CVS</primary>
      <secondary>anonymous</secondary>
    </indexterm>

    <para><application>Anonymous CVS</application> und
      <application>CVSup</application> benutzen die
      <foreignphrase>Pull</foreignphrase>-Methode
      <footnote>
	<para>Von engl. <foreignphrase>to pull</foreignphrase> =
	  <emphasis>ziehen</emphasis>.  Der Client holt sich bei dieser
	  Methode die Dateien ab.</para>
      </footnote>, um die Quellen zu aktualisieren.  Im Fall von
      <application>CVSup</application> ruft der Benutzer oder ein
      <command>cron</command>-Skript <command>cvsup</command> auf, das
      wiederum mit einem <command>cvsupd</command> Server interagiert, um
      Ihre Quellen zu aktualisieren.  Mit beiden Methoden erhalten Sie
      aktuelle Updates zu einem genau von Ihnen bestimmten Zeitpunkt.  Sie
      k&ouml;nnen die Prozedur auf bestimmte Dateien oder Verzeichnisse
      einschr&auml;nken, so dass Sie nur die Updates bekommen, die
      f&uuml;r Sie von Interesse sind.  Die Updates werden zur Laufzeit,
      abh&auml;ngig von den Sachen, die Sie schon haben und den Sachen, die
      Sie haben wollen, auf dem Server generiert.  <application>Anonymous
        CVS</application> ist eine Erweiterung von
      <application>CVS</application>, die es Ihnen erlaubt, &Auml;nderungen
      direkt aus einem entfernten CVS-Repository zu ziehen.
      <application>Anonymous CVS</application> ist leichter zu handhaben
      als <application>CVSup</application>, doch ist letzteres sehr viel
      effizienter.</para>

    <indexterm>
      <primary><application>CTM</application></primary>
    </indexterm>
    <para>Im Gegensatz dazu vergleicht <application>CTM</application> Ihre
      Quellen nicht mit denen auf einem Server.  Stattdessen l&auml;uft auf
      dem Server ein Skript, das &Auml;nderungen an Dateien gegen&uuml;ber
      seinem vorigen Lauf bemerkt, die &Auml;nderungen komprimiert, mit
      einer Sequenznummer versieht und f&uuml;r das Verschicken per E-Mail
      kodiert (es werden nur druckbare ASCII-Zeichen verwendet).  Wenn Sie
      diese <quote>CTM-Deltas</quote> erhalten haben, k&ouml;nnen Sie sie
      mit &man.ctm.rmail.1; benutzen, welches die Deltas dekodiert,
      verifiziert und dann die &Auml;nderungen an Ihren Quellen vornimmt.
      Dieses Verfahren ist viel effizienter als
      <application>CVSup</application> und erzeugt auch weniger Last auf
      unseren Servern, da es die
      <foreignphrase>Push</foreignphrase>-Methode
      <footnote>
	<para>Von engl. <foreignphrase>to push</foreignphrase> =
	  <emphasis>schieben</emphasis>.  Der Server schickt dem Client die
	  Dateien.</para>
      </footnote> verwendet.</para>

    <para>Es gibt nat&uuml;rlich noch weitere Unterschiede, die Sie
      beachten sollten.  Wenn Sie unabsichtlich Teile Ihres Archivs
      l&ouml;schen, wird das von <application>CVSup</application>
      wie <application>Anonymous CVS</application> erkannt
      und repariert.  Wenn sich fehlerhafte Dateien in Ihrem Quellbaum
      befinden, l&ouml;schen Sie diese einfach und synchronisieren erneut.
      <application>CTM</application> leistet das nicht,
      wenn Sie Teile des Quellbaums gel&ouml;scht haben und keine Sicherung
      besitzen, m&uuml;ssen Sie von neuem, das hei&szlig;t vom letzten
      <quote>Basis-Delta</quote>, starten und die &Auml;nderungen wieder
      mit <application>CTM</application> nachziehen.</para>
  </sect1>

  <sect1 id="makeworld">
    <title>Das komplette Basissystem neu bauen</title>

    <indexterm>
      <primary>Bau des Basissystems</primary>
    </indexterm>

    <para>Wenn Sie Ihren lokalen Quellbaum mit einer bestimmten FreeBSD
      Version (&os.stable;, &os.current;, usw.) synchronisiert haben,
      k&ouml;nnen Sie diesen benutzen, um das System neu zu
      bauen.</para>

    <warning>
      <title>Erstellen Sie eine Sicherungskopie!</title>

      <para>Es kann nicht oft genug betont werden, wie wichtig es ist, Ihr
        System zu sichern, <emphasis>bevor</emphasis> Sie die nachfolgenden
	Schritte ausf&uuml;hren.  Obwohl der Neubau des Systems eine
	einfache Aufgabe ist, wenn Sie sich an die folgende Anleitung
	halten, kann es dennoch vorkommen, dass Sie einen Fehler machen,
	oder dass Ihr System nicht mehr bootet, weil andere Entwickler
	Fehler in den Quellbaum eingef&uuml;hrt haben.</para>

      <para>Stellen Sie sicher, dass Sie eine Sicherung erstellt haben
        und &uuml;ber eine Fixit-Floppy oder eine startf&auml;hige CD
	verf&uuml;gen.  Wahrscheinlich werden Sie die Startmedien
	nicht ben&ouml;tigen, aber gehen Sie auf Nummer Sicher!</para>
    </warning>

    <warning>
      <title>Abonnieren Sie die richtige Mailingliste</title>

      <indexterm><primary>Mailingliste</primary></indexterm>
      <para>Die &os.stable; und &os.current; Zweige befinden sich in
        <emphasis>st&auml;ndiger Entwicklung</emphasis>.  Die Leute, die zu
	&os; beitragen, sind Menschen und ab und zu machen sie
	Fehler.</para>

      <para>Manchmal sind diese Fehler harmlos und lassen Ihr System eine
        Warnung ausgeben.  Die Fehler k&ouml;nnen allerdings auch
	katastrophal sein und dazu f&uuml;hren, dass Sie Ihr System
	nicht mehr booten k&ouml;nnen, Dateisysteme besch&auml;digt
	werden oder Schlimmeres passiert.</para>

      <para>Wenn solche Probleme auftauchen, wird ein
	<quote>heads up</quote> an die passende Mailingliste geschickt, welches
	das Problem erkl&auml;rt und die betroffenen Systeme benennt.  Eine
	<quote>all clear</quote> Meldung wird versendet, wenn das
	Problem gel&ouml;st ist.</para>

      <para>Wenn Sie &os.stable; oder &os.current; benutzen und nicht die
        Mailinglisten &a.stable; beziehungsweise &a.current; lesen, bringen
	Sie sich nur unn&ouml;tig in Schwierigkeiten.</para>
    </warning>

    <warning>
      <title>Finger weg von <command>make world</command></title>

      <para>&Auml;ltere Dokumentationen empfehlen, das Kommando
	<command>make world</command> f&uuml;r den Neubau.
	Das Kommando &uuml;berspringt wichtige Schritte.  Setzen
	Sie es nur ein, wenn Sie wissen was Sie tun.  In fast
	allen F&auml;llen ist <command>make world</command>
	falsch, benutzen Sie stattdessen die nachstehende
	Anleitung.</para>
    </warning>

    <sect2 id="canonical-build">
      <title>Richtig aktualisieren</title>

      <para>Um Ihr System zu aktualisieren, sollten Sie zuerst
	<filename>/usr/src/UPDATING</filename> lesen, und
	eventuelle, f&uuml;r Ihre Quellcodeversion n&ouml;tigen
	Aufgaben erledigen, bevor Sie das System bauen.  Danach
	aktualisieren Sie Ihr System mit den folgenden
	Schritten.</para>

      <para>Bei den hier dargestellten Aktualisierungsschritten wird davon
        ausgegangen, dass Sie momentan eine alte &os;-Version verwenden, die
        aus einem alten Compiler, Kernel, sowie einem alten Basissystem und
        veralteten Konfigurationsdateien besteht.  Mit
        <quote>Basissystem</quote> sind hier die zentralen Bin&auml;rdateien,
        Bibliotheken und Entwicklerdateien gemeint.  Der Compiler ist Teil
        des <quote>Basissystems</quote>, beinhaltet aber ein paar
        Besonderheiten.</para>

      <para>Es wird ausserdem davon ausgegangen, dass Sie bereits die Quellen
        f&uuml;r ein neues System bezogen haben.  Falls die Quellen in dem
        vorliegenden System zu alt sind, lesen Sie <xref linkend="synching">,
        um detaillierte Hilfe &uuml;ber die Aktualisierung der Quellen zu
        erhalten.</para>

      <para>Die Aktualisierung des Systems aus den Quellen ist ein wenig
        ausget&uuml;ftelter als es zun&auml;chst den Anschein hat. Die
        Entwickler von &os; haben es &uuml;ber die Jahre f&uuml;r N&ouml;tig
        befunden, den vorgeschlagenen Ablauf ziemlich stark zu
        ver&auml;ndern, da neue Arten von unvermeidlichen Abh&auml;ngigkeiten
        mit der Zeit ans Licht kamen.  Der &uuml;brige Teil dieses Abschnitts
        beschreibt die &Uuml;berlegungen hinter der aktuell empfohlenen
        Aktualisierungsreihenfolge.</para>

      <para>Jede erfolgreiche Aktualisierung muss sich mit den folgenden
        Sachverhalten auseinandersetzen:</para>

      <itemizedlist>
        <listitem>
          <para>Der alte Compiler ist m&ouml;glicherweise nicht in der Lage,
            den neuen Kernel zu &uuml;bersetzen (alte Compiler besitzen
            manchmal Fehler).  Deshalb sollte der neue Kernel mit dem neuen
            Compiler &uuml;bersetzt werden.  Ganz besonders muss darauf
            geachtet werden, dass der neue Compiler vor dem neuen Kernel
            gebaut wird.  Das bedeutet nicht unbedingt, dass der neue
            Compiler auch <emphasis>installiert</emphasis> werden muss, bevor
            der neue Kernel gebaut wird.</para>
        </listitem>

        <listitem>
          <para>Das neue Basissystem ben&ouml;tigt eventuell neue
            Eigenschaften des Kernels. Also muss der neue Kernel installiert
            sein, bevor das neue Basissystem installiert wird.</para>
        </listitem>
      </itemizedlist>

      <para>Diese ersten beiden Sachverhalte sind die Grundlage f&uuml;r die
        zentrale Sequenz von <maketarget>buildworld</maketarget>,
        <maketarget>buildkernel</maketarget>,
        <maketarget>installkernel</maketarget> und
        <maketarget>installworld</maketarget>, die in den folgenden
        Abschnitten beschrieben wird.  Dies ist keine vollst&auml;ndige Liste
        all der Gr&uuml;nde, warum Sie den aktuell empfohlenen Prozess der
        Aktualisierung bevorzugen sollten.  Ein paar der weniger
        naheliegenden Gr&uuml;nde sind im folgenden aufgez&auml;hlt:</para>

     <itemizedlist>
       <listitem>
         <para>Das alte Basissystem wird m&ouml;glicherweise nicht korrekt
           mit dem neuen Kernel funktionieren, weshalb Sie das neue
           Basissystem sofort nach der Installation des neuen Kernels
           installieren m&uuml;ssen.</para>
       </listitem>

       <listitem>
  	 <para>Manche &Auml;nderungen an der Konfiguration m&uuml;ssen
  	   erledigt worden sein, bevor das neue Basissystem installiert wird,
  	   jedoch k&ouml;nnen andere die Funktionalit&auml;t des alten
  	   Basissystems beeintr&auml;chtigen.  Aus diesem Grund sind zwei
  	   verschiedene Schritte notwendig, um eine Aktualisierung der
  	   Konfiguration durchzuf&uuml;hren.</para>
       </listitem>

       <listitem>
         <para>Der Aktualisierungsprozess ersetzt zum Grossteil Dateien oder
           f&uuml;gt neue hinzu, bestehende Dateien werden nicht
           gel&ouml;scht.  In wenigen Ausnahmef&auml;llen kann dies Probleme
           verursachen.  Aus diesem Grund wird der Aktualisierungsprozess
           manchmal bestimmte Dateien zum manuellen L&ouml;schen vorschlagen.
           Dies wird eventuell in der Zukunft automatisch
           durchgef&uuml;hrt.</para>
       </listitem>
     </itemizedlist>

     <para>Diese Bedenken haben zu der folgenden Reihenfolge gef&uuml;hrt.
       Beachten Sie, dass der genaue Ablauf f&uuml;r bestimmte
       Aktualisierungen zus&auml;tzliche Schritte nach sich zieht, jedoch
       sollte der Kernprozess davon nicht beeintr&auml;chtigt werden:</para>

     <orderedlist>
       <listitem>
         <para><command>make
           <maketarget>buildworld</maketarget></command></para>

         <para>Dieser Schritt &uuml;bersetzt zuerst den neuen Compiler und
           ein paar damit zusammenh&auml;ngende Werkzeuge und verwendet dann
           den neuen Compiler, um den Rest des Basissystems zu erstellen.
           Das Ergebnis landet dann in <filename
           class="directory">/usr/obj</filename>.</para>
       </listitem>

       <listitem>
         <para><command>make
           <maketarget>buildkernel</maketarget></command></para>

         <para>Statt dem alten Ansatz, &man.config.8; und
           &man.make.1; zu verwenden, nutzt dieser den
           <emphasis>neuen</emphasis> Compiler, der in <filename
           class="directory">/usr/obj</filename> abgelegt ist.
           Das sch&uuml;tzt Sie vor falschen
           Compiler-Kernel-Kombinationen.</para>
       </listitem>

       <listitem>
         <para><command>make
           <maketarget>installkernel</maketarget></command></para>

         <para>Platziert den neuen Kernel und Kernelmodule auf der Platte,
           was es erlaubt, mit dem frisch aktualisierten Kernel zu
           starten.</para>
       </listitem>

       <listitem>
         <para>Starten Sie das System neu in den Single-User-Modus.</para>

         <para>Der Single-User-Modus minimiert Probleme mit der
           Aktualisierung von Programmen, die bereits gestartet sind.  Ebenso
           minimiert es Probleme, die mit der Verwendung des alten
           Basissystems und des neuen Kernels zu tun haben
           k&ouml;nnten.</para>
       </listitem>

       <listitem>
         <para><command>mergemaster <option>-p</option></command></para>

         <para>Dieser Schritt aktualisiert ein paar initiale
           Konfigurationsdateien als Vorbereitung f&uuml;r das neue
           Basissystem.  Beispielsweise f&uuml;gt es neue Benutzergruppen
           zum System oder neue Benutzernamen in die Passwortdatenbank hinzu.
           Dies wird oftmals ben&ouml;tigt, wenn neue Gruppen oder bestimmte
           Systembenutzerkonten seit der letzten Aktualisierung hinzu gekommen
           sind, so dass der <maketarget>installworld</maketarget>-Schritt
           in der Lage ist, auf dem neu installierten System die Benutzer
           oder Systemgruppennamen ohne Probleme zu verwenden.</para>
       </listitem>

       <listitem>
         <para><command>make
           <maketarget>installworld</maketarget></command></para>

         <para>Kopiert das Basissystem aus <filename
           class="directory">/usr/obj</filename>.  Sie haben jetzt den
           neuen Kernel und das neue Basissystem auf der Festplatte.</para>
       </listitem>

       <listitem>
         <para><command>mergemaster</command></para>

         <para>Sie k&ouml;nnen nun die verbleibenden Konfigurationsdateien
           aktualisieren, da Sie nun das neue Basissystem auf der Platte
           haben.</para>
       </listitem>

       <listitem>
         <para>Starten Sie das System neu.</para>

         <para>Ein kompletter Systemneustart ist notwendig, um den neuen
           Kernel und das neue Basissystem mit den neuen
           Konfigurationsdateien zu laden.</para>
       </listitem>
      </orderedlist>

      <para>Beachten Sie, dass wenn Sie von einem Release des gleichen
        &os;-Zweigs auf ein aktuelleres Release des gleichen Zweigs, z.B.
        von 7.0 auf 7.1, aktualisieren, dann ist diese Vorgehensweise nicht
        unbedingt notwendig, da Sie nur sehr unwahrscheinlich in
        ung&uuml;nstige Kombinationen zwischen Compiler, Kernel, Basissystem
        und den Konfigurationsdateien geraten werden.  Die &auml;ltere
        Vorgehensweise von <command>make
        <maketarget>world</maketarget></command>, gefolgt von der Erstellung
        und Installation des neuen Kernels funktioniert m&ouml;glicherweise
        gut genug, um kleinere Aktualisierungen vorzunehmen.</para>

      <para>Wenn Sie allerdings zwischen Hauptversionen aktualisieren wollen
        und befolgen diese Schritte nicht, sollten Sie sich auf Probleme
        gefasst machen.</para>

      <para>Es ist auch wichtig zu wissen, dass viele Aktualisierungen, z.B.
        von 4.<replaceable>X</replaceable> auf 5.0, viele spezielle und
        zus&auml;tzliche Schritte ben&ouml;tigt, wie beispielsweise das
        umbennen oder l&ouml;schen von speziellen Dateien vor installworld.
        Lesen Sie die Datei <filename>/usr/src/UPDATING</filename>
        gr&uuml;ndlich, besonders am Ende, wo die aktuell vorgeschlagene
        Aktualisierungssequenz explizit aufgelistet ist.</para>

      <para>Diese Prozedur hat sich mit der Zeit weiterentwickelt, da die
        Entwickler es f&uuml;r unm&ouml;glich erachtet haben, bestimmte
        Arten von Kombinationsproblemen vollst&auml;ndig auszuschliessen.
        Hoffentlich wird die aktuelle Aktualisierungsprozedur f&uuml;r lange
        Zeit stabil bleiben.</para>

      <para>Als Zusammenfassung ist hier nochmal die aktuell vorgeschlagene
        Vorgehensweise f&uuml;r die Aktualisierung von &os; aus den Quellen
        aufgelistet:</para>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make buildworld</userinput>
&prompt.root; <userinput>make buildkernel</userinput>
&prompt.root; <userinput>make installkernel</userinput>
&prompt.root; <userinput>shutdown -r now</userinput></screen>

      <note>
	<para>Es gibt einige, sehr seltene Situationen, in denen Sie
	  <command>mergemaster -p</command> zus&auml;tzlich
	  ausf&uuml;hren m&uuml;ssen, bevor Sie das System mit
	  <maketarget>buildworld</maketarget> bauen.  Diese Situationen
	  werden in <filename>UPDATING</filename> beschrieben.  Solche
	  Situationen treten aber in der Regel nur dann auf, wenn Sie
	  Ihr &os;-System um eine oder mehrere Hauptversionen
	  aktualisieren.</para>
      </note>

      <para>Nachdem <maketarget>installkernel</maketarget> erfolgreich
	abgeschlossen wurde, starten Sie das System im Single-User-Modus
	(etwa durch die Eingabe von <command>boot -s</command> am
	Loaderprompt).  Danach f&uuml;hren Sie die folgenden Anweisungen
	aus:</para>

      <screen>&prompt.root; <userinput>adjkerntz -i</userinput>
&prompt.root; <userinput>mount -a -t ufs</userinput>
&prompt.root; <userinput>mergemaster -p</userinput>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>mergemaster</userinput>
&prompt.root; <userinput>reboot</userinput></screen>

      <warning>
	<title>Lesen Sie bitte weiter</title>

	<para>Die obige Vorschrift ist nur eine
	  Ged&auml;chtnisst&uuml;tze.  Um die einzelnen
	  Schritte zu verstehen, lesen Sie bitte die
	  folgenden Abschnitte, insbesondere wenn Sie
	  einen angepassten Kernel erstellen.</para>
      </warning>
    </sect2>

    <sect2 id="src-updating">
      <title>Lesen Sie <filename>/usr/src/UPDATING</filename></title>

      <para>Bevor Sie etwas anderes tun, lesen Sie bitte
        <filename>/usr/src/UPDATING</filename> (oder die entsprechende
	Datei, wenn Sie den Quellcode woanders installiert haben).  Die
	Datei enth&auml;lt wichtige Informationen zu Problemen, auf die Sie
	sto&szlig;en k&ouml;nnten oder gibt die Reihenfolge vor, in der Sie
	bestimmte Kommandos laufen lassen m&uuml;ssen.  Die Anweisungen in
	<filename>UPDATING</filename> sind aktueller als die in diesem
	Handbuch.  Im Zweifelsfall folgen Sie bitte den Anweisungen aus
	<filename>UPDATING</filename>.</para>

      <important>
	<para>Das Lesen von <filename>UPDATING</filename> ersetzt nicht das
	  Abonnieren der richtigen Mailingliste.  Die beiden Voraussetzungen
	  erg&auml;nzen sich, es reicht nicht aus, nur eine zu
	  erf&uuml;llen.</para>
      </important>
    </sect2>

    <sect2 id="make-conf">
      <title>&Uuml;berpr&uuml;fen Sie
	<filename>/etc/make.conf</filename></title>
      <indexterm>
        <primary><filename>make.conf</filename></primary>
      </indexterm>

      <para>&Uuml;berpr&uuml;fen Sie die Dateien
	<filename>/usr/share/examples/etc/make.conf</filename>
	und <filename>/etc/make.conf</filename>.  Die erste enth&auml;lt
	Vorgabewerte, von denen die meisten auskommentiert sind.  Um diese
	w&auml;hrend des Neubaus des Systems zu nutzen, tragen Sie die
	Werte in <filename>/etc/make.conf</filename> ein.  Beachten Sie,
	dass alles, was Sie in <filename>/etc/make.conf</filename>
	eintragen, bei jedem Aufruf von <command>make</command> angezogen
	wird.  Es ist also klug, hier etwas Sinnvolles einzutragen.</para>

      <para>Typischerweise wollen Sie die Zeilen, die
        <makevar>CFLAGS</makevar> und <makevar>NO_PROFILE</makevar>
	enthalten, aus
	<filename>/usr/share/examples/etc/make.conf</filename>
	nach <filename>/etc/make.conf</filename> &uuml;bertragen und dort
	aktivieren.</para>

      <para>Sehen Sie sich auch die anderen Definitionen, wie
        <makevar>COPTFLAGS</makevar> oder <makevar>NOPORTDOCS</makevar> an
	und entscheiden Sie, ob Sie diese aktivieren wollen.</para>
    </sect2>

    <sect2 id="updating-etc">
      <title>Aktualisieren Sie die Dateien in <filename>/etc</filename></title>

      <para>Das Verzeichnis <filename>/etc</filename> enth&auml;lt den
        Gro&szlig;teil der Konfigurationsdateien des Systems und Skripten,
	die beim Start des Systems ausgef&uuml;hrt werden.  Einige dieser
	Skripten &auml;ndern sich bei einer Migration auf eine neue
	FreeBSD-Version.</para>

      <para>Einige der Konfigurationsdateien, besonders
        <filename>/etc/group</filename>, werden f&uuml;r den Normalbetrieb
	des Systems gebraucht.</para>

      <para>Es gab F&auml;lle, in denen das Kommando
        <command>make installworld</command> auf bestimmte
	Accounts oder Gruppen angewiesen war, die aber w&auml;hrend
	der Aktualisierung fehlten.  Demzufolge kam es zu Problemen
	bei der Aktualisierung.  In einigen F&auml;llen pr&uuml;ft
	<command>make buildworld</command> ob die Accounts oder
	Gruppen vorhanden sind.</para>

      <para>Ein Beispiel daf&uuml;r trat beim Anlegen des Benutzers
	<username>smmsp</username> auf.  Die Installationsprozedur
	schlug an der Stelle fehl, an der &man.mtree.8;
	versuchte, <filename>/var/spool/clientmqueue</filename>
	anzulegen.</para>

      <para>Um dieses Problem zu umgehen,rufen Sie &man.mergemaster.8;
	pr&auml;-buildworld-Modus auf, der mit <option>-p</option> aktiviert
	wird.  In diesem Modus werden nur Dateien verglichen, die f&uuml;r
	den Erfolg von <maketarget>buildworld</maketarget> oder
	<maketarget>installworld</maketarget> essentiell sind.  Wenn Ihre
	alte Version von <command>mergemaster</command> die Option
	<option>-p</option> noch nicht unterst&uuml;tzt, nehmen Sie beim
	ersten Lauf die neue Version aus dem Quellbaum:</para>

      <screen>&prompt.root; <userinput>cd /usr/src/usr.sbin/mergemaster</userinput>
&prompt.root; <userinput>./mergemaster.sh -p</userinput></screen>

      <tip>
	<para>Wenn Sie besonders paranoid sind, sollten Sie Ihr System nach
	  Dateien absuchen, die der Gruppe, die Sie umbenennen oder
	  l&ouml;schen, geh&ouml;ren:</para>

	<screen>&prompt.root; <userinput>find / -group <replaceable>GID</replaceable> -print</userinput></screen>

	<para>Das obige Kommando zeigt alle Dateien an, die der Gruppe
	  <replaceable>GID</replaceable> (dies kann entweder ein
	  Gruppenname oder eine numerische ID sein) geh&ouml;ren.</para>
      </tip>
    </sect2>

    <sect2 id="makeworld-singleuser">
      <title>Wechseln Sie in den Single-User-Modus</title>
      <indexterm><primary>Single-User-Modus</primary></indexterm>

      <para>Sie k&ouml;nnen das System im Single-User-Modus
        &uuml;bersetzen.  Abgesehen davon, dass dies etwas schneller
	ist, werden bei der Installation des Systems viele wichtige Dateien,
	wie die Standard-Systemprogramme, die Bibliotheken und
	Include-Dateien, ver&auml;ndert.  Sie bringen sich in
	Schwierigkeiten, wenn Sie diese Dateien auf einem laufenden System
	ver&auml;ndern, besonders dann, wenn zu dieser Zeit Benutzer auf
	dem System aktiv sind.</para>

      <indexterm><primary>Mehrbenutzermodus</primary></indexterm>
      <para>Eine andere Methode &uuml;bersetzt das System im
        Mehrbenutzermodus und wechselt f&uuml;r die Installation in den
	Single-User-Modus.  Wenn Sie diese Methode benutzen wollen, warten
	Sie mit den folgenden Schritten, bis der Bau des Systems fertig
	ist und Sie mit <maketarget>installkernel</maketarget> oder
	<maketarget>installworld</maketarget> installieren wollen.</para>

      <para>Als Superuser k&ouml;nnen Sie mit dem folgenden Kommando ein
        laufendes System in den Single-User-Modus bringen:</para>

      <screen>&prompt.root; <userinput>shutdown now</userinput></screen>

      <para>Alternativ k&ouml;nnen Sie das System mit der Option
        <quote>single user</quote> in den Single-User-Modus booten.
	Danach geben Sie die folgenden Befehle ein:</para>

      <screen>&prompt.root; <userinput>fsck -p</userinput>
&prompt.root; <userinput>mount -u /</userinput>
&prompt.root; <userinput>mount -a -t ufs</userinput>
&prompt.root; <userinput>swapon -a</userinput></screen>

      <para>Die Kommandos &uuml;berpr&uuml;fen die Dateisysteme,
        h&auml;ngen <filename>/</filename> wieder beschreibbar ein,
	h&auml;ngen dann alle anderen UFS Dateisysteme aus
	<filename>/etc/fstab</filename> ein und aktivieren den
	Swap-Bereich.</para>

        <note>
	  <para>Zeigt Ihre CMOS-Uhr die lokale Zeit und nicht GMT an, dies
	    erkennen Sie daran, dass &man.date.1; die
	    falsche Zeit und eine flasche Zeitzone anzeigt, setzen Sie das
	    folgende Kommando ab:</para>
<screen>&prompt.root; <userinput>adjkerntz -i</userinput></screen>

	  <para>Dies stellt sicher, dass Ihre Zeitzone richtig
	    eingestellt ist.  Ohne dieses Kommando werden Sie
	    vielleicht sp&auml;ter Probleme bekommen.</para>
        </note>

    </sect2>

    <sect2 id="cleaning-usr-obj">
      <title>Entfernen Sie <filename>/usr/obj</filename></title>

      <para>Die neugebauten Teile des Systems werden in der Voreinstellung
        unter <filename>/usr/obj</filename> gespeichert.  Die Verzeichnisse
	dort spiegeln die Struktur unter
	<filename>/usr/src</filename>.</para>

      <para>Sie k&ouml;nnen den <command>make buildworld</command> Prozess
        beschleunigen, indem Sie dieses Verzeichnis entfernen.  Dies
	erspart Ihnen zudem einigen &Auml;rger aufgrund von
	Abh&auml;ngigkeiten.</para>

      <para>Einige Dateien unter <filename>/usr/obj</filename> sind
        vielleicht durch die <option>immutable</option>-Option
	(siehe &man.chflags.1;) schreibgesch&uuml;tzt, die vor dem
	L&ouml;schen entfernt werden muss.</para>

      <screen>&prompt.root; <userinput>cd /usr/obj</userinput>
&prompt.root; <userinput>chflags -R noschg *</userinput>
&prompt.root; <userinput>rm -rf *</userinput></screen>
    </sect2>

    <sect2 id="updating-upgrading-compilebase">
      <title>&Uuml;bersetzen der Quellen des Basissystems</title>

      <sect3>
	<title>Sichern der Ausgaben</title>

	<para>F&uuml;r den Fall, dass etwas schief geht, sollten Sie
	  die Ausgaben von &man.make.1; in einer Datei sichern, damit Sie
	  eine Kopie der Fehlermeldung besitzen.  Das mag Ihnen nicht
	  helfen, den Fehler zu finden, kann aber anderen helfen, wenn Sie
	  Ihr Problem in einer der &os;-Mailinglisten schildern.</para>

	<para>Dazu k&ouml;nnen Sie einfach das Kommando &man.script.1;
	  benutzen, dem Sie beim Aufruf als Parameter den Dateinamen
	  f&uuml;r die Ausgaben mitgeben.  Setzen Sie das Kommando
	  unmittelbar vor dem Neubau ab und geben Sie
	  <userinput>exit</userinput> ein, wenn der Bau abgeschlossen
	  ist:</para>

	<screen>&prompt.root; <userinput>script /var/tmp/mw.out</userinput>
Script started, output file is /var/tmp/mw.out
&prompt.root; <userinput>make <replaceable>TARGET</replaceable></userinput>
<emphasis>&hellip; Ausgaben des Kommandos &hellip;</emphasis>
&prompt.root; <userinput>exit</userinput>
Script done, &hellip;</screen>

	<para>Sichern Sie die Ausgaben nicht in <filename>/tmp</filename>,
	  da dieses Verzeichnis beim n&auml;chsten Boot aufger&auml;umt
	  werden kann.  Ein geeigneteres Verzeichnis ist
	  <filename>/var/tmp</filename>, wie im vorigen Beispiel gezeigt,
	  oder das Heimatverzeichnis von <username>root</username>.</para>
      </sect3>

      <sect3 id="make-buildworld">
	<title>&Uuml;bersetzen des Basissystems</title>

	<para>Wechseln Sie in das Verzeichnis, in dem die Quellen liegen
	  (in der Voreinstellung ist das
	  <filename>/usr/src</filename>):</para>

	<screen>&prompt.root; <userinput>cd /usr/src</userinput></screen>

	<indexterm><primary><command>make</command></primary></indexterm>

	<para>Zum Neubau der Welt benutzen Sie &man.make.1;.  Dieses
	  Kommando liest ein <filename>Makefile</filename>, das Anweisungen
	  enth&auml;lt, wie die Programme, aus denen &os; besteht, zu bauen
	  sind und in welcher Reihenfolge diese zu bauen sind.</para>

	<para>Ein typischer Aufruf von <command>make</command> sieht wie
	  folgt aus:</para>

	<screen>&prompt.root; <userinput>make -<replaceable>x</replaceable> -D<replaceable>VARIABLE</replaceable> <replaceable>target</replaceable></userinput></screen>

	<para>In diesem Beispiel ist
	  <option>-<replaceable>x</replaceable></option> eine Option, die
	  Sie an &man.make.1; weitergeben wollen.  Eine Liste g&uuml;ltiger
	  Optionen finden Sie in der &man.make.1; Manualpage.</para>

	<para>Das Verhalten eines <filename>Makefile</filename>s wird von
	  Variablen bestimmt.  Mit
	  <option>-D<replaceable>VARIABLE</replaceable></option> setzen Sie
	  eine Variable.  Diese Variablen sind dieselben, die auch in
	  <filename>/etc/make.conf</filename> gesetzt werden, dies ist nur
	  ein alternativer Weg, Variablen zu setzen.</para>

	<para>Um zu verhindern, dass die <quote>profiled</quote>
	  Bibliotheken gebaut werden, rufen Sie <command>make</command> wie
	  folgt auf:</para>
	<screen>&prompt.root; <userinput>make -DNO_PROFILE <replaceable>target</replaceable></userinput></screen>

	<para>Dieser Aufruf entspricht dem folgenden Eintrag in
	  <filename>/etc/make.conf</filename>:</para>

	<programlisting>NO_PROFILE=    true     #    Avoid compiling profiled libraries</programlisting>

	<para>Jedes <filename>Makefile</filename> definiert einige
	  <quote>Ziele</quote>, die festlegen, was genau zu tun ist.  Mit
	  <replaceable>target</replaceable> w&auml;hlen Sie eins dieser
	  Ziele aus.</para>

	<para>Einige Ziele im <filename>Makefile</filename> sind nicht
	  f&uuml;r den Endanwender gedacht, sondern unterteilen den
	  Bauprozess in eine Reihe von Einzelschritten.</para>

	<para>Im Regelfall m&uuml;ssen Sie &man.make.1; keine Parameter
	  mitgeben, so dass Ihre Kommandozeile wie folgt aussehen
	  wird:</para>

	<screen>&prompt.root; <userinput>make <replaceable>target</replaceable></userinput></screen>

	<para><replaceable>target</replaceable> steht dabei f&uuml;r
	  die verschiedenen Ziele.  Das erste Ziel sollte immer
	  <makevar>buildworld</makevar> sein.</para>

	<para>Mit <maketarget>buildworld</maketarget> wird ein kompletter
	  Baum unterhalb von <filename>/usr/obj</filename> gebaut, der mit
	  <maketarget>installworld</maketarget>, einem weiteren Ziel, auf
	  dem System installiert werden kann.</para>

	<para>&Uuml;ber seperate Optionen zu verf&uuml;gen, ist aus
	  mehreren Gr&uuml;nden n&uuml;tzlich.  Erstens
	  k&ouml;nnen Sie das System auf einem laufenden System bauen, da die
	  Bauprozedur abgekapselt vom Rest des Systems ist.  Das System
	  l&auml;sst sich im Mehrbenutzermodus ohne negative
	  Seiteneffekte bauen.  Die Installation mit
	  <maketarget>installworld</maketarget> sollte aber immer noch im
	  Single-User-Modus erfolgen.</para>

	<para>Zweitens k&ouml;nnen Sie NFS benutzen, um mehrere Maschinen
	  in Ihrem Netzwerk zu aktualisieren.  Wenn Sie die Maschinen
	  <hostid>A</hostid>, <hostid>B</hostid> und <hostid>C</hostid>
	  aktualisieren wollen, lassen sie <command>make
	    buildworld</command> und <command>make installworld</command> auf
	  <hostid>A</hostid> laufen.  Auf den Maschinen <hostid>B</hostid>
	  und <hostid>C</hostid> k&ouml;nnen Sie die
	  Verzeichnisse <filename>/usr/src</filename> und
	  <filename>/usr/obj</filename> von <hostid>A</hostid> einh&auml;ngen
	  und brauchen dort nur noch <command>make installworld</command>
	  auszuf&uuml;hren, um die Bauresultate zu installieren.</para>

	<para>Obwohl das Ziel <maketarget>world</maketarget> noch
	  existiert, sollten Sie es wirklich nicht mehr benutzen.</para>

	<para>Um das System zu bauen, setzen Sie das folgende Kommando
	  ab:</para>

	<screen>&prompt.root; <userinput>make buildworld</userinput></screen>

	<para>Mit <option>-j</option> k&ouml;nnen Sie
	  <command>make</command> anweisen, mehrere Prozesse zu starten.
	  Besonders effektiv ist das auf Mehrprozessor-Systemen.  Da aber
	  der &Uuml;bersetzungsprozess haupts&auml;chlich von IO statt
	  der CPU bestimmt wird, ist diese Option auch auf
	  Einprozessor-Systemen n&uuml;tzlich.</para>

	<para>Auf einem typischen Einprozessor-System k&ouml;nnen Sie den
	  folgenden Befehl absetzen:</para>

	<screen>&prompt.root; <userinput>make -j4 buildworld</userinput></screen>

	<para>&man.make.1; wird dann bis zu vier Prozesse gleichzeitig
	  laufen lassen.  Erfahrungsberichte aus den Mailinglisten zeigen,
	  dass dieser Aufruf typischerweise den besten
	  Geschwindigkeitsgewinn bringt.</para>

	<para>Wenn Sie ein Mehrprozessor-System besitzen und SMP in Ihrem
	  Kernel konfiguriert ist, probieren Sie Werte zwischen 6 und 10
	  aus.</para>
      </sect3>

      <sect3>
	<title>Laufzeiten</title>
	<indexterm>
	  <primary>Bau des Basissystems</primary>
	  <secondary>Laufzeiten</secondary>
	</indexterm>

	<para>Die Laufzeit eines Baus wird von vielen Faktoren
	  beeinflusst, ein aktuelles System ben&ouml;tigt aber etwa
	  zwei Stunden um &os.stable; zu bauen.  Der Bau von
	  &os.current; dauert etwas l&auml;nger.</para>
      </sect3>
    </sect2>

    <sect2 id="new-kernel">
      <title>&Uuml;bersetzen und Installation des Kernels</title>
      <indexterm>
        <primary>Kernel</primary>
	<secondary>&Uuml;bersetzen</secondary>
      </indexterm>

      <para>Um das Beste aus Ihrem System zu holen, sollten Sie einen neuen
	Kernel kompilieren.  Praktisch gesehen ist das sogar notwendig, da
	sich einige Datenstrukturen ge&auml;ndert haben und Programme wie
	&man.ps.1; oder &man.top.1; nur mit einem Kernel zusammen arbeiten,
	der auch zu dem entsprechenden Quellcode passt.</para>

      <para>Am einfachsten und sichersten bauen Sie dazu den
        <filename>GENERIC</filename> Kernel.  Obwohl der
        <filename>GENERIC</filename> Kernel vielleicht nicht alle
        Ihre Ger&auml;te unterst&uuml;tzt, sollte er alles enthalten,
        um das System in den Single-User-Modus zu booten.  Dies ist auch
        ein guter Test, um zu sehen, dass das System
        ordnungsgem&auml;&szlig; funktioniert.  Nachdem Sie mit
        <filename>GENERIC</filename> gebootet und sichergestellt haben,
        dass Ihr System funktioniert, k&ouml;nnen Sie einen neuen
        Kernel mit Ihrer Konfigurationsdatei bauen.</para>

      <para>In aktuellen &os;-Versionen m&uuml;ssen Sie das
	<link linkend="make-buildworld">Basissystem neu bauen</link>,
	bevor Sie einen neuen Kernel erstellen.</para>

      <note>
	<para>Wenn Sie einen angepassten Kernel erstellen wollen und
	  bereits &uuml;ber eine Konfigurationsdatei verf&uuml;gen,
	  geben Sie diese, wie im folgenden Beispiel gezeigt, auf der
	  Kommandozeile an:</para>

        <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make buildkernel KERNCONF=<replaceable>MYKERNEL</replaceable></userinput>
&prompt.root; <userinput>make installkernel KERNCONF=<replaceable>MYKERNEL</replaceable></userinput></screen>

      </note>

      <para>Wenn <varname>kern.securelevel</varname> einen Wert
	gr&ouml;&szlig;er als <literal>1</literal> besitzt
	<emphasis>und</emphasis> der Kernel mit <literal>noschg</literal>
	oder &auml;hnlichen Optionen gesch&uuml;tzt ist, m&uuml;ssen Sie
	<maketarget>installkernel</maketarget> im Einbenutzermodus
	ausf&uuml;hren.  Wenn das nicht der Fall ist, sollten die beiden
	Kommandos problemlos im Mehrbenutzermodus laufen.  Weitere
	Informationen &uuml;ber <varname>kern.securelevel</varname> finden
	Sie in &man.init.8; und &man.chflags.1; erl&auml;utert Optionen, die
	Sie auf Dateien setzen k&ouml;nnen.</para>
    </sect2>

    <sect2 id="new-kernel-singleuser">
      <title>Booten Sie in den Single-User-Modus</title>
      <indexterm><primary>Single-User-Modus</primary></indexterm>

      <para>Um zu pr&uuml;fen, ob der neue Kernel funktioniert, sollten Sie
        in den Single-User-Modus booten.  Folgen Sie dazu der Anleitung aus
	<xref linkend="makeworld-singleuser">.</para>
    </sect2>

    <sect2 id="make-installworld">
      <title>Installation des Systems</title>

      <para>Nun k&ouml;nen Sie das neue System mit
	<maketarget>installworld</maketarget> installieren.
	Rufen Sie dazu das folgende Kommando auf:</para>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make installworld</userinput></screen>

      <note>
	<para>Wenn Sie mit dem <command>make buildworld</command> Kommando
	  Variablen verwenden haben, m&uuml;ssen Sie dieselben Variablen
	  auch bei dem <command>make installworld</command> Kommando
	  angeben.  Auf die anderen Optionen trifft das nur bedingt zu:
	  <option>-j</option> darf mit <maketarget>installworld</maketarget>
	  nicht benutzt werden.</para>

	<para>Sie haben zum Bauen die folgende Kommandozeile
	  verwendet:</para>

	<screen>&prompt.root; <userinput>make -DNO_PROFILE buildworld</userinput></screen>

	<para>Bei der Installation setzen Sie dann das folgende Kommando
	  ab:</para>

	<screen>&prompt.root; <userinput>make -DNO_PROFILE installworld</userinput></screen>

	<para>W&uuml;rden Sie die Variable bei der Installation weglassen,
	  so w&uuml;rde das System versuchen, die <quote>profiled</quote>
	  Bibliotheken, die aber gar nicht gebaut wurden, zu
	  installieren.</para>
      </note>
    </sect2>

    <sect2 id="post-installworld-updates">
      <title>Aktualisieren der von <command>make installworld</command>
        ausgelassenen Dateien</title>

      <para>Neue oder ge&auml;nderte Konfigurationsdateien aus einigen
        Verzeichnissen, besonders <filename>/etc</filename>,
	<filename>/var</filename> und <filename>/usr</filename> werden bei
	der Installationsprozedur nicht ber&uuml;cksichtigt.</para>

      <para>Sie k&ouml;nnen diese Dateien mit &man.mergemaster.8;
        aktualisieren.  Alternativ k&ouml;nnen Sie das auch manuell
	durchf&uuml;hren, obwohl wir diesen Weg nicht empfehlen.  Egal
	welchen Weg Sie beschreiten, sichern Sie vorher den Inhalt von
	<filename>/etc</filename> f&uuml;r den Fall, dass etwas schief
	geht.</para>

      <sect3 id="mergemaster">
        <sect3info>
	  <authorgroup>
	    <author>
	      <firstname>Tom</firstname>
	      <surname>Rhodes</surname>
	      <contrib>Beigetragen von </contrib>
	    </author>
	  </authorgroup>
        </sect3info>
	<title><command>mergemaster</command></title>
        <indexterm><primary><command>mergemaster</command></primary></indexterm>

	<para>Das Bourne-Shell Skript &man.mergemaster.8; hilft Ihnen dabei,
	  die Unterschiede zwischen den Konfigurationsdateien in
	  <filename>/etc</filename> und denen im Quellbaum unter
	  <filename>/usr/src/etc</filename> zu finden.
	  <command>mergemaster</command> ist der empfohlene Weg, Ihre
	  Systemkonfiguration mit dem Quellbaum abzugleichen.</para>

	<para>Rufen Sie <command>mergemaster</command> einfach auf und
	  schauen Sie zu.  Ausgehend von <filename>/</filename> wird
	  <command>mergemaster</command> einen virtuellen Root-Baum
	  aufbauen und darin die neuen Konfigurationsdateien ablegen.
	  Diese Dateien werden dann mit den auf Ihrem System installierten
	  verglichen.  Unterschiede zwischen den Dateien werden im
	  &man.diff.1;-Format dargestellt.  Neue oder ge&auml;nderte Zeilen
	  werden mit <option>+</option> gekennzeichnet.  Zeilen die
	  gel&ouml;scht oder ersetzt werden, sind mit einem
	  <option>-</option> gekennzeichnet.  Das Anzeigeformat wird in
	  &man.diff.1; genauer erkl&auml;rt.</para>

	<para>&man.mergemaster.8; zeigt Ihnen jede ge&auml;nderte Datei an
	  und Sie haben die Wahl, die neue Datei (in
	  <command>mergemaster</command> wird sie tempor&auml;re Datei
	  genannt) zu l&ouml;schen, sie unver&auml;ndert zu installieren,
	  den Inhalt der neuen Datei mit dem Inhalt der alten Datei
	  abzugleichen, oder die &man.diff.1; Ausgabe noch einmal zu
	  sehen.  Sie k&ouml;nnen die aktuelle Datei auch
	  &uuml;berspringen, sie wird dann noch einmal angezeigt, nachdem
	  alle anderen Dateien abgearbeitet wurden.  Sie erhalten Hilfe,
	  wenn Sie bei der Eingabeaufforderung von
	  <command>mergemaster</command> ein <keycap>?</keycap>
	  eingeben.</para>

	<para>Wenn Sie die tempor&auml;re Datei l&ouml;schen, geht
	  <command>mergemaster</command> davon aus, dass Sie Ihre
	  aktuelle Datei behalten m&ouml;chten.  W&auml;hlen Sie die Option
	  bitte nur dann, wenn Sie keinen Grund sehen, die aktuelle Datei
	  zu &auml;ndern.</para>

	<para>Wenn Sie die tempor&auml;re Datei installieren, wird Ihre
	  aktuelle Datei mit der neuen Datei &uuml;berschrieben.  Sie
	  sollten alle unver&auml;nderten Konfigurationsdateien auf diese
	  Weise aktualisieren.</para>

	<para>Wenn Sie sich entschlie&szlig;en den Inhalt beider Dateien
	  abzugleichen, wird ein Texteditor aufgerufen, indem Sie beide
	  Dateien nebeneinander betrachten k&ouml;nnen.  Mit der Taste
	  <keycap>l</keycap> &uuml;bernehmen Sie die aktuelle Zeile der
	  links dargestellten Datei, mit der Taste <keycap>r</keycap>
	  &uuml;bernehmen Sie die Zeile der rechts dargestellten Datei.
	  Das Ergebnis ist eine Datei, die aus Teilen der beiden
	  urspr&uuml;nglichen Dateien besteht und installiert werden kann.
	  Dieses Verfahren wird gew&ouml;hnlich bei ver&auml;nderten
	  Dateien genutzt.</para>

	<para>Haben Sie sich entschieden die Differenzen noch einmal
	  anzuzeigen, zeigt Ihnen &man.mergemaster.8; dieselbe Ausgabe, die
	  Sie gesehen haben, bevor die Eingabeaufforderung ausgegeben
	  wurde.</para>

	<para>Wenn &man.mergemaster.8; alle Systemdateien abgearbeitet hat,
	  werden weitere Optionen abgefragt.  Sie werden unter
	  Umst&auml;nden gefragt, ob Sie die Passwort-Datei neu bauen
	  lassen wollen.  Am Ende haben Sie die M&ouml;glichkeit, den Rest
	  der tempor&auml;ren Dateien zu l&ouml;schen.</para>
      </sect3>

      <sect3>
	<title>Manueller Abgleich der Konfigurationsdateien</title>

	<para>Wenn Sie den Abgleich lieber selbst ausf&uuml;hren wollen,
	  beachten Sie bitte, dass Sie nicht einfach die Dateien aus
	  <filename>/usr/src/etc</filename> nach <filename>/etc</filename>
	  kopieren k&ouml;nnen.  Einige dieser Dateien m&uuml;ssen zuerst
	  <emphasis>installiert</emphasis> werden, bevor sie benutzt werden
	  k&ouml;nnen.  Das liegt daran, dass
	  <filename>/usr/src/etc</filename> keine exakte Kopie von
	  <filename>/etc</filename> ist.  Zudem gibt es Dateien, die sich
	  in <filename>/etc</filename> befinden aber nicht in
	  <filename>/usr/src/etc</filename>.</para>

	<para>Wenn Sie, wie empfohlen, <command>mergemaster</command>
	  benutzen, k&ouml;nnen Sie direkt in den n&auml;chsten
	  <link linkend="updating-upgrading-rebooting">Abschnitt</link>
	  wechseln.</para>

	<para>Am einfachsten ist es, wenn Sie die neuen Dateien in ein
	  tempor&auml;res Verzeichnis installieren und sie nacheinander auf
	  Differenzen zu den bestehenden Dateien durchsehen.</para>

	<warning>
	  <title>Sichern Sie die Inhalte von <filename>/etc</filename></title>

	  <para>Obwohl bei dieser Prozedur keine Dateien in
	    <filename>/etc</filename> automatisch ver&auml;ndert werden,
	    sollten Sie dessen Inhalt an einen sicheren Ort
	    kopieren:</para>

	    <screen>&prompt.root; <userinput>cp -Rp /etc /etc.old</userinput></screen>

	    <para>Mit <option>-R</option> wird rekursiv kopiert und
	      <option>-p</option> erh&auml;lt die Attribute der kopierten
	      Dateien, wie Zugriffszeiten und Eigent&uuml;mer.</para>
	</warning>

	<para>Sie m&uuml;ssen die neuen Dateien in einem tempor&auml;ren
	  Verzeichnis installieren.  <filename>/var/tmp/root</filename> ist
	  eine gute Wahl f&uuml;r das tempor&auml;re Verzeichnis, in dem
	  auch noch einige Unterverzeichnisse angelegt werden
	  m&uuml;ssen.</para>

        <screen>&prompt.root; <userinput>mkdir /var/tmp/root</userinput>
&prompt.root; <userinput>cd /usr/src/etc</userinput>
&prompt.root; <userinput>make DESTDIR=/var/tmp/root distrib-dirs distribution</userinput></screen>

	<para>Die obigen Kommandos bauen die n&ouml;tige
	  Verzeichnisstruktur auf und installieren die neuen Dateien in
	  diese Struktur.  Unterhalb von <filename>/var/tmp/root</filename>
	  wurden einige leere Verzeichnisse angelegt, die Sie am besten wie
	  folgt entfernen:</para>

        <screen>&prompt.root; <userinput>cd /var/tmp/root</userinput>
&prompt.root; <userinput>find -d . -type d | xargs rmdir 2&gt;/dev/null</userinput></screen>

	<para>Im obigen Beispiel wurde die Fehlerausgabe nach
	  <filename>/dev/null</filename> umgeleitet, um die Warnungen
	  &uuml;ber nicht leere Verzeichnisse zu unterdr&uuml;cken.</para>

	<para><filename>/var/tmp/root</filename> enth&auml;lt nun alle
	  Dateien, die unterhalb von <filename>/</filename> installiert
	  werden m&uuml;ssen.  Sie m&uuml;ssen nun jede dieser Dateien mit
	  den schon existierenden Dateien vergleichen.</para>

	<para>Einige der installierten Dateien unter
	  <filename>/var/tmp/root</filename> beginnen mit einem
	  <quote>.</quote>.
	  Als dieses Kapitel verfasst wurde, waren das nur die
	  Startdateien f&uuml;r die Shells in
	  <filename>/var/tmp/root/</filename> und
	  <filename>/var/tmp/root/root/</filename>.  Abh&auml;ngig davon,
	  wann Sie dieses Handbuch lesen, k&ouml;nnen mehr Dateien dieser
	  Art existieren.  Verwenden Sie <command>ls -a</command> um
	  sicherzustellen, dass Sie alle derartigen Dateien
	  finden.</para>

	<para>Benutzen Sie &man.diff.1; um Unterschiede zwischen zwei
	  Dateien festzustellen:</para>

        <screen>&prompt.root; <userinput>diff /etc/shells /var/tmp/root/etc/shells</userinput></screen>

	<para>Das obige Kommando zeigt Ihnen die Unterschiede zwischen der
	  installierten Version von <filename>/etc/shells</filename> und
	  der neuen Version in <filename>/var/tmp/root/etc/shells</filename>.
	  Entscheiden Sie anhand der Unterschiede, ob
	  Sie beide Dateien abgleichen oder die neue Version &uuml;ber die
	  alte kopieren wollen.</para>

	<tip>
	  <title>Versehen Sie das tempor&auml;re Verzeichnis mit einem
	    Zeitstempel</title>

	  <para>Wenn Sie das System oft neu bauen, m&uuml;ssen Sie
	    <filename>/etc</filename> genauso oft aktualisieren.  Dies kann
	    mit der Zeit sehr l&auml;stig werden.</para>

	  <para>Sie k&ouml;nnen das Verfahren beschleunigen, wenn Sie sich
	    eine Kopie der Dateien behalten, die Sie zuletzt nach
	    <filename>/etc</filename> installiert haben.  Das folgende
	    Verfahren zeigt Ihnen, wie das geht.</para>

	  <procedure>
	    <step>
	      <para>Folgen Sie der normalen Prozedur um das System zu
	        bauen.  Wenn Sie <filename>/etc</filename> und die anderen
		Verzeichnisse aktualisieren wollen, geben Sie dem
		tempor&auml;ren Verzeichnis einen Namen, der das aktuelle
		Datum enth&auml;lt.  Wenn Sie dies zum Beispiel am
		14.&nbsp;Februar 1998 durchf&uuml;hrten, h&auml;tten Sie die
		folgenden Kommandos abgesetzt:</para>

	      <screen>&prompt.root; <userinput>mkdir /var/tmp/root-19980214</userinput>
&prompt.root; <userinput>cd /usr/src/etc</userinput>
&prompt.root; <userinput>make DESTDIR=/var/tmp/root-19980214 \
    distrib-dirs distribution</userinput></screen>
	    </step>

	    <step>
	      <para>Gleichen Sie die &Auml;nderungen entsprechend der
		Anleitung von oben ab.</para>

	      <para>Wenn Sie fertig sind, entfernen Sie das Verzeichnis
		<filename>/var/tmp/root-19980214</filename>
		<emphasis>nicht</emphasis>.</para>
	    </step>

	    <step>
	      <para>Wenn Sie nun neue Quellen heruntergeladen und gebaut
	        haben, folgen Sie bitte Schritt 1.  Wenn Sie zwischen den
		Updates eine Woche gewartet haben, haben Sie nun ein
		Verzeichnis mit dem Namen
		<filename>/var/tmp/root-19980221</filename>.</para>
	    </step>

	    <step>
	      <para>Sie k&ouml;nnen nun die Unterschiede, die sich in einer
		Woche ergeben haben, sehen, indem Sie &man.diff.1; rekursiv
		anwenden:</para>

	      <screen>&prompt.root; <userinput>cd /var/tmp</userinput>
&prompt.root; <userinput>diff -r root-19980214 root-19980221</userinput></screen>

	      <para>&Uuml;blicherweise sind die Differenzen, die Sie jetzt
	        sehen, kleiner als die Differenzen zwischen
		<filename>/var/tmp/root-19980221/etc</filename> und
		<filename>/etc</filename>.  Da die angezeigten Differenzen
		kleiner sind, ist es jetzt einfacher den Abgleich der
		Dateien durchzuf&uuml;hren.</para>
	    </step>

	    <step>
	      <para>Sie k&ouml;nnen nun das &auml;lteste der beiden
	        <filename>/var/tmp/root-*</filename> Verzeichnisse
	        entfernen:</para>

	      <screen>&prompt.root; <userinput>rm -rf /var/tmp/root-19980214</userinput></screen>
	    </step>

	    <step>
	      <para>Wiederholen Sie diesen Prozess jedes Mal wenn Sie
		Dateien in <filename>/etc</filename> abgleichen
		m&uuml;ssen.</para>
	    </step>
	  </procedure>

	  <para>Mit &man.date.1; k&ouml;nnen Sie den Verzeichnisnamen
	    automatisch erzeugen:</para>

	  <screen>&prompt.root; <userinput>mkdir /var/tmp/root-`date "+%Y%m%d"`</userinput></screen>
	</tip>
      </sect3>
    </sect2>

    <sect2 id="updating-upgrading-rebooting">
      <title>Das System neu starten</title>

      <para>Sie sind nun am Ende der Prozedur angelangt.  Nachdem Sie sich
        davon &uuml;berzeugt haben, dass Ihr System funktioniert,
        starten Sie Ihr System mit &man.shutdown.8; neu:</para>

      <screen>&prompt.root; <userinput>shutdown -r now</userinput></screen>
    </sect2>

    <sect2>
      <title>Ende</title>

      <para>Herzlichen Gl&uuml;ckwunsch!  Sie haben gerade erfolgreich Ihr
        &os; System aktualisiert.</para>

      <para>Es ist &uuml;brigens leicht einen Teil des Systems
        wiederherzustellen, f&uuml;r den Fall, dass Ihnen ein kleiner
	Fehler unterlaufen ist.  Wenn Sie beispielsweise w&auml;hrend des
	Updates oder Abgleichs <filename>/etc/magic</filename> aus Versehen
	gel&ouml;scht haben, wird &man.file.1; nicht mehr funktionieren.
	In diesem Fall k&ouml;nnen Sie das Problem mit dem folgenden
	Kommando beheben:</para>

	<screen>&prompt.root; <userinput>cd /usr/src/usr.bin/file</userinput>
&prompt.root; <userinput>make all install</userinput></screen>
    </sect2>

    <sect2 id="updating-questions">
      <title>Fragen</title>

      <qandaset>
	<qandaentry>
	  <question>
	    <para>Muss ich wirklich immer alles neu bauen, wenn sich
	      etwas ge&auml;ndert hat?</para>
	  </question>

	  <answer>
	    <para>Darauf gibt es keine einfache Antwort.  Was zu tun ist,
	      h&auml;ngt von den &Auml;nderungen ab.  Es lohnt
	      wahrscheinlich nicht, alles neu zu bauen, wenn sich bei einem
	      <application>CVSup</application>-Lauf nur die folgenden
	      Dateien ge&auml;ndert haben:</para>

	    <screen><filename>src/games/cribbage/instr.c</filename>
<filename>src/games/sail/pl_main.c</filename>
<filename>src/release/sysinstall/config.c</filename>
<filename>src/release/sysinstall/media.c</filename>
<filename>src/share/mk/bsd.port.mk</filename></screen>

	    <para>In diesem Fall k&ouml;nnen Sie in die entsprechenden
	      Unterverzeichnisse wechseln und dort <command>make all
	      install</command> ausf&uuml;hren.  Wenn sich allerdings etwas
	      Wichtiges, wie <filename>src/lib/libc/stdlib</filename>,
	      ge&auml;ndert hat, sollten Sie die Welt oder
	      mindestens die statisch gelinkten Teile des Systems (sowie
	      Ihre statisch gelinkten Erg&auml;nzungen) neu bauen.</para>

	    <para>Letztendlich ist das Ihre Entscheidung.  Sie sind
	      vielleicht damit zufrieden, das System alle zwei Wochen neu
	      zu bauen und in der Zwischenzeit die anfallenden
	      &Auml;nderungen zu sammeln.  Wenn Sie sich zutrauen, alle
	      Abh&auml;ngigkeiten zu erkennen, bauen Sie vielleicht auch
	      nur die ge&auml;nderten Sachen neu.</para>

	    <para>Das h&auml;ngt nat&uuml;rlich auch noch davon ab, wie oft
	      Sie ein Update durchf&uuml;hren wollen und ob Sie &os.stable;
	      oder &os.current; benutzen.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Der Bau bricht mit vielen
	      <errorname>Signal 11</errorname>-Fehlern (oder anderen
	      Signalnummern) ab.  Was ist da passiert?</para>
	  </question>
	  <indexterm><primary>Signal 11</primary></indexterm>

	  <answer>
	    <para>Normalerweise zeigen diese Meldungen Hardwarefehler an.
	      Ein Neubau der Welt ist ein guter Belastungstest f&uuml;r
	      Ihre Hardware und zeigt oft Probleme mit dem Speicher auf.
	      Dies &auml;u&szlig;ert sich darin, dass der Kompiler
	      mit dem Erhalt von seltsamen Signalen abbricht.</para>

	    <para>Es liegt garantiert ein Hardwarefehler vor, wenn ein
	      neuer &Uuml;bersetzungslauf an einer anderen Stelle
	      abbricht.</para>

	    <para>In diesem Fall k&ouml;nnen Sie nur einzelne Komponenten
	      Ihres Systems tauschen, um zu bestimmen, welche Komponente den
	      Fehler verursacht.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Kann ich <filename>/usr/obj</filename> l&ouml;schen, wenn
	      ich fertig bin?</para>
	  </question>

	  <answer>
	    <para>Kurze Antwort: Ja.</para>

	    <para>In <filename>/usr/obj</filename> werden alle Dateien
	      abgelegt, die w&auml;hrend der &Uuml;bersetzungsphase erstellt
	      wurden.  Dieses Verzeichnis wird in einem der ersten Schritte
	      der Bauprozedur entfernt.  Es macht daher
	      wenig Sinn, dieses Verzeichnis zu behalten und Sie setzen
	      eine Menge Plattenplatz, momentan ungef&auml;hr 2&nbsp;GB,
	      frei, wenn Sie es l&ouml;schen.</para>

	    <para>Wenn Sie allerdings genau wissen, was Sie tun, k&ouml;nnen
	      Sie diesen Schritt bei <command>make buildworld</command>
	      auslassen.  Nachfolgende Bauprozeduren werden dadurch erheblich
	      schneller, da die meisten Quelldateien nicht mehr neu
	      &uuml;bersetzt werden.  Daf&uuml;r k&ouml;nnen aber subtile
	      Abh&auml;ngigkeitsprobleme entstehen, die dazu f&uuml;hren,
	      dass der Bau auf merkw&uuml;rdige Weise abbrechen kann.
	      Dies f&uuml;hrt h&auml;ufig zu unn&ouml;tigen Diskussionen auf
	      den &os; Mailinglisten, wenn sich jemand &uuml;ber einen
	      kaputten Bau beschwert, aber nicht sieht, dass er
	      Probleme hat, weil er eine Abk&uuml;rzung genommen hat.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Kann ein abgebrochener Bau weitergef&uuml;hrt
	      werden?</para>
	  </question>

	  <answer>
	    <para>Das h&auml;ngt davon ab, wieweit der Bauprozess
	      fortgeschritten ist.</para>

	    <para><emphasis>&Uuml;blicherweise</emphasis> werden
	      essentielle Werkzeuge, wie &man.gcc.1; und &man.make.1;,
	      und die Systembibliotheken w&auml;hrend des Bauprozesses
	      neu erstellt (dies ist aber keine allgemein g&uuml;ltige
	      Regel).  Die neu erstellen Werkzeuge und Bibliotheken werden
	      dann benutzt, um sich selbst noch einmal zu bauen, und wieder
	      installiert.  Anschlie&szlig;end wird das Gesamtsystem mit
	      den neu erstellten Systemdateien gebaut.</para>

	    <para>Wenn Sie sich im letzten Schritt befinden und Sie wissen,
	      dass Sie dort sind, weil Sie durch die Ausgaben, die Sie
	      ja sichern, der Bauprozedur gesehen haben, k&ouml;nnen Sie
	      mit ziemlicher Sicherheit den Bau weiterf&uuml;hren:</para>

	    <screen><emphasis>&hellip; Fehler beheben &hellip;</emphasis>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make -DNO_CLEAN all</userinput></screen>

	    <para>Diese Variablen verhindern,
	      dass <command>make buildworld</command> die vorher erstellten
	      Dateien l&ouml;scht.</para>

	    <para>Das Sie sich im letzten Schritt der Bauprozedur
	      befinden, erkennen Sie daran, dass Sie in der Ausgabe die
	      folgenden Zeilen finden:</para>

	      <screen>--------------------------------------------------------------
Building everything..
--------------------------------------------------------------</screen>

	    <para>Wenn Sie diese Meldung nicht finden, oder sich nicht sicher
	      sind, dann ist es besser, noch einmal ganz von Vorne
	      anzufangen.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Wie kann ich den Bauprozesss beschleunigen?</para>
          </question>

          <answer>
	    <itemizedlist>
	      <listitem>
		<para>Bauen Sie im Single-User-Modus.</para>
	      </listitem>

	      <listitem>
		<para>Legen Sie <filename>/usr/src</filename> und
		  <filename>/usr/obj</filename> in getrennte Dateisysteme auf
		  unterschiedliche Festplatten.  Benutzen Sie nach
		  M&ouml;glichkeit auch getrennte Platten-Controller.</para>
	      </listitem>

	      <listitem>
		<para>Noch besser ist es, diese Dateisysteme auf mehrere
		  Festplatten mit &man.ccd.4; zu verteilen.</para>
	      </listitem>

	      <listitem>
		<para>Bauen Sie die <quote>profiled</quote>-Bibliotheken,
		  die Sie wahrscheinlich sowieso nicht brauchen, nicht.
		  <filename>/etc/make.conf</filename> sollte dazu
		  <literal>NO_PROFILE=true</literal> enthalten.</para>
	      </listitem>

	      <listitem>
		<para>Setzen Sie die <makevar>CFLAGS</makevar> in
		  <filename>/etc/make.conf</filename> auf <option>-O
		    -pipe</option>.  Die Optimierungsstufe
		  <option>-O2</option> ist deutlich langsamer und die
		  Performance-Unterschiede zwischen <option>-O</option> und
		  <option>-O2</option> sind vernachl&auml;ssigbar klein.
		  <option>-pipe</option> veranlasst den Kompiler Pipes
		  anstelle von Dateien f&uuml;r die Kommunikation zu
		  benutzen.  Dies spart einige Plattenzugriffe, geht aber
		  auf Kosten des Speichers.</para>
	      </listitem>

	      <listitem>
		<para>Benutzen Sie
		  <option>-j<replaceable>n</replaceable></option>, um
		  mehrere Prozesse parallel laufen zu lassen.
		  Normalerweise beschleunigt dies den Bauprozess
		  unabh&auml;ngig davon, ob Sie ein Einprozessor oder
		  Mehrprozessor System einsetzen.</para>
	      </listitem>

	      <listitem>
		<para>Sie k&ouml;nnen das Dateisystem
		  <filename>/usr/src</filename> mit der Option
		  <option>noatime</option> einh&auml;ngen.  Dies
		  verhindert, dass die Zugriffszeiten der Dateien
		  aktualisiert werden (eine Information, die Sie vielleicht
		  gar nicht brauchen).</para>

		<screen>&prompt.root; <userinput>mount -u -o noatime /usr/src</userinput></screen>

		<warning>
		  <para>Das Beispiel geht davon aus, dass sich
		    <filename>/usr/src</filename> auf einem separaten
		    Dateisystem befindet.  Wenn das nicht der Fall ist,
		    weil das Verzeichnis beispielsweise Teil des
		    <filename>/usr</filename> Dateisystems ist,
		    m&uuml;ssen Sie anstelle von
		    <filename>/usr/src</filename> den Mountpoint des
		    Dateisystems angeben.</para>
		</warning>
	      </listitem>

	      <listitem>
		<para>Das Dateisystem, in dem sich
		  <filename>/usr/obj</filename> befindet, kann mit der
		  Option <option>async</option> eingehangen werden.  Dies
		  bewirkt, dass Schreibzugriffe auf die Platte
		  asynchron stattfinden, das hei&szlig;t ein Schreibzugriff
		  ist sofort beendet, die Daten werden allerdings erst einige
		  Sekunden sp&auml;ter geschrieben.  Dadurch k&ouml;nnen
		  Schreibzugriffe zusammengefasst werden, was einen
		  erheblichen Geschwindigkeitszuwachs mit sich bringen
		  kann.</para>

		<warning>
		  <para>Beachten Sie, dass dies Ihr Dateisystem
		    anf&auml;lliger f&uuml;r Fehler macht.  Im Fall eines
		    Stromausfalls besteht eine erh&ouml;hte
		    Wahrscheinlichkeit, dass das Dateisystem beim
		    Start der Maschine zerst&ouml;rt ist.</para>

		  <para>Wenn sich <filename>/usr/obj</filename> auf einem
		    extra Dateisystem befindet, ist das kein Problem.  Wenn
		    sich allerdings auf diesem Dateisystem noch andere
		    wertvolle Daten befinden, stellen Sie sicher, dass
		    Sie aktuelle Sicherungen besitzen.</para>
		</warning>

		<screen>&prompt.root; <userinput>mount -u -o async /usr/obj</userinput></screen>

		<warning>
		  <para>Ersetzen Sie <filename>/usr/obj</filename> durch
		    den Mountpoint des entsprechenden Dateisystems, wenn es
		    sich nicht auf einem eigenen Dateisystem
		    befindet.</para>
		</warning>
	      </listitem>
	    </itemizedlist>
	  </answer>
	</qandaentry>

        <qandaentry>
          <question>
	    <para>Was mache ich, wenn etwas nicht funktioniert?</para>
          </question>

          <answer>
	    <para>Stellen Sie sicher, dass sich in Ihrer Umgebung
	      keine Reste eines vorherigen Baus befinden.  Das geht ganz
	      einfach:</para>

            <screen>&prompt.root; <userinput>chflags -R noschg /usr/obj/usr</userinput>
&prompt.root; <userinput>rm -rf /usr/obj/usr</userinput>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make cleandir</userinput>
&prompt.root; <userinput>make cleandir</userinput></screen>

	    <para>Ja, <command>make cleandir</command> muss wirklich
	      zweimal aufgerufen werden.</para>

	    <para>Nachdem Sie aufger&auml;umt haben, starten Sie den
	      Bauprozess wieder mit <command>make
	        buildworld</command>.</para>

	    <para>Wenn Sie immer noch Probleme haben, schicken Sie die
	      Fehlermeldungen und die Ausgabe von <command>uname
	        -a</command> an die Mailingliste &a.de.questions;.  Bereiten
	      Sie sich darauf vor, weitere Fragen zu Ihrer Umgebung zu
	      beantworten.</para>
          </answer>
        </qandaentry>
      </qandaset>
    </sect2>
  </sect1>

  <sect1 id="make-delete-old">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Anton</firstname>
	  <surname>Shterenlikht</surname>
	  <contrib>Basiert auf Notizen von </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title>Veraltete Dateien, Verzeichnisse und Bibliotheken
      l&ouml;schen</title>
    <indexterm>
      <primary>Veraltete Dateien, Verzeichnisse und Bibliotheken
	l&ouml;schen</primary>
    </indexterm>

    <para>Aufgrund der st&auml;ndigen Weiterentwicklung von &os; kann es
      dazu kommen, dass Dateien (und deren Inhalte) obsolet werden, weil
      deren Funktionalit&auml;t entweder in anderen Dateien implementiert
      wurde, sich die Versionsnummer der Bibliothek ge&auml;ndert hat
      oder deren Funktion nicht mehr ben&ouml;tigt wird.  Dies kann
      sowohl Dateien und Verzeichnis, aber auch Bibliotheken betreffen.
      Diese veralteten Dateien sollten daher entfernt werden, bevor Sie
      Ihr System aktualisieren.  Der Vorteil f&uuml;r den Benutzer ist
      darin zu sehen, dass dessen System (sowie dessen Backup) von
      nicht mehr ben&ouml;tigten Dateien gereinigt wird.  Falls die
      obsolete Bibliothek Sicherheits- oder Stabilit&auml;tsprobleme
      aufweist, sollte das System ebenfalls aktualisiert werden, um
      Ihr System sicher zu halten und/oder durch die fehlerhafte
      Bibliothek verursachte Systemabst&uuml;rze zu vermeiden.  Veraltete
      Dateien, Verzeichnisse und Bibliotheken sind in der Datei
      <filename>/usr/src/ObsoleteFiles.inc</filename> aufgelistet.  Die
      folgenden Anweisungen sollen Ihnen dabei helfen, diese Dateien
      w&auml;hrend der Systemaktualisierung zu entfernen.</para>

    <para>Im Folgenden wird angenommen, dass Sie den Anweisungen von
      <xref linkend="canonical-build"> folgen.  Nachdem Sie
      <command>make <maketarget>installworld</maketarget></command>
      sowie <command>mergemaster</command> erfolgreich ausgef&uuml;hrt
      haben, sollten Sie Ihr System auf veraltete Dateien und
      Bibliotheken hin &uuml;berpr&uuml;fen:</para>

    <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make check-old</userinput></screen>

    <para>Werden dabei veraltete Dateien gefunden, k&ouml;nnen diese
      im n&auml;chsten Schritt entfernt werden:</para>

    <screen>&prompt.root; <userinput>make delete-old</userinput></screen>

    <tip>
      <para>Weitere interessante Targets finden sich in der Datei
	<filename>/usr/src/Makefile</filename>.</para>
    </tip>

    <para>Bei jeder Datei wird nachgefragt, ob Sie diese wirklich
      l&ouml;schen wollen.  Es ist aber auch m&ouml;glich, alle
      Dateien automatisch l&ouml;schen zu lassen.  Dies erreichen Sie,
      indem Sie die Umgebungsvariable
      <makevar>BATCH_DELETE_OLD_FILES</makevar> entsprechend
      setzen:</para>

    <screen>&prompt.root; <userinput>make -DBATCH_DELETE_OLD_FILES delete-old</userinput></screen>

    <para>Alternativ k&ouml;nnen Sie auch den folgenen Befehl
      einsetzen (und jeweils die Antwort <command>yes</command>
      an die einzelnen Abfragen weiterreichen):</para>

    <screen>&prompt.root; <userinput>yes|make delete-old</userinput></screen>

    <warning>
      <title>Warnung</title>
	<para>Das L&ouml;schen veralteter Dateien kann dazu f&uuml;hren,
	  dass Programme, die auf diese Dateien angewiesen sind, nicht mehr
	  funktionieren.  Dies gilt insbesondere f&uuml;r veraltete
	  Bibliotheken.  In den meisten F&auml;llen ist es dann notwendig,
	  Programme, Ports und Bibliotheken, welche die veraltete
	  Bibliothek verwenden, neu zu bauen, bevor Sie den Befehl
	  <command>make
	  <maketarget>delete-old-libs</maketarget></command>
	  ausf&uuml;hren.</para>
    </warning>

    <para>Die Ports-Sammlung enth&auml;t Werkzeuge, die Ihnen beim
      Pr&uuml;fen von Bibliothek-Abh&auml;ngigkeiten helfen k&ouml;nnen:
      <filename role="package">sysutils/libchk</filename>
      sowie <filename
      role="package">sysutils/bsdadminscripts</filename>.</para>

    <para>Veraltete Bibliotheken k&ouml;nnen zu Konflikten mit neueren
      Bibliotheken f&uuml;hren und beispielsweise folgende
      Meldungen verursachen:</para>

    <screen>/usr/bin/ld: warning: libz.so.4, needed by /usr/local/lib/libtiff.so, may conflict with libz.so.5
/usr/bin/ld: warning: librpcsvc.so.4, needed by /usr/local/lib/libXext.so, may conflict with librpcsvc.so.5</screen>

    <para>Um diese Probleme zu l&ouml;sen, m&uuml;ssen Sie zuerst
      herausfinden, welcher Port die Bibliothek installiert hat:</para>

    <screen>&prompt.root; <userinput>pkg_info -W  /usr/local/lib/libtiff.so</userinput>
/usr/local/lib/libtiff.so was installed by package tiff-3.9.4
&prompt.root; <userinput>pkg_info -W /usr/local/lib/libXext.so</userinput>
/usr/local/lib/libXext.so was installed by package libXext-1.1.1,1</screen>

    <para>Danach deinstallieren Sie den Port und bauen ihn neu, um ihn
      danach erneut zu installieren.  Dieser Vorgang kann durch den
      Einsatz der Werkzeuge <filename
      role="package">ports-mgmt/portmaster</filename> oder <filename
      role="package">ports-mgmt/portupgrade</filename> automatisiert
      werden.  Nachdem Sie alle Ports erfolgreich neu gebaut haben
      (und Sie daher keine veralteten Bibliotheken mehr verwenden)
      k&ouml;nnen Sie die veralteten Bibliotheken endg&uuml;ltig
      entfernen:</para>

    <screen>&prompt.root; <userinput>make delete-old-libs</userinput></screen>
  </sect1>

  <sect1 id="small-lan">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Mike</firstname>
	  <surname>Meyer</surname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Installation mehrerer Maschinen</title>

    <para>Wenn Sie mehrere Maschinen besitzen, die Sie alle auf dem
      gleichen Stand halten wollen, ist es eine Verschwendung von
      Ressourcen, die Quellen auf jeder Maschine vorzuhalten und zu
      &uuml;bersetzen.  Die L&ouml;sung dazu ist, eine Maschine den
      Gro&szlig;teil der Arbeit durchf&uuml;hren zu lassen und den anderen
      Maschinen das Ergebnis mit NFS zur Verf&uuml;gung zu stellen.  Dieser
      Abschnitt zeigt Ihnen wie das geht.</para>

    <sect2 id="small-lan-preliminaries">
      <title>Voraussetzungen</title>

      <para>Stellen Sie zuerst eine Liste der Maschinen zusammen, die auf
        demselben Stand sein sollen.  Wir nennen diese Maschinen die
	<emphasis>Baugruppe</emphasis>.  Jede dieser Maschinen kann mit
	einem eigenen Kernel laufen, doch sind die Programme des Userlands
	auf allen Maschinen gleich.  W&auml;hlen Sie aus der Baugruppe eine
	Maschine aus, auf der der Bau durchgef&uuml;hrt wird, den
	<emphasis>Bau-Master</emphasis>.  Dies sollte eine Maschine sein,
	die &uuml;ber die n&ouml;tigen Ressourcen f&uuml;r
	<command>make buildworld</command> und
	<command>make installworld</command> verf&uuml;gt.
	Sie brauchen auch eine
	<emphasis>Testmaschine</emphasis>, auf der Sie die Updates testen,
	bevor Sie sie in Produktion installieren.  Dies sollte eine
	Maschine, eventuell der Bau-Master, sein, die &uuml;ber einen
	l&auml;ngeren Zeitraum nicht zur Verf&uuml;gung stehen kann.</para>

      <para>Alle Maschinen der Baugruppe m&uuml;ssen
        <filename>/usr/obj</filename> und <filename>/usr/src</filename> von
	derselben Maschine an gleichem Ort einh&auml;ngen.  Idealerweise
	befinden sich die beiden Verzeichnisse auf dem Bau-Master auf
	verschiedenen Festplatten, sie k&ouml;nnen allerdings auch auf dem
	Bau-Master &uuml;ber NFS zur Verf&uuml;gung gestellt werden.  Wenn
	Sie mehrere Baugruppen haben, sollte sich
	<filename>/usr/src</filename> auf einem Bau-Master befinden und
	&uuml;ber NFS f&uuml;r den Rest der Maschinen zur Verf&uuml;gung
	gestellt werden.</para>

      <para>Stellen Sie sicher, dass
        <filename>/etc/make.conf</filename> und
        <filename>/etc/src.conf</filename> auf allen Maschinen einer
	Baugruppe mit der Datei des Bau-Masters &uuml;bereinstimmt.  Der
	Bau-Master muss jeden Teil des Systems bauen, den irgendeine
	Maschine der Baugruppe ben&ouml;tigt.  Auf dem Bau-Master
	m&uuml;ssen in <filename>/etc/make.conf</filename> alle zu bauenden
	Kernel mit der Variablen <makevar>KERNCONF</makevar> bekannt gegeben
	werden.  Geben Sie dabei den Kernel des Bau-Masters zuerst an.
	F&uuml;r jeden zu bauenden Kernel muss auf dem Bau-Master die
	entsprechende Konfigurationsdatei unter
	<filename>/usr/src/sys/<replaceable>arch</replaceable>/conf</filename>
	abgelegt werden.</para>
    </sect2>

    <sect2 id="small-lan-base-system">
      <title>Installation des Basissystems</title>

      <para>Nach diesen Vorbereitungen k&ouml;nnen Sie mit dem Bau
        beginnen.  Bauen Sie auf dem Bau-Master, wie in <xref
	linkend="make-buildworld"> beschrieben, den Kernel und die Welt,
	installieren Sie aber nichts.  Wechseln Sie auf die Testmaschine
	und installieren Sie den gerade gebauten Kernel.  Wenn diese
	Maschine <filename>/usr/src</filename> und
	<filename>/usr/obj</filename> &uuml;ber NFS bekommt, m&uuml;ssen
	Sie das Netzwerk im Single-User-Modus aktivieren und die beiden
	Dateisysteme einh&auml;ngen.  Am einfachsten ist dies, wenn Sie
	auf der Testmaschine ausgehend vom Mehrbenutzermodus mit
	<command>shutdown now</command> in den Single-User-Modus wechseln.
	Sie k&ouml;nnen dann mit der normalen Prozedur den neuen Kernel
	und das System installieren und anschlie&szlig;end
	<command>mergemaster</command> laufen lassen.  Wenn Sie damit
	fertig sind, k&ouml;nnen Sie die Maschine wieder in den
	Mehrbenutzermodus booten.</para>

      <para>Nachdem Sie sichergestellt haben, dass die Testmaschine
        einwandfrei funktioniert, wiederholen Sie diese Prozedur f&uuml;r
	jede Maschine in der Baugruppe.</para>
    </sect2>

    <sect2 id="small-lan-ports">
      <title>Die Ports-Sammlung</title>

      <para>Dasselbe Verfahren k&ouml;nnen Sie auch f&uuml;r die
        Ports-Sammlung anwenden.  Zuerst m&uuml;ssen alle Maschinen einer
	Baugruppe <filename>/usr/ports</filename> von derselben Maschine
	&uuml;ber NFS zur Verf&uuml;gung gestellt bekommen.  Setzen Sie
	dann ein Verzeichnis f&uuml;r die Quellen auf, das sich alle
	Maschinen teilen.  Dieses Verzeichnis k&ouml;nnen Sie in
	<filename>/etc/make.conf</filename> mit der Variablen
	<makevar>DISTDIR</makevar> angeben.  Das Verzeichnis sollte
	f&uuml;r den Benutzer beschreibbar sein, auf den der Benutzer
	<username>root</username> vom NFS Subsystem abgebildet wird.  Jede
	Maschine sollte noch <makevar>WRKDIRPREFIX</makevar> auf ein
	lokales Bauverzeichnis setzen.  Wenn Sie vorhaben, Pakete zu bauen
	und zu verteilen, sollten Sie <makevar>PACKAGES</makevar> auf ein
	Verzeichnis mit den gleichen Eigenschaften wie
	<makevar>DISTDIR</makevar> setzen.</para>
    </sect2>
  </sect1>
</chapter>
<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->

