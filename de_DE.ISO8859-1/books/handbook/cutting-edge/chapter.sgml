<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde: de-docproj/books/handbook/cutting-edge/chapter.sgml,v 1.76 2005/09/11 08:47:10 jkois Exp $
     basiert auf: 1.219
-->

<chapter id="cutting-edge">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Jim</firstname>
	<surname>Mock</surname>
	<contrib>Umstrukturiert und aktualisiert von </contrib>
      </author>
      <!-- Mar 2000 -->
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Jordan</firstname>
	<surname>Hubbard</surname>
	<contrib>Im Original von </contrib>
      </author>
      <author>
	<firstname>Poul-Henning</firstname>
	<surname>Kamp</surname>
      </author>
      <author>
	<firstname>John</firstname>
	<surname>Polstra</surname>
      </author>
      <author>
	<firstname>Nik</firstname>
	<surname>Clayton</surname>
      </author>
    </authorgroup>
    <!-- with feedback from various others -->
    <authorgroup>
      <author>
	<firstname>Martin</firstname>
	<surname>Heinen</surname>
	<contrib>&Uuml;bersetzt von </contrib>
      </author>
    </authorgroup>
  </chapterinfo>

  <title>Das Neueste und Beste</title>

  <sect1 id="cutting-edge-synopsis">
    <title>&Uuml;bersicht</title>

    <para>&os; wird zwischen einzelnen Releases konstant weiter entwickelt.
      Es gibt mehrere einfache M&ouml;glichkeiten, ein System auf dem
      aktuellen Stand der Entwicklung zu halten.  Seien Sie jedoch gewarnt:
      Die neueste Version ist nicht f&uuml;r jeden geeignet!  Dieses
      Kapitel hilft Ihnen bei der Entscheidung, ob Sie mit dem
      Entwicklungssystem Schritt halten oder ein Release verwenden
      wollen.</para>

    <para>Nachdem Sie dieses Kapitel gelesen haben, werden Sie</para>

    <itemizedlist>
      <listitem>
	<para>den Unterschied der beiden Entwicklerversionen
          &os.stable; und &os.current; kennen,</para>
      </listitem>

      <listitem>
	<para>wissen, wie Sie Ihr System mit
          <application>CVSup</application>, <application>CVS</application>
	  oder <application>CTM</application> aktualisieren.</para>
      </listitem>

      <listitem>
	<para>Wissen, wie Sie das komplette Basissystem
	  mit <command>make buildworld</command> neu bauen und
	  installieren.</para>
      </listitem>
    </itemizedlist>

    <para>Bevor Sie dieses Kapitel lesen, sollten Sie</para>

    <itemizedlist>
      <listitem>
	<para>Ihr Netzwerk richtig konfiguriert haben
	  (<xref linkend="advanced-networking">) und</para>
      </listitem>

      <listitem>
	<para>wissen, wie Sie Software Dritter installieren
	  (<xref linkend="ports">).</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="current-stable">
    <title>&os.current; vs. &os.stable;</title>
    <indexterm><primary>-CURRENT</primary></indexterm>
    <indexterm><primary>-STABLE</primary></indexterm>

    <para>FreeBSD besitzt zwei Entwicklungszweige: &os.current; und
      &os.stable;.  Dieser Abschnitt beschreibt beide Zweige und
      erl&auml;utert, wie Sie Ihr System auf dem aktuellen Stand
      eines Zweiges halten.  Zuerst wird &os.current; vorgestellt, dann
      &os.stable;.</para>

    <sect2 id="current">
      <title>&os.current;</title>

      <para>Beachten Sie im Folgenden, dass &os.current; die Spitze
        der Entwicklung von &os; ist.  Benutzer von &os.current; sollten
	&uuml;ber sehr gute technische F&auml;higkeiten verf&uuml;gen und
	in der Lage sein, schwierige Probleme alleine zu l&ouml;sen.  Wenn
	&os; neu f&uuml;r Sie ist, &uuml;berlegen Sie sich genau, ob Sie
	&os.current; benutzen wollen.</para>

      <sect3>
	<title>Was ist &os.current;?</title>
	<indexterm><primary>Snapshot</primary></indexterm>

	<para>&os.current; besteht aus den neuesten Quellen des
	  FreeBSD-Systems.  Es enth&auml;lt Sachen, an denen gerade
	  gearbeitet wird, experimentelle &Auml;nderungen und
	  &Uuml;bergangsmechanismen, die im n&auml;chsten offiziellen
	  Release der Software enthalten sein k&ouml;nnen oder nicht.
	  Obwohl &os.current; t&auml;glich von vielen Entwicklern gebaut
	  wird, gibt es Zeitr&auml;ume, in denen sich das System nicht
	  bauen l&auml;sst.  Diese Probleme werden so schnell wie
	  m&ouml;glich gel&ouml;st, aber ob Sie mit &os.current;
	  Schiffbruch erleiden oder die gew&uuml;nschten Verbesserungen
	  erhalten, kann von dem Zeitpunkt abh&auml;ngen, an dem Sie sich
	  den Quelltext besorgt haben!</para>
      </sect3>

      <sect3>
	<title>Wer braucht &os.current;?</title>

	<para>&os.current; wird haupts&auml;chlich f&uuml;r 3
	  Interessengruppen zur Verf&uuml;gung gestellt:</para>

	<orderedlist>
	  <listitem>
	    <para>Entwickler, die an einem Teil des Quellbaums arbeiten und
	      daher &uuml;ber die aktuellen Quellen verf&uuml;gen
	      m&uuml;ssen.</para>
	  </listitem>

	  <listitem>
	    <para>Tester, die bereit sind, Zeit in das L&ouml;sen von
	      Problemen zu investieren und sicherstellen, dass
	      &os.current; so stabil wie m&ouml;glich bleibt.  Weiterhin
	      Leute, die Vorschl&auml;ge zu &Auml;nderungen oder der
	      generellen Entwicklung von &os; machen und Patches
	      bereitstellen, um diese Vorschl&auml;ge zu realisieren.</para>
	  </listitem>

	  <listitem>
	    <para>F&uuml;r Leute, die die Entwicklung im Auge behalten
	      wollen, oder die Quellen zu Referenzzwecken (zum Beispiel
	      darin lesen, aber nicht verwenden) benutzen wollen.  Auch diese
	      Gruppe macht Vorschl&auml;ge oder steuert Quellcode
	      bei.</para>
	  </listitem>
	</orderedlist>
      </sect3>

      <sect3>
	<title>Was &os.current; <emphasis>nicht</emphasis> ist!</title>

	<orderedlist>
	  <listitem>
	    <para>Der schnellste Weg, neue Sachen vor dem offiziellen
	      Release auszuprobieren.  Bedenken Sie, dass der erste,
	      der die neuen Sachen ausprobiert, auch der erste ist, der die
	      neuen Fehler findet.</para>
	  </listitem>

	  <listitem>
	    <para>Ein schneller Weg, um an Fehlerbehebungen (engl.
	      <foreignphrase>bug fixes</foreignphrase>) zu kommen.  Jede
	      Version von &os.current; f&uuml;hrt mit gleicher
	      Wahrscheinlichkeit neue Fehler ein, mit der sie alte
	      behebt.</para>
	  </listitem>

	  <listitem>
	    <para>In irgendeiner Form <quote>offiziell
	        unterst&uuml;tzt</quote>.  Wir tun unser Bestes, um Leuten
	      aus den drei <quote>legitimen</quote> Benutzergruppen von
	      &os.current; zu helfen, aber wir <emphasis>haben einfach nicht
	      die Zeit</emphasis>, technische Unterst&uuml;tzung zu
	      erbringen.  Das kommt nicht daher, dass wir kleinliche,
	      gemeine Leute sind, die anderen nicht helfen wollen (wenn
	      wir das w&auml;ren, w&uuml;rden wir &os; nicht machen), wir
	      k&ouml;nnen einfach nicht jeden Tag Hunderte Nachrichten
	      beantworten <emphasis>und</emphasis> an &os; arbeiten!  Vor
	      die Wahl gestellt, &os; zu verbessern oder jede Menge Fragen
	      zu experimentellem Code zu beantworten, haben sich die
	      Entwickler f&uuml;r ersteres entschieden.</para>
	  </listitem>
	</orderedlist>
      </sect3>

      <sect3>
	<title>Benutzen von &os.current;</title>

	<indexterm>
	  <primary>-CURRENT</primary>
	  <secondary>benutzen</secondary>
	</indexterm>
	<orderedlist>
	  <listitem>
	    <para>Es ist <emphasis>essentiell</emphasis>, die Mailinglisten
	      &a.current.name; und &a.cvsall.name; zu lesen.  Wenn Sie
	      &a.current.name; nicht lesen, verpassen Sie die Kommentare
	      anderer &uuml;ber den momentanen Zustand des Systems und rennen
	      demzufolge in viele bekannte Probleme, die schon gel&ouml;st
	      sind.  Noch kritischer ist, dass Sie wichtige
	      Bekanntmachungen verpassen, die erhebliche Auswirkungen
	      auf die Stabilit&auml;t Ihres Systems haben k&ouml;nnen.</para>

	    <para>In der &a.cvsall.name; Mailingliste sehen Sie zu jeder
	      &Auml;nderung das Commit-Log, das Informationen zu
	      m&ouml;glichen Seiteneffekten enth&auml;lt.</para>

	    <para>Um diese Listen zu abonnieren (oder zu lesen)
	      besuchen Sie bitte die Seite &a.mailman.lists.link;.
	      Weitere Informationen erhalten Sie, wenn Sie dort
	      auf die gew&uuml;nschte Liste klicken.</para>
	  </listitem>

	  <listitem>
	    <para>Beschaffen Sie sich die Quellen von einem
	      <link linkend="mirrors">&os;-Spiegel</link>.  Sie haben
	      dazu zwei M&ouml;glichkeiten:</para>

	    <orderedlist>
              <indexterm>
                <primary><command>cvsup</command></primary>
              </indexterm>
              <indexterm>
                <primary><command>cron</command></primary>
              </indexterm>
              <indexterm>
	        <primary>-CURRENT</primary>
		<secondary>mit <application>CVSup</application>
		  synchronisieren</secondary>
	      </indexterm>

	      <listitem>
		<para>Benutzen Sie das Programm
		  <link linkend="cvsup">cvsup</link>
		  mit der Datei <filename>standard-supfile</filename>
		  aus dem Verzeichnis
		  <filename>/usr/share/examples/cvsup</filename>.
		  Dies ist die empfohlene Methode, da Sie die ganzen
		  Quellen nur einmal herunterladen und danach nur noch
		  &Auml;nderungen beziehen.  Viele lassen
		  <command>cvsup</command> aus <command>cron</command>
		  heraus laufen, um ihre Quellen automatisch auf Stand
		  zu bringen.  Sie m&uuml;ssen die obige Sup-Datei
		  anpassen und <link linkend="cvsup">cvsup</link>
		  in Ihrer Umgebung konfigurieren.</para>
	      </listitem>

              <indexterm>
	        <primary>-CURRENT</primary>
		<secondary>mit CTM synchronisieren</secondary>
	      </indexterm>
	      <listitem>
		<para><application><link linkend="ctm">CTM</link></application>
		  kommt in Frage, wenn Sie
		  &uuml;ber eine schlechte Internet-Anbindung (hoher Preis
		  oder nur E-Mail Zugriff) verf&uuml;gen.  Der Umgang mit
		  <application>CTM</application> ist allerdings recht
		  m&uuml;hsam und Sie k&ouml;nnen besch&auml;digte Dateien
		  erhalten.  Daher wird es selten benutzt, was wiederum
		  dazu f&uuml;hrt, dass es &uuml;ber l&auml;ngere Zeit
		  nicht funktioniert.  Wir empfehlen jedem mit einem
		  9600&nbsp;bps oder schnellerem Modem,
		  <application><link linkend="cvsup">CVSup</link></application>
		  zu benutzen.</para>
	      </listitem>
	    </orderedlist>
	  </listitem>

	  <listitem>
	    <para>Wenn Sie die Quellen einsetzen und nicht nur darin
	      lesen wollen, besorgen Sie sich bitte die
	      <emphasis>kompletten</emphasis> Quellen von &os.current; und
	      nicht nur ausgesuchte Teile.  Der Grund hierf&uuml;r ist,
	      dass die verschiedenen Teile der Quellen voneinander
	      abh&auml;ngen.  Es ist ziemlich sicher, dass Sie in
	      Schwierigkeiten geraten, wenn Sie versuchen, nur einen Teil
	      der Quellen zu &uuml;bersetzen.</para>

	    <indexterm>
	      <primary>-CURRENT</primary>
	      <secondary>&uuml;bersetzen</secondary>
	    </indexterm>

	    <para>Sehen Sie sich das <filename>Makefile</filename> in
	      <filename>/usr/src</filename> genau an, bevor Sie
	      &os.current; &uuml;bersetzen.  Wenn Sie
	      &os; das erste Mal aktualisieren, sollten Sie sowohl
	      <link linkend="makeworld">einen Kernel als auch das
		System neu installieren</link>.
	      Lesen Sie bitte die Mailingliste &a.current;
	      und <filename>/usr/src/UPDATING</filename>, um &uuml;ber
	      &Auml;nderungen im Installationsverfahren, die manchmal
	      vor der Einf&uuml;hrung eines neuen Releases notwendig sind,
	      informiert zu sein.</para>
	  </listitem>

	  <listitem>
	    <para>Seien Sie aktiv!  Wenn Sie &os.current; laufen lassen,
	      wollen wir wissen, was Sie dar&uuml;ber denken, besonders
	      wenn Sie Verbesserungsvorschl&auml;ge oder Fehlerbehebungen
	      haben.  Verbesserungsvorschl&auml;ge, die Code enthalten,
	      werden &uuml;brigens begeistert entgegengenommen.</para>
	  </listitem>
	</orderedlist>
      </sect3>
    </sect2>

    <sect2 id="stable">
      <title>&os.stable;</title>

      <sect3>
	<title>Was ist &os.stable;?</title>
	<indexterm><primary>-STABLE</primary></indexterm>

	<para>&os.stable; ist der Entwicklungszweig, auf dem Releases
	  erstellt werden.  Dieser Zweig &auml;ndert sich langsamer als
	  &os.current; und alle &Auml;nderungen hier sollten zuvor in
	  &os.current; ausgetestet sein.  Beachten Sie, dass dies
	  <emphasis>immer noch</emphasis> ein Entwicklungszweig ist und
	  daher zu jedem Zeitpunkt die Quellen von &os.stable; verwendbar
	  sein k&ouml;nnen oder nicht.  &os.stable; ist Teil des
	  Entwicklungsprozesses und nicht f&uuml;r Endanwender
	  gedacht.</para>
      </sect3>

      <sect3>
	<title>Wer braucht &os.stable;?</title>

	<para>Wenn Sie den FreeBSD-Entwicklungsprozess, besonders im
	  Hinblick auf das n&auml;chste Release, verfolgen oder
	  dazu beitragen wollen, sollten Sie erw&auml;gen, &os.stable; zu
	  benutzen.</para>

	<para>Auch wenn sicherheitsrelevante Fehlerbehebungen in den
	  &os.stable; Zweig einflie&szlig;en, m&uuml;ssen Sie deswegen
	  noch lange nicht &os.stable; verfolgen.  Jeder der FreeBSD
	  Sicherheitshinweise beschreibt f&uuml;r jedes betroffene Release,
	  <footnote><para>Das stimmt nicht ganz.  Obwohl wir alte FreeBSD
	    Releases f&uuml;r einige Jahre unterst&uuml;tzen, k&ouml;nnen
	    wir sie nicht ewig unterst&uuml;tzen.  Eine vollst&auml;ndige
	    Beschreibung der Sicherheitspolitik f&uuml;r alte FreeBSD
	    Releases entnehmen Sie bitte <ulink
	    url="&url.base;/security/">http://www.FreeBSD.org/security/</ulink>.</para>
	  </footnote>
	  wie sie einen sicherheitsrelevanten Fehler beheben.
	  Wenn Sie den Entwicklungszweig aus Sicherheitsgr&uuml;nden
	  verfolgen wollen, bedenken Sie, dass Sie neben
	  Fehlerbehebungen auch eine Vielzahl unerw&uuml;nschter
	  &Auml;nderungen erhalten werden.</para>

	<para>Obwohl wir versuchen sicherzustellen, dass der
	  &os.stable; Zweig sich jederzeit &uuml;bersetzen l&auml;sst
	  und l&auml;uft, k&ouml;nnen wir daf&uuml;r keine Garantie
	  &uuml;bernehmen.  Auch wenn Neuentwicklungen in &os.current;
	  stattfinden, ist es jedoch so, dass mehr Leute
	  &os.stable; benutzen als &os.current; und es daher unvermeidlich
	  ist, dass Fehler und Grenzf&auml;lle erst in &os.stable;
	  auffallen.</para>

	<para>Aus diesen Gr&uuml;nden empfehlen wir Ihnen
	  <emphasis>nicht</emphasis>, blindlings &os.stable; zu benutzen.
	  Es ist wichtig, dass Sie &os.stable; zuerst sorgf&auml;ltig
	  in einer Testumgebung austesten, bevor Sie Ihre Produktion
	  auf &os.stable; migrieren.</para>

	<para>Wenn Sie dies nicht leisten k&ouml;nnen, empfehlen wir Ihnen,
	  das aktuelle FreeBSD-Release zu verwenden.  Benutzen Sie dann den
	  bin&auml;ren Update-Mechanismus, um auf neue Releases
	  zu migrieren.</para>
      </sect3>

      <sect3>
	<title>Benutzen von &os.stable;</title>

	<indexterm>
	  <primary>-STABLE</primary>
	  <secondary>benutzen</secondary>
	</indexterm>
	<orderedlist>
	  <listitem>
	    <para>Lesen Sie Mailingliste &a.stable.name;, damit Sie &uuml;ber
	      Abh&auml;ngigkeiten beim Bau von &os.stable; und Sachen, die
	      besondere Aufmerksamkeit erfordern, informiert sind.
	      Umstrittene Fehlerbehebungen oder &Auml;nderungen werden von
	      den Entwicklern auf dieser Liste bekannt gegeben.  Dies
	      erlaubt es den Benutzern, Einw&auml;nde gegen die
	      vorgeschlagenen &Auml;nderungen vorzubringen.</para>

	    <para>In der &a.cvsall.name; Mailingliste sehen Sie zu jeder
	      &Auml;nderung das Commit-Log, das Informationen zu
	      m&ouml;glichen Seiteneffekten enth&auml;lt.</para>

	    <para>Um diese Listen oder andere Listen zu abonnieren
	      besuchen Sie bitte die Seite &a.mailman.lists.link;.
	      Weitere Informationen erhalten Sie, wenn Sie dort
	      auf die gew&uuml;nschte Liste klicken.</para>
	  </listitem>

	  <listitem>
	    <para>Wenn Sie ein neues System installieren und so aktuell wie
	      m&ouml;glich sein wollen, holen Sie sich einfach den neusten
	      <foreignphrase>Snapshot</foreignphrase> von
	      <ulink url="ftp://snapshots.jp.FreeBSD.org/pub/FreeBSD/snapshots/"></ulink>
	      und installieren ihn wie ein normales Release.  Sie
	      k&ouml;nnen ebenfalls das neuste &os.stable; von
	      den <link linkend="mirrors">Spiegeln</link> beziehen
	      und Ihr System nach den folgenden Anweisungen
	      aktualisieren.</para>

	    <para>Wenn Sie schon ein &auml;lteres Release von &os;
	      und das System mit dem Quellcode aktualisieren wollen,
	      benutzen Sie einen der <link
	        linkend="mirrors">&os;-Spiegel</link>.  Sie haben
	      dazu zwei M&ouml;glichkeiten:</para>

	    <orderedlist>
	      <indexterm>
		<primary><command>cvsup</command></primary>
	      </indexterm>
	      <indexterm>
		<primary><command>cron</command></primary>
	      </indexterm>
	      <indexterm>
	        <primary>-STABLE</primary>
		<secondary>mit <application>CVSup</application>
		  synchronisieren</secondary>
	      </indexterm>
	      <listitem>
		<para>Benutzen Sie das Programm
		  <link linkend="cvsup">cvsup</link>
		  mit der Datei <filename>stable-supfile</filename>
		  aus dem Verzeichnis
		  <filename>/usr/share/examples/cvsup</filename>.
		  Dies ist die empfohlene Methode, da Sie die ganzen
		  Quellen nur einmal herunterladen und danach nur noch
		  &Auml;nderungen beziehen.  Viele lassen
		  <command>cvsup</command> aus <command>cron</command>
		  heraus laufen, um ihre Quellen automatisch auf Stand
		  zu bringen.  Sie m&uuml;ssen das oben erw&auml;hnte
		  <filename>supfile</filename> anpassen und <link
		    linkend="cvsup">cvsup</link> konfigurieren.</para>
	      </listitem>

	      <indexterm>
	        <primary>-STABLE</primary>
		<secondary>mit CTM synchronisieren</secondary>
	      </indexterm>
	      <listitem>
		<para>Benutzen Sie <application><link linkend="ctm">
		    CTM</link></application>.  Wenn Sie &uuml;ber
		  keine schnelle und billige Internet-Anbindung
		  verf&uuml;gen, sollten Sie diese Methode in Betracht
		  ziehen.</para>
	      </listitem>
	   </orderedlist>
	 </listitem>

	  <listitem>
	    <para>Benutzen Sie <command>cvsup</command> oder
	      <command>ftp</command>, wenn Sie schnellen Zugriff auf die
	      Quellen brauchen und die Bandbreite keine Rolle spielt,
	      andernfalls benutzen Sie
	      <application>CTM</application>.</para>
	  </listitem>

	  <indexterm>
	    <primary>-STABLE</primary>
	    <secondary>&uuml;bersetzen</secondary>
	  </indexterm>
	  <listitem>
	    <para>Bevor Sie &os.stable; &uuml;bersetzen, sollten Sie sich
	      das <filename>Makefile</filename> in
	      <filename>/usr/src</filename> genau anschauen.  Wenn Sie
	      &os; das erste Mal aktualisieren, sollten Sie sowohl
	      <link linkend="makeworld">einen Kernel als auch das
		System neu installieren</link>.
	      Lesen Sie bitte die Mailingliste &a.stable;
	      und <filename>/usr/src/UPDATING</filename>, um &uuml;ber
	      &Auml;nderungen im Installationsverfahren, die manchmal
	      vor der Einf&uuml;hrung eines neuen Releases notwendig sind,
	      informiert zu sein.</para>
	  </listitem>
	</orderedlist>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="synching">
    <title>Synchronisation der Quellen</title>

    <para>Sie k&ouml;nnen eine Internet-Verbindung (oder E-Mail) dazu
      nutzen, Teile von &os;, wie die Quellen zu einzelnen Projekten, oder
      das Gesamtsystem, aktuell zu halten.  Dazu bieten wir die Dienste
      <link linkend="anoncvs">AnonymousCVS</link>,
      <link linkend="cvsup">CVSup</link> und
      <link linkend="ctm">CTM</link> an.</para>

    <warning>
      <para>Obwohl es m&ouml;glich ist, nur Teile des Quellbaums zu
        aktualisieren, ist die einzige unterst&uuml;tze Migrationsprozedur,
	den kompletten Quellbaum zu aktualisieren und alles, das
	hei&szlig;t das Userland (z.B. alle Programme in
	<filename>/bin</filename> und <filename>/sbin</filename>) und die
	Kernelquellen, neu zu &uuml;bersetzen.  Wenn Sie nur einen Teil der
	Quellen, zum Beispiel nur den Kernel oder nur die Programme aus dem
	Userland, aktualisieren, werden Sie oft Probleme haben, die von
	&Uuml;bersetzungsfehlern &uuml;ber Kernel-Panics bis hin zu
	Besch&auml;digungen Ihrer Daten reichen k&ouml;nnen.</para>
    </warning>

    <indexterm>
      <primary>CVS</primary>
      <secondary>anonymous</secondary>
    </indexterm>

    <para><application>Anonymous CVS</application> und
      <application>CVSup</application> benutzen die
      <foreignphrase>Pull</foreignphrase>-Methode
      <footnote>
	<para>Von engl. <foreignphrase>to pull</foreignphrase> =
	  <emphasis>ziehen</emphasis>.  Der Client holt sich bei dieser
	  Methode die Dateien ab.</para>
      </footnote>, um die Quellen zu aktualisieren.  Im Fall von
      <application>CVSup</application> ruft der Benutzer oder ein
      <command>cron</command>-Skript <command>cvsup</command> auf, das
      wiederum mit einem <command>cvsupd</command> Server interagiert, um
      Ihre Quellen zu aktualisieren.  Mit beiden Methoden erhalten Sie
      aktuelle Updates zu einem genau von Ihnen bestimmten Zeitpunkt.  Sie
      k&ouml;nnen die Prozedur auf bestimmte Dateien oder Verzeichnisse
      einschr&auml;nken, so dass Sie nur die Updates bekommen, die
      f&uuml;r Sie von Interesse sind.  Die Updates werden zur Laufzeit,
      abh&auml;ngig von den Sachen, die Sie schon haben und den Sachen, die
      Sie haben wollen, auf dem Server generiert.  <application>Anonymous
        CVS</application> ist eine Erweiterung von
      <application>CVS</application>, die es Ihnen erlaubt, &Auml;nderungen
      direkt aus einem entfernten CVS-Repository zu ziehen.
      <application>Anonymous CVS</application> ist leichter zu handhaben
      als <application>CVSup</application>, doch ist letzteres sehr viel
      effizienter.</para>

    <indexterm>
      <primary><application>CTM</application></primary>
    </indexterm>
    <para>Im Gegensatz dazu vergleicht <application>CTM</application> Ihre
      Quellen nicht mit denen auf einem Server.  Stattdessen l&auml;uft auf
      dem Server ein Skript, das &Auml;nderungen an Dateien gegen&uuml;ber
      seinem vorigen Lauf bemerkt, die &Auml;nderungen komprimiert, mit
      einer Sequenznummer versieht und f&uuml;r das Verschicken per E-Mail
      kodiert (es werden nur druckbare ASCII-Zeichen verwendet).  Wenn Sie
      diese <quote>CTM-Deltas</quote> erhalten haben, k&ouml;nnen Sie sie
      mit &man.ctm.rmail.1; benutzen, welches die Deltas dekodiert,
      verifiziert und dann die &Auml;nderungen an Ihren Quellen vornimmt.
      Dieses Verfahren ist viel effizienter als
      <application>CVSup</application> und erzeugt auch weniger Last auf
      unseren Servern, da es die
      <foreignphrase>Push</foreignphrase>-Methode
      <footnote>
	<para>Von engl. <foreignphrase>to push</foreignphrase> =
	  <emphasis>schieben</emphasis>.  Der Server schickt dem Client die
	  Dateien.</para>
      </footnote> verwendet.</para>

    <para>Es gibt nat&uuml;rlich noch weitere Unterschiede, die Sie
      beachten sollten.  Wenn Sie unabsichtlich Teile Ihres Archivs
      l&ouml;schen, wird das von <application>CVSup</application>
      wie <application>Anonymous CVS</application> erkannt
      und repariert.  Wenn sich fehlerhafte Dateien in Ihrem Quellbaum
      befinden, l&ouml;schen Sie diese einfach und synchronisieren erneut.
      <application>CTM</application> leistet das nicht,
      wenn Sie Teile des Quellbaums gel&ouml;scht haben und keine Sicherung
      besitzen, m&uuml;ssen Sie von neuem, das hei&szlig;t vom letzten
      <quote>Basis-Delta</quote>, starten und die &Auml;nderungen wieder
      mit <application>CTM</application> nachziehen.</para>
  </sect1>

  <sect1 id="makeworld">
    <title>Das komplette Basissystem neu bauen</title>

    <indexterm>
      <primary>Bau des Basissystems</primary>
    </indexterm>

    <para>Wenn Sie Ihren lokalen Quellbaum mit einer bestimmten FreeBSD
      Version (&os.stable;, &os.current;, usw.) synchronisiert haben,
      k&ouml;nnen Sie diesen benutzen, um das System neu zu
      bauen.</para>

    <warning>
      <title>Erstellen Sie eine Sicherung!</title>

      <para>Es kann nicht oft genug betont werden, wie wichtig es ist, Ihr
        System zu sichern, <emphasis>bevor</emphasis> Sie die nachfolgenden
	Schritte ausf&uuml;hren.  Obwohl der Neubau des Systems eine
	einfache Aufgabe ist, wenn Sie sich an die folgende Anleitung
	halten, kann es dennoch vorkommen, dass Sie einen Fehler machen,
	oder dass Ihr System nicht mehr bootet, weil andere Entwickler
	Fehler in den Quellbaum eingef&uuml;hrt haben.</para>

      <para>Stellen Sie sicher, dass Sie eine Sicherung erstellt haben
        und &uuml;ber eine Fixit-Floppy oder eine startf&auml;hige CD
	verf&uuml;gen.  Wahrscheinlich werden Sie die Startmedien
	nicht ben&ouml;tigen, aber gehen Sie auf Nummer Sicher!</para>
    </warning>

    <warning>
      <title>Abonnieren Sie die richtige Mailingliste</title>

      <indexterm><primary>Mailingliste</primary></indexterm>
      <para>Die &os.stable; und &os.current; Zweige befinden sich in
        <emphasis>st&auml;ndiger Entwicklung</emphasis>.  Die Leute, die zu
	&os; beitragen, sind Menschen und ab und zu machen sie
	Fehler.</para>

      <para>Manchmal sind diese Fehler harmlos und lassen Ihr System eine
        Warnung ausgeben.  Die Fehler k&ouml;nnen allerdings auch
	katastrophal sein und dazu f&uuml;hren, dass Sie Ihr System
	nicht mehr booten k&ouml;nnen, Dateisysteme besch&auml;digt
	werden oder Schlimmeres passiert.</para>

      <para>Wenn solche Probleme auftauchen, wird ein
	<quote>heads up</quote> an die passende Mailingliste geschickt, welches
	das Problem erkl&auml;rt und die betroffenen Systeme benennt.  Eine
	<quote>all clear</quote> Meldung wird versendet, wenn das
	Problem gel&ouml;st ist.</para>

      <para>Wenn Sie &os.stable; oder &os.current; benutzen und nicht die
        Mailinglisten &a.stable; beziehungsweise &a.current; lesen, bringen
	Sie sich nur unn&ouml;tig in Schwierigkeiten.</para>
    </warning>

    <warning>
      <title>Finger weg von <command>make world</command></title>

      <para>&Auml;ltere Dokumentationen empfehlen, das Kommando
	<command>make world</command> f&uuml;r den Neubau.
	Das Kommando &uuml;berspringt wichtige Schritte.  Setzen
	Sie es nur ein, wenn Sie wissen was Sie tun.  In fast
	allen F&auml;llen ist <command>make world</command>
	falsch, benutzen Sie stattdessen die nachstehende
	Anleitung.</para>
    </warning>

    <sect2>
      <title>Richtig aktualisieren</title>

      <para>Um Ihr System zu aktualisieren, sollten Sie zuerst
	<filename>/usr/src/UPDATING</filename> lesen, und
	eventuelle, f&uuml;r Ihre Quellcodeversion n&ouml;tigen
	Aufgaben erledigen, bevor Sie das System bauen.  Danach
	aktualisieren Sie Ihr System mit den folgenden
	Schritten:</para>

      <screen>&prompt.root; <userinput>make buildworld</userinput>
&prompt.root; <userinput>make buildkernel</userinput>
&prompt.root; <userinput>make installkernel</userinput>
&prompt.root; <userinput>reboot</userinput></screen>

      <note>
	<para>Es gibt einige, sehr seltene Situationen, in denen Sie
	  <command>mergemaster -p</command> zus&auml;tzlich
	  ausf&uuml;hren m&uuml;ssen, bevor Sie das System mit
	  <maketarget>buildworld</maketarget> bauen.  Diese Situationen
	  werden in <filename>UPDATING</filename> beschrieben.  Solche
	  Situationen treten aber in der Regel nur dann auf, wenn Sie
	  Ihr &os;-System um eine oder mehrere Hauptversionen
	  aktualisieren.</para>
      </note>

      <para>Nachdem <maketarget>installkernel</maketarget> erfolgreich
	abgeschlossen wurde, starten Sie das System im Single-User-Modus
	(etwa durch die Eingabe von <command>boot -s</command> am
	Loaderprompt).  Danach f&uuml;hren Sie die folgenden Anweisungen
	aus:</para>

      <screen>&prompt.root; <userinput>mergemaster -p</userinput>
&prompt.root; <userinput>make installworld</userinput>
&prompt.root; <userinput>mergemaster</userinput>
&prompt.root; <userinput>reboot</userinput></screen>

      <warning>
	<title>Lesen Sie bitte weiter</title>

	<para>Die obige Vorschrift ist nur eine
	  Ged&auml;chtnisst&uuml;tze.  Um die einzelnen
	  Schritte zu verstehen, lesen Sie bitte die
	  folgenden Abschnitte, insbesondere wenn Sie
	  einen angepassten Kernel erstellen.</para>
      </warning>
    </sect2>

    <sect2>
      <title>Lesen Sie <filename>/usr/src/UPDATING</filename></title>

      <para>Bevor Sie etwas anderes tun, lesen Sie bitte
        <filename>/usr/src/UPDATING</filename> (oder die entsprechende
	Datei, wenn Sie den Quellcode woanders installiert haben).  Die
	Datei enth&auml;lt wichtige Informationen zu Problemen, auf die Sie
	sto&szlig;en k&ouml;nnten oder gibt die Reihenfolge vor, in der Sie
	bestimmte Kommandos laufen lassen m&uuml;ssen.  Die Anweisungen in
	<filename>UPDATING</filename> sind aktueller als die in diesem
	Handbuch.  Im Zweifelsfall folgen Sie bitte den Anweisungen aus
	<filename>UPDATING</filename>.</para>

      <important>
	<para>Das Lesen von <filename>UPDATING</filename> ersetzt nicht das
	  Abonnieren der richtigen Mailingliste.  Die beiden Voraussetzungen
	  erg&auml;nzen sich, es reicht nicht aus, nur eine zu
	  erf&uuml;llen.</para>
      </important>
    </sect2>

    <sect2>
      <title>&Uuml;berpr&uuml;fen Sie
	<filename>/etc/make.conf</filename></title>
      <indexterm>
        <primary><filename>make.conf</filename></primary>
      </indexterm>

      <para>&Uuml;berpr&uuml;fen Sie die Dateien
	<filename>/usr/share/examples/etc/make.conf</filename>
        (<filename>/etc/defaults/make.conf</filename> unter &os;&nbsp;4.X)
	und <filename>/etc/make.conf</filename>.  Die erste enth&auml;lt
	Vorgabewerte, von denen die meisten auskommentiert sind.  Um diese
	w&auml;hrend des Neubaus des Systems zu nutzen, tragen Sie die
	Werte in <filename>/etc/make.conf</filename> ein.  Beachten Sie,
	dass alles, was Sie in <filename>/etc/make.conf</filename>
	eintragen, bei jedem Aufruf von <command>make</command> angezogen
	wird.  Es ist also klug, hier etwas Sinnvolles einzutragen.</para>

      <para>Typischerweise wollen Sie die Zeilen, die
        <makevar>CFLAGS</makevar> und <makevar>NOPROFILE</makevar>
	enthalten, aus
	<filename>/usr/share/examples/etc/make.conf</filename>
	(<filename>/etc/defaults/make.conf</filename> unter &os;&nbsp;4.X)
	nach <filename>/etc/make.conf</filename> &uuml;bertragen und dort
	aktivieren.</para>

      <para>Sehen Sie sich auch die anderen Definitionen, wie
        <makevar>COPTFLAGS</makevar> oder <makevar>NOPORTDOCS</makevar> an
	und entscheiden Sie, ob Sie diese aktivieren wollen.</para>
    </sect2>

    <sect2>
      <title>Aktualisieren Sie die Dateien in <filename>/etc</filename></title>

      <para>Das Verzeichnis <filename>/etc</filename> enth&auml;lt den
        Gro&szlig;teil der Konfigurationsdateien des Systems und Skripten,
	die beim Start des Systems ausgef&uuml;hrt werden.  Einige dieser
	Skripten &auml;ndern sich bei einer Migration auf eine neue
	FreeBSD-Version.</para>

      <para>Einige der Konfigurationsdateien, besonders
        <filename>/etc/group</filename>, werden f&uuml;r den Normalbetrieb
	des Systems gebraucht.</para>

      <para>Es gab F&auml;lle, in denen das Kommando
        <command>make installworld</command> auf bestimmte
	Accounts oder Gruppen angewiesen war, die aber w&auml;hrend
	der Aktualisierung fehlten.  Demzufolge kam es zu Problemen
	bei der Aktualisierung.  In einigen F&auml;llen pr&uuml;ft
	<command>make buildworld</command> ob die Accounts oder
	Gruppen vorhanden sind.</para>

      <para>Ein Beispiel daf&uuml;r ist der vor kurzem hinzugef&uuml;gte
        Benutzer <username>smmsp</username>.  Die Installationsprozedur
	schlug an der Stelle fehl, an der &man.mtree.8;
	versuchte, <filename>/var/spool/clientmqueue</filename>
	anzulegen.</para>

      <para>Um dieses Problem zu umgehen, vergleichen Sie die Gruppen in
        <filename>/usr/src/etc/group</filename> mit den auf Ihrem System
	vorhandenen Gruppen.  Wenn sich in dieser Datei neue Gruppen
	befinden, kopieren Sie diese nach <filename>/etc/group</filename>.
	Gruppen, die in <filename>/etc/group</filename> dieselbe GID wie in
	<filename>/usr/src/etc/group</filename> aber einen
	unterschiedlichen Namen haben, sollten Sie umbenennen.</para>

      <para>Seit 4.6-RELEASE besitzt &man.mergemaster.8; einen
	pr&auml;-buildworld Modus, der mit <option>-p</option> aktiviert
	wird.  In diesem Modus werden nur Dateien verglichen, die f&uuml;r
	den Erfolg von <maketarget>buildworld</maketarget> oder
	<maketarget>installworld</maketarget> essentiell sind.  Wenn Ihre
	alte Version von <command>mergemaster</command> die Option
	<option>-p</option> noch nicht unterst&uuml;tzt, nehmen Sie beim
	ersten Lauf die neue Version aus dem Quellbaum:</para>

      <screen>&prompt.root; <userinput>cd /usr/src/usr.sbin/mergemaster</userinput>
&prompt.root; <userinput>./mergemaster.sh -p</userinput></screen>

      <tip>
	<para>Wenn Sie besonders paranoid sind, sollten Sie Ihr System nach
	  Dateien absuchen, die der Gruppe, die Sie umbenennen oder
	  l&ouml;schen, geh&ouml;ren:</para>

	<screen>&prompt.root; <userinput>find / -group <replaceable>GID</replaceable> -print</userinput></screen>

	<para>Das obige Kommando zeigt alle Dateien an, die der Gruppe
	  <replaceable>GID</replaceable> (dies kann entweder ein
	  Gruppenname oder eine numerische ID sein) geh&ouml;ren.</para>
      </tip>
    </sect2>

    <sect2 id="makeworld-singleuser">
      <title>Wechseln Sie in den Single-User-Modus</title>
      <indexterm><primary>Single-User-Modus</primary></indexterm>

      <para>Sie k&ouml;nnen das System im Single-User-Modus
        &uuml;bersetzen.  Abgesehen davon, dass dies etwas schneller
	ist, werden bei der Installation des Systems viele wichtige Dateien,
	wie die Standard-Systemprogramme, die Bibliotheken und
	Include-Dateien, ver&auml;ndert.  Sie bringen sich in
	Schwierigkeiten, wenn Sie diese Dateien auf einem laufenden System
	ver&auml;ndern, besonders dann, wenn zu dieser Zeit Benutzer auf
	dem System aktiv sind.</para>

      <indexterm><primary>Mehrbenutzermodus</primary></indexterm>
      <para>Eine andere Methode &uuml;bersetzt das System im
        Mehrbenutzermodus und wechselt f&uuml;r die Installation in den
	Single-User-Modus.  Wenn Sie diese Methode benutzen wollen, warten
	Sie mit den folgenden Schritten, bis der Bau des Systems fertig
	ist und Sie mit <maketarget>installkernel</maketarget> oder
	<maketarget>installworld</maketarget> installieren wollen.</para>

      <para>Als Superuser k&ouml;nnen Sie mit dem folgenden Kommando ein
        laufendes System in den Single-User-Modus bringen:</para>

      <screen>&prompt.root; <userinput>shutdown now</userinput></screen>

      <para>Alternativ k&ouml;nnen Sie das System mit der Option
        <option>-s</option> in den Single-User-Modus booten.  Setzen Sie
	dann die folgenden Kommandos ab:</para>

      <screen>&prompt.root; <userinput>fsck -p</userinput>
&prompt.root; <userinput>mount -u /</userinput>
&prompt.root; <userinput>mount -a -t ufs</userinput>
&prompt.root; <userinput>swapon -a</userinput></screen>

      <para>Die Kommandos &uuml;berpr&uuml;fen die Dateisysteme,
        h&auml;ngen <filename>/</filename> wieder beschreibbar ein,
	h&auml;ngen dann alle anderen UFS Dateisysteme aus
	<filename>/etc/fstab</filename> ein und aktivieren den
	Swap-Bereich.</para>

        <note>
	  <para>Zeigt Ihre CMOS-Uhr die lokale Zeit und nicht GMT an, dies
	    erkennen Sie daran, dass &man.date.1; die
	    falsche Zeit und eine flasche Zeitzone anzeigt, setzen Sie das
	    folgende Kommando ab:</para>
<screen>&prompt.root; <userinput>adjkerntz -i</userinput></screen>

	  <para>Dies stellt sicher, dass Ihre Zeitzone richtig
	    eingestellt ist.  Ohne dieses Kommando werden Sie
	    vielleicht sp&auml;ter Probleme bekommen.</para>
        </note>

    </sect2>

    <sect2>
      <title>Entfernen Sie <filename>/usr/obj</filename></title>

      <para>Die neugebauten Teile des Systems werden in der Voreinstellung
        unter <filename>/usr/obj</filename> gespeichert.  Die Verzeichnisse
	dort spiegeln die Struktur unter
	<filename>/usr/src</filename>.</para>

      <para>Sie k&ouml;nnen den <command>make buildworld</command> Prozess
        beschleunigen, indem Sie dieses Verzeichnis entfernen.  Dies
	erspart Ihnen zudem einigen &Auml;rger aufgrund von
	Abh&auml;ngigkeiten.</para>

      <para>Einige Dateien unter <filename>/usr/obj</filename> sind
        vielleicht durch die <option>immutable</option>-Option
	(siehe &man.chflags.1;) schreibgesch&uuml;tzt, die vor dem
	L&ouml;schen entfernt werden muss.</para>

      <screen>&prompt.root; <userinput>cd /usr/obj</userinput>
&prompt.root; <userinput>chflags -R noschg *</userinput>
&prompt.root; <userinput>rm -rf *</userinput></screen>
    </sect2>

    <sect2>
      <title>&Uuml;bersetzen der Quellen</title>

      <sect3>
	<title>Sichern der Ausgaben</title>

	<para>F&uuml;r den Fall, dass etwas schief geht, sollten Sie
	  die Ausgaben von &man.make.1; in einer Datei sichern, damit Sie
	  eine Kopie der Fehlermeldung besitzen.  Das mag Ihnen nicht
	  helfen, den Fehler zu finden, kann aber anderen helfen, wenn Sie
	  Ihr Problem in einer der &os;-Mailinglisten schildern.</para>

	<para>Dazu k&ouml;nnen Sie einfach das Kommando &man.script.1;
	  benutzen, dem Sie beim Aufruf als Parameter den Dateinamen
	  f&uuml;r die Ausgaben mitgeben.  Setzen Sie das Kommando
	  unmittelbar vor dem Neubau ab und geben Sie
	  <userinput>exit</userinput> ein, wenn der Bau abgeschlossen
	  ist:</para>

	<screen>&prompt.root; <userinput>script /var/tmp/mw.out</userinput>
Script started, output file is /var/tmp/mw.out
&prompt.root; <userinput>make <replaceable>TARGET</replaceable></userinput>
<emphasis>&hellip; Ausgaben des Kommandos &hellip;</emphasis>
&prompt.root; <userinput>exit</userinput>
Script done, &hellip;</screen>

	<para>Sichern Sie die Ausgaben nicht in <filename>/tmp</filename>,
	  da dieses Verzeichnis beim n&auml;chsten Boot aufger&auml;umt
	  werden kann.  Ein geeigneteres Verzeichnis ist
	  <filename>/var/tmp</filename>, wie im vorigen Beispiel gezeigt,
	  oder das Heimatverzeichnis von <username>root</username>.</para>
      </sect3>

      <sect3 id="make-buildworld">
	<title>&Uuml;bersetzen des Basissystems</title>

	<para>Wechseln Sie in das Verzeichnis, in dem die Quellen liegen
	  (in der Voreinstellung ist das
	  <filename>/usr/src</filename>):</para>

	<screen>&prompt.root; <userinput>cd /usr/src</userinput></screen>

	<indexterm><primary><command>make</command></primary></indexterm>

	<para>Zum Neubau der Welt benutzen Sie &man.make.1;.  Dieses
	  Kommando liest ein <filename>Makefile</filename>, das Anweisungen
	  enth&auml;lt, wie die Programme, aus denen &os; besteht, zu bauen
	  sind und in welcher Reihenfolge diese zu bauen sind.</para>

	<para>Ein typischer Aufruf von <command>make</command> sieht wie
	  folgt aus:</para>

	<screen>&prompt.root; <userinput>make -<replaceable>x</replaceable> -D<replaceable>VARIABLE</replaceable> <replaceable>target</replaceable></userinput></screen>

	<para>In diesem Beispiel ist
	  <option>-<replaceable>x</replaceable></option> eine Option, die
	  Sie an &man.make.1; weitergeben wollen.  Eine Liste g&uuml;ltiger
	  Optionen finden Sie in der &man.make.1; Manualpage.</para>

	<para>Das Verhalten eines <filename>Makefile</filename>s wird von
	  Variablen bestimmt.  Mit
	  <option>-D<replaceable>VARIABLE</replaceable></option> setzen Sie
	  eine Variable.  Diese Variablen sind dieselben, die auch in
	  <filename>/etc/make.conf</filename> gesetzt werden, dies ist nur
	  ein alternativer Weg, Variablen zu setzen.</para>

	<para>Um zu verhindern, dass die <quote>profiled</quote>
	  Bibliotheken gebaut werden, rufen Sie <command>make</command> wie
	  folgt auf:</para>
	<screen>&prompt.root; <userinput>make -DNOPROFILE <replaceable>target</replaceable></userinput></screen>

	<para>Dieser Aufruf entspricht dem folgenden Eintrag in
	  <filename>/etc/make.conf</filename>:</para>

	<programlisting>NOPROFILE=    true     #    Avoid compiling profiled libraries</programlisting>

	<para>Jedes <filename>Makefile</filename> definiert einige
	  <quote>Ziele</quote>, die festlegen, was genau zu tun ist.  Mit
	  <replaceable>target</replaceable> w&auml;hlen Sie eins dieser
	  Ziele aus.</para>

	<para>Einige Ziele im <filename>Makefile</filename> sind nicht
	  f&uuml;r den Endanwender gedacht, sondern unterteilen den
	  Bauprozess in eine Reihe von Einzelschritten.</para>

	<para>Im Regelfall m&uuml;ssen Sie &man.make.1; keine Parameter
	  mitgeben, so dass Ihre Kommandozeile wie folgt aussehen
	  wird:</para>

	<screen>&prompt.root; <userinput>make <replaceable>target</replaceable></userinput></screen>

	<para>In der &os; Version 2.2.5 wurde das Ziel
	  <maketarget>world</maketarget> in zwei Ziele aufgespalten:
	  <maketarget>buildworld</maketarget> und
	  <maketarget>installworld</maketarget>.  Tats&auml;chlich ist das
	  zuerst in &os.current; passiert und wurde dann irgendwann
	  zwischen den Versionen 2.2.2 und 2.2.5 in &os.stable;
	  eingebaut.  In der Voreinstellung wird das Ziel
	  <maketarget>world</maketarget> ab &os;&nbsp;5.3 nicht mehr
	  funktionieren, da es in den meisten F&auml;llen Schaden
	  anrichtet.</para>

	<para>Mit <maketarget>buildworld</maketarget> wird ein kompletter
	  Baum unterhalb von <filename>/usr/obj</filename> gebaut, der mit
	  <maketarget>installworld</maketarget> auf dem System installiert
	  werden kann.</para>

	<para>Dies ist aus zwei Gr&uuml;nden n&uuml;tzlich.  Erstens
	  k&ouml;nnen Sie das System auf einem laufenden System bauen, da die
	  Bauprozedur abgekapselt vom Rest des Systems ist.  Das System
	  l&auml;sst sich im Mehrbenutzermodus ohne negative
	  Seiteneffekte bauen.  Die Installation mit
	  <maketarget>installworld</maketarget> sollte aber immer noch im
	  Single-User-Modus erfolgen.</para>

	<para>Zweitens k&ouml;nnen Sie NFS benutzen, um mehrere Maschinen
	  in Ihrem Netzwerk zu aktualisieren.  Wenn Sie die Maschinen
	  <hostid>A</hostid>, <hostid>B</hostid> und <hostid>C</hostid>
	  aktualisieren wollen, lassen sie <command>make
	    buildworld</command> und <command>make installworld</command> auf
	  <hostid>A</hostid> laufen.  Auf den Maschinen <hostid>B</hostid>
	  und <hostid>C</hostid> k&ouml;nnen Sie die
	  Verzeichnisse <filename>/usr/src</filename> und
	  <filename>/usr/obj</filename> von <hostid>A</hostid> einh&auml;ngen
	  und brauchen dort nur noch <command>make installworld</command>
	  auszuf&uuml;hren, um die Bauresultate zu installieren.</para>

	<para>Obwohl das Ziel <maketarget>world</maketarget> noch
	  existiert, sollten Sie es wirklich nicht mehr benutzen.</para>

	<para>Um das System zu bauen, setzen Sie das folgende Kommando
	  ab:</para>

	<screen>&prompt.root; <userinput>make buildworld</userinput></screen>

	<para>Mit <option>-j</option> k&ouml;nnen Sie
	  <command>make</command> anweisen, mehrere Prozesse zu starten.
	  Besonders effektiv ist das auf Mehrprozessor-Systemen.  Da aber
	  der &Uuml;bersetzungsprozess haupts&auml;chlich von IO statt
	  der CPU bestimmt wird, ist diese Option auch auf
	  Einprozessor-Systemen n&uuml;tzlich.</para>

	<para>Auf einem typischen Einprozessor-System k&ouml;nnen Sie den
	  folgenden Befehl absetzen:</para>

	<screen>&prompt.root; <userinput>make -j4 buildworld</userinput></screen>

	<para>&man.make.1; wird dann bis zu vier Prozesse gleichzeitig
	  laufen lassen.  Erfahrungsberichte aus den Mailinglisten zeigen,
	  dass dieser Aufruf typischerweise den besten
	  Geschwindigkeitsgewinn bringt.</para>

	<para>Wenn Sie ein Mehrprozessor-System besitzen und SMP in Ihrem
	  Kernel konfiguriert ist, probieren Sie Werte zwischen 6 und 10
	  aus.</para>

	<para>Beachten Sie bitte, dass dies noch nicht richtig
	  unterst&uuml;tzt wird und dass es bei einigen
	  &Auml;nderungen am Quellbaum zu Fehlern kommen kann.  Wenn Sie
	  diesen Parameter benutzt haben und der Bau nicht funktioniert,
	  bauen Sie bitte noch einmal ohne den Parameter, bevor Sie ein
	  Problem melden.</para>
      </sect3>

      <sect3>
	<title>Laufzeiten</title>
	<indexterm>
	  <primary>Bau des Basissystems</primary>
	  <secondary>Laufzeiten</secondary>
	</indexterm>

	<para>Die Laufzeit eines Baus wird von vielen Faktoren
	  beeinflusst.  Ein 500&nbsp;MHz &pentium;&nbsp;III braucht
	  ungef&auml;hr zwei Stunden um &os.stable; zu bauen.  Der Bau von
	  &os.current; dauert etwas l&auml;nger.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>&Uuml;bersetzen und Installation des Kernels</title>
      <indexterm>
        <primary>Kernel</primary>
	<secondary>&Uuml;bersetzen</secondary>
      </indexterm>

      <para>Um das Beste aus Ihrem System zu holen, sollten Sie einen neuen
	Kernel kompilieren.  Praktisch gesehen ist das sogar notwendig, da
	sich einige Datenstrukturen ge&auml;ndert haben und Programme wie
	&man.ps.1; oder &man.top.1; nur mit einem Kernel zusammen arbeiten,
	der auch zu dem entsprechenden Quellcode passt.</para>

      <para>Am einfachsten und sichersten bauen Sie dazu den
        <filename>GENERIC</filename> Kernel.  Obwohl der
	<filename>GENERIC</filename> Kernel vielleicht nicht alle
	Ihre Ger&auml;te unterst&uuml;tzt, sollte er alles enthalten,
	um das System in den Single-User-Modus zu booten.  Dies ist auch
	ein guter Test, um zu sehen, dass das System
	ordnungsgem&auml;&szlig; funktioniert.  Nachdem Sie mit
	<filename>GENERIC</filename> gebootet und sichergestellt haben,
	dass Ihr System funktioniert, k&ouml;nnen Sie einen neuen
	Kernel mit Ihrer Konfigurationsdatei bauen.</para>

      <para>In aktuellen &os;-Versionen m&uuml;ssen Sie das
	<link linkend="make-buildworld">Basissystem neu bauen</link>,
	bevor Sie einen neuen Kernel erstellen.</para>

      <note>
	<para>Wenn Sie einen angepassten Kernel erstellen wollen und
	  bereits &uuml;ber eine Konfigurationsdatei verf&uuml;gen,
	  geben Sie diese, wie im folgenden Beispiel gezeigt, auf der
	  Kommandozeile an:</para>

        <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make buildkernel KERNCONF=<replaceable>MYKERNEL</replaceable></userinput>
&prompt.root; <userinput>make installkernel KERNCONF=<replaceable>MYKERNEL</replaceable></userinput></screen>

      </note>

      <para>Wenn <varname>kern.securelevel</varname> einen Wert
	gr&ouml;&szlig;er als <literal>1</literal> besitzt
	<emphasis>und</emphasis> der Kernel mit <literal>noschg</literal>
	oder &auml;hnlichen Optionen gesch&uuml;tzt ist, m&uuml;ssen Sie
	<maketarget>installkernel</maketarget> im Einbenutzermodus
	ausf&uuml;hren.  Wenn das nicht der Fall ist, sollten die beiden
	Kommandos problemlos im Mehrbenutzermodus laufen.  Weitere
	Informationen &uuml;ber <varname>kern.securelevel</varname> finden
	Sie in &man.init.8; und &man.chflags.1; erl&auml;utert Optionen, die
	Sie auf Dateien setzen k&ouml;nnen.</para>
    </sect2>

    <sect2>
      <title>Booten Sie in den Single-User-Modus</title>
      <indexterm><primary>Single-User-Modus</primary></indexterm>

      <para>Um zu pr&uuml;fen, ob der neue Kernel funktioniert, sollten Sie
        in den Single-User-Modus booten.  Folgen Sie dazu der Anleitung aus
	<xref linkend="makeworld-singleuser">.</para>
    </sect2>

    <sect2>
      <title>Installation des Systems</title>

      <para>Wenn Sie <command>make buildworld</command> benutzt haben, um
        das System zu bauen, sollten Sie jetzt
	<maketarget>installworld</maketarget> benutzen, um es zu
	installieren.  Rufen Sie dazu das folgende Kommando auf:</para>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make installworld</userinput></screen>

      <note>
	<para>Wenn Sie mit dem <command>make buildworld</command> Kommando
	  Variablen verwenden haben, m&uuml;ssen Sie dieselben Variablen
	  auch bei dem <command>make installworld</command> Kommando
	  angeben.  Auf die anderen Optionen trifft das nur bedingt zu:
	  <option>-j</option> darf mit <maketarget>installworld</maketarget>
	  nicht benutzt werden.</para>

	<para>Sie haben zum Bauen die folgende Kommandozeile
	  verwendet:</para>

	<screen>&prompt.root; <userinput>make -DNOPROFILE buildworld</userinput></screen>

	<para>Bei der Installation setzen Sie dann das folgende Kommando
	  ab:</para>

	<screen>&prompt.root; <userinput>make -DNOPROFILE installworld</userinput></screen>

	<para>W&uuml;rden Sie die Variable bei der Installation weglassen,
	  so w&uuml;rde das System versuchen, die <quote>profiled</quote>
	  Bibliotheken, die aber gar nicht gebaut wurden, zu
	  installieren.</para>
      </note>
    </sect2>

    <sect2>
      <title>Aktualisieren der von <command>make installworld</command>
        ausgelassenen Dateien</title>

      <para>Neue oder ge&auml;nderte Konfigurationsdateien aus einigen
        Verzeichnissen, besonders <filename>/etc</filename>,
	<filename>/var</filename> und <filename>/usr</filename> werden bei
	der Installationsprozedur nicht ber&uuml;cksichtigt.</para>

      <para>Sie k&ouml;nnen diese Dateien mit &man.mergemaster.8;
        aktualisieren.  Alternativ k&ouml;nnen Sie das auch manuell
	durchf&uuml;hren, obwohl wir diesen Weg nicht empfehlen.  Egal
	welchen Weg Sie beschreiten, sichern Sie vorher den Inhalt von
	<filename>/etc</filename> f&uuml;r den Fall, dass etwas schief
	geht.</para>

      <sect3 id="mergemaster">
        <sect3info>
	  <authorgroup>
	    <author>
	      <firstname>Tom</firstname>
	      <surname>Rhodes</surname>
	      <contrib>Beigetragen von </contrib>
	    </author>
	  </authorgroup>
        </sect3info>
	<title><command>mergemaster</command></title>
        <indexterm><primary><command>mergemaster</command></primary></indexterm>

	<para>Das Bourne-Shell Skript &man.mergemaster.8; hilft Ihnen dabei,
	  die Unterschiede zwischen den Konfigurationsdateien in
	  <filename>/etc</filename> und denen im Quellbaum unter
	  <filename>/usr/src/etc</filename> zu finden.
	  <command>mergemaster</command> ist der empfohlene Weg, Ihre
	  Systemkonfiguration mit dem Quellbaum abzugleichen.</para>

	<para>Rufen Sie <command>mergemaster</command> einfach auf und
	  schauen Sie zu.  Ausgehend von <filename>/</filename> wird
	  <command>mergemaster</command> einen virtuellen Root-Baum
	  aufbauen und darin die neuen Konfigurationsdateien ablegen.
	  Diese Dateien werden dann mit den auf Ihrem System installierten
	  verglichen.  Unterschiede zwischen den Dateien werden im
	  &man.diff.1;-Format dargestellt.  Neue oder ge&auml;nderte Zeilen
	  werden mit <option>+</option> gekennzeichnet.  Zeilen die
	  gel&ouml;scht oder ersetzt werden, sind mit einem
	  <option>-</option> gekennzeichnet.  Das Anzeigeformat wird in
	  &man.diff.1; genauer erkl&auml;rt.</para>

	<para>&man.mergemaster.8; zeigt Ihnen jede ge&auml;nderte Datei an
	  und Sie haben die Wahl, die neue Datei (in
	  <command>mergemaster</command> wird sie tempor&auml;re Datei
	  genannt) zu l&ouml;schen, sie unver&auml;ndert zu installieren,
	  den Inhalt der neuen Datei mit dem Inhalt der alten Datei
	  abzugleichen, oder die &man.diff.1; Ausgabe noch einmal zu
	  sehen.  Sie k&ouml;nnen die aktuelle Datei auch
	  &uuml;berspringen, sie wird dann noch einmal angezeigt, nachdem
	  alle anderen Dateien abgearbeitet wurden.  Sie erhalten Hilfe,
	  wenn Sie bei der Eingabeaufforderung von
	  <command>mergemaster</command> ein <keycap>?</keycap>
	  eingeben.</para>

	<para>Wenn Sie die tempor&auml;re Datei l&ouml;schen, geht
	  <command>mergemaster</command> davon aus, dass Sie Ihre
	  aktuelle Datei behalten m&ouml;chten.  W&auml;hlen Sie die Option
	  bitte nur dann, wenn Sie keinen Grund sehen, die aktuelle Datei
	  zu &auml;ndern.</para>

	<para>Wenn Sie die tempor&auml;re Datei installieren, wird Ihre
	  aktuelle Datei mit der neuen Datei &uuml;berschrieben.  Sie
	  sollten alle unver&auml;nderten Konfigurationsdateien auf diese
	  Weise aktualisieren.</para>

	<para>Wenn Sie sich entschlie&szlig;en den Inhalt beider Dateien
	  abzugleichen, wird ein Texteditor aufgerufen, indem Sie beide
	  Dateien nebeneinander betrachten k&ouml;nnen.  Mit der Taste
	  <keycap>l</keycap> &uuml;bernehmen Sie die aktuelle Zeile der
	  links dargestellten Datei, mit der Taste <keycap>r</keycap>
	  &uuml;bernehmen Sie die Zeile der rechts dargestellten Datei.
	  Das Ergebnis ist eine Datei, die aus Teilen der beiden
	  urspr&uuml;nglichen Dateien besteht und installiert werden kann.
	  Dieses Verfahren wird gew&ouml;hnlich bei ver&auml;nderten
	  Dateien genutzt.</para>

	<para>Haben Sie sich entschieden die Differenzen noch einmal
	  anzuzeigen, zeigt Ihnen &man.mergemaster.8; dieselbe Ausgabe, die
	  Sie gesehen haben, bevor die Eingabeaufforderung ausgegeben
	  wurde.</para>

	<para>Wenn &man.mergemaster.8; alle Systemdateien abgearbeitet hat,
	  werden weitere Optionen abgefragt.  Sie werden unter
	  Umst&auml;nden gefragt, ob Sie die Passwort-Datei neu bauen
	  oder &man.MAKEDEV.8; laufen lassen wollen.  Am Ende
	  haben Sie die M&ouml;glichkeit, den Rest der tempor&auml;ren Dateien
	  zu l&ouml;schen.</para>
      </sect3>

      <sect3>
	<title>Manueller Abgleich der Konfigurationsdateien</title>

	<para>Wenn Sie den Abgleich lieber selbst ausf&uuml;hren wollen,
	  beachten Sie bitte, dass Sie nicht einfach die Dateien aus
	  <filename>/usr/src/etc</filename> nach <filename>/etc</filename>
	  kopieren k&ouml;nnen.  Einige dieser Dateien m&uuml;ssen zuerst
	  <emphasis>installiert</emphasis> werden, bevor sie benutzt werden
	  k&ouml;nnen.  Das liegt daran, dass
	  <filename>/usr/src/etc</filename> keine exakte Kopie von
	  <filename>/etc</filename> ist.  Zudem gibt es Dateien, die sich
	  in <filename>/etc</filename> befinden aber nicht in
	  <filename>/usr/src/etc</filename>.  Wenn Sie, wie empfohlen,
	  <command>mergemaster</command> benutzen, lesen Sie bitte im
	  <link linkend="update-dev"> n&auml;chsten Abschnitt</link>
	  weiter.</para>

	<para>Am einfachsten ist es, wenn Sie die neuen Dateien in ein
	  tempor&auml;res Verzeichnis installieren und sie nacheinander auf
	  Differenzen zu den bestehenden Dateien durchsehen.</para>

	<warning>
	  <title>Sichern Sie die Inhalte von <filename>/etc</filename></title>

	  <para>Obwohl bei dieser Prozedur keine Dateien in
	    <filename>/etc</filename> automatisch ver&auml;ndert werden,
	    sollten Sie dessen Inhalt an einen sicheren Ort
	    kopieren:</para>

	    <screen>&prompt.root; <userinput>cp -Rp /etc /etc.old</userinput></screen>

	    <para>Mit <option>-R</option> wird rekursiv kopiert und
	      <option>-p</option> erh&auml;lt die Attribute der kopierten
	      Dateien, wie Zugriffszeiten und Eigent&uuml;mer.</para>
	</warning>

	<para>Sie m&uuml;ssen die neuen Dateien in einem tempor&auml;ren
	  Verzeichnis installieren.  <filename>/var/tmp/root</filename> ist
	  eine gute Wahl f&uuml;r das tempor&auml;re Verzeichnis, in dem
	  auch noch einige Unterverzeichnisse angelegt werden
	  m&uuml;ssen.</para>

        <screen>&prompt.root; <userinput>mkdir /var/tmp/root</userinput>
&prompt.root; <userinput>cd /usr/src/etc</userinput>
&prompt.root; <userinput>make DESTDIR=/var/tmp/root distrib-dirs distribution</userinput></screen>

	<para>Die obigen Kommandos bauen die n&ouml;tige
	  Verzeichnisstruktur auf und installieren die neuen Dateien in
	  diese Struktur.  Unterhalb von <filename>/var/tmp/root</filename>
	  wurden einige leere Verzeichnisse angelegt, die Sie am besten wie
	  folgt entfernen:</para>

        <screen>&prompt.root; <userinput>cd /var/tmp/root</userinput>
&prompt.root; <userinput>find -d . -type d | xargs rmdir 2&gt;/dev/null</userinput></screen>

	<para>Im obigen Beispiel wurde die Fehlerausgabe nach
	  <filename>/dev/null</filename> umgeleitet, um die Warnungen
	  &uuml;ber nicht leere Verzeichnisse zu unterdr&uuml;cken.</para>

	<para><filename>/var/tmp/root</filename> enth&auml;lt nun alle
	  Dateien, die unterhalb von <filename>/</filename> installiert
	  werden m&uuml;ssen.  Sie m&uuml;ssen nun jede dieser Dateien mit
	  den schon existierenden Dateien vergleichen.</para>

	<para>Einige der installierten Dateien unter
	  <filename>/var/tmp/root</filename> beginnen mit einem
	  <quote>.</quote>.
	  Als dieses Kapitel verfasst wurde, waren das nur die
	  Startdateien f&uuml;r die Shells in
	  <filename>/var/tmp/root/</filename> und
	  <filename>/var/tmp/root/root/</filename>.  Abh&auml;ngig davon,
	  wann Sie dieses Handbuch lesen, k&ouml;nnen mehr Dateien dieser
	  Art existieren.  Verwenden Sie <command>ls -a</command> um
	  sicherzustellen, dass Sie alle derartigen Dateien
	  finden.</para>

	<para>Benutzen Sie &man.diff.1; um Unterschiede zwischen zwei
	  Dateien festzustellen:</para>

        <screen>&prompt.root; <userinput>diff /etc/shells /var/tmp/root/etc/shells</userinput></screen>

	<para>Das obige Kommando zeigt Ihnen die Unterschiede zwischen der
	  installierten Version von <filename>/etc/shells</filename> und
	  der neuen Version in <filename>/var/tmp/root/etc/shells</filename>.
	  Entscheiden Sie anhand der Unterschiede, ob
	  Sie beide Dateien abgleichen oder die neue Version &uuml;ber die
	  alte kopieren wollen.</para>

	<tip>
	  <title>Versehen Sie das tempor&auml;re Verzeichnis mit einem
	    Zeitstempel</title>

	  <para>Wenn Sie das System oft neu bauen, m&uuml;ssen Sie
	    <filename>/etc</filename> genauso oft aktualisieren.  Dies kann
	    mit der Zeit sehr l&auml;stig werden.</para>

	  <para>Sie k&ouml;nnen das Verfahren beschleunigen, wenn Sie sich
	    eine Kopie der Dateien behalten, die Sie zuletzt nach
	    <filename>/etc</filename> installiert haben.  Das folgende
	    Verfahren zeigt Ihnen, wie das geht.</para>

	  <procedure>
	    <step>
	      <para>Folgen Sie der normalen Prozedur um das System zu
	        bauen.  Wenn Sie <filename>/etc</filename> und die anderen
		Verzeichnisse aktualisieren wollen, geben Sie dem
		tempor&auml;ren Verzeichnis einen Namen, der das aktuelle
		Datum enth&auml;lt.  Wenn Sie dies zum Beispiel am
		14.&nbsp;Februar 1998 durchf&uuml;hrten, h&auml;tten Sie die
		folgenden Kommandos abgesetzt:</para>

	      <screen>&prompt.root; <userinput>mkdir /var/tmp/root-19980214</userinput>
&prompt.root; <userinput>cd /usr/src/etc</userinput>
&prompt.root; <userinput>make DESTDIR=/var/tmp/root-19980214 \
    distrib-dirs distribution</userinput></screen>
	    </step>

	    <step>
	      <para>Gleichen Sie die &Auml;nderungen entsprechend der
		Anleitung von oben ab.</para>

	      <para>Wenn Sie fertig sind, entfernen Sie das Verzeichnis
		<filename>/var/tmp/root-19980214</filename>
		<emphasis>nicht</emphasis>.</para>
	    </step>

	    <step>
	      <para>Wenn Sie nun neue Quellen heruntergeladen und gebaut
	        haben, folgen Sie bitte Schritt 1.  Wenn Sie zwischen den
		Updates eine Woche gewartet haben, haben Sie nun ein
		Verzeichnis mit dem Namen
		<filename>/var/tmp/root-19980221</filename>.</para>
	    </step>

	    <step>
	      <para>Sie k&ouml;nnen nun die Unterschiede, die sich in einer
		Woche ergeben haben, sehen, indem Sie &man.diff.1; rekursiv
		anwenden:</para>

	      <screen>&prompt.root; <userinput>cd /var/tmp</userinput>
&prompt.root; <userinput>diff -r root-19980214 root-19980221</userinput></screen>

	      <para>&Uuml;blicherweise sind die Differenzen, die Sie jetzt
	        sehen, kleiner als die Differenzen zwischen
		<filename>/var/tmp/root-19980221/etc</filename> und
		<filename>/etc</filename>.  Da die angezeigten Differenzen
		kleiner sind, ist es jetzt einfacher den Abgleich der
		Dateien durchzuf&uuml;hren.</para>
	    </step>

	    <step>
	      <para>Sie k&ouml;nnen nun das &auml;lteste der beiden
	        <filename>/var/tmp/root-*</filename> Verzeichnisse
	        entfernen:</para>

	      <screen>&prompt.root; <userinput>rm -rf /var/tmp/root-19980214</userinput></screen>
	    </step>

	    <step>
	      <para>Wiederholen Sie diesen Prozess jedes Mal wenn Sie
		Dateien in <filename>/etc</filename> abgleichen
		m&uuml;ssen.</para>
	    </step>
	  </procedure>

	  <para>Mit &man.date.1; k&ouml;nnen Sie den Verzeichnisnamen
	    automatisch erzeugen:</para>

	  <screen>&prompt.root; <userinput>mkdir /var/tmp/root-`date "+%Y%m%d"`</userinput></screen>
	</tip>
      </sect3>
    </sect2>

    <sect2 id="update-dev">
      <title>Aktualisieren Sie <filename>/dev</filename></title>

      <note>
        <indexterm><primary>DEVFS</primary></indexterm>
	<para>&Uuml;berspringen Sie diesen Abschnitt, wenn Sie
	  FreeBSD&nbsp;5.0 oder eine neuere Version benutzen.  In diesen
	  Versionen werden die Ger&auml;tedateien automatisch von
	  &man.devfs.5; angelegt.</para>
      </note>

      <para>In den meisten F&auml;llen bemerkt &man.mergemaster.8; wann es
        notwendig ist, Ger&auml;tedateien in <filename>/dev</filename>
	zu erstellen.  Die folgenden Anweisungen zeigen Ihnen, wie Sie dies
	manuell durchf&uuml;hren.</para>

      <para>Um sicher zu gehen, besteht dieser Prozess aus mehreren
        Schritten.</para>

      <procedure>
	<step>
	  <para>Kopieren Sie <filename>/var/tmp/root/dev/MAKEDEV</filename>
	    nach <filename>/dev</filename>:</para>

	  <screen>&prompt.root; <userinput>cp /var/tmp/root/dev/MAKEDEV /dev</userinput></screen>
	  <indexterm>
	    <primary><filename>MAKEDEV</filename></primary>
	  </indexterm>

	  <para>Wenn Sie &man.mergemaster.8; benutzt haben, sollte
	    <filename>MAKEDEV</filename> schon aktualisiert sein, obwohl es
	    nicht schadet, das mit <command>diff</command> zu
	    &uuml;berpr&uuml;fen und die Datei, wenn n&ouml;tig, manuell zu
	    kopieren.</para>
	</step>

	<step>
	  <para>Sichern Sie jetzt die Dateiinformationen aus
	    <filename>/dev</filename>.  Sie brauchen die Rechte,
	    Eigent&uuml;mer, sowie die Major und Minor Nummern der
	    Ger&auml;tedateien (die Zeitstempel sind nicht wichtig).  Am
	    besten erledigen Sie das mit &man.awk.1;:</para>

	  <screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>ls -l | awk '{print $1, $2, $3, $4, $5, $6, $NF}' > /var/tmp/dev.out</userinput></screen>
	</step>

	<step>
	  <para>Erstellen Sie alle Ger&auml;tedateien neu:</para>

	    <screen>&prompt.root; <userinput/sh MAKEDEV all/</screen>
	</step>

	<step>
	  <para>Sammeln Sie erneut die Dateiinformationen aus
	    <filename>/dev</filename>, diesmal in der Datei
	    <filename>/var/tmp/dev2.out</filename> ein.  Vergleichen Sie
	    beide Dateien und suchen Sie nach Ger&auml;tedateien, die nicht
	    erstellt wurden.  Sie sollten keine finden, aber es ist besser
	    das jetzt wirklich zu kontrollieren:</para>

	  <screen>&prompt.root; <userinput>diff /var/tmp/dev.out /var/tmp/dev2.out</userinput></screen>

	  <para>Wenn es doch fehlende Eintr&auml;ge gibt, sind dies
	    wahrscheinlich fehlende Ger&auml;te f&uuml;r Slices.  Diese
	    k&ouml;nnen Sie mit einem Befehl wie dem folgenden
	    wiederherstellen:</para>

	  <screen>&prompt.root; <userinput>sh MAKEDEV sd0s1</userinput></screen>

	  <para>Die genauen Ger&auml;te k&ouml;nnen bei Ihnen
	    nat&uuml;rlich andere sein.</para>
	</step>
      </procedure>
    </sect2>

    <sect2>
      <title>Aktualisieren Sie <filename>/stand</filename></title>

      <note>
	<para>Dieser Schritt wurde nur der Vollst&auml;ndigkeit wegen
	  aufgenommen.  Sie k&ouml;nnen ihn komplett auslassen.
	  Ab &os;&nbsp;5.2 werden beim Lauf von
	  <command>make installworld</command> automatisch
	  aktuelle statisch &uuml;bersetzte Programme im Verzeichnis
	  <filename>/rescue</filename> installiert.  Daher ist
	  es &uuml;berfl&uuml;ssig, <filename>/stand</filename>
	  zu aktualisieren (das ab &os;&nbsp;6.0 ohnehin nicht
	  mehr existiert).</para>
      </note>

      <para>Der Vollst&auml;ndigkeit halber wollen Sie vielleicht auch die
        Dateien in <filename>/stand</filename> aktualisieren.  Alle Dateien
	in diesem Verzeichnis sind Hardlinks zu
	<filename>/stand/sysinstall</filename>.  Dieses Programm ist
	statisch gelinkt, so dass es unabh&auml;ngig von den Dateien
	in anderen Dateisystemen, insbesondere <filename>/usr</filename>,
	ist.</para>

      <screen>&prompt.root; <userinput>cd /usr/src/release/sysinstall</userinput>
&prompt.root; <userinput>make all install</userinput></screen>
    </sect2>

    <sect2>
      <title>Booten</title>

      <para>Sie sind nun am Ende der Prozedur angelangt.  Nachdem Sie sich
        davon &uuml;berzeugt haben, dass Ihr System funktioniert,
	booten Sie das System mit &man.shutdown.8;:</para>

      <screen>&prompt.root; <userinput>shutdown -r now</userinput></screen>
    </sect2>

    <sect2>
      <title>Ende</title>

      <para>Herzlichen Gl&uuml;ckwunsch!  Sie haben gerade erfolgreich Ihr
        &os; System aktualisiert.</para>

      <para>Es ist &uuml;brigens leicht einen Teil des Systems
        wiederherzustellen, f&uuml;r den Fall, dass Ihnen ein kleiner
	Fehler unterlaufen ist.  Wenn Sie beispielsweise w&auml;hrend des
	Updates oder Abgleichs <filename>/etc/magic</filename> aus Versehen
	gel&ouml;scht haben, wird &man.file.1; nicht mehr funktionieren.
	In diesem Fall k&ouml;nnen Sie das Problem mit dem folgenden
	Kommando beheben:</para>

	<screen>&prompt.root; <userinput>cd /usr/src/usr.bin/file</userinput>
&prompt.root; <userinput/make all install/</screen>
    </sect2>

    <sect2>
      <title>Fragen</title>

      <qandaset>
	<qandaentry>
	  <question>
	    <para>Muss ich wirklich immer alles neu bauen, wenn sich
	      etwas ge&auml;ndert hat?</para>
	  </question>

	  <answer>
	    <para>Darauf gibt es keine einfache Antwort.  Was zu tun ist,
	      h&auml;ngt von den &Auml;nderungen ab.  Es lohnt
	      wahrscheinlich nicht, alles neu zu bauen, wenn sich bei einem
	      <application>CVSup</application>-Lauf nur die folgenden
	      Dateien ge&auml;ndert haben:</para>

	    <screen><filename>src/games/cribbage/instr.c</filename>
<filename>src/games/sail/pl_main.c</filename>
<filename>src/release/sysinstall/config.c</filename>
<filename>src/release/sysinstall/media.c</filename>
<filename>src/share/mk/bsd.port.mk</filename></screen>

	    <para>In diesem Fall k&ouml;nnen Sie in die entsprechenden
	      Unterverzeichnisse wechseln und dort <command>make all
	      install</command> ausf&uuml;hren.  Wenn sich allerdings etwas
	      Wichtiges, wie <filename>src/lib/libc/stdlib</filename>,
	      ge&auml;ndert hat, sollten Sie die Welt oder
	      mindestens die statisch gelinkten Teile des Systems (sowie
	      Ihre statisch gelinkten Erg&auml;nzungen) neu bauen.</para>

	    <para>Letztendlich ist das Ihre Entscheidung.  Sie sind
	      vielleicht damit zufrieden, das System alle zwei Wochen neu
	      zu bauen und in der Zwischenzeit die anfallenden
	      &Auml;nderungen zu sammeln.  Wenn Sie sich zutrauen, alle
	      Abh&auml;ngigkeiten zu erkennen, bauen Sie vielleicht auch
	      nur die ge&auml;nderten Sachen neu.</para>

	    <para>Das h&auml;ngt nat&uuml;rlich auch noch davon ab, wie oft
	      Sie ein Update durchf&uuml;hren wollen und ob Sie &os.stable;
	      oder &os.current; benutzen.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Der Bau bricht mit vielen
	      <errorname>Signal 11</errorname>-Fehlern (oder anderen
	      Signalnummern) ab.  Was ist da passiert?</para>
	  </question>
	  <indexterm><primary>Signal 11</primary></indexterm>

	  <answer>
	    <para>Normalerweise zeigen diese Meldungen Hardwarefehler an.
	      Ein Neubau der Welt ist ein guter Belastungstest f&uuml;r
	      Ihre Hardware und zeigt oft Probleme mit dem Speicher auf.
	      Dies &auml;u&szlig;ert sich darin, dass der Kompiler
	      mit dem Erhalt von seltsamen Signalen abbricht.</para>

	    <para>Es liegt garantiert ein Hardwarefehler vor, wenn ein
	      neuer &Uuml;bersetzungslauf an einer anderen Stelle
	      abbricht.</para>

	    <para>In diesem Fall k&ouml;nnen Sie nur einzelne Komponenten
	      Ihres Systems tauschen, um zu bestimmen, welche Komponente den
	      Fehler verursacht.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Kann ich <filename>/usr/obj</filename> l&ouml;schen, wenn
	      ich fertig bin?</para>
	  </question>

	  <answer>
	    <para>Kurze Antwort: Ja.</para>

	    <para>In <filename>/usr/obj</filename> werden alle Dateien
	      abgelegt, die w&auml;hrend der &Uuml;bersetzungsphase erstellt
	      wurden.  Dieses Verzeichnis wird in einem der ersten Schritte
	      der Bauprozedur entfernt.  Es macht daher
	      wenig Sinn, dieses Verzeichnis zu behalten und Sie setzen
	      eine Menge Plattenplatz, momentan ungef&auml;hr 340&nbsp;MB,
	      frei, wenn Sie es l&ouml;schen.</para>

	    <para>Wenn Sie allerdings genau wissen, was Sie tun, k&ouml;nnen
	      Sie diesen Schritt bei <command>make buildworld</command>
	      auslassen.  Nachfolgende Bauprozeduren werden dadurch erheblich
	      schneller, da die meisten Quelldateien nicht mehr neu
	      &uuml;bersetzt werden.  Daf&uuml;r k&ouml;nnen aber subtile
	      Abh&auml;ngigkeitsprobleme entstehen, die dazu f&uuml;hren,
	      dass der Bau auf merkw&uuml;rdige Weise abbrechen kann.
	      Dies f&uuml;hrt h&auml;ufig zu unn&ouml;tigen Diskussionen auf
	      den &os; Mailinglisten, wenn sich jemand &uuml;ber einen
	      kaputten Bau beschwert, aber nicht sieht, dass er
	      Probleme hat, weil er eine Abk&uuml;rzung genommen hat.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Kann ein abgebrochener Bau weitergef&uuml;hrt
	      werden?</para>
	  </question>

	  <answer>
	    <para>Das h&auml;ngt davon ab, wieweit der Bauprozess
	      fortgeschritten ist.</para>

	    <para><emphasis>&Uuml;blicherweise</emphasis> werden
	      essentielle Werkzeuge, wie &man.gcc.1; und &man.make.1;,
	      und die Systembibliotheken w&auml;hrend des Bauprozesses
	      neu erstellt (dies ist aber keine allgemein g&uuml;ltige
	      Regel).  Die neu erstellen Werkzeuge und Bibliotheken werden
	      dann benutzt, um sich selbst noch einmal zu bauen, und wieder
	      installiert.  Anschlie&szlig;end wird das Gesamtsystem mit
	      den neu erstellten Systemdateien gebaut.</para>

	    <para>Wenn Sie sich im letzten Schritt befinden und Sie wissen,
	      dass Sie dort sind, weil Sie durch die Ausgaben, die Sie
	      ja sichern, der Bauprozedur gesehen haben, k&ouml;nnen Sie
	      mit ziemlicher Sicherheit den Bau weiterf&uuml;hren:</para>

	    <screen><emphasis>&hellip; Fehler beheben &hellip;</emphasis>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make -DNOCLEAN all</userinput></screen>

	    <para>Die Variable <makevar>NOCLEAN</makevar> verhindert,
	      dass <command>make buildworld</command> die vorher erstellten
	      Dateien l&ouml;scht.</para>

	    <para>Das Sie sich im letzten Schritt der Bauprozedur
	      befinden, erkennen Sie daran, dass Sie in der Ausgabe die
	      folgenden Zeilen finden:</para>

	      <screen>--------------------------------------------------------------
Building everything..
--------------------------------------------------------------</screen>

	    <para>Wenn Sie diese Meldung nicht finden, oder sich nicht sicher
	      sind, dann ist es besser, noch einmal ganz von Vorne
	      anzufangen.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Wie kann ich den Bauprozesss beschleunigen?</para>
          </question>

          <answer>
	    <itemizedlist>
	      <listitem>
		<para>Bauen Sie im Single-User-Modus.</para>
	      </listitem>

	      <listitem>
		<para>Legen Sie <filename>/usr/src</filename> und
		  <filename>/usr/obj</filename> in getrennte Dateisysteme auf
		  unterschiedliche Festplatten.  Benutzen Sie nach
		  M&ouml;glichkeit auch getrennte Platten-Controller.</para>
	      </listitem>

	      <listitem>
		<para>Noch besser ist es, diese Dateisysteme auf mehrere
		  Festplatten mit &man.ccd.4; zu verteilen.</para>
	      </listitem>

	      <listitem>
		<para>Bauen Sie die <quote>profiled</quote>-Bibliotheken,
		  die Sie wahrscheinlich sowieso nicht brauchen, nicht.
		  <filename>/etc/make.conf</filename> sollte dazu
		  <literal>NOPROFILE=true</literal> enthalten.</para>
	      </listitem>

	      <listitem>
		<para>Setzen Sie die <makevar>CFLAGS</makevar> in
		  <filename>/etc/make.conf</filename> auf <option>-O
		    -pipe</option>.  Die Optimierungsstufe
		  <option>-O2</option> ist deutlich langsamer und die
		  Performance-Unterschiede zwischen <option>-O</option> und
		  <option>-O2</option> sind vernachl&auml;ssigbar klein.
		  <option>-pipe</option> veranlasst den Kompiler Pipes
		  anstelle von Dateien f&uuml;r die Kommunikation zu
		  benutzen.  Dies spart einige Plattenzugriffe, geht aber
		  auf Kosten des Speichers.</para>
	      </listitem>

	      <listitem>
		<para>Benutzen Sie
		  <option>-j<replaceable>n</replaceable></option>, um
		  mehrere Prozesse parallel laufen zu lassen.
		  Normalerweise beschleunigt dies den Bauprozess
		  unabh&auml;ngig davon, ob Sie ein Einprozessor oder
		  Mehrprozessor System einsetzen.</para>
	      </listitem>

	      <listitem>
		<para>Sie k&ouml;nnen das Dateisystem
		  <filename>/usr/src</filename> mit der Option
		  <option>noatime</option> einh&auml;ngen.  Dies
		  verhindert, dass die Zugriffszeiten der Dateien
		  aktualisiert werden (eine Information, die Sie vielleicht
		  gar nicht brauchen).</para>

		<screen>&prompt.root; <userinput>mount -u -o noatime /usr/src</userinput></screen>

		<warning>
		  <para>Das Beispiel geht davon aus, dass sich
		    <filename>/usr/src</filename> auf einem separaten
		    Dateisystem befindet.  Wenn das nicht der Fall ist,
		    weil das Verzeichnis beispielsweise Teil des
		    <filename>/usr</filename> Dateisystems ist,
		    m&uuml;ssen Sie anstelle von
		    <filename>/usr/src</filename> den Mountpoint des
		    Dateisystems angeben.</para>
		</warning>
	      </listitem>

	      <listitem>
		<para>Das Dateisystem, in dem sich
		  <filename>/usr/obj</filename> befindet, kann mit der
		  Option <option>async</option> eingehangen werden.  Dies
		  bewirkt, dass Schreibzugriffe auf die Platte
		  asynchron stattfinden, das hei&szlig;t ein Schreibzugriff
		  ist sofort beendet, die Daten werden allerdings erst einige
		  Sekunden sp&auml;ter geschrieben.  Dadurch k&ouml;nnen
		  Schreibzugriffe zusammengefasst werden, was einen
		  erheblichen Geschwindigkeitszuwachs mit sich bringen
		  kann.</para>

		<warning>
		  <para>Beachten Sie, dass dies Ihr Dateisystem
		    anf&auml;lliger f&uuml;r Fehler macht.  Im Fall eines
		    Stromausfalls besteht eine erh&ouml;hte
		    Wahrscheinlichkeit, dass das Dateisystem beim
		    Start der Maschine zerst&ouml;rt ist.</para>

		  <para>Wenn sich <filename>/usr/obj</filename> auf einem
		    extra Dateisystem befindet, ist das kein Problem.  Wenn
		    sich allerdings auf diesem Dateisystem noch andere
		    wertvolle Daten befinden, stellen Sie sicher, dass
		    Sie aktuelle Sicherungen besitzen.</para>
		</warning>

		<screen>&prompt.root; <userinput>mount -u -o async /usr/obj</userinput></screen>

		<warning>
		  <para>Ersetzen Sie <filename>/usr/obj</filename> durch
		    den Mountpoint des entsprechenden Dateisystems, wenn es
		    sich nicht auf einem eigenen Dateisystem
		    befindet.</para>
		</warning>
	      </listitem>
	    </itemizedlist>
	  </answer>
	</qandaentry>

        <qandaentry>
          <question>
	    <para>Was mache ich, wenn etwas nicht funktioniert?</para>
          </question>

          <answer>
	    <para>Stellen Sie sicher, dass sich in Ihrer Umgebung
	      keine Reste eines vorherigen Baus befinden.  Das geht ganz
	      einfach:</para>

            <screen>&prompt.root; <userinput>chflags -R noschg /usr/obj/usr</userinput>
&prompt.root; <userinput>rm -rf /usr/obj/usr</userinput>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make cleandir</userinput>
&prompt.root; <userinput>make cleandir</userinput></screen>

	    <para>Ja, <command>make cleandir</command> muss wirklich
	      zweimal aufgerufen werden.</para>

	    <para>Nachdem Sie aufger&auml;umt haben, starten Sie den
	      Bauprozess wieder mit <command>make
	        buildworld</command>.</para>

	    <para>Wenn Sie immer noch Probleme haben, schicken Sie die
	      Fehlermeldungen und die Ausgabe von <command>uname
	        -a</command> an die Mailingliste &a.de.questions;.  Bereiten
	      Sie sich darauf vor, weitere Fragen zu Ihrer Umgebung zu
	      beantworten.</para>
          </answer>
        </qandaentry>
      </qandaset>
    </sect2>
  </sect1>

  <sect1 id="small-lan">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Mike</firstname>
	  <surname>Meyer</surname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Installation mehrerer Maschinen</title>

    <para>Wenn Sie mehrere Maschinen besitzen, die Sie alle auf dem
      gleichen Stand halten wollen, ist es eine Verschwendung von
      Ressourcen, die Quellen auf jeder Maschine vorzuhalten und zu
      &uuml;bersetzen.  Die L&ouml;sung dazu ist, eine Maschine den
      Gro&szlig;teil der Arbeit durchf&uuml;hren zu lassen und den anderen
      Maschinen das Ergebnis mit NFS zur Verf&uuml;gung zu stellen.  Dieser
      Abschnitt zeigt Ihnen wie das geht.</para>

    <sect2 id="small-lan-preliminaries">
      <title>Voraussetzungen</title>

      <para>Stellen Sie zuerst eine Liste der Maschinen zusammen, die auf
        demselben Stand sein sollen.  Wir nennen diese Maschinen die
	<emphasis>Baugruppe</emphasis>.  Jede dieser Maschinen kann mit
	einem eigenen Kernel laufen, doch sind die Programme des Userlands
	auf allen Maschinen gleich.  W&auml;hlen Sie aus der Baugruppe eine
	Maschine aus, auf der der Bau durchgef&uuml;hrt wird, den
	<emphasis>Bau-Master</emphasis>.  Dies sollte eine Maschine sein,
	die &uuml;ber die n&ouml;tigen Ressourcen f&uuml;r
	<command>make buildworld</command> und
	<command>make installworld</command> verf&uuml;gt.
	Sie brauchen auch eine
	<emphasis>Testmaschine</emphasis>, auf der Sie die Updates testen,
	bevor Sie sie in Produktion installieren.  Dies sollte eine
	Maschine, eventuell der Bau-Master, sein, die &uuml;ber einen
	l&auml;ngeren Zeitraum nicht zur Verf&uuml;gung stehen kann.</para>

      <para>Alle Maschinen der Baugruppe m&uuml;ssen
        <filename>/usr/obj</filename> und <filename>/usr/src</filename> von
	derselben Maschine an gleichem Ort einh&auml;ngen.  Idealerweise
	befinden sich die beiden Verzeichnisse auf dem Bau-Master auf
	verschiedenen Festplatten, sie k&ouml;nnen allerdings auch auf dem
	Bau-Master &uuml;ber NFS zur Verf&uuml;gung gestellt werden.  Wenn
	Sie mehrere Baugruppen haben, sollte sich
	<filename>/usr/src</filename> auf einem Bau-Master befinden und
	&uuml;ber NFS f&uuml;r den Rest der Maschinen zur Verf&uuml;gung
	gestellt werden.</para>

      <para>Stellen Sie sicher, dass
        <filename>/etc/make.conf</filename> auf allen Maschinen einer
	Baugruppe mit der Datei des Bau-Masters &uuml;bereinstimmt.  Der
	Bau-Master muss jeden Teil des Systems bauen, den irgendeine
	Maschine der Baugruppe ben&ouml;tigt.  Auf dem Bau-Master
	m&uuml;ssen in <filename>/etc/make.conf</filename> alle zu bauenden
	Kernel mit der Variablen <makevar>KERNCONF</makevar> bekannt gegeben
	werden.  Geben Sie dabei den Kernel des Bau-Masters zuerst an.
	F&uuml;r jeden zu bauenden Kernel muss auf dem Bau-Master die
	entsprechende Konfigurationsdatei unter
	<filename>/usr/src/sys/<replaceable>arch</replaceable>/conf</filename>
	abgelegt werden.</para>
    </sect2>

    <sect2>
      <title>Installation des Basissystems</title>

      <para>Nach diesen Vorbereitungen k&ouml;nnen Sie mit dem Bau
        beginnen.  Bauen Sie auf dem Bau-Master, wie in <xref
	linkend="make-buildworld"> beschrieben, den Kernel und die Welt,
	installieren Sie aber nichts.  Wechseln Sie auf die Testmaschine
	und installieren Sie den gerade gebauten Kernel.  Wenn diese
	Maschine <filename>/usr/src</filename> und
	<filename>/usr/obj</filename> &uuml;ber NFS bekommt, m&uuml;ssen
	Sie das Netzwerk im Single-User-Modus aktivieren und die beiden
	Dateisysteme einh&auml;ngen.  Am einfachsten ist dies, wenn Sie
	auf der Testmaschine ausgehend vom Mehrbenutzermodus mit
	<command>shutdown now</command> in den Single-User-Modus wechseln.
	Sie k&ouml;nnen dann mit der normalen Prozedur den neuen Kernel
	und das System installieren und anschlie&szlig;end
	<command>mergemaster</command> laufen lassen.  Wenn Sie damit
	fertig sind, k&ouml;nnen Sie die Maschine wieder in den
	Mehrbenutzermodus booten.</para>

      <para>Nachdem Sie sichergestellt haben, dass die Testmaschine
        einwandfrei funktioniert, wiederholen Sie diese Prozedur f&uuml;r
	jede Maschine in der Baugruppe.</para>
    </sect2>

    <sect2>
      <title>Die Ports-Sammlung</title>

      <para>Dasselbe Verfahren k&ouml;nnen Sie auch f&uuml;r die
        Ports-Sammlung anwenden.  Zuerst m&uuml;ssen alle Maschinen einer
	Baugruppe <filename>/usr/ports</filename> von derselben Maschine
	&uuml;ber NFS zur Verf&uuml;gung gestellt bekommen.  Setzen Sie
	dann ein Verzeichnis f&uuml;r die Quellen auf, das sich alle
	Maschinen teilen.  Dieses Verzeichnis k&ouml;nnen Sie in
	<filename>/etc/make.conf</filename> mit der Variablen
	<makevar>DISTDIR</makevar> angeben.  Das Verzeichnis sollte
	f&uuml;r den Benutzer beschreibbar sein, auf den der Benutzer
	<username>root</username> vom NFS Subsystem abgebildet wird.  Jede
	Maschine sollte noch <makevar>WRKDIRPREFIX</makevar> auf ein
	lokales Bauverzeichnis setzen.  Wenn Sie vorhaben, Pakete zu bauen
	und zu verteilen, sollten Sie <makevar>PACKAGES</makevar> auf ein
	Verzeichnis mit den gleichen Eigenschaften wie
	<makevar>DISTDIR</makevar> setzen.</para>
    </sect2>
  </sect1>
</chapter>
<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->

