<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde$
     basiert auf: r54686
-->
<chapter xmlns="http://docbook.org/ns/docbook"
  xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0"
  xml:id="updating-upgrading">

  <info>
    <title>&os; aktualisieren</title>

    <authorgroup>
      <author>
	<personname>
	  <firstname>Jim</firstname>
	  <surname>Mock</surname>
	</personname>
	<contrib>Umstrukturiert und aktualisiert von </contrib>
      </author>
      <!-- Mar 2000 -->
    </authorgroup>

    <authorgroup>
      <author>
	<personname>
	  <firstname>Jordan</firstname>
	  <surname>Hubbard</surname>
	</personname>
	<contrib>Im Original von </contrib>
      </author>

      <author>
	<personname>
	  <firstname>Poul-Henning</firstname>
	  <surname>Kamp</surname>
	</personname>
      </author>

      <author>
	<personname>
	  <firstname>John</firstname>
	  <surname>Polstra</surname>
	</personname>
      </author>

      <author>
	<personname>
	  <firstname>Nik</firstname>
	  <surname>Clayton</surname>
	</personname>
      </author>
    </authorgroup>

    <authorgroup>
      <author>
	<personname>
	  <firstname>Martin</firstname>
	  <surname>Heinen</surname>
	</personname>
	<contrib>Übersetzt von </contrib>
      </author>
    </authorgroup>
  </info>

  <sect1 xml:id="updating-upgrading-synopsis">
    <title>Übersicht</title>

    <para>&os; wird zwischen einzelnen Releases ständig weiter
      entwickelt.  Manche Leute bevorzugen die offiziellen
      Release-Versionen, während andere wiederum lieber auf dem
      aktuellen Stand der Entwicklung bleiben möchten.  Wie dem auch
      sei, sogar offizielle Release-Versionen werden oft mit
      Sicherheitsaktualisierungen und anderen kritischen
      Fehlerbereinigungen versorgt.  Unabhängig von der eingesetzten
      Version bringt &os; alle nötigen Werkzeuge mit, um das System
      aktuell zu halten und es innerhalb verschiedener Versionen zu
      aktualisieren.  Dieses Kapitel beschreibt, wie man einem
      Entwicklungssystem folgen kann, sowie die grundlegenden
      Werkzeuge um &os; zu aktualisieren.</para>

    <para>Nachdem Sie dieses Kapitel gelesen haben, werden Sie</para>

    <itemizedlist>
      <listitem>
	<para>wissen, wie das System mit
	  <application>freebsd-update</application> oder
	  <application>Subversion</application> aktualisiert
	  wird.</para>
      </listitem>

      <listitem>
	<para>wissen, wie man das aktuell installierte System mit
	  einer ursprünglichen Version vergleicht.</para>
      </listitem>

      <listitem>
	<para>wissen, wie die installierte Dokumentation mit
	  <application>Subversion</application> oder
	  Dokumentations-Ports
          <!-- oder <application>Docsnap</application> -->
	  aktualisiert wird.</para>
      </listitem>

      <listitem>
	<para>den Unterschied zwischen den beiden Entwicklungszweigen
	  &os.stable; und &os.current; kennen.</para>
      </listitem>

      <listitem>
	<para>wissen, wie das komplette Basissystem neu gebaut und
	  installiert wird.</para>
      </listitem>
    </itemizedlist>

    <para>Bevor Sie dieses Kapitel lesen, sollten Sie</para>

    <itemizedlist>
      <listitem>
	<para>das Netzwerk richtig konfiguriert haben
	  (<xref linkend="advanced-networking"/>).</para>
      </listitem>

      <listitem>
	<para>wissen, wie Software Dritter installiert wird
	  (<xref linkend="ports"/>).</para>
      </listitem>
    </itemizedlist>

    <note>
      <para>In diesem Kapitel wird <command>svnlite</command>
	benutzt, um die &os; Quellen zu beziehen und zu
	aktualisieren.  Alternativ kann auch der Port oder das Paket
	<package>devel/subversion</package> installiert werden.</para>
    </note>
  </sect1>

  <sect1 xml:id="updating-upgrading-freebsdupdate">
    <info>
      <title>&os;-Update</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	  </personname>
	  <contrib>Geschrieben von </contrib>
	</author>
      </authorgroup>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Colin</firstname>
	    <surname>Percival</surname>
	  </personname>
	  <contrib>Basierend auf Mitschriften von </contrib>
	</author>
      </authorgroup>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Benedict</firstname>
	    <surname>Reuschling</surname>
	  </personname>
	  <contrib>Übersetzt von </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm><primary>Updating and Upgrading</primary></indexterm>
    <indexterm>
      <primary>freebsd-update</primary>
      <see>updating-upgrading</see>
    </indexterm>

    <para>Das zeitnahe Einspielen von Sicherheitsaktualisierungen und
      die Aktualisierung des Betriebssystems sind wichtige Aspekte der
      Systemadministration.  &os; enthält das Werkzeug
      <command>freebsd-update</command>, mit dem Sie diese beiden
      Aufgaben erfüllen können.</para>

    <para>Dieses Werkzeug ermöglicht die Anwendung von
      Sicherheitsaktualisierungen im Binärformat auf das &os;
      Basissystem, ohne dieses neu zu übersetzen und zu installieren.
      Die Aktualisierungen im Binärformat sind für alle Architekturen
      und Versionen verfügbar, welche vom &os; Sicherheitsteam
      unterstützt werden.  Eine Liste der unterstützten Versionen und
      der <foreignphrase>End-of-Life</foreignphrase>-Daten ist unter
      <uri xlink:href="https://www.FreeBSD.org/security/">
	https://www.FreeBSD.org/security/</uri> aufgeführt.</para>

    <para><command>freebsd-update</command> unterstützt auch die
      Aktualisierung des Betriebssystems auf eine neuere Unterversion
      sowie eine Aktualisierung auf einen anderen Release-Zweig.
      Bevor Sie auf eine neue Version aktualisieren, sollten Sie die
      aktuellen Ankündigungen zu dem Release gelesen haben, da diese
      wichtige Informationen zu dem entsprechenden Release enthalten.
      Ankündigungen finden Sie unter <uri
	xlink:href="https://www.FreeBSD.org/releases/">
	https://www.FreeBSD.org/releases/</uri>.</para>

    <note>
      <para>Wenn eine <command>crontab</command> existiert, welche die
	Eigenschaften von &man.freebsd-update.8; verwendet, muss diese
	deaktiviert werden, bevor das Betriebssystem aktualisiert
	wird.</para>
    </note>

    <para>Dieser Abschnitt beschreibt die Verwendung der
      Konfigurationsdatei von <command>freebsd-update</command>.  Es
      wird gezeigt wie Sie Sicherheitsaktualisierungen einspielen,
      oder wie Sie das Betriebssystem auf neuere Haupt- und
      Unterversionen aktualisieren können.</para>

    <sect2 xml:id="freebsdupdate-config-file">
      <title>Die Konfigurationsdatei</title>

      <para>In der Regel muss die Konfigurationsdatei von
	<command>freebsd-update</command> nicht bearbeitet werden.
	Manche Benutzer möchten die Standard-Konfigurationsdatei
	<filename>/etc/freebsd-update.conf</filename> trotzdem
	anpassen, um bessere Kontrolle über den gesamten Prozess zu
	besitzen.  Die Kommentare in dieser Datei beschreiben die
	verfügbaren Optionen, jedoch benötigen die folgenden ein paar
	zusätzliche Erklärungen:</para>

      <programlisting># Components of the base system which should be kept updated.
Components world kernel</programlisting>

      <para>Dieser Parameter kontrolliert, welche Teile von &os; auf
	dem aktuellen Stand gehalten werden sollen.  In der
	Voreinstellung wird das gesamte Basissystem sowie der Kernel
	aktualisiert.  Es können auch einzelne Komponenten, wie
	<literal>src/base</literal> oder <literal>src/sys</literal>,
	angegeben werden.  Die beste Einstellung ist, diese Option so
	zu belassen, da eine Änderung es bedingt, dass man als
	Benutzer jede Komponente auflisten muss, die aktualisiert
	werden soll.  Dies könnte katastrophale Folgen nach sich
	ziehen, da der Quellcode und die Binärdateien dadurch nicht
	mehr synchron wären.</para>

      <programlisting># Paths which start with anything matching an entry in an IgnorePaths
# statement will be ignored.
IgnorePaths /boot/kernel/linker.hints</programlisting>

      <para>Fügen Sie Pfade wie <filename>/bin</filename> oder
	<filename>/sbin</filename> hinzu, um diese speziellen
	Verzeichnisse während des Aktualisierungsprozesses unberührt
	zu lassen.  Diese Option kann verwendet werden, um zu
	verhindern, dass <command>freebsd-update</command> lokale
	Änderungen überschreibt.</para>

      <programlisting># Paths which start with anything matching an entry in an UpdateIfUnmodified
# statement will only be updated if the contents of the file have not been
# modified by the user (unless changes are merged; see below).
UpdateIfUnmodified /etc/ /var/ /root/ /.cshrc /.profile</programlisting>

      <para>Diese Option aktualisiert nur unmodifizierte
	Konfigurationsdateien in den angegebenen Verzeichnissen.  Jede
	Änderung, die der Benutzer daran vorgenommen hat, wird die
	automatische Aktualisierung dieser Dateien verhindern.  Es
	gibt eine weitere Option
	<literal>KeepModifiedMetadata</literal>, die
	<command>freebsd-update</command> instruiert, die Änderungen
	während der Zusammenführung zu speichern.</para>

      <programlisting># When upgrading to a new &os; release, files which match MergeChanges
# will have any local changes merged into the version from the new release.
MergeChanges /etc/ /var/named/etc/ /boot/device.hints</programlisting>

      <para>Eine Liste von Verzeichnissen mit Konfigurationsdateien,
	in denen <command>freebsd-update</command> Zusammenführungen
	versuchen soll.  Dieser Verschmelzungsprozess von Dateien ist
	eine Serie von &man.diff.1;-Korrekturen, ähnlich wie
	&man.mergemaster.8;, aber mit weniger Optionen.  Die
	Änderungen werden entweder akzeptiert, oder öffnen einen
	Editor, oder <command>freebsd-update</command> bricht ab.  Im
	Zweifelsfall sichern Sie <filename>/etc</filename> und
	akzeptieren einfach die Änderungen.  Lesen Sie
	&man.mergemaster.8;, um Informationen über
	<command>mergemaster</command> zu erhalten.</para>

      <programlisting># Directory in which to store downloaded updates and temporary
# files used by &os; Update.
# WorkDir /var/db/freebsd-update</programlisting>

      <para>In diesem Verzeichnis werden alle Korrekturen und
	temporären Dateien abgelegt.  Im Falle einer
	Versionsaktualisierung sollte diesem Verzeichnis mindestens
	ein Gigabyte Festplattenspeicher zur Verfügung stehen.</para>

      <programlisting># When upgrading between releases, should the list of Components be
# read strictly (StrictComponents yes) or merely as a list of components
# which *might* be installed of which &os; Update should figure out
# which actually are installed and upgrade those (StrictComponents no)?
# StrictComponents no</programlisting>

      <para>Wenn diese Option auf <literal>yes</literal> gesetzt ist,
	wird <command>freebsd-update</command> annehmen, dass die
	<literal>Components</literal>-Liste vollständig ist und nicht
	versuchen, Änderungen ausserhalb dieser Liste zu tätigen.
	Tatsächlich wird <command>freebsd-update</command> versuchen,
	jede Datei zu aktualisieren, die zu der
	<literal>Components</literal>-Liste gehört.</para>
    </sect2>

    <sect2 xml:id="freebsdupdate-security-patches">
      <title>Sicherheitskorrekturen anwenden</title>

      <para>Das Einspielen von &os; Sicherheitskorrekturen wurde
	dahingehend vereinfacht, dass der Administrator nun das
	gesamte System mit <command>freebsd-update</command> auf
	dem aktuellen Stand halten kann.  Weitere Informationen zu
	&os; Sicherheitshinweisen finden Sie in <xref
	  linkend="security-advisories"/>.</para>

      <para>Sicherheitskorrekturen für &os; können wie folgt
	heruntergeladen und installiert werden.  Das erste
	Kommando prüft, ob noch ausstehende Korrekturen verfügbar
	sind, und wenn dass der Fall ist, zeigt es welche Dateien
	davon betroffen wären.  Das zweite Kommando wird die
	Korrekturen auf das System anwenden.</para>

      <screen>&prompt.root; <userinput>freebsd-update fetch</userinput>
&prompt.root; <userinput>freebsd-update install</userinput></screen>

      <para>Wenn während der Aktualisierung Korrekturen am Kernel
	angewendet werden, muss das System neu gestartet werden, damit
	der korrigierte Kernel gebootet wird.  Wenn die Korrekturen
	auf laufende Binärdateien angewendet werden, sollten die
	betroffenen Anwendungen neu gestartet werden, damit die
	korrigierte Version der Binärdatei geladen wird.</para>

      <note>
	<para>Im Regelfall muss der Benutzer darauf vorbereitet sein,
	  das System neu zu starten.  Um herauszufinden, ob ein
	  Neustart durch eine Aktualisierung des Kernels erforderlich
	  ist, führen Sie die Befehle
	  <command>freebsd-version -k</command> und
	  <command>uname -r</command> aus.  Ist die Ausgabe dieser
	  Befehle unterschiedlich, ist ein Neustart des Systems
	  erforderlich.</para>
      </note>

      <para>Mit dem folgenden Eintrag in
	<filename>/etc/crontab</filename> wird das System einmal
	täglich nach Aktualisierungen suchen:</para>

      <programlisting>@daily                                  root    freebsd-update cron</programlisting>

      <para>Wenn Korrekturen existieren, werden diese automatisch
	heruntergeladen, aber nicht eingespielt.  Der <systemitem
	  class="username">root</systemitem>-Benutzer bekommt eine
	Nachricht, damit die Korrekturen überprüft und mit
	<command>freebsd-update install</command> manuell installiert
	werden können.</para>

      <para>Wenn etwas schief geht, kann
	<command>freebsd-update</command> den letzten Satz von
	Änderungen mit folgendem Befehl rückgängig machen:</para>

      <screen>&prompt.root; <userinput>freebsd-update rollback</userinput>
Uninstalling updates... done.</screen>

      <para>Wie bereits erwähnt, sollte das System neu gestartet
	werden, wenn der Kernel oder ein Kernelmodul verändert wurde.
	Betroffene Anwendungen sollten neu gestartet werden, wenn
	Binärdateien verändert wurden.</para>

      <para>Das <command>freebsd-update</command>-Werkzeug kann nur
	den <filename>GENERIC</filename>-Kernel automatisch
	aktualisieren.  Wenn ein angepasster Kernel verwendet wird,
	muss dieser neu erstellt und installiert werden, nachdem
	<command>freebsd-update</command> die Aktualisierungen
	durchgeführt hat.  Der voreingestellte Kernel ist
	<emphasis>GENERIC</emphasis>.  Benutzen Sie das Kommando
	&man.uname.1; um dies zu überprüfen.</para>

      <note>
	<para>Behalten Sie immer eine Kopie des
	  <filename>GENERIC</filename>-Kernels in
	  <filename>/boot/GENERIC</filename>.  Das wird bei der
	  Diagnose von verschiedenen Problemen sowie bei der
	  Durchführung von Versionsaktualisierungen eine große Hilfe
	  sein.  Im <xref linkend="freebsd-update-custom-kernel-9x"/>
	  wird beschrieben, wie Sie eine Kopie des
	  <filename>GENERIC</filename>-Kernels bekommen.</para>
      </note>

      <para>Solange die Standardkonfiguration in
	<filename>/etc/freebsd-update.conf</filename> nicht geändert
	wurde, wird <command>freebsd-update</command> die
	aktualisierten Quellcodedateien des Kernels zusammen mit dem
	Rest der Neuerungen installieren.  Die erneute Übersetzung und
	Installation eines neuen, angepassten Kernels kann dann auf
	die übliche Art und Weise durchgeführt werden.</para>

      <para>Die Aktualisierungen, die über
	<command>freebsd-update</command> verteilt werden, betreffen
	nicht immer den Kernel.  Es ist nicht notwendig, den
	angepassten Kernel neu zu erstellen, wenn die Kernelquellen
	nicht durch <command>freebsd-update install</command> geändert
	wurden.  Allerdings wird <command>freebsd-update</command>
	immer <filename>/usr/src/sys/conf/newvers.sh</filename>
	aktualisieren.  Der aktuelle Patch-Level, der mit der
	<literal>-p</literal>-Nummer bei <command>uname -r</command>
	ausgegeben wird, wird aus dieser Datei ausgelesen.  Die
	Neuinstallation des angepassten Kernels, selbst wenn sich
	daran nichts geändert hat, erlaubt es
	<command>uname</command>, den aktuellen Patch-Level des
	Systems korrekt wiederzugeben.  Dies ist besonders hilfreich,
	wenn mehrere Systeme gewartet werden, da es eine schnelle
	Einschätzung der installierten Aktualisierungen in jedem
	einzelnen System ermöglicht.</para>
    </sect2>

    <sect2 xml:id="freebsdupdate-upgrade">
      <title>Aktualisierungen an Haupt- und Unterversionen</title>

      <para>Aktualisierungen einer Unterversion von &os; zur nächsten
	Version ist beispielsweise die Aktualisierung von
	&os;&nbsp;9.0 auf &os;&nbsp;9.1.  Die Aktualisierung einer
	Hauptversion ist beispielsweise von &os;&nbsp;9.X auf
	&os;&nbsp;10.X.  Beide Arten der Aktualisierungen können
	durchgeführt werden, indem man
	<command>freebsd-update</command> eine Release-Version als
	Ziel übergibt.</para>

      <note>
	<para>Wenn auf dem System ein angepasster Kernel eingesetzt
	  wird, stellen Sie sicher, dass eine Kopie des
	  <filename>GENERIC</filename>-Kernels in
	  <filename>/boot/GENERIC</filename> existiert.  Im
	  <xref linkend="freebsd-update-custom-kernel-9x"/> wird
	  beschrieben, wie Sie eine Kopie des
	  <filename>GENERIC</filename>-Kernels bekommen.</para>
      </note>

      <para>Wenn Sie das folgende Kommando auf einem System
	mit &os;&nbsp;9.0 ausführen, wird das System auf
	&os;&nbsp;9.1 aktualisiert:</para>

      <screen>&prompt.root; <userinput>freebsd-update -r 9.1-RELEASE upgrade</userinput></screen>

      <para>Nach der Eingabe des Kommandos überprüft
	<command>freebsd-update</command> die Konfigurationsdatei und
	das aktuelle System, um die nötigen Informationen für die
	Systemaktualisierung zu sammeln.  Eine Bildschirmausgabe wird
	anzeigen, welche Komponenten erkannt und welche nicht erkannt
	wurden.  Zum Beispiel:</para>

      <screen>Looking up update.FreeBSD.org mirrors... 1 mirrors found.
Fetching metadata signature for 9.0-RELEASE from update1.FreeBSD.org... done.
Fetching metadata index... done.
Inspecting system... done.

The following components of FreeBSD seem to be installed:
kernel/smp src/base src/bin src/contrib src/crypto src/etc src/games
src/gnu src/include src/krb5 src/lib src/libexec src/release src/rescue
src/sbin src/secure src/share src/sys src/tools src/ubin src/usbin
world/base world/info world/lib32 world/manpages

The following components of FreeBSD do not seem to be installed:
kernel/generic world/catpages world/dict world/doc world/games
world/proflibs

Does this look reasonable (y/n)? <userinput>y</userinput></screen>

      <para>An diesem Punkt wird <command>freebsd-update</command>
	versuchen, alle notwendigen Dateien für die Aktualisierung
	herunter zu laden.  In manchen Fällen wird der Benutzer mit
	Fragen konfrontiert, um festzustellen, was installiert werden
	soll oder auf welche Art und Weise fortgesetzt werden
	soll.</para>

      <para>Wenn ein angepasster Kernel benutzt wird, produziert der
	vorherige Schritt eine Warnung ähnlich zu der
	folgenden:</para>

      <screen>WARNING: This system is running a "
<replaceable>MYKERNEL</replaceable>" kernel, which is not a
kernel configuration distributed as part of FreeBSD 9.0-RELEASE.
This kernel will not be updated: you MUST update the kernel manually
before running "/usr/sbin/freebsd-update install"</screen>

      <para>Diese Warnung kann an dieser Stelle problemlos ignoriert
	werden.  Der aktualisierte
	<filename>GENERIC</filename>-Kernel wird als ein
	Zwischenschritt im Aktualisierungsprozess verwendet.</para>

      <para>Nachdem alle Korrekturen auf das lokale System
	heruntergeladen wurden, werden diese eingespielt.  Dieser
	Prozess kann eine gewisse Zeit in Anspruch nehmen, abhängig
	von der Geschwindigkeit und Auslastung der Maschine.
	Konfigurationsdateien werden ebenfalls zusammengefügt.  Dieser
	Teil der Prozedur verlangt einige Benutzereingaben, da eine
	Datei möglicherweise von Hand zusammengefasst werden muss oder
	ein Editor erscheint auf dem Bildschirm zum manuellen
	bearbeiten.  Die Ergebnisse von jeder erfolgreichen
	Zusammenfassung werden dem Benutzer angezeigt, während der
	Prozess weiter läuft.  Eine fehlgeschlagene oder ignorierte
	Zusammenfassung wird den Prozess sofort beenden.  Benutzer
	sollten eine Sicherung von <filename>/etc</filename> anlegen
	und wichtige Dateien später manuell vereinen, beispielsweise
	<filename>master.passwd</filename> oder
	<filename>group</filename>.</para>

      <note>
	<para>Das System ist zu diesem Zeitpunkt noch nicht
	  verändert worden, da alle Korrekturen und Vereinigungen
	  in einem anderen Verzeichnis vorgenommen wurden.  Wenn
	  alle Korrekturen erfolgreich eingespielt, alle
	  Konfigurationsdateien zusammengefügt wurden und es den
	  Anschein hat, dass der Prozess problemlos verlaufen wird,
	  müssen die Änderungen vom Anwender noch angewendet und auf
	  die Platte geschrieben werden:</para>

	<screen>&prompt.root; <userinput>freebsd-update install</userinput></screen>
      </note>

      <para>Der Kernel und die Module werden zuerst aktualisiert.
	Wenn das System einen angepassten Kernel verwendet, benutzen
	Sie &man.nextboot.8;, um den Kernel für den nächsten
	Neustart auf <filename>/boot/GENERIC</filename> zu
	setzen:</para>

      <screen>&prompt.root; <userinput>nextboot -k GENERIC</userinput></screen>

      <warning>
	<para>Bevor das System mit dem
	  <filename>GENERIC</filename>-Kernel neu gestartet wird,
	  vergewissern Sie sich, dass für den Neustart alle
	  benötigten Treiber enthalten sind.  Falls auf die
	  Maschine aus der Ferne zugegriffen wird, stellen Sie
	  sicher, dass das System ordnungsgemäß an das Netzwerk
	  angeschlossen ist.  Achten Sie besonders darauf, dass wenn
	  der angepasste Kernel Funktionalität beinhaltet, die
	  normalerweise von Kernelmodulen zur Verfügung gestellt
	  werden, dass diese temporär über
	  <filename>/boot/loader.conf</filename> in den
	  <filename>GENERIC</filename>-Kernel übernommen werden.
	  Zudem wird empfohlen, nicht benötigte Dienste, eingehängte
	  Platten und verbundene Netzlaufwerke zu deaktivieren, bis
	  der Aktualisierungsprozess abgeschlossen ist.</para>
      </warning>

      <para>Die Maschine sollte nun mit dem aktualisierten Kernel
	neu gestartet werden:</para>

      <screen>&prompt.root; <userinput>shutdown -r now</userinput></screen>

      <para>Sobald das System wieder hochgefahren ist, muss
	<command>freebsd-update</command> erneut gestartet werden.
	Da der Zustand des Prozesses zuvor gesichert wurde, wird
	<command>freebsd-update</command> nicht von vorne
	beginnen, sondern mit der nächsten Phase fortfahren und
	alle alten Bibliotheken und Objektdateien löschen.</para>

      <screen>&prompt.root; <userinput>freebsd-update install</userinput></screen>

      <note>
	<para>Abhängig davon, ob irgendwelche Bibliotheksversionen
	  erhöht wurden, kann es sein, dass nur zwei
	  Installationsphasen anstatt drei durchlaufen werden.</para>
      </note>

      <para>Die Aktualisierung ist nun abgeschlossen.  Wenn es sich
	hierbei um eine Aktualisierung auf eine neue Hauptversion
	handelt, müssen alle Ports und Pakete neu installiert
	werden.  Dieser Vorgang wird in <xref
	  linkend="freebsdupdate-portsrebuild"/> beschrieben.</para>

      <sect3 xml:id="freebsd-update-custom-kernel-9x">
	<title>Angepasste Kernel unter &os;&nbsp;9.X und
	  später</title>

	<para>Stellen Sie vor der ersten Benutzung von
	  <command>freebsd-update</command> sicher, dass eine
	  Kopie des <filename>GENERIC</filename>-Kernels in
	  <filename>/boot/GENERIC</filename> existiert.  Wenn ein
	  angepasster Kernel erstmalig gebaut wurde, ist der Kernel
	  in <filename>/boot/kernel.old</filename> der
	  <filename>GENERIC</filename>-Kernel.  Benennen Sie
	  dieses Verzeichnis einfach in
	  <filename>/boot/GENERIC</filename> um.</para>

	<para>Wenn bereits mehrfach ein angepasster Kernel gebaut
	  wurde, oder nicht bekannt ist wie oft ein angepasster
	  Kernel gebaut wurde, behalten Sie besser eine Kopie des
	  <filename>GENERIC</filename>-Kernels, welcher mit der
	  aktuellen Version des Betriebssystems übereinstimmt.
	  Wenn ein direkter Zugriff auf die Maschine möglich ist,
	  kann eine Kopie des <filename>GENERIC</filename>-Kernels
	  von den Installationsmedien installiert werden:</para>

	<screen>&prompt.root; <userinput>mount /cdrom</userinput>
&prompt.root; <userinput>cd /cdrom/usr/freebsd-dist</userinput>
&prompt.root; <userinput>tar -C/ -xvf kernel.txz boot/kernel/kernel</userinput></screen>

	<para>Alternativ kann der
	  <filename>GENERIC</filename>-Kernel aus den Quellen neu
	  gebaut und installiert werden:</para>

	<screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make kernel __MAKE_CONF=/dev/null SRCCONF=/dev/null</userinput></screen>

	<para>Damit dieser Kernel als
	  <filename>GENERIC</filename>-Kernel von
	  <command>freebsd-update</command> erkannt wird, darf
	  die <filename>GENERIC</filename>-Konfigurationsdatei
	  in keiner Weise geändert worden sein.  Es wird ebenfalls
	  empfohlen, dass dieser ohne irgendwelche speziellen
	  Optionen erstellt wird.</para>

	<para>Der Neustart in den
	  <filename>GENERIC</filename>-Kernel ist nicht notwendig,
	  da <command>freebsd-update</command> lediglich
	  <filename>/boot/GENERIC</filename> benötigt.</para>
      </sect3>

      <sect3 xml:id="freebsdupdate-portsrebuild">
	<title>Aktualisierung der Pakete nach einem Upgrade auf eine
	  Hauptversion</title>

	<para>In der Regel funktionieren nach einer Aktualisierung
	  einer Unterversion die installierten Anwendungen weiterhin
	  problemlos.  Neue Hauptversionen verwenden jedoch andere
	  Binärschnittstellen (<acronym>ABI</acronym>s), was dazu
	  führt, dass die meisten Anwendungen von Drittherstellern
	  nicht mehr funktionieren.  Nach der Aktualisierung auf eine
	  Hauptversion, müssen alle installierten Ports und Pakete
	  aktualisiert werden.  Benutzen Sie
	  <command>pkg upgrade</command> um Pakte zu aktualisieren.
	  Installierte Ports können Sie mit einem Werkzeug wie
	  <package>ports-mgmt/portmaster</package> aktualisiert
	  werden.</para>

	<para>Bei einer erzwungenen Aktualisierung aller installierten
	  Pakete, werden diese durch eine neue Version aus dem
	  Repository ersetzt, sogar dann, wenn sich die Versionsnummer
	  nicht erhöht hat.  Dieser Schritt ist erforderlich, da sich
	  die <acronym>ABI</acronym> bei einer Aktualisierung der
	  Hauptversion von &os; verändert hat.  Eine erzwungene
	  Aktualisierung aller installierten Pakete geschieht wie
	  folgt:</para>

	<screen>&prompt.root; <userinput>pkg-static upgrade -f</userinput></screen>

	<para>Ein Neubau der installierten Ports führen Sie mit
	  diesem Kommando durch:</para>

	<screen>&prompt.root; <userinput>portmaster -af</userinput></screen>

	<para>Dieser Befehl wird die Konfigurationen für jede
	  Anwendung anzeigen, und der Benutzer hat die Möglichkeit,
	  die Optionen anzupassen.  Wenn Sie ausschließlich die
	  voreingestellten Optionen verwenden möchten, verwenden Sie
	  mit dem obigen Befehl den Parameter
	  <option>-G</option>.</para>

	<para>Sobald dies abgeschlossen ist, beenden Sie den
	  Aktualisierungsprozess mit einem letzten Aufruf von
	  <command>freebsd-update</command>.  Geben Sie den folgenden
	  Befehl ein, um alle losen Enden des Aktualisierungsprozesses
	  miteinander zu verknüpfen:</para>

	<screen>&prompt.root; <userinput>freebsd-update install</userinput></screen>

	<para>Wenn der <filename>GENERIC</filename>-Kernel temporär
	  Verwendung fand, ist dies der richtige Zeitpunkt, einen
	  neuen, angepassten Kernel nach den Anweisungen in <xref
	    linkend="kernelconfig"/> zu bauen und zu
	  installieren.</para>

	<para>Booten Sie anschließend die Maschine in die neue
	  &os;-Version.  Der Aktualisierungsprozess ist damit
	  abgeschlossen.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="freebsdupdate-system-comparison">
      <title>Vergleich des Systemzustands</title>

      <para><command>freebsd-update IDS</command> kann verwendet
	werden, um den Zustand der installierten &os;-Version
	gegenüber einer bekannten und funktionierenden Kopie zu
	vergleichen.  Dieses Kommando vergleicht die aktuelle Version
	von Systemwerkzeugen, Bibliotheken sowie Konfigurationsdateien
	und kann als integriertes Intrusion Detection System
	(<acronym>IDS</acronym>) benutzt werden.</para>

      <warning>
	<para>Dieses Programm ist kein Ersatz für ein echtes
	  <acronym>IDS</acronym>-System wie
	  <package>security/snort</package>.  Da
	  <command>freebsd-update</command> Daten auf der Festplatte
	  speichert, ist die Möglichkeit von Verfälschungen
	  offensichtlich.  Obwohl diese Möglichkeit durch die
	  Verwendung von <varname>kern.securelevel</varname> oder die
	  Speicherung von Daten auf einem Nur-Lese Dateisystem
	  eingedämmt werden kann, besteht eine bessere Lösung darin,
	  das System gegen ein gesichertes Medium, wie eine
	  <acronym>DVD</acronym> oder einen externen, separat
	  aufbewahrten <acronym>USB</acronym>-Plattenspeicher, zu
	  vergleichen.  Eine alternative Methode zur Bereitstellung
	  von <acronym>IDS</acronym>-Funktionaliäten wird in
	  <xref linkend="security-ids"/> beschrieben.</para>
      </warning>

      <para>Beginnen Sie den Vergleich, indem Sie das Programm starten
	und eine Ausgabedatei festlegen:</para>

      <screen>&prompt.root; <userinput>freebsd-update IDS &gt;&gt; <replaceable>outfile.ids</replaceable></userinput></screen>

      <para>Das System wird nun überprüft.  Dabei wird eine lange
	Liste von Dateien zusammen mit den
	<acronym>SHA256</acronym>-Hashwerten der Release-Version und
	den Werten des aktuell installierten Systems, in die
	angegebene Ausgabedatei geschrieben.</para>

      <para>Die Zeilen in der Ausgabe sind extrem lang, aber das
	Ausgabeformat kann einfach verarbeitet werden.  Um
	beispielsweise eine Liste von allen Dateien zu erhalten, die
	sich vom aktuellen Release unterscheiden, geben Sie das
	folgende Kommando ein:</para>

      <screen>&prompt.root; <userinput>cat outfile.ids | awk '{ print $1 }' | more</userinput>
/etc/master.passwd
/etc/motd
/etc/passwd
/etc/pf.conf</screen>

      <para>Diese Beispielausgabe wurde abgeschnitten, da noch viele
	weitere Dateien vorhanden sind.  Einige Dateien wurden auf
	natürliche Art verändert.  <filename>/etc/passwd</filename>
	wurde beispielsweise geändert, wenn Benutzer zum System
	hinzugefügt wurden.  Kernelmodule können sich unterscheiden,
	wenn <command>freebsd-update</command> diese aktualisiert hat.
	Um bestimmte Dateien oder Verzeichnisse auszuschließen, fügen
	Sie diese an die <literal>IDSIgnorePaths</literal>-Option in
	<filename>/etc/freebsd-update.conf</filename> an.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="updating-upgrading-documentation">
    <info>
      <title>Aktualisieren der Dokumentationssammlung</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Benedict</firstname>
	    <surname>Reuschling</surname>
	  </personname>
	  <contrib>Übersetzt von </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm><primary>Updating and Upgrading</primary></indexterm>

    <indexterm>
      <primary>Documentation</primary>
      <see>Updating and Upgrading</see>
    </indexterm>

    <para>Dokumentation ein wichtiger Bestandteil des &os;
      Betriebssystems.  Obwohl eine aktuelle Version der &os;
      Dokumentation jederzeit auf der &os; Webseite (<link
	xlink:href="&url.base;/doc/">
	https://www.freebsd.org/doc/</link>) verfügbar ist, kann es
      nützlich sein, eine lokale Kopie der &os; Webseite, Handbücher,
      <acronym>FAQ</acronym> und Artikel zu haben.</para>

    <para>Dieser Abschnitt beschreibt, wie Sie die &os; Dokumentation
      über die Quellen oder die &os; Ports-Sammlung aktuell
      halten.</para>

    <para>Informationen zum Bearbeiten und Einreichen von Korrekturen
      finden Sie in der <link
	xlink:href="&url.doc.langbase;/books/fdp-primer">Fibel für
	neue Mitarbeiter des
	&os;-Dokumentationsprojekts</link>.</para>

    <sect2 xml:id="updating-installed-documentation">
      <title>Die &os;-Dokumentation aus den Quellen
	installieren</title>

      <para>Der Bau der &os; Dokumentation aus den Quellen erfordert
	einige Werkzeuge, die nicht Teil des Basissystems sind.  Die
	erforderlichen Werkzeuge können über den Port oder das
	Paket <package>textproc/docproj</package> installiert
	werden.</para>

      <para>Benutzen Sie nach der Installation
	<application>svnlite</application>, um eine saubere Kopie der
	Dokumentationsquellen zu holen:</para>

      <screen>&prompt.root; <userinput>svnlite checkout https://svn.FreeBSD.org/doc/head /usr/doc</userinput></screen>

      <para>Es dauert eine Weile, bis die Quellen das allererste Mal
	heruntergeladen werden.  Lassen Sie den Vorgang laufen, bis es
	fertig ist.</para>

      <para>Zukünftige Aktualisierungen der Dokumentationsquellen
	können wie folgt durchgeführt werden:</para>

      <screen>&prompt.root; <userinput>svnlite update /usr/doc</userinput></screen>

      <para>Sobald ein aktueller Schnappschuss der
	Dokumentationsquellen nach <filename>/usr/doc</filename>
	heruntergeladen wurde, ist alles bereit für eine
	Aktualisierung der bestehenden Dokumentation.</para>

      <para>Eine komplette Aktualisierung aller Sprachen kann durch
	folgende Eingabe erreicht werden:</para>

      <screen>&prompt.root; <userinput>cd /usr/doc</userinput>
&prompt.root; <userinput>make install clean</userinput></screen>

      <para>Wenn nur eine Aktualisierung einer bestimmten Sprache
	gewünscht wird, kann <command>make</command> in einem
	sprachspezifischen Unterverzeichnis von
	<filename>/usr/doc</filename> aufgerufen werden:</para>

      <screen>&prompt.root; <userinput>cd /usr/doc/en_US.ISO8859-1</userinput>
&prompt.root; <userinput>make install clean</userinput></screen>

      <para>Alternativ kann der folgende Befehl in
	<filename>/usr/doc</filename> oder einem sprachspezifischen
	Unterverzeichnis abgesetzt werden, um die Dokumentation zu
	aktualisieren:</para>

      <screen>&prompt.root; <userinput>make update</userinput></screen>

      <para>Die zu installierenden Ausgabeformate können durch das
	Setzen von <varname>FORMATS</varname> angegeben werden:</para>

      <screen>&prompt.root; <userinput>cd /usr/doc</userinput>
&prompt.root; <userinput>make FORMATS='html html-split' install clean</userinput></screen>

      <para>Es existieren ein paar Optionen, welche den Prozess der
	Aktualisierung von Teilen der Dokumentation oder einer
	bestimmten Übersetzung erleichtern.  Diese Optionen können
	entweder systemweit in <filename>/etc/make.conf</filename>
	gesetzt, oder als Kommandozeilenoptionen an
	<command>make</command> übergeben werden.</para>

      <para>Zu den Optionen gehören:</para>

      <variablelist>
	<varlistentry>
	  <term><varname>DOC_LANG</varname></term>

	  <listitem>
	    <para>Eine Liste von Sprachen und Kodierungen, die gebaut
	      und installiert werden sollen, z.B.
	      <literal>en_US.ISO8859-1</literal>, um nur die englische
	      Dokumentation zu erhalten.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>FORMATS</varname></term>

	  <listitem>
	    <para>Ein einzelnes Format oder eine Liste von
	      Ausgabeformaten, das gebaut werden soll.  Momentan
	      werden <literal>html</literal>,
	      <literal>html-split</literal>, <literal>txt</literal>,
	      <literal>ps</literal> und <literal>pdf</literal>
	      unterstützt.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>DOCDIR</varname></term>

	  <listitem>
	    <para>Wohin die Dokumentation installiert werden soll.
	      Der Standardpfad ist
	      <filename>/usr/share/doc</filename>.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>Für weitere <command>make</command>-Variablen, die als
	systemweite Optionen in &os; unterstützt werden, lesen Sie
	&man.make.conf.5;.</para>
    </sect2>

    <sect2 xml:id="doc-ports-install-package">
      <info>
	<title>Die Dokumentation aus den Ports aktualisieren</title>

	<authorgroup>
	  <author>
	    <personname>
	      <firstname>Marc</firstname>
	      <surname>Fonvieille</surname>
	    </personname>
	    <contrib>Basierend auf der Arbeit von </contrib>
	  </author>
	</authorgroup>
      </info>

      <indexterm><primary>Updating and Upgrading</primary></indexterm>

      <indexterm>
	<primary>documentation package</primary>
	<see>Updating and Upgrading</see>
      </indexterm>

      <para>Im vorherigen Abschnitt wurde eine Methode gezeigt, wie
	die &os;-Dokumentation aus den Quellen gebaut werden kann.
	Dieser Abschnitt beschreibt eine alternative Methode, in der
	die Ports-Sammlung verwendet wird und die es
	ermöglicht:</para>

      <itemizedlist>
	<listitem>
	  <para>vorgefertigte Schnappschüsse der Dokumentation zu
	    installieren, ohne vorher die Werkzeugsammlung der
	    Dokumentation installieren zu müssen.</para>
	</listitem>

	<listitem>
	  <para>die Dokumentationsquellen durch das Ports-System
	    erstellen zu lassen, was die Schritte zum Auschecken und
	    Erstellen etwas erleichtert.</para>
	</listitem>
      </itemizedlist>

      <para>Diese Methoden der Aktualisierung der
	&os;-Dokumentation werden durch eine Menge von
	Dokumentations-Ports und Paketen unterstützt, die von
	&a.doceng; monatlich aktualisiert wird.  Diese sind in der
	&os; Ports-Sammlung unter der Kategorie <quote>docs</quote>
	gelistet (<link
	  xlink:href="http://www.freshports.org/docs/">
	  http://www.freshports.org/docs/</link>).</para>

      <para>Die Dokumentations-Ports sind wie folgt
	organisiert:</para>

      <itemizedlist>
	<listitem>
	  <para>Das Paket oder der Port
	    <package>misc/freebsd-doc-en</package> installiert die
	    englische Dokumentation.</para>
	</listitem>

	<listitem>
	  <para>Das Paket oder der Port
	    <package>misc/freebsd-doc-all</package> installiert die
	    komplette Dokumentation in allen verfügbaren
	    Sprachen.</para>
	</listitem>

	<listitem>
	  <para>Es gibt noch ein Paket oder einen Port für jede
	    Übersetzung, beispielsweise
	    <package>misc/freebsd-doc-hu</package> für die
	    ungarische Dokumentation.</para>
	</listitem>
      </itemizedlist>

      <para>Wenn Sie Pakete benutzen, wird die &os;-Dokumentation in
	allen verfügbaren Formaten der jeweiligen Sprache
	installiert.  Das folgende Beispiel wird das aktuelle Paket
	der ungarischen Dokumentation installieren:</para>

      <screen>&prompt.root; <userinput>pkg install hu-freebsd-doc</userinput></screen>

      <note>
	<para>Pakete verwenden ein Format, welches sich von dem
	  Namen des dazugehörigen Ports unterscheidet:
	  <literal><replaceable>lang</replaceable>-freebsd-doc</literal>.
	  <replaceable>lang</replaceable> entspricht hier der
	  Kurzform des Sprachcodes, z.B. <literal>hu</literal> für
	  Ungarisch, oder <literal>zh_cn</literal> für vereinfachtes
	  Chinesisch.</para>
      </note>

      <para>Um das Format der Dokumentation zu bestimmen, muss
	anstelle des Pakets der Port gebaut werden.  Das folgende
	Beispiel baut und installiert die englische
	Dokumentation:</para>

      <screen>&prompt.root; <userinput>cd /usr/ports/misc/freebsd-doc-en</userinput>
&prompt.root; <userinput>make install clean</userinput></screen>

      <para>Der Port enthält ein Konfigurationsmenü, in dem das
	Format ausgewählt werden kann.  In der Voreinstellung sind
	<literal>html-split</literal> und <literal>pdf</literal>
	ausgewählt.</para>

      <para>Alternativ können bei der Erstellung eines
	Dokumentations-Ports verschiedene
	<command>make</command>-Optionen angegeben werden.
	Dazu gehören:</para>

      <variablelist>
	<varlistentry>
	  <term><varname>WITH_HTML</varname></term>

	  <listitem>
	    <para>Erstellt das <acronym>HTML</acronym>-Format mit
	      einer einzigen <acronym>HTML</acronym>-Datei pro
	      Dokument.  Die formatierte Dokumentation wird als
	      Datei mit dem Namen <filename>article.html</filename>
	      oder <filename>book.html</filename> gespeichert.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>WITH_PDF</varname></term>

	  <listitem>
	    <para>Die formatierte Dokumentation wird als Datei
	      mit dem Namen <filename>article.pdf</filename> oder
	      <filename>book.pdf</filename> gespeichert.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>DOCBASE</varname></term>

	  <listitem>
	    <para>Legt den Pfad fest, wohin die Dokumentation
	      installiert werden soll.  Die Voreinstellung ist
	      <filename>/usr/local/share/doc/freebsd</filename>.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>Dieses Beispiel verwendet Variablen, um die ungarische
	Dokumentation als <acronym>PDF</acronym> in ein bestimmtes
	Verzeichnis zu installieren:</para>

      <screen>&prompt.root; <userinput>cd /usr/ports/misc/freebsd-doc-hu</userinput>
&prompt.root; <userinput>make -DWITH_PDF DOCBASE=share/doc/freebsd/hu install clean</userinput></screen>

      <para>Dokumentations-Ports oder -Pakete können nach den
	Anweisungen in <xref linkend="ports"/> aktualisiert werden.
	Beispielsweise aktualisiert das folgende Kommando die
	installierte ungarische Dokumentation mittels
	<package>ports-mgmt/portmaster</package> unter Verwendung
	von Paketen:</para>

      <screen>&prompt.root; <userinput>portmaster -PP hu-freebsd-doc</userinput></screen>
    </sect2>
  </sect1>

  <sect1 xml:id="current-stable">
    <title>Einem Entwicklungszweig folgen</title>

    <indexterm><primary>-CURRENT</primary></indexterm>
    <indexterm><primary>-STABLE</primary></indexterm>

    <para>&os; besitzt zwei Entwicklungszweige: &os.current; und
      &os.stable;.</para>

    <para>Dieser Abschnitt beschreibt beide Zweige sowie deren
      Interessengruppen und erläutert, wie ein System auf dem
      aktuellen Stand eines jeweiligen Zweiges gehalten wird.</para>

    <sect2 xml:id="current">
      <title>&os.current;</title>

      <para>&os.current; ist die allerneueste Entwicklung von &os;.
	Benutzer von &os.current; sollten über sehr gute technische
	Fähigkeiten verfügen.  Benutzer mit weniger technischen
	Fähigkeiten sollten stattdessen &os.stable; benutzen, wenn
	sie einem Entwicklungszweig folgen möchten.</para>

      <para>&os.current; besteht aus den neuesten Quellen des
	&os;-Systems und enthält Sachen, an denen gerade
	gearbeitet wird, experimentelle Änderungen und
	Übergangsmechanismen, die im nächsten offiziellen
	Release enthalten sein können oder nicht.  Obwohl &os.current;
	täglich von vielen Entwicklern gebaut wird, gibt es Zeiträume,
	in denen sich das System vielleicht nicht bauen lässt.  Diese
	Probleme werden so schnell wie möglich behoben, aber ob Sie
	mit &os.current; eine Katastrophe erleben oder neue Funktionen
	erhalten, kann von dem Zeitpunkt abhängen, an dem der
	Quelltext synchronisiert wurde.</para>

      <para>&os.current; wird hauptsächlich für drei
	Interessengruppen zur Verfügung gestellt:</para>

      <orderedlist>
	<listitem>
	  <para>Mitglieder der &os; Gemeinschaft, die aktiv an einem
	    Teil des Quellbaums arbeiten.</para>
	</listitem>

	<listitem>
	  <para>Mitglieder der &os; Gemeinschaft, die aktive Tester
	    sind.  Diese Personen sind bereit, Zeit in das Lösen von
	    Problemen zu investieren, Vorschläge zu Änderungen oder
	    der generellen Entwicklung von &os; zu machen und
	    Fehlerkorrekturen einzureichen.</para>
	</listitem>

	<listitem>
	  <para>Benutzer, die die Entwicklung im Auge behalten, oder
	    die Quellen zu Referenzzwecken benutzen wollen.  Diese
	    Gruppe macht auch Vorschläge oder steuert Quellcode
	    bei.</para>
	</listitem>
      </orderedlist>

      <para>&os.current; ist <emphasis>nicht</emphasis> der
	schnellste Weg, neue Funktionen vor dem offiziellen Release
	auszuprobieren.  Bedenken Sie, dass neue Funktionen noch
	nicht im vollen Umfang getestet wurden und daher
	höchstwahrscheinlich Fehler enthalten.  Es ist auch nicht
	der schnellste Weg, um an Fehlerbehebungen (engl.
	<foreignphrase>bug fixes</foreignphrase>) zu kommen.  Jede
	Fehlerbehebung führt mit gleicher Wahrscheinlichkeit neue
	Fehler ein, mit der sie alte behebt.  &os.current; wird in
	keiner Weise <quote>offiziell unterstützt</quote>.</para>

      <indexterm>
	<primary>-CURRENT</primary>
	<secondary>benutzen</secondary>
      </indexterm>

      <para>Um &os.current; zu folgen:</para>

      <orderedlist>
	<listitem>
	  <para>Lesen Sie die Mailinglisten &a.current.name; und
	    &a.svn-src-head.name;.  Dies ist
	    <emphasis>notwendig</emphasis>, um die Kommentare
	    über den akutellen Status des Systems und wichtige
	    Mitteilungen zum aktuellen Zustand von &os.current; zu
	    erfahren.</para>

	  <para>Die &a.svn-src-head.name; Mailingliste erfasst die
	    Commit-Logs für jede Änderung und enthält alle
	    relevanten Informationen zu möglichen
	    Seiteneffekten.</para>

	  <para>Um diese Listen zu abonnieren, besuchen Sie
	    &a.mailman.lists.link;, klicken Sie auf die gewünschte
	    Liste und folgen Sie den Anweisungen.  Wenn Sie die
	    Änderungen am gesamten Quellbaum verfolgen möchten,
	    abonnieren Sie die &a.svn-src-all.name; Liste.</para>
	</listitem>

	<listitem>
	  <para>Synchronisieren Sie die Quellen für &os.current;.
	    In der Regel wird <link linkend="svn">svnlite</link>
	    benutzt, um die Quellen für -CURRENT aus dem Zweig
	    <literal>head</literal> zu laden.  Verwenden Sie dazu
	    einen Subversion Spiegel aus <xref
	      linkend="svn-mirrors"/>.</para>
	</listitem>

	<listitem>
	  <para>Aufgrund der Größe des Repositories ist es
	    empfehlenswert, nur die gewünschten Teilbäume
	    auszuchecken.  Wenn Sie die Quellen einsetzen und
	    nicht nur darin lesen wollen, laden Sie sich die
	    <emphasis>kompletten</emphasis> Quellen von &os.current;
	    und nicht nur ausgesuchte Teile.</para>

	  <para>Lesen Sie <filename>/usr/src/Makefile</filename>
	    sehr aufmerksam und folgen Sie den Anweisungen in <xref
	      linkend="makeworld"/>.  Lesen Sie die
	    Mailingliste &a.current; und
	    <filename>/usr/src/UPDATING</filename>, um über
	    Änderungen im Installationsverfahren, die manchmal vor
	    der Einführung eines neuen Releases notwendig sind,
	    informiert zu sein.</para>
	</listitem>

	<listitem>
	  <para>Seien Sie aktiv!  Benutzer von &os.current; werden
	    aufgefordert ihre Verbesserungsvorschläge oder
	    Fehlerbehebungen einzureichen.  Verbesserungsvorschläge,
	    die Code enthalten, sind jederzeit herzlich
	    willkommen.</para>
	</listitem>
      </orderedlist>
    </sect2>

    <sect2 xml:id="stable">
      <title>&os.stable;</title>

      <para>&os.stable; ist der Entwicklungszweig, auf dem Releases
	erstellt werden.  Dieser Zweig ändert sich langsamer als
	&os.current; und alle Änderungen sollten zuvor in
	&os.current; ausgetestet sein.  Beachten Sie, dass dies
	<emphasis>immer noch</emphasis> ein Entwicklungszweig ist und
	daher zu jedem Zeitpunkt die Quellen von &os.stable;
	verwendbar sein können oder eben auch nicht.  &os.stable; ist
	Teil des Entwicklungsprozesses und nicht für Endanwender
	gedacht.  Benutzer, die nicht über die notwendigen Ressourcen
	zum Testen verfügen, sollten stattdessen ein aktuelles Release
	von &os; benutzen.</para>

      <para>Wer daran interessiert ist den Entwicklungsprozess von
	&os; zu verfolgen oder dazu beizutragen, insbesondere im
	Hinblick auf das nächste Release, der sollte es in Erwägung
	ziehen &os.stable; zu benutzen.</para>

      <para>Obwohl wir versuchen sicherzustellen, dass sich
	&os.stable; jederzeit übersetzen lässt und lauffähig ist,
	können wir dafür keine Garantie übernehmen.  Auch wenn
	Neuentwicklungen in &os.current; stattfinden, ist es jedoch
	so, dass mehr Leute &os.stable; anstelle von &os.current;
	benutzen und es daher unvermeidlich ist, dass Fehler und
	Grenzfälle erst in &os.stable; auffallen.  Aus diesen Gründen
	empfehlen wir, &os.stable; <emphasis>nicht</emphasis>
	blindlings zu benutzen.</para>

      <para>Um &os.stable; zu folgen:</para>

      <indexterm>
	<primary>-STABLE</primary>
	<secondary>benutzen</secondary>
      </indexterm>

      <orderedlist>
	<listitem>
	  <para>Lesen Sie die Mailingliste &a.stable.name;, damit Sie
	    über Abhängigkeiten beim Bau von &os.stable; und Dinge,
	    die besondere Aufmerksamkeit erfordern, informiert sind.
	    Umstrittene Fehlerbehebungen oder Änderungen werden von
	    den Entwicklern auf dieser Liste bekannt gegeben.  Dies
	    erlaubt es den Benutzern, Einwände gegen die
	    vorgeschlagenen Änderungen vorzubringen.</para>

	  <para>Abonnieren Sie die passende
	    <application>svn</application>-Liste für den jeweiligen
	    Zweig, den Sie verfolgen.  Wenn Sie beispielsweise den
	    Zweig 9-STABLE verfolgen, lesen Sie
	    &a.svn-src-stable-9.name;.  Diese Liste enthält zu jeder
	    Änderung das Commit-Log, das Informationen zu möglichen
	    Seiteneffekten enthält.</para>

	  <para>Um diese Listen zu abonnieren, besuchen Sie die Seite
	    &a.mailman.lists.link;.  Klicken Sie auf die gewünschte
	    Liste und folgen Sie den Anweisungen.  Wenn Sie daran
	    interessiert sind, Änderungen am gesamten Quellbaum zu
	    verfolgen, abonnieren Sie &a.svn-src-all.name;.</para>
	</listitem>

	<listitem>
	  <para>Wenn Sie ein neues System installieren und dazu einen
	    der monatlich aus &os.stable; erzeugten Snapshots
	    verwenden wollen, sollten Sie zuerst <link
	      xlink:href="&url.base;/snapshots">
	      www.freebsd.org/snapshots"</link> auf aktuelle
	    Informationen überprüfen.  Alternativ können Sie auch das
	    neueste &os.stable;-Release von den <link
	      linkend="mirrors">&os; Spiegeln</link> beziehen.</para>

	  <para>Um ein bestehendes &os;-System auf &os.stable; zu
	    aktualisieren, benutzen
	    Sie <link linkend="svn">svn</link>
	    <indexterm>
	      <primary>Subversion</primary>
	    </indexterm> um den gewünschten
	    Entwicklungs- oder Release-Zweig auszuchecken.  Die
	    Zweige, wie beispielsweise <literal>stable/9</literal>,
	    sind unter <link xlink:href="&url.base;/releng/">
	      www.freebsd.org/releng</link> aufgeführt.</para>
	</listitem>

	<listitem>
	  <para>Lesen Sie <filename>/usr/src/Makefile</filename> sehr
	    aufmerksam bevor Sie &os.stable;
	    <indexterm>
	      <primary>-STABLE</primary>
	    </indexterm> aktualisieren und folgen Sie den Anweisungen
	    in <xref linkend="makeworld"/>.  Lesen Sie die
	    Mailingliste &a.stable; und
	    <filename>/usr/src/UPDATING</filename>, um über Änderungen
	    im Installationsablauf, die manchmal vor der Einführung
	    eines neuen Releases notwendig sind, informiert zu
	    sein.</para>
	</listitem>
      </orderedlist>
    </sect2>
  </sect1>

  <sect1 xml:id="makeworld">
    <title>&os; aus den Quellen aktualisieren</title>

    <para>Das Aktualisieren von &os; aus den Quellen bietet im
      Vergleich zu binären Updates mehrere Vorteile.  Der Quellcode
      kann mit Optionen gebaut werden, um die Vorteile von
      spezifischer Hardware zu nutzen.  Teile des Basissystems können
      mit veränderten Einstellungen gebaut, oder falls nicht
      gewünscht, auch ganz ausgelassen werden.
      Dieser Prozess dauert zwar länger als die Aktualisierung mit
      binären Updates, ermöglicht aber eine vollständige Anpassung, um
      eine individuelle Version von &os; zu erstellen.</para>

    <sect2 xml:id="updating-src-quick-start">
      <title>Schnellstartanleitung</title>

      <para>Diese kurze Referenz zeigt die typischen Schritte um &os;
	aus den Quellen zu aktualisieren.  Spätere Abschnitte
	beschreiben die Prozedur im Detail.</para>

      <procedure>
	<step>
	  <title>Aktualisierung und Bauprozess</title>

	  <screen>&prompt.root; <userinput>svnlite update /usr/src</userinput>  <co xml:id="updating-src-qs-svnup"/>
<emphasis>check <filename>/usr/src/UPDATING</filename></emphasis>  <co xml:id="updating-src-qs-review-updating"/>
&prompt.root; <userinput>cd /usr/src</userinput>          <co xml:id="updating-src-qs-cd"/>
&prompt.root; <userinput>make -j<replaceable>4</replaceable> buildworld</userinput>  <co xml:id="updating-src-qs-buildworld"/>
&prompt.root; <userinput>make -j<replaceable>4</replaceable> kernel</userinput>      <co xml:id="updating-src-qs-kernel"/>
&prompt.root; <userinput>shutdown -r now</userinput>      <co xml:id="updating-src-qs-reboot"/>
&prompt.root; <userinput>cd /usr/src</userinput>          <co xml:id="updating-src-qs-cd2"/>
&prompt.root; <userinput>make installworld</userinput>    <co xml:id="updating-src-qs-installworld"/>
&prompt.root; <userinput>mergemaster -Ui</userinput>      <co xml:id="updating-src-qs-mergemaster"/>
&prompt.root; <userinput>shutdown -r now</userinput>      <co xml:id="updating-src-qs-shutdown"/></screen>

	  <calloutlist>
	    <callout arearefs="updating-src-qs-svnup">
	      <para>Holt die neueste Version der Quellen.
		<xref linkend="updating-src-obtaining-src"/> enthält
		weitere Informationen zum Aktualisieren und Bauen der
		Quellen.</para>
	    </callout>

	    <callout arearefs="updating-src-qs-review-updating">
	      <para><filename>/usr/src/UPDATING</filename> enthält
		Anweisungen für alle manuellen Schritte, die vor oder
		nach dem Bau der Quellen erforderlich sind.</para>
	    </callout>

	    <callout arearefs="updating-src-qs-cd">
	      <para>Wechsel in das Bauverzeichnis.</para>
	    </callout>

	    <callout arearefs="updating-src-qs-buildworld">
	      <para>Bau des Basissystems, mit Ausnahme des
		Kernels.</para>
	    </callout>

	    <callout arearefs="updating-src-qs-kernel">
	      <para>Bau und Installation des Kernels.  Dieser Schritt
		ist gleichbedeutend mit <command>make buildkernel
		  installkernel</command>.</para>
	    </callout>

	    <callout arearefs="updating-src-qs-installworld">
	      <para>Installation des Basissystems.</para>
	    </callout>

	    <callout arearefs="updating-src-qs-mergemaster">
	      <para>Aktualisierung und Zusammenführung der
		Konfigurationsdateien in
		<filename>/etc</filename>.</para>
	    </callout>

	    <callout arearefs="updating-src-qs-shutdown">
	      <para>Neustart des Systems mit dem neu erstellten
		Basissystem und Kernel.</para>
	    </callout>
	  </calloutlist>
	</step>
      </procedure>
    </sect2>

    <sect2 xml:id="updating-src-preparing">
      <title>Vorbereitungen zum Aktualisieren aus den Quellen</title>

      <para>Lesen Sie <filename>/usr/src/UPDATING</filename>.  Jeder
	manuelle Schritt, welcher vor oder nach der Aktualisierung
	erforderlich ist, wird in dieser Datei beschrieben.</para>
    </sect2>

    <sect2 xml:id="updating-src-obtaining-src">
      <title>Den Quellcode aktualisieren</title>

      <para>Der Quellcode von &os; befindet sich in
	<filename>/usr/src/</filename>.  Die bevorzugte Methode zur
	Aktualisierung dieser Quellen ist über das
	Versionskontrollsystem <application>Subversion</application>.
	Sie sollten sicherstellen, dass der Quellcode unter
	Versionskontrolle steht:</para>

      <screen>&prompt.root; <userinput>svnlite info /usr/src</userinput>
Path: /usr/src
Working Copy Root Path: /usr/src
...</screen>

      <para>Dies ist ein Hinweis darauf, dass
	<filename>/usr/src/</filename> unter Versionskontrolle steht
	und mit &man.svnlite.1; aktualisiert werden kann.</para>

      <screen xml:id="synching">&prompt.root; <userinput>svnlite update /usr/src</userinput></screen>

      <para>Dieser Vorgang kann einige Zeit in Anspruch nehmen, falls
	das Verzeichnis nicht zuletzt aktualisiert wurde.  Nach
	Beendigung ist der Quellcode aktuell und der im nächsten
	Abschnitt beschriebene Bauprozess kann beginnen.</para>

      <note xml:id="updating-src-obtaining-src-checkout">
	<title>Synchronisation der Quellen</title>

	<para>Meldet die Ausgabe
	  <literal>'/usr/src' is not a working copy</literal>, dann
	  fehlen entweder Dateien, oder das Verzeichnis wurde mit
	  einer anderen Methode aktualisiert.  Ein erneuter Checkout
	  der Quellen ist jetzt erforderlich.</para>

	<table xml:id="updating-src-obtaining-src-repopath">
	  <title>&os; Versionen und Repository-Pfade</title>

	  <tgroup cols="3">
	    <thead>
	      <row>
		<entry>Ausgabe von <command>uname -r</command></entry>
		<entry>Repository-Pfad</entry>
		<entry>Beschreibung</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><literal><replaceable>X.Y</replaceable>-RELEASE</literal></entry>
		<entry><literal>base/releng/</literal><replaceable>X.Y</replaceable></entry>
		<entry>Die Release-Version inklusive kritischer
		  Sicherheits- und Bugfix-Patches.  Dieser Zweig wird
		  für die meisten Benutzer empfohlen.</entry>
	      </row>

	      <row xml:id="STABLE">
		<entry><literal><replaceable>X.Y</replaceable>-STABLE</literal></entry>
		<entry><literal>base/stable/</literal><replaceable>X</replaceable></entry>
		<entry>
		  <para>Die Release-Version und alle weitere Versionen
		    auf diesem Zweig.
		    <emphasis>STABLE</emphasis> bezieht sich darauf,
		    dass die Binärschnittstelle
		    (<acronym>ABI</acronym>) sich nicht ändert, sodass
		    Anwendungen welche auf älteren Versionen erstellt
		    wurden weiterhin lauffähig sind.  Eine Anwendung,
		    welche für &os;&nbsp;10.1 übersetzt wurde, läuft
		    auch auf &os;&nbsp;10-STABLE.</para>

		  <para>STABLE-Zweige haben gelegentlich Fehler und
		    Inkompatibilitäten, welche den Benutzer
		    beeinträchtigen könnten.  In der Regel werden
		    diese Fehler aber zügig behoben.</para>
		</entry>
	      </row>

	      <row>
		<entry><literal><replaceable>X</replaceable>-CURRENT</literal></entry>
		<entry><literal>base/head/</literal></entry>
		<entry>Die neueste unveröffentlichte Version von
		  &os;.  Der CURRENT-Zweig kann viele Fehler und
		  Inkompatibilitäten enthalten und wird daher nur für
		  fortgeschrittene Benutzer empfohlen.</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>

	<para>Ermitteln Sie mit &man.uname.1; die verwendete
	  &os;-Version:</para>

	<screen>&prompt.root; <userinput>uname -r</userinput>
10.3-RELEASE</screen>

	<para>Basierend auf <xref
	    linkend="updating-src-obtaining-src-repopath"/> ist
	  <literal>base/releng/10.3</literal> der Repository-Pfad zur
	  Aktualisierung von <literal>10.3-RELEASE</literal>.  Dieser
	  Pfad wird beim Auschecken der Quellen benutzt:</para>

	<screen>&prompt.root; <userinput>mv /usr/src /usr/src.bak</userinput>  <co xml:id="updating-src-obtaining-src-mv"/>
&prompt.root; <userinput>svnlite checkout https://svn.freebsd.org/base/<replaceable>releng/10.3</replaceable> /usr/src</userinput>  <co xml:id="updating-src-obtaining-src-checkout-cmd"/></screen>

	<calloutlist>
	  <callout arearefs="updating-src-obtaining-src-mv">
	    <para>Verschiebt das alte Verzeichnis.  Wenn es keine
	      lokalen Änderungen in diesem Verzeichnis gibt, kann es
	      gelöscht werden.</para>
	  </callout>

	  <callout arearefs="updating-src-obtaining-src-checkout-cmd">
	    <para>Der Pfad aus <xref
		linkend="updating-src-obtaining-src-repopath"/> wird
	      der Repository-URL hinzugefügt.  Der dritte Parameter
	      ist das lokale Zielverzeichnis für den Quellcode.</para>
	  </callout>
	</calloutlist>
      </note>
    </sect2>

    <sect2 xml:id="updating-src-building">
      <title>Den Quellcode bauen</title>

      <para>Die Welt, also das gesamte
	Basissystem mit Ausnahme des Kernels, wird zuerst
	übersetzt, um aktuelle Werkzeuge zum Erstellen des
	Kernels bereitzustellen.  Anschließend wird der
	Kernel gebaut:</para>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make buildworld</userinput>
&prompt.root; <userinput>make buildkernel</userinput></screen>

      <para>Das Ergebnis wird in <filename>/usr/obj</filename>
	abgelegt.</para>

      <para>Dies sind die grundlegenden Schritte.  Weitere Optionen
	zur Kontrolle des Bauprozesses sind nachfolgend
	beschrieben.</para>

      <sect3 xml:id="updating-src-building-clean-build">
	<title>Umgebung für den Bauprozess säubern</title>

	<para>Einige Versionen von &os; hinterlassen bereits
	  übersetzten Code im temporären Objektverzeichnis
	  <filename>/usr/obj</filename>.  Dies kann nachfolgende
	  Bauprozesse beschleunigen, da Code, der nicht verändert
	  wurde, nicht neu übersetzt werden muss.  Um eine saubere
	  Umgebung für den Bauprozess zu schaffen, benutzen Sie
	  <buildtarget>cleanworld</buildtarget> bevor Sie mit dem Bau
	  beginnen.</para>

	<screen>&prompt.root; <userinput>make cleanworld</userinput></screen>
      </sect3>

      <sect3 xml:id="updating-src-building-jobs">
	<title>Anzahl der Prozesse einstellen</title>

	<para>Eine höhere Anzahl an Prozessen kann die
	  Geschwindigkeit auf Mehrprozessor-Systemen verbessern.
	  Die Anzahl der Kerne lässt sich mit
	  <command>sysctl hw.cpu</command> bestimmen.  Prozessoren
	  variieren ebenso, wie die verschiedenen Build-Systeme von
	  &os;.  Sie müssen daher mehrere Versuche starten um zu
	  sehen, wie die Anzahl der Prozesse die Geschwindigkeit
	  beeinflusst.  Als Ausgangspunkt können Sie die halbe bis
	  doppelte Anzahl der Kerne als Wert probieren.  Die Anzahl
	  der Prozesse wird mit <option>-j</option> angegeben.</para>

	<example xml:id="updating-src-building-jobs-example">
	  <title>Die Anzahl der Prozesse erhöhen</title>

	  <para>Das Basissystem und den Kernel mit vier Prozessen
	    bauen:</para>

	  <screen>&prompt.root; <userinput>make -j4 buildworld buildkernel</userinput></screen>
	</example>
      </sect3>

      <sect3 xml:id="updating-src-building-only-kernel">
	<title>Nur den Kernel erstellen</title>

	<para>Wenn sich der Quellcode verändert hat, muss ein
	  <buildtarget>buildworld</buildtarget> ausgeführt
	  werden.  Danach kann der Kernel mit
	  <buildtarget>buildkernel</buildtarget> übersetzt
	  werden.  Um lediglich den Kernel zu übersetzen:</para>

	<screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make buildkernel</userinput></screen>
      </sect3>

      <sect3 xml:id="updating-src-building-custom-kernel">
	<title>Einen angepassten Kernel erstellen</title>

	<para>Der &os; Standard-Kernel basiert auf einer
	  <emphasis>Konfigurationsdatei</emphasis> namens
	  <filename>GENERIC</filename>.  Der
	  <filename>GENERIC</filename>-Kernel enthält die
	  gängigsten Gerätetreiber und Optionen.  Manchmal ist es
	  aber sinnvoll oder gar notwendig, einen angepassten
	  Kernel zu erstellen, um Gerätetreiber oder Optionen
	  hinzuzufügen oder zu entfernen, um bestimmte Anforderungen
	  zu erfüllen.</para>

	<para>Zum Beispiel könnte jemand, der einen kleinen
	  eingebetteten Rechner mit eingeschränktem
	  <acronym>RAM</acronym> entwickelt, nicht benötigte
	  Gerätetreiber oder Optionen entfernen, um den Kernel etwas
	  kleiner zu machen.</para>

	<para>Die Kernelkonfigurationsdateien befinden sich in
	  <filename>/usr/src/sys/<replaceable>arch</replaceable>/conf/</filename>,
	  wobei <replaceable>arch</replaceable> die Ausgabe von
	  <command>uname -m</command> ist.  Auf den meisten Rechnern
	  ist dies <literal>amd64</literal>, demnach befinden sich die
	  Konfigurationsdateien in
	  <filename>/usr/src/sys/<replaceable>amd64</replaceable>/conf/</filename>.</para>

	<tip>
	  <para><filename>/usr/src</filename> kann aus Versehen
	    gelöscht oder neu erstellt werden.  Daher ist es
	    vorzuziehen, angepasste Kernelkonfigurationsdateien in
	    einen separaten Verzeichnis, wie bspw.
	    <filename>/root</filename> zu speichern und diese in das
	    <filename>conf</filename>-Verzeichnis zu verlinken.  Wenn
	    dieses Verzeichnis gelöscht oder überschrieben wird, kann
	    die Kernelkonfigurationsdatei einfach neu verknüpft
	    werden.</para>
	</tip>

	<para>Eine benutzerdefinierte Konfigurationsdatei kann durch
	  Kopieren der
	  <filename>GENERIC</filename>-Konfigurationsdatei erstellt
	  werden.  In diesem Beispiel ist der neue Kernel für einen
	  Speicherserver, heißt also
	  <filename>STORAGESERVER</filename>:</para>

	<screen>&prompt.root; <userinput>cp /usr/src/sys/amd64/conf/GENERIC /root/STORAGESERVER</userinput>
&prompt.root; <userinput>cd /usr/src/sys/amd64/conf</userinput>
&prompt.root; <userinput>ln -s /root/STORAGESERVER .</userinput></screen>

	<para>Jetzt kann <filename>/root/STORAGESERVER</filename>
	  bearbeitet werden.  Die Manualpage &man.config.5; zeigt,
	  wie Treiber und Optionen hinzugefügt oder entfernt
	  werden.</para>

	<para>Der angepasste Kernel wird mit der Variablen
	  <varname>KERNCONF</varname>, die auf die
	  Kernelkonfigurationsdatei verweist, übersetzt:</para>

	<screen>&prompt.root; <userinput>make buildkernel KERNCONF=STORAGESERVER</userinput></screen>
      </sect3>
    </sect2>

    <sect2 xml:id="updating-src-installing">
      <title>Installation des Codes</title>

      <para>Nachdem die Schritte <buildtarget>buildworld</buildtarget>
	und <buildtarget>buildkernel</buildtarget> abgeschlossen
	sind, wird der neue Kernel und die Welt installiert:</para>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make installkernel</userinput>
&prompt.root; <userinput>shutdown -r now</userinput>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make installworld</userinput>
&prompt.root; <userinput>shutdown -r now</userinput></screen>

      <para>Wenn ein angepasster Kernel erstellt wurde, muss
	zusätzlich die Variable <varname>KERNCONF</varname> gesetzt
	werden:</para>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make installkernel KERNCONF=STORAGESERVER</userinput>
&prompt.root; <userinput>shutdown -r now</userinput>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make installworld</userinput>
&prompt.root; <userinput>shutdown -r now</userinput></screen>
    </sect2>

    <sect2 xml:id="updating-src-completing">
      <title>Die Aktualisierung abschließen</title>

      <para>Ein paar abschließende Aufgaben beenden die
	Aktualisierung.  Alle Konfigurationsdateien werden mit den
	neuen Versionen zusammengeführt, veraltete Bibliotheken werden
	entfernt, dann wird das System neu gestartet.</para>

      <sect3 xml:id="updating-src-completing-merge-mergemaster">
	<title>Konfigurationsdateien mit
	  &man.mergemaster.8; zusammenführen</title>

	<para>&man.mergemaster.8; bietet einen einfachen Weg, um die
	  Konfigurationsdateien des Systems mit den neuen Versionen
	  dieser Dateien zusammenzuführen.</para>

	<para>Mit der Option <option>-Ui</option> aktualisiert
	  &man.mergemaster.8; automatisch Dateien, welche nicht vom
	  Benutzer verändert wurden und installiert neue Dateien, die
	  noch nicht vorhanden sind:</para>

	<screen>&prompt.root; <userinput>mergemaster -Ui</userinput></screen>

	<para>Wenn eine Datei manuell zusammengeführt werden muss,
	  erlaubt eine interaktive Anzeige, zu wählen, welche Teile
	  der Dateien beibehalten werden.  Die Manualpage
	  &man.mergemaster.8; enthält weitere Informationen.</para>
      </sect3>

      <sect3 xml:id="updating-src-completing-check-old">
	<title>Veraltete Dateien und Bibliotheken entfernen</title>

	<para>Nach einer Aktualisierung können sich immer noch
	  veraltete Dateien und Verzeichnisse im System befinden.
	  Diese lassen sich mit folgendem Kommando auflisten:</para>

	<screen>&prompt.root; <userinput>make check-old</userinput></screen>

	<para>und löschen:</para>

	<screen>&prompt.root; <userinput>make delete-old</userinput></screen>

	<para>Einige veraltete Bibliotheken können ebenfalls noch
	  vorhanden sein.  Diese werden mit folgenden Kommando
	  aufgelistet:</para>

	<screen>&prompt.root; <userinput>make check-old-libs</userinput></screen>

	<para>und wie folgt gelöscht:</para>

	<screen>&prompt.root; <userinput>make delete-old-libs</userinput></screen>

	<para>Programme, die diese alten Bibliotheken noch verwenden,
	  werden nicht mehr funktionieren, wenn die Bibliothek
	  gelöscht wurde.  Diese Programme müssen nach dem Löschen der
	  alten Bibliotheken neu gebaut oder ersetzt werden.</para>

	<tip>
	  <para>Wenn Sie sich sicher sind, dass alle Dateien und
	    Verzeichnisse gelöscht werden können, dann setzen Sie
	    <varname>BATCH_DELETE_OLD_FILES</varname>, um nicht jede
	    einzelne Datei mit <keycap>y</keycap> und
	    <keycap>Enter</keycap> bestätigen zu müssen.
	    Zum Beispiel:</para>

	  <screen>&prompt.root; <userinput>make BATCH_DELETE_OLD_FILES=yes delete-old-libs</userinput></screen>
	</tip>
      </sect3>

      <sect3 xml:id="updating-src-completing-restart">
	<title>Neustart des Systems</title>

	<para>Zum Abschluss der Aktualisierung muss das System neu
	  gestartet werden, damit alle Änderungen wirksam
	  werden:</para>

	<screen>&prompt.root; <userinput>shutdown -r now</userinput></screen>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="small-lan">
    <info>
      <title>Installation mehrerer Maschinen</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Mike</firstname>
	    <surname>Meyer</surname>
	  </personname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
    </info>

    <para>Wenn Sie mehrere Maschinen auf dem gleichen Stand
      halten wollen, ist es eine Verschwendung von
      Ressourcen, die Quellen auf jeder Maschine vorzuhalten und zu
      übersetzen.  Die Lösung dazu ist, eine Maschine den
      Großteil der Arbeit durchführen zu lassen und den anderen
      Maschinen das Ergebnis mit <acronym>NFS</acronym> zur Verfügung
      zu stellen.  Dieser Abschnitt zeigt eine Methode dies zu tun.
      Weitere Informationen zu <acronym>NFS</acronym> finden Sie in
      <xref linkend="network-nfs"/>.</para>

    <para>Stellen Sie zuerst eine Liste der Maschinen zusammen, die
      auf demselben Stand sein sollen.  Wir nennen diese Maschinen die
      <firstterm>Baugruppe</firstterm>.  Jede dieser Maschinen kann
      mit einem eigenen Kernel laufen, doch sind die Programme des
      Userlands auf allen Maschinen gleich.  Wählen Sie aus der
      Baugruppe eine Maschine aus, auf der der Bau durchgeführt wird,
      den <firstterm>Bau-Master</firstterm>.  Dies sollte eine
      Maschine sein, die über die nötigen
      <acronym>CPU</acronym>-Ressourcen für
      <command>make buildworld</command> und
      <command>make installworld</command> verfügt.</para>

    <para>Sie brauchen auch eine <firstterm>Testmaschine</firstterm>,
      auf der Sie die Updates testen, bevor Sie sie in Produktion
      installieren.  Dies <emphasis>muss</emphasis> eine Maschine
      sein, die über einen längeren Zeitraum nicht zur Verfügung
      stehen kann.</para>

    <para>Alle Maschinen der Baugruppe müssen
      <filename>/usr/obj</filename> und
      <filename>/usr/src</filename> über <acronym>NFS</acronym> vom
      Bau-Master an gleichem Ort einhängen.  Wenn Sie mehrere
      Baugruppen haben, sollte sich <filename>/usr/src</filename>
      auf einem Bau-Master befinden und über <acronym>NFS</acronym>
      für den Rest der Maschinen zur Verfügung gestellt
      werden.</para>

    <para>Stellen Sie sicher, dass
      <filename>/etc/make.conf</filename> und
      <filename>/etc/src.conf</filename> auf allen Maschinen einer
      Baugruppe mit der Datei des Bau-Masters übereinstimmt.  Der
      Bau-Master muss jeden Teil des Systems bauen, den irgendeine
      Maschine der Baugruppe benötigt.  Auf dem Bau-Master müssen in
      <filename>/etc/make.conf</filename> alle zu bauenden Kernel mit
      der Variablen <varname>KERNCONF</varname> bekannt gegeben
      werden.  Geben Sie dabei den Kernel des Bau-Masters zuerst an.
      Für jeden zu bauenden Kernel muss auf dem Bau-Master die
      entsprechende Konfigurationsdatei unter
      <filename>/usr/src/sys/<replaceable>arch</replaceable>/conf</filename>
      abgelegt werden.</para>

    <para>Bauen Sie auf dem Bau-Master, wie in <xref
	linkend="makeworld"/> beschrieben, den Kernel und die
      Welt, installieren Sie aber nichts.  Wechseln Sie auf die
      Testmaschine und installieren Sie den gerade gebauten Kernel.
      Hängen Sie auf der Testmaschine <filename>/usr/src</filename>
      und <filename>/usr/obj</filename> über <acronym>NFS</acronym>
      ein.  Geben Sie dann <command>shutdown now</command> ein, um
      in den Single-User-Modus zu gelangen, von wo aus Sie den neuen
      Kernel und das System installieren.  Lassen Sie anschließend
      <command>mergemaster</command> laufen.  Wenn Sie fertig sind,
      booten Sie die Maschine wieder in den
      Mehrbenutzermodus.</para>

    <para>Nachdem Sie sichergestellt haben, dass die Testmaschine
      einwandfrei funktioniert, wiederholen Sie diese Prozedur für
      jede Maschine in der Baugruppe.</para>

    <para>Dasselbe Verfahren können Sie auch für die
      Ports-Sammlung anwenden.  Zuerst müssen alle Maschinen einer
      Baugruppe <filename>/usr/ports</filename> über
      <acronym>NFS</acronym> zur Verfügung gestellt bekommen.
      Setzen Sie ein Verzeichnis für die Quellen auf, das sich alle
      Maschinen teilen.  Dieses Verzeichnis können Sie in
      <filename>/etc/make.conf</filename> mit der Variablen
      <varname>DISTDIR</varname> angeben.  Das Verzeichnis sollte
      für den Benutzer beschreibbar sein, auf den der Benutzer
      <systemitem class="username">root</systemitem> vom
      <acronym>NFS</acronym> Subsystem abgebildet wird.  Jede
      Maschine sollte noch <varname>WRKDIRPREFIX</varname> auf ein
      lokales Bauverzeichnis setzen.  Wenn Sie vorhaben, Pakete zu
      bauen und zu verteilen, sollten Sie
      <varname>PACKAGES</varname> auf ein Verzeichnis mit den
      gleichen Eigenschaften wie <varname>DISTDIR</varname>
      setzen.</para>
  </sect1>
</chapter>
