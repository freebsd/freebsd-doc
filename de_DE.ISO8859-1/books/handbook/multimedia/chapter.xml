<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde: de-docproj/books/handbook/multimedia/chapter.xml,v 1.100 2012/04/22 20:49:51 bcr Exp $
     basiert auf: r54106
-->
<chapter xmlns="http://docbook.org/ns/docbook"
  xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0"
  xml:id="multimedia">
  <info>
    <title>Multimedia</title>

    <authorgroup>
      <author>
	<personname>
	  <firstname>Ross</firstname>
	  <surname>Lippert</surname>
	</personname>
	<contrib>Überarbeitet von </contrib>
      </author>
    </authorgroup>
  </info>

  <sect1 xml:id="multimedia-synopsis">
    <title>Übersicht</title>

    <para>&os; unterstützt viele unterschiedliche Soundkarten,
      die Benutzern den Genuss von Highfidelity-Klängen auf dem
      Computer ermöglichen.  Dazu gehört unter anderem die
      Möglichkeit, Tonquellen in den Formaten MPEG Audio Layer 3
      (<acronym>MP3</acronym>), Waveform Audio File
      (<acronym>WAV</acronym>), Ogg Vorbis und vielen weiteren
      Formaten aufzunehmen und wiederzugeben.  Darüber hinaus enthält
      die &os; Ports-Sammlung Anwendungen, die das Bearbeiten von
      aufgenommenen Tonspuren, das Hinzufügen von Klangeffekten
      und die Kontrolle der angeschlossenen MIDI-Geräte
      erlauben.</para>

    <para>&os; unterstützt auch die Wiedergabe von Videos und
      <acronym>DVD</acronym>s.
      Die &os; Ports-Sammlung enthält Anwendungen, um verschiedene
      Video-Medien wiederzugeben, zu kodieren und zu
      konvertieren.</para>

    <para>Dieses Kapitel beschreibt die Einrichtung von
      Soundkarten, Video-Wiedergabe, TV-Tuner Karten und
      Scannern unter &os;.  Es werden auch einige Anwendungen
      beschrieben, die für die Verwendung dieser Geräte zur Verfügung
      stehen.</para>

    <para>Dieses Kapitel behandelt die folgenden Punkte:</para>

    <itemizedlist>
      <listitem>
	<para>Konfiguration einer Soundkarte in &os;.</para>
      </listitem>

      <listitem>
	<para>Fehlersuche bei Sound Einstellungen.</para>
      </listitem>

      <listitem>
	<para>Wiedergabe und Kodierung von <acronym>MP3</acronym>s und
	  anderen Audio-Formaten.</para>
      </listitem>

      <listitem>
	<para>Vorbereitung des Systems für die Wiedergabe von
	  Videos.</para>
      </listitem>

      <listitem>
	<para>Wiedergabe von <acronym>DVD</acronym>s,
	  <filename>.mpg</filename>- und
	  <filename>.avi</filename>-Dateien.</para>
      </listitem>

      <listitem>
	<para>Rippen von <acronym>CD</acronym>s und
	  <acronym>DVD</acronym>s.</para>
      </listitem>

      <listitem>
	<para>Konfiguration von TV-Karten.</para>
      </listitem>

      <listitem>
	<para>Installation und Konfiguration von MythTV.</para>
      </listitem>

      <listitem>
	<para>Konfiguration von Scannern</para>
      </listitem>

      <listitem>
	<para>Konfiguration von Bluetooth-Kopfhörern</para>
      </listitem>
    </itemizedlist>

    <para>Bevor Sie dieses Kapitel lesen, sollten Sie:</para>

    <itemizedlist>
      <listitem>
	<para>Wissen, wie Sie Anwendungen installieren
	  (<xref linkend="ports"/>).</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 xml:id="sound-setup">
    <info>
      <title>Soundkarten einrichten</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Moses</firstname>
	    <surname>Moore</surname>
	  </personname>
	  <contrib>Von </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <personname>
	    <firstname>Marc</firstname>
	    <surname>Fonvieille</surname>
	  </personname>
	  <contrib>Aktualisiert von </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <personname>
	    <firstname>Benedikt</firstname>
	    <surname>Köhler</surname>
	  </personname>
	  <contrib>Übersetzt von </contrib>
	</author>
	<author>
	  <personname>
	    <firstname>Uwe</firstname>
	    <surname>Pierau</surname>
	  </personname>
	</author>
      </authorgroup>
    </info>

    <indexterm><primary>PCI</primary></indexterm>
    <indexterm><primary>Soundkarten</primary></indexterm>

    <para>Bevor Sie die Konfiguration beginnen, sollten Sie in
      Erfahrung bringen welches Soundkartenmodell und welcher Chip
      benutzt wird.  &os; unterstützt eine Reihe Soundkarten.  Die
      <link
	xlink:href="&rel.current.hardware;">Hardware-Notes</link>
      zählen alle unterstützten Karten und deren Treiber für
      &os; auf.</para>

    <indexterm>
      <primary>Kernel</primary>
      <secondary>Konfiguration</secondary>
    </indexterm>

    <para>Um die Soundkarte benutzen zu können, muss der richtige
      Gerätetreiber geladen werden.  Am einfachsten ist es, das
      Kernelmodul für die Soundkarte mit &man.kldload.8; zu laden.
      Dieses Beispiel lädt den Treiber für einen integrierten
      Chipsatz, basierend auf der Intel Spezifikation:</para>

    <screen>&prompt.root; <userinput>kldload snd_hda</userinput></screen>

    <para>Um den Treiber automatisch beim Systemstart zu laden,
      fügen Sie folgende Zeile in
      <filename>/boot/loader.conf</filename> ein:</para>

    <programlisting>snd_hda_load="YES"</programlisting>

    <para>Weitere ladbare Soundmodule sind in
      <filename>/boot/defaults/loader.conf</filename> aufgeführt.
      Wenn Sie nicht sicher sind, welchen Gerätetreiber Sie laden
      müssen, laden Sie das Modul
      <filename>snd_driver</filename>:</para>

    <screen>&prompt.root; <userinput>kldload snd_driver</userinput></screen>

    <para>Der Treiber <filename>snd_driver</filename> ist ein
      Meta-Treiber, der alle gebräuchlichen Treiber lädt und die Suche
      nach dem richtigen Treiber vereinfacht.  Durch Hinzufügen des
      Meta-Treibers in <filename>/boot/loader.conf</filename> können
      alternativ alle Audio-Treiber geladen werden.</para>

    <para>Um zu ermitteln, welcher Treiber für die Soundkarte vom
      Meta-Treiber <filename>snd_driver</filename> geladen wurde,
      geben Sie <command>cat /dev/sndstat</command> ein.</para>

    <sect2>
      <title>Soundkarten in der Kernelkonfiguration einrichten</title>

      <para>Die Unterstützung für die Soundkarte kann auch direkt in
	den Kernel kompiliert werden.  Weitere Informationen über den
	Bau eines Kernels finden Sie im <xref
	  linkend="kernelconfig"/>.</para>

      <para>Bei der Verwendung eines eigenen Kernels müssen Sie
	sicherstellen, dass der Treiber für das Audio-Framework in
	der Kernelkonfigurationsdatei vorhanden ist:</para>

      <programlisting>device sound</programlisting>

      <para>Als Nächstes muss die Unterstützung für die Soundkarte
	hinzugefügt werden.  Um das Beispiel mit dem integrierten
	Intel Audio-Chipsatz aus dem vorherigen Abschnitt
	fortzusetzen, verwenden Sie die folgende Zeile in der
	Kernelkonfigurationsdatei:</para>

      <programlisting>device snd_hda</programlisting>

      <para>Lesen Sie die Manualpage des Treibers, um den
	entsprechenden Gerätenamen herauszufinden.</para>

      <para>Nicht PnP-fähige ISA-Soundkarten benötigen eventuell
	Einstellungen, wie IRQ und I/O-Port in
	<filename>/boot/device.hints</filename>.  Während des
	Systemstarts liest der &man.loader.8; diese Datei und reicht
	die Einstellungen an den Kernel weiter.  Für eine alte
	Creative &soundblaster; 16 ISA-Karte, die sowohl den
	&man.snd.sbc.4;- als auch den
	<literal>snd_sb16</literal>-Treiber benötigt, müssen die
	folgenden Zeilen in die Kernelkonfigurationsdatei eingetragen
	werden:</para>

      <programlisting>device snd_sbc
device snd_sb16</programlisting>

      <para>Wenn die Karte den I/O-Port <literal>0x220</literal> und
	IRQ <literal>5</literal> benutzt, müssen folgende Zeilen
	zusätzlich in <filename>/boot/device.hints</filename>
	hinzugefügt werden:</para>

      <programlisting>hint.sbc.0.at="isa"
hint.sbc.0.port="0x220"
hint.sbc.0.irq="5"
hint.sbc.0.drq="1"
hint.sbc.0.flags="0x15"</programlisting>

      <para>Die Syntax für <filename>/boot/device.hints</filename>
	wird in &man.sound.4;, sowie in der Manualpage des
	jeweiligen Treibers beschrieben.</para>

      <para>Das Beispiel verwendet die vorgegebenen Werte.
	Falls die Karteneinstellungen andere Werte vorgeben,
	müssen die Werte in der Kernelkonfiguration angepasst
	werden.  Weitere Informationen zu dieser Soundkarte
	finden Sie in &man.snd.sbc.4;.</para>
    </sect2>

    <sect2 xml:id="sound-testing">
      <title>Die Soundkarte testen</title>

      <para>Nachdem Sie den neuen Kernel gestartet oder das
	erforderliche Modul geladen haben, sollte die
	Soundkarte erkannt werden.  Führen Sie
	<command>dmesg | grep pcm</command> aus, um dies zu
	überprüfen.  Diese Ausgabe stammt von einem System mit
	einem integrierten Conexant CX20590 Chipsatz:</para>

      <screen>pcm0: &lt;NVIDIA (0x001c) (HDMI/DP 8ch)&gt; at nid 5 on hdaa0
pcm1: &lt;NVIDIA (0x001c) (HDMI/DP 8ch)&gt; at nid 6 on hdaa0
pcm2: &lt;Conexant CX20590 (Analog 2.0+HP/2.0)&gt; at nid 31,25 and 35,27 on hdaa1</screen>

      <para>Der Status der Karte kann auch mit diesem Kommando
	geprüft werden:</para>

      <screen>&prompt.root; <userinput>cat /dev/sndstat</userinput>
FreeBSD Audio Driver (newpcm: 64bit 2009061500/amd64)
Installed devices:
pcm0: &lt;NVIDIA (0x001c) (HDMI/DP 8ch)&gt; (play)
pcm1: &lt;NVIDIA (0x001c) (HDMI/DP 8ch)&gt; (play)
pcm2: &lt;Conexant CX20590 (Analog 2.0+HP/2.0)&gt; (play/rec) default</screen>

      <para>Die Ausgabe kann für jede Soundkarte anders aussehen.
	Wenn das Gerät <filename>pcm</filename> nicht erscheint,
	prüfen Sie die Kernelkonfigurationsdatei und stellen Sie
	sicher, dass der richtige Treiber geladen oder in den Kernel
	kompiliert wurde.  Im nächsten Abschnitt werden häufig
	auftretende Probleme sowie deren Lösungen besprochen.</para>

      <para>Jetzt sollte die Soundkarte unter
	&os; funktionieren.  Wenn ein <acronym>CD</acronym>- oder
	<acronym>DVD</acronym>-Laufwerk an die Soundkarte
	angeschlossen ist, können Sie jetzt mit &man.cdcontrol.1; eine
	<acronym>CD</acronym> abspielen:</para>

      <screen>&prompt.user; <userinput>cdcontrol -f /dev/acd0 play 1</userinput></screen>

      <warning>
	<para>Audio CDs besitzen eine spezielle Kodierung.  Daher
	  sollten sie nicht mit &man.mount.8; in das Dateisystem
	  eingehangen werden.</para>
      </warning>

      <para>Es gibt viele Anwendungen, wie
	<package>audio/workman</package>, die
	eine bessere Benutzerschnittstelle besitzen.  Zur Wiedergabe
	von MP3-Audiodateien kann <package>audio/mpg123</package>
	installiert werden.</para>

      <para>Eine weitere schnelle Möglichkeit die Karte zu
	prüfen, ist es, Daten an das Gerät
	<filename>/dev/dsp</filename> zu senden:</para>

      <screen>&prompt.user; <userinput>cat <replaceable>Datei</replaceable> &gt; /dev/dsp</userinput></screen>

      <para>Für
	<filename><replaceable>Datei</replaceable></filename> kann
	eine beliebige Datei verwendet werden.  Wenn Sie einige
	Geräusche hören, funktioniert die Soundkarte.</para>

      <note>
	<para>Die Gerätedateien <filename>/dev/dsp*</filename>
	  werden automatisch erzeugt, wenn sie das erste Mal benötigt
	  werden.  Werden sie nicht verwendet, sind sie hingegen nicht
	  vorhanden und tauchen daher auch nicht in der Ausgabe von
	  &man.ls.1; auf.</para>
      </note>
    </sect2>

    <sect2 xml:id="bluetooth-headset">
      <title>Konfiguration von Bluetooth-Soundgeräten</title>

      <indexterm>
	<primary>Bluetooth Audio</primary>
      </indexterm>

      <para>Die Verbindung zu einem Bluetooth-Gerät wird in diesem
	Abschnitt nicht erläutert.  Dazu finden Sie weitere
	Informationen in <xref linkend="network-bluetooth"/>.</para>

      <para>Damit Bluetooth zusammen mit dem Soundsystem von &os;
	funktioniert, müssen Benutzer zuerst
	<package>audio/virtual_oss</package> installieren:</para>

      <screen>&prompt.root; <userinput>pkg install virtual_oss</userinput></screen>

      <para><package>audio/virtual_oss</package> setzt voraus, dass
	<literal>cuse</literal> in den Kernel geladen wird:</para>

      <screen>&prompt.root; <userinput>kldload cuse</userinput></screen>

      <para>Führen Sie folgenden Befehl aus, damit
	<literal>cuse</literal> beim Systemstart automatisch geladen
	wird:</para>

      <screen>&prompt.root; <userinput>sysrc -f /boot/loader.conf cuse_load=yes</userinput></screen>

      <para>Um Kopfhörer mit <package>audio/virtual_oss</package> zu
	benutzten, muss nach der Verbindung mit einem
	Bluetooth-Audiogerät ein virtuelles Gerät erstellt
	werden:</para>

      <screen>&prompt.root; <userinput>virtual_oss -C 2 -c 2 -r 48000 -b 16 -s 768 -R /dev/null -P /dev/bluetooth/<replaceable>headphones</replaceable> -d dsp</userinput></screen>

      <note>
	<para><replaceable>headphones</replaceable> ist in diesem
	  Beispiel ein Hostname aus
	  <filename>/etc/bluetooth/hosts</filename>.  Stattdessen
	  kann auch <literal>BT_ADDR</literal>
	  verwendet werden.</para>
      </note>

      <para>Weitere Informationen finden Sie
	in &man.virtual_oss.8;.</para>
    </sect2>

    <sect2 xml:id="troubleshooting">
      <title>Fehlerbehebung</title>

      <indexterm><primary>Device Node</primary></indexterm>
      <indexterm><primary>Gerätedatei</primary></indexterm>
      <indexterm><primary>I/O port</primary></indexterm>
      <indexterm><primary>IRQ</primary></indexterm>
      <indexterm><primary>DSP</primary></indexterm>

      <para><xref
	  linkend="multimedia-sound-common-error-messages"/> zeigt
	typische Fehlermeldungen sowie deren Lösungen:</para>

      <table xml:id="multimedia-sound-common-error-messages"
	frame="none" pgwide="1">
	<title>Typische Fehlermeldungen</title>

	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Fehler</entry>
	      <entry>Lösung</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><errorname>sb_dspwr(XX) timed
		  out</errorname></entry>
	      <entry><para>Der I/O-Port ist nicht korrekt
		angegeben.</para></entry>
	    </row>

	    <row>
	      <entry><errorname>bad irq XX</errorname></entry>
	      <entry><para>Der IRQ ist falsch angegeben.  Stellen Sie
		sicher, dass der angegebene IRQ mit dem Sound IRQ
		übereinstimmt.</para></entry>
	    </row>

	    <row>
	      <entry><errorname>xxx: gus pcm not attached, out of
		  memory</errorname></entry>
	      <entry><para>Es ist nicht genug Speicher verfügbar,
		um das Gerät zu betreiben.</para></entry>
	    </row>

	    <row>
	      <entry><errorname>xxx: can't
		  open /dev/dsp!</errorname></entry>
	      <entry><para>Überprüfen Sie mit <command>fstat | grep
		  dsp</command> ob eine andere Anwendung das Gerät
		geöffnet hat.  Häufige Störenfriede sind
		<application>esound</application> oder die
		Sound-Unterstützung von
		<application>KDE</application>.</para></entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <para>Moderne Grafikkarten beinhalten oft auch ihre eigenen
	Soundtreiber, um <acronym>HDMI</acronym> zu verwenden.
	Diese Audiogeräte werden manchmal vor der eigentlichen,
	separaten Soundkarte aufgeführt und dadurch nicht als das
	Standardgerät zum Abspielen von Tönen benutzt.  Um zu
	prüfen, ob das der Fall ist, führen Sie
	<application>dmesg</application> aus und suchen Sie nach der
	Zeichenfolge <literal>pcm</literal>.  Die Ausgabe sieht in
	etwa so aus:</para>

      <programlisting>...
hdac0: HDA Driver Revision: 20100226_0142
hdac1: HDA Driver Revision: 20100226_0142
hdac0: HDA Codec #0: NVidia (Unknown)
hdac0: HDA Codec #1: NVidia (Unknown)
hdac0: HDA Codec #2: NVidia (Unknown)
hdac0: HDA Codec #3: NVidia (Unknown)
pcm0: &lt;HDA NVidia (Unknown) PCM #0 DisplayPort&gt; at cad 0 nid 1 on hdac0
pcm1: &lt;HDA NVidia (Unknown) PCM #0 DisplayPort&gt; at cad 1 nid 1 on hdac0
pcm2: &lt;HDA NVidia (Unknown) PCM #0 DisplayPort&gt; at cad 2 nid 1 on hdac0
pcm3: &lt;HDA NVidia (Unknown) PCM #0 DisplayPort&gt; at cad 3 nid 1 on hdac0
hdac1: HDA Codec #2: Realtek ALC889
pcm4: &lt;HDA Realtek ALC889 PCM #0 Analog&gt; at cad 2 nid 1 on hdac1
pcm5: &lt;HDA Realtek ALC889 PCM #1 Analog&gt; at cad 2 nid 1 on hdac1
pcm6: &lt;HDA Realtek ALC889 PCM #2 Digital&gt; at cad 2 nid 1 on hdac1
pcm7: &lt;HDA Realtek ALC889 PCM #3 Digital&gt; at cad 2 nid 1 on hdac1
...</programlisting>

      <para>In diesem Beispiel wurde die Grafikkarte
	(<literal>NVidia</literal>) vor der Soundkarte
	(<literal>Realtek ALC889</literal>) aufgeführt.  Um die
	Soundkarte als Standardabspielgerät einzusetzen, ändern Sie
	<literal>hw.snd.default_unit</literal> auf die Einheit, welche
	für das Abspielen benutzt werden soll:</para>

      <screen>&prompt.root; <userinput>sysctl hw.snd.default_unit=<replaceable>n</replaceable></userinput></screen>

      <para>Hier repräsentiert <literal>n</literal> die Nummer
	der Soundkarte, die verwendet werden soll, in diesem Beispiel
	also <literal>4</literal>.  Sie können diese Änderung
	dauerhaft machen, indem Sie die folgende Zeile in
	<filename>/etc/sysctl.conf</filename> hinzufügen:</para>

      <programlisting>hw.snd.default_unit=<replaceable>4</replaceable></programlisting>
    </sect2>

    <sect2 xml:id="sound-multiple-sources">
      <info>
	<title>Mehrere Tonquellen abspielen</title>

	<authorgroup>
	  <author>
	    <personname>
	      <firstname>Munish</firstname>
	      <surname>Chopra</surname>
	    </personname>
	    <contrib>Beigetragen von </contrib>
	  </author>
	</authorgroup>
      </info>

      <para>Oft sollen mehrere Tonquellen gleichzeitig
	abgespielt werden.  &os; verwendet dazu
	<emphasis>virtuelle Tonkanäle</emphasis>.  Virtuelle Kanäle
	mischen die Tonquellen im Kernel, sodass mehrere Kanäle
	benutzt werden können, als von der Hardware unterstützt
	werden.</para>

      <para>Drei &man.sysctl.8; Optionen stehen zur Konfiguration der
	virtuellen Kanäle zur Verfügung:</para>

      <screen>&prompt.root; <userinput>sysctl dev.pcm.0.play.vchans=4</userinput>
&prompt.root; <userinput>sysctl dev.pcm.0.rec.vchans=4</userinput>
&prompt.root; <userinput>sysctl hw.snd.maxautovchans=4</userinput></screen>

      <para>Im Beispiel werden vier virtuelle Kanäle
	eingerichtet, eine im Normalfall ausreichende Anzahl.
	Sowohl <varname>dev.pcm.0.play.vchans=4</varname> und
	<varname>dev.pcm.0.rec.vchans=4</varname> sind die Anzahl
	der virtuellen Kanäle des Geräts <filename>pcm0</filename>,
	die fürs Abspielen und Aufnehmen verwendet werden und sie
	können konfiguriert werden, sobald das Gerät existiert.  Da
	das Modul <filename>pcm</filename> unabhängig von den
	Hardware-Treibern geladen werden kann, gibt
	<varname>hw.snd.maxautovchans</varname> die Anzahl der
	virtuellen Kanäle an, die später eingerichtete Audiogeräte
	erhalten.  Lesen Sie &man.pcm.4; für weitere
	Informationen.</para>

      <note>
	<para>Die Anzahl der virtuellen Kanäle kann nicht geändert
	  werden, solange das Gerät genutzt wird.  Schließen Sie daher
	  zuerst alle Programme wie Musikabspielprogramme oder
	  Sound-Daemonen, die auf dieses Gerät zugreifen.</para>
      </note>

      <para>Die korrekte <filename>pcm</filename>-Gerätedatei
	wird automatisch zugeteilt, wenn ein Programm das Gerät
	<filename>/dev/dsp0</filename> anfordert.</para>
    </sect2>

    <sect2>
      <info>
	<title>Den Mixer einstellen</title>

	<authorgroup>
	  <author>
	    <personname>
	      <firstname>Josef</firstname>
	      <surname>El-Rayes</surname>
	    </personname>
	    <contrib>Beigetragen von </contrib>
	  </author>
	</authorgroup>
      </info>

      <para>Die Voreinstellungen des Mixers sind im Treiber
	&man.pcm.4; fest kodiert.  Es gibt zwar viele Anwendungen
	und Dienste, die den Mixer einstellen können und die
	eingestellten Werte bei jedem Start wieder setzen, am
	einfachsten ist es allerdings, die Standardwerte für den Mixer
	direkt im Treiber einzustellen.  Der Mixer kann mit den
	entsprechenden Werten in
	<filename>/boot/device.hints</filename> eingestellt
	werden:</para>

      <programlisting>hint.pcm.0.vol="50"</programlisting>

      <para>Die Zeile setzt die Lautstärke des Mixers
	beim Laden des Moduls &man.pcm.4; auf den Wert
	<literal>50</literal>.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="sound-mp3">
    <info>
      <title>MP3-Audio</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Chern</firstname>
	    <surname>Lee</surname>
	  </personname>
	  <contrib>Ein Beitrag von </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <personname>
	    <firstname>Benedikt</firstname>
	    <surname>Köhler</surname>
	  </personname>
	  <contrib>Übersetzt von </contrib>
	</author>
      </authorgroup>
    </info>

    <para>Dieser Abschnitt beschreibt einige unter &os; verfügbare
      <acronym>MP3</acronym>-Player.  Zudem wird beschrieben, wie
      Audio-<acronym>CD</acronym>s gerippt und <acronym>MP3</acronym>s
      kodiert und dekodiert werden.</para>

    <sect2 xml:id="mp3-players">
      <title>MP3-Player</title>

      <para>Ein beliebter graphischer <acronym>MP3</acronym>-Player
	ist <application>Audacious</application>, welcher
	<application>WinAmp</application>-Skins und zusätzliche
	Plugins unterstützt.  Die Benutzerschnittstelle ist leicht zu
	erlernen und enthält eine Playlist, einen graphischen
	Equalizer und vieles mehr.  Diejenigen, die bereits mit
	<application>WinAmp</application> vertraut sind, werden
	<application>Audacious</application> sehr leicht zu benutzen
	finden.  Unter &os; kann <application>Audacious</application>
	als Port oder Paket <package>multimedia/audacious</package>
	installiert werden.  <application>Audacious</application> ist
	ein Ableger von <application>XMMS</application>.</para>

      <para>Das Paket <package>audio/mpg123</package> ist ein
	alternativer, kommandozeilenorientierter
	<acronym>MP3</acronym>-Player.  Nach der Installation kann
	die abzuspielende <acronym>MP3</acronym>-Datei auf der
	Kommandozeile angegeben werden.  Geben Sie auch das
	entsprechende Soundkarte an, falls das System über mehrere
	Audiogeräte verfügt:</para>

      <screen>&prompt.root; <userinput>mpg123 <replaceable>-a /dev/dsp1.0 Foobar-GreatestHits.mp3</replaceable></userinput>
High Performance MPEG 1.0/2.0/2.5 Audio Player for Layer 1, 2 and 3
        version 1.18.1; written and copyright by Michael Hipp and others
        free software (LGPL) without any warranty but with best wishes

Playing MPEG stream from Foobar-GreatestHits.mp3 ...
MPEG 1.0 layer III, 128 kbit/s, 44100 Hz joint-stereo</screen>

      <para>Weitere <acronym>MP3</acronym>-Player stehen in der &os;
	Ports-Sammlung zur Verfügung.</para>
    </sect2>

    <sect2 xml:id="rip-cd">
      <title><acronym>CD</acronym>-Audio Tracks rippen</title>

      <para>Bevor eine ganze <acronym>CD</acronym> oder einen
	<acronym>CD</acronym>-Track in das
	<acronym>MP3</acronym>-Format umgewandelt werden kann, müssen
	die Audiodaten von der <acronym>CD</acronym> auf die
	Festplatte gerippt werden.  Dabei werden die
	<acronym>CDDA</acronym> (CD Digital Audio) Rohdaten in
	<acronym>WAV</acronym>-Dateien kopiert.</para>

      <para>Die Anwendung <command>cdda2wav</command>, die im
	<package>sysutils/cdrtools</package> Paket enthalten
	ist, kann zum Rippen der Audiodaten von <acronym>CD</acronym>s
	genutzt werden.</para>

      <para>Wenn die Audio <acronym>CD</acronym> in dem Laufwerk
	liegt, kann der folgende Befehl als <systemitem
	  class="username">root</systemitem> ausgeführt werden, um
	eine ganze <acronym>CD</acronym> in einzelne
	<acronym>WAV</acronym>-Dateien zu rippen:</para>

      <screen>&prompt.root; <userinput>cdda2wav -D <replaceable>0,1,0</replaceable> -B</userinput></screen>

      <para>In diesem Beispiel bezieht sich der Schalter <option>-D
	  <replaceable>0,1,0</replaceable></option> auf das
	<acronym>SCSI</acronym>-Gerät <filename>0,1,0</filename>, das
	die zu rippende <acronym>CD</acronym> enthält.  Benutzen Sie
	<command>cdrecord -scanbus</command> um die richtigen
	Geräteparameter für das System zu bestimmen.</para>

      <para>Um einzelne Tracks zu rippen, benutzen Sie
	<option>-t</option> wie folgt:</para>

      <screen>&prompt.root; <userinput>cdda2wav -D <replaceable>0,1,0</replaceable> -t 7</userinput></screen>

      <para>Um mehrere Tracks zu rippen, zum Beispiel die Tracks
	eins bis sieben, können Sie wie folgt einen Bereich
	angeben:</para>

      <screen>&prompt.root; <userinput>cdda2wav -D <replaceable>0,1,0</replaceable> -t 1+7</userinput></screen>

      <para>Wenn Sie von einem <acronym>ATAPI</acronym>
	(<acronym>IDE</acronym>) <acronym>CD-ROM</acronym>-Laufwerk
	rippen, geben Sie den Gerätenamen anstelle der
	<acronym>SCSI</acronym>-Gerätenummer an.  Dieses Beispiel
	rippt Track 7 von einem
	<acronym>IDE</acronym>-Laufwerk:</para>

      <screen>&prompt.root; <userinput>cdda2wav -D <replaceable>/dev/acd0 -t 7</replaceable></userinput></screen>

      <para>Alternativ können mit <command>dd</command> ebenfalls
	Audio-Stücke von <acronym>ATAPI</acronym>-Laufwerken kopiert
	werden.  Dies wird in <xref
	  linkend="duplicating-audiocds"/> erläutert.</para>
    </sect2>

    <sect2 xml:id="mp3-encoding">
      <title>MP3-Dateien kodieren und dekodieren</title>

      <para><application>Lame</application> ist ein weitverbreiteter
	<acronym>MP3</acronym>-Encoder, der als Port
	<package>audio/lame</package> installiert werden kann.  Wegen
	Patentproblemen ist kein Paket verfügbar.</para>

      <para>Der folgende Befehl konvertiert die gerippte
	<acronym>WAV</acronym>-Datei
	<filename><replaceable>audio01.wav</replaceable></filename>
	in <filename><replaceable>audio01.mp3</replaceable></filename>
	um:</para>

      <screen>&prompt.root; <userinput>lame -h -b <replaceable>128</replaceable> --tt "<replaceable>Foo Liedtietel</replaceable>" --ta "<replaceable>FooBar Künstler</replaceable>" --tl "<replaceable>FooBar Album</replaceable>" \
--ty "<replaceable>2014</replaceable>" --tc "<replaceable>Gerippt und kodiert von Foo</replaceable>" --tg "<replaceable>Musikrichtung</replaceable>" <replaceable>audio01.wav audio01.mp3</replaceable></userinput></screen>

      <para>128&nbsp;kbits ist die gewöhnliche
	<acronym>MP3</acronym>-Bitrate, wohingegen die Bitraten 160
	und 192&nbsp;kbits eine höhere Qualität bieten.  Je höher die
	Bitrate ist, desto mehr Speicherplatz benötigt die
	resultierende <acronym>MP3</acronym>-Datei.  Die Option
	<option>-h</option> verwendet den <quote>higher quality but a
	  little slower</quote> (höhere Qualität, aber etwas
	  langsamer) Modus.  Die Schalter, die mit
	<option>--t</option> beginnen, sind
	<acronym>ID3</acronym>-Tags, die in der Regel Informationen
	über das Lied enthalten und in die
	<acronym>MP3</acronym>-Datei eingebettet sind.  Weitere
	Optionen können in der Manualpage von
	<application>lame</application> nachgelesen werden.</para>

      <para>Um aus <acronym>MP3</acronym>-Dateien eine Audio
	<acronym>CD</acronym> zu erstellen, müssen diese zuerst in ein
	nicht komprimiertes Format umgewandelt werden.  Verwenden Sie
	<application>XMMS</application> um die Datei im
	<acronym>WAV</acronym>-Format zu schreiben und
	<application>mpg123</application>, um die
	<acronym>MP3</acronym>-Datei in rohe
	<acronym>PCM</acronym>-Audiodaten umzuwandeln.</para>

      <para>Um <filename>audio01.mp3</filename> mit
	<application>mpg123</application> umzuwandeln, geben Sie den
	Namen der <acronym>PCM</acronym>-Datei an:</para>

      <screen>&prompt.root; <userinput>mpg123 -s <replaceable>audio01.mp3</replaceable> &gt; <replaceable>audio01.pcm</replaceable></userinput></screen>

      <para>So verwenden Sie <application>XMMS</application> um eine
	<acronym>MP3</acronym>-Datei in das
	<acronym>WAV</acronym>-Format zu konvertieren:</para>

      <procedure>
	<title>Mit <application>XMMS</application> in das
	  <acronym>WAV</acronym>-Format konvertieren</title>

	<step>
	  <para>Starten Sie <application>XMMS</application>.</para>
	</step>

	<step>
	  <para>Klicken Sie mit der rechten Maustaste, um das
	    <application>XMMS</application>-Menu zu öffnen.</para>
	</step>

	<step>
	  <para>Wählen Sie <literal>Preferences</literal> im
	    Untermenü <literal>Options</literal>.</para>
	</step>

	<step>
	  <para>Ändern Sie das Output-Plugin in
	    <quote>Disk Writer Plugin</quote>.</para>
	</step>

	<step>
	  <para>Drücken Sie <literal>Configure</literal>.</para>
	</step>

	<step>
	  <para>Geben Sie ein Verzeichnis ein, in das Sie die
	    unkomprimierte Datei schreiben wollen.</para>
	</step>

	<step>
	  <para>Laden Sie die <acronym>MP3</acronym>-Datei wie gewohnt
	    in <application>XMMS</application> mit einer Lautstärke
	    von 100% und einem abgeschalteten EQ.</para>
	</step>

	<step>
	  <para>Drücken Sie <literal>Play</literal> und es wird
	    so aussehen, als spiele <application>XMMS</application>
	    die <acronym>MP3</acronym>-Datei ab, aber keine Musik ist
	    zu hören.  Der Player überspielt die
	    <acronym>MP3</acronym>-Datei in eine Datei.</para>
	</step>

	<step>
	  <para>Vergessen Sie nicht, das Output-Plugin wieder in den
	    Ausgangszustand zurückzusetzen um wieder
	    <acronym>MP3</acronym>-Dateien anhören zu können.</para>
	</step>
      </procedure>

      <para><application>cdrecord</application> kann mit beiden
	Formaten Audio-<acronym>CD</acronym>s erstellen.  Der
	Dateikopf von <acronym>WAV</acronym>-Dateien erzeugt am Anfang
	des Stücks ein Knacken.  Der Dateikopf mit dem Port oder Paket
	<package>audio/sox</package> entfernt werden:</para>

      <screen>&prompt.user; <userinput>sox -t wav -r 44100 -s -w -c 2 <replaceable>track.wav track.raw</replaceable></userinput></screen>

      <para>Lesen Sie <xref linkend="creating-cds"/>, um mehr
	Informationen zur Benutzung von <acronym>CD</acronym>-Brennern
	mit &os; zu erhalten.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="video-playback">
    <info>
      <title>Videos wiedergeben</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Ross</firstname>
	    <surname>Lippert</surname>
	  </personname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
    </info>

    <para>Bevor Sie beginnen, sollten Sie das Modell
      und den benutzten Chip der Videokarte kennen.  Obwohl
      <application>&xorg;</application> viele Videokarten
      unterstützt, können nicht alle Karten Videos
      schnell genug wiedergeben.  Eine Liste der Erweiterungen,
      die der <application>&xorg;</application>-Server für eine
      Videokarte unterstützt, erhalten Sie unter laufendem
      <application>&xorg;</application> mit
      <command>xdpyinfo</command>.</para>

    <para>Halten Sie eine kurze MPEG-Datei bereit, mit der
      Sie Wiedergabeprogramme und deren Optionen testen können.
      Da einige <acronym>DVD</acronym>-Spieler in der Voreinstellung
      das <acronym>DVD</acronym>-Gerät mit
      <filename>/dev/dvd</filename> ansprechen oder diesen Namen fest
      einkodiert haben, ist es vielleicht hilfreich symbolische Links
      auf die richtigen Geräte anzulegen:</para>

    <screen>&prompt.root; <userinput>ln -sf /dev/acd0 /dev/dvd</userinput></screen>

    <para>Aufgrund der Beschaffenheit &man.devfs.5; gehen gesondert
      angelegte Links wie diese bei einem Neustart des Systems
      verloren.  Damit die symbolischen Links automatisch beim
      Neustart des Systems angelegt werden, fügen Sie die folgende
      Zeile in <filename>/etc/devfs.conf</filename> ein:</para>

    <programlisting>link acd0 dvd</programlisting>

    <para>Das Entschlüsseln von <acronym>DVD</acronym>s erfordert den
      Aufruf bestimmter Funktionen, sowie Schreibzugriff auf das
      <acronym>DVD</acronym>-Gerät.</para>

    <para><application>&xorg;</application> benutzt Shared-Memory und
      es wird empfohlen, die nachstehenden &man.sysctl.8;-Variablen
      auf die gezeigten Werte zu erhöhen:</para>

    <programlisting>kern.ipc.shmmax=67108864
kern.ipc.shmall=32768</programlisting>

    <sect2 xml:id="video-interface">
      <title>Video-Schnittstellen</title>

      <indexterm><primary>XVideo</primary></indexterm>
      <indexterm><primary>SDL</primary></indexterm>
      <indexterm><primary>DGA</primary></indexterm>

      <para>Es gibt einige Möglichkeiten, Videos unter
	<application>&xorg;</application> abzuspielen.  Welche
	Möglichkeit funktioniert, hängt stark von der verwendeten
	Hardware ab.</para>

      <para>Gebräuchliche Video-Schnittstellen sind:</para>

      <orderedlist>
	<listitem>
	  <para><application>&xorg;</application>: normale Ausgabe
	    über Shared-Memory.</para>
	</listitem>

	<listitem>
	  <para>XVideo: Eine Erweiterung der
	    <application>&xorg;</application>-Schnittstelle,
	    die Videos in jedem X11-Drawable anzeigen kann.  Diese
	    Erweiterung bietet auch auf leistungsschwachen Maschinen
	    eine gute Qualität der Wiedergabe.  Der nächste Abschnitt
	    beschreibt, wie Sie feststellen, ob diese Erweiterung
	    ausgeführt wird.</para>
	</listitem>

	<listitem>
	  <para><acronym>SDL</acronym>: Simple DirectMedia
	    Layer ist eine portable Schnittstelle für verschiedene
	    Betriebssysteme, mit denen Anwendungen plattformunabhängig
	    und effizient Ton und Grafik benutzen können.
	    <acronym>SDL</acronym> bietet eine hardwarenahe
	    Schnittstelle, die manchmal schneller ist als die
	    <application>&xorg;</application>-Schnittstelle.  Unter
	    &os; kann <acronym>SDL</acronym> über das Paket oder den
	    Port <package>devel/sdl20</package> installiert
	    werden.</para>
	</listitem>

	<listitem>
	  <para><acronym>DGA</acronym>: Direct Graphics Access ist
	    eine <application>&xorg;</application>-Erweiterung die es
	    Anwendungen erlaubt, am
	    <application>&xorg;</application>-Server vorbei direkt in
	    den Framebuffer zu schreiben.  Da die Anwendung und der
	    <application>&xorg;</application>-Server auf gemeinsame
	    Speicherbereiche zugreifen, müssen die Anwendungen unter
	    dem Benutzer <systemitem
	      class="username">root</systemitem> laufen.  Die
	    <acronym>DGA</acronym>-Erweiterung kann mit &man.dga.1;
	    getestet werden.  Wenn <acronym>DGA</acronym> ausgeführt
	    wird, ändert sich die Farbe des Bildschrims, wenn eine
	    Taste gedrückt wird.  Drücken Sie zum Beenden
	    <keycap>q</keycap>.</para>
	</listitem>

	<listitem>
	  <para>SVGAlib: Eine Schnittstelle zur Grafikausgabe auf
	    der Konsole.</para>
	</listitem>
      </orderedlist>

      <sect3 xml:id="video-interface-xvideo">
	<title>XVideo</title>

	<para>Ob die Erweiterung läuft, entnehmen Sie der
	  Ausgabe von <command>xvinfo</command>:</para>

	<screen>&prompt.user; <userinput>xvinfo</userinput></screen>

	<para>XVideo wird untertsützt, wenn die Ausgabe in etwa wie
	  folgt aussieht:</para>

	<screen>X-Video Extension version 2.2
screen #0
  Adaptor #0: "Savage Streams Engine"
    number of ports: 1
    port base: 43
    operations supported: PutImage
    supported visuals:
      depth 16, visualID 0x22
      depth 16, visualID 0x23
    number of attributes: 5
      "XV_COLORKEY" (range 0 to 16777215)
              client settable attribute
              client gettable attribute (current value is 2110)
      "XV_BRIGHTNESS" (range -128 to 127)
              client settable attribute
              client gettable attribute (current value is 0)
      "XV_CONTRAST" (range 0 to 255)
              client settable attribute
              client gettable attribute (current value is 128)
      "XV_SATURATION" (range 0 to 255)
              client settable attribute
              client gettable attribute (current value is 128)
      "XV_HUE" (range -180 to 180)
              client settable attribute
              client gettable attribute (current value is 0)
    maximum XvImage size: 1024 x 1024
    Number of image formats: 7
      id: 0x32595559 (YUY2)
        guid: 59555932-0000-0010-8000-00aa00389b71
        bits per pixel: 16
        number of planes: 1
        type: YUV (packed)
      id: 0x32315659 (YV12)
        guid: 59563132-0000-0010-8000-00aa00389b71
        bits per pixel: 12
        number of planes: 3
        type: YUV (planar)
      id: 0x30323449 (I420)
        guid: 49343230-0000-0010-8000-00aa00389b71
        bits per pixel: 12
        number of planes: 3
        type: YUV (planar)
      id: 0x36315652 (RV16)
        guid: 52563135-0000-0000-0000-000000000000
        bits per pixel: 16
        number of planes: 1
        type: RGB (packed)
        depth: 0
        red, green, blue masks: 0x1f, 0x3e0, 0x7c00
      id: 0x35315652 (RV15)
        guid: 52563136-0000-0000-0000-000000000000
        bits per pixel: 16
        number of planes: 1
        type: RGB (packed)
        depth: 0
        red, green, blue masks: 0x1f, 0x7e0, 0xf800
      id: 0x31313259 (Y211)
        guid: 59323131-0000-0010-8000-00aa00389b71
        bits per pixel: 6
        number of planes: 3
        type: YUV (packed)
      id: 0x0
        guid: 00000000-0000-0000-0000-000000000000
        bits per pixel: 0
        number of planes: 0
        type: RGB (packed)
        depth: 1
        red, green, blue masks: 0x0, 0x0, 0x0</screen>

	<para>Einige der aufgeführten Formate, wie YUV2 oder YUV12
	  existieren in machen XVideo-Implementierungen nicht.
	  Dies kann zu Problemen mit einigen Spielern führen.</para>

	<para>XVideo wird wahrscheinlich von der Karte
	  nicht unterstützt, wenn die Ausgabe wie folgt
	  aussieht:</para>

	<screen>X-Video Extension version 2.2
screen #0
no adaptors present</screen>

	<para>Wenn die XVideo-Erweiterung auf der Karte nicht
	  läuft, wird es nur etwas schwieriger, die
	  Anforderungen für die Wiedergabe von Videos zu
	  erfüllen.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="video-ports">
      <title>Video-Anwendungen</title>

      <indexterm>
	<primary>Video-Anwendungen</primary>
      </indexterm>

      <para>Dieser Abschnitt behandelt Anwendungen aus der
	&os;-Ports-Sammlung, die für die Wiedergabe von Videos
	genutzt werden können.</para>

      <sect3 xml:id="video-mplayer">
	<title><application>MPlayer</application> und
	  <application>MEncoder</application></title>

	<para><application>MPlayer</application> ist ein auf
	  Geschwindigkeit und Flexibilität ausgelegter Video-Spieler
	  für die Kommandozeile mit optionaler graphischer Oberfläche.
	  Weitere graphische Oberflächen für
	  <application>MPlayer</application> stehen in der &os;
	  Ports-Sammlung zur Verfügung.</para>

	<indexterm><primary>MPlayer</primary></indexterm>

	<para><application>MPlayer</application> kann als Paket oder
	  Port <package>multimedia/mplayer</package> installiert
	  werden.  Der Bau von <application>MPlayer</application>
	  berücksichtigt die vorhandene Hardware und es können
	  zahlreiche Optionen ausgewählt werden.  Aus diesen Gründen
	  ziehen es manche Benutzer vor, den Port zu übersetzen,
	  anstatt das Paket zu installieren.</para>

	<para>Die Optionen sollten beim Bau des Ports überprüft
	  werden, um dem Umfang der Unterstützung, mit dem der Port
	  gebaut wird, zu bestimmen.  Wenn eine Option nicht
	  ausgewählt wird, ist <application>MPlayer</application>
	  nicht in der Lage, diese Art von Video-Format
	  wiederzugeben.  Mit den Pfeiltasten und der Leertaste
	  können die erforderlichen Formate ausgewählt werden.  Wenn
	  Sie fertig sind, drücken Sie <keycap>Enter</keycap>, um
	  den Bau und die Installation fortzusetzen.</para>

	<para>In der Voreinstellung wird das Paket oder der Port das
	  <command>mplayer</command>-Kommandozeilenprogramm und das
	  graphische Programm <command>gmplayer</command> bauen.  Um
	  Videos zu dekodieren, installieren Sie den Port
	  <package>multimedia/mencoder</package>.  Aus
	  lizenzrechtlichen Gründen steht ein Paket von
	  <application>MEncoder</application> nicht zur
	  Verfügung.</para>

	<para><application>MPlayer</application> erstellt beim
	  ersten Start <filename>~/.mplayer</filename> im
	  Heimatverzeichnis des Benutzers.  Dieses Verzeichnis
	  enthält die voreingestellten Konfigurationseinstellungen
	  für den Benutzer.</para>

	<para>Dieser Abschnitt beschreibt nur ein paar wenige
	  Anwendungsmöglichkeiten.  Eine vollständige Beschreibung
	  der zahlreichen Möglichkeiten finden Sie in der Manualpage
	  von mplayer(1).</para>

	<para>Um die Datei
	  <filename><replaceable>testfile.avi</replaceable></filename>
	  abzuspielen, geben Sie die Video-Schnittstelle mit
	  <option>-vo</option> an:</para>

	<screen>&prompt.user; <userinput>mplayer -vo xv <replaceable>testfile.avi</replaceable></userinput></screen>

	<screen>&prompt.user; <userinput>mplayer -vo sdl <replaceable>testfile.avi</replaceable></userinput></screen>

	<screen>&prompt.user; <userinput>mplayer -vo x11 <replaceable>testfile.avi</replaceable></userinput></screen>

	<screen>&prompt.root; <userinput>mplayer -vo dga <replaceable>testfile.avi</replaceable></userinput></screen>

	<screen>&prompt.root; <userinput>mplayer -vo 'sdl:dga' <replaceable>testfile.avi</replaceable></userinput></screen>

	<para>Es lohnt sich, alle Option zu testen.  Die erzielte
	  Geschwindigkeit hängt von vielen Faktoren ab und variiert
	  beträchtlich je nach eingesetzter Hardware.</para>

	<para>Wenn Sie eine <acronym>DVD</acronym> abspielen wollen,
	  ersetzen Sie
	  <filename><replaceable>testfile.avi</replaceable></filename>
	  durch
	  <option>-dvd://<replaceable>N</replaceable>
	    <replaceable>Gerät</replaceable></option>.
	  <replaceable>N</replaceable> ist die Nummer des
	  Stücks, das Sie abspielen wollen und
	  <filename><replaceable>Gerät</replaceable></filename> gibt
	  den Gerätenamen der <acronym>DVD</acronym> an.  Das
	  nachstehende Kommando spielt das dritte Stück von
	  <filename>/dev/dvd</filename>:</para>

	<screen>&prompt.root; <userinput>mplayer -vo dga -dvd://3 /dev/dvd</userinput></screen>

	<note>
	  <para>Das standardmäßig verwendete
	    <acronym>DVD</acronym>-Laufwerk kann beim Bau des
	    <application>MPlayer</application>-Ports mit der Option
	    <varname>WITH_DVD_DEVICE=/pfad/zum/gerät</varname>
	    festgelegt werden.  Die Voreinstellung verwendet das
	    Gerät <filename>/dev/cd0</filename>.  Weitere Details
	    finden Sie in <filename>Makefile.options</filename> des
	    Ports.</para>
	</note>

	<para>Die Tastenkombinationen zum Abbrechen, Anhalten
	  und Weiterführen der Wiedergabe entnehmen Sie
	  der Ausgabe von <command>mplayer -h</command> oder der
	  mplayer(1) Manualpage.</para>

	<para>Weitere nützliche Optionen für die
	  Wiedergabe sind <option>-fs -zoom</option> zur Wiedergabe
	  im Vollbild-Modus und <option>-framedrop</option>
	  zur Steigerung der Geschwindigkeit.</para>

	<para>Jeder Benutzer kann häufig verwendete Optionen in
	  seine <filename>~/.mplayer/config</filename>
	  eintragen:</para>

	<programlisting>vo=xv
fs=yes
zoom=yes</programlisting>

	<para><command>mplayer</command> kann verwendet werden, um
	  <acronym>DVD</acronym>-Stücke in
	  <filename>.vob</filename>-Dateien zu rippen.  Das zweite
	  Stück einer <acronym>DVD</acronym> wandeln Sie wie folgt
	  in eine Datei um:</para>

	<screen>&prompt.root; <userinput>mplayer -dumpstream -dumpfile out.vob -dvd://2 /dev/dvd</userinput></screen>

	<para>Die Ausgabedatei <filename>out.vob</filename>
	  wird im <acronym>MPEG</acronym>-Format
	  abgespeichert.</para>

	<para>Jeder Benutzer, der mehr Informationen über Video
	  unter &unix; sammeln möchte, sollte <link
	    xlink:href="http://www.mplayerhq.hu/DOCS/">
	    mplayerhq.hu/DOCS</link> konsultieren, da es technisch
	  sehr informativ ist.  Diese Dokumentation sollte ebenfalls
	  studiert werden, bevor Fehlerberichte eingereicht
	  werden.</para>

	<indexterm>
	  <primary>mencoder</primary>
	</indexterm>

	<para>Vor der Verwendung von <command>mencoder</command>
	  ist es hilfreich, sich mit den auf <link
	    xlink:href="http://www.mplayerhq.hu/DOCS/HTML/en/mencoder.html">mplayerhq.hu/DOCS/HTML/en/mencoder.html</link>
	  beschriebenen Optionen vertraut zu machen.
	  Es gibt unzählige Möglichkeiten die Qualität zu verbessern,
	  die Bitrate zu verringern und Formate zu konvertieren.
	  Einige davon haben erhebliche Auswirkungen auf die
	  Geschwindigkeit.  Falsche Kombinationen von
	  Kommandozeilenparametern ergeben eventuell Dateien, die
	  selbst <command>mplayer</command> nicht mehr wiedergeben
	  kann.</para>

	<para>Hier ist ein Beispiel für eine einfache Kopie:</para>

	<screen>&prompt.user; <userinput>mencoder <replaceable>input.avi</replaceable> -oac copy -ovc copy -o <replaceable>output.avi</replaceable></userinput></screen>

	<para>Wenn Sie in eine Datei rippen, benutzen Sie
	  die Option <option>-dumpfile</option> von
	  <command>mplayer</command>.</para>

	<para>Um
	  <filename><replaceable>input.avi</replaceable></filename>
	  nach MPEG4 mit MPEG3 für den Ton zu konvertieren, muss
	  zunächst der Port <package>audio/lame</package>
	  installiert werden.  Aus lizenzrechtlichen Gründen ist ein
	  Paket nicht verfügbar.  Wenn der Port installiert ist,
	  geben Sie ein:</para>

	<screen>&prompt.user; <userinput>mencoder <replaceable>input.avi</replaceable> -oac mp3lame -lameopts br=192 \
	  -ovc lavc -lavcopts vcodec=mpeg4:vhq -o <replaceable>output.avi</replaceable></userinput></screen>

	<para>Die Ausgabedatei lässt sich mit Anwendungen wie
	  <command>mplayer</command> oder
	  <command>xine</command> abspielen.</para>

	<para><filename>input.avi</filename> kann durch
	  <option>-dvd://1 /dev/dvd</option> ersetzt und das
	  Kommando als <systemitem
	    class="username">root</systemitem> ausgeführt werden,
	  um ein <acronym>DVD</acronym>-Stück direkt zu
	  konvertieren.  Da vielleicht ein paar Versuche nötig sind,
	  um das gewünschte Ergebnis zu erhalten, empfiehlt es sich
	  das Stück zuerst in eine Datei zu schreiben und
	  anschließend die Datei weiter zu bearbeiten.</para>
      </sect3>

      <sect3 xml:id="video-xine">
	<title>Der Video-Spieler
	  <application>xine</application></title>

	<para><application>xine</application> ist ein Video-Spieler
	  mit einer wiederverwendbaren Bibliothek und ein Programm,
	  das durch Plugins erweitert werden kann.  Es kann als Paket
	  oder Port <package>multimedia/xine</package> installiert
	  werden.</para>

	<para>Für einen reibungslosen Betrieb benötigt
	  <application>xine</application> entweder eine schnelle
	  <acronym>CPU</acronym> mit einer schnellen Grafikkarte,
	  oder die XVideo-Erweiterung.  Am schnellsten läuft
	  <application>xine</application> mit der
	  XVideo-Erweiterung.</para>

	<para>In der Voreinstellung startet
	  <application>xine</application> eine grafische
	  Benutzeroberfläche.  Über die Menüs können dann
	  bestimmte Dateien geöffnet werden.</para>

	<para>Alternativ kann <application>xine</application> auch
	  über die Kommandozeile aufgerufen werden, um Dateien direkt
	  wiederzugeben:</para>

	<screen>&prompt.user; <userinput>xine -g -p <replaceable>mymovie.avi</replaceable></userinput></screen>

	<para>Weitere Informationen und Tipps zur Fehlerbehebung
	  finden Sie unter <link
	    xlink:href="http://www.xine-project.org/faq">
	    xine-project.org/faq</link>.</para>
      </sect3>

      <sect3 xml:id="video-ports-transcode">
	<title>Die
	  <application>Transcode</application>-Werkzeuge</title>

	<para><application>Transcode</application> ist eine Sammlung
	  von Werkzeugen zur Umwandlung von Video- und Audio-Dateien.
	  <application>Transcode</application> mischt Video-Dateien
	  und kann kaputte Video-Dateien reparieren.  Die Werkzeuge
	  werden als Filter verwendet, das heißt die Ein- und Ausgaben
	  verwenden stdin/stdout.</para>

	<para>Unter &os; kann <application>Transcode</application> als
	  Paket oder Port <package>multimedia/transcode</package>
	  installiert werden.  Viele Benutzer bevorzugen es den Port
	  zu bauen, da er ein Menü bereitstellt, wo die entsprechenden
	  Formate für den Bau ausgewählt werden können.  Mit den
	  Pfeiltasten und der Leertaste können die erforderlichen
	  Formate ausgewählt werden.  Wenn Sie fertig sind, drücken
	  Sie <keycap>Enter</keycap>, um den Bau und die Installation
	  fortzusetzen.</para>

	<para>Dieses Beispiel zeigt, wie eine DivX-Datei in eine PAL
	  MPEG-1-Datei konvertiert wird:</para>

	<screen>&prompt.user; <userinput>transcode -i <replaceable>input.avi</replaceable> -V --export_prof vcd-pal -o output_vcd</userinput>
&prompt.user; <userinput>mplex -f 1 -o <replaceable>output_vcd.mpg output_vcd.m1v output_vcd.mpa</replaceable></userinput></screen>

	<para>Die daraus resultierende <acronym>MPEG</acronym>-Datei,
	  <filename><replaceable>output_vcd.mpg</replaceable></filename>,
	  kann beispielsweise mit <application>MPlayer</application>
	  abgespielt werden.  Die Datei kann auch mit einem Programm
	  wie <package>multimedia/vcdimager</package> oder
	  <package>sysutils/cdrdao</package> als
	  Video-<acronym>CD</acronym> auf eine <acronym>CD</acronym>-R
	  gebrannt werden.</para>

	<para>Zusätzlich zu der Manualpage von
	  <command>transcode</command>, sollten Sie auch die
	  Informationen und Beispiele im <link
	    xlink:href="http://www.transcoding.org/cgi-bin/transcode">
	    transcoding.org/cgi-bin/transcode</link> lesen.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="tvcard">
    <info>
      <title>TV-Karten</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Josef</firstname>
	    <surname>El-Rayes</surname>
	  </personname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <personname>
	    <firstname>Marc</firstname>
	    <surname>Fonvieille</surname>
	  </personname>
	  <contrib>Überarbeitet von </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>TV-Karten</primary>
    </indexterm>

    <para>Mit TV-Karten können Sie mit dem Rechner über Kabel oder
      Antenne fernsehen.  Die meisten Karten besitzen einen
      <acronym>RCA</acronym>- oder S-Video-Eingang.  Einige Karten
      haben auch einen <acronym>FM</acronym>-Radio-Empfänger.</para>

    <para>Der &man.bktr.4;-Treiber von &os; unterstützt PCI-TV-Karten
      mit einem Brooktree Bt848/849/878/879 Chip.  Dieser Teiber
      unterstützt die meisten Pinnacle PCTV Karten.  Die Karte sollte
      einen der unterstützten Empfänger besitzen, die in &man.bktr.4;
      aufgeführt sind.</para>

    <sect2>
      <title>Den Treiber laden</title>

      <para>Um die Karte benutzen zu können, muss der
	&man.bktr.4;-Treiber geladen werden.  Damit dies beim
	Systemstart automatisch erfolgt, muss die folgende Zeile
	in <filename>/boot/loader.conf</filename> hinzugefügt
	werden:</para>

      <programlisting>bktr_load="YES"</programlisting>

      <para>Alternativ kann der Treiber für die TV-Karte
	auch fest in den Kernel kompiliert werden.  In diesem Fall
	müssen folgende Zeilen in die Kernelkonfigurationsdatei
	aufgenommen werden:</para>

      <programlisting>device	 bktr
device	iicbus
device	iicbb
device	smbus</programlisting>

      <para>Die zusätzlichen Treiber werden benötigt,
	da die Komponenten der Karte über einen I2C-Bus
	verbunden sind.  Bauen und installieren Sie dann den
	neuen Kernel.</para>

      <para>Um den Treiber zu testen, muss das System neu gestartet
	werden.  Während des Neustarts sollte die TV-Karte erkannt
	werden:</para>

      <programlisting>bktr0: &lt;BrookTree 848A&gt; mem 0xd7000000-0xd7000fff irq 10 at device 10.0 on pci0
iicbb0: &lt;I2C bit-banging driver&gt; on bti2c0
iicbus0: &lt;Philips I2C bus&gt; on iicbb0 master-only
iicbus1: &lt;Philips I2C bus&gt; on iicbb0 master-only
smbus0: &lt;System Management Bus&gt; on bti2c0
bktr0: Pinnacle/Miro TV, Philips SECAM tuner.</programlisting>

      <para>Abhängig von der verwendeten Hardware können die
	Meldungen natürlich anders aussehen.  Die entdeckten Geräte
	lassen sich mit &man.sysctl.8; oder in der
	Kernelkonfigurationsdatei überschreiben.  Wenn Sie
	beispielsweise einen Philips-SECAM-Empfänger erzwingen wollen,
	fügen Sie die folgende Zeile zur Kernelkonfigurationsdatei
	hinzu:</para>

      <programlisting>options OVERRIDE_TUNER=6</programlisting>

      <para>Alternativ können Sie &man.sysctl.8; benutzen:</para>

      <screen>&prompt.root; <userinput>sysctl hw.bt848.tuner=6</userinput></screen>

      <para>Weitere Informationen zu den verschiedenen Kerneloptionen
	und &man.sysctl.8;-Parametern finden Sie in
	&man.bktr.4;.</para>
    </sect2>

    <sect2>
      <title>Nützliche Anwendungen</title>

      <para>Um die TV-Karte zu benutzen, installieren Sie eine
	der nachstehenden Anwendungen:</para>

      <itemizedlist>
	<listitem>
	  <para><package>multimedia/fxtv</package>
	    lässt das Fernsehprogramm in einem Fenster laufen
	    und kann Bilder, Audio und Video aufzeichnen.</para>
	</listitem>
	<listitem>
	  <para><package>multimedia/xawtv</package>
	    eine weitere TV-Anwendung mit vergleichbaren
	    Funktionen.</para>
	</listitem>
	<listitem>
	  <para>Mit <package>audio/xmradio</package>
	    lässt sich der FM-Radio-Empfänger, der sich
	    auf TV-Karten befindet, benutzen.</para>
	</listitem>
      </itemizedlist>

      <para>Weitere Anwendungen finden Sie in der &os;
	Ports-Sammlung.</para>
    </sect2>

    <sect2>
      <title>Fehlersuche</title>

      <para>Wenn Sie Probleme mit der TV-Karte haben, prüfen
	Sie zuerst, ob der Video-Capture-Chip und der Empfänger
	vom &man.bktr.4;-Treiber unterstützt werden und ob Sie die
	richtigen Optionen verwenden.  Weitere Hilfe zu
	unterstützten TV-Karten finden Sie auf der Mailingliste
	&a.multimedia.name;.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="mythtv">
    <title>MythTV</title>

    <para>MythTV ist eine beliebte Open Source
      <acronym>PVR</acronym>-Anwendung.  Dieser Abschnitt beschreibt
      die Installation und Konfiguration von MythTV unter &os;.
      Weitere Informationen zur Benutzung von MythTV finden Sie unter
      <link xlink:href="http://www.mythtv.org/wiki/">
	mythtv.org/wiki</link>.</para>

    <para>MythTV benötigt ein Frontend und ein Backend.  Diese
      Komponenten können entweder auf dem gleichen System, oder auf
      unterschiedlichen Maschinen installiert werden.</para>

    <para>Das Frontend kann unter &os; über den Port oder das Paket
      <package>multimedia/mythtv-frontend</package> installiert
      werden.  Zudem muss &xorg;, wie in <xref linkend="x11"/>
      beschrieben, installiert und konfiguriert sein.  Idealerweise
      besitzt das System auch eine Videokarte, die
      <foreignphrase>X-Video Motion Compensation</foreignphrase>
      (<acronym>XvMC</acronym>) unterstützt, sowie optional eine
      <acronym>LIRC</acronym>-kompatible Fernbedienung.</para>

    <para>Benutzen Sie <package>multimedia/mythtv</package>, um sowohl
      das Frontend als auch das Backend zu installieren.  Ein &mysql;
      Datenbank-Server ist ebenfalls erforderlich und sollte
      automatisch als Abhängigkeit installiert werden.  Optional
      sollte das System einen Empfänger und ausreichend Speicherplatz
      haben, um die aufgezeichneten Daten speichern zu können.</para>

    <sect2>
      <title>Hardware</title>

      <para>MythTV verwendet <acronym>V4L</acronym> um auf
	Videoeingabegeräte, wie Kodierer und Empfänger zuzugreifen.
	Unter &os; funktioniert MythTV am besten mit
	<acronym>USB</acronym> DVB-S/C/T Karten, die von
	<package>multimedia/webcamd</package> unterstützt werden, da
	dies eine <acronym>V4L</acronym>-Anwendung zur Verfügung
	stellt, die als Benutzerprogramm läuft.  Jede
	<acronym>DVB</acronym>-Karte, die von
	<application>webcamd</application> unterstützt wird, sollte
	mit MythTV funktionieren, jedoch gibt es eine Liste von
	Karten, die unter <link
	  xlink:href="https://wiki.freebsd.org/WebcamCompat">
	  wiki.freebsd.org/WebcamCompat</link> abgerufen werden kann.
	Es existieren auch Treiber für Hauppauge-Karten in den
	folgenden Paketen: <package>multimedia/pvr250</package> und
	<package>multimedia/pvrxxx</package>, allerdings liefern diese
	nur eine Treiberschnittstelle, die nicht dem Standard
	entspricht und die nicht mit MythTV-Versionen grösser als
	0.23 funktionieren.  Aus lizenzrechtlichen Gründen ist ein
	Paket nicht verfügbar, sodass die beiden Ports übersetzt
	werden müssen.</para>

      <para>Die <link xlink:href="https://wiki.freebsd.org/HTPC">
	  wiki.freebsd.org/HTPC</link> enthält eine Liste von allen
	verfügbaren <acronym>DVB</acronym>-Treibern.</para>
    </sect2>

    <sect2>
      <title>MythTV Backend einrichten</title>

      <para>Geben Sie folgendes ein, um MythTV als Binärpaket
	zu installieren:</para>

      <screen>&prompt.root; <userinput>pkg install mythtv</userinput></screen>

      <para>Alternativ können Sie den Port installieren:</para>

      <screen>&prompt.root; <userinput>cd /usr/ports/multimedia/mythtv</userinput>
&prompt.root; <userinput>make install</userinput></screen>

      <para>Richten Sie anschließend die MythTV-Datenbank ein:</para>

      <screen>&prompt.root; <userinput>mysql -uroot -p &lt; /usr/local/share/mythtv/database/mc.sql</userinput></screen>

      <para>Konfigurieren Sie dann das Backend:</para>

      <screen>&prompt.root; <userinput>mythtv-setup</userinput></screen>

      <para>Zum Schluss starten Sie das Backend:</para>

      <screen>&prompt.root; <userinput>sysrc mythbackend_enable=yes</userinput>
&prompt.root; <userinput>service mythbackend start</userinput></screen>
    </sect2>
  </sect1>

  <sect1 xml:id="scanners">
    <info>
      <title>Scanner</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Marc</firstname>
	    <surname>Fonvieille</surname>
	  </personname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>Scanner</primary>
    </indexterm>

    <para>Unter &os; stellt <application>SANE</application> (Scanner
      Access Now Easy) aus der Ports-Sammlung eine einheitliche
      Schnittstelle (<acronym>API</acronym>) für den Zugriff auf
      Scanner bereit.  <application>SANE</application> wiederum greift
      auf Scanner mithilfe einiger &os;-Treiber zu.</para>

    <para>&os; unterstützt sowohl <acronym>SCSI</acronym>- als auch
      <acronym>USB</acronym>-Scanner.  Abhängig von der Schnittstelle
      des Scanners, werden unterschiedliche Treiber benötigt.  Prüfen
      Sie vor der Konfiguration mithilfe der <link
	xlink:href="http://www.sane-project.org/sane-supported-devices.html">
	Liste der unterstützten Geräte</link> ob der Scanner von
      <application>SANE</application> unterstützt wird.</para>

    <para>Dieses Kapitel beschreibt, wie Sie feststellen können, ob
      der Scanner von &os; erkannt wurde.  Zudem enthält es einen
      Überblick über die Konfiguration und Verwendung von
      <application>SANE</application> unter &os;.</para>

    <sect2 xml:id="scanners-kernel-usb">
      <title>Den Scanner überprüfen</title>

      <para>Im <filename>GENERIC</filename>-Kernel sind schon alle,
	für einen <acronym>USB</acronym>-Scanner notwendigen Treiber
	enthalten.  Benutzer mit einem angepassten Kernel sollten
	sicherstellen, dass die Kernelkonfiguration die nachstehenden
	Zeilen enthält:</para>

      <programlisting>device usb
device uhci
device ohci
device ehci
device xhci</programlisting>

      <para>Um zu überprüfen ob der Scanner erkannt wird, schließen
	Sie den USB-Scanner an.  Prüfen Sie dann mit &man.dmesg.8;,
	ob der Scanner in den Systemmeldungen erscheint:</para>

      <screen>ugen0.2: &lt;EPSON&gt; at usbus0</screen>

      <para>In diesem Beispiel wurde ein
	&epson.perfection;&nbsp;1650 <acronym>USB</acronym>-Scanner an
	<filename>/dev/ugen0.2</filename> erkannt.</para>

      <para>Wenn der Scanner eine
	<acronym>SCSI</acronym>-Schnittstelle besitzt, ist die
	Kernelkonfiguration abhängig vom verwendeten
	<acronym>SCSI</acronym>-Controller.  Der
	<filename>GENERIC</filename>-Kernel unterstützt die
	gebräuchlichen <acronym>SCSI</acronym>-Controller.  Den
	richtigen Treiber finden Sie in
	<filename>/usr/src/sys/conf/NOTES</filename>.  Neben dem
	<acronym>SCSI</acronym>-Treiber muss die Kernelkonfiguration
	noch die nachstehenden Zeilen enthalten:</para>

      <programlisting>device scbus
device pass</programlisting>

      <para>Nachdem Sie einen Kernel gebaut und installiert haben,
	sollte der Scanner beim Neustart in den Systemmeldungen
	erscheinen:</para>

      <screen>pass2 at aic0 bus 0 target 2 lun 0
pass2: &lt;AGFA SNAPSCAN 600 1.10&gt; Fixed Scanner SCSI-2 device
pass2: 3.300MB/s transfers</screen>

      <para>Wenn der Scanner während des Systemstarts
	ausgeschaltet war, können Sie die Geräteerkennung
	erzwingen, indem Sie den <acronym>SCSI</acronym>-Bus erneut
	absuchen.  Verwenden Sie dazu
	<command>camcontrol</command>:</para>

      <screen>&prompt.root; <userinput>camcontrol rescan all</userinput>
Re-scan of bus 0 was successful
Re-scan of bus 1 was successful
Re-scan of bus 2 was successful
Re-scan of bus 3 was successful</screen>

      <para>Der Scanner sollte jetzt in der
	<acronym>SCSI</acronym>-Geräteliste erscheinen:</para>

      <screen>&prompt.root; <userinput>camcontrol devlist</userinput>
&lt;IBM DDRS-34560 S97B&gt;              at scbus0 target 5 lun 0 (pass0,da0)
&lt;IBM DDRS-34560 S97B&gt;              at scbus0 target 6 lun 0 (pass1,da1)
&lt;AGFA SNAPSCAN 600 1.10&gt;           at scbus1 target 2 lun 0 (pass3)
&lt;PHILIPS CDD3610 CD-R/RW 1.00&gt;     at scbus2 target 0 lun 0 (pass2,cd0)</screen>

      <para>Weitere Informationen über <acronym>SCSI</acronym>-Geräte
	unter &os; finden Sie in &man.scsi.4; und
	&man.camcontrol.8;.</para>
    </sect2>

    <sect2>
      <title><application>SANE</application> konfigurieren</title>

      <para>Das <application>SANE</application>-System ermöglicht den
	Zugriff auf den Scanner über Backends
	(<package>graphics/sane-backends</package>).  Lesen Sie <link
	  xlink:href="http://www.sane-project.org/sane-supported-devices.html">
	  http://www.sane-project.org/sane-supported-devices.html</link>
	um herauszufinden, welches Backend welchen Scanner
	unterstützt.  Eine graphische Oberfläche wird über Anwendungen
	von Drittanbietern wie <application>Kooka</application>
	(<package>graphics/kooka</package>) oder
	<application>XSane</application>
	(<package>graphics/xsane</package>) bereitgestellt.  Die
	Backends von <application>SANE</application> reichen aus, um
	den Scanner zu testen.</para>

      <para>Installieren Sie die Backends als Paket:</para>

      <screen>&prompt.root; <userinput>pkg install sane-backends</userinput></screen>

      <para>Alternativ können Sie die Backends aus der
	Ports-Sammlung installieren:</para>

      <screen>&prompt.root; <userinput>cd /usr/ports/graphics/sane-backends</userinput>
&prompt.root; <userinput>make install clean</userinput></screen>

      <para>Nachdem Sie den Port oder das Paket
	<package>graphics/sane-backends</package> installiert haben,
	können Sie mit dem Befehl <command>sane-find-scanner</command>
	prüfen, ob <application>SANE</application> den Scanner
	erkennt:</para>

      <screen>&prompt.root; <userinput>sane-find-scanner -q</userinput>
found SCSI scanner "AGFA SNAPSCAN 600 1.10" at /dev/pass3</screen>

      <para>Die Ausgabe zeigt die Schnittstelle und die verwendete
	Gerätedatei des Scanners.  Der Hersteller und das
	Modell können in der Ausgabe fehlen.</para>

      <note>
	<para>Bei einigen <acronym>USB</acronym>-Scannern muss die
	  Firmware geladen werden.  Lesen Sie sane-find-scanner(1) und
	  sane(7) für weitere Details.</para>
      </note>

      <para>Als nächstes müssen Sie prüfen, ob
	der Scanner vom Frontend erkannt wird.  Die
	<application>SANE</application>-Backends werden
	mit dem Kommandozeilenwerkzeug <command>scanimage</command>
	geliefert.  Mit diesem Werkzeug können Sie
	sich Scanner anzeigen lassen und den Scan-Prozess
	von der Kommandozeile starten.  Die Option
	<option>-L</option> zeigt die Scanner an.  Das erste Beispiel
	ist für einen <acronym>SCSI</acronym>-Scanner, das zweite ist
	für einen <acronym>USB</acronym>-Scanner:</para>

      <screen>&prompt.root; <userinput>scanimage -L</userinput>
device `snapscan:/dev/pass3' is a AGFA SNAPSCAN 600 flatbed scanner
&prompt.root; <userinput>scanimage -L</userinput>
device 'epson2:libusb:000:002' is a Epson GT-8200 flatbed scanner</screen>

      <para>Im zweiten Beispiel ist <literal>epson2</literal> der
	Backend-Name.  <literal>libusb:000:002</literal> bedeutet,
	dass <filename>/dev/ugen0.2</filename> die vom Scanner
	verwendete Gerätedatei ist.</para>

      <para>Wenn <command>scanimage</command> den Scanner nicht
	erkennen kann, erscheint folgende Meldung:</para>

      <screen>&prompt.root; <userinput>scanimage -L</userinput>

No scanners were identified. If you were expecting something different,
check that the scanner is plugged in, turned on and detected by the
sane-find-scanner tool (if appropriate). Please read the documentation
which came with this software (README, FAQ, manpages).</screen>

      <para>Wenn das passiert, müssen Sie in der Konfigurationsdatei
	des Backends unterhalb von
	<filename>/usr/local/etc/sane.d/</filename> den verwendeten
	Scanner eintragen.  Wenn der Scanner
	&epson.perfection;&nbsp;1650, der das Backend
	<literal>epson2</literal> benutzt, nicht erkannt wurde, muss
	<filename>/usr/local/etc/sane.d/epson2.conf</filename>
	angepasst werden.  Fügen Sie eine Zeile mit der Schnittstelle
	und dem Gerätenamen in die Datei ein.  In diesem Beispiel
	wurde die nachstehende Zeile eingefügt:</para>

	<programlisting>usb /dev/ugen0.2</programlisting>

	<para>Speichern Sie die Änderungen und prüfen Sie, ob der
	  Scanner mit dem richtigen Backend und Gerätenamen erkannt
	  wird:</para>

	<screen>&prompt.root; <userinput>scanimage -L</userinput>
device 'epson2:libusb:000:002' is a Epson GT-8200 flatbed scanner</screen>

      <para>Wenn <command>scanimage -L</command> den Scanner erkannt
	hat, ist der Scanner eingerichtet und bereit, zu
	scannen.</para>

      <para>Obwohl <command>scanimage</command> von der Kommandozeile
	scannen kann, ist eine graphische Anwendung
	zum Scannen besser geeignet.  Bekannte Programme sind
	<application>Koka</application> oder
	<application>XSane</application>.  Diese Frontends besitzten
	erweiterte Funktionen wie den Scan-Modus, Farbkorrektur und
	Batch-Scans.  <application>XSane</application> lässt sich auch
	als <application>GIMP</application>-Plugin verwenden.</para>
    </sect2>

    <sect2>
      <title>Berechtigungen für den Scanner</title>

      <para>Wenn andere Benutzer den Scanner benutzen sollen,
	müssen sie Lese- und Schreibrechte auf die
	Gerätedatei des Scanners besitzen.  Im vorherigen Beispiel
	wird die Datei <filename>/dev/ugen0.2</filename> verwendet,
	die faktisch nur ein Symlink auf die echte Gerätedatei,
	<filename>/dev/usb/0.2.0</filename> genannt, darstellt.
	Sowohl der Symlink als auch die Gerätedatei sind jeweils im
	Besitz der Gruppen <systemitem
	  class="groupname">wheel</systemitem> und <systemitem
	  class="groupname">operator</systemitem>.  Damit ein Benutzer
	den Scanner benutzen kann, muss er Mitglied in einer der
	beiden Gruppen sein.  Allerdings sollte aus Sicherheitsgründen
	genau überlegt werden, welche Benutzer zu welcher Gruppe
	hinzugefügt werden, besonders bei der Gruppe <systemitem
	  class="groupname">wheel</systemitem>.  Eine bessere
	Lösung ist es, eine spezielle Gruppe für den Zugriff
	anzulegen und den Scanner für Mitglieder dieser
	Gruppe zugänglich zu machen.</para>

      <para>Dieses Beispiel erstellt eine Gruppe namens <systemitem
	  class="groupname"><replaceable>usb</replaceable></systemitem>:</para>

      <screen>&prompt.root; <userinput>pw groupadd usb</userinput></screen>

      <para>Anschließend muss der
	<filename>/dev/ugen0.2</filename>-Symlink und der Gerätename
	<filename>/dev/usb/0.2.0</filename> für die Gruppe <systemitem
	  class="groupname">usb</systemitem> mit den Schreibrechten
	<literal>0660</literal> oder <literal>0664</literal>
	ausgestattet werden.  All dies kann durch das Hinzufügen der
	folgenden Zeilen in <filename>/etc/devfs.rules</filename>
	erreicht werden:</para>

      <programlisting>[system=5]
add path ugen0.2 mode 0660 group usb
add path usb/0.2.0 mode 0666 group usb</programlisting>

      <note>
	<para>Es kommt vor, dass sich der Gerätename mit dem
	  Hinzufügen oder Entfernen von Geräten ändert, so dass man
	  stattdessen vielleicht allen USB-Geräten mit diesem
	  Regelsatz Zugriff gewähren möchte:</para>
	
	<programlisting>[system=5]
add path 'ugen*' mode 0660 group usb
add path 'usb/*' mode 0666 group usb</programlisting>
      </note>

      <para>Weitere Informationen zu dieser Datei finden Sie
	in &man.devfs.rules.5;.</para>

      <para>Als nächstes aktivieren Sie den Regelsatz in
	<filename>/etc/rc.conf</filename>:</para>

      <programlisting>devfs_system_ruleset="system"</programlisting>

      <para>Starten Sie anschließend das &man.devfs.8;-System
	neu:</para>

      <screen>&prompt.root; <userinput>service devfs restart</userinput></screen>

      <para>Jetzt müssen nur noch Benutzer zur Gruppe <systemitem
	  class="groupname"><replaceable>usb</replaceable></systemitem>
	hinzugefügt werden, um ihnen den Zugriff auf den Scanner zu
	erlauben:</para>

      <screen>&prompt.root;<userinput>pw groupmod usb -m <replaceable>joe</replaceable></userinput></screen>

      <para>Weitere Details finden Sie in &man.pw.8;.</para>
    </sect2>
  </sect1>
</chapter>
