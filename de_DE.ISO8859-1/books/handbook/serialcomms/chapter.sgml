<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde: de-docproj/books/handbook/serialcomms/chapter.sgml,v 1.86 2010/12/18 11:50:16 jkois Exp $
     basiert auf: 1.134
-->

<chapter id="serialcomms">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Martin</firstname>
	<surname>Heinen</surname>
	<contrib>&Uuml;bersetzt von </contrib>
      </author>
    </authorgroup>
  </chapterinfo>

  <title>Serielle Daten&uuml;bertragung</title>

  <sect1 id="serial-synopsis">
    <title>&Uuml;bersicht</title>

    <indexterm><primary>serielle Daten&uuml;bertragung</primary></indexterm>
    <para>&unix; Systeme unterst&uuml;tzten schon immer die serielle
      Daten&uuml;bertragung.  Tats&auml;chlich wurden Ein- und Ausgaben auf
      den ersten &unix; Maschinen &uuml;ber serielle Leitungen
      durchgef&uuml;hrt.  Seit der Zeit, in der ein durchschnittlicher
      <quote>Terminal</quote> aus einem seriellen Drucker mit
      10&nbsp;Zeichen/Sekunde und einer Tastatur bestand, hat sich viel
      ver&auml;ndert.  Dieses Kapitel behandelt einige M&ouml;glichkeiten,
      serielle Daten&uuml;bertragung unter FreeBSD zu verwenden.</para>

    <para>Nachdem Sie dieses Kapitel durchgearbeitet haben, werden
      Sie Folgendes wissen:</para>
    <itemizedlist>
      <listitem><para>Wie Sie Terminals an Ihr FreeBSD anschlie&szlig;en.
	</para></listitem>
      <listitem><para>Wie Sie sich mit einem Modem auf einem entfernten
        Rechner einw&auml;hlen.</para></listitem>
      <listitem><para>Wie Sie entfernten Benutzern erlauben, sich mit einem
        Modem in Ihr System einzuw&auml;hlen.</para></listitem>
      <listitem><para>Wie Sie Ihr System &uuml;ber eine serielle Konsole
        booten.</para></listitem>
    </itemizedlist>

    <para>Bevor Sie dieses Kapitel lesen, sollten Sie</para>
    <itemizedlist>
      <listitem><para>einen neuen Kernel konfigurieren und installieren
        k&ouml;nnen (<xref linkend="kernelconfig">).</para></listitem>
      <listitem><para>Das Berechtigungskonzept von &unix; und Prozesse
        verstehen (<xref linkend="basics">).</para></listitem>
      <listitem><para>Zudem sollten Sie Zugriff auf die Handb&uuml;cher der
        seriellen Komponenten (Modem oder Multiportkarte) haben, die Sie
	mit FreeBSD verwenden wollen.</para></listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="serial">
    <title>Einf&uuml;hrung</title>

    <warning>
      <para>Mit &os;&nbsp;8.0 wurden die Ger&auml;tedateien f&uuml;r
	serielle Ports von
	<filename>/dev/ttyd<replaceable>N</replaceable></filename> in
	<filename>/dev/ttyu<replaceable>N</replaceable></filename>
	umbenannt.  Setzen Sie noch &os;&nbsp;7.X ein, m&uuml;ssen
	Sie die Befehle in den folgenden Abschnitten entsprechend
	anpassen.</para>
    </warning>

    <!-- XXX Write me! -->

    <sect2 id="serial-terminology">
      <title>Begriffe</title>

      <variablelist>
        <indexterm><primary>bits-per-second</primary></indexterm>
	<varlistentry>
	  <term>bps</term>
	  <listitem>
	    <para>Bits pro Sekunde &ndash; Einheit f&uuml;r die
	      &Uuml;bertragungsgeschwindigkeit.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>DEE (DTE)</term>
	  <indexterm><primary>DEE</primary></indexterm>
	  <indexterm><primary>DTE</primary></indexterm>
	  <listitem>
	    <para>Datenendeinrichtung (Data Terminal Equipment) &ndash;
	      zum Beispiel Ihr Computer.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>D&Uuml;E (DCE)</term>
	  <indexterm><primary>D&Uuml;E</primary></indexterm>
	  <indexterm><primary>DCE</primary></indexterm>
	  <listitem>
	    <para>Daten&uuml;bertragungseinrichtung (Data Communications
	      Equipment) &ndash;  Ein Modem.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>RS-232</term>
	  <indexterm><primary>RS-232C Kabel</primary></indexterm>
	  <listitem>
	    <para>EIA (Electronic Industries Association) Norm f&uuml;r
	      die serielle Daten&uuml;bertragung.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>In diesem Abschnitt wird der Begriff <quote>Baud</quote> nicht
        f&uuml;r &Uuml;bertragungsgeschwindigkeiten gebraucht.  Baud
	bezeichnet elektrische Zustandswechsel pro Zeiteinheit, die Taktfrequenz,
	w&auml;hrend <quote>bps</quote> (Bits pro Sekunde) der
	<emphasis>richtige</emphasis> Begriff f&uuml;r die
	&Uuml;bertragungsgeschwindigkeit ist (die meisten Pedanten sollten
	damit zufrieden sein).</para>
    </sect2>

    <sect2 id="serial-cables-ports">
      <title>Kabel und Schnittstellen</title>

      <para>Um ein Modem oder einen Terminal an Ihr FreeBSD-System
        anzuschlie&szlig;en, muss Ihr Computer &uuml;ber eine serielle
	Schnittstelle verf&uuml;gen.  Zus&auml;tzlich brauchen Sie noch das
	passende Kabel, um das Ger&auml;t mit der Schnittstelle zu
	verbinden.  Wenn Sie mit Ihren Ger&auml;ten und den n&ouml;tigen
	Kabeln schon vertraut sind, k&ouml;nnen Sie diesen Abschnitt
	&uuml;berspringen.</para>

      <sect3 id="term-cables">
	<title>Kabel</title>

	<para>Es gibt verschiedene serielle Kabel.  Die zwei h&auml;ufigsten
	  sind Nullmodemkabel und Standard-RS-232-Kabel.  Die
	  Dokumentation Ihrer Hardware sollte beschreiben, welchen Kabeltyp
	  Sie ben&ouml;tigen.</para>

	<sect4 id="term-cables-null">
	  <title>Nullmodemkabel</title>

	  <indexterm>
	    <primary>Nullmodemkabel</primary>
	  </indexterm>
	  <para>Ein Nullmodemkabel verbindet einige Signale, wie die
	    Betriebserde, eins zu eins, andere Signale werden getauscht:
	    Die Sende- und Empfangsleitungen werden zum Beispiel
	    gekreuzt.</para>

	  <para>Sie k&ouml;nnen das Kabel f&uuml;r die Anbindung eines
	    Terminals auch selbst herstellen.  Die folgende Tabelle
	    enth&auml;lt die <link
	    linkend="serialcomms-signal-names">Signalnamen</link> von
	    RS-232C sowie die Pinbelegung f&uuml;r einen Stecker vom
	    Typ DB-25.  Beachten Sie dabei aber, dass der Standard
	    zwar eine direkte Verbindung beider Pin 1
	    (<emphasis>Protective Ground</emphasis>) vorschreibt, diese
	    aber in vielen F&auml;llen nicht vorhanden ist.  Einige
	    Terminals ben&ouml;tigen nur die Pins 2, 3 und 7 f&uuml;r
	    eine korrekte Funktion, w&auml;hrend andere eine
	    unterschiedliche Konfiguration als die in den folgenden
	    Beispielen gezeigte ben&ouml;tigen.</para>

	  <table frame="none" pgwide="1">
	    <title>Nullmodemkabel vom Typ DB-25-zu-DB-25</title>

	    <tgroup cols="5">
	      <thead>
		<row>
		  <entry align="left">Signal</entry>
		  <entry align="left">Pin #</entry>
		  <entry align="left"></entry>
		  <entry align="left">Pin #</entry>
		  <entry align="left">Signal</entry>
		</row>
	      </thead>

	      <tbody>
		<row>
		  <entry>SG</entry>
		  <entry>7</entry>
		  <entry>verbunden mit</entry>
		  <entry>7</entry>
		  <entry>SG</entry>
		</row>

		<row>
		  <entry>TD</entry>
		  <entry>2</entry>
		  <entry>verbunden mit</entry>
		  <entry>3</entry>
		  <entry>RD</entry>
		</row>

		<row>
		  <entry>RD</entry>
		  <entry>3</entry>
		  <entry>verbunden mit</entry>
		  <entry>2</entry>
		  <entry>TD</entry>
		</row>

		<row>
		  <entry>RTS</entry>
		  <entry>4</entry>
		  <entry>verbunden mit</entry>
		  <entry>5</entry>
		  <entry>CTS</entry>
		</row>

		<row>
		  <entry>CTS</entry>
		  <entry>5</entry>
		  <entry>verbunden mit</entry>
		  <entry>4</entry>
		  <entry>RTS</entry>
		</row>

		<row>
		  <entry>DTR</entry>
		  <entry>20</entry>
		  <entry>verbunden mit</entry>
		  <entry>6</entry>
		  <entry>DSR</entry>
		</row>

		<row>
		  <entry>DTR</entry>
		  <entry>20</entry>
		  <entry>verbunden mit</entry>
		  <entry>8</entry>
		  <entry>DCD</entry>
		</row>

		<row>
		  <entry>DSR</entry>
		  <entry>6</entry>
		  <entry>verbunden mit</entry>
		  <entry>20</entry>
		  <entry>DTR</entry>
		</row>

		<row>
		  <entry>DCD</entry>
		  <entry>8</entry>
		  <entry>verbunden mit</entry>
		  <entry>20</entry>
		  <entry>DTR</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>

	  <para>Die folgenden zwei Schemata werden heutzutage ebenfalls
	    h&auml;ufig eingesetzt:</para>

          <table frame="none" pgwide="1">
            <title>Nullmodemkabel vom Typ DB-9-zu-DB-9</title>

            <tgroup cols="5">
              <thead>
                <row>
                  <entry align="left">Signal</entry>
                  <entry align="left">Pin #</entry>
                  <entry align="left"></entry>
                  <entry align="left">Pin #</entry>
                  <entry align="left">Signal</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>RD</entry>
                  <entry>2</entry>
                  <entry>verbunden mit</entry>
                  <entry>3</entry>
                  <entry>TD</entry>
                </row>

                <row>
                  <entry>TD</entry>
                  <entry>3</entry>
                  <entry>verbunden mit</entry>
                  <entry>2</entry>
                  <entry>RD</entry>
                </row>

                <row>
                  <entry>DTR</entry>
                  <entry>4</entry>
                  <entry>verbunden mit</entry>
                  <entry>6</entry>
                  <entry>DSR</entry>
                </row>

                <row>
                  <entry>DTR</entry>
                  <entry>4</entry>
                  <entry>verbunden mit</entry>
                  <entry>1</entry>
                  <entry>DCD</entry>
                </row>

                <row>
                  <entry>SG</entry>
                  <entry>5</entry>
                  <entry>verbunden mit</entry>
                  <entry>5</entry>
                  <entry>SG</entry>
                </row>

                <row>
                  <entry>DSR</entry>
                  <entry>6</entry>
                  <entry>verbunden mit</entry>
                  <entry>4</entry>
                  <entry>DTR</entry>
                </row>

                <row>
                  <entry>DCD</entry>
                  <entry>1</entry>
                  <entry>verbunden mit</entry>
                  <entry>4</entry>
                  <entry>DTR</entry>
                </row>

                <row>
                  <entry>RTS</entry>
                  <entry>7</entry>
                  <entry>verbunden mit</entry>
                  <entry>8</entry>
                  <entry>CTS</entry>
                </row>

                <row>
                  <entry>CTS</entry>
                  <entry>8</entry>
                  <entry>verbunden mit</entry>
                  <entry>7</entry>
                  <entry>RTS</entry>
                </row>
              </tbody>
            </tgroup>
          </table>

          <table frame="none" pgwide="1">
            <title>Nullmodemkabel vom Typ DB-9-zu-DB-25</title>

            <tgroup cols="5">
              <thead>
                <row>
                  <entry align="left">Signal</entry>
                  <entry align="left">Pin #</entry>
                  <entry align="left"></entry>
                  <entry align="left">Pin #</entry>
                  <entry align="left">Signal</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>RD</entry>
                  <entry>2</entry>
                  <entry>verbunden mit</entry>
                  <entry>2</entry>
                  <entry>TD</entry>
                </row>

                <row>
                  <entry>TD</entry>
                  <entry>3</entry>
                  <entry>verbunden mit</entry>
                  <entry>3</entry>
                  <entry>RD</entry>
                </row>

                <row>
                  <entry>DTR</entry>
                  <entry>4</entry>
                  <entry>verbunden mit</entry>
                  <entry>6</entry>
                  <entry>DSR</entry>
                </row>

                <row>
                  <entry>DTR</entry>
                  <entry>4</entry>
                  <entry>verbunden mit</entry>
                  <entry>8</entry>
                  <entry>DCD</entry>
                </row>

                <row>
                  <entry>SG</entry>
                  <entry>5</entry>
                  <entry>verbunden mit</entry>
                  <entry>7</entry>
                  <entry>SG</entry>
                </row>

                <row>
                  <entry>DSR</entry>
                  <entry>6</entry>
                  <entry>verbunden mit</entry>
                  <entry>20</entry>
                  <entry>DTR</entry>
                </row>

                <row>
                  <entry>DCD</entry>
                  <entry>1</entry>
                  <entry>verbunden mit</entry>
                  <entry>20</entry>
                  <entry>DTR</entry>
                </row>

                <row>
                  <entry>RTS</entry>
                  <entry>7</entry>
                  <entry>verbunden mit</entry>
                  <entry>5</entry>
                  <entry>CTS</entry>
                </row>

                <row>
                  <entry>CTS</entry>
                  <entry>8</entry>
                  <entry>verbunden mit</entry>
                  <entry>4</entry>
                  <entry>RTS</entry>
                </row>
              </tbody>
            </tgroup>
          </table>

	  <note>
	    <para>Wird ein Pin eines Kabels mit zwei Pins des anderen
	      Kabels verbunden, werden dazu in der Regel zuerst die
	      beiden Pins mit einem kurzem Draht verbunden.  Danach
	      wird dieser Draht mit dem Pin des anderen Endes
	      verbunden.</para>
	  </note>

	  <para>Die eben besprochenen Schemata scheinen die beliebtesten
	    zu sein.  Es gibt aber noch weitere Varianten.  Im Buch
	    <emphasis>RS-232 Made Easy</emphasis> wird beispielsweise
	    SG mit SG verbunden, TD mit RD, RTS und CTS mit DCD, DTR
	    mit DSR, und umgekehrt.</para>
	</sect4>

	<sect4 id="term-cables-std">
	  <title>Standard RS-232C Kabel</title>
	  <indexterm><primary>RS-232C Kabel</primary></indexterm>

	  <para>Ein Standard-RS-232C-Kabel verbindet alle Signale direkt,
	    das hei&szlig;t das Signal <quote>Transmitted Data</quote> wird mit
	    dem Signal <quote>Transmitted Data</quote> der Gegenstelle verbunden.
	    Dieses Kabel wird ben&ouml;tigt, um ein Modem mit einem
	    FreeBSD-System zu verbinden.  Manche Terminals ben&ouml;tigen dieses
	    Kabel ebenfalls.</para>
	</sect4>
      </sect3>

      <sect3 id="term-ports">
	<title>Schnittstellen</title>

	<para>&Uuml;ber serielle Schnittstellen werden Daten zwischen dem
	  FreeBSD-System und dem Terminal &uuml;bertragen.  Dieser
	  Abschnitt beschreibt die verschiedenen Schnittstellen und wie sie
	  unter FreeBSD angesprochen werden.</para>

	<sect4 id="term-portkinds">
	  <title>Arten von Schnittstellen</title>

	  <para>Da es verschiedene Schnittstellen gibt, sollten Sie vor
	    dem Kauf oder Selbstbau eines Kabels sicherstellen, dass
	    dieses zu den Schnittstellen Ihres Terminals und
	    FreeBSD-Systems passt.</para>

	  <para>Die meisten Terminals besitzen DB-25-Stecker.
	    Personal Computer haben DB-25- oder DB-9-Stecker.  Wenn
	    Sie eine serielle Multiportkarte f&uuml;r Ihren PC besitzen,
	    haben Sie vielleicht RJ-12- oder RJ-45-Anschl&uuml;sse.</para>

	  <para>Die Dokumentation Ihrer Ger&auml;te sollte Aufschluss
	    &uuml;ber den Typ der ben&ouml;tigten Anschl&uuml;sse geben.
	    Oft hilft es, wenn Sie sich den Anschluss einfach
	    ansehen.</para>
	</sect4>

	<sect4 id="term-portnames">
	  <title>Schnittstellenbezeichnung</title>

	  <para>Unter FreeBSD sprechen Sie die serielle Schnittstelle
	    (Port) &uuml;ber einen Eintrag im <filename>/dev</filename>
	    Verzeichnis an.  Es gibt dort zwei verschiedene
	    Eintr&auml;ge:</para>

	  <itemizedlist>
	    <listitem>
	      <para>Schnittstellen f&uuml;r eingehende Verbindungen werden
	        <filename>/dev/ttyu<replaceable>N</replaceable></filename>
		genannt.  Dabei ist <replaceable>N</replaceable> die Nummer
		der Schnittstelle, deren Z&auml;hlung bei Null beginnt.
		Allgemein wird diese Schnittstelle f&uuml;r Terminals
		benutzt.  Diese Schnittstelle funktioniert nur, wenn ein
		<quote>Data Carrier Detect</quote> Signal (DCD)
		vorliegt.</para>
	    </listitem>

	    <listitem>
	      <para>F&uuml;r ausgehende Verbindungen wird
	        <filename>/dev/cuad<replaceable>N</replaceable></filename>
		verwendet.  Dieser Port wird normalerweise nur von
		Modems genutzt.  Sie k&ouml;nnen ihn allerdings f&uuml;r
		Terminals benutzen, die das <quote>Data Carrier Detect</quote>
		Signal nicht unterst&uuml;tzen.</para>
	    </listitem>
	  </itemizedlist>

	  <para>Wenn Sie einen Terminal an die erste serielle Schnittstelle
	    (<devicename>COM1</devicename> in &ms-dos;), angeschlossen haben,
	    sprechen Sie ihn &uuml;ber <filename>/dev/ttyu0</filename> an.
	    Wenn er an der zweiten seriellen Schnittstelle angeschlossen
	    ist, verwenden Sie <filename>/dev/ttyu1</filename>, usw.</para>

	</sect4>
      </sect3>
    </sect2>

    <sect2>
      <title>Kernelkonfiguration</title>

      <para>In der Voreinstellung benutzt FreeBSD vier serielle
        Schnittstellen, die in &ms-dos;-Kreisen als
	<devicename>COM1</devicename>, <devicename>COM2</devicename>,
	<devicename>COM3</devicename> und <devicename>COM4</devicename>
	bekannt sind.  Momentan unterst&uuml;tzt FreeBSD einfache
	Multiportkarten (z.B. die BocaBoard 1008 und 2016) und bessere wie
	die von Digiboard und Stallion Technologies.  In der Voreinstellung
	sucht der Kernel allerdings nur nach den
	Standardanschl&uuml;ssen.</para>

      <para>Um zu &uuml;berpr&uuml;fen, ob der Kernel eine Ihrer seriellen
        Schnittstellen erkennt, achten Sie auf die Meldungen beim Booten,
	oder schauen sich diese sp&auml;ter mit
	<command>/sbin/dmesg</command> an.  Insbesondere sollten Sie auf
	Meldungen achten, die mit den Zeichen <literal>sio</literal>
	anfangen.</para>

      <tip><para>Das folgende Kommando zeigt Ihnen nur die Meldungen an,
        die die Folge <literal>sio</literal> enthalten:</para>

      <screen>&prompt.root; <userinput>/sbin/dmesg | grep 'sio'</userinput></screen>
      </tip>

      <para>Auf einem System mit vier seriellen Schnittstellen sollte der
        Kernel die folgenden Meldungen ausgeben:</para>

      <screen>sio0 at 0x3f8-0x3ff irq 4 on isa
sio0: type 16550A
sio1 at 0x2f8-0x2ff irq 3 on isa
sio1: type 16550A
sio2 at 0x3e8-0x3ef irq 5 on isa
sio2: type 16550A
sio3 at 0x2e8-0x2ef irq 9 on isa
sio3: type 16550A</screen>

      <para>Wenn Ihr Kernel nicht alle seriellen Schnittstellen erkennt,
	m&uuml;ssen Sie Ihren Kernel &uuml;ber die Datei
	<filename>/boot/device.hints</filename> konfigurieren.
	Zus&auml;tzlich k&ouml;nnen Sie Eintr&auml;ge f&uuml;r
	Ger&auml;te, die auf Ihrem System nicht vorhanden sind, aus dem
	Kernel entfernen.</para>

      <para>Die Hilfeseite &man.sio.4; enth&auml;lt weitere Informationen
	zu seriellen Schnittstellen und Multiportkarten.
	Seien Sie vorsichtig, wenn Sie Konfigurationsdateien
	von &auml;lteren FreeBSD-Versionen verwenden, da sich die Syntax
	und die Bedeutung der Optionen zwischen verschiedenen
	Versionen ge&auml;ndert hat.</para>

      <note>
	<para><literal>port IO_COM1</literal> ist ein Ersatz f&uuml;r
	  <literal>port 0x3f8</literal>, <literal>IO_COM2</literal>
	  bedeutet <literal>port 0x2f8</literal>, <literal>IO_COM3</literal>
	  bedeutet <literal>port 0x3e8</literal> und <literal>IO_COM4</literal>
	  steht f&uuml;r <literal>port 0x2e8</literal>.  Die angegebenen
	  IO-Adressen sind genau wie die Interrupts 4, 3, 5 und 9
	  &uuml;blich f&uuml;r serielle Schnittstellen.  Beachten Sie
	  bitte, dass sich normale serielle Schnittstellen auf ISA-Bussen
	  <emphasis>keine</emphasis> Interrupts teilen k&ouml;nnen.
	  Multiportkarten besitzen zus&auml;tzliche Schaltkreise, die es
	  allen 16550As auf der Karte erlauben, sich einen oder zwei
	  Interrupts zu teilen.</para>
      </note>

    </sect2>

    <sect2>
      <title>Ger&auml;tedateien</title>

      <para>Die meisten Ger&auml;te im Kernel werden durch
        Ger&auml;tedateien in <filename>/dev</filename> angesprochen.  Die
	<devicename>sio</devicename> Ger&auml;te werden durch
	<filename>/dev/ttyu<replaceable>N</replaceable></filename>
	f&uuml;r eingehende Verbindungen und durch
	<filename>/dev/cuad<replaceable>N</replaceable></filename> f&uuml;r
	ausgehende Verbindungen angesprochen.  Zum Initialisieren der
	Ger&auml;te stellt FreeBSD die Dateien
	<filename>/dev/ttyu<replaceable>N</replaceable>.init</filename> und
	<filename>/dev/cuad<replaceable>N</replaceable>.init</filename>
	zur Verf&uuml;gung.
	Zus&auml;tzlich existieren Dateien f&uuml;r das Sperren von
	Ger&auml;tedateien (<foreignphrase>Locking</foreignphrase>).
	Dabei handelt es sich um die Dateien
	<filename>/dev/ttyu<replaceable>N</replaceable>.lock</filename>
	und
	<filename>/dev/cuad<replaceable>N</replaceable>.lock</filename>.
	Diese Dateien werden benutzt, um Kommunikationsparameter beim
	&Ouml;ffnen eines Ports vorzugeben.  F&uuml;r Modems, die zur
	Flusskontrolle <literal>RTS/CTS</literal> benutzen, kann damit
	<literal>crtscts</literal> gesetzt werden.  Die Ger&auml;te
	<filename>/dev/ttyld<replaceable>N</replaceable></filename> und
	<filename>/dev/cuala<replaceable>N</replaceable></filename> (locking
	devices) werden genutzt, um bestimmte Parameter festzuschreiben und
	vor Ver&auml;nderungen zu sch&uuml;tzen.  Weitere Informationen
	zu Terminals finden Sie in &man.termios.4;, &man.sio.4; erkl&auml;rt
	die Dateien zum Initialisieren und Sperren der Ger&auml;te,
	&man.stty.1; beschreibt schlie&szlig;lich
	Terminal-Einstellungen.</para>
    </sect2>

    <sect2 id="serial-hw-config">
      <title>Konfiguration der seriellen Schnittstelle</title>

    <indexterm><primary><devicename>ttyu</devicename></primary></indexterm>
    <indexterm><primary><devicename>cuad</devicename></primary></indexterm>

    <para>Anwendungen benutzen normalerweise die Ger&auml;te
      <devicename>ttyu<replaceable>N</replaceable></devicename> oder
      <devicename>cuad<replaceable>N</replaceable></devicename>.  Das
      Ger&auml;t besitzt einige Voreinstellungen f&uuml;r Terminal-I/O,
      wenn es von einem Prozess ge&ouml;ffnet wird.  Mit dem folgenden
      Kommando k&ouml;nnen Sie sich diese Einstellungen ansehen:</para>

    <screen>&prompt.root; <userinput>stty -a -f /dev/ttyu1</userinput></screen>

    <para>Sie k&ouml;nnen diese Einstellungen ver&auml;ndern, sie bleiben
      allerdings nur solange wirksam, bis das Ger&auml;t geschlossen wird.
      Wenn das Ger&auml;t danach wieder ge&ouml;ffnet wird, sind die
      Voreinstellungen wieder wirksam.  Um die Voreinstellungen zu
      &auml;ndern, &ouml;ffnen Sie das Ger&auml;t, das zum Initialisieren
      dient und ver&auml;ndern dessen Einstellungen.  Um beispielsweise
      f&uuml;r <devicename>ttyu5</devicename> den <option>CLOCAL</option>
      Modus, 8-Bit Kommunikation und <option>XON/XOFF</option>
      Flusssteuerung einzuschalten, setzen Sie das folgende
      Kommando ab:</para>

    <screen>&prompt.root; <userinput>stty -f /dev/ttyu5.init clocal cs8 ixon ixoff</userinput></screen>

    <indexterm>
      <primary>rc-Dateien</primary>
      <secondary><filename>rc.serial</filename></secondary>
    </indexterm>

    <para>In <filename>/etc/rc.d/rc.serial</filename> werden die
      systemweiten Voreinstellungen f&uuml;r serielle Ger&auml;te
      vorgenommen.</para>

    <para>Um zu verhindern, dass Einstellungen von Anwendungen
      ver&auml;ndert werden, k&ouml;nnen Sie die Ger&auml;te zum
      Festschreiben von Einstellungen (<quote>locking devices</quote>)
      benutzen.  Wenn sie beispielsweise die Geschwindigkeit von
      <devicename>ttyu5</devicename> auf 57600&nbsp;bps festlegen wollen,
      benutzen Sie das folgende Kommando:</para>

    <screen>&prompt.root; <userinput>stty -f /dev/ttyld5 57600</userinput></screen>

    <para>Eine Anwendung, die <devicename>ttyu5</devicename> &ouml;ffnet,
      kann nun nicht mehr die Geschwindigkeit &auml;ndern und muss
      57600&nbsp;bps benutzen.</para>

    <para>Die Ger&auml;te zum Initialisieren und Festschreiben von
      Einstellungen sollten selbstverst&auml;ndlich nur von
      <username>root</username> beschreibbar sein.</para>
    </sect2>
  </sect1>

  <sect1 id="term">
    <sect1info>
      <authorgroup>
        <author>
	  <firstname>Sean</firstname>
	  <surname>Kelly</surname>
	  <contrib>Beigetragen von </contrib>
	</author>
	<!-- 28 July 1996 -->
      </authorgroup>
    </sect1info>
    <title>Terminals</title>

    <warning>
      <para>Mit &os;&nbsp;8.0 wurden die Ger&auml;tedateien f&uuml;r
	serielle Ports von
	<filename>/dev/ttyd<replaceable>N</replaceable></filename> in
	<filename>/dev/ttyu<replaceable>N</replaceable></filename>
	umbenannt.  Setzen Sie noch &os;&nbsp;7.X ein, m&uuml;ssen
	Sie die Befehle in den folgenden Abschnitten entsprechend
	anpassen.</para>
    </warning>

    <indexterm><primary>Terminals</primary></indexterm>

    <para>Wenn Sie sich nicht an der Konsole oder &uuml;ber ein Netzwerk an
      Ihrem FreeBSD-System anmelden k&ouml;nnen, sind Terminals ein
      bequemer und billiger Weg auf Ihr System zuzugreifen.  Dieser
      Abschnitt beschreibt wie Sie Terminals mit FreeBSD benutzen.</para>

    <sect2 id="term-uses">
      <title>Terminaltypen</title>

      <para>Das urspr&uuml;ngliche &unix; System besa&szlig; keine Konsolen.
	Zum Anmelden und Starten von Programmen wurden stattdessen
	Terminals benutzt, die an den seriellen Schnittstellen des Rechners
	angeschlossen waren.  Dies entspricht der Benutzung eines Modems
	zum Anmelden auf einem entfernten System, um dort mit einem
	Terminalemulator im Textmodus zu arbeiten.</para>

      <para>Die Konsolen heutiger PCs besitzen sehr gute
	Grafikf&auml;higkeiten, trotzdem gibt es in fast jedem &unix; System
	die M&ouml;glichkeit, sich &uuml;ber die serielle Schnittstelle
	anzumelden; FreeBSD ist da keine Ausnahme.  Sie k&ouml;nnen sich an
	einem Terminal anmelden und dort jedes Textprogramm, das Sie
	normalerweise an der Konsole oder in einem <command>xterm</command>
	Fenster im X Window System benutzen, laufen lassen.</para>

      <para>Im kommerziellen Umfeld k&ouml;nnen Sie viele Terminals an ein
        FreeBSD-System anschlie&szlig;en und diese auf den
	Arbeitspl&auml;tzen Ihrer Angestellten aufstellen.  Im privaten
	Umfeld kann ein &auml;lterer IBM PC oder &macintosh; als Terminal
	dienen.  Damit verwandeln Sie einen Einzelarbeitsplatz in ein
	leistungsf&auml;higes Mehrbenutzersystem.</para>

      <para>FreeBSD kennt drei verschiedene Terminals:</para>

      <itemizedlist>
	<listitem>
	  <para><link linkend="term-dumb">Dumb terminals,</link></para>
	</listitem>

	<listitem>
	  <para><link linkend="term-pcs">PCs, die als Terminals
	    fungieren,</link></para>
	</listitem>

	<listitem>
	  <para><link linkend="term-x">X Terminals.</link></para>
	</listitem>
      </itemizedlist>

      <para>Die folgenden Abschnitte beschreiben jeden dieser Terminals.</para>

      <sect3 id="term-dumb">
	<title>Dumb-Terminals</title>

	<para>Dumb-Terminals (unintelligente Datenstationen) sind
	  Ger&auml;te, die &uuml;ber die serielle Schnittstelle mit einem
	  Rechner verbunden werden.  Sie werden
	  <quote>unintelligent</quote> genannt, weil sie nur Text senden
	  und empfangen und keine Programme laufen lassen k&ouml;nnen.
	  Alle Programme, wie Texteditoren, Compiler oder Spiele befinden
	  sich auf dem Rechner, der mit dem Terminal verbunden ist.</para>

	<para>Es gibt viele Dumb-Terminals, die von verschiedenen
	  Herstellern produziert werden, wie zum Beispiel der VT-100 von
	  Digital Equipment Corporation oder der WY-75 von Wyse.  So gut
	  wie jeder der verschiedenen Terminals sollte mit FreeBSD
	  zusammenarbeiten.  Manche High-End Ger&auml;te verf&uuml;gen
	  sogar &uuml;ber Grafikf&auml;higkeiten, die allerdings nur von
	  spezieller Software genutzt werden kann.</para>

	<para>Dumb-Terminals sind in Umgebungen beliebt, in denen keine
	  Grafikanwendungen, wie zum Beispiel X-Programme, laufen
	  m&uuml;ssen.</para>
      </sect3>

      <sect3 id="term-pcs">
	<title>PCs, die als Terminal fungieren</title>

	<para>Jeder PC kann die Funktion eines <link linkend="term-dumb">
	    Dumb-Terminals</link>, der ja nur
	  Text senden und empfangen kann, &uuml;bernehmen.  Dazu brauchen
	  Sie nur das richtige Kabel und eine
	  <emphasis>Terminalemulation</emphasis>, die auf dem PC
	  l&auml;uft.</para>

	<para>Diese Konfiguration ist im privaten Umfeld sehr beliebt.  Wenn
	  Ihr Ehepartner zum Beispiel gerade an der FreeBSD-Konsole arbeitet,
	  k&ouml;nnen Sie einen weniger leistungsstarken PC, der als
	  Terminal mit dem FreeBSD-System verbunden ist, benutzen, um dort
	  gleichzeitig im Textmodus zu arbeiten.</para>

	<para>Bereits im Basissystem sind mindestens zwei Werkzeuge
	  vorhanden, die Sie zur Arbeit &uuml;ber eine serielle Konsole
	  einsetzen k&ouml;nnen:  &man.cu.1; sowie &man.tip.1;.</para>

	<para>Um sich von einem &os;-System aus &uuml;ber eine serielle
	  Verbindung mit einem anderen System zu verbinden, geben Sie
	  folgenden Befehl ein:</para>

	<screen>&prompt.root; <userinput>cu -l <replaceable>serial-port-device</replaceable></userinput></screen>

	<para><quote>serial-port-device</quote> ist hier der Name der
	  Ger&auml;tedatei, die einer bestimmten seriellen Schnittstelle
	  Ihres Systems zugewiesen ist.  Diese Ger&auml;tedateien werden
	  <devicename>/dev/cuad<replaceable>N</replaceable></devicename>
	  genannt.</para>

	<para>Der Buchstabe <quote>N</quote> muss dabei durch die Nummer
	  des seriellen Ports Ihres Systems ersetzt werden.</para>

	<note>
	  <para>Beachten Sie, dass die Numerierung dieses Daten (im
	    Gegensatz etwa zu &ms-dos;-kompatiblen Systemen) unter &os;
	    mit Null und nicht mit Eins beginnt.  Die Schnittstelle
	    <quote>COM1</quote> entspricht daher in der Regel
	    <filename>/dev/cuad0</filename> unter &os;.</para>
	</note>

	<note>
	  <para>In der Ports-Sammlung finden sich weitere Programme
	    (beispielsweise <filename
	    role="package">comms/minicom</filename>), mit denen Sie
	    eine Verbindung &uuml;ber eine serielle Schnittstelle
	    herstellen k&ouml;nnen.</para>
	</note>
      </sect3>

      <sect3 id="term-x">
	<title>X-Terminals</title>

	<para>X-Terminals sind die ausgereiftesten der verf&uuml;gbaren
	  Terminals.  Sie werden nicht mit der seriellen Schnittstelle
	  sondern mit einem Netzwerk, wie dem Ethernet, verbunden.  Diese
	  Terminals sind auch nicht auf den Textmodus beschr&auml;nkt,
	  sondern k&ouml;nnen jede X-Anwendung darstellen.</para>

	<para>X-Terminals sind hier nur der Vollst&auml;ndigkeit halber
	  aufgez&auml;hlt.  Die Einrichtung von X-Terminals wird in diesem
	  Abschnitt <emphasis>nicht</emphasis> beschrieben.</para>
      </sect3>
    </sect2>

    <sect2 id="term-config">
      <title>Konfiguration</title>

      <para>Im Folgenden wird beschrieben, wie Sie Ihr FreeBSD-System
        konfigurieren m&uuml;ssen, um sich an einem Terminal anzumelden.
	Dabei wird vorausgesetzt, dass der Kernel bereits die
	serielle Schnittstelle, die mit dem Terminal verbunden ist,
	unterst&uuml;tzt.  Weiterhin sollte der Terminal schon
	angeschlossen sein.</para>

      <para>Aus <xref linkend="boot"> wissen Sie, dass
        <command>init</command> f&uuml;r das Initialisieren des Systems und
	den Start von Prozessen zum Zeitpunkt des Systemstarts
	verantwortlich ist.  Unter anderem liest <command>init</command>
	<filename>/etc/ttys</filename> ein und startet f&uuml;r jeden
	verf&uuml;gbaren Terminal einen <command>getty</command>
	Prozess.  <command>getty</command> wiederum fragt beim
	Anmelden den Benutzernamen ab und startet
	<command>login</command>.</para>

      <para>Um Terminals auf Ihrem FreeBSD-System einzurichten, f&uuml;hren
        Sie folgenden Schritte als <username>root</username> durch:</para>

      <procedure>
	<step>
	  <para>Wenn er noch nicht da ist, f&uuml;gen Sie einen Eintrag in
	    <filename>/etc/ttys</filename> f&uuml;r die serielle
	    Schnittstelle aus <filename>/dev</filename> ein.</para>
	</step>

	<step>
	  <para>Geben Sie <command>/usr/libexec/getty</command> als
	    auszuf&uuml;hrendes Programm an.  Als Parameter f&uuml;r
	    <command>getty</command> geben Sie den passenden Verbindungstyp
	    aus <filename>/etc/gettytab</filename> an.</para>
	</step>

	<step>
	  <para>Geben Sie den Terminaltyp an.</para>
	</step>

	<step>
	  <para>Aktivieren Sie den Anschluss.</para>
	</step>

	<step>
	  <para>Geben Sie die Sicherheit des Anschlusses an.</para>
	</step>

	<step>
	  <para>Veranlassen Sie <command>init</command>
	    <filename>/etc/ttys</filename> erneut zu lesen.</para>
	</step>
      </procedure>

      <para>Optional k&ouml;nnen Sie in <filename>/etc/gettytab</filename>
	auch einen auf Ihre Zwecke angepassten Terminaltyp erstellen.
	Die genaue Vorgehensweise wird in diesem Abschnitt nicht
	erkl&auml;rt, aber die Manualpages von &man.gettytab.5; und
	&man.getty.8; enthalten dazu weitere Informationen.</para>

      <sect3 id="term-etcttys">
	<title>Hinzuf&uuml;gen eines Eintrags in
	  <filename>/etc/ttys</filename></title>

	<para>In <filename>/etc/ttys</filename> werden alle Terminals
	  aufgef&uuml;hrt, an denen Sie sich auf dem FreeBSD-System
	  anmelden k&ouml;nnen.  Hier findet sich zum Beispiel ein Eintrag
	  f&uuml;r die erste virtuelle Konsole
	  <devicename>/dev/ttyv0</devicename>, der es Ihnen erm&ouml;glicht,
	  sich dort anzumelden.  Die Datei enth&auml;lt des Weiteren
	  Eintr&auml;ge f&uuml;r andere virtuelle Konsolen, serielle
	  Schnittstellen und Pseudoterminals.  Wenn Sie einen Terminal
	  konfigurieren wollen, f&uuml;gen sie einen Eintrag f&uuml;r den
	  Namen des Ger&auml;tes aus <filename>/dev</filename> ohne das
	  Pr&auml;fix <filename>/dev</filename> hinzu.  Zum Beispiel wird
	  <filename>/dev/ttyv0</filename> als
	  <devicename>ttyv0</devicename> aufgef&uuml;hrt.</para>

	<para>In der Voreinstellung enth&auml;lt
	  <filename>/etc/ttys</filename> Eintr&auml;ge f&uuml;r die ersten
	  vier seriellen Schnittstellen: <devicename>ttyu0</devicename> bis
	  <devicename>ttyu3</devicename>.  Wenn Sie an eine von diesen einen
	  Terminal anschlie&szlig;en, brauchen Sie keinen weiteren Eintrag
	  hinzuzuf&uuml;gen.</para>

	<example id="ex-etc-ttys">
	  <title>Eintr&auml;ge in <filename>/etc/ttys</filename>
	    hinzuf&uuml;gen</title>

	  <para>Angenommen, wir wollen an ein System zwei Terminals
	    anschlie&szlig;en:  Einen Wyse-50 und einen alten 286 IBM PC,
	    der mit <application>Procomm</application> einen VT-100
	    Terminal emuliert.  Den Wyse-Terminal verbinden wir mit der
	    zweiten seriellen Schnittstelle und den 286 mit der sechsten
	    seriellen Schnittstelle (einem Anschluss auf einer
	    Multiportkarte).  Die entsprechenden Eintr&auml;ge in
	    <filename>/etc/ttys</filename> w&uuml;rden dann wie folgt
	    aussehen:</para>

	  <programlisting>ttyu1<co
	      id="co-ttys-line1col1">  "/usr/libexec/getty std.38400"<co
	      id="co-ttys-line1col2">  wy50<co
	      id="co-ttys-line1col3">  on<co
	      id="co-ttys-line1col4">  insecure<co
	      id="co-ttys-line1col5">
ttyu5   "/usr/libexec/getty std.19200"  vt100  on  insecure
	  </programlisting>

	  <calloutlist>
	    <callout arearefs="co-ttys-line1col1">
	      <para>Das erste Feld gibt normalerweise den Namen der
	        Ger&auml;tedatei aus <filename>/dev</filename> an.</para>
	    </callout>
	    <callout arearefs="co-ttys-line1col2">

	      <para>Im zweiten Feld wird das auszuf&uuml;hrende Kommando,
	        normal ist das &man.getty.8;, angegeben.
		<command>getty</command> initialisiert und &ouml;ffnet die
		Verbindung, setzt die Geschwindigkeit und fragt den
		Benutzernamen ab.  Danach f&uuml;hrt es &man.login.1;
		aus.</para>

	      <para><command>getty</command> akzeptiert einen optionalen
	        Parameter auf der Kommandozeile, den Verbindungstyp, der
		die Eigenschaften der Verbindung, wie die Geschwindigkeit
		und Parit&auml;t, festlegt.  Die Typen und die damit
		verbundenen Eigenschaften liest <command>getty</command>
		aus <filename>/etc/gettytab</filename>.</para>

	      <para><filename>/etc/gettytab</filename> enth&auml;lt viele
	        Eintr&auml;ge sowohl f&uuml;r neue wie auch alte
		Terminalverbindungen.  Die meisten Eintr&auml;ge, die mit
		<literal>std</literal> beginnen, sollten mit einem
		festverdrahteten Terminal funktionieren.  F&uuml;r jede
		Geschwindigkeit zwischen 110&nbsp;bps und 115200&nbsp;bps
		gibt es einen <literal>std</literal> Eintrag.  Nat&uuml;rlich
		k&ouml;nnen Sie auch eigene Eintr&auml;ge erstellen,
		Informationen dazu finden Sie in &man.gettytab.5;.</para>

	      <para>Wenn Sie den Verbindungstyp in
	        <filename>/etc/ttys</filename> eintragen, stellen Sie
		bitte sicher, dass die Kommunikationseinstellungen
		auch mit denen des Terminals &uuml;bereinstimmen.</para>

	      <para>In unserem Beispiel verwendet der Wyse-50 keine
	        Parit&auml;t und 38400&nbsp;bps, der 286 PC benutzt ebenfalls
		keine Parit&auml;t und arbeitet mit 19200&nbsp;bps.</para>

	    </callout>

	    <callout arearefs="co-ttys-line1col3">

	      <para>Das dritte Feld gibt den Terminaltyp an, der
	        normalerweise mit diesem Anschluss verbunden ist.
		F&uuml;r Einw&auml;hlverbindungen wird oft
		<literal>unknown</literal> oder <literal>dialup</literal>
		benutzt, da sich die Benutzer praktisch mit beliebigen
		Terminals oder Emulatoren anmelden k&ouml;nnen.  Bei
		festverdrahteten Terminals &auml;ndert sich der Typ nicht,
		so dass Sie in diesem Feld einen richtigen Typ aus der
		&man.termcap.5; Datenbank angeben k&ouml;nnen.</para>

	      <para>In unserem Beispiel benutzen wir f&uuml;r den Wyse-50
	        den entsprechenden Typ aus &man.termcap.5;, der 286 PC
		wird als VT-100, den er ja emuliert, angegeben.</para>

	    </callout>

	    <callout arearefs="co-ttys-line1col4">
	      <para>Das vierte Feld gibt an, ob der Anschluss
	        aktiviert werden soll.  Wenn Sie hier <literal>on</literal>
		angeben, startet <command>init</command> das Programm, das
		im zweiten Feld angegeben wurde (normal
		<command>getty</command>).  Wenn Sie <literal>off</literal>
		angeben, wird das Kommando aus dem zweiten Feld nicht
		ausgef&uuml;hrt und folglich k&ouml;nnen Sie sich dann an
		dem betreffenden Terminal nicht anmelden.</para>
	    </callout>

	    <callout arearefs="co-ttys-line1col5">
	      <para>Im letzten Feld geben Sie die Sicherheit des
	        Anschlusses an.  Wenn Sie hier <literal>secure</literal>
		angeben, darf sich <username>root</username> (oder jeder
		Account mit der UID <literal>0</literal>) &uuml;ber diese
		Verbindung anmelden.  Wenn Sie <literal>insecure</literal>
		angeben, d&uuml;rfen sich nur unprivilegierte Benutzer
		anmelden.  Diese k&ouml;nnen sp&auml;ter mit &man.su.1;
		oder einem &auml;hnlichen Mechanismus zu
		<username>root</username> wechseln.</para>

	      <para>Es wird dringend empfohlen, <literal>insecure</literal>
	        nur f&uuml;r Terminals hinter verschlossenen T&uuml;ren
		zu verwenden, da Sie mit <command>su</command> leicht zum
		Superuser werden k&ouml;nnen.</para>
	    </callout>
	  </calloutlist>
	</example>
      </sect3>

      <sect3 id="term-hup">
	<title><command>init</command> zwingen,
	  <filename>/etc/ttys</filename> erneut zu lesen</title>

	<para>Nachdem Sie die n&ouml;tigen &Auml;nderungen in
	  <filename>/etc/ttys</filename> vorgenommen haben, schicken Sie
	  <command>init</command> ein SIGHUP-Signal (hangup), um es zu
	  veranlassen, seine Konfigurationsdatei neu zu lesen:</para>

	<screen>&prompt.root; <userinput>kill -HUP 1</userinput></screen>

	<note>
	  <para>Da <command>init</command> immer der erste Prozess auf
	    einem System ist, besitzt es immer die PID
	    <literal>1</literal>.</para>
	</note>

	<para>Wenn alles richtig eingerichtet ist, alle Kabel angeschlossen
	  und die Terminals eingeschaltet sind, sollte f&uuml;r jeden
	  Terminal ein <command>getty</command> Prozess laufen und auf
	  jedem Terminal sollten Sie eine Anmeldeaufforderung sehen.</para>
      </sect3>
    </sect2>

    <sect2 id="term-debug">
      <title>Fehlersuche</title>

      <para>Selbst wenn Sie den Anweisungen akribisch gefolgt sind, kann es
	immer noch zu Fehlern beim Einrichten eines Terminals kommen.  Die
	folgende Aufz&auml;hlung von Symptomen beschreibt m&ouml;gliche
	L&ouml;sungen:</para>

      <sect3>
	<title>Es erscheint kein Anmeldeprompt</title>

	<para>Stellen Sie sicher, dass der Terminal verbunden und
	  eingeschaltet ist.  Wenn ein PC als Terminal fungiert,
	  &uuml;berpr&uuml;fen Sie, dass die Terminalemulation auf
	  den richtigen Schnittstellen l&auml;uft.</para>

	<para>Stellen Sie sicher, dass Sie das richtige Kabel
	  verwenden und dass das Kabel fest mit dem Terminal und
	  dem FreeBSD-Rechner verbunden ist.</para>

	<para>Stellen Sie sicher, dass die Einstellungen f&uuml;r
	  die Geschwindigkeit (bps) und Parit&auml;t auf dem FreeBSD
	  System und dem Terminal gleich sind.  Wenn Ihr Terminal einen
	  Bildschirm besitzt, &uuml;berpr&uuml;fen Sie die richtige
	  Einstellung von Helligkeit und Kontrast.  Wenn Ihr Terminal
	  druckt, stellen Sie die ausreichende Versorgung mit Papier
	  und Tinte sicher.</para>

	<para>&Uuml;berpr&uuml;fen Sie mit <command>ps</command>,
	  dass der <command>getty</command> Prozess f&uuml;r
	  den Terminal l&auml;uft:</para>

        <screen>&prompt.root; <userinput>ps -axww|grep getty</userinput></screen>

	<para>F&uuml;r jeden Terminal sollten Sie einen Eintrag sehen.
	  Aus dem folgenden Beispiel erkennen Sie, dass
	  <command>getty</command> auf der zweiten seriellen
	  Schnittstelle <devicename>tyyd1</devicename> l&auml;uft und den
	  Verbindungstyp <literal>std.38400</literal> aus
	  <filename>/etc/gettytab</filename> benutzt:</para>

	<screen>22189  d1  Is+    0:00.03 /usr/libexec/getty std.38400 ttyu1</screen>

	<para>Wenn <command>getty</command> nicht l&auml;uft,
	  &uuml;berpr&uuml;fen Sie, ob der Anschluss in
	  <filename>/etc/ttys</filename> aktiviert ist.  Haben Sie
	  <command>kill -HUP 1</command> abgesetzt, nachdem Sie
	  <filename>/etc/ttys</filename> ge&auml;ndert hatten?</para>

	<para>Wenn <command>getty</command> l&auml;uft, aber der
	  Terminal immer noch kein Anmeldeprompt ausgibt, oder Sie am
	  Anmeldeprompt nichts eingeben k&ouml;nnen, kann es sein,
	  dass Ihr Terminal oder Kabel keinen Hardware-Handshake
	  unterst&uuml;tzt.  &Auml;ndern Sie dann den Eintrag
	  <literal>std.38400</literal> in <filename>/etc/ttys</filename>
	  zu <literal>3wire.38400</literal>.  Nachdem Sie
	  <filename>/etc/ttys</filename> ge&auml;ndert haben, setzen
	  Sie das Kommando <command>kill -HUP 1</command> ab.  Der
	  Eintrag <literal>3wire</literal> besitzt &auml;hnliche
	  Eigenschaften wie der Eintrag <literal>std</literal>,
	  ignoriert aber den Hardware-Handshake.  Wenn Sie den Eintrag
	  <literal>3wire</literal> verwenden, m&uuml;ssen Sie
	  vielleicht die Geschwindigkeit verkleinern oder die
	  Software-Flusssteuerung aktivieren, um
	  Puffer&uuml;berl&auml;ufe zu vermeiden.</para>
      </sect3>

      <sect3>
	<title>Es erscheinen nur unverst&auml;ndliche Zeichen</title>


	<para>Stellen Sie sicher, dass die Einstellungen f&uuml;r
          die Geschwindigkeit (bps) und Parit&auml;t auf dem FreeBSD
	  System und dem Terminal gleich sind.  Kontrollieren Sie den
	  <command>getty</command> Prozess und stellen Sie sicher,
	  dass der richtige Verbindungstyp aus
	  <filename>/etc/gettytab</filename> benutzt wird.  Wenn das
	  nicht der Fall ist, editieren Sie
	  <filename>/etc/ttys</filename> und setzen das Kommando
	  <command>kill-HUP 1</command> ab.</para>
      </sect3>

      <sect3>
	<title>Zeichen erscheinen doppelt und eingegebene
	  Passw&ouml;rter erscheinen im Klartext</title>

	<para>Stellen Sie den Terminal oder die Terminalemulation von
	  <quote>half duplex</quote> oder <quote>local echo</quote> auf
	  <quote>full duplex.</quote> um.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="dialup">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Guy</firstname>
	  <surname>Helmer</surname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
      <authorgroup>
        <author>
	  <firstname>Sean</firstname>
	  <surname>Kelly</surname>
	  <contrib>Mit Anmerkungen von </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Einw&auml;hlverbindungen</title>

    <warning>
      <para>Mit &os;&nbsp;8.0 wurden die Ger&auml;tedateien f&uuml;r
	serielle Ports von
	<filename>/dev/ttyd<replaceable>N</replaceable></filename> in
	<filename>/dev/ttyu<replaceable>N</replaceable></filename>
	umbenannt.  Setzen Sie noch &os;&nbsp;7.X ein, m&uuml;ssen
	Sie die Befehle in den folgenden Abschnitten entsprechend
	anpassen.</para>
    </warning>

    <indexterm><primary>Einw&auml;hlverbindungen</primary></indexterm>

    <para>Das Einrichten von Einw&auml;hlverbindungen &auml;hnelt dem
      Anschlie&szlig;en von Terminals, nur dass Sie anstelle eines
      Terminals ein Modem verwenden.</para>

      <sect2>
	<title>Externe und interne Modems</title>

	<para>Externe Modems sind f&uuml;r Einw&auml;hlverbindungen besser
	  geeignet, da sie die Konfiguration in nicht fl&uuml;chtigem RAM
	  speichern k&ouml;nnen.  Zudem verf&uuml;gen Sie &uuml;ber
	  Leuchtanzeigen, die den Status wichtiger RS-232 Signale
	  anzeigen und unter Umst&auml;nden Besucher beeindrucken
	  k&ouml;nnen.</para>

	<para>Interne Modems verf&uuml;gen normalerweise nicht &uuml;ber
	  nicht fl&uuml;chtiges RAM und lassen sich meist nur &uuml;ber
	  DIP-Schalter konfigurieren.  Selbst wenn ein internes Modem
	  Leuchtanzeigen besitzt, sind diese meist schwer einzusehen, wenn
	  das Modem eingebaut ist.</para>

      <sect3>
	<title>Modems und Kabel</title>
	<indexterm><primary>Modem</primary></indexterm>

	<para>Mit einem externen Modem m&uuml;ssen Sie das richtige Kabel
	  benutzen:  Ein Standard RS-232C Kabel, bei dem die folgenden
	  Signale miteinander verbunden sind, sollte ausreichen:</para>

          <table frame="none" pgwide="1" id="serialcomms-signal-names">
            <title>Signalnamen</title>

            <tgroup cols="2">
              <thead>
                <row>
                  <entry align="left">Abk&uuml;rzung</entry>
                  <entry align="left">Bedeutung</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry><acronym>RD</acronym></entry>
                  <entry>Received Data</entry>
                </row>

                <row>
                  <entry><acronym>TD</acronym></entry>
                  <entry>Transmitted Data</entry>
                </row>

                <row>
                  <entry><acronym>DTR</acronym></entry>
                  <entry>Data Terminal Ready</entry>
                </row>

                <row>
                  <entry><acronym>DSR</acronym></entry>
                  <entry>Data Set Ready</entry>
                </row>

                <row>
                  <entry><acronym>DCD</acronym></entry>
                  <entry>Data Carrier Detect (dadurch erkennt RS-232
                    das Signal <emphasis>Received Line</emphasis>)</entry>
                </row>

                <row>
                  <entry><acronym>SG</acronym></entry>
                  <entry>Signal Ground</entry>
                </row>

                <row>
                  <entry><acronym>RTS</acronym></entry>
                  <entry>Request to Send</entry>
                </row>

                <row>
                  <entry><acronym>CTS</acronym></entry>
                  <entry>Clear to Send</entry>
                </row>
              </tbody>
            </tgroup>
          </table>

	<para>Ab Geschwindigkeiten von 2400&nbsp;bps ben&ouml;tigt FreeBSD die
	  Signale <acronym>RTS</acronym> und <acronym>CTS</acronym>
	  f&uuml;r die Flusssteuerung.  Das Signal
	  <acronym>CD</acronym> zeigt an, ob ein Tr&auml;ger vorliegt, das
	  hei&szlig;t ob die Verbindung aufgebaut ist oder beendet wurde.
	  <acronym>DTR</acronym> zeigt an, dass das Ger&auml;t
	  betriebsbereit ist.  Es gibt einige Kabel, bei denen nicht alle
	  n&ouml;tigen Signale verbunden sind.  Wenn Sie Probleme der Art
	  haben, dass zum Beispiel die Sitzung nicht beendet wird,
	  obwohl die Verbindung beendet wurde, kann das an einem solchen
	  Kabel liegen.</para>

	<para>Wie andere &unix; Betriebssysteme auch, benutzt FreeBSD
	  Hardwaresignale, um festzustellen, ob ein Anruf
	  beantwortet wurde, eine Verbindung beendet wurde, oder um die
	  Verbindung zu schlie&szlig;en und das Modem zur&uuml;ckzusetzen.
	  FreeBSD vermeidet es, dem Modem Kommandos zu senden, oder den
	  Statusreport des Modems abzufragen.  Falls Sie ein Benutzer
	  von PC-basierenden Bulletin Board Systemen sind, mag Sie das
	  verwundern.</para>
      </sect3>
      </sect2>

      <sect2>
	<title>Schnittstellenbausteine</title>

	<para>FreeBSD unterst&uuml;tzt EIA RS-232C (CCITT V.24) serielle
	  Schnittstellen, die auf den NS8250, NS16450, NS16550 oder NS16550A
	  Bausteinen basieren.  Die Bausteine der Serie 16550 verf&uuml;gen
	  &uuml;ber einen 16&nbsp;Byte gro&szlig;en Puffer, der als FIFO angelegt
	  ist.  Wegen Fehler in der FIFO-Logik kann der Puffer in einem 16550
	  Baustein allerdings nicht genutzt werden, das hei&szlig;t der
	  Baustein muss als 16450 betrieben werden.  Bei allen
	  Bausteinen ohne Puffer und dem 16550 Baustein muss jedes
	  Byte einzeln von dem Betriebssystem verarbeitet werden, was
	  Fehler bei hohen Geschwindigkeiten oder gro&szlig;er Systemlast
	  erzeugt.  Es sollten daher nach M&ouml;glichkeit serielle
	  Schnittstellen, die auf 16550A Bausteinen basieren, eingesetzt
	  werden.</para>
      </sect2>

    <sect2>
      <title>&Uuml;berblick</title>

      <indexterm><primary>getty</primary></indexterm>
      <para>Wie bei Terminals auch, startet <command>init</command> f&uuml;r
	jede serielle Schnittstelle, die eine Einw&auml;hlverbindung zur
	Verf&uuml;gung stellt, einen <command>getty</command> Prozess.
	Wenn das Modem beispielsweise an <filename>/dev/ttyu0</filename>
	angeschlossen ist, sollte in der Ausgabe von <command>ps
	  ax</command> eine Zeile wie die folgende erscheinen:</para>

      <screen> 4850 ??  I      0:00.09 /usr/libexec/getty V19200 ttyu0</screen>

      <para>Wenn sich ein Benutzer einw&auml;hlt und die Verbindung
        aufgebaut ist, zeigt das Modem dies durch das <acronym>CD</acronym>
	Signal (Carrier Detect) an.  Der Kernel merkt, dass ein Signal
	anliegt und vollendet das &Ouml;ffnen der Schnittstelle durch
	<command>getty</command>.  Dann sendet <command>getty</command> das
	Anmeldeprompt mit der ersten f&uuml;r die Verbindung vereinbarten
	Geschwindigkeit und wartet auf eine Antwort.  Wenn die Antwort
	unverst&auml;ndlich ist, weil zum Beispiel die Geschwindigkeit des
	Modems von <command>getty</command>s Geschwindigkeit abweicht,
	versucht <command>getty</command> die Geschwindigkeit solange
	anzupassen, bis es eine verst&auml;ndliche Antwort
	erh&auml;lt.</para>

      <indexterm>
        <primary><command>/usr/bin/login</command></primary>
      </indexterm>
      <para><command>getty</command> f&uuml;hrt, nachdem der Benutzer seinen
	Namen eingegeben hat, <filename>/usr/bin/login</filename> aus,
	welches das Passwort abfragt und danach die Shell des
	Benutzers startet.</para>
    </sect2>


    <sect2>
      <title>Konfigurationsdateien</title>

      <para>Drei Konfigurationsdateien in <filename>/etc</filename>
        steuern, ob eine Einwahl in Ihr FreeBSD-System m&ouml;glich ist.
	Die erste, <filename>/etc/gettytab</filename>, konfiguriert den
	<filename>/usr/libexec/getty</filename> D&aelig;mon.  In
	<filename>/etc/ttys</filename> wird festgelegt, auf welchen
	Schnittstellen <filename>/sbin/init</filename> einen
	<command>getty</command> Prozess startet.  Schlie&szlig;lich
	haben Sie in <filename>/etc/rc.d/serial</filename> die
	M&ouml;glichkeit, Schnittstellen zu initialisieren.</para>

      <para>Es gibt zwei Ansichten dar&uuml;ber, wie Modems f&uuml;r
        Einw&auml;hlverbindungen unter &unix; zu konfigurieren sind.  Zum
	einen kann die Geschwindigkeit zwischen dem Modem und dem Computer
	fest eingestellt werden.  Sie ist damit unabh&auml;ngig von der
	Geschwindigkeit, mit der sich der entfernte Benutzer einw&auml;hlt.
	Dies hat den Vorteil, dass der entfernte Benutzer das
	Anmeldeprompt sofort bekommt.  Der Nachteil bei diesem Verfahren
	ist, dass das System die tats&auml;chliche Geschwindigkeit
	der Verbindung nicht kennt.  Damit k&ouml;nnen bildschirmorientierte
	Programme wie <application>Emacs</application> ihren
	Bildschirmaufbau nicht an langsame Verbindungen anpassen,
	um die Antwortzeiten zu verbessern.</para>

      <para>Die andere M&ouml;glichkeit besteht darin, die Geschwindigkeit
        der RS-232 Schnittstelle des lokalen Modems an die Geschwindigkeit
	des entfernten Modems anzupassen.  Bei einer V.32bis (14400&nbsp;bps)
	Verbindung kann das lokale Modem die RS-232 Schnittstelle mit
	19200&nbsp;bps betreiben, w&auml;hrend bei einer Verbindung mit
	2400&nbsp;bps die RS-232 Schnittstelle mit 2400&nbsp;bps
	betrieben wird.  Da <command>getty</command> die
	Verbindungsgeschwindigkeit des Modems nicht kennt, startet es
	den Anmeldevorgang mit der Ausgabe
	von <prompt>login:</prompt> und wartet auf eine Antwort.  Wenn der
	Benutzer der Gegenstelle nun nur unverst&auml;ndliche Zeichen
	erh&auml;lt, muss er solange <keycap>Enter</keycap>
	dr&uuml;cken, bis das Anmeldeprompt erscheint.  Solange die
	Geschwindigkeiten nicht &uuml;bereinstimmen, sind die Antworten der
	Gegenstelle f&uuml;r <command>getty</command> ebenfalls
	unverst&auml;ndlich.  In diesem Fall wechselt
	<command>getty</command> zur n&auml;chsten Geschwindigkeit und gibt
	wieder <prompt>login:</prompt> aus.  In aller Regel erh&auml;lt der
	Benutzer der Gegenstelle nach ein bis zwei Tastendr&uuml;cken
	eine erkennbare Anmeldeaufforderung.  Diese Anmeldeprozedur sieht
	nicht so sauber wie die Methode mit einer festen Geschwindigkeit
	aus, bietet dem Benutzer einer langsamen Verbindung allerdings den
	Vorteil, dass sich bildschirmorientierte Programme an die
	Geschwindigkeit anpassen k&ouml;nnen.</para>

      <para>Im Folgenden wird die Konfiguration f&uuml;r beide Methoden
        besprochen, doch die Methode der angepassten Geschwindigkeit
	wird bei der Diskussion bevorzugt.</para>

      <sect3>
	<title><filename>/etc/gettytab</filename></title>

  <indexterm>
    <primary><filename>/etc/gettytab</filename></primary>
  </indexterm>
	<para>Mit <filename>/etc/gettytab</filename> wird &man.getty.8; im
	Stil von &man.termcap.5; konfiguriert.  Das Format dieser Datei und
	die Bedeutung der Eintr&auml;ge wird in &man.gettytab.5;
	beschrieben.</para>

	<sect4>
	  <title>Konfiguration f&uuml;r feste Geschwindigkeit</title>

	  <para>Wenn Sie die Modemgeschwindigkeit vorgeben, werden Sie in
	    <filename>/etc/gettytab</filename> nichts &auml;ndern
	    m&uuml;ssen.</para>
	</sect4>

	<sect4>
	  <title>Konfiguration f&uuml;r angepasste Geschwindigkeit</title>

	  <para>In <filename>/etc/gettytab</filename> m&uuml;ssen
	    Eintr&auml;ge f&uuml;r die Geschwindigkeiten, die Sie benutzen
	    wollen, sein.  Wenn Sie ein 2400&nbsp;bps Modem besitzen,
	    k&ouml;nnen Sie wahrscheinlich den schon vorhandenen
	    <literal>D2400</literal> Eintrag benutzen.</para>

	  <programlisting>#
# Fast dialup terminals, 2400/1200/300 rotary (can start either way)
#
D2400|d2400|Fast-Dial-2400:\
        :nx=D1200:tc=2400-baud:
3|D1200|Fast-Dial-1200:\
        :nx=D300:tc=1200-baud:
5|D300|Fast-Dial-300:\
        :nx=D2400:tc=300-baud:</programlisting>

	  <para>Wenn Sie ein Modem mit einer h&ouml;heren Geschwindigkeit
	    besitzen, m&uuml;ssen Sie wahrscheinlich in
	    <filename>/etc/gettytab</filename> weitere Eintr&auml;ge
	    erstellen.  Hier ist ein Beispiel, das Sie mit einem 14400&nbsp;bps
	    Modem benutzen k&ouml;nnen:</para>

	  <programlisting>#
# Additions for a V.32bis Modem
#
um|V300|High Speed Modem at 300,8-bit:\
        :nx=V19200:tc=std.300:
un|V1200|High Speed Modem at 1200,8-bit:\
        :nx=V300:tc=std.1200:
uo|V2400|High Speed Modem at 2400,8-bit:\
        :nx=V1200:tc=std.2400:
up|V9600|High Speed Modem at 9600,8-bit:\
        :nx=V2400:tc=std.9600:
uq|V19200|High Speed Modem at 19200,8-bit:\
        :nx=V9600:tc=std.19200:</programlisting>

	  <para>Die damit erzeugten Verbindungen verwenden 8&nbsp;Bit und keine
	    Parit&auml;t.</para>

	  <para>Im obigen Beispiel startet die Geschwindigkeit bei
	    19200&nbsp;bps (eine V.32bis Verbindung) und geht dann
	    &uuml;ber 9600&nbsp;bps (V.32), 400&nbsp;bps, 1200&nbsp;bps
	    und 300&nbsp;bps wieder zur&uuml;ck zu 19200&nbsp;bps.
	    Das Schl&uuml;sselwort <literal>nx=</literal>
	    (<foreignphrase>next table</foreignphrase>) sorgt f&uuml;r
	    das zyklische Durchlaufen der Geschwindigkeiten.  Jede Zeile
	    zieht zudem noch mit <literal>tc=</literal>
	    (<foreignphrase>table continuation</foreignphrase>)
	    die Vorgabewerte f&uuml;r die jeweilige Geschwindigkeit an.</para>

	  <para>Wenn Sie ein 28800&nbsp;bps Modem besitzen und/oder Kompression
	    mit einem 14400&nbsp;bps Modem benutzen wollen, brauchen Sie
	    h&ouml;here Geschwindigkeiten als 19200&nbsp;bps.  Das folgende
	    Beispiel startet mit 57600&nbsp;bps:</para>

	  <programlisting>#
# Additions for a V.32bis or V.34 Modem
# Starting at 57600 bps
#
vm|VH300|Very High Speed Modem at 300,8-bit:\
        :nx=VH57600:tc=std.300:
vn|VH1200|Very High Speed Modem at 1200,8-bit:\
        :nx=VH300:tc=std.1200:
vo|VH2400|Very High Speed Modem at 2400,8-bit:\
        :nx=VH1200:tc=std.2400:
vp|VH9600|Very High Speed Modem at 9600,8-bit:\
        :nx=VH2400:tc=std.9600:
vq|VH57600|Very High Speed Modem at 57600,8-bit:\
        :nx=VH9600:tc=std.57600:</programlisting>

	  <note>
	    <para>Wenn Sie eine langsame CPU oder ein stark ausgelastetes
	      System besitzen und sich kein 16550A in Ihrem System befindet,
	      erhalten Sie bei 57600&nbsp;bps vielleicht
	      <errorname>sio</errorname> Fehlermeldungen der Form <quote>silo
	      overflow</quote>.</para>
          </note>
	</sect4>
      </sect3>

      <sect3 id="dialup-ttys">
	<title><filename>/etc/ttys</filename></title>
	<indexterm>
	  <primary><filename>/etc/ttys</filename></primary>
	</indexterm>

	<para><filename>/etc/ttys</filename> wurde bereits in <xref
	    linkend="ex-etc-ttys"> besprochen.  Die Konfiguration f&uuml;r
	  Modems ist &auml;hnlich, allerdings braucht
	  <command>getty</command> ein anderes Argument und es muss
	  ein anderer Terminaltyp angegeben werden.  Der Eintrag f&uuml;r
	  beide Methoden (feste und angepasste Geschwindigkeit) hat die
	  folgende Form:</para>

	<programlisting>ttyu0   "/usr/libexec/getty <replaceable>xxx</replaceable>"   dialup on</programlisting>

	<para>Das erste Feld der obigen Zeile gibt die Ger&auml;tedatei
	  f&uuml;r diesen Eintrag an &ndash; <devicename>ttyu0</devicename>
	  bedeutet, dass <command>getty</command> mit
	  <filename>/dev/ttyu0</filename> arbeitet.  Das zweite Feld
	  <literal>"/usr/libexec/getty <replaceable>xxx</replaceable>"</literal>
	  gibt das Kommando an, das <command>init</command> f&uuml;r dieses
	  Ger&auml;t startet (<replaceable>xxx</replaceable> wird durch
	  einen passenden Eintrag aus <filename>/etc/gettytab</filename>
	  ersetzt).  Die Vorgabe f&uuml;r den Terminaltyp, hier
	  <literal>dialup</literal>, wird im dritten Feld angegeben.  Das
	  vierte Feld, <literal>on</literal>, zeigt
	  <command>init</command> an, dass die Schnittstelle aktiviert
	  ist.  Im f&uuml;nften Feld k&ouml;nnte noch
	  <literal>secure</literal> angegeben werden, um Anmeldungen von
	  <username>root</username> zu erlauben, doch sollte das wirklich
	  nur f&uuml;r physikalisch sichere Terminals, wie die
	  Systemkonsole, aktiviert werden.</para>

	<para>Die Vorgabe f&uuml;r den Terminaltyp,
	  <literal>dialup</literal> im obigen Beispiel, h&auml;ngt von lokalen
	  Gegebenheiten ab.  Traditionell wird <literal>dialup</literal>
	  f&uuml;r Einw&auml;hlverbindungen verwendet, so dass die
	  Benutzer in ihren Anmeldeskripten den Terminaltyp auf ihren
	  Terminal abstimmen k&ouml;nnen, wenn der Typ auf
	  <literal>dialup</literal> gesetzt ist.  Wenn Sie aber
	  beispielsweise nur VT102 Terminals oder Emulatoren einsetzen,
	  k&ouml;nnen Sie den Terminaltyp hier auch fest auf
	  <literal>vt102</literal> setzen.</para>

	<para>Nachdem Sie <filename>/etc/ttys</filename> ge&auml;ndert
	  haben, m&uuml;ssen Sie <command>init</command> ein
	  <acronym>HUP</acronym> Signal schicken, damit es die Datei wieder
	  einliest.  Sie k&ouml;nnen dazu das folgende Kommando
	  verwenden:</para>

	<screen>&prompt.root; <userinput>kill -HUP 1</userinput></screen>

	<para>Wenn Sie das System zum ersten Mal konfigurieren, sollten Sie
	  dieses Kommando erst ausf&uuml;hren, wenn Sie Ihr Modem richtig
	  konfiguriert und angeschlossen haben.</para>

	<sect4>
	  <title>Konfiguration f&uuml;r feste Geschwindigkeit</title>

	  <para>Das Argument von <command>getty</command> muss in
	    diesem Fall eine feste Geschwindigkeit vorgeben.  Der Eintrag
	    f&uuml;r ein Modem, das fest auf 19200&nbsp;bps eingestellt ist,
	    k&ouml;nnte wie folgt aussehen:</para>

	  <programlisting>ttyu0   "/usr/libexec/getty std.19200"   dialup on</programlisting>

	  <para>Wenn Ihr Modem auf eine andere Geschwindigkeit eingestellt
	    ist, setzen Sie anstelle von <literal>std.19200</literal> einen
	    passenden Eintrag der Form
	    <literal>std.<replaceable>speed</replaceable></literal> ein.
	    Stellen Sie sicher, dass dies auch ein g&uuml;ltiger
	    Verbindungstyp aus <filename>/etc/gettytab</filename>
	    ist.</para>
	</sect4>

	<sect4>
	  <title>Konfiguration f&uuml;r angepasste Geschwindigkeit</title>

	  <para>Das Argument von <command>getty</command> muss hier auf
	    einen der Eintr&auml;ge aus <filename>/etc/gettytab</filename>
	    zeigen, der zu einer Kette von Eintr&auml;gen geh&ouml;rt, die
	    die zu probierenden Geschwindigkeiten beschreiben.  Wenn Sie
	    dem obigen Beispiel gefolgt sind und zus&auml;tzliche
	    Eintr&auml;ge in <filename>/etc/gettytab</filename> erzeugt
	    haben, k&ouml;nnen Sie die folgende Zeile verwenden:</para>

	  <programlisting>ttyu0   "/usr/libexec/getty V19200"   dialup on</programlisting>
	</sect4>
      </sect3>

      <sect3>
	<title><filename>/etc/rc.d/serial</filename></title>
	<indexterm>
	  <primary>rc-Dateien</primary>
	  <secondary><filename>rc.serial</filename></secondary>
	</indexterm>

	<para>Modems, die h&ouml;here Geschwindigkeiten unterst&uuml;tzen,
	  zum Beispiel V.32, V.32bis und V.34 Modems, benutzen
	  Hardware-Flusssteuerung (<literal>RTS/CTS</literal>).  F&uuml;r
	  die entsprechenden Schnittstellen k&ouml;nnen Sie die
	  Flusssteuerung mit <command>stty</command> in
	  <filename>/etc/rc.d/serial</filename> einstellen.</para>

	<para>Um beispielsweise die Hardware-Flusssteuerung
	  f&uuml;r die Ger&auml;te zur Ein- und Auswahl der zweiten
	  seriellen Schnittstelle (<devicename>COM2</devicename>)
	  zu aktivieren, benutzen Sie die Dateien zur Initialisierung der
	  entsprechenden Ger&auml;te und f&uuml;gen die folgenden Zeilen in
	  <filename>/etc/rc.d/serial</filename> hinzu:</para>
	<programlisting># Serial port initial configuration
stty -f /dev/ttyu1.init crtscts
stty -f /dev/cuad1.init crtscts</programlisting>

      </sect3>
    </sect2>

    <sect2>
      <title>Modemkonfiguration</title>

      <para>Wenn Sie ein Modem besitzen, das seine Konfiguration in nicht
        fl&uuml;chtigem RAM speichert, werden Sie ein Terminalprogramm wie
	<application>Telix</application> unter &ms-dos; oder
	<command>tip</command> unter &os; ben&ouml;tigen, um die Parameter
	einzustellen.  Verbinden Sie sich mit derselben Geschwindigkeit, die
	<command>getty</command> zuerst benutzen w&uuml;rde, mit dem Modem und
	treffen Sie folgende Einstellungen:</para>

      <itemizedlist>
	<listitem>
	  <para><acronym>DCD</acronym> ist eingeschaltet, wenn das
	    Tr&auml;gersignal des entfernten Modems erkannt wird.</para>
	</listitem>

	<listitem>
	  <para>Im Betrieb liegt <acronym>DTR</acronym> an.  Bei einem Verlust
	    von DTR legt das Modem auf und setzt sich zur&uuml;ck.</para>
	</listitem>

	<listitem>
	  <para><acronym>CTS</acronym> Flusssteuerung ist f&uuml;r
	    ausgehende Daten aktiviert.</para>
	</listitem>

	<listitem>
	  <para><acronym>XON/XOFF</acronym> Flusssteuerung ist
	    ausgeschaltet.</para>
	</listitem>

	<listitem>
	  <para><acronym>RTS</acronym> Flusssteuerung ist f&uuml;r
	    eingehende Daten aktiviert.</para>
	</listitem>

	<listitem>
	  <para>Keine R&uuml;ckmeldungen ausgeben.</para>
	</listitem>

	<listitem>
	  <para>Die Echo-Funktion ist deaktiviert.</para>
	</listitem>
      </itemizedlist>

      <para>In der Dokumentation Ihres Modems finden Sie die n&ouml;tigen
        Befehle, die Sie absetzen m&uuml;ssen, und/oder n&ouml;tigen
        DIP-Schalterstellungen, um die obigen Einstellungen zu
	treffen.</para>

      <para>F&uuml;r ein externes 14400 &usrobotics; &sportster; gelten zum
        Beispiel die folgenden Befehle:</para>

      <programlisting>ATZ
AT&amp;C1&amp;D2&amp;H1&amp;I0&amp;R2&amp;W</programlisting>

      <para>Bei dieser Gelegenheit k&ouml;nnen Sie auch gleich andere
        Einstellungen, zum Beispiel ob Sie V42.bis und/oder MNP5
	Kompression benutzen wollen, an Ihrem Modem vornehmen.</para>

      <para>Bei einem externen 14400 &usrobotics; &sportster;
	m&uuml;ssen Sie auch noch einige DIP-Schalter einstellen.
	Die folgenden Einstellungen k&ouml;nnen Sie vielleicht
	als Beispiel f&uuml;r andere Modems verwenden:</para>

      <itemizedlist>
	<listitem>
	  <para>Schalter 1: OBEN &ndash; DTR normal</para>
	</listitem>

	<listitem>
	  <para>Schalter 2: N/A (R&uuml;ckmeldungen als Text/numerische
	    R&uuml;ckmeldungen)</para>
	</listitem>

	<listitem>
	  <para>Schalter 3: OBEN &ndash; Keine R&uuml;ckmeldungen
	    ausgeben</para>
	</listitem>

	<listitem>
	  <para>Schalter 4: UNTEN &ndash; Echo-Funktion aus</para>
	</listitem>

	<listitem>
	  <para>Schalter 5: OBEN &ndash; Rufannahme aktiviert</para>
	</listitem>

	<listitem>
	  <para>Schalter 6: OBEN &ndash; Carrier Detect normal</para>
	</listitem>

	<listitem>
	  <para>Schalter 7: OBEN &ndash; Einstellungen aus dem NVRAM laden</para>
	</listitem>

	<listitem>
	  <para>Schalter 8: N/A (Smart Mode/Dumb Mode)</para>
	</listitem>
      </itemizedlist>

      <para>F&uuml;r Einw&auml;hlverbindungen sollten die
        R&uuml;ckmeldungen deaktiviert sein, da sonst
	<command>getty</command> dem Modem das Anmeldeprompt
	<prompt>login:</prompt> schickt und das Modem im Kommandomodus das
	Prompt wieder ausgibt (Echo-Funktion) oder eine R&uuml;ckmeldung gibt.
	Das f&uuml;hrt dann zu einer l&auml;nglichen und fruchtlosen
	Kommunikation zwischen dem Modem und
	<command>getty</command>.</para>

      <sect3>
	<title>Konfiguration f&uuml;r feste Geschwindigkeit</title>

	<para>Die Geschwindigkeit zwischen Modem und Computer muss auf
	  einen festen Wert eingestellt werden.  Mit einem externen 14400
	  &usrobotics; &sportster; Modem setzen die folgenden Kommandos die
	  Geschwindigkeit auf den Wert der Datenendeinrichtung fest:</para>

	<programlisting>ATZ
AT&amp;B1&amp;W</programlisting>
      </sect3>

      <sect3>
	<title>Konfiguration f&uuml;r angepasste Geschwindigkeit</title>

	<para>In diesem Fall muss die Geschwindigkeit der seriellen
	  Schnittstelle des Modems der eingehenden Geschwindigkeit
	  angepasst werden.  F&uuml;r ein externes
	  14400 &usrobotics; &sportster;
	  Modem erlauben die folgenden Befehle eine Anpassung der
	  Geschwindigkeit der seriellen Schnittstelle f&uuml;r
	  Verbindungen, die keine Fehlerkorrektur verwenden:</para>

	<programlisting>ATZ
AT&amp;B2&amp;W</programlisting>

	<para>Verbindungen mit Fehlerkorrektur (V.42, MNP) verwenden die
	  Geschwindigkeit der Datenendeinrichtung.</para>
      </sect3>

      <sect3>
	<title>&Uuml;berpr&uuml;fen der Modemkonfiguration</title>

	<para>Die meisten Modems verf&uuml;gen &uuml;ber Kommandos, die die
	  Konfiguration des Modems in lesbarer Form ausgeben.  Auf einem
	  externen 14400 &usrobotics; &sportster; zeigt
	  <command>ATI5</command> die Einstellungen im nicht
	  fl&uuml;chtigen RAM an.  Um die wirklichen
	  Einstellungen unter Ber&uuml;cksichtigung der DIP-Schalter zu
	  sehen, benutzen Sie <command>ATZ</command> gefolgt von
	  <command>ATI4</command>.</para>

	<para>Wenn Sie ein anderes Modem benutzen, schauen Sie bitte in der
	  Dokumentation Ihres Modems nach, wie Sie die Konfiguration des
	  Modems &uuml;berpr&uuml;fen k&ouml;nnen.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Fehlersuche</title>

      <para>Bei Problemen k&ouml;nnen Sie die Einw&auml;hlverbindung anhand
        der folgenden Punkte &uuml;berpr&uuml;fen:</para>

      <sect3>
	<title>&Uuml;berpr&uuml;fen des FreeBSD-Systems</title>

	<para>Schlie&szlig;en Sie das Modem an das FreeBSD-System an und
	  booten Sie das System.  Wenn Ihr Modem &uuml;ber
	  Statusindikatoren verf&uuml;gt, &uuml;berpr&uuml;fen Sie, ob der
	  <acronym>DTR</acronym> Indikator leuchtet, wenn das Anmeldeprompt
	  erscheint.  Dies zeigt an, dass das FreeBSD-System einen
	  <command>getty</command> Prozess auf der entsprechenden
	  Schnittstelle gestartet hat und das Modem auf einkommende
	  Verbindungen wartet.</para>

	<para>Wenn der <acronym>DTR</acronym>-Indikator nicht leuchtet,
	  melden Sie sich an dem FreeBSD-System an und &uuml;berpr&uuml;fen mit
	  <command>ps ax</command>, ob FreeBSD einen
	  <command>getty</command>-Prozess auf der entsprechenden
	  Schnittstelle gestartet hat.  Unter den angezeigten Prozessen
	  sollten Sie &auml;hnliche wie die folgenden finden:</para>

	<screen>  114 ??  I      0:00.10 /usr/libexec/getty V19200 ttyu0
  115 ??  I      0:00.10 /usr/libexec/getty V19200 ttyu1</screen>

	<para>Wenn das Modem noch keinen Anruf entgegengenommen hat und Sie
	  stattdessen die folgende Zeile sehen</para>

	  <screen>  114 d0  I      0:00.10 /usr/libexec/getty V19200 ttyu0</screen>

	<para>bedeutet dies, dass <command>getty</command> die
	  Schnittstelle schon ge&ouml;ffnet hat und zeigt Kabelprobleme
	  oder eine falsche Modemkonfiguration an, da
	  <command>getty</command> die Schnittstelle erst dann &ouml;ffnen
	  kann, wenn das <acronym>CD</acronym> Signal (Carrier Detect) vom
	  Modem anliegt.</para>

	<para>Wenn Sie keine <command>getty</command>-Prozesse auf den
	  gew&uuml;nschten <devicename>ttyu<replaceable>N</replaceable></devicename>
	  Ports finden, untersuchen Sie bitte <filename>/etc/ttys</filename>
	  auf Fehler.  Suchen Sie auch in <filename>/var/log/messages</filename>
	  nach Meldungen von <command>init</command> oder
	  <command>getty</command>.  Wenn Sie dort Meldungen finden,
	  sollten Sie noch einmal die beiden Konfigurationsdateien
	  <filename>/etc/ttys</filename> und <filename>/etc/gettytab</filename>
	  nach Fehlern durchsehen.  &Uuml;berpr&uuml;fen Sie auch, ob die
	  Ger&auml;tedateien
	  <filename>/dev/ttyu<replaceable>N</replaceable></filename>
	  vorhanden sind.</para>
      </sect3>

      <sect3>
	<title>Einw&auml;hlversuch</title>

	<para>Versuchen Sie, sich in Ihr System einzuw&auml;hlen.  Auf dem
	  entfernten System stellen Sie bitte die folgenden
	  Kommunikationsparameter ein: 8&nbsp;Bit, keine Parit&auml;t, ein
	  Stop-Bit.  Wenn Sie kein Anmeldeprompt erhalten oder nur
	  unleserliche Zeichen sehen, dr&uuml;cken Sie mehrmals, in
	  Abst&auml;nden von ungef&auml;hr einer Sekunde,
	  <keycap>Enter</keycap>.  Wenn Sie immer noch nicht die
	  <prompt>login:</prompt> Meldung sehen, schicken Sie ein
	  <command>BREAK</command> Kommando.  Wenn Sie zur Einwahl ein
	  Highspeed-Modem benutzen, verwenden Sie eine feste
	  Geschwindigkeit auf der seriellen Schnittstelle des Modems
	  (<command>AT&amp;B1</command> f&uuml;r ein
	  &usrobotics; &sportster;).</para>

	<para>Wenn Sie jetzt immer noch kein Anmeldeprompt erhalten,
	  &uuml;berpr&uuml;fen Sie nochmals <filename>/etc/gettytab</filename>
	  und stellen sicher, dass</para>

	<itemizedlist>
	  <listitem>
	    <para>der Verbindungstyp in <filename>/etc/ttys</filename> zu
	      einem g&uuml;ltigen Eintrag in <filename>/etc/gettytab</filename>
	      geh&ouml;rt,</para>
	  </listitem>

	  <listitem>
	    <para>jeder der <literal>nx=</literal> Eintr&auml;ge in
	      <filename>gettytab</filename> g&uuml;ltig ist und</para>
	  </listitem>

	  <listitem>
	    <para>jeder <literal>tc=</literal> Eintrag auf einen
	      g&uuml;ltigen Eintrag in <filename>gettytab</filename>
	      verweist.</para>
	  </listitem>
	</itemizedlist>

	<para>Wenn das Modem an Ihrem FreeBSD-System auf einen eingehenden Anruf
	  nicht antwortet, stellen Sie sicher, dass das Modem so
	  konfiguriert ist, dass es einen Anruf beantwortet, wenn
	  <acronym>DTR</acronym> anliegt.  Wenn Ihr Modem Statusindikatoren
	  besitzt, k&ouml;nnen Sie das Anliegen von <acronym>DTR</acronym>
	  anhand der Leuchten &uuml;berpr&uuml;fen.</para>

	<para>Wenn Sie alles schon mehrfach &uuml;berpr&uuml;ft haben und
	  es immer noch noch nicht funktioniert, machen Sie erst einmal
	  eine Pause, bevor Sie weitermachen.  Wenn es immer noch nicht
	  funktioniert, k&ouml;nnen Sie eine Mail an die Mailingliste
	  &a.de.questions; schicken, in der Sie Ihr Modem und Ihr Problem
	  beschreiben und Ihnen sollte geholfen werden.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="dialout">
    <title>Verbindungen nach Au&szlig;en</title>

    <warning>
      <para>Mit &os;&nbsp;8.0 wurden die Ger&auml;tedateien f&uuml;r
	serielle Ports von
	<filename>/dev/ttyd<replaceable>N</replaceable></filename> in
	<filename>/dev/ttyu<replaceable>N</replaceable></filename>
	umbenannt.  Setzen Sie noch &os;&nbsp;7.X ein, m&uuml;ssen
	Sie die Befehle in den folgenden Abschnitten entsprechend
	anpassen.</para>
    </warning>

    <para>Die folgenden Ratschl&auml;ge beschreiben, wie Sie mit einem
      Modem eine Verbindung zu einem anderen Computer herstellen.  Dies
      k&ouml;nnen Sie nutzen, um sich auf einem entfernten Computer
      anzumelden, oder um eine Verbindung zu einem BBS (Bulletin Board
      System) herzustellen.</para>

    <para>Weiterhin ist diese Art von Verbindungen n&uuml;tzlich, wenn mal
      Ihr PPP nicht funktioniert.  Wenn Sie zum Beispiel eine Datei
      mit FTP &uuml;bertragen wollen und das &uuml;ber PPP gerade nicht
      m&ouml;glich ist, melden Sie sich auf dem entfernten Rechner an und
      f&uuml;hren dort die FTP-Sitzung durch.  Die Dateien k&ouml;nnen Sie
      danach mit zmodem auf den lokalen Rechner &uuml;bertragen.</para>

    <sect2 id="hayes-unsupported">
      <title>Mein Hayes Modem wird nicht unterst&uuml;tzt &ndash; was kann
        ich tun?</title>

      <para>Eigentlich ist die Onlinehilfe f&uuml;r <command>tip</command>
	nicht mehr aktuell.  Es gibt einen eingebauten, allgemeinen
        Hayes W&auml;hler.  Verwenden Sie einfach <literal>at=hayes</literal>
        in <filename>/etc/remote</filename>.</para>

      <para>Der Hayes-Treiber ist nicht schlau genug, um ein paar der
        erweiterten Funktionen von neueren Modems zu erkennen &ndash;
	Nachrichten wie <literal>BUSY</literal>,
	<literal>NO DIALTONE</literal> oder <literal>CONNECT 115200</literal>
	verwirren ihn nur.  Sie sollten diese Nachrichten mit Hilfe von
	<command>ATX0&amp;W</command> abschalten, wenn Sie
	<command>tip</command> benutzen.</para>

      <para>Der Anwahl-Timeout von <command>tip</command> betr&auml;gt 60
        Sekunden.  Ihr Modem sollte weniger verwenden, oder
	<command>tip</command> denkt, dass ein Kommunikationsfehler
	vorliegt.  Versuchen Sie es mit
	<command>ATS7=45&amp;W</command>.</para>
    </sect2>

    <sect2 id="direct-at">
      <title>Wie soll ich die AT-Befehle eingeben?</title>

      <indexterm>
        <primary><filename>/etc/remote</filename></primary>
      </indexterm>
      <para>Erstellen Sie einen so genannten <literal>direct</literal>
        Eintrag in <filename>/etc/remote</filename>.  Wenn Ihr Modem zum
	Beispiel an der ersten seriellen Schnittstelle,
	<devicename>/dev/cuad0</devicename>, angeschlossen ist, dann
	f&uuml;gen Sie die folgende Zeile hinzu:</para>

      <programlisting>cuad0:dv=/dev/cuad0:br#19200:pa=none</programlisting>

      <para>Verwenden Sie die h&ouml;chste bps-Rate, die Ihr Modem in der
        br F&auml;higkeit unterst&uuml;tzt.  Geben Sie dann <command>tip
	<devicename>cuad0</devicename></command> ein und Sie sind mit Ihrem
	Modem verbunden.</para>

      <para>Oder benutzen Sie <command>cu</command> als
        <username>root</username> mit dem folgenden Befehl:</para>

      <screen>&prompt.root; <userinput>cu -l<replaceable>line</replaceable> -s<replaceable>speed</replaceable></userinput></screen>

      <para><replaceable>line</replaceable> steht f&uuml;r die serielle
        Schnittstelle (<filename>/dev/cuad0</filename>) und
	<replaceable>speed</replaceable> f&uuml;r die Geschwindigkeit
	(<literal>57600</literal>).  Wenn Sie mit dem Eingeben der AT
	Befehle fertig sind, beenden Sie mit <command>~.</command>.</para>
    </sect2>

    <sect2 id="gt-failure">
      <title>Wieso funktioniert das <literal>@</literal> Zeichen f&uuml;r
        die pn F&auml;higkeit nicht?</title>

      <para>Das <literal>@</literal> Zeichen in der
        Telefonnummerf&auml;higkeit sagt <command>tip</command>, dass
	es in der Datei <filename>/etc/phones</filename> nach einer Nummer
	suchen soll.  Aber <literal>@</literal> ist auch ein spezielles
	Zeichen in den Dateien, in denen F&auml;higkeiten beschrieben
	werden, wie <filename>/etc/remote</filename>.  Schreiben Sie es mit
	einem Backslash:</para>

      <programlisting>pn=\@</programlisting>
    </sect2>

    <sect2 id="dial-command-line">
      <title>Wie kann ich von der Kommandozeile eine Telefonnummer
        w&auml;hlen?</title>

      <para>Stellen Sie einen allgemeinen Eintrag in
        <filename>/etc/remote</filename>.  Zum Beispiel:</para>

      <programlisting>tip115200|Dial any phone number at 115200 bps:\
        :dv=/dev/cuad0:br#115200:at=hayes:pa=none:du:
tip57600|Dial any phone number at 57600 bps:\
        :dv=/dev/cuad0:br#57600:at=hayes:pa=none:du:</programlisting>

      <para>Mit dem folgenden Befehl k&ouml;nnen Sie dann
        w&auml;hlen:</para>

      <screen>&prompt.root; <userinput>tip -115200 5551234</userinput></screen>

      <para>Sollten Sie <command>cu</command> gegen&uuml;ber
        <command>tip</command> bevorzugen, verwenden Sie einen allgemeinen
	cu-Eintrag:</para>

      <programlisting>cu115200|Use cu to dial any number at 115200bps:\
        :dv=/dev/cuad1:br#57600:at=hayes:pa=none:du:</programlisting>

      <para>und benutzen zum W&auml;hlen das Kommando:</para>

      <screen>&prompt.root; <userinput>cu 5551234 -s 115200</userinput></screen>
    </sect2>

    <sect2 id="set-bps">
      <title>Muss ich dabei jedes Mal die bps-Rate angeben?</title>

      <para>Schreiben Sie einen <literal>tip1200</literal>- oder einen
        <literal>cu1200</literal>-Eintrag, aber geben Sie auch die bps-Rate
	an, die Ihr Modem wirklich unterst&uuml;tzt.  Leider denkt
	&man.tip.1;, dass 1200&nbsp;bps ein guter Standardwert ist und
	deswegen sucht es nach einem <literal>tip1200</literal>-Eintrag.
	Nat&uuml;rlich m&uuml;ssen Sie nicht 1200&nbsp;bps
	benutzen.</para>
    </sect2>

    <sect2 id="terminal-server">
      <title>Wie kann ich m&ouml;glichst komfortabel &uuml;ber einen
        Terminal-Server auf verschiedene Rechner zugreifen?</title>

      <para>Sie m&uuml;ssen nicht warten bis Sie verbunden sind, und
        jedes Mal <command>CONNECT <replaceable>Rechner</replaceable></command>
	eingeben, benutzen Sie <command>tip</command>s
	<literal>cm</literal>-F&auml;higkeit. Sie k&ouml;nnen diese
	Eintr&auml;ge in <filename>/etc/remote</filename> verwenden:</para>

      <programlisting>pain|pain.deep13.com|Forrester's machine:\
        :cm=CONNECT pain\n:tc=deep13:
muffin|muffin.deep13.com|Frank's machine:\
        :cm=CONNECT muffin\n:tc=deep13:
deep13:Gizmonics Institute terminal server:\
        :dv=/dev/cuad2:br#38400:at=hayes:du:pa=none:pn=5551234:</programlisting>

      <para>Mit den Befehlen <command>tip pain</command> oder <command>tip
        muffin</command> k&ouml;nnen Sie eine Verbindungen zu den Rechnern
	<hostid>pain</hostid> oder <hostid>muffin</hostid> herstellen;  mit
	<command>tip deep13</command> verbinden Sie sich mit dem
	Terminalserver.</para>
    </sect2>

    <sect2 id="tip-multiline">
      <title>Kann <command>tip</command> mehr als eine Verbindung f&uuml;r
        jede Seite ausprobieren?</title>

      <para>Das ist oft ein Problem, wenn eine Universit&auml;t mehrere
        Telefonleitungen hat und viele tausend Studenten diese benutzen
	wollen.</para>

      <para>Erstellen Sie einen Eintrag f&uuml;r Ihre Universit&auml;t in
      <filename>/etc/remote</filename> und benutzen Sie
      <literal>@</literal> f&uuml;r die
        <literal>pn</literal>-F&auml;higkeit:</para>

      <programlisting>big-university:\
        :pn=\@:tc=dialout
dialout:\
        :dv=/dev/cuad3:br#9600:at=courier:du:pa=none:</programlisting>

      <para>Listen Sie die Telefonnummern der Universit&auml;t in
        <filename>/etc/phones</filename> auf:</para>

      <programlisting>big-university 5551111
big-university 5551112
big-university 5551113
big-university 5551114</programlisting>

      <para><command>tip</command> probiert jede der Nummern in der
        aufgelisteten Reihenfolge und gibt dann auf.  M&ouml;chten Sie,
        dass <command>tip</command> beim Versuchen eine Verbindung
        herzustellen nicht aufgibt, lassen Sie es in einer while-Schleife
        laufen.</para>
    </sect2>

    <sect2 id="multi-controlp">
      <title>Warum muss ich zweimal
        <keycombo action="simul">
          <keycap>Ctrl</keycap>
          <keycap>P</keycap>
        </keycombo>
        tippen, um ein
        <keycombo action="simul">
          <keycap>Ctrl</keycap>
          <keycap>P</keycap>
        </keycombo>
        zu senden?</title>

      <para><keycombo action="simul">
	  <keycap>Ctrl</keycap>
	  <keycap>P</keycap>
	</keycombo>
	ist das voreingestellte Zeichen, mit dem eine &Uuml;bertragung
	erzwungen werden kann und wird benutzt, um <command>tip</command>
	zu sagen, dass das n&auml;chste Zeichen direkt gesendet werden
	soll und nicht als Fluchtzeichen interpretiert werden soll.  Mit
	Hilfe der Fluchtsequenz <command>~s</command>, mit der man
	Variablen setzen kann, k&ouml;nnen Sie jedes andere Zeichen als
	<quote>force</quote>-Zeichen definieren.</para>

      <para>Geben Sie
	<command>~sforce=<replaceable>Zeichen</replaceable></command>
	gefolgt von <keycap>Enter</keycap> ein.  F&uuml;r
	<replaceable>Zeichen</replaceable> k&ouml;nnen Sie ein beliebiges
	einzelnes Zeichen einsetzen.  Wenn Sie
	<replaceable>Zeichen</replaceable> weglassen, ist das
	<quote>force</quote>-Zeichen <quote>nul</quote>, das Sie mit
	<keycombo action="simul">
	  <keycap>Ctrl</keycap><keycap>2</keycap>
	</keycombo>
	oder
	<keycombo action="simul">
	  <keycap>Ctrl</keycap><keycap>Leertaste</keycap>
	</keycombo> eingeben k&ouml;nnen.  Ein guter Wert f&uuml;r
	<replaceable>Zeichen</replaceable> ist
	<keycombo action="simul">
	  <keycap>Shift</keycap>
	  <keycap>Ctrl</keycap>
	  <keycap>6</keycap>
	</keycombo>, welches nur auf wenigen Terminal Servern benutzt
	wird.</para>

      <para>Sie k&ouml;nnen das <quote>force</quote>-Zeichen auch
        bestimmen, indem Sie in <filename>&dollar;HOME/.tiprc</filename> das
        Folgende einstellen:</para>

      <programlisting>force=<replaceable>single-char</replaceable></programlisting>
    </sect2>

    <sect2 id="uppercase">
      <title>Warum ist auf einmal alles was ich schreibe in
        GROSSBUCHSTABEN??</title>

      <para>Sie m&uuml;ssen
	<keycombo action="simul">
	  <keycap>Ctrl</keycap>
	  <keycap>A</keycap>
	</keycombo>, eingegeben haben, das <quote>raise</quote>-Zeichen von
	<command>tip</command>, das speziell f&uuml;r Leute mit defekten
	caps-lock Tasten eingerichtet wurde.  Benutzen Sie
	<command>~s</command> wie oben und setzen Sie die Variable
	<literal>raisechar</literal> auf etwas, das Ihnen angemessen
	erscheint.  Tats&auml;chlich kann die Variable auf das gleiche
	Zeichen wie das <quote>force</quote>-Zeichen gesetzt werden, wenn
	Sie diese F&auml;higkeiten niemals benutzen wollen.</para>

      <para>Hier ist ein Muster der <filename>.tiprc</filename> Datei,
        perfekt f&uuml;r <application>Emacs</application> Benutzer, die oft
	<keycombo action="simul">
	  <keycap>Ctrl</keycap><keycap>2</keycap>
	</keycombo>
	und
	<keycombo action="simul">
	  <keycap>Ctrl</keycap><keycap>A</keycap>
	</keycombo>
	tippen m&uuml;ssen:</para>

      <programlisting>force=^^
raisechar=^^</programlisting>

      <para>Geben Sie f&uuml;r <literal>^^</literal>
	<keycombo action="simul">
	  <keycap>Shift</keycap><keycap>Ctrl</keycap><keycap>6</keycap>
	</keycombo> ein.</para>

    </sect2>

    <sect2 id="tip-filetransfer">
      <title>Wie kann ich Dateien mit <command>tip</command>
        &uuml;bertragen?</title>

      <para>Wenn Sie mit einem anderen &unix; System kommunizieren,
        k&ouml;nnen Sie mit <command>~p</command> (put) und
	<command>~t</command> (take) Dateien senden und empfangen.  Diese
	Befehle lassen <command>cat</command> und <command>echo</command>
	auf dem entfernten System laufen, um Dateien zu empfangen und zu
	senden.  Die Syntax ist:</para>

      <cmdsynopsis>
	<command>~p</command>
	<arg choice="plain">local-file</arg>
	<arg choice="opt">remote-file</arg>
      </cmdsynopsis>

      <cmdsynopsis>
	<command>~t</command>
	<arg choice="plain">remote-file</arg>
	<arg choice="opt">local-file</arg>
      </cmdsynopsis>

      <para>Es gibt keine Fehlerkontrolle, deshalb sollten Sie besser ein
        anderes Protokoll, wie zmodem, benutzen.</para>
    </sect2>

    <sect2 id="zmodem-tip">
      <title>Wie kann ich zmodem mit <command>tip</command> laufen
        lassen?</title>

      <para>Um Dateien zu empfangen, starten Sie das Programm zum Senden
        auf dem entfernten Computer.  Geben Sie dann
	<command>~C rz</command> ein, um die Dateien lokal zu empfangen.</para>

      <para>Um Dateien zu senden, starten Sie das Programm zum Empfangen
        auf dem entfernten Computer.  Geben Sie dann
	<command>~C sz <replaceable>Dateien</replaceable></command> ein,
	um Dateien auf das entfernte System zu senden.</para>
    </sect2>
  </sect1>

  <sect1 id="serialconsole-setup">
    <sect1info>
      <authorgroup>
        <author>
	  <firstname>Kazutaka</firstname>
	  <surname>YOKOTA</surname>
	  <contrib>Beigesteuert von </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <firstname>Bill</firstname>
	  <surname>Paul</surname>
	  <contrib>Auf Grundlage eines Dokuments von </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <title>Einrichten der seriellen Konsole</title>

    <warning>
      <para>Mit &os;&nbsp;8.0 wurden die Ger&auml;tedateien f&uuml;r
	serielle Ports von
	<filename>/dev/ttyd<replaceable>N</replaceable></filename> in
	<filename>/dev/ttyu<replaceable>N</replaceable></filename>
	umbenannt.  Setzen Sie noch &os;&nbsp;7.X ein, m&uuml;ssen
	Sie die Befehle in den folgenden Abschnitten entsprechend
	anpassen.</para>
    </warning>

    <indexterm><primary>serielle Konsole</primary></indexterm>

    <sect2 id="serialconsole-intro">
      <title>Einf&uuml;hrung</title>

      <para>FreeBSD kann ein System mit einem Dumb-Terminal (unintelligente
	Datenstation) an einer seriellen Schnittstelle als Konsole booten.
	Diese Konfiguration ist besonders n&uuml;tzlich f&uuml;r
	Systemadministratoren, die FreeBSD auf Systemen ohne Tastatur oder
	Monitor installieren wollen, und Entwickler, die den Kernel oder
	Ger&auml;tetreiber debuggen.</para>

      <para>Wie in <xref linkend="boot"> beschrieben, besitzt FreeBSD drei
        Bootphasen.  Der Code f&uuml;r die ersten beiden Bootphasen befindet
	sich im Bootsektor am
	Anfang der FreeBSD-Slice der Bootplatte.  Dieser Bootblock
	l&auml;dt den Bootloader (<filename>/boot/loader</filename>) in
	Phase drei.</para>

      <para>Um eine serielle Konsole einzurichten, m&uuml;ssen Sie den
        Bootblock, den Bootloader und den Kernel konfigurieren.</para>
    </sect2>

    <sect2 id="serialconsole-howto-fast">
      <title>Serielle Konsole einrichten, Kurzfassung</title>

      <para>Dieser Abschnitt fasst zusammen, wie Sie eine
	serielle Konsole einrichten.  Es wird vorausgesetzt, dass
	Sie die Voreinstellungen verwenden und wissen, wie
	serielle Schnittstellen verbunden werden.</para>

      <procedure>
	<step>
	  <para>Verbinden Sie die serielle Konsole mit
	    <devicename>COM1</devicename> sowie dem Kontrollterminal.</para>
	</step>

	<step>
	  <para>Um die Startmeldungen der seriellen Konsole zu sehen,
	    geben Sie als <username>root</username> Folgendes ein:</para>

	<screen>&prompt.root; echo 'console="comconsole"' &gt;&gt; /boot/loader.conf</screen>

	</step>

	<step>
	  <para>&Auml;ndern Sie in <filename>/etc/ttys</filename>
	    den Eintrag f&uuml;r <devicename>ttyu0</devicename> von
	    <literal>off</literal> auf <literal>on</literal>.
	    Zus&auml;tzlich sollten Sie den Wert
	    <literal>dialup</literal> auf <literal>vt100</literal>
	    &auml;ndern.  Nur so wird auf der seriellen Konsole
	    eine Eingabeaufforderung mit einer Passwortabfrage
	    aktiviert.</para>
	</step>

	<step>
	  <para>Starten Sie nun das System neu, damit die serielle
	    Konsole aktiviert wird.</para>
	</step>
      </procedure>

      <para>Wenn Sie eine unterschiedliche Konfiguration ben&ouml;tigen,
        sollten Sie <xref linkend="serialconsole-howto"> lesen.</para>
    </sect2>

    <sect2 id="serialconsole-howto">
      <title>Konfiguration der Konsole</title>

      <procedure>
	<step>
	  <para>Bereiten Sie ein serielles Kabel vor.</para>

	  <indexterm><primary>Nullmodemkabel</primary></indexterm>
	  <para>Sie ben&ouml;tigen entweder ein Nullmodemkabel oder ein
	    serielles Standard Kabel mit einem Nullmodemkabel-Adapter.  In
	    <xref linkend="serial-cables-ports"> wurden serielle Kabel
	    beschrieben.</para>
	</step>

	<step>
	  <para>Trennen Sie die Tastatur vom Computer.</para>

	  <para>Die meisten PC Systeme suchen beim Power On Self Test
	    (POST) nach einer Tastatur und geben eine Fehlermeldung aus,
	    wenn sie keine finden.  Einige Maschinen werden sich sogar
	    weigern, ohne Tastatur zu booten.</para>

	  <para>Wenn Ihr Rechner trotz einer Fehlermeldung normal
	    weiterbootet, brauchen Sie weiter nichts zu tun.
	    Beispielsweise geben einige Maschinen mit einem Phoenix BIOS
	    nur <errorname>Keyboard failed</errorname> aus und booten dann
	    normal weiter.</para>

	  <para>Wenn Ihr System ohne Tastatur nicht booten will,
	    m&uuml;ssen Sie das BIOS so konfigurieren, das es diesen Fehler
	    ignoriert (wenn das m&ouml;glich ist).  Das Handbuch zu Ihrem
	    Motherboard sollte beschreiben, wie das zu bewerkstelligen
	    ist.</para>

	  <tip>
	    <para>Selbst wenn Sie im BIOS <quote>Not installed</quote>
	      f&uuml;r die Tastatur einstellen, k&ouml;nnen Sie eine
	      Tastatur angeschlossen haben und diese auch weiterhin
	      benutzen, da sie mit dieser Anweisung das BIOS
	      lediglich anweisen, nach dem Einschalten des Rechners nicht
	      nach einer Tastatur zu suchen und den Rechner ohne
	      entsprechende Fehlermeldung zu starten.  Wenn die oben
	      beschriebene Option nicht im BIOS vorhanden ist, halten Sie
	      stattdessen Ausschau nach einer <quote>Halt on Error</quote>
	      Option.  Sie k&ouml;nnen den gleichen Effekt wie oben erzielen,
	      wenn Sie diese Option auf <quote>All but Keyboard</quote> oder
	      sogar <quote>No Errors</quote> setzen.</para>
	  </tip>

	  <note>
	    <para>Wenn Ihr System &uuml;ber eine &ps2; Maus verf&uuml;gt,
	      m&uuml;ssen Sie diese wahrscheinlich auch abziehen.  Da sich
	      die &ps2; Maus und die Tastatur einige Hardwarekomponenten
	      teilen, kann das dazu f&uuml;hren, dass die
	      Hardwareerkennung f&auml;lschlicherweise eine Tastatur findet,
	      wenn eine &ps2; Maus angeschlossen ist.  Gateway 2000
	      Pentium 90&nbsp;MHz Systemen wird dieses Verhalten nachgesagt.
	      Normalerweise ist das kein Problem, da eine Maus ohne
	      Tastatur sowieso nicht sinnvoll einsetzbar ist.</para>
	  </note>
	</step>

	<step>
	  <para>Schlie&szlig;en Sie einen Dumb-Terminal an
	    <devicename>COM1</devicename> (<devicename>sio0</devicename>)
	    an.</para>

	  <para>Wenn Sie keinen Dumb-Terminal besitzen, k&ouml;nnen Sie
	    einen alten PC/XT mit einem Terminalemulator oder die serielle
	    Schnittstelle eines anderen &unix; Rechners benutzen.  Sie
	    ben&ouml;tigen auf jeden Fall eine freie erste serielle
	    Schnittstelle (<devicename>COM1</devicename>).  Zurzeit ist es
	    nicht m&ouml;glich, in den Bootbl&ouml;cken eine andere
	    Schnittstelle zu konfigurieren, ohne diese neu zu kompilieren.
	    Wenn Sie <devicename>COM1</devicename> bereits f&uuml;r ein
	    anderes Ger&auml;t benutzen, m&uuml;ssen Sie dieses Ger&auml;t
	    tempor&auml;r entfernen und einen neuen Bootblock sowie Kernel
	    installieren, wenn Ihr FreeBSD erst einmal installiert ist.
	    Auf einem Server sollte <devicename>COM1</devicename> ohnehin
	    verf&uuml;gbar sein.  Wenn Sie die Schnittstelle f&uuml;r ein
	    anderes Ger&auml;t benutzen und Sie dieses nicht auf
	    <devicename>COM2</devicename> (<devicename>sio1</devicename>)
	    legen k&ouml;nnen, sollten Sie sich nicht an erster Stelle mit
	    dem Aufsetzen einer seriellen Konsole besch&auml;ftigen.</para>
	</step>

	<step>
	  <para>Stellen Sie sicher, dass Ihre Kernelkonfiguration die
	    richtigen Optionen f&uuml;r <devicename>COM1</devicename>
	    (<devicename>sio0</devicename>) enth&auml;lt.</para>

	  <para>Relevante Optionen sind:</para>

	  <variablelist>
	    <varlistentry>
	      <term><literal>0x10</literal></term>

	      <listitem>
		<para>Aktiviert die Konsolenunterst&uuml;tzung f&uuml;r
		  dieses Ger&auml;t.  Zurzeit kann nur ein Ger&auml;t die
		  Konsolenunterst&uuml;tzung aktiviert haben.  Das erste,
		  in der Konfigurationsdatei aufgef&uuml;hrte Ger&auml;t,
		  mit dieser Option, verf&uuml;gt &uuml;ber eine aktivierte
		  Konsolenunterst&uuml;tzung.  Beachten Sie, dass
		  diese Option alleine nicht ausreicht, um die serielle
		  Konsole zu aktivieren.  Setzen Sie entweder noch die
		  nachfolgend diskutierte Option oder verwenden Sie beim
		  Booten, wie unten beschrieben, den Schalter
		  <option>-h</option>.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><literal>0x20</literal></term>

	      <listitem>
		<para>Das erste Ger&auml;t in der Kernelkonfigurationsdatei
		  mit dieser Option wird, unabh&auml;ngig von dem unten
		  diskutierten Schalter <option>-h</option>, zur Konsole.
		  Die Option <option>0x20</option> muss zusammen mit
		  <option>0x10</option> verwendet werden.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><literal>0x40</literal></term>

	      <listitem>
		<para>Reserviert dieses Ger&auml;t und sperrt es f&uuml;r
		  normale Zugriffe.  Sie sollten diese Option nicht auf dem
		  Ger&auml;t setzen, das Sie als serielle Konsole verwenden
		  wollen.  Der Zweck dieser Option ist es, dieses
		  Ger&auml;t f&uuml;r das Remote-Debuggen zu reservieren.
		  Das <ulink
		    url="&url.books.developers-handbook.en;/index.html">
		    FreeBSD Developers' Handbook</ulink> enth&auml;lt dazu weitere
		  Informationen.</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>

	  <para>Beispiel:</para>

	  <programlisting>device sio0 at isa? port IO_COM1 tty flags 0x10 irq 4</programlisting>

	  <para>Weitere Einzelheiten entnehmen Sie bitte
	    &man.sio.4;.</para>

	  <para>Wenn diese Optionen nicht gesetzt sind, m&uuml;ssen Sie auf
	    einer anderen Konsole beim Booten UserConfig starten oder den
	    Kernel neu kompilieren.</para>
	</step>

	<step>
	  <para>Erstellen Sie <filename>boot.config</filename> im
	    Rootverzeichnis der <literal>a</literal>-Partition des
	    Bootlaufwerks.</para>

	  <para>Der Code des Bootblocks entnimmt dieser Datei, wie Sie Ihr
	    System booten m&ouml;chten.  Um die serielle Konsole zu
	    aktivieren, m&uuml;ssen Sie hier eine oder mehrere Optionen
	    (alle in derselben Zeile) angeben.  Die folgenden Optionen
	    stehen zur Auswahl der Konsole zur Verf&uuml;gung:</para>

	  <variablelist>
	    <varlistentry>
	      <term><option>-h</option></term>

	      <listitem>
		<para>Schaltet zwischen der internen und der seriellen
		  Konsole um.  Wenn Sie beispielsweise von der internen
		  Konsole (Bildschirm) booten, weist <option>-h</option>
		  den Bootloader und den Kernel an, die serielle
		  Schnittstelle als Konsole zu nehmen.  Wenn die Konsole
		  normal auf der seriellen Schnittstelle liegt, w&auml;hlen
		  Sie mit <option>-h</option> den Bildschirm aus.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><option>-D</option></term>

	      <listitem>
		<para>Schaltet zwischen Einzelkonsole und Dual-Konsole um.
		  Die Einzelkonsole ist entweder die interne Konsole
		  (der Bildschirm) oder die serielle Schnittstelle, je nach
		  dem Stand von <option>-h</option>.  Im
		  Dual-Konsolen Betrieb ist die Konsole, unabh&auml;ngig
		  von <option>-h</option>, gleichzeitig der Bildschirm und
		  die serielle Schnittstelle.  Dies trifft aber nur zu,
		  wenn der Bootblock ausgef&uuml;hrt wird.  Sobald der
		  Bootloader ausgef&uuml;hrt wird, wird die durch
		  <option>-h</option> gegebene Konsole die alleinige
		  Konsole.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><option>-P</option></term>

	      <listitem>
		<para>Veranlasst den Bootblock nach einer Tastatur zu
		  suchen.  Wenn keine Tastatur gefunden wird, werden
		  <option>-D</option> und <option>-h</option> automatisch
		  gesetzt.</para>

		<note>
		  <para>Wegen Platzbeschr&auml;nkungen in den
		    Bootbl&ouml;cken kann <option>-P</option> nur
		    erweiterte Tastaturen erkennen.  Tastaturen mit weniger
		    als 101 Tasten (und ohne F11 und F12 Tasten) werden
		    wahrscheinlich, wie vielleicht auch die Tastaturen
		    einiger Laptops, nicht erkannt.  Wenn dies bei Ihrem
		    System der Fall ist, k&ouml;nnen Sie <option>-P</option>
		    nicht verwenden, da es leider noch keine Umgehung
		    f&uuml;r dieses Problem gibt.</para>
		</note>
	      </listitem>
	    </varlistentry>
	  </variablelist>

	  <para>Benutzen Sie also entweder <option>-P</option>, um die
	    Konsole automatisch zu setzen, oder <option>-h</option>, um die
	    serielle Konsole zu verwenden.</para>

	  <para>In <filename>boot.config</filename> k&ouml;nnen Sie auch
	    andere, in &man.boot.8; beschriebene Optionen,
	    aufnehmen.</para>

	  <para>Mit Ausnahme von <option>-P</option> werden die Optionen an
	    den Bootloader (<filename>/boot/loader</filename>)
	    weitergegeben.  Der Bootloader untersucht dann einzig
	    <option>-h</option> um festzustellen, welches Ger&auml;t die
	    Konsole wird.  Wenn Sie also nur <option>-D</option> angegeben
	    haben, k&ouml;nnen Sie die serielle Schnittstelle nur als
	    Konsole verwenden w&auml;hrend der Bootblock ausgef&uuml;hrt
	    wird.  Danach wird der Bootloader, da ja <option>-h</option>
	    fehlt, den Bildschirm zur Konsole machen.</para>
	</step>

	<step>
	  <para>Booten Sie die Maschine.</para>

	  <para>Wenn Sie das FreeBSD-System starten, werden die
	    Bootbl&ouml;cke den Inhalt von <filename>/boot.config</filename>
	    auf der Konsole ausgeben:</para>

	  <screen>/boot.config: -P
Keyboard: no</screen>

	  <para>Die zweite Zeile sehen Sie nur, wenn Sie in
	    <filename>/boot.config</filename> <option>-P</option> angegeben
	    haben.  Sie zeigt an, ob eine Tastatur angeschlossen ist oder
	    nicht.  Die Meldungen gehen je nach den Einstellungen in
	    <filename>/boot.config</filename> auf die interne Konsole, die
	    serielle Konsole, oder beide Konsolen.</para>

	  <informaltable frame="none" pgwide="1">
	    <tgroup cols="2">
	      <thead>
		<row>
		  <entry align="left">Optionen</entry>
		  <entry align="left">Meldungen erscheinen auf</entry>
		</row>
	      </thead>

	      <tbody>
		<row>
		  <entry>keine</entry>
		  <entry>der internen Konsole</entry>
		</row>

		<row>
		  <entry><option>-h</option></entry>
		  <entry>der seriellen Konsole</entry>
		</row>

		<row>
		  <entry><option>-D</option></entry>
		  <entry>der seriellen und der internen Konsole</entry>
		</row>

		<row>
		  <entry><option>-Dh</option></entry>
		  <entry>der seriellen und der internen Konsole</entry>
		</row>

		<row>
		  <entry><option>-P</option>, mit Tastatur</entry>
		  <entry>der internen Konsole</entry>
		</row>

		<row>
		  <entry><option>-P</option>, ohne Tastatur</entry>
		  <entry>der seriellen Konsole</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </informaltable>

	  <para>Nach den oben gezeigten Meldungen gibt es eine kleine
	    Verz&ouml;gerung bevor die Bootbl&ouml;cke den Bootloader
	    laden und weitere Meldungen auf der Konsole erscheinen.  Sie
	    k&ouml;nnen die Ausf&uuml;hrung der Bootbl&ouml;cke
	    unterbrechen, um zu &uuml;berpr&uuml;fen, ob auch alles richtig
	    aufgesetzt ist, brauchen das aber unter normalen Umst&auml;nden
	    nicht zu tun.</para>

	  <para>Dr&uuml;cken Sie eine Taste au&szlig;er
	    <keycap>Enter</keycap> um den Bootvorgang zu unterbrechen.  Sie
	    erhalten dann ein Prompt, an dem Sie weitere Eingaben
	    t&auml;tigen k&ouml;nnen:</para>

	  <screen>&gt;&gt; FreeBSD/i386 BOOT
Default: 0:ad(0,a)/boot/loader
boot:</screen>

	  <para>Je nach Inhalt von <filename>/boot.config</filename>
	    erscheint das Prompt auf der seriellen Konsole, der internen
	    Konsole oder beiden Konsolen.  Wenn die Meldung auf der
	    richtigen Konsole erscheint, dr&uuml;cken Sie
	    <keycap>Enter</keycap> um fortzufahren.</para>

	  <para>Wenn Sie das Prompt auf der seriellen Konsole erwartet
	    haben, dort aber nichts sehen, liegt ein Fehler in Ihren
	    Einstellungen vor.  Als Umgehung geben Sie an der momentanen
	    Konsole <option>-h</option> ein, um den Bootblock und den
	    Bootloader auf die serielle Konsole umzustellen.  F&uuml;hren
	    Sie dann den Bootvorgang mit <keycap>Enter</keycap> weiter
	    und wenn das System gebootet hat, k&ouml;nnen Sie die
	    fehlerhaften Einstellungen korrigieren.</para>
	</step>
      </procedure>

      <para>Nachdem der Bootloader geladen wurde und Sie sich in der
        dritten Bootphase befinden, k&ouml;nnen Sie immer noch zwischen der
	internen und der seriellen Konsole ausw&auml;hlen.  Setzen Sie dazu,
	wie in <xref linkend="serialconsole-loader"> beschrieben, die
	entsprechenden Variablen des Bootloaders.</para>
    </sect2>

  <sect2 id="serialconsole-summary">
    <title>Zusammenfassung</title>

      <para>Die folgende &Uuml;bersicht zeigt, welche Konsole, abh&auml;ngig
	von den getroffenen Einstellungen, ausgew&auml;hlt wird.</para>

      <sect3>
	<title>Fall 1: Option 0x10 f&uuml;r
	  <devicename>sio0</devicename></title>

	<programlisting>device sio0 at isa? port IO_COM1 tty flags 0x10 irq 4</programlisting>

	<informaltable frame="none" pgwide="1">
	  <tgroup cols="4">
	    <thead>
	      <row>
		<entry align="left">Optionen in <filename>/boot.config</filename></entry>
		<entry align="left">Konsole in den Bootbl&ouml;cken</entry>
		<entry align="left">Konsole im Bootloader</entry>
		<entry align="left">Konsole im Kernel</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry>keine</entry>
		<entry>interne</entry>
		<entry>interne</entry>
		<entry>interne</entry>
	      </row>

	      <row>
		<entry><option>-h</option></entry>
		<entry>serielle</entry>
		<entry>serielle</entry>
		<entry>serielle</entry>
	      </row>

	      <row>
		<entry><option>-D</option></entry>
		<entry>serielle und interne</entry>
		<entry>interne</entry>
		<entry>interne</entry>
	      </row>

	      <row>
		<entry><option>-Dh</option></entry>
		<entry>serielle und interne</entry>
		<entry>serielle</entry>
		<entry>serielle</entry>
	      </row>

	      <row>
		<entry><option>-P</option>, mit Tastatur</entry>
		<entry>interne</entry>
		<entry>interne</entry>
		<entry>interne</entry>
	      </row>

	      <row>
		<entry><option>-P</option>, ohne Tastatur</entry>
		<entry>serielle und interne</entry>
		<entry>serielle</entry>
		<entry>serielle</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </sect3>

      <sect3>
	<title>Fall 2: Option 0x30 f&uuml;r
	  <devicename>sio0</devicename></title>

	<programlisting>device sio0 at isa? port IO_COM1 tty flags 0x30 irq 4</programlisting>

	<informaltable frame="none" pgwide="1">
	  <tgroup cols="4">
	    <thead>
	      <row>
		<entry align="left">Optionen in <filename>/boot.config</filename></entry>
		<entry align="left">Konsole in den Bootbl&ouml;cken</entry>
		<entry align="left">Konsole im Bootloader</entry>
		<entry align="left">Konsole im Kernel</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry>keine</entry>
		<entry>interne</entry>
		<entry>interne</entry>
		<entry>serielle</entry>
	      </row>

	      <row>
		<entry><option>-h</option></entry>
		<entry>serielle</entry>
		<entry>serielle</entry>
		<entry>serielle</entry>
	      </row>

	      <row>
		<entry><option>-D</option></entry>
		<entry>serielle und interne</entry>
		<entry>interne</entry>
		<entry>serielle</entry>
	      </row>

	      <row>
		<entry><option>-Dh</option></entry>
		<entry>serielle und interne</entry>
		<entry>serielle</entry>
		<entry>serielle</entry>
	      </row>

	      <row>
		<entry><option>-P</option>, mit Tastatur</entry>
		<entry>interne</entry>
		<entry>interne</entry>
		<entry>serielle</entry>
	      </row>

	      <row>
		<entry><option>-P</option>, ohne Tastatur</entry>
		<entry>serielle und interne</entry>
		<entry>serielle</entry>
		<entry>serielle</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </sect3>
    </sect2>

    <sect2 id="serialconsole-tips">
      <title>Hinweise zur seriellen Konsole</title>

      <sect3>
	<title>Verwenden einer h&ouml;heren Geschwindigkeit</title>

	<para>Die Vorgabewerte f&uuml;r die Kommunikationsparameter der
	  seriellen Schnittstelle sind: 9600&nbsp;baud, 8&nbsp;Bit, keine
	  Parit&auml;t und ein Stopp-Bit.  Wenn Sie die
	  Standardgeschwindigkeit &auml;ndern wollen, haben Sie folgende
	  M&ouml;glichkeiten:</para>

	<itemizedlist>
	  <listitem>
	    <para>Geben Sie die neue Konsolengeschwindigkeit mit
	      <makevar>BOOT_COMCONSOLE_SPEED</makevar> an und
	      kompilieren Sie die Bootbl&ouml;cke neu.  Ausf&uuml;hrliche
	      Informationen zum Bau und zur Installation von neuen
	      Bootbl&ouml;cken finden Sie im
	      <xref linkend="serialconsole-com2"> des Handbuchs.</para>

	    <para>Wenn die serielle Konsole nicht mit der Option
	      <option>-h</option> gestartet wird,
	      oder wenn die verwendete serielle Konsole sich von
	      der von den Bootbl&ouml;cken verwendeten unterscheidet,
	      m&uuml;sssen Sie zus&auml;tzlich die folgende Option in
	      Ihre Kernelkonfigurationsdatei aufnehmen und den Kernel
	      neu bauen:</para>

	    <programlisting>options CONSPEED=19200</programlisting>
	  </listitem>

	  <listitem>
	    <para>Verwenden Sie die Option <option>-S</option>, um den
	      Kernel zu booten.  Die Option <option>-S</option> kann
	      auch in die Datei <filename>/boot.config</filename>
	      aufgenommen werden.  Eine Beschreibung dieses Vorgangs
	      sowie eine Auflistung der von
	      <filename>/boot.config</filename> unterst&uuml;tzten
	      Optionen finden Sie in der Manualpage &man.boot.8;.</para>
	  </listitem>

	  <listitem>
	    <para>Aktivieren Sie die Option
	      <varname>comconsole_speed</varname> in der Datei
	      <filename>/boot/loader.conf</filename>.</para>

	    <para>Diese Option setzt voraus, dass auch die Optionen
	      <varname>console</varname>,
	      <varname>boot_serial</varname>, sowie
	      <varname>boot_multicons</varname> in der Datei
	      <filename>/boot/loader.conf</filename> gesetzt sind.
	      Im Folgenden finden Sie ein Beispiel, in dem
	      <varname>comconsole_speed</varname> verwendet wird,
	      um die Geschwindigkeit der seriellen Konsole zu
	      &auml;ndern:</para>

	    <programlisting>boot_multicons="YES"
boot_serial="YES"
comconsole_speed="115200"
console="comconsole,vidconsole"</programlisting>
	  </listitem>
	</itemizedlist>
      </sect3>

      <sect3 id="serialconsole-com2">
	<title>Eine andere Schnittstelle als <devicename>sio0</devicename>
	  benutzen</title>

	<para>Wenn Sie, warum auch immer, ein anderes Ger&auml;t als
	  <devicename>sio0</devicename> f&uuml;r die serielle Konsole
	  einsetzen wollen, kompilieren Sie bitte die Bootbl&ouml;cke, den
	  Bootloader und den Kernel nach dem folgenden Verfahren
	  neu.</para>

	<procedure>
	  <step>
	    <para>Installieren Sie die Kernelquellen (siehe
	      <xref linkend="updating-upgrading">).</para>
	  </step>

	  <step>
	    <para>Setzen Sie in <filename>/etc/make.conf</filename>
	      <literal>BOOT_COMCONSOLE_PORT</literal> auf die Adresse der
	      Schnittstelle (0x3F8, 0x2F8, 0x3E8 oder 0x2E8), die Sie
	      benutzen m&ouml;chten.  Sie k&ouml;nnen nur
	      <devicename>sio0</devicename> bis
	      <devicename>sio3</devicename> (<devicename>COM1</devicename>
	      bis <devicename>COM4</devicename>) benutzen, Multiportkarten
	      k&ouml;nnen Sie nicht als Konsole benutzen.  Interrupts
	      m&uuml;ssen Sie hier nicht angeben.</para>
	  </step>

	  <step>
	    <para>Erstellen Sie eine angepasste Kernelkonfiguration
	      und geben Sie dort die richtigen Optionen f&uuml;r die
	      Schnittstelle, die Sie benutzen m&ouml;chten, an.  Wenn Sie
	      zum Beispiel <devicename>sio1</devicename>
	      (<devicename>COM2</devicename>) zur Konsole machen wollen,
	      geben Sie dort entweder</para>

	    <programlisting>device sio1 at isa? port IO_COM2 tty flags 0x10 irq 3</programlisting>

	    <para>oder</para>

	    <programlisting>device sio1 at isa? port IO_COM2 tty flags 0x30 irq 3</programlisting>

	    <para>an.  Keine andere serielle Schnittstelle sollte als
	      Konsole definiert werden.</para>
	  </step>

	  <step>
	    <para>&Uuml;bersetzen und installieren Sie die
	      Bootbl&ouml;cke und den Bootloader:</para>

	    <screen>&prompt.root; <userinput>cd /sys/boot</userinput>
&prompt.root; <userinput>make clean</userinput>
&prompt.root; <userinput>make</userinput>
&prompt.root; <userinput>make install</userinput></screen>
	  </step>

	  <step>
	    <para>Bauen und installieren Sie einen neuen Kernel.</para>
	  </step>

	  <step>
	    <para>Schreiben Sie die Bootbl&ouml;cke mit &man.bsdlabel.8;
	      auf die Bootplatte und booten Sie den neuen Kernel.</para>
	  </step>
	</procedure>
      </sect3>

      <sect3 id="serialconsole-ddb">
	<title>DDB Debugger &uuml;ber die serielle Schnittstelle</title>

	<para>Wenn Sie den Kerneldebugger &uuml;ber eine serielle
	  Verbindung bedienen m&ouml;chten (n&uuml;tzlich, kann aber
	  gef&auml;hrlich sein, wenn auf der Leitung falsche BREAK-Signale
	  generiert werden), sollten Sie einen Kernel mit
	  den folgenden Optionen erstellen:</para>

	<programlisting>options BREAK_TO_DEBUGGER
options DDB</programlisting>
      </sect3>

      <sect3>
	<title>Benutzung der seriellen Konsole zum Anmelden</title>

	<para>Da Sie schon die Bootmeldungen auf der Konsole verfolgen
	  k&ouml;nnen und den Kerneldebugger &uuml;ber die Konsole bedienen
	  k&ouml;nnen, wollen Sie sich vielleicht auch an der Konsole
	  anmelden.</para>

	<para>&Ouml;ffnen Sie <filename>/etc/ttys</filename> in einem
	  Editor und suchen Sie nach den folgenden Zeilen:</para>

      <programlisting>ttyu0 "/usr/libexec/getty std.9600" unknown off secure
ttyu1 "/usr/libexec/getty std.9600" unknown off secure
ttyu2 "/usr/libexec/getty std.9600" unknown off secure
ttyu3 "/usr/libexec/getty std.9600" unknown off secure</programlisting>

	<para><devicename>ttyu0</devicename> bis <devicename>ttyu3</devicename>
	  entsprechen <devicename>COM1</devicename> bis
	  <devicename>COM4</devicename>.  &Auml;ndern Sie f&uuml;r die
	  entsprechende Schnittstelle <literal>off</literal> zu
	  <literal>on</literal>.  Wenn Sie auch die Geschwindigkeit der
	  seriellen Schnittstelle ge&auml;ndert haben, m&uuml;ssen Sie
	  <literal>std.9600</literal> auf die momentane Geschwindigkeit, zum
	  Beispiel <literal>std.19200</literal>, anpassen.</para>

	<para>Sie sollten auch den Terminaltyp von
	  <literal>unknown</literal> auf den tats&auml;chlich verwendeten
	  Terminal setzen.</para>

	<para>Damit die &Auml;nderungen an der Datei wirksam werden,
	  m&uuml;ssen Sie noch <command>kill -HUP 1</command>
	  absetzen.</para>
      </sect3>
    </sect2>

    <sect2 id="serialconsole-loader">
      <title>Die Konsole im Bootloader &auml;ndern</title>

      <para>In den vorigen Abschnitten wurde beschrieben, wie Sie die
        serielle Konsole durch &Auml;nderungen im Bootblock aktivieren.
	Dieser Abschnitt zeigt Ihnen, wie Sie mit Kommandos und
	Umgebungsvariablen die Konsole im Bootloader definieren.  Da der
	Bootloader die dritte Phase im Bootvorgang ist und nach den
	Bootbl&ouml;cken ausgef&uuml;hrt wird, &uuml;berschreiben
	seine Einstellungen die des Bootblocks.</para>

      <sect3>
	<title>Festlegen der Konsole</title>

	<para>Mit einer einzigen Zeile in
	  <filename>/boot/loader.conf</filename> k&ouml;nnen Sie den
	  Bootloader und den Kernel anweisen, die serielle Schnittstelle
	  zur Konsole zu machen:</para>

	<programlisting>set console="comconsole"</programlisting>

	<para>Unabh&auml;ngig von den Einstellungen im Bootblock legt dies
	  die Konsole fest.</para>

	<para>Die obige Zeile sollte die erste Zeile in
	  <filename>/boot/loader.conf</filename> sein, so dass Sie die
	  Bootmeldungen so fr&uuml;h wie m&ouml;glich auf der Konsole
	  sehen.</para>

	<para>Analog k&ouml;nnen Sie die interne Konsole verwenden:</para>

	<programlisting>set console="vidconsole"</programlisting>

	<para>Wenn Sie <envar>console</envar> nicht setzen, bestimmt der
	  Bootloader (und damit auch der Kernel) die Konsole &uuml;ber
	  die <option>-h</option> Option des Bootblocks.</para>

	<para>Sie k&ouml;nnen die Bootkonsole in
	  <filename>/boot/loader.conf.local</filename> oder
	  <filename>/boot/loader.conf</filename> angeben.</para>

	<para>Weitere Informationen erhalten Sie in &man.loader.conf.5;.</para>

	<note>
	  <para>Momentan gibt es im Bootloader nichts vergleichbares zu
	    <option>-P</option> im Bootblock.  Damit kann die Konsole nicht
	    automatisch &uuml;ber das Vorhandensein einer Tastatur
	    festgelegt werden.</para>
	</note>
      </sect3>

      <sect3>
	<title>Eine andere Schnittstelle als <devicename>sio0</devicename>
	  benutzen</title>

	<para>Sie m&uuml;ssen den Bootloader neu kompilieren, wenn Sie eine
	  andere Schnittstelle als <devicename>sio0</devicename> benutzen
	  wollen.  Folgen Sie der Anleitung aus
	  <xref linkend="serialconsole-com2">.</para>
      </sect3>
    </sect2>

    <sect2 id="serialconsole-caveats">
      <title>Vorbehalte</title>

      <para>Hinter dem ganzen steckt die Idee, Server ohne Hardware
        f&uuml;r Grafik und ohne Tastatur zu betreiben.  Obwohl es die
	meisten Systeme erlauben, ohne Tastatur zu booten, gibt es leider
	nur wenige Systeme, die ohne eine Grafikkarte booten.  Maschinen
	mit einem AMI BIOS k&ouml;nnen ohne Grafik booten, indem Sie den
	Grafikadapter im CMOS-Setup auf <literal>Not installed</literal>
	setzen.</para>

      <para>Viele Maschinen unterst&uuml;tzen diese Option allerdings nicht.
        Damit diese Maschinen booten, m&uuml;ssen sie &uuml;ber eine
	Grafikkarte, auch wenn es nur eine alte Monochromkarte ist,
	verf&uuml;gen.  Allerdings brauchen Sie keinen Monitor an die Karte
	anzuschlie&szlig;en.  Sie k&ouml;nnen nat&uuml;rlich auch
	versuchen, auf diesen Maschinen ein AMI BIOS zu
	installieren.</para>
    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->

