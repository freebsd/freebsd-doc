<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde: de-docproj/books/handbook/serialcomms/chapter.xml,v 1.89 2012/04/30 16:20:14 bcr Exp $
     basiert auf: r51494
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="serialcomms">
  <info><title>Serielle Datenübertragung</title>
    <authorgroup>
      <author><personname><firstname>Martin</firstname><surname>Heinen</surname></personname><contrib>Übersetzt von </contrib></author>
    </authorgroup>
  </info>

  <sect1 xml:id="serial-synopsis">
    <title>Übersicht</title>

    <indexterm><primary>serielle Datenübertragung</primary></indexterm>

    <para>&unix; Systeme unterstützten schon immer die serielle
      Datenübertragung.  Tatsächlich wurden Ein- und Ausgaben auf
      den ersten &unix; Maschinen über serielle Leitungen
      durchgeführt.  Seit der Zeit, in der ein durchschnittlicher
      Terminal aus einem seriellen Drucker mit
      10&nbsp;Zeichen/Sekunde und einer Tastatur bestand, hat sich viel
      verändert.  Dieses Kapitel behandelt einige Möglichkeiten,
      serielle Datenübertragung unter &os; zu verwenden.</para>

    <para>Nachdem Sie dieses Kapitel gelesen haben, werden
      Sie Folgendes wissen:</para>

    <itemizedlist>
      <listitem>
	<para>Wie Sie Terminals an ein &os;-System
	  anschließen.</para>
      </listitem>

      <listitem>
	<para>Wie Sie sich mit einem Modem auf entfernte
	  Rechner einwählen.</para>
      </listitem>

      <listitem>
	<para>Wie Sie entfernten Benutzern erlauben, sich mit einem
	  Modem in ein &os;-System einzuwählen.</para>
      </listitem>

      <listitem>
	<para>Wie Sie ein &os;-System über eine serielle Konsole
	  booten.</para>
      </listitem>
    </itemizedlist>

    <para>Bevor Sie dieses Kapitel lesen, sollten Sie</para>

    <itemizedlist>
      <listitem>
	<para>einen <link linkend="kernelconfig">angepassten Kernel
	    konfigurieren und installieren</link> können.</para>
      </listitem>

      <listitem>
	<para><link linkend="basics">Berechtigungen und Prozesse unter
	    &os;</link> verstehen.</para>
      </listitem>

      <listitem>
	<para>Zugriff auf die Handbücher der seriellen Komponenten
	  haben, die mit &os; verwendet werden sollen.</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 xml:id="serial">
    <title>Begriffe und Hardware</title>

    <para>Die folgenden Begriffe werden oft verwendet, wenn es um
      serielle Kommunikation geht:</para>

      <variablelist>
	<varlistentry>
	  <term><acronym>bps</acronym></term>
	  <listitem>
	    <para>Bits pro Sekunde
	      <indexterm><primary>bits-per-second</primary></indexterm>
	      (<acronym>bps</acronym>) ist die
	      Einheit für die Übertragungsgeschwindigkeit.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><acronym>DEE</acronym> (<acronym>DTE</acronym>)</term>

	  <listitem>
	    <para>Eine Datenendeinrichtung
	      <indexterm><primary>DTE</primary></indexterm>(Data
	      Terminal Equipment) ist einer der beiden Endpunkte bei
	      der seriellen Kommunikation. Zum Beispiel ein
	      Computer.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><acronym>DÜE</acronym> (<acronym>DCE</acronym>)</term>

	  <listitem>
	    <para>Datenübertragungseinrichtung
	      <indexterm><primary>DCE</primary></indexterm> (Data
	      Communications Equipment) ist der andere Endpunkt bei
	      der seriellen Kommunikation.  Typischerweise ein
	      Modem.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>RS-232</term>

	  <listitem>
	    <para>Der originale Standard, der serielle
	      Datenübertragung definiert.  Er wird
	      heutzutage als <acronym>TIA</acronym>-232
	      <indexterm><primary>RS-232C Kabel</primary></indexterm>
	      bezeichnet.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>In diesem Abschnitt wird der Begriff <quote>Baud</quote> nicht
        für Übertragungsgeschwindigkeiten gebraucht.  Baud
	bezeichnet elektrische Zustandswechsel pro Zeiteinheit, die Taktfrequenz,
	während <quote>bps</quote> der <emphasis>richtige</emphasis>
	Begriff für die Übertragungsgeschwindigkeit ist.</para>

      <para>Um ein Modem oder einen Terminal an ein &os;-System
	anzuschließen, muss der Computer über eine serielle
	Schnittstelle verfügen.  Zusätzlich wird das passende Kabel
	benötigt, um das Gerät mit der Schnittstelle zu
	verbinden.  Benutzer, die mit seriellen Geräten und den
	nötigen Kabeln schon vertraut sind, können diesen Abschnitt
	überspringen.</para>

      <sect2 xml:id="term-cables-null">
	<title>Kabel und Schnittstellen</title>

	<para>Es gibt verschiedene serielle Kabel.  Die zwei häufigsten
	  sind Nullmodemkabel und Standard-RS-232-Kabel.  Die
	  Dokumentation der Hardware sollte beschreiben, welcher
	  Kabeltyp benötigt wird.</para>

	  <indexterm>
	    <primary>Nullmodemkabel</primary>
	  </indexterm>
	  <para>Ein Nullmodemkabel verbindet einige Signale, wie die
	    Betriebserde, eins zu eins, andere Signale werden getauscht:
	    Die Sende- und Empfangsleitungen werden zum Beispiel
	    gekreuzt.</para>

	  <para>Nullmodemkabel für die Anbindung eines Terminals
	    können auch selbst hergestellt werden.  Die folgende
	    Tabelle enthält die <link
	      linkend="serialcomms-signal-names">Signalnamen</link>
	    von RS-232C sowie die Pinbelegung für einen Stecker vom
	    Typ DB-25.  Obwohl der Standard eine direkte Verbindung
	    von Pin 1 zu Pin 1
	    (<emphasis>Protective Ground</emphasis>) vorschreibt, ist
	    diese in vielen Fällen nicht vorhanden.  Einige
	    Terminals benötigen nur die Pins 2, 3 und 7 für
	    eine korrekte Funktion, während andere eine
	    unterschiedliche Konfiguration als die in den folgenden
	    Beispielen gezeigte benötigen.</para>

	  <table frame="none" pgwide="1">
	    <title>Nullmodemkabel vom Typ DB-25-zu-DB-25</title>

	    <tgroup cols="5">
	      <thead>
		<row>
		  <entry align="left">Signal</entry>
		  <entry align="left">Pin #</entry>
		  <entry align="left"/>
		  <entry align="left">Pin #</entry>
		  <entry align="left">Signal</entry>
		</row>
	      </thead>

	      <tbody>
		<row>
		  <entry>SG</entry>
		  <entry>7</entry>
		  <entry>verbunden mit</entry>
		  <entry>7</entry>
		  <entry>SG</entry>
		</row>

		<row>
		  <entry>TD</entry>
		  <entry>2</entry>
		  <entry>verbunden mit</entry>
		  <entry>3</entry>
		  <entry>RD</entry>
		</row>

		<row>
		  <entry>RD</entry>
		  <entry>3</entry>
		  <entry>verbunden mit</entry>
		  <entry>2</entry>
		  <entry>TD</entry>
		</row>

		<row>
		  <entry>RTS</entry>
		  <entry>4</entry>
		  <entry>verbunden mit</entry>
		  <entry>5</entry>
		  <entry>CTS</entry>
		</row>

		<row>
		  <entry>CTS</entry>
		  <entry>5</entry>
		  <entry>verbunden mit</entry>
		  <entry>4</entry>
		  <entry>RTS</entry>
		</row>

		<row>
		  <entry>DTR</entry>
		  <entry>20</entry>
		  <entry>verbunden mit</entry>
		  <entry>6</entry>
		  <entry>DSR</entry>
		</row>

		<row>
		  <entry>DTR</entry>
		  <entry>20</entry>
		  <entry>verbunden mit</entry>
		  <entry>8</entry>
		  <entry>DCD</entry>
		</row>

		<row>
		  <entry>DSR</entry>
		  <entry>6</entry>
		  <entry>verbunden mit</entry>
		  <entry>20</entry>
		  <entry>DTR</entry>
		</row>

		<row>
		  <entry>DCD</entry>
		  <entry>8</entry>
		  <entry>verbunden mit</entry>
		  <entry>20</entry>
		  <entry>DTR</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>

	  <para>Die folgenden zwei Schemata werden heutzutage ebenfalls
	    häufig eingesetzt:</para>

          <table frame="none" pgwide="1">
            <title>Nullmodemkabel vom Typ DB-9-zu-DB-9</title>

            <tgroup cols="5">
              <thead>
                <row>
                  <entry align="left">Signal</entry>
                  <entry align="left">Pin #</entry>
                  <entry align="left"/>
                  <entry align="left">Pin #</entry>
                  <entry align="left">Signal</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>RD</entry>
                  <entry>2</entry>
                  <entry>verbunden mit</entry>
                  <entry>3</entry>
                  <entry>TD</entry>
                </row>

                <row>
                  <entry>TD</entry>
                  <entry>3</entry>
                  <entry>verbunden mit</entry>
                  <entry>2</entry>
                  <entry>RD</entry>
                </row>

                <row>
                  <entry>DTR</entry>
                  <entry>4</entry>
                  <entry>verbunden mit</entry>
                  <entry>6</entry>
                  <entry>DSR</entry>
                </row>

                <row>
                  <entry>DTR</entry>
                  <entry>4</entry>
                  <entry>verbunden mit</entry>
                  <entry>1</entry>
                  <entry>DCD</entry>
                </row>

                <row>
                  <entry>SG</entry>
                  <entry>5</entry>
                  <entry>verbunden mit</entry>
                  <entry>5</entry>
                  <entry>SG</entry>
                </row>

                <row>
                  <entry>DSR</entry>
                  <entry>6</entry>
                  <entry>verbunden mit</entry>
                  <entry>4</entry>
                  <entry>DTR</entry>
                </row>

                <row>
                  <entry>DCD</entry>
                  <entry>1</entry>
                  <entry>verbunden mit</entry>
                  <entry>4</entry>
                  <entry>DTR</entry>
                </row>

                <row>
                  <entry>RTS</entry>
                  <entry>7</entry>
                  <entry>verbunden mit</entry>
                  <entry>8</entry>
                  <entry>CTS</entry>
                </row>

                <row>
                  <entry>CTS</entry>
                  <entry>8</entry>
                  <entry>verbunden mit</entry>
                  <entry>7</entry>
                  <entry>RTS</entry>
                </row>
              </tbody>
            </tgroup>
          </table>

          <table frame="none" pgwide="1">
            <title>Nullmodemkabel vom Typ DB-9-zu-DB-25</title>

            <tgroup cols="5">
              <thead>
                <row>
                  <entry align="left">Signal</entry>
                  <entry align="left">Pin #</entry>
                  <entry align="left"/>
                  <entry align="left">Pin #</entry>
                  <entry align="left">Signal</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>RD</entry>
                  <entry>2</entry>
                  <entry>verbunden mit</entry>
                  <entry>2</entry>
                  <entry>TD</entry>
                </row>

                <row>
                  <entry>TD</entry>
                  <entry>3</entry>
                  <entry>verbunden mit</entry>
                  <entry>3</entry>
                  <entry>RD</entry>
                </row>

                <row>
                  <entry>DTR</entry>
                  <entry>4</entry>
                  <entry>verbunden mit</entry>
                  <entry>6</entry>
                  <entry>DSR</entry>
                </row>

                <row>
                  <entry>DTR</entry>
                  <entry>4</entry>
                  <entry>verbunden mit</entry>
                  <entry>8</entry>
                  <entry>DCD</entry>
                </row>

                <row>
                  <entry>SG</entry>
                  <entry>5</entry>
                  <entry>verbunden mit</entry>
                  <entry>7</entry>
                  <entry>SG</entry>
                </row>

                <row>
                  <entry>DSR</entry>
                  <entry>6</entry>
                  <entry>verbunden mit</entry>
                  <entry>20</entry>
                  <entry>DTR</entry>
                </row>

                <row>
                  <entry>DCD</entry>
                  <entry>1</entry>
                  <entry>verbunden mit</entry>
                  <entry>20</entry>
                  <entry>DTR</entry>
                </row>

                <row>
                  <entry>RTS</entry>
                  <entry>7</entry>
                  <entry>verbunden mit</entry>
                  <entry>5</entry>
                  <entry>CTS</entry>
                </row>

                <row>
                  <entry>CTS</entry>
                  <entry>8</entry>
                  <entry>verbunden mit</entry>
                  <entry>4</entry>
                  <entry>RTS</entry>
                </row>
              </tbody>
            </tgroup>
          </table>

	  <note>
	    <para>Wird ein Pin eines Kabels mit zwei Pins des anderen
	      Kabels verbunden, werden dazu in der Regel zuerst die
	      beiden Pins mit einem kurzem Draht verbunden.  Danach
	      wird dieser Draht mit dem Pin des anderen Endes
	      verbunden.</para>
	  </note>

	  <para>Die eben besprochenen Schemata scheinen die
	    beliebtesten zu sein.  Weitere Varianten verbinden SG mit
	    SG, TD mit RD, RTS und CTS mit DCD, DTR mit DSR, und
	    umgekehrt.</para>

	  <indexterm><primary>RS-232C Kabel</primary></indexterm>

	  <para>Ein Standard-RS-232C-Kabel verbindet alle Signale
	    direkt.  Das Signal <quote>Transmitted Data</quote> wird
	    mit dem Signal <quote>Transmitted Data</quote> der
	    Gegenstelle verbunden.  Dieses Kabel wird benötigt, um ein
	    Modem mit einem &os;-System zu verbinden.  Manche
	    Terminals benötigen dieses Kabel ebenfalls.</para>

	  <para>Über serielle Schnittstellen werden Daten zwischen dem
	    &os;-System und dem Terminal übertragen.  Dieser Abschnitt
	    beschreibt die verschiedenen Schnittstellen und wie sie
	    unter &os; angesprochen werden.</para>

	  <para>Da es verschiedene Schnittstellen gibt, sollte vor
	    dem Kauf oder Selbstbau eines Kabels sichergestellt
	    werden, dass dieses zu den Schnittstellen des Terminals
	    und des &os;-Systems passt.</para>

	  <para>Die meisten Terminals besitzen DB-25-Stecker.
	    Personal Computer haben DB-25- oder DB-9-Stecker.  Eine
	    serielle Multiportkarte hat vielleicht RJ-12- oder
	    RJ-45-Anschlüsse.</para>

	  <para>Die Dokumentation der Geräte sollte Aufschluss
	    über den Typ der benötigten Anschlüsse geben.
	    Oft hilft es, wenn Sie sich den Anschluss einfach
	    ansehen.</para>

	  <para>Unter &os; wird jede serielle Schnittstelle
	    (Port) über einen Eintrag in <filename>/dev</filename>
	    angesprochen.  Es gibt dort zwei verschiedene
	    Einträge:</para>

	  <itemizedlist>
	    <listitem>
	      <para>Schnittstellen für eingehende Verbindungen werden
	        <filename>/dev/ttyu<replaceable>N</replaceable></filename>
		genannt.  Dabei ist <replaceable>N</replaceable> die Nummer
		der Schnittstelle, deren Zählung bei Null beginnt.
		Allgemein wird diese Schnittstelle für Terminals
		benutzt.  Diese Schnittstelle funktioniert nur, wenn ein
		<quote>Data Carrier Detect</quote> Signal
		(<acronym>DCD</acronym>) vorliegt.</para>
	    </listitem>

	    <listitem>
	      <para>Für ausgehende Verbindungen wird in &os; 8.X und
		neueren Versionen
	        <filename>/dev/cuau<replaceable>N</replaceable></filename>
		verwendet.  &os; 7.X und ältere Versionen verwenden
		<filename>/dev/cuad<replaceable>N</replaceable></filename>.
		Dieser Port wird normalerweise nur von
		Modems genutzt.  Er kann allerdings auch für
		Terminals benutzt werden, die das
		<quote>Data Carrier Detect</quote> Signal nicht
		unterstützen.</para>
	    </listitem>
	  </itemizedlist>

	  <para>Wenn ein Terminal an die erste serielle Schnittstelle
	    (<filename>COM1</filename>) angeschlossen ist, wird er
	    über <filename>/dev/ttyu0</filename> angesprochen.
	    Wenn er an der zweiten seriellen Schnittstelle
	    (<acronym>COM2</acronym>) angeschlossen ist, verwenden Sie
	    <filename>/dev/ttyu1</filename>, usw.</para>
    </sect2>

    <sect2>
      <title>Kernelkonfiguration</title>

      <para>In der Voreinstellung benutzt &os; vier serielle
        Schnittstellen, die unter &ms-dos; als
	<filename>COM1</filename>, <filename>COM2</filename>,
	<filename>COM3</filename> und <filename>COM4</filename>
	bekannt sind.  Momentan unterstützt &os; einfache
	Multiportkarten, wie bspw. die BocaBoard 1008 und 2016 und
	bessere wie die von Digiboard und Stallion Technologies.  In
	der Voreinstellung sucht der Kernel allerdings nur nach den
	Standardanschlüssen.</para>

      <para>Um zu überprüfen, ob der Kernel die seriellen
	Schnittstellen erkennt, achten Sie auf die Meldungen beim
	Booten, oder schauen sich diese später mit
	<command>/sbin/dmesg</command> an.  Achten Sie
	auf Meldungen die mit <literal>uart</literal> beginnen:</para>

      <screen>&prompt.root; <userinput>/sbin/dmesg | grep 'uart'</userinput></screen>

      <para>Wenn der Kernel nicht alle seriellen Schnittstellen
	erkennt, müssen Sie <filename>/boot/device.hints</filename>
	konfigurieren.  Wenn Sie diese Datei editieren, können Sie
	die Einträge für Geräte, die auf dem System nicht vorhanden
	sind, auskommentieren oder komplett entfernen.</para>

      <note>
	<para><literal>port IO_COM1</literal> ist ein Ersatz für
	  <literal>port 0x3f8</literal>, <literal>IO_COM2</literal>
	  bedeutet <literal>port 0x2f8</literal>, <literal>IO_COM3</literal>
	  bedeutet <literal>port 0x3e8</literal> und <literal>IO_COM4</literal>
	  steht für <literal>port 0x2e8</literal>.  Die angegebenen
	  IO-Adressen sind genau wie die Interrupts 4, 3, 5 und 9
	  üblich für serielle Schnittstellen.  Beachten Sie, dass sich
	  normale serielle Schnittstellen auf ISA-Bussen
	  <emphasis>keine</emphasis> Interrupts teilen können.
	  Multiportkarten besitzen zusätzliche Schaltkreise, die es
	  allen 16550As auf der Karte erlauben, sich einen oder zwei
	  Interrupts zu teilen.</para>
      </note>
    </sect2>

    <sect2>
      <title>Gerätedateien</title>

      <para>Die meisten Geräte im Kernel werden durch
        Gerätedateien in <filename>/dev</filename> angesprochen.  Die
	<filename>sio</filename> Geräte werden durch
	<filename>/dev/ttyuN</filename>
	für eingehende Verbindungen und durch
	<filename>/dev/cuau<replaceable>N</replaceable></filename> für
	ausgehende Verbindungen angesprochen.  Zum Initialisieren der
	Geräte stellt &os; die Dateien
	<filename>/dev/ttyu<replaceable>N</replaceable>.init</filename> und
	<filename>/dev/cuau<replaceable>N</replaceable>.init</filename>
	zur Verfügung.
	Zusätzlich existieren Dateien für das Sperren von
	Gerätedateien (<foreignphrase>Locking</foreignphrase>).
	Dabei handelt es sich um die Dateien
	<filename>/dev/ttyuN.lock</filename>
	und
	<filename>/dev/cuau<replaceable>N</replaceable>.lock</filename>.
	Diese Dateien werden benutzt, um Kommunikationsparameter beim
	Öffnen eines Ports vorzugeben.  Für Modems, die zur
	Flusskontrolle <literal>RTS/CTS</literal> benutzen, kann damit
	<literal>crtscts</literal> gesetzt werden.  Die Geräte
	<filename>/dev/ttyldN</filename> und
	<filename>/dev/cualaN</filename> (locking
	devices) werden genutzt, um bestimmte Parameter festzuschreiben und
	vor Veränderungen zu schützen.  Weitere Informationen
	zu Terminals finden Sie in &man.termios.4;, &man.sio.4; erklärt
	die Dateien zum Initialisieren und Sperren der Geräte,
	&man.stty.1; beschreibt schließlich
	Terminal-Einstellungen.</para>
    </sect2>

    <sect2 xml:id="serial-hw-config">
      <title>Konfiguration der seriellen Schnittstelle</title>

    <indexterm><primary><filename>ttyu</filename></primary></indexterm>
    <indexterm><primary><filename>cuau</filename></primary></indexterm>

    <para>Anwendungen benutzen normalerweise die Geräte
      <filename>ttyu<replaceable>N</replaceable></filename> oder
      <filename>cuau<replaceable>N</replaceable></filename>.  Das
      Gerät besitzt einige Voreinstellungen für Terminal-I/O,
      wenn es von einem Prozess geöffnet wird.  Mit dem folgenden
      Kommando können Sie sich diese Einstellungen ansehen:</para>

    <screen>&prompt.root; <userinput>stty -a -f /dev/ttyu1</userinput></screen>

    <para>Wenn diese Einstellungen verändert werden, bleiben sie
      nur solange wirksam, bis das Gerät geschlossen wird.
      Wenn das Gerät danach wieder geöffnet wird, sind die
      Voreinstellungen wieder wirksam.  Um die Voreinstellungen
      dauerhaft zu ändern, öffnen Sie das Gerät, das zum Initialisieren
      dient und verändern dessen Einstellungen.  Um beispielsweise
      für <filename>ttyu5</filename> den <option>CLOCAL</option>
      Modus, 8-Bit Kommunikation und <option>XON/XOFF</option>
      Flusssteuerung einzuschalten, setzen Sie das folgende
      Kommando ab:</para>

    <screen>&prompt.root; <userinput>stty -f /dev/ttyu5.init clocal cs8 ixon ixoff</userinput></screen>

    <indexterm>
      <primary>rc-Dateien</primary>
      <secondary><filename>rc.serial</filename></secondary>
    </indexterm>

    <para>In <filename>/etc/rc.d/rc.serial</filename> werden die
      systemweiten Voreinstellungen für serielle Geräte
      vorgenommen.</para>

    <para>Um zu verhindern, dass Einstellungen von Anwendungen
      verändert werden, können Sie die Geräte zum
      Festschreiben von Einstellungen (<quote>locking devices</quote>)
      benutzen.  Wenn sie beispielsweise die Geschwindigkeit von
      <filename>ttyu5</filename> auf 57600&nbsp;bps festlegen wollen,
      benutzen Sie das folgende Kommando:</para>

    <screen>&prompt.root; <userinput>stty -f /dev/ttyld5 57600</userinput></screen>

    <para>Eine Anwendung, die <filename>ttyu5</filename> öffnet,
      kann nun nicht mehr die Geschwindigkeit ändern und muss
      57600&nbsp;bps benutzen.</para>

    <para>Die Geräte zum Initialisieren und Festschreiben von
      Einstellungen sollten selbstverständlich nur von
      <systemitem class="username">root</systemitem> beschreibbar sein.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="term">
    <info>
    <title>Terminals</title>

    <authorgroup>
      <author>
	<personname>
	  <firstname>Sean</firstname>
	  <surname>Kelly</surname>
	</personname>
	<contrib>Beigetragen von </contrib>
      </author>
	<!-- 28 July 1996 -->
    </authorgroup>
    </info>

    <indexterm><primary>Terminals</primary></indexterm>

    <para>Wenn Sie sich nicht an der Konsole oder über ein Netzwerk an
      ein &os;-System anmelden können, sind Terminals ein
      bequemer und kostengünstiger Weg, um auf ein System zuzugreifen.
      Dieser Abschnitt beschreibt wie Sie Terminals mit &os;
      benutzen.</para>

    <para>Das ursprüngliche &unix; System besaß keine Konsolen.
      Zum Anmelden und Starten von Programmen wurden stattdessen
      Terminals benutzt, die an den seriellen Schnittstellen des
      Rechners angeschlossen waren.</para>

    <para>Die Möglichkeit, über eine serielle Schnittstelle eine
      Anmeldesitzung herzustellen, existiert heute noch in fast
      jedem &unix;-artigen Betriebssystem, einschließlich &os;.
      Der Einsatz eines Terminals, das an einem freien seriellen
      Port angeschlossen ist, ermöglicht es dem Benutzer sich
      anzumelden und dort jedes Textprogramm zu starten, das
      normalerweise an der Konsole oder in einem
      <command>xterm</command> Fenster ausgeführt wird.</para>

    <para>Viele Terminals können an einem &os;-System angeschlossen
      werden.  Ein alter Computer kann als Terminal an ein
      leistungsfähiges &os;-System angeschlossen werden.  Damit kann
      ein Einzelarbeitsplatz in ein leistungsfähiges
      Mehrbenutzersystem verwandelt werden.</para>

    <para>&os; unterstützt drei Arten von Anschlüssen:</para>

    <variablelist>
      <varlistentry>
	<term>Dumb-Terminals</term>
	<listitem>
	  <para>Dumb-Terminals (unintelligente Datenstationen) sind
	    Geräte, die über die serielle Schnittstelle mit einem
	    Rechner verbunden werden.  Sie werden
	    <quote>unintelligent</quote> genannt, weil sie nur Text
	    senden und empfangen und keine Programme laufen lassen
	    können.  Alle benötigten Programme befinden sich auf dem
	    Rechner, der mit dem Terminal verbunden ist.</para>

	  <para>Es gibt viele Dumb-Terminals, die von verschiedenen
	    Herstellern produziert werden, und so gut wie jeder der
	    verschiedenen Terminals sollte mit &os; zusammenarbeiten.
	    Manche High-End Geräte verfügen sogar über
	    Grafikfähigkeiten, die allerdings nur von spezieller
	    Software genutzt werden kann.</para>

	  <para>Dumb-Terminals sind in Umgebungen beliebt, in denen
	    keine Grafikanwendungen benötigt werden.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>Computer, die als Terminal fungieren</term>
	<listitem>
	  <para>Jeder Computer kann die Funktion eines Dumb-Terminals,
	    der ja nur Text senden und empfangen kann, übernehmen.
	    Dazu wird lediglich das richtige Kabel benötigt und eine
	    <emphasis>Terminalemulation</emphasis>, die auf dem
	    Computer läuft.</para>

	  <para>Diese Konfiguration ist sehr nützlich.  Wenn ein
	    Benutzer zum Beispiel gerade an der &os;-Konsole arbeitet,
	    kann ein anderer Benutzer einen weniger leistungsstarken
	    Computer, der als Terminal mit dem &os;-System verbunden
	    ist, benutzen, um dort gleichzeitig im Textmodus zu
	    arbeiten.</para>

	  <para>Bereits im Basissystem sind mindestens zwei Werkzeuge
	    vorhanden, die Sie zur Arbeit über eine serielle Konsole
	    einsetzen können:  &man.cu.1; sowie &man.tip.1;.</para>

	  <para>Um sich von einem &os;-System aus über eine serielle
	    Verbindung mit einem anderen System zu verbinden, geben
	    Sie folgenden Befehl ein:</para>

	  <screen>&prompt.root; <userinput>cu -l /dev/cuau<replaceable>N</replaceable></userinput></screen>

	  <para>Die Ports sind von Null beginnend nummeriert.  Das
	    bedeutet, dass <filename>COM1</filename> dem Gerät
	    <filename>/dev/cuau0</filename> entspricht.</para>

	    <para>In der Ports-Sammlung finden sich weitere Programme,
	      wie beispielsweise <package>comms/minicom</package>, mit
	      denen eine Verbindung über eine serielle Schnittstelle
	      hergestellt werden kann.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>X-Terminals</term>
	<listitem>
	  <para>X-Terminals sind die ausgereiftesten der verfügbaren
	    Terminals.  Sie werden nicht mit der seriellen
	    Schnittstelle sondern mit einem Netzwerk, wie dem
	    Ethernet, verbunden.  Diese Terminals sind auch nicht auf
	    den Textmodus beschränkt, sondern können jede
	    <application>&xorg;</application>-Anwendung
	    darstellen.</para>

	  <para>Die Einrichtung und Verwendung von X-Terminals wird in
	    diesem Abschnitt nicht beschrieben.</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <sect2 xml:id="term-config">
      <title>Konfiguration</title>

      <para>Dieser Abschnitt beschreibt, wie Sie ein &os;-System
	konfigurieren müssen, um sich an einem Terminal anzumelden.
	Dabei wird vorausgesetzt, dass der Kernel bereits die
	serielle Schnittstelle, die mit dem Terminal verbunden ist,
	unterstützt.  Weiterhin sollte der Terminal schon
	angeschlossen sein.</para>

      <para>Der <command>init</command> Prozess ist für das
	Initialisieren des Systems und den Start von Prozessen zum
	Zeitpunkt des Systemstarts verantwortlich.  Unter anderem
	liest <command>init</command> <filename>/etc/ttys</filename>
	ein und startet für jeden
	verfügbaren Terminal einen <command>getty</command>
	Prozess.  <command>getty</command> wiederum fragt beim
	Anmelden den Benutzernamen ab und startet
	<command>login</command>.</para>

      <para>Um Terminals auf einem &os;-System einzurichten, führen
        Sie folgenden Schritte als <systemitem
	  class="username">root</systemitem> durch:</para>

      <procedure>
	<step>
	  <para>Fügen Sie einen Eintrag in
	    <filename>/etc/ttys</filename> für die serielle
	    Schnittstelle aus <filename>/dev</filename> ein, falls
	    dieser nicht bereits vorhanden ist.</para>
	</step>

	<step>
	  <para>Geben Sie <command>/usr/libexec/getty</command> als
	    auszuführendes Programm an.  Als Parameter für
	    <replaceable>getty</replaceable> geben Sie den passenden
	    Verbindungstyp aus <filename>/etc/gettytab</filename>
	    an.</para>
	</step>

	<step>
	  <para>Geben Sie den Terminaltyp an.</para>
	</step>

	<step>
	  <para>Aktivieren Sie den Anschluss.</para>
	</step>

	<step>
	  <para>Geben Sie die Sicherheit des Anschlusses an.</para>
	</step>

	<step>
	  <para>Veranlassen Sie <command>init</command>
	    <filename>/etc/ttys</filename> erneut zu lesen.</para>
	</step>
      </procedure>

      <para>Optional können Sie in <filename>/etc/gettytab</filename>
	auch einen auf Ihre Zwecke angepassten Terminaltyp erstellen.
	&man.gettytab.5; und &man.getty.8; enthalten dazu weitere
	Informationen.</para>

      <sect3 xml:id="term-etcttys">
	<title>Hinzufügen eines Eintrags in
	  <filename>/etc/ttys</filename></title>

	<para>In <filename>/etc/ttys</filename> werden alle Terminals
	  aufgeführt, an denen eine Anmeldung auf dem &os;-System
	  möglich ist.  Hier findet sich zum Beispiel ein Eintrag
	  für die erste virtuelle Konsole
	  <filename>/dev/ttyv0</filename>, der es Benutzern
	  ermöglicht, sich dort anzumelden.  Die Datei enthält weitere
	  Einträge für andere virtuelle Konsolen, serielle
	  Schnittstellen und Pseudoterminals.  Um einen Terminal
	  zu konfigurieren, fügen Sie einen Eintrag für den
	  Namen des Gerätes aus <filename>/dev</filename> ohne das
	  Präfix <filename>/dev</filename> hinzu.  Zum Beispiel wird
	  <filename>/dev/ttyv0</filename> als
	  <literal>ttyv0</literal> aufgeführt.</para>

	<para>In der Voreinstellung enthält
	  <filename>/etc/ttys</filename> Einträge für die ersten
	  vier seriellen Schnittstellen: <filename>ttyu0</filename>
	  bis <filename>ttyu3</filename>.  Wird an eine von diesen
	  Schnittstellen ein Terminal angeschlossen, braucht in dieser
	  Datei kein weiter Eintrag hinzugefügt werden.</para>

	<example xml:id="ex-etc-ttys">
	  <title>Einträge in <filename>/etc/ttys</filename>
	    hinzufügen</title>

	  <para>Dieses Beispiel konfiguriert zwei Terminals:
	    Einen Wyse-50 und einen alten 286 IBM PC,
	    der mit <application>Procomm</application> einen VT-100
	    Terminal emuliert.  Der Wyse-Terminal ist mit der
	    zweiten seriellen Schnittstelle verbunden und der 286
	    mit der sechsten seriellen Schnittstelle, einem Anschluss
	    auf einer Multiportkarte.  Die entsprechenden Einträge in
	    <filename>/etc/ttys</filename> würden dann wie folgt
	    aussehen:</para>

	  <programlisting>ttyu1<co xml:id="co-ttys-line1col1"/>  "/usr/libexec/getty std.38400"<co xml:id="co-ttys-line1col2"/>  wy50<co xml:id="co-ttys-line1col3"/>  on<co xml:id="co-ttys-line1col4"/>  insecure<co xml:id="co-ttys-line1col5"/>
ttyu5   "/usr/libexec/getty std.19200"  vt100  on  insecure
	  </programlisting>

	  <calloutlist>
	    <callout arearefs="co-ttys-line1col1">
	      <para>Das erste Feld gibt normalerweise den Namen der
	        Gerätedatei aus <filename>/dev</filename> an.</para>
	    </callout>
	    <callout arearefs="co-ttys-line1col2">

	      <para>Im zweiten Feld wird das auszuführende Kommando,
	        normal ist das &man.getty.8;, angegeben.
		<command>getty</command> initialisiert und öffnet die
		Verbindung, setzt die Geschwindigkeit und fragt den
		Benutzernamen ab.  Danach führt es &man.login.1;
		aus.</para>

	      <para><command>getty</command> akzeptiert einen optionalen
	        Parameter auf der Kommandozeile, den Verbindungstyp, der
		die Eigenschaften der Verbindung, wie die Geschwindigkeit
		und Parität, festlegt.  Die Typen und die damit
		verbundenen Eigenschaften liest <command>getty</command>
		aus <filename>/etc/gettytab</filename>.</para>

	      <para><filename>/etc/gettytab</filename> enthält viele
	        Einträge sowohl für neue wie auch alte
		Terminalverbindungen.  Die meisten Einträge, die mit
		<literal>std</literal> beginnen, sollten mit einem
		festverdrahteten Terminal funktionieren.  Für jede
		Geschwindigkeit zwischen
		110&nbsp;<acronym>bps</acronym> und
		115200&nbsp;<acronym>bps</acronym> gibt es einen
		<literal>std</literal> Eintrag.  Weitere Informationen
		dazu finden Sie in &man.gettytab.5;.</para>

	      <para>Wenn Sie den Verbindungstyp in
	        <filename>/etc/ttys</filename> eintragen, stellen Sie
		sicher, dass die Kommunikationseinstellungen
		auch mit denen des Terminals übereinstimmen.</para>

	      <para>In diesem Beispiel verwendet der Wyse-50 keine
	        Parität und 38400&nbsp;<acronym>bps</acronym>, der
		286&nbsp;PC benutzt ebenfalls keine Parität und
		arbeitet mit 19200&nbsp;<acronym>bps</acronym>.</para>

	    </callout>

	    <callout arearefs="co-ttys-line1col3">

	      <para>Das dritte Feld gibt den Terminaltyp an, der
	        normalerweise mit diesem Anschluss verbunden ist.
		Für Einwählverbindungen wird oft
		<literal>unknown</literal> oder <literal>dialup</literal>
		benutzt, da sich die Benutzer praktisch mit beliebigen
		Terminals oder Emulatoren anmelden können.  Bei
		festverdrahteten Terminals ändert sich der Typ nicht,
		so dass in diesem Feld ein richtiger Typ aus der
		&man.termcap.5; Datenbank angegeben werden
		kann.</para>

	      <para>In diesem Beispiel benutzt der Wyse-50
	        den entsprechenden Typ aus &man.termcap.5;, der 286 PC
		wird als VT-100, den er ja emuliert, angegeben.</para>

	    </callout>

	    <callout arearefs="co-ttys-line1col4">
	      <para>Das vierte Feld gibt an, ob der Anschluss
	        aktiviert werden soll.  Ist das Feld auf
		<literal>on</literal> gesetzt, startet
		<command>init</command> das Programm, das
		im zweiten Feld angegeben ist. Normalerweise ist dies
		<command>getty</command>.  Wenn das Feld auf
		<literal>off</literal>gesetzt wird, wird
		<command>getty</command> nicht ausgeführt und folglich
		kann sich niemand an dem betreffenden Terminal
		anmelden.</para>
	    </callout>

	    <callout arearefs="co-ttys-line1col5">
	      <para>Das letzte Feld gibt die Sicherheit des
	        Anschlusses an.  Wenn hier <literal>secure</literal>
		angegeben wird, darf sich <systemitem
		  class="username">root</systemitem>, oder jeder
		Account mit der <acronym>UID</acronym>
		<literal>0</literal> über diese Verbindung anmelden.
		Wenn <literal>insecure</literal> angegeben wird,
		dürfen sich nur unprivilegierte Benutzer anmelden.
		Diese können später mit &man.su.1; oder einem
		ähnlichen Mechanismus zu <systemitem
		  class="username">root</systemitem> wechseln.</para>

	      <para>Es wird dringend empfohlen
		<literal>insecure</literal> zu verwenden, sogar für
		Terminals hinter verschlossenen Türen.  Es ist ganz
		einfach sich mit <command>su</command> anzumelden,
		wenn Superuser-Rechte benötigt werden.</para>
	    </callout>
	  </calloutlist>
	</example>
      </sect3>

      <sect3 xml:id="term-hup">
	<title><command>init</command> zwingen,
	  <filename>/etc/ttys</filename> erneut zu lesen</title>

	<para>Nachdem Änderungen in <filename>/etc/ttys</filename>
	  vorgenommen wurden, schicken Sie
	  <command>init</command> ein SIGHUP-Signal (hangup), um es zu
	  veranlassen, seine Konfigurationsdatei neu zu lesen:</para>

	<screen>&prompt.root; <userinput>kill -HUP 1</userinput></screen>

	<note>
	  <para>Da <command>init</command> immer der erste Prozess auf
	    einem System ist, besitzt es immer die Prozess-ID
	    <literal>1</literal>.</para>
	</note>

	<para>Wenn alles richtig eingerichtet ist, alle Kabel angeschlossen
	  und die Terminals eingeschaltet sind, sollte für jeden
	  Terminal ein <command>getty</command> Prozess laufen und auf
	  jedem Terminal sollte eine Anmeldeaufforderung zu sehen
	  sein.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="term-debug">
      <title>Fehlersuche</title>

      <para>Selbst wenn Sie den Anweisungen akribisch gefolgt sind, kann es
	immer noch zu Fehlern beim Einrichten eines Terminals kommen.
	Hier eine Liste der häufigsten Symptome, sowie einige mögliche
	Lösungen:</para>

	<para>Wenn kein Anmeldeprompt erscheint, stellen Sie sicher,
	  dass der Terminal verbunden und
	  eingeschaltet ist.  Wenn ein PC als Terminal fungiert,
	  überprüfen Sie, dass die Terminalemulation auf
	  den richtigen Schnittstellen läuft.</para>

	<para>Stellen Sie sicher, dass Sie das richtige Kabel
	  verwenden und dass das Kabel fest mit dem Terminal und
	  dem &os;-Rechner verbunden ist.</para>

	<para>Stellen Sie sicher, dass die Einstellungen für
	  die Geschwindigkeit (<acronym>bps</acronym>) und Parität auf
	  dem &os;-System und dem Terminal gleich sind.  Wenn der
	  Terminal einen Bildschirm besitzt, überprüfen Sie die
	  richtige Einstellung von Helligkeit und Kontrast.  Wenn der
	  Terminal druckt, stellen Sie die ausreichende Versorgung mit
	  Papier und Tinte sicher.</para>

	<para>Überprüfen Sie mit <command>ps</command>,
	  dass der <command>getty</command> Prozess für
	  den Terminal läuft:</para>

        <screen>&prompt.root; <userinput>ps -axww|grep getty</userinput></screen>

	<para>Für jeden Terminal sollte ein Eintrag vorhanden sein.
	  Aus dem folgenden Beispiel ist zu erkennen, dass
	  <command>getty</command> auf der zweiten seriellen
	  Schnittstelle <filename>tyyd1</filename> läuft und den
	  Verbindungstyp <literal>std.38400</literal> aus
	  <filename>/etc/gettytab</filename> benutzt:</para>

	<screen>22189  d1  Is+    0:00.03 /usr/libexec/getty std.38400 ttyu1</screen>

	<para>Wenn <command>getty</command> nicht läuft,
	  überprüfen Sie, ob der Anschluss in
	  <filename>/etc/ttys</filename> aktiviert ist.  Denken Sie
	  daran <command>kill -HUP 1</command> auszuführen, nachdem
	  <filename>/etc/ttys</filename> geändert wurde.</para>

	<para>Wenn <command>getty</command> läuft, aber der
	  Terminal immer noch kein Anmeldeprompt ausgibt, oder am
	  Anmeldeprompt nichts eingegeben werden kann, kann es sein,
	  dass der Terminal oder Kabel keinen Hardware-Handshake
	  unterstützt.  Ändern Sie dann den Eintrag
	  <literal>std.38400</literal> in <filename>/etc/ttys</filename>
	  zu <literal>3wire.38400</literal>.  Nachdem Sie
	  <filename>/etc/ttys</filename> geändert haben, setzen
	  Sie <command>kill -HUP 1</command> ab.  Der
	  Eintrag <literal>3wire</literal> besitzt ähnliche
	  Eigenschaften wie der Eintrag <literal>std</literal>,
	  ignoriert aber den Hardware-Handshake.  Wenn Sie den Eintrag
	  <literal>3wire</literal> verwenden, muss vielleicht die
	  Geschwindigkeit verkleinert oder die Software-Flusssteuerung
	  aktiviert werden, um Pufferüberläufe zu vermeiden.</para>

	<para>Wenn nur unverständliche Zeichen erscheinen, stellen Sie
	  sicher, dass die Einstellungen für
	  die Geschwindigkeit (<acronym>bps</acronym>) und Parität auf
	  dem &os;-System
	  und dem Terminal gleich sind.  Kontrollieren Sie den
	  <command>getty</command> Prozess und stellen Sie sicher,
	  dass der richtige Verbindungstyp aus
	  <filename>/etc/gettytab</filename> benutzt wird.  Wenn das
	  nicht der Fall ist, editieren Sie
	  <filename>/etc/ttys</filename> und setzen das Kommando
	  <command>kill-HUP 1</command> ab.</para>

	<para>Wenn Zeichen doppelt und eingegebene Passwörter im
	  Klartext erscheinen, stellen Sie den Terminal oder die
	  Terminalemulation von <quote>half duplex</quote> oder
	  <quote>local echo</quote> auf <quote>full duplex</quote>
	  um.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="dialup">
    <info>
    <title>Einwählverbindungen</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Guy</firstname>
	    <surname>Helmer</surname>
	  </personname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
      <authorgroup>
        <author>
	  <personname>
	    <firstname>Sean</firstname>
	    <surname>Kelly</surname>
	  </personname>
	  <contrib>Mit Anmerkungen von </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm><primary>Einwählverbindungen</primary></indexterm>

    <para>Das Einrichten von Einwählverbindungen auf
      &os;-Systemen ähnelt dem Anschließen von Terminals, nur dass
      anstelle eines Terminals ein Modem verwendet wird.  &os;
      unterstützt sowohl externe als auch interne Modems.</para>

	<para>Externe Modems sind für Einwählverbindungen besser
	  geeignet, da sie die Konfiguration in nicht flüchtigem RAM
	  speichern können.  Zudem verfügen Sie über
	  Leuchtanzeigen, die den Status wichtiger RS-232 Signale
	  anzeigen.</para>

	<para>Interne Modems verfügen normalerweise nicht über
	  nicht flüchtiges RAM und lassen sich meist nur über
	  DIP-Schalter konfigurieren.  Selbst wenn ein internes Modem
	  Leuchtanzeigen besitzt, sind diese meist schwer einzusehen, wenn
	  das Modem eingebaut ist.</para>

	<indexterm><primary>Modem</primary></indexterm>

	<para>Mit einem externen Modem muss das passende Kabel
	  verwendet werden.  Ein Standard RS-232C Kabel, bei dem die
	  folgenden Signale miteinander verbunden sind, sollte
	  ausreichen:</para>

          <table frame="none" pgwide="1" xml:id="serialcomms-signal-names">
            <title>Signalnamen</title>

            <tgroup cols="2">
              <thead>
                <row>
                  <entry align="left">Abkürzung</entry>
                  <entry align="left">Bedeutung</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry><acronym>RD</acronym></entry>
                  <entry>Received Data</entry>
                </row>

                <row>
                  <entry><acronym>TD</acronym></entry>
                  <entry>Transmitted Data</entry>
                </row>

                <row>
                  <entry><acronym>DTR</acronym></entry>
                  <entry>Data Terminal Ready</entry>
                </row>

                <row>
                  <entry><acronym>DSR</acronym></entry>
                  <entry>Data Set Ready</entry>
                </row>

                <row>
                  <entry><acronym>DCD</acronym></entry>
                  <entry>Data Carrier Detect (dadurch erkennt RS-232
                    das Signal <emphasis>Received Line</emphasis>)</entry>
                </row>

                <row>
                  <entry><acronym>SG</acronym></entry>
                  <entry>Signal Ground</entry>
                </row>

                <row>
                  <entry><acronym>RTS</acronym></entry>
                  <entry>Request to Send</entry>
                </row>

                <row>
                  <entry><acronym>CTS</acronym></entry>
                  <entry>Clear to Send</entry>
                </row>
              </tbody>
            </tgroup>
          </table>

	<para>Ab Geschwindigkeiten von 2400&nbsp;bps benötigt &os; die
	  Signale <acronym>RTS</acronym> und <acronym>CTS</acronym>
	  für die Flusssteuerung.  Das Signal
	  <acronym>CD</acronym> zeigt an, ob ein Träger vorliegt, das
	  heißt ob die Verbindung aufgebaut ist oder beendet wurde.
	  <acronym>DTR</acronym> zeigt an, dass das Gerät
	  betriebsbereit ist.  Es gibt einige Kabel, bei denen nicht alle
	  nötigen Signale verbunden sind.  Wenn Probleme dieser Art
	  auftreten, dass zum Beispiel die Sitzung nicht beendet wird,
	  obwohl die Verbindung beendet wurde, kann das an einem solchen
	  Kabel liegen.</para>

	<para>Wie andere &unix; Betriebssysteme auch, benutzt &os;
	  Hardwaresignale, um festzustellen, ob ein Anruf
	  beantwortet wurde, eine Verbindung beendet wurde, oder um die
	  Verbindung zu schließen und das Modem zurückzusetzen.
	  &os; vermeidet es, dem Modem Kommandos zu senden, oder den
	  Statusreport des Modems abzufragen.</para>

      <sect2>
	<title>Schnittstellenbausteine</title>

	<para>&os; unterstützt EIA RS-232C (CCITT V.24) serielle
	  Schnittstellen, die auf den NS8250, NS16450, NS16550 oder NS16550A
	  Bausteinen basieren.  Die Bausteine der Serie 16550 verfügen
	  über einen 16&nbsp;Byte großen Puffer, der als FIFO angelegt
	  ist.  Wegen Fehler in der FIFO-Logik kann der Puffer in einem 16550
	  Baustein allerdings nicht genutzt werden, das heißt der
	  Baustein muss als 16450 betrieben werden.  Bei allen
	  Bausteinen ohne Puffer und dem 16550 Baustein muss jedes
	  Byte einzeln von dem Betriebssystem verarbeitet werden, was
	  Fehler bei hohen Geschwindigkeiten oder großer Systemlast
	  erzeugt.  Es sollten daher nach Möglichkeit serielle
	  Schnittstellen, die auf 16550A Bausteinen basieren, eingesetzt
	  werden.</para>
      </sect2>

    <sect2>
      <title>Überblick</title>

      <indexterm><primary>getty</primary></indexterm>
      <para>Wie bei Terminals auch, startet <command>init</command> für
	jede serielle Schnittstelle, die eine Einwählverbindung zur
	Verfügung stellt, einen <command>getty</command> Prozess.
	Wenn das Modem beispielsweise an <filename>/dev/ttyu0</filename>
	angeschlossen ist, sollte in der Ausgabe von <command>ps
	  ax</command> eine Zeile wie die folgende erscheinen:</para>

      <screen> 4850 ??  I      0:00.09 /usr/libexec/getty V19200 ttyu0</screen>

      <para>Wenn sich ein Benutzer einwählt und die Verbindung
        aufgebaut ist, zeigt das Modem dies durch das <acronym>CD</acronym>
	Signal (Carrier Detect) an.  Der Kernel merkt, dass ein Signal
	anliegt und weist <command>getty</command> an, die
	Schnittstelle zu öffnen.  Dann sendet <command>getty</command> das
	Anmeldeprompt mit der ersten für die Verbindung vereinbarten
	Geschwindigkeit und wartet auf eine Antwort.  Wenn die Antwort
	unverständlich ist, weil zum Beispiel die Geschwindigkeit des
	Modems von <command>getty</command>s Geschwindigkeit abweicht,
	versucht <command>getty</command> die Geschwindigkeit solange
	anzupassen, bis es eine verständliche Antwort
	erhält.</para>

      <indexterm>
        <primary><command>/usr/bin/login</command></primary>
      </indexterm>
      <para>Nachdem der Benutzer seinen Benutzernamen eingegeben hat,
	führt <command>getty</command>
	<filename>/usr/bin/login</filename> aus, welches das Passwort
	abfragt und danach die Shell des Benutzers startet.</para>
    </sect2>


    <sect2>
      <title>Konfigurationsdateien</title>

      <para>Drei Konfigurationsdateien in <filename>/etc</filename>
        steuern, ob eine Einwahl in das &os;-System möglich ist.
	<filename>/etc/gettytab</filename>, konfiguriert den
	<filename>/usr/libexec/getty</filename> D&aelig;mon.  In
	<filename>/etc/ttys</filename> wird festgelegt, auf welchen
	Schnittstellen <filename>/sbin/init</filename> einen
	<command>getty</command> Prozess startet.  Schließlich
	bietet <filename>/etc/rc.d/serial</filename> die
	Möglichkeit, Schnittstellen zu initialisieren.</para>

      <para>Es gibt zwei Ansichten darüber, wie Modems für
        Einwählverbindungen unter &unix; zu konfigurieren sind.  Zum
	einen kann die Geschwindigkeit zwischen dem Modem und dem Computer
	fest eingestellt werden.  Sie ist damit unabhängig von der
	Geschwindigkeit, mit der sich der entfernte Benutzer einwählt.
	Dies hat den Vorteil, dass der entfernte Benutzer das
	Anmeldeprompt sofort bekommt.  Der Nachteil bei diesem Verfahren
	ist, dass das System die tatsächliche Geschwindigkeit
	der Verbindung nicht kennt.  Damit können bildschirmorientierte
	Programme wie <application>Emacs</application> ihren
	Bildschirmaufbau nicht an langsame Verbindungen anpassen,
	um die Antwortzeiten zu verbessern.</para>

      <para>Die andere Möglichkeit besteht darin, die Geschwindigkeit
        der RS-232 Schnittstelle des lokalen Modems an die Geschwindigkeit
	des entfernten Modems anzupassen.  Bei einer V.32bis (14400&nbsp;bps)
	Verbindung kann das lokale Modem die RS-232 Schnittstelle mit
	19200&nbsp;bps betreiben, während bei einer Verbindung mit
	2400&nbsp;bps die RS-232 Schnittstelle mit 2400&nbsp;bps
	betrieben wird.  Da <command>getty</command> die
	Verbindungsgeschwindigkeit des Modems nicht kennt, startet es
	den Anmeldevorgang mit der Ausgabe
	von <prompt>login:</prompt> und wartet auf eine Antwort.  Wenn der
	Benutzer der Gegenstelle nun nur unverständliche Zeichen
	erhält, muss er solange <keycap>Enter</keycap>
	drücken, bis das Anmeldeprompt erscheint.  Solange die
	Geschwindigkeiten nicht übereinstimmen, sind die Antworten der
	Gegenstelle für <command>getty</command> ebenfalls
	unverständlich.  In diesem Fall wechselt
	<command>getty</command> zur nächsten Geschwindigkeit und gibt
	wieder <prompt>login:</prompt> aus.  In aller Regel erhält der
	Benutzer der Gegenstelle nach ein bis zwei Tastendrücken
	eine erkennbare Anmeldeaufforderung.  Diese Anmeldeprozedur sieht
	nicht so sauber wie die Methode mit einer festen Geschwindigkeit
	aus, bietet dem Benutzer einer langsamen Verbindung allerdings den
	Vorteil, dass sich bildschirmorientierte Programme an die
	Geschwindigkeit anpassen können.</para>

      <para>Im Folgenden wird die Konfiguration für beide Methoden
        besprochen, doch die Methode der angepassten Geschwindigkeit
	wird bei der Diskussion bevorzugt.</para>

      <sect3>
	<title><filename>/etc/gettytab</filename></title>

  <indexterm>
    <primary><filename>/etc/gettytab</filename></primary>
  </indexterm>
	<para>Mit <filename>/etc/gettytab</filename> wird &man.getty.8; im
	Stil von &man.termcap.5; konfiguriert.  Das Format dieser Datei und
	die Bedeutung der Einträge wird in &man.gettytab.5;
	beschrieben.</para>

	  <para>Wenn die Modemgeschwindigkeit vorgeben wird, sollten
	    Anpassungen in <filename>/etc/gettytab</filename> nicht
	    erforderlich sein.</para>

	  <para>Wenn jedoch die Geschwindigkeit angepasst werden soll,
	    erstellen Sie einen Eintrag in
	    <filename>/etc/gettytab</filename>, um
	    <command>getty</command> die Geschwindigkeit für das
	    Modem mitzuteilen.  Für ein 2400&nbsp;bps Modem kann der
	    vorhandene <literal>D2400</literal> Eintrag benutzt
	    werden.</para>

	  <programlisting>#
# Fast dialup terminals, 2400/1200/300 rotary (can start either way)
#
D2400|d2400|Fast-Dial-2400:\
        :nx=D1200:tc=2400-baud:
3|D1200|Fast-Dial-1200:\
        :nx=D300:tc=1200-baud:
5|D300|Fast-Dial-300:\
        :nx=D2400:tc=300-baud:</programlisting>

	  <para>Wird ein Modem mit einer höheren Geschwindigkeit
	    eingesetzt, müssen weitere Einträge in
	    <filename>/etc/gettytab</filename> erstellt werden.
	    Dieses Beispiel zeigt einen Eintrag für ein 14400&nbsp;bps
	    Modem mit einer Geschwindigkeit bis zu
	    19200&nbsp;bps:</para>

	  <programlisting>#
# Additions for a V.32bis Modem
#
um|V300|High Speed Modem at 300,8-bit:\
        :nx=V19200:tc=std.300:
un|V1200|High Speed Modem at 1200,8-bit:\
        :nx=V300:tc=std.1200:
uo|V2400|High Speed Modem at 2400,8-bit:\
        :nx=V1200:tc=std.2400:
up|V9600|High Speed Modem at 9600,8-bit:\
        :nx=V2400:tc=std.9600:
uq|V19200|High Speed Modem at 19200,8-bit:\
        :nx=V9600:tc=std.19200:</programlisting>

	  <para>Die damit erzeugten Verbindungen verwenden 8&nbsp;Bit und keine
	    Parität.</para>

	  <para>Im obigen Beispiel startet die Geschwindigkeit bei
	    19200&nbsp;bps (eine V.32bis Verbindung) und geht dann
	    über 9600&nbsp;bps (V.32), 400&nbsp;bps, 1200&nbsp;bps
	    und 300&nbsp;bps wieder zurück zu 19200&nbsp;bps.
	    Das Schlüsselwort <literal>nx=</literal>
	    (<foreignphrase>next table</foreignphrase>) sorgt für
	    das zyklische Durchlaufen der Geschwindigkeiten.  Jede Zeile
	    zieht zudem noch mit <literal>tc=</literal>
	    (<foreignphrase>table continuation</foreignphrase>)
	    die Vorgabewerte für die jeweilige Geschwindigkeit an.</para>

	  <para>Wenn Sie ein 28800&nbsp;bps Modem besitzen und/oder Kompression
	    mit einem 14400&nbsp;bps Modem benutzen wollen, brauchen Sie
	    höhere Geschwindigkeiten als 19200&nbsp;bps.  Das folgende
	    Beispiel startet mit 57600&nbsp;bps:</para>

	  <programlisting>#
# Additions for a V.32bis or V.34 Modem
# Starting at 57600 bps
#
vm|VH300|Very High Speed Modem at 300,8-bit:\
        :nx=VH57600:tc=std.300:
vn|VH1200|Very High Speed Modem at 1200,8-bit:\
        :nx=VH300:tc=std.1200:
vo|VH2400|Very High Speed Modem at 2400,8-bit:\
        :nx=VH1200:tc=std.2400:
vp|VH9600|Very High Speed Modem at 9600,8-bit:\
        :nx=VH2400:tc=std.9600:
vq|VH57600|Very High Speed Modem at 57600,8-bit:\
        :nx=VH9600:tc=std.57600:</programlisting>

	  <para>Wenn Sie eine langsame CPU oder ein stark
	    ausgelastetes System besitzen und sich kein 16550A im
	    System befindet, erhalten Sie bei 57600&nbsp;bps
	    vielleicht <errorname>sio</errorname> Fehlermeldungen der
	    Form <quote>silo overflow</quote>.</para>
      </sect3>

      <sect3 xml:id="dialup-ttys">
	<title><filename>/etc/ttys</filename></title>
	<indexterm>
	  <primary><filename>/etc/ttys</filename></primary>
	</indexterm>

	<para><filename>/etc/ttys</filename> wurde bereits in <xref
	    linkend="ex-etc-ttys"/> besprochen.  Die Konfiguration für
	  Modems ist ähnlich, allerdings braucht
	  <command>getty</command> ein anderes Argument und es muss
	  ein anderer Terminaltyp angegeben werden.  Der Eintrag für
	  beide Methoden (feste und angepasste Geschwindigkeit) hat
	  die folgende Form:</para>

	<programlisting>ttyu0   "/usr/libexec/getty <replaceable>xxx</replaceable>"   dialup on</programlisting>

	<para>Das erste Feld der obigen Zeile gibt die Gerätedatei
	  für diesen Eintrag an.  <filename>ttyu0</filename>
	  bedeutet, dass <command>getty</command> mit
	  <filename>/dev/ttyu0</filename> arbeitet.  Das zweite Feld
	  <literal>"/usr/libexec/getty xxx"</literal>
	  gibt das Kommando an, das <command>init</command> für dieses
	  Gerät startet (<replaceable>xxx</replaceable> wird durch
	  einen passenden Eintrag aus <filename>/etc/gettytab</filename>
	  ersetzt).  Die Vorgabe für den Terminaltyp, hier
	  <literal>dialup</literal>, wird im dritten Feld angegeben.  Das
	  vierte Feld, <literal>on</literal>, zeigt
	  <command>init</command> an, dass die Schnittstelle aktiviert
	  ist.  Im fünften Feld könnte noch
	  <literal>secure</literal> angegeben werden, um Anmeldungen von
	  <systemitem class="username">root</systemitem> zu erlauben, doch sollte das wirklich
	  nur für physikalisch sichere Terminals, wie die
	  Systemkonsole, aktiviert werden.</para>

	<para>Die Vorgabe für den Terminaltyp,
	  <literal>dialup</literal> im obigen Beispiel, hängt von lokalen
	  Gegebenheiten ab.  Traditionell wird <literal>dialup</literal>
	  für Einwählverbindungen verwendet, so dass die
	  Benutzer in ihren Anmeldeskripten den Terminaltyp auf ihren
	  Terminal abstimmen können, wenn der Typ auf
	  <literal>dialup</literal> gesetzt ist.  Wenn Sie nur VT102
	  Terminals oder Emulatoren einsetzen,
	  können Sie den Terminaltyp hier auch fest auf
	  <literal>vt102</literal> setzen.</para>

	<para>Nachdem <filename>/etc/ttys</filename> geändert wurde,
	  muss <command>init</command> ein <acronym>HUP</acronym>
	  Signal schicken, damit es die Datei wieder einliest:</para>

	<screen>&prompt.root; <userinput>kill -HUP 1</userinput></screen>

	<para>Stellen Sie sicher, dass das Modem richtig konfiguriert
	  und angeschlossen ist, bevor Sie das Signal an
	  <command>init</command> schicken.</para>

	  <para>Das Argument von <command>getty</command> muss in
	    diesem Fall eine feste Geschwindigkeit vorgeben.  Der Eintrag
	    für ein Modem, das fest auf 19200&nbsp;bps eingestellt ist,
	    könnte wie folgt aussehen:</para>

	  <programlisting>ttyu0   "/usr/libexec/getty std.19200"   dialup on</programlisting>

	  <para>Wenn das Modem auf eine andere Geschwindigkeit eingestellt
	    ist, setzen Sie anstelle von <literal>std.19200</literal> einen
	    passenden Eintrag der Form
	    <literal>std.<replaceable>speed</replaceable></literal> ein.
	    Stellen Sie sicher, dass dies auch ein gültiger
	    Verbindungstyp aus <filename>/etc/gettytab</filename>
	    ist.</para>

	  <para>Das Argument von <command>getty</command> muss hier auf
	    einen der Einträge aus <filename>/etc/gettytab</filename>
	    zeigen, der zu einer Kette von Einträgen gehört, die
	    die zu probierenden Geschwindigkeiten beschreiben.  Wenn Sie
	    dem obigen Beispiel gefolgt sind und zusätzliche
	    Einträge in <filename>/etc/gettytab</filename> erzeugt
	    haben, können Sie die folgende Zeile verwenden:</para>

	  <programlisting>ttyu0   "/usr/libexec/getty V19200"   dialup on</programlisting>
      </sect3>

      <sect3>
	<title><filename>/etc/rc.d/serial</filename></title>
	<indexterm>
	  <primary>rc-Dateien</primary>
	  <secondary><filename>rc.serial</filename></secondary>
	</indexterm>

	<para>Modems, die höhere Geschwindigkeiten unterstützen,
	  zum Beispiel V.32, V.32bis und V.34 Modems, benutzen
	  Hardware-Flusssteuerung (<literal>RTS/CTS</literal>).  Für
	  die entsprechenden Schnittstellen können Sie die
	  Flusssteuerung mit <command>stty</command> in
	  <filename>/etc/rc.d/serial</filename> einstellen.</para>

	<para>Um beispielsweise die Hardware-Flusssteuerung
	  für die Geräte zur Ein- und Auswahl der zweiten
	  seriellen Schnittstelle (<filename>COM2</filename>)
	  zu aktivieren, benutzen Sie die Dateien zur Initialisierung der
	  entsprechenden Geräte und fügen die folgenden Zeilen in
	  <filename>/etc/rc.d/serial</filename> hinzu:</para>

	<programlisting># Serial port initial configuration
stty -f /dev/ttyu1.init crtscts
stty -f /dev/cuad1.init crtscts</programlisting>

      </sect3>
    </sect2>

    <sect2>
      <title>Modemkonfiguration</title>

      <para>Für ein Modem, das seine Konfiguration in nicht
        flüchtigem RAM speichert, wird ein Terminalprogramm wie
	<application>Telix</application> unter &ms-dos; oder
	<command>tip</command> unter &os; benötigt, um die Parameter
	einzustellen.  Verbinden Sie sich mit derselben Geschwindigkeit, die
	<command>getty</command> zuerst benutzen würde, mit dem Modem und
	treffen Sie folgende Einstellungen:</para>

      <itemizedlist>
	<listitem>
	  <para><acronym>DCD</acronym> ist eingeschaltet, wenn das
	    Trägersignal des entfernten Modems erkannt wird.</para>
	</listitem>

	<listitem>
	  <para>Im Betrieb liegt <acronym>DTR</acronym> an.  Bei einem Verlust
	    von DTR legt das Modem auf und setzt sich zurück.</para>
	</listitem>

	<listitem>
	  <para><acronym>CTS</acronym> Flusssteuerung ist für
	    ausgehende Daten aktiviert.</para>
	</listitem>

	<listitem>
	  <para><acronym>XON/XOFF</acronym> Flusssteuerung ist
	    ausgeschaltet.</para>
	</listitem>

	<listitem>
	  <para><acronym>RTS</acronym> Flusssteuerung ist für
	    eingehende Daten aktiviert.</para>
	</listitem>

	<listitem>
	  <para>Keine Rückmeldungen ausgeben.</para>
	</listitem>

	<listitem>
	  <para>Die Echo-Funktion ist deaktiviert.</para>
	</listitem>
      </itemizedlist>

      <para>Lesen Sie die Dokumentation für das Modem, um
	herauszufinden welche Befehle und/oder DIP-Schalterstellungen
	benötigt werden.</para>

      <para>Für ein externes 14400 &usrobotics; &sportster; gelten zum
        Beispiel die folgenden Befehle:</para>

      <programlisting>ATZ
AT&amp;C1&amp;D2&amp;H1&amp;I0&amp;R2&amp;W</programlisting>

      <para>Bei dieser Gelegenheit können Sie auch gleich andere
        Einstellungen, zum Beispiel ob Sie V42.bis und/oder MNP5
	Kompression benutzen wollen, an Ihrem Modem vornehmen.</para>

      <para>Bei einem externen 14400 &usrobotics; &sportster;
	müssen Sie auch noch einige DIP-Schalter einstellen.
	Die folgenden Einstellungen können verwendet werden:</para>

      <itemizedlist>
	<listitem>
	  <para>Schalter 1: OBEN &ndash; DTR normal</para>
	</listitem>

	<listitem>
	  <para>Schalter 2: N/A (Rückmeldungen als Text/numerische
	    Rückmeldungen)</para>
	</listitem>

	<listitem>
	  <para>Schalter 3: OBEN &ndash; Keine Rückmeldungen
	    ausgeben</para>
	</listitem>

	<listitem>
	  <para>Schalter 4: UNTEN &ndash; Echo-Funktion aus</para>
	</listitem>

	<listitem>
	  <para>Schalter 5: OBEN &ndash; Rufannahme aktiviert</para>
	</listitem>

	<listitem>
	  <para>Schalter 6: OBEN &ndash; Carrier Detect normal</para>
	</listitem>

	<listitem>
	  <para>Schalter 7: OBEN &ndash; Einstellungen aus dem NVRAM laden</para>
	</listitem>

	<listitem>
	  <para>Schalter 8: N/A (Smart Mode/Dumb Mode)</para>
	</listitem>
      </itemizedlist>

      <para>Für Einwählverbindungen sollten die
        Rückmeldungen deaktiviert sein, da sonst
	<command>getty</command> dem Modem das Anmeldeprompt
	<prompt>login:</prompt> schickt und das Modem im Kommandomodus das
	Prompt wieder ausgibt (Echo-Funktion) oder eine Rückmeldung gibt.
	Das führt dann zu einer länglichen und fruchtlosen
	Kommunikation zwischen dem Modem und
	<command>getty</command>.</para>

	<para>Die Geschwindigkeit zwischen Modem und Computer muss auf
	  einen festen Wert eingestellt werden.  Mit einem externen 14400
	  &usrobotics; &sportster; Modem setzen die folgenden Kommandos die
	  Geschwindigkeit auf den Wert der Datenendeinrichtung fest:</para>

	<programlisting>ATZ
AT&amp;B1&amp;W</programlisting>

	<para>In diesem Fall muss die Geschwindigkeit der seriellen
	  Schnittstelle des Modems der eingehenden Geschwindigkeit
	  angepasst werden.  Für ein externes
	  14400 &usrobotics; &sportster;
	  Modem erlauben die folgenden Befehle eine Anpassung der
	  Geschwindigkeit der seriellen Schnittstelle für
	  Verbindungen, die keine Fehlerkorrektur verwenden:</para>

	<programlisting>ATZ
AT&amp;B2&amp;W</programlisting>

	<para>Verbindungen mit Fehlerkorrektur (V.42, MNP) verwenden die
	  Geschwindigkeit der Datenendeinrichtung.</para>

      <sect3>
	<title>Überprüfen der Modemkonfiguration</title>

	<para>Die meisten Modems verfügen über Kommandos, die die
	  Konfiguration des Modems in lesbarer Form ausgeben.  Auf einem
	  externen 14400 &usrobotics; &sportster; zeigt
	  <command>ATI5</command> die Einstellungen im nicht
	  flüchtigen RAM an.  Um die wirklichen
	  Einstellungen unter Berücksichtigung der DIP-Schalter zu
	  sehen, benutzen Sie <command>ATZ</command> gefolgt von
	  <command>ATI4</command>.</para>

	<para>Wenn Sie ein anderes Modem benutzen, schauen Sie bitte in der
	  Dokumentation des Modems nach, wie Sie die Konfiguration des
	  Modems überprüfen können.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Fehlersuche</title>

      <para>Bei Problemen können Sie die Einwählverbindung anhand
        der folgenden Punkte überprüfen:</para>

	<para>Schließen Sie das Modem an das &os;-System an und
	  booten Sie das System.  Wenn das Modem über
	  Statusindikatoren verfügt, überprüfen Sie, ob der
	  <acronym>DTR</acronym> Indikator leuchtet, wenn das Anmeldeprompt
	  erscheint.  Dies zeigt an, dass das &os;-System einen
	  <command>getty</command> Prozess auf der entsprechenden
	  Schnittstelle gestartet hat und das Modem auf einkommende
	  Verbindungen wartet.</para>

	<para>Wenn der <acronym>DTR</acronym>-Indikator nicht leuchtet,
	  melden Sie sich an dem &os;-System an und überprüfen mit
	  <command>ps ax</command>, ob &os; einen
	  <command>getty</command>-Prozess auf der entsprechenden
	  Schnittstelle gestartet hat:</para>

	<screen>  114 ??  I      0:00.10 /usr/libexec/getty V19200 ttyu0
  115 ??  I      0:00.10 /usr/libexec/getty V19200 ttyu1</screen>

	<para>Wenn das Modem noch keinen Anruf entgegengenommen hat und Sie
	  stattdessen die folgende Zeile sehen</para>

	  <screen>  114 d0  I      0:00.10 /usr/libexec/getty V19200 ttyu0</screen>

	<para>bedeutet dies, dass <command>getty</command> die
	  Schnittstelle schon geöffnet hat und zeigt Kabelprobleme
	  oder eine falsche Modemkonfiguration an, da
	  <command>getty</command> die Schnittstelle erst dann öffnen
	  kann, wenn das <acronym>CD</acronym> Signal (Carrier Detect) vom
	  Modem anliegt.</para>

	<para>Wenn Sie keine <command>getty</command>-Prozesse auf den
	  gewünschten <filename>ttyu<replaceable>N</replaceable></filename>
	  Ports finden, untersuchen Sie <filename>/etc/ttys</filename>
	  auf Fehler.  Suchen Sie auch in <filename>/var/log/messages</filename>
	  nach Meldungen von <command>init</command> oder
	  <command>getty</command>.  Wenn Sie dort Meldungen finden,
	  sollten Sie noch einmal die beiden Konfigurationsdateien
	  <filename>/etc/ttys</filename> und <filename>/etc/gettytab</filename>
	  nach Fehlern durchsehen.  Überprüfen Sie auch, ob die
	  Gerätedateien
	  <filename>/dev/ttyu<replaceable>N</replaceable></filename>
	  vorhanden sind.</para>

	<para>Versuchen Sie als nächstes, sich in das System
	  einzuwählen.  Auf dem
	  entfernten System stellen Sie bitte die folgenden
	  Kommunikationsparameter ein: 8&nbsp;Bit, keine Parität, ein
	  Stop-Bit.  Wenn kein Anmeldeprompt erscheint oder nur
	  unleserliche Zeichen, drücken Sie mehrmals, in
	  Abständen von ungefähr einer Sekunde,
	  <keycap>Enter</keycap>.  Wenn Sie immer noch nicht die
	  <prompt>login:</prompt> Meldung sehen, schicken Sie ein
	  <command>BREAK</command> Kommando.  Wenn Sie zur Einwahl ein
	  Highspeed-Modem benutzen, verwenden Sie eine feste
	  Geschwindigkeit auf der seriellen Schnittstelle des
	  Modems.</para>

	<para>Wenn jetzt immer noch kein Anmeldeprompt erscheint,
	  überprüfen Sie nochmals <filename>/etc/gettytab</filename>
	  und stellen sicher, dass:</para>

	<itemizedlist>
	  <listitem>
	    <para>der Verbindungstyp in <filename>/etc/ttys</filename> zu
	      einem gültigen Eintrag in <filename>/etc/gettytab</filename>
	      gehört.</para>
	  </listitem>

	  <listitem>
	    <para>jeder der <literal>nx=</literal> Einträge in
	      <filename>gettytab</filename> gültig ist und</para>
	  </listitem>

	  <listitem>
	    <para>jeder <literal>tc=</literal> Eintrag auf einen
	      gültigen Eintrag in <filename>gettytab</filename>
	      verweist.</para>
	  </listitem>
	</itemizedlist>

	<para>Wenn das Modem am &os;-System auf einen eingehenden Anruf
	  nicht antwortet, stellen Sie sicher, dass das Modem so
	  konfiguriert ist, dass es einen Anruf beantwortet, wenn
	  <acronym>DTR</acronym> anliegt.  Wenn das Modem Statusindikatoren
	  besitzt, können Sie das Anliegen von <acronym>DTR</acronym>
	  anhand der Leuchten überprüfen.</para>

	<para>Wenn Sie alles schon mehrfach überprüft haben und
	  es immer noch noch nicht funktioniert, versuchen Sie es zu
	  einem späteren Zeitpunkt erneut.  Wenn es immer noch nicht
	  funktioniert, können Sie eine Mail an die Mailingliste
	  &a.de.questions; schicken, in der Sie Ihr Modem und Ihr
	  Problem beschreiben.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="dialout">
    <title>Verbindungen nach Außen</title>

    <para>Die folgenden Ratschläge beschreiben, wie Sie mit einem
      Modem eine Verbindung zu einem anderen Computer herstellen.  Dies
      können Sie nutzen, um sich auf einem entfernten Computer
      anzumelden.</para>

    <para>Weiterhin ist diese Art von Verbindungen nützlich, wenn
      PPP mal nicht funktioniert.  Wenn Sie zum Beispiel eine Datei
      mit FTP übertragen wollen und das über PPP gerade nicht
      möglich ist, melden Sie sich auf dem entfernten Rechner an und
      führen dort die FTP-Sitzung durch.  Die Dateien können danach
      mit zmodem auf den lokalen Rechner übertragen werden.</para>

    <sect2 xml:id="hayes-unsupported">
      <title>Ein Hayes Modem benutzen</title>

      <para>Es gibt einen eingebauten, allgemeinen Hayes Wähler in
	<command>tip</command>.  Verwenden Sie
	<literal>at=hayes</literal> in
	<filename>/etc/remote</filename>.</para>

      <para>Der Hayes-Treiber ist nicht schlau genug, um ein paar der
        erweiterten Funktionen von neueren Modems, bspw.
	<literal>BUSY</literal>, <literal>NO DIALTONE</literal> oder
	<literal>CONNECT 115200</literal> zu nutzen.  Schalten Sie
	diese Nachrichten mit Hilfe von <command>ATX0&amp;W</command>
	ab, wenn Sie <command>tip</command> benutzen.</para>

      <para>Der Anwahl-Timeout von <command>tip</command> beträgt 60
        Sekunden.  Das Modem sollte weniger verwenden, oder
	<command>tip</command> denkt, dass ein Kommunikationsfehler
	vorliegt.  Versuchen Sie es mit
	<command>ATS7=45&amp;W</command>.</para>
    </sect2>

    <sect2 xml:id="direct-at">
      <title><literal>AT</literal>-Befehle benutzen</title>

      <indexterm>
        <primary><filename>/etc/remote</filename></primary>
      </indexterm>
      <para>Erstellen Sie einen <literal>direct</literal>
        Eintrag in <filename>/etc/remote</filename>.  Wenn das Modem zum
	Beispiel an der ersten seriellen Schnittstelle,
	<filename>/dev/cuad0</filename>, angeschlossen ist, dann
	fügen Sie die folgende Zeile hinzu:</para>

      <programlisting>cuad0:dv=/dev/cuad0:br#19200:pa=none</programlisting>

      <para>Verwenden Sie die höchste bps-Rate, die das Modem in der
        <literal>br</literal> Fähigkeit unterstützt.  Geben Sie dann
	<command>tip cuad0</command> ein und Sie sind mit dem
	Modem verbunden.</para>

      <para>Oder benutzen Sie <command>cu</command> als
        <systemitem class="username">root</systemitem> mit dem folgenden Befehl:</para>

      <screen>&prompt.root; <userinput>cu -l<replaceable>line</replaceable> -s<replaceable>speed</replaceable></userinput></screen>

      <para><replaceable>line</replaceable> steht für die serielle
        Schnittstelle (<filename>/dev/cuad0</filename>) und
	<replaceable>speed</replaceable> für die Geschwindigkeit
	(<literal>57600</literal>).  Wenn Sie mit dem Eingeben der AT
	Befehle fertig sind, beenden Sie mit <command>~.</command>.</para>
    </sect2>

    <sect2 xml:id="gt-failure">
      <title>Das <literal>@</literal> Zeichen funktioniert
	nicht</title>

      <para>Das <literal>@</literal> Zeichen in der
        Telefonnummerfähigkeit sagt <command>tip</command>, dass
	es in <filename>/etc/phones</filename> nach einer Nummer
	suchen soll.  Aber <literal>@</literal> ist auch ein spezielles
	Zeichen in den Dateien, in denen Fähigkeiten beschrieben
	werden, wie <filename>/etc/remote</filename>.  Schreiben Sie es mit
	einem Backslash:</para>

      <programlisting>pn=\@</programlisting>
    </sect2>

    <sect2 xml:id="dial-command-line">
      <title>Wie kann ich von der Kommandozeile eine Telefonnummer
        wählen?</title>

      <para>Setzen Sie einen allgemeinen Eintrag in
        <filename>/etc/remote</filename>.  Zum Beispiel:</para>

      <programlisting>tip115200|Dial any phone number at 115200 bps:\
        :dv=/dev/cuad0:br#115200:at=hayes:pa=none:du:
tip57600|Dial any phone number at 57600 bps:\
        :dv=/dev/cuad0:br#57600:at=hayes:pa=none:du:</programlisting>

      <para>Folgendes sollte jetzt funktionieren:</para>

      <screen>&prompt.root; <userinput>tip -115200 5551234</userinput></screen>

      <para>Benutzer, die <command>cu</command> gegenüber
        <command>tip</command> bevorzugen, können einen allgemeinen
	<literal>cu</literal>-Eintrag verwenden:</para>

      <programlisting>cu115200|Use cu to dial any number at 115200bps:\
        :dv=/dev/cuad1:br#57600:at=hayes:pa=none:du:</programlisting>

      <para>und benutzen zum Wählen das Kommando:</para>

      <screen>&prompt.root; <userinput>cu 5551234 -s 115200</userinput></screen>
    </sect2>

    <sect2 xml:id="set-bps">
      <title>Die <acronym>bps</acronym>-Rate angeben</title>

      <para>Schreiben Sie einen <literal>tip1200</literal>- oder einen
        <literal>cu1200</literal>-Eintrag, aber geben Sie auch die
	<acronym>bps</acronym>-Rate an, die das Modem wirklich
	unterstützt.  Leider denkt &man.tip.1;, dass 1200&nbsp;bps ein
	guter Standardwert ist und deswegen sucht es nach einem
	<literal>tip1200</literal>-Eintrag.  Natürlich müssen Sie
	nicht 1200&nbsp;bps benutzen.</para>
    </sect2>

    <sect2 xml:id="terminal-server">
      <title>Über einen Terminal-Server auf verschiedene Rechner
	zugreifen</title>

      <para>Sie müssen nicht warten bis Sie verbunden sind, und
        jedes Mal
	<command>CONNECT <replaceable>Rechner</replaceable></command>
	eingeben, benutzen Sie <command>tip</command>s
	<literal>cm</literal>-Fähigkeit. Sie können diese
	Einträge in <filename>/etc/remote</filename> verwenden.
	Mit den Befehlen <command>tip pain</command> oder
	<command>tip muffin</command> können Sie eine Verbindungen zu
	den Rechnern <systemitem>pain</systemitem> oder
	<systemitem>muffin</systemitem> herstellen;  mit
	<command>tip deep13</command> verbinden Sie sich mit dem
	Terminalserver.</para>

      <programlisting>pain|pain.deep13.com|Forrester's machine:\
        :cm=CONNECT pain\n:tc=deep13:
muffin|muffin.deep13.com|Frank's machine:\
        :cm=CONNECT muffin\n:tc=deep13:
deep13:Gizmonics Institute terminal server:\
        :dv=/dev/cuad2:br#38400:at=hayes:du:pa=none:pn=5551234:</programlisting>

    </sect2>

    <sect2 xml:id="tip-multiline">
      <title>Mehr als eine Verbindung mit <command>tip</command>
	benutzen</title>

      <para>Das ist oft ein Problem, wenn eine Universität mehrere
        Telefonleitungen hat und viele tausend Studenten diese benutzen
	wollen.</para>

      <para>Erstellen Sie einen Eintrag in
      <filename>/etc/remote</filename> und benutzen Sie
      <literal>@</literal> für die
      <literal>pn</literal>-Fähigkeit:</para>

      <programlisting>big-university:\
        :pn=\@:tc=dialout
dialout:\
        :dv=/dev/cuad3:br#9600:at=courier:du:pa=none:</programlisting>

      <para>Listen Sie dann die Telefonnummern in
        <filename>/etc/phones</filename> auf:</para>

      <programlisting>big-university 5551111
big-university 5551112
big-university 5551113
big-university 5551114</programlisting>

      <para><command>tip</command> probiert jede der Nummern in der
        aufgelisteten Reihenfolge und gibt dann auf.  Möchten Sie,
        dass <command>tip</command> beim Versuchen eine Verbindung
        herzustellen nicht aufgibt, lassen Sie es in einer
	<literal>while</literal>-Schleife laufen.</para>
    </sect2>

    <sect2 xml:id="multi-controlp">
      <title>Eine Übertragung erzwingen</title>

      <para><keycombo action="simul">
	  <keycap>Ctrl</keycap>
	  <keycap>P</keycap>
	</keycombo>
	ist das voreingestellte Zeichen, mit dem eine Übertragung
	erzwungen werden kann und wird benutzt, um <command>tip</command>
	zu sagen, dass das nächste Zeichen direkt gesendet werden
	soll und nicht als Fluchtzeichen interpretiert werden soll.  Mit
	Hilfe der Fluchtsequenz <command>~s</command>, mit der man
	Variablen setzen kann, können Sie jedes andere Zeichen als
	<quote>force</quote>-Zeichen definieren.</para>

      <para>Geben Sie
	<command>~sforce=<replaceable>Zeichen</replaceable></command>
	gefolgt von <keycap>Enter</keycap> ein.  Für
	<replaceable>Zeichen</replaceable> können Sie ein beliebiges
	einzelnes Zeichen einsetzen.  Wenn Sie
	<replaceable>Zeichen</replaceable> weglassen, ist das
	<quote>force</quote>-Zeichen <quote>nul</quote>, das Sie mit
	<keycombo action="simul">
	  <keycap>Ctrl</keycap><keycap>2</keycap>
	</keycombo>
	oder
	<keycombo action="simul">
	  <keycap>Ctrl</keycap><keycap>Leertaste</keycap>
	</keycombo> eingeben können.  Ein guter Wert für
	<replaceable>Zeichen</replaceable> ist
	<keycombo action="simul">
	  <keycap>Shift</keycap>
	  <keycap>Ctrl</keycap>
	  <keycap>6</keycap>
	</keycombo>, welches nur auf wenigen Terminal Servern benutzt
	wird.</para>

      <para>Sie können das <quote>force</quote>-Zeichen auch
        bestimmen, indem Sie in <filename>&dollar;HOME/.tiprc</filename> das
        Folgende einstellen:</para>

      <programlisting>force=<replaceable>single-char</replaceable></programlisting>
    </sect2>

    <sect2 xml:id="uppercase">
      <title>Großbuchstaben</title>

      <para>Dies passiert, wenn
	<keycombo action="simul">
	  <keycap>Ctrl</keycap>
	  <keycap>A</keycap>
	</keycombo> eingegeben wurde, das <quote>raise</quote>-Zeichen von
	<command>tip</command>, das speziell für Leute mit defekten
	caps-lock Tasten eingerichtet wurde.  Benutzen Sie
	<command>~s</command> wie oben und setzen Sie die Variable
	<literal>raisechar</literal> auf etwas, das Ihnen angemessen
	erscheint.  Tatsächlich kann die Variable auf das gleiche
	Zeichen wie das <quote>force</quote>-Zeichen gesetzt werden,
	wenn diese Fähigkeiten niemals benutzt werden sollen.</para>

      <para>Hier ist ein Muster der <filename>.tiprc</filename> Datei
        für <application>Emacs</application> Benutzer, die
	<keycombo action="simul">
	  <keycap>Ctrl</keycap><keycap>2</keycap>
	</keycombo>
	und
	<keycombo action="simul">
	  <keycap>Ctrl</keycap><keycap>A</keycap>
	</keycombo>
	tippen müssen:</para>

      <programlisting>force=^^
raisechar=^^</programlisting>

      <para>Geben Sie für <literal>^^</literal>
	<keycombo action="simul">
	  <keycap>Shift</keycap><keycap>Ctrl</keycap><keycap>6</keycap>
	</keycombo> ein.</para>

    </sect2>

    <sect2 xml:id="tip-filetransfer">
      <title>Dateien mit <command>tip</command> übertragen</title>

      <para>Wenn Sie mit einem anderen &unix; System kommunizieren,
        können Sie mit <command>~p</command> (put) und
	<command>~t</command> (take) Dateien senden und empfangen.  Diese
	Befehle lassen <command>cat</command> und <command>echo</command>
	auf dem entfernten System laufen, um Dateien zu empfangen und zu
	senden.  Die Syntax ist:</para>

      <cmdsynopsis>
	<command>~p</command>
	<arg choice="plain">local-file</arg>
	<arg choice="opt">remote-file</arg>
      </cmdsynopsis>

      <cmdsynopsis>
	<command>~t</command>
	<arg choice="plain">remote-file</arg>
	<arg choice="opt">local-file</arg>
      </cmdsynopsis>

      <para>Es gibt keine Fehlerkontrolle, deshalb sollte besser ein
        anderes Protokoll, wie zmodem, benutzt werden.</para>
    </sect2>

    <sect2 xml:id="zmodem-tip">
      <title><application>zmodem</application> mit
	<command>tip</command> benutzen</title>

      <para>Um Dateien zu empfangen, starten Sie das Programm zum Senden
        auf dem entfernten Computer.  Geben Sie dann
	<command>~C rz</command> ein, um die Dateien lokal zu empfangen.</para>

      <para>Um Dateien zu senden, starten Sie das Programm zum Empfangen
        auf dem entfernten Computer.  Geben Sie dann
	<command>~C sz <replaceable>Dateien</replaceable></command> ein,
	um Dateien auf das entfernte System zu senden.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="serialconsole-setup">
    <info>
    <title>Einrichten der seriellen Konsole</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Kazutaka</firstname>
	    <surname>YOKOTA</surname>
	  </personname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <personname>
	    <firstname>Bill</firstname>
	    <surname>Paul</surname>
	  </personname>
	  <contrib>Based on a document by </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm><primary>serielle Konsole</primary></indexterm>

      <para>&os; kann ein System mit einem Dumb-Terminal
	(unintelligente Datenstation) an einer seriellen
	Schnittstelle als Konsole booten.  Diese Konfiguration ist
	besonders nützlich für Systemadministratoren, die &os; auf
	Systemen ohne Tastatur oder Monitor installieren wollen, und
	Entwickler, die den Kernel oder Gerätetreiber debuggen.</para>

      <para>Wie in <xref linkend="boot"/> beschrieben, besitzt &os;
	drei Bootphasen.  Der Code für die ersten beiden Bootphasen
	befindet sich im Bootsektor am Anfang der &os;-Slice der
	Bootplatte.  Dieser Bootblock lädt den Bootloader in Phase
	drei.</para>

      <para>Um eine serielle Konsole einzurichten, muss der
        Bootblock, der Bootloader und der Kernel konfiguriert
	werden.</para>

    <sect2 xml:id="serialconsole-howto-fast">
      <title>Schnelle Konfiguration der seriellen Konsole</title>

      <para>Dieser Abschnitt bietet einen schnellen Überblick über die
	Einrichtung einer seriellen Konsolen.  Es wird vorausgesetzt,
	dass die Voreinstellungen verwendet werden.</para>

      <procedure>
	<step>
	  <para>Verbinden Sie die serielle Konsole mit
	    <filename>COM1</filename> sowie dem Kontrollterminal.</para>
	</step>

	<step>
	  <para>Um die Startmeldungen der seriellen Konsole zu sehen,
	    geben Sie als <systemitem
	      class="username">root</systemitem> folgendes ein:</para>

	  <screen>&prompt.root; echo 'console="comconsole"' &gt;&gt; /boot/loader.conf</screen>
	</step>

	<step>
	  <para>Ändern Sie in <filename>/etc/ttys</filename>
	    den Eintrag für <filename>ttyu0</filename> von
	    <literal>off</literal> auf <literal>on</literal>.
	    Zusätzlich sollten Sie den Wert
	    <literal>dialup</literal> auf <literal>vt100</literal>
	    ändern.  Nur so wird auf der seriellen Konsole
	    eine Eingabeaufforderung mit einer Passwortabfrage
	    aktiviert.</para>
	</step>

	<step>
	  <para>Starten Sie nun das System neu, damit die serielle
	    Konsole aktiviert wird.</para>
	</step>
      </procedure>

      <para>Wenn Sie eine unterschiedliche Konfiguration benötigen,
	lesen Sie den nächsten Abschnitt für eine tiefer gehende
	Erklärung.</para>
    </sect2>

    <sect2 xml:id="serialconsole-howto">
      <title>Konfiguration der seriellen Konsole</title>

      <procedure>
	<step>
	  <para>Bereiten Sie ein serielles Kabel vor.</para>

	  <indexterm><primary>Nullmodemkabel</primary></indexterm>

	  <para>Sie benötigen entweder ein Nullmodemkabel oder ein
	    serielles Standard Kabel mit einem Nullmodemkabel-Adapter.
	    In <xref linkend="term-cables-null"/> werden serielle
	    Kabel beschrieben.</para>
	</step>

	<step>
	  <para>Trennen Sie die Tastatur vom Computer.</para>

	  <para>Viele PC Systeme suchen beim Power On Self Test
	    (<acronym>POST</acronym>) nach einer Tastatur und geben
	    eine Fehlermeldung aus, wenn sie keine finden.  Einige
	    Maschinen werden sich sogar weigern, ohne Tastatur zu
	    booten.</para>

	  <para>Wenn der Rechner trotz einer Fehlermeldung normal
	    weiterbootet, brauchen Sie weiter nichts zu tun.</para>

	  <para>Wenn das System ohne Tastatur nicht booten will,
	    müssen Sie das BIOS so konfigurieren, dass es diesen Fehler
	    ignoriert (wenn das möglich ist).  Das Handbuch zum
	    Motherboard sollte beschreiben, wie das zu bewerkstelligen
	    ist.</para>

	  <tip>
	    <para>Selbst wenn Sie im BIOS <quote>Not installed</quote>
	      für die Tastatur einstellen, können Sie eine
	      Tastatur angeschlossen haben und diese auch weiterhin
	      benutzen, da sie mit dieser Anweisung das BIOS
	      lediglich anweisen, nach dem Einschalten des Rechners nicht
	      nach einer Tastatur zu suchen und den Rechner ohne
	      entsprechende Fehlermeldung zu starten.  Wenn die oben
	      beschriebene Option nicht im BIOS vorhanden ist, halten Sie
	      stattdessen Ausschau nach einer <quote>Halt on Error</quote>
	      Option.  Sie können den gleichen Effekt wie oben erzielen,
	      wenn Sie diese Option auf <quote>All but Keyboard</quote> oder
	      sogar <quote>No Errors</quote> setzen.</para>
	  </tip>

	  <note>
	    <para>Wenn das System über eine &ps2; Maus verfügt,
	      müssen Sie diese wahrscheinlich auch abziehen.  Da sich
	      die &ps2; Maus und die Tastatur einige Hardwarekomponenten
	      teilen, kann das dazu führen, dass die
	      Hardwareerkennung fälschlicherweise eine Tastatur findet,
	      wenn eine &ps2; Maus angeschlossen ist.</para>
	  </note>
	</step>

	<step>
	  <para>Schließen Sie einen Dumb-Terminal an
	    <filename>COM1</filename> (<filename>sio0</filename>)
	    an.</para>

	  <para>Wenn Sie keinen Dumb-Terminal besitzen, können Sie
	    einen alten Computer mit einem Terminalemulator oder die
	    serielle Schnittstelle eines anderen &unix; Rechners
	    benutzen.  Sie benötigen auf jeden Fall eine freie erste
	    serielle Schnittstelle (<filename>COM1</filename>).
	    Zurzeit ist es nicht möglich, in den Bootblöcken eine
	    andere Schnittstelle zu konfigurieren, ohne diese neu zu kompilieren.
	    Wenn Sie <filename>COM1</filename> bereits für ein
	    anderes Gerät benutzen, müssen Sie dieses Gerät
	    temporär entfernen und einen neuen Bootblock sowie Kernel
	    installieren, wenn &os; erst einmal installiert
	    ist.</para>
	</step>

	<step>
	  <para>Stellen Sie sicher, dass die Kernelkonfiguration die
	    richtigen Optionen für <filename>COM1</filename>
	    (<filename>sio0</filename>) enthält.</para>

	  <para>Relevante Optionen sind:</para>

	  <variablelist>
	    <varlistentry>
	      <term><literal>0x10</literal></term>

	      <listitem>
		<para>Aktiviert die Konsolenunterstützung für
		  dieses Gerät.  Zurzeit kann nur ein Gerät die
		  Konsolenunterstützung aktiviert haben.  Das erste,
		  in der Konfigurationsdatei aufgeführte Gerät,
		  mit dieser Option, verfügt über eine aktivierte
		  Konsolenunterstützung.  Beachten Sie, dass
		  diese Option alleine nicht ausreicht, um die serielle
		  Konsole zu aktivieren.  Setzen Sie entweder noch die
		  nachfolgend diskutierte Option oder verwenden Sie beim
		  Booten, wie unten beschrieben, den Schalter
		  <option>-h</option>.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><literal>0x20</literal></term>

	      <listitem>
		<para>Das erste Gerät in der Kernelkonfigurationsdatei
		  mit dieser Option wird, unabhängig von dem unten
		  diskutierten Schalter <option>-h</option>, zur Konsole.
		  Die Option <option>0x20</option> muss zusammen mit
		  <option>0x10</option> verwendet werden.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><literal>0x40</literal></term>

	      <listitem>
		<para>Reserviert dieses Gerät und sperrt es für
		  normale Zugriffe.  Sie sollten diese Option nicht auf dem
		  Gerät setzen, das Sie als serielle Konsole verwenden
		  wollen.  Der Zweck dieser Option ist es, dieses
		  Gerät für das Remote-Debuggen zu reservieren.
		  Das <link xlink:href="&url.books.developers-handbook.en;/index.html">
		    FreeBSD Developers' Handbook</link> enthält dazu weitere
		  Informationen.</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>

	  <para>Beispiel:</para>

	  <programlisting>device sio0 at isa? port IO_COM1 tty flags 0x10 irq 4</programlisting>

	  <para>Weitere Einzelheiten finden Sie in
	    &man.sio.4;.</para>

	  <para>Wenn diese Optionen nicht gesetzt sind, müssen Sie auf
	    einer anderen Konsole beim Booten UserConfig starten oder den
	    Kernel neu kompilieren.</para>
	</step>

	<step>
	  <para>Erstellen Sie <filename>boot.config</filename> im
	    Rootverzeichnis der <literal>a</literal>-Partition des
	    Bootlaufwerks.</para>

	  <para>Der Code des Bootblocks entnimmt dieser Datei, wie Sie Ihr
	    System booten möchten.  Um die serielle Konsole zu
	    aktivieren, müssen Sie hier eine oder mehrere Optionen
	    (alle in derselben Zeile) angeben.  Die folgenden Optionen
	    stehen zur Auswahl der Konsole zur Verfügung:</para>

	  <variablelist>
	    <varlistentry>
	      <term><option>-h</option></term>

	      <listitem>
		<para>Schaltet zwischen der internen und der seriellen
		  Konsole um.  Wenn Sie beispielsweise von der internen
		  Konsole (Bildschirm) booten, weist <option>-h</option>
		  den Bootloader und den Kernel an, die serielle
		  Schnittstelle als Konsole zu nehmen.  Wenn die Konsole
		  normal auf der seriellen Schnittstelle liegt, wählen
		  Sie mit <option>-h</option> den Bildschirm aus.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><option>-D</option></term>

	      <listitem>
		<para>Schaltet zwischen Einzelkonsole und Dual-Konsole um.
		  Die Einzelkonsole ist entweder die interne Konsole
		  (der Bildschirm) oder die serielle Schnittstelle, je nach
		  dem Stand von <option>-h</option>.  Im
		  Dual-Konsolen Betrieb ist die Konsole, unabhängig
		  von <option>-h</option>, gleichzeitig der Bildschirm und
		  die serielle Schnittstelle.  Dies trifft aber nur zu,
		  wenn der Bootblock ausgeführt wird.  Sobald der
		  Bootloader ausgeführt wird, wird die durch
		  <option>-h</option> gegebene Konsole die alleinige
		  Konsole.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><option>-P</option></term>

	      <listitem>
		<para>Veranlasst den Bootblock nach einer Tastatur zu
		  suchen.  Wenn keine Tastatur gefunden wird, werden
		  <option>-D</option> und <option>-h</option> automatisch
		  gesetzt.</para>

		<note>
		  <para>Wegen Platzbeschränkungen in den
		    Bootblöcken kann <option>-P</option> nur
		    erweiterte Tastaturen erkennen.  Tastaturen mit weniger
		    als 101 Tasten und ohne F11 und F12 Tasten werden
		    wahrscheinlich, wie vielleicht auch die Tastaturen
		    einiger Laptops, nicht erkannt.  Wenn das der
		    Fall ist, können Sie <option>-P</option>
		    nicht verwenden, da es leider keine Abhilfe
		    für dieses Problem gibt.</para>
		</note>
	      </listitem>
	    </varlistentry>
	  </variablelist>

	  <para>Benutzen Sie also entweder <option>-P</option>, um die
	    Konsole automatisch zu setzen, oder <option>-h</option>, um die
	    serielle Konsole zu verwenden.</para>

	  <para>Weitere Optionen werden in &man.boot.8;
	    beschrieben.</para>

	  <para>Mit Ausnahme von <option>-P</option> werden die
	    Optionen an den Bootloader weitergegeben.  Der Bootloader
	    untersucht dann einzig <option>-h</option> um
	    festzustellen, welches Gerät die Konsole wird.  Wenn Sie
	    also nur <option>-D</option> angegeben haben, können Sie
	    die serielle Schnittstelle nur als Konsole verwenden
	    während der Bootblock ausgeführt wird.  Danach wird der
	    Bootloader, da ja <option>-h</option> fehlt, den
	    Bildschirm zur Konsole machen.</para>
	</step>

	<step>
	  <para>Booten Sie die Maschine.</para>

	  <para>Wenn Sie das &os;-System starten, werden die
	    Bootblöcke den Inhalt von <filename>/boot.config</filename>
	    auf der Konsole ausgeben:</para>

	  <screen>/boot.config: -P
Keyboard: no</screen>

	  <para>Die zweite Zeile sehen Sie nur, wenn Sie in
	    <filename>/boot.config</filename> <option>-P</option> angegeben
	    haben.  Sie zeigt an, ob eine Tastatur angeschlossen ist oder
	    nicht.  Die Meldungen gehen je nach den Einstellungen in
	    <filename>/boot.config</filename> auf die interne Konsole, die
	    serielle Konsole, oder beide Konsolen.</para>

	  <informaltable frame="none" pgwide="1">
	    <tgroup cols="2">
	      <thead>
		<row>
		  <entry align="left">Optionen</entry>
		  <entry align="left">Meldungen erscheinen auf</entry>
		</row>
	      </thead>

	      <tbody>
		<row>
		  <entry>keine</entry>
		  <entry>der internen Konsole</entry>
		</row>

		<row>
		  <entry><option>-h</option></entry>
		  <entry>der seriellen Konsole</entry>
		</row>

		<row>
		  <entry><option>-D</option></entry>
		  <entry>der seriellen und der internen Konsole</entry>
		</row>

		<row>
		  <entry><option>-Dh</option></entry>
		  <entry>der seriellen und der internen Konsole</entry>
		</row>

		<row>
		  <entry><option>-P</option>, mit Tastatur</entry>
		  <entry>der internen Konsole</entry>
		</row>

		<row>
		  <entry><option>-P</option>, ohne Tastatur</entry>
		  <entry>der seriellen Konsole</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </informaltable>

	  <para>Nach den oben gezeigten Meldungen gibt es eine kleine
	    Verzögerung bevor die Bootblöcke den Bootloader
	    laden und weitere Meldungen auf der Konsole erscheinen.  Sie
	    können die Ausführung der Bootblöcke
	    unterbrechen, um zu überprüfen, ob auch alles richtig
	    aufgesetzt ist, brauchen das aber unter normalen Umständen
	    nicht zu tun.</para>

	  <para>Drücken Sie eine Taste außer
	    <keycap>Enter</keycap> um den Bootvorgang zu unterbrechen.  Sie
	    erhalten dann ein Prompt, an dem Sie weitere Eingaben
	    tätigen können:</para>

	  <screen>&gt;&gt; FreeBSD/i386 BOOT
Default: 0:ad(0,a)/boot/loader
boot:</screen>

	  <para>Je nach Inhalt von <filename>/boot.config</filename>
	    erscheint das Prompt auf der seriellen Konsole, der internen
	    Konsole oder beiden Konsolen.  Wenn die Meldung auf der
	    richtigen Konsole erscheint, drücken Sie
	    <keycap>Enter</keycap> um fortzufahren.</para>

	  <para>Wenn kein Prompt auf der seriellen Konsole erscheint,
	    liegt ein Fehler in den Einstellungen vor.  Als Abhilfe
	    geben Sie an der momentanen Konsole <option>-h</option>
	    ein, um den Bootblock und den Bootloader auf die serielle
	    Konsole umzustellen.  Führen Sie dann den Bootvorgang mit
	    <keycap>Enter</keycap> weiter und wenn das System gebootet
	    hat, können Sie die fehlerhaften Einstellungen
	    korrigieren.</para>
	</step>
      </procedure>

      <para>Während der dritten Bootphase können Sie immer noch
	zwischen der internen und der seriellen Konsole auswählen.
	Setzen Sie dazu, wie in <xref linkend="serialconsole-loader"/>
	beschrieben, die entsprechenden Variablen des
	Bootloaders.</para>
    </sect2>

    <sect2 xml:id="serialconsole-summary">
      <title>Zusammenfassung</title>

      <para>Die folgende Tabelle bietet eine Zusammenfassung der
	verschiedenen Einstellungen, die in diesem Abschnitt
	diskutiert wurden:</para>

      <table frame="none" pgwide="1">
	<title>Fall 1: Option 0x10 für
	  <filename>sio0</filename></title>

	  <tgroup cols="4">
	    <thead>
	      <row>
		<entry align="left">Optionen in <filename>/boot.config</filename></entry>
		<entry align="left">Konsole in den Bootblöcken</entry>
		<entry align="left">Konsole im Bootloader</entry>
		<entry align="left">Konsole im Kernel</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry>keine</entry>
		<entry>interne</entry>
		<entry>interne</entry>
		<entry>interne</entry>
	      </row>

	      <row>
		<entry><option>-h</option></entry>
		<entry>serielle</entry>
		<entry>serielle</entry>
		<entry>serielle</entry>
	      </row>

	      <row>
		<entry><option>-D</option></entry>
		<entry>serielle und interne</entry>
		<entry>interne</entry>
		<entry>interne</entry>
	      </row>

	      <row>
		<entry><option>-Dh</option></entry>
		<entry>serielle und interne</entry>
		<entry>serielle</entry>
		<entry>serielle</entry>
	      </row>

	      <row>
		<entry><option>-P</option>, mit Tastatur</entry>
		<entry>interne</entry>
		<entry>interne</entry>
		<entry>interne</entry>
	      </row>

	      <row>
		<entry><option>-P</option>, ohne Tastatur</entry>
		<entry>serielle und interne</entry>
		<entry>serielle</entry>
		<entry>serielle</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>

      <table frame="none" pgwide="1">
	<title>Fall 2: Option 0x30 für
	  <filename>sio0</filename></title>

	  <tgroup cols="4">
	    <thead>
	      <row>
		<entry align="left">Optionen in <filename>/boot.config</filename></entry>
		<entry align="left">Konsole in den Bootblöcken</entry>
		<entry align="left">Konsole im Bootloader</entry>
		<entry align="left">Konsole im Kernel</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry>keine</entry>
		<entry>interne</entry>
		<entry>interne</entry>
		<entry>serielle</entry>
	      </row>

	      <row>
		<entry><option>-h</option></entry>
		<entry>serielle</entry>
		<entry>serielle</entry>
		<entry>serielle</entry>
	      </row>

	      <row>
		<entry><option>-D</option></entry>
		<entry>serielle und interne</entry>
		<entry>interne</entry>
		<entry>serielle</entry>
	      </row>

	      <row>
		<entry><option>-Dh</option></entry>
		<entry>serielle und interne</entry>
		<entry>serielle</entry>
		<entry>serielle</entry>
	      </row>

	      <row>
		<entry><option>-P</option>, mit Tastatur</entry>
		<entry>interne</entry>
		<entry>interne</entry>
		<entry>serielle</entry>
	      </row>

	      <row>
		<entry><option>-P</option>, ohne Tastatur</entry>
		<entry>serielle und interne</entry>
		<entry>serielle</entry>
		<entry>serielle</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>
    </sect2>

    <sect2 xml:id="serialconsole-tips">
      <title>Hinweise zur seriellen Konsole</title>

      <sect3>
	<title>Verwenden einer höheren Geschwindigkeit</title>

	<para>Die Vorgabewerte für die Kommunikationsparameter der
	  seriellen Schnittstelle sind: 9600&nbsp;baud, 8&nbsp;Bit, keine
	  Parität und ein Stopp-Bit.  Um die Standardgeschwindigkeit
	  zu ändern, stehen folgende Möglichkeiten zur
	  Verfügung:</para>

	<itemizedlist>
	  <listitem>
	    <para>Geben Sie die neue Konsolengeschwindigkeit mit
	      <varname>BOOT_COMCONSOLE_SPEED</varname> an und
	      kompilieren Sie die Bootblöcke neu.  Ausführliche
	      Informationen zum Bau und zur Installation von neuen
	      Bootblöcken finden Sie im
	      <xref linkend="serialconsole-com2"/> des Handbuchs.</para>

	    <para>Wenn die serielle Konsole nicht mit der Option
	      <option>-h</option> gestartet wird,
	      oder wenn die verwendete serielle Konsole sich von
	      der von den Bootblöcken verwendeten unterscheidet,
	      müsssen Sie zusätzlich die folgende Option in
	      die Kernelkonfigurationsdatei aufnehmen und den Kernel
	      neu bauen:</para>

	    <programlisting>options CONSPEED=19200</programlisting>
	  </listitem>

	  <listitem>
	    <para>Verwenden Sie die Option <option>-S</option>, um den
	      Kernel zu booten.  Eine Beschreibung dieses Vorgangs
	      sowie eine Auflistung der von
	      <filename>/boot.config</filename> unterstützten Optionen
	      finden Sie in &man.boot.8;.</para>
	  </listitem>

	  <listitem>
	    <para>Aktivieren Sie die Option
	      <varname>comconsole_speed</varname> in
	      <filename>/boot/loader.conf</filename>.</para>

	    <para>Diese Option setzt voraus, dass auch die Optionen
	      <varname>console</varname>,
	      <varname>boot_serial</varname>, sowie
	      <varname>boot_multicons</varname> in
	      <filename>/boot/loader.conf</filename> gesetzt sind.
	      Im Folgenden finden Sie ein Beispiel, in dem
	      <varname>comconsole_speed</varname> verwendet wird,
	      um die Geschwindigkeit der seriellen Konsole zu
	      ändern:</para>

	    <programlisting>boot_multicons="YES"
boot_serial="YES"
comconsole_speed="115200"
console="comconsole,vidconsole"</programlisting>
	  </listitem>
	</itemizedlist>
      </sect3>

      <sect3 xml:id="serialconsole-com2">
	<title>Eine andere Schnittstelle als <filename>sio0</filename>
	  benutzen</title>

	<para>Wenn Sie, warum auch immer, ein anderes Gerät als
	  <filename>sio0</filename> für die serielle Konsole
	  einsetzen wollen, kompilieren Sie bitte die Bootblöcke, den
	  Bootloader und den Kernel nach dem folgenden Verfahren
	  neu.</para>

	<procedure>
	  <step>
	    <para>Installieren Sie die Kernelquellen wie im
	      <xref linkend="updating-upgrading"/> beschrieben.</para>
	  </step>

	  <step>
	    <para>Setzen Sie in <filename>/etc/make.conf</filename>
	      <literal>BOOT_COMCONSOLE_PORT</literal> auf die Adresse der
	      Schnittstelle (0x3F8, 0x2F8, 0x3E8 oder 0x2E8), die Sie
	      benutzen möchten.  Sie können nur
	      <filename>sio0</filename> bis
	      <filename>sio3</filename> (<filename>COM1</filename>
	      bis <filename>COM4</filename>) benutzen, Multiportkarten
	      können Sie nicht als Konsole benutzen.  Interrupts
	      müssen Sie hier nicht angeben.</para>
	  </step>

	  <step>
	    <para>Erstellen Sie eine angepasste Kernelkonfiguration
	      und geben Sie dort die richtigen Optionen für die
	      Schnittstelle, die Sie benutzen möchten, an.  Wenn Sie
	      zum Beispiel <filename>sio1</filename>
	      (<filename>COM2</filename>) zur Konsole machen wollen,
	      geben Sie dort entweder</para>

	    <programlisting>device sio1 at isa? port IO_COM2 tty flags 0x10 irq 3</programlisting>

	    <para>oder</para>

	    <programlisting>device sio1 at isa? port IO_COM2 tty flags 0x30 irq 3</programlisting>

	    <para>an.  Keine andere serielle Schnittstelle sollte als
	      Konsole definiert werden.</para>
	  </step>

	  <step>
	    <para>Übersetzen und installieren Sie die
	      Bootblöcke und den Bootloader:</para>

	    <screen>&prompt.root; <userinput>cd /sys/boot</userinput>
&prompt.root; <userinput>make clean</userinput>
&prompt.root; <userinput>make</userinput>
&prompt.root; <userinput>make install</userinput></screen>
	  </step>

	  <step>
	    <para>Bauen und installieren Sie einen neuen Kernel.</para>
	  </step>

	  <step>
	    <para>Schreiben Sie die Bootblöcke mit &man.bsdlabel.8;
	      auf die Bootplatte und booten Sie den neuen Kernel.</para>
	  </step>
	</procedure>
      </sect3>

      <sect3 xml:id="serialconsole-ddb">
	<title>DDB Debugger über die serielle Schnittstelle</title>

	<para>Wenn Sie den Kerneldebugger über eine serielle
	  Verbindung bedienen möchten, übersetzen Sie einen
	  angepassten Kernel mit den folgenden Optionen.  Das ist
	  nützlich, kann aber gefährlich sein, wenn auf der Leitung
	  falsche BREAK-Signale generiert werden.</para>

	<programlisting>options BREAK_TO_DEBUGGER
options DDB</programlisting>
      </sect3>

      <sect3>
	<title>Benutzung der seriellen Konsole zum Anmelden</title>

	<para>Da Sie schon die Bootmeldungen auf der Konsole verfolgen
	  können und den Kerneldebugger über die Konsole bedienen
	  können, wollen Sie sich vielleicht auch an der Konsole
	  anmelden.</para>

	<para>Öffnen Sie <filename>/etc/ttys</filename> in einem
	  Editor und suchen Sie nach den folgenden Zeilen:</para>

      <programlisting>ttyu0 "/usr/libexec/getty std.9600" unknown off secure
ttyu1 "/usr/libexec/getty std.9600" unknown off secure
ttyu2 "/usr/libexec/getty std.9600" unknown off secure
ttyu3 "/usr/libexec/getty std.9600" unknown off secure</programlisting>

	<para><filename>ttyu0</filename> bis <filename>ttyu3</filename>
	  entsprechen <filename>COM1</filename> bis
	  <filename>COM4</filename>.  Ändern Sie für die
	  entsprechende Schnittstelle <literal>off</literal> zu
	  <literal>on</literal>.  Wenn Sie auch die Geschwindigkeit der
	  seriellen Schnittstelle geändert haben, müssen Sie
	  <literal>std.9600</literal> auf die momentane
	  Geschwindigkeit anpassen.</para>

	<para>Auch kann den Terminaltyp von
	  <literal>unknown</literal> auf den tatsächlich verwendeten
	  Terminal gesetzt werden.</para>

	<para>Damit die Änderungen wirksam werden,
	  müssen Sie noch <command>kill -HUP 1</command>
	  absetzen.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="serialconsole-loader">
      <title>Die Konsole im Bootloader ändern</title>

      <para>In den vorigen Abschnitten wurde beschrieben, wie Sie die
        serielle Konsole durch Änderungen im Bootblock aktivieren.
	Dieser Abschnitt zeigt, wie Sie mit Kommandos und
	Umgebungsvariablen die Konsole im Bootloader definieren.  Da der
	Bootloader die dritte Phase im Bootvorgang ist und nach den
	Bootblöcken ausgeführt wird, überschreiben
	seine Einstellungen die des Bootblocks.</para>

      <sect3>
	<title>Festlegen der Konsole</title>

	<para>Mit einer einzigen Zeile in
	  <filename>/boot/loader.conf</filename> können Sie den
	  Bootloader und den Kernel anweisen, die serielle Schnittstelle
	  zur Konsole zu machen:</para>

	<programlisting>console="comconsole"</programlisting>

	<para>Unabhängig von den Einstellungen im Bootblock legt dies
	  die Konsole fest.</para>

	<para>Die obige Zeile sollte die erste Zeile in
	  <filename>/boot/loader.conf</filename> sein, so dass die
	  Bootmeldungen so früh wie möglich auf der Konsole zu sehen
	  sind.</para>

	<para>Analog können Sie die interne Konsole verwenden:</para>

	<programlisting>console="vidconsole"</programlisting>

	<para>Wenn die Umgebungsvariable <envar>console</envar> nicht
	  gesetzt ist, bestimmt der Bootloader und damit auch der
	  Kernel, die Konsole über die <option>-h</option> Option des
	  Bootblocks.</para>

	<para>Die Bootkonsole kann in
	  <filename>/boot/loader.conf.local</filename> oder
	  <filename>/boot/loader.conf</filename> angegeben
	  werden.</para>

	<para>Weitere Informationen erhalten Sie in &man.loader.conf.5;.</para>

	<note>
	  <para>Momentan gibt es im Bootloader nichts vergleichbares zu
	    <option>-P</option> im Bootblock.  Damit kann die Konsole nicht
	    automatisch über das Vorhandensein einer Tastatur
	    festgelegt werden.</para>
	</note>
      </sect3>

      <sect3>
	<title>Eine andere Schnittstelle als <filename>sio0</filename>
	  benutzen</title>

	<para>Der Bootloader muss neu kompiliert werden, wenn eine
	  andere Schnittstelle als <filename>sio0</filename> benutzt
	  werden soll.  Folgen Sie der Anleitung aus
	  <xref linkend="serialconsole-com2"/>.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="serialconsole-caveats">
      <title>Vorbehalte</title>

      <para>Obwohl es die meisten Systeme erlauben, ohne Tastatur zu
	booten, gibt es nur wenige Systeme, die ohne eine Grafikkarte
	booten.  Maschinen mit einem AMI BIOS können ohne Grafik
	booten, indem Sie den Grafikadapter im CMOS-Setup auf
	<literal>Not installed</literal> setzen.</para>

      <para>Viele Maschinen unterstützen diese Option allerdings nicht.
        Damit diese Maschinen booten, müssen sie über eine
	Grafikkarte, auch wenn es nur eine alte Monochromkarte ist,
	verfügen.  Allerdings brauchen Sie keinen Monitor an die Karte
	anzuschließen.  Sie können natürlich auch
	versuchen, auf diesen Maschinen ein AMI BIOS zu
	installieren.</para>
    </sect2>
  </sect1>
</chapter>
