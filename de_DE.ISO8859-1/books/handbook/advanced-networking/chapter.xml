<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde:$
     basiert auf: r51703
-->
<chapter xmlns="http://docbook.org/ns/docbook"
  xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0"
  xml:id="advanced-networking">

  <info>
    <title>Weiterführende Netzwerkthemen</title>

    <authorgroup>
      <author>
	<personname>
	  <firstname>Johann</firstname>
	  <surname>Kois</surname>
	</personname>
	<contrib>Übersetzt von </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	<personname>
	  <firstname>Björn</firstname>
	  <surname>Heidotting</surname>
	</personname>
	<contrib>Überarbeitet von </contrib>
      </author>
    </authorgroup>
  </info>

  <sect1 xml:id="advanced-networking-synopsis">
    <title>Übersicht</title>

    <para>Dieses Kapitel beschreibt verschiedene
      weiterführende Netzwerkthemen.</para>

    <para>Nachdem Sie dieses Kapitel gelesen haben, werden Sie</para>

    <itemizedlist>
      <listitem>
	<para>Die Grundlagen von Gateways und Routen kennen.</para>
      </listitem>

      <listitem>
	<para>Wissen, wie man USB Tethering einrichtet.</para>
      </listitem>

      <listitem>
	<para>&bluetooth;- sowie drahtlose, der Norm
	  &ieee;&nbsp;802.11 entsprechende, Geräte mit &os; verwenden
	  können.</para>
      </listitem>

      <listitem>
	<para>Eine Bridge unter &os; einrichten können.</para>
      </listitem>

      <listitem>
	<para>Wissen, wie man mithilfe von <acronym>PXE</acronym> über
	  ein Netzwerk von einem <acronym>NFS</acronym>
	  Root-Dateisystem bootet.</para>
      </listitem>

      <listitem>
	<para>IPv6 auf einem &os;-Rechner einrichten
	  können.</para>
      </listitem>

      <listitem>
	<para>Das Common Address Redundancy Protocol
	  (<acronym>CARP</acronym>) unter &os; einsetzen
	  können.</para>
      </listitem>

      <listitem>
	<para>Wissen, wie <acronym>VLAN</acronym>s unter &os;
	  konfiguriert werden.</para>
      </listitem>
    </itemizedlist>

    <para>Bevor Sie dieses Kapitel lesen, sollten Sie</para>

    <itemizedlist>
      <listitem>
	<para>Die Grundlagen der <filename>/etc/rc</filename>-Skripte
	  verstanden haben.</para>
      </listitem>

      <listitem>
	<para>Mit der grundlegenden Netzwerkterminologie vertraut
	  sein.</para>
      </listitem>

      <listitem>
	<para>Einen neuen &os;-Kernel konfigurieren und installieren
	  können (<xref linkend="kernelconfig"/>).</para>
      </listitem>

      <listitem>
	<para>Wissen, wie man zusätzliche Software von
	  Drittherstellern installiert
	  (<xref linkend="ports"/>).</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 xml:id="network-routing">
    <info>
      <title>Gateways und Routen</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Coranth</firstname>
	    <surname>Gryphon</surname>
	  </personname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>Routing</primary>
    </indexterm>

    <indexterm>
      <primary>Gateway</primary>
    </indexterm>

    <indexterm>
      <primary>Subnetz</primary>
    </indexterm>

    <para>Der Mechanismus mit dem ein Rechner einen Rechner über ein
      Netzwerk finden kann, wird als <firstterm>Routing</firstterm>
      bezeichnet.  Eine <quote>Route</quote> besteht aus einem
      definierten Adresspaar: Einem <quote>Ziel</quote> und einem
      <quote>Gateway</quote>.  Die Route zeigt an, dass Pakete über
      das <emphasis>Gateway</emphasis> zum <emphasis>Ziel</emphasis>
      gelangen können.  Es gibt drei Arten von Zielen: Einzelne
      Rechner (Hosts), Subnetze und das <quote>Standard</quote>ziel.
      Die <quote>Standardroute</quote>
      wird verwendet, wenn keine andere Route zutrifft.  Außerdem gibt
      es drei Arten von Gateways: Einzelne Rechner
      (Hosts), Schnittstellen (Interfaces, auch als
      <quote>Links</quote> bezeichnet), sowie Ethernet
      Hardware-Adressen (<acronym>MAC</acronym>).  Bekannte Adressen
      werden in einer Routingtabelle gespeichert.</para>

    <para>Dieser Abschnitt bietet einen Überblick über die Grundlagen
      des Routings.  Er demonstriert, wie ein &os;-System als
      Router konfiguriert werden kann und bietet einige Tipps zur
      Fehlerbehebung.</para>

    <sect2 xml:id="network-routing-default">
      <title>Grundlagen des Routings</title>

      <para>&man.netstat.1; zeigt die Routingtabellen
	eines &os;-Systems an:</para>

      <screen>&prompt.user; <userinput>netstat -r</userinput>
Routing tables

Internet:
Destination      Gateway            Flags     Refs     Use     Netif Expire
default          outside-gw         UGS        37      418       em0
localhost        localhost          UH          0      181       lo0
test0            0:e0:b5:36:cf:4f   UHLW        5    63288       re0     77
10.20.30.255     link#1             UHLW        1     2421
example.com      link#1             UC          0        0
host1            0:e0:a8:37:8:1e    UHLW        3     4601       lo0
host2            0:e0:a8:37:8:1e    UHLW        0        5       lo0 =&gt;
host2.example.com link#1            UC          0        0
224              link#1             UC          0        0</screen>

      <para>Die Einträge in diesem Beispiel sind wie folgt:</para>

      <variablelist>
	<varlistentry>
	  <term>default</term>
	  <listitem>
	    <para>Die erste Route in der Ausgabe gibt die
	      Standardroute (<literal>default</literal>) an.  Wenn
	      sich der lokale Rechner mit einem entfernten Rechner
	      verbinden will, wird die Routingtabelle überprüft, um
	      festzustellen, ob bereits ein bekannter Pfad vorhanden
	      ist.  Wird für den entfernten Rechner ein Eintrag in
	      der Routingtabelle gefunden, so prüft das System ob es
	      sich über die angegebene Schnittstelle verbinden
	      kann.</para>

	    <para>Wenn das Zielsystem mit keinem Eintrag
	      übereinstimmt, oder wenn alle bekannten Routen
	      fehlschlagen, verwendet das System die Standardroute.
	      Für die Rechner im lokalen Netzwerk ist das Feld
	      <literal>Gateway</literal> auf das System gesetzt,
	      welches direkt mit dem Internet verbunden ist.
	      <literal>UG</literal> in der Spalte
	      <literal>Flags</literal> zeigt an, dass das Gateway
	      einsatzbereit ist.</para>

	    <para>Die Standardroute für einen Rechner, der selbst als
	      Gateway zur Außenwelt fungiert, ist der Gateway-Rechner
	      des Internetanbieters (<acronym>ISP</acronym>).</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>localhost</term>
	  <listitem>
	    <para>Die zweite Route zeigt die
	      <literal>localhost</literal> Route.  Die festgelegte
	      Schnittstelle in der <literal>Netif</literal>-Spalte
	      für <literal>localhost</literal> ist
	      <literal>lo0</literal>, das auch als loopback-Gerät
	      bekannt ist.  Das bedeutet, dass der gesamte
	      Datenverkehr für dieses Ziel intern bleibt, anstatt ihn
	      über ein Netzwerk zu versenden.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>MAC-Adresse</term>
	  <listitem>
	    <para>Bei den mit <systemitem
		class="etheraddress">0:e0:</systemitem> beginnenden
	      Adressen handelt es sich um
	      <acronym>MAC</acronym>-Adressen.  &os; identifiziert
	      Rechner im lokalen Netz, im Beispiel
	      <systemitem>test0</systemitem>, automatisch und fügt
	      eine direkte Route über die Ethernet-Schnittstelle
	      <filename>re0</filename> zu diesem Rechner hinzu.
	      Außerdem existiert in der Spalte
	      <literal>Expire</literal> ein Timeout, der verwendet
	      wird, wenn dieser Rechner in einem definierten Zeitraum
	      nicht reagiert.  Wenn dies passiert, wird die Route zu
	      diesem Rechner automatisch gelöscht.  Rechner im lokalen
	      Netz werden über das Routing Information Protocol
	      (<acronym>RIP</acronym>) identifiziert, welches den
	      kürzesten Weg zu den jeweiligen Rechnern
	      berechnet.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>Subnetz</term>
	  <listitem>
	    <para>&os; wird automatisch Subnetzrouten für das lokale
	      Subnetz hinzufügen.  In diesem Beispiel ist <systemitem
		class="ipaddress">10.20.30.255</systemitem> die
	      Broadcast-Adresse für das Subnetz <systemitem
		class="ipaddress">10.20.30</systemitem>, und
	      <systemitem
		class="fqdomainname">example.com</systemitem> ist der
	      zu diesem Subnetz gehörige Domainname.  Das Ziel
	      <literal>link#1</literal> bezieht sich auf die erste
	      Ethernet-Karte im Rechner.</para>

	    <para>Routen für Rechner im lokalen Netz und lokale
	      Subnetze werden automatisch durch den
	      &man.routed.8; Daemon konfiguriert.  Ist dieser nicht
	      gestartet, existieren nur statische Routen, die vom
	      Administrator definiert werden.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>Host</term>
	  <listitem>
	    <para>Die Zeile <literal>host1</literal> bezieht sich auf
	      den Rechner, der durch seine Ethernetadresse bekannt
	      ist.  Da es sich um den sendenden Rechner handelt,
	      verwendet &os; automatisch das Loopback-Gerät
	      (<filename>lo0</filename>), anstatt den Datenverkehr
	      über die Ethernet-Schnittstelle zu senden.</para>

	    <para>Die zwei <literal>host2</literal> Zeilen
	      repräsentieren Aliase, die mit &man.ifconfig.8; erstellt
	      wurden.  Das Symbol <literal>=&gt;</literal> nach der
	      <filename>lo0</filename>-Schnittstelle sagt aus, dass
	      zusätzlich zur Loopback-Adresse auch ein Alias
	      eingestellt ist.  Solche Routen sind nur auf Rechnern
	      vorhanden, die den Alias bereitstellen.  Alle anderen
	      Rechner im lokalen Netz haben für solche Routen nur eine
	      <literal>link#1</literal> Zeile.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>224</term>
	  <listitem>
	    <para>Die letzte Zeile (Zielsubnetz
	      <literal>224</literal>) behandelt Multicasting.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>Schließlich gibt es für Routen noch
	verschiedene Attribute, die sich in der Spalte
	<literal>Flags</literal> befinden.  <xref
	  linkend="routeflags"/> fasst einige dieser Flags und
	deren Bedeutung zusammen:</para>

      <table xml:id="routeflags" frame="none" pgwide="1">
	<title>Allgemeine Attribute in Routingtabellen</title>

	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Attribut</entry>
	      <entry>Bedeutung</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>U</entry>
	      <entry>Die Route ist aktiv (up).</entry>
	    </row>

	    <row>
	      <entry>H</entry>
	      <entry>Das Ziel der Route ist ein einzelner Rechner
		(Host).</entry>
	    </row>

	    <row>
	      <entry>G</entry>
	      <entry>Alle Daten, die an dieses Ziel gesendet werden,
		werden von dem Gateway an ihr jeweiliges Ziel
		weitergeleitet.</entry>
	    </row>

	    <row>
	      <entry>S</entry>
	      <entry>Diese Route wurde statisch konfiguriert.</entry>
	    </row>

	    <row>
	      <entry>C</entry>
	      <entry>Erzeugt eine neue Route, basierend auf der
		Route für den Rechner, mit dem wir uns verbinden.
		Diese Routenart wird normalerweise für lokale
		Netzwerke verwendet.</entry>
	    </row>

	    <row>
	      <entry>W</entry>
	      <entry>Eine Route, die automatisch
		konfiguriert wurde.  Sie basiert auf einer lokalen
		Netzwerkroute (Clone).</entry>
	    </row>

	    <row>
	      <entry>L</entry>
	      <entry>Die Route beinhaltet einen Verweis auf eine
		Ethernetkarte (Link).</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <para>In &os; kann die Standardroute durch
	die Angabe der <acronym>IP</acronym>-Adresse des
	Standard-Gateways in <filename>/etc/rc.conf</filename>
	definiert werden:</para>

      <programlisting>defaultrouter="10.20.30.1"</programlisting>

      <para>Die Standardroute kann mit <command>route</command> auch
	manuell gesetzt werden:</para>

      <screen>&prompt.root; <userinput>route add default 10.20.30.1</userinput></screen>

      <para>Beachten Sie, dass manuell hinzugefügte Routen bei einem
	Neustart des Systems verloren gehen.  Weitere Informationen
	zum Bearbeiten von Netzwerk-Routingtabellen finden Sie in
	&man.route.8;.</para>
    </sect2>

    <sect2 xml:id="network-static-routes">
      <info>
	<title>Statische Routen einrichten</title>

	<authorgroup>
	  <author>
	    <personname>
	      <firstname>Al</firstname>
	      <surname>Hoang</surname>
	    </personname>
	    <contrib>Beigetragen von </contrib>
	  </author>
	</authorgroup>
      </info>
      <!-- Feb 2004 -->

      <indexterm>
	<primary>Dual-Homed-Hosts</primary>
      </indexterm>

      <para>Ein &os;-System kann als Standard-Gateway bzw. Router für
	ein Netzwerk konfiguriert werden, wenn es sich um einen
	Dual-Homed-Host handelt.  Ein Dual-Homed-Host ist ein Rechner,
	der sich in mindestens zwei verschiedenen Netzwerken
	befindet.  Typischerweise ist jedes Netzwerk über eine
	separate Netzwerkschnittstelle verbunden.  Mit
	<acronym>IP</acronym> Aliasing können mehrere Adressen, die
	jeweils zu einem andren Subnetz gehören, an eine physikalische
	Schnittstelle gebunden werden.</para>

      <indexterm>
	<primary>Router</primary>
      </indexterm>

      <para>Damit Pakete zwischen den Schnittstellen weitergeleitet
	werden können, muss das &os;-System als Router konfiguriert
	werden.  Internetstandards und gute Ingenieurspraxis sorgten
	dafür, dass diese Funktion in &os; in der Voreinstellung
	deaktiviert ist.  Sie kann jedoch aktiviert werden,
	indem folgende Zeile in <filename>/etc/rc.conf</filename>
	hinzugefügt wird:</para>

      <programlisting>gateway_enable="YES"          # Auf YES setzen, wenn der Rechner als Gateway arbeiten soll</programlisting>

      <para>Um das Routing zu aktivieren, setzen Sie die
	&man.sysctl.8;-Variable
	<varname>net.inet.ip.forwarding</varname> auf
	<literal>1</literal>.  Um das Routing zu stoppen,
	muss die Variable wieder auf <literal>0</literal> gesetzt
	werden.</para>

      <indexterm>
	<primary>BGP</primary>
      </indexterm>
      <indexterm>
	<primary>RIP</primary>
      </indexterm>
      <indexterm>
	<primary>OSPF</primary>
      </indexterm>

      <para>Die Routingtabelle eines Routers benötigt zusätzliche
	Routen, damit er weiß, wie er andere Netzwerke erreichen kann.
	Die Routen können entweder manuell als statische Routen
	hinzugefügt werden, oder aber der Router lernt automatisch
	die Routen anhand des Routing-Protokolls.  Statische Routen
	eignen sich für kleine Netzwerke und dieser Abschnitt
	beschreibt, wie Sie eine statische Route für ein kleines
	Netzwerk hinzufügen.</para>

      <note>
	<para>In großen Netzwerken sind statische Routen schlecht
	  skalierbar.  &os; beinhaltet den
	  <acronym>BSD</acronym>-Routing-Daemon &man.routed.8;, der
	  die Protokolle <acronym>RIP</acronym> (Version 1 und
	  Version 2) sowie <acronym>IRDP</acronym> unterstützt.  Die
	  Routing-Protokolle <acronym>BGP</acronym> und
	  <acronym>OSPF</acronym> können über den Port oder das Paket
	  <package>net/zebra</package> installiert werden.</para>
      </note>

      <para>Nehmen wir an, dass wir über folgendes Netzwerk
	verfügen:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="advanced-networking/static-routes"/>
	</imageobject>

	<textobject>
	  <literallayout class="monospaced">
    INTERNET
      | (10.0.0.1/24) Default Router to Internet
      |
      |Interface xl0
      |10.0.0.10/24
   +------+
   |      | RouterA
   |      | (FreeBSD gateway)
   +------+
      | Interface xl1
      | 192.168.1.1/24
      |
  +--------------------------------+
   Internal Net 1      | 192.168.1.2/24
                       |
                   +------+
                   |      | RouterB
                   |      |
                   +------+
                       | 192.168.2.1/24
                       |
                     Internal Net 2
          </literallayout>
	</textobject>
      </mediaobject>

      <para><systemitem>RouterA</systemitem>, ein &os;-Rechner, dient
	als Router für den Zugriff auf das Internet.  Die
	Standardroute ist auf <systemitem
	  class="ipaddress">10.0.0.1</systemitem> gesetzt, damit ein
	Zugriff auf das Internet möglich wird.
	<systemitem>RouterB</systemitem> ist bereits konfiguriert, da
	er <systemitem class="ipaddress">192.168.1.1</systemitem> als
	Standard-Gateway benutzt.</para>

      <para>Bevor die statischen Routen hinzugefügt werden, sieht
	die Routingtabelle auf <systemitem>RouterA</systemitem> in
	etwa so aus:</para>

      <screen>&prompt.user; <userinput>netstat -nr</userinput>
Routing tables

Internet:
Destination        Gateway            Flags    Refs      Use  Netif  Expire
default            10.0.0.1           UGS         0    49378    xl0
127.0.0.1          127.0.0.1          UH          0        6    lo0
10.0.0/24          link#1             UC          0        0    xl0
192.168.1/24       link#2             UC          0        0    xl1</screen>

      <para>Mit dieser Routingtabelle hat
	<systemitem>RouterA</systemitem> keine Route zum Netzwerk
	<systemitem class="ipaddress">192.168.2.0/24</systemitem>.
	Der folgende Befehl wird das interne Netz 2 in die
	Routingtabelle von <systemitem>RouterA</systemitem>
	aufnehmen und dabei <systemitem
	  class="ipaddress">192.168.1.2</systemitem> als nächsten
	Zwischenschritt (<foreignphrase>Hop</foreignphrase>)
	verwenden:</para>

      <screen>&prompt.root; <userinput>route add -net 192.168.2.0/24 192.168.1.2</userinput></screen>

      <para>Ab sofort kann <systemitem>RouterA</systemitem> alle
	Rechner des Netzwerks <systemitem
	  class="ipaddress">192.168.2.0/24</systemitem> erreichen.
	Allerdings gehen die Routing-Informationen verloren, wenn das
	&os;-System neu gestartet wird.  Um statische Routen dauerhaft
	einzurichten, müssen diese in
	<filename>/etc/rc.conf</filename> eingetragen werden:</para>

      <programlisting># Add Internal Net 2 as a persistent static route
static_routes="internalnet2"
route_internalnet2="-net 192.168.2.0/24 192.168.1.2"</programlisting>

      <para>Die Variable <literal>static_routes</literal> enthält
	eine Reihe von Strings, die durch Leerzeichen getrennt sind.
	Jeder String bezieht sich auf den Namen einer Route.  Die
	Variable
	<literal>route_<replaceable>internalnet2</replaceable></literal>
	enthält die statische Route.</para>

      <para>Wird mit der Variablen <literal>static_routes</literal>
	mehr als eine Variable angegeben, so werden auch mehrere
	Routen angelegt.  Im folgenden Beispiel werden statische
	Routen zu den Netzwerken <systemitem
	  class="ipaddress">192.168.0.0/24</systemitem> und
	<systemitem class="ipaddress">192.168.1.0/24</systemitem>
	angelegt.</para>

      <programlisting>static_routes="net1 net2"
route_net1="-net 192.168.0.0/24 192.168.0.1"
route_net2="-net 192.168.1.0/24 192.168.1.1"</programlisting>
    </sect2>

    <sect2 xml:id="network-routing-troubleshooting">
      <title>Problembehandlung</title>

      <para>Wenn ein Adressraum einem Netzwerk zugeordnet wird,
	konfiguriert der Dienstanbieter seine Routing-Tabellen, so
	dass der gesamte Verkehr für das Netzwerk über die Verbindung
	zu der Seite gesendet wird.  Aber woher wissen externe
	Webseiten, dass sie die Daten an das Netzwerk des
	<acronym>ISP</acronym> senden sollen?</para>

      <para>Es gibt ein System, das alle zugewiesenen Adressräume
	verwaltet und die Verbindung zum Internet-Backbone definiert.
	Der <quote>Backbone</quote> ist das Netz aus
	Hauptverbindungen, die den Internetverkehr in der ganzen Welt
	transportieren und verteilen.  Jeder Backbone-Rechner verfügt
	über eine Kopie von Master-Tabellen, die den Verkehr für ein
	bestimmtes Netzwerk hierarchisch vom Backbone über eine Kette
	von Dienstanbietern bis hin zu einem bestimmten Netzwerk
	leiten.</para>

      <para>Es ist die Aufgabe des Dienstanbieters, den
	Backbone-Seiten mitzuteilen, dass sie mit einer Seite
	verbunden wurden.  Dieser Vorgang wird als
	<emphasis>Bekanntmachung von Routen</emphasis>
	(<foreignphrase>routing propagation</foreignphrase>)
	bezeichnet.</para>

      <indexterm>
	<primary>&man.traceroute.8;</primary>
      </indexterm>

      <para>Manchmal kommt es zu Problemen bei der Bekanntmachung von
	Routen, und einige Seiten sind nicht in der Lage, sich zu
	verbinden.  Der vielleicht nützlichste Befehl, um
	festzustellen wo das Routing nicht funktioniert, ist
	<command>traceroute</command>.  Das Programm ist nützlich,
	falls <command>ping</command> fehlschlägt.</para>

      <para>Rufen Sie <command>traceroute</command> mit dem Namen des
	entfernten Rechners auf, mit dem eine Verbindung aufgebaut
	werden soll.  Die Ausgabe zeigt die Gateway-Rechner entlang
	des Verbindungspfades an.  Schließlich wird der Zielrechner
	erreicht oder es kommt zu einem Verbindungsabbruch.  Weitere
	Informationen finden Sie in &man.traceroute.8;.</para>
    </sect2>

    <sect2 xml:id="network-routing-multicast">
      <title>Multicast-Routing</title>

      <indexterm>
	<primary>Multicast-Routing</primary>
      </indexterm>

      <indexterm>
	<primary>Kerneloptionen</primary>
	<secondary>MROUTING</secondary>
      </indexterm>

      <para>&os; unterstützt sowohl Multicast-Anwendungen als
	auch Multicast-Routing.  Multicast-Anwendungen benötigen keine
	spezielle Konfiguration, um auf &os; lauffähig zu sein.  Damit
	Multicast-Routing unterstützt wird, muss die folgende Option
	in der Kernelkonfiguration aktiviert werden:</para>

      <programlisting>options MROUTING</programlisting>

      <para>Der Multicast-Routing-Daemon
	<application>mrouted</application> kann als Port oder Paket
	<package>net/mroute</package> installiert werden.  Dieser
	Daemon implementiert das <acronym>DVMRP</acronym>
	Multicast-Routing-Protokoll.  Um die Tunnel und
	<acronym>DVMRP</acronym> einzurichten, muss
	<filename>/usr/local/etc/mrouted.conf</filename> bearbeitet
	werden.  Bei der Installation von
	<application>mrouted</application> wird auch
	<application>map-mbone</application> und
	<application>mrinfo</application> sowie die zugehörigen
	Manualpages installiert, in denen Sie auch
	Konfigurationsbeispiele finden können.</para>

      <note>
	<para><acronym>DVMRP</acronym> wurde in vielen
	  Multicast-Installationen weitgehend durch das
	  <acronym>PIM</acronym>-Protokoll ersetzt.  Weitere
	  Informationen finden Sie in &man.pim.4;.</para>
      </note>
    </sect2>
  </sect1>

  <sect1 xml:id="network-wireless">
    <info>
      <title>Drahtlose Netzwerke</title>

      <authorgroup>
	<author>
	  <personname>
	    <othername>Loader</othername>
	  </personname>
	</author>

	<author>
	  <personname>
	    <firstname>Marc</firstname>
	    <surname>Fonvieille</surname>
	  </personname>
	</author>

	<author>
	  <personname>
	    <firstname>Murray</firstname>
	    <surname>Stokely</surname>
	  </personname>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>Netzwerke, drahtlos</primary>
    </indexterm>
    <indexterm>
      <primary>802.11</primary>
      <see>drahtlose Netzwerke</see>
    </indexterm>

    <sect2>
      <title>Grundlagen</title>

      <para>Die meisten drahtlosen Netzwerke basieren auf dem
	Standard &ieee;&nbsp;802.11.  Ein einfaches drahtloses
	Netzwerk besteht aus Stationen, die im 2,4&nbsp;GHz- oder im
	5&nbsp;GHz-Band miteinander kommunizieren.  Es ist aber auch
	möglich, dass regional andere Frequenzen, beispielsweise im
	2,3&nbsp;GHz- oder 4,9&nbsp;GHz-Band, verwendet werden.</para>

      <para>802.11-Netzwerke können auf zwei verschiedene
	Arten aufgebaut sein:  Im
	<emphasis>Infrastruktur-Modus</emphasis> agiert eine
	Station als Master, mit dem sich alle anderen Stationen
	verbinden.  Die Summe aller Stationen wird als Basic Service
	Set (<acronym>BSS</acronym>), die Master-Station hingegen als
	Access Point (<acronym>AP</acronym>) bezeichnet.  In einem
	<acronym>BSS</acronym> läuft jedwede Kommunikation über den
	Access Point.  Die zweite Form drahtloser Netzwerke sind die
	sogenannten <emphasis>Ad-hoc-Netzwerke</emphasis> (auch als
	<acronym>IBSS</acronym> bezeichnet), in denen es keinen Access
	Point gibt und in denen die Stationen direkt miteinander
	kommunizieren.</para>

      <para>Die ersten 802.11-Netzwerke arbeiteten im
	2,4&nbsp;GHz-Band und nutzten dazu Protokolle der
	&ieee;-Standards 802.11 sowie 802.11b.  Diese Standards legen
	unter anderem Betriebsfrequenzen sowie Merkmale des
	<acronym>MAC</acronym>-Layers (wie Frames und
	Transmissionsraten) fest.  Später kam der Standard 802.11a
	hinzu, der im 5&nbsp;GHz-Band, im Gegensatz zu den ersten
	beiden Standards aber mit unterschiedlichen Signalmechanismen
	und höheren Transmissionsraten arbeitet.  Der neueste Standard
	802.11g implementiert die Signal- und Transmissionsmechanismen
	von 802.11a im 2,4&nbsp;GHz-Band, ist dabei aber
	abwärtskompatibel zu 802.11b-Netzwerken.</para>

      <para>Unabhängig von den zugrundeliegenden Transportmechanismen
	verfügen 802.11-Netzwerke über diverse Sicherheitsmechanismen.
	Der ursprüngliche 802.11-Standard definierte lediglich ein
	einfaches Sicherheitsprotokoll namens <acronym>WEP</acronym>.
	Dieses Protokoll verwendet einen fixen, gemeinsam verwendeten
	Schlüssel sowie die RC4-Kryptografie-Chiffre, um Daten
	verschlüsselt über das drahtlose Netzwerk zu senden.  Alle
	Stationen des Netzwerks müssen sich auf den gleichen fixen
	Schlüssel einigen, um miteinander kommunizieren zu können.
	Dieses Schema ist sehr leicht zu knacken und wird deshalb
	heute kaum mehr eingesetzt.  Aktuelle Sicherheitsmechanismen
	bauen auf dem Standard &ieee;&nbsp;802.11i auf, der neue
	kryptographische Schlüssel (Chiffren), ein neues Protokoll für
	die Anmeldung von Stationen an einem Access Point, sowie
	Mechanismen zum Austausch von Schlüsseln als Vorbereitung der
	Kommunikation zwischen verschiedenen Geräten festlegt.
	Kryptografische Schlüssel werden in regelmäßigen Abständen
	aktualisiert.  Außerdem gibt es Mechanismen zur Feststellung
	und Prävention von Einbruchsversuchen.  Ein weiteres häufig
	verwendetes Sicherheitsprotokoll ist <acronym>WPA</acronym>.
	Dabei handelt es sich um einen Vorläufer von 802.11i, der von
	einem Industriekonsortium als Zwischenlösung bis zur
	endgültigen Verabschiedung von 802.11i entwickelt wurde.
	<acronym>WPA</acronym> definiert eine Untergruppe der
	Anforderungen des 802.11i-Standards und ist für den Einsatz in
	älterer Hardware vorgesehen.  <acronym>WPA</acronym> benötigt
	nur den <acronym>TKIP</acronym>-Chiffre, welcher auf dem
	ursprünglichen <acronym>WEP</acronym>-Code basiert.  802.11i
	erlaubt zwar auch die Verwendung von <acronym>TKIP</acronym>,
	benötigt aber zusätzlich eine stärkere Chiffre (AES-CCM)
	für die Datenverschlüsselung.  <acronym>AES</acronym> war für
	<acronym>WPA</acronym> nicht vorgesehen, weil man es als zu
	rechenintensiv für den Einsatz in älteren Geräten
	ansah.</para>

      <para>Ein weiterer zu beachtender Standard ist 802.11e.  Dieser
	definiert Protokolle zur Übertragung von
	Multimedia-Anwendungen, wie das Streaming von Videodateien
	oder Voice-over-IP (<acronym>VoIP</acronym>) in einem
	802.11-Netzwerk.  Analog zu 802.11i verfügt auch 802.11e über
	eine vorläufige Spezifikation namens <acronym>WMM</acronym>
	(ursprünglich <acronym>WME</acronym>), die von einem
	Industriekonsortium als Untergruppe von 802.11e spezifiziert
	wurde, um Multimedia-Anwendungen bereits vor der endgültigen
	Verabschiedung des 802.11e-Standards implementieren zu können.
	802.11e sowie <acronym>WME</acronym>/<acronym>WMM</acronym>
	erlauben eine Prioritätenvergabe beim Datentransfer in einem
	drahtlosen Netzwerk.  Möglich wird dies durch den Einsatz von
	Quality of Service-Protokollen (<acronym>QoS</acronym>) und
	erweiterten Medienzugriffsprotokollen.  Werden diese
	Protokolle korrekt implementiert, erlauben sie hohe
	Datenübertragungsraten und einen priorisierten
	Datenfluss.</para>

      <para>&os; unterstützt die Standards
	802.11a, 802.11b und 802.11g.  Ebenfalls unterstützt
	werden <acronym>WPA</acronym> sowie die Sicherheitsprotokolle
	gemäß 802.11i (sowohl für 11a, 11b als auch 11g).
	<acronym>QoS</acronym> und Verkehrspriorisierung, die von den
	<acronym>WME</acronym>/<acronym>WMM</acronym>-Protokollen
	benötigt werden, werden für einen begrenzten Satz von
	drahtlosen Geräten unterstützt.</para>
    </sect2>

    <sect2 xml:id="network-wireless-quick-start">
      <title>Schnellstartanleitung</title>

      <para>Häufig soll ein Computer an ein vorhandenes
	Drahtlosnetzwerk angeschlossen werden.  Diese Prozedur zeigt
	die dazu erforderlichen Schritte.</para>

      <procedure>
	<step>
	  <para>Besorgen Sie sich vom Netzwerkadministrator die
	    <acronym>SSID</acronym>
	    (<foreignphrase>Service Set Identifier</foreignphrase>)
	    und den <acronym>PSK</acronym>
	    (<foreignphrase>Pre Shared Key</foreignphrase>) für das
	    Drahtlosnetzwerk.</para>
	</step>

	<step>
	  <para>Ermitteln Sie den drahtlosen Adapter.  Der
	    <filename>GENERIC</filename>-Kernel von &os; enthält
	    Treiber für viele gängige Adapter.  Wenn der drahtlose
	    Adapter eines dieser Modelle ist, wird das in der Ausgabe
	    von &man.ifconfig.8; angezeigt:</para>

	  <screen>&prompt.user; <userinput>ifconfig | grep -B3 -i wireless</userinput></screen>

	  <para>In &os;&nbsp;11 und neueren Versionen verwenden Sie
	    stattdessen diesen Befehl:</para>

	  <screen>&prompt.user; <userinput>sysctl net.wlan.devices</userinput></screen>

	  <para>Wenn der drahtlose Adapter nicht aufgeführt wird,
	    könnte ein zusätzliches Kernelmodul erforderlich sein.  Es
	    besteht jedoch auch die Möglichkeit, dass der Adapter von
	    &os; nicht unterstützt wird.</para>
	  <!-- WB: refer to section that shows how to identify a
	  wireless adapter and load the kernel modules for it. -->

	  <para>Dieses Beispiel verwendet einen drahtlosen
	    Atheros-Adapter <literal>ath0</literal>.</para>
	</step>

	<step>
	  <para>Fügen Sie in
	    <filename>/etc/wpa_supplicant.conf</filename> einen
	    Eintrag für das Netzwerk hinzu.  Wenn die Datei nicht
	    existiert, müssen Sie diese erstellen.  Ersetzen Sie
	    <replaceable>myssid</replaceable> und
	    <replaceable>psk</replaceable> durch die
	    <acronym>SSID</acronym> und den <acronym>PSK</acronym>.
	    Diese Informationen werden vom Netzwerkadministrator zur
	    Verfügung gestellt.</para>

	  <programlisting>network={
	ssid="<replaceable>myssid</replaceable>"
	psk="<replaceable>mypsk</replaceable>"
}</programlisting>
	</step>

	<step>
	  <para>Fügen Sie die entsprechenden Einträge in
	    <filename>/etc/rc.conf</filename> ein, um das Netzwerk
	    beim Start zu konfigurieren:</para>

	  <programlisting>wlans_<replaceable>ath0</replaceable>="wlan0"
ifconfig_wlan0="WPA SYNCDHCP"</programlisting>
	</step>

	<step>
	  <para>Starten Sie den Computer oder den Netzwerkdienst neu,
	    um sich mit dem Netzwerk zu verbinden:</para>

	  <screen>&prompt.root; <userinput>service netif restart</userinput></screen>
	</step>
      </procedure>
    </sect2>

    <sect2 xml:id="network-wireless-basic">
      <title>Basiskonfiguration</title>

      <sect3>
	<title>Kernelkonfiguration</title>

	<para>Um ein drahtloses Netzwerk zu nutzen, wird eine
	  drahtlose Netzwerkkarte benötigt und ein Kernel, der
	  drahtlose Netzwerke unterstützt.  Der Kernel
	  unterstützt den Einsatz von Kernelmodulen.  Daher
	  muss nur die Unterstützung für die verwendeten Geräte
	  aktiviert werden.</para>

	<para>Die meisten drahtlosen Geräte verwenden Bauteile von
	  Atheros und werden deshalb vom &man.ath.4;-Treiber
	  unterstützt.  Um diesen Treiber zu verwenden,
	  muss die folgende Zeile in
	  <filename>/boot/loader.conf</filename> hinzugefügt
	  werden:</para>

	<programlisting>if_ath_load="YES"</programlisting>

	<para>Der Atheros-Treiber besteht aus drei Teilen:
	  dem Treiber selbst (&man.ath.4;), dem
	  Hardware-Support-Layer für die
	  chip-spezifischen Funktionen (&man.ath.hal.4;)
	  sowie einem Algorithmus zur Auswahl der
	  Frame-Übertragungsrate (ath_rate_sample).  Wenn diese
	  Unterstützung als Kernelmodul geladen wird, kümmert sich
	  das Modul automatisch um Abhängigkeiten.  Um die
	  Unterstützung für ein anderes drahtloses Gerät zu laden,
	  geben Sie das entsprechende Modul für dieses Gerät an.
	  Dieses Beispiel zeigt die Verwendung von Geräten, die auf
	  Bauteilen von Intersil Prism basieren und den Treiber
	  &man.wi.4; benötigen:</para>

	<programlisting>if_wi_load="YES"</programlisting>

	<note>
	  <para>Die Beispiele in diesem Abschnitt verwenden den
	    &man.ath.4;-Treiber.  Verwenden Sie ein anderes Gerät,
	    muss der Gerätename an die Konfiguration angepasst werden.
	    Eine Liste aller verfügbaren Treiber und unterstützten
	    drahtlosen Geräte finden sich in den &os;
	    Hardware Notes unter <link
	      xlink:href="https://www.FreeBSD.org/releases/index.html">
	      Release Information</link> der &os; Homepage.  Gibt es
	    keinen nativen &os;-Treiber für das drahtlose
	    Gerät, kann möglicherweise mit
	    <link linkend="config-network-ndis">NDIS</link> ein
	    &windows;-Treiber verwendet werden.</para>
	</note>

	<para>Zusätzlich müssen die Module zur Verschlüsselung des
	  drahtlosen Netzwerks geladen werden.  Diese werden
	  normalerweise dynamisch vom &man.wlan.4;-Modul geladen.  Im
	  folgenden Beispiel erfolgt allerdings eine manuelle
	  Konfiguration.  Folgende Module sind verfügbar:
	  &man.wlan.wep.4;, &man.wlan.ccmp.4; und &man.wlan.tkip.4;.
	  Sowohl &man.wlan.ccmp.4; als auch &man.wlan.tkip.4; werden
	  nur benötigt, wenn <acronym>WPA</acronym> und/oder die
	  Sicherheitsprotokolle von 802.11i verwendet werden.  Wenn
	  das Netzwerk keine Verschlüsselung verwendet, wird die
	  &man.wlan.wep.4;-Unterstützung nicht benötigt.  Um diese
	  Module beim Systemstart zu laden, fügen Sie folgende
	  Zeilen in <filename>/boot/loader.conf</filename> ein:</para>

	<programlisting>wlan_wep_load="YES"
wlan_ccmp_load="YES"
wlan_tkip_load="YES"</programlisting>

	<para>Sobald diese Einträge in
	  <filename>/boot/loader.conf</filename> vorhanden sind, muss
	  das &os;-System neu gestartet werden.  Alternativ können
	  die Kernelmodule auch manuell mit &man.kldload.8; geladen
	  werden.</para>

	<note>
	  <para>Benutzer, die keine Kernelmodule verwenden wollen,
	    können die benötigten Treiber auch in den Kernel
	    kompilieren.  Dazu müssen die folgenden Zeilen in die
	    Kernelkonfigurationsdatei aufgenommen werden:</para>

	  <programlisting>device wlan              # 802.11 support
device wlan_wep          # 802.11 WEP support
device wlan_ccmp         # 802.11 CCMP support
device wlan_tkip         # 802.11 TKIP support
device wlan_amrr         # AMRR transmit rate control algorithm
device ath               # Atheros pci/cardbus NIC's
device ath_hal           # pci/cardbus chip support
options AH_SUPPORT_AR5416 # enable AR5416 tx/rx descriptors
device ath_rate_sample   # SampleRate tx rate control for ath</programlisting>

	  <para>Mit diesen Informationen in der
	    Kernelkonfigurationsdatei kann der Kernel neu gebaut, und
	    das &os;-System anschließend neu gestartet werden.</para>
	</note>

	<para>Informationen über das drahtlose Gerät sollten in den
	  Boot-Meldungen folgendermaßen angezeigt werden:</para>

	<screen>ath0: &lt;Atheros 5212&gt; mem 0x88000000-0x8800ffff irq 11 at device 0.0 on cardbus1
ath0: [ITHREAD]
ath0: AR2413 mac 7.9 RF2413 phy 4.5</screen>
      </sect3>
    </sect2>

    <sect2>
      <title>Infrastruktur-Modus</title>

      <para>Drahtlose Netzwerke werden in der Regel im
	Infrastruktur-Modus (<acronym>BSS</acronym>) betrieben.
	Dazu werden mehrere drahtlose Access Points zu einem
	gemeinsamen drahtlosen Netzwerk verbunden.  Jedes dieser
	drahtlosen Netzwerke hat einen eigenen Namen, der als
	<acronym>>SSID</acronym>> bezeichnet wird.  Alle Clients
	eines drahtlosen Netzwerks verbinden sich in diesem Modus
	mit einem Access Point.</para>

      <sect3>
	<title>&os;-Clients</title>

	<sect4>
	  <title>Einen Access Point finden</title>

	  <para>Um nach verfügbaren drahtlosen Netzwerken zu suchen
	    verwenden Sie &man.ifconfig.8;.  Dieser Scanvorgang kann
	    einen Moment dauern, da jede verfügbare Frequenz auf
	    verfügbare Access Points hin überprüft werden muss.  Nur
	    der Super-User kann einen Scanvorgang starten:</para>

	  <screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> create wlandev <replaceable>ath0</replaceable></userinput>
&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> up scan</userinput>
SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS
dlinkap         00:13:46:49:41:76   11   54M -90:96   100 EPS  WPA WME
freebsdap       00:11:95:c3:0d:ac    1   54M -83:96   100 EPS  WPA</screen>

	  <note>
	    <para>Die Netzwerkkarte muss in den Status
	      <option>up</option> versetzt werden, bevor der erste
	      Scanvorgang gestartet werden kann.  Für spätere
	      Scans ist dies aber nicht mehr erforderlich.</para>
	  </note>

	  <para>Als Ergebnis erhalten Sie eine Liste mit allen
	    gefundenen
	    <acronym>BSS</acronym>/<acronym>IBSS</acronym>-Netzwerken.
	    Zusätzlich zum Namen des Netzwerks, der
	    <literal>SSID</literal>, wird auch die
	    <literal>BSSID</literal> ausgegeben.  Dabei handelt es
	    sich um die <acronym>MAC</acronym>-Adresse des Access
	    Points.  Das Feld <literal>CAPS</literal> gibt den Typ des
	    Netzwerks sowie die Fähigkeiten der Stationen innerhalb
	    des Netzwerks an:</para>

	  <table frame="none" pgwide="0">
	    <title>Station Capability Codes</title>

	    <tgroup cols="2">
	      <thead>
		<row>
		  <entry>Capability Code</entry>
		  <entry>Bedeutung</entry>
		</row>
	      </thead>

	      <tbody>
		<row>
		  <entry><literal>E</literal></entry>
		  <entry>Extended Service Set
		    (<acronym>ESS</acronym>).  Zeigt an, dass die
		    Station Teil eines Infrastruktur-Netzwerks ist,
		    und nicht eines
		    <acronym>IBSS</acronym>/Ad-hoc-Netzwerks.</entry>
		</row>

		<row>
		  <entry><literal>I</literal></entry>
		  <entry><acronym>IBSS</acronym>/Ad-hoc-Netzwerk.  Die
		    Station ist Teil eines Ad-hoc-Netzwerks und nicht
		    eines <acronym>ESS</acronym>-Netzwerks.</entry>
		</row>

		<row>
		  <entry><literal>P</literal></entry>
		  <entry>Privacy.  Alle Datenframes, die innerhalb des
		    <acronym>BSS</acronym> ausgetauscht werden, sind
		    verschlüsselt.  Dieses <acronym>BSS</acronym>
		    verwendet dazu kryptographische Verfahren wie
		    <acronym>WEP</acronym>, <acronym>TKIP</acronym>
		    oder
		    <acronym>AES</acronym>-<acronym>CCMP</acronym>.</entry>
		</row>

		<row>
		  <entry><literal>S</literal></entry>
		  <entry>Short Preamble.  Das Netzwerk verwendet eine
		    kurze Präambel (definiert in 802.11b High
		    Rate/DSSS PHY).  Eine kurze Präambel verwendet
		    ein 56&nbsp;Bit langes Sync-Feld, im Gegensatz
		    zu einer langen Präambel, die ein
		    128&nbsp;Bit langes Sync-Feld verwendet.</entry>
		</row>

		<row>
		  <entry><literal>s</literal></entry>
		  <entry>Short slot time.  Das 802.11g-Netzwerk
		    verwendet eine kurze Slotzeit, da es in diesem
		    Netzwerk keine veralteten (802.11b) Geräte
		    gibt.</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>

	  <para>Um eine Liste der bekannten Netzwerke auszugeben,
	    verwenden Sie den folgenden Befehl:</para>

	  <screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> list scan</userinput></screen>

	  <para>Diese Liste kann entweder automatisch durch das
	    drahtlose Gerät oder manuell durch eine
	    <option>scan</option>-Aufforderung aktualisiert werden.
	    Veraltete Informationen werden dabei automatisch
	    entfernt.</para>
	</sect4>

	<sect4>
	  <title>Basiseinstellungen</title>

	  <para>Dieser Abschnitt beschreibt, wie Sie eine
	    drahtlose Netzwerkkarte ohne Verschlüsselung unter &os;
	    einrichten.  Nachdem Sie sich mit den Informationen dieses
	    Abschnitts vertraut gemacht haben, sollten Sie das
	    drahtlose Netzwerk mit <link
	      linkend="network-wireless-wpa">WPA</link>
	    verschlüsseln.</para>

	  <para>Das Einrichten eines drahtlosen Netzwerks erfolgt
	    in drei Schritten:  Der Auswahl eines Access Points, die
	    Anmeldung der Station sowie der Konfiguration der
	    <acronym>IP</acronym>-Adresse.</para>

	  <sect5>
	    <title>Einen Access Point auswählen</title>

	    <para>Im Normalfall wird sich die Station automatisch mit
	      einem der zur Verfügung stehenden Access Points
	      verbinden.  Dazu muss lediglich das drahtlose Gerät
	      aktiviert, oder in <filename>/etc/rc.conf</filename>
	      eingetragen sein:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="DHCP"</programlisting>

	    <para>Stehen mehrere Access Points zur Verfügung, kann
	      ein spezifischer durch Angabe der
	      <acronym>SSID</acronym> gewählt werden:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="ssid <replaceable>Ihre_SSID</replaceable> DHCP"</programlisting>

	    <para>Gibt es in einem Netzwerk mehrere Access Points
	      mit der gleichen <acronym>SSID</acronym>, was das
	      Routing vereinfacht, kann es notwendig sein, dass ein
	      bestimmtes Gerät verbunden werden muss.  Dazu muss
	      lediglich die <acronym>BSSID</acronym> des Access Points
	      angeben werden.  Die Angabe der <acronym>SSID</acronym>
	      ist hierbei nicht zwingend notwendig:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="ssid <replaceable>Ihre_SSID</replaceable> bssid <replaceable>xx:xx:xx:xx:xx:xx</replaceable> DHCP"</programlisting>

	    <para>Es gibt noch weitere Möglichkeiten, den Zugriff
	      auf bestimmte Access Point zu beschränken,
	      beispielsweise durch die Begrenzung der Frequenzen, auf
	      denen eine Station nach einem Access Point sucht.
	      Sinnvoll ist ein solches Vorgehen beispielsweise, wenn
	      das drahtlose Gerät in verschiedenen Frequenzbereichen
	      arbeiten kann, da in diesem Fall das Prüfen aller
	      Frequenzen sehr zeitintensiv sein kann.  Um nur
	      innerhalb eines bestimmten Frequenzbereichs nach einem
	      Access Point zu suchen, verwenden Sie die Option
	      <option>mode</option>:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="mode <replaceable>11g</replaceable> ssid <replaceable>Ihre_SSID</replaceable> DHCP"</programlisting>

	    <para>In diesem Beispiel sucht das drahtlose Gerät nur im
	      2,4&nbsp;GHz-Band (802.11g), aber nicht innerhalb des
	      5&nbsp;GHz-Bandes nach einem Access Point.  Mit der
	      Option <option>channel</option> kann eine bestimmte
	      Frequenz vorgegeben werden, auf der gesucht werden soll.
	      Die Option <option>chanlist</option> erlaubt die Angabe
	      mehrerer erlaubter Frequenzen.  Eine umfassende
	      Beschreibung dieser Optionen finden Sie in
	      &man.ifconfig.8;.</para>
	  </sect5>

	  <sect5>
	    <title>Authentifizierung</title>

	    <para>Sobald ein Access Point gefunden wurde, muss
	      sich die Station am Access Point authentifizieren, bevor
	      Daten übertragen werden können.  Dazu gibt es
	      verschiedene Möglichkeiten.  Am häufigsten
	      wird die sogenannte <emphasis>offene
	      Authentifizierung</emphasis> verwendet.  Dabei wird
	      es jeder Station erlaubt, sich mit einem Netzwerk
	      zu verbinden und Daten zu übertragen.  Aus
	      Sicherheitsgründen sollte diese Methode allerdings
	      nur zu Testzwecken bei der erstmaligen Einrichtung
	      eines drahtlosen Netzwerks verwendet werden.  Andere
	      Authentifizierungsmechanismen erfordern den Austausch
	      kryptographischer Informationen, bevor sie die
	      Übertragung von Daten erlauben.  Dazu gehören
	      der Austausch fixer (vorher vereinbarter) Schlüssel
	      oder Kennwörter, sowie der Einsatz komplexerer
	      Verfahren mit Backend-Diensten wie
	      <acronym>RADIUS</acronym>.  Die offene Authentifizierung
	      ist die Voreinstellung.  Am zweithäufigsten kommt das im
	      <xref
		linkend="network-wireless-wpa-wpa-psk"/>
	      beschriebene <acronym>WPA-PSK</acronym> zum Einsatz,
	      welches auch als <acronym>WPA</acronym> Personal
	      bezeichnet wird.</para>

	    <note>
	      <para>Kommt eine &apple; &airport; Extreme-Basisstation
		als Access Point zum Einsatz, muss sowohl die
		Shared-Key-Authentifizierung als auch ein
		<acronym>WEP</acronym>-Schlüssel konfiguriert werden.
		Die entsprechende Konfiguration erfolgt entweder in
		<filename>/etc/rc.conf</filename> oder über das
		Programm &man.wpa.supplicant.8;.  Für eine einzelne
		&airport;-Basisstation kann der Zugriff wie folgt
		konfiguriert werden:</para>

	      <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="authmode shared wepmode on weptxkey <replaceable>1</replaceable> wepkey <replaceable>01234567</replaceable> DHCP"</programlisting>


	      <para>Normalerweise sollte Shared-Key-Authentifizierung
		nicht verwendet werden, da diese die Sicherheit des
		<acronym>WEP</acronym>-Schlüssel noch weiter
		verringert.  Wenn <acronym>WEP</acronym> für
		Kompatibilität mit älteren Geräten verwendet werden
		muss, ist es besser, <acronym>WEP</acronym> mit
		offener Authentifizierung zu verwenden.  Weitere
		Informationen zu <acronym>WEP</acronym> finden Sie im
		<xref linkend="network-wireless-wep"/>.</para>
	    </note>
	  </sect5>

	  <sect5>
	    <title>Eine <acronym>IP</acronym>-Adresse über
	      <acronym>DHCP</acronym> beziehen</title>

	    <para>Sobald ein Access Point ausgewählt ist und die
	      Authentifizierungsparameter festgelegt sind, wird eine
	      <acronym>IP</acronym>-Adresse benötigt.  In der Regel
	      wird die <acronym>IP</acronym>-Adresse über
	      <acronym>DHCP</acronym> bezogen.  Um dies zu erreichen,
	      bearbeiten Sie <filename>/etc/rc.conf</filename> und
	      fügen Sie <literal>DHCP</literal> für das drahtlose
	      Gerät in die Konfiguration hinzu:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="DHCP"</programlisting>

	    <para>Das drahtlose Gerät kann nun gestartet
	      werden:</para>

	    <screen>&prompt.root; <userinput>service netif start</userinput></screen>

	    <para>Nachdem das Gerät aktiviert wurde, kann mit
	      &man.ifconfig.8; der Status des Geräts
	      <filename>ath0</filename> abgefragt werden:</para>

	    <screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable></userinput>
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        ether 00:11:95:d5:43:62
        inet 192.168.1.100 netmask 0xffffff00 broadcast 192.168.1.255
        media: IEEE 802.11 Wireless Ethernet OFDM/54Mbps mode 11g
        status: associated
        ssid dlinkap channel 11 (2462 Mhz 11g) bssid 00:13:46:49:41:76
        country US ecm authmode OPEN privacy OFF txpower 21.5 bmiss 7
        scanvalid 60 bgscan bgscanintvl 300 bgscanidle 250 roam:rssi 7
        roam:rate 5 protmode CTS wme burst</screen>


	    <para><literal>status: associated</literal> besagt, dass
	      sich das Gerät mit dem drahtlosen Netzwerk verbunden
	      hat.  <literal>bssid 00:13:46:49:41:76</literal> ist die
	      <acronym>MAC</acronym>-Adresse des Access Points und
	      <literal>authmode OPEN</literal> zeigt an, dass die
	      Kommunikation nicht verschlüsselt wird.</para>
	  </sect5>

	  <sect5>
	    <title>Statische <acronym>IP</acronym>-Adressen</title>

	    <para>Wenn eine <acronym>IP</acronym>-Adresse nicht von
	      einem <acronym>DHCP</acronym>-Server bezogen werden
	      kann, vergeben Sie eine statische
	      <acronym>IP</acronym>-Adresse.  Ersetzten Sie dazu das
	      oben gezeigte Schlüsselwort <literal>DHCP</literal>
	      durch die entsprechende <acronym>IP</acronym>-Adresse.
	      Beachten Sie dabei, dass Sie die anderen
	      Konfigurationsparameter nicht versehentlich
	      verändern:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="inet <replaceable>192.168.1.100</replaceable> netmask <replaceable>255.255.255.0</replaceable> ssid <replaceable>your_ssid_here</replaceable>"</programlisting>
	  </sect5>
	</sect4>

	<sect4 xml:id="network-wireless-wpa">
	  <title><acronym>WPA</acronym></title>

	  <para><foreignphrase>Wi-Fi Protected Access</foreignphrase>
	    (<acronym>WPA</acronym>) ist ein Sicherheitsprotokoll, das
	    in 802.11-Netzwerken verwendet wird, um die fehlende
	    Authentifizierung und Schwächen von <acronym>WEP</acronym>
	    zu vermeiden.  <acronym>WPA</acronym> stellt das aktuelle
	    802.1X-Authentifizierungsprotokoll dar und verwendet
	    eine von mehreren Chiffren, um die Datensicherheit
	    zu gewährleisten.  Die einzige Chiffre, die von
	    <acronym>WPA</acronym> verlangt wird, ist
	    <foreignphrase>Temporary Key Integrity
	    Protocol</foreignphrase> (<acronym>TKIP</acronym>).
	    <acronym>TKIP</acronym> ist eine Chiffre, die die von
	    <acronym>WEP</acronym> verwendete RC4-Chiffre um
	    Funktionen zur Prüfung der Datenintegrität und zur
	    Erkennung und Bekämpfung von Einbruchsversuchen
	    erweitert.  <acronym>TKIP</acronym> ist durch
	    Softwaremodifikationen auch unter veralteter Hardware
	    lauffähig.  Im Vergleich zu <acronym>WEP</acronym> ist
	    <acronym>WPA</acronym> zwar sehr viel sicherer, es ist
	    aber dennoch nicht völlig immun gegen Angriffe.
	    <acronym>WPA</acronym> definiert mit
	    <acronym>AES-CCMP</acronym> noch eine weitere Chiffre als
	    Alternative zu <acronym>TKIP</acronym>.
	    <acronym>AES-CCMP</acronym>, welches häufig als
	    <acronym>WPA2</acronym> oder <acronym>RSN</acronym>
	    bezeichnet wird, sollte bevorzugt eingesetzt
	    werden.</para>

	  <para><acronym>WPA</acronym> definiert Authentifizierungs-
	    und Verschlüsselungsprotokolle.  Die Authentifizierung
	    erfolgt in der Regel über eine der folgenden Techniken:
	    802.1X gemeinsam mit einem
	    Backend-Authentifizierungsdienst wie
	    <acronym>RADIUS</acronym>, oder durch einen
	    Minimal-Handshake zwischen der Station und dem Access
	    Point mit einem vorher vereinbarten gemeinsamen Schlüssel.
	    Die erste Technik wird als <acronym>WPA</acronym>
	    Enterprise, die zweite hingegen als
	    <acronym>WPA Personal</acronym> bezeichnet.  Da sich der
	    Aufwand für das Aufsetzen eines
	    <acronym>RADIUS</acronym>-Backend-Servers für die meisten
	    drahtlosen Netzwerke nicht lohnt, wird
	    <acronym>WPA</acronym> in der Regel als
	    <acronym>WPA-PSK</acronym> konfiguriert.</para>

	  <para>Die Kontrolle der drahtlosen Verbindung sowie das
	    Aushandeln des Schlüssel, oder die Authentifizierung mit
	    einem Server, erfolgt über &man.wpa.supplicant.8;.  Dieses
	    Programm benötigt eine Konfigurationsdatei,
	    <filename>/etc/wpa_supplicant.conf</filename>.  Weitere
	    Informationen finden Sie in
	    &man.wpa.supplicant.conf.5;.</para>

	  <sect5 xml:id="network-wireless-wpa-wpa-psk">
	    <title><acronym>WPA-PSK</acronym></title>

	    <para><acronym>WPA-PSK</acronym>, das auch als
	      <acronym>WPA</acronym>-Personal bekannt ist, basiert auf
	      einem gemeinsamen, vorher vereinbarten Schlüssel
	      (<acronym>PSK</acronym>), der aus einem Passwort
	      generiert und danach als Master-Key des drahtlosen
	      Netzwerks verwendet wird.  Jeder Benutzer des drahtlosen
	      Netzwerks verwendet daher
	      <emphasis>den gleichen</emphasis> Schlüssel.
	      <acronym>WPA-PSK</acronym> sollte nur in kleinen
	      Netzwerken eingesetzt werden, in denen die Konfiguration
	      eines Authentifizierungsservers nicht möglich oder
	      erwünscht ist.</para>

	    <warning>
	      <para>Achten Sie darauf, immer starke Passwörter zu
		verwenden, die ausreichend lang sind und auch
		Sonderzeichen enthalten, damit diese nicht leicht
		erraten oder umgangen werden können.</para>
	    </warning>

	    <para>Der erste Schritt zum Einsatz von
	      <acronym>WPA-PSK</acronym> ist die Konfiguration der
	      <acronym>SSID</acronym> und des gemeinsamen Schlüssels
	      des Netzwerks in
	      <filename>/etc/wpa_supplicant.conf</filename>:</para>

	    <programlisting>network={
  ssid="freebsdap"
  psk="freebsdmall"
}</programlisting>

	    <para>Danach wird in
	      <filename>/etc/rc.conf</filename> definiert, dass
	      <acronym>WPA</acronym> zur Verschlüsselung eingesetzt
	      werden soll und dass die <acronym>IP</acronym>-Adresse
	      über <acronym>DHCP</acronym> bezogen wird:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="WPA DHCP"</programlisting>

	    <para>Nun kann das drahtlose Gerät aktiviert
	      werden:</para>

	    <screen>&prompt.root; <userinput>service netif start</userinput>
Starting wpa_supplicant.
DHCPDISCOVER on wlan0 to 255.255.255.255 port 67 interval 5
DHCPDISCOVER on wlan0 to 255.255.255.255 port 67 interval 6
DHCPOFFER from 192.168.0.1
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPACK from 192.168.0.1
bound to 192.168.0.254 -- renewal in 300 seconds.
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 MHz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</screen>

	    <para>Alternativ kann das drahtlose Gerät manuell, mit
	      Hilfe der Informationen aus
	      <filename>/etc/wpa_supplicant.conf</filename>
	      konfiguriert werden:</para>

	    <screen>&prompt.root; <userinput>wpa_supplicant -i <replaceable>wlan0</replaceable> -c /etc/wpa_supplicant.conf</userinput>
Trying to associate with 00:11:95:c3:0d:ac (SSID='freebsdap' freq=2412 MHz)
Associated with 00:11:95:c3:0d:ac
WPA: Key negotiation completed with 00:11:95:c3:0d:ac [PTK=CCMP GTK=CCMP]
CTRL-EVENT-CONNECTED - Connection to 00:11:95:c3:0d:ac completed (auth) [id=0 id_str=]</screen>

	    <para>Im zweiten Schritt starten Sie nun
	      &man.dhclient.8;, um eine <acronym>IP</acronym>-Adresse
	      vom <acronym>DHCP</acronym>-Server zu beziehen:</para>

	    <screen>&prompt.root; <userinput>dhclient <replaceable>wlan0</replaceable></userinput>
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPACK from 192.168.0.1
bound to 192.168.0.254 -- renewal in 300 seconds.
&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable></userinput>
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 MHz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</screen>

	    <note>
	      <para>Enthält <filename>/etc/rc.conf</filename>
		bereits die Zeile
		<literal>ifconfig_wlan0="DHCP"</literal>, wird
		&man.dhclient.8; automatisch gestartet, nachdem
		&man.wpa.supplicant.8; sich mit dem Access Point
		verbunden hat.</para>
	    </note>

	    <para>Sollte der Einsatz von <acronym>DHCP</acronym> nicht
	      möglich oder nicht gewünscht sein, konfigurieren Sie
	      eine statische <acronym>IP</acronym>-Adresse, nachdem
	      &man.wpa.supplicant.8; die Station authentifiziert
	      hat:</para>

	    <screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> inet <replaceable>192.168.0.100</replaceable> netmask <replaceable>255.255.255.0</replaceable></userinput>
&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable></userinput>
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.100 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 MHz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</screen>

	    <para>Falls <acronym>DHCP</acronym> nicht verwendet wird,
	      müssen zusätzlich noch das Standard-Gateway sowie
	      der Nameserver manuell festgelegt werden:</para>

	    <screen>&prompt.root; <userinput>route add default <replaceable>your_default_router</replaceable></userinput>
&prompt.root; <userinput>echo "nameserver <replaceable>your_DNS_server</replaceable>" &gt;&gt; /etc/resolv.conf</userinput></screen>
	  </sect5>

	  <sect5 xml:id="network-wireless-wpa-eap-tls">
	    <title><acronym>WPA</acronym> und
	      <acronym>EAP-TLS</acronym></title>

	    <para>Die zweite Möglichkeit, <acronym>WPA</acronym>
	      einzusetzen, ist die Verwendung eines
	      802.1X-Backend-Authentifizierungsservers.  Diese
	      Variante wird als <acronym>WPA</acronym>-Enterprise
	      bezeichnet, um sie vom weniger sicheren
	      <acronym>WPA</acronym>-Personal abzugrenzen.  Die bei
	      <acronym>WPA</acronym>-Enterprise verwendete
	      Authentifizierung basiert auf dem
	      <foreignphrase>Extensible Authentication
	      Protocol</foreignphrase>
	      (<acronym>EAP</acronym>).</para>

	    <para><acronym>EAP</acronym> selbst bietet keine
	      Verschlüsselung, sondern operiert in einem
	      verschlüsselten Tunnel.  Es gibt verschiedene auf
	      <acronym>EAP</acronym> basierende
	      Authentifizierungsmethoden, darunter
	      <acronym>EAP-TLS</acronym>,
	      <acronym>EAP-TTLS</acronym> und
	      <acronym>EAP-PEAP</acronym>.</para>

	    <para><acronym>EAP</acronym> mit <foreignphrase>Transport
	      Layers Security</foreignphrase>
	      (<acronym>EAP-TLS</acronym>) ist ein sehr gut
	      unterstütztes Authentifizierungsprotokoll, da es sich
	      dabei um die erste <acronym>EAP</acronym>-Methode
	      handelt, die von der <link
		xlink:href="http://www.wi-fi.org/">
		Wi-Fi Alliance</link> zertifiziert wurde.
	      <acronym>EAP-TLS</acronym> erfordert drei Zertifikate:
	      Das auf allen Rechnern installierte
	      <acronym>CA</acronym>-Zertifikat, das Server-Zertifikat
	      des Authentifizierungsservers, sowie ein
	      Client-Zertifikat für jeden drahtlosen Client.  Sowohl
	      der Authentifizierungsservers als auch die drahtlosen
	      Clients authentifizieren sich gegenseitig über
	      Zertifikate, wobei sie überprüfen, ob diese Zertifikate
	      auch von der Zertifizierungs-Authorität
	      (<acronym>CA</acronym>) des jeweiligen Unternehmens
	      signiert wurden.</para>

	    <para>Die Konfiguration erfolgt (analog zu
	      <acronym>WPA-PSK</acronym>) über
	      <filename>/etc/wpa_supplicant.conf</filename>:</para>

	    <programlisting>network={
  ssid="freebsdap" <co xml:id="co-tls-ssid"/>
  proto=RSN  <co xml:id="co-tls-proto"/>
  key_mgmt=WPA-EAP <co xml:id="co-tls-kmgmt"/>
  eap=TLS <co xml:id="co-tls-eap"/>
  identity="loader" <co xml:id="co-tls-id"/>
  ca_cert="/etc/certs/cacert.pem" <co xml:id="co-tls-cacert"/>
  client_cert="/etc/certs/clientcert.pem" <co xml:id="co-tls-clientcert"/>
  private_key="/etc/certs/clientkey.pem" <co xml:id="co-tls-pkey"/>
  private_key_passwd="freebsdmallclient" <co xml:id="co-tls-pwd"/>
}</programlisting>

	    <calloutlist>
	      <callout arearefs="co-tls-ssid">
		<para>Der Name des Netzwerks
		  (<acronym>SSID</acronym>).</para>
	      </callout>

	      <callout arearefs="co-tls-proto">
		<para>Das als <acronym>WPA2</acronym> bekannte
		  <acronym>RSN</acronym> &ieee; 802.11i Protokoll wird
		  verwendet.</para>
	      </callout>

	      <callout arearefs="co-tls-kmgmt">
		<para>Die <literal>key_mgmt</literal>-Zeile bezieht
		  sich auf das verwendete Key-Management-Protokoll.
		  In diesem Beispiel wird <acronym>WPA</acronym>
		  gemeinsam mit der
		  <acronym>EAP</acronym>-Authentifizierung
		  verwendet.</para>
	      </callout>

	      <callout arearefs="co-tls-eap">
		<para>Die für die Verbindung verwendete
		  <acronym>EAP</acronym>-Methode.</para>
	      </callout>

	      <callout arearefs="co-tls-id">
		<para>Das <literal>identity</literal>-Feld enthält
		  den von <acronym>EAP</acronym> verwendeten
		  Identifizierungsstring.</para>
	      </callout>

	      <callout arearefs="co-tls-cacert">
		<para>Das Feld <literal>ca_cert</literal> gibt den
		  Pfad zum <acronym>CA</acronym>-Zertifikat an.  Diese
		  Datei wird zur Verifizierung des Server-Zertifikats
		  benötigt.</para>
	      </callout>

	      <callout arearefs="co-tls-clientcert">
		<para>Die <literal>client_cert</literal>-Zeile gibt
		  den Pfad zum Client-Zertifikat an.  Jeder Client hat
		  ein eigenes, innerhalb des Netzwerks eindeutiges,
		  Zertifikat.</para>
	      </callout>

	      <callout arearefs="co-tls-pkey">
		<para>Das Feld <literal>private_key</literal> gibt den
		  Pfad zum privaten Schlüssel des
		  Client-Zertifikat an.</para>
	      </callout>

	      <callout arearefs="co-tls-pwd">
		<para>Das Feld <literal>private_key_passwd</literal>
		  enthält die Passphrase für den privaten
		  Schlüssel.</para>
	      </callout>
	    </calloutlist>

	    <para>Danach fügen Sie die folgende Zeile in
	      <filename>/etc/rc.conf</filename> ein:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="WPA DHCP"</programlisting>

	    <para>Nun können Sie das drahtlose Gerät
	      aktivieren:</para>

	    <screen>&prompt.root; <userinput>service netif start</userinput>
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
DHCPACK from 192.168.0.20
bound to 192.168.0.254 -- renewal in 300 seconds.
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 MHz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</screen>

	    <para>Alternativ kann das drahtlose Gerät manuell mit
	      &man.wpa.supplicant.8; und &man.ifconfig.8; aktiviert
	      werden.</para>
	  </sect5>

	  <sect5 xml:id="network-wireless-wpa-eap-ttls">
	    <title><acronym>WPA</acronym> mit
	      <acronym>EAP-TTLS</acronym></title>

	    <para>Bei <acronym>EAP-TLS</acronym> müssen sowohl der
	      Authentifizierungsserver als auch die Clients jeweils
	      ein eigenes Zertifikat aufweisen.  Bei
	      <acronym>EAP-TTLS</acronym> ist das Client-Zertifikat
	      optional.  <acronym>EAP-TTLS</acronym> geht dabei
	      vor wie ein Webserver, der einen sicheren
	      <acronym>SSL</acronym>-Tunnel erzeugen kann, ohne dass
	      der Besucher dabei über ein clientseitiges Zertifikat
	      verfügen muss.  <acronym>EAP-TTLS</acronym> verwendet
	      einen verschlüsselten <acronym>TLS-Tunnel</acronym> zum
	      sicheren Transport der Authentifizierungsdaten.</para>

	    <para>Die erforderliche Konfiguration erfolgt in
	      <filename>/etc/wpa_supplicant.conf</filename>:</para>

	    <programlisting>network={
  ssid="freebsdap"
  proto=RSN
  key_mgmt=WPA-EAP
  eap=TTLS <co xml:id="co-ttls-eap"/>
  identity="test" <co xml:id="co-ttls-id"/>
  password="test" <co xml:id="co-ttls-passwd"/>
  ca_cert="/etc/certs/cacert.pem" <co xml:id="co-ttls-cacert"/>
  phase2="auth=MD5" <co xml:id="co-ttls-pha2"/>
}</programlisting>

	    <calloutlist>
	      <callout arearefs="co-ttls-eap">
		<para>Die für die Verbindung verwendete
		  <acronym>EAP</acronym>-Methode.</para>
	      </callout>

	      <callout arearefs="co-ttls-id">
		<para>Das <literal>identity</literal>-Feld enthält
		  den Identifizierungsstring für die
		  <acronym>EAP</acronym>-Authentifizierung innerhalb
		  des verschlüsselten
		  <acronym>TLS</acronym>-Tunnels.</para>
	      </callout>

	      <callout arearefs="co-ttls-passwd">
		<para>Das <literal>password</literal>-Feld enthält
		  die Passphrase für die
		  <acronym>EAP</acronym>-Authentifizierung.</para>
	      </callout>

	      <callout arearefs="co-ttls-cacert">
		<para>Das Feld <literal>ca_cert</literal> gibt den
		  Pfad zum <acronym>CA</acronym>-Zertifikat an.  Diese
		  Datei wird zur Verifizierung des Server-Zertifikats
		  benötigt.</para>
	      </callout>

	      <callout arearefs="co-peap-pha2">
		<para>Die innerhalb des verschlüsselten
		  <acronym>TLS</acronym>-Tunnels verwendete
		  Authentifizierungsmethode.  In Fall von
		  <acronym>PEAP</acronym> ist dies
		  <literal>auth=MSCHAPV2</literal>.</para>
	      </callout>
	    </calloutlist>

	    <para>Folgende Zeilen müssen in
	      <filename>/etc/rc.conf</filename> aufgenommen
	      werden:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="WPA DHCP"</programlisting>

	    <para>Nun kann das drahtlose Gerät aktiviert
	      werden:</para>

	    <screen>&prompt.root; <userinput>service netif start</userinput>
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 21
DHCPACK from 192.168.0.20
bound to 192.168.0.254 -- renewal in 300 seconds.
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 MHz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</screen>
	  </sect5>

	  <sect5 xml:id="network-wireless-wpa-eap-peap">
	    <title><acronym>WPA</acronym> mit
	      <acronym>EAP-PEAP</acronym></title>

	    <note>
	      <para><acronym>PEAPv0/EAP-MSCHAPv2</acronym> ist die
		gängigste <acronym>PEAP</acronym>-Methode.  In diesem
		Kapitel wird der Begriff <acronym>PEAP</acronym>
		stellvertretend für diese Methode verwendet.</para>
	    </note>

	    <para><foreignphrase>Protected EAP</foreignphrase>
	      (<acronym>PEAP</acronym>) wurde als Alternative zu
	      <acronym>EAP-TTLS</acronym> entwickelt und ist nach
	      <acronym>EAP-TLS</acronym> der meist genutzte
	      <acronym>EAP</acronym>-Standard.  In einem Netzwerk mit
	      verschiedenen Betriebssystemen sollte
	      <acronym>PEAP</acronym> das am besten unterstützte
	      Standard nach <acronym>EAP-TLS</acronym> sein.</para>

	    <para><acronym>PEAP</acronym> arbeitet ähnlich wie
	      <acronym>EAP-TTLS</acronym>.  Es verwendet ein
	      serverseitiges Zertifikat, um einen verschlüsselten
	      <acronym>TLS</acronym>-Tunnel, über den die sichere
	      Authentifizierung zwischen den Clients und dem
	      Authentifizierungsserver erfolgt.  In Sachen Sicherheit
	      unterscheiden sich <acronym>EAP-TTLS</acronym> und
	      <acronym>PEAP</acronym> allerdings:
	      <acronym>PEAP</acronym> überträgt den Benutzernamen im
	      Klartext und verschlüsselt nur das Passwort, während
	      <acronym>EAP-TTLS</acronym> sowohl den Benutzernamen,
	      als auch das Passwort über den
	      <acronym>TLS</acronym>-Tunnel überträgt.</para>

	    <para>Um <acronym>EAP-PEAP</acronym> zu konfigurieren,
	      fügen Sie die folgenden Zeilen in
	      <filename>/etc/wpa_supplicant.conf</filename>
	      ein:</para>

	    <programlisting>network={
  ssid="freebsdap"
  proto=RSN
  key_mgmt=WPA-EAP
  eap=PEAP <co xml:id="co-peap-eap"/>
  identity="test" <co xml:id="co-peap-id"/>
  password="test" <co xml:id="co-peap-passwd"/>
  ca_cert="/etc/certs/cacert.pem" <co xml:id="co-peap-cacert"/>
  phase1="peaplabel=0" <co xml:id="co-peap-pha1"/>
  phase2="auth=MSCHAPV2" <co xml:id="co-peap-pha2"/>
}</programlisting>

	    <calloutlist>
	      <callout arearefs="co-peap-eap">
		<para>Die für die Verbindung verwendete
		  <acronym>EAP</acronym>-Methode.</para>
	      </callout>

	      <callout arearefs="co-peap-id">
		<para>Das <literal>identity</literal>-Feld enthält
		  den Identifizierungsstring für die innerhalb
		  des verschlüsselten <acronym>TLS</acronym>-Tunnels
		  erfolgende
		  <acronym>EAP</acronym>-Authentifizierung.</para>
	      </callout>

	      <callout arearefs="co-peap-passwd">
		<para>Das Feld <literal>password</literal> enthält
		  die Passphrase für die
		  <acronym>EAP</acronym>-Authentifizierung.</para>
	      </callout>

	      <callout arearefs="co-peap-cacert">
		<para>Das Feld <literal>ca_cert</literal> gibt den
		  Pfad zum <acronym>CA</acronym>-Zertifikat an.  Diese
		  Datei wird zur Verifizierung des Server-Zertifikats
		  benötigt.</para>
	      </callout>

	      <callout arearefs="co-peap-pha1">
		<para>Dieses Feld enthält die Parameter für die erste
		  Phase der Authentifizierung, den
		  <acronym>TLS</acronym>-Tunnel.  Je nachdem, welcher
		  Authentifizierungsserver benutzt wird, kann ein
		  spezifisches Label für die Authentifizierung
		  verwendet werden.  Meistens lautet das Label
		  <quote>client <acronym>EAP</acronym>
		  encryption</quote>, dass durch
		  <literal>peaplabel=0</literal> gesetzt wird.
		  Weitere Informationen finden Sie in
		  &man.wpa.supplicant.conf.5;.</para>
	      </callout>

	      <callout arearefs="co-peap-pha2">
		<para>Das innerhalb des verschlüsselten TLS-Tunnels
		  verwendete Authentifizierungsprotokoll.  In unserem
		  Beispiel handelt es sich dabei um
		  <literal>auth=MSCHAPV2</literal>.</para>
	      </callout>
	    </calloutlist>

	    <para>Danach fügen Sie die folgende Zeile in
	      <filename>/etc/rc.conf</filename> ein:</para>

	    <programlisting>ifconfig_ath0="WPA DHCP"</programlisting>

	    <para>Nun kann das drahtlose Gerät aktiviert
	      werden.</para>

	    <screen>&prompt.root; <userinput>service netif start</userinput>
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 21
DHCPACK from 192.168.0.20
bound to 192.168.0.254 -- renewal in 300 seconds.
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 MHz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</screen>
	  </sect5>
	</sect4>

	<sect4 xml:id="network-wireless-wep">
	  <title><acronym>WEP</acronym></title>

	  <para><foreignphrase>Wired Equivalent
	    Privacy</foreignphrase> (<acronym>WEP</acronym>) ist Teil
	    des ursprünglichen 802.11-Standards.  Es enthält
	    keinen Authentifzierungsmechanismus und verfügt
	    lediglich über eine schwache Zugriffskontrolle,
	    die sehr leicht umgangen werden kann.</para>

	  <para><acronym>WEP</acronym> kann über &man.ifconfig.8;
	    aktiviert werden:</para>

	  <screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> create wlandev <replaceable>ath0</replaceable></userinput>
&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> inet <replaceable>192.168.1.100</replaceable> netmask <replaceable>255.255.255.0</replaceable> \
            ssid <replaceable>my_net</replaceable> wepmode on weptxkey <replaceable>3</replaceable> wepkey <replaceable>3:0x3456789012</replaceable></userinput></screen>

	  <itemizedlist>
	    <listitem>
	      <para><literal>weptxkey</literal> definiert den
		<acronym>WEP</acronym>-Schlüssel, der für die
		Datenübertragung verwendet wird.  Dieses Beispiel
		verwendet den dritten Schlüssel.  Der gleiche
		Schlüssel muss auch am Access Point eingestellt sein.
		Kennen Sie den vom Access Point verwendeten Schlüssel
		nicht, sollten Sie zuerst den Wert
		<literal>1</literal> (den ersten Schlüssel) für diese
		Variable verwenden.</para>
	    </listitem>

	    <listitem>
	      <para><literal>wepkey</literal> legt den zu
		verwendenden <acronym>WEP</acronym>-Schlüssel in der
		Form <replaceable>Nummer:Schlüssel</replaceable> fest.
		Schlüssel <literal>1</literal> wird standardmäßig
		verwendet.  Die "Nummer" muss nur angegeben werden,
		wenn ein anderer als der erste Schlüssel verwendet
		werden soll.</para>

	      <note>
		<para>Ersetzen Sie <literal>0x3456789012</literal>
		  durch den am Access Point konfigurierten
		  Schlüssel.</para>
	      </note>
	    </listitem>
	  </itemizedlist>

	  <para>Weitere Informationen finden Sie in
	    &man.ifconfig.8;.</para>

	  <para>Das Programm &man.wpa.supplicant.8; eignet sich
	    ebenfalls dazu, <acronym>WEP</acronym> für drahtlose
	    Geräte zu aktivieren.  Obige Konfiguration lässt
	    sich dabei durch die Aufnahme der folgenden Zeilen in
	    <filename>/etc/wpa_supplicant.conf</filename>
	    realisieren:</para>

	  <programlisting>network={
  ssid="my_net"
  key_mgmt=NONE
  wep_key3=3456789012
  wep_tx_keyidx=3
}</programlisting>

	  <para>Danach müssen Sie das Programm noch aufrufen:</para>

	  <screen>&prompt.root; <userinput>wpa_supplicant -i <replaceable>wlan0</replaceable> -c /etc/wpa_supplicant.conf</userinput>
Trying to associate with 00:13:46:49:41:76 (SSID='dlinkap' freq=2437 MHz)
Associated with 00:13:46:49:41:76</screen>
	</sect4>
      </sect3>
    </sect2>

    <sect2>
      <title>Ad-hoc-Modus</title>

      <para>Der <acronym>IBSS</acronym>-Modus, der auch als
	Ad-hoc-Modus bezeichnet wird, ist für
	Punkt-zu-Punkt-Verbindungen vorgesehen.  Um beispielsweise
	eine Ad-hoc-Verbindung zwischen den Rechnern
	<systemitem>A</systemitem> und <systemitem>B</systemitem>
	aufzubauen, werden lediglich zwei
	<acronym>IP</acronym>-Adressen und eine
	<acronym>SSID</acronym> benötigt.</para>

      <para>Auf Rechner <systemitem>A</systemitem>:</para>

      <screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> create wlandev <replaceable>ath0</replaceable> wlanmode adhoc</userinput>
&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> inet <replaceable>192.168.0.1</replaceable> netmask <replaceable>255.255.255.0</replaceable> ssid <replaceable>freebsdap</replaceable></userinput>
&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable></userinput>
  wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
      ether 00:11:95:c3:0d:ac
      inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;adhoc&gt;
      status: running
      ssid freebsdap channel 2 (2417 Mhz 11g) bssid 02:11:95:c3:0d:ac
      country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
      protmode CTS wme burst</screen>

      <para>Der <literal>adhoc</literal>-Parameter zeigt an, dass die
	Schnittstelle im <acronym>IBSS</acronym>-Modus läuft.</para>

      <para>Rechner <systemitem>B</systemitem> sollte nun in der Lage
	sein, Rechner <systemitem>A</systemitem> zu finden:</para>

      <screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> create wlandev <replaceable>ath0</replaceable> wlanmode adhoc</userinput>
&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> up scan</userinput>
  SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS
  freebsdap       02:11:95:c3:0d:ac    2   54M -64:-96  100 IS   WME</screen>

      <para>Der Wert <literal>I</literal> (Spalte CAPS) in dieser
	Ausgabe bestätigt, dass sich Rechner
	<systemitem>A</systemitem> im Ad-hoc-Modus befindet.  Nun
	müssen Sie noch Rechner <systemitem>B</systemitem> eine andere
	<acronym>IP</acronym>-Adresse zuweisen:</para>

      <screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> inet <replaceable>192.168.0.2</replaceable> netmask <replaceable>255.255.255.0</replaceable> ssid <replaceable>freebsdap</replaceable></userinput>
&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable></userinput>
  wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;adhoc&gt;
      status: running
      ssid freebsdap channel 2 (2417 Mhz 11g) bssid 02:11:95:c3:0d:ac
      country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
      protmode CTS wme burst</screen>

      <para>Damit sind die Rechner <systemitem>A</systemitem> und
	<systemitem>B</systemitem> bereit und können untereinander
	Daten austauschen.</para>
    </sect2>

    <sect2 xml:id="network-wireless-ap">
      <title>&os; Host Access Points</title>

      <para>&os; kann als Access Point (<acronym>AP</acronym>)
	agieren.  Dies verhindert, dass man sich einen Hardware
	<acronym>AP</acronym> kaufen oder ein Ad-hoc Netzwerk laufen
	lassen muss.  Dies kann sinnvoll sein, falls der &os;-Computer
	als Gateway zu einem anderen Netzwerk, wie dem Internet,
	fungiert.</para>

      <sect3 xml:id="network-wireless-ap-basic">
	<title>Grundeinstellungen</title>

	<para>Bevor Sie einen &os;-Computer als <acronym>AP</acronym>
	  konfigurieren, muss der Kernel mit der entsprechenden
	  Netzwerkunterstützung für die drahtlose Karte, sowie die
	  Sicherheitsprotokolle konfiguriert werden.  Weitere
	  Informationen finden Sie im <xref
	    linkend="network-wireless-basic"/>.</para>

	<note>
	  <para>Die Verwendung der <acronym>NDIS</acronym> Treiber für
	    &windows; erlauben zur Zeit keinen
	    <acronym>AP</acronym>-Modus.  Nur die nativen
	    &os;-Wireless-Treiber unterstützen den
	    <acronym>AP</acronym>-Modus.</para>
	</note>

	<para>Nachdem die Netzwerkunterstützung geladen ist,
	  überprüfen Sie, ob das Wireless-Gerät den hostbasierenden
	  Access-Point Modus, der auch als hostap-Modus bekannt ist,
	  unterstützt:</para>

	<screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> create wlandev <replaceable>ath0</replaceable></userinput>
&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> list caps</userinput>
drivercaps=6f85edc1&lt;STA,FF,TURBOP,IBSS,HOSTAP,AHDEMO,TXPMGT,SHSLOT,SHPREAMBLE,MONITOR,MBSS,WPA1,WPA2,BURST,WME,WDS,BGSCAN,TXFRAG&gt;
cryptocaps=1f&lt;WEP,TKIP,AES,AES_CCM,TKIPMIC&gt;</screen>

	<para>Diese Ausgabe zeigt die Eigenschaften der Karte.  Das
	  Wort <literal>HOSTAP</literal> bestätigt, dass diese
	  Wireless-Karte als <acronym>AP</acronym> agieren kann.  Die
	  verschiedenen unterstützten Algorithmen werden ebenfalls
	  angezeigt: <acronym>WEP</acronym>,
	  <acronym>TKIP</acronym> und <acronym>AES</acronym>.  Diese
	  Informationen zeigen an, welche Sicherheitsprotokolle auf
	  dem <acronym>AP</acronym> nutzbar sind.</para>

	<para>Das Wireless-Gerät kann nur während der Erzeugung
	  des Pseudo-Geräts in den hostap-Modus gesetzt werden.
	  Zuvor erstellte Pseudo-Geräte müssen also vorher
	  zerstört werden:</para>

	<screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> destroy</userinput></screen>

	<para>Danach muss das Gerät erneut erstellt werden, bevor
	  die restlichen Netzwerkparameter konfiguriert werden
	  können:</para>

	<screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> create wlandev <replaceable>ath0</replaceable> wlanmode hostap</userinput>
&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> inet <replaceable>192.168.0.1</replaceable> netmask <replaceable>255.255.255.0</replaceable> ssid <replaceable>freebsdap</replaceable> mode 11g channel 1</userinput></screen>

	<para>Benutzen Sie danach erneut &man.ifconfig.8;, um den
	  Status der <filename>wlan0</filename>-Schnittstelle
	  abzufragen:</para>

	<screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable></userinput>
  wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
      ether 00:11:95:c3:0d:ac
      inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;hostap&gt;
      status: running
      ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
      protmode CTS wme burst dtimperiod 1 -dfs</screen>

	<para>Die <literal>hostap</literal>-Parameter geben die
	  Schnittstelle an, die im hostbasierenden Access Point Modus
	  läuft.</para>

	<para>Die Konfiguration der Schnittstelle kann durch
	  Hinzufügen der folgenden Zeilen in die Datei
	  <filename>/etc/rc.conf</filename> automatisch während
	  des Bootvorganges erfolgen:</para>

	<programlisting>wlans_ath0="wlan0"
create_args_wlan0="wlanmode hostap"
ifconfig_wlan0="inet <replaceable>192.168.0.1</replaceable> netmask <replaceable>255.255.255.0</replaceable> ssid <replaceable>freebsdap</replaceable> mode 11g channel <replaceable>1</replaceable>"</programlisting>
      </sect3>

      <sect3>
	<title>Hostbasierender Access Point ohne Authentifizierung
	  oder Verschlüsselung</title>

	<para>Obwohl es nicht empfohlen wird, einen
	  <acronym>AP</acronym> ohne jegliche
	  Authentifizierung oder Verschlüsselung laufen zu lassen,
	  ist es eine einfache Art zu testen, ob der
	  <acronym>AP</acronym> funktioniert.
	  Diese Konfiguration ist auch wichtig für die Fehlersuche
	  bei Client-Problemen.</para>

	<para>Nachdem der <acronym>AP</acronym> konfiguriert wurde,
	  ist es möglich von einem anderen drahtlosen
	  Computer eine Suche nach dem <acronym>AP</acronym> zu
	  starten:</para>

	<screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> create wlandev <replaceable>ath0</replaceable></userinput>
&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> up scan</userinput>
SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS
freebsdap       00:11:95:c3:0d:ac    1   54M -66:-96  100 ES   WME</screen>

	<para>Der Client-Rechner hat den <acronym>AP</acronym>
	  gefunden und kann nun eine Verbindung aufbauen:</para>

	<screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> inet <replaceable>192.168.0.2</replaceable> netmask <replaceable>255.255.255.0</replaceable> ssid <replaceable>freebsdap</replaceable></userinput>
&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable></userinput>
  wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/54Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode OPEN privacy OFF txpower 21.5 bmiss 7
      scanvalid 60 bgscan bgscanintvl 300 bgscanidle 250 roam:rssi 7
      roam:rate 5 protmode CTS wme burst</screen>
      </sect3>

      <sect3 xml:id="network-wireless-ap-wpa">
	<title><acronym>WPA2</acronym>-hostbasierter
	  Access Point</title>

	<para>Dieser Abschnitt beschäftigt sich mit der Konfiguration
	  eines &os; Access Point mit dem
	  <acronym>WPA2</acronym>-Sicherheitsprotokoll.  Weitere
	  Einzelheiten zu <acronym>WPA</acronym> und der Konfiguration
	  von Clients mit <acronym>WPA</acronym> finden Sie im
	  <xref linkend="network-wireless-wpa"/>.</para>

	<para>Der &man.hostapd.8;-Dienst wird genutzt,
	  um die Client-Authentifizierung und das Schlüsselmanagement
	  auf dem <acronym>AP</acronym> mit aktiviertem
	  <acronym>WPA2</acronym> zu nutzen.</para>

	<para>Die folgende Konfiguration wird auf dem
	  &os;-Computer ausgeführt, der als <acronym>AP</acronym>
	  agiert.  Nachdem der <acronym>AP</acronym> korrekt arbeitet,
	  sollte &man.hostapd.8; automatisch beim Booten durch
	  folgende Zeile in <filename>/etc/rc.conf</filename>
	  aktiviert werden:</para>

	<programlisting>hostapd_enable="YES"</programlisting>

	<para>Bevor Sie versuchen &man.hostapd.8; zu konfigurieren,
	  konfigurieren Sie zunächst die Grundeinstellungen, wie im
	  <xref linkend="network-wireless-ap-basic"/>
	  beschrieben.</para>

	<sect4>
	  <title><acronym>WPA2-PSK</acronym></title>

	  <para><acronym>WPA2-PSK</acronym> ist für kleine Netzwerke
	    gedacht, in denen die Verwendung eines
	    Authentifizierungs-Backend-Server nicht möglich oder
	    nicht erwünscht ist.</para>

	  <para>Die Konfiguration wird in
	    <filename>/etc/hostapd.conf</filename>
	    durchgeführt:</para>

	  <programlisting>interface=wlan0                  <co xml:id="co-ap-wpapsk-iface"/>
debug=1                          <co xml:id="co-ap-wpapsk-dbug"/>
ctrl_interface=/var/run/hostapd  <co xml:id="co-ap-wpapsk-ciface"/>
ctrl_interface_group=wheel       <co xml:id="co-ap-wpapsk-cifacegrp"/>
ssid=freebsdap                   <co xml:id="co-ap-wpapsk-ssid"/>
wpa=2                            <co xml:id="co-ap-wpapsk-wpa"/>
wpa_passphrase=freebsdmall       <co xml:id="co-ap-wpapsk-pass"/>
wpa_key_mgmt=WPA-PSK             <co xml:id="co-ap-wpapsk-kmgmt"/>
wpa_pairwise=CCMP                <co xml:id="co-ap-wpapsk-pwise"/></programlisting>

	  <calloutlist>
	    <callout arearefs="co-ap-wpapsk-iface">
	      <para>Die Wireless-Schnittstelle, die
		für den Access Point verwendet wird an.</para>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-dbug">
	      <para>Der debuglevel von &man.hostapd.8; während der
		Ausführung.  Ein Wert von <literal>1</literal> ist der
		kleinste zulässige Wert.</para>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-ciface">
	      <para>Der Pfadname des Verzeichnisses, der von
		&man.hostapd.8; genutzt wird, um die
		Domain-Socket-Dateien zu speichern, die für die
		Kommunikation mit externen Programmen, wie z.B.
		&man.hostapd.cli.8;, benutzt werden.  In diesem
		Beispiel wird der Standardwert verwendet.</para>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-cifacegrp">
	      <para>Die Gruppe die Zugriff auf die
		Schnittstellendateien hat.</para>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-ssid">
	      <para>Der Name des drahtlosen Netzwerks
		(<acronym>SSID</acronym>).</para>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-wpa">
	      <para>Aktiviert <acronym>WPA</acronym> und gibt an
		welches
		<acronym>WPA</acronym>-Authentifizierungprotokoll
		benötigt wird.  Ein Wert von <literal>2</literal>
		konfiguriert den <acronym>AP</acronym> mit
		<acronym>WPA2</acronym>.  Setzen Sie den Wert nur auf
		<literal>1</literal>, wenn Sie das veraltete
		<acronym>WPA</acronym> benötigen.</para>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-pass">
	      <para>Das ASCII-Passwort für die
		<acronym>WPA</acronym>-Authentifizierung.</para>

	      <warning>
		<para>Achten Sie darauf, immer starke Passwörter zu
		  verwenden, die mindestens 8 Zeichen lang sind und
		  auch Sonderzeichen enthalten, damit diese nicht
		  leicht erraten oder umgangen werden können.</para>
	      </warning>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-kmgmt">

	      <para>Das verwendete Schlüsselmanagement-Protokoll.
		Dieses Beispiel nutzt
		<acronym>WPA-PSK</acronym>.</para>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-pwise">
	      <para>Die zulässigen Verschlüsselungsverfahren des
		Access-Points.  In diesem Beispiel wird nur
		<acronym>CCMP</acronym> (<acronym>AES</acronym>)
		akzeptiert.  <acronym>CCMP</acronym> ist eine
		Alternative zu <acronym>TKIP</acronym> und
		sollte wenn möglich eingesetzt werden.
		<acronym>TKIP</acronym> sollte nur da eingesetzt
		werden, wo kein <acronym>CCMP</acronym> möglich
		ist.</para>
	    </callout>
	  </calloutlist>

	  <para>Als nächstes wird <application>hostapd</application>
	    gestartet:</para>

	  <screen>&prompt.root; <userinput>service hostapd forcestart</userinput></screen>

	  <screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable></userinput>
wlan0: flags=8943&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	ether 04:f0:21:16:8e:10
	inet6 fe80::6f0:21ff:fe16:8e10%wlan0 prefixlen 64 scopeid 0x9
	nd6 options=21&lt;PERFORMNUD,AUTO_LINKLOCAL&gt;
	media: IEEE 802.11 Wireless Ethernet autoselect mode 11na &lt;hostap&gt;
	status: running
	ssid No5ignal channel 36 (5180 MHz 11a ht/40+) bssid 04:f0:21:16:8e:10
	country US ecm authmode WPA2/802.11i privacy MIXED deftxkey 2
	AES-CCM 2:128-bit AES-CCM 3:128-bit txpower 17 mcastrate 6 mgmtrate 6
	scanvalid 60 ampdulimit 64k ampdudensity 8 shortgi wme burst
	dtimperiod 1 -dfs
	groups: wlan</screen>

	  <para>Sobald der <acronym>AP</acronym> läuft, können sich
	    die Clients mit ihm verbinden.  Weitere Informationen
	    finden Sie im <xref linkend="network-wireless-wpa"/>.  Es
	    ist möglich zu sehen, welche Stationen mit dem
	    <acronym>AP</acronym> verbunden sind.  Geben Sie dazu
	    <command>ifconfig
	      <replaceable>wlan0</replaceable> list sta</command>
	    ein.</para>
	</sect4>
      </sect3>

      <sect3>
	<title><acronym>WEP</acronym>-hostbasierter
	  Access Point</title>

	<para>Es ist nicht empfehlenswert, einen
	  <acronym>AP</acronym> mit <acronym>WEP</acronym> zu
	  konfigurieren, da es keine Authentifikationsmechanismen
	  gibt und <acronym>WEP</acronym> leicht zu knacken ist.
	  Einige ältere drahtlose Karten unterstützen nur
	  <acronym>WEP</acronym> als Sicherheitsprotokoll.  Diese
	  Karten können nur mit einem <acronym>AP</acronym> ohne
	  Authentifikation oder Verschlüsselung genutzt
	  werden.</para>

	<para>Das Wireless-Gerät kann nun in den hostap-Modus
	  versetzt werden und mit der korrekten
	  <acronym>SSID</acronym> und <acronym>IP</acronym>-Adresse
	  konfiguriert werden:</para>

	<screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> create wlandev <replaceable>ath0</replaceable> wlanmode hostap</userinput>
&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> inet <replaceable>192.168.0.1</replaceable> netmask <replaceable>255.255.255.0</replaceable> \
  ssid <replaceable>freebsdap</replaceable> wepmode on weptxkey <replaceable>3</replaceable> wepkey <replaceable>3:0x3456789012</replaceable> mode 11g</userinput></screen>

	<itemizedlist>
	  <listitem>
	    <para>Der <literal>weptxkey</literal> zeigt an,
	      welcher <acronym>WEP</acronym>-Schlüssel bei der
	      Übertragung benutzt wird.  In diesem Beispiel wird der
	      dritte Schlüssel benutzt, da die Nummerierung bei
	      <literal>1</literal> beginnt.  Dieser Parameter muss
	      angegeben werden, damit die Daten verschlüsselt
	      werden.</para>
	  </listitem>

	  <listitem>
	    <para>Der <literal>wepkey</literal> gibt den
	      gewählten <acronym>WEP</acronym>-Schlüssel an.  Er
	      sollte im folgenden Format
	      <replaceable>index:key</replaceable> vorliegen.  Wenn
	      kein Index vorhanden ist, wird der Schlüssel
	      <literal>1</literal> benutzt.  Ansonsten muss der
	      Index manuell festgelegt werden.</para>
	  </listitem>
	</itemizedlist>

	<para>Benutzen Sie &man.ifconfig.8; um den Status der
	  <filename>wlan0</filename>-Schnittstelle erneut
	  anzuzeigen:</para>

	<screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable></userinput>
  wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
      ether 00:11:95:c3:0d:ac
      inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;hostap&gt;
      status: running
      ssid freebsdap channel 4 (2427 Mhz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode OPEN privacy ON deftxkey 3 wepkey 3:40-bit
      txpower 21.5 scanvalid 60 protmode CTS wme burst dtimperiod 1 -dfs</screen>

	<para>Es ist möglich, von einem anderen drahtlosen
	  Computer eine Suche nach dem <acronym>AP</acronym> zu
	  starten:</para>

	<screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> create wlandev <replaceable>ath0</replaceable></userinput>
&prompt.root; <userinput>ifconfig wlan0 up scan</userinput>
SSID            BSSID              CHAN RATE  S:N   INT CAPS
freebsdap       00:11:95:c3:0d:ac    1   54M 22:1   100 EPS</screen>

	<para>Der Client-Rechner hat den <acronym>AP</acronym>
	  gefunden und kann nun eine Verbindung aufbauen.  Weitere
	  Informationen finden Sie im <xref
	    linkend="network-wireless-wep"/>.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Benutzung von drahtgebundenen und drahtlosen
	Verbindungen</title>

      <para>Eine Verbindung per Kabel bietet eine bessere Leistung
	und eine höhere Zuverlässigkeit, während die
	Wireless-Verbindung eine höhere Flexibilität und Mobilität
	bietet.  Benutzer von Laptops wollen normalerweise beides
	nutzen und zwischen beiden Verbindungen hin und her
	schalten.</para>

      <para>Unter &os; ist es möglich zwei oder mehr
	Netzwerkschnittstellen in einem <quote>failover</quote>-Mode
	zu kombinieren.  Diese Konfiguration nutzt die beste
	verfügbare Verbindung aus einer Gruppe von
	Netzwerkverbindungen.  Sobald sich der Linkstatus ändert,
	wechselt das Betriebssystem automatisch auf eine andere
	Verbindung.</para>

      <para>Link-Aggregation und Failover werden im <xref
	  linkend="network-aggregation"/> behandelt.  Ein Beispiel
	für die Verwendung von kabelgebundenen und drahtlosen
	Verbindungen gibt es im <xref
	  linkend="networking-lagg-wired-and-wireless"/>.</para>
    </sect2>

    <sect2>
      <title>Problembehandlung</title>

      <para>Dieser Abschnitt beschreibt eine Reihe von Maßnahmen zur
	Behebung von alltäglichen Problemen mit
	Drahtlosnetzwerken.</para>

      <itemizedlist>
	<listitem>
	  <para>Wird der Access Point bei der Suche nicht gefunden,
	    überprüfen Sie, dass die Konfiguration des drahtlosen
	    Geräts nicht die Anzahl der Kanäle beschränkt.</para>
	</listitem>

	<listitem>
	  <para>Wenn sich das Gerät nicht mit dem Access Point
	    verbinden kann, überprüfen Sie, ob die Konfiguration der
	    Station auch der des Access Points entspricht.  Dazu
	    gehören auch die Authentifzierungsmethode und die
	    Sicherheitsprotokolle.  Halten Sie die Konfiguration so
	    einfach wie möglich.  Wenn Sie ein Sicherheitsprotokoll
	    wie <acronym>WPA</acronym> oder <acronym>WEP</acronym>
	    verwenden, können Sie testweise den Access Point auf
	    <emphasis>offene Authentifizierung</emphasis> und
	    <emphasis>keine Sicherheit</emphasis> einstellen.</para>

	  <para>Für die Fehlersuche steht &man.wpa.supplicant.8;
	    zur Verfügung.  Starten Sie das Programm  manuell mit der
	    Option <option>-dd</option> und durchsuchen Sie
	    anschließend die Systemprotokolle nach eventuellen
	    Fehlermeldungen.</para>
	</listitem>

	<listitem>
	  <para>Sobald sich das Gerät mit dem Access Point verbinden
	    kann, prüfen Sie die Netzwerkkonfiguration mit
	    einfachen Werkzeugen wie &man.ping.8;.</para>
	</listitem>

	<listitem>
	  <para>Zusätzlich gibt es auch zahlreiche
	    Low-Level-Debugging-Werkzeuge.  Die Ausgabe von
	    Debugging-Informationen des 802.11 Protocol Support Layers
	    lassen sich mit dem Programm &man.wlandebug.8; aktivieren.
	    Um beispielsweise während der Suche nach Access Points und
	    des Aufbaus von 802.11-Verbindungen
	    (<foreignphrase>Handshake</foreignphrase>) auftretende
	    Systemmeldungen auf die Konsole auszugeben, verwenden
	    Sie den folgenden Befehl:</para>

	  <screen>&prompt.root; <userinput>wlandebug -i <replaceable>wlan0</replaceable> +scan+auth+debug+assoc</userinput>
  net.wlan.0.debug: 0 =&gt; 0xc80000&lt;assoc,auth,scan&gt;</screen>

	  <para>Der 802.11-Layer liefert umfangreiche Statistiken,
	    die mit dem Werkzeug <command>wlanstats</command>, das
	    sich in
	    <filename>/usr/src/tools/tools/net80211</filename>
	    befindet, abgerufen werden können.  Diese Statistiken
	    sollten alle Fehler identifizieren, die im 802.11-Layer
	    auftreten.  Beachten Sie aber, dass einige Fehler bereits
	    im darunterliegenden Gerätetreiber auftreten und
	    daher in diesen Statistiken nicht enthalten sind.  Wie
	    Sie Probleme des Gerätetreibers identifizieren,
	    entnehmen Sie bitte der Dokumentation des
	    Gerätetreibers.</para>
	</listitem>
      </itemizedlist>

      <para>Wenn die oben genannten Informationen nicht helfen das
	Problem zu klären, erstellen Sie einen Problembericht, der die
	Ausgabe der weiter oben genannten Werkzeuge beinhaltet.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="network-usb-tethering">
    <info>
      <title>USB Tethering</title>
    </info>

    <indexterm>
      <primary>tether</primary>
    </indexterm>

    <para>Viele Mobiltelefone bieten die Möglichkeit, ihre
      Datenverbindung über USB (oft "Tethering" genannt) zu
      teilen.  Diese Funktion verwendet entweder das
      <acronym>RNDIS</acronym>-, <acronym>CDC</acronym>- oder ein
      &apple; &iphone;/&ipad;-Protokoll.</para>

    <itemizedlist>
      <listitem>
	<para>&android;-Geräte benutzen in der Regel den
	  &man.urndis.4;-Treiber.</para>
      </listitem>

      <listitem>
	<para>&apple;-Geräte benutzen den
	  &man.ipheth.4;-Treiber.</para>
      </listitem>

      <listitem>
	<para>Ältere Geräte benutzen oft den
	  &man.cdce.4;-Treiber.</para>
      </listitem>
    </itemizedlist>

    <para>Bevor Sie ein Gerät anschließen, laden Sie den
      entsprechenden Treiber in den Kernel:</para>

    <screen>&prompt.root; <userinput>kldload if_urndis</userinput>
&prompt.root; <userinput>kldload if_cdce</userinput>
&prompt.root; <userinput>kldload if_ipheth</userinput></screen>

    <para>Sobald das Gerät angeschlossen ist, steht es
      unter <literal>ue</literal><replaceable>0</replaceable>
      wie ein normales Netzwerkgerät zur Verfügung.
      Stellen Sie sicher, dass die Option
      <quote>USB Tethering</quote> auf dem Gerät
      aktiviert ist.</para>
  </sect1>

  <sect1 xml:id="network-bluetooth">
    <info>
      <title>Bluetooth</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Pav</firstname>
	    <surname>Lucistnik</surname>
	  </personname>
	  <contrib>Beigetragen von </contrib>
	  <email>pav@FreeBSD.org</email>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>Bluetooth</primary>
    </indexterm>

    <para>Bluetooth ermöglicht die Bildung von persönlichen
      Netzwerken über drahtlose Verbindungen bei einer maximalen
      Reichweite von 10 Metern und operiert im unlizensierten
      2,4-GHz-Band.  Solche Netzwerke werden normalerweise spontan
      gebildet, wenn sich mobile Geräte, wie Mobiltelefone,
      Handhelds oder Notebooks miteinander verbinden.  Im Gegensatz
      zu Wireless LAN ermöglicht Bluetooth auch höherwertige
      Dienste, wie <acronym>FTP</acronym>-ähnliche Dateiserver,
      Filepushing, Sprachübertragung, Emulation von seriellen
      Verbindungen und mehr.</para>

    <para>Dieses Kapitel beschreibt die Verwendung von
      <acronym>USB</acronym>-Bluetooth-Adaptern in &os;.  Weiterhin
      werden verschiedene Bluetooth-Protokolle und Programme
      vorgestellt.</para>

    <sect2>
      <title>Die Bluetooth-Unterstützung aktivieren</title>

      <para>Der Bluetooth-Stack von &os; verwendet das
	&man.netgraph.4;-Framework.  Viele
	Bluetooth-<acronym>USB</acronym>-Adapter werden durch den
	&man.ng.ubt.4;-Treiber unterstützt.  Auf dem Chip BCM2033
	von Broadcom basierende Bluetooth-Geräte werden von den
	Treibern &man.ubtbcmfw.4; sowie &man.ng.ubt.4; unterstützt.
	Die Bluetooth-PC-Card 3CRWB60-A von 3Com verwendet den
	&man.ng.bt3c.4;-Treiber.  Serielle sowie auf UART basierende
	Bluetooth-Geräte werden von &man.sio.4;, &man.ng.h4.4;
	sowie &man.hcseriald.8; unterstützt.</para>

      <para>Bevor ein Gerät angeschlossen wird, muss der entsprechende
	Treiber in den Kernel geladen werden.  Hier verwendet das
	Gerät den &man.ng.ubt.4;-Treiber:</para>

      <screen>&prompt.root; <userinput>kldload ng_ubt</userinput></screen>

      <para>Ist das Bluetooth-Gerät beim Systemstart angeschlossen,
	kann das entsprechende Modul bei Booten geladen werden, indem
	der entsprechende Treiber in
	<filename>/boot/loader.conf</filename> hinzugefügt
	wird:</para>

      <programlisting>ng_ubt_load="YES"</programlisting>

      <para>Sobald der Treiber geladen ist, schließen Sie den
	<acronym>USB</acronym>-Adapter an.  Eine Meldung ähnlich der
	folgenden wird auf der Konsole und in
	<filename>/var/log/messages</filename> erscheinen:</para>

      <screen>ubt0: vendor 0x0a12 product 0x0001, rev 1.10/5.25, addr 2
ubt0: Interface 0 endpoints: interrupt=0x81, bulk-in=0x82, bulk-out=0x2
ubt0: Interface 1 (alt.config 5) endpoints: isoc-in=0x83, isoc-out=0x3,
      wMaxPacketSize=49, nframes=6, buffer size=294</screen>

      <para>Verwenden Sie das Startskript zum Starten und Beenden des
	Bluetooth-Stacks.  Es ist empfehlenswert, den Bluetooth-Stack
	zu beenden, bevor Sie den Adapter entfernen.  Wenn Sie den
	Bluetooth-Stack starten, erhalten Sie eine Meldung ähnlich
	der folgenden:</para>

      <screen>&prompt.root; <userinput>service bluetooth start ubt0</userinput>
BD_ADDR: 00:02:72:00:d4:1a
Features: 0xff 0xff 0xf 00 00 00 00 00
&lt;3-Slot&gt; &lt;5-Slot&gt; &lt;Encryption&gt; &lt;Slot offset&gt;
&lt;Timing accuracy&gt; &lt;Switch&gt; &lt;Hold mode&gt; &lt;Sniff mode&gt;
&lt;Park mode&gt; &lt;RSSI&gt; &lt;Channel quality&gt; &lt;SCO link&gt;
&lt;HV2 packets&gt; &lt;HV3 packets&gt; &lt;u-law log&gt; &lt;A-law log&gt; &lt;CVSD&gt;
&lt;Paging scheme&gt; &lt;Power control&gt; &lt;Transparent SCO data&gt;
Max. ACL packet size: 192 bytes
Number of ACL packets: 8
Max. SCO packet size: 64 bytes
Number of SCO packets: 8</screen>
    </sect2>

    <sect2>
      <title>Suche nach anderen Bluetooth-Geräten</title>

      <indexterm>
	<primary>HCI</primary>
      </indexterm>

      <para>Das
	<foreignphrase>Host Controller Interface</foreignphrase>
	(<acronym>HCI</acronym>) bietet eine einheitliche Methode für
	den Zugriff auf Bluetooth-Basisband-Funktionen.  In &os; wird
	ein netgraph <acronym>HCI</acronym>-Knoten für jedes
	Bluetooth-Gerät erstellt.  Weitere Einzelheiten finden Sie in
	&man.ng.hci.4;.</para>

      <para>Eine der wichtigsten Aufgaben ist das Auffinden von sich
	in Reichweite befindenden Bluetooth-Geräten.  Diese
	Funktion wird als <emphasis>inquiry</emphasis> bezeichnet.
	Inquiry sowie andere mit <acronym>HCI</acronym> in Verbindung
	stehende Funktionen werden von &man.hccontrol.8; zur Verfügung
	gestellt.  Das folgende Beispiel zeigt, wie man herausfindet,
	welche Bluetooth-Geräte sich in Reichweite befinden.  Eine
	solche Abfrage dauert nur wenige Sekunden.  Beachten Sie, dass
	ein Gerät nur dann antwortet, wenn es sich im Modus
	<emphasis>discoverable</emphasis> befindet.</para>

      <screen>&prompt.user; <userinput>hccontrol -n ubt0hci inquiry</userinput>
Inquiry result, num_responses=1
Inquiry result #0
       BD_ADDR: 00:80:37:29:19:a4
       Page Scan Rep. Mode: 0x1
       Page Scan Period Mode: 00
       Page Scan Mode: 00
       Class: 52:02:04
       Clock offset: 0x78ef
Inquiry complete. Status: No error [00]</screen>

      <para><literal>BD_ADDR</literal> stellt, ähnlich der
	<acronym>MAC</acronym>-Adresse einer Netzwerkkarte, die
	eindeutige Adresse eines Bluetooth-Gerätes dar.  Diese Adresse
	ist für die Kommunikation mit dem Gerät nötig.  Es ist aber
	auch möglich, BD_ADDR einen Klartextnamen zuzuweisen.
	<filename>/etc/bluetooth/hosts</filename> enthält
	Informationen über die bekannten Bluetooth-Rechner.  Das
	folgende Beispiel zeigt, wie man den Klartextnamen eines
	entfernten Geräts in Erfahrung bringen kann:</para>

      <screen>&prompt.user; <userinput>hccontrol -n ubt0hci remote_name_request 00:80:37:29:19:a4</userinput>
BD_ADDR: 00:80:37:29:19:a4
Name: Pav's T39</screen>

      <para>Wenn Sie ein entferntes Bluetooth-Gerät abfragen, wird
	dieses den Rechner unter dem Namen
	<quote>your.host.name (ubt0)</quote> finden.  Dieser Name kann
	aber jederzeit geändert werden.</para>

      <para>Bluetooth ermöglicht Punkt-zu-Punkt-Verbindungen an
	denen nur zwei Bluetooth-Geräte beteiligt sind, aber auch
	Punkt-zu-Multipunkt-Verbindungen, bei denen eine Verbindung
	von mehreren Bluetooth-Geräten gemeinsam genutzt wird.  Das
	folgende Beispiel zeigt, wie man die aktiven
	Basisbandverbindungen des lokalen Gerätes anzeigen
	kann:</para>

      <screen>&prompt.user; <userinput>hccontrol -n ubt0hci read_connection_list</userinput>
Remote BD_ADDR    Handle Type Mode Role Encrypt Pending Queue State
00:80:37:29:19:a4     41  ACL    0 MAST    NONE       0     0 OPEN</screen>

      <para>Ein <emphasis>connection handle</emphasis> ist für die
	Beendigung einer Basisbandverbindung nützlich.  Im
	Normalfall werden inaktive Verbindungen aber automatisch vom
	Bluetooth-Stack getrennt.</para>

      <screen>&prompt.root; <userinput>hccontrol -n ubt0hci disconnect 41</userinput>
Connection handle: 41
Reason: Connection terminated by local host [0x16]</screen>

      <para>Rufen Sie <command>hccontrol help</command> auf, wenn Sie
	eine komplette Liste aller verfügbaren
	<acronym>HCI</acronym>-Befehle benötigen.  Die meisten dieser
	Befehle müssen nicht als <systemitem
	  class="username">root</systemitem> ausgeführt werden.</para>
    </sect2>

    <sect2>
      <title>Erstmaliger Verbindungsaufbau zwischen zwei
	Bluetooth-Geräten (<foreignphrase>Pairing</foreignphrase>)
      </title>

      <indexterm>
	<primary>Pairing</primary>
      </indexterm>

      <para>In der Voreinstellung nutzt Bluetooth keine
	Authentifizierung, daher kann sich jedes Bluetoothgerät mit
	jedem anderen Gerät verbinden.  Ein Bluetoothgerät, wie
	beispielsweise ein Mobiltelefon, kann jedoch für einen
	bestimmten Dienst, etwa eine Einwählverbindung, eine
	Authentifizierung anfordern.  Bluetooth verwendet zu diesem
	Zweck <emphasis><acronym>PIN</acronym>-Codes</emphasis>.  Ein
	<acronym>PIN</acronym>-Code ist ein maximal 16 Zeichen langer
	ASCII-String.  Damit eine Verbindung zustande kommt, muss auf
	beiden Geräten der gleiche <acronym>PIN</acronym>-Code
	verwendet werden.  Nachdem der Code eingegeben wurde, erzeugen
	beide Geräte einen <emphasis>link key</emphasis>,
	der auf den Geräten gespeichert wird.  Beim nächsten
	Verbindungsaufbau wird der zuvor erzeugte Link Key verwendet.
	Diesen Vorgang bezeichnet man als
	<foreignphrase>Pairing</foreignphrase>.  Geht der Link Key auf
	einem Gerät verloren, muss das Pairing wiederholt
	werden.</para>

      <para>Der &man.hcsecd.8;-Daemon verarbeitet
	Bluetooth-Authentifzierungsanforderungen und wird über die
	Datei <filename>/etc/bluetooth/hcsecd.conf</filename>
	konfiguriert.  Der folgende Ausschnitt dieser Datei zeigt die
	Konfiguration für ein Mobiltelefon, das den
	<acronym>PIN</acronym>-Code <quote>1234</quote>
	verwendet:</para>

      <programlisting>device {
        bdaddr  00:80:37:29:19:a4;
        name    "Pav's T39";
        key     nokey;
        pin     "1234";
      }</programlisting>

      <para>Von der Länge abgesehen, unterliegen
	<acronym>PIN</acronym>-Codes keinen Einschränkungen.  Einige
	Geräte, beispielsweise Bluetooth-Headsets, haben einen festen
	<acronym>PIN</acronym>-Code eingebaut.  Die Option
	<option>-d</option> sorgt dafür, dass der
	&man.hcsecd.8;-Daemon im Vordergrund läuft.  Dadurch kann
	der Ablauf einfach verfolgt werden.  Stellen Sie das entfernte
	Gerät auf <foreignphrase>receive pairing</foreignphrase>
	und initiieren Sie die Bluetoothverbindung auf dem entfernten
	Gerät.  Sie erhalten die Meldung, dass Pairing akzeptiert
	wurde und der <acronym>PIN</acronym>-Code benötigt wird.
	Geben Sie den gleichen <acronym>PIN</acronym>-Code ein, den
	Sie in <filename>hcsecd.conf</filename> festgelegt haben.  Der
	Computer und das entfernte Gerät sind nun miteinander
	verbunden.  Alternativ können Sie das Pairing auch auf dem
	entfernten Gerät initiieren.</para>

      <para>&man.hcsecd.8; kann durch das Einfügen
	der folgenden Zeile in <filename>/etc/rc.conf</filename>
	beim Systemstart automatisch aktiviert werden:</para>

      <programlisting>hcsecd_enable="YES"</programlisting>

      <para>Es folgt nun eine beispielhafte Ausgabe
	des &man.hcsecd.8;-Daemons:</para>

      <programlisting>hcsecd[16484]: Got Link_Key_Request event from 'ubt0hci', remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name 'Pav's T39', link key doesn't exist
hcsecd[16484]: Sending Link_Key_Negative_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Got PIN_Code_Request event from 'ubt0hci', remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name 'Pav's T39', PIN code exists
hcsecd[16484]: Sending PIN_Code_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4</programlisting>
    </sect2>

    <sect2>
      <title>Einwahlverbindungen und Netzwerkverbindungen mit
	<acronym>PPP</acronym>-Profilen einrichten</title>

      <para>Ein
	<foreignphrase>Dial-Up Networking</foreignphrase>-Profil
	(<acronym>DUN</acronym>) kann dazu benutzt werden, ein
	Mobiltelefon als drahtloses Modem zu nutzen, um sich über
	einen Einwahlprovider mit dem Internet zu verbinden.  Es
	kann auch dazu genutzt werden, einen Computer so zu
	konfigurieren, dass dieser Datenabfragen empfängt.</para>

      <para>Der Zugriff auf ein Netzwerk über ein
	<acronym>PPP</acronym>-Profil kann einen Zugriff auf das
	<acronym>LAN</acronym> für ein oder mehrere Bluetooth-Geräte
	bieten.  Eine
	<acronym>PC</acronym>-zu-<acronym>PC</acronym>-Verbindung
	unter Verwendung einer <acronym>PPP</acronym>-Verbindung
	über eine serielle Verbindung ist ebenfalls möglich.</para>

      <para>Diese Profile werden unter &os; durch &man.ppp.8; sowie
	&man.rfcomm.pppd.8; implementiert - einem Wrapper, der
	Bluetooth-Verbindungen unter
	<acronym>PPP</acronym> nutzbar macht.  Bevor ein Profil
	verwendet werden kann, muss ein neuer
	<acronym>PPP</acronym>-Abschnitt in
	<filename>/etc/ppp/ppp.conf</filename> erzeugt werden.
	Beispielkonfigurationen zu diesem Thema finden Sie in
	&man.rfcomm.pppd.8;.</para>

      <para>Dieses Beispiel verwendet &man.rfcomm.pppd.8;, um
	eine Verbindung zu einem entfernten Gerät mit der
	<literal>BD_ADDR</literal>
	<literal>00:80:37:29:19:a4</literal> auf
	dem <acronym>RFCOMM</acronym>-Kanal <literal>DUN</literal>
	aufzubauen:</para>

      <screen>&prompt.root; <userinput>rfcomm_pppd -a 00:80:37:29:19:a4 -c -C dun -l rfcomm-dialup</userinput></screen>

      <para>Die aktuelle Kanalnummer des entfernten Geräts erhalten
	Sie über das <acronym>SDP</acronym>-Protokoll.  Es ist auch
	möglich, manuell einen <acronym>RFCOMM</acronym>-Kanal
	festzulegen.  In diesem Fall führt &man.rfcomm.pppd.8; keine
	<acronym>SDP</acronym>-Abfrage durch.  Verwenden Sie
	&man.sdpcontrol.8;, um die <acronym>RFCOMM-Kanäle</acronym>
	des entfernten Geräts herauszufinden.</para>

      <para>Der &man.sdpd.8;-Server muss laufen, damit ein Netzzugriff
	mit dem <acronym>PPP</acronym> <acronym>LAN</acronym>-Profil
	möglich ist.  Außerdem muss für den
	<acronym>LAN</acronym>-Client ein neuer Eintrag in
	<filename>/etc/ppp/ppp.conf</filename> erzeugt werden.
	Beispielkonfigurationen zu diesem Thema finden Sie in
	&man.rfcomm.pppd.8;.  Danach starten Sie den
	<acronym>RFCOMM</acronym> <acronym>PPP</acronym>-Server
	über eine gültige <acronym>RFCOMM</acronym>-Kanalnummer.
	Der <acronym>RFCOMM</acronym> <acronym>PPP</acronym>-Server
	bindet dadurch den Bluetooth-<acronym>LAN</acronym>-Dienst an
	den lokalen <acronym>SDP</acronym>-Daemon.  Das folgende
	Beispiel zeigt, wie man den <acronym>RFCOMM</acronym>
	<acronym>PPP</acronym>-Server startet.</para>

      <screen>&prompt.root; <userinput>rfcomm_pppd -s -C 7 -l rfcomm-server</userinput></screen>
    </sect2>

    <sect2>
      <title>Bluetooth-Protokolle</title>

      <para>Dieser Abschnitt gibt einen Überblick über die
	verschiedenen Bluetooth-Protokolle, ihre Funktionen sowie
	weitere Programme.</para>

      <sect3>
	<title>Das Logical Link Control and Adaptation Protocol
	  (<acronym>L2CAP</acronym>)</title>

	<indexterm>
	  <primary>L2CAP</primary>
	</indexterm>

	<para>Das <foreignphrase>Logical Link Control and Adaptation
	  Protocol</foreignphrase> (<acronym>L2CAP</acronym>) bietet
	  höherwertigen Protokollen verbindungsorientierte und
	  verbindungslose Datendienste an.  <acronym>L2CAP</acronym>
	  erlaubt höherwertigen Protokollen und Programmen den Versand
	  und Empfang von <acronym>L2CAP</acronym>-Datenpaketen mit
	  einer Länge von bis zu 64 Kilobytes.</para>

	<para><acronym>L2CAP</acronym> arbeitet
	  <emphasis>kanal</emphasis>basiert.  Ein Kanal ist eine
	  logische Verbindung innerhalb einer Basisbandverbindung.
	  Jeder Kanal ist dabei an ein einziges Protokoll gebunden.
	  Mehrere Geräte können an das gleiche Protokoll gebunden
	  sein, es ist aber nicht möglich, einen Kanal an mehrere
	  Protokolle zu binden.  Jedes über einen Kanal ankommende
	  <acronym>L2CAP</acronym>-Paket wird an das entsprechende
	  höherwertige Protokoll weitergeleitet.  Mehrere Kanäle
	  können sich die gleiche Basisbandverbindung teilen.</para>

	<para>Unter &os; wird eine netgraph-Gerätedatei vom Typ
	  <emphasis>l2cap</emphasis> für jedes einzelne
	  Bluetooth-Gerät erzeugt.  Diese Gerätedatei ist
	  normalerweise mit der
	  Bluetooth-<acronym>HCI</acronym>-Gerätedatei (downstream)
	  sowie der Bluetooth-Socket-Gerätedatei (upstream) verbunden.
	  Der Standardname für die
	  <acronym>L2CAP</acronym>-Gerätedatei lautet
	  <quote>devicel2cap</quote>.  Weitere Details finden Sie in
	  &man.ng.l2cap.4;.</para>

	<para>Ein nützlicher Befehl zum Anpingen von anderen
	  Geräten ist &man.l2ping.8;.  Einige Bluetooth-Geräte
	  senden allerdings nicht alle erhaltenen Daten zurück.  Die
	  Ausgabe <literal>0 bytes</literal> im folgenden Beispiel ist
	  also kein Fehler:</para>

	<screen>&prompt.root; <userinput>l2ping -a 00:80:37:29:19:a4</userinput>
0 bytes from 0:80:37:29:19:a4 seq_no=0 time=48.633 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=1 time=37.551 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=2 time=28.324 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=3 time=46.150 ms result=0</screen>

	<para>Das Programm &man.l2control.8; liefert Informationen
	  über <acronym>L2CAP</acronym>-Dateien.  Das folgende
	  Beispiel zeigt, wie man die Liste der logischen Verbindungen
	  (Kanäle) sowie die Liste der Basisbandverbindungen abfragen
	  kann:</para>

	<screen>&prompt.user; <userinput>l2control -a 00:02:72:00:d4:1a read_channel_list</userinput>
L2CAP channels:
Remote BD_ADDR     SCID/ DCID   PSM  IMTU/ OMTU State
00:07:e0:00:0b:ca    66/   64     3   132/  672 OPEN
&prompt.user; <userinput>l2control -a 00:02:72:00:d4:1a read_connection_list</userinput>
L2CAP connections:
Remote BD_ADDR    Handle Flags Pending State
00:07:e0:00:0b:ca     41 O           0 OPEN</screen>

	<para>&man.btsockstat.1; ist ein weiteres Diagnoseprogramm.
	  Es funktioniert ähnlich wie &man.netstat.1;, arbeitet aber
	  mit Bluetooth-Datenstrukturen.  Das folgende Beispiel zeigt
	  die gleiche Liste der logischen Verbindungen wie
	  &man.l2control.8; im vorherigen Beispiel.</para>

	<screen>&prompt.user; <userinput>btsockstat</userinput>
Active L2CAP sockets
PCB      Recv-Q Send-Q Local address/PSM       Foreign address   CID   State
c2afe900      0      0 00:02:72:00:d4:1a/3     00:07:e0:00:0b:ca 66    OPEN
Active RFCOMM sessions
L2PCB    PCB      Flag MTU   Out-Q DLCs State
c2afe900 c2b53380 1    127   0     Yes  OPEN
Active RFCOMM sockets
PCB      Recv-Q Send-Q Local address     Foreign address   Chan DLCI State
c2e8bc80      0    250 00:02:72:00:d4:1a 00:07:e0:00:0b:ca 3    6    OPEN</screen>
      </sect3>

      <sect3>
	<title>Radio Frequency Communication
	  (<acronym>RFCOMM</acronym>)</title>

	<indexterm>
	  <primary>RFCOMM</primary>
	</indexterm>

	<para>Das <acronym>RFCOMM</acronym>-Protokoll emuliert
	  serielle Verbindungen über das
	  <acronym>L2CAP</acronym>-Protokoll.  Bei
	  <acronym>RFCOMM</acronym> handelt es sich um ein einfaches
	  Transportprotokoll, das um Funktionen zur Emulation der
	  9poligen Schaltkreise von mit RS-232 (EIATIA-232-E)
	  kompatiblen seriellen Ports ergänzt wurde.  Es erlaubt bis
	  zu 60 simultane Verbindungen
	  (<acronym>RFCOMM</acronym>-Kanäle) zwischen zwei
	  Bluetooth-Geräten.</para>

	<para>Eine <acronym>RFCOMM</acronym>-Kommunikation besteht aus
	  zwei Anwendungen (den Kommunikationsendpunkten), die über
	  das Kommunikationssegment miteinander verbunden sind.
	  <acronym>RFCOMM</acronym> unterstützt Anwendungen, die auf
	  serielle Ports angewiesen sind.  Das Kommunikationssegment
	  entspricht der direkten Bluetooth-Verbindung zwischen den
	  beiden Geräten.</para>

	<para><acronym>RFCOMM</acronym> kümmert sich um die direkte
	  Verbindung von zwei Geräten, oder um die Verbindung zwischen
	  einem Gerät und einem Modem über eine Netzwerkverbindung.
	  <acronym>RFCOMM</acronym> unterstützt auch andere
	  Konfigurationen.  Ein Beispiel dafür sind
	  Module, die drahtlose Bluetooth-Geräte mit einer
	  verkabelten Schnittstelle verbinden können.</para>

	<para>Unter &os; ist das <acronym>RFCOMM</acronym>-Protokoll
	  im Bluetooth Socket-Layer implementiert.</para>
      </sect3>

      <sect3>
	<title>Das Service Discovery Protocol
	  (<acronym>SDP</acronym>)</title>

	<indexterm>
	  <primary>SDP</primary>
	</indexterm>

	<para>Das
	  <foreignphrase>Service Discovery Protocol</foreignphrase>
	  (<acronym>SDP</acronym>) erlaubt es Clientanwendungen, von
	  Serveranwendungen angebotene Dienste sowie deren
	  Eigenschaften abzufragen.  Zu diesen Eigenschaften gehören
	  die Art oder die Klasse der angebotenen Dienste sowie der
	  Mechanismus oder das Protokoll, die zur Nutzung des Dienstes
	  notwendig sind.</para>

	<para><acronym>SDP</acronym> ermöglicht Verbindungen zwischen
	  einem <acronym>SDP</acronym>-Server und einem
	  <acronym>SDP</acronym>-Client.  Der Server enthält eine
	  Liste mit den Eigenschaften der vom Server angebotenen
	  Dienste.  Jeder Eintrag beschreibt jeweils einen einzigen
	  Serverdienst.  Ein Client kann diese Informationen durch
	  eine <acronym>SDP</acronym>-Anforderung vom
	  <acronym>SDP</acronym>-Server beziehen.  Wenn der Client
	  oder eine Anwendung des Clients einen Dienst nutzen will,
	  muss eine separate Verbindung mit dem Dienstanbieter
	  aufgebaut werden.  <acronym>SDP</acronym> bietet einen
	  Mechanismus zum Auffinden von Diensten und deren
	  Eigenschaften an, es bietet aber keine Mechanismen zur
	  Verwendung dieser Dienste.</para>

	<para>Normalerweise sucht ein <acronym>SDP</acronym>-Client
	  nur nach Diensten, die bestimmte geforderte Eigenschaften
	  erfüllen.  Es ist aber auch möglich, anhand der
	  Dienstbeschreibungen eine allgemeine Suche nach den von
	  einem <acronym>SDP</acronym>-Server angebotenen Diensten
	  durchzuführen.  Diesen Vorgang bezeichnet man als
	  <foreignphrase>Browsing</foreignphrase>.</para>

	<para>Der Bluetooth-<acronym>SDP</acronym>-Server &man.sdpd.8;
	  und der Kommandozeilenclient &man.sdpcontrol.8; sind bereits
	  in der Standardinstallation von &os; enthalten.  Das
	  folgende Beispiel zeigt, wie eine
	  <acronym>SDP</acronym>-Abfrage durchgeführt wird:</para>

	<screen>&prompt.user; <userinput>sdpcontrol -a 00:01:03:fc:6e:ec browse</userinput>
Record Handle: 00000000
Service Class ID List:
        Service Discovery Server (0x1000)
Protocol Descriptor List:
        L2CAP (0x0100)
                Protocol specific parameter #1: u/int/uuid16 1
                Protocol specific parameter #2: u/int/uuid16 1

Record Handle: 0x00000001
Service Class ID List:
        Browse Group Descriptor (0x1001)

Record Handle: 0x00000002
Service Class ID List:
        LAN Access Using PPP (0x1102)
Protocol Descriptor List:
        L2CAP (0x0100)
        RFCOMM (0x0003)
                Protocol specific parameter #1: u/int8/bool 1
Bluetooth Profile Descriptor List:
        LAN Access Using PPP (0x1102) ver. 1.0</screen>

	<para>Beachten Sie, dass jeder Dienst eine Liste seiner
	  Eigenschaften, wie etwa den <acronym>RFCOMM</acronym>-Kanal,
	  zurückgibt.  Je nachdem, welche Dienste der Benutzer
	  benötigt, sollten einige dieser Eigenschaften notiert
	  werden.  Einige Bluetooth-Implementationen unterstützen kein
	  <foreignphrase>Service Browsing</foreignphrase> und geben
	  daher eine leere Liste zurück.  Ist dies der Fall, ist es
	  dennoch möglich, nach einem bestimmten Dienst zu suchen.
	  Das folgende Beispiel demonstriert die Suche nach dem
	  <acronym>OBEX</acronym> Object Push
	  (<acronym>OPUSH</acronym>) Dienst:</para>

	<screen>&prompt.user; <userinput>sdpcontrol -a 00:01:03:fc:6e:ec search OPUSH</userinput></screen>

	<para>Unter &os; ist es die Aufgabe des &man.sdpd.8;-Servers,
	  Bluetooth-Clients verschiedene Dienste anzubieten.  Sie
	  können diesen Server durch das Einfügen der folgenden
	  Zeile in <filename>/etc/rc.conf</filename>
	  aktivieren:</para>

	<programlisting>sdpd_enable="YES"</programlisting>

	<para>Nun kann der &man.sdpd.8;-Daemon durch
	  folgende Eingabe gestartet werden:</para>

	<screen>&prompt.root; <userinput>service sdpd start</userinput></screen>

	<para>Der lokale Server, der den entfernten Clients
	  Bluetooth-Dienste anbieten soll, bindet diese Dienste an den
	  lokalen <acronym>SDP</acronym>-Daemon.  Ein Beispiel für
	  eine solche Anwendung ist &man.rfcomm.pppd.8;.  Einmal
	  gestartet, wird der Bluetooth-LAN-Dienst an den lokalen
	  <acronym>SDP</acronym>-Daemon gebunden.</para>

	<para>Die Liste der vorhandenen Dienste, die am lokalen
	  <acronym>SDP</acronym>-Server registriert sind, lässt sich
	  durch eine <acronym>SDP</acronym>-Abfrage über einen lokalen
	  Kontrollkanal abfragen:</para>

	<screen>&prompt.root; <userinput>sdpcontrol -l browse</userinput></screen>
      </sect3>

      <sect3>
	<title><acronym>OBEX</acronym> Object-Push
	  (<acronym>OPUSH</acronym>)</title>

	<indexterm>
	  <primary>OBEX</primary>
	</indexterm>

	<para><acronym>OBEX</acronym> ist ein häufig verwendetes
	  Protokoll für den Dateitransfer zwischen Mobilgeräten.  Sein
	  Hauptzweck ist die Kommunikation über die
	  Infrarotschnittstelle.  Es dient daher zum Datentransfer
	  zwischen Notebooks oder <acronym>PDA</acronym>s sowie zum
	  Austausch von Visitenkarten oder Kalendereinträgen zwischen
	  Mobiltelefonen und anderen Geräten mit
	  <acronym>PIM</acronym>-Funktionen.</para>

	<para>Server und Client von <acronym>OBEX</acronym> werden
	  durch <application>obexapp</application> bereitgestellt, das
	  als Paket oder Port <package>comms/obexapp</package>
	  installiert werden kann.</para>

	<para>Mit dem <acronym>OBEX</acronym>-Client werden Objekte
	  zum <acronym>OBEX</acronym>-Server geschickt oder
	  angefordert.  Ein Objekt kann etwa eine Visitenkarte oder
	  ein Termin sein.  Der <acronym>OBEX</acronym>-Client fordert
	  über <acronym>SDP</acronym> die Nummer des
	  <acronym>RFCOMM</acronym>-Kanals vom entfernten Gerät an.
	  Dies kann auch durch die Verwendung des Servicenamens
	  anstelle der <acronym>RFCOMM</acronym>-Kanalnummer erfolgen.
	  Folgende Dienste werden unterstützt:
	  <literal>IrMC</literal>, <literal>FTRN</literal> und
	  <literal>OPUSH</literal>.  Es ist möglich, den
	  <acronym>RFCOMM</acronym>-Kanal als Nummer anzugeben.  Es
	  folgt ein Beispiel für eine <acronym>OBEX</acronym>-Sitzung,
	  bei der ein Informationsobjekt vom Mobiltelefon angefordert
	  und ein neues Objekt (hier eine Visitenkarte) an das
	  Telefonbuch des Mobiltelefons geschickt wird:</para>

	<screen>&prompt.user; <userinput>obexapp -a 00:80:37:29:19:a4 -C IrMC</userinput>
obex&gt; get telecom/devinfo.txt
Success, response: OK, Success (0x20)
obex&gt; put new.vcf
Success, response: OK, Success (0x20)
obex&gt; di
Success, response: OK, Success (0x20)</screen>

	<para>Um <acronym>OBEX</acronym>-Push-Dienste anbieten zu
	  können, muss der <application>sdpd</application>-Server
	  gestartet sein.  Ein Wurzelverzeichnis, in dem alle
	  ankommenden Objekte gespeichert werden, muss zusätzlich
	  angelegt werden.  In der Voreinstellung ist dies
	  <filename>/var/spool/obex</filename>.  Starten Sie den
	  <acronym>OBEX</acronym>-Server mit einer gültigen
	  Kanalnummer.  Der <acronym>OBEX</acronym>-Server registriert
	  nun den <acronym>OBEX</acronym>-Push-Dienst mit dem lokalen
	  <acronym>SDP</acronym>-Daemon.  Das folgende Beispiel zeigt,
	  wie der <acronym>OBEX</acronym>-Server gestartet
	  wird:</para>

	<screen>&prompt.root; <userinput>obexapp -s -C 10</userinput></screen>
      </sect3>

      <sect3>
	<title>Das Serial-Port Profil (<acronym>SPP</acronym>)</title>

	<para>Das <foreignphrase>Serial Port Profile</foreignphrase>
	  (<acronym>SSP</acronym>) ermöglicht es Bluetooth-Geräten
	  eine serielle Kabelverbindung zu emulieren.  Anwendungen
	  sind dadurch in der Lage, über eine virtuelle serielle
	  Verbindung Bluetooth als Ersatz für eine Kabelverbindung zu
	  nutzen.</para>

	<para>&man.rfcomm.sppd.1; implementiert unter &os;
	  <application>SSP</application> und ein Pseudo-tty, das als
	  virtuelle serielle Verbindung verwendet wird.  Das folgende
	  Beispiel zeigt, wie man eine Verbindung mit einem entfernten
	  Serial-Port-Dienst herstellt.  Ein
	  <acronym>RFCOMM</acronym>-Kanal muss dabei nicht angegeben
	  werden, da &man.rfcomm.sppd.1; den Kanal über
	  <acronym>SDP</acronym> abfragen kann.  Um dies zu umgehen,
	  geben Sie einen <acronym>RFCOMM</acronym>-Kanal auf der
	  Kommandozeile an.</para>

	<screen>&prompt.root; <userinput>rfcomm_sppd -a 00:07:E0:00:0B:CA -t</userinput>
rfcomm_sppd[94692]: Starting on /dev/pts/6...
/dev/pts/6</screen>

	<para>Sobald die Verbindung hergestellt ist, kann pseudo-tty
	  als serieller Port verwenden werden.</para>

	<screen>&prompt.root; <userinput>cu -l /dev/pts/6</userinput></screen>

	<para>Das pseudo-tty wird auf der Standardausgabe ausgegeben
	  und kann von Wrapper-Skripten gelesen werden:</para>

	<programlisting>PTS=`rfcomm_sppd -a 00:07:E0:00:0B:CA -t`
cu -l $PTS</programlisting>

      </sect3>
    </sect2>

    <sect2>
      <title>Problembehandlung</title>

      <para>Wenn &os; eine neue Verbindung
	akzeptiert, versucht es, die Rolle zu tauschen, um zum
	Master zu werden.  Einige ältere Geräte, die dies nicht
	unterstützen, können keine Verbindung aufbauen.  Da der
	Rollentausch ausgeführt wird sobald eine neue Verbindung
	aufgebaut wird, ist es nicht möglich, das entfernte Gerät zu
	fragen ob es den Rollentausch unterstützt.  Es gibt jedoch
	eine <acronym>HCI</acronym>-Option, die dieses Verhalten
	deaktiviert:</para>

      <screen>&prompt.root; <userinput>hccontrol -n ubt0hci write_node_role_switch 0</userinput></screen>

      <para>Verwenden Sie <application>hcidump</application>,
	das als Paket Port <package>comms/hcidump</package>
	installiert werden kann, um Bluetooth-Pakete anzuzeigen.
	Dieses Programm hat Ähnlichkeiten mit &man.tcpdump.1; und
	kann zur Anzeige der Bluetooth-Pakete in einem Terminal,
	oder zur Speicherung von Paketen in einer Datei (Dump)
	verwendet werden.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="network-bridging">
    <info>
      <title>LAN-Kopplung mit einer Bridge</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Andrew</firstname>
	    <surname>Thompson</surname>
	  </personname>
	  <contrib>Geschrieben von </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary><acronym>IP</acronym>-Subnetz</primary>
    </indexterm>
    <indexterm>
      <primary>Bridge</primary>
    </indexterm>

    <para>Manchmal ist es nützlich, ein Netzwerk, wie
      ein Ethernetsegment, in separate Netzwerke aufzuteilen,
      ohne gleich <acronym>IP</acronym>-Subnetze zu erzeugen, die
      über einen Router miteinander verbunden sind.  Ein Gerät, das
      zwei Netze auf diese Weise verbindet, wird als
      <quote>Bridge</quote> bezeichnet.</para>

    <para>Eine Bridge arbeitet, indem sie die
      <acronym>MAC</acronym>-Adressen der Geräte in
      ihren Netzwerksegmenten lernt.  Der Verkehr wird nur dann
      zwischen zwei Segmenten weitergeleitet, wenn sich Sender und
      Empfänger in verschiedenen Netzwerksegmenten befinden.  Jedes
      &os;-System mit zwei Netzwerkkarten kann als Bridge
      fungieren.</para>

    <para>Bridging kann in den folgenden Situationen sinnvoll
      sein:</para>

    <variablelist>
      <varlistentry>
	<term>Verbinden von Netzwerken</term>
	<listitem>
	  <para>Die Hauptaufgabe einer Bridge ist die Verbindung von
	    zwei oder mehreren Netzwerksegmenten.  Es gibt viele
	    Gründe, eine hostbasierte Bridge einzusetzen, anstelle
	    von Netzwerkkomponenten, wie beispielsweise
	    Kabelverbindungen oder Firewalls.  Eine Bridge kann
	    außerdem ein drahtloses Gerät mit einem Kabelnetzwerk
	    verbinden.  Diese Fähigkeit der Bridge wird als
	    <foreignphrase>HostAP-Modus</foreignphrase> bezeichnet.
	    Die Bridge agiert in diesem Fall als Access Point für
	    das drahtlose Gerät.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>Filtering / Traffic Shaping Firewall</term>
	<listitem>
	  <para>Eine Bridge kann eingesetzt werden, wenn
	    Firewallfunktionen benötigt werden, ohne dabei
	    Routing oder <foreignphrase>Network Adress
	    Translation</foreignphrase> (<acronym>NAT</acronym>)
	    zu verwenden.</para>

	  <para>Ein Beispiel dafür wäre ein kleines Unternehmen,
	    das über <acronym>DSL</acronym> oder
	    <acronym>ISDN</acronym> an einen <acronym>ISP</acronym>
	    angebunden ist.  Es verfügt über 13 erreichbare
	    <acronym>IP</acronym>-Adressen und das Netzwerk besteht
	    aus 10 Rechnern.  In dieser Situation ist der Einsatz
	    von Subnetzen sowie einer routerbasierten Firewall
	    aufgrund der <acronym>IP</acronym>-Adressierung
	    schwierig.  Eine Bridge-basierte Firewall kann hingegen
	    ohne Probleme konfiguriert werden.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>Netzwerküberwachung</term>
	<listitem>
	  <para>Eine Bridge kann zwei Netzwerksegmente miteinander
	    verbinden und danach alle Ethernet-Rahmen überprüfen,
	    die zwischen den beiden Netzwerksegmenten ausgetauscht
	    werden.  Dazu verwendet man entweder &man.bpf.4; und
	    &man.tcpdump.1; auf dem Netzgerät der Bridge oder schickt
	    Kopien aller Rahmen an ein zusätzliches Netzgerät, das als
	    <foreignphrase>Span Port</foreignphrase> bekannt
	    ist.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>Layer 2 <acronym>VPN</acronym></term>
	<listitem>
	  <para>Zwei Ethernetnetzwerke können über einen
	    <acronym>IP</acronym>-Link miteinander verbunden werden,
	    indem die beiden Netzwerke über einen EtherIP-Tunnel
	    gekoppelt werden, oder eine &man.tap.4;-basierte Lösung
	    wie <application>OpenVPN</application> eingesetzt
	    wird.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>Layer 2 Redundanz</term>
	<listitem>
	  <para>Die Systeme eines Netzwerks können über das
	    <foreignphrase>Spanning Tree Protocol</foreignphrase>
	    (<acronym>STP</acronym>) redundant miteinander verbunden
	    sein, um redundante Pfade zu blockieren.</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <para>Dieser Abschnitt beschreibt, wie ein &os;-System mit Hilfe
      von &man.if.bridge.4; als Bridge konfiguriert wird.  Ein
      netgraph-Bridge-Treiber ist ebenfalls verfügbar und wird in
      &man.ng.bridge.4; beschrieben.</para>

    <note>
      <para>Paketfilter können mit allen Firewallpaketen verwendet
	werden, die das &man.pfil.9;-Framework benutzen.  Eine Bridge
	kann auch als <foreignphrase>Traffic Shaper</foreignphrase>
	verwendet werden, wenn Sie &man.altq.4; oder
	&man.dummynet.4; einsetzen.</para>
    </note>

    <sect2>
      <title>Die Bridge aktivieren</title>

      <para>In &os; handelt es sich bei &man.if.bridge.4; um ein
	Kernelmodul, das von &man.ifconfig.8; automatisch geladen
	wird, wenn eine Bridge-Schnittstelle erzeugt wird.  Es ist
	auch möglich, die Unterstützung für den Treiber in den Kernel
	zu kompilieren, indem die Zeile
	<literal>device if_bridge</literal> in die
	Kernelkonfigurationsdatei hinzugefügt wird.</para>

      <para>Eine Bridge wird durch das Klonen von Schnittstellen
	erzeugt.  Um eine Bridge zu erzeugen, verwenden Sie:</para>

      <screen>&prompt.root; <userinput>ifconfig bridge create</userinput>
bridge0
&prompt.root; <userinput>ifconfig bridge0</userinput>
bridge0: flags=8802&lt;BROADCAST,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        ether 96:3d:4b:f1:79:7a
        id 00:00:00:00:00:00 priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 timeout 1200
        root id 00:00:00:00:00:00 priority 0 ifcost 0 port 0</screen>

      <para>Wenn eine Bridge erzeugt wird, erhält sie automatisch eine
	zufällig generierte Ethernet-Adresse.  Die Parameter
	<literal>maxaddr</literal> sowie <literal>timeout</literal>
	legen fest, wie viele <acronym>MAC</acronym>-Adressen die
	Bridge in ihrer Forward-Tabelle halten kann und wie viele
	Sekunden jeder Eintrag erhalten bleiben soll, nachdem
	er zuletzt verwendet wurde.  Die restlichen Parameter sind
	für die Konfiguration von <acronym>STP</acronym>
	notwendig.</para>

      <para>Im nächsten Schritt werden die Schnittstellen, die
	die Bridge verbinden soll, zugewiesen.  Damit die Bridge
	Datenpakete weiterleiten kann, müssen sowohl die Bridge
	als auch die Schnittstellen der zu verbindenden
	Netzwerksegmente aktiviert sein:</para>

      <screen>&prompt.root; <userinput>ifconfig bridge0 addm fxp0 addm fxp1 up</userinput>
&prompt.root; <userinput>ifconfig fxp0 up</userinput>
&prompt.root; <userinput>ifconfig fxp1 up</userinput></screen>

      <para>Jetzt ist die Bridge in der Lage, Ethernet-Rahmen zwischen
	den Schnittstellen <filename>fxp0</filename> und
	<filename>fxp1</filename> weiterzuleiten.  Um diese
	Konfiguration beim Systemstart automatisch zu aktivieren,
	müssen die folgenden Zeilen in
	<filename>/etc/rc.conf</filename> hinzugefügt werden:</para>

      <programlisting>cloned_interfaces="bridge0"
ifconfig_bridge0="addm fxp0 addm fxp1 up"
ifconfig_fxp0="up"
ifconfig_fxp1="up"</programlisting>

      <para>Wenn die Bridge eine <acronym>IP</acronym>-Adresse
	benötigt, muss diese der Schnittstelle der Bridge zugewiesen
	werden und nicht der Schnittstelle der gekoppelten
	Netzwerksegmente.  Die <acronym>IP</acronym>-Adresse kann
	manuell gesetzt, oder über <acronym>DHCP</acronym> bezogen
	werden.  Dieses Beispiel verwendet eine statische
	<acronym>IP</acronym>-Adresse:</para>

      <screen>&prompt.root; <userinput>ifconfig bridge0 inet 192.168.0.1/24</userinput></screen>

      <para>Es ist auch möglich der Bridge-Schnittstelle eine
	<acronym>IPv6</acronym>-Adresse zuzuweisen.  Um die Änderungen
	dauerhaft zu speichern, fügen Sie die Adressinformationen in
	<filename>/etc/rc.conf</filename> ein.</para>

      <note>
	<para>Nachdem ein Paketfilter aktiviert wurde, können
	  Datenpakete, die von den Schnittstellen der gekoppelten
	  Netzwerksegmente gesendet und empfangen werden, über
	  die Bridge weitergeleitet oder nach bestimmten Regeln
	  gefiltert oder auch komplett geblockt werden.  Ist die
	  Richtung des Paketflusses wichtig, ist es am besten, eine
	  Firewall auf den Schnittstellen der einzelnen
	  Netzwerksegmente einzurichten und nicht auf der Bridge
	  selbst.</para>

	<para>Eine Bridge verfügt über verschiedene Optionen zur
	  Weiterleitung von Nicht-<acronym>IP</acronym>- und
	  <acronym>IP</acronym>-Paketen, sowie Paketfilterung auf
	  Layer 2 mittels &man.ipfw.8;.  Weitere Informationen finden
	  Sie in &man.if.bridge.4;.</para>
      </note>
    </sect2>

    <sect2>
      <title>Spanning Tree aktivieren</title>

      <para>Damit ein Ethernet-Netzwerk richtig funktioniert, kann nur
	ein aktiver Pfad zwischen zwei Geräten existieren.  Das
	<acronym>STP</acronym>-Protokoll erkennt Schleifen in einer
	Netzwerktopologie und setzt redundante Pfade in einen
	blockierten Zustand.  Sollte eine der aktiven Verbindungen
	ausfallen, berechnet <acronym>STP</acronym> einen anderen Baum
	und ermöglicht es dann einem blockierten Pfad, alle
	Netzwerkverbindungen wiederherzustellen.</para>

      <para>Das
	<foreignphrase>Rapid Spanning Tree Protocol</foreignphrase>
	(<acronym>RSTP</acronym> oder 802.1w), ist abwärtskompatibel
	zum veralteten <acronym>STP</acronym>.
	<acronym>RSTP</acronym> arbeitet schneller und tauscht
	Informationen mit benachbarten Switchen aus, um Pakete korrekt
	weiterzuleiten und eine Schleifenbildung zu verhindern.  &os;
	unterstützt die Betriebsmodi <acronym>RSTP</acronym> und
	<acronym>STP</acronym>, wobei <acronym>RSTP</acronym> als
	Standardmodus voreingestellt ist.</para>

      <para><acronym>STP</acronym> kann auf den Schnittstellen der
	durch die Bridge verbundenen Netzwerksegmente mittels
	&man.ifconfig.8; aktiviert werden.  Für eine
	Bridge, die die Schnittstellen <filename>fxp0</filename> und
	<filename>fxp1</filename> verbindet, aktivieren Sie
	<acronym>STP</acronym> wie folgt:</para>

      <screen>&prompt.root; <userinput>ifconfig bridge0 stp fxp0 stp fxp1</userinput>
bridge0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        ether d6:cf:d5:a0:94:6d
        id 00:01:02:4b:d4:50 priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 timeout 1200
        root id 00:01:02:4b:d4:50 priority 32768 ifcost 0 port 0
        member: fxp0 flags=1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 3 priority 128 path cost 200000 proto rstp
                role designated state forwarding
        member: fxp1 flags=1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 4 priority 128 path cost 200000 proto rstp
                role designated state forwarding</screen>

      <para>Diese Bridge hat die Spanning-Tree-ID
	<literal>00:01:02:4b:d4:50</literal> und die Priorität
	<literal>32768</literal>.  Da diese ID mit der
	<literal>Root-ID</literal> identisch ist, handelt es sich um
	die Root-Bridge dieses Netzwerks.</para>

      <para>Auf einer anderen Bridge des Netzwerks ist
	<acronym>STP</acronym> ebenfalls aktiviert:</para>

      <screen>bridge0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        ether 96:3d:4b:f1:79:7a
        id 00:13:d4:9a:06:7a priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 timeout 1200
        root id 00:01:02:4b:d4:50 priority 32768 ifcost 400000 port 4
        member: fxp0 flags=1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 4 priority 128 path cost 200000 proto rstp
                role root state forwarding
        member: fxp1 flags=1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 5 priority 128 path cost 200000 proto rstp
                role designated state forwarding</screen>

      <para>Die Zeile <literal>root id 00:01:02:4b:d4:50 priority
	  32768 ifcost 400000 port 4</literal> zeigt an, dass die
	Root-Bridge die ID <literal>00:01:02:4b:d4:50</literal> hat.
	Die Pfadkosten hin zur Root-Bridge betragen
	<literal>400000</literal>, wobei der Pfad zur Root-Bridge
	über <literal>port 4</literal> geht, der wiederum
	der Schnittstelle <filename>fxp0</filename> entspricht.</para>
    </sect2>

    <sect2>
      <title>Parameter der Bridge-Schnittstelle</title>

      <para>Einige Parameter von <command>ifconfig</command> dienen
	ausschließlich der Konfiguration von Bridge-Schnittstellen.
	Dieser Abschnitt fasst die Verwendung dieser Parameter
	zusammen.  Die vollständige Liste der verfügbaren Parameter
	wird in &man.ifconfig.8; beschrieben.</para>

      <variablelist>
	<varlistentry>
	  <term>private</term>
	  <listitem>
	    <para>Eine private Schnittstelle leitet keine Daten an
	      einen Port weiter, bei dem es sich ebenfalls um eine
	      private Schnittstelle handelt.  Der Datenverkehr wird
	      dabei komplett blockiert, auch Ethernet-Rahmen und
	      <acronym>ARP</acronym>-Pakete werden nicht
	      weitergeleitet.  Wollen Sie hingegen nur spezifische
	      Datenpakete blockieren, sollten Sie eine Firewall
	      einsetzen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>span</term>
	  <listitem>
	    <para>Ein <foreignphrase>Span Port</foreignphrase>
	      übertragt eine Kopie jedes Ethernet-Rahmens, der an der
	      Bridge ankommt.  Auf einer Bridge können beliebig viele
	      Span Ports festgelegt werden.  Wird eine Schnittstelle
	      als Span Port konfiguriert, kann sie nicht mehr als
	      normaler Bridge-Port verwendet werden.  Eine derartige
	      Konfiguration ist beispielsweise sinnvoll, um den
	      Datenverkehr, der in einem Netzwerk über die Bridge
	      läuft, auf einen Rechner zu übertragen, der mit einem
	      Span Port der Bridge verbunden ist.  Um beispielsweise
	      eine Kopie aller Ethernet-Rahmen über die Schnittstelle
	      <filename>fxp0</filename> zu übertragen:</para>

	    <screen>&prompt.root; <userinput>ifconfig bridge0 span fxp4</userinput></screen>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>sticky</term>
	  <listitem>
	    <para>Wenn die Schnittstelle eines über eine Bridge
	      verbundenen Netzwerksegments als
	      <foreignphrase>sticky</foreignphrase> gekennzeichnet
	      wird, werden alle dynamisch gelernten Adressen als
	      statische Adressen behandelt, sobald sie in den
	      Forward-Cache der Bridge aufgenommen wurden.
	      Sticky-Einträge werden niemals aus dem Cache entfernt
	      oder ersetzt.  Selbst dann nicht, wenn die Adresse von
	      einer anderen Schnittstelle verwendet wird.  Sie können
	      dadurch die Vorteile statischer Adresseinträge nutzen,
	      ohne die Forward-Tabelle vor dem Einsatz der Bridge mit
	      statischen Einträgen füllen zu müssen.  Clients, die
	      sich in einem bestimmten von der Bridge verwalteten
	      Segmente befinden, können dabei nicht in ein anderes
	      Segment wechseln.</para>

	    <para>Ein Beispiel für den Einsatz von Sticky-Adressen ist
	      die Kombination einer Bridge mit mehreren
	      <acronym>VLAN</acronym>s, um einen Router zu
	      konfigurieren, der einzelne Kundennetzwerke voneinander
	      trennt, ohne dabei <acronym>IP</acronym>-Adressbereiche
	      zu verschwenden.  Für das folgende Beispiel nehmen wir
	      an, dass sich der Client <systemitem
		class="fqdomainname">CustomerA</systemitem> im
	      <acronym>VLAN</acronym> <literal>vlan100</literal> und
	      der Client <systemitem
		class="fqdomainname">CustomerB</systemitem> im
	      <acronym>VLAN</acronym> <literal>vlan101</literal>
	      befinden.  Die Bridge hat die
	      <acronym>IP</acronym>-Adresse <systemitem
		class="ipaddress">192.168.0.1</systemitem>:</para>

	    <screen>&prompt.root; <userinput>ifconfig bridge0 addm vlan100 sticky vlan100 addm vlan101 sticky vlan101</userinput>
&prompt.root; <userinput>ifconfig bridge0 inet 192.168.0.1/24</userinput></screen>

	    <para>In diesem Beispiel sehen beide Clients <systemitem
		class="ipaddress">192.168.0.1</systemitem> als das
	      Default-Gateway.  Da der Brücken-Cache
	      <emphasis>sticky</emphasis> ist, sind Sie nicht dazu in
	      der Lage, die <acronym>MAC</acronym>-Adresse des anderen
	      Kunden zu spoofen und dessen Datenverkehr
	      abzufangen.</para>

	    <para>Sie können die Kommunikation zwischen den
	      <acronym>VLAN</acronym>s vollständig unterbinden, wenn
	      Sie private Schnittstellen oder eine Firewall
	      einsetzen:</para>

	    <screen>&prompt.root; <userinput>ifconfig bridge0 private vlan100 private vlan101</userinput></screen>

	    <para>Die Kunden sind nun komplett voneinander isoliert
	      und der komplette <systemitem
		class="netmask">/24</systemitem>-Adressbereich kann
	      zugewiesen werden, ohne dass Subnetze eingesetzt
	      werden.</para>

	    <para>Die maximale mögliche Anzahl an eindeutigen
	      <acronym>MAC</acronym>-Adressen hinter einer
	      Schnittstelle kann festgelegt werden.  Sobald das Limit
	      erreicht ist, werden Pakete mit einer unbekannten
	      Quell-Adresse solange verworfen, bis ein existierender
	      Eintrag gelöscht wird oder abläuft.</para>

	    <para>Das folgende Beispiel setzt die maximale Anzahl von
	      Netzgeräten für <systemitem
		class="fqdomainname">CustomerA</systemitem> für das
	      VLAN <literal>vlan100</literal> auf 10.</para>

	    <screen>&prompt.root; <userinput>ifconfig bridge0 ifmaxaddr vlan100 10</userinput></screen>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>Die Bridge unterstützt auch den Monitormodus.  Dabei
	werden alle Pakete verworfen, nachdem sie von &man.bpf.4;
	verarbeitet wurden.  In diesem Modus erfolgt keine weitere
	Bearbeitung und auch keine Weiterleitung von Datenpaketen.
	Es ist daher möglich, die Eingabe von zwei oder mehr
	Netzwerkschnittstellen in einen einzigen gemeinsamen
	&man.bpf.4;-Stream zu vereinen.  Ein solcher Datenstrom
	ist beispielsweise nützlich, um den Datenverkehr für
	<quote>network taps</quote> zu rekonstruieren, die ihre
	RX/TX-Signale über verschiedene Schnittstellen senden.  Um
	beispielsweise die Eingabe von vier Netzwerkschnittstellen
	in einzigen gemeinsamen Datenstrom zu vereinen:</para>

      <screen>&prompt.root; <userinput>ifconfig bridge0 addm fxp0 addm fxp1 addm fxp2 addm fxp3 monitor up</userinput>
&prompt.root; <userinput>tcpdump -i bridge0</userinput></screen>
    </sect2>

    <sect2>
      <title><acronym>SNMP</acronym>-Monitoring</title>

      <para>Die Schnittstelle der Bridge sowie die
	<acronym>STP</acronym>-Parameter können durch den im
	Basissystem enthaltenen &man.bsnmpd.1; überwacht werden.
	Die exportierten Bridge-<acronym>MIB</acronym>s entsprechen
	den <acronym>IETF</acronym>-Standards, daher kann ein
	beliebiger <acronym>SNMP</acronym>-Client oder ein
	beliebiges Monitoring-Werkzeug eingesetzt werden, um die
	benötigten Daten zu erhalten.</para>

      <para>Um das Monitoring auf der Bridge zu aktivieren,
	kommentieren Sie diese Zeile in
	<filename>/etc/snmpd.config</filename> aus, indem Sie das
	Zeichen <literal>#</literal> entfernen:</para>

      <programlisting>begemotSnmpdModulePath."bridge" = "/usr/lib/snmp_bridge.so"</programlisting>

      <para>Weitere Konfigurationsparameter wie Community-Namen und
	Zugriffslisten müssen ebenfalls in dieser Datei angepasst
	werden.  Weitere Informationen finden Sie in &man.bsnmpd.1;
	und &man.snmp.bridge.3;.  Nachdem die Änderungen gespeichert
	wurden, fügen Sie folgende Zeile in
	<filename>/etc/rc.conf</filename> hinzu:</para>

      <programlisting>bsnmpd_enable="YES"</programlisting>

      <para>Danach starten Sie &man.bsnmpd.1;:</para>

      <screen>&prompt.root; <userinput>service bsnmpd start</userinput></screen>

      <para>Die folgenden Beispiele verwenden das Softwarepaket
	<application>Net-SNMP</application>
	(<package>net-mgmt/net-snmp</package>), um die Bridge vom
	Client aus abzufragen.  Alternativ kann auch der Port
	<package>net-mgmt/bsnmptools</package> benutzt werden.  Auf
	dem <acronym>SNMP</acronym>-Client müssen danach die folgenden
	Zeilen in <filename>$HOME/.snmp/snmp.conf</filename>
	hinzugefügt werden, um die <acronym>MIB</acronym>-Definitionen
	der Bridge in <application>Net-SNMP</application> zu
	importieren:</para>

      <programlisting>mibdirs +/usr/share/snmp/mibs
mibs +BRIDGE-MIB:RSTP-MIB:BEGEMOT-MIB:BEGEMOT-BRIDGE-MIB</programlisting>

      <para>Um eine einzelne Bridge über den IETF BRIDGE-MIB
	(RFC4188) zu überwachen:</para>

      <screen>&prompt.user; <userinput>snmpwalk -v 2c -c public bridge1.example.com mib-2.dot1dBridge</userinput>
BRIDGE-MIB::dot1dBaseBridgeAddress.0 = STRING: 66:fb:9b:6e:5c:44
BRIDGE-MIB::dot1dBaseNumPorts.0 = INTEGER: 1 ports
BRIDGE-MIB::dot1dStpTimeSinceTopologyChange.0 = Timeticks: (189959) 0:31:39.59 centi-seconds
BRIDGE-MIB::dot1dStpTopChanges.0 = Counter32: 2
BRIDGE-MIB::dot1dStpDesignatedRoot.0 = Hex-STRING: 80 00 00 01 02 4B D4 50
...
BRIDGE-MIB::dot1dStpPortState.3 = INTEGER: forwarding(5)
BRIDGE-MIB::dot1dStpPortEnable.3 = INTEGER: enabled(1)
BRIDGE-MIB::dot1dStpPortPathCost.3 = INTEGER: 200000
BRIDGE-MIB::dot1dStpPortDesignatedRoot.3 = Hex-STRING: 80 00 00 01 02 4B D4 50
BRIDGE-MIB::dot1dStpPortDesignatedCost.3 = INTEGER: 0
BRIDGE-MIB::dot1dStpPortDesignatedBridge.3 = Hex-STRING: 80 00 00 01 02 4B D4 50
BRIDGE-MIB::dot1dStpPortDesignatedPort.3 = Hex-STRING: 03 80
BRIDGE-MIB::dot1dStpPortForwardTransitions.3 = Counter32: 1
RSTP-MIB::dot1dStpVersion.0 = INTEGER: rstp(2)</screen>

      <para>Der Wert der Variable
	<literal>dot1dStpTopChanges.0</literal> ist hier 2, die
	<acronym>STP</acronym>-Topologie der Bridge wurde also
	bereits zweimal geändert.  Unter einer Änderung versteht man
	die Anpassung eines oder mehrerer Links und die Kalkulation
	eines neuen Baums.  Der Wert der Variable
	<literal>dot1dStpTimeSinceTopologyChange.0</literal> gibt an,
	wann dies zuletzt geschah.</para>

      <para>Um mehrere Bridge-Schnittstellen zu überwachen,
	kann der private BEGEMOT-BRIDGE-MIB eingesetzt
	werden:</para>

      <screen>&prompt.user; <userinput>snmpwalk -v 2c -c public bridge1.example.com</userinput>
enterprises.fokus.begemot.begemotBridge
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseName."bridge0" = STRING: bridge0
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseName."bridge2" = STRING: bridge2
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseAddress."bridge0" = STRING: e:ce:3b:5a:9e:13
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseAddress."bridge2" = STRING: 12:5e:4d:74:d:fc
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseNumPorts."bridge0" = INTEGER: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseNumPorts."bridge2" = INTEGER: 1
...
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTimeSinceTopologyChange."bridge0" = Timeticks: (116927) 0:19:29.27 centi-seconds
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTimeSinceTopologyChange."bridge2" = Timeticks: (82773) 0:13:47.73 centi-seconds
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTopChanges."bridge0" = Counter32: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTopChanges."bridge2" = Counter32: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeStpDesignatedRoot."bridge0" = Hex-STRING: 80 00 00 40 95 30 5E 31
BEGEMOT-BRIDGE-MIB::begemotBridgeStpDesignatedRoot."bridge2" = Hex-STRING: 80 00 00 50 8B B8 C6 A9</screen>

      <para>Um die über den
	<literal>mib-2.dot1dBridge</literal>-Subtree überwachte
	Bridge-Schnittstelle zu ändern:</para>

      <screen>&prompt.user; <userinput>snmpset -v 2c -c private bridge1.example.com</userinput>
BEGEMOT-BRIDGE-MIB::begemotBridgeDefaultBridgeIf.0 s bridge2</screen>
    </sect2>
  </sect1>

  <sect1 xml:id="network-aggregation">
    <info>
      <title>Link-Aggregation und Failover</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Andrew</firstname>
	    <surname>Thompson</surname>
	  </personname>
	  <contrib>Geschrieben von </contrib>
	</author>
      </authorgroup>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Benedict</firstname>
	    <surname>Reuschling</surname>
	  </personname>
	  <contrib>Übersetzt von </contrib>
	</author>

	<author>
	  <personname>
	    <firstname>Sharon</firstname>
	    <surname>Bahagi</surname>
	  </personname>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>lagg</primary>
    </indexterm>
    <indexterm>
      <primary>failover</primary>
    </indexterm>
    <indexterm>
      <primary>FEC</primary>
    </indexterm>
    <indexterm>
      <primary>LACP</primary>
    </indexterm>
    <indexterm>
      <primary>loadbalance</primary>
    </indexterm>
    <indexterm>
      <primary>roundrobin</primary>
    </indexterm>

    <para>Die von &os; unterstützte &man.lagg.4;-Schnittstelle erlaubt
      die Gruppierung von mehreren Netzwerkadaptern als eine virtuelle
      Schnittstelle, mit dem Ziel, Ausfallsicherheit (Failover) und
      Link Aggregation bereitzustellen.  Bei Failover kann der Verkehr
      auch dann weiter fließen, wenn nur eine Schnittstelle verfügbar
      ist.  Link Aggregation funktioniert am besten mit Switches,
      die <acronym>LCAP</acronym> unterstützen, da dieses Protokoll
      den Datenverkehr bidirektional verteilt, während es auch auf den
      Ausfall einzelner Verbindungen reagiert.</para>

    <para>Die von der lagg-Schnittstelle unterstützten Protokolle
      bestimmen, welche Ports für den ausgehenden Datenverkehr benutzt
      werden, und ob ein bestimmter Port eingehenden Datenverkehr
      akzeptiert.  Die folgenden Protokolle werden von &man.lagg.4;
      unterstützt:</para>

    <variablelist>
      <varlistentry>
	<term>Failover (Ausfallsicherheit)</term>
	<listitem>
	  <para>Dieser Modus sendet und empfängt Datenverkehr nur
	    auf dem Masterport.  Sollte der Masterport nicht zur
	    Verfügung stehen, wird der nächste aktive Port
	    verwendet.  Der zuerst hinzugefügte Adapter der
	    virtuellen Schnittstelle wird zum Masterport, jeder
	    weitere Adapter dient als Gerät zur Ausfallsicherheit.
	    Wenn ein Failover auf einem Nicht-Master Port
	    stattfindet, wird der ursprüngliche Port wieder zum
	    Master-Port, sobald er wieder verfügbar ist.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>fec / loadbalance (Lastverteilung)</term>
	<listitem>
	  <para>&cisco; Fast &etherchannel; (<acronym>FEC</acronym>)
	    findet sich auf älteren &cisco; Switches.  Es bietet
	    eine statische Konfiguration und handelt weder
	    Aggregation mit der Gegenstelle aus, noch werden Frames
	    zur Überwachung der Verbindung ausgetauscht.  Wenn der
	    Switch <acronym>LACP</acronym> unterstützt, sollte diese
	    Option auch verwendet werden.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><acronym>lacp</acronym></term>
	<listitem>
	  <para>Das &ieee; 802.3ad Link-Aggregation Control
	    Protokoll (<acronym>LACP</acronym>).  Mit
	    <acronym>LACP</acronym> wird eine Menge von
	    aggregierbaren Verbindungen mit der Gegenstelle in einer
	    oder mehreren Link Aggregated Groups
	    (<acronym>LAG</acronym>) ausgehandelt.  Jede
	    <acronym>LAG</acronym> besteht aus Ports der gleichen
	    Geschwindigkeit, eingestellt auf Voll-Duplex-Betrieb.
	    Der Verkehr wird über die Ports in der
	    <acronym>LAG</acronym> mit der größten
	    Gesamtgeschwindigkeit balanciert.  Typischerweise gibt
	    es nur eine <acronym>LAG</acronym>, die alle Ports
	    enthält.  Im Falle von Änderungen in der physischen
	    Anbindung wird <acronym>LACP</acronym> schnell zu einer
	    neuen Konfiguration konvergieren.</para>

	  <para><acronym>LACP</acronym> balanciert ausgehenden
	    Verkehr über die aktiven Ports basierend auf der
	    gehashten Protokollheaderinformation und akzeptiert
	    eingehenden Verkehr auf jedem aktiven Port.  Der Hash
	    beinhaltet die Ethernet-Quell- und Zieladresse, und,
	    soweit verfügbar, den <acronym>VLAN</acronym>-Tag,
	    sowie die <acronym>IPv4</acronym> oder
	    <acronym>IPv6</acronym> Quell- und Zieladresse.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>roundrobin</term>
	<listitem>
	  <para>Dieser Modus verteilt ausgehenden Verkehr mittels
	    einer Round-Robin-Zuteilung über alle aktiven Ports und
	    akzeptiert eingehenden Verkehr auf jedem aktiven Port.
	    Da dieser Modus die Reihenfolge von Ethernet-Rahmen
	    verletzt, sollte er mit Vorsicht eingesetzt
	    werden.</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <sect2>
      <title>Beispiele</title>

      <para>Dieser Abschnitt zeigt, wie man einen &cisco; Switch und
	ein &os;-System für <acronym>LACP</acronym> Load Balancing
	konfiguriert.  Weiterhin wird gezeigt, wie man zwei
	Ethernet-Schnittstellen, sowie eine Ethernet- und eine
	Drahtlos-Schnittstelle für den Failover-Modus konfigurieren
	kann.</para>

      <example xml:id="networking-lacp-aggregation-cisco">
	<title><acronym>LACP</acronym> Aggregation mit einem &cisco;
	  Switch</title>

	<para>Dieses Beispiel verbindet zwei &man.fxp.4;
	  Ethernet-Schnittstellen einer &os;-Maschine zu den ersten
	  zwei Ethernet-Ports auf einem &cisco; Switch als eine
	  einzelne, lastverteilte und ausfallsichere Verbindung.
	  Weitere Adapter können hinzugefügt werden, um den Durchsatz
	  zu erhöhen und die Ausfallsicherheit zu steigern.  Ersetzen
	  Sie die Namen der &cisco;-Ports, Ethernet-Geräte,
	  channel-group Nummern und <acronym>IP</acronym>-Adressen im
	  Beispiel durch Namen, die mit Ihrer lokalen Konfiguration
	  übereinstimmen.</para>

	<para>Da die Reihenfolge der Frames bei Ethernet zwingend
	  eingehalten werden muss, fließt auch jeglicher Verkehr
	  zwischen zwei Stationen über den gleichen physischen
	  Kanal, was die maximale Geschwindigkeit der Verbindung auf
	  die eines einzelnen Adapters beschränkt.
	  Der Übertragungsalgorithmus versucht, so viele
	  Informationen wie möglich zu verwenden, um die
	  verschiedenen Verkehrsflüsse zu unterscheiden und
	  balanciert diese über die verfügbaren Adapter.</para>

	<para>Fügen Sie auf dem &cisco;-Switch die Adapter
	  <replaceable>FastEthernet0/1</replaceable> und
	  <replaceable>FastEthernet0/2</replaceable> zu der
	  channel-group <replaceable>1</replaceable> hinzu:</para>

	<screen><userinput>interface <replaceable>FastEthernet0/1</replaceable>
 channel-group <replaceable>1</replaceable> mode active
 channel-protocol lacp</userinput>
!
<userinput>interface <replaceable>FastEthernet0/2</replaceable>
 channel-group <replaceable>1</replaceable> mode active
 channel-protocol lacp</userinput></screen>

	<para>Erstellen Sie auf der &os; Maschine die
	  &man.lagg.4;-Schnittstelle unter Verwendung von
	  <replaceable>fxp0</replaceable> und
	  <replaceable>fxp1</replaceable> und starten Sie die
	  Schnittstelle mit der <acronym>IP</acronym>-Adresse
	  <replaceable>10.0.0.3/24</replaceable>:</para>

	<screen>&prompt.root; <userinput>ifconfig <replaceable>fxp0</replaceable> up</userinput>
&prompt.root; <userinput>ifconfig <replaceable>fxp1</replaceable> up</userinput>
&prompt.root; <userinput>ifconfig <literal>lagg<replaceable>0</replaceable></literal> create </userinput>
&prompt.root; <userinput>ifconfig <literal>lagg<replaceable>0</replaceable></literal> up laggproto lacp laggport <replaceable>fxp0</replaceable> laggport <replaceable>fxp1</replaceable> <replaceable>10.0.0.3/24</replaceable></userinput></screen>

	<para>Überprüfen Sie den Status der virtuellen
	  Schnittstelle:</para>

	<screen>&prompt.root; <userinput>ifconfig <literal>lagg<replaceable>0</replaceable></literal></userinput>
lagg0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        options=8&lt;VLAN_MTU&gt;
        ether 00:05:5d:71:8d:b8
        inet 10.0.0.3 netmask 0xffffff00 broadcast 10.0.0.255
        media: Ethernet autoselect
        status: active
        laggproto lacp
        laggport: fxp1 flags=1c&lt;ACTIVE,COLLECTING,DISTRIBUTING&gt;
        laggport: fxp0 flags=1c&lt;ACTIVE,COLLECTING,DISTRIBUTING&gt;</screen>

	<para>Ports, die als <emphasis>ACTIVE</emphasis> markiert
	  sind, sind Teil der aktiven Aggregations-Gruppe, die mit dem
	  Switch ausgehandelt wurde.  Der Verkehr wird über diese
	  Gruppe übertragen und empfangen.  Benutzen Sie
	  &man.ifconfig.8; mit <option>-v</option>, um sich die
	  <acronym>LAG</acronym>-Bezeichner anzeigen zu lassen.</para>

	<para>Um den Status der Ports auf dem Switch
	  anzuzeigen, benutzen Sie
	  <userinput>show lacp neighbor</userinput>:</para>

	<screen>switch# show lacp neighbor
Flags:  S - Device is requesting Slow LACPDUs
        F - Device is requesting Fast LACPDUs
        A - Device is in Active mode       P - Device is in Passive mode

Channel group 1 neighbors

Partner's information:

                  LACP port                        Oper    Port     Port
Port      Flags   Priority  Dev ID         Age     Key     Number   State
Fa0/1     SA      32768     0005.5d71.8db8  29s    0x146   0x3      0x3D
Fa0/2     SA      32768     0005.5d71.8db8  29s    0x146   0x4      0x3D</screen>

	<para>Benutzen Sie <userinput>show lacp neighbor
	  detail</userinput>, um weitere Informationen zu
	  erhalten.</para>

	<para>Damit diese Konfiguration auch nach einem Neustart
	  erhalten bleibt, fügen Sie auf dem &os;-System folgende
	  Einträge in <filename>/etc/rc.conf</filename> hinzu:</para>

	<programlisting>ifconfig_<replaceable>fxp0</replaceable>="up"
ifconfig_<replaceable>fxp1</replaceable>="up"
cloned_interfaces="<literal>lagg<replaceable>0</replaceable></literal>
ifconfig_<literal>lagg<replaceable>0</replaceable></literal>="laggproto lacp laggport <replaceable>fxp0</replaceable> laggport <replaceable>fxp1</replaceable> <replaceable>10.0.0.3/24</replaceable>"</programlisting>
      </example>

      <example xml:id="networking-lagg-failover">
	<title>Ausfallsicherer Modus</title>

	<para>Der ausfallsichere Modus kann verwendet werden, um zu
	  einer zweiten Schnittstelle zu wechseln, sollte die
	  Verbindung mit der Master-Schnittstelle ausfallen.  Um den
	  ausfallsicheren Modus zu konfigurieren, aktivieren Sie
	  zunächst die zugrunde liegenden physikalischen
	  Schnittstellen.  Erstellen Sie dann die
	  &man.lagg.4;-Schnittstelle mit
	  <replaceable>fxp0</replaceable> als Master-Schnittstelle und
	  <replaceable>fxp1</replaceable> als sekundäre Schnittstelle.
	  Der virtuellen Schnittstelle wird die
	  <acronym>IP</acronym>-Adresse
	  <replaceable>10.0.0.15/24</replaceable> zugewiesen:</para>

	<screen>&prompt.root; <userinput>ifconfig <replaceable>fxp0</replaceable> up</userinput>
&prompt.root; <userinput>ifconfig <replaceable>fxp1</replaceable> up</userinput>
&prompt.root; <userinput>ifconfig <literal>lagg<replaceable>0</replaceable></literal> create</userinput>
&prompt.root; <userinput>ifconfig <literal>lagg<replaceable>0</replaceable></literal> up laggproto failover laggport <replaceable>fxp0</replaceable> laggport <replaceable>fxp1</replaceable> <replaceable>10.0.0.15/24</replaceable></userinput></screen>

	<para>Die virtuelle Schnittstelle sollte in etwa so
	  aussehen:</para>

	<screen>&prompt.root; <userinput>ifconfig lagg0</userinput>
lagg0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        options=8&lt;VLAN_MTU&gt;
        ether 00:05:5d:71:8d:b8
        inet 10.0.0.15 netmask 0xffffff00 broadcast 10.0.0.255
        media: Ethernet autoselect
        status: active
        laggproto failover
        laggport: fxp1 flags=0&lt;&gt;
        laggport: fxp0 flags=5&lt;MASTER,ACTIVE&gt;</screen>

	<para>Der Verkehr wird auf <replaceable>fxp0</replaceable>
	  übertragen und empfangen.  Wenn die Verbindung auf
	  <replaceable>fxp0</replaceable> abbricht, wird
	  <replaceable>fxp1</replaceable> die Verbindung übernehmen.
	  Sobald die Verbindung auf der Master-Schnittstelle
	  wiederhergestellt ist, wird diese wieder als aktive
	  Schnittstelle genutzt.</para>

	<para>Damit diese Konfiguration auch nach einem Neustart
	  erhalten bleibt, fügen Sie folgende Einträge in
	  <filename>/etc/rc.conf</filename> hinzu:</para>

	<programlisting>ifconfig_<replaceable>fxp0</replaceable>="up"
ifconfig_<replaceable>fxp1</replaceable>="up"
cloned_interfaces="<literal>lagg<replaceable>0</replaceable></literal>
ifconfig_<literal>lagg<replaceable>0</replaceable></literal>="laggproto failover laggport <replaceable>fxp0</replaceable> laggport <replaceable>fxp1</replaceable> <replaceable>10.0.0.15/24</replaceable>"</programlisting>
      </example>

      <example xml:id="networking-lagg-wired-and-wireless">
	<title>Failover Modus zwischen Ethernet- und
	  Wireless-Schnittstellen</title>

	<para>Für Laptop-Benutzer ist es normalerweise wünschenswert,
	  <quote>wireless</quote> als sekundäre Schnittstelle
	  einzurichten, die verwendet wird, wenn die
	  Ethernet-Verbindung nicht verfügbar ist.  Mit &man.lagg.4;
	  ist es möglich, ein Failover mit einer
	  <acronym>IP</acronym>-Adresse zu konfigurieren, welches die
	  Ethernet-Verbindung aus Performance- und Sicherheitsgründen
	  bevorzugt, während es gleichzeitig möglich bleibt, Daten
	  über die drahtlose Verbindung zu übertragen.</para>

	<para>Dies wird durch das Überschreiben der physikalischen
	  <acronym>MAC</acronym>-Adresse der drahtlosen Schnittstelle,
	  durch die der Ethernet-Schnittstelle erreicht.</para>

	<para>In diesem Beispiel ist die Ethernet-Schnittstelle
	  <replaceable>bge0</replaceable>  die Master-Schnittstelle
	  und die drahtlose Schnittstelle
	  <replaceable>wlan0</replaceable> die Failover-Schnittstelle.
	  <replaceable>wlan0</replaceable> wurde von der
	  <replaceable>iwn0</replaceable> mit der
	  <acronym>MAC</acronym>-Adresse der Ethernet-Schnittstelle
	  eingerichtet.  Im ersten Schritt wird die
	  <acronym>MAC</acronym>-Adresse der
	  Ethernet-Schnittstelle ermittelt:</para>

	<screen>&prompt.root; <userinput>ifconfig <replaceable>bge0</replaceable></userinput>
bge0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	options=19b&lt;RXCSUM,TXCSUM,VLAN_MTU,VLAN_HWTAGGING,VLAN_HWCSUM,TSO4&gt;
	ether 00:21:70:da:ae:37
	inet6 fe80::221:70ff:feda:ae37%bge0 prefixlen 64 scopeid 0x2
	nd6 options=29&lt;PERFORMNUD,IFDISABLED,AUTO_LINKLOCAL&gt;
	media: Ethernet autoselect (1000baseT &lt;full-duplex&gt;)
	status: active</screen>

	<para>Ersetzen Sie <replaceable>bge0</replaceable> durch den
	  Namen der Ethernet-Schnittstelle des Systems.  Die
	  <literal>ether</literal>-Zeile wird die
	  <acronym>MAC</acronym>-Adresse der angegebenen Schnittstelle
	  enthalten.  Ändern Sie nun die
	  <acronym>MAC</acronym>-Adresse der zugrunde liegenden
	  drahtlosen Schnittstelle:</para>

	<screen>&prompt.root; <userinput>ifconfig <replaceable>iwn0</replaceable> ether <replaceable>00:21:70:da:ae:37</replaceable></userinput></screen>

	<para>Starten Sie die drahtlose Schnittstelle, aber ohne
	  eine <acronym>IP</acronym>-Adresse zu setzen:</para>

	<screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> create wlandev <replaceable>iwn0</replaceable> ssid <replaceable>my_router</replaceable> up</userinput></screen>

	<para>Stellen Sie sicher, dass die
	  <replaceable>bge0</replaceable>-Schnittstelle aktiv ist.
	  Erstellen Sie die &man.lagg.4;-Schnittstelle mit
	  <replaceable>bge0</replaceable> als Master und
	  <replaceable>wlan0</replaceable> als Failover:</para>

	<screen>&prompt.root; <userinput>ifconfig <replaceable>bge0</replaceable> up</userinput>
&prompt.root; <userinput>ifconfig <literal>lagg<replaceable>0</replaceable></literal> create</userinput>
&prompt.root; <userinput>ifconfig <literal>lagg<replaceable>0</replaceable></literal> up laggproto failover laggport <replaceable>bge0</replaceable> laggport <replaceable>wlan0</replaceable></userinput></screen>

	<para>Die virtuelle Schnittstelle sollte in etwa so
	  aussehen:</para>

	<screen>&prompt.root; <userinput>ifconfig <literal>lagg<replaceable>0</replaceable></literal></userinput>
lagg0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        options=8&lt;VLAN_MTU&gt;
        ether 00:21:70:da:ae:37
        media: Ethernet autoselect
        status: active
        laggproto failover
        laggport: wlan0 flags=0&lt;&gt;
        laggport: bge0 flags=5&lt;MASTER,ACTIVE&gt;</screen>

	<para>Starten Sie dann den <acronym>DHCP</acronym>-Client,
	  um eine <acronym>IP</acronym>-Adresse zu erhalten:</para>

	<screen>&prompt.root; <userinput>dhclient <literal>lagg<replaceable>0</replaceable></literal></userinput></screen>

	<para>Damit diese Konfiguration auch nach einem Neustart
	  erhalten bleibt, fügen Sie folgende Einträge in
	  <filename>/etc/rc.conf</filename> hinzu:</para>

	<programlisting>ifconfig_bge0="up"
wlans_<replaceable>iwn0</replaceable>="wlan0"
ifconfig_wlan0="WPA"
create_args_wlan0="<replaceable>wlanaddr 00:21:70:da:ae:37</replaceable>"
cloned_interfaces="<literal>lagg<replaceable>0</replaceable></literal>"
ifconfig_<literal>lagg<replaceable>0</replaceable></literal>="up laggproto failover laggport bge0 laggport wlan0 DHCP"</programlisting>
      </example>
    </sect2>
  </sect1>

  <sect1 xml:id="network-diskless">
    <info>
      <title>Plattenloser Betrieb mit <acronym>PXE</acronym></title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Jean-Fran&ccedil;ois</firstname>
	    <surname>Dock&egrave;s</surname>
	  </personname>
	  <contrib>Aktualisiert von </contrib>
	</author>
      </authorgroup>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Alex</firstname>
	    <surname>Dupre</surname>
	  </personname>
	  <contrib>Reorganisiert und erweitert von </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>plattenloser Arbeitsplatz</primary>
    </indexterm>
    <indexterm>
      <primary>plattenloser Betrieb</primary>
    </indexterm>

    <para>Das &intel; Preboot eXecution Environment
      (<acronym>PXE</acronym>) erlaubt es dem Betriebssystem über das
      Netzwerk zu starten.  Zum Beispiel kann ein &os;-System, ohne
      lokale Festplatte, über das Netzwerk gestartet und betrieben
      werden.  Die Dateisysteme werden dabei über einen
      <acronym>NFS</acronym>-Server eingehangen.
      <acronym>PXE</acronym>-Unterstützung steht in der Regel im
      <acronym>BIOS</acronym> zur Verfügung.  Um
      <acronym>PXE</acronym> beim Systemstart zu verwenden, müssen Sie
      im <acronym>BIOS</acronym> des Rechners die Option <literal>Über
	das Netzwerk starten</literal> aktivieren.  Alternativ können
      Sie während der PC-Initialisierung auch eine Funktionstaste
      drücken.</para>

    <para>Um die notwendigen Dateien für ein Betriebssystem für den
      Start über das Netzwerk bereitzustellen, benötigt ein
      <acronym>PXE</acronym>-Setup einen richtig konfigurierten
      <acronym>DHCP</acronym>-, <acronym>TFTP</acronym>- und
      <acronym>NFS</acronym>-Server, wobei:</para>

    <itemizedlist>
      <listitem>
	<para>Die initialen Parameter, wie
	  <acronym>IP</acronym>-Adresse, Dateiname und Speicherort
	  der ausführbaren Bootdateien, Servername sowie Root-Pfad
	  vom <acronym>DHCP</acronym>-Server bezogen werden.</para>
      </listitem>

      <listitem>
	<para>Der Loader für das Betriebssystem über
	  <acronym>TFTP</acronym> gestartet wird.</para>
      </listitem>

      <listitem>
	<para>Die Dateisysteme über
	  <acronym>NFS</acronym> geladen werden.</para>
      </listitem>
    </itemizedlist>

    <para>Sobald das Gastsystem über <acronym>PXE</acronym> startet,
      erhält es vom <acronym>DHCP</acronym>-Server Informationen, wo
      der initiale Bootloader per <acronym>TFTP</acronym> zu bekommen
      ist.  Nachdem das Gastsystem diese Informationen erhalten hat,
      lädt es den Bootloader über <acronym>TFTP</acronym> herunter und
      führt diesen anschließend aus.  In &os; ist
      <filename>/boot/pxeboot</filename> der Bootloader.  Nachdem
      <filename>/boot/pxeboot</filename> ausgeführt und der
      &os;-Kernel geladen wurde, wird mit dem Rest der
      &os;-Bootsequenz, wie in <xref linkend="boot"/> beschrieben,
      fortgefahren.</para>

    <para>Dieser Abschnitt beschreibt, wie Sie diese Dienste auf
      einem &os;-System so konfigurieren, sodass andere Systeme &os;
      über <acronym>PXE</acronym> starten können.  Weitere
      Informationen finden Sie in &man.diskless.8;.</para>

    <caution>
      <para>Wie beschrieben, ist das System, welches diese Dienste
	bereitstellt, unsicher.  Daher sollte es in einem
	geschützten Bereich des Netzwerks aufgestellt und von
	anderen Hosts als nicht vertrauenswürdig eingestuft
	werden.</para>
    </caution>

    <sect2 xml:id="network-pxe-nfs">
      <info>
	<title>Konfiguration der
	  <acronym>PXE</acronym>-Umgebung</title>

	<authorgroup>
	  <author>
	    <personname>
	      <firstname>Craig</firstname>
	      <surname>Rodrigues</surname>
	    </personname>
	    <affiliation>
	      <address>rodrigc@FreeBSD.org</address>
	    </affiliation>
	    <contrib>Beigetragen von </contrib>
	  </author>
	</authorgroup>
      </info>

      <para>Die in diesem Abschnitt dargestellten Schritte
	konfigurieren die in &os; enthaltenen <acronym>NFS</acronym>-
	und <acronym>TFTP</acronym>-Server.  Der folgende Abschnitt
	beschreibt die Installation und Konfiguration des
	<acronym>DHCP</acronym>-Servers.  In diesem Beispiel verwenden
	wir <filename>/b/tftpboot/FreeBSD/install</filename>, welches
	die Dateien für <acronym>PXE</acronym>-Benutzer enthält.  Es
	ist wichtig, dass dieses Verzeichnis existiert und das der
	gleiche Verzeichnisname ebenfalls in
	<filename>/etc/inetd.conf</filename> und
	<filename>/usr/local/etc/dhcpd.conf</filename> gesetzt
	wird.</para>

      <procedure>
	<step>
	  <para>Erstellen Sie das Root-Verzeichnis, welches eine
	    &os;-Installation enthält und über <acronym>NFS</acronym>
	    eingehangen werden kann:</para>

	  <screen>&prompt.root; <userinput>export NFSROOTDIR=/b/tftpboot/FreeBSD/install</userinput>
&prompt.root; <userinput>mkdir -p ${NFSROOTDIR}</userinput></screen>
	</step>

	<step>
	  <para>Aktivieren Sie den <acronym>NFS</acronym>-Server,
	    indem Sie folgende Zeile in
	    <filename>/etc/rc.conf</filename> hinzufügen:</para>

	  <programlisting>nfs_server_enable="YES"</programlisting>

	  <para>Exportieren Sie das Root-Verzeichnis über
	    <acronym>NFS</acronym>, indem Sie folgende Zeile in
	    <filename>/etc/exports</filename> hinzufügen:</para>

	  <programlisting>/b -ro -alldirs -maproot=root</programlisting>
	</step>

	<step>
	  <para>Starten Sie den <acronym>NFS</acronym>-Server:</para>

	  <screen>&prompt.root; <userinput>service nfsd start</userinput></screen>
	</step>

	<step>
	  <para>Aktivieren Sie &man.inetd.8;, indem Sie folgende Zeile
	    in <filename>/etc/rc.conf</filename> hinzufügen:</para>

	  <programlisting>inetd_enable="YES"</programlisting>
	</step>

	<step>
	  <para>Kommentieren Sie die folgende Zeile in
	    <filename>/etc/inetd.conf</filename> aus, indem Sie
	    sicherstellen, dass die Zeile nicht mit einem
	    <literal>#</literal>-Zeichen beginnt:</para>

	  <programlisting>tftp dgram udp wait root /usr/libexec/tftp tftp -l -s /b/tftpboot</programlisting>

	  <note>
	    <para>Einige <acronym>PXE</acronym>-Versionen benötigen
	      die <acronym>TCP</acronym>-Version von
	      <acronym>TFTP</acronym>.  In diesem Fall können Sie
	      die zweite <literal>tftp</literal>-Zeile, welche
	      <literal>stream tcp</literal> enthält,
	      auskommentieren.</para>
	  </note>
	</step>

	<step>
	  <para>Starten Sie &man.inetd.8;:</para>

	  <screen>&prompt.root; <userinput>service inetd start</userinput></screen>
	</step>

	<step>
	  <para>Installieren Sie das Basissystem nach
	    <filename>${NFSROOTDIR}</filename>, indem Sie die
	    offiziellen Archive entpacken, oder ein neues
	    Basissystem und einen &os;-Kernel erstellen.  Detaillierte
	    Anweisungen hierzu finden Sie im <xref
	      linkend="makeworld"/>.  Vergessen Sie jedoch nicht
	    <option>DESTDIR=<replaceable>${NFSROOTDIR}</replaceable></option>
	    hinzuzufügen, wenn Sie die Kommandos
	    <command>make installkernel</command> und
	    <command>make installworld</command> ausführen.</para>
	</step>

	<step>
	  <para>Testen Sie den <acronym>TFTP</acronym>-Server und
	    vergewissern Sie sich, dass Sie den Bootloader
	    herunterladen können, der über <acronym>PXE</acronym>
	    bereitgestellt wird:</para>

	  <screen>&prompt.root; <userinput>tftp localhost</userinput>
tftp> <userinput>get FreeBSD/install/boot/pxeboot</userinput>
Received 264951 bytes in 0.1 seconds</screen>
	</step>

	<step>
	  <para>Bearbeiten Sie
	    <filename>${NFSROOTDIR}/etc/fstab</filename> und
	    erstellen Sie einen Eintrag, um das Root-Dateisystem
	    über <acronym>NFS</acronym> einzuhängen:</para>

	  <programlisting># Device                                         Mountpoint    FSType   Options  Dump Pass$
	    <replaceable>myhost.example.com</replaceable>:/b/tftpboot/FreeBSD/install       /         nfs      ro        0    0</programlisting>

	  <para>Ersetzen Sie
	    <replaceable>myhost.example.com</replaceable> durch den
	    Hostnamen oder die <acronym>IP</acronym>-Adresse des
	    <acronym>NFS</acronym>-Servers.  In diesem Beispiel wird
	    das Root-Dateisystem schreibgeschützt eingehangen, um
	    ein potenzielles Löschen des Inhalts durch die
	    <acronym>NFS</acronym>-Clients zu verhindern.</para>
	</step>

	<step>
	  <para>Setzen Sie das root-Passwort in der
	    <acronym>PXE</acronym>-Umgebung für Client-Maschinen, die
	    über <acronym>PXE</acronym> starten:</para>

	  <screen>&prompt.root; <userinput>chroot ${NFSROOTDIR} </userinput>
&prompt.root; <userinput>passwd</userinput></screen>
	</step>

	<step>
	  <para>Falls erforderlich, aktivieren Sie &man.ssh.1;
	    root-Logins für Client-Maschinen, die über
	    <acronym>PXE</acronym> starten, indem Sie die
	    Option <literal>PermitRootLogin</literal> in
	    <filename>${NFSROOTDIR}/etc/ssh/sshd_config</filename>
	    aktivieren.  Dies ist in &man.sshd.config.5;
	    dokumentiert.</para>
	</step>

	<step>
	  <para>Führen Sie alle weiteren Anpassungen der
	    <acronym>PXE</acronym>-Umgebung in
	    <filename>${NFSROOTDIR}</filename> durch,
	    wie zum Beispiel die Installation weiterer Pakete, oder
	    dass Bearbeiten der Passwortdatei mit &man.vipw.8;.</para>
	</step>
      </procedure>

      <para>Booten Sie von einem <acronym>NFS</acronym>-Root-Volume,
	so erkennt <filename>/etc/rc</filename> dies und startet
	daraufhin das <filename>/etc/rc.initdiskless</filename>
	Skript.  Lesen Sie die Kommentare in diesem Skript um zu
	verstehen, was dort vor sich geht.  Weil das
	<acronym>NFS</acronym>-Root-Verzeichnis schreibgeschützt ist,
	wir aber Schreibzugriff für <filename>/etc</filename> und
	<filename>/var</filename> benötigen, müssen wir diese
	Verzeichnisse über Speicher-Dateisysteme (memory backed file
	system) einbinden.</para>

      <screen>&prompt.root; <userinput>chroot ${NFSROOTDIR}</userinput>
&prompt.root; <userinput>mkdir -p conf/base</userinput>
&prompt.root; <userinput>tar -c -v -f conf/base/etc.cpio.gz --format cpio --gzip etc</userinput>
&prompt.root; <userinput>tar -c -v -f conf/base/var.cpio.gz --format cpio --gzip var</userinput></screen>

      <para>Wenn das System bootet, werden Speicher-Dateisysteme
	für <filename>/etc</filename> und
	<filename>/var</filename> erstellt und eingehangen.
	Anschließend wird der Inhalt der
	<filename>cpio.gz</filename>-Dateien in diese Dateisysteme
	kopiert.  Standardmäßig haben diese Dateisysteme eine maximale
	Kapazität von 5 Megabyte.  Wenn die Archive nicht passen, was
	für gewöhnlich bei <filename>/var</filename> der Fall ist,
	erhöhen Sie die Kapazität indem Sie die Anzahl der benötigten
	512 Byte Sektoren (5 Megabyte sind 10240 Sektoren) in
	<filename>${NFSROOTDIR}/conf/base/etc/md_size</filename> und
	<filename>${NFSROOTDIR}/conf/base/var/md_size</filename> für
	die Dateisysteme <filename>/etc</filename> und
	<filename>/var</filename> eintragen.</para>
    </sect2>

    <sect2 xml:id="network-pxe-setting-up-dhcp">
      <title>Konfiguration des
	<acronym>DHCP</acronym>-Servers</title>

      <indexterm>
	<primary>DHCP</primary>
	<secondary>plattenloser Betrieb</secondary>
      </indexterm>

      <para>Der <acronym>DHCP</acronym>-Server muss nicht auf
	derselben Maschine laufen wie der <acronym>TFTP</acronym>- und
	<acronym>NFS</acronym>-Server, aber er muss über das Netzwerk
	erreichbar sein.</para>

      <para><acronym>DHCP</acronym> ist nicht Bestandteil des &os;
	Basissystems, kann jedoch über den Port
	<package>net/isc-dhcp43-server</package> oder als Paket
	nachinstalliert werden.</para>

      <para>Einmal installiert, bearbeiten Sie die
	Konfigurationsdatei
	<filename>/usr/local/etc/dhcpd.conf</filename>.
	Konfigurieren Sie die <literal>next-server</literal>,
	<literal>filename</literal> und <literal>root-path</literal>
	Einstellungen, wie in diesem Beispiel zu sehen ist:</para>

      <programlisting>subnet 192.168.0.0 netmask 255.255.255.0 {
range 192.168.0.2 192.168.0.3;
option subnet-mask 255.255.255.0;
option routers 192.168.0.1;
option broadcast-address 192.168.0.255;
option domain-name-servers 192.168.35.35, 192.168.35.36;
option domain-name "example.com";

# IP address of TFTP server
next-server <replaceable>192.168.0.1</replaceable>;

# path of boot loader obtained via tftp
filename "<replaceable>FreeBSD/install/boot/pxeboot</replaceable>";

# pxeboot boot loader will try to NFS mount this directory for root FS
option root-path "<replaceable>192.168.0.1:/b/tftpboot/FreeBSD/install/</replaceable>";
}</programlisting>

<!--
This option still needed?
host corbieres {
	  <para>Diese Option
	    weist <application>dhcpd</application> an, den Wert der
	    <literal>host</literal>-Deklaration als Rechnernamen des
	    plattenlosen Rechners zu senden.  Alternativ kann man der
	    <literal>host</literal>-Deklaration Folgendes
	    hinzufügen: <literal>option host-name
	    margaux</literal></para>
            -->

      <para>Die Anweisung <literal>next-server</literal> wird benutzt,
	um die <acronym>IP</acronym>-Adresse des
	<acronym>TFTP</acronym>-Servers anzugeben.</para>

      <para>Die Anweisung <literal>filename</literal> definiert den
	Pfad zu <filename>/boot/pxeboot</filename>.  Da hier der
	relative Dateiname verwendet wird, bedeutet das, dass
	<filename>/b/tftpboot</filename> nicht im Pfad enthalten
	ist.</para>

      <para>Die Option <literal>root-path</literal> bestimmt den
	Pfad zum <acronym>NFS</acronym> root-Dateisystem.</para>

      <para>Sobald die Änderungen gespeichert werden, aktivieren
	Sie <acronym>DHCP</acronym> beim Systemstart, indem Sie die
	folgende Zeile in <filename>/etc/rc.conf</filename>
	hinzufügen:</para>

      <programlisting>dhcpd_enable="YES"</programlisting>

      <para>Starten Sie anschließend den
	<acronym>DHCP</acronym>-Dienst:</para>

      <screen>&prompt.root; <userinput>service isc-dhcpd start</userinput></screen>
    </sect2>

<!--
I don't know why this is still here. Comment it out for now.
      <sect2>
	<title>Konfiguration bei Verwendung von BOOTP</title>

	<indexterm>
	  <primary>BOOTP</primary>
	  <secondary>plattenloser Betrieb</secondary>
	</indexterm>

	<para>Es folgt nun eine der Konfiguration von DHCP
	  entsprechende Konfiguration (für einen Client) für
	  <application>bootpd</application>.  Zu finden ist die
	  Konfigurationsdatei unter <filename>/etc/bootptab</filename>.
	</para>

	<para>Beachten Sie bitte, dass
	  <application>Etherboot</application> mit der Option
	  <literal>NO_DHCP_SUPPORT</literal> kompiliert werden muss,
	  damit BOOTP verwendet werden kann.  <acronym>PXE</acronym>
	  hingegen <emphasis>benötigt</emphasis>
	  <acronym>DHCP</acronym>.  Der einzige offensichtliche
	  Vorteil von <application>bootpd</application> ist, dass es
	  bereits im Basissystem vorhanden ist.</para>

	<programlisting>.def100:\
  :hn:ht=1:sa=192.168.4.4:vm=rfc1048:\
  :sm=255.255.255.0:\
  :ds=192.168.4.1:\
  :gw=192.168.4.1:\
  :hd="/tftpboot":\
  :bf="/kernel.diskless":\
  :rp="192.168.4.4:/data/misc/diskless":

margaux:ha=0123456789ab:tc=.def100</programlisting>
      </sect2>

      <sect2>
        <title>Ein Startprogramm unter Verwendung von
          <application>Etherboot</application> erstellen</title>

        <indexterm>
          <primary>Etherboot</primary>
        </indexterm>

	<para>Die <link xlink:href="http://etherboot.sourceforge.net">
	  Internetseite von Etherboot</link> enthält
	  <link xlink:href="http://etherboot.sourceforge.net/doc/html/userman/t1.html">
          ausführliche Informationen</link>, die zwar vor allem
          für Linux gedacht sind, aber dennoch nützliche
          Informationen enthalten.  Im Folgenden wird daher nur grob
          beschrieben, wie Sie <application>Etherboot</application> auf
          einem &os;-System einsetzen können.</para>

        <para>Als Erstes müssen Sie
          <package>net/etherboot</package> als Paket
          oder als Port installieren.</para>

	<para>Sie können <application>Etherboot</application> so
	  konfigurieren, dass <acronym>TFTP</acronym> anstelle von
	  <acronym>NFS</acronym> verwendet wird, indem Sie die Datei
	  <filename>Config</filename> im Quellverzeichnis von
	  <application>Etherboot</application> bearbeiten.</para>

        <para>Für unsere Installation verwenden wir eine
          Startdiskette.  Für Informationen zu anderen Methoden
	  (PROM oder &ms-dos;-Programme) lesen Sie bitte die
	  Dokumentation zu <application>Etherboot</application>.</para>

        <para>Um eine Startdiskette zu erzeugen, legen Sie eine Diskette
          in das Laufwerk des Rechners ein, auf dem Sie
          <application>Etherboot</application> installiert haben.  Danach
          wechseln Sie in das Verzeichnis <filename>src</filename> des
          <application>Etherboot</application>-Verzeichnisbaums und geben
          Folgendes ein:</para>

	<screen>&prompt.root; <userinput>gmake bin32/devicetype.fd0</userinput></screen>

        <para><replaceable>devicetype</replaceable> hängt vom Typ
          der Ethernetkarte ab, über die der plattenlose Rechner
          verfügt.  Lesen Sie dazu <filename>NIC</filename> im
          gleichen Verzeichnis, um den richtigen Wert für
        <replaceable>devicetype</replaceable> zu bestimmen.</para>
      </sect2>
-->
<!--
Are these sections still needed?
      <sect2>
        <title>Vorbereitung des Root-Dateisystems</title>

        <indexterm>
          <primary>plattenloser Betrieb</primary>
          <secondary>Kernelkonfiguration</secondary>
        </indexterm>

        <para>Wenn Sie <acronym>PXE</acronym> verwenden, ist die
          Erzeugung eines neuen Kernels zwar nicht unbedingt
          notwendig, es wird allerdings dennoch empfohlen.  Die
          Aktivierung dieser Optionen bewirkt, dass die Anzahl der
          möglichen <acronym>DHCP</acronym>-Anfragen während des
          Kernelstarts erhöht wird.  Ein kleiner Nachteil sind
          eventuell auftretende Inkonsistenzen zwischen den neuen
          Werten und den von &man.pxeboot.8; erhaltenen Werten.
          Der große Vorteil dieser Variante ist es, das dabei der
          Rechnername gesetzt wird, den Sie ansonsten durch eine
          andere Methode, beispielsweise in einer clientspezifischen
          <filename>/etc/rc.conf</filename> festlegen müssten.</para>

        <programlisting>options     BOOTP          # Use BOOTP to obtain IP address/hostname
options     BOOTP_NFSROOT  # NFS mount root file system using BOOTP info</programlisting>

        <para>Außerdem können Sie die Optionen
	  <literal>BOOTP_NFSV3</literal>,
	  <literal>BOOT_COMPAT</literal> sowie
          <literal>BOOTP_WIRED_TO</literal> verwenden (sehen Sie sich
	  dazu auch die Datei <filename>NOTES</filename> an).</para>

	 <para>Die Namen dieser Optionen sind historisch bedingt.
	   Sie ermöglichen eine unterschiedliche Verwendung von
	   <acronym>DHCP</acronym> und BOOTP innerhalb des Kernels.
	   Es ist auch möglich, eine strikte Verwendung von BOOTP
	   oder <acronym>DHCP</acronym> zu erzwingen.</para>

        <para>Erzeugen Sie den neuen Kernel (lesen Sie dazu auch
	  <xref linkend="kernelconfig"/>) und kopieren Sie ihn an den
          in <filename>/usr/local/etc/dhcpd.conf</filename> festgelegten
          Ort.</para>

        <indexterm>
          <primary>Root-Dateisystem</primary>
	  <secondary>plattenloser Betrieb</secondary>
        </indexterm>

        <para>Sie müssen für den plattenlosen Rechner ein
          root-Dateisystem erzeugen, und zwar an dem in
          <filename>/usr/local/etc/dhcpd.conf</filename> als
	  <literal>root-path</literal> festgelegten Ort.</para>

        <para><command>make world</command> zum Füllen des
	    Dateisystems einsetzen</para>

	  <para>Diese schnelle Methode installiert ein komplettes
	    <quote>jungfräuliches</quote> System (und nicht nur ein
	    root-Dateisystem) nach <envar>DESTDIR</envar>.  Dazu
	    müssen Sie lediglich das folgende Skript
	    ausführen:</para>

	  <programlisting>#!/bin/sh
export DESTDIR=/data/misc/diskless
mkdir -p ${DESTDIR}
cd /usr/src; make buildworld &amp;&amp; make buildkernel
make installworld &amp;&amp; make installkernel
cd /usr/src/etc; make distribution</programlisting>

	  <para>Danach müssen Sie noch die dadurch in
	    <envar>DESTDIR</envar> erzeugten Dateien
	    <filename>/etc/rc.conf</filename> sowie
	    <filename>/etc/fstab</filename> Ihren Wünschen
	    anpassen.</para>
	</sect2>

      <sect2>
        <title>Den Auslagerungsbereich konfigurieren</title>

	<para>Falls nötig, kann eine auf dem
	  <acronym>NFS</acronym>-Server liegende Datei als
	  Auslagerungsdatei eingerichtet werden.</para>

	  <para>Der Kernel unterstützt beim Systemstart keine
	    <acronym>NFS</acronym>-Auslagerungsdatei.  Diese muss daher
	    in den Startskripten aktiviert werden, indem ein
	    beschreibbares Dateisystem eingehängt wird, um dort
	    die Auslagerungsdatei zu erzeugen und zu aktivieren.  Um
	    eine Auslagerungsdatei zu erzeugen, gehen Sie wie folgt
	    vor:</para>

	  <screen>&prompt.root; <userinput>dd if=/dev/zero of=<replaceable>/path/to/swapfile</replaceable> bs=1k count=1 oseek=<replaceable>100000</replaceable></userinput></screen>

	  <para>Um die Auslagerungsdatei zu aktivieren, fügen Sie
	    folgende Zeile in <filename>rc.conf</filename> ein:</para>

	  <programlisting>swapfile=<replaceable>/path/to/swapfile</replaceable></programlisting>
	</sect2>

      <sect2>
        <title>Verschiedenes</title>

          <indexterm>
            <primary>plattenloser Betrieb</primary>
            <secondary>/usr schreibgeschützt</secondary>
          </indexterm>

          <para>Wenn am plattenlosen Rechner
            <application>&xorg;</application> sowie ein
            schreibgeschütztes <filename>/usr</filename> läuft, müssen
            Sie die Konfigurationsdatei von
            <application>XDM</application> anpassen, da Fehlermeldungen
            in der Voreinstellung auf <filename>/usr</filename>
            geschrieben werden.</para>

	  <para>Wenn das root-Dateisystem nicht auf einem
	    &os;-Rechner liegt, muss das Dateisystem zuerst unter
	    &os; erzeugt werden.  Anschließend wird es
	    beispielsweise mit <command>tar</command> oder
	    <command>cpio</command> an den gewünschten Ort
	    kopiert.</para>

	  <para>Dabei kann es Probleme mit den Gerätedateien
	    in <filename>/dev</filename> geben, die durch eine
	    unterschiedliche Darstellung der  Major- und Minor-Number
	    von Geräten auf beiden Systemen hervorgerufen werden.
	    Eine Problemlösung besteht darin, das root-Verzeichnis
	    auf einem &os;-Rechner einzuhängen und die
	    Gerätedateien dort mit &man.devfs.5; zu erzeugen.</para>
    </sect2>
-->
    <sect2>
      <title>Fehlersuche bei <acronym>PXE</acronym> Problemen</title>

      <para>Sobald alle Dienste konfiguriert und gestartet wurden,
	sollten <acronym>PXE</acronym>-Clients in der Lage sein, &os;
	automatisch über das Netzwerk zu starten.  Wenn ein
	bestimmter Client beim hochfahren keine Verbindung herstellen
	kann, sehen Sie im <acronym>BIOS</acronym> nach, ob die Option
	für den Start über das Netzwerk konfiguriert ist.</para>

      <para>Dieser Abschnitt gibt einige Tipps zu Fehlerbehebung und
	zeigt, wie Sie Konfigurationsprobleme eingrezen können für
	den Fall, dass <acronym>PXE</acronym>-Clients nicht in der
	Lage sind über das Netzwerk zu starten.</para>

      <procedure>
	<step>
	  <para>Benutzen Sie den <package>net/wireshark</package> Port
	    um Fehler im Netzwerkverkehr während des Bootvorgangs von
	    <acronym>PXE</acronym> zu finden.  Der Bootvorgang wird im
	    folgenden Diagramm schematisch dargestellt.</para>

	  <figure>
	    <title><acronym>PXE</acronym>-Bootvorgang mit
	      <acronym>NFS</acronym> Root Mount</title>

	    <mediaobject>
	      <imageobjectco>
		<areaspec units="calspair">
		  <area
		    xml:id="co-pxenfs1" coords="2873,8133 3313,7266"/>
		  <area
		    xml:id="co-pxenfs2" coords="3519,6333 3885,5500"/>
		  <area
		    xml:id="co-pxenfs3" coords="4780,5866 5102,5200"/>
		  <area
		    xml:id="co-pxenfs4" coords="4794,4333 5102,3600"/>
		  <area
		    xml:id="co-pxenfs5" coords="3108,2666 3519,1800"/>
		</areaspec>
		<imageobject>
		  <imagedata fileref="advanced-networking/pxe-nfs"/>
		</imageobject>
		<calloutlist>
		  <callout arearefs="co-pxenfs1">
		    <para>Client sendet eine
		      <literal>DHCPDISCOVER</literal>
		      Nachricht.</para>
		  </callout>
		  <callout arearefs="co-pxenfs2">
		    <para>Der <acronym>DHCP</acronym>-Server antwortet
		      mit einer <acronym>IP</acronym>-Adresse, sowie
		      den Werten für <literal>next-server</literal>,
		      <literal>filename</literal> und
		      <literal>root-path</literal>.</para>
		  </callout>
		  <callout arearefs="co-pxenfs3">
		    <para>Der Client sendet eine
		      <acronym>TFTP</acronym>-Anfrage an
		      <literal>next-server</literal>, mit der Bitte
		      <literal>filename</literal> zu empfangen.</para>
		  </callout>
		  <callout arearefs="co-pxenfs4">
		    <para>Der <acronym>TFTP</acronym>-Server antwortet
		      und sendet <literal>filename</literal> zum
		      Client.</para>
		  </callout>
		  <callout arearefs="co-pxenfs5">
		    <para>Der Client führt <literal>filename</literal>,
		      sprich &man.pxeboot.8; aus, was wiederum den
		      Kernel lädt.  Wenn der Kernel ausgeführt wird,
		      wird das Root-Dateisystem, welches in
		      <literal>root-path</literal> spezifiziert ist,
		      über <acronym>NFS</acronym> eingebunden.</para>
		  </callout>
		</calloutlist>
	      </imageobjectco>
	    </mediaobject>
	  </figure>
	</step>

	<step>
	  <para>Schauen Sie in <filename>/var/log/xferlog</filename>
	    auf dem <acronym>TFTP</acronym>-Server und vergewissern
	    Sie sich, dass die <filename>pxeboot</filename>-Datei von
	    der richtigen Adresse heruntergeladen wurde.  Um die obige
	    Konfiguration von
	    <filename>/usr/local/etc/dhcpd.conf</filename> zu testen,
	    geben Sie folgendes ein:</para>

	  <screen>&prompt.root; <userinput>tftp 192.168.0.1</userinput>
tftp> <userinput>get FreeBSD/install/boot/pxeboot</userinput>
Received 264951 bytes in 0.1 seconds</screen>

	  <para>Weitere Informationen finden Sie in &man.tftpd.8; und
	    &man.tftp.1;.  Die <literal>BUGS</literal>-Sektionen dieser
	    Seiten dokumentieren einige Einschränkungen von
	    <acronym>TFTP</acronym>.</para>
	</step>

	<step>
	  <para>Achten Sie darauf, dass Sie das Root-Dateisystem über
	    <acronym>NFS</acronym> einhängen können.  Auch hier können
	    Sie Ihre Einstellungen aus
	    <filename>/usr/local/etc/dhcpd.conf</filename> wie folgt
	    testen:</para>

	  <screen>&prompt.root; <userinput>mount -t nfs 192.168.0.1:/b/tftpboot/FreeBSD/install /mnt</userinput></screen>
	</step>
      </procedure>
    </sect2>
  </sect1>

  <sect1 xml:id="network-ipv6">
    <info>
      <title><acronym>IPv6</acronym></title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Aaron</firstname>
	    <surname>Kaplan</surname>
	  </personname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <personname>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	  </personname>
	  <contrib>Überarbeitet und erweitert von </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <personname>
	    <firstname>Brad</firstname>
	    <surname>Davis</surname>
	  </personname>
	  <contrib>Erweitert von </contrib>
	</author>
      </authorgroup>
    </info>

    <para><acronym>IPv6</acronym> ist die neueste Version des
      bekannten <acronym>IP</acronym>-Protokolls, das auch als
      <acronym>IPv4</acronym> bezeichnet wird.
      <acronym>IPv6</acronym> bietet gegenüber <acronym>IPv4</acronym>
      mehrere Vorteile sowie viele neue Funktionen:</para>

    <itemizedlist>
      <listitem>
	<para><acronym>IPv6</acronym> hat einen 128&nbsp;Bit großen
	  Adressraum, der
	  340.282.366.920.938.463.463.374.607.431.768.211.456 Adressen
	  erlaubt.  Dies behebt das Problem der immer knapper
	  werdenden <acronym>IPv4</acronym>-Adressen und einer
	  eventuellen Erschöpfung des
	  <acronym>IPv4</acronym>-Adressraums.</para>
      </listitem>

      <listitem>
	<para>Router speichern nur noch Netzwerk-Aggregationsadressen
	  in ihren Routingtabellen.  Dadurch reduziert sich die
	  durchschnittliche Größe  einer Routingtabelle auf
	  8192&nbsp;Einträge.  Dies ist mit den Problemen bei der
	  Skalierbarkeit von <acronym>IPv4</acronym> verbunden, da
	  jeder zugeordnete Block von <acronym>IPv4</acronym>-Adressen
	  erfordert, dass Routing-Informationen zwischen vielen
	  Routern im Internet ausgetauscht werden müssen.  Die
	  Routing-Tabellen wurden mit der Zeit so groß, dass ein
	  effizientes Routing jetzt kaum noch möglich ist.</para>
      </listitem>
    </itemizedlist>

    <itemizedlist>
      <listitem>
	<para>Die automatische Konfiguration von Adressen, die im
	  <link xlink:href="http://www.ietf.org/rfc/rfc2462.txt">
	    RFC2462</link> beschrieben wird.</para>
      </listitem>

      <listitem>
	<para>Verpflichtende Multicast-Adressen.</para>
      </listitem>

      <listitem>
	<para>Integriertes <acronym>IPsec</acronym>
	  (<acronym>IP</acronym>-Security).</para>
      </listitem>

      <listitem>
	<para>Eine vereinfachte Headerstruktur.</para>
      </listitem>

      <listitem>
	<para>Unterstützung für mobile
	  <acronym>IP</acronym>-Adressen.</para>
      </listitem>

      <listitem>
	<para>Die Umwandlung von <acronym>IPv4</acronym>- in
	  <acronym>IPv6</acronym>-Adressen.</para>
      </listitem>
    </itemizedlist>

    <para>&os; enthält die IPv6-Referenzimplementation von <link
	xlink:href="http//www.kame.net/">KAME</link> und erfüllt
      damit bereits alle für die Nutzung von <acronym>IPv6</acronym>
      nötigen Voraussetzungen.  Dieser Abschnitt konzentriert sich
      auf die Konfiguration und den Betrieb von
      <acronym>IPv6</acronym>.</para>

    <sect2>
      <title>Hintergrundinformationen zu
	<acronym>IPv6</acronym>-Adressen</title>

      <para>Es gibt verschiedene Arten von
	<acronym>IPv6</acronym>-Adressen:</para>

      <variablelist>
	<varlistentry>
	  <term>Unicast</term>
	  <listitem>
	    <para>Ein Paket, das an eine Unicast-Adresse gesendet
	      wird, kommt nur an der Schnittstelle an, die dieser
	      Adresse zugeordnet ist.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>Anycast</term>
	  <listitem>
	    <para>Anycast-Adressen unterscheiden sich in ihrer Syntax
	      nicht von Unicast-Adressen, sie wählen allerdings aus
	      mehreren Schnittstellen eine Schnittstelle aus.  Ein für
	      eine Anycast-Adresse bestimmtes Paket kommt an der
	      nächstgelegenen (entsprechend der Router-Metrik)
	      Schnittstelle an.  Anycast-Adressen werden nur von
	      Routern verwendet.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>Mulitcast</term>
	  <listitem>
	    <para>Multicast-Adressen bestimmen Gruppen, denen mehrere
	      Schnittstellen angehören.  Ein Paket, das an eine
	      Multicast-Adresse geschickt wird, kommt an allen
	      Schnittstellen an, die zur Multicast-Gruppe gehören.
	      Die von <acronym>IPv4</acronym> bekannte
	      Broadcast-Adresse (normalerweise <systemitem
		class="ipaddress">xxx.xxx.xxx.255</systemitem>) wird
	      bei <acronym>IPv6</acronym> durch Multicast-Adressen
	      verwirklicht.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>Die kanonische Form einer <acronym>IPv6</acronym>-Adresse
	lautet <systemitem>x:x:x:x:x:x:x:x</systemitem>, wobei jedes
	<quote>x</quote> für einen 16-Bit-Hexadezimalwert steht.  Ein
	Beispiel für eine <acronym>IPv6</acronym>-Adresse wäre etwa
	<systemitem>FEBC:A574:382B:23C1:AA49:4592:4EFE:9982</systemitem>.</para>

      <para>Eine <acronym>IPv6</acronym>-Adresse enthält oft
	Teilzeichenfolgen aus lauter Nullen.  Eine solche Zeichenfolge
	kann zu <quote>::</quote> verkürzt werden.  Bis zu drei
	führende Nullen eines Hexquads können ebenfalls weggelassen
	werden.  <systemitem>fe80::1</systemitem> entspricht also der
	Adresse
	<systemitem>fe80:0000:0000:0000:0000:0000:0000:0001</systemitem>.</para>

      <para>Eine weitere Möglichkeit ist die Darstellung der letzten
	32&nbsp;Bit in der bekannten <acronym>IPv4</acronym>-Notation.
	<systemitem>2002::10.0.0.1</systemitem> ist also eine andere
	Schreibweise für die (hexadezimale) kanonische Form
	<systemitem>2002:0000:0000:0000:0000:0000:0a00:0001</systemitem>,
	die wiederum der Adresse <systemitem>2002::a00:1</systemitem>
	entspricht.</para>

      <para>Benutzen Sie &man.ifconfig.8;, um die
	<acronym>IPv6</acronym>-Adresse eines &os;-Systems
	anzuzeigen:</para>

      <screen>&prompt.root; <userinput>ifconfig</userinput>
rl0: flags=8943&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500
         inet 10.0.0.10 netmask 0xffffff00 broadcast 10.0.0.255
         inet6 fe80::200:21ff:fe03:8e1%rl0 prefixlen 64 scopeid 0x1
         ether 00:00:21:03:08:e1
         media: Ethernet autoselect (100baseTX )
         status: active</screen>

      <para>Bei <systemitem>fe80::200:21ff:fe03:8e1%rl0</systemitem>
	handelt es sich um eine automatisch konfigurierte
	<foreignphrase>link-local</foreignphrase>-Adresse.  Sie
	wird im Rahmen der automatischen Konfiguration aus der
	<acronym>MAC</acronym>-Adresse erzeugt.</para>

      <para>Einige <acronym>IPv6</acronym>-Adressen sind reserviert.
	Eine Zusammenfassung dieser Adressen finden Sie in
	<xref linkend="reservedip6"/>:</para>

      <table xml:id="reservedip6" frame="none">
	<title>Reservierte <acronym>IPv6</acronym>-Adressen</title>

	<tgroup cols="4">
	  <thead>
	    <row>
	      <entry><acronym>IPv6</acronym>-Adresse</entry>
	      <entry>Präfixlänge</entry>
	      <entry>Beschreibung</entry>
	      <entry>Anmerkungen</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><systemitem>::</systemitem></entry>
	      <entry>128 Bit</entry>
	      <entry>nicht festgelegt</entry>
	      <entry>entspricht <systemitem
		  class="ipaddress">0.0.0.0</systemitem> bei
		<acronym>IPv4</acronym>.</entry>
	    </row>

	    <row>
	      <entry><systemitem>::1</systemitem></entry>
	      <entry>128 Bit</entry>
	      <entry>Loopback-Adresse</entry>
	      <entry>entspricht <systemitem
		  class="ipaddress">127.0.0.1</systemitem> bei
		<acronym>IPv4</acronym>.</entry>
	    </row>

	    <row>
	      <entry><systemitem>::00:xx:xx:xx:xx</systemitem></entry>
	      <entry>96 Bit</entry>
	      <entry>Eingebettete
		<acronym>IPv4</acronym>-Adresse</entry>
	      <entry>Die niedrigen 32&nbsp;Bit sind die kompatiblen
		<acronym>IPv4</acronym>-Adressen.</entry>
	    </row>

	    <row>
	      <entry><systemitem>::ff:xx:xx:xx:xx</systemitem></entry>
	      <entry>96 Bit</entry>
	      <entry>Eine auf <acronym>IPv6</acronym> abgebildete
		<acronym>IPv4</acronym>-Adresse.</entry>
	      <entry>Die niedrigen 32&nbsp;Bit sind
		<acronym>IPv4</acronym>-Adressen für Hosts, die kein
		<acronym>IPv6</acronym> unterstützen.</entry>
	    </row>

	    <row>
	      <entry><systemitem>fe80::/10</systemitem></entry>
	      <entry>10 Bit</entry>
	      <entry>link-local</entry>
	      <entry>Entspricht 196.254.0.0/16 bei
		<acronym>IPv4</acronym>.</entry>
	    </row>

	    <row>
	      <entry><systemitem>fc00::/7</systemitem></entry>
	      <entry>7 Bit</entry>
	      <entry>unique-local</entry>
	      <entry>Diese einzigartigen Adressen sind für die lokale
		Kommunikation bestimmt und werden nur innerhalb von
		abgegrenzten Standorten
		(<foreignphrase>Sites</foreignphrase>)
		weitergeleitet.</entry>
	    </row>

	    <row>
	      <entry><systemitem>ff00::</systemitem></entry>
	      <entry>8 Bit</entry>
	      <entry>Multicast</entry>
	      <entry>&nbsp;</entry>
	    </row>

	    <row>
	      <entry><systemitem>2000::-3fff:: </systemitem></entry>
	      <entry>3 Bit</entry>
	      <entry>Globaler Unicast</entry>
	      <entry>Alle globalen Unicast-Adressen stammen aus diesem
		Pool.  Die ersten 3&nbsp;Bit lauten
		<literal>001</literal>.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <para>Weitere Informationen zum Aufbau von
	<acronym>IPv6</acronym>-Adressen finden Sie im <link
	  xlink:href="http://www.ietf.org/rfc/rfc3513.txt">
	  RFC3513</link>.</para>
    </sect2>

    <sect2>
      <title><acronym>IPv6</acronym> konfigurieren</title>

      <para>Um ein &os;-System als <acronym>IPv6</acronym>-Client zu
	konfigurieren, fügen Sie folgende Zeile in
	<filename>/etc/rc.conf</filename> ein:</para>

      <programlisting>ifconfig_<replaceable>rl0</replaceable>_ipv6="inet6 accept_rtadv"
rtsold_enable="YES"</programlisting>

      <para>Die erste Zeile ermöglicht der angegebenen Schnittstelle,
	Router-Solicitation-Nachrichten zu empfangen.  Die zweite
	Zeile aktiviert den Router-Solicitation-Daemon
	&man.rtsold.8;.</para>

      <para>Falls die Schnittstelle eine statisch zugewiesene
	<acronym>IPv6</acronym>-Adresse benötigt, fügen Sie einen
	Eintrag mit der statischen Adresse und dem zugehörigen
	Präfix für das Subnetz hinzu:</para>

      <programlisting>ifconfig_<replaceable>rl0</replaceable>_ipv6="inet6 <replaceable>2001:db8:4672:6565:2026:5043:2d42:5344</replaceable> prefixlen <replaceable>64</replaceable>"</programlisting>

      <para>Um einen Standardrouter festzulegen, fügen Sie die
	Adresse hinzu:</para>

      <programlisting>ipv6_defaultrouter="<replaceable>2001:db8:4672:6565::1</replaceable>"</programlisting>
    </sect2>

    <sect2>
      <title>Verbindung zu einem Provider aufbauen</title>

      <para>Um sich mit anderen <acronym>IPv6</acronym>-Netzwerken
	zu verbinden, benötigen Sie einen Provider oder einen
	Tunnel, der <acronym>IPv6</acronym> unterstützt:</para>

      <itemizedlist>
	<listitem>
	  <para>Fragen Sie einen Internetprovider, ob er
	    <acronym>IPv6</acronym> anbietet.</para>
	</listitem>

	<listitem>
	  <para><link
	      xlink:href="http://www.tunnelbroker.net">Hurricane
	    Electric</link> bietet weltweit
	    <acronym>IPv6</acronym>-Tunnelverbindungen an.</para>
	</listitem>
      </itemizedlist>

      <note>
	<para>Die Verwendung des Ports
	  <filename>/usr/ports/net/freenet6</filename> für
	  Einwahlverbindungen.</para>
      </note>

      <para>Dieser Abschnitt beschreibt, wie Sie die Anweisungen
	eines Tunnel-Providers dauerhaft in
	<filename>/etc/rc.conf</filename> einrichten.</para>

      <para>Der erste Eintrag in <filename>/etc/rc.conf</filename>
	erzeugt die generische Tunnelschnittstelle
	<filename>gif<replaceable>0</replaceable></filename>:</para>

      <programlisting>cloned_interfaces="gif<replaceable>0</replaceable>"</programlisting>

      <para>Als nächstes konfigurieren Sie die
	<acronym>IPv4</acronym>-Adressen der lokalen und entfernten
	Endpunkte.  Ersetzen Sie
	<replaceable>MY_IPv4_ADDR</replaceable> und
	<replaceable>REMOTE_IPv4_ADDR</replaceable> durch die
	tatsächlichen <acronym>IPv4</acronym>-Adressen:</para>

      <programlisting>cloned_interfaces_gif0="<replaceable>MY_IPv4_ADDR REMOTE_IPv4_ADDR</replaceable>"</programlisting>

      <para>Um die zugewiesene <acronym>IPv6</acronym>-Adresse als
	Endpunkt für den <acronym>IPv6</acronym>-Tunnel zu
	verwenden, fügen Sie folgende Zeile für
	&os;&nbsp;9.<replaceable>x</replaceable> (und neuer)
	ein:</para>

      <programlisting>ifconfig_gif0_ipv6="inet6 <replaceable>MY_ASSIGNED_IPv6_TUNNEL_ENDPOINT_ADDR</replaceable>"</programlisting>

      <para>Legen Sie dann die Standardroute für das andere Ende
	des <acronym>IPv6</acronym>-Tunnels fest.  Ersetzen Sie
	<replaceable>MY_IPv6_REMOTE_TUNNEL_ENDPOINT_ADDR</replaceable>
	mit der Adresse des Standard-Gateways des Providers:</para>

      <programlisting>ipv6_defaultrouter="<replaceable>MY_IPv6_REMOTE_TUNNEL_ENDPOINT_ADDR</replaceable>"</programlisting>

      <para>Wenn das &os;-System <acronym>IPv6</acronym>-Verkehr
	zwischen dem Netzwerk und der Außenwelt routen muss,
	aktivieren Sie das Gateway mit dieser Zeile:</para>

      <programlisting>ipv6_gateway_enable="YES"</programlisting>
    </sect2>

    <sect2>
      <title>Bekanntmachung von Routen und automatische
	Rechnerkonfiguration</title>

      <para>Dieser Abschnitt beschreibt die Einrichtung von
	&man.rtadvd.8;, das Sie bei der Bekanntmachung der
	<acronym>IPv6</acronym>-Standardroute unterstützt.</para>

      <para>Um &man.rtadvd.8; zu aktivieren, fügen Sie folgende
	Zeile in <filename>/etc/rc.conf</filename> ein:</para>

      <programlisting>rtadvd_enable="YES"</programlisting>

      <para>Es ist wichtig, die Schnittstelle anzugeben, über die
	<acronym>IPv6</acronym>-Routen bekanntgemacht werden sollen.
	Soll &man.rtadvd.8; <filename>rl0</filename> verwenden, ist
	folgender Eintrag nötig:</para>

      <programlisting>rtadvd_interfaces="rl0"</programlisting>

      <para>Danach erzeugen Sie die Konfigurationsdatei
	<filename>/etc/rtadvd.conf</filename>.  Dazu ein
	Beispiel:</para>

      <programlisting>rl0:\
    :addrs#1:addr="2001:db8:1f11:246::":prefixlen#64:tc=ether:</programlisting>

      <para>Ersetzen Sie dabei <filename>fxp0</filename> durch die zu
	verwendende Schnittstelle, und
	<systemitem>2001:db8:1f11:246::</systemitem> durch das
	entsprechend zugewiesene Präfix.</para>

      <para>Bei einem <systemitem
	  class="netmask">/64</systemitem>-Subnetz müssen keine
	weiteren Anpassungen vorgenommen werden.  Anderenfalls muss
	<literal>prefixlen#</literal> auf den korrekten Wert
	gesetzt werden.</para>
    </sect2>

    <sect2>
      <title><acronym>IPv6</acronym> und Abbildung von
	<acronym>IPv6</acronym>-Adressen</title>

      <para>Wenn <acronym>IPv6</acronym> auf einem Server aktiviert
	ist, kann es für die Kommunikation erforderlich sein,
	<acronym>IPv4</acronym>-Adressen auf
	<acronym>IPv6</acronym>-Adressen abzubilden.  Diese
	Kompatibilität erlaubt es, das
	<acronym>IPv4</acronym>-Adressen als
	<acronym>IPv6</acronym>-Adressen dargestellt werden.  Die
	Kommunikation von <acronym>IPv6</acronym>-Anwendungen mit
	<acronym>IPv4</acronym> und umgekehrt kann jedoch ein
	Sicherheitsrisiko darstellen.</para>

      <para>Diese Option dient nur der Kompatibilität und wird in
	den meisten Fällen nicht erforderlich sein.  Die Option
	ermöglicht es <acronym>IPv6</acronym>-Anwendungen zusammen
	mit <acronym>IPv4</acronym> in einer Dual-Stack-Umgebung
	zu funktionieren.  Dies ist besonders nützlich für
	Anwendungen von Drittanbietern, die evtl. keine
	<acronym>IPv6</acronym>-Umgebungen unterstützen.  Um diese
	Funktion zu aktivieren, fügen Sie folgendes in
	<filename>/etc/rc.conf</filename> hinzu:</para>

      <programlisting>ipv6_ip4mapping="YES"</programlisting>

      <para>Für einige Administratoren können die Informationen im
	<acronym>RFC</acronym> 3493 (Sektion 3.6 und 3.7) und
	<acronym>RFC</acronym> 4038 (Sektion 4.2) hilfreich
	sein.</para>
    </sect2>
  </sect1>
<!--
  <sect1 xml:id="network-atm">
    <info><title>ATM - Asynchronous Transfer Mode</title>
      <authorgroup>
        <author><personname><firstname>Harti</firstname><surname>Brandt</surname></personname><contrib>Beigetragen von </contrib></author>
      </authorgroup>
    </info>



    <sect2>
      <title><foreignphrase>Classical IP over ATM</foreignphrase>
        als PVC-Verbindung einrichten</title>

      <para><foreignphrase>Classical IP over ATM</foreignphrase>
        (<acronym>CLIP</acronym>) ist die einfachste Möglichkeit,
        um IP-Verkehr über ATM (<foreignphrase>Asynchronous
        Transfer Mode</foreignphrase>-Verbindungen zu übertragen.
        CLIP kann sowohl mit geschalteten Verbindungen (SVCs) als auch
        mit permanenten Verbindungen (PVCs) verwendet werden.  Dieser
        Abschnitt beschreibt die Einrichtung eines PVC-basierten
        Netzwerks.</para>

      <sect3>
        <title>Ein vollständig vermaschtes Netzwerk aufbauen</title>

        <para>Bei einem vollständig vermaschten
          (<foreignphrase>fully meshed</foreignphrase>) Netzwerk ist
          jeder Rechner über eine dezidierte Verbindung mit jedem
          anderen Rechner des Netzwerks verbunden.  Die Konfiguration
          ist - vor allem für kleinere Netzwerke - relativ einfach.
          Unser Beispielnetzwerk besteht aus vier Rechnern, die jeweils
          über eine
          <acronym role="Asynchronous Transfer Mode">ATM</acronym>-Adapterkarte
          mit dem
          <acronym role="Asynchronous Transfer Mode">ATM</acronym>-Netzwerk
          verbunden sind.  Als ersten Konfigurationsschritt planen wir
          die Vergabe von IP-Adressen sowie die anzulegenden
          <acronym role="Asynchronous Transfer Mode">ATM</acronym>-Verbindungen:
        </para>

	<informaltable frame="none" pgwide="1">
	  <tgroup cols="2">
	    <colspec colwidth="1*"/>
	    <colspec colwidth="1*"/>
	    <thead>
	      <row>
		<entry>Rechner</entry>
		<entry>IP-Adresse</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><systemitem>hostA</systemitem></entry>
		<entry><systemitem class="ipaddress">192.168.173.1</systemitem></entry>
	      </row>

	      <row>
		<entry><systemitem>hostB</systemitem></entry>
		<entry><systemitem class="ipaddress">192.168.173.2</systemitem></entry>
	      </row>

	      <row>
		<entry><systemitem>hostC</systemitem></entry>
		<entry><systemitem class="ipaddress">192.168.173.3</systemitem></entry>
	      </row>

	      <row>
		<entry><systemitem>hostD</systemitem></entry>
		<entry><systemitem class="ipaddress">192.168.173.4</systemitem></entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

        <para>Um ein vollständiges Netz aufzubauen, benötigen
          wir für jedes Rechnerpaar eine eigene ATM-Verbindung:</para>

	<informaltable frame="none" pgwide="1">
	  <tgroup cols="2">
	    <colspec colwidth="1*"/>
	    <colspec colwidth="1*"/>
	    <thead>
	      <row>
		<entry>Rechnerpaar</entry>
		<entry>VPI.VCI-Paar</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><systemitem>hostA</systemitem> - <systemitem>hostB</systemitem></entry>
		<entry>0.100</entry>
	      </row>

	      <row>
		<entry><systemitem>hostA</systemitem> - <systemitem>hostC</systemitem></entry>
		<entry>0.101</entry>
	      </row>

	      <row>
		<entry><systemitem>hostA</systemitem> - <systemitem>hostD</systemitem></entry>
		<entry>0.102</entry>
	      </row>

	      <row>
		<entry><systemitem>hostB</systemitem> - <systemitem>hostC</systemitem></entry>
		<entry>0.103</entry>
	      </row>

	      <row>
		<entry><systemitem>hostB</systemitem> - <systemitem>hostD</systemitem></entry>
		<entry>0.104</entry>
	      </row>

	      <row>
		<entry><systemitem>hostC</systemitem> - <systemitem>hostD</systemitem></entry>
		<entry>0.105</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

        <para>Die Werte VPI und VCI an den Verbindungsenden können
          natürlich unterschiedlich sein.  Wir nehmen hier aber an,
          dass sie gleich sind.  Nun müssen wir die
          ATM-Schnittstellen auf jedem Rechner einrichten:</para>

        <screen>hostA&prompt.root; <userinput>ifconfig hatm0 192.168.173.1 up</userinput>
hostB&prompt.root; <userinput>ifconfig hatm0 192.168.173.2 up</userinput>
hostC&prompt.root; <userinput>ifconfig hatm0 192.168.173.3 up</userinput>
hostD&prompt.root; <userinput>ifconfig hatm0 192.168.173.4 up</userinput></screen>

        <para>Dabei setzen wir voraus, dass
          <filename>hatm0</filename> auf allen Rechnern die
          ATM-Schnittstelle darstellt.  Danach werden, beginnend mit
          <systemitem>hostA</systemitem>, die PVCs auf den einzelnen Rechnern
          eingerichtet (Wir nehmen an, dass die PVCs auf den
          ATM-Switches bereits eingerichet sind.  Lesen Sie die
          entsprechenden Handbücher, wenn Sie einen Switch
          einrichten müssen.):</para>

        <screen>hostA&prompt.root; <userinput>atmconfig natm add 192.168.173.2 hatm0 0 100 llc/snap ubr</userinput>
hostA&prompt.root; <userinput>atmconfig natm add 192.168.173.3 hatm0 0 101 llc/snap ubr</userinput>
hostA&prompt.root; <userinput>atmconfig natm add 192.168.173.4 hatm0 0 102 llc/snap ubr</userinput>

hostB&prompt.root; <userinput>atmconfig natm add 192.168.173.1 hatm0 0 100 llc/snap ubr</userinput>
hostB&prompt.root; <userinput>atmconfig natm add 192.168.173.3 hatm0 0 103 llc/snap ubr</userinput>
hostB&prompt.root; <userinput>atmconfig natm add 192.168.173.4 hatm0 0 104 llc/snap ubr</userinput>

hostC&prompt.root; <userinput>atmconfig natm add 192.168.173.1 hatm0 0 101 llc/snap ubr</userinput>
hostC&prompt.root; <userinput>atmconfig natm add 192.168.173.2 hatm0 0 103 llc/snap ubr</userinput>
hostC&prompt.root; <userinput>atmconfig natm add 192.168.173.4 hatm0 0 105 llc/snap ubr</userinput>

hostD&prompt.root; <userinput>atmconfig natm add 192.168.173.1 hatm0 0 102 llc/snap ubr</userinput>
hostD&prompt.root; <userinput>atmconfig natm add 192.168.173.2 hatm0 0 104 llc/snap ubr</userinput>
hostD&prompt.root; <userinput>atmconfig natm add 192.168.173.3 hatm0 0 105 llc/snap ubr</userinput></screen>

        <para>Statt UBR können auch andere
          <foreignphrase>traffic contracts</foreignphrase> verwendet
          werden.  Voraussetzung ist allerdings, dass diese von Ihrem
          ATM-Adapter unterstützt werden.  Ist dies der Fall,
          folgen auf den Namen des
          <foreignphrase>traffic contracts</foreignphrase> die
          entsprechenden Konfigurationsparameter.  Weitere Informationen
          zur Konfiguration von ATM-Adapterkarten erhalten Sie über
          den Befehl</para>

        <screen>&prompt.root; <userinput>atmconfig help natm add</userinput></screen>

        <para>oder durch das Lesen von &man.atmconfig.8;.</para>

        <para>Die Konfiguration von ATM-Adaptern kann auch über die
          Datei <filename>/etc/rc.conf</filename> erfolgen.  Für
          <systemitem>hostA</systemitem> sähe die Konfiguration so
          aus:</para>

        <programlisting>network_interfaces="lo0 hatm0"
ifconfig_hatm0="inet 192.168.173.1 up"
natm_static_routes="hostB hostC hostD"
route_hostB="192.168.173.2 hatm0 0 100 llc/snap ubr"
route_hostC="192.168.173.3 hatm0 0 101 llc/snap ubr"
route_hostD="192.168.173.4 hatm0 0 102 llc/snap ubr"</programlisting>

        <para>Mit dem folgenden Befehl lässt sich der derzeitige
          Status aller <acronym>CLIP</acronym>-Routen anzeigen:</para>

        <screen>hostA&prompt.root; <userinput>atmconfig natm show</userinput></screen>
      </sect3>
    </sect2>
  </sect1>
-->
  <sect1 xml:id="carp">
    <info>
      <title>Common Address Redundancy Protocol
	(<acronym>CARP</acronym>)</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	  </personname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <personname>
	    <firstname>Allan</firstname>
	    <surname>Jude</surname>
	  </personname>
	  <contrib>Aktualisiert von </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary><acronym>CARP</acronym></primary>
    </indexterm>
    <indexterm>
      <primary>Common Address Redundancy Protocol</primary>
    </indexterm>

    <para>Das <foreignphrase>Common Address Redundancy Protocol</foreignphrase>
      (<acronym>CARP</acronym>) erlaubt es, mehreren Rechnern die
      gleiche <acronym>IP</acronym>-Adresse und
      <foreignphrase>Virtual Host ID</foreignphrase>
      (<acronym>VHID</acronym>) zuzuweisen und
      <emphasis>Hochverfügbarkeit</emphasis> bereitzustellen.  Das
      bedeutet, dass ein oder mehrere Rechner ausfallen können und die
      anderen Rechner transparent einspringen, ohne dass die Benutzer
      etwas von einem Ausfall mitbekommen.</para>

    <para>Neben der gemeinsamen <acronym>IP</acronym>-Adresse, haben
      die jeweiligen Rechner auch eine eindeutige
      <acronym>IP</acronym>-Adresse zur Verwaltung und Konfiguration.
      Alle Maschinen, die sich eine <acronym>IP</acronym>-Adresse
      teilen, verwenden die gleiche <acronym>VHID</acronym>.  Die
      <acronym>VHID</acronym> für jede einzelne
      <acronym>IP</acronym>-Adresse muss, entsprechend der
      Broadcast-Domäne der Netzwerkschnittstelle, eindeutig
      sein.</para>

    <para>Hochverfügbarkeit mit <acronym>CARP</acronym> ist in &os;
      enthalten, jedoch unterscheidet sich die Konfiguration von der
      eingesetzten &os;-Version.  Dieser Abschnitt enthält die
      gleichen Konfigurationsdateien für verschiedene Versionen von
      &os;.</para>

    <para>Dieses Beispiel konfiguriert eine Failover-Unterstützung mit
      drei Servern (mit jeweils eigener, eindeutiger
      <acronym>IP</acronym>-Adresse), die alle den gleichen
      Web-Inhalt anbieten.  Es werden zwei verschiedene Master namens
      <systemitem>hosta.example.org</systemitem> und
      <systemitem>hostb.example.org</systemitem> benutzt, mit einem
      gemeinsamen Backup namens
      <systemitem>hostc.example.org</systemitem>.</para>

    <para>Die Lastverteilung dieser Maschinen wird dabei über
      <foreignphrase>Round Robin</foreignphrase>
      <acronym>DNS</acronym> konfiguriert.  Mit Ausnahme des
      Hostnamens und der <acronym>IP</acronym>-Management-Adresse sind
      Master- und Backup-Maschinen identisch konfiguriert.  Die Server
      müssen die gleiche Konfiguration und die gleichen Dienste
      aktiviert haben.  Tritt ein Failover auf, können Anfragen an den
      Dienst mit der gemeinsam genutzten <acronym>IP</acronym>-Adresse
      nur dann richtig beantwortet werden, wenn der Backup-Server
      Zugriff auf denselben Inhalt hat.  Die Backup-Maschine verfügt
      über zwei zusätzliche <acronym>CARP</acronym>-Schnittstellen,
      eine für jede <acronym>IP</acronym>-Adresse des
      Master-Content-Servers.  Sobald ein Fehler auftritt, übernimmt
      der Backup-Server die <acronym>IP</acronym>-Adresse des
      ausgefallenen Master-Servers.</para>

    <sect2 xml:id="carp-10x">
      <title><acronym>CARP</acronym> mit &os;&nbsp;10 (und neuer)
	benutzen</title>

      <para>Unterstützung für <acronym>CARP</acronym> erhalten Sie
	durch das Laden des Kernelmoduls <filename>carp.ko</filename>
	in <filename>/boot/loader.conf</filename>:</para>

      <programlisting>carp_load="YES"</programlisting>

      <para>So laden Sie das Modul ohne Neustart:</para>

      <screen>&prompt.root; <userinput>kldload carp</userinput></screen>

      <para>Benutzer, die einen angepassten Kernel verwenden
	möchten, müssen die folgende Zeile in die Konfigurationsdatei
	aufnehmen.  Anschließend muss der Kernel, wie in
	<xref linkend="kernelconfig"/> beschrieben, neu gebaut
	werden:</para>

      <programlisting>device  carp</programlisting>

      <para>Hostname, <acronym>IP</acronym>-Management-Adresse,
	Subnetzmaske, gemeinsame <acronym>IP</acronym>-Adresse und
	<acronym>VHID</acronym> werden durch Einträge in
	<filename>/etc/rc.conf</filename> gesetzt.  Dieses Beispiel
	ist für <systemitem>hosta.example.org</systemitem>:</para>

      <programlisting>hostname="<replaceable>hosta.example.org</replaceable>"
ifconfig_<replaceable>em0</replaceable>="inet <replaceable>192.168.1.3</replaceable> netmask <replaceable>255.255.255.0</replaceable>"
ifconfig_<replaceable>em0</replaceable>_alias0="inet vhid <replaceable>1</replaceable> pass <replaceable>testpass</replaceable> alias <replaceable>192.168.1.50</replaceable>/32"</programlisting>


      <para>Die nächsten Einträge sind für
	<systemitem>hostb.example.org</systemitem>.  Da der Rechner
	einen zweiten Master darstellt, verwendet er eine andere
	gemeinsame <acronym>IP</acronym>-Adresse und
	<acronym>VHID</acronym>.  Die mittels <option>pass</option>
	angegebenen Passwörter müssen jedoch identisch sein, da
	<acronym>CARP</acronym> nur mit Systemen kommuniziert,
	die über das richtige Passwort verfügen.</para>

      <programlisting>hostname="<replaceable>hostb.example.org</replaceable>"
ifconfig_<replaceable>em0</replaceable>="inet <replaceable>192.168.1.4</replaceable> netmask <replaceable>255.255.255.0</replaceable>"
ifconfig_<replaceable>em0</replaceable>_alias0="inet vhid <replaceable>2</replaceable> pass <replaceable>testpass</replaceable> alias <replaceable>192.168.1.51</replaceable>/32"</programlisting>

      <para>Die dritte Maschine,
	<systemitem>hostc.example.org</systemitem> ist so
	konfiguriert, das sie aktiviert wird, wenn einer der beiden
	Masterserver ausfällt.  Diese Maschine ist mit
	zwei <acronym>CARP</acronym> <acronym>VHID</acronym>s
	konfiguriert, eine für jede virtuelle
	<acronym>IP</acronym>-Adresse der beiden Master-Server.  Die
	<acronym>CARP</acronym> advertising skew,
	<option>advskew</option> wird gesetzt, um sicherzustellen,
	dass sich der Backup-Server später ankündigt wie der
	Master-Server, da <option>advskew</option> die Rangfolge
	steuert für den Fall, dass mehrere Backup-Server zur Verfügung
	stehen.</para>

      <programlisting>hostname="hostc.example.org"
ifconfig_<replaceable>em0</replaceable>="inet <replaceable>192.168.1.5</replaceable> netmask <replaceable>255.255.255.0</replaceable>"
ifconfig_<replaceable>em0</replaceable>_alias0="inet vhid <replaceable>1</replaceable> advskew <replaceable>100</replaceable> pass <replaceable>testpass</replaceable> alias <replaceable>192.168.1.50</replaceable>/32"
ifconfig_<replaceable>em0</replaceable>_alias1="inet vhid <replaceable>2</replaceable> advskew <replaceable>100</replaceable> pass <replaceable>testpass</replaceable> alias <replaceable>192.168.1.51</replaceable>/32"</programlisting>

      <para>Durch die beiden konfigurierten <acronym>CARP</acronym>
	<acronym>VHID</acronym>s ist
	<systemitem>hostc.example.org</systemitem> in der Lage
	festzustellen, wenn einer der Master-Server nicht mehr
	reagiert.  Wenn der Master-Server sich später ankündigt als
	der Backup-Server, übernimmt der Backup-Server die gemeinsame
	<acronym>IP</acronym>-Adresse, bis der Master-Server erneut
	verfügbar ist.</para>

      <note>
	<para>Auch wenn der ursprüngliche Master-Server wieder
	  verfügbar wird, gibt
	  <systemitem>hostc.example.org</systemitem>
	  die virtuelle <acronym>IP</acronym>-Adresse nicht
	  automatisch wieder frei.  Dazu muss
	  <foreignphrase>Preemption</foreignphrase> aktiviert
	  werden.  Preemption ist standardmäßig deaktiviert und
	  wird über die &man.sysctl.8;-Variable
	  <varname>net.inet.carp.preempt</varname> gesteuert.
	  Der Administrator kann den Backup-Server zwingen, die
	  <acronym>IP</acronym>-Adresse an den Master
	  zurückzugeben:</para>

	<screen>&prompt.root; <userinput>ifconfig em0 vhid 1 state backup</userinput></screen>
      </note>

      <para>Sobald die Konfiguration abgeschlossen ist, muss das
	Netzwerk oder die Maschine neu gestartet werden.
	Hochverfügbarkeit ist nun aktiviert.</para>

      <para>Die Funktionalität von <acronym>CARP</acronym> kann, wie
	in der Manualpage &man.carp.4; beschrieben, über verschiedene
	&man.sysctl.8; Parameter kontrolliert werden.  Mit dem Einsatz
	von &man.devd.8; können weitere Aktionen zu
	<acronym>CARP</acronym>-Ereignissen ausgelöst werden.</para>
    </sect2>

    <sect2 xml:id="carp-9x">
      <title><acronym>CARP</acronym> mit &os;&nbsp;9 (und älter)
	benutzen</title>

      <para>Die Konfiguration für diese Versionen von &os; ist ähnlich
	wie im vorhergehenden Abschnitt beschrieben, mit der Ausnahme,
	dass zuerst ein <acronym>CARP</acronym>-Gerät in der
	Konfiguration erstellt und bezeichnet werden muss.</para>

      <para>Unterstützung für <acronym>CARP</acronym> erhalten Sie
	durch das Laden des Kernelmoduls <filename>carp.ko</filename>
	in <filename>/boot/loader.conf</filename>:</para>

      <programlisting>if_carp_load="YES"</programlisting>

      <para>So laden Sie das Modul ohne Neustart:</para>

      <screen>&prompt.root; <userinput>kldload carp</userinput></screen>

      <para>Benutzer, die einen angepassten Kernel verwenden
	möchten, müssen die folgende Zeile in die Konfigurationsdatei
	aufnehmen.  Anschließend muss der Kernel, wie in
	<xref linkend="kernelconfig"/> beschrieben, neu gebaut
	werden:</para>

      <programlisting>device    carp</programlisting>

      <para>Als nächstes erstellen Sie auf jedem Rechner eine
	<acronym>CARP</acronym>-Schnittstelle:</para>

      <screen>&prompt.root; <userinput>ifconfig carp0 create</userinput></screen>

      <para>Konfigurieren Sie Hostnamen,
	<acronym>IP</acronym>-Management-Adresse, die gemeinsam
	genutzte <acronym>IP</acronym>-Adresse und die
	<acronym>VHID</acronym>, indem Sie die erforderlichen Zeilen
	in <filename>/etc/rc.conf</filename> hinzufügen.  Da anstelle
	eines Alias eine virtuelles <acronym>CARP</acronym>-Gerät
	verwendet wird, wird die tatsächliche Subnetzmaske
	<literal>/24</literal> anstatt <literal>/32</literal> benutzt.
	Hier sind die Einträge für
	<systemitem>hosta.example.org</systemitem>:</para>

      <programlisting>hostname="<replaceable>hosta.example.org</replaceable>"
ifconfig_<replaceable>fxp0</replaceable>="inet <replaceable>192.168.1.3</replaceable> netmask <replaceable>255.255.255.0</replaceable>"
cloned_interfaces="carp0"
ifconfig_carp0="vhid <replaceable>1</replaceable> pass <replaceable>testpass</replaceable> <replaceable>192.168.1.50/24</replaceable>"</programlisting>

      <para>Beispiel für
	<systemitem>hostb.example.org</systemitem>:</para>

      <programlisting>hostname="<replaceable>hostb.example.org</replaceable>"
ifconfig_<replaceable>fxp0</replaceable>="inet <replaceable>192.168.1.4</replaceable> netmask <replaceable>255.255.255.0</replaceable>"
cloned_interfaces="carp0"
ifconfig_carp0="vhid <replaceable>2</replaceable> pass <replaceable>testpass</replaceable> <replaceable>192.168.1.51/24</replaceable>"</programlisting>

      <para>Die dritte Maschine,
	<systemitem>hostc.example.org</systemitem> ist so
	konfiguriert, das sie aktiviert wird, wenn einer der beiden
	Masterserver ausfällt:</para>

      <programlisting>hostname="<replaceable>hostc.example.org</replaceable>"
ifconfig_<replaceable>fxp0</replaceable>="inet <replaceable>192.168.1.5</replaceable> netmask <replaceable>255.255.255.0</replaceable>"
cloned_interfaces="carp0 carp1"
ifconfig_carp0="vhid <replaceable>1</replaceable> advskew <replaceable>100</replaceable> pass <replaceable>testpass</replaceable> <replaceable>192.168.1.50/24</replaceable>"
ifconfig_carp1="vhid <replaceable>2</replaceable> advskew <replaceable>100</replaceable> pass <replaceable>testpass</replaceable> <replaceable>192.168.1.51/24</replaceable>"</programlisting>

      <note>
	<para><foreignphrase>Preemption</foreignphrase> ist im
	  <filename>GENERIC</filename>-Kernel deaktiviert.  Haben Sie
	  jedoch <foreignphrase>Preemption</foreignphrase> in einem
	  angepassten Kernel aktiviert, dass
	  <systemitem>hostc.example.org</systemitem> die virtuelle
	  <acronym>IP</acronym>-Adresse nicht wieder an den
	  Master-Server zurückgibt.  Der Administrator kann jedoch den
	  Backup-Server dazu zwingen, die übernommene
	  <acronym>IP</acronym>-Adresse wieder an den Master-Server
	  zurückzugeben:</para>

	<screen>&prompt.root; <userinput>ifconfig carp0 down &amp;&amp; ifconfig carp0 up</userinput></screen>

	<para>Dieser Befehl muss auf dem
	  <filename>carp</filename>-Gerät ausgeführt werden, dass dem
	  betroffenen System zugeordnet ist.</para>
      </note>

      <para>Sobald die Konfiguration abgeschlossen ist, muss das
	Netzwerk oder die Maschine neu gestartet werden.
	Hochverfügbarkeit ist nun aktiviert.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="network-vlan">
    <info>
      <title>VLANs</title>
    </info>

    <indexterm><primary><acronym>VLAN</acronym>s</primary></indexterm>
    <indexterm><primary>Virtuelle LANs</primary></indexterm>

    <para><acronym>VLAN</acronym>s sind eine Möglichkeit ein Netzwerk
      in viele Subnetze zu unterteilen.  Jedes Subnetz hat seine
      eigene Broadcast-Domäne und ist von den restlichen
      <acronym>VLAN</acronym>s isoliert.</para>

    <para>Unter &os; müssen <acronym>VLAN</acronym>s vom Treiber der
      Netzwerkkarte unterstützt werden.  &man.vlan.4; enthält eine
      Liste von Treibern mit integrierter
      <acronym>VLAN</acronym>-Unterstützung.</para>

    <para>Für die Konfiguration eines <acronym>VLAN</acronym> werden
      zwei Informationen benötigt: die verwendete
      Netzwerkschnittstelle und das
      <acronym>VLAN</acronym>-Tag.</para>

    <para>Das folgende Kommando konfiguriert ein
      <acronym>VLAN</acronym> mit der Netzwerkschnittstelle
      <literal>em0</literal> und dem <acronym>VLAN</acronym>-Tag
      <systemitem>5</systemitem>:</para>

    <screen>&prompt.root; <userinput>ifconfig <replaceable>em0.5</replaceable> create vlan <replaceable>5</replaceable> vlandev <replaceable>em0</replaceable> inet 192.168.20.20/24</userinput></screen>

    <note>
      <para>In diesem Beispiel fällt auf, dass der Name der
	Schnittstelle den Treibernamen und das
	<acronym>VLAN</acronym>-Tag enthält, getrennt durch
	einen Punkt.  Diese Methode hat sich bewährt, da sie die
	Konfiguration von Systemen mit mehreren
	<acronym>VLAN</acronym>s deutlich erleichtert.</para>
    </note>

    <para>Um <acronym>VLAN</acronym>s beim Booten zu konfigurieren,
      muss <filename>/etc/rc.conf</filename> angepasst werden.  Für
      das obige Beispiel müssten folgende Zeilen in die Konfiguration
      aufgenommen werden:</para>

    <programlisting>vlans_<replaceable>em0</replaceable>="<replaceable>5</replaceable>"
ifconfig_<replaceable>em0</replaceable>_<replaceable>5</replaceable>="inet 192.168.20.20/24"</programlisting>

    <para>Das gleiche Schema kann benutzt werden, um weitere
      <acronym>VLAN</acronym>s hinzuzufügen.</para>
  </sect1>
</chapter>
