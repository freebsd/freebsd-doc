<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde: de-docproj/books/handbook/advanced-networking/chapter.sgml,v 1.195 2011/02/23 12:30:43 jkois Exp $
     basiert auf: 1.436
-->

<chapter id="advanced-networking">
  <chapterinfo>
    <authorgroup>
      <author>
	  <firstname>Johann</firstname>
	  <surname>Kois</surname>
	  <contrib>&Uuml;bersetzt von </contrib>
      </author>
    </authorgroup>
  </chapterinfo>

  <title>Weiterf&uuml;hrende Netzwerkthemen</title>

  <sect1 id="advanced-networking-synopsis">

    <title>&Uuml;bersicht</title>

    <para>Dieses Kapitel beschreibt verschiedene
      weiterf&uuml;hrende Netzwerkthemen.</para>

    <para>Nachdem Sie dieses Kapitel gelesen haben, werden Sie</para>

    <itemizedlist>
      <listitem>
	<para>Die Grundlagen von Gateways und Routen kennen.</para>
      </listitem>

      <listitem>
	<para>&bluetooth;- sowie drahtlose, der Norm &ieee;&nbsp;802.11
	  entsprechende, Ger&auml;te mit FreeBSD verwenden
	  k&ouml;nnen.</para>
      </listitem>

      <listitem>
	<para>Eine Bridge unter FreeBSD einrichten k&ouml;nnen.</para>
      </listitem>

      <listitem>
	<para>Einen plattenlosen Rechner &uuml;ber das Netzwerk starten
	  k&ouml;nnen.</para>
      </listitem>

      <listitem>
	<para>Wissen, wie man NAT (Network Address Translation)
	  einrichtet.</para>
      </listitem>

      <listitem>
	<para>Zwei Computer &uuml;ber PLIP verbinden k&ouml;nnen.</para>
      </listitem>

      <listitem>
	<para>IPv6 auf einem FreeBSD-Rechner einrichten
	  k&ouml;nnen.</para>
      </listitem>

      <listitem>
	<para>ATM einrichten k&ouml;nnen.</para>
      </listitem>

      <listitem>
	<para>CARP, das Common Address Redundancy Protocol, unter
	  &os; einsetzen k&ouml;nnen.</para>
      </listitem>
    </itemizedlist>

    <para>Bevor Sie dieses Kapitel lesen, sollten Sie</para>

    <itemizedlist>
      <listitem>
	<para>Die Grundlagen der <filename>/etc/rc</filename>-Skripte
	  verstanden haben.</para>
      </listitem>

      <listitem>
	<para>Mit der grundlegenden Netzwerkterminologie vertraut
	  sein.</para>
      </listitem>

      <listitem>
	<para>Einen neuen FreeBSD-Kernel konfigurieren und installieren
	  k&ouml;nnen (<xref linkend="kernelconfig">).</para>
      </listitem>

      <listitem>
	<para>Wissen, wie man zus&auml;tzliche Softwarepakete von
	  Drittherstellern installiert (<xref linkend="ports">).</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="network-routing">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Coranth</firstname>
	  <surname>Gryphon</surname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title>Gateways und Routen</title>

    <indexterm>
      <primary>Routing</primary>
    </indexterm>
    <indexterm>
      <primary>Gateway</primary>
    </indexterm>
    <indexterm>
      <primary>Subnetz</primary>
    </indexterm>

    <para>Damit ein Rechner einen anderen &uuml;ber ein Netzwerk
      finden kann, muss ein Mechanismus vorhanden sein, der
      beschreibt, wie man von einem Rechner zum anderen gelangt.
      Dieser Vorgang wird als <firstterm>Routing</firstterm>
      bezeichnet.  Eine <quote>Route</quote> besteht aus einem
      definierten Adressenpaar: Einem <quote>Ziel</quote> und einem
      <quote>Gateway</quote>.  Dieses Paar zeigt an, dass Sie
      &uuml;ber das <emphasis>Gateway</emphasis> zum
      <emphasis>Ziel</emphasis> gelangen wollen.  Es gibt drei Arten
      von Zielen: Einzelne Rechner (Hosts), Subnetze und das
      <quote>Standard</quote>ziel.  Die <quote>Standardroute</quote>
      wird verwendet, wenn keine andere Route zutrifft.  Wir werden
      Standardrouten sp&auml;ter etwas genauer behandeln.
      Au&szlig;erdem gibt es drei Arten von Gateways: Einzelne Rechner
      (Hosts), Schnittstellen (Interfaces, auch als <quote>Links</quote>
      bezeichnet), sowie Ethernet Hardware-Adressen (MAC-Adressen).
    </para>

    <sect2>
      <title>Ein Beispiel</title>

      <para>Um die verschiedenen Aspekte des Routings zu
	veranschaulichen, verwenden wir folgende Ausgaben von
	<command>netstat</command>:</para>

      <screen>&prompt.user; <userinput>netstat -r</userinput>
Routing tables

Destination               Gateway            Flags       Refs     Use     Netif Expire

default                   outside-gw         UGSc        37       418     ppp0
localhost                 localhost          UH          0        181     lo0
test0                     0:e0:b5:36:cf:4f   UHLW        5        63288   ed0    77
10.20.30.255              link#1             UHLW        1        2421
example.com               link#1             UC          0        0
host1                     0:e0:a8:37:8:1e    UHLW        3        4601    lo0
host2                     0:e0:a8:37:8:1e    UHLW        0        5       lo0 =>
host2.example.com         link#1             UC          0        0
224                       link#1             UC          0        0
</screen>

      <indexterm>
	<primary>Defaultroute</primary>
      </indexterm>

      <para>Die ersten zwei Zeilen geben die Standardroute (die wir
	im <link linkend="network-routing-default"> n&auml;chsten
	Abschnitt</link> behandeln), sowie die
	<hostid>localhost</hostid> Route an.</para>

      <indexterm>
	<primary>Loopback-Ger&auml;t</primary>
      </indexterm>

      <para>Das in der Routingtabelle f&uuml;r
	<literal>localhost</literal> festgelegte Interface
	(<literal>Netif</literal>-Spalte)
	<devicename>lo0</devicename>, ist auch als loopback-Ger&auml;t
	(Pr&uuml;fschleife) bekannt.  Das hei&szlig;t, dass der ganze
	Datenverkehr f&uuml;r dieses Ziel intern (innerhalb des
	Ger&auml;tes) bleibt, anstatt ihn &uuml;ber ein Netzwerk (LAN)
	zu versenden, da das Ziel dem Start entspricht.</para>

      <indexterm>
	<primary>Ethernet</primary>
	<secondary>MAC-Adresse</secondary>
      </indexterm>

      <para>Der n&auml;chste auff&auml;llige Punkt sind die mit
	<hostid role="mac">0:e0:</hostid> beginnenden Adressen.  Es
	handelt sich dabei um Ethernet Hardwareadressen, die auch als
	MAC-Adressen bekannt sind.  FreeBSD identifiziert Rechner im
	lokalen Netz automatisch (im Beispiel <hostid>test0</hostid>)
	und f&uuml;gt eine direkte Route zu diesem Rechner hinzu.  Dies
	passiert &uuml;ber die Ethernet-Schnittstelle
	<devicename>ed0</devicename>.  Au&szlig;erdem existiert ein Timeout
	(in der Spalte <literal>Expire</literal>) f&uuml;r diese Art
	von Routen, der verwendet wird, wenn dieser Rechner in einem
	definierten Zeitraum nicht reagiert.  Wenn dies passiert, wird
	die Route zu diesem Rechner automatisch gel&ouml;scht.
	Rechner im lokalen Netz werden durch einen als RIP (Routing
	Information Protocol) bezeichneten Mechanismus identifiziert,
	der den k&uuml;rzesten Weg zu den jeweiligen Rechnern
	bestimmt.</para>

      <indexterm>
	<primary>Subnetz</primary>
      </indexterm>

      <para>FreeBSD f&uuml;gt au&szlig;erdem Subnetzrouten f&uuml;r das
	lokale Subnetz hinzu (<hostid
	role="ipaddr">10.20.30.255</hostid> ist die Broadcast-Adresse
	f&uuml;r das Subnetz <hostid role="ipaddr">10.20.30</hostid>,
	<hostid role="domainname">example.com</hostid> ist der zu
	diesem Subnetz geh&ouml;rige Domainname).  Das Ziel
	<literal>link#1</literal> bezieht sich auf die erste
	Ethernet-Karte im Rechner.  Sie k&ouml;nnen auch feststellen,
	dass keine zus&auml;tzlichen Schnittstellen angegeben
	sind.</para>

      <para>Routen f&uuml;r Rechner im lokalen Netz und lokale
	Subnetze werden automatisch durch den
	<application>routed</application> Daemon konfiguriert.  Ist
	dieser nicht gestartet, sind nur statisch definierte
	(explizit eingegebene) Routen vorhanden.</para>

      <para>Die Zeile <literal>host1</literal> bezieht sich auf
	unseren Rechner, der durch seine Ethernetadresse bekannt ist.
	Da unser Rechner der Sender ist, verwendet FreeBSD automatisch
	das Loopback-Ger&auml;t (<devicename>lo0</devicename>),
	anstatt den Datenverkehr &uuml;ber die Ethernetschnittstelle
	zu senden.</para>

      <para>Die zwei <literal>host2</literal> Zeilen sind ein Beispiel
	daf&uuml;r, was passiert, wenn wir ein &man.ifconfig.8; Alias
	verwenden (Lesen Sie dazu den Abschnitt &uuml;ber Ethernet,
	wenn Sie wissen wollen, warum wir das tun sollten.).  Das
	Symbol <literal>=&gt;</literal> (nach der
	<devicename>lo0</devicename>-Schnittstelle) sagt aus, dass wir
	nicht nur das Loopbackger&auml;t verwenden (da sich die
	Adresse auf den lokalen Rechner bezieht), sondern dass es sich
	zus&auml;tzlich auch um ein Alias handelt.  Solche Routen sind
	nur auf Rechnern vorhanden, die den Alias bereitstellen;
	alle anderen Rechner im lokalen Netz haben f&uuml;r solche
	Routen nur eine einfache <literal>link#1</literal>
	Zeile.</para>

      <para>Die letzte Zeile (Zielsubnetz <literal>224</literal>)
	behandelt das Multicasting, das wir in einem anderen Abschnitt
	besprechen werden.</para>

      <para>Schlie&szlig;lich gibt es f&uuml;r Routen noch
	verschiedene Attribute, die Sie in der Spalte
	<literal>Flags</literal> finden.  Nachfolgend finden Sie eine
	kurze &Uuml;bersicht von einigen dieser Flags und ihrer
	Bedeutung:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
          <colspec colwidth="1*">
          <colspec colwidth="4*">

	  <tbody>
	    <row>
	      <entry>U</entry>

	      <entry>Up: Die Route ist aktiv.</entry>
	    </row>

	    <row>
	      <entry>H</entry>

	      <entry>Host: Das Ziel der Route ist ein einzelner
		Rechner (Host).</entry>
	    </row>

	    <row>
	      <entry>G</entry>

	      <entry>Gateway: Alle Daten, die an dieses Ziel gesendet
		werden, werden von diesem System an ihr jeweiliges
		Ziel weitergeleitet.</entry>
	    </row>

	    <row>
	      <entry>S</entry>

	      <entry>Static: Diese Route wurde manuell konfiguriert,
		das hei&szlig;t sie wurde <emphasis>nicht</emphasis>
		automatisch vom System erzeugt.</entry>
	    </row>

	    <row>
	      <entry>C</entry>

	      <entry>Clone: Erzeugt eine neue Route, basierend auf der
		Route f&uuml;r den Rechner, mit dem wir uns verbinden.
		Diese Routenart wird normalerweise f&uuml;r lokale
		Netzwerke verwendet.</entry>
	    </row>

	    <row>
	      <entry>W</entry>

	      <entry>WasCloned: Eine Route, die automatisch
		konfiguriert wurde.  Sie basiert auf einer lokalen
		Netzwerkroute (Clone).</entry>
	    </row>

	    <row>
	      <entry>L</entry>

	      <entry>Link: Die Route beinhaltet einen Verweis auf eine
		Ethernetkarte (MAC-Adresse).</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </sect2>

    <sect2 id="network-routing-default">
      <title>Standardrouten</title>

      <indexterm>
	<primary>Defaultroute</primary>
      </indexterm>

      <indexterm>
	<primary>Standardroute</primary>
	<see>Defaultroute</see>
      </indexterm>

      <para>Wenn sich der lokale Rechner mit einem entfernten Rechner
	verbinden will, wird die Routingtabelle &uuml;berpr&uuml;ft,
	um festzustellen, ob bereits ein bekannter Pfad vorhanden ist.
	Geh&ouml;rt dieser entfernte Rechner zu einem Subnetz, dessen
	Pfad uns bereits bekannt ist
	(<foreignphrase>Cloned route</foreignphrase>), dann versucht der
	lokale Rechner &uuml;ber diese Schnittstelle eine Verbindung
	herzustellen.</para>

      <para>Wenn alle bekannten Pfade nicht funktionieren, hat der
	lokale Rechner eine letzte M&ouml;glichkeit: Die
	Standardroute (Defaultroute).  Bei dieser
	Route handelt es sich um eine spezielle Gateway-Route
	(gew&ouml;hnlich die einzige im System vorhandene), die im
	Flags-Feld immer mit <literal>C</literal> gekennzeichnet ist.
	F&uuml;r Rechner im lokalen Netzwerk ist dieses Gateway auf
	<emphasis>welcher Rechner auch immer eine Verbindung nach
	au&szlig;en hat</emphasis> gesetzt (entweder &uuml;ber eine
	PPP-Verbindung, DSL, ein Kabelmodem, T1 oder eine beliebige
	andere Netzwerkverbindung).</para>

      <para>Wenn Sie die Standardroute f&uuml;r einen Rechner
	konfigurieren, der selbst als Gateway zur Au&szlig;enwelt
	funktioniert, wird die Standardroute zum Gateway-Rechner Ihres
	Internetanbieter (ISP) gesetzt.</para>

      <para>Sehen wir uns ein Beispiel f&uuml;r Standardrouten an.  So
	sieht eine &uuml;bliche Konfiguration aus:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="advanced-networking/net-routing">
	</imageobject>

	<textobject>
	  <literallayout class="monospaced">
[Local2]  &lt;--ether--&gt;  [Local1]  &lt;--PPP--&gt; [ISP-Serv]  &lt;--ether--&gt;  [T1-GW]
	  </literallayout>
	</textobject>
      </mediaobject>

      <para>Die Rechner <hostid>Local1</hostid> und
	<hostid>Local2</hostid> befinden sich auf Ihrer Seite.
	<hostid>Local1</hostid> ist mit einem ISP &uuml;ber eine
	PPP-Verbindung verbunden.  Dieser PPP-Server ist &uuml;ber ein
	lokales Netzwerk mit einem anderen Gateway-Rechner verbunden,
	der &uuml;ber eine Schnittstelle die Verbindung des ISP zum
	Internet herstellt.</para>

      <para>Die Standardrouten f&uuml;r Ihre Maschinen lauten:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>Host</entry>

	      <entry>Standard Gateway</entry>

	      <entry>Schnittstelle</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>Local2</entry>

	      <entry>Local1</entry>

	      <entry>Ethernet</entry>
	    </row>

	    <row>
	      <entry>Local1</entry>

	      <entry>T1-GW</entry>

	      <entry>PPP</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>Eine h&auml;ufig gestellte Frage lautet: <quote>Warum (oder
	wie) sollten wir <hostid>T1-GW</hostid> als Standard-Gateway
	f&uuml;r <hostid>Local1</hostid> setzen, statt den (direkt
	verbundenen) ISP-Server zu verwenden?</quote>.</para>

      <para>Bedenken Sie, dass die PPP-Schnittstelle f&uuml;r die
	Verbindung eine Adresse des lokalen Netzes des ISP verwendet.
	Daher werden Routen f&uuml;r alle anderen Rechner im lokalen
	Netz des ISP automatisch erzeugt.  Daraus folgt, dass Sie
	bereits wissen, wie Sie <hostid>T1-GW</hostid> erreichen
	k&ouml;nnen!  Es ist also unn&ouml;tig, einen Zwischenschritt
	&uuml;ber den ISP-Server zu machen.</para>

      <para>Es ist &uuml;blich, die Adresse <hostid
	role="ipaddr">X.X.X.1</hostid> als Gateway-Adresse f&uuml;r
	ihr lokales Netzwerk zu verwenden.  F&uuml;r unser Beispiel
	bedeutet dies Folgendes: Wenn Ihr lokaler Klasse-C-Adressraum
	<hostid role="ipaddr">10.20.30</hostid> ist und Ihr ISP
	<hostid role="ipaddr">10.9.9</hostid> verwendet, sehen die
	Standardrouten so aus:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Rechner (Host)</entry>

	      <entry>Standardroute</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>Local2 (10.20.30.2)</entry>

	      <entry>Local1 (10.20.30.1)</entry>
	    </row>

	    <row>
	      <entry>Local1 (10.20.30.1, 10.9.9.30)</entry>

	      <entry>T1-GW (10.9.9.1)</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>Sie k&ouml;nnen die Standardroute ganz einfach in der Datei
	<filename>/etc/rc.conf</filename> festlegen.  In unserem
	Beispiel wurde auf dem Rechner <hostid>Local2</hostid>
	folgende Zeile in <filename>/etc/rc.conf</filename>
	eingef&uuml;gt:</para>

      <programlisting>defaultrouter="10.20.30.1"</programlisting>

      <para>Die Standardroute kann &uuml;ber &man.route.8; auch direkt
	gesetzt werden:</para>

      <screen>&prompt.root; <userinput>route add default 10.20.30.1</userinput></screen>

      <para>Weitere Informationen zum Bearbeiten von
	Netzwerkroutingtabellen finden Sie in &man.route.8;.</para>
    </sect2>

    <sect2 id="network-dual-homed-hosts">
      <title>Rechner mit zwei Heimatnetzen</title>
      <indexterm>
	<primary>Dual-Homed-Hosts</primary>
      </indexterm>

      <para>Es gibt noch eine Konfigurationsm&ouml;glichkeit, die wir
	besprechen sollten, und zwar Rechner, die sich in zwei
	Netzwerken befinden.  Technisch gesehen, z&auml;hlt jeder als
	Gateway arbeitende Rechner zu den Rechnern mit zwei
	Heimatnetzen (im obigen Beispiel unter Verwendung einer
	PPP-Verbindung).  In der Praxis meint man damit allerdings nur
	Rechner, die sich in zwei lokalen Netzen befinden.</para>

      <para>Entweder verf&uuml;gt der Rechner &uuml;ber zwei
	Ethernetkarten und jede dieser Karten hat eine Adresse in
	einem separaten Subnetz, oder der Rechner hat nur eine
	Ethernetkarte und verwendet &man.ifconfig.8; Aliasing.  Die
	erste M&ouml;glichkeit wird verwendet, wenn zwei physikalisch
	getrennte Ethernet-Netzwerke vorhanden sind, die zweite, wenn
	es nur ein physikalisches Ethernet-Netzwerk gibt, das aber aus
	zwei logisch getrennten Subnetzen besteht.</para>

      <para>In beiden F&auml;llen werden Routingtabellen erstellt,
	damit jedes Subnetz wei&szlig;, dass dieser Rechner als Gateway
	zum anderen Subnetz arbeitet (<foreignphrase>inbound
	route</foreignphrase>).  Diese Konfiguration (der
	Gateway-Rechner arbeitet als Router zwischen den Subnetzen) wird
	h&auml;ufig verwendet, wenn es darum geht, Paketfilterung oder
	eine Firewall (in eine oder beide Richtungen) zu implementieren.
      </para>

      <para>Soll dieser Rechner Pakete zwischen den beiden
	Schnittstellen weiterleiten, m&uuml;ssen Sie diese Funktion
	manuell konfigurieren und aktivieren.  Lesen Sie den
	n&auml;chsten Abschnitt, wenn Sie weitere Informationen zu
	diesem Thema ben&ouml;tigen.</para>
    </sect2>

    <sect2 id="network-dedicated-router">
      <title>Einen Router konfigurieren</title>

      <indexterm>
	<primary>Router</primary>
      </indexterm>

      <para>Ein Netzwerkrouter ist einfach ein System, das Pakete von
	einer Schnittstelle zur anderen weiterleitet.
	Internetstandards und gute Ingenieurspraxis sorgten
	daf&uuml;r, dass diese Funktion in FreeBSD in der Voreinstellung
	deaktiviert ist.  Sie k&ouml;nnen diese Funktion aktivieren,
	indem Sie in &man.rc.conf.5;  folgende &Auml;nderung
	durchf&uuml;hren:</para>

      <programlisting>gateway_enable="YES"          # Auf YES setzen, wenn der Rechner als Gateway arbeiten soll</programlisting>

      <para>Diese Option setzt die &man.sysctl.8;-Variable
	<varname>net.inet.ip.forwarding</varname> auf
	<literal>1</literal>.  Wenn Sie das Routing kurzzeitig
	unterbrechen wollen, k&ouml;nnen Sie die Variable auf
	<literal>0</literal> setzen.</para>

      <indexterm><primary>BGP</primary></indexterm>
      <indexterm><primary>RIP</primary></indexterm>
      <indexterm><primary>OSPF</primary></indexterm>

      <para>Ihr neuer Router ben&ouml;tigt nun noch Routen, um zu
	wissen, wohin er den Verkehr senden soll.  Haben Sie ein
	(sehr) einfaches Netzwerk, k&ouml;nnen Sie statische Routen
	verwenden.  FreeBSD verf&uuml;gt &uuml;ber den Standard
	BSD-Routing-Daemon &man.routed.8;, der RIP (sowohl Version 1
	als auch Version 2) und IRDP versteht.  BGP&nbsp;v4,
	OSPF&nbsp;v2 und andere Protokolle werden von
	<filename role="package">net/zebra</filename>
	unterst&uuml;tzt.  Es stehen auch kommerzielle Produkte
	wie <application>gated</application> zur Verf&uuml;gung.</para>
    </sect2>

    <sect2 id="network-static-routes">
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Al</firstname>
	    <surname>Hoang</surname>
	    <contrib>Beigetragen von </contrib>
	  </author>
	</authorgroup>
      </sect2info>

      <title>Statische Routen einrichten</title>

      <sect3>
	<title>Manuelle Konfiguration</title>

	<para>Nehmen wir an, dass wir &uuml;ber folgendes Netzwerk
	  verf&uuml;gen:</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="advanced-networking/static-routes">
          </imageobject>

          <textobject>
            <literallayout class="monospaced">
    INTERNET
      | (10.0.0.1/24) Default Router to Internet
      |
      |Interface xl0
      |10.0.0.10/24
   +------+
   |      | RouterA
   |      | (FreeBSD gateway)
   +------+
      | Interface xl1
      | 192.168.1.1/24
      |
  +--------------------------------+
   Internal Net 1      | 192.168.1.2/24
                       |
                   +------+
                   |      | RouterB
                   |      |
                   +------+
                       | 192.168.2.1/24
                       |
                     Internal Net 2
            </literallayout>
          </textobject>
        </mediaobject>

	<para><hostid>RouterA</hostid>, ein &os;-Rechner, dient als
	  Router f&uuml;r den Zugriff auf das Internet.  Die
	  Standardroute ist auf <hostid role="ipaddr">10.0.0.1</hostid>
	  gesetzt, damit ein Zugriff auf das Internet m&ouml;glich wird.
	  Wir nehmen nun an, dass <hostid>RouterB</hostid> bereits
	  konfiguriert ist und daher wei&szlig;, wie er andere Rechner
	  erreichen kann.  Dazu wird die Standardroute von
	  <hostid>RouterB</hostid> auf
	  <hostid role="ipaddr">192.168.1.1</hostid> gesetzt, da dieser
	  Rechner als Gateway fungiert.</para>

	<para>Sieht man sich die Routingtabelle f&uuml;r
	  <hostid>RouterA</hostid> an, erh&auml;lt man folgende Ausgabe:
	</para>

	<screen>&prompt.user; <userinput>netstat -nr</userinput>
Routing tables

Internet:
Destination        Gateway            Flags    Refs      Use  Netif  Expire
default            10.0.0.1           UGS         0    49378    xl0
127.0.0.1          127.0.0.1          UH          0        6    lo0
10.0.0/24          link#1             UC          0        0    xl0
192.168.1/24       link#2             UC          0        0    xl1</screen>

	<para>Mit dieser Routingtabelle kann <hostid>RouterA</hostid>
	  unser internes Netz 2 nicht erreichen, da keine Route zum
	  Rechner <hostid role="ipaddr">192.168.2.0/24</hostid>
	  vorhanden ist.  Um dies zu korrigieren, kann die Route manuell
	  gesetzt werden.  Durch den folgenden Befehl wird das
	  interne Netz 2 in die Routingtabelle des Rechners
	  <hostid>RouterA</hostid> aufgenommen, indem
	  <hostid role="ipaddr">192.168.1.2</hostid> als n&auml;chster
	  Zwischenschritt verwenden wird:</para>

	<screen>&prompt.root; <userinput>route add -net 192.168.2.0/24 192.168.1.2</userinput></screen>

	<para>Ab sofort kann <hostid>RouterA</hostid> alle Rechner des
	  Netzwerks <hostid role="ipaddr">192.168.2.0/24</hostid>
	  erreichen.</para>
      </sect3>

      <sect3>
	<title>Routen dauerhaft einrichten</title>

	<para>Das obige Beispiel ist f&uuml;r die Konfiguration einer
	  statischen Route auf einem laufenden System geeignet.  Diese
	  Information geht jedoch verloren, wenn der &os;-Rechner neu
	  gestartet werden muss.  Um dies zu verhindern, wird diese
	  Route in <filename>/etc/rc.conf</filename> eingetragen:</para>

	<programlisting># Add Internal Net 2 as a static route
static_routes="internalnet2"
route_internalnet2="-net 192.168.2.0/24 192.168.1.2"</programlisting>

	<para>Die Variable <literal>static_routes</literal> enth&auml;lt
	  eine Reihe von Strings, die durch Leerzeichen getrennt sind.
	  Jeder String bezieht sich auf den Namen einer Route.  In
	  unserem Beispiel hat <literal>static_routes</literal>
	  <replaceable>internalnet2</replaceable> als einzigen String.
	  Zus&auml;tzlich verwendet man die Konfigurationsvariable
	  <literal>route_<replaceable>internalnet2</replaceable></literal>,
	  in der alle sonstigen an &man.route.8; zu &uuml;bergebenden
	  Parameter festgelegt werden.  In obigen Beispiel h&auml;tte
	  man folgenden Befehl verwendet:</para>

	<screen>&prompt.root; <userinput>route add -net 192.168.2.0/24 192.168.1.2</userinput></screen>

	<para>Daher wird
	  <literal>"-net 192.168.2.0/24 192.168.1.2"</literal> als
	  Parameter der Variable <literal>route_</literal> angegeben.
	</para>

	<para>Wie bereits erw&auml;hnt, k&ouml;nnen bei
	  <literal>static_routes</literal> auch mehrere Strings
	  angegeben werden.  Dadurch lassen sich mehrere statische
	  Routen anlegen.  Durch folgende Zeilen werden auf einem
	  imagin&auml;ren Rechner statische Routen zu den Netzwerken
	  <hostid role="ipaddr">192.168.0.0/24</hostid> sowie <hostid
	  role="ipaddr">192.168.1.0/24</hostid> definiert:</para>

	<programlisting>static_routes="net1 net2"
route_net1="-net 192.168.0.0/24 192.168.0.1"
route_net2="-net 192.168.1.0/24 192.168.1.1"</programlisting>
      </sect3>
    </sect2>

    <sect2 id="network-routing-propagation">
      <title>Verteilung von Routing-Informationen</title>
      <indexterm>
	<primary>routing propagation</primary>
      </indexterm>

      <para>Wir haben bereits dar&uuml;ber gesprochen, wie wir unsere
	Routen zur Au&szlig;enwelt definieren, aber nicht dar&uuml;ber,
	wie die Au&szlig;enwelt uns finden kann.</para>

      <para>Wir wissen bereits, dass Routing-Tabellen so erstellt
	werden k&ouml;nnen, dass s&auml;mtlicher Verkehr f&uuml;r
	einen bestimmten Adressraum (in unserem Beispiel ein
	Klasse-C-Subnetz) zu einem bestimmten Rechner in diesem
	Netzwerk gesendet wird, der die eingehenden Pakete im Subnetz
	verteilt.</para>

      <para>Wenn Sie einen Adressraum f&uuml;r Ihre Seite zugewiesen
	bekommen, richtet Ihr Diensteanbieter seine Routingtabellen so
	ein, dass der ganze Verkehr f&uuml;r Ihr Subnetz entlang Ihrer
	PPP-Verbindung zu Ihrer Seite gesendet wird.  Aber woher
	wissen die Seiten in der Au&szlig;enwelt, dass sie die Daten an
	Ihren ISP senden sollen?</para>

      <para>Es gibt ein System (&auml;hnlich dem verbreiteten DNS),
	das alle zugewiesenen Adressr&auml;ume verwaltet und ihre
	Verbindung zum Internet-Backbone definiert und dokumentiert.
	Der <quote>Backbone</quote> ist das Netz aus
	Hauptverbindungen, die den Internetverkehr in der ganzen Welt
	transportieren und verteilen.  Jeder Backbone-Rechner
	verf&uuml;gt &uuml;ber eine Kopie von Haupttabellen, die den
	Verkehr f&uuml;r ein bestimmtes Netzwerk hierarchisch vom
	Backbone &uuml;ber eine Kette von Diensteanbietern bis hin zu
	Ihrer Seite leiten.</para>

      <para>Es ist die Aufgabe Ihres Diensteanbieters, den
	Backbone-Seiten mitzuteilen, dass sie mit Ihrer Seite
	verbunden wurden.  Durch diese Mitteilung der Route ist nun
	auch der Weg zu Ihnen bekannt.  Dieser Vorgang wird als
	<emphasis>Bekanntmachung von Routen</emphasis>
	(<foreignphrase>routing propagation</foreignphrase>)
	bezeichnet.</para>
    </sect2>

    <sect2 id="network-routing-troubleshooting">
      <title>Problembehebung</title>
      <indexterm>
	<primary><command>traceroute</command></primary>
      </indexterm>

      <para>Manchmal kommt es zu Problemen bei der Bekanntmachung von
	Routen, und einige Seiten sind nicht in der Lage, Sie zu
	erreichen.  Vielleicht der n&uuml;tzlichste Befehl, um
	festzustellen, wo das Routing nicht funktioniert, ist
	&man.traceroute.8;.  Er ist au&szlig;erdem sehr n&uuml;tzlich,
	wenn Sie einen entfernten Rechner nicht erreichen k&ouml;nnen
	(lesen Sie dazu auch &man.ping.8;).</para>

      <para>&man.traceroute.8; wird mit dem zu erreichenden Rechner
	(Host) ausgef&uuml;hrt.  Angezeigt werden die Gateway-Rechner
	entlang des Verbindungspfades.  Schlie&szlig;lich wird der
	Zielrechner erreicht oder es kommt zu einem Verbindungsabbruch
	(beispielsweise durch Nichterreichbarkeit eines
	Gateway-Rechners).</para>

      <para>Weitere Informationen finden Sie in
	&man.traceroute.8;.</para>
    </sect2>

    <sect2 id="network-routing-multicast">
      <title>Multicast-Routing</title>
      <indexterm>
	<primary>Multicast-Routing</primary>
      </indexterm>

      <indexterm>
	<primary>Kerneloptionen</primary>
	<secondary>MROUTING</secondary>
      </indexterm>

      <para>&os; unterst&uuml;tzt sowohl Multicast-Anwendungen als
	auch Multicast-Routing.  Multicast-Anwendungen m&uuml;ssen
	nicht konfiguriert werden, sie laufen einfach.
	Multicast-Routing muss in der Kernelkonfiguration aktiviert
	werden:</para>

      <programlisting>options MROUTING</programlisting>

      <para>Zus&auml;tzlich muss &man.mrouted.8;, der
	Multicast-Routing-Daemon, &uuml;ber die Datei
	<filename>/etc/mrouted.conf</filename> eingerichtet werden,
	um Tunnel und <acronym>DVMRP</acronym> zu aktivieren.  Weitere
	Informationen zu diesem Thema finden Sie in
	&man.mrouted.8;.</para>

      <note>
	<para>&man.mrouted.8;, der Multicast Routing Daemon,
	  verwendet das <acronym>DVMRP</acronym> Multicast Routing
	  Protocol, das inzwischen in den meisten Multicast-Installationen
	  durch &man.pim.4; ersetzt wurde.   &man.mrouted.8; sowie die
	  damit in Verbindung stehenden Werkzeuge &man.map-mbone.8; und
	  &man.mrinfo.8;k&ouml;nnen &uuml;ber die &os;-Ports-Sammlung
	  (genauer den Port <filename
	  role="package">net/mrouted</filename>) installiert werden.</para>
      </note>
    </sect2>
  </sect1>

  <sect1 id="network-wireless">
    <sect1info>
      <authorgroup>
	<author>
	  <othername>Loader</othername>
	</author>

	<author>
	  <firstname>Marc</firstname>
	  <surname>Fonvieille</surname>
	</author>

	<author>
	  <firstname>Murray</firstname>
	  <surname>Stokely</surname>
	</author>
      </authorgroup>
    </sect1info>

    <title>Drahtlose Netzwerke</title>

    <indexterm><primary>Netzwerke, drahtlos</primary></indexterm>
    <indexterm>
      <primary>802.11</primary>
      <see>drahtlose Netzwerke</see>
    </indexterm>

    <sect2>
      <title>Grundlagen</title>

      <para>Die meisten drahtlosen Netzwerke basieren auf dem
	Standard &ieee;&nbsp;802.11.  Sie bestehen aus Stationen, die
	in der Regel im 2,4&nbsp;GHz- oder im 5&nbsp;GHz-Band
	miteinander kommunizieren.  Es ist aber auch
	m&ouml;glich, dass regional andere Frequenzen,
	beispielsweise im 2,3&nbsp;GHz- oder 4,9&nbsp;GHz-Band,
	verwendet werden.</para>

      <para>802.11-Netzwerke k&ouml;nnen auf zwei verschiedene
	Arten aufgebaut sein:  Im
	<emphasis>Infrastruktur-Modus</emphasis> agiert eine
	Station als Master, mit dem sich alle anderen Stationen
	verbinden.  Die Summe aller Stationen wird als BSS
	(Basic Service Set), die Master-Station hingegen als
	Access Point (AP) bezeichnet.  In einem BSS l&auml;uft
	jedwede Kommunikation &uuml;ber den Access Point.  Die
	zweite Form drahtloser Netzwerke sind die sogenannten
	<emphasis>Ad-hoc-Netzwerke</emphasis> (auch als IBSS
	bezeichnet), in denen es keinen Access Point gibt und
	in denen die Stationen direkt miteinander
	kommunizieren.</para>

      <para>Die ersten 802.11-Netzwerke arbeiteten im
	2,4&nbsp;GHz-Band und nutzten dazu Protokolle der
	&ieee;-Standards 802.11 sowie 802.11b.  Diese Standards
	legen unter anderem Betriebsfrequenzen sowie Merkmale
	des MAC-Layers (wie Frames und Transmissionsraten) fest.
	Sp&auml;ter kam der Standard 802.11a hinzu, der im
	5&nbsp;GHz-Band, im Gegensatz zu den ersten beiden
	Standards aber mit unterschiedlichen Signalmechanismen
	und h&ouml;heren Transmissionsraten arbeitet.  Der
	neueste Standard 802.11g implementiert die Signal- und
	Transmissionsmechanismen von 802.11a im 2,4&nbsp;GHz-Band,
	ist dabei aber abw&auml;rtskompatibel zu
	802.11b-Netzwerken.</para>

      <para>Unabh&auml;ngig von den zugrundeliegenden
	Transportmechanismen verf&uuml;gen 802.11-Netzwerke
	&uuml;ber diverse Sicherheitsmechanismen.  Der
	urspr&uuml;ngliche 802.11-Standard definierte lediglich
	ein einfaches Sicherheitsprotokoll namens WEP.  Dieses
	Protokoll verwendet einen fixen (gemeinsam verwendeten)
	Schl&uuml;ssel sowie die RC4-Kryptografie-Chiffre,
	um Daten verschl&uuml;sselt &uuml;ber das drahtlose
	Netzwerk zu senden.  Alle Stationen des Netzwerks
	m&uuml;ssen sich auf den gleichen fixen Schl&uuml;ssel
	einigen, um miteinander kommunizieren zu k&ouml;nnen.  Dieses
	Schema ist sehr leicht zu knacken und wird deshalb heute
	kaum mehr eingesetzt.  Aktuelle Sicherheitsmechanismen
	bauen auf dem Standard &ieee;&nbsp;802.11i auf, der neue
	kryptografische Schl&uuml;ssel (Chiffren), ein neues
	Protokoll f&uuml;r die Anmeldung von Stationen an einem
	Access Point, sowie Mechanismen zum Austausch von
	Schl&uuml;sseln als Vorbereitung der Kommunikation zwischen
	verschiedenen Ger&auml;ten festlegt.  Kryptografische
	Schl&uuml;ssel werden regelm&auml;&szlig;ig getauscht.
	Au&szlig;erdem gibt es Mechanismen, um Einbruchsversuche
	zu entdecken (und Gegenma&szlig;nahmen ergreifen zu k&ouml;nnen).
	Ein weiteres h&auml;ufig verwendetes Sicherheitsprotokoll ist
	WPA.  Dabei handelt es sich um einen Vorl&auml;ufer von 802.11i,
	der von einem Industriekonsortium als Zwischenl&ouml;sung bis
	zur endg&uuml;ltigen Verabschiedung von 802.11i entwickelt
	wurde.  WPA definiert eine Untergruppe der Anforderungen des
	802.11i-Standards und ist f&uuml;r den Einsatz in &auml;lterer
	Hardware vorgesehen.  WPA ben&ouml;tigt nur den (auf dem
	urspr&uuml;nglichen WEP-Code basierenden) TKIP-Chiffre.  802.11i
	erlaubt zwar auch die Verwendung von TKIP, fordert aber
	zus&auml;tzlich eine st&auml;rkere Chiffre (AES-CCM)
	f&uuml;r die Datenverschl&uuml;sselung.  (AES war f&uuml;r
	WPA nicht vorgesehen, weil man es als zu rechenintensiv
	f&uuml;r den Einsatz in &auml;lteren Ger&auml;ten ansah.)</para>

      <para>Neben den weiter oben erw&auml;hnten Standards ist auch
	der Standard 802.11e von gro&szlig;er Bedeutung.  Dieser
	definiert Protokolle zur &Uuml;bertragung von
	Multimedia-Anwendungen wie das Streaming von Videodateien
	oder Voice-over-IP (VoIP) in einem 802.11-Netzwerk.  Analog
	zu 802.11i verf&uuml;gt auch 802.11e &uuml;ber eine
	vorl&auml;ufige Spezifikation namens WMM (urspr&uuml;nglich
	WME), die von einem Industriekonsortium als Untergruppe
	von 802.11e spezifiziert wurde, um Multimedia-Anwendungen
	bereits vor der endg&uuml;ltigen Verabschiedung des
	802.11e-Standards implementieren zu k&ouml;nnen.  802.11e
	sowie WME/WMM  erlauben eine Priorit&auml;tenvergabe beim
	Datentransfer im einem drahtlosen Netzwerk.  M&ouml;glich
	wird dies durch den Einsatz von Quality of Service-Protokollen
	(QoS) und erweiterten Medienzugriffsprotokollen.  Werden
	diese Protokolle korrekt implementiert, erlauben sie daher
	hohe Daten&uuml;bertragungsraten und einen priorisierten
	Datenfluss.</para>

      <para>&os; unterst&uuml;tzt die Standards
	802.11a, 802.11b, sowie 802.11g.  Ebenfalls unterst&uuml;tzt
	werden WPA sowie die Sicherheitsprotokolle gem&auml;&szlig;
	802.11i (dies sowohl f&uuml;r 11a, 11b als auch 11g). QoS und
	Verkehrspriorisierung, die von den WME/WMM-Protokollen
	ben&ouml;tigt werden, werden ebenfalls (allerdings nicht
	f&uuml;r alle drahtlosen Ger&auml;te) unterst&uuml;tzt.</para>
    </sect2>

    <sect2 id="network-wireless-basic">
      <title>Basiskonfiguration</title>

      <sect3>
	<title>Kernelkonfiguration</title>

	<para>Um ein drahtloses Netzwerk zu nutzen, ben&ouml;tigen
	  Sie eine drahtlose Netzwerkkarte und einen Kernel, der
	  drahtlose Netzwerke unterst&uuml;tzt.  Der &os;-Kernel
	  unterst&uuml;tzt den Einsatz von Kernelmodulen.  Daher
	  m&uuml;ssen Sie nur die Unterst&uuml;tzung f&uuml;r die
	  von Ihnen verwendeten Ger&auml;te aktivieren.</para>

	<para>Als Erstes ben&ouml;tigen Sie ein drahtloses Ger&auml;t.
	  Die meisten drahtlosen Ger&auml;te verwenden Bauteile von
	  Atheros und werden deshalb vom &man.ath.4;-Treiber
	  unterst&uuml;tzt.  Um diesen Treiber zu verwenden,
	  nehmen Sie die folgende Zeile in die Datei
	  <filename>/boot/loader.conf</filename> auf:</para>

	<programlisting>if_ath_load="YES"</programlisting>

	<para>Der Atheros-Treiber besteht aus drei Teilen:
	  dem Treiber selbst (&man.ath.4;), dem
	  Hardware-Support-Layer f&uuml;r die
	  chip-spezifischen Funktionen (&man.ath.hal.4;)
	  sowie einem Algorithmus zur Auswahl der korrekten
	  Frame-&Uuml;bertragungsrate (ath_rate_sample).
	  Wenn Sie die Unterst&uuml;tzung f&uuml;r diesen
	  Treiber als Kernelmodul laden, k&uuml;mmert sich
	  dieses automatisch um diese Aufgaben.  Verwenden
	  Sie ein Nicht-Atheros-Ger&auml;t, so m&uuml;ssen
	  Sie hingegen das f&uuml;r dieses Ger&auml;t geeignete
	  Modul laden, beispielsweise</para>

	<programlisting>if_wi_load="YES"</programlisting>

	<para>f&uuml;r Ger&auml;te, die auf Bauteilen von
	  Intersil Prism basieren und daher den Treiber
	  &man.wi.4; voraussetzen.</para>

	<note>
	  <para>In den folgenden Abschnitten wird der
	    &man.ath.4;-Treiber verwendet.  Verwenden Sie ein
	    anderes Ger&auml;t, m&uuml;ssen Sie diesen Wert
	    daher an Ihre Konfiguration anpassen.  Eine Liste aller
	    verf&uuml;gbaren Treiber und unterst&uuml;tzten
	    drahtlosen Ger&auml;te finden sich in den &os;
	    Hardware Notes.  Diese sind f&uuml;r verschiedene
	    Releases und Architekturen auf der Seite <ulink
	    url="http://www.FreeBSD.org/releases/index.html">
	    Release Information</ulink> der &os; Homepage.  Gibt es
	    keinen nativen &os;-Treiber f&uuml;r Ihr drahtloses
	    Ger&auml;t, k&ouml;nnen Sie m&ouml;glicherweise mit
	    <link linkend="config-network-ndis">NDIS</link> einen
	    &windows;-Treiber verwenden.</para>
	</note>

	<para>Unter &os;&nbsp;7.X ben&ouml;tigen Sie zus&auml;tlich
	  zum korrekten Treiber auch die Unterst&uuml;tzung
	  f&uuml;r 802.11-Netzwerke.  F&uuml;r
	  den &man.ath.4;-Treiber werden dazu mindestens die
	  Module &man.wlan.4;, <literal>wlan_scan_ap</literal>
	  sowie <literal>wlan_scan_sta</literal> ben&ouml;tigt.
	  Das &man.wlan.4;-Kernelmodul wird automatisch mit dem
	  Treiber des drahtlosen Ger&auml;ts geladen, die beiden
	  anderen Module werden jeweils durch einen Eintrag in der
	  Datei <filename>/boot/loader.conf</filename> beim Systemstart
	  geladen:</para>

	<programlisting>wlan_scan_ap_load="YES"
wlan_scan_sta_load="YES"</programlisting>

	<para>Ab &os;&nbsp;8.0 sind diese Module Teil des
	  &man.wlan.4;-Treibers und werden bei Bedarf automatisch
	  geladen.</para>

	<para>Zus&auml;tzlich
	  ben&ouml;tigen Sie noch Module zur Verschl&uuml;sselung
	  ihres drahtlosen Netzwerks.  Diese werden normalerweise
	  dynamisch vom &man.wlan.4;-Modul geladen.  Im folgenden
	  Beispiel erfolgt allerdings eine manuelle Konfiguration.
	  Folgende Module sind verf&uuml;gbar:  &man.wlan.wep.4;,
	  &man.wlan.ccmp.4; sowie &man.wlan.tkip.4;.  Sowohl
	  &man.wlan.ccmp.4; als auch &man.wlan.tkip.4; werden nur
	  ben&ouml;tigt, wenn Sie WPA und/oder die Sicherheitsprotokolle
	  von 802.11i verwenden wollen.  Wollen Sie Ihr Netzwerk
	  hingegen ohne Verschl&uuml;sselung betreiben,
	  ben&ouml;tigen Sie nicht einmal
	  die &man.wlan.wep.4;-Unterst&uuml;tzung.  Um alle drei
	  Module beim Systemstart zu laden, f&uuml;gen Sie folgende
	  Zeilen in die Datei <filename>/boot/loader.conf</filename>
	  ein:</para>

	<programlisting>wlan_wep_load="YES"
wlan_ccmp_load="YES"
wlan_tkip_load="YES"</programlisting>

	<para>Um diese neuen Eintr&auml;ge in der Datei
	  <filename>/boot/loader.conf</filename> zu aktivieren, m&uuml;ssen
	  Sie Ihr &os;-System neu starten.  Alternativ k&ouml;nnen Sie
	  die Kernelmodule aber auch manuell mit &man.kldload.8; laden.</para>

	<note>
	  <para>Wollen Sie keine Kernelmodule verwenden, k&ouml;nnen
	    Sie die ben&ouml;tigten Treiber auch in Ihren Kernel
	    kompilieren.  Daz nehmen Sie folgende Zeilen in Ihre
	    Kernelkonfigurationsdatei auf:</para>

	  <programlisting>device wlan              # 802.11 support
device wlan_wep          # 802.11 WEP support
device wlan_ccmp         # 802.11 CCMP support
device wlan_tkip         # 802.11 TKIP support
device wlan_amrr         # AMRR transmit rate control algorithm
device ath               # Atheros pci/cardbus NIC's
device ath_hal           # pci/cardbus chip support
options AH_SUPPORT_AR5416 # enable AR5416 tx/rx descriptors
device ath_rate_sample   # SampleRate tx rate control for ath</programlisting>

        <para>Verwenden Sie &os;&nbsp;7.X, m&uuml;ssen Sie auch die beiden
	  Module <literal>wlan_scan_ap</literal> und
	  <literal>wlan_scan_sta</literal> in den Kernel aufnehmen (unter
	  &os;&nbsp;8.X ist dies hingegen nicht mehr notwendig):</para>

	<programlisting>device wlan_scan_ap      # 802.11 AP mode scanning
device wlan_scan_sta     # 802.11 STA mode scanning</programlisting>

	  <para>Danach bauen Sie den neuen Kernel und starten Ihr
	    &os;-System neu.</para>
	</note>

	<para>W&auml;hrend des Systemstarts sollten nun einige
	  Informationen &auml;hnlich den folgenden &uuml;ber das von
	  Ihnen verwendete drahtlose Ger&auml;t ausgegeben
	  werden:</para>

	<screen>ath0: &lt;Atheros 5212&gt; mem 0x88000000-0x8800ffff irq 11 at device 0.0 on cardbus1
ath0: [ITHREAD]
ath0: AR2413 mac 7.9 RF2413 phy 4.5</screen>
      </sect3>
    </sect2>

    <sect2>
      <title>Infrastruktur-Modus</title>

      <para>Drahtlose Netzwerke werden in der Regel im
	Infrastruktur-Modus (auch BSS-Modus genannt) betrieben.
	Dazu werden mehrere drahtlose Access Points zu einem
	gemeinsamen drahtlosen Netzwerk verbunden.  Jedes dieser
	drahtlosen Netzwerke hat einen eigenen Namen, der als
	<emphasis>SSID</emphasis> bezeichnet wird.  Alle Clients
	eines drahtlosen Netzwerks verbinden sich in diesem Modus
	mit einem Access Point.</para>

      <sect3>
	<title>&os;-Clients</title>

	<sect4>
	  <title>Einen Access Point finden</title>

	  <para>Um nach drahtlosen Netzwerken zu suchen verwenden Sie
	    <command>ifconfig</command>.  Dieser Scanvorgang kann einige
	    Zei in Anspruch nehmen, da dazu jede verf&uuml;gbare
	    Frequenz auf verf&uuml;gbare Access Points hin
	    &uuml;berpr&uuml;ft werden muss.  Um die Suche zu starten,
	    m&uuml;ssen Sie als Super-User angemeldet sein:</para>

	  <screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> create wlandev <replaceable>ath0</replaceable></userinput>
&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> up scan</userinput>
SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS
dlinkap         00:13:46:49:41:76   11   54M -90:96   100 EPS  WPA WME
freebsdap       00:11:95:c3:0d:ac    1   54M -83:96   100 EPS  WPA</screen>

	  <note>
	    <para>Ihre Netzwerkkarte muss in den Status
	      <option>up</option> versetzt werden, bevor Sie den ersten
	      Scanvorgang starten k&ouml;nnen.  F&uuml;r sp&auml;tere
	      Scans ist dies aber nicht mehr erforderlich.</para>
	  </note>

	  <note>
	    <para>Unter &os;&nbsp;7.X wird der Ger&auml;tetreiber,
	      beispielsweise
	      <devicename><replaceable>ath0</replaceable></devicename>,
	      direkt verwendet, anstatt auf das allgemeine Ger&auml;t
	      <devicename>wlan<replaceable>0</replaceable></devicename>
	      zuzugreifen.  Verwenden Sie also &os;&nbsp;7.X, m&uuml;ssen
	      Sie die beiden Befehle im vorigen Beispiel durch den
	      folgenden Befehl ersetzen:</para>

	    <screen>&prompt.root; <userinput>ifconfig <replaceable>ath0</replaceable> up scan</userinput></screen>

	    <para>Dies gilt auch f&uuml;r alle weiteren Ausf&uuml;hrungen
	      in diesem Kapitel.  Unter &os;&nbsp;7.X m&uuml;ssen analog
	      alle Befehle und Konfigurationsdateien/Zeilen entsprechend
	      angepasst werden.</para>
	  </note>

	  <para>Als Ergebnis erhalten Sie eine Liste mit allen
	    gefundenen BSS/IBSS-Netzwerken.  Zus&auml;tzlich zur
	    <literal>SSID</literal> (dem Namen des Netzwerks) wird
	    auch die <literal>BSSID</literal> ausgegeben.  Dabei
	    handelt es sich um MAC-Adresse des Access Points.  Das
	    Feld <literal>CAPS</literal> gibt den Typ des Netzwerks
	    sowie die F&auml;higkeiten der Stationen innerhalb des
	    Netzwerks an:</para>

	  <variablelist>
	    <varlistentry>
	      <term><literal>E</literal></term>

	      <listitem>
		<para>Extended Service Set (ESS).  Zeigt an, dass die
		  Station Teil eines Infrastruktur-Netzwerks ist (und
		  nicht eines IBSS/Ad-hoc-Netzwerks).</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><literal>I</literal></term>

	      <listitem>
		<para>IBSS/Ad-hoc-Netzwerk.  Die Station ist Teil eines
		  Ad-hoc-Netzwerks (und nicht eines
		  ESS-Netzwerks).</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><literal>P</literal></term>

	      <listitem>
		<para>Privacy.  Alle Datenframes, die innerhalb des
		  BSS ausgetauscht werden, sind verschl&uuml;sselt.
		  Dieses BSS verwendet dazu kryptografische Verfahren
		  wie WEP, TKIP oder AES-CCMP.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><literal>S</literal></term>

	      <listitem>
		<para>Short Preamble.  Das Netzwerk verwendet eine
		  kurze Pr&auml;ambel (definiert in 802.11b High
		  Rate/DSSS PHY). Eine kurze Pr&auml;ambel verwendet
		  ein 56&nbsp;Bit langes Sync-Feld (im Gegensatz
		  zu einer langen Pr&auml;ambel, die ein
		  128&nbsp;Bit langes Sync-Feld verwendet).</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><literal>s</literal></term>

	      <listitem>
		<para>Short slot time.  Das 802.11g-Netzwerk verwendet
		  eine kurze Slotzeit, da es in diesem Netzwerk keine
		  veralteten (802.11b) Ger&auml;te gibt.</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>

	  <para>Um eine Liste der bekannten Netzwerke auszugeben,
	    verwenden Sie den folgenden Befehl:</para>

	  <screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> list scan</userinput></screen>

	  <para>Diese Liste kann entweder automatisch durch das
	    drahtlose Ger&auml;t oder manuell durch eine
	    <option>scan</option>-Aufforderung aktualisiert werden.
	    Veraltete Informationen werden dabei automatisch
	    entfernt.</para>
	</sect4>

	<sect4>
	  <title>Basiseinstellungen</title>

	  <para>Dieser Abschnitt beschreibt, wie Sie ein einfaches
	    drahtloses Netzerk ohne Verschl&uuml;sselung unter &os;
	    einrichten.  Nachdem Sie sich mit den Informationen dieses
	    Abschnitts vertraut gemacht haben, sollten Sie Ihr
	    drahtloses Netzwerk mit <link
	    linkend="network-wireless-wpa">WPA</link>
	    verschl&uuml;sseln.</para>

	  <para>Das Einrichten eines drahtlosen Netzwerks erfolgt
	    in drei Schritten:  Der Auswahl eines Access Points, der
	    Anmeldung Ihrer Station sowie der Konfiguration Ihrer
	    IP-Adresse.</para>

	  <sect5>
	    <title>Einen Access Point ausw&auml;hlen</title>

	    <para>Im Normalfall wird sich Ihre Station automatisch mit
	      einem der zur Verf&uuml;gung stehenden Access Points
	      verbinden.  Sie m&uuml;ssen dazu lediglich Ihr
	      drahtloses Ger&auml;t aktivieren.  Alternativ k&ouml;nnen
	      Sie auch einen Eintrag &auml;hnlich dem folgenden in
	      <filename>/etc/rc.conf</filename> aufnehmen:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="DHCP"</programlisting>

	    <note>
	      <para>Wie bereits erw&auml;hnt, ben&ouml;tigen Sie unter
		&os;&nbsp;7.X anstelle dieser beiden Zeilen nur eine
		Zeile (mit dem entsprechenden Ger&auml;tetreiber):</para>

	      <programlisting>ifconfig_ath0="DHCP"</programlisting>
	    </note>

	    <para>Wollen Sie sich hingegen mit einem bestimmten
	      Access Point verbinden, m&uuml;ssen Sie dessen
	      SSID angeben:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="ssid <replaceable>Ihre_SSID</replaceable> DHCP"</programlisting>

	    <para>Gibt es in Ihrem Netzwerk mehrere Access Points
	      mit der gleichen SSID (was der Einfachheit wegen
	      h&auml;ufig der Fall ist), k&ouml;nnen Sie sich dennoch
	      mit einem bestimmten Access Point verbinden.  Dazu
	      m&uuml;ssen Sie lediglich die BSSID des Access Points
	      angeben (die Angabe der SSID ist in diesem Fall nicht
	      erforderlich):</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="ssid <replaceable>Ihre_SSID</replaceable> bssid <replaceable>xx:xx:xx:xx:xx:xx</replaceable> DHCP"</programlisting>

	    <para>Es gibt noch weitere M&ouml;glichkeiten, den Zugriff
	      auf bestimmte Access Point zu beschr&auml;nken,
	      beispielsweise durch die Begrenzung der Frequenzen, auf
	      denen eine Station nach einem Access Point sucht.  Sinnvoll
	      ist ein solches Vorgehen beispielsweise, wenn Ihr
	      drahtloses Ger&auml;t in verschiedenen Frequenzbereichen
	      arbeiten kann, da in diesem Fall das Pr&uuml;fen aller
	      Frequenzen sehr zeitintensiv ist.  Um nur innerhalb eines
	      bestimmten Frequenzbereichs nach einem Access Point zu
	      suchen, verwenden Sie die Option <option>mode</option>:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="mode <replaceable>11g</replaceable> ssid <replaceable>Ihre_SSID</replaceable> DHCP"</programlisting>

	    <para>Dadurch sucht Ihr drahtloses Ger&auml;t nur im
	      2,4&nbsp;GHz-Band (802.11g), aber nicht innerhalb des
	      5&nbsp;GHz-Bandes nach einem Access Point.  Mit der
	      Option <option>channel</option> k&ouml;nnen Sie eine
	      bestimmte Frequenz vorgeben, auf der gesucht werden
	      soll.   Die Option <option>chanlist</option> erlaubt
	      die Angabe mehrerer erlaubter Frequenzen.  Eine
	      umfassende Beschreibung dieser Optionen finden Sie in
	      der Manualpage &man.ifconfig.8;.</para>
	  </sect5>

	  <sect5>
	    <title>Authentifizierung</title>

	    <para>Wenn Sie einen Access Point gefunden haben, muss
	      sich Ihrem Station am Access Point anmelden, bevor
	      Sie Daten &uuml;bertragen kann.  Dazu gibt es
	      verschiedene M&ouml;glichkeiten.  Am h&auml;ufigsten
	      wird nach wie vor die sogenannte <emphasis>offene
	      Authentifizierung</emphasis> verwendet.  Dabei wird
	      es jeder Station erlaubt, sich mit einem Netzwerk
	      zu verbinden und Daten zu &uuml;bertragen.  Aus
	      Sicherheitsgr&uuml;nden sollte diese Methode allerdings
	      nur zu Testzwecken bei der erstmaligen Einrichtung
	      eines drahtlosen Netzwerks verwendet werden.  Andere
	      Authentifizierungsmechanismen erfordern den Austausch
	      kryptografischer Informationen, bevor Sie die
	      &Uuml;bertragung von Daten erlauben.  Dazu geh&ouml;ren
	      der Austausch fixer (vorher vereinbarter) Schl&uuml;ssel
	      oder Kennw&ouml;rter sowie der Einsatz komplexerer
	      Verfahren mit Backend-Diensten wie RADIUS.  Die meisten
	      Netzwerke nutzen allerdings nach wie vor die offene
	      Authentifizierung, da dies die Voreinstellung ist.  Am
	      zweith&auml;ufigsten kommt das weiter unten beschriebene
	      <link
	      linkend="network-wireless-wpa-wpa-psk">WPA-PSK</link>
	      (das auch als <foreignphrase>WPA Personal</foreignphrase>
	      bezeichnet wird) zum Einsatz.</para>

	    <note>
	      <para>Verwenden Sie eine
		&apple; &airport; Extreme-Basisstation als Access Point,
		ben&ouml;tigen Sie wahrscheinlich sowohl die
		Shared-Key-Authentifizierung als auch einen
		WEP-Schl&uuml;ssel.  Die entsprechende Konfiguration
		erfolgt entweder in der Datei
		<filename>/etc/rc.conf</filename> oder &uuml;ber das
		Programm &man.wpa.supplicant.8;.  Verwenden Sie nur
		eine einzige &airport;-Basisstation, ben&ouml;tigen
		Sie einen Eintrag &auml;hnlich dem folgenden:</para>

	      <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="authmode shared wepmode on weptxkey <replaceable>1</replaceable> wepkey <replaceable>01234567</replaceable> DHCP"</programlisting>


	      <para>Normalerweise sollten Sie
		Shared-Key-Authentifizierung aber nicht verwenden,
		da diese die Sicherheit des WEP-Schl&uuml;ssel noch
		weiter verringert.  M&uuml;ssen Sie WEP einsetzen
		(beispielsweise weil Sie zu veralteten Ger&auml;ten
		kompatibel bleiben m&uuml;ssen),  sollten Sie WEP
		nur zusammen mit der offenen Authentifizierung
		(<literal>open</literal> authentication) verwenden.
		WEP wird im <xref
		linkend="network-wireless-wep"> n&auml;her
		beschrieben.</para>
	    </note>
	  </sect5>

	  <sect5>
	    <title>Eine IP-Adresse &uuml;ber DHCP beziehen</title>

	    <para>Nachdem Sie einen Access Point gefunden und sich
	      authentifiziert haben, ben&ouml;tigen Sie noch eine
	      IP-Adresse, die Sie in der Regel &uuml;ber DHCP
	      zugewiesen bekommen.  Dazu m&uuml;ssen Sie lediglich
	      die Option <literal>DHCP</literal> in Ihre
	      in der Datei <filename>/etc/rc.conf</filename>
	      vorhandene Konfiguration Ihres drahtlosen Ger&auml;ts
	      aufnehmen:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="DHCP"</programlisting>

	    <para>Nun k&ouml;nnen Sie Ihr drahtloses Ger&auml;t
	      starten:</para>

	    <screen>&prompt.root; <userinput>/etc/rc.d/netif start</userinput></screen>

	    <para>Nachdem Sie das Ger&auml;t aktiviert haben,
	      k&ouml;nnen Sie mit <command>ifconfig</command> den
	      Status des Ger&auml;ts <devicename>ath0</devicename>
	      abfragen:</para>

	    <screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable></userinput>
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        ether 00:11:95:d5:43:62
        inet 192.168.1.100 netmask 0xffffff00 broadcast 192.168.1.255
        media: IEEE 802.11 Wireless Ethernet OFDM/54Mbps mode 11g
        status: associated
        ssid dlinkap channel 11 (2462 Mhz 11g) bssid 00:13:46:49:41:76
        country US ecm authmode OPEN privacy OFF txpower 21.5 bmiss 7
        scanvalid 60 bgscan bgscanintvl 300 bgscanidle 250 roam:rssi 7
        roam:rate 5 protmode CTS wme burst</screen>


	    <para><literal>status: associated</literal> besagt, dass
	      sich Ihr Ger&auml;t mit dem drahtlosen Netzwerk verbunden
	      hat (konkret mit dem Netzwerk <literal>dlinkap</literal>).
	      <literal>bssid 00:13:46:49:41:76</literal> gibt die
	      MAC-Adresse Ihres Access Points aus und die Zeile mit
	      <literal>authmode OPEN</literal> informiert Sie dar&uuml;ber,
	      dass Ihre Kommunikation nicht verschl&uuml;sselt wird.</para>
	  </sect5>

	  <sect5>
	    <title>Statische IP-Adressen</title>

	    <para>Alternativ zu dynamischen IP-Adressen
	      k&ouml;nnen Sie auch eine statische IP-Adresse verwenden.
	      Dazu ersetzen Sie in Ihrer Konfiguration
	      <literal>DHCP</literal> durch die zu verwendende
	      IP-Adresse.  Beachten Sie dabei, dass Sie die anderen
	      Konfigurationsparameter nicht versehentlich
	      ver&auml;ndern:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="inet <replaceable>192.168.1.100</replaceable> netmask <replaceable>255.255.255.0</replaceable> ssid <replaceable>your_ssid_here</replaceable>"</programlisting>
	  </sect5>
	</sect4>

	<sect4 id="network-wireless-wpa">
	  <title>WPA</title>

	  <para>Bei WPA (Wi-Fi Protected Access) handelt es sich um ein
	    Sicherheitsprotokoll, das in 802.11-Netzwerken verwendet
	    wird, um die Nachteile von <link
	    linkend="network-wireless-wep">WEP</link> (fehlende
	    Authentifizierung und schwache Verschl&uuml;sselung)
	    zu vermeiden.  WPA stellt das aktuelle
	    802.1X-Authentifizierungsprotokoll dar und verwendet
	    eine von mehreren Chiffren, um die Datensicherheit
	    zu gew&auml;hrleisten.  Die einzige Chiffre, die von
	    WPA verlangt wird, ist TKIP (<foreignphrase>Temporary
	    Key Integrity Protocol</foreignphrase>), eine Chiffre,
	    die die von WEP verwendete RC4-Chiffre um Funktionen
	    zur Pr&uuml;fung der Datenintegrit&auml;t und zur
	    Erkennung und Bek&auml;mpfung von Einbruchsversuchen
	    erweitert.
	    TKIP ist durch Softwaremodifikationen auch unter
	    veralteter Hardware lauff&auml;hig.  Im Vergleich zu
	    WEP ist WPA zwar sehr viel sicherer, es ist aber dennoch
	    nicht v&ouml;llig immun gegen Angriffe.  WPA definiert
	    mit AES-CCMP noch eine weitere Chiffre als Alternative
	    zu TKIP.  AES-CCMP (das h&auml;ufig als WPA2 oder RSN
	    bezeichnet wird) sollte, wenn m&ouml;glich, eingesetzt
	    werden.</para>

	  <para>WPA definiert Authentifizierungs- und
	    Verschl&uuml;sselungsprotokolle.  Die Authentifizierung
	    erfolgt in der Regel &uuml;ber eine der folgenden
	    Techniken:  802.1X gemeinsam mit einem
	    Backend-Authentifizierungsdienst wie RADIUS, oder durch
	    einen Minimal-Handshake zwischen der Station und dem
	    Access Point mit einem vorher vereinbarten gemeinsamen
	    Schl&uuml;ssel.  Die erste Technik wird als
	    <foreignphrase>WPA Enterprise</foreignphrase>, die zweite
	    hingegen als <foreignphrase>WPA Personal</foreignphrase>
	    bezeichnet.  Da sich der Aufwand f&uuml;r das Aufsetzen
	    eines RADIUS-Backend-Servers f&uuml;r die meisten
	    drahtlosen Netzwerke nicht lohnt, wird WPA in der Regel
	    als WPA-PSK (WPA, Pre-Shared-Key) konfiguriert.</para>

	  <para>Die Kontrolle der drahtlosen Verbindung sowie die
	    vorangehende Authentifizierung (&uuml;ber Schl&uuml;ssel
	    oder durch die Kommunikation mit einem Server) erfolgt
	    &uuml;ber das Programm &man.wpa.supplicant.8;, das
	    &uuml;ber die Datei
	    <filename>/etc/wpa_supplicant.conf</filename>
	    eingerichtet wird.  Ausf&uuml;hrliche Informationen
	    zur Konfiguration des Programms finden sich in der
	    Manualpage &man.wpa.supplicant.conf.5;.</para>

	  <sect5 id="network-wireless-wpa-wpa-psk">
	    <title>WPA-PSK</title>

	    <para>WPA-PSK oder WPA-Personal basiert auf einem
	      gemeinsamen (vorher vereinbarten) Schl&uuml;ssel (PSK),
	      der aus einem Passwort generiert und danach als
	      Master-Key des drahtlosen Netzwerks verwendet wird.
	      Jeder Benutzer des drahtlosen Netzwerks verwendet daher
	      <emphasis>den gleichen</emphasis> Schl&uuml;ssel.  WPA-PSK
	      sollte nur in kleinen Netzwerken eingesetzt werden, in
	      denen die Konfiguration eines Authentifizierungsservers
	      nicht m&ouml;glich oder erw&uuml;nscht ist.</para>

	    <warning>
	      <para>Achten Sie darauf, dass Sie immer starke
		Passw&ouml;rter verwenden, die ausreichend lang
		sind und, wenn m&ouml;glich, auch Sonderzeichen
		enthalten, damit diese nicht leicht erraten und/oder
		umgangen werden k&ouml;nnen.</para>
	    </warning>

	    <para>Der erste Schritt zum Einsatz von WPA-PSK ist die
	      Konfiguration der SSID und des gemeinsamen Schl&uuml;ssels
	      Ihres Netzwerks in der Datei
	      <filename>/etc/wpa_supplicant.conf</filename>:</para>

	    <programlisting>network={
  ssid="freebsdap"
  psk="freebsdmall"
}</programlisting>

	    <para>Danach geben Sie in <filename>/etc/rc.conf</filename>
	      an, dass WPA zur Verschl&uuml;sselung eingesetzt werden
	      soll und dass die IP-Adresse &uuml;ber DHCP bezogen
	      wird:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="WPA DHCP"</programlisting>

	    <para>Nun k&ouml;nnen Sie Ihr Netzger&auml;t aktivieren:</para>

	    <screen>&prompt.root; <userinput><filename>/etc/rc.d/netif</filename> start</userinput>
Starting wpa_supplicant.
DHCPDISCOVER on wlan0 to 255.255.255.255 port 67 interval 5
DHCPDISCOVER on wlan0 to 255.255.255.255 port 67 interval 6
DHCPOFFER from 192.168.0.1
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPACK from 192.168.0.1
bound to 192.168.0.254 -- renewal in 300 seconds.
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 MHz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</screen>

	    <para>Alternativ k&ouml;nnen Sie die Konfiguration von
	      <link linkend="network-wireless-wpa-wpa-psk">WPA-PSK</link>
	      auch manuell durchf&uuml;hren, wobei Sie wiederum die
	      Konfigurationsdatei
	      <filename>/etc/wpa_supplicant.conf</filename>
	      verwenden:</para>

	    <screen>&prompt.root; <userinput>wpa_supplicant -i <replaceable>wlan0</replaceable> -c /etc/wpa_supplicant.conf</userinput>
Trying to associate with 00:11:95:c3:0d:ac (SSID='freebsdap' freq=2412 MHz)
Associated with 00:11:95:c3:0d:ac
WPA: Key negotiation completed with 00:11:95:c3:0d:ac [PTK=CCMP GTK=CCMP]
CTRL-EVENT-CONNECTED - Connection to 00:11:95:c3:0d:ac completed (auth) [id=0 id_str=]</screen>

	    <para>Im zweiten Schritt starten Sie nun
	      <command>dhclient</command>, um eine IP-Adresse vom
	      DHCP-Server zu beziehen:</para>

	    <screen>&prompt.root; <userinput>dhclient <replaceable>wlan0</replaceable></userinput>
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPACK from 192.168.0.1
bound to 192.168.0.254 -- renewal in 300 seconds.
&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable></userinput>
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 MHz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</screen>

	    <note>
	      <para>Enth&auml;lt Ihre <filename>/etc/rc.conf</filename>
		bereits die Zeile <literal>ifconfig_wlan0="DHCP"</literal>,
		m&uuml;ssen Sie <command>dhclient</command> nicht mehr
		manuell aufrufen, da <command>dhclient</command> in
		diesem Fall automatisch gestartet wird, nachdem
		<command>wpa_supplicant</command> die Schl&uuml;ssel
		&uuml;bergibt.</para>
	    </note>

	    <para>Sollte der Einsatz von DHCP nicht m&ouml;glich sein,
	      k&ouml;nnen Sie auch eine statische IP-Adresse
	      angeben, nachdem <command>wpa_supplicant</command> Ihre
	      Station authentifiziert hat:</para>

	    <screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> inet <replaceable>192.168.0.100</replaceable> netmask <replaceable>255.255.255.0</replaceable></userinput>
&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable></userinput>
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.100 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 MHz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</screen>

	    <para>Verwenden Sie DHCP nicht, m&uuml;ssen Sie
	      zus&auml;tzlich noch das Standard-Gateway sowie
	      den/die Nameserver manuell festlegen:</para>

	    <screen>&prompt.root; <userinput>route add default <replaceable>your_default_router</replaceable></userinput>
&prompt.root; <userinput>echo "nameserver <replaceable>your_DNS_server</replaceable>" &gt;&gt; /etc/resolv.conf</userinput></screen>
	  </sect5>

	  <sect5 id="network-wireless-wpa-eap-tls">
	    <title>WPA und EAP-TLS</title>

	    <para>Die zweite M&ouml;glichkeit, WPA einzusetzen, ist
	      die Verwendung eines
	      802.1X-Backend-Authentifizierungsservers.  Diese
	      Variante wird als WPA-Enterprise bezeichnet, um sie
	      vom weniger sicheren WPA-Personal abzugrenzen, das
	      auf dem Austausch gemeinsamer (und vorher vereinbarter
	      Schl&uuml;ssel) basiert.  Die bei WPA-Enterprise
	      verwendete Authentifizierung basiert auf EAP
	      (<foreignphrase>Extensible Authentication
	      Protocol</foreignphrase>).</para>

	    <para>EAP selbst bietet keine Verschl&uuml;sselung,
	      sondern operiert in einem verschl&uuml;sselten
	      Tunnel.  Es gibt verschiedene, auf EAP basierende
	      Authentifizierungsmethoden, darunter EAP-TLS,
	      EAP-TTLS sowie EAP-PEAP.</para>

	    <para>Bei EAP-TLS (<foreignphrase>EAP with Transport Layers
	      Security</foreignphrase>) handelt es sich um sehr gut
	      unterst&uuml;tztes Authentifizierungsprotokoll, da es
	      sich dabei um die erste EAP-Methode handelt, die von
	      der <ulink url="http://www.wi-fi.org/">Wi-Fi
	      Alliance</ulink> zertifiziert wurde.  EAP-TLS
	      erfordert drei Zertifikate:  Das (auf allen Rechnern
	      installierte) CA-Zertifikat, das Server-Zertifikat
	      Ihres Authentifizierungsservers, sowie ein
	      Client-Zertifikat f&uuml;r jeden drahtlosen Client.
	      Sowohl der Authentifizierungsservers als auch die
	      drahtlosen Clients authentifizieren sich gegenseitig
	      durch ihre Zertifikate, wobei sie &uuml;berpr&uuml;fen,
	      ob diese Zertifikate auch von der
	      Zertifizierungs-Authorit&auml;t (CA) des jeweiligen
	      Unternehmens signiert wurden.</para>

	    <para>Die Konfiguration erfolgt (analog zu WPA-PSK)
	      &uuml;ber die Datei
	      <filename>/etc/wpa_supplicant.conf</filename>:</para>

	    <programlisting>network={
  ssid="freebsdap" <co id="co-tls-ssid">
  proto=RSN  <co id="co-tls-proto">
  key_mgmt=WPA-EAP <co id="co-tls-kmgmt">
  eap=TLS <co id="co-tls-eap">
  identity="loader" <co id="co-tls-id">
  ca_cert="/etc/certs/cacert.pem" <co id="co-tls-cacert">
  client_cert="/etc/certs/clientcert.pem" <co id="co-tls-clientcert">
  private_key="/etc/certs/clientkey.pem" <co id="co-tls-pkey">
  private_key_passwd="freebsdmallclient" <co id="co-tls-pwd">
}</programlisting>

	    <calloutlist>
	      <callout arearefs="co-tls-ssid">
		<para>Der Name des Netzwerks (die SSID).</para>
	      </callout>

	      <callout arearefs="co-tls-proto">
		<para>Das RSN/WPA2-Protokoll (&ieee; 802.11i) wird
		  verwendet.</para>
	      </callout>

	      <callout arearefs="co-tls-kmgmt">
		<para>Die <literal>key_mgmt</literal>-Zeile bezieht
		  sich auf das verwendete Key-Management-Protokoll.
		  In diesem Beispiel wird WPA gemeinsam mit der
		  EAP-Authentifizierung verwendet
		  (<literal>WPA-EAP</literal>).</para>
	      </callout>

	      <callout arearefs="co-tls-eap">
		<para>Die f&uuml;r die Verbindung verwendete
		  EAP-Methode.</para>
	      </callout>

	      <callout arearefs="co-tls-id">
		<para>Das <literal>identity</literal>-Feld enth&auml;lt
		  den von EAP verwendeten Identifizierungsstring.</para>
	      </callout>

	      <callout arearefs="co-tls-cacert">
		<para>Das Feld <literal>ca_cert</literal> gibt den Pfad
		  zum CA-Zertifikat an.  Dieses Datei wird ben&ouml;tigt,
		  um das Server-Zertifikat zu verifizieren.</para>
	      </callout>

	      <callout arearefs="co-tls-clientcert">
		<para>Die <literal>client_cert</literal>-Zeile gibt den
		  Pfad zum Client-Zertifikat an.  Jeder Client hat ein
		  eigenes, innerhalb des Netzwerks eindeutiges,
		  Zertifikat.</para>
	      </callout>

	      <callout arearefs="co-tls-pkey">
		<para>Das Feld <literal>private_key</literal> gibt den
		  Pfad zum privaten Schl&uuml;ssel des
		  Client-Zertifikat an.</para>
	      </callout>

	      <callout arearefs="co-tls-pwd">
		<para>Das Feld <literal>private_key_passwd</literal>
		  enth&auml;lt die Passphrase f&uuml;r den privaten
		  Schl&uuml;ssel.</para>
	      </callout>
	    </calloutlist>

	    <para>Danach f&uuml;gen Sie die folgende Zeile in
	      <filename>/etc/rc.conf</filename> ein:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="WPA DHCP"</programlisting>

	    <para>Nun k&ouml;nnen Sie Ihr drahtloses Ger&auml;t
	      &uuml;ber das <filename>rc.d</filename>-System
	      aktivieren:</para>

	    <screen>&prompt.root; <userinput>/etc/rc.d/netif start</userinput>
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
DHCPACK from 192.168.0.20
bound to 192.168.0.254 -- renewal in 300 seconds.
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 MHz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</screen>

	    <para>Alternativ k&ouml;nnen Sie Ihr drahtloses Ger&auml;lt
	      wiederum manuell &uuml;ber
	      <command>wpa_supplicant</command> und
	      <command>ifconfig</command> aktivieren.</para>
	  </sect5>

	  <sect5 id="network-wireless-wpa-eap-ttls">
	    <title>WPA und EAP-TTLS</title>

	    <para>Bei EAP-TLS m&uuml;ssen sowohl der
	      Authentifizierungsserver als auch die Clients jeweils
	      ein eigenes Zertifikat aufweisen.  Setzen Sie hingegen
	      EAP-TTLS (<foreignphrase>EAP-Tunneled
	      Transport Layer Security</foreignphrase>) ein, ist das
	      Client-Zertifikat optional.  EAP-TTLS geht dabei
	      &auml;hnlich vor wie verschl&uuml;sselte Webseiten,
	      bei denen der Webserver einen sicheren SSL-Tunnel
	      erzeugen kann, ohne dass der Besucher dabei &uuml;ber
	      ein client-seitiges Zertifikat verf&uuml;gen muss.
	      EAP-TTLS verwendet einen verschl&uuml;sselten
	      TLS-Tunnel zum sicheren Transport der
	      Authentifizierungsdaten.</para>

	    <para>Die Konfiguration von EAP-TTLS erfolgt in der
	      Datei <filename>/etc/wpa_supplicant.conf</filename>:</para>

	    <programlisting>network={
  ssid="freebsdap"
  proto=RSN
  key_mgmt=WPA-EAP
  eap=TTLS <co id="co-ttls-eap">
  identity="test" <co id="co-ttls-id">
  password="test" <co id="co-ttls-passwd">
  ca_cert="/etc/certs/cacert.pem" <co id="co-ttls-cacert">
  phase2="auth=MD5" <co id="co-ttls-pha2">
}</programlisting>

	    <calloutlist>
	      <callout arearefs="co-ttls-eap">
		<para>Die f&uuml;r die Verbindung verwendete
		  EAP-Methode.</para>
	      </callout>

	      <callout arearefs="co-ttls-id">
		<para>Das <literal>identity</literal>-Feld enth&auml;lt
		  den Identifizierungsstring f&uuml;r die
		  EAP-Authentifizierung innerhalb des
		  verschl&uuml;sselten TlS-Tunnels.</para>
	      </callout>

	      <callout arearefs="co-ttls-passwd">
		<para>Das <literal>password</literal>-Feld enth&auml;lt
		  die Passphrase f&uuml;r die
		  EAP-Authentifizierung.</para>
	      </callout>

	      <callout arearefs="co-ttls-cacert">
		<para>Das Feld <literal>ca_cert</literal> gibt den
		  Pfad zum CA-Zertifikat an, das ben&ouml;tigt wird,
		  um das Server-Zertifikat zu verifizieren.</para>
	      </callout>

	      <callout arearefs="co-ttls-pha2">
		<para>Die innerhalb des verschl&uuml;sselten TLS-Tunnels
		  verwendete Authentifizierungsmethode.  In unserem
		  Beispiel handelt es sich dabei um EAP und MD5.  Diese
		  Phase der <quote>inneren Authentifizierung</quote> wird
		  oft als <quote>phase2</quote> bezeichnet.</para>
	      </callout>
	    </calloutlist>

	    <para>Folgende Zeilen m&uuml;ssen zus&auml;tzlich in die Datei
	      <filename>/etc/rc.conf</filename> aufgenommen werden:</para>

	    <programlisting>wlans_ath0="wlan0"
ifconfig_wlan0="WPA DHCP"</programlisting>

	    <para>Nun k&ouml;nnen Sie Ihr drahtloses Ger&auml;t
	      aktivieren:</para>

	    <screen>&prompt.root; <userinput>/etc/rc.d/netif start</userinput>
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 21
DHCPACK from 192.168.0.20
bound to 192.168.0.254 -- renewal in 300 seconds.
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 MHz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</screen>
	  </sect5>

	  <sect5 id="network-wireless-wpa-eap-peap">
	    <title>WPA und EAP-PEAP</title>

	    <para>PEAP (<foreignphrase>Protected EAP</foreignphrase>)
	      wurde als Alternative zu EAP-TTLS entwickelt.  Es gibt
	      zwei verschiedene PEAP-Methoden, wobei es sich bei
	      PEAPv0/EAP-MSCHAPv2 um die h&auml;ufiger verwendete
	      Methode handelt.  In den folgenden Ausf&uuml;hrungen
	      wird der Begriff PEAP synonym f&uuml;r diese
	      EAP-Methode verwendet.  PEAP ist nach EAP-TLS der
	      am h&auml;ufigsten verwendete und am besten
	      unterst&uuml;tzte EAP-Standard.</para>

	    <para>PEAP arbeitet &auml;hnlich wie EAP-TTLS:  Es
	      verwendet ein server-seitiges Zertifikat, um
	      einen verschl&uuml;sselten TLS-Tunnel zu erzeugen,
	      &uuml;ber den die sichere Authentifizierung zwischen
	      den Clients und dem Authentifizierungsserver erfolgt.
	      In Sachen Sicherheit unterscheiden sich EAP-TTLS und
	      PEAP allerdings:  PEAP &uuml;bertr&auml;gt den
	      Benutzernamen im Klartext und verschl&uuml;sselt nur
	      das Passwort, w&auml;hrend EAP-TTLS sowohl den
	      Benutzernamen als auch das Passwort &uuml;ber den
	      TLS-Tunnel &uuml;bertr&auml;gt.</para>

	    <para>Um EAP-PEAP einzurichten, m&uuml;ssen Sie die
	      Konfigurationsdatei
	      <filename>/etc/wpa_supplicant.conf</filename>
	      anpassen:</para>

	    <programlisting>network={
  ssid="freebsdap"
  proto=RSN
  key_mgmt=WPA-EAP
  eap=PEAP <co id="co-peap-eap">
  identity="test" <co id="co-peap-id">
  password="test" <co id="co-peap-passwd">
  ca_cert="/etc/certs/cacert.pem" <co id="co-peap-cacert">
  phase1="peaplabel=0" <co id="co-peap-pha1">
  phase2="auth=MSCHAPV2" <co id="co-peap-pha2">
}</programlisting>

	    <calloutlist>
	      <callout arearefs="co-peap-eap">
		<para>Die f&uuml;r die Verbindung verwendete
		  EAP-Methode.</para>
	      </callout>

	      <callout arearefs="co-peap-id">
		<para>Das <literal>identity</literal>-Feld enth&auml;lt
		  den Identifizierungsstring f&uuml;r die innerhalb
		  des verschl&uuml;sselten TLS-Tunnels erfolgende
		  EAP-Authentifizierung.</para>
	      </callout>

	      <callout arearefs="co-peap-passwd">
		<para>Das Feld <literal>password</literal> enth&auml;lt
		  die Passphrase f&uuml;r die EAP-Authentifizierung.</para>
	      </callout>

	      <callout arearefs="co-peap-cacert">
		<para>Das Feld <literal>ca_cert</literal> gibt den Pfad
		  zum CA-Zertifikat an, das zur Verifizierung des
		  Server-Zertifikats ben&ouml;tigt wird.</para>
	      </callout>

	      <callout arearefs="co-peap-pha1">
		<para>Dieses Feld enth&auml;lt die Parameter f&uuml;r
		  die erste Phase der Authentifizierung (also den
		  TLS-Tunnel).  Je nach dem, welchen
		  Authentifizierungsserver Sie verwenden, m&uuml;ssen
		  Sie hier einen unterschiedlichen Wert angeben.
		  In den meisten F&auml;llen wird dieses Feld den
		  Wert <quote>client EAP encryption</quote> aufweisen,
		  der durch die Angabe von
		  <literal>peaplabel=0</literal> gesetzt wird.  Weitere
		  Informationen zur Konfiguration von PEAP finden Sie
		  in der Manualpage &man.wpa.supplicant.conf.5;.</para>
	      </callout>

	      <callout arearefs="co-peap-pha2">
		<para>Das innerhalb des verschl&uuml;sselten TLS-Tunnels
		  verwendete Authentifizierungsprotokoll.  In unserem
		  Beispiel handelt es sich dabei um
		  <literal>auth=MSCHAPV2</literal>.</para>
	      </callout>
	    </calloutlist>

	    <para>Danach f&uuml;gen Sie die folgende Zeile in
	      <filename>/etc/rc.conf</filename> ein:</para>

	    <programlisting>ifconfig_ath0="WPA DHCP"</programlisting>

	    <para>Zuletzt m&uuml;ssen Sie die Netzwerkkarte noch
	      aktivieren:</para>

	    <screen>&prompt.root; <userinput>/etc/rc.d/netif start</userinput>
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 21
DHCPACK from 192.168.0.20
bound to 192.168.0.254 -- renewal in 300 seconds.
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 MHz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</screen>
	  </sect5>
	</sect4>

	<sect4 id="network-wireless-wep">
	  <title>WEP</title>

	  <para>WEP (Wired Equivalent Privacy) ist Teil des
	    urspr&uuml;nglichen 802.11-Standards.  Es enth&auml;lt
	    keinen Authentifzierungsmechanismus und verf&uuml;gt
	    lediglich &uuml;ber eine schwache Zugriffskontrolle,
	    die sehr leicht umgangen werden kann.</para>

	  <para>WEP kann &uuml;ber <command>ifconfig</command>
	    aktiviert werden:</para>

	  <screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> create wlandev <replaceable>ath0</replaceable></userinput>
&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> inet <replaceable>192.168.1.100</replaceable> netmask <replaceable>255.255.255.0</replaceable> \
	    ssid <replaceable>my_net</replaceable> wepmode on weptxkey <replaceable>3</replaceable> wepkey <replaceable>3:0x3456789012</replaceable></userinput></screen>

	  <itemizedlist>
	    <listitem>
	      <para> Mit <literal>weptxkey</literal> geben Sie an,
		welcher WEP-Schl&uuml;ssel f&uuml;r f&uuml;r die
		Daten&uuml;bertragung verwendet wird (in unserem
		Beispiel ist dies der dritte Schl&uuml;ssel).  Der
		gleiche Schl&uuml;ssel muss auch am Access Point
		eingestellt sein.  Kennen Sie den vom Access Point
		verwendeten Schl&uuml;ssel nciht, sollten Sie zuerst
		den Wert <literal>1</literal> (d.h. den ersten
		Schl&uuml;ssel) f&uuml;r diese Variable verwenden.</para>
	    </listitem>

	    <listitem>
	      <para>Mit <literal>wepkey</literal> legen Sie den zu
		verwendenden WEP-Schl&uuml;ssel in der Form
		<replaceable>Nummer:Schl&uuml;ssel</replaceable> fest.
		Ist der Schl&uuml;ssel "Nummer" nicht vorhanden, wird
		automatisch Schl&uuml;ssel <literal>1</literal>
		verwendet.  Die Angabe von "Nummer" ist zwingend
		n&ouml;tig, wenn Sie einen anderen als den ersten
		Schl&uuml;ssel verwenden wollen.</para>

	      <note>
		<para>In Ihrer Konfiguration m&uuml;ssen Sie
		  <literal>0x3456789012</literal> durch den an
		  Ihrem Access Point konfigurierten Schl&uuml;ssel
		  ersetzen.</para>
	      </note>
	    </listitem>
	  </itemizedlist>

	  <para>Weitere Informationen finden Sie in der Manualpage
	    &man.ifconfig.8;.</para>

	  <para>Das Programm <command>wpa_supplicant</command>
	    eignet sich ebenfalls dazu, WEP f&uuml;r Ihr drahtloses
	    Ger&auml;t zu aktivieren.  Obige Konfiguration l&auml;sst
	    sich dabei durch die Aufnahme der folgenden Zeilen in die
	    Datei <filename>/etc/wpa_supplicant.conf</filename>
	    realisieren:</para>

	  <programlisting>network={
  ssid="my_net"
  key_mgmt=NONE
  wep_key3=3456789012
  wep_tx_keyidx=3
}</programlisting>

	  <para>Danach m&uuml;ssen Sie das Programm noch aufrufen:</para>

	  <screen>&prompt.root; <userinput>wpa_supplicant -i <replaceable>wlan0</replaceable> -c /etc/wpa_supplicant.conf</userinput>
Trying to associate with 00:13:46:49:41:76 (SSID='dlinkap' freq=2437 MHz)
Associated with 00:13:46:49:41:76</screen>
	</sect4>
      </sect3>
    </sect2>

    <sect2>
      <title>Ad-hoc-Modus</title>

      <para>Der IBSS-Modus (auch als Ad-hoc-Modus bezeichnet), ist
	f&uuml;r Punkt-zu-Punkt-Verbindungen vorgesehen.  Um
	beispielsweise eine Ad-hoc-Verbindung zwischen den Rechnern
	<hostid>A</hostid> und <hostid>B</hostid> aufzubauen,
	ben&ouml;tigen Sie lediglich zwei IP-Adressen und eine
	SSID.</para>

      <para>Auf dem Rechner <hostid>A</hostid> geben Sie Folgendes
	ein:</para>

      <screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> create wlandev <replaceable>ath0</replaceable> wlanmode adhoc</userinput>
&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> inet <replaceable>192.168.0.1</replaceable> netmask <replaceable>255.255.255.0</replaceable> ssid <replaceable>freebsdap</replaceable></userinput>
&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable></userinput>
  wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
      ether 00:11:95:c3:0d:ac
      inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;adhoc&gt;
      status: running
      ssid freebsdap channel 2 (2417 Mhz 11g) bssid 02:11:95:c3:0d:ac
      country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
      protmode CTS wme burst</screen>

      <para>Der <literal>adhoc</literal>-Parameter gibt an, dass die
	Schnittstelle im IBSS-Modus l&auml;uft.</para>

      <para>Rechner <hostid>B</hostid> sollte nun in der Lage sein,
	Rechner <hostid>A</hostid> zu finden:</para>

      <screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> create wlandev <replaceable>ath0</replaceable> wlanmode adhoc</userinput>
&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> up scan</userinput>
  SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS
  freebsdap       02:11:95:c3:0d:ac    2   54M -64:-96  100 IS   WME</screen>

      <para>Der Wert <literal>I</literal> (Spalte CAPS) gibt an,
	dass sich Rechner <hostid>A</hostid> im Ad-hoc-Modus befindet.
	Nun m&uuml;ssen Sie nur noch Rechner <hostid>B</hostid> eine
	unterschiedliche IP-Adresse zuweisen:</para>

      <screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> inet <replaceable>192.168.0.2</replaceable> netmask <replaceable>255.255.255.0</replaceable> ssid <replaceable>freebsdap</replaceable></userinput>
&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable></userinput>
  wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;adhoc&gt;
      status: running
      ssid freebsdap channel 2 (2417 Mhz 11g) bssid 02:11:95:c3:0d:ac
      country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
      protmode CTS wme burst</screen>

      <para>Damit sind die Rechner <hostid>A</hostid> und
	<hostid>B</hostid> bereit und k&ouml;nnen untereinander
	Daten austauschen.</para>
    </sect2>

    <sect2 id="network-wireless-ap">
      <title>&os; Host Access Points</title>

      <para>&os; kann als Access Point (AP) agieren. Dies verhindert,
        dass man sich einen Hardware AP kaufen oder ein ad-hoc
        Netzwerk laufen lassen muss.  Dies kann sinnvoll sein,
        falls Ihre &os;-Computer als Gateway zu einem anderen
        Netzwerk (z.B. Internet) fungiert.</para>

      <sect3 id="network-wireless-ap-basic">
        <title>Grundeinstellungen</title>

        <para>Bevor Sie ihren &os;-Computer als einen AP konfigurieren,
          muss der Kernel mit dem f&uuml;r ihre Wireless-Karte
          entsprechenden Treibern konfiguriert werden.  Sie
          m&uuml;ssen ebenfalls die Sicherheitsprotokolle, die Sie
          nutzen wollen, dem Kernel hinzuf&uuml;gen.  F&uuml;r
          weitere Informationen siehe:
          <xref linkend="network-wireless-basic">.</para>

        <note>
          <para>Die Verwendung der NDIS und &windows; Treiber erlauben
            zur Zeit keinen AP-Modus. Nur die nativen
            &os;-Wireless-Treiber unterst&uuml;ten den AP Modus.</para>
        </note>

        <para>Nachdem die Unterst&uuml;tzung f&uuml;r ihr drahtloses
          Netzwerk geladen ist, k&ouml;nnen Sie &uuml;berpr&uuml;fen, ob
          Ihr Wireless-Ger&auml;t den hostbasierenden Access-Point Modus
          (auch bekannt als hostap Modus) unterst&uuml;tzt:</para>

	<screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> create wlandev <replaceable>ath0</replaceable></userinput>
&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> list caps</userinput>
drivercaps=6f85edc1&lt;STA,FF,TURBOP,IBSS,HOSTAP,AHDEMO,TXPMGT,SHSLOT,SHPREAMBLE,MONITOR,MBSS,WPA1,WPA2,BURST,WME,WDS,BGSCAN,TXFRAG&gt;
cryptocaps=1f&lt;WEP,TKIP,AES,AES_CCM,TKIPMIC&gt;</screen>

	<para>Diese Ausgabe zeigt die M&ouml;glichkeiten der Karte. Das
	  Wort <literal>HOSTAP</literal> best&auml;tigt, dass diese
	  Wireless-Karte als Access Point agieren kann.  Die
	  verschiedenen unterst&uuml;tzten Algorithmen
	  (z.B. WEP, TKIP, AES usw.) werden ebenfalls angezeigt.
	  Diese Informationen sind wichtig, wenn Sie wissen wollen,
	  welche Sicherheitsprotokolle auf diesem Access Point
	  verwendbar sind.</para>

	<para>Das Wireless-Ger&auml;t kann nur w&auml;hrend der Erzeugung
	  des Pseudo-Ger&auml;ts in den hostap-Modus gesetzt werden.
	  Zuvor erstellte Pseudo-Ger&auml;te m&uuml;ssen also vorher
	  zerst&ouml;rt werden:</para>

	<screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> destroy</userinput></screen>

	<para>Danach muss das Ger&auml;t erneut erstellt werden, bevor
	  die restlichen Netzwerkparameter konfiguriert werden
	  k&ouml;nnen:</para>

	<screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> create wlandev <replaceable>ath0</replaceable> wlanmode hostap</userinput>
&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> inet <replaceable>192.168.0.1</replaceable> netmask <replaceable>255.255.255.0</replaceable> ssid <replaceable>freebsdap</replaceable> mode 11g channel 1</userinput></screen>

	<para>Benutzen Sie danach erneut den Befehl
	  <command>ifconfig</command>, um den Status der
	  <devicename>wlan0</devicename>-Schnittstelle abzufragen:</para>

	<screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable></userinput>
  wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
      ether 00:11:95:c3:0d:ac
      inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;hostap&gt;
      status: running
      ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
      protmode CTS wme burst dtimperiod 1 -dfs</screen>

	<para>Die <literal>hostap</literal>-Parameter geben die
	  Schnittstelle an, die im hostbasierenden Access Point Modus
	  l&auml;uft.</para>

	<para>Die Konfiguration der Schnittstelle kann durch
	  Hinzuf&uuml;gen der folgenden Zeilen in die Datei
	  <filename>/etc/rc.conf</filename> automatisch w&auml;hrend
	  des Bootvorganges erfolgen:</para>

	<programlisting>wlans_ath0="wlan0"
create_args_wlan0="wlanmode hostap"
ifconfig_wlan0="inet <replaceable>192.168.0.1</replaceable> netmask <replaceable>255.255.255.0</replaceable> ssid <replaceable>freebsdap</replaceable> mode 11g channel <replaceable>1</replaceable>"</programlisting>
      </sect3>

      <sect3>
	<title>Hostbasierender Access Point ohne Authentifizierung
	  oder Verschl&uuml;sselung</title>

	<para>Obwohl es nicht empfohlen wird, einen AP ohne jegliche
	  Authentifizierung oder Verschl&uuml;sselung laufen zu lassen,
	  ist es eine einfache Art zu testen, ob der AP funktioniert.
	  Diese Konfiguration ist auch wichtig f&uuml;r die Fehlersuche
	  bei Client-Problemen.</para>

	<para>Nachdem Sie den AP, wie oben beschrieben, konfiguriert
	  haben, ist es m&ouml;glich von einem anderen drahtlosen
	  Computer eine Suche nach dem AP zu starten:</para>

	<screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> create wlandev <replaceable>ath0</replaceable></userinput>
&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> up scan</userinput>
SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS
freebsdap       00:11:95:c3:0d:ac    1   54M -66:-96  100 ES   WME</screen>

	<para>Der Client-Rechner fand den Access Point und kann mit ihm
	  verbunden werden:</para>

	<screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> inet <replaceable>192.168.0.2</replaceable> netmask <replaceable>255.255.255.0</replaceable> ssid <replaceable>freebsdap</replaceable></userinput>
&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable></userinput>
  wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/54Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode OPEN privacy OFF txpower 21.5 bmiss 7
      scanvalid 60 bgscan bgscanintvl 300 bgscanidle 250 roam:rssi 7
      roam:rate 5 protmode CTS wme burst</screen>
      </sect3>

      <sect3>
	<title>WPA-basierender Host-Access Point</title>

	<para>Dieser Abschnitt besch&auml;ftigt sich mit dem Konfigurieren
	  eines &os;-Access-Points mit dem WPA-Sicherheitsprotokoll.
	  Weitere Einzelheiten zu WPA und der Konfiguration von Clients mit
	  WPA finden Sie im
	  <xref linkend="network-wireless-wpa">.</para>

	<para>Der <application>hostapd</application>-Dienst wird genutzt,
	  um die Client-Authentifizierung und das Schl&uuml;sselmanagement
	  auf dem Access Point mit aktiviertem WPA zu nutzen.</para>

	<para>In den folgenden Abschnitten werden allen Konfigurationen
	  auf dem &os;-Computer ausgef&uuml;hrt, der als AP agiert.
	  Nachdem der AP korrekt arbeitet, sollte
	  <application>hostapd</application> automatisch beim Booten
	  durch folgende Zeile in der <filename>/etc/rc.conf</filename>
	  aktiviert werden:</para>

	<programlisting>hostapd_enable="YES"</programlisting>

	<para>Bevor Sie versuchen <application>hostapd</application>
	  zu konfigurieren, stellen Sie sicher, dass die
	  Grundeinstellungen, wie in
	  <xref linkend="network-wireless-ap-basic"> beschrieben,
	  ausgef&uuml;hrt wurden.</para>

	<sect4>
	  <title>WPA-PSK</title>

	  <para>WPA-PSK ist f&uuml;r kleine Netzwerke gedacht, in denen die
	    Verwendung eines Authentifizierungs-Backend-Server nicht
	    m&ouml;glich oder erw&uuml;nscht ist.</para>

	  <para>Die Konfiguration wird in
	    <filename>/etc/hostapd.conf</filename>
	    durchgef&uuml;hrt:</para>

	  <programlisting>interface=wlan0 <co id="co-ap-wpapsk-iface">
debug=1 <co id="co-ap-wpapsk-dbug">
ctrl_interface=/var/run/hostapd <co id="co-ap-wpapsk-ciface">
ctrl_interface_group=wheel <co id="co-ap-wpapsk-cifacegrp">
ssid=freebsdap <co id="co-ap-wpapsk-ssid">
wpa=1 <co id="co-ap-wpapsk-wpa">
wpa_passphrase=freebsdmall <co id="co-ap-wpapsk-pass">
wpa_key_mgmt=WPA-PSK <co id="co-ap-wpapsk-kmgmt">
wpa_pairwise=CCMP TKIP <co id="co-ap-wpapsk-pwise"></programlisting>

	  <calloutlist>
	    <callout arearefs="co-ap-wpapsk-iface">
	      <para>Dieses Feld zeigt die Wireless-Schnittstelle an, die
	        f&uuml;r den Access Point verwendet wird an.</para>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-dbug">
	      <para>Dieses Feld legt den debuglevel von
	        <application>hostapd</application> w&auml;hrend der
	        Ausf&uuml;hrung fest.  Ein Wert von <literal>1</literal>
	        ist der kleinste zul&auml;ssige Wert.</para>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-ciface">
	      <para>Das <literal>ctrl_interface</literal>-Feld gibt
	        den Pfadnamen des Verzeichnisses an, der von
	        <application>hostapd</application> dazu genutzt wird,
	        um die domain socket Dateien zu speichern, die f&uuml;r
	        die Kommunikation mit externen Programmen,
	        wie z.B. &man.hostapd.cli.8;, benutzt werden.
	        Hier wurden die Standardwerte benutzt.</para>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-cifacegrp">
	      <para>Die Zeile <literal>ctrl_interface_group</literal>
	        legt fest, welche Gruppe (hier ist es die
	        <groupname>wheel</groupname>-Gruppe) die Erlaubnis hat,
	        die Schnittstellendateien zu kontrollieren.</para>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-ssid">
	      <para>Dieses Feld setzt den Netzwerknamen.</para>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-wpa">
	      <para>Das <literal>wpa</literal>-Feld aktiviert WPA und
	        gibt an welches WPA-Authentifizierungprotokoll
	        ben&ouml;tigt wird.  Ein Wert von <literal>1</literal>
	        konfiguriert den AP mit WPA-PSK.</para>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-pass">
	      <para>Das <literal>wpa_passphrase</literal>-Feld
	        beinhaltet das ASCII-Passwort f&uuml;r die
	        WPA-Authentifikation.</para>

	      <warning>

	        <para>Verwenden Sie immer sichere Passw&ouml;rter,
	          die ausreichend lang sind und aus vielen
	          unterschiedlichen Zeichen bestehen, damit sie nicht
	          erraten werden oder umgangen werden k&ouml;nnen.</para>
	      </warning>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-kmgmt">

	      <para>Die <literal>wpa_key_mgmt</literal> Zeile bestimmt
	        das Schl&uuml;sselmanagement-Protokoll, das benutzt wird.
	        In unserem Fall ist es WPA-PSK.</para>
	    </callout>

	    <callout arearefs="co-ap-wpapsk-pwise">
	      <para>Das <literal>wpa_pairwise</literal> Feld zeigt die
	        zul&auml;ssigen Verschl&uuml;sselungs-Algorithmen
	        des Access Points.  Hier werden beide, TKIP (WPA) und
	        CCMP (WPA2), akzeptiert.  CCMP-Verschl&uuml;sselung ist
	        eine Alternative zu TKIP und sollte wenn m&ouml;glich
	        eingesetzt werden.  TKIP sollte nur da eingesetzt werden,
	        wo kein CCMP m&ouml;glich ist.</para>
	    </callout>
	  </calloutlist>

	  <para>Als n&auml;chstes wird der
	    <application>hostapd</application> gestartet:</para>

	  <screen>&prompt.root; <userinput>/etc/rc.d/hostapd forcestart</userinput></screen>

	<screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable></userinput>
  wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 2290
      inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
      inet6 fe80::211:95ff:fec3:dac%ath0 prefixlen 64 scopeid 0x4
      ether 00:11:95:c3:0d:ac
      media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;hostap&gt;
      status: associated
      ssid freebsdap channel 1 bssid 00:11:95:c3:0d:ac
      authmode WPA2/802.11i privacy MIXED deftxkey 2 TKIP 2:128-bit txpowmax 36 protmode CTS dtimperiod 1 bintval 100</screen>

 	  <para>Der Access Point l&auml;ft nun, die Clients
 	    k&ouml;nnen mit ihm verbunden werden.  Weitere
 	    Informationen finden Sie im
 	    <xref linkend="network-wireless-wpa">.  Es ist m&ouml;glich
 	    zu sehen, welche Stationen mit dem AP verbunden sind.
 	    Dazu geben Sie den Befehl
 	    <command>ifconfig <replaceable>wlan0</replaceable> list sta</command>
 	    ein.</para>
 	</sect4>
      </sect3>

      <sect3>
 	<title>WEP hostbasierender Access Point</title>

 	  <para>Es ist nicht empfehlenswert, einen Access Point mit
 	    WEP zu konfigurieren, da es keine
 	    Authentifikationsmechanismen gibt und WEP leicht zu
 	    knacken ist.  Einige &auml;ltere WLAN-Karten
 	    unterst&uuml;tzen nur WEP als Sicherheitsprotokoll.  F&uuml;r
 	    solche Karten ist es notwendig den AP ohne
 	    Authentifikation, Verschl&uuml;sselung oder mit dem
 	    WEP-Protokoll zu konfigurieren.</para>

 	  <para>Das Wireless-Ger&auml;t kann nun in den hostap-Modus
 	    versetzt werden und mit der korrekten SSID und IP-Adresse
 	    konfiguriert werden:</para>

	<screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> create wlandev <replaceable>ath0</replaceable> wlanmode hostap</userinput>
&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> inet <replaceable>192.168.0.1</replaceable> netmask <replaceable>255.255.255.0</replaceable> \
      ssid <replaceable>freebsdap</replaceable> wepmode on weptxkey <replaceable>3</replaceable> wepkey <replaceable>3:0x3456789012</replaceable> mode 11g</userinput></screen>

	  <itemizedlist>
	    <listitem>
	      <para>Der <literal>weptxkey</literal> gibt an,
	        welcher WEP-Schl&uuml;ssel bei der &Uuml;bertragung
	        benutzt wird.  Hier nutzen wir den 3. Schl&uuml;ssel
	        (die Nummerierung der Schl&uuml;ssel beginnt bei
	        <literal>1</literal>).  Dieses Parameter muss angegeben
	        sein, damit die Daten wirklich verschl&uuml;sselt
	        werden.</para>
	    </listitem>

	    <listitem>
	      <para>Der <literal>wepkey</literal> gibt den
	        gew&auml;hlten WEP-Schl&uuml;ssel an.  Er sollte im
	        folgenden Format <replaceable>index:key</replaceable>
	        vorliegen.  Wenn kein Index vorhanden ist, wird der
	        Schl&uuml;ssel <literal>1</literal> benutzt.  Das bedeutet
	        wir brauchen einen Index, falls wir einen anderen
	        Schl&uuml;ssel als den ersten nutzen wollen.</para>
	    </listitem>
	  </itemizedlist>

	  <para>Benutzen Sie den Befehl <command>ifconfig</command>
	    noch einmal um den Status der
	    <devicename>wlan0</devicename>-Schnittstelle zu sehen:</para>

	<screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable></userinput>
  wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
      ether 00:11:95:c3:0d:ac
      inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;hostap&gt;
      status: running
      ssid freebsdap channel 4 (2427 Mhz 11g) bssid 00:11:95:c3:0d:ac
      country US ecm authmode OPEN privacy ON deftxkey 3 wepkey 3:40-bit
      txpower 21.5 scanvalid 60 protmode CTS wme burst dtimperiod 1 -dfs</screen>

	  <para>Es ist m&ouml;glich, von einem anderen drahtlosen
	    Computer eine Suche nach dem AP zu starten:</para>

	<screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> create wlandev <replaceable>ath0</replaceable></userinput>
&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> up scan</userinput>
SSID            BSSID              CHAN RATE  S:N   INT CAPS
freebsdap       00:11:95:c3:0d:ac    1   54M 22:1   100 EPS</screen>

	  <para>Der Client-Rechner fand den Access Point und kann
	    mit den korrekten Parametern (Schl&uuml;ssel usw.)
	    mit ihm verbunden werden.  Weitere Informationen gibt es in
	    folgendem <xref linkend="network-wireless-wep"></para>
      </sect3>
    </sect2>

    <sect2>
      <title>Benutzung von drahtgebundenen und drahtlosen
	Verbindungen</title>

      <para>Eine Verbindung per Kabel bietet eine bessere Leistung
        und eine h&ouml;here Zuverl&auml;ssigkeit, w&auml;hrend die
        Wireless-Verbindung eine h&ouml;here Flexibilit&auml;t
        und Mobilit&auml;t bietet.  Benutzer von Laptops wollen
        normalerweise beides nutzen und zwischen beiden hin und her
        schalten.</para>

      <para>Unter &os; ist es m&ouml;glich zwei oder mehr
        Netzwerkschnittstellen in einem <quote>failover</quote>-Mode zu
        kombinieren, so dass automatisch die beste verf&uuml;gbare Verbindung
        aus der Gruppe ausgew&auml;hlt wird, sobald der Linkstatus
        wechselt.</para>

      <para>Wir behandeln Link-Aggregation und Failover in dem Kapitel
        <xref linkend="network-aggregation">.  Dort gibt es auch ein
        Beispiel (<xref linkend="networking-lagg-wired-and-wireless">)
        f&uuml;r die Verwendung von sowohl kabelgebundenen wie
        auch drahtlosen Verbindungen.</para>
    </sect2>

    <sect2>
      <title>Problembehandlung</title>

      <para>Die folgenden Auflistung zeigt, wie Sie einige
	h&auml;ufig auftretende Probleme bei der Einrichtung
	Ihres drahtlosen Netzwerks beheben k&ouml;nnen.</para>

      <itemizedlist>
	<listitem>
	  <para>Wird Ihr Access Point bei der Suche nicht gefunden,
	    sollten Sie &uuml;berpr&uuml;fen, ob Sie bei Konfiguration
	    Ihres drahtlosen Ger&auml;ts die Anzahl der Kan&auml;le
	    beschr&auml;nkt haben.</para>
	</listitem>

	<listitem>
	  <para>Wenn Sie sich nicht mit Ihrem Access Point verbinden
	    k&ouml;nnen, sollten Sie &uuml;berpr&uuml;fen, ob die
	    Konfiguration Ihrer Station auch der des Access Points
	    entspricht.  Achten Sie dabei speziell auf die
	    Authentifzierungsmethode und die Sicherheitsprotokolle.
	    Halten Sie Ihre Konfiguration so einfach wie m&ouml;glich.
	    Verwenden Sie ein Sicherheitsprotokoll wie WPA oder WEP,
	    sollten Sie testweise Ihren Access Point auf
	    <emphasis>offene Authentifizierung</emphasis> und
	    <emphasis>keine Sicherheit</emphasis> einstellen.
	    Danach versuchen Sie sich erneut mit Ihren Access Point
	    zu verbinden.</para>
	</listitem>

	<listitem>
	  <para>Nachdem Sie sich mit dem Access Point verbinden
	    k&ouml;nnen, pr&uuml;fen Sie die Sicherheitseinstellungen,
	    beginnend mit einfachen Werkzeugen wie &man.ping.8;.</para>

	  <para>Das Programm <command>wpa_supplicant</command>
	    kann Ihnen bei der Fehlersuche helfen.  Dazu starten
	    Sie es manuell mit der Option <option>-dd</option> und
	    durchsuchen anschlie&szlig;end die Protokollinformationen
	    nach eventuellen Fehlermeldungen.</para>
	</listitem>

	<listitem>
	  <para>Zus&auml;tzlich gibt es auch zahlreiche
	    Low-Level-Debugging-Werkzeuge.  Die Ausgabe von
	    Debugging-Informationen des 802.11 Protocol Support Layers
	    lassen sich mit dem Programm <command>wlandebug</command>
	    (das sich unter
	    <filename>/usr/src/tools/tools/net80211</filename>
	    befindet) aktivieren.  Um beispielsweise w&auml;hrend
	    der Suche nach Access Points und des Aufbaus von
	    802.11-Verbindungen
	    (<foreignphrase>Handshake</foreignphrase>) auftretende
	    Systemmeldungen auf die Konsole auszugeben, verwenden
	    Sie den folgenden Befehl:</para>

	  <screen>&prompt.root; <userinput>wlandebug -i <replaceable>ath0</replaceable> +scan+auth+debug+assoc</userinput>
  net.wlan.0.debug: 0 =&gt; 0xc80000&lt;assoc,auth,scan&gt;</screen>

	  <para>Der 802.11-Layer liefert umfangreiche Statistiken,
	    die Sie mit dem Werkzeug <command>wlanstats</command>
	    abrufen k&ouml;nnen.  Diese Statistiken sollten alle
	    Fehler identifizieren, die im 802.11-Layer auftreten.
	    Beachten Sie aber, dass einige Fehler bereits im
	    darunterliegenden Ger&auml;tetreiber auftreten und
	    daher in diesen Statistiken nicht enthalten sind.  Wie
	    Sie Probleme des Ger&auml;tetreibers identifizieren,
	    entnehmen Sie bitte der Dokumentation Ihres
	    Ger&auml;tetreibers.</para>
	</listitem>
      </itemizedlist>

      <para>K&ouml;nnen Sie Ihr Problem durch diese
	Ma&szlig;nahmen nicht l&ouml;sen, sollten Sie einen
	Problembericht (PR) erstellen und die Ausgabe der weiter
	oben genannten Werkzeuge in den Bericht aufnehmen.</para>
    </sect2>
  </sect1>

  <sect1 id="network-bluetooth">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Pav</firstname>
          <surname>Lucistnik</surname>
          <contrib>Beigetragen von </contrib>
          <affiliation>
            <address><email>pav@FreeBSD.org</email></address>
          </affiliation>
        </author>
      </authorgroup>
    </sect1info>

    <title>Bluetooth</title>

    <indexterm><primary>Bluetooth</primary></indexterm>

    <sect2>
      <title>&Uuml;bersicht</title>

      <para>Bluetooth erm&ouml;glicht die Bildung von pers&ouml;nlichen
	Netzwerken &uuml;ber drahtlose Verbindungen bei einer maximalen
	Reichweite von 10 Metern und operiert im unlizensierten
	2,4-GHz-Band.  Solche Netzwerke werden normalerweise spontan
	gebildet, wenn sich mobile Ger&auml;te, wie Mobiltelefone,
	Handhelds oder Notebooks miteinander verbinden.  Im Gegensatz zu
	Wireless LAN erm&ouml;glicht Bluetooth auch h&ouml;herwertige
	Dienste, wie FTP-&auml;hnliche Dateiserver, Filepushing,
	Sprach&uuml;bertragung, Emulation von seriellen Verbindungen
	und andere mehr.</para>

      <para>Der Bluetooth-Stack von &os; verwendet das
	Netgraph-Framework (&man.netgraph.4;).  Viele
	Bluetooth-USB-Adapter werden durch den &man.ng.ubt.4;-Treiber
	unterst&uuml;tzt.  Auf dem Chip BCM2033
	von Broadcom basierende	Bluetooth-Ger&auml;te werden von den
	Treibern &man.ubtbcmfw.4; sowie &man.ng.ubt.4; unterst&uuml;tzt.
	Die Bluetooth-PC-Card 3CRWB60-A von 3Com verwendet den
	&man.ng.bt3c.4;-Treiber.  Serielle sowie auf UART basierende
	Bluetooth-Ger&auml;te werden von &man.sio.4;, &man.ng.h4.4;
	sowie &man.hcseriald.8;	unterst&uuml;tzt.  Dieses Kapitel
	beschreibt die Verwendung von USB-Bluetooth-Adaptern.</para>
    </sect2>

    <sect2>
      <title>Die Bluetooth-Unterst&uuml;tzung aktivieren</title>

      <para>Bluetooth-Unterst&uuml;tzung ist in der Regel als
	Kernelmodul verf&uuml;gbar.  Damit ein Ger&auml;t funktioniert,
	muss der entsprechende Treiber im Kernel geladen werden:</para>

      <screen>&prompt.root; <userinput>kldload ng_ubt</userinput></screen>

      <para>Ist das Bluetooth-Ger&auml;t beim Systemstart angeschlossen,
        kann das entsprechende Modul auch von
        <filename>/boot/loader.conf</filename> geladen werden:</para>

      <programlisting>ng_ubt_load="YES"</programlisting>

      <para>Schlie&szlig;en Sie Ihren USB-Adapter an, sollte eine
	Meldung &auml;hnlich der folgenden auf der Konsole (oder in
	syslog) erscheinen:</para>

      <screen>ubt0: vendor 0x0a12 product 0x0001, rev 1.10/5.25, addr 2
ubt0: Interface 0 endpoints: interrupt=0x81, bulk-in=0x82, bulk-out=0x2
ubt0: Interface 1 (alt.config 5) endpoints: isoc-in=0x83, isoc-out=0x3,
      wMaxPacketSize=49, nframes=6, buffer size=294</screen>

      <para>Zum Starten und Beenden des Bluetooth-Stacks verwenden Sie
	das Skript <filename>/etc/rc.d/bluetooth</filename>.  Es ist
	empfehlenswert, den Bluetooth-Stack zu beenden, bevor Sie den
	Adapter entfernen.  Selbst wenn Sie dies nicht tun, kommt es
	(normalerweise) zu keinem fatalen Fehler.  Wenn Sie den
	Bluetooth-Stack starten, erhalten Sie eine Meldung &auml;hnlich
	der folgenden:</para>

      <screen>&prompt.root; <userinput>/etc/rc.d/bluetooth start ubt0</userinput>
BD_ADDR: 00:02:72:00:d4:1a
Features: 0xff 0xff 0xf 00 00 00 00 00
&lt;3-Slot&gt; &lt;5-Slot&gt; &lt;Encryption&gt; &lt;Slot offset&gt;
&lt;Timing accuracy&gt; &lt;Switch&gt; &lt;Hold mode&gt; &lt;Sniff mode&gt;
&lt;Park mode&gt; &lt;RSSI&gt; &lt;Channel quality&gt; &lt;SCO link&gt;
&lt;HV2 packets&gt; &lt;HV3 packets&gt; &lt;u-law log&gt; &lt;A-law log&gt; &lt;CVSD&gt;
&lt;Paging scheme&gt; &lt;Power control&gt; &lt;Transparent SCO data&gt;
Max. ACL packet size: 192 bytes
Number of ACL packets: 8
Max. SCO packet size: 64 bytes
Number of SCO packets: 8</screen>

    </sect2>

    <indexterm><primary>HCI</primary></indexterm>

    <sect2>
      <title>Das Host Controller Interface (HCI)</title>

      <para>Das <foreignphrase>Host Controller Interface</foreignphrase>
	(HCI) bietet eine Befehlsschnittstelle zum Basisbandcontroller
	und Linkmanager, sowie Zugriff auf den Hardwarestatus und die
	Kontrollregister.  Dadurch wird ein einheitlicher Zugriff auf
	die F&auml;higkeiten des Bluetooth-Basisbands m&ouml;glich.  Die
	HCI-Layer des Rechners tauschen Daten und Befehle mit der
	HCI-Firmware der Bluetooth-Ger&auml;te aus.  &Uuml;ber den
	Host Controller Transport Layer-Treiber (also den physikalischen
	Bus) k&ouml;nnen beide HCI-Layer miteinander
	kommunizieren.</para>

      <para>Eine einzelne Netgraph-Ger&auml;tedatei vom Typ
	<emphasis>hci</emphasis> wird f&uuml;r ein einzelnes
	Bluetooth-Ger&auml;t erzeugt.  Die HCI-Ger&auml;tedatei ist
	normalerweise mit der Bluetooth-Ger&auml;tetreiberdatei
	(downstream) sowie der L2CAP-Ger&auml;tedatei (upstream)
	verbunden.  Alle HCI-Operationen m&uuml;ssen &uuml;ber die
	HCI-Ger&auml;tedatei und nicht &uuml;ber die Treiberdatei
	erfolgen.  Der Standardname f&uuml;r die HCI-Ger&auml;tedatei
	(die in &man.ng.hci.4; beschrieben wird) lautet
	<quote>devicehci</quote>.</para>

      <para>Eine der wichtigsten Aufgaben ist das Auffinden von sich
	in Reichweite befindenden Bluetooth-Ger&auml;ten.  Diese
	Funktion wird als <emphasis>inquiry</emphasis> bezeichnet.
	Inquiry sowie andere mit HCI in Verbindung stehende Funktionen
	werden von &man.hccontrol.8; zur Verf&uuml;gung gestellt.  Das
	folgende Beispiel zeigt, wie man herausfindet, welche
	Bluetooth-Ger&auml;te sich in Reichweite befinden.  Eine solche
	Abfrage dauert nur wenige Sekunden.  Beachten Sie, dass ein
	Ger&auml;t nur dann antwortet, wenn es sich im Modus
	<emphasis>discoverable</emphasis> befindet.</para>

      <screen>&prompt.user; <userinput>hccontrol -n ubt0hci inquiry</userinput>
Inquiry result, num_responses=1
Inquiry result #0
       BD_ADDR: 00:80:37:29:19:a4
       Page Scan Rep. Mode: 0x1
       Page Scan Period Mode: 00
       Page Scan Mode: 00
       Class: 52:02:04
       Clock offset: 0x78ef
Inquiry complete. Status: No error [00]</screen>

      <para><literal>BD_ADDR</literal> stellt, &auml;hnlich der
	MAC-Adresse einer Netzwerkkarte, die eindeutige Adresse eines
	Bluetooth-Ger&auml;tes dar.  Diese Adresse ist f&uuml;r die
	Kommunikation mit dem Ger&auml;t n&ouml;tig.  Es ist aber auch
	m&ouml;glich, BD_ADDR einen Klartextnamen zuzuweisen.  Die
	Datei <filename>/etc/bluetooth/hosts</filename> enth&auml;lt
	Informationen &uuml;ber die bekannten Bluetooth-Rechner.  Das
	folgende Beispiel zeigt, wie man den Klartextnamen eines
	entfernten Ger&auml;ts in Erfahrung bringen kann:</para>

      <screen>&prompt.user; <userinput>hccontrol -n ubt0hci remote_name_request 00:80:37:29:19:a4</userinput>
BD_ADDR: 00:80:37:29:19:a4
Name: Pav's T39</screen>

      <para>Wenn Sie ein entferntes Bluetooth-Ger&auml;t abfragen, wird
	dieses Ihren Rechner unter dem Namen
	<quote>your.host.name (ubt0)</quote> finden.  Dieser Name kann
	aber jederzeit ge&auml;ndert werden.</para>

      <para>Bluetooth erm&ouml;glicht Punkt-zu-Punkt-Verbindungen (an
	denen nur zwei Bluetooth-Ger&auml;te beteiligt sind), aber auch
	Punkt-zu-Multipunkt-Verbindungen, bei denen eine Verbindung von
	mehreren Bluetooth-Ger&auml;ten gemeinsam genutzt wird.  Das
	folgende Beispiel zeigt, wie man die aktiven
	Basisbandverbindungen des lokalen Ger&auml;tes anzeigen kann:</para>

      <screen>&prompt.user; <userinput>hccontrol -n ubt0hci read_connection_list</userinput>
Remote BD_ADDR    Handle Type Mode Role Encrypt Pending Queue State
00:80:37:29:19:a4     41  ACL    0 MAST    NONE       0     0 OPEN</screen>

      <para>Ein <emphasis>connection handle</emphasis> ist f&uuml;r die
	Beendigung einer Basisbandverbindung n&uuml;tzlich.  Im
	Normalfall werden inaktive Verbindungen aber automatisch vom
	Bluetooth-Stack getrennt.</para>

      <screen>&prompt.root; <userinput>hccontrol -n ubt0hci disconnect 41</userinput>
Connection handle: 41
Reason: Connection terminated by local host [0x16]</screen>

      <para>Rufen Sie <command>hccontrol help</command> auf, wenn Sie
	eine komplette Liste aller verf&uuml;gbaren HCI-Befehle
	ben&ouml;tigen.  Die meisten dieser Befehle m&uuml;ssen nicht
	als <username>root</username> ausgef&uuml;hrt werden.</para>
    </sect2>

    <indexterm><primary>L2CAP</primary></indexterm>

    <sect2>
      <title>Das Logical Link Control and Adaptation Protocol (L2CAP)</title>

      <para>Das <foreignphrase>Logical Link Control and Adaptation
	Protocol</foreignphrase> (L2CAP) bietet
	h&ouml;herwertigen Protokollen verbindungsorientierte und
	verbindungslose Datendienste an.  Dazu geh&ouml;ren auch
	Protokollmultiplexing, Segmentierung und Reassemblierung.
	L2CAP erlaubt h&ouml;herwertigen Protokollen und Programmen den
	Versand und Empfang von L2CAP-Datenpaketen mit einer L&auml;nge
	von bis zu 64 Kilobytes.</para>

      <para>L2CAP arbeitet <emphasis>kanal</emphasis>basiert.  Ein
	Kanal ist eine logische Verbindung innerhalb einer
	Basisbandverbindung.  Jeder Kanal ist dabei an ein einziges
	Protokoll gebunden.  Mehrere Ger&auml;te k&ouml;nnen an das
	gleiche Protokoll gebunden sein, es ist	aber nicht m&ouml;glich,
	einen Kanal an mehrere Protokolle zu binden.  Jedes &uuml;ber
	einen Kanal ankommende L2CAP-Paket wird an das entsprechende
	h&ouml;herwertige Protokoll weitergeleitet.  Mehrere Kan&auml;le
	k&ouml;nnen sich die gleiche Basisbandverbindung teilen.</para>

      <para>Eine einzelne Netgraph-Ger&auml;tedatei vom Typ
	<emphasis>l2cap</emphasis> wird f&uuml;r ein einzelnes
	Bluetooth-Ger&auml;t erzeugt.  Die L2CAP-Ger&auml;tedatei ist
	normalerweise mit der Bluetooth-HCI-Ger&auml;tedatei
	(downstream) sowie der Bluetooth-Socket-Ger&auml;tedatei
	(upstream) verbunden.  Der Standardname f&uuml;r die
	L2CAP-Ger&auml;tedatei, die in &man.ng.l2cap.4; beschrieben
	wird, lautet <quote>devicel2cap</quote>.</para>

      <para>Ein n&uuml;tzlicher Befehl zum Anpingen von anderen
	Ger&auml;ten ist &man.l2ping.8;.  Einige Bluetooth-Ger&auml;te
	senden allerdings nicht alle erhaltenen Daten zur&uuml;ck.  Die
	Ausgabe <literal>0 bytes</literal> ist also kein Fehler:</para>

      <screen>&prompt.root; <userinput>l2ping -a 00:80:37:29:19:a4</userinput>
0 bytes from 0:80:37:29:19:a4 seq_no=0 time=48.633 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=1 time=37.551 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=2 time=28.324 ms result=0
0 bytes from 0:80:37:29:19:a4 seq_no=3 time=46.150 ms result=0</screen>

      <para>Das Programm &man.l2control.8; liefert Informationen
	&uuml;ber L2CAP-Dateien.  Das folgende Beispiel zeigt, wie man
	die Liste der logischen Verbindungen (Kan&auml;le) sowie die
	Liste der Basisbandverbindungen abfragen kann:</para>

      <screen>&prompt.user; <userinput>l2control -a 00:02:72:00:d4:1a read_channel_list</userinput>
L2CAP channels:
Remote BD_ADDR     SCID/ DCID   PSM  IMTU/ OMTU State
00:07:e0:00:0b:ca    66/   64     3   132/  672 OPEN
&prompt.user; <userinput>l2control -a 00:02:72:00:d4:1a read_connection_list</userinput>
L2CAP connections:
Remote BD_ADDR    Handle Flags Pending State
00:07:e0:00:0b:ca     41 O           0 OPEN</screen>

      <para>&man.btsockstat.1; ist ein weiteres Diagnoseprogramm.  Es
	funktioniert analog zu &man.netstat.1;, arbeitet aber mit
	Bluetooth-Datenstrukturen.  Das folgende Beispiel zeigt die
	gleiche Liste der logischen Verbindungen wie &man.l2control.8;
	im vorherigen Beispiel.</para>

      <screen>&prompt.user; <userinput>btsockstat</userinput>
Active L2CAP sockets
PCB      Recv-Q Send-Q Local address/PSM       Foreign address   CID   State
c2afe900      0      0 00:02:72:00:d4:1a/3     00:07:e0:00:0b:ca 66    OPEN
Active RFCOMM sessions
L2PCB    PCB      Flag MTU   Out-Q DLCs State
c2afe900 c2b53380 1    127   0     Yes  OPEN
Active RFCOMM sockets
PCB      Recv-Q Send-Q Local address     Foreign address   Chan DLCI State
c2e8bc80      0    250 00:02:72:00:d4:1a 00:07:e0:00:0b:ca 3    6    OPEN</screen>

    </sect2>

    <sect2>
      <title>Das RFCOMM-Protokoll</title>

      <indexterm><primary>RFCOMM</primary></indexterm>

      <para>Das RFCOMM-Protokoll emuliert serielle Verbindungen
	&uuml;ber das L2CAP-Protokoll.  Es basiert auf dem ETSI-Standard
	TS 07.10.  Bei RFCOMM handelt es sich um ein einfaches
	Transportprotokoll, das um Funktionen zur Emulation der
	9poligen Schaltkreise von mit RS-232 (EIATIA-232-E) kompatiblen
	seriellen Ports erg&auml;nzt wurde.  RFCOMM erlaubt bis zu 60
	simultane Verbindungen (RFCOMM-Kan&auml;e) zwischen zwei
	Bluetooth-Ger&auml;ten.</para>

      <para>Eine RFCOMM-Kommunikation besteht aus zwei Anwendungen (den
	Kommunikationsendpunkten), die &uuml;ber das
	Kommunikationssegment miteinander verbunden sind.  RFCOMM
	unterst&uuml;tzt Anwendungen, die auf serielle Ports angewiesen
	sind.  Das Kommunikationssegment entspricht der (direkten)
	Bluetooth-Verbindung zwischen den beiden Ger&auml;ten.</para>

      <para>RFCOMM k&uuml;mmert sich um die direkte Verbindung von zwei
	Ger&auml;ten, oder um die Verbindung zwischen einem Ger&auml;t
	und einem Modem (Netzwerkverbindung).  RFCOMM unterst&uuml;tzt
	auch andere Konfigurationen.  Ein Beispiel daf&uuml;r sind
	Module, die drahtlose Bluetooth-Ger&auml;te mit einer
	verkabelten Schnittstelle verbinden k&ouml;nnen.</para>

      <para>Unter &os; wurde das RFCOMM-Protokoll im Bluetooth Socket-Layer
	implementiert.</para>
    </sect2>

    <indexterm><primary>Pairing</primary></indexterm>

    <sect2>
      <title>Erstmaliger Verbindungsaufbau zwischen zwei
	Bluetooth-Ger&auml;ten (<foreignphrase>Pairing</foreignphrase>)
      </title>

      <para>In der Voreinstellung nutzt Bluetooth keine
	Authentifizierung, daher kann sich jedes Bluetoothger&auml;t mit
	jedem anderen Ger&auml;t verbinden.  Ein Bluetoothger&auml;t
	(beispielsweise ein Mobiltelefon) kann jedoch f&uuml;r einen
	bestimmten Dienst (etwa eine Einw&auml;hlverbindung) eine
	Authentifizierung anfordern.  Bluetooth verwendet zu diesem
	Zweck <emphasis>PIN-Codes</emphasis>.  Ein PIN-Code ist ein
	maximal 16 Zeichen langer ASCII-String.  Damit eine Verbindung
	zustande kommt, muss auf beiden Ger&auml;ten der gleiche
	PIN-Code verwendet werden.  Nachdem der Code eingegeben wurde,
	erzeugen beide Ger&auml;te einen <emphasis>link key</emphasis>,
	der auf den Ger&auml;ten gespeichert wird.  Beim n&auml;chsten
	Verbindungsaufbau wird der zuvor erzeugte Link Key verwendet.
	Diesen Vorgang bezeichnet man als
	<foreignphrase>Pairing</foreignphrase>.  Geht der Link Key auf
	einem Ger&auml;t verloren, muss das Pairing wiederholt
	werden.</para>

      <para>Der &man.hcsecd.8;-Daemon verarbeitet alle
	Bluetooth-Authentifzierungsanforderungen und wird &uuml;ber die
	Datei <filename>/etc/bluetooth/hcsecd.conf</filename>
	konfiguriert.  Der folgende Ausschnitt dieser Datei zeigt die
	Konfiguration f&uuml;r ein Mobiltelefon, das den PIN-Code
	<quote>1234</quote> verwendet:</para>

      <programlisting>device {
        bdaddr  00:80:37:29:19:a4;
        name    "Pav's T39";
        key     nokey;
        pin     "1234";
      }</programlisting>

      <para>Von der L&auml;nge abgesehen, unterliegen PIN-Codes keinen
	Einschr&auml;nkungen.  Einige Ger&auml;te, beispielsweise
	Bluetooth-Headsets, haben einen festen PIN-Code eingebaut.  Die
	Option <option>-d</option> sorgt daf&uuml;r, dass der
	&man.hcsecd.8;-Daemon im Vordergrund l&auml;uft.  Dadurch kann
	der Ablauf einfach verfolgt werden.  Stellen Sie das entfernte
	Ger&auml;t auf <foreignphrase>receive pairing</foreignphrase>
	und initiieren Sie die Bluetoothverbindung auf dem entfernten
	Ger&auml;t.  Sie erhalten die Meldung, dass Pairing akzeptiert
	wurde und der PIN-Code ben&ouml;tigt wird.  Geben Sie den
	gleichen PIN-Code ein, den Sie in
	<filename>hcsecd.conf</filename> festgelegt haben.  Ihr Computer
	und das entfernte Ger&auml;t sind nun miteinander verbunden.
	Alternativ k&ouml;nnen Sie das Pairing auch auf dem entfernten
	Ger&auml;t initiieren.</para>

      <para><application>hcsecd</application> kann durch das Einf&uuml;gen
	der folgenden Zeile in <filename>/etc/rc.conf</filename>
	beim Systemstart automatisch aktiviert werden:</para>

      <programlisting>hcsecd_enable="YES"</programlisting>

      <para>Es folgt nun eine beispielhafte Ausgabe
	des <application>hcsecd</application>-Daemons:</para>

<programlisting>hcsecd[16484]: Got Link_Key_Request event from 'ubt0hci', remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name 'Pav's T39', link key doesn't exist
hcsecd[16484]: Sending Link_Key_Negative_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Got PIN_Code_Request event from 'ubt0hci', remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name 'Pav's T39', PIN code exists
hcsecd[16484]: Sending PIN_Code_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4</programlisting>

    </sect2>

    <indexterm><primary>SDP</primary></indexterm>

    <sect2>
      <title>Das Service Discovery Protocol (SDP)</title>

      <para>Das <foreignphrase>Service Discovery Protocol</foreignphrase>
	(SDP) erlaubt es Clientanwendungen, von Serveranwendungen
	angebotene Dienste sowie deren Eigenschaften abzufragen.  Zu
	diesen Eigenschaften geh&ouml;ren die Art oder die Klasse der
	angebotenen Dienste sowie der Mechanismus oder das Protokoll,
	die zur Nutzung des Dienstes notwendig sind.</para>

      <para>SDP erm&ouml;glicht Verbindungen zwischen einem SDP-Server
	und einem SDP-Client.  Der Server enth&auml;lt eine Liste mit
	den Eigenschaften der vom Server angebotenen Dienste.  Jeder
	Eintrag beschreibt jeweils einen einzigen Serverdienst.  Ein
	Client kann diese Informationen durch eine SDP-Anforderung
	vom SDP-Server beziehen.  Wenn der Client oder eine Anwendung
	des Clients einen Dienst nutzen will, muss eine seperate
	Verbindung mit dem Dienstanbieter aufgebaut werden.  SDP bietet
	einen Mechanismus zum Auffinden von Diensten und deren
	Eigenschaften an, es bietet aber keine Mechanismen zur Verwendung
	dieser Dienste.</para>

      <para>Normalerweise sucht ein SDP-Client nur nach Diensten, die
	bestimmte geforderte Eigenschaften erf&uuml;llen.  Es ist aber
	auch m&ouml;glich, anhand der Dienstbeschreibungen eine
	allgemeine Suche nach den von einem Server angebotenen Diensten
	durchzuf&uuml;hren.  Diesen Vorgang bezeichnet man als
        <foreignphrase>Browsing</foreignphrase>.</para>

      <para>Der Bluetooth-SDP-Server &man.sdpd.8; und der
	Kommandozeilenclient &man.sdpcontrol.8; sind bereits in der
	Standardinstallation von &os; enthalten.  Das folgende Beispiel
	zeigt, wie eine SDP-Abfrage durchgef&uuml;hrt wird:</para>

      <screen>&prompt.user; <userinput>sdpcontrol -a 00:01:03:fc:6e:ec browse</userinput>
Record Handle: 00000000
Service Class ID List:
        Service Discovery Server (0x1000)
Protocol Descriptor List:
        L2CAP (0x0100)
                Protocol specific parameter #1: u/int/uuid16 1
                Protocol specific parameter #2: u/int/uuid16 1

Record Handle: 0x00000001
Service Class ID List:
        Browse Group Descriptor (0x1001)

Record Handle: 0x00000002
Service Class ID List:
        LAN Access Using PPP (0x1102)
Protocol Descriptor List:
        L2CAP (0x0100)
        RFCOMM (0x0003)
                Protocol specific parameter #1: u/int8/bool 1
Bluetooth Profile Descriptor List:
        LAN Access Using PPP (0x1102) ver. 1.0
</screen>

      <para>... und so weiter.  Beachten Sie, dass jeder Dienst eine
	Liste seiner Eigenschaften (etwa den RFCOMM-Kanal)
	zur&uuml;ckgibt.  Je nach dem, welche Dienste Sie
	ben&ouml;tigen, sollten Sie sich einige dieser Eigenschaften
	notieren.  Einige Bluetooth-Implementationen unterst&uuml;tzen
	kein <foreignphrase>Service Browsing</foreignphrase> und geben
	daher eine leere Liste zur&uuml;ck.  Ist dies der Fall, ist es
	dennoch m&ouml;glich, nach einem bestimmten Dienst zu suchen.
	Das folgende Beispiel demonstriert die Suche nach dem
	OBEX Object Push (OPUSH) Dienst:</para>

      <screen>&prompt.user; <userinput>sdpcontrol -a 00:01:03:fc:6e:ec search OPUSH</userinput></screen>

      <para>Unter &os; ist es die Aufgabe des &man.sdpd.8;-Servers,
	Bluetooth-Clients verschiedene Dienste anzubieten.  Sie
	k&ouml;nnen diesen Server durch das Einf&uuml;gen der folgenden
	Zeile in die Datei <filename>/etc/rc.conf</filename>
	aktivieren:</para>

      <programlisting>sdpd_enable="YES"</programlisting>

      <para>Nun kann der <application>sdpd</application>-Daemon durch
	folgene Eingabe gestartet werden:</para>

      <screen>&prompt.root; <userinput>/etc/rc.d/sdpd start</userinput></screen>

      <para>Der lokale Server, der den entfernten Clients
	Bluetooth-Dienste anbieten soll, bindet diese Dienste an den
	lokalen SDP-Daemon.  Ein Beispiel f&uuml;r eine solche
	Anwendung ist &man.rfcomm.pppd.8;.  Einmal gestartet, wird der
	Bluetooth-LAN-Dienst an den lokalen SDP-Daemon gebunden.</para>

      <para>Die Liste der vorhandenen Dienste, die am lokalen SDP-Server
	registriert sind, l&auml;sst sich durch eine SDP-Abfrage
	&uuml;ber einen lokalen Kontrollkanal abfragen:</para>

      <screen>&prompt.root; <userinput>sdpcontrol -l browse</userinput></screen>

    </sect2>

    <sect2>
      <title>Einwahlverbindungen (Dial-Up Networking (DUN)) oder
	Netzwerkverbindungen mit PPP (LAN)-Profilen einrichten</title>

      <para>Das
	<foreignphrase>Dial-Up Networking (DUN)</foreignphrase>-Profil
	wird vor allem f&uuml;r Modems und Mobiltelefone verwendet.
	Dieses Profil erm&ouml;glicht folgende Szenarien:</para>

      <itemizedlist>
        <listitem><para>Die Verwendung eines Mobiltelefons oder eines
	  Modems durch einen Computer als drahtloses Modem, um sich
	  &uuml;ber einen Einwahlprovider mit dem Internet zu verbinden
	  oder andere Einwahldienste zu benutzen.</para>
	</listitem>

        <listitem><para>Die Verwendung eines Mobiltelefons oder eines
	  Modems durch einen Computers, um auf Datenabfragen zu
	  reagieren.</para>
	</listitem>
      </itemizedlist>

      <para>Der Zugriff auf ein Netzwerk &uuml;ber das PPP (LAN)-Profil
	kann in folgenden Situationen verwendet werden:</para>

      <itemizedlist>
        <listitem><para>Den LAN-Zugriff f&uuml;r ein einzelnes
	  Bluetooth-Ger&auml;t</para>
	</listitem>

        <listitem><para>Den LAN-Zugriff f&uuml;r mehrere
	  Bluetooth-Ger&auml;te</para>
	</listitem>

        <listitem><para>Eine PC-zu-PC-Verbindung (unter Verwendung
	  einer PPP-Verbindung &uuml;ber eine emulierte serielle
	  Verbindung)</para>
	</listitem>
      </itemizedlist>

      <para>Beide Profile werden unter &os; durch &man.ppp.8; sowie
	&man.rfcomm.pppd.8; implementiert - einem Wrapper, der
	RFCOMM Bluetooth-Verbindungen unter PPP nutzbar macht.  Bevor
	ein Profil verwendet werden kann, muss ein neuer PPP-Abschnitt
	in <filename>/etc/ppp/ppp.conf</filename> erzeugt werden.
	Beispielkonfigurationen zu diesem Thema finden Sie in
	&man.rfcomm.pppd.8;.</para>

      <para>Im folgenden Beispiel verwenden wir &man.rfcomm.pppd.8;, um
	eine RFCOMM-Verbindung zu einem entfernten Ger&auml;t mit der
	<literal>BD_ADDR 00:80:37:29:19:a4</literal> auf dem
	RFCOMM-Kanal <literal>DUN</literal> aufzubauen.  Die aktuelle
	RFCOMM-Kanalnummer erhalten Sie vom entfernten Ger&auml;t
	&uuml;ber SDP.  Es ist auch m&ouml;glich, manuell einen
	RFCOMM-Kanal festzulegen.  In diesem Fall f&uuml;hrt
	&man.rfcomm.pppd.8; keine SDP-Abfrage durch.  Verwenden Sie
	&man.sdpcontrol.8;, um die RFCOMM-Kan&auml;le des entfernten
	Ger&auml;ts herauszufinden.</para>

      <screen>&prompt.root; <userinput>rfcomm_pppd -a 00:80:37:29:19:a4 -c -C dun -l rfcomm-dialup</userinput></screen>

      <para>Der &man.sdpd.8;-Server muss laufen, damit ein Netzzugriff
	mit dem PPP (LAN)-Profil m&ouml;glich ist.  Au&szlig;erdem muss
	f&uuml;r den LAN-Client ein neuer Eintrag in
	<filename>/etc/ppp/ppp.conf</filename> erzeugt werden.
	Beispielkonfigurationen zu diesem Thema finden Sie in
	&man.rfcomm.pppd.8;.  Danach starten Sie den RFCOMM PPP-Server
	&uuml;ber eine g&uuml;ltige RFCOMM-Kanalnummer.  Der
	RFCOMM PPP-Server bindet dadurch den Bluetooth-LAN-Dienst an den
	lokalen SDP-Daemon.  Das folgende Beispiel zeigt Ihnen, wie man
	den RFCOMM PPP-Server startet.</para>

      <screen>&prompt.root; <userinput>rfcomm_pppd -s -C 7 -l rfcomm-server</userinput></screen>

    </sect2>

    <indexterm><primary>OBEX</primary></indexterm>

    <sect2>
      <title>Das Profil OBEX-Push (OPUSH)</title>

      <para>OBEX ist ein h&auml;ufig verwendetes Protokoll f&uuml;r den
	Dateitransfer zwischen Mobilger&auml;ten.  Sein Hauptzweck ist
	die Kommunikation &uuml;ber die Infrarotschnittstelle.  Es dient
	daher zum Datentransfer zwischen Notebooks oder PDAs sowie zum
	Austausch von Visitenkarten oder Kalendereintr&auml;gen zwischen
	Mobiltelefonen und anderen Ger&auml;ten mit PIM-Funktionen.</para>

      <para>Server und Client von OBEX werden durch das Softwarepaket
	<application>obexapp</application> bereitgestellt, das als Port
	<filename role="package">comms/obexapp</filename> verf&uuml;gbar
	ist.</para>

      <para>Mit dem OBEX-Client werden Objekte zum OBEX-Server geschickt
	oder angefordert.  Ein Objekt kann etwa eine Visitenkarte oder
	ein Termin sein.  Der OBEX-Client fordert &uuml;ber SDP die
	Nummer des RFCOMM-Kanals vom entfernten Ger&auml;t an.  Dies
	kann auch durch die Verwendung des Servicenamens anstelle der
	RFCOMM-Kanalnummer erfolgen.  Folgende Dienste werden
	unterst&uuml;tzt:  IrMC, FTRN und OPUSH.  Es ist m&ouml;glich,
	den RFCOMM-Kanal als Nummer anzugeben.  Es folgt nun ein
	Beispiel f&uuml;r eine OBEX-Sitzung, bei der ein
	Informationsobjekt vom Mobiltelefon angefordert und ein neues
	Objekt (hier eine Visitenkarte) an das Telefonbuch des
	Mobiltelefons geschickt wird:</para>

      <screen>&prompt.user; <userinput>obexapp -a 00:80:37:29:19:a4 -C IrMC</userinput>
obex&gt; get telecom/devinfo.txt
Success, response: OK, Success (0x20)
obex&gt; put new.vcf
Success, response: OK, Success (0x20)
obex&gt; di
Success, response: OK, Success (0x20)</screen>

      <para>Um OBEX-Push-Dienste anbieten zu k&ouml;nnen, muss der
	<application>sdpd</application>-Server gestartet sein.  Ein
	Wurzelverzeichnis, in dem alle ankommenden Objekt gespeichert
	werden, muss zus&auml;tzlich angelegt werden.  In der
	Voreinstellung ist dies <filename>/var/spool/obex</filename>.
	Starten Sie den OBEX-Server mit einer g&uuml;ltigen Kanalnummer.
	Der OBEX-Server registriert nun den OBEX-Push-Dienst mit dem
	lokalen SDP-Daemon.  Um den OBEX-Server zu starten, geben Sie
	Folgendes ein:</para>

      <screen>&prompt.root; <userinput>obexapp -s -C 10</userinput></screen>

    </sect2>

    <sect2>
      <title>Das Profil Serial-Port (SPP)</title>

      <para>Durch dieses Profil k&ouml;nnen Bluetooth-Ger&auml;te RS232-
	(oder damit kompatible) serielle Kabelverbindungen emulieren.
	Anwendungen sind dadurch in der Lage, &uuml;ber eine virtuelle
	serielle Verbindung Bluetooth als Ersatz f&uuml;r eine
	Kabelverbindung zu nutzen.</para>

      <para>Das Profil Serial-Port wird durch &man.rfcomm.sppd.1;
	verwirklicht.  Pseudo-tty wird hier als virtuelle serielle
	Verbindung verwendet.  Das folgende Beispiel zeigt, wie man sich
	mit einem entfernten Serial-Port-Dienst verbindet.  Beachten
	Sie, dass Sie den RFCOMM-Kanal nicht angeben m&uuml;ssen, da
	&man.rfcomm.sppd.1; diesen &uuml;ber SDP vom entfernten
	Ger&auml;t abfragen kann.  Wenn Sie dies nicht wollen,
	k&ouml;nnen Sie einen RFCOMM-Kanal auch manuell festlegen.</para>

      <screen>&prompt.root; <userinput>rfcomm_sppd -a 00:07:E0:00:0B:CA -t /dev/ttyp6</userinput>
rfcomm_sppd[94692]: Starting on /dev/ttyp6...</screen>

      <para>Sobald die Verbindung hergestellt ist, kann pseudo-tty als
        serieller Port verwenden werden.</para>

      <screen>&prompt.root; <userinput>cu -l ttyp6</userinput></screen>
    </sect2>

    <sect2>
      <title>Problembehandlung</title>

      <sect3>
        <title>Ein entferntes Ger&auml;t kann keine Verbindung
	  aufbauen</title>

	<para>Einige &auml;ltere Bluetooth-Ger&auml;te unterst&uuml;tzen
	  keinen Rollentausch.  Wenn &os; eine neue Verbindung
	  akzeptiert, wird versucht, die Rolle zu tauschen, um zum
	  Master zu werden.  Ger&auml;te, die dies nicht
	  unterst&uuml;tzen, k&ouml;nnen keine Verbindung aufbauen.
	  Beachten Sie, dass der Rollentausch ausgef&uuml;hrt wird,
	  sobald eine neue Verbindung aufgebaut wird, daher ist es
	  nicht m&ouml;glich, das entfernte Ger&auml;t zu fragen, ob es
	  den Rollentausch unterst&uuml;tzt.  Dieses Verhalten von &os;
	  kann aber durch eine HCI-Option ge&auml;ndert werden:</para>

        <screen>&prompt.root; <userinput>hccontrol -n ubt0hci write_node_role_switch 0</userinput></screen>

      </sect3>

      <sect3>
        <title>Wo finde ich genaue Informationen dar&uuml;ber, was
	  schiefgelaufen ist?</title>

	<para>Verwenden Sie <application>hcidump</application>,
	  das Sie &uuml;ber den Port <filename
	  role="package">comms/hcidump</filename> installieren
	  k&ouml;nnen.  <application>hcidump</application> hat
	  &Auml;hnlichkeiten mit &man.tcpdump.1;.  Es dient zur Anzeige
	  der Bluetooth-Pakete in einem Terminal oder zur Speicherung
	  der Pakete in einer Datei (Dump).</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="network-bridging">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Andrew</firstname>
	  <surname>Thompson</surname>
	  <contrib>Geschrieben von </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title>LAN-Kopplung mit einer Bridge</title>

    <sect2>
      <title>Einf&uuml;hrung</title>

      <indexterm><primary>Subnetz</primary></indexterm>
      <indexterm><primary>Bridge</primary></indexterm>

      <para>Manchmal ist es n&uuml;tzlich, ein physikalisches Netzwerk
	(wie ein Ethernetsegment) in zwei separate Netzwerke
	aufzuteilen, ohne gleich IP-Subnetze zu erzeugen, die &uuml;ber
	einen Router miteinander verbunden sind.  Ein Ger&auml;t, das
	zwei Netze auf diese Weise verbindet, wird als
	<emphasis>Bridge</emphasis> bezeichnet.  Jedes FreeBSD-System
	mit zwei Netzwerkkarten kann als Bridge fungieren.</para>

      <para>Die Bridge arbeitet, indem sie die MAC Layeradressen
	(Ethernet Adressen) der Ger&auml;te in ihren
	Netzwerksegmenten lernt.  Der Verkehr wird nur dann zwischen
	zwei Segmenten weitergeleitet, wenn sich Sender und
	Empf&auml;nger in verschiedenen Netzwerksegmenten
	befinden.</para>

      <para>In vielerlei Hinsicht entspricht eine Bridge daher einem
        Ethernet-Switch mit sehr wenigen Ports.</para>
    </sect2>

    <sect2>
      <title>Situationen, in denen <emphasis>Bridging</emphasis>
	angebracht ist</title>

      <para>Es gibt zahlreiche Situationen, in denen der Einsatz
	einer Bridge sinnvoll ist:</para>

      <sect3>
	<title>Verbinden von Netzwerken</title>

	<para>Die Hauptaufgabe einer Bridge ist die Verbindung von zwei
	  oder mehreren Netzwerksegmenten zu einem gemeinsamen Netzwerk.
	  Es ist oft sinnvoller, eine hostbasierte Bridge anstelle
	  normaler Netzwerkkomponenten (wie Kabelverbindungen),
	  Firewalls oder Pseudonetzwerken &uuml;ber die
	  Schnittstelle einer virtuellen Maschine einzusetzen.
	  Eine Bridge kann au&szlig;erdem ein drahtloses Ger&auml;t mit
	  einem Kabelnetzwerk verbinden.  Diese F&auml;higkeit der
	  Bridge wird als <foreignphrase>HostAP-Modus</foreignphrase>
	  bezeichnet.  Die Bridge agiert in diesem Fall als
	  Access Point f&uuml;r das drahtlose Ger&auml;t.</para>
      </sect3>

      <sect3>
	<title>Filtering/Traffic Shaping Firewall</title>

	<indexterm><primary>Firewall</primary></indexterm>
	<indexterm><primary>NAT</primary></indexterm>

	<para>H&auml;ufig kommt es vor, dass Firewallfunktionen
	  ben&ouml;tigt werden, ohne dass Routing oder
	  <foreignphrase>Network Adress Translation</foreignphrase>
	  (NAT) verwendet werden soll.</para>

	<para>Ein Beispiel daf&uuml;r w&auml;re ein kleines Unternehmen,
	  das &uuml;ber DSL oder ISDN an seinen ISP angebunden ist.  Es
	  verf&uuml;gt &uuml;ber 13 weltweit erreichbare IP-Adressen,
	  sein Netzwerk besteht aus 10 Rechnern.  In dieser Situation
	  ist der Einsatz von Subnetzen sowie einer routerbasierten
	  Firewall schwierig.</para>

	<indexterm><primary>Router</primary></indexterm>
	<indexterm><primary>DSL</primary></indexterm>
	<indexterm><primary>ISDN</primary></indexterm>

	<para>Eine brigdebasierte Firewall kann konfiguriert und in den
	  ISDN/DSL-Downstreampfad ihres Routers eingebunden werden, ohne
	  dass Sie sich um IP-Adressen k&uuml;mmern m&uuml;ssen.</para>
      </sect3>

      <sect3>
	<title>Netzwerk&uuml;berwachung</title>

	<para>Eine Bridge kann zwei Netzwerksegmente miteinander
	  verbinden und danach alle Ethernet-Rahmen &uuml;berpr&uuml;fen,
	  die zwischen den beiden Netzwerksegmenten ausgetauscht werden.
	  Dazu verwendet man entweder &man.bpf.4;/&man.tcpdump.1; auf
	  dem Netzger&auml;t der Bridge oder schickt Kopien aller
	  Rahmen an ein zus&auml;tzliches Netzger&auml;t (den sogenannten
	  <foreignphrase>Span Port</foreignphrase>).</para>
      </sect3>

      <sect3>
	<title>Layer&nbsp;2-VPN</title>

	<para>Zwei Ethernetnetzwerke k&ouml;nnen &uuml;ber einen IP-Link
	  miteinander verbunden werden, indem Sie die beiden Netzwerke
	  &uuml;ber einen EtherIP-Tunnel koppeln oder eine
	  &man.tap.4;-basierte L&ouml;sung wie OpenVPN einsetzen.</para>
      </sect3>

      <sect3>
	<title>Layer&nbsp;2-Redundanz</title>

	<para>Die Systeme eines Netzwerks k&ouml;nnen redundant
	  miteinander verbunden sein.  In diesem Fall verwenden Sie das
	  <foreignphrase>Spanning Tree Protocol</foreignphrase>, um
	  redundante Pfade zu blockieren.  Damit ein Ethernetnetzwerk
	  korrekt arbeitet, darf immer nur ein aktiver Pfad zwischen
	  zwei Ger&auml;ten des Netzwerks existieren.  Aufgabe des
	  Spanning Tree Protocols ist es daher, Schleifen zu entdecken
	  und redundante Links in den Status
	  <emphasis>blockiert</emphasis> zu versetzen.  F&auml;llt ein
	  aktiver Link aus, so berechnet das Protokoll einen neuen
	  Pfad.  Dazu wird ein blockierter Pfad in den Status
	  <emphasis>aktiv</emphasis> versetzt, damit alle Systeme des
	  Netzwerks wieder miteinander kommunizieren k&ouml;nnen.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Kernelkonfiguration</title>

      <para>Dieser Abschnitt beschreibt nur die
	&man.if.bridge.4;-Bridge-Implementierung.  Ein
	Netgraph-Bridge-Treiber ist ebenfalls verf&uuml;gbar, wird
	hier aber nicht behandelt.  Lesen Sie die Manualpage
	&man.ng.bridge.4;, wenn Sie diesen Treiber einsetzen
	wollen.</para>

      <para>Bei diesem Treiber handelt es sich um ein
	Kernelmodul, das von &man.ifconfig.8; automatisch geladen
	wird, wenn ein Bridge-Interface erzeugt wird.  Alternativ ist
	es aber auch m&ouml;glich, die Unterst&uuml;tzung f&uuml;r
	den Treiber in Ihren Kernel zu kompilieren.  Dazu f&uuml;gen
	Sie die Zeile <literal>device if_bridge</literal> in Ihre
	Kernelkonfigurationsdatei ein und bauen danach den Kernel
	neu.</para>

      <para>Paketfilter k&ouml;nnen mit allen Firewallpaketen verwendet
	werden, die das &man.pfil.9;-Framework benutzen.  Die Firewall
	kann dabei entweder als Kernelmodul geladen oder in den Kernel
	kompiliert werden.</para>

      <para>Eine Bridge kann auch als <foreignphrase>Traffic
	Shaper</foreignphrase> verwendet werden, wenn Sie
	&man.altq.4; oder &man.dummynet.4; einsetzen.</para>
    </sect2>

    <sect2>
      <title>Die LAN-Kopplung aktivieren</title>

      <para>Eine Bridge wird durch das Klonen von Schnittstellen
	erzeugt.  Um eine Bridge zu erzeugen, verwenden Sie den Befehl
	&man.ifconfig.8;.  Ist der Bridge-Treiber nicht in Ihren Kernel
	kompiliert, wird er automatisch geladen.</para>

      <screen>&prompt.root; <userinput>ifconfig bridge create</userinput>
bridge0
&prompt.root; <userinput>ifconfig bridge0</userinput>
bridge0: flags=8802&lt;BROADCAST,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        ether 96:3d:4b:f1:79:7a
        id 00:00:00:00:00:00 priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 timeout 1200
        root id 00:00:00:00:00:00 priority 0 ifcost 0 port 0</screen>

      <para>Im obigen Beispiel wird die Bridge erzeugt und erh&auml;lt
	automatisch eine zuf&auml;llig generierte Ethernet-Adresse
	zugewiesen.  Die Parameter <literal>maxaddr</literal> sowie
	<literal>timeout</literal> legen fest, wie viele MAC-Adressen
	die Bridge in ihrer Forward-Tabelle halten kann beziehungsweise
	wie viele Sekunden jeder Eintrag erhalten bleiben soll, nachdem
	er zuletzt verwendet wurde.  Die restlichen Parameter sind
	f&uuml;r die Konfiguration von Spanning&nbsp;Tree notwendig.</para>

      <para>Im n&auml;chsten Schritt werden die Schnittstellen, die
	die Bridge verbinden soll, zugewiesen.  Damit die Bridge
	Datenpakete weiterleiten kann, m&uuml;ssen sowohl die Bridge
	als auch die Schnittstellen (der zu verbindenden
	Netzwerksegmente) aktiviert sein:</para>

      <screen>&prompt.root; <userinput>ifconfig bridge0 addm fxp0 addm fxp1 up</userinput>
&prompt.root; <userinput>ifconfig fxp0 up</userinput>
&prompt.root; <userinput>ifconfig fxp1 up</userinput></screen>

      <para>Danach ist die Bridge in der Lage, Ethernet-Rahmen zwischen
	den Schnittstellen <devicename>fxp0</devicename> und
	<devicename>fxp1</devicename> weiterzuleiten.  Um diese
	Konfiguration beim Systemstart automatisch zu aktivieren,
	m&uuml;ssen Sie folgende Eintr&auml;ge in die Datei
	<filename>/etc/rc.conf</filename> aufnehmen:</para>

      <programlisting>cloned_interfaces="bridge0"
ifconfig_bridge0="addm fxp0 addm fxp1 up"
ifconfig_fxp0="up"
ifconfig_fxp1="up"</programlisting>

      <para>Ben&ouml;tigen Sie f&uuml;r die Bridge eine IP-Adresse,
	m&uuml;ssen Sie diese der Schnittstelle der Bridge zuweisen
	(und nicht einer der Schnittstellen der gekoppelten
	Netzwerksegmente).  Dabei k&ouml;nnen Sie die IP-Adresse
	sowohl statisch als auch dynamisch &uuml;ber DHCP
	zuweisen:</para>

      <screen>&prompt.root; <userinput>ifconfig bridge0 inet 192.168.0.1/24</userinput></screen>

      <para>Sie k&ouml;nnen der Bridge-Schnittstelle auch eine
	IPv6-Adresse zuweisen.</para>
    </sect2>

    <sect2>
      <title>Firewalls</title>
      <indexterm><primary>firewall</primary></indexterm>

      <para>Nachdem ein Paketfilter aktiviert wurde, k&ouml;nnen
	Datenpakete, die von den Schnittstellen der gekoppelten
	Netzwerksegmente gesendet und empfangen werden, &uuml;ber
	die Bridge weitergeleitet oder nach bestimmten Regeln
	gefiltert oder auch komplett geblockt werden.  Ist die
	Richtung des Paketflusses wichtig, ist es am besten, eine
	Firewall auf den Schnittstellen der einzelnen
	Netzwerksegmente einzurichten und nicht auf der Bridge
	selbst.</para>

      <para>Eine Bridge verf&uuml;gt &uuml;ber verschiedene Optionen,
	&uuml;ber die Sie die Weiterleitung von Nicht-IP- und
	ARP-Paketen sowie den Einsatz von Layer&nbsp;2-Firewalls
	(mit IPFW) steuern k&ouml;nnen.  Lesen Sie die Manualpage
	&man.if.bridge.4;, wenn Sie diese Funktionen
	ben&ouml;tigen.</para>
    </sect2>

    <sect2>
      <title>Spanning&nbsp;Tree</title>

      <para>Der Bridge-Treiber implementiert das <foreignphrase>Rapid
	Spanning Tree Protocol</foreignphrase> (RSTP oder 802.1w), das
	abw&auml;rtskompatibel zum veralteten <foreignphrase>Spanning
	Tree Protocol</foreignphrase> (STP) ist.  Spanning&nbsp;Tree
	dient dazu, Schleifen in einer Netzwerktopologie zu entdecken
	und zu entfernen.  RSTP arbeitet dabei schneller als das
	veraltete STP.  RSTP tauscht Informationen mit
	benachbarten Switchen aus, um Pakete korrekt weiterzuleiten
	und eine Schleifenbildung zu verhindern.</para>

      <para>&os; unterst&uuml;tzt die Betriebsmode RSTP sowie STP,
	von denen RSTP als Standardmodus voreingestellt ist.</para>

      <para>Spanning&nbsp;Tree kann auf den Schnittstellen der
	durch die Bridge verbundenen Netzwerksegmente &uuml;ber die
	Option <literal>stp</literal> aktiviert werden.  F&uuml;r eine
	Bridge, die die Schnittstellen <devicename>fxp0</devicename> und
	<devicename>fxp1</devicename> verbindet, aktivieren Sie STP wie
	folgt:</para>

      <screen>&prompt.root; <userinput>ifconfig bridge0 stp fxp0 stp fxp1</userinput>
bridge0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        ether d6:cf:d5:a0:94:6d
        id 00:01:02:4b:d4:50 priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 timeout 1200
        root id 00:01:02:4b:d4:50 priority 32768 ifcost 0 port 0
        member: fxp0 flags=1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 3 priority 128 path cost 200000 proto rstp
                role designated state forwarding
        member: fxp1 flags=1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 4 priority 128 path cost 200000 proto rstp
                role designated state forwarding</screen>

      <para>Diese Bridge hat die Spanning-Tree-ID
	<literal>00:01:02:4b:d4:50</literal> und die Priorit&auml;t
	<literal>32768</literal>.  Da diese ID mit der
	<literal>Root-ID</literal> identisch ist, handelt es sich um die
	Root-Bridge dieses Netzwerks.</para>

      <para>Auf einer anderen Bridge des Netzwerks ist Spanning&nbsp;Tree
	ebenfalls aktiviert:</para>

      <screen>bridge0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        ether 96:3d:4b:f1:79:7a
        id 00:13:d4:9a:06:7a priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 timeout 1200
        root id 00:01:02:4b:d4:50 priority 32768 ifcost 400000 port 4
        member: fxp0 flags=1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 4 priority 128 path cost 200000 proto rstp
                role root state forwarding
        member: fxp1 flags=1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 5 priority 128 path cost 200000 proto rstp
                role designated state forwarding</screen>

      <para>Die Zeile <literal>root id 00:01:02:4b:d4:50 priority 32768
	ifcost 400000 port 4</literal> zeigt an, dass die Root-Bridge wie
	im obigen Beispiel die ID <literal>00:01:02:4b:d4:50</literal>
	hat.  Die Pfadkosten hin zur Root-Bridge betragen
	<literal>400000</literal>, wobei der Pfad zur Root-Bridge
	&uuml;ber <literal>Port&nbsp;4</literal> geht (der wiederum
	der Schnittstelle <devicename>fxp0</devicename>
	entspricht).</para>
    </sect2>

    <sect2>
      <title>Fortgeschrittene Funktionen</title>

      <sect3>
	<title>Den Datenfluss rekonstruieren</title>

	<para>Die Bridge unterst&uuml;tzt den Monitormodus.  Dabei
	  werden alle Pakete verworfen, nachdem sie von &man.bpf.4;
	  verarbeitet wurden.  In diesem Modus erfolgt keine weitere
	  Bearbeitung und auch keine Weiterleitung von Datenpaketen.
	  Es ist daher m&ouml;glich, die Eingabe von zwei oder mehr
	  Netzwerkschnittstellen in einen einzigen gemeinsamen
	  &man.bpf.4;-Stream zu vereinen.  Ein solcher Datenstrom
	  ist beispielsweise n&uuml;tzlich, um den Datenverkehr f&uuml;r
	  ""network taps"" zu rekonstruieren, die ihre RX/TX-Signale
	  &uuml;ber verschiedene Schnittstellen senden.</para>

	<para>Um die Eingabe von vier Netzwerkschnittstellen in einzigen
	  gemeinsamen Datenstrom zu vereinen, geben Sie Folgendes
	  ein:</para>

	<screen>&prompt.root; <userinput>ifconfig bridge0 addm fxp0 addm fxp1 addm fxp2 addm fxp3 monitor up</userinput>
&prompt.root; <userinput>tcpdump -i bridge0</userinput></screen>
      </sect3>

      <sect3>
	<title>Span Ports</title>

	<para>Eine Kopie jedes Ethernet-Rahmens, der an der Bridge
	  ankommt, wird &uuml;ber einen festgelegten
	  <foreignphrase>Span&nbsp;Port</foreignphrase> verschickt.
	  Auf einer Bridge k&ouml;nnen
	  beliebig viele Span&nbsp;Ports festgelegt werden.  Wird
	  eine Schnittstelle als Span&nbsp;Port konfiguriert, kann
	  sie nicht mehr als normaler Bridge-Port verwendet werden.
	  Eine derartige Konfiguration ist beispielsweise sinnvoll,
	  um den Datenverkehr, der in einem Netzwerk &uuml;ber die
	  Bridge l&auml;uft, auf einen Rechner zu &uuml;bertragen,
	  der mit einem Span&nbsp;Port der Bridge verbunden
	  ist.</para>

	<para>Um eine Kopie aller Ethernet-Rahmen &uuml;ber die
	  Schnittstelle <devicename>fxp4</devicename> zu verschicken,
	  geben Sie Folgendes ein:</para>

	<screen>&prompt.root; <userinput>ifconfig bridge0 span fxp4</userinput></screen>
      </sect3>

      <sect3>
	<title>Private Schnittstellen</title>

	<para>Eine private Schnittstelle leitet keine Daten an einen
	  Port weiter, bei dem es sich ebenfalls um eine private
	  Schnittstelle handelt.  Der Datenverkehr wird dabei komplett
	  blockiert, auch Ethernet-Rahmen und ARP-Pakete werden nicht
	  weitergeleitet.  Wollen Sie hingegen nur spezifische
	  Datenpakete blockieren, sollten Sie eine Firewall
	  einsetzen.</para>
      </sect3>

      <sect3>
	<title>Schnittstellen als <foreignphrase>sticky</foreignphrase>
	  kennzeichnen</title>

	<para>Wenn die Schnittstelle eines &uuml;ber eine Bridge
	  verbundenen Netzwerksegments als
	  <foreignphrase>sticky</foreignphrase> gekennzeichnet wird,
	  werden alle dynamisch gelernten Adressen als statische Adressen
	  behandelt, sobald sie in den Forward-Cache der Bridge
	  aufgenommen wurden.  Sticky-Eintr&auml;ge werden niemals aus
	  dem Cache entfernt oder ersetzt.  Selbst dann nicht, wenn die
	  Adresse von einer anderen Schnittstelle verwendet wird.  Sie
	  k&ouml;nnen dadurch die Vorteile statischer Adresseintr&auml;ge
	  nutzen, ohne die Forward-Tabelle vor dem Einsatz der Bridge
	  mit statischen Eintr&auml;gen f&uuml;llen zu m&uuml;ssen.
	  Clients, die sich in einem bestimmten von der Bridge
	  verwalteten Segmente befinden, k&ouml;nnen dabei nicht in ein
	  anderes Segment wechseln.</para>

	<para>Ein weiteres Beispiel f&uuml;r den Einsatz von
	  Sticky-Adressen w&auml;re die Kombination einer Bridge mit
	  mehreren VLANs, um einen Router zu konfigurieren, der in
	  in der Lage ist, einzelne Kundennetzwerke voneinander zu
	  trennen, ohne IP-Adressbereiche zu verschwenden.  F&uuml;r das
	  folgende Beispiel nehmen wir an, dass sich der Client
	  <hostid role="Hostname">CustomerA</hostid> im VLAN
	  <literal>vlan100</literal> und der Client
	  <hostid role="hostname">CustomerB</hostid> im VLAN
	  <literal>vlan101</literal> befinden.  Die Bridge hat die
	  IP-Adresse <hostid role="ipaddr">192.168.0.1</hostid> und ist
	  als Internet-Router konfiguriert.</para>

	<screen>&prompt.root; <userinput>ifconfig bridge0 addm vlan100 sticky vlan100 addm vlan101 sticky vlan101</userinput>
&prompt.root; <userinput>ifconfig bridge0 inet 192.168.0.1/24</userinput></screen>

	<para>Beide Clients sehen <hostid
	  role="ipaddr">192.168.0.1</hostid> als Ihr Default-Gateway.
	  Da der Br&uuml;cken-Cache <emphasis>sticky</emphasis> ist,
	  sind Sie nicht dazu in der Lage, die MAC-Adresse des
	  anderen Kunden zu spoofen und dessen Datenverkehr
	  abzufangen.</para>

	<para>Sie k&ouml;nnen die Kommunikation zwischen den VLANs
	  vollst&auml;ndig unterbinden, wenn Sie private Schnittstellen
	  (oder eine Firewall) einsetzen:</para>

	<screen>&prompt.root; <userinput>ifconfig bridge0 private vlan100 private vlan101</userinput></screen>

	<para>Die Kunden sind nun komplett voneinander isoliert und
	  der komplette <hostid role="netmask">/24</hostid>-Adressbereich
	  kann zugewiesen werden, ohne dass Sie Subnetze einsetzen
	  m&uuml;ssen.</para>
      </sect3>

      <sect3>
	<title>Adressen-Limitierung</title>

	<para>Die maximale m&ouml;gliche Anzahl an eindeutigen
	  MAC-Adressen hinter einer Schnittstelle kann festgelegt werden.
	  Sobald das Limit erreicht ist, werden Pakete mit einer
	  unbekannten Quell-Adresse solange verworfen, bis ein
	  exisitierender Eintrag gel&ouml;scht wird oder
	  abl&auml;uft.</para>

	<para>Das folgende Beispiel setzt die maximale Anzahl von
	  Netzger&auml;ten f&uuml;r
	  <hostid role="Hostname">CustomerA</hostid> f&uuml;r
	  das VLAN <literal>vlan100</literal> auf 10.</para>

	<screen>&prompt.root; <userinput>ifconfig bridge0 ifmaxaddr vlan100 10</userinput></screen>
      </sect3>

      <sect3>
	<title>SNMP-Monitoring</title>

	<para>Die Schnittstelle der Bridge sowie die STP-Parameter
	  k&ouml;nnen durch den bereits im Basissystem enthaltenen
	  SNMP-Daemon &uuml;berwacht werden.  Die exportierten
	  Bridge-MIBs entsprechen den IETF-Standards, daher k&ouml;nnen
	  Sie einen beliebigen SNMP-Client oder ein beliebiges
	  Monitoring-Werkzeug einsetzen, um die ben&ouml;tigten Daten
	  zu erhalten.</para>

	<para>Auf dem Rechner, auf dem die Bridge konfiguriert ist,
	  aktivieren Sie die Zeile
	  <literal>begemotSnmpdModulePath."bridge" = "/usr/lib/snmp_bridge.so"</literal>
	  in der Datei <filename>/etc/snmp.config</filename> und starten
	  danach den <application>bsnmpd</application>-Daemon.
	  Eventuell ben&ouml;tigen Sie noch weitere
	  Konfigurationsparameter wie Community-Namen und
	  Zugriffslisten.  Die Konfiguration dieser Parameter wird
	  in den Manualpages &man.bsnmpd.1; sowie &man.snmp.bridge.3;
	  beschrieben.</para>

	<para>Die folgenden Beispiele verwenden das Softwarepaket
	  <application>Net-SNMP</application> (<filename
	  role="package">net-mgmt/net-snmp</filename>), um die Bridge
	  abzufragen.  Alternativ k&ouml;nnen Sie daf&uuml;r auch den
	  Port <filename role="package">net-mgmt/bsnmptools</filename>
	  einsetzen.  Auf dem SNMP-Client f&uuml;gen Sie danach die
	  folgenden Zeilen in die Datei
	  <filename>$HOME/.snmp/snmp.conf</filename> ein, um die
	  MIB-Definitionen der Bridge in
	  <application>Net-SNMP</application> zu importieren:</para>

	<programlisting>mibdirs +/usr/share/snmp/mibs
mibs +BRIDGE-MIB:RSTP-MIB:BEGEMOT-MIB:BEGEMOT-BRIDGE-MIB</programlisting>

	<para>Um eine einzelne Bridge &uuml;ber den IETF BRIDGE-MIB
	  (RFC4188) zu &uuml;berwachen, geben Sie Folgendes ein:</para>

	<screen>&prompt.user; <userinput>snmpwalk -v 2c -c public bridge1.example.com mib-2.dot1dBridge</userinput>
BRIDGE-MIB::dot1dBaseBridgeAddress.0 = STRING: 66:fb:9b:6e:5c:44
BRIDGE-MIB::dot1dBaseNumPorts.0 = INTEGER: 1 ports
BRIDGE-MIB::dot1dStpTimeSinceTopologyChange.0 = Timeticks: (189959) 0:31:39.59 centi-seconds
BRIDGE-MIB::dot1dStpTopChanges.0 = Counter32: 2
BRIDGE-MIB::dot1dStpDesignatedRoot.0 = Hex-STRING: 80 00 00 01 02 4B D4 50
...
BRIDGE-MIB::dot1dStpPortState.3 = INTEGER: forwarding(5)
BRIDGE-MIB::dot1dStpPortEnable.3 = INTEGER: enabled(1)
BRIDGE-MIB::dot1dStpPortPathCost.3 = INTEGER: 200000
BRIDGE-MIB::dot1dStpPortDesignatedRoot.3 = Hex-STRING: 80 00 00 01 02 4B D4 50
BRIDGE-MIB::dot1dStpPortDesignatedCost.3 = INTEGER: 0
BRIDGE-MIB::dot1dStpPortDesignatedBridge.3 = Hex-STRING: 80 00 00 01 02 4B D4 50
BRIDGE-MIB::dot1dStpPortDesignatedPort.3 = Hex-STRING: 03 80
BRIDGE-MIB::dot1dStpPortForwardTransitions.3 = Counter32: 1
RSTP-MIB::dot1dStpVersion.0 = INTEGER: rstp(2)</screen>

	<para>Der Wert der Variable
	  <literal>dot1dStpTopChanges.0</literal> ist hier 2, die
	  STP-Topologie der Bridge wurde also bereits zweimal
	  ge&auml;ndert.  Unter einer &Auml;nderung versteht man dabei
	  die Anpassung eines oder mehrerer Links und die Kalkulation
	  eines neuen Baums.  Der Wert der Variable
	  <literal>dot1dStpTimeSinceTopologyChange.0</literal> gibt an,
	  wann dies zuletzt geschah.</para>

	<para>Um mehrere Bridge-Schnittstellen zu &uuml;berwachen,
	  k&ouml;nnen Sie den privaten BEGEMOT-BRIDGE-MIB
	  einsetzen:</para>

	<screen>&prompt.user; <userinput>snmpwalk -v 2c -c public bridge1.example.com</userinput>
enterprises.fokus.begemot.begemotBridge
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseName."bridge0" = STRING: bridge0
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseName."bridge2" = STRING: bridge2
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseAddress."bridge0" = STRING: e:ce:3b:5a:9e:13
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseAddress."bridge2" = STRING: 12:5e:4d:74:d:fc
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseNumPorts."bridge0" = INTEGER: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseNumPorts."bridge2" = INTEGER: 1
...
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTimeSinceTopologyChange."bridge0" = Timeticks: (116927) 0:19:29.27 centi-seconds
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTimeSinceTopologyChange."bridge2" = Timeticks: (82773) 0:13:47.73 centi-seconds
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTopChanges."bridge0" = Counter32: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTopChanges."bridge2" = Counter32: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeStpDesignatedRoot."bridge0" = Hex-STRING: 80 00 00 40 95 30 5E 31
BEGEMOT-BRIDGE-MIB::begemotBridgeStpDesignatedRoot."bridge2" = Hex-STRING: 80 00 00 50 8B B8 C6 A9</screen>

	<para>Um die &uuml;ber den
	  <literal>mib-2.dot1dBridge</literal>-Subtree &uuml;berwachte
	  Bridge-Schnittstelle zu &auml;ndern, geben Sie Folgendes
	  ein:</para>

	<screen>&prompt.user; <userinput>snmpset -v 2c -c private bridge1.example.com</userinput>
BEGEMOT-BRIDGE-MIB::begemotBridgeDefaultBridgeIf.0 s bridge2</screen>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="network-aggregation">
    <sect1info>
      <authorgroup>
        <author>
	  <firstname>Andrew</firstname>
	  <surname>Thompson</surname>
	  <contrib>Geschrieben von </contrib>
	</author>
      </authorgroup>

      <authorgroup>
        <author>
	  <firstname>Benedict</firstname>
	  <surname>Reuschling</surname>
	  <contrib>&Uuml;bersetzt von </contrib>
        </author>
        <author>
	  <firstname>Sharon</firstname>
	  <surname>Bahagi</surname>
        </author>
      </authorgroup>
    </sect1info>
    <title>Link-Aggregation und Failover</title>

    <indexterm><primary>lagg</primary></indexterm>
    <indexterm><primary>failover</primary></indexterm>
    <indexterm><primary>fec</primary></indexterm>
    <indexterm><primary>lacp</primary></indexterm>
    <indexterm><primary>loadbalance</primary></indexterm>
    <indexterm><primary>roundrobin</primary></indexterm>

    <sect2>
      <title>Einleitung</title>
      <para>Die &man.lagg.4;-Schnittstelle erlaubt die Aggregation von
        mehreren Netzwerkadaptern als eine virtuelle Schnittstelle mit dem
        Ziel, Ausfallsicherheit (Failover) und Hochgeschwindigkeitsverbindungen
        bereitzustellen.</para>
    </sect2>

    <sect2>
      <title>Anwendungsoptionen</title>

      <variablelist>

	<varlistentry><term>Ausfallsicherheit (Failover)</term>

	<listitem>
	<para>Sendet und empf&auml;ngt Netzwerkverkehr nur auf dem
	  Masterport.  Sollte der Masterport nicht zur Verf&uuml;gung stehen,
	  wird der n&auml;chste aktive Port verwendet.  Der zuerst
	  hinzugef&uuml;gte Adapter wird zum Masterport, jeder weitere Adapter
	  dient als Ger&auml;t zur Ausfallsicherheit.</para>
        </listitem>
        </varlistentry>

	<varlistentry><term>&cisco; Fast &etherchannel;</term>

	<listitem>
	<para>&cisco; Fast &etherchannel; (FEC), ist eine statische
          Konfiguration und handelt weder Aggregation mit der Gegenstelle aus,
          noch werden Frames zur &Uuml;berwachung der Verbindung ausgetauscht.
          Wenn der Switch LACP unterst&uuml;tzt, sollte diese Option auch
          verwendet werden.</para>

	<para><acronym>FEC</acronym> balanciert den ausgehenden Verkehr
          &uuml;ber die aktiven Ports, basierend auf gehashten
          Protokollheaderinformationen und akzeptiert eingehenden Verkehr auf
          jedem aktiven Port.  Der Hash enth&auml;lt die Ethernet-Quell- und
          Zieladresse, und, falls verf&uuml;gbar, den VLAN-Tag, sowie die
          IPv4/IPv6 Quell- und Zieladresse.</para>
        </listitem>
	</varlistentry>

	<varlistentry><term>LACP</term>

	<listitem>
	<para>Das &ieee; 802.3ad Link-Aggregation Control Protokoll
	  (LACP) und das Marker Protocol. LACP wird eine Menge von
	  aggregierbaren Verbindungen mit der Gegenstelle in einer oder
	  mehreren Link Aggregated Groups (LAG) aushandeln.  Jede LAG besteht
	  aus Ports der gleichen Geschwindigkeit, eingestellt auf
	  Voll-Duplex-Betrieb.  Der Verkehr wird &uuml;ber die Ports
	  in der LAG mit der gr&ouml;&szlig;ten Gesamtgeschwindigkeit
	  balanciert, in den meisten F&auml;llen wird es nur eine LAG geben,
	  die alle Ports enth&auml;lt.  Im Falle von &Auml;nderungen in der
	  physischen Anbindung wird die Link-Aggregation schnell zu einer
	  neuen Konfiguration konvergieren.</para>

	<para><acronym>LACP</acronym> balanciert ausgehenden Verkehr
          &uuml;ber die aktiven Ports basierend auf der gehashten
          Protokollheaderinformation und akzeptiert eingehenden Verkehr auf
          jedem aktiven Port.  Der Hash beinhaltet die Ethernet-Quell- und
          Zieladresse, und, soweit verf&uuml;gbar, den VLAN-Tag, sowie die
          IPv4/IPv6 Quell- und Zieladresse.</para>
        </listitem>
	</varlistentry>

	<varlistentry><term>Lastverteilung (Loadbalance)</term>

	<listitem>
	<para>Dabei handelt es sich um einen Alias des
	  <emphasis>FEC</emphasis>-Modus.</para>
        </listitem>
        </varlistentry>

	<varlistentry><term>Round-Robin</term>

	<listitem>
	<para>Verteilt ausgehenden Verkehr mittels einer Round-Robin-Zuteilung
          &uuml;ber alle aktiven Ports und akzeptiert eingehenden Verkehr auf
          jedem aktiven Port. Dieser Modus verletzt die Reihenfolge von
          Ethernet-Frames und sollte mit Vorsicht eingesetzt werden.</para>
        </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2>
      <title>Beispiele</title>

      <example id="networking-lacp-aggregation-cisco">
	<title>LACP Aggregation mit einem Switch von &cisco;</title>

	<para>Dieses Beispiel verbindet zwei Adapter auf einer &os;-Maschine
          mit dem Switch als eine einzelne, lastverteilte und ausfallsichere
          Verbindung.  Weitere Adapter k&ouml;nnen hinzugef&uuml;gt werden, um
          den Durchsatz zu erh&ouml;hen und die Ausfallsicherheit zu steigern.
          Da die Reihenfolge der Frames bei Ethernet zwingend eingehalten
          werden muss, flie&szlig;t auch jeglicher Verkehr zwischen zwei
          Stationen &uuml;ber den gleichen physischen Kanal, was die maximale
          Geschwindigkeit der Verbindung auf die eines einzelnen Adapters
          beschr&auml;nkt.  Der &Uuml;bertragungsalgorithmus versucht, so viele
          Informationen wie m&ouml;glich zu verwenden, um die verschiedenen
          Verkehrsfl&uuml;sse zu unterscheiden und balanciert diese &uuml;ber
          die verf&uuml;gbaren Adapter.</para>

	<para>F&uuml;gen Sie auf dem &cisco;-Switch die Adapter
	  <replaceable>FastEthernet0/1</replaceable> und
	  <replaceable>FastEthernet0/2</replaceable> zu der
	  channel-group <replaceable>1</replaceable> hinzu:</para>

	<screen><userinput>interface <replaceable>FastEthernet0/1</replaceable>
 channel-group <replaceable>1</replaceable> mode active
 channel-protocol lacp</userinput>
!
<userinput>interface <replaceable>FastEthernet0/2</replaceable>
 channel-group <replaceable>1</replaceable> mode active
 channel-protocol lacp</userinput></screen>

	<para>Auf der Maschine mit &os; erstellen Sie die
	  &man.lagg.4;-Schnittstelle unter Verwendung von
	  <replaceable>fxp0</replaceable> und
	  <replaceable>fxp1</replaceable>:</para>

        <screen>&prompt.root; <userinput>ifconfig <replaceable>lagg0</replaceable> create </userinput>
&prompt.root; <userinput>ifconfig <replaceable>lagg0</replaceable> up laggproto lacp laggport <replaceable>fxp0</replaceable> laggport <replaceable>fxp1</replaceable></userinput></screen>

	<para>&Uuml;berpr&uuml;fen Sie den Status der Schnittstelle, indem
	  Sie folgendes eingeben:</para>

	<screen>&prompt.root; <userinput>ifconfig <replaceable>lagg0</replaceable></userinput></screen>

	<para>Ports, die als <emphasis>ACTIVE</emphasis> markiert sind, sind
	  Teil der aktiven Aggregations-Gruppe, die mit dem Switch
	  ausgehandelt wurde und der Verkehr wird &uuml;ber diese
	  &uuml;bertragen und empfangen.  Benutzen Sie die ausf&uuml;hrliche
	  Ausgabe von &man.ifconfig.8;, um sich die LAG-Identifikatoren
	  anzeigen zu lassen.</para>

	<screen>lagg0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        options=8&lt;VLAN_MTU&gt;
        ether 00:05:5d:71:8d:b8
        media: Ethernet autoselect
        status: active
        laggproto lacp
        laggport: fxp1 flags=1c&lt;ACTIVE,COLLECTING,DISTRIBUTING&gt;
        laggport: fxp0 flags=1c&lt;ACTIVE,COLLECTING,DISTRIBUTING&gt;</screen>

	<para>Um den  Status der Ports auf dem Switch anzuzeigen, geben Sie
	  <userinput>show lacp neighbor</userinput> ein:</para>

	<screen>switch# show lacp neighbor
Flags:  S - Device is requesting Slow LACPDUs
        F - Device is requesting Fast LACPDUs
        A - Device is in Active mode       P - Device is in Passive mode

Channel group 1 neighbors

Partner's information:

                  LACP port                        Oper    Port     Port
Port      Flags   Priority  Dev ID         Age     Key     Number   State
Fa0/1     SA      32768     0005.5d71.8db8  29s    0x146   0x3      0x3D
Fa0/2     SA      32768     0005.5d71.8db8  29s    0x146   0x4      0x3D</screen>

	<para>Benutzen Sie das Kommando <userinput>show lacp neighbor
	  detail</userinput>, um weitere Informationen zu erhalten.</para>
      </example>
      <example id="networking-lagg-failover">
	<title>Ausfallsicherer Modus</title>

	<para>Der ausfallsichere Modus kann verwendet werden, um zu einer
	  zweiten Schnittstelle zu wechseln, sollte die Verbindung mit der
	  Master-Schnittstelle ausfallen.  Erstellen und konfigurieren Sie die
	  <replaceable>lagg0</replaceable>-Schnittstelle mit
	  <replaceable>fxp0</replaceable> als Master und
	  <replaceable>fxp1</replaceable> als die sekund&auml;re
	  Schnittstelle:</para>

        <screen>&prompt.root; <userinput>ifconfig <replaceable>lagg0</replaceable> create</userinput>
&prompt.root; <userinput>ifconfig <replaceable>lagg0</replaceable> up laggproto failover laggport <replaceable>fxp0</replaceable> laggport <replaceable>fxp1</replaceable></userinput></screen>

	<para>Die Schnittstelle wird so &auml;hnlich wie im folgenden
	  aussehen, mit dem gro&szlig;en Unterschied, dass die
	  <acronym>MAC</acronym>-Adresse und die Ger&auml;tenamen
	  unterschiedlich sein werden:</para>

        <screen>&prompt.root; <userinput>ifconfig <replaceable>lagg0</replaceable></userinput>
lagg0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        options=8&lt;VLAN_MTU&gt;
        ether 00:05:5d:71:8d:b8
        media: Ethernet autoselect
        status: active
        laggproto failover
        laggport: fxp1 flags=0&lt;&gt;
        laggport: fxp0 flags=5&lt;MASTER,ACTIVE&gt;</screen>

	<para>Der Verkehr wird auf <replaceable>fxp0</replaceable>
          &uuml;bertragen und empfangen.  Wenn die Verbindung auf
          <replaceable>fxp0</replaceable> abbricht, so wird
	  <replaceable>fxp1</replaceable> die Verbindung &uuml;bernehmen.
	  Sobald die Verbindung auf der Master-Schnittstelle wiederhergestellt
	  ist, wird diese auch wieder als aktive Schnittstelle genutzt.</para>
      </example>

      <example id="networking-lagg-wired-and-wireless">
        <title>Failover Modus zwischen drahtgebundenen und drahtlosen
          Schnittstellen</title>

        <para>F&uuml;r Laptop-Benutzer ist es normalerweise
          w&uuml;nschenswert, wireless als sekund&auml;re Schnittstelle
          einzurichten, die verwendet wird, wenn die Verbindung via Kabel
          nicht verf&uuml;gbar ist.  Mit &man.lagg.4; ist es m&ouml;glich,
          eine IP-Adresse f&uuml;r die Kabelverbindung zu verwenden.
          Sie ist leistungsf&auml;hig und sicher.  Gleichzeitig haben Sie
          die M&ouml;glichkeit Daten &uuml;ber die drahtlose Verbindung
          zu &uuml;bertragen.</para>

        <para>In dieser Konfiguration, m&uuml;ssen wir die zugrunde
          liegenden <acronym>MAC</acronym>-Adresse der WLAN-Schnittstelle
          &uuml;berschreiben, damit sie zur Adresse von &man.lagg.4; passt,
          welche von der drahtgebundenen Masterschnittstelle vererbt
          wurde.</para>

        <para>In dieser Konfiguration behandeln wir die drahtgebundene
          Schnittstelle <replaceable>bge0</replaceable> als die Master und
          die drahtlose Schnittstelle <replaceable>wlan0</replaceable> als
          die Failover-Schnittstelle.  Die <replaceable>wlan0</replaceable>
          wurde von der <replaceable>iwn0</replaceable> mit der
          <acronym>MAC</acronym>-Adresse der kabelgebundenen eingerichtet.
          Im ersten Schritt erhalten wir die <acronym>MAC</acronym>-Adresse
          der kabelgebundenen Schnittstelle:</para>

        <screen>&prompt.root; <userinput>ifconfig <replaceable>bge0</replaceable></userinput>
bge0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
 options=19b&lt;RXCSUM,TXCSUM,VLAN_MTU,VLAN_HWTAGGING,VLAN_HWCSUM,TSO4&gt;
 ether 00:21:70:da:ae:37
 inet6 fe80::221:70ff:feda:ae37%bge0 prefixlen 64 scopeid 0x2
 nd6 options=29&lt;PERFORMNUD,IFDISABLED,AUTO_LINKLOCAL&gt;
 media: Ethernet autoselect (1000baseT &lt;full-duplex&gt;)
 status: active</screen>

	<para>Sie k&ouml;nnen <replaceable>bge0</replaceable> in
	  ihre tats&auml;chliche &auml;ndern und werden eine andere
	  <literal>ether</literal>-Zeile mit der
	  <acronym>MAC</acronym>-Adresse ihrer kabelgebundenen
	  Schnittstelle erhalten. Nun &auml;ndern wir die zugrunde liegende
	  drahtlose Schnittstelle <replaceable>iwn0</replaceable>:</para>

	<screen>&prompt.root; <userinput>ifconfig <replaceable>iwn0</replaceable> ether <replaceable>00:21:70:da:ae:37</replaceable></userinput></screen>

	<para>Starten Sie den Wireless-Schnittstelle, aber ohne
	  IP-Adresse:</para>

	<screen>&prompt.root; <userinput>ifconfig <replaceable>wlan0</replaceable> create wlandev <replaceable>iwn0</replaceable> ssid <replaceable>my_router</replaceable> up</userinput></screen>

	<para>Erstellen Sie die &man.lagg.4; Schnittstelle mit
	  <replaceable>bge0</replaceable> als Master und
	  <replaceable>wlan0</replaceable> als Failover falls
	  notwendig:</para>

	<screen>&prompt.root; <userinput>ifconfig <replaceable>lagg0</replaceable> create</userinput>
&prompt.root; <userinput>ifconfig <replaceable>lagg0</replaceable> up laggproto failover laggport <replaceable>bge0</replaceable> laggport <replaceable>wlan0</replaceable></userinput></screen>

	<para>Die Schnittstelle sieht &auml;nhlich aus, die Hauptunterschiede
	  werden die <acronym>MAC</acronym>-Adresse und die Ger&auml;tenamen
	  sein:</para>

	<screen>&prompt.root; <userinput>ifconfig <replaceable>lagg0</replaceable></userinput>
lagg0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        options=8&lt;VLAN_MTU&gt;
        ether 00:21:70:da:ae:37
        media: Ethernet autoselect
        status: active
        laggproto failover
        laggport: wlan0 flags=0&lt;&gt;
        laggport: bge0 flags=5&lt;MASTER,ACTIVE&gt;</screen>

        <para>Um zu vermeiden, dass Sie dies nach jedem Neustart machen m&uuml;ssen, k&ouml;nnen Sie
          etwas in der Art in ihre <filename>/etc/rc.conf</filename>
          Datei schreiben:</para>

        <programlisting>ifconfig_bge0="up"
ifconfig_iwn0="ether 00:21:70:da:ae:37"
wlans_iwn0="wlan0"
ifconfig_wlan0="WPA"
cloned_interfaces="lagg0"
ifconfig_lagg0="laggproto failover laggport bge0 laggport wlan0 DHCP"
	</programlisting>
      </example>
    </sect2>
  </sect1>

  <sect1 id="network-diskless">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Jean-Fran&ccedil;ois</firstname>
          <surname>Dock&egrave;s</surname>
          <contrib>Aktualisiert von </contrib>
        </author>
      </authorgroup>

      <authorgroup>
	<author>
	  <firstname>Alex</firstname>
	  <surname>Dupre</surname>
	  <contrib>Reorganisiert und erweitert von </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title>Start und Betrieb von FreeBSD &uuml;ber ein Netzwerk</title>

    <indexterm>
      <primary>plattenloser Arbeitsplatz</primary>
    </indexterm>
    <indexterm>
      <primary>plattenloser Betrieb</primary>
    </indexterm>

    <para>FreeBSD kann &uuml;ber ein Netzwerk starten und arbeiten, ohne
      eine lokale Festplatte zu verwenden, indem es Dateisysteme eines
      <acronym>NFS</acronym>-Servers in den eigenen Verzeichnisbaum
      einh&auml;ngt.  Dazu sind, von den Standardkonfigurationsdateien
      abgesehen, keine System&auml;nderungen n&ouml;tig.  Ein solches
      System kann leicht installiert werden, da alle notwendigen
      Elemente bereits vorhanden sind:</para>

    <itemizedlist>
      <listitem>
        <para>Es gibt mindestens zwei M&ouml;glichkeiten, den Kernel
          &uuml;ber das Netzwerk zu laden:</para>

        <itemizedlist>
          <listitem>
	    <para><acronym>PXE</acronym>: Das
              <quote>Preboot eXecution Environment System</quote> von
	      &intel; ist eine Art intelligentes Boot-ROM, das in
	      einigen Netzwerkkarten oder Hauptplatinen verwendet wird.
	      Weitere Informationen finden Sie in &man.pxeboot.8;.
	    </para>
          </listitem>

          <listitem>
            <para>Der Port
	      <application>Etherboot</application>
	      (<filename role="package">net/etherboot</filename>)
	      erzeugt ROM-f&auml;higen Code, um einen Kernel &uuml;ber
	      das Netzwerk zu laden.  Dieser Code kann entweder auf ein
              Boot-PROM einer Netzwerkkarte gebrannt werden, was von vielen
              Netzwerkkarten unterst&uuml;tzt wird.  Oder er kann von einer
              lokalen Diskette, Festplatte oder von einem laufenden
              &ms-dos;-System geladen werden.</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Das Beispielskript
	  <filename>/usr/share/examples/diskless/clone_root</filename>
	  erleichtert die Erzeugung und die Wartung des
	  root-Dateisystems auf dem Server.  Das Skript muss
	  wahrscheinlich angepasst werden, dennoch werden Sie schnell zu
	  einem Ergebnis kommen.</para>
      </listitem>

      <listitem>
        <para>Die Startdateien, die einen plattenlosen Systemstart
          erkennen und unterst&uuml;tzen, sind nach der Installation
          in <filename>/etc</filename> vorhanden.</para>
      </listitem>

      <listitem>
	<para>Dateiauslagerungen k&ouml;nnen sowohl via
	  <acronym>NFS</acronym> als auch auf die lokale Platte
	  erfolgen.</para>
      </listitem>
    </itemizedlist>

    <para>Es gibt verschiedene Wege, einen plattenlosen Rechner
      einzurichten.  Viele Elemente sind daran beteiligt, die fast
      immer an den pers&ouml;nlichen Geschmack angepasst werden
      k&ouml;nnen.  Im folgenden Abschnitt wird die Installation
      eines kompletten Systems beschrieben, wobei der
      Schwerpunkt auf Einfachheit und Kompatibilit&auml;t zu den
      Standardstartskripten von FreeBSD liegt.  Das beschriebene
      System hat folgende Eigenschaften:</para>

    <itemizedlist>
      <listitem>
        <para>Die plattenlosen Rechner haben ein gemeinsames
          <filename>/</filename>- sowie ein gemeinsames
          <filename>/usr</filename>-Dateisystem, die jeweils
          schreibgesch&uuml;tzt sind.</para>

        <para>Das root-Dateisystem ist eine Kopie
          eines Standardwurzelverzeichnisses von FreeBSD
          (&uuml;blicherweise das des Servers), bei dem einige
          Konfigurationsdateien durch f&uuml;r den plattenlosen
          Betrieb geeignete Versionen ersetzt wurden.</para>

        <para>F&uuml;r die Bereiche des root-Dateisystems, die
          beschreibbar sein m&uuml;ssen, werden mit &man.md.4;
          virtuelle Dateisysteme erzeugt.  Dies bedeutet aber auch, dass
          alle Ver&auml;nderungen verloren gehen, wenn das System neu
          gestartet wird.</para>
      </listitem>

      <listitem>
	<para>Der Kernel wird, in Abh&auml;ngigkeit von der jeweiligen
	  Situation, entweder von <application>Etherboot</application>
	  oder von <acronym>PXE</acronym> transferiert und geladen.
	</para>
      </listitem>
    </itemizedlist>

    <caution><para>Das hier beschriebene System ist nicht sicher.  Es
      sollte nur in einem gesicherten Bereich eines Netzwerks verwendet
      werden und f&uuml;r andere Rechner nicht erreichbar sein.</para>
    </caution>

    <para>Alle Informationen in diesem Abschnitt wurden unter
      &os;&nbsp;5.2.1-RELEASE getestet.</para>

    <sect2>
      <title>Hintergrundinformationen</title>

      <para>Die Einrichtung von plattenlosen Rechnern ist einfach, aber
	auch fehleranf&auml;llig.  Der Grund daf&uuml;r sind auftretende
	Fehler, die sich oft nur schwer zuordnen lassen.  Unter anderem
	sind daf&uuml;r folgende Umst&auml;nde verantwortlich:</para>

      <itemizedlist>
	<listitem>
	  <para>Kompilierte Optionen haben zur Laufzeit unterschiedliche
	    Auswirkungen.</para>
	</listitem>

	<listitem>
	  <para>Fehlermeldungen sind oft kryptisch oder fehlen
	    vollst&auml;ndig.</para>
	</listitem>
      </itemizedlist>

      <para>Daher ist es n&uuml;tzlich, &uuml;ber die im Hintergrund
	ablaufenden Mechanismen Bescheid zu wissen.  Dadurch wird es
	einfacher, eventuell auftretende Fehler zu beheben.</para>

      <para>Verschiedene Operationen m&uuml;ssen ausgef&uuml;hrt werden,
	um ein System erfolgreich zu starten:</para>

      <itemizedlist>
	<listitem>
	  <para>Der Rechner ben&ouml;tigt einige Startparameter, wie
	    seine IP-Adresse, die Namen ausf&uuml;hrbarer Dateien, den
	    Servernamen sowie den root-Pfad.  F&uuml;r die
	    &Uuml;bermittlung dieser Informationen wird entweder das
	    <acronym>DHCP</acronym>- oder das BOOTP-Protokoll verwendet.
	    Bei <acronym>DHCP</acronym> handelt es sich um eine
	    abw&auml;rtskompatible Erweiterung von BOOTP, die die
	    gleichen Portnummern und das gleiche Paketformat verwendet.
	  </para>

	  <para>Es ist m&ouml;glich, das System so zu konfigurieren,
	    dass es nur BOOTP verwendet.  Das Serverprogramm
	    &man.bootpd.8; ist bereits im &os;-Basissystem enthalten.
	  </para>

	  <para><acronym>DHCP</acronym> hat im Vergleich zu BOOTP
	    allerdings mehrere Vorteile (bessere Konfigurationsdateien,
	    die M&ouml;glichkeit zur Verwendung von
	    <acronym>PXE</acronym>, sowie viele andere, die nicht in
	    direktem Zusammenhang mit dem plattenlosen Betrieb stehen).
	    Dieser Abschnitt beschreibt die Konfiguration mittels
	    <acronym>DHCP</acronym>.  Wenn m&ouml;glich, werden aber
	    entsprechende Beispiele f&uuml;r &man.bootpd.8;
	    angef&uuml;hrt.  Die Beispielkonfiguration nutzt das
	    Softwarepaket <application>ISC DHCP</application>.</para>
	</listitem>

	<listitem>
	  <para>Der Rechner muss ein oder mehrere Programme in den
	    lokalen Speicher laden.  Dazu wird entweder
	    <acronym>TFTP</acronym> oder <acronym>NFS</acronym>
	    verwendet.  Die Auswahl zwischen <acronym>TFTP</acronym> und
	    <acronym>NFS</acronym> erfolgt &uuml;ber das Setzen von
	    verschiedenen Kompilieroptionen.  Ein h&auml;ufig gemachter
	    Fehler ist es, Dateinamen f&uuml;r das falsche Protokoll
	    anzugeben:  <acronym>TFTP</acronym> transferiert
	    normalerweise alle Dateien aus einem einzigen Verzeichnis
	    des Servers, und erwartet einen Pfad relativ zu diesem
	    Verzeichnis.  <acronym>NFS</acronym> verlangt hingegen
	    absolute Dateipfade.</para>
	</listitem>

	<listitem>
	  <para>Die m&ouml;glichen Bootstrap-Programme und der Kernel
	    m&uuml;ssen initialisiert und ausgef&uuml;hrt werden.  Dabei
	    gibt es zwei M&ouml;glichkeiten:</para>

	  <itemizedlist>
	    <listitem>
	      <para><acronym>PXE</acronym> l&auml;dt &man.pxeboot.8;.
	        Dabei handelt es sich um eine modifizierte Version des
	        &os;-Laders der Boot-Phase drei.  Der &man.loader.8;
	        beschafft alle f&uuml;r den Systemstart notwendigen
	        Parameter, und hinterlegt diese in der Kernelumgebung,
	        bevor er die Kontrolle &uuml;bergibt.  Es ist hier
	        m&ouml;glich, den <filename>GENERIC</filename>-Kernel
	        zu verwenden.</para>
	    </listitem>

	    <listitem>
	      <para><application>Etherboot</application> l&auml;dt den
	        Kernel hingegen direkt.  Daf&uuml;r m&uuml;ssen Sie
	        allerdings einen Kernel mit spezifischen Optionen
	        erzeugen.</para>
	    </listitem>
	  </itemizedlist>

	  <para><acronym>PXE</acronym> und
	    <application>Etherboot</application> sind zwar im
	    Gro&szlig;en und Ganzen gleichwertig, da der Kernel
	    aber viele Aufgaben an &man.loader.8; &uuml;bergibt, sollte
	    bevorzugt <acronym>PXE</acronym> eingesetzt werden.</para>

	  <para>Wenn Ihr <acronym>BIOS</acronym> und Ihre Netzwerkkarten
	    <acronym>PXE</acronym> unterst&uuml;tzen, sollten Sie es
	    auch verwenden.</para>
	</listitem>

	<listitem>
	   <para>Zuletzt muss der Rechner auf seine Dateisysteme
	     zugreifen k&ouml;nnen.  Daf&uuml;r wird stets
	     <acronym>NFS</acronym> verwendet.</para>
	</listitem>
      </itemizedlist>

      <para>Weitere Informationen finden Sie in &man.diskless.8;.</para>
    </sect2>

    <sect2>
      <title>Installationsanweisungen</title>

      <sect3>
	<title>Konfiguration unter Verwendung von
	  <application>ISC DHCP</application></title>

	<indexterm>
	  <primary>DHCP</primary>
	  <secondary>plattenloser Betrieb</secondary>
	</indexterm>

	<para>Der <application>ISC DHCP</application>-Server kann
	  Anfragen sowohl von BOOTP als auch von DHCP beantworten.
	</para>

	<para><application>isc-dhcp 3.1</application> ist nicht Teil
	  des Basissystems.  Sie m&uuml;ssen es daher zuerst
	  installieren.  Verwenden Sie dazu den Port
	  <filename role="package">net/isc-dhcp31-server</filename>
	  oder das entsprechende Paket.</para>

	<para>Nachdem <application>ISC DHCP</application> installiert
	  ist, muss das Programm konfiguriert werden (normalerweise in
	  <filename>/usr/local/etc/dhcpd.conf</filename>).  Im
	  folgenden Beispiel verwendet Rechner <hostid>margaux</hostid>
	  <application>Etherboot</application>, w&auml;hrend Rechner
	  <hostid>corbieres</hostid> <acronym>PXE</acronym> verwendet:
	</para>

	<programlisting>          default-lease-time 600;
          max-lease-time 7200;
          authoritative;

          option domain-name "example.com";
          option domain-name-servers 192.168.4.1;
          option routers 192.168.4.1;

          subnet 192.168.4.0 netmask 255.255.255.0 {
            use-host-decl-names on; <co id="co-dhcp-host-name">
            option subnet-mask 255.255.255.0;
            option broadcast-address 192.168.4.255;

            host margaux {
              hardware ethernet 01:23:45:67:89:ab;
              fixed-address margaux.example.com;
              next-server 192.168.4.4;<co id="co-dhcp-next-server">
              filename "/tftpboot/kernel.diskless";<co id="co-dhcp-filename">
              option root-path "192.168.4.4:/data/misc/diskless";<co id="co-dhcp-root-path">
            }
           host corbieres {
             hardware ethernet 00:02:b3:27:62:df;
              fixed-address corbieres.example.com;
              next-server 192.168.4.4;
              filename "pxeboot";
              option root-path "192.168.4.4:/data/misc/diskless";
            }
          }
        </programlisting>

	<calloutlist>
	  <callout arearefs="co-dhcp-host-name"><para>Diese Option
	    weist <application>dhcpd</application> an, den Wert der
	    <literal>host</literal>-Deklaration als Rechnernamen des
	    plattenlosen Rechners zu senden.  Alternativ kann man der
	    <literal>host</literal>-Deklaration Folgendes
	    hinzuf&uuml;gen: <literal>option host-name
	    <replaceable>margaux</replaceable></literal></para>
	  </callout>

	  <callout arearefs="co-dhcp-next-server"><para>Die Anweisung
	    <literal>next-server</literal> bestimmt den
	    <acronym>TFTP</acronym>- oder
	    <acronym>NFS</acronym>-Server, von dem der Loader oder
	    der Kernel geladen werden (in der Voreinstellung ist das
	    der <acronym>DHCP</acronym>-Server selbst).</para>
	  </callout>

	  <callout arearefs="co-dhcp-filename"><para>Die Anweisung
	    <literal>filename</literal> bestimmt die Datei, die
	    <application>Etherboot</application> als n&auml;chstes
	    l&auml;dt.  Das genaue Format h&auml;ngt von der
	    gew&auml;hlten Transfermethode ab.
	    <application>Etherboot</application> kann sowohl mit
	    <acronym>NFS</acronym> als auch mit
	    <acronym>TFTP</acronym> kompiliert werden.  In der
	    Voreinstellung wird der &os;-Port mit
	    <acronym>NFS</acronym>-Unterst&uuml;tzung kompiliert.
	    <acronym>PXE</acronym> verwendet <acronym>TFTP</acronym>,
	    daher wird im Beispiel ein relativer Dateipfad verwendet.
	    Dies kann aber, je nach Konfiguration des
	    <acronym>TFTP</acronym>-Servers, auch anders sein.
	    Beachten Sie, dass <acronym>PXE</acronym>
	    <filename>pxeboot</filename> l&auml;dt, und nicht den
	    Kernel.  Es ist auch m&ouml;glich, das Verzeichnis
	    <filename class="directory">/boot</filename> einer
	    &os;-CD-ROM von <filename>pxeboot</filename> laden zu
	    lassen.  &man.pxeboot.8; kann einen
	    <filename>GENERIC</filename>-Kernel laden, dadurch ist es
	    m&ouml;glich, <acronym>PXE</acronym> von einer entfernten
	    CD-ROM zu starten.</para>
	  </callout>

	  <callout arearefs="co-dhcp-root-path"><para>Die Option
	    <literal>root-path</literal> bestimmt den Pfad des
	    root-Dateisystems in normaler NFS-Schreibweise.  Wird
	    <acronym>PXE</acronym> verwendet, ist es m&ouml;glich,
	    die IP-Adresse des Rechners wegzulassen, solange nicht
	    die Kerneloption BOOTP aktiviert wird.  Der
	    <acronym>NFS</acronym>-Server entspricht in diesem Fall
	    dem <acronym>TFTP</acronym>-Server.</para>
	  </callout>
	</calloutlist>
      </sect3>

      <sect3>
	<title>Konfiguration bei Verwendung von BOOTP</title>

	<indexterm>
	  <primary>BOOTP</primary>
	  <secondary>plattenloser Betrieb</secondary>
	</indexterm>

	<para>Es folgt nun eine der Konfiguration von DHCP
	  entsprechende Konfiguration (f&uuml;r einen Client) f&uuml;r
	  <application>bootpd</application>.  Zu finden ist die
	  Konfigurationsdatei unter <filename>/etc/bootptab</filename>.
	</para>

	<para>Beachten Sie bitte, dass
	  <application>Etherboot</application> mit der Option
	  <literal>NO_DHCP_SUPPORT</literal> kompiliert werden muss,
	  damit BOOTP verwendet werden kann.  <acronym>PXE</acronym>
	  hingegen <emphasis>ben&ouml;tigt</emphasis>
	  <acronym>DHCP</acronym>.  Der einzige offensichtliche
	  Vorteil von <application>bootpd</application> ist, dass es
	  bereits im Basissystem vorhanden ist.</para>

	<programlisting>.def100:\
  :hn:ht=1:sa=192.168.4.4:vm=rfc1048:\
  :sm=255.255.255.0:\
  :ds=192.168.4.1:\
  :gw=192.168.4.1:\
  :hd="/tftpboot":\
  :bf="/kernel.diskless":\
  :rp="192.168.4.4:/data/misc/diskless":

margaux:ha=0123456789ab:tc=.def100</programlisting>
      </sect3>

      <sect3>
        <title>Ein Startprogramm unter Verwendung von
          <application>Etherboot</application> erstellen</title>

        <indexterm>
          <primary>Etherboot</primary>
        </indexterm>

	<para>Die <ulink url="http://etherboot.sourceforge.net">
	  Internetseite von Etherboot</ulink> enth&auml;lt
	  <ulink url="http://etherboot.sourceforge.net/doc/html/userman/t1.html">
          ausf&uuml;hrliche Informationen</ulink>, die zwar vor allem
          f&uuml;r Linux gedacht sind, aber dennoch n&uuml;tzliche
          Informationen enthalten.  Im Folgenden wird daher nur grob
          beschrieben, wie Sie <application>Etherboot</application> auf
          einem FreeBSD-System einsetzen k&ouml;nnen.</para>

        <para>Als Erstes m&uuml;ssen Sie
          <filename role="package">net/etherboot</filename> als Paket
          oder als Port installieren.</para>

	<para>Sie k&ouml;nnen <application>Etherboot</application> so
	  konfigurieren, dass <acronym>TFTP</acronym> anstelle von
	  <acronym>NFS</acronym> verwendet wird, indem Sie die Datei
	  <filename>Config</filename> im Quellverzeichnis von
	  <application>Etherboot</application> bearbeiten.</para>

        <para>F&uuml;r unsere Installation verwenden wir eine
          Startdiskette.  F&uuml;r Informationen zu anderen Methoden
	  (PROM oder &ms-dos;-Programme) lesen Sie bitte die
	  Dokumentation zu <application>Etherboot</application>.</para>

        <para>Um eine Startdiskette zu erzeugen, legen Sie eine Diskette
          in das Laufwerk des Rechners ein, auf dem Sie
          <application>Etherboot</application> installiert haben.  Danach
          wechseln Sie in das Verzeichnis <filename>src</filename> des
          <application>Etherboot</application>-Verzeichnisbaums und geben
          Folgendes ein:</para>

	<screen>&prompt.root; <userinput>gmake bin32/<replaceable>devicetype</replaceable>.fd0</userinput></screen>

        <para><replaceable>devicetype</replaceable> h&auml;ngt vom Typ
          der Ethernetkarte ab, &uuml;ber die der plattenlose Rechner
          verf&uuml;gt.  Lesen Sie dazu <filename>NIC</filename> im
          gleichen Verzeichnis, um den richtigen Wert f&uuml;r
        <replaceable>devicetype</replaceable> zu bestimmen.</para>
      </sect3>

      <sect3>
	<title>Das System mit <acronym>PXE</acronym> starten</title>

	<para>In der Voreinstellung l&auml;dt der
	  &man.pxeboot.8;-Loader den Kernel &uuml;ber
	  <acronym>NFS</acronym>.  Soll stattdessen
	  <acronym>TFTP</acronym> verwendet werden, muss beim
	  Kompilieren die Option
	  <literal>LOADER_TFTP_SUPPORT</literal> in der Datei
	  <filename>/etc/make.conf</filename> eingetragen sein. Sehen
	  Sie sich die Datei
	  <filename>/usr/share/examples/etc/make.conf</filename>
	  f&uuml;r weitere Anweisungen an.</para>

	<para>Es gibt zwei Optionen f&uuml;r
	  <filename>make.conf</filename>, die n&uuml;tzlich sein
	  k&ouml;nnen, wenn Sie eine plattenlose serielle Konsole
	  einrichten wollen:
	  <literal>BOOT_PXELDR_PROBE_KEYBOARD</literal>, und
	  <literal>BOOT_PXELDR_ALWAYS_SERIAL</literal>.</para>

	<para>Um <acronym>PXE</acronym> beim Systemstart zu verwenden,
	  m&uuml;ssen Sie im <acronym>BIOS</acronym> des Rechner die
	  Option <literal>&Uuml;ber das Netzwerk starten</literal>
	  aktivieren.  Alternativ k&ouml;nnen Sie w&auml;hrend der
	  PC-Initialisierung auch eine Funktionstaste dr&uuml;cken.
	</para>
      </sect3>

      <sect3>
	<title>Serverkonfiguration - <acronym>TFTP</acronym> und
	  <acronym>NFS</acronym></title>

        <indexterm>
          <primary>TFTP</primary>
          <secondary>plattenloser Betrieb</secondary>
        </indexterm>

        <indexterm>
          <primary>NFS</primary>
          <secondary>plattenloser Betrieb</secondary>
        </indexterm>

	<para>Wenn Sie <acronym>PXE</acronym> oder
	  <application>Etherboot</application> so konfiguriert haben,
	  dass diese <acronym>TFTP</acronym> verwenden, m&uuml;ssen
	  Sie auf dem Dateiserver <application>tftpd</application>
	  aktivieren:</para>

        <procedure>
          <step>
            <para>Erzeugen Sie ein Verzeichnis, in dem
	      <application>tftpd</application> seine Dateien ablegt,
              beispielsweise <filename>/tftpboot</filename>.</para>
          </step>

          <step>
            <para>F&uuml;gen Sie folgende Zeile in
              <filename>/etc/inetd.conf</filename> ein:</para>

            <programlisting>tftp    dgram   udp     wait    root  /usr/libexec/tftpd    tftpd -s /tftpboot</programlisting>

            <note><para>Anscheinend ben&ouml;tigen zumindest einige
	      <acronym>PXE</acronym>-Versionen die
	      <acronym>TCP</acronym>-Version von
	      <acronym>TFTP</acronym>.  Sollte dies bei Ihnen der
              Fall sein, f&uuml;gen Sie eine zweite Zeile ein, in der
              Sie <literal>dgram udp</literal> durch
              <literal>stream tcp</literal> ersetzen.</para>
            </note>
          </step>

          <step>
	    <para>Weisen Sie <application>inetd</application> an, seine
	      Konfiguration erneut einzulesen (Damit der folgende
	      Befehl funktioniert, muss die Option
	      <option>inetd_enable="YES"</option> in der Datei
	      <filename>/etc/rc.conf</filename> vorhanden sein.):</para>

            <screen>&prompt.root; <userinput>/etc/rc.d/inetd restart</userinput></screen>
          </step>
        </procedure>

        <para>Sie k&ouml;nnen das Verzeichnis
          <filename>/tftpboot</filename> an einem beliebigen Ort auf dem
          Server ablegen.  Stellen Sie aber sicher, dass Sie diesen Ort
          sowohl in <filename>inetd.conf</filename> als auch in
	  <filename>dhcpd.conf</filename> eingetragen haben.</para>

        <para>Au&szlig;erdem m&uuml;ssen Sie NFS aktivieren und die
          entsprechenden Verzeichnisse exportieren.</para>

        <procedure>
          <step>
            <para>F&uuml;gen Sie folgende Zeile in
              <filename>/etc/rc.conf</filename> ein:</para>

            <programlisting>nfs_server_enable="YES"</programlisting>
          </step>

          <step>
            <para>Exportieren Sie das Verzeichnis, in dem sich das
              Wurzelverzeichnis f&uuml;r den plattenlosen Betrieb
              befindet, indem Sie folgende Zeile in
              <filename>/etc/exports</filename> einf&uuml;gen (passen
	      Sie dabei den <foreignphrase>mountpoint</foreignphrase>
	      an und ersetzen Sie
	      <replaceable>margaux corbieres</replaceable> durch den
	      Namen Ihres plattenlosen Rechners):</para>

            <programlisting><replaceable>/data/misc</replaceable> -alldirs -ro <replaceable>margaux</replaceable></programlisting>
          </step>

          <step>
	    <para>Weisen sie nun <application>mountd</application> an,
	      seine Konfigurationsdatei erneut einzulesen.  Wenn Sie
	      <acronym>NFS</acronym> erst in der Datei
	      <filename>/etc/rc.conf</filename> aktivieren mussten,
              sollten Sie stattdessen den Rechner neu starten.  Dadurch
              wird die Konfigurationsdatei ebenfalls neu eingelesen.
            </para>

            <screen>&prompt.root; <userinput>/etc/rc.d/mountd restart</userinput></screen>
          </step>
        </procedure>
      </sect3>

      <sect3>
        <title>Einen plattenlosen Kernel erzeugen</title>

        <indexterm>
          <primary>plattenloser Betrieb</primary>
          <secondary>Kernelkonfiguration</secondary>
        </indexterm>

	<para>Wenn Sie <application>Etherboot</application> verwenden,
	  m&uuml;ssen Sie in die Kernelkonfigurationsdatei Ihres
	  plattenlosen Clients zus&auml;tzlich folgende Optionen
	  einf&uuml;gen:</para>

        <programlisting>options     BOOTP          # Use BOOTP to obtain IP address/hostname
options     BOOTP_NFSROOT  # NFS mount root file system using BOOTP info</programlisting>

        <para>Au&szlig;erdem k&ouml;nnen Sie die Optionen
	  <literal>BOOTP_NFSV3</literal>,
	  <literal>BOOT_COMPAT</literal> sowie
          <literal>BOOTP_WIRED_TO</literal> verwenden (sehen Sie sich
	  dazu auch die Datei <filename>NOTES</filename> an).</para>

	 <para>Die Namen dieser Optionen sind historisch bedingt.
	   Sie erm&ouml;glichen eine unterschiedliche Verwendung von
	   <acronym>DHCP</acronym> und BOOTP innerhalb des Kernels.
	   Es ist auch m&ouml;glich, eine strikte Verwendung von BOOTP
	   oder <acronym>DHCP</acronym> zu erzwingen.</para>

        <para>Erzeugen Sie den neuen Kernel (lesen Sie dazu auch
	  <xref linkend="kernelconfig">) und kopieren Sie ihn an den
	  in <filename>dhcpd.conf</filename> festgelegten Ort.</para>

	<note><para>Wenn Sie <acronym>PXE</acronym> verwenden, ist die
	    Erzeugung eines Kernels zwar nicht unbedingt n&ouml;tig, sie
	    wird allerdings dennoch empfohlen.  Die Aktivierung dieser
	    Optionen bewirkt, dass die Anzahl der m&ouml;glichen
	    <acronym>DHCP</acronym>-Anforderungen w&auml;hrend des
	    Kernelstarts erh&ouml;ht wird.  Ein kleiner Nachteil sind
	    eventuell auftretende Inkonsistenzen zwischen den neuen
	    Werten und den von &man.pxeboot.8; erhaltenen Werten.  Der
	    gro&szlig;e Vorteil dieser Variante ist es, dass dabei der
	    Rechnername gesetzt wird, den Sie ansonsten durch eine
	    andere Methode, beispielsweise in einer clientspezifischen
	    <filename>rc.conf</filename>-Datei festlegen m&uuml;ssten.
	  </para>
	</note>

	<note><para>Damit der Kernel von
	    <application>Etherboot</application> geladen werden kann,
	    m&uuml;ssen <foreignphrase>device hints</foreignphrase> im
	    Kernel einkompiliert sein.  Dazu setzen Sie normalerweise
	    folgende Option in die Kernelkonfigurationsdatei (sehen Sie
	    sich dazu auch die kommentierte Datei
	    <filename>NOTES</filename> an):</para>

	  <programlisting>hints         "GENERIC.hints"</programlisting>
	</note>
      </sect3>

      <sect3>
        <title>Das root-Dateisystem erzeugen</title>

        <indexterm>
          <primary>Root-Dateisystem</primary>
	  <secondary>plattenloser Betrieb</secondary>
        </indexterm>

        <para>Sie m&uuml;ssen f&uuml;r den plattenlosen Rechner ein
          root-Dateisystem erzeugen, und zwar an dem in
          <filename>dhcpd.conf</filename> als
	  <literal>root-path</literal> festgelegten Ort.</para>

	<sect4>
	  <title><command>make world</command> zum F&uuml;llen des
	    Dateisystems einsetzen</title>

	  <para>Diese schnelle Methode installiert ein komplettes
	    <quote>jungfr&auml;uliches</quote> System (und nicht nur ein
	    root-Dateisystem) nach <envar>DESTDIR</envar>.  Dazu
	    m&uuml;ssen Sie lediglich das folgende Skript
	    ausf&uuml;hren:</para>

	  <programlisting>#!/bin/sh
export DESTDIR=/data/misc/diskless
mkdir -p ${DESTDIR}
cd /usr/src; make buildworld &amp;&amp; make buildkernel
make installworld &amp;&amp; make installkernel
cd /usr/src/etc; make distribution</programlisting>

	  <para>Danach m&uuml;ssen Sie noch die dadurch in
	    <envar>DESTDIR</envar> erzeugten Dateien
	    <filename>/etc/rc.conf</filename> sowie
	    <filename>/etc/fstab</filename> Ihren W&uuml;nschen
	    anpassen.</para>
	</sect4>
      </sect3>

      <sect3>
        <title>Den Auslagerungsbereich konfigurieren</title>

	<para>Falls n&ouml;tig, kann eine auf dem
	  <acronym>NFS</acronym>-Server liegende Datei als
	  Auslagerungsdatei eingerichtet werden.</para>

	<sect4>
	  <title>Eine <acronym>NFS</acronym>-Auslagerungsdatei
	    einrichten</title>

	  <para>Der Kernel unterst&uuml;tzt beim Systemstart keine
	    <acronym>NFS</acronym>-Auslagerungsdatei.  Diese muss daher
	    in den Startskripten aktiviert werden, indem ein
	    beschreibbares Dateisystem eingeh&auml;ngt wird, um dort
	    die Auslagerungsdatei zu erzeugen und zu aktivieren.  Um
	    eine Auslagerungsdatei zu erzeugen, gehen Sie wie folgt
	    vor:</para>

	  <screen>&prompt.root; <userinput>dd if=/dev/zero of=<replaceable>/path/to/swapfile</replaceable> bs=1k count=1 oseek=<replaceable>100000</replaceable></userinput></screen>

	  <para>Um die Auslagerungsdatei zu aktivieren, f&uuml;gen Sie
	    folgende Zeile in <filename>rc.conf</filename> ein:</para>

	  <programlisting>swapfile=<replaceable>/path/to/swapfile</replaceable></programlisting>
	</sect4>
      </sect3>

      <sect3>
        <title>Verschiedenes</title>

        <sect4>
          <title>Schreibgesch&uuml;tztes Dateisystem
	    <filename>/usr</filename></title>

          <indexterm>
            <primary>plattenloser Betrieb</primary>
            <secondary>/usr schreibgesch&uuml;tzt</secondary>
          </indexterm>

          <para>Wenn am plattenlosen Rechner X l&auml;uft, m&uuml;ssen
            Sie die Konfigurationsdatei von
            <application>XDM</application> anpassen, da Fehlermeldungen
            in der Voreinstellung auf <filename>/usr</filename>
            geschrieben werden.</para>
        </sect4>

        <sect4>
          <title>Der Server l&auml;uft nicht unter FreeBSD</title>

	  <para>Wenn das root-Dateisystem nicht auf einem
	    FreeBSD-Rechner liegt, muss das Dateisystem zuerst unter
	    FreeBSD erzeugt werden.  Anschlie&szlig;end wird es
	    beispielsweise mit <command>tar</command> oder
	    <command>cpio</command> an den gew&uuml;nschten Ort
	    kopiert.</para>

	  <para>Dabei kann es Probleme mit den Ger&auml;tedateien
	    in <filename>/dev</filename> geben, die durch eine
	    unterschiedliche Darstellung der  Major- und Minor-Number
	    von Ger&auml;ten auf beiden Systemen hervorgerufen werden.
	    Eine Probleml&ouml;sung besteht darin, das root-Verzeichnis
	    auf einem FreeBSD-Rechner einzuh&auml;ngen und die
	    Ger&auml;tedateien dort mit &man.devfs.5; zu erzeugen.</para>
        </sect4>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="network-isdn">
    <title>ISDN &ndash; diensteintegrierendes digitales Netzwerk</title>

    <indexterm>
      <primary>ISDN</primary>
    </indexterm>

    <para>Eine gute Quelle f&uuml;r Informationen zu ISDN ist die
      <ulink url="http://www.alumni.caltech.edu/~dank/isdn/">
      ISDN-Seite</ulink> von Dan Kegel.</para>

    <para>Welche Informationen finden Sie in diesem Abschnitt?</para>

    <itemizedlist>
      <listitem>
        <para>Wenn Sie in Europa leben, k&ouml;nnte der Abschnitt
          &uuml;ber ISDN-Karten f&uuml;r Sie interessant sein.</para>
      </listitem>

      <listitem>
        <para>Wenn Sie ISDN haupts&auml;chlich dazu verwenden wollen, um
          sich &uuml;ber einen Anbieter ins Internet einzuw&auml;hlen,
          sollten Sie den Abschnitt &uuml;ber Terminaladapter lesen.
          Dies ist die flexibelste Methode, die auch die wenigsten
          Probleme verursacht.</para>
      </listitem>

      <listitem>
        <para>Wenn Sie zwei Netzwerke miteinander verbinden, oder sich
          &uuml;ber eine ISDN-Standleitung mit dem Internet verbinden
          wollen, finden Sie entsprechende Informationen im Abschnitt
          &uuml;ber Router und Bridges.</para>
      </listitem>
    </itemizedlist>

    <para>Bei der Wahl der gew&uuml;nschten L&ouml;sung sind die
      entstehenden Kosten ein entscheidender Faktor.  Die folgenden
      Beschreibungen reichen von der billigsten bis zur teuersten
      Variante.</para>

    <sect2 id="network-isdn-cards">
      <sect2info>
        <authorgroup>
          <author>
            <firstname>Hellmuth</firstname>
            <surname>Michaelis</surname>
            <contrib>Beigetragen von </contrib>
          </author>
        </authorgroup>
      </sect2info>

      <title>ISDN-Karten</title>

      <indexterm>
        <primary>ISDN</primary>
        <secondary>Karten</secondary>
      </indexterm>

      <para>Das ISDN-Subsystem von FreeBSD unterst&uuml;tzt den
        DSS1/Q.931- (oder Euro-ISDN)-Standard nur f&uuml;r passive
        Karten.  Zus&auml;tzlich werden aber auch einige
        aktive Karten unterst&uuml;tzt, bei denen die Firmware auch
        andere Signalprotokolle unterst&uuml;tzt;  dies schlie&szlig;t
        auch die erste ISDN-Karte mit
        Prim&auml;rmultiplex-Unterst&uuml;tzung mit ein.</para>

      <para><application>isdn4bsd</application> erm&ouml;glicht es
	Ihnen, sich unter Nutzung von
	<emphasis>IP over raw HDLC</emphasis> oder
        <emphasis>synchronem PPP</emphasis> mit anderen ISDN-Routern zu
        verbinden.  Dazu verwenden Sie entweder Kernel-&man.ppp.8;
	(via <literal>isppp</literal>, einem modifizierten
	sppp-Treiber), oder Sie benutzen User-&man.ppp.8;.  Wenn Sie
	User-&man.ppp.8; verwenden, k&ouml;nnen Sie zwei oder mehrere
	ISDN-B-Kan&auml;le b&uuml;ndeln.  Im Paket enthalten ist auch
	ein Programm mit Anrufbeantworterfunktion sowie verschiedene
	Werkzeuge, wie ein Softwaremodem, das 300&nbsp;Baud
	unterst&uuml;tzt.</para>

      <para>FreeBSD unterst&uuml;tzt eine st&auml;ndig wachsende Anzahl
        von PC-ISDN-Karten, die weltweit erfolgreich eingesetzt werden.
      </para>

      <para>Von FreeBSD unterst&uuml;tzte passive ISDN-Karten enthalten
        fast immer den ISAC/HSCX/IPAC ISDN-Chipsatz von Infineon
        (ehemals Siemens).  Unterst&uuml;tzt werden aber auch Karten mit
        Cologne Chip (diese allerdings nur f&uuml;r den ISA-Bus),
        PCI-Karten mit Winbond W6692 Chipsatz, einige Karten mit dem
        Tiger 300/320/ISAC Chipsatz sowie einige Karten mit einem
        herstellerspezifischen Chipsatz, wie beispielsweise die
        Fritz!Card PCI V.1.0 und die Fritz!Card PnP von AVM.</para>

      <para>An aktiven ISDN-Karten werden derzeit die AVM B1 BRI-Karten
        (ISA und PCI-Version) sowie die AVM T1 PRI-Karten (PCI-Version)
        unterst&uuml;tzt.</para>

      <para>Informationen zu <application>isdn4bsd</application> finden
	Sie auf der
        <ulink url="http://www.freebsd-support.de/i4b/">Internetseite</ulink>
        von <application>isdn4bsd</application>.  Dort finden Sie auch
        Verweise zu Tipps, Korrekturen, sowie weiteren Informationen,
        wie dem
        <ulink url="http://people.FreeBSD.org/~hm/">isdn4bsd-Handbuch</ulink>.
      </para>

      <para>Falls Sie an der Unterst&uuml;tzung eines zus&auml;tzlichen
        ISDN-Protokolls, einer weiteren ISDN-Karte oder an einer anderen
        Erweiterung von <application>isdn4bsd</application> interessiert
        sind, wenden Sie sich bitte an &a.hm;.</para>

      <para>F&uuml;r Fragen zur Installation, Konfiguration und zu
        sonstigen Problemen von <application>isdn4bsd</application> gibt
        es die Mailingliste &a.isdn.name;.</para>
    </sect2>

    <sect2>
      <title>ISDN-Terminaladapter</title>

      <indexterm>
        <primary>Terminaladapter</primary>
      </indexterm>

      <para>Terminaladapter (TA) sind f&uuml;r ISDN, was Modems f&uuml;r
        analoge Telefonleitungen sind.</para>

      <indexterm>
        <primary>Modem</primary>
      </indexterm>

      <para>Die meisten Terminaladapter verwenden den
	Standardbefehlssatz f&uuml;r Modems von Hayes (AT-Kommandos) und
	k&ouml;nnen daher als Modemersatz verwendet werden.</para>

      <para>Ein Terminaladapter funktioniert prinzipiell wie ein Modem,
	allerdings erfolgt der Verbindungsaufbau um einiges schneller.
	Die Konfiguration von <link linkend="ppp">PPP</link> entspricht
	dabei exakt der eines Modems.  Stellen Sie dabei allerdings
	die serielle Geschwindigkeit so hoch wie m&ouml;glich ein.
      </para>

      <indexterm>
        <primary>PPP</primary>
      </indexterm>

      <para>Der Hauptvorteil bei der Verwendung eines Terminaladapters
	zur Verbindung mit einem Internetanbieter ist die
	M&ouml;glichkeit zur Nutzung von dynamischem PPP.  Da
	IP-Adressen immer knapper werden, vergeben die meisten Provider
	keine statischen IP-Adressen mehr.  Die meisten Router
	unterst&uuml;tzen allerdings keine dynamische Zuweisung von
	IP-Adressen.</para>

      <para>Der PPP-Daemon bestimmt die Stabilit&auml;t und
	Eigenschaften der Verbindung, wenn Sie einen Terminaladapter
	verwenden.  Daher k&ouml;nnen Sie unter FreeBSD einfach von
	einer Modemverbindung auf eine ISDN-Verbindung wechseln, wenn
	Sie PPP bereits konfiguriert haben.  Allerdings bedeutet
	dies auch, das bereits bestehende Probleme mit PPP auch unter
	ISDN auftreten werden.</para>

      <para>Wenn Sie an maximaler Stabilit&auml;t interessiert sind,
        verwenden Sie Kernel-<link linkend="ppp">PPP</link>, und
	nicht das <link linkend="userppp">User-PPP</link>.</para>

      <para>Folgende Terminaladapter werden von FreeBSD
	unterst&uuml;tzt:</para>

      <itemizedlist>
        <listitem>
          <para>Motorola BitSurfer und Bitsurfer Pro</para>
        </listitem>

        <listitem>
          <para>Adtran</para>
        </listitem>
      </itemizedlist>

      <para>Die meisten anderen Terminaladapter werden wahrscheinlich
	ebenfalls funktionieren, da die Hersteller von Terminaladaptern
	darauf achten, dass ihre Produkte den Standardbefehlssatz
	m&ouml;glichst gut unterst&uuml;tzen.</para>

      <para>Das wirkliche Problem mit einem externen Terminaladapter ist,
        dass, &auml;hnlich wie bei Modems, eine gute serielle Karte
        eine Grundvoraussetzung ist.</para>

      <para>Sie sollten sich die
        <ulink url="&url.articles.serial-uart.en;/index.html">
        Anleitung f&uuml;r die Nutzung serieller Ger&auml;te unter
        FreeBSD</ulink> ansehen, wenn Sie detaillierte Informationen
        &uuml;ber serielle Ger&auml;te und die Unterschiede zwischen
	asynchronen und synchronen seriellen Ports ben&ouml;tigen.
      </para>

      <para>Ein Terminaladapter, der an einem (asynchronen)
	seriellen Standardport angeschlossen ist, beschr&auml;nkt
	Sie auf 115,2&nbsp;Kbs.  Dies
        selbst dann, wenn Sie eine Verbindung mit 128&nbsp;Kbs haben.
        Um die volle Leistungsf&auml;higkeit von ISDN (128&nbsp;Kbs)
        nutzen zu k&ouml;nnen, m&uuml;ssen Sie den Terminaladapter
	daher an eine synchrone serielle Karte anschlie&szlig;en.</para>

      <para>Kaufen Sie keinen internen Terminaladapter in der Hoffnung,
        damit das synchron/asynchron-Problem vermeiden zu k&ouml;nnen.
	Interne Terminaladapter haben einen (asynchronen) seriellen
	Standardportchip eingebaut.  Der einzige Vorteil interner
	Terminaladapter ist es, dass Sie ein serielles sowie ein
	Stromkabel weniger ben&ouml;tigen.</para>

      <para>Eine synchrone Karte mit einem Terminaladapter ist
	mindestens so schnell wie ein autonomer ISDN-Router,
	und, in Kombination mit einem einfachen 386-FreeBSD-System,
	wahrscheinlich flexibler.</para>

      <para>Die Entscheidung zwischen synchroner Karte/Terminaladapter
	und einem autonomen ISDN-Router ist beinahe eine religi&ouml;se
        Angelegenheit.  Zu diesem Thema gibt es viele Diskussionen
        in den Mailinglisten.  Suchen Sie in den
        <ulink url="&url.base;/search/index.html"> Archiven</ulink>
        danach, wenn Sie an der kompletten Diskussion interessiert
        sind.</para>
    </sect2>

    <sect2>
      <title>ISDN-Bridges und Router</title>

      <indexterm>
        <primary>ISDN</primary>
        <secondary>Autonome Bridge/Router</secondary>
      </indexterm>

      <para>ISDN-Bridges und Router sind keine Eigenheit von
        FreeBSD oder eines anderen Betriebssystems.  F&uuml;r eine
        vollst&auml;ndigere Beschreibung von Routing und
        Netzwerkkopplungen mit einer Bridge informieren Sie sich
        bitte durch weiterf&uuml;hrende Literatur.</para>

      <para>In diesem Abschnitt werden die Begriffe Router und
        Bridge synonym verwendet.</para>

      <para>ISDN-Router und Bridges werden immer g&uuml;nstiger und
	damit auch immer beliebter.  Ein ISDN-Router ist eine kleine
	Box, die direkt an Ihr lokales Ethernet-Netzwerk angeschlossen
	wird und sich mit einem Router oder einer Bridge verbindet.
	Die eingebaute Software erm&ouml;glicht die Kommunikation
	&uuml;ber PPP oder andere beliebte Protokolle.</para>

      <para>Ein Router erm&ouml;glicht einen deutlich h&ouml;heren
        Datendurchsatz als ein herk&ouml;mmlicher Terminaladapter,
	da er eine vollsynchrone ISDN-Verbindung nutzt.</para>

      <para>Das Hauptproblem mit ISDN-Routern und Bridges ist,
        dass die Zusammenarbeit zwischen Ger&auml;ten verschiedener
        Hersteller nach wie vor ein Problem ist.  Wenn Sie sich auf
        diese Weise mit einem Internetanbieter verbinden wollen,
        kl&auml;ren Sie daher vorher ab, welche Anforderungen Ihre
        Ger&auml;te erf&uuml;llen m&uuml;ssen.</para>

      <para>Eine ISDN-Bridge ist eine einfache und wartungsarme
	L&ouml;sung, zwei Netze, beispielsweise Ihr privates Netz
	und Ihr Firmennetz, miteinander zu verbinden.  Da Sie die
        technische Ausstattung f&uuml;r beide Seiten kaufen m&uuml;ssen,
        ist sichergestellt, dass die Verbindung funktionieren
        wird.</para>

      <para>Um beispielsweise einen privaten Computer oder eine
        Zweigstelle mit dem Hauptnetzwerk zu verbinden, k&ouml;nnte
        folgende Konfiguration verwendet werden:</para>

      <example>
        <title>Kleines Netzwerk (Privatnetz)</title>

        <indexterm>
          <primary>10 base 2</primary>
        </indexterm>

        <para>Das Netzwerk basiert auf der Bustopologie mit 10base2
          Ethernet (<quote>Thinnet</quote>).  Falls n&ouml;tig, stellen
          Sie die Verbindung zwischen Router und Netzwerkkabel mit einem
          AUI/10BT-Transceiver her.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="advanced-networking/isdn-bus">
          </imageobject>

          <textobject>
            <literallayout class="monospaced">
---Sun Workstation
|
---FreeBSD Rechner
|
---Windows 95
|
Autonomer Router
   |
ISDN BRI Verbindung
            </literallayout>
          </textobject>

          <textobject>
            <phrase>10Base2 - Ethernet</phrase>
          </textobject>
        </mediaobject>

        <para>Wenn Sie nur einen einzelnen Rechner verbinden wollen,
          k&ouml;nnen Sie auch ein Twisted-Pair-Kabel (Cross-Over)
          verwenden, das direkt an den Router angeschlossen wird.</para>
      </example>

      <example>
        <title>Gro&szlig;es Netzwerk (Firmennetz)</title>

        <indexterm>
          <primary>10 base T</primary>
        </indexterm>

        <para>Dieses Netzwerk basiert auf der Sterntopologie und 10baseT
          Ethernet (<quote>Twisted Pair</quote>).</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="advanced-networking/isdn-twisted-pair">
          </imageobject>

          <textobject>
            <literallayout class="monospaced">
-------Novell Server
    | H |
    |   ---Sun
    |   |
    | U ---FreeBSD
    |   |
    |   ---Windows 95
    | B |
    |___---Autonomer Router
                |
        ISDN BRI Verbindung
            </literallayout>
          </textobject>

          <textobject>
            <phrase>ISDN Netzwerkdiagramm</phrase>
          </textobject>
        </mediaobject>
      </example>

      <para>Ein gro&szlig;er Vorteil der meisten Router und Bridges
	ist es, dass man <emphasis>gleichzeitig</emphasis> zwei
	<emphasis>unabh&auml;ngige</emphasis> PPP-Verbindungen
	zu zwei verschiedenen Zielen aufbauen kann.  Diese
        Funktion bieten die meisten Terminaladapter nicht.  Die
        Ausnahme sind spezielle (meist teure) Modelle, die &uuml;ber
        zwei getrennte serielle Ports verf&uuml;gen.  Verwechseln Sie
        dies aber nicht mit Kanalb&uuml;ndelung oder MPP.</para>

      <para>Dies kann sehr n&uuml;tzlich sein, wenn Sie eine
        ISDN-Standleitung in Ihrem B&uuml;ro haben, die sie
        aufteilen wollen, ohne eine zus&auml;tzliche ISDN-Leitung
        zu installieren.  Ein ISDN-Router kann &uuml;ber einen B-Kanal
        (64&nbsp;Kbps) eine dedizierte Verbindung ins Internet aufbauen,
        und gleichzeitig den anderen B-Kanal f&uuml;r eine separate
        Datenverbindung nutzen.  Der zweite B-Kanal kann beispielsweise
        f&uuml;r ein- oder ausgehende Verbindungen verwendet werden.
        Sie k&ouml;nnen ihn aber auch dynamisch mit dem ersten B-Kanal
        b&uuml;ndeln, um Ihre Bandbreite zu erh&ouml;hen.</para>

      <indexterm>
        <primary>IPX/SPX</primary>
      </indexterm>

      <para>Eine Ethernet-Bridge kann Daten nicht nur im IP-Protokoll,
        sondern auch in beliebigen anderen Protokollen versenden.</para>
    </sect2>
  </sect1>

  <sect1 id="network-natd">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Chern</firstname>
          <surname>Lee</surname>
          <contrib>Beigetragen von </contrib>
        </author>
      </authorgroup>
    </sect1info>

    <title>NAT - Network Address Translation</title>

    <sect2 id="network-natoverview">
      <title>&Uuml;berblick</title>

      <indexterm>
        <primary><application>natd</application></primary>
      </indexterm>

      <para>&man.natd.8;, der Network-Address-Translation-Daemon von
        FreeBSD, akzeptiert ankommende Raw-IP-Pakete, &auml;ndert den
        Sender der Daten in den eigenen Rechner und leitet diese Pakete
        in den ausgehenden IP-Paketstrom um, indem IP-Adresse und Port
        des Senders so ge&auml;ndert werden, dass bei einer Antwort der
        urspr&uuml;ngliche Sender wieder bestimmt und die Daten an
        ihn weitergeleitet werden k&ouml;nnen.</para>

      <indexterm><primary>Internet connection sharing</primary></indexterm>

      <indexterm><primary>NAT</primary></indexterm>

      <para>Der h&auml;ufigste Grund f&uuml;r die Verwendung von NAT ist
        die gemeinsame Nutzung einer Internetverbindung.</para>
    </sect2>

    <sect2 id="network-natsetup">
      <title>Einrichtung</title>

      <para>Wegen der begrenzten Verf&uuml;gbarkeit von IPv4-Adressen
        und der gestiegenen Anzahl von Breitbandverbindungen &uuml;ber
        Kabelmodem oder DSL, wird die gemeinsame Nutzung von
        Internetverbindungen immer wichtiger.  Der &man.natd.8;-Daemon
        erm&ouml;glicht die Anbindung von mehreren Rechnern an das
        Internet unter Nutzung einer gemeinsamen Verbindung und einer
        IP-Adresse.</para>

      <para>H&auml;ufig soll ein &uuml;ber Kabelmodem oder DSL und eine
        IP-Adresse an das Internet angebundener Rechner mehreren
        Rechnern eines lokalen Netzwerks Internetdienste anbieten.</para>

      <para>Um dies zu erm&ouml;glichen, muss der FreeBSD-Rechner als
        Gateway fungieren.  Dazu sind zwei Netzwerkkarten notwendig.  Eine
        f&uuml;r die Verbindung zum Internet, die zweite f&uuml;r die
        Verbindung mit dem lokalen Netzwerk.  S&auml;mtliche Rechner
        des lokalen Netzwerks sind &uuml;ber einen Hub oder einen Switch
        miteinander verbunden.</para>

      <note>
        <para>Es gibt verschiedene M&ouml;glichkeiten, ein LAN &uuml;ber
          ein &os;-Gateway an das Internet anzubinden.  Das folgende
          Beispiel beschreibt ein Gateway, das zumindest zwei
          Netzwerkkarten enth&auml;lt.</para>
      </note>

      <mediaobject>
        <imageobject>
          <imagedata fileref="advanced-networking/natd">
        </imageobject>

        <textobject>
         <literallayout class="monospaced">  _______       __________       ________
 |       |     |          |     |        |
 |  Hub  |-----| Client B |-----| Router |----- Internet
 |_______|     |__________|     |________|
     |
 ____|_____
|          |
| Client A |
|__________|</literallayout>
        </textobject>

        <textobject>
          <phrase>Network Layout</phrase>
        </textobject>
      </mediaobject>

      <para>Eine derartige Netzwerkkonfiguration wird vor allem zur
        gemeinsamen Nutzung einer Internetverbindung verwendet.  Ein
        Rechner des lokalen Netzwerks (<acronym>LAN</acronym>) ist mit
        dem Internet verbunden.  Alle anderen Rechner des lokalen
        Netzwerks haben nur &uuml;ber diesen
        <quote>Gateway</quote>-Rechner Zugriff auf das Internet.</para>
    </sect2>

    <sect2 id="network-natdloaderconfiguration">
      <indexterm>
        <primary>boot loader</primary>
        <secondary>configuration</secondary>
      </indexterm>

      <title>Boot Loader Konfiguration</title>

      <para>Die Kerneleigenschaften f&uuml;r Network Address Translation mit
        &man.natd.8; sind im <filename>GENERIC</filename>-Kernel nicht
        aktiviert, k&ouml;nnen aber bereits zur Bootzeit geladen werden, indem
        ein paar Zeilen in die Datei <filename>/boot/loader.conf</filename>
        hinzugef&uuml;gt werden:</para>

      <programlisting>ipfw_load="YES"
ipdivert_load="YES"</programlisting>

      <para>Zus&auml;tzlich kann die Option
        <literal>net.inet.ip.fw.default_to_accept</literal> auf
        <literal>1</literal> gesetzt werden:</para>

      <programlisting>net.inet.ip.fw.default_to_accept="1"</programlisting>

      <note>
        <para>Es ist eine gute Idee, diese Option w&auml;hrend den ersten
          Versuchen, eine Firewall und ein NAT-Gateway aufzusetzen, zu
          aktivieren.  Damit ist die Standardvorgehensweise von &man.ipfw.8;
          diejenige, <literal>allow ip from any to any</literal>, anstatt der
          weniger freiz&uuml;gigen <literal>deny ip from any to any</literal>.
          Es wird dadurch etwas schwieriger, sich aus Versehen nach einem
          Neustart aus dem System auszusperren.</para>
      </note>
    </sect2>

    <sect2 id="network-natdkernconfiguration">
      <title>Kernelkonfiguration</title>
      <indexterm>
        <primary>Kernel</primary>
        <secondary>Konfiguration</secondary>
      </indexterm>

      <para>Wenn Module nicht in Frage kommen oder Sie bevorzugen, alle
        notwendigen Eigenschaften in den laufenden Kernel einzubauen,
        m&uuml;ssen die folgenden Optionen in die Kernelkonfigurationsdatei
        eingetragen werden:</para>

      <programlisting>options IPFIREWALL
options IPDIVERT</programlisting>

      <para>Die folgende Optionen k&ouml;nnen ebenfalls eingetragen
        werden:</para>

       <programlisting>options IPFIREWALL_DEFAULT_TO_ACCEPT
options IPFIREWALL_VERBOSE</programlisting>
    </sect2>

    <sect2 id="network-natdsystemconfiguration">
      <title>System Bootkonfiguration</title>

      <para>Um Firewall- und NAT-Unterst&uuml;tzung zur Bootzeit zu aktivieren,
        tragen Sie Folgendes in <filename>/etc/rc.conf</filename> ein:</para>

      <programlisting>gateway_enable="YES" <co id="co-natd-gateway-enable">
firewall_enable="YES" <co id="co-natd-firewall-enable">
firewall_type="OPEN" <co id="co-natd-firewall-type">
natd_enable="YES"
natd_interface="<replaceable>fxp0</replaceable>" <co id="co-natd-natd-interface">
natd_flags="" <co id="co-natd-natd-flags"></programlisting>

      <calloutlist>
        <callout arearefs="co-natd-gateway-enable">
          <para>Richtet den Rechner als Gateway ein.  Die
            Ausf&uuml;hrung von
            <command>sysctl net.inet.ip.forwarding=1</command>
            h&auml;tte den gleichen Effekt.</para>
        </callout>

        <callout arearefs="co-natd-firewall-enable">
          <para>Aktiviert die Firewallregeln in
            <filename>/etc/rc.firewall</filename> beim
            Systemstart.</para>
        </callout>

        <callout arearefs="co-natd-firewall-type">
          <para>Ein vordefinierter Satz von Firewallregeln, der alle
            Pakete durchl&auml;sst.  Sehen Sie sich
            <filename>/etc/rc.firewall</filename> an, wenn Sie diese
            Option verwenden wollen.</para>
        </callout>

        <callout arearefs="co-natd-natd-interface">
          <para>Die Netzwerkkarte, die Pakete weiterleitet (und mit dem
            Internet verbunden ist).</para>
        </callout>

        <callout arearefs="co-natd-natd-flags">
          <para>Zus&auml;tzliche Konfigurationsoptionen, die beim
            Systemstart an &man.natd.8; &uuml;bergeben werden.</para>
        </callout>
      </calloutlist>

      <para>Durch die Definition dieser Optionen in
        <filename>/etc/rc.conf</filename> wird die Anweisung
        <command>natd -interface fxp0</command> beim Systemstart
        ausgef&uuml;hrt.  Dies kann aber auch manuell erfolgen.</para>

      <note>
        <para>Falls Sie viele Optionen an &man.natd.8; &uuml;bergeben
          m&uuml;ssen, k&ouml;nnen Sie auch eine Konfigurationsdatei
          verwenden.  Dazu f&uuml;gen Sie folgende Zeile in
          <filename>/etc/rc.conf</filename> ein:</para>

      <programlisting>natd_flags="-f /etc/natd.conf"</programlisting>

      <para>Die Datei <filename>/etc/natd.conf</filename> enth&auml;lt
        verschiedene Konfigurationsoptionen, wobei jede Option in einer
        Zeile steht.  Das Beispiel im n&auml;chsten Abschnitt w&uuml;rde
        folgende Konfigurationsdatei verwenden:</para>

      <programlisting>redirect_port tcp 192.168.0.2:6667 6667
redirect_port tcp 192.168.0.3:80 80</programlisting>

      <para>Wenn Sie eine Konfigurationsdatei verwenden wollen, sollten
        Sie sich die Handbuchseite zu &man.natd.8; durchlesen,
        insbesondere den Abschnitt &uuml;ber die Nutzung der Option
        <option>-f</option>.</para>
      </note>

      <para>Jedem Rechner und jeder Schnittstelle des lokalen Netzwerks
        sollte eine IP-Adresse des im <ulink
        url="ftp://ftp.isi.edu/in-notes/rfc1918.txt">RFC 1918</ulink>
        definierten privaten Adressraums zugewiesen werden.  Der
        Standardgateway entspricht der internen IP-Adresse des
        <application>natd</application>-Rechners.</para>

      <para>Im Beispiel werden den LAN-Clients <hostid>A</hostid> und
        <hostid>B</hostid> die IP-Adressen
        <hostid role="ipaddr">192.168.0.2</hostid> und
        <hostid role="ipaddr">192.168.0.3</hostid> zugewiesen,
        w&auml;hrend die LAN-Netzwerkkarte des
        <application>natd</application>-Rechners die IP-Adresse
        <hostid role="ipaddr">192.168.0.1</hostid> erh&auml;lt.  Der
        <application>natd</application>-Rechner mit der IP-Adresse
        <hostid role="ipaddr">192.168.0.1</hostid> wird als
        Standardgateway f&uuml;r die Clients <hostid>A</hostid> und
        <hostid>B</hostid> gesetzt.  Die externe Netzwerkkarte des
        <application>natd</application>-Rechners muss f&uuml;r die
        korrekte Funktion von &man.natd.8; nicht konfiguriert
        werden.</para>
    </sect2>

    <sect2 id="network-natdport-redirection">
      <title>Ports umleiten</title>

      <para>Wenn Sie &man.natd.8; verwenden, sind Ihre LAN-Clients von
        aussen nicht erreichbar.  LAN-Clients k&ouml;nnen zwar
        Verbindungen nach aussen aufbauen, sind aber f&uuml;r
        ankommende Verbindungen nicht erreichbar.  Wenn Sie
        Internetdienste auf einem LAN-Client anbieten wollen, haben Sie
        daher ein Problem.  Eine einfache L&ouml;sung ist die Umleitung
        von bestimmten Internetports des
        <application>natd</application>-Rechners auf einen LAN-Client.</para>

      <para>Beispielsweise k&ouml;nnte ein IRC-Server auf Client
        <hostid>A</hostid> und ein Webserver auf Client
        <hostid>B</hostid> laufen.  Damit diese Konfiguration
        funktioniert, m&uuml;ssen Verbindungen, die auf den Ports 6667
        (IRC) und 80 (Web) ankommen, auf die entsprechenden Clients
        umgeleitet werden.</para>

      <para>Dazu wird die Option <option>-redirect_port</option> unter
        Nutzung folgender Syntax an &man.natd.8; &uuml;bergeben:</para>

      <programlisting>     -redirect_port proto targetIP:targetPORT[-targetPORT]
                 [aliasIP:]aliasPORT[-aliasPORT]
                 [remoteIP[:remotePORT[-remotePORT]]]</programlisting>

      <para>F&uuml;r unser Beispiel hei&szlig;t das:</para>

      <programlisting>    -redirect_port tcp 192.168.0.2:6667 6667
    -redirect_port tcp 192.168.0.3:80 80</programlisting>

      <para>Dadurch werden die entsprechenden
        <emphasis>tcp</emphasis>-Ports auf die jeweiligen LAN-Clients
        umgeleitet.</para>

      <para>Mit <option>-redirect_port</option> k&ouml;nnen auch ganze
        Portbereiche statt einzelner Ports umgeleitet werden.  So werden
        mit <replaceable>tcp 192.168.0.2:2000-3000
        2000-3000</replaceable> alle Verbindungen, die auf den Ports
        2000 bis 3000 ankommen, auf die entsprechenden Ports des Clients
        <hostid>A</hostid> umgeleitet.</para>

      <para>Diese Optionen k&ouml;nnen w&auml;hrend des Betriebs von
        &man.natd.8; oder &uuml;ber die Option
        <literal>natd_flags=""</literal> in
        <filename>/etc/rc.conf</filename> gesetzt werden.</para>

      <para>Eine ausf&uuml;hrliche Konfigurationsanleitung finden Sie
        in &man.natd.8;.</para>
    </sect2>

    <sect2 id="network-natdaddress-redirection">
      <title>Adressen umleiten</title>

      <indexterm><primary>address redirection</primary></indexterm>

      <para>Die Umleitung von Adressen ist n&uuml;tzlich, wenn mehrere
        IP-Adressen verf&uuml;gbar sind, die aber alle auf einem Rechner
        verbleiben sollen.  In diesem Fall kann &man.natd.8; jedem
        LAN-Client eine eigene externe IP-Adresse zuweisen.  Ausgehende
        Pakete eines LAN-Clients werden so der entsprechenden
        externen IP-Adresse des Clients zugeordnet.  Ankommender Verkehr
        f&uuml;r diese IP-Adresse wird automatisch an den entsprechenden
        LAN-Client weitergeleitet.  Diesen Vorgang bezeichnet man
        auch als statisches NAT.  Dem
        <application>natd</application>-Gatewayrechner k&ouml;nnten
        beispielsweise die IP-Adressen
        <hostid role="ipaddr">128.1.1.1</hostid>,
        <hostid role="ipaddr">128.1.1.2</hostid> sowie
        <hostid role="ipaddr">128.1.1.3</hostid> zugewiesen werden.
        <hostid role="ipaddr">128.1.1.1</hostid> wird als die externe
        IP-Adresse des <application>natd</application>-Gatewayrechners
        verwendet, w&auml;hrend <hostid role="ipaddr">128.1.1.2</hostid>
        und <hostid role="ipaddr">128.1.1.3</hostid> an die LAN-Clients
        <hostid>A</hostid> und <hostid>B</hostid> weitergegeben werden.
      </para>

      <para><option>-redirect_address</option> benutzt folgende
        Syntax:</para>

      <programlisting>-redirect_address localIP publicIP</programlisting>

      <informaltable frame="none" pgwide="1">
        <tgroup cols="2">
          <tbody>
            <row>
              <entry>localIP</entry>

              <entry>Die interne IP-Adresse des LAN-Clients</entry>
            </row>
            <row>
              <entry>publicIP</entry>

              <entry>Die externe IP-Adresse des LAN-Clients</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>F&uuml;r unser Beispiel hie&szlig;e dies:</para>

      <programlisting>-redirect_address 192.168.0.2 128.1.1.2
-redirect_address 192.168.0.3 128.1.1.3</programlisting>

      <para>Analog zur Option <option>-redirect_port</option>
        k&ouml;nnen Sie diese Argumente auch in der Option
        <literal>natd_flags=""</literal> in
        <filename>/etc/rc.conf</filename> angeben.  Bei der Nutzung
        der Adressumleitung ist die Portumleitung &uuml;berfl&uuml;ssig,
        weil alle f&uuml;r eine bestimmte IP-Adresse ankommenden Daten
        umgeleitet werden.</para>

      <para>Die externe IP-Adresse des
        <application>natd</application>-Rechners muss aktiv sein und
        der externen Netzwerkkarte zugewiesen sein.  Weitere Informationen
         zu diesem Thema finden Sie in &man.rc.conf.5;.</para>
    </sect2>
  </sect1>

  <sect1 id="network-plip">
    <title>PLIP &ndash; Parallel Line IP</title>

    <indexterm>
      <primary>PLIP</primary>
    </indexterm>

    <indexterm>
      <primary>Parallel Line IP</primary>
      <see>PLIP</see>
    </indexterm>

    <para>PLIP erm&ouml;glicht TCP/IP-Verbindungen zwischen zwei
      Rechnern, die &uuml;ber ihre parallelen Schnittstellen
      verbunden sind.  Eine solche Verbindung ist n&uuml;tzlich,
      wenn zwei Rechner nicht mit Netzwerkkarten ausgestattet sind,
      oder wenn eine Installation auf einem Laptop erfolgen soll.
      Dieser Abschnitt behandelt folgende Themen:</para>

    <itemizedlist>
      <listitem>
	<para>Die Herstellung eines parallelen (Laplink-) Kabels</para>
      </listitem>

      <listitem>
	<para>Die Verbindung von zwei Computern &uuml;ber PLIP</para>
      </listitem>
    </itemizedlist>

    <sect2 id="network-create-parallel-cable">
      <title>Ein paralleles Kabel herstellen</title>

      <para>Ein paralleles (Laplink-)Kabel k&ouml;nnen Sie in fast jedem
	Computergesch&auml;ft kaufen.  Falls dies nicht m&ouml;glich
	sein sollte, oder Sie einfach wissen wollen, wie ein solches
	Kabel aufgebaut ist, sollten Sie sich die folgende Tabelle
	ansehen.  Sie beschreibt die Herstellung eines parallelen
	Netzwerkkabels aus einem gew&ouml;hnlichen parallelen
	Druckerkabel.</para>

      <table frame="none">
	<title>Die Netzwerk-Verdrahtung eines parallelen Kabels</title>

	<tgroup cols="5">
	  <thead>
	    <row>
	      <entry>A-Name</entry>

	      <entry>A-Ende</entry>

	      <entry>B-Ende</entry>

	      <entry>Beschreibung</entry>

	      <entry>Post/Bit</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><literallayout>DATA0
-ERROR</literallayout></entry>

	      <entry><literallayout>2
15</literallayout></entry>

	      <entry><literallayout>15
2</literallayout></entry>

	      <entry>Data</entry>

	      <entry><literallayout>0/0x01
1/0x08</literallayout></entry>
	    </row>

	    <row>
	      <entry><literallayout>DATA1
+SLCT</literallayout></entry>

	      <entry><literallayout>3
13</literallayout></entry>

	      <entry><literallayout>13
3</literallayout></entry>

	      <entry>Data</entry>

	      <entry><literallayout>0/0x02
1/0x10</literallayout></entry>
	    </row>

	    <row>
	      <entry><literallayout>DATA2
+PE</literallayout></entry>

	      <entry><literallayout>4
12</literallayout></entry>

	      <entry><literallayout>12
4</literallayout></entry>

	      <entry>Data</entry>

	      <entry><literallayout>0/0x04
1/0x20</literallayout></entry>
	    </row>

	    <row>
	      <entry><literallayout>DATA3
-ACK</literallayout></entry>

	      <entry><literallayout>5
10</literallayout></entry>

	      <entry><literallayout>10
5</literallayout></entry>

	      <entry>Strobe</entry>

	      <entry><literallayout>0/0x08
1/0x40</literallayout></entry>
	    </row>

	    <row>
	      <entry><literallayout>DATA4
BUSY</literallayout></entry>

	      <entry><literallayout>6
11</literallayout></entry>

	      <entry><literallayout>11
6</literallayout></entry>

	      <entry>Data</entry>

	      <entry><literallayout>0/0x10
1/0x80</literallayout></entry>
	    </row>

	    <row>
	      <entry>GND</entry>

	      <entry>18-25</entry>

	      <entry>18-25</entry>

	      <entry>GND</entry>

	      <entry>-</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>
    </sect2>

    <sect2 id="network-plip-setup">
      <title>PLIP einrichten</title>

      <para>Als Erstes ben&ouml;tigen Sie ein Laplink-Kabel.  Danach
	m&uuml;ssen Sie sicherstellen, dass beide Computerkernel den
	&man.lpt.4;-Treiber unterst&uuml;tzen:</para>

      <screen>&prompt.root; <userinput>grep lp /var/run/dmesg.boot</userinput>
lpt0: &lt;Printer&gt; on ppbus0
lpt0: Interrupt-driven port</screen>

      <para>Der Parallelport muss Interrupt-gesteuert sein, daher
	sollte die Datei <filename>/boot/device.hints</filename>
	zwei Zeilen &auml;hnlich den folgenden enthalten:</para>

      <programlisting>hint.ppc.0.at="isa"
hint.ppc.0.irq="7"</programlisting>

      <para>Danach &uuml;berpr&uuml;fen Sie, ob die
	Kernelkonfigurationsdatei die Zeile
	<literal>device plip</literal> enth&auml;lt, oder ob das
	Kernelmodul <filename>plip.ko</filename> geladen wurde. In
	beiden F&auml;llen sollte die parallele Schnittstelle
	von &man.ifconfig.8; angezeigt werden:</para>

      <screen>&prompt.root; <userinput>ifconfig plip0</userinput>
plip0: flags=8810&lt;POINTOPOINT,SIMPLEX,MULTICAST&gt; mtu 1500</screen>

      <para>Verbinden Sie die parallelen Schnittstellen der beiden
	Computer &uuml;ber das (Laplink-)Kabel.</para>

      <para>Konfigurieren Sie die Netzwerkparameter auf beiden Rechnern
	als <username>root</username>.  Wenn Sie beispielsweise den Rechner
	<hostid>host1</hostid> mit dem Rechner <hostid>host2</hostid>
	verbinden wollen, gehen Sie folgenderma&szlig;en vor:</para>

      <programlisting>                 host1 &lt;-----&gt; host2
IP Address    10.0.0.1      10.0.0.2</programlisting>

      <para>Richten Sie die parallele Schnittstelle von
	<hostid>host1</hostid> ein, indem Sie Folgendes eingeben:</para>

      <screen>&prompt.root; <userinput>ifconfig plip0 10.0.0.1 10.0.0.2</userinput></screen>

      <para>Danach richten Sie die parallele Schnittstelle von
	<hostid>host2</hostid> ein:</para>

      <screen>&prompt.root; <userinput>ifconfig plip0 10.0.0.2 10.0.0.1</userinput></screen>

      <para>Sie sollten nun &uuml;ber eine funktionierende Verbindung
	verf&uuml;gen.  Bei Problemen lesen Sie bitte die Hilfeseiten
	&man.lp.4; sowie &man.lpt.4;.</para>

      <para>Zus&auml;tzlich sollten beide Rechner in
	<filename>/etc/hosts</filename> eingetragen werden:</para>

      <programlisting>127.0.0.1               localhost.my.domain localhost
10.0.0.1                host1.my.domain host1
10.0.0.2                host2.my.domain host2</programlisting>

      <para>Um die Verbindung zu &uuml;berpr&uuml;fen, pingen Sie jeden
	Rechner vom anderen Rechner aus an.  Auf <hostid>host1</hostid>
	gehen Sie dazu folgenderma&szlig;en vor:</para>

      <screen>&prompt.root; <userinput>ifconfig plip0</userinput>
plip0: flags=8851&lt;UP,POINTOPOINT,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet 10.0.0.1 --&gt; 10.0.0.2 netmask 0xff000000
&prompt.root; <userinput>netstat -r</userinput>
Routing tables

Internet:
Destination        Gateway          Flags     Refs     Use      Netif Expire
host2              host1              UH          0       0       plip0
&prompt.root; <userinput>ping -c 4 host2</userinput>
PING host2 (10.0.0.2): 56 data bytes
64 bytes from 10.0.0.2: icmp_seq=0 ttl=255 time=2.774 ms
64 bytes from 10.0.0.2: icmp_seq=1 ttl=255 time=2.530 ms
64 bytes from 10.0.0.2: icmp_seq=2 ttl=255 time=2.556 ms
64 bytes from 10.0.0.2: icmp_seq=3 ttl=255 time=2.714 ms

--- host2 ping statistics ---
4 packets transmitted, 4 packets received, 0% packet loss
round-trip min/avg/max/stddev = 2.530/2.643/2.774/0.103 ms</screen>
    </sect2>
  </sect1>

  <sect1 id="network-ipv6">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Aaron</firstname>
          <surname>Kaplan</surname>
          <contrib>Beigetragen von </contrib>
         </author>
      </authorgroup>

      <authorgroup>
        <author>
          <firstname>Tom</firstname>
          <surname>Rhodes</surname>
          <contrib>&Uuml;berarbeitet und erweitert von </contrib>
        </author>
      </authorgroup>

      <authorgroup>
        <author>
          <firstname>Brad</firstname>
          <surname>Davis</surname>
          <contrib>Erweitert von </contrib>
        </author>
      </authorgroup>
    </sect1info>

    <title>IPv6 &ndash; Internet Protocol Version 6</title>

    <para>Bei IPv6 (auch als IPng oder
      <foreignphrase>IP next generation</foreignphrase>
      bekannt) handelt es sich um die neueste Version des bekannten
      IP-Protokolls (das auch als <acronym>IPv4</acronym> bezeichnet
      wird).  FreeBSD enth&auml;lt, genauso wie die anderen frei
      erh&auml;ltlichen BSD-Systeme, die IPv6-Referenzimplementation
      von KAME.  FreeBSD erf&uuml;llt damit bereits
      alle f&uuml;r die Nutzung von IPv6 n&ouml;tigen Voraussetzungen.
      Dieser Abschnitt konzentriert sich daher auf die Konfiguration
      und den Betrieb von IPv6.</para>

    <para>Anfang der 90er Jahre wurde man auf den stark steigenden
      Verbrauch von IPv4-Adressen aufmerksam.  Im Hinblick auf das
      Wachstums des Internets gab es zwei Hauptsorgen:</para>

    <itemizedlist>
      <listitem>
        <para>Die drohende Knappheit von IPv4-Adressen.  Dieses Problem
          konnte durch die Einf&uuml;hrung von privaten
          Adressr&auml;umen gem&auml;&szlig; RFC1918 (mit Adressen wie
          <hostid role="ipaddr">10.0.0.0/8</hostid>,
          <hostid role="ipaddr">172.16.0.0/12</hostid>, oder
          <hostid role="ipaddr">192.168.0.0/16</hostid>) sowie der
          Entwicklung von <foreignphrase>Network Address
          Translation</foreignphrase> (<acronym>NAT</acronym>)
          weitestgehend entsch&auml;rft werden.</para>
      </listitem>

      <listitem>
        <para>Die immer gr&ouml;&szlig;er werdenden Eintr&auml;ge in
          Router-Tabellen.  Dieses Problem ist auch heute noch
          aktuell.</para>
      </listitem>
    </itemizedlist>

    <para>IPv6 ist in der Lage, diese, aber auch viele andere Probleme
      zu l&ouml;sen:</para>

    <itemizedlist>
      <listitem>
        <para>IPv6 hat einen 128&nbsp;Bit gro&szlig;en Adressraum. Es sind
          also theoretisch
          340.282.366.920.938.463.463.374.607.431.768.211.456 Adressen
          verf&uuml;gbar.  In anderen Worten: F&uuml;r jeden
          Quadratmeter der Erdoberfl&auml;che sind etwa
          6,67&nbsp;*&nbsp;10^27 IPv6-Adressen verf&uuml;gbar.</para>
      </listitem>

      <listitem>
        <para>Router speichern nur noch Netzwerk-Aggregationsadressen in
          Ihren Routingtabellen.  Dadurch reduziert sich die
          durchschnittliche Gr&ouml;&szlig;e  einer Routingtabelle auf
          8192&nbsp;Eintr&auml;ge.</para>
      </listitem>
    </itemizedlist>

    <para>Weitere n&uuml;tzliche Eigenschaften von IPv6 sind:</para>

    <itemizedlist>
      <listitem>
        <para>Die automatische Konfiguration von Adressen, die im
          <ulink url="http://www.ietf.org/rfc/rfc2462.txt">RFC2462</ulink>
          beschrieben wird.</para>
      </listitem>

      <listitem>
        <para>Anycast-Adressen (<quote>eine-von-vielen</quote>)</para>
      </listitem>

      <listitem>
        <para>Verpflichtende Multicast-Adressen</para>
      </listitem>

      <listitem>
        <para>Die Unterst&uuml;tzung von IPsec (IP-Security)</para>
      </listitem>

      <listitem>
        <para>Eine vereinfachte Headerstruktur</para>
      </listitem>

      <listitem>
        <para>Mobile <acronym>IP</acronym>-Adressen</para>
      </listitem>

      <listitem>
        <para>Die Umwandlung von IPv4- in IPv6-Adressen</para>
      </listitem>
    </itemizedlist>

    <para>Weitere Informationsquellen:</para>

    <itemizedlist>
      <listitem>
        <para>Beschreibung von IPv6 auf
          <ulink url="http://playground.sun.com/pub/ipng/html/ipng-main.html">playground.sun.com</ulink>
        </para>
      </listitem>

      <listitem>
        <para><ulink url="http://www.kame.net">KAME.net</ulink></para>
      </listitem>
    </itemizedlist>

    <sect2>
      <title>Hintergrundinformationen zu IPv6-Adressen</title>

      <para>Es gibt verschiedene Arten von IPv6-Adressen: Unicast-,
        Anycast- und Multicast-Adressen.</para>

      <para>Unicast-Adressen sind die herk&ouml;mlichen Adressen. Ein
        Paket, das an eine Unicast-Adresse gesendet wird, kommt nur an
        der Schnittstelle an, die dieser Adresse zugeordnet ist.</para>

      <para>Anycast-Adressen unterscheiden sich in ihrer Syntax nicht
        von Unicast-Adressen, sie w&auml;hlen allerdings aus
	mehreren Schnittstellen eine Schnittstelle aus.
	Ein f&uuml;r eine Anycast-Adresse
	bestimmtes Paket kommt an der n&auml;chstgelegenen
	(entsprechend der Router-Metrik) Schnittstelle
        an.  Anycast-Adressen werden nur von Routern verwendet.</para>

      <para>Multicast-Adressen bestimmen Gruppen, denen mehrere
        Schnittstellen angeh&ouml;ren.  Ein
        Paket, das an eine Multicast-Adresse geschickt wird, kommt an
        allen Schnittstellen an, die zur Multicast-Gruppe geh&ouml;ren.</para>

        <note><para>Die von IPv4 bekannte Broadcast-Adresse
          (normalerweise
          <hostid role="ipaddr">xxx.xxx.xxx.255</hostid>) wird bei IPv6
          durch Multicast-Adressen verwirklicht.</para></note>

      <table frame="none">
        <title>Reservierte IPv6-Adressen</title>

        <tgroup cols="4">
          <thead>
            <row>
              <entry>IPv6-Adresse</entry>
              <entry>Pr&auml;fixl&auml;nge</entry>
              <entry>Beschreibung</entry>
              <entry>Anmerkungen</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><hostid role="ip6addr">::</hostid></entry>
              <entry>128 Bit</entry>
              <entry>nicht festgelegt</entry>
              <entry>entspricht <hostid role="ipaddr">0.0.0.0</hostid>
                bei IPv4</entry>
            </row>

            <row>
              <entry><hostid role="ip6addr">::1</hostid></entry>
              <entry>128 Bit</entry>
              <entry>Loopback-Adresse</entry>
              <entry>entspricht <hostid role="ipaddr">127.0.0.1</hostid>
                bei IPv4</entry>
            </row>

            <row>
              <entry><hostid
                role="ip6addr">::00:xx:xx:xx:xx</hostid></entry>
              <entry>96 Bit</entry>
              <entry>Eingebettete IPv4-Adresse</entry>
              <entry>Die niedrigen 32&nbsp;Bit entsprechen der IPv4-Adresse.
                Wird auch als <quote>IPv4-kompatible IPv6-Adresse
                bezeichnet</quote>.</entry>
	    </row>

            <row>
              <entry><hostid
                role="ip6addr">::ff:xx:xx:xx:xx</hostid></entry>
              <entry>96 Bit</entry>
	      <entry>Eine auf IPv6 abgebildete IPv4-Adresse</entry>
              <entry>Die niedrigen 32&nbsp;Bit entsprechen der IPv4-Adresse.
                Notwendig f&uuml;r Rechner, die IPv6 nicht
                unterst&uuml;tzen.</entry>
            </row>

            <row>
              <entry><hostid role="ip6addr">fe80::</hostid> - <hostid
                role="ip6addr">feb::</hostid></entry>
              <entry>10 Bit</entry>
              <entry><foreignphrase>link-local</foreignphrase></entry>
              <entry>Entspricht der Loopback-Adresse bei IPv4</entry>
            </row>

            <row>
              <entry><hostid role="ip6addr">fec0::</hostid> - <hostid
                role="ip6addr">fef::</hostid></entry>
              <entry>10 Bit</entry>
              <entry><foreignphrase>site-local</foreignphrase></entry>
              <entry>&nbsp;</entry>
            </row>

            <row>
              <entry><hostid role="ip6addr">ff::</hostid></entry>
              <entry>8 Bit</entry>
              <entry>Multicast</entry>
              <entry>&nbsp;</entry>
            </row>

            <row>
              <entry><hostid role="ip6addr">001</hostid>
		(im Dualsystem)</entry>
              <entry>3 Bit</entry>
              <entry>Globaler Unicast</entry>
              <entry>Alle globalen Unicastadressen stammen aus diesem
                Pool.  Die ersten 3&nbsp;Bit lauten <quote>001</quote>.
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </sect2>

    <sect2>
      <title>IPv6-Adressen verstehen</title>

      <para>Die kanonische Form von IPv6-Adressen lautet
        <hostid role="ip6addr">x:x:x:x:x:x:x:x</hostid>, jedes
        <quote>x</quote> steht dabei f&uuml;r einen
        16-Bit-Hexadezimalwert.  Ein Beispiel f&uuml;r eine IPv6-Adresse
        w&auml;re etwa
        <hostid
        role="ip6addr">FEBC:A574:382B:23C1:AA49:4592:4EFE:9982</hostid>.</para>

      <para>Eine IPv6-Adresse enth&auml;lt oft Teilzeichenfolgen aus lauter
        Nullen.  Eine solche Zeichenfolge kann zu <quote>::</quote>
        verk&uuml;rzt werden.  Bis zu drei f&uuml;hrende Nullen eines
        Hexquads k&ouml;nnen ebenfalls weggelassen werden.
        <hostid role="ip6addr">fe80::1</hostid> entspricht also der Adresse
        <hostid role="ip6addr">fe80:0000:0000:0000:0000:0000:0000:0001</hostid>.
      </para>

      <para>Eine weitere M&ouml;glichkeit ist die Darstellung der
        letzten 32&nbsp;Bit in  der bekannten (dezimalen) IPv4-Darstellung,
        bei der Punkte (<quote>.</quote>) zur Trennung verwendet werden.
        <hostid role="ip6addr">2002::10.0.0.1</hostid> ist also nur eine
        andere Schreibweise f&uuml;r die (hexadezimale) kanonische Form
        <hostid role="ip6addr">2002:0000:0000:0000:0000:0000:0a00:0001</hostid>,
        die wiederum der Adresse
        <hostid role="ip6addr">2002::a00:1</hostid> entspricht.</para>

      <para>Sie sollten nun in der Lage sein, die folgende Ausgabe zu
        verstehen:</para>

      <screen>&prompt.root; <userinput>ifconfig</userinput>
rl0: flags=8943&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500
         inet 10.0.0.10 netmask 0xffffff00 broadcast 10.0.0.255
         inet6 fe80::200:21ff:fe03:8e1%rl0 prefixlen 64 scopeid 0x1
         ether 00:00:21:03:08:e1
         media: Ethernet autoselect (100baseTX )
         status: active</screen>

      <para>Bei
        <hostid role="ip6addr">fe80::200:21ff:fe03:8e1%rl0</hostid>
        handelt es sich um eine automatisch konfigurierte
        <foreignphrase>link-local</foreignphrase>-Adresse.  Sie
        wird im Rahmen der automatischen Konfiguration aus der
        MAC-Adresse erzeugt.</para>

      <para>Weitere Informationen zum Aufbau von IPv6-Adressen finden
        Sie im <ulink url="http://www.ietf.org/rfc/rfc3513.txt">
        RFC3513</ulink>.</para>
    </sect2>

    <sect2>
      <title>Eine IPv6-Verbindung herstellen</title>

      <para>Es gibt derzeit vier M&ouml;glichkeiten, sich mit anderen
        IPv6-Rechnern oder Netzwerken zu verbinden:</para>

      <itemizedlist>
        <listitem>
          <para>Fragen Sie Ihren Internetprovider, ob er IPv6
            bereits unterst&uuml;tzt.</para>
        </listitem>

        <listitem>
          <para><ulink url="http://www.sixxs.net">SixXS</ulink>
            bietet weltweit IPv6-Tunnelverbindungen an.</para>
        </listitem>

        <listitem>
          <para>Die Verwendung eines 6-nach-4-Tunnels
            (<ulink
            url="http://www.ietf.org/rfc/rfc3068.txt">RFC3068</ulink>).</para>
        </listitem>

        <listitem>
          <para>Die Verwendung des Ports
            <filename>/usr/ports/net/freenet6</filename> bei der Einwahl
            ins Internet.</para>
        </listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>DNS in der IPv6-Welt</title>

      <para>Urspr&uuml;nglich gab es zwei verschiedene DNS-Eintr&auml;ge
        f&uuml;r IPv6.  Da A6-Eintr&auml;ge von der IETF f&uuml;r
        obsolet erkl&auml;rt wurden, sind AAAA-Eintr&auml;ge nun
        Standard.</para>

      <para>Weisen Sie die erhaltene IPv6-Adresse Ihrem Rechnernamen zu,
        indem Sie den Eintrag</para>

      <programlisting>MYHOSTNAME           AAAA    MYIPv6ADDR</programlisting>

      <para>in Ihre prim&auml;re DNS-Zonendatei einf&uuml;gen.  Falls
        Sie nicht f&uuml;r Ihre <acronym>DNS</acronym>-Zone
        verantwortlich sind, bitten Sie den daf&uuml;r
        Zust&auml;ndigen, diese &Auml;nderung durchzuf&uuml;hren.
        Die aktuellen Versionen von <application>bind</application>
        (Version&nbsp;8.3 oder 9) sowie
        <filename role="package">dns/djbdns</filename> (bei Verwendung
        des IPv6-Patches) unterst&uuml;tzen AAAA-Eintr&auml;ge.</para>
    </sect2>

    <sect2>
      <title><filename>/etc/rc.conf</filename> f&uuml;r die Nutzung von
        IPv6 anpassen</title>

      <sect3>
        <title>Einen Client unter IPv6 einrichten</title>

        <para>Dieser Abschnitt beschreibt die Konfiguration eines
          Rechners, der in Ihrem LAN als Client, aber nicht als Router
          verwendet wird.  Um die Schnittstelle w&auml;hrend des
          Systemstarts mit &man.rtsol.8; automatisch einzurichten,
          f&uuml;gen Sie folgende Zeile in
          <filename>/etc/rc.conf</filename> ein:</para>

        <programlisting>ipv6_enable="YES"</programlisting>

        <para>Durch die folgende Zeile weisen Sie Ihrer Schnittstelle
          <devicename>fxp0</devicename> die statische IP-Adresse <hostid
          role="ip6addr">2001:471:1f11:251:290:27ff:fee0:2093</hostid>
          zu:</para>

        <programlisting>ipv6_ifconfig_fxp0="2001:471:1f11:251:290:27ff:fee0:2093"</programlisting>

        <para>Um <hostid role="ip6addr">2001:471:1f11:251::1</hostid>
          als Standardrouter festzulegen, f&uuml;gen Sie folgende Zeile
          in <filename>/etc/rc.conf</filename> ein:</para>

        <programlisting>ipv6_defaultrouter="2001:471:1f11:251::1"</programlisting>
      </sect3>

      <sect3>
        <title>Gateways und Router unter IPv6 einrichten</title>

        <para>Dieser Abschnitt beschreibt, wie Sie Ihren Rechner mit
          Hilfe der von Ihrem Tunnel-Anbieter erhaltenen
          Anweisungen dauerhaft f&uuml;r die Nutzung von IPv6
          einrichten.  Um den Tunnel beim Systemstart
          wiederherzustellen, passen Sie
          <filename>/etc/rc.conf</filename> wie folgt an:</para>

        <para>Listen Sie die einzurichtenden Tunnelschnittstellen
          (hier <devicename>gif0</devicename>) auf:</para>

        <programlisting>gif_interfaces="gif0"</programlisting>

        <para>Um den lokalen Endpunkt
          <replaceable>MY_IPv4_ADDR</replaceable> &uuml;ber diese
          Schnittstelle mit dem entfernten Endpunkt
          <replaceable>REMOTE_IPv4_ADDR</replaceable> zu
          verbinden, verwenden Sie folgende Zeile:</para>

        <programlisting>gifconfig_gif0="<replaceable>MY_IPv4_ADDR REMOTE_IPv4_ADDR</replaceable>"</programlisting>

        <para>Um die Ihnen zugewiesene IPv6-Adresse als Endpunkt Ihres
          IPv6-Tunnels zu verwenden, f&uuml;gen Sie folgende Zeile
          ein:</para>

        <programlisting>ipv6_ifconfig_gif0="<replaceable>MY_ASSIGNED_IPv6_TUNNEL_ENDPOINT_ADDR</replaceable>"</programlisting>

        <para>Nun m&uuml;ssen Sie nur noch die IPv6-Standardroute
          angeben.  Diese legt das andere Ende des IPv6-Tunnels
          fest.</para>

        <programlisting>ipv6_defaultrouter="<replaceable>MY_IPv6_REMOTE_TUNNEL_ENDPOINT_ADDR</replaceable>"</programlisting>
      </sect3>

      <sect3>
        <title>Einen IPv6-Tunnel einrichten</title>

        <para>Wenn Ihr Server IPv6-Verkehr zwischen Ihrem Netzwerk und
          der Au&szlig;enwelt routen muss, ben&ouml;tigen Sie
          zus&auml;tzlich die folgenden Zeilen in Ihrer
          <filename>/etc/rc.conf</filename>:</para>

        <programlisting>ipv6_gateway_enable="YES"</programlisting>

      </sect3>
    </sect2>

    <sect2>
      <title>Bekanntmachung von Routen und automatische
        Rechnerkonfiguration</title>

      <para>Dieser Abschnitt beschreibt die Einrichtung von
        &man.rtadvd.8;, das Sie bei der Bekanntmachung der
        IPv6-Standardroute unterst&uuml;tzt.</para>

      <para>Um &man.rtadvd.8; zu aktivieren, f&uuml;gen Sie folgende
        Zeile in <filename>/etc/rc.conf</filename> ein:</para>

      <programlisting>rtadvd_enable="YES"</programlisting>

      <para>Es ist wichtig, die Schnittstelle anzugeben, &uuml;ber die
        IPv6-Routen bekanntgemacht werden sollen.  Soll &man.rtadvd.8;
        <devicename>fxp0</devicename> verwenden, ist folgender Eintrag
        n&ouml;tig:</para>

      <programlisting>rtadvd_interfaces="fxp0"</programlisting>

      <para>Danach erzeugen Sie die Konfigurationsdatei
        <filename>/etc/rtadvd.conf</filename>.  Dazu ein Beispiel:</para>

      <programlisting>fxp0:\
    :addrs#1:addr="2001:471:1f11:246::":prefixlen#64:tc=ether:</programlisting>

      <para>Ersetzen Sie dabei <devicename>fxp0</devicename> durch die
        zu verwendende Schnittstelle.</para>

      <para>Anschlie&szlig;end ersetzen Sie
        <hostid role="ip6addr">2001:471:1f11:246::</hostid> durch das
        Pr&auml;fix der Ihnen zugewiesenen Verbindung.</para>

      <para>Wenn Sie eine <hostid role="netmask">/64</hostid>-Netzmaske
        verwenden, m&uuml;ssen Sie keine weiteren Anpassungen vornehmen.
        Anderenfalls m&uuml;ssen Sie <literal>prefixlen#</literal>
        auf den korrekten Wert setzen.</para>
    </sect2>
  </sect1>

  <sect1 id="network-atm">
    <sect1info>
      <authorgroup>
        <author>
          <firstname>Harti</firstname>
          <surname>Brandt</surname>
          <contrib>Beigetragen von </contrib>
        </author>
      </authorgroup>
    </sect1info>

    <title>ATM - Asynchronous Transfer Mode</title>

    <sect2>
      <title><foreignphrase>Classical IP over ATM</foreignphrase>
        als PVC-Verbindung einrichten</title>

      <para><foreignphrase>Classical IP over ATM</foreignphrase>
        (<acronym>CLIP</acronym>) ist die einfachste M&ouml;glichkeit,
        um IP-Verkehr &uuml;ber ATM (<foreignphrase>Asynchronous
        Transfer Mode</foreignphrase>-Verbindungen zu &uuml;bertragen.
        CLIP kann sowohl mit geschalteten Verbindungen (SVCs) als auch
        mit permanenten Verbindungen (PVCs) verwendet werden.  Dieser
        Abschnitt beschreibt die Einrichtung eines PVC-basierten
        Netzwerks.</para>

      <sect3>
        <title>Ein vollst&auml;ndig vermaschtes Netzwerk aufbauen</title>

        <para>Bei einem vollst&auml;ndig vermaschten
          (<foreignphrase>fully meshed</foreignphrase>) Netzwerk ist
          jeder Rechner &uuml;ber eine dezidierte Verbindung mit jedem
          anderen Rechner des Netzwerks verbunden.  Die Konfiguration
          ist - vor allem f&uuml;r kleinere Netzwerke - relativ einfach.
          Unser Beispielnetzwerk besteht aus vier Rechnern, die jeweils
          &uuml;ber eine
          <acronym role="Asynchronous Transfer Mode">ATM</acronym>-Adapterkarte
          mit dem
          <acronym role="Asynchronous Transfer Mode">ATM</acronym>-Netzwerk
          verbunden sind.  Als ersten Konfigurationsschritt planen wir
          die Vergabe von IP-Adressen sowie die anzulegenden
          <acronym role="Asynchronous Transfer Mode">ATM</acronym>-Verbindungen:
        </para>

	<informaltable frame="none" pgwide="1">
	  <tgroup cols="2">
	    <colspec colwidth="1*">
	    <colspec colwidth="1*">
	    <thead>
	      <row>
		<entry>Rechner</entry>
		<entry>IP-Adresse</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><hostid>hostA</hostid></entry>
		<entry><hostid role="ipaddr">192.168.173.1</hostid></entry>
	      </row>

	      <row>
		<entry><hostid>hostB</hostid></entry>
		<entry><hostid role="ipaddr">192.168.173.2</hostid></entry>
	      </row>

	      <row>
		<entry><hostid>hostC</hostid></entry>
		<entry><hostid role="ipaddr">192.168.173.3</hostid></entry>
	      </row>

	      <row>
		<entry><hostid>hostD</hostid></entry>
		<entry><hostid role="ipaddr">192.168.173.4</hostid></entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

        <para>Um ein vollst&auml;ndiges Netz aufzubauen, ben&ouml;tigen
          wir f&uuml;r jedes Rechnerpaar eine eigene ATM-Verbindung:</para>

	<informaltable frame="none" pgwide="1">
	  <tgroup cols="2">
	    <colspec colwidth="1*">
	    <colspec colwidth="1*">
	    <thead>
	      <row>
		<entry>Rechnerpaar</entry>
		<entry>VPI.VCI-Paar</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><hostid>hostA</hostid> - <hostid>hostB</hostid></entry>
		<entry>0.100</entry>
	      </row>

	      <row>
		<entry><hostid>hostA</hostid> - <hostid>hostC</hostid></entry>
		<entry>0.101</entry>
	      </row>

	      <row>
		<entry><hostid>hostA</hostid> - <hostid>hostD</hostid></entry>
		<entry>0.102</entry>
	      </row>

	      <row>
		<entry><hostid>hostB</hostid> - <hostid>hostC</hostid></entry>
		<entry>0.103</entry>
	      </row>

	      <row>
		<entry><hostid>hostB</hostid> - <hostid>hostD</hostid></entry>
		<entry>0.104</entry>
	      </row>

	      <row>
		<entry><hostid>hostC</hostid> - <hostid>hostD</hostid></entry>
		<entry>0.105</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

        <para>Die Werte VPI und VCI an den Verbindungsenden k&ouml;nnen
          nat&uuml;rlich unterschiedlich sein.  Wir nehmen hier aber an,
          dass sie gleich sind.  Nun m&uuml;ssen wir die
          ATM-Schnittstellen auf jedem Rechner einrichten:</para>

        <screen>hostA&prompt.root; <userinput>ifconfig hatm0 192.168.173.1 up</userinput>
hostB&prompt.root; <userinput>ifconfig hatm0 192.168.173.2 up</userinput>
hostC&prompt.root; <userinput>ifconfig hatm0 192.168.173.3 up</userinput>
hostD&prompt.root; <userinput>ifconfig hatm0 192.168.173.4 up</userinput></screen>

        <para>Dabei setzen wir voraus, dass
          <devicename>hatm0</devicename> auf allen Rechnern die
          ATM-Schnittstelle darstellt.  Danach werden, beginnend mit
          <hostid>hostA</hostid>, die PVCs auf den einzelnen Rechnern
          eingerichtet (Wir nehmen an, dass die PVCs auf den
          ATM-Switches bereits eingerichet sind.  Lesen Sie die
          entsprechenden Handb&uuml;cher, wenn Sie einen Switch
          einrichten m&uuml;ssen.):</para>

        <screen>hostA&prompt.root; <userinput>atmconfig natm add 192.168.173.2 hatm0 0 100 llc/snap ubr</userinput>
hostA&prompt.root; <userinput>atmconfig natm add 192.168.173.3 hatm0 0 101 llc/snap ubr</userinput>
hostA&prompt.root; <userinput>atmconfig natm add 192.168.173.4 hatm0 0 102 llc/snap ubr</userinput>

hostB&prompt.root; <userinput>atmconfig natm add 192.168.173.1 hatm0 0 100 llc/snap ubr</userinput>
hostB&prompt.root; <userinput>atmconfig natm add 192.168.173.3 hatm0 0 103 llc/snap ubr</userinput>
hostB&prompt.root; <userinput>atmconfig natm add 192.168.173.4 hatm0 0 104 llc/snap ubr</userinput>

hostC&prompt.root; <userinput>atmconfig natm add 192.168.173.1 hatm0 0 101 llc/snap ubr</userinput>
hostC&prompt.root; <userinput>atmconfig natm add 192.168.173.2 hatm0 0 103 llc/snap ubr</userinput>
hostC&prompt.root; <userinput>atmconfig natm add 192.168.173.4 hatm0 0 105 llc/snap ubr</userinput>

hostD&prompt.root; <userinput>atmconfig natm add 192.168.173.1 hatm0 0 102 llc/snap ubr</userinput>
hostD&prompt.root; <userinput>atmconfig natm add 192.168.173.2 hatm0 0 104 llc/snap ubr</userinput>
hostD&prompt.root; <userinput>atmconfig natm add 192.168.173.3 hatm0 0 105 llc/snap ubr</userinput></screen>

        <para>Statt UBR k&ouml;nnen auch andere
          <foreignphrase>traffic contracts</foreignphrase> verwendet
          werden.  Voraussetzung ist allerdings, dass diese von Ihrem
          ATM-Adapter unterst&uuml;tzt werden.  Ist dies der Fall,
          folgen auf den Namen des
          <foreignphrase>traffic contracts</foreignphrase> die
          entsprechenden Konfigurationsparameter.  Weitere Informationen
          zur Konfiguration von ATM-Adapterkarten erhalten Sie &uuml;ber
          den Befehl</para>

        <screen>&prompt.root; <userinput>atmconfig help natm add</userinput></screen>

        <para>oder durch das Lesen von &man.atmconfig.8;.</para>

        <para>Die Konfiguration von ATM-Adaptern kann auch &uuml;ber die
          Datei <filename>/etc/rc.conf</filename> erfolgen.  F&uuml;r
          <hostid>hostA</hostid> s&auml;he die Konfiguration so
          aus:</para>

        <programlisting>network_interfaces="lo0 hatm0"
ifconfig_hatm0="inet 192.168.173.1 up"
natm_static_routes="hostB hostC hostD"
route_hostB="192.168.173.2 hatm0 0 100 llc/snap ubr"
route_hostC="192.168.173.3 hatm0 0 101 llc/snap ubr"
route_hostD="192.168.173.4 hatm0 0 102 llc/snap ubr"</programlisting>

        <para>Mit dem folgenden Befehl l&auml;sst sich der derzeitige
          Status aller <acronym>CLIP</acronym>-Routen anzeigen:</para>

        <screen>hostA&prompt.root; <userinput>atmconfig natm show</userinput></screen>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="carp">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title>CARP - Common Address Redundancy Protocol</title>

    <indexterm><primary>CARP</primary></indexterm>
    <indexterm><primary>Common Address Redundancy Protocol (CARP)</primary></indexterm>

    <para>Das <foreignphrase>Common Address Redundancy
      Protocol</foreignphrase> (<acronym>CARP</acronym>) erlaubt es,
      mehreren Rechnern die gleiche <acronym>IP</acronym>-Adresse
      zuzuweisen.  Durch ein solches Vorgehen l&auml;&szlig;t sich
      beispielsweise die Verf&uuml;gbarkeit bestimmter Dienste
      verbessern oder die Last zwischen einzelnen Systemen besser
      verteilen.  Den auf diese Art und Weise konfigurierten Systemen
      kann zus&auml;tzlich eine eigene (im Netzwerk eindeutige)
      <acronym>IP</acronym>-Adresse zugewiesen werden (wie dies auch
      im folgenden Beispiel erfolgt).</para>

    <para>Um <acronym>CARP</acronym> zu aktivieren, m&uuml;ssen Sie die
      &os;-Kernelkonfigurationsdatei um die folgende Option erweitern
      und danach den &os;-Kernel (wie in <xref
      linkend="kernelconfig"> beschrieben) neu bauen:</para>

    <programlisting>device	carp</programlisting>

    <para>Alternativ k&ouml;nnen Sie aber auch das Kernelmodul
      <filename>if_carp.ko</filename> beim Systemstart
      automatisch laden.  Dazu nehmen Sie die folgende Zeile
      in die Datei <filename>/boot/loader.conf</filename>
      auf:</para>

    <programlisting>if_carp_load="YES"</programlisting>

    <para>Danach ist <acronym>CARP</acronym> auf Ihrem System
      verf&uuml;gbar und kann &uuml;ber verschiedene
      <command>sysctl</command>-Optionen (<acronym>OID</acronym>s)
      gesteuert werden.</para>

    <informaltable frame="none" pgwide="1">
      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>OID</entry>
	    <entry>Beschreibung</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry><varname>net.inet.carp.allow</varname></entry>
	    <entry>Akzeptiert ankommende <acronym>CARP</acronym>-Pakete.
	      In der Voreinstellung aktiviert.</entry>
	  </row>

	  <row>
	    <entry><varname>net.inet.carp.preempt</varname></entry>
	    <entry>Diese Option deaktiviert alle
	      <acronym>CARP</acronym>-Ger&auml;te, sobald eines von
	      ihnen ausf&auml;llt.  In der Voreinstellung
	      deaktiviert.</entry>
	  </row>

	  <row>
	    <entry><varname>net.inet.carp.log</varname></entry>
	    <entry>Hat diese Variable den Wert <literal>0</literal>, wird
	      kein Protokoll generiert, w&auml;hrend mit dem Wert
	      <literal>1</literal> nur inkorrekte
	      <acronym>CARP</acronym>-Pakete protokolliert werden.  Hat
	      die Variable einen Wert gr&ouml;&szlig;er
	      <literal>1</literal>, werden nur die Statuswechsel von
	      <acronym>CARP</acronym>-Ger&auml;ten protokolliert.  In der
	      Voreinstellung hat diese Variable den Wert
	      <literal>1</literal>.</entry>
	  </row>

	  <row>
	    <entry><varname>net.inet.carp.arpbalance</varname></entry>
	    <entry>Gleicht die Netzwerklast im lokalen Netzwerk durch
	      den Einsatz von <acronym>ARP</acronym> aus.  In der
	      Voreinstellung deaktiviert.</entry>
	  </row>

	  <row>
	    <entry><varname>net.inet.carp.suppress_preempt</varname></entry>
	    <entry>Eine nur lesbare <acronym>OID</acronym>, die
	      den <foreignphrase>Preemption Suppression</foreignphrase>-Status
	      anzeigt. Preemption kann verhindert werden.  Dies auch dann,
	      wenn ein Ger&auml;t ausf&auml;llt.  Hat die Variable
	      den Wert <literal>0</literal>, bedeutet dies, dass Preemption
	      nicht verhindert wird.  Tritt ein Problem auf, wird der Wert
	      dieser <acronym>OID</acronym> um <literal>1</literal>
	      erh&ouml;ht.</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <para>Das <acronym>CARP</acronym>-Ger&auml;t selbst erzeugen Sie mit dem
      <command>ifconfig</command>-Befehl:</para>

    <screen>&prompt.root; <userinput>ifconfig carp0 create</userinput></screen>

    <para>Damit Sie dieses Protokoll in Ihrem Netzwerk einsetzen
      k&ouml;nnen, muss jede Netzwerkkarte eine eindeutige
      Identifikationsnummer, die sogenannte <acronym>VHID</acronym>
      (<foreignphrase>Virtual Host Identification</foreignphrase>),
      besitzen, da sich ansonsten die Rechner Ihres Netzwerks nicht
      voneinander unterscheiden lassen.</para>

    <sect2>
      <title>Die Serververf&uuml;gbarkeit mit CARP
	verbessern</title>

      <para>Wie bereits weiter oben erw&auml;hnt wurde, k&ouml;nnen Sie
	<acronym>CARP</acronym> dazu verwenden, die Verf&uuml;barkeit
	Ihrer Server zu verbessern.  Im folgenden Bespiel werden
	insgesamt drei Server (mit jeweils eigener, eindeutiger
	<acronym>IP</acronym>-Adresse), die alle den gleichen Inhalt
	anbieten, in einer <foreignphrase>Round Robin</foreignphrase>
	<acronym>DNS</acronym>-Konfiguration eingerichtet.
	Der Backup-Server verf&uuml;gt &uuml;ber zwei
	<acronym>CARP</acronym>-Schnittstellen (f&uuml;r die beiden
	<acronym>IP</acronym>-Adressen der Content-Server).  Tritt bei
	einem Content-Server ein Problem auf, &uuml;bernimmt der
	Backup-Server die <acronym>IP</acronym>-Adresse des
	ausgefallenen Servers.  Dadurch sollte die Auswahl eines Servers
	vom Anwender nicht bemerkt werden.  Der Backup-Server muss
	identisch konfiguriert sein und die gleichen Daten und Dienste
	anbieten wie das System, das er ersetzen soll.</para>

      <para>Die beiden Content-Server werden (abgesehen von ihren
	jeweiligen Hostnamen und <acronym>VHID</acronym>s) identisch
	konfiguriert und hei&szlig;en in unserem Beispiel
	<hostid>hosta.example.org</hostid> beziehungsweise
	<hostid>hostb.example.org</hostid>.  Damit Sie
	<acronym>CARP</acronym> einsetzen k&ouml;nnen, m&uuml;ssen
	Sie als Erstes die Datei <filename>rc.conf</filename> auf
	beiden Systemen anpassen.  F&uuml;r das System
	<hostid>hosta.example.org</hostid> nehmen Sie dazu folgende
	Zeilen in <filename>rc.conf</filename> auf:</para>

      <programlisting>hostname="hosta.example.org"
ifconfig_fxp0="inet 192.168.1.3 netmask 255.255.255.0"
cloned_interfaces="carp0"
ifconfig_carp0="vhid 1 pass testpass 192.168.1.50/24"</programlisting>

      <para>F&uuml;r das System <hostid>hostb.example.org</hostid>
	ben&ouml;tigen Sie zus&auml;tzlich folgende Zeilen in
	<filename>rc.conf</filename>:</para>

      <programlisting>hostname="hostb.example.org"
ifconfig_fxp0="inet 192.168.1.4 netmask 255.255.255.0"
cloned_interfaces="carp0"
ifconfig_carp0="vhid 2 pass testpass 192.168.1.51/24"</programlisting>

      <note>
	<para>Achten Sie unbedingt darauf, dass die durch die Option
	  <option>pass</option> an <command>ifconfig</command>
	  &uuml;bergebenen Passw&ouml;rter auf beiden Systemen
	  identisch sind, da
	  <devicename>carp</devicename>-Ger&auml;te nur mit Systemen
	  kommunizieren k&ouml;nnen, die &uuml;ber ein korrektes Passwort
	  verf&uuml;gen.  Beachten Sie weiters, dass sich die
	  <acronym>VHID</acronym>s der beiden Systeme unterscheiden
	  m&uuml;ssen.</para>
      </note>

      <para>Nun richten Sie noch das dritte System,
	<hostid>provider.example.org</hostid>, ein, das aktiviert
	wird, wenn eines der beiden zuvor konfigurierten Systeme
	ausf&auml;llt.  Dieses dritte System ben&ouml;tigt zwei
	<devicename>carp</devicename>-Ger&auml;te, um bei Bedarf
	eines der beiden anderen
	Systeme ersetzen zu k&ouml;nnen.  Dazu konfigurieren Sie
	<filename>rc.conf</filename> analog zur folgenden
	Beispielkonfiguration:</para>

      <programlisting>hostname="provider.example.org"
ifconfig_fxp0="inet 192.168.1.5 netmask 255.255.255.0"
cloned_interfaces="carp0 carp1"
ifconfig_carp0="vhid 1 advskew 100 pass testpass 192.168.1.50/24"
ifconfig_carp1="vhid 2 advskew 100 pass testpass 192.168.1.51/24"</programlisting>

      <para>Durch die beiden <devicename>carp</devicename>-Ger&auml;te
	ist es <hostid>provider.example.org</hostid> m&ouml;glich,
	festzustellen, ob eines der beiden anderen Systeme nicht mehr
	reagiert.  In diesem Fall &uuml;bernimmt
	<hostid>provider.example.org</hostid> die
	<acronym>IP</acronym>-Adresse des betroffenen Systems.</para>

      <note>
        <para>Ist im installierten &os;-Kernel die Option
	  "preemption" aktiviert, kann es sein, dass
	  <hostid>provider.example.org</hostid> die &uuml;bernommene
	  <acronym>IP</acronym>-Adresse nicht mehr an den
	  Content-Server zur&uuml;ckgibt (wenn dieser wieder
	  funktioniert).  In diesem Fall muss ein Administrator die
	  entsprechende Schnittstelle dazu zwingen, dies zu tun.
	  Dazu gibt er auf dem Rechner
	  <hostid>provider.example.org</hostid> den folgenden
	  Befehl ein:</para>

	<screen>&prompt.root; <userinput>ifconfig carp0 down && ifconfig carp0 up</userinput></screen>

	<para>Dieser Befehl muss auf das
	  <devicename>carp</devicename>-Ger&auml;t ausgef&uuml;hrt
	  werden, das dem betroffenen System zugeordnet ist.</para>
      </note>

      <para>Damit ist <acronym>CARP</acronym> vollst&auml;ndig
	konfiguriert und der Testbetrieb kann beginnen.  Zuvor
	m&uuml;ssen Sie allerdings noch alle Systeme neu starten
	(beziehungsweise die Netzwerkkonfiguration auf allen
	Systemen neu einlesen), um die Einstelllungen zu
	&uuml;bernehmen.</para>

      <para>F&uuml;r weitere Informtionen lesen Sie bitte die Manualpage
        &man.carp.4;.</para>
    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
