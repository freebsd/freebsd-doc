<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde$
     basiert auf: r42953
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="basics">
  <title>Grundlagen des UNIX Betriebssystems</title>
    <!--
    <authorgroup>
      <author><personname><firstname>Chris</firstname><surname>Shumway</surname></personname><contrib>Umgeschrieben von </contrib></author>
    </authorgroup>

    <authorgroup>
      <author><personname><firstname>Uwe</firstname><surname>Pierau</surname></personname><contrib>Übersetzt von </contrib></author>
    </authorgroup>
    -->

  <sect1 xml:id="basics-synopsis">
    <title>Übersicht</title>

   <para>Dieses Kapitel umfasst die grundlegenden Kommandos
     und Funktionsweisen des &os;-Betriebssystems.  Viel von diesem
     Material gilt auch für jedes andere &unix;-artige System.
     Neue Benutzer von &os; sollten dieses Kapitel aufmerksam
     lesen.</para>

   <para>Dieser Abschnitt behandelt die folgenden Themen:</para>

   <itemizedlist>
     <listitem>
       <para>virtuelle Konsolen,</para>
     </listitem>
     <listitem>
       <para>Erstellung und Verwaltung von Benutzern und Gruppen in
	 &os;,</para>
     </listitem>
     <listitem>
       <para>Zugriffsrechte unter &unix; sowie Datei-Flags unter &os;,</para>
     </listitem>
     <listitem>
       <para>Zugriffskontrolllisten für Dateisysteme,</para>
     </listitem>
     <listitem>
       <para>die Verzeichnisstruktur von &os;,</para>
     </listitem>
     <listitem>
       <para>Organisation von Dateisystemen unter &os;,</para>
     </listitem>
     <listitem>
       <para>Ein- und Abhängen von Dateisystemen,</para>
     </listitem>
     <listitem>
       <para>Prozesse, Dämonen und Signale,</para>
     </listitem>
     <listitem>
       <para>Shells und die Login-Umgebung,</para>
     </listitem>
     <listitem>
       <para>Texteditoren,</para>
     </listitem>
     <listitem>
       <para>Geräte und Gerätedateien,</para>
     </listitem>
     <listitem>
       <para>wie Sie in den Manualpages nach weiteren Informationen
	 suchen können.</para>
     </listitem>
   </itemizedlist>
  </sect1>

  <sect1 xml:id="consoles">
    <title>Virtuelle Konsolen und Terminals</title>
    <indexterm><primary>virtuelle Konsole</primary></indexterm>
    <indexterm><primary>Terminals</primary></indexterm>
    <indexterm><primary>Konsole</primary></indexterm>

      <para>Wenn das &os;-System so konfiguriert wurde, dass es ohne
	eine grafische Benutzeroberfläche startet, wird das System
	nach dem Start einen Anmeldeprompt ausgeben, wie in diesem
	Beispiel zu sehen:</para>

      <screen>FreeBSD/amd64 (pc3.example.org) (ttyv0)

login:</screen>

      <para>Die erste Zeile enthält einige Informationen über das
	System.  <literal>amd64</literal> zeigt an, dass auf dem
	System in diesem Beispiel eine 64-Bit Version von &os;
	läuft.  Der Hostname ist
	<systemitem>pc3.example.org</systemitem> und
	<filename>ttyv0</filename> gibt an, dass dies die
	<quote>Systemkonsole</quote> ist.  Die zweite Zeile zeigt den
	Anmeldeprompt.</para>

      <para>Da &os; ein Mehrbenutzersystem ist, muss es die
	verschiedenen Benutzer voneinander unterscheiden können.  Dies
	wird dadurch erreicht, dass sich jeder Benutzer zuerst am
	System anmelden muss, um Zugriff auf die Programme zu
	bekommen.  Jeder Benutzer hat einen eindeutigen
	<quote>Benutzernamen</quote> und ein persönliches
	<quote>Kennwort</quote>.</para>

      <para>Um sich auf der Systemkonsole anzumelden, geben Sie den
	Benutzernamen ein, der während der Systeminstallation, wie in
	<link linkend="bsdinstall-addusers"/> beschrieben,
	konfiguriert wurde und drücken Sie <keycap>Enter</keycap>.
	Geben Sie dann das zum Benutzernamen zugeordnete Passwort ein
	und drücken <keycap>Enter</keycap>.  Das Passwort wird aus
	Sicherheitsgründen
	<emphasis>nicht angezeigt</emphasis>.</para>

      <para>Sobald das richtige Passwort eingegeben wird, wird die
	Nachricht des Tages (<acronym>MOTD</acronym>) gefolgt von
	einer Eingabeaufforderung ausgegeben.  In Abhängigkeit der
	verwendeten Shell des Benutzers wird der Prompt mit dem
	Zeichen <literal>#</literal>, <literal>$</literal> oder
	<literal>%</literal> dargestellt.  Der Prompt zeigt an,  dass
	der Benutzer jetzt an der &os; Systemkonsole angemeldet ist
	und nun alle verfügbaren Befehle probieren kann.</para>

    <sect2 xml:id="consoles-virtual">
      <title>Virtuelle Konsolen</title>

      <para>Obwohl die Systemkonsole dazu verwendet werden kann, um
	mit dem System zu interagieren,  wird sich ein Benutzer in der
	Regel an einer virtuellen Konsole im &os;-System anmelden.
	Das liegt daran, dass die Systemmeldungen standardmäßig auf
	der Systemkonsole angezeigt werden und somit die Meldungen des
	Befehls oder einer Datei, die der Benutzer gerade bearbeitet,
	überschrieben werden.</para>

      <para>In der Voreinstellung ist &os; so konfiguriert, dass viele
	virtuelle Konsolen zur Eingabe von Befehlen zur Verfügung
	stehen.  Jede virtuelle Konsole verfügt über einen eigenen
	Anmeldeprompt und eine Shell.  Sie können ganz einfach
	zwischen den virtuellen Konsolen umschalten.  Dies ist 
	vergleichbar mit mehreren geöffneten Fenstern in einer
	graphischen Umgebung.</para>

      <para>Die Tastenkombinationen
	<keycombo><keycap>Alt</keycap><keycap>F1</keycap></keycombo>
	bis
	<keycombo><keycap>Alt</keycap><keycap>F8</keycap></keycombo>
	sind in &os; zum Umschalten zwischen virtuellen Konsolen
	reserviert.  Verwenden Sie
	<keycombo><keycap>Alt</keycap><keycap>F1</keycap></keycombo>
	um auf die Systemkonsole (<filename>ttyv0</filename>) zu
	wechseln,
	<keycombo><keycap>Alt</keycap><keycap>F2</keycap></keycombo>
	für die erste virtuelle Konsole (<filename>ttyv1</filename>,
	<keycombo><keycap>Alt</keycap><keycap>F3</keycap></keycombo>
	für die zweite virtuelle Konsole (<filename>ttyv2</filename>,
	und so weiter.</para>

      <para>Beim Wechsel von einer Konsole zur nächsten wird die
	Bildschirmausgabe von &os; verwaltet.  Dies erzeugt die
	Illusion mehrerer Bildschirme und Tastaturen, an denen
	Kommandos abgesetzt werden können.  Die Programme, die in
	einer virtuellen Konsole gestartet werden, laufen auch dann
	weiter, wenn der Benutzer auf eine andere virtuelle Konsole
	wechselt.</para>

      <para>Lesen Sie &man.syscons.4;, &man.atkbd.4;,
	&man.vidcontrol.1; und &man.kbdcontrol.1; für eine recht
	technische Beschreibung der &os;-Konsole und der
	Tastatur-Treiber.</para>

      <para>In &os; wird die Anzahl der verfügbaren virtuellen
	Konsolen in diesem Abschnitt von
	<filename>/etc/ttys</filename> konfiguriert:</para>

      <programlisting># name	getty			      type  status comments
#
ttyv0   "/usr/libexec/getty Pc"         cons25  on  secure
# Virtual terminals
ttyv1   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv2   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv3   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv4   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv5   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv6   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv7   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv8   "/usr/X11R6/bin/xdm -nodaemon"  xterm   off secure</programlisting>

      <para>Um eine virtuelle Konsole zu deaktivieren, setzen Sie ein
	Kommentarzeichen (<literal>#</literal> an den Anfang der Zeile
	für die entsprechende Konsole.  Um bspw. die Anzahl der
	verfügbaren virtuellen Konsolen von acht auf vier zu
	reduzieren, setzen Sie ein <literal>#</literal> an den Anfang
	der letzten vier Zeilen, den virtuellen Konsolen
	<filename>ttyv5</filename> bis <filename>ttyv8</filename>.
	Kommentieren Sie nicht die Zeile für die Systemkonsole
	<filename>ttyv0</filename> aus!  Beachten Sie, dass die
	letzte virtuelle Konsole (<filename>ttyv8</filename>) zum
	Wechsel auf die graphische Oberfläche gedacht ist, wenn
	&xorg; wie im <xref linkend="x11"/> installiert und
	konfiguriert ist.</para>

      <para>&man.ttys.5; enthält eine ausführliche
	Beschreibung der Spalten dieser Datei und der verfügbaren
	Optionen für virtuelle Konsolen.</para>
    </sect2>

    <sect2 xml:id="consoles-singleuser">
      <title>Single-User-Modus</title>

      <para>Das &os; Boot-Menü verfügt über eine Option
	<quote>Boot Single User</quote>.  Wird diese Option
	gewählt, bootet das System in einen speziellen Modus, der als
	<quote>Single-User-Modus</quote> bekannt ist.  Dieser Modus
	wird normalerweise zur Reparatur des Systems verwendet,
	bspw. wenn das System nicht mehr startet, oder das
	<systemitem class="username">root</systemitem>-Passwort
	zurückgesetzt werden muss.  Im Single-User-Modus haben Sie
	keinen Zugriff auf das Netzwerk und es stehen Ihnen keine
	weiteren virtuellen Konsolen zur Verfügung.  Allerdings
	haben Sie vollen Zugriff auf das System und in der
	Voreinstellung wird das <systemitem
	  class="username">root</systemitem>-Passwort nicht
	benötigt.  Aus diesem Grund wird ein physischer Zugriff
	auf die Tastatur benötigt, um in diesem Modus zu booten.
	Zur Absicherung eines &os;-Systems sollte ermittelt werden,
	welche Personen physischen Zugriff auf die Tastatur bekommen
	sollen.</para>

      <para>Die Einstellungen für den Single-User-Modus befinden sich
	diesem Abschnitt von <filename>/etc/ttys</filename>:</para>

      <programlisting># name  getty                           type  status  comments
#
# If console is marked "insecure", then init will ask for the root password
# when going to single-user mode.
console none                            unknown  off  secure</programlisting>

      <para>In der Voreinstellung ist der Status auf
	<literal>secure</literal> eingestellt.  Das setzt voraus, dass
	der physische Zugriff auf die Tastatur entweder unwichtig ist,
	oder über eine Sicherheitsrichtlinie geregelt wird.  Wenn der
	Status auf <literal>insecure</literal> eingestellt wird, wird
	davon ausgegangen, dass die Umgebung selbst unsicher ist, da
	jeder Zugriff auf die Tastatur hat.  &os; wird dann nach dem
	<systemitem class="username">root</systemitem>-Passwort
	fragen, wenn ein Benutzer versucht in den Single-User-Modus zu
	booten.</para>

      <note>
	<para><emphasis>Setzen Sie <literal>insecure</literal> nicht
	    leichtfertig ein</emphasis>!  Wenn das
	  <systemitem class="username">root</systemitem>-Passwort
	  vergessen wird, wird es schwierig in den
	  Single-User-Modus zu gelangen, wenn man den Bootprozess von
	  &os; nicht genau versteht.</para>
      </note>
    </sect2>

    <sect2 xml:id="consoles-vidcontrol">
      <title>Den Videomodus der Konsole anpassen</title>

      <para>Der Standard-Videomodus der &os;-Konsole kann auf jeden
	Modus eingestellt werden, der von der Grafikkarte und dem
	Monitor unterstützt wird (beispielsweise 1024x768 oder
	1280x1024).  Um eine andere Einstellung zu verwenden, muss
	das <literal>VESA</literal>-Modul geladen werden:</para>

      <screen>&prompt.root; <userinput>kldload vesa</userinput></screen>

      <para>Um festzustellen, welche Video-Modi von der Hardware
	unterstützt werden, nutzen Sie &man.vidcontrol.1;.  Um eine
	Liste aller unterstützten Modi zu sehen, verwenden Sie diesen
	Befehl:</para>

      <screen>&prompt.root; <userinput>vidcontrol -i mode</userinput></screen>

      <para>Die Ausgabe dieses Befehls listet alle Videomodi, die von
	der Hardware unterstützt werden.  Um einen neuen Video-Modi zu
	wählen, wird der entsprechende Modus als
	<systemitem class="username">root</systemitem>-Benutzer an
	&man.vidcontrol.1; übergeben:</para>

      <screen>&prompt.root; <userinput>vidcontrol MODE_279</userinput></screen>

      <para>Um diese Einstellung dauerhaft zu speichern, muss
	folgende Zeile in <filename>/etc/rc.conf</filename>
	hinzugefügt werden:</para>

      <programlisting>allscreens_flags="MODE_279"</programlisting>
    </sect2>
  </sect1>

  <!--
  <chapterinfo>
    <authorgroup>
      <author>
	<personname>
	  <firstname>Neil</firstname>
	  <surname>Blakey-Milner</surname>
	</personname>
	<contrib>Beigetragen von </contrib>
      </author>
      <author>
	<personname>
	  <firstname>Robert</firstname>
	  <surname>Drehmel</surname>
	</personname>
	<contrib>Übersetzt von </contrib>
      </author>
    </authorgroup>
  </chapterinfo>
  -->
  <sect1 xml:id="users-synopsis">
    <title>Benutzer und grundlegende Account-Verwaltung</title>

    <para>&os; ermöglicht es mehreren Benutzern, den Computer zur
      selben Zeit zu benutzen.  Es kann immer nur ein Benutzer
      vor der Konsole sitzen, aber es können sich beliebig viele
      Benutzer über das Netzwerk am System anmelden.  Jeder Benutzer
      muss einen Account haben, um das System benutzen zu
      können.</para>

    <para>Nachdem Sie dieses Kapitel gelesen haben, werden Sie</para>

    <itemizedlist>
      <listitem>
	<para>die verschiedenen Account-Typen von &os; kennen,</para>
      </listitem>

      <listitem>
	<para>wissen, wie Sie Accounts angelegen, verändern oder
	  löschen,</para>
      </listitem>

      <listitem>
	<para>wissen, wie Sie Limits für einen Benutzer oder eine
	  Gruppe setzen, um beispielsweise Ressourcen, wie Speicher
	  oder CPU-Zeit einzuschränken,</para>
      </listitem>

      <listitem>
	<para>wissen, wie Sie Gruppen erstellen und Benutzer zu
	  diesen Gruppen hinzufügen.</para>
      </listitem>
    </itemizedlist>

    <sect2 xml:id="users-introduction">
      <title>Account-Typen</title>

      <para>Jeder Zugriff auf das &os;-System geschieht über Accounts
	und alle Prozesse werden von Benutzern gestartet, also sind
	Benutzer- und Account-Verwaltung von wesentlicher
	Bedeutung.</para>

      <para>Es gibt drei Haupttypen von Accounts: Systembenutzer,
	Benutzer-Accounts und der Superuser-Account.</para>

      <sect3 xml:id="users-system">
	<title>Systembenutzer</title>

	<indexterm>
	  <primary>Accounts</primary>
	  <secondary>System-Accounts</secondary>
	</indexterm>

	<para>Systembenutzer starten Dienste wie DNS, Mail-Server und
	  Web-Server.  Der Grund dafür ist die Sicherheit; wenn die
	  Programme von dem Superuser gestartet werden, können Sie
	  ohne Einschränkungen handeln.</para>

	<indexterm>
	  <primary>Accounts</primary>
	  <secondary><systemitem
	      class="username">daemon</systemitem></secondary>
	</indexterm>
	<indexterm>
	  <primary>Accounts</primary>
	  <secondary><systemitem
	      class="username">operator</systemitem></secondary>
	</indexterm>

	<para>Beispiele von Systembenutzern sind
	  <systemitem class="username">daemon</systemitem>,
	  <systemitem class="username">operator</systemitem>,
	  <systemitem class="username">bind</systemitem>,
	  <systemitem class="username">news</systemitem> und
	  <systemitem class="username">www</systemitem>.</para>

	<indexterm>
	  <primary>Accounts</primary>
	  <secondary><systemitem
	      class="username">nobody</systemitem></secondary>
	</indexterm>

	<para><systemitem class="username">nobody</systemitem> ist der
	  generische unprivilegierte Systembenutzer.  Bedenken Sie
	  aber, dass je mehr Dienste <systemitem
	    class="username">nobody</systemitem> benutzen, desto mehr
	  Dateien und Prozesse diesem Benutzer gehören und dieser
	  Benutzer damit umso privilegierter wird.</para>
      </sect3>

      <sect3 xml:id="users-user">
	<title>Benutzer-Accounts</title>

	<indexterm>
	  <primary>Accounts</primary>
	  <secondary>Benutzer-Accounts</secondary>
	</indexterm>

	<para>Benutzer-Accounts sind realen Personen zugeordnet und sind
	  das primäre Mittel des Zugriffs das System.  Jede Person,
	  die Zugriff auf das System bekommt, sollte einen eindeutigen
	  Benutzer-Account besitzen.  Dies erlaubt es dem
	  Administrator herauszufinden, wer was macht.
	  Gleichzeitig werden die Benutzer daran gehindert, die
	  Einstellungen anderer Benutzer zu zerstören.</para>

	<para>Jeder Benutzer kann die eigene Umgebung anpassen,
	  bspw. seine voreingestellte Shell, Editor, Tastenbelegungen
	  und Spracheinstellungen.</para>

	<para>Mit jedem Account eines &os;-Systems sind bestimmte
	  Informationen verknüpft:</para>

	<variablelist>
	  <varlistentry>
	    <term>Loginnamen</term>

	    <listitem>
	      <para>Der Loginname wird am <prompt>login:</prompt>
		Prompt eingegeben.  Es gibt eine Reihe von Regeln für
		die Erstellung von gültigen Loginnamen, die in
		&man.passwd.5; dokumentiert sind.  Es wird aus
		Kompatibilitätsgründen empfohlen, Benutzernamen zu
		verwenden, die aus Kleinbuchstaben bestehen und bis zu
		acht Zeichen lang sind.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>Passwort</term>

	    <listitem>
	      <para>Jeder Account ist mit einem Passwort
		verknüpft.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>User ID (<acronym>UID</acronym>)</term>

	    <listitem>
	      <para>Die User ID (<acronym>UID</acronym>) ist eine
		Zahl, die verwendet wird, um die Benutzer auf dem
		&os;-System eindeutig zu identifizieren.  Programme,
		die einen Loginnamen akzeptieren, wandeln diesen
		zuerst in eine <acronym>UID</acronym> um.  Es wird
		empfohlen, nur <acronym>UID</acronym>s kleiner
		65535 zu verwenden, da höhere Werte
		Kompatibilitätsprobleme mit einigen Anwendungen
		verursachen können.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>Group ID (<acronym>GID</acronym>)</term>

	    <listitem>
	      <para>Die Group ID (<acronym>GID</acronym>) ist eine
		Zahl, die verwendet wird, um die primäre Gruppe eines
		Benutzers eindeutig zu identifizieren.  Gruppen sind
		ein Mechanismus zur Steuerung des Zugriffs auf
		Ressourcen über die <acronym>GID</acronym> eines
		Benutzers anstelle der <acronym>UID</acronym>.  Dies
		kann die Größe einiger Konfigurationsdateien
		signifikant reduzieren und ermöglicht es Benutzern,
		Mitglied mehreren Gruppen zu sein.  Es wird empfohlen,
		<acronym>GID</acronym>s kleiner 65535 zu verwenden, da
		höhere Werte bei einigen Anwendungen große Probleme
		verursachen können.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>Login-Klasse</term>

	    <listitem>
	      <para>Login-Klassen erweitern das Gruppenkonzept.  Sie
		erhöhen die Flexibilität des Systems in der Handhabung
		der verschiedenen Accounts.  Login-Klassen werden
		auch im <xref linkend="users-limiting"/>
		diskutiert.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>Gültigkeit von Passwörtern</term>

	    <listitem>
	      <para>Ein regelmäßiges Ändern des Passworts wird in
		der Voreinstellung von &os; nicht erzwungen.
		Allerdings können Passwortwechsel nach einer
		gewissen Zeit auf Basis einzelner Accounts mit
		&man.pw.8; erzwungen werden.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>Verfallszeit eines Accounts</term>

	    <listitem>
	      <para>In der Voreinstellung verfallen unter &os; keine
		Accounts.  Wenn Sie Accounts einrichten, die nur für
		eine bestimmte Zeit gültig sein sollen, beispielsweise
		Accounts für Teilnehmer eines Praktikums, können Sie
		mit &man.pw.8; die Gültigkeitsdauer des Accounts
		angeben.  Nachdem die angegebene Zeitspanne
		verstrichen ist, kann dieser Account nicht mehr zum
		Anmelden verwendet werden, obwohl alle Verzeichnisse
		und Dateien, die diesem Account gehören, noch
		vorhanden sind.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>vollständiger Benutzername</term>

	    <listitem>
	      <para>&os; identifiziert einen Account eindeutig über
		den Loginnamen, der aber keine Ähnlichkeit mit dem
		richtigen Namen des Benutzers haben muss.  Ähnlich
		wie bei einem Kommentar, erlaubt diese Information
		Großbuchstaben und mehr als 8 Zeichen.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>Heimatverzeichnis</term>

	    <listitem>
	      <para>Das Heimatverzeichnis gibt den vollständigen Pfad
		zu dem Verzeichnis an, in dem sich der Benutzer nach
		erfolgreicher Anmeldung befindet.  Es ist üblich, alle
		Heimatverzeichnisse unter
		<filename>/home/<replaceable>Loginname</replaceable></filename>
		oder
		<filename>/usr/home/<replaceable>Loginname</replaceable></filename>
		anzulegen.  Im Heimatverzeichnis oder in dort
		angelegten Verzeichnissen werden die Dateien eines Benutzers
		gespeichert.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>Login-Shell</term>

	    <listitem>
	      <para>Grundsätzlich ist die Shell, von denen es viele
		unterschiedliche gibt, eine Schnittstelle zum System.
		Die bevorzugte Shell eines Benutzers kann seinem
		Account zugeordnet werden.</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </sect3>

      <sect3 xml:id="users-superuser">
	<title>Der Superuser-Account</title>

	<indexterm>
	  <primary>Accounts</primary>
	  <secondary>Superuser (root)</secondary>
	</indexterm>

	<para>Der Superuser-Account, normalerweise <systemitem
	    class="username">root</systemitem> genannt, ist
	  vorkonfiguriert und erleichtert die Systemverwaltung, sollte
	  aber nicht für alltägliche Aufgaben wie das Verschicken und
	  Empfangen von Mails, Erforschen des Systems oder
	  Programmierung benutzt werden.</para>

	<para>Der Superuser kann, im Gegensatz zu normalen
	  Benutzer-Accounts, ohne Beschränkungen operieren und die
	  falsche Anwendung des Superuser-Accounts kann in
	  spektakulären Katastrophen resultieren.  Benutzer-Accounts
	  sind nicht in der Lage, das System versehentlich zu
	  zerstören, deswegen wird empfohlen, normale
	  Benutzer-Accounts zu verwenden, solange nicht zusätzliche
	  Privilegien benötigt werden.</para>

	<para>Kommandos, die Sie als Superuser eingeben, sollten Sie
	  immer doppelt und dreifach überprüfen, da ein zusätzliches
	  Leerzeichen oder ein fehlender Buchstabe irreparablen
	  Datenverlust bedeuten kann.</para>

	<para>Es gibt mehrere Möglichkeiten Superuser-Rechte zu
	  bekommen.  Obwohl man sich direkt als <systemitem
	    class="username">root</systemitem> anmelden kann, wird von
	  dieser Methode dringend abgeraten.</para>

	<para>Verwenden Sie stattdessen &man.su.1; um zum Superuser zu
	  werden. Wenn Sie noch ein <literal>-</literal> eingeben,
	  wird der Benutzer auch die Umgebung des Root-Benutzers
	  erben.  Der Benutzer, der diesen Befehl ausführt muss
	  Mitglied der Gruppe <systemitem
	    class="groupname">wheel</systemitem> sein, oder der
	  Befehl schlägt fehl.  Zudem muss der Benutzer das Kennwort
	  für den Benutzer-Account <systemitem
	    class="username">root</systemitem> kennen.</para>

	<para>In diesem Besipiel wird der Benutzer nur zum Superuser,
	  um <command>make install</command> auszuführen, da dieser
	  Befehl Superuser-Rechte erfordert.  Nachdem der Befehl
	  ausgeführt wurde, kann der Benutzer <command>exit</command>
	  eingeben, um den Superuser-Account zu verlassen und zu den
	  Privilegien des Benutzer-Accounts zurückkehren.</para>

	<example>
	  <title>Ein Programm als Superuser installieren</title>

	  <screen>&prompt.user; <userinput>configure</userinput>
&prompt.user; <userinput>make</userinput>
&prompt.user; <userinput>su -</userinput>
Password:
&prompt.root; <userinput>make install</userinput>
&prompt.root; <userinput>exit</userinput>
&prompt.user;</screen>
	</example>

	<para>Das in &os; enthaltene &man.su.1; funktioniert gut für
	  einzelne Systeme oder in kleineren Netzwerken, mit nur einem
	  Administrator.  Eine Alternative ist es, das Paket oder den
	  Port <package>security/sudo</package> zu installieren.
	  Diese Software bietet eine Protokollierung von Aktivitäten
	  und ermöglicht es dem Administrator zu bestimmen, welche
	  Benutzer welche Befehle als Superuser ausführen
	  dürfen.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="users-modifying">
      <title>Accounts verändern</title>

      <indexterm>
	<primary>Accounts</primary>
	<secondary>verändern</secondary>
      </indexterm>

      <para>&os; stellt eine Vielzahl an Programmen bereit, um
	Accounts zu verändern.  Die gebräuchlichsten Kommandos sind in
	<xref linkend="users-modifying-utilities"/>
	gefolgt von einer detaillierten Beschreibung,
	zusammengefasst.  Weitere Informationen und
	Anwendungsbeispiele finden Sie in der Manualpage des
	jeweiligen Programms.</para>

      <table frame="none" pgwide="1"
	xml:id="users-modifying-utilities">
	<title>Programme zur Verwaltung von Benutzer-Accounts</title>

	<tgroup cols="2">
	  <colspec colwidth="1*"/>
	  <colspec colwidth="2*"/>

	  <thead>
	    <row>
	      <entry>Programm</entry>
	      <entry>Zusammenfassung</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>&man.adduser.8;</entry>
	      <entry>Das empfohlene Werkzeug, um neue Accounts zu
		erstellen.</entry>
	    </row>
	    <row>
	      <entry>&man.rmuser.8;</entry>
	      <entry>Das empfohlene Werkzeug, um Accounts zu
		löschen.</entry>
	    </row>
	    <row>
	      <entry>&man.chpass.1;</entry>
	      <entry>Ein flexibles Werkzeug, um Informationen in der
		Account-Datenbank zu verändern.</entry>
	    </row>
	    <row>
	      <entry>&man.passwd.1;</entry>
	      <entry>Ein einfaches Werkzeug, um Passwörter von Accounts
		zu ändern.</entry>
	    </row>
	    <row>
	      <entry>&man.pw.8;</entry>
	      <entry>Ein mächtiges und flexibles Werkzeug um alle
		Informationen über Accounts zu ändern.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <sect3 xml:id="users-adduser">
	<title><command>adduser</command></title>

	<indexterm>
	  <primary>Accounts</primary>
	  <secondary>erstellen</secondary>
	</indexterm>
	<indexterm>
	  <primary><command>adduser</command></primary>
	</indexterm>
	<indexterm>
	  <primary><filename>/usr/share/skel</filename></primary>
	</indexterm>

	<para>&man.adduser.8; ist ein einfaches Programm zum
	  Hinzufügen neuer Benutzer.  Wenn ein neuer Benutzer
	  hinzugefügt wird, aktualisiert das Programm automatisch
	  <filename>/etc/passwd</filename> und
	  <filename>/etc/group</filename>.  Es erstellt auch das
	  Heimatverzeichnis für den Benutzer, kopiert die
	  Standardkonfigurationsdateien aus
	  <filename>/usr/share/skel</filename> und kann optional
	  eine ,,Willkommen``-Nachricht an den neuen Benutzer
	  versenden.</para>

	<example>
	  <title>Einen Benutzer unter &os; anlegen</title>

	  <screen>&prompt.root; <userinput>adduser</userinput>
Username: <userinput>jru</userinput>
Full name: <userinput>J. Random User</userinput>
Uid (Leave empty for default):
Login group [jru]:
Login group is jru. Invite jru into other groups? []: <userinput>wheel</userinput>
Login class [default]:
Shell (sh csh tcsh zsh nologin) [sh]: <userinput>zsh</userinput>
Home directory [/home/jru]:
Home directory permissions (Leave empty for default):
Use password-based authentication? [yes]:
Use an empty password? (yes/no) [no]:
Use a random password? (yes/no) [no]:
Enter password:
Enter password again:
Lock out the account after creation? [no]:
Username   : jru
Password   : ****
Full Name  : J. Random User
Uid        : 1001
Class      :
Groups     : jru wheel
Home       : /home/jru
Shell      : /usr/local/bin/zsh
Locked     : no
OK? (yes/no): <userinput>yes</userinput>
adduser: INFO: Successfully added (jru) to the user database.
Add another user? (yes/no): <userinput>no</userinput>
Goodbye!
&prompt.root;</screen>
	</example>

	<note>
	  <para>Wenn Sie das Passwort eingeben, werden weder Passwort noch
	    Sternchen angezeigt.  Passen Sie auf, dass Sie das Passwort
	    korrekt eingeben.</para>
	</note>
      </sect3>

      <sect3 xml:id="users-rmuser">
	<title><command>rmuser</command></title>

	<indexterm>
	  <primary><command>rmuser</command></primary>
	</indexterm>
	<indexterm>
	  <primary>Accounts</primary>
	  <secondary>löschen</secondary>
	</indexterm>

	<para>Benutzen Sie &man.rmuser.8;, um einen Account
	  vollständig aus dem System zu entfernen.  Dieses Programm
	  führt die folgenden Schritte durch:</para>

	<procedure>
	  <step>
	    <para>Entfernt den &man.crontab.1; Eintrag des Benutzers,
	      wenn dieser existiert.</para>
	  </step>

	  <step>
	    <para>Entfernt alle &man.at.1; jobs, die dem Benutzer
	      gehören.</para>
	  </step>

	  <step>
	    <para>Schließt alle Prozesse des Benutzers.</para>
	  </step>

	  <step>
	    <para>Entfernt den Benutzer aus der lokalen Passwort-Datei
	      des Systems.</para>
	  </step>

	  <step>
	    <para>Entfernt das Heimatverzeichnis des Benutzers, falls
	      es dem Benutzer gehört.</para>
	  </step>

	  <step>
	    <para>Entfernt eingegangene E-Mails des Benutzers
	      aus <filename>/var/mail</filename>.</para>
	  </step>

	  <step>
	    <para>Entfernt alle Dateien des Benutzers aus temporären
	      Dateispeicherbereichen wie
	      <filename>/tmp</filename>.</para>
	  </step>

	  <step>
	    <para>Entfernt den Loginnamen von allen Gruppen, zu denen
	      er gehört, aus <filename>/etc/group</filename>.  Wenn
	      eine Gruppe leer wird und der Gruppenname mit dem
	      Loginnamen identisch ist, wird die Gruppe entfernt.  Das
	      ergänzt sich mit den einzelnen Benutzer-Gruppen, die von
	      &man.adduser.8; für jeden neuen Benutzer erstellt
	      werden.</para>
	  </step>
	</procedure>

	<para>Der Superuser-Account kann nicht mit &man.rmuser.8;
	  entfernt werden, da dies in den meisten Fällen das System
	  unbrauchbar macht.</para>

	<para>Als Vorgabe wird ein interaktiver Modus benutzt.</para>

	<example>
	  <title>Interaktives Löschen von Accounts mit
	    <command>rmuser</command></title>

	  <screen>&prompt.root; <userinput>rmuser jru</userinput>
Matching password entry:
jru:*:1001:1001::0:0:J. Random User:/home/jru:/usr/local/bin/zsh
Is this the entry you wish to remove? <userinput>y</userinput>
Remove user's home directory (/home/jru)? <userinput>y</userinput>
Updating password file, updating databases, done.
Updating group file: trusted (removing group jru -- personal group is empty) done.
Removing user's incoming mail file /var/mail/jru: done.
Removing files belonging to jru from /tmp: done.
Removing files belonging to jru from /var/tmp: done.
Removing files belonging to jru from /var/tmp/vi.recover: done.
&prompt.root;</screen>
	</example>
      </sect3>

      <sect3 xml:id="users-chpass">
	<title><command>chpass</command></title>

	<indexterm>
	  <primary><command>chpass</command></primary>
	</indexterm>

	<para>Mit &man.chpass.1; können Informationen der
	  Benutzerdatenbank, wie Passwörter, Shells und persönliche
	  Informationen verändert werden.</para>

	<para>Nur der Superuser kann die Informationen und Passwörter
	  der anderen Benutzer mit &man.chpass.1; verändern.</para>

	<para>Werden neben dem optionalen Loginnamen keine weiteren
	  Optionen angegeben, zeigt &man.chpass.1; einen Editor mit
	  Account-Informationen an.  Wenn der Benutzer den Editor
	  verlässt, wird die Account-Datenbank mit den neuen
	  Informationen aktualisiert.</para>

	<note>
	  <para>Unter &os; wird nach dem Verlassen des Editors nach
	    dem Passwort gefragt, es sei denn, man ist als Superuser
	    angemeldet.</para>
	</note>

	<example>
	  <title>Interaktives <command>chpass</command> des Superusers</title>

	  <screen>#Changing user database information for jru.
Login: jru
Password: *
Uid [#]: 1001
Gid [# or name]: 1001
Change [month day year]:
Expire [month day year]:
Class:
Home directory: /home/jru
Shell: /usr/local/bin/zsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:</screen>
	</example>

	<para>Der normale Benutzer kann nur einen kleinen Teil dieser
	  Informationen verändern und natürlich nur die Daten des
	  eigenen Accounts.</para>

	<example>
	  <title>Interaktives <command>chpass</command> eines normalen
	    Benutzers</title>

	  <screen>#Changing user database information for jru.
Shell: /usr/local/bin/tcsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:</screen>
	</example>

	<note>
	  <para>&man.chfn.1; und &man.chsh.1; sind nur Verweise auf
	    &man.chpass.1; genauso wie &man.ypchpass.1;,
	    &man.ypchfn.1; und &man.ypchsh.1;.  <acronym>NIS</acronym>
	    wird automatisch unterstützt, deswegen ist es nicht
	    notwendig das <literal>yp</literal> vor dem Kommando
	    einzugeben.  <acronym>NIS</acronym> wird später im
	    <xref linkend="network-servers"/> besprochen.</para>
	</note>
      </sect3>

      <sect3 xml:id="users-passwd">
	<title><application>passwd</application></title>

	<indexterm>
	  <primary><command>passwd</command></primary>
	</indexterm>
	<indexterm>
	  <primary>Accounts</primary>
	  <secondary>Passwort wechseln</secondary>
	</indexterm>
	
	<para>&man.passwd.1; ist der übliche Weg, Ihr eigenes Passwort
	  als Benutzer zu ändern oder das Passwort eines anderen
	  Benutzers als Superuser.</para>

	<note>
	  <para>Um unberechtigte Änderungen zu verhindern,
	    muss bei einem Passwortwechsel zuerst das ursprüngliche
	    Passwort eingegeben werden.</para>
	</note>

	<example>
	  <title>Das eigene Passwort wechseln</title>

	  <screen>&prompt.user; <userinput>passwd</userinput>
Changing local password for jru.
Old password:
New password:
Retype new password:
passwd: updating the database...
passwd: done</screen>

	</example>

	<example>
	  <title>Als Superuser das Passwort eines anderen Accounts
	    verändern</title>

	  <screen>&prompt.root; <userinput>passwd jru</userinput>
Changing local password for jru.
New password:
Retype new password:
passwd: updating the database...
passwd: done</screen>
	</example>

	<note>
	  <para>Wie bei &man.chpass.1; ist &man.yppasswd.1;
	    nur ein Verweis auf &man.passwd.1;.  NIS wird von
	    jedem dieser Kommandos unterstützt.</para>
	</note>
      </sect3>

      <sect3 xml:id="users-pw">
	<title><command>pw</command></title>

	<indexterm>
	  <primary><command>pw</command></primary>
	</indexterm>

	<para>&man.pw.8; ist ein Kommandozeilenprogramm, mit dem man
	  Accounts und Gruppen erstellen, entfernen, verändern und
	  anzeigen kann.  Dieses Kommando dient als Schnittstelle zu
	  den Benutzer- und Gruppendateien des Systems.  &man.pw.8;
	  besitzt eine Reihe mächtiger Kommandozeilenschalter, die es
	  für die Benutzung in Shell-Skripten geeignet machen, doch
	  finden neue Benutzer die Bedienung des Kommandos
	  komplizierter, als die der anderen hier vorgestellten
	  Kommandos.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="users-limiting">
      <title>Benutzer einschränken</title>

      <indexterm><primary>Benutzer einschränken</primary></indexterm>
      <indexterm>
	<primary>Accounts</primary>
	<secondary>einschränken</secondary>
      </indexterm>

      <para>&os; bietet dem Systemadministrator mehrere
	Möglichkeiten die System-Ressourcen, die ein einzelner
	Benutzer verwenden kann, einzuschränken.  Diese Limitierungen
	sind in zwei Kategorien eingeteilt: Festplattenkontingente und
	andere Ressourcenbeschränkungen.</para>

      <indexterm><primary>Quotas</primary></indexterm>
      <indexterm>
	<primary>Benutzer einschränken</primary>
	<secondary>Quotas</secondary>
      </indexterm>
      <indexterm><primary>Festplatten Quotas</primary></indexterm>

      <para>Festplatten-Kontingente schränken den Plattenplatz, der
	einem Benutzer zur Verfügung steht, ein.  Sie bieten zudem,
	ohne aufwändige Berechnung, einen schnellen Überblick
	über den verbrauchten Plattenplatz.  Kontingente werden im
	<xref linkend="quotas"/> diskutiert.</para>

      <para>Die anderen Ressourcenbeschränkungen umfassen die
	Begrenzung von CPU, Speicher und weitere Ressourcen, die ein
	Benutzer verbrauchen kann.</para>

      <indexterm>
	<primary><filename>/etc/login.conf</filename></primary>
      </indexterm>

      <para>Login-Klassen werden in
	<filename>/etc/login.conf</filename> und sind in
	&man.login.conf.5; im Detail beschrieben.n.  Jeder Benutzer
	wird einer Login-Klasse zugewiesen (standardmäßig
	<literal>default</literal>) und jede Login-Klasse ist mit
	einem Satz von Login-Fähigkeiten verbunden.  Eine
	Login-Fähigkeit ist ein
	<literal><replaceable>Name</replaceable>=<replaceable>Wert</replaceable></literal>
	Paar, in dem <replaceable>Name</replaceable> die Fähigkeit
	bezeichnet und <replaceable>Wert</replaceable> ein beliebiger
	Text ist, der in Abhänigkeit von
	<replaceable>Name</replaceable> entsprechend verarbeitet wird.
	Login-Klassen und -Fähigkeiten zu definieren ist ziemlich
	einfach und wird auch in &man.login.conf.5;
	beschrieben.</para>

      <note>
	<para>&os; liest die Konfiguration aus
	  <filename>/etc/login.conf</filename> normalerweise nicht
	  direkt, sondern nur über die Datenbank
	  <filename>/etc/login.conf.db</filename>, da diese eine
	  schnellere Abfrage erlaubt.  Wenn
	  <filename>/etc/login.conf</filename> verändert wurde, muss
	  die <filename>/etc/login.conf.db</filename> mit dem
	  folgenden Kommando aktualisiert werden:</para>

	<screen>&prompt.root; <userinput>cap_mkdb /etc/login.conf</userinput></screen>
      </note>

      <para>Ressourcenbeschränkungen unterscheiden sich von normalen
	Login-Fähigkeiten zweifach.  Erstens gibt es für jede
	Beschränkung ein aktuelles und ein maximales Limit.  Das
	aktuelle Limit kann vom Benutzer oder einer Anwendung beliebig
	bis zum maximalen Limit verändert werden.  Letzteres kann
	der Benutzer nur heruntersetzen.  Zweitens gelten die meisten
	Ressourcenbeschränkungen für jeden vom Benutzer gestarteten
	Prozess, nicht für den Benutzer selbst.  Beachten Sie jedoch,
	dass diese Unterschiede durch das spezifische Einlesen der
	Limits und nicht durch das System der Login-Fähigkeiten
	entstehen (das heißt, Ressourcenbeschränkungen sind
	<emphasis>keine</emphasis> Login-Fähigkeiten).</para>

      <para>Hier befinden sich die am häufigsten benutzten
	Ressourcenbeschränkungen.  Der Rest kann zusammen mit den
	anderen Login-Fähigkeiten in &man.login.conf.5; gefunden
	werden:</para>

      <variablelist>
	<varlistentry>
	  <term><literal>coredumpsize</literal></term>

	  <listitem>
	    <indexterm><primary>coredumpsize</primary></indexterm>
	    <indexterm>
	      <primary>Benutzer einschränken</primary>
	      <secondary>coredumpsize</secondary>
	    </indexterm>

	    <para>Das Limit der Größe einer core-Datei, die von einem
	      Programm generiert wird, unterliegt aus offensichtlichen
	      Gründen anderen Limits der Festplattenbenutzung, zum
	      Beispiel <literal>filesize</literal> oder
	      Festplattenkontingenten.  Es wird aber trotzdem oft als
	      weniger harte Methode zur Kontrolle des
	      Festplattenplatz-Verbrauchs verwendet: Da Benutzer die
	      core-Dateien nicht selbst erstellen und sie oft nicht
	      löschen, kann sie diese Option davor retten, dass kein
	      Festplattenspeicher mehr zur Verfügung steht, sollte ein
	      großes Programm abstürzen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>cputime</literal></term>

	  <listitem>
	    <indexterm><primary>cputime</primary></indexterm>
	    <indexterm>
	      <primary>Benutzer einschränken</primary>
	      <secondary>cputime</secondary>
	    </indexterm>

	    <para>Die maximale Rechenzeit, die ein Prozess eines
	      Benutzers verbrauchen darf.  Überschreitet der Prozess
	      diesen Wert, wird er vom Kernel beendet.</para>

	    <note>
	      <para>Die Rechen<emphasis>zeit</emphasis> wird
		limitiert, nicht die prozentuale Prozessorenbenutzung,
		wie es in einigen Feldern in &man.top.1; und
		&man.ps.1; dargestellt wird.</para>
	    </note>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>filesize</literal></term>

	  <listitem>
	    <indexterm><primary>filesize</primary></indexterm>
	    <indexterm>
	      <primary>Benutzer einschränken</primary>
	      <secondary>filesize</secondary>
	    </indexterm>

	    <para>Hiermit lässt sich die maximale Größe einer Datei
	      bestimmen, die der Benutzer besitzen darf.  Im Gegensatz
	      zu <link linkend="quotas">Festplattenkontingenten</link>
	      ist diese Beschränkung nur für jede einzelne Datei
	      gültig und nicht für den Platz, den alle Dateien eines
	      Benutzers verwenden.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>maxproc</literal></term>

	  <listitem>
	    <indexterm><primary>maxproc</primary></indexterm>
	    <indexterm>
	      <primary>Benutzer einschränken</primary>
	      <secondary>maxproc</secondary>
	    </indexterm>

	    <para>Das ist die maximale Anzahl von Prozessen, die ein
	      Benutzer starten darf, und beinhaltet sowohl
	      Vordergrund- als auch Hintergrundprozesse.  Natürlich
	      darf dieser Wert nicht höher sein als das System-Limit,
	      das in <varname>kern.maxproc</varname> angegeben ist.
	      Vergessen Sie auch nicht, dass ein zu kleiner Wert den
	      Benutzer in seiner Produktivität einschränken könnte; es
	      ist oft nützlich, mehrfach eingeloggt zu sein, oder
	      <foreignphrase>Pipelines</foreignphrase>
		<footnote>
		  <para><foreignphrase>Pipeline</foreignphrase> =
		    <emphasis>Leitung</emphasis>.
		    Mit <foreignphrase>Pipes</foreignphrase> sind
		    Verbindungen zwischen zwei Sockets in meistens
		    zwei verschiedenen Prozessen gemeint.</para>
		</footnote>
	      zu verwenden.  Ein paar Aufgaben, wie die Kompilierung
	      eines großen Programms, starten mehrere Prozesse.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>memorylocked</literal></term>

	  <listitem>
	    <indexterm><primary>memorylocked</primary></indexterm>
	    <indexterm>
	      <primary>Benutzer einschränken</primary>
	      <secondary>memorylocked</secondary>
	    </indexterm>

	    <para>Dieses Limit gibt an, wie viel virtueller Speicher
	      von einem Prozess maximal im Arbeitsspeicher festgesetzt
	      werden kann (siehe auch &man.mlock.2;).  Ein paar
	      systemkritische Programme, wie &man.amd.8;, verhindern
	      damit einen Systemzusammenbruch, der auftreten könnte,
	      wenn sie aus dem Speicher genommen werden.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>memoryuse</literal></term>

	  <listitem>
	    <indexterm><primary>memoryuse</primary></indexterm>
	    <indexterm>
	      <primary>Benutzer einschränken</primary>
	      <secondary>memoryuse</secondary>
	    </indexterm>

	    <para>Bezeichnet den maximalen Speicher, den ein Prozess
	      benutzen darf und beinhaltet sowohl Arbeitsspeicher-,
	      als auch Swap- Benutzung.  Es ist kein allübergreifendes
	      Limit für den Speicherverbrauch, aber ein guter
	      Anfang.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>openfiles</literal></term>

	  <listitem>
	    <indexterm><primary>openfiles</primary></indexterm>
	    <indexterm>
	      <primary>Benutzer einschränken</primary>
	      <secondary>openfiles</secondary>
	    </indexterm>

	    <para>Mit diesem Limit lässt sich die maximale Anzahl
	      der von einem Prozess des Benutzers geöffneten Dateien
	      festlegen.  In &os; werden Dateien auch verwendet, um
	      Sockets und <foreignphrase>IPC</foreignphrase>-Kanäle
	      <footnote>
		<para><foreignphrase>IPC</foreignphrase> steht für
		  <foreignphrase>Interprocess
		    Communication</foreignphrase>.</para>
	      </footnote>
	      darzustellen.  Setzen Sie es deshalb nicht zu niedrig.
	      Das System-Limit ist im <varname>kern.maxfiles</varname>
	      &man.sysctl.8; definiert.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>sbsize</literal></term>

	  <listitem>
	    <indexterm><primary>sbsize</primary></indexterm>
	    <indexterm>
	      <primary>Benutzer einschränken</primary>
	      <secondary>sbsize</secondary>
	    </indexterm>

	    <para>Dieses Limit beschränkt den Netzwerk-Speicher und
	      damit die mbufs, die ein Benutzer verbrauchen darf.  Es
	      stammt aus einer Antwort auf einen DoS-Angriff, bei dem
	      viele Netzwerk-Sockets geöffnet wurden, kann aber
	      generell dazu benutzt werden Netzwerk-Verbindungen zu
	      beschränken.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>stacksize</literal></term>

	  <listitem>
	    <para>Das ist die maximale Größe, auf die der Stack eines
	      Prozesses heranwachsen darf.  Das allein ist natürlich
	      nicht genug, um den Speicher zu beschränken, den ein
	      Programm verwenden darf.  Es sollte deshalb in
	      Verbindung mit anderen Limits gesetzt werden.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>Beim Setzen von Ressourcenbeschränkungen sind noch andere
	Dinge zu beachten.  Nachfolgend ein paar generelle Tipps,
	Empfehlungen und verschiedene Kommentare.</para>

      <itemizedlist>
	<listitem>
	  <para>Von <filename>/etc/rc</filename> beim Hochfahren des
	    Systems gestartete Prozesse werden der
	    <literal>daemon</literal> Login-Klasse zugewiesen.</para>
	</listitem>

	<listitem>
	  <para>Obwohl das mitgelieferte
	    <filename>/etc/login.conf</filename> eine Quelle von
	    vernünftigen Limits darstellt, können nur Sie, der
	    Administrator, wissen, was für Ihr System angebracht ist.
	    Ein Limit zu hoch anzusetzen könnte Ihr System für
	    Missbrauch öffnen, und ein zu niedriges Limit der
	    Produktivität einen Riegel vorschieben.</para>
	</listitem>

	<listitem>
	  <para>Benutzer des <application>&xorg;</application> sollten
	    wahrscheinlich mehr Ressourcen zugeteilt bekommen als
	    andere Benutzer.  <application>&xorg;</application>
	    beansprucht selbst schon eine Menge Ressourcen, verleitet
	    die Benutzer aber auch, mehrere Programme gleichzeitig
	    laufen zu lassen.</para>
	</listitem>

	<listitem>
	  <para>Bedenken Sie, dass viele Limits für einzelne Prozesse
	    gelten und nicht für den Benutzer selbst.  Setzt man zum
	    Beispiel <varname>openfiles</varname> auf 50, kann jeder
	    Prozess des Benutzers bis zu 50 Dateien öffnen.  Dadurch
	    ist die maximale Anzahl von Dateien, die von einem
	    Benutzer geöffnet werden können,
	    <literal>openfiles</literal> mal
	    <literal>maxproc</literal>.  Das gilt auch für den
	    Speicherverbrauch.</para>
	</listitem>
      </itemizedlist>

      <para>Weitere Informationen über Ressourcenbeschränkungen,
	Login-Klassen und -Fähigkeiten finden Sie in &man.cap.mkdb.1;,
	&man.getrlimit.2; und &man.login.conf.5;.</para>
    </sect2>

    <sect2 xml:id="users-groups">
      <title>Gruppen</title>

      <indexterm><primary>Gruppen</primary></indexterm>
      <indexterm>
	<primary><filename>/etc/groups</filename></primary>
      </indexterm>
      <indexterm>
	<primary>Accounts</primary>
	<secondary>Gruppen</secondary>
      </indexterm>

      <para>Eine Gruppe ist einfach eine Zusammenfassung von Accounts.
	Gruppen werden durch den Gruppennamen und die
	<acronym>GID</acronym> identifiziert.  Der Kernel von &os;
	entscheidet anhand der <acronym>UID</acronym> und der
	Gruppenmitgliedschaft eines Prozesses, ob er dem Prozess etwas
	erlaubt oder nicht.  Wenn jemand von der
	<acronym>GID</acronym> eines Benutzers oder Prozesses spricht,
	meint er damit meistens die erste Gruppe der
	Gruppenliste.</para>

      <para>Die Zuordnung von Gruppennamen zur <acronym>GID</acronym>
	steht in <filename>/etc/group</filename>, einer Textdatei mit
	vier durch Doppelpunkte getrennten Feldern.  Im ersten Feld
	steht der Gruppenname, das zweite enthält ein verschlüsseltes
	Passwort, das dritte gibt die <acronym>GID</acronym> an und
	das vierte besteht aus einer Komma separierten Liste der
	Mitglieder der Gruppe.  Eine ausführliche Beschreibung der
	Syntax dieser Datei finden Sie in &man.group.5;.</para>

      <para>Wenn Sie <filename>/etc/group</filename> nicht händisch
	editieren möchten, können Sie &man.pw.8; zum Editieren
	benutzen.  Das folgende Beispiel zeigt das Hinzufügen einer
	Gruppe mit dem Namen <systemitem
	  class="groupname">teamtwo</systemitem>:</para>

      <example>
	<title>Setzen der Mitgliederliste einer Gruppe mit
	  &man.pw.8;</title>

	<screen>&prompt.root; <userinput>pw groupadd teamtwo</userinput>
&prompt.root; <userinput>pw groupshow teamtwo</userinput>
teamtwo:*:1100:</screen>
      </example>

      <para><literal>1100</literal> ist die <acronym>GID</acronym> der
	Gruppe <systemitem class="groupname">teamtwo</systemitem>.
	Momentan hat <systemitem
	  class="groupname">teamtwo</systemitem> noch keine
	Mitglieder.  Mit dem folgenden Kommando wird der Benutzer
	<systemitem class="username">jru</systemitem> in die Gruppe
	<systemitem class="groupname">teamtwo</systemitem>
	aufgenommen.</para>

      <example>
	<title>Ein Gruppenmitglied mit &man.pw.8; hinzufügen</title>

	<screen>&prompt.root; <userinput>pw groupmod teamtwo -M jru</userinput>
&prompt.root; <userinput>pw groupshow teamtwo</userinput>
teamtwo:*:1100:jru</screen>
      </example>

      <para>Als Argument von <option>-M</option> geben Sie eine Komma
	separierte Liste von Mitgliedern an, die in die Gruppe
	aufgenommen werden sollen.  Aus den vorherigen Abschnitten ist
	bekannt, dass die Passwort-Datei ebenfalls eine Gruppe für
	jeden Benutzer enthält.  Das System teilt dem Benutzer
	automatisch eine Gruppe zu, die aber vom
	<option>groupshow</option> Kommando von &man.pw.8; nicht
	angezeigt wird.  Diese Information wird allerdings von
	&man.id.1; und ähnlichen Werkzeugen angezeigt.  Das heißt,
	dass &man.pw.8; nur <filename>/etc/group</filename>
	manipuliert, es wird nicht versuchen, zusätzliche
	Informationen aus <filename>/etc/passwd</filename> zu
	lesen.</para>

      <example>
	<title>Hinzufügen eines neuen Gruppenmitglieds mittels
	  &man.pw.8;</title>

	<screen>&prompt.root; <userinput>pw groupmod teamtwo -m db</userinput>
&prompt.root; <userinput>pw groupshow teamtwo</userinput>
teamtwo:*:1100:jru,db</screen>
      </example>

      <para>Die Argumente zur Option <option>-m</option> ist eine
	durch Komma getrennte Liste von Benutzern, die der Gruppe
	hinzugefügt werden sollen.  Anders als im vorherigen Beispiel
	werden diese Benutzer in die Gruppe aufgenommen und ersetzen
	nicht die Liste der bereits bestehenden Benutzer in der
	Gruppe.</para>

      <example>
	<title>Mit <command>id</command> die Gruppenzugehörigkeit
	  bestimmen</title>

	<screen>&prompt.user; <userinput>id jru</userinput>
uid=1001(jru) gid=1001(jru) groups=1001(jru), 1100(teamtwo)</screen>
      </example>

      <para>In diesem Beispiel ist <systemitem
	  class="username">jru</systemitem> Mitglied von
	<systemitem class="groupname">jru</systemitem> und
	<systemitem class="groupname">teamtwo</systemitem>.</para>

      <para>Weitere Informationen zu diesem Befehl und dem Format von
	<filename>/etc/group</filename> finden Sie in &man.pw.8; und
	&man.group.5;.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="permissions">
    <title>Zugriffsrechte</title>
    <indexterm><primary>UNIX</primary></indexterm>

    <para>In &os; besitzt jede Datei und jedes Verzeichnis einen Satz
      von Zugriffsrechten.  Es stehen mehrere Programme zum Anzeigen
      und Bearbeiten dieser Rechte zur Verfügung.  Ein Verständnis für
      die Funktionsweise von Zugriffsrechten ist notwendig, um
      sicherzustellen, dass Benutzer nur auf die von ihnen benötigten
      Dateien zugreifen können und nicht auf die Dateien des
      Betriebssystems oder von anderen Benutzern.</para>

    <para>In diesem Abschnitt werden die traditionellen
      Zugriffsrechte von &unix; beschrieben.  Informationen
      zu feingranularen Zugriffsrechten für Dateisysteme finden
      Sie im <xref linkend="fs-acl"/>.</para>

    <para>In &unix; werden die grundlegenden Zugriffsrechte in
      drei Typen unterteilt: Lesen, Scheiben und Ausführen.
      Diese Zugriffstypen werden verwendet, um den Dateizugriff
      für den Besitzer der Datei, die Gruppe und alle anderen zu
      bestimmen.  Die Lese-, Schreib- und Ausführungsberechtigungen
      werden mit den Buchstaben <literal>r</literal>,
      <literal>w</literal> und <literal>x</literal> dargestellt.
      Alternativ können die Berechtigungen als binäre Zahlen
      dargestellt werden, da jede Berechtigung entweder aktiviert
      oder deaktiviert (<literal>0</literal>) ist.  Wenn die
      Berechtigung als Zahl dargestellt wird, ist die Reihenfolge
      immer als <literal>rwx</literal> zu lesen, wobei
      <literal>r</literal> den Wert <literal>4</literal> hat,
      <literal>w</literal> den Wert <literal>2</literal> und
      <literal>x</literal> den Wert <literal>1</literal>.</para>

    <para>In Tabelle 4.1 sind die einzelnen nummerischen und
      alphabetischen Möglichkeiten zusammengefasst.  Das Zeichen
      <literal>-</literal> in der Spalte
      <quote>Auflistung im Verzeichnis</quote> besagt, dass eine
      eine Berechtigung deaktiviert ist.</para>

    <indexterm><primary>Zugriffsrechte</primary></indexterm>
    <indexterm>
      <primary>Dateizugriffsrechte</primary>
    </indexterm>
    <table frame="none" pgwide="1">
      <title>&unix; Zugriffsrechte</title>

      <tgroup cols="3">
	<thead>
	  <row>
	    <entry>Wert</entry>
	    <entry>Zugriffsrechte</entry>
	    <entry>Auflistung im Verzeichnis</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry>0</entry>
	    <entry>Kein Lesen, Kein Schreiben, Kein Ausführen</entry>
	    <entry><literal>---</literal></entry>
	  </row>

	  <row>
	    <entry>1</entry>
	    <entry>Kein Lesen, Kein Schreiben, Ausführen</entry>
	    <entry><literal>--x</literal></entry>
	  </row>

	  <row>
	    <entry>2</entry>
	    <entry>Kein Lesen, Schreiben, Kein Ausführen</entry>
	    <entry><literal>-w-</literal></entry>
	  </row>

	  <row>
	    <entry>3</entry>
	    <entry>Kein Lesen, Schreiben, Ausführen</entry>
	    <entry><literal>-wx</literal></entry>
	  </row>

	  <row>
	    <entry>4</entry>
	    <entry>Lesen, Kein Schreiben, Kein Ausführen</entry>
	    <entry><literal>r--</literal></entry>
	  </row>

	  <row>
	    <entry>5</entry>
	    <entry>Lesen, Kein Schreiben, Ausführen</entry>
	    <entry><literal>r-x</literal></entry>
	  </row>

	  <row>
	    <entry>6</entry>
	    <entry>Lesen, Schreiben, Kein Ausführen</entry>
	    <entry><literal>rw-</literal></entry>
	  </row>

	  <row>
	    <entry>7</entry>
	    <entry>Lesen, Schreiben, Ausführen</entry>
	    <entry><literal>rwx</literal></entry>
	  </row>
	</tbody>
      </tgroup>
    </table>

    <indexterm>
      <primary>&man.ls.1;</primary>
    </indexterm>
    <indexterm><primary>Verzeichnisse</primary></indexterm>

    <para>Benutzen Sie das Argument <option>-l</option> mit
      &man.ls.1;, um eine ausführliche Verzeichnisauflistung
      zu sehen, die in einer Spalte die Zugriffsrechte für den
      Besitzer, die Gruppe und alle anderen enthält.
      Die Ausgabe von <command>ls -l</command> könnte
      wie folgt aussehen:</para>

    <screen>&prompt.user; <userinput>ls -l</userinput>
total 530
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 myfile
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 otherfile
-rw-r--r--  1 root  wheel    7680 Sep  5 12:31 email.txt</screen>

    <para>Das erste Zeichen (ganz links) der ersten Spalte zeigt an,
      ob es sich um eine normale Datei, ein Verzeichnis, ein
      zeichenorientiertes Gerät, ein Socket oder irgendeine andere
      Pseudo-Datei handelt.  In diesem Beispiel zeigt <literal>-</literal> eine
      normale Datei an.  Die nächsten drei Zeichen,
      dargestellt als <literal>rw-</literal>, ergeben die Rechte
      für den Datei-Besitzer.  Die drei Zeichen danach
      <literal>r--</literal> die Rechte der Gruppe, zu der die Datei
      gehört.  Die letzten drei Zeichen, <literal>r--</literal>,
      geben die Rechte für den Rest der Welt an.  Ein Minus
      bedeutet, dass das Recht nicht gegeben ist.  In diesem Beispiel
      sind die Zugriffsrechte also: der Eigentümer kann die Datei
      lesen und schreiben, die Gruppe kann lesen und alle anderen
      können auch nur lesen.  Entsprechend obiger Tabelle
      wären die Zugriffsrechte für diese Datei
      <literal>644</literal>, worin jede Ziffer die drei Teile der
      Zugriffsrechte dieser Datei verkörpert.</para>

    <para>Wie kontrolliert das System die Rechte von Hardware-Geräten?
      &os; behandelt die meisten Hardware-Geräte als Dateien, welche
      Programme öffnen, lesen und mit Daten beschreiben können.  Diese
      speziellen Gerätedateien sind in <filename>/dev</filename>
      gespeichert.</para>

    <para>Verzeichnisse werden ebenfalls wie Dateien behandelt.  Sie
      haben Lese-, Schreib- und Ausführ-Rechte.  Das
      Ausführungs-Bit hat eine etwas andere Bedeutung für
      ein Verzeichnis als für eine Datei.  Die Ausführbarkeit
      eines Verzeichnisses bedeutet, dass in das Verzeichnis,
      zum Beispiel mit &man.cd.1;, gewechselt werden kann.
      Das bedeutet auch, dass in dem Verzeichnis auf Dateien, deren
      Namen bekannt sind, zugegriffen werden kann, vorausgesetzt die
      Zugriffsrechte der Dateien lassen dies zu.</para>

    <para>Das Leserecht auf einem Verzeichnis erlaubt es, sich den Inhalt
      des Verzeichnisses anzeigen zu lassen.  Um eine Datei mit bekanntem
      Namen in einem Verzeichnis zu löschen, müssen auf dem
      Verzeichnis Schreib- <emphasis>und</emphasis> Ausführ-Rechte
      gesetzt sein.</para>

    <para>Es gibt noch mehr Rechte, aber die werden vor allem in
      speziellen Umständen benutzt, wie zum Beispiel bei
      SetUID-Binaries und Verzeichnissen mit gesetztem Sticky-Bit.
      Mehr über Zugriffsrechte von Dateien und wie sie gesetzt werden,
      finden Sie in &man.chmod.1;.</para>

    <sect2>
      <info><title>Symbolische Zugriffsrechte</title>
	<authorgroup>
	  <author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Beigesteuert von </contrib></author>
	</authorgroup>
      </info>

      
      <indexterm>
	<primary>Zugriffsrechte</primary>
	<secondary>symbolische</secondary>
      </indexterm>

      <para>Symbolische Zugriffsrechte verwenden Zeichen anstelle von
	oktalen Werten, um die Berechtigungen für Dateien oder
	Verzeichnisse festzulegen.  Zugriffsrechte verwenden die
	Syntax <replaceable>Wer</replaceable>,
	<replaceable>Aktion</replaceable> und
	<replaceable>Berechtigung</replaceable>. Die folgenden
	Werte stehen zur Auswahl:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>Option</entry>
	      <entry>Symbol</entry>
	      <entry>Bedeutung</entry>
	    </row>
	  </thead>

	<tbody>
	  <row>
	    <entry><replaceable>Wer</replaceable></entry>
	    <entry>u</entry>
	    <entry>Benutzer (<foreignphrase>user</foreignphrase>)</entry>
	  </row>

	  <row>
	    <entry><replaceable>Wer</replaceable></entry>
	    <entry>g</entry>
	    <entry>Gruppe (<foreignphrase>group</foreignphrase>)</entry>
	  </row>

	  <row>
	    <entry><replaceable>Wer</replaceable></entry>
	    <entry>o</entry>
	    <entry>Andere (<foreignphrase>other</foreignphrase>)</entry>
	  </row>

	  <row>
	    <entry><replaceable>Wer</replaceable></entry>
	    <entry>a</entry>
	    <entry>Alle</entry>
	  </row>

	  <row>
	    <entry><replaceable>Aktion</replaceable></entry>
	    <entry>+</entry>
	    <entry>Berechtigungen hinzufügen</entry>
	  </row>

	  <row>
	    <entry><replaceable>Aktion</replaceable></entry>
	    <entry>-</entry>
	    <entry>Berechtigungen entziehen</entry>
	  </row>

	  <row>
	    <entry><replaceable>Aktion</replaceable></entry>
	    <entry>=</entry>
	    <entry>Berechtigungen explizit setzen</entry>
	  </row>

	  <row>
	    <entry><replaceable>Berechtigung</replaceable></entry>
	    <entry>r</entry>
	    <entry>lesen (<foreignphrase>read</foreignphrase>)</entry>
	  </row>

	  <row>
	    <entry><replaceable>Berechtigung</replaceable></entry>
	    <entry>w</entry>
	    <entry>schreiben (<foreignphrase>write</foreignphrase>)</entry>
	  </row>

	  <row>
	    <entry><replaceable>Berechtigung</replaceable></entry>
	    <entry>x</entry>
	    <entry>ausführen
	      (<foreignphrase>execute</foreignphrase>)</entry>
	  </row>

	  <row>
	    <entry><replaceable>Berechtigung</replaceable></entry>
	    <entry>t</entry>
	    <entry>Sticky-Bit</entry>
	  </row>

	  <row>
	    <entry><replaceable>Berechtigung</replaceable></entry>
	    <entry>s</entry>
	    <entry>Set-UID oder Set-GID</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <para>Diese symbolischen Werte werden zusammen mit &man.chmod.1;
      verwendet.  Beispielsweise würde der folgende Befehl den Zugriff
      auf <replaceable>FILE</replaceable> für alle anderen Benutzer
      verbieten:</para>

    <screen>&prompt.user; <userinput>chmod go= FILE</userinput></screen>

    <para>Wenn Sie mehr als eine Änderung der Rechte einer
      Datei vornehmen wollen, können Sie eine durch Kommata
      getrennte Liste der Rechte angeben.  Das folgende Beispiel
      entzieht der Gruppe und der Welt die Schreibberechtigung auf
      <replaceable>FILE</replaceable> und fügt für jeden
      Ausführungsrechte hinzu:</para>

    <screen>&prompt.user; <userinput>chmod go-w,a+x FILE</userinput></screen>

<!--
    <para>Mit symbolischen Zugriffsrechten können Sie Rechte
      hinzufügen oder Rechte wegnehmen.  Numerische Zugriffsrechte
      erlauben nur das explizite Setzen der Zugriffsrechte.</para>
-->
    </sect2>

    <sect2>
      <info><title>&os; Datei-Flags</title>
	<authorgroup>
	  <author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Beigetragen von </contrib></author>
	</authorgroup>
      </info>

      <para>Zusätzlich zu den Zugriffsrechten unterstützt &os; auch
	die Nutzung von <quote>Datei-Flags</quote>.  Diese erhöhen die
	Sicherheit des Systems, indem sie eine verbesserte Kontrolle
	von Dateien erlauben.  Verzeichnisse werden allerdings nicht
	unterstützt.  Mit dem Einsatz von Datei-Flags kann sogar
	<systemitem class="username">root</systemitem> daran gehindert
	werden, Dateien zu löschen oder zu verändern.</para>

      <para>Datei-Flags werden mit &man.chflags.1; verändert.  Um
	beispielsweise auf der Datei <filename>file1</filename> das
	<quote>unlöschbar</quote>-Flag zu aktivieren, geben Sie
	folgenden Befehl ein:</para>

      <screen>&prompt.root; <userinput>chflags sunlink file1</userinput></screen>

      <para>Um dieses Flag zu deaktivieren, setzen Sie ein
	<quote>no</quote> vor <option>sunlink</option>:</para>

      <screen>&prompt.root; <userinput>chflags nosunlink file1</userinput></screen>

      <para>Um die Flags einer Datei anzuzeigen, verwenden Sie
	&man.ls.1; zusammen mit <option>-lo</option>:</para>

      <screen>&prompt.root; <userinput>ls -lo file1</userinput></screen>

      <programlisting>-rw-r--r--  1 trhodes  trhodes  sunlnk 0 Mar  1 05:54 file1</programlisting>

      <para>Einige Datei-Flags können nur vom
	<systemitem class="username">root</systemitem>-Benutzer
	gesetzt oder gelöscht werden.  Andere wiederum können
	auch vom Eigentümer der Datei gesetzt werden.  Weitere
	Informationen hierzu finden sich in &man.chflags.1; und
	&man.chflags.2;.</para>
    </sect2>

    <sect2>
      <info><title>Die Berechtigungen <literal>setuid</literal>,
          <literal>setgid</literal>, und
          <literal>sticky</literal></title>
        <authorgroup>
          <author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Beigetragen von </contrib></author>
        </authorgroup>
      </info>

      

      <para>Anders als die Berechtigungen, die bereits angesprochen wurden,
        existieren drei weitere Einstellungen, über die alle
        Administratoren Bescheid wissen sollten.  Dies sind die Berechtigungen
        <literal>setuid</literal>, <literal>setgid</literal> und
        <literal>sticky</literal>.</para>

      <para>Diese Einstellungen sind wichtig für manche &unix;-Operationen,
        da sie Funktionalitäten zur Verfügung stellen, die
        normalerweise nicht an gewöhnliche Anwender vergeben wird.
        Um diese zu verstehen, muss der Unterschied zwischen der realen
        und der effektiven Benutzer-ID erwähnt werden.</para>

      <para>Die reale Benutzer-ID ist die <acronym>UID</acronym>, welche den
        Prozess besitzt oder gestartet hat.  Die effektive
        <acronym>UID</acronym> ist diejenige, als die der Prozess läuft.
        Beispielsweise wird &man.passwd.1; mit der realen ID des Benutzers
        ausgeführt, der sein Passwort ändert. Um jedoch die
        Passwortdatenbank zu bearbeiten, wird es effektiv als
        <systemitem class="username">root</systemitem>-Benutzer ausgeführt.  Das
        ermöglicht es normalen Benutzern, ihr Passwort zu ändern, ohne
        einen <errorname>Permission Denied</errorname>-Fehler angezeigt zu
        bekommen.</para>

      <para>Die setuid-Berechtigung kann durch das Voranstellen bei einer
        Berechtigungsgruppe mit der Nummer Vier (4) gesetzt werden, wie im
        folgenden Beispiel gezeigt wird:</para>

      <screen>&prompt.root; <userinput>chmod 4755 suidexample.sh</userinput></screen>

      <para>Die Berechtigungen auf <filename>suidexample.sh</filename>
        sehen jetzt wie folgt aus:</para>

      <programlisting>-rwsr-xr-x   1 trhodes  trhodes    63 Aug 29 06:36 suidexample.sh</programlisting>

      <para>Beachten Sie, dass ein <literal>s</literal> jetzt Teil der
	Berechtigungen des Dateibesitzers geworden ist, welches
        das Ausführen-Bit ersetzt.  Dies ermöglicht es Werkzeugen
        mit erhöhten Berechtigungen zu laufen, wie z.B.
        <command>passwd</command>.</para>

      <note>
	<para>Die <literal>nosuid</literal> &man.mount.8;-Option
	  bewirkt, dass solche Anwendungen stillschweigend scheitern,
	  ohne den Anwender darüber zu informieren.  Diese Option ist
	  nicht völlig zuverlässig, da ein
	  <literal>nosuid</literal>-Wrapper in der Lage wäre, dies zu
          umgehen.</para>
      </note>

      <para>Um dies in Echtzeit zu beobachten, öffnen Sie zwei
	Terminals.  Starten Sie auf einem <command>passwd</command>
	als normaler Benutzer.  Während es auf die Passworteingabe
	wartet, überprüfen Sie die Prozesstabelle und sehen Sie sich
	die Informationen für &man.passwd.1; an:</para>

      <para>Im Terminal A:</para>

      <screen>Changing local password for trhodes
Old Password:</screen>

      <para>Im Terminal B:</para>

      <screen>&prompt.root; <userinput>ps aux | grep passwd</userinput></screen>

      <screen>trhodes  5232  0.0  0.2  3420  1608   0  R+    2:10AM   0:00.00 grep passwd
root     5211  0.0  0.2  3620  1724   2  I+    2:09AM   0:00.01 passwd</screen>

      <para>Obwohl &man.passwd.1; als normaler Benutzer ausgeführt
	wird, benutzt es die effektive <acronym>UID</acronym> von
	<systemitem class="username">root</systemitem>.</para>

      <para>Die <literal>setgid</literal>-Berechtigung führt die gleiche
        Aktion wie die <literal>setuid</literal>-Berechtigung durch, allerdings
        verändert sie die Gruppenberechtigungen.  Wenn eine Anwendung
        oder ein Werkzeug mit dieser Berechtigung ausgeführt wird,
        erhält es die Berechtigungen basierend auf der Gruppe, welche die
        Datei besitzt und nicht die des Benutzers, der den Prozess gestartet
        hat.</para>

      <para>Um die <literal>setgid</literal>-Berechtigung auf einer
	Datei zu setzen, geben Sie &man.chmod.1; eine führende
	Zwei (2) mit:</para>

      <screen>&prompt.root; <userinput>chmod 2755 sgidexample.sh</userinput></screen>

      <para>Beachten Sie in der folgenden Auflistung,
        dass das <literal>s</literal> sich jetzt in dem Feld befindet, das
        für die Berechtigungen der Gruppe bestimmt ist:</para>

      <screen>-rwxr-sr-x   1 trhodes  trhodes    44 Aug 31 01:49 sgidexample.sh</screen>

      <note>
        <para>Obwohl es sich bei dem in diesen Beispielen gezeigten Shellskript
          um eine ausführbare Datei handelt, wird es nicht mit einer
          anderen <acronym>EUID</acronym> oder effektiven Benutzer-ID
          ausgeführt.  Das ist so, weil Shellskripte keinen Zugriff auf
          &man.setuid.2;-Systemaufrufe erhalten.</para>
      </note>

      <para>Die <literal>setuid</literal> und
	<literal>setgid</literal> Berechtigungs-Bits können die
	Systemsicherheit verringern, da sie erhöhte Rechte
	ermöglichen.  Das dritte Berechtigungs-Bit, das
	<literal>sticky bit</literal> kann die Sicherheit eines
	Systems erhöhen.</para>

      <para>Wenn das <literal>sticky bit</literal> auf einem
	Verzeichnis angewendet wird, erlaubt es das Löschen von
	Dateien nur durch den Besitzer der Datei.  Dies ist nützlich,
	um die Löschung von Dateien in öffentlichen Verzeichnissen wie
	<filename>/tmp</filename>, durch Benutzer denen diese Dateien
	nicht gehören, zu verhindern.  Um diese Berechtigung
	anzuwenden, stellen Sie der Berechtigung eine Eins (1)
	voran:</para>

      <screen>&prompt.root; <userinput>chmod 1777 /tmp</userinput></screen>

      <para>Das <literal>sticky bit</literal> kann anhand des
	<literal>t</literal> ganz am Ende der Berechtigungen abgelesen
	werden.</para>

      <screen>&prompt.root; <userinput>ls -al / | grep tmp</userinput></screen>

      <screen>drwxrwxrwt  10 root  wheel         512 Aug 31 01:49 tmp</screen>

    </sect2>
  </sect1>

  <sect1 xml:id="dirstructure">
    <title>Verzeichnis-Strukturen</title>
    <indexterm><primary>Verzeichnis Hierarchien</primary></indexterm>

    <para>Die &os;-Verzeichnishierarchie ist die Grundlage, um
      ein umfassendes Verständnis des Systems zu erlangen.
      Das wichtigste Verzeichnis ist das Root-Verzeichnis
      <quote>/</quote>.  Dieses Verzeichnis ist das
      erste, das während des Bootens eingehangen wird.  Es
      enthält das notwendige Basissystem, um das Betriebssystem in den
      Mehrbenutzerbetrieb zu bringen.  Das Root-Verzeichnis enthält
      auch die Mountpunkte für Dateisysteme, die beim Wechsel in
      den Multiuser-Modus eingehängt werden.</para>

    <para>Ein Mountpunkt ist ein Verzeichnis, in das zusätzliche
      Dateisysteme (in der Regel unterhalb des Wurzelverzeichnisses)
      eingehängt werden können.  Dieser Vorgang wird in
      <xref linkend="disk-organization"/> ausführlich beschrieben.
      Standard-Mountpunkte sind <filename>/usr</filename>,
      <filename>/var</filename>, <filename>/tmp</filename>,
      <filename>/mnt</filename> sowie <filename>/cdrom</filename>.
      Auf diese Verzeichnisse verweisen üblicherweise Einträge
      in <filename>/etc/fstab</filename>.  Diese Datei ist
      eine Tabelle mit verschiedenen Dateisystemen und Mountpunkten,
      vom System gelesen werden.  Die meisten der Dateisysteme in
      <filename>/etc/fstab</filename> werden beim Booten automatisch
      durch das Skript &man.rc.8; gemountet, wenn die zugehörigen
      Einträge nicht mit <option>noauto</option>
      versehen sind.  Weitere Informationen zu diesem Thema finden Sie
      im <xref linkend="disks-fstab"/>.</para>

    <para>Eine vollständige Beschreibung der Dateisystem-Hierarchie
      finden Sie in &man.hier.7;.  Die folgende Aufstellung gibt einen
      kurzen Überblick über die am häufigsten verwendeten
      Verzeichnisse:</para>

    <para>
      <informaltable frame="none" pgwide="1">
        <tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Verzeichnis</entry>
	      <entry>Beschreibung</entry>
	    </row>
	  </thead>
	  <tbody valign="top">
            <row>
	      <entry><filename>/</filename></entry>
	      <entry>Wurzelverzeichnis des Dateisystems.</entry>
            </row>

	    <row>
	      <entry><filename>/bin/</filename></entry>
	      <entry>Grundlegende Werkzeuge für den Single-User-Modus
		sowie den Mehrbenutzerbetrieb.</entry>
	    </row>

	    <row>
	      <entry><filename>/boot/</filename></entry>
	      <entry>Programme und Konfigurationsdateien, die während
		des Bootens benutzt werden.</entry>
	    </row>

	    <row>
	      <entry><filename>/boot/defaults/</filename></entry>
	      <entry>Vorgaben für die Boot-Konfiguration.  Weitere
		Details finden Sie in &man.loader.conf.5;.</entry>
	    </row>

	    <row>
	      <entry><filename>/dev/</filename></entry>
	      <entry>Gerätedateien.  Weitere Details finden Sie in
		&man.intro.4;.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/</filename></entry>
	      <entry>Konfigurationsdateien und Skripten des Systems.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/defaults/</filename></entry>
	      <entry>Vorgaben für die System Konfigurationsdateien.
		Weitere Details finden Sie in &man.rc.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/mail/</filename></entry>
	      <entry>Konfigurationsdateien von MTAs wie
		&man.sendmail.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/namedb/</filename></entry>
	      <entry>Konfigurationsdateien von
		&man.named.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/periodic/</filename></entry>
	      <entry>Täglich, wöchentlich oder monatlich laufende
		Skripte, die von &man.cron.8; gestartet werden.
		Weitere Details finden Sie in
		&man.periodic.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/ppp/</filename></entry>
	      <entry>Konfigurationsdateien von &man.ppp.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/mnt/</filename></entry>
	      <entry>Ein leeres Verzeichnis, das von Systemadministratoren
		häufig als temporärer Mountpunkt genutzt wird.</entry>
	    </row>

	    <row>
	      <entry><filename>/proc/</filename></entry>
	      <entry>Prozess Dateisystem.  Weitere Details finden Sie
		in &man.procfs.5; und &man.mount.procfs.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/rescue/</filename></entry>
	      <entry>Statisch gelinkte Programme zur Wiederherstellung
		des Systems, wie in &man.rescue.8;
		beschrieben.</entry>
	    </row>

	    <row>
	      <entry><filename>/root/</filename></entry>
	      <entry>Home Verzeichnis von <systemitem class="username">root</systemitem>.</entry>
	    </row>

	    <row>
	      <entry><filename>/sbin/</filename></entry>
	      <entry>Systemprogramme und administrative Werkzeuge, die
		grundlegend für den Single-User-Modus und den
		Mehrbenutzerbetrieb sind.</entry>
	    </row>

	    <row>
	      <entry><filename>/tmp/</filename></entry>
	      <entry>Temporäre Dateien, die für gewöhnlich
		bei einem Neustart des Systems verloren gehen.
		Häufig wird ein speicherbasiertes Dateisystem unter
		<filename>/tmp</filename>
		eingehängt.  Dieser Vorgang kann automatisiert werden,
		wenn tmpmfs-bezogene Variablen von &man.rc.conf.5;
		verwendet werden, oder ein entsprechender
		Eintrag in <filename>/etc/fstab</filename> existiert.
		Weitere Informationen finden Sie in
		&man.mdmfs.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/</filename></entry>
	      <entry>Der Großteil der Benutzerprogramme und
		Anwendungen.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/bin/</filename></entry>
	      <entry>Gebräuchliche Werkzeuge, Programmierhilfen und
		Anwendungen.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/include/</filename></entry>
	      <entry>Standard C include-Dateien.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/lib/</filename></entry>
	      <entry>Bibliotheken.</entry>
	    </row>


	    <row>
	      <entry><filename>/usr/libdata/</filename></entry>
	      <entry>Daten verschiedener Werkzeuge.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/libexec/</filename></entry>
	      <entry>System-Dämonen und System-Werkzeuge, die von
		anderen Programmen ausgeführt werden.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/local/</filename></entry>

	      <entry>Lokale Programme und Bibliotheken.  Die
		Ports-Sammlung von &os; benutzt dieses Verzeichnis
		als Zielverzeichnis für Anwendungen.  Innerhalb von
		<filename>/usr/local</filename> sollte das von
		&man.hier.7; beschriebene Layout für
		<filename>/usr</filename> benutzt werden.  Das
		<filename>man</filename> Verzeichnis wird direkt unter
		<filename>/usr/local</filename> anstelle unter
		<filename>/usr/local/share</filename> angelegt.  Die
		Dokumentation der Ports findet sich in
		<filename>share/doc/<replaceable>port</replaceable></filename>.
	      </entry>
	    </row>

	    <row>
	      <entry><filename>/usr/obj/</filename></entry>
	      <entry>Von der Architektur abhängiger Verzeichnisbaum,
		der durch das Bauen von <filename>/usr/src</filename>
		entsteht.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/ports/</filename></entry>
	      <entry>Die &os;-Ports-Sammlung (optional).</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/sbin/</filename></entry>
	      <entry>System-Dämonen und System-Werkzeuge, die von
		Benutzern ausgeführt werden.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/share/</filename></entry>
	      <entry>Von der Architektur unabhängige Dateien.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/src/</filename></entry>
	      <entry>Quelldateien von BSD und/oder lokalen
		Ergänzungen.</entry>
	    </row>

	    <row>
	      <entry><filename>/var/</filename></entry>
	      <entry>Wird für mehrere Zwecke genutzt und enthält
		Logdateien, temporäre Daten und Spooldateien.
		Manchmal wird ein speicherbasiertes Dateisystem unter
		<filename>/var</filename>
		eingehängt.  Dieser Vorgang kann automatisiert werden,
		wenn die varmfs-bezogenen Variablen von
		&man.rc.conf.5; verwendet werden, oder ein
		entsprechender Eintrag in
		<filename>/etc/fstab</filename> existiert.  Weitere
		Informationen finden Sie in &man.mdmfs.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/var/log/</filename></entry>
	      <entry>Verschiedene Logdateien des Systems.</entry>
	    </row>

	    <row>
	      <entry><filename>/var/mail/</filename></entry>
	      <entry>Postfächer der Benutzer.</entry>
	    </row>

	    <row>
	      <entry><filename>/var/spool/</filename></entry>
	      <entry>Verschiedene Spool-Verzeichnisse der Drucker- und
		Mailsysteme.</entry>
	    </row>

	    <row>
	      <entry><filename>/var/tmp/</filename></entry>
	      <entry>Temporäre Dateien, die in der Regel auch bei
		einem Neustart des Systems erhalten bleiben, es sei
		denn, bei
	        <filename>/var</filename> handelt es
	        sich um ein speicherbasiertes Dateisystem.</entry>
	    </row>

	    <row>
	      <entry><filename>/var/yp/</filename></entry>
	      <entry>NIS maps.</entry>
	    </row>

	  </tbody>
	</tgroup>
      </informaltable>
    </para>
  </sect1>

  <sect1 xml:id="disk-organization">
      <title>Festplatten, Slices und Partitionen</title>

      <para>&os; identifiziert Dateien anhand eines Dateinamens.
	In Dateinamen wird zwischen Groß- und Kleinschreibung
	unterschieden:  <filename>readme.txt</filename> und
	<filename>README.TXT</filename> bezeichnen daher zwei
	verschiedene Dateien.  &os; benutzt keine Dateiendungen,
	um den Typ der Datei zu bestimmen, egal ob es sich um ein
	Programm, ein Dokument oder um andere Daten handelt.</para>

      <para>Dateien werden in Verzeichnissen gespeichert.  In einem
	Verzeichnis können sich keine oder hunderte Dateien
	befinden.  Ein Verzeichnis kann auch andere Verzeichnisse
	enthalten und so eine Hierarchie von Verzeichnissen aufbauen,
	die die Ablage von Daten erleichtert.</para>

      <para>In Dateinamen werden Verzeichnisse durch einen
	Schrägstrich (<literal>/</literal>,
	<foreignphrase>Slash</foreignphrase>) getrennt.  Wenn z.B.
	das Verzeichnis <filename>foo</filename>
	ein Verzeichnis <filename>bar</filename>
	enthält, in dem sich die Datei <filename>readme.txt</filename>
	befindet, lautet der vollständige Name der Datei (oder der
	<firstterm>Pfad</firstterm> zur Datei)
	<filename>foo/bar/readme.txt</filename>.  Beachten Sie, dass
	sich dies von &windows; unterscheidet, wo der
	<literal>\</literal> (<foreignphrase>Backslash</foreignphrase>
	für die Trennung von Datei- und Verzeichnisnamen
	verwendet wird.  &os; benutzt keine Laufwerkbuchstaben oder
	Laufwerknamen im Pfad.  Beispielsweise würde man unter
	&os; nicht <filename>c:/foo/bar/readme.txt</filename>
	eingeben.</para>

      <para>Verzeichnisse und Dateien werden in einem Dateisystem
	gespeichert.  Jedes Dateisystem besitzt genau ein
	<firstterm>Wurzelverzeichnis</firstterm>, das so genannte
	<foreignphrase>Root-Directory</foreignphrase>.  Dieses
	Wurzelverzeichnis kann weitere Verzeichnisse enthalten.
	Ein Dateisystem wird als Wurzeldateisystem festgelegt, und
	jedes weitere Dateisystem wird unter dem Wurzeldateisystem
	<firstterm>eingehangen</firstterm>.  Daher scheint jedes
	Verzeichnis, unabhängig von der Anzahl der Platten, auf der
	selben Platte zu liegen.</para>

      <para>Betrachten wir die drei Dateisysteme <literal>A</literal>,
	<literal>B</literal> und <literal>C</literal>.  Jedes
	Dateisystem besitzt ein eigenes Wurzelverzeichnis, das
	zwei andere Verzeichnisse enthält:
	<filename>A1</filename>, <filename>A2</filename>,
	<filename>B1</filename>, <filename>B2</filename>,
	<filename>C1</filename> und <filename>C2</filename>.</para>

      <para>Das Wurzeldateisystem soll <literal>A</literal> sein.
	&man.ls.1; zeigt darin die beiden Verzeichnisse
	<filename>A1</filename> und <filename>A2</filename> an.
	Der Verzeichnisbaum sieht wie folgt aus:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir1"/>
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2</literallayout>
	</textobject>
      </mediaobject>

      <para>Ein Dateisystem wird in einem Verzeichnis eines anderen
	Dateisystems eingehangen.  Wir hängen nun das Dateisystem
	<literal>B</literal> in das Verzeichnis
	<filename>A1</filename> ein.  Das Wurzelverzeichnis von
	<literal>B</literal> ersetzt nun das Verzeichnis
	<filename>A1</filename> und die Verzeichnisse des Dateisystems
	<literal>B</literal> werden sichtbar:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir2"/>
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |     |
 |     +--- B1
 |     |
 |     `--- B2
 |
 `--- A2</literallayout>
	</textobject>
      </mediaobject>

      <para>Jede Datei in den Verzeichnissen
	<filename>B1</filename> oder <filename>B2</filename> kann
	über den Pfad <filename>/A1/B1</filename> oder
	<filename>/A1/B2</filename> erreicht werden.  Dateien aus dem
	Verzeichnis <filename>/A1</filename> sind jetzt verborgen.
	Wenn das Dateisystem <literal>B</literal> wieder
	<firstterm>abgehangen</firstterm> wird
	(<foreignphrase>umount</foreignphrase>), erscheinen die
	verborgenen Dateien wieder.</para>

      <para>Wenn das Dateisystem <literal>B</literal> unter dem
	Verzeichnis <filename>A2</filename>
	eingehangen würde, sähe der Verzeichnisbaum
	so aus:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir3"/>
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2
       |
       +--- B1
       |
       `--- B2</literallayout>
	</textobject>
      </mediaobject>

      <para>Die Dateien des Dateisystems <literal>B</literal> wären
	unter den Pfaden <filename>/A2/B1</filename> und
	<filename>/A2/B2</filename> erreichbar.</para>

      <para>Dateisysteme können übereinander eingehangen
	werden.  Der folgende Baum entsteht, wenn im letzten
	Beispiel das Dateisystem <literal>C</literal> in das Verzeichnis
	<filename>B1</filename> des Dateisystems
	<literal>B</literal> eingehangen wird:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir4"/>
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2
       |
       +--- B1
       |     |
       |     +--- C1
       |     |
       |     `--- C2
       |
       `--- B2</literallayout>
	</textobject>
      </mediaobject>

      <para><literal>C</literal> könnte auch im Verzeichnis
	<filename>A1</filename> eingehangen
	werden:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir5"/>
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |     |
 |     +--- C1
 |     |
 |     `--- C2
 |
 `--- A2
       |
       +--- B1
       |
       `--- B2</literallayout>
	</textobject>
      </mediaobject>

      <para>Sie können sogar mit nur einem großen
	Dateisystem auskommen.  Dies hat mehrere Nachteile
	und einen Vorteil.</para>

      <itemizedlist>
	<title>Vorteile mehrerer Dateisysteme</title>

	<listitem>
	  <para>Die Dateisysteme können mit unterschiedlichen
	    Optionen (<foreignphrase>mount options</foreignphrase>)
	    eingehangen werden.  Beispielsweise kann das
	    Wurzeldateisystem schreibgeschützt eingehangen werden,
	    sodass es für Benutzer nicht möglich ist, versehentlich
	    kritische Dateien zu editieren oder zu löschen.
	    Von Benutzern beschreibbare Dateisysteme
	    wie <filename>/home</filename>
	    können mit der Option <firstterm>nosuid</firstterm>
	    eingehangen werden, wenn sie von anderen Dateisystemen
	    getrennt sind.  Die <firstterm>SUID</firstterm>- und
	    <firstterm>GUID</firstterm>-Bits verlieren auf solchen
	    Dateisystemen ihre Wirkung und die Sicherheit des
	    Systems kann dadurch erhöht werden.</para>
	</listitem>

	<listitem>
	  <para>Die Lage von Dateien im Dateisystem wird, abhängig
	    vom Gebrauch des Dateisystems, automatisch von &os;
	    optimiert.  Ein Dateisystem mit vielen kleinen Dateien,
	    die häufig geschrieben werden, wird anders behandelt
	    als ein Dateisystem mit wenigen großen Dateien.
	    Mit nur einem Dateisystem ist diese Optimierung
	    unmöglich.</para>
	</listitem>

	<listitem>
	  <para>In der Regel übersteht ein &os;-Dateisystem auch
	    einen Stromausfall.  Allerdings kann ein Stromausfall zu
	    einem kritischen Zeitpunkt das Dateisystem beschädigen.
	    Wenn die Daten über mehrere Dateisysteme verteilt
	    sind, lässt sich das System mit hoher
	    Wahrscheinlichkeit noch starten.  Dies erleichtert
	    das Zurückspielen von Datensicherungen.</para>
	</listitem>
      </itemizedlist>

      <itemizedlist>
	<title>Vorteil eines einzelnen Dateisystems</title>

	<listitem>
	  <para>Dateisysteme haben eine festgelegte Größe.
	    Es kann passieren, dass Sie eine Partition
	    vergrößern müssen.  Dies ist nicht leicht:
	    Sie müssen die Daten sichern, das Dateisystem
	    vergrößert anlegen und die gesicherten
	    Daten zurückspielen.</para>

	  <important>
	    <para>&os; kennt den Befehl &man.growfs.8;, mit dem man
	      Dateisysteme im laufenden Betrieb
	      vergrößern kann.</para>
	  </important>
	</listitem>
      </itemizedlist>

      <para>Dateisysteme befinden sich in Partitionen (damit sind
	nicht die normalen &ms-dos;-Partitionen gemeint).  Jede Partition
	wird mit einem Buchstaben von <literal>a</literal> bis
	<literal>h</literal> bezeichnet und kann nur ein Dateisystem
	enthalten.  Dateisysteme können daher über ihren
	Mount-Point, den Punkt an dem sie eingehangen sind, oder
	den Buchstaben der Partition, in der sie liegen, identifiziert
	werden.</para>

      <para>&os; benutzt einen Teil der Platte für den
	<firstterm>Swap-Bereich</firstterm>, um
	<firstterm>virtuellen Speicher</firstterm> zur Verfügung zu
	stellen.  Dadurch kann der Rechner Anwendungen mehr Speicher
	zur Verfügung stellen als tatsächlich eingebaut
	ist.  Wenn der Speicher knapp wird, kann &os; nicht benutzte
	Daten in den Swap-Bereich auslagern.  Die ausgelagerten
	Daten können später wieder in den Speicher
	geholt werden (dafür werden dann andere Daten
	ausgelagert).</para>

      <para>Für einige Partitionen gelten besondere
        Konventionen:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <colspec colwidth="1*"/>
	  <colspec colwidth="5*"/>

	  <thead>
	    <row>
	      <entry>Partition</entry>

	      <entry>Konvention</entry>
	    </row>
	  </thead>

	  <tbody valign="top">
	    <row>
	      <entry><literal>a</literal></entry>

	      <entry>Enthält normalerweise
		das Wurzeldateisystem.</entry>
	    </row>

	    <row>
	      <entry><literal>b</literal></entry>

	      <entry>Enthält normalerweise
		den Swap-Bereich.</entry>
	    </row>

	    <row>
	      <entry><literal>c</literal></entry>

	      <entry>Ist normalerweise genauso groß wie
		die Slice in der die Partition liegt.  Werkzeuge,
		die auf der kompletten Slice arbeiten, wie ein
		Bad-Block-Scanner, können so die
		<literal>c</literal>-Partition benutzen.
		Für gewöhnlich wird in dieser Partition kein
		Dateisystem angelegt.</entry>
	    </row>

	    <row>
	      <entry><literal>d</literal></entry>

	      <entry>Früher hatte die <literal>d</literal>-Partition
		eine besondere Bedeutung.  Heute ist dies nicht mehr der
		Fall und die Partition <literal>d</literal> kann wie
		jede andere Partition auch verwendet werden.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>In &os; werden Festplatten in Slices, welche in &windows;
	als Partitionen bekannt sind, aufgeteilt und von
	1 bis 4 durchnummeriert.  Diese werden dann in Partitionen
	unterteilt, welche wiederum Dateisysteme enthalten und mit
	Buchstaben benannt werden.</para>

      <indexterm><primary>Slices</primary></indexterm>
      <indexterm><primary>Partitionen</primary></indexterm>
      <indexterm><primary>dangerously dedicated</primary></indexterm>

      <para>Die Slice-Nummern werden mit vorgestelltem
	<literal>s</literal> hinter den Gerätenamen gestellt:
	<quote>da0<emphasis>s1</emphasis></quote>
	ist die erste Slice auf dem ersten SCSI-Laufwerk.  Auf einer
	Festplatte gibt es höchstens vier Slices.  In einer
	Slice des passenden Typs kann es weitere logische Slices
	geben.  Diese erweiterten Slices werden ab fünf durchnummeriert:
	<quote>ad0<emphasis>s5</emphasis></quote> ist
	die erste erweiterte Slice auf einer IDE-Platte.  Diese
	Geräte werden von Dateisystemen benutzt, die sich in
	einer kompletten Slice befinden müssen.</para>

      <para>Slices, <quote>dangerously dedicated</quote>-Festplatten
	und andere Platten enthalten Partitionen, die mit Buchstaben
	von <literal>a</literal> bis <literal>h</literal> bezeichnet
	werden.  Der Buchstabe wird an den Gerätenamen
	gehangen: <quote>da0<emphasis>a</emphasis></quote>
	ist die <literal>a</literal>-Partition des ersten
	<literal>da</literal>-Laufwerks.  Dieses Laufwerk ist
	<quote>dangerously dedicated</quote>.
	<quote>ad1s3<emphasis>e</emphasis></quote> ist
	die fünfte Partition in der dritten Slice der zweiten
	IDE-Platte.</para>

      <para>Schließlich wird noch jede Festplatte des Systems
	eindeutig bezeichnet.  Der Name einer Festplatte beginnt mit
	einem Code, der den Typ der Platte bezeichnet.  Es folgt eine
	Nummer, die angibt, um welche Festplatte es sich handelt.
	Anders als bei Slices werden Festplatten von Null beginnend
	durchnummeriert.  Gängige Festplatten-Namen sind in
	<xref linkend="basics-dev-codes"/> aufgeführt.</para>

      <para>Wenn Sie eine Partition angeben, beinhaltet das den
	Plattennamen, <literal>s</literal>, die Slice-Nummer und den
	Buchstaben der Partition.
	Einige Beispiele finden Sie in
	<xref linkend="basics-disk-slice-part"/>.</para>

      <para>Der Aufbau einer Festplatte wird in
	<xref linkend="basics-concept-disk-model"/> dargestellt.</para>

      <para>Bei der Installation von &os; legen Sie Slices auf der
	Festplatte an, erstellen Partitionen für &os; innerhalb der
	Slice, erstellen ein Dateisystem oder Auslagerungsbereiche und
	entscheiden, welche Dateisysteme wo eingehangen werden.</para>

      <table frame="none" pgwide="1" xml:id="basics-dev-codes">
	<title>Laufwerk-Codes</title>

	<tgroup cols="2">
          <colspec colwidth="1*"/>
          <colspec colwidth="5*"/>

	  <thead>
	    <row>
	      <entry>Code</entry>

	      <entry>Bedeutung</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><filename>ad</filename></entry>

	      <entry>ATAPI (IDE) Festplatte</entry>
	    </row>

	    <row>
	      <entry><filename>da</filename></entry>

	      <entry>SCSI-Festplatte</entry>
	    </row>

	    <row>
	      <entry><filename>acd</filename></entry>

	      <entry>ATAPI (IDE) CD-ROM</entry>
	    </row>

	    <row>
	      <entry><filename>cd</filename></entry>

	      <entry>SCSI-CD-ROM</entry>
	    </row>

	    <row>
	      <entry><filename>fd</filename></entry>

	      <entry>Disketten-Laufwerk</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <example xml:id="basics-disk-slice-part">
	<title>Namen von Platten, Slices und Partitionen</title>

	<informaltable frame="none" pgwide="1">
	  <tgroup cols="2">
            <colspec colwidth="1*"/>
            <colspec colwidth="5*"/>

	    <thead>
	      <row>
		<entry>Name</entry>

		<entry>Bedeutung</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><filename>ad0s1a</filename></entry>

		<entry>Die erste Partition (<literal>a</literal>)
		  in der ersten Slice (<literal>s1</literal>) der
		  ersten IDE-Festplatte (<literal>ad0</literal>).</entry>
	      </row>

	      <row>
		<entry><filename>da1s2e</filename></entry>

		<entry>Die fünfte Partition (<literal>e</literal>)
		  der zweiten Slice (<literal>s2</literal>) auf
		  der zweiten SCSI-Festplatte
		  (<literal>da1</literal>).</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </example>

      <example xml:id="basics-concept-disk-model">
	<title>Aufteilung einer Festplatte</title>

	<para>Das folgende Diagramm zeigt die Sicht von &os; auf die
	  erste IDE-Festplatte des Systems.  Die Platte soll
	  4&nbsp;GB groß sein und zwei Slices (&ms-dos;-Partitionen)
	  mit je 2&nbsp;GB besitzen.  Die erste Slice enthält
	  ein &ms-dos;-Laufwerk (<filename>C:</filename>), die zweite
	  Slice wird von &os; benutzt.  Die &os;-Installation in
	  diesem Beispiel verwendet drei Datenpartitionen und einen
	  Auslagerungsbereich.</para>

	<para>Jede der drei Partitionen enthält ein Dateisystem.
	  Das Wurzeldateisystem ist die <literal>a</literal>-Partition.
	  In der <literal>e</literal>-Partition befindet sich
	  der <filename>/var</filename>-Verzeichnisbaum
	  und in der <literal>f</literal>-Partition befindet sich
	  der Verzeichnisbaum unterhalb von
	  <filename>/usr</filename>.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="install/disk-layout"/>
          </imageobject>

          <textobject>
	    <literallayout class="monospaced">.-----------------.  --.
|                 |    |
|  DOS / Windows  |    |
:                 :     &gt;  First slice, ad0s1
:                 :    |
|                 |    |
:=================:  ==:                               --.
|                 |    |  Partition a, mounted as /      |
|                 |     &gt; referred to as ad0s2a          |
|                 |    |                                 |
:-----------------:  ==:                                 |
|                 |    |  Partition b, used as swap      |
|                 |     &gt; referred to as ad0s2b          |
|                 |    |                                 |
:-----------------:  ==:                                 |  Partition c, no
|                 |    |  Partition e, used as /var       &gt; file system, all
|                 |     &gt; referred to as ad0s2e          |  of FreeBSD slice,
|                 |    |                                 |  ad0s2c
:-----------------:  ==:                                 |
|                 |    |                                 |
:                 :    |  Partition f, used as /usr      |
:                 :     &gt; referred to as ad0s2f          |
:                 :    |                                 |
|                 |    |                                 |
|                 |  --'                                 |
`-----------------'                                    --'</literallayout>
          </textobject>
        </mediaobject>
      </example>
  </sect1>

  <sect1 xml:id="mount-unmount">
    <title>Anhängen und Abhängen von Dateisystemen</title>

    <para>Ein Dateisystem wird am besten als ein Baum mit der
      Wurzel <filename>/</filename> veranschaulicht.
      <filename>/dev</filename>, <filename>/usr</filename>, und
      die anderen Verzeichnisse im Rootverzeichnis sind Zweige,
      die wiederum eigene Zweige wie <filename>/usr/local</filename>
      haben können.</para>

    <indexterm><primary>Root-Dateisystem</primary></indexterm>
    <para>Es gibt verschiedene Gründe, bestimmte dieser Verzeichnisse
      auf eigenen Dateisystemen anzulegen.  <filename>/var</filename>
      enthält <filename>log/</filename>, <filename>spool/</filename>
      sowie verschiedene andere temporäre
      Dateien und kann sich daher schnell füllen.  Es empfiehlt sich,
      <filename>/var</filename> von <filename>/</filename> zu trennen,
      da es schlecht ist, wenn das Root-Dateisystem voll
      läuft.</para>

    <para>Ein weiterer Grund bestimmte Verzeichnisbäume auf
      andere Dateisysteme zu legen, ist gegeben, wenn sich die
      Verzeichnisbäume auf gesonderten physikalischen oder
      virtuellen Platten, wie
      <link linkend="network-nfs">Network File System</link>
      oder CD-ROM-Laufwerken, befinden.</para>

    <sect2 xml:id="disks-fstab">
      <title>Die <filename>fstab</filename> Datei</title>

      <indexterm>
	 <primary>Dateisysteme</primary>
	 <secondary>fstab</secondary>
      </indexterm>
      <para>Während des Boot-Prozesses (<xref linkend="boot"/>)
	werden in <filename>/etc/fstab</filename> aufgeführte
	Verzeichnisse, sofern sie nicht mit der Option
	<option>noauto</option> versehen sind, automatisch angehangen.
	Diese Datei enthält Einträge in folgendem Format:</para>

      <programlisting><replaceable>device</replaceable>	<replaceable>/mount-point</replaceable>	<replaceable>fstype</replaceable>	<replaceable>options</replaceable>	<replaceable>dumpfreq</replaceable>	<replaceable>passno</replaceable></programlisting>

      <variablelist>
	<varlistentry>
	  <term><literal>device</literal></term>

	  <listitem>
            <para>Ein existierender Gerätename
	      wie in <xref linkend="disks-naming"/> beschrieben.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>mount-point</literal></term>

	  <listitem>
            <para>Ein existierendes Verzeichnis, auf dem
	      das Dateisystem gemountet wird.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>fstype</literal></term>

	  <listitem>
            <para>Der Typ des Dateisystems,
	      der an &man.mount.8; weitergegeben wird.  &os;s
	      Standarddateisystem ist <literal>ufs</literal>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>options</literal></term>

	  <listitem>
	    <para>Entweder <option>rw</option>
	      für beschreibbare Dateisysteme oder <option>ro</option>
	      für schreibgeschützte Dateisysteme, gefolgt von
	      weiteren benötigten Optionen.  Eine häufig verwendete
	      Option ist <option>noauto</option> für Dateisysteme,
	      die während der normalen Bootsequenz nicht angehangen
	      werden sollen.  Weitere Optionen finden sich
	      in &man.mount.8;.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>dumpfreq</literal></term>

	  <listitem><para>Wird von &man.dump.8; benutzt, um bestimmen
	      zu können, welche Dateisysteme gesichert werden müssen.
	      Fehlt der Wert, wird <literal>0</literal>
	      angenommen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>passno</literal></term>

	  <listitem><para>Bestimmt die Reihenfolge, in der die Dateisysteme
	      überprüft werden sollen.  Für Dateisysteme,
	      die übersprungen werden sollen, ist
	      <literal>passno</literal> auf <literal>0</literal> zu setzen.  Für das
	      Root-Dateisystem, das vor allen anderen überprüft
	      werden muss, sollte der Wert von
	      <literal>passno</literal> <literal>1</literal> betragen.  Allen anderen
	      Dateisystemen sollten Werte größer <literal>1</literal> zugewiesen
	      werden.  Wenn mehrere Dateisysteme den gleichen Wert
	      besitzen, wird &man.fsck.8; versuchen, diese parallel zu
	      überprüfen.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>Lesen Sie &man.fstab.5; für weitere Informationen über das
	Format von <filename>/etc/fstab</filename> und dessen
	Optionen.</para>
    </sect2>

    <sect2 xml:id="disks-mount">
      <title>Verwendung von &man.mount.8;</title>

      <indexterm>
	<primary>Dateisysteme</primary>
	<secondary>anhängen</secondary>
      </indexterm>

      <para>Dateisysteme werden mit &man.mount.8; eingehängt.  In der
	grundlegenden Form wird es wie folgt benutzt:</para>

      <informalexample>
	<screen>&prompt.root; <userinput>mount <replaceable>device</replaceable>
<replaceable>mountpoint</replaceable></userinput></screen>
      </informalexample>

      <para>Dieser Befehl bietet viele Optionen, die in &man.mount.8;
	beschrieben werden.  Die am häufigsten verwendeten Optionen
	sind:</para>

      <variablelist>
	<title>Optionen von <command>mount</command></title>

	<varlistentry>
	  <term><option>-a</option></term>

	  <listitem>
            <para>Hängt alle Dateisysteme aus
	      <filename>/etc/fstab</filename> an.  Davon ausgenommen
	      sind Dateisysteme, die mit <quote>noauto</quote> markiert
	      sind, die mit der Option <option>-t</option> ausgeschlossen
	      wurden und Dateisysteme, die schon angehangen sind.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-d</option></term>

	  <listitem>
            <para>Führt alles bis auf den
	      <function>mount</function>-Systemaufruf aus.
	      Nützlich ist diese Option in Verbindung
	      mit <option>-v</option>.  Damit wird angezeigt, was
	      &man.mount.8; tatsächlich versuchen
	      würde, um das Dateisystem anzuhängen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-f</option></term>

	  <listitem>
	    <para>Erzwingt das Anhängen eines unsauberen Dateisystems
	      (riskant) oder die Rücknahme des Schreibzugriffs, wenn
	      der Status des Dateisystems von beschreibbar auf
	      schreibgeschützt geändert wird.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-r</option></term>

	  <listitem>
	    <para>Hängt das Dateisystem schreibgeschützt ein.  Dies
	      kann auch durch Angabe von <option>-o ro</option>
	      erreicht werden.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-t</option>
	    <replaceable>fstype</replaceable></term>

	  <listitem>
            <para>Hängt das Dateisystem mit dem angegebenen Typ an,
	      oder hängt nur Dateisysteme mit dem angegebenen Typ
	      an, wenn <option>-a</option> angegeben wurde.
	      <quote>ufs</quote> ist das Standarddateisystem.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-u</option></term>

	  <listitem>
	    <para>Aktualisiert die Mountoptionen des Dateisystems.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-v</option></term>

	  <listitem>
	    <para>Geschwätzig sein.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-w</option></term>

	  <listitem>
	    <para>Hängt das Dateisystem beschreibbar an.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>Die folgenden Optionen können durch eine Kommata
	separierte Liste an <option>-o</option> übergeben
	werden:</para>

      <variablelist>
	<varlistentry>
	  <term>nosuid</term>

	  <listitem>
	    <para>SetUID und SetGID Bits werden auf dem Dateisystem
	      nicht beachtet.  Dies ist eine nützliche
	      Sicherheitsfunktion.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 xml:id="disks-umount">
      <title>Verwendung von &man.umount.8;</title>

      <indexterm>
	<primary>Dateisysteme</primary>
	<secondary>abhängen</secondary>
      </indexterm>

      <para>&man.umount.8; hängt ein Dateisysstem ab. Dieser Befehl
	akzeptiert als Parameter entweder
	einen Mountpoint, einen Gerätenamen, <option>-a</option>
	oder <option>-A</option>.</para>

      <para>Jede Form akzeptiert <option>-f</option>, um das
	Abhängen zu erzwingen, und <option>-v</option>, um
	etwas geschwätziger zu sein.  Seien Sie bitte vorsichtig mit
	<option>-f</option>, da der Computer abstürzen kann oder es
	können Daten auf dem Dateisystem beschädigt werden.</para>

      <para>Um alle Dateisysteme abzuhängen, oder nur diejenigen, die
	mit <option>-t</option> gelistet werden, wird
	<option>-a</option> oder <option>-A</option> benutzt.
	Beachten Sie, dass <option>-a</option> das Root-Dateisystem
	nicht aushängt.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="basics-processes">
    <title>Prozesse</title>

    <para>&os; ist ein Multitasking-Betriebssystem.  Jedes
      Programm, das zu irgendeiner Zeit läuft wird als
      <firstterm>Prozess</firstterm> bezeichnet.  Jedes laufende
      Kommando startet mindestens einen neuen Prozess.  Dazu gibt
      es eine Reihe von Systemprozessen, die von &os; ausgeführt
      werden.</para>

    <para>Jeder Prozess wird durch eine eindeutige Nummer identifiziert,
      die <firstterm>Prozess-ID</firstterm>
      (<firstterm>PID</firstterm>) genannt wird.  Prozesse haben ebenso
      wie Dateien einen Besitzer und eine Gruppe, die festlegen, welche
      Dateien und Geräte der Prozess benutzen kann.  Die meisten
      Prozesse haben auch einen Elternprozess, der sie gestartet hat.
      Beispielsweise ist die Shell ein Prozess.  Jedes in Shell
      gestartete Kommando ist dann ein neuer Prozess, der die Shell
      als Elternprozess besitzt.  Die Ausnahme hiervon ist ein
      spezieller Prozess namens &man.init.8;, der beim booten immer
      als erstes gestartet wird und der immer die
      <acronym>PID</acronym> 1 hat.</para>

    <para>Um die Prozesse auf dem System zu sehen, benutzen Sie
      &man.ps.1; und &man.top.1;.  Eine statische Liste der laufenden
      Prozesse, deren <acronym>PID</acronym>s, Speicherverbrauch und
      die Kommandozeile, mit der sie gestartet wurden, erhalten Sie
      mit &man.ps.1;.  Um alle laufenden Prozesse in einer Anzeige zu
      sehen, die alle paar Sekunden aktualisiert wird, so dass Sie
      interaktiv sehen können was der Computer macht, benutzen Sie
      &man.top.1;.</para>

    <para>In der Voreinstellung zeigt &man.ps.1; nur die laufenden
      Prozesse, die dem Benutzer gehören.  Zum Beispiel:</para>

    <screen>&prompt.user; <userinput>ps</userinput>
  PID  TT  STAT      TIME COMMAND
  298  p0  Ss     0:01.10 tcsh
 7078  p0  S      2:40.88 xemacs mdoc.xsl (xemacs-21.1.14)
37393  p0  I      0:03.11 xemacs freebsd.dsl (xemacs-21.1.14)
72210  p0  R+     0:00.00 ps
  390  p1  Is     0:01.14 tcsh
 7059  p2  Is+    1:36.18 /usr/local/bin/mutt -y
 6688  p3  IWs    0:00.00 tcsh
10735  p4  IWs    0:00.00 tcsh
20256  p5  IWs    0:00.00 tcsh
  262  v0  IWs    0:00.00 -tcsh (tcsh)
  270  v0  IW+    0:00.00 /bin/sh /usr/X11R6/bin/startx -- -bpp 16
  280  v0  IW+    0:00.00 xinit /home/nik/.xinitrc -- -bpp 16
  284  v0  IW     0:00.00 /bin/sh /home/nik/.xinitrc
  285  v0  S      0:38.45 /usr/X11R6/bin/sawfish</screen>

    <para>Die Ausgabe von &man.ps.1; ist in einer Anzahl von Spalten
      organisiert.  Die <literal>PID</literal> Spalte zeigt die
      Prozess-ID.  <acronym>PID</acronym>s werden von 1 beginnend bis
      99999 zugewiesen und fangen wieder von vorne an.  Ist eine
      <acronym>PID</acronym> bereits vergeben, wird diese allerdings
      nicht erneut vergeben.  Die Spalte <literal>TT</literal> zeigt
      den Terminal, auf dem das Programm läuft.
      <literal>STAT</literal> zeigt den Status des Programms und
      <literal>TIME</literal> gibt die Zeit an, die das Programm auf
      der CPU gelaufen ist.  Dies ist nicht unbedingt die Zeit, die
      seit dem Start des Programms vergangen ist, da die meisten
      Programme hauptsächlich auf bestimmte Dinge warten, bevor sie
      wirklich CPU-Zeit verbrauchen.  Unter der Spalte
      <literal>COMMAND</literal> findet sich schließlich die
      Kommandozeile, mit der das Programm gestartet wurde.</para>

    <para>&man.ps.1; besitzt viele Optionen, um die angezeigten Informationen
      zu beeinflussen.  Eine nützliche Kombination ist
      <literal>auxww</literal>.  <option>a</option> zeigt Information
      über alle laufenden Prozesse aller Benutzer. Der Name des
      Besitzers des Prozesses, sowie Informationen
      über den Speicherverbrauch werden mit <option>u</option>
      angezeigt.  <option>x</option> zeigt auch Dämonen-Prozesse an,
      und <option>ww</option> veranlasst &man.ps.1; die komplette
      Kommandozeile für jeden Befehl anzuzeigen, anstatt sie
      abzuschneiden, wenn sie zu lang für die Bildschirmausgabe
      wird.</para>

    <para>Die Ausgabe von &man.top.1; sieht ähnlich aus:</para>

    <screen>&prompt.user; <userinput>top</userinput>
last pid: 72257;  load averages:  0.13,  0.09,  0.03    up 0+13:38:33  22:39:10
47 processes:  1 running, 46 sleeping
CPU states: 12.6% user,  0.0% nice,  7.8% system,  0.0% interrupt, 79.7% idle
Mem: 36M Active, 5256K Inact, 13M Wired, 6312K Cache, 15M Buf, 408K Free
Swap: 256M Total, 38M Used, 217M Free, 15% Inuse

  PID USERNAME PRI NICE  SIZE    RES STATE    TIME   WCPU    CPU COMMAND
72257 nik       28   0  1960K  1044K RUN      0:00 14.86%  1.42% top
 7078 nik        2   0 15280K 10960K select   2:54  0.88%  0.88% xemacs-21.1.14
  281 nik        2   0 18636K  7112K select   5:36  0.73%  0.73% XF86_SVGA
  296 nik        2   0  3240K  1644K select   0:12  0.05%  0.05% xterm
  175 root       2   0   924K   252K select   1:41  0.00%  0.00% syslogd
 7059 nik        2   0  7260K  4644K poll     1:38  0.00%  0.00% mutt
...</screen>

    <para>Die Ausgabe ist in zwei Abschnitte geteilt.  In den ersten
      fünf Kopfzeilen finden sich die zuletzt zugeteilte
      <acronym>PID</acronym>, die Systemauslastung
      (engl. <foreignphrase>load average</foreignphrase>), die
      Systemlaufzeit (die Zeit seit dem letzten Reboot) und die
      momentane Zeit.  Die weiteren Zahlen im Kopf beschreiben wie
      viele Prozesse momentan laufen (im Beispiel 47), wie viel
      Speicher und Swap verbraucht wurde und wie viel Zeit das System
      in den verschiedenen CPU-Modi verbringt.</para>

    <para>Darunter befinden sich einige Spalten mit ähnlichen
      Informationen wie in der Ausgabe von &man.ps.1;,
      beispielsweise die <acronym>PID</acronym>, den Besitzer, die
      verbrauchte CPU-Zeit und das Kommando, das den Prozess gestartet
      hat.  &man.top.1; zeigt in zwei Spalten den Speicherverbrauch
      des Prozesses an.  Die erste Spalte gibt
      den gesamten Speicherverbrauch des Prozesses an, in der zweiten
      Spalte wird der aktuelle Verbrauch angegeben.
      <application>mutt</application> hat im gezeigten Beispiel
      insgesamt 8&nbsp;MB Speicher verbraucht.  Momentan benutzt
      es allerdings nur 5&nbsp;MB.</para>

    <para>Die Anzeige wird von &man.top.1; automatisch alle zwei
      Sekunden aktualisiert.  Ein anderer Intervall kann mit
      <option>-s</option> spezifiziert werden.</para>
  </sect1>

  <sect1 xml:id="basics-daemons">
    <title>Dämonen, Signale und Stoppen von Prozessen</title>

    <para>Wenn Sie einen Editor benutzen, können Sie ihn leicht
      bedienen und Dateien laden, weil der Editor dafür Vorsorge
      getroffen hat und auf einem <firstterm>Terminal</firstterm>
      läuft.  Manche Programme erwarten keine Eingaben von einem
      Benutzer und lösen sich bei erster Gelegenheit von ihrem
      Terminal.  Ein Webserver zum Beispiel antwortet auf
      Web-Anfragen und nicht auf Benutzereingaben.  Mail-Server sind
      ein weiteres Beispiel für diesen Typ von Anwendungen.</para>

    <para>Diese Programme sind als <firstterm>Dämonen</firstterm>
      bekannt.  Der Begriff Dämon stammt aus der griechischen
      Mythologie und bezeichnet ein Wesen, das weder gut noch böse ist
      und welches unsichtbar nützliche Aufgaben verrichtet.  Deshalb
      ist das BSD Maskottchen dieser fröhlich aussehende Dämon mit
      Turnschuhen und Dreizack.</para>

    <para>Programme, die als Dämon laufen, werden entsprechend einer
      Konvention mit einem <quote>d</quote> am Ende benannt.
      <application>BIND</application> steht beispielsweise für
      Berkeley Internet Name Domain, das tatsächlich laufende Programm
      heißt aber &man.named.8;.  Der <application>Apache</application>
      Webserver wird <command>httpd</command> genannt und der
      Druckerspool-Dämon heißt &man.lpd.8;.  Dies ist allerdings nur
      eine Konvention. Der Dämon der Anwendung
      <application>Sendmail</application> heißt beispielsweise
      &man.sendmail.8; und nicht <literal>maild</literal>.</para>

    <para>Eine Möglichkeit mit einem Dämon oder einem laufenden
      Prozess zu kommunizieren, ist über das Versenden von
      <firstterm>Signalen</firstterm> mittels &man.kill.1;.  Es gibt
      eine Reihe von verschiedenen Signalen.  Manche haben eine feste
      Bedeutung, während andere in der Dokumentation der Anwendung
      beschrieben sind.  Ein Benutzer kann ein Signal nur an einen
      Prozess senden, welcher ihm gehört.  Wird versucht ein Signal
      an einen Prozess eines anderen Benutzers zu senden, resultiert
      dies in einem Zugriffsfehler mangels fehlender Berechtigungen.
      Die Ausnahme ist der
      <systemitem class="username">root</systemitem>-Benutzer, welcher
      jedem Prozess Signale senden kann.</para>

    <para>&os; kann auch ein Signal an einen Prozess senden.  Wenn
      eine Anwendung schlecht geschrieben ist und auf Speicher
      zugreift, auf den sie nicht zugreifen soll, so sendet &os; dem
      Prozess das <firstterm>Segmentation Violation</firstterm> Signal
      (<literal>SIGSEGV</literal>).  Wenn eine Anwendung den &man.alarm.3;
      Systemaufruf benutzt hat, um nach einiger Zeit benachrichtigt zu
      werden, bekommt sie das Alarm Signal (<literal>SIGALRM</literal>)
      gesendet.</para>

    <para>Zwei Signale können benutzt werden, um einen Prozess zu stoppen:
      <literal>SIGTERM</literal> und <literal>SIGKILL</literal>.
      <literal>SIGTERM</literal> fordert den Prozess höflich zum
      Beenden auf.  Der Prozess kann das Signal abfangen und hat dann
      Gelegenheit Logdateien  zu schließen und die Aktion, die er
      durchführte, abzuschließen.  In manchen Situationen kann der
      Prozess <literal>SIGTERM</literal> ignorieren, wenn er eine
      Aktion durchführt, die nicht unterbrochen werden darf.</para>

    <para><literal>SIGKILL</literal> kann von keinem Prozess ignoriert
      werden.  Das Signal lässt sich mit <quote>Mich interessiert
      nicht, was du gerade machst, hör sofort auf damit!</quote>
      umschreiben.  Wird einem Prozess <literal>SIGKILL</literal>
      geschickt, dann wird &os; diesen sofort beenden<footnote>
	<para>Es gibt Fälle, in denen ein Prozess nicht unterbrochen
	  werden kann.  Wenn ein Prozess zum Beispiel eine Datei von
	  einem anderen Rechner auf dem Netzwerk liest und dieser
	  Rechner nicht erreichbar ist, dann ist der Prozess nicht zu
	  unterbrechen.  Wenn der Prozess den Lesezugriff nach einem
	  Timeout von typischerweise zwei Minuten aufgibt, dann wird
	  er beendet.</para>
      </footnote>.</para>

    <para>Andere häufig verwendete Signale sind
      <literal>SIGHUP</literal>, <literal>SIGUSR1</literal> und
      <literal>SIGUSR2</literal>.  Diese Signale sind für allgemeine
      Zwecke vorgesehen und verschiedene Anwendungen werden
      unterschiedlich auf diese Signale reagieren.</para>

    <para>Ändern Sie beispielsweise die Konfiguration eines
      Webservers, so muss dieser angewiesen werden, seine
      Konfiguration neu zu lesen.  Ein Neustart von
      <command>httpd</command> würde dazu führen, dass der Server für
      kurze Zeit nicht erreichbar ist.  Senden Sie dem Dämon
      stattdessen das <literal>SIGHUP</literal>-Signal.  Es sei
      erwähnt, dass verschiedene Dämonen sich anders verhalten.  Lesen
      Sie bitte die Dokumentation des entsprechenden Dämonen um zu
      überprüfen, ob der Dämon bei einem <literal>SIGHUP</literal> die
      gewünschten Ergebnisse erzielt.</para>

    <procedure>
      <title>Verschicken von Signalen</title>

      <para>Das folgende Beispiel zeigt, wie Sie &man.inetd.8; ein
	Signal schicken.  Die Konfigurationsdatei von
	&man.inetd.8; ist <filename>/etc/inetd.conf</filename>.
	Diese Konfigurationsdatei liest &man.inetd.8; ein,
	wenn er <literal>SIGHUP</literal> empfängt.</para>

      <step>
	<para>Suchen Sie mit &man.pgrep.1; die <acronym>PID</acronym>
	  des Prozesses, dem Sie ein Signal schicken wollen.  In
	  diesem Beispiel ist die <acronym>PID</acronym> von
	  &man.inetd.8; 198:</para>

	<screen>&prompt.user; <userinput>pgrep -l inetd</userinput>
198 inetd -wW</screen>

      </step>

      <step>
	<para>Benutzen Sie &man.kill.1;, um ein Signal zu senden.  Da
	  &man.inetd.8; dem Benutzer <systemitem
	    class="username">root</systemitem> gehört, müssen
	  Sie zuerst mit &man.su.1;
	  <systemitem class="username">root</systemitem>
	  werden:</para>

	<screen>&prompt.user; <userinput>su</userinput>
<prompt>Password:</prompt>
&prompt.root; <userinput>/bin/kill -s HUP 198</userinput></screen>

	<para>&man.kill.1; wird, wie andere &unix; Kommandos auch,
	  keine Ausgabe erzeugen, wenn das Kommando erfolgreich war.
	  Wird versucht, einem Prozess der nicht dem Benutzer
	  gehört, ein Signal zu senden, dann wird die Meldung
	  <errorname>kill: <replaceable>PID</replaceable>: Operation
	    not permitted</errorname> ausgegeben.  Ein Tippfehler bei
	  der Eingabe der <acronym>PID</acronym> führt dazu, dass das
	  Signal an einen falschen Prozess gesendet wird, was zu
	  negativen Ergebnissen führen kann, oder das Signal wird an
	  eine <acronym>PID</acronym> gesendet die derzeit nicht in
	  Gebrauch ist, was zu dem Fehler
	  <errorname>kill: <replaceable>PID</replaceable>: No such
	    process</errorname> führt.</para>

	<note>
	  <title>Warum sollte man <command>/bin/kill</command>
	    benutzen?</title>

	  <para>Viele Shells stellen <command>kill</command> als internes
	    Kommando zur Verfügung, das heißt die Shell sendet
	    das Signal direkt, anstatt <filename>/bin/kill</filename>
	    zu starten.  Beachten Sie, dass die unterschiedlichen
	    Shells eine andere Syntax benutzen, um die Namen der
	    Signale anzugeben.  Anstatt jede Syntax zu
	    lernen, kann es einfacher sein, <command>/bin/kill
	      <replaceable>...</replaceable></command> direkt
	    aufzurufen.</para>
	</note>
      </step>
    </procedure>

    <para>Beim Versenden von anderen Signalen, ersetzen
      Sie <literal>TERM</literal> oder <literal>KILL</literal> in der
      Kommandozeile mit dem entsprechenden Signal.</para>

    <important>
      <para>Das zufällige Beenden eines Prozesses kann gravierende
	Auswirkungen haben.  Insbesondere &man.init.8;, mit der
	<acronym>PID</acronym> 1, ist ein Spezialfall.
	<command>/bin/kill -s KILL 1</command> ist ein schneller,
	jedoch nicht empfohlener Weg, das System herunterzufahren.
	Überprüfen Sie die Argumente von &man.kill.1;
	<emphasis>immer</emphasis> zweimal <emphasis>bevor</emphasis>
	Sie <keycap>Return</keycap> drücken.</para>
    </important>
  </sect1>

  <sect1 xml:id="shells">
    <title>Shells</title>
    <indexterm><primary>Shells</primary></indexterm>
    <indexterm><primary>Kommandozeile</primary></indexterm>

    <para>&os; stellt mit der Shell eine Kommandozeilen-Schnittstelle
      zur Verfügung.  Eine Shell empfängt Befehle von einem
      Eingabekanal und führt diese aus.  Viele Shells bieten bieten
      eingebaute Funktionen, die die tägliche Arbeit erleichtern,
      beispielsweise eine Dateiverwaltung, die Vervollständigung von
      Dateinamen (Globbing), Kommandozeilen-Editor, sowie Makros und
      Umgebungsvariablen.  &os; enthält einige Shells, darunter die
      Bourne Shell (&man.sh.1;) und die verbesserte C-Shell
      (&man.tcsh.1;).  Weitere Shells, wie <command>zsh</command> oder
      <command>bash</command>, befinden sich in der
      Ports-Sammlung.</para>

    <para>Die verwendete Shell ist letztlich eine Frage des
      Geschmacks.  Ein C-Programmierer, findet vielleicht eine
      C-artige Shell wie &man.tcsh.1; angenehmer.  Ein
      &linux;-Benutzer bevorzugt vielleicht <command>bash</command>.
      Jede Shell hat ihre speziellen Eigenschaften, die mit der
      bevorzugten Arbeitsumgebung des Benutzers harmonieren kann oder
      nicht.  Deshalb stehen mehrere Shells zur Auswahl.</para>

    <para>Ein verbreitetes Merkmal in Shells ist die
      Dateinamen-Vervollständigung.  Nachdem der Benutzer einige
      Buchstaben eines Kommandos oder eines Dateinamen eingeben hat,
      vervollständigt die Shell den Rest automatisch durch
      drücken der <keycap>Tab</keycap>-Taste.  Angenommen, Sie
      haben zwei Dateien <filename>foobar</filename> und
      <filename>foo.bar</filename>.  Um <filename>foo.bar</filename>
      zu löschen,  geben Sie folgendes ein:
      <command>rm fo[Tab].[Tab]</command></para>

    <para>Die Shell sollte dann <command>rm
      foo[BEEP].bar</command> ausgeben.</para>

    <para>[BEEP] meint den Rechner-Piepser, den die Shell ausgibt um
      anzuzeigen, dass es den Dateinamen nicht vervollständigen
      konnte, da es mehrere Möglichkeiten gibt.  Beide Dateien
      <filename>foobar</filename> und <filename>foo.bar</filename>
      beginnen mit <literal>fo</literal>.  Nach der Eingabe von
      <literal>.</literal> und erneutem drücken der
      <keycap>Tab</keycap>-Taste, war die Shell in der Lage den Rest
      auszufüllen.</para>

    <indexterm><primary>Umgebungsvariablen</primary></indexterm>

    <para>Ein weiteres Merkmal der Shell ist der Gebrauch von
      Umgebungsvariablen.  Dies sind veränderbare Schlüsselpaare
      im Umgebungsraum der Shell, die jedes von der Shell aufgerufene
      Programm lesen kann.  Daher enthält der Umgebungsraum viele
      Konfigurationsdaten für Programme.  Die folgende Liste zeigt
      verbreitete Umgebungsvariablen und deren Bedeutung:</para>

    <informaltable frame="none" pgwide="1">
      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>Variable</entry>
	    <entry>Beschreibung</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry><envar>USER</envar></entry>
	    <entry>Name des angemeldeten Benutzers.</entry>
	  </row>

	  <row>
	    <entry><envar>PATH</envar></entry>
	    <entry>Liste mit Verzeichnissen (getrennt durch Doppelpunkt)
              zum Suchen nach Programmen.</entry>
	  </row>

	  <row>
	    <entry><envar>DISPLAY</envar></entry>
	    <entry>Der Name des
	      <application>Xorg</application>-Bildschirms, auf dem
	      Ausgaben erfolgen sollen.</entry>
	  </row>

	  <row>
	    <entry><envar>SHELL</envar></entry>
	    <entry>Die aktuelle Shell.</entry>
	  </row>

	  <row>
	    <entry><envar>TERM</envar></entry>
	    <entry>Name des Terminaltyps des Benutzers.  Benutzt, um die
              Fähigkeiten des Terminals zu bestimmen.</entry>
	  </row>

	  <row>
	    <entry><envar>TERMCAP</envar></entry>
	    <entry>Datenbankeintrag der Terminal Escape Codes,
              benötigt um verschieden Terminalfunktionen
              auszuführen.</entry>
	  </row>

	  <row>
	    <entry><envar>OSTYPE</envar></entry>
	    <entry>Typ des Betriebssystems.</entry>
	  </row>

	  <row>
	    <entry><envar>MACHTYPE</envar></entry>
	    <entry>Die CPU-Architektur des Systems.</entry>
	  </row>

	  <row>
	    <entry><envar>EDITOR</envar></entry>
	    <entry>Vom Benutzer bevorzugter Text-Editor.</entry>
	  </row>

	  <row>
	    <entry><envar>PAGER</envar></entry>
	    <entry>Vom Benutzer bevorzugter Text-Betrachter.</entry>
	  </row>

	  <row>
	    <entry><envar>MANPATH</envar></entry>
	    <entry>Liste mit Verzeichnissen (getrennt durch Doppelpunkt)
              zum Suchen nach Manualpages.</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <indexterm>
      <primary>Shells</primary>
      <secondary>Bourne Shell</secondary>
    </indexterm>
    <para>Das Setzen von Umgebungsvariablen unterscheidet sich
      von Shell zu Shell.  In &man.tcsh.1; und &man.csh.1; wird dazu
      <command>setenv</command> benutzt.  &man.sh.1; und
      <command>bash</command> benutzen <command>export</command> um
      Umgebungsvariablen zu setzen.  Dieses Beispiel für die
      &man.tcsh.1;-Shell setzt die Variable <envar>EDITOR</envar> auf
      <filename>/usr/local/bin/emacs</filename>:</para>

    <screen>&prompt.user; <userinput>setenv EDITOR /usr/local/bin/emacs</userinput></screen>

    <para>Der entsprechende Befehl für <command>bash</command>
      wäre:</para>

    <screen>&prompt.user; <userinput>export EDITOR="/usr/local/bin/emacs"</userinput></screen>

    <para>Um eine Umgebungsvariable zu expandieren, geben Sie in der
      Kommandozeile das Zeichen <literal>$</literal> vor dessen Namen
      ein.  Zum Beispiel gibt <command>echo $TERM</command> den
      aktuellen Wert von<envar>$TERM</envar> aus.</para>

    <para>Shells behandeln Spezialzeichen, so genannte Metazeichen,
      als besondere Darstellungen für Daten.  Das häufigste Zeichen
      ist <literal>*</literal>, das eine beliebige Anzahl Zeichen in
      einem Dateinamen repräsentiert.  Metazeichen können zur
      Vervollständigung von Dateinamen (Globbing) benutzt werden.
      Beispielsweise liefert <command>echo *</command> nahezu das
      gleiche wie &man.ls.1;, da die Shell alle Dateinamen die mit
      <literal>*</literal> übereinstimmen, an <command>echo</command>
      weitergibt.</para>

    <para>Um zu verhindern, dass die Shell ein Sonderzeichen
      interpretiert, schützt man es, indem man einen
      Backslash (<literal>\</literal>) voranstellt.  Zum Beispiel
      zeigt <command>echo $TERM</command> die Einstellung des
      Terminals an, wohingegen <command>echo \$TERM</command> einfach
      die Zeichenfolge <literal>$TERM</literal> ausgibt.</para>

    <sect2 xml:id="changing-shells">
      <title>Ändern der Shell</title>

      <para>Der einfachste Weg die Standard Shell zu ändern, ist
        <command>chsh</command> zu benutzen.
        <command>chsh</command> startet den Editor, welcher durch
	die Umgebungsvariable <envar>EDITOR</envar> gesetzt ist.
	Standardmäßig ist dies &man.vi.1;.
        Tragen Sie in die Zeile die mit <quote>Shell:</quote> beginnt,
        den absoluten Pfad der neuen Shell ein.</para>

      <para>Alternativ setzt <command>chsh -s</command> die Shell,
	ohne dabei einen Editor aufzurufen.  Um die Shell
        zum Beispiel auf <command>bash</command> zu ändern, geben Sie
	folgenden Befehl ein:</para>

      <screen>&prompt.user; <userinput>chsh -s /usr/local/bin/bash</userinput></screen>

      <note>
	<para>Die neue Shell <emphasis>muss</emphasis> in
	  <filename>/etc/shells</filename> aufgeführt sein.  Wurde die
	  Shell aus der &os; Ports-Sammlung installiert, so wie in
	  <xref linkend="ports"/> beschrieben, sollte sie automatisch
	  zu dieser Datei hinzugefügt worden sein.  Wenn der Eintrag
	  fehlt, nutzen Sie folgenden Befehl, und ersetzen Sie den
	  Pfad mit dem Pfad zur gewünschten Shell:</para>

      <screen>&prompt.root; <userinput>echo &quot;/usr/local/bin/bash&quot; &gt;&gt; /etc/shells</userinput></screen>

       <para>Danach kann &man.chsh.1; erneut aufgerufen werden.</para>
     </note>
   </sect2>
  </sect1>

  <sect1 xml:id="editors">
    <title>Text-Editoren</title>
    <indexterm><primary>Text Editoren</primary></indexterm>
    <indexterm><primary>Editoren</primary></indexterm>

    <para>Die meiste Konfiguration unter &os; wird durch
      das Editieren von Textdateien erledigt.  Deshalb ist es eine
      gute Idee, mit einem Texteditor vertraut zu werden.  &os; hat
      ein paar davon im Basissystem und sehr viel mehr in der
      Ports-Sammlung.</para>

    <indexterm>
      <primary>&man.ee.1;</primary>
    </indexterm>

    <indexterm>
      <primary>Text Editoren</primary>
      <secondary><command>ee</command></secondary>
    </indexterm>

    <para>Ein einfach zu erlernender Editor ist &man.ee.1;, was für
      <foreignphrase>easy editor</foreignphrase> steht.  Um diesen
      Editor zu starten, gibt man in der Kommandozeile <command>ee
	<replaceable>filename</replaceable></command> ein, wobei
      <replaceable>filename</replaceable> den Namen der zu
      editierenden Datei darstellt.  Einmal im Editor, finden sich
      alle Editor-Funktionen oben im Display aufgelistet.  Das
      Einschaltungszeichen <literal>^</literal> steht für die
      <keycap>Ctrl</keycap> (oder <keycap>Strg</keycap>) Taste, mit
      <literal>^e</literal> ist also die Tastenkombination
      <keycombo
	action="simul"><keycap>Ctrl</keycap><keycap>e</keycap></keycombo>
      gemeint.  Um &man.ee.1; zu verlassen, drücken Sie
      <keycap>Esc</keycap> und wählen dann im Hauptmenü <option>leave
        editor</option> aus.  Der Editor fragt nach, ob Sie speichern
      möchten, wenn die Datei verändert wurde.</para>

    <indexterm>
      <primary>&man.vi.1;</primary>
    </indexterm>
    <indexterm>
      <primary>Text Editoren</primary>
      <secondary>&man.vi.1;</secondary>
    </indexterm>
    <indexterm>
      <primary><command>emacs</command></primary>
    </indexterm>
    <indexterm>
      <primary>Text Editoren</primary>
      <secondary><command>emacs</command></secondary>
    </indexterm>

    <para>&os; verfügt über leistungsfähigere Editoren wie &man.vi.1;
      als Teil des Basissystems.  Andere Editoren wie
      <package>editors/emacs</package> und
      <package>editors/vim</package> sind Teil der Ports-Sammlung.
      Diese Editoren bieten höhere Funktionalität, jedoch auf Kosten
      einer etwas schwierigeren Erlernbarkeit.  Das Erlernen eines
      leistungsfähigeren Editors, wie <application>vim</application>
      oder <application>Emacs</application>, kann auf lange Sicht Zeit
      einsparen.</para>

    <para>Viele Anwendungen, die Dateien verändern oder Texteingabe
      erwarten, werden automatisch einen Texteditor öffnen.  Um den
      Standardeditor zu ändern, wird die Umgebungsvariable
      <envar>EDITOR</envar> gesetzt, wie im Abschnitt
      <xref linkend="shells"/> beschrieben.</para>
  </sect1>

  <sect1 xml:id="basics-devices">
    <title>Geräte und Gerätedateien</title>

    <para>Der Begriff Gerät wird meist in Verbindung mit Hardware
      wie Laufwerken, Druckern, Grafikkarten oder Tastaturen gebraucht.
      Der Großteil der Meldungen, die beim Booten von &os; angezeigt
      werden, beziehen sich auf gefundene Geräte.  Eine Kopie dieser
      Bootmeldungen wird in <filename>/var/run/dmesg.boot</filename>
      gespeichert.</para>

    <para>Jedes Gerät verfügt über einen Gerätenamen und Gerätenummer.
      Zum Beispiel steht <filename>acd0</filename> für das erste
      IDE CD-ROM Laufwerk, während <filename>kbd0</filename> die
      Tastatur repräsentiert.</para>

    <para>Auf die meisten Geräte wird unter &os; über spezielle
      Gerätedateien im <filename>/dev</filename> Verzeichnis
      zugegriffen.</para>
  </sect1>

  <sect1 xml:id="basics-more-information">
    <title>Weitere Informationen</title>

    <sect2 xml:id="basics-man">
      <title>Manualpages</title>
      <indexterm><primary>Manualpages</primary></indexterm>

      <para>Die umfassendste Dokumentation rund um &os; gibt es in
        Form von Manualpages.  Annähernd jedes Programm im System
        bringt eine kurze Referenzdokumentation mit, die die
        grundsätzliche Funktion und verschiedene Parameter
	erklärt.  Diese Manuals können mit <command>man</command>
	eingesehen werden:</para>

      <screen>&prompt.user; <userinput>man <replaceable>Kommando</replaceable></userinput></screen>

      <para><replaceable>Kommando</replaceable> ist der Name des
	Kommandos, über das man etwas erfahren will.  Um
	beispielsweise mehr über das Kommando &man.ls.1; zu
	erfahren, geben Sie ein:</para>

      <screen>&prompt.user; <userinput>man ls</userinput></screen>

      <para>Die Online-Manuals sind in nummerierte Sektionen
        unterteilt:</para>

      <orderedlist>
	<listitem>
	  <para>Benutzerkommandos.</para>
	</listitem>

	<listitem>
	  <para>Systemaufrufe und Fehlernummern.</para>
	</listitem>

	<listitem>
	  <para>Funktionen der C Bibliothek.</para>
	</listitem>

	<listitem>
	  <para>Gerätetreiber.</para>
	</listitem>

	<listitem>
	  <para>Dateiformate.</para>
	</listitem>

	<listitem>
	  <para>Spiele und andere Unterhaltung.</para>
	</listitem>

	<listitem>
	  <para>Verschiedene Informationen.</para>
	</listitem>

	<listitem>
	  <para>Systemverwaltung und -Kommandos.</para>
	</listitem>

	<listitem>
	  <para>Kernel Entwickler.</para>
	</listitem>
      </orderedlist>

      <para>In einigen Fällen kann dasselbe Thema in mehreren
	Sektionen auftauchen.  Es gibt zum Beispiel ein
	&man.chmod.1; Benutzerkommando und einen
	<function>chmod()</function> Systemaufruf.  Um &man.man.1;
	mitzuteilen, aus welcher Sektion die Information angezeigt
	werden soll, kann die Sektionsnummer mit angeben
	werden:</para>

      <screen>&prompt.user; <userinput>man 1 chmod</userinput></screen>

      <para>Dies wird Ihnen die Manualpage für das Benutzerkommando
	&man.chmod.1; zeigen.  Verweise auf eine Sektion der
	Manualpages werden traditionell in Klammern gesetzt.  So
	bezieht sich &man.chmod.1; auf das Benutzerkommando und
	&man.chmod.2; auf den Systemaufruf.</para>

      <para>Wenn der Name des Kommandos nicht bekannt ist, benutzt
	man <command>man -k</command>, um nach Schlüsselbegriffen in
	den Kommandobeschreibungen zu suchen:</para>

      <screen>&prompt.user; <userinput>man -k <replaceable>mail</replaceable>
</userinput></screen>

      <para>Dieser Befehl zeigt eine Liste von Kommandos, deren
        Beschreibung das Schlüsselwort
        <quote>mail</quote> enthält.  Die gleiche Funktionalität
        erhalten Sie auch, wenn Sie &man.apropos.1;
        benutzen.</para>

      <para>Um herauszufinden, was die Kommandos in
	<filename>/usr/bin</filename> tun, geben Sie ein:</para>

      <screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>man -f *</userinput></screen>

      <para>Dasselbe erreichen Sie durch Eingabe von:</para>

      <screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>whatis *</userinput></screen>

    </sect2>

    <sect2 xml:id="basics-info">
      <title>GNU Info Dateien</title>

      <para>&os; enthält viele Anwendungen und Utilities der Free
	Software Foundation (FSF).  Zusätzlich zu den Manualpages
	können diese Programme Hypertext-Dokumente enthalten, die
	<literal>info</literal>-Seiten genannt werden.  Diese
	Dokumente können mit &man.info.1; ansehen kann.  Wenn
	<package>editors/emacs</package> installiert ist, kann auch
	der info-Modus von <application>emacs</application> benutzt
	werden.</para>

      <para>Um &man.info.1; zu benutzen, geben Sie ein:</para>

      <screen>&prompt.user; <userinput>info</userinput></screen>

      <para>Eine kurze Einführung gibt es mit
        <literal>h</literal>; eine Befehlsreferenz erhalten Sie durch
        Eingabe von: <literal>?</literal>.</para>
    </sect2>
  </sect1>
</chapter>
