<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde$
     basiert auf: r39631
-->

<chapter id="basics">
  <chapterinfo>
    <authorgroup>
      <author>
	 <firstname>Chris</firstname>
	 <surname>Shumway</surname>
	 <contrib>Umgeschrieben von </contrib>
      </author>
    </authorgroup>

    <authorgroup>
      <author>
	 <firstname>Uwe</firstname>
	 <surname>Pierau</surname>
	 <contrib>Übersetzt von </contrib>
      </author>
    </authorgroup>
  </chapterinfo>

  <title>Grundlagen des UNIX Betriebssystems</title>

  <sect1 id="basics-synopsis">
    <title>Übersicht</title>

   <para>Das folgende Kapitel umfasst die grundlegenden Kommandos
     und Funktionsweisen des Betriebssystems FreeBSD.  Viel von dem folgenden
     Material gilt auch für jedes andere &unix;-artige System.
     Falls Sie mit dem Material schon vertraut sind, können Sie dieses
     Kapitel überlesen.  Wenn FreeBSD neu für Sie ist, dann sollten
     Sie dieses Kapitel auf jeden Fall aufmerksam lesen.</para>

   <para>Dieser Abschnitt behandelt die folgenden Themen:</para>

   <itemizedlist>
     <listitem>
       <para>virtuelle Konsolen,</para>
     </listitem>
     <listitem>
       <para>Zugriffsrechte unter &unix; sowie Datei-Flags unter &os;,</para>
     </listitem>
     <listitem>
       <para>Zugriffskontrolllisten für Dateisysteme,</para>
     </listitem>
     <listitem>
       <para>die Verzeichnisstruktur von &os;,</para>
     </listitem>
     <listitem>
       <para>Organisation von Dateisystemen unter &os;,</para>
     </listitem>
     <listitem>
       <para>Ein- und Abhängen von Dateisystemen,</para>
     </listitem>
     <listitem>
       <para>Prozesse, Dämonen und Signale,</para>
     </listitem>
     <listitem>
       <para>Shells und die Login-Umgebung,</para>
     </listitem>
     <listitem>
       <para>Texteditoren,</para>
     </listitem>
     <listitem>
       <para>Geräte und Gerätedateien,</para>
     </listitem>
     <listitem>
       <para>Binärformate unter &os; und</para>
     </listitem>
     <listitem>
       <para>wie Sie in den Manualpages nach weiteren Informationen
	 suchen können.</para>
     </listitem>
   </itemizedlist>
  </sect1>

  <sect1 id="consoles">
    <title>Virtuelle Konsolen und Terminals</title>
    <indexterm><primary>virtuelle Konsole</primary></indexterm>
    <indexterm><primary>Terminals</primary></indexterm>

    <para>Sie können FreeBSD mit einem Terminal benutzen, der nur Text
      darstellen kann.  Wenn Sie FreeBSD auf diese Weise benutzen, stehen
      Ihnen alle Möglichkeiten eines &unix; Betriebssystems zur
      Verfügung.  Dieser Abschnitt beschreibt was Terminals und
      Konsolen sind und wie sie unter FreeBSD eingesetzt werden.</para>

    <sect2 id="consoles-intro">
      <title>Die Konsole</title>
      <indexterm><primary>Konsole</primary></indexterm>

      <para>Wenn Ihr FreeBSD-System ohne eine graphische
        Benutzeroberfläche startet, wird am Ende des Systemstarts,
	nachdem die Startskripten gelaufen sind, ein Anmeldeprompt
	ausgegeben.  Die letzten Startmeldungen sollten ähnlich wie
	die Folgenden aussehen:</para>

      <screen>Additional ABI support:.
Local package initialization:.
Additional TCP options:.

Fri Sep 20 13:01:06 EEST 2002

FreeBSD/i386 (pc3.example.org) (ttyv0)

login:</screen>

      <para>Beachten Sie die letzten beiden Zeilen der Ausgabe, die
        vorletzte lautet:</para>

      <programlisting>FreeBSD/i386 (pc3.example.org) (ttyv0)</programlisting>

      <para>Diese Zeile enthält einige Informationen über das
        gerade gestartete System.  Die Ausgabe stammt von der
	FreeBSD-Konsole einer Maschine mit einem Intel oder
	Intel-kompatiblen Prozessor der x86-Architektur<footnote>
	  <para>Genau das ist mit <literal>i386</literal> gemeint.  Auch
	    wenn Ihr System keine Intel 386&nbsp;CPU besitzt, wird
	    <literal>i386</literal> ausgegeben.  Es wird immer die
	    Architektur und nicht der Typ des Prozessors ausgegeben.</para>
	</footnote>.  Der Name des Systems (jedes &unix; System besitzt
	einen Namen) ist <hostid>pc3.example.org</hostid> und die Ausgabe
	stammt von der Systemkonsole, dem Terminal
	<devicename>ttyv0</devicename>.</para>

      <para>Das Ende der Ausgabe ist immer die Aufforderung zur Eingabe
        eines Benutzernamens:</para>

      <programlisting>login:</programlisting>

      <para>Der Anmeldevorgang wird im nächsten Abschnitt
        erläutert.</para>
    </sect2>

    <sect2 id="consoles-login">
      <title>Der Anmeldevorgang</title>

      <para>FreeBSD ist ein Mehrbenutzersystem, das Multitasking
        unterstützt.  Das heißt mehrere Benutzer können
	gleichzeitig viele Programme auf einem System laufen lassen.</para>

      <para>Jedes Mehrbenutzersystem muss die Benutzer voneinander
        unterscheiden können.  Bei FreeBSD und allen anderen
	&unix;-artigen
	Betriebssystemen wird dies dadurch erreicht, dass sich die
	Benutzer anmelden müssen, bevor sie Programme laufen lassen
	können.  Jeder Benutzer besitzt einen eindeutigen Namen (den
	Account) und ein dazugehörendes Passwort, die beide bei
	der Anmeldung abgefragt werden.</para>

      <indexterm><primary>Startskripten</primary></indexterm>
      <para>Nachdem FreeBSD gestartet ist und die Startskripten<footnote>
	  <para>Startskripten sind Programme, die FreeBSD automatisch bei
	    jedem Startvorgang ausführt.  Der Zweck der Skripte
	    besteht darin, das System zu konfigurieren und nützliche
	    Dienste im Hintergrund zu starten.</para>
	</footnote>, gelaufen sind, erscheint eine Aufforderung zur Eingabe
	des Benutzernamens:</para>

      <screen>login:</screen>

      <para>Wenn Ihr Benutzername beispielsweise <username>john</username>
        ist, geben Sie jetzt <literal>john</literal> gefolgt von
	<keycap>Enter</keycap> ein.  Sie sollten dann eine Aufforderung zur
	Eingabe des Passworts erhalten:</para>

      <screen>login: <userinput>john</userinput>
Password:</screen>

      <para>Geben Sie jetzt das Passwort von <username>john</username>
	gefolgt von <keycap>Enter</keycap> ein.  Das Passwort wird aus
	Sicherheitsgründen nicht auf dem Bildschirm angezeigt.</para>

      <para>Wenn Sie das richtige Passwort eingegeben haben, sind Sie
        am System angemeldet und können nun alle verfügbaren
	Kommandos absetzen.</para>

      <para>Anmgemeldet sind Sie, wenn Sie die Tagesmeldungen
	(<foreignphrase>message of today</foreignphrase>) gefolgt
	von einer Eingabeaufforderung (dem Zeichen <literal>#</literal>,
	<literal>$</literal> oder <literal>%</literal>) gesehen
	haben.</para>
    </sect2>

    <sect2 id="consoles-virtual">
      <title>Virtuelle Konsolen</title>

      <para>Da FreeBSD mehrere Programme gleichzeitig laufen lassen kann,
        ist eine einzige Konsole, an der Kommandos abgesetzt werden
	können, zu wenig.  Abhilfe schaffen virtuelle Konsolen, die
	mehrere Konsolen zur Verfügung stellen.</para>

      <para>Die Anzahl der virtuellen Konsolen unter FreeBSD können Sie
        einstellen.  Zwischen den einzelnen Konsolen können Sie mit
	speziellen Tastenkombinationen wechseln.  Jede Konsole verfügt
	über einen eigenen Ausgabekanal und FreeBSD ordnet die
	Tastatureingaben und Monitorausgaben der richtigen Konsole zu, wenn
	Sie zwischen den Konsolen wechseln.</para>

      <para>Zum Umschalten der Konsolen stellt FreeBSD spezielle
        Tastenkombinationen bereit<footnote>
	  <para>Eine recht technische und genaue Beschreibung der FreeBSD-Konsole
            und der Tastatur-Treiber finden Sie in den Hilfeseiten
	    &man.syscons.4;, &man.atkbd.4;, &man.vidcontrol.1; und
	    &man.kbdcontrol.1;.  Lesen Sie diese Seiten, wenn Sie an den
	    Einzelheiten interessiert sind.</para>
	</footnote>.  Benutzen Sie
	<keycombo><keycap>Alt</keycap><keycap>F1</keycap></keycombo>,
	<keycombo><keycap>Alt</keycap><keycap>F2</keycap></keycombo> bis
	<keycombo><keycap>Alt</keycap><keycap>F8</keycap></keycombo>,
	um zwischen den verschiedenen Konsolen umzuschalten.</para>

      <para>Wenn Sie zu einer anderen Konsole wechseln, sichert FreeBSD den
        Bildschirminhalt und gibt den Bildschirminhalt der neuen Konsole
	aus.  Dies erzeugt die Illusion mehrerer Bildschirme und
	Tastaturen, an denen Sie Kommandos absetzen können.  Wenn eine
	Konsole nicht sichtbar ist, weil Sie auf eine andere Konsole
	gewechselt haben, laufen die dort abgesetzten Kommandos
	weiter.</para>
    </sect2>

    <sect2 id="consoles-ttys">
      <title><filename>/etc/ttys</filename></title>

      <para>In der Voreinstellung stehen unter FreeBSD acht virtuelle
	Konsolen zur Verfügung, deren Anzahl Sie leicht erhöhen
	oder verringern können.  Die Anzahl und Art der Konsolen wird
	in <filename>/etc/ttys</filename> eingestellt.</para>

      <para>Jede Zeile in <filename>/etc/ttys</filename>, die nicht mit
        <literal>#</literal> anfängt, konfiguriert einen Terminal oder
	eine virtuelle Konsole.  In der Voreinstellung werden in dieser
	Datei neun virtuelle Konsolen definiert, von denen acht aktiviert
	sind.  Die Konsolen sind in den Zeilen, die mit
	<literal>ttyv</literal> beginnen, definiert:</para>

      <programlisting># name  getty                           type    status          comments
#
ttyv0   "/usr/libexec/getty Pc"         cons25  on  secure
# Virtual terminals
ttyv1   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv2   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv3   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv4   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv5   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv6   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv7   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv8   "/usr/X11R6/bin/xdm -nodaemon"  xterm   off secure</programlisting>

      <para>Die Hilfeseite &man.ttys.5; enthält eine ausführliche
	Beschreibung der Spalten dieser Datei und der Optionen, die Sie zum
	Konfigurieren der virtuellen Konsolen benutzen können.</para>
    </sect2>

    <sect2 id="consoles-singleuser">
      <title>Die Konsole im Single-User-Modus</title>

      <para>Eine eingehende Beschreibung des Single-User-Modus finden Sie
        in <xref linkend="boot-singleuser"/>.  Im Single-User-Modus steht
	Ihnen nur <emphasis>eine</emphasis> Konsole zur Verfügung.
	Die Definition dieser Konsole befindet sich ebenfalls in
	<filename>/etc/ttys</filename>.  Suchen Sie nach einer Zeile, die
	mit <literal>console</literal> beginnt:</para>

      <programlisting># name  getty                           type    status          comments
#
# If console is marked "insecure", then init will ask for the root password
# when going to single-user mode.
console none                            unknown off secure</programlisting>

      <note>
	<para>In der Zeile, die mit <literal>console</literal> beginnt,
	  können Sie <literal>secure</literal> durch
	  <literal>insecure</literal> ersetzen.  Wenn Sie danach in den
	  Single-User-Modus booten, verlangt das System ebenfalls die
	  Eingabe des <username>root</username>-Passworts.</para>

	<para><emphasis>Setzen Sie <literal>insecure</literal> nicht
	  leichtfertig ein.</emphasis>  Wenn Sie das Passwort von
	  <username>root</username> vergessen, wird es schwierig, in den
	  Single-User-Modus zu gelangen, wenn Sie den
	  FreeBSD-Boot-Prozess nicht genau verstehen.</para>
      </note>
    </sect2>

    <sect2 id="consoles-vidcontrol">
      <title>Den Videomodus der Konsole anpassen</title>

      <para>Der Standard-Videomodus der FreeBSD-Konsole kann auf jeden
	Modus eingestellt werden, der von Ihrer Grafikkarte und Ihrem
	Monitor unterstützt wird (beispielsweise 1024x768 oder
	1280x1024).  Wollen Sie eine andere Einstellung verwenden,
	müssen Sie Ihren Kernel neu kompilieren, nachdem Sie die
	zwei folgenden Zeilen in Ihre Kernelkonfigurationsdatei
	aufgenommen haben:</para>

      <programlisting>OPTIONS VESA
options SC_PIXEL_MODE</programlisting>

      <para>Nachdem Sie den Kernel mit diesen zwei Optionen neu
	kompiliert haben, bestimmen Sie die möglichen
	Videomodi mit dem Werkzeug &man.vidcontrol.1;.  Um
	beispielsweise einer Liste aller unterstützten
	Modi zu erhalten, verwenden Sie den folgenden Befehl:</para>

      <screen>&prompt.root; <userinput>vidcontrol -i mode</userinput></screen>

      <para>Als Ergebnis erhalten Sie eine Liste aller Videomodi,
	die von Ihrer Hardware unterstützt werden.  Sie wählen
	einen neuen Modus aus, indem Sie den entsprechenden Wert
	(wiederum als Benutzer <username>root</username>) an
	&man.vidcontrol.1; übergeben:</para>

      <screen>&prompt.root; <userinput>vidcontrol MODE_279</userinput></screen>

      <para>Um diese Einstellung dauerhaft zu speichern, müssen Sie
	die folgende Zeile in die Datei
	<filename>/etc/rc.conf</filename> aufnehmen:</para>

      <programlisting>allscreens_flags="MODE_279"</programlisting>
    </sect2>
  </sect1>

  <sect1 id="permissions">
    <title>Zugriffsrechte</title>
    <indexterm><primary>UNIX</primary></indexterm>

    <para>FreeBSD, das ein direkter Abkömmling von BSD &unix; ist,
      stützt sich auf mehrere Grundkonzepte von &unix; Systemen.
      Das erste und ausgeprägteste: FreeBSD ist
      ein Mehrbenutzer-Betriebssystem.  Das System ermöglicht,
      dass mehrere Benutzer gleichzeitig an völlig verschiedenen
      und unabhängigen Aufgaben arbeiten können.  Es ist
      verantwortlich für eine gerechte Auf- und Zuteilung von
      Nachfragen nach Hardware- und Peripheriegeräten, Speicher
      und CPU-Zeit unter den Benutzern.</para>

    <para>Da das System mehrere Benutzer unterstützt, hat alles,
      was das System verwaltet, einen Satz von Rechten, die bestimmen,
      wer die jeweilige Ressource lesen, schreiben oder ausführen
      darf.  Diese Zugriffsrechte stehen in drei Achtergruppen, die in
      drei Teile unterteilt sind: einen für den Besitzer der
      Datei, einen für die Gruppe, zu der die Datei gehört
      und einen für alle anderen.  Die numerische Darstellung
      sieht wie folgt aus:</para>

    <indexterm><primary>Zugriffsrechte</primary></indexterm>
    <indexterm>
      <primary>Dateizugriffsrechte</primary>
    </indexterm>
    <informaltable frame="none" pgwide="1">
      <tgroup cols="3">
	<thead>
	  <row>
	    <entry>Wert</entry>
	    <entry>Zugriffsrechte</entry>
	    <entry>Auflistung im Verzeichnis</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry>0</entry>
	    <entry>Kein Lesen, Kein Schreiben, Kein Ausführen</entry>
	    <entry><literal>---</literal></entry>
	  </row>

	  <row>
	    <entry>1</entry>
	    <entry>Kein Lesen, Kein Schreiben, Ausführen</entry>
	    <entry><literal>--x</literal></entry>
	  </row>

	  <row>
	    <entry>2</entry>
	    <entry>Kein Lesen, Schreiben, Kein Ausführen</entry>
	    <entry><literal>-w-</literal></entry>
	  </row>

	  <row>
	    <entry>3</entry>
	    <entry>Kein Lesen, Schreiben, Ausführen</entry>
	    <entry><literal>-wx</literal></entry>
	  </row>

	  <row>
	    <entry>4</entry>
	    <entry>Lesen, Kein Schreiben, Kein Ausführen</entry>
	    <entry><literal>r--</literal></entry>
	  </row>

	  <row>
	    <entry>5</entry>
	    <entry>Lesen, Kein Schreiben, Ausführen</entry>
	    <entry><literal>r-x</literal></entry>
	  </row>

	  <row>
	    <entry>6</entry>
	    <entry>Lesen, Schreiben, Kein Ausführen</entry>
	    <entry><literal>rw-</literal></entry>
	  </row>

	  <row>
	    <entry>7</entry>
	    <entry>Lesen, Schreiben, Ausführen</entry>
	    <entry><literal>rwx</literal></entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>
    <indexterm>
      <primary><command>ls</command></primary>
    </indexterm>
    <indexterm><primary>Verzeichnisse</primary></indexterm>

    <para>Sie können <option>-l</option> auf der Kommandozeile
      von &man.ls.1; angeben, um eine ausführliche Verzeichnisauflistung
      zu sehen, die in einer Spalte die Zugriffsrechte für den
      Besitzer, die Gruppe und alle anderen enthält.
      Die Ausgabe von <command>ls -l</command> könnte
      wie folgt aussehen:</para>

    <screen>&prompt.user; <userinput>ls -l</userinput>
total 530
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 myfile
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 otherfile
-rw-r--r--  1 root  wheel    7680 Sep  5 12:31 email.txt
...</screen>

    <para>Die erste Spalte der Ausgabe enthält die
      Zugriffsrechte:</para>

    <screen>-rw-r--r--</screen>

    <para>Das erste Zeichen von links ist ein Symbol, welches angibt,
      ob es sich um eine normale Datei, ein Verzeichnis, ein
      zeichenorientiertes Gerät, ein Socket oder irgendeine andere
      Pseudo-Datei handelt.  In diesem Beispiel zeigt <literal>-</literal> eine
      normale Datei an.  Die nächsten drei Zeichen,
      dargestellt als <literal>rw-</literal>, ergeben die Rechte
      für den Datei-Besitzer.  Die drei Zeichen danach
      <literal>r--</literal> die Rechte der Gruppe, zu der die Datei
      gehört.  Die letzten drei Zeichen, <literal>r--</literal>,
      geben die Rechte für den Rest der Welt an.  Ein Minus
      bedeutet, dass das Recht nicht gegeben ist.  In diesem Fall
      sind die Zugriffsrechte also: der Eigentümer kann die Datei
      lesen und schreiben, die Gruppe kann lesen und alle anderen
      können auch nur lesen.  Entsprechend obiger Tabelle
      wären die Zugriffsrechte für diese Datei
      <literal>644</literal>, worin jede Ziffer die drei Teile der
      Zugriffsrechte dieser Datei verkörpert.</para>

    <para>Das ist alles schön und gut, aber wie kontrolliert das
      System die Rechte von Hardware-Geräten?  FreeBSD behandelt
      die meisten Hardware-Geräte als Dateien, welche Programme
      öffnen, lesen und mit Daten beschreiben können wie
      alle anderen Dateien auch.  Diese Spezial-Dateien sind im
      Verzeichnis <filename>/dev</filename> gespeichert.</para>

    <para>Verzeichnisse werden ebenfalls wie Dateien behandelt.  Sie
      haben Lese-, Schreib- und Ausführ-Rechte.  Das
      Ausführungs-Bit hat eine etwas andere Bedeutung für
      ein Verzeichnis als für eine Datei.  Die Ausführbarkeit
      eines Verzeichnisses bedeutet, dass in das Verzeichnis
      zum Beispiel mit <command>cd</command> gewechselt werden kann.
      Das bedeutet auch, dass in dem Verzeichnis auf Dateien, deren
      Namen bekannt sind, zugegriffen werden kann, vorausgesetzt die
      Zugriffsrechte der Dateien lassen dies zu.</para>

    <para>Das Leserecht auf einem Verzeichnis erlaubt es, sich den Inhalt
      des Verzeichnisses anzeigen zu lassen.  Um eine Datei mit bekanntem
      Namen in einem Verzeichnis zu löschen, müssen auf dem
      Verzeichnis Schreib- <emphasis>und</emphasis> Ausführ-Rechte
      gesetzt sein.</para>

    <para>Es gibt noch mehr Rechte, aber die werden vor allem in
      speziellen Umständen benutzt, wie zum Beispiel bei
      SetUID-Binaries und Verzeichnissen mit gesetztem Sticky-Bit.
      Mehr über Zugriffsrechte von Dateien und wie sie gesetzt werden,
      finden Sie in &man.chmod.1;.</para>

    <sect2>
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	    <contrib>Beigesteuert von </contrib>
	  </author>
	</authorgroup>
      </sect2info>

      <title>Symbolische Zugriffsrechte</title>
      <indexterm>
	<primary>Zugriffsrechte</primary>
	<secondary>symbolische</secondary>
      </indexterm>

      <para>Die Zugriffsrechte lassen sich auch über Symbole
	anstelle von oktalen Werten festlegen.  Symbolische
	Zugriffsrechte werden in der Reihenfolge
	<replaceable>Wer</replaceable>, <replaceable>Aktion</replaceable>
	und <replaceable>Berechtigung</replaceable> angegeben.
	Die folgenden Symbole stehen zur Auswahl:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>Option</entry>
	      <entry>Symbol</entry>
	      <entry>Bedeutung</entry>
	    </row>
	  </thead>

	<tbody>
	  <row>
	    <entry><replaceable>Wer</replaceable></entry>
	    <entry>u</entry>
	    <entry>Benutzer (<foreignphrase>user</foreignphrase>)</entry>
	  </row>

	  <row>
	    <entry><replaceable>Wer</replaceable></entry>
	    <entry>g</entry>
	    <entry>Gruppe (<foreignphrase>group</foreignphrase>)</entry>
	  </row>

	  <row>
	    <entry><replaceable>Wer</replaceable></entry>
	    <entry>o</entry>
	    <entry>Andere (<foreignphrase>other</foreignphrase>)</entry>
	  </row>

	  <row>
	    <entry><replaceable>Wer</replaceable></entry>
	    <entry>a</entry>
	    <entry>Alle</entry>
	  </row>

	  <row>
	    <entry><replaceable>Aktion</replaceable></entry>
	    <entry>+</entry>
	    <entry>Berechtigungen hinzufügen</entry>
	  </row>

	  <row>
	    <entry><replaceable>Aktion</replaceable></entry>
	    <entry>-</entry>
	    <entry>Berechtigungen entziehen</entry>
	  </row>

	  <row>
	    <entry><replaceable>Aktion</replaceable></entry>
	    <entry>=</entry>
	    <entry>Berechtigungen explizit setzen</entry>
	  </row>

	  <row>
	    <entry><replaceable>Berechtigung</replaceable></entry>
	    <entry>r</entry>
	    <entry>lesen (<foreignphrase>read</foreignphrase>)</entry>
	  </row>

	  <row>
	    <entry><replaceable>Berechtigung</replaceable></entry>
	    <entry>w</entry>
	    <entry>schreiben (<foreignphrase>write</foreignphrase>)</entry>
	  </row>

	  <row>
	    <entry><replaceable>Berechtigung</replaceable></entry>
	    <entry>x</entry>
	    <entry>ausführen
	      (<foreignphrase>execute</foreignphrase>)</entry>
	  </row>

	  <row>
	    <entry><replaceable>Berechtigung</replaceable></entry>
	    <entry>t</entry>
	    <entry>Sticky-Bit</entry>
	  </row>

	  <row>
	    <entry><replaceable>Berechtigung</replaceable></entry>
	    <entry>s</entry>
	    <entry>Set-UID oder Set-GID</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <para>Symbolische Zugriffsrechte werden wie die numerischen
      mit dem Kommando &man.chmod.1; vergeben.  Wenn
      Sie beispielsweise allen anderen Benutzern den Zugriff auf
      die Datei <replaceable>FILE</replaceable> verbieten wollen,
      benutzen Sie den nachstehenden Befehl:</para>

    <screen>&prompt.user; <userinput>chmod go= FILE</userinput></screen>

    <para>Wenn Sie mehr als eine Änderung der Rechte einer
      Datei vornehmen wollen, können Sie eine durch Kommata
      getrennte Liste der Rechte angeben.  Das folgende Beispiel
      entzieht der Gruppe und der Welt (den anderen) die
      Schreibberechtigung auf die Datei <replaceable>FILE</replaceable>
      und fügt dann für alle Ausführungsrechte
      hinzu:</para>

    <screen>&prompt.user; <userinput>chmod go-w,a+x <replaceable>FILE</replaceable></userinput></screen>

<!--
    <para>Mit symbolischen Zugriffsrechten können Sie Rechte
      hinzufügen oder Rechte wegnehmen.  Numerische Zugriffsrechte
      erlauben nur das explizite Setzen der Zugriffsrechte.</para>
-->
    </sect2>

    <sect2>
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	    <contrib>Beigetragen von </contrib>
	  </author>
	</authorgroup>
      </sect2info>

      <title>&os; Datei-Flags</title>

      <para>Zusätzlich zu den vorhin diskutierten Zugriffsrechten
	unterstützt &os; auch die sogenannten
	<quote>Datei-Flags</quote>.  Diese erhöhen die Sicherheit
	Ihres Systems, indem sie eine verbesserte Kontrolle von
	Dateien erlauben.  Verzeichnisse werden allerdings nicht
	unterstützt.</para>

      <para>Diese verbesserte Sicherheit führt dazu, dass manche
	Dateien nicht einmal von <username>root</username> gelöscht
	oder bearbeitet werden können.</para>

      <para>Datei-Flags können über &man.chflags.1; gesetzt
	oder gelöscht werden.  Um beispielsweise die Datei
	<filename>file1</filename> mit dem
	<quote>unlöschbar</quote>-Flag zu sichern, geben Sie
	folgenden Befehl ein:</para>

      <screen>&prompt.root; <userinput>chflags sunlink <filename>file1</filename></userinput></screen>

      <para>Um dieses Flag wieder zu löschen, geben Sie den
	Befehl erneut ein.  Allerdings setzen Sie ein
	<quote>no</quote> vor <option>sunlink</option>:</para>

      <screen>&prompt.root; <userinput>chflags nosunlink <filename>file1</filename></userinput></screen>

      <para>Um die Flags dieser Datei anzuzeigen, verwenden Sie
	&man.ls.1; zusammen mit der Option <option>-lo</option>:</para>

      <screen>&prompt.root; <userinput>ls -lo <filename>file1</filename></userinput></screen>

      <para>Dadurch erhalten Sie eine Ausgabe ähnlich der
	folgenden:</para>

      <programlisting>-rw-r--r--  1 trhodes  trhodes  sunlnk 0 Mar  1 05:54 file1</programlisting>

      <para>Viele Flags können nur von <username>root</username>
	gesetzt oder gelöscht werden.  Andere wiederum können
	auch vom Eigentümer der Datei gesetzt werden.  Weitere
	Informationen zu Datei-Flags finden sich in den Manualpages
	&man.chflags.1; und &man.chflags.2;.</para>
    </sect2>

    <sect2>
      <sect2info>
        <authorgroup>
          <author>
            <firstname>Tom</firstname>
  	    <surname>Rhodes</surname>
  	    <contrib>Beigetragen von </contrib>
          </author>
        </authorgroup>
      </sect2info>

      <title>Die Berechtigungen setuid, setgid, und sticky</title>

      <para>Anders als die Berechtigungen, die bereits angesprochen wurden,
        existieren drei weitere Einstellungen, über die alle
        Administratoren Bescheid wissen sollten.  Dies sind die Berechtigungen
        <literal>setuid</literal>, <literal>setgid</literal> und
        <literal>sticky</literal>.</para>

      <para>Diese Einstellungen sind wichtig für manche &unix;-Operationen,
        da sie Funktionalitäten zur Verfügung stellen, die
        normalerweise nicht an gewöhnliche Anwender vergeben wird.
        Um diese zu verstehen, muss der Unterschied zwischen der realen
        und der effektiven Benutzer-ID erwähnt werden.</para>

      <para>Die reale Benutzer-ID ist die <acronym>UID</acronym>, welche den
        Prozess besitzt oder gestartet hat.  Die effektive
        <acronym>UID</acronym> ist diejenige, als die der Prozess läuft.
        Beispielsweise wird &man.passwd.1; mit der realen ID des Benutzers
        ausgeführt, der sein Passwort ändert. Um jedoch die
        Passwortdatenbank zu bearbeiten, wird es effektiv als
        <username>root</username>-Benutzer ausgeführt.  Das
        ermöglicht es normalen Benutzern, ihr Passwort zu ändern, ohne
        einen <errorname>Permission Denied</errorname>-Fehler angezeigt zu
        bekommen.</para>

      <note>
        <para>Die <literal>nosuid</literal> &man.mount.8;-Option wird dafür
          sorgen, dass diese Anwendungen stillschweigend scheitern.  Genauer
          gesagt, sie werden nicht ausgeführt und der Anwender wird
          darüber auch nicht informiert.  Auf diese Option kann man sich
          nicht vollständig verlassen, da ein
          <literal>nosuid</literal>-Wrapper in der Lage wäre, dies zu
          umgehen, wie in der &man.mount.8; Manualpage zu lesen ist.</para>
      </note>

      <para>Die setuid-Berechtigung kann durch das Voranstellen bei einer
        Berechtigungsgruppe mit der Nummer Vier (4) gesetzt werden, wie im
        folgenden Beispiel gezeigt wird:</para>

      <screen>&prompt.root; <userinput>chmod 4755 suidexample.sh</userinput></screen>

      <para>Die Berechtigungen auf der
        <filename><replaceable>suidexample.sh</replaceable></filename>-Datei
        sollten jetzt wie folgt aussehen:</para>

      <programlisting>-rwsr-xr-x   1 trhodes  trhodes    63 Aug 29 06:36 suidexample.sh</programlisting>

      <para>In dem Beispiel sollte auffallen, dass ein <literal>s</literal>
        jetzt Teil der Berechtigungen des Dateibesitzers geworden ist, welches
        das Ausführen-Bit ersetzt.  Dies ermöglicht es Werkzeugen
        mit erhöhten Berechtigungen zu laufen, wie z.B.
        <command>passwd</command>.</para>

      <para>Um dies in Echtzeit zu beobachten, öffnen Sie zwei Terminals.
        Starten Sie auf einem den <command>passwd</command>-Prozess als normaler
        Benutzer.  Während es auf die Passworteingabe wartet,
        überprüfen Sie die Prozesstabelle und sehen Sie sich die
        Informationen des <command>passwd</command>-Kommandos an.</para>

      <para>Im Terminal A:</para>

      <screen>Changing local password for trhodes
Old Password:</screen>

      <para>Im Terminal B:</para>

      <screen>&prompt.root; <userinput>ps aux | grep passwd</userinput></screen>

      <screen>trhodes  5232  0.0  0.2  3420  1608   0  R+    2:10AM   0:00.00 grep passwd
  	 root     5211  0.0  0.2  3620  1724   2  I+    2:09AM   0:00.01 passwd</screen>

      <para>Wie oben erwähnt, wird <command>passwd</command> von einem
        normalen Benutzer ausgeführt, benutzt aber die effektive
        <acronym>UID</acronym> von <username>root</username>.</para>

      <para>Die <literal>setgid</literal>-Berechtigung führt die gleiche
        Aktion wie die <literal>setuid</literal>-Berechtigung durch, allerdings
        verändert sie die Gruppenberechtigungen.  Wenn eine Anwendung
        oder ein Werkzeug mit dieser Berechtigung ausgeführt wird,
        erhält es die Berechtigungen basierend auf der Gruppe, welche die
        Datei besitzt und nicht die des Benutzers, der den Prozess gestartet
        hat.</para>

      <para>Um die <literal>setgid</literal>-Berechtigung auf einer Datei zu
        setzen, geben Sie dem <command>chmod</command>-Befehl eine
        führende Zwei (2) mit, wie im folgenden gezeigt:</para>

      <screen>&prompt.root; <userinput>chmod 2755 sgidexample.sh</userinput></screen>

      <para>Die neue Einstellung kann wie zuvor betrachtet werden. Beachten Sie,
        dass das <literal>s</literal> sich jetzt in dem Feld befindet, das
        für die Berechtigungen der Gruppe bestimmt ist:</para>

      <screen>-rwxr-sr-x   1 trhodes  trhodes    44 Aug 31 01:49 sgidexample.sh</screen>

      <note>
        <para>Obwohl es sich bei dem in diesen Beispielen gezeigten Shellskript
          um eine ausführbare Datei handelt, wird es nicht mit einer
          anderen <acronym>EUID</acronym> oder effektiven Benutzer-ID
          ausgeführt.  Das ist so, weil Shellskripte keinen Zugriff auf
          &man.setuid.2;-Systemaufrufe erhalten.</para>
      </note>

      <para>Diese beiden ersten angesprochenen Spezialberechtigungen (die
        <literal>setuid</literal> und <literal>setgid</literal>
        Berechtigungs-Bits) können die Systemsicherheit verringern, da
        sie erhöhte Rechte ermöglichen.  Es gibt noch ein drittes
        Berechtigungs-Bit, das die Sicherheit eines Systems erhöhen kann:
        das <literal>sticky bit</literal>.</para>

      <para>Das <literal>sticky bit</literal> erlaubt, wenn es auf ein
        Verzeichnis angewendet wird, nur dem Besitzer der Datei diese Dateien
        auch zu löschen.  Dieses Recht ist nützlich, um die
        Löschung von Dateien in öffentlichen Verzeichnissen durch
        Benutzer, denen diese Dateien nicht gehören, zu verhindern, wie
        z.B. in <filename
        class="directory">/tmp</filename>.  Um diese Berechtigung anzuwenden,
        stellen Sie der Berechtigung eine Eins (1) voran, beispielsweise
        so:</para>

      <screen>&prompt.root; <userinput>chmod 1777 /tmp</userinput></screen>

      <para>Den Effekt können Sie sich ansehen, indem Sie
        das Kommando <command>ls</command> ausführen:</para>

      <screen>&prompt.root; <userinput>ls -al / | grep tmp</userinput></screen>

      <screen>drwxrwxrwt  10 root  wheel         512 Aug 31 01:49 tmp</screen>

      <para>Das <literal>sticky bit</literal> kann anhand des
        <literal>t</literal> ganz am Ende der Berechtigungen abgelesen
        werden.</para>
    </sect2>
  </sect1>

  <sect1 id="dirstructure">
    <title>Verzeichnis-Strukturen</title>
    <indexterm><primary>Verzeichnis Hierarchien</primary></indexterm>

    <para>Die FreeBSD-Verzeichnishierarchie ist die Grundlage, um
      ein umfassendes Verständnis des Systems zu erlangen.
      Das wichtigste Konzept, das Sie verstehen sollten, ist das
      Root-Verzeichnis <quote>/</quote>.  Dieses Verzeichnis ist das
      erste, das während des Bootens eingehangen wird.  Es
      enthält das notwendige Basissystem, um das System in den
      Mehrbenutzerbetrieb zu bringen.  Das Root-Verzeichnis enthält
      auch die Mountpunkte für Dateisysteme, die beim Wechsel in
      den Multiuser-Modus eingehängt werden.</para>

    <para>Ein Mountpunkt ist ein Verzeichnis, in das zusätzliche
      Dateisysteme (in der Regel unterhalb des Wurzelverzeichnisses)
      eingehängt werden können.  Dieser Vorgang wird in
      <xref linkend="disk-organization"/> ausführlich beschrieben.
      Standard-Mountpunkte sind <filename>/usr</filename>,
      <filename>/var</filename>, <filename>/tmp</filename>,
      <filename>/mnt</filename> sowie <filename>/cdrom</filename>.
      Auf diese Verzeichnisse verweisen üblicherweise Einträge
      in der Datei <filename>/etc/fstab</filename>.
      <filename>/etc/fstab</filename> ist
      eine Tabelle mit verschiedenen Dateisystemen und Mountpunkten
      als Referenz des Systems.  Die meisten der Dateisysteme in
      <filename>/etc/fstab</filename> werden beim Booten automatisch
      durch das Skript &man.rc.8; gemountet, wenn die zugehörigen
      Einträge nicht mit der Option <option>noauto</option>
      versehen sind.  Weitere Informationen zu diesem Thema finden Sie
      im <xref linkend="disks-fstab"/>.</para>

    <para>Eine vollständige Beschreibung der Dateisystem-Hierarchie
      finden Sie in &man.hier.7;.  Als Beispiel sei eine kurze
      Übersicht über die am häufigsten verwendeten
      Verzeichnisse gegeben:</para>

    <para>
      <informaltable frame="none" pgwide="1">
        <tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Verzeichnis</entry>
	      <entry>Beschreibung</entry>
	    </row>
	  </thead>
	  <tbody valign="top">
            <row>
	      <entry><filename class="directory">/</filename></entry>
	      <entry>Wurzelverzeichnis des Dateisystems.</entry>
            </row>

	    <row>
	      <entry><filename class="directory">/bin/</filename></entry>
	      <entry>Grundlegende Werkzeuge für den Single-User-Modus
		sowie den Mehrbenutzerbetrieb.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/boot/</filename></entry>
	      <entry>Programme und Konfigurationsdateien, die während
		des Bootens benutzt werden.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/boot/defaults/</filename></entry>
	      <entry>Vorgaben für die Boot-Konfiguration, siehe
		&man.loader.conf.5;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/dev/</filename></entry>
	      <entry>Gerätedateien, siehe &man.intro.4;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/</filename></entry>
	      <entry>Konfigurationsdateien und Skripten des Systems.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/defaults/</filename></entry>
	      <entry>Vorgaben für die System Konfigurationsdateien,
		siehe &man.rc.8;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/mail/</filename></entry>
	      <entry>Konfigurationsdateien von MTAs wie
		&man.sendmail.8;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/namedb/</filename></entry>
	      <entry>Konfigurationsdateien von <command>named</command>,
		siehe &man.named.8;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/periodic/</filename></entry>
	      <entry>Täglich, wöchentlich oder monatlich
		ablaufende Skripte, die von &man.cron.8; gestartet werden.
		Siehe &man.periodic.8;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/ppp/</filename></entry>
	      <entry>Konfigurationsdateien von <command>ppp</command>,
		siehe &man.ppp.8;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/mnt/</filename></entry>
	      <entry>Ein leeres Verzeichnis, das von Systemadministratoren
		häufig als temporärer Mountpunkt genutzt wird.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/proc/</filename></entry>
	      <entry>Prozess Dateisystem, siehe &man.procfs.5;
		und &man.mount.procfs.8;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/rescue/</filename></entry>
	      <entry>Statisch gelinkte Programme zur Wiederherstellung
		des Systems, lesen Sie dazu auch &man.rescue.8;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/root/</filename></entry>
	      <entry>Home Verzeichnis von <username>root</username>.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/sbin/</filename></entry>
	      <entry>Systemprogramme und administrative Werkzeuge, die
		grundlegend für den Single-User-Modus und den
		Mehrbenutzerbetrieb sind.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/tmp/</filename></entry>
	      <entry>Temporäre Dateien, die für gewöhnlich
		bei einem Neustart des Systems verloren gehen.
		Häufig wird ein speicherbasiertes Dateisystem unter
		<filename class="directory">/tmp</filename>
		eingehängt.  Dieser Vorgang kann automatisiert werden,
		wenn Sie die tmpmfs-bezogenen Variablen von
		&man.rc.conf.5; verwenden.  Alternativ können Sie
		auch einen entsprechenden Eintrag in
		<filename>/etc/fstab</filename> aufnehmen.  Weitere
		Informationen finden Sie in &man.mdmfs.8;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/</filename></entry>
	      <entry>Der Großteil der Benutzerprogramme und
		Anwendungen.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/bin/</filename></entry>
	      <entry>Gebräuchliche Werkzeuge, Programmierhilfen und
		Anwendungen.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/include/</filename></entry>
	      <entry>Standard C include-Dateien.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/lib/</filename></entry>
	      <entry>Bibliotheken.</entry>
	    </row>


	    <row>
	      <entry><filename class="directory">/usr/libdata/</filename></entry>
	      <entry>Daten verschiedener Werkzeuge.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/libexec/</filename></entry>
	      <entry>System-Dämonen und System-Werkzeuge, die von
		anderen Programmen ausgeführt werden.</entry>
	    </row>

	    <row>
	      <entry><filename
	      class="directory">/usr/local/</filename></entry>

	      <entry>Lokale Programme, Bibliotheken usw.  Die Ports-Sammlung
		benutzt dieses Verzeichnis als Zielverzeichnis für zu
		installierende Anwendungen.  Innerhalb von
		<filename>/usr/local</filename> sollte das von
		&man.hier.7; beschriebene Layout für
		<filename>/usr</filename> benutzt werden.  Das
		<filename>man</filename> Verzeichnis wird direkt unter
		<filename>/usr/local</filename> anstelle unter
		<filename>/usr/local/share</filename> angelegt.  Die
		Dokumentation der Ports findet sich in
		<filename>share/doc/<replaceable>port</replaceable></filename>.
	      </entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/obj/</filename></entry>
	      <entry>Von der Architektur abhängiger Verzeichnisbaum,
		der durch das Bauen von <filename>/usr/src</filename>
		entsteht.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/ports/</filename></entry>
	      <entry>Die FreeBSD-Ports-Sammlung (optional).</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/sbin/</filename></entry>
	      <entry>System-Dämonen und System-Werkzeuge, die von
		Benutzern ausgeführt werden.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/share/</filename></entry>
	      <entry>Von der Architektur unabhängige Dateien.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/src/</filename></entry>
	      <entry>Quelldateien von BSD und/oder lokalen
		Ergänzungen.</entry>
	    </row>

	    <row>
	      <entry><filename
	      class="directory">/usr/X11R6/</filename></entry>
	      <entry>Optionale X11R6-Programme und Bibliotheken.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/var/</filename></entry>
	      <entry>Wird für mehrere Zwecke genutzt und enthält
		Logdateien, temporäre Daten und Spooldateien.
		Manchmal wird ein speicherbasiertes Dateisystem unter
		<filename class="directory">/var</filename>
		eingehängt.  Dieser Vorgang kann automatisiert werden,
		wenn Sie die varmfs-bezogenen Variablen von
		&man.rc.conf.5; verwenden.  Alternativ können Sie
		auch einen entsprechenden Eintrag in
		<filename>/etc/fstab</filename> aufnehmen.  Weitere
		Informationen finden Sie in &man.mdmfs.8;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/var/log/</filename></entry>
	      <entry>Verschiedene Logdateien des Systems.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/var/mail/</filename></entry>
	      <entry>Postfächer der Benutzer.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/var/spool/</filename></entry>
	      <entry>Verschiedene Spool-Verzeichnisse der Drucker- und
		Mailsysteme.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/var/tmp/</filename></entry>
	      <entry>Temporäre Dateien.  Dateien in diesem
	        Verzeichnis bleiben in der Regel auch bei einem Neustart
	        des Systems erhalten, es sei denn, bei
	        <filename class="directory">/var</filename> handelt es
	        sich um ein speicherbasiertes Dateisystem.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/var/yp/</filename></entry>
	      <entry>NIS maps.</entry>
	    </row>

	  </tbody>
	</tgroup>
      </informaltable>
    </para>
  </sect1>

  <sect1 id="disk-organization">
      <title>Festplatten, Slices und Partitionen</title>

      <para>&os; identifiziert Dateien anhand eines Dateinamens.
	In Dateinamen wird zwischen Groß- und Kleinschreibung
	unterschieden:  <filename>readme.txt</filename> und
	<filename>README.TXT</filename> bezeichnen daher zwei
	verschiedene Dateien.  &os; benutzt keine Dateiendungen wie
	<filename>.txt</filename>, um den Typ der Datei
	(ein Programm, ein Dokument oder andere Daten) zu
	bestimmen.</para>

      <para>Dateien werden in Verzeichnissen gespeichert.  In einem
	Verzeichnis können sich keine oder hunderte Dateien
	befinden.  Ein Verzeichnis kann auch andere Verzeichnisse
	enthalten und so eine Hierarchie von Verzeichnissen aufbauen,
	die Ihnen die Ablage von Daten erleichtert.</para>

      <para>In Dateinamen werden Verzeichnisse durch einen
	Schrägstrich (<literal>/</literal>,
	<foreignphrase>Slash</foreignphrase>) getrennt.  Wenn
	das Verzeichnis <filename class="directory">foo</filename>
	ein Verzeichnis <filename class="directory">bar</filename>
	enthält, in dem sich die Datei <filename>readme.txt</filename>
	befindet, lautet der vollständige Name der Datei
	(oder der <firstterm>Pfad</firstterm> zur Datei)
	<filename>foo/bar/readme.txt</filename>.</para>

      <para>Verzeichnisse und Dateien werden in einem Dateisystem
	gespeichert.  Jedes Dateisystem besitzt ein
	<firstterm>Wurzelverzeichnis</firstterm>
	(<foreignphrase>Root-Directory</foreignphrase>),
	das weitere Verzeichnisse enthalten kann.</para>

      <para>Dieses Konzept kennen Sie vielleicht von anderen
	Betriebssystemen, aber es gibt einige Unterschiede:
	In &ms-dos; werden Datei- und Verzeichnisnamen mit dem
	Zeichen <literal>\</literal> getrennt, &macos; benutzt
	dazu das Zeichen <literal>:</literal>.</para>

      <para>&os; kennt keine Laufwerksbuchstaben und in Pfaden
	werden keine Bezeichnungen für Laufwerke benutzt.
	Die Pfadangabe <filename>c:/foo/bar/readme.txt</filename>
	gibt es in &os; nicht.</para>

      <para>Stattdessen wird ein Dateisystem als Wurzeldateisystem
	(<foreignphrase>root file system</foreignphrase>)
	ausgewählt.  Das Wurzelverzeichnis dieses Dateisystems
	wird <filename class="directory">/</filename> genannt.
	Jedes andere Dateisystem wird unter dem Wurzeldateisystem
	<firstterm>eingehangen</firstterm>
	(<foreignphrase>mount</foreignphrase>).  Daher scheint
	jedes Verzeichnis, unabhängig von der Anzahl der
	Platten, auf derselben Platte zu liegen.</para>

      <para>Betrachten wir drei Dateisysteme <literal>A</literal>,
	<literal>B</literal> und <literal>C</literal>.  Jedes
	Dateisystem besitzt ein eigenes Wurzelverzeichnis, das
	zwei andere Verzeichnisse enthält:
	<filename class="directory">A1</filename>,
	<filename class="directory">A2</filename>,
	<filename class="directory">B1</filename>,
	<filename class="directory">B2</filename>,
	<filename class="directory">C1</filename> und
	<filename class="directory">C2</filename>.</para>

      <para>Das Wurzeldateisystem soll <literal>A</literal> sein.
	Das Kommando <command>ls</command> zeigt darin
	die beiden Verzeichnisse <filename class="directory">A1</filename>
	und <filename class="directory">A2</filename> an.
	Der Verzeichnisbaum sieht wie folgt aus:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir1"/>
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2</literallayout>
	</textobject>
      </mediaobject>

      <para>Ein Dateisystem wird in einem Verzeichnis eines anderen
	Dateisystems eingehangen.  Wir hängen nun das Dateisystem
	<literal>B</literal> in das Verzeichnis
	<filename class="directory">A1</filename> ein.  Das
	Wurzelverzeichnis von <literal>B</literal> ersetzt nun
	das Verzeichnis <filename class="directory">A1</filename> und
	die Verzeichnisse des Dateisystems <literal>B</literal>
	werden sichtbar:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir2"/>
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |     |
 |     +--- B1
 |     |
 |     `--- B2
 |
 `--- A2</literallayout>
	</textobject>
      </mediaobject>

      <para>Jede Datei in den Verzeichnissen
	<filename class="directory">B1</filename> oder
	<filename class="directory">B2</filename> kann
	über den Pfad <filename class="directory">/A1/B1</filename>
	oder <filename class="directory">/A1/B2</filename>
	erreicht werden.  Dateien aus dem Verzeichnis
	<filename class="directory">/A1</filename> sind jetzt
	verborgen.  Wenn das Dateisystem <literal>B</literal>
	wieder <firstterm>abgehangen</firstterm> wird
	(<foreignphrase>umount</foreignphrase>), erscheinen
	die verborgenen Dateien wieder.</para>

      <para>Wenn das Dateisystem <literal>B</literal> unter dem
	Verzeichnis <filename class="directory">A2</filename>
	eingehangen würde, sähe der Verzeichnisbaum
	so aus:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir3"/>
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2
       |
       +--- B1
       |
       `--- B2</literallayout>
	</textobject>
      </mediaobject>

      <para>Die Dateien des Dateisystems <literal>B</literal> wären
	unter den Pfaden <filename class="directory">/A2/B1</filename> und
	<filename class="directory">/A2/B2</filename> erreichbar.</para>

      <para>Dateisysteme können übereinander eingehangen
	werden.  Der folgende Baum entsteht, wenn im letzten
	Beispiel das Dateisystem <literal>C</literal> in das Verzeichnis
	<filename class="directory">B1</filename> des Dateisystems
	<literal>B</literal> eingehangen wird:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir4"/>
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2
       |
       +--- B1
       |     |
       |     +--- C1
       |     |
       |     `--- C2
       |
       `--- B2</literallayout>
	</textobject>
      </mediaobject>

      <para><literal>C</literal> könnte auch im Verzeichnis
	<filename class="directory">A1</filename> eingehangen
	werden:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir5"/>
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |     |
 |     +--- C1
 |     |
 |     `--- C2
 |
 `--- A2
       |
       +--- B1
       |
       `--- B2</literallayout>
	</textobject>
      </mediaobject>

      <para>Der &ms-dos;-Befehl <command>join</command> kann Ähnliches
	bewirken.</para>

      <para>Normalerweise müssen Sie sich nicht mit Dateisystemen
	beschäftigen.  Während der Installation werden
	die Dateisysteme und die Stellen, in der sie eingehangen werden,
	festgelegt.  Dateisysteme müssen Sie erst wieder anlegen,
	wenn Sie eine neue Platte hinzufügen.</para>

      <para>Sie können sogar mit nur einem großen
	Dateisystem auskommen.  Dies hat mehrere Nachteile
	und einen Vorteil.</para>

      <itemizedlist>
	<title>Vorteile mehrerer Dateisysteme</title>

	<listitem>
	  <para>Die Dateisysteme können mit unterschiedlichen
	    Optionen (<foreignphrase>mount options</foreignphrase>)
	    eingehangen werden.  Bei sorgfältiger Planung können
	    Sie beispielsweise das Wurzeldateisystem nur lesbar
	    einhängen.  Damit schützen Sie sich vor dem
	    unabsichtlichen Löschen oder Editieren kritischer
	    Dateien.  Von Benutzern beschreibbare Dateisysteme
	    wie <filename class="directory">/home</filename>
	    können Sie mit der Option <firstterm>nosuid</firstterm>
	    einhängen, wenn sie von anderen Dateisystemen getrennt
	    sind.  Die <firstterm>SUID</firstterm>- und
	    <firstterm>GUID</firstterm>-Bits verlieren auf solchen
	    Dateisystemen ihre Wirkung und die Sicherheit des
	    Systems kann dadurch erhöht werden.</para>
	</listitem>

	<listitem>
	  <para>Die Lage von Dateien im Dateisystem wird, abhängig
	    vom Gebrauch des Dateisystems, automatisch von &os;
	    optimiert.  Ein Dateisystem mit vielen kleinen Dateien,
	    die häufig geschrieben werden, wird anders behandelt
	    als ein Dateisystem mit wenigen großen Dateien.
	    Mit nur einem Dateisystem ist diese Optimierung
	    unmöglich.</para>
	</listitem>

	<listitem>
	  <para>In der Regel übersteht ein &os;-Dateisystem auch
	    einen Stromausfall.  Allerdings kann ein Stromausfall zu
	    einem kritischen Zeitpunkt das Dateisystem beschädigen.
	    Wenn die Daten über mehrere Dateisysteme verteilt
	    sind, lässt sich das System mit hoher
	    Wahrscheinlichkeit noch starten.  Dies erleichtert
	    das Zurückspielen von Datensicherungen.</para>
	</listitem>
      </itemizedlist>

      <itemizedlist>
	<title>Vorteil eines einzelnen Dateisystems</title>

	<listitem>
	  <para>Die Größe von Dateisystemen liegt fest.
	    Es kann passieren, dass Sie eine Partition
	    vergrößern müssen.  Dies ist nicht leicht:
	    Sie müssen die Daten sichern, das Dateisystem
	    vergrößert anlegen und die gesicherten
	    Daten zurückspielen.</para>

	  <important>
	    <para>&os; kennt den Befehl &man.growfs.8;, mit dem man
	      Dateisysteme im laufenden Betrieb
	      vergrößern kann.</para>
	  </important>
	</listitem>
      </itemizedlist>

      <para>Dateisysteme befinden sich in Partitionen (damit sind
	nicht die normalen &ms-dos;-Partitionen gemeint).  Jede Partition
	wird mit einem Buchstaben von <literal>a</literal> bis
	<literal>h</literal> bezeichnet und kann nur ein Dateisystem
	enthalten.  Dateisysteme können daher über ihren
	Mount-Point, den Punkt an dem sie eingehangen sind, oder
	den Buchstaben der Partition, in der sie liegen, identifiziert
	werden.</para>

      <para>&os; benutzt einen Teil der Platte für den
	<firstterm>Swap-Bereich</firstterm>, der dem Rechner
	<firstterm>virtuellen Speicher</firstterm> zur Verfügung
	stellt.  Dadurch kann der Rechner Anwendungen mehr Speicher
	zur Verfügung stellen als tatsächlich eingebaut
	ist.  Wenn der Speicher knapp wird, kann &os; nicht benutzte
	Daten in den Swap-Bereich auslagern.  Die ausgelagerten
	Daten können später wieder in den Speicher
	geholt werden (dafür werden dann andere Daten
	ausgelagert).</para>

      <para>Für einige Partitionen gelten besondere
        Konventionen:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <colspec colwidth="1*"/>
	  <colspec colwidth="5*"/>

	  <thead>
	    <row>
	      <entry>Partition</entry>

	      <entry>Konvention</entry>
	    </row>
	  </thead>

	  <tbody valign="top">
	    <row>
	      <entry><literal>a</literal></entry>

	      <entry>Enthält normalerweise
		das Wurzeldateisystem</entry>
	    </row>

	    <row>
	      <entry><literal>b</literal></entry>

	      <entry>Enthält normalerweise
		den Swap-Bereich</entry>
	    </row>

	    <row>
	      <entry><literal>c</literal></entry>

	      <entry>Ist normalerweise genauso groß wie
		die Slice in der die Partition liegt.  Werkzeuge,
		die auf der kompletten Slice arbeiten, wie ein
		Bad-Block-Scanner, können so die
		<literal>c</literal>-Partition benutzen.
		Für gewöhnlich legen Sie in dieser
		Partition kein Dateisystem an.</entry>
	    </row>

	    <row>
	      <entry><literal>d</literal></entry>

	      <entry>Früher hatte die <literal>d</literal>-Partition
		eine besondere Bedeutung.  Heute ist dies nicht mehr der
		Fall und die Partition <literal>d</literal> kann wie
		jede andere Partition auch verwendet werden.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>Jede Partition, die ein Dateisystem enthält,
	wird in einer <firstterm>Slice</firstterm> angelegt.
	Slice ist der Begriff, den &os; für &ms-dos;-Partitionen
	verwendet.  Slices werden von eins bis vier durchnummeriert.</para>

      <indexterm><primary>Slices</primary></indexterm>
      <indexterm><primary>Partitionen</primary></indexterm>
      <indexterm><primary>dangerously dedicated</primary></indexterm>

      <para>Die Slice-Nummern werden mit vorgestelltem
	<literal>s</literal> hinter den Gerätenamen gestellt:
	<quote>da0<emphasis>s1</emphasis></quote>
	ist die erste Slice auf dem ersten SCSI-Laufwerk.  Auf einer
	Festplatte gibt es höchstens vier Slices.  In einer
	Slice des passenden Typs kann es weitere logische Slices
	geben.  Diese erweiterten Slices werden ab fünf durchnummeriert:
	<quote>ad0<emphasis>s5</emphasis></quote> ist
	die erste erweiterte Slice auf einer IDE-Platte.  Diese
	Geräte werden von Dateisystemen benutzt, die sich in
	einer kompletten Slice befinden müssen.</para>

      <para>Slices, <quote>dangerously dedicated</quote>-Festplatten
	und andere Platten enthalten Partitionen, die mit Buchstaben
	von <literal>a</literal> bis <literal>h</literal> bezeichnet
	werden.  Der Buchstabe wird an den Gerätenamen
	gehangen: <quote>da0<emphasis>a</emphasis></quote>
	ist die <literal>a</literal>-Partition des ersten
	<literal>da</literal>-Laufwerks.  Dieses Laufwerk ist
	<quote>dangerously dedicated</quote>.
	<quote>ad1s3<emphasis>e</emphasis></quote> ist
	die fünfte Partition in der dritten Slice der zweiten
	IDE-Platte.</para>

      <para>Schließlich wird noch jede Festplatte des Systems
	eindeutig bezeichnet.  Der Name einer Festplatte beginnt mit
	einem Code, der den Typ der Platte bezeichnet.  Es folgt eine
	Nummer, die angibt, um welche Festplatte es sich handelt.
	Anders als bei Slices werden Festplatten von Null beginnend
	durchnummeriert.  Gängige Festplatten-Namen sind in
	<xref linkend="basics-dev-codes"/> zusammengestellt.</para>

      <para>Wenn Sie eine Partition angeben, erwartet &os;, dass Sie
        auch die Slice und die Platte angeben, in denen sich die
	Partition befindet.  Wenn Sie eine Slice angeben, müssen
	Sie auch die Platte der Slice angeben.  Setzen Sie den Namen
	aus dem Plattennamen gefolgt von einem <literal>s</literal>,
	der Slice-Nummer und dem Buchstaben der Partition zusammen.
	Einige Beispiele finden Sie in
	<xref linkend="basics-disk-slice-part"/>.</para>

      <para>Der Aufbau einer Festplatte wird in
	<xref linkend="basics-concept-disk-model"/> dargestellt.</para>

      <para>Um &os; zu installieren, müssen Sie zuerst Slices
	auf den Festplatten anlegen.  Innerhalb der Slices, die Sie
	für &os; verwenden wollen, müssen Sie dann
	Partitionen anlegen.  In den Partitionen wiederum werden
	die Dateisysteme (oder der Auslagerungsbereich) angelegt.
	Für Dateisysteme müssen Sie schließlich
	noch festlegen, wo diese eingehangen werden (Mount-Point).</para>

      <table frame="none" pgwide="1" id="basics-dev-codes">
	<title>Laufwerk-Codes</title>

	<tgroup cols="2">
          <colspec colwidth="1*"/>
          <colspec colwidth="5*"/>

	  <thead>
	    <row>
	      <entry>Code</entry>

	      <entry>Bedeutung</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><devicename>ad</devicename></entry>

	      <entry>ATAPI (IDE) Festplatte</entry>
	    </row>

	    <row>
	      <entry><devicename>da</devicename></entry>

	      <entry>SCSI-Festplatte</entry>
	    </row>

	    <row>
	      <entry><devicename>acd</devicename></entry>

	      <entry>ATAPI (IDE) CD-ROM</entry>
	    </row>

	    <row>
	      <entry><devicename>cd</devicename></entry>

	      <entry>SCSI-CD-ROM</entry>
	    </row>

	    <row>
	      <entry><devicename>fd</devicename></entry>

	      <entry>Disketten-Laufwerk</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <example id="basics-disk-slice-part">
	<title>Namen von Platten, Slices und Partitionen</title>

	<informaltable frame="none" pgwide="1">
	  <tgroup cols="2">
            <colspec colwidth="1*"/>
            <colspec colwidth="5*"/>

	    <thead>
	      <row>
		<entry>Name</entry>

		<entry>Bedeutung</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><devicename>ad0s1a</devicename></entry>

		<entry>Die erste Partition (<literal>a</literal>)
		  in der ersten Slice (<literal>s1</literal>) der
		  ersten IDE-Festplatte (<literal>ad0</literal>).</entry>
	      </row>

	      <row>
		<entry><devicename>da1s2e</devicename></entry>

		<entry>Die fünfte Partition (<literal>e</literal>)
		  der zweiten Slice (<literal>s2</literal>) auf
		  der zweiten SCSI-Festplatte
		  (<literal>da1</literal>).</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </example>

      <example id="basics-concept-disk-model">
	<title>Aufteilung einer Festplatte</title>

	<para>Das folgende Diagramm zeigt die Sicht von &os; auf die
	  erste IDE-Festplatte eines Rechners.  Die Platte soll
	  4&nbsp;GB groß sein und zwei Slices (&ms-dos;-Partitionen)
	  mit je 2&nbsp;GB besitzen.  Die erste Slice enthält
	  ein &ms-dos;-Laufwerk (<devicename>C:</devicename>), die zweite
	  Slice wird von &os; benutzt.  Im Beispiel verwendet die
	  &os;-Installationen drei Datenpartitionen und einen
	  Auslagerungsbereich.</para>

	<para>Jede der drei Partitionen enthält ein Dateisystem.
	  Das Wurzeldateisystem ist die <literal>a</literal>-Partition.
	  In der <literal>e</literal>-Partition befindet sich
	  der <filename class="directory">/var</filename>-Verzeichnisbaum
	  und in der <literal>f</literal>-Partition befindet sich
	  der Verzeichnisbaum unterhalb von
	  <filename class="directory">/usr</filename>.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="install/disk-layout"/>
          </imageobject>

          <textobject>
	    <literallayout class="monospaced">.-----------------.  --.
|                 |    |
|  DOS / Windows  |    |
:                 :     &gt;  First slice, ad0s1
:                 :    |
|                 |    |
:=================:  ==:                               --.
|                 |    |  Partition a, mounted as /      |
|                 |     &gt; referred to as ad0s2a          |
|                 |    |                                 |
:-----------------:  ==:                                 |
|                 |    |  Partition b, used as swap      |
|                 |     &gt; referred to as ad0s2b          |
|                 |    |                                 |
:-----------------:  ==:                                 |  Partition c, no
|                 |    |  Partition e, used as /var       &gt; file system, all
|                 |     &gt; referred to as ad0s2e          |  of FreeBSD slice,
|                 |    |                                 |  ad0s2c
:-----------------:  ==:                                 |
|                 |    |                                 |
:                 :    |  Partition f, used as /usr      |
:                 :     &gt; referred to as ad0s2f          |
:                 :    |                                 |
|                 |    |                                 |
|                 |  --'                                 |
`-----------------'                                    --'</literallayout>
          </textobject>
        </mediaobject>
      </example>
  </sect1>

  <sect1 id="mount-unmount">
    <title>Anhängen und Abhängen von Dateisystemen</title>

    <para>Ein Dateisystem wird am besten als ein Baum mit der
      Wurzel <filename>/</filename> veranschaulicht.
      <filename>/dev</filename>, <filename>/usr</filename>, und
      die anderen Verzeichnisse im Rootverzeichnis sind Zweige,
      die wiederum eigene Zweige wie <filename>/usr/local</filename>
      haben können.</para>

    <indexterm><primary>Root-Dateisystem</primary></indexterm>
    <para>Es gibt verschiedene Gründe, bestimmte dieser Verzeichnisse
      auf eigenen Dateisystemen anzulegen.  <filename>/var</filename>
      enthält <filename>log/</filename>, <filename>spool/</filename>
      sowie verschiedene andere temporäre
      Dateien und kann sich daher schnell füllen.  Es empfiehlt sich,
      <filename>/var</filename> von <filename>/</filename> zu trennen,
      da es schlecht ist, wenn das Root-Dateisystem voll
      läuft.</para>

    <para>Ein weiterer Grund bestimmte Verzeichnisbäume auf
      andere Dateisysteme zu legen, ist gegeben, wenn sich die
      Verzeichnisbäume auf gesonderten physikalischen oder
      virtuellen Platten, wie
      <link linkend="network-nfs">Network File System</link>
      oder CD-ROM-Laufwerken, befinden.</para>

    <sect2 id="disks-fstab">
      <title>Die <filename>fstab</filename> Datei</title>

      <indexterm>
	 <primary>Dateisysteme</primary>
	 <secondary>fstab</secondary>
      </indexterm>
      <para>Während des <link linkend="boot">Boot-Prozesses</link>
	werden in <filename>/etc/fstab</filename> aufgeführte
	Verzeichnisse, sofern sie nicht mit der Option <option>noauto</option>
	versehen sind, automatisch angehangen.</para>

      <para>Die Zeilen in <filename>/etc/fstab</filename> haben das
	folgende Format:</para>

      <programlisting><replaceable>device</replaceable>	<replaceable>/mount-point</replaceable>	<replaceable>fstype</replaceable>	<replaceable>options</replaceable>	<replaceable>dumpfreq</replaceable>	<replaceable>passno</replaceable></programlisting>

      <variablelist>
	<varlistentry>
	  <term><literal>device</literal></term>

	  <listitem>
            <para>Ein existierender Gerätename
	      wie in <xref linkend="disks-naming"/> beschrieben.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>mount-point</literal></term>

	  <listitem>
            <para>Ein existierendes Verzeichnis,
	      an das das Dateisystem angehangen wird.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>fstype</literal></term>

	  <listitem>
            <para>Der Typ des Dateisystems,
	      der an &man.mount.8; weitergegeben wird.  FreeBSDs
	      Standarddateisystem ist <literal>ufs</literal>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>options</literal></term>

	  <listitem>
	    <para>Entweder <option>rw</option>
	      für beschreibbare Dateisysteme oder <option>ro</option>
	      für schreibgeschützte Dateisysteme, gefolgt von
	      weiteren benötigten Optionen.  Eine häufig verwendete
	      Option ist <option>noauto</option> für Dateisysteme,
	      die während der normalen Bootsequenz nicht angehangen
	      werden sollen.  Weitere Optionen finden sich
	      in &man.mount.8;.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>dumpfreq</literal></term>

	  <listitem><para>Gibt die Anzahl der Tage an, nachdem das
	      Dateisystem gesichert werden soll.  Fehlt der Wert, wird
	      <literal>0</literal> angenommen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>passno</literal></term>

	  <listitem><para>Bestimmt die Reihenfolge, in der die Dateisysteme
	      überprüft werden sollen.  Für Dateisysteme,
	      die übersprungen werden sollen, ist
	      <literal>passno</literal> auf null zu setzen.  Für das
	      Root-Dateisystem, das vor allen anderen überprüft
	      werden muss, sollte der Wert von
	      <literal>passno</literal> eins betragen.  Allen anderen
	      Dateisystemen sollten Werte größer eins zugewiesen
	      werden.  Wenn mehrere Dateisysteme den gleichen Wert
	      besitzen, wird &man.fsck.8; versuchen, diese parallel zu
	      überprüfen.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 id="disks-mount">
      <title>Das <command>mount</command> Kommando</title>
      <indexterm>
	<primary>Dateisysteme</primary>
	<secondary>anhängen</secondary>
      </indexterm>

      <para>&man.mount.8; hängt schließlich Dateisysteme
	an.</para>

      <para>In der grundlegenden Form wird es wie folgt benutzt:</para>

      <informalexample>
	<screen>&prompt.root; <userinput>mount <replaceable>device</replaceable> <replaceable>mountpoint</replaceable></userinput></screen>
      </informalexample>

      <para>Viele Optionen werden in &man.mount.8; beschrieben,
	die am häufigsten verwendeten sind:</para>

      <variablelist>
	<title>Optionen von <command>mount</command></title>

	<varlistentry>
	  <term><option>-a</option></term>

	  <listitem>
            <para>Hängt alle Dateisysteme aus
	      <filename>/etc/fstab</filename> an.  Davon ausgenommen
	      sind Dateisysteme, die mit <quote>noauto</quote> markiert
	      sind, die mit der Option <option>-t</option> ausgeschlossen
	      wurden und Dateisysteme, die schon angehangen sind.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-d</option></term>

	  <listitem>
            <para>Führt alles bis auf den
	      <function>mount</function>-Systemaufruf aus.
	      Nützlich ist diese Option in Verbindung
	      mit <option>-v</option>.  Damit wird angezeigt, was
	      &man.mount.8; tatsächlich versuchen
	      würde, um das Dateisystem anzuhängen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-f</option></term>

	  <listitem>
	    <para>Erzwingt das Anhängen eines unsauberen Dateisystems
	      oder erzwingt die Rücknahme des Schreibzugriffs, wenn
	      der Status des Dateisystems von beschreibbar auf
	      schreibgeschützt geändert wird.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-r</option></term>

	  <listitem>
	    <para>Hängt das Dateisystem schreibgeschützt ein.  Das
	      kann auch durch Angabe von <option>ro</option> als Argument
	      der Option <option>-o</option> erreicht werden.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-t</option>
	    <replaceable>fstype</replaceable></term>

	  <listitem>
            <para>Hängt das Dateisystem mit dem angegebenen Typ an,
	      oder hängt nur Dateisysteme mit dem angegebenen Typ
	      an, wenn auch <option>-a</option> angegeben
	      wurde.</para>

            <para>Die Voreinstellung für den Typ des Dateisystems
	      ist <quote>ufs</quote>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-u</option></term>

	  <listitem>
	    <para>Aktualisiert die Mountoptionen des Dateisystems.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-v</option></term>

	  <listitem>
	    <para>Geschwätzig sein.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-w</option></term>

	  <listitem>
	    <para>Hängt das Dateisystem beschreibbar an.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para><option>-o</option> erwartet eine durch Kommata separierte Liste
	von Optionen, unter anderem die folgenden:</para>

      <variablelist>
	<varlistentry>
	  <term>noexec</term>

	  <listitem>
	    <para>Verbietet das Ausführen von binären
	      Dateien auf dem Dateisystem.  Dies ist eine
	      nützliche Sicherheitsfunktion.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>nosuid</term>

	  <listitem>
	    <para>SetUID und SetGID Bits werden auf dem Dateisystem
	      nicht beachtet.  Dies ist eine nützliche
	      Sicherheitsfunktion.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 id="disks-umount">
      <title>Das <command>umount</command> Kommando</title>
      <indexterm>
	<primary>Dateisysteme</primary>
	<secondary>abhängen</secondary>
      </indexterm>

      <para>&man.umount.8; akzeptiert als Parameter entweder
	einen Mountpoint, einen Gerätenamen, oder die
	Optionen <option>-a</option> oder <option>-A</option>.</para>

      <para>Jede Form akzeptiert <option>-f</option>, um das
	Abhängen zu erzwingen, und <option>-v</option>, um
	etwas geschwätziger zu sein.  Seien Sie bitte vorsichtig mit
	<option>-f</option>: Ihr Computer kann abstürzen oder es
	können Daten auf dem Dateisystem beschädigt werden, wenn
	Sie das Abhängen erzwingen.</para>

      <para><option>-a</option> und <option>-A</option> werden benutzt
	um alle Dateisysteme, deren Typ durch <option>-t</option>
	modifiziert werden kann, abzuhängen.  <option>-A</option>
	hängt das Rootdateisystem nicht ab.</para>
    </sect2>
  </sect1>

  <sect1 id="basics-processes">
    <title>Prozesse</title>

    <para>Da FreeBSD ein Multitasking-Betriebssystem ist, sieht es so aus,
      als ob mehrere Prozesse zur gleichen Zeit laufen.  Jedes Programm,
      das zu irgendeiner Zeit läuft, wird
      <firstterm>Prozess</firstterm> genannt.  Jedes Kommando
      startet mindestens einen Prozess.  Einige Systemprozesse
      laufen ständig und stellen die Funktion des Systems sicher.</para>

    <para>Jeder Prozess wird durch eine eindeutige Nummer identifiziert,
      die <firstterm>Prozess-ID</firstterm> oder
      <firstterm>PID</firstterm> genannt wird.  Prozesse haben ebenso
      wie Dateien einen Besitzer und eine Gruppe, die festlegen, welche
      Dateien und Geräte der Prozess benutzen kann.  Dabei
      finden die vorher beschriebenen Zugriffsrechte Anwendung.  Die meisten
      Prozesse haben auch einen Elternprozess, der sie gestartet hat.
      Wenn Sie in der Shell Kommandos eingeben, dann ist die Shell ein
      Prozess und jedes Kommando, das Sie starten, ist auch ein
      Prozess.  Jeder Prozess, den Sie auf diese Weise starten,
      besitzt den Shell-Prozess als Elternprozess.  Die Ausnahme
      hiervon ist ein spezieller Prozess, der &man.init.8;
      heißt.  <command>init</command> ist immer der erste Prozess
      und hat somit die PID 1.  <command>init</command> wird vom Kernel
      beim Booten von FreeBSD gestartet.</para>

    <para>Die Kommandos &man.ps.1; und &man.top.1; sind besonders
      nützlich, um sich die Prozesse auf einem System anzusehen.
      <command>ps</command> zeigt eine statische Liste der laufenden
      Prozesse und kann deren PID, Speicherverbrauch und die
      Kommandozeile, mit der sie gestartet wurden und vieles mehr
      anzeigen.  <command>top</command> zeigt alle laufenden Prozesse
      an und aktualisiert die Anzeige, so dass Sie Ihrem Computer
      bei der Arbeit zuschauen können.</para>

    <para>Normal zeigt Ihnen <command>ps</command> nur die laufenden
      Prozesse, die Ihnen gehören.  Zum Beispiel:</para>

    <screen>&prompt.user; <userinput>ps</userinput>
  PID  TT  STAT      TIME COMMAND
  298  p0  Ss     0:01.10 tcsh
 7078  p0  S      2:40.88 xemacs mdoc.xsl (xemacs-21.1.14)
37393  p0  I      0:03.11 xemacs freebsd.dsl (xemacs-21.1.14)
48630  p0  S      2:50.89 /usr/local/lib/netscape-linux/navigator-linux-4.77.bi
48730  p0  IW     0:00.00 (dns helper) (navigator-linux-)
72210  p0  R+     0:00.00 ps
  390  p1  Is     0:01.14 tcsh
 7059  p2  Is+    1:36.18 /usr/local/bin/mutt -y
 6688  p3  IWs    0:00.00 tcsh
10735  p4  IWs    0:00.00 tcsh
20256  p5  IWs    0:00.00 tcsh
  262  v0  IWs    0:00.00 -tcsh (tcsh)
  270  v0  IW+    0:00.00 /bin/sh /usr/X11R6/bin/startx -- -bpp 16
  280  v0  IW+    0:00.00 xinit /home/nik/.xinitrc -- -bpp 16
  284  v0  IW     0:00.00 /bin/sh /home/nik/.xinitrc
  285  v0  S      0:38.45 /usr/X11R6/bin/sawfish</screen>

    <para>Wie Sie sehen, gibt &man.ps.1; mehrere Spalten aus.  In der
      <literal>PID</literal> Spalte findet sich die vorher besprochene
      Prozess-ID.  PIDs werden von 1 beginnend bis 99999 zugewiesen
      und fangen wieder von vorne an, wenn die Grenze überschritten
      wird.  Ist eine PID bereits vergeben, wird diese allerdings nicht
      erneut vergeben.
      Die Spalte <literal>TT</literal> zeigt den Terminal, auf dem das
      Programm läuft.  <literal>STAT</literal> zeigt den Status
      des Programms an und kann für die Zwecke dieser Diskussion ebenso
      wie <literal>TT</literal> ignoriert werden.  <literal>TIME</literal>
      gibt die Zeit an, die das Programm auf der CPU gelaufen ist &ndash;
      dies ist nicht unbedingt die Zeit, die seit dem Start des Programms
      vergangen ist, da die meisten Programme hauptsächlich auf
      bestimmte Dinge warten, bevor sie wirklich CPU-Zeit verbrauchen.
      Unter der Spalte <literal>COMMAND</literal> finden Sie schließlich
      die Kommandozeile, mit der das Programm gestartet wurde.</para>

    <para>&man.ps.1; besitzt viele Optionen, um die angezeigten Informationen
      zu beeinflussen.  Eine nützliche Kombination ist
      <literal>auxww</literal>.  Mit <option>a</option> werden Information
      über alle laufenden Prozesse und nicht nur Ihrer eigenen
      angezeigt.  Der Name des Besitzers des Prozesses, sowie Informationen
      über den Speicherverbrauch werden mit <option>u</option>
      angezeigt.  <option>x</option> zeigt auch Dämonen-Prozesse an,
      und <option>ww</option> veranlasst &man.ps.1; die komplette
      Kommandozeile für jeden Befehl anzuzeigen, anstatt sie
      abzuschneiden, wenn sie zu lang für die Bildschirmausgabe
      wird.</para>

    <para>Die Ausgabe von &man.top.1; sieht ähnlich aus:</para>

    <screen>&prompt.user; <userinput>top</userinput>
last pid: 72257;  load averages:  0.13,  0.09,  0.03    up 0+13:38:33  22:39:10
47 processes:  1 running, 46 sleeping
CPU states: 12.6% user,  0.0% nice,  7.8% system,  0.0% interrupt, 79.7% idle
Mem: 36M Active, 5256K Inact, 13M Wired, 6312K Cache, 15M Buf, 408K Free
Swap: 256M Total, 38M Used, 217M Free, 15% Inuse

  PID USERNAME PRI NICE  SIZE    RES STATE    TIME   WCPU    CPU COMMAND
72257 nik       28   0  1960K  1044K RUN      0:00 14.86%  1.42% top
 7078 nik        2   0 15280K 10960K select   2:54  0.88%  0.88% xemacs-21.1.14
  281 nik        2   0 18636K  7112K select   5:36  0.73%  0.73% XF86_SVGA
  296 nik        2   0  3240K  1644K select   0:12  0.05%  0.05% xterm
48630 nik        2   0 29816K  9148K select   3:18  0.00%  0.00% navigator-linu
  175 root       2   0   924K   252K select   1:41  0.00%  0.00% syslogd
 7059 nik        2   0  7260K  4644K poll     1:38  0.00%  0.00% mutt
...</screen>

    <para>Die Ausgabe ist in zwei Abschnitte geteilt.  In den ersten
      fünf Kopfzeilen finden sich die zuletzt zugeteilte PID, die
      Systemauslastung (engl. <foreignphrase>load average</foreignphrase>),
      die Systemlaufzeit (die Zeit seit dem letzten Reboot) und die
      momentane Zeit.  Die weiteren Zahlen im Kopf beschreiben wie viele
      Prozesse momentan laufen (im Beispiel 47), wie viel Speicher
      und Swap verbraucht wurde und wie viel Zeit das System in den
      verschiedenen CPU-Modi verbringt.</para>

    <para>Darunter befinden sich einige Spalten mit ähnlichen
      Informationen wie in der Ausgabe von &man.ps.1;.  Wie im vorigen
      Beispiel können Sie die PID, den Besitzer, die verbrauchte
      CPU-Zeit und das Kommando erkennen.  &man.top.1; zeigt auch den
      Speicherverbrauch des Prozesses an, der in zwei Spalten aufgeteilt
      ist.  Die erste Spalte gibt den gesamten Speicherverbrauch des
      Prozesses an, in der zweiten Spalte wird der aktuelle Verbrauch
      angegeben.  <application>&netscape;</application> hat im gezeigten
      Beispiel insgesamt 30&nbsp;MB Speicher verbraucht.  Momentan benutzt
      es allerdings nur 9&nbsp;MB.</para>

    <para>Die Anzeige wird von &man.top.1; automatisch alle zwei Sekunden
      aktualisiert.  Der Zeitraum kann mit <option>-s</option> eingestellt
      werden.</para>
  </sect1>

  <sect1 id="basics-daemons">
    <title>Dämonen, Signale und Stoppen von Prozessen</title>

    <para>Wenn Sie einen Editor starten, können Sie ihn leicht bedienen
      und Dateien laden.  Sie können das, weil der Editor dafür
      Vorsorge getroffen hat und auf einem <firstterm>Terminal</firstterm>
      läuft.  Manche Programme erwarten keine Eingaben von einem
      Benutzer und lösen sich bei erster Gelegenheit von ihrem
      Terminal.  Ein Web-Server zum Beispiel verbringt den ganzen Tag
      damit, auf Anfragen zu antworten und erwartet keine Eingaben von Ihnen.
      Programme, die E-Mail von einem Ort zu einem anderen Ort transportieren
      sind ein weiteres Beispiel für diesen Typ von Anwendungen.</para>

    <para>Wir nennen diese Programme <firstterm>Dämonen</firstterm>.
      Dämonen stammen aus der griechischen Mythologie und waren
      weder gut noch böse.  Sie waren kleine dienstbare Geister,
      die meistens nützliche Sachen für die Menschheit vollbrachten.
      Ähnlich wie heutzutage Web-Server und Mail-Server nützliche
      Dienste verrichten.  Seit langer Zeit ist daher das BSD Maskottchen
      dieser fröhlich aussehende Dämon mit Turnschuhen
      und Dreizack.</para>

    <para>Programme, die als Dämon laufen, werden entsprechend einer
      Konvention mit einem <quote>d</quote> am Ende benannt.
      <application>BIND</application> steht beispielsweise für
      Berkeley Internet Name Domain, das tatsächlich laufende Programm
      heißt aber
      <command>named</command>.  Der Apache Webserver wird
      <command>httpd</command> genannt, der Druckerspool-Dämon heißt
      <command>lpd</command> usw.  Dies ist allerdings eine Konvention
      und keine unumstößliche Regel: Der Dämon der
      Anwendung <application>sendmail</application> heißt
      <command>sendmail</command> und nicht <command>maild</command>, wie
      Sie vielleicht gedacht hatten.</para>

    <para>Manchmal müssen Sie mit einem Dämon kommunizieren.  Dazu
      verwenden Sie <firstterm>Signale</firstterm>.  Sie können
      mit einem Dämonen oder jedem anderen laufenden Prozess
      kommunizieren, indem Sie diesem ein Signal schicken.  Sie können
      verschiedene Signale verschicken &ndash; manche haben eine festgelegte
      Bedeutung, andere werden von der Anwendung interpretiert.  Die
      Dokumentation zur fraglichen Anwendung wird erklären, wie
      die Anwendung Signale interpretiert.  Sie können nur Signale
      zu Prozessen senden,  die Ihnen gehören.  Normale Benutzer haben
      nicht die Berechtigung, Prozessen anderer Benutzer mit &man.kill.1;
      oder &man.kill.2; Signale zu schicken.  Der Benutzer
      <username>root</username> darf jedem Prozess Signale schicken.</para>

    <para>In manchen Fällen wird FreeBSD Signale senden.  Wenn eine
      Anwendung schlecht geschrieben ist und auf Speicher zugreift, auf
      den sie nicht zugreifen soll, so sendet FreeBSD dem Prozess
      das <firstterm>Segmentation Violation</firstterm> Signal
      (<literal>SIGSEGV</literal>).  Wenn eine Anwendung den &man.alarm.3;
      Systemaufruf benutzt hat, um nach einiger Zeit benachrichtigt zu
      werden, bekommt sie das Alarm Signal (<literal>SIGALRM</literal>)
      gesendet.</para>

    <para>Zwei Signale können benutzt werden, um Prozesse zu stoppen:
      <literal>SIGTERM</literal> und <literal>SIGKILL</literal>.  Mit
      <literal>SIGTERM</literal> fordern Sie den Prozess höflich zum
      Beenden auf.  Der Prozess kann das Signal abfangen und merken,
      dass er sich beenden soll.  Er hat dann Gelegenheit Logdateien
      zu schließen und die Aktion, die er vor der Aufforderung
      sich zu beenden durchführte, abzuschließen.  Er kann
      sogar <literal>SIGTERM</literal> ignorieren, wenn er eine Aktion
      durchführt, die nicht unterbrochen werden darf.</para>

    <para><literal>SIGKILL</literal> kann von keinem Prozess ignoriert
      werden.  Das Signal lässt sich mit <quote>Mich interessiert
      nicht, was du gerade machst, hör sofort auf damit!</quote>
      umschreiben.  Wenn Sie einem Prozess <literal>SIGKILL</literal>
      schicken, dann wird FreeBSD diesen sofort beenden<footnote><para>
	Das stimmt nicht ganz: Es gibt Fälle, in denen ein Prozess
	nicht unterbrochen werden kann.  Wenn der Prozesss zum Beispiel
	eine Datei von einem anderen Rechner auf dem Netzwerk liest und dieser
	Rechner aus irgendwelchen Gründen nicht erreichbar ist
	(ausgeschaltet, oder ein Netzwerkfehler), dann ist der Prozess
	nicht zu unterbrechen.  Wenn der Prozess den Lesezugriff
	nach einem Timeout von typischerweise zwei Minuten aufgibt,
	dann wird er beendet.</para>
      </footnote>.</para>

    <para>Andere Signale, die Sie vielleicht verschicken wollen, sind
      <literal>SIGHUP</literal>, <literal>SIGUSR1</literal> und
      <literal>SIGUSR2</literal>.  Diese Signale sind für allgemeine
      Zwecke vorgesehen und verschiedene Anwendungen werden unterschiedlich
      auf diese Signale reagieren.</para>

    <para>Nehmen wir an, Sie haben die Konfiguration Ihres Webservers
      verändert und möchten dies dem Server mitteilen.  Sie
      könnten den Server natürlich stoppen und
      <command>httpd</command> wieder starten.  Die Folge wäre eine
      kurze Zeit, in der der Server nicht erreichbar ist.  Die meisten
      Dämonen lesen Ihre Konfigurationsdatei beim Empfang eines
      <literal>SIGHUP</literal> neu ein.  Da es keinen Standard gibt, der
      vorschreibt, wie auf diese Signale zu reagieren ist, lesen
      Sie bitte die Dokumentation zu dem in Frage kommenden Dämon.</para>

    <para>Mit &man.kill.1; können Sie, wie unten gezeigt, Signale
      verschicken.</para>

    <procedure>
      <title>Verschicken von Signalen</title>

      <para>Das folgende Beispiel zeigt, wie Sie &man.inetd.8; ein
	Signal schicken.  Die Konfigurationsdatei von
	<command>inetd</command> ist <filename>/etc/inetd.conf</filename>.
	Diese Konfigurationsdatei liest <command>inetd</command> ein,
	wenn er ein <literal>SIGHUP</literal> empfängt.</para>

      <step>
	<para>Suchen Sie die Prozess-ID des Prozesses, dem Sie ein Signal
	  schicken wollen.  Benutzen Sie dazu &man.ps.1; und &man.grep.1;.
	  Mit &man.grep.1; können Sie in einer Ausgabe nach einem
	  String suchen.  Da &man.inetd.8; unter dem Benutzer
	  <username>root</username> läuft und Sie das Kommando als
	  normaler Benutzer absetzen, müssen Sie &man.ps.1; mit
	  <option>ax</option> aufrufen:</para>

	<screen>&prompt.user; <userinput>ps -ax | grep inetd</userinput>
  198  ??  IWs    0:00.00 inetd -wW</screen>

	<para>Die Prozess-ID von &man.inetd.8; ist 198.  In einigen
	  Fällen werden Sie auch das <literal>grep inetd</literal>
	  Kommando in der Ausgabe sehen.  Dies hat damit zu tun, wie
	  &man.ps.1; die Liste der laufenden Prozesse untersucht.</para>
      </step>

      <step>
	<para>Senden Sie das Signal mit &man.kill.1;.  Da &man.inetd.8;
	  unter dem Benutzer <username>root</username> läuft, müssen
	  Sie zuerst mit &man.su.1; <username>root</username> werden:</para>

	<screen>&prompt.user; <userinput>su</userinput>
<prompt>Password:</prompt>
&prompt.root; <userinput>/bin/kill -s HUP 198</userinput></screen>

	<para>&man.kill.1; wird, wie andere Kommandos von &unix; Systemen auch, keine Ausgabe
	  erzeugen, wenn das Kommando erfolgreich war.  Wenn Sie versuchen,
	  einem Prozess, der nicht Ihnen gehört, ein Signal zu
	  senden, dann werden Sie die Meldung
	  <errorname>kill: <replaceable>PID</replaceable>: Operation not
	  permitted</errorname> sehen.  Wenn Sie sich bei der Eingabe der
	  PID vertippen, werden Sie das Signal dem falschen Prozess
	  schicken, was schlecht sein kann.  Wenn Sie Glück haben,
	  existiert der Prozess nicht und Sie werden mit der Ausgabe
	  <errorname>kill: <replaceable>PID</replaceable>: No such
	  process</errorname> belohnt.</para>

	<note>
	  <title>Warum soll ich <command>/bin/kill</command> benutzen?</title>

	  <para>Viele Shells stellen <command>kill</command> als internes
	    Kommando zur Verfügung, das heißt die Shell sendet
	    das Signal direkt, anstatt <filename>/bin/kill</filename>
	    zu starten.  Das kann nützlich sein, aber die
	    unterschiedlichen Shells benutzen eine verschiedene Syntax,
	    um die Namen der Signale anzugeben.  Anstatt jede Syntax zu
	    lernen, kann es einfacher sein, <command>/bin/kill
	    <replaceable>...</replaceable></command> direkt aufzurufen.</para>
	</note>
      </step>
    </procedure>

    <para>Andere Signale senden Sie auf die gleiche Weise, ersetzen
      Sie nur <literal>TERM</literal> oder <literal>KILL</literal>
      entsprechend.</para>

    <important>
      <para>Es kann gravierende Auswirkungen haben, wenn Sie zufällig
	Prozesse beenden.  Insbesondere &man.init.8; mit der Prozess-ID
	ist ein Spezialfall.  Mit <command>/bin/kill -s KILL 1</command>
	können Sie Ihr System schnell herunterfahren.
	Überprüfen Sie die Argumente von &man.kill.1;
	<emphasis>immer</emphasis> zweimal <emphasis>bevor</emphasis>
	Sie <keycap>Return</keycap> drücken.</para>
    </important>
  </sect1>

  <sect1 id="shells">
    <title>Shells</title>
    <indexterm><primary>Shells</primary></indexterm>
    <indexterm><primary>Kommandozeile</primary></indexterm>

    <para>Von der tagtäglichen Arbeit mit FreeBSD wird eine Menge
      mit der Kommandozeilen Schnittstelle der Shell erledigt.  Die
      Hauptaufgabe einer Shell besteht darin, Kommandos der Eingabe
      anzunehmen und diese auszuführen.  Viele Shells haben
      außerdem eingebaute Funktionen, die die tägliche
      Arbeit erleichtern, beispielsweise eine Dateiverwaltung,
      die Vervollständigung  von Dateinamen (Globbing), einen
      Kommandozeileneditor, sowie Makros und Umgebungsvariablen.  FreeBSD
      enthält die Shells <command>sh</command> (die Bourne Shell) und
      <command>tcsh</command> (die verbesserte C-Shell) im Basissystem.
      Viele andere Shells, wie <command>zsh</command> oder
      <command>bash</command>, befinden sich in der Ports-Sammlung.</para>

    <para>Welche Shell soll ich benutzen?  Das ist wirklich eine
      Geschmacksfrage.  Sind Sie ein C-Programmierer, finden Sie
      vielleicht eine C-artige Shell wie die <command>tcsh</command>
      angenehmer.  Kommen Sie von Linux oder ist Ihnen der Umgang mit &unix; Systemen
      neu, so könnten Sie die <command>bash</command> probieren.
      Der Punkt ist, dass
      jede Shell ihre speziellen Eigenschaften hat, die mit Ihrer
      bevorzugten Arbeitsumgebung harmonieren können oder nicht.
      Sie müssen sich eine Shell aussuchen.</para>

    <para>Ein verbreitetes Merkmal in Shells ist die
      Dateinamen-Vervollständigung.  Sie müssen nur einige
      Buchstaben eines Kommandos oder eines Dateinamen eingeben und
      die Shell vervollständigt den Rest automatisch durch
      drücken der <keycap>Tab</keycap>-Taste.  Hier ist ein Beispiel.
      Angenommen, Sie
      haben zwei Dateien <filename>foobar</filename> und
      <filename>foo.bar</filename>.  Die Datei
      <filename>foo.bar</filename> möchten Sie löschen.  Nun
      würden Sie an der Tastatur eingeben:
      <command>rm fo[<keycap>Tab</keycap>].
      [<keycap>Tab</keycap>]</command>.</para>

    <para>Die Shell würde dann <command>rm
      foo[BEEP].bar</command> ausgeben.</para>

    <para>[BEEP] meint den Rechner-Piepser.  Diesen gibt die Shell
      aus, um anzuzeigen, dass es den Dateinamen nicht
      vervollständigen konnte, da es mehrere Möglichkeiten
      gibt.  Beide Dateien <filename>foobar</filename> und
      <filename>foo.bar</filename> beginnen mit <literal>fo</literal>,
      so konnte nur bis <literal>foo</literal> ergänzt werden.
      Nachdem Sie <literal>.</literal> eingaben und dann die
      <keycap>Tab</keycap>-Taste
      drückten, konnte die Shell den Rest für Sie
      ausfüllen.</para>

    <indexterm><primary>Umgebungsvariablen</primary></indexterm>

    <para>Ein weiteres Merkmal der Shell ist der Gebrauch von
      Umgebungsvariablen.  Dies sind veränderbare Schlüsselpaare
      im Umgebungsraum der Shell, die jedes von der Shell aufgerufene
      Programm lesen kann.  Daher enthält der Umgebungsraum viele
      Konfigurationsdaten für Programme.  Die folgende Liste zeigt
      verbreitete Umgebungsvariablen und was sie bedeuten:</para>

    <indexterm><primary>Umgebungsvariablen</primary></indexterm>
    <informaltable frame="none" pgwide="1">
      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>Variable</entry>
	    <entry>Beschreibung</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry><envar>USER</envar></entry>
	    <entry>Name des angemeldeten Benutzers.</entry>
	  </row>

	  <row>
	    <entry><envar>PATH</envar></entry>
	    <entry>Liste mit Verzeichnissen (getrennt durch Doppelpunkt)
              zum Suchen nach Programmen.</entry>
	  </row>

	  <row>
	    <entry><envar>DISPLAY</envar></entry>
	    <entry>Der Name des X11-Bildschirms, auf dem
	      Ausgaben erfolgen sollen.</entry>
	  </row>

	  <row>
	    <entry><envar>SHELL</envar></entry>
	    <entry>Die aktuelle Shell.</entry>
	  </row>

	  <row>
	    <entry><envar>TERM</envar></entry>
	    <entry>Name des Terminaltyps des Benutzers.  Benutzt, um die
              Fähigkeiten des Terminals zu bestimmen.</entry>
	  </row>

	  <row>
	    <entry><envar>TERMCAP</envar></entry>
	    <entry>Datenbankeintrag der Terminal Escape Codes,
              benötigt um verschieden Terminalfunktionen
              auszuführen.</entry>
	  </row>

	  <row>
	    <entry><envar>OSTYPE</envar></entry>
	    <entry>Typ des Betriebsystems, beispielsweise FreeBSD.</entry>
	  </row>

	  <row>
	    <entry><envar>MACHTYPE</envar></entry>
	    <entry>Die CPU Architektur auf dem das System
              läuft.</entry>
	  </row>

	  <row>
	    <entry><envar>EDITOR</envar></entry>
	    <entry>Vom Benutzer bevorzugter Text-Editor.</entry>
	  </row>

	  <row>
	    <entry><envar>PAGER</envar></entry>
	    <entry>Vom Benutzer bevorzugter Text-Betrachter.</entry>
	  </row>

	  <row>
	    <entry><envar>MANPATH</envar></entry>
	    <entry>Liste mit Verzeichnissen (getrennt durch Doppelpunkt)
              zum Suchen nach Manualpages.</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <indexterm>
      <primary>Shells</primary>
      <secondary>Bourne Shell</secondary>
    </indexterm>
    <para>Das Setzen von Umgebungsvariablen funktioniert
      von Shell zu Shell unterschiedlich.  Zum Beispiel benutzt man
      in C-artigen Shells wie der <command>tcsh</command> dazu
      <command>setenv</command>.  Unter Bourne-Shells wie <command>sh</command>
      oder <command>bash</command> benutzen Sie zum Setzen von
      Umgebungsvariablen <command>export</command>.  Um
      beispielsweise die Variable <envar>EDITOR</envar> mit
      <command>csh</command> oder <command>tcsh</command> auf
      <filename>/usr/local/bin/emacs</filename> zu setzen, setzen Sie das
      folgende Kommando ab:</para>

    <screen>&prompt.user; <userinput>setenv EDITOR /usr/local/bin/emacs</userinput></screen>

    <para>Unter Bourne-Shells:</para>

    <screen>&prompt.user; <userinput>export EDITOR="/usr/local/bin/emacs"</userinput></screen>

    <para>Sie können die meisten Shells Umgebungsvariablen
      expandieren lassen, in dem Sie in der Kommandozeile ein
      <literal>$</literal> davor eingeben.  Zum Beispiel gibt
      <command>echo $TERM</command> aus, worauf <envar>$TERM</envar>
      gesetzt ist, weil die Shell <envar>$TERM</envar> expandiert
      und das Ergebnis an <command>echo</command> gibt.</para>

    <para>Shells behandeln viele Spezialzeichen, so genannte
      Metazeichen, als besondere Darstellungen für Daten.
      Das allgemeinste ist das Zeichen <literal>*</literal>, das eine
      beliebige Anzahl Zeichen in einem Dateinamen repräsentiert.
      Diese Metazeichen können zum Vervollständigen von
      Dateinamen (Globbing) benutzt werden.  Beispielsweise liefert
      das Kommando <command>echo *</command> nahezu das gleiche
      wie die Eingabe von <command>ls</command>, da die Shell alle
      Dateinamen die mit <literal>*</literal> übereinstimmen, an
      <command>echo</command> weitergibt.</para>

    <para>Um zu verhindern, dass die Shell diese Sonderzeichen
      interpretiert, kann man sie schützen, indem man ihnen einen
      Backslash (<literal>\</literal>) voranstellt.  <command>echo
      $TERM</command> gibt aus, auf was auch immer Ihr Terminal
      gesetzt ist.  <command>echo \$TERM</command> gibt
      <envar>$TERM</envar> genauso aus, wie es hier steht.</para>

    <sect2 id="changing-shells">
      <title>Ändern der Shell</title>

      <para>Der einfachste Weg Ihre Shell zu ändern, ist das
        Kommando <command>chsh</command> zu benutzen.
        <command>chsh</command> platziert Sie im Editor, welcher durch
        Ihre Umgebungsvariable <envar>EDITOR</envar> gesetzt ist,
        im <command>vi</command> wenn die Variable nicht gesetzt ist.
        Ändern Sie die Zeile mit <quote>Shell:</quote>
        entsprechend Ihren Wünschen.</para>

      <para>Sie können auch <command>chsh</command> mit der Option
	<option>-s</option> aufrufen, dann wird Ihre Shell gesetzt,
        ohne dass Sie in einen Editor gelangen.  Um Ihre Shell
        zum Beispiel auf die <command>bash</command> zu ändern,
	geben Sie das folgende Kommando ein:</para>

      <screen>&prompt.user; <userinput>chsh -s /usr/local/bin/bash</userinput></screen>

      <note>
	<para>Die von Ihnen gewünschte Shell
          <emphasis>muss</emphasis> in <filename>/etc/shells</filename>
          aufgeführt sein.  Haben Sie eine Shell aus der
	  <link linkend="ports">Ports-Sammlung</link> installiert,
          sollte das schon automatisch erledigt werden.  Installierten
          Sie die Shell von Hand, so müssen Sie sie dort
          eintragen.</para>

      <para>Haben Sie beispielsweise die <command>bash</command> nach
	<filename>/usr/local/bin</filename> installiert, geben Sie
	Folgendes ein:</para>

      <screen>&prompt.root; <userinput>echo &quot;/usr/local/bin/bash&quot; &gt;&gt; /etc/shells</userinput></screen>

       <para>Danach können Sie <command>chsh</command> aufrufen.</para>
     </note>
   </sect2>
  </sect1>

  <sect1 id="editors">
    <title>Text-Editoren</title>
    <indexterm><primary>Text Editoren</primary></indexterm>
    <indexterm><primary>Editoren</primary></indexterm>

    <para>Eine großer Teil der Konfiguration wird bei FreeBSD durch
      das Editieren von Textdateien erledigt.  Deshalb ist es eine
      gute Idee, mit einem Texteditor vertraut zu werden.  FreeBSD hat
      ein paar davon im Basissystem und sehr viel mehr in der
      Ports-Sammlung.</para>

    <indexterm>
      <primary><command>ee</command></primary>
    </indexterm>

    <indexterm>
      <primary>Text Editoren</primary>
      <secondary><command>ee</command></secondary>
    </indexterm>

    <para>Der am leichtesten und einfachsten zu erlernende Editor nennt
      sich <application>ee</application>, was für
      <foreignphrase>easy editor</foreignphrase> steht.
      Um <application>ee</application> zu starten, gibt man in der
      Kommandozeile <command>ee filename</command> ein, wobei
      <replaceable>filename</replaceable> den Namen der zu editierenden
      Datei darstellt.  Um zum Beispiel <filename>/etc/rc.conf</filename>
      zu editieren, tippen Sie <command>ee /etc/rc.conf</command> ein.
      Einmal im Editor, finden Sie alle Editor-Funktionen oben im
      Display aufgelistet.  Das Einschaltungszeichen
      <literal>^</literal> steht für die <keycap>Ctrl</keycap> (oder
      <keycap>Strg</keycap>) Taste, mit <literal>^e</literal> ist also die
      Tastenkombination <keycombo
        action="simul"><keycap>Ctrl</keycap><keycap>e</keycap></keycombo>
      gemeint.  Um <application>ee</application> zu verlassen, drücken
      Sie <keycap>Esc</keycap> und wählen dann <option>leave
        editor</option> aus.  Der Editor fragt nach, ob Sie speichern
      möchten, wenn die Datei verändert wurde.</para>

    <indexterm>
      <primary><command>vi</command></primary>
    </indexterm>
    <indexterm>
      <primary>Text Editoren</primary>
      <secondary><command>vi</command></secondary>
    </indexterm>
    <indexterm>
      <primary><command>emacs</command></primary>
    </indexterm>
    <indexterm>
      <primary>Text Editoren</primary>
      <secondary><command>emacs</command></secondary>
    </indexterm>
    <para>FreeBSD verfügt über leistungsfähigere
      Editoren wie <application>vi</application> als Teil des
      Basissystems, andere Editoren wie <application>emacs</application>
      oder <application>vim</application> sind Teil der Ports-Sammlung.
      Diese Editoren bieten höhere Funktionalität und
      Leistungsfähigkeit, jedoch auf Kosten einer etwas
      schwierigeren Erlernbarkeit.  Wenn Sie viele Textdateien
      editieren, sparen Sie auf lange Sicht mehr Zeit durch das Erlernen
      von Editoren wie <application>vim</application> oder
      <application>emacs</application> ein.</para>

    <para>Viele Anwendungen, die Dateien verändern oder Texteingabe
      erwarten, werden automatisch einen Texteditor öffnen.  Um den
      Standardeditor zu ändern, setzen Sie die Umgebungsvariable
      <envar>EDITOR</envar>.  Um mehr darüber zu erfahren, lesen Sie den
      Abschnitt <link linkend="shells">Shells</link>.</para>
  </sect1>

  <sect1 id="basics-devices">
    <title>Geräte und Gerätedateien</title>

    <para>Der Begriff Gerät wird meist in Verbindung mit Hardware
      wie Laufwerken, Druckern, Grafikkarten oder Tastaturen gebraucht.
      Der Großteil der Meldungen, die beim Booten von FreeBSD angezeigt
      werden, beziehen sich auf gefundene Geräte.  Sie können sich
      die Bootmeldungen später in <filename>/var/run/dmesg.boot</filename>
      ansehen.</para>

    <para>Gerätenamen, die Sie wahrscheinlich in den Bootmeldungen sehen
      werden, sind zum Beispiel <devicename>acd0</devicename>, das erste
      IDE CD-ROM oder <devicename>kbd0</devicename>, die Tastatur.</para>

    <para>Auf die meisten Geräte wird unter &unix; Systemen über spezielle
      Gerätedateien im <filename>/dev</filename> Verzeichnis
      zugegriffen.</para>

    <sect2>
      <title>Anlegen von Gerätedateien</title>
      <para>Wenn sie ein neues Gerät zu Ihrem System hinzufügen,
	oder die Unterstützung für zusätzliche Geräte
	kompilieren, müssen ein oder mehrere Gerätedateien
	erstellt werden.</para>

      <sect3>
	<title><literal>DEVFS</literal> (Gerätedateisystem)</title>

	<para>Das Gerätedateisystem <literal>DEVFS</literal>
	  ermöglicht durch den
	  Namensraum des Dateisystems Zugriff auf den Namensraum der
	  Geräte im Kernel.  Damit müssen Gerätedateien
	  nicht mehr extra angelegt werden, sondern werden von
	  <literal>DEVFS</literal> verwaltet.</para>

	<para>Weitere Informationen finden Sie in &man.devfs.5;.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="binary-formats">
    <title>Binärformate</title>

    <para>Um zu verstehen, warum &os; das Format
      &man.elf.5; benutzt, müssen Sie
      zunächst etwas über die drei gegenwärtig
      <quote>dominanten</quote> ausführbaren Formate
      für &unix; Systeme wissen:</para>

    <itemizedlist>
      <listitem>
        <para>&man.a.out.5;</para>

        <para>Das älteste und <quote>klassische</quote>
          Objektformat von &unix; Systemen.  Es benutzt einen kurzen,
	  kompakten Header mit einer magischen Nummer am Anfang, die oft
          benutzt wird, um das Format zu charakterisieren
          (weitere Details finden Sie unter &man.a.out.5;).  Es
          enthält drei geladene Segmente: .text, .data und
          .bss, sowie eine Symboltabelle und eine
          Stringtabelle.</para>
      </listitem>

      <listitem>
        <para><acronym>COFF</acronym></para>

        <para>Das Objektformat von SVR3.  Der Header
          enthält nun eine <quote>Sectiontable</quote>.  Man kann
          also mit mehr als nur den Sections .text, .data und .bss
          arbeiten.</para>
      </listitem>

      <listitem>
        <para>&man.elf.5;</para>

        <para>Der Nachfolger von <acronym>COFF</acronym>.
          Kennzeichnend sind mehrere Sections und mögliche
          32-Bit- oder 64-Bit-Werte.  Ein wesentlicher Nachteil:
          <acronym>ELF</acronym> wurde auch unter der Annahme
          entworfen, dass es nur eine ABI (Application
          Binary Interface) pro Systemarchitektur geben wird.
          Tatsächlich ist diese Annahme falsch &ndash; nicht
          einmal für die kommerzielle SYSV-Welt (in der es
          mindestens drei ABIs gibt: SVR4, Solaris, SCO) trifft
          sie zu.</para>

        <para>FreeBSD versucht, dieses Problem zu umgehen, indem
          ein Werkzeug bereitgestellt wird, um ausführbare
          Dateien im <acronym>ELF</acronym>-Format mit
          Informationen über die ABI zu versehen, zu der
          sie passen.  Weitere Informationen finden Sie in der
          Manualpage &man.brandelf.1;.</para>
      </listitem>
    </itemizedlist>

    <para>FreeBSD kommt aus dem <quote>klassischen</quote> Lager
      und verwendete traditionell das Format &man.a.out.5;, eine
      Technik, die bereits über viele BSD-Releases
      hinweg eingesetzt und geprüft worden ist.  Obwohl es
      bereits seit einiger Zeit möglich war, auf einem
      FreeBSD-System auch Binaries (und Kernel) im
      <acronym>ELF</acronym>-Format zu erstellen und
      auszuführen, widersetzte FreeBSD sich anfangs dem
      <quote>Druck</quote>, auf <acronym>ELF</acronym> als
      Standardformat umzusteigen.  Warum?  Nun, als das
      Linux-Lager die schmerzhafte Umstellung auf
      <acronym>ELF</acronym> durchführte, ging es nicht so
      sehr darum, dem ausführbaren Format
      <filename>a.out</filename> zu entkommen, als dem
      unflexiblen, auf Sprungtabellen basierten Mechanismus
      für <quote>Shared-Libraries</quote> der die Konstruktion von
      Shared-Libraries für Hersteller und Entwickler
      gleichermaßen sehr kompliziert machte.  Da die
      verfügbaren <acronym>ELF</acronym>-Werkzeuge eine
      Lösung für das Problem mit den Shared-Libraries
      anboten und ohnehin generell als <quote>ein Schritt
      vorwärts</quote> angesehen wurden, wurde der Aufwand
      für die Umstellung als notwendig akzeptiert und die
      Umstellung wurde durchgeführt.  Unter FreeBSD ist der
      Mechanismus von Shared-Libraries enger an den Stil des
      Shared-Library-Mechanismus von Suns &sunos;
      angelehnt und von daher sehr einfach zu verwenden.</para>

    <para>Ja, aber warum gibt es so viele unterschiedliche Formate?</para>


    <para>In alter, grauer Vorzeit gab es simple Hardware.
      Diese simple Hardware unterstützte ein einfaches,
      kleines System.  <filename>a.out</filename> war absolut passend
      für die Aufgabe, Binaries auf diesem simplen System (eine PDP-11)
      darzustellen.  Als &unix; von diesem simplen System portiert
      wurde, wurde auch das <filename>a.out</filename>-Format beibehalten,
      weil es für die frühen Portierungen auf Architekturen
      wie den Motorola 68000 und VAX ausreichte.</para>

    <para>Dann dachte sich ein schlauer Hardware-Ingenieur,
      dass, wenn er Software zwingen könnte, einige
      Tricks anzustellen, es ihm möglich wäre, ein
      paar Gatter im Design zu sparen, und seinen CPU-Kern
      schneller zu machen.  Obgleich es dazu gebracht wurde, mit
      dieser neuen Art von Hardware (heute als <acronym>RISC</acronym>
      bekannt) zu arbeiten, war <filename>a.out</filename> für
      diese Hardware schlecht geeignet.  Deshalb wurden viele neue
      Formate entwickelt, um eine bessere Leistung auf dieser
      Hardware zu erreichen, als mit dem begrenzten, simplen
      <filename>a.out</filename>-Format.  Dinge wie
      <acronym>COFF</acronym>, <acronym>ECOFF</acronym> und
      einige andere obskure wurden erdacht und ihre Grenzen
      untersucht, bevor die Dinge sich in Richtung
      <acronym>ELF</acronym> entwickelten.</para>

    <para>Hinzu kam, dass die Größe von
      Programmen gewaltig wurde und Festplatten sowie
      physikalischer Speicher immer noch relativ klein waren.
      Also wurde das Konzept von Shared-Libraries geboren.  Das
      VM-System wurde auch immer fortgeschrittener.  Obwohl bei
      jedem dieser Fortschritte das
      <filename>a.out</filename>-Format benutzt worden ist,
      wurde sein Nutzen mit jedem neuen Merkmal mehr und mehr
      gedehnt.  Zusätzlich wollte man Dinge dynamisch zur
      Ausführungszeit laden, oder Teile ihres Programms
      nach der Initialisierung wegwerfen, um Hauptspeicher
      oder Swap-Speicher zu sparen.  Programmiersprachen
      wurden immer fortschrittlicher und man wollte, dass
      Code automatisch vor der main-Funktion aufgerufen wird.
      Das <filename>a.out</filename>-Format wurde oft
      überarbeitet, um alle diese Dinge zu ermöglichen
      und sie funktionierten auch für einige Zeit.
      <filename>a.out</filename> konnte diese Probleme nicht
      ohne ein ständiges Ansteigen eines Overheads im Code
      und in der Komplexität handhaben.  Obwohl
      <acronym>ELF</acronym> viele dieser Probleme löste,
      wäre es sehr aufwändig, ein System umzustellen, das
      im Grunde genommen funktionierte.  Also musste
      <acronym>ELF</acronym> warten, bis es aufwändiger war, bei
      <filename>a.out</filename> zu bleiben, als zu
      <acronym>ELF</acronym> überzugehen.</para>

    <para>Im Laufe der Zeit haben sich die Erstellungswerkzeuge,
      von denen FreeBSD seine Erstellungswerkzeuge abgeleitet
      hat (speziell der Assembler und der Loader), in zwei
      parallele Zweige entwickelt.  Im FreeBSD-Zweig wurden
      Shared-Libraries hinzugefügt und einige Fehler
      behoben.  Das GNU-Team, das diese Programme
      ursprünglich geschrieben hat, hat sie umgeschrieben
      und eine simplere Unterstützung zur Erstellung von
      Cross-Compilern durch beliebiges Einschalten verschiedener
      Formate usw. hinzugefügt.  Viele Leute wollten
      Cross-Compiler für FreeBSD erstellen, aber sie hatten
      kein Glück, denn FreeBSD's ältere Sourcen
      für <application>as</application> und <application>ld</application>
      waren hierzu nicht geeignet.  Die neuen
      GNU-Werkzeuge (<application>binutils</application>) unterstützen
      Cross-Compilierung, <acronym>ELF</acronym>, Shared-Libraries,
      C++-Erweiterungen und mehr.  Weiterhin geben viele
      Hersteller <acronym>ELF</acronym>-Binaries heraus und es
      ist gut, wenn FreeBSD sie ausführen kann.</para>

    <para><acronym>ELF</acronym> ist ausdrucksfähiger als
      <filename>a.out</filename> und gestattet eine bessere Erweiterbarkeit
      des Basissystems.  Die <acronym>ELF</acronym>-Werkzeuge werden
      besser gewartet und bieten Unterstützung von
      Cross-Compilierung, was für viele Leute wichtig ist.
      <acronym>ELF</acronym> mag etwas langsamer sein, als
      <filename>a.out</filename>, aber zu versuchen, das zu messen,
      könnte schwierig werden.  Es gibt unzählige Details, in
      denen sich die beiden Formate unterscheiden, wie sie Pages
      abbilden, Initialisierungscode handhaben usw.  Keins davon
      ist sehr wichtig, aber es sind Unterschiede.  Irgendwann
      wird die Unterstützung für Programme im
      <filename>a.out</filename>-Format aus dem
      <filename>GENERIC</filename>-Kernel entfernt werden.
      Wenn es dann keinen oder kaum noch
      Bedarf für die Unterstützung dieses Formates
      gibt, werden die entsprechenden Routinen ganz entfernt
      werden.</para>
  </sect1>

  <sect1 id="basics-more-information">
    <title>Weitere Informationen</title>

    <sect2 id="basics-man">
      <title>Manualpages</title>
      <indexterm><primary>Manualpages</primary></indexterm>

      <para>Die umfassendste Dokumentation rund um FreeBSD gibt es in
        Form von Manualpages.  Annähernd jedes Programm im System
        bringt eine kurze Referenzdokumentation mit, die die
        grundsätzliche Funktion und verschiedene Parameter
        erklärt.  Diese Dokumentationen kann man mit dem
        <command>man</command> Kommando benutzen.  Die Benutzung des
        <command>man</command> Kommandos ist einfach:</para>

      <screen>&prompt.user; <userinput>man <replaceable>Kommando</replaceable></userinput></screen>

      <para><literal>Kommando</literal> ist der Name des Kommandos,
        über das Sie etwas erfahren wollen.  Um beispielsweise
        mehr über das Kommando <command>ls</command> zu lernen,
        geben Sie ein:</para>

      <screen>&prompt.user; <userinput>man ls</userinput></screen>

      <para>Die Online-Dokumentation ist in nummerierte Sektionen
        unterteilt:</para>

      <orderedlist>
	<listitem>
	  <para>Benutzerkommandos.</para>
	</listitem>

	<listitem>
	  <para>Systemaufrufe und Fehlernummern.</para>
	</listitem>

	<listitem>
	  <para>Funktionen der C Bibliothek.</para>
	</listitem>

	<listitem>
	  <para>Gerätetreiber.</para>
	</listitem>

	<listitem>
	  <para>Dateiformate.</para>
	</listitem>

	<listitem>
	  <para>Spiele und andere Unterhaltung.</para>
	</listitem>

	<listitem>
	  <para>Verschiedene Informationen.</para>
	</listitem>

	<listitem>
	  <para>Systemverwaltung und -Kommandos.</para>
	</listitem>

	<listitem>
	  <para>Kernel Entwickler.</para>
	</listitem>
      </orderedlist>

      <para>In einigen Fällen kann dasselbe Thema in mehreren
        Sektionen auftauchen.  Es gibt zum Beispiel ein <command>chmod</command>
        Benutzerkommando und einen <function>chmod()</function>
        Systemaufruf.  In diesem Fall können Sie dem
	<command>man</command> Kommando
        sagen, aus welcher Sektion Sie die Information erhalten
        möchten, indem Sie die Sektion mit angeben:</para>

      <screen>&prompt.user; <userinput>man 1 chmod</userinput></screen>

      <para>Dies wird Ihnen die Manualpage für das Benutzerkommando
        <command>chmod</command> zeigen.  Verweise auf eine Sektion
        der Manualpages werden traditionell in Klammern
        gesetzt.  So bezieht sich &man.chmod.1; auf das
        Benutzerkommando <command>chmod</command> und mit
        &man.chmod.2; ist der Systemaufruf gemeint.</para>

      <para>Das ist nett, wenn Sie den Namen eines Kommandos wissen,
        und lediglich wissen wollen, wie es zu benutzen ist.  Aber was
        tun Sie, wenn Sie Sich nicht an den Namen des Kommandos
        erinnern können?  Sie können mit <command>man</command>
	nach Schlüsselbegriffen in den
	Kommandobeschreibungen zu suchen, indem Sie den Parameter
	<option>-k</option> benutzen:</para>

      <screen>&prompt.user; <userinput>man -k mail</userinput></screen>

      <para>Mit diesem Kommando bekommen Sie eine Liste der
        Kommandos, deren Beschreibung das Schlüsselwort
        <quote>mail</quote> enthält.  Diese Funktionalität
        erhalten Sie auch, wenn Sie das Kommando <command>apropos</command>
        benutzen.</para>

      <para>Nun, Sie schauen Sich alle die geheimnisvollen Kommandos
        in <filename>/usr/bin</filename> an, haben aber nicht den
        blassesten Schimmer, wozu die meisten davon gut sind?  Dann
        rufen Sie doch das folgende Kommando auf:</para>
        <screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>man -f *</userinput></screen>

      <para>Dasselbe erreichen Sie durch Eingabe von:</para>

      <screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>whatis *</userinput></screen>

    </sect2>

    <sect2 id="basics-info">
      <title>GNU Info Dateien</title>

      <para>FreeBSD enthält viele Anwendungen und Utilities
        der Free Software Foundation (FSF).  Zusätzlich zu den
        Manualpages bringen diese Programme ausführlichere
        Hypertext-Dokumente (<literal>info</literal> genannt) mit,
        welche man sich mit dem Kommando <command>info</command>
        ansehen kann.  Wenn Sie <application>emacs</application>
        installiert haben, können Sie auch dessen info-Modus
        benutzen.</para>

      <para>Um das Kommando &man.info.1; zu benutzen, geben Sie
        ein:</para>

      <screen>&prompt.user; <userinput>info</userinput></screen>

      <para>Eine kurze Einführung gibt es mit
        <literal>h</literal>; eine Befehlsreferenz erhalten Sie durch
        Eingabe von: <literal>?</literal>.</para>
    </sect2>
  </sect1>
</chapter>
