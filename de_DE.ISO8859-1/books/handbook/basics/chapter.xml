<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde$
     basiert auf: r41813
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="basics">
  <info><title>Grundlagen des UNIX Betriebssystems</title>
    <authorgroup>
      <author><personname><firstname>Chris</firstname><surname>Shumway</surname></personname><contrib>Umgeschrieben von </contrib></author>
    </authorgroup>

    <authorgroup>
      <author><personname><firstname>Uwe</firstname><surname>Pierau</surname></personname><contrib>Übersetzt von </contrib></author>
    </authorgroup>
  </info>

  

  <sect1 xml:id="basics-synopsis">
    <title>Übersicht</title>

   <para>Dieses Kapitel umfasst die grundlegenden Kommandos
     und Funktionsweisen des &os;-Betriebssystems.  Viel von diesem
     Material gilt auch für jedes andere &unix;-artige System.
     Neue Benutzer von &os; sollten dieses Kapitel aufmerksam
     lesen.</para>

   <para>Dieser Abschnitt behandelt die folgenden Themen:</para>

   <itemizedlist>
     <listitem>
       <para>virtuelle Konsolen,</para>
     </listitem>
     <listitem>
       <para>Zugriffsrechte unter &unix; sowie Datei-Flags unter &os;,</para>
     </listitem>
     <listitem>
       <para>Zugriffskontrolllisten für Dateisysteme,</para>
     </listitem>
     <listitem>
       <para>die Verzeichnisstruktur von &os;,</para>
     </listitem>
     <listitem>
       <para>Organisation von Dateisystemen unter &os;,</para>
     </listitem>
     <listitem>
       <para>Ein- und Abhängen von Dateisystemen,</para>
     </listitem>
     <listitem>
       <para>Prozesse, Dämonen und Signale,</para>
     </listitem>
     <listitem>
       <para>Shells und die Login-Umgebung,</para>
     </listitem>
     <listitem>
       <para>Texteditoren,</para>
     </listitem>
     <listitem>
       <para>Geräte und Gerätedateien,</para>
     </listitem>
     <listitem>
       <para>Binärformate unter &os; und</para>
     </listitem>
     <listitem>
       <para>wie Sie in den Manualpages nach weiteren Informationen
	 suchen können.</para>
     </listitem>
   </itemizedlist>
  </sect1>

  <sect1 xml:id="consoles">
    <title>Virtuelle Konsolen und Terminals</title>
    <indexterm><primary>virtuelle Konsole</primary></indexterm>
    <indexterm><primary>Terminals</primary></indexterm>

    <para>Sie können &os; mit einem Terminal benutzen, der nur Text
      darstellen kann.  Wenn Sie FreeBSD auf diese Weise benutzen, stehen
      Ihnen alle Möglichkeiten eines &unix; Betriebssystems zur
      Verfügung.  Dieser Abschnitt beschreibt was Terminals und
      Konsolen sind und wie sie unter &os; eingesetzt werden.</para>

    <sect2 xml:id="consoles-intro">
      <title>Die Konsole</title>
      <indexterm><primary>Konsole</primary></indexterm>

      <para>Wenn das &os;-System so konfiguriert wurde, dass es ohne
	eine grafische Benutzeroberfläche startet, wird das System
	nach dem Start einen Anmeldeprompt ausgeben, wie in diesem
	Beispiel zu sehen:</para>

      <screen>FreeBSD/amd64 (pc3.example.org) (ttyv0)

login:</screen>

      <para>Die erste Zeile enthält einige Informationen über das
	System.  <literal>amd64</literal> zeigt an, dass auf dem
	System in diesem Beispiel eine 64-Bit Version von &os;
	läuft.  Der Hostname ist
	<systemitem>pc3.example.org</systemitem> und
	<filename>ttyv0</filename> gibt an, dass dies die
	Systemkonsole ist.</para>

      <para>Die zweite Zeile zeigt den Anmeldeprompt.  Im nächsten
	Abschnitt wird beschrieben, wie Sie sich an diesem Prompt
	anmelden.</para>
    </sect2>

    <sect2 xml:id="consoles-login">
      <title>Der Anmeldevorgang</title>

      <para>&os; ist ein Mehrbenutzersystem, das Multitasking
	unterstützt.  Das heißt mehrere Benutzer können
	gleichzeitig viele Programme auf einem System laufen lassen.</para>

      <para>Jedes Mehrbenutzersystem muss die Benutzer voneinander
	unterscheiden können.  Bei &os; und allen anderen
	&unix;-artigen
	Betriebssystemen wird dies dadurch erreicht, dass sich die
	Benutzer anmelden müssen, bevor sie Programme laufen lassen
	können.  Jeder Benutzer besitzt einen eindeutigen Namen (den
	Account) und ein dazugehörendes Passwort. &os; wird beides
	abfragen, bevor es dem Benutzer ermöglicht Programme laufen zu
	lassen.</para>

      <indexterm><primary>Startskripten</primary></indexterm>
      <para>Wenn ein &os;-System startet, werden automatisch
	Startskripte ausgeführt, um das System vorzubereiten und
	entsprechend konfigurierte Dienste zu starten.  Nachdem das
	System die Startskripte abgearbeitet hat, wird es einen
	Anmeldeprompt präsentieren:</para>

      <screen>login:</screen>

      <para>Geben Sie den Benutzernamen ein, der während der
	<link linkend="bsdinstall-addusers">Systeminstallation</link>
	konfiguriert wurde und drücken Sie <keycap>Enter</keycap>.
	Geben Sie dann das zum Benutzernamen zugeordnete Passwort ein
	und drücken <keycap>Enter</keycap>.  Das Passwort wird aus
	Sicherheitsgründen
	<emphasis>nicht angezeigt</emphasis>.</para>

      <para>Sobald das richtige Passwort eingegeben wird, wird die
	Nachricht des Tages (<acronym>MOTD</acronym>) gefolgt von
	einer Eingabeaufforderung (dem Zeichen <literal>#</literal>,
	<literal>$</literal> oder <literal>%</literal>) angezeigt.
	Sie sind nun an der &os;-Systemkonsole angemeldet und bereit,
	alle verfügbaren Kommandos zu probieren.</para>
    </sect2>

    <sect2 xml:id="consoles-virtual">
      <title>Virtuelle Konsolen</title>

      <para>&os; kann so konfiguriert werden, dass viele virtuelle
	Konsolen zur Eingabe von Befehlen zur Verfügung stehen.  Jede
	virtuelle Konsole verfügt über einen eigenen Anmeldeprompt und
	Ausgabekanal, und &os; kümmert sich um die ordnungsgemäße
	Umleitung von Tastatureingaben und Monitorausgaben, wenn Sie
	zwischen den virtuellen Konsolen umschalten.</para>

      <para>Zum Umschalten der Konsolen stellt &os; spezielle
	Tastenkombinationen bereit<footnote>
	  <para>Lesen Sie &man.syscons.4;, &man.atkbd.4;,
	    &man.vidcontrol.1; und &man.kbdcontrol.1; für eine recht
	    technische Beschreibung der &os;-Konsole und der
	    Tastatur-Treiber.</para></footnote>.  Benutzen Sie
	<keycombo><keycap>Alt</keycap><keycap>F1</keycap></keycombo>,
	<keycombo><keycap>Alt</keycap><keycap>F2</keycap></keycombo>
	bis
	<keycombo><keycap>Alt</keycap><keycap>F8</keycap></keycombo>,
	um zwischen den verschiedenen virtuellen Konsolen
	umzuschalten.</para>

      <para>Wird von einer Konsole zur nächsten gewechselt, sichert
	&os; den Bildschirminhalt und gibt den Bildschirminhalt der
	neuen Konsole aus.  Dies erzeugt die Illusion mehrerer
	Bildschirme und Tastaturen, an denen Kommandos abgesetzt
	werden können.  Wenn eine Konsole nicht sichtbar ist, weil
	ein Benutzer auf eine andere Konsole gewechselt hat, laufen
	die dort abgesetzten Kommandos trotzdem weiter.</para>
    </sect2>

    <sect2 xml:id="consoles-ttys">
      <title><filename>/etc/ttys</filename></title>

      <para>In der Voreinstellung startet &os; acht virtuelle
	Konsolen, deren Anzahl Sie leicht erhöhen
	oder verringern können.  Die Anzahl und Art der Konsolen wird
	in <filename>/etc/ttys</filename> eingestellt.</para>

      <para>Jede Zeile in <filename>/etc/ttys</filename>, die nicht
	mit <literal>#</literal> anfängt, konfiguriert einen Terminal
	oder eine virtuelle Konsole.  In der Voreinstellung werden
	neun virtuelle Konsolen definiert, von denen acht aktiviert
	sind.  Die Zeilen, die mit <literal>ttyv</literal> beginnen,
	kennzeichnen die Konsolen:</para>

      <programlisting># name	getty			      type  status comments
#
ttyv0   "/usr/libexec/getty Pc"         cons25  on  secure
# Virtual terminals
ttyv1   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv2   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv3   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv4   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv5   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv6   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv7   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv8   "/usr/X11R6/bin/xdm -nodaemon"  xterm   off secure</programlisting>

      <para>Die Manualpage &man.ttys.5; enthält eine ausführliche
	Beschreibung der Spalten dieser Datei und der verfügbaren
	Optionen für virtuelle Konsolen.</para>
    </sect2>

    <sect2 xml:id="consoles-singleuser">
      <title>Die Konsole im Single-User-Modus</title>

      <para>Eine eingehende Beschreibung des Single-User-Modus findet sich
	in <xref linkend="boot-singleuser"/>.  Im Single-User-Modus steht
	nur <emphasis>eine</emphasis> Konsole zur Verfügung.
	Die Einstellungen dieser Konsole befinden sich in diesem
	Abschnitt von <filename>/etc/ttys</filename>:</para>

      <programlisting># name  getty                           type  status  comments
#
# If console is marked "insecure", then init will ask for the root password
# when going to single-user mode.
console none                            unknown  off  secure</programlisting>

      <note>
	<para>In der Zeile, die mit <literal>console</literal> beginnt,
	  kann <literal>secure</literal> durch
	  <literal>insecure</literal> ersetzt werden.  Wenn danach in
	  den Single-User-Modus gebootet wird, verlangt das System die
	  Eingabe des <systemitem
	    class="username">root</systemitem>-Passworts.  In der
	  Standardeinstellung wird beim Betreten des Single-User-Modus
	  kein Passwort verlangt.</para>

	<para><emphasis>Setzen Sie <literal>insecure</literal> nicht
	    leichtfertig ein.</emphasis>  Wenn Sie das
	  <systemitem class="username">root</systemitem>-Passwort
	  vergessen, wird es schwierig, in den
	  Single-User-Modus zu gelangen, wenn man den Bootprozess von
	  &os; nicht genau versteht.</para>
      </note>
    </sect2>

    <sect2 xml:id="consoles-vidcontrol">
      <title>Den Videomodus der Konsole anpassen</title>

      <para>Der Standard-Videomodus der &os;-Konsole kann auf jeden
	Modus eingestellt werden, der von der Grafikkarte und dem
	Monitor unterstützt wird (beispielsweise 1024x768 oder
	1280x1024).  Um eine andere Einstellung zu verwenden, muss
	das <literal>VESA</literal>-Modul geladen werden:</para>

      <screen>&prompt.root; <userinput>kldload vesa</userinput></screen>

      <para>Um festzustellen, welche Video-Modi von der Hardware
	unterstützt werden, nutzen Sie &man.vidcontrol.1;.  Um eine
	Liste aller unterstützten Modi zu sehen, verwenden Sie diesen
	Befehl:</para>

      <screen>&prompt.root; <userinput>vidcontrol -i mode</userinput></screen>

      <para>Die Ausgabe dieses Befehls listet alle Videomodi, die von
	der Hardware unterstützt werden.  Um einen neuen Video-Modi zu
	wählen, wird der entsprechende Modus als
	<systemitem class="username">root</systemitem>-Benutzer an
	&man.vidcontrol.1; übergeben:</para>

      <screen>&prompt.root; <userinput>vidcontrol MODE_279</userinput></screen>

      <para>Um diese Einstellung dauerhaft zu speichern, muss
	folgende Zeile in <filename>/etc/rc.conf</filename>
	hinzugefügt werden:</para>

      <programlisting>allscreens_flags="MODE_279"</programlisting>
    </sect2>
  </sect1>

  <sect1 xml:id="permissions">
    <title>Zugriffsrechte</title>
    <indexterm><primary>UNIX</primary></indexterm>

    <para>&os;, das ein direkter Abkömmling von BSD &unix; ist,
      stützt sich auf mehrere Grundkonzepte von &unix; Systemen.
      Das erste und ausgeprägteste: &os; ist
      ein Mehrbenutzer-Betriebssystem, das es ermöglicht,
      dass mehrere Benutzer gleichzeitig an völlig verschiedenen
      und unabhängigen Aufgaben arbeiten können.  Es ist
      verantwortlich für eine gerechte Auf- und Zuteilung von
      Anfragen nach Hardware- und Peripheriegeräten, Speicher
      und CPU-Zeit unter den Benutzern.</para>

    <para>Da das System mehrere Benutzer unterstützt, hat alles,
      was das System verwaltet, einen Satz von Rechten, die bestimmen,
      wer die jeweilige Ressource lesen, schreiben oder ausführen
      darf.  Diese Zugriffsrechte stehen in drei Achtergruppen, die in
      drei Teile unterteilt sind: einen für den Besitzer der
      Datei, einen für die Gruppe, zu der die Datei gehört
      und einen für alle anderen.  Die numerische Darstellung
      sieht wie folgt aus:</para>

    <note>
      <para>In diesem Abschnitt werden die traditionellen
	Zugriffsrechte von &unix; beschrieben.  Informationen
	zu fein granulierten Zugriffsrechten für Dateisysteme finden
	Sie in <link linkend="fs-acl">Zugriffskontrolllisten
	  für Dateisysteme</link>.</para>
    </note>

    <indexterm><primary>Zugriffsrechte</primary></indexterm>
    <indexterm>
      <primary>Dateizugriffsrechte</primary>
    </indexterm>
    <informaltable frame="none" pgwide="1">
      <tgroup cols="3">
	<thead>
	  <row>
	    <entry>Wert</entry>
	    <entry>Zugriffsrechte</entry>
	    <entry>Auflistung im Verzeichnis</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry>0</entry>
	    <entry>Kein Lesen, Kein Schreiben, Kein Ausführen</entry>
	    <entry><literal>---</literal></entry>
	  </row>

	  <row>
	    <entry>1</entry>
	    <entry>Kein Lesen, Kein Schreiben, Ausführen</entry>
	    <entry><literal>--x</literal></entry>
	  </row>

	  <row>
	    <entry>2</entry>
	    <entry>Kein Lesen, Schreiben, Kein Ausführen</entry>
	    <entry><literal>-w-</literal></entry>
	  </row>

	  <row>
	    <entry>3</entry>
	    <entry>Kein Lesen, Schreiben, Ausführen</entry>
	    <entry><literal>-wx</literal></entry>
	  </row>

	  <row>
	    <entry>4</entry>
	    <entry>Lesen, Kein Schreiben, Kein Ausführen</entry>
	    <entry><literal>r--</literal></entry>
	  </row>

	  <row>
	    <entry>5</entry>
	    <entry>Lesen, Kein Schreiben, Ausführen</entry>
	    <entry><literal>r-x</literal></entry>
	  </row>

	  <row>
	    <entry>6</entry>
	    <entry>Lesen, Schreiben, Kein Ausführen</entry>
	    <entry><literal>rw-</literal></entry>
	  </row>

	  <row>
	    <entry>7</entry>
	    <entry>Lesen, Schreiben, Ausführen</entry>
	    <entry><literal>rwx</literal></entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>
    <indexterm>
      <primary><command>ls</command></primary>
    </indexterm>
    <indexterm><primary>Verzeichnisse</primary></indexterm>

    <para>Benutzen Sie das Argument <option>-l</option> mit
      &man.ls.1;, um eine ausführliche Verzeichnisauflistung
      zu sehen, die in einer Spalte die Zugriffsrechte für den
      Besitzer, die Gruppe und alle anderen enthält.
      Die Ausgabe von <command>ls -l</command> könnte
      wie folgt aussehen:</para>

    <screen>&prompt.user; <userinput>ls -l</userinput>
total 530
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 myfile
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 otherfile
-rw-r--r--  1 root  wheel    7680 Sep  5 12:31 email.txt</screen>

    <para>Das erste Zeichen (ganz links) der ersten Spalte zeigt an,
      ob es sich um eine normale Datei, ein Verzeichnis, ein
      zeichenorientiertes Gerät, ein Socket oder irgendeine andere
      Pseudo-Datei handelt.  In diesem Beispiel zeigt <literal>-</literal> eine
      normale Datei an.  Die nächsten drei Zeichen,
      dargestellt als <literal>rw-</literal>, ergeben die Rechte
      für den Datei-Besitzer.  Die drei Zeichen danach
      <literal>r--</literal> die Rechte der Gruppe, zu der die Datei
      gehört.  Die letzten drei Zeichen, <literal>r--</literal>,
      geben die Rechte für den Rest der Welt an.  Ein Minus
      bedeutet, dass das Recht nicht gegeben ist.  In diesem Beispiel
      sind die Zugriffsrechte also: der Eigentümer kann die Datei
      lesen und schreiben, die Gruppe kann lesen und alle anderen
      können auch nur lesen.  Entsprechend obiger Tabelle
      wären die Zugriffsrechte für diese Datei
      <literal>644</literal>, worin jede Ziffer die drei Teile der
      Zugriffsrechte dieser Datei verkörpert.</para>

    <para>Wie kontrolliert das System die Rechte von Hardware-Geräten?
      &os; behandelt die meisten Hardware-Geräte als Dateien, welche
      Programme öffnen, lesen und mit Daten beschreiben können.  Diese
      speziellen Gerätedateien sind in <filename>/dev</filename>
      gespeichert.</para>

    <para>Verzeichnisse werden ebenfalls wie Dateien behandelt.  Sie
      haben Lese-, Schreib- und Ausführ-Rechte.  Das
      Ausführungs-Bit hat eine etwas andere Bedeutung für
      ein Verzeichnis als für eine Datei.  Die Ausführbarkeit
      eines Verzeichnisses bedeutet, dass in das Verzeichnis,
      zum Beispiel mit <command>cd</command>, gewechselt werden kann.
      Das bedeutet auch, dass in dem Verzeichnis auf Dateien, deren
      Namen bekannt sind, zugegriffen werden kann, vorausgesetzt die
      Zugriffsrechte der Dateien lassen dies zu.</para>

    <para>Das Leserecht auf einem Verzeichnis erlaubt es, sich den Inhalt
      des Verzeichnisses anzeigen zu lassen.  Um eine Datei mit bekanntem
      Namen in einem Verzeichnis zu löschen, müssen auf dem
      Verzeichnis Schreib- <emphasis>und</emphasis> Ausführ-Rechte
      gesetzt sein.</para>

    <para>Es gibt noch mehr Rechte, aber die werden vor allem in
      speziellen Umständen benutzt, wie zum Beispiel bei
      SetUID-Binaries und Verzeichnissen mit gesetztem Sticky-Bit.
      Mehr über Zugriffsrechte von Dateien und wie sie gesetzt werden,
      finden Sie in &man.chmod.1;.</para>

    <sect2>
      <info><title>Symbolische Zugriffsrechte</title>
	<authorgroup>
	  <author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Beigesteuert von </contrib></author>
	</authorgroup>
      </info>

      
      <indexterm>
	<primary>Zugriffsrechte</primary>
	<secondary>symbolische</secondary>
      </indexterm>

      <para>Symbolische Zugriffsrechte verwenden Zeichen anstelle von
	oktalen Werten, um die Berechtigungen für Dateien oder
	Verzeichnisse festzulegen.  Zugriffsrechte verwenden die
	Syntax <replaceable>Wer</replaceable>,
	<replaceable>Aktion</replaceable> und
	<replaceable>Berechtigung</replaceable>. Die folgenden
	Werte stehen zur Auswahl:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>Option</entry>
	      <entry>Symbol</entry>
	      <entry>Bedeutung</entry>
	    </row>
	  </thead>

	<tbody>
	  <row>
	    <entry><replaceable>Wer</replaceable></entry>
	    <entry>u</entry>
	    <entry>Benutzer (<foreignphrase>user</foreignphrase>)</entry>
	  </row>

	  <row>
	    <entry><replaceable>Wer</replaceable></entry>
	    <entry>g</entry>
	    <entry>Gruppe (<foreignphrase>group</foreignphrase>)</entry>
	  </row>

	  <row>
	    <entry><replaceable>Wer</replaceable></entry>
	    <entry>o</entry>
	    <entry>Andere (<foreignphrase>other</foreignphrase>)</entry>
	  </row>

	  <row>
	    <entry><replaceable>Wer</replaceable></entry>
	    <entry>a</entry>
	    <entry>Alle</entry>
	  </row>

	  <row>
	    <entry><replaceable>Aktion</replaceable></entry>
	    <entry>+</entry>
	    <entry>Berechtigungen hinzufügen</entry>
	  </row>

	  <row>
	    <entry><replaceable>Aktion</replaceable></entry>
	    <entry>-</entry>
	    <entry>Berechtigungen entziehen</entry>
	  </row>

	  <row>
	    <entry><replaceable>Aktion</replaceable></entry>
	    <entry>=</entry>
	    <entry>Berechtigungen explizit setzen</entry>
	  </row>

	  <row>
	    <entry><replaceable>Berechtigung</replaceable></entry>
	    <entry>r</entry>
	    <entry>lesen (<foreignphrase>read</foreignphrase>)</entry>
	  </row>

	  <row>
	    <entry><replaceable>Berechtigung</replaceable></entry>
	    <entry>w</entry>
	    <entry>schreiben (<foreignphrase>write</foreignphrase>)</entry>
	  </row>

	  <row>
	    <entry><replaceable>Berechtigung</replaceable></entry>
	    <entry>x</entry>
	    <entry>ausführen
	      (<foreignphrase>execute</foreignphrase>)</entry>
	  </row>

	  <row>
	    <entry><replaceable>Berechtigung</replaceable></entry>
	    <entry>t</entry>
	    <entry>Sticky-Bit</entry>
	  </row>

	  <row>
	    <entry><replaceable>Berechtigung</replaceable></entry>
	    <entry>s</entry>
	    <entry>Set-UID oder Set-GID</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <para>Diese symbolischen Werte werden zusammen mit &man.chmod.1;
      verwendet.  Beispielsweise würde der folgende Befehl den Zugriff
      auf <replaceable>FILE</replaceable> für alle anderen Benutzer
      verbieten:</para>

    <screen>&prompt.user; <userinput>chmod go= FILE</userinput></screen>

    <para>Wenn Sie mehr als eine Änderung der Rechte einer
      Datei vornehmen wollen, können Sie eine durch Kommata
      getrennte Liste der Rechte angeben.  Das folgende Beispiel
      entzieht der Gruppe und der Welt die Schreibberechtigung auf
      <replaceable>FILE</replaceable> und fügt für jeden
      Ausführungsrechte hinzu:</para>

    <screen>&prompt.user; <userinput>chmod go-w,a+x FILE</userinput></screen>

<!--
    <para>Mit symbolischen Zugriffsrechten können Sie Rechte
      hinzufügen oder Rechte wegnehmen.  Numerische Zugriffsrechte
      erlauben nur das explizite Setzen der Zugriffsrechte.</para>
-->
    </sect2>

    <sect2>
      <info><title>&os; Datei-Flags</title>
	<authorgroup>
	  <author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Beigetragen von </contrib></author>
	</authorgroup>
      </info>

      

      <para>Zusätzlich zu den Zugriffsrechten
	unterstützt &os; auch die Nutzung von
	<quote>Datei-Flags</quote>.  Diese erhöhen die Sicherheit
	Ihres Systems, indem sie eine verbesserte Kontrolle von
	Dateien erlauben.  Verzeichnisse werden allerdings nicht
	unterstützt.  Mit dem Einsatz von Datei-Flags kann sogar
	<systemitem class="username">root</systemitem> daran gehindert
	werden, Dateien zu löschen oder zu verändern.</para>

      <para>Datei-Flags werden mit &man.chflags.1; verändert.  Um
	beispielsweise auf der Datei <filename>file1</filename> das
	<quote>unlöschbar</quote>-Flag zu aktivieren, geben Sie
	folgenden Befehl ein:</para>

      <screen>&prompt.root; <userinput>chflags sunlink file1</userinput></screen>

      <para>Um dieses Flag zu deaktivieren, setzen Sie ein
	<quote>no</quote> vor <option>sunlink</option>:</para>

      <screen>&prompt.root; <userinput>chflags nosunlink file1</userinput></screen>

      <para>Um die Flags einer Datei anzuzeigen, verwenden Sie
	&man.ls.1; zusammen mit <option>-lo</option>:</para>

      <screen>&prompt.root; <userinput>ls -lo file1</userinput></screen>

      <programlisting>-rw-r--r--  1 trhodes  trhodes  sunlnk 0 Mar  1 05:54 file1</programlisting>

      <para>Einige Datei-Flags können nur vom
	<systemitem class="username">root</systemitem>-Benutzer
	gesetzt oder gelöscht werden.  Andere wiederum können
	auch vom Eigentümer der Datei gesetzt werden.  Weitere
	Informationen hierzu finden sich in &man.chflags.1; und
	&man.chflags.2;.</para>
    </sect2>

    <sect2>
      <info><title>Die Berechtigungen <literal>setuid</literal>,
          <literal>setgid</literal>, und
          <literal>sticky</literal></title>
        <authorgroup>
          <author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Beigetragen von </contrib></author>
        </authorgroup>
      </info>

      

      <para>Anders als die Berechtigungen, die bereits angesprochen wurden,
        existieren drei weitere Einstellungen, über die alle
        Administratoren Bescheid wissen sollten.  Dies sind die Berechtigungen
        <literal>setuid</literal>, <literal>setgid</literal> und
        <literal>sticky</literal>.</para>

      <para>Diese Einstellungen sind wichtig für manche &unix;-Operationen,
        da sie Funktionalitäten zur Verfügung stellen, die
        normalerweise nicht an gewöhnliche Anwender vergeben wird.
        Um diese zu verstehen, muss der Unterschied zwischen der realen
        und der effektiven Benutzer-ID erwähnt werden.</para>

      <para>Die reale Benutzer-ID ist die <acronym>UID</acronym>, welche den
        Prozess besitzt oder gestartet hat.  Die effektive
        <acronym>UID</acronym> ist diejenige, als die der Prozess läuft.
        Beispielsweise wird &man.passwd.1; mit der realen ID des Benutzers
        ausgeführt, der sein Passwort ändert. Um jedoch die
        Passwortdatenbank zu bearbeiten, wird es effektiv als
        <systemitem class="username">root</systemitem>-Benutzer ausgeführt.  Das
        ermöglicht es normalen Benutzern, ihr Passwort zu ändern, ohne
        einen <errorname>Permission Denied</errorname>-Fehler angezeigt zu
        bekommen.</para>

      <para>Die setuid-Berechtigung kann durch das Voranstellen bei einer
        Berechtigungsgruppe mit der Nummer Vier (4) gesetzt werden, wie im
        folgenden Beispiel gezeigt wird:</para>

      <screen>&prompt.root; <userinput>chmod 4755 suidexample.sh</userinput></screen>

      <para>Die Berechtigungen auf <filename>suidexample.sh</filename>
        sehen jetzt wie folgt aus:</para>

      <programlisting>-rwsr-xr-x   1 trhodes  trhodes    63 Aug 29 06:36 suidexample.sh</programlisting>

      <para>Beachten Sie, dass ein <literal>s</literal> jetzt Teil der
	Berechtigungen des Dateibesitzers geworden ist, welches
        das Ausführen-Bit ersetzt.  Dies ermöglicht es Werkzeugen
        mit erhöhten Berechtigungen zu laufen, wie z.B.
        <command>passwd</command>.</para>

      <note>
	<para>Die <literal>nosuid</literal> &man.mount.8;-Option
	  bewirkt, dass solche Anwendungen stillschweigend scheitern,
	  ohne den Anwender darüber zu informieren.  Diese Option ist
	  nicht völlig zuverlässig, da ein
	  <literal>nosuid</literal>-Wrapper in der Lage wäre, dies zu
          umgehen.</para>
      </note>

      <para>Um dies in Echtzeit zu beobachten, öffnen Sie zwei Terminals.
        Starten Sie auf einem den <command>passwd</command>-Prozess als normaler
        Benutzer.  Während es auf die Passworteingabe wartet,
        überprüfen Sie die Prozesstabelle und sehen Sie sich die
        Informationen für <command>passwd</command> an.</para>

      <para>Im Terminal A:</para>

      <screen>Changing local password for trhodes
Old Password:</screen>

      <para>Im Terminal B:</para>

      <screen>&prompt.root; <userinput>ps aux | grep passwd</userinput></screen>

      <screen>trhodes  5232  0.0  0.2  3420  1608   0  R+    2:10AM   0:00.00 grep passwd
  	 root     5211  0.0  0.2  3620  1724   2  I+    2:09AM   0:00.01 passwd</screen>

      <para>Wie oben erwähnt, wird <command>passwd</command> von einem
        normalen Benutzer ausgeführt, benutzt aber die effektive
        <acronym>UID</acronym> von <systemitem class="username">root</systemitem>.</para>

      <para>Die <literal>setgid</literal>-Berechtigung führt die gleiche
        Aktion wie die <literal>setuid</literal>-Berechtigung durch, allerdings
        verändert sie die Gruppenberechtigungen.  Wenn eine Anwendung
        oder ein Werkzeug mit dieser Berechtigung ausgeführt wird,
        erhält es die Berechtigungen basierend auf der Gruppe, welche die
        Datei besitzt und nicht die des Benutzers, der den Prozess gestartet
        hat.</para>

      <para>Um die <literal>setgid</literal>-Berechtigung auf einer Datei zu
        setzen, geben Sie <command>chmod</command> eine
        führende Zwei (2) mit:</para>

      <screen>&prompt.root; <userinput>chmod 2755 sgidexample.sh</userinput></screen>

      <para>Beachten Sie in der folgenden Auflistung,
        dass das <literal>s</literal> sich jetzt in dem Feld befindet, das
        für die Berechtigungen der Gruppe bestimmt ist:</para>

      <screen>-rwxr-sr-x   1 trhodes  trhodes    44 Aug 31 01:49 sgidexample.sh</screen>

      <note>
        <para>Obwohl es sich bei dem in diesen Beispielen gezeigten Shellskript
          um eine ausführbare Datei handelt, wird es nicht mit einer
          anderen <acronym>EUID</acronym> oder effektiven Benutzer-ID
          ausgeführt.  Das ist so, weil Shellskripte keinen Zugriff auf
          &man.setuid.2;-Systemaufrufe erhalten.</para>
      </note>

      <para>Die <literal>setuid</literal> und
	<literal>setgid</literal> Berechtigungs-Bits können die
	Systemsicherheit verringern, da sie erhöhte Rechte
	ermöglichen.  Das dritte Berechtigungs-Bit, das
	<literal>sticky bit</literal> kann die Sicherheit eines
	Systems erhöhen.</para>

      <para>Wenn das <literal>sticky bit</literal> auf einem
	Verzeichnis angewendet wird, erlaubt es das Löschen von
	Dateien nur durch den Besitzer der Datei.  Dies ist nützlich,
	um die Löschung von Dateien in öffentlichen Verzeichnissen wie
	<filename>/tmp</filename>, durch Benutzer denen diese Dateien
	nicht gehören, zu verhindern.  Um diese Berechtigung
	anzuwenden, stellen Sie der Berechtigung eine Eins (1)
	voran:</para>

      <screen>&prompt.root; <userinput>chmod 1777 /tmp</userinput></screen>

      <para>Das <literal>sticky bit</literal> kann anhand des
	<literal>t</literal> ganz am Ende der Berechtigungen abgelesen
	werden.</para>

      <screen>&prompt.root; <userinput>ls -al / | grep tmp</userinput></screen>

      <screen>drwxrwxrwt  10 root  wheel         512 Aug 31 01:49 tmp</screen>

    </sect2>
  </sect1>

  <sect1 xml:id="dirstructure">
    <title>Verzeichnis-Strukturen</title>
    <indexterm><primary>Verzeichnis Hierarchien</primary></indexterm>

    <para>Die &os;-Verzeichnishierarchie ist die Grundlage, um
      ein umfassendes Verständnis des Systems zu erlangen.
      Das wichtigste Verzeichnis ist das Root-Verzeichnis
      <quote>/</quote>.  Dieses Verzeichnis ist das
      erste, das während des Bootens eingehangen wird.  Es
      enthält das notwendige Basissystem, um das Betriebssystem in den
      Mehrbenutzerbetrieb zu bringen.  Das Root-Verzeichnis enthält
      auch die Mountpunkte für Dateisysteme, die beim Wechsel in
      den Multiuser-Modus eingehängt werden.</para>

    <para>Ein Mountpunkt ist ein Verzeichnis, in das zusätzliche
      Dateisysteme (in der Regel unterhalb des Wurzelverzeichnisses)
      eingehängt werden können.  Dieser Vorgang wird in
      <xref linkend="disk-organization"/> ausführlich beschrieben.
      Standard-Mountpunkte sind <filename>/usr</filename>,
      <filename>/var</filename>, <filename>/tmp</filename>,
      <filename>/mnt</filename> sowie <filename>/cdrom</filename>.
      Auf diese Verzeichnisse verweisen üblicherweise Einträge
      in <filename>/etc/fstab</filename>.  Diese Datei ist
      eine Tabelle mit verschiedenen Dateisystemen und Mountpunkten,
      vom System gelesen werden.  Die meisten der Dateisysteme in
      <filename>/etc/fstab</filename> werden beim Booten automatisch
      durch das Skript &man.rc.8; gemountet, wenn die zugehörigen
      Einträge nicht mit <option>noauto</option>
      versehen sind.  Weitere Informationen zu diesem Thema finden Sie
      im <xref linkend="disks-fstab"/>.</para>

    <para>Eine vollständige Beschreibung der Dateisystem-Hierarchie
      finden Sie in &man.hier.7;.  Die folgende Aufstellung gibt einen
      kurzen Überblick über die am häufigsten verwendeten
      Verzeichnisse:</para>

    <para>
      <informaltable frame="none" pgwide="1">
        <tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Verzeichnis</entry>
	      <entry>Beschreibung</entry>
	    </row>
	  </thead>
	  <tbody valign="top">
            <row>
	      <entry><filename>/</filename></entry>
	      <entry>Wurzelverzeichnis des Dateisystems.</entry>
            </row>

	    <row>
	      <entry><filename>/bin/</filename></entry>
	      <entry>Grundlegende Werkzeuge für den Single-User-Modus
		sowie den Mehrbenutzerbetrieb.</entry>
	    </row>

	    <row>
	      <entry><filename>/boot/</filename></entry>
	      <entry>Programme und Konfigurationsdateien, die während
		des Bootens benutzt werden.</entry>
	    </row>

	    <row>
	      <entry><filename>/boot/defaults/</filename></entry>
	      <entry>Vorgaben für die Boot-Konfiguration.  Weitere
		Details finden Sie in &man.loader.conf.5;.</entry>
	    </row>

	    <row>
	      <entry><filename>/dev/</filename></entry>
	      <entry>Gerätedateien.  Weitere Details finden Sie in
		&man.intro.4;.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/</filename></entry>
	      <entry>Konfigurationsdateien und Skripten des Systems.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/defaults/</filename></entry>
	      <entry>Vorgaben für die System Konfigurationsdateien.
		Weitere Details finden Sie in &man.rc.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/mail/</filename></entry>
	      <entry>Konfigurationsdateien von MTAs wie
		&man.sendmail.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/namedb/</filename></entry>
	      <entry>Konfigurationsdateien von
		<command>named</command>.  Weitere Details finden Sie
		in &man.named.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/periodic/</filename></entry>
	      <entry>Täglich, wöchentlich oder monatlich laufende
		Skripte, die von &man.cron.8; gestartet werden.
		Weitere Details finden Sie in
		&man.periodic.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/ppp/</filename></entry>
	      <entry>Konfigurationsdateien von <command>ppp</command>,
		wie in &man.ppp.8; beschrieben.</entry>
	    </row>

	    <row>
	      <entry><filename>/mnt/</filename></entry>
	      <entry>Ein leeres Verzeichnis, das von Systemadministratoren
		häufig als temporärer Mountpunkt genutzt wird.</entry>
	    </row>

	    <row>
	      <entry><filename>/proc/</filename></entry>
	      <entry>Prozess Dateisystem.  Weitere Details finden Sie
		in &man.procfs.5; und &man.mount.procfs.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/rescue/</filename></entry>
	      <entry>Statisch gelinkte Programme zur Wiederherstellung
		des Systems, wie in &man.rescue.8;
		beschrieben.</entry>
	    </row>

	    <row>
	      <entry><filename>/root/</filename></entry>
	      <entry>Home Verzeichnis von <systemitem class="username">root</systemitem>.</entry>
	    </row>

	    <row>
	      <entry><filename>/sbin/</filename></entry>
	      <entry>Systemprogramme und administrative Werkzeuge, die
		grundlegend für den Single-User-Modus und den
		Mehrbenutzerbetrieb sind.</entry>
	    </row>

	    <row>
	      <entry><filename>/tmp/</filename></entry>
	      <entry>Temporäre Dateien, die für gewöhnlich
		bei einem Neustart des Systems verloren gehen.
		Häufig wird ein speicherbasiertes Dateisystem unter
		<filename>/tmp</filename>
		eingehängt.  Dieser Vorgang kann automatisiert werden,
		wenn tmpmfs-bezogene Variablen von &man.rc.conf.5;
		verwendet werden, oder ein entsprechender
		Eintrag in <filename>/etc/fstab</filename> existiert.
		Weitere Informationen finden Sie in
		&man.mdmfs.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/</filename></entry>
	      <entry>Der Großteil der Benutzerprogramme und
		Anwendungen.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/bin/</filename></entry>
	      <entry>Gebräuchliche Werkzeuge, Programmierhilfen und
		Anwendungen.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/include/</filename></entry>
	      <entry>Standard C include-Dateien.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/lib/</filename></entry>
	      <entry>Bibliotheken.</entry>
	    </row>


	    <row>
	      <entry><filename>/usr/libdata/</filename></entry>
	      <entry>Daten verschiedener Werkzeuge.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/libexec/</filename></entry>
	      <entry>System-Dämonen und System-Werkzeuge, die von
		anderen Programmen ausgeführt werden.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/local/</filename></entry>

	      <entry>Lokale Programme und Bibliotheken.  Die
		Ports-Sammlung von &os; benutzt dieses Verzeichnis
		als Zielverzeichnis für Anwendungen.  Innerhalb von
		<filename>/usr/local</filename> sollte das von
		&man.hier.7; beschriebene Layout für
		<filename>/usr</filename> benutzt werden.  Das
		<filename>man</filename> Verzeichnis wird direkt unter
		<filename>/usr/local</filename> anstelle unter
		<filename>/usr/local/share</filename> angelegt.  Die
		Dokumentation der Ports findet sich in
		<filename>share/doc/port</filename>.
	      </entry>
	    </row>

	    <row>
	      <entry><filename>/usr/obj/</filename></entry>
	      <entry>Von der Architektur abhängiger Verzeichnisbaum,
		der durch das Bauen von <filename>/usr/src</filename>
		entsteht.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/ports/</filename></entry>
	      <entry>Die &os;-Ports-Sammlung (optional).</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/sbin/</filename></entry>
	      <entry>System-Dämonen und System-Werkzeuge, die von
		Benutzern ausgeführt werden.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/share/</filename></entry>
	      <entry>Von der Architektur unabhängige Dateien.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/src/</filename></entry>
	      <entry>Quelldateien von BSD und/oder lokalen
		Ergänzungen.</entry>
	    </row>

	    <row>
	      <entry><filename>/var/</filename></entry>
	      <entry>Wird für mehrere Zwecke genutzt und enthält
		Logdateien, temporäre Daten und Spooldateien.
		Manchmal wird ein speicherbasiertes Dateisystem unter
		<filename>/var</filename>
		eingehängt.  Dieser Vorgang kann automatisiert werden,
		wenn die varmfs-bezogenen Variablen von
		&man.rc.conf.5; verwendet werden, oder ein
		entsprechender Eintrag in
		<filename>/etc/fstab</filename> existiert.  Weitere
		Informationen finden Sie in &man.mdmfs.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/var/log/</filename></entry>
	      <entry>Verschiedene Logdateien des Systems.</entry>
	    </row>

	    <row>
	      <entry><filename>/var/mail/</filename></entry>
	      <entry>Postfächer der Benutzer.</entry>
	    </row>

	    <row>
	      <entry><filename>/var/spool/</filename></entry>
	      <entry>Verschiedene Spool-Verzeichnisse der Drucker- und
		Mailsysteme.</entry>
	    </row>

	    <row>
	      <entry><filename>/var/tmp/</filename></entry>
	      <entry>Temporäre Dateien, die in der Regel auch bei
		einem Neustart des Systems erhalten bleiben, es sei
		denn, bei
	        <filename>/var</filename> handelt es
	        sich um ein speicherbasiertes Dateisystem.</entry>
	    </row>

	    <row>
	      <entry><filename>/var/yp/</filename></entry>
	      <entry>NIS maps.</entry>
	    </row>

	  </tbody>
	</tgroup>
      </informaltable>
    </para>
  </sect1>

  <sect1 xml:id="disk-organization">
      <title>Festplatten, Slices und Partitionen</title>

      <para>&os; identifiziert Dateien anhand eines Dateinamens.
	In Dateinamen wird zwischen Groß- und Kleinschreibung
	unterschieden:  <filename>readme.txt</filename> und
	<filename>README.TXT</filename> bezeichnen daher zwei
	verschiedene Dateien.  &os; benutzt keine Dateiendungen,
	um den Typ der Datei zu bestimmen, egal ob es sich um ein
	Programm, ein Dokument oder um andere Daten handelt.</para>

      <para>Dateien werden in Verzeichnissen gespeichert.  In einem
	Verzeichnis können sich keine oder hunderte Dateien
	befinden.  Ein Verzeichnis kann auch andere Verzeichnisse
	enthalten und so eine Hierarchie von Verzeichnissen aufbauen,
	die die Ablage von Daten erleichtert.</para>

      <para>In Dateinamen werden Verzeichnisse durch einen
	Schrägstrich (<literal>/</literal>,
	<foreignphrase>Slash</foreignphrase>) getrennt.  Wenn z.B.
	das Verzeichnis <filename>foo</filename>
	ein Verzeichnis <filename>bar</filename>
	enthält, in dem sich die Datei <filename>readme.txt</filename>
	befindet, lautet der vollständige Name der Datei (oder der
	<firstterm>Pfad</firstterm> zur Datei)
	<filename>foo/bar/readme.txt</filename>.  Beachten Sie, dass
	sich dies von &windows; unterscheidet, wo der 
	<literal>\</literal> (<foreignphrase>Backslash</foreignphrase>
	für die Trennung von Datei- und Verzeichnisnamen
	verwendet wird.  &os; benutzt keine Laufwerkbuchstaben oder
	Laufwerknamen im Pfad.  Beispielsweise würde man unter
	&os; nicht <filename>c:/foo/bar/readme.txt</filename>
	eingeben.</para>

      <para>Verzeichnisse und Dateien werden in einem Dateisystem
	gespeichert.  Jedes Dateisystem besitzt genau ein
	<firstterm>Wurzelverzeichnis</firstterm>, das so genannte
	<foreignphrase>Root-Directory</foreignphrase>.  Dieses
	Wurzelverzeichnis kann weitere Verzeichnisse enthalten.
	Ein Dateisystem wird als Wurzeldateisystem festgelegt, und
	jedes weitere Dateisystem wird unter dem Wurzeldateisystem
	<firstterm>eingehangen</firstterm>.  Daher scheint jedes
	Verzeichnis, unabhängig von der Anzahl der Platten, auf der
	selben Platte zu liegen.</para>

      <para>Angenommen, Sie haben drei Dateisysteme <literal>A</literal>,
	<literal>B</literal> und <literal>C</literal>.  Jedes
	Dateisystem besitzt ein eigenes Wurzelverzeichnis, das
	zwei andere Verzeichnisse enthält:
	<filename>A1</filename>,
	<filename>A2</filename>,
	<filename>B1</filename>,
	<filename>B2</filename>,
	<filename>C1</filename> und
	<filename>C2</filename>.</para>

      <para>Das Wurzeldateisystem soll <literal>A</literal> sein.
	<command>ls</command> zeigt darin
	die beiden Verzeichnisse <filename>A1</filename>
	und <filename>A2</filename> an.
	Der Verzeichnisbaum sieht wie folgt aus:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir1"/>
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2</literallayout>
	</textobject>
      </mediaobject>

      <para>Ein Dateisystem wird in einem Verzeichnis eines anderen
	Dateisystems eingehangen.  Wir hängen nun das Dateisystem
	<literal>B</literal> in das Verzeichnis
	<filename>A1</filename> ein.  Das
	Wurzelverzeichnis von <literal>B</literal> ersetzt nun
	das Verzeichnis <filename>A1</filename> und
	die Verzeichnisse des Dateisystems <literal>B</literal>
	werden sichtbar:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir2"/>
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |     |
 |     +--- B1
 |     |
 |     `--- B2
 |
 `--- A2</literallayout>
	</textobject>
      </mediaobject>

      <para>Jede Datei in den Verzeichnissen
	<filename>B1</filename> oder
	<filename>B2</filename> kann
	über den Pfad <filename>/A1/B1</filename>
	oder <filename>/A1/B2</filename>
	erreicht werden.  Dateien aus dem Verzeichnis
	<filename>/A1</filename> sind jetzt
	verborgen.  Wenn das Dateisystem <literal>B</literal>
	wieder <firstterm>abgehangen</firstterm> wird
	(<foreignphrase>umount</foreignphrase>), erscheinen
	die verborgenen Dateien wieder.</para>

      <para>Wenn das Dateisystem <literal>B</literal> unter dem
	Verzeichnis <filename>A2</filename>
	eingehangen würde, sähe der Verzeichnisbaum
	so aus:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir3"/>
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2
       |
       +--- B1
       |
       `--- B2</literallayout>
	</textobject>
      </mediaobject>

      <para>Die Dateien des Dateisystems <literal>B</literal> wären
	unter den Pfaden <filename>/A2/B1</filename> und
	<filename>/A2/B2</filename> erreichbar.</para>

      <para>Dateisysteme können übereinander eingehangen
	werden.  Der folgende Baum entsteht, wenn im letzten
	Beispiel das Dateisystem <literal>C</literal> in das Verzeichnis
	<filename>B1</filename> des Dateisystems
	<literal>B</literal> eingehangen wird:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir4"/>
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2
       |
       +--- B1
       |     |
       |     +--- C1
       |     |
       |     `--- C2
       |
       `--- B2</literallayout>
	</textobject>
      </mediaobject>

      <para><literal>C</literal> könnte auch im Verzeichnis
	<filename>A1</filename> eingehangen
	werden:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir5"/>
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |     |
 |     +--- C1
 |     |
 |     `--- C2
 |
 `--- A2
       |
       +--- B1
       |
       `--- B2</literallayout>
	</textobject>
      </mediaobject>

      <para>Normalerweise müssen Sie sich nicht mit Dateisystemen
	beschäftigen.  Während der Installation von &os; werden
	die Dateisysteme und die Stellen, in der sie eingehangen werden,
	festgelegt.  Dateisysteme müssen erst wieder angelegt werden,
	wenn Sie eine neue Platte hinzufügen.</para>

      <para>Sie können sogar mit nur einem großen
	Dateisystem auskommen.  Dies hat mehrere Nachteile
	und einen Vorteil.</para>

      <itemizedlist>
	<title>Vorteile mehrerer Dateisysteme</title>

	<listitem>
	  <para>Die Dateisysteme können mit unterschiedlichen
	    Optionen (<foreignphrase>mount options</foreignphrase>)
	    eingehangen werden.  Beispielsweise kann das
	    Wurzeldateisystem schreibgeschützt eingehangen werden,
	    sodass es für Benutzer nicht möglich ist, versehentlich
	    kritische Dateien zu editieren oder zu löschen.
	    Von Benutzern beschreibbare Dateisysteme
	    wie <filename>/home</filename>
	    können Sie mit der Option <firstterm>nosuid</firstterm>
	    einhängen, wenn sie von anderen Dateisystemen getrennt
	    sind.  Die <firstterm>SUID</firstterm>- und
	    <firstterm>GUID</firstterm>-Bits verlieren auf solchen
	    Dateisystemen ihre Wirkung und die Sicherheit des
	    Systems kann dadurch erhöht werden.</para>
	</listitem>

	<listitem>
	  <para>Die Lage von Dateien im Dateisystem wird, abhängig
	    vom Gebrauch des Dateisystems, automatisch von &os;
	    optimiert.  Ein Dateisystem mit vielen kleinen Dateien,
	    die häufig geschrieben werden, wird anders behandelt
	    als ein Dateisystem mit wenigen großen Dateien.
	    Mit nur einem Dateisystem ist diese Optimierung
	    unmöglich.</para>
	</listitem>

	<listitem>
	  <para>In der Regel übersteht ein &os;-Dateisystem auch
	    einen Stromausfall.  Allerdings kann ein Stromausfall zu
	    einem kritischen Zeitpunkt das Dateisystem beschädigen.
	    Wenn die Daten über mehrere Dateisysteme verteilt
	    sind, lässt sich das System mit hoher
	    Wahrscheinlichkeit noch starten.  Dies erleichtert
	    das Zurückspielen von Datensicherungen.</para>
	</listitem>
      </itemizedlist>

      <itemizedlist>
	<title>Vorteil eines einzelnen Dateisystems</title>

	<listitem>
	  <para>Dateisysteme haben eine festgelegte Größe.
	    Es kann passieren, dass Sie eine Partition
	    vergrößern müssen.  Dies ist nicht leicht:
	    Sie müssen die Daten sichern, das Dateisystem
	    vergrößert anlegen und die gesicherten
	    Daten zurückspielen.</para>

	  <important>
	    <para>&os; kennt den Befehl &man.growfs.8;, mit dem man
	      Dateisysteme im laufenden Betrieb
	      vergrößern kann.</para>
	  </important>
	</listitem>
      </itemizedlist>

      <para>Dateisysteme befinden sich in Partitionen (damit sind
	nicht die normalen &ms-dos;-Partitionen gemeint).  Jede Partition
	wird mit einem Buchstaben von <literal>a</literal> bis
	<literal>h</literal> bezeichnet und kann nur ein Dateisystem
	enthalten.  Dateisysteme können daher über ihren
	Mount-Point, den Punkt an dem sie eingehangen sind, oder
	den Buchstaben der Partition, in der sie liegen, identifiziert
	werden.</para>

      <para>&os; benutzt einen Teil der Platte für den
	<firstterm>Swap-Bereich</firstterm>, um
	<firstterm>virtuellen Speicher</firstterm> zur Verfügung zu
	stellen.  Dadurch kann der Rechner Anwendungen mehr Speicher
	zur Verfügung stellen als tatsächlich eingebaut
	ist.  Wenn der Speicher knapp wird, kann &os; nicht benutzte
	Daten in den Swap-Bereich auslagern.  Die ausgelagerten
	Daten können später wieder in den Speicher
	geholt werden (dafür werden dann andere Daten
	ausgelagert).</para>

      <para>Für einige Partitionen gelten besondere
        Konventionen:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <colspec colwidth="1*"/>
	  <colspec colwidth="5*"/>

	  <thead>
	    <row>
	      <entry>Partition</entry>

	      <entry>Konvention</entry>
	    </row>
	  </thead>

	  <tbody valign="top">
	    <row>
	      <entry><literal>a</literal></entry>

	      <entry>Enthält normalerweise
		das Wurzeldateisystem.</entry>
	    </row>

	    <row>
	      <entry><literal>b</literal></entry>

	      <entry>Enthält normalerweise
		den Swap-Bereich.</entry>
	    </row>

	    <row>
	      <entry><literal>c</literal></entry>

	      <entry>Ist normalerweise genauso groß wie
		die Slice in der die Partition liegt.  Werkzeuge,
		die auf der kompletten Slice arbeiten, wie ein
		Bad-Block-Scanner, können so die
		<literal>c</literal>-Partition benutzen.
		Für gewöhnlich legen Sie in dieser
		Partition kein Dateisystem an.</entry>
	    </row>

	    <row>
	      <entry><literal>d</literal></entry>

	      <entry>Früher hatte die <literal>d</literal>-Partition
		eine besondere Bedeutung.  Heute ist dies nicht mehr der
		Fall und die Partition <literal>d</literal> kann wie
		jede andere Partition auch verwendet werden.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>In &os; werden Festplatten in Slices, welche in &windows;
	als Partitionen bekannt sind, aufgeteilt und von
	1 bis 4 durchnummeriert.  Diese werden dann in Partitionen
	unterteilt, welche wiederum Dateisysteme enthalten und mit
	Buchstaben benannt werden.</para>

      <indexterm><primary>Slices</primary></indexterm>
      <indexterm><primary>Partitionen</primary></indexterm>
      <indexterm><primary>dangerously dedicated</primary></indexterm>

      <para>Die Slice-Nummern werden mit vorgestelltem
	<literal>s</literal> hinter den Gerätenamen gestellt:
	<quote>da0<emphasis>s1</emphasis></quote>
	ist die erste Slice auf dem ersten SCSI-Laufwerk.  Auf einer
	Festplatte gibt es höchstens vier Slices.  In einer
	Slice des passenden Typs kann es weitere logische Slices
	geben.  Diese erweiterten Slices werden ab fünf durchnummeriert:
	<quote>ad0<emphasis>s5</emphasis></quote> ist
	die erste erweiterte Slice auf einer IDE-Platte.  Diese
	Geräte werden von Dateisystemen benutzt, die sich in
	einer kompletten Slice befinden müssen.</para>

      <para>Slices, <quote>dangerously dedicated</quote>-Festplatten
	und andere Platten enthalten Partitionen, die mit Buchstaben
	von <literal>a</literal> bis <literal>h</literal> bezeichnet
	werden.  Der Buchstabe wird an den Gerätenamen
	gehangen: <quote>da0<emphasis>a</emphasis></quote>
	ist die <literal>a</literal>-Partition des ersten
	<literal>da</literal>-Laufwerks.  Dieses Laufwerk ist
	<quote>dangerously dedicated</quote>.
	<quote>ad1s3<emphasis>e</emphasis></quote> ist
	die fünfte Partition in der dritten Slice der zweiten
	IDE-Platte.</para>

      <para>Schließlich wird noch jede Festplatte des Systems
	eindeutig bezeichnet.  Der Name einer Festplatte beginnt mit
	einem Code, der den Typ der Platte bezeichnet.  Es folgt eine
	Nummer, die angibt, um welche Festplatte es sich handelt.
	Anders als bei Slices werden Festplatten von Null beginnend
	durchnummeriert.  Gängige Festplatten-Namen sind in
	<xref linkend="basics-dev-codes"/> zusammengestellt.</para>

      <para>Wenn Sie eine Partition angeben, beinhaltet das den
	Plattennamen, <literal>s</literal>, die Slice-Nummer und den
	Buchstaben der Partition.
	Einige Beispiele finden Sie in
	<xref linkend="basics-disk-slice-part"/>.</para>

      <para>Der Aufbau einer Festplatte wird in
	<xref linkend="basics-concept-disk-model"/> dargestellt.</para>

      <para>Bei der Installation von &os; legen Sie Slices auf der
	Festplatte an, erstellen Partitionen für &os; innerhalb der
	Slice, erstellen ein Dateisystem oder Auslagerungsbereiche und
	entscheiden, welche Dateisysteme wo eingehangen werden.</para>

      <table frame="none" pgwide="1" xml:id="basics-dev-codes">
	<title>Laufwerk-Codes</title>

	<tgroup cols="2">
          <colspec colwidth="1*"/>
          <colspec colwidth="5*"/>

	  <thead>
	    <row>
	      <entry>Code</entry>

	      <entry>Bedeutung</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><filename>ad</filename></entry>

	      <entry>ATAPI (IDE) Festplatte</entry>
	    </row>

	    <row>
	      <entry><filename>da</filename></entry>

	      <entry>SCSI-Festplatte</entry>
	    </row>

	    <row>
	      <entry><filename>acd</filename></entry>

	      <entry>ATAPI (IDE) CD-ROM</entry>
	    </row>

	    <row>
	      <entry><filename>cd</filename></entry>

	      <entry>SCSI-CD-ROM</entry>
	    </row>

	    <row>
	      <entry><filename>fd</filename></entry>

	      <entry>Disketten-Laufwerk</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <example xml:id="basics-disk-slice-part">
	<title>Namen von Platten, Slices und Partitionen</title>

	<informaltable frame="none" pgwide="1">
	  <tgroup cols="2">
            <colspec colwidth="1*"/>
            <colspec colwidth="5*"/>

	    <thead>
	      <row>
		<entry>Name</entry>

		<entry>Bedeutung</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><filename>ad0s1a</filename></entry>

		<entry>Die erste Partition (<literal>a</literal>)
		  in der ersten Slice (<literal>s1</literal>) der
		  ersten IDE-Festplatte (<literal>ad0</literal>).</entry>
	      </row>

	      <row>
		<entry><filename>da1s2e</filename></entry>

		<entry>Die fünfte Partition (<literal>e</literal>)
		  der zweiten Slice (<literal>s2</literal>) auf
		  der zweiten SCSI-Festplatte
		  (<literal>da1</literal>).</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </example>

      <example xml:id="basics-concept-disk-model">
	<title>Aufteilung einer Festplatte</title>

	<para>Das folgende Diagramm zeigt die Sicht von &os; auf die
	  erste IDE-Festplatte des Systems.  Die Platte soll
	  4&nbsp;GB groß sein und zwei Slices (&ms-dos;-Partitionen)
	  mit je 2&nbsp;GB besitzen.  Die erste Slice enthält
	  ein &ms-dos;-Laufwerk (<filename>C:</filename>), die zweite
	  Slice wird von &os; benutzt.  Die &os;-Installation in
	  diesem Beispiel verwendet drei Datenpartitionen und einen
	  Auslagerungsbereich.</para>

	<para>Jede der drei Partitionen enthält ein Dateisystem.
	  Das Wurzeldateisystem ist die <literal>a</literal>-Partition.
	  In der <literal>e</literal>-Partition befindet sich
	  der <filename>/var</filename>-Verzeichnisbaum
	  und in der <literal>f</literal>-Partition befindet sich
	  der Verzeichnisbaum unterhalb von
	  <filename>/usr</filename>.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="install/disk-layout"/>
          </imageobject>

          <textobject>
	    <literallayout class="monospaced">.-----------------.  --.
|                 |    |
|  DOS / Windows  |    |
:                 :     &gt;  First slice, ad0s1
:                 :    |
|                 |    |
:=================:  ==:                               --.
|                 |    |  Partition a, mounted as /      |
|                 |     &gt; referred to as ad0s2a          |
|                 |    |                                 |
:-----------------:  ==:                                 |
|                 |    |  Partition b, used as swap      |
|                 |     &gt; referred to as ad0s2b          |
|                 |    |                                 |
:-----------------:  ==:                                 |  Partition c, no
|                 |    |  Partition e, used as /var       &gt; file system, all
|                 |     &gt; referred to as ad0s2e          |  of FreeBSD slice,
|                 |    |                                 |  ad0s2c
:-----------------:  ==:                                 |
|                 |    |                                 |
:                 :    |  Partition f, used as /usr      |
:                 :     &gt; referred to as ad0s2f          |
:                 :    |                                 |
|                 |    |                                 |
|                 |  --'                                 |
`-----------------'                                    --'</literallayout>
          </textobject>
        </mediaobject>
      </example>
  </sect1>

  <sect1 xml:id="mount-unmount">
    <title>Anhängen und Abhängen von Dateisystemen</title>

    <para>Ein Dateisystem wird am besten als ein Baum mit der
      Wurzel <filename>/</filename> veranschaulicht.
      <filename>/dev</filename>, <filename>/usr</filename>, und
      die anderen Verzeichnisse im Rootverzeichnis sind Zweige,
      die wiederum eigene Zweige wie <filename>/usr/local</filename>
      haben können.</para>

    <indexterm><primary>Root-Dateisystem</primary></indexterm>
    <para>Es gibt verschiedene Gründe, bestimmte dieser Verzeichnisse
      auf eigenen Dateisystemen anzulegen.  <filename>/var</filename>
      enthält <filename>log/</filename>, <filename>spool/</filename>
      sowie verschiedene andere temporäre
      Dateien und kann sich daher schnell füllen.  Es empfiehlt sich,
      <filename>/var</filename> von <filename>/</filename> zu trennen,
      da es schlecht ist, wenn das Root-Dateisystem voll
      läuft.</para>

    <para>Ein weiterer Grund bestimmte Verzeichnisbäume auf
      andere Dateisysteme zu legen, ist gegeben, wenn sich die
      Verzeichnisbäume auf gesonderten physikalischen oder
      virtuellen Platten, wie
      <link linkend="network-nfs">Network File System</link>
      oder CD-ROM-Laufwerken, befinden.</para>

    <sect2 xml:id="disks-fstab">
      <title>Die <filename>fstab</filename> Datei</title>

      <indexterm>
	 <primary>Dateisysteme</primary>
	 <secondary>fstab</secondary>
      </indexterm>
      <para>Während des <link linkend="boot">Boot-Prozesses</link>
	werden in <filename>/etc/fstab</filename> aufgeführte
	Verzeichnisse, sofern sie nicht mit der Option <option>noauto</option>
	versehen sind, automatisch angehangen.  Diese Datei enthält
	Einträge in folgendem Format:</para>

      <programlisting><replaceable>device</replaceable>	<replaceable>/mount-point</replaceable>	<replaceable>fstype</replaceable>	<replaceable>options</replaceable>	<replaceable>dumpfreq</replaceable>	<replaceable>passno</replaceable></programlisting>

      <variablelist>
	<varlistentry>
	  <term><literal>device</literal></term>

	  <listitem>
            <para>Ein existierender Gerätename
	      wie in <xref linkend="disks-naming"/> beschrieben.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>mount-point</literal></term>

	  <listitem>
            <para>Ein existierendes Verzeichnis, auf dem
	      das Dateisystem gemountet wird.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>fstype</literal></term>

	  <listitem>
            <para>Der Typ des Dateisystems,
	      der an &man.mount.8; weitergegeben wird.  &os;s
	      Standarddateisystem ist <literal>ufs</literal>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>options</literal></term>

	  <listitem>
	    <para>Entweder <option>rw</option>
	      für beschreibbare Dateisysteme oder <option>ro</option>
	      für schreibgeschützte Dateisysteme, gefolgt von
	      weiteren benötigten Optionen.  Eine häufig verwendete
	      Option ist <option>noauto</option> für Dateisysteme,
	      die während der normalen Bootsequenz nicht angehangen
	      werden sollen.  Weitere Optionen finden sich
	      in &man.mount.8;.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>dumpfreq</literal></term>

	  <listitem><para>Wird von &man.dump.8; benutzt, um bestimmen
	      zu können, welche Dateisysteme gesichert werden müssen.
	      Fehlt der Wert, wird <literal>0</literal>
	      angenommen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>passno</literal></term>

	  <listitem><para>Bestimmt die Reihenfolge, in der die Dateisysteme
	      überprüft werden sollen.  Für Dateisysteme,
	      die übersprungen werden sollen, ist
	      <literal>passno</literal> auf <literal>0</literal> zu setzen.  Für das
	      Root-Dateisystem, das vor allen anderen überprüft
	      werden muss, sollte der Wert von
	      <literal>passno</literal> <literal>1</literal> betragen.  Allen anderen
	      Dateisystemen sollten Werte größer <literal>1</literal> zugewiesen
	      werden.  Wenn mehrere Dateisysteme den gleichen Wert
	      besitzen, wird &man.fsck.8; versuchen, diese parallel zu
	      überprüfen.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>Lesen Sie &man.fstab.5; für weitere Informationen über das
	Format von <filename>/etc/fstab</filename> und dessen
	Optionen.</para>
    </sect2>

    <sect2 xml:id="disks-mount">
      <title>Das <command>mount</command> Kommando</title>
      <indexterm>
	<primary>Dateisysteme</primary>
	<secondary>anhängen</secondary>
      </indexterm>

      <para>Dateisysteme werden mit &man.mount.8; eingehängt.  In der
	grundlegenden Form wird es wie folgt benutzt:</para>

      <informalexample>
	<screen>&prompt.root; <userinput>mount <replaceable>device</replaceable>
<replaceable>mountpoint</replaceable></userinput></screen>
      </informalexample>

      <para>Dieser Befehl bietet viele Optionen, die in &man.mount.8;
	beschrieben werden.  Die am häufigsten verwendeten Optionen
	sind:</para>

      <variablelist>
	<title>Optionen von <command>mount</command></title>

	<varlistentry>
	  <term><option>-a</option></term>

	  <listitem>
            <para>Hängt alle Dateisysteme aus
	      <filename>/etc/fstab</filename> an.  Davon ausgenommen
	      sind Dateisysteme, die mit <quote>noauto</quote> markiert
	      sind, die mit der Option <option>-t</option> ausgeschlossen
	      wurden und Dateisysteme, die schon angehangen sind.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-d</option></term>

	  <listitem>
            <para>Führt alles bis auf den
	      <function>mount</function>-Systemaufruf aus.
	      Nützlich ist diese Option in Verbindung
	      mit <option>-v</option>.  Damit wird angezeigt, was
	      &man.mount.8; tatsächlich versuchen
	      würde, um das Dateisystem anzuhängen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-f</option></term>

	  <listitem>
	    <para>Erzwingt das Anhängen eines unsauberen Dateisystems
	      (riskant) oder die Rücknahme des Schreibzugriffs, wenn
	      der Status des Dateisystems von beschreibbar auf
	      schreibgeschützt geändert wird.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-r</option></term>

	  <listitem>
	    <para>Hängt das Dateisystem schreibgeschützt ein.  Dies
	      kann auch durch Angabe von <option>-o ro</option>
	      erreicht werden.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-t</option>
	    <replaceable>fstype</replaceable></term>

	  <listitem>
            <para>Hängt das Dateisystem mit dem angegebenen Typ an,
	      oder hängt nur Dateisysteme mit dem angegebenen Typ
	      an, wenn <option>-a</option> angegeben wurde.
	      <quote>ufs</quote> ist das Standarddateisystem.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-u</option></term>

	  <listitem>
	    <para>Aktualisiert die Mountoptionen des Dateisystems.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-v</option></term>

	  <listitem>
	    <para>Geschwätzig sein.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-w</option></term>

	  <listitem>
	    <para>Hängt das Dateisystem beschreibbar an.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>Die folgenden Optionen können durch eine Kommata
	separierte Liste an <option>-o</option> übergeben
	werden:</para>

      <variablelist>
	<varlistentry>
	  <term>nosuid</term>

	  <listitem>
	    <para>SetUID und SetGID Bits werden auf dem Dateisystem
	      nicht beachtet.  Dies ist eine nützliche
	      Sicherheitsfunktion.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 xml:id="disks-umount">
      <title>Das <command>umount</command> Kommando</title>
      <indexterm>
	<primary>Dateisysteme</primary>
	<secondary>abhängen</secondary>
      </indexterm>

      <para>&man.umount.8; hängt ein Dateisysstem ab. Dieser Befehl
	akzeptiert als Parameter entweder
	einen Mountpoint, einen Gerätenamen, <option>-a</option>
	oder <option>-A</option>.</para>

      <para>Jede Form akzeptiert <option>-f</option>, um das
	Abhängen zu erzwingen, und <option>-v</option>, um
	etwas geschwätziger zu sein.  Seien Sie bitte vorsichtig mit
	<option>-f</option>, da der Computer abstürzen kann oder es
	können Daten auf dem Dateisystem beschädigt werden.</para>

      <para>Um alle Dateisysteme abzuhängen, oder nur diejenigen, die
	mit <option>-t</option> gelistet werden, wird
	<option>-a</option> oder <option>-A</option> benutzt.
	Beachten Sie, dass <option>-a</option> das Root-Dateisystem
	nicht aushängt.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="basics-processes">
    <title>Prozesse</title>

    <para>&os; ist ein Multitasking-Betriebssystem.  Jedes
      Programm, das zu irgendeiner Zeit läuft wird als
      <firstterm>Prozess</firstterm> bezeichnet.  Jedes laufende
      Kommando startet mindestens einen neuen Prozess.  Dazu gibt
      es eine Reihe von Systemprozessen, die von &os; ausgeführt
      werden.</para>

    <para>Jeder Prozess wird durch eine eindeutige Nummer identifiziert,
      die <firstterm>Prozess-ID</firstterm>
      (<firstterm>PID</firstterm>) genannt wird.  Prozesse haben ebenso
      wie Dateien einen Besitzer und eine Gruppe, die festlegen, welche
      Dateien und Geräte der Prozess benutzen kann.  Die meisten
      Prozesse haben auch einen Elternprozess, der sie gestartet hat.
      Beispielsweise ist die Shell ein Prozess.  Jedes in Shell
      gestartete Kommando ist dann ein neuer Prozess, der die Shell
      als Elternprozess besitzt.  Die Ausnahme hiervon ist ein
      spezieller Prozess namens &man.init.8;, der beim booten immer
      als erstes gestartet wird und der immer die PID 1 hat.</para>

    <para>Um die Prozesse auf dem System zu sehen, benutzen Sie
      &man.ps.1; und &man.top.1;.  Eine statische Liste der laufenden
      Prozesse, deren PID, Speicherverbauch und die Kommandozeile, mit
      der sie gestartet wurden, erhalten Sie mit &man.ps.1;.  Um alle
      laufenden Prozesse in einer Anzeige zu sehen, die alle paar
      Sekunden aktualisiert wird, so dass Sie interaktiv sehen können
      was der Computer macht, benutzen Sie &man.top.1;.</para>

    <para>Normal zeigt <command>ps</command> nur die laufenden
      Prozesse, die dem Benutzer gehören.  Zum Beispiel:</para>

    <screen>&prompt.user; <userinput>ps</userinput>
  PID  TT  STAT      TIME COMMAND
  298  p0  Ss     0:01.10 tcsh
 7078  p0  S      2:40.88 xemacs mdoc.xsl (xemacs-21.1.14)
37393  p0  I      0:03.11 xemacs freebsd.dsl (xemacs-21.1.14)
72210  p0  R+     0:00.00 ps
  390  p1  Is     0:01.14 tcsh
 7059  p2  Is+    1:36.18 /usr/local/bin/mutt -y
 6688  p3  IWs    0:00.00 tcsh
10735  p4  IWs    0:00.00 tcsh
20256  p5  IWs    0:00.00 tcsh
  262  v0  IWs    0:00.00 -tcsh (tcsh)
  270  v0  IW+    0:00.00 /bin/sh /usr/X11R6/bin/startx -- -bpp 16
  280  v0  IW+    0:00.00 xinit /home/nik/.xinitrc -- -bpp 16
  284  v0  IW     0:00.00 /bin/sh /home/nik/.xinitrc
  285  v0  S      0:38.45 /usr/X11R6/bin/sawfish</screen>

    <para>Die Ausgabe von &man.ps.1; ist in einer Anzahl von Spalten
      organisiert.  Die <literal>PID</literal> Splate zeigt die
      Prozess-ID. PIDs werden von 1 beginnend bis 99999 zugewiesen und
      fangen wieder von vorne an. Ist eine PID breits vergeben, wird
      diese allerdings nicht erneut vergeben.


      Die Spalte <literal>TT</literal> zeigt den Terminal, auf dem das
      Programm läuft.  <literal>STAT</literal> zeigt den Status
      des Programms an und kann für die Zwecke dieser Diskussion ebenso
      wie <literal>TT</literal> ignoriert werden.  <literal>TIME</literal>
      gibt die Zeit an, die das Programm auf der CPU gelaufen ist.
      Dies ist nicht unbedingt die Zeit, die seit dem Start des Programms
      vergangen ist, da die meisten Programme hauptsächlich auf
      bestimmte Dinge warten, bevor sie wirklich CPU-Zeit verbrauchen.
      Unter der Spalte <literal>COMMAND</literal> finden Sie schließlich
      die Kommandozeile, mit der das Programm gestartet wurde.</para>

    <para>&man.ps.1; besitzt viele Optionen, um die angezeigten Informationen
      zu beeinflussen.  Eine nützliche Kombination ist
      <literal>auxww</literal>.  <option>a</option> zeigt Information
      über alle laufenden Prozesse aller Benutzer. Der Name des
      Besitzers des Prozesses, sowie Informationen
      über den Speicherverbrauch werden mit <option>u</option>
      angezeigt.  <option>x</option> zeigt auch Dämonen-Prozesse an,
      und <option>ww</option> veranlasst &man.ps.1; die komplette
      Kommandozeile für jeden Befehl anzuzeigen, anstatt sie
      abzuschneiden, wenn sie zu lang für die Bildschirmausgabe
      wird.</para>

    <para>Die Ausgabe von &man.top.1; sieht ähnlich aus:</para>

    <screen>&prompt.user; <userinput>top</userinput>
last pid: 72257;  load averages:  0.13,  0.09,  0.03    up 0+13:38:33  22:39:10
47 processes:  1 running, 46 sleeping
CPU states: 12.6% user,  0.0% nice,  7.8% system,  0.0% interrupt, 79.7% idle
Mem: 36M Active, 5256K Inact, 13M Wired, 6312K Cache, 15M Buf, 408K Free
Swap: 256M Total, 38M Used, 217M Free, 15% Inuse

  PID USERNAME PRI NICE  SIZE    RES STATE    TIME   WCPU    CPU COMMAND
72257 nik       28   0  1960K  1044K RUN      0:00 14.86%  1.42% top
 7078 nik        2   0 15280K 10960K select   2:54  0.88%  0.88% xemacs-21.1.14
  281 nik        2   0 18636K  7112K select   5:36  0.73%  0.73% XF86_SVGA
  296 nik        2   0  3240K  1644K select   0:12  0.05%  0.05% xterm
  175 root       2   0   924K   252K select   1:41  0.00%  0.00% syslogd
 7059 nik        2   0  7260K  4644K poll     1:38  0.00%  0.00% mutt
...</screen>

    <para>Die Ausgabe ist in zwei Abschnitte geteilt.  In den ersten
      fünf Kopfzeilen finden sich die zuletzt zugeteilte PID, die
      Systemauslastung (engl. <foreignphrase>load average</foreignphrase>),
      die Systemlaufzeit (die Zeit seit dem letzten Reboot) und die
      momentane Zeit.  Die weiteren Zahlen im Kopf beschreiben wie viele
      Prozesse momentan laufen (im Beispiel 47), wie viel Speicher
      und Swap verbraucht wurde und wie viel Zeit das System in den
      verschiedenen CPU-Modi verbringt.</para>

    <para>Darunter befinden sich einige Spalten mit ähnlichen
      Informationen wie in der Ausgabe von &man.ps.1;, wie
      beispielsweise die PID, den Besitzer, die verbrauchte
      CPU-Zeit und das Kommando, das den Prozess gestartet hat.
      &man.top.1; zeigt auch den Speicherverbrauch des Prozesses an,
      der in zwei Spalten aufgeteilt ist.  Die erste Spalte gibt den
      gesamten Speicherverbrauch des Prozesses an, in der zweiten
      Spalte wird der aktuelle Verbrauch angegeben.
      <application>mutt</application> hat im gezeigten
      Beispiel insgesamt 8&nbsp;MB Speicher verbraucht.  Momentan benutzt
      es allerdings nur 5&nbsp;MB.</para>

    <para>Die Anzeige wird von &man.top.1; automatisch alle zwei
      Sekunden aktualisiert.  Ein anderer Intervall kann mit
      <option>-s</option> spezifiziert werden.</para>
  </sect1>

  <sect1 xml:id="basics-daemons">
    <title>Dämonen, Signale und Stoppen von Prozessen</title>

    <para>Wenn Sie einen Editor benutzen, können Sie ihn leicht
      bedienen und Dateien laden, weil der Editor dafür Vorsorge
      getroffen hat und auf einem <firstterm>Terminal</firstterm>
      läuft.  Manche Programme erwarten keine Eingaben von einem
      Benutzer und lösen sich bei erster Gelegenheit von ihrem
      Terminal.  Ein Webserver zum Beispiel antwortet auf
      Web-Anfragen und nicht auf Benutzereingaben.  Mail-Server sind
      ein weiteres Beispiel für diesen Typ von Anwendungen.</para>

    <para>Diese Programme sind als <firstterm>Dämonen</firstterm>
      bekannt.  Der Begriff Dämon stammt aus der griechischen
      Mythologie und bezeichnet ein Wesen, das weder gut noch böse ist
      und welches unsichtbar nützliche Aufgaben verrichtet.  Deshalb
      ist das BSD Maskottchen dieser fröhlich aussehende Dämon mit
      Turnschuhen und Dreizack.</para>

    <para>Programme, die als Dämon laufen, werden entsprechend einer
      Konvention mit einem <quote>d</quote> am Ende benannt.
      <application>BIND</application> steht beispielsweise für
      Berkeley Internet Name Domain, das tatsächlich laufende Programm
      heißt aber <command>named</command>.  Der
      <application>Apache</application> Webserver wird
      <command>httpd</command> genannt und der Druckerspool-Dämon
      heißt <command>lpd</command>.  Dies ist allerdings nur eine
      Konvention. Der Dämon der Anwendung
      <application>sendmail</application> heißt beispielsweise
      <command>sendmail</command> und nicht
      <command>maild</command>.</para>

    <para>Eine Möglichkeit mit einem Dämon oder einem laufenden
      Prozess zu kommunizieren, ist über das Versenden von
      <firstterm>Signalen</firstterm> mittels &man.kill.1;.  Es gibt
      eine Reihe von verschiedenen Signalen.  Manche haben eine feste
      Bedeutung, während andere in der Dokumentation der Anwendung
      beschrieben sind.  Ein Benutzer kann ein Signal nur an einen
      Prozess senden, welcher ihm gehört.  Wird versucht ein Signal
      an einen Prozess eines anderen Benutzers zu senden, resultiert
      dies in einem Zugriffsfehler mangels fehlender Berechtigungen.
      Die Ausnahme ist der
      <systemitem class="username">root</systemitem>-Benutzer, welcher
      jedem Prozess Signale senden kann.</para>

    <para>&os; kann auch ein Signal an einen Prozess senden.  Wenn
      eine Anwendung schlecht geschrieben ist und auf Speicher
      zugreift, auf den sie nicht zugreifen soll, so sendet &os; dem
      Prozess das <firstterm>Segmentation Violation</firstterm> Signal
      (<literal>SIGSEGV</literal>).  Wenn eine Anwendung den &man.alarm.3;
      Systemaufruf benutzt hat, um nach einiger Zeit benachrichtigt zu
      werden, bekommt sie das Alarm Signal (<literal>SIGALRM</literal>)
      gesendet.</para>

    <para>Zwei Signale können benutzt werden, um einen Prozess zu stoppen:
      <literal>SIGTERM</literal> und <literal>SIGKILL</literal>.
      <literal>SIGTERM</literal> fordert den Prozess höflich zum
      Beenden auf.  Der Prozess kann das Signal abfangen und hat dann
      Gelegenheit Logdateien  zu schließen und die Aktion, die er
      durchführte, abzuschließen.  In manchen Situationen kann der
      Prozess <literal>SIGTERM</literal> ignorieren, wenn er eine
      Aktion durchführt, die nicht unterbrochen werden darf.</para>

    <para><literal>SIGKILL</literal> kann von keinem Prozess ignoriert
      werden.  Das Signal lässt sich mit <quote>Mich interessiert
      nicht, was du gerade machst, hör sofort auf damit!</quote>
      umschreiben.  Wird einem Prozess <literal>SIGKILL</literal>
      geschickt, dann wird &os; diesen sofort beenden<footnote>
	<para>Es gibt Fälle, in denen ein Prozess nicht unterbrochen
	  werden kann.  Wenn ein Prozess zum Beispiel eine Datei von
	  einem anderen Rechner auf dem Netzwerk liest und dieser
	  Rechner nicht erreichbar ist, dann ist der Prozess nicht zu
	  unterbrechen.  Wenn der Prozess den Lesezugriff nach einem
	  Timeout von typischerweise zwei Minuten aufgibt, dann wird
	  er beendet.</para>
      </footnote>.</para>

    <para>Andere häufig verwendete Signale sind
      <literal>SIGHUP</literal>, <literal>SIGUSR1</literal> und
      <literal>SIGUSR2</literal>.  Diese Signale sind für allgemeine
      Zwecke vorgesehen und verschiedene Anwendungen werden
      unterschiedlich auf diese Signale reagieren.</para>

    <para>Ändern Sie beispielsweise die Konfiguration eines
      Webservers, so muss dieser angewiesen werden, seine
      Konfiguration neu zu lesen.  Ein Neustart von
      <command>httpd</command> würde dazu führen, dass der Server für
      kurze Zeit nicht erreichbar ist.  Senden Sie dem Dämon
      stattdessen das <literal>SIGHUP</literal>-Signal.  Es sei
      erwähnt, dass verschiedene Dämonen sich anders verhalten.  Lesen
      Sie bitte die Dokumentation des entsprechenden Dämonen um zu
      überprüfen, ob der Dämon bei einem <literal>SIGHUP</literal> die
      gewünschten Ergebnisse erzielt.</para>

    <procedure>
      <title>Verschicken von Signalen</title>

      <para>Das folgende Beispiel zeigt, wie Sie &man.inetd.8; ein
	Signal schicken.  Die Konfigurationsdatei von
	<command>inetd</command> ist <filename>/etc/inetd.conf</filename>.
	Diese Konfigurationsdatei liest <command>inetd</command> ein,
	wenn er <literal>SIGHUP</literal> empfängt.</para>

      <step>
	<para>Suchen Sie mit &man.pgrep.1; die Prozess-ID des
	  Prozesses, dem Sie ein Signal schicken wollen.  In diesem
	  Beispiel ist die PID von &man.inetd.8; 198:</para>

	<screen>&prompt.user; <userinput>pgrep -l inetd</userinput>
198 inetd -wW</screen>

      </step>

      <step>
	<para>Benutzen Sie &man.kill.1;, um ein Signal zu senden.  Da
	  &man.inetd.8; dem Benutzer <systemitem
	    class="username">root</systemitem> gehört, müssen
	  Sie zuerst mit &man.su.1;
	  <systemitem class="username">root</systemitem>
	  werden:</para>

	<screen>&prompt.user; <userinput>su</userinput>
<prompt>Password:</prompt>
&prompt.root; <userinput>/bin/kill -s HUP 198</userinput></screen>

	<para>&man.kill.1; wird, wie andere &unix; Kommandos auch,
	  keine Ausgabe erzeugen, wenn das Kommando erfolgreich war.
	  Wenn Sie versuchen, einem Prozess, der nicht Ihnen gehört,
	  ein Signal zu senden, dann werden Sie die Meldung
	  <errorname>kill: <replaceable>PID</replaceable>: Operation
	    not permitted</errorname> sehen.  Ein Tippfehler bei der
	  Eingabe der PID führt dazu, dass das Signal an einen
	  falschen Prozess gesendet wird, was zu negativen Ergebnissen
	  führen kann, oder das Signal wird an eine PID gesendet die
	  derzeit nicht in Gebrauch ist, was zu dem Fehler
	  <errorname>kill: <replaceable>PID</replaceable>: No such
	    process</errorname> führt.</para>

	<note>
	  <title>Warum sollte man <command>/bin/kill</command>
	    benutzen?</title>

	  <para>Viele Shells stellen <command>kill</command> als internes
	    Kommando zur Verfügung, das heißt die Shell sendet
	    das Signal direkt, anstatt <filename>/bin/kill</filename>
	    zu starten.  Beachten Sie, dass die unterschiedlichen
	    Shells eine andere Syntax benutzen, um die Namen der
	    Signale anzugeben.  Anstatt jede Syntax zu
	    lernen, kann es einfacher sein, <command>/bin/kill
	      <replaceable>...</replaceable></command> direkt
	    aufzurufen.</para>
	</note>
      </step>
    </procedure>

    <para>Beim Versenden von anderen Signalen, ersetzen
      Sie <literal>TERM</literal> oder <literal>KILL</literal> in der
      Kommandozeile mit dem entsprechenden Signal.</para>

    <important>
      <para>Das zufällige Beenden eines Prozesses kann gravierende
	Auswirkungen haben.  Insbesondere &man.init.8;, mit der PID 1,
	ist ein Spezialfall.  <command>/bin/kill -s KILL 1</command>
	ist ein schneller, jedoch nicht empfohlener Weg, das System
	herunterzufahren.
	Überprüfen Sie die Argumente von &man.kill.1;
	<emphasis>immer</emphasis> zweimal <emphasis>bevor</emphasis>
	Sie <keycap>Return</keycap> drücken.</para>
    </important>
  </sect1>

  <sect1 xml:id="shells">
    <title>Shells</title>
    <indexterm><primary>Shells</primary></indexterm>
    <indexterm><primary>Kommandozeile</primary></indexterm>

    <para>&os; stellt mit der Shell eine Kommandozeilen-Schnittstelle
      zur Verfügung.  Eine Shell empfängt Befehle von einem
      Eingabekanal und führt diese aus.  Viele Shells bieten bieten
      eingebaute Funktionen, die die tägliche Arbeit erleichtern,
      beispielsweise eine Dateiverwaltung, die Vervollständigung von
      Dateinamen (Globbing), Kommandozeilen-Editor, sowie Makros und
      Umgebungsvariablen.  &os; enthält die Shells
      <command>sh</command> (Bourne Shell) und <command>tcsh</command>
      (verbesserte C-Shell) im Basissystem.  Weitere Shells, wie
      <command>zsh</command> oder <command>bash</command>, befinden
      sich in der Ports-Sammlung.</para>

    <para>Die verwendete Shell ist letztlich eine Frage des
      Geschmacks.  Ein C-Programmierer, findet vielleicht eine
      C-artige Shell wie <command>tcsh</command> angenehmer.  Ein
      Linux-Benutzer bevorzugt vielleicht <command>bash</command>.
      Jede Shell hat ihre speziellen Eigenschaften, die mit der
      bevorzugten Arbeitsumgebung des Benutzers harmonieren kann oder
      nicht.  Deshalb stehen mehrere Shells zur Auswahl.</para>

    <para>Ein verbreitetes Merkmal in Shells ist die
      Dateinamen-Vervollständigung.  Nachdem der Benutzer einige
      Buchstaben eines Kommandos oder eines Dateinamen eingeben hat,
      vervollständigt die Shell den Rest automatisch durch
      drücken der <keycap>Tab</keycap>-Taste.  Angenommen, Sie
      haben zwei Dateien <filename>foobar</filename> und
      <filename>foo.bar</filename>.  Um <filename>foo.bar</filename>
      zu löschen,  geben Sie folgendes ein:
      <command>rm fo[Tab].[Tab]</command></para>

    <para>Die Shell sollte dann <command>rm
      foo[BEEP].bar</command> ausgeben.</para>

    <para>[BEEP] meint den Rechner-Piepser, den die Shell ausgibt um
      anzuzeigen, dass es den Dateinamen nicht vervollständigen
      konnte, da es mehrere Möglichkeiten gibt.  Beide Dateien
      <filename>foobar</filename> und <filename>foo.bar</filename>
      beginnen mit <literal>fo</literal>.  Nach der Eingabe von
      <literal>.</literal> und erneutem drücken der
      <keycap>Tab</keycap>-Taste, war die Shell in der Lage den Rest
      auszufüllen.</para>

    <indexterm><primary>Umgebungsvariablen</primary></indexterm>

    <para>Ein weiteres Merkmal der Shell ist der Gebrauch von
      Umgebungsvariablen.  Dies sind veränderbare Schlüsselpaare
      im Umgebungsraum der Shell, die jedes von der Shell aufgerufene
      Programm lesen kann.  Daher enthält der Umgebungsraum viele
      Konfigurationsdaten für Programme.  Die folgende Liste zeigt
      verbreitete Umgebungsvariablen und deren Bedeutung:</para>

    <informaltable frame="none" pgwide="1">
      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>Variable</entry>
	    <entry>Beschreibung</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry><envar>USER</envar></entry>
	    <entry>Name des angemeldeten Benutzers.</entry>
	  </row>

	  <row>
	    <entry><envar>PATH</envar></entry>
	    <entry>Liste mit Verzeichnissen (getrennt durch Doppelpunkt)
              zum Suchen nach Programmen.</entry>
	  </row>

	  <row>
	    <entry><envar>DISPLAY</envar></entry>
	    <entry>Der Name des
	      <application>Xorg</application>-Bildschirms, auf dem
	      Ausgaben erfolgen sollen.</entry>
	  </row>

	  <row>
	    <entry><envar>SHELL</envar></entry>
	    <entry>Die aktuelle Shell.</entry>
	  </row>

	  <row>
	    <entry><envar>TERM</envar></entry>
	    <entry>Name des Terminaltyps des Benutzers.  Benutzt, um die
              Fähigkeiten des Terminals zu bestimmen.</entry>
	  </row>

	  <row>
	    <entry><envar>TERMCAP</envar></entry>
	    <entry>Datenbankeintrag der Terminal Escape Codes,
              benötigt um verschieden Terminalfunktionen
              auszuführen.</entry>
	  </row>

	  <row>
	    <entry><envar>OSTYPE</envar></entry>
	    <entry>Typ des Betriebssystems.</entry>
	  </row>

	  <row>
	    <entry><envar>MACHTYPE</envar></entry>
	    <entry>Die CPU-Architektur des Systems.</entry>
	  </row>

	  <row>
	    <entry><envar>EDITOR</envar></entry>
	    <entry>Vom Benutzer bevorzugter Text-Editor.</entry>
	  </row>

	  <row>
	    <entry><envar>PAGER</envar></entry>
	    <entry>Vom Benutzer bevorzugter Text-Betrachter.</entry>
	  </row>

	  <row>
	    <entry><envar>MANPATH</envar></entry>
	    <entry>Liste mit Verzeichnissen (getrennt durch Doppelpunkt)
              zum Suchen nach Manualpages.</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <indexterm>
      <primary>Shells</primary>
      <secondary>Bourne Shell</secondary>
    </indexterm>
    <para>Das Setzen von Umgebungsvariablen unterscheidet sich
      von Shell zu Shell.  In <command>tcsh</command> und
      <command>csh</command> wird dazu <command>setenv</command>
      benutzt.  <command>sh</command> und <command>bash</command>
      benutzen <command>export</command> um Umgebungsvariablen zu
      setzen.  Dieses Beispiel für die <command>tcsh</command>-Shell
      setzt die Variable <envar>EDITOR</envar> auf
      <filename>/usr/local/bin/emacs</filename>:</para>

    <screen>&prompt.user; <userinput>setenv EDITOR /usr/local/bin/emacs</userinput></screen>

    <para>Der entsprechende Befehl für <command>bash</command>
      wäre:</para>

    <screen>&prompt.user; <userinput>export EDITOR="/usr/local/bin/emacs"</userinput></screen>

    <para>Um eine Umgebungsvariable zu expandieren, geben Sie in der
      Kommandozeile das Zeichen <literal>$</literal> vor dessen Namen
      ein.  Zum Beispiel gibt <command>echo $TERM</command> den
      aktuellen Wert von<envar>$TERM</envar> aus.</para>

    <para>Shells behandeln Spezialzeichen, so genannte
      Metazeichen, als besondere Darstellungen für Daten.
      Das häufigste Zeichen ist <literal>*</literal>, das eine
      beliebige Anzahl Zeichen in einem Dateinamen repräsentiert.
      Metazeichen können zur Vervollständigung von
      Dateinamen (Globbing) benutzt werden.  Beispielsweise liefert
      <command>echo *</command> nahezu das gleiche wie
      <command>ls</command>, da die Shell alle
      Dateinamen die mit <literal>*</literal> übereinstimmen, an
      <command>echo</command> weitergibt.</para>

    <para>Um zu verhindern, dass die Shell ein Sonderzeichen
      interpretiert, schützt man es, indem man einen
      Backslash (<literal>\</literal>) voranstellt.  Zum Beispiel
      zeigt <command>echo $TERM</command> die Einstellung des
      Terminals an, wohingegen <command>echo \$TERM</command> einfach
      die Zeichenfolge <literal>$TERM</literal> ausgibt.</para>

    <sect2 xml:id="changing-shells">
      <title>Ändern der Shell</title>

      <para>Der einfachste Weg die Standard Shell zu ändern, ist
        <command>chsh</command> zu benutzen.
        <command>chsh</command> startet den Editor, welcher durch
	die Umgebungsvariable <envar>EDITOR</envar> gesetzt ist.
	Standardmäßig ist dies <command>vi</command>.
        Tragen Sie in die Zeile die mit <quote>Shell:</quote> beginnt,
        den absoluten Pfad der neuen Shell ein.</para>

      <para>Alternativ setzt <command>chsh -s</command> die Shell,
	ohne dabei einen Editor aufzurufen.  Um die Shell
        zum Beispiel auf <command>bash</command> zu ändern, geben Sie
	folgenden Befehl ein:</para>

      <screen>&prompt.user; <userinput>chsh -s /usr/local/bin/bash</userinput></screen>

      <note>
	<para>Die neue Shell <emphasis>muss</emphasis> in
	  <filename>/etc/shells</filename> aufgeführt sein.  Wurde die
	  Shell aus der <link linkend="ports">Ports-Sammlung</link>
	  installiert, sollte sie automatisch zu dieser Datei
	  hinzugefügt worden sein.  Wenn der Eintrag fehlt, nutzen Sie
	  folgenden Befehl, und ersetzen Sie den Pfad mit dem Pfad zur
	  gewünschten Shell:</para>

      <screen>&prompt.root; <userinput>echo &quot;/usr/local/bin/bash&quot; &gt;&gt; /etc/shells</userinput></screen>

       <para>Danach können Sie <command>chsh</command> aufrufen.</para>
     </note>
   </sect2>
  </sect1>

  <sect1 xml:id="editors">
    <title>Text-Editoren</title>
    <indexterm><primary>Text Editoren</primary></indexterm>
    <indexterm><primary>Editoren</primary></indexterm>

    <para>Die meiste Konfiguration unter &os; wird durch
      das Editieren von Textdateien erledigt.  Deshalb ist es eine
      gute Idee, mit einem Texteditor vertraut zu werden.  &os; hat
      ein paar davon im Basissystem und sehr viel mehr in der
      Ports-Sammlung.</para>

    <indexterm>
      <primary><command>ee</command></primary>
    </indexterm>

    <indexterm>
      <primary>Text Editoren</primary>
      <secondary><command>ee</command></secondary>
    </indexterm>

    <para>Ein einfach zu erlernender Editor ist
      <application>ee</application>, was für
      <foreignphrase>easy editor</foreignphrase> steht.
      Um diesen Editor zu starten, gibt man in der
      Kommandozeile <command>ee filename</command> ein, wobei
      <replaceable>filename</replaceable> den Namen der zu editierenden
      Datei darstellt.  Einmal im Editor, finden sich alle Editor-Funktionen oben im
      Display aufgelistet.  Das Einschaltungszeichen
      <literal>^</literal> steht für die <keycap>Ctrl</keycap> (oder
      <keycap>Strg</keycap>) Taste, mit <literal>^e</literal> ist also die
      Tastenkombination <keycombo action="simul"><keycap>Ctrl</keycap><keycap>e</keycap></keycombo>
      gemeint.  Um <application>ee</application> zu verlassen, drücken
      Sie <keycap>Esc</keycap> und wählen dann im Hauptmenü <option>leave
        editor</option> aus.  Der Editor fragt nach, ob Sie speichern
      möchten, wenn die Datei verändert wurde.</para>

    <indexterm>
      <primary><command>vi</command></primary>
    </indexterm>
    <indexterm>
      <primary>Text Editoren</primary>
      <secondary><command>vi</command></secondary>
    </indexterm>
    <indexterm>
      <primary><command>emacs</command></primary>
    </indexterm>
    <indexterm>
      <primary>Text Editoren</primary>
      <secondary><command>emacs</command></secondary>
    </indexterm>
    <para>&os; verfügt über leistungsfähigere
      Editoren wie <application>vi</application> als Teil des
      Basissystems.  Andere Editoren wie <application>emacs</application>
      und <application>vim</application> sind Teil der Ports-Sammlung.
      Diese Editoren bieten höhere Funktionalität, jedoch auf Kosten einer etwas
      schwierigeren Erlernbarkeit.  Das Erlernen eines
      leistungsfähigeren Editors, wie <application>vim</application>
      oder <application>Emacs</application>, kann auf lange Sicht Zeit
      einsparen.</para>

    <para>Viele Anwendungen, die Dateien verändern oder Texteingabe
      erwarten, werden automatisch einen Texteditor öffnen.  Um den
      Standardeditor zu ändern, wird die Umgebungsvariable
      <envar>EDITOR</envar> gesetzt, wie im Abschnitt
      <link linkend="shells">Shells</link> beschrieben.</para>
  </sect1>

  <sect1 xml:id="basics-devices">
    <title>Geräte und Gerätedateien</title>

    <para>Der Begriff Gerät wird meist in Verbindung mit Hardware
      wie Laufwerken, Druckern, Grafikkarten oder Tastaturen gebraucht.
      Der Großteil der Meldungen, die beim Booten von &os; angezeigt
      werden, beziehen sich auf gefundene Geräte.  Eine Kopie dieser
      Bootmeldungen wird in <filename>/var/run/dmesg.boot</filename>
      gespeichert.</para>

    <para>Jedes Gerät verfügt über einen Gerätenamen und Gerätenummer.
      Zum Beispiel steht <filename>acd0</filename> für das erste
      IDE CD-ROM Laufwerk, während <filename>kbd0</filename> die
      Tastatur repräsentiert.</para>

    <para>Auf die meisten Geräte wird unter &os; über spezielle
      Gerätedateien im <filename>/dev</filename> Verzeichnis
      zugegriffen.</para>

    <sect2>
      <title>Anlegen von Gerätedateien</title>
      <para>Wenn sie ein neues Gerät zu Ihrem System hinzufügen,
	oder die Unterstützung für zusätzliche Geräte
	kompilieren, müssen ein oder mehrere Gerätedateien
	erstellt werden.</para>

      <sect3>
	<title><literal>DEVFS</literal> (Gerätedateisystem)</title>

	<para>Das Gerätedateisystem <literal>DEVFS</literal>
	  ermöglicht durch den
	  Namensraum des Dateisystems Zugriff auf den Namensraum der
	  Geräte im Kernel.  Damit müssen Gerätedateien
	  nicht mehr extra angelegt werden, sondern werden von
	  <literal>DEVFS</literal> automatisch verwaltet.  Weitere
	  Informationen finden Sie in &man.devfs.5;.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="binary-formats">
    <title>Binärformate</title>

    <para>Um zu verstehen, warum &os; das Format
      &man.elf.5; benutzt, müssen zunächst die drei gegenwärtig
      <quote>dominanten</quote> ausführbaren Formate
      für &unix; beschrieben werden:</para>

    <itemizedlist>
      <listitem>
        <para>&man.a.out.5;</para>

        <para>Das älteste und <quote>klassische</quote>
          Objektformat von &unix; Systemen.  Es benutzt einen kurzen,
	  kompakten Header mit einer
	  <foreignphrase>&man.magic.5; number</foreignphrase> am
	  Anfang, die oft benutzt wird, um das Format zu
	  charakterisieren.  Es enthält drei geladene Segmente: .text,
	  .data und .bss, sowie eine Symboltabelle und eine
          Stringtabelle.</para>
      </listitem>

      <listitem>
        <para><acronym>COFF</acronym></para>

        <para>Das Objektformat von SVR3.  Der Header
          enthält eine <quote>Sectiontable</quote>, die mehr enthalten
          kann als nur .text, .data und .bss Sektionen..</para>
      </listitem>

      <listitem>
        <para>&man.elf.5;</para>

        <para>Der Nachfolger von <acronym>COFF</acronym>.
          Kennzeichnend sind mehrere Sections und mögliche
          32-Bit- oder 64-Bit-Werte.  Ein wesentlicher Nachteil ist,
	  dass <acronym>ELF</acronym> unter der Annahme entworfen
	  wurde, dass es nur eine ABI (Application Binary Interface)
	  pro Systemarchitektur geben wird.  Tatsächlich ist diese
	  Annahme falsch, denn nicht einmal für die kommerzielle
	  SYSV-Welt (in der es mindestens drei ABIs gibt: SVR4,
	  Solaris, SCO) trifft sie zu.</para>

        <para>&os; versucht dieses Problem zu umgehen, indem
          ein Werkzeug bereitgestellt wird, um ausführbare
          Dateien im <acronym>ELF</acronym>-Format mit
          Informationen über die ABI zu versehen, zu der
	  sie passen.  Weitere Informationen finden Sie in
	  &man.brandelf.1;.</para>
      </listitem>
    </itemizedlist>

    <para>&os; kommt aus dem <quote>klassischen</quote> Lager
      und verwendete traditionell das Format &man.a.out.5;, eine
      Technik, die bereits über viele BSD-Releases
      hinweg eingesetzt und geprüft worden ist.  Obwohl es
      bereits seit einiger Zeit möglich war, auf einem
      &os;-System auch Binaries (und Kernel) im
      <acronym>ELF</acronym>-Format zu erstellen und
      auszuführen, widersetzte &os; sich anfangs dem
      <quote>Druck</quote>, auf <acronym>ELF</acronym> als
      Standardformat umzusteigen.  Warum?  Nun, als
      Linux die schmerzhafte Umstellung auf
      <acronym>ELF</acronym> durchführte, weil der
      unflexible, auf Sprungtabellen basierte Mechanismus
      für <quote>Shared-Libraries</quote> der die Konstruktion von
      Shared-Libraries für Hersteller und Entwickler kompliziert
      machte.  Da die verfügbaren <acronym>ELF</acronym>-Werkzeuge
      eine Lösung für das Problem mit den Shared-Libraries
      anboten und generell als <quote>ein Schritt
      vorwärts</quote> angesehen wurden, wurde der Aufwand
      für die Umstellung als notwendig akzeptiert und die
      Umstellung wurde durchgeführt.  Unter &os; ist der
      Mechanismus von Shared-Libraries enger an den Stil des
      Shared-Library-Mechanismus von &sunos;
      angelehnt und einfacher zu verwenden.</para>

    <para>Ja, aber warum gibt es so viele unterschiedliche Formate?
      Damals zu Zeiten der PDP-11, als simple Hardware ein einfaches,
      kleines System unterstützte, war <filename>a.out</filename>
      absolut passend für die Aufgabe, Binaries darzustellen.  Als
      &unix; portiert wurde, wurde auch das
      <filename>a.out</filename>-Format beibehalten, weil es für die
      frühen Portierungen auf Architekturen wie den Motorola 68k oder
      die VAX ausreichte.</para>

    <para>Dann dachte sich ein schlauer Hardware-Ingenieur,
      dass, wenn er Software zwingen könnte, einige
      Tricks anzustellen, es ihm möglich wäre, ein
      paar Gatter im Design zu sparen, und die CPU
      schneller zu machen.  <filename>a.out</filename> war für diese
      neue Art von Hardware, bekannt als <acronym>RISC</acronym>,
      schlecht geeignet.  Viele neue Formate wurden entwickelt, um
      eine bessere Leistung auf dieser Hardware zu erreichen, als mit
      dem begrenzten, simplen <filename>a.out</filename>-Format.
      <acronym>COFF</acronym>, <acronym>ECOFF</acronym> und
      einige andere wurden erdacht und ihre Grenzen
      untersucht, bevor man sich auf <acronym>ELF</acronym>
      festgelegt hat.</para>

    <para>Hinzu kam, dass die Größe von
      Programmen gewaltig wurde und Festplatten sowie
      physikalischer Speicher immer noch relativ klein waren.
      Also wurde das Konzept von Shared-Libraries geboren.  Die
      virtuelle Speicherverwaltung wurde auch immer fortgeschrittener.
      Obwohl bei jedem dieser Fortschritte das
      <filename>a.out</filename>-Format benutzt worden ist,
      wurde sein Nutzen mit jedem neuen Merkmal mehr gedehnt.
      Zusätzlich wollte man Dinge dynamisch zur
      Ausführungszeit laden, oder Teile eines Programms
      nach der Initialisierung wegwerfen, um Hauptspeicher
      oder Swap-Speicher zu sparen.  Programmiersprachen
      wurden immer fortschrittlicher und man wollte, dass
      Code automatisch vor der main-Funktion aufgerufen wird.
      Das <filename>a.out</filename>-Format wurde oft
      überarbeitet, um alle diese Dinge zu ermöglichen
      und sie funktionierten auch für einige Zeit.
      <filename>a.out</filename> konnte diese Probleme nicht
      ohne ein ständiges Ansteigen eines Overheads im Code
      und in der Komplexität handhaben.  Obwohl
      <acronym>ELF</acronym> viele dieser Probleme löste,
      wäre es sehr aufwändig, ein System umzustellen, das
      im Grunde genommen funktionierte.  Also musste
      <acronym>ELF</acronym> warten, bis es aufwändiger war, bei
      <filename>a.out</filename> zu bleiben, als zu
      <acronym>ELF</acronym> überzugehen.</para>

    <para>Im Laufe der Zeit haben sich die Erstellungswerkzeuge,
      von denen &os; seine Erstellungswerkzeuge abgeleitet
      hat, speziell der Assembler und der Loader, in zwei
      parallele Zweige entwickelt.  Im &os;-Zweig wurden
      Shared-Libraries hinzugefügt und einige Fehler
      behoben.  Das GNU-Team, das diese Programme
      ursprünglich geschrieben hat, hat sie umgeschrieben
      und eine simplere Unterstützung zur Erstellung von
      Cross-Compilern durch beliebiges Einschalten verschiedener
      Formate hinzugefügt.  Viele Leute wollten
      Cross-Compiler für &os; erstellen, aber sie hatten
      kein Glück, denn &os;'s ältere Sourcen
      für <application>as</application> und <application>ld</application>
      waren hierzu nicht geeignet.  Die neuen
      GNU-Werkzeuge (<application>binutils</application>) unterstützen
      Cross-Compilierung, <acronym>ELF</acronym>, Shared-Libraries und
      C++-Erweiterungen.  Weiterhin geben viele
      Hersteller <acronym>ELF</acronym>-Binaries heraus und &os;
      sollte in der Lage sein, diese ausführen.</para>

    <para><acronym>ELF</acronym> ist ausdrucksfähiger als
      <filename>a.out</filename> und gestattet eine bessere Erweiterbarkeit
      des Basissystems.  Die <acronym>ELF</acronym>-Werkzeuge werden
      besser gewartet und bieten Unterstützung für Cross-Compilierung.
      <acronym>ELF</acronym> mag etwas langsamer sein, als
      <filename>a.out</filename>, aber zu versuchen, das zu messen,
      könnte schwierig werden.  Es gibt unzählige Details, in
      denen sich die beiden Formate unterscheiden, wie sie Pages
      abbilden, oder Initialisierungscode handhaben.</para>
  </sect1>

  <sect1 xml:id="basics-more-information">
    <title>Weitere Informationen</title>

    <sect2 xml:id="basics-man">
      <title>Manualpages</title>
      <indexterm><primary>Manualpages</primary></indexterm>

      <para>Die umfassendste Dokumentation rund um &os; gibt es in
        Form von Manualpages.  Annähernd jedes Programm im System
        bringt eine kurze Referenzdokumentation mit, die die
        grundsätzliche Funktion und verschiedene Parameter
	erklärt.  Diese Manuals können mit <command>man</command>
	eingesehen werden:</para>

      <screen>&prompt.user; <userinput>man Kommando</userinput></screen>

      <para><literal>Kommando</literal> ist der Name des Kommandos,
        über das Sie etwas erfahren wollen.  Um beispielsweise
        mehr über das Kommando <command>ls</command> zu lernen,
        geben Sie ein:</para>

      <screen>&prompt.user; <userinput>man ls</userinput></screen>

      <para>Die Online-Manuals sind in nummerierte Sektionen
        unterteilt:</para>

      <orderedlist>
	<listitem>
	  <para>Benutzerkommandos.</para>
	</listitem>

	<listitem>
	  <para>Systemaufrufe und Fehlernummern.</para>
	</listitem>

	<listitem>
	  <para>Funktionen der C Bibliothek.</para>
	</listitem>

	<listitem>
	  <para>Gerätetreiber.</para>
	</listitem>

	<listitem>
	  <para>Dateiformate.</para>
	</listitem>

	<listitem>
	  <para>Spiele und andere Unterhaltung.</para>
	</listitem>

	<listitem>
	  <para>Verschiedene Informationen.</para>
	</listitem>

	<listitem>
	  <para>Systemverwaltung und -Kommandos.</para>
	</listitem>

	<listitem>
	  <para>Kernel Entwickler.</para>
	</listitem>
      </orderedlist>

      <para>In einigen Fällen kann dasselbe Thema in mehreren
        Sektionen auftauchen.  Es gibt zum Beispiel ein <command>chmod</command>
        Benutzerkommando und einen <function>chmod()</function>
        Systemaufruf.  Sie können <command>man</command>
        sagen, aus welcher Sektion Sie die Information erhalten
        möchten, indem Sie die Sektionsnummer mit angeben:</para>

      <screen>&prompt.user; <userinput>man 1 chmod</userinput></screen>

      <para>Dies wird Ihnen die Manualpage für das Benutzerkommando
        <command>chmod</command> zeigen.  Verweise auf eine Sektion
        der Manualpages werden traditionell in Klammern
        gesetzt.  So bezieht sich &man.chmod.1; auf das
        Benutzerkommando <command>chmod</command> und mit
        &man.chmod.2; ist der Systemaufruf gemeint.</para>

      <para>Wenn Sie den Namen des Kommandos kennen, benutzen Sie
	<command>man -k</command>, um nach Schlüsselbegriffen in den
	Kommandobeschreibungen zu suchen:</para>

      <screen>&prompt.user; <userinput>man -k <replaceable>mail</replaceable>
</userinput></screen>

      <para>Dieser Befehl zeigt eine Liste von Kommandos, deren
        Beschreibung das Schlüsselwort
        <quote>mail</quote> enthält.  Die gleiche Funktionalität
        erhalten Sie auch, wenn Sie &man.apropos.1;
        benutzen.</para>

      <para>Um herauszufinden, was die Kommandos in
	<filename>/usr/bin</filename> tun, geben Sie ein:</para>

      <screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>man -f *</userinput></screen>

      <para>Dasselbe erreichen Sie durch Eingabe von:</para>

      <screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>whatis *</userinput></screen>

    </sect2>

    <sect2 xml:id="basics-info">
      <title>GNU Info Dateien</title>

      <para>&os; enthält viele Anwendungen und Utilities
        der Free Software Foundation (FSF).  Zusätzlich zu den
	Manualpages können diese Programme Hypertext-Dokumente
	enthalten, die <literal>info</literal>-Seiten genannt werden.
        Diese Dokumente können mit <command>info</command>
	ansehen kann.  Wenn Sie <package>editors/emacs</package>
	installiert haben, können Sie auch den info-Modus von
	<application>emacs</application> benutzen.</para>

      <para>Um &man.info.1; zu benutzen, geben Sie ein:</para>

      <screen>&prompt.user; <userinput>info</userinput></screen>

      <para>Eine kurze Einführung gibt es mit
        <literal>h</literal>; eine Befehlsreferenz erhalten Sie durch
        Eingabe von: <literal>?</literal>.</para>
    </sect2>
  </sect1>
</chapter>
