<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde$
     basiert auf: r51390
-->
<chapter xmlns="http://docbook.org/ns/docbook"
  xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0"
  xml:id="basics">

  <title>Grundlagen des &os; Betriebssystems</title>
    <!--
    <authorgroup>
      <author><personname><firstname>Chris</firstname><surname>Shumway</surname></personname><contrib>Umgeschrieben von </contrib></author>
    </authorgroup>

    <authorgroup>
      <author><personname><firstname>Uwe</firstname><surname>Pierau</surname></personname><contrib>Übersetzt von </contrib></author>
    </authorgroup>
    -->

  <sect1 xml:id="basics-synopsis">
    <title>Übersicht</title>

    <para>Dieses Kapitel umfasst die grundlegenden Kommandos
      und Funktionsweisen des &os;-Betriebssystems.  Viel von diesem
      Material gilt auch für jedes andere &unix;-artige System.
      Neue Benutzer von &os; sollten dieses Kapitel aufmerksam
      lesen.</para>

    <para>Dieser Abschnitt behandelt die folgenden Themen:</para>

    <itemizedlist>
      <listitem>
	<para>virtuelle Konsolen,</para>
      </listitem>
      <listitem>
	<para>Erstellung und Verwaltung von Benutzern und Gruppen in
	  &os;,</para>
      </listitem>
      <listitem>
	<para>Zugriffsrechte unter &unix; sowie Datei-Flags unter
	  &os;,</para>
      </listitem>
      <listitem>
	<para>Zugriffskontrolllisten für Dateisysteme,</para>
      </listitem>
      <listitem>
	<para>die Verzeichnisstruktur von &os;,</para>
      </listitem>
      <listitem>
	<para>Organisation von Dateisystemen unter &os;,</para>
      </listitem>
      <listitem>
	<para>Ein- und Abhängen von Dateisystemen,</para>
      </listitem>
      <listitem>
	<para>Prozesse, Dämonen und Signale,</para>
      </listitem>
      <listitem>
	<para>Shells und die Login-Umgebung,</para>
      </listitem>
      <listitem>
	<para>Texteditoren,</para>
      </listitem>
      <listitem>
	<para>Geräte und Gerätedateien,</para>
      </listitem>
      <listitem>
	<para>wie Sie in den Manualpages nach weiteren Informationen
	  suchen können.</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 xml:id="consoles">
    <title>Virtuelle Konsolen und Terminals</title>

    <indexterm><primary>virtuelle Konsole</primary></indexterm>
    <indexterm><primary>Terminals</primary></indexterm>
    <indexterm><primary>Konsole</primary></indexterm>

    <para>Wenn das &os;-System so konfiguriert wurde, dass es ohne
      eine grafische Benutzeroberfläche startet, wird das System
      nach dem Start einen Anmeldeprompt ausgeben, wie in diesem
      Beispiel zu sehen:</para>

    <screen>FreeBSD/amd64 (pc3.example.org) (ttyv0)

login:</screen>

    <para>Die erste Zeile enthält einige Informationen über das
      System.  <literal>amd64</literal> zeigt an, dass auf dem
      System in diesem Beispiel eine 64-Bit Version von &os;
      läuft.  Der Hostname ist
      <systemitem>pc3.example.org</systemitem> und
      <filename>ttyv0</filename> gibt an, dass dies die
      <quote>Systemkonsole</quote> ist.  Die zweite Zeile zeigt den
      Anmeldeprompt.</para>

    <para>Da &os; ein Mehrbenutzersystem ist, muss es die
      verschiedenen Benutzer voneinander unterscheiden können.  Dies
      wird dadurch erreicht, dass sich jeder Benutzer zuerst am
      System anmelden muss, um Zugriff auf die Programme zu
      bekommen.  Jeder Benutzer hat einen eindeutigen
      <quote>Benutzernamen</quote> und ein persönliches
      <quote>Kennwort</quote>.</para>

    <para>Um sich auf der Systemkonsole anzumelden, geben Sie den
      Benutzernamen ein, der während der Systeminstallation, wie in
      <xref linkend="bsdinstall-addusers"/> beschrieben,
      konfiguriert wurde und drücken Sie <keycap>Enter</keycap>.
      Geben Sie dann das zum Benutzernamen zugeordnete Passwort ein
      und drücken <keycap>Enter</keycap>.  Das Passwort wird aus
      Sicherheitsgründen
      <emphasis>nicht angezeigt</emphasis>.</para>

    <para>Sobald das richtige Passwort eingegeben wird, wird die
      Nachricht des Tages (<acronym>MOTD</acronym>) gefolgt von
      einer Eingabeaufforderung ausgegeben.  In Abhängigkeit der
      verwendeten Shell des Benutzers wird der Prompt mit dem
      Zeichen <literal>#</literal>, <literal>$</literal> oder
      <literal>%</literal> dargestellt.  Der Prompt zeigt an,  dass
      der Benutzer jetzt an der &os; Systemkonsole angemeldet ist
      und nun alle verfügbaren Befehle probieren kann.</para>

    <sect2 xml:id="consoles-virtual">
      <title>Virtuelle Konsolen</title>

      <para>Obwohl die Systemkonsole dazu verwendet werden kann, um
	mit dem System zu interagieren,  wird sich ein Benutzer in der
	Regel an einer virtuellen Konsole im &os;-System anmelden.
	Das liegt daran, dass die Systemmeldungen standardmäßig auf
	der Systemkonsole angezeigt werden und somit die Meldungen des
	Befehls oder einer Datei, die der Benutzer gerade bearbeitet,
	überschrieben werden.</para>

      <para>In der Voreinstellung ist &os; so konfiguriert, dass viele
	virtuelle Konsolen zur Eingabe von Befehlen zur Verfügung
	stehen.  Jede virtuelle Konsole verfügt über einen eigenen
	Anmeldeprompt und eine Shell.  Sie können ganz einfach
	zwischen den virtuellen Konsolen umschalten.  Dies ist
	vergleichbar mit mehreren geöffneten Fenstern in einer
	graphischen Umgebung.</para>

      <para>Die Tastenkombinationen
	<keycombo><keycap>Alt</keycap><keycap>F1</keycap></keycombo>
	bis
	<keycombo><keycap>Alt</keycap><keycap>F8</keycap></keycombo>
	sind in &os; zum Umschalten zwischen virtuellen Konsolen
	reserviert.  Verwenden Sie
	<keycombo><keycap>Alt</keycap><keycap>F1</keycap></keycombo>
	um auf die Systemkonsole (<filename>ttyv0</filename>) zu
	wechseln,
	<keycombo><keycap>Alt</keycap><keycap>F2</keycap></keycombo>
	für die erste virtuelle Konsole (<filename>ttyv1</filename>,
	<keycombo><keycap>Alt</keycap><keycap>F3</keycap></keycombo>
	für die zweite virtuelle Konsole (<filename>ttyv2</filename>,
	und so weiter.</para>

      <para>Beim Wechsel von einer Konsole zur nächsten wird die
	Bildschirmausgabe von &os; verwaltet.  Dies erzeugt die
	Illusion mehrerer Bildschirme und Tastaturen, an denen
	Kommandos abgesetzt werden können.  Die Programme, die in
	einer virtuellen Konsole gestartet werden, laufen auch dann
	weiter, wenn der Benutzer auf eine andere virtuelle Konsole
	wechselt.</para>

      <para>Lesen Sie &man.kbdcontrol.1;, &man.vidcontrol.1;,
	&man.atkbd.4;, &man.syscons.4; sowie &man.vt.4; für eine recht
	technische Beschreibung der &os;-Konsole und der
	Tastatur-Treiber.</para>

      <para>In &os; wird die Anzahl der verfügbaren virtuellen
	Konsolen in diesem Abschnitt von
	<filename>/etc/ttys</filename> konfiguriert:</para>

      <programlisting># name    getty                         type  status comments
#
ttyv0   "/usr/libexec/getty Pc"         xterm   on  secure
# Virtual terminals
ttyv1   "/usr/libexec/getty Pc"         xterm   on  secure
ttyv2   "/usr/libexec/getty Pc"         xterm   on  secure
ttyv3   "/usr/libexec/getty Pc"         xterm   on  secure
ttyv4   "/usr/libexec/getty Pc"         xterm   on  secure
ttyv5   "/usr/libexec/getty Pc"         xterm   on  secure
ttyv6   "/usr/libexec/getty Pc"         xterm   on  secure
ttyv7   "/usr/libexec/getty Pc"         xterm   on  secure
ttyv8   "/usr/X11R6/bin/xdm -nodaemon"  xterm   off secure</programlisting>

      <para>Um eine virtuelle Konsole zu deaktivieren, setzen Sie ein
	Kommentarzeichen (<literal>#</literal> an den Anfang der Zeile
	für die entsprechende Konsole.  Um bspw. die Anzahl der
	verfügbaren virtuellen Konsolen von acht auf vier zu
	reduzieren, setzen Sie ein <literal>#</literal> an den Anfang
	der letzten vier Zeilen, den virtuellen Konsolen
	<filename>ttyv5</filename> bis <filename>ttyv8</filename>.
	Kommentieren Sie nicht die Zeile für die Systemkonsole
	<filename>ttyv0</filename> aus!  Beachten Sie, dass die
	letzte virtuelle Konsole (<filename>ttyv8</filename>) zum
	Wechsel auf die graphische Oberfläche gedacht ist, wenn
	&xorg; wie im <xref linkend="x11"/> installiert und
	konfiguriert ist.</para>

      <para>&man.ttys.5; enthält eine ausführliche
	Beschreibung der Spalten dieser Datei und der verfügbaren
	Optionen für virtuelle Konsolen.</para>
    </sect2>

    <sect2 xml:id="consoles-singleuser">
      <title>Single-User-Modus</title>

      <para>Das &os; Boot-Menü verfügt über eine Option
	<quote>Boot Single User</quote>.  Wird diese Option
	gewählt, bootet das System in einen speziellen Modus, der als
	<quote>Single-User-Modus</quote> bekannt ist.  Dieser Modus
	wird normalerweise zur Reparatur des Systems verwendet,
	bspw. wenn das System nicht mehr startet, oder das
	<systemitem class="username">root</systemitem>-Passwort
	zurückgesetzt werden muss.  Im Single-User-Modus haben Sie
	keinen Zugriff auf das Netzwerk und es stehen Ihnen keine
	weiteren virtuellen Konsolen zur Verfügung.  Allerdings
	haben Sie vollen Zugriff auf das System und in der
	Voreinstellung wird das <systemitem
	  class="username">root</systemitem>-Passwort nicht
	benötigt.  Aus diesem Grund wird ein physischer Zugriff
	auf die Tastatur benötigt, um in diesem Modus zu booten.
	Zur Absicherung eines &os;-Systems sollte ermittelt werden,
	welche Personen physischen Zugriff auf die Tastatur bekommen
	sollen.</para>

      <para>Die Einstellungen für den Single-User-Modus befinden sich
	diesem Abschnitt von <filename>/etc/ttys</filename>:</para>

      <programlisting># name  getty                           type  status  comments
#
# If console is marked "insecure", then init will ask for the root password
# when going to single-user mode.
console none                            unknown  off  secure</programlisting>

      <para>In der Voreinstellung ist der Status auf
	<literal>secure</literal> eingestellt.  Das setzt voraus, dass
	der physische Zugriff auf die Tastatur entweder unwichtig ist,
	oder über eine Sicherheitsrichtlinie geregelt wird.  Wenn der
	Status auf <literal>insecure</literal> eingestellt wird, wird
	davon ausgegangen, dass die Umgebung selbst unsicher ist, da
	jeder Zugriff auf die Tastatur hat.  &os; wird dann nach dem
	<systemitem class="username">root</systemitem>-Passwort
	fragen, wenn ein Benutzer versucht in den Single-User-Modus zu
	booten.</para>

      <note>
	<para><emphasis>Setzen Sie <literal>insecure</literal> nicht
	    leichtfertig ein</emphasis>!  Wenn das
	  <systemitem class="username">root</systemitem>-Passwort
	  vergessen wird, wird es schwierig in den
	  Single-User-Modus zu gelangen, wenn man den Bootprozess von
	  &os; nicht genau versteht.</para>
      </note>
    </sect2>

    <sect2 xml:id="consoles-vidcontrol">
      <title>Den Videomodus der Konsole anpassen</title>

      <para>Der Standard-Videomodus der &os;-Konsole kann auf jeden
	Modus eingestellt werden, der von der Grafikkarte und dem
	Monitor unterstützt wird (beispielsweise 1024x768 oder
	1280x1024).  Um eine andere Einstellung zu verwenden, muss
	das <literal>VESA</literal>-Modul geladen werden:</para>

      <screen>&prompt.root; <userinput>kldload vesa</userinput></screen>

      <para>Um festzustellen, welche Video-Modi von der Hardware
	unterstützt werden, nutzen Sie &man.vidcontrol.1;.  Um eine
	Liste aller unterstützten Modi zu sehen, verwenden Sie diesen
	Befehl:</para>

      <screen>&prompt.root; <userinput>vidcontrol -i mode</userinput></screen>

      <para>Die Ausgabe dieses Befehls listet alle Videomodi, die von
	der Hardware unterstützt werden.  Um einen neuen Video-Modi zu
	wählen, wird der entsprechende Modus als
	<systemitem class="username">root</systemitem>-Benutzer an
	&man.vidcontrol.1; übergeben:</para>

      <screen>&prompt.root; <userinput>vidcontrol MODE_279</userinput></screen>

      <para>Um diese Einstellung dauerhaft zu speichern, muss
	folgende Zeile in <filename>/etc/rc.conf</filename>
	hinzugefügt werden:</para>

      <programlisting>allscreens_flags="MODE_279"</programlisting>
    </sect2>
  </sect1>

  <!--
  <chapterinfo>
    <authorgroup>
      <author>
	<personname>
	  <firstname>Neil</firstname>
	  <surname>Blakey-Milner</surname>
	</personname>
	<contrib>Beigetragen von </contrib>
      </author>
      <author>
	<personname>
	  <firstname>Robert</firstname>
	  <surname>Drehmel</surname>
	</personname>
	<contrib>Übersetzt von </contrib>
      </author>
    </authorgroup>
  </chapterinfo>
  -->
  <sect1 xml:id="users-synopsis">
    <title>Benutzer und grundlegende Account-Verwaltung</title>

    <para>&os; ermöglicht es mehreren Benutzern, den Computer zur
      selben Zeit zu benutzen.  Es kann immer nur ein Benutzer
      vor der Konsole sitzen, aber es können sich beliebig viele
      Benutzer über das Netzwerk am System anmelden.  Jeder Benutzer
      muss einen Account haben, um das System benutzen zu
      können.</para>

    <para>Nachdem Sie dieses Kapitel gelesen haben, werden Sie</para>

    <itemizedlist>
      <listitem>
	<para>die verschiedenen Account-Typen von &os; kennen,</para>
      </listitem>

      <listitem>
	<para>wissen, wie Sie Accounts angelegen, verändern oder
	  löschen,</para>
      </listitem>

      <listitem>
	<para>wissen, wie Sie Limits für einen Benutzer oder eine
	  Gruppe setzen, um beispielsweise Ressourcen, wie Speicher
	  oder CPU-Zeit einzuschränken,</para>
      </listitem>

      <listitem>
	<para>wissen, wie Sie Gruppen erstellen und Benutzer zu
	  diesen Gruppen hinzufügen.</para>
      </listitem>
    </itemizedlist>

    <sect2 xml:id="users-introduction">
      <title>Account-Typen</title>

      <para>Jeder Zugriff auf das &os;-System geschieht über Accounts
	und alle Prozesse werden von Benutzern gestartet, also sind
	Benutzer- und Account-Verwaltung von wesentlicher
	Bedeutung.</para>

      <para>Es gibt drei Haupttypen von Accounts: Systembenutzer,
	Benutzer-Accounts und der Superuser-Account.</para>

      <sect3 xml:id="users-system">
	<title>Systembenutzer</title>

	<indexterm>
	  <primary>Accounts</primary>
	  <secondary>System-Accounts</secondary>
	</indexterm>

	<para>Systembenutzer starten Dienste wie DNS, Mail-Server und
	  Web-Server.  Der Grund dafür ist die Sicherheit; wenn die
	  Programme von dem Superuser gestartet werden, können Sie
	  ohne Einschränkungen handeln.</para>

	<indexterm>
	  <primary>Accounts</primary>
	  <secondary><systemitem
	      class="username">daemon</systemitem></secondary>
	</indexterm>
	<indexterm>
	  <primary>Accounts</primary>
	  <secondary><systemitem
	      class="username">operator</systemitem></secondary>
	</indexterm>

	<para>Beispiele von Systembenutzern sind
	  <systemitem class="username">daemon</systemitem>,
	  <systemitem class="username">operator</systemitem>,
	  <systemitem class="username">bind</systemitem>,
	  <systemitem class="username">news</systemitem> und
	  <systemitem class="username">www</systemitem>.</para>

	<indexterm>
	  <primary>Accounts</primary>
	  <secondary><systemitem
	      class="username">nobody</systemitem></secondary>
	</indexterm>

	<para><systemitem class="username">nobody</systemitem> ist der
	  generische unprivilegierte Systembenutzer.  Bedenken Sie
	  aber, dass je mehr Dienste <systemitem
	    class="username">nobody</systemitem> benutzen, desto mehr
	  Dateien und Prozesse diesem Benutzer gehören und dieser
	  Benutzer damit umso privilegierter wird.</para>
      </sect3>

      <sect3 xml:id="users-user">
	<title>Benutzer-Accounts</title>

	<indexterm>
	  <primary>Accounts</primary>
	  <secondary>Benutzer-Accounts</secondary>
	</indexterm>

	<para>Benutzer-Accounts sind realen Personen zugeordnet und
	  sind das primäre Mittel des Zugriffs das System.  Jede
	  Person, die Zugriff auf das System bekommt, sollte einen
	  eindeutigen Benutzer-Account besitzen.  Dies erlaubt es dem
	  Administrator herauszufinden, wer was macht.  Gleichzeitig
	  werden die Benutzer daran gehindert, die Einstellungen
	  anderer Benutzer zu zerstören.</para>

	<para>Jeder Benutzer kann die eigene Umgebung anpassen,
	  bspw. seine voreingestellte Shell, Editor, Tastenbelegungen
	  und Spracheinstellungen.</para>

	<para>Mit jedem Account eines &os;-Systems sind bestimmte
	  Informationen verknüpft:</para>

	<variablelist>
	  <varlistentry>
	    <term>Loginnamen</term>

	    <listitem>
	      <para>Der Loginname wird am <prompt>login:</prompt>
		Prompt eingegeben.  Jeder Benutzer muss einen
		eindeutigen Benutzernamen haben.  Es gibt eine Reihe
		von Regeln für die Erstellung von gültigen Loginnamen,
		die in &man.passwd.5; dokumentiert sind.  Es wird aus
		Kompatibilitätsgründen empfohlen, Benutzernamen zu
		verwenden, die aus Kleinbuchstaben bestehen und bis zu
		acht Zeichen lang sind.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>Passwort</term>

	    <listitem>
	      <para>Jeder Account ist mit einem Passwort
		verknüpft.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>User ID (<acronym>UID</acronym>)</term>

	    <listitem>
	      <para>Die User ID (<acronym>UID</acronym>) ist eine
		Zahl, die verwendet wird, um die Benutzer auf dem
		&os;-System eindeutig zu identifizieren.  Programme,
		die einen Loginnamen akzeptieren, wandeln diesen
		zuerst in eine <acronym>UID</acronym> um.  Es wird
		empfohlen, nur <acronym>UID</acronym>s kleiner
		65535 zu verwenden, da höhere Werte
		Kompatibilitätsprobleme mit einigen Anwendungen
		verursachen können.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>Group ID (<acronym>GID</acronym>)</term>

	    <listitem>
	      <para>Die Group ID (<acronym>GID</acronym>) ist eine
		Zahl, die verwendet wird, um die primäre Gruppe eines
		Benutzers eindeutig zu identifizieren.  Gruppen sind
		ein Mechanismus zur Steuerung des Zugriffs auf
		Ressourcen über die <acronym>GID</acronym> eines
		Benutzers anstelle der <acronym>UID</acronym>.  Dies
		kann die Größe einiger Konfigurationsdateien
		signifikant reduzieren und ermöglicht es Benutzern,
		Mitglied mehreren Gruppen zu sein.  Es wird empfohlen,
		<acronym>GID</acronym>s kleiner 65535 zu verwenden, da
		höhere Werte bei einigen Anwendungen große Probleme
		verursachen können.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>Login-Klasse</term>

	    <listitem>
	      <para>Login-Klassen erweitern das Gruppenkonzept.  Sie
		erhöhen die Flexibilität des Systems in der Handhabung
		der verschiedenen Accounts.  Login-Klassen werden
		auch im <xref linkend="users-limiting"/>
		diskutiert.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>Gültigkeit von Passwörtern</term>

	    <listitem>
	      <para>In der Voreinstellung verfallen Passwörter nicht.
		Allerdings können Passwortwechsel nach einer
		gewissen Zeit auf Basis einzelner Accounts erzwungen
		werden.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>Verfallszeit eines Accounts</term>

	    <listitem>
	      <para>In der Voreinstellung verfallen unter &os; keine
		Accounts.  Wenn Sie Accounts einrichten, die nur für
		eine bestimmte Zeit gültig sein sollen, beispielsweise
		Accounts für Teilnehmer eines Praktikums, können Sie
		mit &man.pw.8; die Gültigkeitsdauer des Accounts
		angeben.  Nachdem die angegebene Zeitspanne
		verstrichen ist, kann dieser Account nicht mehr zum
		Anmelden verwendet werden, obwohl alle Verzeichnisse
		und Dateien, die diesem Account gehören, noch
		vorhanden sind.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>vollständiger Benutzername</term>

	    <listitem>
	      <para>&os; identifiziert einen Account eindeutig über
		den Loginnamen, der aber keine Ähnlichkeit mit dem
		richtigen Namen des Benutzers haben muss.  Ähnlich
		wie bei einem Kommentar, kann diese Information
		Leerzeichen, Großbuchstaben und mehr als 8 Zeichen
		enthalten.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>Heimatverzeichnis</term>

	    <listitem>
	      <para>Das Heimatverzeichnis gibt den vollständigen Pfad
		zu dem Verzeichnis an, in dem sich der Benutzer nach
		erfolgreicher Anmeldung befindet.  Es ist üblich, alle
		Heimatverzeichnisse unter
		<filename><replaceable>/home/Loginname</replaceable></filename>
		oder
		<filename><replaceable>/usr/home/Loginname</replaceable></filename>
		anzulegen.  Im Heimatverzeichnis oder in dort
		angelegten Verzeichnissen werden die Dateien eines
		Benutzers gespeichert.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>Login-Shell</term>

	    <listitem>
	      <para>Grundsätzlich ist die Shell, von denen es viele
		unterschiedliche gibt, eine Schnittstelle zum System.
		Die bevorzugte Shell eines Benutzers kann seinem
		Account zugeordnet werden.</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </sect3>

      <sect3 xml:id="users-superuser">
	<title>Der Superuser-Account</title>

	<indexterm>
	  <primary>Accounts</primary>
	  <secondary>Superuser (root)</secondary>
	</indexterm>

	<para>Der Superuser-Account, normalerweise <systemitem
	    class="username">root</systemitem> genannt, ist
	  vorkonfiguriert und erleichtert die Systemverwaltung, sollte
	  aber nicht für alltägliche Aufgaben wie das Verschicken und
	  Empfangen von Mails, Erforschen des Systems oder
	  Programmierung benutzt werden.</para>

	<para>Der Superuser kann, im Gegensatz zu normalen
	  Benutzer-Accounts, ohne Beschränkungen operieren und die
	  falsche Anwendung des Superuser-Accounts kann in
	  spektakulären Katastrophen resultieren.  Benutzer-Accounts
	  sind nicht in der Lage, das System versehentlich zu
	  zerstören, deswegen wird empfohlen, normale
	  Benutzer-Accounts zu verwenden, solange nicht zusätzliche
	  Privilegien benötigt werden.</para>

	<para>Kommandos, die Sie als Superuser eingeben, sollten Sie
	  immer doppelt und dreifach überprüfen, da ein zusätzliches
	  Leerzeichen oder ein fehlender Buchstabe irreparablen
	  Datenverlust bedeuten kann.</para>

	<para>Es gibt mehrere Möglichkeiten Superuser-Rechte zu
	  bekommen.  Obwohl man sich direkt als <systemitem
	    class="username">root</systemitem> anmelden kann, wird von
	  dieser Methode dringend abgeraten.</para>

	<para>Verwenden Sie stattdessen &man.su.1; um zum Superuser zu
	  werden.  Wenn Sie noch ein <literal>-</literal> eingeben,
	  wird der Benutzer auch die Umgebung des Root-Benutzers
	  erben.  Der Benutzer, der diesen Befehl ausführt muss
	  Mitglied der Gruppe <systemitem
	    class="groupname">wheel</systemitem> sein, oder der
	  Befehl schlägt fehl.  Zudem muss der Benutzer das Kennwort
	  für den Benutzer-Account <systemitem
	    class="username">root</systemitem> kennen.</para>

	<para>In diesem Beispiel wird der Benutzer nur zum Superuser,
	  um <command>make install</command> auszuführen, da dieser
	  Befehl Superuser-Rechte erfordert.  Nachdem der Befehl
	  ausgeführt wurde, kann der Benutzer <command>exit</command>
	  eingeben, um den Superuser-Account zu verlassen und zu den
	  Privilegien des Benutzer-Accounts zurückkehren.</para>

	<example>
	  <title>Ein Programm als Superuser installieren</title>

	  <screen>&prompt.user; <userinput>configure</userinput>
&prompt.user; <userinput>make</userinput>
&prompt.user; <userinput>su -</userinput>
Password:
&prompt.root; <userinput>make install</userinput>
&prompt.root; <userinput>exit</userinput>
&prompt.user;</screen>
	</example>

	<para>Das in &os; enthaltene &man.su.1; funktioniert gut für
	  einzelne Systeme oder in kleineren Netzwerken, mit nur einem
	  Administrator.  Eine Alternative ist es, das Paket oder den
	  Port <package>security/sudo</package> zu installieren.
	  Diese Software bietet eine Protokollierung von Aktivitäten
	  und ermöglicht es dem Administrator zu bestimmen, welche
	  Benutzer welche Befehle als Superuser ausführen
	  dürfen.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="users-modifying">
      <title>Accounts verändern</title>

      <indexterm>
	<primary>Accounts</primary>
	<secondary>verändern</secondary>
      </indexterm>

      <para>&os; stellt eine Vielzahl an Programmen bereit, um
	Accounts zu verändern.  Die gebräuchlichsten Kommandos sind in
	<xref linkend="users-modifying-utilities"/>
	gefolgt von einer detaillierten Beschreibung,
	zusammengefasst.  Weitere Informationen und
	Anwendungsbeispiele finden Sie in der Manualpage des
	jeweiligen Programms.</para>

      <table frame="none" pgwide="1"
	xml:id="users-modifying-utilities">
	<title>Programme zur Verwaltung von Benutzer-Accounts</title>

	<tgroup cols="2">
	  <colspec colwidth="1*"/>
	  <colspec colwidth="2*"/>

	  <thead>
	    <row>
	      <entry>Programm</entry>
	      <entry>Zusammenfassung</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>&man.adduser.8;</entry>
	      <entry>Das empfohlene Werkzeug, um neue Accounts zu
		erstellen.</entry>
	    </row>

	    <row>
	      <entry>&man.rmuser.8;</entry>
	      <entry>Das empfohlene Werkzeug, um Accounts zu
		löschen.</entry>
	    </row>

	    <row>
	      <entry>&man.chpass.1;</entry>
	      <entry>Ein flexibles Werkzeug, um Informationen in der
		Account-Datenbank zu verändern.</entry>
	    </row>

	    <row>
	      <entry>&man.passwd.1;</entry>
	      <entry>Ein Werkzeug, um Passwörter von Accounts
		zu ändern.</entry>
	    </row>

	    <row>
	      <entry>&man.pw.8;</entry>
	      <entry>Ein mächtiges und flexibles Werkzeug um alle
		Informationen über Accounts zu ändern.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <sect3 xml:id="users-adduser">
	<title><command>adduser</command></title>

	<indexterm>
	  <primary>Accounts</primary>
	  <secondary>erstellen</secondary>
	</indexterm>
	<indexterm>
	  <primary><command>adduser</command></primary>
	</indexterm>
	<indexterm>
	  <primary><filename>/usr/share/skel</filename></primary>
	</indexterm>

	<para>Das empfohlene Programm zum Hinzufügen neuer Benutzer
	  ist &man.adduser.8;.  Wenn ein neuer Benutzer
	  hinzugefügt wird, aktualisiert das Programm automatisch
	  <filename>/etc/passwd</filename> und
	  <filename>/etc/group</filename>.  Es erstellt auch das
	  Heimatverzeichnis für den Benutzer, kopiert die
	  Standardkonfigurationsdateien aus
	  <filename>/usr/share/skel</filename> und kann optional
	  eine ,,Willkommen``-Nachricht an den neuen Benutzer
	  versenden.  Das Programm muss als Superuser ausgeführt
	  werden.</para>

	<para>Das Werkzeug &man.adduser.8; arbeitet interaktiv und
	  führt durch die einzelnen Schritte, wenn ein neues
	  Benutzerkonto erstellt wird.  Wie in <xref
	    linkend="users-modifying-adduser"/> zu sehen
	  ist, müssen Sie entweder die benötigte Information eingeben
	  oder <keycap>Return</keycap> drücken, um den Vorgabewert in
	  eckigen Klammern zu akzeptieren.  In diesem Beispiel wird
	  der Benutzer in die Gruppe <systemitem
	    class="groupname">wheel</systemitem> aufgenommen, was es
	  ihm erlaubt mit &man.su.1; zum Superuser zu werden.  Wenn
	  Sie fertig sind, können Sie entweder einen weiteren Benutzer
	  erstellen oder das Programm beenden.</para>

	<example xml:id="users-modifying-adduser">
	  <title>Einen Benutzer unter &os; anlegen</title>

	  <screen>&prompt.root; <userinput>adduser</userinput>
Username: <userinput>jru</userinput>
Full name: <userinput>J. Random User</userinput>
Uid (Leave empty for default):
Login group [jru]:
Login group is jru. Invite jru into other groups? []: <userinput>wheel</userinput>
Login class [default]:
Shell (sh csh tcsh zsh nologin) [sh]: <userinput>zsh</userinput>
Home directory [/home/jru]:
Home directory permissions (Leave empty for default):
Use password-based authentication? [yes]:
Use an empty password? (yes/no) [no]:
Use a random password? (yes/no) [no]:
Enter password:
Enter password again:
Lock out the account after creation? [no]:
Username   : jru
Password   : ****
Full Name  : J. Random User
Uid        : 1001
Class      :
Groups     : jru wheel
Home       : /home/jru
Shell      : /usr/local/bin/zsh
Locked     : no
OK? (yes/no): <userinput>yes</userinput>
adduser: INFO: Successfully added (jru) to the user database.
Add another user? (yes/no): <userinput>no</userinput>
Goodbye!
&prompt.root;</screen>
	</example>

	<note>
	  <para>Wenn Sie das Passwort eingeben, werden weder Passwort
	    noch Sternchen angezeigt.  Passen Sie auf, dass Sie das
	    Passwort korrekt eingeben.</para>
	</note>
      </sect3>

      <sect3 xml:id="users-rmuser">
	<title><command>rmuser</command></title>

	<indexterm>
	  <primary><command>rmuser</command></primary>
	</indexterm>
	<indexterm>
	  <primary>Accounts</primary>
	  <secondary>löschen</secondary>
	</indexterm>

	<para>Benutzen Sie &man.rmuser.8; als Superuser, um einen
	  Account vollständig aus dem System zu entfernen.  Dieses
	  Programm führt die folgenden Schritte durch:</para>

	<procedure>
	  <step>
	    <para>Entfernt den &man.crontab.1; Eintrag des Benutzers,
	      wenn dieser existiert.</para>
	  </step>

	  <step>
	    <para>Entfernt alle &man.at.1; jobs, die dem Benutzer
	      gehören.</para>
	  </step>

	  <step>
	    <para>Schließt alle Prozesse des Benutzers.</para>
	  </step>

	  <step>
	    <para>Entfernt den Benutzer aus der lokalen Passwort-Datei
	      des Systems.</para>
	  </step>

	  <step>
	    <para>Entfernt optional das Heimatverzeichnis des
	      Benutzers, falls es dem Benutzer gehört.</para>
	  </step>

	  <step>
	    <para>Entfernt eingegangene E-Mails des Benutzers
	      aus <filename>/var/mail</filename>.</para>
	  </step>

	  <step>
	    <para>Entfernt alle Dateien des Benutzers aus temporären
	      Dateispeicherbereichen wie
	      <filename>/tmp</filename>.</para>
	  </step>

	  <step>
	    <para>Entfernt den Loginnamen von allen Gruppen, zu denen
	      er gehört, aus <filename>/etc/group</filename>.  Wenn
	      eine Gruppe leer wird und der Gruppenname mit dem
	      Loginnamen identisch ist, wird die Gruppe entfernt.  Das
	      ergänzt sich mit den einzelnen Benutzer-Gruppen, die von
	      &man.adduser.8; für jeden neuen Benutzer erstellt
	      werden.</para>
	  </step>
	</procedure>

	<para>Der Superuser-Account kann nicht mit &man.rmuser.8;
	  entfernt werden, da dies in den meisten Fällen das System
	  unbrauchbar macht.</para>

	<para>Als Vorgabe wird ein interaktiver Modus benutzt.</para>

	<example>
	  <title>Interaktives Löschen von Accounts mit
	    <command>rmuser</command></title>

	  <screen>&prompt.root; <userinput>rmuser jru</userinput>
Matching password entry:
jru:*:1001:1001::0:0:J. Random User:/home/jru:/usr/local/bin/zsh
Is this the entry you wish to remove? <userinput>y</userinput>
Remove user's home directory (/home/jru)? <userinput>y</userinput>
Removing user (jru): mailspool home passwd.
&prompt.root;</screen>
	</example>
      </sect3>

      <sect3 xml:id="users-chpass">
	<title><command>chpass</command></title>

	<indexterm>
	  <primary><command>chpass</command></primary>
	</indexterm>

	<para>Jeder Benutzer kann &man.chpass.1; verwenden, um die
	  Shell und persönliche Informationen des Benutzerkontos zu
	  verändern.  Der Superuser kann dieses Werkzeug benutzen, um
	  zusätzliche Kontoinformationen für alle Benutzer zu
	  ändern.</para>

	<para>Werden neben dem optionalen Loginnamen keine weiteren
	  Optionen angegeben, zeigt &man.chpass.1; einen Editor mit
	  Account-Informationen an.  Wenn der Benutzer den Editor
	  verlässt, wird die Account-Datenbank mit den neuen
	  Informationen aktualisiert.</para>

	<note>
	  <para>Dieses Programm fragt nach dem Verlassen des Editors
	    nach dem Passwort, es sei denn, man ist als Superuser
	    angemeldet.</para>
	</note>

	<para>In <xref linkend="users-modifying-chpass-su"/> hat der
	  Superuser <command>chpass jru</command> eingegeben.  Es
	  werden die Felder ausgegeben, die für diesen Benutzer
	  geändert werden können.  Wenn stattdessen <systemitem
	    class="username">jru</systemitem> diesen Befehl aufruft,
	  werden nur die letzten sechs Felder ausgegeben.  Dies ist in
	  <xref linkend="users-modifying-chpass-ru"/> zu sehen.</para>

	<example xml:id="users-modifying-chpass-su">
	  <title><command>chpass</command> als Superuser
	    verwenden</title>

	  <screen>#Changing user database information for jru.
Login: jru
Password: *
Uid [#]: 1001
Gid [# or name]: 1001
Change [month day year]:
Expire [month day year]:
Class:
Home directory: /home/jru
Shell: /usr/local/bin/zsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:</screen>
	</example>

	<example xml:id="users-modifying-chpass-ru">
	  <title><command>chpass</command> als normaler Benutzer
	    verwenden</title>

	  <screen>#Changing user database information for jru.
Shell: /usr/local/bin/tcsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:</screen>
	</example>

	<note>
	  <para>Die Kommandos &man.chfn.1; und &man.chsh.1; sind nur
	    Verweise auf &man.chpass.1;, genauso wie &man.ypchpass.1;,
	    &man.ypchfn.1; und &man.ypchsh.1;.  Da
	    <acronym>NIS</acronym> automatisch unterstützt wird, ist
	    es nicht notwendig das <literal>yp</literal> vor dem
	    Kommando einzugeben.  <acronym>NIS</acronym> wird später
	    im <xref linkend="network-servers"/> besprochen.</para>
	</note>
      </sect3>

      <sect3 xml:id="users-passwd">
	<title><application>passwd</application></title>

	<indexterm>
	  <primary><command>passwd</command></primary>
	</indexterm>
	<indexterm>
	  <primary>Accounts</primary>
	  <secondary>Passwort wechseln</secondary>
	</indexterm>

	<para>Jeder Benutzer kann mit &man.passwd.1; einfach sein
	  Passwort ändern.  Um eine versehentliche oder unbefugte
	  Änderung zu verhindern, muss bei einem Passwortwechsel
	  zunächst das ursprüngliche Passwort eingegeben
	  werden, bevor das neue Passwort festgelegt werden
	  kann.</para>

	<example>
	  <title>Das eigene Passwort wechseln</title>

	  <screen>&prompt.user; <userinput>passwd</userinput>
Changing local password for jru.
Old password:
New password:
Retype new password:
passwd: updating the database...
passwd: done</screen>
	</example>

	<para>Der Superuser kann jedes beliebige Passwort ändern,
	  indem er den Benutzernamen an &man.passwd.1; übergibt.
	  Das Programm fordert den Superuser nicht dazu auf, das
	  aktuelle Passwort des Benutzers einzugeben.  Dadurch kann
	  das Passwort geändert werden, falls der Benutzer sein
	  ursprüngliches Passwort vergessen hat.</para>

	<example>
	  <title>Als Superuser das Passwort eines anderen Accounts
	    verändern</title>

	  <screen>&prompt.root; <userinput>passwd jru</userinput>
Changing local password for jru.
New password:
Retype new password:
passwd: updating the database...
passwd: done</screen>
	</example>

	<note>
	  <para>Wie bei &man.chpass.1; ist &man.yppasswd.1;
	    nur ein Verweis auf &man.passwd.1;.
	    <acronym>NIS</acronym> wird von jedem dieser Kommandos
	    unterstützt.</para>
	</note>
      </sect3>

      <sect3 xml:id="users-pw">
	<title><command>pw</command></title>

	<indexterm>
	  <primary><command>pw</command></primary>
	</indexterm>

	<para>Mit dem Werkzeug &man.pw.8; können Accounts und Gruppen
	  erstellt, entfernt, verändert und angezeigt werden.  Dieses
	  Kommando dient als Schnittstelle zu den Benutzer- und
	  Gruppendateien des Systems.  &man.pw.8; besitzt eine Reihe
	  mächtiger Kommandozeilenschalter, die es für die Benutzung
	  in Shell-Skripten geeignet machen, doch finden neue Benutzer
	  die Bedienung des Kommandos komplizierter, als die der
	  anderen hier vorgestellten Kommandos.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="users-groups">
      <title>Gruppen</title>

      <indexterm><primary>Gruppen</primary></indexterm>
      <indexterm>
	<primary><filename>/etc/groups</filename></primary>
      </indexterm>
      <indexterm>
	<primary>Accounts</primary>
	<secondary>Gruppen</secondary>
      </indexterm>

      <para>Eine Gruppe ist einfach eine Zusammenfassung von Accounts.
	Gruppen werden durch den Gruppennamen und die
	<acronym>GID</acronym> identifiziert.  Der Kernel von &os;
	entscheidet anhand der <acronym>UID</acronym> und der
	Gruppenmitgliedschaft eines Prozesses, ob er dem Prozess etwas
	erlaubt oder nicht.  Wenn jemand von der
	<acronym>GID</acronym> eines Benutzers oder Prozesses spricht,
	meint er damit meistens die erste Gruppe der
	Gruppenliste.</para>

      <para>Die Zuordnung von Gruppennamen zur <acronym>GID</acronym>
	steht in <filename>/etc/group</filename>, einer Textdatei mit
	vier durch Doppelpunkte getrennten Feldern.  Im ersten Feld
	steht der Gruppenname, das zweite enthält ein verschlüsseltes
	Passwort, das dritte gibt die <acronym>GID</acronym> an und
	das vierte besteht aus einer Komma separierten Liste der
	Mitglieder der Gruppe.  Eine ausführliche Beschreibung der
	Syntax dieser Datei finden Sie in &man.group.5;.</para>

      <para>Wenn Sie <filename>/etc/group</filename> nicht von Hand
	editieren möchten, können Sie &man.pw.8; zum Editieren
	benutzen.  Das folgende Beispiel zeigt das Hinzufügen einer
	Gruppe mit dem Namen <systemitem
	  class="groupname">teamtwo</systemitem>:</para>

      <example>
	<title>Setzen der Mitgliederliste einer Gruppe mit
	  &man.pw.8;</title>

	<screen>&prompt.root; <userinput>pw groupadd teamtwo</userinput>
&prompt.root; <userinput>pw groupshow teamtwo</userinput>
teamtwo:*:1100:</screen>
      </example>

      <para><literal>1100</literal> ist die <acronym>GID</acronym> der
	Gruppe <systemitem class="groupname">teamtwo</systemitem>.
	Momentan hat <systemitem
	  class="groupname">teamtwo</systemitem> noch keine
	Mitglieder.  Mit dem folgenden Kommando wird der Benutzer
	<systemitem class="username">jru</systemitem> in die Gruppe
	<systemitem class="groupname">teamtwo</systemitem>
	aufgenommen.</para>

      <example>
	<title>Ein Gruppenmitglied mit &man.pw.8; hinzufügen</title>

	<screen>&prompt.root; <userinput>pw groupmod teamtwo -M jru</userinput>
&prompt.root; <userinput>pw groupshow teamtwo</userinput>
teamtwo:*:1100:jru</screen>
      </example>

      <para>Als Argument von <option>-M</option> geben Sie eine Komma
	separierte Liste von Mitgliedern an, die in die Gruppe
	aufgenommen werden sollen.  Aus den vorherigen Abschnitten ist
	bekannt, dass die Passwort-Datei ebenfalls eine Gruppe für
	jeden Benutzer enthält.  Das System teilt dem Benutzer
	automatisch eine Gruppe zu, die aber vom
	<option>groupshow</option> Kommando von &man.pw.8; nicht
	angezeigt wird.  Diese Information wird allerdings von
	&man.id.1; und ähnlichen Werkzeugen angezeigt.  Das heißt,
	dass &man.pw.8; nur <filename>/etc/group</filename>
	manipuliert, es wird nicht versuchen, zusätzliche
	Informationen aus <filename>/etc/passwd</filename> zu
	lesen.</para>

      <example>
	<title>Hinzufügen eines neuen Gruppenmitglieds mittels
	  &man.pw.8;</title>

	<screen>&prompt.root; <userinput>pw groupmod teamtwo -m db</userinput>
&prompt.root; <userinput>pw groupshow teamtwo</userinput>
teamtwo:*:1100:jru,db</screen>
      </example>

      <para>Die Argumente zur Option <option>-m</option> ist eine
	durch Komma getrennte Liste von Benutzern, die der Gruppe
	hinzugefügt werden sollen.  Anders als im vorherigen Beispiel
	werden diese Benutzer in die Gruppe aufgenommen und ersetzen
	nicht die bestehenden Benutzer in der Gruppe.</para>

      <example>
	<title>Mit <command>id</command> die Gruppenzugehörigkeit
	  bestimmen</title>

	<screen>&prompt.user; <userinput>id jru</userinput>
uid=1001(jru) gid=1001(jru) groups=1001(jru), 1100(teamtwo)</screen>
      </example>

      <para>In diesem Beispiel ist <systemitem
	  class="username">jru</systemitem> Mitglied von
	<systemitem class="groupname">jru</systemitem> und
	<systemitem class="groupname">teamtwo</systemitem>.</para>

      <para>Weitere Informationen zu diesem Befehl und dem Format von
	<filename>/etc/group</filename> finden Sie in &man.pw.8; und
	&man.group.5;.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="permissions">
    <title>Zugriffsrechte</title>

    <indexterm><primary>UNIX</primary></indexterm>

    <para>In &os; besitzt jede Datei und jedes Verzeichnis einen Satz
      von Zugriffsrechten.  Es stehen mehrere Programme zum Anzeigen
      und Bearbeiten dieser Rechte zur Verfügung.  Ein Verständnis für
      die Funktionsweise von Zugriffsrechten ist notwendig, um
      sicherzustellen, dass Benutzer nur auf die von ihnen benötigten
      Dateien zugreifen können und nicht auf die Dateien des
      Betriebssystems oder von anderen Benutzern.</para>

    <para>In diesem Abschnitt werden die traditionellen
      Zugriffsrechte von &unix; beschrieben.  Informationen
      zu feingranularen Zugriffsrechten für Dateisysteme finden
      Sie im <xref linkend="fs-acl"/>.</para>

    <para>In &unix; werden die grundlegenden Zugriffsrechte in
      drei Typen unterteilt: Lesen, Schreiben und Ausführen.
      Diese Zugriffstypen werden verwendet, um den Dateizugriff
      für den Besitzer der Datei, die Gruppe und alle anderen zu
      bestimmen.  Die Lese-, Schreib- und Ausführungsberechtigungen
      werden mit den Buchstaben <literal>r</literal>,
      <literal>w</literal> und <literal>x</literal> dargestellt.
      Alternativ können die Berechtigungen als binäre Zahlen
      dargestellt werden, da jede Berechtigung entweder aktiviert
      oder deaktiviert (<literal>0</literal>) ist.  Wenn die
      Berechtigung als Zahl dargestellt wird, ist die Reihenfolge
      immer als <literal>rwx</literal> zu lesen, wobei
      <literal>r</literal> den Wert <literal>4</literal> hat,
      <literal>w</literal> den Wert <literal>2</literal> und
      <literal>x</literal> den Wert <literal>1</literal>.</para>

    <para>In Tabelle 4.1 sind die einzelnen nummerischen und
      alphabetischen Möglichkeiten zusammengefasst.  Das Zeichen
      <literal>-</literal> in der Spalte
      <quote>Auflistung im Verzeichnis</quote> besagt, dass eine
      Berechtigung deaktiviert ist.</para>

    <indexterm><primary>Zugriffsrechte</primary></indexterm>
    <indexterm>
      <primary>Dateizugriffsrechte</primary>
    </indexterm>
    <table frame="none" pgwide="1">
      <title>&unix; Zugriffsrechte</title>

      <tgroup cols="3">
	<thead>
	  <row>
	    <entry>Wert</entry>
	    <entry>Zugriffsrechte</entry>
	    <entry>Auflistung im Verzeichnis</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry>0</entry>
	    <entry>Kein Lesen, Kein Schreiben, Kein Ausführen</entry>
	    <entry><literal>---</literal></entry>
	  </row>

	  <row>
	    <entry>1</entry>
	    <entry>Kein Lesen, Kein Schreiben, Ausführen</entry>
	    <entry><literal>--x</literal></entry>
	  </row>

	  <row>
	    <entry>2</entry>
	    <entry>Kein Lesen, Schreiben, Kein Ausführen</entry>
	    <entry><literal>-w-</literal></entry>
	  </row>

	  <row>
	    <entry>3</entry>
	    <entry>Kein Lesen, Schreiben, Ausführen</entry>
	    <entry><literal>-wx</literal></entry>
	  </row>

	  <row>
	    <entry>4</entry>
	    <entry>Lesen, Kein Schreiben, Kein Ausführen</entry>
	    <entry><literal>r--</literal></entry>
	  </row>

	  <row>
	    <entry>5</entry>
	    <entry>Lesen, Kein Schreiben, Ausführen</entry>
	    <entry><literal>r-x</literal></entry>
	  </row>

	  <row>
	    <entry>6</entry>
	    <entry>Lesen, Schreiben, Kein Ausführen</entry>
	    <entry><literal>rw-</literal></entry>
	  </row>

	  <row>
	    <entry>7</entry>
	    <entry>Lesen, Schreiben, Ausführen</entry>
	    <entry><literal>rwx</literal></entry>
	  </row>
	</tbody>
      </tgroup>
    </table>

    <indexterm>
      <primary>&man.ls.1;</primary>
    </indexterm>
    <indexterm><primary>Verzeichnisse</primary></indexterm>

    <para>Benutzen Sie das Argument <option>-l</option> mit
      &man.ls.1;, um eine ausführliche Verzeichnisauflistung
      zu sehen, die in einer Spalte die Zugriffsrechte für den
      Besitzer, die Gruppe und alle anderen enthält.
      Die Ausgabe von <command>ls -l</command> könnte
      wie folgt aussehen:</para>

    <screen>&prompt.user; <userinput>ls -l</userinput>
total 530
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 myfile
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 otherfile
-rw-r--r--  1 root  wheel    7680 Sep  5 12:31 email.txt</screen>

    <para>Das erste Zeichen (ganz links) der ersten Spalte zeigt an,
      ob es sich um eine normale Datei, ein Verzeichnis, ein
      zeichenorientiertes Gerät, ein Socket oder irgendeine andere
      Pseudo-Datei handelt.  In diesem Beispiel zeigt
      <literal>-</literal> eine normale Datei an.  Die nächsten drei
      Zeichen, dargestellt als <literal>rw-</literal>, ergeben die
      Rechte für den Datei-Besitzer.  Die drei Zeichen danach
      <literal>r--</literal> die Rechte der Gruppe, zu der die Datei
      gehört.  Die letzten drei Zeichen, <literal>r--</literal>,
      geben die Rechte für den Rest der Welt an.  Ein Minus
      bedeutet, dass das Recht nicht gegeben ist.  In diesem Beispiel
      sind die Zugriffsrechte also: der Eigentümer kann die Datei
      lesen und schreiben, die Gruppe kann lesen und alle anderen
      können auch nur lesen.  Entsprechend obiger Tabelle
      wären die Zugriffsrechte für diese Datei
      <literal>644</literal>, worin jede Ziffer die drei Teile der
      Zugriffsrechte dieser Datei verkörpert.</para>

    <para>Wie kontrolliert das System die Rechte von Hardware-Geräten?
      &os; behandelt die meisten Hardware-Geräte als Dateien, welche
      Programme öffnen, lesen und mit Daten beschreiben können.  Diese
      speziellen Gerätedateien sind in <filename>/dev</filename>
      gespeichert.</para>

    <para>Verzeichnisse werden ebenfalls wie Dateien behandelt.  Sie
      haben Lese-, Schreib- und Ausführ-Rechte.  Das
      Ausführungs-Bit hat eine etwas andere Bedeutung für
      ein Verzeichnis als für eine Datei.  Die Ausführbarkeit
      eines Verzeichnisses bedeutet, dass in das Verzeichnis,
      zum Beispiel mit &man.cd.1;, gewechselt werden kann.
      Das bedeutet auch, dass in dem Verzeichnis auf Dateien, deren
      Namen bekannt sind, zugegriffen werden kann, vorausgesetzt die
      Zugriffsrechte der Dateien lassen dies zu.</para>

    <para>Das Leserecht auf einem Verzeichnis erlaubt es, sich den
      Inhalt des Verzeichnisses anzeigen zu lassen.  Um eine Datei mit
      bekanntem Namen in einem Verzeichnis zu löschen, müssen auf dem
      Verzeichnis Schreib- <emphasis>und</emphasis> Ausführ-Rechte
      gesetzt sein.</para>

    <para>Es gibt noch mehr Rechte, aber die werden vor allem in
      speziellen Umständen benutzt, wie zum Beispiel bei
      SetUID-Binaries und Verzeichnissen mit gesetztem Sticky-Bit.
      Mehr über Zugriffsrechte von Dateien und wie sie gesetzt werden,
      finden Sie in &man.chmod.1;.</para>

    <sect2>
      <info>
	<title>Symbolische Zugriffsrechte</title>

	<authorgroup>
	  <author>
	    <personname>
	      <firstname>Tom</firstname>
	      <surname>Rhodes</surname>
	    </personname>
	    <contrib>Beigesteuert von </contrib>
	  </author>
	</authorgroup>
      </info>

      <indexterm>
	<primary>Zugriffsrechte</primary>
	<secondary>symbolische</secondary>
      </indexterm>

      <para>Symbolische Zugriffsrechte verwenden Zeichen anstelle von
	oktalen Werten, um die Berechtigungen für Dateien oder
	Verzeichnisse festzulegen.  Zugriffsrechte verwenden die
	Syntax <replaceable>Wer</replaceable>,
	<replaceable>Aktion</replaceable> und
	<replaceable>Berechtigung</replaceable>.  Die folgenden Werte
	stehen zur Auswahl:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>Option</entry>
	      <entry>Symbol</entry>
	      <entry>Bedeutung</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><replaceable>Wer</replaceable></entry>
	      <entry>u</entry>
	      <entry>Benutzer
		(<foreignphrase>user</foreignphrase>)</entry>
	    </row>

	    <row>
	      <entry><replaceable>Wer</replaceable></entry>
	      <entry>g</entry>
	      <entry>Gruppe
		(<foreignphrase>group</foreignphrase>)</entry>
	    </row>

	    <row>
	      <entry><replaceable>Wer</replaceable></entry>
	      <entry>o</entry>
	      <entry>Andere
		(<foreignphrase>other</foreignphrase>)</entry>
	    </row>

	    <row>
	      <entry><replaceable>Wer</replaceable></entry>
	      <entry>a</entry>
	      <entry>Alle</entry>
	    </row>

	    <row>
	      <entry><replaceable>Aktion</replaceable></entry>
	      <entry>+</entry>
	      <entry>Berechtigungen hinzufügen</entry>
	    </row>

	    <row>
	      <entry><replaceable>Aktion</replaceable></entry>
	      <entry>-</entry>
	      <entry>Berechtigungen entziehen</entry>
	    </row>

	    <row>
	      <entry><replaceable>Aktion</replaceable></entry>
	      <entry>=</entry>
	      <entry>Berechtigungen explizit setzen</entry>
	    </row>

	    <row>
	      <entry><replaceable>Berechtigung</replaceable></entry>
	      <entry>r</entry>
	      <entry>lesen
		(<foreignphrase>read</foreignphrase>)</entry>
	    </row>

	    <row>
	      <entry><replaceable>Berechtigung</replaceable></entry>
	      <entry>w</entry>
	      <entry>schreiben
		(<foreignphrase>write</foreignphrase>)</entry>
	    </row>

	    <row>
	      <entry><replaceable>Berechtigung</replaceable></entry>
	      <entry>x</entry>
	      <entry>ausführen
		(<foreignphrase>execute</foreignphrase>)</entry>
	    </row>

	    <row>
	      <entry><replaceable>Berechtigung</replaceable></entry>
	      <entry>t</entry>
	      <entry>Sticky-Bit</entry>
	    </row>

	    <row>
	      <entry><replaceable>Berechtigung</replaceable></entry>
	      <entry>s</entry>
	      <entry>Set-UID oder Set-GID</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>Diese symbolischen Werte werden zusammen mit &man.chmod.1;
	verwendet.  Beispielsweise würde der folgende Befehl den Zugriff
	auf <replaceable>FILE</replaceable> für alle anderen Benutzer
	verbieten:</para>

      <screen>&prompt.user; <userinput>chmod go= FILE</userinput></screen>

      <para>Wenn Sie mehr als eine Änderung der Rechte einer
	Datei vornehmen wollen, können Sie eine durch Kommata
	getrennte Liste der Rechte angeben.  Das folgende Beispiel
	entzieht der Gruppe und der Welt die Schreibberechtigung auf
	<replaceable>FILE</replaceable> und fügt für jeden
	Ausführungsrechte hinzu:</para>

      <screen>&prompt.user; <userinput>chmod go-w,a+x <replaceable>FILE</replaceable></userinput></screen>

<!--
    <para>Mit symbolischen Zugriffsrechten können Sie Rechte
      hinzufügen oder Rechte wegnehmen.  Numerische Zugriffsrechte
      erlauben nur das explizite Setzen der Zugriffsrechte.</para>
-->
    </sect2>

    <sect2>
      <info>
	<title>&os; Datei-Flags</title>

	<authorgroup>
	  <author>
	    <personname>
	      <firstname>Tom</firstname>
	      <surname>Rhodes</surname>
	    </personname>
	    <contrib>Beigetragen von </contrib>
	  </author>
	</authorgroup>
      </info>

      <para>Zusätzlich zu den Zugriffsrechten unterstützt &os; auch
	die Nutzung von <quote>Datei-Flags</quote>.  Diese erhöhen die
	Sicherheit des Systems, indem sie eine verbesserte Kontrolle
	von Dateien erlauben.  Verzeichnisse werden allerdings nicht
	unterstützt.  Mit dem Einsatz von Datei-Flags kann sogar
	<systemitem class="username">root</systemitem> daran gehindert
	werden, Dateien zu löschen oder zu verändern.</para>

      <para>Datei-Flags werden mit &man.chflags.1; verändert.  Um
	beispielsweise auf der Datei <filename>file1</filename> das
	<quote>unlöschbar</quote>-Flag zu aktivieren, geben Sie
	folgenden Befehl ein:</para>

      <screen>&prompt.root; <userinput>chflags sunlink file1</userinput></screen>

      <para>Um dieses Flag zu deaktivieren, setzen Sie ein
	<quote>no</quote> vor <option>sunlink</option>:</para>

      <screen>&prompt.root; <userinput>chflags nosunlink file1</userinput></screen>

      <para>Um die Flags einer Datei anzuzeigen, verwenden Sie
	&man.ls.1; zusammen mit <option>-lo</option>:</para>

      <screen>&prompt.root; <userinput>ls -lo file1</userinput></screen>

      <programlisting>-rw-r--r--  1 trhodes  trhodes  sunlnk 0 Mar  1 05:54 file1</programlisting>

      <para>Einige Datei-Flags können nur vom
	<systemitem class="username">root</systemitem>-Benutzer
	gesetzt oder gelöscht werden.  Andere wiederum können
	auch vom Eigentümer der Datei gesetzt werden.  Weitere
	Informationen hierzu finden sich in &man.chflags.1; und
	&man.chflags.2;.</para>
    </sect2>

    <sect2>
      <info>
	<title>Die Berechtigungen <literal>setuid</literal>,
	  <literal>setgid</literal>, und
	  <literal>sticky</literal></title>

	<authorgroup>
	  <author>
	    <personname>
	      <firstname>Tom</firstname>
	      <surname>Rhodes</surname>
	    </personname>
	    <contrib>Beigetragen von </contrib>
	  </author>
	</authorgroup>
      </info>

      <para>Anders als die Berechtigungen, die bereits angesprochen
	wurden, existieren drei weitere Einstellungen, über die alle
	Administratoren Bescheid wissen sollten.  Dies sind die
	Berechtigungen <literal>setuid</literal>,
	<literal>setgid</literal> und
	<literal>sticky</literal>.</para>

      <para>Diese Einstellungen sind wichtig für manche
	&unix;-Operationen, da sie Funktionalitäten zur Verfügung
	stellen, die normalerweise nicht an gewöhnliche Anwender
	vergeben wird.  Um diese zu verstehen, muss der Unterschied
	zwischen der realen und der effektiven Benutzer-ID erwähnt
	werden.</para>

      <para>Die reale Benutzer-ID ist die <acronym>UID</acronym>,
	welche den Prozess besitzt oder gestartet hat.  Die effektive
	<acronym>UID</acronym> ist diejenige, als die der Prozess
	läuft.  Beispielsweise wird &man.passwd.1; mit der realen ID
	des Benutzers ausgeführt, der sein Passwort ändert.  Um jedoch
	die Passwortdatenbank zu bearbeiten, wird es effektiv als
	<systemitem class="username">root</systemitem>-Benutzer
	ausgeführt.  Das ermöglicht es normalen Benutzern, ihr
	Passwort zu ändern, ohne einen
	<errorname>Permission Denied</errorname>-Fehler angezeigt zu
	bekommen.</para>

      <para>Die setuid-Berechtigung kann durch das Voranstellen bei
	einer Berechtigungsgruppe mit der Nummer Vier (4) gesetzt
	werden, wie im folgenden Beispiel gezeigt wird:</para>

      <screen>&prompt.root; <userinput>chmod 4755 suidexample.sh</userinput></screen>

      <para>Die Berechtigungen auf
	<filename><replaceable>suidexample.sh</replaceable></filename>
	sehen jetzt wie folgt aus:</para>

      <programlisting>-rwsr-xr-x   1 trhodes  trhodes    63 Aug 29 06:36 suidexample.sh</programlisting>

      <para>Beachten Sie, dass ein <literal>s</literal> jetzt Teil der
	Berechtigungen des Dateibesitzers geworden ist, welches das
	Ausführen-Bit ersetzt.  Dies ermöglicht es Werkzeugen mit
	erhöhten Berechtigungen zu laufen, wie beispielsweise
	<command>passwd</command>.</para>

      <note>
	<para>Die <literal>nosuid</literal> &man.mount.8;-Option
	  bewirkt, dass solche Anwendungen stillschweigend scheitern,
	  ohne den Anwender darüber zu informieren.  Diese Option ist
	  nicht völlig zuverlässig, da ein
	  <literal>nosuid</literal>-Wrapper in der Lage wäre, dies zu
	  umgehen.</para>
      </note>

      <para>Um dies in Echtzeit zu beobachten, öffnen Sie zwei
	Terminals.  Starten Sie auf einem <command>passwd</command>
	als normaler Benutzer.  Während es auf die Passworteingabe
	wartet, überprüfen Sie die Prozesstabelle und sehen Sie sich
	die Informationen für &man.passwd.1; an:</para>

      <para>Im Terminal A:</para>

      <screen>Changing local password for trhodes
Old Password:</screen>

      <para>Im Terminal B:</para>

      <screen>&prompt.root; <userinput>ps aux | grep passwd</userinput></screen>

      <screen>trhodes  5232  0.0  0.2  3420  1608   0  R+    2:10AM   0:00.00 grep passwd
root     5211  0.0  0.2  3620  1724   2  I+    2:09AM   0:00.01 passwd</screen>

      <para>Obwohl &man.passwd.1; als normaler Benutzer ausgeführt
	wird, benutzt es die effektive <acronym>UID</acronym> von
	<systemitem class="username">root</systemitem>.</para>

      <para>Die <literal>setgid</literal>-Berechtigung führt die
	gleiche Aktion wie die <literal>setuid</literal>-Berechtigung
	durch, allerdings verändert sie die Gruppenberechtigungen.
	Wenn eine Anwendung oder ein Werkzeug mit dieser Berechtigung
	ausgeführt wird, erhält es die Berechtigungen basierend auf
	der Gruppe, welche die Datei besitzt und nicht die des
	Benutzers, der den Prozess gestartet hat.</para>

      <para>Um die <literal>setgid</literal>-Berechtigung auf einer
	Datei zu setzen, geben Sie &man.chmod.1; eine führende
	Zwei (2) mit:</para>

      <screen>&prompt.root; <userinput>chmod 2755 sgidexample.sh</userinput></screen>

      <para>Beachten Sie in der folgenden Auflistung, dass das
	<literal>s</literal> sich jetzt in dem Feld befindet, das für
	die Berechtigungen der Gruppe bestimmt ist:</para>

      <screen>-rwxr-sr-x   1 trhodes  trhodes    44 Aug 31 01:49 sgidexample.sh</screen>

      <note>
	<para>Obwohl es sich bei dem in diesen Beispielen gezeigten
	  Shellskript um eine ausführbare Datei handelt, wird es nicht
	  mit einer anderen <acronym>EUID</acronym> oder effektiven
	  Benutzer-ID ausgeführt.  Das ist so, weil Shellskripte
	  keinen Zugriff auf &man.setuid.2;-Systemaufrufe
	  erhalten.</para>
      </note>

      <para>Die <literal>setuid</literal> und
	<literal>setgid</literal> Berechtigungs-Bits können die
	Systemsicherheit verringern, da sie erhöhte Rechte
	ermöglichen.  Das dritte Berechtigungs-Bit, das
	<literal>sticky bit</literal> kann die Sicherheit eines
	Systems erhöhen.</para>

      <para>Wenn das <literal>sticky bit</literal> auf einem
	Verzeichnis angewendet wird, erlaubt es das Löschen von
	Dateien nur durch den Besitzer der Datei.  Dies ist nützlich,
	um die Löschung von Dateien in öffentlichen Verzeichnissen wie
	<filename>/tmp</filename>, durch Benutzer denen diese Dateien
	nicht gehören, zu verhindern.  Um diese Berechtigung
	anzuwenden, stellen Sie der Berechtigung eine Eins (1)
	voran:</para>

      <screen>&prompt.root; <userinput>chmod 1777 /tmp</userinput></screen>

      <para>Das <literal>sticky bit</literal> kann anhand des
	<literal>t</literal> ganz am Ende der Berechtigungen abgelesen
	werden.</para>

      <screen>&prompt.root; <userinput>ls -al / | grep tmp</userinput></screen>

      <screen>drwxrwxrwt  10 root  wheel         512 Aug 31 01:49 tmp</screen>

    </sect2>
  </sect1>

  <sect1 xml:id="dirstructure">
    <title>Verzeichnis-Strukturen</title>

    <indexterm><primary>Verzeichnis Hierarchien</primary></indexterm>

    <para>Die &os;-Verzeichnishierarchie ist die Grundlage, um ein
      umfassendes Verständnis des Systems zu erlangen.  Das wichtigste
      Verzeichnis ist das Root-Verzeichnis <quote>/</quote>.  Dieses
      Verzeichnis ist das erste, das während des Bootens eingehangen
      wird.  Es enthält das notwendige Basissystem, um das
      Betriebssystem in den Mehrbenutzerbetrieb zu bringen.  Das
      Root-Verzeichnis enthält auch die Mountpunkte für Dateisysteme,
      die beim Wechsel in den Multiuser-Modus eingehängt
      werden.</para>

    <para>Ein Mountpunkt ist ein Verzeichnis, in das zusätzliche
      Dateisysteme (in der Regel unterhalb des Wurzelverzeichnisses)
      eingehängt werden können.  Dieser Vorgang wird in
      <xref linkend="disk-organization"/> ausführlich beschrieben.
      Standard-Mountpunkte sind <filename>/usr</filename>,
      <filename>/var</filename>, <filename>/tmp</filename>,
      <filename>/mnt</filename> sowie <filename>/cdrom</filename>.
      Auf diese Verzeichnisse verweisen üblicherweise Einträge
      in <filename>/etc/fstab</filename>.  Diese Datei ist
      eine Tabelle mit verschiedenen Dateisystemen und Mountpunkten,
      vom System gelesen werden.  Die meisten der Dateisysteme in
      <filename>/etc/fstab</filename> werden beim Booten automatisch
      durch das Skript &man.rc.8; gemountet, wenn die zugehörigen
      Einträge nicht mit <option>noauto</option>
      versehen sind.  Weitere Informationen zu diesem Thema finden Sie
      im <xref linkend="disks-fstab"/>.</para>

    <para>Eine vollständige Beschreibung der Dateisystem-Hierarchie
      finden Sie in &man.hier.7;.  Die folgende Aufstellung gibt einen
      kurzen Überblick über die am häufigsten verwendeten
      Verzeichnisse:</para>

    <informaltable frame="none" pgwide="1">
      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>Verzeichnis</entry>
	    <entry>Beschreibung</entry>
	  </row>
	</thead>
	<tbody valign="top">
	  <row>
	    <entry><filename>/</filename></entry>
	    <entry>Wurzelverzeichnis des Dateisystems.</entry>
	  </row>

	  <row>
	    <entry><filename>/bin/</filename></entry>
	    <entry>Grundlegende Werkzeuge für den Single-User-Modus
	      sowie den Mehrbenutzerbetrieb.</entry>
	  </row>

	  <row>
	    <entry><filename>/boot/</filename></entry>
	    <entry>Programme und Konfigurationsdateien, die während
	      des Bootens benutzt werden.</entry>
	  </row>

	  <row>
	    <entry><filename>/boot/defaults/</filename></entry>
	    <entry>Vorgaben für die Boot-Konfiguration.  Weitere
	      Details finden Sie in &man.loader.conf.5;.</entry>
	  </row>

	  <row>
	    <entry><filename>/dev/</filename></entry>
	    <entry>Gerätedateien.  Weitere Details finden Sie in
	      &man.intro.4;.</entry>
	  </row>

	  <row>
	    <entry><filename>/etc/</filename></entry>
	    <entry>Konfigurationsdateien und Skripten des
	      Systems.</entry>
	  </row>

	  <row>
	    <entry><filename>/etc/defaults/</filename></entry>
	    <entry>Vorgaben für die System Konfigurationsdateien.
	      Weitere Details finden Sie in &man.rc.8;.</entry>
	  </row>

	  <row>
	    <entry><filename>/etc/mail/</filename></entry>
	    <entry>Konfigurationsdateien von MTAs wie
	      &man.sendmail.8;.</entry>
	  </row>

	  <row>
	    <entry><filename>/etc/periodic/</filename></entry>
	    <entry>Täglich, wöchentlich oder monatlich laufende
	      Skripte, die von &man.cron.8; gestartet werden.
	      Weitere Details finden Sie in
	      &man.periodic.8;.</entry>
	  </row>

	  <row>
	    <entry><filename>/etc/ppp/</filename></entry>
	    <entry>Konfigurationsdateien von &man.ppp.8;.</entry>
	  </row>

	  <row>
	    <entry><filename>/mnt/</filename></entry>
	    <entry>Ein leeres Verzeichnis, das von
	      Systemadministratoren häufig als temporärer Mountpunkt
	      genutzt wird.</entry>
	  </row>

	  <row>
	    <entry><filename>/proc/</filename></entry>
	    <entry>Prozess Dateisystem.  Weitere Details finden Sie
	      in &man.procfs.5; und &man.mount.procfs.8;.</entry>
	  </row>

	  <row>
	    <entry><filename>/rescue/</filename></entry>
	    <entry>Statisch gelinkte Programme zur Wiederherstellung
	      des Systems, wie in &man.rescue.8;
	      beschrieben.</entry>
	  </row>

	  <row>
	    <entry><filename>/root/</filename></entry>
	    <entry>Home Verzeichnis von <systemitem
		class="username">root</systemitem>.</entry>
	  </row>

	  <row>
	    <entry><filename>/sbin/</filename></entry>
	    <entry>Systemprogramme und administrative Werkzeuge, die
	      grundlegend für den Single-User-Modus und den
	      Mehrbenutzerbetrieb sind.</entry>
	  </row>

	  <row>
	    <entry><filename>/tmp/</filename></entry>
	    <entry>Temporäre Dateien, die für gewöhnlich bei einem
	      Neustart des Systems verloren gehen.  Häufig wird ein
	      speicherbasiertes Dateisystem unter
	      <filename>/tmp</filename> eingehängt.  Dieser Vorgang
	      kann automatisiert werden, wenn tmpmfs-bezogene
	      Variablen von &man.rc.conf.5; verwendet werden, oder
	      ein entsprechender Eintrag in
	      <filename>/etc/fstab</filename> existiert.  Weitere
	      Informationen finden Sie in &man.mdmfs.8;.</entry>
	  </row>

	  <row>
	    <entry><filename>/usr/</filename></entry>
	    <entry>Der Großteil der Benutzerprogramme und
	      Anwendungen.</entry>
	  </row>

	  <row>
	    <entry><filename>/usr/bin/</filename></entry>
	    <entry>Gebräuchliche Werkzeuge, Programmierhilfen und
	      Anwendungen.</entry>
	  </row>

	  <row>
	    <entry><filename>/usr/include/</filename></entry>
	    <entry>Standard C include-Dateien.</entry>
	  </row>

	  <row>
	    <entry><filename>/usr/lib/</filename></entry>
	    <entry>Bibliotheken.</entry>
	  </row>

	  <row>
	    <entry><filename>/usr/libdata/</filename></entry>
	    <entry>Daten verschiedener Werkzeuge.</entry>
	  </row>

	  <row>
	    <entry><filename>/usr/libexec/</filename></entry>
	    <entry>System-Dämonen und System-Werkzeuge, die von
	      anderen Programmen ausgeführt werden.</entry>
	  </row>

	  <row>
	    <entry><filename>/usr/local/</filename></entry>

	    <entry>Lokale Programme und Bibliotheken.  Die
	      Ports-Sammlung von &os; benutzt dieses Verzeichnis
	      als Zielverzeichnis für Anwendungen.  Innerhalb von
	      <filename>/usr/local</filename> sollte das von
	      &man.hier.7; beschriebene Layout für
	      <filename>/usr</filename> benutzt werden.  Das
	      <filename>man</filename> Verzeichnis wird direkt unter
	      <filename>/usr/local</filename> anstelle unter
	      <filename>/usr/local/share</filename> angelegt.  Die
	      Dokumentation der Ports findet sich in
	      <filename>share/doc/<replaceable>port</replaceable></filename>.</entry>
	  </row>

	  <row>
	    <entry><filename>/usr/obj/</filename></entry>
	    <entry>Von der Architektur abhängiger Verzeichnisbaum,
	      der durch das Bauen von <filename>/usr/src</filename>
	      entsteht.</entry>
	  </row>

	  <row>
	    <entry><filename>/usr/ports/</filename></entry>
	    <entry>Die &os;-Ports-Sammlung (optional).</entry>
	  </row>

	  <row>
	    <entry><filename>/usr/sbin/</filename></entry>
	    <entry>System-Dämonen und System-Werkzeuge, die von
	      Benutzern ausgeführt werden.</entry>
	  </row>

	  <row>
	    <entry><filename>/usr/share/</filename></entry>
	    <entry>Von der Architektur unabhängige Dateien.</entry>
	  </row>

	  <row>
	    <entry><filename>/usr/src/</filename></entry>
	    <entry>Quelldateien von BSD und/oder lokalen
	      Ergänzungen.</entry>
	  </row>

	  <row>
	    <entry><filename>/var/</filename></entry>
	    <entry>Wird für mehrere Zwecke genutzt und enthält
	      Logdateien, temporäre Daten und Spooldateien.
	      Manchmal wird ein speicherbasiertes Dateisystem unter
	      <filename>/var</filename>
	      eingehängt.  Dieser Vorgang kann automatisiert werden,
	      wenn die varmfs-bezogenen Variablen von
	      &man.rc.conf.5; verwendet werden, oder ein
	      entsprechender Eintrag in
	      <filename>/etc/fstab</filename> existiert.  Weitere
	      Informationen finden Sie in &man.mdmfs.8;.</entry>
	  </row>

	  <row>
	    <entry><filename>/var/log/</filename></entry>
	    <entry>Verschiedene Logdateien des Systems.</entry>
	  </row>

	  <row>
	    <entry><filename>/var/mail/</filename></entry>
	    <entry>Postfächer der Benutzer.</entry>
	  </row>

	  <row>
	    <entry><filename>/var/spool/</filename></entry>
	    <entry>Verschiedene Spool-Verzeichnisse der Drucker- und
	      Mailsysteme.</entry>
	  </row>

	  <row>
	    <entry><filename>/var/tmp/</filename></entry>
	    <entry>Temporäre Dateien, die in der Regel auch bei
	      einem Neustart des Systems erhalten bleiben, es sei
	      denn, bei <filename>/var</filename> handelt es sich um
	      ein speicherbasiertes Dateisystem.</entry>
	  </row>

	  <row>
	    <entry><filename>/var/yp/</filename></entry>
	    <entry>NIS maps.</entry>
	  </row>

	</tbody>
      </tgroup>
    </informaltable>
  </sect1>

  <sect1 xml:id="disk-organization">
    <title>Festplatten, Slices und Partitionen</title>

    <para>&os; identifiziert Dateien anhand eines Dateinamens.  In
      Dateinamen wird zwischen Groß- und Kleinschreibung
      unterschieden:  <filename>readme.txt</filename> und
      <filename>README.TXT</filename> bezeichnen daher zwei
      verschiedene Dateien.  &os; benutzt keine Dateiendungen, um den
      Typ der Datei zu bestimmen, egal ob es sich um ein Programm, ein
      Dokument oder um andere Daten handelt.</para>

    <para>Dateien werden in Verzeichnissen gespeichert.  In einem
      Verzeichnis können sich keine oder hunderte Dateien befinden.
      Ein Verzeichnis kann auch andere Verzeichnisse enthalten und so
      eine Hierarchie von Verzeichnissen aufbauen, die die Ablage von
      Daten erleichtert.</para>

    <para>In Dateinamen werden Verzeichnisse durch einen
      Schrägstrich (<literal>/</literal>,
      <foreignphrase>Slash</foreignphrase>) getrennt.  Wenn z.B.
      das Verzeichnis <filename>foo</filename> ein Verzeichnis
      <filename>bar</filename> enthält, in dem sich die Datei
      <filename>readme.txt</filename> befindet, lautet der
      vollständige Name der Datei (oder der
      <firstterm>Pfad</firstterm> zur Datei)
      <filename>foo/bar/readme.txt</filename>.  Beachten Sie, dass
      sich dies von &windows; unterscheidet, wo der
      <literal>\</literal> (<foreignphrase>Backslash</foreignphrase>
      für die Trennung von Datei- und Verzeichnisnamen verwendet wird.
      &os; benutzt keine Laufwerkbuchstaben oder Laufwerknamen im
      Pfad.  Beispielsweise würde man unter &os; nicht
      <filename>c:\foo\bar\readme.txt</filename> eingeben.</para>

    <para>Verzeichnisse und Dateien werden in einem Dateisystem
      gespeichert.  Jedes Dateisystem besitzt genau ein
      <firstterm>Wurzelverzeichnis</firstterm>, das so genannte
      <foreignphrase>Root-Directory</foreignphrase>.  Dieses
      Wurzelverzeichnis kann weitere Verzeichnisse enthalten.  Ein
      Dateisystem wird als Wurzeldateisystem festgelegt, und jedes
      weitere Dateisystem wird unter dem Wurzeldateisystem
      <firstterm>eingehangen</firstterm>.  Daher scheint jedes
      Verzeichnis, unabhängig von der Anzahl der Platten, auf
      derselben Platte zu liegen.</para>

    <para>Betrachten wir die drei Dateisysteme <literal>A</literal>,
      <literal>B</literal> und <literal>C</literal>.  Jedes
      Dateisystem besitzt ein eigenes Wurzelverzeichnis, das zwei
      andere Verzeichnisse enthält: <filename>A1</filename>,
      <filename>A2</filename>, <filename>B1</filename>,
      <filename>B2</filename>, <filename>C1</filename> und
      <filename>C2</filename>.</para>

    <para>Das Wurzeldateisystem soll <literal>A</literal> sein.
      &man.ls.1; zeigt darin die beiden Verzeichnisse
      <filename>A1</filename> und <filename>A2</filename> an.
      Der Verzeichnisbaum sieht wie folgt aus:</para>

    <mediaobject>
      <imageobject>
	<imagedata fileref="basics/example-dir1"/>
      </imageobject>

      <textobject>
	<literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2</literallayout>
      </textobject>
    </mediaobject>

    <para>Ein Dateisystem wird in einem Verzeichnis eines anderen
      Dateisystems eingehangen.  Wir hängen nun das Dateisystem
      <literal>B</literal> in das Verzeichnis
      <filename>A1</filename> ein.  Das Wurzelverzeichnis von
      <literal>B</literal> ersetzt nun das Verzeichnis
      <filename>A1</filename> und die Verzeichnisse des Dateisystems
      <literal>B</literal> werden sichtbar:</para>

    <mediaobject>
      <imageobject>
	<imagedata fileref="basics/example-dir2"/>
      </imageobject>

      <textobject>
	<literallayout class="monospaced"> /
 |
 +--- A1
 |     |
 |     +--- B1
 |     |
 |     `--- B2
 |
 `--- A2</literallayout>
      </textobject>
    </mediaobject>

    <para>Jede Datei in den Verzeichnissen
      <filename>B1</filename> oder <filename>B2</filename> kann
      über den Pfad <filename>/A1/B1</filename> oder
      <filename>/A1/B2</filename> erreicht werden.  Dateien aus dem
      Verzeichnis <filename>/A1</filename> sind jetzt verborgen.
      Wenn das Dateisystem <literal>B</literal> wieder
      <firstterm>abgehangen</firstterm> wird
      (<foreignphrase>umount</foreignphrase>), erscheinen die
      verborgenen Dateien wieder.</para>

    <para>Wenn das Dateisystem <literal>B</literal> unter dem
      Verzeichnis <filename>A2</filename>
      eingehangen würde, sähe der Verzeichnisbaum
      so aus:</para>

    <mediaobject>
      <imageobject>
	<imagedata fileref="basics/example-dir3"/>
      </imageobject>

      <textobject>
	<literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2
       |
       +--- B1
       |
       `--- B2</literallayout>
      </textobject>
    </mediaobject>

    <para>Die Dateien des Dateisystems <literal>B</literal> wären
      unter den Pfaden <filename>/A2/B1</filename> und
      <filename>/A2/B2</filename> erreichbar.</para>

    <para>Dateisysteme können übereinander eingehangen werden.  Der
      folgende Baum entsteht, wenn im letzten Beispiel das
      Dateisystem <literal>C</literal> in das Verzeichnis
      <filename>B1</filename> des Dateisystems
      <literal>B</literal> eingehangen wird:</para>

    <mediaobject>
      <imageobject>
	<imagedata fileref="basics/example-dir4"/>
      </imageobject>

      <textobject>
	<literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2
       |
       +--- B1
       |     |
       |     +--- C1
       |     |
       |     `--- C2
       |
       `--- B2</literallayout>
      </textobject>
    </mediaobject>

    <para><literal>C</literal> könnte auch im Verzeichnis
      <filename>A1</filename> eingehangen
      werden:</para>

    <mediaobject>
      <imageobject>
	<imagedata fileref="basics/example-dir5"/>
      </imageobject>

      <textobject>
	<literallayout class="monospaced"> /
 |
 +--- A1
 |     |
 |     +--- C1
 |     |
 |     `--- C2
 |
 `--- A2
       |
       +--- B1
       |
       `--- B2</literallayout>
      </textobject>
    </mediaobject>

    <para>Sie können sogar mit nur einem großen
      Dateisystem auskommen.  Dies hat mehrere Nachteile
      und einen Vorteil.</para>

    <itemizedlist>
      <title>Vorteile mehrerer Dateisysteme</title>

      <listitem>
	<para>Die Dateisysteme können mit unterschiedlichen
	  Optionen (<foreignphrase>mount options</foreignphrase>)
	  eingehangen werden.  Beispielsweise kann das
	  Wurzeldateisystem schreibgeschützt eingehangen werden,
	  sodass es für Benutzer nicht möglich ist, versehentlich
	  kritische Dateien zu editieren oder zu löschen.
	  Von Benutzern beschreibbare Dateisysteme
	  wie <filename>/home</filename>
	  können mit der Option <firstterm>nosuid</firstterm>
	  eingehangen werden, wenn sie von anderen Dateisystemen
	  getrennt sind.  Die <firstterm>SUID</firstterm>- und
	  <firstterm>GUID</firstterm>-Bits verlieren auf solchen
	  Dateisystemen ihre Wirkung und die Sicherheit des
	  Systems kann dadurch erhöht werden.</para>
      </listitem>

      <listitem>
	<para>Die Lage von Dateien im Dateisystem wird, abhängig
	  vom Gebrauch des Dateisystems, automatisch von &os;
	  optimiert.  Ein Dateisystem mit vielen kleinen Dateien,
	  die häufig geschrieben werden, wird anders behandelt
	  als ein Dateisystem mit wenigen großen Dateien.
	  Mit nur einem Dateisystem ist diese Optimierung
	  unmöglich.</para>
      </listitem>

      <listitem>
	<para>In der Regel übersteht ein &os;-Dateisystem auch
	  einen Stromausfall.  Allerdings kann ein Stromausfall zu
	  einem kritischen Zeitpunkt das Dateisystem beschädigen.
	  Wenn die Daten über mehrere Dateisysteme verteilt
	  sind, lässt sich das System mit hoher
	  Wahrscheinlichkeit noch starten.  Dies erleichtert
	  das Zurückspielen von Datensicherungen.</para>
      </listitem>
    </itemizedlist>

    <itemizedlist>
      <title>Vorteil eines einzelnen Dateisystems</title>

      <listitem>
	<para>Dateisysteme haben eine festgelegte Größe.  Es kann
	  passieren, dass Sie eine Partition vergrößern müssen.  Dies
	  ist nicht leicht: Sie müssen die Daten sichern, das
	  Dateisystem vergrößert anlegen und die gesicherten Daten
	  zurückspielen.</para>

	<important>
	  <para>&os; kennt den Befehl &man.growfs.8;, mit dem man
	    Dateisysteme im laufenden Betrieb vergrößern kann.</para>
	</important>
      </listitem>
    </itemizedlist>

    <para>Dateisysteme befinden sich in Partitionen (damit sind
      nicht die normalen &ms-dos;-Partitionen gemeint).  Jede
      Partition wird mit einem Buchstaben von <literal>a</literal>
      bis <literal>h</literal> bezeichnet und kann nur ein
      Dateisystem enthalten.  Dateisysteme können daher über ihren
      Mount-Point, den Punkt an dem sie eingehangen sind, oder
      den Buchstaben der Partition, in der sie liegen, identifiziert
      werden.</para>

    <para>&os; benutzt einen Teil der Platte für den
      <firstterm>Swap-Bereich</firstterm>, um
      <firstterm>virtuellen Speicher</firstterm> zur Verfügung zu
      stellen.  Dadurch kann der Rechner Anwendungen mehr Speicher
      zur Verfügung stellen als tatsächlich eingebaut ist.  Wenn der
      Speicher knapp wird, kann &os; nicht benutzte Daten in den
      Swap-Bereich auslagern.  Die ausgelagerten Daten können später
      wieder in den Speicher geholt werden (dafür werden dann andere
      Daten ausgelagert).</para>

    <para>Für einige Partitionen gelten besondere Konventionen:</para>

    <informaltable frame="none" pgwide="1">
      <tgroup cols="2">
	<colspec colwidth="1*"/>
	<colspec colwidth="5*"/>

	<thead>
	  <row>
	    <entry>Partition</entry>

	    <entry>Konvention</entry>
	  </row>
	</thead>

	<tbody valign="top">
	  <row>
	    <entry><literal>a</literal></entry>

	    <entry>Enthält normalerweise
	      das Wurzeldateisystem.</entry>
	  </row>

	  <row>
	    <entry><literal>b</literal></entry>

	    <entry>Enthält normalerweise
	      den Swap-Bereich.</entry>
	  </row>

	  <row>
	    <entry><literal>c</literal></entry>

	    <entry>Ist normalerweise genauso groß wie die Slice in der
	      die Partition liegt.  Werkzeuge, die auf der kompletten
	      Slice arbeiten, wie ein Bad-Block-Scanner, können so die
	      <literal>c</literal>-Partition benutzen.  Für gewöhnlich
	      wird in dieser Partition kein Dateisystem
	      angelegt.</entry>
	  </row>

	  <row>
	    <entry><literal>d</literal></entry>

	    <entry>Früher hatte die <literal>d</literal>-Partition
	      eine besondere Bedeutung.  Heute ist dies nicht mehr
	      der Fall und die Partition <literal>d</literal> kann
	      wie jede andere Partition auch verwendet
	      werden.</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <para>In &os; werden Festplatten in Slices, welche in &windows;
      als Partitionen bekannt sind, aufgeteilt und von 1 bis 4
      durchnummeriert.  Diese werden dann in Partitionen unterteilt,
      welche wiederum Dateisysteme enthalten und mit Buchstaben
      benannt werden.</para>

    <indexterm><primary>Slices</primary></indexterm>
    <indexterm><primary>Partitionen</primary></indexterm>
    <indexterm><primary>dangerously dedicated</primary></indexterm>

    <para>Die Slice-Nummern werden mit vorgestelltem
      <literal>s</literal> hinter den Gerätenamen gestellt:
      <quote>da0<emphasis>s1</emphasis></quote> ist die erste Slice
      auf dem ersten <acronym>SCSI</acronym>-Laufwerk.  Auf einer
      Festplatte gibt es höchstens vier Slices.  In einer Slice des
      passenden Typs kann es weitere logische Slices geben.  Diese
      erweiterten Slices werden ab fünf durchnummeriert:
      <quote>ada0<emphasis>s5</emphasis></quote> ist die erste
      erweiterte Slice auf einer SATA-Platte.  Diese Geräte werden
      von Dateisystemen benutzt, die sich in einer kompletten Slice
      befinden müssen.</para>

    <para>Slices, <quote>dangerously dedicated</quote>-Festplatten
      und andere Platten enthalten Partitionen, die mit Buchstaben
      von <literal>a</literal> bis <literal>h</literal> bezeichnet
      werden.  Der Buchstabe wird an den Gerätenamen gehangen:
      <quote>da0<emphasis>a</emphasis></quote> ist die
      <literal>a</literal>-Partition des ersten
      <literal>da</literal>-Laufwerks.  Dieses Laufwerk ist
      <quote>dangerously dedicated</quote>.
      <quote>ada1s3<emphasis>e</emphasis></quote> ist
      die fünfte Partition in der dritten Slice der zweiten
      SATA-Platte.</para>

    <para>Schließlich wird noch jede Festplatte des Systems eindeutig
      bezeichnet.  Der Name einer Festplatte beginnt mit einem Code,
      der den Typ der Platte bezeichnet.  Es folgt eine Nummer, die
      angibt, um welche Festplatte es sich handelt.  Anders als bei
      Slices werden Festplatten von Null beginnend durchnummeriert.
      Gängige Festplatten-Namen sind in <xref linkend="disks-naming"/>
      aufgeführt.</para>

    <para>Wenn Sie eine Partition angeben, beinhaltet das den
      Plattennamen, <literal>s</literal>, die Slice-Nummer und den
      Buchstaben der Partition.  Einige Beispiele finden Sie in
      <xref linkend="basics-disk-slice-part"/>.</para>

    <para>Der Aufbau einer Festplatte wird in <xref
	linkend="basics-concept-disk-model"/> dargestellt.</para>

    <para>Bei der Installation von &os; legen Sie Slices auf der
      Festplatte an, erstellen Partitionen für &os; innerhalb der
      Slice, erstellen ein Dateisystem oder Auslagerungsbereiche und
      entscheiden, welche Dateisysteme wo eingehangen werden.</para>

    <table frame="none" pgwide="1" xml:id="disks-naming">
      <title>Laufwerk-Codes</title>

      <tgroup cols="2">
	<colspec colwidth="1*"/>
	<colspec colwidth="5*"/>

	<thead>
	  <row>
	    <entry>Laufwerkstyp</entry>
	    <entry>Gerätename</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry><acronym>SATA</acronym>- und
	      <acronym>IDE</acronym>-Festplatten</entry>
	    <entry><literal>ada</literal> oder
	      <literal>ad</literal></entry>
	  </row>

	  <row>
	    <entry><acronym>SCSI</acronym>-Festplatten und
	      <acronym>USB</acronym>-Speichermedien</entry>
	    <entry><literal>da</literal></entry>
	  </row>

	  <row>
	    <entry><acronym>SATA</acronym>- und
	      <acronym>IDE</acronym>-<acronym>CD-ROM</acronym>-Laufwerke</entry>
	    <entry><literal>cd</literal> oder
	      <literal>acd</literal></entry>
	  </row>

	  <row>
	    <entry><acronym>SCSI</acronym>-<acronym>CD-ROM</acronym>-Laufwerke</entry>
	    <entry><literal>cd</literal></entry>
	  </row>

	  <row>
	    <entry>Diskettenlaufwerke</entry>
	    <entry><literal>fd</literal></entry>
	  </row>

	  <row>
	    <entry>Verschiedene proprietäre
	      <acronym>CD-ROM</acronym>-Laufwerke</entry>
	    <entry><literal>mcd</literal> für Mitsumi
	      <acronym>CD-ROM</acronym> und <literal>scd</literal>
	      für Sony <acronym>CD-ROM</acronym></entry>
	  </row>

	  <row>
	    <entry><acronym>SCSI</acronym>-Bandlaufwerke</entry>
	    <entry><literal>sa</literal></entry>
	  </row>

	  <row>
	    <entry><acronym>IDE</acronym>-Bandlaufwerke</entry>
	    <entry><literal>ast</literal></entry>
	  </row>

	  <row>
	    <entry>RAID-Laufwerke</entry>
	    <entry>Beispiele sind <literal>aacd</literal> für
	      &adaptec; AdvancedRAID, <literal>mlxd</literal> für
	      &mylex;, <literal>amrd</literal> für AMI &megaraid;,
	      <literal>idad</literal> für Compaq Smart RAID,
	      <literal>twed</literal> für &tm.3ware; RAID.</entry>
	  </row>
	</tbody>
      </tgroup>
    </table>

    <example xml:id="basics-disk-slice-part">
      <title>Namen von Platten, Slices und Partitionen</title>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <colspec colwidth="1*"/>
	  <colspec colwidth="5*"/>

	  <thead>
	    <row>
	      <entry>Name</entry>

	      <entry>Bedeutung</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><filename>ada0s1a</filename></entry>

	      <entry>Die erste Partition (<literal>a</literal>)
		in der ersten Slice (<literal>s1</literal>) der
		ersten <acronym>SATA</acronym>-Festplatte
		(<literal>ada0</literal>).</entry>
	    </row>

	    <row>
	      <entry><filename>da1s2e</filename></entry>

	      <entry>Die fünfte Partition (<literal>e</literal>)
		der zweiten Slice (<literal>s2</literal>) auf
		der zweiten SCSI-Festplatte
		(<literal>da1</literal>).</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </example>

    <example xml:id="basics-concept-disk-model">
      <title>Aufteilung einer Festplatte</title>

      <para>Das folgende Diagramm zeigt die Sicht von &os; auf die
	erste <acronym>SATA</acronym>-Festplatte des Systems.  Die
	Platte soll 250&nbsp;GB groß sein und eine 80&nbsp;GB große
	Slice (&ms-dos;-Partitionen) sowie eine 170&nbsp;GB große
	Slice enthalten.  Die erste Slice enthält ein &windows;
	<acronym>NTFS</acronym>-Dateisystem
	(<filename>C:</filename>), die zweite Slice enthält eine
	&os;-Installation.  Die &os;-Installation in diesem Beispiel
	verwendet vier Datenpartitionen und einen
	Auslagerungsbereich.</para>

      <para>Jede der vier Partitionen enthält ein Dateisystem.  Das
	Wurzeldateisystem ist die <literal>a</literal>-Partition.
	In der <literal>d</literal>-Partition befindet sich
	<filename>/var</filename> und in der
	<literal>f</literal>-Partition befindet sich
	<filename>/usr</filename>.  Die
	<literal>c</literal>-Partition bezieht sich auf die gesamte
	Slice und wird nicht für gewöhnliche Partitionen
	verwendet.</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="basics/disk-layout"/>
	</imageobject>
      </mediaobject>
    </example>
  </sect1>

  <sect1 xml:id="mount-unmount">
    <title>Anhängen und Abhängen von Dateisystemen</title>

    <para>Ein Dateisystem wird am besten als ein Baum mit der
      Wurzel <filename>/</filename> veranschaulicht.
      <filename>/dev</filename>, <filename>/usr</filename>, und
      die anderen Verzeichnisse im Rootverzeichnis sind Zweige,
      die wiederum eigene Zweige wie <filename>/usr/local</filename>
      haben können.</para>

    <indexterm><primary>Root-Dateisystem</primary></indexterm>

    <para>Es gibt verschiedene Gründe, bestimmte dieser Verzeichnisse
      auf eigenen Dateisystemen anzulegen.  <filename>/var</filename>
      enthält <filename>log/</filename>, <filename>spool/</filename>
      sowie verschiedene andere temporäre
      Dateien und kann sich daher schnell füllen.  Es empfiehlt sich,
      <filename>/var</filename> von <filename>/</filename> zu trennen,
      da es schlecht ist, wenn das Root-Dateisystem voll
      läuft.</para>

    <para>Ein weiterer Grund bestimmte Verzeichnisbäume auf
      andere Dateisysteme zu legen, ist gegeben, wenn sich die
      Verzeichnisbäume auf gesonderten physikalischen oder
      virtuellen Platten, wie
      <link linkend="network-nfs">Network File System</link>
      oder CD-ROM-Laufwerken, befinden.</para>

    <sect2 xml:id="disks-fstab">
      <title>Die <filename>fstab</filename> Datei</title>

      <indexterm>
	 <primary>Dateisysteme</primary>
	 <secondary>fstab</secondary>
      </indexterm>

      <para>Während des Boot-Prozesses (<xref linkend="boot"/>)
	werden in <filename>/etc/fstab</filename> aufgeführte
	Verzeichnisse, sofern sie nicht mit der Option
	<option>noauto</option> versehen sind, automatisch angehangen.
	Diese Datei enthält Einträge in folgendem Format:</para>

      <programlisting><replaceable>device</replaceable>	<replaceable>/mount-point</replaceable>	<replaceable>fstype</replaceable>	<replaceable>options</replaceable>	<replaceable>dumpfreq</replaceable>	<replaceable>passno</replaceable></programlisting>

      <variablelist>
	<varlistentry>
	  <term><literal>device</literal></term>

	  <listitem>
	    <para>Ein existierender Gerätename
	      wie in <xref linkend="disks-naming"/>
	      beschrieben.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>mount-point</literal></term>

	  <listitem>
	    <para>Ein existierendes Verzeichnis, auf dem
	      das Dateisystem gemountet wird.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>fstype</literal></term>

	  <listitem>
	    <para>Der Typ des Dateisystems,
	      der an &man.mount.8; weitergegeben wird.  &os;s
	      Standarddateisystem ist <literal>ufs</literal>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>options</literal></term>

	  <listitem>
	    <para>Entweder <option>rw</option>
	      für beschreibbare Dateisysteme oder <option>ro</option>
	      für schreibgeschützte Dateisysteme, gefolgt von
	      weiteren benötigten Optionen.  Eine häufig verwendete
	      Option ist <option>noauto</option> für Dateisysteme,
	      die während der normalen Bootsequenz nicht angehangen
	      werden sollen.  Weitere Optionen finden sich
	      in &man.mount.8;.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>dumpfreq</literal></term>

	  <listitem>
	    <para>Wird von &man.dump.8; benutzt, um bestimmen
	      zu können, welche Dateisysteme gesichert werden müssen.
	      Fehlt der Wert, wird <literal>0</literal>
	      angenommen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>passno</literal></term>

	  <listitem>
	    <para>Bestimmt die Reihenfolge, in der die Dateisysteme
	      überprüft werden sollen.  Für Dateisysteme, die
	      übersprungen werden sollen, ist
	      <literal>passno</literal> auf <literal>0</literal> zu
	      setzen.  Für das Root-Dateisystem, das vor allen anderen
	      überprüft werden muss, sollte der Wert von
	      <literal>passno</literal> <literal>1</literal> betragen.
	      Allen anderen Dateisystemen sollten Werte größer
	      <literal>1</literal> zugewiesen werden.  Wenn mehrere
	      Dateisysteme den gleichen Wert besitzen, wird
	      &man.fsck.8; versuchen, diese parallel zu
	      überprüfen.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>Lesen Sie &man.fstab.5; für weitere Informationen über das
	Format von <filename>/etc/fstab</filename> und dessen
	Optionen.</para>
    </sect2>

    <sect2 xml:id="disks-mount">
      <title>Verwendung von &man.mount.8;</title>

      <indexterm>
	<primary>Dateisysteme</primary>
	<secondary>anhängen</secondary>
      </indexterm>

      <para>Dateisysteme werden mit &man.mount.8; eingehängt.  In der
	grundlegenden Form wird es wie folgt benutzt:</para>

      <informalexample>
	<screen>&prompt.root; <userinput>mount <replaceable>device</replaceable> <replaceable>mountpoint</replaceable></userinput></screen>
      </informalexample>

      <para>Dieser Befehl bietet viele Optionen, die in &man.mount.8;
	beschrieben werden.  Die am häufigsten verwendeten Optionen
	sind:</para>

      <variablelist>
	<title>Optionen von <command>mount</command></title>

	<varlistentry>
	  <term><option>-a</option></term>

	  <listitem>
	    <para>Hängt alle Dateisysteme aus
	      <filename>/etc/fstab</filename> an.  Davon ausgenommen
	      sind Dateisysteme, die mit <quote>noauto</quote>
	      markiert sind, die mit der Option <option>-t</option>
	      ausgeschlossen wurden und Dateisysteme, die schon
	      angehangen sind.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-d</option></term>

	  <listitem>
	    <para>Führt alles bis auf den
	      <function>mount</function>-Systemaufruf aus.
	      Nützlich ist diese Option in Verbindung
	      mit <option>-v</option>.  Damit wird angezeigt, was
	      &man.mount.8; tatsächlich versuchen
	      würde, um das Dateisystem anzuhängen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-f</option></term>

	  <listitem>
	    <para>Erzwingt das Anhängen eines unsauberen Dateisystems
	      (riskant) oder die Rücknahme des Schreibzugriffs, wenn
	      der Status des Dateisystems von beschreibbar auf
	      schreibgeschützt geändert wird.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-r</option></term>

	  <listitem>
	    <para>Hängt das Dateisystem schreibgeschützt ein.  Dies
	      kann auch durch Angabe von <option>-o ro</option>
	      erreicht werden.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-t</option>
	    <replaceable>fstype</replaceable></term>

	  <listitem>
	    <para>Hängt das Dateisystem mit dem angegebenen Typ an,
	      oder hängt nur Dateisysteme mit dem angegebenen Typ
	      an, wenn <option>-a</option> angegeben wurde.
	      <quote>ufs</quote> ist das Standarddateisystem.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-u</option></term>

	  <listitem>
	    <para>Aktualisiert die Mountoptionen des
	      Dateisystems.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-v</option></term>

	  <listitem>
	    <para>Geschwätzig sein.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-w</option></term>

	  <listitem>
	    <para>Hängt das Dateisystem beschreibbar an.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>Die folgenden Optionen können durch eine Kommata
	separierte Liste an <option>-o</option> übergeben
	werden:</para>

      <variablelist>
	<varlistentry>
	  <term>nosuid</term>

	  <listitem>
	    <para>SetUID und SetGID Bits werden auf dem Dateisystem
	      nicht beachtet.  Dies ist eine nützliche
	      Sicherheitsfunktion.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 xml:id="disks-umount">
      <title>Verwendung von &man.umount.8;</title>

      <indexterm>
	<primary>Dateisysteme</primary>
	<secondary>abhängen</secondary>
      </indexterm>

      <para>&man.umount.8; hängt ein Dateisystem ab.  Dieser Befehl
	akzeptiert als Parameter entweder
	einen Mountpoint, einen Gerätenamen, <option>-a</option>
	oder <option>-A</option>.</para>

      <para>Jede Form akzeptiert <option>-f</option>, um das
	Abhängen zu erzwingen, und <option>-v</option>, um
	etwas geschwätziger zu sein.  Seien Sie bitte vorsichtig mit
	<option>-f</option>, da der Computer abstürzen kann oder es
	können Daten auf dem Dateisystem beschädigt werden.</para>

      <para>Um alle Dateisysteme abzuhängen, oder nur diejenigen, die
	mit <option>-t</option> gelistet werden, wird
	<option>-a</option> oder <option>-A</option> benutzt.
	Beachten Sie, dass <option>-a</option> das Root-Dateisystem
	nicht aushängt.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="basics-processes">
    <title>Prozesse und Dämonen</title>

    <para>&os; ist ein Multitasking-Betriebssystem.  Jedes
      Programm, das zu irgendeiner Zeit läuft wird als
      <firstterm>Prozess</firstterm> bezeichnet.  Jedes laufende
      Kommando startet mindestens einen neuen Prozess.  Dazu gibt
      es eine Reihe von Systemprozessen, die von &os; ausgeführt
      werden.</para>

    <para>Jeder Prozess wird durch eine eindeutige Nummer
      identifiziert, die <firstterm>Prozess-ID</firstterm>
      (<firstterm>PID</firstterm>) genannt wird.  Prozesse haben
      ebenso wie Dateien einen Besitzer und eine Gruppe, die
      festlegen, welche Dateien und Geräte der Prozess benutzen kann.
      Die meisten Prozesse haben auch einen Elternprozess, der sie
      gestartet hat.  Beispielsweise ist die Shell ein Prozess.  Jedes
      in Shell gestartete Kommando ist dann ein neuer Prozess, der die
      Shell als Elternprozess besitzt.  Die Ausnahme hiervon ist ein
      spezieller Prozess namens &man.init.8;, der beim booten immer
      als erstes gestartet wird und der immer die
      <acronym>PID</acronym> <literal>1</literal> hat.</para>

    <para>Manche Programme erwarten keine Eingaben vom Benutzer und
      lösen sich bei erster Gelegenheit von ihrem Terminal.  Ein
      Webserver zum Beispiel antwortet auf Web-Anfragen und nicht auf
      Benutzereingaben.  Mail-Server sind ein weiteres Beispiel für
      diesen Typ von Anwendungen.  Diese Programme sind als
      <firstterm>Dämonen</firstterm> bekannt.  Der Begriff Dämon
      stammt aus der griechischen Mythologie und bezeichnet ein Wesen,
      das weder gut noch böse ist und welches unsichtbar nützliche
      Aufgaben verrichtet.  Deshalb ist das BSD Maskottchen dieser
      fröhlich aussehende Dämon mit Turnschuhen und Dreizack.</para>

    <para>Programme, die als Dämon laufen, werden entsprechend einer
      Konvention mit einem <quote>d</quote> am Ende benannt.
      <application>BIND</application> steht beispielsweise für
      Berkeley Internet Name Domain, das tatsächlich laufende Programm
      heißt aber <command>named</command>.  Der
      <application>Apache</application> Webserver wird
      <command>httpd</command> genannt und der Druckerspool-Dämon
      heißt &man.lpd.8;.  Dies ist allerdings nur eine Konvention.
      Der Dämon der Anwendung <application>Sendmail</application>
      heißt beispielsweise <command>sendmail</command> und nicht
      <literal>maild</literal>.</para>

    <sect2>
      <title>Prozesse beobachten</title>

      <para>Um die Prozesse auf dem System zu sehen, benutzen Sie
	&man.ps.1; und &man.top.1;.  Eine statische Liste der
	laufenden Prozesse, deren <acronym>PID</acronym>s,
	Speicherverbrauch und die Kommandozeile, mit der sie gestartet
	wurden, erhalten Sie mit &man.ps.1;.  Um alle laufenden
	Prozesse in einer Anzeige zu sehen, die alle paar Sekunden
	aktualisiert wird, so dass Sie interaktiv sehen können was der
	Computer macht, benutzen Sie &man.top.1;.</para>

      <para>In der Voreinstellung zeigt &man.ps.1; nur die laufenden
	Prozesse, die dem Benutzer gehören.  Zum Beispiel:</para>

      <screen>&prompt.user; <userinput>ps</userinput>
 PID TT  STAT    TIME COMMAND
8203  0  Ss   0:00.59 /bin/csh
8895  0  R+   0:00.00 ps</screen>

      <para>Die Ausgabe von &man.ps.1; ist in einer Anzahl von Spalten
	organisiert.  Die <literal>PID</literal> Spalte zeigt die
	Prozess-ID.  <acronym>PID</acronym>s werden von 1 beginnend
	bis 99999 zugewiesen und fangen wieder von vorne an.  Ist eine
	<acronym>PID</acronym> bereits vergeben, wird diese allerdings
	nicht erneut vergeben.  Die Spalte <literal>TT</literal> zeigt
	den Terminal, auf dem das Programm läuft.
	<literal>STAT</literal> zeigt den Status des Programms und
	<literal>TIME</literal> gibt die Zeit an, die das Programm auf
	der CPU gelaufen ist.  Dies ist nicht unbedingt die Zeit, die
	seit dem Start des Programms vergangen ist, da die meisten
	Programme hauptsächlich auf bestimmte Dinge warten, bevor sie
	wirklich CPU-Zeit verbrauchen.  Unter der Spalte
	<literal>COMMAND</literal> findet sich schließlich die
	Kommandozeile, mit der das Programm gestartet wurde.</para>

      <para>&man.ps.1; besitzt viele Optionen, um die angezeigten
	Informationen zu beeinflussen.  Eine nützliche Kombination ist
	<literal>auxww</literal>.  <option>a</option> zeigt
	Information über alle laufenden Prozesse aller Benutzer.  Der
	Name des Besitzers des Prozesses, sowie Informationen
	über den Speicherverbrauch werden mit <option>u</option>
	angezeigt.  <option>x</option> zeigt auch Dämonen-Prozesse an,
	und <option>ww</option> veranlasst &man.ps.1; die komplette
	Kommandozeile für jeden Befehl anzuzeigen, anstatt sie
	abzuschneiden, wenn sie zu lang für die Bildschirmausgabe
	wird.</para>

      <para>Die Ausgabe von &man.top.1; sieht in etwa so aus:</para>

      <screen>&prompt.user; <userinput>top</userinput>
last pid:  9609;  load averages:  0.56,  0.45,  0.36              up 0+00:20:03  10:21:46
107 processes: 2 running, 104 sleeping, 1 zombie
CPU:  6.2% user,  0.1% nice,  8.2% system,  0.4% interrupt, 85.1% idle
Mem: 541M Active, 450M Inact, 1333M Wired, 4064K Cache, 1498M Free
ARC: 992M Total, 377M MFU, 589M MRU, 250K Anon, 5280K Header, 21M Other
Swap: 2048M Total, 2048M Free

  PID USERNAME    THR PRI NICE   SIZE    RES STATE   C   TIME   WCPU COMMAND
  557 root          1 -21  r31   136M 42296K select  0   2:20  9.96% Xorg
 8198 dru           2  52    0   449M 82736K select  3   0:08  5.96% kdeinit4
 8311 dru          27  30    0  1150M   187M uwait   1   1:37  0.98% firefox
  431 root          1  20    0 14268K  1728K select  0   0:06  0.98% moused
 9551 dru           1  21    0 16600K  2660K CPU3    3   0:01  0.98% top
 2357 dru           4  37    0   718M   141M select  0   0:21  0.00% kdeinit4
 8705 dru           4  35    0   480M    98M select  2   0:20  0.00% kdeinit4
 8076 dru           6  20    0   552M   113M uwait   0   0:12  0.00% soffice.bin
 2623 root          1  30   10 12088K  1636K select  3   0:09  0.00% powerd
 2338 dru           1  20    0   440M 84532K select  1   0:06  0.00% kwin
 1427 dru           5  22    0   605M 86412K select  1   0:05  0.00% kdeinit4</screen>

      <para>Die Ausgabe ist in zwei Abschnitte geteilt.  In den ersten
	fünf Kopfzeilen finden sich die zuletzt zugeteilte
	<acronym>PID</acronym>, die Systemauslastung
	(engl. <foreignphrase>load average</foreignphrase>), die
	Systemlaufzeit (die Zeit seit dem letzten Reboot) und die
	momentane Zeit.  Die weiteren Zahlen im Kopf beschreiben wie
	viele Prozesse momentan laufen, wie viel
	Speicher und Swap verbraucht wurde und wie viel Zeit das
	System in den verschiedenen CPU-Modi verbringt.  Wenn das
	<acronym>ZFS</acronym>-Kernelmodul geladen ist, dann zeigt
	die Zeile <literal>ARC</literal>, wie
	viele Daten aus dem Cache gelesen wurden.</para>

      <para>Darunter befinden sich einige Spalten mit ähnlichen
	Informationen wie in der Ausgabe von &man.ps.1;,
	beispielsweise die <acronym>PID</acronym>, den Besitzer, die
	verbrauchte CPU-Zeit und das Kommando, das den Prozess
	gestartet hat.  &man.top.1; zeigt in zwei Spalten den
	Speicherverbrauch des Prozesses an.  Die erste Spalte gibt
	den gesamten Speicherverbrauch des Prozesses an, in der
	zweiten Spalte wird der aktuelle Verbrauch angegeben.</para>

      <para>Die Anzeige wird von &man.top.1; automatisch alle zwei
	Sekunden aktualisiert.  Ein anderer Intervall kann mit
	<option>-s</option> spezifiziert werden.</para>
    </sect2>

    <sect2 xml:id="basics-daemons">
      <title>Stoppen von Prozessen</title>

      <para>Eine Möglichkeit mit einem laufenden
	Prozess zu kommunizieren, ist über das Versenden von
	<firstterm>Signalen</firstterm> mittels &man.kill.1;.  Es gibt
	eine Reihe von verschiedenen Signalen.  Manche haben eine
	feste Bedeutung, während andere in der Dokumentation der
	Anwendung beschrieben sind.  Ein Benutzer kann ein Signal nur
	an einen Prozess senden, welcher ihm gehört.  Wird versucht
	ein Signal an einen Prozess eines anderen Benutzers zu senden,
	resultiert dies in einem Zugriffsfehler mangels fehlender
	Berechtigungen.  Die Ausnahme ist der <systemitem
	  class="username">root</systemitem>-Benutzer, welcher jedem
	Prozess Signale senden kann.</para>

      <para>&os; kann auch ein Signal an einen Prozess senden.  Wenn
	eine Anwendung schlecht geschrieben ist und auf Speicher
	zugreift, auf den sie nicht zugreifen soll, so sendet &os; dem
	Prozess das <firstterm>Segmentation Violation</firstterm>
	Signal (<literal>SIGSEGV</literal>).  Wenn eine Anwendung
	programmiert wurde, den &man.alarm.3; Systemaufruf zu
	benutzen, um nach einiger Zeit benachrichtigt zu werden,
	bekommt sie das <quote>Alarm</quote>-Signal
	(<literal>SIGALRM</literal>) gesendet.</para>

      <para>Zwei Signale können benutzt werden, um einen Prozess zu
	stoppen: <literal>SIGTERM</literal> und
	<literal>SIGKILL</literal>.  <literal>SIGTERM</literal>
	fordert den Prozess höflich zum Beenden auf.  Der Prozess kann
	das Signal abfangen und hat dann Gelegenheit Logdateien zu
	schließen und die Aktion, die er durchführte, abzuschließen.
	In manchen Situationen kann der Prozess
	<literal>SIGTERM</literal> ignorieren, wenn er eine Aktion
	durchführt, die nicht unterbrochen werden darf.</para>

      <para><literal>SIGKILL</literal> kann von keinem Prozess
	ignoriert werden.  Wird einem Prozess
	<literal>SIGKILL</literal> geschickt, dann wird &os; diesen
	sofort beenden<footnote>
	  <para>Es gibt Fälle, in denen ein Prozess nicht unterbrochen
	    werden kann.  Wenn ein Prozess zum Beispiel eine Datei von
	    einem anderen Rechner auf dem Netzwerk liest und dieser
	    Rechner nicht erreichbar ist, dann ist der Prozess nicht
	    zu unterbrechen.  Wenn der Prozess den Lesezugriff nach
	    einem Timeout von typischerweise zwei Minuten aufgibt,
	    dann wird er beendet.</para>
	</footnote>.</para>

      <para>Andere häufig verwendete Signale sind
	<literal>SIGHUP</literal>, <literal>SIGUSR1</literal> und
	<literal>SIGUSR2</literal>.  Da diese Signale für allgemeine
	Zwecke vorgesehen sind, werden verschiedene Anwendungen
	unterschiedlich auf diese Signale reagieren.</para>

      <para>Ändern Sie beispielsweise die Konfiguration eines
	Webservers, so muss dieser angewiesen werden, seine
	Konfiguration neu zu lesen.  Ein Neustart von
	<command>httpd</command> würde dazu führen, dass der Server
	für kurze Zeit nicht erreichbar ist.  Senden Sie dem Dämon
	stattdessen das <literal>SIGHUP</literal>-Signal.  Es sei
	erwähnt, dass verschiedene Dämonen sich anders verhalten.
	Lesen Sie die Dokumentation des entsprechenden Dämonen um zu
	überprüfen, ob der Dämon bei einem <literal>SIGHUP</literal>
	die gewünschten Ergebnisse erzielt.</para>

      <procedure>
	<title>Verschicken von Signalen</title>

	<para>Das folgende Beispiel zeigt, wie Sie &man.inetd.8; ein
	  Signal schicken.  Die Konfigurationsdatei von
	  &man.inetd.8; ist <filename>/etc/inetd.conf</filename>.
	  Diese Konfigurationsdatei liest &man.inetd.8; ein,
	  wenn er <literal>SIGHUP</literal> empfängt.</para>

	<step>
	  <para>Suchen Sie mit &man.pgrep.1; die
	    <acronym>PID</acronym> des Prozesses, dem Sie ein Signal
	    schicken wollen.  In diesem Beispiel ist die
	    <acronym>PID</acronym> von &man.inetd.8; 198:</para>

	  <screen>&prompt.user; <userinput>pgrep -l inetd</userinput>
198 inetd -wW</screen>

	</step>

	<step>
	  <para>Benutzen Sie &man.kill.1;, um ein Signal zu senden.
	    Da &man.inetd.8; dem Benutzer <systemitem
	      class="username">root</systemitem> gehört, müssen
	    Sie zuerst mit &man.su.1;
	    <systemitem class="username">root</systemitem>
	    werden:</para>

	  <screen>&prompt.user; <userinput>su</userinput>
<prompt>Password:</prompt>
&prompt.root; <userinput>/bin/kill -s HUP 198</userinput></screen>

	  <para>&man.kill.1; wird, wie andere &unix; Kommandos auch,
	    keine Ausgabe erzeugen, wenn das Kommando erfolgreich war.
	    Wird versucht, einem Prozess der nicht dem Benutzer
	    gehört, ein Signal zu senden, dann wird die Meldung
	    <errorname>kill: <replaceable>PID</replaceable>: Operation
	      not permitted</errorname> ausgegeben.  Ein Tippfehler
	    bei der Eingabe der <acronym>PID</acronym> führt dazu,
	    dass das Signal an einen falschen Prozess gesendet wird,
	    was zu negativen Ergebnissen führen kann, oder das Signal
	    wird an eine <acronym>PID</acronym> gesendet die derzeit
	    nicht in Gebrauch ist, was zu dem Fehler
	    <errorname>kill: <replaceable>PID</replaceable>: No such
	      process</errorname> führt.</para>

	  <note>
	    <title>Warum sollte man <command>/bin/kill</command>
	      benutzen?</title>

	    <para>Viele Shells stellen <command>kill</command> als
	      internes Kommando zur Verfügung, das heißt die Shell
	      sendet das Signal direkt, anstatt
	      <filename>/bin/kill</filename> zu starten.  Beachten
	      Sie, dass die unterschiedlichen Shells eine andere
	      Syntax benutzen, um die Namen der Signale anzugeben.
	      Anstatt jede Syntax zu lernen, kann es einfacher sein,
	      <command>/bin/kill</command> direkt aufzurufen.</para>
	  </note>
	</step>
      </procedure>

      <para>Beim Versenden von anderen Signalen, ersetzen Sie
	<literal>TERM</literal> oder <literal>KILL</literal> in der
	Kommandozeile mit dem Namen des Signals.</para>

      <important>
	<para>Das zufällige Beenden eines Prozesses kann gravierende
	  Auswirkungen haben.  Insbesondere &man.init.8;, mit der
	  <acronym>PID</acronym> 1, ist ein Spezialfall.
	  <command>/bin/kill -s KILL 1</command> ist ein schneller,
	  jedoch nicht empfohlener Weg, das System herunterzufahren.
	  Überprüfen Sie die Argumente von &man.kill.1;
	  <emphasis>immer</emphasis> zweimal
	  <emphasis>bevor</emphasis> Sie <keycap>Return</keycap>
	  drücken.</para>
      </important>
    </sect2>
  </sect1>

  <sect1 xml:id="shells">
    <title>Shells</title>

    <indexterm><primary>Shells</primary></indexterm>
    <indexterm><primary>Kommandozeile</primary></indexterm>

    <para>Eine <firstterm>Shell</firstterm> stellt eine
      Kommandozeilen-Schnittstelle zur Interaktion mit dem
      Betriebssystem zur Verfügung.  Sie empfängt Befehle von einem
      Eingabekanal und führt diese aus.  Viele Shells bieten
      eingebaute Funktionen, die die tägliche Arbeit erleichtern,
      beispielsweise eine Dateiverwaltung, die Vervollständigung von
      Dateinamen (Globbing), Kommandozeilen-Editor, sowie Makros und
      Umgebungsvariablen.  &os; enthält einige Shells, darunter die
      Bourne Shell (&man.sh.1;) und die verbesserte C-Shell
      (&man.tcsh.1;).  Weitere Shells, wie <command>zsh</command> oder
      <command>bash</command>, befinden sich in der
      Ports-Sammlung.</para>

    <para>Die verwendete Shell ist letztlich eine Frage des
      Geschmacks.  Ein C-Programmierer, findet vielleicht eine
      C-artige Shell wie &man.tcsh.1; angenehmer.  Ein
      &linux;-Benutzer bevorzugt vielleicht <command>bash</command>.
      Jede Shell hat ihre speziellen Eigenschaften, die mit der
      bevorzugten Arbeitsumgebung des Benutzers harmonieren kann oder
      nicht.  Deshalb stehen mehrere Shells zur Auswahl.</para>

    <para>Ein verbreitetes Merkmal in Shells ist die
      Dateinamen-Vervollständigung.  Nachdem der Benutzer einige
      Buchstaben eines Kommandos oder eines Dateinamen eingeben hat,
      vervollständigt die Shell den Rest durch
      drücken der <keycap>Tab</keycap>-Taste.  Angenommen, Sie
      haben zwei Dateien <filename>foobar</filename> und
      <filename>football</filename>.  Um <filename>foobar</filename>
      zu löschen, kann der Benutzer <command>rm foo</command> eingeben
      und <keycap>Tab</keycap> drücken um den Dateinamen zu
      vervollständigen.</para>

    <para>Die Shell wird lediglich <command>rm foo</command> anzeigen.
      Sie konnte den Dateinamen nicht vervollständigen, da sowohl
      <filename>foobar</filename> als auch
      <filename>football</filename> mit <literal>foo</literal>
      anfangen.  Einige Shells geben einen Signalton aus, oder zeigen
      alle Möglichkeiten an, wenn mehr als ein Name mit dem gegebenen
      Muster übereinstimmt.  Der Benutzer muss dann
      weitere Zeichen eingeben, damit die Shell den gewünschten
      Dateinamen bestimmen kann.  Durch Eingabe von
      <literal>t</literal> und erneutes Drücken von
      <keycap>Tab</keycap> ist die Shell in der Lage, den gewünschten
      Dateinamen zu vervollständigen.</para>

    <indexterm><primary>Umgebungsvariablen</primary></indexterm>

    <para>Ein weiteres Merkmal der Shell ist der Gebrauch von
      Umgebungsvariablen.  Dies sind veränderbare Schlüsselpaare
      im Umgebungsraum der Shell, die jedes von der Shell aufgerufene
      Programm lesen kann.  Daher enthält der Umgebungsraum viele
      Konfigurationsdaten für Programme.  <xref
	linkend="shell-env-vars"/> zeigt verbreitete
      Umgebungsvariablen und deren Bedeutung.  Beachten Sie, dass die
      Namen der Umgebungsvariablen immer in Großbuchstaben geschrieben
      sind:</para>

    <table xml:id="shell-env-vars" frame="none" pgwide="1">
      <title>Gebräuchliche Umgebungsvariablen</title>

      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>Variable</entry>
	    <entry>Beschreibung</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry><envar>USER</envar></entry>
	    <entry>Name des angemeldeten Benutzers.</entry>
	  </row>

	  <row>
	    <entry><envar>PATH</envar></entry>
	    <entry>Liste mit Verzeichnissen (getrennt durch
	      Doppelpunkt) zum Suchen nach Programmen.</entry>
	  </row>

	  <row>
	    <entry><envar>DISPLAY</envar></entry>
	    <entry>Der Name des
	      <application>Xorg</application>-Bildschirms, auf dem
	      Ausgaben erfolgen sollen.</entry>
	  </row>

	  <row>
	    <entry><envar>SHELL</envar></entry>
	    <entry>Die aktuelle Shell.</entry>
	  </row>

	  <row>
	    <entry><envar>TERM</envar></entry>
	    <entry>Name des Terminaltyps des Benutzers.  Benutzt, um
	      die Fähigkeiten des Terminals zu bestimmen.</entry>
	  </row>

	  <row>
	    <entry><envar>TERMCAP</envar></entry>
	    <entry>Datenbankeintrag der Terminal Escape Codes,
	      benötigt um verschieden Terminalfunktionen
	      auszuführen.</entry>
	  </row>

	  <row>
	    <entry><envar>OSTYPE</envar></entry>
	    <entry>Typ des Betriebssystems.</entry>
	  </row>

	  <row>
	    <entry><envar>MACHTYPE</envar></entry>
	    <entry>Die CPU-Architektur des Systems.</entry>
	  </row>

	  <row>
	    <entry><envar>EDITOR</envar></entry>
	    <entry>Vom Benutzer bevorzugter Text-Editor.</entry>
	  </row>

	  <row>
	    <entry><envar>PAGER</envar></entry>
	    <entry>Vom Benutzer bevorzugter Text-Betrachter.</entry>
	  </row>

	  <row>
	    <entry><envar>MANPATH</envar></entry>
	    <entry>Liste mit Verzeichnissen (getrennt durch
	      Doppelpunkt) zum Suchen nach Manualpages.</entry>
	  </row>
	</tbody>
      </tgroup>
    </table>

    <indexterm>
      <primary>Shells</primary>
      <secondary>Bourne Shell</secondary>
    </indexterm>

    <para>Das Setzen von Umgebungsvariablen unterscheidet sich
      von Shell zu Shell.  In &man.tcsh.1; und &man.csh.1; wird dazu
      <command>setenv</command> benutzt.  &man.sh.1; und
      <command>bash</command> benutzen <command>export</command> um
      Umgebungsvariablen zu setzen.  Dieses Beispiel für die
      &man.tcsh.1;-Shell setzt die Variable <envar>EDITOR</envar> auf
      <filename>/usr/local/bin/emacs</filename>:</para>

    <screen>&prompt.user; <userinput>setenv EDITOR /usr/local/bin/emacs</userinput></screen>

    <para>Der entsprechende Befehl für <command>bash</command>
      wäre:</para>

    <screen>&prompt.user; <userinput>export EDITOR="/usr/local/bin/emacs"</userinput></screen>

    <para>Um eine Umgebungsvariable zu expandieren, geben Sie in der
      Kommandozeile das Zeichen <literal>$</literal> vor dessen Namen
      ein.  Zum Beispiel gibt <command>echo $TERM</command> den
      aktuellen Wert von<envar>$TERM</envar> aus.</para>

    <para>Shells behandeln Spezialzeichen, so genannte Metazeichen,
      als besondere Darstellungen für Daten.  Das häufigste Zeichen
      ist <literal>*</literal>, das eine beliebige Anzahl Zeichen in
      einem Dateinamen repräsentiert.  Metazeichen können zur
      Vervollständigung von Dateinamen (Globbing) benutzt werden.
      Beispielsweise liefert <command>echo *</command> nahezu das
      gleiche wie <command>ls</command>, da die Shell alle Dateinamen
      die mit <literal>*</literal> übereinstimmen, an
      <command>echo</command> weitergibt.</para>

    <para>Um zu verhindern, dass die Shell ein Sonderzeichen
      interpretiert, schützt man es, indem man einen
      Backslash (<literal>\</literal>) voranstellt.  Zum Beispiel
      zeigt <command>echo $TERM</command> die Einstellung des
      Terminals an, wohingegen <command>echo \$TERM</command> einfach
      die Zeichenfolge <literal>$TERM</literal> ausgibt.</para>

    <sect2 xml:id="changing-shells">
      <title>Ändern der Shell</title>

      <para>Der einfachste Weg die Standard Shell zu ändern, ist
	<command>chsh</command> zu benutzen.
	<command>chsh</command> startet den Editor, welcher durch
	die Umgebungsvariable <envar>EDITOR</envar> gesetzt ist.
	Standardmäßig ist dies &man.vi.1;.  Tragen Sie in die Zeile
	die mit <literal>Shell:</literal> beginnt, den absoluten Pfad
	der neuen Shell ein.</para>

      <para>Alternativ setzt <command>chsh -s</command> die Shell,
	ohne dabei einen Editor aufzurufen.  Um die Shell zum Beispiel
	auf <command>bash</command> zu ändern, geben Sie folgenden
	Befehl ein:</para>

      <screen>&prompt.user; <userinput>chsh -s /usr/local/bin/bash</userinput></screen>

      <note>
	<para>Die neue Shell <emphasis>muss</emphasis> in
	  <filename>/etc/shells</filename> aufgeführt sein.  Wurde die
	  Shell aus der &os; Ports-Sammlung installiert, so wie in
	  <xref linkend="ports"/> beschrieben, sollte sie automatisch
	  zu dieser Datei hinzugefügt worden sein.  Wenn der Eintrag
	  fehlt, nutzen Sie folgenden Befehl, und ersetzen Sie den
	  Pfad mit dem Pfad zur gewünschten Shell:</para>

	<screen>&prompt.root; <userinput>echo <replaceable>/usr/local/bin/bash</replaceable> &gt;&gt; /etc/shells</userinput></screen>

	<para>Danach kann &man.chsh.1; erneut aufgerufen
	  werden.</para>
      </note>
    </sect2>

    <sect2>
      <info>
	<title>Fortgeschrittene Shell Techniken</title>

	<authorgroup>
	  <author>
	    <personname>
	      <firstname>Tom</firstname>
	      <surname>Rhodes</surname>
	    </personname>
	    <contrib>Geschrieben von </contrib>
	  </author>
	</authorgroup>
      </info>

      <para>Die &unix;-Shell ist nicht nur ein
	Kommandozeileninterpreter, sie ist ein leistungsfähiges
	Werkzeug, das Benutzern die Ausführung von Befehlen
	ermöglicht.  Es kann die Ein- und Ausgabe umleiten und Befehle
	miteinander verketten, um die finale Ausgabe zu verbessern.
	Diese Funktionalität, gepaart mit den eingebauten Befehlen,
	bietet dem Benutzer eine Umgebung, welche die Effizienz
	erheblich steigern kann.</para>

      <para>Als <foreignphrase>Redirection</foreignphrase> bezeichnet
	man die Umleitung der Ein- oder Ausgabe in einen anderen
	Befehl oder Datei.  Um beispielsweise die Ausgabe des Befehls
	&man.ls.1; in eine Datei zu schreiben, muss die Ausgabe
	umgeleitet werden:</para>

      <screen>&prompt.user; <userinput>ls &gt; Verzeichnis_Ausgabe.txt</userinput></screen>

      <para>Die Datei <filename>Verzeichnis_Ausgabe.txt</filename>
	enthält nun den Verzeichnisinhalt.  Einige Befehle, wie
	beispielsweise &man.sort.1;, können verwendet werden um von
	der Eingabe zu lesen.  Wenn Sie die Ausgabe sortieren möchten,
	müssen Sie die Eingabe umleiten:</para>

      <screen>&prompt.user; <userinput>sort &lt; Verzeichnis_Ausgabe.txt</userinput></screen>

      <para>Die Eingabe wird sortiert und auf dem Bildschirm
	ausgegeben.  Um diese Ausgabe wiederum in eine Datei
	umzuleiten, kann die Ausgabe von &man.sort.1;
	umgeleitet werden:</para>

      <screen>&prompt.user; <userinput>sort &lt; Verzeichnis_Ausgabe.txt &gt; Sortierte_Ausgabe.txt</userinput></screen>

      <para>In den bisherigen Beispielen wurden für die Umleitung
	Dateideskriptoren verwendet.  Jedes &unix;-System verfügt über
	drei Dateideskriptoren: Standardeingabe (stdin),
	Standardausgabe (stdout) und Stardardfehlerausgabe (stderr).
	Jeder Deskriptor hat einen bestimmten Zweck.  Die Eingabe
	könnte von einer Tastatur, einer Maus oder einem anderen
	Eingabegerät stammen.  Die Ausgabe könnte der Bildschirm oder
	ein Drucker sein.  Die Standardfehlerausgabe wird zur Diagnose
	und für Fehlermeldungen verwendet.  Alle drei Deskriptoren
	arbeiten <acronym>I/O</acronym> basiert und werden häufig als
	<foreignphrase>Streams</foreignphrase> bezeichnet.</para>

      <para>Die Verwendung von Deskriptoren erlaubt es der Shell, die
	Ein- und Ausgabe von verschiedenen Kommandos umzuleiten und
	zu teilen.  Eine weitere Möglichkeit zur Umleitung bietet der
	Pipe-Operator.</para>

      <para>Der &unix; Pipe-Operator <quote>|</quote> wird verwendet,
	um die Ausgabe eines Kommandos an ein anderes Programm zu
	übergeben.  Grundsätzlich bedeutet dies, dass die
	Standardausgabe eines Programms als Standardeingabe für ein
	weiteres Programm verwendet wird.  Ein Beispiel:</para>

      <screen>&prompt.user; <userinput>cat Verzeichnis_Auflistung.txt | sort | less</userinput></screen>

      <para>In diesem Beispiel wird der Inhalt von
	<filename>Verzeichnis_Auflistung.txt</filename> sortiert und
	die Ausgabe an &man.less.1; übergeben.  Dies erlaubt es dem
	Benutzer, die Ausgabe Schritt für Schritt und im eigenen Tempo
	zu betrachten.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="editors">
    <title>Text-Editoren</title>

    <indexterm><primary>Text Editoren</primary></indexterm>
    <indexterm><primary>Editoren</primary></indexterm>

    <para>Die meiste Konfiguration unter &os; wird durch
      das Editieren von Textdateien erledigt.  Deshalb ist es eine
      gute Idee, mit einem Texteditor vertraut zu werden.  &os; hat
      ein paar davon im Basissystem und sehr viel mehr in der
      Ports-Sammlung.</para>

    <indexterm>
      <primary>&man.ee.1;</primary>
    </indexterm>

    <indexterm>
      <primary>Text Editoren</primary>
      <secondary><command>ee</command></secondary>
    </indexterm>

    <para>Ein einfach zu erlernender Editor ist &man.ee.1;, was für
      <foreignphrase>easy editor</foreignphrase> steht.  Um diesen
      Editor zu starten, gibt man in der Kommandozeile <command>ee
	<replaceable>filename</replaceable></command> ein, wobei
      <replaceable>filename</replaceable> den Namen der zu
      editierenden Datei darstellt.  Einmal im Editor, finden sich
      alle Editor-Funktionen oben im Display aufgelistet.  Das
      Einschaltungszeichen (<literal>^</literal>) steht für die
      <keycap>Ctrl</keycap> (oder <keycap>Strg</keycap>) Taste, mit
      <literal>^e</literal> ist also die Tastenkombination
      <keycombo
	action="simul"><keycap>Ctrl</keycap><keycap>e</keycap></keycombo>
      gemeint.  Um &man.ee.1; zu verlassen, drücken Sie
      <keycap>Esc</keycap> und wählen dann im Hauptmenü <option>leave
	editor</option> aus.  Der Editor fragt nach, ob Sie speichern
      möchten, wenn die Datei verändert wurde.</para>

    <indexterm>
      <primary><command>vi</command></primary>
    </indexterm>
    <indexterm>
      <primary>Text Editoren</primary>
    </indexterm>
    <indexterm>
      <primary><command>emacs</command></primary>
    </indexterm>

    <para>&os; verfügt über leistungsfähigere Editoren wie &man.vi.1;
      als Teil des Basissystems.  Andere Editoren wie
      <package>editors/emacs</package> und
      <package>editors/vim</package> sind Teil der Ports-Sammlung.
      Diese Editoren bieten höhere Funktionalität, jedoch auf Kosten
      einer etwas schwierigeren Erlernbarkeit.  Das Erlernen eines
      leistungsfähigeren Editors, wie <application>vim</application>
      oder <application>Emacs</application>, kann auf lange Sicht Zeit
      einsparen.</para>

    <para>Viele Anwendungen, die Dateien verändern oder Texteingabe
      erwarten, werden automatisch einen Texteditor öffnen.  Um den
      Standardeditor zu ändern, wird die Umgebungsvariable
      <envar>EDITOR</envar> gesetzt, wie im Abschnitt
      <xref linkend="shells"/> beschrieben.</para>
  </sect1>

  <sect1 xml:id="basics-devices">
    <title>Geräte und Gerätedateien</title>

    <para>Der Begriff Gerät wird meist in Verbindung mit Hardware wie
      Laufwerken, Druckern, Grafikkarten oder Tastaturen gebraucht.
      Der Großteil der Meldungen, die beim Booten von &os; angezeigt
      werden, beziehen sich auf gefundene Geräte.  Eine Kopie dieser
      Bootmeldungen wird in <filename>/var/run/dmesg.boot</filename>
      gespeichert.</para>

    <para>Jedes Gerät verfügt über einen Gerätenamen und Gerätenummer.
      Zum Beispiel steht <filename>ada0</filename> für die erste
      SATA Festplatte, während <filename>kbd0</filename> die
      Tastatur repräsentiert.</para>

    <para>Auf die meisten Geräte wird unter &os; über spezielle
      Gerätedateien im <filename>/dev</filename> Verzeichnis
      zugegriffen.</para>
  </sect1>

  <sect1 xml:id="basics-more-information">
    <title>Manualpages</title>

    <sect2 xml:id="basics-man">
      <title>Manualpages</title>

      <indexterm><primary>Manualpages</primary></indexterm>

      <para>Die umfassendste Dokumentation rund um &os; gibt es in
	Form von Manualpages.  Annähernd jedes Programm im System
	bringt eine kurze Referenzdokumentation mit, die die
	grundsätzliche Funktion und verschiedene Parameter
	erklärt.  Diese Manuals können mit <command>man</command>
	eingesehen werden:</para>

      <screen>&prompt.user; <userinput>man <replaceable>Kommando</replaceable></userinput></screen>

      <para><replaceable>Kommando</replaceable> ist der Name des
	Kommandos, über das man etwas erfahren will.  Um
	beispielsweise mehr über das Kommando &man.ls.1; zu
	erfahren, geben Sie ein:</para>

      <screen>&prompt.user; <userinput>man ls</userinput></screen>

      <para>Die Manualpages sind in nummerierte Sektionen
	unterteilt, die jeweils ein Thema darstellen.  In &os; sind
	die folgenden Sektionen verfügbar:</para>

      <orderedlist>
	<listitem>
	  <para>Benutzerkommandos.</para>
	</listitem>

	<listitem>
	  <para>Systemaufrufe und Fehlernummern.</para>
	</listitem>

	<listitem>
	  <para>Funktionen der C Bibliothek.</para>
	</listitem>

	<listitem>
	  <para>Gerätetreiber.</para>
	</listitem>

	<listitem>
	  <para>Dateiformate.</para>
	</listitem>

	<listitem>
	  <para>Spiele und andere Unterhaltung.</para>
	</listitem>

	<listitem>
	  <para>Verschiedene Informationen.</para>
	</listitem>

	<listitem>
	  <para>Systemverwaltung und -Kommandos.</para>
	</listitem>

	<listitem>
	  <para>Kernel Schnittstellen.</para>
	</listitem>
      </orderedlist>

      <para>In einigen Fällen kann dasselbe Thema in mehreren
	Sektionen auftauchen.  Es gibt zum Beispiel ein
	<command>chmod</command> Benutzerkommando und einen
	<function>chmod()</function> Systemaufruf.  Um &man.man.1;
	mitzuteilen, aus welcher Sektion die Information angezeigt
	werden soll, kann die Sektionsnummer mit angeben
	werden:</para>

      <screen>&prompt.user; <userinput>man 1 chmod</userinput></screen>

      <para>Dies wird Ihnen die Manualpage für das Benutzerkommando
	&man.chmod.1; zeigen.  Verweise auf eine Sektion der
	Manualpages werden traditionell in Klammern gesetzt.  So
	bezieht sich &man.chmod.1; auf das Benutzerkommando und
	&man.chmod.2; auf den Systemaufruf.</para>

      <para>Wenn das Kommando nicht bekannt ist, kann
	<command>man -k</command> benutzt werden, um nach
	Schlüsselbegriffen in den Kommandobeschreibungen zu
	suchen:</para>

      <screen>&prompt.user; <userinput>man -k <replaceable>mail</replaceable></userinput></screen>

      <para>Dieser Befehl zeigt eine Liste von Kommandos, deren
	Beschreibung das Schlüsselwort <quote>mail</quote> enthält.
	Die gleiche Funktionalität erhalten Sie auch, wenn Sie
	&man.apropos.1; benutzen.</para>

      <para>Um die Beschreibungen der Kommandos in
	<filename>/usr/bin</filename> zu lesen, geben Sie ein:</para>

      <screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>man -f * | more</userinput></screen>

      <para>Dasselbe erreichen Sie durch Eingabe von:</para>

      <screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>whatis * | more</userinput></screen>

    </sect2>

    <sect2 xml:id="basics-info">
      <title>GNU Info Dateien</title>

      <indexterm>
	<primary>Free Software Foundation</primary>
      </indexterm>

      <para>&os; enthält verschiedene Anwendungen und Utilities der
	Free Software Foundation (FSF).  Zusätzlich zu den Manualpages
	können diese Programme Hypertext-Dokumente enthalten, die
	<literal>info</literal>-Seiten genannt werden.  Diese
	Dokumente können mit &man.info.1; ansehen kann.  Wenn
	<package>editors/emacs</package> installiert ist, kann auch
	der info-Modus von <application>emacs</application> benutzt
	werden.</para>

      <para>Um &man.info.1; zu benutzen, geben Sie ein:</para>

      <screen>&prompt.user; <userinput>info</userinput></screen>

      <para>Eine kurze Einführung gibt es mit
        <literal>h</literal>; eine Befehlsreferenz erhalten Sie durch
        Eingabe von: <literal>?</literal>.</para>
    </sect2>
  </sect1>
</chapter>
