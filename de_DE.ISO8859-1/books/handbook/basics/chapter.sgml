<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde: de-docproj/books/handbook/basics/chapter.sgml,v 1.82 2004/01/10 01:32:00 mheinen Exp $
     basiert auf: 1.123
-->

<chapter id="basics">
  <chapterinfo>
    <authorgroup>
      <author>
	 <firstname>Chris</firstname>
	 <surname>Shumway</surname>
	 <contrib>Umgeschrieben von </contrib>
      </author>
    </authorgroup>
    <!-- 10 Mar 2000 -->
    <authorgroup>
      <author>
	 <firstname>Uwe</firstname>
	 <surname>Pierau</surname>
	 <contrib>&Uuml;bersetzt von </contrib>
      </author>
    </authorgroup>
  </chapterinfo>

  <title>Grundlagen des UNIX Betriebssystems</title>

  <sect1 id="basics-synopsis">
    <title>&Uuml;bersicht</title>
    <indexterm><primary>Grundlagen</primary></indexterm>

   <para>Das folgende Kapitel umfasst die grundlegenden Kommandos
     und Funktionsweisen des Betriebssystems FreeBSD.  Viel von dem folgenden
     Material gilt auch f&uuml;r jedes andere &unix; System.
     Falls Sie mit dem Material schon vertraut sind, k&ouml;nnen Sie dieses
     Kapitel &uuml;berlesen.  Wenn FreeBSD neu f&uuml;r Sie ist, dann sollten
     Sie dieses Kapitel auf jeden Fall aufmerksam lesen.</para>

   <para>Dieser Abschnitt behandelt die folgenden Themen:</para>

   <itemizedlist>
     <listitem>
       <para>virtuelle Konsolen,</para>
     </listitem>
     <listitem>
       <para>Zugriffsrechte unter &unix;,</para>
     </listitem>
     <listitem>
       <para>Zugriffskontrolllisten f&uuml;r Dateisysteme,</para>
     </listitem>
     <listitem>
       <para>die Verzeichnisstruktur von &os;,</para>
     </listitem>
     <listitem>
       <para>Organisation von Dateisystemen unter &os;,</para>
     </listitem>
     <listitem>
       <para>Ein- und Abh&auml;ngen von Dateisystemen,</para>
     </listitem>
     <listitem>
       <para>Prozesse, D&auml;monen und Signale,</para>
     </listitem>
     <listitem>
       <para>Shells und die Login-Umgebung,</para>
     </listitem>
     <listitem>
       <para>Texteditoren,</para>
     </listitem>
     <listitem>
       <para>Ger&auml;te und Ger&auml;tedateien,</para>
     </listitem>
     <listitem>
       <para>Bin&auml;rformate unter &os; und</para>
     </listitem>
     <listitem>
       <para>wie Sie in den Manualpages nach weiteren Informationen
	 suchen k&ouml;nnen.</para>
     </listitem>
   </itemizedlist>
  </sect1>

  <sect1 id="consoles">
    <title>Virtuelle Konsolen und Terminals</title>
    <indexterm><primary>virtuelle Konsole</primary></indexterm>
    <indexterm><primary>Terminals</primary></indexterm>

    <para>Sie k&ouml;nnen FreeBSD mit einem Terminal benutzen, der nur Text
      darstellen kann.  Wenn Sie FreeBSD auf diese Weise benutzen, stehen
      Ihnen alle M&ouml;glichkeiten eines &unix; Betriebssystems zur
      Verf&uuml;gung.  Dieser Abschnitt beschreibt was Terminals und
      Konsolen sind und wie sie unter FreeBSD eingesetzt werden.</para>

    <sect2 id="consoles-intro">
      <title>Die Konsole</title>
      <indexterm><primary>Konsole</primary></indexterm>

      <para>Wenn Ihr FreeBSD-System ohne eine graphische
        Benutzeroberfl&auml;che startet, wird am Ende des Systemstarts,
	nachdem die Startskripten gelaufen sind, ein Anmeldeprompt
	ausgegeben.  Die letzten Startmeldungen sollten &auml;hnlich wie
	die Folgenden aussehen:</para>

      <screen>Additional ABI support:.
Local package initialization:.
Additional TCP options:.

Fri Sep 20 13:01:06 EEST 2002

FreeBSD/i386 (pc3.example.org) (ttyv0)

login:</screen>

      <para>Beachten Sie die letzten beiden Zeilen der Ausgabe, die
        vorletzte lautet:</para>

      <programlisting>FreeBSD/i386 (pc3.example.org) (ttyv0)</programlisting>

      <para>Diese Zeile enth&auml;lt einige Informationen &uuml;ber das
        gerade gestartete System.  Die Ausgabe stammt von der
	FreeBSD-Konsole einer Maschine mit einem Intel oder
	Intel-kompatiblen Prozessor der x86-Architektur<footnote>
	  <para>Genau das ist mit <literal>i386</literal> gemeint.  Auch
	    wenn Ihr System keine Intel 386&nbsp;CPU besitzt, wird
	    <literal>i386</literal> ausgegeben.  Es wird immer die
	    Architektur und nicht der Typ des Prozessors ausgegeben.</para>
	</footnote>.  Der Name des Systems (jedes &unix; System besitzt
	einen Namen) ist <hostid>pc3.example.org</hostid> und die Ausgabe
	stammt von der Systemkonsole, dem Terminal
	<devicename>ttyv0</devicename>.</para>

      <para>Das Ende der Ausgabe ist immer die Aufforderung zur Eingabe
        eines Benutzernamens:</para>

      <programlisting>login:</programlisting>

      <para>Der Anmeldevorgang wird im n&auml;chsten Abschnitt
        erl&auml;utert.</para>
    </sect2>

    <sect2 id="consoles-login">
      <title>Der Anmeldevorgang</title>

      <para>FreeBSD ist ein Mehrbenutzersystem, das Multitasking
        unterst&uuml;tzt.  Das hei&szlig;t mehrere Benutzer k&ouml;nnen
	gleichzeitig viele Programme auf einem System laufen lassen.</para>

      <para>Jedes Mehrbenutzersystem muss die Benutzer voneinander
        unterscheiden k&ouml;nnen.  Bei FreeBSD und allen anderen &unix;
	Betriebssystemen wird dies dadurch erreicht, dass sich die
	Benutzer anmelden m&uuml;ssen, bevor sie Programme laufen lassen
	k&ouml;nnen.  Jeder Benutzer besitzt einen eindeutigen Namen (den
	Account) und ein dazugeh&ouml;rendes Passwort, die beide bei
	der Anmeldung abgefragt werden.</para>

      <indexterm><primary>Startskripten</primary></indexterm>
      <para>Nachdem FreeBSD gestartet ist und die Startskripten<footnote>
	  <para>Startskripten sind Programme, die FreeBSD automatisch bei
	    jedem Startvorgang ausf&uuml;hrt.  Der Zweck der Skripte
	    besteht darin, das System zu konfigurieren und n&uuml;tzliche
	    Dienste im Hintergrund zu starten.</para>
	</footnote>, gelaufen sind, erscheint eine Aufforderung zur Eingabe
	des Benutzernamens:</para>

      <screen>login:</screen>

      <para>Wenn Ihr Benutzername beispielsweise <username>john</username>
        ist, geben Sie jetzt <literal>john</literal> gefolgt von
	<keycap>Enter</keycap> ein.  Sie sollten dann eine Aufforderung zur
	Eingabe des Passworts erhalten:</para>

      <screen>login: <userinput>john</userinput>
Password:</screen>

      <para>Geben Sie jetzt das Passwort von <username>john</username>
	gefolgt von <keycap>Enter</keycap> ein.  Das Passwort wird aus
	Sicherheitsgr&uuml;nden nicht auf dem Bildschirm angezeigt.</para>

      <para>Wenn Sie das richtige Passwort eingegeben haben, sind Sie
        am System angemeldet und k&ouml;nnen nun alle verf&uuml;gbaren
	Kommandos absetzen.</para>

      <para>Anmgemeldet sind Sie, wenn Sie die Tagesmeldungen
	(<foreignphrase>message of today</foreignphrase>) gefolgt
	von einer Eingabeaufforderung (dem Zeichen <literal>#</literal>,
	<literal>$</literal> oder <literal>%</literal>) gesehen
	haben.</para>
    </sect2>

    <sect2 id="consoles-virtual">
      <title>Virtuelle Konsolen</title>

      <para>Da FreeBSD mehrere Programme gleichzeitig laufen lassen kann,
        ist eine einzige Konsole, an der Kommandos abgesetzt werden
	k&ouml;nnen, zu wenig.  Abhilfe schaffen virtuelle Konsolen, die
	mehrere Konsolen zur Verf&uuml;gung stellen.</para>

      <para>Die Anzahl der virtuellen Konsolen unter FreeBSD k&ouml;nnen Sie
        einstellen.  Zwischen den einzelnen Konsolen k&ouml;nnen Sie mit
	speziellen Tastenkombinationen wechseln.  Jede Konsole verf&uuml;gt
	&uuml;ber einen eigenen Ausgabekanal und FreeBSD ordnet die
	Tastatureingaben und Monitorausgaben der richtigen Konsole zu, wenn
	Sie zwischen den Konsolen wechseln.</para>

      <para>Zum Umschalten der Konsolen stellt FreeBSD spezielle
        Tastenkombinationen bereit<footnote>
	  <para>Eine recht technische und genaue Beschreibung der FreeBSD-Konsole
            und der Tastatur-Treiber finden Sie in den Hilfeseiten
	    &man.syscons.4;, &man.atkbd.4;, &man.vidcontrol.1; und
	    &man.kbdcontrol.1;.  Lesen Sie diese Seiten, wenn Sie an den
	    Einzelheiten interessiert sind.</para>
	</footnote>.  Benutzen Sie
	<keycombo><keycap>Alt</keycap><keycap>F1</keycap></keycombo>,
	<keycombo><keycap>Alt</keycap><keycap>F2</keycap></keycombo> bis
	<keycombo><keycap>Alt</keycap><keycap>F8</keycap></keycombo>,
	um zwischen den verschiedenen Konsolen umzuschalten.</para>

      <para>Wenn Sie zu einer anderen Konsole wechseln, sichert FreeBSD den
        Bildschirminhalt und gibt den Bildschirminhalt der neuen Konsole
	aus.  Dies erzeugt die Illusion mehrerer Bildschirme und
	Tastaturen, an denen Sie Kommandos absetzen k&ouml;nnen.  Wenn eine
	Konsole nicht sichtbar ist, weil Sie auf eine andere Konsole
	gewechselt haben, laufen die dort abgesetzten Kommandos
	weiter.</para>
    </sect2>

    <sect2 id="consoles-ttys">
      <title><filename>/etc/ttys</filename></title>

      <para>In der Voreinstellung stehen unter FreeBSD acht virtuelle
	Konsolen zur Verf&uuml;gung, deren Anzahl Sie leicht erh&ouml;hen
	oder verringern k&ouml;nnen.  Die Anzahl und Art der Konsolen wird
	in <filename>/etc/ttys</filename> eingestellt.</para>

      <para>Jede Zeile in <filename>/etc/ttys</filename>, die nicht mit
        <literal>#</literal> anf&auml;ngt, konfiguriert einen Terminal oder
	eine virtuelle Konsole.  In der Voreinstellung werden in dieser
	Datei neun virtuelle Konsolen definiert, von denen acht aktiviert
	sind.  Die Konsolen sind in den Zeilen, die mit
	<literal>ttyv</literal> beginnen, definiert:</para>

      <programlisting># name  getty                           type    status          comments
#
ttyv0   "/usr/libexec/getty Pc"         cons25  on  secure
# Virtual terminals
ttyv1   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv2   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv3   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv4   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv5   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv6   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv7   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv8   "/usr/X11R6/bin/xdm -nodaemon"  xterm   off secure</programlisting>

      <para>Die Hilfeseite &man.ttys.5; enth&auml;lt eine ausf&uuml;hrliche
	Beschreibung der Spalten dieser Datei und der Optionen, die Sie zum
	Konfigurieren der virtuellen Konsolen benutzen k&ouml;nnen.</para>
    </sect2>

    <sect2 id="consoles-singleuser">
      <title>Die Konsole im Single-User-Modus</title>

      <para>Eine eingehende Beschreibung des Single-User-Modus finden Sie
        in <xref linkend="boot-singleuser">.  Im Single-User-Modus steht
	Ihnen nur <emphasis>eine</emphasis> Konsole zur Verf&uuml;gung.
	Die Definition dieser Konsole befindet sich ebenfalls in
	<filename>/etc/ttys</filename>.  Suchen Sie nach einer Zeile, die
	mit <literal>console</literal> beginnt:</para>

      <programlisting># name  getty                           type    status          comments
#
# If console is marked "insecure", then init will ask for the root password
# when going to single-user mode.
console none                            unknown off secure</programlisting>

      <note>
	<para>In der Zeile, die mit <literal>console</literal> beginnt,
	  k&ouml;nnen Sie <literal>secure</literal> durch
	  <literal>insecure</literal> ersetzen.  Wenn Sie danach in den
	  Single-User-Modus booten, verlangt das System ebenfalls die
	  Eingabe des <username>root</username>-Passworts.</para>

	<para><emphasis>Setzen Sie <literal>insecure</literal> nicht
	  leichtfertig ein.</emphasis>  Wenn Sie das Passwort von
	  <username>root</username> vergessen, wird es schwierig, in den
	  Single-User-Modus zu gelangen, wenn Sie den
	  FreeBSD-Boot-Prozess nicht genau verstehen.</para>
      </note>
    </sect2>
  </sect1>

  <sect1 id="permissions">
    <title>Zugriffsrechte</title>
    <indexterm><primary>UNIX</primary></indexterm>

    <para>FreeBSD, das ein direkter Abk&ouml;mmling von BSD &unix; ist,
      st&uuml;tzt sich auf mehrere Grundkonzepte von &unix; Systemen.
      Das erste und ausgepr&auml;gteste: FreeBSD ist
      ein Mehrbenutzer-Betriebssystem.  Das System erm&ouml;glicht,
      dass mehrere Benutzer gleichzeitig an v&ouml;llig verschiedenen
      und unabh&auml;ngigen Aufgaben arbeiten k&ouml;nnen.  Es ist
      verantwortlich f&uuml;r eine gerechte Auf- und Zuteilung von
      Nachfragen nach Hardware- und Peripherieger&auml;ten, Speicher
      und CPU-Zeit unter den Benutzern.</para>

    <para>Da das System mehrere Benutzer unterst&uuml;tzt, hat alles,
      was das System verwaltet, einen Satz von Rechten, die bestimmen,
      wer die jeweilige Ressource lesen, schreiben oder ausf&uuml;hren
      darf.  Diese Zugriffsrechte stehen in drei Achtergruppen, die in
      drei Teile unterteilt sind: einen f&uuml;r den Besitzer der
      Datei, einen f&uuml;r die Gruppe, zu der die Datei geh&ouml;rt
      und einen f&uuml;r alle anderen.  Die numerische Darstellung
      sieht wie folgt aus:</para>

    <indexterm><primary>Zugriffsrechte</primary></indexterm>
    <indexterm>
      <primary>Dateizugriffsrechte</primary>
    </indexterm>
    <informaltable frame="none">
      <tgroup cols="3">
	<thead>
	  <row>
	    <entry>Wert</entry>
	    <entry>Zugriffsrechte</entry>
	    <entry>Auflistung im Verzeichnis</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry>0</entry>
	    <entry>Kein Lesen, Kein Schreiben, Kein Ausf&uuml;hren</entry>
	    <entry><literal>---</literal></entry>
	  </row>

	  <row>
	    <entry>1</entry>
	    <entry>Kein Lesen, Kein Schreiben, Ausf&uuml;hren</entry>
	    <entry><literal>--x</literal></entry>
	  </row>

	  <row>
	    <entry>2</entry>
	    <entry>Kein Lesen, Schreiben, Kein Ausf&uuml;hren</entry>
	    <entry><literal>-w-</literal></entry>
	  </row>

	  <row>
	    <entry>3</entry>
	    <entry>Kein Lesen, Schreiben, Ausf&uuml;hren</entry>
	    <entry><literal>-wx</literal></entry>
	  </row>

	  <row>
	    <entry>4</entry>
	    <entry>Lesen, Kein Schreiben, Kein Ausf&uuml;hren</entry>
	    <entry><literal>r--</literal></entry>
	  </row>

	  <row>
	    <entry>5</entry>
	    <entry>Lesen, Kein Schreiben, Ausf&uuml;hren</entry>
	    <entry><literal>r-x</literal></entry>
	  </row>

	  <row>
	    <entry>6</entry>
	    <entry>Lesen, Schreiben, Kein Ausf&uuml;hren</entry>
	    <entry><literal>rw-</literal></entry>
	  </row>

	  <row>
	    <entry>7</entry>
	    <entry>Lesen, Schreiben, Ausf&uuml;hren</entry>
	    <entry><literal>rwx</literal></entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>
    <indexterm>
      <primary><command>ls</command></primary>
    </indexterm>
    <indexterm><primary>Verzeichnisse</primary></indexterm>

    <para>Sie k&ouml;nnen <option>-l</option> auf der Kommandozeile
      von &man.ls.1; angeben, um eine ausf&uuml;hrliche Verzeichnisauflistung
      zu sehen, die in einer Spalte die Zugriffsrechte f&uuml;r den
      Besitzer, die Gruppe und alle anderen enth&auml;lt.
      Die Ausgabe von <command>ls -l</command> k&ouml;nnte
      wie folgt aussehen:</para>

    <screen>&prompt.user; <userinput>ls -l</userinput>
total 530
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 myfile
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 otherfile
-rw-r--r--  1 root  wheel    7680 Sep  5 12:31 email.txt
...</screen>

    <para>Die erste Spalte der Ausgabe enth&auml;lt die
      Zugriffsrechte:</para>

    <screen>-rw-r--r--</screen>

    <para>Das erste Zeichen von links ist ein Symbol, welches angibt,
      ob es sich um eine normale Datei, ein Verzeichnis, ein
      zeichenorientiertes Ger&auml;t, ein Socket oder irgendeine andere
      Pseudo-Datei handelt.  In diesem Beispiel zeigt <literal>-</literal> eine
      normale Datei an.  Die n&auml;chsten drei Zeichen,
      dargestellt als <literal>rw-</literal>, ergeben die Rechte
      f&uuml;r den Datei-Besitzer.  Die drei Zeichen danach
      <literal>r--</literal> die Rechte der Gruppe, zu der die Datei
      geh&ouml;rt.  Die letzten drei Zeichen, <literal>r--</literal>,
      geben die Rechte f&uuml;r den Rest der Welt an.  Ein Minus
      bedeutet, dass das Recht nicht gegeben ist.  In diesem Fall
      sind die Zugriffsrechte also: der Eigent&uuml;mer kann die Datei
      lesen und schreiben, die Gruppe kann lesen und alle anderen
      k&ouml;nnen auch nur lesen.  Entsprechend obiger Tabelle
      w&auml;ren die Zugriffsrechte f&uuml;r diese Datei
      <literal>644</literal>, worin jede Ziffer die drei Teile der
      Zugriffsrechte dieser Datei verk&ouml;rpert.</para>

    <para>Das ist alles sch&ouml;n und gut, aber wie kontrolliert das
      System die Rechte von Hardware-Ger&auml;ten?  FreeBSD behandelt
      die meisten Hardware-Ger&auml;te als Dateien, welche Programme
      &ouml;ffnen, lesen und mit Daten beschreiben k&ouml;nnen wie
      alle anderen Dateien auch.  Diese Spezial-Dateien sind im
      Verzeichnis <filename>/dev</filename> gespeichert.</para>

    <para>Verzeichnisse werden ebenfalls wie Dateien behandelt.  Sie
      haben Lese-, Schreib- und Ausf&uuml;hr-Rechte.  Das
      Ausf&uuml;hrungs-Bit hat eine etwas andere Bedeutung f&uuml;r
      ein Verzeichnis als f&uuml;r eine Datei.  Die Ausf&uuml;hrbarkeit
      eines Verzeichnisses bedeutet, dass in das Verzeichnis
      zum Beispiel mit <command>cd</command> gewechselt werden kann.
      Das bedeutet auch, dass in dem Verzeichnis auf Dateien, deren
      Namen bekannt sind, zugegriffen werden kann, vorausgesetzt die
      Zugriffsrechte der Dateien lassen dies zu.</para>

    <para>Das Leserecht auf einem Verzeichnis erlaubt es, sich den Inhalt
      des Verzeichnisses anzeigen zu lassen.  Um eine Datei mit bekanntem
      Namen in einem Verzeichnis zu l&ouml;schen, m&uuml;ssen auf dem
      Verzeichnis Schreib- <emphasis>und</emphasis> Ausf&uuml;hr-Rechte
      gesetzt sein.</para>

    <para>Es gibt noch mehr Rechte, aber die werden vor allem in
      speziellen Umst&auml;nden benutzt, wie zum Beispiel bei
      SetUID-Binaries und Verzeichnissen mit gesetztem Sticky-Bit.
      Mehr &uuml;ber Zugriffsrechte von Dateien und wie sie gesetzt werden,
      finden Sie in &man.chmod.1;.</para>

    <sect2>
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	    <contrib>Beigesteuert von </contrib>
	  </author>
	</authorgroup>
      </sect2info>

      <title>Symbolische Zugriffsrechte</title>
      <indexterm>
	<primary>Zugriffsrechte</primary>
	<secondary>symbolische</secondary>
      </indexterm>

      <para>Die Zugriffsrechte lassen sich auch &uuml;ber Symbole
	anstelle von oktalen Werten festlegen.  Symbolische
	Zugriffsrechte werden in der Reihenfolge
	<replaceable>Wer</replaceable>, <replaceable>Aktion</replaceable>
	und <replaceable>Berechtigung</replaceable> angegeben.
	Die folgenden Symbole stehen zur Auswahl:</para>

      <informaltable frame="none">
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>Option</entry>
	      <entry>Symbol</entry>
	      <entry>Bedeutung</entry>
	    </row>
	  </thead>

	<tbody>
	  <row>
	    <entry><replaceable>Wer</replaceable></entry>
	    <entry>u</entry>
	    <entry>Benutzer (<foreignphrase>user</foreignphrase>)</entry>
	  </row>

	  <row>
	    <entry><replaceable>Wer</replaceable></entry>
	    <entry>g</entry>
	    <entry>Gruppe (<foreignphrase>group</foreignphrase>)</entry>
	  </row>

	  <row>
	    <entry><replaceable>Wer</replaceable></entry>
	    <entry>o</entry>
	    <entry>Andere (<foreignphrase>other</foreignphrase>)</entry>
	  </row>

	  <row>
	    <entry><replaceable>Wer</replaceable></entry>
	    <entry>a</entry>
	    <entry>Alle</entry>
	  </row>

	  <row>
	    <entry><replaceable>Aktion</replaceable></entry>
	    <entry>+</entry>
	    <entry>Berechtigungen hinzuf&uuml;gen</entry>
	  </row>

	  <row>
	    <entry><replaceable>Aktion</replaceable></entry>
	    <entry>-</entry>
	    <entry>Berechtigungen entziehen</entry>
	  </row>

	  <row>
	    <entry><replaceable>Aktion</replaceable></entry>
	    <entry>=</entry>
	    <entry>Berechtigungen explizit setzen</entry>
	  </row>

	  <row>
	    <entry><replaceable>Berechtigung</replaceable></entry>
	    <entry>r</entry>
	    <entry>lesen (<foreignphrase>read</foreignphrase>)</entry>
	  </row>

	  <row>
	    <entry><replaceable>Berechtigung</replaceable></entry>
	    <entry>w</entry>
	    <entry>schreiben (<foreignphrase>write</foreignphrase>)</entry>
	  </row>

	  <row>
	    <entry><replaceable>Berechtigung</replaceable></entry>
	    <entry>x</entry>
	    <entry>ausf&uuml;hren
	      (<foreignphrase>execute</foreignphrase>)</entry>
	  </row>

	  <row>
	    <entry><replaceable>Berechtigung</replaceable></entry>
	    <entry>t</entry>
	    <entry>Sticky-Bit</entry>
	  </row>

	  <row>
	    <entry><replaceable>Berechtigung</replaceable></entry>
	    <entry>s</entry>
	    <entry>Set-UID oder Set-GID</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <para>Symbolische Zugriffsrechte werden wie die numerischen
      mit dem Kommando &man.chmod.1; vergeben.  Wenn
      Sie beispielsweise allen anderen Benutzern den Zugriff auf
      die Datei <replaceable>FILE</replaceable> verbieten wollen,
      benutzen Sie den nachstehenden Befehl:</para>

    <screen>&prompt.user; <userinput>chmod go= FILE</userinput></screen>

    <para>Wenn Sie mehr als eine &Auml;nderung der Rechte einer
      Datei vornehmen wollen, k&ouml;nnen Sie eine durch Kommata
      getrennte Liste der Rechte angeben.  Das folgende Beispiel
      entzieht der Gruppe und der Welt (den anderen) die
      Schreibberechtigung auf die Datei <replaceable>FILE</replaceable>
      und f&uuml;gt dann f&uuml;r alle Ausf&uuml;hrungsrechte
      hinzu:</para>

    <screen>&prompt.user; <userinput>chmod go-w,a+x <replaceable>FILE</replaceable></userinput></screen>

<!--
    <para>Mit symbolischen Zugriffsrechten k&ouml;nnen Sie Rechte
      hinzuf&uuml;gen oder Rechte wegnehmen.  Numerische Zugriffsrechte
      erlauben nur das explizite Setzen der Zugriffsrechte.</para>
-->
    </sect2>
  </sect1>

  <sect1 id="dirstructure">
    <title>Verzeichnis-Strukturen</title>
    <indexterm><primary>Verzeichnis Hierarchien</primary></indexterm>

    <para>Die FreeBSD-Verzeichnishierarchie ist die Grundlage, um
      ein umfassendes Verst&auml;ndnis des Systems zu erlangen.
      Das wichtigste Konzept, das Sie verstehen sollten, ist das
      Root-Verzeichnis <quote>/</quote>.  Dieses Verzeichnis ist das
      erste, das w&auml;hrend des Bootens eingehangen wird.  Es
      enth&auml;lt das notwendige Basissystem, um das System in den
      Mehrbenutzerbetrieb zu bringen.  Das Root-Verzeichnis enth&auml;lt
      auch die Mountpunkte anderer Dateisysteme, die sp&auml;ter
      eingehangen werden.</para>

    <para>Ein Mountpunkt ist ein Verzeichnis, in das zus&auml;tzliche
      Dateisysteme in das <filename>/</filename> Verzeichnis eingepflanzt
      werden k&ouml;nnen.
      Standard Mountpunkte beinhalten <filename>/usr</filename>,
      <filename>/var</filename>, <filename>/mnt</filename> und
      <filename>/cdrom</filename>.  Auf diese Verzeichnisse verweisen
      &uuml;blicherweise Eintr&auml;ge in der Datei
      <filename>/etc/fstab</filename>.  <filename>/etc/fstab</filename> ist
      eine Tabelle mit verschiedenen Dateisystemen und Mountpunkten
      als Referenz des Systems.  Die meisten der Dateisysteme in
      <filename>/etc/fstab</filename> werden beim Booten automatisch
      durch das Skript &man.rc.8; gemountet, wenn die zugeh&ouml;rigen
      Eintr&auml;ge nicht mit der Option <option>noauto</option>
      versehen sind.  Konsultieren Sie die &man.fstab.5; Manualpage
      f&uuml;r mehr Informationen &uuml;ber das Format der Datei
      <filename>/etc/fstab</filename> und den Optionen darin.</para>

    <para>Eine vollst&auml;ndige Beschreibung der Dateisystem-Hierarchie
      finden Sie in &man.hier.7;.  Als Beispiel sei eine kurze
      &Uuml;bersicht &uuml;ber die gebr&auml;uchlisten Verzeichnisse
      gegeben:</para>

    <para>
      <informaltable frame="none">
        <tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Verzeichnis</entry>
	      <entry>Beschreibung</entry>
	    </row>
	  </thead>
	  <tbody>
            <row>
	      <entry><filename class="directory">/</filename></entry>
	      <entry>Root-Verzeichnis des Dateisystems.</entry>
            </row>

	    <row>
	      <entry><filename class="directory">/bin/</filename></entry>
	      <entry>Grundlegende Werkzeuge f&uuml;r den Single-User-Modus
		sowie den Mehrbenutzerbetrieb.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/boot/</filename></entry>
	      <entry>Programme und Konfigurationsdateien, die w&auml;hrend
		des Bootens benutzt werden.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/boot/defaults/</filename></entry>
	      <entry>Vorgaben f&uuml;r die Boot-Konfiguration, siehe
		&man.loader.conf.5;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/dev/</filename></entry>
	      <entry>Ger&auml;tedateien, siehe &man.intro.4;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/</filename></entry>
	      <entry>Konfigurationsdateien und Skripten des Systems.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/defaults/</filename></entry>
	      <entry>Vorgaben f&uuml;r die System Konfigurationsdateien,
		siehe &man.rc.8;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/mail/</filename></entry>
	      <entry>Konfigurationsdateien von MTAs wie
		&man.sendmail.8;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/namedb/</filename></entry>
	      <entry>Konfigurationsdateien von <command>named</command>,
		siehe &man.named.8;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/periodic/</filename></entry>
	      <entry>T&auml;glich, w&ouml;chentlich oder monatlich
		ablaufende Skripte, die von &man.cron.8; gestartet werden.
		Siehe &man.periodic.8;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/etc/ppp/</filename></entry>
	      <entry>Konfigurationsdateien von <command>ppp</command>,
		siehe &man.ppp.8;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/mnt/</filename></entry>
	      <entry>Ein leeres Verzeichnis, das von Systemadministratoren
		h&auml;ufig als tempor&auml;rer Mountpunkt genutzt wird.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/proc/</filename></entry>
	      <entry>Prozess Dateisystem, siehe &man.procfs.5;
		und &man.mount.procfs.8;.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/root/</filename></entry>
	      <entry>Home Verzeichnis von <username>root</username>.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/sbin/</filename></entry>
	      <entry>Systemprogramme und administrative Werkzeuge, die
		grundlegend f&uuml;r den Single-User-Modus und den
		Mehrbenutzerbetrieb sind.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/stand/</filename></entry>
	      <entry>Programme, die ohne andere Programme oder Bibliotheken
		laufen.</entry>
	    </row>


	    <row>
	      <entry><filename class="directory">/tmp/</filename></entry>
	      <entry>Tempor&auml;re Dateien, die f&uuml;r gew&ouml;hnlich
		nicht nach einem Reboot erhalten werden.  Dies kann
		ein speicherbasiertes Dateisystem, siehe &man.mfs.8;,
		sein.</entry>
	    </row>


	    <row>
	      <entry><filename class="directory">/usr/</filename></entry>
	      <entry>Der Gro&szlig;teil der Benutzerprogramme und
		Anwendungen.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/bin/</filename></entry>
	      <entry>Gebr&auml;uchliche Werkzeuge, Programmierhilfen und
		Anwendungen.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/include/</filename></entry>
	      <entry>Standard C include-Dateien.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/lib/</filename></entry>
	      <entry>Bibliotheken.</entry>
	    </row>


	    <row>
	      <entry><filename class="directory">/usr/libdata/</filename></entry>
	      <entry>Daten verschiedener Werkzeuge.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/libexec/</filename></entry>
	      <entry>System-D&auml;monen und System-Werkzeuge, die von
		anderen Programmen ausgef&uuml;hrt werden.</entry>
	    </row>

	    <row>
	      <entry><filename
	      class="directory">/usr/local/</filename></entry>

	      <entry>Lokale Programme, Bibliotheken usw.  Die Ports-Sammlung
		benutzt dieses Verzeichnis als Zielverzeichnis f&uuml;r zu
		installierende Anwendungen.  Innerhalb von
		<filename>/usr/local</filename> sollte das von
		&man.hier.7; beschriebene Layout f&uuml;r
		<filename>/usr</filename> benutzt werden.  Das
		<filename>man</filename> Verzeichnis wird direkt unter
		<filename>/usr/local</filename> anstelle unter
		<filename>/usr/local/share</filename> angelegt.  Die
		Dokumentation der Ports findet sich in
		<filename>share/doc/<replaceable>port</replaceable></filename>.
	      </entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/obj/</filename></entry>
	      <entry>Von der Architektur abh&auml;ngiger Verzeichnisbaum,
		der durch das Bauen von <filename>/usr/src</filename>
		entsteht.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/ports</filename></entry>
	      <entry>Die FreeBSD-Ports-Sammlung (optional).</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/sbin/</filename></entry>
	      <entry>System-D&auml;monen und System-Werkzeuge, die von
		Benutzern ausgef&uuml;hrt werden.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/share/</filename></entry>
	      <entry>Von der Architektur unabh&auml;ngige Dateien.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/usr/src/</filename></entry>
	      <entry>Quelldateien von BSD und/oder lokalen
		Erg&auml;nzungen.</entry>
	    </row>

	    <row>
	      <entry><filename
	      class="directory">/usr/X11R6/</filename></entry>
	      <entry>Optionale X11R6-Programme und Bibliotheken.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/var/</filename></entry>
	      <entry>Wird f&uuml;r mehrere Zwecke genutzt und enth&auml;lt
		Logdateien, tempor&auml;re Daten und Spooldateien.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/var/log/</filename></entry>
	      <entry>Verschiedene Logdateien des Systems.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/var/mail/</filename></entry>
	      <entry>Postf&auml;cher der Benutzer.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/var/spool/</filename></entry>
	      <entry>Verschiedene Spool-Verzeichnisse der Drucker- und
		Mailsysteme.</entry>
	    </row>

	    <row>
	      <entry><filename class="directory">/var/tmp/</filename></entry>
	      <entry>Tempor&auml;re Dateien, die &uuml;ber Reboots erhalten
		bleiben.</entry>
	    </row>

	    <row>
	      <entry><filename>/var/yp</filename></entry>
	      <entry>NIS maps.</entry>
	    </row>

	  </tbody>
	</tgroup>
      </informaltable>
    </para>
  </sect1>

  <sect1 id="disk-organization">
      <title>Festplatten, Slices und Partitionen</title>

      <para>&os; identifiziert Dateien anhand eines Dateinamens.
	In Dateinamen wird zwischen Gro&szlig;- und Kleinschreibung
	unterschieden:  <filename>readme.txt</filename> und
	<filename>README.TXT</filename> bezeichnen daher zwei
	verschiedene Dateien.  &os; benutzt keine Dateiendungen wie
	<filename>.txt</filename>, um den Typ der Datei
	(ein Programm, ein Dokument oder andere Daten) zu
	bestimmen.</para>

      <para>Dateien werden in Verzeichnissen gespeichert.  In einem
	Verzeichnis k&ouml;nnen sich keine oder hunderte Dateien
	befinden.  Ein Verzeichnis kann auch andere Verzeichnisse
	enthalten und so eine Hierarchie von Verzeichnissen aufbauen,
	die Ihnen die Ablage von Daten erleichtert.</para>

      <para>In Dateinamen werden Verzeichnisse durch einen
	Schr&auml;gstrich (<literal>/</literal>,
	<foreignphrase>Slash</foreignphrase>) getrennt.  Wenn
	das Verzeichnis <filename class="directory">foo</filename>
	ein Verzeichnis <filename class="directory">bar</filename>
	enth&auml;lt, in dem sich die Datei <filename>readme.txt</filename>
	befindet, lautet der vollst&auml;ndige Name der Datei
	(oder der <firstterm>Pfad</firstterm> zur Datei)
	<filename>foo/bar/readme.txt</filename>.</para>

      <para>Verzeichnisse und Dateien werden in einem Dateisystem
	gespeichert.  Jedes Dateisystem besitzt ein
	<firstterm>Wurzelverzeichnis</firstterm>
	(<foreignphrase>Root-Directory</foreignphrase>),
	das weitere Verzeichnisse enthalten kann.</para>

      <para>Dieses Konzept kennen Sie vielleicht von anderen
	Betriebssystemen, aber es gibt einige Unterschiede:
	In &ms-dos; werden Datei- und Verzeichnisnamen mit dem
	Zeichen <literal>\</literal> getrennt, &macos; benutzt
	dazu das Zeichen <literal>:</literal>.</para>

      <para>&os; kennt keine Laufwerksbuchstaben und in Pfaden
	werden keine Bezeichnungen f&uuml;r Laufwerke benutzt.
	Die Pfadangabe <filename>c:/foo/bar/readme.txt</filename>
	gibt es in &os; nicht.</para>

      <para>Stattdessen wird ein Dateisystem als Wurzeldateisystem
	(<foreignphrase>Root-Filesystem</foreignphrase>)
	ausgew&auml;hlt.  Das Wurzelverzeichnis dieses Dateisystems
	wird <filename class="directory">/</filename> genannt.
	Jedes andere Dateisystem wird unter dem Wurzeldateisystem
	<firstterm>eingehangen</firstterm>
	(<foreignphrase>mount</foreignphrase>).  Daher scheint
	jedes Verzeichnis, unabh&auml;ngig von der Anzahl der
	Platten, auf derselben Platte zu liegen.</para>

      <para>Betrachten wir drei Dateisysteme <literal>A</literal>,
	<literal>B</literal> und <literal>C</literal>.  Jedes
	Dateisystem besitzt ein eigenes Wurzelverzeichnis, das
	zwei andere Verzeichnisse enth&auml;lt:
	<filename class="directory">A1</filename>,
	<filename class="directory">A2</filename>,
	<filename class="directory">B1</filename>,
	<filename class="directory">B2</filename>,
	<filename class="directory">C1</filename> und
	<filename class="directory">C2</filename>.</para>

      <para>Das Wurzeldateisystem soll <literal>A</literal> sein.
	Das Kommando <command>ls</command> zeigt darin
	die beiden Verzeichnisse <filename class="directory">A1</filename>
	und <filename class="directory">A2</filename> an.
	Der Verzeichnisbaum sieht wie folgt aus:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir1" format="EPS">
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2</literallayout>
	</textobject>
      </mediaobject>

      <para>Ein Dateisystem wird in einem Verzeichnis eines anderen
	Dateisystems eingehangen.  Wir h&auml;ngen nun das Dateisystem
	<literal>B</literal> in das Verzeichnis
	<filename class="directory">A1</filename> ein.  Das
	Wurzelverzeichnis von <literal>B</literal> ersetzt nun
	das Verzeichnis <filename class="directory">A1</filename> und
	die Verzeichnisse des Dateisystems <literal>B</literal>
	werden sichtbar:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir2" format="EPS">
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |     |
 |     +--- B1
 |     |
 |     `--- B2
 |
 `--- A2</literallayout>
	</textobject>
      </mediaobject>

      <para>Jede Datei in den Verzeichnissen
	<filename class="directory">B1</filename> oder
	<filename class="directory">B2</filename> kann
	&uuml;ber den Pfad <filename class="directory">/A1/B1</filename>
	oder <filename class="directory">/A1/B2</filename>
	erreicht werden.  Dateien aus dem Verzeichnis
	<filename class="directory">/A1</filename> sind jetzt
	verborgen.  Wenn das Dateisystem <literal>B</literal>
	wieder <firstterm>abgehangen</firstterm> wird
	(<foreignphrase>umount</foreignphrase>), erscheinen
	die verborgenen Dateien wieder.</para>

      <para>Wenn das Dateisystem <literal>B</literal> unter dem
	Verzeichnis <filename class="directory">A2</filename>
	eingehangen w&uuml;rde, s&auml;he der Verzeichnisbaum
	so aus:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir3" format="EPS">
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2
       |
       +--- B1
       |
       `--- B2</literallayout>
	</textobject>
      </mediaobject>

      <para>Die Dateien des Dateisystems <literal>B</literal> w&auml;ren
	unter den Pfaden <filename class="directory">/A2/B1</filename> und
	<filename class="directory">/A2/B2</filename> erreichbar.</para>

      <para>Dateisysteme k&ouml;nnen &uuml;bereinander eingehangen
	werden.  Der folgende Baum entsteht, wenn im letzten
	Beispiel das Dateisystem <literal>C</literal> in das Verzeichnis
	<filename class="directory">B1</filename> des Dateisystems
	<literal>B</literal> eingehangen wird:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir4" format="EPS">
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2
       |
       +--- B1
       |     |
       |     +--- C1
       |     |
       |     `--- C2
       |
       `--- B2</literallayout>
	</textobject>
      </mediaobject>

      <para><literal>C</literal> k&ouml;nnte auch im Verzeichnis
	<filename class="directory">A1</filename> eingehangen
	werden:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir5" format="EPS">
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |     |
 |     +--- C1
 |     |
 |     `--- C2
 |
 `--- A2
       |
       +--- B1
       |
       `--- B2</literallayout>
	</textobject>
      </mediaobject>

      <para>Der &ms-dos;-Befehl <command>join</command> kann &Auml;hnliches
	bewirken.</para>

      <para>Normalerweise m&uuml;ssen Sie sich nicht mit Dateisystemen
	besch&auml;ftigen.  W&auml;hrend der Installation werden
	die Dateisysteme und die Stellen, in der sie eingehangen werden,
	festgelegt.  Dateisysteme m&uuml;ssen Sie erst wieder anlegen,
	wenn Sie eine neue Platte hinzuf&uuml;gen.</para>

      <para>Sie k&ouml;nnen sogar mit nur einem gro&szlig;en
	Dateisystem auskommen.  Dies hat mehrere Nachteile
	und einen Vorteil.</para>

      <itemizedlist>
	<title>Vorteile mehrerer Dateisysteme</title>

	<listitem>
	  <para>Die Dateisysteme k&ouml;nnen mit unterschiedlichen
	    Optionen (<foreignphrase>mount options</foreignphrase>)
	    eingehangen werden.  Bei sorgf&auml;ltiger Planung k&ouml;nnen
	    Sie beispielsweise das Wurzeldateisystem nur lesbar
	    einh&auml;ngen.  Damit sch&uuml;tzen Sie sich vor dem
	    unabsichtlichen L&ouml;schen oder Editieren kritischer
	    Dateien.  Von Benutzern beschreibbare Dateisysteme
	    wie <filename class="directory">/home</filename>
	    k&ouml;nnen Sie mit der Option <firstterm>nosuid</firstterm>
	    einh&auml;ngen, wenn sie von anderen Dateisystemen getrennt
	    sind.  Die <firstterm>SUID</firstterm>- und
	    <firstterm>GUID</firstterm>-Bits verlieren auf solchen
	    Dateisystemen ihre Wirkung und die Sicherheit des
	    Systems kann dadurch erh&ouml;ht werden.</para>
	</listitem>

	<listitem>
	  <para>Die Lage von Dateien im Dateisystem wird, abh&auml;ngig
	    vom Gebrauch des Dateisystems, automatisch von &os;
	    optimiert.  Ein Dateisystem mit vielen kleinen Dateien,
	    die h&auml;ufig geschrieben werden, wird anders behandelt
	    als ein Dateisystem mit wenigen gro&szlig;en Dateien.
	    Mit nur einem Dateisystem ist diese Optimierung
	    unm&ouml;glich.</para>
	</listitem>

	<listitem>
	  <para>In der Regel &uuml;bersteht ein &os;-Dateisystem auch
	    einen Stromausfall.  Allerdings kann ein Stromausfall zu
	    einem kritischen Zeitpunkt das Dateisystem besch&auml;digen.
	    Wenn die Daten &uuml;ber mehrere Dateisysteme verteilt
	    sind, l&auml;sst sich das System mit hoher
	    Wahrscheinlichkeit noch starten.  Dies erleichtert
	    das Zur&uuml;ckspielen von Datensicherungen.</para>
	</listitem>
      </itemizedlist>

      <itemizedlist>
	<title>Vorteil eines einzelnen Dateisystems</title>

	<listitem>
	  <para>Die Gr&ouml;&szlig;e von Dateisystemen liegt fest.
	    Es kann passieren, dass Sie eine Partition
	    vergr&ouml;&szlig;ern m&uuml;ssen.  Dies ist nicht leicht:
	    Sie m&uuml;ssen die Daten sichern, das Dateisystem
	    vergr&ouml;&szlig;ert anlegen und die gesicherten
	    Daten zur&uuml;ckspielen.</para>

	  <important>
	    <para>Ab &os;&nbsp;4.4 existiert diese Beschr&auml;nkung
	      nicht mehr:  Das Kommando &man.growfs.8; kann Dateisysteme
	      im laufenden Betrieb vergr&ouml;&szlig;ern.</para>
	  </important>
	</listitem>
      </itemizedlist>

      <para>Dateisysteme befinden sich in Partitionen (damit sind
	nicht die normalen &ms-dos;-Partitionen gemeint).  Jede Partition
	wird mit einem Buchstaben von <literal>a</literal> bis
	<literal>h</literal> bezeichnet und kann nur ein Dateisystem
	enthalten.  Dateisysteme k&ouml;nnen daher &uuml;ber ihren
	Mount-Point, den Punkt an dem sie eingehangen sind, oder
	den Buchstaben der Partition, in der sie liegen, identifiziert
	werden.</para>

      <para>&os; benutzt einen Teil der Platte f&uuml;r den
	<firstterm>Swap-Bereich</firstterm>, der dem Rechner
	<firstterm>virtuellen Speicher</firstterm> zur Verf&uuml;gung
	stellt.  Dadurch kann der Rechner Anwendungen mehr Speicher
	zur Verf&uuml;gung stellen als tats&auml;chlich eingebaut
	ist.  Wenn der Speicher knapp wird, kann &os; nicht benutzte
	Daten in den Swap-Bereich auslagern.  Die ausgelagerten
	Daten k&ouml;nnen sp&auml;ter wieder in den Speicher
	geholt werden (daf&uuml;r werden dann andere Daten
	ausgelagert).</para>

      <para>F&uuml;r einige Partitionen gelten besondere
        Konventionen:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <colspec colwidth="1*">
	  <colspec colwidth="5*">

	  <thead>
	    <row>
	      <entry>Partition</entry>

	      <entry>Konvention</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><literal>a</literal></entry>

	      <entry>Enth&auml;lt normalerweise
		das Wurzeldateisystem</entry>
	    </row>

	    <row>
	      <entry><literal>b</literal></entry>

	      <entry>Enth&auml;lt normalerweise
		den Swap-Bereich</entry>
	    </row>

	    <row>
	      <entry><literal>c</literal></entry>

	      <entry>Ist normalerweise genauso gro&szlig; wie
		die Slice in der die Partition liegt.  Werkzeuge,
		die auf der kompletten Slice arbeiten, wie ein
		Bad-Block-Scanner, k&ouml;nnen so die
		<literal>c</literal>-Partition benutzen.
		F&uuml;r gew&ouml;hnlich legen Sie in dieser
		Partition kein Dateisystem an.</entry>
	    </row>

	    <row>
	      <entry><literal>d</literal></entry>

	      <entry>Fr&uuml;her hatte die <literal>d</literal>-Partition
		eine besondere Bedeutung.  Bis heute haben einige
		Werkzeuge Schwierigkeiten mit der
		<literal>d</literal>-Partition, sodass
		<application>sysinstall</application> normalerweise
		keine <literal>d</literal>-Partition anlegt.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>Jede Partition, die ein Dateisystem enth&auml;lt,
	wird in einer <firstterm>Slice</firstterm> angelegt.
	Slice ist der Begriff, den &os; f&uuml;r &ms-dos;-Partitionen
	verwendet.  Slices werden von eins bis vier durchnummeriert.</para>

      <indexterm><primary>Slices</primary></indexterm>
      <indexterm><primary>Partitionen</primary></indexterm>
      <indexterm><primary>dangerously dedicated</primary></indexterm>

      <para>Die Slice-Nummern werden mit vorgestelltem
	<literal>s</literal> hinter den Ger&auml;tenamen gestellt:
	<quote>da0<emphasis>s1</emphasis></quote>
	ist die erste Slice auf dem ersten SCSI-Laufwerk.  Auf einer
	Festplatte gibt es h&ouml;chstens vier Slices.  In einer
	Slice des passenden Typs kann es weitere logische Slices
	geben.  Diese erweiterten Slices werden ab f&uuml;nf durchnummeriert:
	<quote>ad0<emphasis>s5</emphasis></quote> ist
	die erste erweiterte Slice auf einer IDE-Platte.  Diese
	Ger&auml;te werden von Dateisystemen benutzt, die sich in
	einer kompletten Slice befinden m&uuml;ssen.</para>

      <para>Slices, <quote>dangerously dedicated</quote>-Festplatten
	und andere Platten enthalten Partitionen, die mit Buchstaben
	von <literal>a</literal> bis <literal>h</literal> bezeichnet
	werden.  Der Buchstabe wird an den Ger&auml;tenamen
	gehangen: <quote>da0<emphasis>a</emphasis></quote>
	ist die <literal>a</literal>-Partition des ersten
	<literal>da</literal>-Laufwerks.  Dieses Laufwerk ist
	<quote>dangerously dedicated</quote>.
	<quote>ad1s3<emphasis>e</emphasis></quote> ist
	die f&uuml;nfte Partition in der dritten Slice der zweiten
	IDE-Platte.</para>

      <para>Schlie&szlig;lich wird noch jede Festplatte des Systems
	eindeutig bezeichnet.  Der Name einer Festplatte beginnt mit
	einem Code, der den Typ der Platte bezeichnet.  Es folgt eine
	Nummer, die angibt, um welche Festplatte es sich handelt.
	Anders als bei Slices werden Festplatten von Null beginnend
	durchnummeriert.  G&auml;ngige Festplatten-Namen sind in
	<xref linkend="basics-dev-codes"> zusammengestellt.</para>

      <para>Wenn Sie eine Partition angeben, erwartet &os; dass Sie
        auch die Slice und die Platte angeben, in denen sich die
	Partition befindet.  Wenn Sie eine Slice angeben, m&uuml;ssen
	Sie auch die Platte der Slice angeben.  Setzen Sie den Namen
	aus dem Plattennamen gefolgt von einem <literal>s</literal>,
	der Slice-Nummer und dem Buchstaben der Partition zusammen.
	Einige Beispiele finden Sie in
	<xref linkend="basics-disk-slice-part">.</para>

      <para>Der Aufbau einer Festplatte wird in
	<xref linkend="basics-concept-disk-model"> dargestellt.</para>

      <para>Um &os; zu installieren, m&uuml;ssen Sie zuerst Slices
	auf den Festplatten anlegen.  Innerhalb der Slices, die Sie
	f&uuml;r &os; verwenden wollen, m&uuml;ssen Sie dann
	Partitionen anlegen.  In den Partitionen wiederum werden
	die Dateisysteme (oder der Auslagerungsbereich) angelegt.
	F&uuml;r Dateisysteme m&uuml;ssen Sie schlie&szlig;lich
	noch festlegen, wo diese eingehangen werden (Mount-Point).</para>

      <table frame="none" pgwide="1" id="basics-dev-codes">
	<title>Laufwerk-Codes</title>

	<tgroup cols="2">
          <colspec colwidth="1*">
          <colspec colwidth="5*">

	  <thead>
	    <row>
	      <entry>Code</entry>

	      <entry>Bedeutung</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><devicename>ad</devicename></entry>

	      <entry>ATAPI (IDE) Festplatte</entry>
	    </row>

	    <row>
	      <entry><devicename>da</devicename></entry>

	      <entry>SCSI-Festplatte</entry>
	    </row>

	    <row>
	      <entry><devicename>acd</devicename></entry>

	      <entry>ATAPI (IDE) CD-ROM</entry>
	    </row>

	    <row>
	      <entry><devicename>cd</devicename></entry>

	      <entry>SCSI-CD-ROM</entry>
	    </row>

	    <row>
	      <entry><devicename>fd</devicename></entry>

	      <entry>Disketten-Laufwerk</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <example id="basics-disk-slice-part">
	<title>Namen von Platten, Slices und Partitionen</title>

	<informaltable frame="none" pgwide="1">
	  <tgroup cols="2">
            <colspec colwidth="1*">
            <colspec colwidth="5*">

	    <thead>
	      <row>
		<entry>Name</entry>

		<entry>Bedeutung</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><devicename>ad0s1a</devicename></entry>

		<entry>Die erste Partition (<literal>a</literal>)
		  in der ersten Slice (<literal>s1</literal>) der
		  ersten IDE-Festplatte (<literal>ad0</literal>).</entry>
	      </row>

	      <row>
		<entry><devicename>da1s2e</devicename></entry>

		<entry>Die f&uuml;nfte Partition (<literal>e</literal>)
		  der zweiten Slice (<literal>s2</literal>) auf
		  der zweiten SCSI-Festplatte
		  (<literal>da1</literal>).</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </example>

      <example id="basics-concept-disk-model">
	<title>Aufteilung einer Festplatte</title>

	<para>Das folgende Diagramm zeigt die Sicht von &os; auf die
	  erste IDE-Festplatte eines Rechners.  Die Platte soll
	  4&nbsp;GB gro&szlig; sein und zwei Slices (&ms-dos;-Partitionen)
	  mit je 2&nbsp;GB besitzen.  Die erste Slice enth&auml;lt
	  ein &ms-dos;-Laufwerk (<devicename>C:</devicename>), die zweite
	  Slice wird von &os; benutzt.  Im Beispiel verwendet die
	  &os;-Installationen drei Partitionen und einen
	  Auslagerungsbereich.</para>

	<para>Jede der drei Partitionen enth&auml;lt ein Dateisystem.
	  Das Wurzeldateisystem ist die <literal>a</literal>-Partition.
	  In der <literal>e</literal>-Partition befindet sich
	  der <filename class="directory">/var</filename>-Verzeichnisbaum
	  und in der <literal>f</literal>-Partition befindet sich
	  der Verzeichnisbaum unterhalb von
	  <filename class="directory">/usr</filename>.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="install/disk-layout" format="EPS">
          </imageobject>

          <textobject>
	    <literallayout class="monospaced">.-----------------.  --.
|                 |    |
|  DOS / Windows  |    |
:                 :     >  First slice, ad0s1
:                 :    |
|                 |    |
:=================:  ==:                               --.
|                 |    |  Partition a, mounted as /      |
|                 |     > referred to as ad0s2a          |
|                 |    |                                 |
:-----------------:  ==:                                 |
|                 |    |  Partition b, used as swap      |
|                 |     > referred to as ad0s2b          |
|                 |    |                                 |
:-----------------:  ==:                                 |  Partition c, no
|                 |    |  Partition e, used as /var       > filesystem, all
|                 |     > referred to as ad0s2e          |  of FreeBSD slice,
|                 |    |                                 |  ad0s2c
:-----------------:  ==:                                 |
|                 |    |                                 |
:                 :    |  Partition f, used as /usr      |
:                 :     > referred to as ad0s2f          |
:                 :    |                                 |
|                 |    |                                 |
|                 |  --'                                 |
`-----------------'                                    --'</literallayout>
          </textobject>
        </mediaobject>
      </example>
  </sect1>

  <sect1 id="disks-mounting">
    <title>Anh&auml;ngen und Abh&auml;ngen von Dateisystemen</title>

    <para>Ein Dateisystem wird am besten als ein Baum mit der
      Wurzel <filename>/</filename> veranschaulicht.
      <filename>/dev</filename>, <filename>/usr</filename>, und
      die anderen Verzeichnisse im Rootverzeichnis sind Zweige,
      die wiederum eigene Zweige wie <filename>/usr/local</filename>
      haben k&ouml;nnen.</para>

    <indexterm><primary>Root-Dateisystem</primary></indexterm>
    <para>Es gibt verschiedene Gr&uuml;nde, bestimmte dieser Verzeichnisse
      auf eigenen Dateisystemen anzulegen.  <filename>/var</filename>
      enth&auml;lt <filename>log/</filename>, <filename>spool/</filename>
      sowie verschiedene andere tempor&auml;re
      Dateien und kann sich daher schnell f&uuml;llen.  Es empfiehlt sich,
      <filename>/var</filename> von <filename>/</filename> zu trennen,
      da es schlecht ist, wenn das Root-Dateisystem voll
      l&auml;uft.</para>

    <para>Ein weiterer Grund bestimmte Verzeichnisb&auml;ume auf
      andere Dateisysteme zu legen, ist gegeben, wenn sich die
      Verzeichnisb&auml;ume auf gesonderten physikalischen oder
      virtuellen Platten, wie
      <link linkend="network-nfs">Network File System</link>
      oder CD-ROM-Laufwerken, befinden.</para>

    <sect2 id="disks-fstab">
      <title>Die <filename>fstab</filename> Datei</title>

      <indexterm>
	 <primary>Dateisysteme</primary>
	 <secondary>fstab</secondary>
      </indexterm>
      <para>W&auml;hrend des <link linkend="boot">Boot-Prozesses</link>
	werden in <filename>/etc/fstab</filename> aufgef&uuml;hrte
	Verzeichnisse, sofern sie nicht mit der Option <option>noauto</option>
	versehen sind, automatisch angehangen.</para>

      <para>Die Zeilen in <filename>/etc/fstab</filename> haben das
	folgende Format:</para>

      <programlisting><replaceable>device</replaceable>	<replaceable>/mount-point</replaceable>	<replaceable>fstype</replaceable>	<replaceable>options</replaceable>	<replaceable>dumpfreq</replaceable>	<replaceable>passno</replaceable></programlisting>

      <variablelist>
	<varlistentry>
	  <term><literal>device</literal></term>

	  <listitem>
            <para>Ein existierender Ger&auml;tename
	      wie in <xref linkend="disks-naming"> beschrieben.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>mount-point</literal></term>

	  <listitem>
            <para>Ein existierendes Verzeichnis,
	      an das das Dateisystem angehangen wird.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>fstype</literal></term>

	  <listitem>
            <para>Der Typ des Dateisystems,
	      der an &man.mount.8; weitergegeben wird.  FreeBSDs
	      Standarddateisystem ist <literal>ufs</literal>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>options</literal></term>

	  <listitem>
	    <para>Entweder <option>rw</option>
	      f&uuml;r beschreibbare Dateisysteme oder <option>ro</option>
	      f&uuml;r schreibgesch&uuml;tzte Dateisysteme, gefolgt von
	      weiteren ben&ouml;tigten Optionen.  Eine h&auml;ufig verwendete
	      Option ist <option>noauto</option> f&uuml;r Dateisysteme,
	      die w&auml;hrend der normalen Bootsequenz nicht angehangen
	      werden sollen.  Weitere Optionen finden sich
	      in &man.mount.8;.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>dumpfreq</literal></term>

	  <listitem><para>Gibt die Anzahl der Tage an, nachdem das
	      Dateisystem gesichert werden soll.  Fehlt der Wert, wird
	      <literal>0</literal> angenommen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>passno</literal></term>

	  <listitem><para>Bestimmt die Reihenfolge, in der die Dateisysteme
	      &uuml;berpr&uuml;ft werden sollen.  F&uuml;r Dateisysteme,
	      die &uuml;bersprungen werden sollen, ist
	      <literal>passno</literal> auf null zu setzen.  F&uuml;r das
	      Root-Dateisystem, das vor allen anderen &uuml;berpr&uuml;ft
	      werden muss, sollte der Wert von
	      <literal>passno</literal> eins betragen.  Allen anderen
	      Dateisystemen sollten Werte gr&ouml;&szlig;er eins zugewiesen
	      werden.  Wenn mehrere Dateisysteme den gleichen Wert
	      besitzen, wird &man.fsck.8; versuchen, diese parallel zu
	      &uuml;berpr&uuml;fen.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 id="disks-mount">
      <title>Das <command>mount</command> Kommando</title>
      <indexterm>
	<primary>Dateisysteme</primary>
	<secondary>anh&auml;ngen</secondary>
      </indexterm>

      <para>&man.mount.8; h&auml;ngt schlie&szlig;lich Dateisysteme
	an.</para>

      <para>In der grundlegenden Form wird es wie folgt benutzt:</para>

      <informalexample>
	<screen>&prompt.root; <userinput>mount <replaceable>device</replaceable> <replaceable>mountpoint</replaceable></userinput></screen>
      </informalexample>

      <para>Viele Optionen werden in &man.mount.8; beschrieben,
	die am h&auml;ufigsten verwendeten sind:</para>

      <variablelist>
	<title>Optionen von <command>mount</command></title>

	<varlistentry>
	  <term><option>-a</option></term>

	  <listitem>
            <para>H&auml;ngt alle Dateisysteme aus
	      <filename>/etc/fstab</filename> an.  Davon ausgenommen
	      sind Dateisysteme, die mit <quote>noauto</quote> markiert
	      sind, die mit der Option <option>-t</option> ausgeschlossen
	      wurden und Dateisysteme, die schon angehangen sind.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-d</option></term>

	  <listitem>
            <para>F&uuml;hrt alles bis auf den
	      <function>mount</function>-Systemaufruf aus.
	      N&uuml;tzlich ist diese Option in Verbindung
	      mit <option>-v</option>.  Damit wird angezeigt, was
	      &man.mount.8; tats&auml;chlich versuchen
	      w&uuml;rde, um das Dateisystem anzuh&auml;ngen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-f</option></term>

	  <listitem>
	    <para>Erzwingt das Anh&auml;ngen eines unsauberen Dateisystems
	      oder erzwingt die R&uuml;cknahme des Schreibzugriffs, wenn
	      der Status des Dateisystems von beschreibbar auf
	      schreibgesch&uuml;tzt ge&auml;ndert wird.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-r</option></term>

	  <listitem>
	    <para>H&auml;ngt das Dateisystem schreibgesch&uuml;tzt an.  Das
	      kann auch durch Angabe von <option>rdonly</option> zu der
	      <option>-o</option> Option erreicht werden.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-t</option>
	    <replaceable>fstype</replaceable></term>

	  <listitem>
            <para>H&auml;ngt das Dateisystem mit dem angegebenen Typ an,
	      oder h&auml;ngt nur Dateisysteme mit dem angegebenen Typ
	      an, wenn auch <option>-a</option> angegeben
	      wurde.</para>

            <para>Die Voreinstellung f&uuml;r den Typ des Dateisystems
	      ist <quote>ufs</quote>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-u</option></term>

	  <listitem>
	    <para>Aktualisiert die Mountoptionen des Dateisystems.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-v</option></term>

	  <listitem>
	    <para>Geschw&auml;tzig sein.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-w</option></term>

	  <listitem>
	    <para>H&auml;ngt das Dateisystem beschreibbar an.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para><option>-o</option> erwartet eine durch Kommata separierte Liste
	von Optionen, unter anderem die folgenden:</para>

      <variablelist>
	<varlistentry>
	  <term>nodev</term>

	  <listitem>
            <para>Beachtet keine Ger&auml;tedateien auf dem Dateisystem.
	      Dies ist eine n&uuml;tzliche Sicherheitsfunktion.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>noexec</term>

	  <listitem>
	    <para>Verbietet das Ausf&uuml;hren von bin&auml;ren
	      Dateien auf dem Dateisystem.  Dies ist eine
	      n&uuml;tzliche Sicherheitsfunktion.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>nosuid</term>

	  <listitem>
	    <para>SetUID und SetGID Bits werden auf dem Dateisystem
	      nicht beachtet.  Dies ist eine n&uuml;tzliche
	      Sicherheitsfunktion.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 id="disks-umount">
      <title>Das <command>umount</command> Kommando</title>
      <indexterm>
	<primary>Dateisysteme</primary>
	<secondary>abh&auml;ngen</secondary>
      </indexterm>

      <para>&man.umount.8; akzeptiert als Parameter entweder
	einen Mountpoint, einen Ger&auml;tenamen, oder die
	Optionen <option>-a</option> oder <option>-A</option>.</para>

      <para>Jede Form akzeptiert <option>-f</option>, um das
	Abh&auml;ngen zu erzwingen, und <option>-v</option>, um
	etwas geschw&auml;tziger zu sein.  Seien Sie bitte vorsichtig mit
	<option>-f</option>: Ihr Computer kann abst&uuml;rzen oder es
	k&ouml;nnen Daten auf dem Dateisystem besch&auml;digt werden, wenn
	Sie das Abh&auml;ngen erzwingen.</para>

      <para><option>-a</option> und <option>-A</option> werden benutzt
	um alle Dateisysteme, deren Typ durch <option>-t</option>
	modifiziert werden kann, abzuh&auml;ngen.  <option>-A</option>
	h&auml;ngt das Rootdateisystem nicht ab.</para>
    </sect2>
  </sect1>

  <sect1 id="basics-processes">
    <title>Prozesse</title>

    <para>Da FreeBSD ein Multitasking-Betriebssystem ist, sieht es so aus,
      als ob mehrere Prozesse zur gleichen Zeit laufen.  Jedes Programm,
      das zu irgendeiner Zeit l&auml;uft, wird
      <firstterm>Prozess</firstterm> genannt.  Jedes Kommando
      startet mindestens einen Prozess.  Einige Systemprozesse
      laufen st&auml;ndig und stellen die Funktion des Systems sicher.</para>

    <para>Jeder Prozess wird durch eine eindeutige Nummer identifiziert,
      die <firstterm>Prozess-ID</firstterm> oder
      <firstterm>PID</firstterm> genannt wird.  Prozesse haben ebenso
      wie Dateien einen Besitzer und eine Gruppe, die festlegen, welche
      Dateien und Ger&auml;te der Prozess benutzen kann.  Dabei
      finden die vorher beschriebenen Zugriffsrechte Anwendung.  Die meisten
      Prozesse haben auch einen Elternprozess, der sie gestartet hat.
      Wenn Sie in der Shell Kommandos eingeben, dann ist die Shell ein
      Prozess und jedes Kommando, das Sie starten, ist auch ein
      Prozess.  Jeder Prozess, den Sie auf diese Weise starten,
      besitzt den Shell-Prozess als Elternprozess.  Die Ausnahme
      hiervon ist ein spezieller Prozess, der &man.init.8;
      hei&szlig;t.  <command>init</command> ist immer der erste Prozess
      und hat somit die PID 1.  <command>init</command> wird vom Kernel
      beim Booten von FreeBSD gestartet.</para>

    <para>Die Kommandos &man.ps.1; und &man.top.1; sind besonders
      n&uuml;tzlich, um sich die Prozesse auf einem System anzusehen.
      <command>ps</command> zeigt eine statische Liste der laufenden
      Prozesse und kann deren PID, Speicherverbrauch und die
      Kommandozeile, mit der sie gestartet wurden und vieles mehr
      anzeigen.  <command>top</command> zeigt alle laufenden Prozesse
      an und aktualisiert die Anzeige, so dass Sie Ihrem Computer
      bei der Arbeit zuschauen k&ouml;nnen.</para>

    <para>Normal zeigt Ihnen <command>ps</command> nur die laufenden
      Prozesse, die Ihnen geh&ouml;ren.  Zum Beispiel:</para>

    <screen>&prompt.user; <userinput>ps</userinput>
  PID  TT  STAT      TIME COMMAND
  298  p0  Ss     0:01.10 tcsh
 7078  p0  S      2:40.88 xemacs mdoc.xsl (xemacs-21.1.14)
37393  p0  I      0:03.11 xemacs freebsd.dsl (xemacs-21.1.14)
48630  p0  S      2:50.89 /usr/local/lib/netscape-linux/navigator-linux-4.77.bi
48730  p0  IW     0:00.00 (dns helper) (navigator-linux-)
72210  p0  R+     0:00.00 ps
  390  p1  Is     0:01.14 tcsh
 7059  p2  Is+    1:36.18 /usr/local/bin/mutt -y
 6688  p3  IWs    0:00.00 tcsh
10735  p4  IWs    0:00.00 tcsh
20256  p5  IWs    0:00.00 tcsh
  262  v0  IWs    0:00.00 -tcsh (tcsh)
  270  v0  IW+    0:00.00 /bin/sh /usr/X11R6/bin/startx -- -bpp 16
  280  v0  IW+    0:00.00 xinit /home/nik/.xinitrc -- -bpp 16
  284  v0  IW     0:00.00 /bin/sh /home/nik/.xinitrc
  285  v0  S      0:38.45 /usr/X11R6/bin/sawfish</screen>

    <para>Wie Sie sehen, gibt &man.ps.1; mehrere Spalten aus.  In der
      <literal>PID</literal> Spalte findet sich die vorher besprochene
      Prozess-ID.  PIDs werden von 1 beginnend bis 99999 zugewiesen
      und fangen wieder von vorne an, wenn die Grenze &uuml;berschritten
      wird.  Die Spalte <literal>TT</literal> zeigt den Terminal, auf dem das
      Programm l&auml;uft.  <literal>STAT</literal> zeigt den Status
      des Programms an und kann f&uuml;r die Zwecke dieser Diskussion ebenso
      wie <literal>TT</literal> ignoriert werden.  <literal>TIME</literal>
      gibt die Zeit an, die das Programm auf der CPU gelaufen ist &ndash;
      dies ist nicht unbedingt die Zeit, die seit dem Start des Programms
      vergangen ist, da die meisten Programme haupts&auml;chlich auf
      bestimmte Dinge warten, bevor sie wirklich CPU-Zeit verbrauchen.
      Unter der Spalte <literal>COMMAND</literal> finden Sie schlie&szlig;lich
      die Kommandozeile, mit der das Programm gestartet wurde.</para>

    <para>&man.ps.1; besitzt viele Optionen, um die angezeigten Informationen
      zu beeinflussen.  Eine n&uuml;tzliche Kombination ist
      <literal>auxww</literal>.  Mit <option>a</option> werden Information
      &uuml;ber alle laufenden Prozesse und nicht nur Ihrer eigenen
      angezeigt.  Der Name des Besitzers des Prozesses, sowie Informationen
      &uuml;ber den Speicherverbrauch werden mit <option>u</option>
      angezeigt.  <option>x</option> zeigt auch D&auml;monen-Prozesse an,
      und <option>ww</option> veranlasst &man.ps.1; die komplette
      Kommandozeile anzuzeigen, anstatt sie abzuschneiden, wenn sie
      zu lang f&uuml;r die Bildschirmausgabe wird.</para>

    <para>Die Ausgabe von &man.top.1; sieht &auml;hnlich aus:</para>

    <screen>&prompt.user; <userinput>top</userinput>
last pid: 72257;  load averages:  0.13,  0.09,  0.03    up 0+13:38:33  22:39:10
47 processes:  1 running, 46 sleeping
CPU states: 12.6% user,  0.0% nice,  7.8% system,  0.0% interrupt, 79.7% idle
Mem: 36M Active, 5256K Inact, 13M Wired, 6312K Cache, 15M Buf, 408K Free
Swap: 256M Total, 38M Used, 217M Free, 15% Inuse

  PID USERNAME PRI NICE  SIZE    RES STATE    TIME   WCPU    CPU COMMAND
72257 nik       28   0  1960K  1044K RUN      0:00 14.86%  1.42% top
 7078 nik        2   0 15280K 10960K select   2:54  0.88%  0.88% xemacs-21.1.14
  281 nik        2   0 18636K  7112K select   5:36  0.73%  0.73% XF86_SVGA
  296 nik        2   0  3240K  1644K select   0:12  0.05%  0.05% xterm
48630 nik        2   0 29816K  9148K select   3:18  0.00%  0.00% navigator-linu
  175 root       2   0   924K   252K select   1:41  0.00%  0.00% syslogd
 7059 nik        2   0  7260K  4644K poll     1:38  0.00%  0.00% mutt
...</screen>

    <para>Die Ausgabe ist in zwei Abschnitte geteilt.  In den ersten
      f&uuml;nf Kopfzeilen finden sich die zuletzt zugeteilte PID, die
      Systemauslastung (engl. <foreignphrase>load average</foreignphrase>),
      die Systemlaufzeit (die Zeit seit dem letzten Reboot) und die
      momentane Zeit.  Die weiteren Zahlen im Kopf beschreiben wie viele
      Prozesse momentan laufen (im Beispiel 47), wie viel Speicher
      und Swap verbraucht wurde und wie viel Zeit das System in den
      verschiedenen CPU-Modi verbringt.</para>

    <para>Darunter befinden sich einige Spalten mit &auml;hnlichen
      Informationen wie in der Ausgabe von &man.ps.1;.  Wie im vorigen
      Beispiel k&ouml;nnen Sie die PID, den Besitzer, die verbrauchte
      CPU-Zeit und das Kommando erkennen.  &man.top.1; zeigt auch den
      Speicherverbrauch des Prozesses an, der in zwei Spalten aufgeteilt
      ist.  Die erste Spalte gibt den gesamten Speicherverbrauch des
      Prozesses an, in der zweiten Spalte wird der aktuelle Verbrauch
      angegeben.  <application>&netscape;</application> hat im gezeigten
      Beispiel insgesamt 30&nbsp;MB Speicher verbraucht.  Momentan benutzt
      es allerdings nur 9&nbsp;MB.</para>

    <para>Die Anzeige wird von &man.top.1; automatisch alle zwei Sekunden
      aktualisiert.  Der Zeitraum kann mit <option>-s</option> eingestellt
      werden.</para>
  </sect1>

  <sect1 id="basics-daemons">
    <title>D&auml;monen, Signale und Stoppen von Prozessen</title>

    <para>Wenn Sie einen Editor starten, k&ouml;nnen Sie ihn leicht bedienen
      und Dateien laden.  Sie k&ouml;nnen das, weil der Editor daf&uuml;r
      Vorsorge getroffen hat und auf einem <firstterm>Terminal</firstterm>
      l&auml;uft.  Manche Programme erwarten keine Eingaben von einem
      Benutzer und l&ouml;sen sich bei erster Gelegenheit von ihrem
      Terminal.  Ein Web-Server zum Beispiel verbringt den ganzen Tag
      damit, auf Anfragen zu antworten und erwartet keine Eingaben von Ihnen.
      Programme, die E-Mail von einem Ort zu einem anderen Ort transportieren
      sind ein weiteres Beispiel f&uuml;r diesen Typ von Anwendungen.</para>

    <para>Wir nennen diese Programme <firstterm>D&auml;monen</firstterm>.
      D&auml;monen stammen aus der griechischen Mythologie und waren
      weder gut noch b&ouml;se.  Sie waren kleine dienstbare Geister,
      die meistens n&uuml;tzliche Sachen f&uuml;r die Menschheit vollbrachten.
      &Auml;hnlich wie heutzutage Web-Server und Mail-Server n&uuml;tzliche
      Dienste verrichten.  Seit langer Zeit ist daher das BSD Maskottchen
      dieser fr&ouml;hlich aussehende D&auml;mon mit Turnschuhen
      und Dreizack.</para>

    <para>Programme, die als D&auml;mon laufen, werden entsprechend einer
      Konvention mit einem <quote>d</quote> am Ende benannt.
      <application>BIND</application> ist der Berkeley Internet Name Daemon
      und das tats&auml;chlich laufende Programm hei&szlig;t
      <command>named</command>.  Der Apache Webserver wird
      <command>httpd</command> genannt, der Druckerspool-D&auml;mon hei&szlig;t
      <command>lpd</command> usw.  Dies ist allerdings eine Konvention
      und keine unumst&ouml;&szlig;liche Regel: Der D&auml;mon der
      Anwendung <application>sendmail</application> hei&szlig;t
      <command>sendmail</command> und nicht <command>maild</command>, wie
      Sie vielleicht gedacht hatten.</para>

    <para>Manchmal m&uuml;ssen Sie mit einem D&auml;mon kommunizieren und
      dazu benutzen Sie <firstterm>Signale</firstterm>.  Sie k&ouml;nnen
      mit einem D&auml;monen oder jedem anderen laufenden Prozess
      kommunizieren, indem Sie diesem ein Signal schicken.  Sie k&ouml;nnen
      verschiedene Signale verschicken &ndash; manche haben eine festgelegte
      Bedeutung, andere werden von der Anwendung interpretiert.  Die
      Dokumentation zur fraglichen Anwendung wird erkl&auml;ren, wie
      die Anwendung Signale interpretiert.  Sie k&ouml;nnen nur Signale
      zu Prozessen senden,  die Ihnen geh&ouml;ren.  Normale Benutzer haben
      nicht die Berechtigung, Prozessen anderer Benutzer mit &man.kill.1;
      oder &man.kill.2; Signale zu schicken.  Der Benutzer
      <username>root</username> darf jedem Prozess Signale schicken.</para>

    <para>In manchen F&auml;llen wird FreeBSD Signale senden.  Wenn eine
      Anwendung schlecht geschrieben ist und auf Speicher zugreift, auf
      den sie nicht zugreifen soll, so sendet FreeBSD dem Prozess
      das <firstterm>Segmentation Violation</firstterm> Signal
      (<literal>SIGSEGV</literal>).  Wenn eine Anwendung den &man.alarm.3;
      Systemaufruf benutzt hat, um nach einiger Zeit benachrichtigt zu
      werden, bekommt sie das Alarm Signal (<literal>SIGALRM</literal>)
      gesendet.</para>

    <para>Zwei Signale k&ouml;nnen benutzt werden, um Prozesse zu stoppen:
      <literal>SIGTERM</literal> und <literal>SIGKILL</literal>.  Mit
      <literal>SIGTERM</literal> fordern Sie den Prozess h&ouml;flich zum
      Beenden auf.  Der Prozess kann das Signal abfangen und merken,
      dass er sich beenden soll.  Er hat dann Gelegenheit Logdateien
      zu schlie&szlig;en und die Aktion, die er vor der Aufforderung
      sich zu beenden durchf&uuml;hrte, abzuschlie&szlig;en.  Er kann
      sogar <literal>SIGTERM</literal> ignorieren, wenn er eine Aktion
      durchf&uuml;hrt, die nicht unterbrochen werden darf.</para>

    <para><literal>SIGKILL</literal> kann von keinem Prozess ignoriert
      werden.  Das Signal l&auml;sst sich mit <quote>Mich interessiert
      nicht, was du gerade machst, h&ouml;r sofort auf damit!</quote>
      umschreiben.  Wenn Sie einem Prozess <literal>SIGKILL</literal>
      schicken, dann wird FreeBSD diesen sofort beenden<footnote><para>
	Das stimmt nicht ganz: Es gibt F&auml;lle, in denen ein Prozess
	nicht unterbrochen werden kann.  Wenn der Prozesss zum Beispiel
	eine Datei von einem anderen Rechner auf dem Netzwerk liest und dieser
	Rechner aus irgendwelchen Gr&uuml;nden nicht erreichbar ist
	(ausgeschaltet, oder ein Netzwerkfehler), dann ist der Prozess
	nicht zu unterbrechen.  Wenn der Prozess den Lesezugriff
	nach einem Timeout von typischerweise zwei Minuten aufgibt,
	dann wir er beendet.</para>
      </footnote>.</para>

    <para>Andere Signale, die Sie vielleicht verschicken wollen, sind
      <literal>SIGHUP</literal>, <literal>SIGUSR1</literal> und
      <literal>SIGUSR2</literal>.  Diese Signale sind f&uuml;r allgemeine
      Zwecke vorgesehen und verschiedene Anwendungen werden unterschiedlich
      auf diese Signale reagieren.</para>

    <para>Nehmen wir an, Sie haben die Konfiguration Ihres Webservers
      ver&auml;ndert und m&ouml;chten dies dem Server mitteilen.  Sie
      k&ouml;nnten den Server nat&uuml;rlich stoppen und
      <command>httpd</command> wieder starten.  Die Folge w&auml;re eine
      kurze Zeit, in der der Server nicht erreichbar ist.  Die meisten
      D&auml;monen lesen Ihre Konfigurationsdatei beim Empfang eines
      <literal>SIGHUP</literal> neu ein.  Da es keinen Standard gibt, der
      vorschreibt, wie auf diese Signale zu reagieren ist, lesen
      Sie bitte die Dokumentation zu dem in Frage kommenden D&auml;mon.</para>

    <para>Mit &man.kill.1; k&ouml;nnen Sie, wie unten gezeigt, Signale
      verschicken.</para>

    <procedure>
      <title>Verschicken von Signalen</title>

      <para>Das folgende Beispiel zeigt, wie Sie &man.inetd.8; ein
	Signal schicken.  Die Konfigurationsdatei von
	<command>inetd</command> ist <filename>/etc/inetd.conf</filename>.
	Diese Konfigurationsdatei liest <command>inetd</command> ein,
	wenn er ein <literal>SIGHUP</literal> empf&auml;ngt.</para>

      <step>
	<para>Suchen Sie die Prozess-ID des Prozesses, dem Sie ein Signal
	  schicken wollen.  Benutzen Sie dazu &man.ps.1; und &man.grep.1;.
	  Mit &man.grep.1; k&ouml;nnen Sie in einer Ausgabe nach einem
	  String suchen.  Da &man.inetd.8; unter dem Benutzer
	  <username>root</username> l&auml;uft und Sie das Kommando als
	  normaler Benutzer absetzen, m&uuml;ssen Sie &man.ps.1; mit
	  <option>ax</option> aufrufen:</para>

	<screen>&prompt.user; <userinput>ps -ax | grep inetd</userinput>
  198  ??  IWs    0:00.00 inetd -wW</screen>

	<para>Die Prozess-ID von &man.inetd.8; ist 198.  In einigen
	  F&auml;llen werden Sie auch das <literal>grep inetd</literal>
	  Kommando in der Ausgabe sehen.  Dies hat damit zu tun, wie
	  &man.ps.1; die Liste der laufenden Prozesse untersucht.</para>
      </step>

      <step>
	<para>Senden Sie das Signal mit &man.kill.1;.  Da &man.inetd.8;
	  unter dem Benutzer <username>root</username> l&auml;uft, m&uuml;ssen
	  Sie zuerst mit &man.su.1; <username>root</username> werden:</para>

	<screen>&prompt.user; <userinput>su</userinput>
<prompt>Password:</prompt>
&prompt.root; <userinput>/bin/kill -s HUP 198</userinput></screen>

	<para>&man.kill.1; wird, wie andere Kommandos von &unix; Systemen auch, keine Ausgabe
	  erzeugen, wenn das Kommando erfolgreich war.  Wenn Sie versuchen,
	  einem Prozess, der nicht Ihnen geh&ouml;rt, ein Signal zu
	  senden, dann werden Sie die Meldung
	  <errorname>kill: <replaceable>PID</replaceable>: Operation not
	  permitted</errorname> sehen.  Wenn Sie sich bei der Eingabe der
	  PID vertippen, werden Sie das Signal dem falschen Prozess
	  schicken, was schlecht sein kann.  Wenn Sie Gl&uuml;ck haben,
	  existiert der Prozess nicht und Sie werden mit der Ausgabe
	  <errorname>kill: <replaceable>PID</replaceable>: No such
	  process</errorname> belohnt.</para>

	<note>
	  <title>Warum soll ich <command>/bin/kill</command> benutzen?</title>

	  <para>Viele Shells stellen <command>kill</command> als internes
	    Kommando zur Verf&uuml;gung, das hei&szlig;t die Shell sendet
	    das Signal direkt, anstatt <filename>/bin/kill</filename>
	    zu starten.  Das kann n&uuml;tzlich sein, aber die
	    unterschiedlichen Shells benutzen eine verschiedene Syntax,
	    um die Namen der Signale anzugeben.  Anstatt jede Syntax zu
	    lernen, kann es einfacher sein, <command>/bin/kill
	    <replaceable>...</replaceable></command> direkt aufzurufen.</para>
	</note>
      </step>
    </procedure>

    <para>Andere Signale senden Sie auf die gleiche Weise, ersetzen
      Sie nur <literal>TERM</literal> oder <literal>KILL</literal>
      entsprechend.</para>

    <important>
      <para>Es kann gravierende Auswirkungen haben, wenn Sie zuf&auml;llig
	Prozesse beenden.  Insbesondere &man.init.8; mit der Prozess-ID
	ist ein Spezialfall.  Mit <command>/bin/kill -s KILL 1</command>
	k&ouml;nnen Sie Ihr System schnell herunterfahren.
	&Uuml;berpr&uuml;fen Sie die Argumente von &man.kill.1;
	<emphasis>immer</emphasis> zweimal <emphasis>bevor</emphasis>
	Sie <keycap>Return</keycap> dr&uuml;cken.</para>
    </important>
  </sect1>

  <sect1 id="shells">
    <title>Shells</title>
    <indexterm><primary>Shells</primary></indexterm>
    <indexterm><primary>Kommandozeile</primary></indexterm>

    <para>Von der tagt&auml;glichen Arbeit mit FreeBSD wird eine Menge
      mit der Kommandozeilen Schnittstelle der Shell erledigt.  Die
      Hauptaufgabe einer Shell besteht darin, Kommandos der Eingabe
      anzunehmen und diese auszuf&uuml;hren.  Viele Shells haben
      au&szlig;erdem eingebaute Funktionen, die die t&auml;gliche
      Arbeit erleichtern, beispielsweise eine Dateiverwaltung,
      die Vervollst&auml;ndigung  von Dateinamen (Globbing), einen
      Kommandozeileneditor, sowie Makros und Umgebungsvariablen.  FreeBSD
      enth&auml;lt die Shells <command>sh</command> (die Bourne Shell) und
      <command>tcsh</command> (die verbesserte C-Shell) im Basissystem.
      Viele andere Shells, wie <command>zsh</command> oder
      <command>bash</command>, befinden sich in der Ports-Sammlung.</para>

    <para>Welche Shell soll ich benutzen?  Das ist wirklich eine
      Geschmacksfrage.  Sind Sie ein C-Programmierer, finden Sie
      vielleicht eine C-artige Shell wie die <command>tcsh</command>
      angenehmer.  Kommen Sie von Linux oder ist Ihnen der Umgang mit &unix; Systemen
      neu, so k&ouml;nnten Sie die <command>bash</command> probieren.
      Der Punkt ist, dass
      jede Shell ihre speziellen Eigenschaften hat, die mit Ihrer
      bevorzugten Arbeitsumgebung harmonieren k&ouml;nnen oder nicht.
      Sie m&uuml;ssen sich eine Shell aussuchen.</para>

    <para>Ein verbreitetes Merkmal in Shells ist die
      Dateinamen-Vervollst&auml;ndigung.  Sie m&uuml;ssen nur einige
      Buchstaben eines Kommandos oder eines Dateinamen eingeben und
      die Shell vervollst&auml;ndigt den Rest automatisch durch
      dr&uuml;cken der <keycap>Tab</keycap>-Taste.  Hier ist ein Beispiel.
      Angenommen, Sie
      haben zwei Dateien <filename>foobar</filename> und
      <filename>foo.bar</filename>.  Die Datei
      <filename>foo.bar</filename> m&ouml;chten Sie l&ouml;schen.  Nun
      w&uuml;rden Sie an der Tastatur eingeben:
      <command>rm fo[<keycap>Tab</keycap>].
      [<keycap>Tab</keycap>]</command>.</para>

    <para>Die Shell w&uuml;rde dann <command>rm
      foo[BEEP].bar</command> ausgeben.</para>

    <para>[BEEP] meint den Rechner-Piepser.  Diesen gibt die Shell
      aus, um anzuzeigen, dass es den Dateinamen nicht
      vervollst&auml;ndigen konnte, da es mehrere M&ouml;glichkeiten
      gibt.  Beide Dateien <filename>foobar</filename> und
      <filename>foo.bar</filename> beginnen mit <literal>fo</literal>,
      so konnte nur bis <literal>foo</literal> erg&auml;nzt werden.
      Nachdem Sie <literal>.</literal> eingaben und dann die
      <keycap>Tab</keycap>-Taste
      dr&uuml;ckten, konnte die Shell den Rest f&uuml;r Sie
      ausf&uuml;llen.</para>

    <indexterm><primary>Umgebungsvariablen</primary></indexterm>

    <para>Ein weiteres Merkmal der Shell ist der Gebrauch von
      Umgebungsvariablen.  Dies sind ver&auml;nderbare Schl&uuml;sselpaare
      im Umgebungsraum der Shell, die jedes von der Shell aufgerufene
      Programm lesen kann.  Daher enth&auml;lt der Umgebungsraum viele
      Konfigurationsdaten f&uuml;r Programme.  Die folgende Liste zeigt
      verbreitete Umgebungsvariablen und was sie bedeuten:</para>

    <indexterm><primary>Umgebungsvariablen</primary></indexterm>
    <informaltable frame="none">
      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>Variable</entry>
	    <entry>Beschreibung</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry><envar>USER</envar></entry>
	    <entry>Name des angemeldeten Benutzers.</entry>
	  </row>

	  <row>
	    <entry><envar>PATH</envar></entry>
	    <entry>Liste mit Verzeichnissen (getrennt durch Doppelpunkt)
              zum Suchen nach Programmen.</entry>
	  </row>

	  <row>
	    <entry><envar>DISPLAY</envar></entry>
	    <entry>Wenn gesetzt der Netzwerkname des X11 Bildschirms
              f&uuml;r die Anzeige.</entry>
	  </row>

	  <row>
	    <entry><envar>SHELL</envar></entry>
	    <entry>Die aktuelle Shell.</entry>
	  </row>

	  <row>
	    <entry><envar>TERM</envar></entry>
	    <entry>Name des Terminals des Benutzers.  Benutzt, um die
              F&auml;higkeiten des Terminals bestimmen.</entry>
	  </row>

	  <row>
	    <entry><envar>TERMCAP</envar></entry>
	    <entry>Datenbankeintrag der Terminal Escape Codes,
              ben&ouml;tigt um verschieden Terminalfunktionen
              auszuf&uuml;hren.</entry>
	  </row>

	  <row>
	    <entry><envar>OSTYPE</envar></entry>
	    <entry>Typ des Betriebsystems, beispielsweise FreeBSD.</entry>
	  </row>

	  <row>
	    <entry><envar>MACHTYPE</envar></entry>
	    <entry>Die CPU Architektur auf dem das System
              l&auml;uft.</entry>
	  </row>

	  <row>
	    <entry><envar>EDITOR</envar></entry>
	    <entry>Vom Benutzer bevorzugter Text-Editor.</entry>
	  </row>

	  <row>
	    <entry><envar>PAGER</envar></entry>
	    <entry>Vom Benutzer bevorzugter Text-Betrachter.</entry>
	  </row>

	  <row>
	    <entry><envar>MANPATH</envar></entry>
	    <entry>Liste mit Verzeichnissen (getrennt durch Doppelpunkt)
              zum Suchen nach Manualpages.</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <indexterm>
      <primary>Shells</primary>
      <secondary>Bourne Shell</secondary>
    </indexterm>
    <para>Das Setzen von Umgebungsvariablen funktioniert
      von Shell zu Shell unterschiedlich.  Zum Beispiel benutzt man
      in C-artigen Shells wie der <command>tcsh</command> dazu
      <command>setenv</command>.  Unter Bourne-Shells wie <command>sh</command>
      oder <command>bash</command> benutzen Sie zum Setzen von
      Umgebungsvariablen <command>export</command>.  Um
      beispielsweise die Variable <envar>EDITOR</envar> mit
      <command>csh</command> oder <command>tcsh</command> auf
      <filename>/usr/local/bin/emacs</filename> zu setzen, setzen Sie das
      folgende Kommando ab:</para>

    <screen>&prompt.user; <userinput>setenv EDITOR /usr/local/bin/emacs</userinput></screen>

    <para>Unter Bourne-Shells:</para>

    <screen>&prompt.user; <userinput>export EDITOR="/usr/local/bin/emacs"</userinput></screen>

    <para>Sie k&ouml;nnen die meisten Shells Umgebungsvariablen
      expandieren lassen, in dem Sie in der Kommandozeile ein
      <literal>$</literal> davor eingeben.  Zum Beispiel gibt
      <command>echo $TERM</command> aus, worauf <envar>$TERM</envar>
      gesetzt ist, weil die Shell <envar>$TERM</envar> expandiert
      und das Ergebnis an <command>echo</command> gibt.</para>

    <para>Shells behandeln viele Spezialzeichen, so genannte
      Metazeichen, als besondere Darstellungen f&uuml;r Daten.
      Das allgemeinste ist das Zeichen <literal>*</literal>, das eine
      beliebige Anzahl Zeichen in einem Dateinamen repr&auml;sentiert.
      Diese Metazeichen k&ouml;nnen zum Vervollst&auml;ndigen von
      Dateinamen (Globbing) benutzt werden.  Beispielsweise liefert
      das Kommando <command>echo *</command> nahezu das gleiche
      wie die Eingabe von <command>ls</command>, da die Shell alle
      Dateinamen die mit <literal>*</literal> &uuml;bereinstimmen, an
      <command>echo</command> weitergibt.</para>

    <para>Um zu verhindern, dass die Shell diese Sonderzeichen
      interpretiert, kann man sie sch&uuml;tzen, indem man ihnen einen
      Backslash (<literal>\</literal>) voranstellt.  <command>echo
      $TERM</command> gibt aus, auf was auch immer Ihr Terminal
      gesetzt ist.  <command>echo \$TERM</command> gibt
      <envar>$TERM</envar> genauso aus, wie es hier steht.</para>

    <sect2 id="changing-shells">
      <title>&Auml;ndern der Shell</title>

      <para>Der einfachste Weg Ihre Shell zu &auml;ndern, ist das
        Kommando <command>chsh</command> zu benutzen.
        <command>chsh</command> platziert Sie im Editor, welcher durch
        Ihre Umgebungsvariable <envar>EDITOR</envar> gesetzt ist,
        im <command>vi</command> wenn die Variable nicht gesetzt ist.
        &Auml;ndern Sie die Zeile mit <quote>Shell:</quote>
        entsprechend Ihren W&uuml;nschen.</para>

      <para>Sie k&ouml;nnen auch <command>chsh</command> mit der Option
	<option>-s</option> aufrufen, dann wird Ihre Shell gesetzt,
        ohne dass Sie in einen Editor gelangen.  Um Ihre Shell
        zum Beispiel auf die <command>bash</command> zu &auml;ndern,
	geben Sie das folgende Kommando ein:</para>

      <screen>&prompt.user; <userinput>chsh -s /usr/local/bin/bash</userinput></screen>

      <para>Dasselbe Ergebnis h&auml;tten Sie erzielt, wenn Sie einfach
        <command>chsh</command> ohne Optionen aufgerufen und die
	entsprechende Zeile editiert h&auml;tten.</para>

      <note>
	<para>Die von Ihnen gew&uuml;nschte Shell
          <emphasis>muss</emphasis> in <filename>/etc/shells</filename>
          aufgef&uuml;hrt sein.  Haben Sie eine Shell aus der
	  <link linkend="ports">Ports Sammlung</link> installiert,
          sollte das schon automatisch erledigt werden.  Installierten
          Sie die Shell von Hand, so m&uuml;ssen Sie sie dort
          eintragen.</para>

      <para>Haben Sie beispielsweise die <command>bash</command> nach
	<filename>/usr/local/bin</filename> installiert, wollen Sie
        dies tun:</para>

      <screen>&prompt.root; <userinput>echo &quot;/usr/local/bin/bash&quot; &gt;&gt; /etc/shells</userinput></screen>

       <para>Danach k&ouml;nnen Sie <command>chsh</command> aufrufen.</para>
     </note>
   </sect2>
  </sect1>

  <sect1 id="editors">
    <title>Text-Editoren</title>
    <indexterm><primary>Text Editoren</primary></indexterm>
    <indexterm><primary>Editoren</primary></indexterm>

    <para>Eine Menge der Konfiguration wird bei FreeBSD durch
      das Editieren von Textdateien erledigt.  Deshalb ist es eine
      gute Idee, mit einem Texteditor vertraut zu werden.  FreeBSD hat
      ein paar davon im Basissystem und sehr viel mehr in der
      Ports-Sammlung.</para>

    <indexterm>
      <primary><command>ee</command></primary>
    </indexterm>
    <para>Der am leichtesten und einfachsten zu erlernende Editor nennt
      sich <application>ee</application>, was f&uuml;r
      <foreignphrase>easy editor</foreignphrase> steht.
      Um <application>ee</application> zu starten, gibt man in der
      Kommandozeile <command>ee filename</command> ein, worin
      <replaceable>filename</replaceable> der Name der zu editierenden Datei
      ist.  Um zum Beispiel <filename>/etc/rc.conf</filename> zu
      editieren, tippen Sie <command>ee /etc/rc.conf</command>.
      Einmal im Editor, finden Sie alle Editor-Funktionen oben im
      Display aufgelistet.  Das Einschaltungszeichen
      <literal>^</literal> steht f&uuml;r die <keycap>Ctrl</keycap> (oder
      <keycap>Strg</keycap>) Taste, mit <literal>^e</literal> ist also die
      Tastenkombination <keycombo
        action="simul"><keycap>Ctrl</keycap><keycap>e</keycap></keycombo>
      gemeint.  Um <application>ee</application> zu verlassen, dr&uuml;cken
      Sie <keycap>Esc</keycap> und w&auml;hlen dann <option>leave
        editor</option> aus.  Der Editor fragt nach, ob Sie speichern
      m&ouml;chten, wenn die Datei ver&auml;ndert wurde.</para>

    <indexterm>
      <primary><command>vi</command></primary>
    </indexterm>
    <indexterm>
      <primary>Text Editoren</primary>
      <secondary><command>vi</command></secondary>
    </indexterm>
    <indexterm>
      <primary><command>emacs</command></primary>
    </indexterm>
    <indexterm>
      <primary>Text Editoren</primary>
      <secondary><command>emacs</command></secondary>
    </indexterm>
    <para>FreeBSD verf&uuml;gt &uuml;ber leistungsf&auml;higere
      Editoren wie <command>vi</command> als Teil des
      Basissystems, andere Editoren wie <command>emacs</command> oder
      <command>vim</command> sind Teil der Ports Sammlung.
      Diese Editoren bieten h&ouml;here Funktionalit&auml;t und
      Leistungsf&auml;higkeit jedoch auf Kosten einer etwas
      schwierigeren Erlernbarkeit.  Wenn Sie viel
      Textdateien editieren werden, sparen Sie auf lange Sicht mehr
      Zeit durch das Erlernen von Editoren wie
      <application>vim</application> oder
      <application>emacs</application> ein.</para>
  </sect1>

  <sect1 id="basics-devices">
    <title>Ger&auml;te und Ger&auml;tedateien</title>

    <para>Der Begriff Ger&auml;t wird meist in Verbindung mit Hardware
      wie Laufwerken, Druckern, Grafikkarten oder Tastaturen gebraucht.
      Der Gro&szlig;teil der Meldungen, die beim Booten von FreeBSD angezeigt
      werden, beziehen sich auf gefundene Ger&auml;te.  Sie k&ouml;nnen sich
      die Bootmeldungen sp&auml;ter in <filename>/var/run/dmesg.boot</filename>
      ansehen.</para>

    <para>Ger&auml;tenamen, die Sie wahrscheinlich in den Bootmeldungen sehen
      werden, sind zum Beispiel <devicename>acd0</devicename>, das erste
      IDE CD-ROM oder <devicename>kbd0</devicename>, die Tastatur.</para>

    <para>Auf die meisten Ger&auml;te wird unter &unix; Systemen &uuml;ber spezielle
      Ger&auml;tedateien im <filename>/dev</filename> Verzeichnis
      zugegriffen.</para>

    <sect2>
      <title>Anlegen von Ger&auml;tedateien</title>
      <para>Wenn sie ein neues Ger&auml;t zu Ihrem System hinzuf&uuml;gen,
	oder die Unterst&uuml;tzung f&uuml;r zus&auml;tzliche Ger&auml;te
	kompilieren, m&uuml;ssen oft ein oder mehrere Ger&auml;tedateien
	erstellt werden.</para>

      <sect3>
	<title>MAKEDEV Skript</title>
	<para>Auf Systemen ohne <literal>DEVFS</literal> (das sind alle
	  Systeme vor FreeBSD&nbsp;5.0) m&uuml;ssen Ger&auml;tedateien mit
	  &man.MAKEDEV.8; wie unten gezeigt angelegt werden:</para>

	<screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>sh MAKEDEV ad1</userinput>
	</screen>

	<para>Im Beispiel werden alle Ger&auml;tedateien f&uuml;r das
	  zweite IDE Laufwerk angelegt.</para>
      </sect3>

      <sect3>
	<title><literal>DEVFS</literal> (Ger&auml;tedateisystem)</title>

	<para>Das Ger&auml;tedateisystem <literal>DEVFS</literal>
	  erm&ouml;glicht durch den
	  Namensraum des Dateisystems Zugriff auf den Namensraum der
	  Ger&auml;te im Kernel.  Damit m&uuml;ssen Ger&auml;tedateien
	  nicht mehr extra angelegt werden, sondern werden von
	  <literal>DEVFS</literal> verwaltet.</para>

	<para>Weitere Informationen finden Sie in &man.devfs.5;.</para>

	<para><literal>DEVFS</literal> ist ab &os;&nbsp;5.0
	  in der Grundeinstellung aktiviert.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="binary-formats">
    <title>Bin&auml;rformate</title>

    <para>Um zu verstehen, warum &os; das Format
      &man.elf.5; benutzt, m&uuml;ssen Sie
      zun&auml;chst etwas &uuml;ber die drei gegenw&auml;rtig
      <quote>dominanten</quote> ausf&uuml;hrbaren Formate
      f&uuml;r &unix; Systeme wissen:</para>

    <itemizedlist>
      <listitem>
        <para>&man.a.out.5;</para>

        <para>Das &auml;lteste und <quote>klassische</quote>
          Objektformat von &unix; Systemen.  Es benutzt einen kurzen,
	  kompakten Header mit einer magischen Nummer am Anfang, die oft
          benutzt wird, um das Format zu charakterisieren
          (weitere Details finden Sie unter &man.a.out.5;).  Es
          enth&auml;lt drei geladene Segmente: .text, .data und
          .bss, sowie eine Symboltabelle und eine
          Stringtabelle.</para>
      </listitem>

      <listitem>
        <para><acronym>COFF</acronym></para>

        <para>Das Objektformat von SVR3.  Der Header
          enth&auml;lt nun eine <quote>Sectiontable</quote>.  Man kann
          also mit mehr als nur den Sections .text, .data und .bss
          arbeiten.</para>
      </listitem>

      <listitem>
        <para>&man.elf.5;</para>

        <para>Der Nachfolger von <acronym>COFF</acronym>.
          Kennzeichnend sind mehrere Sections und m&ouml;gliche
          32-Bit- oder 64-Bit-Werte.  Ein wesentlicher Nachteil:
          <acronym>ELF</acronym> wurde auch unter der Annahme
          entworfen, dass es nur eine ABI (Application
          Binary Interface) pro Systemarchitektur geben wird.
          Tats&auml;chlich ist diese Annahme falsch &ndash; nicht
          einmal f&uuml;r die kommerzielle SYSV-Welt (in der es
          mindestens drei ABIs gibt: SVR4, Solaris, SCO) trifft
          sie zu.</para>

        <para>FreeBSD versucht, dieses Problem zu umgehen, indem
          ein Werkzeug bereitgestellt wird, um ausf&uuml;hrbare
          Dateien im <acronym>ELF</acronym>-Format mit
          Informationen &uuml;ber die ABI zu versehen, zu der
          sie passen.  Weitere Informationen finden Sie in der
          Manualpage &man.brandelf.1;.</para>
      </listitem>
    </itemizedlist>

    <para>FreeBSD kommt aus dem <quote>klassischen</quote> Lager
      und verwendete traditionell das Format &man.a.out.5;, eine
      Technik, die bereits &uuml;ber viele BSD-Releases
      hinweg eingesetzt und gepr&uuml;ft worden ist.  Obwohl es
      bereits seit einiger Zeit m&ouml;glich war, auf einem
      FreeBSD-System auch Binaries (und Kernel) im
      <acronym>ELF</acronym>-Format zu erstellen und
      auszuf&uuml;hren, widersetzte FreeBSD sich anfangs dem
      <quote>Druck</quote>, auf <acronym>ELF</acronym> als
      Standardformat umzusteigen.  Warum?  Nun, als das
      Linux-Lager die schmerzhafte Umstellung auf
      <acronym>ELF</acronym> durchf&uuml;hrte, ging es nicht so
      sehr darum, dem ausf&uuml;hrbaren Format
      <filename>a.out</filename> zu entkommen, als dem
      unflexiblen, auf Sprungtabellen basierten Mechanismus
      f&uuml;r <quote>Shared-Libraries</quote> der die Konstruktion von
      Shared-Libraries f&uuml;r Hersteller und Entwickler
      gleicherma&szlig;en sehr kompliziert machte.  Da die
      verf&uuml;gbaren <acronym>ELF</acronym>-Werkzeuge eine
      L&ouml;sung f&uuml;r das Problem mit den Shared-Libraries
      anboten und ohnehin generell als <quote>ein Schritt
      vorw&auml;rts</quote> angesehen wurden, wurde der Aufwand
      f&uuml;r die Umstellung als notwendig akzeptiert und die
      Umstellung wurde durchgef&uuml;hrt.  Unter FreeBSD ist der
      Mechanismus von Shared-Libraries enger an den Stil des
      Shared-Library-Mechanismus von Suns &sunos;
      angelehnt und von daher sehr einfach zu verwenden.</para>

    <para>Ja, aber warum gibt es so viele unterschiedliche Formate?</para>


    <para>In alter, grauer Vorzeit gab es simple Hardware.
      Diese simple Hardware unterst&uuml;tzte ein einfaches,
      kleines System.  <filename>a.out</filename> war absolut passend
      f&uuml;r die Aufgabe, Binaries auf diesem simplen System (eine PDP-11)
      darzustellen.  Als &unix; von diesem simplen System portiert
      wurde, wurde auch das <filename>a.out</filename>-Format beibehalten,
      weil es f&uuml;r die fr&uuml;hen Portierungen auf Architekturen
      wie den Motorola 68000 und VAX ausreichte.</para>

    <para>Dann dachte sich ein schlauer Hardware-Ingenieur,
      dass, wenn er Software zwingen k&ouml;nnte, einige
      Tricks anzustellen, es ihm m&ouml;glich w&auml;re, ein
      paar Gatter im Design zu sparen, und seinen CPU-Kern
      schneller zu machen.  Obgleich es dazu gebracht wurde, mit
      dieser neuen Art von Hardware (heute als <acronym>RISC</acronym>
      bekannt) zu arbeiten, war <filename>a.out</filename> f&uuml;r
      diese Hardware schlecht geeignet.  Deshalb wurden viele neue
      Formate entwickelt, um eine bessere Leistung auf dieser
      Hardware zu erreichen, als mit dem begrenzten, simplen
      <filename>a.out</filename>-Format.  Dinge wie
      <acronym>COFF</acronym>, <acronym>ECOFF</acronym> und
      einige andere obskure wurden erdacht und ihre Grenzen
      untersucht, bevor die Dinge sich in Richtung
      <acronym>ELF</acronym> entwickelten.</para>

    <para>Hinzu kam, dass die Gr&ouml;&szlig;e von
      Programmen gewaltig wurde und Festplatten sowie
      physikalischer Speicher immer noch relativ klein waren.
      Also wurde das Konzept von Shared-Libraries geboren.  Das
      VM-System wurde auch immer fortgeschrittener.  Obwohl bei
      jedem dieser Fortschritte das
      <filename>a.out</filename>-Format benutzt worden ist,
      wurde sein Nutzen mit jedem neuen Merkmal mehr und mehr
      gedehnt.  Zus&auml;tzlich wollte man Dinge dynamisch zur
      Ausf&uuml;hrungszeit laden, oder Teile ihres Programms
      nach der Initialisierung wegwerfen, um Hauptspeicher
      oder Swap-Speicher zu sparen.  Programmiersprachen
      wurden immer fortschrittlicher und man wollte, dass
      Code automatisch vor der main-Funktion aufgerufen wird.
      Das <filename>a.out</filename>-Format wurde oft
      &uuml;berarbeitet, um alle diese Dinge zu erm&ouml;glichen
      und sie funktionierten auch f&uuml;r einige Zeit.
      <filename>a.out</filename> konnte diese Probleme nicht
      ohne ein st&auml;ndiges Ansteigen eines Overheads im Code
      und in der Komplexit&auml;t handhaben.  Obwohl
      <acronym>ELF</acronym> viele dieser Probleme l&ouml;ste,
      w&auml;re es sehr aufw&auml;ndig, ein System umzustellen, das
      im Grunde genommen funktionierte.  Also musste
      <acronym>ELF</acronym> warten, bis es aufw&auml;ndiger war, bei
      <filename>a.out</filename> zu bleiben, als zu
      <acronym>ELF</acronym> &uuml;berzugehen.</para>

    <para>Im Laufe der Zeit haben sich die Erstellungswerkzeuge,
      von denen FreeBSD seine Erstellungswerkzeuge abgeleitet
      hat (speziell der Assembler und der Loader), in zwei
      parallele Zweige entwickelt.  Im FreeBSD-Zweig wurden
      Shared-Libraries hinzugef&uuml;gt und einige Fehler
      behoben.  Das GNU-Team, das diese Programme
      urspr&uuml;nglich geschrieben hat, hat sie umgeschrieben
      und eine simplere Unterst&uuml;tzung zur Erstellung von
      Cross-Compilern durch beliebiges Einschalten verschiedener
      Formate usw. hinzugef&uuml;gt.  Viele Leute wollten
      Cross-Compiler f&uuml;r FreeBSD erstellen, aber sie hatten
      kein Gl&uuml;ck, denn FreeBSD's &auml;ltere Sourcen
      f&uuml;r <application>as</application> und <application>ld</application>
      waren hierzu nicht geeignet.  Die neuen
      GNU-Werkzeuge (<application>binutils</application>) unterst&uuml;tzen
      Cross-Compilierung, <acronym>ELF</acronym>, Shared-Libraries,
      C++-Erweiterungen und mehr.  Weiterhin geben viele
      Hersteller <acronym>ELF</acronym>-Binaries heraus und es
      ist gut, wenn FreeBSD sie ausf&uuml;hren kann.</para>

    <para><acronym>ELF</acronym> ist ausdrucksf&auml;higer als
      <filename>a.out</filename> und gestattet eine bessere Erweiterbarkeit
      des Basissystems.  Die <acronym>ELF</acronym>-Werkzeuge werden
      besser gewartet und bieten Unterst&uuml;tzung von
      Cross-Compilierung, was f&uuml;r viele Leute wichtig ist.
      <acronym>ELF</acronym> mag etwas langsamer sein, als
      <filename>a.out</filename>, aber zu versuchen, das zu messen,
      k&ouml;nnte schwierig werden.  Es gibt unz&auml;hlige Details, in
      denen sich die beiden Formate unterscheiden, wie sie Pages
      abbilden, Initialisierungscode handhaben usw.  Keins davon
      ist sehr wichtig, aber es sind Unterschiede.  Irgendwann
      wird die Unterst&uuml;tzung f&uuml;r Programme im
      <filename>a.out</filename>-Format aus dem
      <filename>GENERIC</filename>-Kernel entfernt werden.
      Wenn es dann keinen oder kaum noch
      Bedarf f&uuml;r die Unterst&uuml;tzung dieses Formates
      gibt, werden die entsprechenden Routinen ganz entfernt
      werden.</para>
  </sect1>

  <sect1 id="basics-more-information">
    <title>Weitere Informationen</title>

    <sect2 id="basics-man">
      <title>Manualpages</title>
      <indexterm><primary>Manualpages</primary></indexterm>

      <para>Die umfassendste Dokumentation rund um FreeBSD gibt es in
        Form von Manualpages.  Ann&auml;hernd jedes Programm im System
        bringt eine kurze Referenzdokumentation mit, die die
        grunds&auml;tzliche Funktion und verschiedene Parameter
        erkl&auml;rt.  Diese Dokumentationen kann man mit dem
        <command>man</command> Kommando benutzen.  Die Benutzung des
        <command>man</command> Kommandos ist einfach:</para>

      <screen>&prompt.user; <userinput>man <replaceable>Kommando</replaceable></userinput></screen>

      <para><literal>Kommando</literal> ist der Name des Kommandos,
        &uuml;ber das Sie etwas erfahren wollen.  Um beispielsweise
        mehr &uuml;ber das Kommando <command>ls</command> zu lernen,
        geben Sie ein:</para>

      <screen>&prompt.user; <userinput>man ls</userinput></screen>

      <para>Die Online-Dokumentation ist in nummerierte Sektionen
        unterteilt:</para>

      <orderedlist>
	<listitem>
	  <para>Benutzerkommandos.</para>
	</listitem>

	<listitem>
	  <para>Systemaufrufe und Fehlernummern.</para>
	</listitem>

	<listitem>
	  <para>Funktionen der C Bibliothek.</para>
	</listitem>

	<listitem>
	  <para>Ger&auml;tetreiber.</para>
	</listitem>

	<listitem>
	  <para>Dateiformate.</para>
	</listitem>

	<listitem>
	  <para>Spiele und andere Unterhaltung.</para>
	</listitem>

	<listitem>
	  <para>Verschiedene Informationen.</para>
	</listitem>

	<listitem>
	  <para>Systemverwaltung und -Kommandos.</para>
	</listitem>

	<listitem>
	  <para>Kernel Entwickler.</para>
	</listitem>
      </orderedlist>

      <para>In einigen F&auml;llen kann dasselbe Thema in mehreren
        Sektionen auftauchen.  Es gibt zum Beispiel ein <command>chmod</command>
        Benutzerkommando und einen <function>chmod()</function>
        Systemaufruf.  In diesem Fall k&ouml;nnen Sie dem
	<command>man</command> Kommando
        sagen, aus welcher Sektion Sie die Information erhalten
        m&ouml;chten, indem Sie die Sektion mit angeben:</para>

      <screen>&prompt.user; <userinput>man 1 chmod</userinput></screen>

      <para>Dies wird Ihnen die Manualpage f&uuml;r das Benutzerkommando
        <command>chmod</command> zeigen.  Verweise auf eine Sektion
        der Manualpages werden traditionell in Klammern
        gesetzt.  So bezieht sich &man.chmod.1; auf das
        Benutzerkommando <command>chmod</command> und mit
        &man.chmod.2; ist der Systemaufruf gemeint.</para>

      <para>Das ist nett, wenn Sie den Namen eines Kommandos wissen,
        und lediglich wissen wollen, wie es zu benutzen ist.  Aber was
        tun Sie, wenn Sie Sich nicht an den Namen des Kommandos
        erinnern k&ouml;nnen?  Sie k&ouml;nnen mit <command>man</command>
	nach Schl&uuml;sselbegriffen in den
	Kommandobeschreibungen zu suchen, indem Sie den Parameter
	<option>-k</option> benutzen:</para>

      <screen>&prompt.user; <userinput>man -k mail</userinput></screen>

      <para>Mit diesem Kommando bekommen Sie eine Liste der
        Kommandos, deren Beschreibung das Schl&uuml;sselwort
        <quote>mail</quote> enth&auml;lt.  Diese Funktionalit&auml;t
        erhalten Sie auch, wenn Sie das Kommando <command>apropos</command>
        benutzen.</para>

      <para>Nun, Sie schauen Sich alle die geheimnisvollen Kommandos
        in <filename>/usr/bin</filename> an, haben aber nicht den
        blassesten Schimmer, wozu die meisten davon gut sind?  Dann
        rufen Sie doch einfach das folgende Kommando auf:</para>
        <screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>man -f *</userinput></screen>

      <para>Dasselbe erreichen Sie durch Eingabe von:</para>

      <screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>whatis *</userinput></screen>

    </sect2>

    <sect2 id="basics-info">
      <title>GNU Info Dateien</title>

      <para>FreeBSD enth&auml;lt viele Anwendungen und Utilities
        der Free Software Foundation (FSF).  Zus&auml;tzlich zu den
        Manualpages bringen diese Programme ausf&uuml;hrlichere
        Hypertext-Dokumente (<literal>info</literal> genannt) mit,
        welche man sich mit dem Kommando <command>info</command>
        ansehen kann.  Wenn Sie <application>emacs</application>
        installiert haben, k&ouml;nnen Sie auch dessen info-Modus
        benutzen.</para>

      <para>Um das Kommando &man.info.1; zu benutzen, geben Sie
        einfach ein:</para>

      <screen>&prompt.user; <userinput>info</userinput></screen>

      <para>Eine kurze Einf&uuml;hrung gibt es mit
        <literal>h</literal>; eine Befehlsreferenz erhalten Sie durch
        Eingabe von: <literal>?</literal>.</para>
    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
