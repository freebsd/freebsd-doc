<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde: de-docproj/books/handbook/users/chapter.sgml,v 1.47 2012/04/30 16:19:09 bcr Exp $
     basiert auf: 1.63
-->

<chapter id="users">
  <chapterinfo>
    <authorgroup>
      <author>
        <firstname>Neil</firstname>
	<surname>Blakey-Milner</surname>
	<contrib>Beigetragen von </contrib>
      </author>
    </authorgroup>
    <!-- Feb 2000 -->
    <authorgroup>
      <author>
        <firstname>Robert</firstname>
	<surname>Drehmel</surname>
	<contrib>&Uuml;bersetzt von </contrib>
      </author>
    </authorgroup>
    <!-- Jul 2000 -->
  </chapterinfo>

  <title>Benutzer und grundlegende Account-Verwaltung</title>

  <sect1 id="users-synopsis">
    <title>&Uuml;bersicht</title>

    <para>Einen FreeBSD-Computer k&ouml;nnen mehrere Benutzer zur selben
      Zeit benutzen, allerdings kann immer nur einer vor der Konsole sitzen
      <footnote>
	<para>Au&szlig;er Sie verwenden, wie in <xref
	linkend="serialcomms"> besprochen,  zus&auml;tzliche Terminals</para>
      </footnote>, &uuml;ber das Netzwerk k&ouml;nnen beliebig viele
      Benutzer angemeldet sein.  Jeder Benutzer muss einen Account
      haben, um das System benutzen zu k&ouml;nnen.</para>

    <para>Nachdem Sie dieses Kapitel gelesen haben, werden Sie</para>

    <itemizedlist>
      <listitem>
	<para>die verschiedenen Account-Typen von FreeBSD kennen,</para>
      </listitem>

      <listitem>
	<para>wissen, wie Accounts angelegt werden,</para>
      </listitem>

      <listitem>
	<para>wissen, wie Sie Accounts l&ouml;schen,</para>
      </listitem>

      <listitem>
	<para>wie Sie Attribute eines Accounts, wie den Loginnamen oder
	  die Login-Shell &auml;ndern,</para>
      </listitem>

      <listitem>
	<para>wissen, wie Sie Limits f&uuml;r einen Account setzen, um
	  beispielsweise Ressourcen, wie Speicher oder CPU-Zeit,
	  einzuschr&auml;nken,</para>
      </listitem>

      <listitem>
	<para>wie Sie mit Gruppen die Verwaltung der Accounts
	  vereinfachen.</para>
      </listitem>
    </itemizedlist>

    <para>Vor dem Lesen dieses Kapitels sollten Sie</para>

    <itemizedlist>
      <listitem>
	<para>die Grundlagen von &unix; und FreeBSD (<xref linkend="basics">)
	  verstanden haben.</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="users-introduction">
    <title>Einf&uuml;hrung</title>

    <para>Jeder Zugriff auf das System geschieht &uuml;ber Accounts und alle
      Prozesse werden von Benutzern gestartet, also sind Benutzer- und
      Account-Verwaltung von wesentlicher Bedeutung in FreeBSD-Systemen.</para>

    <para>Mit jedem Account eines FreeBSD-Systems sind bestimmte Informationen
      verkn&uuml;pft, die diesen Account identifizieren.</para>

    <variablelist>
      <varlistentry>
	<term>Loginnamen</term>

	<listitem>
	  <para>Den Loginnamen geben Sie bei der Anmeldung ein, wenn Sie
	    dazu mit <prompt>login:</prompt> aufgefordert werden.
	    Loginnamen m&uuml;ssen auf dem System eindeutig sein, das
	    hei&szlig;t auf einem System kann es nicht zwei Accounts mit
	    demselben Loginnamen geben.  In &man.passwd.5; wird
	    beschrieben, wie ein g&uuml;ltiger Loginname gebildet wird.
	    Normalerweise sollten Sie Namen verwenden, die aus
	    Kleinbuchstaben bestehen und bis zu acht Zeichen lang sind.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>Passwort</term>

	<listitem>
	  <para>Mit jedem Account ist ein Passwort verkn&uuml;pft.  Wenn
	    das Passwort leer ist, wird es bei der Anmeldung nicht
	    abgefragt.  Das ist allerdings nicht zu empfehlen, daher sollte
	    jeder Account ein Passwort besitzen.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>User ID (UID)</term>

	<listitem>
	  <para>Die UID ist &uuml;blicherweise eine Zahl zwischen
	    0 und 65535<footnote id="users-largeuidgid">
	      <para>F&uuml;r UIDs und GIDs k&ouml;nnen Zahlen bis
		einschlie&szlig;lich 4294967295 verwendet werden.
		Allerdings k&ouml;nnen solche IDs erhebliche
		Probleme mit Anwendungen verursachen, die
		Annahmen &uuml;ber den Wertebereich der IDs
		treffen.</para>
	    </footnote>, die einen
	    Account eindeutig identifiziert.  Intern verwendet FreeBSD nur
	    die UID, Loginnamen werden zuerst in eine UID umgewandelt,
	    mit der das System dann weiter arbeitet.  Das bedeutet, dass
	    Sie Accounts mit unterschiedlichen Loginnamen aber gleicher
	    UID einrichten k&ouml;nnen.  Vom Standpunkt des Systems handelt
	    es sich dabei um denselben Account.  In der Praxis werden Sie
	    diese Eigenschaft des Systems wahrscheinlich nicht
	    benutzen.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>Group ID (GID)</term>

	<listitem>
	  <para>Die GID ist &uuml;blicherweise eine Zahl zwischen 0 und
	    65536<footnoteref linkend="users-largeuidgid">, die eine Gruppe
	    eindeutig identifiziert.  Mit Gruppen kann der Zugriff auf
	    Ressourcen &uuml;ber die GID anstelle der UID geregelt werden.
	    Einige Konfigurationsdateien werden durch diesen Mechanismus
	    deutlich kleiner.  Ein Account kann mehreren Gruppen
	    zugeh&ouml;ren.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>Login-Klasse</term>

	<listitem>
	  <para>Login-Klassen erweitern das Gruppenkonzept.  Sie
	    erh&ouml;hen die Flexibilit&auml;t des Systems in der Handhabung
	    der verschiedenen Accounts.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>G&uuml;ltigkeit von Passw&ouml;rtern</term>

	<listitem>
	  <para>Ein regelm&auml;&szlig;iges &Auml;ndern des Passworts wird in
	    der Voreinstellung von FreeBSD nicht erzwungen.  Sie
	    k&ouml;nnen allerdings einen Passwortwechsel nach einer
	    gewissen Zeit auf Basis einzelner Accounts erzwingen.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>Verfallszeit eines Accounts</term>

	<listitem>
	  <para>In der Voreinstellung verfallen unter FreeBSD keine
	    Accounts.  Wenn Sie Accounts einrichten, die nur f&uuml;r eine
	    bestimmte Zeit g&uuml;ltig sein sollen, beispielsweise Accounts
	    f&uuml;r Teilnehmer eines Praktikums, k&ouml;nnen Sie angeben,
	    wie lange der Account g&uuml;ltig sein soll.  Nachdem die
	    angegebene Zeitspanne verstrichen ist, kann dieser Account
	    nicht mehr zum Anmelden verwendet werden, obwohl alle
	    Verzeichnisse und Dateien, die diesem Account geh&ouml;ren,
	    noch vorhanden sind.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>vollst&auml;ndiger Benutzername</term>

	<listitem>
	  <para>FreeBSD identifiziert einen Account eindeutig &uuml;ber
	    den Loginnamen, der aber keine &Auml;hnlichkeit mit dem
	    richtigen Namen des Benutzers haben muss.  Der
	    vollst&auml;ndige Benutzername kann daher beim Einrichten eines
	    Accounts angegeben werden.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>Heimatverzeichnis</term>

	<listitem>
	  <para>Das Heimatverzeichnis gibt den vollst&auml;ndigen Pfad zu
	    dem Verzeichnis an, in dem sich der Benutzer nach erfolgreicher
	    Anmeldung befindet.  Es ist &uuml;blich, alle
	    Heimatverzeichnisse unter
	    <filename>/home/<replaceable>Loginname</replaceable></filename>
	    oder
	    <filename>/usr/home/<replaceable>Loginname</replaceable></filename>
	    anzulegen.  Im Heimatverzeichnis oder in dort angelegten
	    Verzeichnissen werden die Dateien eines Benutzers
	    gespeichert.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>Login-Shell</term>

	<listitem>
	  <para>Grunds&auml;tzlich ist die Schnittstelle zum System eine
	    Shell, von denen es viele unterschiedliche gibt.  Die
	    bevorzugte Shell eines Benutzers kann seinem Account zugeordnet
	    werden.</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <para>Es gibt drei Haupttypen von Accounts: Der
      <link linkend="users-superuser">Superuser</link>,
      <link linkend="users-system">Systembenutzer</link> und
      <link linkend="users-user">Benutzer-Accounts</link>.  Der
      Superuser-Account, normalerweise <username>root</username> genannt, wird
      benutzt, um das System ohne Beschr&auml;nkungen auf Privilegien zu
      verwalten.  Systembenutzer starten Dienste.  Abschlie&szlig;end werden
      Benutzer-Accounts von echten Menschen genutzt, die sich einloggen, Mails
      lesen und so weiter.</para>
  </sect1>

  <sect1 id="users-superuser">
    <title>Der Superuser-Account</title>

    <indexterm>
      <primary>Accounts</primary>
      <secondary>Superuser (root)</secondary>
    </indexterm>

    <para>Der Superuser-Account, normalerweise <username>root</username>
      genannt, ist vorkonfiguriert und erleichtert die Systemverwaltung, sollte
      aber nicht f&uuml;r allt&auml;gliche Aufgaben wie das Verschicken und
      Empfangen von Mails, Entdecken des Systems oder Programmierung benutzt
      werden.</para>

    <para>Das ist so, da der Superuser im Gegensatz zu normalen
      Benutzer-Accounts ohne Beschr&auml;nkungen operiert und falsche
      Anwendung des Superuser-Accounts in spektakul&auml;ren Katastrophen
      resultieren kann.  Benutzer-Accounts sind nicht in der Lage, das System
      versehentlich zu zerst&ouml;ren, deswegen ist es generell am besten
      normale Benutzer-Accounts zu verwenden, solange man nicht
      haupts&auml;chlich die extra Privilegien ben&ouml;tigt.</para>

    <para>Kommandos, die Sie als Superuser eingeben, sollten Sie immer
      doppelt und dreifach &uuml;berpr&uuml;fen, da ein
      zus&auml;tzliches Leerzeichen oder ein fehlender Buchstabe irreparablen
      Datenverlust bedeuten kann.</para>

    <para>Das erste, das Sie tun sollten, nachdem Sie dieses Kapitel gelesen
      haben, ist einen unprivilegierten Benutzer f&uuml;r Ihre eigene normale
      Benutzung zu erstellen, wenn Sie das nicht bereits getan haben.  Das
      trifft immer zu, egal ob Sie ein Mehrbenutzersystem oder ein System
      laufen haben, welches Sie alleine benutzen.  Sp&auml;ter in diesem
      Kapitel besprechen wir, wie man zus&auml;tzliche Accounts erstellt und
      wie man zwischen dem normalen Benutzer und dem Superuser wechselt.</para>
  </sect1>

  <sect1 id="users-system">
    <title>System-Accounts</title>

    <indexterm>
      <primary>Accounts</primary>
      <secondary>System-Accounts</secondary>
    </indexterm>

    <para>Systembenutzer starten Dienste wie DNS, Mail-Server, Web-Server und so
      weiter.  Der Grund daf&uuml;r ist die Sicherheit; wenn die Programme
      von dem Superuser gestartet werden, k&ouml;nnen Sie ohne
      Einschr&auml;nkungen handeln.</para>

    <indexterm>
      <primary>Accounts</primary>
      <secondary><username>daemon</username></secondary>
    </indexterm>
    <indexterm>
      <primary>Accounts</primary>
      <secondary><username>operator</username></secondary>
    </indexterm>
    <para>Beispiele von Systembenutzern sind <username>daemon</username>,
      <username>operator</username>, <username>bind</username> (f&uuml;r den
      Domain Name Service) und <username>news</username> und
      <username>www</username>.</para>

    <indexterm>
      <primary>Accounts</primary>
      <secondary><username>nobody</username></secondary>
    </indexterm>
    <para><username>nobody</username> ist der generische unprivilegierte
      Systembenutzer.  Bedenken Sie aber, dass je mehr Dienste
      <username>nobody</username> benutzen, desto mehr Dateien und Prozesse
      diesem Benutzer geh&ouml;ren und dieser Benutzer damit umso
      privilegierter wird.</para>
  </sect1>

  <sect1 id="users-user">
    <title>Benutzer-Accounts</title>

    <indexterm>
      <primary>Accounts</primary>
      <secondary>Benutzer-Accounts</secondary>
    </indexterm>

    <para>Benutzer-Accounts sind das prim&auml;re Mittel des Zugriffs f&uuml;r
      Menschen auf das System und isolieren Benutzer und Umgebung,
      sch&uuml;tzen die Benutzer davor, das System oder Daten anderer Benutzer
      zu besch&auml;digen und erlauben Benutzern ihre Umgebung selbst
      einzurichten, ohne das sich dies auf andere auswirkt.</para>

    <para>Jede Person, die auf Ihr System zugreift, sollte ihren eigenen
      Account besitzen.  Das erlaubt Ihnen herauszufinden, wer was macht
      und h&auml;lt Leute davon ab, die Einstellungen der anderen zu
      ver&auml;ndern oder Mails zu lesen, die nicht f&uuml;r sie bestimmt
      waren.</para>

    <para>Jeder Benutzer kann sich eine eigene Umgebung mit alternativen
      Shells, Editoren, Tastaturbelegungen und Sprachen einrichten.</para>
  </sect1>

  <sect1 id="users-modifying">
    <title>Accounts ver&auml;ndern</title>

    <indexterm>
      <primary>Accounts</primary>
      <secondary>ver&auml;ndern</secondary>
    </indexterm>

    <para>Unter &unix; gibt es verschiedene Kommandos, um Accounts zu
      ver&auml;ndern.  Die gebr&auml;uchlichsten Kommandos sind unten,
      gefolgt von einer detaillierten Beschreibung, zusammengefasst.</para>

    <informaltable frame="none" pgwide="1">
      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>Kommando</entry>
	    <entry>Zusammenfassung</entry>
	  </row>
	</thead>
	<tbody>
	  <row>
	    <entry>&man.adduser.8;</entry>
	    <entry>Das empfohlene Werkzeug, um neue Accounts zu
	      erstellen.</entry>
	  </row>
	  <row>
	    <entry>&man.rmuser.8;</entry>
	    <entry>Das empfohlene Werkzeug, um Accounts zu
	      l&ouml;schen.</entry>
	  </row>
	  <row>
	    <entry>&man.chpass.1;</entry>
	    <entry>Ein flexibles Werkzeug, um Informationen in der
	      Account-Datenbank zu ver&auml;ndern.</entry>
	  </row>
	  <row>
	    <entry>&man.passwd.1;</entry>
	    <entry>Ein einfaches Werkzeug, um Passw&ouml;rter von Accounts
	      zu &auml;ndern.</entry>
	  </row>
	  <row>
	    <entry>&man.pw.8;</entry>
	    <entry>Ein m&auml;chtiges und flexibles Werkzeug um alle
	      Informationen &uuml;ber Accounts zu &auml;ndern.</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <sect2 id="users-adduser">
      <title><command>adduser</command></title>

      <indexterm>
	<primary>Accounts</primary>
	<secondary>erstellen</secondary>
      </indexterm>
      <indexterm>
	<primary><command>adduser</command></primary>
      </indexterm>
      <indexterm>
	<primary><filename class="directory">/usr/share/skel</filename></primary>
      </indexterm>
      <para>&man.adduser.8; ist ein einfaches Programm
        um neue Benutzer hinzuzuf&uuml;gen.  Es erstellt
	<filename>passwd</filename> und <filename>group</filename>
	Eintr&auml;ge f&uuml;r den
        Benutzer, genauso wie ein home Verzeichnis, kopiert ein paar
        vorgegebene Dotfiles aus <filename>/usr/share/skel</filename> und kann
        optional dem Benutzer eine ,,Willkommen``-Nachricht zuschicken.</para>

      <example>
	<title>Einen Benutzer unter &os; anlegen</title>

	<screen>&prompt.root; <userinput>adduser</userinput>
Username: <userinput>jru</userinput>
Full name: <userinput>J. Random User</userinput>
Uid (Leave empty for default):
Login group [jru]:
Login group is jru. Invite jru into other groups? []: <userinput>wheel</userinput>
Login class [default]:
Shell (sh csh tcsh zsh nologin) [sh]: <userinput>zsh</userinput>
Home directory [/home/jru]:
Home directory permissions (Leave empty for default):
Use password-based authentication? [yes]:
Use an empty password? (yes/no) [no]:
Use a random password? (yes/no) [no]:
Enter password:
Enter password again:
Lock out the account after creation? [no]:
Username   : jru
Password   : ****
Full Name  : J. Random User
Uid        : 1001
Class      :
Groups     : jru wheel
Home       : /home/jru
Shell      : /usr/local/bin/zsh
Locked     : no
OK? (yes/no): <userinput>yes</userinput>
adduser: INFO: Successfully added (jru) to the user database.
Add another user? (yes/no): <userinput>no</userinput>
Goodbye!
&prompt.root;</screen>
      </example>

      <note>
        <para>Wenn Sie das Passwort eingeben, werden weder Passwort noch
          Sternchen angezeigt.  Passen Sie auf, dass Sie das Passwort
          korrekt eingeben.</para>
      </note>
    </sect2>

    <sect2 id="users-rmuser">
      <title><command>rmuser</command></title>

      <indexterm><primary><command>rmuser</command></primary></indexterm>
      <indexterm>
	<primary>Accounts</primary>
	<secondary>l&ouml;schen</secondary>
      </indexterm>

      <para>Benutzen Sie &man.rmuser.8;, um einen Account
        vollst&auml;ndig aus dem System zu entfernen.
	&man.rmuser.8; f&uuml;hrt die folgenden Schritte
	durch:</para>

      <procedure>
        <step>
          <para>Entfernt den &man.crontab.1; Eintrag des Benutzers
	    (wenn dieser existiert).</para>
        </step>
        <step>
          <para>Entfernt alle &man.at.1; jobs, die dem Benutzer geh&ouml;ren.
          </para>
        </step>
        <step>
          <para>Schlie&szlig;t alle Prozesse des Benutzers.</para>
        </step>
        <step>
          <para>Entfernt den Benutzer aus der lokalen Passwort-Datei des
            Systems.</para>
        </step>
        <step>
          <para>Entfernt das Heimatverzeichnis des Benutzers (falls es dem
            Benutzer geh&ouml;rt).</para>
        </step>
        <step>
          <para>Entfernt eingegangene E-Mails des Benutzers
            aus <filename>/var/mail</filename>.</para>
        </step>
        <step>
          <para>Entfernt alle Dateien des Benutzers aus tempor&auml;ren
            Dateispeicherbereichen wie <filename>/tmp</filename>.</para>
        </step>
        <step>
          <para>Entfernt den Loginnamen von allen Gruppen, zu denen er
            geh&ouml;rt, aus <filename>/etc/group</filename>.</para>

            <note>
              <para>Wenn eine Gruppe leer wird und der Gruppenname mit dem
                Loginnamen identisch ist, wird die Gruppe entfernt; das
                erg&auml;nzt sich mit den einzelnen Benutzer-Gruppen, die von
                &man.adduser.8; f&uuml;r jeden neuen Benutzer erstellt werden.
              </para>
            </note>
        </step>
      </procedure>

      <para>Der Superuser-Account kann nicht mit &man.rmuser.8; entfernt
        werden, da dies in den meisten F&auml;llen das System unbrauchbar
	macht.</para>

      <para>Als Vorgabe wird ein interaktiver Modus benutzt, der
        sicherzustellen versucht, dass Sie wissen, was Sie tun.</para>

      <example>
        <title>Interaktives L&ouml;schen von Account mit
	  <command>rmuser</command></title>

        <screen>&prompt.root; <userinput>rmuser jru</userinput>
Matching password entry:
jru:*:1001:1001::0:0:J. Random User:/home/jru:/usr/local/bin/zsh
Is this the entry you wish to remove? <userinput>y</userinput>
Remove user's home directory (/home/jru)? <userinput>y</userinput>
Updating password file, updating databases, done.
Updating group file: trusted (removing group jru -- personal group is empty) done.
Removing user's incoming mail file /var/mail/jru: done.
Removing files belonging to jru from /tmp: done.
Removing files belonging to jru from /var/tmp: done.
Removing files belonging to jru from /var/tmp/vi.recover: done.
&prompt.root;</screen>
      </example>
    </sect2>

    <sect2 id="users-chpass">
      <title><command>chpass</command></title>

      <indexterm><primary><command>chpass</command></primary></indexterm>
      <para>&man.chpass.1; &auml;ndert Informationen der
        Benutzerdatenbank wie Passw&ouml;rter, Shells und pers&ouml;nliche
        Informationen.</para>

      <para>Nur Systemadministratoren, mit Superuser-Rechten, k&ouml;nnen die
        Informationen und Passw&ouml;rter der anderen Benutzer mit
        &man.chpass.1; ver&auml;ndern.</para>

      <para>Werden keine Optionen neben dem optionalen Loginnamen
        angegeben, zeigt &man.chpass.1; einen Editor
        mit Account-Informationen an und aktualisiert die
	Account-Datenbank, wenn dieser verlassen wird.</para>

      <note>
        <para>Unter &os; wird nach dem Verlassen des Editors
          nach dem Passwort gefragt, es sei denn, man ist als Superuser
          angemeldet.</para>
      </note>

      <example>
        <title>Interaktives <command>chpass</command> des Superusers</title>

        <screen>#Changing user database information for jru.
Login: jru
Password: *
Uid [#]: 1001
Gid [# or name]: 1001
Change [month day year]:
Expire [month day year]:
Class:
Home directory: /home/jru
Shell: /usr/local/bin/zsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:</screen>
      </example>

      <para>Der normale Benutzer kann nur einen kleinen Teil dieser
        Informationen ver&auml;ndern und nat&uuml;rlich nur die Daten des
	eigenen Accounts.</para>

      <example>
        <title>Interaktives <command>chpass</command> eines normalen
	  Benutzers</title>

        <screen>#Changing user database information for jru.
Shell: /usr/local/bin/tcsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:</screen>
      </example>

      <note>
        <para>&man.chfn.1; und &man.chsh.1; sind
          nur Verweise auf &man.chpass.1; genauso wie
          &man.ypchpass.1;, &man.ypchfn.1; und
          &man.ypchsh.1;.  NIS wird automatisch unterst&uuml;tzt,
          deswegen ist es nicht notwendig das <literal>yp</literal> vor dem
          Kommando einzugeben.  NIS wird sp&auml;ter
	  in <xref linkend="network-servers"> besprochen.</para>
      </note>
    </sect2>
    <sect2 id="users-passwd">
      <title><application>passwd</application></title>

      <indexterm><primary><command>passwd</command></primary></indexterm>
      <indexterm>
	<primary>Accounts</primary>
	<secondary>Passwort wechseln</secondary>
      </indexterm>
      <para>&man.passwd.1; ist der &uuml;bliche Weg, Ihr
        eigenes Passwort als Benutzer zu &auml;ndern oder das Passwort eines
        anderen Benutzers als Superuser.</para>

      <note>
	<para>Um unberechtigte &Auml;nderungen zu verhindern,
	  muss bei einem Passwortwechsel zuerst das urspr&uuml;ngliche
	  Passwort eingegeben werden.</para>
      </note>

      <example>
        <title>Wechseln des Passworts</title>

        <screen>&prompt.user; <userinput>passwd</userinput>
Changing local password for jru.
Old password:
New password:
Retype new password:
passwd: updating the database...
passwd: done

&prompt.root; <userinput>passwd jru</userinput>
Changing local password for jru.
New password:
Retype new password:
passwd: updating the database...
passwd: done</screen>
      </example>

      <example>
	<title>Als Superuser das Passwort eines anderen Accounts
	  ver&auml;ndern</title>

	<screen>&prompt.root; <userinput>passwd jru</userinput>
Changing local password for jru.
New password:
Retype new password:
passwd: updating the database...
passwd: done</screen>
      </example>

      <note>
        <para>Wie bei &man.chpass.1; ist &man.yppasswd.1;
	  nur ein Verweis auf &man.passwd.1;.  NIS wird von
	  jedem dieser Kommandos unterst&uuml;tzt.</para>
      </note>
    </sect2>

    <sect2 id="users-pw">
      <title><command>pw</command></title>
      <indexterm><primary><command>pw</command></primary></indexterm>

      <para>&man.pw.8; ist ein Kommandozeilenprogramm, mit
        dem man Accounts und Gruppen erstellen, entfernen, ver&auml;ndern
	und anzeigen kann.  Dieses Kommando dient als Schnittstelle zu den
        Benutzer- und Gruppendateien des Systems.  &man.pw.8;
	besitzt eine Reihe m&auml;chtiger Kommandozeilenschalter, die es
	f&uuml;r die Benutzung in Shell-Skripten geeignet machen, doch
	finden neue Benutzer die Bedienung des Kommandos komplizierter, als
	die der anderen hier vorgestellten Kommandos.</para>
    </sect2>
  </sect1>

  <sect1 id="users-limiting">
    <title>Benutzer einschr&auml;nken</title>

    <indexterm><primary>Benutzer einschr&auml;nken</primary></indexterm>
    <indexterm>
      <primary>Accounts</primary>
      <secondary>einschr&auml;nken</secondary>
    </indexterm>
    <para>Wenn ein System von mehreren Benutzern verwendet wird, ist es
      vielleicht notwendig, den Gebrauch des Systems zu beschr&auml;nken.
      FreeBSD bietet dem Systemadministrator mehrere M&ouml;glichkeiten
      die System-Ressourcen, die ein einzelner Benutzer verwenden kann,
      einzuschr&auml;nken.  Diese Limitierungen sind in zwei Kategorien
      eingeteilt: Festplattenkontingente und andere
      Ressourcenbeschr&auml;nkungen.</para>

    <indexterm><primary>Quotas</primary></indexterm>
    <indexterm>
      <primary>Benutzer einschr&auml;nken</primary>
      <secondary>Quotas</secondary>
    </indexterm>
    <indexterm><primary>Festplatten Quotas</primary></indexterm>
    <para>Festplatten-Kontingente schr&auml;nken den Plattenplatz, der
      einem Benutzer zur Verf&uuml;gung steht, ein.  Sie bieten zudem,
      ohne aufw&auml;ndige Berechnung, einen schnellen &Uuml;berblick
      &uuml;ber den verbrauchten Plattenplatz.
      Kontingente werden in <xref linkend="quotas"> diskutiert.</para>

    <indexterm>
      <primary><filename>/etc/login.conf</filename></primary>
    </indexterm>
    <para>Die Login-Klassen werden in <filename>/etc/login.conf</filename>
      definiert.  Auf die pr&auml;zisen Semantiken gehen wir hier nicht
      weiter ein, sie k&ouml;nnen jedoch in &man.login.conf.5;
      nachgelesen werden.  Es ist ausreichend zu sagen, dass jeder
      Benutzer einer Login-Klasse zugewiesen wird (standardm&auml;&szlig;ig
      <literal>default</literal>) und dass jede Login-Klasse mit einem Satz
      von Login-F&auml;higkeiten verbunden ist.  Eine Login-F&auml;higkeit
      ist ein <literal><replaceable>Name</replaceable>=<replaceable>Wert
      </replaceable></literal> Paar, in dem <replaceable>Name</replaceable>
      die F&auml;higkeit bezeichnet und <replaceable>Wert</replaceable>
      ein willk&uuml;rlicher Text ist, der je nach <replaceable>Name
      </replaceable> entsprechend verarbeitet wird.  Login-Klassen und
      -F&auml;higkeiten zu definieren, ist fast schon selbsterkl&auml;rend
      und wird auch in &man.login.conf.5; beschrieben.</para>

    <note>
      <para>Das System verwendet die Datei
	<filename>/etc/login.conf</filename> normalerweise nicht direkt,
	sondern nur &uuml;ber die Datenbank
	<filename>/etc/login.conf.db</filename>, da diese eine
	schnellere Abfrage erlaubt.  Der nachstehende Befehl erzeugt die
	Datenbank <filename>/etc/login.conf.db</filename> aus der Datei
	<filename>/etc/login.conf</filename>:</para>

      <screen>&prompt.root; <userinput>cap_mkdb /etc/login.conf</userinput></screen>
    </note>

    <para>Ressourcenbeschr&auml;nkungen unterscheiden sich von normalen
      Login-F&auml;higkeiten zweifach.  Erstens gibt es f&uuml;r jede
      Beschr&auml;nkung ein aktuelles und ein maximales Limit.  Das
      aktuelle Limit kann vom Benutzer oder einer Anwendung beliebig
      bis zum maximalen Limit ver&auml;ndert werden.  Letzteres kann
      der Benutzer nur heruntersetzen.  Zweitens gelten die meisten
      Ressourcenbeschr&auml;nkungen f&uuml;r jeden vom Benutzer
      gestarteten Prozess, nicht f&uuml;r den Benutzer selbst.
      Beachten Sie jedoch, dass diese Unterschiede durch das spezifische
      Einlesen der Limits und nicht durch das System der
      Login-F&auml;higkeiten entstehen (das hei&szlig;t,
      Ressourcenbeschr&auml;nkungen sind <emphasis>keine</emphasis>
      Login-F&auml;higkeiten).</para>

    <para>Hier befinden sich die am h&auml;ufigsten benutzten
      Ressourcenbeschr&auml;nkungen (der Rest kann zusammen mit den
      anderen Login-F&auml;higkeiten in &man.login.conf.5; gefunden
      werden):</para>

    <variablelist>
      <varlistentry>
	<term><literal>coredumpsize</literal></term>

	<listitem>
	  <indexterm><primary>coredumpsize</primary></indexterm>
	  <indexterm>
	    <primary>Benutzer einschr&auml;nken</primary>
	    <secondary>coredumpsize</secondary>
	  </indexterm>
          <para>Das Limit der Gr&ouml;&szlig;e einer core-Datei, die
	    von einem Programm generiert wird, unterliegt aus
	    offensichtlichen Gr&uuml;nden anderen Limits der
	    Festplattenbenutzung (zum Beispiel <literal>filesize</literal>
	    oder Festplattenkontingenten).  Es wird aber trotzdem
	    oft als weniger harte Methode zur Kontrolle des
	    Festplattenplatz-Verbrauchs verwendet: Da Benutzer die
	    core-Dateien nicht selbst erstellen, und sie oft nicht
	    l&ouml;schen, kann sie diese Option davor retten, dass
	    ihnen kein Festplattenspeicher mehr zur Verf&uuml;gung
	    steht, sollte ein gro&szlig;es Programm, wie
	    <application>emacs</application>, abst&uuml;rzen.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>cputime</literal></term>

	<listitem>
	  <indexterm><primary>cputime</primary></indexterm>
	  <indexterm>
	    <primary>Benutzer einschr&auml;nken</primary>
	    <secondary>cputime</secondary>
	  </indexterm>
	  <para>Die maximale Rechenzeit, die ein Prozess eines Benutzers
	    verbrauchen darf.  &Uuml;berschreitet der Prozess diesen Wert,
	    wird er vom Kernel beendet.</para>

	    <note>
	      <para>Die Rechen<emphasis>zeit</emphasis> wird limitiert,
		nicht die prozentuale Prozessorenbenutzung, wie es in
		einigen Feldern in &man.top.1; und &man.ps.1; dargestellt
		wird.  Letzteres war zu der Zeit, als dies hier geschrieben
		wurde nicht m&ouml;glich und w&uuml;rde eher nutzlos sein:
		Ein Compiler &ndash; ein wahrscheinlich legitimer
		Vorgang &ndash; kann leicht fast 100% des Prozessors in
		Anspruch nehmen.</para>
	    </note>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>filesize</literal></term>

	<listitem>
	  <indexterm><primary>filesize</primary></indexterm>
	  <indexterm>
	    <primary>Benutzer einschr&auml;nken</primary>
	    <secondary>filesize</secondary>
	  </indexterm>
	  <para>Hiermit l&auml;sst sich die maximale Gr&ouml;&szlig;e einer Datei
	    bestimmen, die der Benutzer besitzen darf.  Im Gegensatz zu
            <link linkend="quotas">Festplattenkontingenten</link> ist diese
	    Beschr&auml;nkung nur f&uuml;r jede einzelne Datei g&uuml;ltig
	    und nicht f&uuml;r den Platz, den alle Dateien eines Benutzers
	    verwenden.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>maxproc</literal></term>

	<listitem>
	  <indexterm><primary>maxproc</primary></indexterm>
	  <indexterm>
	    <primary>Benutzer einschr&auml;nken</primary>
	    <secondary>maxproc</secondary>
	  </indexterm>
	  <para>Das ist die maximale Anzahl von Prozessen, die ein
	    Benutzer starten darf, und beinhaltet sowohl Vordergrund-
	    als auch Hintergrundprozesse.  Nat&uuml;rlich darf dieser
	    Wert nicht h&ouml;her sein als das System-Limit, das in
	    <varname>kern.maxproc</varname> angegeben ist.  Vergessen
	    Sie auch nicht, dass ein zu kleiner Wert den Benutzer in
	    seiner Produktivit&auml;t einschr&auml;nken k&ouml;nnte;
	    es ist oft n&uuml;tzlich, mehrfach eingeloggt zu sein, oder
	    <foreignphrase>Pipelines</foreignphrase>
	      <footnote>
		<para><foreignphrase>Pipeline</foreignphrase> =
		  <emphasis>Leitung</emphasis>.
		  Mit <foreignphrase>Pipes</foreignphrase> sind Verbindungen
		  zwischen zwei Sockets in meistens zwei verschiedenen
		  Prozessen gemeint.</para>
	      </footnote>
	    zu verwenden.  Ein paar Aufgaben, wie die Kompilierung eines
	    gro&szlig;en Programms, starten mehrere Prozesse (zum Beispiel
	    &man.make.1;, &man.cc.1; und andere).</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>memorylocked</literal></term>

	<listitem>
	  <indexterm><primary>memorylocked</primary></indexterm>
	  <indexterm>
	    <primary>Benutzer einschr&auml;nken</primary>
	    <secondary>memorylocked</secondary>
	  </indexterm>
	  <para>Dieses Limit gibt an, wie viel virtueller Speicher von einem
	    Prozess maximal im Arbeitsspeicher festgesetzt werden kann.
	    (siehe auch &man.mlock.2;).  Ein paar systemkritische Programme,
	    wie &man.amd.8;, verhindern damit einen Systemzusammenbruch, der
	    auftreten k&ouml;nnte, wenn sie aus dem Speicher genommen werden.
	  </para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>memoryuse</literal></term>

	<listitem>
	  <indexterm><primary>memoryuse</primary></indexterm>
	  <indexterm>
	    <primary>Benutzer einschr&auml;nken</primary>
	    <secondary>memoryuse</secondary>
	  </indexterm>
	  <para>Bezeichnet den maximalen Speicher, den ein Prozess benutzen
	    darf und beinhaltet sowohl Arbeitsspeicher-, als auch Swap-
	    Benutzung.  Es ist kein all&uuml;bergreifendes Limit f&uuml;r
	    den Speicherverbrauch, aber ein guter Anfang.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>openfiles</literal></term>

	<listitem>
	  <indexterm><primary>openfiles</primary></indexterm>
	  <indexterm>
	    <primary>Benutzer einschr&auml;nken</primary>
	    <secondary>openfiles</secondary>
	  </indexterm>
	  <para>Mit diesem Limit l&auml;sst sich die maximale Anzahl
	    der von einem Prozess des Benutzers ge&ouml;ffneten Dateien
	    festlegen.  In FreeBSD werden Dateien auch verwendet, um Sockets
	    und <foreignphrase>IPC</foreignphrase>-Kan&auml;le
	    <footnote>
	      <para><foreignphrase>IPC</foreignphrase> steht f&uuml;r
		<foreignphrase>Interprocess Communication</foreignphrase>.
		</para>
	    </footnote>
	    darzustellen.  Setzen Sie es deshalb nicht zu niedrig.  Das
	    System-Limit ist im <varname>kern.maxfiles</varname>
	    &man.sysctl.8; definiert.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>sbsize</literal></term>

	<listitem>
	  <indexterm><primary>sbsize</primary></indexterm>
	  <indexterm>
	    <primary>Benutzer einschr&auml;nken</primary>
	    <secondary>sbsize</secondary>
	  </indexterm>
	  <para>Dieses Limit beschr&auml;nkt den Netzwerk-Speicher, und damit
	    die mbufs, die ein Benutzer verbrauchen darf.  Es stammt aus einer
	    Antwort auf einen DoS-Angriff, bei dem viele Netzwerk-Sockets
	    ge&ouml;ffnet wurden, kann aber generell dazu benutzt werden
	    Netzwerk-Verbindungen zu beschr&auml;nken.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>stacksize</literal></term>

	<listitem>
	  <para>Das ist die maximale Gr&ouml;&szlig;e, auf die der Stack
	    eines Prozesses heranwachsen darf.  Das allein ist nat&uuml;rlich
	    nicht genug, um den Speicher zu beschr&auml;nken, den ein Programm
	    verwenden darf.  Es sollte deshalb in Verbindung mit anderen
	    Limits gesetzt werden.</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <para>Beim Setzen von Ressourcenbeschr&auml;nkungen sind noch andere
      Dinge zu beachten.  Nachfolgend ein paar generelle Tipps, Empfehlungen
      und verschiedene Kommentare.</para>

    <itemizedlist>
      <listitem>
	<para>Von <filename>/etc/rc</filename> beim Hochfahren des Systems
	  gestartete Prozesse werden der <literal>daemon</literal>
	  Login-Klasse zugewiesen.</para>
      </listitem>

      <listitem>
	<para>Obwohl das mitgelieferte <filename>/etc/login.conf</filename>
	  eine Quelle von vern&uuml;nftigen Limits darstellt, k&ouml;nnen nur
	  Sie, der Administrator, wissen, was f&uuml;r Ihr System angebracht
	  ist.  Ein Limit zu hoch anzusetzen k&ouml;nnte Ihr System f&uuml;r
	  Missbrauch &ouml;ffnen, und ein zu niedriges Limit der
	  Produktivit&auml;t einen Riegel vorschieben.</para>
      </listitem>

      <listitem>
	<para>Benutzer des X-Window Systems (X11) sollten wahrscheinlich
	  mehr Ressourcen zugeteilt bekommen als andere Benutzer.  X11
	  beansprucht selbst schon eine Menge Ressourcen, verleitet die
	  Benutzer aber auch, mehrere Programme gleichzeitig laufen zu
	  lassen.</para>
      </listitem>

      <listitem>
	<para>Bedenken Sie, dass viele Limits f&uuml;r einzelne Prozesse
	  gelten und nicht f&uuml;r den Benutzer selbst.  Setzt man
	  zum Beispiel <varname>openfiles</varname> auf 50, kann jeder
	  Prozess des Benutzers bis zu 50 Dateien &ouml;ffnen.  Dadurch
	  ist die maximale Anzahl von Dateien, die von einem Benutzer
	  ge&ouml;ffnet werden k&ouml;nnen, <literal>openfiles</literal>
	  mal <literal>maxproc</literal>.  Das gilt auch f&uuml;r den
	  Speicherverbrauch.</para>
      </listitem>
    </itemizedlist>

    <para>Weitere Informationen &uuml;ber
      Ressourcenbeschr&auml;nkungen, Login-Klassen und -F&auml;higkeiten
      enthalten die Hilfeseiten
      &man.cap.mkdb.1;, &man.getrlimit.2; und &man.login.conf.5;.</para>
  </sect1>

  <sect1 id="users-groups">
    <title>Gruppen</title>

    <indexterm><primary>Gruppen</primary></indexterm>
    <indexterm>
      <primary><filename>/etc/groups</filename></primary>
    </indexterm>
    <indexterm>
      <primary>Accounts</primary>
      <secondary>Gruppen</secondary>
    </indexterm>
    <para>Eine Gruppe ist einfach eine Zusammenfassung von Accounts.
      Gruppen werden durch den Gruppennamen und die GID (group ID)
      identifiziert.  Der Kernel von FreeBSD (und den meisten anderen &unix;
      Systemen) entscheidet anhand der UID und der Gruppenmitgliedschaft
      eines Prozesses, ob er dem Prozess etwas erlaubt oder nicht.  Im
      Unterschied zur UID kann ein Prozess zu einer Reihe von Gruppen
      geh&ouml;ren.  Wenn jemand von der GID eines
      Benutzers oder Prozesses spricht, meint er damit meistens die erste
      Gruppe der Gruppenliste.</para>

    <para>Die Zuordnung von Gruppennamen zur GID steht in
      <filename>/etc/group</filename>, einer Textdatei mit vier durch
      Doppelpunkte getrennten Feldern.  Im ersten Feld steht der
      Gruppenname, das zweite enth&auml;lt ein verschl&uuml;sseltes
      Passwort, das dritte gibt die GID an und das vierte besteht aus einer
      Komma separierten Liste der Mitglieder der Gruppe.  Diese Datei kann
      einfach editiert werden (nat&uuml;rlich nur, wenn Sie dabei keine
      Syntaxfehler machen).  Eine ausf&uuml;hrliche Beschreibung der Syntax
      dieser Datei finden Sie in &man.group.5;.</para>

    <para>Wenn Sie <filename>/etc/group</filename> nicht h&auml;ndisch
      editieren m&ouml;chten, k&ouml;nnen Sie &man.pw.8; zum Editieren
      benutzen.  Das folgende Beispiel zeigt das Hinzuf&uuml;gen einer
      Gruppe mit dem Namen <groupname>teamtwo</groupname>:</para>

    <example>
      <title>Setzen der Mitgliederliste einer Gruppe mit &man.pw.8;</title>

      <screen>&prompt.root; <userinput>pw groupadd teamtwo</userinput>
&prompt.root; <userinput>pw groupshow teamtwo</userinput>
teamtwo:*:1100:</screen>
    </example>

    <para>Die Zahl <literal>1100</literal> ist die GID der Gruppe
      <groupname>teamtwo</groupname>.  Momentan hat
      <groupname>teamtwo</groupname> noch keine Mitglieder und ist daher
      ziemlich nutzlos.  Um das zu &auml;ndern, nehmen wir nun
      <username>jru</username> in <groupname>teamtwo</groupname>
      auf.</para>

    <example>
      <title>Ein Gruppenmitglied mit <command>pw</command>
	hinzuf&uuml;gen</title>

      <screen>&prompt.root; <userinput>pw groupmod teamtwo -M jru</userinput>
&prompt.root; <userinput>pw groupshow teamtwo</userinput>
teamtwo:*:1100:jru</screen>
    </example>

    <para>Als Argument von <option>-M</option> geben Sie eine Komma
      separierte Liste von Mitgliedern an, die in die Gruppe aufgenommen
      werden sollen.  Aus den vorherigen Abschnitten ist bekannt, dass die
      Passwort-Datei ebenfalls eine Gruppe f&uuml;r jeden Benutzer
      enth&auml;lt.  Das System teilt dem Benutzer automatisch eine Gruppe
      zu, die aber vom <option>groupshow</option> Kommando von &man.pw.8;
      nicht angezeigt wird.  Diese Information wird allerdings von
      &man.id.1; und &auml;hnlichen Werkzeugen angezeigt.  Das hei&szlig;t,
      dass &man.pw.8; nur <filename>/etc/group</filename> manipuliert,
      es wird nicht versuchen, zus&auml;tzliche Informationen aus
      <filename>/etc/passwd</filename> zu lesen.</para>

    <example>
      <title>Hinzuf&uuml;gen eines neuen Gruppenmitglieds mittels 
      &man.pw.8;</title>
      
      <screen>&prompt.root; <userinput>pw groupmod teamtwo -m db</userinput>
&prompt.root; <userinput>pw groupshow teamtwo</userinput>
teamtwo:*:1100:jru,db</screen>
    </example>
    
    <para>Die Argumente zur Option <option>-m</option> ist eine durch Komma
      getrennte Liste von Benutzern, die der Gruppe hinzugef&uuml;gt werden
      sollen.  Anders als im vorherigen Beispiel werden diese Benutzer in die
      Gruppe aufgenommen und ersetzen nicht die Liste der bereits bestehenden
      Benutzer in der Gruppe.</para>

    <example>
      <title>Mit <command>id</command> die Gruppenzugeh&ouml;rigkeit
	bestimmen</title>

      <screen>&prompt.user; <userinput>id jru</userinput>
uid=1001(jru) gid=1001(jru) groups=1001(jru), 1100(teamtwo)</screen>
    </example>

    <para>Wie Sie sehen, ist <username>jru</username> Mitglied von
      <groupname>jru</groupname> und <groupname>teamtwo</groupname>.</para>

    <para>Weitere Informationen entnehmen Sie bitte &man.pw.8;.</para>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
