<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde: de-docproj/books/handbook/security/chapter.xml,v 1.178 2012/04/30 17:07:41 bcr Exp $
     basiert auf: r51479
-->
<chapter xmlns="http://docbook.org/ns/docbook"
  xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0"
  xml:id="security">

  <info>
    <title>Sicherheit</title>

    <authorgroup>
      <author>
	<personname>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	</personname>
	<contrib>Neu verfasst von </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	<personname>
	  <firstname>Martin</firstname>
	  <surname>Heinen</surname>
	</personname>
	<contrib>Übersetzt von </contrib>
      </author>
    </authorgroup>
  </info>

  <indexterm><primary>Sicherheit</primary></indexterm>

  <sect1 xml:id="security-synopsis">
    <title>Übersicht</title>

    <para>Sicherheit, ob nun physisch oder virtuell, ist ein so breit
      gefächertes Thema, dass sich eine ganze Industrie darum gebildet
      hat.  Es wurden bereits hunderte Verfahren zur Sicherung von
      Systemen und Netzwerken verfasst, und als Benutzer von &os; ist
      es unumgänglich zu verstehen, wie Sie sich gegen Angreifer und
      Eindringlinge schützen können.</para>


    <para>In diesem Kapitel werden einige Grundlagen und Techniken
      diskutiert.  Ein &os;-System implementiert Sicherheit in
      mehreren Schichten, und viele weitere Programme von
      Drittanbietern können zur Verbesserung der Sicherheit
      beitragen.</para>

    <para>Nachdem Sie dieses Kapitel gelesen haben, werden Sie:</para>

    <itemizedlist>
      <listitem>
	<para>Grundlegende auf &os; bezogene Sicherheitsaspekte
	  kennen.</para>
      </listitem>

      <listitem>
	<para>Die verschiedenen Verschlüsselungsmechanismen
	  von &os; kennen.</para>
      </listitem>

      <listitem>
	<para>Wissen, wie Sie ein Einmalpasswörter
	  zur Authentifizierung verwenden.</para>
      </listitem>

      <listitem>
	<para><application>TCP Wrapper</application> für &man.inetd.8;
	  einrichten können.</para>
      </listitem>

      <listitem>
	<para>Wissen, wie Sie <application>Kerberos</application>
	  unter &os; einrichten.</para>
      </listitem>

      <listitem>
	<para>Wissen, wie Sie <acronym>IPsec</acronym> konfigurieren
	  und ein <acronym>VPN</acronym> einrichten.</para>
      </listitem>

      <listitem>
	<para>Wissen, wie Sie <application>OpenSSH</application> unter
	  &os; konfigurieren und benutzen.</para>
      </listitem>

      <listitem>
	<para>Wissen, wie Sie <acronym>ACL</acronym>s für Dateisysteme
	  benutzen.</para>
      </listitem>

      <listitem>
	<para><application>pkg</application> anwenden können,
	  um Softwarepakete aus der Ports-Sammlung auf bekannte
	  Sicherheitslücken hin zu überprüfen.</para>
      </listitem>

      <listitem>
	<para>Mit &os;-Sicherheitshinweisen umgehen können.</para>
      </listitem>

      <listitem>
	<para>Eine Vorstellung davon haben, was Prozessüberwachung
	  (<foreignphrase>Process Accounting</foreignphrase>) ist und
	  wie Sie diese Funktion unter &os; aktivieren können.</para>
      </listitem>

      <listitem>
	<para>Wissen, wie Sie Login-Klassen oder die
	  Ressourcen-Datenbank benutzen, um die Ressourcen für
	  Benutzer zu steuern.</para>
      </listitem>
    </itemizedlist>

    <para>Bevor Sie dieses Kapitel lesen, sollten Sie</para>

    <itemizedlist>
      <listitem>
	<para>Grundlegende Konzepte von &os; und dem Internet
	  verstehen.</para>
      </listitem>
    </itemizedlist>

    <para>Dieses Buch behandelt weitere Sicherheitsthemen.
      Beispielsweise werden verbindliche Zugriffskontrollen
      im <xref linkend="mac"/> und Firewalls im
      <xref linkend="firewalls"/> besprochen.</para>
  </sect1>

  <sect1 xml:id="security-intro">
    <title>Einführung</title>

    <para>Sicherheit ist die Verantwortung eines jeden Einzelnen.  Ein
      schwacher Einstiegspunkt in einem System kann einem
      Eindringling Zugriff auf wichtige Informationen verschaffen, was
      sich verheerend auf das gesamte Netzwerk auswirken kann.  Eines
      der Grundprinzipien der Informationssicherheit sind die
      Vertraulichkeit, Integrität und Verfügbarkeit von
      Informationssystemen.</para>

    <para>Diese Grundprinzipien sind ein fundamentales Konzept der
      Computer-Sicherheit, da Kunden und Benutzer erwarten, dass ihre
      Daten geschützt sind.  Zum Beispiel erwartet ein Kunde, dass
      seine Kreditkarteninformationen sicher gespeichert werden
      (Vertraulichkeit), dass seine Aufträge nicht hinter den Kulissen
      geändert werden (Integrität) und dass er zu jeder Zeit Zugang zu
      seinen Informationen hat (Verfügbarkeit).</para>

    <para>Um diese Grundprinzipien zu implementieren, wenden
      Sicherheitsexperten das sogenannte
      <foreignphrase>Defense-in-Depth</foreignphrase>-Konzept an.  Die
      Idee dahinter ist, mehrere Sicherheitsschichten zu addieren, so
      dass nicht die gesamte Systemsicherheit gefährdet ist, wenn
      eine einzelne Sicherheitsschicht kompromittiert wird.
      Beispielsweise ist es nicht ausreichend, ein Netzwerk oder ein
      System nur mit einer Firewall zu sichern.  Der
      Systemadministrator muss auch Benutzerkonten überwachen, die
      Integrität von Binärdateien prüfen und sicherstellen, dass keine
      bösartigen Programme installiert sind.  Um eine effektive
      Sicherheitsstrategie zu implementieren, muss man Bedrohungen
      verstehen und wissen, wie man sich dagegen verteidigen
      kann.</para>

    <para>Was ist eine Bedrohung, wenn es um Computer-Sicherheit geht?
      Bedrohungen beschränken sich nicht nur auf entfernte Angreifer,
      die sich unerlaubten Zugriff auf ein System verschaffen wollen.
      Zu den Bedrohungen zählen auch Mitarbeiter, bösartige Software,
      nicht autorisierte Netzwerkgeräte, Naturkatastrophen,
      Sicherheitslücken und sogar konkurrierende Unternehmen.</para>

    <para>Der Zugriff auf Netzwerke und Systeme erfolgt ohne
      Erlaubnis, manchmal durch Zufall, oder von entfernten
      Angreifern, und in einigen Fällen durch Industriespionage oder
      ehemalige Mitarbeiter.  Als Anwender müssen Sie vorbereitet sein
      und auch zugeben, wenn ein Fehler zu einer Sicherheitsverletzung
      geführt hat.  Melden Sie Probleme umgehend dem verantwortlichen
      Sicherheitspersonal.  Als Administrator ist es wichtig,
      Bedrohungen zu kennen und darauf vorbereitet zu sein, mögliche
      Schäden zu mildern.</para>

    <para>Wenn Sicherheit auf Systeme angewendet wird, empfiehlt es
      sich mit der Sicherung der Benutzerkonten zu beginnen und dann
      die Netzwerkschicht zu sichern.  Dabei ist zu beachten, dass die
      Sicherheitsrichtlinien des Systems und des Unternehmens
      eingehalten werden.  Viele Unternehmen haben bereits eine
      Sicherheitsrichtlinie, welche die Konfiguration von technischen
      Geräten abdeckt.  Die Richtlinie sollte die Konfiguration von
      Arbeitsplatzrechnern, Desktops, mobilen Geräten, Mobiltelefonen,
      Produktions- und Entwicklungsservern umfassen.  In einigen
      Fällen ist bereits eine Standardvorgehensweise vorhanden.
      Fragen Sie im Zweifelsfall das Sicherheitspersonal.</para>

    <para>Der übrige Teil dieser Einführung beschreibt, wie einige
      grundlegende Sicherheitskonfigurationen auf einem
      &os;-System durchgeführt werden.  Der Rest des Kapitels
      zeigt einige spezifische Werkzeuge, die verwendet werden
      können, um eine Sicherheitsrichtlinie auf einem &os;-System zu
      implementieren.</para>

    <sect2 xml:id="security-accounts">
      <title>Anmeldungen am System verhindern</title>

      <para>Ein guter Ausgangspunkt für die Absicherung des Systems
	ist die Prüfung der Benutzerkonten.  Stellen Sie sicher, dass
	<systemitem class="username">root</systemitem> ein starkes
	Passwort besitzt und dass dieses Passwort nicht weitergegeben
	wird.  Deaktivieren Sie alle Konten, die keinen Zugang zum
	System benötigen.</para>

      <para>Es existieren zwei Methoden, um die Anmeldung über ein
	Benutzerkonto zu verweigern.  Die erste Methode ist, das
	Konto zu sperren.  Dieses Beispiel sperrt das Benutzerkonto
	<systemitem class="username">toor</systemitem>:</para>

      <screen>&prompt.root; <userinput>pw lock <replaceable>toor</replaceable></userinput></screen>

      <para>Bei der zweiten Methode wird der Anmeldevorgang
	verhindert, indem die Shell auf
	<filename>/sbin/nologin</filename> gesetzt wird.  Nur der
	Superuser kann die Shell für andere Benutzer ändern:</para>

      <screen>&prompt.root; <userinput>chsh -s /usr/sbin/nologin <replaceable>toor</replaceable></userinput></screen>

      <para>Die Shell <filename>/usr/sbin/nologin</filename>
	verhindert, dass dem Benutzer bei der Anmeldung am System eine
	Shell zugeordnet wird.</para>
    </sect2>

    <sect2 xml:id="security-accountmgmt">
      <title>Gemeinsame Nutzung von Benutzerkonten</title>

      <para>In manchen Fällen wird die Systemadministration auf
	mehrere Benutzer aufgeteilt.  &os; bietet zwei Methoden, um
	solche Situationen zu handhaben.  Bei der ersten und nicht
	empfohlenen Methode wird ein gemeinsames root Passwort der
	Mitglieder der Gruppe <systemitem
	class="groupname">wheel</systemitem> verwendet.  Hier gibt
	der Benutzer <command>su</command> und das Passwort für
	<systemitem class="groupname">wheel</systemitem> ein, wenn er
	die Rechte des Superusers benötigt.  Der Benutzer sollte dann
	nach der Beendigung der administrativen Aufgaben
	<command>exit</command> eingeben.  Um einen Benutzer zu dieser
	Gruppe hinzuzufügen, bearbeiten Sie
	<filename>/etc/group</filename> und fügen Sie den Benutzer an
	das Ende des Eintrags <literal>wheel</literal> hinzu.  Die
	Benutzer müssen durch Komma und ohne Leerzeichen getrennt
	werden.</para>

      <para>Die zweite und empfohlene Methode ein Benutzerkonto zu
	teilen wird über den Port oder das Paket
	<package>security/sudo</package> realisiert.  Dieses Programm
	bietet zusätzliche Prüfungen, bessere Benutzerkontrolle und
	es kann auch konfiguriert werden, einzelnen Benutzern Zugriff
	auf bestimme, privilegierte Befehle zu gestatten.</para>

      <para>Benutzen Sie nach der Installation
	<command>visudo</command>, um
	<filename>/usr/local/etc/sudoers</filename> zu bearbeiten.
	Dieses Beispiel erstellt eine neue Gruppe <systemitem
	  class="groupname">webadmin</systemitem> und fügt das
	Benutzerkonto <systemitem
	  class="username">trhodes</systemitem> dieser Gruppe hinzu.
	Anschließend wird die Gruppe so konfiguriert, dass es
	Gruppenmitgliedern gestattet wird <package>apache24</package>
	neu zu starten:</para>

      <screen>&prompt.root; <userinput>pw groupadd webadmin -M trhodes -g 6000</userinput>
&prompt.root; <userinput>visudo</userinput>
%webadmin ALL=(ALL) /usr/sbin/service apache24 *</screen>
    </sect2>

    <sect2 xml:id="security-passwords">
      <title>Passwort-Hashes</title>

      <para>Passwörter sind ein notwendiges Übel.  Wenn sie verwendet
	werden müssen, sollten sie sehr komplex sein und dazu sollte
	eine leistungsfähige Hash-Funktion gewählt werden, um die
	Version des Passworts zu verschlüsseln, die in der
	Passwortdatenbank gespeichert wird.  &os; unterstützt die
	Hash-Funktionen <acronym>DES</acronym>,
	<acronym>MD5</acronym>, <acronym>SHA256</acronym>,
	<acronym>SHA512</acronym>, sowie
	Blowfish Hash-Funktionen in seiner
	<function>crypt()</function>-Bibliothek.  Das in der
	Voreinstellung verwendete <acronym>SHA512</acronym> sollte
	nicht durch eine weniger sichere Hash-Funktion getauscht
	werden.  Es kann jedoch durch den besseren
	Blowfish-Algorithmus ersetzt werden.</para>

      <note>
	<para>Blowfish ist nicht Bestandteil von
	  <acronym>AES</acronym> und ist nicht kompatibel mit allen
	  Federal Information Processing Standards
	  (<acronym>FIPS</acronym>).  Die Verwendung wird in einigen
	  Umgebungen vielleicht nicht gestattet.</para>
      </note>

      <para>Um zu bestimmen, welche Hash-Funktion das Passwort eines
	Benutzers verschlüsselt, kann der Superuser den Hash für den
	Benutzer in der Passwortdatenbank von &os; nachsehen.  Jeder
	Hash beginnt mit einem Zeichen, mit dem die verwendete
	Hash-Funktion identifiziert werden kann.  Bei
	<acronym>DES</acronym> gibt es allerdings kein führendes
	Zeichen.  <acronym>MD5</acronym> benutzt das Zeichen
	<literal>$</literal>.  <acronym>SHA256</acronym> und
	<acronym>SHA512</acronym> verwenden das Zeichen
	<literal>$6$</literal>.  Blowfish benutzt das Zeichen
	<literal>$2a$</literal>.  In diesem Beispiel wird das Passwort
	von <systemitem class="username">dru</systemitem> mit dem
	Hash-Algorithmus <acronym>SHA512</acronym> verschlüsselt, da
	der Hash mit <literal>$6$</literal> beginnt.  Beachten Sie,
	dass der verschlüsselte Hash und nicht das Passwort selbst, in
	der Passwortdatenbank gespeichert wird:</para>

      <screen>&prompt.root; <userinput>grep dru /etc/master.passwd</userinput>
dru:$6$pzIjSvCAn.PBYQBA$PXpSeWPx3g5kscj3IMiM7tUEUSPmGexxta.8Lt9TGSi2lNQqYGKszsBPuGME0:1001:1001::0:0:dru:/usr/home/dru:/bin/csh</screen>

      <para>Der Hash-Mechanismus wird in der Login-Klasse des
	Benutzers festgelegt.  In diesem Beispiel wird die
	voreingestellte Login-Klasse für den Benutzer verwendet.  Der
	Hash-Algorithmus wird mit dieser Zeile in
	<filename>/etc/login.conf</filename> gesetzt:</para>

      <programlisting>        :passwd_format=sha512:\</programlisting>

      <para>Um den Algorithmus auf Blowfish zu ändern, passen Sie die
	Zeile wie folgt an:</para>

      <programlisting>        :passwd_format=blf:\</programlisting>

      <para>Führen Sie anschließend
	<command>cap_mkdb /etc/login.conf</command> aus, wie in <xref
	  linkend="users-limiting"/> beschrieben.  Beachten Sie, dass
	vorhandene Passwort-Hashes durch diese Änderung nicht
	beeinträchtigt werden.  Das bedeutet, dass alle Passwörter neu
	gehasht werden sollten, indem die Benutzer mit
	<command>passwd</command> ihr Passwort ändern.</para>

      <para>Für die Anmeldung auf entfernten Rechnern sollte eine
	Zwei-Faktor-Authentifizierung verwendet werden.  Ein Beispiel
	für eine Zwei-Faktor-Authentifizierung ist
	<quote>etwas, was Sie besitzen</quote> (bspw. einen Schlüssel)
	und <quote>etwas, was Sie wissen</quote> (bspw. das Passwort
	für diesen Schlüssel).  Da <application>OpenSSH</application>
	Teil des &os;-Basissystems ist, sollten alle Anmeldungen über
	das Netzwerk über eine verschlüsselte Verbindung mit einer
	schlüsselbasierten Authentifizierung stattfinden.  Passwörter
	sollten hier nicht verwendet werden.  Weitere Informationen
	finden Sie in <xref linkend="openssh"/>.  Kerberos-Benutzer
	müssen eventuell zusätzliche Änderungen vornehmen, um
	<application>OpenSSH</application> in Ihrem Netzwerk zu
	implementieren.  Diese Änderungen sind in <xref
	  linkend="kerberos5"/> beschrieben.</para>
    </sect2>

    <sect2 xml:id="security-pwpolicy">
      <title>Durchsetzung einer Passwort-Richtlinie</title>

      <para>Die Durchsetzung einer starken Passwort-Richtlinie für
	lokale Benutzerkonten ist ein wesentlicher Aspekt der
	Systemsicherheit.  In &os; kann die Länge, Stärke und
	Komplexität des Passworts mit den <foreignphrase>Pluggable
	  Authentication Modules</foreignphrase>
	(<acronym>PAM</acronym>) implementiert werden.</para>

      <para>In diesem Abschnitt wird gezeigt, wie Sie die minimale und
	maximale Passwortlänge und die Durchsetzung von gemischten
	Zeichen mit dem Modul <filename>pam_passwdqc.so</filename>
	konfigurieren.  Dieses Modul wird aufgerufen, wenn ein
	Benutzer sein Passwort ändert.</para>

      <para>Um dieses Modul zu konfigurieren, müssen Sie als Superuser
	die Zeile mit <literal>pam_passwdqc.so</literal> in
	<filename>/etc/pam.d/passwd</filename> auskommentieren.
	Anschließend bearbeiten Sie die Zeile, so dass sie den
	vorliegenden Passwort-Richtlinien entspricht:</para>

      <programlisting>password        requisite       pam_passwdqc.so <replaceable>min=disabled,disabled,disabled,12,10 similar=deny retry=3</replaceable> enforce=users</programlisting>

      <para>Dieses Beispiel legt gleich mehrere Anforderungen für neue
	Passwörter fest.  Die Einstellung <literal>min</literal>
	kontrolliert die Passwortlänge.  Es verfügt über fünf Werte,
	weil dieses Modul fünf verschiedene Arten von Passwörtern
	definiert, basierend auf der Komplexität.  Die Komplexität
	wird durch die Art von Zeichen definiert, die in einem
	Passwort vorhanden sind, wie zum Beispiel Buchstaben, Zahlen
	und Sonderzeichen.  Die verschiedenen Arten von Passwörtern
	werden in &man.pam.passwdqc.8; beschrieben.  In diesem
	Beispiel sind die ersten drei Arten von Passwörtern
	deaktiviert, was bedeutet, dass Passwörter, die dieser
	Komplexitätsstufe entsprechen, nicht akzeptiert werden,
	unabhängig von der Länge des Passworts.  Die
	<literal>12</literal> legt eine Richtlinie von mindestens
	zwölf Zeichen fest, wenn das Passwort auch drei Arten von
	Komplexität aufweist.  Die <literal>10</literal> legt eine
	Richtlinie fest, die auch Passwörter mit mindestens zehn
	Zeichen zulassen, wenn das Passwort Zeichen mit vier Arten
	von Komplexität aufweist.</para>

      <para>Die Einstellung <literal>similar</literal> verbietet
	Passwörter, die dem vorherigen Passwort des Benutzers ähnlich
	sind.  Die Einstellung <literal>retry</literal> bietet dem
	Benutzer drei Möglichkeiten, ein neues Passwort
	einzugeben.</para>

      <para>Sobald diese Datei gespeichert wird, sehen Benutzer bei
	der Änderung ihres Passworts die folgende Meldung:</para>

      <screen>&prompt.user; <userinput>passwd</userinput>
Changing local password for trhodes
Old Password:

You can now choose the new password.
A valid password should be a mix of upper and lower case letters,
digits and other characters.  You can use a 12 character long
password with characters from at least 3 of these 4 classes, or
a 10 character long password containing characters from all the
classes.  Characters that form a common pattern are discarded by
the check.
Alternatively, if noone else can see your terminal now, you can
pick this as your password: "trait-useful&amp;knob".
Enter new password:</screen>

      <para>Wenn ein Passwort nicht den Richtlinien entspricht, wird
	es mit einer Warnung abgelehnt und der Benutzer bekommt die
	Möglichkeit, es erneut zu versuchen, bis die Anzahl an
	Wiederholungen erreicht ist.</para>

      <para>Die meisten Passwort-Richtlinien erzwingen, dass
	Passwörter nach einer bestimmten Anzahl von Tagen ablaufen.
	Um dieses Limit in &os; zu konfigurieren, setzen Sie es für
	die Login-Klasse des Benutzers in
	<filename>/etc/login.conf</filename>.  Die voreingestellte
	Login-Klasse enthält dazu ein Beispiel:</para>

      <programlisting>#       :passwordtime=90d:\</programlisting>

      <para>Um für diese Login-Klasse das Passwort nach 90 Tagen
	ablaufen zu lassen, entfernen Sie das Kommentarzeichen
	(<literal>#</literal>), speichern Sie die Änderungen und
	führen Sie <command>cap_mkdb /etc/login.conf</command>
	aus.</para>

      <para>Um das Passwort für einzelne Benutzer ablaufen zu lassen,
	geben Sie <command>pw</command> ein Ablaufdatum oder die
	Anzahl von Tagen, zusammen mit dem Benutzer an:</para>

      <screen>&prompt.root; <userinput>pw usermod -p <replaceable>30-apr-2015</replaceable> -n <replaceable>trhodes</replaceable></userinput></screen>

      <para>Wie zu sehen ist, wird das Ablaufdatum in der Form von
	Tag, Monat und Jahr angegeben.  Weitere Informationen finden
	Sie in &man.pw.8;.</para>
    </sect2>

    <sect2 xml:id="security-rkhunter">
      <title>Erkennen von Rootkits</title>

      <para>Ein <firstterm>Rootkit</firstterm> ist eine nicht
	autorisierte Software die versucht, Root-Zugriff auf ein
	System zu erlangen.  Einmal installiert, wird diese bösartige
	Software normalerweise eine Hintertür für den Angreifer
	installieren.  Realistisch betrachtet sollte ein durch ein
	Rootkit kompromittiertes System nach der Untersuchung von
	Grund auf neu installiert werden.  Es besteht jedoch die
	enorme Gefahr, dass sogar das Sicherheitspersonal oder
	Systemingenieure etwas übersehen, was ein Angreifer dort
	platziert hat.</para>

      <para>Wird ein Rootkit erkannt, ist dies bereits ein Zeichen
	dafür, dass das System an einem bestimmten Zeitpunkt
	kompromittiert wurde.  Meist neigen diese Art von Anwendungen
	dazu, sehr gut versteckt zu sein.  Dieser Abschnitt zeigt das
	Werkzeug <package>security/rkhunter</package>, mit dem
	Rootkits erkannt werden können.</para>

      <para>Nach der Installation dieses Ports oder Pakets kann das
	System mit dem folgenden Kommando überprüft werden.  Das
	Programm generiert eine ganze Menge Informationen und Sie
	werden diverse Male <keycap>ENTER</keycap> drücken
	müssen:</para>

      <screen>&prompt.root; <userinput>rkhunter -c</userinput></screen>

      <para>Nachdem der Prozess abgeschlossen ist, wird eine
	Statusmeldung auf dem Bildschirm ausgegeben.  Die Meldung
	enthält die Anzahl der überprüften Dateien, verdächtige
	Dateien, mögliche Rootkits und weitere Informationen.  Während
	der Überprüfung erscheinen allgemeine Sicherheitswarnungen,
	zum Beispiel über versteckte Dateien, die Auswahl von
	<application>OpenSSH</application>-Protokollen und bekannte,
	anfällige Versionen installierter Anwendungen.  Diese können
	nun direkt, oder nach detaillierter Analyse untersucht
	werden.</para>

      <para>Jeder Administrator sollte wissen, was auf den Systemen
	läuft, für die er verantwortlich ist.  Werkzeuge von
	Drittanbietern, wie <application>rkhunter</application> oder
	<package>sysutils/lsof</package>, sowie native Befehle wie
	<command>netstat</command> oder <command>ps</command>, können
	eine große Menge an Informationen über das System anzeigen.
	Machen Sie sich Notizen darüber, was <quote>normal</quote>
	ist, und fragen Sie nach, wenn Ihnen etwas suspekt erscheint.
	Eine Beeinträchtigung zu verhindern ist ideal, aber die
	Erkennung einer Beeinträchtigung ist ein Muss.</para>
    </sect2>

    <sect2 xml:id="security-ids">
      <title>Überprüfung von Binärdateien</title>

      <para>Die Überprüfung von System- und Binärdateien ist wichtig,
	da sie Systemadministratoren Informationen über
	Systemänderungen zur Verfügung stellt.  Eine Software, die das
	System auf Änderungen überwacht wird <foreignphrase>Intrustion
	  Detection System</foreignphrase> (<acronym>IDS</acronym>)
	genannt.</para>

      <para>&os; bietet native Unterstützung für ein einfaches
	<acronym>IDS</acronym>-System.  Obwohl die täglichen
	Sicherheits-E-Mails den Administrator über Änderungen in
	Kenntnis setzen, werden diese Informationen lokal gespeichert
	und es besteht die Möglichkeit, dass ein Angreifer diese
	Informationen manipulieren kann, um Änderungen am System zu
	verbergen.  Daher ist es empfehlenswert, einen eigenen Satz an
	Signaturen zu erstellen und diese dann in einem
	schreibgeschützten Verzeichnis, oder vorzugsweise auf einem
	<acronym>USB</acronym>-Stick oder auf einem entfernten Server
	zu speichern.</para>

      <para>Das im Basissystem enthaltene Werkzeug
	<application>mtree</application> kann verwendet werden, um
	eine Spezifikation des Inhalts eines Verzeichnisses zu
	erzeugen.  Hierbei wird ein Startwert
	(<foreignphrase>Seed</foreignphrase>) oder eine numerische
	Konstante benutzt, um die Spezifikation zu erstellen und um
	sicherzustellen, dass sich die Spezifikation nicht geändert
	hat.  Dadurch kann festgestellt werden, ob eine Datei oder
	eine Binärdatei verändert wurde.  Da ein Angreifer den
	Seed nicht kennt, ist es ihm fast unmöglich die
	Prüfsummen von Dateien zu manipulieren.  Das folgende Beispiel
	generiert einen Satz mit <acronym>SHA256</acronym>-Prüfsummen
	für jede Binärdatei unterhalb von <filename>/bin</filename>
	und speichert diese Werte in einer versteckten Datei im
	Heimatverzeichnis von <systemitem
	  class="username">root</systemitem> unter dem Namen
	<filename>/root/.bin_chksum_mtree</filename>:</para>

      <screen>&prompt.root; <userinput>mtree -s <replaceable>3483151339707503</replaceable> -c -K cksum,sha256digest -p <replaceable>/bin</replaceable> &gt; <replaceable>/root/.bin_chksum_mtree</replaceable></userinput>
&prompt.root; mtree: /bin checksum: 3427012225</screen>

      <para><replaceable>3483151339707503</replaceable> stellt den
	Seed dar.  Diesen Wert sollten Sie sich merken, aber
	nicht mit anderen Personen teilen.</para>

      <para>Die Ausgabe von
	<filename>/root/.bin_chksum_mtree</filename> sollte ähnlich
	der folgenden sein:</para>

      <programlisting>#          user: root
#       machine: dreadnaught
#          tree: /bin
#          date: Mon Feb  3 10:19:53 2014

# .
/set type=file uid=0 gid=0 mode=0555 nlink=1 flags=none
.               type=dir mode=0755 nlink=2 size=1024 \
                time=1380277977.000000000
    \133        nlink=2 size=1170 time=1380277977.000000000 \
                cksum=484492447 \
                sha256digest=6207490fbdb5ed1904441fbfa941279055c3e24d3a4049aeb45094596400662a
    cat         size=12096 time=1380277975.000000000 cksum=3909216944 \
                sha256digest=65ea347b9418760b247ab10244f47a7ca2a569c9836d77f074e7a306900c1e69
    chflags     size=8168 time=1380277975.000000000 cksum=3949425175 \
                sha256digest=c99eb6fc1c92cac335c08be004a0a5b4c24a0c0ef3712017b12c89a978b2dac3
    chio        size=18520 time=1380277975.000000000 cksum=2208263309 \
                sha256digest=ddf7c8cb92a58750a675328345560d8cc7fe14fb3ccd3690c34954cbe69fc964
    chmod       size=8640 time=1380277975.000000000 cksum=2214429708 \
                sha256digest=a435972263bf814ad8df082c0752aa2a7bdd8b74ff01431ccbd52ed1e490bbe7</programlisting>

      <para>Der Report enthält den Rechnernamen, das Datum und die
	Uhrzeit der Spezifikation, sowie den Namen des Benutzers, der
	die Spezifikation erstellt hat.  Für jede Binärdatei im
	Verzeichnis gibt es eine Prüfsumme, Größe, Uhrzeit und einen
	<acronym>SHA256</acronym>-Hashwert.</para>

      <para>Um sicherzustellen, dass die binären Signaturen nicht
	verändert wurden, vergleichen Sie den Inhalt des aktuellen
	Verzeichnisses mit der zuvor erstellen Spezifikation.
	Speichern Sie die Ergebnisse in einer Datei.  Dieses Kommando
	benötigt den Seed, der verwendet wurde um die
	ursprüngliche Spezifikation zu erstellen:</para>

      <screen>&prompt.root; <userinput>mtree -s <replaceable>3483151339707503</replaceable> -p <replaceable>/bin</replaceable> &lt; <replaceable>/root/.bin_chksum_mtree</replaceable> &gt;&gt; <replaceable>/root/.bin_chksum_output</replaceable></userinput>
&prompt.root; mtree: /bin checksum: 3427012225</screen>

      <para>Dies sollte die gleiche Prüfsumme für
	<filename>/bin</filename> produzieren, wie die ursprüngliche
	Spezifikation.  Wenn keine Änderungen an den Binärdateien in
	diesem Verzeichnis aufgetreten sind, wird die Ausgabedatei
	<filename>/root/.bin_chksum_output</filename> leer sein.  Um
	eine Änderung zu simulieren, ändern Sie mit
	<command>touch</command> das Datum von
	<filename>/bin/cat</filename> und führen Sie die Verifikation
	erneut aus:</para>

      <screen>&prompt.root; <userinput>touch /bin/cat</userinput>
&prompt.root; <userinput>mtree -s <replaceable>3483151339707503</replaceable> -p <replaceable>/bin</replaceable> &lt; <replaceable>/root/.bin_chksum_mtree</replaceable> &gt;&gt; <replaceable>/root/.bin_chksum_output</replaceable></userinput>
&prompt.root; <userinput>more /root/.bin_chksum_output</userinput>
cat changed
	modification time expected Fri Sep 27 06:32:55 2013 found Mon Feb  3 10:28:43 2014</screen>

      <para>Es wird empfohlen, Spezifikationen für Verzeichnisse zu
	erstellen, welche Binärdateien, Konfigurationsdateien und
	sensible Daten enthalten.  In der Regel werden Spezifikationen
	für <filename>/bin</filename>, <filename>/sbin</filename>,
	<filename>/usr/bin</filename>, <filename>/usr/sbin</filename>,
	<filename>/usr/local/bin</filename>,
	<filename>/usr/local/sbin</filename>,
	<filename>/etc</filename> und
	<filename>/usr/local/etc</filename> erstellt.</para>

      <para>Mit <package>security/aide</package> steht ein
	fortgeschrittenes <acronym>IDS</acronym>-System zur Verfügung,
	aber in den meisten Fällen bietet <command>mtree</command> die
	Funktionalität, die von Administratoren benötigt wird.  Es ist
	jedoch sehr wichtig den Seed und die Prüfsummen in der
	Ausgabe vor böswilligen Benutzern verborgen zu halten.
	Weitere Informationen zu <command>mtree</command> finden Sie
	in &man.mtree.8;.</para>
    </sect2>

    <sect2 xml:id="security-tuning">
      <title>System-Tuning für Sicherheit</title>

      <para>Unter &os; können viele Systemfunktionen mit
	<command>sysctl</command> konfiguriert werden.  Dieser
	Abschnitt behandelt ein paar Sicherheitsmerkmale mit denen
	<foreignphrase>Denial of Service</foreignphrase>
	(<acronym>DoS</acronym>) verhindert werden sollen.  Weitere
	Informationen über die Benutzung von
	<command>sysctl</command> und wie Werte vorübergehend oder
	auch permanent geändert werden können, finden Sie in <xref
	  linkend="configtuning-sysctl"/>.</para>

      <note>
	<para>Jedes Mal wenn eine Einstellung mit
	  <command>sysctl</command> geändert wird, vergrößert sich die
	  Wahrscheinlichkeit eines unerwünschten Schadens, was die
	  Verfügbarkeit des Systems beeinflusst.  Alle Änderungen
	  sollten überwacht und wenn möglich, vorher auf einem
	  Testsystem ausprobiert werden, bevor sie auf einem
	  Produktivsystem verwendet werden.</para>
      </note>

      <para>In der Voreinstellung startet &os; in der Sicherheitsstufe
	(<foreignphrase>Securelevel</foreignphrase>)
	<literal>-1</literal>.  Dieser Modus wird
	<quote>unsicherer Modus</quote> genannt, da die
	unveränderlichen Datei-Flags ausgeschaltet werden können und
	dadurch von allen Geräten gelesen und geschrieben werden kann.
	Solange die Einstellung nicht über <command>sysctl</command>
	oder in den Startskripten geändert wird, verbleibt die
	Sicherheitsstufe auf <literal>-1</literal>.  Die
	Sicherheitsstufe kann während des Systemstarts erhöht werden.
	Dazu muss in <filename>/etc/rc.conf</filename>
	<varname>kern_securelevel_enable</varname> auf
	<literal>YES</literal> und <varname>kern_securelevel</varname>
	auf den gewünschten Wert gesetzt werden.  Weitere
	Informationen zu diesen Einstellungen und den verfügbaren
	Sicherheitsstufen finden Sie in &man.security.7; und
	&man.init.8;.</para>

      <warning>
	<para>Das Erhöhen der Sicherheitsstufe kann zu Problemen mit
	  <application>&xorg;</application> führen.</para>
      </warning>

      <para>Die Einstellungen
	<varname>net.inet.tcp.blackhole</varname> und
	<varname>net.inet.udp.blackhole</varname> können benutzt
	werden, um eingehende <acronym>SYN</acronym>-Pakete an
	geschlossenen Ports zu blockieren, ohne ein
	<acronym>RST</acronym>-Paket als Antwort zu senden.
	Standardmäßig wird jedoch ein <acronym>RST</acronym>-Paket
	gesendet, um zu zeigen, dass der Port geschlossen ist.  Das
	ändern dieser Voreinstellung bietet einen gewissen Schutz
	gegen Portscans.  Diese Portscans versuchen herauszufinden,
	welche Anwendungen auf einem System ausgeführt werden.  Setzen
	Sie <varname>net.inet.tcp.blackhole</varname> auf
	<literal>2</literal> und
	<varname>net.inet.udp.blackhole</varname> auf
	<literal>1</literal>.  Weitere Informationen zu diesen
	Einstellungen finden Sie in &man.blackhole.4;.</para>

      <para>Die Einstellung
	<varname>net.inet.icmp.drop_redirect</varname> hilft dabei,
	sogenannte Redirect-Angriffe zu verhindern.  Ein
	Redirect-Angriff ist eine Art von <acronym>DoS</acronym>, die
	massenhaft <acronym>ICMP</acronym>-Pakete Typ 5 versendet.  Da
	solche Pakete nicht benötigt werden, setzen Sie
	<varname>net.inet.icmp.drop_redirect</varname> auf
	<literal>1</literal> und
	<varname>net.inet.ip.redirect</varname> auf
	<literal>0</literal>.</para>

      <para><foreignphrase>Source Routing</foreignphrase> zur
	Erfassung und zum Zugriff auf nicht-routbare Adressen im
	internen Netzwerk.  Dies sollte deaktiviert werden, da
	nicht-routbare Adressen in der Regel nicht absichtlich
	geroutet werden.  Um diese Funktion zu deaktivieren, setzen
	Sie <varname>net.inet.ip.sourceroute</varname> und
	<varname>net.inet.accept_sourceroute</varname> auf
	<literal>0</literal>.</para>

      <para>Wenn ein Netzwerkgerät Nachrichten an alle Rechner in
	einem Subnetz senden muss, wird eine
	<acronym>ICMP</acronym>-Echo-Request Nachricht an die
	Broadcast-Adresse gesendet.  Allerdings gibt es keinen guten
	Grund für externe Rechner, solche Nachrichten zu verschicken.
	Um alle externen Broadcast-Anfragen abzulehnen, setzen Sie
	<varname>net.inet.icmp.bmcastecho</varname> auf
	<literal>0</literal>.</para>

      <para>Einige zusätzliche Einstellungen sind in &man.security.7;
	dokumentiert.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="one-time-passwords">
    <title>Einmalpasswörter</title>

    <indexterm><primary>Einmalpasswörter</primary></indexterm>
    <indexterm>
      <primary>Sicherheit</primary>
      <secondary>Einmalpasswörter</secondary>
    </indexterm>

    <para>In der Voreinstellung unterstützt &os;
      <foreignphrase>One-time Passwords in Everything</foreignphrase>
      (<acronym>OPIE</acronym>).  <acronym>OPIE</acronym> wurde
      konzipiert um Replay-Angriffe zu verhindern, bei dem ein
      Angreifer das Passwort eines Benutzers ausspäht und es
      benutzt, um Zugriff auf ein System zu erlangen.  Da ein Passwort
      unter <acronym>OPIE</acronym> nur einmal benutzt wird, ist ein
      ausgespähtes Passwort für einen Angreifer nur von geringem
      Nutzen.  <acronym>OPIE</acronym> verwendet eine sichere
      Hash-Funktion und ein Challenge/Response-System, um Passwörter
      zu verwalten.  Die &os;-Implementation verwendet in der
      Voreinstellung die <acronym>MD5</acronym>-Hash-Funktion.</para>

    <para><acronym>OPIE</acronym> verwendet drei verschiedene Arten
      von Passwörtern.  Das erste ist das normale &unix;- oder
      Kerberos-Passwort.  Das zweite ist das Einmalpasswort, das von
      <command>opiekey</command> generiert wird.  Das dritte Passwort
      ist das <quote>geheime Passwort</quote>, das zum Erstellen der
      Einmalpasswörter verwendet wird.  Das geheime Passwort steht in
      keiner Beziehung zum &unix;-Passwort und beide Passwörter
      sollten unterschiedlich sein.</para>

    <para>Es gibt noch zwei weitere Werte, die für
      <acronym>OPIE</acronym> wichtig sind.  Der erste ist der
      <quote>Initialwert</quote> (engl.
      <foreignphrase>seed</foreignphrase> oder
      <foreignphrase>key</foreignphrase>), der aus zwei Buchstaben und
      fünf Ziffern besteht.  Der zweite Wert ist der
      <quote>Iterationszähler</quote>, eine Zahl zwischen 1 und 100.
      <acronym>OPIE</acronym> generiert das Einmalpasswort, indem
      es den Initialwert und das geheime Passwort aneinander hängt
      und dann die <acronym>MD5</acronym>-Hash-Funktion so oft, wie
      durch den Iterationszähler gegeben, anwendet.  Das Ergebnis wird
      in sechs englische Wörter umgewandelt, die das Einmalpasswort
      ergeben.  Das Authentifizierungssystem (meistens PAM) merkt sich
      das zuletzt benutzte Einmalpasswort und der Benutzer ist
      authentifiziert, wenn die Hash-Funktion des Passworts dem
      vorigen Passwort entspricht.  Da nicht umkehrbare
      Hash-Funktionen benutzt werden, ist es unmöglich, aus einem
      bekannten Passwort weitere gültige Einmalpasswörter zu
      berechnen.  Der Iterationszähler wird nach jeder erfolgreichen
      Anmeldung um eins verringert und stellt so die Synchronisation
      zwischen Benutzer und Login-Programm sicher.  Wenn der
      Iterationszähler den Wert <literal>1</literal> erreicht, muss
      <acronym>OPIE</acronym> neu initialisiert werden.</para>

    <para>Es gibt ein paar Programme, die in diesen Prozess einbezogen
      werden.  Ein Einmalpasswort oder eine Liste von
      Einmalpasswörtern, die von &man.opiekey.1; durch Angabe eines
      Iterationszählers, eines Initalwertes und einem geheimen
      Passwort generiert wird.  &man.opiepasswd.1; wird benutzt, um
      Passwörter, Iterationszähler oder Initialwerte zu ändern.
      &man.opieinfo.1; hingegen gibt den momentanen Iterationszähler
      und Initialwert eines Benutzers aus, den es aus
      <filename>/etc/opiekeys</filename> ermittelt.</para>
      <!-- Credential Dateien -->

    <para>Dieser Abschnitt beschreibt vier verschiedene Arten von
      Tätigkeiten.  Zuerst wird erläutert, wie Einmalpasswörter über
      eine gesicherte Verbindung konfiguriert werden.  Als nächstes
      wird erklärt, wie <command>opiepasswd</command> über
      eine nicht gesicherte Verbindung eingesetzt wird.  Als drittes
      wird beschrieben, wie man sich über eine nicht gesicherte
      Verbindung anmeldet.  Die vierte Tätigkeit beschreibt, wie man
      eine Reihe von Schlüsseln generiert, die man sich aufschreiben
      oder ausdrucken kann, um sich von Orten anzumelden, die über
      keine gesicherten Verbindungen verfügen.</para>

    <sect2>
      <title><acronym>OPIE</acronym> initialisieren</title>

      <para>Um <acronym>OPIE</acronym> erstmals zu initialisieren,
	rufen Sie &man.opiepasswd.1; über eine gesicherte Verbindung
	auf:</para>

      <screen>&prompt.user; <userinput>opiepasswd -c</userinput>
[grimreaper] ~ $ opiepasswd -f -c
Adding unfurl:
Only use this method from the console; NEVER from remote. If you are using
telnet, xterm, or a dial-in, type ^C now or exit with no password.
Then run opiepasswd without the -c parameter.
Using MD5 to compute responses.
Enter new secret pass phrase:
Again new secret pass phrase:

ID unfurl OTP key is 499 to4268
MOS MALL GOAT ARM AVID COED</screen>

      <para>Die Option <option>-c</option> startet den Konsolen-Modus,
	der davon ausgeht, dass der Befehl von einem sicherem Ort
	ausgeführt wird.  Dies kann beispielsweise der eigene Rechner
	sein, oder über eine mit <acronym>SSH</acronym> gesicherte
	Verbindung zum eigenen Rechner.</para>

      <para>Geben Sie das geheime Passwort ein, wenn Sie danach
	gefragt werden.  Damit werden die Einmalpasswörter generiert.
	Dieses Passwort sollte schwer zu erraten sein und sich
	ebenfalls vom Passwort des Bentuzerkontos unterscheiden.  Es
	muss zwischen 10 und 127 Zeichen lang sein.  Prägen Sie sich
	dieses Passwort gut ein!</para>

      <para>Die Zeile, die mit <quote>ID</quote> beginnt, enthält den
	Login-Namen (<literal>unfrul</literal>), den voreingestellten
	Iterationszähler (<literal>499</literal>) und den Initialwert
	(<literal>to4268</literal>).  Das System erinnert sich an
	diese Parameter und wird sie bei einem Anmeldeversuch
	anzeigen.  Sie brauchen sich diese Dinge also nicht merken.
	Die letzte Zeile enthält das generierte Einmalpasswort, das
	aus den Parametern und dem geheimen Passwort ermittelt wurde.
	Bei der nächsten Anmeldung muss dann diese Einmalpasswort
	benutzt werden.</para>
    </sect2>

    <sect2>
      <title>Initialisierung über eine nicht gesicherte
	Verbindung</title>

      <para>Um Einmalpasswörter über eine nicht gesicherte Verbindung
	zu initialisieren, oder das geheime Passwort zu ändern, müssen
	Sie über eine gesicherte Verbindung zu einer Stelle verfügen,
	an der Sie <command>opiekey</command> ausführen können.  Dies
	kann etwa die Eingabeaufforderung auf einer Maschine sein, der
	Sie vertrauen.  Zudem müssen Sie einen Iterationszähler
	vorgeben (100 ist ein guter Wert) und einen Initialwert
	wählen, wobei Sie auch einen zufällig generierten benutzen
	können.  Benutzen Sie &man.opiepasswd.1; über die ungesicherte
	Verbindung zu der Maschine, die Sie einrichten wollen:</para>

      <screen>&prompt.user; <userinput>opiepasswd</userinput>

Updating unfurl:
You need the response from an OTP generator.
Old secret pass phrase:
        otp-md5 498 to4268 ext
        Response: GAME GAG WELT OUT DOWN CHAT
New secret pass phrase:
        otp-md5 499 to4269
        Response: LINE PAP MILK NELL BUOY TROY

ID mark OTP key is 499 gr4269
LINE PAP MILK NELL BUOY TROY</screen>

      <para>Drücken Sie <keycap>Return</keycap>, um die Vorgabe
	für den Initialwert zu akzeptieren.  Bevor
	Sie nun das Zugriffspasswort
	(engl. <foreignphrase>access password</foreignphrase>)
	eingeben, rufen Sie über die gesicherte Verbindung
	<command>opikey</command> mit denselben Parametern auf:</para>

      <screen>&prompt.user; <userinput>opiekey 498 to4268</userinput>
Using the MD5 algorithm to compute response.
Reminder: Don not use opiekey from telnet or dial-in sessions.
Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT</screen>

      <para>Gehen Sie zurück zu der nicht gesicherten Verbindung
	und geben dort das eben generierte Einmalpasswort ein.</para>
    </sect2>

    <sect2>
      <title>Erzeugen eines einzelnen Einmalpasswortes</title>

      <para>Nachdem Sie <acronym>OPIE</acronym> eingerichtet haben,
	werden Sie beim nächsten Anmelden wie folgt begrüßt:</para>

      <screen>&prompt.user; <userinput>telnet example.com</userinput>
Trying 10.0.0.1...
Connected to example.com
Escape character is '^]'.

FreeBSD/i386 (example.com) (ttypa)

login: <userinput>&lt;username&gt;</userinput>
otp-md5 498 gr4269 ext
Password: </screen>

      <para><acronym>OPIE</acronym> besitzt eine nützliche
	Eigenschaft.  Wenn Sie an der Eingabeaufforderung
	<keycap>Return</keycap> drücken, wird die echo-Funktion
	eingeschaltet, das heißt Sie sehen, was Sie tippen.  Dies ist
	besonders nützlich, wenn Sie ein generiertes Passwort von
	einem Ausdruck abtippen müssen.</para>

      <indexterm><primary>MS-DOS</primary></indexterm>
      <indexterm><primary>Windows</primary></indexterm>
      <indexterm><primary>MacOS</primary></indexterm>

      <para>Jetzt müssen Sie das Einmalpasswort generieren,
	um der Anmeldeaufforderung nachzukommen.  Dies muss auf
	einem gesicherten System geschehen, auf dem Sie
	&man.opiekey.1; ausführen können.  Dieses Programm gibt es
	auch für &windows;, &macos; und &os;.  Es benötigt den
	Iterationszähler sowie den Initialwert als Parameter, die Sie
	mittels <quote>cut-and-paste</quote> direkt von der
	Login-Aufforderung nehmen können.</para>

      <para>Auf dem sicheren System:</para>

      <screen>&prompt.user; <userinput>opiekey 498 to4268</userinput>
Using the MD5 algorithm to compute response.
Reminder: Do not use opiekey from telnet or dial-in sessions.
Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT</screen>

      <para>Sobald das Einmalpasswort generiert wurde, können Sie die
	Anmeldeprozedur fortsetzen.</para>
    </sect2>

    <sect2>
      <title>Erzeugen von mehreren Einmalpasswörtern</title>

      <para>Manchmal haben Sie keinen Zugriff auf eine sichere
	Maschine oder eine sichere Verbindung.  In diesem Fall können
	Sie vorher mit &man.opiekey.1; einige Einmalpasswörter
	generieren.  Zum Beispiel:</para>

      <screen>&prompt.user; <userinput>opiekey -n 5 30 zz99999</userinput>
Using the MD5 algorithm to compute response.
Reminder: Do not use opiekey from telnet or dial-in sessions.
Enter secret pass phrase: <userinput>&lt;secret password&gt;</userinput>
26: JOAN BORE FOSS DES NAY QUIT
27: LATE BIAS SLAY FOLK MUCH TRIG
28: SALT TIN ANTI LOON NEAL USE
29: RIO ODIN GO BYE FURY TIC
30: GREW JIVE SAN GIRD BOIL PHI</screen>

      <para>Mit <option>-n 5</option> fordern Sie fünf
	Passwörter der Reihe nach an.  Der letzte
	Iterationszähler wird durch <option>30</option> gegeben.
	Beachten Sie bitte, dass die Passwörter in der
	<emphasis>umgekehrten</emphasis> Reihenfolge, in der sie
	zu benutzen sind, ausgeben werden.  Wirklich paranoide
	Benutzer können sich jetzt die Passwörter aufschreiben oder
	ausdrucken.  Sie sollten die Passwörter nach Gebrauch
	durchstreichen.</para>
    </sect2>

    <sect2>
      <title>Einschränken der Benutzung von
	System-Passwörtern</title>

      <para><acronym>OPIE</acronym> kann die Verwendung von
	&unix;-Passwörtern abhängig von der
	<acronym>IP</acronym>-Adresse einschränken.  Die dazu nötigen
	Einstellungen werden in <filename>/etc/opieaccess</filename>
	vorgenommen, die bei der Installation des Systems automatisch
	erzeugt wird.  Weitere Informationen über diese Datei und
	Sicherheitshinweise zu ihrer Verwendung finden Sie in
	&man.opieaccess.5;.</para>

      <para><filename>opieaccess</filename> könnte
	beispielsweise die folgende Zeile enthalten:</para>

      <programlisting>permit 192.168.0.0 255.255.0.0</programlisting>

      <para>Diese Zeile erlaubt es Benutzern, die sich von einer der
	angegebenen <acronym>IP</acronym>-Adressen anmelden, ihr
	&unix;-Passwort zu verwenden.  Beachten Sie bitte, dass eine
	<acronym>IP</acronym>-Adresse leicht gefälscht werden
	kann.</para>

      <para>Findet sich in <filename>opieaccess</filename> kein
	passender Eintrag, muss die Anmeldung mit
	<acronym>OPIE</acronym> erfolgen.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="tcpwrappers">
    <info>
      <title>TCP Wrapper</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	  </personname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>TCP Wrapper</primary>
    </indexterm>

    <para><application>TCP Wrapper</application> ist ein
      rechnerbasiertes Zugriffskontrollsystem, das die Fähigkeiten von
      <xref linkend="network-inetd"/> erweitert.  Beispielsweise
      können Verbindungen protokolliert, Nachrichten zurückgesandt
      oder nur interne Verbindungen angenommen werden.  Weitere
      Informationen über <application>TCP Wrapper</application> und
      dessen Funktionen finden Sie in &man.tcpd.8;.</para>

    <para><application>TCP Wrapper</application> sollten nicht als
      Ersatz für eine ordentlich konfigurierte Firewall angesehen
      werden.  Stattdessen sollten
      <application>TCP Wrapper</application> in Verbindung mit einer
      Firewall und anderen Sicherheitsmechanismen eingesetzt werden,
      um bei der Umsetzung einer Sicherheitsrichtlinie eine weitere
      Sicherheitsschicht zu bieten.</para>

    <sect2>
      <title>Konfiguration</title>

      <para>Um <application>TCP Wrapper</application> unter &os; zu
	aktivieren, fügen Sie die folgenden Zeilen in
	<filename>/etc/rc.conf</filename> ein:</para>

      <programlisting>inetd_enable="YES"
inetd_flags="-Ww"</programlisting>

      <para>Anschließend muss <filename>/etc/hosts.allow</filename>
	richtig konfiguriert werden.</para>

      <note>
	<para>Im Gegensatz zu anderen Implementierungen der
	  <application>TCP Wrapper</application> wird unter &os; vom
	  Gebrauch der Datei <filename>hosts.deny</filename>
	  abgeraten.  Die Konfiguration sollte sich vollständig in
	  <filename>/etc/hosts.allow</filename> befinden.</para>
      </note>

      <para>In der einfachsten Konfiguration werden Dienste abhängig
	von den Optionen in <filename>/etc/hosts.allow</filename>
	erlaubt oder gesperrt.  Unter &os; wird in der Voreinstellung
	jeder von <application>inetd</application> gestartete Dienst
	erlaubt.</para>

      <para>Eine Konfigurationszeile ist wie folgt aufgebaut:
	<literal>Dienst : Adresse : Aktion</literal>.
	<literal>Dienst</literal> ist der von
	<application>inetd</application> gestartete Dienst (auch
	Daemon genannt).  Die <literal>Adresse</literal> ist ein
	gültiger Rechnername, eine <acronym>IP</acronym>-Adresse oder
	eine <acronym>IPv6</acronym>-Adresse in Klammern
	(<literal>[</literal>&nbsp;<literal>]</literal>).  Der Wert
	<literal>allow</literal> im Feld <literal>Aktion</literal>
	erlaubt Zugriffe, der Wert <literal>deny</literal> verbietet
	Zugriffe.  Die Zeilen in <filename>hosts.allow</filename>
	werden für jede Verbindung der Reihe nach abgearbeitet.
	Trifft eine Zeile auf eine Verbindung zu, wird die
	entsprechende Aktion ausgeführt und die Abarbeitung ist
	beendet.</para>

      <para>Um beispielsweise einkommende
	<acronym>POP</acronym>3-Verbindungen für den Dienst
	<package>mail/qpopper</package> zu erlauben, sollte
	<filename>hosts.allow</filename> um die nachstehende Zeile
	erweitert werden:</para>

      <programlisting># This line is required for POP3 connections:
qpopper : ALL : allow</programlisting>

      <para>Jedes Mal, wenn diese Datei bearbeitet wird, muss
	<application>inetd</application> neu gestartet werden:</para>

      <screen>&prompt.root; <userinput>service inetd restart</userinput></screen>
    </sect2>

    <sect2>
      <title>Erweiterte Konfiguration</title>

      <para><application>TCP Wrapper</application> besitzen weitere
	Optionen, die bestimmen, wie Verbindungen behandelt werden.
	In einigen Fällen ist es gut, wenn bestimmten Rechnern oder
	Diensten eine Nachricht geschickt wird.  In anderen Fällen
	soll vielleicht der Verbindungsaufbau protokolliert oder eine
	E-Mail an einen Administrator versandt werden.  Oder ein
	Dienst soll nur für das lokale Netz bereitstehen.  Dies alles
	ist mit so genannten Wildcards, Metazeichen und der Ausführung
	externer Programme möglich.</para>

      <para>Stellen Sie sich vor, eine Verbindung soll verhindert
	werden und gleichzeitig soll dem Rechner, der die Verbindung
	aufgebaut hat, eine Nachricht geschickt werden.  Solch eine
	Aktion ist mit <option>twist</option> möglich.
	<option>twist</option> führt beim Verbindungsaufbau ein
	Kommando oder ein Skript aus.  Ein Beispiel ist in
	<filename>hosts.allow</filename> enthalten:</para>

      <programlisting># Alle anderen Dienste sind geschützt
ALL : ALL \
        : severity auth.info \
        : twist /bin/echo "You are not welcome to use %d from %h."</programlisting>

      <para>Für jeden Dienst, der nicht vorher in
	<filename>hosts.allow</filename> konfiguriert wurde, wird die
	Meldung <quote>You are not allowed to use
	  <replaceable>daemon name</replaceable> from
	  <replaceable>hostname</replaceable>.</quote> zurückgegeben.
	Dies ist nützlich, wenn die Gegenstelle sofort benachrichtigt
	werden soll, nachdem die Verbindung getrennt wurde.  Der Text
	der Meldung <emphasis>muss</emphasis> in Anführungszeichen
	(<literal>"</literal>) stehen.</para>

      <warning>
	<para>Ein so konfigurierter Server ist anfällig für
	  Denial-of-Service-Angriffe.  Ein Angreifer kann die
	  gesperrten Dienste mit Verbindungsanfragen
	  überfluten.</para>
      </warning>

      <para>Eine weitere Möglichkeit bietet <option>spawn</option>.
	Wie <option>twist</option> verbietet <option>spawn</option>
	die Verbindung und führt externe Kommandos aus.  Allerdings
	sendet <option>spawn</option> dem Rechner keine Rückmeldung.
	Sehen Sie sich die nachstehende Konfigurationsdatei an:</para>

      <programlisting># Verbindungen von example.com sind gesperrt:
ALL : .example.com \
	: spawn (/bin/echo %a from %h attempted to access %d &gt;&gt; \
	  /var/log/connections.log) \
	: deny</programlisting>

      <para>Damit sind Verbindungen von der Domain <systemitem
	  class="fqdomainname">*.example.com</systemitem> gesperrt.
	Jeder Verbindungsaufbau wird zudem in
	<filename>/var/log/connections.log</filename> protokolliert.
	Das Protokoll enthält den Rechnernamen, die
	<acronym>IP</acronym>-Adresse und den Dienst, der angesprochen
	wurde.  In diesem Beispiel wurden die Metazeichen
	<literal>%a</literal> und <literal>%h</literal> verwendet.
	Eine vollständige Liste der Metazeichen finden Sie in
	&man.hosts.access.5;.</para>

      <para>Die Wildcard <literal>ALL</literal> passt auf jeden
	Dienst, jede Domain oder jede <acronym>IP</acronym>-Adresse.
	Eine andere Wildcard ist <literal>PARANOID</literal>.  Sie
	passt auf jeden Rechner, dessen
	<acronym>IP</acronym>-Adresse möglicherweise gefälscht ist.
	Dies ist beispielsweise der Fall, wenn der Verbindungsaufbau
	von einer <acronym>IP</acronym>-Adresse erfolgt, die nicht zu
	dem übermittelten Rechnernamen passt.  In diesem Beispiel
	werden alle Verbindungsanfragen zu
	<application>Sendmail</application> abgelehnt, wenn die
	<acronym>IP</acronym>-Adresse nicht zum Rechnernamen
	passt:</para>

      <programlisting># Block possibly spoofed requests to sendmail:
sendmail : PARANOID : deny</programlisting>

      <caution>
	<para>Die Wildcard <literal>PARANOID</literal> wird
	  Verbindungen ablehnen, wenn der Client oder der Server eine
	  fehlerhafte <acronym>DNS</acronym>-Konfiguration
	  besitzt.</para>
      </caution>

      <para>Weitere Informationen über Wildcards und deren Funktion
	finden Sie in &man.hosts.access.5;.</para>

      <note>
	<para>Wenn Sie neue Einträge zur Konfiguration hinzufügen,
	  sollten Sie sicherstellen, dass nicht benötigte Einträge in
	  <filename>hosts.allow</filename> auskommentiert
	  werden.</para>
      </note>
    </sect2>
  </sect1>

  <sect1 xml:id="kerberos5">
    <info>
      <title><application>Kerberos</application></title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Tillman</firstname>
	    <surname>Hodgson</surname>
	  </personname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <personname>
	    <firstname>Mark</firstname>
	    <surname>Murray</surname>
	  </personname>
	  <contrib>Beruht auf einem Beitrag von </contrib>
	</author>
      </authorgroup>
    </info>

    <para><application>Kerberos</application> ist ein
      Netzwerk-Authentifizierungsprotokoll, das ursprünglich am
      Massachusetts Institute of Technology (<acronym>MIT</acronym>)
      entwickelt wurde.  Es bietet die Möglichkeit zur sicheren
      Authentifizierung über ein potentiell unsicheres Netzwerk.  Das
      <application>Kerberos</application>-Protokoll benutzt eine
      starke Kryptographie, um die Identität von Clients und Servern
      nachweisen zu können.  Dabei werden keine unverschlüsselten
      Daten über das Netzewrk gesendet.
      <application>Kerberos</application> kann als eine Art Proxy zur
      Identitätsprüfung, oder als vertrauenswürdiges
      Authentifizierungssystem betrachtet werden.</para>

    <para><application>Kerberos</application> hat nur eine Aufgabe:
      Die sichere Prüfung der Identität eines Benutzers
      (Authentifizierung) über das Netzwerk.  Das System
      überprüft weder die Berechtigungen der Benutzer
      (Autorisierung), noch verfolgt es die durchgeführten
      Aktionen (Audit).  Daher sollte
      <application>Kerberos</application> zusammen mit anderen
      Sicherheits-Systemen eingesetzt werden, die diese Funktionen
      bereitstellen.</para>

    <para>Die aktuelle Version des Protokolls ist Version 5, die in
      <acronym>RFC</acronym>&nbsp;4120 beschrieben ist.  Es existieren
      mehrere freie Implementierungen dieses Protokolls für eine Reihe
      von Betriebssystemen.  Das <acronym>MIT</acronym> entwickelt
      auch weiterhin seine
      <application>Kerberos</application>-Version weiter.
      Es wird in den vereinigten Staaten als Kryptographie-Produkt
      eingesetzt und unterlag in der Vergangenheit
      <acronym>US</acronym>-Exportbeschränkungen.  In &os; ist
      <acronym>MIT</acronym>-<application>Kerberos</application> als
      Port oder Paket <package>security/krb5</package>
      verfügbar.  Die
      <application>Kerberos</application>-Implementation von Heimdal
      wurde außerhalb der <acronym>USA</acronym> entwickelt und
      unterliegt daher keinen Export-Beschränkungen.
      Heimdal-<application>Kerberos</application> ist im Basissystem
      von &os; enthalten.  Mit <package>security/heimdal</package> aus
      der Ports-Sammlung steht eine weitere Distribution, mit mehr
      konfigurierbaren Optionen zur Verfügung.</para>

    <para>Unter <application>Kerberos</application> werden Benutzer
      und Dienste als <quote>Prinzipale</quote> bezeichnet, die
      innerhalb einer administrativen Domäne, dem sogenannten
      <quote>Realm</quote> enthalten sind.  Ein typisches
      Benutzer-Prinzipal hätte das Format
      <literal><replaceable>user</replaceable>@<replaceable>REALM</replaceable></literal>
      (Realms sind traditionell in Großbuchstaben).</para>

    <para>Die folgenden Anweisungen beschreiben, wie Sie das mit
      &os; gelieferte Heimdal-<application>Kerberos</application>
      einrichten.</para>

    <para>Die Beschreibung der
      <application>Kerberos</application>-Installation benutzt
      folgende Namensräume:</para>

    <itemizedlist>
      <listitem>
	<para>Die <acronym>DNS</acronym>-Domain (<quote>Zone</quote>)
	  heißt <systemitem
	    class="fqdomainname">example.org</systemitem>.</para>
      </listitem>

      <listitem>
	<para>Das <application>Kerberos</application>-Realm
	  heißt <literal>EXAMPLE.ORG</literal>.</para>
      </listitem>
    </itemizedlist>

    <note>
      <para>Benutzen Sie echte Domain-Namen, wenn Sie
	<application>Kerberos</application> einrichten.  Damit
	vermeiden Sie <acronym>DNS</acronym>-Probleme und stellen
	die Zusammenarbeit mit anderen
	<application>Kerberos</application>-Realms sicher.</para>
    </note>

    <sect2>
      <title>Das Heimdal <acronym>KDC</acronym> einrichten</title>

      <indexterm>
	<primary>Kerberos5</primary>
	<secondary>Key Distribution Center</secondary>
      </indexterm>

      <para><application>Kerberos</application> authentifiziert
	Benutzer an einer zentralen Stelle: dem Key Distribution
	Center (<acronym>KDC</acronym>).  Das <acronym>KDC</acronym>
	verteilt <firstterm>Tickets</firstterm>, mit denen ein
	Dienst die Identität eines Benutzers feststellen kann.
	Weil alle Mitglieder eines
	<application>Kerberos</application>-Realms dem
	<acronym>KDC</acronym> vertrauen, gelten für das
	<acronym>KDC</acronym> erhöhte Sicherheitsanforderungen.
	Der direkte Zugriff auf das <acronym>KDC</acronym> sollte
	daher eingeschränkt sein.</para>

      <para>Obwohl der <application>Kerberos</application>-Server
	wenig Ressourcen benötigt, sollte das <acronym>KDC</acronym>
	wegen der Sicherheitsanforderungen auf einem separaten Rechner
	installiert werden.</para>

      <para>Das <acronym>KDC</acronym> wird in
	<filename>/etc/rc.conf</filename> wie folgt aktiviert:</para>

      <programlisting>kdc_enable="YES"
kadmind_enable="YES"</programlisting>

      <para>Danach wird <filename>/etc/krb5.conf</filename>
	wie folgt bearbeitet:</para>

      <programlisting>[libdefaults]
    default_realm = <replaceable>EXAMPLE.ORG</replaceable>
[realms]
    <replaceable>EXAMPLE.ORG</replaceable> = {
	kdc = <replaceable>kerberos.example.org</replaceable>
	admin_server = <replaceable>kerberos.example.org</replaceable>
    }
[domain_realm]
    <replaceable>.example.org</replaceable> = <replaceable>EXAMPLE.ORG</replaceable></programlisting>

      <para>Diese Einstellungen setzen voraus, dass der voll
	qualifizierte Name des <acronym>KDC</acronym>s
	<systemitem
	  class="fqdomainname">kerberos.example.org</systemitem> ist.
	Der Rechnername des <acronym>KDC</acronym> muss im
	<acronym>DNS</acronym> auflösbar sein.</para>

      <para>In großen Netzwerken mit einem ordentlich konfigurierten
	<acronym>DNS</acronym>-Server kann die Datei aus dem obigen
	Beispiel verkürzt werden:</para>

      <programlisting>[libdefaults]
      default_realm = <replaceable>EXAMPLE.ORG</replaceable>
[domain_realm]
    <replaceable>.example.org</replaceable> = <replaceable>EXAMPLE.ORG</replaceable></programlisting>

      <para>Die Zonendatei von <systemitem
	  class="fqdomainname">example.org</systemitem> muss dann die
	folgenden Zeilen enthalten:</para>

      <programlisting>_kerberos._udp      IN  SRV     01 00 88 <replaceable>kerberos.example.org</replaceable>.
_kerberos._tcp      IN  SRV     01 00 88 <replaceable>kerberos.example.org</replaceable>.
_kpasswd._udp       IN  SRV     01 00 464 <replaceable>kerberos.example.org</replaceable>.
_kerberos-adm._tcp  IN  SRV     01 00 749 <replaceable>kerberos.example.org</replaceable>.
_kerberos           IN  TXT     <replaceable>EXAMPLE.ORG</replaceable></programlisting>

      <note>
	<para>Damit die Clients die
	  <application>Kerberos</application>-Dienste benutzen
	  können, <emphasis>muss</emphasis> sie entweder eine
	  vollständig konfigurierte
	  <filename>/etc/krb5.conf</filename> enthalten, oder eine
	  minimale Konfiguration <emphasis>und</emphasis> zusätzlich
	  ein richtig konfigurierter
	  <acronym>DNS</acronym>-Server.</para>
      </note>

      <para>Im nächsten Schritt wird die
	<application>Kerberos</application>-Datenbank eingerichtet.
	Die Datenbank enthält die Schlüssel aller Prinzipale
	und ist mit einem Passwort geschützt.  Dieses Passwort
	brauchen Sie sich nicht merken, da ein davon abgeleiteter
	Schlüssel in <filename>/var/heimdal/m-key</filename>
	gespeichert wird.  Es wäre durchaus sinnvoll, ein 45-stelliges
	Zufallspasswort für diesen Zweck zu benutzten.  Um den
	Schlüssel zu erstellen, rufen Sie <command>kstash</command>
	auf und geben Sie ein Passwort ein:</para>

      <screen>&prompt.root; <userinput>kstash</userinput>
Master key: <userinput><replaceable>xxxxxxxxxxxxxxxxxxxxxxx</replaceable></userinput>
Verifying password - Master key: <userinput><replaceable>xxxxxxxxxxxxxxxxxxxxxxx</replaceable></userinput></screen>

      <para>Nachdem der Schlüssel erstellt wurde, sollte die Datenbank
	initialisiert werden.  Das
	<application>Kerberos</application>-Werkzeug &man.kadmin.8;
	kann die Datenbank mit <command>kadmin -l</command> direkt
	bearbeiten, ohne dabei den Netzwerkdienst &man.kadmind.8; zu
	benutzen.  An der Eingabeaufforderung von
	<command>kadmin</command> kann mit <command>init</command> die
	Datenbank des Realms initialisiert werden:</para>

      <screen>&prompt.root; <userinput>kadmin -l</userinput>
kadmin&gt; <userinput>init <replaceable>EXAMPLE.ORG</replaceable></userinput>
Realm max ticket life [unlimited]:</screen>

      <para>Zuletzt wird mit <command>add</command> das erste
	Prinzipal erstellt.  Benutzen Sie die voreingestellten
	Optionen.  Die Einstellungen können später mit
	<command>modify</command> verändert werden.  An der
	Eingabeaufforderung von &man.kadmin.8; zeigt
	<command>?</command> die verfügbaren Optionen an.</para>

      <screen>kadmin&gt; <userinput>add <replaceable>tillman</replaceable></userinput>
Max ticket life [unlimited]:
Max renewable life [unlimited]:
Attributes []:
Password: <userinput><replaceable>xxxxxxxx</replaceable></userinput>
Verifying password - Password: <userinput><replaceable>xxxxxxxx</replaceable></userinput></screen>

      <para>Jetzt können die <acronym>KDC</acronym>-Dienste mit
	<command>service kdc start</command> und
	<command>service kadmind start</command> gestartet werden.
	Obwohl zu diesem Zeitpunkt noch keine kerberisierten Dienste
	laufen, kann die Funktion des <acronym>KDC</acronym>s
	schon überprüft werden, indem Sie für den eben angelegten
	Benutzer ein Ticket anfordern:</para>

      <screen>&prompt.user; <userinput>kinit <replaceable>tillman</replaceable></userinput>
tillman@EXAMPLE.ORG's Password:</screen>

      <para>Überprüfen Sie, ob das Ticket erfolgreich ausgestellt
	wurde:</para>

      <screen>&prompt.user; <userinput>klist</userinput>
Credentials cache: FILE: /tmp/krb5cc_1001
        Principal: tillman@EXAMPLE.ORG

  Issued                Expires               Principal
Aug 27 15:37:58 2013  Aug 28 01:37:58 2013  krbtgt/EXAMPLE.ORG@EXAMPLE.ORG</screen>

      <para>Nachdem der Test abgeschlossen ist, kann das temporäre
	Ticket zurückgezogen werden:</para>

      <screen>&prompt.user; <userinput>kdestroy</userinput></screen>
    </sect2>

    <sect2>
      <title><application>Kerberos</application>-Dienste auf dem
	Server einrichten</title>

      <indexterm>
	<primary>Kerberos5</primary>
	<secondary>Dienste einrichten</secondary>
      </indexterm>

      <para>Bei der Konfiguration eines Servers für die
	<application>Kerberos</application>-Authentifizierung muss
	zuerst sichergestellt werden, dass
	<filename>/etc/krb5.conf</filename> richtig konfiguriert ist.
	Die Datei kann entweder vom <acronym>KDC</acronym> kopiert,
	oder auf dem neuen System generiert werden.</para>

      <para>Als nächstes muss auf dem Server die
	<filename>/etc/krb5.keytab</filename> erzeugt werden.  Dies
	ist der Hauptbestandteil um Dienste zu
	<quote>kerberisieren</quote> und entspricht der Erzeugung
	eines geheimen Schlüssels zwischen dem Dienst und dem
	<application>KDC</application>.  Das Geheimnis ist ein
	kryptographischer Schlüssel, der in einem
	<filename>keytab</filename>> abgelegt wird.  Diese Datei
	enthält den Schlüssel des Servers, mit dem sich der Server und
	das <acronym>KDC</acronym> gegenseitig authentifizieren
	können.  Sie muss in einer sicheren Art und Weise an den
	Server übertragen werden, da ansonsten die Sicherheit des
	Servers gefährdet ist, wenn z.B. die Schlüssel öffentlich
	werden.  In der Regel wird die <filename>keytab</filename> auf
	einem vertrauenswürdigen Rechner mit <command>kadmin</command>
	erzeugt und anschließend sicher auf den Server übertragen,
	beispielsweise mit &man.scp.1;.  Wenn die
	Sicherheitsrichtlinien es erlauben, kann die Datei auch direkt
	auf dem Server erzeugt werden.  Es ist sehr wichtig, dass die
	<filename>keytab</filename> auf sichere Weise auf den Server
	übertragen wird.  Wenn der Schlüssel einer anderen Partei
	bekannt wird, kann sich diese Partei den Benutzern als
	Server ausgeben!  Da der Eintrag für das Host-Prinzipal für
	die <acronym>KDC</acronym>-Datenbank auch mit
	<command>kadmin</command> erstellt wird, ist es praktisch,
	<command>kadmin</command> direkt auf dem Server zu
	benutzen.</para>

      <para>Natürlich ist auch <command>kadmin</command> ein
	kerberisierter Dienst: ein
	<application>Kerberos</application>-Ticket ist erforderlich,
	um sich gegenüber dem Netzwerkdienst zu authentifizieren und
	um sicherzustellen, dass der Benutzer, der
	<command>kadmin</command> ausführt, tatsächlich vorhanden ist.
	<command>kadmin</command> wird nach dem Passwort fragen, um
	ein neues Ticket zu generieren.  Das Prinzipal, das sich mit
	dem kadmin-Dienst authentifiziert, muss über die
	Zugriffskontrollliste <filename>kadmin.acl</filename> dazu
	berechtigt sein.  Weitere Informationen über
	Zugriffskontrolllisten finden Sie in den Heimdal-Info-Seiten
	(<command>info heimdal</command>) im Abschnitt
	<quote>Remote administration</quote>.  Wenn der Zugriff auf
	<command>kadmin</command> von entfernten Rechnern verboten
	ist, kann sich der Administrator entweder über die lokale
	Konsole oder über &man.ssh.1; mit dem <acronym>KDC</acronym>
	verbinden, um die lokale Administration mit
	<command>kadmin -l</command> durchzuführen.</para>

      <para>Nach der Installation von
	<filename>/etc/krb5.conf</filename>, können Sie das Kommando
	<command>add --random-key</command> in
	<command>kadmin</command> ausführen, um das Host-Prinzipal in
	die Datenbank zu schreiben.  Das Kommando
	<command>ext</command> extrahiert den Schlüssel des Prinzipals
	in eine eigene keytab:</para>

      <screen>&prompt.root; <userinput>kadmin</userinput>
kadmin&gt; <userinput>add --random-key <replaceable>host/myserver.example.org</replaceable></userinput>
Max ticket life [unlimited]:
Max renewable life [unlimited]:
Principal expiration time [never]:
Password expiration time [never]:
Attributes []:
kadmin&gt; <userinput>ext_keytab <replaceable>host/myserver.example.org</replaceable></userinput>
kadmin&gt; <userinput>exit</userinput></screen>

      <para>Beachten Sie, dass <command>ext_keytab</command> den
	extrahierten Schlüssel standardmäßig in
	<filename>/etc/krb5.keytab</filename> speichert.  Das ist
	gut, wenn das Kommando auf dem kerberisierten Server
	ausgeführt wird, ansonsten sollte das Argument
	<command>--keytab
	  <replaceable>pfad/zur/datei</replaceable></command>
	benutzt werden, wenn die keytab an einen anderen Ort
	extrahiert wird:</para>

      <screen>&prompt.root; <userinput>kadmin</userinput>
kadmin&gt; <userinput>ext_keytab --keytab=/tmp/example.keytab <replaceable>host/myserver.example.org</replaceable></userinput>
kadmin&gt; <userinput>exit</userinput></screen>

      <para>Anschließend kann die erzeugte keytab sicher mit
	&man.scp.1; auf Server oder auf einen
	Wechseldatenträger kopiert werden.  Geben Sie auf jeden Fall
	einen anderen Namen für die keytab an, um unnötige Schlüssel
	in der keytab des Systems zu vermeiden.</para>

      <para>Mit Hilfe der Datei <filename>krb5.conf</filename> kann
	der Server nun mit dem <acronym>KDC</acronym> kommunizieren
	und seine Identität mithilfe der Datei
	<filename>krb5.keytab</filename> nachweisen.  Jetzt
	können die kerberisierten Dienste aktiviert werden.  Einer der
	gebräuchlichsten Dienste ist &man.sshd.8;, der
	<application>Kerberos</application> über
	<acronym>GSS-API</acronym> unterstützt.  Fügen Sie folgende
	Zeile in <filename>/etc/ssh/sshd_config</filename> ein:</para>

      <programlisting>GSSAPIAuthentication yes</programlisting>

      <para>Nach dieser Änderung muss &man.sshd.8; mit
	<command>service sshd restart</command> neu gestartet werden,
	damit die neue Konfiguration wirksam wird.</para>
    </sect2>

    <sect2>
      <title><application>Kerberos</application> auf dem Client
	einrichten</title>

      <indexterm>
	<primary>Kerberos5</primary>
	<secondary>Clients einrichten</secondary>
      </indexterm>

      <para>Genau wie der Server, benötigt auch der Client eine
	Konfiguration in <filename>/etc/krb5.conf</filename>.
	Kopien Sie die Datei (sicher) vom <acronym>KDC</acronym>
	auf den Client, oder schreiben Sie die Datei bei Bedarf
	einfach neu.</para>

      <para>Testen Sie den Client, indem Sie mit
	<command>kinit</command> Tickets anfordern, mit
	<command>klist</command> Tickets anzeigen und mit
	<command>kdestroy</command> Tickets löschen.
	<application>Kerberos</application>-Anwendungen sollten auch
	kerberisierte Server ansprechen können.  Wenn das nicht
	funktioniert, Sie aber Tickets anfordern können, hat
	wahrscheinlich der kerberisierte Server ein Problem und nicht
	der Client oder das <acronym>KDC</acronym>.  Im Falle eines
	kerberisierten &man.ssh.1; ist <acronym>GSS-API</acronym> in
	der Voreinstellung deaktiviert.  Testen Sie daher mit
	<command>ssh -o GSSAPIAuthentication=yes
	  <replaceable>hostname</replaceable></command>.</para>

      <para>Wenn Sie die kerberisierten Anwendungen testen, können Sie
	einen Paket-Sniffer wie <command>tcpdump</command> benutzen,
	um sicherzustellen, dass keine sensiblen Informationen im
	Klartext übertragen werden.</para>

      <para>Es stehen verschiedene
	<application>Kerberos</application>-Anwendungen zur Verfügung.
	Die Anwendungen, die <acronym>SASL</acronym> benutzen, können
	dann auch <acronym>GSS-API</acronym> benutzen.  Viele Arten
	von Anwendungen können <application>Kerberos</application> zur
	Authentifizierung verwenden, vom Jabber-Client bis zum
	<acronym>IMAP</acronym>-Client.</para>

      <indexterm>
	<primary><filename>.k5login</filename></primary>
      </indexterm>
      <indexterm>
	<primary><filename>.k5users</filename></primary>
      </indexterm>

      <para>Normalerweise wird ein
	<application>Kerberos</application>-Prinzipal auf ein lokales
	Benutzerkonto abgebildet.  Manchmal wird aber Zugriff auf ein
	lokales Benutzerkonto benötigt, zu dem es keinen passenden
	<application>Kerberos</application>-Prinzipal gibt.
	Der Prinzipal <systemitem
	  class="username">tillman@EXAMPLE.ORG</systemitem> bräuchte
	beispielsweise Zugriff auf das Konto <systemitem
	  class="username">webdevelopers</systemitem>.  Ebenso könnten
	andere Prinzipale auf dieses Konto zugreifen wollen.</para>

      <para>Die Dateien <filename>.k5login</filename> und
	<filename>.k5users</filename> im Heimatverzeichnis eines
	Benutzers können verwendet werden, um dieses Problem zu lösen.
	Mit der folgenden <filename>.k5login</filename> im
	Heimatverzeichnis des Benutzers <systemitem
	  class="username">webdevelopers</systemitem> haben beide
	Prinzipale auch ohne das gemeinsame Passwort Zugriff auf das
	Konto:</para>

      <programlisting>tillmann@example.org
jdoe@example.org</programlisting>

      <para>Weitere Informationen zu <filename>.k5users</filename>
	finden Sie in &man.ksu.1;.</para>
    </sect2>

    <sect2>
      <title>Unterschiede zur
	<acronym>MIT</acronym>-Implementation</title>

      <para>Der Hauptunterschied zwischen der <acronym>MIT</acronym>-
	und der Heimdal-Implementation ist das Kommando
	<command>kadmin</command>.  Die Befehlssätze des Kommandos
	(obwohl funktional gleichwertig) und das verwendete Protokoll
	unterscheiden sich in beiden Varianten.  Das
	<acronym>KDC</acronym> lässt sich nur mit dem
	<command>kadmin</command> Kommando der passenden
	<application>Kerberos</application>-Variante verwalten.</para>

      <para>Für dieselbe Funktion können auch die
	Client-Anwendungen leicht geänderte Kommandozeilenoptionen
	besitzen.  Folgen Sie der Anleitung auf  <uri
	  xlink:href="http://web.mit.edu/Kerberos/www/">
	  http://web.mit.edu/Kerberos/www/</uri>.  Achten Sie
	besonders auf den Suchpfad für Anwendungen.  Der
	<acronym>MIT</acronym>-Port wird unter &os; standardmäßig in
	<filename>/usr/local/</filename> installiert.  Wenn die
	Umgebungsvariable <envar>PATH</envar> zuerst die
	Systemverzeichnisse enthält, werden die Systemprogramme
	anstelle der <acronym>MIT</acronym>-Programme
	ausgeführt.</para>

      <para>Wenn Sie
	<acronym>MIT</acronym>-<application>Kerberos</application>
	verwenden, sollten Sie außerdem folgende Änderungen an
	<filename>/etc/rc.conf</filename> vornehmen:</para>

      <programlisting>kerberos5_server="/usr/local/sbin/krb5kdc"
kadmind5_server="/usr/local/sbin/kadmind"
kerberos5_server_flags=""
kerberos5_server_enable="YES"
kadmind5_server_enable="YES"</programlisting>
    </sect2>

    <sect2>
      <title>Tipps und Fehlersuche</title>

      <para>Während der Konfiguration und bei der Fehlersuche sollten
	die folgenden Punkte beachtet werden:</para>

      <itemizedlist>
	<listitem>
	  <para>Wenn Sie Heimdal- oder
	    <acronym>MIT</acronym>-<application>Kerberos</application>
	    benutzen, muss in der Umgebungsvariable
	    <envar>PATH</envar> der Pfad zu den
	    <application>Kerberos</application>-Programmen vor dem
	    Pfad zu den Programmen des Systems stehen.</para>
	</listitem>

	<listitem>
	  <para>Wenn die Clients im Realm ihre Uhrzeit nicht
	    synchronisieren, schlägt vielleicht die Authentifizierung
	    fehl.  <xref linkend="network-ntp"/> beschreibt, wie
	    Sie mithilfe von <acronym>NTP</acronym> die Uhrzeiten
	    synchronisieren.</para>
	</listitem>

	<listitem>
	  <para>Wenn Sie den Namen eines Rechners ändern,
	    müssen Sie auch den <systemitem
	      class="username">host/</systemitem>-Prinzipal ändern und
	    die keytab aktualisieren.  Dies
	    betrifft auch spezielle Einträge wie den <systemitem
	      class="username">HTTP/</systemitem>-Prinzipal für
	    Apaches <package>www/mod_auth_kerb</package>.</para>
	</listitem>

	<listitem>
	  <para>Alle Rechner in einem Realm müssen vor- und
	    rückwärts aufgelöst werden können.  Entweder über
	    <acronym>DNS</acronym>, zumindest aber über
	    <filename>/etc/hosts</filename>.
	    <acronym>CNAME</acronym>-Einträge im
	    <acronym>DNS</acronym> funktionieren, aber die
	    entsprechenden A- und PTR-Einträge müssen
	    vorhanden und richtig sein.  Wenn sich Namen nicht
	    auflösen lassen, ist die Fehlermeldung nicht
	    gerade selbstsprechend: <errorname>Kerberos5 refuses
	      authentication because Read req
	      failed: Key table entry not found</errorname>.</para>
	</listitem>

	<listitem>
	  <para>Einige Betriebssysteme installieren
	    <command>ksu</command> mit falschen Zugriffsrechten;
	    es fehlt das Set-UID-Bit für <systemitem
	      class="username">root</systemitem>.  Das hat zur Folge,
	    dass <command>ksu</command> nicht funktioniert.  Dies ist
	    ein Fehler in den Zugriffsrechten und kein Fehler des
	    <acronym>KDC</acronym>s.</para>
	</listitem>

	<listitem>
	  <para>Wenn Sie für einen Prinzipal unter
	    <acronym>MIT</acronym>-<application>Kerberos</application>
	    Tickets mit einer längeren Gültigkeit als
	    der vorgegebenen zehn Stunden einrichten wollen,
	    müssen Sie zwei Sachen ändern.  Benutzen
	    Sie <command>modify_principal</command> am Prompt von
	    &man.kadmin.8;, um die maximale
	    Gültigkeitsdauer für den Prinzipal selbst und den
	    Prinzipal <systemitem class="username">krbtgt</systemitem>
	    zu erhöhen.  Das Prinzipal kann dann mit
	    <command>kinit -l</command> ein Ticket mit einer
	    längeren Gültigkeit beantragen.</para>
	</listitem>

	<listitem>
	  <para>Mit einem Packet-Sniffer können Sie feststellen, dass
	    Sie sofort nach dem Aufruf von <command>kinit</command>
	    eine Antwort vom <acronym>KDC</acronym> bekommen &ndash;
	    noch bevor Sie überhaupt ein Passwort eingegeben haben!
	    Das ist in Ordnung: Das <acronym>KDC</acronym> händigt ein
	    Ticket-Granting-Ticket (<acronym>TGT</acronym>) auf
	    Anfrage aus, da es durch einen vom Passwort des Benutzers
	    abgeleiteten Schlüssel geschützt ist.  Wenn das Passwort
	    eingegeben wird, wird es nicht zum <acronym>KDC</acronym>
	    gesendet, sondern zum Entschlüsseln der Antwort des
	    <acronym>KDC</acronym>s benutzt, die
	    <command>kinit</command> schon erhalten hat.  Wird die
	    Antwort erfolgreich entschlüsselt, erhält der Benutzer
	    einen Sitzungs-Schlüssel für die künftige verschlüsselte
	    Kommunikation mit dem <acronym>KDC</acronym> und das
	    <acronym>TGT</acronym>.  Das <acronym>TGT</acronym>
	    wiederum ist mit dem Schlüssel des <acronym>KDC</acronym>s
	    verschlüsselt.  Diese Verschlüsselung ist für den Benutzer
	    völlig transparent und erlaubt dem <acronym>KDC</acronym>,
	    die Echtheit jedes einzelnen <acronym>TGT</acronym> zu
	    prüfen.</para>
	</listitem>

	<listitem>
	  <para>Host-Prinzipale können Tickets mit längerer Gültigkeit
	    besitzen.  Wenn der Prinzipal eines Benutzers über ein
	    Ticket verfügt, das eine Woche gültig ist, das Ticket des
	    Host-Prinzipals aber nur neun Stunden gültig ist,
	    funktioniert der Ticket-Cache nicht wie erwartet.  Im
	    Cache befindet sich dann ein abgelaufenes Ticket des
	    Host-Prinzipals.</para>
	</listitem>

	<listitem>
	  <para>Wenn Sie mit <filename>krb5.dict</filename> die
	    Verwendung schlechter Passwörter verhindern wollen, wie
	    in &man.kadmin.8; beschrieben, geht das nur mit
	    Prinzipalen, denen eine Passwort-Policy zugewiesen wurde.
	    Das Format von <filename>krb5.dict</filename> enthält pro
	    Zeile ein Wort.   Sie können daher einen symbolischen Link
	    auf <filename>/usr/share/dict/words</filename>
	    erstellen.</para>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>Beschränkungen von
	<application>Kerberos</application></title>

      <indexterm>
	<primary>Kerberos5</primary>
	<secondary>Beschränkungen</secondary>
      </indexterm>

      <para><application>Kerberos</application> muss ganzheitlich
	verwendet werden.  Jeder über das Netzwerk angebotene Dienst
	muss mit <application>Kerberos</application> zusammenarbeiten
	oder auf anderen Wegen gegen Angriffe aus dem Netzwerk
	geschützt sein.  Andernfalls können Berechtigungen gestohlen
	und wiederverwendet werden.  Es ist beispielsweise nicht
	sinnvoll, für Remote-Shells
	<application>Kerberos</application> zu benutzen, dagegen aber
	<acronym>POP3</acronym>-Zugriff auf einem Mail-Server zu
	erlauben, da <acronym>POP3</acronym> Passwörter im Klartext
	versendet.</para>

      <para>Das <acronym>KDC</acronym> ist verwundbar und muss daher
	genauso abgesichert werden, wie die auf ihm befindliche
	Passwort-Datenbank.  Auf dem <acronym>KDC</acronym> sollten
	absolut keine anderen Dienste laufen und der Rechner sollte
	physikalisch gesichert sein.  Die Gefahr ist groß, da
	<application>Kerberos</application> alle Passwörter mit einem
	Schlüssel, dem Haupt-Schlüssel, verschlüsselt.  Der
	Haupt-Schlüssel wiederum wird in einer Datei auf dem
	<acronym>KDC</acronym> gespeichert.</para>

      <para>Ein kompromittierter Haupt-Schlüssel ist nicht ganz so
	schlimm wie allgemein angenommen.  Der Haupt-Schlüssel wird
	nur zum Verschlüsseln der Passwort-Datenbank und zum
	Initialisieren des Zufallsgenerators verwendet.  Solange der
	Zugriff auf das <acronym>KDC</acronym> abgesichert ist, kann
	ein Angreifer wenig mit dem Haupt-Schlüssel anfangen.</para>

      <para>Wenn das <acronym>KDC</acronym> nicht zur Verfügung steht,
	sind auch die Netzwerkdienste nicht benutzbar, da eine
	Authentifizierung nicht durchgeführt werden kann.  Das
	<acronym>KDC</acronym> ist also ein optimales Ziel für einen
	Denial-of-Service Angriff.  Sie können diesem Angriff
	entgegenwirken, indem Sie einen <acronym>KDC</acronym>-Master
	und einen oder mehrere Slaves verwenden.  Der Rückfall auf ein
	sekundäres <acronym>KDC</acronym> mittels
	<acronym>PAM</acronym>-Authentifizierung muss sorgfältig
	eingerichtet werden.</para>

      <para>Mit <application>Kerberos</application> können sich
	Benutzer, Rechner und Dienste gegenseitig authentifizieren.
	Allerdings existiert kein Mechanismus, der das
	<acronym>KDC</acronym> gegenüber Benutzern, Rechnern oder
	Diensten authentifiziert.  Ein verändertes
	<command>kinit</command> könnte beispielsweise alle
	Benutzernamen und Passwörter abfangen.  Die von veränderten
	Programmen ausgehende Gefahr können Sie lindern, indem Sie die
	Integrität von Dateien mit Werkzeugen wie
	<package>security/tripwire</package> prüfen.</para>
    </sect2>

    <sect2>
      <title>Weiterführende Dokumentation</title>

      <indexterm>
	<primary>Kerberos5</primary>
	<secondary>weiterführende Dokumentation</secondary>
      </indexterm>

      <itemizedlist>
	<listitem>
	  <para><link
	      xlink:href="http://www.faqs.org/faqs/Kerberos-faq/general/preamble.html">
	      The <application>Kerberos</application> FAQ</link></para>
	</listitem>

	<listitem>
	  <para><link
	      xlink:href="http://web.mit.edu/Kerberos/www/dialogue.html">
	      Designing an Authentication System: a Dialogue in Four
	      Scenes</link></para>
	</listitem>

	<listitem>
	  <para><link
	      xlink:href="http://www.ietf.org/rfc/rfc4120.txt?number=4120">
	      RFC 4120, The <application>Kerberos</application>
	      Network Authentication Service (V5)</link></para>
	</listitem>

	<listitem>
	  <para><link
	      xlink:href="http://web.mit.edu/Kerberos/www/">
	      <acronym>MIT</acronym>
	      <application>Kerberos</application>-Seite</link></para>
	</listitem>

	<listitem>
	  <para><link
	      xlink:href="http://www.pdc.kth.se/heimdal/">Heimdal
	      <application>Kerberos</application>-Seite</link></para>
	</listitem>
      </itemizedlist>
    </sect2>
  </sect1>

  <sect1 xml:id="openssl">
    <info>
      <title>OpenSSL</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	  </personname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>Sicherheit</primary>
      <secondary>OpenSSL</secondary>
    </indexterm>
    <indexterm><primary>OpenSSL</primary></indexterm>

    <para><application>OpenSSL</application> ist eine Open Source
      Implementierung der <acronym>SSL</acronym> und
      <acronym>TLS</acronym>-Protokolle.  Es bietet eine
      verschlüsselte Transportschicht oberhalb der
      normalen Kommunikationsschicht und kann daher zusammen
      mit vielen Netzdiensten benutzt werden.</para>

    <para>Das in &os; integrierte <application>OpenSSL</application>
      stellt die Protokolle Secure Sockets Layer v2/v3 (SSLv2/SSLv3)
      und Transport Layer Security v1 (TLSv1) zur Verfügung.
      Die <application>OpenSSL</application>-Bibliotheken stellen
      kryptographische Funktionen bereit.</para>

    <para>Anwendungsbeispiele für <application>OpenSSL</application>
      sind die verschlüsselte Authentifizierung von
      E-Mail-Clients oder Web-Transaktionen wie das Bezahlen mit
      Kreditkarte.  Einige Ports, wie <package>www/apache24</package>
      und <package>databases/portgresql91-server</package>, haben eine
      Option für den Bau mit
      <application>OpenSSL</application>.</para>

    <para>&os; verfügt über zwei <acronym>OpenSSL</acronym> Versionen:
      eine im Basissystem, die andere aus der Ports-Sammlung.  Der
      Benutzer kann mit Hilfe der folgenden Optionen wählen, welche
      Version in der Voreinstellung für andere Ports verwendet
      wird:</para>

    <itemizedlist>
      <listitem>
	<para>WITH_OPENSSL_PORT: wenn diese Option gesetzt ist, wird
	  der Port <application>OpenSSL</application> aus dem Port
	  <package>security/openssl</package> verwenden, auch dann,
	  wenn die Version im Basisystem aktueller ist.</para>
      </listitem>

      <listitem>
	<para>WITH_OPENSSL_BASE: wenn diese Option gesetzt ist, wird
	  der Port mit <application>OpenSSL</application> aus dem
	  Basissystem übersetzt.</para>
      </listitem>
    </itemizedlist>

    <para><application>OpenSSL</application> wird auch eingesetzt,
      um Zertifikate für Anwendungen bereitzustellen.  Die
      Zertifikate stellen die Identität einer Firma oder eines
      Einzelnen sicher.  Wenn ein Zertifikat nicht von einer
      Zertifizierungsstelle
      (<foreignphrase>Certificate Authority</foreignphrase>,
      <acronym>CA</acronym>) gegengezeichnet wurde, erhalten Sie
      normalerweise eine Warnung.  Eine Zertifizierungsstelle ist eine
      Firma wie <link
	xlink:href="http://www.verisign.com/">VeriSign</link>, die
      Zertifikate von Personen oder Firmen gegenzeichnet und damit die
      Korrektheit der Zertifikate bestätigt.  Diese Prozedur kostet
      Geld, ist aber keine Voraussetzung für den Einsatz von
      Zertifikaten, beruhigt aber sicherheitsbewusste Benutzer.</para>

    <para>Dieser Abschnitt beschreibt, wie Sie auf einem &os;-System
      Zertifikate erstellen und benutzen.
      <xref linkend="ldap-config"/> beschreibt, wie Sie eine
      <acronym>CA</acronym> erstellen um die eigenen Zertifikate zu
      signieren.</para>

    <para>Weitere Informationen über <acronym>SSL</acronym> finden Sie
      im kostenlosen <link
	xlink:href="https://www.feistyduck.com/books/openssl-cookbook/">
	OpenSSL Cookbook</link>.</para>

    <sect2>
      <title>Zertifikate erzeugen</title>

      <indexterm>
	<primary>OpenSSL</primary>
	<secondary>Zertifikate erzeugen</secondary>
      </indexterm>

      <para>Um ein Zertifikat zu erzeugen, das von einer externen
	<acronym>CA</acronym> signiert werden soll, geben Sie
	folgenden Befehl und die angeforderten Informationen
	ein.  Diese Informationen werden in das Zertifikat
	geschrieben.  Für <literal>Common Name</literal> geben Sie
	den vollqualifizierten Namen des Systems ein, auf dem das
	Zertifikat später installiert wird.  Wenn der Name nicht
	übereinstimmt, wird die Anwendung, die das Zertifikat
	überprüft, dem Benuzter eine Warnung anzeigen.  Die
	Überprüfung würde fehlschlagen und das Zertifikat damit
	unbrauchbar machen.</para>

      <screen>&prompt.root; <userinput>openssl req -new -nodes -out req.pem -keyout cert.key -sha256 -newkey rsa:2048</userinput>
Generating a 2048 bit RSA private key
..................+++
.............................................................+++
writing new private key to 'cert.key'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [AU]:<userinput><replaceable>US</replaceable></userinput>
State or Province Name (full name) [Some-State]:<userinput><replaceable>PA</replaceable></userinput>
Locality Name (eg, city) []:<userinput><replaceable>Pittsburgh</replaceable></userinput>
Organization Name (eg, company) [Internet Widgits Pty Ltd]:<userinput><replaceable>My Company</replaceable></userinput>
Organizational Unit Name (eg, section) []:<userinput><replaceable>Systems Administrator</replaceable></userinput>
Common Name (eg, YOUR name) []:<userinput><replaceable>localhost.example.org</replaceable></userinput>
Email Address []:<userinput><replaceable>trhodes@FreeBSD.org</replaceable></userinput>

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:
An optional company name []:<userinput><replaceable>Another Name</replaceable></userinput></screen>

      <para>Bei der Erzeugung des Zertifikates können noch weitere
	Optionen, wie die Gültigkeitsdauer
	und alternative Verschlüsselungsalgorithmen,  angegeben
	werden.  &man.openssl.1; beschreibt die zur
	Verfügung stehenden Optionen.</para>

      <para>Das folgende Kommando erstellt zwei Dateien im aktuellen
	Verzeichnis: Die Anforderung für ein neues Zertifikat wird in
	<filename>req.pem</filename> gespeichert.  Diese Datei können
	Sie an eine <acronym>CA</acronym> senden, wo die Angaben
	geprüft werden.  Nach erfolgreicher Prüfung wird das
	Zertifikat signiert und an Sie zurückgesandt.
	<filename>cert.key</filename>, enthält den privaten Schlüssel
	für das Zertifikat und darf auch keine Fall in fremde Hände
	geraten, da ein Angreifer sonst in der Lage ist, anderen
	Personen oder Rechnern vorzugaukeln, dass es sich bei ihm um
	Sie handelt.</para>

      <para>Wenn Sie keine Signatur einer Zertifizierungsstelle
	benötigen, können Sie ein selbst signiertes
	Zertifikat erstellen.  Erzeugen Sie dazu zuerst einen
	<acronym>RSA</acronym>-Schlüssel:</para>

      <screen>&prompt.root; <userinput>openssl genrsa -rand -genkey -out cert.key 2048</userinput>
0 semi-random bytes loaded
Generating RSA private key, 2048 bit long modulus
.............................................+++
.................................................................................................................+++
e is 65537 (0x10001)</screen>

      <para>Benutzen Sie diesen Schlüssel, um ein selbst signiertes
	Zertifikat zu erzeugen.  Folgen Sie wieder den Anweisungen am
	Prompt:</para>

      <screen>&prompt.root; <userinput>openssl req -new -x509 -days 365 -key cert.key -out cert.crt -sha256</userinput>
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [AU]:<userinput><replaceable>US</replaceable></userinput>
State or Province Name (full name) [Some-State]:<userinput><replaceable>PA</replaceable></userinput>
Locality Name (eg, city) []:<userinput><replaceable>Pittsburgh</replaceable></userinput>
Organization Name (eg, company) [Internet Widgits Pty Ltd]:<userinput><replaceable>My Company</replaceable></userinput>
Organizational Unit Name (eg, section) []:<userinput><replaceable>Systems Administrator</replaceable></userinput>
Common Name (e.g. server FQDN or YOUR name) []:<userinput><replaceable>localhost.example.org</replaceable></userinput>
Email Address []:<userinput><replaceable>trhodes@FreeBSD.org</replaceable></userinput></screen>

      <para>Dieses Kommando erstellt zwei neue Dateien im aktuellen
	Verzeichnis: Der Schlüssel der Zertifizierungsstelle
	<filename>cert.key</filename> und das Zertifikat selbst,
	<filename>cert.crt</filename>.  Sie sollten in einem
	Verzeichnis, vorzugsweise unterhalb von
	<filename>/etc/ssl/</filename> abgelegt werden, das nur von
	<systemitem class="username">root</systemitem> lesbar
	ist.  Die Zugriffsrechte der Dateien können mit
	<command>chmod</command> auf <literal>0700</literal> gesetzt
	werden.</para>
    </sect2>

    <sect2>
      <title>Zertifikate benutzen</title>

      <para>Mit einem Zertifikat können beispielsweise die
	Verbindungen zu <application>Sendmail</application>
	verschlüsselt werden, um eine Klartext-Authentifizierung
	zu verhindern.</para>

      <note>
	<para>Einige E-Mail-Programme geben Warnungen aus, wenn ein
	  Zertifikat nicht lokal installiert ist.  Weitere
	  Informationen zur Installation von Zertifikaten finden Sie
	  in der Dokumentation der entsprechenden Software.</para>
      </note>

      <para>Unter &os; 10.0-RELEASE und neueren Versionen ist es
	möglich, ein selbst signiertes Zertifikat für
	<application>Sendmail</application> automatisch erzeugen
	zu lassen.  Um diese Funktionalität zu aktivieren, fügen Sie
	die folgenden Zeilen in <filename>/etc/rc.conf</filename>
	ein:</para>

      <programlisting>sendmail_enable="YES"
sendmail_cert_enable="YES"
sendmail_cert_cn="<replaceable>localhost.example.org</replaceable>"</programlisting>

      <para>Dadurch wird automatisch ein selbst signiertes Zertifikat
	(<filename>/etc/mail/certs/host.cert</filename>), der
	Schlüssel für die <acronym>CA</acronym>
	(<filename>/etc/mail/certs/host.key</filename> und das
	Zertifikat der <acronym>CA</acronym>
	(<filename>/etc/mail/certs/cacert.pem</filename> erzeugt.  Das
	Zertifikat wird den in <option>sendmail_cert_cn</option>
	festgelegten <literal>Common Name</literal> verwenden.
	Nachdem Sie die Änderungen gespeichert haben, starten Sie
	<application>Sendmail</application> neu:</para>

      <screen>&prompt.root; <userinput>service sendmail restart</userinput></screen>

      <para>Wenn alles gut ging, erscheinen keine Fehlermeldungen
	in <filename>/var/log/maillog</filename>.  Für einen einfachen
	Test, bauen Sie mit Hilfe von <command>telnet</command> eine
	Verbindung zum Mailserver auf:</para>

      <screen>&prompt.root; <userinput>telnet <replaceable>example.com</replaceable> 25</userinput>
Trying 192.0.34.166...
Connected to example.com.
Escape character is '^]'.
220 example.com ESMTP Sendmail 8.14.7/8.14.7; Fri, 18 Apr 2014 11:50:32 -0400 (EDT)
<userinput>ehlo <replaceable>example.com</replaceable></userinput>
250-example.com Hello example.com [192.0.34.166], pleased to meet you
250-ENHANCEDSTATUSCODES
250-PIPELINING
250-8BITMIME
250-SIZE
250-DSN
250-ETRN
250-AUTH LOGIN PLAIN
250-STARTTLS
250-DELIVERBY
250 HELP
<userinput>quit</userinput>
221 2.0.0 example.com closing connection
Connection closed by foreign host.</screen>

      <para>Wenn die Zeile <literal>STARTTLS</literal>
	erscheint, hat alles funktioniert.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="ipsec">
    <info>
      <title><acronym>VPN</acronym> mit
	<acronym>IPsec</acronym></title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Nik</firstname>
	    <surname>Clayton</surname>
	  </personname>
	  <affiliation>
	    <address><email>nik@FreeBSD.org</email></address>
	  </affiliation>
	  <contrib>Geschrieben von </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <personname>
	    <firstname>Hiten M.</firstname>
	    <surname>Pandya</surname>
	  </personname>
	  <affiliation>
	    <address><email>hmp@FreeBSD.org</email></address>
	  </affiliation>
	  <contrib>Geschrieben von </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary><acronym>IPsec</acronym></primary>
    </indexterm>

    <para><foreignphrase>Internet Protocol Security</foreignphrase>
      (<acronym>IPsec</acronym>) ist ein Satz von Protokollen, die auf
      dem Internet-Protokoll (<acronym>IP</acronym>) aufbauen.  Durch
      Authentifizierung und Verschlüsselung jedes einzelnen
      <acronym>IP</acronym>-Pakets, können mehrere Systeme geschützt
      miteinander kommunizieren.  &os;s <acronym>IPSsec</acronym>
      Netzwerk-Stack basiert auf der <link
	xlink:href="http://www.kame.net">http://www.kame.net</link>
      Implementierung und unterstützt sowohl <acronym>IPv4</acronym>
      als auch <acronym>IPv6</acronym>.</para>

    <indexterm>
      <primary><acronym>IPsec</acronym></primary>
      <secondary>ESP</secondary>
    </indexterm>

    <indexterm>
      <primary><acronym>IPsec</acronym></primary>
      <secondary>AH</secondary>
    </indexterm>

    <para><acronym>IPsec</acronym> besteht aus den folgenden
      Protokollen:</para>

    <itemizedlist>
      <listitem>
	<para><emphasis>Encapsulated Security Payload
	    (<acronym>ESP</acronym>)</emphasis>: dieses Protokoll
	  verschlüsselt <acronym>IP</acronym>-Pakete mit einem
	  symmetrischen Verfahren wie Blowfish oder
	  <acronym>3DES</acronym>.  Damit werden die Pakete vor
	  Manipulationen Dritter geschützt.</para>
      </listitem>

      <listitem>
	<para><emphasis>Authentication Header
	    (<acronym>AH</acronym>)</emphasis>: dieses Protokoll
	  enthält eine kryptographische Prüfsumme, die sicher stellt,
	  dass ein <acronym>IP</acronym>-Paket nicht verändert wurde.
	  Der Authentication-Header folgt nach dem normalen
	  <acronym>IP</acronym>-Header und erlaubt dem Empfänger eines
	  <acronym>IP</acronym>-Paketes, dessen Integrität zu
	  prüfen.</para>
      </listitem>

      <listitem>
	<para><emphasis>IP Payload Compression Protocol
	    (<acronym>IPComp</acronym>)</emphasis>:  dieses Protokoll
	  versucht durch Komprimierung der
	  <acronym>IP</acronym>-Nutzdaten die Menge der gesendeten
	  Daten zu reduzieren und somit die Kommunikationsleistung zu
	  verbessern.</para>
      </listitem>
    </itemizedlist>

    <para>Diese Protokolle können, je nach Situation, zusammen oder
      einzeln verwendet werden.</para>

    <indexterm>
      <primary><acronym>VPN</acronym></primary>
    </indexterm>

    <indexterm>
      <primary>Virtual Private Network</primary>
      <see>VPN</see>
    </indexterm>

    <para><acronym>IPsec</acronym> unterstützt zwei Modi:  Der
      <firstterm>Transport-Modus</firstterm> verschlüsselt die Daten
      zwischen zwei Systemen.  Der <firstterm>Tunnel-Modus</firstterm>
      verbindet zwei Subnetze miteinander.  Durch einen Tunnel können
      dann verschlüsselte Daten übertragen werden.  Ein Tunnel wird
      auch als <foreignphrase>Virtual-Private-Network</foreignphrase>
      (<acronym>VPN</acronym>) bezeichnet.  Detaillierte Informationen
      über das <acronym>IPsec</acronym>-Subsystem von &os; finden Sie
      in &man.ipsec.4;.</para>

    <para>Seit &os;&nbsp;11 ist <acronym>IPsec</acronym> in der
      Voreinstellung aktiviert.  Um die Unterstützung für
      <acronym>IPsec</acronym> in älteren Versionen zu aktivieren,
      fügen Sie folgenden Optionen in die
      Kernelkonfigurationsdatei ein und erstellen Sie einen neuen
      Kernel, wie in <xref linkend="kernelconfig"/>
      beschrieben.</para>

    <indexterm>
      <primary>Kerneloption</primary>
      <secondary>IPSEC</secondary>
    </indexterm>

    <screen>options   IPSEC        #IP security
device    crypto</screen>

    <indexterm>
      <primary>Kerneloption</primary>
      <secondary>IPSEC_DEBUG</secondary>
    </indexterm>

    <para>Wenn Sie zur Fehlersuche im
      <acronym>IPsec</acronym>-Subsystem Unterstützung wünschen,
      sollten Sie die folgende Option ebenfalls aktivieren:</para>

    <screen>options   IPSEC_DEBUG  #debug for IP security</screen>

    <para>Der Rest dieses Kapitels beschreibt die Einrichtung eines
      <acronym>IPsec</acronym>-<acronym>VPN</acronym> zwischen einem
      Heimnetzwerk und einem Firmennetzwerk.  Für das folgende
      Beispiel gilt:</para>

    <itemizedlist>
      <listitem>
	<para>Beide Netzwerke sind über ein &os;-Gateway mit dem
	  Internet verbunden.</para>
      </listitem>

      <listitem>
	<para>Der Gateway jedes Netzwerks besitzt mindestens eine
	  externe <acronym>IP</acronym>-Adresse.  In diesem Beispiel
	  ist die externe <acronym>IP</acronym>-Adresse des
	  Firmennetzwerks (<acronym>LAN</acronym>) <systemitem
	    class="ipaddress">172.16.5.4</systemitem> und das
	  Heimnetzwerk (<acronym>LAN</acronym>) hat die externe
	  <acronym>IP</acronym>-Adresse <systemitem
	    class="ipaddress">192.168.1.12</systemitem>.</para>
      </listitem>

      <listitem>
	<para>Die intern verwendeten <acronym>IP</acronym>-Adressen
	  können private oder öffentliche Adressen sein.  Sie dürfen
	  sich jedoch nicht überschneiden.  Zum Beispiel sollten nicht
	  beide Netze <systemitem
	    class="ipaddress">192.168.1.x</systemitem> benutzen.  In
	  diesem Beispiel ist die interne
	  <acronym>IP</acronym>-Adresse des Firmennetzwerks
	  (<acronym>LAN</acronym>) <systemitem
	    class="ipaddress">10.246.38.1</systemitem> und das
	  Heimnetzwerk (<acronym>LAN</acronym>) hat die interne
	  <acronym>IP</acronym>-Adresse <systemitem
	    class="ipaddress">10.0.0.5</systemitem>.</para>
      </listitem>
    </itemizedlist>

    <sect2>
      <info>
	<title>Konfiguration eines <acronym>VPN</acronym> unter
	  &os;</title>

	<authorgroup>
	  <author>
	    <personname>
	      <firstname>Tom</firstname>
	      <surname>Rhodes</surname>
	    </personname>
	    <affiliation>
	      <address><email>trhodes@FreeBSD.org</email></address>
	    </affiliation>
	    <contrib>Geschrieben von </contrib>
	  </author>
	</authorgroup>
      </info>

      <para>Als erstes muss <package>security/ipsec-tools</package>
	aus der Ports-Sammlung installiert werden.  Diese Software
	enthält einige Anwendungen, die bei der Konfiguration von
	IPsec hilfreich sind.</para>

      <para>Als nächstes müssen zwei &man.gif.4;-Pseudogeräte angelegt
	werden, um die Pakete zu tunneln und dafür zu sorgen, dass
	beide Netzwerke richtig miteinander kommunizieren können.
	Geben Sie als <systemitem class="username">root</systemitem>
	die folgenden Befehle ein, wobei Sie
	<replaceable>intern</replaceable> und
	<replaceable>extern</replaceable> durch die realen internen
	und externen <acronym>IP</acronym>-Adressen der Gateways
	ersetzen müssen:</para>

      <screen>&prompt.root; <userinput>ifconfig gif0 create</userinput>
&prompt.root; <userinput>ifconfig gif0 <replaceable>intern1 intern2</replaceable></userinput>
&prompt.root; <userinput>ifconfig gif0 tunnel <replaceable>extern1 extern2</replaceable></userinput></screen>

      <para>Überprüfen Sie mit <command>ifconfig</command> die
	Konfiguration auf beiden Gateways.  Hier folgt die Ausgabe
	von Gateway 1:</para>

      <programlisting>gif0: flags=8051 mtu 1280
tunnel inet 172.16.5.4 --&gt; 192.168.1.12
inet6 fe80::2e0:81ff:fe02:5881%gif0 prefixlen 64 scopeid 0x6
inet 10.246.38.1 --&gt; 10.0.0.5 netmask 0xffffff00</programlisting>

      <para>Hier folgt die Ausgabe von Gateway 2:</para>

      <programlisting>gif0: flags=8051 mtu 1280
tunnel inet 192.168.1.12 --&gt; 172.16.5.4
inet 10.0.0.5 --&gt; 10.246.38.1 netmask 0xffffff00
inet6 fe80::250:bfff:fe3a:c1f%gif0 prefixlen 64 scopeid 0x4</programlisting>

      <para>Wenn Sie fertig sind, sollten beide internen Adressen über
	&man.ping.8; erreichbar sein:</para>

      <programlisting>priv-net# ping 10.0.0.5
PING 10.0.0.5 (10.0.0.5): 56 data bytes
64 bytes from 10.0.0.5: icmp_seq=0 ttl=64 time=42.786 ms
64 bytes from 10.0.0.5: icmp_seq=1 ttl=64 time=19.255 ms
64 bytes from 10.0.0.5: icmp_seq=2 ttl=64 time=20.440 ms
64 bytes from 10.0.0.5: icmp_seq=3 ttl=64 time=21.036 ms
--- 10.0.0.5 ping statistics ---
4 packets transmitted, 4 packets received, 0% packet loss
round-trip min/avg/max/stddev = 19.255/25.879/42.786/9.782 ms

corp-net# ping 10.246.38.1
PING 10.246.38.1 (10.246.38.1): 56 data bytes
64 bytes from 10.246.38.1: icmp_seq=0 ttl=64 time=28.106 ms
64 bytes from 10.246.38.1: icmp_seq=1 ttl=64 time=42.917 ms
64 bytes from 10.246.38.1: icmp_seq=2 ttl=64 time=127.525 ms
64 bytes from 10.246.38.1: icmp_seq=3 ttl=64 time=119.896 ms
64 bytes from 10.246.38.1: icmp_seq=4 ttl=64 time=154.524 ms
--- 10.246.38.1 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 28.106/94.594/154.524/49.814 ms</programlisting>

      <para>Wie erwartet, können nun beiden Seiten
	<acronym>ICMP</acronym>-Pakete von ihren privaten Adressen
	senden und empfangen.  Als nächstes müssen beide Gateways so
	konfiguriert werden, dass sie die Pakete des anderen
	Netzwerkes richtig routen.  Dazu werden folgende Befehle
	verwendet:</para>

      <screen>corp-net&prompt.root; <userinput>route add <replaceable>10.0.0.0 10.0.0.5 255.255.255.0</replaceable></userinput>
corp-net&prompt.root; <userinput>route add net <replaceable>10.0.0.0: gateway 10.0.0.5</replaceable></userinput>
priv-net&prompt.root; <userinput>route add <replaceable>10.246.38.0 10.246.38.1 255.255.255.0</replaceable></userinput>
priv-net&prompt.root; <userinput>route add host <replaceable>10.246.38.0: gateway 10.246.38.1</replaceable></userinput></screen>

      <para>Ab jetzt sollten die Rechner von den Gateways sowie von
	den Rechnern hinter den Gateways erreichbar sein.  Dies können
	Sie wieder mit &man.ping.8; überprüfen:</para>

      <programlisting>corp-net# ping 10.0.0.8
PING 10.0.0.8 (10.0.0.8): 56 data bytes
64 bytes from 10.0.0.8: icmp_seq=0 ttl=63 time=92.391 ms
64 bytes from 10.0.0.8: icmp_seq=1 ttl=63 time=21.870 ms
64 bytes from 10.0.0.8: icmp_seq=2 ttl=63 time=198.022 ms
64 bytes from 10.0.0.8: icmp_seq=3 ttl=63 time=22.241 ms
64 bytes from 10.0.0.8: icmp_seq=4 ttl=63 time=174.705 ms
--- 10.0.0.8 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 21.870/101.846/198.022/74.001 ms

priv-net# ping 10.246.38.107
PING 10.246.38.1 (10.246.38.107): 56 data bytes
64 bytes from 10.246.38.107: icmp_seq=0 ttl=64 time=53.491 ms
64 bytes from 10.246.38.107: icmp_seq=1 ttl=64 time=23.395 ms
64 bytes from 10.246.38.107: icmp_seq=2 ttl=64 time=23.865 ms
64 bytes from 10.246.38.107: icmp_seq=3 ttl=64 time=21.145 ms
64 bytes from 10.246.38.107: icmp_seq=4 ttl=64 time=36.708 ms
--- 10.246.38.107 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 21.145/31.721/53.491/12.179 ms</programlisting>

      <para>Das Konfigurieren der Tunnel ist der einfache Teil.  Die
	Konfiguration einer sicheren Verbindung geht viel mehr in
	die Tiefe.  Die folgende Konfiguration benutzt pre-shared
	(<acronym>PSK</acronym>) <acronym>RSA</acronym>-Schlüssel.
	Abgesehen von den <acronym>IP</acronym>-Adressen, sind beide
	<filename>/usr/local/etc/racoon/racoon.conf</filename>
	identisch und sehen ähnlich aus:</para>

      <programlisting>path    pre_shared_key  "/usr/local/etc/racoon/psk.txt"; #location of pre-shared key file
log     debug;  #log verbosity setting: set to 'notify' when testing and debugging is complete

padding # options are not to be changed
{
        maximum_length  20;
        randomize       off;
        strict_check    off;
        exclusive_tail  off;
}

timer   # timing options. change as needed
{
        counter         5;
        interval        20 sec;
        persend         1;
#       natt_keepalive  15 sec;
        phase1          30 sec;
        phase2          15 sec;
}

listen  # address [port] that racoon will listen on
{
        isakmp          172.16.5.4 [500];
        isakmp_natt     172.16.5.4 [4500];
}

remote  192.168.1.12 [500]
{
        exchange_mode   main,aggressive;
        doi             ipsec_doi;
        situation       identity_only;
        my_identifier   address 172.16.5.4;
        peers_identifier        address 192.168.1.12;
        lifetime        time 8 hour;
        passive         off;
        proposal_check  obey;
#       nat_traversal   off;
        generate_policy off;

                        proposal {
                                encryption_algorithm    blowfish;
                                hash_algorithm          md5;
                                authentication_method   pre_shared_key;
                                lifetime time           30 sec;
                                dh_group                1;
                        }
}

sainfo  (address 10.246.38.0/24 any address 10.0.0.0/24 any)    # address $network/$netmask $type address $network/$netmask $type ( $type being any or esp)
{                                                               # $network must be the two internal networks you are joining.
        pfs_group       1;
        lifetime        time    36000 sec;
        encryption_algorithm    blowfish,3des;
        authentication_algorithm        hmac_md5,hmac_sha1;
        compression_algorithm   deflate;
}</programlisting>

      <para>Eine Beschreibung der verfügbaren Optionen finden Sie in
	der Manualpage von <filename>racoon.conf</filename>.</para>

      <para>Die
	<foreignphrase>Security Policy Database</foreignphrase>
	(<acronym>SPD</acronym>) muss noch konfiguriert werden, so
	dass &os; und <application>racoon</application> in der
	Lage sind den Netzwerkverkehr zwischen den Hosts zu ver-
	und entschlüsseln.</para>

      <para>Dies wird durch ein Shellskript ähnlich wie das
	folgende, das auf dem Firmennetzwerk-Gateway liegt,
	ausgeführt.  Diese Datei wird während der
	Systeminitialisierung ausgeführt und sollte unter
	<filename>/usr/local/etc/racoon/setkey.conf</filename>
	gespeichert werden.</para>

      <programlisting>flush;
spdflush;

# To the home network
spdadd 10.246.38.0/24 10.0.0.0/24 any -P out ipsec esp/tunnel/172.16.5.4-192.168.1.12/use;
spdadd 10.0.0.0/24 10.246.38.0/24 any -P in ipsec esp/tunnel/192.168.1.12-172.16.5.4/use;</programlisting>

      <para>Nachdem die Datei gespeichert wurde, kann
	<application>racoon</application> durch das folgende Kommando
	auf beiden Gateways gestartet werden:</para>

      <screen>&prompt.root; <userinput>/usr/local/sbin/racoon -F -f /usr/local/etc/racoon/racoon.conf -l /var/log/racoon.log</userinput></screen>

      <para>Die Ausgabe sollte so ähnlich aussehen:</para>

      <programlisting>corp-net# /usr/local/sbin/racoon -F -f /usr/local/etc/racoon/racoon.conf
Foreground mode.
2006-01-30 01:35:47: INFO: begin Identity Protection mode.
2006-01-30 01:35:48: INFO: received Vendor ID: KAME/racoon
2006-01-30 01:35:55: INFO: received Vendor ID: KAME/racoon
2006-01-30 01:36:04: INFO: ISAKMP-SA established 172.16.5.4[500]-192.168.1.12[500] spi:623b9b3bd2492452:7deab82d54ff704a
2006-01-30 01:36:05: INFO: initiate new phase 2 negotiation: 172.16.5.4[0]192.168.1.12[0]
2006-01-30 01:36:09: INFO: IPsec-SA established: ESP/Tunnel 192.168.1.12[0]-&gt;172.16.5.4[0] spi=28496098(0x1b2d0e2)
2006-01-30 01:36:09: INFO: IPsec-SA established: ESP/Tunnel 172.16.5.4[0]-&gt;192.168.1.12[0] spi=47784998(0x2d92426)
2006-01-30 01:36:13: INFO: respond new phase 2 negotiation: 172.16.5.4[0]192.168.1.12[0]
2006-01-30 01:36:18: INFO: IPsec-SA established: ESP/Tunnel 192.168.1.12[0]-&gt;172.16.5.4[0] spi=124397467(0x76a279b)
2006-01-30 01:36:18: INFO: IPsec-SA established: ESP/Tunnel 172.16.5.4[0]-&gt;192.168.1.12[0] spi=175852902(0xa7b4d66)</programlisting>

      <para>Um sicherzustellen, dass der Tunnel richtig funktioniert,
	wechseln Sie auf eine andere Konsole und benutzen Sie
	&man.tcpdump.1; mit dem folgenden Befehl, um sich den
	Netzwerkverkehr anzusehen.  Tauschen Sie
	<literal>em0</literal> durch die richtige Netzwerkkarte
	aus:</para>

      <screen>&prompt.root; <userinput>tcpdump -i em0 host <replaceable>172.16.5.4 and dst 192.168.1.12</replaceable></userinput></screen>

      <para>Die Ausgabe der Konsole sollte dem hier ähneln.  Wenn
	nicht, gibt es ein Problem und ein Debuggen der ausgegebenen
	Daten ist notwendig.</para>

      <programlisting>01:47:32.021683 IP corporatenetwork.com &gt; 192.168.1.12.privatenetwork.com: ESP(spi=0x02acbf9f,seq=0xa)
01:47:33.022442 IP corporatenetwork.com &gt; 192.168.1.12.privatenetwork.com: ESP(spi=0x02acbf9f,seq=0xb)
01:47:34.024218 IP corporatenetwork.com &gt; 192.168.1.12.privatenetwork.com: ESP(spi=0x02acbf9f,seq=0xc)</programlisting>

      <para>An diesem Punkt sollten beide Netzwerke verfügbar sein und
	den Anschein haben, dass sie zum selben Netzwerk gehören.
	Meistens sind beide Netzwerke durch eine Firewall geschützt.
	Um den Netzwerkverkehr zwischen den beiden Netzwerken zu
	erlauben, ist es notwendig Regeln zu erstellen.  Für die
	&man.ipfw.8; Firewall fügen Sie folgende Zeilen in die
	Firewall-Konfigurationsdatei ein:</para>

      <programlisting>ipfw add 00201 allow log esp from any to any
ipfw add 00202 allow log ah from any to any
ipfw add 00203 allow log ipencap from any to any
ipfw add 00204 allow log udp from any 500 to any</programlisting>

      <note>
	<para>Die Regelnummern müssen eventuell, je nach
	  Hostkonfiguration, angepasst werden.</para>
      </note>

      <para>Für Benutzer der &man.pf.4;- oder &man.ipf.8;-Firewall
	sollte folgendes funktionieren:</para>

      <programlisting>pass in quick proto esp from any to any
pass in quick proto ah from any to any
pass in quick proto ipencap from any to any
pass in quick proto udp from any port = 500 to any port = 500
pass in quick on gif0 from any to any
pass out quick proto esp from any to any
pass out quick proto ah from any to any
pass out quick proto ipencap from any to any
pass out quick proto udp from any port = 500 to any port = 500
pass out quick on gif0 from any to any</programlisting>

      <para>Zum Ende, um dem Computer den Start vom
	<acronym>VPN</acronym> während der Systeminitialisierung
	zu erlauben, fügen Sie folgende Zeilen in ihre
	<filename>/etc/rc.conf</filename>: ein</para>

      <programlisting>ipsec_enable="YES"
ipsec_program="/usr/local/sbin/setkey"
ipsec_file="/usr/local/etc/racoon/setkey.conf" # allows setting up spd policies on boot
racoon_enable="yes"</programlisting>
    </sect2>
  </sect1>

  <sect1 xml:id="openssh">
    <info>
      <title>OpenSSH</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Chern</firstname>
	    <surname>Lee</surname>
	  </personname>
	  <contrib>Beigetragen von </contrib>
	</author>
	<!-- 21 April 2001 -->
      </authorgroup>
    </info>

    <indexterm><primary>OpenSSH</primary></indexterm>
    <indexterm>
      <primary>Sicherheit</primary>
      <secondary>OpenSSH</secondary>
    </indexterm>

    <para><application>OpenSSH</application> stellt Werkzeuge bereit,
      um sicher auf entfernte Maschinen zuzugreifen.  Zusätzlich
      können <acronym>TCP/IP</acronym>-Verbindungen sicher durch
      <acronym>SSH</acronym> getunnelt oder weitergeleitet werden.
      <application>OpenSSH</application> verschlüsselt alle
      Verbindungen.  Dadurch wird beispielsweise verhindert, dass die
      Verbindung abgehört oder übernommen
      (<foreignphrase>Hijacking</foreignphrase>) werden kann.  Weitere
      Informationen zu <application>OpenSSH</application> finden Sie
      auf <link xlink:href="http://www.openssh.com/">
	http://www.openssh.com/</link>.</para>

    <para>Dieser Abschnitt enthält einen Überblick über die
      integrierten Client-Werkzeuge, mit denen Sie sicher auf
      entfernte Systeme zugreifen können, oder mit denen Sie sicher
      Dateien austauschen können.  Der Abschnitt beschreibt auch die
      Konfiguration eines <acronym>SSH</acronym>-Servers auf einem
      &os;-System.  Weitere Informationen finden Sie in den hier
      erwähnten Manualpages.</para>

    <sect2>
      <title>Die SSH Client-Werkzeuge benutzen</title>

      <indexterm>
	<primary>OpenSSH</primary>
	<secondary>Client</secondary>
      </indexterm>

      <para>Benutzen Sie <command>ssh</command> zusammen mit einem
	Benutzernamen und einer <acronym>IP</acronym>-Adresse oder dem
	Hostnamen, um sich an einem <acronym>SSH</acronym>-Server
	anzumelden.  Ist dies das erste Mal, dass eine Verbindung mit
	dem angegebenen Server hergestellt wird, wird der Benutzer
	aufgefordert, zuerst den Fingerabdruck des Servers zu
	prüfen:</para>

      <screen>&prompt.root; <userinput>ssh <replaceable>user@example.com</replaceable></userinput>
The authenticity of host 'example.com (10.0.0.1)' can't be established.
ECDSA key fingerprint is 25:cc:73:b5:b3:96:75:3d:56:19:49:d2:5c:1f:91:3b.
Are you sure you want to continue connecting (yes/no)? <userinput>yes</userinput>
Permanently added 'example.com' (ECDSA) to the list of known hosts.
Password for user@example.com: <userinput><replaceable>user_password</replaceable></userinput></screen>

      <para><acronym>SSH</acronym> speichert einen Fingerabdruck des
	Serverschlüssels um die Echtheit des Servers zu überprüfen,
	wenn der Client eine Verbindung herstellt.  Wenn der Benutzer
	den Fingerabdruck mit <literal>yes</literal> bestätigt, wird
	eine Kopie des Schlüssels in
	<filename>.ssh/known_hosts</filename> im Heimatverzeichnis des
	Benutzers gespeichert.  Zukünftige Verbindungen zu dem Server
	werden gegen den gespeicherten Fingerabdruck des Schlüssels
	geprüft und der Client gibt eine Warnung aus, wenn sich der
	empfangene Fingerabdruck von dem gespeicherten unterscheidet.
	Wenn dies passiert, sollte zunächst geprüft werden, ob sich
	der Schlüssel geändert hat, bevor die Verbindung hergestellt
	wird.</para>

      <para>In der Voreinstellung akzeptieren aktuelle Versionen von
	<application>OpenSSH</application> nur
	<acronym>SSH</acronym>v2 Verbindungen.  Wenn möglich, wird der
	Client versuchen Version&nbsp;2 zu verwenden, ist dies nicht
	möglich, fällt er auf Version&nbsp;1 zurück.  Der Client kann
	gezwungen werden, nur eine der beiden Versionen zu verwenden,
	indem die Option <option>-1</option> oder <option>-2</option>
	übergeben wird.  Weitere Optionen sind in &man.ssh.1;
	beschrieben.</para>

      <indexterm>
	<primary>OpenSSH</primary>
	<secondary>secure copy</secondary>
      </indexterm>
      <indexterm><primary>&man.scp.1;</primary></indexterm>

      <para>Mit &man.scp.1; lassen sich Dateien in einer sicheren
	Weise auf entfernte Maschinen übertragen.  Dieses Beispiel
	kopiert die Datei <filename>COPYRIGHT</filename> von einem
	entfernten System in eine Datei mit dem gleichen Namen auf
	das lokale System:</para>

      <screen>&prompt.root; <userinput> scp <replaceable>user@example.com:/COPYRIGHT COPYRIGHT</replaceable></userinput>
Password for user@example.com: <userinput><replaceable>*******</replaceable></userinput>
COPYRIGHT            100% |*****************************|  4735
00:00
&prompt.root;</screen>

      <para>Da der Fingerabdruck für diesen Rechner bereits bestätigt
	wurde, wird er automatisch überprüft, bevor der Benutzer zur
	Eingabe des Passworts aufgefordert wird.</para>

      <para>Die Argumente, die <command>scp</command> übergeben
	werden, gleichen denen von <command>cp</command> in der
	Beziehung, dass die ersten Argumente die zu kopierenden
	Dateien sind und das letzte Argument den Bestimmungsort
	angibt.  Da die Dateien über das Netzwerk kopiert werden,
	können ein oder mehrere Argumente die Form
	<option>user@host:&lt;path_to_remote_file&gt;</option>
	besitzen.  Beachten Sie, das <command>scp</command> die
	Option <option>-r</option> verwendet um Dateien rekursiv
	zu kopieren, während <command>cp</command> <option>-R</option>
	benutzt.</para>

      <para>Mit <command>sftp</command> können Dateien über eine
	interaktive Sitzung kopiert werden.  &man.sftp.1; beschreibt
	die verfügbaren Befehle, die während einer
	<command>sftp</command>-Sitzung zur Verfügung stehen.</para>

      <sect3 xml:id="security-ssh-keygen">
	<title>Schlüsselbasierte Authentifizierung</title>

	<para>Ein Client kann bei der Verbindung auch Schlüssel
	  anstelle von Passwörtern verwenden.  Benutzen Sie
	  <command>ssh-keygen</command> um
	  <acronym>RSA</acronym>-Schlüssel erzeugen.  Geben
	  Sie das entsprechende Protokoll an, wenn Sie einen
	  öffentlichen und einen privaten Schlüssel erzeugen.  Folgen
	  Sie anschließend den Anweisungen des Programms.  Es wird
	  empfohlen, die Schlüssel mit einer einprägsamen, aber schwer
	  zu erratenen Passphrase zu schützen.</para>

	<screen>&prompt.user; <userinput>ssh-keygen -t rsa</userinput>
Generating public/private rsa key pair.
Enter file in which to save the key (/home/user/.ssh/id_rsa):
Enter passphrase (empty for no passphrase):  <co xml:id="co-ssh-keygen-passphrase1"/>
Enter same passphrase again:                 <co xml:id="co-ssh-keygen-passphrase2"/>
Your identification has been saved in /home/user/.ssh/id_rsa.
Your public key has been saved in /home/user/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:54Xm9Uvtv6H4NOo6yjP/YCfODryvUU7yWHzMqeXwhq8 user@host.example.com
The key's randomart image is:
+---[RSA 2048]----+
|                 |
|                 |
|                 |
|        . o..    |
|       .S*+*o    |
|      . O=Oo . . |
|       = Oo= oo..|
|      .oB.* +.oo.|
|       =OE**.o..=|
+----[SHA256]-----+</screen>

	<calloutlist>
	  <callout arearefs="co-ssh-keygen-passphrase1">
	    <para>Geben Sie hier die Passphrase ein.  Diese darf auch
	      Leer- und Sonderzeichen enthalten.</para>
	  </callout>

	  <callout arearefs="co-ssh-keygen-passphrase2">
	    <para>Geben Sie die Passphrase zur Überprüfung erneut
	      ein.</para>
	  </callout>
	</calloutlist>

	<para>Der private Schlüssel wird in
	  <filename>~/.ssh/id_rsa</filename> und der öffentliche
	  Schlüssel in <filename>~/.ssh/id_rsa.pub</filename>
	  gespeichert.  Der <emphasis>öffentliche</emphasis> Schlüssel
	  muss zuerst auf den entfernten Rechner nach
	  <filename>~/.ssh/authorized_keys</filename> kopiert werden,
	  damit die schlüsselbasierte Authentifizierung
	  funktioniert.</para>

	<warning>
	  <para>Viele Benutzer denken, dass die Verwendung von
	    Schlüsseln generell sicher ist.  Sie verwenden dann einen
	    Schlüssel ohne eine Passphrase.  Dies ist jedoch sehr
	    <emphasis>gefährlich</emphasis>.  Ein Administrator kann
	    überprüfen, ob ein Schlüsselpaar mit einer Passphrase
	    geschützt ist.  Wenn die Datei mit dem privaten Schlüssel
	    den Text <literal>ENCRYPTED</literal> enthält, dann hat
	    der Benutzer eine Passphrase verwendet.  Um die Benutzer
	    zusätzlich zu schützen, kann ein
	    <literal>from</literal>-Feld in der Datei des öffentlichen
	    Schlüssels hinzugefügt werden.  Zum Beispiel würde das
	    Hinzufügen von <literal>from="192.168.10.5"</literal> vor
	    dem <literal>ssh-rsa</literal>-Präfix dafür sorgen, dass
	    sich ein bestimmter Benutzer nur noch von dieser
	    <acronym>IP</acronym>-Adresse anmelden darf.</para>
	</warning>

	<para>Die Optionen und Dateinamen sind abhängig von der
	  eingesetzten Version von <application>OpenSSH</application>.
	  Die für das System gültigen Optionen finden Sie in
	  &man.ssh-keygen.1;.</para>

	<para>Wenn bei der Erzeugung des Schlüssels eine Passphrase
	  angegeben wurde, wird der Benutzer bei jeder Anmeldung am
	  Server zur Eingabe der Passphrase aufgefordert.  Mit
	  &man.ssh-agent.1; und &man.ssh-add.1; ist es möglich,
	  <application>SSH</application>-Schlüssel in den Speicher zu
	  laden, damit die Passphrase nicht jedes Mal eingegeben
	  werden muss.</para>

	<para><command>ssh-agent</command> übernimmt die
	  Authentifizierung mit den geladenen privaten Schlüsseln.
	  <command>ssh-agent</command> kann dazu verwendet
	  werden, ein anderes Programm zu starten, beispielsweise eine
	  Shell oder einen Window-Manager.</para>

	<para>Um <command>ssh-agent</command> in einer Shell zu
	  verwenden, muss es mit einer Shell als Argument aufgerufen
	  werden.  Die zu verwaltende Identität muss mit
	  <command>ssh-add</command> sowie der Passphrase für den
	  privaten Schlüssel übergeben werden.  Danach kann sich der
	  Benutzer mit <command>ssh</command> auf
	  jedem Rechner anmelden, der einen entsprechenden
	  öffentlichen Schlüssel besitzt.  Dazu ein Beispiel:</para>

	<screen>&prompt.user; <userinput>ssh-agent <replaceable>csh</replaceable></userinput>
&prompt.user; <userinput>ssh-add</userinput>
Enter passphrase for /usr/home/user/.ssh/id_rsa:  <co xml:id="co-ssh-agent-passphrase"/>
Identity added: /usr/home/user/.ssh/id_rsa (/home/user/.ssh/id_rsa)
&prompt.user;</screen>

	<calloutlist>
	  <callout arearefs="co-ssh-agent-passphrase">
	    <para>Geben Sie hier die Passphrase für den Schlüssel
	      ein.</para>
	  </callout>
	</calloutlist>

	<para>Um <command>ssh-agent</command> unter
	  <application>&xorg;</application> zu verwenden, muss ein
	  Eintrag für das Programm in <filename>~/.xinitrc</filename>
	  aufgenommen werden.  Dadurch können alle unter
	  <application>&xorg;</application> gestarteten Programme die
	  Dienste von <command>ssh-agent</command> nutzen.
	  <filename>~/.xinitrc</filename> könnte etwa so
	  aussehen:</para>

	<programlisting>exec ssh-agent <replaceable>startxfce4</replaceable></programlisting>

	<para>Dadurch wird bei jedem Start von
	  <application>&xorg;</application> zuerst
	  <command>ssh-agent</command> aufgerufen, das wiederum
	  <application>XFCE</application> startet.  Nachdem diese
	  Änderung durchgeführt wurde, muss
	  <application>&xorg;</application> neu gestartet werden.
	  Danach können Sie mit <command>ssh-add</command> die
	  <acronym>SSH</acronym>-Schlüssel laden.</para>
      </sect3>

      <sect3 xml:id="security-ssh-tunneling">
	<title><acronym>SSH</acronym>-Tunnel</title>

	<indexterm>
	  <primary>OpenSSH</primary>
	  <secondary>Tunnel</secondary>
	</indexterm>

	<para>Mit <application>OpenSSH</application> ist es möglich,
	  einen Tunnel zu erstellen, in dem ein anderes Protokoll
	  verschlüsselt übertragen wird.</para>

	<para>Im folgenden Kommando erzeugt <command>ssh</command>
	  einen Tunnel für <command>telnet</command>:</para>

	<screen>&prompt.user; <userinput>ssh -2 -N -f -L <replaceable>5023:localhost:23 user@foo.example.com</replaceable></userinput>
&prompt.user;</screen>

	<para>Dieses Beispiel verwendet die folgenden Optionen:</para>

	<variablelist>
	  <varlistentry>
	    <term><option>-2</option></term>

	    <listitem>
	      <para>Zwingt <command>ssh</command> dazu, die Version 2
		des Protokolls zu verwenden, um sich mit dem Server zu
		verbinden.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><option>-N</option></term>

	    <listitem>
	      <para>Zeigt an, dass ein Tunnel erstellt werden soll.
		Ohne diese Option würde <command>ssh</command> eine
		normale Sitzung öffnen.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><option>-f</option></term>

	    <listitem>
	      <para>Zwingt <command>ssh</command> im Hintergrund zu
		laufen.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><option>-L</option></term>

	    <listitem>
	      <para>Ein lokaler Tunnel wird in der Form
		<replaceable>localport:remotehost:remoteport</replaceable>
		angegeben.  Die Verbindung wird dabei von dem lokalen
		Port <replaceable>localport</replaceable> auf einen
		entfernten Rechner weitergeleitet.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><option>user@foo.example.com</option></term>

	    <listitem>
	      <para>Gibt den Anmeldenamen auf dem entfernten
		<acronym>SSH</acronym>-Server an.</para>
	    </listitem>
	  </varlistentry>
	</variablelist>

	<para>Ein <acronym>SSH</acronym>-Tunnel erzeugt einen Socket
	  auf <systemitem>localhost</systemitem> und dem angegebenen
	  lokalen Port.  Jede Verbindung, die auf dem angegebenen
	  Socket aufgemacht wird, wird dann auf den spezifizierten
	  entfernten Rechner und Port weitergeleitet.  Im Beispiel
	  wird der lokale Port <literal>5023</literal> an die
	  entfernte  Maschine auf Port <literal>23</literal>
	  weitergeleitet.  Da  der Port 23 für
	  <command>telnet</command> reserviert ist,  erzeugt das eine
	  sichere &man.telnet.1;-Verbindung durch einen
	  <acronym>SSH</acronym>-Tunnel.</para>

	<para>Wie in den folgenden Beispielen zu sehen ist, kann diese
	  Vorgehensweise genutzt werden, um jedes unsichere
	  <acronym>TCP</acronym>-Protokoll, wie
	  <acronym>SMTP</acronym>, <acronym>POP3</acronym> und
	  <acronym>FTP</acronym>, weiterzuleiten.</para>

	<example>
	  <title>Einen sicheren Tunnel für <acronym>SMTP</acronym>
	    erstellen</title>

	  <screen>&prompt.user; <userinput>ssh -2 -N -f -L <replaceable>5025:localhost:25 user@mailserver.example.com</replaceable></userinput>
user@mailserver.example.com's password: <userinput>*****</userinput>
&prompt.user; <userinput>telnet localhost 5025</userinput>
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
220 mailserver.example.com ESMTP</screen>

	  <para>Zusammen mit <command>ssh-keygen</command> und
	    zusätzlichen Benutzer-Accounts können leicht benutzbare
	    <acronym>SSH</acronym>-Tunnel aufgebaut werden.  Anstelle
	    von Passwörtern können Schlüssel benutzt werden und jeder
	    Tunnel kann unter einem eigenen Benutzer laufen.</para>
	</example>

	<example>
	  <title>Sicherer Zugriff auf einen
	    <acronym>POP3</acronym>-Server</title>

	  <para>In diesem Beispiel gibt es einen
	    <acronym>SSH</acronym>-Server, der Verbindungen von außen
	    akzeptiert.  Im selben Netzwerk befindet sich zudem
	    noch ein Mail-Server, der <acronym>POP3</acronym> spricht.
	    Um E-Mails auf sichere Weise abzurufen, bauen Sie eine
	    <acronym>SSH</acronym>-Verbindung zu dem
	    <acronym>SSH</acronym>-Server im Netzwerk auf und tunneln
	    von dort zum Mail-Server weiter.</para>

	  <screen>&prompt.user; <userinput>ssh -2 -N -f -L <replaceable>2110:mail.example.com:110 user@ssh-server.example.com</replaceable></userinput>
user@ssh-server.example.com's password: <userinput>******</userinput></screen>

	  <para>Wenn Sie den Tunnel eingerichtet haben, konfigurieren
	    Sie den Mail-Client so, dass er <acronym>POP3</acronym>
	    Anfragen zu <systemitem>localhost</systemitem> auf Port
	    2110 sendet.  Diese Verbindung wird dann über den
	    gesicherten Tunnel zu
	    <systemitem>mail.example.com</systemitem>
	    weitergeleitet.</para>
	</example>

	<example>
	  <title>Umgehen einer Firewall</title>

	  <para>Einige Firewalls filtern sowohl eingehende als auch
	    ausgehende Verbindungen.  Zum Beispiel könnte eine
	    Firewall den Zugriff auf entfernte Rechner auf die Ports
	    22 und 80 beschränken, um lediglich <acronym>SSH</acronym>
	    und Web-Inhalte zu erlauben.  Dies würde den Zugriff auf
	    Dienste verhindern, die nicht die Ports 22 oder 80
	    benutzen.</para>

	  <para>Die Lösung hier ist es, eine
	    <acronym>SSH</acronym>-Verbindung zu einer Maschine
	    außerhalb der Firewall aufzumachen und durch diese zum
	    gewünschten Dienst zu tunneln:</para>

	  <screen>&prompt.user; <userinput>ssh -2 -N -f -L <replaceable>8888:music.example.com:8000 user@unfirewalled-system.example.org</replaceable></userinput>
user@unfirewalled-system.example.org's password: <userinput>*******</userinput></screen>

	  <para>In diesem Beispiel benutzt ein Ogg Vorbis Client
	    <systemitem>localhost</systemitem> und Port 8888.  Die
	    Verbindung wird dann zu
	    <systemitem>music.example.com</systemitem> Port 8000
	    weitergeleitet.  Die Firewall wurde somit erfolgreich
	    umgangen.</para>
	</example>
      </sect3>
    </sect2>

    <sect2>
      <title>Den SSH-Server aktivieren</title>

      <indexterm>
	<primary>OpenSSH</primary>
	<secondary>aktivieren</secondary>
      </indexterm>

      <para>Neben den integrierten
	<acronym>SSH</acronym> Client-Werkzeugen, die zur Verfügung
	stehen, kann ein &os;-System auch als
	<acronym>SSH</acronym>-Server konfiguriert werden, um
	Verbindungen von anderen <acronym>SSH</acronym>-Clients zu
	akzeptieren.</para>

      <para>Benutzen Sie den Kommando &man.service.8;, um zu prüfen
	ob der <application>sshd</application> ausgeführt wird:</para>

      <screen>&prompt.root; <userinput>service sshd status</userinput></screen>

      <para>Wenn der Dienst nicht ausgeführt wird, fügen Sie folgende
	Zeile in <filename>/etc/rc.conf</filename> ein:</para>

      <programlisting>sshd_enable="YES"</programlisting>

      <para>Diese Zeile startet <command>sshd</command>, den
	<application>OpenSSH</application>-Daemon, beim nächsten
	Systemstart.  Geben Sie folgendes ein, um den Dienst jetzt
	zu starten:</para>

      <screen>&prompt.root; <userinput>service sshd start</userinput></screen>

      <para>Wenn <command>sshd</command> erstmalig gestartet wird,
	werden die Host-Schlüssel des Systems erzeugt und der
	Fingerabdruck wird auf der Konsole angezeigt.  Stellen Sie den
	Fingerabdruck den Benutzern zur Verfügung, sodass sie ihn
	überprüfen können, wenn sie das erste Mal eine Verbindung mit
	dem Server herstellen.</para>

      <para>&man.sshd.8; enthält die verfügbaren Optionen für den
	Start von <command>sshd</command> und weitere Informationen
	zur Authentifizierung, den Anmeldeprozess und die
	verschiedenen Konfigurationsdateien.</para>

      <para>Ab jetzt sollte <application>sshd</application> für alle
	Benutzer mit einem Benutzernamen und Kennwort zur Verfügung
	stehen.</para>
    </sect2>

    <sect2>
      <title>SSH Server Sicherheit</title>

      <para>Obwohl <application>sshd</application> das am weitesten
	verbreitete Remote-Administrations-Werkzeug ist, sind
	<foreignphrase>Brute-Force</foreignphrase>- und
	<foreignphrase>Drive-by</foreignphrase>-Angriffe auf
	öffentliche Netzwerke weit verbreitet.  Daher stehen mehrere
	Optionen zur Verfügung, um diese Art von Angriffen zu
	verhindern.  Diese Optionen werden in diesem Abschnitt
	beschrieben.</para>

      <para>Es ist in der Regel ein gute Idee, festzulegen, welche
	Benutzer sich von welchem Rechner aus anmelden können.  Dies
	lässt sich beispielsweise über die Option
	<literal>AllowUsers</literal> festlegen.  Soll sich etwa nur
	<systemitem class="username">root</systemitem> vom Rechner mit
	der <acronym>IP</acronym>-Adresse <systemitem
	  class="ipaddress">192.168.1.32</systemitem> aus einwählen
	dürfen, würden Sie folgenden Eintrag in
	<filename>/etc/ssh/sshd_config</filename> aufnehmen:</para>

      <programlisting>AllowUsers root@192.168.1.32</programlisting>

      <para>Damit sich <systemitem class="username">admin</systemitem>
	von jedem Rechner aus anmelden kann, geben Sie nur den
	Benutzernamen an:</para>

      <programlisting>AllowUsers admin</programlisting>

      <para>Sie können auch mehrere Benutzer in einer Zeile
	aufführen:</para>

      <programlisting>AllowUsers root@192.168.1.32 admin</programlisting>

      <para>Nachdem Sie <filename>/etc/ssh/sshd_config</filename>
	angepasst haben, muss <command>sshd</command> seine
	Konfigurationsdateien neu einlesen.  Dazu geben Sie Folgendes
	ein:</para>

      <screen>&prompt.root; <userinput>/etc/rc.d/sshd reload</userinput></screen>

      <note>
	<para>Wenn die Option <literal>AllowUsers</literal> verwendet
	  wird, ist es wichtig, jeden Benutzer aufzulisten, der sich
	  an diesem Rechner anmelden muss.  Benutzer, die nicht in
	  dieser Liste aufgeführt sind, dürfen sich nicht anmelden.
	  Die Optionen für die Konfigurationsdatei von
	  <application>OpenSSH</application> unterscheiden zwischen
	  Groß- und Kleinschreibung.  Wenn Sie eine Option falsch
	  schreiben, so wird sie ingnoriert.  Testen Sie immer
	  die Änderungen, um sicherzustellen, dass sie wie erwartet
	  funktionieren.  Weitere Informationen zu den verfügbaren
	  Optionen finden Sie in &man.sshd.config.5;.</para>
      </note>

      <para>Darüber hinaus können Benutzer gezwungen werden, eine
	Zwei-Faktor-Authentifizierung mit einem öffentlichen und einem
	privaten Schlüssel zu benutzen.  Bei Bedarf kann der Benutzer
	ein Schlüsselpaar mit &man.ssh-keygen.1; erzeugen und dem
	Administrator den öffentlichen Schlüssel zukommen lassen.  Der
	Schlüssel wird, wie weiter oben beschrieben, in
	<filename>authorized_keys</filename> platziert.  Um den
	Benutzer zu zwingen, ausschließlich Schlüssel zu benutzen,
	kann die folgende Option konfiguriert werden:</para>

      <programlisting>AuthenticationMethods publickey</programlisting>

      <tip>
	<para>Verwechseln Sie nicht
	  <filename>/etc/ssh/sshd_config</filename> mit
	  <filename>/etc/ssh/ssh_config</filename> (beachten Sie das
	  zusätzliche <literal>d</literal> im ersten Dateinamen).  Die
	  erste Datei konfiguriert den Server und die zweite Datei
	  konfiguriert den Client.  &man.ssh.config.5; enthält eine
	  Auflistung der verfügbaren Client-Einstellungen.</para>
      </tip>
    </sect2>
  </sect1>

  <sect1 xml:id="fs-acl">
    <info>
      <title>Zugriffskontrolllisten für Dateisysteme
	(<acronym>ACL</acronym>)</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	  </personname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>ACL</primary>
    </indexterm>

    <para><firstterm>Zugriffskontrolllisten</firstterm>
      (<foreignphrase>Access Control Lists</foreignphrase>,
      <acronym>ACL</acronym>) erweitern die normalen Zugriffsrechte
      von &unix; Systemen auf eine kompatible (&posix;.1e) Weise
      und bieten feiner granulierte Sicherheitsmechanismen.</para>

    <para>Der <filename>GENERIC</filename>-Kernel von &os; bietet
      <acronym>ACL</acronym>-Unterstützung für
      <acronym>UFS</acronym>-Dateisysteme.  Benutzer, die es vorziehen
      einen eigenen Kernel zu übersetzen, müssen die folgende Option
      in die Kernelkonfigurationsdatei aufnehmen:</para>

    <programlisting>options UFS_ACL</programlisting>

    <para>Das System gibt eine Warnung aus, wenn ein Dateisystem mit
      <acronym>ACL</acronym>s eingehangen werden soll und die
      Unterstützung für <acronym>ACL</acronym>s nicht im Kernel
      aktiviert ist.  <acronym>ACL</acronym>s bauen auf den
      erweiterten Attributen auf, die von <acronym>UFS2</acronym>
      standardmäßig unterstützt werden.</para>

    <para>Dieses Kapitel beschreibt, wie
      <acronym>ACL</acronym>-Unterstützung aktiviert wird.  Zudem
      werden einige Anwendungsbeispiele vorgestellt.</para>

    <sect2>
      <title><acronym>ACL</acronym>-Unterstützung aktivieren</title>

      <para>Die Option <option>acl</option> in
	<filename>/etc/fstab</filename> aktiviert
	Zugriffskontrolllisten für ein Dateisystem.  Die bevorzugte
	Möglichkeit ist die Verwendung von Zugriffskontrolllisten mit
	&man.tunefs.8; (Option <option>-a</option>), im Superblock des
	Dateisystems festzuschreiben.  Diese Möglichkeit hat mehrere
	Vorteile:</para>

      <itemizedlist>
	<listitem>
	  <para>Nochmaliges Einhängen eines Dateisystems (Option
	    <option>-u</option> von &man.mount.8;) verändert den
	    Status der Zugriffskontrolllisten nicht.  Die Verwendung
	    von Zugriffskontrolllisten kann nur durch Abhängen und
	    erneutes Einhängen eines Dateisystems verändert werden.
	    Das heißt auch, dass Zugriffskontrolllisten nicht
	    nachträglich auf dem Root-Dateisystem aktiviert werden
	    können.</para>
	</listitem>

	<listitem>
	  <para>Die Zugriffskontrolllisten auf den Dateisystemen sind,
	    unabhängig von den Optionen in
	    <filename>/etc/fstab</filename> oder Namensänderungen der
	    Geräte, immer aktiv.  Dies verhindert auch, dass
	    Zugriffskontrolllisten aus Versehen auf Dateisystemen ohne
	    Zugriffskontrolllisten aktiviert werden.</para>
	</listitem>
      </itemizedlist>

      <note>
	<para>Es kann sein, dass sich der Status von
	  Zugriffskontrolllisten später durch nochmaliges Einhängen
	  des Dateisystems (Option <option>-u</option> von
	  &man.mount.8;) ändern lässt.  Die momentane Variante ist
	  aber sicherer, da der Status der Zugriffskontrolllisten
	  nicht versehentlich geändert werden kann.  Allgemein sollten
	  Zugriffskontrolllisten auf einem Dateisystem, auf dem sie
	  einmal verwendet wurden, nicht deaktiviert werden, da danach
	  die Zugriffsrechte falsch sein können.  Werden
	  Zugriffskontrolllisten auf einem solchen Dateisystem wieder
	  aktiviert, werden die Zugriffsrechte von Dateien, die sich
	  zwischenzeitlich geändert haben, überschrieben, was zu
	  erneuten Problemen führt.</para>
      </note>

      <para>Die Zugriffsrechte einer Datei werden durch ein
	<literal>+</literal> (Plus) gekennzeichnet, wenn die Datei
	durch Zugriffskontrolllisten geschützt ist:</para>

      <programlisting>drwx------  2 robert  robert  512 Dec 27 11:54 private
drwxrwx---+ 2 robert  robert  512 Dec 23 10:57 directory1
drwxrwx---+ 2 robert  robert  512 Dec 22 10:20 directory2
drwxrwx---+ 2 robert  robert  512 Dec 27 11:57 directory3
drwxr-xr-x  2 robert  robert  512 Nov 10 11:54 public_html</programlisting>

      <para>In diesem Beispiel sind die Verzeichnisse
	<filename>directory1</filename>,
	<filename>directory2</filename> und
	<filename>directory3</filename> durch Zugriffskontrolllisten
	geschützt, wohingegen das Verzeichnis
	<filename>public_html</filename> nicht geschützt ist.</para>
    </sect2>

    <sect2>
      <title>Zugriffskontrolllisten benutzen</title>

      <para><command>getfacl</command> zeigt Zugriffskontrolllisten
	an.  Das folgende Kommando zeigt die <acronym>ACL</acronym>s
	auf der Datei <filename>test</filename>:</para>

      <screen>&prompt.user; <userinput>getfacl test</userinput>
	#file:test
	#owner:1001
	#group:1001
	user::rw-
	group::r--
	other::r--</screen>

      <para><command>setfacl</command> ändert oder entfernt
	<acronym>ACL</acronym>s auf Dateien.  Um alle
	<acronym>ACL</acronym>s einer Datei zu entfernen, können Sie
	die Option <option>-k</option> benutzen.  Es ist jedoch
	empfehlenswert die Option <option>-b</option> zu verwenden, da
	sie die erforderlichen Felder, die für <acronym>ACL</acronym>s
	benötigt werden, beibehält.</para>

      <screen>&prompt.root; <userinput>setfacl -k test</userinput></screen>

      <para>Benutzen Sie <option>-m</option> um die Einträge der
	<acronym>ACL</acronym> zu verändern:</para>

      <screen>&prompt.user; <userinput>setfacl -m u:trhodes:rwx,g:web:r--,o::--- test</userinput></screen>

      <para>In diesem Beispiel gab es keine vordefinierten Einträge,
	da sie durch den vorhergehenden Befehl entfernt wurden.
	Mit diesem Kommando werden die eben entfernten
	Zugriffskontrolllisten wiederhergestellt.  Der Befehl gibt die
	Fehlermeldung <errorname>Invalid argument</errorname> aus,
	wenn Sie nicht existierende Benutzer oder Gruppen als
	Parameter angeben.</para>

      <para>Weitere Informationen zu den Optionen dieser Kommandos
	finden Sie in &man.getfacl.1; und &man.setfacl.1;.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="security-pkg">
    <info>
      <title>Sicherheitsprobleme in Software von
	Drittanbietern überwachen</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	  </personname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>pkg</primary>
    </indexterm>

    <para>In den letzten Jahren wurden zahlreiche Verbesserungen in
      der Einschätzung und dem Umgang mit Sicherheitsproblemen
      erzielt.  Die Gefahr von Einbrüchen in ein System wird
      aber immer größer, da Softwarepakete von Dritten
      auf nahezu jedem Betriebssystem installiert und konfiguriert
      werden.</para>

    <para>Die Einschätzung der Verletzlichkeit eines Systems ist
      ein Schlüsselfaktor für dessen Sicherheit.  &os;
      veröffentlicht zwar Sicherheitshinweise
      (<foreignphrase>security advisories</foreignphrase>) für
      das Basissystem, das Projekt ist allerdings nicht dazu in der
      Lage, dies auch für die zahlreichen Softwarepakete von
      Dritten zu tun.  Dennoch gibt es einen Weg, auch diese
      Programmpakete zu überwachen.  Das &os; Dienstprogramm
      <application>pkg</application> enthält Optionen für genau
      diesen Anwendungsfall.</para>

    <para><application>pkg</application> fragt dazu eine Datenbank auf
      bekannte Sicherheitsprobleme ab.  Diese Datenbank wird vom &os;
      Security Team sowie den Ports-Entwicklern aktualisiert und
      gewartet.</para>

    <para>Anweisungen zur Installation von
      <application>pkg</application> finden Sie im
      <xref linkend="pkgng-intro"/>.</para>

    <para>Die Installation enthält Konfigurationsdateien für
      &man.periodic.8;, welche die Datenbank von
      <application>pkg</application> verwaltet und aktualisiert.
      Diese Funktionalität wird aktiviert, wenn in
      &man.periodic.conf.5; die Variable
      <literal>daily_status_security_pkgaudit_enable</literal> auf
      <literal>YES</literal> gesetzt wird.  Stellen Sie auf jeden Fall
      sicher, dass diese (an das E-Mail-Konto von <systemitem
	class="username">root</systemitem> gesendeten)
      Sicherheitsberichte auch gelesen werden.</para>

    <para>Nach der Installation kann ein Administrator mit dem
      folgenden Kommando die Datenbank aktualisieren und sich die
      Sicherheitslücken in installierten Paketen anzeigen
      lassen:</para>

    <screen>&prompt.root; <userinput>pkg audit -F</userinput></screen>

    <para><application>pkg</application> zeigt dann die
      Schwachstellen in installierten Pakete an:</para>

    <programlisting>Affected package: cups-base-1.1.22.0_1
Type of problem: cups-base -- HPGL buffer overflow vulnerability.
Reference: &lt;https://www.FreeBSD.org/ports/portaudit/40a3bca2-6809-11d9-a9e7-0001020eed82.html&gt;

1 problem(s) in your installed packages found.

You are advised to update or deinstall the affected package(s) immediately.</programlisting>

    <para>Wenn Sie die angegebene <acronym>URL</acronym> über einen
      Internetbrowser aufrufen, erhalten Sie weitere Informationen
      über die bestehende Sicherheitslücke, wie die betroffenen
      Versionen, die Version des &os;-Ports sowie Hinweise auf weitere
      Seiten, die ebenfalls Sicherheitshinweise zu diesem Problem
      bieten.</para>

    <para><application>pkg</application> ist ein mächtiges
      Werkzeug und insbesondere in Zusammenarbeit mit
      <package>ports-mgmt/portmaster</package> äußerst
      hilfreich.</para>
  </sect1>

  <sect1 xml:id="security-advisories">
    <info>
      <title>&os; Sicherheitshinweise</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	  </personname>
	  <contrib>Beigesteuert von </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>&os; Sicherheitshinweise</primary>
    </indexterm>

    <para>Wie viele andere Hersteller von hochwertigen
      Betriebssystemen, hat auch das &os;-Projekt ein Sicherheitsteam,
      das für die Bestimmung des End-of-Life (<acronym>EoL</acronym>)
      Datum verantwortlich ist.  Das Sicherheitsteam stellt zudem
      sicher, dass Sicherheitsupdates für unterstützte Versionen,
      welche noch nicht ihr <acronym>EoL</acronym> erreicht haben, zur
      Verfügung gestellt werden.  Weitere Informationen über das &os;
      Sicherheitsteam und den unterstützten Versionen finden Sie auf
      der Webseite <link
	xlink:href="&url.base;/security">&os; Security</link>.</para>

    <para>Zu den Aufgaben des Sicherheitsteams zählt es, auf gemeldete
      Sicherheitslücken im &os;-Betriebssystem zu reagieren.  Sobald
      eine Sicherheitslücke bestätigt wird, überprüft das
      Sicherheitsteam die notwendigen Schritte, um die Schwachstelle
      zu beheben und den Quellcode mit der Korrektur zu
      aktualisieren.  Anschließend veröffentlicht es die Details in
      einem Sicherheitshinweis
      (<foreignphrase>Security Advisory</foreignphrase>).  Die
      Sicherheitshinweise werden auf der <link
	xlink:href="&url.base;/security/advisories.html">
	&os; Webseite</link> und auf den Mailinglisten
      &a.security-notifications.name;, &a.security.name; und
      &a.announce.name; veröffentlicht.</para>

    <para>Dieser Abschnitt beschreibt das Format eines
      &os; Sicherheitshinweises.</para>

    <sect2>
      <title>Format eines Sicherheitshinweis</title>

      <para>Hier ist ein Beispiel für einen &os;
	Sicherheitshinweis:</para>

      <programlisting>=============================================================================
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

=============================================================================
FreeBSD-SA-14:04.bind                                       Security Advisory
                                                          The FreeBSD Project

Topic:          BIND remote denial of service vulnerability

Category:       contrib
Module:         bind
Announced:      2014-01-14
Credits:        ISC
Affects:        FreeBSD 8.x and FreeBSD 9.x
Corrected:      2014-01-14 19:38:37 UTC (stable/9, 9.2-STABLE)
                2014-01-14 19:42:28 UTC (releng/9.2, 9.2-RELEASE-p3)
                2014-01-14 19:42:28 UTC (releng/9.1, 9.1-RELEASE-p10)
                2014-01-14 19:38:37 UTC (stable/8, 8.4-STABLE)
                2014-01-14 19:42:28 UTC (releng/8.4, 8.4-RELEASE-p7)
                2014-01-14 19:42:28 UTC (releng/8.3, 8.3-RELEASE-p14)
CVE Name:       CVE-2014-0591

For general information regarding FreeBSD Security Advisories,
including descriptions of the fields above, security branches, and the
following sections, please visit &lt;URL:http://security.FreeBSD.org/&gt;.

I.   Background

BIND 9 is an implementation of the Domain Name System (DNS) protocols.
The named(8) daemon is an Internet Domain Name Server.

II.  Problem Description

Because of a defect in handling queries for NSEC3-signed zones, BIND can
crash with an "INSIST" failure in name.c when processing queries possessing
certain properties.  This issue only affects authoritative nameservers with
at least one NSEC3-signed zone.  Recursive-only servers are not at risk.

III. Impact

An attacker who can send a specially crafted query could cause named(8)
to crash, resulting in a denial of service.

IV.  Workaround

No workaround is available, but systems not running authoritative DNS service
with at least one NSEC3-signed zone using named(8) are not vulnerable.

V.   Solution

Perform one of the following:

1) Upgrade your vulnerable system to a supported FreeBSD stable or
release / security branch (releng) dated after the correction date.

2) To update your vulnerable system via a source code patch:

The following patches have been verified to apply to the applicable
FreeBSD release branches.

a) Download the relevant patch from the location below, and verify the
detached PGP signature using your PGP utility.

[FreeBSD 8.3, 8.4, 9.1, 9.2-RELEASE and 8.4-STABLE]
# fetch http://security.FreeBSD.org/patches/SA-14:04/bind-release.patch
# fetch http://security.FreeBSD.org/patches/SA-14:04/bind-release.patch.asc
# gpg --verify bind-release.patch.asc

[FreeBSD 9.2-STABLE]
# fetch http://security.FreeBSD.org/patches/SA-14:04/bind-stable-9.patch
# fetch http://security.FreeBSD.org/patches/SA-14:04/bind-stable-9.patch.asc
# gpg --verify bind-stable-9.patch.asc

b) Execute the following commands as root:

# cd /usr/src
# patch &lt; /path/to/patch

Recompile the operating system using buildworld and installworld as
described in &lt;URL:https://www.FreeBSD.org/handbook/makeworld.html&gt;.

Restart the applicable daemons, or reboot the system.

3) To update your vulnerable system via a binary patch:

Systems running a RELEASE version of FreeBSD on the i386 or amd64
platforms can be updated via the freebsd-update(8) utility:

# freebsd-update fetch
# freebsd-update install

VI.  Correction details

The following list contains the correction revision numbers for each
affected branch.

Branch/path                                                      Revision
- -------------------------------------------------------------------------
stable/8/                                                         r260646
releng/8.3/                                                       r260647
releng/8.4/                                                       r260647
stable/9/                                                         r260646
releng/9.1/                                                       r260647
releng/9.2/                                                       r260647
- -------------------------------------------------------------------------

To see which files were modified by a particular revision, run the
following command, replacing NNNNNN with the revision number, on a
machine with Subversion installed:

# svn diff -cNNNNNN --summarize svn://svn.freebsd.org/base

Or visit the following URL, replacing NNNNNN with the revision number:

&lt;URL:https://svnweb.freebsd.org/base?view=revision&amp;revision=NNNNNN&gt;

VII. References

&lt;URL:https://kb.isc.org/article/AA-01078&gt;

&lt;URL:http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0591&gt;

The latest revision of this advisory is available at
&lt;URL:http://security.FreeBSD.org/advisories/FreeBSD-SA-14:04.bind.asc&gt;
-----BEGIN PGP SIGNATURE-----

iQIcBAEBCgAGBQJS1ZTYAAoJEO1n7NZdz2rnOvQP/2/68/s9Cu35PmqNtSZVVxVG
ZSQP5EGWx/lramNf9566iKxOrLRMq/h3XWcC4goVd+gZFrvITJSVOWSa7ntDQ7TO
XcinfRZ/iyiJbs/Rg2wLHc/t5oVSyeouyccqODYFbOwOlk35JjOTMUG1YcX+Zasg
ax8RV+7Zt1QSBkMlOz/myBLXUjlTZ3Xg2FXVsfFQW5/g2CjuHpRSFx1bVNX6ysoG
9DT58EQcYxIS8WfkHRbbXKh9I1nSfZ7/Hky/kTafRdRMrjAgbqFgHkYTYsBZeav5
fYWKGQRJulYfeZQ90yMTvlpF42DjCC3uJYamJnwDIu8OhS1WRBI8fQfr9DRzmRua
OK3BK9hUiScDZOJB6OqeVzUTfe7MAA4/UwrDtTYQ+PqAenv1PK8DZqwXyxA9ThHb
zKO3OwuKOVHJnKvpOcr+eNwo7jbnHlis0oBksj/mrq2P9m2ueF9gzCiq5Ri5Syag
Wssb1HUoMGwqU0roS8+pRpNC8YgsWpsttvUWSZ8u6Vj/FLeHpiV3mYXPVMaKRhVm
067BA2uj4Th1JKtGleox+Em0R7OFbCc/9aWC67wiqI6KRyit9pYiF3npph+7D5Eq
7zPsUdDd+qc+UTiLp3liCRp5w6484wWdhZO6wRtmUgxGjNkxFoNnX8CitzF8AaqO
UWWemqWuz3lAZuORQ9KX
=OQzQ
-----END PGP SIGNATURE-----</programlisting>

      <para>Jeder Sicherheitshinweis verwendet das folgende
	Format:</para>

      <itemizedlist>
	<listitem>
	  <para>Jeder Sicherheitshinweis wird mit dem
	    <acronym>PGP</acronym>-Schlüssel des
	    Sicherheitsbeauftragten unterzeichnet.  Der öffentliche
	    Schlüssel des Sicherheitsbeauftragten kann in <xref
	      linkend="pgpkeys"/> überprüft werden.</para>
	</listitem>

	<listitem>
	  <para>Der Name des Sicherheitshinweises beginnt immer mit
	    <literal>FreeBSD-SA-</literal> (für FreeBSD Security
	    Advisory), gefolgt vom Jahr im zweistelligen Format
	    (<literal>14:</literal>), gefolgt von der Anzahl von
	    Sicherheitshinweisen für dieses Jahr
	    (<literal>04.</literal>), gefolgt vom Namen der Anwendung
	    oder des betroffenen Subsystems (<literal>bind</literal>).
	    Der hier gezeigte Sicherheitshinweis ist der vierte
	    Hinweis für das Jahr 2014 und betrifft die Anwendung
	    <application>BIND</application>.</para>
	</listitem>

	<listitem>
	  <para>Das Feld <literal>Topic</literal> enthält eine
	    Beschreibung der Schwachstelle.</para>
	</listitem>

	<listitem>
	  <para>Das Feld <literal>Category</literal> beschreibt den
	    betroffenen Systemteil.  Mögliche Werte für dieses Feld
	    sind <literal>core</literal>, <literal>contrib</literal>
	    oder <literal>ports</literal>.  Die Kategorie
	    <literal>core</literal> gilt für Komponenten des
	    &os;-Betriebssystems, die Kategorie
	    <literal>contrib</literal> beschreibt zum Basissystem
	    gehörende Software Dritter, beispielsweise
	    <application>BIND</application>.  Die Kategorie
	    <literal>ports</literal> beschreibt Software, die Teil
	    der Ports-Sammlung ist.</para>
	</listitem>

	<listitem>
	  <para>Das Feld <literal>Module</literal> beschreibt die
	    betroffene Komponente.  Im diesem Beispiel ist das
	    <literal>bind</literal>-Modul betroffen, dass heißt
	    dieses Problem betrifft eine Anwendung aus dem
	    Betriebssystem.</para>
	</listitem>

	<listitem>
	  <para>Das Feld <literal>Announced</literal> gibt den
	    Zeitpunkt der Bekanntgabe des Sicherheitshinweises
	    an.  Das bedeutet, dass das Sicherheitsteam das Problem
	    bestätigt hat und das eine entsprechende Korrektur bereits
	    im &os; Quellcode-Repository zur Verfügung steht .</para>
	</listitem>

	<listitem>
	  <para>Das Feld <literal>Credits</literal> gibt die Person
	    oder Organisation an, die das Sicherheitsproblem
	    bemerkt und gemeldet hat.</para>
	</listitem>

	<listitem>
	  <para>Das Feld <literal>Affects</literal> listet die
	    &os;-Releases auf, die von dem Problem betroffen
	    sind.</para>
	</listitem>

	<listitem>
	  <para>Das Feld <literal>Corrected</literal> zeigt an,
	    wann das Problem in welchem Release behoben wurde.  Der
	    Teil in Klammern zeigt an, in welchem Zweig die
	    Aktualisierung eingeflossen ist und die entsprechende
	    Versionsnummer und Patch-Level des Release.  Der
	    Patch-Level besteht aus dem Buchstaben
	    <literal>p</literal>, gefolgt von einer Nummer.  Dies
	    erlaubt es dem Benutzer festzustellen, welche Korrekturen
	    bereits auf dem System eingespielt wurden.</para>
	</listitem>

	<listitem>
	  <para>Reserviert für Informationen, über die
	    auf <link xlink:href="http://cve.mitre.org">
	      cve.mitre.org</link> nach Sicherheitslücken
	    gesucht werden kann.</para>
	</listitem>

	<listitem>
	  <para>Im Feld <literal>Background</literal> wird
	    das betroffene Modul beschrieben.</para>
	</listitem>

	<listitem>
	  <para>Im Feld <literal>Problem Description</literal> wird
	    das Sicherheitsproblem beschrieben.  Hier wird
	    fehlerhafter Code beschrieben oder geschildert,
	    wie ein Werkzeug ausgenutzt werden könnte.</para>
	</listitem>

	<listitem>
	  <para>Das Feld <literal>Impact</literal> beschreibt die
	    Auswirkungen des Sicherheitsproblems auf ein
	    System.</para>
	</listitem>

	<listitem>
	  <para>Im Feld <literal>Workaround</literal> wird
	    eine Umgehung des Sicherheitsproblems beschrieben.
	    Die Umgehung ist für Administratoren gedacht,
	    die das System aus Zeitnot, Netzwerk-technischen oder
	    anderen Gründen nicht aktualisieren können.</para>
	</listitem>

	<listitem>
	  <para>Das Feld <literal>Solution</literal> enthält eine
	    getestete Schritt-für-Schritt Anleitung, die das
	    Sicherheitsproblem behebt.</para>
	</listitem>

	<listitem>
	  <para>Das Feld <literal>Correction Details</literal>
	    enthält die <application>Subversion</application>-Tags
	    der betroffenen Dateien zusammen mit zugehörigen
	    Revisionsnummern, in denen das Problem behoben
	    wurde.</para>
	</listitem>

	<listitem>
	  <para>Im Feld <literal>References</literal> finden sich
	    Verweise auf weitere Informationsquellen.</para>
	</listitem>
      </itemizedlist>
    </sect2>
  </sect1>

  <sect1 xml:id="security-accounting">
    <info>
      <title>Prozess-Überwachung</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	  </personname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>Prozess-Überwachung</primary>
    </indexterm>

    <para>Prozess-Überwachung
      (<foreignphrase>Process accounting</foreignphrase>) ist ein
      Sicherheitsverfahren, bei dem ein Administrator verfolgt,
      welche Systemressourcen verwendet werden und wie sich diese
      auf die einzelnen Anwender verteilen.  Dadurch kann das
      System überwacht werden und es ist sogar möglich,
      zu kontrollieren, welche Befehle ein Anwender eingibt.</para>

    <para>Die Überwachung von Prozessen hat sowohl Vor- als auch
      Nachteile.  Positiv ist, dass man einen Einbruchsversuch bis an
      den Anfang zurückverfolgen kann.  Von Nachteil ist allerdings,
      dass durch diesen Prozess Unmengen an Protokolldateien erzeugt
      werden, die auch dementsprechenden Plattenplatz benötigen.
      Dieser Abschnitt beschreibt die Grundlagen der
      Prozess-Überwachung.</para>

    <note>
      <para>Wenn Sie eine differenzierte Prozess-Überwachung
	benötigen, lesen Sie <xref linkend="audit"/>.</para>
    </note>

    <sect2>
      <title>Die Prozess-Überwachung aktivieren und
	konfigurieren</title>

      <para>Bevor Sie die Prozess-Überwachung verwenden können, müssen
	Sie diese über die folgenden Befehle aktivieren:</para>

      <screen>&prompt.root; <userinput>touch /var/account/acct</userinput>
&prompt.root; <userinput>chmod 600 /var/account/acct</userinput>
&prompt.root; <userinput>accton /var/account/acct</userinput>
&prompt.root; <userinput>echo 'accounting_enable="YES"' &gt;&gt; /etc/rc.conf</userinput></screen>

      <para>Einmal aktiviert, wird sofort mit der Überwachung von
	<acronym>CPU</acronym>-Statistiken, Befehlen und anderen
	Vorgängen begonnen.  Protokolldateien werden in einem
	nur von Maschinen lesbaren Format gespeichert und können
	mit <command>sa</command>  aufgerufen werden.  Ohne Optionen
	gibt <command>sa</command> Informationen wie die Anzahl der
	Aufrufe pro Anwender, die abgelaufene Zeit in Minuten, die
	gesamte <acronym>CPU</acronym>- und Anwenderzeit in Minuten
	und die durchschnittliche Anzahl der Ein- und
	Ausgabeoperationen aus.  &man.sa.8; enthält eine Liste der
	Optionen, welche die Ausgabe steuern.</para>

      <para>Benutzen Sie <command>lastcomm</command>, um die von den
	Benutzern ausgeführten Befehle anzuzeigen.  Dieses Beispiel
	zeigt die Nutzung von <command>ls</command> durch <systemitem
	  class="username">trhodes</systemitem> auf dem Terminal
	<literal>ttyp1</literal>:</para>

      <screen>&prompt.root; <userinput>lastcomm ls trhodes ttyp1</userinput></screen>

      <para>Zahlreiche weitere nützliche Optionen finden Sie
	&man.lastcomm.1;, &man.acct.5; sowie &man.sa.8;.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="security-resourcelimits">
    <title>Einschränkung von Ressourcen</title>

    <info>
      <authorgroup>
	<author>
	  <personname>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	  </personname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>Ressourcen einschränken</primary>
    </indexterm>

    <para>&os; bietet dem Systemadministrator mehrere
      Möglichkeiten die System-Ressourcen, die ein einzelner
      Benutzer verwenden kann, einzuschränken.
      Festplatten-Kontingente schränken den Plattenplatz, der
      einem Benutzer zur Verfügung steht, ein.  Kontingente werden
      im <xref linkend="quotas"/> diskutiert.</para>

    <indexterm><primary>Quotas</primary></indexterm>
    <indexterm>
      <primary>Benutzer einschränken</primary>
      <secondary>Quotas</secondary>
    </indexterm>

    <para>Einschränkungen auf andere Ressourcen, wie
      <acronym>CPU</acronym> und Speicher, können über eine
      Konfigurationsdatei oder über die Kommandozeile konfiguriert
      werden.  Traditionell werden Login-Klassen in
      <filename>/etc/login.conf</filename> definiert.  Obwohl diese
      Methode immer noch untersützt wird, muss nach jeder Änderung
      an dieser Datei die Ressourcen-Datenbank neu gebaut werden.
      Zudem müssen Sie die notwendigen Änderungen in
      <filename>/etc/master.passwd</filename> vornehmen und die
      Passwort-Datenbnak neu bauen.  Dieser Prozess kann, abhängig
      davon, wie viele Benutzer bearbeitet werden müssen, sehr
      zeitaufwändig sein.</para>

    <para>Mit
      <command>rctl</command> Ressourcen für Benutzer sehr
      detailliert gesteuert werden.  Dieser Befehl unterstützt nicht
      nur die Kontrolle der Ressourcen für Benutzer, sondern auch die
      Beschränkung auf Prozesse und Jails.</para>

    <para>In diesem Abschnitt werden beide Methoden
      vorgestellt.  Angefangen wird mit der traditionellen
      Methode.</para>

    <sect2 xml:id="users-limiting">
      <title>Login-Klassen konfigurieren</title>

      <indexterm><primary>Benutzer einschränken</primary></indexterm>
      <indexterm>
	<primary>Accounts</primary>
	<secondary>einschränken</secondary>
      </indexterm>
      <indexterm>
	<primary><filename>/etc/login.conf</filename></primary>
      </indexterm>

      <para>Bei der traditionellen Methode werden Login-Klassen und
	Ressourcenbeschränkungen in
	<filename>/etc/login.conf</filename> definiert.  Jeder
	Benutzer kann einer Login-Klasse zugewiesen werden
	(standardmäßig <literal>default</literal>) und jede
	Login-Klasse ist mit einem Satz von Login-Fähigkeiten
	verbunden.  Eine Login-Fähigkeit ist ein
	<literal><replaceable>Name</replaceable>=<replaceable>Wert</replaceable></literal>
	Paar, in dem <replaceable>Name</replaceable> die Fähigkeit
	bezeichnet und <replaceable>Wert</replaceable> ein beliebiger
	Text ist, der in Abhänigkeit von
	<replaceable>Name</replaceable> entsprechend verarbeitet
	wird.</para>

      <note>
	<para>Immer wenn <filename>/etc/login.conf</filename>
	  verändert wurde, muss die
	  <filename>/etc/login.conf.db</filename> mit dem folgenden
	  Kommando aktualisiert werden:</para>

	<screen>&prompt.root; <userinput>cap_mkdb /etc/login.conf</userinput></screen>
      </note>

      <para>Ressourcenbeschränkungen unterscheiden sich von normalen
	Login-Fähigkeiten zweifach.  Erstens gibt es für jede
	Beschränkung ein aktuelles und ein maximales Limit.  Das
	aktuelle Limit kann vom Benutzer oder einer Anwendung beliebig
	bis zum maximalen Limit verändert werden.  Letzteres kann
	der Benutzer nur heruntersetzen.  Zweitens gelten die meisten
	Ressourcenbeschränkungen für jeden vom Benutzer gestarteten
	Prozess.</para>

      <para><xref linkend="resource-limits"/> listet die
	gebräuchlichen Ressourcenbeschränkungen auf.  Alle verfügbaren
	Ressourcenbeschränkungen und Fähigkeiten sind im Detail in
	&man.login.conf.5; beschrieben.</para>

      <indexterm>
	<primary>Benutzer einschränken</primary>
	<secondary>coredumpsize</secondary>
      </indexterm>
      <indexterm>
	<primary>Benutzer einschränken</primary>
	<secondary>cputime</secondary>
      </indexterm>
      <indexterm>
	<primary>Benutzer einschränken</primary>
	<secondary>filesize</secondary>
      </indexterm>
      <indexterm>
	<primary>Benutzer einschränken</primary>
	<secondary>maxproc</secondary>
      </indexterm>
      <indexterm>
	<primary>Benutzer einschränken</primary>
	<secondary>memorylocked</secondary>
      </indexterm>
      <indexterm>
	<primary>Benutzer einschränken</primary>
	<secondary>memoryuse</secondary>
      </indexterm>
      <indexterm>
	<primary>Benutzer einschränken</primary>
	<secondary>openfiles</secondary>
      </indexterm>
      <indexterm>
	<primary>Benutzer einschränken</primary>
	<secondary>sbsize</secondary>
      </indexterm>
      <indexterm>
	<primary>Benutzer einschränken</primary>
	<secondary>stacksize</secondary>
      </indexterm>

      <table xml:id="resource-limits" frame="none" pgwide="1">
	<title>Ressourcenbeschränkungen für Login-Klassen</title>

	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Ressourcenbeschränkung</entry>
	      <entry>Beschreibung</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>coredumpsize</entry>
	      <entry>Das Limit der Größe einer core-Datei, die von
		einem Programm generiert wird, unterliegt aus
		offensichtlichen Gründen anderen Limits der
		Festplattenbenutzung, zum Beispiel
		<literal>filesize</literal> oder
		Festplattenkontingenten.  Es wird oft als weniger
		harte Methode zur Kontrolle des
		Festplattenplatz-Verbrauchs verwendet.  Da Benutzer
		die core-Dateien selbst nicht erstellen und sie oft
		nicht löschen, kann diese Option davor schützen, dass
		kein Festplattenspeicher mehr zur Verfügung steht,
		sollte ein großes Programm abstürzen.</entry>
	    </row>

	    <row>
	      <entry>cputime</entry>
	      <entry>Die maximale Rechenzeit, die ein Prozess eines
		Benutzers verbrauchen darf.  Überschreitet ein Prozess
		diesen Wert, wird er vom Kernel beendet.  Beachten
		Sie, dass die Rechen<emphasis>zeit</emphasis>
		limitiert wird, nicht die prozentuale
		Prozessorenbenutzung, wie es in einigen Feldern von
		<command>top</command> und <command>ps</command>
		dargestellt wird.</entry>
	    </row>

	    <row>
	      <entry>filesize</entry>
	      <entry>Hiermit lässt sich die maximale Größe einer Datei
		bestimmen, die der Benutzer besitzen darf.  Im
		Gegensatz zu <link
		  linkend="quotas">Festplattenkontingenten</link> ist
		diese Beschränkung nur für jede einzelne Datei gültig
		und nicht für den Platz, den alle Dateien eines
		Benutzers verwenden.</entry>
	    </row>

	    <row>
	      <entry>maxproc</entry>
	      <entry>Das ist die maximale Anzahl von Prozessen, die
		ein Benutzer starten darf, und beinhaltet sowohl
		Vordergrund- als auch Hintergrundprozesse.  Dieser
		Wert nicht höher sein als das System-Limit, das in
		<varname>kern.maxproc</varname> angegeben ist.
		Vergessen Sie nicht, dass ein zu kleiner Wert den
		Benutzer in seiner Produktivität einschränken könnte,
		wenn beispielsweise ein großes Programm übersetzt wird
		oder viele Prozesse gestartet sind.</entry>
	    </row>

	    <row>
	      <entry>memorylocked</entry>
	      <entry>Dieses Limit gibt an, wie viel virtueller
		Speicher von einem Prozess maximal im Arbeitsspeicher
		festgesetzt werden kann (siehe auch &man.mlock.2;).
		Ein paar systemkritische Programme, wie &man.amd.8;,
		verhindern damit einen Systemzusammenbruch, der
		auftreten könnte, wenn sie aus dem Speicher genommen
		werden.</entry>
	    </row>

	    <row>
	      <entry>memoryuse</entry>
	      <entry>Bezeichnet den maximalen Speicher, den ein
		Prozess benutzen darf und beinhaltet sowohl
		Arbeitsspeicher-, als auch Swap-Benutzung.  Es ist
		kein allübergreifendes Limit für den
		Speicherverbrauch, aber ein guter Anfang.</entry>
	    </row>

	    <row>
	      <entry>openfiles</entry>
	      <entry>Mit diesem Limit lässt sich die maximale Anzahl
		der von einem Prozess des Benutzers geöffneten Dateien
		festlegen.  In &os; werden Dateien auch verwendet, um
		Sockets und <acronym>>IPC</acronym>>-Kanäle
		darzustellen.  Setzen Sie es deshalb nicht zu niedrig.
		Das System-Limit ist in
		<varname>kern.maxfiles</varname> definiert.</entry>
	    </row>

	    <row>
	      <entry>sbsize</entry>
	      <entry>Dieses Limit beschränkt den Netzwerk-Speicher,
		den ein Benutzer verbrauchen darf.  Es kann generell
		dazu benutzt werden Netzwerk-Verbindungen zu
		beschränken.</entry>
	    </row>

	    <row>
	      <entry>stacksize</entry>
	      <entry>Das ist die maximale Größe, auf die der Stack
		eines Prozesses heranwachsen darf.  Das allein ist
		natürlich nicht genug, um den Speicher zu beschränken,
		den ein Programm verwenden darf.  Es sollte deshalb in
		Verbindung mit anderen Limits verwendet
		werden.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <para>Beim Setzen von Ressourcenbeschränkungen sind noch andere
	Dinge zu beachten:</para>

      <itemizedlist>
	<listitem>
	  <para>Von <filename>/etc/rc</filename> beim Hochfahren des
	    Systems gestartete Prozesse werden der
	    <literal>daemon</literal> Login-Klasse zugewiesen.</para>
	</listitem>

	<listitem>
	  <para>Obwohl die voreingestellte
	    <filename>/etc/login.conf</filename> sinnvolle Limits
	    enthält, sind sie evtl. nicht für jedes System geeignet.
	    Ein zu hohes Limit kann das System für Missbrauch anfällig
	    machen, und ein zu niedriges Limit kann der Produktivität
	    schaden.</para>
	</listitem>

	<listitem>
	  <para><application>&xorg;</application> beansprucht selbst
	    eine Menge Ressourcen und verleitet die Benutzer dazu,
	    mehrere Programme gleichzeitig laufen zu lassen.</para>
	</listitem>

	<listitem>
	  <para>Bedenken Sie, dass viele Limits für einzelne Prozesse
	    gelten und nicht für den Benutzer selbst.  Setzt man zum
	    Beispiel <varname>openfiles</varname> auf
	    <literal>50</literal>, kann jeder Prozess des Benutzers
	    bis zu <literal>50</literal> Dateien öffnen.  Dadurch
	    ist die maximale Anzahl von Dateien, die von einem
	    Benutzer geöffnet werden können,
	    <literal>openfiles</literal> mal
	    <literal>maxproc</literal>.  Das gilt auch für den
	    Speicherverbrauch.</para>
	</listitem>
      </itemizedlist>

      <para>Weitere Informationen über Ressourcenbeschränkungen,
	Login-Klassen und -Fähigkeiten finden Sie in &man.cap.mkdb.1;,
	&man.getrlimit.2; und &man.login.conf.5;.</para>
    </sect2>

    <sect2>
      <title>Einschränkung von Ressourcen aktivieren und
	konfigurieren</title>

      <para>Die Variable <varname>kern.racct.enable</varname> muss
	auf einen Wert ungleich Null eingestellt sein.  Angepasste
	Kernel benötigen eine spezielle Konfiguration:</para>

      <programlisting>options           RACCT
options         RCTL</programlisting>

      <para>Sobald das System mit dem neuen Kernel gestartet wird,
	kann <command>rctl</command> benutzt werden, um die Regeln für
	das System festzulegen.</para>

      <para>Die Syntax der Regeln wird durch
	<emphasis>subject</emphasis>, <emphasis>subject-id</emphasis>,
	<emphasis>resource</emphasis> und <emphasis>action</emphasis>
	gesteuert, wie in diesem Beispiel zu sehen ist:</para>

      <programlisting>user:trhodes:maxproc:deny=10/user</programlisting>

      <para>Diese Regel zeigt den grundlegenden Aufbau, hier mit dem
	Subjekt <literal>user</literal> und der Subjekt-ID
	<literal>trhodes</literal>.  <literal>maxproc</literal>
	definiert die Anzahl der Prozesse.  Die <quote>Aktion</quote>
	<literal>deny</literal> verhindert, dass neue Prozesse
	erstellt werden.  Im vorherigen Beispiel wurde für den
	Benutzer <literal>trhodes</literal> eine Beschränkung von
	<literal>10</literal> Prozessen konfiguriert.  Zu den weiteren
	Aktionen zählen beispielsweise die Protokollierung auf der
	Konsole, Benachrichtigungen an &man.devd.8; oder das Senden
	eines <literal>SIGTERM</literal> an einen Prozess.</para>

      <para>Beim hinzufügen von Regeln müssen einige Dinge beachtet
	werden.  Das obige Beispiel würde den Benutzer sogar daran
	hindern, einfachste Dinge zu tun, nachdem er sich anmeldet und
	eine <command>screen</command> Sitzung gestartet hat.  Sobald
	die Begrenzung für eine Ressource erreicht ist, wird folgende
	Fehlermeldung ausgegeben:</para>

      <screen>&prompt.root; <userinput>man test</userinput>
/usr/bin/man: Cannot fork: Resource temporarily unavailable
eval: Cannot fork: Resource temporarily unavailable</screen>

      <para>&man.rctl.8; kann auch benutzt werden, um einer Jail
	eine Speichergrenze zuzuweisen.  Eine solche Regel könnte
	wie folgt festgelegt werden:</para>

      <screen>&prompt.root; <userinput>rctl -a jail:httpd:memoryuse:deny=2G/jail</userinput></screen>

      <para>Damit die Regeln auch nach einem Neustart erhalten
	bleiben, müssen sie in <filename>/etc/rctl.conf</filename>
	hinzugefügt werden.  Dazu schreiben Sie einfach die Regel,
	ohne das vorhergehende Kommando.  Zum Beispiel:</para>

      <programlisting># Block jail from using more than 2G memory:
jail:httpd:memoryuse:deny=2G/jail</programlisting>

      <para>Mit <command>rctl</command> können auch Regeln entfernt
	werden:</para>

      <screen>&prompt.root; <userinput>rctl -r user:trhodes:maxproc:deny=10/user</userinput></screen>

      <para>&man.rctl.8; zeigt auch eine Möglichkeit, alle Regeln zu
	entfernen.  Falls es erforderlich ist alle Regeln für einen
	einzelnen Benutzer zu entfernen, kann dieser Befehl verwendet
	werden:</para>

      <screen>&prompt.root; <userinput>rctl -r user:trhodes</userinput></screen>

      <para>Es gibt noch viele weitere Ressourcen, die verwendet
	werden können, um zusätzliche <literal>subjects</literal> zu
	kontrollieren.  Weitere Informationen zu diesem Thema finden
	Sie in &man.rctl.8;.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="security-sudo">
    <info>
      <title>Gemeinsame Administration mit Sudo</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	  </personname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <personname>
	    <firstname>Björn</firstname>
	    <surname>Heidotting</surname>
	  </personname>
	  <contrib>Übersetzt von </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>Sicherheit</primary>
      <secondary>Sudo</secondary>
    </indexterm>

    <para>Systemadministratoren benötigen häufig die Möglichkeit,
      Benutzern erweiterte Berechtigungen zu gewähren, damit
      diese privilegierte Aufgaben ausführen können.  Die Idee, dass
      Teammitglieder einen Zugang zu einem &os;-System zur Verfügung
      gestellt bekommen, um ihre spezifischen Aufgaben erledigen zu
      können, stellt den Administrator vor eine große
      Herausforderung.  Diese Teammitglieder benötigen in der Regel
      nur einen eingeschränkten Zugang.  Für manche Aufgaben werden
      jedoch die Rechte des Superusers benötigt.  Zum Glück gibt es
      keinen Grund, diesen Mitgliedern einen solchen Zugang zu geben,
      da es Werkzeuge für genau diesen Anwendungsfall gibt.</para>

    <para>Bislang wurde in diesem Kapitel immer versucht, den Zugriff
      für autorisierte Benutzer zu gewähren und den Zugriff für
      nicht autorisierte Benutzer zu verhindern.  Ein weiteres Problem
      entsteht, sobald autorisierte Benutzer Zugriff auf die
      Ressourcen des Systems haben.  In vielen Fällen benötigen einige
      Benutzer Zugriff auf Startskripte von Anwendungen.  In anderen
      Fällen muss eine Gruppe von Administratoren das System
      verwalten.  Traditionell wird der Zugriff über Benutzer,
      Gruppen, Dateiberechtigungen und manchmal sogar &man.su.1;
      verwaltet.  Und da immer mehr Anwendungen einen Zugriff brauchen
      und immer mehr Benutzer Zugriff auf die Systemressourcen
      benötigen, ist ein besserer Lösungsansatz erforderlich.  Die am
      häufigsten verwendete Anwendung in solchen Fällen ist derzeit
      <application>Sudo</application>.</para>

    <para><application>Sudo</application> erlaubt dem Administrator
      eine rigide Konfiguration des Zugriffs auf bestimmte Kommandos
      und stellt einige erweiterte Protokollfunktionen zur Verfügung.
      Dieses Werkzeug kann als Port oder Paket
      <package>security/sudo</package> installiert werden.  Das Paket
      wird wie folgt installiert:</para>

    <screen>&prompt.root; <userinput>pkg install sudo</userinput></screen>

    <para>Nach der Installation können Sie <command>visudo</command>
      benutzen, um die Konfiguration in einem Texteditor zu öffnen.
      Es wird ausdrücklich <command>visudo</command> empfohlen, da
      dieses Programm die Syntax auf Fehler überprüft, bevor die
      Konfigurationsdatei gespeichert wird.</para>

    <para>Die Konfigurationsdatei besteht aus mehreren kleinen
      Abschnitten, die eine umfangreiche Konfiguration ermöglichen.
      Im folgenden Beispiel soll der Webentwickler (<systemitem
	class="username">user1</systemitem>) den Dienst
      <replaceable>webservice</replaceable> starten und stoppen
      dürfen.  Um ihm dieses Recht zu gewähren, fügen Sie folgende
      Zeile an das Ende von
      <filename>/usr/local/etc/sudoers</filename> ein:</para>

    <programlisting>user1   ALL=(ALL)       /usr/sbin/service webservice *</programlisting>

    <para>Der Benutzer kann jetzt
      <replaceable>webservice</replaceable> über dieses Kommando
      starten:</para>

    <screen>&prompt.user; <userinput>sudo /usr/sbin/service <replaceable>webservice</replaceable> start</userinput></screen>

    <para>Diese Konfiguration gestattet den Zugriff auf den
      <application>webservice</application> für einen einzelnen
      Benutzer.  Jedoch ist in den meisten Organisationen ein ganzes
      Team für die Verwaltung eines solchen Dienstes verantwortlich.
      Mit einer weiteren Zeile ist es möglich, einer ganzen Gruppe
      diesen Zugriff zu geben.  Die folgenden Schritte erstellen eine
      Gruppe mit den entsprechenden Benutzern.  Der Gruppe wird es
      dann ermöglicht, diesen Dienst zu verwalten:</para>

    <screen>&prompt.root; <userinput>pw groupadd -g 6001 -n webteam</userinput></screen>

    <para>Nun werden die Benutzer mit Hilfe von &man.pw.8; in die
      Gruppe <replaceable>webteam</replaceable> hinzugefügt:</para>

    <screen>&prompt.root; <userinput>pw groupmod -m user1 -n webteam</userinput></screen>

    <para>Zuletzt wird folgende Zeile in
      <filename>/usr/local/etc/sudoers</filename> hinzugefügt, damit
      jedes Mitglied von <replaceable>webteam</replaceable> den Dienst
      <replaceable>webservice</replaceable> verwalten kann:</para>

    <programlisting>%webteam   ALL=(ALL)       /usr/sbin/service webservice *</programlisting>

    <para>Im Gegensatz zu &man.su.1;, benötigt
      <application>Sudo</application> nur das Passwort des
      Benutzers.</para>

    <para>Benutzer, die mit Hilfe von <application>Sudo</application>
      Programme ausführen, müssen lediglich ihr eigenes Passwort
      eingeben.  Dies ist sicherer und bietet eine bessere Kontrolle
      als &man.su.1;, wo der Benutzer das <systemitem
	class="username">root</systemitem>-Passwort eingibt und damit
      alle Rechte von <systemitem class="username">root</systemitem>
      erlangt.</para>

    <tip>
      <para>Viele Organisationen haben bereits auf eine
	Zwei-Faktor-Authentifizierung umgestellt.  In diesen Fällen
	hat der Benutzer möglicherweise gar kein Passwort, welches er
	eingeben könnte.  <application>Sudo</application> bietet für
	solche Fälle die Variable <literal>NOPASSWD</literal>.  Wenn
	die Variable in die obige Konfiguration hinzugefügt wird,
	dürfen die Mitglieder der Gruppe
	<replaceable>webteam</replaceable> den Dienst verwalten, ohne
	ein Passwort eingeben zu müssen:</para>

      <programlisting>%webteam   ALL=(ALL)       NOPASSWD: /usr/sbin/service webservice *</programlisting>
    </tip>

    <sect2 xml:id="security-sudo-loggin">
      <title>Protokollierung</title>

      <para>Ein Vorteil von <application>Sudo</application> ist, dass
	Sitzungen protokolliert werden können.  Mit den integrierten
	Protokollmechanismen und dem Befehl
	<application>sudoreplay</application> können alle über
	<application>Sudo</application> ausgelösten Befehle
	protokolliert und zu einem späteren Zeitpunkt überprüft
	werden.  Um diese Funktion zu aktivieren, fügen Sie einen
	Eintrag für das Verzeichnis der Protokolle hinzu.  Dieses
	Beispiel verwendet eine Benutzervariable.  Weitere
	Informationen finden Sie in der Manualpage von
	<application>sudoreplay</application>.</para>

      <programlisting>Defaults iolog_dir=/var/log/sudo-io/%{user}</programlisting>

      <tip>
	<para>Dieses Verzeichnis wird automatisch nach der
	  Konfiguration erstellt.  Um auf der sicheren Seite zu sein,
	  ist es am besten, das System die Verzeichnisse mit
	  Standardberechtigungen erstellen zu lassen.  Dieser
	  Eintrag wird auch ein Protokoll für Administratoren
	  erstellen, wenn diese den Befehl
	  <application>sudoreplay</application> benutzen.  Um dieses
	  Verhalten zu ändern, kommentieren Sie die entsprechenden
	  Zeilen in <filename>sudoers</filename> aus.</para>
      </tip>

      <para>Nachdem dieser Eintrag in die Datei
	<filename>sudoers</filename> hinzugefügt wurde, kann die
	Konfiguration der Benutzer für die Protokollierung
	aktualisiert werden.  In dem gezeigten Beispiel würde der
	aktualisierte Eintrag für das
	<replaceable>webteam</replaceable> zusätzlich folgende
	Änderung benötigen:</para>

      <programlisting>%webteam ALL=(ALL) NOPASSWD: LOG_INPUT: LOG_OUTPUT: /usr/sbin/service webservice *</programlisting>

      <para>Von nun an wird jede Änderung am
	<replaceable>webservice</replaceable> protokolliert, wenn sie
	von einem Mitglied der Gruppe
	<replaceable>webteam</replaceable> initiiert wurde.  Eine
	Liste der Sitzungen kann wie folgt angezeigt werden:</para>

      <screen>&prompt.root; <userinput>sudoreplay -l</userinput></screen>

      <para>Wenn Sie eine bestimmte Sitzung wiedergeben möchten,
	suchen Sie in der Ausgabe nach dem Eintrag
	<literal>TSID=</literal> und übergeben Sie den Wert ohne
	weitere Optionen an <application>sudoreplay</application>.
	Zum Beispiel:</para>

      <screen>&prompt.root; <userinput>sudoreplay user1/00/00/02</userinput></screen>

      <warning>
	<para>Obwohl die Sitzungen protokolliert werden, kann ein
	  böswilliger Administrator wahllos die Sitzungsprotokolle
	  löschen.  Daher ist es eine gute Idee, eine tägliche
	  Kontrolle mit einem <foreignphrase>Intrusion Detection
	    System</foreignphrase> (<acronym>IDS</acronym>) oder
	  einer ähnlichen Software durchzuführen, so dass andere
	  Administratoren auf manuelle Änderungen aufmerksam gemacht
	  werden.</para>
      </warning>

      <para><application>sudoreplay</application> ist extrem
	erweiterbar.  Lesen Sie die Dokumentation für weitere
	Informationen.</para>
    </sect2>
  </sect1>
</chapter>
