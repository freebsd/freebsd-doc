<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde: de-docproj/books/handbook/security/chapter.sgml,v 1.131 2005/09/04 09:27:23 jkois Exp $
     basiert auf: 1.281
-->

<chapter id="security">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Matthew</firstname>
	<surname>Dillon</surname>
	<contrib>Viel von diesem Kapitel stammt aus der security(7)
	  Manualpage von </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Martin</firstname>
	<surname>Heinen</surname>
	<contrib>&Uuml;bersetzt von </contrib>
      </author>
    </authorgroup>
  </chapterinfo>

  <title>Sicherheit</title>
  <indexterm><primary>Sicherheit</primary></indexterm>

  <sect1 id="security-synopsis">
    <title>&Uuml;bersicht</title>

    <para>Dieses Kapitel bietet eine Einf&uuml;hrung in die Konzepte
      der Systemsicherheit.  Neben einigen Daumenregeln werden
      weiterf&uuml;hrende Themen wie S/Key, OpenSSL und Kerberos
      diskutiert.  Die meisten der hier besprochenen Punkte treffen
      sowohl auf die Systemsicherheit sowie die Internetsicherheit zu.
      Das Internet hat aufgeh&ouml;rt ein <quote>friedlicher</quote>
      Ort zu sein, an dem Sie nur nette Leute finden werden.  Es ist
      unumg&auml;nglich, dass Sie Ihre Daten, Ihr geistiges Eigentum,
      Ihre Zeit und vieles mehr vor dem Zugriff von Hackern
      sch&uuml;tzen.</para>

    <para>&os; besitzt eine Reihe von Werkzeugen und Mechanismen, um die
      Integrit&auml;t und die Sicherheit Ihrer Systeme und Netzwerke
      zu gew&auml;hrleisten.</para>

    <para>Nach dem Sie dieses Kapitel durchgearbeitet haben, werden
      Sie:</para>

    <itemizedlist>
      <listitem>
	<para>Grundlegende auf &os; bezogene Sicherheitsaspekte
	  kennen.</para>
      </listitem>

      <listitem>
	<para>Die verschiedenen Verschl&uuml;sselungsmechanismen
	  von &os;, wie <acronym>DES</acronym> oder
	  <acronym>MD5</acronym>, kennen.</para>
      </listitem>

      <listitem>
	<para>Wissen, wie Sie ein Einmalpassw&ouml;rter
	  zur Authentifizierung verwenden.</para>
      </listitem>

      <listitem>
	<para><acronym>TCP</acronym>-Wrapper f&uuml;r
	  <command>inetd</command> einrichten k&ouml;nnen.</para>
      </listitem>

      <listitem>
	<para>Wissen, wie Sie <application>KerberosIV</application>
	  vor 5.0-Release einrichten.</para>
      </listitem>

      <listitem>
	<para>Wissen, wie Sie <application>Kerberos5</application>
	  ab 5.0-Release einrichten.</para>
      </listitem>

      <listitem>
	<para>Firewalls mit <acronym>IPFW</acronym>
	  erstellen k&ouml;nnen.</para>
      </listitem>

      <listitem>
	<para>Wissen, wie Sie IPsec konfigurieren und ein
	  <acronym>VPN</acronym> zwischen &os;/&windows;
	  Systemen einrichten,</para>
      </listitem>

      <listitem>
	<para><application>OpenSSH</application>, &os;s
	  Implementierung von <acronym>SSH</acronym>, konfigurieren
	  und benutzen k&ouml;nnen.</para>
      </listitem>

      <listitem>
	<para><application>Portaudit</application> anwenden k&ouml;nnen,
	  um Softwarepakete Dritter, die Sie &uuml;ber die
	  Ports-Sammlung installieren, auf bekannte
	  Sicherheitsl&uuml;cken hin zu &uuml;berpr&uuml;fen.</para>
      </listitem>

      <listitem>
	<para>Mit &os;-Sicherheitshinweisen umgehen k&ouml;nnen.</para>
      </listitem>

      <listitem>
	<para>Eine Vorstellung davon haben, was Prozess&uuml;berwachung
	  (<foreignphrase>Process Accounting</foreignphrase>) ist und wie
	  Sie diese Funktion unter &os; aktivieren k&ouml;nnen.</para>
      </listitem>
    </itemizedlist>

    <para>Bevor Sie dieses Kapitel lesen, sollten Sie</para>

    <itemizedlist>
      <listitem>
	<para>Grundlegende Konzepte von &os; und dem Internet
	  verstehen.</para>
      </listitem>
    </itemizedlist>

    <para>Dieses Buch behandelt weitere Sicherheitsthemen.
      Beispielsweise werden vorgeschriebene Zugriffskontrollen
      in <xref linkend="mac"> und Firewalls in
      <xref linkend="firewalls"> besprochen.</para>
  </sect1>

  <sect1 id="security-intro">
    <title>Einf&uuml;hrung</title>

    <para>Sicherheit ist ein Konzept, das beim Systemadministrator anf&auml;ngt
      und aufh&ouml;rt.  Obwohl alle BSD &unix; Mehrbenutzersysteme &uuml;ber
      Sicherheitsfunktionen verf&uuml;gen, ist es wohl eine der
      gr&ouml;&szlig;ten Aufgaben eines Systemadministrators zus&auml;tzliche
      Sicherheitsmechanismen zu erstellen und zu pflegen.  Maschinen sind
      nur so sicher wie sie gemacht werden und Sicherheitsanforderungen
      stehen oft der Benutzerfreundlichkeit entgegen.  Auf &unix; Systemen
      k&ouml;nnen sehr viele Prozesse gleichzeitig laufen und viele dieser
      Prozesse sind Server, das hei&szlig;t von au&szlig;en kann auf sie
      zugegriffen werden.  In einer Zeit, in der die Minicomputer und
      Mainframes von gestern die Desktops von heute sind und Rechner
      immer mehr vernetzt werden, kommt der Sicherheit eine gro&szlig;e
      Bedeutung zu.</para>

    <para>Sicherheit wird am besten in mehreren Schichten implementiert.
      Kurz gesagt wollen Sie eine angemessene Anzahl Schichten einrichten,
      und dann das System auf Einbr&uuml;che hin beobachten.  Die
      Sicherheitsma&szlig;nahmen sollten nicht &uuml;berzogen werden,
      da sie sonst das Entdecken von Einbr&uuml;chen st&ouml;ren und die
      M&ouml;glichkeit, Einbr&uuml;che zu entdecken, ist einer der wichtigsten
      Aspekte einer Sicherheitsma&szlig;nahme.  Es macht zum Beispiel wenig
      Sinn, jedes Programm mit der <literal>schg</literal> Option (siehe auch
      &man.chflags.1;) zu sch&uuml;tzen, weil dies verhindert, dass ein
      Angreifer eine leicht zu entdeckende Ver&auml;nderung vornimmt und
      vielleicht dazu f&uuml;hrt, dass Ihre Sicherheitsvorkehrungen den
      Angreifer &uuml;berhaupt nicht entdecken.</para>

    <para>Zur Systemsicherheit geh&ouml;rt auch die Besch&auml;ftigung mit
      verschiedenen Arten von Angriffen, auch solchen, die versuchen,
      ein System still zu legen, oder sonst unbrauchbar zu machen ohne
      <username>root</username> zu kompromittieren.  Sicherheitsaspekte
      lassen sich in mehrere Kategorien unterteilen:</para>

    <orderedlist>
      <listitem>
	<para>Denial-of-Service Angriffe.</para>
      </listitem>

      <listitem>
	<para>Kompromittierte Accounts.</para>
      </listitem>

      <listitem>
	<para>Kompromittierter <username>root</username>-Account durch
	  zugreifbare Server.</para>
      </listitem>

      <listitem>
	<para>Kompromittierter <username>root</username>-Account durch
	  kompromittierte Accounts.</para>
      </listitem>

      <listitem>
	<para>Einrichten von Hintert&uuml;ren.</para>
      </listitem>
    </orderedlist>

    <indexterm>
      <primary>DoS Angriffe</primary>
      <see>Denial-of-Service (DoS)</see>
    </indexterm>
    <indexterm>
      <primary>Sicherheit</primary>
      <secondary>DoS Angriffe</secondary>
      <see>Denial-of-Service (DoS)</see>
    </indexterm>
    <indexterm><primary>Denial-of-Service (DoS)</primary></indexterm>

    <para>Ein Denial-of-Service (Verhinderung von Diensten, DoS) Angriff
      entzieht einer Maschine Ressourcen, die sie zur Bereitstellung
      von Diensten ben&ouml;tigt.  Meist versuchen Denial-of-Service Angriffe
      die Dienste oder den Netzwerkstack einer Maschine zu &uuml;berlasten,
      um so die Maschine auszuschalten oder nicht nutzbar zu machen.  Einige
      Angriffe versuchen, Fehler im Netzwerkstack auszunutzen, und die
      Maschine mit einem einzigen Paket auszuschalten.  Diese Art des
      Angriffs kann nur verhindert werden, indem der entsprechende Fehler
      im Kernel behoben wird.  Oft k&ouml;nnen Angriffe auf Dienste durch
      die Angabe von Optionen verhindert werden, die die Last, die ein
      Dienst auf das System unter widrigen Umst&auml;nden aus&uuml;ben kann,
      begrenzt.  Angriffen auf das Netzwerk ist schwerer zu begegnen.
      Au&szlig;er durch Trennen der Internetverbindung ist zum Beispiel
      einem Angriff mit gef&auml;lschten Paketen nicht zu begegnen.
      Diese Art von Angriff wird Ihr System zwar nicht unbrauchbar machen,
      kann aber die Internetverbindung s&auml;ttigen.</para>

    <indexterm>
      <primary>Sicherheit</primary>
      <secondary>kompromittierte Accounts</secondary>
    </indexterm>

    <para>Kompromittierte Accounts kommen noch h&auml;ufiger als
      DoS Angriffe vor.  Viele Systemadministratoren lassen auf ihren
      Maschinen noch die Dienste <application>telnetd</application>,
      <application>rlogind</application>, <application>rshd</application>
      und <application>ftpd</application> laufen.  Verbindungen zu diesen
      Servern werden nicht verschl&uuml;sselt.  Wenn Sie eine
      gr&ouml;&szlig;ere Benutzerzahl auf Ihrem System haben, die sich von
      einem entfernten System anmelden, ist die Folge davon, dass
      das Passwort eines oder mehrerer Benutzer ausgesp&auml;ht wurde.
      Ein aufmerksamer Systemadministrator wird die Logs &uuml;ber Anmeldungen
      von entfernten Systemen auf verd&auml;chtige Quelladressen, auch
      f&uuml;r erfolgreiche Anmeldungen, untersuchen.</para>

    <para>Es ist immer davon auszugehen, dass ein Angreifer, der
      Zugriff auf einen Account hat, Zugang zum
      <username>root</username>-Account erlangt.  Allerdings gibt der
      Zugriff auf einen Account auf einem gut gesicherten und
      gepflegten System nicht notwendig Zugriff auf den
      <username>root</username>-Account.  Diese Unterscheidung ist wichtig,
      da ein Angreifer, der keinen Zugang zu <username>root</username>
      besitzt, seine Spuren nicht verwischen kann.  Er kann h&ouml;chstens
      die Dateien des betreffenden Benutzers ver&auml;ndern oder die
      Maschine stilllegen.  Kompromittierte Accounts sind sehr
      h&auml;ufig, da Benutzer meist nicht dieselben Vorsichtsma&szlig;nahmen
      wie Administratoren treffen.</para>

    <indexterm>
      <primary>Sicherheit</primary>
      <secondary>Hintert&uuml;ren</secondary>
    </indexterm>

    <para>Es gibt viele Wege, Zugang zum <username>root</username>-Account
      eines Systems zu bekommen: Ein Angreifer kann das Passwort von
      <username>root</username> kennen, er kann einen Fehler in einem
      Server entdecken, der unter <username>root</username> l&auml;uft und
      dann &uuml;ber eine Netzwerkverbindung zu diesem Server einbrechen.
      Oder er kennt einen
      Fehler in einem SUID-<username>root</username> Programm, der es
      ihm erlaubt, <username>root</username> zu werden, wenn er einmal
      einen Account kompromittiert hat.  Wenn ein Angreifer einen
      Weg gefunden hat, <username>root</username> zu werden, braucht er
      vielleicht keine Hintert&uuml;r auf dem System installieren.
      Viele der heute
      bekannten und geschlossenen Sicherheitsl&ouml;cher, die zu einem
      <username>root</username> Zugriff f&uuml;hren, verlangen vom Angreifer
      einen erheblichen Aufwand, um seine Spuren zu verwischen.  Aus diesem
      Grund wird er sich wahrscheinlich entschlie&szlig;en, eine Hintert&uuml;r
      (engl. <foreignphrase>Backdoor</foreignphrase>) zu installieren.
      Eine Hintert&uuml;r erlaubt es
      dem Angreifer leicht auf den <username>root</username>-Account
      zuzugreifen.  Einem klugen Systemadministrator erlaubt sie allerdings
      auch, den Einbruch zu entdecken.  Wenn Sie es einem Angreifer verwehren,
      Hintert&uuml;ren zu installieren, kann das sch&auml;dlich f&uuml;r
      Ihre Sicherheit sein, da es vielleicht verhindert, dass die
      L&uuml;cke, die der Angreifer f&uuml;r den Einbruch ausgenutzt hat,
      entdeckt wird.</para>

    <para>Sicherheitsma&szlig;nahmen sollten immer in mehreren Schichten
      angelegt werden.  Die Schichten k&ouml;nnen wie folgt eingeteilt
      werden:</para>

    <orderedlist>
      <listitem>
	<para>Absichern von <username>root</username> und
	  Accounts.</para>
      </listitem>

      <listitem>
	<para>Absichern von unter <username>root</username> laufenden
	  Servern und SUID/SGID Programmen.</para>
      </listitem>

      <listitem>
	<para>Absichern von Accounts.</para>
      </listitem>

      <listitem>
	<para>Absichern der Passwort-Datei.</para>
      </listitem>

      <listitem>
	<para>Absichern des Kernels, der Ger&auml;te und von
	  Dateisystemen.</para>
      </listitem>

      <listitem>
	<para>Schnelles Aufdecken von unbefugten Ver&auml;nderungen des
	  Systems.</para>
      </listitem>

      <listitem>
	<para>Paranoia.</para>
      </listitem>
    </orderedlist>

    <para>Die einzelnen Punkte der obigen Liste werden im n&auml;chsten
      Abschnitt genauer behandelt.</para>
  </sect1>

  <sect1 id="securing-freebsd">
    <title>Absichern von &os;</title>

    <indexterm>
      <primary>Sicherheit</primary>
      <secondary>&os; absichern</secondary>
    </indexterm>

    <note>
      <title>Kommandos und Protokolle</title>
      <para>In diesem Abschnitt werden Anwendungen
	<application>fett</application> gekennzeichnet, spezifische
	Kommandos werden in einer <command>Fixschrift</command>
	dargestellt und Protokolle verwenden die normale Schriftart.
	Diese typographische Konvention hilft, Begriffe wie ssh
	zu unterscheiden, die sowohl Protokoll als auch Kommando
	sein k&ouml;nnen.</para>
    </note>

    <para>Die folgenden Abschnitte behandeln die im
      <link linkend="security-intro">letzten Abschnitt</link> erw&auml;hnten
      Methoden Ihr &os;-System zu sichern.</para>

    <sect2 id="securing-root-and-staff">
      <title>Absichern von <username>root</username> und
	Accounts</title>

      <indexterm>
        <primary><command>su</command></primary>
      </indexterm>

      <para>Zuallererst, k&uuml;mmern Sie sich nicht um die Absicherung
	von Accounts, wenn Sie <username>root</username>
	noch nicht abgesichert haben.  Auf den meisten Systemen ist
	<username>root</username> ein Passwort zugewiesen.  Sie
	sollten <emphasis>immer</emphasis> davon ausgehen, dass
	dieses Passwort kompromittiert ist.  Das hei&szlig;t nicht,
	dass Sie das Passwort entfernen sollten, da es meist
	f&uuml;r den Konsolenzugriff notwendig ist.  Vielmehr hei&szlig;t
	es, dass Sie das Passwort nicht au&szlig;erhalb der
	Konsole, auch nicht zusammen mit &man.su.1;, verwenden sollten.
	Stellen Sie sicher, dass Ihre PTYs in <filename>ttys</filename> als
	unsicher markiert sind und damit Anmeldungen von
	<username>root</username> mit <command>telnet</command> oder
	<command>rlogin</command> verboten sind.  Wenn Sie andere
	Anwendungen wie <application>SSH</application> zum Anmelden
	benutzen, vergewissern Sie sich, dass dort ebenfalls
	Anmeldungen als <username>root</username> verboten sind.  F&uuml;r
	<application>SSH</application> editieren Sie
	<filename>/etc/ssh/sshd_config</filename> und &uuml;berpr&uuml;fen,
	dass <literal>PermitRootLogin</literal> auf <literal>NO</literal>
	gesetzt ist.  Beachten Sie jede Zugriffsmethode &ndash; Dienste
	wie FTP werden oft vergessen.  Nur an der Systemkonsole sollte
	ein direktes Anmelden als <username>root</username> m&ouml;glich
	sein.</para>

      <indexterm>
        <primary><groupname>wheel</groupname></primary>
      </indexterm>

      <para>Nat&uuml;rlich m&uuml;ssen Sie als Systemadministrator
	<username>root</username>-Zugriff erlangen k&ouml;nnen.  Dieser
	sollte aber durch zus&auml;tzliche Passw&ouml;rter
	gesch&uuml;tzt sein.  Ein Weg, Zugang zu <username>root</username>
	zu erm&ouml;glichen, ist es, berechtigte Mitarbeiter in
	<filename>/etc/group</filename> in die Gruppe
	<groupname>wheel</groupname> aufzunehmen.  Die Personen, die
	Mitglieder in der Gruppe <groupname>wheel</groupname> sind,
	k&ouml;nnen mit <command>su</command> zu <username>root</username>
	wechseln.  Ihre Mitarbeiter sollten niemals die Gruppe
	<groupname>wheel</groupname> als prim&auml;re Gruppe in
	<filename>/etc/passwd</filename> besitzen.  Mitarbeiter sollten
	der Gruppe <groupname>staff</groupname> angeh&ouml;ren und &uuml;ber
	<filename>/etc/group</filename> in <groupname>wheel</groupname>
	aufgenommen werden.  Es sollten auch nur die Mitarbeiter, die
	wirklich <username>root</username> Zugriff ben&ouml;tigen in
	<groupname>wheel</groupname> aufgenommen werden.  Mit anderen
	Authentifizierungsmethoden m&uuml;ssen Sie niemanden in
	<groupname>wheel</groupname> aufnehmen.  Wenn Sie z.B.
	<application>Kerberos</application> benutzen, wechseln Sie mit
	&man.ksu.1; zu <username>root</username> und der Zugriff wird
	mit der Datei <filename>.k5login</filename> geregelt.  Dies ist
	vielleicht eine bessere L&ouml;sung, da es der
	<groupname>wheel</groupname>-Mechanismus einem Angreifer immer
	noch m&ouml;glich macht, den <username>root</username>-Account
	zu knacken, nachdem er einen Mitarbeiter-Account geknackt hat.
	Obwohl der <groupname>wheel</groupname>-Mechanismus besser als
	gar nichts ist, ist er nicht unbedingt die sicherste L&ouml;sung.</para>

      <para>Indirekt k&ouml;nnen Sie die Accounts von Mitarbeitern und
        damit auch den Zugriff auf <username>root</username> sch&uuml;tzen,
	indem Sie eine alternative Zugangsmethode verwenden und die
	Accounts der Mitarbeiter mit einem ung&uuml;ltigen verschl&uuml;sselten
	Passwort versehen.  Mit &man.vipw.8; k&ouml;nnen Sie jedes
	verschl&uuml;sselte Passwort mit einem
	<quote><literal>*</literal></quote> Zeichen ersetzen.  Das Kommando
	wird <filename>/etc/master.passwd</filename> und die
	Benutzer/Passwort Datenbank aktualisieren und die Passwort
	Authentifizierung abstellen.</para>

      <para>Ein Account wie</para>

      <programlisting>foobar:R9DT/Fa1/LV9U:1000:1000::0:0:Foo Bar:/home/foobar:/usr/local/bin/tcsh</programlisting>

      <para>sollte wie folgt abge&auml;ndert werden:</para>

      <programlisting>foobar:*:1000:1000::0:0:Foo Bar:/home/foobar:/usr/local/bin/tcsh</programlisting>

      <para>Da ein verschl&uuml;sseltes Passwort niemals
	ein <quote><literal>*</literal></quote> sein kann, verhindert dies
	die normale Anmeldung.  Damit m&uuml;ssen sich die Mitarbeiter
	mit anderen Mechanismen wie &man.kerberos.1; oder &man.ssh.1;
	authentifizieren.  Wenn Sie etwas wie
	<application>Kerberos</application> benutzen, m&uuml;ssen Sie
	die Maschinen, die die <application>Kerberos</application>-Server
	beheimaten und die Maschinen der Benutzer absichern.  Wenn Sie
	&ouml;ffentliche/private Schl&uuml;ssel mit
	<application>SSH</application> benutzen, muss die Maschine
	<emphasis>von</emphasis> der die Anmeldung gestartet wird, gesichert
	werden.  Als zus&auml;tzliche Sicherheitsschicht k&ouml;nnen Sie
	das Schl&uuml;sselpaar beim Erstellen mit &man.ssh-keygen.1; durch
	ein Passwort sch&uuml;tzen.  Dadurch, dass Sie die
	Passw&ouml;rter Ihrer Mitarbeiter als ung&uuml;ltig markiert
	haben, stellen Sie sicher, dass sich die Mitarbeiter nur mit
	den sicheren Methoden, die Sie aufgesetzt haben, anmelden k&ouml;nnen.
	Dies zwingt alle Mitarbeiter, verschl&uuml;sselte Verbindungen
	f&uuml;r ihre Sitzungen zu verwenden, und schlie&szlig;t ein
	wichtiges Loch, dass gerne von Angreifern ausgenutzt wird:
	Das Abh&ouml;ren des Netzwerks von einer anderen weniger gesicherten
	Maschine.</para>

      <para>Die indirekten Sicherheitsmechanismen setzen voraus, dass
	Sie sich von einer restriktiven Maschine auf einer weniger restriktiven
	Maschine anmelden.  Wenn zum Beispiel auf Ihrem Hauptrechner alle
	m&ouml;glichen Arten von Servern laufen, so sollten auf Ihrer
	Workstation keine Server laufen.  Um Ihre Workstation vern&uuml;nftig
	abzusichern, sollten auf Ihr so wenig Server wie m&ouml;glich bis hin
	zu keinem Server laufen.  Sie sollten zudem &uuml;ber einen
	Bildschirmschoner verf&uuml;gen, der mit einem Passwort
	gesichert ist.  Nat&uuml;rlich kann ein Angreifer, der physikalischen
	Zugang zu einer Maschine hat, jede Art von Sicherheitsmechanismen
	umgehen.  Dieses Problem sollten Sie daher auch in Ihren
	&Uuml;berlegungen ber&uuml;cksichtigen.  Beachten Sie dabei aber,
	dass der Gro&szlig;teil der Einbr&uuml;che &uuml;ber das
	Netzwerk erfolgt und die Einbrecher keinen Zugang zu der Maschine
	besitzen.</para>
      <indexterm><primary>KerberosIV</primary></indexterm>

      <para>Mit <application>Kerberos</application> k&ouml;nnen Sie das
	Passwort eines Mitarbeiters an einer Stelle &auml;ndern
	und alle Maschinen, auf denen der Mitarbeiter einen Account hat,
	beachten die &Auml;nderung sofort.  Wird der Account eines
	Mitarbeiters einmal kompromittiert, so sollte die F&auml;higkeit, das
	Passwort mit einem Schlag auf allen Maschinen zu &auml;ndern,
	nicht untersch&auml;tzt werden.  Mit einzelnen Passw&ouml;rtern
	wird es schwierig, das Passwort auf N Maschinen zu &auml;ndern.
	Mit <application>Kerberos</application> k&ouml;nnen Sie auch
	Beschr&auml;nkungen f&uuml;r Passw&ouml;rter festlegen:
	Nicht nur das Ticket kann nach einiger Zeit ung&uuml;ltig werden,
	Sie k&ouml;nnen auch festlegen, dass ein Benutzer nach einer
	bestimmten Zeit, z.B. nach einem Monat, das Passwort wechseln
	muss.</para>
    </sect2>

    <sect2>
      <title>Absichern von unter <username>root</username> laufenden
        Servern und SUID/SGID Programmen</title>

      <indexterm>
        <primary><command>ntalk</command></primary>
      </indexterm>
      <indexterm>
        <primary><command>comsat</command></primary>
      </indexterm>
      <indexterm>
        <primary><command>finger</command></primary>
      </indexterm>
      <indexterm>
        <primary>Sandk&auml;sten</primary>
      </indexterm>
      <indexterm>
        <primary><application>sshd</application></primary>
      </indexterm>
      <indexterm>
        <primary><application>telnetd</application></primary>
      </indexterm>
      <indexterm>
        <primary><application>rshd</application></primary>
      </indexterm>
      <indexterm>
        <primary><application>rlogind</application></primary>
      </indexterm>

      <para>Ein kluger Systemadministrator l&auml;sst nur die
	Dienste, die er wirklich braucht, laufen; nicht mehr und auch
	nicht weniger.  Beachten Sie, dass Server von Dritten die
	fehleranf&auml;lligsten sind.  Wenn Sie z.B. eine alte Version von
	<application>imapd</application> oder <application>popper</application>
	laufen lassen, ist das so, als w&uuml;rden Sie der ganzen Welt
	freien Zugang zu <username>root</username> geben.  Lassen Sie keine
	Server laufen, die Sie vorher nicht genau &uuml;berpr&uuml;ft haben.
	Viele Server m&uuml;ssen nicht unter <username>root</username>
	laufen, zum Beispiel k&ouml;nnen <application>ntalk</application>,
	<application>comsat</application> und <application>finger</application>
        in speziellen <firstterm>Sandk&auml;sten</firstterm> unter
	einem Benutzer laufen.  Ein Sandkasten ist keine perfekte L&ouml;sung,
	wenn Sie nicht eine Menge Arbeit in die Konfiguration investieren,
	doch bew&auml;hrt sich hier das Prinzip, die Sicherheit in Schichten
	aufzubauen.  Wenn es einem Angreifer gelingt, in einen Server,
	der in einem Sandkasten l&auml;uft, einzubrechen, dann muss
	er immer noch aus dem Sandkasten selber ausbrechen.  Je mehr Schichten
	der Angreifer zu durchbrechen hat, desto kleiner sind seine Aussichten
	auf Erfolg.  In der Vergangenheit wurden praktisch in jedem
	Server, der unter <username>root</username> l&auml;uft, L&uuml;cken
	gefunden, die zu einem <username>root</username> Zugriff f&uuml;hrten.
	Dies betrifft selbst die grundlegenden Systemdienste.  Wenn Sie eine
	Maschine betreiben, auf der man sich nur mit
	<application>SSH</application> anmelden kann, dann stellen Sie die
	Dienste <application>telnetd</application>,
	<application>rshd</application> oder <application>rlogind</application>
	ab!</para>

      <para>In der Voreinstellung laufen unter &os;
	<application>ntalkd</application>, <application>comsat</application>
	und <application>finger</application> nun in einem Sandkasten.  Ein
	weiteres Programm, das in einem Sandkasten laufen sollte, ist
	&man.named.8;.  In <filename>/etc/defaults/rc.conf</filename> sind
	die notwendigen Argumente, um <application>named</application> in
	einem Sandkasten laufen zu lassen, in kommentierter Form schon
	enthalten.  Abh&auml;ngig davon, ob Sie ein neues System installieren
	oder ein altes System aktualisieren, sind die hierf&uuml;r
	ben&ouml;tigten Benutzer noch nicht installiert.
	Ein kluger Systemadministrator sollte immer nach M&ouml;glichkeiten
	suchen, Server in einem Sandkasten laufen zu lassen.</para>
      <indexterm>
        <primary><application>sendmail</application></primary>
      </indexterm>

      <para>Einige Server wie <application>sendmail</application>,
	<application>popper</application>, <application>imapd</application>
	und <application>ftpd</application> werden normalerweise nicht in
	Sandk&auml;sten betrieben.  Zu einigen Servern gibt es Alternativen,
	aber diese wollen Sie vielleicht wegen der zus&auml;tzlich n&ouml;tigen
	Arbeit nicht installieren (ein weiteres Beispiel f&uuml;r den
	Widerspruch zwischen Sicherheit und Benutzerfreundlichkeit).
	In diesem Fall m&uuml;ssen Sie die
	Server unter <username>root</username> laufen lassen und auf die
	eingebauten Mechanismen vertrauen, Einbr&uuml;che zu entdecken.</para>

      <para>Weitere potentielle L&ouml;cher, die zu einem
	<username>root</username>-Zugriff f&uuml;hren k&ouml;nnen, sind
        die auf dem System installierten SUID- und SGID-Programme.  Die
	meisten dieser Programme wie <application>rlogin</application> stehen
	in <filename>/bin</filename>, <filename>/sbin</filename>,
	<filename>/usr/bin</filename>, oder <filename>/usr/sbin</filename>.
	Obwohl nichts 100% sicher ist, k&ouml;nnen Sie davon ausgehen,
	dass die SUID- und SGID-Programme des Basissystems ausreichend
	sicher sind.  Allerdings werden ab und an in diesen Programmen
	L&ouml;cher gefunden.  1998 wurde in <literal>Xlib</literal> ein
	Loch gefunden, das <application>xterm</application>, der
	normal mit SUID installiert wird, verwundbar machte.  Es ist besser
	auf der sicheren Seite zu sein, als sich sp&auml;ter zu beklagen,
	darum wird ein kluger Systemadministrator den Zugriff auf
	SUID-Programme mit einer Gruppe, auf die nur Mitarbeiter zugreifen
	k&ouml;nnen, beschr&auml;nken.  SUID-Programme, die niemand benutzt,
	sollten mit <command>chmod 000</command> deaktiviert werden.  Zum
	Beispiel braucht ein Server ohne Bildschirm kein
	<application>xterm</application> Programm.  SGID-Programme sind
	vergleichbar gef&auml;hrlich.  Wenn ein Einbrecher Zugriff auf
	SGID-<groupname>kmem</groupname> Programm erh&auml;lt, kann er
	vielleicht <filename>/dev/kmem</filename> und damit die
	verschl&uuml;sselte Passwortdatei lesen.  Dies kompromittiert
	unter Umst&auml;nden jeden Account, der mit einem Passwort
	gesch&uuml;tzt ist.  Alternativ kann ein Einbrecher, der in die
	Gruppe <groupname>kmem</groupname> eingebrochen ist, die
	Tastendr&uuml;cke auf PTYs verfolgen.  Dies schlie&szlig;t
	auch PTYs mit ein, auf denen sich ein Benutzer mit sicheren
	Methoden anmeldet.  Ein Einbrecher, der Zugriff auf die
	<groupname>tty</groupname> Gruppe hat, kann auf fast jeden Terminal
	anderer Benutzer schreiben.  Wenn der Benutzer einen Terminal-Emulator
	benutzt, der &uuml;ber eine Tastatur-Simulation verf&uuml;gt,
	k&ouml;nnte der Angreifer Daten generieren, die den Terminal
	veranlassen, ein Kommando unter diesem Benutzer laufen zu lassen.</para>
    </sect2>

    <sect2 id="secure-users">
      <title>Absichern von Accounts</title>

      <para>Accounts sind f&uuml;r gew&ouml;hnlich sehr schwierig
	abzusichern.  W&auml;hrend Sie drakonische Beschr&auml;nkungen
	f&uuml;r Ihre Mitarbeiter einrichten und deren Passw&ouml;rter
	als ung&uuml;ltig markieren k&ouml;nnen, werden Sie das
	vielleicht bei den normalen Accounts nicht durchsetzen.
	Wenn Sie &uuml;ber ausreichend Macht verf&uuml;gen, gelingt es Ihnen
	vielleicht doch, ansonsten m&uuml;ssen Sie diese Accounts
	aufmerksam &uuml;berwachen.  Wegen der zus&auml;tzlichen
	Administrationsarbeit und der n&ouml;tigen technischen
	Unterst&uuml;tzung ist die Verwendung von
	<application>SSH</application> und <application>Kerberos</application>
	mit normalen Accounts erschwert, obwohl das nat&uuml;rlich
	sicherer als die Verwendung von verschl&uuml;sselten
	Passw&ouml;rtern ist.</para>
    </sect2>

    <sect2>
      <title>Absichern der Passwort-Datei</title>

      <para>Der einzig sichere Weg ist, so viele Accounts wie m&ouml;glich als
	ung&uuml;ltig zu markieren und <application>SSH</application> oder
	<application>Kerberos</application> zu benutzen, um auf sie
	zuzugreifen.  Obwohl die Datei <filename>/etc/spwd.db</filename>,
	die die verschl&uuml;sselten Passw&ouml;rter enth&auml;lt,
	nur von <username>root</username> gelesen werden kann, mag ein
	Angreifer lesenden Zugriff auf diese Datei erlangen, ohne die
	F&auml;higkeit sie auch zu beschreiben.</para>

      <para>Ihre &Uuml;berwachungsskripten sollten &Auml;nderungen
	an der Passwort-Datei melden (siehe <link
	linkend="security-integrity">&Uuml;berpr&uuml;fen der
	Integrit&auml;t von Dateien</link> weiter unten).</para>
    </sect2>

    <sect2>
      <title>Absichern des Kernels, der Ger&auml;te und von
        Dateisystemen</title>

      <para>Wenn ein Angreifer <username>root</username>-Zugriff erlangt,
	kann er so ziemlich alles mit Ihrem System anstellen, doch sollten Sie
	es ihm nicht zu leicht machen.  Die meisten modernen Kernel haben
	zum Beispiel einen Ger&auml;tetreiber, der es erlaubt, Pakete
	abzuh&ouml;ren.  Unter &os; wird das Ger&auml;t
	<devicename>bpf</devicename> genannt.  F&uuml;r gew&ouml;hnlich
	wird ein Angreifer versuchen, dieses Ger&auml;t zu nutzen, um
	Pakete abzuh&ouml;ren.  Sie sollten ihm diese Gelegenheit nicht
	geben und auf den meisten Systemen ist das Ger&auml;t
	<devicename>bpf</devicename> nicht n&ouml;tig.</para>

      <indexterm>
        <primary><command>sysctl</command></primary>
      </indexterm>
      <para>Auch wenn Sie <devicename>bpf</devicename> nicht verwenden,
	m&uuml;ssen Sie sich immer noch um <filename>/dev/mem</filename>
	und <filename>/dev/kmem</filename> sorgen.  Au&szlig;erdem
	kann der Angreifer immer noch auf die rohen Ger&auml;te
	(<foreignphrase>raw devices</foreignphrase>)
	schreiben.  Weiterhin gibt es ein Programm zum Nachladen von
	Modulen in den Kernel: &man.kldload.8;.  Ein unternehmungslustiger
	Angreifer kann dies benutzen, um sein eigenes
	<devicename>bpf</devicename> oder ein anderes zum Abh&ouml;ren
	geeignetes Ger&auml;t in den laufenden Kernel einzubringen.  Um diese
	Probleme zu vermeiden, m&uuml;ssen Sie den Kernel auf einer
	h&ouml;heren Sicherheitsstufe, mindestens <literal>1</literal>,
	laufen lassen.  Die Sicherheitsstufe wird durch die Variable
	<varname>kern.securelevel</varname>, die mit <command>sysctl</command>
	gesetzt werden kann, angegeben.  Nachdem Sie die Sicherheitsstufe
	auf <literal>1</literal> gesetzt haben, sind schreibende Zugriffe
	auf rohe Ger&auml;te verboten und die speziellen
	<command>chflags</command> Optionen, wie <literal>schg</literal>
	werden erzwungen.  Sie m&uuml;ssen sicherstellen, dass die
	<literal>schg</literal> Option auf allen kritischen Programmen,
	Verzeichnissen und Skripten, die bis zum Setzen der Option laufen,
	aktiviert ist.  Das mag &uuml;bertrieben sein da eine Migration
	des Systems erschwert wird, wenn Sie auf einer h&ouml;heren
	Sicherheitsstufe arbeiten.  Sie k&ouml;nnen einen Kompromiss
	erreichen, indem Sie das System auf einer erh&ouml;hten
	Sicherheitsstufe laufen lassen, aber die <literal>schg</literal>
	Option nicht f&uuml;r jede Datei und jedes Verzeichnis auf der Welt
	setzen.  Eine andere M&ouml;glichkeit besteht darin,
	<filename>/</filename> und <filename>/usr</filename> einfach
	schreibgesch&uuml;tzt einzuh&auml;ngen.  Bedenken Sie, dass
	Sie das Aufdecken eines Einbruchs vielleicht verhindern, wenn
	Sie zu drastische Ma&szlig;nahmen zum Schutz Ihres Systems
	verwenden.</para>
    </sect2>

    <sect2 id="security-integrity">
      <title>&Uuml;berpr&uuml;fen der Integrit&auml;t von Dateien</title>

      <para>Sie k&ouml;nnen die Systemkonfiguration und die Dateien
	nur so weit sch&uuml;tzen, wie es die Benutzbarkeit des
	Systems nicht einschr&auml;nkt.  Wenn Sie zum Beispiel
	mit <command>chflags</command> die Option <literal>schg</literal>
	auf die meisten Dateien in <filename>/</filename> und
	<filename>/usr</filename> setzen, kann das Ihre Arbeit mehr behindern
	als n&uuml;tzen.  Die Ma&szlig;nahme sch&uuml;tzt zwar die
	Dateien, schlie&szlig;t aber auch eine M&ouml;glichkeit,
	Ver&auml;nderungen zu entdecken, aus.  Die letzte Schicht des
	Sicherheitsmodells &ndash; das Aufdecken von Einbr&uuml;chen &ndash;
	ist sicherlich die wichtigste.  Alle Sicherheitsma&szlig;nahmen sind
	nichts wert, oder wiegen Sie in falscher Sicherheit, wenn Sie
	nicht in der Lage sind, einen m&ouml;glichen Einbruch zu entdecken.
	Die H&auml;lfte der Sicherheitsma&szlig;nahmen hat die Aufgabe,
        einen Einbruch zu verlangsamen, um es zu erm&ouml;glichen, den
	Einbrecher auf frischer Tat zu ertappen.</para>

      <para>Der beste Weg, einen Einbruch zu entdecken, ist es, nach
	ver&auml;nderten, fehlenden oder unerwarteten Dateien zu suchen.
	Der wiederum beste Weg, nach ver&auml;nderten Dateien zu suchen, ist
	es, die Suche von einem anderen (oft zentralen) besonders
	gesch&uuml;tzten System durchzuf&uuml;hren.  Es ist wichtig, dass
	Ihre Sicherheits&uuml;berpr&uuml;fungen vor einem Angreifer
	verborgen bleiben und daher sind sie auf einem besonders
	gesch&uuml;tzten System gut aufgehoben.  Um dies optimal auszunutzen,
	m&uuml;ssen Sie dem besonders gesch&uuml;tzten System Zugriffsrechte
	auf die zu sch&uuml;tzenden Systeme geben.  Sie k&ouml;nnen die
	Dateisysteme der zu sch&uuml;tzenden Systeme schreibgesch&uuml;tzt
	f&uuml;r das besonders gesch&uuml;tzte System exportieren, oder
	Sie k&ouml;nnen der besonders gesch&uuml;tzten Maschine
	<application>SSH</application> auf die anderen Maschinen erlauben,
	indem Sie <application>SSH</application> Schl&uuml;sselpaare
	installieren.  Mit Ausnahme des verursachten Netzwerkverkehrs
	ist die NFS-Methode die am wenigsten sichtbare.  Sie erlaubt es Ihnen,
	nahezu unentdeckt die Dateisysteme der Clients zu beobachten.  Wenn
	Ihr besonders gesch&uuml;tztes System mit den Clients &uuml;ber
	einen Switch verbunden ist, ist die NFS-Methode oft das Mittel der
	Wahl.  Wenn das besonders gesch&uuml;tzte System allerdings
	mit einem Hub verbunden ist, oder der Zugriff &uuml;ber mehrere
	Router geschieht, ist die NFS-Methode aus der Netzwerksicht zu
	unsicher.  In einem solchen Fall ist <application>SSH</application>
	besser geeignet, auch wenn es deutliche Spuren
	hinterl&auml;sst.</para>

      <para>Wenn das besonders gesch&uuml;tzte System lesenden Zugriff
        auf die Clients hat, m&uuml;ssen Sie Skripten schreiben, die die
	&Uuml;berwachung durchf&uuml;hren.  Wenn Sie die NFS-Methode
	verwenden, k&ouml;nnen Sie dazu einfache Systemwerkzeuge wie
	&man.find.1; und &man.md5.1; benutzen.  Am besten berechnen
	Sie einmal am Tag MD5-Pr&uuml;fsummen der Dateien, Konfigurationsdateien
	in <filename>/etc</filename> und <filename>/usr/local/etc</filename>
	sollten &ouml;fter &uuml;berpr&uuml;ft werden.  Wenn Unstimmigkeiten
	zwischen den auf der besonders gesch&uuml;tzten Maschine gehaltenen
	MD5-Pr&uuml;fsummen und den ermittelten Pr&uuml;fsummen festgestellt
	werden, sollte Ihr System einen Systemadministrator benachrichtigen,
	der den Unstimmigkeiten dann nachgehen sollte.  Ein gutes Skript
	&uuml;berpr&uuml;ft das System auch auf verd&auml;chtige
	SUID-Programme sowie gel&ouml;schte oder neue Dateien in
	<filename>/</filename> und <filename>/usr</filename>.</para>

      <para>Wenn Sie <application>SSH</application> anstelle von NFS
	benutzen, wird das Erstellen der Skripten schwieriger.  Sie m&uuml;ssen
	die Skripten und die Programme wie <command>find</command> mit
	<command>scp</command> auf den Client kopieren.  Damit machen
	Sie die &Uuml;berpr&uuml;fung f&uuml;r einen Angreifer sichtbar.
	Au&szlig;erdem kann der SSH-Client auf dem
	Zielsystem schon kompromittiert sein.  Zusammenfassend, kann der
	Einsatz von <application>SSH</application> n&ouml;tig sein,
	wenn Sie &uuml;ber ungesicherte Verbindungen arbeiten, aber
	der Umgang mit dieser Methode ist auch sehr viel schwieriger.</para>

      <para>Ein gutes Sicherheitsskript wird auch Dateien von Benutzern,
	die den Zugriff auf ein System erm&ouml;glichen, wie
	<filename>.rhosts</filename>, <filename>.shosts</filename>,
	<filename>.ssh/authorized_keys</filename> usw., auf
	Ver&auml;nderungen untersuchen, die &uuml;ber die M&ouml;glichkeiten
	einer &Uuml;berpr&uuml;fung mit <literal>MD5</literal>,
	die ja nur Ver&auml;nderungen feststellen kann, hinausgehen.</para>

      <para>Wenn Sie &uuml;ber gro&szlig;e Partitionen verf&uuml;gen, kann
	es zu lange dauern, jede Datei zu &uuml;berpr&uuml;fen.  In diesem
	Fall sollten Sie beim Einh&auml;ngen des Dateisystems Optionen
	setzen, die das Ausf&uuml;hren von SUID-Programmen und den
	Zugriff auf Ger&auml;te verbieten.  &man.mount.8; stellt dazu
	die Optionen <option>nodev</option> und <option>nosuid</option>
	zur Verf&uuml;gung.  Sie sollten diese Dateien aber trotzdem
	mindestens einmal die Woche &uuml;berpr&uuml;fen, da das Ziel
	dieser Schicht das Aufdecken eines Einbruchs, auch wenn er nicht
	erfolgreich war, ist.</para>

      <para>Die Prozess&uuml;berwachung (siehe &man.accton.8;)
	des Betriebssystems steht ein g&uuml;nstiges Werkzeug zur
	Verf&uuml;gung, dass sich bei der Analyse eines Einbruchs
	als n&uuml;tzlich erweisen kann.  Insbesondere k&ouml;nnen Sie
	damit herausfinden, wie der Einbrecher in das System eingedrungen ist,
	vorausgesetzt die Dateien der Prozess&uuml;berwachung sind
	noch alle intakt.</para>

      <para>Schlie&szlig;lich sollten die Sicherheitsskripten die Logdateien
	analysieren.  Dies sollte so sicher wie m&ouml;glich durchgef&uuml;hrt
	werden, n&uuml;tzlich ist das Schreiben von Logdateien auf
	entfernte Systeme mit <command>syslog</command>.  Ein Einbrecher
	wird versuchen, seine Spuren zu verwischen.  Die Logdateien
	sind wichtig f&uuml;r den Systemadministrator, da er aus ihnen
	den Zeitpunkt und die Art des Einbruchs bestimmen kann.  Eine
	M&ouml;glichkeit, die Logdateien unver&auml;ndert aufzuheben,
	ist es, die Systemkonsole auf einen seriellen Port zu legen
	und die Informationen dort von einer gesicherten Maschine
	auszulesen.</para>
    </sect2>

    <sect2>
      <title>Paranoia</title>

      <para>Es schadet nicht, ein bisschen paranoid zu sein.
	Grunds&auml;tzlich darf ein Systemadministrator jede
	Sicherheitsma&szlig;nahme treffen, die die Bedienbarkeit des
	Systems nicht einschr&auml;nkt.  Er kann auch Ma&szlig;nahmen
	treffen, die die Bedienbarkeit einschr&auml;nken,
	wenn er diese vorher genau durchdacht hat.  Was noch wichtiger
	ist: Halten Sie sich nicht sklavisch an dieses Dokument, sondern
	f&uuml;hren Sie eigene Ma&szlig;nahmen ein, um nicht einem
	k&uuml;nftigen Angreifer, der auch Zugriff auf dieses Dokument
	hat, alle Ihre Methoden zu verraten.</para>
    </sect2>

    <sect2>
      <title>Denial-of-Service Angriffe</title>
      <indexterm><primary>Denial-of-Service (DoS)</primary></indexterm>

      <para>Dieser Abschnitt behandelt Denial-of-Service Angriffe (DoS).
	Ein DoS-Angriff findet typischerweise auf der Paketebene statt.
	W&auml;hrend Sie nicht viel gegen moderne Angriffe mit falschen
	Paketen, die das Netzwerk s&auml;ttigen, ausrichten k&ouml;nnen,
	k&ouml;nnen Sie allerdings den Schaden in der Hinsicht begrenzen,
	dass Ihre Server von einem solchen Angriff nicht gestoppt
	werden.</para>

      <orderedlist>
	<listitem>
	  <para>Begrenzen von <function>fork()</function> Aufrufen.</para>
	</listitem>

	<listitem>
	  <para>Begrenzen von Sprungbrett-Angriffen (ICMP response Angriffen,
	    <application>ping</application> zu Broadcast-Adressen usw.).</para>
	</listitem>

	<listitem>
	  <para>Kernel-Cache f&uuml;r Routen.</para>
	</listitem>
      </orderedlist>

      <para>Ein h&auml;ufiger DoS-Angriff gegen forkende Server versucht
	den Server dazu zu bringen, m&ouml;glichst viele Prozesse, viele
	Dateideskriptoren und viel Speicher zu verbrauchen, bis hin zu
	dem Punkt, an dem die Maschine ausf&auml;llt.  &man.inetd.8;
	besitzt einige Optionen, um diese Art von Angriffen zu begrenzen.
	Beachten Sie bitte, dass es m&ouml;glich ist, einen
	Ausfall einer Maschine zu verhindern, doch ist es generell nicht
	m&ouml;glich, den Ausfall eines Dienstes bei dieser Art
	von Angriffen zu verhindern.  Lesen Sie sich bitte die Manualpages
	von <application>inetd</application> gut durch und achten Sie speziell
	auf die Optionen <option>-c</option>, <option>-C</option> und
	<option>-R</option>.  Angriffe mit gef&auml;lschten IP-Adressen
	umgehen <option>-C</option>, so dass normalerweise eine
	Kombination der Optionen benutzt werden muss.  Manche Server,
	die nicht von <application>inetd</application> gestartet werden,
	besitzen Optionen, um den Start &uuml;ber <function>fork()</function>
	einzuschr&auml;nken.</para>

      <para><application>Sendmail</application> besitzt die Option
	<option>-OMaxDaemonChildren</option>, die besser als die
	eingebauten Optionen zur Begrenzung der Systemauslastung funktioniert.
	Sie sollten beim Start von <application>sendmail</application>
	<literal>MaxDaemonChildren</literal> so hoch setzen, dass Sie
	die erwartete Auslastung gut abfangen k&ouml;nnen.  Allerdings
	sollten Sie den Wert nicht so hoch setzen, dass der
	Rechner &uuml;ber seine eigenen F&uuml;&szlig;e f&auml;llt.
	Es ist auch klug, <application>sendmail</application> im
	Queue-Modus (<option>-ODeliveryMode=queued</option>) laufen zu
	lassen.  Der D&aelig;mon (<command>sendmail -bd</command>) sollte
	getrennt von den Queue-L&auml;ufen (<command>sendmail -q15m</command>)
	laufen.  Wenn Sie trotzdem eine sofortige Auslieferung der Post
	w&uuml;nschen, k&ouml;nnen Sie die Queue in einem geringeren
	Intervall, etwa <option>-q1m</option>, abarbeiten.  Geben Sie
	f&uuml;r <emphasis>dieses</emphasis>
	<application>sendmail</application> aber einen vern&uuml;nftigen
	Wert f&uuml;r <literal>MaxDaemonChildren</literal> an, um
	Fehler zu verhindern.</para>

      <para><application>Syslogd</application> kann direkt angegriffen
	werden.  Daher empfehlen wir Ihnen unbedingt die Option
	<option>-s</option> zu benutzen.  Sollte das nicht m&ouml;glich
	sein, benutzen Sie bitte <option>-a</option>.</para>

      <para>Vorsicht ist auch mit Diensten geboten, die automatisch
	eine R&uuml;ckverbindung er&ouml;ffnen, wie der
	reverse-identd der <application>TCP-Wrapper</application>.
        Diese Funktion der <application>TCP-Wrapper</application>
	sollten Sie normalerweise nicht benutzen.</para>

      <para>Es empfiehlt sich sehr, interne Dienste vor externen Zugriffen
	durch eine Firewall an der Grenze Ihres Netzwerks zu sch&uuml;tzen.
	Dahinter steckt mehr die Idee, das Netzwerk vor &Uuml;berlastung
	durch Angriffe von au&szlig;en zu sch&uuml;tzen, als interne
	Dienste vor einem <username>root</username>-Zugriff aus dem Netz
	zu sch&uuml;tzen.  Konfigurieren Sie immer eine Firewall, die
	alle Zugriffe blockiert, das hei&szlig;t blockieren Sie
	<emphasis>alles</emphasis> au&szlig;er den Ports A, B, C, D
	und M-Z.  Damit k&ouml;nnen Sie Zugriffe auf alle niedrigen
	Ports blockieren und Zugriffe auf spezielle Dienste wie
	<application>named</application>, wenn Sie den prim&auml;ren
	Namensdienst f&uuml;r eine Zone anbieten,
	<application>ntalkd</application> oder
	<application>sendmail</application> erlauben.  Wenn Sie die
	Firewall so konfigurieren, das sie in der Voreinstellung alle
	Zugriffe erlaubt, ist es sehr wahrscheinlich, dass Sie
	vergessen, eine Reihe von Diensten zu blockieren bzw. einen
	internen Dienst einf&uuml;hren und dann vergessen die Firewall
	zu aktualisieren.  Sie k&ouml;nnen immer die h&ouml;heren
	Portnummern &ouml;ffnen, ohne die niedrigen Portnummern,
	die nur von <username>root</username> benutzt werden d&uuml;rfen,
	zu kompromittieren.  Beachten Sie bitte auch, dass es
	&os; erlaubt, die Portnummern, die f&uuml;r dynamische
	Verbindungen zur Verf&uuml;gung stehen, zu konfigurieren.
	Mit <command>sysctl</command> lassen sich verschiedene
	Bereiche der <varname>net.inet.ip.portrange</varname> Variablen
	setzen (eine Liste erhalten Sie mit <command>sysctl -a | fgrep
	portrange</command>).
	So k&ouml;nnen Sie zum Beispiel die Portnummern 4000 bis 5000
	f&uuml;r den normalen Bereich und die Nummern 49152 bis 65535
	f&uuml;r den hohen Bereich vorsehen.  Dies erleichtert Ihnen
	die Konfiguration der Firewall, da Sie nun Zugriffe auf Ports
	unterhalb von 4000, mit Ausnahme der Dienste, die von au&szlig;en
	erreichbar sein sollen, blockieren k&ouml;nnen.</para>

      <indexterm><primary>ICMP_BANDLIM</primary></indexterm>

      <para>Eine andere Form eines DoS-Angriffs nutzt einen Server
	als Sprungbrett, der Server wird dabei so angegriffen, dass
	seine Antworten ihn selber, das lokale Netzwerk oder einen
	anderen Server &uuml;berlasten.  Der am h&auml;ufigsten verwendete
	Angriff dieser Art ist der <emphasis>ICMP ping broadcast
	Angriff</emphasis>.  Der Angreifer f&auml;lscht dazu
	<application>ping</application>-Pakete, die zu der Broadcast-Adresse
	Ihres LANs gesendet werden, indem er darin als Quelladresse
	die Adresse des Opfers einsetzt.  Wenn die Router an der Grenze
	Ihres Netzwerks <application>ping</application>-Pakete auf
	Broadcast-Adressen nicht abwehren, wird Ihr LAN gen&uuml;gend
	Netzwerkverkehr generieren, um das Ziel des Angriffs zu
	&uuml;berlasten.  Dies kann besonders effektiv sein, wenn der
	Angreifer diese Methode mit mehreren Dutzend Broadcast-Adressen
	&uuml;ber mehrere Netzwerke einsetzt.  Es wurden schon
	Broadcast-Angriffe mit &uuml;ber 120&nbsp;Megabit pro Sekunde
	gemessen.  Ein zweiter Sprungbrett-Angriff wird gegen
	das Fehlerbehandlungssystem von ICMP eingesetzt.  Indem ein Angreifer
	Pakete konstruiert, die eine ICMP-Fehlermeldung hervorrufen, kann
	er das einkommende Netzwerk des Servers s&auml;ttigen und diesen
	wiederum veranlassen sein ausgehendes Netzwerk mit ICMP-Antworten
	zu s&auml;ttigen.  Diese Art des Angriffs kann alle mbuf-Strukturen
	auf dem Server aufbrauchen und damit den Server stilllegen,
	insbesondere wenn der Server nicht in der Lage ist, die generierten
	ICMP-Antworten schnell genug abzuf&uuml;hren.  Der &os;-Kernel
	besitzt eine neue Option <option>ICMP_BANDLIM</option>, die die
	Auswirkungen von solchen Angriffen begrenzen kann.  Die letzte
	weit verbreitete Form von Sprungbrett-Angriffen verwendet
	interne <application>inetd</application>-Dienste wie den
	UDP <application>echo</application>-Dienst.  Der Angreifer f&auml;lscht
	dazu einfach ein UDP-Paket, indem er als Quellport den
	<application>echo</application>-Port von Server A
	und als Zielport den <application>echo</application>-Port von
	Server B angibt, wobei beide
	Server in Ihrem LAN stehen.  Die beiden Server werden nun
        dieses Paket zwischen sich hin und her schicken.  Der Angreifer
	kann die beiden Server und das LAN einfach damit &uuml;berlasten,
	dass er mehrere Pakete dieser Art generiert.  &Auml;hnliche
	Probleme gibt es mit dem internen
	<application>chargen</application>-Port, daher sollten Sie
	die internen <application>inetd</application>-Testdienste
	abstellen.</para>

      <para>Gef&auml;lschte IP-Pakete k&ouml;nnen dazu benutzt werden,
	den Kernel-Cache f&uuml;r Routen zu &uuml;berlasten.  Schauen Sie
	sich bitte die  <command>sysctl</command>-Parameter
	<varname>net.inet.ip.rtexpire</varname>, <varname>rtminexpire</varname>
	und <varname>rtmaxcache</varname> an.  Ein Angriff der gef&auml;lschte
	Pakete mit zuf&auml;lligen Quelladressen einsetzt, bewirkt, dass
	der Kernel eine Route im Route-Cache anlegt, die Sie sich mit
	<command>netstat -rna | fgrep W3</command> ansehen k&ouml;nnen.
	Diese Routen verfallen f&uuml;r gew&ouml;hnlich nach 1600 Sekunden.
	Wenn der Kernel feststellt, dass die Routingtabelle im Cache
	zu gro&szlig; geworden ist, wird er dynamisch den Wert von
	<varname>rtexpire</varname> verringern.  Dieser Wert wird aber nie
	kleiner werden als <varname>rtminexpire</varname>.  Daraus
	ergeben sich zwei Probleme:</para>

      <orderedlist>
	<listitem>
	  <para>Der Kernel reagiert nicht schnell genug, wenn ein
	    Server mit einer niedrigen Grundlast pl&ouml;tzlich angegriffen
	    wird.</para>
	</listitem>

	<listitem>
	  <para><varname>rtminexpire</varname> ist nicht klein genug,
	    um einen anhaltenden Angriff zu &uuml;berstehen.</para>
	</listitem>
      </orderedlist>

      <para>Wenn Ihre Server &uuml;ber eine T3 oder eine noch schnellere
	Leitung mit dem Internet verbunden sind, ist es klug, mit
        &man.sysctl.8; die Werte f&uuml;r <varname>rtexpire</varname> und
	<varname>rtminexpire</varname> h&auml;ndisch zu setzen.  Setzen
	Sie bitte keinen der Werte auf Null, au&szlig;er Sie wollen die
	Maschine zum Erliegen bringen.  Ein Wert von 2&nbsp;Sekunden f&uuml;r
	beide Parameter sollte ausreichen, um die Routingtabelle vor
	einem Angriff zu sch&uuml;tzen.</para>
    </sect2>

    <sect2>
      <title>Anmerkungen zum Zugriff mit Kerberos und SSH</title>
      <indexterm><primary><command>ssh</command></primary></indexterm>
      <indexterm><primary>KerberosIV</primary></indexterm>

      <para>Es gibt ein paar Punkte, die Sie beachten sollten, wenn Sie
	<application>Kerberos</application> oder <application>SSH</application>
	einsetzen wollen.  <application>Kerberos V</application> ist ein
	ausgezeichnetes Authentifizierungsprotokoll.  Leider gibt es
	Fehler, in den f&uuml;r <application>Kerberos</application>
	angepassten Versionen von <application>telnet</application> und
	<application>rlogin</application>, die sie ungeeignet f&uuml;r den
	Umgang mit bin&auml;ren Datenstr&ouml;men machen.  Weiterhin
	verschl&uuml;sselt <application>Kerberos</application> Ihre Sitzung
	nicht, wenn Sie nicht die <option>-x</option> Option verwenden,
	mit <application>SSH</application> wird dagegen alles
	verschl&uuml;sselt.</para>

      <para>Ein Problem mit SSH sind Weiterleitungen von Verbindungen.
	Wenn Sie von einer sicheren Maschine, auf der sich Ihre
	Schl&uuml;ssel  befinden, eine Verbindung zu einer
	ungesicherten Maschine aufmachen, wird f&uuml;r die Dauer der
	Sitzung ein Port f&uuml;r Weiterleitungen ge&ouml;ffnet.
	Ein Angreifer, der auf der unsicheren Maschine Zugang zu
	<username>root</username> hat, kann diesen Port
	benutzen, um Zugriff auf andere Maschinen zu
	erlangen, die mit Ihren Schl&uuml;sseln zug&auml;nglich
	sind.</para>

      <para>Wir empfehlen Ihnen, f&uuml;r die Logins Ihrer Mitarbeiter immer
	<application>SSH</application> zusammen mit
	<application>Kerberos</application> einzusetzen.  Damit reduzieren
	Sie die Abh&auml;ngigkeit von potentiell gef&auml;hrdeten
	Schl&uuml;sseln und sch&uuml;tzen gleichzeitig die Passw&ouml;rter
	mit <application>Kerberos</application>.
	<application>SSH</application>-Schl&uuml;sselpaare sollten nur
	f&uuml;r automatisierte Aufgaben von einem besonders gesicherten
	Server eingesetzt werden (<application>Kerberos</application>
	kann f&uuml;r diese Art von Aufgaben nicht eingesetzt werden).
	Weiterhin empfehlen wir Ihnen, das Weiterreichen von Schl&uuml;sseln
	in der <application>SSH</application>-Konfiguration abzustellen bzw.
	die <literal>from=IP/DOMAIN</literal> Option in
	<filename>authorized_keys</filename> zu verwenden, die den
	Schl&uuml;ssel nur von bestimmten Maschinen aus nutzbar macht.</para>
    </sect2>
  </sect1>

  <sect1 id="crypt">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Bill</firstname>
	  <surname>Swingle</surname>
	  <contrib>Teile umgeschrieben und aktualisiert von </contrib>
	</author>
      </authorgroup>
      <!-- 21 Mar 2000 -->
    </sect1info>

    <title>DES, MD5, und <function>crypt()</function></title>
    <indexterm>
      <primary>Sicherheit</primary>
      <secondary><function>crypt()</function></secondary>
    </indexterm>

    <indexterm><primary><function>crypt()</function></primary></indexterm>
    <indexterm><primary>DES</primary></indexterm>
    <indexterm><primary>MD5</primary></indexterm>

    <para>Jedem Benutzer eines &unix; Systems ist ein Passwort zugeordnet.
      Es scheint offensichtlich, dass das Passwort nur dem Benutzer
      und dem System bekannt sein muss.  Um die Passw&ouml;rter
      geheim zu halten, werden sie mit einer nicht umkehrbaren Hash-Funktion
      verschl&uuml;sselt, das hei&szlig;t sie k&ouml;nnen leicht
      verschl&uuml;sselt aber nicht entschl&uuml;sselt werden.  Was wir
      gerade als offensichtlich dargestellt haben, ist also nicht wahr: Das
      Betriebssystem kennt das Passwort <emphasis>wirklich</emphasis>
      nicht, es kennt nur das <emphasis>verschl&uuml;sselte</emphasis>
      Passwort.  Die einzige M&ouml;glichkeit, das originale Passwort
      herauszufinden, besteht darin, alle m&ouml;glichen Passw&ouml;rter
      auszuprobieren (<foreignphrase>brute force</foreignphrase> Suche).</para>

    <para>Zu der Zeit als &unix; entstanden ist, war die einzig sichere
      M&ouml;glichkeit Passw&ouml;rter zu verschl&uuml;sseln, leider
      DES (Data Encryption Standard).  F&uuml;r die Einwohner der USA
      stellte das kein Problem dar, aber da der Quellcode von DES nicht aus
      den USA exportiert werden durfte, musste ein Weg gefunden werden,
      der die Gesetze der USA nicht verletzte und gleichzeitig die
      Kompatibilit&auml;t mit anderen &unix; Systemen, die immer noch DES
      benutzten, wahrte.</para>

    <para>Die L&ouml;sung bestand darin, die Verschl&uuml;sselungsbibliotheken
      aufzuspalten.  Benutzer in den USA konnten die DES-Bibliotheken
      installieren und nutzen.  In der Grundeinstellung benutzt &os;
      MD5 als Verschl&uuml;sselungsmethode, das exportiert werden durfte
      und damit von jedem genutzt werden konnte.  Es wird davon ausgegangen,
      dass MD5 sicherer als DES ist, so dass DES nur aus
      Kompatibilit&auml;tsgr&uuml;nden installiert werden sollte.</para>

    <sect2>
      <title>Erkennen der Verschl&uuml;sselungsmethode</title>

      <para>Vor &os;&nbsp;4.4 war <filename>libcrypt.a</filename> ein
        symbolischer Link, der auf die Library zeigte, die die
	Verschl&uuml;sselungsroutinen enthielt.  Seit &os;&nbsp;4.4 enth&auml;lt
	<filename>libcrypt.a</filename> verschiedene Hash-Funktionen, deren
	Anwendung sich konfigurieren l&auml;sst.  Momentan werden
	DES-, MD5- und Blowfish-Hash Funktionen unterst&uuml;tzt.  In der
	Voreinstellung benutzt &os; die MD5-Hash Funktion.</para>

      <para>Sie k&ouml;nnen leicht herausfinden, welche
	Verschl&uuml;sselungsmethode von &os; verwendet wird.  Ein Weg
	besteht darin, die verschl&uuml;sselten Passw&ouml;rter in
	<filename>/etc/master.passwd</filename> zu untersuchen.
	Passw&ouml;rter, die mit MD5 verschl&uuml;sselt wurden,
	sind l&auml;nger als die mit DES verschl&uuml;sselten und
	beginnen mit den Zeichen <literal>&dollar;1&dollar;</literal>.
	Passw&ouml;rter, die mit <literal>&dollar;2a&dollar;</literal>
	anfangen, wurden mit der Blowfish-Funktion verschl&uuml;sselt.
	DES Passw&ouml;rter besitzen keine offensichtlichen Merkmale,
	an denen sie identifiziert werden k&ouml;nnten.  Sie sind aber
	k&uuml;rzer als MD5-Passw&ouml;rter und sind in einem
	64 Zeichen umfassenden Alphabet kodiert, das das
	<literal>&dollar;</literal>-Zeichen nicht enth&auml;lt.  Ein relativ
	kurzes Passwort, das nicht mit einem
	<literal>&dollar;</literal>-Zeichen anf&auml;ngt, ist wahrscheinlich
	ein DES-Passwort.</para>

      <para>Die Verschl&uuml;sselungsmethode f&uuml;r neue
        Passw&ouml;rter wird durch <literal>passwd_format</literal> in
	<filename>/etc/login.conf</filename> bestimmt.  Der Wert dieser
	Variablen kann entweder <literal>des</literal>, <literal>md5</literal>
	oder <literal>blf</literal> sein.  N&auml;heres schlagen Sie bitte
	in &man.login.conf.5; nach.</para>
    </sect2>
  </sect1>

  <sect1 id="one-time-passwords">
    <title>Einmalpassw&ouml;rter</title>
    <indexterm><primary>Einmalpassw&ouml;rter</primary></indexterm>
    <indexterm>
      <primary>Sicherheit</primary>
      <secondary>Einmalpassw&ouml;rter</secondary>
    </indexterm>

    <para>S/Key ist ein Einmalpasswort System, das auf einer nicht
      umkehrbaren Hash-Funktion beruht.  Aus Kompatibilit&auml;tsgr&uuml;nden
      benutzt &os; MD4-Hashes, andere Systeme benutzen MD5 und DES-MAC.
      S/Key ist seit Version 1.1.5 Teil des &os;-Basissystems und wird
      auf einer wachsenden Anzahl anderer Systeme benutzt.  S/Key
      ist eine gesch&uuml;tzte Warenmarke von
      Bell Communications Research, Inc.</para>

    <para>Ab &os;&nbsp;5.0 wurde S/Key durch OPIE
      (One-time Passwords In Everything), das die gleichen Funktionen
      bietet, abgel&ouml;st.  OPIE benutzt MD5 Hash-Funktionen.</para>

    <para>Im Folgenden werden drei verschiedene
      Passw&ouml;rter verwendet.  Das Erste ist Ihr normales System- oder
      Kerberos-Passwort und wird im Folgenden <quote>System-Passwort</quote>
      genannt.  Das Zweite ist das Einmalpasswort, das bei S/Key
      von <command>key</command> oder bei OPIE von
      <command>opiekey</command> generiert wird.  Dieses Passwort wird von
      den Programmen <command>keyinit</command> oder
      <command>opiepasswd</command> und dem Login-Programm akzeptiert.  Im
      Folgenden wird es <quote>Einmalpasswort</quote> genannt.  Das Dritte
      Passwort ist das geheime Passwort, das Sie mit den Programmen
      <command>key</command>/<command>opiekey</command> (manchmal auch mit
      <command>keyinit</command>/<command>opiepasswd</command>) zum Erstellen
      der Einmalpassw&ouml;rter verwenden.  Dieses Passwort
      werden wir im Folgenden <quote>geheimes Passwort</quote>
      oder schlicht <quote>Passwort</quote> nennen.</para>

    <para>Das geheime Passwort steht in keiner Beziehung zu Ihrem
      System-Passwort, beide k&ouml;nnen gleich sein, obwohl das nicht
      empfohlen wird.  Die geheimen Passw&ouml;rter von S/Key oder
      OPIE sind nicht auf eine L&auml;nge von 8&nbsp;Zeichen,
      wie alte &unix; Passw&ouml;rter<footnote>
	<para>Unter &os; darf das System-Passwort maximal
	  128&nbsp;Zeichen lang sein.</para></footnote>, beschr&auml;nkt.
      Sie k&ouml;nnen so lang sein, wie Sie wollen.  Gebr&auml;uchlich sind
      Passw&ouml;rter, die sich aus sechs bis sieben W&ouml;rtern
      zusammensetzen.  Das S/Key oder OPIE System arbeitet
      gr&ouml;&szlig;tenteils unabh&auml;ngig von den
      auf &unix; Systemen verwendeten Passwort-Mechanismen.</para>

    <para>Neben dem Passwort gibt es noch zwei Werte, die f&uuml;r
      S/Key und OPIE wichtig sind.  Der erste ist der
      <quote>Initialwert</quote> (engl. <foreignphrase>seed</foreignphrase>
      oder <foreignphrase>key</foreignphrase>), der aus zwei Buchstaben
      und f&uuml;nf Ziffern besteht.  Der zweite Wert ist der
      <quote>Iterationsz&auml;hler</quote>, eine Zahl zwischen
      1 und 100.  S/Key generiert das Einmalpasswort, indem
      es den Initialwert und das geheime Passwort aneinander h&auml;ngt
      und dann die MD4/MD5 Hash-Funktion so oft, wie durch den
      Iterationsz&auml;hler gegeben, anwendet.  Das Ergebnis wird in
      sechs englische W&ouml;rter umgewandelt, die Ihr Einmalpasswort
      sind.  Das Authentifizierungssystem (meistens PAM) merkt sich das
      zuletzt benutzte Einmalpasswort und Sie sind authentisiert,
      wenn die Hash-Funktion des Passworts dem vorigen Passwort
      entspricht.  Da nicht umkehrbare Hash-Funktionen benutzt werden,
      ist es unm&ouml;glich, aus einem bekannten Passwort weitere
      g&uuml;ltige Einmalpassw&ouml;rter zu berechnen.  Der
      Iterationsz&auml;hler wird nach jeder erfolgreichen Anmeldung um
      eins verringert und stellt so die Synchronisation zwischen Benutzer
      und Login-Programm sicher.  Wenn der Iterationsz&auml;hler den
      Wert 1 erreicht, m&uuml;ssen S/Key und OPIE neu initialisiert
      werden.</para>

    <para>In jedem System werden drei Programme verwendet, die weiter unten
      beschrieben werden.  Die Programme <command>key</command> und
      <command>opiekey</command> verlangen einen Iterationsz&auml;hler,
      einen Initialwert und ein geheimes Passwort.  Daraus generieren
      sie ein Einmalpasswort oder eine Liste von
      Einmalpassw&ouml;rtern.  Die Programme <command>keyinit</command>
      und <command>opiepasswd</command> werden benutzt, um S/Key bzw.
      OPIE zu initialisieren.  Mit ihnen k&ouml;nnen Passw&ouml;rter,
      Iterationsz&auml;hler oder Initialwerte ge&auml;ndert werden.
      Als Parameter verlangen sie entweder ein geheimes Passwort
      oder einen Iterationsz&auml;hler oder einen Initialwert und ein
      Einmalpasswort.  Die Programme <command>keyinfo</command>
      und <command>opieinfo</command> geben den momentanen
      Iterationsz&auml;hler und Initialwert eines Benutzers aus.  Diese
      werden aus den Dateien <filename>/etc/skeykeys</filename> bzw.
      <filename>/etc/opiekeys</filename> ermittelt.</para>
      <!-- Credential Dateien -->

    <para>Im Folgenden werden vier verschiedene T&auml;tigkeiten beschrieben.
      Zuerst wird erl&auml;utert, wie <command>keyinit</command> oder
      <command>opiepasswd</command> &uuml;ber eine gesicherte Verbindung
      eingesetzt werden, um Einmalpassw&ouml;rter das erste Mal
      zu konfigurieren oder das Passwort oder den Initialwert
      zu &auml;ndern.  Als n&auml;chstes wird erkl&auml;rt, wie
      <command>keyinit</command> oder <command>opiepasswd</command>
      &uuml;ber eine nicht gesicherte Verbindung, zusammen mit
      <command>key</command> oder <command>opiekey</command> &uuml;ber eine
      gesicherte Verbindung, eingesetzt werden, um dasselbe zu erreichen.
      Als drittes wird beschrieben, wie
      <command>key</command>/<command>opiekey</command> genutzt werden,
      um sich &uuml;ber eine nicht gesicherte Verbindung anzumelden.
      Die vierte T&auml;tigkeit beschreibt, wie mit <command>key</command>
      oder <command>opiekey</command> eine Reihe von Schl&uuml;sseln
      generiert werden, die Sie sich aufschreiben oder ausdrucken k&ouml;nnen,
      um sich von Orten anzumelden, die &uuml;ber keine gesicherten
      Verbindungen verf&uuml;gen.</para>

    <sect2>
      <title>Einrichten &uuml;ber eine gesicherte Verbindung</title>

      <para>Benutzen Sie <command>keyinit</command> um S/Key das erste
	Mal einzurichten, das Passwort oder den Initialwert
	zu &auml;ndern, w&auml;hrend Sie &uuml;ber eine gesicherte
	Verbindung, das hei&szlig;t an der Konsole oder &uuml;ber
	<application>SSH</application> angemeldet, sind:</para>

      <screen>&prompt.user; <userinput>keyinit</userinput>
Adding unfurl:
Reminder - Only use this method if you are directly connected.
If you are using telnet or rlogin exit with no password and use keyinit -s.
Enter secret password:
Again secret password:

ID unfurl s/key is 99 to17757
DEFY CLUB PRO NASH LACE SOFT</screen>

      <para>Mit OPIE benutzen Sie stattdessen
	<command>opiepasswd</command>:</para>

      <screen>&prompt.user; <userinput>opiepasswd -c</userinput>
[grimreaper] ~ $ opiepasswd -f -c
Adding unfurl:
Only use this method from the console; NEVER from remote. If you are using
telnet, xterm, or a dial-in, type ^C now or exit with no password.
Then run opiepasswd without the -c parameter.
Using MD5 to compute responses.
Enter new secret pass phrase:
Again new secret pass phrase:
ID unfurl OTP key is 499 to4268
MOS MALL GOAT ARM AVID COED
</screen>

      <para>Nach der Aufforderung <prompt>Enter new secret pass phrase:</prompt>
	oder <prompt>Enter secret password:</prompt> geben Sie bitte Ihr
	Passwort ein.  Dies ist nicht das Passwort, mit dem Sie sich
	anmelden, sondern es wird genutzt, um das Einmalpasswort
	zu generieren.  Die Zeile, die mit <quote>ID</quote> anf&auml;ngt,
	enth&auml;lt Ihren Login-Namen, den Iterationsz&auml;hler und den
	Initialwert.  Diese Werte m&uuml;ssen Sie sich nicht behalten, da
	das System sie zeigen wird, wenn Sie sich anmelden.  In der letzten
	Zeile steht das Einmalpasswort, das aus diesen Parametern
	und Ihrem geheimen Passwort ermittelt wurde.  Wenn sie sich jetzt
	wieder anmelden wollten, dann m&uuml;ssten Sie dieses
	Passwort benutzen.</para>
    </sect2>

    <sect2>
      <title>Einrichten &uuml;ber eine nicht gesicherte Verbindung</title>

      <para>Um Einmalpassw&ouml;rter &uuml;ber eine nicht gesicherte
	Verbindung einzurichten, oder das geheime Passwort zu &auml;ndern,
        m&uuml;ssen Sie &uuml;ber eine gesicherte Verbindung zu einer Stelle
	verf&uuml;gen, an der Sie die Kommandos <command>key</command>
	oder <command>opiekey</command> ausf&uuml;hren.  Dies kann
	ein <quote>Desk Accessory</quote> auf einem &macintosh; oder
	die Eingabeaufforderung auf einer Maschine, der Sie vertrauen, sein.
	Zudem m&uuml;ssen Sie einen Iterationsz&auml;hler vorgeben (100
	ist ein guter Wert) und einen Initialwert w&auml;hlen, wobei
	Sie auch einen zuf&auml;llig generierten benutzen k&ouml;nnen.
	Benutzen Sie <command>keyinit -s</command> &uuml;ber die ungesicherte
	Verbindung zu der Maschine, die Sie einrichten wollen:</para>

      <screen>&prompt.user; <userinput>keyinit -s</userinput>
Updating unfurl:
Old key: to17758
Reminder you need the 6 English words from the key command.
Enter sequence count from 1 to 9999: <userinput>100</userinput>
Enter new key [default to17759]:
s/key 100 to 17759
s/key access password:
s/key access password:<userinput>CURE MIKE BANE HIM RACY GORE</userinput>
</screen>

      <para>Mit OPIE benutzen Sie <command>opiepasswd</command>:</para>

      <screen>&prompt.user; <userinput>opiepasswd</userinput>

Updating unfurl:
You need the response from an OTP generator.
Old secret pass phrase:
        otp-md5 498 to4268 ext
        Response: GAME GAG WELT OUT DOWN CHAT
New secret pass phrase:
        otp-md5 499 to4269
        Response: LINE PAP MILK NELL BUOY TROY

ID mark OTP key is 499 gr4269
LINE PAP MILK NELL BUOY TROY
</screen>

      <para>Dr&uuml;cken Sie <keycap>Return</keycap>, um die Vorgabe
	f&uuml;r den Initialwert, der von <command>keyinit</command>
	<literal>key</literal> genannt wird, zu akzeptieren.  Bevor
	Sie nun das Zugriffspasswort
	(engl. <foreignphrase>access password</foreignphrase>)
	eingeben, rufen Sie &uuml;ber die gesicherte Verbindung
	<command>key</command> mit denselben Parametern auf:</para>

      <screen>&prompt.user; <userinput>key 100 to17759</userinput>
Reminder - Do not use this program while logged in via telnet or rlogin.
Enter secret password: <userinput>&lt;secret password&gt;</userinput>
CURE MIKE BANE HIM RACY GORE</screen>

      <para>Mit OPIE benutzen Sie <command>opiekey</command>:</para>

      <screen>&prompt.user; <userinput>opiekey 498 to4268</userinput>
Using the MD5 algorithm to compute response.
Reminder: Don't use opiekey from telnet or dial-in sessions.
Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT
</screen>

      <para>Gehen Sie nun zur&uuml;ck zu der nicht gesicherten Verbindung
	und geben dort das eben generierte Einmalpasswort ein.</para>
    </sect2>

    <sect2>
      <title>Erzeugen eines einzelnen Einmalpasswortes</title>

      <para>Nachdem Sie S/Key oder OPIE eingerichtet haben, werden Sie beim
	n&auml;chsten Anmelden wie folgt begr&uuml;&szlig;t:</para>

<screen>&prompt.user; <userinput>telnet example.com</userinput>
Trying 10.0.0.1...
Connected to example.com
Escape character is '^]'.

FreeBSD/i386 (example.com) (ttypa)

login: <userinput>&lt;username&gt;</userinput>
s/key 97 fw13894
Password: </screen>

      <para>OPIE begr&uuml;&szlig;t Sie wie folgt:</para>

<screen>&prompt.user; <userinput>telnet example.com</userinput>
Trying 10.0.0.1...
Connected to example.com
Escape character is '^]'.

FreeBSD/i386 (example.com) (ttypa)

login: <userinput>&lt;username&gt;</userinput>
otp-md5 498 gr4269 ext
Password: </screen>

      <para>Anmerkung: S/Key und OPIE besitzen eine n&uuml;tzliche Eigenschaft,
	die hier nicht gezeigt ist.  Wenn Sie an der Eingabeaufforderung
	<keycap>Return</keycap> eingeben, wird die echo-Funktion eingeschaltet,
	das hei&szlig;t Sie sehen, was Sie tippen.  Dies ist besonders
	n&uuml;tzlich, wenn Sie ein generiertes Passwort von einem
	Ausdruck abtippen m&uuml;ssen.</para>

      <indexterm><primary>MS-DOS</primary></indexterm>
      <indexterm><primary>Windows</primary></indexterm>
      <indexterm><primary>MacOS</primary></indexterm>

      <para>Jetzt m&uuml;ssen Sie Ihr Einmalpasswort generieren,
	um der Anmeldeaufforderung nachzukommen.  Dies muss auf
	einem gesicherten System geschehen, auf dem Sie <command>key</command>
	oder <command>opiekey</command> ausf&uuml;hren k&ouml;nnen.
	Diese Programme gibt es &uuml;brigens auch f&uuml;r DOS, &windows; und
	&macos;.  Beide Programme ben&ouml;tigen den Iterationsz&auml;hler
	sowie den Initialwert als Parameter, die Sie mittels
	<quote>cut-and-paste</quote> direkt von der Login Aufforderung
	nehmen k&ouml;nnen.</para>

      <para>Auf dem sicheren System:</para>

      <screen>&prompt.user; <userinput>key 97 fw13894</userinput>
Reminder - Do not use this program while logged in via telnet or rlogin.
Enter secret password:
WELD LIP ACTS ENDS ME HAAG</screen>

      <para>Mit OPIE:</para>

      <screen>&prompt.user; <userinput>opiekey 498 to4268</userinput>
Using the MD5 algorithm to compute response.
Reminder: Don't use opiekey from telnet or dial-in sessions.
Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT</screen>

      <para>Mit dem jetzt generierten Einmalpasswort k&ouml;nnen
	Sie die Anmeldeprozedur fortsetzen:</para>

      <screen>login: <userinput>&lt;username&gt;</userinput>
s/key 97 fw13894
Password: <userinput>&lt;return to enable echo&gt;</userinput>
s/key 97 fw13894
Password [echo on]: WELD LIP ACTS ENDS ME HAAG
Last login: Tue Mar 21 11:56:41 from 10.0.0.2 ...</screen>

    </sect2>

    <sect2>
      <title>Erzeugen von mehreren Einmalpassw&ouml;rtern</title>

      <para>Manchmal m&uuml;ssen Sie sich an Orte begeben, an denen
	Sie keinen Zugriff auf eine sichere Maschine oder eine
	sichere Verbindung haben.  In diesem Fall k&ouml;nnen Sie
	vorher mit <command>key</command> oder <command>opiekey</command>
	einige Einmalpassw&ouml;rter generieren, die Sie sich
	ausdrucken und mitnehmen k&ouml;nnen.  Zum Beispiel:</para>

      <screen>&prompt.user; <userinput>key -n 5 30 zz99999</userinput>
Reminder - Do not use this program while logged in via telnet or rlogin.
Enter secret password: <userinput>&lt;secret password&gt;</userinput>
26: SODA RUDE LEA LIND BUDD SILT
27: JILT SPY DUTY GLOW COWL ROT
28: THEM OW COLA RUNT BONG SCOT
29: COT MASH BARR BRIM NAN FLAG
30: CAN KNEE CAST NAME FOLK BILK</screen>

      <para>Mit OPIE:</para>

      <screen>&prompt.user; <userinput>opiekey -n 5 30 zz99999</userinput>
Using the MD5 algorithm to compute response.
Reminder: Don't use opiekey from telnet or dial-in sessions.
Enter secret pass phrase: <userinput>&lt;secret password&gt;</userinput>
26: JOAN BORE FOSS DES NAY QUIT
27: LATE BIAS SLAY FOLK MUCH TRIG
28: SALT TIN ANTI LOON NEAL USE
29: RIO ODIN GO BYE FURY TIC
30: GREW JIVE SAN GIRD BOIL PHI</screen>

      <para>Mit <option>-n 5</option> fordern Sie f&uuml;nf
	Passw&ouml;rter der Reihe nach an.  Der letzte
	Iterationsz&auml;hler wird durch <option>30</option> gegeben.
	Beachten Sie bitte, dass die Passw&ouml;rter in der
	<emphasis>umgekehrten</emphasis> Reihenfolge, in der sie
	zu benutzen sind, ausgeben werden.  Wenn Sie wirklich paranoid
	sind, schreiben Sie sich jetzt die Passw&ouml;rter auf,
	ansonsten drucken Sie sie mit <command>lpr</command> aus.
	Beachten Sie, dass jede Zeile den Iterationsz&auml;hler
	und das Einmalpasswort zeigt, trotzdem finden Sie es
	vielleicht hilfreich, eine Zeile nach Gebrauch durchzustreichen.</para>
    </sect2>

    <sect2>
      <title>Einschr&auml;nken der Benutzung von
	System-Passw&ouml;rtern</title>

      <para>Mit S/Key k&ouml;nnen Sie die Verwendung von
	System-Passw&ouml;rtern, basierend auf dem Hostnamen,
	Benutzernamen, Terminal oder IP-Adresse, einschr&auml;nken.
	Die Beschr&auml;nkungen werden in
	<filename>/etc/skey.access</filename> definiert.  Die
	Manualpage &man.skey.access.5; beschreibt das Format dieser
	Datei sowie einige Vorsichtsma&szlig;nahmen, die Sie treffen
	sollten, bevor Sie diese Datei einsetzen.</para>

      <para>Wenn <filename>/etc/skey.access</filename> nicht existiert
	(wie auf &os;&nbsp;4.X Systemen), dann d&uuml;rfen sich
	alle Benutzer mit ihren System-Passw&ouml;rtern anmelden.
	Wenn die Datei existiert, dann m&uuml;ssen alle Benutzer
	S/Key zum Anmelden benutzen.  Ausnahmen m&uuml;ssen explizit
	in <filename>skey.access</filename> konfiguriert werden.
	In allen F&auml;llen werden System-Passw&ouml;rter
	beim Anmelden auf der Konsole erlaubt.</para>

      <para>Das folgende Beispiel f&uuml;r <filename>skey.access</filename>
	zeigt die drei gel&auml;ufigsten Konfigurationsoptionen:</para>

      <para>Das folgende Beispiel zeigt die drei h&auml;ufigsten
	Ausnahmen:</para>

      <programlisting>permit internet 192.168.0.0 255.255.0.0
permit user fnord
permit port ttyd0</programlisting>

      <para>Die erste Zeile (<literal>permit internet</literal>) erlaubt
	es Benutzern, deren IP-Adresse, die immer noch gef&auml;lscht werden
	kann, mit dem angegebenen Wert und der angegebenen Maske
	&uuml;bereinstimmt, System-Passw&ouml;rter zu benutzen.  Dies
	sollte nicht als Sicherheitsmechanismus missverstanden werden,
	sondern sollte autorisierte Benutzer daran erinnern, dass sie
	ein ungesichertes Netzwerk benutzen und sich mit S/Key anmelden
	m&uuml;ssen.</para>

      <para>Die zweite Zeile (<literal>permit user</literal>) erlaubt
	es dem angegebenen Benutzer, hier <username>fnord</username>,
	jederzeit System-Passw&ouml;rter zu verwenden.  Dies sollte
	allerdings nur f&uuml;r Benutzer konfiguriert werden, die das
	<command>key</command> Programm nicht benutzen k&ouml;nnen (Leute
	mit <quote>dumb</quote> Terminals oder wirklich uneinsichtige).</para>

      <para>Die dritte Zeile (<literal>permit port</literal>) erlaubt allen
	Benutzern, die sich an dem angegebenen Terminal anmelden,
	System-Passw&ouml;rter zu benutzen.  Sie sollte f&uuml;r
	Einw&auml;hlverbindungen genutzt werden.</para>

      <para>Wie S/Key kann OPIE die Verwendung von System-Passw&ouml;rtern
	abh&auml;ngig von der Quell-IP-Adresse einschr&auml;nken.
	Die dazu n&ouml;tigen Einstellungen werden in der Datei
	<filename>/etc/opieaccess</filename> vorgenommen, die
	auf Systemen ab &os;&nbsp;5.0 vorhanden ist.  Weitere
	Informationen &uuml;ber diese Datei und Sicherheitshinweise
	zu ihrer Verwendung entnehmen Sie bitte der Hilfeseite
	&man.opieaccess.5;.</para>

      <para>Die Datei <filename>opieaccess</filename> k&ouml;nnte
	beispielsweise die folgende Zeile enthalten:</para>

      <programlisting>permit 192.168.0.0 255.255.0.0</programlisting>

      <para>Diese Zeile erlaubt es Benutzern, die sich von einer der
	angegebenen Quell-IP-Adressen anmelden, ihr System-Passwort
	zu verwenden.  Beachten Sie bitte, dass eine Quell-IP-Adresse
	leicht gef&auml;lscht werden kann.</para>

      <para>Findet sich in <filename>opieaccess</filename> kein
	passender Eintrag, muss die Anmeldung mit OPIE erfolgen.</para>
    </sect2>
  </sect1>

  <sect1 id="tcpwrappers">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <indexterm>
      <primary>TCP-Wrapper</primary>
    </indexterm>

    <title>TCP-Wrapper</title>

    <para>Wahrscheinlich hat jeder, der &man.inetd.8; kennt,
      schon mal von den TCP-Wrappern geh&ouml;rt.  Die
      wenigsten erkennen den vollen Nutzen der TCP-Wrapper
      in einer Netzumgebung.  Es scheint, dass die meisten
      Leute Netzverbindungen mit einer Firewall absichern
      wollen.  Auch wenn eine Firewall ein m&auml;chtiges
      Instrument ist, gibt es Sachen, die eine Firewall
      nicht kann.  Eine Firewall kann beispielsweise keine
      Nachricht an den Verbindungsursprung senden.  Genau
      das und mehr k&ouml;nnen aber die
      <acronym>TCP</acronym>-Wrapper.  Im Folgenden werden
      die Funktionen der <acronym>TCP</acronym>-Wrapper
      und Beispiele f&uuml;r deren Konfiguration vorgestellt.</para>

    <para>Die <acronym>TCP</acronym>-Wrapper erweitern die
      Steuerungsm&ouml;glichkeiten, die <command>inetd</command>
      &uuml;ber die Dienste unter seiner Kontrolle hat.
      Beispielsweise k&ouml;nnen Verbindungen protokolliert,
      Nachrichten zur&uuml;ckgesandt oder nur interne Verbindungen
      angenommen werden.  Die <acronym>TCP</acronym>-Wrapper
      bieten nicht nur eine weitere Sicherheitsschicht, die
      teilweise auch von Firewalls geboten wird, sie bieten
      dar&uuml;ber hinaus Funktionen zur Steuerung von
      Verbindungen, die eine Firewall nicht bietet.</para>

    <para>Die erweiterten Funktionen der
      <acronym>TCP</acronym>-Wrapper sind kein Firewall-Ersatz.
      Sie sollten zusammen mit einer Firewall und anderen
      Sicherheitsvorkehrungen eingesetzt werden.  Die
      <acronym>TCP</acronym>-Wrapper sind eine weitere
      Sicherheitsschicht zum Schutz eines Systems.</para>

    <para>Da die Wrapper die Funktion von <command>inetd</command>
      erweitern, wird im Folgenden vorausgesetzt, dass Sie den
      Abschnitt &uuml;ber die
      <link linkend="network-inetd">inetd-Konfiguration</link>
      schon gelesen haben.</para>

    <note>
      <para>Streng genommen handelt es sich bei den von &man.inetd.8;
        gestarteten Programmen nicht um <quote>Daemonen</quote>.  Da
        sich diese Bezeichnung aber eingeb&uuml;rgert hat, wird sie auch
        in diesem Abschnitt verwendet.</para>
    </note>

    <sect2>
      <title>TCP-Wrapper einrichten</title>

      <para>Um die <acronym>TCP</acronym>-Wrapper unter &os;
	zu benutzen, muss nur der <command>inetd</command>
	aus <filename>rc.conf</filename> mit den voreingestellten
	Optionen <option>-Ww</option> gestartet werden.
	Die Konfigurationsdatei <filename>/etc/hosts.allow</filename>
	darf keine Fehler enthalten; falls doch, werden die
	Fehler mit &man.syslogd.8; protokolliert.</para>

      <note>
	<para>Im Gegensatz zu anderen Implementationen der
	  <acronym>TCP</acronym>-Wrapper wird vom Gebrauch
	  der Datei <filename>hosts.deny</filename> abgeraten.
	  Die Konfiguration sollte sich vollst&auml;ndig in der
	  Datei <filename>/etc/hosts.allow</filename> befinden.</para>
      </note>

      <para>In der einfachsten Konfiguration werden Dienste
	abh&auml;ngig vom Inhalt der Datei
	<filename>/etc/hosts.allow</filename> erlaubt oder
	gesperrt.  Unter &os; wird in der Voreinstellung
	jeder von <command>inetd</command> gestartete Dienst
	erlaubt.  Sehen wir uns zun&auml;chst die Grundkonfiguration
	an.</para>

      <para>Eine Konfigurationszeile ist wie folgt aufgebaut:
	<literal>Dienst : Adresse : Aktion</literal>.
	<literal>Dienst</literal> ist der von <command>inetd</command>
	gestartete Dienst (auch Daemon genannt).  Die
	<literal>Adresse</literal> kann ein g&uuml;ltiger
	Rechnername, eine <acronym>IP</acronym>-Adresse oder
	eine IPv6-Adresse in Klammern
	(<literal>[</literal>&nbsp;<literal>]</literal>) sein.
	Der Wert <literal>allow</literal> im Feld
	<literal>Aktion</literal> erlaubt Zugriffe, der Wert
	<literal>deny</literal> verbietet Zugriffe.
	Die Zeilen in <filename>hosts.allow</filename>
	werden f&uuml;r jede Verbindung der Reihe nach
	abgearbeitet.  Trifft eine Zeile auf eine Verbindung
	zu, wird die entsprechende Aktion ausgef&uuml;hrt
	und die Abarbeitung ist beendet.</para>

      <para>Es gibt noch weitere Konfigurationsoptionen, die
	gleich erl&auml;utert werden.  Das bisher Gesagte
	reicht, um eine einfache Regel aufzustellen.  Wenn
	Sie einkommende <acronym>POP</acronym>3-Verbindungen
	f&uuml;r den Dienst
	<filename role="package">mail/qpopper</filename>
	erlauben wollen, erweitern Sie
	<filename>hosts.allow</filename> um die nachstehende
	Zeile:</para>

      <programlisting># This line is required for POP3 connections:
qpopper : ALL : allow</programlisting>

      <para>Nachdem Sie die Zeile hinzugef&uuml;gt haben, muss der
	<command>inetd</command> neu gestartet werden.  Sie
	k&ouml;nnen dazu das Kommando &man.kill.1; verwenden
	oder <command>/etc/rc.d/inetd restart</command>
	ausf&uuml;hren.</para>
    </sect2>

    <sect2>
      <title>Erweiterte Konfiguration der TCP-Wrapper</title>

      <para>Die <acronym>TCP</acronym>-Wrapper besitzen
	weitere Optionen, die bestimmen, wie Verbindungen
	behandelt werden.  In einigen F&auml;llen ist es
	gut, wenn bestimmten Rechnern oder Diensten eine
	Nachricht geschickt wird.  In anderen F&auml;llen
	soll vielleicht der Verbindungsaufbau protokolliert
	oder eine E-Mail an einen Administrator versandt
	werden.  Oder ein Dienst soll nur f&uuml;r das
	lokale Netz bereitstehen.  Dies alles ist mit so genannten
	Wildcards, Metazeichen und der Ausf&uuml;hrung externer
	Programme m&ouml;glich und wird in den n&auml;chsten
	zwei Abschnitten erl&auml;utert.</para>

      <sect3>
	<title>Externe Kommandos ausf&uuml;hren</title>

	<para>Stellen Sie sich vor, eine Verbindung soll
	  verhindert werden und gleichzeitig soll demjenigen,
	  der die Verbindung aufgebaut hat, eine Nachricht
	  geschickt werden.  Auf welche Art m&uuml;ssen
	  die <acronym>TCP</acronym>-Wrapper konfiguriert werden?
	  Die Option <option>twist</option> f&uuml;hrt beim
	  Verbindungsaufbau ein Kommando aus.  In der Datei
	  <filename>hosts.allow</filename> ist ein Beispiel
	  f&uuml;r diese Option enthalten:</para>

	<programlisting># Alle anderen Dienste sind gesch&uuml;tzt
ALL : ALL \
        : severity auth.info \
        : twist /bin/echo "You are not welcome to use %d from %h."</programlisting>

	<para>F&uuml;r jeden Dienst, der nicht vorher in
	  der Datei <filename>hosts.allow</filename> konfiguriert
	  wurde, wird die Meldung <quote>You are not allowed to use
	  <literal>daemon</literal> from
	  <literal>hostname</literal>.</quote> zur&uuml;ckgegegeben.
	  Dies ist besonders n&uuml;tzlich, wenn Sie die
	  Gegenstelle sofort benachrichtigen wollen, nachdem
	  die Verbindung getrennt wurde.  Beachten Sie, dass
	  der Text der Meldung in Anf&uuml;hrungszeichen
	  (<literal>"</literal>) stehen <emphasis>muss</emphasis>,
	  es gibt keine Ausnahmen zu dieser Regel.</para>

	<warning>
	  <para>Ein so konfigurierter Server ist anf&auml;llig
	    f&uuml;r Denial-of-Service-Angriffe.  Ein Angreifer
	    kann die gesperrten Dienste mit Verbindungsanfragen
	    &uuml;berfluten.</para>
	</warning>

	<para>Um einem Denial-of-Service-Angriff zu entgehen,
	  benutzen Sie die Option <option>spawn</option>.
	  Wie die Option <option>twist</option> verbietet
	  <option>spawn</option> die Verbindung und f&uuml;hrt
	  externe Kommandos aus.  Allerdings sendet die
	  Option <option>spawn</option> der Gegenstelle
	  keine R&uuml;ckmeldung.  Sehen Sie sich die
	  nachstehende Konfigurationsdatei an:</para>

	<programlisting># Verbindungen von example.com sind gesperrt:
ALL : .example.com \
	: spawn (/bin/echo %a from %h attempted to access %d &gt;&gt; \
	  /var/log/connections.log) \
	: deny</programlisting>

	<para>Damit sind Verbindungen von der Domain
	  <hostid role="fqdn">*.example.com</hostid> gesperrt.
	  Jeder Verbindungsaufbau wird zudem in der Datei
	  <filename>/var/log/connections.log</filename>
	  protokolliert.  Das Protokoll enth&auml;lt den
	  Rechnernamen, die <acronym>IP</acronym>-Adresse
	  und den Dienst, der angesprochen wurde.</para>

	<para>In der Konfigurationsdatei wurde beispielsweise
	  das Metazeichen %a verwendet.  Es gibt weitere
	  Metazeichen, die in der Hilfeseite &man.hosts.access.5;
	  beschrieben werden.</para>
      </sect3>

      <sect3>
	<title>Wildcards</title>

	<para>Bisher verwendeten die Beispiele immer die
	  Wildcard <literal>ALL</literal>.  Die Wildcard
	  <literal>ALL</literal> passt beispielsweise auf
	  jeden Dienst, jede Domain oder jede
	  <acronym>IP</acronym>-Adresse.  Eine andere
	  Wildcard ist <literal>PARANOID</literal>.  Sie passt
	  auf jeden Rechner dessen <acronym>IP</acronym>-Adresse
	  m&ouml;glicherweise gef&auml;lscht ist.  Dies ist dann
	  der Fall, wenn der Verbindungsaufbau von einer
	  <acronym>IP</acronym>-Adresse erfolgt, die nicht
	  zu dem &uuml;bermittelten Rechnernamen passt.
	  F&uuml;r solche F&auml;lle werden mit der
	  Wildcard <literal>PARANOID</literal> Aktionen
	  festgelegt, beispielsweise:</para>

	<programlisting># Block possibly spoofed requests to sendmail:
sendmail : PARANOID : deny</programlisting>

	<para>In diesem Beispiel werden alle Verbindungen zu
	  <command>sendmail</command> verboten, die von einer
	  <acronym>IP</acronym>-Adresse ausgehen, die nicht zum
	  Rechnernamen passt.</para>

	<caution>
	  <para>Die Wildcard <literal>PARANOID</literal>
	    kann einen Dienst unbrauchbar machen, wenn der
	    Client oder der Server eine fehlerhafte
	    <acronym>DNS</acronym>-Konfiguration besitzt.
	    Setzen Sie die Wildcard bitte umsichtig ein.</para>
	</caution>

	<para>Weiteres &uuml;ber Wildcards und deren Funktion
	  lesen Sie bitte in der Hilfeseite &man.hosts.access.5;
	  nach.</para>

	<para>In der Voreinstellung sind alle Dienste erlaubt.
	  Damit die gezeigten Beispiele funktionieren, m&uuml;ssen
	  Sie die erste Konfigurationszeile in der Datei
	  <filename>hosts.allow</filename> auskommentieren.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="kerberosIV">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Mark</firstname>
	  <surname>Murray</surname>
	  <contrib>Beigesteuert von </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <firstname>Mark</firstname>
	  <surname>Dapoz</surname>
	  <contrib>Basiert auf einem Beitrag von </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title><application>KerberosIV</application></title>
    <indexterm><primary>KerberosIV</primary></indexterm>

    <para>Kerberos ist ein zus&auml;tzliches Netzwerkprotokoll, das es
      Benutzern erlaubt, sich &uuml;ber einen sicheren Server zu
      authentifizieren.  Dienste wie <application>rlogin</application>,
      <application>rcp</application> oder das sichere Kopieren von Dateien
      zwischen Systemen und andere risikoreiche T&auml;tigkeiten werden
      durch Kerberos erheblich sicherer und kontrollierbarer.</para>

    <para>Die folgende Anleitung kann nur als Wegweiser dazu dienen, wie
      Sie Kerberos f&uuml;r &os; konfigurieren.  Eine komplette
      Beschreibung des Systems finden Sie in den entsprechenden
      Hilfeseiten.</para>

    <sect2>
      <title>Installation von <application>KerberosIV</application></title>

      <indexterm><primary>MIT</primary></indexterm>
      <indexterm>
	<primary>KerberosIV</primary>
	<secondary>installieren</secondary>
      </indexterm>
      <para>Kerberos ist eine optionale Komponente von &os;.  Am
	leichtesten installieren Sie die Software, wenn Sie bei
	der ersten Installation von &os; in
	<application>sysinstall</application> die Distribution
	<literal>krb4</literal> oder <literal>krb5</literal>
	ausw&auml;hlen.  Damit installieren Sie entweder die
	<quote>eBones</quote> (KerberosIV) oder <quote>Heimdal</quote>
	(Kerberos5) Version von Kerberos.  Beide Versionen werden
	mit &os; ausgeliefert, da sie au&szlig;erhalb von den
	USA oder Kanada entwickelt werden.
	Sie unterliegen deshalb auch nicht den restriktiven
	Exportbeschr&auml;nkungen der USA und sind auch f&uuml;r
	Bewohner anderer L&auml;nder zug&auml;nglich.</para>

      <para>Als Alternative steht die MIT Variante von Kerberos in der
	Ports-Kollektion unter <filename role="package">security/krb5</filename> zur
	Verf&uuml;gung.</para>
    </sect2>

    <sect2>
      <title>Erstellen der initialen Datenbank</title>

      <para>Die folgenden Schritte werden nur auf dem Kerberos-Server
	durchgef&uuml;hrt.  Stellen Sie bitte vorher sicher, dass
	keine alten Kerberos-Datenbanken mehr vorhanden sind.  Im
	Verzeichnis <filename>/etc/kerberosIV</filename> sollten sich nur
	die folgenden Dateien befinden:</para>

      <screen>&prompt.root; <userinput>cd /etc/kerberosIV</userinput>
&prompt.root; <userinput>ls</userinput>
README		krb.conf        krb.realms</screen>

      <para>Wenn noch andere Dateien, wie <filename>principal.*</filename>
	oder <filename>master_key</filename>, existieren, m&uuml;ssen
	Sie die alte Kerberos-Datenbank mit <command>kdb_destroy</command>
	l&ouml;schen.  Wenn Kerberos nicht l&auml;uft, k&ouml;nnen Sie
	die Dateien auch einfach l&ouml;schen.</para>

      <para>Sie sollten nun die Dateien <filename>krb.conf</filename> und
	<filename>krb.realms</filename> editieren, um Ihr Kerberos-Realm zu
	definieren.  Das folgende Beispiel zeigt dies f&uuml;r das Realm
	<literal>EXAMPLE.COM</literal> auf dem Server
	<hostid role="fqdn">grunt.example.com</hostid>.
	<filename>krb.conf</filename> sollte wie folgt aussehen:</para>

      <screen>&prompt.root; <userinput>cat krb.conf</userinput>
EXAMPLE.COM
EXAMPLE.COM grunt.example.com admin server
CS.BERKELEY.EDU okeeffe.berkeley.edu
ATHENA.MIT.EDU kerberos.mit.edu
ATHENA.MIT.EDU kerberos-1.mit.edu
ATHENA.MIT.EDU kerberos-2.mit.edu
ATHENA.MIT.EDU kerberos-3.mit.edu
LCS.MIT.EDU kerberos.lcs.mit.edu
TELECOM.MIT.EDU bitsy.mit.edu
ARC.NASA.GOV trident.arc.nasa.gov</screen>

      <para>Die zus&auml;tzlich aufgef&uuml;hrten Realms brauchen Sie nicht
	anzulegen.  Sie zeigen hier nur, wie man Kerberos dazu bringt, andere
	Realms zu erkennen.  Sie k&ouml;nnen Sie also auch weglassen.</para>

      <para>Die erste Zeile benennt das Realm, in dem das System arbeitet.
	Die anderen Zeilen enthalten Realm/Host Paare.  Der erste Wert jeder
	Zeile ist das Realm, der zweite Teil ein Host, der in diesem
	Realm <quote>Key Distribution Center</quote> ist.  Die
	Schl&uuml;sselw&ouml;rter <literal>admin server</literal> nach einem
	Hostnamen bedeuten, dass dieser Host auch einen administrativen
	Datenbankserver zur Verf&uuml;gung stellt.  Weitere Erkl&auml;rungen zu
	diesen Begriffen finden Sie in den Kerberos Manualpages.</para>

      <para>Als n&auml;chstes muss
	<hostid role="fqdn">grunt.example.com</hostid> in das Realm
	<literal>EXAMPLE.COM</literal> aufgenommen werden.  Des Weiteren
	erstellen wir einen Eintrag, der alle Rechner der Dom&auml;ne
	<hostid role="domainname">.example.com</hostid> in das Realm
	<literal>EXAMPLE.COM</literal>  aufnimmt.
	<filename>krb.realms</filename> sollte danach so aussehen:</para>

      <screen>&prompt.root; <userinput>cat krb.realms</userinput>
grunt.example.com EXAMPLE.COM
.example.com EXAMPLE.COM
.berkeley.edu CS.BERKELEY.EDU
.MIT.EDU ATHENA.MIT.EDU
.mit.edu ATHENA.MIT.EDU</screen>

      <para>Die zus&auml;tzlichen Realms sind hier wieder als Beispiel
	gedacht.  Sie k&ouml;nnen sie der Einfachheit halber auch
	weglassen.</para>

      <para>Die erste Zeile nimmt ein <emphasis>einzelnes</emphasis> System
	in das Realm auf.  Die anderen Zeilen zeigen, wie bestimmte
	Subdom&auml;nen einem bestimmten Realm zugeordnet werden.</para>

      <para>Das folgende Kommando muss nur auf dem Kerberos-Server
	(oder <quote>Key Distribution Center</quote>) laufen.  Mit
	<command>kdb_init</command> k&ouml;nnen wir die Datenbank
	anlegen:</para>

      <screen>&prompt.root; <userinput>kdb_init</userinput>
<prompt>Realm name [default  ATHENA.MIT.EDU ]:</prompt> <userinput>EXAMPLE.COM</userinput>
You will be prompted for the database Master Password.
It is important that you NOT FORGET this password.

<prompt>Enter Kerberos master key:</prompt> </screen>

      <para>Anschlie&szlig;end muss der Schl&uuml;ssel gespeichert
	werden, damit Server auf der lokalen Maschine darauf zugreifen
	k&ouml;nnen.  Dies geschieht mit <command>kstash</command>:</para>

      <screen>&prompt.root; <userinput>kstash</userinput>

<prompt>Enter Kerberos master key:</prompt>

Current Kerberos master key version is 1.

Master key entered. BEWARE!</screen>

      <para>Das verschl&uuml;sselte Master-Passwort wurde in
	<filename>/etc/kerberosIV/master_key</filename> gesichert.</para>
    </sect2>

    <sect2>
      <title>Anlegen von Prinzipals</title>

      <para>F&uuml;r <emphasis>jedes</emphasis> System, das mit Kerberos
	gesichert werden soll, m&uuml;ssen zwei Prinzipale in die
	Datenbank eingetragen werden.  Ihre Namen sind
	<literal>kpasswd</literal> und <literal>rcmd</literal>.  Beide
	Prinzipale m&uuml;ssen f&uuml;r jedes System angelegt werden, wobei
	die Instanz der Name des jeweiligen Systems ist.</para>

      <para>Die D&aelig;monen <application>kpasswd</application> und
	<application>rcmd</application> erlauben es anderen Systemen,
	Kerberos-Passw&ouml;rter zu &auml;ndern und Kommandos wie
	&man.rcp.1;, &man.rlogin.1; und &man.rsh.1;
	laufen zu lassen.</para>

      <para>Beide Eintr&auml;ge werden im Folgenden angelegt:</para>

      <screen>&prompt.root; <userinput>kdb_edit</userinput>
Opening database...

<prompt>Enter Kerberos master key:</prompt>

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Previous or default values are in [brackets] ,
enter return to leave the same, or new value.

<prompt>Principal name:</prompt> <userinput>passwd</userinput>
<prompt>Instance:</prompt> <userinput>grunt</userinput>

&lt;Not found&gt;, <prompt>Create [y] ?</prompt> <userinput>y</userinput>

Principal: passwd, Instance: grunt, kdc_key_ver: 1
<prompt>New Password:</prompt>                    &lt;---- geben Sie hier Zufallswerte ein
Verifying password

<prompt>New Password:</prompt> &lt;---- geben Sie hier Zufallswerte ein

<prompt>Random password [y] ?</prompt> <userinput>y</userinput>

Principal's new key version = 1
<prompt>Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ?</prompt>
<prompt>Max ticket lifetime (*5 minutes) [ 255 ] ?</prompt>
<prompt>Attributes [ 0 ] ?</prompt>
Edit O.K.
<prompt>Principal name:</prompt> <userinput>rcmd</userinput>
<prompt>Instance:</prompt> <userinput>grunt</userinput>

&lt;Not found&gt;, <prompt>Create [y] ?</prompt>

Principal: rcmd, Instance: grunt, kdc_key_ver: 1
<prompt>New Password:</prompt>		&lt;---- geben Sie hier Zufallswerte ein
Verifying password

<prompt>New Password:</prompt>           &lt;---- geben Sie hier Zufallswerte ein

<prompt>Random password [y] ?</prompt>

Principal's new key version = 1
<prompt>Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ?</prompt>
<prompt>Max ticket lifetime (*5 minutes) [ 255 ] ?</prompt>
<prompt>Attributes [ 0 ] ?</prompt>
Edit O.K.
<prompt>Principal name:</prompt>         &lt;---- geben Sie nichts an, um das Programm zu verlassen</screen>
    </sect2>

    <sect2>
      <title>Erstellen der Server-Datei</title>

      <para>Wir m&uuml;ssen nun f&uuml;r jede Maschine die Instanzen,
	die Dienste definieren, aus der Datenbank mit
	<command>ext_srvtab</command> extrahieren.  Die erstelle Datei
	muss auf einem <emphasis>sicheren Weg</emphasis> in das
	<filename>/etc/kerberosIV</filename> Verzeichnis jedes Clients
	kopiert werden.  Die Datei muss auf jedem Server und auf
	jedem Client vorhanden sein und ist unabdingbar f&uuml;r
	Kerberos.</para>

      <screen>&prompt.root; <userinput>ext_srvtab grunt</userinput>
<prompt>Enter Kerberos master key:</prompt>

Current Kerberos master key version is 1.

Master key entered. BEWARE!
Generating 'grunt-new-srvtab'....</screen>

      <para>Das Kommando erzeugt Dateien mit einem tempor&auml;ren Namen,
	der es anderen Servern erlaubt, ihre Datei abzuholen.  Die Datei
	muss auf dem entsprechenden System in <filename>srvtab</filename>
	umbenannt werden.  Auf dem originalen System k&ouml;nnen Sie
	&man.mv.1; benutzen, um die Datei umzubenennen:</para>

      <screen>&prompt.root; <userinput>mv grunt-new-srvtab srvtab</userinput></screen>

      <para>Wenn die Datei f&uuml;r ein Client-System bestimmt ist und das
	Netzwerk nicht sicher ist, kopieren Sie die Datei auf ein bewegliches
	Medium und transportieren sie physikalisch.  Kopieren Sie die Datei
	auf den Client in das Verzeichnis <filename>/etc/kerberosIV</filename>.
	Benennen Sie die Datei in <filename>srvtab</filename> um und setzen Sie
	schlie&szlig;lich noch die Berechtigungen auf 600:</para>

      <screen>&prompt.root; <userinput>mv grumble-new-srvtab srvtab</userinput>
&prompt.root; <userinput>chmod 600 srvtab</userinput></screen>
    </sect2>

    <sect2>
      <title>F&uuml;llen der Datenbank</title>

      <para>Wir k&ouml;nnen nun Benutzer in der Datenbank anlegen.  Mit
	<command>kdb_edit</command> legen wir zuerst die Benutzerin
	<username>jane</username> an:</para>

      <screen>&prompt.root; <userinput>kdb_edit</userinput>
Opening database...

<prompt>Enter Kerberos master key:</prompt>

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Previous or default values are in [brackets] ,
enter return to leave the same, or new value.

<prompt>Principal name:</prompt> <userinput>jane</userinput>
<prompt>Instance:</prompt>

&lt;Not found&gt;, <prompt>Create [y] ?</prompt> <userinput>y</userinput>

Principal: jane, Instance: , kdc_key_ver: 1
<prompt>New Password:</prompt>                &lt;---- geben Sie ein sicheres Passwort ein
Verifying password

<prompt>New Password:</prompt>                &lt;---- wiederholen Sie die Eingabe
Principal's new key version = 1
<prompt>Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ?</prompt>
<prompt>Max ticket lifetime (*5 minutes) [ 255 ] ?</prompt>
<prompt>Attributes [ 0 ] ?</prompt>
Edit O.K.
<prompt>Principal name:</prompt>		   &lt;---- geben Sie nichts an, um das Programm zu verlassen</screen>
    </sect2>

    <sect2>
      <title>Testen</title>

      <para>Zuerst m&uuml;ssen die Kerberos-D&aelig;monen gestartet sein.
	Wenn Sie <filename>/etc/rc.conf</filename> richtig angepasst haben,
	passiert das automatisch, wenn Sie booten.  Dieser Schritt ist nur
	auf dem Kerberos-Server notwendig, die Clients bekommen alles
	was sie brauchen aus dem <filename>/etc/kerberosIV</filename>
	Verzeichnis.</para>

      <screen>&prompt.root; <userinput>kerberos &amp;</userinput>
Kerberos server starting
Sleep forever on error
Log file is /var/log/kerberos.log
Current Kerberos master key version is 1.

Master key entered. BEWARE!

Current Kerberos master key version is 1
Local realm: EXAMPLE.COM
&prompt.root; <userinput>kadmind -n &amp;</userinput>
KADM Server KADM0.0A initializing
Please do not use 'kill -9' to kill this job, use a
regular kill instead

Current Kerberos master key version is 1.

Master key entered.  BEWARE!</screen>

      <para>Jetzt k&ouml;nnen wir mit <command>kinit</command> versuchen,
	ein Ticket f&uuml;r die ID <username>jane</username>, die wir
	oben angelegt haben, zu erhalten:</para>

      <screen>&prompt.user; <userinput>kinit jane</userinput>
MIT Project Athena (grunt.example.com)
Kerberos Initialization for "jane"
<prompt>Password:</prompt> </screen>

      <para>Mit <command>klist</command> k&ouml;nnen Sie sich vergewissern,
	dass Sie die Tickets auch erhalten haben:</para>

      <screen>&prompt.user; <userinput>klist</userinput>
Ticket file:    /tmp/tkt245
Principal:      jane@EXAMPLE.COM

  Issued           Expires          Principal
Apr 30 11:23:22  Apr 30 19:23:22  krbtgt.EXAMPLE.COM@EXAMPLE.COM</screen>

      <para>Versuchen Sie nun das Passwort mit &man.passwd.1;
	zu &auml;ndern, um zu &uuml;berpr&uuml;fen, dass der
	<application>kpasswd</application> D&aelig;mon auch auf der
	Kerberos-Datenbank autorisiert ist:</para>

      <screen>&prompt.user; <userinput>passwd</userinput>
realm EXAMPLE.COM
<prompt>Old password for jane:</prompt>
<prompt>New Password for jane:</prompt>
Verifying password
<prompt>New Password for jane:</prompt>
Password changed.</screen>
    </sect2>

    <sect2>
      <title>Anlegen von <command>su</command> Privilegien</title>

      <para>Mit Kerberos kann <emphasis>jedem</emphasis> Benutzer, der
	<username>root</username>-Privilegien braucht, ein
	<emphasis>eigenes</emphasis> Passwort f&uuml;r
	&man.su.1; zugewiesen werden.  Dies wird dadurch
	erreicht, dass die Instanz eines Prinzipals
	<username>root</username> ist.  Mit <command>kbd_edit</command>
	legen wir nun den Eintrag <literal>jane.root</literal> in der
	Kerberos-Datenbank an:</para>

      <screen>&prompt.root; <userinput>kdb_edit</userinput>
Opening database...

<prompt>Enter Kerberos master key:</prompt>

Current Kerberos master key version is 1.

Master key entered.  BEWARE!
Previous or default values are in [brackets] ,
enter return to leave the same, or new value.

<prompt>Principal name:</prompt> <userinput>jane</userinput>
<prompt>Instance:</prompt> <userinput>root</userinput>

&lt;Not found&gt;, Create [y] ? y

Principal: jane, Instance: root, kdc_key_ver: 1
<prompt>New Password:</prompt>                    &lt;---- geben Sie ein sicheres Passwort ein
Verifying password

<prompt>New Password:</prompt>    	 	 &lt;---- geben Sie das Passwort erneut ein

Principal's new key version = 1
<prompt>Expiration date (enter yyyy-mm-dd) [ 2000-01-01 ] ?</prompt>
<prompt>Max ticket lifetime (*5 minutes) [ 255 ] ?</prompt> <userinput>12</userinput> &lt;--- Keep this short!
<prompt>Attributes [ 0 ] ?</prompt>
Edit O.K.
<prompt>Principal name:</prompt>		         &lt;---- geben Sie nichts an, um das Programm zu verlassen</screen>

      <para>Versuchen Sie nun, f&uuml;r diesen Prinzipal Tickets zu
	bekommen:</para>

      <screen>&prompt.root; <userinput>kinit jane.root</userinput>
MIT Project Athena (grunt.example.com)
Kerberos Initialization for "jane.root"
<prompt>Password:</prompt></screen>

      <para>Als n&auml;chstes f&uuml;gen wir den Prinzipal in
	<filename>.klogin</filename> von <username>root</username> ein:</para>

      <screen>&prompt.root; <userinput>cat /root/.klogin</userinput>
jane.root@EXAMPLE.COM</screen>

      <para>Jetzt benutzen wir &man.su.1;:</para>

      <screen>&prompt.user; <userinput>su</userinput>
Password:</screen>

      <para>und kontrollieren, welche Tickets wir haben:</para>

      <screen>&prompt.root; <userinput>klist</userinput>
Ticket file:	/tmp/tkt_root_245
Principal:      jane.root@EXAMPLE.COM

  Issued           Expires          Principal
May  2 20:43:12  May  3 04:43:12  krbtgt.EXAMPLE.COM@EXAMPLE.COM</screen>
    </sect2>

    <sect2>
      <title>Weitere Kommandos</title>

      <para>In einem der Beispiele haben wir einen Prinzipal mit
	dem Namen <literal>jane</literal> und der Instanz
	<literal>root</literal> angelegt.  Der Prinzipal entstand aus
	einem Benutzer mit dem gleichen Namen.  Unter Kerberos ist es
	Standard, dass ein
	<replaceable>principal.instance</replaceable> der Form
	<replaceable>username.</replaceable><username>root</username> es dem
	Benutzer <replaceable>username</replaceable> erlaubt, mit
	&man.su.1; <username>root</username> zu werden, wenn die
	entsprechenden Eintr&auml;ge in <filename>.klogin</filename> von
	<username>root</username> existieren:</para>

      <screen>&prompt.root; <userinput>cat /root/.klogin</userinput>
jane.root@EXAMPLE.COM</screen>

      <para>Das gilt auch f&uuml;r die <filename>.klogin</filename>-Datei
	im Heimatverzeichnis eines Benutzers:</para>

      <screen>&prompt.user; <userinput>cat ~/.klogin</userinput>
jane@EXAMPLE.COM
jack@EXAMPLE.COM</screen>

      <para>Die Eintr&auml;ge erlauben jedem, der sich im Realm
	<literal>EXAMPLE.COM</literal> als <username>jane</username> oder
	<username>jack</username> mit <command>kinit</command> authentifiziert
	hat, mittels &man.rlogin.1;, &man.rsh.1; oder &man.rcp.1;
	auf den Account <username>jane</username> und dessen
	Dateien zuzugreifen.</para>

      <para>Im folgenden Beispiel meldet sich <username>jane</username>
	mit Kerberos auf <hostid>grunt</hostid> an:</para>

	    <screen>&prompt.user; <userinput>kinit</userinput>
MIT Project Athena (grunt.example.com)
<prompt>Password:</prompt>
&prompt.user; <userinput>rlogin grunt</userinput>
Last login: Mon May  1 21:14:47 from grumble
Copyright (c) 1980, 1983, 1986, 1988, 1990, 1991, 1993, 1994
        The Regents of the University of California.   All rights reserved.

FreeBSD BUILT-19950429 (GR386) #0: Sat Apr 29 17:50:09 SAT 1995</screen>

      <para>Im folgenden Beispiel wurde der Prinzipal <username>jack</username>
	mit einer Instanz <literal>null</literal> angelegt.  Mit der obigen
	<filename>.klogin</filename>-Datei kann er sich nun auf derselben
	Maschine als <username>jane</username> anmelden:</para>

      <screen>&prompt.user; <userinput>kinit</userinput>
&prompt.user; <userinput>rlogin grunt -l jane</userinput>
MIT Project Athena (grunt.example.com)
<prompt>Password:</prompt>
Last login: Mon May  1 21:16:55 from grumble
Copyright (c) 1980, 1983, 1986, 1988, 1990, 1991, 1993, 1994
        The Regents of the University of California.   All rights reserved.
FreeBSD BUILT-19950429 (GR386) #0: Sat Apr 29 17:50:09 SAT 1995</screen>
    </sect2>
  </sect1>

  <sect1 id="kerberos5">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tillman</firstname>
	  <surname>Hodgson</surname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <firstname>Mark</firstname>
	  <surname>Murray</surname>
	  <contrib>Beruht auf einem Beitrag von </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title><application>Kerberos5</application></title>

    <para>Das Basissystem enth&auml;lt ab &os;&nbsp;5.1
      nur noch <application>Kerberos5</application>.  Die
      Konfiguration von <application>Kerberos5</application>
      ist der Konfiguration von <application>KerberosIV</application>
      sehr &auml;hnlich.  Wenn Sie <application>KerberosIV</application>
      ben&ouml;tigen, installieren Sie den Port
      <filename role="package">security/krb4</filename>.
      Der folgende Abschnitt beschreibt ausschlie&szlig;lich
      <application>Kerberos5</application> f&uuml;r &os;-Releases
      ab 5.0.</para>

    <para><application>Kerberos</application> ist ein Netzwerk-Protokoll,
      das Benutzer mithilfe eines sicheren Servers authentifiziert.
      Mit Risiken behaftete Dienste, wie das Anmelden an entfernten
      Systemen oder das Kopieren von Daten auf entfernte Systeme,
      werden durch <application>Kerberos</application> erheblich
      sicherer und lassen sich leichter steuern.</para>

    <para><application>Kerberos</application> hat eine Aufgabe:
      Die sichere Pr&uuml;fung der Identit&auml;t eines Benutzers
      (Authentifizierung) &uuml;ber das Netzwerk.  Das System
      &uuml;berpr&uuml;ft weder die Berechtigungen der Benutzer
      (Autorisierung), noch verfolgt es die durchgef&uuml;hrten
      Aktionen (Audit).  Daher sollte <application>Kerberos</application>
      zusammen mit anderen Sicherheits-Systemen eingesetzt werden, die
      diese Funktionen bereitstellen.  Die Daten einer Kommunikation
      k&ouml;nnen verschl&uuml;sselt werden, nachdem die
      Kommunikationspartner mit <application>Kerberos</application>
      ihre Identit&auml;t gepr&uuml;ft haben.</para>

    <para>Die folgenden Anweisungen beschreiben, wie Sie das mit
      &os; gelieferte <application>Kerberos</application> einrichten.
      Eine vollst&auml;ndige Beschreibung des Systems entnehmen
      Sie bitte den entsprechenden Hilfeseiten.</para>

    <para>Die Beschreibung der
      <application>Kerberos</application>-Installation benutzt
      folgende Namensr&auml;ume:</para>

    <itemizedlist>
      <listitem>
	<para>Die <acronym>DNS</acronym>-Domain (Zone) hei&szlig;t
	  example.org.</para>
      </listitem>

      <listitem>
	<para>Das <application>Kerberos</application>-Realm
	  hei&szlig;t EXAMPLE.ORG.</para>
      </listitem>
    </itemizedlist>

    <note>
      <para>Benutzen Sie echte Domain-Namen, wenn Sie
	<application>Kerberos</application> einrichten.  Damit
	vermeiden Sie <acronym>DNS</acronym>-Probleme und stellen
	die Zusammenarbeit mit anderen
	<application>Kerberos</application>-Realms sicher.</para>
    </note>

    <sect2>
      <title>Geschichte</title>
      <indexterm>
	<primary>Kerberos5</primary>
	<secondary>Geschichte</secondary>
      </indexterm>

      <para>Das <acronym>MIT</acronym> entwickelte
        <application>Kerberos</application>, um Sicherheitsprobleme
	auf dem Netzwerk zu l&ouml;sen.  Das
	<application>Kerberos</application>-Protokoll verwendet
	starke Kryptographie, sodass ein Server die Identit&auml;t
	eines Clients (der umgekehrte Vorgang ist auch m&ouml;glich)
	&uuml;ber ein unsicheres Netzwerk feststellen kann.</para>

      <para>Der Begriff Kerberos wird sowohl f&uuml;r das Protokoll
	als auch f&uuml;r Programme verwendet, die
	<application>Kerberos</application> benutzen (wie
	<application>Kerberos</application>-Telnet).  Die aktuelle
	Protokollversion ist 5 und wird in
	<acronym>RFC</acronym>&nbsp;1510 beschrieben.</para>

      <para>Mehrere Implementierungen des Protokolls stehen frei
	zur Verf&uuml;gung und decken viele Betriebssysteme ab.
	Das Massachusetts Institute of Technology
	(<acronym>MIT</acronym>), an dem <application>Kerberos</application>
	urspr&uuml;nglich entwickelt wurde, entwickelt seine
	<application>Kerberos</application>-Version weiter.  In den
	<acronym>USA</acronym> wird diese Version h&auml;ufig
	eingesetzt, unterlag aber Export-Beschr&auml;nkungen,
	da sie in den <acronym>USA</acronym> entwickelt wurde.
	Die <acronym>MIT</acronym>-Version von
	<application>Kerberos</application> befindet sich im Port
	<filename role="package">security/krb5</filename>.
	Heimdal ist eine weitere Implementierung der Protokollversion 5.
	Sie wurde au&szlig;erhalb der <acronym>USA</acronym> entwickelt
	und unterliegt daher keinen Export-Beschr&auml;nkungen.
	Heimdal-<application>Kerberos</application> befindet sich
	im Port <filename role="package">security/heimdal</filename>
	und das Basissystem von &os; enth&auml;lt eine minimale
	Installation von Heimdal.</para>

      <para>Um m&ouml;glichst viele Benutzer anzusprechen, verwenden
	die folgenden Beispiele die in &os; enthaltene
	Heimdal-Distribution.</para>
    </sect2>

    <sect2>
      <title>Das Heimdal <acronym>KDC</acronym> einrichten</title>
      <indexterm>
	<primary>Kerberos5</primary>
	<secondary>Key Distribution Center</secondary>
      </indexterm>

      <para><application>Kerberos</application> authentifiziert
	Benutzer an einer zentralen Stelle: dem Key Distribution
	Center (<acronym>KDC</acronym>).  Das <acronym>KDC</acronym>
	verteilt <firstterm>Tickets</firstterm>, mit denen ein
	Dienst die Identit&auml;t eines Benutzers feststellen kann.
	Alle Mitglieder eines <application>Kerberos</application>-Realms
	vertrauen dem <acronym>KDC</acronym>, daher gelten f&uuml;r
	das <acronym>KDC</acronym> erh&ouml;hte
	Sicherheitsanforderungen.</para>

      <para>Obwohl das <acronym>KDC</acronym> wenig Ressourcen eines
	Rechners ben&ouml;tigt, sollte es wegen der
	Sicherheitsanforderungen auf einem separaten Rechner
	installiert werden.</para>

      <para>Das <acronym>KDC</acronym> wird in
        <filename>/etc/rc.conf</filename> wie folgt aktiviert:</para>

      <programlisting>kerberos5_server_enable="YES"
kadmind5_server_enable="YES"
kerberos_stash="YES"</programlisting>

      <note>
	<para>Die Option <option>kerberos_stash</option> gibt es
	  nur in &os;&nbsp;4.X.</para>
      </note>

      <para>Danach wird die Konfigurationsdatei von
        <application>Kerberos</application>,
	<filename>/etc/krb5.conf</filename>, erstellt:</para>

      <programlisting>[libdefaults]
    default_realm = EXAMPLE.ORG
[realms]
    EXAMPLE.ORG = {
        kdc = kerberos.example.org
	admin_server = kerberos.example.org
    }
[domain_realm]
    .example.org = EXAMPLE.ORG</programlisting>

      <para>Diese Einstellungen setzen voraus, dass der voll
	qualifizierte Name des <acronym>KDC</acronym>s
	<hostid role="fqdn">kerberos.example.org</hostid> ist.
	Wenn Ihr <acronym>KDC</acronym> einen anderen Namen hat,
	m&uuml;ssen Sie in der DNS-Zone einen Alias-Eintrag (CNAME-Record)
	f&uuml;r das <acronym>KDC</acronym> hinzuf&uuml;gen.</para>

      <note>
	<para>Auf gro&szlig;en Netzwerken mit einem ordentlich
	  konfigurierten <acronym>BIND</acronym>
	  <acronym>DNS</acronym>-Server kann die Datei verk&uuml;rzt
	  werden:</para>

        <programlisting>[libdefaults]
      default_realm = EXAMPLE.ORG</programlisting>

	<para>Die Zonendatei von <hostid role="fqdn">example.org</hostid>
	  muss dann die folgenden Zeilen enthalten:</para>

	<programlisting>_kerberos._udp      IN  SRV     01 00 88 kerberos.example.org.
_kerberos._tcp      IN  SRV     01 00 88 kerberos.example.org.
_kpasswd._udp       IN  SRV     01 00 464 kerberos.example.org.
_kerberos-adm._tcp  IN  SRV     01 00 749 kerberos.example.org.
_kerberos           IN  TXT     EXAMPLE.ORG</programlisting>
      </note>

      <note>
	<para>Damit Klienten die
	  <application>Kerberos</application>-Dienste benutzen
	  k&ouml;nnen, muss die Datei <filename>/etc/krb5.conf</filename>
	  entweder die vollst&auml;ndige Konfiguration enthalten
	  oder eine minimale Konfiguration enthalten
	  <emphasis>und</emphasis> zus&auml;tzlich ein DNS-Server
	  richtig eingerichtet sein.</para>
      </note>

      <para>Im n&auml;chsten Schritt wird die
        <application>Kerberos</application>-Datenbank eingerichtet.
	Die Datenbank enth&auml;lt die Schl&uuml;ssel aller Prinzipale
	und ist mit einem Passwort gesch&uuml;tzt.  Dieses Passwort
	brauchen Sie nicht zu behalten, da ein davon abgeleiteter
	Schl&uuml;ssel in der Datei <filename>/var/heimdal/m-key</filename>
	gespeichert wird.  Den Schl&uuml;ssel erstellen Sie, indem
	Sie das Programm <command>kstash</command> aufrufen und
	ein Passwort eingeben.</para>

      <para>Nachdem Sie den Schl&uuml;ssel in
        <filename>/var/heimdal/m-key</filename> erstellt haben,
	k&ouml;nnen Sie die Datenbank mit dem Kommando
	<command>kadmin</command> initialisieren.  Verwenden
	Sie hierbei die Option <option>-l</option> (lokal).  Mit
	dieser Option wird die Datenbank lokal modifiziert.  Normal
	w&uuml;rde der <command>kadmind</command>-Dienst benutzt,
	der aber zu diesem Zeitpunkt noch nicht l&auml;uft.  An
	der Eingabeaufforderung von <command>kadmin</command>
	k&ouml;nnen Sie mit dem Kommando <command>init</command>
	die Datenbank des Realms einrichten.</para>

      <para>Zuletzt erstellen Sie mit dem Kommando <command>add</command>
	Ihren ersten Prinzipal.  Benutzen Sie die voreingestellten
	Optionen;  Sie k&ouml;nnen die Einstellungen sp&auml;ter
	mit dem Kommando <command>modify</command> &auml;ndern.
	An der Eingabeaufforderung zeigt das Kommando
	<command>?</command> Hilfetexte an.</para>

      <para>Zusammengefasst wird die Datenbank wie folgt
	eingerichtet:</para>

      <screen>&prompt.root; <userinput>kstash</userinput>
Master key: <userinput>xxxxxxxx</userinput>
Verifying password - Master key: <userinput>xxxxxxxx</userinput>

&prompt.root; <userinput>kadmin -l</userinput>
kadmin> <userinput>init EXAMPLE.ORG</userinput>
Realm max ticket life [unlimited]:
kadmin> <userinput>add tillman</userinput>
Max ticket life [unlimited]:
Max renewable life [unlimited]:
Attributes []:
Password: <userinput>xxxxxxxx</userinput>
Verifying password - Password: <userinput>xxxxxxxx</userinput></screen>

      <para>Jetzt kann das <acronym>KDC</acronym> gestartet werden.
	F&uuml;hren Sie zum Start der Dienste die Kommandos
	<command>/etc/rc.d/kerberos start</command> und
	<command>/etc/rc.d/kadmind start</command> aus.  Obwohl
	zu diesem Zeitpunkt noch keine kerberisierten Dienste
	laufen, k&ouml;nnen Sie die Funktion des <acronym>KDC</acronym>s
	schon &uuml;berpr&uuml;fen.  F&uuml;r den eben angelegten
	Benutzer k&ouml;nnen Sie sich vom <acronym>KDC</acronym>
	Tickets holen und diese Tickets anzeigen:</para>

      <screen>&prompt.user; <userinput>k5init <replaceable>tillman</replaceable></userinput>
tillman@EXAMPLE.ORG's Password:

&prompt.user; <userinput>k5list</userinput>
Credentials cache: FILE: <filename>/tmp/krb5cc_500</filename>
        Principal: tillman@EXAMPLE.ORG

  Issued           Expires          Principal
Aug 27 15:37:58  Aug 28 01:37:58  krbtgt/EXAMPLE.ORG@EXAMPLE.ORG</screen>
    </sect2>

    <sect2>
      <title><application>Kerberos</application>-Dienste
	einrichten</title>
      <indexterm>
	<primary>Kerberos5</primary>
	<secondary>Dienste einrichten</secondary>
      </indexterm>

      <para>Alle Rechner, die kerberisierte Dienste anbieten,
	m&uuml;ssen eine Kopie der
	<application>Kerberos</application>-Konfigurationsdatei
	<filename>/etc/krb5.conf</filename> besitzen.  Sie
	k&ouml;nnen die Datei einfach vom <acronym>KDC</acronym>
	kopieren.</para>

      <para>Anschlie&szlig;end m&uuml;ssen Sie die Datei
	<filename>/etc/krb5.keytab</filename> erzeugen.  Im
	Gegensatz zu normalen Workstations ben&ouml;tigt jeder
	Server eine <filename>keytab</filename>.
	Diese Datei enth&auml;lt den Schl&uuml;ssel des
	Servers, mit dem sich der Server und das
	<acronym>KDC</acronym> gegenseitig authentifizieren
	k&ouml;nnen.  Die Datei muss sicher auf den Server
	transportiert werden (beispielsweise mit &man.scp.1;
	oder einer Diskette).  Unter keinen Umst&auml;nden
	darf die Datei im Klartext, zum Beispiel mit
	<acronym>FTP</acronym>, &uuml;bertragen werden,
	da sonst die Sicherheit des Servers gef&auml;hrdet
	ist.</para>

      <para>Sie k&ouml;nnen die <filename>keytab</filename> auch
	mit dem Programm <command>kadmin</command> &uuml;bertragen.
	Da Sie mit <command>kadmin</command> sowieso einen Host-Prinzipal
	f&uuml;r den Server einrichten m&uuml;ssen, ist das ganz
	praktisch.</para>

      <para>Sie m&uuml;ssen allerdings schon ein Ticket
	besitzen und berechtigt sein, <command>kadmin</command>
	auszuf&uuml;hren.  Die Berechtigung erhalten Sie durch
	einen Eintrag in der Zugriffskontrollliste
	<filename>kadmind.acl</filename>.  Weitere Informationen
	&uuml;ber Zugriffskontrolllisten erhalten Sie in den
	Heimdal-Info-Seiten (<command>info heimdal</command>)
	im Abschnitt <quote>Remote administration</quote>.  Wenn
	der Zugriff auf <command>kadmin</command> von entfernten
	Maschinen verboten ist, m&uuml;ssen Sie sich sicher
	auf dem <acronym>KDC</acronym> anmelden (lokale Konsole,
	&man.ssh.1; oder kerberisiertes Telnet) und die
	<filename>keytab</filename> lokal mit
	<command>kadmin -l</command> erzeugen.</para>

      <para>Nachdem Sie die Datei <filename>/etc/krb5.conf</filename>
	installiert haben, k&ouml;nnen Sie das Kommando
	<command>kadmin</command> benutzen.  An der Eingabeaufforderung
	von <command>kadmin</command> erstellt das Kommando
	<command>add --random-key</command> den Host-Prinzipal
	und das Kommando <command>ext</command> extrahiert den
	Schl&uuml;ssel des Prinzipals in eine Datei:</para>

      <screen>&prompt.root; <userinput>kadmin</userinput>
kadmin> <userinput>add --random-key host/myserver.example.org</userinput>
Max ticket life [unlimited]:
Max renewable life [unlimited]:
Attributes []:
kadmin> <userinput>ext host/myserver.example.org</userinput>
kadmin> <userinput>exit</userinput></screen>

      <para>Das Kommando <command>ext</command> (von
	<foreignphrase>extract</foreignphrase>) speichert den
	extrahierten Schl&uuml;ssel in der Datei
	<filename>/etc/krb5.keytab</filename>.</para>

      <para>Wenn auf dem <acronym>KDC</acronym>, vielleicht aus
	Sicherheitsgr&uuml;nden, <command>kadmind</command>
	nicht l&auml;uft, k&ouml;nnen Sie das Kommando
	<command>kadmin</command> von entfernten Rechnern nicht
	benutzen.  In diesem Fall legen Sie den Host-Prinzipal
	<username>host/myserver.EXAMPLE.ORG</username> direkt
	auf dem <acronym>KDC</acronym> an.  Den Schl&uuml;ssel
	extrahieren Sie in eine tempor&auml;re Datei (damit
	die Datei <filename>/etc/krb5.keytab</filename> nicht
	&uuml;berschrieben wird):</para>

      <screen>&prompt.root; <userinput>kadmin</userinput>
kadmin> <userinput>ext --keytab=/tmp/example.keytab host/myserver.example.org</userinput>
kadmin> <userinput>exit</userinput></screen>

      <para>Anschlie&szlig;end m&uuml;ssen Sie die erzeugte
	<filename>example.keytab</filename> sicher auf den
	Server kopieren (mit <command>scp</command> oder
	mithilfe einer Diskette).  Geben Sie auf jeden Fall
	einen anderen Namen f&uuml;r die <filename>keytab</filename>
	an, weil sonst die <filename>keytab</filename> des
	<acronym>KDC</acronym>s &uuml;berschrieben w&uuml;rde.</para>

      <para>Wegen der Datei <filename>krb5.conf</filename> kann
	der Server nun mit dem <acronym>KDC</acronym> kommunizieren
	und seine Identit&auml;t mithilfe der Datei
	<filename>krb5.keytab</filename> nachweisen.  Jetzt
	k&ouml;nnen wir kerberisierte Dienste aktivieren.
	F&uuml;r <command>telnet</command> muss die folgende
	Zeile in <filename>/etc/inetd.conf</filename> eingef&uuml;gt
	werden:</para>

      <programlisting>telnet    stream  tcp     nowait  root    /usr/libexec/telnetd  telnetd -a user</programlisting>

      <para>Ausschlaggebend ist, dass die Authentifizierungs-Methode
	mit <option>-a</option> auf <literal>user</literal> gesetzt
	wird.  Weitere Details entnehmen Sie bitte der Hilfeseite
	&man.telnetd.8;.</para>

      <para>Nachdem sie die Zeile in <filename>/etc/inetd.conf</filename>
	eingef&uuml;gt haben, starten Sie &man.inetd.8; mit
	dem Kommando <command>/etc/rc.d/inetd restart</command>
	durch.</para>
    </sect2>

    <sect2>
      <title><application>Kerberos</application>-Clients
	einrichten</title>
      <indexterm>
	<primary>Kerberos5</primary>
	<secondary>Clients einrichten</secondary>
      </indexterm>

      <para>Ein Client l&auml;sst sich leicht einrichten.
	Sie ben&ouml;tigen nur die
	<application>Kerberos</application>-Konfigurationsdatei
	<filename>/etc/krb5.conf</filename>.  Kopieren Sie
	die Konfigurationsdatei einfach vom <acronym>KDC</acronym>
	auf den Client.</para>

      <para>Sie k&ouml;nnen jetzt mit <command>kinit</command>
        Tickets anfordern, mit <command>klist</command> Tickets
	anzeigen und mit <command>kdestroy</command> Tickets
	l&ouml;schen.  Sie k&ouml;nnen mit
	<application>Kerberos</application>-Anwendungen kerberisierte
	Server ansprechen.  Wenn das nicht funktioniert,
	Sie aber Tickets anfordern k&ouml;nnen, hat wahrscheinlich
	der  kerberisierte Server ein Problem und nicht der
	Client oder das <acronym>KDC</acronym>.</para>

      <para>Wenn Sie eine Anwendung wie <command>telnet</command>
	testen, k&ouml;nnen Sie mit einem Paket-Sniffer
	(beispielsweise &man.tcpdump.1;) &uuml;berpr&uuml;fen,
	dass Passw&ouml;rter verschl&uuml;sselt &uuml;bertragen
	werden.  Probieren Sie auch die Option <option>-x</option>
	von <command>telnet</command>, die den gesamten Datenverkehr
	verschl&uuml;sselt (analog zu <command>ssh</command>).</para>

      <para>Die <application>Kerberos</application>-Basisanwendungen
	<command>kinit</command>, <command>klist</command>,
	<command>kdestroy</command> und <command>kpasswd</command>
	geh&ouml;ren zum &os;-Basissystem.  Beachten Sie, dass
	die Programme vor &os;&nbsp;5.0 in <command>k5init</command>,
	<command>k5list</command>, <command>k5destroy</command>,
	<command>k5passwd</command> und <command>k5stash</command>
	umbenannt wurden.</para>

      <para>Zu Heimdal geh&ouml;ren noch weitere Anwendungen.
	Allerdings enth&auml;lt das &os;-Basissystem eine
	minimale Heimdal-Installation und nur eine
	kerberisierte Anwendung: <command>telnet</command>.</para>

      <para>Der Heimdal-Port enth&auml;lt noch mehr kerberisierte
	Anwendungen wie <command>ftp</command>, <command>rsh</command>,
	<command>rcp</command> und <command>rlogin</command>.
	Der <acronym>MIT</acronym>-Port enth&auml;lt ebenfalls
	weitere kerberisierte Anwendungen.</para>
    </sect2>

    <sect2>
      <title><filename>.k5login</filename> und
	<filename>.k5users</filename></title>

      <indexterm>
	<primary><filename>.k5login</filename></primary>
      </indexterm>
      <indexterm>
	<primary><filename>.k5users</filename></primary>
      </indexterm>

      <para>Normalerweise wird ein
	<application>Kerberos</application>-Prinzipal wie
	<username>tillman@EXAMPLE.ORG</username> auf ein lokales
	Benutzerkonto, beispielsweise <username>tillman</username>,
	abgebildet.  Daher ben&ouml;tigen Client-Anwendungen (zum
	Beispiel <command>telnet</command>) keinen Benutzernamen.</para>

      <para>Manchmal wird aber Zugriff auf ein lokales Benutzerkonto
	ben&ouml;tigt, zu dem es keinen passenden
	<application>Kerberos</application>-Prinzipal gibt.
	Der Prinzipal <username>tillman@EXAMPLE.ORG</username>
	br&auml;uchte beispielsweise Zugriff auf das Konto
	<username>webdevelopers</username>.  Ebenso k&ouml;nnten
	andere Prinzipale auf dieses Konto zugreifen wollen.</para>

      <para>Die Dateien <filename>.k5login</filename> und
	<filename>.k5users</filename> im Heimatverzeichnis eines
	Benutzerkontos gew&auml;hren Zugriffe &auml;hnlich wie
	die Dateien <filename>.hosts</filename> und
	<filename>.rhosts</filename>.  Um den Prinzipalen
	<username>tillman@example.org</username> und
	<username>jdoe@example.org</username> auf das Konto
	<username>webdevelopers</username> zu geben, wird im
	Heimatverzeichnis von <username>webdevelopers</username>
	die Datei <filename>.k5login</filename> mit folgendem
	Inhalt angelegt:</para>

      <screen>tillman@example.org
jdoe@example.org</screen>

      <para>Die angegebenen Prinzipale haben nun ohne ein gemeinsames
	Passwort Zugriff auf das Konto.</para>

      <para>Einzelheiten entnehmen Sie bitte den Hilfeseiten
	zu diesen Dateien.  Die Datei <filename>.k5users</filename>
	wird in der Hilfeseite des Kommandos <command>ksu</command>
	beschrieben.</para>
    </sect2>

    <sect2>
      <title>Tipps und Fehlersuche</title>
      <indexterm>
	<primary>Kerberos5</primary>
	<secondary>Fehlersuche</secondary>
      </indexterm>

      <itemizedlist>
	<listitem>
	  <para>Wenn Sie den Heimdal-Port oder den
	    <acronym>MIT</acronym>-Port benutzen, muss in der
	    Umgebungsvariable <envar>PATH</envar> der Pfad zu
	    den Programmen des Ports vor dem Pfad zu den
	    <application>Kerberos</application>-Programmen des Systems
	    stehen.</para>
	</listitem>

	<listitem>
	  <para>Sind die Uhrzeiten der Systeme synchronisiert?
	    Wenn nicht, schl&auml;gt vielleicht die Authentifizierung
	    fehl.  <xref linkend="network-ntp"> beschreibt, wie
	    Sie mithilfe von <acronym>NTP</acronym> die Uhrzeiten
	    synchronisieren.</para>
	</listitem>

	<listitem>
	  <para>Die <acronym>MIT</acronym>- und Heimdal-Systeme
	    arbeiten bis auf <command>kadmin</command> gut zusammen.
	    F&uuml;r <command>kadmin</command> wurde das Protokoll
	    nicht normiert.</para>
	</listitem>

	<listitem>
	  <para>Wenn Sie den Namen eines Rechners &auml;ndern,
	    m&uuml;ssen Sie auch den <username>host/</username>-Prinzipal
	    &auml;ndern und die Datei <filename>keytab</filename>
	    aktualisieren.  Dies betrifft auch spezielle Eintr&auml;ge
	    wie den Prinzipal f&uuml;r Apaches <filename
	      role="package">www/mod_auth_kerb</filename>.</para>
	</listitem>

	<listitem>
	  <para>Die Rechnernamen m&uuml;ssen vor- und
	    r&uuml;ckw&auml;rts aufgel&ouml;st werden (im
	    <acronym>DNS</acronym> oder in
	    <filename>/etc/hosts</filename>).
	    <acronym>CNAME</acronym>-Eintr&auml;ge im
	    <acronym>DNS</acronym> funktionieren, aber die
	    entsprechenden A- und PTR-Eintr&auml;ge m&uuml;ssen
	    vorhanden und richtig sein.  Wenn sich Namen nicht
	    aufl&ouml;sen lassen, ist die Fehlermeldung nicht
	    gerade selbstsprechend: <errorname>Kerberos5 refuses
	      authentication because Read req
	      failed: Key table entry not found</errorname>.</para>
	</listitem>

	<listitem>
	  <para>Einige Betriebssysteme installieren
	    <command>ksu</command> mit falschen Zugriffsrechten;
	    es fehlt das Set-UID-Bit f&uuml;r <username>root</username>.
	    Das mag aus Sicherheitsgr&uuml;nden richtig sein,
	    doch funktioniert <command>ksu</command> dann nicht.
	    Dies ist kein Fehler des <acronym>KDC</acronym>s.</para>
	</listitem>

	<listitem>
	  <para>Wenn Sie f&uuml;r einen Prinzipal unter
	    <acronym>MIT</acronym>-<application>Kerberos</application>
	    Tickets mit einer l&auml;ngeren G&uuml;ltigkeit als
	    der vorgegebenen zehn Stunden einrichten wollen,
	    m&uuml;ssen Sie zwei Sachen &auml;ndern.  Benutzen
	    Sie das <command>modify_principal</command> von
	    <command>kadmin</command>, um die maximale
	    G&uuml;ltigkeitsdauer f&uuml;r den Prinzipal selbst
	    und den Prinzipal <username>krbtgt</username>
	    zu erh&ouml;hen.</para>
	</listitem>

	<listitem>
	  <para>Mit einem Packet-Sniffer k&ouml;nnen Sie feststellen,
	    dass Sie sofort nach dem Aufruf von <command>kinit</command>
	    eine Antwort vom <acronym>KDC</acronym>
	    bekommen &ndash; noch bevor Sie &uuml;berhaupt ein
	    Passwort eingegeben haben!  Das ist in Ordnung:
	    Das <acronym>KDC</acronym> h&auml;ndigt
	    ein Ticket-Granting-Ticket (<acronym>TGT</acronym>)
	    auf Anfrage aus, da es durch einen vom Passwort
	    des Benutzers abgeleiteten Schl&uuml;ssel
	    gesch&uuml;tzt ist.  Wenn das Passwort
	    eingegeben wird, wird es nicht zum <acronym>KDC</acronym>
	    gesendet, sondern zum Entschl&uuml;sseln der
	    Antwort des <acronym>KDC</acronym>s benutzt, die
	    <command>kinit</command> schon erhalten hat.
	    Wird die Antwort erfolgreich entschl&uuml;sselt,
	    erh&auml;lt der Benutzer einen Sitzungs-Schl&uuml;ssel
	    f&uuml;r die k&uuml;nftige verschl&uuml;sselte
	    Kommunikation mit dem <acronym>KDC</acronym> und das
	    Ticket-Granting-Ticket.  Das Ticket-Granting-Ticket
	    wiederum ist mit dem Schl&uuml;ssel des <acronym>KDC</acronym>s
	    verschl&uuml;sselt.  Diese Verschl&uuml;sselung ist
	    f&uuml;r den Benutzer v&ouml;llig transparent und
	    erlaubt dem <acronym>KDC</acronym>,
	    die Echtheit jedes einzelnen <acronym>TGT</acronym>
	    zu pr&uuml;fen.</para>
	</listitem>

	<listitem>
	  <para>Wenn Sie <application>OpenSSH</application> verwenden
	    und Tickets mir einer langen G&uuml;ltigkeit
	    (beispielsweise einer Woche) benutzen, setzen Sie die Option
	    <option>TicketCleanup</option> in der Datei
	    <filename>sshd_config</filename> auf <literal>no</literal>.
	    Ansonsten werden Ihre Tickets gel&ouml;scht, wenn Sie
	    sich abmelden.</para>
	</listitem>

	<listitem>
	  <para>Host-Prinzipale k&ouml;nnen ebenfalls Tickets mit
	    l&auml;ngerer G&uuml;ltigkeit besitzen.  Wenn der
	    Prinzipal eines Benutzers &uuml;ber ein Ticket verf&uuml;gt,
	    das eine Woche g&uuml;ltig ist, das Ticket des
	    Host-Prinzipals aber nur neun Stunden g&uuml;ltig ist,
	    funktioniert der Ticket-Cache nicht wie erwartet.
	    Im Cache befindet sich dann ein abgelaufenes Ticket
	    des Host-Prinzipals.</para>
	</listitem>

	<listitem>
	  <para>Wenn Sie mit <filename>krb5.dict</filename> die
	    Verwendung schlechter Passw&ouml;rter verhindern wollen,
	    geht das nur mit Prinzipalen, denen eine Passwort-Policy
	    zugewiesen wurde.  Die Hilfeseite von
	    <command>kadmind</command> beschreibt kurz, wie
	    <filename>krb5.dict</filename> verwendet wird.  Das
	    Format von <filename>krb5.dict</filename> ist
	    einfach:  Die Datei enth&auml;lt pro Zeile ein Wort.
	    Sie k&ouml;nnen daher einen symbolischen Link auf
	    <filename>/usr/share/dict/words</filename> erstellen.</para>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>Unterschiede zum <acronym>MIT</acronym>-Port</title>

      <para>Der Hauptunterschied zwischen
	<acronym>MIT</acronym>-<application>Kerberos</application>
	und Heimdal-<application>Kerberos</application>
	ist das Kommando <command>kadmin</command>.
	Die Befehlss&auml;tze des Kommandos (obwohl funktional
	gleichwertig) und das verwendete
	Protokoll unterscheiden sich in beiden Varianten.
	Das <acronym>KDC</acronym> l&auml;sst sich nur mit
	dem <command>kadmin</command> Kommando der passenden
	<application>Kerberos</application>-Variante verwalten.</para>

      <para>F&uuml;r dieselbe Funktion k&ouml;nnen auch die
	Client-Anwendungen leicht ge&auml;nderte Kommandozeilenoptionen
	besitzen.  Folgen Sie bitte der Anleitung auf der
	<application>Kerberos</application>-Seite
	(<ulink url="http://web.mit.edu/Kerberos/www/"></ulink>) des
	<acronym>MIT</acronym>s.  Achten Sie besonders auf den
	Suchpfad f&uuml;r Anwendungen.  Der <acronym>MIT</acronym>-Port
	wird standardm&auml;&szlig;ig in <filename>/usr/local/</filename>
	installiert.  Wenn die Umgebungsvariable <envar>PATH</envar>
	zuerst die Systemverzeichnisse enth&auml;lt, werden die
	Systemprogramme anstelle der <acronym>MIT</acronym>-Programme
	ausgef&uuml;hrt.</para>

      <note>
	<para>Wenn Sie den <acronym>MIT</acronym>-Port
	  <filename role="package">security/krb5</filename> verwenden,
	  erscheint bei der Anmeldung mit <command>telnetd</command>
	  und <command>klogind</command> die Fehlermeldung
	  <errorname>incorrect permissions on cache file</errorname>.
	  Lesen Sie dazu bitte die im Port enthaltene Datei
	  <filename>/usr/local/share/doc/krb5/README.FreeBSD</filename>.
	  Wichtig ist, dass zur Authentifizierung die Bin&auml;rdatei
	  <command>login.krb5</command> verwendet wird, die
	  f&uuml;r durchgereichte Berechtigungen die Eigent&uuml;mer
	  korrekt &auml;ndert.</para>
      </note>
    </sect2>

    <sect2>
      <title>Beschr&auml;nkungen von
	<application>Kerberos</application></title>
      <indexterm>
	<primary>Kerberos5</primary>
	<secondary>Beschr&auml;nkungen</secondary>
      </indexterm>

      <sect3>
	<title><application>Kerberos</application> muss ganzheitlich
	  verwendet werden</title>

	<para>Jeder &uuml;ber das Netzwerk angebotetene Dienst
	  muss mit <application>Kerberos</application>
	  zusammenarbeiten oder auf anderen Wegen gegen Angriffe
	  aus dem Netzwerk gesch&uuml;tzt sein.  Andernfalls
	  k&ouml;nnen Berechtigungen gestohlen und wiederverwendet
	  werden.  Es ist beispielsweise nicht sinnvoll, f&uuml;r
	  Anmeldungen mit <command>rsh</command> und
	  <command>telnet</command> <application>Kerberos</application>
	  zu benutzen, dagegen aber <acronym>POP3</acronym>-Zugriff
	  auf einen Mail-Server zu erlauben, da <acronym>POP3</acronym>
	  Passw&ouml;rter im Klartext versendet.</para>
      </sect3>

      <sect3>
	<title><application>Kerberos</application> ist f&uuml;r
	  Einbenutzer-Systeme gedacht</title>

	<para>In Mehrbenutzer-Umgebungen ist
	  <application>Kerberos</application> unsicherer als in
	  Einbenutzer-Umgebungen, da die Tickets im f&uuml;r alle
	  lesbaren Verzeichnis <filename>/tmp</filename>
	  gespeichert werden.  Wenn ein Rechner von mehreren
	  Benutzern verwendet wird, ist es m&ouml;glich, dass
	  Tickets gestohlen werden.</para>

	<para>Dieses Problem k&ouml;nnen Sie l&ouml;sen, indem Sie mit
	  der Kommandozeilenoption <option>-c</option> oder besser
	  mit der Umgebungsvariablen <envar>KRB5CCNAME</envar> einen
	  Ort f&uuml;r die Tickets vorgeben.  Diese Vorgehensweise
	  wird leider selten benutzt.  Es reicht, die Tickets
	  im Heimatverzeichnis eines Benutzers zu speichern und
	  mit Zugriffsrechten zu sch&uuml;tzen.</para>
      </sect3>

      <sect3>
	<title>Das <acronym>KDC</acronym> ist verwundbar</title>

	<para>Das <acronym>KDC</acronym> muss genauso abgesichert
	  werden wie die auf ihm befindliche Passwort-Datenbank.
	  Auf dem <acronym>KDC</acronym> d&uuml;rfen keine anderen
	  Dienste laufen und der Rechner sollte physikalisch
	  gesichert sein.  Die Gefahr ist gro&szlig;, da
	  <application>Kerberos</application> alle Passw&ouml;rter
	  mit einem Schl&uuml;ssel, dem Haupt-Schl&uuml;ssel,
	  verschl&uuml;sselt.  Der Haupt-Schl&uuml;ssel wiederum
	  wird in einer Datei auf dem <acronym>KDC</acronym>
	  gespeichert.</para>

	<para>Ein kompromittierter Haupt-Schl&uuml;ssel ist nicht
	  ganz so schlimm wie allgemein angenommen.  Der
	  Haupt-Schl&uuml;ssel wird nur zum Verschl&uuml;sseln
	  der Passwort-Datenbank und zum Initialisieren des
	  Zufallsgenerators verwendet.  Solange der Zugriff
	  auf das <acronym>KDC</acronym> abgesichert ist, kann
	  ein Angreifer wenig mit dem Haupt-Schl&uuml;ssel
	  anfangen.</para>

	<para>Wenn das <acronym>KDC</acronym> nicht zur Verf&uuml;gung
	  steht, vielleicht wegen eines Denial-of-Service Angriffs
	  oder wegen eines Netzwerkproblems, ist eine Authentifizierung
	  unm&ouml;glich.  Damit k&ouml;nnen die Netzwerk-Dienste
	  nicht benutzt werden; das <acronym>KDC</acronym> ist
	  also ein optimales Ziel f&uuml;r einen Denial-of-Service
	  Angriff.  Sie k&ouml;nnen diesem Angriff ausweichen,
	  indem Sie mehrere <acronym>KDC</acronym>s (einen Master
	  und einen oder mehrere Slaves) verwenden.  Der R&uuml;ckfall
	  auf ein sekund&auml;res <acronym>KDC</acronym> oder
	  eine andere Authentifizierungs-Methode (dazu ist
	  <acronym>PAM</acronym> bestens geeignet) muss sorgf&auml;ltig
	  eingerichtet werden.</para>
      </sect3>

      <sect3>
	<title>M&auml;ngel von
	  <application>Kerberos</application></title>

	<para>Mit <application>Kerberos</application> k&ouml;nnen
	  sich Benutzer, Rechner und Dienste gegenseitig
	  authentifizieren.  Allerdings existiert kein Mechanismus,
	  der das <acronym>KDC</acronym> gegen&uuml;ber Benutzern,
	  Rechnern oder Diensten authentifiziert.  Ein ver&auml;ndertes
	  <command>kinit</command> k&ouml;nnte beispielsweise alle
	  Benutzernamen und Passw&ouml;rter abfangen.  Die von
	  ver&auml;nderten Programmen ausgehende Gefahr k&ouml;nnen
	  Sie lindern, indem Sie die Integrit&auml;t von Dateien
	  mit Werkzeugen wie
	  <filename role="package">security/tripwire</filename>
	  pr&uuml;fen.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Weiterf&uuml;hrende Dokumentation</title>
      <indexterm>
	<primary>Kerberos5</primary>
	<secondary>weiterf&uuml;hrende Dokumentation</secondary>
      </indexterm>

      <itemizedlist>
	<listitem>
	  <para><ulink
	    url="http://www.faqs.org/faqs/Kerberos-faq/general/preamble.html">The
            Kerberos FAQ</ulink></para>
	</listitem>

	<listitem>
	  <para><ulink url="http://web.mit.edu/Kerberos/www/dialogue.html">Designing
	    an Authentication System: a Dialogue in Four
	    Scenes</ulink></para>
	</listitem>

	<listitem>
	  <para><ulink url="http://www.ietf.org/rfc/rfc1510.txt?number=1510">RFC 1510,
	    The <application>Kerberos</application> Network
	    Authentication Service (V5)</ulink></para>
	</listitem>

	<listitem>
	  <para><ulink url="http://web.mit.edu/Kerberos/www/"><acronym>MIT</acronym>
	    <application>Kerberos</application>-Seite</ulink></para>
	</listitem>

	<listitem>
	  <para><ulink url="http://www.pdc.kth.se/heimdal/">Heimdal
	    <application>Kerberos</application>-Seite</ulink></para>
	</listitem>
      </itemizedlist>
    </sect2>
  </sect1>

  <sect1 id="openssl">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <title>OpenSSL</title>
    <indexterm>
      <primary>Sicherheit</primary>
      <secondary>OpenSSL</secondary>
    </indexterm>
    <indexterm><primary>OpenSSL</primary></indexterm>

    <para>Es wird oft &uuml;bersehen, dass
      <application>OpenSSL</application> Teil des &os;-Basissystems
      ist.  <application>OpenSSL</application> bietet eine
      verschl&uuml;sselte Transportschicht oberhalb der
      normalen Kommunikationsschicht und kann daher zusammen
      mit vielen Netzdiensten benutzt werden.</para>

    <para>Anwendungsbeispiele f&uuml;r <application>OpenSSL</application>
      sind die verschl&uuml;sselte Authentifizierung von
      E-Mail-Clients oder Web-Transaktionen wie das Bezahlen mit
      einer Kreditkarte.  <application>OpenSSL</application>
      kann w&auml;hrend des Baus in viele Ports, wie
      <filename role="package">www/apache13-ssl</filename> und
      <filename role="package">mail/sylpheed-claws</filename>,
      integriert werden.</para>

    <note>
      <para>Ist beim Aufruf von <command>make</command> die
	Variable <makevar>WITH_OPENSSL_BASE</makevar> nicht
	explizit auf <literal>yes</literal> gesetzt, baut
	die Ports-Sammlung meist den Port
	<filename role="package">security/openssl</filename>.</para>
    </note>

    <para>Das <application>OpenSSL</application> von &os; stellt
      die Protokolle Secure Sockets Layer v2/v3 (SSLv2/SSLv3) und
      Transport Layer Security v1 (TLSv1) zur Verf&uuml;gung.
      Die <application>OpenSSL</application>-Bibliotheken stellen
      kryptographische Funktionen bereit.</para>

    <note>
      <para>Mit <application>OpenSSL</application> kann der
	<acronym>IDEA</acronym>-Algorithmus verwendet werden,
	wegen Patenten in den USA ist der Algorithmus in der
	Voreinstellung allerdings deaktiviert.  Wenn Sie die
	<acronym>IDEA</acronym>-Lizenz akzeptieren, k&ouml;nnen
	Sie den <acronym>IDEA</acronym>-Algorithmus aktivieren,
	indem Sie die Variable <makevar>MAKE_IDEA</makevar>
	in <filename>make.conf</filename> setzen.</para>
    </note>

    <para>Meist wird <application>OpenSSL</application> eingesetzt,
      um Zertifikate f&uuml;r Anwendungen bereitzustellen.  Die
      Zertifikate stellen die Identit&auml;t einer Firma oder
      eines Einzelnen sicher.  Wenn ein Zertifikat nicht von
      einer Zertifizierungsstelle (<foreignphrase>Certificate
        Authority</foreignphrase>, <acronym>CA</acronym>)
      gegengezeichnet wurde, erhalten Sie normalerweise eine
      Warnung.  Eine Zertifizierungsstelle ist eine Firma
      wie <ulink url="http://www.verisign.com/">VeriSign</ulink>,
      die Zertifikate von Personen oder Firmen
      gegenzeichnet und damit die Korrektheit der Zertifikate
      best&auml;tigt.  Diese Prozedur kostet Geld, ist aber
      keine Voraussetzung f&uuml;r den Einsatz von Zertifikaten,
      beruhigt aber sicherheitsbewusste Benutzer.</para>
      <!-- XXX paranoid users ?? -->

    <sect2>
      <title>Zertifikate erzeugen</title>

      <indexterm>
	<primary>OpenSSL</primary>
	<secondary>Zertifikate erzeugen</secondary>
      </indexterm>

      <para>Ein Zertifikat erzeugen Sie mit dem nachstehenden
	Kommando:</para>

      <screen>&prompt.root; <userinput>openssl req -new -nodes -out req.pem -keyout cert.pem</userinput>
Generating a 1024 bit RSA private key
................++++++
.......................................++++++
writing new private key to 'cert.pem'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [AU]:<userinput><replaceable>US</replaceable></userinput>
State or Province Name (full name) [Some-State]:<userinput><replaceable>PA</replaceable></userinput>
Locality Name (eg, city) []:<userinput><replaceable>Pittsburgh</replaceable></userinput>
Organization Name (eg, company) [Internet Widgits Pty Ltd]:<userinput><replaceable>My Company</replaceable></userinput>
Organizational Unit Name (eg, section) []:<userinput><replaceable>Systems Administrator</replaceable></userinput>
Common Name (eg, YOUR name) []:<userinput><replaceable>localhost.example.org</replaceable></userinput>
Email Address []:<userinput><replaceable>trhodes@FreeBSD.org</replaceable></userinput>

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:<userinput><replaceable>SOME PASSWORD</replaceable></userinput>
An optional company name []:<userinput><replaceable>Another Name</replaceable></userinput></screen>

      <para>Beachten Sie bitte, dass die Eingabe bei
	<quote>Common Name</quote> ein g&uuml;ltiger Domain-Name
	sein muss.  Eine andere Eingabe erzeugt ein unbrauchbares
	Zertifikat.  Das Zertifikat kann mit einer
	G&uuml;ltigkeitsdauer und anderen
	Verschl&uuml;sselungsalgorithmen erzeugt werden.
	Die Hilfeseite &man.openssl.1; beschreibt die zur
	Verf&uuml;gung stehenden Optionen.</para>

      <para>Das Verzeichnis, in dem Sie den letzten Befehl ausgef&uuml;hrt
	haben, enth&auml;lt nun zwei Dateien:  Die Anforderung f&uuml;r
	ein neues Zertifikat wurde in <filename>req.pem</filename>
	gespeichert.  Diese Datei k&ouml;nnen Sie an eine
	Zertifizierungsstelle senden, wo Ihre Angaben gepr&uuml;ft werden.
	Nach erfolgreicher Pr&uuml;fung wird das Zertifikat an Sie
	zur&uuml;ckgesandt.  Die zweite Datei, <filename>cert.pem</filename>,
	enth&auml;lt den privaten Schl&uuml;ssel f&uuml;r Ihr Zertifikat
	und darf auch keine Fall in fremde H&auml;nde geraten, da ein
	Angreifer sonst in der Lage ist, anderen Personen oder Rechnern
	vorzugaukeln, dass es sich bei ihm um Sie handelt.</para>

      <para>Wenn Sie keine Signatur einer Zertifizierungsstelle
	ben&ouml;tigen, k&ouml;nnen Sie ein selbst-signiertes
	Zertifikat erstellen.  Erzeugen Sie dazu zuerst einen
	<acronym>RSA</acronym>-Schl&uuml;ssel:</para>

      <screen>&prompt.root; <userinput>openssl dsaparam -rand -genkey -out <filename>myRSA.key</filename> 1024</userinput></screen>

      <para>Erzeugen Sie dann den <acronym>CA</acronym>-Schl&uuml;ssel:</para>

      <screen>&prompt.root; <userinput>openssl gendsa -des3 -out <filename>myca.key</filename> <filename>myRSA.key</filename></userinput></screen>

      <para>Erstellen Sie mit diesem Schl&uuml;ssel das
        Zertifikat:</para>

      <screen>&prompt.root; <userinput>openssl req -new -x509 -days 365 -key <filename>myca.key</filename> -out <filename>new.crt</filename></userinput></screen>

      <para>Zwei neue Dateien befinden sich nun im Verzeichnis:
	Der Schl&uuml;ssel der Zertifizierungsstelle
	<filename>myca.key</filename> und das Zertifikat selbst,
	<filename>new.crt</filename>.  Sie sollten in einem
	Verzeichnis, vorzugsweise unterhalb von
	<filename class="directory">/etc</filename> abgelegt
	werden, das nur von <username>root</username> lesbar
	ist.  Setzen Sie die Zugriffsrechte der Dateien mit
	<command>chmod</command> auf <literal>0700</literal>.</para>
    </sect2>

    <sect2>
      <title>Beispiel f&uuml;r Zertifikate</title>

      <para>Was fangen Sie mit einem Zertifikat an?  Sie
	k&ouml;nnten damit beispielsweise die Verbindungen zu
	<application>Sendmail</application> verschl&uuml;sseln.
	Dies w&uuml;rde die Klartext-Authentifizierung
	f&uuml;r Benutzer des lokalen <acronym>MTA</acronym>
	&uuml;berfl&uuml;ssig machen.</para>

      <note>
	<para>Das ist nicht unbedingt die beste L&ouml;sung,
	  da einige <acronym>MUA</acronym>s Warnungen ausgeben,
	  wenn ein Zertifikat nicht lokal installiert ist.
	  Die Installation von Zertifikaten wird in der
	  Dokumentation der <acronym>MUA</acronym>s
	  beschrieben.</para>
      </note>

      <para>Erg&auml;nzen Sie die Konfigurationsdatei von
	<application>sendmail</application> (<filename>.mc</filename>)
	um die nachstehenden Zeilen:</para>

      <programlisting>dnl SSL Options
define(`confCACERT_PATH',`/etc/certs')dnl
define(`confCACERT',`/etc/certs/new.crt')dnl
define(`confSERVER_CERT',`/etc/certs/new.crt')dnl
define(`confSERVER_KEY',`/etc/certs/myca.key')dnl
define(`confTLS_SRV_OPTIONS', `V')dnl</programlisting>

      <para>Im Verzeichnis
	<filename class="directory">/etc/certs</filename>
	befindet sich der Schl&uuml;ssel und das Zertifikat.
	Bauen Sie danach im Verzeichnis
	<filename class="directory">/etc/mail</filename>
	mit dem Kommando <command>make install</command>
	die <filename>.cf</filename>-Datei und starten
	Sie anschlie&szlig;end <application>sendmail</application>
	mit <command>make restart</command> neu.</para>

      <para>Wenn alles gut ging, erscheinen keine Fehlermeldungen
	in der Datei <filename>/var/log/maillog</filename> und
	Sie sehen <application>sendmail</application> in der
	Prozessliste.</para>

      <para>Testen Sie nun den Mailserver mit dem Kommando
	&man.telnet.1;:</para>

      <screen>&prompt.root; <userinput>telnet <replaceable>example.com</replaceable> 25</userinput>
Trying 192.0.34.166...
Connected to <hostid role="fqdn">example.com</hostid>.
Escape character is '^]'.
220 <hostid role="fqdn">example.com</hostid> ESMTP Sendmail 8.12.10/8.12.10; Tue, 31 Aug 2004 03:41:22 -0400 (EDT)
<userinput>ehlo <replaceable>example.com</replaceable></userinput>
250-example.com Hello example.com [192.0.34.166], pleased to meet you
250-ENHANCEDSTATUSCODES
250-PIPELINING
250-8BITMIME
250-SIZE
250-DSN
250-ETRN
250-AUTH LOGIN PLAIN
250-STARTTLS
250-DELIVERBY
250 HELP
<userinput>quit</userinput>
221 2.0.0 <hostid role="fqdn">example.com</hostid> closing connection
Connection closed by foreign host.</screen>

      <para>Wenn in einer Zeile <literal>STARTTLS</literal>
	erscheint, hat alles funktioniert.</para>
    </sect2>
  </sect1>

  <sect1 id="ipsec">
    <sect1info>
      <authorgroup>
        <author>
	  <firstname>Nik</firstname>
	  <surname>Clayton</surname>
	  <affiliation>
	    <address><email>nik@FreeBSD.org</email></address>
          </affiliation>
          <contrib>Geschrieben von </contrib>
        </author>
      </authorgroup>
    </sect1info>

    <title>VPNs mit IPsec</title>

    <indexterm>
      <primary>IPsec</primary>
    </indexterm>

    <para>Dieser Abschnitt beschreibt, wie Sie mit &os;-Gateways
      ein <firstterm>Virtual-Private-Network</firstterm>
      (<acronym>VPN</acronym>) einrichten.  Als Beispiel wird ein
      <acronym>VPN</acronym> zwischen zwei Netzen verwendet,
      die &uuml;ber das Internet miteinander verbunden sind.</para>

    <sect2>
      <sect2info>
        <authorgroup>
          <author>
            <firstname>Hiten M.</firstname>
            <surname>Pandya</surname>
	    <affiliation>
	      <address><email>hmp@FreeBSD.org</email></address>
	    </affiliation>
	    <contrib>Geschrieben von </contrib>
	  </author>
	</authorgroup>
      </sect2info>

      <title>IPsec Grundlagen</title>

      <para>Dieser Abschnitt zeigt Ihnen, wie Sie IPsec einrichten
	und damit &os;-Systeme und &microsoft.windows; 2000/XP Systeme
	sicher miteinander verbinden.  Um IPsec einzurichten,
	sollten Sie einen neuen Kernel erzeugen k&ouml;nnen (siehe
	<xref linkend="kernelconfig">).</para>

      <para>IPsec ist ein Protokoll, das auf dem Internet-Protokoll
	(IP) aufbaut.  Mit IPsec k&ouml;nnen mehrere Systeme
	gesch&uuml;tzt miteinander kommunizieren.  Das in
	&os; realisierte IPsec-Protokoll baut auf der
	<ulink url="http://www.kame.net/">KAME-Implementierung</ulink>
	auf und unterst&uuml;tzt sowohl IPv4 als auch IPv6.</para>

      <note>
	<para>&os;&nbsp;5.X enth&auml;lt eine von Hardware
	  beschleunigte Variante des IPsec-Protokolls.  Diese
	  Variante wurde von OpenBSD &uuml;bernommen und wird
	  <quote>Fast-IPsec</quote> genannt.  Das
	  &man.crypto.4;-Subsystem arbeitet mit Kryptographie-Hardware
	  zusammen, die IPsec beschleunigt.  Das Subsystem
	  ist neu und bietet noch nicht alle Funktionen, die
	  KAME-IPsec bietet.  Wenn Sie die Hardware-Beschleunigung
	  nutzen wollen, f&uuml;gen Sie folgende Zeile der
	  Kernelkonfiguration hinzu:</para>

        <indexterm>
	  <primary>Kerneloption</primary>
	  <secondary>FAST_IPSEC</secondary>
	</indexterm>

        <screen>options	  FAST_IPSEC  # new IPsec (cannot define w/ IPSEC)</screen>

	<para>Momentan k&ouml;nnen Sie <quote>Fast-IPsec</quote>
	  nicht zusammen mit KAME-IPsec benutzen.  Weiteres zu
	  <quote>Fast-IPsec</quote> erfahren Sie in der
	  Hilfeseite &man.fast.ipsec.4;.</para>
      </note>

      <indexterm>
	<primary>IPsec</primary>
	<secondary>ESP</secondary>
      </indexterm>

      <indexterm>
	<primary>IPsec</primary>
	<secondary>AH</secondary>
      </indexterm>

      <para>IPsec besteht wiederum aus zwei Protokollen:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Encapsulated Security Payload (ESP)</emphasis>
	    verschl&uuml;sselt IP-Pakete mit einem symmetrischen Verfahren
	    (beispielsweise Blowfish oder 3DES).  Damit werden
	    die Pakete vor Manipulationen Dritter gesch&uuml;tzt.</para>
        </listitem>

        <listitem>
          <para>Der <emphasis>Authentication Header (AH)</emphasis>
	    enth&auml;t eine kryptographische Pr&uuml;summe,
	    die sicher stellt, dass ein IP-Paket nicht ver&auml;ndert
	    wurde.  Der Authentication-Header folgt nach dem
	    normalen IP-Header und erlaubt dem Empf&auml;nger
	    eines IP-Paketes, dessen Integrit&auml;t zu
	    pr&uuml;fen.</para>
        </listitem>
      </itemizedlist>

      <para><acronym>ESP</acronym> und <acronym>AH</acronym>
	k&ouml;nnen, je nach Situation, zusammen oder einzeln
	verwendet werden.</para>

      <indexterm>
        <primary>VPN</primary>
      </indexterm>

      <indexterm>
        <primary>Virtual Private Network</primary>
        <see>VPN</see>
      </indexterm>

      <para>IPsec kann in zwei Modi betrieben werden:  Der
	<firstterm>Transport-Modus</firstterm> verschl&uuml;sselt
	die Daten zwischen zwei Systemen.  Der
	<firstterm>Tunnel-Modus</firstterm> verbindet zwei
	Subnetze miteinander.  Durch einen Tunnel k&ouml;nnen
	dann beispielsweise verschl&uuml;sselte Daten &uuml;bertragen
	werden.  Ein Tunnel wird auch als Virtual-Private-Network (VPN)
	bezeichnet.  Detaillierte Informationen &uuml;ber
	das IPsec-Subsystem von &os; enth&auml;lt die
	Hilfeseite &man.ipsec.4;.</para>

      <para>Die folgenden Optionen in der Kernelkonfiguration
	aktivieren IPsec:</para>

      <indexterm>
        <primary>Kerneloption</primary>
        <secondary>IPSEC</secondary>
      </indexterm>

      <indexterm>
        <primary>Kerneloption</primary>
        <secondary>IPSEC_ESP</secondary>
      </indexterm>

      <screen>options   IPSEC        #IP security
options   IPSEC_ESP    #IP security (crypto; define w/ IPSEC)</screen>

      <indexterm>
        <primary>Kerneloption</primary>
        <secondary>IPSEC_DEBUG</secondary>
      </indexterm>

      <para>Wenn Sie zur Fehlersuche im IPsec-Subsystem
	Unterst&uuml;tzung w&uuml;nschen, sollten Sie die
	folgende Option ebenfalls aktivieren:</para>

      <screen>options   IPSEC_DEBUG  #debug for IP security</screen>
    </sect2>

    <sect2>
      <title>Was ist ein VPN?</title>

      <para>Es gibt keinen Standard, der festlegt, was ein
	Virtual-Private-Network ist.  VPNs k&ouml;nnen mit
	verschiedenen Techniken, die jeweils eigene Vor- und
	Nachteile besitzen, implementiert werden.
	Dieser Abschnitt stellt eine M&ouml;glichkeit vor,
	ein VPN aufzubauen.</para>
    </sect2>

    <sect2>
      <title>VPN zwischen zwei Netzen &uuml;ber das Internet</title>

      <indexterm>
        <primary>VPN</primary>
        <secondary>Einrichtung</secondary>
      </indexterm>

      <para>Dieses Szenario hat die folgenden Vorausetzungen:</para>

      <itemizedlist>
        <listitem>
	  <para>Es m&uuml;ssen zwei Netzwerke vorhanden sein.</para>
        </listitem>

        <listitem>
	  <para>Beide Netzwerke m&uuml;ssen intern IP benutzen.</para>
        </listitem>

        <listitem>
	  <para>Beide Netzwerke sind &uuml;ber einen &os;-Gateway
	    mit dem Internet verbunden.</para>
        </listitem>

        <listitem>
	  <para>Der Gateway jedes Netzwerks besitzt mindestens
	    eine &ouml;ffentliche IP-Adresse.</para>
        </listitem>

        <listitem>
          <para>Die intern verwendeten IP-Adressen k&ouml;nnen
	    private oder &ouml;ffentliche Adressen sein.
	    Der Gateway kann, wenn n&ouml;tig, IP-Adressen mit
	    NAT umschreiben.</para>
        </listitem>

        <listitem>
	  <para>Die IP-Adressen der internen Netzwerke
	    <emphasis>d&uuml;rfen nicht &uuml;berlappen</emphasis>.
	    Mit NAT lie&szlig;e sich diese Anforderung zwar umgehen, doch
	    w&auml;re die Konfiguration und Pflege des resultierenden
	    Netzwerks zu aufw&auml;ndig.</para>
        </listitem>
      </itemizedlist>

      <para>Wenn die zu verbindenden Netzwerke intern dieselben
	IP-Adressen benutzen (beispielsweise
	<hostid role="ipaddr">192.168.1.x</hostid>), m&uuml;ssen
	einem der Netzwerke neue IP-Adressen zugewiesen werden.</para>

      <para>Die Netzwerktopologie sieht wie folgt aus:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="security/ipsec-network" align="center">
	</imageobject>

	<textobject>
<literallayout class="monospaced">Netzwerk #1           [ Interne Rechner ]    Privates Netz, 192.168.1.2-254
                      [   Win9x/NT/2K   ]
                      [      UNIX       ]
                               |
                               |
                        .---[fxp1]---.      Private IP, 192.168.1.1
                        |   FreeBSD  |
                        `---[fxp0]---'      &Ouml;ffentliche IP, A.B.C.D
                               |
                               |
                      -=-=- Internet -=-=-
                               |
                               |
                        .---[fxp0]---.      &Ouml;ffentliche IP, W.X.Y.Z
                        |   FreeBSD  |
                        `---[fxp1]---'      Private IP, 192.168.2.1
                               |
                               |
Netzwerk #2           [ Interne Rechner ]
                      [   Win9x/NT/2K   ]    Privates Netz, 192.168.2.2-254
                      [      UNIX       ]</literallayout>
	</textobject>
      </mediaobject>

      <para>Beachten Sie die beiden &ouml;ffentlichen IP-Adressen.
	Im Folgenden werden sie durch Buchstaben (als Platzhalter)
	gekennzeichnet.  Setzen Sie hierf&uuml;r Ihre eigenen
	&ouml;ffentlichen IP-Adressen ein.  Beide Gateways
	besitzen die interne Adresse
	<hostid role="ipaddr">x.x.x.1</hostid> und beide
	Netzwerke besitzen unterschiedliche private IP-Adressen:
	<hostid role="ipaddr">192.168.1.x</hostid> und
	<hostid role="ipaddr">192.168.2.x</hostid>.  Die Default-Route
	aller internen Systeme ist jeweils die Gateway-Maschine
	(<hostid role="ipaddr">x.x.x.1</hostid>).</para>

      <para>Aus der Sicht der Systeme sollen jetzt beide
	Netzwerke wie &uuml;ber einen Router, der in diesem
	Fall etwas langsamer ist, verbunden werden.</para>

      <para>Auf dem Rechner <hostid role="ipaddr">192.168.1.20</hostid>
	soll also beispielsweise der folgende Befehl funktionieren:</para>

      <programlisting>ping 192.168.2.34</programlisting>

      <para>&windows;-Systeme sollen die Systeme auf dem anderen
	Netzwerk erkennen und Shares sollen funktionieren.  Alles
	soll genauso wie in lokalen Netzwerken funktionieren.</para>

      <para>Zus&auml;tzlich soll die Kommunikation zwischen beiden
	Netzwerken noch verschl&uuml;sselt werden.</para>

      <para>Das VPN wird in mehreren Schritten aufgebaut:</para>

      <orderedlist>
        <listitem>
	  <para>Zuerst wird eine virtuelle Verbindung zwischen
	    beiden Netzwerken &uuml;ber das Internet eingerichtet.
	    Die virtuelle Verbindung k&ouml;nnen Sie mit Werkzeugen
	    wie &man.ping.8; pr&uuml;fen.</para>
        </listitem>

        <listitem>
	  <para>Danach wird eine Sicherheitsrichtlinie
	    (<foreignphrase>Security-Policy</foreignphrase>) festgelegt,
	    die automatisch den Datenverkehr zwischen beiden
	    Netzwerken verschl&uuml;sselt und entschl&uuml;sselt.
	    Mit Werkzeugen wie &man.tcpdump.1; k&ouml;nnen Sie
	    &uuml;berpr&uuml;fen, dass die Daten tats&auml;chlich
	    verschl&uuml;sselt werden.</para>
        </listitem>

        <listitem>
	  <para>Wenn sich &windows;-Systeme im VPN gegenseitig
	    erkennen sollen, so sind noch weitere
	    Konfigurationsschritte notwendig, die aber nicht
	    in diesem Abschnitt beschrieben werden.</para>
        </listitem>
      </orderedlist>

      <sect3>
        <title>Schritt 1:  Die virtuelle Verbindung einrichten</title>

        <para>Nehmen wir an, sie wollten von der Gateway-Maschine
	  im Netzwerk&nbsp;#1 (&ouml;ffentliche IP-Adresse
	  <hostid role="ipaddr">A.B.C.D</hostid>, private IP-Adresse
	  <hostid role="ipaddr">192.168.1.1</hostid>) das Kommando
	  <command>ping 192.168.2.1</command> absetzen.
	  <hostid role="ipaddr">192.168.2.1</hostid> ist die private
	  IP-Adresse des Systems <hostid role="ipaddr">W.X.Y.Z</hostid>
	  im Netzwerk&nbsp;#2.  Welche Voraussetzungen m&uuml;ssen
	  erf&uuml;llt sein, damit der Befehl funktioniert?</para>

        <orderedlist>
          <listitem>
	    <para>Die Gateway-Maschine muss das System
	      <hostid role="ipaddr">192.168.2.1</hostid> erreichen
	      k&ouml;nnen.  Das hei&szlig;t, eine Route zu diesem
	      System muss existieren.</para>
          </listitem>

          <listitem>
	    <para>Private IP-Adressen, wie der Bereich
	      <hostid role="ipaddr">192.168.x</hostid>, sollten im
	      Internet nicht verwendet werden.  Jedes Paket zu
	      <hostid role="ipaddr">192.168.2.1</hostid> muss daher
	      in ein anderes Paket gepackt werden, das von
	      <hostid role="ipaddr">A.B.C.D</hostid> kommt und
	      zu <hostid role="ipaddr">W.X.Y.Z</hostid> geschickt
	      wird.  Das erneute Verpacken der Pakete wird als
	      <firstterm>Kapselung</firstterm> bezeichnet.</para>
          </listitem>

          <listitem>
	    <para>Wenn das Paket <hostid role="ipaddr">W.X.Y.Z</hostid>
	      erreicht, muss es dort ausgepackt und an
	      <hostid role="ipaddr">192.168.2.1</hostid> ausgeliefert
	      werden.</para>
          </listitem>
        </orderedlist>

        <para>Sie k&ouml;nnen sich diese Prozedur so vorstellen,
	  dass ein Tunnel zwischen beiden Netzwerken existiert.
	  Die beiden Tunnel-Enden besitzen die IP-Adressen
	  <hostid role="ipaddr">A.B.C.D</hostid> und
	  <hostid role="ipaddr">W.X.Y.Z</hostid>.  Der Tunnel
	  muss zudem Verkehr zwischen den privaten IP-Adressen
	  erlauben und transportiert so Daten zwischen privaten
	  IP-Adressen &uuml;ber das Internet.</para>

        <para>Unter &os; wird der Tunnel mit
          <devicename>gif</devicename>-Ger&auml;ten (<foreignphrase>generic
	    interface</foreignphrase>) erstellt.  Auf jedem Gateway
	  muss das <devicename>gif</devicename>-Ger&auml;t mit
	  vier IP-Adressen eingerichtet werden:  Zwei &ouml;ffentliche
	  IP-Adressen und zwei private IP-Adressen.</para>

        <para>Die <devicename>gif</devicename>-Ger&auml;te werden vom
	  Kernel bereitgestellt und m&uuml;ssen in der
	  Kernelkonfigurationsdatei auf beiden Maschinen angegeben
	  werden:</para>

        <programlisting>device gif</programlisting>

        <para>Wie gew&ouml;hnlich m&uuml;ssen Sie danach einen
	  neuen Kernel erstellen, installieren und das System
	  neu starten.</para>

        <para>Der Tunnel wird in zwei Schritten aufgebaut.  Mit
          &man.gifconfig.8; werden zuerst die &ouml;ffentlichen
	  IP-Adressen konfiguriert.  Anschlie&szlig;end werden
	  die privaten IP-Adressen mit &man.ifconfig.8; eingerichtet.</para>

	<note>
	  <para>In &os;&nbsp;5.X sind die Funktionen von
	    &man.gifconfig.8; in das Kommando &man.ifconfig.8;
	    integriert.</para>
	</note>

        <para>Auf der Gateway-Maschine im Netzwerk&nbsp;#1 bauen
	  Sie den Tunnel mit den folgenden Kommandos auf:</para>

        <programlisting>gifconfig gif0 A.B.C.D W.X.Y.Z
ifconfig gif0 inet 192.168.1.1 192.168.2.1 netmask 0xffffffff</programlisting>

        <para>Auf dem anderen Gateway benutzen Sie dieselben Kommandos,
	  allerdings mit vertauschten IP-Adressen:</para>

        <programlisting>gifconfig gif0 W.X.Y.Z A.B.C.D
ifconfig gif0 inet 192.168.2.1 192.168.1.1 netmask 0xffffffff</programlisting>

        <para>Die Konfiguration k&ouml;nnen Sie anschlie&szlig;end mit
	  dem folgenden Kommando &uuml;berpr&uuml;fen:</para>

        <programlisting>gifconfig gif0</programlisting>

        <para>Auf dem Gateway in Netzwerk&nbsp;#1 sollten Sie
	  beispielsweise die nachstehende Ausgabe erhalten:</para>

        <screen>&prompt.root; <userinput>gifconfig gif0</userinput>
gif0: flags=8011&lt;UP,POINTTOPOINT,MULTICAST&gt; mtu 1280
inet 192.168.1.1 --&gt; 192.168.2.1 netmask 0xffffffff
physical address inet A.B.C.D --&gt; W.X.Y.Z</screen>

        <para>Wie Sie sehen, ist ein Tunnel zwischen den IP-Adressen
	  <hostid role="ipaddr">A.B.C.D</hostid> und
	  <hostid role="ipaddr">W.X.Y.Z</hostid> aufgebaut worden,
	  der Verkehr zwischen den Adressen
	  <hostid role="ipaddr">192.168.1.1</hostid> und
	  <hostid role="ipaddr">192.168.2.1</hostid> zul&auml;sst.</para>

        <para>Gleichzeitig wurde ein Eintrag in der Routing-Tabelle
	  erstellt, den Sie sich mit <command>netstat -rn</command>
	  ansehen k&ouml;nnen.  Auf der Gateway-Maschine in Netzwerk&nbsp;#1
	  sieht das so aus:</para>

        <screen>&prompt.root; <userinput>netstat -rn</userinput>
Routing tables

Internet:
Destination      Gateway       Flags    Refs    Use    Netif  Expire
...
192.168.2.1      192.168.1.1   UH        0        0    gif0
...</screen>

        <para>Die Route ist eine Host-Route, wie in der Spalte
	  <quote>Flags</quote> angegeben.  Das hei&szlig;t
	  die beiden Gateways wissen wie sie einander erreichen,
	  sie kennen allerdings nicht das Netzwerk auf der
	  anderen Seite.  Dieses Problem werden wir gleich
	  angehen.</para>

        <para>Wahrscheinlich ist auf beiden Gateways eine Firewall
	  eingerichtet.  F&uuml;r den VPN-Verkehr muss die Firewall
	  umgegangen werden.  Sie k&ouml;nnen generell den Verkehr
	  zwischen beiden Netzwerken erlauben oder Regeln erstellen,
	  die beide Tunnel-Enden des VPNs voreinander sch&uuml;tzen.</para>

        <para>Der Test des VPNs wird erheblich leichter, wenn Sie
	  jeden Verkehr zwischen den Tunnel-Enden in der Firewall
	  erlauben.  Wenn Sie auf der Gateway-Maschine &man.ipfw.8;
	  einsetzen, erlaubt die folgende Regel jeden Verkehr
	  zwischen den Tunnel-Enden, ohne die anderen Regeln zu
	  beeinflussen:</para>

        <programlisting>ipfw add 1 allow ip from any to any via gif0</programlisting>

        <para>Diese Regel muss offensichtlich auf beiden Gateway-Maschinen
	  existieren.</para>

        <para>Damit sollten Sie das Kommando <command>ping</command>
	  jetzt absetzen k&ouml;nnen.  Auf dem System
	  <hostid role="ipaddr">192.168.1.1</hostid> sollte der
	  nachstehende Befehl Antworten erhalten:</para>

        <programlisting>ping 192.168.2.1</programlisting>

        <para>Denselben Test k&ouml;nnen Sie auch auf der anderen
	  Gateway-Maschine ausf&uuml;hren.</para>

        <para>Allerdings k&ouml;nnen Sie noch nicht die anderen
	  internen Maschinen auf den Netzwerken erreichen.  Die Ursache
	  ist das Routing &ndash; die Gateway kennen sich zwar
	  gegenseitig, wissen aber noch nichts von den Netzwerken
	  hinter dem anderen Gateway.</para>

        <para>Um die Netzwerke bekannt zu geben, muss auf jeder
	  Gateway-Maschine noch eine statische Route hinzugef&uuml;gt
	  werden.  Auf der ersten Gateway-Maschine setzen Sie dazu
	  das folgende Kommando ab:</para>

        <programlisting>route add 192.168.2.0 192.168.2.1 netmask 0xffffff00</programlisting>

        <para>Dies entspricht der Anweisung:  <quote>Um Rechner
	  auf dem Netz <hostid role="ipaddr">192.168.2.0</hostid>
	  zu erreichen, schicke die Pakete zumSystem
	  <hostid role="ipaddr">192.168.2.1</hostid></quote>.  Auf
	  dem anderen Gateway muss das analoge Kommando (mit den
	  IP-Adressen <hostid role="ipaddr">192.168.1.x</hostid>)
	  abgesetzt werden.</para>

        <para>Damit ist jetzt der IP-Verkehr zwischen beiden
	  Netzwerken m&ouml;glich.</para>

        <para>Zwei Drittel des VPNs zwischen beiden Netzen
	  ist nun eingerichtet.  Es ist <quote>virtuell</quote> und
	  es ist ein <quote>Netzwerk</quote>.  Es ist allerdings
	  noch nicht <quote>privat</quote>.  Dies k&ouml;nnen Sie
	  mit &man.ping.8; und &man.tcpdump.1; &uuml;berpr&uuml;fen.
	  Setzen Sie auf dem ersten Gateway den folgenden Befehl ab:</para>

        <programlisting>tcpdump dst host 192.168.2.1</programlisting>

        <para>Starten Sie dann, ebenfalls auf dem ersten Gateway, den
	  folgenden Befehl:</para>

        <programlisting>ping 192.168.2.1</programlisting>

        <para>Sie werden die nachstehende Ausgabe erhalten:</para>

        <programlisting>16:10:24.018080 192.168.1.1 &gt; 192.168.2.1: icmp: echo request
16:10:24.018109 192.168.1.1 &gt; 192.168.2.1: icmp: echo reply
16:10:25.018814 192.168.1.1 &gt; 192.168.2.1: icmp: echo request
16:10:25.018847 192.168.1.1 &gt; 192.168.2.1: icmp: echo reply
16:10:26.028896 192.168.1.1 &gt; 192.168.2.1: icmp: echo request
16:10:26.029112 192.168.1.1 &gt; 192.168.2.1: icmp: echo reply</programlisting>

        <para>Die ICMP-Nachrichten werden unverschl&uuml;sselt
	  &uuml;bertragen.  Mit der Option <option>-s</option>
	  von &man.tcpdump.1; k&ouml;nnen Sie sich weitere Daten
	  der Pakete anzeigen lassen.</para>

        <para>Die Daten sollen aber automatisch verschl&uuml;sselt
          werden.  Wie das geht, wird im n&auml;chsten Abschnitt
	  erl&auml;utert.</para>

        <itemizedlist>
          <title>Zusammenfassung</title>
          <listitem>
	    <para>Richten sie in beiden Kerneln das
	      <devicename>gif</devicename>-Ger&auml;t ein.</para>
          </listitem>

          <listitem>
	    <para>F&uuml;gen Sie auf dem Gateway in Netzwerk&nbsp;#1
	      folgende Zeilen in <filename>/etc/rc.conf</filename>
	      ein:</para>

            <programlisting>gifconfig_gif0="A.B.C.D W.X.Y.Z"
ifconfig_gif0="inet 192.168.1.1 192.168.2.1 netmask 0xffffffff"
static_routes="vpn"
route_vpn="192.168.2.0 192.168.2.1 netmask 0xffffff00"</programlisting>

	    <para>Setzen Sie dabei die richtigen IP-Adressen f&uuml;r
	      die Platzhalter ein.</para>
          </listitem>

          <listitem>
	    <para>F&uuml;gen Sie auf beiden Gateways die nachstehende
	      Regel in das Firewall-Skript (zum Beispiel
	      <filename>/etc/rc.firewall</filename>) ein:</para>

            <programlisting>ipfw add 1 allow ip from any to any via gif0</programlisting>
          </listitem>

          <listitem>
	    <para>Nehmen Sie in <filename>/etc/rc.conf</filename> auf dem
	      Gateway&nbsp;#2 analoge &Auml;nderungen, die IP-Adressen
	      m&uuml;ssen vertauscht werden, vor.</para>
          </listitem>
        </itemizedlist>
      </sect3>

      <sect3>
        <title>Schritt 2: Die Verbindung mit IPsec sch&uuml;tzen</title>

        <para>Um die Verbindung zu sch&uuml;tzen, verwenden wir IPsec.
	  IPsec bietet einen Mechanismus, mit dem sich zwei
	  Systeme auf einen Schl&uuml;ssel einigen k&ouml;nnen.
	  Mit diesem Schl&uuml;ssel wird dann der Datenverkehr zwischen
	  beiden Systemen verschl&uuml;sselt.</para>

        <para>Es gibt hierbei zwei Sachen die konfiguriert werden
	  m&uuml;ssen:</para>

        <orderedlist>
          <listitem>
	    <para>Die <firstterm>Security-Association</firstterm> bestimmt,
	      mit welchen Methoden der Verkehr zwischen beiden Systemen
	      verschl&uuml;sselt wird.</para>
          </listitem>

          <listitem>
	    <para>Die <firstterm>Security-Policy</firstterm> bestimmt,
	      was verschl&uuml;sselt wird.  Es soll ja nicht der
	      gesamte Datenverkehr nach au&szlig;en verschl&uuml;sselt
	      werden, sondern nur der Teil des Verkehrs, der zum
	      VPN geh&ouml;rt.</para>
           </listitem>
         </orderedlist>

         <para>Die Security-Association wie auch die Security-Policy
	   werden vom Kernel verwaltet und k&ouml;nnen von Anwendungen
	   ver&auml;ndert werden.  Dazu m&uuml;ssen allerdings zuerst
	   IPsec und das Encapsulated-Security-Payload (ESP) Protokoll
	   in die Kernelkonfigurationsdatei eingetragen werden:</para>

	 <indexterm>
	   <primary>Kerneloption</primary>
	   <secondary>IPSEC</secondary>
	 </indexterm>

         <programlisting>options IPSEC
options IPSEC_ESP</programlisting>

         <para>Wie &uuml;blich, m&uuml;ssen Sie danach den Kernel
	   &uuml;bersetzen, installieren und das System neu starten.
	   Die Kernel m&uuml;ssen auf beiden Gateway-Maschinen
	   neu erstellt werden.</para>

	 <indexterm>
	   <primary>IKE</primary>
	 </indexterm>

	 <para>Sie k&ouml;nnen die Security-Association auf zwei
	   Arten konfigurieren:  Manuell, dann m&uuml;ssen Sie
	   den Verschl&uuml;sselungsalgorithmus, die Schl&uuml;ssel
	   und alles Weitere selbst konfigurieren.  Oder automatisch,
	   mithilfe eines D&aelig;mons, der das Internet-Key-Exchange
	   Protokoll (IKE) beherrscht.</para>

         <para>Im Allgemeinen wird die letzte Variante bevorzugt.
	   Sie ist auch wesentlich leichter einzurichten.</para>

	 <indexterm>
	   <primary>IPsec</primary>
	   <secondary>Security-Policy</secondary>
	 </indexterm>

	 <indexterm>
	   <primary><command>setkey</command></primary>
	 </indexterm>

         <para>Mit &man.setkey.8; k&ouml;nnen Sie Security-Policies
	   editieren und anzeigen.  Die Beziehung von
	   <command>setkey</command> und der Tabelle der
	   Security-Policies im Kernel entspricht
	   dem Verh&auml;ltnis von &man.route.8; und der Routing-Tabelle.
	   Die momentanen Security-Associations lassen sich ebenfalls
	   mit <command>setkey</command> anzeigen;
	   <command>setkey</command> verh&auml;lt sich in diesem Fall
	   wie <command>netstat -r</command>, um die Analogie
	   fortzuf&uuml;hren.</para>

         <para>Sie haben die Wahl zwischen mehreren Programmen,
	   wenn Sie Security-Associations mit &os; verwalten
	   wollen.  Im Folgenden wird <application>racoon</application>
	   beschrieben.  racoon l&auml;sst sich in gewohnter
	   Weise aus der Ports-Sammlung installieren.  Sie finden
	   das Programm unter
	   <filename role="package">security/racoon</filename>.</para>

	 <indexterm>
	   <primary>racoon</primary>
	 </indexterm>

	 <para>Auf beiden Gateway-Maschinen muss
	   <filename role="package">security/racoon</filename> laufen.
	   Konfiguriert wird jeweils die IP-Adresse der Gegenstelle
	   sowie der geheime Schl&uuml;ssel.  Dabei muss auf beiden
	   Gateway-Maschinen der gleiche Schl&uuml;ssel verwendet
	   werden.</para>

         <para>Die beiden raccon-Daemonen pr&uuml;fen mithilfe des
	   geheimen Schl&uuml;ssels gegenseitig ihre Identit&auml;t.
	   Anschlie&szlig;end generieren Sie einen neuen geheimen
	   Schl&uuml;ssel, mit dem dann der Datenverkehr im VPN
	   verschl&uuml;sselt wird.  Dieser Schl&uuml;ssel wird
	   von Zeit zu Zeit ge&auml;ndert.  Ein Angreifer,
	   der einen der Schl&uuml;ssel geknackt hat &ndash; das ist
	   schon ziemlich unwahrscheinlich &ndash; kann somit nicht
	   viel mit diesem Schl&uuml;ssel anfangen, da schon wieder ein
	   anderer Schl&uuml;ssel verwendet wird.</para>

         <para>Die Konfiguration von racoon befindet sich in
	   <filename>${PREFIX}/etc/racoon</filename>.  In der
	   dort befindlichen Konfigurationsdatei sollten Sie nicht
	   allzu viele &Auml;nderungen vornehmen m&uuml;ssen.
	   Sie m&uuml;ssen allerdings den so genannten
	   <quote>Pre-Shared-Key</quote> (den vorher ausgetauschten
	   Schl&uuml;ssel) &auml;ndern.</para>

         <para>In der Voreinstellung befindet sich dieser Schl&uuml;ssel
	   in der Datei <filename>${PREFIX}/etc/racoon/psk.txt</filename>.
	   Dieser Schl&uuml;ssel wird <emphasis>nicht</emphasis> zum
	   Verschl&uuml;sseln des Datenverkehrs verwendet.  Er dient
	   lediglich der Authentifizierung der beiden racoon-Daemonen.</para>

         <para>F&uuml;r jeden entfernten Kommunikationspartner enth&auml;lt
	   <filename>psk.txt</filename> eine Zeile.  Damit besteht die
	   Datei <filename>psk.txt</filename> in unserem Beispiel
	   aus einer Zeile (wir verwenden einen entfernten
	   Kommunikationspartner).</para>

         <para>Auf dem Gateway&nbsp;#1 sieht diese Zeile wie
	   folgt aus:</para>

         <programlisting>W.X.Y.Z            geheim</programlisting>

         <para>Die Zeile besteht aus der &ouml;ffentlichen IP-Adresse
	   der Gegenstelle, Leerzeichen und dem geheimen Schl&uuml;ssel.
	   Sie sollten nat&uuml;rlich nicht <literal>geheim</literal>
	   verwenden.  F&uuml;r den geheimen Schl&uuml;ssel gelten
	   dieselben Regeln wie f&uuml;r Passw&ouml;rter.</para>

         <para>Auf dem anderen Gateway sieht die Zeile
	   folgenderma&szlig;en aus:</para>

         <programlisting>A.B.C.D            geheim</programlisting>

         <para>Die Zeile besteht aus der &ouml;ffentlichen IP-Adresse
	   der Gegenstelle, Leerzeichen und dem geheimen Schl&uuml;ssel.
	   Die Zugriffsrechte von <filename>psk.txt</filename> m&uuml;ssen
	   auf <literal>0600</literal> (Lese- und Schreibzugriff nur
	   f&uuml;r <username>root</username>) gesetzt sein, bevor
	   racoon gestartet wird.</para>

         <para>Auf beiden Gateway-Maschinen muss racoon laufen.  Sie
	   brauchen ebenfalls Firewall-Regeln, die IKE-Verkehr
	   erlauben.  IKE verwendet UDP, um Nachrichten zum
	   ISAKMP-Port (Internet Security Association Key Management Protocol)
	   zu schicken.  Die Regeln sollten fr&uuml;h in der
	   Regelkette auftauchen:</para>

         <programlisting>ipfw add 1 allow udp from A.B.C.D to W.X.Y.Z isakmp
ipfw add 1 allow udp from W.X.Y.Z to A.B.C.D isakmp</programlisting>

         <para>Wenn racoon l&auml;uft, k&ouml;nnen Sie versuchen,
	   mit <command>ping</command> von einem Gateway-Rechner aus
	   den anderen Gateway zu erreichen.  Die Verbindung wird zwar immer
	   noch nicht verschl&uuml;sselt, aber racoon wird die
	   Security-Association zwischen beiden Systemen einrichten.
	   Dies kann eine Weile dauern, und Sie bemerken vielleicht
	   eine kleine Verz&ouml;gerung, bevor die Antworten von
	   der Gegenstelle kommen.</para>

         <para>Die Security-Association k&ouml;nnen Sie sich auf einem
	   der beiden Gateway-Systeme mit &man.setkey.8; ansehen:</para>

         <programlisting>setkey -D</programlisting>

         <para>Damit ist die erste H&auml;lfte der Arbeit getan.
	   Jetzt muss noch die Security-Policy konfiguriert werden.</para>

         <para>Damit wir eine sinnvolle Security-Policy erstellen
	   k&ouml;nnen, fassen wir das bisher geleistete zusammen.
	   Die Diskussion gilt f&uuml;r beide Enden des Tunnels.</para>

         <para>Jedes gesendete IP-Paket enth&auml;lt im Header
	   Informationen &uuml;ber das Paket selbst.  Im Header
	   befinden sich die IP-Adressen des Senders und des
	   Empf&auml;ngers.  Wie wir bereits wissen, d&uuml;rfen
	   private IP-Adressen, wie
	   <hostid role="ipaddr">192.168.x.y</hostid> nicht auf
	   das Internet gelangen.  Pakete zu privaten IP-Adressen
	   m&uuml;ssen zuerst in einem anderen Paket gekapselt
	   werden.  In diesem Paket werden die privaten IP-Adressen
	   durch &ouml;ffentliche IP-Adressen ersetzt.</para>

         <para>Das ausgehende Paket hat beispielsweise wie folgt
	   ausgesehen:</para>

	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="security/ipsec-out-pkt" align="center">
	    </imageobject>

	    <textobject>
	      <literallayout class="monospaced">
  .----------------------.
  | Src: 192.168.1.1     |
  | Dst: 192.168.2.1     |
  | &lt;other header info&gt;  |
  +----------------------+
  | &lt;packet data&gt;        |
  `----------------------'</literallayout>
	    </textobject>
	  </mediaobject>

         <para>Es wird in ein anderes Paket umgepackt (gekapselt)
	   und sieht danach wie folgt aus:</para>

	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="security/ipsec-encap-pkt" align="center">
	    </imageobject>

	    <textobject>
	      <literallayout class="monospaced">
  .--------------------------.
  | Src: A.B.C.D             |
  | Dst: W.X.Y.Z             |
  | &lt;other header info&gt;      |
  +--------------------------+
  | .----------------------. |
  | | Src: 192.168.1.1     | |
  | | Dst: 192.168.2.1     | |
  | | &lt;other header info&gt;  | |
  | +----------------------+ |
  | | &lt;packet data&gt;        | |
  | `----------------------' |
  `--------------------------'</literallayout>
	    </textobject>
	  </mediaobject>

         <para>Die Kapselung wird vom <devicename>gif</devicename>-Ger&auml;t
	   vorgenommen.  Das neue Paket enth&auml;lt im Header eine
	   &ouml;ffentliche IP-Adresse und der Datenteil des Pakets
	   enth&auml;lt das urspr&uuml;ngliche Paket.</para>

         <para>Nat&uuml;rlich soll der gesamte Datenverkehr des VPNs
	   verschl&uuml;sselt werden.  Dies kann man wie folgt
	   ausdr&uuml;cken:</para>

         <para>
	   <quote>Wenn ein Paket von <hostid role="ipaddr">A.B.C.D</hostid>
	     zu <hostid role="ipaddr">W.X.Y.Z</hostid> geschickt wird,
	     verschl&uuml;ssele es entsprechend der
	     Security-Association.</quote>
         </para>

         <para>
	   <quote>Wenn ein Paket von <hostid role="ipaddr">W.X.Y.Z</hostid>
	     kommt und f&uuml;r <hostid role="ipaddr">A.B.C.D</hostid>
	     bestimmt ist, entschl&uuml;ssele es entsprechend der
	     Security-Association.</quote>
         </para>

         <para>Das ist fast richtig.  Mit diesen Regeln w&uuml;rde
	   der ganze Verkehr von und zu <hostid role="ipaddr">W.X.Y.Z</hostid>
	   verschl&uuml;sselt, auch wenn er nicht zum VPN geh&ouml;rt.
	   Die richtige Formulierung lautet:</para>

         <para>
	   <quote>Wenn ein Paket, das ein gekapseltes Paket enth&auml;lt,
	     von <hostid role="ipaddr">A.B.C.D</hostid> zu
	     <hostid role="ipaddr">W.X.Y.Z</hostid> geschickt wird,
	     verschl&uuml;ssele es entsprechend der
	     Security-Association.</quote>
         </para>

         <para>
	   <quote>Wenn ein Paket, das ein gekapseltes Paket enth&auml;lt,
	     von <hostid role="ipaddr">W.X.Y.Z</hostid> kommt und f&uuml;r
	     <hostid role="ipaddr">A.B.C.D</hostid> bestimmt ist,
	     entschl&uuml;ssele es entsprechend der
	     Security-Association.</quote>
         </para>

         <para>Dies ist eine zwar subtile aber eine
	   notwendige &Auml;nderung.</para>

         <para>Die Security-Policy k&ouml;nnen Sie mit &man.setkey.8;
	   erstellen.  &man.setkey.8; besitzt eine Konfigurations-Syntax
	   zur Erstellung der Security-Policy.  Sie k&ouml;nnen die
	   Konfiguration &uuml;ber die Standardeingabe oder in einer
	   Datei, die Sie mit der Option <option>-f</option> angeben,
	   erstellen.</para>

         <para>Gateway&nbsp;#1 (&ouml;ffentliche IP-Adresse:
	   <hostid role="ipaddr">A.B.C.D</hostid>) muss
	   folgenderma&szlig;en konfiguriert werden, um alle
	   ausgehenden Pakete an <hostid role="ipaddr">W.X.Y.Z</hostid>
	   zu verschl&uuml;sseln:</para>

         <programlisting>spdadd A.B.C.D/32 W.X.Y.Z/32 ipencap -P out ipsec esp/tunnel/A.B.C.D-W.X.Y.Z/require;</programlisting>

         <para>Speichern Sie dieses Kommando in einer Datei, beispielsweise
	   <filename>/etc/ipsec.conf</filename> ab.  Rufen Sie
	   anschlie&szlig;end das nachstehende Kommando auf:</para>

         <screen>&prompt.root; <userinput>setkey -f /etc/ipsec.conf</userinput></screen>

         <para><option>spdadd</option> weist &man.setkey.8; an,
	   der Security-Policy-Datenbank eine Regel hinzuzuf&uuml;gen.
	   Der Rest der Zeile gibt an, auf welche Pakete diese
	   Regel zutrifft.  <hostid role="ipaddr">A.B.C.D/32</hostid>
	   und <hostid role="ipaddr">W.X.Y.Z/32</hostid> sind
	   die IP-Adressen und Netzmasken, die Systeme angeben,
	   auf die diese Regel zutrifft.  Im Beispiel gilt die
	   Regel f&uuml;r die beiden Gateway-Systeme.
	   <option>ipencap</option> zeigt an, dass die Regel nur
	   f&uuml;r Pakete gilt, die gekapselte Pakete enthalten.
	   <option>-P out</option> legt fest, dass die Regel nur
	   f&uuml;r ausgehende Pakete gilt.</para>

         <para><option>ipsec</option> gibt an, dass die Pakete
           gesch&uuml;tzt werden.  Das benutzte Protokoll
	   wird durch <option>esp</option> angegeben.
	   <option>tunnel</option> kapselt das Paket in ein
	   IPsec-Paket.  Die nochmalige Angabe von
	   <hostid role="ipaddr">A.B.C.D</hostid> und
	   <hostid role="ipaddr">W.X.Y.Z</hostid> gibt die
	   Security-Association an.  Das abschlie&szlig;ende
	   <option>require</option> erzwingt die Verschl&uuml;sselung
	   der Pakete.</para>

         <para>Diese Regel gilt nur f&uuml;r ausgehende Pakete.
	   Sie brauchen eine analoge Regel f&uuml;r eingehende
	   Pakete:</para>

         <programlisting>spdadd W.X.Y.Z/32 A.B.C.D/32 ipencap -P in ipsec esp/tunnel/W.X.Y.Z-A.B.C.D/require;</programlisting>

         <para>In dieser Regel wird <option>in</option> anstelle
	   von <option>out</option> benutzt und die IP-Adressen
	   sind notwendigerweise umgekehrt angegeben.</para>

         <para>Das zweite Gateway-System mit der IP-Adresse
	   <hostid role="ipaddr">W.X.Y.Z</hostid> braucht
	   entsprechende Regeln:</para>

         <programlisting>spdadd W.X.Y.Z/32 A.B.C.D/32 ipencap -P out ipsec esp/tunnel/W.X.Y.Z-A.B.C.D/require;
spdadd A.B.C.D/32 W.X.Y.Z/32 ipencap -P in ipsec esp/tunnel/A.B.C.D-W.X.Y.Z/require;</programlisting>

         <para>Schlie&szlig;lich brauchen Sie auf beiden Gateway-Systemen
	   noch Firewall-Regeln, die ESP- und IPENCAP-Pakete in beide
	   Richtungen erlauben:</para>

         <programlisting>ipfw add 1 allow esp from A.B.C.D to W.X.Y.Z
ipfw add 1 allow esp from W.X.Y.Z to A.B.C.D
ipfw add 1 allow ipencap from A.B.C.D to W.X.Y.Z
ipfw add 1 allow ipencap from W.X.Y.Z to A.B.C.D</programlisting>

         <para>Da die Regeln symmetrisch sind, k&ouml;nnen sie auf
	   beiden Systemen verwendet werden.</para>

         <para>Damit sehen ausgehende Pakete wie folgt aus:</para>

	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="security/ipsec-crypt-pkt" align="center">
	    </imageobject>

	    <textobject>
	      <literallayout class="monospaced">
  .------------------------------.  --------------------------.
  | Src: A.B.C.D                 |                            |
  | Dst: W.X.Y.Z                 |                            |
  | &lt; weitere Header  &gt;          |                            |  Encrypted
  +------------------------------+                            |  packet.
  | .--------------------------. |  -------------.            |  contents
  | | Src: A.B.C.D             | |               |            |  are
  | | Dst: W.X.Y.Z             | |               |            |  completely
  | | &lt; weitere Header  &gt;      | |               |            |- secure
  | +--------------------------+ |               |  Encap'd   |  from third
  | | .----------------------. | |  -.           |  packet    |  party
  | | | Src: 192.168.1.1     | | |   |  Original |- with real |  snooping
  | | | Dst: 192.168.2.1     | | |   |  packet,  |  IP addr   |
  | | | &lt; weitere Header  &gt;  | | |   |- private  |            |
  | | +----------------------+ | |   |  IP addr  |            |
  | | | &lt;Paket-Daten&gt;        | | |   |           |            |
  | | `----------------------' | |  -'           |            |
  | `--------------------------' |  -------------'            |
  `------------------------------'  --------------------------'
	      </literallayout>
	    </textobject>
	  </mediaobject>

         <para>Am anderen Ende des VPNs werden die Pakete zuerst
	   entsprechend der von racoon ausgehandelten Security-Association
	   entschl&uuml;sselt.  Das <devicename>gif</devicename>-Interface
	   entfernt dann die zweite Schicht, damit das urspr&uuml;ngliche
	   Paket zum Vorschein kommt.  Dieses kann dann in das interne
	   Netzwerk transportiert werden.</para>

         <para>Dass die Pakete wirklich verschl&uuml;sselt werden,
	   k&ouml;nnen Sie wieder mit &man.ping.8; &uuml;berpr&uuml;fen.
	   Melden Sie sich auf dem Gateway
	   <hostid role="ipaddr">A.B.C.D</hostid> an und rufen
	   das folgende Kommando auf:</para>

         <programlisting>tcpdump dst host 192.168.2.1</programlisting>

         <para>Auf demselben Rechner setzen Sie dann noch das
	   nachstehende Kommando ab:</para>

         <programlisting>ping 192.168.2.1</programlisting>

         <para>Dieses Mal wird die Ausgabe wie folgt aussehen:</para>

         <programlisting>XXX tcpdump output</programlisting>

         <para>Jetzt zeigt &man.tcpdump.1; ESP-Pakete an.  Auch wenn
	   Sie diese mit der Option <option>-s</option> untersuchen,
	   werden Sie wegen der Verschl&uuml;sselung nur
	   unverst&auml;ndliche Zeichen sehen.</para>

        <para>Herzlichen Gl&uuml;ckwunsch.  Sie haben soeben ein
	  VPN zwischen zwei entfernten Netzen eingerichtet.</para>

        <itemizedlist>
          <title>Zusammenfassung</title>
          <listitem>
	    <para>IPsec muss in beiden Kernelkonfigurationsdateien
	      enthalten sein:</para>

            <programlisting>options IPSEC
options IPSEC_ESP</programlisting>
          </listitem>

          <listitem>
	    <para>Installieren Sie <filename
	        role="package">security/racoon</filename>.  Tragen Sie
	      auf beiden Rechnern in
	      <filename>${PREFIX}/etc/racoon/psk.txt</filename> jeweils
	      die IP-Adresse des entfernten Gateways und den geheimen
	      Schl&uuml;ssel ein.  Setzen Sie die Zugriffsrechte der
	      Datei auf <literal>0600</literal>.</para>
          </listitem>

          <listitem>
	    <para>F&uuml;gen Sie auf jedem Rechner die folgenden
	      Zeilen zu <filename>/etc/rc.conf</filename> hinzu:</para>

            <programlisting>ipsec_enable="YES"
ipsec_file="/etc/ipsec.conf"</programlisting>
          </listitem>

          <listitem>
	    <para>Erstellen Sie auf jedem Rechner die Datei
	      <filename>/etc/ipsec.conf</filename> mit den n&ouml;tigen
	      <option>spadd</option>-Zeilen.  Auf dem Gateway&nbsp;#1
	      hat die Datei folgenden Inhalt:</para>

            <programlisting>spdadd A.B.C.D/32 W.X.Y.Z/32 ipencap -P out ipsec
  esp/tunnel/A.B.C.D-W.X.Y.Z/require;
spdadd W.X.Y.Z/32 A.B.C.D/32 ipencap -P in ipsec
  esp/tunnel/W.X.Y.Z-A.B.C.D/require;</programlisting>

	    <para>Auf dem Gateway&nbsp;#2 sieht die Datei so aus:</para>

            <programlisting>spdadd W.X.Y.Z/32 A.B.C.D/32 ipencap -P out ipsec
  esp/tunnel/W.X.Y.Z-A.B.C.D/require;
spdadd A.B.C.D/32 W.X.Y.Z/32 ipencap -P in ipsec
  esp/tunnel/A.B.C.D-W.X.Y.Z/require;</programlisting>
          </listitem>

          <listitem>
	    <para>F&uuml;gen Sie auf beiden Rechnern Firewall-Regeln
	      hinzu, die IKE-, ESP- und IPENCAP-Verkehr erlauben:</para>

            <programlisting>ipfw add 1 allow udp from A.B.C.D to W.X.Y.Z isakmp
ipfw add 1 allow udp from W.X.Y.Z to A.B.C.D isakmp
ipfw add 1 allow esp from A.B.C.D to W.X.Y.Z
ipfw add 1 allow esp from W.X.Y.Z to A.B.C.D
ipfw add 1 allow ipencap from A.B.C.D to W.X.Y.Z
ipfw add 1 allow ipencap from W.X.Y.Z to A.B.C.D</programlisting>
          </listitem>
        </itemizedlist>

        <para>Das VPN wurde in zwei Schritten eingerichtet.  Maschinen
	  auf beiden Netzen k&ouml;nnen miteinander kommunizieren
	  und der Datenverkehr zwischen beiden Netzen wird automatisch
	  verschl&uuml;sselt.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="openssh">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Chern</firstname>
	  <surname>Lee</surname>
	  <contrib>Beigetragen von </contrib>
	</author>
	<!-- 21 April 2001 -->
      </authorgroup>
    </sect1info>

    <title>OpenSSH</title>
    <indexterm><primary>OpenSSH</primary></indexterm>
    <indexterm>
      <primary>Sicherheit</primary>
      <secondary>OpenSSH</secondary>
    </indexterm>

    <para><application>OpenSSH</application> stellt Werkzeuge bereit,
      um sicher auf entfernte
      Maschinen zuzugreifen.  Die Kommandos <command>rlogin</command>,
      <command>rsh</command>, <command>rcp</command> und
      <command>telnet</command> k&ouml;nnen durch
      <application>OpenSSH</application> ersetzt werden.
      Zus&auml;tzlich k&ouml;nnen andere TCP/IP-Verbindungen sicher durch
      SSH weitergeleitet (getunnelt) werden.  Mit SSH werden alle
      Verbindungen verschl&uuml;sselt, dadurch wird verhindert, dass
      die Verbindung zum Beispiel abgeh&ouml;rt oder &uuml;bernommen
      (<foreignphrase>Hijacking</foreignphrase>) werden kann.</para>

    <para><application>OpenSSH</application> wird vom OpenBSD-Projekt
      gepflegt und basiert auf SSH&nbsp;v1.2.12 mit allen aktuellen
      Fixen und Aktualisierungen.  <application>OpenSSH</application>
      ist mit den SSH-Protokollen der Versionen 1 und 2 kompatibel.  Seit
      &os;&nbsp;4.0 ist die <application>OpenSSH</application> Teil
      des Basissystems.</para>

    <sect2>
      <title>Vorteile von OpenSSH</title>

      <para>Mit &man.telnet.1; oder &man.rlogin.1; werden Daten in
	einer unverschl&uuml;sselten Form &uuml;ber das Netzwerk
	gesendet.  Daher besteht die Gefahr, das Benutzer/Passwort
	Kombinationen oder alle Daten an beliebiger Stelle zwischen
	dem Client und dem Server abgeh&ouml;rt werden.  Mit
	<application>OpenSSH</application> stehen eine Reihe von
	Authentifizierungs- und Verschl&uuml;sselungsmethoden zur
	Verf&uuml;gung, um das zu verhindern.</para>
    </sect2>

    <sect2>
      <title>Aktivieren von sshd</title>
      <indexterm>
        <primary>OpenSSH</primary>
        <secondary>aktivieren</secondary>
      </indexterm>

      <para>Unter &os;&nbsp;4.X ist der
        <application>sshd</application>-Daemon bereits in der
        Voreinstellung aktiviert.  Unter &os;&nbsp;5.X hat der Anwender
        die Wahl, ob der Daemon aktiviert werden soll oder nicht.
        Um zu &uuml;berpr&uuml;fen, ob der Daemon bei Ihnen
        aktiviert ist, suchen Sie in <filename>rc.conf</filename>
        nach der folgenden Zeile:</para>

      <screen>sshd_enable="YES"</screen>

      <para>Dadurch wird &man.sshd.8;, der D&aelig;mon von
	<application>OpenSSH</application> beim n&auml;chsten Neustart
        geladen.  Alternativ k&ouml;nnen Sie den D&aelig;mon auch
	direkt starten, indem Sie auf der Kommandozeile das Kommando
	<command>sshd</command> absetzen.</para>
    </sect2>

    <sect2>
      <title>SSH Client</title>
      <indexterm>
        <primary>OpenSSH</primary>
        <secondary>Client</secondary>
      </indexterm>

      <para>&man.ssh.1; arbeitet &auml;hnlich wie &man.rlogin.1;:</para>

      <screen>&prompt.root; <userinput>ssh <replaceable>user@example.com</replaceable></userinput>
Host key not found from the list of known hosts.
Are you sure you want to continue connecting (yes/no)? <userinput>yes</userinput>
Host 'example.com' added to the list of known hosts.
user@example.com's password: <userinput>*******</userinput></screen>

      <para>Der Anmeldevorgang wird danach, wie von
        <command>rlogin</command> oder <command>telnet</command> gewohnt,
	weiterlaufen.  SSH speichert einen Fingerabdruck des
	Serverschl&uuml;ssels.  Die Aufforderung, <literal>yes</literal>
	einzugeben, erscheint nur bei der ersten Verbindung zu einem
	Server.  Weitere Verbindungen zu dem Server werden gegen den
	gespeicherten Fingerabdruck des Schl&uuml;ssels gepr&uuml;ft und
	der Client gibt eine Warnung aus, wenn sich der empfangene
	Fingerabdruck von dem gespeicherten unterscheidet.  Die
	Fingerabdr&uuml;cke der Version 1 werden in
	<filename>~/.ssh/known_hosts</filename>, die der Version 2 in
	<filename>~/.ssh/known_hosts2</filename>  gespeichert.</para>

      <para>In der Voreinstellung akzeptieren aktuelle
	<application>OpenSSH</application>-Server nur SSH&nbsp;v2
	Verbindungen.  Wenn m&ouml;glich, wird Version&nbsp;2 verwendet,
	ist dies nicht m&ouml;glich, f&auml;llt der Server auf
	Version&nbsp;1 zur&uuml;ck.  Der Client kann gezwungen werden,
	nur eine der beiden Versionen zu verwenden, indem die Option
	<option>-1</option> (f&uuml;r die Version&nbsp;1) oder
	<option>-2</option> (f&uuml;r die Version&nbsp;2) &uuml;bergeben
	wird.  Die Unterst&uuml;tzung f&uuml;r Version&nbsp;1 ist nur
	noch aus Kompatibilit&auml;tsgr&uuml;nden zu &auml;lteren
	Versionen enthalten.</para>
    </sect2>

    <sect2>
      <title>Secure Copy</title>
      <indexterm>
        <primary>OpenSSH</primary>
        <secondary>secure copy</secondary>
      </indexterm>
      <indexterm><primary><command>scp</command></primary></indexterm>

      <para>Mit  &man.scp.1; lassen sich Dateien analog wie mit
        &man.rcp.1; auf entfernte Maschinen kopieren.  Mit
	<command>scp</command> werden die Dateien allerdings in einer
	sicheren Weise &uuml;bertragen.</para>

      <screen>&prompt.root; <userinput> scp <replaceable>user@example.com:/COPYRIGHT COPYRIGHT</replaceable></userinput>
user@example.com's password:
COPYRIGHT            100% |*****************************|  4735
00:00
&prompt.root;</screen>

      <para>Da der Fingerabdruck schon im vorigen Beispiel abgespeichert
        wurde, wird er bei der Verwendung von <command>scp</command> in
	diesem Beispiel &uuml;berpr&uuml;ft.  Da die Fingerabdr&uuml;cke
	&uuml;bereinstimmen, wird keine Warnung ausgegeben.</para>

      <para>Die Argumente, die <command>scp</command> &uuml;bergeben
        werden, gleichen denen von <command>cp</command> in der Beziehung,
	dass die ersten Argumente die zu kopierenden Dateien sind und
	das letzte Argument den Bestimmungsort angibt.  Da die Dateien
	&uuml;ber das Netzwerk kopiert werden, k&ouml;nnen ein oder mehrere
	Argumente die Form
	<option>user@host:&lt;path_to_remote_file></option>
	besitzen.</para>
    </sect2>

    <sect2>
      <title>Konfiguration</title>
      <indexterm>
        <primary>OpenSSH</primary>
        <secondary>Konfiguration</secondary>
      </indexterm>

      <para>Die f&uuml;r das ganze System g&uuml;ltigen
        Konfigurationsdateien des
	<application>OpenSSH</application>-D&aelig;mons und des Clients
	finden sich in dem Verzeichnis
	<filename>/etc/ssh</filename>.</para>

      <para>Die Client-Konfiguration befindet sich in
        <filename>ssh_config</filename>, die des Servers befindet sich in
	<filename>sshd_config</filename>.</para>

      <para>Das SSH-System l&auml;sst sich weiterhin &uuml;ber die
        Anweisungen <option>sshd_program</option> (Vorgabe ist
	<filename>/usr/sbin/sshd</filename>) und
	<option>sshd_flags</option> in <filename>/etc/rc.conf</filename>
	konfigurieren.</para>
    </sect2>

    <sect2 id="security-ssh-keygen">
      <title>ssh-keygen</title>

      <para>Mit &man.ssh-keygen.1; k&ouml;nnen DSA- oder RSA-Schl&uuml;ssel
        f&uuml;r einen Benutzer erzeugt werden, die anstelle von
	Passw&ouml;rtern verwendet werden k&ouml;nnen:</para>

      <screen>&prompt.user; <userinput>ssh-keygen -t <replaceable>dsa</replaceable></userinput>
Generating public/private dsa key pair.
Enter file in which to save the key (/home/user/.ssh/id_dsa):
Created directory '/home/user/.ssh'.
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /home/user/.ssh/id_dsa.
Your public key has been saved in /home/user/.ssh/id_dsa.pub.
The key fingerprint is:
bb:48:db:f2:93:57:80:b6:aa:bc:f5:d5:ba:8f:79:17 user@host.example.com
</screen>

      <para>&man.ssh-keygen.1; erzeugt einen &ouml;ffentlichen und einen
        privaten Schl&uuml;ssel f&uuml;r die Authentifizierung.  Der private
        Schl&uuml;ssel wird in <filename>~/.ssh/id_dsa</filename> oder
        <filename>~/.ssh/id_rsa</filename> gespeichert, w&auml;hrend
        sich der &ouml;ffentliche Schl&uuml;ssel in
        <filename>~/.ssh/id_dsa.pub</filename> oder
        <filename>~/.ssh/id_rsa.pub</filename> befindet, je nachdem,
        ob es sich um einen DSA- oder einen RSA-Schl&uuml;ssel handelt.
        Der &ouml;ffentliche Schl&uuml;ssel muss in die Datei
        <filename>~/.ssh/authorized_keys</filename> auf dem entfernten
        Rechner aufgenommen werden, damit der Schl&uuml;ssel
        funktioniert.  Analog muss auch ein
        RSA-Version&nbsp;1-Schl&uuml;ssel nach
        <filename>~/.ssh/authorized_keys</filename> kopiert werden.</para>

      <para>Damit werden Verbindungen zu der entfernten Maschine &uuml;ber
	SSH-Schl&uuml;sseln anstelle von Passw&ouml;rtern
	authentifiziert.</para>

      <para>Wenn bei der Erstellung der Schl&uuml;ssel mit
	&man.ssh-keygen.1; ein Passwort angegeben wurde, wird der
	Benutzer bei jeder Anmeldung zur Eingabe des Passworts
	aufgefordert.  Um den Umgang mit SSH-Schl&uuml;sseln zu
	erleichtern, kann &man.ssh-agent.1; die Verwaltung dieser
	Schl&uuml;ssel f&uuml;r Sie &uuml;bernehmen.  Lesen Sie dazu
	den <xref linkend="security-ssh-agent"> weiter unten.</para>

      <warning>
	<para>Die Kommandozeilenoptionen und Dateinamen sind
	  abh&auml;ngig von der <application>OpenSSH</application>-Version.
	  Die f&uuml;r Ihr System g&uuml;ltigen Optionen finden Sie
	  in der Hilfeseite &man.ssh-keygen.1;.</para>
      </warning>
    </sect2>

    <sect2 id="security-ssh-agent">
      <title>ssh-agent und ssh-add</title>

      <para>Mit &man.ssh-agent.1; und &man.ssh-add.1; ist es
        m&ouml;glich, <application>SSH</application>-Schl&uuml;ssel
        in den Speicher zu laden, damit die Passphrase nicht jedesmal
        eingegeben werden muss.</para>

      <para>&man.ssh-agent.1; &uuml;bernimmt die Authentifizierung
        von ihm geladener privater Schl&uuml;ssel.
        &man.ssh-agent.1; sollte nur dazu verwendet werden, ein
        anderes Programm zu starten, beispielsweise eine Shell oder
        einen Window-Manager.<para>

      <para>Um &man.ssh-agent.1; in einer Shell zu verwenden, muss
        es mit einer Shell als Argument aufgerufen werden.
        Zus&auml;tzlich m&uuml;ssen die zu verwaltende Identit&auml;t
        (durch &man.ssh-add.1;) sowie deren Passphrase f&uuml;r den
        privaten Schl&uuml;ssel &uuml;bergeben werden.  Nachdem dies
        erledigt ist, kann sich ein Benutzer &uuml;ber &man.ssh.1;
        auf jedem Rechner anmelden, der einen entsprechenden
        &ouml;ffentlichen Schl&uuml;ssel besitzt.  Dazu ein
        Beispiel:</para>

      <screen>&prompt.user; ssh-agent <replaceable>csh</replaceable>
&prompt.user; ssh-add
Enter passphrase for /home/user/.ssh/id_dsa:
Identity added: /home/user/.ssh/id_dsa (/home/user/.ssh/id_dsa)
&prompt.user;</screen>

      <para>Um &man.ssh-agent.1; unter X11 zu verwenden, m&uuml;ssen
        Sie &man.ssh-agent.1; in Ihre <filename>~/.xinitrc</filename>
        aufnehmen.  Dadurch k&ouml;nnen alle unter X11 gestarteten
        Programme die Dienste von &man.ssh-agent.1; nutzen.  Ihre
        <filename>~/.xinitrc</filename> k&ouml;nnte dazu etwas so
        aussehen:</para>

      <programlisting>exec ssh-agent <replaceable>startxfce4</replaceable></programlisting>

      <para>Dadurch wird bei jedem Start von X11 zuerst
        &man.ssh-agent.1; aufgerufen, das wiederum
        <application>XFCE</application> startet.  Nachdem Sie diese
        &Auml;nderung durchgef&uuml;hrt haben, m&uuml;ssen Sie X11
        neu starten.  Danach k&ouml;nnen Sie mit &man.ssh-add.1;
        Ihre SSH-Schl&uuml;ssel laden.</para>
    </sect2>

    <sect2 id="security-ssh-tunneling">
      <title>SSH-Tunnel</title>
      <indexterm>
        <primary>OpenSSH</primary>
        <secondary>Tunnel</secondary>
      </indexterm>

      <para>Mit <application>OpenSSH</application> ist es m&ouml;glich,
	einen Tunnel zu erstellen, in dem ein anderes Protokoll
	verschl&uuml;sselt &uuml;bertragen wird.</para>

      <para>Das folgende Kommando erzeugt einen Tunnel f&uuml;r
        <application>telnet</application>:</para>

       <screen>&prompt.user; <userinput>ssh -2 -N -f -L <replaceable>5023:localhost:23 user@foo.example.com</replaceable></userinput>
&prompt.user;</screen>

      <para>Dabei wurden die folgenden Optionen von <command>ssh</command>
        verwendet:</para>

      <variablelist>
	<varlistentry>
	  <term><option>-2</option></term>

	  <listitem>
	    <para>Erzwingt die Version 2 des Protokolls (Benutzen Sie die
	      Option nicht mit langsamen
	      <application>SSH</application>-Servern).</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-N</option></term>

	  <listitem>
	    <para>Zeigt an, dass ein Tunnel erstellt werden soll.
	      Ohne diese Option w&uuml;rde <command>ssh</command> eine
	      normale Sitzung &ouml;ffnen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-f</option></term>

	  <listitem>
	    <para>Zwingt <command>ssh</command> im Hintergrund zu
	      laufen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-L</option></term>

	  <listitem>
	    <para>Ein lokaler Tunnel wird in der Form
	      <replaceable>localport:remotehost:remoteport</replaceable>
	      angegeben.  Die Verbindung wird dabei von dem lokalen Port
	      <replaceable>localport</replaceable> auf einen entfernten
	      Rechner weitergeleitet.</para>
	  </listitem>
	  </varlistentry>

	<varlistentry>
	  <term><option>user@foo.example.com</option></term>

	  <listitem>
	    <para>Gibt den entfernten SSH server an.</para>
	  </listitem>
	</varlistentry>
      </variablelist>


       <para>Ein SSH-Tunnel erzeugt ein Socket auf
         <hostid>localhost</hostid> und dem angegebenen Port.  Jede
	 Verbindung, die auf dem angegebenen Socket aufgemacht wird, wird
	 dann auf den spezifizierten entfernten Rechner und Port
	 weitergeleitet.</para>

       <para>Im Beispiel wird der Port <replaceable>5023</replaceable> auf
	 die entfernte Maschine und dort auf <hostid>localhost</hostid>
	 Port <replaceable>23</replaceable> weitergeleitet.  Da der Port
	 <replaceable>23</replaceable> f&uuml;r
	 <application>Telnet</application> reserviert ist,
	 erzeugt das eine sichere
	 <application>Telnet</application>-Verbindung durch einen
	 SSH-Tunnel.</para>

       <para>Diese Vorgehensweise kann genutzt werden, um jedes unsichere
         TCP-Protokoll wie SMTP, POP3, FTP, usw. weiterzuleiten.</para>

       <example>
       <title>Mit SSH einen sicheren Tunnel f&uuml;r SMTP erstellen</title>
       <screen>&prompt.user; <userinput>ssh -2 -N -f -L <replaceable>5025:localhost:25 user@mailserver.example.com</replaceable></userinput>
user@mailserver.example.com's password: <userinput>*****</userinput>
&prompt.user; <userinput>telnet localhost 5025</userinput>
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
220 mailserver.example.com ESMTP</screen>

       <para>Zusammen mit &man.ssh-keygen.1; und zus&auml;tzlichen
         Benutzer-Accounts k&ouml;nnen Sie leicht benutzbare SSH-Tunnel
	 aufbauen.  Anstelle von Passw&ouml;rtern k&ouml;nnen Sie
	 Schl&uuml;ssel benutzen und jeder Tunnel kann unter einem eigenen
	 Benutzer laufen.</para>
       </example>

      <sect3>
	<title>Beispiel f&uuml;r SSH-Tunnel</title>

	<sect4>
	  <title>Sicherer Zugriff auf einen POP3-Server</title>

	  <para>Nehmen wir an, an Ihrer Arbeitsstelle gibt es einen
	    SSH-Server, der Verbindungen von au&szlig;en akzeptiert.  Auf
	    dem Netzwerk Ihrer Arbeitsstelle soll sich zudem noch ein
	    Mail-Server befinden, der POP3 spricht.  Das Netzwerk oder die
	    Verbindung von Ihrem Haus zu Ihrer Arbeitsstelle ist unsicher
	    und daher m&uuml;ssen Sie Ihre E-Mail &uuml;ber eine gesicherte
	    Verbindung abholen k&ouml;nnen.  Die L&ouml;sung zu diesem
	    Problem besteht darin, eine SSH-Verbindung von Ihrem Haus zu
	    dem SSH-Server an Ihrer Arbeitsstelle aufzubauen, und von dort
	    weiter zum Mail-Server zu tunneln.</para>

	  <screen>&prompt.user; <userinput>ssh -2 -N -f -L <replaceable>2110:mail.example.com:110 user@ssh-server.example.com</replaceable></userinput>
user@ssh-server.example.com's password: <userinput>******</userinput></screen>

	  <para>Wenn Sie den Tunnel eingerichtet haben, konfigurieren Sie
	    Ihren Mail-Client so, dass er POP3 Anfragen zu
	    <hostid>localhost</hostid> Port 2110 sendet.  Die Verbindung
	    wird dann sicher zu <hostid>mail.example.com</hostid>
	    weitergeleitet.</para>
	</sect4>

	<sect4>
	  <title>Umgehen einer strengen Firewall</title>

	  <para>Einige Netzwerkadministratoren stellen sehr drakonische
	    Firewall-Regeln auf, die nicht nur einkommende Verbindungen
	    filtern, sondern auch ausgehende.  Es kann sein, dass Sie
	    externe Maschinen nur &uuml;ber die Ports 22 und 80 (SSH und
	    Web) erreichen.</para>

	  <para>Sie wollen auf einen Dienst, der vielleicht nichts mit
	    Ihrer Arbeit zu tun hat, wie einen Ogg Vorbis Musik-Server,
	    zugreifen.  Wenn der Ogg Vorbis Server nicht auf den Ports 22
	    oder 80 l&auml;uft, k&ouml;nnen Sie aber nicht auf ihn
	    zugreifen.</para>

	  <para>Die L&ouml;sung hier ist es, eine SSH-Verbindung zu einer
	    Maschine au&szlig;erhalb der Firewall aufzumachen und durch
	    diese zum Ogg Vorbis Server zu tunneln.</para>

	  <screen>&prompt.user; <userinput>ssh -2 -N -f -L <replaceable>8888:music.example.com:8000 user@unfirewalled-system.example.org</replaceable></userinput>
user@unfirewalled-system.example.org's password: <userinput>*******</userinput></screen>

	  <para>Konfigurieren Sie Ihren Client so, dass er
	    <hostid>localhost</hostid> und Port 8888 benutzt.  Die Verbindung
	    wird dann zu <hostid>music.example.com</hostid> Port 8000
	    weitergeleitet und Sie haben die Firewall erfolgreich
	    umgangen.</para>
      </sect4>
      </sect3>
    </sect2>

    <sect2>
      <title>Die Option <varname>AllowUsers</varname></title>

      <para>Es ist in der Regel ein gute Idee, festzulegen, welche
        Benutzer sich von welchem Rechner aus anmelden k&ouml;nnen.
        Dies l&auml;sst sich beispielsweise &uuml;ber die Option
        <literal>AllowUsers</literal> festlegen.  Soll sich etwa
        nur <username>root</username> vom Rechner mit der IP-Adresse
        <hostid role="ipaddr">192.168.1.32</hostid> aus einw&auml;hlen
        d&uuml;rfen, w&uuml;rden Sie folgenden Eintrag in
        <filename>/etc/ssh/sshd_config</filename> aufnehmen:</para>

      <programlisting>AllowUsers root@192.168.1.32</programlisting>

      <para>Damit sich <username>admin</username> von jedem Rechner aus
        anmelden kann, geben Sie nur den Benutzernamen an:</para>

      <programlisting>AllowUsers admin</programlisting>

      <para>Sie k&ouml;nnen auch mehrere Benutzer in einer Zeile
        auff&uuml;hren:</para>

      <programlisting>AllowUsers root@192.168.1.32 admin</programlisting>

      <note>
        <para>Nur ein Benutzer, der in dieser Liste aufgef&uuml;hrt ist,
          darf sich auf diesem Rechner anmelden.</para>
      </note>

      <para>Nachdem Sie <filename>/etc/ssh/sshd_config</filename>
        angepasst haben, muss &man.sshd.8; seine Konfigurationsdateien
        neu einlesen.  Dazu geben Sie Folgendes ein:</para>

      <screen>&prompt.root; <userinput>/etc/rc.d/sshd reload</userinput></screen>
    </sect2>

    <sect2>
      <title>Weiterf&uuml;hrende Informationen</title>
      <para><ulink url="http://www.openssh.com/">OpenSSH</ulink></para>
      <para>&man.ssh.1; &man.scp.1; &man.ssh-keygen.1;
        &man.ssh-agent.1; &man.ssh-add.1; &man.ssh.config.5;</para>
      <para>&man.sshd.8; &man.sftp-server.8; &man.sshd.config.5;</para>
    </sect2>
  </sect1>

  <sect1 id="fs-acl">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <indexterm>
      <primary>ACL</primary>
    </indexterm>
    <title>Zugriffskontrolllisten f&uuml;r Dateisysteme</title>

    <para>Zusammen mit anderen Verbesserungen des Dateisystems wie
      Schnappsch&uuml;sse gibt es ab &os;&nbsp;5.0
      <firstterm>Zugriffskontrolllisten</firstterm> (<foreignphrase>access
        control list</foreignphrase>, <acronym>ACL</acronym>).</para>

    <para>Zugriffskontrolllisten erweitern die normalen Zugriffsrechte
      von &unix; Systemen auf eine kompatible (&posix;.1e) Weise
      und bieten feiner granulierte Sicherheitsmechanismen.</para>

    <para>Zugriffskontrolllisten f&uuml;r Dateisysteme werden mit der
      nachstehenden Zeile in der Kernelkonfiguration aktiviert:</para>

    <programlisting>options UFS_ACL</programlisting>

    <para>Diese Option ist in der <filename>GENERIC</filename>-Konfiguration
      aktiviert.  Das System gibt eine Warnung aus, wenn ein Dateisystem mit
      <acronym>ACL</acronym>s eingehangen werden soll und die
      Unterst&uuml;tzung f&uuml;r <acronym>ACL</acronym>s nicht im Kernel
      aktiviert ist.  Das Dateisystem muss weiterhin erweiterte Attribute
      zur Verf&uuml;gung stellen, damit <acronym>ACL</acronym>s verwendet
      werden k&ouml;nnen.  Das neue <acronym>UNIX</acronym>-Dateisystem
      <acronym>UFS2</acronym> stellt diese Attribute
      standardm&auml;&szlig;ig zur Verf&uuml;gung.</para>

    <note><para>Die Konfiguration erweiterter Attribute auf
      <acronym>UFS1</acronym> ist mit einem h&ouml;heren Aufwand als die
      Konfiguration erweiterter Attribute auf <acronym>UFS2</acronym>
      verbunden.  Zudem ist <acronym>UFS2</acronym> mit erweiterten
      Attributen leistungsf&auml;higer als <acronym>UFS1</acronym>.
      Zugriffskontrolllisten sollten daher mit <acronym>UFS2</acronym>
      verwendet werden.</para></note>

    <para>Die Angabe der Option <option>acl</option> in
      <filename>/etc/fstab</filename> aktiviert Zugriffskontrolllisten
      f&uuml;r ein Dateisystem.  Die bevorzugte M&ouml;glichkeit ist
      die Verwendung von Zugriffskontrolllisten mit &man.tunefs.8; (Option
      <option>-a</option>), im Superblock des Dateisystems festzuschreiben.
      Diese M&ouml;glichkeit hat mehrere Vorteile:</para>

    <itemizedlist>
      <listitem>
	<para>Nochmaliges Einh&auml;ngen eines Dateisystems (Option
	  <option>-u</option> von &man.mount.8;) ver&auml;ndert den Status
	  der Zugriffskontrolllisten nicht.  Die Verwendung von
	  Zugriffskontrolllisten kann nur durch Abh&auml;ngen und erneutes
	  Einh&auml;ngen eines Dateisystems ver&auml;ndert werden.  Das
	  hei&szlig;t auch, dass Zugriffskontrolllisten nicht
	  nachtr&auml;glich auf dem Root-Dateisystem aktiviert werden
	  k&ouml;nnen.</para>
      </listitem>

      <listitem>
	<para>Die Zugriffskontrolllisten auf den Dateisystemen sind,
	  unabh&auml;ngig von den Option in <filename>/etc/fstab</filename>
	  oder Namens&auml;nderungen der Ger&auml;te, immer aktiv.  Dies
	  verhindert auch, dass Zugriffskontrolllisten aus Versehen
	  auf Dateisystem ohne Zugriffskontrolllisten aktiviert werden und
	  durch falsche Zugriffsrechte Sicherheitsprobleme entstehen.</para>
      </listitem>
    </itemizedlist>

    <note>
      <para>Es kann sein, dass sich der Status von Zugriffskontrolllisten
        sp&auml;ter durch nochmaliges Einh&auml;ngen des Dateisystems
	(Option <option>-u</option> von &man.mount.8;) &auml;ndern
	l&auml;sst.  Die momentane Variante ist aber sicherer, da der
	Status der Zugriffskontrolllisten nicht versehentlich ge&auml;ndert
	werden kann.  Allgemein sollten Zugriffskontrolllisten auf einem
	Dateisystem, auf dem sie einmal verwendet wurden, nicht deaktiviert
	werden, da danach die Zugriffsrechte falsch sein k&ouml;nnen.
	Werden Zugriffskontrolllisten auf einem solchen Dateisystem wieder
	aktiviert, werden die Zugriffsrechte von Dateien, die sich
	zwischenzeitlich ge&auml;ndert haben, &uuml;berschrieben, was zu
	erneuten Problemen f&uuml;hrt.</para>
    </note>

    <para>Die Zugriffsrechte einer Datei werden durch ein
      <literal>+</literal> (Plus) gekennzeichnet, wenn die Datei durch
      Zugriffskontrolllisten gesch&uuml;tzt ist:</para>

    <programlisting>drwx------  2 robert  robert  512 Dec 27 11:54 private
drwxrwx---+ 2 robert  robert  512 Dec 23 10:57 directory1
drwxrwx---+ 2 robert  robert  512 Dec 22 10:20 directory2
drwxrwx---+ 2 robert  robert  512 Dec 27 11:57 directory3
drwxr-xr-x  2 robert  robert  512 Nov 10 11:54 public_html</programlisting>

    <para>Die Verzeichnisse <filename>directory1</filename>,
      <filename>directory2</filename> und <filename>directory3</filename>
      sind durch Zugriffskontrolllisten gesch&uuml;tzt, das Verzeichnis
      <filename>public_html</filename> nicht.</para>

    <sect2>
      <title>Zugriffskontrolllisten benutzen</title>

      <para>Das Werkzeug &man.getfacl.1; zeigt Zugriffskontrolllisten
	an.  Das folgende Kommando zeigt die <acronym>ACL</acronym>s
	auf der Datei <filename>test</filename>:</para>

      <screen>&prompt.user; <userinput>getfacl <filename>test</filename></userinput>
	#file:test
	#owner:1001
	#group:1001
	user::rw-
	group::r--
	other::r--</screen>

      <para>Das Werkzeug &man.setfacl.1; &auml;ndert oder entfernt
        <acronym>ACL</acronym>s auf Dateien.  Zum Beispiel:</para>

      <screen>&prompt.user; <userinput>setfacl -k <filename>test</filename></userinput></screen>

      <para>Die Option <option>-k</option> entfernt alle
	<acronym>ACL</acronym>s einer Datei oder eines Dateisystems.
	Besser w&auml;re es, die Option <option>-b</option>
	zu verwenden, da sie die erforderlichen Felder
	beibeh&auml;lt.</para>

      <screen>&prompt.user; <userinput>setfacl -m u:trhodes:rwx,g:web:r--,o::--- <filename>test</filename></userinput></screen>

      <para>Mit dem vorstehenden Kommando werden die eben
	entfernten Zugriffskontrolllisten wiederhergestellt.
	Der Befehl gibt die Fehlermeldung
	<errorname>Invalid argument</errorname> aus,
	<!-- doch nicht auf <devicename>stdout</devicename> ?? -->
	wenn Sie nicht existierende Benutzer oder Gruppen
	als Parameter angeben.</para>
    </sect2>
  </sect1>

  <sect1 id="security-portaudit">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <indexterm>
      <primary>Portaudit</primary>
    </indexterm>
    <title>Sicherheitsprobleme in Software Dritter &uuml;berwachen</title>

    <para>In den letzten Jahren wurden zahlreiche Verbesserungen in
      der Einsch&auml;tzung und dem Umgang mit Sicherheitsproblemen
      erzielt.  Die Gefahr von Einbr&uuml;chen in ein System wird
      aber immer gr&ouml;&szlig;er, da Softwarepakete von Dritten
      auf nahezu jedem Betriebssystem installiert und konfiguriert
      werden.</para>

    <para>Die Einsch&auml;tzung der Verletzlichkeit eines Systems ist
      ein Schl&uuml;sselfaktor f&uuml;r dessen Sicherheit.  &os;
      ver&ouml;ffentlicht zwar Sicherheitshinweise
      (<foreignphrase>security advisories</foreignphrase>) f&uuml;r
      das Basissystem, das Projekt ist allerdings nicht dazu in der
      Lage, dies auch f&uuml;r die zahlreichen Softwarepakete von
      Dritten zu tun.  Dennoch gibt es einen Weg, auch diese
      Programmpakete zu &uuml;berwachen.  Das in der Ports-Sammlung
      enthaltene Programm <application>Portaudit</application> wurde
      gezielt daf&uuml;r entwickelt.</para>

    <para>Der Port <filename role="port">security/portaudit</filename>
      fragt dazu eine Datenbank, die vom &os; Security Team sowie
      den Ports-Entwicklern aktualisiert und gewartet wird, auf
      bekannte Sicherheitsprobleme ab.</para>

    <para>Bevor Sie <application>Portaudit</application> verwenden
      k&ouml;nnen, m&uuml;ssen Sie es &uuml;ber die Ports-Sammlung
      installieren:</para>

    <screen>&prompt.root; <userinput>cd /usr/ports/security/portaudit && make install clean</userinput></screen>

    <para>W&auml;hrend der Installation werden die
      Konfigurationsdateien f&uuml;r &man.periodic.8; aktualisiert, was
      es <application>Portaudit</application> erlaubt, seine Ausgabe
      in den t&auml;glichen Sicherheitsbericht einzuf&uuml;gen.
      Stellen Sie auf jeden Fall sicher, dass diese (an das
      E-Mail-Konto von <username>root</username> gesendeten)
      Sicherheitsberichte auch gelesen werden.  An dieser Stelle
      ist keine weitere Konfiguration n&ouml;tig.</para>

    <para>Nach der Installation muss ein Administrator die unter
      <filename role="directory">/var/db/portaudit</filename> lokal
      gespeicherte Datenbank aktualisieren:</para>

    <screen>&prompt.root; <userinput>portaudit -F</userinput></screen>

    <note>
      <para>Die Datenbank wird automatisch aktualisiert, wenn
        &man.periodic.8; ausgef&uuml;hrt wird.  Der eben genannte
        Befehl ist daher optional, er wird aber f&uuml;r das
        folgende Beispiel ben&ouml;tigt.</para>
    </note>

    <para>Um &uuml;ber die Ports-Sammlung installierte
      Softwarepakete Dritter zu &uuml;berpr&uuml;fen, muss ein
      Administrator nur den folgenden Befehl eingeben:</para>

    <screen>&prompt.root; <userinput>portaudit -a</userinput></screen>

    <para>Eine Ausgabe k&ouml;nnte beispielsweise so aussehen:</para>

    <programlisting>Affected package: cups-base-1.1.22.0_1
Type of problem: cups-base -- HPGL buffer overflow vulnerability.
Reference: &lt;http://www.FreeBSD.org/ports/portaudit/40a3bca2-6809-11d9-a9e7-0001020eed82.html&gt;

1 problem(s) in your installed packages found.

You are advised to update or deinstall the affected package(s) immediately.</programlisting>

    <para>Wenn Sie die angegebene <acronym>URL</acronym> &uuml;ber einen
      Internetbroswer aufrufen, erhalten Sie weitere Informationen
      &uuml;ber die bestehende Sicherheitsl&uuml;cke, wie die betroffenen
      Versionen, die Version des &os;-Ports sowie Hinweise auf weitere
      Seiten, die ebenfalls Sicherheitshinweise zu diesem Problem
      bieten.</para>

    <para><application>Portaudit</application> ist ein m&auml;chtiges
      Werkzeug und insbesondere in Zusammenarbeit mit dem
      Port <application>Portupgrade</application> &auml;u&szlig;erst
      hilfreich.</para>
  </sect1>

  <sect1 id="security-advisories">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Beigesteuert von </contrib>
	</author>
      </authorgroup>
    </sect1info>
    <indexterm>
      <primary>Sicherheitshinweise</primary>
    </indexterm>
    <title>&os; Sicherheitshinweise</title>

    <para>Wie f&uuml;r andere hochwertige Betriebssysteme auch
      werden f&uuml;r &os; Sicherheitshinweise herausgegeben.
      Die Hinweise werden gew&ouml;hnlich auf den Sicherheits-Mailinglisten
      und in den Errata ver&ouml;ffentlicht, nachdem das
      Sicherheitsproblem behoben ist.  Dieser Abschnitt beschreibt
      den Umgang mit den Sicherheitshinweisen.</para>

    <sect2>
      <title>Wie sieht ein Sicherheitshinweis aus?</title>

      <para>Der nachstehende Sicherheitshinweis stammt von
	der Mailingliste &a.security-notifications.name;:</para>

      <programlisting>=============================================================================
&os;-SA-XX:XX.UTIL                                     Security Advisory
                                                          The &os; Project

Topic:          denial of service due to some problem<co id="co-topic">

Category:       core<co id="co-category">
Module:         sys<co id="co-module">
Announced:      2003-09-23<co id="co-announce">
Credits:        Person@EMAIL-ADDRESS<co id="co-credit">
Affects:        All releases of &os;<co id="co-affects">
                &os; 4-STABLE prior to the correction date
Corrected:      2003-09-23 16:42:59 UTC (RELENG_4, 4.9-PRERELEASE)
                2003-09-23 20:08:42 UTC (RELENG_5_1, 5.1-RELEASE-p6)
                2003-09-23 20:07:06 UTC (RELENG_5_0, 5.0-RELEASE-p15)
                2003-09-23 16:44:58 UTC (RELENG_4_8, 4.8-RELEASE-p8)
                2003-09-23 16:47:34 UTC (RELENG_4_7, 4.7-RELEASE-p18)
                2003-09-23 16:49:46 UTC (RELENG_4_6, 4.6-RELEASE-p21)
                2003-09-23 16:51:24 UTC (RELENG_4_5, 4.5-RELEASE-p33)
                2003-09-23 16:52:45 UTC (RELENG_4_4, 4.4-RELEASE-p43)
                2003-09-23 16:54:39 UTC (RELENG_4_3, 4.3-RELEASE-p39)<co id="co-corrected">
&os; only:   NO<co id="co-only">

For general information regarding FreeBSD Security Advisories,
including descriptions of the fields above, security branches, and the
following sections, please visit
http://www.FreeBSD.org/security/.

I.   Background<co id="co-backround">


II.  Problem Description<co id="co-descript">


III. Impact<co id="co-impact">


IV.  Workaround<co id="co-workaround">


V.   Solution<co id="co-solution">


VI.  Correction details<co id="co-details">


VII. References<co id="co-ref"></programlisting>


      <calloutlist>
	<callout arearefs="co-topic">
	  <para>Das Feld <literal>Topic</literal> enth&auml;lt eine
	    Beschreibung des Sicherheitsproblems und benennt das
	    betroffene Programm.</para>
	</callout>

	<callout arearefs="co-category">
	  <para>Das Feld <literal>Category</literal> beschreibt den
	    betroffenen Systemteil.  M&ouml;gliche Werte f&uuml;r dieses
	    Feld sind <literal>core</literal>, <literal>contrib</literal>
	    oder <literal>ports</literal>.  Die Kategorie
	    <literal>core</literal> gilt f&uuml;r Kernkomponenten
	    des &os;-Betriebssystems, die Kategorie
	    <literal>contrib</literal> beschreibt zum Basissystem
	    geh&ouml;rende Software Dritter beispielsweise
	    <application>sendmail</application>.  Die Kategorie
	    <literal>ports</literal> beschreibt Software, die
	    Teil der Ports-Sammlung ist.</para>
	</callout>

	<callout arearefs="co-module">
	  <para>Das Feld <literal>Module</literal> beschreibt die
	    betroffene Komponente.  Im Beispiel ist
	    <literal>sys</literal> angegeben, das hei&szlig;t
	    dieses Problem betrifft eine Komponente, die vom
	    Kernel benutzt wird.</para>
	</callout>

	<callout arearefs="co-announce">
	  <para>Das Feld <literal>Announced</literal> gibt den
	    Zeitpunkt der Bekanntgabe des Sicherheitshinweises
	    an.  Damit existiert das Sicherheitsproblem,
	    ist vom Sicherheits-Team best&auml;tigt worden
	    und eine entsprechende Korrektur wurde in das
	    Quellcode-Repository von &os; gestellt.</para>
	</callout>

	<callout arearefs="co-credit">
	  <para>Das Feld <literal>Credits</literal> gibt die Person
	    oder Organisation an, die das Sicherheitsproblem
	    bemerkte und gemeldet hat.</para>
	</callout>

	<callout arearefs="co-affects">
	  <para>Welche &os;-Releases betroffen sind, ist im Feld
	    <literal>Affects</literal> angegeben.  Die Version einer
	    Datei, die zum Kernel geh&ouml;rt, k&ouml;nnen Sie
	    schnell mit <command>ident</command> ermitteln.  Bei Ports
	    ist die Versionsnummer angegeben, die Sie im Verzeichnis
	    <filename class="directory">/var/db/pkg</filename> finden.
	    Wenn Sie Ihr System nicht t&auml;glich aktualisieren,
	    ist Ihr System wahrscheinlich betroffen.</para>
	</callout>

	<callout arearefs="co-corrected">
	  <para>Wann das Problem in welchem Release behoben wurde,
	    steht im Feld <literal>Corrected</literal>.</para>
	</callout>

	<callout arearefs="co-only">
	  <para>Im Feld <literal>&os; only</literal> wird angegeben,
	    ob das Sicherheitsproblem nur &os; oder auch andere
	    Betriebssysteme betrifft.</para>
	</callout>

	<callout arearefs="co-backround">
	  <para>Im Feld <literal>Background</literal> wird
	    das betroffene Werkzeug beschrieben.  Meist finden Sie
	    hier warum das Werkzeug Bestandteil von &os; ist,
	    wof&uuml;r es benutzt wird und eine kurze
	    Darstellung der Herkunft des Werkzeugs.</para>
	</callout>

	<callout arearefs="co-descript">
	  <para>Im Feld <literal>Problem Description</literal> befindet
	    sich eine genaue Darstellung des Sicherheitsproblems.
	    Hier wird fehlerhafter Code beschrieben oder geschildert,
	    wie ein Werkzeug ausgenutzt wird.</para>
	</callout>

	<callout arearefs="co-impact">
	  <para>Das Feld <literal>Impact</literal> beschreibt die
	    Auswirkungen des Sicherheitsproblems auf ein System,
	    beispielsweise erweiterte Rechte oder gar
	    Superuser-Rechte f&uuml;r normale Benutzer.</para>
	</callout>

	<callout arearefs="co-workaround">
	  <para>Im Feld <literal>Workaround</literal> wird
	    eine Umgehung des Sicherheitsproblems beschrieben.
	    Die Umgehung ist f&uuml;r Administratoren gedacht,
	    die ihr System aus Zeitnot, Netzwerk-technischen oder
	    anderen Gr&uuml;nden nicht aktualisieren k&ouml;nnen.
	    Nehmen Sie Sicherheitsprobleme ernst:  Auf einem
	    betroffenen System sollte das Problem entweder behoben
	    oder, wie hier beschrieben, umgangen werden.</para>
	</callout>

	<callout arearefs="co-solution">
	  <para>Im Feld <literal>Solution</literal> enth&auml;lt eine
	    getestete Schritt-f&uuml;r-Schritt Anleitung, die das
	    Sicherheitsproblem behebt.</para>
	</callout>

	<callout arearefs="co-details">
	  <para>Das Feld <literal>Correction Details</literal>
	    enth&auml;lt die CVS-Tags der betroffenen Dateien
	    zusammen mit zugeh&ouml;rigen Revisionsnummern.</para>
	</callout>

	<callout arearefs="co-ref">
	  <para>Im Feld <literal>References</literal> finden sich
	    Verweise auf weitere Informationsquellen.  Dies k&ouml;nnen
	    URLs zu Webseiten, B&uuml;cher, Mailinglisten und Newsgroups
	    sein.</para>
	</callout>
      </calloutlist>
    </sect2>
  </sect1>

  <sect1 id="security-accounting">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
    </sect1info>

    <indexterm>
      <primary>Prozess-&Uuml;berwachung</primary>
    </indexterm>

    <title>Prozess-&Uuml;berwachung</title>

    <para>Prozess-&Uuml;berwachung
      (<foreignphrase>Process accounting</foreignphrase>) ist ein
      Sicherheitsverfahren, bei dem ein Administrator verfolgt,
      welche Systemressourcen verwendet werden und wie sich diese
      auf die einzelnen Anwender verteilen.  Dadurch kann das
      System &uuml;berwacht werden und es ist sogar m&ouml;glich,
      zu kontrollieren, welche Befehle ein Anwender eingibt.</para>

    <para>Diese F&auml;higkeiten haben sowohl Vor- als auch Nachteile.
      Positiv ist, dass man ein Einbruchsversuch bis an den Anfang
      zur&uuml;ckverfolgen kann.  Von Nachteil ist allerdings,
      dass durch diesen Prozess Unmengen an Protokolldateien erzeugt
      werden, die auch dementsprechenden Plattenplatz ben&ouml;tigen.
      Dieser Abschnitt beschreibt die Grundlagen der
      Prozess-&Uuml;berwachung.</para>

    <sect2>
      <title>Die Prozess-&Uuml;berwachung aktivieren und
        konfigurieren</title>

      <para>Bevor Sie die Prozess-&Uuml;berwachung verwenden k&ouml;nnen,
        m&uuml;ssen Sie diese aktivieren.  Dazu f&uuml;hren Sie als
        <username>root</username> die folgenden Befehle aus:</para>

       <screen>&prompt.root; <userinput>touch <filename>/var/account/acct</filename></userinput>
&prompt.root; <userinput>accton <filename>/var/account/acct</filename></userinput>
&prompt.root; <userinput>echo 'accounting_enable="YES"' &gt;&gt; <filename>/etc/rc.conf</filename></userinput></screen>

      <para>Einmal aktiviert, wird sofort mit der &Uuml;berwachung von
	<acronym>CPU</acronym>-Statistiken, Befehlen und anderen
	Vorg&auml;ngen begonnen.  Protokolldateien werden in einem
	nur von Maschinen lesbaren Format gespeichert, daher m&uuml;ssen
	Sie diese &uuml;ber &man.sa.8; aufrufen.  Geben Sie keine
	Optionen an, gibt <command>sa</command> Informationen wie
	die Anzahl der Aufrufe pro Anwender, die abgelaufene Zeit in
	Minuten, die gesamte <acronym>CPU</acronym>- und Anwenderzeit
	in Minuten, die durchschnittliche Anzahl der Ein- und
	Ausgabeoperationen und viel andere mehr aus.</para>

      <para>Um Informationen &uuml;ber ausgef&uuml;hrte Befehle zu
	erhalten, verwenden Sie &man.lastcomm.1;. So k&ouml;nnen Sie
	etwa ermittlen, welche Befehle von wem auf welchem &man.ttys.5;
	ausgef&uuml;hrt wurden:</para>

      <screen>&prompt.root; <userinput>lastcomm ls
	<username>trhodes</username> ttyp1</userinput></screen>

      <para>Das Ergebnis sind alle bekannten Eins&auml;tze von
        <command>ls</command> durch <username>trhodes</username>
        auf dem Terminal ttyp1.</para>

      <para>Zahlreiche weitere n&uuml;tzliche Optionen finden Sie in den
	Manualpages zu &man.lastcomm.1;, &man.acct.5; sowie
	&man.sa.8;.</para>
    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
