<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde: de-docproj/books/handbook/disks/chapter.xml,v 1.187 2012/04/26 19:32:48 bcr Exp $
     basiert auf: r54328
-->
<chapter xmlns="http://docbook.org/ns/docbook"
  xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0"
  xml:id="disks">
  <info>
    <title>Speichermedien</title>

    <authorgroup>
      <author>
	<personname>
	  <firstname>Bernd</firstname>
	  <surname>Warken</surname>
	</personname>
	<contrib>Übersetzt von </contrib>
      </author>
      <author>
	<personname>
	  <firstname>Martin</firstname>
	  <surname>Heinen</surname>
	</personname>
      </author>
    </authorgroup>
  </info>

  <sect1 xml:id="disks-synopsis">
    <title>Übersicht</title>

    <para>Dieses Kapitel behandelt die Benutzung von Laufwerken unter
      &os;.  Hierzu zählen <acronym>SCSI</acronym>- und
      <acronym>IDE</acronym>-Geräte, <acronym>CD</acronym>- und
      <acronym>DVD</acronym>-Medien, speicherbasierte Laufwerke und
      <acronym>USB</acronym>-Geräte.</para>

    <para>Nachdem Sie dieses Kapitel gelesen haben, werden Sie
      Folgendes wissen:</para>

    <itemizedlist>
      <listitem>
	<para>Wie Sie zusätzliche Laufwerke zu einem &os;-System
	  hinzufügen.</para>
      </listitem>

      <listitem>
	<para>Wie Sie unter &os; die Partition einer Festplatte
	  vergrößern.</para>
      </listitem>

      <listitem>
	<para>Wie Sie &os; zur Verwendung von
	  <acronym>USB</acronym>-Speichermedien konfigurieren.</para>
      </listitem>

      <listitem>
	<para>Wie Sie <acronym>CD</acronym>- und
	  <acronym>DVD</acronym>-Medien unter &os; benutzen.</para>
      </listitem>

      <listitem>
	<para>Wie Sie die unter &os; erhältlichen Backup-Programme
	  benutzen.</para>
      </listitem>

      <listitem>
	<para>Wie Sie RAM-Disks einrichten.</para>
      </listitem>

      <listitem>
	<para>Was Dateisystem-Schnappschüsse sind und wie sie
	  effizient eingesetzt werden.</para>
      </listitem>

      <listitem>
	<para>Wie Sie mit Quotas die Benutzung von Laufwerken
	  einschränken.</para>
      </listitem>

      <listitem>
	<para>Wie Sie Festplatten und Swap verschlüsseln, um Daten
	  vor Angreifern zu schützen.</para>
      </listitem>

      <listitem>
	<para>Wie Sie ein hochverfügbares Speichernetzwerk
	  konfigurieren.</para>
      </listitem>
    </itemizedlist>

    <para>Bevor Sie dieses Kapitel lesen,</para>

    <itemizedlist>
      <listitem>
	<para>sollten Sie wissen, wie Sie einen
	  <link linkend="kernelconfig">neuen &os;-Kernel konfigurieren
	    und installieren</link>.</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 xml:id="disks-adding">
    <info>
      <title>Hinzufügen von Laufwerken</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>David</firstname>
	    <surname>O'Brian</surname>
	  </personname>
	  <contrib>Im Original von </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>Laufwerke</primary>
      <secondary>hinzufügen</secondary>
    </indexterm>

    <para>Dieser Abschnitt beschreibt, wie Sie ein neues
      <acronym>SATA</acronym>-Laufwerk zu einer Maschine
      hinzufügen, die momentan nur ein Laufwerk hat.  Dazu schalten
      Sie zuerst den Rechner aus und installieren das Laufwerk
      entsprechend der Anleitungen Ihres Rechners, Ihres Controllers
      und des Laufwerkherstellers.  Starten Sie das System neu und
      melden Sie sich als Benutzer
      <systemitem class="username">root</systemitem> an.</para>

    <para>Kontrollieren Sie <filename>/var/run/dmesg.boot</filename>,
      um sicherzustellen, dass das neue Laufwerk gefunden wurde.  In
      diesem Beispiel erscheint das neu hinzugefügte
      <acronym>SATA</acronym>-Laufwerk als
      <filename>ada1</filename>.</para>

    <indexterm><primary>Partitionen</primary></indexterm>
    <indexterm>
      <primary><command>gpart</command></primary>
    </indexterm>

    <para>In diesem Beispiel wird eine einzige große Partition auf der
      Festplatte erstellt.  Verwendet wird das <link
	xlink:href="https://de.wikipedia.org/wiki/GUID_Partition_Table">
	<acronym>GPT</acronym></link>-Partitionsschema, welches
      gegenüber dem älteren und weniger vielseitigen
      <acronym>MBR</acronym>-Schema bevorzug wird.</para>

    <note>
      <para>Wenn die hinzugefügte Festplatte nicht leer ist, können
	alte Partitionsinformationen mit
	<command>gpart delete</command> entfernt werden.  Details
	finden Sie in &man.gpart.8;.</para>
    </note>

    <para>Zuerst wird das Partitionsschema erstellt und dann eine
      einzelne Partition angefügt.  Zur Verbesserung der Leistung auf
      neueren Festplatten mit größeren Blockgrößen, wird die
      Partition an einer Megabyte-Grenze ausgerichtet:</para>

    <screen>&prompt.root; <userinput>gpart create -s GPT ada1</userinput>
&prompt.root; <userinput>gpart add -t freebsd-ufs -a 1M ada1</userinput></screen>

    <para>Je nach Anwendung kann es wünschenswert sein, mehrere
      kleinere Partitionen zu haben.  In &man.gpart.8; finden Sie
      Optionen zum Erstellen von kleineren Partitionen.</para>

    <para>Informationen über die Partitionen der Festplatte werden mit
      <command>gpart show</command> angezeigt:</para>

    <screen>&prompt.user; <userinput>gpart show ada1</userinput>
=>        34  1465146988  ada1  GPT  (699G)
          34        2014        - free -  (1.0M)
        2048  1465143296     1  freebsd-ufs  (699G)
  1465145344        1678        - free -  (839K)</screen>

    <para>Ein Dateisystem wird in der neuen Partition erstellt:</para>

    <screen>&prompt.root; <userinput>newfs -U /dev/ada1p1</userinput></screen>

    <para>Ein leeres Verzeichnis wird als Mountpunkt erstellt, also
      ein Speicherort für die Montage der neuen Festplatte im
      originalen Dateisystem:</para>

    <screen>&prompt.root; <userinput>mkdir /newdisk</userinput></screen>

    <para>Abschließend wird ein Eintrag in
      <filename>/etc/fstab</filename> hinzugefügt, damit die neue
      Festplatte automatisch beim Start eingehängt wird:</para>

    <programlisting>/dev/ada1p1	/newdisk      ufs   rw	    2	  2</programlisting>

    <para>Die neue Festplatte kann manuell montiert werden, ohne das
      System neu zu starten:</para>

    <screen>&prompt.root; <userinput>mount /newdisk</userinput></screen>
  </sect1>

  <sect1 xml:id="disks-growing">
    <info>
      <title>Partitionen vergrößern</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Allan</firstname>
	    <surname>Jude</surname>
	  </personname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <personname>
	    <firstname>Björn</firstname>
	    <surname>Heidotting</surname>
	  </personname>
	  <contrib>Übersetzt von </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>Partitionen</primary>
      <secondary>vergrößern</secondary>
    </indexterm>

    <para>Die Kapazität einer Festplatte kann sich ohne Änderungen
      an bereits vorhandenen Daten erhöhen.  Dies geschieht
      üblicherweise mit virtuellen Maschinen, wenn sich herausstellt,
      dass die virtuelle Festplatte zu klein ist und vergrößert werden
      soll.  Zuweilen wird auch ein Abbild einer Platte auf einen
      <acronym>USB</acronym>-Stick geschrieben, ohne dabei die volle
      Kapazität zu nutzen.  Dieser Abschnitt beschreibt, wie man
      Platten vergrößert, bzw. <emphasis>erweitert</emphasis>, um die
      Vorteile der erhöhten Kapazität zu nutzen.</para>

    <para>Überprüfen Sie <filename>/var/run/dmesg.boot</filename>, um
      den Gerätenamen der Festplatte zu bestimmen, die vergrößert
      werden soll.  In diesem Beispiel gibt es nur eine
      <acronym>SATA</acronym>-Festplatte im System, so dass die Platte
      als <filename>ada0</filename> angezeigt wird.</para>

    <indexterm><primary>Partitionen</primary></indexterm>
    <indexterm>
      <primary><command>gpart</command></primary>
    </indexterm>

    <para>Um die aktuelle Konfiguration der Partitionen auf der
      Festplatte anzuzeigen:</para>

    <screen>&prompt.root; <userinput>gpart show <replaceable>ada0</replaceable></userinput>
=>      34  83886013  ada0  GPT  (48G) [CORRUPT]
        34       128     1  freebsd-boot  (64k)
       162  79691648     2  freebsd-ufs  (38G)
  79691810   4194236     3  freebsd-swap  (2G)
  83886046         1        - free -  (512B)</screen>

    <note>
      <para>Wenn die Festplatte mit dem <link
	  xlink:href="http://en.wikipedia.org/wiki/GUID_Partition_Table">
	  <acronym>GPT</acronym></link>-Partitionsschema formatiert
	wurde kann es vorkommen, dass sie als
	<quote>corrupted</quote> angezeigt wird, weil sich die
	Sicherung der <acronym>GPT</acronym>-Partitionstabellen nicht
	mehr am Ende des Laufwerks befinden.  Reparieren Sie in so
	einem Fall die Partitionstabelle mit
	<command>gpart</command>:</para>

      <screen>&prompt.root; <userinput>gpart recover <replaceable>ada0</replaceable></userinput>
ada0 recovered</screen>
    </note>

    <para>Nun steht der zusätzliche Speicherplatz zur Verfügung und
      kann verwendet werden, um eine neue Partition anzulegen oder
      eine bestehende Partition zu erweitern:</para>

    <screen>&prompt.root; <userinput>gpart show <replaceable>ada0</replaceable></userinput>
=>       34  102399933  ada0  GPT  (48G)
         34        128     1  freebsd-boot  (64k)
        162   79691648     2  freebsd-ufs  (38G)
   79691810    4194236     3  freebsd-swap  (2G)
   83886046   18513921        - free -  (8.8G)</screen>

    <para>Partitionen können nur auf zusammenhängenden, freien
      Speicherplatz vergrößert werden.  In diesem Beispiel wird die
      letzte Partition der Platte als Swap-Speicher genutzt, aber die
      zweite Partition ist die, dessen Größe verändert werden soll.
      Weil der Swap-Speicher nur temporäre Daten enthält, kann er
      gefahrlos ausgehangen, gelöscht und nachdem die zweite Partition
      vergrößert wurde, als dritte Partition neu erstellt werden.</para>

    <para>Deaktivieren Sie Swap-Speicher Partition:</para>

    <screen>&prompt.root; <userinput>swapoff <replaceable>/dev/ada0p3</replaceable></userinput></screen>

    <para>Löschen Sie die dritte Partition, angegeben mit dem Schalter
      <option>-i</option>, der Festplatte
      <replaceable>ada0</replaceable>:</para>

    <screen>&prompt.root; <userinput>gpart delete -i <replaceable>3</replaceable> <replaceable>ada0</replaceable></userinput>
ada0p3 deleted
&prompt.root; <userinput>gpart show <replaceable>ada0</replaceable></userinput>
=>       34  102399933  ada0  GPT  (48G)
         34        128     1  freebsd-boot  (64k)
        162   79691648     2  freebsd-ufs  (38G)
	79691810   22708157        - free -  (10G)</screen>

    <warning>
      <para>Es besteht die Gefahr von Datenverlust, wenn die
	Partitionstabelle eines eingehangenen Dateisystems verändert
	wird.  Es empfiehlt sich daher, die folgenden Schritte auf
	einem ausgehangenen Dateisystem durchzuführen, während die
	Umsetzung über eine Live-<acronym>CD-ROM</acronym> oder
	von einem <acronym>USB</acronym>-Gerät erfolgt.  Wenn es
	jedoch absolut notwendig ist, kann ein eingehangenes
	Dateisystem auch vergrößert werden, nachdem die
	Sicherheitsfunktionen von GEOM deaktiviert wurden:</para>

      <screen>&prompt.root; <userinput>sysctl kern.geom.debugflags=16</userinput></screen>
    </warning>

    <para>Vergrößern Sie die Partition und lassen Sie Platz, um die
      Swap-Partition in der gewünschten Größe neu erstellen zu können.
      Die zu ändernde Partition wird mit <option>-i</option> und die
      neue gewünschte Größe mit <option>-s</option> angegeben.
      Optional wird die Ausrichtung der Partition mit
      <option>-a</option> festgelegt.  Dieser Schritt ändert nur die
      Größe der Partition.  Das Dateisystem innerhalb der Partition
      wird in einem separaten Schritt erweitert.</para>

    <screen>&prompt.root; <userinput>gpart resize -i <replaceable>2</replaceable> -s <replaceable>47G</replaceable> -a 4k <replaceable>ada0</replaceable></userinput>
ada0p2 resized
&prompt.root; <userinput>gpart show <replaceable>ada0</replaceable></userinput>
=>       34  102399933  ada0  GPT  (48G)
         34        128     1  freebsd-boot  (64k)
        162   98566144     2  freebsd-ufs  (47G)
   98566306    3833661        - free -  (1.8G)</screen>

    <para>Erstellen Sie die Swap-Partition neu und aktivieren Sie
      sie:</para>

    <screen>&prompt.root; <userinput>gpart add -t freebsd-swap -a 4k <replaceable>ada0</replaceable></userinput>
ada0p3 added
&prompt.root; <userinput>gpart show <replaceable>ada0</replaceable></userinput>
=>       34  102399933  ada0  GPT  (48G)
         34        128     1  freebsd-boot  (64k)
        162   98566144     2  freebsd-ufs  (47G)
   98566306    3833661     3  freebsd-swap  (1.8G)
&prompt.root; <userinput>swapon <replaceable>/dev/ada0p3</replaceable></userinput></screen>

    <para>Erweitern Sie das <acronym>UFS</acronym>-Dateisystem, um die
      Kapazität der vergrößerten Partition zu nutzen:</para>

    <screen>&prompt.root; <userinput>growfs <replaceable>/dev/ada0p2</replaceable></userinput>
Device is mounted read-write; resizing will result in temporary write suspension for /.
It's strongly recommended to make a backup before growing the file system.
OK to grow file system on /dev/ada0p2, mounted on /, from 38GB to 47GB? [Yes/No] <userinput>Yes</userinput>
super-block backups (for fsck -b #) at:
 80781312, 82063552, 83345792, 84628032, 85910272, 87192512, 88474752,
 89756992, 91039232, 92321472, 93603712, 94885952, 96168192, 97450432</screen>

    <para>Wenn das Dateisystem <acronym>ZFS</acronym> ist, wird die
      Größenänderung mit dem Unterkommando <option>online</option> und
      <option>-e</option> ausgelöst:</para>

    <screen>&prompt.root; <userinput>zfs online -e <replaceable>zroot</replaceable> <replaceable>/dev/ada0p2</replaceable></userinput></screen>

    <para>Sowohl die Partition als auch das Dateisystem wurden jetzt
      vergrößert, um den neu zur Verfügung stehenden Speicherplatz zu
      nutzen.</para>
  </sect1>

  <sect1 xml:id="usb-disks">
    <info>
      <title><acronym>USB</acronym> Speichermedien</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Marc</firstname>
	    <surname>Fonvieille</surname>
	  </personname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>USB</primary>
      <secondary>Speichermedien</secondary>
    </indexterm>

    <para>Der Universal Serial Bus (<acronym>USB</acronym>) wird
      von vielen externen Speichern benutzt:  Festplatten,
      <acronym>USB</acronym>-Thumbdrives sowie von
      <acronym>CD</acronym>- und <acronym>DVD</acronym>-Brennern.
      &os; bietet Unterstützung für Geräte mit <acronym>USB</acronym>
      1.x, 2.0 und 3.0.</para>

    <note>
      <para>Die Unterstützung für <acronym>USB</acronym> 3.0 ist mit
	einiger Hardware, einschließlich Haswell (Lynx Point)
	Chipsätzen, nicht kompatibel.  Wenn &os; beim Booten mit dem
	Fehler <errorname>failed with error 19</errorname> abbricht,
	müssen Sie xHCI/USB3 im <acronym>BIOS</acronym>
	deaktivieren.</para>
    </note>

    <para>Unterstützung für <acronym>USB</acronym>-Massenspeicher ist
      im <filename>GENERIC</filename>-Kernel enthalten.  Für einen
      angepassten Kernel müssen die nachstehenden Zeilen in der
      Kernelkonfigurationsdatei enthalten sein:</para>

    <programlisting>device scbus    # SCSI bus (required for ATA/SCSI)
device da	# Direct Access (disks)
device pass	# Passthrough device (direct ATA/SCSI access)
device uhci	# provides USB 1.x support
device ohci	# provides USB 1.x support
device ehci	# provides USB 2.0 support
device xhci	# provides USB 3.0 support
device usb	# USB Bus (required)
device umass	# Disks/Mass storage - Requires scbus and da
device cd	# needed for CD and DVD burners</programlisting>

    <para>&os; benutzt den &man.umass.4;-Treiber, der das
      <acronym>SCSI</acronym>-Subsystem verwendet um auf
      <acronym>USB</acronym>-Geräte zuzugreifen.  Da alle
      <acronym>USB</acronym>-Geräte vom System als
      <acronym>SCSI</acronym>-Geräte erkannt werden, dürfen Sie
      <emphasis>nicht</emphasis> <option>device atapicam</option>
      in die Kernelkonfigurationsdatei aufnehmen, wenn es sich bei
      dem Gerät um einen <acronym>CD</acronym>- oder
      <acronym>DVD</acronym>-Brenner handelt.</para>

    <para>Der übrige Abschnitt beschreibt, wie Sie überprüfen können
      ob ein <acronym>USB</acronym>-Gerät von &os; erkannt wird und
      wie Sie das Gerät so konfigurieren, dass es verwendet werden
      kann.</para>

    <sect2>
      <title>Konfiguration von Geräten</title>

      <para>Um die <acronym>USB</acronym>-Konfiguration zu testen,
	schließen Sie das <acronym>USB</acronym>-Gerät an.
	Verwenden Sie <command>dmesg</command> um zu überprüfen, ob
	das Gerät in den Systemmeldungen erscheint.  Dies sollte in
	etwa so aussehen:</para>

      <screen>umass0: &lt;STECH Simple Drive, class 0/0, rev 2.00/1.04, addr 3&gt; on usbus0
umass0:  SCSI over Bulk-Only; quirks = 0x0100
umass0:4:0:-1: Attached to scbus4
da0 at umass-sim0 bus 0 scbus4 target 0 lun 0
da0: &lt;STECH Simple Drive 1.04&gt; Fixed Direct Access SCSI-4 device
da0: Serial Number WD-WXE508CAN263
da0: 40.000MB/s transfers
da0: 152627MB (312581808 512 byte sectors: 255H 63S/T 19457C)
da0: quirks=0x2&lt;NO_6_BYTE&gt;</screen>

      <para>Fabrikat, Gerätedatei (<filename>da0</filename>),
	Geschwindigkeit und Kapazität werden je nach Gerät
	unterschiedlich sein.</para>

      <para>Da ein <acronym>USB</acronym>-Gerät als
	<acronym>SCSI</acronym>-Gerät erkannt wird, kann
	<command>camcontrol</command> benutzt werden, um die mit dem
	System verbundenen <acronym>USB</acronym>-Massenspeicher
	anzuzeigen:</para>

      <screen>&prompt.root; <userinput>camcontrol devlist</userinput>
&lt;STECH Simple Drive 1.04&gt;          at scbus4 target 0 lun 0 (pass3,da0)</screen>

      <para>Alternativ kann <command>usbconfig</command> benutzt
	werden, um die Geräte aufzulisten.  Weitere Informationen zu
	diesem Kommando finden Sie in &man.usbconfig.8;.</para>

      <screen>&prompt.root; <userinput>usbconfig</userinput>
ugen0.3: &lt;Simple Drive STECH&gt; at usbus0, cfg=0 md=HOST spd=HIGH (480Mbps) pwr=ON (2mA)</screen>

      <para>Wenn das Gerät noch nicht formatiert ist, finden Sie in
	<xref linkend="disks-adding"/> Informationen, wie Sie
	<acronym>USB</acronym>-Laufwerke formatieren und Partitionen
	einrichten.  Wenn das Laufwerk bereits ein Dateisystem
	enthält, kann es von <systemitem
	  class="username">root</systemitem> nach den Anweisungen in
	<xref linkend="mount-unmount"/> eingehängt werden.</para>

      <warning>
        <para>Aus Sicherheitsgründen sollten Sie Benutzern, denen Sie
	  nicht vertrauen, das Einhängen (z.B. durch die unten
	  beschriebene Aktivierung von
	  <literal>vfs.usermount</literal>) beliebiger Medien
	  verbieten.  Die meisten Dateisysteme wurden nicht
	  entwickelt, um sich vor böswilligen Geräten zu
	  schützen.</para>
      </warning>

      <para>Um auch normalen Anwendern das Einhängen des Laufwerks zu
	gestatten, könnten Sie beispielsweise mit &man.pw.8; alle
	potentiellen Benutzer dieser Gerätedateien in die Gruppe
	<systemitem class="groupname">operator</systemitem> aufnehmen.
	Außerdem muss sichergestellt werden, dass <systemitem
	  class="groupname">operator</systemitem>
	Schreib- und Lesezugriff auf diese Gerätedateien haben.
	Hierfür werden die folgenden Zeilen in
	<filename>/etc/devfs.rules</filename> hinzugefügt:</para>

      <programlisting>[localrules=5]
add path 'da*' mode 0660 group operator</programlisting>

      <note>
	<para>Verfügt das System über interne
	  <acronym>SCSI</acronym>-Laufwerke, so verändern Sie die
	  zweite Zeile wie folgt:</para>

	<programlisting>add path 'da[<replaceable>3</replaceable>-9]*' mode 0660 group operator</programlisting>

	<para>Dies wird die ersten drei
	  <acronym>SCSI</acronym>-Laufwerke (<filename>da0</filename>
	  bis <filename>da2</filename>) davon ausschließen, in die
	  Gruppe <systemitem class="groupname">operator</systemitem>
	  aufgenommen zu werden.  Ersetzen Sie <literal>3</literal>
	  durch die Anzahl der <acronym>SCSI</acronym>-Laufwerke.
	  Weitere Informationen zu dieser Datei finden Sie in
	  &man.devfs.rules.5;.</para>
      </note>

      <para>Aktivieren Sie nun die Regeln
	in <filename>/etc/rc.conf</filename>:</para>

      <programlisting>devfs_system_ruleset="localrules"</programlisting>

      <para>Als nächstes müssen Sie das System anweisen, auch
	normalen Benutzern das mounten von Dateisystemen zu erlauben,
	indem Sie die folgende Zeile in
	<filename>/etc/sysctl.conf</filename> hinzufügen:</para>

      <programlisting>vfs.usermount=1</programlisting>

      <para>Da diese Einstellung erst nach einem Neustart wirksam
	wird, können Sie diese Variable mit <command>sysctl</command>
	auch direkt setzen:</para>

      <screen>&prompt.root; <userinput>sysctl vfs.usermount=1</userinput>
vfs.usermount: 0 -&gt; 1</screen>

      <para>Zuletzt müssen Sie noch ein Verzeichnis anlegen, in
	das das <acronym>USB</acronym>-Laufwerk eingehängt werden
	soll.  Dieses Verzeichnis muss dem Benutzer gehören, der das
	<acronym>USB</acronym>-Laufwerk in den Verzeichnisbaum
	einhängen will.  Dazu legen Sie als <systemitem
	  class="username">root</systemitem> ein
	Unterverzeichnis
	<filename>/mnt/<replaceable>username</replaceable></filename>
	an, wobei Sie <replaceable>username</replaceable>
	durch den Login des jeweiligen Benutzers sowie
	<replaceable>usergroup</replaceable> durch die primäre
	Gruppe des Benutzers ersetzen:</para>

      <screen>&prompt.root; <userinput>mkdir /mnt/<replaceable>username</replaceable></userinput>
&prompt.root; <userinput>chown <replaceable>username</replaceable>:<replaceable>usergroup</replaceable> /mnt/<replaceable>username</replaceable></userinput></screen>

      <para>Wenn Sie nun beispielsweise einen
	<acronym>USB</acronym>-Stick
	anschließen, wird automatisch die Gerätedatei
	<filename>/dev/da0s1</filename> erzeugt.  Ist das Gerät mit
	einem <acronym>FAT</acronym>-Dateisystem formatiert, kann es
	der Benutzer mit dem folgenden Befehl in den Verzeichnisbaum
	einhängen:</para>

      <screen>&prompt.user; <userinput>mount -t msdosfs -o -m=644,-M=755 /dev/da0s1 /mnt/<replaceable>username</replaceable></userinput></screen>

      <para>Bevor das Gerät entfernt werden kann,
	<emphasis>muss</emphasis> es abgehängt werden:</para>

      <screen>&prompt.root; <userinput>umount /mnt/<replaceable>username</replaceable></userinput></screen>

      <para>Nach Entfernen des Geräts stehen in den Systemmeldungen
	Einträge, ähnlich der folgenden:</para>

      <screen>umass0: at uhub3, port 2, addr 3 (disconnected)
da0 at umass-sim0 bus 0 scbus4 target 0 lun 0
da0: &lt;STECH Simple Drive 1.04&gt; s/n WD-WXE508CAN263          detached
(da0:umass-sim0:0:0:0): Periph destroyed</screen>
    </sect2>

    <sect2>
      <title>Automatisches Einhängen von Wechselmedien</title>

      <para>Damit <acronym>USB</acronym>-Geräte automatisch
	eingehängt werden, muss der Kommentar für folgende Zeile in
	<filename>/etc/auto_master</filename> entfernt werden:</para>

      <screen>/media		-media		-nosuid</screen>

      <para>Anschließend fügen Sie folgende Zeilen in
	<filename>/etc/devd.conf</filename> hinzu:</para>

      <screen>notify 100 {
	match "system" "GEOM";
	match "subsystem" "DEV";
	action "/usr/sbin/automount -c";
};</screen>

      <para>Falls &man.autofs.5; und &man.devd.8; bereits
	ausgeführt werden, müssen Sie die Konfiguration neu
	einlesen:</para>

      <screen>&prompt.root; <userinput>service automount restart</userinput>
&prompt.root; <userinput>service devd restart</userinput></screen>

      <para>&man.autofs.5; wird beim Booten automatisch gestartet,
	wenn Sie folgende Zeile in <filename>/etc/rc.conf</filename>
	hinzufügen:</para>

      <programlisting>autofs_enable="YES"</programlisting>

      <para>Damit &man.autofs.5; funktioniert, muss &man.devd.8;
	aktiviert sein, was aber in der Voreinstellung der Fall
	ist.</para>

      <para>Starten Sie jetzt die Dienste:</para>

      <screen>&prompt.root; <userinput>service automount start</userinput>
&prompt.root; <userinput>service automountd start</userinput>
&prompt.root; <userinput>service autounmountd start</userinput>
&prompt.root; <userinput>service devd start</userinput></screen>

      <para>Jedes Dateisystem, das automatisch eingehängt werden kann,
	erscheint als ein Verzeichnis unterhalb von
	<filename>media</filename>.  Das Verzeichnis wird nach dem
	Dateisystemlabel benannt, bzw. nach dem Gerätenamen, falls
	kein Label existiert.</para>

      <para>Das Dateisystem wird transparent beim ersten Zugriff in
	den Verzeichnisbaum eingehängt und auch nach gewisser Zeit der
	Inaktivität wieder ausgehängt.  Laufwerke können auch manuell
	ausgehängt werden:</para>

      <screen>&prompt.root; <userinput>automount -fu</userinput></screen>

      <para>Diese Methode wird in der Regel bei Speicherkarten und
	<acronym>USB</acronym>-Sticks verwendet.  Sie funktioniert
	aber mit allen Blockgeräten, einschließlich optischen
	Laufwerken und
	<acronym>iSCSI</acronym>-<acronym>LUN</acronym>s.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="creating-cds">
    <info>
      <title>Erstellen und Verwenden
	von <acronym>CD</acronym>s</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Mike</firstname>
	    <surname>Meyer</surname>
	  </personname>
	  <contrib>Beigesteuert von </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary><acronym>CD-ROM</acronym>s</primary>
      <secondary>brennen</secondary>
    </indexterm>

      <para><acronym>CD</acronym>s besitzen einige Eigenschaften, die
	sie von konventionellen Laufwerken unterscheiden.  Sie wurden
	so entworfen, dass sie ununterbrochen, ohne Verzögerungen
	durch Kopfbewegungen zwischen den Spuren, gelesen werden
	können.  <acronym>CD</acronym>s besitzen Spuren, aber damit
	ist der Teil Daten gemeint, der ununterbrochen gelesen wird,
	und nicht eine physikalische Eigenschaft der
	<acronym>CD</acronym>.  Das <acronym>ISO</acronym>
	9660-Dateisystem wurde entworfen, um mit diesen Unterschieden
	umzugehen.</para>

      <indexterm>
	<primary><acronym>ISO</acronym> 9660</primary>
      </indexterm>
      <indexterm>
	<primary>Dateisysteme</primary>
	<secondary>ISO 9660</secondary>
      </indexterm>

      <indexterm>
	<primary><acronym>CD</acronym>-Brenner</primary>
	<secondary><acronym>ATAPI</acronym></secondary>
      </indexterm>

      <para>Die &os; Ports-Sammlung bietet einige Werkzeuge zum
	Brennen und Kopieren von Audio- und
	Daten-<acronym>CD</acronym>s.  Dieses Kapitel beschreibt die
	Verwendung von mehreren Kommandozeilen-Werkzeugen.  Wenn Sie
	eine graphische Oberfläche zum Brennen von
	<acronym>CD</acronym>s benutzen, können Sie
	<package>sysutils/xcdroast</package> oder
	<package>sysutils/k3b</package> installieren.</para>

      <sect2 xml:id="atapicam">
	<info>
	  <title>Unterstützte Geräte</title>

	  <authorgroup>
	    <author>
	      <personname>
		<firstname>Marc</firstname>
		<surname>Fonvielle</surname>
	      </personname>
	      <contrib>Beigetragen von </contrib>
	    </author>
	  </authorgroup>
	</info>

	<indexterm>
	  <primary><acronym>CD</acronym>-Brenner</primary>
	  <secondary>ATAPI/CAM Treiber</secondary>
	</indexterm>

	<para>Der <filename>GENERIC</filename>-Kernel enthält
	  Unterstützung für <acronym>SCSI</acronym>,
	  <acronym>USB</acronym> und <acronym>ATAPI</acronym>
	  <acronym>CD</acronym> Lesegeräte und Brenner.  Wird ein
	  angepasster Kernel erstellt, unterscheiden sich die Optionen
	  für die Kernelkonfigurationsdatei je nach Art des
	  Geräts.</para>

	<para>Für einen <acronym>SCSI</acronym>-Brenner müssen
	  folgende Optionen vorhanden sein:</para>

	<programlisting>device scbus	  # SCSI bus (required for ATA/SCSI)
device da	  # Direct Access (disks)
device pass	  # Passthrough device (direct ATA/SCSI access)
device cd	  # needed for CD and DVD burners</programlisting>

	<para>Für einen <acronym>USB</acronym>-Brenner müssen folgende
	  Optionen vorhanden sein:</para>

	<programlisting>device scbus	  # SCSI bus (required for ATA/SCSI)
device da	  # Direct Access (disks)
device pass	  # Passthrough device (direct ATA/SCSI access)
device cd>	  # needed for CD and DVD burners
device uhci	  # provides USB 1.x support
device ohci	  # provides USB 1.x support
device ehci	  # provides USB 2.0 support
device xhci	  # provides USB 3.0 support
device usb	  # USB Bus (required)
device umass	  # Disks/Mass storage - Requires scbus and da</programlisting>

	<para>Für einen <acronym>ATAPI</acronym>-Brenner müssen
	  folgende Optionen vorhanden sein:</para>

	<programlisting>device ata	  # Legacy ATA/SATA controllers
device scbus	  # SCSI bus (required for ATA/SCSI)
device pass	  # Passthrough device (direct ATA/SCSI access)
device cd	  # needed for CD and DVD burners</programlisting>


	<note>
	  <para>Unter &os; Versionen kleiner 10.x wird auch diese
	    Option in der Kernelkonfigurationsdatei benötigt, falls
	    der Brenner ein <acronym>ATAPI</acronym>-Gerät ist:</para>

	  <programlisting>device atapicam</programlisting>

	  <para>Alternativ kann folgende Zeile in
	    <filename>/boot/loader.conf</filename> hinzugefügt werden,
	    um den Treiber beim Booten automatisch zu laden:</para>

	  <programlisting>atapicam_load="YES"</programlisting>

	  <para>Hierzu ist ein Neustart des Systems erforderlich, da
	    dieser Treiber nur beim Booten geladen werden kann.</para>
	</note>

	<para>Mit <command>dmesg</command> können Sie prüfen, ob das
	  Gerät von &os; erkannt wurde.  Unter &os; Versionen kleiner
	  10.x lautet der Gerätename <filename>acd0</filename>
	  anstelle von <filename>cd0</filename>.</para>

	<screen>&prompt.user; <userinput>dmesg | grep cd</userinput>
cd0 at ahcich1 bus 0 scbus1 target 0 lun 0
cd0: &lt;HL-DT-ST DVDRAM GU70N LT20&gt; Removable CD-ROM SCSI-0 device
cd0: Serial Number M3OD3S34152
cd0: 150.000MB/s transfers (SATA 1.x, UDMA6, ATAPI 12bytes, PIO 8192bytes)
cd0: Attempt to query device size failed: NOT READY, Medium not present - tray closed</screen>
    </sect2>

    <sect2 xml:id="cdrecord">
      <title>Eine <acronym>CD</acronym> brennen</title>

      <para>Unter &os; kann <command>cdrecord</command> zum Brennen
	von <acronym>CD</acronym>s benutzt werden.  Dieses Programm
	wird aus dem Port oder Paket
	<package>sysutils/cdrtools</package> installiert.</para>

      <para>Obwohl <command>cdrecord</command> viele Optionen besitzt,
	ist die grundlegende Benutzung sehr einfach.  Geben Sie den
	Namen der zu brennenden ISO-Datei an.  Wenn das System über
	mehrere Brenner verfügt, müssen Sie auch den Namen des
	Gerätes angeben:</para>

      <screen>&prompt.root; <userinput>cdrecord <replaceable>dev=device</replaceable> <replaceable>imagefile.iso</replaceable></userinput></screen>

      <para>Benutzen Sie <option>-scanbus</option> um den Gerätenamen
	des Brenners zu bestimmen.  Die Ausgabe könnte wie folgt
	aussehen:</para>

      <indexterm>
	<primary><acronym>CD-ROM</acronym></primary>
	<secondary>brennen</secondary>
      </indexterm>

      <screen>&prompt.root; <userinput>cdrecord -scanbus</userinput>
ProDVD-ProBD-Clone 3.00 (amd64-unknown-freebsd10.0) Copyright (C) 1995-2010 Jörg Schilling
Using libscg version 'schily-0.9'
scsibus0:
        0,0,0     0) 'SEAGATE ' 'ST39236LW       ' '0004' Disk
        0,1,0     1) 'SEAGATE ' 'ST39173W        ' '5958' Disk
        0,2,0     2) *
        0,3,0     3) 'iomega  ' 'jaz 1GB         ' 'J.86' Removable Disk
        0,4,0     4) 'NEC     ' 'CD-ROM DRIVE:466' '1.26' Removable CD-ROM
        0,5,0     5) *
        0,6,0     6) *
        0,7,0     7) *
scsibus1:
        1,0,0   100) *
        1,1,0   101) *
        1,2,0   102) *
        1,3,0   103) *
        1,4,0   104) *
        1,5,0   105) 'YAMAHA  ' 'CRW4260         ' '1.0q' Removable CD-ROM
        1,6,0   106) 'ARTEC   ' 'AM12S           ' '1.06' Scanner
        1,7,0   107) *</screen>

      <para>Benutzen Sie die drei durch Kommas separierten Zahlen, die
	für den <acronym>CD</acronym>-Brenner angegeben sind, als
	Argument für <option>dev</option>.  Im Beispiel ist das
	Yamaha-Gerät <literal>1,5,0</literal>, so dass die passende
	Eingabe <option>dev=1,5,0</option> ist.  Einfachere Wege das
	Argument anzugeben, sowie Informationen über Audiospuren und
	das Einstellen der Geschwindigkeit, sind in der Manualpage von
	<command>cdrecord</command> beschrieben.</para>

      <para>Alternativ können Sie den folgenden Befehl ausführen, um
	die Geräteadresse des Brenners zu ermitteln:</para>

      <screen>&prompt.root; <userinput>camcontrol devlist</userinput>
&lt;MATSHITA CDRW/DVD UJDA740 1.00&gt;   at scbus1 target 0 lun 0 (cd0,pass0)</screen>

      <para>Verwenden Sie die numerischen Werte für
	<literal>scbus</literal>, <literal>target</literal> und
	<literal>lun</literal>.  Für dieses Beispiel wäre
	<literal>1,0,0</literal> als Gerätename zu verwenden.</para>
    </sect2>

    <sect2 xml:id="mkisofs">
      <title>Daten auf <acronym>ISO</acronym>-Dateisystem
	schreiben</title>

      <para>Die Datendateien müssen vorbereitet sein, bevor sie auf
	eine <acronym>CD</acronym> gebrannt werden.  In &os; wird
	<command>mkisofs</command> vom Paket oder Port
	<package>sysutils/cdrtools</package> installiert.  Dieses
	Programm kann aus einem &unix; Verzeichnisbaum ein
	<acronym>ISO</acronym> 9660-Dateisystem erzeugen.  Im
	einfachsten Fall müssen Sie lediglich den Namen der zu
	erzeugenden <acronym>ISO</acronym>-Datei und den Pfad zu den
	Dateien angeben, die auf dem <acronym>ISO</acronym>
	9660-Dateisystem platziert werden:</para>

      <screen>&prompt.root; <userinput>mkisofs -o <replaceable>imagefile.iso</replaceable> <replaceable>/path/to/tree</replaceable></userinput></screen>

      <indexterm>
	<primary>Dateisysteme</primary>
	<secondary>ISO 9660</secondary>
      </indexterm>

      <para>Bei diesem Kommando werden die Dateinamen auf Namen
	abgebildet, die den Restriktionen des <acronym>ISO</acronym>
	9660-Dateisystem entsprechen.  Dateien, die diesem Standard
	nicht entsprechen bleiben unberücksichtigt.</para>

      <indexterm>
	<primary>Dateisysteme</primary>
	<secondary>Joliet</secondary>
      </indexterm>

      <para>Es gibt einige Optionen, um die Beschränkungen dieses
	Standards zu überwinden.  Die unter &unix; Systemen üblichen
	Rock-Ridge-Erweiterungen werden durch <option>-R</option>
	aktiviert und <option>-J</option> aktiviert die von
	&microsoft; Systemen benutzten Joliet-Erweiterungen.</para>

      <para>Für <acronym>CD</acronym>s, die nur auf &os;-Systemen
	verwendet werden sollen, kann <option>-U</option> genutzt
	werden, um alle Beschränkungen für Dateinamen aufzuheben.
	Zusammen mit <option>-R</option> wird ein Abbild des
	Dateisystems, identisch zu angegebenen &os;-Dateibaum
	erstellt, selbst wenn dies den <acronym>ISO</acronym> 9660
	Standard verletzt.</para>

      <indexterm>
	<primary><acronym>CD-ROM</acronym></primary>
	<secondary>bootbare erstellen</secondary>
      </indexterm>

      <para>Die letzte übliche Option ist <option>-b</option>.
	Sie wird benutzt, um den Ort eines Bootimages einer
	<quote>El Torito</quote> bootbaren <acronym>CD</acronym>
	anzugeben.  Das Argument zu dieser Option ist der Pfad zu
	einem Bootimage ausgehend von der Wurzel des Baumes, der auf
	die <acronym>CD</acronym> geschrieben werden soll.  In der
	Voreinstellung erzeugt <command>mkisofs</command> ein
	<acronym>ISO</acronym>-Image im
	<quote>Diskettenemulations</quote>-Modus.  Dabei muss das
	Image genau 1200, 1440 oder 2880&nbsp;KB groß sein.  Einige
	Bootloader, darunter der auf den &os; Installationsmedien
	verwendete, kennen keinen Emulationsmodus.  Daher sollte in
	diesen Fällen <option>-no-emul-boot</option> verwendet werden.
	Wenn <filename>/tmp/myboot</filename> ein bootbares
	&os;-System enthält, dessen Bootimage sich in
	<filename>/tmp/myboot/boot/cdboot</filename> befindet, dann
	würde folgendes Kommando
	<filename>/tmp/bootable.iso</filename> erstellen:</para>

      <screen>&prompt.root; <userinput>mkisofs -R -no-emul-boot -b boot/cdboot -o /tmp/bootable.iso /tmp/myboot</userinput></screen>

      <para>Das resultierende <acronym>ISO</acronym>-Abbild kann als
	speicherbasiertes Laufwerk eingehängt werden:</para>

      <screen>&prompt.root; <userinput>mdconfig -a -t vnode -f /tmp/bootable.iso -u 0</userinput>
&prompt.root; <userinput>mount -t cd9660 /dev/md0 /mnt</userinput></screen>

      <para>Jetzt können Sie überprüfen, dass
	<filename>/mnt</filename> und <filename>/tmp/myboot</filename>
	identisch sind.</para>

      <para>Sie können das Verhalten von <command>mkisofs</command>
	mit einer Vielzahl von Optionen beeinflussen.  Details dazu
	entnehmen Sie bitte &man.mkisofs.8;.</para>

      <note>
	<para>Es ist möglich eine Daten-<acronym>CD</acronym> in eine
	  Datei zu kopieren, die einem Image entspricht, das mit
	  <command>mkisofs</command> erstellt wurde.  Verwenden Sie
	  dazu <command>dd</command> mit dem Gerätenamen als
	  Eingabedatei und den Namen der <acronym>ISO</acronym> als
	  Ausgabedatei:</para>

	<screen>&prompt.root; <userinput>dd if=/dev/<replaceable>cd0</replaceable> of=<replaceable>file.iso</replaceable> bs=2048</userinput></screen>

	<para>Das resultierende Abbild kann auf eine
	  <acronym>CD</acronym> gebrannt werden, wie in <xref
	    linkend="cdrecord"/> beschrieben.</para>
      </note>
    </sect2>

    <sect2 xml:id="mounting-cd">
      <title>Einhängen von Daten-<acronym>CD</acronym>s</title>

      <para>Sobald ein Abbild auf eine <acronym>CD</acronym> gebrannt
	wurde, kann es durch Angabe des Dateisystemtyp, des
	<acronym>CD</acronym>-Laufwerks und des Mountpunktes
	eingehangen werden:</para>

      <screen>&prompt.root; <userinput>mount -t cd9660 <replaceable>/dev/cd0</replaceable> <replaceable>/mnt</replaceable></userinput></screen>

      <para>Da <command>mount</command> davon ausgeht, dass ein
	Dateisystem vom Typ <literal>ufs</literal> ist, würde die
	Fehlermeldung <errorname>Incorrect super block</errorname>
	erscheinen, wenn Sie beim Einhängen einer
	Daten-<acronym>CD</acronym> auf die Angabe
	<literal>-t cd9660</literal> verzichten.</para>

      <para>Auf diese Weise können Daten-<acronym>CD</acronym>s
	von jedem Hersteller verwendet werden.  Es kann allerdings zu
	Problemen mit <acronym>CD</acronym>s kommen, die verschiedene
	<acronym>ISO</acronym> 9660-Erweiterungen benutzen.  So
	speichern Joliet-<acronym>CD</acronym>s alle Dateinamen unter
	Verwendung von zwei Byte langen Unicode-Zeichen.  Tauchen
	statt bestimmter Zeichen nur Fragezeichen auf, so
	muss über die Option <option>-C</option> der benötigte
	Zeichensatz angegeben werden.  Weitere Informationen zu
	diesem Problem finden Sie in &man.mount.cd9660.8;.</para>

      <note>
	<para>Damit der Kernel diese Zeichenkonvertierung (festgelegt
	  durch die Option <option>-C</option>) erkennt, müssen Sie
	  das Kernelmodul <filename>cd9660_iconv.ko</filename> laden.
	  Dazu fügen Sie folgende Zeile in
	  <filename>loader.conf</filename> ein:</para>

	<programlisting>cd9660_iconv_load="YES"</programlisting>

	<para>Danach müssen Sie allerdings Ihr System neu starten.
	  Alternativ können Sie das Kernelmodul auch direkt
	  über <command>kldload</command> laden.</para>
      </note>

      <para>Manchmal werden Sie die Meldung
	<errorname>Device not configured</errorname> erhalten, wenn
	Sie versuchen, eine Daten-<acronym>CD</acronym> einzuhängen.
	Für gewöhnlich liegt das daran, dass das Laufwerk keine
	<acronym>CD</acronym> erkannt hat, oder dass das Laufwerk
	auf dem Bus nicht erkannt wird.  Es kann einige Sekunden
	dauern, bevor das Laufwerk die <acronym>CD</acronym> erkennt.
	Seien Sie also geduldig.</para>

      <para>Manchmal wird ein
	<acronym>SCSI</acronym>-<acronym>CD</acronym> nicht
	erkannt, weil es keine Zeit hatte, auf das Zurücksetzen des
	Busses zu antworten.  Um dieses Problem zu lösen, fügen Sie
	die folgende Zeile in die Kernelkonfiguration ein und
	erstellen Sie einen angepassten Kernel nach den Anweisungen in
	<xref linkend="kernelconfig-building"/>:</para>

      <programlisting>options SCSI_DELAY=15000</programlisting>

      <para>Die Zeile bewirkt, dass nach dem Zurücksetzen des
	<acronym>SCSI</acronym>-Busses beim Booten 15 Sekunden
	gewartet wird, um dem
	<acronym>CD</acronym>-Laufwerk genügend Zeit zu geben,
	darauf zu antworten.</para>

      <note>
	<para>Es ist möglich eine Datei auch direkt auf eine
	  <acronym>CD</acronym> zu brennen, ohne vorher auf ihr ein
	  <acronym>ISO</acronym> 9660-Dateisystem einzurichten.  Man
	  sagt auch, Daten werden roh auf die <acronym>CD</acronym>
	  gebrannt.  Einige Leute nutzen dies, um Datensicherungen
	  durchzuführen.</para>

	<para>Eine auf diese Weise gefertigte
	  Daten-<acronym>CD</acronym> kann nicht in das Dateisystem
	  eingehangen werden.  Um auf die Daten einer solchen
	  <acronym>CD</acronym> zuzugreifen, müssen die Daten vom
	  rohen Gerät gelesen werden.  Beispielsweise würde dieser
	  Befehl eine komprimierte tar-Datei auf dem zweiten
	  <acronym>CD</acronym>-Laufwerk in das aktuelle Verzeichnis
	  extrahieren:</para>

	<screen>&prompt.root; <userinput>tar xzvf /dev/<replaceable>cd1</replaceable></userinput></screen>

	<para>Um eine Daten-<acronym>CD</acronym> in das System
	  einzuhängen, müssen die Daten mit <command>mkisofs</command>
	  geschrieben werden.</para>
      </note>
    </sect2>

    <sect2 xml:id="duplicating-audiocds">
      <title>Kopieren von Audio-<acronym>CD</acronym>s</title>

      <para>Um eine Kopie einer Audio-<acronym>CD</acronym> zu
	erstellen, kopieren Sie die Stücke der <acronym>CD</acronym>
	in einzelne Dateien und brennen diese Dateien dann auf eine
	leere <acronym>CD</acronym>.</para>

      <para><xref linkend="using-cdrecord"/> beschreibt, wie eine
	Audio-<acronym>CD</acronym> kopiert und gebrannt wird.  Wenn
	die Version älter als &os; 10.0 ist und ein
	<acronym>ATAPI</acronym>-Gerät verwendet wird, muss zunächst
	das Modul <option>atapicam</option> nach den Anweisungen in
	<xref linkend="atapicam"/> geladen werden.</para>

      <procedure xml:id="using-cdrecord">
	<title>Eine Audio-<acronym>CD</acronym> kopieren</title>

	<step>
	  <para>Der Port oder das Paket
	    <package>sysutils/cdrtools</package> installiert
	    <command>cdda2wav</command>.  Mit diesem Kommando können
	    Audiodaten in das aktuelle Verzeichnis extrahiert werden,
	    wobei jede Datei in eine separate
	    <acronym>WAV</acronym>-Datei geschrieben wird:</para>

	  <screen>&prompt.user; <userinput>cdda2wav -vall -B -Owav</userinput></screen>

	  <para>Wenn das System nur über ein
	    <acronym>CD</acronym>-Laufwerk verfügt, muss der
	    Gerätename nicht angegeben werden.  Lesen Sie die
	    Manualpage von <command>cdda2wav</command> für
	    Anweisungen, wie ein Gerät spezifiziert wird und weitere
	    verfügbare Optionen für dieses Kommando.</para>
	</step>

	<step>
	  <para>Die erzeugten <filename>.wav</filename> Dateien
	    schreiben Sie mit <command>cdrecord</command> auf eine
	    leere <acronym>CD</acronym>:</para>

	  <screen>&prompt.user; <userinput>cdrecord -v dev=<replaceable>2,0</replaceable> -dao -useinfo *.wav</userinput></screen>

	  <para>Das Argument von <option>dev</option> gibt das
	    verwendete Gerät an, das wie in <xref linkend="cdrecord"/>
	    ermittelt werden kann.</para>
	</step>
      </procedure>
    </sect2>
  </sect1>

  <sect1 xml:id="creating-dvds">
    <info>
      <title><acronym>DVD</acronym>s benutzen</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Marc</firstname>
	    <surname>Fonvieille</surname>
	  </personname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <personname>
	    <firstname>Andy</firstname>
	    <surname>Polyakov</surname>
	  </personname>
	  <contrib>Mit Beiträgen von </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary><acronym>DVD</acronym></primary>
      <secondary>brennen</secondary>
    </indexterm>

    <para>Nach der <acronym>CD</acronym> ist die
      <acronym>DVD</acronym> die nächste Generation optischer
      Speichermedien.  Auf einer <acronym>DVD</acronym> können
      mehr Daten als auf einer <acronym>CD</acronym> gespeichert
      werden.  <acronym>DVD</acronym>s werden als Standardmedium für
      Videos verwendet.</para>

    <para>Für beschreibbare <acronym>DVD</acronym>s existieren fünf
      Medienformate:</para>

    <itemizedlist>
      <listitem>
	<para>DVD-R:  Dies war das erste verfügbare Format.  Das
	  Format wurde vom <link
	    xlink:href="http://www.dvdforum.org/forum.shtml">
	    <acronym>DVD</acronym>-Forum</link> festgelegt.  Die Medien sind nur einmal
	  beschreibbar.</para>
      </listitem>

      <listitem>
	<para><acronym>DVD-RW</acronym>:  Dies ist die
	  wiederbeschreibbare Version des DVD-R Standards.  Eine
	  <acronym>DVD-RW</acronym> kann ungefähr
	  1000&nbsp;Mal beschrieben werden.</para>
      </listitem>

      <listitem>
	<para><acronym>DVD-RAM</acronym>:  Dies ist ein
	  wiederbeschreibbares Format, das wie ein Wechsellaufwerk
	  betrachtet werden kann.  Allerdings sind die Medien nicht
	  kompatibel zu den meisten
	  <acronym>DVD-ROM</acronym>-Laufwerken und
	  DVD-Video-Spielern, da das
	  <acronym>DVD-RAM-Format</acronym> nur von wenigen Brennern
	  unterstützt wird.  Informationen zur Nutzung von
	  <acronym>DVD-RAM</acronym> finden Sie in
	  <xref linkend="creating-dvd-ram"/>.</para>
      </listitem>

      <listitem>
	<para><acronym>DVD+RW</acronym>:  Ist ein
	  wiederbeschreibbares Format, das von der <link
	    xlink:href="https://de.wikipedia.org/wiki/DVD%2BRW_Alliance">
	    <acronym>DVD+RW</acronym> Alliance</link> festgelegt
	  wurde.  Eine <acronym>DVD+RW</acronym> kann ungefähr
	  1000&nbsp;Mal beschrieben werden.</para>
      </listitem>

      <listitem>
	<para>DVD+R:  Dieses Format ist die nur einmal beschreibbare
	  Variante des <acronym>DVD+RW</acronym> Formats.</para>
      </listitem>
    </itemizedlist>

    <para>Auf einer einfach beschichteten <acronym>DVD</acronym>
      können 4.700.000.000&nbsp;Bytes gespeichert werden.  Das
      sind 4,38&nbsp;GB oder 4485&nbsp;MB (1&nbsp;Kilobyte
      sind 1024&nbsp;Bytes).</para>

    <note>
      <para>Die physischen Medien sind unabhängig von der Anwendung.
	Ein DVD-Video ist eine spezielle Anordnung von Dateien, die
	auf irgendein Medium, beispielsweise DVD-R, DVD+R oder
	<acronym>DVD-RW</acronym> geschrieben werden kann.  Bevor Sie
	ein Medium auswählen, müssen Sie sicherstellen, dass der
	Brenner und der DVD-Spieler mit dem Medium umgehen
	können.</para>
    </note>

    <sect2>
      <title>Konfiguration</title>

      <para>Benutzen Sie &man.growisofs.1;, um <acronym>DVD</acronym>s
	zu beschreiben.  Das Kommando ist Bestandteil von
	<package>sysutils/dvd+rw-tools</package>, und kann mit allen
	<acronym>DVD</acronym>-Medien umgehen.</para>

      <para>Diese Werkzeuge verwenden das
	<acronym>SCSI</acronym>-Subsystem, um auf die Geräte
	zuzugreifen.  Daher muss <link
	  linkend="atapicam">ATAPI/CAM-Unterstützung</link>
	geladen, oder statisch in den Kernel kompiliert werden.
	Sollte der Brenner jedoch die
	<acronym>USB</acronym>-Schnittstelle nutzen, wird diese
	Unterstützung nicht benötigt.  Weitere Informationen zur
	Konfiguration von <acronym>USB</acronym>-Geräten finden Sie in
	<xref linkend="usb-disks"/>.</para>

      <para>Für <acronym>ATAPI</acronym>-Geräte müssen ebenfalls
	DMA-Zugriffe aktiviert werden.  Dazu wird die folgende Zeile
	in <filename>/boot/loader.conf</filename> eingefügt:</para>

      <programlisting>hw.ata.atapi_dma="1"</programlisting>

      <para>Bevor Sie <application>dvd+rw-tools</application>
	benutzen, lesen Sie bitte die
	Hardware-Informationen auf der Seite <link
	  xlink:href="http://fy.chalmers.se/~appro/linux/DVD+RW/hcn.html">Hardware
	  Compatibility Notes</link>.</para>

      <note>
	<para>Für eine grafische Oberfläche sollten Sie sich
	  <package>sysutils/k3b</package> ansehen, das eine
	  benutzerfreundliche Schnittstelle zu &man.growisofs.1; und
	  vielen anderen Werkzeugen bietet.</para>
      </note>
    </sect2>

    <sect2>
      <title>Daten-<acronym>DVD</acronym>s brennen</title>

      <para>&man.growisofs.1; erstellt mit dem Programm
	<link linkend="mkisofs">mkisofs</link> das Dateisystem
	und brennt anschließend die <acronym>DVD</acronym>.  Vor dem
	Brennen braucht daher kein Abbild der Daten erstellt zu
	werden.</para>

      <para>Wenn Sie von den Daten im Verzeichnis
	<filename>/path/to/data</filename> eine
	DVD+R oder eine DVD-R brennen wollen, benutzen Sie
	das nachstehende Kommando:</para>

      <screen>&prompt.root; <userinput>growisofs -dvd-compat -Z <replaceable>/dev/cd0</replaceable> -J -R <replaceable>/path/to/data</replaceable></userinput></screen>

      <para>In diesem Beispiel wird <option>-J -R</option> an
	&man.mkisofs.8; durchgereicht und dient zum Erstellen
	des Dateisystems (hier:  ein ISO-9660-Dateisystem mit
	Joliet- und Rock-Ridge-Erweiterungen).  Weiteres
	entnehmen Sie bitte der Hilfeseite &man.mkisofs.8;.</para>

      <para>Die Option <option>-Z</option> wird für die erste
	Aufnahme einer Single- oder Multisession benötigt.  Ersetzen
	Sie <replaceable>/dev/cd0</replaceable> mit dem Gerätenamen
	des <acronym>DVD</acronym>-Gerätes.  Die Nutzung von
	<option>-dvd-compat</option> schließt das Medium, weitere
	Daten können danach nicht mehr angehängt werden.  Dies sollte
	auch eine bessere Kompatibilität mit anderen
	<acronym>DVD-ROM</acronym>-Laufwerken bieten.</para>

      <para>Um ein vorher erstelltes Abbild der Daten zu brennen,
	beispielsweise <replaceable>imagefile.iso</replaceable>,
	verwenden Sie:</para>

      <screen>&prompt.root; <userinput>growisofs -dvd-compat -Z <replaceable>/dev/cd0</replaceable>=<replaceable>imagefile.iso</replaceable></userinput></screen>

      <para>Die Schreibgeschwindigkeit hängt von den
	verwendeten Medium sowie dem verwendeten Gerät ab
	und sollte automatisch gesetzt werden.  Um die
	Schreibgeschwindigkeit vorzugeben, verwenden Sie
	<option>-speed=</option>.  Beispiele finden Sie in
	&man.growisofs.1;.</para>

      <note>
	<para>Um größere Dateien als 4.38GB zu unterstützen, ist es
	  notwendig ein UDF/ISO-9660 Hybrid-Dateisystem zu erstellen.
	  Dieses Dateisystem muss mit zusätzlichen Parametern
	  <option>-udf -iso-level 3</option> bei &man.mkisofs.8; und
	  allen relevanten Programmen, wie beispielsweise
	  &man.growisofs.1;) erzeugt werden.  Dies ist nur notwendig,
	  wenn Sie ein ISO-Image erstellen oder direkt auf eine DVD
	  schreiben wollen.  DVDs, die in dieser Weise hergestellt
	  worden sind, müssen als UDF-Dateisystem mit
	  &man.mount.udf.8; eingehangen werden.  Sie sind nur auf
	  Betriebssystemen, die UDF unterstützen brauchbar, ansonsten
	  sieht es so aus, als ob sie kaputte Dateien enthalten
	  würden.</para>

	<para>Um diese Art von ISO-Datei zu erstellen:</para>

	<screen>&prompt.user; <userinput>mkisofs -R -J -udf -iso-level 3 -o <replaceable>imagefile.iso</replaceable> <replaceable>/path/to/data</replaceable>
</userinput></screen>

	<para>Um Daten direkt auf eine DVD zu brennen, geben Sie den
	  folgenden Befehl ein:</para>

	<screen>&prompt.root; <userinput>growisofs -dvd-compat -udf -iso-level 3 -Z <replaceable>/dev/cd0</replaceable> -J -R <replaceable>/path/to/data</replaceable>
</userinput></screen>

	<para>Wenn ein ISO-Abbild bereits große Dateien enthält, sind
	  keine weiteren Optionen für &man.growisofs.1; notwendig, um
	  das Abbild auf die DVD zu brennen.</para>

	<para>Achten Sie darauf, eine aktuelle Version von
	  <package>sysutils/cdrtools</package> zu verwenden, welche
	  &man.mkisofs.8; enthält, da ältere Versionen keinen Support
	  für große Dateien enthalten.  Falls die neueste Version
	  nicht funktioniert, installieren Sie
	  <package>sysutils/cdrtools-devel</package> und lesen Sie
	  &man.mkisofs.8;.</para>
      </note>
    </sect2>

    <sect2>
      <title><acronym>DVD</acronym>-Videos brennen</title>

      <indexterm>
	<primary><acronym>DVD</acronym></primary>
	<secondary>DVD-Video</secondary>
      </indexterm>

      <para>Ein DVD-Video ist eine spezielle Anordnung von Dateien,
	die auf den ISO-9660 und den micro-UDF (M-UDF) Spezifikationen
	beruht.  Da DVD-Video auf eine bestimmte Datei-Hierarchie
	angewiesen ist, müssen <acronym>DVD</acronym>s mit speziellen
	Programmen wie <package>multimedia/dvdauthor</package>
	erstellt werden.</para>

      <para>Ist bereits ein Abbild des Dateisystems eines
	DVD-Videos vorhanden, kann es auf die gleiche Weise wie jedes
	andere Abbild gebrannt werden.  Wenn
	<command>dvdauthor</command> verwendet wurde, um die
	<acronym>DVD</acronym> zu erstellen und die Resultate in
	<filename>/path/to/video</filename> liegen, kann das folgende
	Kommando verwendet werden, um ein DVD-Video zu brennen:</para>

      <screen>&prompt.root; <userinput>growisofs -Z <replaceable>/dev/cd0</replaceable> -dvd-video <replaceable>/path/to/video</replaceable></userinput></screen>

      <para><option>-dvd-video</option> wird an &man.mkisofs.8;
	weitergereicht, um die Datei-Hierarchie für ein DVD-Video zu
	erstellen.  Weiterhin bewirkt diese Option, dass
	&man.growisofs.1; mit <option>-dvd-compat</option> aufgerufen
	wird.</para>
    </sect2>

    <sect2>
      <title><acronym>DVD+RW</acronym>-Medien benutzen</title>

      <indexterm>
	<primary><acronym>DVD</acronym></primary>
	<secondary><acronym>DVD+RW</acronym></secondary>
      </indexterm>

      <para>Im Gegensatz zu CD-RW-Medien müssen
	<acronym>DVD+RW</acronym>-Medien
	erst formatiert werden, bevor sie benutzt werden können.
	Es wird <emphasis>empfohlen</emphasis> &man.growisofs.1;
	einzusetzen, da das Programm Medien automatisch formatiert,
	wenn es erforderlich ist.  Es ist jedoch möglich, auch
	<command>dvd+rw-format</command> zu nutzen, um die
	<acronym>DVD+RW</acronym> zu formatieren:</para>

      <screen>&prompt.root; <userinput>dvd+rw-format <replaceable>/dev/cd0</replaceable></userinput></screen>

      <para>Dieser Vorgang muss nur einmal durchgeführt werden.
	Denken Sie daran, dass nur neue DVD+RWs formatiert werden
	müssen.  Anschließend können <acronym>DVD+RW</acronym>s, wie
	gewohnt gebrannt werden.</para>

      <para>Wenn Sie auf einer <acronym>DVD+RW</acronym> ein neues
	Dateisystem erstellen wollen, brauchen Sie die
	<acronym>DVD+RW</acronym> vorher nicht zu
	löschen.  Überschreiben Sie einfach das vorige Dateisystem
	indem Sie eine neue Session anlegen:</para>

      <screen>&prompt.root; <userinput>growisofs -Z <replaceable>/dev/cd0</replaceable> -J -R <replaceable>/path/to/newdata</replaceable></userinput></screen>

      <para>Das <acronym>DVD+RW</acronym>-Format erlaubt es, Daten an
	eine vorherige Aufnahme anzuhängen.  Dazu wird eine neue
	Session mit der schon bestehenden zusammengeführt.
	Es wird keine Multi-Session geschrieben, sondern
	&man.growisofs.1; <emphasis>vergrößert</emphasis>
	das ISO-9660-Dateisystem auf dem Medium.</para>

      <para>Das folgende Kommando fügt weitere Daten zu
	einer vorher erstellten <acronym>DVD+RW</acronym>
	hinzu:</para>

      <screen>&prompt.root; <userinput>growisofs -M <replaceable>/dev/cd0</replaceable> -J -R <replaceable>/path/to/nextdata</replaceable></userinput></screen>

      <para>Wenn Sie eine <acronym>DVD+RW</acronym> erweitern,
	verwenden Sie dieselben &man.mkisofs.8;-Optionen wie beim
	Erstellen der <acronym>DVD+RW</acronym>.</para>

      <note>
	<para>Verwenden Sie <option>-dvd-compat</option>, um bessere
	  Kompatibilität mit <acronym>DVD-ROM</acronym>-Laufwerken zu
	  gewährleisten.  Zu einem <acronym>DVD+RW</acronym>-Medium
	  können Sie mit dieser Option auch weiterhin Daten
	  hinzufügen.</para>
      </note>

      <para>Um das Medium zu löschen, verwenden Sie:</para>

      <screen>&prompt.root; <userinput>growisofs -Z <replaceable>/dev/cd0</replaceable>=<replaceable>/dev/zero</replaceable></userinput></screen>
    </sect2>

    <sect2>
      <title><acronym>DVD-RW</acronym>-Medien benutzen</title>

      <indexterm>
	<primary><acronym>DVD</acronym></primary>
	<secondary><acronym>DVD-RW</acronym></secondary>
      </indexterm>

      <para>Eine <acronym>DVD-RW</acronym> kann mit zwei Methoden
	beschrieben werden:
	<firstterm>Sequential-Recording</firstterm> oder
	<firstterm>Restricted-Overwrite</firstterm>.  Voreingestellt
	ist Sequential-Recording.</para>

      <para>Eine neue <acronym>DVD-RW</acronym> kann direkt
	beschrieben werden; sie muss nicht vorher formatiert werden.
	Allerdings muss eine <acronym>DVD-RW</acronym>, die mit
	Sequential-Recording aufgenommen wurde, zuerst gelöscht
	werden, bevor eine neue Session aufgenommen werden
	kann.</para>

      <para>Der folgende Befehl löscht eine <acronym>DVD-RW</acronym>
	im Sequential-Recording-Modus:</para>

      <screen>&prompt.root; <userinput>dvd+rw-format -blank=full <replaceable>/dev/cd0</replaceable></userinput></screen>

      <note>
	<para>Das vollständige Löschen mit
	  <option>-blank=full</option> dauert mit einem
	  1x&nbsp;Medium ungefähr eine Stunde.  Wenn die
	  <acronym>DVD-RW</acronym> im Disk-At-Once-Modus (DAO)
	  aufgenommen wurde, kann sie mit <option>-blank</option>
	  schneller gelöscht werden.  Um eine
	  <acronym>DVD-RW</acronym> im DAO-Modus zu brennen, benutzen
	  Sie das folgende Kommando:</para>

	<screen>&prompt.root; <userinput>growisofs -use-the-force-luke=dao -Z <replaceable>/dev/cd0</replaceable>=<replaceable>imagefile.iso</replaceable>
</userinput></screen>

	<para>Die Option <option>-use-the-force-luke=dao</option>
	  sollte nicht erforderlich sein, da &man.growisofs.1;
	  den DAO-Modus automatisch erkennt.</para>

	<para>Der Restricted-Overwrite-Modus sollte mit jeder
	  <acronym>DVD-RW</acronym> verwendet werden, da er flexibler
	  als der voreingestellte Sequential-Recording-Modus
	  ist.</para>
      </note>

      <para>Um Daten auf eine <acronym>DVD-RW</acronym> im
	Sequential-Recording-Modus zu schreiben, benutzen Sie dasselbe
	Kommando wie für die anderen
	<acronym>DVD</acronym>-Formate:</para>

      <screen>&prompt.root; <userinput>growisofs -Z <replaceable>/dev/cd0</replaceable> -J -R <replaceable>/path/to/data</replaceable></userinput></screen>

      <para>Um weitere Daten zu einer Aufnahme hinzuzufügen, benutzen
	Sie <option>-M</option> mit &man.growisofs.1;.  Werden die
	Daten im Sequential-Recording-Modus hinzugefügt, wird eine
	neue Session erstellt.  Das Ergebnis ist ein
	Multi-Session-Medium.</para>

      <para>Eine <acronym>DVD-RW</acronym> im
	Restricted-Overwrite-Modus muss nicht gelöscht werden, um eine
	neue Session aufzunehmen.  Das Medium kann einfach mit
	<option>-Z</option> überschrieben werden.  Mit
	<option>-M</option> kann das ISO-9660-Dateisystem, wie mit
	einer <acronym>DVD+RW</acronym>, vergrößert werden.
	Die <acronym>DVD</acronym> enthält danach eine Session.</para>

      <para>Benutzen sie das nachstehende Kommando, um den
	Restricted-Overwrite-Modus einzustellen:</para>

      <screen>&prompt.root; <userinput>dvd+rw-format <replaceable>/dev/cd0</replaceable></userinput></screen>

      <para>Das folgende Kommando stellt den Modus wieder auf
	Sequential-Recording zurück:</para>

      <screen>&prompt.root; <userinput>dvd+rw-format -blank=full <replaceable>/dev/cd0</replaceable></userinput></screen>
    </sect2>

    <sect2>
      <title>Multi-Session</title>

      <para>Nur wenige <acronym>DVD-ROM</acronym>-Laufwerke
	unterstützen Multi-Session-DVDs und lesen meist nur die erste
	Session.  Mehrere Sessions werden von DVD+R, DVD-R und
	<acronym>DVD-RW</acronym> im Sequential-Recording-Modus
	unterstützt.  Im Modus Restricted-Overwrite gibt nur eine
	Session.</para>

      <para>Wenn das Medium noch nicht geschlossen ist, erstellt das
	nachstehende Kommando eine neue Session auf einer DVD+R, DVD-R
	oder <acronym>DVD-RW</acronym> im
	Sequential-Recording-Modus:</para>

      <screen>&prompt.root; <userinput>growisofs -M <replaceable>/dev/cd0</replaceable> -J -R <replaceable>/path/to/nextdata</replaceable></userinput></screen>

      <para>Wird dieses Kommando mit <acronym>DVD+RW</acronym>- oder
	<acronym>DVD-RW</acronym>-Medien im Restricted-Overwrite-Modus
	benutzt, werden die neuen Daten mit
	den Daten der bestehenden Session zusammengeführt.  Das Medium
	enthält danach eine Session.  Nutzen Sie diese Methode, um
	neue Daten zu einer bestehenden Session hinzuzufügen.</para>

      <note>
	<para>Für den Anfang und das Ende einer Session wird auf dem
	  Medium zusätzlicher Platz verbraucht.  Um den Speicherplatz
	  auf dem Medium optimal auszunutzen, sollten Sie daher
	  Sessions mit vielen Daten hinzufügen.  Auf ein DVD+R-Medium
	  passen maximal 154&nbsp;Sessions, 2000&nbsp;Sessions auf ein
	  DVD-R-Medium und 127&nbsp;Sessions auf eine DVD+R Double
	  Layer.</para>
      </note>
    </sect2>

    <sect2>
      <title>Weiterführendes</title>

      <para><command>dvd+rw-mediainfo
	  <replaceable>/dev/cd0</replaceable></command> zeigt
	Informationen über eine im Laufwerk liegende
	<acronym>DVD</acronym> an.</para>

      <para>Weiteres zu <application>dvd+rw-tools</application>
	finden Sie in &man.growisofs.1;, auf der <link
	  xlink:href="http://fy.chalmers.se/~appro/linux/DVD+RW/">
	  dvd+rw-tools Web-Seite</link> und in den Archiven
	der <link xlink:href="http://lists.debian.org/cdwrite/">
	  cdwrite-Mailingliste</link>.</para>

      <note>
	<para>Wenn Sie einen Problembericht zur Nutzung der
	  <application>dvd+rw-tools</application> erstellen, fügen Sie
	  immer die Ausgabe von <command>dvd+rw-mediainfo</command>
	  hinzu.</para>
      </note>
    </sect2>

    <sect2 xml:id="creating-dvd-ram">
      <title><acronym>DVD-RAM</acronym></title>

      <indexterm>
	<primary><acronym>DVD</acronym></primary>
	<secondary><acronym>DVD-RAM</acronym></secondary>
      </indexterm>

      <para><acronym>DVD-RAM</acronym>-fähige Brenner nutzten die
	<acronym>SCSI</acronym>- oder
	<acronym>ATAPI</acronym>-Schnittstelle.  Für
	<acronym>ATAPI</acronym>-Geräte muss der DMA-Modus aktiviert
	werden, indem die folgende Zeile in
	<filename>/boot/loader.conf</filename> hinzugefügt
	wird:</para>

      <programlisting>hw.ata.atapi_dma="1"</programlisting>

      <para>Eine <acronym>DVD-RAM</acronym> kann mit einer
	Wechselplatte verglichen werden.  Wie diese, muss auch eine
	<acronym>DVD-RAM</acronym> vor dem ersten
	Einsatz formatiert werden.  In diesem Beispiel wird das
	gesamte Medium mit dem Standard-UFS2-Dateisystem
	formatiert:</para>

      <screen>&prompt.root; <userinput>dd if=/dev/zero of=<replaceable>/dev/acd0</replaceable> bs=2k count=1</userinput>
&prompt.root; <userinput>bsdlabel -Bw <replaceable>acd0</replaceable></userinput>
&prompt.root; <userinput>newfs <replaceable>/dev/acd0</replaceable></userinput></screen>

      <para>Denken Sie dabei daran, dass Sie gegebenenfalls die
	Gerätedatei (hier <filename>acd0</filename>) an
	Ihre Konfiguration anpassen müssen.</para>

      <para>Nachdem die <acronym>DVD-RAM</acronym> formatiert ist,
	kann sie wie eine normale Festplatte gemountet
	werden:</para>

      <screen>&prompt.root; <userinput>mount <replaceable>/dev/acd0</replaceable> <replaceable>/mnt</replaceable></userinput></screen>

      <para>Danach kann schreibend und lesend auf das
	<acronym>DVD-RAM</acronym> Medium zugegriffen werden.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="floppies">
    <title>Disketten benutzen</title>

<!--
      <authorgroup>
	<author>
	  <personname>
	    <firstname>Julio</firstname>
	    <surname>Merino</surname>
	  </personname>
	  <contrib>Original von </contrib>
	</author>
      </authorgroup>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Martin</firstname>
	    <surname>Karlsson</surname>
	  </personname>
	  <contrib>Umgeschrieben von </contrib>
	</author>
      </authorgroup>
-->

    <para>Dieser Abschnitt beschreibt die Formatierung
      von 3,5&nbsp;Zoll Disketten in &os;.</para>

    <procedure>
      <title>Disketten formatieren</title>

      <para>Bevor eine Diskette benutzt werden kann, muss sie
	(low-level) formatiert werden, was normalerweise der
	Hersteller schon gemacht hat.  Sie können die Diskette
	allerdings noch einmal formatieren, um das Medium zu
	überprüfen.  Benutzen Sie &man.fdformat.1;, um Disketten
	unter &os; zu formatieren.  Achten Sie dabei auf
	Fehlermeldungen, die schlechte Speichermedien
	anzeigen.</para>

      <step>
	<para>Um eine Diskette zu formatieren, legen Sie eine
	  3,5&nbsp;Zoll Diskette in das erste Diskettenlaufwerk ein
	  und führen das folgende Kommando aus:</para>

	<screen>&prompt.root; <userinput>/usr/sbin/fdformat -f 1440 /dev/fd0</userinput></screen>
      </step>

      <step>
	<para>Nach dem Formatieren muss auf der Diskette ein
	  Disklabel erstellt werden, um die Größe und Geometrie der
	  Diskette zu erkennen.  Eine Liste der unterstützten
	  Geometrien finden Sie in
	  <filename>/etc/disktab</filename>.</para>

	<para>Erstellen Sie nun das Label mit &man.bsdlabel.8;:</para>

	<screen>&prompt.root; <userinput>/sbin/bsdlabel -B -w /dev/fd0 fd1440</userinput></screen>
      </step>

      <step>
	<para>Auf der Diskette kann nun ein Dateisystem erstellt
	  werden (high-level Formatierung).  Das Dateisystem der
	  Diskette kann entweder UFS oder FAT sein, wobei FAT für
	  Disketten in der Regel die bessere Wahl ist.</para>

	<para>Um die Diskette mit FAT zu formatieren, geben Sie
	  folgendes Kommando ein:</para>

	<screen>&prompt.root; <userinput>/sbin/newfs_msdos /dev/fd0</userinput></screen>
      </step>
    </procedure>

    <para>Die Diskette kann nun benutzt werden.  Um die Diskette
      zu verwenden, kann sie mit &man.mount.msdosfs.8; eingehängt
      werden.  Man kann auch <package>emulators/mtools</package> aus
      der Ports-Sammlung installieren, um mit der Diskette zu
      arbeiten.</para>
  </sect1>

  <sect1 xml:id="backup-basics">
    <title>Datensicherung</title>

    <!--
      <authorgroup>
	<author>
	  <personname>
	    <firstname>Lowell</firstname>
	    <surname>Gilbert</surname>
	  </personname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
      -->

    <para>Die Planung und Umsetzung einer Backup-Strategie ist
      unerlässlich, um Daten in bestimmten Situationen
      wiederherstellen zu können, zum Beispiel bei Plattendefekten,
      versehentlichem Löschen von Dateien, willkürlicher Korrumpierung
      von Dateien oder der vollständigen Zerstörung des Systems und
      der Backups, die am gleichen Ort aufbewahrt werden.</para>

    <para>Die Art und der Zeitplan des Backups kann variieren,
      abhängig von der Wichtigkeit der Daten, der benötigten
      Granularität zur Wiederherstellung von Dateien und der
      Dauer einer akzeptablen Ausfallzeit.  Zu den möglichen
      Backup-Strategien gehören unter anderem:</para>

    <itemizedlist>
      <listitem>
	<para>Die Archivierung des kompletten Systems auf externen
	  Datenträgern.  Dieser Ansatz schützt zwar vor allen oben
	  aufgeführten Problemen, ist aber zeitaufwändig und unbequem
	  bei der Wiederherstellung, insbesondere für nicht
	  privilegierte Benutzer.</para>
      </listitem>

      <listitem>
	<para>Dateisystem-Snapshots sind nützlich bei der
	  Wiederherstellung von gelöschten Dateien, bzw. früheren
	  Versionen von Dateien.</para>
      </listitem>

      <listitem>
	<para>Kopien ganzer Dateisysteme oder Festplatten, die mit
	  einem anderen System im Netzwerk mittels
	  <package>net/rsync</package> synchronisiert werden.</para>
      </listitem>

      <listitem>
	<para>Hardware oder Software <acronym>RAID</acronym>, was im
	  Falle von Plattendefekten die Ausfallzeit minimiert oder
	  vermeidet.</para>
      </listitem>
    </itemizedlist>

    <para>Üblicherweise wird eine Mischung aus verschiedenen
      Strategien verwendet.  Es kann zum Beispiel ein Sicherungsplan
      erstellt und automatisiert werden,  um eine wöchentliche,
      vollständige Systemsicherung, ergänzt mit stündlichen
      ZFS-Snapshots, zu erstellen.  Darüber hinaus könnte man
      eine manuelle Sicherung einzelner Verzeichnisse oder Dateien
      machen, bevor diese bearbeitet oder gelöscht werden.</para>

    <para>Dieser Abschnitt beschreibt einige Programme, die zur
      Erstellung und Verwaltung von Sicherungen unter &os; verwendet
      werden können.</para>

    <sect2>
      <title>Sicherung von Dateisystemen</title>

      <indexterm>
	<primary>Backup-Software</primary>
	<secondary>dump / restore</secondary>
      </indexterm>
      <indexterm>
	<primary><command>dump</command></primary>
      </indexterm>
      <indexterm>
	<primary><command>restore</command></primary>
      </indexterm>

      <para>Die traditionellen &unix;-Programme zum Sichern und
	Wiederherstellen von Dateisystemen sind &man.dump.8; und
	&man.restore.8;.  Diese Programme arbeiten auf der Block-Ebene
	der Festplatte, also unterhalb des Abstraktionslevels von
	Dateien, Links und Verzeichnissen, die die Grundlage des
	Dateisystemkonzepts bilden.  Im Gegensatz zu anderen
	Backup-Programmen sichert <command>dump</command> ein ganzes
	Dateisystem und nicht nur einen Teil des Dateisystems, oder
	einen Verzeichnisbaum, der mehr als ein Dateisystem umfasst.
	Anstatt Dateien oder Verzeichnisse zu schreiben, schreibt
	<command>dump</command> die Blöcke, aus denen die Dateien und
	Verzeichnisse bestehen.</para>

      <note>
	<para>Wird <command>dump</command> benutzt, um das
	  Root-Verzeichnis zu sichern, werden
	  <filename>/home</filename>, <filename>/usr</filename> und
	  viele andere Verzeichnisse nicht gesichert, da dies
	  normalerweise Mountpunkte für andere Dateisysteme oder
	  symbolische Links zu diesen Dateisystemen sind.</para>
      </note>

      <para>Wenn <command>restore</command> zum Extrahieren von Daten
	verwendet wird, werden temporäre Dateien standardmäßig in
	<filename>/tmp</filename> abgelegt.  Wenn Sie von einer Platte
	mit einem kleinen <filename>/tmp</filename>-Verzeichnis
	zurücksichern, setzen Sie die Umgebungsvariable
	<envar>TMPDIR</envar> auf ein Verzeichnis mit mehr freiem
	Speicherplatz, damit die Wiederherstellung gelingt.</para>

      <para>Beachten Sie bei der Verwendung von
	<command>dump</command>, dass es einige Eigenarten aus den
	frühen Tagen der Version 6 von AT&amp;T &unix; (ca. 1975)
	beibehalten hat.  Die Standardparameter gehen davon aus, dass
	auf einem 9-Spur-Band gesichert wird, und nicht auf ein
	anderes Medium oder auf Sicherungsbänder mit hoher Dichte.
	Diese Standardwerte müssen auf der Kommandozeile überschrieben
	werden.</para>

      <indexterm>
	<primary><filename>.rhosts</filename></primary>
      </indexterm>

      <para>Es ist möglich, das Dateisystem über das Netzwerk auf
	einem anderen Rechner zu sichern, oder auf einem Bandlaufwerk
	eines anderen Rechners.  Obwohl die Programme &man.rdump.8;
	und &man.rrestore.8; für diese Zwecke benutzt werden können,
	gelten sie als nicht sicher.</para>

      <para>Verwenden Sie stattdessen <command>dump</command> und
	<command>restore</command> in einer sichereren Weise über eine
	<acronym>SSH</acronym>-Verbindung.  In diesem Beispiel wird
	eine vollständige, komprimierte Sicherung von
	<filename>/usr</filename> erstellt, das
	anschließend an einen bestimmten Host über eine
	<acronym>SSH</acronym>-Verbindung gesendet wird.</para>

      <example>
	<title><command>dump</command> mit
	  <application>ssh</application> benutzen</title>

	<screen>&prompt.root; <userinput>/sbin/dump -0uan -f - /usr | gzip -2 | ssh -c blowfish \
	  targetuser@targetmachine.example.com dd of=/mybigfiles/dump-usr-l0.gz</userinput></screen>
      </example>

      <para>In diesem Beispiel wird <envar>RSH</envar> gesetzt, um
	über eine <acronym>SSH</acronym>-Verbindung eine Sicherung auf
	ein Bandlaufwerk eines entfernten Systems zu schreiben:</para>

      <example>
	<title><command>dump</command> über
	  <application>ssh</application> mit gesetzter
	  <envar>RSH</envar> benutzen</title>

	<screen>&prompt.root; <userinput>env RSH=/usr/bin/ssh /sbin/dump -0uan -f tatargetuser@targetmachine.example.com:/dev/sa0 /usr</userinput></screen>
      </example>
    </sect2>

    <sect2>
      <title>Sicherung von Verzeichnissen</title>

      <indexterm>
	<primary>Backup-Software</primary>
	<secondary><command>tar</command></secondary>
      </indexterm>

      <para>Einige integrierte Werkzeuge stehen zur Sicherung
	und Wiederherstellung von bestimmten Dateien und
	Verzeichnissen bei Bedarf zur Verfügung.</para>

      <para>Wenn es um die Sicherung von Dateien in einem Verzeichnis
	geht, ist &man.tar.1; eine gute Wahl.  Dieses Werkzeug stammt
	aus Version 6 von AT&amp;T &unix; und erwartet standardmäßig
	eine rekursive Sicherung auf ein lokales Band.  Es können
	jedoch Optionen angegeben werden, um den Namen einer
	Sicherungsdatei zu bestimmen.</para>

      <indexterm><primary><command>tar</command></primary></indexterm>

      <para>In diesem Beispiel wird eine komprimierte Sicherung des
	aktuellen Verzeichnisses nach
	<filename>/tmp/mybackup.tgz</filename> gespeichert.  Achten
	Sie bei der Sicherungsdatei darauf, dass sie nicht in dem
	Verzeichnis gespeichert wird, welches gesichert werden
	soll.</para>

      <example>
	<title>Das aktuelle Verzeichnis mit <command>tar</command>
	  sichern</title>

	<screen>&prompt.root; <userinput>tar czvf <replaceable>/tmp/mybackup.tgz</replaceable> .</userinput></screen>
      </example>

      <para>Um eine komplette Sicherung wiederherzustellen, wechseln
	Sie mit <command>cd</command> in das Verzeichnis, in dem Sie
	die Daten wiederherstellen möchten und geben Sie den Namen der
	Sicherungsdatei an.  Beachten Sie, dass dabei alle Dateien in
	dem Verzeichnis überschrieben werden.  Im Zweifel sichern Sie
	besser in einem temporären Verzeichnis, oder geben Sie den
	Verzeichnisnamen bei der Wiederherstellung an.</para>

      <example>
	<title>Wiederherstellung mit <command>tar</command> in das
	  aktuelle Verzeichnis</title>

	<screen>&prompt.root; <userinput>tar xzvf <replaceable>/tmp/mybackup.tgz</replaceable></userinput></screen>
      </example>

      <para>Es gibt dutzende Optionen, die in &man.tar.1; beschrieben
	werden.  Das Programm unterstützt auch die Verwendung von
	Ausschlußmustern, um bestimmte Dateien von der Sicherung oder
	Wiederherstellung von Verzeichnissen auszuschließen.</para>

      <indexterm>
	<primary>Backup-Software</primary>
	<secondary><command>cpio</command></secondary>
      </indexterm>

      <para>Um bestimmte, aufgelistete Dateien und Verzeichnisse zu
	sichern, ist &man.cpio.1; eine gute Wahl.  Im Gegensatz zu
	<command>tar</command> weiß <command>cpio</command> nicht
	wie ein Verzeichnisbaum durchlaufen wird.  Daher ist es auf
	eine Liste von zu sichernden Dateien angewiesen.</para>

      <para>So kann beispielsweise eine Liste von Dateien mit
	<command>ls</command> oder <command>find</command> erzeugt
	werden.  Dieses Beispiel erstellt eine rekursive Liste des
	aktuellen Verzeichnisses, die dann über eine Pipe an
	<command>cpio</command> übergeben wird, um eine Sicherung
	namens <filename>/tmp/mybackup.cpio</filename> zu
	erstellen.</para>

      <example>
	<title>Rekursive Sicherung des aktuellen Verzeichnisses mit
	  <command>ls</command> und <command>cpio</command></title>

	<screen>&prompt.root; <userinput>ls -R | cpio -ovF /tmp/mybackup.cpio</userinput></screen>
      </example>

      <indexterm>
	<primary>Backup-Software</primary>
	<secondary><command>pax</command></secondary>
      </indexterm>
      <indexterm><primary><command>pax</command></primary></indexterm>
      <indexterm><primary>POSIX</primary></indexterm>
      <indexterm><primary>IEEE</primary></indexterm>

      <para>&man.pax.1; ist ein Programm, welches versucht die
	Funktionen von <command>tar</command> und
	<command>cpio</command> zu kombinieren.  Über die Jahre
	hinweg sind die verschiedenen Versionen von
	<command>tar</command> und <command>cpio</command> leicht
	inkompatibel geworden.  Daher hat &posix;
	<command>pax</command> geschaffen, welches versucht viele
	der unterschiedlichen <command>cpio</command>- und
	<command>tar</command>-Formate zu lesen und zu schreiben,
	außerdem einige neue, eigene Formate.</para>

      <para>Für die vorangegangenen Beispiele wäre ein äquivalenter
	Aufruf von <command>pax</command>:</para>

      <example>
	<title>Das aktuelle Verzeichnis mit <command>pax</command>
	  sichern</title>

	<screen>&prompt.root; <userinput>pax -wf <replaceable>/tmp/mybackup.pax</replaceable> .</userinput></screen>
      </example>
    </sect2>

    <sect2 xml:id="backups-tapebackups">
      <title>Bandmedien benutzen</title>

      <indexterm><primary>Bandmedien</primary></indexterm>

      <para>Obwohl sich Bandmedien mit der Zeit weiterentwickelt
	haben, verwenden moderne Backup-Systeme in der Regel
	<foreignphrase>Offsite-Backups</foreignphrase> in Verbindung
	mit lokalen Wechseldatenträgern.  &os; unterstützt alle
	<acronym>SCSI</acronym>-Bandlaufwerke, wie etwa
	<acronym>LTO</acronym> und <acronym>DAT</acronym>.  Zusätzlich
	gibt es begrenzte Unterstützung für <acronym>SATA</acronym>-
	und <acronym>USB</acronym>-Bandlaufwerke.</para>

      <para>Für <acronym>SCSI</acronym>-Bandlaufwerke nutzt &os; den
	&man.sa.4; Treiber, der die Schnittstellen
	<filename>/dev/sa0</filename>, <filename>/dev/nsa0</filename>
	und <filename>/dev/esa0</filename> bereitstellt.  Der Name des
	physikalischen Geräts ist <filename>/dev/sa0</filename>.
	Wird <filename>/dev/nsa0</filename> benutzt, dann wird die
	Backup-Anwendung nach dem Schreibvorgang das Band nicht
	zurückspulen, was es ermöglicht, mehr als eine Datei auf das
	Band zu schreiben.  Die Verwendung von
	<filename>/dev/esa0</filename> wirft das Band aus, nachdem das
	Gerät geschlossen wurde.</para>

      <para>&os; nutzt <command>mt</command> für die Steuerung der
	Operationen des Bandlaufwerks, wie die Suche nach Dateien auf
	einem Band, oder um Kontrollmarkierungen auf ein Band zu
	schreiben.  Beispielsweise können die ersten drei Dateien auf
	einem Band erhalten bleiben, indem sie übersprungen werden,
	bevor eine neue Datei auf das Band geschrieben wird</para>

      <screen>&prompt.root; <userinput>mt -f /dev/nsa0 fsf 3</userinput></screen>

      <para>Dieses Werkzeug unterstützt viele Operationen.  Weitere
	Einzelheiten finden Sie in &man.mt.1;.</para>

      <para>Um eine Datei mit <command>tar</command> auf ein Band zu
	schreiben, geben Sie den Namen des Bandlaufwerks und den
	Dateinamen an:</para>

      <screen>&prompt.root; <userinput>tar cvf /dev/sa0 <replaceable>file</replaceable></userinput></screen>

      <para>Wiederherstellung von Dateien aus dem
	<command>tar</command>-Archiv von Band in das aktuelle
	Verzeichnis:</para>

      <screen>&prompt.root; <userinput>tar xvf /dev/sa0</userinput></screen>

      <para>Benutzen Sie <command>dump</command>, um ein
	<acronym>UFS</acronym>-Dateisystem zu sichern.  Dieses
	Beispiel sichert <filename>/usr</filename>, ohne danach das
	Band zurückzuspulen:</para>

      <screen>&prompt.root; <userinput>dump -0aL -b64 -f /dev/nsa0 /usr</userinput></screen>

      <para>Interaktive Wiederherstellung von Dateien aus einer
	&man.dump.8;-Datei von Band in das aktuelle
	Verzeichnis:</para>

      <screen>&prompt.root; <userinput>restore -i -f /dev/nsa0</userinput></screen>
    </sect2>

    <sect2 xml:id="backups-programs-amanda">
      <title>Backup-Software von Drittanbietern</title>

      <indexterm>
	<primary>Backup-Software</primary>
      </indexterm>

      <para>Die &os; Ports-Sammlung enthält viele Programme von
	Drittanbietern, die verwendet werden können um die zeitliche
	Erstellung von Sicherungen zu planen, zu vereinfachen und
	bequemer zu machen.  Viele dieser Programme basieren auf dem
	Client-Server-Modell und können benutzt werden, um die
	Sicherung von einzelnen Systemen oder allen Rechnern in einem
	Netzwerk zu automatisieren.</para>

      <para>Zu den bekannten Programmen gehören
	<application>Amanda</application>,
	<application>Bacula</application>,
	<application>rsync</application> und
	<application>duplicity</application>.</para>
    </sect2>

    <sect2>
      <title>Die Wiederherstellung in einem Notfall</title>

      <para>Zusätzlich zu den regelmäßigen Sicherungen empfiehlt es
	sich, die folgenden Schritte im Rahmen eines Notfallplans
	durchzuführen.</para>

      <indexterm>
	<primary><command>bsdlabel</command></primary>
      </indexterm>

      <para>Erstellen Sie einen Ausdruck der Ausgabe der folgenden
	Kommandos:</para>

      <itemizedlist>
	<listitem>
	  <para><command>gpart show</command></para>
	</listitem>

	<listitem>
	  <para><command>more /etc/fstab</command></para>
	</listitem>

	<listitem>
	  <para><command>dmesg</command></para>
	</listitem>
      </itemizedlist>

      <indexterm><primary>Live-CD</primary></indexterm>

      <para>Bewahren Sie diesen Ausdruck und eine Kopie des
	Installationsmediums an einem sicheren Ort auf.  Im Falle
	einer Wiederherstellung im Notfall, starten Sie von dem
	Installationsmedium und wählen Sie <literal>Live CD</literal>,
	um eine Rettungs-Shell zu starten.  Dieser Rettungsmodus kann
	verwendet werden, um den aktuellen Stand des Systems
	anzuzeigen, und wenn nötig, Festplatten zu formatieren und
	Daten aus den Sicherungen wiederherzustellen.</para>

      <note>
	<para>Das Installationsmedium für
	  &os;/&arch.i386;&nbsp;&rel2.current;-RELEASE enthält
	  keine Rettungs-Shell.  Laden Sie für diese Version ein
	  Abbild der Livefs <acronym>CD</acronym> von <uri
	    xlink:href="ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/&arch.i386;/ISO-IMAGES/&rel2.current;/&os;-&rel2.current;-RELEASE-&arch.i386;-livefs.iso">ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/&arch.i386;/ISO-IMAGES/&rel2.current;/&os;-&rel2.current;-RELEASE-&arch.i386;-livefs.iso</uri>.</para>
      </note>

      <para>Als nächstes testen Sie die Rettungs-Shell und die
	Sicherungen.  Dokumentieren Sie diesen Ablauf.  Bewahren Sie
	diese Notizen zusammen mit den Medien, den Ausdrucken und den
	Sicherungen auf.  Diese Notizen können Ihnen im Notfall helfen
	eine versehentliche Zerstörung der Sicherungen zu verhindern,
	während Sie unter Stress eine Wiederherstellung
	durchführen.</para>

      <para>Als zusätzliche Sicherheitsvorkehrung kann jeweils die
	letzte Sicherung an einem entfernten Standort aufbewahrt
	werden.  Dieser Standort sollte räumlich von den Computern und
	Festplatten durch eine erhebliche Entfernung getrennt
	sein.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="disks-virtual">
    <info>
      <title>Speicherbasierte Laufwerke</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Marc</firstname>
	    <surname>Fonvieille</surname>
	  </personname>
	  <contrib>Verbessert und neu strukturiert von </contrib>
	</author>
      </authorgroup>
    </info>

    <para>Neben physikalischen Laufwerken unterstützt &os;
      auch speicherbasierte Laufwerke.  Eine mögliche Verwendung für
      ein speicherbasiertes Laufwerk ist der Zugriff auf ein
      <acronym>ISO</acronym>-Dateisystem, jedoch ohne vorher
      die Daten auf eine <acronym>CD</acronym> oder
      <acronym>DVD</acronym> zu brennen und dann das Medium
      einzuhängen.</para>

    <para>&os; verwendet den &man.md.4; Treiber um Unterstützung für
      speicherbasierte Laufwerke bereitzustellen.  Dieser Treiber ist
      bereits im <filename>GENERIC</filename>-Kernel enthalten.  Wenn
      Sie eine angepasste Kernelkonfigurationsdatei verwenden, stellen
      Sie sicher, dass folgende Zeile enthalten ist:</para>

    <programlisting>device md</programlisting>

    <sect2 xml:id="disks-mdconfig">
      <title>Ein- und Aushängen von bestehenden Abbildern</title>

      <indexterm>
	<primary>Laufwerke</primary>
	<secondary>speicherbasierte</secondary>
      </indexterm>

      <para>Um ein bestehendes Abbild eines Dateisystems einzuhängen,
	verwenden Sie <command>mdconfig</command> zusammen mit dem
	Namen der <acronym>ISO</acronym>-Datei und einer freien
	Gerätenummer.  Benutzen Sie dann diese Gerätenummer, um das
	Abbild in einen existierenden Mountpunkt einzuhängen.  Sobald
	dies erledigt ist, erscheinen die Dateien des Abbildes
	unterhalb des Mountpunktes.  Dieses Beispiel wird
	<filename>diskimage.iso</filename> an das speicherbasierte
	Laufwerk <filename>/dev/md0</filename> binden und dann in
	<filename>/mnt</filename> einhängen:</para>

      <screen>&prompt.root; <userinput>mdconfig -f <replaceable>diskimage.iso</replaceable> -u <replaceable>0</replaceable></userinput>
&prompt.root; <userinput>mount -t cd9660 /dev/md<replaceable>0</replaceable> <replaceable>/mnt</replaceable></userinput></screen>

      <para>Beachten Sie, dass <option>-t cd9660</option> benutzt
	wurde, um ein ISO-Format einzuhängen.  Wenn keine Gerätenummer mit <option>-u</option> angegeben
	ist, wird von &man.md.4; automatisch eine
	ungenutzte Gerätenummer zugewiesen.  Das zugewiesene Gerät
	wird auf der Standardausgabe ausgegeben (zum Beispiel
	<filename>md4</filename>).  Weitere Informationen zu diesem
	Kommando und dessen Optionen finden Sie in
	&man.mdconfig.8;.</para>

      <indexterm>
	<primary>Laufwerke</primary>
	<secondary>speicherbasiertes Laufwerk aushängen</secondary>
      </indexterm>

      <para>Wenn ein speicherbasiertes Laufwerk nicht mehr in Gebrauch
	ist, sollten seine belegten Ressourcen wieder an das System
	zurückgegeben werden.  Hängen Sie zuerst das Dateisystem aus,
	dann verwenden Sie <command>mdconfig</command>, um die Platte
	vom System zu trennen und die Ressourcen freizugeben.</para>

      <screen>&prompt.root; <userinput>umount /mnt</userinput>
&prompt.root; <userinput>mdconfig -d -u <replaceable>0</replaceable></userinput></screen>

      <para>Um festzustellen, ob noch irgendwelche speicherbasierten
	Laufwerke am System angeschlossen sind, benutzen Sie
	<command>mdconfig -l</command>.</para>
    </sect2>

    <sect2 xml:id="disks-md-freebsd5">
      <title>Ein datei- oder speicherbasiertes Laufwerk
	erzeugen</title>

      <indexterm>
	<primary>Laufwerke</primary>
	<secondary>speicherbasierte</secondary>
      </indexterm>

      <para>&os; unterstützt auch speicherbasierte Laufwerke, bei
	denen der verwendete Speicher entweder einer Festplatte, oder
	einem Bereich im Arbeitsspeicher zugewiesen wird.  Die erste
	Methode ist gemeinhin als dateibasiertes Dateisystem, die
	zweite als speicherbasiertes Dateisystem bekannt.  Beide Typen
	können mit <command>mdconfig</command> erzeugt werden.</para>

      <para>Um ein speicherbasiertes Dateisystem zu erstellen, geben
	Sie den Typ <literal>swap</literal> sowie die gewünschte Größe
	des Laufwerks an.  Dieses Beispiel erzeugt ein 5&nbsp;MB
	großes Laufwerk an der Gerätenummer <literal>1</literal>.  Das
	Laufwerk wird mit dem <acronym>UFS</acronym>-Dateisystem
	formatiert, bevor es eingehängt wird:</para>

      <screen>&prompt.root; <userinput>mdconfig -a -t swap -s <replaceable>5</replaceable>m -u <replaceable>1</replaceable></userinput>
&prompt.root; <userinput>newfs -U md1</userinput>
/dev/md1: 5.0MB (10240 sectors) block size 16384, fragment size 2048
        using 4 cylinder groups of 1.27MB, 81 blks, 192 inodes.
        with soft updates
super-block backups (for fsck -b #) at:
 160, 2752, 5344, 7936
&prompt.root; <userinput>mount /dev/md<replaceable>1</replaceable> <replaceable>/mnt</replaceable></userinput>
&prompt.root; <userinput>df <replaceable>/mnt</replaceable></userinput>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md1        4718    4  4338     0%    /mnt</screen>

      <para>Um ein dateibasiertes Dateisystem zu erstellen,
	muss zunächst ein Stück Speicher auf der Festplatte reserviert
	werden.  Dieses Beispiel erzeugt eine 5&nbsp;MB große Datei
	namens <filename>newimage</filename>:</para>

      <screen>&prompt.root; <userinput>dd if=/dev/zero of=<replaceable>newimage</replaceable> bs=1k count=<replaceable>5</replaceable>k</userinput>
5120+0 records in
5120+0 records out</screen>

      <para>Als nächstes muss diese Datei an ein speicherbasiertes
	Laufwerk gebunden, gelabelt und mit dem
	<acronym>UFS</acronym>-Dateisystem formatiert werden.  Danach
	können Sie das Laufwerk einhängen und die Größe
	überprüfen:</para>

      <screen>&prompt.root; <userinput>mdconfig -f <replaceable>newimage</replaceable> -u <replaceable>0</replaceable></userinput>
&prompt.root; <userinput>bsdlabel -w md<replaceable>0</replaceable> auto</userinput>
&prompt.root; <userinput>newfs -U md<replaceable>0</replaceable>a</userinput>
/dev/md0a: 5.0MB (10224 sectors) block size 16384, fragment size 2048
        using 4 cylinder groups of 1.25MB, 80 blks, 192 inodes.
super-block backups (for fsck -b #) at:
 160, 2720, 5280, 7840
&prompt.root; <userinput>mount /dev/md<replaceable>0</replaceable>a <replaceable>/mnt</replaceable></userinput>
&prompt.root; <userinput>df <replaceable>/mnt</replaceable></userinput>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md0a       4710    4  4330     0%    /mnt</screen>

      <para>Es benötigt mehrere Befehle, um ein datei- oder
	speicherbasiertes Dateisystem mit <command>mdconfig</command>
	zu erstellen.  &os; enthält auch <command>mdmfs</command>, das
	ein speicherbasiertes Laufwerk automatisch konfigurieren,
	formatieren und einhängen kann.  Nachdem beispielsweise
	<filename>newimage</filename> mit <command>dd</command>
	erstellt wurde, hätte auch der folgende Befehl benutzt werden
	können, anstelle der oben verwendeten Kommandos
	<command>bsdlabel</command>, <command>newfs</command> und
	<command>mount</command>:</para>

      <screen>&prompt.root; <userinput>mdmfs -F <replaceable>newimage</replaceable> -s <replaceable>5</replaceable>m md<replaceable>0</replaceable> <replaceable>/mnt</replaceable></userinput></screen>

      <para>Um hingegen ein speicherbasiertes Laufwerk mit
	<command>mdmfs</command> zu erstellen, wird dieser Befehl
	benutzt:</para>

      <screen>&prompt.root; <userinput>mdmfs -s <replaceable>5</replaceable>m md<replaceable>1</replaceable> <replaceable>/mnt</replaceable></userinput></screen>

      <para>Wenn die Gerätenummer nicht angegeben wird, wählt
	<command>mdmfs</command> automatisch ein ungenutztes
	Gerät aus.  Weitere Einzelheiten über <command>mdmfs</command>
	finden Sie in &man.mdmfs.8;.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="snapshots">
    <info>
      <title>Schnappschüsse von Dateisystemen</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	  </personname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>Schnappschüsse</primary>
      <secondary>von Dateisystemen</secondary>
    </indexterm>

    <para>Zusammen mit
      <link linkend="soft-updates">Soft Updates</link> bietet &os;
      eine weitere Funktion: Schnappschüsse von Dateisystemen.</para>

    <para>UFS-Schnappschüsse sind Dateien, die ein Abbild eines
      Dateisystems enthalten und müssen auf dem jeweiligen Dateisystem
      erstellt werden.  Pro Dateisystem darf es maximal
      20&nbsp;Schnappschüsse, die im Superblock vermerkt werden,
      geben.  Schnappschüsse bleiben erhalten, wenn das Dateisystem
      abgehangen, neu eingehangen oder das System neu gestartet wird.
      Wenn ein Schnappschuss nicht mehr benötigt wird, kann er
      mit &man.rm.1; gelöscht werden.  Es ist egal, in welcher
      Reihenfolge Schnappschüsse gelöscht werden.  Es kann allerdings
      vorkommen, dass nicht der gesamte Speicherplatz wieder
      freigegeben wird, da ein anderer Schnappschuss einen Teil der
      entfernten Blöcke für sich beanspruchen kann.</para>

    <para>Das unveränderliche <option>Snapshot</option>-Dateiflag
      wird nach der Erstellung des Snapshots von &man.mksnap.ffs.8;
      gesetzt.  Durch die Verwendung von &man.unlink.1; ist es
      allerdings möglich, einen Schnappschuss zu löschen.</para>

    <para>Schnappschüsse werden mit &man.mount.8; erstellt.  Das
      folgende Kommando legt einen Schnappschuss von
      <filename>/var</filename> in
      <filename>/var/snapshot/snap</filename> ab:</para>

    <screen>&prompt.root; <userinput>mount -u -o snapshot /var/snapshot/snap /var</userinput></screen>

    <para>Alternativ kann der Schnappschuss auch mit
      &man.mksnap.ffs.8; erstellt werden.</para>

    <screen>&prompt.root; <userinput>mksnap_ffs /var /var/snapshot/snap</userinput></screen>

    <para>Um Schnappschüsse auf einem Dateisystem, beispielsweise
      <filename>/var</filename> zu finden, kann man &man.find.1;
      verwenden:</para>

    <screen>&prompt.root; <userinput>find /var -flags snapshot</userinput></screen>

    <para>Nachdem ein Schnappschuss erstellt wurde, können Sie
      ihn für verschiedene Zwecke benutzen:</para>

    <itemizedlist>
      <listitem>
	<para>Sie können den Schnappschuss für die
	  Datensicherung benutzen und ihn auf eine
	  <acronym>CD</acronym> oder ein Band schreiben.</para>
      </listitem>

      <listitem>
	<para>Die Integrität des Schnappschusses kann mit &man.fsck.8;
	  geprüft werden.  Wenn das Dateisystem zum Zeitpunkt der
	  Erstellung des Schnappschusses in Ordnung war, sollte
	  &man.fsck.8; immer erfolgreich durchlaufen.</para>
      </listitem>

      <listitem>
	<para>Sie können den Schnappschuss mit &man.dump.8;
	  sichern.  Sie erhalten dann eine konsistente Sicherung des
	  Dateisystems zu dem Zeitpunkt, der durch den Zeitstempel des
	  Schnappschusses gegeben ist.  Der Schalter
	  <option>-L</option> von &man.dump.8; erstellt für die
	  Sicherung einen Schnappschuss und entfernt diesen am Ende
	  der Sicherung wieder.</para>
      </listitem>

      <listitem>
	<para>Sie können einen Schnappschuss in den
	  Verzeichnisbaum einhängen und sich dann den Zustand des
	  Dateisystems zu dem Zeitpunkt ansehen, an dem der
	  Schnappschuss erstellt wurde.  Der folgende Befehl
	  hängt den Schnappschuss
	  <filename>/var/snapshot/snap</filename> ein:</para>

	<screen>&prompt.root; <userinput>mdconfig -a -t vnode -o readonly -f /var/snapshot/snap -u 4</userinput>
&prompt.root; <userinput>mount -r /dev/md4 /mnt</userinput></screen>

      </listitem>
    </itemizedlist>

    <para>Der eingefrorene Stand des
      <filename>/var</filename>-Dateisystems ist nun unterhalb von
      <filename>/mnt</filename> verfügbar.  Mit Ausnahme der früheren
      Schnappschüsse, die als leere Dateien auftauchen, wird zu
      Beginn alles so aussehen, wie zum Zeitpunkt der Erstellung des
      Schnappschusses.  Der Schnappschuss kann wie folgt abgehängt
      werden:</para>

    <screen>&prompt.root; <userinput>umount /mnt</userinput>
&prompt.root; <userinput>mdconfig -d -u 4</userinput></screen>

    <para>Weitere Informationen über Soft Updates und
      Schnappschüsse von Dateisystemen sowie technische Artikel finden
      Sie auf der <link xlink:href="http://www.mckusick.com/">
	Webseite von Marshall Kirk McKusick</link>.</para>
  </sect1>

  <sect1 xml:id="quotas">
    <title>Disk Quotas</title>

    <indexterm>
      <primary>Accounting</primary>
      <secondary>Plattenplatz</secondary>
    </indexterm>
    <indexterm><primary>Disk Quotas</primary></indexterm>

    <para>Disk Quotas erlauben dem Administrator, den Plattenplatz
      und/oder die Anzahl der Dateien eines Benutzers oder der
      Mitglieder einer Gruppe, auf Dateisystemebene zu beschränken.
      Dadurch wird verhindert, dass ein Benutzer oder eine Gruppe von
      Benutzern den ganzen verfügbaren Plattenplatz belegt.</para>

    <para>Dieser Abschnitt beschreibt die Konfiguration von Disk
      Quotas für <acronym>UFS</acronym>-Dateisysteme.  Lesen Sie
      <xref linkend="zfs-zfs-quota"/>, wenn Sie Disk Quotas auf einem
      <acronym>ZFS</acronym>-Dateisystem einrichten möchten.</para>

    <sect2>
      <title>Disk Quotas aktivieren</title>

      <para>Prüfen Sie zunächst, ob der &os;-Kernel Disk Quotas
	unterstützt:</para>

      <screen>&prompt.user; <userinput>sysctl kern.features.ufs_quota</userinput>
kern.features.ufs_quota: 1</screen>

      <para>In diesem Beispiel zeigt die <literal>1</literal> an, das
	Quotas unterstützt werden.  Falls <literal>0</literal>
	ausgegeben wird, fügen Sie folgende Zeile in die
	Kernelkonfigurationsdatei ein, und folgen Sie den Anweisungen
	in <xref linkend="kernelconfig"/> um den Kernel zu
	aktualisieren:</para>

      <programlisting>options QUOTA</programlisting>

      <para>Als nächstes aktivieren Sie Disk Quotas in
	<filename>/etc/rc.conf</filename>:</para>

      <programlisting>quota_enable="YES"</programlisting>

      <indexterm>
	<primary>Disk Quotas</primary>
	<secondary>überprüfen</secondary>
      </indexterm>

      <para>Normalerweise wird beim Booten die Integrität der Quotas
	auf allen Dateisystemen mit &man.quotacheck.8;
	überprüft.  Dieses Programm stellt sicher, dass die
	Quota-Datenbank mit den Daten auf einem Dateisystem
	übereinstimmt.  Dies ist allerdings ein zeitraubender Prozess,
	der die Zeit, die das System zum Booten braucht, signifikant
	beeinflusst.  Eine Variable in
	<filename>/etc/rc.config</filename> erlaubt es, diesen Schritt
	zu überspringen:</para>

      <programlisting>check_quotas="NO"</programlisting>

      <para>Zuletzt muss noch <filename>/etc/fstab</filename>
	bearbeitet werden, um die Plattenquotas auf Dateisystemebene
	zu aktivieren.  Um Quotas pro Benutzer für ein Dateisystem zu
	aktivieren, geben Sie für dieses Dateisystem
	<option>userquota</option> im Feld Optionen von
	<filename>/etc/fstab</filename> an.  Zum Beispiel:</para>

      <programlisting>/dev/da1s2g   /home    ufs rw,userquota 1 2</programlisting>

      <para>Um Quotas für Gruppen einzurichten, verwenden
	Sie <option>groupquota</option>.  Um Quotas für Benutzer
	und Gruppen einzurichten, trennen Sie die Optionen durch
	Kommata:</para>

      <programlisting>/dev/da1s2g    /home    ufs rw,userquota,groupquota 1 2</programlisting>

      <para>Quota-Dateien werden standardmäßig im Rootverzeichnis
	des Dateisystems unter <filename>quota.user</filename> und
	<filename>quota.group</filename> abgelegt.  Weitere
	Informationen finden Sie in &man.fstab.5;.  Es wird nicht
	empfohlen, Quota-Dateien an anderen Stellen zu
	speichern.</para>

      <para>Sobald die Konfiguration abgeschlossen ist, starten Sie
	das System neu.
	<filename>/etc/rc</filename> wird dann automatisch die
	richtigen Kommandos aufrufen, um die Quota-Dateien für
	alle in <filename>/etc/rc.conf</filename> definierten Quotas
	anzulegen.</para>

      <para>Normalerweise brauchen die Kommandos
	&man.quotacheck.8;, &man.quotaon.8; oder
	&man.quotaoff.8; nicht von Hand aufgerufen werden,
	obwohl man die entsprechenden Seiten im
	Manual lesen sollte, um sich mit ihnen vertraut
	zu machen.</para>
    </sect2>

    <sect2>
      <title>Setzen von Quota-Limits</title>

      <indexterm>
	<primary>Disk Quotas</primary>
	<secondary>Limits</secondary>
      </indexterm>

      <para>Stellen Sie sicher, dass Quotas auch tatsächlich
	aktiviert sind:</para>

      <screen>&prompt.root; <userinput>quota -v</userinput></screen>

      <para>Für jedes Dateisystem, auf dem Quotas aktiviert sind,
	sollte eine Zeile mit der Plattenauslastung und den
	aktuellen Quota-Limits zu sehen sein.</para>

      <para>Mit <command>edquota</command> können nun
	Quota-Limits zugewiesen werden.</para>

      <para>Mehrere Möglichkeiten stehen zur Verfügung, um Limits für
	den Plattenplatz, den ein Benutzer oder eine Gruppe
	verbrauchen kann, oder die Anzahl der Dateien, die angelegt
	werden dürfen, festzulegen.  Die Limits können auf dem
	Plattenplatz (Block-Quotas), der Anzahl der Dateien
	(Inode-Quotas) oder einer Kombination von beiden basieren.
	Jedes Limit wird weiterhin in zwei Kategorien geteilt:
	Hardlimits und Softlimits.</para>

      <indexterm><primary>Hardlimit</primary></indexterm>
      <para>Ein Hardlimit kann nicht überschritten werden.
	Hat der Benutzer einmal ein Hardlimit erreicht, so kann er
	auf dem betreffenden Dateisystem keinen weiteren Platz mehr
	beanspruchen.  Hat ein Benutzer beispielsweise ein Hardlimit
	von 500 Kilobytes auf einem Dateisystem und benutzt davon
	490 Kilobyte, so kann er nur noch 10 weitere Kilobytes
	beanspruchen.  Der Versuch, weitere 11 Kilobytes zu
	beanspruchen, wird fehlschlagen.</para>

      <indexterm><primary>Softlimit</primary></indexterm>

      <para>Softlimits können für eine befristete Zeit überschritten
	werden.  Diese Frist beträgt in der Grundeinstellung eine
	Woche.  Hat der Benutzer das Softlimit über die Frist hinaus
	überschritten, so wird das Softlimit in ein Hardlimit
	umgewandelt und der Benutzer kann keinen weiteren Platz mehr
	beanspruchen.  Wenn er einmal das Softlimit unterschreitet,
	wird die Frist wieder zurückgesetzt.</para>

      <para>Im folgenden Beispiel wird das Quota des Benutzerkonto
	<systemitem class="username">test</systemitem> bearbeitet.
	Wenn <command>edquota</command> aufgerufen wird,
	wird der in <envar>EDITOR</envar> definierte Editor
	aufgerufen, um die Quota-Limts zu konfigurieren.  Der
	Standard-Editor ist <application>vi</application>.</para>

      <screen>&prompt.root; <userinput>edquota -u test</userinput>

Quotas for user test:

/usr: kbytes in use: 65, limits (soft = 50, hard = 75)
        inodes in use: 7, limits (soft = 50, hard = 60)
/usr/var: kbytes in use: 0, limits (soft = 50, hard = 75)
        inodes in use: 0, limits (soft = 50, hard = 60)</screen>

      <para>Für jedes Dateisystem, auf dem Quotas aktiv sind,
	sind zwei Zeilen zu sehen.  Eine repräsentiert die
	Block-Quotas und die andere die Inode-Quotas.  Um ein Limit zu
	modifizieren, ändern Sie einfach den angezeigten Wert.  Um
	beispielsweise das Blocklimit von <filename>/usr</filename>
	auf ein Softlimit von <literal>500</literal> und ein Hardlimit
	von <literal>600</literal> zu erhöhen, ändern Sie die Zeile
	wie folgt:</para>

      <programlisting>/usr: kbytes in use: 65, limits (soft = 500, hard = 600)</programlisting>

      <para>Die neuen Limits sind wirksam, sobald der Editor verlassen
	wird.</para>

      <para>Manchmal ist es wünschenswert, die Limits für eine Reihe
	von Benutzern zu setzen.  Dazu weisen Sie zunächst einem
	Benutzer das gewünschte Quota-Limit zu.  Anschließend benutzen
	Sie <option>-p</option>, um das Quota auf einen bestimmten
	Bereich von Benutzer-IDs (<acronym>UID</acronym>) zu
	duplizieren.  Der folgende Befehl dupliziert die Quota-Limits
	auf die <acronym>UID</acronym>s <literal>10000</literal> bis
	<literal>19999</literal>:</para>

      <screen>&prompt.root; <userinput>edquota -p test 10000-19999</userinput></screen>

      <para>Weitere Informationen finden Sie in
	&man.edquota.8;.</para>
    </sect2>

    <sect2>
      <title>Überprüfen von Quota-Limits und Plattennutzung</title>

      <indexterm>
	<primary>Disk Quotas</primary>
	<secondary>überprüfen</secondary>
      </indexterm>

      <para>Um die Limits oder die Plattennutzung individueller
	Benutzer und Gruppen zu überprüfen, kann &man.quota.1; benutzt
	werden.  Ein Benutzer kann nur die eigenen Quotas und die
	Quotas der Gruppe, der er angehört untersuchen.  Nur der
	Superuser darf sich alle Limits ansehen.  Mit &man.repquota.8;
	erhalten Sie eine Zusammenfassung von allen Limits und der
	Plattenausnutzung für alle Dateisysteme, auf denen Quotas
	aktiv sind.</para>

      <para>In der Ausgabe von &man.quota.1; werden Dateisysteme, auf
	denen ein Benutzer keinen Platz verbraucht, nicht angezeigt,
	auch wenn diesem Quotas zugewiesen wurden.  Benutzen Sie
	<option>-v</option> um solche Dateisysteme ebenfalls
	anzuzeigen.  Das folgende Beispiel zeigt die Ausgabe von
	<command>quota -v</command> für einen Benutzer, der
	Quota-Limits auf zwei Dateisystemen besitzt:</para>

      <programlisting>Disk quotas for user test (uid 1002):
     Filesystem  usage   quota   limit   grace   files   quota   limit   grace
           /usr      65*     50      75   5days       7      50      60
       /usr/var       0      50      75               0      50      60</programlisting>

      <indexterm><primary>grace period</primary></indexterm>

      <para>Im Dateisystem <filename>/usr</filename> liegt der
	Benutzer momentan 15 Kilobytes über dem Softlimit von 50
	Kilobytes und hat noch 5 Tage seiner Frist übrig.  Der Stern
	<literal>*</literal> zeigt an, dass der Benutzer sein Limit
	überschritten hat.</para>
    </sect2>

    <sect2>
      <title>Quotas über NFS</title>

      <indexterm><primary>NFS</primary></indexterm>

      <para>Quotas werden von dem Quota-Subsystem auf dem
	<acronym>NFS</acronym>-Server erzwungen.  Der
	&man.rpc.rquotad.8; Daemon stellt <command>quota</command> die
	Quota Informationen auf dem <acronym>NFS</acronym>-Client
	zur Verfügung, so dass Benutzer auf diesen Systemen ihre
	Quotas abfragen können.</para>

      <para>Sie aktivieren <command>rpc.rquotad</command> auf dem
	<acronym>NFS</acronym>-Server, indem Sie das Zeichen
	<literal>#</literal> auf folgender Zeile in
	<filename>/etc/inetd.conf</filename> entfernen:</para>

      <programlisting>rquotad/1      dgram rpc/udp wait root /usr/libexec/rpc.rquotad rpc.rquotad</programlisting>

      <para>Anschließend starten Sie <command>inetd</command>
	neu:</para>

      <screen>&prompt.root; <userinput>service inetd restart</userinput></screen>
    </sect2>
  </sect1>

  <sect1 xml:id="disks-encrypting">
    <info>
      <title>Partitionen verschlüsseln</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Lucky</firstname>
	    <surname>Green</surname>
	  </personname>
	  <contrib>Beigetragen von </contrib>
	  <affiliation>
	    <address>
	      <email>shamrock@cypherpunks.to</email>
	    </address>
	  </affiliation>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>Partitionen</primary>
      <secondary>verschlüsseln</secondary>
    </indexterm>

    <para>&os; bietet ausgezeichnete Möglichkeiten, Daten vor
      unberechtigten Zugriffen zu schützen.  Wenn das Betriebssystem
      läuft, schützen Zugriffsrechte und vorgeschriebene
      Zugriffskontrollen (MAC) (siehe <xref linkend="mac"/>) die
      Daten.  Die Zugriffskontrollen des Betriebssystems schützen
      allerdings nicht vor einem Angreifer, der Zugriff auf den
      Rechner hat.  Der Angreifer kann eine Festplatte in ein anderes
      System einbauen und dort die Daten analysieren.</para>

    <para>Die für &os; verfügbaren kryptografischen Subsysteme,
      <acronym>GEOM</acronym> Based Disk Encryption
      (<command>gbde</command>) und <command>geli</command> sind in
      der Lage, Daten auf Dateisystemen auch vor hoch motivierten
      Angreifern zu schützen,  die über erhebliche Mittel verfügen.
      Dieser Schutz ist unabhängig von der Art und Weise, durch die
      ein Angreifer Zugang zu einer Festplatte oder zu einem Rechner
      erlangt hat.  Im Gegensatz zu anderen Verschlüsselungsmethoden,
      bei denen einzelne Dateien verschlüsselt werden, verschlüsseln
      <application>gbde</application> und <command>geli</command>
      transparent ganze Dateisysteme.  Auf der Festplatte werden dabei
      keine Daten im Klartext gespeichert.</para>

    <para>Dieses Kapitel zeigt, wie ein verschlüsseltes Dateisystem
      unter &os; erstellt wird.  Zunächst wird der Ablauf für
      <application>gbde</application> beschrieben und anschließend
      das gleiche Beispiel für <application>geli</application>.</para>

    <sect2>
      <title>Plattenverschlüsselung mit
	<application>gbde</application></title>

      <para>Das Ziel von &man.gbde.4; ist es, einen Angreifer vor eine
	große Herausforderung zu stellen, um an die Daten einer
	Festplatte zu gelangen.  Falls jedoch der Rechner
	kompromittiert wurde, während er im Betrieb war und das
	Speichergerät aktiv verbunden war, oder wenn der Angreifer
	eine gültige Passphrase kennt, bietet dieses System keinen
	Schutz für die Daten der Festplatte.  Daher ist es wichtig,
	für die physische Sicherheit zu sorgen, während das System im
	Betrieb ist.  Außerdem muss die Passphrase für den
	Verschlüsselungsmechanismus geschützt werden.</para>

      <para>&man.gbde.4; besitzt einige Funktionen um die Daten,
	die in einem Sektor gespeichert sind, zu schützen.  Es benutzt
	128-Bit <acronym>AES</acronym> im
	<acronym>CBC</acronym>-Modus, um die Daten eines Sektors zu
	verschlüsseln.  Jeder Sektor einer Festplatte wird mit einem
	anderen <acronym>AES</acronym>-Schlüssel verschlüsselt.
	Weitere Informationen zum kryptographischen Design und wie die
	Schlüssel für einen Sektor aus der gegebenen Passphrase
	ermittelt werden, finden Sie in &man.gbde.4;.</para>

      <para>&os; enthält ein Kernelmodul für
	<application>gbde</application>, das wie folgt geladen werden
	kann:</para>

      <screen>&prompt.root; <userinput>kldload geom_bde</userinput></screen>

      <para>Wenn Sie einen angepassten Kernel verwenden, stellen Sie
	sicher, dass folgende Zeile in der Kernelkonfigurationsdatei
	enthalten ist:</para>

      <para><literal>options GEOM_BDE</literal></para>

      <para>Das folgende Beispiel beschreibt, wie eine Partition
	auf einer neuen Festplatte verschlüsselt wird.  Die
	Partition wird in <filename>/private</filename>
	eingehangen.</para>

      <procedure>
	<title>Eine Partition mit <application>gbde</application>
	  verschlüsseln</title>

	<step>
	  <title>Installieren der Festplatte</title>

	  <para>Installieren Sie die Festplatte wie in
	    <xref linkend="disks-adding"/> beschrieben.  Im Beispiel
	    wird die Partition <filename>/dev/ad4s1c</filename>
	    verwendet.  Die Gerätedateien
	    <filename>/dev/ad0s1<replaceable>*</replaceable></filename>
	    sind Standard-Partitionen des &os;-Systems.</para>

	  <screen>&prompt.root; <userinput>ls /dev/ad*</userinput>
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4</screen>
	</step>

	<step>
	  <title>Verzeichnis für gbde-Lock-Dateien anlegen</title>

	  <screen>&prompt.root; <userinput>mkdir /etc/gbde</userinput></screen>

	  <para>Die Lock-Dateien sind für den Zugriff von
	    <application>gbde</application> auf verschlüsselte
	    Partitionen notwendig.  Ohne die Lock-Dateien können
	    die Daten nur mit erheblichem manuellen Aufwand wieder
	    entschlüsselt werden (dies wird auch von der Software
	    nicht unterstützt).  Jede verschlüsselte
	    Partition benötigt eine gesonderte Lock-Datei.</para>
	</step>

	<step>
	  <title>Vorbereiten der gbde-Partition</title>

	  <para>Eine von <application>gbde</application> benutzte
	    Partition muss einmalig initialisiert werden, bevor
	    sie benutzt werden kann.  Das Programm öffnet eine Vorlage
	    im Standard-Editor, um verschiedene Optionen zu
	    konfigurieren.  Setzen Sie <varname>sector_size</varname>
	    auf <literal>2048</literal>, wenn Sie
	    <acronym>UFS</acronym> benutzen:</para>

	  <screen>&prompt.root; <userinput>gbde init /dev/ad4s1c -i -L /etc/gbde/ad4s1c.lock</userinput>
<phrase its:translate="no">&dollar;FreeBSD: src/sbin/gbde/template.txt,v 1.1.36.1 2009/08/03 08:13:06 kensmith Exp $</phrase>
#
# Sector size is the smallest unit of data which can be read or written.
# Making it too small decreases performance and decreases available space.
# Making it too large may prevent filesystems from working.  512 is the
# minimum and always safe.  For UFS, use the fragment size
#
sector_size     =       2048
[...]</screen>

	  <para>Sobald die Änderungen gespeichert werden, wird der
	    Benutzer zweimal aufgefordert, die zum Schutz der Daten
	    verwendete Passphrase einzugeben.  Die Passphrase muss
	    beide Mal gleich eingegeben werden.  Die Sicherheit der
	    Daten hängt allein von der Qualität der gewählten
	    Passphrase ab.  Die Auswahl einer sicheren und leicht zu
	    merkenden Passphrase wird auf der Webseite <link
	      xlink:href="http://world.std.com/~reinhold/diceware.html">
	      http://world.std.com/~reinhold/diceware.html</link>
	    beschrieben.</para>

	  <para>Bei der Initialisierung wird eine Lock-Datei für die
	    <application>gbde</application>-Partition erstellt.  In
	    diesem Beispiel
	    <filename>/etc/gbde/ad4s1c.lock</filename>.  Lock-Dateien
	    müssen die Dateiendung <quote>.lock</quote> aufweisen,
	    damit sie von <filename>/etc/rc.d/gbde</filename>, dem
	    Startskript von <application>gbde</application>, erkannt
	    werden.</para>

	  <caution>
	    <para>Lock-Dateien müssen immer zusammen mit den
	      verschlüsselten Dateisystemen gesichert werden.  Ohne
	      die Lock-Datei können Sie allerdings nicht auf die
	      verschlüsselten Daten zugreifen.</para>
	  </caution>
	</step>

	<step>
	  <title>Einbinden der verschlüsselten Partition
	    in den Kernel</title>

	  <screen>&prompt.root; <userinput>gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c.lock</userinput></screen>

	  <para>Dieses Kommando fragt die Passphrase ab, die bei der
	    Initialisierung der verschlüsselten Partition eingegeben
	    wurde.  Das neue verschlüsselte Gerät erscheint danach in
	    <filename>/dev</filename> als
	    <filename>/dev/device_name.bde</filename>:</para>

	  <screen>&prompt.root; <userinput>ls /dev/ad*</userinput>
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4        /dev/ad4s1c.bde</screen>
	</step>

	<step>
	  <title>Dateisystem auf dem verschlüsselten Gerät
	    anlegen</title>

	  <para>Nachdem die verschlüsselte Partition im Kernel
	    eingebunden ist, kann ein Dateisystem erstellt werden.
	    Dieses Beispiel erstellt ein
	    <acronym>UFS</acronym>-Dateisystem mit aktivierten Soft
	    Updates.  Achten Sie darauf, die Partition mit der
	    Erweiterung
	    <filename><replaceable>*</replaceable>.bde</filename>
	    zu benutzen:</para>

	  <screen>&prompt.root; <userinput>newfs -U -O2 /dev/ad4s1c.bde</userinput></screen>
	</step>

	<step>
	  <title>Einhängen der verschlüsselten Partition</title>

	  <para>Legen Sie einen Mountpunkt für das
	    verschlüsselte Dateisystem an.  Hängen Sie anschließend
	    das Dateisystem ein:</para>

	  <screen>&prompt.root; <userinput>mkdir /private</userinput>
&prompt.root; <userinput>mount /dev/ad4s1c.bde /private</userinput></screen>
	</step>

	<step>
	  <title>Überprüfen des verschlüsselten
	    Dateisystems</title>

	  <para>Das verschlüsselte Dateisystem sollte jetzt erkannt
	    und benutzt werden können:</para>

	  <screen>&prompt.user; <userinput>df -H</userinput>
Filesystem        Size   Used  Avail Capacity  Mounted on
/dev/ad0s1a      1037M    72M   883M     8%    /
/devfs            1.0K   1.0K     0B   100%    /dev
/dev/ad0s1f       8.1G    55K   7.5G     0%    /home
/dev/ad0s1e      1037M   1.1M   953M     0%    /tmp
/dev/ad0s1d       6.1G   1.9G   3.7G    35%    /usr
/dev/ad4s1c.bde   150G   4.1K   138G     0%    /private</screen>
	</step>
      </procedure>

      <para>Nach jedem Neustart müssen verschlüsselte
	Dateisysteme dem Kernel wieder bekannt gemacht werden,
	auf Fehler überprüft werden und eingehangen
	werden.  Für die dazu nötigen Schritte fügen Sie folgende
	Zeilen in <filename>/etc/rc.conf</filename> hinzu:</para>

      <programlisting>gbde_autoattach_all="YES"
gbde_devices="<replaceable>ad4s1c</replaceable>"
gbde_lockdir="/etc/gbde"</programlisting>

      <para>Durch diese Argumente muss beim Systemstart auf der
	Konsole die Passphrase eingegeben werden.  Erst nach Eingabe
	der korrekten Passphrase wird die verschlüsselte Partition
	automatisch in den Verzeichnisbaum eingehängt.  Weitere
	Bootoptionen von <application>gbde</application> finden Sie
	in &man.rc.conf.5;.</para>

<!--
What about bsdinstall?
-->

      <note>
	<para><application>sysinstall</application> ist nicht
	  kompatibel mit
	  <application>gbde</application>-verschlüsselten Geräten.
	  Bevor <application>sysinstall</application> gestartet
	  wird, müssen alle <filename>*.bde</filename> Geräte vom
	  Kernel getrennt werden, da sonst der Kernel bei der
	  ersten Suche nach Geräten abstürzt.  Um das verschlüsselte
	  Gerät aus dem Beispiel zu trennen, benutzen Sie das
	  folgende Kommando:</para>

	<screen>&prompt.root; <userinput>gbde detach /dev/<replaceable>ad4s1c</replaceable></userinput></screen>
      </note>
    </sect2>

    <sect2 xml:id="disks-encrypting-geli">
      <info>
	<title>Plattenverschlüsselung mit
	  <command>geli</command></title>

	<authorgroup>
	  <author>
	    <personname>
	      <firstname>Daniel</firstname>
	      <surname>Gerzo</surname>
	    </personname>
	    <contrib>Beigetragen von </contrib>
	  </author>
	</authorgroup>
      </info>

      <para>Mit <command>geli</command> steht eine alternative
	kryptografische <acronym>GEOM</acronym>-Klasse zur Verfügung.
	Dieses Werkzeug unterstützt unterschiedliche Fähigkeiten und
	verfolgt einen anderen Ansatz für die Verschlüsselung.
	<application>geli</application> bietet die folgenden
	Funktionen:</para>

      <itemizedlist>
	<listitem>
	  <para>Die Nutzung des &man.crypto.9;-Frameworks.  Wenn das
	    System über kryptografische Hardware verfügt, wird diese
	    von <command>geli</command> automatisch verwendet.</para>
	</listitem>

	<listitem>
	  <para>Die Unterstützung verschiedener kryptografischer
	    Algorithmen, wie <acronym>AES</acronym>, Blowfish, und
	    <acronym>3DES</acronym>.</para>
	</listitem>

	<listitem>
	  <para>Die Möglichkeit, die root-Partition zu
	    verschlüsseln.  Um auf die verschlüsselte
	    root-Partition zugreifen zu können, muss beim
	    Systemstart die Passphrase eingegeben werden.</para>
	</listitem>

	<listitem>
	  <para>Erlaubt den Einsatz von zwei voneinander unabhängigen
	    Schlüsseln.</para>
	</listitem>

	<listitem>
	  <para>Es ist durch einfache Sektor-zu-Sektor-Verschlüsselung
	    sehr schnell.</para>
	</listitem>

	<listitem>
	  <para>Die Möglichkeit, Master-Keys zu sichern und
	    wiederherzustellen.  Wenn ein Benutzer seinen Schlüssel
	    zerstört, kann er über seinen zuvor gesicherten
	    Schlüssel wieder auf seine Daten zugreifen.</para>
	</listitem>

	<listitem>
	  <para><command>geli</command> erlaubt es, Platten mit
	    einem zufälligen Einmal-Schlüssel einzusetzen,
	    was für Swap-Partitionen und
	    temporäre Dateisysteme interessant ist.</para>
	</listitem>
      </itemizedlist>

      <para>Weitere Funktionen und Anwendungsbeispiele finden Sie in
	&man.geli.8;.</para>

      <para>Das folgende Beispiel beschreibt, wie eine
	Schlüsseldatei erzeugt wird, die als Teil des Master-Keys für
	den Verschlüsselungs-Provider verwendet wird, der unter
	<filename>/private</filename> in den Verzeichnisbaum
	eingehängt wird.  Die Schlüsseldatei liefert zufällige Daten,
	die für die Verschlüsselung des Master-Keys benutzt werden.
	Zusätzlich wird der Master-Key durch eine Passphrase
	geschützt.  Die Sektorgröße des Providers beträgt 4&nbsp;KB.
	Das Beispiel beschreibt, wie Sie einen
	<command>geli</command>-Provider aktivieren, ein vom ihm
	verwaltetes Dateisystem erzeugen, es mounten, mit ihm arbeiten
	und wie Sie es schließlich wieder unmounten und den Provider
	deaktivieren.</para>

      <procedure>
	<title>Eine Partition mit <command>geli</command>
	  verschlüsseln</title>

	<step>
	  <title>Laden der
	    <command>geli</command>-Unterstützung</title>

	  <para>Die Unterstützung für <command>geli</command> wird
	    über ein ladbares Kernelmodul zur Verfügung gestellt.
	    Damit das Modul automatisch beim Booten geladen wird,
	    fügen Sie folgende Zeile in
	    <filename>/boot/loader.conf</filename> ein:</para>

	  <programlisting>geom_eli_load="YES"</programlisting>

	  <para>Um das Modul direkt zu laden:</para>

	  <screen>&prompt.root; <userinput>kldload geom_eli</userinput></screen>

	  <para>Stellen Sie bei einer angepassten
	    Kernelkonfigurationsdatei sicher, dass diese Zeilen
	    enthalten sind:</para>

	  <programlisting>options GEOM_ELI
device crypto</programlisting>
	</step>

	<step>
	  <title>Erzeugen des Master-Keys</title>

	  <para>Die folgenden Befehle erzeugen einen Master-Key, mit
	    dem alle Daten verschlüsselt werden.  Dieser Schlüssel
	    kann niemals geändert werden. Anstatt ihn direkt zu
	    benutzen, wird er mit einem oder mehrere Schlüsseln
	    verschlüsselt.  Die Schlüssel bestehen aus einer
	    optionalen Kombination von zufälligen Bytes aus einer
	    Datei, <filename>/root/da2.key</filename>, und/oder einer
	    Passphrase.  In diesem Fall ist die Datenquelle der
	    Schlüsseldatei <filename>/dev/random</filename>.  Dieser
	    Befehl konfiguriert auch die Sektorgröße des Providers
	    (<filename>/dev/da2.eli</filename>) mit 4&nbsp;KB, um eine
	    bessere Leistung zu erzielen:</para>

	  <screen>&prompt.root; <userinput>dd if=/dev/random of=/root/da2.key bs=64 count=1</userinput>
&prompt.root; <userinput>geli init -K /root/da2.key -s 4096 /dev/da2</userinput>
Enter new passphrase:
Reenter new passphrase:</screen>

	  <para>Es ist nicht zwingend nötig, sowohl eine Passphrase
	    als auch eine Schlüsseldatei zu verwenden.  Die
	    einzelnen Methoden können auch unabhängig
	    voneinander eingesetzt werden.</para>

	  <para>Wird für die Schlüsseldatei
	    <quote>-</quote> angegeben, wird dafür die
	    Standardeingabe verwendet.  Das folgende Kommando erzeugt
	    beispielsweise drei Schlüsseldateien:</para>

	  <screen>&prompt.root; <userinput>cat keyfile1 keyfile2 keyfile3 | geli init -K - /dev/da2</userinput></screen>
	</step>

	<step>
	  <title>Aktivieren des Providers mit dem erzeugten
	    Schlüssel</title>

	  <para>Um den Provider zu aktivieren, geben Sie die
	    Schlüsseldatei, den Namen des Laufwerks und die Passphrase
	    an:</para>

	  <screen>&prompt.root; <userinput>geli attach -k /root/da2.key /dev/da2</userinput>
Enter passphrase:</screen>

	  <para>Dadurch wird ein neues Gerät mit der Erweiterung
	    <filename>.eli</filename> angelegt:</para>

	  <screen>&prompt.root; <userinput>ls /dev/da2*</userinput>
/dev/da2  /dev/da2.eli</screen>
	</step>

	<step>
	  <title>Das neue Dateisystem erzeugen</title>

	  <para>Als nächstes muss das Gerät mit dem
	    <acronym>UFS</acronym>-Dateisystem formatiert und an einen
	    vorhandenen Mountpunkt eingehängt werden:</para>

	  <screen>&prompt.root; <userinput>dd if=/dev/random of=/dev/da2.eli bs=1m</userinput>
&prompt.root; <userinput>newfs /dev/da2.eli</userinput>
&prompt.root; <userinput>mount /dev/da2.eli <replaceable>/private</replaceable></userinput></screen>

	  <para>Das verschlüsselte Dateisystem sollte jetzt erkannt
	    und benutzt werden können:</para>

	  <screen>&prompt.root; <userinput>df -H</userinput>
Filesystem     Size   Used  Avail Capacity  Mounted on
/dev/ad0s1a    248M    89M   139M    38%    /
/devfs         1.0K   1.0K     0B   100%    /dev
/dev/ad0s1f    7.7G   2.3G   4.9G    32%    /usr
/dev/ad0s1d    989M   1.5M   909M     0%    /tmp
/dev/ad0s1e    3.9G   1.3G   2.3G    35%    /var
/dev/da2.eli   150G   4.1K   138G     0%    /private</screen>
	</step>
      </procedure>

      <para>Wenn Sie nicht mehr mit dem verschlüsselten Dateisystem
	arbeiten und die unter <filename>/private</filename>
	eingehängte Partition daher nicht mehr benötigen,  sollten Sie
	diese unmounten und den
	<command>geli</command>-Verschlüsselungs-Provider wieder
	deaktivieren:</para>

      <screen>&prompt.root; <userinput>umount /private</userinput>
&prompt.root; <userinput>geli detach da2.eli</userinput></screen>

      <para>&os; verfügt über ein <filename>rc.d</filename>-Skript,
	das dass Einhängen von verschlüsselten Geräten beim Booten
	deutlich vereinfacht.  Für dieses Beispiel, fügen Sie
	folgende Zeilen in <filename>/etc/rc.conf</filename>
	hinzu:</para>

      <programlisting>geli_devices="<replaceable>da2</replaceable>"
geli_da2_flags="-p -k /root/<replaceable>da2.key</replaceable>"</programlisting>

      <para>Dies konfiguriert <filename>/dev/da2</filename> als
	<command>geli</command>-Provider mit dem Master-Key
	<filename>/root/da2.key</filename>.  Das System wird den
	Provider automatisch deaktivieren, bevor es heruntergefahren
	wird.  Während des Startvorgangs fordert das Skript die
	Passphrase an, bevor der Provider aktiviert wird.  Vor und
	nach der Eingabeaufforderung für die Passphrase werden noch
	weitere Kernelmeldungen angezeigt.  Achten Sie sorgfältig
	auf die Eingabeaufforderung zwischen den anderen Meldungen,
	falls es zu Problemen beim Startvorgang kommt.  Sobald die
	richtige Passphrase eingegeben wurde, wird der Provider
	aktiviert.  Anschließend werden die Dateisysteme gemäß
	<filename>/etc/fstab</filename> eingehängt.  Lesen Sie
	<xref linkend="mount-unmount"/> wenn Sie wissen möchten,
	wie Sie ein Dateisystem konfigurieren, sodass es beim
	booten automatisch gestartet wird.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="swap-encrypting">
    <info>
      <title>Den Auslagerungsspeicher verschlüsseln</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Christian</firstname>
	    <surname>Brueffer</surname>
	  </personname>
	  <contrib>Geschrieben von </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>Auslagerungsspeicher</primary>
      <secondary>verschlüsseln</secondary>
    </indexterm>

    <para>Wie die Verschlüsselung von Partitionen, wird auch der
      Auslagerungsspeicher verschlüsselt, um sensible Informationen
      zu schützen.  Stellen Sie sich eine Anwendung vor, die mit
      Passwörtern umgeht.  Solange sich diese Passwörter im
      Arbeitsspeicher befinden, werden sie nicht auf die Festplatte
      geschrieben und nach einem Neustart gelöscht.  Falls &os; jedoch
      damit beginnt Speicher auszulagern, um Platz für andere
      Anwendungen zu schaffen, können die Passwörter unverschlüsselt
      auf die Festplatte geschrieben werden.  Die Verschlüsselung des
      Auslagerungsspeichers kann in solchen Situationen Abhilfe
      schaffen.</para>

    <para>Dieser Abschnitt zeigt die Konfiguration eines
      verschlüsselten Auslagerungsspeichers mittels &man.gbde.8; oder
      &man.geli.8;.  In den Beispielen repräsentiert
      <filename>/dev/ada0s1b</filename> die Swap-Partition.</para>

    <sect2>
      <title>Konfiguration eines verschlüsselten
	Auslagerungsspeichers</title>

      <para>Swap-Partitionen werden standardmäßig nicht verschlüsselt.
	Sie sollten daher alle sensiblen Daten im Auslagerungsspeicher
	löschen, bevor Sie fortfahren.  Führen Sie folgenden Befehl
	aus, um die Swap-Partition mit Zufallsdaten zu
	überschreiben:</para>

      <screen>&prompt.root; <userinput>dd if=/dev/random of=/dev/<replaceable>ada0s1b</replaceable> bs=1m</userinput></screen>

      <para>Um den Auslagerungsspeicher mit &man.gbde.8; zu
	verschlüsseln, fügen Sie in <filename>/etc/fstab</filename>
	das Suffix <literal>.bde</literal> an den Gerätenamen der
	Swap-Partition hinzu:</para>

      <programlisting># Device                Mountpoint      FStype  Options         Dump    Pass#
/dev/ada0s1b.bde         none            swap    sw              0       0</programlisting>

      <para>Wenn Sie &man.geli.8; benutzen, verwenden Sie stattdessen
	das Suffix <literal>.eli</literal>, um den
	Auslagerungsspeicher zu verschlüsseln:</para>

      <programlisting># Device                Mountpoint      FStype  Options         Dump    Pass#
/dev/ada0s1b.eli         none            swap    sw              0       0</programlisting>

      <para>In der Voreinstellung verschlüsselt &man.geli.8; mit
	dem <acronym>AES</acronym>-Algorithmus und einer
	Schlüssellänge von 128 Bit.  Diese Voreinstellungen sind in
	der Regel ausreichend, können jedoch im Options-Feld in
	<filename>/etc/fstab</filename> angepasst werden.  Mögliche
	Optionen sind:</para>

      <variablelist>
	<varlistentry>
	  <term>aalgo</term>
	  <listitem>
	    <para>Der Algorithmus für die Prüfung der
	      Datenintegrität.  Dieser wird benutzt um
	      sicherzustellen, dass die verschlüsselten Daten nicht
	      manipuliert wurden.  Eine Liste der unterstützten
	      Algorithmen finden Sie in &man.geli.8;.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>ealgo</term>
	  <listitem>
	    <para>Der Verschlüsselungsalgorithmus, der verwendet wird
	      um die Daten zu schützen.  Eine Liste der unterstützten
	      Algorithmen finden Sie in &man.geli.8;.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>keylen</term>
	  <listitem>
	    <para>Die Länge des Schlüssels für den
	      Verschlüsselungsalgorithmus.  In &man.geli.8; können Sie
	      lesen, welche Schlüssellängen von welchem Algorithmus
	      unterstützt werden.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>sectorsize</term>
	  <listitem>
	    <para>Die Größe, in der die Datenblöcke aufgeteilt werden,
	      bevor sie verschlüsselt werden.  Größere Blöcke erhöhen
	      die Leistung auf Kosten des Speicherverbrauchs.  Die
	      empfohlene Größe beträgt 4096 Byte.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>Dieses Beispiel konfiguriert eine verschlüsselte
	Swap-Partition mit dem Blowfish-Algorithmus, einer
	Schlüssellänge von 128 Bit und einer Sektorgröße von
	4&nbsp;KB:</para>

      <programlisting># Device		Mountpoint	FStype	Options				Dump	Pass#
/dev/ada0s1b.eli	none		swap	sw,ealgo=blowfish,keylen=128,sectorsize=4096	0	0</programlisting>
    </sect2>

    <sect2>
      <title>Überprüfung des verschlüsselten
	Auslagerungsspeichers</title>

      <para>Nachdem das System neu gestartet wurde, kann die korrekte
	Funktion des verschlüsselten Auslagerungsspeichers mit
	<command>swapinfo</command> geprüft werden.</para>

      <para>Wenn Sie &man.gbde.8; einsetzen, erhalten Sie eine
	Meldung ähnlich der folgenden:</para>

      <screen>&prompt.user; <userinput>swapinfo</userinput>
Device          1K-blocks     Used    Avail Capacity
/dev/ada0s1b.bde    542720        0   542720     0%</screen>

      <para>Wenn Sie &man.geli.8; einsetzen, erhalten Sie hingegen
	eine Ausgabe ähnlich der folgenden:</para>

      <screen>&prompt.user; <userinput>swapinfo</userinput>
Device          1K-blocks     Used    Avail Capacity
/dev/ada0s1b.eli    542720        0   542720     0%</screen>
    </sect2>
  </sect1>

  <sect1 xml:id="disks-hast">
    <info>
      <title>Highly Available Storage
	(<acronym>HAST</acronym>)</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Daniel</firstname>
	    <surname>Gerzo</surname>
	  </personname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <personname>
	    <firstname>Freddie</firstname>
	    <surname>Cash</surname>
	  </personname>
	  <contrib>Mit Beiträgen von </contrib>
	</author>
	<author>
	  <personname>
	    <firstname>Pawel Jakub</firstname>
	    <surname>Dawidek</surname>
	  </personname>
	</author>
	<author>
	  <personname>
	    <firstname>Michael W.</firstname>
	    <surname>Lucas</surname>
	  </personname>
	</author>
	<author>
	  <personname>
	    <firstname>Viktor</firstname>
	    <surname>Petersson</surname>
	  </personname>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <personname>
	    <firstname>Benedict</firstname>
	    <surname>Reuschling</surname>
	  </personname>
	  <contrib>Übersetzt von </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>HAST</primary>
      <secondary>high availability</secondary>
    </indexterm>

    <para>Hochverfügbarkeit ist eine der Hauptanforderungen von
      ernsthaften Geschäftsanwendungen und hochverfügbarer Speicher
      ist eine Schlüsselkomponente in solchen Umgebungen.  Highly
      Available STorage (<acronym>HAST</acronym>) ist ein Framework
      in &os;, welches die transparente Speicherung der gleichen
      Daten über mehrere physikalisch getrennte Maschinen ermöglicht,
      die über ein <acronym>TCP/IP</acronym>-Netzwerk verbunden sind.
      <acronym>HAST</acronym> kann als ein netzbasiertes RAID1
      (Spiegel) verstanden werden und ist dem DRBD&reg;-Speichersystem
      der GNU/&linux;-Plattform ähnlich.  In Kombination mit anderen
      Hochverfügbarkeitseigenschaften von &os; wie
      <acronym>CARP</acronym>, ermöglicht es <acronym>HAST</acronym>,
      hochverfügbare Speichercluster zu bauen, die in der Lage sind,
      Hardwareausfällen zu widerstehen.</para>

    <para>Die Hauptmerkmale von <acronym>HAST</acronym> sind:</para>

    <itemizedlist>
      <listitem>
	<para>Es kann zur Maskierung von
	  <acronym>I/O</acronym>-Fehlern auf lokalen Festplatten
	  eingesetzt werden.</para>
      </listitem>

      <listitem>
	<para>Dateisystem-unabhängig, was es erlaubt, jedes von &os;
	  unterstützte Dateisystem zu verwenden.</para>
      </listitem>

      <listitem>
	<para>Effiziente und schnelle Resynchronisation: es werden
	  nur die Blöcke synchronisiert, die während der Ausfallzeit
	  eines Knotens geändert wurden.</para>
      </listitem>

<!--
      <listitem>
	<para>Besitzt mehrere Synchronisationsmodi, um eine schnelle
	  Übergabe an einen anderen Knoten (sog. failover) zu
	  ermöglichen.</para>
      </listitem>
-->

      <listitem>
	<para>Es kann in einer bereits bestehenden Umgebung
	  eingesetzt werden, um zusätzliche Redundanz zu
	  erreichen.</para>
      </listitem>

      <listitem>
	<para>Zusammen mit <acronym>CARP</acronym>,
	  <application>Heartbeat</application>, oder anderen
	  Werkzeugen, ist es möglich, ein robustes und dauerhaftes
	  Speichersystem zu bauen.</para>
      </listitem>
    </itemizedlist>

    <para>Nachdem Sie diesen Abschnitt gelesen haben, werden Sie
      folgendes wissen:</para>

    <itemizedlist>
      <listitem>
	<para>Was <acronym>HAST</acronym> ist, wie es funktioniert und
	  welche Eigenschaften es besitzt.</para>
      </listitem>
      <listitem>
	<para>Wie man <acronym>HAST</acronym> unter &os; aufsetzt und
	  verwendet.</para>
      </listitem>
      <listitem>
	<para>Wie man <acronym>CARP</acronym> und &man.devd.8;
	  kombiniert, um ein robustes Speichersystem zu bauen.</para>
      </listitem>
    </itemizedlist>

    <para>Bevor Sie diesen Abschnitt lesen, sollten Sie:</para>

    <itemizedlist>
      <listitem>
	<para>die Grundlagen von &unix; und &os; verstanden haben
	  (<xref linkend="basics"/>).</para>
      </listitem>
      <listitem>
	<para>wissen, wie man Netzwerkschnittstellen und andere
	  Kernsysteme von &os; konfiguriert (<xref
	    linkend="config-tuning"/>).</para>
      </listitem>
      <listitem>
	<para>ein gutes Verständnis der &os;-Netzwerkfunktionalität
	  besitzen (<xref linkend="network-communication"/>).</para>
      </listitem>
    </itemizedlist>

    <para>Das <acronym>HAST</acronym>-Projekt wurde von der &os;
      Foundation mit Unterstützung der <link
	xlink:href="http://www.omc.net/">
	OMCnet Internet Service GmbH</link> und <link
	xlink:href="http://www.transip.nl/">TransIP BV</link>
      gesponsert.</para>

    <sect2>
      <title>HAST im Einsatz</title>

      <para><acronym>HAST</acronym> bietet eine synchrone Replikation
	auf Blockebene zwischen zwei Maschinen: einem
	<literal>primary</literal>, auch bekannt als
	<literal>master</literal> Knoten, sowie dem
	<literal>secondary</literal>, oder <literal>slave</literal>
	Knoten.  Diese beiden Maschinen zusammen werden als Cluster
	bezeichnet.</para>

      <para>Da <acronym>HAST</acronym> in einer
	primär-sekundär-Konfiguration funktioniert, ist immer nur ein
	Knoten des Clusters zu jeder Zeit aktiv.  Der primäre Knoten,
	auch <emphasis>active</emphasis> genannt, ist derjenige, der
	alle <acronym>I/O</acronym>-Anfragen verarbeitet, die an die
	<acronym>HAST</acronym>-Schnittstelle gesendet werden.  Der
	sekundäre Knoten wird automatisch vom primären Knoten aus
	synchronisiert.</para>

      <para>Die physischen Komponenten des
	<acronym>HAST</acronym>-Systems sind die lokale Platte am
	Primärknoten und die entfernte Platte am
	Sekundärknoten.</para>

      <para><acronym>HAST</acronym> arbeitet synchron auf Blockebene,
	was es für Dateisysteme und Anwendungen transparent macht.
	<acronym>HAST</acronym> stellt gewöhnliche
	<acronym>GEOM</acronym>-Provider in
	<filename>/dev/hast/</filename> für die Verwendung durch
	andere Werkzeuge oder Anwendungen zur Verfügung.  Es gibt
	keinen Unterschied zwischen dem Einsatz von
	<acronym>HAST</acronym> bereitgestellten Geräten und
	herkömmlichen Platten oder Partitionen.</para>

      <para>Jede Schreib-, Lösch- oder Entleerungsoperation wird an
	die lokale und über <acronym>TCP/IP</acronym> zu der entfernt
	liegenden Platte gesendet.  Jede Leseoperation wird von der
	lokalen Platte durchgeführt, es sei denn, die lokale Platte
	ist nicht aktuell oder es tritt ein
	<acronym>I/O</acronym>-Fehler auf.  In solchen Fällen wird die
	Leseoperation an den Sekundärknoten geschickt.</para>

      <para><acronym>HAST</acronym> versucht, eine schnelle
	Fehlerbereinigung zu gewährleisten.  Aus diesem Grund ist es
	wichtig, die Synchronisationszeit nach dem Ausfall eines
	Knotens zu reduzieren.  Um eine schnelle Synchronisation zu
	ermöglichen, verwaltet <acronym>HAST</acronym> eine Bitmap von
	unsauberen Bereichen auf der Platte und synchronisiert nur
	diese während einer regulären Synchronisation (mit Ausnahme
	der initialen Synchronisation).</para>

      <para>Es gibt viele Wege, diese Synchronisation zu behandeln.
	<acronym>HAST</acronym> implementiert mehrere
	Replikationsarten, um unterschiedliche Methoden der
	Synchronisation zu realisieren:</para>

      <itemizedlist>
	<listitem>
	  <para><emphasis>memsync</emphasis>: Dieser Modus meldet
	    Schreiboperationen als vollständig, wenn die lokale
	    Schreiboperation beendet ist und der entfernt liegende
	    Knoten die Ankunft der Daten bestätigt hat, jedoch bevor
	    die Daten wirklich gespeichert wurden.  Die Daten werden
	    auf dem entfernt liegenden Knoten direkt nach dem Senden
	    der Bestätigung gespeichert.  Dieser Modus ist dafür
	    gedacht, Latenzen zu verringern und zusätzlich eine gute
	    Verlässlichkeit zu bieten.  In der Voreinstellung wird
	    dieser Modus benutzt.</para>
	</listitem>

	<listitem>
	  <para><emphasis>fullsync</emphasis>: Dieser Modus meldet
	    Schreiboperationen als vollständig, wenn sowohl die
	    lokale, als auch die entfernte Schreiboperation
	    abgeschlossen wurde.  Dies ist der sicherste und
	    zugleich der langsamste Replikationsmodus.</para>
	</listitem>

	<listitem>
	  <para><emphasis>async</emphasis>: Dieser Modus meldet
	    Schreiboperationen als vollständig, wenn lokale
	    Schreibvorgänge abgeschlossen wurden.  Dies ist der
	    schnellste und gefährlichste Replikationsmodus.  Er
	    sollte nur verwendet werden, wenn die Latenz zu einem
	    entfernten Knoten bei einer Replikation zu hoch ist
	    für andere Modi.</para>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>HAST-Konfiguration</title>

      <para>Das <acronym>HAST</acronym>-Framework besteht aus mehreren
	Komponenten:</para>

      <itemizedlist>
	<listitem>
	  <para>Dem &man.hastd.8;-Daemon, welcher für
	    Datensynchronisation verantwortlich ist.  Wenn dieser
	    Daemon gestartet wird, wird automatisch
	    <varname>geom_gate.ko</varname> geladen.</para>
	</listitem>
	<listitem>
	  <para>Dem &man.hastctl.8; Management-Werkzeug.</para>
	</listitem>
	<listitem>
	  <para>Der Konfigurationsdatei &man.hast.conf.5;.  Diese
	    Datei muss vorhanden sein, bevor
	    <application>hastd</application> gestartet wird.</para>
	</listitem>
      </itemizedlist>

      <para>Alternativ lässt sich die
	<literal>GEOM_GATE</literal>-Unterstützung in den Kernel
	statisch einbauen, indem folgende Zeile zur
	Kernelkonfigurationsdatei hinzugefügt wird.  Anschließend muss
	der Kernel, wie in <xref linkend="kernelconfig"/> beschrieben,
	neu gebaut werden:</para>

      <programlisting>options	GEOM_GATE</programlisting>

      <para>Das folgende Beispiel beschreibt, wie man zwei Knoten als
	master-slave / primary-secondary mittels
	<acronym>HAST</acronym> konfiguriert, um Daten zwischen diesen
	beiden auszutauschen.  Die Knoten werden als
	<literal>hasta</literal> mit der <acronym>IP</acronym>-Adresse
	<literal>172.16.0.1</literal> und <literal>hastb</literal> mit
	der <acronym>IP</acronym>-Adresse
	<literal>172.16.0.2</literal> bezeichnet.  Beide Knoten
	besitzen eine dedizierte Festplatte
	<filename>/dev/ad6</filename> mit der gleichen Größe für den
	<acronym>HAST</acronym>-Betrieb.  Der
	<acronym>HAST</acronym>-Pool, manchmal auch Ressource genannt,
	oder der <acronym>GEOM</acronym>-Provider in
	<filename>/dev/hast/</filename> wird als
	<filename>test</filename> bezeichnet.</para>

      <para>Die Konfiguration von <acronym>HAST</acronym> wird in
	<filename>/etc/hast.conf</filename> vorgenommen.  Diese Datei
	sollte auf beiden Knoten gleich sein.  Die einfachste
	Konfiguration ist folgende:</para>

      <programlisting>resource <replaceable>test</replaceable> {
	on <replaceable>hasta</replaceable> {
		local <replaceable>/dev/ad6</replaceable>
		remote <replaceable>172.16.0.2</replaceable>
	}
	on <replaceable>hastb</replaceable> {
		local <replaceable>/dev/ad6</replaceable>
		remote <replaceable>172.16.0.1</replaceable>
	}
}</programlisting>

      <para>Fortgeschrittene Konfigurationsmöglichkeiten finden Sie in
	&man.hast.conf.5;.</para>

      <tip>
	<para>Es ist ebenfalls möglich, den Hostnamen in den
	  <literal>remote</literal>-Anweisungen zu verwenden, falls
	  die Rechner aufgelöst werden können und in
	  <filename>/etc/hosts</filename>, oder im lokalen
	  <acronym>DNS</acronym> definiert sind.</para>
      </tip>

      <para>Sobald die Konfiguration auf beiden Rechnern vorhanden
	ist, kann ein <acronym>HAST</acronym>-Pool erstellt werden.
	Lassen Sie diese Kommandos auf beiden Knoten ablaufen, um die
	initialen Metadaten auf die lokale Platte zu schreiben und
	starten Sie anschließend &man.hastd.8;:</para>

      <screen>&prompt.root; <userinput>hastctl create <replaceable>test</replaceable></userinput>
&prompt.root; <userinput>service hastd onestart</userinput></screen>

      <note>
	<para>Es ist <emphasis>nicht</emphasis> möglich,
	  <acronym>GEOM</acronym>-Provider
	  mit einem bereits bestehenden Dateisystem zu verwenden, um
	  beispielsweise einen bestehenden Speicher in einen von
	  <acronym>HAST</acronym> verwalteten Pool zu konvertieren.
	  Dieses Verfahren muss einige Metadaten auf den Provider
	  schreiben und dafür würde nicht genug freier Platz zur
	  Verfügung stehen.</para>
      </note>

      <para>Die Rolle eines HAST Knotens, <literal>primary</literal>
	oder <literal>secondary</literal>, wird vom einem
	Administrator, oder einer Software wie
	<application>Heartbeat</application>, mittels
	&man.hastctl.8; festgelegt.  Auf dem primären Knoten
	<literal>hasta</literal> geben Sie diesen Befehl ein:</para>

      <screen>&prompt.root; <userinput>hastctl role primary <replaceable>test</replaceable></userinput></screen>

      <para>Geben Sie folgendes Kommando auf dem sekundären Knoten
	<literal>hastb</literal> ein:</para>

      <screen>&prompt.root; <userinput>hastctl role secondary <replaceable>test</replaceable></userinput></screen>

      <para>Überprüfen Sie das Ergebnis mit <command>hastctl</command>
	auf beiden Knoten:</para>

      <screen>&prompt.root; <userinput>hastctl status <replaceable>test</replaceable></userinput></screen>

      <para>Überprüfen Sie die <literal>status</literal>-Zeile.  Wird
	hier <literal>degraded</literal> angezeigt, dann ist etwas mit
	der Konfigurationsdatei nicht in Ordnung.  Auf jedem Konten
	sollte <literal>complete</literal> angezeigt werden, was
	bedeutet, dass die Synchronisation zwischen den beiden Knoten
	gestartet wurde.  Die Synchronisierung ist abgeschlossen, wenn
	<command>hastctl status</command> meldet, dass die
	<literal>dirty</literal>-Bereiche 0 Bytes betragen.</para>

      <para>Der nächste Schritt ist, ein Dateisystem auf dem
	<acronym>GEOM</acronym>-Provider anzulegen und dieses ins
	System einzuhängen.  Dies muss auf dem
	<literal>primary</literal>-Knoten durchgeführt werden.
	Die Erstellung des Dateisystems kann ein paar Minuten dauern,
	abhängig von der Größe der Festplatte.  Dieses Beispiel
	erstellt ein <acronym>UFS</acronym>-Dateisystem auf
	<filename>/dev/hast/test</filename>:</para>

      <screen>&prompt.root; <userinput>newfs -U /dev/hast/<replaceable>test</replaceable></userinput>
&prompt.root; <userinput>mkdir /hast/<replaceable>test</replaceable></userinput>
&prompt.root; <userinput>mount /dev/hast/<replaceable>test</replaceable> <replaceable>/hast/test</replaceable></userinput></screen>

      <para>Sobald das <acronym>HAST</acronym>-Framework richtig
	konfiguriert wurde, besteht der letzte Schritt nun darin,
	sicherzustellen, dass <acronym>HAST</acronym> während des
	Systemstarts automatisch gestartet wird.  Fügen Sie diese
	Zeile in <filename>/etc/rc.conf</filename> hinzu:</para>

      <programlisting>hastd_enable="YES"</programlisting>

      <sect3>
	<title>Failover-Konfiguration</title>

	<para>Das Ziel dieses Beispiels ist, ein robustes
	  Speichersystem zu bauen, welches Fehlern auf einem
	  beliebigen Knoten widerstehen kann.  Wenn der
	  <literal>primary</literal>-Knoten ausfällt, ist der
	  <literal>secondary</literal>-Knoten da, um nahtlos
	  einzuspringen, das Dateisystem zu prüfen, einzuhängen und
	  mit der Arbeit fortzufahren, ohne dass auch nur ein
	  einzelnes Bit an Daten verloren geht.</para>

	<para>Um diese Aufgabe zu bewerkstelligen, wird das
	  <foreignphrase>Common Address Redundancy
	    Protocol</foreignphrase> (<acronym>CARP</acronym>)
	  benutzt,  welches ein automatisches Failover auf der
	  <acronym>IP</acronym>-Schicht ermöglicht.
	  <acronym>CARP</acronym> erlaubt es mehreren Rechnern im
	  gleichen Netzsegment, die gleiche
	  <acronym>IP</acronym>-Adresse zu verwenden.  Setzen Sie
	  <acronym>CARP</acronym> auf beiden Knoten des Clusters
	  anhand der Dokumentation in <xref linkend="carp"/> auf.
	  In diesem Beispiel hat jeder Knoten seine eigene
	  Management <acronym>IP</acronym>-Adresse und die geteilte
	  <acronym>IP</acronym>-Adresse
	  <replaceable>172.16.0.254</replaceable>.  Der primäre
	  <acronym>HAST</acronym>-Knoten des Clusters muss der
	  <acronym>CARP</acronym>-Masterknoten sein.</para>

	<para>Der <acronym>HAST</acronym>-Pool, welcher im vorherigen
	  Abschnitt erstellt wurde, ist nun bereit für den Export über
	  das Netzwerk auf den anderen Rechner.  Dies kann durch den
	  Export über <acronym>NFS</acronym> oder
	  <application>Samba</application> erreicht werden, indem die
	  geteilte <acronym>IP</acronym>-Adresse
	  <replaceable>172.16.0.254</replaceable> verwendet wird.  Das
	  einzige ungelöste Problem ist der automatische Failover,
	  sollte der primäre Knoten einmal ausfallen.</para>

	<para>Falls die <acronym>CARP</acronym>-Schnittstelle
	  aktiviert oder deaktiviert wird, generiert das
	  &os;-Betriebssystem ein &man.devd.8;-Ereignis, was es
	  ermöglicht, Zustandsänderungen auf den
	  <acronym>CARP</acronym>-Schnittstellen zu überwachen.  Eine
	  Zustandsänderung auf der
	  <acronym>CARP</acronym>-Schnittstelle ist ein Indiz dafür,
	  dass einer der Knoten gerade ausgefallen oder wieder
	  verfügbar ist.  Diese Zustandsänderungen machen es möglich,
	  ein Skript zu starten, welches automatisch den HAST-Failover
	  durchführt.</para>

	<para>Um  Zustandsänderungen auf der
	  <acronym>CARP</acronym>-Schnittstelle abzufangen, müssen
	  diese Zeilen in <filename>/etc/devd.conf</filename> auf
	  jedem Knoten hinzugefügt werden:</para>

	<programlisting>notify 30 {
	match "system" "IFNET";
	match "subsystem" "carp0";
	match "type" "LINK_UP";
	action "/usr/local/sbin/carp-hast-switch master";
};

notify 30 {
	match "system" "IFNET";
	match "subsystem" "carp0";
	match "type" "LINK_DOWN";
	action "/usr/local/sbin/carp-hast-switch slave";
};</programlisting>

	<note>
	  <para>Wenn auf dem System &os;&nbsp;10 oder höher eingesetzt
	    wird, ersetzen Sie <filename>carp0</filename> durch den
	    Namen der konfigurierten Schnittstelle für
	    <acronym>CARP</acronym>.</para>
	</note>

	<para>Starten Sie &man.devd.8; auf beiden Knoten neu, um
	  die neue Konfiguration wirksam werden zu lassen:</para>

	<screen>&prompt.root; <userinput>service devd restart</userinput></screen>

	<para>Wenn die Schnittstelle
	  aktiviert oder deaktiviert wird, erzeugt das System eine
	  Meldung, was es dem &man.devd.8;-Subsystem ermöglicht, ein
	  automatisches Failover-Skript zu starten,
	  <filename>/usr/local/sbin/carp-hast-switch</filename>.
	  Weitere Informationen zu dieser Konfiguration finden Sie in
	  &man.devd.conf.5;.</para>

	<para>Es folgt ein Beispiel für ein automatisches
	  Failover-Skript:</para>

	<programlisting>#!/bin/sh

# Original script by Freddie Cash &lt;fjwcash@gmail.com&gt;
# Modified by Michael W. Lucas &lt;mwlucas@BlackHelicopters.org&gt;
# and Viktor Petersson &lt;vpetersson@wireload.net&gt;

# The names of the HAST resources, as listed in /etc/hast.conf
resources="<replaceable>test</replaceable>"

# delay in mounting HAST resource after becoming master
# make your best guess
delay=3

# logging
log="local0.debug"
name="carp-hast"

# end of user configurable stuff

case "$1" in
	master)
		logger -p $log -t $name "Switching to primary provider for ${resources}."
		sleep ${delay}

		# Wait for any "hastd secondary" processes to stop
		for disk in ${resources}; do
			while $( pgrep -lf "hastd: ${disk} \(secondary\)" &gt; /dev/null 2&gt;&amp;1 ); do
				sleep 1
			done

			# Switch role for each disk
			hastctl role primary ${disk}
			if [ $? -ne 0 ]; then
				logger -p $log -t $name "Unable to change role to primary for resource ${disk}."
				exit 1
			fi
		done

		# Wait for the /dev/hast/* devices to appear
		for disk in ${resources}; do
			for I in $( jot 60 ); do
				[ -c "/dev/hast/${disk}" ] &amp;&amp; break
				sleep 0.5
			done

			if [ ! -c "/dev/hast/${disk}" ]; then
				logger -p $log -t $name "GEOM provider /dev/hast/${disk} did not appear."
				exit 1
			fi
		done

		logger -p $log -t $name "Role for HAST resources ${resources} switched to primary."


		logger -p $log -t $name "Mounting disks."
		for disk in ${resources}; do
			mkdir -p /hast/${disk}
			fsck -p -y -t ufs /dev/hast/${disk}
			mount /dev/hast/${disk} /hast/${disk}
		done

	;;

	slave)
		logger -p $log -t $name "Switching to secondary provider for ${resources}."

		# Switch roles for the HAST resources
		for disk in ${resources}; do
			if ! mount | grep -q "^/dev/hast/${disk} on "
			then
			else
				umount -f /hast/${disk}
			fi
			sleep $delay
			hastctl role secondary ${disk} 2&gt;&amp;1
			if [ $? -ne 0 ]; then
				logger -p $log -t $name "Unable to switch role to secondary for resource ${disk}."
				exit 1
			fi
			logger -p $log -t $name "Role switched to secondary for resource ${disk}."
		done
	;;
esac</programlisting>

	<para>Im Kern führt das Skript die folgenden Aktionen durch,
	  sobald ein Knoten zum Master wird:</para>

	<itemizedlist>
	  <listitem>
	    <para>Es ernennt den <acronym>HAST</acronym>-Pool als den
	      primären für einen gegebenen Knoten.</para>
	  </listitem>
	  <listitem>
	    <para>Es prüft das Dateisystem, dass auf dem
	      <acronym>HAST</acronym>-Pool erstellt wurde.</para>
	  </listitem>
	  <listitem>
	    <para>Es hängt den Pool ins System ein.</para>
	  </listitem>
	</itemizedlist>

	<para>Wenn ein Knoten zum Sekundären ernannt wird:</para>

	<itemizedlist>
	  <listitem>
	    <para>Hängt es den <acronym>HAST</acronym>-Pool aus dem
	      Dateisystem aus.</para>
	  </listitem>
	  <listitem>
	    <para>Degradiert es den <acronym>HAST</acronym>-Pool zum
	      sekundären.</para>
	  </listitem>
	</itemizedlist>

	<caution>
	  <para>Dieses Skript ist nur ein Beispiel für eine mögliche
	    Lösung.  Es behandelt
	    nicht alle möglichen Szenarien, die auftreten können und
	    sollte erweitert bzw. abgeändert werden, so dass z.B.
	    benötigte Dienste gestartet oder gestoppt werden.</para>
	</caution>

	<tip>
	  <para>Für dieses Beispiel wurde ein
	    <acronym>UFS</acronym>-Dateisystem verwendet.  Um die Zeit
	    für die Wiederherstellung zu verringern, kann ein
	    <acronym>UFS</acronym> mit Journal oder ein
	    <acronym>ZFS</acronym>-Dateisystem benutzt werden.</para>
	</tip>

	<para>Weitere detaillierte Informationen mit zusätzlichen
	  Beispielen können unter <link
	    xlink:href="http://wiki.FreeBSD.org/HAST">
	    http://wiki.FreeBSD.org/HAST</link> abgerufen
	  werden.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Fehlerbehebung</title>

      <para><acronym>HAST</acronym> sollte generell ohne Probleme
	funktionieren.  Jedoch kann es, wie bei jeder anderen
	Software auch, zu gewissen Zeiten sein, dass sie sich nicht
	so verhält wie angegeben.  Die Quelle dieser Probleme kann
	unterschiedlich sein, jedoch sollte als Faustregel
	gewährleistet werden, dass die Zeit für alle Knoten im
	Cluster synchron läuft.</para>

      <para>Für die Fehlersuche bei <acronym>HAST</acronym> sollte
	die Anzahl an Debugging-Meldungen von &man.hastd.8; erhöht
	werden.  Dies kann durch das Starten von
	<command>hastd</command> mit <literal>-d</literal> erreicht
	werden.  Diese Option kann mehrfach angegeben werden, um die
	Anzahl an Meldungen weiter zu erhöhen.  Sie sollten ebenfalls
	die Verwendung von <literal>-F</literal> in Erwägung ziehen,
	was <command>hastd</command> im Vordergrund startet.</para>

      <sect3 xml:id="disks-hast-sb">
	<title>Auflösung des Split-brain-Zustands</title>

	<para><literal>split-brain</literal> bezeichnet eine
	  Situation, in der beide Knoten des Clusters nicht in der
	  Lage sind, miteinander zu kommunizieren und dadurch beide
	  als primäre Knoten fungieren.  Dies ist ein
	  gefährlicher Zustand, weil es beiden Knoten erlaubt ist,
	  Änderungen an den Daten vorzunehmen, die miteinander nicht
	  in Einklang gebracht werden können.  Diese Situation muss
	  vom Systemadministrator manuell bereinigt werden.</para>

	<para>Der Administrator muss entscheiden, welcher Knoten die
	  wichtigeren Änderungen besitzt, oder die Zusammenführung
	  manuell durchführen.  Anschließend kann
	  <acronym>HAST</acronym> die volle Synchronisation mit
	  dem Knoten durchführen, der die beschädigten Daten enthält.
	  Um dies zu tun, geben Sie folgende Befehle auf dem Knoten
	  ein, der neu synchronisiert werden muss:</para>

	<screen>&prompt.root; <userinput>hastctl role init <replaceable>test</replaceable></userinput>
&prompt.root; <userinput>hastctl create <replaceable>test</replaceable></userinput>
&prompt.root; <userinput>hastctl role secondary <replaceable>test</replaceable></userinput></screen>
      </sect3>
    </sect2>
  </sect1>
</chapter>
