<!--
	The Vinum Volume Manager
	By Greg Lehey (grog at lemis dot com)

	Added to the Handbook by Hiten Pandya <hmp@FreeBSD.org>
	and Tom Rhodes <trhodes@FreeBSD.org>

	The FreeBSD Documentation Project
	The FreeBSD German Documentation Project

	$FreeBSD$
	$FreeBSDde: de-docproj/books/handbook/vinum/chapter.sgml,v 1.18 2010/12/18 11:57:46 jkois Exp $
	basiert auf: 1.48
-->

<chapter id="vinum-vinum">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Greg</firstname>
	<surname>Lehey</surname>
	<contrib>Urspr&uuml;nglich geschrieben von </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Johann</firstname>
	<surname>Kois</surname>
	<contrib>&Uuml;bersetzt von </contrib>
      </author>
      <author>
	<firstname>Kay</firstname>
	<surname>Abendroth</surname>
      </author>
    </authorgroup>
  </chapterinfo>

  <title>Der Vinum Volume Manager</title>

  <sect1 id="vinum-synopsis">
    <title>&Uuml;bersicht</title>


    <para>Egal, &uuml;ber welche und wieviele Festplatten Ihr System
      auch verf&uuml;gt, immer wieder werden Sie mit den folgenden
      Problemen konfrontiert:</para>

    <itemizedlist>
      <listitem>
        <para>Ihre Platten sind zu klein.</para>
        </listitem>

        <listitem>
          <para>Sie sind zu langsam.</para>
        </listitem>

        <listitem>
          <para>Ihre Platten sind unzuverl&auml;ssig.</para>
        </listitem>
      </itemizedlist>

      <para>Um derartige Probleme zu l&ouml;sen, wurden verschiedene
	Methoden entwickelt.  Eine M&ouml;glichkeit bietet der
	Einsatz von mehreren, manchmal auch redundant ausgelegten
	Platten.  Zus&auml;tzlich zur Unterst&uuml;tzung verschiedener
	Erweiterungskarten und Controller f&uuml;r Hardware-RAID-Systeme
	enth&auml;lt das &os;-Basissystem auch den Vinum
	Volume Manager, einen Blockger&auml;tetreiber, der die
	Einrichtung virtueller Platten unterst&uuml;tzt.  Bei
	<emphasis>Vinum</emphasis> handelt es sich um einen
	sogenannten <emphasis>Volume Manager</emphasis>, einen
	virtuellen Plattentreiber, der obige drei Probleme l&ouml;st.
	Vinum bietet Ihnen gr&ouml;&szlig;ere Flexibilit&auml;t,
	Leistung und Zuverl&auml;ssigkeit als die klassische
	Datenspeicherung auf einzelne Festplatten.  Dazu unterst&uuml;tzt
	Vinum RAID-0, RAID-1 und RAID-5 (sowohl einzeln als auch in
	Kombination).</para>

      <para>Dieses Kapitel bietet Ihnen einen &Uuml;berblick &uuml;ber
	potentielle Probleme der klassischen Datenspeicherung auf
	Festplatten sowie eine Einf&uuml;hrung in den Vinum
	Volume Manager.</para>

      <note>
	<para>F&uuml;r &os;&nbsp;5.X wurde Vinum &uuml;berarbeitet und
	  an die GEOM-Architektur (<xref linkend="GEOM">) angepasst,
	  wobei die urspr&uuml;nglichen Ideeen und Begriffe sowie die
	  auf der Platte ben&ouml;tigten Metadaten beibehalten wurden.
	  Die &uuml;berarbeitete Version wird als
	  <emphasis>gvinum</emphasis> (f&uuml;r
	  <emphasis>GEOM-Vinum</emphasis>) bezeichnet.  Die folgenden
	  Ausf&uuml;hrungen verwenden den Begriff
	  <emphasis>Vinum</emphasis> als abstrakten Namen, unabh&auml;ngig
	  davon, welche Variante implementiert wurde.  S&auml;mtliche
	  Befehlsaufrufe erfolgen &uuml;ber <command>gvinum</command>,
	  welches nun das Kernelmodul <filename>geom_vinum.ko</filename>
	  (statt <filename>vinum.ko</filename>) ben&ouml;tigt.  Analog
	  finden sich alle Ger&auml;tedateien nun unter <filename
	  class="directory">/dev/gvinum</filename> statt unter <filename
	  class="directory">/dev/vinum</filename>. Seit &os;&nbsp;6.x ist die
	  alte Vinum-Implementierung nicht mehr im Basissystem enthalten.</para>
      </note>
  </sect1>

  <sect1 id="vinum-intro">
    <title>Ihre Platten sind zu klein.</title>

    <indexterm><primary>Vinum</primary></indexterm>
    <indexterm>
      <primary>RAID</primary>
      <secondary>Software</secondary>
    </indexterm>

    <para>Festplatten werden zwar immer gr&ouml;&szlig;er, parallel
      dazu steigt aber auch die Gr&ouml;&szlig;e der zu speichernden
      Daten an.  Es kann also nach wie vor vorkommen, dass Sie ein
      Dateisystem ben&ouml;tigen, welches die Gr&ouml;&szlig;e Ihrer
      Platten &uuml;bersteigt.  Zwar ist dieses Problem nicht mehr
      so akut wie noch vor einigen Jahren, aber es existiert nach
      wie vor.   Einige Systeme l&ouml;sen dieses Problem durch die
      Erzeugung eines abstrakten Ger&auml;tes, das seine Daten auf
      mehreren Platten speichert.</para>
  </sect1>

  <sect1 id="vinum-access-bottlenecks">
    <title>M&ouml;gliche Engp&auml;sse</title>

    <para>Moderne Systeme m&uuml;ssen h&auml;ufig parallel auf
      Daten zugreifen.  Gro&szlig;e FTP- und HTTP-Server
      k&ouml;nnen beispielsweise Tausende von parallelen Sitzungen
      verwalten und haben mehrere 100&nbsp;MBit/s-Verbindungen
      zur Au&szlig;enwelt.  Diese Bandbreite &uuml;berschreitet
      die durchschnittliche Transferrate der meisten Platten
      bei weitem.</para>

    <para>Aktuelle Plattenlaufwerke k&ouml;nnen Daten mit bis zu
      70&nbsp;MB/s sequentiell &uuml;bertragen, wobei dieser Wert
      in einer Umgebung, in der viele unabh&auml;ngige Prozesse auf
      eine gemeinsame Platte zugreifen, die jeweils nur einen
      Bruchteil dieses Wertes erreichen, von geringer Aussagekraft
      ist.  In solchen F&auml;llen ist es interessanter, das Problem
      vom Blickwinkel des Platten-Subsystems aus zu betrachten.
      Der wichtigste Parameter ist dabei die Last, die eine
      &Uuml;bertragung auf dem Subsystem verursacht.  Unter Last
      versteht man dabei die Zeit, in der die Platte mit der
      &Uuml;bertragung der Daten besch&auml;ftigt ist.</para>

    <para>Bei jedem Plattenzugriff muss das Laufwerk zuerst die
      K&ouml;pfe positionieren und auf den ersten Sektor warten, bis
      er den Lesekopf passiert.  Dann wird die &Uuml;bertragung
      gestartet.  Diese Aktionen k&ouml;nnen als atomar betrachtet
      werden, da es keinen Sinn macht, diese zu unterbrechen.</para>

    <para><anchor id="vinum-latency">Nehmen wir beispielsweise an,
      dass wir 10&nbsp;kB transferieren wollen.  Aktuelle
      hochperformante Platten k&ouml;nnen die K&ouml;pfe im Durchschnitt
      in 3,5&nbsp;ms positionieren und drehen sich mit maximal
      15.000&nbsp;U/min.  Daher betr&auml;gt die durchschnittliche
      Rotationslatenz (eine halbe Umdrehung) 2&nbsp;ms.
      Bei einer Transferrate von 70&nbsp;MB/s dauert die eigentliche
      &Uuml;bertragung von 10&nbsp;kB etwa 150&nbsp;&mu;s, fast
      nichts im Vergleich zur Positionierungszeit.  In einem solchen
      Fall betr&auml;gt die effektive Transferrate nur etwas mehr
      als 1&nbsp;MB/s.  Die Tranferrate ist also stark von der
      Gr&ouml;&szlig;e der zu tranferierenden Daten
      abh&auml;ngig.</para>

    <para>Die traditionelle und offensichtliche L&ouml;sung zur
      Beseitigung dieses Flaschenhalses sind <quote>mehr
      Spindeln</quote>.  Statt einer einzigen gro&szlig;en Platte werden
      mehrere kleinere Platten mit demselben Gesamtspeicherplatz
      benutzt.  Jede Platte ist in der Lage, unabh&auml;ngig zu
      positionieren und zu transferieren, weshalb der effektive
      Durchsatz um einen Faktor nahe der Zahl der eingesetzten Platten
      steigt.</para>

    <para>Obwohl die Platten Daten parallel transferieren k&ouml;nnen,
      ist es nicht m&ouml;glich, Anfragen gleichm&auml;&szlig;ig auf
      die einzelnen Platten zu verteilen.  Daher wird die Last auf
      bestimmten Laufwerken immer h&ouml;her sein als auf anderen
      Laufwerken.  Daraus ergibt sich auch, dass die exakte Verbesserung
      des Datendurchsatzes immer kleiner ist als die Anzahl der
      involvierten Platten.</para>

    <indexterm>
      <primary>Plattenkonkatenation</primary>
    </indexterm>
    <indexterm>
      <primary>Vinum</primary>
      <secondary>Konkatenation</secondary>
    </indexterm>

    <para>Die gleichm&auml;&szlig;ige Verteilung der Last auf die einzelnen
      Platten ist stark abh&auml;ngig von der Art, wie die Daten auf die
      Laufwerke aufgeteilt werden.  In den folgenden Ausf&uuml;hrungen
      wird eine Platte als eine gro&szlig;e Anzahl von Datensektoren
      dargestellt, die durch Zahlen adressierbar sind (&auml;hnlich
      den Seiten eines Buches).  Die naheliegendste Methode ist es,
      die virtuelle Platte (wieder analog den Seiten eines Buches)
      in Gruppen aufeinanderfolgender Sektoren zu unterteilen, die
      jeweils der Gr&ouml;&szlig;e der einzelnen physischen Platten
      entsprechen.  Diese Vorgehensweise wird als
      <emphasis>Konkatenation</emphasis> bezeichnet und hat den
      Vorteil, dass die Platten keine spezielle
      Gr&ouml;&szlig;enbeziehung haben m&uuml;ssen.  Sie funktioniert
      gut, solange der Zugriff gleichm&auml;&szlig;ig auf den
      Adressraum der virtuellen Platte verteilt wird.  Wenn sich der
      Zugriff allerdings auf einen kleinen Bereich konzentriert, ist die
      Verbesserung vernachl&auml;ssigbar klein.
      <xref linkend="vinum-concat"> verdeutlicht die Verteilung der
      Speichereinheiten in einer konkatenierten Anordnung.</para>

    <para>
      <figure id="vinum-concat">
        <title>Konkatenierte Anordnung</title>
          <graphic fileref="vinum/vinum-concat">
      </figure>
    </para>

    <indexterm>
      <primary>Striping von Platten</primary>
    </indexterm>
    <indexterm>
      <primary>Vinum</primary>
      <secondary>Striping</secondary>
    </indexterm>
    <indexterm>
      <primary>RAID</primary>
    </indexterm>

    <para>Ein alternatives Mapping unterteilt den Adressraum in
      kleinere, gleich gro&szlig;e Komponenten und speichert diese
      sequentiell auf verschiedenen Ger&auml;ten.  Zum Beispiel werden
      die ersten 256 Sektoren auf der ersten Platte, die n&auml;chsten
      256 Sektoren auf der zweiten Platte gespeichert und so
      weiter.  Nachdem die letzte Platte beschrieben wurde, wird dieser
      Vorgang solange wiederholt, bis die Platten voll sind.  Dieses
      Mapping nennt man <emphasis>Striping</emphasis> oder
      <acronym>RAID-0</acronym>.

    <footnote>
      <para><acronym>RAID</acronym> steht f&uuml;r <emphasis>Redundant
        Array of Inexpensive Disks</emphasis> und bietet verschiedene
        Formen der Fehlertorleranz, obwohl der letzte Begriff etwas
        irref&uuml;hrend ist, da RAID keine Redundanz bietet.</para>
    </footnote>

    <para>Striping erfordert einen etwas gr&ouml;&szlig;eren Aufwand,
      um die Daten zu
      lokalisieren, und kann zus&auml;tzliche E/A-Last verursachen,
      wenn eine &Uuml;bertragung &uuml;ber mehrere Platten verteilt
      ist.  Auf der anderen Seite erlaubt es aber eine
      gleichm&auml;&szlig;igere Verteilung der Last auf die einzelnen
      Platten.  <xref linkend="vinum-striped"> veranschaulicht
      die Abfolge, in der Speichereinheiten in einer striped-Anordnung
      alloziert werden.</para>

    <para>
      <figure id="vinum-striped">
        <title>Striped-Anordnung</title>
          <graphic fileref="vinum/vinum-striped">
      </figure>
    </para>
  </sect1>

  <sect1 id="vinum-data-integrity">
    <title>Datenintegrit&auml;t</title>

    <para>Das dritte Problem, welches aktuelle Platten haben, ist ihre
      Unzuverl&auml;ssigkeit.   Obwohl sich die Zuverl&auml;ssigkeit
      von Festplatten in den letzten Jahren stark verbessert hat,
      handelt es sich bei ihnen nach wie vor um die Komponente eines
      Servers, die am ehesten ausf&auml;llt.  F&auml;llt eine
      Festplatte aus, k&ouml;nnen die Folgen katastrophal sein:  Es
      kann Tage dauern, bis eine Platte ersetzt und alle Daten
      wiederhergestellt sind.</para>

      <indexterm>
	<primary>disk mirroring</primary>
      </indexterm>
      <indexterm>
	<primary>Vinum</primary>
	<secondary>Spiegelung</secondary>
      </indexterm>
      <indexterm>
	<primary>RAID-1</primary>
      </indexterm>

      <para>Die traditionelle Art, dieses Problem anzugehen, war es,
        Daten zu <emphasis>spiegeln</emphasis>, also zwei Kopien der
        Daten auf getrennten Platten zu verwahren.  Diese Technik wird
        auch als <acronym>RAID Level 1</acronym> oder
        <acronym>RAID-1</acronym> bezeichnet.  Jeder Schreibzugriff
        findet auf beiden Datentr&auml;gern statt.  Ein Lesezugriff
        kann daher von beiden Laufwerken erfolgen, sodass beim Ausfall
        eines Laufwerks die Daten immer noch auf dem anderen
        Laufwerk verf&uuml;gbar sind.</para>

      <para>Spiegeln verursacht allerdings zwei Probleme:</para>

      <itemizedlist>
        <listitem>
          <para>Es verursacht h&ouml;here Kosten, da doppelt so viel
            Plattenspeicher wie bei einer nicht-redundanten
            L&ouml;sung ben&ouml;tigt wird.</para>
        </listitem>

        <listitem>
          <para>Die Gesamtleistung des Systems sinkt, da
            Schreibzugriffe auf beiden Laufwerken ausgef&uuml;hrt
            werden m&uuml;ssen, daher wird im Vergleich zu einem
            nicht gespiegelten Datentr&auml;ger die doppelte
            Bandbreite ben&ouml;tigt.  Lesezugriffe hingegen sind
            davon nicht betroffen, es sieht sogar so aus, als
            w&uuml;rden diese schneller ausgef&uuml;hrt.</para>
        </listitem>
      </itemizedlist>

      <indexterm><primary>RAID-5</primary></indexterm>

      <para>Eine alternative L&ouml;sung ist
        <emphasis>Parity</emphasis>, das in den
        <acronym>RAID</acronym>-Leveln 2, 3, 4 und 5
        implementiert ist.  Von diesen ist <acronym>RAID-5</acronym>
        der interessanteste.  So wie in VINUM implementiert, ist es
        eine Variante einer gestripten Anordung, welche einen Block
        jedes Stripes als Parit&auml;tsblock f&uuml;r einen der anderen
        Bl&ouml;cke verwendet.  Wie in <acronym>RAID-5</acronym>
        vorgeschrieben, ist die Position dieses Parit&auml;tsblockes
        auf jedem Stripe unterschiedlich.  Die Nummern in den
        Datenbl&ouml;cken geben die relativen Blocknummern an.</para>

      <para>
	<figure id="vinum-raid5-org">
	  <title>RAID-5 Aufbau</title>
	    <graphic fileref="vinum/vinum-raid5-org">
	</figure>
      </para>

      <para>Im Vergleich zur Spiegelung hat RAID-5 den Vorteil, dass
        es signifikant weniger Speicherplatz ben&ouml;tigt.
        Lesezugriffe sind vergleichbar schnell mit jenen bei einem
        Striped-Aufbau, aber Schreibzugriffe sind deutlich langsamer
        (etwa 25% der Lesegeschwindigkeit).  Wenn eine Platte
        ausf&auml;llt, kann das Array in einem "schwachen" Modus
        weiterarbeiten:  Ein Lesezugriff auf eine der &uuml;brigen
        erreichbaren Platten wird normal ausgef&uuml;hrt, ein
        Lesezugriff auf die ausgefallene Platte muss aber
        zun&auml;chst mit dem zugeh&ouml;rigen Block aller
        verbleibender Platten r&uuml;ckberechnet werden.</para>
  </sect1>

  <sect1 id="vinum-objects">
    <title>Vinum-Objekte</title>
      <para>Um die in den vorigen Abschnitte besprochenen Probleme zu
        l&ouml;sen, verwendet Vinum eine vierstufige
        Objekthierarchie:</para>

      <itemizedlist>
	<listitem>
	  <para>Das auff&auml;lligste Objekt ist die virtuelle Platte,
	    die <emphasis>Volume</emphasis> genannt wird.  Volumes
	    haben im Wesentlichen die gleichen Eigenschaften wie ein
	    &unix;-Laufwerk, obwohl es ein paar kleine Unterschiede
	    gibt.  So existieren f&uuml;r Volumes beispielsweise keine
	    Gr&ouml;&szlig;enbeschr&auml;nkungen.</para>
	</listitem>

	<listitem>
	  <para>Volumes bestehen aus einem oder mehreren
	    <emphasis>Plexus</emphasis>,
	    von denen jeder den gesamten Adressraum eines
	    Datentr&auml;gers repr&auml;sentiert.  Diese Hierarchieebene
	    ist f&uuml;r die ben&ouml;tigte Redundanz der Daten
	    erforderlich.  Stellen Sie sich die Plexus als
	    eigenst&auml;ndige Platten in einem gespiegelten
	    Array vor, von denen jede die gleichen Daten
	    enth&auml;lt.</para>
	</listitem>

	<listitem>
	  <para>Da Vinum im &unix;-Plattenspeicher-Framework arbeitet,
	    w&auml;re es m&ouml;glich, als Grundbaustein f&uuml;r
	    Multiplatten-Plexus &unix;-Partitionen zu verwenden.  In
	    der Praxis ist dieser Ansatz aber zu unflexibel, da
	    &unix;-Platten nur eine begrenzte Anzahl von Partitionen
	    haben k&ouml;nnen.  Daher unterteilt Vinum stattdessen
	    eine einzige &unix;-Partition (die
	    <emphasis>Platte</emphasis>) in zusammenh&auml;ngende
	    Bereiche, die als <emphasis>Subdisks</emphasis> bezeichnet
	    werden und als Grundbausteine f&uuml;r einen Plexus
	    benutzt werden.</para>
	</listitem>

	<listitem>
	  <para>Subdisks befinden sich auf
	    Vinum-<emphasis>Platten</emphasis>, eigentlich
	    &unix;-Partitionen.  Vinum-Platten k&ouml;nnen eine
	    beliebige Anzahl von Subdisks haben und den gesamten
	    Speicher der Platte mit Ausnahme eines kleinen Bereiches
	    am Anfang der Platte (welcher zur Speicherung von
	    Konfigurations- und Statusinformationen verwenden wird)
	    verwenden.</para>
	</listitem>
      </itemizedlist>

      <para>Der folgende Abschnitt beschreibt, wie diese Objekte
	die von Vinum ben&ouml;tigten Funktionen zur
	Verf&uuml;gung stellen.</para>

    <sect2>
      <title>&Uuml;berlegungungen zur Gr&ouml;&szlig;e eines Volumes</title>

      <para>Plexus k&ouml;nnen mehrere Subdisks beinhalten, die
	&uuml;ber alle Platten der Vinum-Konfiguration verteilt sind.
	Daraus folgt, dass die Gr&ouml;&szlig;e einer Platte nicht die
	Gr&ouml;&szlig;e eines Plexus (und damit eines Volumes)
	limitiert.</para>
    </sect2>

    <sect2>
      <title>Redundante Datenspeicherung</title>

      <para>Vinum implementiert die Datenspiegelung, indem es ein
	Volume auf mehrere Plexus verteilt.  Jeder Plexus ist
	dabei die Repr&auml;sentation der Daten eines Volumes.
	Ein Volume kann aus bis zu acht Plexus bestehen.</para>

      <para>Obwohl ein Plexus die gesamten Daten eines Volumes
	repr&auml;sentiert, ist es m&ouml;glich, dass Teile der
	Repr&auml;sentation physisch fehlen, entweder aufgrund des
	Designs (etwa durch nicht definierte Subdisks f&uuml;r Teile
	des Plexus) oder durch Zufall (als ein Ergebnis eines
	Plattenfehlers).  Solange wenigstens ein Plexus die gesamten
	Daten f&uuml;r den kompletten Adressbereich des Volumes zur
	Verf&uuml;gung stellen kann, ist das Volume voll
	funktionsf&auml;hig.</para>
    </sect2>

    <sect2>
      <title>&Uuml;berlegungen zur Leistung</title>

      <para>Sowohl Konkatenation als auch Striping werden von Vinum
	auf der Plexus-Ebene realisiert:</para>

      <itemizedlist>
	<listitem>
	  <para>Ein <emphasis>konkatenierter Plexus</emphasis> benutzt
	    abwechselnd den Adressraum jeder Subdisk.</para>
	</listitem>

	<listitem>
	  <para>Ein <emphasis>gestripter Plexus</emphasis> striped die
	    Daten &uuml;ber jede Subdisk. Die Subdisks m&uuml;ssen alle
	    die gleiche Gr&ouml;&szlig;e haben, und es muss mindestens
	    zwei Subdisks in Reihenfolge geben, um ihn von einem
	    konkatenierten Plexus unterscheiden zu k&ouml;nnen.</para>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>Wie ist ein Plexus aufgebaut?</title>

      <para>Die Version von Vinum, welche von &os;-&rel.current;
	bereitgestellt wird, implementiert zwei Arten von Plexus:</para>

      <itemizedlist>
	<listitem>
	  <para>Konkatenierte Plexus sind die flexibelsten:  Sie
	    k&ouml;nnen aus einer beliebigen Anzahl von Subdisks
	    unterschiedlicher Gr&ouml;&szlig;e bestehen.  Der Plexus
	    kann erweitert werden, indem man zus&auml;tzliche Subdisks
	    hinzuf&uuml;gt.  Sie brauchen weniger
	    <acronym>CPU</acronym>-Zeit als gestripte Plexus, obwohl
	    der Unterschied des <acronym>CPU</acronym>-Overheads nicht
	    messbar ist.  Auf der anderen Seite sind sie aber sehr
	    anf&auml;llig f&uuml;r das Entstehen von "hot spots", wobei
	    eine Platte sehr aktiv ist, andere hingegen nahezu ungenutzt
	    sind.</para>
        </listitem>

	<listitem>
	  <para>Der gr&ouml;&szlig;te Vorteil eines gestripten
	    Plexus (<acronym>RAID-0</acronym>) ist die Verringerung von
	    "hot spots".  Dies wird durch die Auswahl eines Stripes
	    optimaler Gr&ouml;&szlig;e (etwa 256&nbsp;kB) erreicht,
	    wodurch die Last gleichm&auml;&szlig;ig auf die Platten
	    verteilt werden kann. Nachteile dieser Vorgehensweise sind
	    ein (geringf&uuml;gig) komplexerer Code sowie einige
	    Restriktionen f&uuml;r die Subdisks:  Diese m&uuml;ssen alle
	    die gleiche Gr&ouml;&szlig;e haben, und das Erweitern eines
	    Plexus durch das Hinzuf&uuml;gen neuer Subdisks ist so
	    kompliziert, dass es von Vinum derzeit nicht
	    unterst&uuml;tzt wird.  Vinum fordert noch eine weitere
	    triviale Beschr&auml;nkung:  Ein gestripter Plexus muss
	    aus mindestens zwei Subdisks bestehen, da er ansonsten nicht
	    von einem konkatenierten Plexus unterscheidbar ist.</para>
	</listitem>
      </itemizedlist>

      <para><xref linkend="vinum-comparison"> fasst die Vor- und
	Nachteile jedes Plexus-Aufbaus zusammen.</para>

      <table id="vinum-comparison" frame="none">
	<title>Vinum-Plexus - Aufbau</title>

	<tgroup cols="5">
	  <thead>
	    <row>
	      <entry>Plexus-Typ</entry>
	      <entry>Minimum an Subdisks?</entry>
	      <entry>Kann Subdisks hinzuf&uuml;gen?</entry>
	      <entry>M&uuml;ssen die gleiche Gr&ouml;&szlig;e
		haben</entry>
	      <entry>Applikation</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>konkateniert</entry>
	      <entry>1</entry>
	      <entry>ja</entry>
	      <entry>nein</entry>
	      <entry>Gro&szlig;er Datenspeicher mit maximaler
		Platzierungsflexibilit&auml;t und moderater
		Leistung</entry>
	    </row>

	    <row>
	      <entry>gestriped</entry>
	      <entry>2</entry>
	      <entry>nein</entry>
	      <entry>ja</entry>
	      <entry>Hohe Leistung in Kombination mit
		gleichzeitigem Zugriff</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>
    </sect2>
  </sect1>

  <sect1 id="vinum-examples">
    <title>Einige Beispiele</title>

    <para>Vinum verwaltet eine
      <emphasis>Konfigurationsdatenbank</emphasis> f&uuml;r alle
      einem individuellen System bekannten Objekte.  Zu Beginn
      erzeugt ein Benutzer mit &man.gvinum.8;
      eine Konfigurationsdatenbank aus einer oder mehreren
      Konfigurationsdateien.  Vinum speichert danach eine Kopie der
      Konfigurationsdatenbank in jedem von ihm kontrollierten
      Slice (von Vinum als <emphasis>Device</emphasis>
      bezeichnet).  Da die Datenbank bei jedem Statuswechsel
      aktualisiert wird, kann nach einem Neustart der Status
      jedes Vinum-Objekts exakt wiederhergestellt werden.</para>

    <sect2>
      <title>Die Konfigurationsdatei</title>

      <para>Die Konfigurationsdatei beschreibt individuelle
        Vinum-Objekte.  Die Beschreibung eines einfachen Volumes
        k&ouml;nnte beispielsweise so aussehen:</para>

      <programlisting>
    drive a device /dev/da3h
    volume myvol
      plex org concat
        sd length 512m drive a</programlisting>

      <para>Diese Datei beschreibt vier Vinum-Objekte:</para>

      <itemizedlist>
	<listitem>
	  <para>Die <emphasis>drive</emphasis>-Zeile beschreibt eine
	    Plattenpartition (<emphasis>drive</emphasis>) sowie ihre
	    Position in Bezug auf die darunter liegende Hardware.
	    Die Partition hat dabei den symbolischen Namen
	    <emphasis>a</emphasis>.  Diese Trennung von symbolischen
	    Namen und Ger&auml;tenamen erlaubt es, die Position von
	    Platten zu &auml;ndern, ohne dass es zu Problemen
	    kommt.</para>
	</listitem>

	<listitem>
	  <para>Die <emphasis>volume</emphasis>-Zeile beschreibt ein
	    Volume.  Daf&uuml;r wird nur ein einziges Attribut, der
	    Name des Volumes, ben&ouml;tigt.  In unserem Fall hat das
	    Volume den Namen <emphasis>myvol</emphasis>.</para>
	</listitem>

	<listitem>
	  <para>Die <emphasis>plex</emphasis>-Zeile definiert einen
	    Plexus.  Auch hier wird nur ein Parameter, und zwar die
	    Art des Aufbau, ben&ouml;tigt (in unserem Fall
	    <emphasis>concat</emphasis>).  Es wird kein Name
	    ben&ouml;tigt, das System generiert automatisch einen
	    Namen aus dem Volume-Namen und dem Suffix
	    <emphasis>.p</emphasis><emphasis>x</emphasis> wobei
	    <emphasis>x</emphasis> die Nummer des Plexus innerhalb
	    des Volumes angibt.  So wird dieser Plexus den Namen
	    <emphasis>myvol.p0</emphasis> erhalten.</para>
	</listitem>

	<listitem>
	  <para>Die <emphasis>sd</emphasis>-Zeile beschreibt eine
	    Subdisk.  Um eine Subdisk einzurichten, m&uuml;ssen Sie
	    zumindest den Namen der Platte, auf der Sie die
	    Subdisk anlegen wollen, sowie die Gr&ouml;&szlig;e der
	    Subdisk angeben. Analog zur Definition eines Plexus wird
	    auch hier kein Name ben&ouml;tigt:  Das System weist
	    automatisch Namen zu, die aus dem Namen des Plexus und
	    dem Suffix <emphasis>.s</emphasis><emphasis>x</emphasis>
	    gebildet werden, wobei <emphasis>x</emphasis> die Nummer
	    der Subdisk innerhalb des Plexus ist.  Folglich gibt
	    Vinum dieser Subdisk den Namen
	    <emphasis>myvol.p0.s0</emphasis>.</para>
	</listitem>
      </itemizedlist>

      <para>Nach dem Verarbeiten dieser Datei erzeugt &man.gvinum.8;
	die folgende Ausgabe:</para>

      <programlisting width="97">
      &prompt.root; gvinum -&gt; <userinput>create config1</userinput>
      Configuration summary
      Drives:         1 (4 configured)
      Volumes:        1 (4 configured)
      Plexes:         1 (8 configured)
      Subdisks:       1 (16 configured)

	D a                     State: up       Device /dev/da3h        Avail: 2061/2573 MB (80%)

	V myvol                 State: up       Plexes:       1 Size:        512 MB

	P myvol.p0            C State: up       Subdisks:     1 Size:        512 MB

	S myvol.p0.s0           State: up       PO:        0  B Size:        512 MB</programlisting>

      <para>Diese Ausgabe entspricht dem verk&uuml;rzten
	Ausgabeformat von &man.gvinum.8; und wird in
	<xref linkend="vinum-simple-vol"> grafisch dargestellt.</para>

      <para>
	<figure id="vinum-simple-vol">
	  <title>Ein einfaches Vinum-Volume</title>
	  <graphic fileref="vinum/vinum-simple-vol">
	</figure>
      </para>

      <para>Dieses und die folgenden Beispiele zeigen jeweils ein
	Volume, welches die Plexus enth&auml;lt, die wiederum die
	Subdisk enthalten.  In diesem trivialen Beispiel enth&auml;lt
	das Volume nur einen Plexus, der wiederum nur aus einer
	Subdisk besteht.</para>

      <para>Eine solche Konfiguration h&auml;tte allerdings keinen
	Vorteil gegen&uuml;ber einer konventionellen Plattenpartion.
	Das Volume enth&auml;lt nur einen einzigen Plexus, daher
	gibt es keine redundante Datenspeicherung.  Da der Plexus
	au&szlig;erdem nur  eine einzige Subdisk enth&auml;lt,
	unterscheidet sich auch die Speicherzuweisung nicht von der
	einer konventionellen Plattenpartition.  Die folgenden
	Abschnitte beschreiben daher verschiedene interessantere
	Konfigurationen.</para>
    </sect2>

    <sect2>
      <title>Verbesserte Ausfallsicherheit durch Spiegelung</title>

      <para>Die Ausfallsicherheit eines Volumes kann durch
	Spiegelung der Daten erh&ouml;ht werden.  Beim Anlegen eines
	gespiegelten Volumes ist es wichtig, die Subdisks jedes
	Plexus auf verschiedene Platten zu verteilen, damit ein
	Plattenausfall nicht beide Plexus unbrauchbar macht.  Die
	folgende Konfiguration spiegelt ein Volume:</para>

      <programlisting>
	drive b device /dev/da4h
	volume mirror
      plex org concat
        sd length 512m drive a
	  plex org concat
	    sd length 512m drive b</programlisting>

      <para>Bei diesem Beispiel war es nicht n&ouml;tig, noch einmal
	eine Platte <emphasis>a</emphasis> zu spezifizieren, da
	Vinum die &Uuml;bersicht &uuml;ber alle Objekte und seine
	Konfigurationsdatenbank beh&auml;lt.  Nach dem Abarbeiten
	dieser Definition sieht die Konfiguration wie folgt aus:</para>

      <programlisting width="97">
	Drives:         2 (4 configured)
	Volumes:        2 (4 configured)
	Plexes:         3 (8 configured)
	Subdisks:       3 (16 configured)

	D a                     State: up       Device /dev/da3h        Avail: 1549/2573 MB (60%)
	D b                     State: up       Device /dev/da4h        Avail: 2061/2573 MB (80%)

    V myvol                 State: up       Plexes:       1 Size:        512 MB
    V mirror                State: up       Plexes:       2 Size:        512 MB

    P myvol.p0            C State: up       Subdisks:     1 Size:        512 MB
    P mirror.p0           C State: up       Subdisks:     1 Size:        512 MB
    P mirror.p1           C State: initializing     Subdisks:     1 Size:        512 MB

    S myvol.p0.s0           State: up       PO:        0  B Size:        512 MB
    S mirror.p0.s0          State: up       PO:        0  B Size:        512 MB
    S mirror.p1.s0          State: empty    PO:        0  B Size:        512 MB</programlisting>

      <para><xref linkend="vinum-mirrored-vol"> stellt diese Struktur
	grafisch dar.</para>

      <para>
	<figure id="vinum-mirrored-vol">
	  <title>Ein gespiegeltes Vinum Volume</title>
	  <graphic fileref="vinum/vinum-mirrored-vol">
	</figure>
      </para>

      <para>In diesem Beispiel enth&auml;lt jeder Plexus die vollen
	512&nbsp;MB des Adressraumes.  Wie im vorangegangenen Beispiel
	enth&auml;lt jeder Plexus nur eine Subdisk.</para>
    </sect2>

    <sect2>
      <title>Die Leistung optimieren</title>

      <para>Das gespiegelte Volume des letzten Beispieles ist
	resistenter gegen&uuml;ber Fehlern als ein ungespiegeltes
	Volume, seine Leistung ist hingegen schlechter, da jeder
	Schreibzugriff auf das Volume einen Schreibzugriff auf beide
	Platten erfordert und damit mehr der insgesamt verf&uuml;gbaren
	Datentransferrate  ben&ouml;tigt.  Steht also die optimale
	Leistung im Vordergrund, muss anders vorgegangen werden:
	Statt alle Daten zu spiegeln, werden die Daten &uuml;ber
	so viele Platten wie m&ouml;glich gestriped.  Die folgende
	Konfiguration zeigt ein Volume
	mit einem &uuml;ber vier Platten hinwegreichenden Plexus:</para>

	<programlisting>
	drive c device /dev/da5h
	drive d device /dev/da6h
	volume stripe
	plex org striped 512k
	  sd length 128m drive a
	  sd length 128m drive b
	  sd length 128m drive c
	  sd length 128m drive d</programlisting>

      <para>Wie zuvor ist es nicht n&ouml;tig, die Platten zu
	definieren, die Vinum schon bekannt sind.  Nach dem Abarbeiten
	dieser Definition sieht die Konfiguration wie folgt aus:</para>

      <programlisting width="92">
	Drives:         4 (4 configured)
	Volumes:        3 (4 configured)
	Plexes:         4 (8 configured)
	Subdisks:       7 (16 configured)

    D a                     State: up       Device /dev/da3h        Avail: 1421/2573 MB (55%)
    D b                     State: up       Device /dev/da4h        Avail: 1933/2573 MB (75%)
    D c                     State: up       Device /dev/da5h        Avail: 2445/2573 MB (95%)
    D d                     State: up       Device /dev/da6h        Avail: 2445/2573 MB (95%)

    V myvol                 State: up       Plexes:       1 Size:        512 MB
    V mirror                State: up       Plexes:       2 Size:        512 MB
    V striped               State: up       Plexes:       1 Size:        512 MB

    P myvol.p0            C State: up       Subdisks:     1 Size:        512 MB
    P mirror.p0           C State: up       Subdisks:     1 Size:        512 MB
    P mirror.p1           C State: initializing     Subdisks:     1 Size:        512 MB
    P striped.p1            State: up       Subdisks:     1 Size:        512 MB

    S myvol.p0.s0           State: up       PO:        0  B Size:        512 MB
    S mirror.p0.s0          State: up       PO:        0  B Size:        512 MB
    S mirror.p1.s0          State: empty    PO:        0  B Size:        512 MB
    S striped.p0.s0         State: up       PO:        0  B Size:        128 MB
    S striped.p0.s1         State: up       PO:      512 kB Size:        128 MB
    S striped.p0.s2         State: up       PO:     1024 kB Size:        128 MB
    S striped.p0.s3         State: up       PO:     1536 kB Size:        128 MB</programlisting>

      <para>
	<figure id="vinum-striped-vol">
	  <title>Ein Striped Vinum Volume</title>
	    <graphic fileref="vinum/vinum-striped-vol">
	</figure>
      </para>

      <para>Dieses Volume wird in <xref linkend="vinum-striped-vol">
        dargestellt.  Die Schattierung der Stripes zeigt die Position
	innerhalb des Plexus-Adressraumes an.  Die hellsten Stripes
	kommen zuerst, die dunkelsten zuletzt.</para>
    </sect2>

    <sect2>
      <title>Ausfallsicherheit und Leistung</title>

      <para><anchor id="vinum-resilience">Mit entsprechender Hardware
	ist es m&ouml;glich, Volumes zu bauen, welche gegen&uuml;ber
	Standard-&unix;-Partitionen beides, n&auml;mlich erh&ouml;hte
	Ausfallsicherheit und erh&ouml;hte Leistung, aufweisen
	k&ouml;nnen.  Eine typische Konfigurationsdatei k&ouml;nnte
	etwa so aussehen:</para>

      <programlisting>
	volume raid10
      plex org striped 512k
        sd length 102480k drive a
        sd length 102480k drive b
        sd length 102480k drive c
        sd length 102480k drive d
        sd length 102480k drive e
      plex org striped 512k
        sd length 102480k drive c
        sd length 102480k drive d
        sd length 102480k drive e
        sd length 102480k drive a
        sd length 102480k drive b</programlisting>

      <para>Die Subdisks des zweiten Plexus sind gegen&uuml;ber denen
	des ersten Plexus um zwei Platten verschoben.  Dadurch wird
	sichergestellt, dass Schreibzugriffe nicht auf den gleichen
	Subdisks auftreten, auch wenn eine &Uuml;bertragung &uuml;ber
	zwei Platten geht.</para>

      <para><xref linkend="vinum-raid10-vol"> veranschaulicht die
	Struktur dieses Volumes.</para>

      <para>
	<figure id="vinum-raid10-vol">
	  <title>Ein gespiegeltes, Striped Vinum Volume</title>
	    <graphic fileref="vinum/vinum-raid10-vol">
        </figure>
      </para>
    </sect2>
  </sect1>

  <sect1 id="vinum-object-naming">
    <title>Objektbenennung</title>

    <para>Wie oben beschrieben, weist Vinum den Plexus und
      Subdisks Standardnamen zu, wenngleich diese &uuml;berschrieben
      werden k&ouml;nnen. Das &Uuml;berschreiben dieser Standardnamen
      wird allerdings nicht empfohlen.  Erfahrungen mit dem VERITAS
      Volume Manager (der eine willk&uuml;rliche Benennung von
      Objekten erlaubt) haben gezeigt, dass diese Flexibilit&auml;t
      keinen entscheidenden Vorteil bringt und zudem Verwirrung
      stiften kann.</para>

    <para>Namen d&uuml;rfen zwar alle nichtleeren Zeichen enthalten,
      es ist aber sinnvoll, nur Buchstaben, Ziffern und den
      Unterstrich zu verwenden.  Die Namen von Volumes, Plexus und
      Subdisks k&ouml;nnen bis zu 64 Zeichen lang sein, die Namen
      von Platten d&uuml;rfen hingegen nur bis zu 32 Zeichen lang
      sein.</para>

    <para>Vinum-Objekten werden Ger&auml;tedateien in der <filename
      class="directory">/dev/gvinum</filename>-Hierarchie zugewiesen.  Die
      weiter oben dargestellte Konfiguration w&uuml;rde Vinum dazu
      veranlassen, die folgenden Ger&auml;tedateien zu erstellen:</para>

    <itemizedlist>
      <listitem>
	<para>Ger&auml;te-Eintr&auml;ge f&uuml;r jedes Volume.
	  Dieses sind die Hauptger&auml;te, die von Vinum benutzt
	  werden.  Somit w&uuml;rde die Konfiguration von oben
	  folgende Ger&auml;te beinhalten:
	  <filename class="devicefile">/dev/gvinum/myvol</filename>,
	  <filename class="devicefile">/dev/gvinum/mirror</filename>,
	  <filename class="devicefile">/dev/gvinum/striped</filename>,
	  <filename class="devicefile">/dev/gvinum/raid5</filename> sowie
	  <filename class="devicefile">/dev/gvinum/raid10</filename>.</para>
      </listitem>

      <listitem>
	<para>Alle Volumes bekommen direkte Eintr&auml;ge unter <filename
	  class="directory">/dev/gvinum/</filename>.</para>
      </listitem>

      <listitem>
	<para>Die Verzeichnisse <filename
	  class="directory">/dev/gvinum/plex</filename> und <filename
	  class="directory">/dev/gvinum/sd</filename>, die Ger&auml;tedateien
	  f&uuml;r jeden Plexus sowie jede Subdisk enthalten.</para>
      </listitem>
    </itemizedlist>

    <para>Stellen Sie sich folgende Konfigurationsdatei vor:</para>

	<programlisting>
	drive drive1 device /dev/sd1h
	drive drive2 device /dev/sd2h
	drive drive3 device /dev/sd3h
	drive drive4 device /dev/sd4h
    volume s64 setupstate
      plex org striped 64k
        sd length 100m drive drive1
        sd length 100m drive drive2
        sd length 100m drive drive3
        sd length 100m drive drive4</programlisting>

    <para>Nach Abarbeitung dieser Datei erstellt &man.gvinum.8; die
      folgende Struktur unter <filename
      class="directory">/dev/gvinum</filename>:</para>

    <programlisting>
	drwxr-xr-x  2 root  wheel       512 Apr 13 16:46 plex
	crwxr-xr--  1 root  wheel   91,   2 Apr 13 16:46 s64
	drwxr-xr-x  2 root  wheel       512 Apr 13 16:46 sd

    /dev/vinum/plex:
    total 0
    crwxr-xr--  1 root  wheel   25, 0x10000002 Apr 13 16:46 s64.p0

    /dev/vinum/sd:
    total 0
    crwxr-xr--  1 root  wheel   91, 0x20000002 Apr 13 16:46 s64.p0.s0
    crwxr-xr--  1 root  wheel   91, 0x20100002 Apr 13 16:46 s64.p0.s1
    crwxr-xr--  1 root  wheel   91, 0x20200002 Apr 13 16:46 s64.p0.s2
    crwxr-xr--  1 root  wheel   91, 0x20300002 Apr 13 16:46 s64.p0.s3</programlisting>

    <para>Es wird empfohlen, f&uuml;r Plexus und Subdisks keine
      eigenen Namen zu vergeben.  Dies gilt aber nicht f&uuml;r
      Vinum-Platten.  Durch die Benennung von Vinum-Platten
      wird es erst m&ouml;glich, eine Platte an einen anderen Ort zu
      verschieben und sie trotzdem noch automatisch erkennen zu lassen.
      Plattennamen k&ouml;nnen bis zu 32 Zeichen lang sein.</para>

    <sect2>
      <title>Dateisysteme erstellen</title>

      <para>Volumes erscheinen (mit einer Ausnahme) dem System nicht
	anders als Platten.  Anders als &unix;-Platten partitioniert
	Vinum seine Volumes nicht, weshalb diese auch keine
	Partitionstabellen haben.  Dies wiederum hat Modifikationen an
	einigen Platten-Tools, insbesondere &man.newfs.8;, n&ouml;tig
	gemacht, welche bis dahin den letzten Buchstaben eines
	Vinum-Volume-Namen als Partitionsbezeichner identifiziert haben.
	Zum Beispiel k&ouml;nnte eine Platte einen Namen wie
	<filename class="devicefile">/dev/ad0a</filename> oder
	<filename class="devicefile">/dev/da2h</filename> haben.  Diese Namen
	bedeuten, dass es sich um die erste Partition
	(<devicename>a</devicename>) der ersten (0) IDE-Platte
	(<devicename>ad</devicename>) und respektive die achte
	Partition (<devicename>h</devicename>) der dritten (2)
	SCSI-Platte (<devicename>da</devicename>) handelt.  Im Vergleich
	dazu k&ouml;nnte ein Vinum-Volume beispielsweise <filename
	class="devicefile">/dev/gvinum/concat</filename> hei&szlig;en, ein Name,
	der in keiner Beziehung mit einem Partitionsnamen steht.</para>

      <para>Normalerweise interpretiert &man.newfs.8; den Namen einer
	Platte und beschwert sich, wenn es ihn nicht versteht:</para>

      <screen>&prompt.root; <userinput>newfs /dev/gvinum/concat</userinput>
newfs: /dev/gvinum/concat: can't figure out file system partition</screen>

      <para>Um nun ein Dateisystem auf diesem Volume anzulegen, benutzen
	Sie &man.newfs.8;:</para>

      <screen>&prompt.root; <userinput>newfs /dev/gvinum/concat</userinput></screen>
    </sect2>
  </sect1>

  <sect1 id="vinum-config">
    <title>Vinum konfigurieren</title>

    <para>Der <filename>GENERIC</filename>-Kernel enth&auml;t kein
      Vinum.  Es ist zwar m&ouml;glich, einen speziellen Kernel zu
      bauen, der Vinum beinhaltet, empfohlen wird aber, Vinum als
      ein Kernelmodul (&uuml;ber <acronym>kld</acronym>) zu laden.
      Dazu m&uuml;ssen Sie nicht einmal &man.kldload.8; benutzen,
      da beim Start von &man.gvinum.8; automatisch &uuml;berpr&uuml;ft
      wird, ob das Modul bereits geladen wurde.  Falls das Modul noch
      nicht geladen wurde, wird es daraufhin geladen.</para>

    <sect2>
      <title>Inbetriebnahme</title>

      <para>Vinum speichert seine Konfigurationsinformationen auf den
	Platten-Slices im Wesentlichen genauso ab wie in den
	Konfigurationsdateien.  Beim Lesen der Konfigurationsdatenbank
	erkennt Vinum eine Anzahl von Schl&uuml;sselw&ouml;rtern, die
	in den Konfigurationsdateien nicht erlaubt sind.  Zum Beispiel
	k&ouml;nnte eine Platten-Konfiguration den folgenden Text
	enthalten:</para>

      <programlisting width="119">volume myvol state up
volume bigraid state down
plex name myvol.p0 state up org concat vol myvol
plex name myvol.p1 state up org concat vol myvol
plex name myvol.p2 state init org striped 512b vol myvol
plex name bigraid.p0 state initializing org raid5 512b vol bigraid
sd name myvol.p0.s0 drive a plex myvol.p0 state up len 1048576b driveoffset 265b plexoffset 0b
sd name myvol.p0.s1 drive b plex myvol.p0 state up len 1048576b driveoffset 265b plexoffset 1048576b
sd name myvol.p1.s0 drive c plex myvol.p1 state up len 1048576b driveoffset 265b plexoffset 0b
sd name myvol.p1.s1 drive d plex myvol.p1 state up len 1048576b driveoffset 265b plexoffset 1048576b
sd name myvol.p2.s0 drive a plex myvol.p2 state init len 524288b driveoffset 1048841b plexoffset 0b
sd name myvol.p2.s1 drive b plex myvol.p2 state init len 524288b driveoffset 1048841b plexoffset 524288b
sd name myvol.p2.s2 drive c plex myvol.p2 state init len 524288b driveoffset 1048841b plexoffset 1048576b
sd name myvol.p2.s3 drive d plex myvol.p2 state init len 524288b driveoffset 1048841b plexoffset 1572864b
sd name bigraid.p0.s0 drive a plex bigraid.p0 state initializing len 4194304b driveoff set 1573129b plexoffset 0b
sd name bigraid.p0.s1 drive b plex bigraid.p0 state initializing len 4194304b driveoff set 1573129b plexoffset 4194304b
sd name bigraid.p0.s2 drive c plex bigraid.p0 state initializing len 4194304b driveoff set 1573129b plexoffset 8388608b
sd name bigraid.p0.s3 drive d plex bigraid.p0 state initializing len 4194304b driveoff set 1573129b plexoffset 12582912b
sd name bigraid.p0.s4 drive e plex bigraid.p0 state initializing len 4194304b driveoff set 1573129b plexoffset 16777216b</programlisting>

      <para>Die offensichtlichen Unterschiede sind hier die Anwesenheit
	von Informationen &uuml;ber explizite Speicherorte und
	Benennungen (beides ist zwar erlaubt, aber es wird dem Benutzer
	davon abgeraten, es zu benutzen) und Informationen &uuml;ber die
	Zust&auml;nde (welche f&uuml;r den Benutzer nicht zur
	Verf&uuml;gung stehen).  Vinum speichert keine Informationen
	&uuml;ber Platten in den Konfigurationsinformationen, es findet
	die Platten durch Scannen nach Vinum-Markierungen auf den
	eingerichteten Laufwerken.  Dies erm&ouml;glicht es,
	Vinum-Platten auch dann noch korrekt zu identifizieren, wenn
	sie schon andere &unix;-Platten-IDs zugewiesen bekommen
	haben.</para>

      <sect3 id="vinum-rc-startup">
	<title>Automatische Inbetriebnahme</title>

	<note>
	  <para><emphasis>Gvinum</emphasis>
	    unterst&uuml;tzt eine automatische Inbetriebnahme immer,
	    wenn das Kernelmodul &uuml;ber &man.loader.conf.5; geladen ist.
	    Um das <emphasis>Gvinum</emphasis> Modul beim Hochfahren des
	    Systems zu laden, f&uuml;gen Sie die Zeile
	    <literal>geom_vinum_load="YES"</literal> in
	    <filename>/boot/loader.conf</filename> ein.</para>
	</note>

	<para>Beim starten von Vinum durch den Befehl <command>vinum
	  start</command> liest Vinum die Konfigurationsdatenbank von
	  einer der Vinum-Platten.  Unter normalen Umst&auml;nden
	  enth&auml;lt jede Platte eine identische Kopie der
	  Konfigurationsdatenbank, so dass es keine Rolle spielt, von
	  welcher der Platten diese eingelesen wird.  Nach einem
	  Plattencrash muss Vinum allerdings zun&auml;chst feststellen,
	  welche der Platten zuletzt aktualisiert wurde und dann die
	  Konfiguration von dieser Platte lesen.  Danach werden (falls
	  n&ouml;tig) die Konfigurationen der "alten" Platten
	  aktualisiert.</para>
      </sect3>
    </sect2>
  </sect1>
<!--  2006-01-04__16:15 -->
  <sect1 id="vinum-root">
    <title>Vinum f&uuml;r das Root-Dateisystem benutzen</title>

    <para>Auf einem System, das mit Hilfe von Vinum
      vollgespiegelte Dateisysteme hat, ist es w&uuml;nschenswert, auch
      das Root-Dateisystem zu spiegeln.  Solch eine Konfiguration ist
      allerdings weniger trivial als das Spiegeln eines
      gew&ouml;hnlichen Dateisystems, weil:</para>

    <itemizedlist>
      <listitem>
	<para>Das Root-Dateisystem in einer sehr fr&uuml;hen Phase
	  des Bootvorgangs verf&uuml;gbar sein muss, und damit auch
	  die Vinum-Infrastruktur.</para>
      </listitem>

      <listitem>
	<para>Das Volume, welches das Root-Dateisystem enth&auml;lt,
	  auch den Bootstrap und den Kernel enth&auml;lt, die
	  wiederum nur mit den systemeigenen Tools (zum Beispiel
	  dem BIOS bei handels&uuml;blichen PCs) gelesen werden
	  k&ouml;nnen und meist nicht dazu gebracht werden k&ouml;nnen,
	  Vinum zu verstehen.</para>
      </listitem>
    </itemizedlist>

    <para>Im folgenden Abschnitt wird der Begriff
      <quote>Root-Volume</quote> benutzt, um das Vinum-Volume zu
      beschreiben, welches das Root-Dateisystem enth&auml;lt.  Es ist
      eine gute Idee, f&uuml;r dieses Volume den Namen
      <literal>"root"</literal> zu benutzen, aber es ist in keiner
      Weise technisch n&ouml;tig (Das folgende Beispiel geht allerdings
      davon aus, dass dies der Fall ist.).</para>

    <sect2>
      <title>Vinum f&uuml;r das Root-Dateisystem rechtzeitig
	starten</title>

      <para>Damit dies gelingt, m&uuml;ssen Sie folgende Aufgaben
	erledigen:</para>

      <itemizedlist>
	<listitem>
	  <para>Vinum muss zum Zeitpunkt des Bootvorganges im
	     Kernel zur Verf&uuml;gung stehen.  Deswegen ist die
	     Methode zum Start von Vinum, die in
	     <xref linkend="vinum-rc-startup"> beschrieben wird,
	     f&uuml;r diese Aufgabe nicht geeignet.  Also muss
	     auch der <literal>start_vinum</literal>-Parameter
	     eigentlich <emphasis>nicht</emphasis> gesetzt werden,
	     wenn man das folgende Setup einrichtet.  Die erste
	     M&ouml;glichkeit w&auml;re es, Vinum statisch in den
	     Kernel zu kompilieren, so dass es st&auml;ndig
	     verf&uuml;gbar ist, was aber in der Regel nicht
	     erw&uuml;nscht ist.  Ebenso gibt es die M&ouml;glichkeit
	     <filename>/boot/loader</filename>
	     (<xref linkend="boot-loader">) das Vinum-Kernelmodul
	     fr&uuml;h genug laden zu lassen (und zwar noch bevor
	     der Kernel gestartet wird).  Dies kann bewerkstelligt
	     werden, indem die Zeile</para>

	  <programlisting>geom_vinum_load="YES"</programlisting>

	  <para>in die Datei <filename>/boot/loader.conf</filename>
	    eingetragen wird.</para>
	</listitem>

	<listitem>
	  <para>F&uuml;r <emphasis>Gvinum</emphasis> ist das oben
	    beschriebene Prozedere alles, was Sie tun m&uuml;ssen,
	    da der gesamte Startvorgang automatisch erledigt wird,
	    sobald das Kernelmodul geladen wurde.</para>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>Ein Vinum-basiertes Root-Volume dem Bootstrap
	verf&uuml;gbar machen</title>

      <para>Da der aktuelle &os;-Bootstrap nur 7,5 KB Code
	enth&auml;lt und schon ohne Vinum die Aufgabe hat,
	bestimmte Dateien (wie <filename>/boot/loader</filename>)
	von einem UFS-Dateisystem zu lesen, ist es schier
	unm&ouml;glich, ihm auch noch die Interna von Vinum
	beizubringen, damit er die Vinum-Konfigurationsdaten
	auslesen und die Elemente eines Boot-Volumes selbst
	herausfinden k&ouml;nnte.  Daher sind ein paar Tricks
	n&ouml;tig, um dem Bootstrap-Code die Illusion
	einer Standard-<literal>"a"</literal>-Partition mit
	einem Root-Dateisystem vorzugaukeln.</para>

      <para>Damit dies &uuml;berhaupt m&ouml;glich wird,
	m&uuml;ssen die folgenden Bedingungen f&uuml;r das
	Root-Dateisystem erf&uuml;llt sein:</para>

      <itemizedlist>
	<listitem>
	  <para>Das Root-Volume darf weder gestriped noch
	    RAID-5 sein.</para>
	</listitem>

	<listitem>
	  <para>Das Root-Volume darf nicht mehr als eine konkatenierte
	    Subdisk pro Plexus enthalten.</para>
	</listitem>
      </itemizedlist>

      <para>Beachten Sie, dass es m&ouml;glich und
	w&uuml;nschenswert ist, mehrere Plexus zu haben, von denen
	jeder eine Kopie des Root-Dateisystems enth&auml;lt.  Der
	Bootstrap-Prozess wird hingegen nur einen dieser Plexus
	benutzen, um den Bootstrap und alle Dateien zu finden, bis der
	Kernel letztendlich das Root-Dateisystem selbst laden wird.
	Jede einzelne Subdisk innerhalb dieser Plexus wird dann ihre
	eigene Illusion der Partition <literal>"a"</literal> brauchen,
	damit das entsprechende Ger&auml;t bootbar wird.  Es ist nicht
	unbedingt notwendig, dass sich jede dieser gef&auml;lschten
	<literal>"a"</literal>-Partitionen auf seinem Ger&auml;t an
	einem Ort befindet, der um den selben Wert verschoben ist wie
	auf den anderen Ger&auml;ten, die Plexus des Root-Dateisystems
	enthalten.  Um Unklarheiten zu verhindern, ist es jedoch eine
	gute Idee, die Vinum-Volumes so zu erstellen, dass die
	gespiegelten Ger&auml;te symmetrisch sind.</para>

      <para>Damit diese <literal>"a"</literal>-Partitionen eingerichtet
	werden k&ouml;nnen, muss f&uuml;r alle Ger&auml;te, die Teil des
	Root-Dateisystems sind, folgendes getan werden:</para>

      <procedure>
	<step>
	  <para>Der Ort (Verschiebung vom Beginn des Ger&auml;tes) und
	    die Gr&ouml;&szlig;e der Subdisk, die Teil des Root-Volumes
	    ist, muss untersucht werden:</para>

	  <screen>&prompt.root; <userinput>gvinum l -rv root</userinput></screen>

	  <para>Beachten Sie, dass Vinum-Verschiebungen und
	    -Gr&ouml;&szlig;en in Bytes gemessen werden.  Sie m&uuml;ssen
	    deshalb durch 512 geteilt werden, um die Blockanzahl zu
	    erhalten, wie sie das <command>bsdlabel</command>-Kommando
	    verwendet.</para>
	</step>

	<step>
	  <para>F&uuml;hren Sie den Befehl</para>

	  <screen>&prompt.root; <userinput>bsdlabel -e <replaceable>devname</replaceable></userinput></screen>

	  <para>f&uuml;r jedes Ger&auml;t, dass am Root-Volume beteiligt
	    ist, aus.  <replaceable>devname</replaceable> muss entweder
	    der Name der Platte (wie <devicename>da0</devicename>), im
	    Falle einer Platte ohne Slice-Tabelle oder der Name des
	    Slices (wie <devicename>ad0s1</devicename>) sein.</para>

	  <para>Wenn es schon eine <literal>"a"</literal>-Partition auf
	    dem Ger&auml;t (in der Regel wahrscheinlich ein
	    Pr&auml;-Vinum-Root-Dateisystem) gibt, sollte diese
	    umbenannt werden, damit sie weiterhin verf&uuml;gbar bleibt
	    (nur f&uuml;r den Fall).  Sie wird aber nicht l&auml;nger
	    benutzt, um das System zu starten.  Beachten Sie aber, dass
	    aktive Partitionen (wie ein gemountetes Root-Dateisystem)
	    nicht umbenannt werden k&ouml;nnen, sodass Sie entweder von
	    einem <quote>Fixit</quote>-Medium booten m&uuml;ssen, oder
	    aber mittels eines zweistufigen Prozesses (sofern Sie in einer
	    gespiegelten Umgebung arbeiten) zuerst die Platte
	    &auml;ndern, von der gerade nicht gebootet wurde.</para>

	  <para>Nun muss die Verschiebung der Vinum-Partition (sofern
	    vorhanden) auf diesem Ger&auml;t mit der Veschiebung der
	    entsprechenden Root-Volume-Subdisk addiert werden. Das
	    Resultat wird der <literal>"offset"</literal>-Wert f&uuml;r
	    die neue <literal>"a"</literal>-Partition. Der
	    <literal>"size"</literal>-Wert f&uuml;r diese Partition
	    kann entsprechend der Berechnung ermittelt werden.
	    <literal>"fstype"</literal> sollte <literal>4.2BSD</literal>
	    sein.  Die <literal>"fsize"</literal>-,
	    <literal>"bsize"</literal>-, und
	    <literal>"cpg"</literal>- Werte sollten entsprechend dem
	    eigentlichen Dateisystem gew&auml;hlt werden, obwohl sie in
	    diesem Kontext ziemlich unwichtig sind.</para>

	  <para>Auf diese Art und Weise wird eine neue Partition
	    <literal>"a"</literal> etabliert, die die Vinum-Partition
	    auf diesem Ger&auml;t &uuml;berschneidet.  Beachte Sie, dass
	    das <command>bsdlabel</command>-Kommando diese
	    &Uuml;berschneidung nur erlaubt, wenn die Partition richtig
	    mit dem <literal>"vinum"</literal>-fstype markiert ist.</para>
	</step>

	<step>
	  <para>Das ist alles.  Auf jedem Ger&auml;t befindet sich nun
	    eine gef&auml;lschte <literal>"a"</literal>-Partition, die
	    eine Kopie des Root-Volumes enth&auml;lt. Es wird dringend
	    empfohlen, das Resultat dieser Konfiguration zu
	    &uuml;berpr&uuml;fen:</para>

	  <screen>&prompt.root; <userinput>fsck -n /dev/<replaceable>devname</replaceable>a</userinput></screen>
	</step>
      </procedure>

      <para>Denken Sie stets daran, dass alle Dateien, die
	Kontrollinformationen enthalten, nun relativ zum
	Root-Dateisystem innerhalb des Vinum-Volumes sein m&uuml;ssen.
	Denn ein neu eingerichtetes Vinum-Root-Dateisystem ist
	m&ouml;glicherweise inkompatibel zum gerade aktiven
	Root-Dateisystem.  Deshalb m&uuml;ssen insbesondere die
	Dateien <filename>/etc/fstab</filename> und
	<filename>/boot/loader.conf</filename> &uuml;berpr&uuml;ft
	werden.</para>

      <para>Beim n&auml;chsten Systemstart sollte der Bootstrap die
	ad&auml;quaten Kontrollinformationen des neuen
	Vinum-basierten Root-Dateisystems automatisch herausfinden und
	entsprechend handeln.  Am Ende des
	Kernel-Initialisierungsprozesses (nachdem alle Ger&auml;te
	angezeigt wurden) erhalten Sie bei einer erfolgreichen
	Konfiguration eine Nachricht &auml;hnlich der folgenden:</para>

      <screen>Mounting root from ufs:/dev/gvinum/root</screen>
    </sect2>

    <sect2>
      <title>Beispiel eines Vinum-basierten Root-Setups</title>

      <para>Nachdem das Vinum-Root-Volume eingerichtet wurde,
	k&ouml;nnte die Ausgabe von <command>gvinum l -rv root</command>
	bespielsweise so aussehen:</para>

	<screen>
...
Subdisk root.p0.s0:
		Size:        125829120 bytes (120 MB)
		State: up
		Plex root.p0 at offset 0 (0  B)
		Drive disk0 (/dev/da0h) at offset 135680 (132 kB)

Subdisk root.p1.s0:
		Size:        125829120 bytes (120 MB)
		State: up
		Plex root.p1 at offset 0 (0  B)
		Drive disk1 (/dev/da1h) at offset 135680 (132 kB)
	</screen>

      <para>Wichtig ist hier insbesondere ist der Wert
	<literal>135680</literal> f&uuml;r die Verschiebung (relativ zur
	Partition <filename
	class="devicefile">/dev/da0h</filename>).  Das entspricht
	beim Einsatz von <command>bsdlabel</command> 265
	512-Byte-Plattenbl&ouml;cken.  Dieses Root-Volume ist ebenso
	245760 512-Byte-Bl&ouml;cke gro&szlig;.
	<filename class="devicefile">/dev/da1h</filename> enth&auml;lt die
	zweite Kopie dieses Root-Volumes und ist symmetrisch aufgebaut.</para>

      <para>Das Bsdlabel f&uuml;r diese Ger&auml;te k&ouml;nnte
	so aussehen:</para>

	<screen>
...
8 partitions:
#        size   offset    fstype   [fsize bsize bps/cpg]
  a:   245760      281    4.2BSD     2048 16384     0   # (Cyl.    0*- 15*)
  c: 71771688        0    unused        0     0         # (Cyl.    0 - 4467*)
  h: 71771672       16     vinum                        # (Cyl.    0*- 4467*)
	</screen>

      <para>Wie man leicht feststellen kann, entspricht der Parameter
	<literal>"size"</literal> der gef&auml;lschten
	<literal>"a"</literal>-Partition dem ausgewiesenen Wert von
	oben, w&auml;hrend der Parameter
	<literal>"offset"</literal> gleich der Summe der Verschiebung
	innerhalb der Vinum-Partition <literal>"h"</literal> und der
	Verschiebung innerhalb des Ger&auml;ts (oder Slice) ist.  Dies
	ist ein typischer Aufbau, der n&ouml;tig ist, um die in
	<xref linkend="vinum-root-panic"> beschriebenen Probleme zu
	vermeiden.  Die gesamte Partition <literal>"a"</literal> befindet
	sich in	<literal>"h"</literal>, die alle Vinum-Daten f&uuml;r
	dieses Ger&auml;t enth&auml;lt.</para>

      <para>Beachten Sie, dass in dem oben beschriebenen Beispiel das
	gesamte Ger&auml;t Vinum gewidmet ist und keine
	Pr&auml;-Vinum-Partition zur&uuml;ckgelassen wurde, da es sich
	im Beispiel um eine neu eingerichtete Platte handelt, die nur
	f&uuml;r die Vinum-Konfiguration bestimmt war.</para>
    </sect2>

    <sect2>
      <title>Fehlerbehebung</title>

      <para>Der folgende Abschnitt beschreibt einige bekannte
	Probleme und Fallstricke bei der Vinum-Konfiguration sowie
	deren Behebung.</para>

      <sect3>
	<title>Der System-Bootstrap l&auml;dt zwar, das System startet
	  aber nicht.</title>

	<para>Wenn aus irgendeinem Grund das System nicht mit dem Booten
	  fortf&auml;hrt, kann man den Bootstrap w&auml;hrend der
	  10-Sekunden-Warnung durch Dr&uuml;cken der
	  <keycap>Leertaste</keycap> unterbrechen.  Die
	  <foreignphrase>loader</foreignphrase>-Variablen (wie
	  <literal>vinum.autostart</literal>) k&ouml;nnen mittels des
	  <command>show</command>-Kommandos untersucht, und mit
	  <command>set</command> oder <command>unset</command>
	  ge&auml;ndert werden.</para>

	<para>Wenn das einzige Problem das Fehlen des
	  Vinum-Kernelmoduls in der Liste der automatisch zu ladenden
	  Module ist, hilft ein einfaches
	  <command>load geom_vinum</command>.</para>

	<para>Danach k&ouml;nnen Sie den Bootvorgang mit
	  <command>boot -as</command> fortsetzen.  Die Optionen
	  <option>-as</option> fordern den Kernel auf, nach dem zu
	  mountenden Root-Dateisystem zu fragen (<option>-a</option>),
	  und den Bootvorgang im Single-User-Modus
	  (<option>-s</option>) zu beenden, in dem das
	  Root-Dateisystem schon schreibgesch&uuml;tzt gemountet ist.
	  Auf diese Weise wird keine Dateninkonsistenz zwischen den
	  Plexus riskiert, auch wenn nur ein Plexus eines
	  Multi-Plexus-Volumes gemountet wurde.</para>

	<para>Beim Prompt, das nach einem Root-Dateisystem fragt,
	  kann jedes Ger&auml;t angegeben werden, dass ein
	  g&uuml;ltiges Root-Dateisystem hat.  Wenn
	  <filename>/etc/fstab</filename> richtig konfiguriert
	  wurde, sollte die Vorgabe etwas wie
	  <literal>ufs:/dev/gvinum/root</literal> sein.  Eine typische
	  Alternative w&uuml;rde etwas wie
	  <literal>ufs:da0d</literal> sein, welches eine
	  hypothetische Partition sein k&ouml;nnte, die ein
	  Pre-Vinum-Root-Dateisystem enth&auml;lt. Vorsicht sollte
	  walten, wenn eine der <foreignphrase>alias</foreignphrase>
	  <literal>"a"</literal>-Partitionen hier eingegeben wird, die
	  eigentlich Referenzen auf die Subdisks des
	  Vinum-Root-Dateisystems sind, da so nur ein St&uuml;ck eines
	  gespiegelten Root-Ger&auml;tes gemountet werden w&uuml;rde.
	  Wenn das Dateisystem sp&auml;ter zum Lesen und Schreiben
	  gemountet werden soll, ist es n&ouml;tig, die anderen Plexus
	  des Vinum-Root-Volumes zu entfernen, weil diese Plexus
	  andernfalls inkonsistente Daten enthalten w&uuml;rden.<para>
      </sect3>

      <sect3>
	<title>Nur der prim&auml;re Bootstrap l&auml;dt</title>

	<para>Wenn das Laden von <filename>/boot/loader</filename>
	  fehlschl&auml;gt, aber der prim&auml;re Bootstrap dennoch
	  l&auml;dt (sichtbar an dem einzelnen Strich in der linken
	  Spalte des Bildschirms gleich nachdem der Bootprozess
	  startet), kann man versuchen, den prim&auml;ren Bootstrap
	  an diesem Punkt durch Benutzen der
	  <keycap>Leertaste</keycap> zu unterbrechen.  Dies wird
	  den Bootstrap in der zweiten Phase stoppen (siehe dazu auch
	  <xref linkend="boot-boot1">).  Hier kann nun der Versuch
	  unternommen werden, von einer anderen Partition zu booten,
	  wie beispielsweise dem vorhergehenden Root-Dateisystem,
	  das von <literal>"a"</literal> verschoben wurde.</para>
      </sect3>

      <sect3 id="vinum-root-panic">
	<title>Nichts bootet, der Bootstrap h&auml;ngt sich auf</title>

	<para>Diese Situation wird vorkommen, wenn der Bootstrap durch
	  die Vinum-Installation zerst&ouml;rt worden ist.
	  Ungl&uuml;cklicherweise l&auml;sst Vinum am Anfang seiner
	  Partition nur 4&nbsp;KB frei und schreibt dahinter seine
	  Kopfinformationen.  Allerdings ben&ouml;tigen Stufe-Eins-
	  und -Zwei-Bootstraps plus dem dazwischen eingebetteten
	  <foreignphrase>bsdlabel</foreignphrase> momentan 8&nbsp;KB.
	  Demzufolge wird die Vinum-Installation, wenn die
	  Vinum-Partition mit der Verschiebung 0 (innerhalb eines
	  Slice oder einer Platte, die zum Start bestimmt waren)
	  eingerichtet wurde, den Bootstrap zerst&ouml;ren.</para>

	<para>Analog wird eine anschlie&szlig;ende
	  Reinstallation eines Bootstrap (zum Beispiel durch Booten
	  eines <quote>Fixit</quote>-Mediums) mit
	  <command>bsdlabel -B</command>, wie in
	  <xref linkend="boot-boot1"> beschrieben, den Vinum-Kopf
	  zerst&ouml;ren und Vinum wird seine Platte(n) nicht mehr
	  finden k&ouml;nnen.  Obwohl keine eigentlichen
	  Vinum-Konfigurationsdaten oder Daten in den Vinum-Volumes
	  zerst&ouml;rt werden und es m&ouml;glich w&auml;re, alle
	  Daten wiederherzustellen, indem die exakt gleichen
	  Vinum-Konfigurationsdaten noch einmal eingegeben werden,
	  bleibt die Situation schwer zu bereinigen, da es n&ouml;tig
	  ist, die gesamte Vinum-Partition um mindestens
	  4&nbsp;KB nach hinten zu verschieben, damit Bootstrap
	  und Vinum-Kopf nicht mehr kollidieren.</para>
      </sect3>
    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
