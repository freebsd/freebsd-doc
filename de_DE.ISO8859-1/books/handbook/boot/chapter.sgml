<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     Original version 1.33
     $FreeBSD$
     $FreeBSDde: de-docproj/books/handbook/boot/chapter.sgml,v 1.7 2002/03/17 11:25:00 mheinen Exp $
-->

<chapter id="boot">
  <title>FreeBSDs Bootvorgang</title>

  <sect1 id="boot-synopsis">
    <title>&Uuml;bersicht</title>
    <indexterm><primary>booting</primary></indexterm>
    <indexterm><primary>bootstrap</primary></indexterm>

    <para>Das Starten des Computers und das Laden des Betriebssystems
      wird im Allgemeinen als <quote>bootstrap Vorgang</quote>
      bezeichnet, oder einfach als <quote>Booten</quote>. FreeBSDs
      Bootvorgang erm&ouml;glicht gro&szlig;e Flexibilit&auml;t, was
      das Anpassen dessen anbelangt, was passiert, wenn das System
      gestartet wird. Es kann zwischen verschiedenen Betriebssystemen,
      die auf demselben Computer installiert sind oder verschiedenen
      Versionen desselben Betriebssystems oder installierten Kernels
      gew&auml;hlt werden.</para>


    <para>Dieses Kapitel zeigt die zur Verf&uuml;gung stehenden Konfigurationsm&ouml;glichkeiten und
      wie man den Bootvorgang anpasst. Dies schlieﬂt alles ein, bis
      der Kernel gestartet worden ist, der dann alle Ger&auml;te
      gefunden hat und &man.init.8; gestartet hat. Falls Sie sich
      nicht ganz sicher sind, wann dies passiert: Es passiert, wenn
      die Farbe des Textes w&auml;hrend des Bootvorgangs von weiﬂ zu
      Hellgrau wechselt.</para>

    <para>Dieses Kapitel informiert &uuml;ber folgende Punkte:</para>

    <itemizedlist>
      <listitem>
	<para>Die Komponenten des FreeBSD Bootstraps und deren Interaktion.</para>
      </listitem>

      <listitem>
	<para>Die Optionen, die die Komponenten im FreeBSD Bootstrap zum Kontrollieren des Bootvorgangs nehmen.</para>
      </listitem>
    </itemizedlist>

    <note>
      <title>nur x86</title>

      <para>Dieses Kapitel erkl&auml;rt den Bootvorgang von FreeBSD auf
        Intel X86 Plattformen.</para>
    </note>
  </sect1>

  <sect1 id="boot-introduction">
    <title>Das Problem des Bootens</title>

    <para>Wenn der Computer Eingeschaltet wird und das Betriebssystem gestartet
      werden soll, entsteht ein interessantes Dilemma, denn der
      Computer weiﬂ per Definition nicht, wie er irgendetwas tut, bis
      das Betriebssystem gestartet wurde. Das schlieﬂt das Starten von
      Programmen, die sich auf der Festplatte befinden, ein. Wenn nun
      der Computer kein Programm von der Festplatte starten kann, sich
      das Betriebssystem aber dummerweise genau dort befindet, wie
      wird es dann gestartet?</para>

    <para>Dieses Problem &auml;hnelt einer Geschichte des Barons von
      M&uuml;nchhausen. Dort war eine Person in einen Sumpf gefallen
      und hat sich selbst an den Riemen seiner Stiefel (engl.:
      bootstrap) herausgezogen. In den jungen Jahren des
      Computerzeitalters wurde mit dem Begriff bootstrap dann die
      Technik das Betriebssystem zu laden bezeichnet und wurde
      hinterher mit booten abgek&uuml;rzt.</para>

    <para>Auf x86 Plattformen ist das BIOS (Basic Input/Output System)
      daf&uuml;r verantwortlich das Betriebssystem zu laden. Dazu
      liest das BIOS den Master Bootsektor (MBR; Master Boot Record)
      aus, der sich an einer bestimmten Stelle auf der
      Festplatte/Diskette befinden muss. Das BIOS kann den MBR
      selbstst&auml;ndig laden und ausf&uuml;hren und geht davon aus,
      dass der die restlichen Dinge, die f&uuml;r das Laden des
      Betriebssystems notwendig sind, selber erledigen kann. </para>

    <indexterm>
      <primary>BIOS</primary>
      <secondary>Basic Input/Output System</secondary>
    </indexterm>

    <para>Falls nur ein Betriebssystem installiert ist, ist der
      standard MBR ausreichend. Dieser MBR sucht nach dem ersten
      bootbaren slice auf dem Laufwerk und f&uuml;rt ihn aus, um das
      restliche Betriebssystem zu laden.</para>

    <para>Falls mehrere Betriebssysteme installiert sind, sollte
      man einen anderen MBR installieren, der eine Liste der
      verf&uuml;gbaren Betriebssysteme anzeigt und einen w&auml;hlen
      l&auml;sst, welches man booten m&ouml;chte. FreeBSD liegt ein
      solcher MBR bei und andere Hersteller bieten Alternativen
      an.</para>

    <para>Das Restliche FreeBSD bootstrap System ist in drei Phasen
      unterteilt. Die erste Phase wird vom MBR durchgef&uuml;hrt, der
      gerade genug Funktionalit&auml;t besitzt um den Computer in
      einen bestimmten Status zu verhelfen und die zweite Phase zu
      starten. Die zweite Phase f&uuml;hrt ein wenig mehr Operationen
      durch und startet schlieﬂlich die dritte Phase, die das Laden
      des Betriebssystems abschlieﬂt. Der ganze Prozess wird in drei
      Phasen durchgef&uuml;hrt, weil der PC Standard die Gr&ouml;ﬂe
      der Programme, die in Phase eins und zwei ausgef&uuml;hrt
      werden, limitiert. Durch das Verketten der durchzuf&uuml;hrenden
      Aufgaben wird es FreeBSD m&ouml;glich ein sehr flexibles
      Ladeprogramm zu besitzen.</para>

    <indexterm><primary>kernel</primary></indexterm>
    <indexterm><primary><command>init</command></primary></indexterm>

    <para>Als n&auml;chstes wird der Kernel gestartet, der zun&auml;chst nach
      Ger&auml;ten sucht und sie f&uuml;r den Gebrauch
      initialisiert. Nach dem Booten des Kernels &uuml;bergibt dieser
      die Kontrolle an den Benutzer Prozess &man.init.8;, der erst
      sicherstellt, dass alle Laufwerke benutzbar sind und die
      Ressourcen Konfiguration auf Benutzer Ebene startet.  Diese
      wiederum mountet Dateisysteme, macht die Netzwerkkarten f&uuml;r
      die Kommunikation mit dem Netzwerk bereit und startet generell
      alle Prozesse, die auf einem FreeBSD System normalerweise beim
      Hochfahren gestartet werden.</para>
</sect1>

  <sect1 id="boot-blocks">
    <title>Der MBR, und die Boot-Phasen Eins, Zwei und Drei</title>

    <sect2 id="boot-boot0">
      <title>Der MBR, <filename>/boot/boot0</filename></title>
      <indexterm><primary>Master Boot Record (MBR)</primary></indexterm>

      <para>Der Master Boot Record (MBR) von FreeBSD befindet sich im
	Verzeichnis <filename>/boot/boot0</filename>.  Allerdings ist dies
	nur eine <emphasis>Kopie</emphasis> des MBR, da der eigentliche
	MBR auf einem Teil des Laufwerks gespeichert sein muss, der auﬂerhalb
        von FreeBSDs benutzbaren Bereich ist.</para>

      <para><filename>boot0</filename> ist ein ziemlich simples
        Programm, und zwar aus dem einfachen Grund, dass der MBR nur
        512 bytes groﬂ sein darf. Falls Sie den FreeBSD MBR
        installiert haben und sich mehrere Betriebssysteme auf Ihrer
        Festplatte befinden, werden Sie beim Starten des Computers
        eine Anzeige sehen, &auml;hnlich der Folgenden:</para>


      <example id="boot-boot0-example">
	<title><filename>boot0</filename> Screenshot</title>

	<screen>F1 DOS
F2 FreeBSD
F3 Linux
F4 ??
F5 Drive 1

Default: F2</screen>
      </example>

      <para>Diverse Betriebssysteme, insbesondere Windows 95 und
        Nachfolger, &uuml;berschreiben den MBR ungefragt mit ihrem
        eigenen. Falls einem dies passiert sein sollte, kann man mit
        folgendem Kommando den momentanen MBR durch den FreeBSD MBR
        ersetzen:</para>

      <screen>&prompt.root; <userinput>fdisk -B -b /boot/boot0 <replaceable>Ger&auml;t</replaceable></userinput></screen>

      <para>Wobei <replaceable>Ger&auml;t</replaceable> das Ger&auml;t ist, von
        dem gebootet wird, also z.B. <devicename>ad0</devicename>
        f&uuml;r die erste IDE Festplatte,
        <devicename>ad2</devicename> f&uuml;r die erste IDE Festplatte
        am zweiten IDE Controller, <devicename>da0</devicename>
        f&uuml;r die erste SCSI Festplatte, usw.</para>

      <para>Wenn Sie auf demselben Rechner FreeBSD und Linux benutzen
        m&ouml;chten, k&ouml;nnen Sie den FreeBSD Boot-Manager oder
	<application>LILO</application> benutzen.  Wollen Sie den MBR von
	<application>LILO</application> benutzen, w&auml;hlen Sie
	bei der FreeBSD Installation im Boot Manager Men&uuml; 
	<!-- Link auf Install-Kapitel einfuegen -->
	<option>Leave The Master Boot Record Untouched</option> aus.  Damit
	Sie das FreeBSD System aus <application>LILO</application> booten
	k&ouml;nnen, tragen Sie in <filename>/etc/lilo.conf</filename> die
	folgenden Zeilen Zeilen ein:</para>

      <programlisting>other=/dev/<replaceable>diskXY</replaceable>
table=/dev/<replaceable>diskX</replaceable>
loader=/boot/chain.b
label=FreeBSD</programlisting>

      <para>Ersetzen Sie dabei <replaceable>diskXY</replaceable> mit
        <literal>hd<replaceable>XY</replaceable></literal>, wenn Sie
	ein IDE-Laufwerk benutzen, oder mit
	<literal>sd<replaceable>XY</replaceable></literal>, wenn Sie
	ein SCSI-Laufwerk benutzen.  Mit
	<replaceable>XY</replaceable> geben Sie die Slice des FreeBSD
	Systems, zum Beispiel <literal>/dev/hdb1</literal>, an.  Wenn sich
	beide Betriebssysteme auf derselben Platte befinden, k&ouml;nnen
	Sie <option>loader=/boot/chain.b</option> auch weglassen.  Mit
	<option>table</option> geben Sie das Ger&auml;t an, auf dem die
	Partitionstabelle liegt, <literal>/dev/hdb</literal> bezeichnet
	zum Beispiel das zweite IDE-Laufwerk.  Die &Auml;nderungen
	k&ouml;nnen Sie nun mit <command>/sbin/lilo -v</command>
	aktivieren.  Achten Sie dabei auf die Bildschirmausgabe, die den
	Erfolg der Operation anzeigt.</para>
    </sect2>
  
    <sect2 id="boot-boot1">
      <title>Phase Eins, <filename>/boot/boot1</filename> und Phase Zwei,
	<filename>/boot/boot2</filename></title>
      
      <para>Im Prinzip sind die erste und die zweite Phase Teile des
        selben Programms, im selben Bereich auf der
        Festplatte. Aufgrund von Speicherplatz-Beschr&auml;nkungen
        wurden sie aufgeteilt, aber man installiert sie eigentlich
        generell zusammen.</para>

      <para>Sie befinden sich beide im Bootsektor des Boot-Slices,
        wo <link linkend="boot-boot0">boot0</link> und jedes andere
        Programm im <abbrev>MBR</abbrev> das Programm erwartet, das
        den weiteren Bootvorgang durchf&uuml;hrt. Die Dateien im
        Verzeichnis <filename>/boot</filename> sind nur Kopien der
        eigentlichen Dateien, die sich auﬂerhalb FreeBSDs Dateisystems
        befinden.</para>

      <para><filename>boot1</filename> ist ebenfalls ein sehr simples
        Programm, da es auch nur 512 byte groﬂ sein darf, und es
        besitzt gerade genug Funktionalit&auml;t um FreeBSDs
        <firstterm>disklabel</firstterm>, das Informationen &uuml;ber
        den Slice enth&auml;lt, auszulesen um
        <filename>boot2</filename> zu finden und
        auszuf&uuml;hren.</para>
      
      <para><filename>boot2</filename> ist schon ein wenig
        umfangreicher und besitzt gen&uuml;gend Funktionalit&auml;t um
        Dateien in FreeBSDs Dateisystem zu finden. Auﬂerdem hat es
        eine einfache Schnittstelle, die es erm&ouml;glicht, den zu
        ladenden Kernel oder Loader auszuw&auml;hlen.</para>

      <para>Da der <link linkend="boot-loader">loader</link> einen
        weitaus gr&ouml;ﬂeren Funktionsumfang hat und eine sch&ouml;ne
        und einfach zu bedienende Boot-Konfigurations-Schnitstelle zur
        Verf&uuml;gung stellt, wird er gew&ouml;hnlich von
        <filename>boot2</filename> anstatt des Kernels
        gestartet. Fr&uuml;her war es jedoch dazu da den Kernel direkt
        zu starten.</para>

      <example id="boot-boot2-example">
	<title><filename>boot2</filename> Screenshot</title>

	<screen>&gt;&gt; FreeBSD/i386 BOOT
Default: 0:ad(0,a)/kernel
boot:</screen>
      </example>

      <para>Um das installierte
        <filename>boot1</filename> und <filename>boot2</filename> zu
        ersetzen, benutzt man &man.disklabel.8;:</para>

      <screen>&prompt.root; <userinput>disklabel -B <replaceable>Slice</replaceable></userinput></screen>

      <para>Wobei <replaceable>Slice</replaceable> Laufwerk und Slice
        darstellt, von dem gebootet wird, also
        z.B. <devicename>ad0s1</devicename> f&uuml;r den ersten Slice
        auf der ersten IDE Festplatte.</para>

      <warning>
	<title>Dangerously Dedicated Mode</title>

	<para>Wenn man nur den Festplatten-Namen, also
          z.B. <devicename>ad0</devicename>, in &man.disklabel.8;
          benutzt wird eine "dangerously dedicated disk" erstellt,
          ohne slices.  Das ist ein Zustand, den man meistens nicht
          hervorrufen m&ouml;chte. Aus diesem Grund sollte man ein
          &man.disklabel.8; Kommando noch einmal pr&uuml;fen, bevor
          man <keycap>Return</keycap> bet&auml;tigt.</para>
      </warning>
    </sect2>

    <sect2 id="boot-loader">
      <title>Phase drei, <filename>/boot/loader</filename></title>

      <indexterm><primary>boot-loader</primary></indexterm>
      <para>Der boot-loader ist der letzte von drei Schritten im
        Bootstrap Prozess und kann im Dateisystem normalerweise unter
        <filename>/boot/loader</filename> gefunden werden.</para>
      
      <para>Der Loader soll eine Benutzerfreundliche
        Konfigurations-Schnittstelle sein mit einem einfach zu
        bedienenden eingebauten Befehlssatz, erg&auml;nzt durch einen
        umfangreichen Interpreter mit einem komplexeren
        Befehlssatz.</para>

      <sect3 id="boot-loader-flow">
        <title>Loader Ablauf</title>
      
        <para>Der Loader sucht w&auml;hrend seiner Initialisierung
          nach Konsolen und Laufwerke, findet heraus, von welchem
          Laufwerk er gerade bootet und setzt dementsprechend
          bestimmte Variablen. Dann wird ein Interpreter gestartet,
          der Befehle interaktiv oder von einem Skript empfangen
          kann.</para>
        <indexterm><primary>loader</primary></indexterm>
        <indexterm><primary>loader Konfiguration</primary></indexterm>

        <para>Danach liest der Loader die Datei
          <filename>/boot/loader.rc</filename> aus, welche ihn
          standardm&auml;ﬂig anweist
          <filename>/boot/defaults/loader.conf</filename> zu lesen, wo
          sinnvolle Standardeinstellungen f&uuml;r diverse Variablen
          festgelegt werden und wiederum
          <filename>/boot/loader.conf</filename> f&uuml;r lokale
          &Auml;nderungen an diesen Variablen ausgelesen
          wird. Anschlieﬂend arbeitet dann
          <filename>loader.rc</filename> entsprechend dieser Variablen
          und l&auml;dt die ausgew&auml;hlten Module und den
          gew&uuml;nschten Kernel.</para>

        <para>Abschlieﬂend wartet der Loader standardm&auml;ﬂig 10
          Sekunden lang auf eine Tastatureingabe und bootet den
          Kernel, falls keine Taste bet&auml;tigt wurde. Falls doch
          eine Taste bet&auml;tigt wurde wird dem Benutzer eine
          Eingabeaufforderung angezeigt. Sie nimmt einen einfach zu
          bedienenden Befehlssatz entgegen, der es dem Benutzer
          erlaubt &auml;nderungen an Variablen vorzunehmen, Module zu
          laden, alle Module zu entladen oder schlieﬂlich zu booten
          bzw. neu zu booten.</para>

      </sect3>
    
      <sect3 id="boot-loader-commands">
        <title>Die eingebauten Befehle des Loaders</title>
      
        <para>Hier werden nur die gebr&auml;uchlichsten Befehle
          bearbeitet. F&uuml;r eine ersch&ouml;pfende Diskussion aller
          verf&uuml;gbaren Befehle konsultieren Sie bitte
          &man.loader.8;.</para>

      <variablelist>
	<varlistentry>
	  <term>autoboot <replaceable>Sekunden</replaceable></term>

	  <listitem>
	    <para>Es wird mit dem Booten des Kernels fortgefahren,
              falls keine Taste in der gegebenen Zeitspanne
              bet&auml;tigt wurde. Es wird ein Countdown angezeigt und
              die standardm&auml;ssige Zeitspanne ist 10
              Sekunden.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>boot
	    <optional><replaceable>-options</replaceable></optional>
	    <optional><replaceable>Kernelname</replaceable></optional></term>

	  <listitem>
	    <para>Bewirkt das sofortige booten des Kernels mit den
              gegebenen Optionen, falls welche angegeben wurden, und
              mit den angegebenen Kernel, falls denn einer angegeben
              wurde.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>boot-conf</term>

	  <listitem>
	    <para>Bewirkt die automatische Konfiguration der Module,
              abh&auml;ngig von den entsprechenden Variablen. Dieser
              Vorgang ist identisch zu dem Vorgang, den der Bootloader
              ausf&uuml;hrt und daher nur sinnvoll, wenn zuvor
              <command>unload</command> benutzt wurde und Variablen
              (gew&ouml;hnlich <envar>kernel</envar>) ver&auml;ndert
              wurden.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>help
	    <optional><replaceable>Thema</replaceable></optional></term>

	  <listitem>
	    <para>Zeigt die Hilfe an, die zuvor aus der Datei
              <filename>/boot/loader.help</filename> gelesen
              wird. Falls <literal>index</literal> als Thema angegeben
              wird, wird die Liste der zur Verf&uuml;gung stehenden
              Hilfe-Themen angezeigt.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>include <replaceable>Dateiname</replaceable>
	    &hellip;</term>

	  <listitem>
	    <para>Verarbeitet die angegebene Datei. Das Einlesen und
	      Interpretieren geschieht Zeile f&uuml;r Zeile und wird im Falle eines
	      Fehlers umgehend unterbrochen.</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>load <optional><option>-t</option>
	    <replaceable>Typ</replaceable></optional>
	    <replaceable>Dateiname</replaceable></term>

	  <listitem>
	    <para>L&auml;dt den Kernel, das Kernel-Modul, oder die Datei
	      des angegebenen Typs. Optionen, die auf den Dateinamen folgen, werden
	      der Datei &uuml;bergeben.</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>ls <optional><option>-l</option></optional>
	    <optional><replaceable>Pfad</replaceable></optional></term>

	  <listitem>
	    <para>Listet die Dateien im angegebenen Pfad auf, oder das
	      root-Verzeichnis(/), falls kein Pfad angegeben
	      wurde. Die Option <option>-l</option> bewirkt, dass die
	      Dateigr&ouml;ssen ebenfalls angezeigt werden.</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>lsdev <optional><option>-v</option></optional></term>

	  <listitem>
	    <para>Listet alle Ger&auml;te auf, f&uuml;r die Module geladen
	      werden k&ouml;nnen. Die option <option>-v</option> bewirkt
	      eine detailreichere Ausgabe.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>lsmod <optional><option>-v</option></optional></term>

	  <listitem>
	    <para>Listet alle geladenen Module auf. Die option
	      <option>-v</option> bewirkt eine detailreichere
	      Ausgabe.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>more <replaceable>Dateiname</replaceable></term>

	  <listitem>
	    <para>Zeigt den Dateinhalt der angegebenen Datei an, wobei
	      eine Pause alle <varname>LINES</varname> Zeilen gemacht
	      wird.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>reboot</term>

	  <listitem>
	    <para>Bewirkt einen umgehenden Neustart des Systems.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>set <replaceable>Variable</replaceable></term>
	  <term>set
	    <replaceable>Variable</replaceable>=<replaceable>Wert</replaceable></term>

	  <listitem>
	    <para>Setzt die Umgebungsvariablen des Loaders.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>unload</term>

	  <listitem>
	    <para>Entl&auml;dt s&auml;mtliche geladenen Module.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect3>

    <sect3 id="boot-loader-examples">
      <title>Beispiele f&uuml;r die Loader Bedienung.</title>

      <para>Hier ein paar praktische Beispiele f&uuml;r die Bedienung des Loaders.</para>

      <itemizedlist>
	<indexterm><primary>Single-User Modus</primary></indexterm>
	<listitem>
	  <para>Um den gew&ouml;hnlichen Kernel im Single-User Modus zu
	    starten:</para>

	  <screen><userinput>boot -s</userinput></screen>
	</listitem>

	<listitem>
	  <para>Um alle gew&ouml;hnlichen Kernelmodule zu entladen und dann
	    nur den alten (oder jeden beliebigen anderen) Kernel zu
	    laden:</para>
    <indexterm>
      <primary><filename>kernel.old</filename></primary>
    </indexterm>

	  <screen><userinput>unload</userinput>
<userinput>load <replaceable>kernel.old</replaceable></userinput></screen>

	  <para>Es kann <filename>kernel.GENERIC</filename> verwendet
            werden, um den allgemeinen, Kernel zu bezeichnen, der
            vorinstalliert wird. <filename>kernel.old</filename>
            bezeichnet den Kernel, der vor dem aktuellen installiert
            war (falls man einen neuen Kernel compiliert und
            installiert hat, zum Beispiel).</para>
	  <note>
	    <para>Der folgende Befehl l&auml;dt die gew&ouml;hnlichen Module mit
              einem anderen Kernel:</para>

	    <screen><userinput>unload</userinput>
<userinput>set kernel="<replaceable>kernel.old</replaceable>"</userinput>
<userinput>boot-conf</userinput></screen></note>
	</listitem>

	<listitem>
	  <para>Folgendes l&auml;dt ein Kernel-Konfigurations-Skript (ein
	    automatisiertes Skript, dass das Selbe tut, was der
	    Benutzer normalerweise von Hand an der Eingabeaufforderung
	    durchf&uuml;hren w&uuml;rde):</para>

	  <screen><userinput>load -t userconfig_script <replaceable>/boot/kernel.conf</replaceable></userinput></screen>
	</listitem>
      </itemizedlist>
  </sect3>
    </sect2>
  </sect1>

  <sect1 id="boot-kernel">
    <title>Kernel Interaktion w&auml;hrend des Bootprozesses</title>
    <indexterm>
      <primary>kernel</primary>
      <secondary>boot interaction</secondary>
    </indexterm>

    <para>Wenn der Kernel einmal geladen ist, entweder durch den <link
	linkend="boot-loader">Loader</link> (die Standardmethode) oder
	durch <link linkend="boot-boot1">boot2</link> (den Loader
	umgehend), verh&auml;lt sich gem&auml;ﬂ seiner Boot-Flags, falls es
	welche gibt.</para>

    <sect2 id="boot-kernel-bootflags">
      <indexterm>
        <primary>kernel</primary>
        <secondary>bootflags</secondary>
      </indexterm>
      <title>Kernel Boot-Flags</title>

      <para>Es folgt eine Auflistung der gebr&auml;uchlichsten
        Boot-Flags:</para>

      <variablelist id="boot-kernel-bootflags-list">
	<varlistentry>
	  <term><option>-a</option></term>

	  <listitem>
	    <para>Bewirkt, dass der Benutzer w&auml;hrend der
	      Kernel-Initialisierung gefragt wird, welches Ger&auml;t als
	      Root-Dateisystem gemounted werden soll.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-C</option></term>

	  <listitem>
	    <para>Es wird von CDROM gebootet.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-c</option></term>

	  <listitem>
	    <para>UserConfig, das Boot-Zeit Konfigurationsprogramm,
	      wird gestartet.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-s</option></term>

	  <listitem>
	    <para>Bewirkt den Start des Single-User Modus.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-v</option></term>

	  <listitem>
	    <para>Zeigt mehr Informationen w&auml;hrend des Starten des
	      Kernels an.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <note>
        <para>F&uuml;r Informationen &uuml;ber weitere Boot-Flags konsultieren
	  Sie bitte &man.boot.8;.</para></note>
    </sect2>

<!--    <sect2 id="boot-kernel-userconfig">
      <title>UserConfig: Das Boot-Zeit Konfigurationsprogramm</title>
      
      <para> </para>
    </sect2> -->
  </sect1>

  <sect1 id="boot-init">
    <indexterm>
      <primary><command>init</command></primary>
    </indexterm>
    <title>Init: Initialisierung der Prozess-Kontrolle</title>
	
    <para>Nachdem der Kernel den Bootprozess abgeschlossen hat
      &uuml;bergibt er die Kontrolle an den Benutzer-Prozess
      <command>init</command>. Dieses Programm befindet sich in
      <filename>/sbin/init</filename>, oder dem Pfad, der durch die
      Variable <envar>init_path</envar> im <command>Loader</command>
      spezifiziert wird.</para>

    <sect2 id="boot-autoreboot">
      <title>Der automatische Reboot-Vorgang</title>
      
      <para>Der automatische Reboot-Vorgang stellt sicher, dass alle
        Dateisysteme des Systems konsistent sind. Falls dies nicht der
        Fall ist und die Inkonsistenz nicht durch
        <command>fsck</command> behebbar ist, schaltet
        <command>init</command> das System in den <link
        linkend="boot-singleuser">Single-User Modus</link>, damit der
        Systemadministrator sich des Problems annehmen kann.</para>
    </sect2>

    <sect2 id="boot-singleuser">
      <title>Der Single-User Modus</title>
      <indexterm><primary>Single-User Modus</primary></indexterm>
      <indexterm><primary>console</primary></indexterm>
      
      <para>Das Schalten in diesen Modus kann erreicht werden durch <link
	linkend="boot-autoreboot">den automatischen
	Reboot-Vorgang</link>, durch das Booten mit der Option
	<option>-s</option> oder das Setzen der
	<envar>boot_single</envar> Variable in
	<command>Loader</command>.</para>

      <para>Weiterhin kann der Single-User Modus aus dem <link
        linkend="boot-multiuser">Multi-User Modus</link> heraus durch
        den Befehl <command>shutdown</command> ohne die reboot
        (<option>-r</option>) oder halt (<option>-h</option>) Option
        erreicht werden.

      <para>Falls die System-Konsole (<literal>console</literal>) in
        <filename>/etc/ttys</filename> auf <literal>insecure</literal>
        (dt.: unsicher) gesetzt ist fordert das System allerdings zur
        Eingabe des root Passworts auf, bevor es den Single-User Modus
        aktiviert.</para>

      <example id="boot-insecure-console">
	<title>Auf Insecure gesetzte Konsole in /etc/ttys</title>

	<programlisting># name  getty                           type    status          comments
#
# If console is marked "insecure", then init will ask for the root password
# when going to single-user mode.
console none                            unknown off insecure</programlisting>
      </example>

      <note>
        <para>Eine Konsole sollte auf <literal>insecure</literal>
	  gesetzt sein, wenn die physikalische Sicherheit der Konsole
	  nicht gegeben ist und sichergestellt werden soll, dass nur
	  Personen, die das root-Passwort kennen den Single-User Modus
	  benutzen k&ouml;nnen. Es bedeutet nicht, dass die Konsole
	  "unsicher" laufen wird. Daher sollte man
	  <literal>insecure</literal> w&auml;hlen, wenn man auf Sicherheit
	  bedacht ist, nicht <literal>secure</literal>.</para>
      </note>
    </sect2>
    
    <sect2 id="boot-multiuser">
      <title>Multi-User Modus</title>
      <indexterm><primary>Multi-User Modus</primary></indexterm>
      
      <para>Stellt <command>init</command> fest, dass das Dateisystem
        in Ordnung ist, oder der Benutzer den <link
        linkend="boot-singleuser">Single-User Modus</link> beendet,
        schaltet das System in den Multi-User Modus, in dem dann die
        Ressourcen Konfiguration des Systems gestartet wird.</para>

      <sect3 id="boot-rc">
      <indexterm><primary>rc Dateien</primary></indexterm>
	<title>Ressourcen Konfiguration (engl.: resource configuration, rc)</title>

	<para>Das Ressourcen Konfigurationssystem liest seine
	  Standardkonfiguration von
	  <filename>/etc/defaults/rc.conf</filename> und
	  System-spezifische Details von
	  <filename>/etc/rc.conf</filename>. Dann mountet es das
	  Dateisystem gem&auml;ﬂ <filename>/etc/fstab</filename>, startet
	  die Netzwerkdienste, diverse System Daemons und f&uuml;hrt
	  schlieﬂlich die Startup-Skripte der lokal installierten
	  Programmpakete (packages) aus.</para>

	<para>Die &man.rc.8; Handbuch Seite ist eine gute Quelle f&uuml;r
	  Informationen &uuml;ber das Ressourcen Konfigurationssystem und
	  ebenso &uuml;ber die Skripte ansich.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="boot-shutdown">
    <title>Der Shutdown Vorgang</title>
    <indexterm>
      <primary><command>shutdown</command></primary>
    </indexterm>

    <para>Im Falle eines kontrollierten herunterfahrens durch
      <command>shutdown</command> f&uuml;hrt init das
      <filename>/etc/rc.shutdown</filename> Skript aus, sendet dann
      s&auml;mtlichen Prozessen ein <literal>TERM</literal> Signal und
      schlieﬂlich ein <literal>KILL</literal> Signal an alle Prozesse,
      die sich nicht schnell genug beendet haben.</para>
  </sect1>
</chapter>

<!-- 
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
