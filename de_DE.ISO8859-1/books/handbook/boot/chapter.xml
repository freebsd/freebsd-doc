<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde: de-docproj/books/handbook/boot/chapter.xml,v 1.63 2012/04/22 20:05:15 bcr Exp $
     basiert auf: r48529
-->
<chapter xmlns="http://docbook.org/ns/docbook"
  xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0"
  xml:id="boot">
  <info>
    <title>&os;s Bootvorgang</title>

    <authorgroup>
      <author>
	<personname>
	  <firstname>Hans-Christian</firstname>
	  <surname>Ebke</surname>
	</personname>
	<contrib>Übersetzt von </contrib>
      </author>
    </authorgroup>
  </info>

  <sect1 xml:id="boot-synopsis">
    <title>Übersicht</title>

    <indexterm><primary>booten</primary></indexterm>
    <indexterm><primary>Bootstrap</primary></indexterm>

    <para>Das Starten des Computers und das Laden des Betriebssystems
      wird im Allgemeinen als <quote>Bootstrap-Vorgang</quote>, oder
      als <quote>Booten</quote> bezeichnet.  &os;s Bootvorgang
      ermöglicht große Flexibilität, was das Anpassen dessen
      anbelangt, was passiert, wenn das System gestartet wird.  Es
      kann zwischen verschiedenen Betriebssystemen, die auf demselben
      Computer installiert sind oder verschiedenen Versionen desselben
      Betriebssystems oder installierten Kernels gewählt
      werden.</para>

    <para>Dieses Kapitel zeigt die zur Verfügung stehenden
      Konfigurationsmöglichkeiten und wie man den Bootvorgang anpasst.
      Dies schließt alles ein, bis der Kernel gestartet worden ist,
      der dann alle Geräte gefunden hat und &man.init.8; gestartet
      hat.  Dies passiert, wenn die Farbe des Textes während des
      Bootvorgangs von weiß zu grau wechselt.</para>

    <para>Dieses Kapitel informiert über folgende Punkte:</para>

    <itemizedlist>
      <listitem>
	<para>Die Komponenten des &os;-Bootvorgangs und deren
	  Interaktion.</para>
      </listitem>

      <listitem>
	<para>Die Optionen, mit denen der &os;-Bootvorgang gesteuert
	  werden kann.</para>
      </listitem>

      <listitem>
	<para>Wie ein angepasster Willkommensbildschirm beim Booten
	  konfiguriert wird.</para>
      </listitem>

      <listitem>
	<para>Wie Geräte mit &man.device.hints.5; konfiguriert
	  werden.</para>
      </listitem>

      <listitem>
	<para>Wie das System in den Single-User-Modus und in den
	  Mehrbenutzer-Modus gestartet wird und wie ein &os;-System
	  ordnungsgemäß heruntergefahren wird.</para>
      </listitem>
    </itemizedlist>

    <note>
      <para>Dieses Kapitel erklärt den Bootvorgang von &os; auf Intel
	x86- und amd64-Plattformen.</para>
    </note>
  </sect1>

  <sect1 xml:id="boot-introduction">
    <title>&os;s Bootvorgang</title>

    <para>Wenn der Computer eingeschaltet wird und das Betriebssystem
      gestartet werden soll, entsteht ein interessantes Dilemma, denn
      der Computer weiß per Definition nicht, wie er irgendetwas tut,
      bis das Betriebssystem gestartet wurde.  Das schließt das
      Starten von Programmen, die sich auf der Festplatte befinden,
      ein.  Wenn der Computer kein Programm von der Festplatte
      starten kann, sich das Betriebssystem aber genau dort befindet,
      wie wird es dann gestartet?</para>

    <para>Dieses Problem ähnelt einer Geschichte des Barons von
      Münchhausen.  Dort war eine Person in einen Sumpf gefallen
      und hat sich selbst an den Riemen seiner Stiefel (engl.
      <foreignphrase>bootstrap</foreignphrase>) herausgezogen.  In den
      jungen Jahren des Computerzeitalters wurde mit dem Begriff
      Bootstrap dann die Technik das Betriebssystem zu laden
      bezeichnet.  Seither wurde es mit <quote>booten</quote>
      abgekürzt.</para>

    <indexterm><primary><acronym>BIOS</acronym></primary></indexterm>

    <indexterm>
      <primary>Basic Input/Output System</primary>
      <see><acronym>BIOS</acronym></see>
    </indexterm>

    <para>Auf x86-Plattformen ist das Basic Input/Output System
      (<acronym>BIOS</acronym>) dafür verantwortlich, das
      Betriebssystem zu laden.  Das <acronym>BIOS</acronym> liest
      den Master Boot Record (<acronym>MBR</acronym>) aus, der sich an
      einer bestimmten Stelle auf der Festplatte befinden muss.  Das
      <acronym>BIOS</acronym> kann den <acronym>MBR</acronym>
      selbstständig laden und ausführen und geht davon aus, dass
      dieser die restlichen Dinge, die für das Laden des
      Betriebssystems notwendig sind, selbst oder mit Hilfe des
      <acronym>BIOS</acronym> erledigen kann.</para>

    <note>
      <para>&os; ermöglicht das Booten sowohl über den alten
	<acronym>MBR</acronym>-Standard, als auch über die neuere
	GUID-Partitionstabelle (<acronym>GPT</acronym>).
	<acronym>GPT</acronym>-Partitionen finden sich häufig auf
	Systemen mit dem <emphasis>Unified Extensible Firmware
	  Interface</emphasis> (<acronym>UEFI</acronym>).
	&os; kann allerdings mit Hilfe von &man.gptboot.8; auch
	<acronym>GPT</acronym>-Partitionen über das alte
	<acronym>BIOS</acronym> booten.  An der Unterstützung für
	ein direktes Booten über <acronym>UEFI</acronym> wird derzeit
	gearbeitet.</para>
    </note>

    <indexterm>
      <primary>Master Boot Record (<acronym>MBR</acronym>)</primary>
    </indexterm>

    <indexterm><primary>Boot Manager</primary></indexterm>

    <indexterm><primary>Boot Loader</primary></indexterm>

    <para>Der Code innerhalb des <acronym>MBR</acronym>s wird für
      gewöhnlich als <emphasis>Boot-Manager</emphasis> bezeichnet,
      insbesondere, wenn eine Interaktion mit dem Anwender
      stattfindet.  Der Boot-Manager verwaltet zusätzlichen Code im
      ersten <emphasis>Track</emphasis> der Platte oder des
      Dateisystems.  Zu den bekanntesten Boot-Managern gehören
      <application>boot0</application>, der auch als
      <application>Boot Easy</application> bekannte
      Standard-Boot-Manager von &os;, sowie
      <application>Grub</application>, welches in vielen
      &linux;-Distributionen verwendet wird.</para>

    <para>Falls nur ein Betriebssystem installiert ist, sucht der
      <acronym>MBR</acronym> nach dem ersten bootbaren Slice
      (das dabei als <emphasis>active</emphasis> gekennzeichnet ist)
      auf dem Laufwerk und führt den dort vorhandenen Code aus, um das
      restliche Betriebssystem zu laden.  Wenn mehrere
      Betriebssysteme installiert sind, kann ein anderer Boot-Manager
      installiert werden, der eine Liste der verfügbaren
      Betriebssysteme anzeigt, so dass der Benutzer wählen kann,
      welches Betriebssystem er booten möchte.</para>

    <para>Das restliche &os;-Bootstrap-System ist in drei Phasen
      unterteilt.  Die erste Phase besitzt gerade genug Funktionalität
      um den Computer in einen bestimmten Status zu verhelfen und die
      zweite Phase zu starten.  Die zweite Phase führt ein wenig mehr
      Operationen durch und startet schließlich die dritte Phase, die
      das Laden des Betriebssystems abschließt.  Der ganze Prozess
      wird in drei Phasen durchgeführt, weil der
      <acronym>MBR</acronym> die Größe der Programme, die in Phase
      eins und zwei ausgeführt werden, limitiert.  Das Verketten der
      durchzuführenden Aufgaben ermöglicht es &os;, ein sehr flexibles
      Ladeprogramm zu besitzen.</para>

    <indexterm><primary>Kernel</primary></indexterm>
    <indexterm><primary>&man.init.8;</primary></indexterm>

    <para>Als nächstes wird der Kernel gestartet, der zunächst nach
      Geräten sucht und sie für den Gebrauch
      initialisiert.  Nach dem Booten des Kernels übergibt dieser
      die Kontrolle an den Benutzer Prozess &man.init.8;, der erst
      sicherstellt, dass alle Laufwerke benutzbar sind und die
      Ressourcen Konfiguration auf Benutzer Ebene startet.  Diese
      wiederum mountet Dateisysteme, macht die Netzwerkkarten für
      die Kommunikation mit dem Netzwerk bereit und startet
      alle Prozesse, die konfiguriert wurden, um beim Hochfahren
      gestartet zu werden.</para>

    <para>Dieser Abschnitt beschreibt die einzelnen Phasen und wie
      sie mit dem &os;-Bootvorgang interagieren.</para>

    <sect2 xml:id="boot-boot0">
      <title>Der Boot-Manager</title>

      <indexterm><primary>Boot Manager</primary></indexterm>

      <indexterm>
	<primary>Master Boot Record (<acronym>MBR</acronym>)</primary>
      </indexterm>

      <para>Der Boot-Manager Code im <acronym>MBR</acronym>
	wird manchmal auch als <emphasis>stage zero</emphasis> des
	Boot-Prozesses bezeichnet.  In der Voreinstellung verwendet
	&os; den <application>boot0</application> Boot-Manager.</para>

      <para>Der vom &os;-Installationsprogramm in der Voreinstelung
	installierte <acronym>MBR</acronym> basiert auf
	<filename>/boot/boot0</filename>.  Die Größe und
	Leistungsfähigkeit von <application>boot0</application> ist
	auf 446&nbsp;Bytes beschränkt, weil der restliche Platz für
	die Partitionstabelle sowie den
	<literal>0x55AA</literal>-Identifier am Ende des
	<acronym>MBR</acronym>s benötigt wird.  Wenn
	<application>boot0</application> und mehrere Betriebssysteme
	installiert sind, wird beim Starten des Computers eine
	Anzeige ähnlich der folgenden zu sehen sein:</para>

      <example xml:id="boot-boot0-example">
	<title><filename>boot0</filename>-Screenshot</title>

	<screen>F1 Win
F2 FreeBSD

Default: F2</screen>
      </example>

      <para>Diverse Betriebssysteme
	überschreiben den existierenden <acronym>MBR</acronym>, wenn
	sie nach &os; installiert werden.  Falls dies passiert, kann
	mit folgendem Kommando der momentane <acronym>MBR</acronym>
	durch den &os;-<acronym>MBR</acronym> ersetzt werden:</para>

      <screen>&prompt.root; <userinput>fdisk -B -b /boot/boot0 <replaceable>Gerät</replaceable></userinput></screen>

      <para>Bei <replaceable>Gerät</replaceable> handelt es sich um
	das Gerät, von dem gebootet wird, also beispielsweise
	<filename>ad0</filename> für die erste
	<acronym>IDE</acronym>-Festplatte, <filename>ad2</filename>
	für die erste <acronym>IDE</acronym>-Festplatte am zweiten
	<acronym>IDE</acronym>-Controller, <filename>da0</filename>
	für die erste <acronym>SCSI</acronym>-Festplatte.  Um eine
	angepasste Konfiguration des <acronym>MBR</acronym> zu
	erstellen, lesen Sie &man.boot0cfg.8;.</para>
    </sect2>

    <sect2 xml:id="boot-boot1">
      <title>Phase Eins und Phase Zwei</title>

      <para>Im Prinzip sind die erste und die zweite Phase Teile
	desselben Programms, im selben Bereich auf der Festplatte.
	Aufgrund von Speicherplatz-Beschränkungen wurden sie in zwei
	Teile aufgeteilt, welche jedoch immer zusammen installiert
	werden.  Beide werden entweder vom &os;-Installationsprogramm
	oder <command>bsdlabel</command> aus der kombinierten
	<filename>/boot/boot</filename> kopiert.</para>

      <para>Beide Phasen befinden sich außerhalb des Dateisystems
	im Bootsektor des Boot-Slices, wo
	<application>boot0</application> oder ein anderer Boot-Manager
	ein Programm erwarten, das den weiteren Bootvorgang
	durchführen kann.</para>

      <para>Die erste Phase, <filename>boot1</filename>, ist ein sehr
	einfaches Programm, da es nur 512&nbsp;Bytes groß sein darf.
	Es besitzt gerade genug Funktionalität, um &os;s
	<firstterm>bsdlabel</firstterm>, das Informationen über den
	Slice enthält, auszulesen, und um <filename>boot2</filename>
	zu finden und auszuführen.</para>

      <para>Die zweite Phase, <filename>boot2</filename>, ist schon
	ein wenig umfangreicher und besitzt genügend Funktionalität,
	um Dateien in &os;s Dateisystem zu finden.  Es kann eine
	einfache Schnittstelle bereitstellen, die es ermöglicht, den
	zu ladenden Kernel oder Loader auszuwählen.  Es lädt den
	<application>loader</application>, der einen weitaus größeren
	Funktionsumfang bietet und eine Konfigurationsdatei zur
	Verfügung stellt.  Wenn der Boot-Prozess während der zweiten
	Phase unterbrochen wird, erscheint der folgende
	Bildschrim:</para>

      <example xml:id="boot-boot2-example">
	<title><filename>boot2</filename>-Screenshot</title>

	<screen>&gt;&gt; FreeBSD/i386 BOOT
Default: 0:ad(0,a)/boot/loader
boot:</screen>
      </example>

      <para>Um das installierte <filename>boot1</filename> und
	<filename>boot2</filename> zu ersetzen, benutzen Sie
	<command>bsdlabel</command>, wobei
	<replaceable>diskslice</replaceable> das Laufwerk und die
	Slice darstellt, von dem gebootet wird, beispielsweise
	<filename>ad0s1</filename> für die erste Slice auf der ersten
	<acronym>IDE</acronym>-Festplatte:</para>

      <screen>&prompt.root; <userinput>bsdlabel -B <replaceable>diskslice</replaceable></userinput></screen>

      <warning>

	<para>Wenn man nur den Festplatten-Namen benutzt,
	  beispielsweise <filename>ad0</filename>, wird
	  <command>bsdlabel</command> eine
	  <quote>dangerously dedicated disk</quote> erstellen, ohne
	  Slices.
	  Das ist ein Zustand, den man meistens nicht
	  hervorrufen möchte.  Aus diesem Grund sollte man das
	  <replaceable>diskslice</replaceable>
	  noch einmal prüfen, bevor <keycap>Return</keycap> gedrückt
	  wird.</para>
      </warning>
    </sect2>

    <sect2 xml:id="boot-loader">
      <title>Phase Drei</title>

      <indexterm><primary>boot-loader</primary></indexterm>

      <para>Der <application>loader</application> ist der letzte von
	drei Schritten im Bootstrap-Prozess.  Er kann im Dateisystem
	normalerweise als <filename>/boot/loader</filename> gefunden
	werden.</para>

      <para>Der <application>loader</application> soll eine
	interaktive Konfigurations-Schnittstelle mit eingebauten
	Befehlssatz sein, ergänzt durch einen umfangreichen
	Interpreter mit einem komplexeren Befehlssatz.</para>

      <para>Der <application>loader</application> sucht während seiner
	Initialisierung nach Konsolen und Laufwerken, findet heraus,
	von welchem Laufwerk er gerade bootet, und setzt
	dementsprechend bestimmte Variablen.  Dann wird ein
	Interpreter gestartet, der Befehle interaktiv oder von einem
	Skript empfangen kann.</para>

      <indexterm><primary>loader</primary></indexterm>
      <indexterm><primary>loader Konfiguration</primary></indexterm>

      <para>Danach liest der <application>loader</application>
	<filename>/boot/loader.rc</filename>, welche ihn standardmäßig
	anweist <filename>/boot/defaults/loader.conf</filename> zu
	lesen, wo sinnvolle Standardeinstellungen für diverse
	Variablen festgelegt werden und wiederum
	<filename>/boot/loader.conf</filename> für lokale Änderungen
	an diesen Variablen ausgelesen wird.  Anschließend arbeitet
	dann <filename>loader.rc</filename> entsprechend dieser
	Variablen und lädt die ausgewählten Module und den gewünschten
	Kernel.</para>

      <para>In der Voreinstellung wartet der
	<application>loader</application> 10&nbsp;Sekunden lang auf
	eine Tastatureingabe und bootet den Kernel, falls keine
	Taste betätigt wurde.  Falls doch eine Taste betätigt wurde
	wird dem Benutzer eine Eingabeaufforderung angezeigt.  Sie
	nimmt einen Befehlssatz entgegen, der es dem Benutzer
	erlaubt, Änderungen an Variablen vorzunehmen, Module zu
	laden, alle Module zu entladen oder schließlich zu booten
	oder neu zu booten.</para>

      <table xml:id="boot-loader-commands" frame="none" pgwide="1">
	<title>Die eingebauten Befehle des Loaders</title>

	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Variable</entry>
	      <entry>Beschreibung</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry>autoboot
		<replaceable>Sekunden</replaceable></entry>
	      <entry>Es wird mit dem Booten des Kernels fortgefahren,
		falls keine Taste in der gegebenen Zeitspanne betätigt
		wurde.  In der gegebenen Zeitspanne, Vorgabe sind
		10&nbsp;Sekunden, wird ein Countdown
		angezeigt.</entry>
	    </row>

	    <row>
	      <entry>boot
		<optional><replaceable>-Optionen</replaceable></optional>
		<optional><replaceable>Kernelname</replaceable></optional></entry>
	      <entry>Bewirkt das sofortige Booten des Kernels mit
		allen gegebenen Optionen, oder dem angegebenen
		Kernelnamen.  Das übergeben eines Kernelnamens ist nur
		nach einem <command>unload</command> anwendbar,
		andernfalls wird der zuvor verwendete Kernel
		benutzt.  Wenn nicht der vollständige Pfad für
		<emphasis>Kernelname</emphasis> angegeben wird, dann
		sucht der Loader den Kernel unter
		<filename>/boot/kernel</filename> und
		<filename>/boot/modules</filename>.</entry>
	    </row>

	    <row>
	      <entry>boot-conf</entry>
	      <entry>Bewirkt die automatische Konfiguration der
		Module, abhängig von den entsprechenden Variablen
		(üblicherweise <envar>kernel</envar>).  Dies nur dann
		sinnvoll, wenn zuvor <command>unload</command> benutzt
		wurde.</entry>
	    </row>

	    <row>
	      <entry>help
		<optional><replaceable>Thema</replaceable></optional></entry>
	      <entry>Zeigt die Hilfe an, die zuvor aus der Datei
		<filename>/boot/loader.help</filename> gelesen wird.
		Falls <literal>index</literal> als Thema angegeben
		wird, wird die Liste der zur Verfügung stehenden
		Hilfe-Themen angezeigt.</entry>
	    </row>

	    <row>
	      <entry>include <replaceable>Dateiname</replaceable>
		&hellip;</entry>
	      <entry>Das Einlesen und Interpretieren der angegebenen
		Datei geschieht Zeile für Zeile und wird im Falle
		eines Fehlers umgehend unterbrochen.</entry>
	    </row>

	    <row>
	      <entry>load <optional>-t
		  <replaceable>Typ</replaceable></optional>
		<replaceable>Dateiname</replaceable></entry>
	      <entry>Lädt den Kernel, das Kernel-Modul, oder die Datei
		des angegebenen Typs.  Argumente, die auf
		<replaceable>Dateiname</replaceable> folgen, werden
		der Datei übergeben.  Wenn nicht der vollständige
		Pfad für <emphasis>Dateiname</emphasis> angegeben
		wird, dann sucht der Loader die Datei unter
		<filename>/boot/kernel</filename> und
		<filename>/boot/modules</filename>.</entry>
	    </row>

	    <row>
	      <entry>ls <optional>-l</optional>
		<optional><replaceable>Pfad</replaceable></optional></entry>
	      <entry>Listet die Dateien im angegebenen Pfad auf, oder
		das Root-Verzeichnis, falls kein Pfad angegeben wurde.
		Die Option <option>-l</option> bewirkt, dass die
		Dateigrößen ebenfalls angezeigt werden.</entry>
	    </row>

	    <row>
	      <entry>lsdev <optional>-v</optional></entry>
	      <entry>Listet alle Geräte auf, für die Module geladen
		werden können.  Die Option <option>-v</option> bewirkt
		eine ausführliche Ausgabe.</entry>
	    </row>

	    <row>
	      <entry>lsmod <optional>-v</optional></entry>
	      <entry>Listet alle geladenen Module auf.  Die Option
		<option>-v</option> bewirkt eine ausführliche
		Ausgabe.</entry>
	    </row>

	    <row>
	      <entry>more <replaceable>Dateiname</replaceable></entry>
	      <entry>Zeigt den Dateinhalt der angegebenen Datei an,
		wobei eine Pause alle <varname>LINES</varname> Zeilen
		gemacht wird.</entry>
	    </row>

	    <row>
	      <entry>reboot</entry>
	      <entry>Bewirkt einen umgehenden Neustart des
		Systems.</entry>
	    </row>

	    <row>
	      <entry>set <replaceable>Variable</replaceable>, set
		<replaceable>Variable</replaceable>=<replaceable>Wert</replaceable></entry>
	      <entry>Setzt die angegebenen Umgebungsvariablen.</entry>
	    </row>

	    <row>
	      <entry>unload</entry>
	      <entry>Entlädt sämtliche geladenen Module.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <para>Hier ein paar praktische Beispiele für die Bedienung
	des Loaders.  Um den gewöhnlichen Kernel im Single-User Modus
	<indexterm><primary>Single-User Modus</primary></indexterm> zu
	starten:</para>

	  <screen><userinput>boot -s</userinput></screen>

	  <para>Um alle gewöhnlichen Kernelmodule zu entladen und dann
	    den alten, oder einen anderen Kernel zu
	    laden:</para>

	  <screen><userinput>unload</userinput>
<userinput>load <replaceable>kernel.old</replaceable></userinput></screen>

	  <para>Verwenden Sie <filename>kernel.GENERIC</filename>,
	    um den allgemeinen Kernel zu bezeichnen, der
	    vorinstalliert wird.  <filename>kernel.old</filename>
	    bezeichnet den Kernel, der vor dem System-Upgrade
	    installiert war.</para>

	  <para>Der folgende Befehl lädt die gewöhnlichen Module mit
	    einem anderen Kernel:</para>

	  <screen><userinput>unload</userinput>
<userinput>set kernel="<replaceable>kernel.old</replaceable>"</userinput>
<userinput>boot-conf</userinput></screen>

	  <para>Um ein automatisiertes Kernelkonfigurations-Skript zu
	    laden, geben Sie ein:</para>

	  <screen><userinput>load -t userconfig_script <replaceable>/boot/kernel.conf</replaceable></userinput></screen>

      <indexterm>
	<primary>Kernel</primary>
	<secondary>Interaktion während des Bootens</secondary>
      </indexterm>
    </sect2>

    <sect2 xml:id="boot-init">
      <title>Die letzte Phase</title>

      <indexterm><primary>&man.init.8;</primary></indexterm>

      <para>Sobald der Kernel einmal geladen ist, entweder durch den
	<application>loader</application> oder durch
	<application>boot2</application>, welches den Loader umgeht,
	dann überprüft er vorhandene Boot-Flags und passt sein
	Verhalten nach Bedarf an.  In <xref linkend="boot-kernel"/>
	sind die gebräuchlichsten Boot-Flags aufgelistet.
	Informationen zu den anderen Boot-Flags finden Sie in
	&man.boot.8;.</para>

      <indexterm>
	<primary>Kernel</primary>
	<secondary>Boot-Flags</secondary>
      </indexterm>

      <table xml:id="boot-kernel" frame="none" pgwide="1">
	<title>Interaktion mit dem Kernel während des Bootens</title>

	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Option</entry>
	      <entry>Beschreibung</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><option>-a</option></entry>
	      <entry>Bewirkt, dass während der Kernel-Initialisierung
		gefragt wird, welches Gerät als Root-Dateisystem
		eingehängt werden soll.</entry>
	    </row>

	    <row>
	      <entry><option>-C</option></entry>
	      <entry>Das Root-Dateisystem wird von
		<acronym>CD-ROM</acronym> gebootet.</entry>
	    </row>

	    <row>
	      <entry><option>-s</option></entry>
	      <entry>Bootet in den Single-User Modus</entry>
	    </row>

	    <row>
	      <entry><option>-v</option></entry>
	      <entry>Zeigt mehr Informationen während des Starten des
		Kernels an.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <para>Nachdem der Kernel den Bootprozess abgeschlossen hat,
	übergibt er die Kontrolle an den Benutzer-Prozess
	&man.init.8;.  Dieses Programm befindet sich in
	<filename>/sbin/init</filename>, oder dem Pfad, der durch die
	Variable <envar>init_path</envar> im <command>loader</command>
	spezifiziert wird.</para>

      <para>Der automatische Reboot-Vorgang stellt sicher, dass alle
	Dateisysteme des Systems konsistent sind.  Falls dies nicht
	der Fall ist und die Inkonsistenz des
	<acronym>UFS</acronym>-Dateisystems nicht durch
	<command>fsck</command> behebbar ist, schaltet
	<command>init</command> das System in den Single-User-Modus,
	damit der Systemadministrator sich des Problems annehmen kann.
	Andernfalls startet das System in den
	Mehrbenutzermodus.</para>

      <sect3 xml:id="boot-singleuser">
	<title>Der Single-User Modus</title>

	<indexterm><primary>Single-User Modus</primary></indexterm>
	<indexterm><primary>Konsole</primary></indexterm>

	<para>Der Wechsel in den Single-User Modus kann beim Booten
	  durch die Option <option>-s</option>, oder das Setzen der
	  Variable <envar>boot_single</envar> in
	  <application>loader</application> erreicht werden.  Zudem
	  kann er auch im Mehrbenutzermodus über den Befehl
	  <command>shutdown now</command> erreicht werden.  Der
	  Single-User Modus beginnt mit dieser Meldung:</para>

	<programlisting>Enter full path of shell or RETURN for /bin/sh:</programlisting>

	<para>Wenn Sie die Eingabetaste drücken, wird das
	  System die Bourne Shell starten.  Falls Sie eine andere
	  Shell starten möchten, geben Sie den vollständigen Pfad
	  zur Shell ein.</para>

	<para>Der Single-User Modus wird normalerweise zur Reparatur
	  verwendet, beispielsweise wenn das System aufgrund eines
	  inkonsistenten Dateisystems oder einem Fehler in einer
	  Konfigurationsdatei nicht bootet.  Der Modus wird auch
	  verwendet, um das Passwort von <systemitem
	    class="username">root</systemitem> zurückzusetzen, falls
	  dieses nicht mehr bekannt ist.  Dies alles ist möglich, da
	  der Single-User Modus vollen Zugriff auf das lokale System
	  und die Konfigurationsdateien gewährt.  Einen Zugang zum
	  Netzwerk bietet dieser Modus allerdings nicht.</para>

	<para>Obwohl der Single-User Modus für Reparaturen am System
	  sehr nützlich ist, stellt es ein Sicherheitsrisiko dar, wenn
	  sich das System an einem physisch unsicheren Standort
	  befindet.  In der Voreinstellung hat jeder Benutzer, der
	  physischen Zugriff auf ein System erlangen kann, volle
	  Kontrolle über das System, nachdem in den Single-User Modus
	  gebootet wurde.</para>

	<para>Falls die System-Konsole (<literal>console</literal>) in
	  <filename>/etc/ttys</filename> auf
	  <literal>insecure</literal> (dt.: unsicher) gesetzt ist,
	  fordert das System zur Eingabe des <systemitem
	    class="username">root</systemitem> Passworts auf, bevor es
	  den Single-User Modus aktiviert.  Dadurch gewinnen Sie zwar
	  ein gewisses Maß an Sicherheit, aber Sie können dann nicht
	  mehr das Passwort von <systemitem
	    class="username">root</systemitem> zurücksetzen, falls es
	  nicht bekannt ist.</para>

	<example xml:id="boot-insecure-console">
	  <title>Auf insecure gesetzte Konsole in
	    <filename>/etc/ttys</filename></title>

	  <programlisting># name  getty                           type    status          comments
#
# If console is marked "insecure", then init will ask for the root password
# when going to single-user mode.
console none                            unknown off insecure</programlisting>
	</example>

	<para>Eine Konsole sollte auf <literal>insecure</literal>
	  gesetzt sein, wenn die physikalische Sicherheit der Konsole
	  nicht gegeben ist und sichergestellt werden soll, dass nur
	  Personen, die das Passwort von <systemitem
	    class="username">root</systemitem> kennen, den
	  Single-User Modus benutzen können.</para>
      </sect3>

      <sect3 xml:id="boot-multiuser">
	<title>Mehrbenutzermodus</title>

	<indexterm><primary>Mehrbenutzermodus</primary></indexterm>

	<para>Stellt <application>init</application> fest, dass das
	  Dateisystem in Ordnung ist, oder der Benutzer den
	  Single-User-Modus mit <command>exit</command> beendet,
	  schaltet das System in den Mehrbenutzermodus, in dem dann
	  die Ressourcen Konfiguration des Systems gestartet
	  wird.</para>

	<indexterm><primary>rc-Dateien</primary></indexterm>

	<para>Das Ressourcen Konfigurationssystem (engl.
	  <foreignphrase>resource configuration</foreignphrase>, rc)
	  liest seine Standardkonfiguration von
	  <filename>/etc/defaults/rc.conf</filename> und
	  System-spezifische Details von
	  <filename>/etc/rc.conf</filename>.  Dann mountet es die
	  Dateisysteme gemäß <filename>/etc/fstab</filename>, startet
	  die Netzwerkdienste, diverse System Daemons und führt
	  schließlich die Start-Skripten der lokal installierten
	  Anwendungen aus.</para>

	<para>Lesen Sie &man.rc.8; und ebenso die Skripte in
	  <filename>/etc/rc.d</filename>, um mehr über das Ressourcen
	  Konfigurationssystem zu erfahren.</para>
      </sect3>
    </sect2>
  </sect1>

    <!--
    <sect2 xml:id="boot-kernel-userconfig">
      <title>UserConfig: das Boot-Zeit Konfigurationsprogramm</title>

      <para></para>
    </sect2> -->

  <sect1 xml:id="boot-splash">
    <info>
      <title>Willkommensbildschirme während des Bootvorgangs
	konfigurieren</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Joseph J.</firstname>
	    <surname>Barbish</surname>
	  </personname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Benedict</firstname>
	    <surname>Reuschling</surname>
	  </personname>
	  <contrib>Übersetzt von </contrib>
	</author>
      </authorgroup>
    </info>

    <para>Wenn ein &os;-System startet, gibt es normalerweise eine
      Reihe von Meldungen auf der Konsole aus.  Ein
      Willkommensbildschirm erzeugt einen alternativen
      Boot-Bildschirm, der alle Bootmeldungen und Meldungen über
      startende Dienste versteckt.  Ein paar Meldungen des
      Bootloaders, einschließlich das Menü mit den Bootoptionen und
      dem Warte-Countdown werden dennoch zur Bootzeit angezeigt,
      auch wenn der Willkommensbildschirm aktiviert ist.  Der
      Willkommensbildschirm kann während des Bootvorgangs mit einem
      beliebigen Tastendruck ausgeschaltet werden.</para>

    <para>Es existieren zwei grundlegende Umgebungen in &os;.  Die
      erste ist die altbekannte, auf virtuellen Konsolen basierte
      Kommandozeile.  Nachdem das System den Bootvorgang abgeschlossen
      hat, wird ein Anmeldebildschirm auf der Konsole anzeigt.  Die
      zweite Umgebung ist eine konfigurierte, graphische Umgebung.
      <xref   linkend="x11"/> enthält weitere Informationen zur
      Installation und Konfiguration eines graphischen
      Display-Managers und Login-Managers.</para>

    <para>Der Willkommensbildschirm ist standardmäßig so eingestellt,
      dass er als Bildschirmschoner verwendet wird.  Nach einer
      bestimmten Zeit der Untätigkeit wird der Willkommensbildschirm
      angezeigt und wechselt durch verschiedene Stufen der Intensität
      von hell zu einem sehr dunklen Bild und wieder zurück.  Das
      Verhalten des Willkommensbildschirms kann durch hinzufügen einer
      <literal>saver=</literal>-Zeile in
      <filename>/etc/rc.conf</filename> geändert werden.  Es gibt
      mehrere eingebaute Bildschirmschoner, die in &man.splash.4;
      beschrieben werden.  Die <literal>saver=</literal>-Option
      bezieht sich nur auf virtuelle Konsolen und hat keinen
      Effekt bei grafischen Display-Managern.</para>

    <para>Dateien mit Beispiel-Willkommensbildschirmen können von
      der Galerie auf <link
	xlink:href="http://artwork.freebsdgr.org/node/3/">
	http://artwork.freebsdgr.org</link> heruntergeladen werden.
      Durch die Installation des Ports oder Pakets
      <package>sysutils/bsd-splash-changer</package> können
      Willkommensbildschirme von einer zufällig ausgewählten
      Sammlung von Bildern bei jedem Neustart angezeigt werden.</para>

    <para>Die Willkommensbildschirm-Funktionalität unterstützt
      256-Farben in den Formaten Bitmap
      (<filename>.bmp</filename>), ZSoft <acronym>PCX</acronym>
      (<filename>.pcx</filename>) oder TheDraw
      (<filename>.bin</filename>).  Die
      Willkommensbildschirm-Datei <filename>.bmp</filename>,
      <filename>.pcx</filename> oder <filename>.bin</filename>
      muss in der Root-Partition, beispielsweise unterhalb von
      <filename>/boot</filename> abgelegt werden.
      Willkommensbildschirm-Dateien dürfen eine Auflösung von 320
      mal 200 Pixeln oder weniger besitzen, damit
      Standard-<acronym>VGA</acronym> Geräte damit arbeiten
      können.  Für eine Standard-Auflösung von 256-Farben, 320 mal
      200 Pixel oder weniger, fügen Sie folgende Zeilen in
      <filename>/boot/loader.conf</filename> ein und ersetzen Sie
      <replaceable>splash.bmp</replaceable> mit dem Namen der
      Bitmap-Datei:</para>

    <programlisting>splash_bmp_load="YES"
bitmap_load="YES"
bitmap_name="/boot/<replaceable>splash.bmp</replaceable>"</programlisting>

    <para>Wenn Sie anstelle der Bitmap-Datei eine
      <acronym>PCX</acronym>-Datei verwenden:</para>

    <programlisting>splash_pcx_load="YES"
bitmap_load="YES"
bitmap_name="/boot/<replaceable>splash.pcx</replaceable>"</programlisting>

    <para>Für ASCII-Art im <uri
	xlink:href="https://en.wikipedia.org/wiki/TheDraw">
	TheDraw</uri>-Format schreiben Sie:</para>

    <programlisting>splash_txt="YES"
bitmap_load="YES"
bitmap_name="/boot/<replaceable>splash.bin</replaceable>"</programlisting>

    <para>Damit größere Bilder bis zu einer maximalen Auflösung von
      1024 mal 768 Pixeln verwendet werden können, muss das
      <acronym>VESA</acronym> Modul beim Systemstart geladen werden.
      Für einen angepassten Kernel, wie in <xref
	linkend="kernelconfig"/> beschrieben, muss die
      <literal>VESA</literal>-Kernelkonfigurationsoption eingefügt
      werden.  Um das <acronym>VESA</acronym>-Modul für den
      Willkommensbildschirm zu laden, fügen Sie zusätzlich zu den
      Zeilen aus den vorherigen Beispielen, folgende Zeile in
      <filename>/boot/loader.conf</filename> ein:</para>

    <programlisting>vesa_load="YES"</programlisting>

    <para>Weitere interessante Optionen für
      <filename>loader.conf</filename> sind:</para>

    <variablelist>
      <varlistentry>
	<term><literal>beastie_disable="YES"</literal></term>

	<listitem>
	  <para>Diese Option verhindert die Anzeige des Menüs mit den
	    Bootoptionen, aber der Countdown ist immer noch aktiv.
	    Selbst wenn das Bootmenü deaktiviert ist, kann während des
	    Countdowns eine der korrespondierenden Optionen ausgewählt
	    werden.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>loader_logo="beastie"</literal></term>

	<listitem>
	  <para>Dies ersetzt die Standardanzeige des Wortes
	    <quote>&os;</quote>.  Stattdessen wird auf der rechten
	    Seite des Bootmenüs das bunte Beastie-Logo
	    angezeigt.</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <para>Weitere Informationen finden Sie in &man.splash.4;,
      &man.loader.conf.5; und &man.vga.4;.</para>
  </sect1>

  <sect1 xml:id="device-hints">
    <info>
      <title>Konfiguration von Geräten</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	  </personname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>device.hints</primary>
    </indexterm>

    <para>Der Boot-Loader liest während des Systemstarts die Datei
      &man.device.hints.5;, die Variablen, auch
      <quote>device hints</quote> genannt, zur Konfiguration von
      Geräten enthält.</para>

    <para>Die Variablen können auch mit Kommandos in Phase 3 des
      Boot-Loaders, wie in <xref linkend="boot-loader"/> beschrieben,
      bearbeitet werden.  Neue Variablen werden mit
      <command>set</command> gesetzt, <command>unset</command> löscht
      schon definierte Variablen und <command>show</command> zeigt
      Variablen an.  Variablen aus
      <filename>/boot/device.hints</filename> können zu diesem
      Zeitpunkt überschrieben werden.  Die hier durchgeführten
      Änderungen sind nicht permanent und beim nächsten Systemstart
      nicht mehr gültig.</para>

    <para>Nach dem Systemstart können alle Variablen mit &man.kenv.1;
      angezeigt werden.</para>

    <para>Pro Zeile enthält <filename>/boot/device.hints</filename>
      eine Variable.  Kommentare werden durch <literal>#</literal>
      eingeleitet.  Die verwendete Syntax lautet:</para>

    <screen><userinput>hint.driver.unit.keyword="<replaceable>value</replaceable>"</userinput></screen>

    <para>Der Boot-Loader verwendet die nachstehende Syntax:</para>

    <screen><userinput>set hint.driver.unit.keyword=<replaceable>value</replaceable></userinput></screen>

    <para>Der Gerätetreiber wird mit <literal>driver</literal>,
      die Nummer des Geräts mit <literal>unit</literal>
      angegeben.  <literal>keyword</literal> ist eine Option aus
      der folgenden Liste:</para>

    <itemizedlist>
      <listitem>
	<para><option>at</option>: Gibt den Bus, auf dem sich das
	  Gerät befindet, an.</para>
      </listitem>

      <listitem>
	<para><option>port</option>: Die Startadresse des
	  <acronym>I/O</acronym>-Bereichs.</para>
      </listitem>

      <listitem>
	<para><option>irq</option>: Gibt die zu verwendende
	  Unterbrechungsanforderung (IRQ) an.</para>
      </listitem>

      <listitem>
	<para><option>drq</option>: Die Nummer des DMA Kanals.</para>
      </listitem>

      <listitem>
	<para><option>maddr</option>: Die physikalische
	  Speicheradresse des Geräts.</para>
      </listitem>

      <listitem>
	<para><option>flags</option>: Setzt verschiedene
	  gerätespezifische Optionen.</para>
      </listitem>

      <listitem>
	<para><option>disabled</option>: Deaktiviert das Gerät, wenn
	  der Wert auf <literal>1</literal> gesetzt wird.</para>
      </listitem>
    </itemizedlist>

    <para>Ein Gerätetreiber kann mehr Optionen, als die hier
      beschriebenen, besitzen oder benötigen.  Es wird empfohlen, die
      Optionen in der Manualpage des Treibers nachzuschlagen.  Weitere
      Informationen finden Sie in &man.device.hints.5;, &man.kenv.1;,
      &man.loader.conf.5; und &man.loader.8;.</para>
  </sect1>

  <sect1 xml:id="boot-shutdown">
    <title>Der Shutdown-Vorgang</title>

    <indexterm>
      <primary>&man.shutdown.8;</primary>
    </indexterm>

    <para>Im Falle eines regulären Herunterfahrens durch
      &man.shutdown.8; führt &man.init.8;
      <filename>/etc/rc.shutdown</filename> aus, sendet dann
      sämtlichen Prozessen ein <literal>TERM</literal> Signal und
      schließlich ein <literal>KILL</literal> Signal an alle Prozesse,
      die sich nicht rechtzeitig beendet haben.</para>

    <para>&os;-Systeme, die Energieverwaltungsfunktionen
      unterstützen, können mit <command>shutdown -p now</command>
      ausgeschaltet werden.  Zum Neustart des Systems wird
      <command>shutdown -r now</command> benutzt.  Das Kommando
      &man.shutdown.8; kann nur von
      <systemitem class="username">root</systemitem> oder Mitgliedern
      der Gruppe <systemitem class="groupname">operator</systemitem>
      benutzt werden.  Man kann auch &man.halt.8; und &man.reboot.8;
      verwenden.  Weitere Informationen finden Sie in den
      Hilfeseiten der drei Kommandos.</para>

    <para>Das Ändern der Gruppenmitgliedschaft wird in <xref
	linkend="users-synopsis"/> beschrieben.</para>

    <note>
      <para>Die Energieverwaltungsfunktionen erfordern, dass die
	Unterstützung für &man.acpi.4; als Modul geladen, oder
	statisch in einen angepassten Kernel kompiliert wird.</para>
    </note>
  </sect1>
</chapter>
