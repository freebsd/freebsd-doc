<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde: de-docproj/books/handbook/firewalls/chapter.xml,v 1.53 2012/04/30 16:15:52 bcr Exp $
     basiert auf: r49919
-->
<chapter xmlns="http://docbook.org/ns/docbook"
  xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0"
  xml:id="firewalls">
  <info>
    <title>Firewalls</title>

    <authorgroup>
      <author>
	<personname>
	  <firstname>Joseph J.</firstname>
	  <surname>Barbish</surname>
	</personname>
	<contrib>Beigetragen von </contrib>
      </author>
    </authorgroup>

    <authorgroup>
      <author>
	<personname>
	  <firstname>Brad</firstname>
	  <surname>Davis</surname>
	</personname>
	<contrib>Nach SGML konvertiert und aktualisiert von </contrib>
      </author>
    </authorgroup>

    <authorgroup>
      <author>
	<personname>
	  <firstname>Michael</firstname>
	  <surname>Bunzel</surname>
	</personname>
	<contrib>Übersetzt von </contrib>
      </author>
      <author>
	<personname>
	  <firstname>Johann</firstname>
	  <surname>Kois</surname>
	</personname>
      </author>
      <author>
	<personname>
	  <firstname>Benjamin</firstname>
	  <surname>Lukas</surname>
	</personname>
      </author>
      <author>
	<personname>
	  <firstname>Björn</firstname>
	  <surname>Heidotting</surname>
	</personname>
      </author>
    </authorgroup>
  </info>

  <indexterm><primary>firewall</primary></indexterm>

  <indexterm>
    <primary>security</primary>
    <secondary>firewalls</secondary>
  </indexterm>

  <sect1 xml:id="firewalls-intro">
    <title>Einführung</title>

    <para>Firewalls ermöglichen es, den ein- und ausgehenden
      Netzwerkverkehr eines Systems zu filtern.  Dazu verwendet eine
      Firewall eine oder mehrere Gruppen von <quote>Regeln</quote>,
      um ankommende Netzwerkpakete zu untersuchen und entweder
      durchzulassen oder zu blockieren.  Die Regeln einer
      Firewall untersuchen charakteristische Eigenschaften von
      Datenpaketen, darunter den Protokolltyp, die Quell- und
      Zieladresse sowie den Quell- und Zielport.</para>

    <para>Firewalls können die Sicherheit eines Rechners oder
      eines Netzwerks erhöhen, indem sie folgende Aufgaben
      übernehmen:</para>

    <itemizedlist>
      <listitem>
	<para>Den Schutz der Anwendungen, Dienste und Rechner eines
	  internen Netzwerks vor unerwünschtem Datenverkehr
	  aus dem Internet.</para>
      </listitem>

      <listitem>
	<para>Die Beschränkung des Zugriffs von Rechnern des internen
	  Netzwerks auf Rechner oder Dienste des öffentlichen
	  Internets.</para>
      </listitem>

      <listitem>
	<para>Den Einsatz von Network Address Translation
	  (<acronym>NAT</acronym>), welches es durch die Verwendung
	  von privaten <acronym>IP</acronym>-Adressen ermöglicht,
	  eine einzige gemeinsame Internetverbindung für mehrere
	  Rechner zu nutzen.  Dies geschieht entweder über eine
	  einzige <acronym>IP</acronym>-Adresse oder über eine Gruppe
	  von jeweils automatisch zugewiesenen öffentlichen
	  Adressen.</para>
      </listitem>
    </itemizedlist>

    <para>Das Basissystem von &os; enthält drei Firewalls:
      <application>PF</application>, <application>IPFW</application>
      und <application>IPFILTER</application> (auch als
      <application>IPF</application> bekannt).  &os; enthält ebenfalls
      zwei <foreignphrase>Traffic-Shaper</foreignphrase> zur Kontrolle
      der Bandbreite: &man.altq.4; und &man.dummynet.4;.
      <application>ALTQ</application> ist traditionell eng an
      <application>PF</application> gebunden, während
      <application>dummynet</application> zusammen mit
      <application>IPFW</application> verwendet wird.
      Gemeinsam ist allen Firewalls, dass sie Regeln einsetzen, um den
      Transfer von ein- und ausgehenden Datenpaketen des Systems
      zu steuern.  Unterschiedlich ist aber die Art und Weise, wie
      dies realisiert wird.  Auch die für diese Regeln verwendete
      Syntax ist unterschiedlich.</para>

    <para>&os; besitzt mehrere Firewalls, um den unterschiedlichen
      Anforderungen und Vorlieben von Benutzern gerecht zu werden.
      Jeder Benutzer sollte selbst beurteilen, welche Firewall seinen
      Bedürfnissen am besten entspricht.</para>

    <para>Nachdem Sie dieses Kapitel gelesen haben, werden Sie
      wissen:</para>

    <itemizedlist>
      <listitem>
	<para>Wie man Paketfilterregeln erstellt.</para>
      </listitem>

      <listitem>
	<para>Was die Unterschiede zwischen den in &os; eingebauten
	  Firewalls sind.</para>
      </listitem>

      <listitem>
	<para>Wie die <application>PF</application>-Firewall
	  konfiguriert und einsetzt wird.</para>
      </listitem>

      <listitem>
	<para>Wie die <application>IPFW</application>-Firewall
	  konfiguriert und einsetzt wird.</para>
      </listitem>

      <listitem>
	<para>Wie die <application>IPFILTER</application>-Firewall
	  konfiguriert und einsetzt wird.</para>
      </listitem>
    </itemizedlist>

    <para>Bevor Sie dieses Kapitel lesen, sollten Sie:</para>

    <itemizedlist>
      <listitem>
	<para>Die grundlegenden Konzepte von &os; und dem Internet
	  verstehen.</para>
      </listitem>
    </itemizedlist>

    <note>
      <para>Da alle Firewalls auf der Inspektion ausgewählter
	Kontrollfelder in Datenpaketen basieren, muss für die
	Erstellung von Firewallregeln ein grundlegendes Verständnis
	von <acronym>TCP/IP</acronym> vorhanden sein.  Eine gute
	Einführung finden Sie in <link
	  xlink:href="http://www.ipprimer.com/overview.cfm">
	  Daryl's TCP/IP Primer</link>.</para>
    </note>
  </sect1>

  <sect1 xml:id="firewalls-concepts">
    <title>Firewallkonzepte</title>

    <indexterm>
      <primary>firewall</primary>
      <secondary>Regelsatz</secondary>
    </indexterm>

    <para>Ein Regelsatz besteht aus einer Gruppe von Regeln, die
      Pakete basierend auf ihren Inhalt entweder blockieren oder
      durchlassen.  Der bidirektionale Austausch von Paketen zwischen
      zwei Rechnern wird als Sitzung
      (<foreignphrase>Session</foreignphrase>) bezeichnet.  Der
      Regelsatz verarbeitet sowohl ankommende Pakete aus dem
      Internet, als auch die vom System erzeugten Antwortpakete.
      Jeder <acronym>TCP/IP</acronym>-Dienst hat ein festgelegtes
      Protokoll und einen vorgegebenen Port.  Pakete für einen
      bestimmten Dienst stammen von einer Quelladresse und einem
      unprivilegierten Port und gehen an einen spezifischen Port
      auf der Zieladresse.  Alle oben genannten Parameter können als
      Selektionskriterien verwendet werden, um einen Regelsatz zu
      erstellen, der den Zugriff auf bestimmte Dienste gewährt oder
      blockiert.</para>

    <para>Unbekannte Portnummern können Sie in
      <filename>/etc/services</filename> nachschlagen.
      Alternativ finden Sie die Portnummern und deren Verwendungszweck
      auf <link
	xlink:href="http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers">
	http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers</link>.</para>

    <para>Die Seite <link
	xlink:href="http://www.sans.org/security-resources/idfaq/oddports.php">
	http://www.sans.org/security-resources/idfaq/oddports.php</link>
      enthält eine Liste der Portnummern, die auch von Trojanern
      benutzt werden.</para>

    <para><acronym>FTP</acronym> hat zwei Modi:  Aktiv und Passiv.
      Unterschied liegt in der Bestimmung des Datenkanals.  Der
      Passiv-Modus ist sicherer, da der Datenkanal vom Client
      bestimmt wird.  Eine ausführliche Erklärung von
      <acronym>FTP</acronym> und den verschiedenen Modi finden Sie
      unter <link
	xlink:href="http://www.slacksite.com/other/ftp.html">
	http://www.slacksite.com/other.ftp.html</link>.</para>

    <para>Ein Firewall-Regelsatz kann entweder
      <quote>einschließend</quote> (<foreignphrase>inclusive
	firewall</foreignphrase>) oder <quote>ausschließend</quote>
      (<foreignphrase>exclusive Firewall</foreignphrase>) sein.  Eine
      ausschließende Firewall lässt jeden Datenverkehr durch, der
      nicht durch eine Regel ausgeschlossen wurde.  Eine
      einschließende Firewall macht das genaue Gegenteil.  Sie lässt
      Datenverkehr nur dann passieren, wenn dieser einer der
      definierten Regeln entspricht.</para>

    <para>Eine einschließende Firewall bietet eine wesentlich bessere
      Kontrolle des ausgehenden Verkehrs, was sie zur besseren Wahl
      für Systeme macht, welche Dienste für das Internet anbieten.
      Sie kontrolliert auch den Verkehr aus dem öffentlichen Internet
      zum privaten Netzwerk.  Jeder Verkehr, der keiner Regel
      entspricht wird geblockt und protokolliert.  Einschließende
      Firewalls sind generell sicherer als ausschließende Firewalls,
      da sie das Risiko, dass unerwünschter Verkehr hindurch geht,
      drastisch reduzieren.</para>

    <note>
      <para>Wenn nicht anders vermerkt, verwenden alle Konfigurationen
	und Regelsätze in diesem Kapitel einschließende
	Firewalls.</para>
    </note>

    <para>Die Sicherheit kann durch den Einsatz einer
      <quote>zustandsorientierten Firewall</quote>
      (<foreignphrase>stateful firewall</foreignphrase>) weiter
      erhöht werden.  Dieser Typ Firewall überwacht alle offenen
      Verbindungen und erlaubt nur Datenverkehr von bereits
      bestehenden Verbindungen oder wenn eine neue Verbindung
      aufgebaut wird.</para>

    <para>Eine zustandsorientierte Firewall behandelt den Verkehr
      als einen bidirektionalen Austausch von Paketen während einer
      Session.  Wenn ein Zustand für eine passende Regel angegeben
      wird, erstellt die Firewall dynamisch interne Regeln für jedes
      Paket, das während dieser Session ausgetauscht wird.  Die
      Firewall hat ausreichend Möglichkeiten, um zu bestimmen, ob ein
      Paket zu einer Session gehört.  Alle Pakete, die nicht zu dieser
      Session passen, werden automatisch abgelehnt.</para>

    <para>Sobald die Session beendet ist, wird sie aus der
      dynamischen Zustandstabelle entfernt.</para>

    <para>Eine zustandsorientierte Filterung erlaubt es, sich auf die
      Sperrung bzw. Freigabe von neuen Sessions zu konzentrieren.
      Wenn eine neue Session genehmigt wird, werden alle nachfolgenden
      Pakete dieser Session automatisch erlaubt und betrügerische
      Pakete werden automatisch abgelehnt.  Wenn eine neue Session
      nicht genehmigt wird, werden alle nachfolgenden Pakete dieser
      Session abgelehnt.  Die zustandsorientierte Filterung bietet
      fortgeschrittene Fähigkeiten zur Abwehr von verschiedensten
      Angriffsmethoden, die von Angreifern eingesetzt werden.</para>

    <para><acronym>NAT</acronym> steht für <emphasis>Network Address
	Translation</emphasis>.  Die <acronym>NAT</acronym>-Funktion
      ermöglicht es einem privaten <acronym>LAN</acronym> hinter einer
      Firewall, sich eine einzelne vom <acronym>ISP</acronym>
      zugewiesene <acronym>IP</acronym>-Adresse zu teilen, auch wenn
      die Adresse dynamisch zugewiesen wird.  <acronym>NAT</acronym>
      ermöglicht den Internetzugriff für jeden Rechner im
      <acronym>LAN</acronym>, ohne dass der <acronym>ISP</acronym> für
      mehrere Internet-Konten bezahlt wird.</para>

    <para><acronym>NAT</acronym> übersetzt automatisch die private
      <acronym>IP</acronym>-Adresse auf die öffentliche
      <acronym>IP</acronym>-Adresse, sobald ein Paket für das
      öffentliche Internet die Firewall passiert.  Zusätzlich führt es
      auch die Übersetzung der Anwortpakete durch.</para>

    <para>Gemäß RFC 1918 sind die folgenden
      <acronym>IP</acronym>-Adressbereiche für private Netzwerke
      reserviert und werden nie ins öffentliche Internet
      weitergeleitet.  Daher sind diese Bereiche für den Einsatz
      mit <acronym>NAT</acronym> geeignet:</para>

    <itemizedlist>
      <listitem>
	<para><literal>10.0.0.0/8</literal></para>
      </listitem>

      <listitem>
	<para><literal>172.16.0.0/12</literal></para>
      </listitem>

      <listitem>
	<para><literal>192.168.0.0/16</literal></para>
      </listitem>
    </itemizedlist>

    <warning>
      <para>Seien Sie <emphasis>äußerst vorsichtig</emphasis> wenn Sie
	mit Firewallregeln arbeiten.  Durch eine falsche Konfiguration
	kann der Administrator den Zugriff auf den Server verlieren.
	Um auf der sicheren Seite zu sein, sollten Sie die anfängliche
	Konfiguration der Firewall von der lokalen Konsole
	durchführen, anstatt dass Sie dies aus der Ferne über
	<application>ssh</application> tun.</para>
    </warning>
  </sect1>

  <sect1 xml:id="firewalls-pf">
    <info>
      <title>PF</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>John</firstname>
	    <surname>Ferrell</surname>
	  </personname>
	  <contrib>Überarbeitet und aktualisiert von </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>firewall</primary>
      <secondary>PF</secondary>
    </indexterm>

    <para>In &os;&nbsp;5.3 wurde <application>PF</application> von
      OpenBSD in das Basissystem integriert.  Bei
      <application>PF</application> handelt es sich um eine komplette,
      voll ausgestattete Firewall, die optional auch
      <application>ALTQ</application> (Alternatives Queuing)
      unterstützt.  <application>ALTQ</application> stellt
      <foreignphrase>Quality of Service</foreignphrase>
      (<acronym>QoS</acronym>) zur Verfügung.</para>

    <para>Das OpenBSD-Projekt pflegt die maßgebliche Referenz von
      <application>PF</application> in der <link
	xlink:href="http://www.openbsd.org/faq/pf">PF FAQ</link>.
      Peter Hansteen betreut ein sehr ausführliches
      <application>PF</application>-Tutorial unter <link
	xlink:href="http://home.nuug.no/~peter/pf/">
	http://home.nuug.no/~peter/pf/</link>.</para>

    <warning>
      <para>Bedenken Sie beim Studium der <link
	  xlink:href="http://www.openbsd.org/faq/pf/">PF FAQ</link>,
	dass &os; die <application>PF</application>-Version aus
	OpenBSD&nbsp;4.5 enthält.</para>
    </warning>

    <para>Die &a.pf; ist ein guter Anlaufpunkt für Fragen zur
      Konfiguration und dem Einsatz der
      <application>PF</application>-Firewall.  Überprüfen Sie
      aber zunächst die Archive der Mailingliste, bevor Sie eine
      Frage stellen.  Vielleicht wurde die Frage dort schon
      beantwortet.</para>

    <para>Weitere Informationen über die Portierung von
      <application>PF</application> nach &os; finden Sie unter <link
	xlink:href="http://pf4freebsd.love2party.net/">
	http://pf4freebsd.love2party.net/</link>.</para>

    <para>Dieser Abschnitt konzentriert sich auf
      <application>PF</application> in &os;.  Es wird beschrieben, wie
      <application>PF</application> und
      <application>ALTQ</application> aktiviert werden.  Anschließend
      wird demonstriert, wie Regelsätze auf einem &os;-System erstellt
      werden.</para>

    <sect2>
      <title><application>PF</application> aktivieren</title>

      <para>Damit <application>PF</application> benutzt werden kann,
	muss zunächst das Kernelmodul geladen werden.  Dieser
	Abschnitt beschreibt die Einträge für
	<filename>/etc/rc.conf</filename>, die verwendet werden können
	um <application>PF</application> zu aktivieren.</para>

      <para>Beginnen Sie mit folgender Zeile in
	<filename>/etc/rc.conf</filename>:</para>

      <programlisting>pf_enable="YES"</programlisting>

      <para>&man.pfctl.8; beschreibt zusätzliche Optionen, die beim
	Start an <application>PF</application> übergeben werden
	können.  Fügen Sie diesen Eintrag in
	<filename>/etc/rc.conf</filename> hinzu und schreiben Sie die
	benötigten Optionen zwischen die Anführungszeichen:</para>

      <programlisting>pf_flags=""                     # additional flags for pfctl startup</programlisting>

      <para><application>PF</application> kann nicht gestartet werden,
	wenn es seine Konfigurationsdatei nicht findet.  In der
	Voreinstellung existiert bereits ein Regelsatz namens
	<filename>/etc/pf.conf</filename>.  Wenn bereits ein Regelsatz
	an anderer Stelle gespeichert wurde, fügen Sie in
	<filename>/etc/rc.conf</filename> einen Eintrag mit dem
	vollständigen Pfad zur Datei ein:</para>

      <programlisting>pf_rules="<replaceable>/path/to/pf.conf</replaceable>"</programlisting>

      <para>Protokollierungsfunktionen für
	<application>PF</application> werden von &man.pflog.4; zur
	Verfügung gestellt.  Fügen Sie folgende Zeile in
	<filename>/etc/rc.conf</filename> ein, um diese Funktion zu
	aktivieren:</para>

      <programlisting>pflog_enable="YES"</programlisting>

      <para>Die folgenden Zeilen können ebenfalls hinzugefügt werden,
	um den Speicherort der Protokolldatei zu bestimmen und weitere
	Optionen beim Start an &man.pflog.4; zu übergeben:</para>

      <programlisting>pflog_logfile="/var/log/pflog"  # where pflogd should store the logfile
pflog_flags=""                  # additional flags for pflogd startup</programlisting>

      <para>Falls ein <acronym>LAN</acronym> hinter der Firewall
	existiert und die Pakete an die Rechner im
	<acronym>LAN</acronym> weitergeleitet werden müssen, oder
	wenn <acronym>NAT</acronym> benötigt wird, fügen Sie die
	folgende Option hinzu:</para>

      <programlisting>gateway_enable="YES"            # Enable as LAN gateway</programlisting>

      <para>Nachdem die Änderungen gespeichert wurden, kann
	<application>PF</application> mit Unterstützung für
	Protokollierung gestartet werden:</para>

      <screen>&prompt.root; <userinput>service pf start</userinput>
&prompt.root; <userinput>service pflog start</userinput></screen>

<!--
This is no longer true as of 9.x. It also references the CARP section
which doesn't explain how to use it...At some point it should.
      <indexterm>$
	<primary>kernel options</primary>
	<secondary>device pf</secondary>
      </indexterm>

      <indexterm>
	<primary>kernel options</primary>
	<secondary>device pflog</secondary>
      </indexterm>

      <indexterm>
	<primary>kernel options</primary>
	<secondary>device pfsync</secondary>
      </indexterm>

      <note>
	<para>While it is not necessary to compile
	  <application>PF</application> support into the &os; kernel,
	  some advanced features are not included, namely &man.pfsync.4;, which is a
	  pseudo-device that exposes certain changes to the state table
	  used by <application>PF</application>.  It can be paired with
	  &man.carp.4; to create failover firewalls using
	  <application>PF</application>.  More information on
	  <acronym>CARP</acronym> can be found in <xref linkend="carp"/>.</para>

	<para>The following <application>PF</application> kernel options
	  are available:</para>

	<programlisting>device pf
device pflog
device pfsync</programlisting>

	<para>where:</para>

	<para><literal>device pf</literal> enables PF support.</para>

	<para><literal>device pflog</literal> enables the optional
	  &man.pflog.4; pseudo network device which can be used to log
>>>>>>>>  traffic to a &man.bpf.4; descriptor.  The &man.pflogd.8;
>>>>>>>>  daemon can then be used to store the logging information to
>>>>>>>>  disk.</para>

	<para><literal>device pfsync</literal> enables the optional
	  &man.pfsync.4; pseudo-network device that is used to monitor
	  <quote>state changes</quote>.</para>
      </note>
-->

      <para>In der Voreinstellung liest <application>PF</application>
	seine Konfiguration aus <filename>/etc/pf.conf</filename> und
	modifiziert, verwirft oder akzeptiert Pakete anhand der
	Definitionen in dieser Datei.  &os; enthält mehrere
	Beispieldateien unter
	<filename>/usr/share/examples/pf/</filename>.  Auch die
	<link xlink:href="http://www.openbsd.org/faq/pf/">PF
	  FAQ</link> enthält sehr ausführliche Beispiele für
	<application>PF</application>-Regeln.</para>

      <para>Zur Steuerung von <application>PF</application> wird
	<command>pfctl</command> verwendet.  <xref linkend="pfctl"/>
	fasst einige nützliche Optionen für diesen Befehl zusammen.
	Eine Beschreibung aller verfügbaren Optionen finden Sie in
	&man.pfctl.8;.</para>

      <table xml:id="pfctl" frame="none" pgwide="1">
	<title>Nützliche <command>pfctl</command> Optionen</title>

	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Kommando</entry>
	      <entry>Aufgabe</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><command>pfctl -e</command></entry>
	      <entry><application>PF</application> aktivieren</entry>
	    </row>

	    <row>
	      <entry><command>pfctl -d</command></entry>
	      <entry><application>PF</application>
		deaktivieren</entry>
	    </row>

	    <row>
	      <entry><command>pfctl -F all -f
		  /etc/pf.conf</command></entry>
	      <entry>Alle Filterregeln zurücksetzen
		(<acronym>NAT</acronym>, Filter, Zustandstabelle) und
		<filename>/etc/pf.conf</filename> erneut
		einlesen.</entry>
	    </row>

	    <row>
	      <entry><command>pfctl -s [ rules | nat |
		  states ]</command></entry>
	      <entry>Zusammenfassung der Filterregeln,
		<application>NAT</application>-Regeln, oder der
		Zustandstabelle.</entry>
	    </row>

	    <row>
	      <entry><command>pfctl -vnf
		  /etc/pf.conf</command></entry>
	      <entry>Überprüft <filename>/etc/pf.conf</filename> auf
		Fehler, lädt aber die Filterregeln nicht neu.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <tip>
	<para><package>security/sudo</package> ist nützlich um
	  Kommandos mit erhöhten Berechtigungen auszuführen, wie
	  beispielsweise <command>pfctl</command>.  Das Programm kann
	  aus der Ports-Sammlung installiert werden.</para>
      </tip>

      <para>Um den ein- und ausgehenden Verkehr im Auge zu behalten,
	können Sie ein Werkzeug wie <package>sysutils/pftop</package>
	benutzen.  Sobald das Programm installiert ist, können Sie
	<application>pftop</application> ausführen, um einen Snapshot
	des Datenverkehrs zu sehen.  Das Format der Ausgabe ist der
	von &man.top.1; sehr ähnlich.</para>
    </sect2>

    <sect2>
      <title><application>ALTQ</application> aktivieren</title>

      <para>Unter &os; kann <application>ALTQ</application> zusammen
	mit <application>PF</application> benutzt werden, um Quality
	of Service (<acronym>QoS</acronym>) bereitzustellen.  Sobald
	<application>ALTQ</application> aktiviert ist, können
	Warteschlangen definiert werden, mit denen Sie die Priorität
	für ausgehende Pakete festlegen können.</para>

      <para>Bevor Sie <application>ALTQ</application> aktivieren,
	sollten Sie &man.altq.4; lesen und sicherstellen, das der
	Treiber der Netzwerkkarte diese Funktion unterstützt.</para>

      <para><application>ALTQ</application> steht nicht als ladbares
	Kernelmodul zur Verfügung.  Wenn die Netzwerkkarte des Systems
	<application>ALTQ</application> unterstützt, erstellen Sie
	nach den Anweisungen in <xref linkend="kernelconfig"/> einen
	angepassten Kernel.  Als erstes muss
	<application>ALTQ</application> aktiviert werden.  Zudem ist
	mindestens eine weitere Option nötig, um den Algorithmus für
	die Warteschlange zu bestimmen:</para>

      <programlisting>options         ALTQ
options         ALTQ_CBQ        # Class Based Queuing (CBQ)
options         ALTQ_RED        # Random Early Detection (RED)
options         ALTQ_RIO        # RED In/Out
options         ALTQ_HFSC       # Hierarchical Packet Schedule (HFSC)
options         ALTQ_PRIQ       # Priority Queuing (PRIQ)</programlisting>

      <para>Die folgenden Algorithmen stehen zur Verfügung:</para>

      <variablelist>
	<varlistentry>
	  <term>CBQ</term>
	  <listitem>
	    <para>Class Based Queuing (<acronym>CBQ</acronym>) erlaubt
	      es, die Bandbreite einer Verbindung in verschiedene
	      Klassen oder Warteschlangen zu unterteilen, um die
	      Priorität von Datenpaketen basierend auf Filterregeln zu
	      beeinflussen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>RED</term>
	  <listitem>
	    <para>Random Early Detection (<acronym>RED</acronym>) wird
	      eingesetzt, um eine Überlastung des Netzwerks zu
	      vermeiden.  Dazu ermittelt <acronym>RED</acronym> die
	      Größe der Warteschlange und vergleicht diesen Wert mit
	      den minimalen und maximalen Grenzwerten der
	      Warteschlange.  Ist die Warteschlange größer als das
	      erlaubte Maximum, werden alle neuen Pakete nach dem
	      Zufallsprinzip verworfen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>RIO</term>
	  <listitem>
	    <para>Random Early Detection In and Out
	      (<acronym>RIO</acronym>).  Dieser Modus verwaltet
	      mehrere Warteschlangen durchschnittlicher Größe mit
	      mehreren Schwellwerten, eine für jedes
	      <acronym>QoS</acronym>-Level.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>HFSC</term>
	  <listitem>
	    <para>Hierachical Fair Service Curve Packet Scheduler
	      (<acronym>HFSC</acronym>) wird in <link
		xlink:href="http://www-2.cs.cmu.edu/~hzhang/HFSC/main.html">
		http://www-2.cs.cmu.edu/~hzhang/HFSC/main.html</link>
	      beschrieben.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>PRIQ</term>
	  <listitem>
	    <para>Priority Queuing (<acronym>PRIQ</acronym>) lässt den
	      Verkehr einer Warteschlange mit höherer Priorität zuerst
	      durch.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>Weitere Informationen über diese Algorithmen und Beispiele
	für Regelsätze finden Sie unter <link
	  xlink:href="http://www.openbsd.org/faq/pf/queueing.html">
	  http://www.openbsd.org/faq/pf/queueing.html</link>.</para>
    </sect2>

    <sect2 xml:id="pf-tutorial">
      <info>
	<title><application>PF</application> Regelsätze</title>

	<authorgroup>
	  <author>
	    <personname>
	      <firstname>Peter</firstname>
	      <surname>Hansteen</surname>
	      <othername>N. M.</othername>
	    </personname>
	    <contrib>Beigetragen von </contrib>
	  </author>
	</authorgroup>
      </info>

      <para>Dieser Abschnitt beschreibt die Erstellung von angepassten
	Regelsätzen.  Es wird mit dem einfachsten Regelsatz begonnen
	auf dem dann weitere aufgebaut werden, um die
	Konzepte und Funktionen von <application>PF</application> an
	einigen konkreten Beispielen zu verdeutlichen.</para>

      <para>Der einfachste Regelsatz gilt für einen Rechner, der
	keine Dienste anbietet und Zugriff auf das Internet haben
	soll.  Für diesen minimalen Regelsatz wird
	<filename>/etc/pf.conf</filename> wie folgt
	konfiguriert:</para>

      <programlisting>block in all
pass out all keep state</programlisting>

      <para>Die erste Regel blockiert jeglichen eingehenden
	Datenverkehr.  Die zweite Regel erlaubt ausgehende
	Verbindungen von diesem Rechner, während die
	Zustandsinformationen dieser Verbindungen gespeichert werden.
	Diese Zustandsinformationen machen es möglich, den
	Antwortverkehr für diese Verbindungen zu erlauben.  Der
	Regelsatz wird mit dem folgenden Befehl geladen:</para>

      <screen>&prompt.root; <userinput>pfctl -e ; pfctl -f /etc/pf.conf</userinput></screen>

      <para>Neben den Zustandsinformationen verfügt
	<application>PF</application> über
	<firstterm>Listen</firstterm> und
	<firstterm>Makros</firstterm>.  Diese können bei der
	Erstellung der Regeln definiert werden.  Makros können Listen
	enthalten und sie müssen vor ihrer ersten Benutzung definiert
	sein.  Fügen Sie beispielsweise folgende Zeilen an den Anfang
	des Regelsatzes:</para>

      <programlisting>tcp_services = "{ ssh, smtp, domain, www, pop3, auth, pop3s }"
udp_services = "{ domain }"</programlisting>

      <para><application>PF</application> versteht sowohl Portnamen
	als auch Portnummern, solange die Namen in
	<filename>/etc/services</filename> aufgeführt sind.  Dieses
	Beispiel erstellt zwei Makros.  Das erste ist eine Liste mit
	sieben <acronym>TCP</acronym>-Portnamen, die zweite Liste
	enthält einen <acronym>UDP</acronym>-Portnamen.  Sobald ein
	Makro definiert ist, kann es in den Regeln verwendet werden.
	In diesem Beispiel wird der gesamte Datenverkehr geblockt, mit
	Ausnahme der Verbindungen die von diesem Rechner initiiert
	wurden und sich auf einen der angegebenen
	<acronym>TCP</acronym>-Dienste oder den
	<acronym>UDP</acronym>-Dienst beziehen:</para>

      <programlisting>tcp_services = "{ ssh, smtp, domain, www, pop3, auth, pop3s }"
udp_services = "{ domain }"
block all
pass out proto tcp to any port $tcp_services keep state
pass proto udp to any port $udp_services keep state</programlisting>

      <para>Obwohl <acronym>UDP</acronym> als zustandsloses Protokoll
	betrachtet wird, ist <application>PF</application> in der Lage
	einige Zustandsinformationen zu verfolgen.  Wenn
	beispielsweise eine <acronym>UDP</acronym>-Abfrage für einen
	Nameserver das System verlässt, wird
	<application>PF</application> nach der Antwort Ausschau halten
	und das Antwortpaket durch lassen.</para>

      <para>Nachdem der Regelsatz verändert wurde, muss er neu geladen
	werden:</para>

      <screen>&prompt.root; <userinput>pfctl -f /etc/pf.conf</userinput></screen>

      <para>Wenn keine Syntaxfehler festgestellt werden, wird
	<command>pfctl</command> keine Ausgabe erzeugen.  Die Syntax
	kann auch getestet werden, bevor der Regelsatz geladen
	wird:</para>

      <screen>&prompt.root; <userinput>pfctl -nf /etc/pf.conf</userinput></screen>

      <para>Die Option <option>-n</option> bewirkt, dass die Regeln
	nur interpretiert, jedoch nicht geladen werden.  Dies bietet
	die Möglichkeit, alle Fehler zu korrigieren.  Es wird immer
	der letzte gültige Regelsatz geladen, bis
	<application>PF</application> entweder deaktiviert, oder ein
	neuer Regelsatz geladen wird.</para>

      <tip>
	<para>Wenn Sie beim Laden oder Prüfen des Regelsatzes noch die
	  Option <option>-v</option> hinzufügen, wird
	  <command>pfctl</command> den komplett interpretierten
	  Regelsatz anzeigen.  Dies ist äußerst nützlich, wenn Sie
	  versuchen Fehler im Regelsatz zu finden.</para>
      </tip>

      <sect3 xml:id="pftut-gateway">
	<title>Einfaches Gateway mit <acronym>NAT</acronym></title>

	<para>Dieser Abschnitt zeigt wie ein &os;-System mit
	  <application>PF</application> als Gateway konfiguriert wird.
	  Das Gateway muss über mindestens zwei Netzwerkkarten
	  verfügen, die jeweils mit einem separaten Netzwerk verbunden
	  sind.  In diesem Beispiel ist <filename>xl1</filename> mit
	  dem Internet verbunden und <filename>xl0</filename> ist mit
	  dem internen Netzwerk verbunden.</para>

	<para>Aktivieren Sie zunächst das Gateway, damit der Rechner
	  den Netzwerkverkehr von einer Schnittstelle zur nächsten
	  weiterleiten kann.  Diese
	  <application>sysctl</application>-Einstellung sorgt dafür,
	  dass <acronym>IPv4</acronym>-Pakete weitergeleitet
	  werden:</para>

	<screen>&prompt.root; <userinput>sysctl net.inet.ip.forwarding=1</userinput></screen>

	<para>So leiten Sie <acronym>IPv6</acronym>-Datenverkehr
	  weiter:</para>

	<screen>&prompt.root; <userinput>sysctl net.inet6.ip6.forwarding=1</userinput></screen>

	<para>Um diese Einstellungen beim Systemstart zu aktivieren,
	  fügen Sie folgende Zeilen in
	  <filename>/etc/rc.conf</filename> ein:</para>
	
	<programlisting>gateway_enable="YES"		#für ipv4
ipv6_gateway_enable="YES"	#für ipv6</programlisting>

	<para>Prüfen Sie mit <command>ifconfig</command>, dass beide
	  Schnittstellen vorhanden und aktiv sind.</para>

	<para>Als nächstes erstellen Sie die nötigen
	  <application>PF</application>-Regeln, damit das Gateway den
	  Datenverkehr weiterleiten kann.  Die folgende Regel erlaubt
	  den zustandsorientierten Verkehr aus dem Internet zu den
	  Rechnern im Netzwerk:</para>

	<programlisting>pass in on xl1 from xl1:network to xl0:network port $ports keep state</programlisting>

	<para>Diese Regel erlaubt lediglich den Datenverkehr über das
	  Gateway auf der internen Schnittstelle.  Damit die Pakete
	  noch weiter gehen, wird eine passende Regel benötigt:</para>

	<programlisting>pass out on xl0 from xl1:network to xl0:network port $ports keep state</programlisting>

	<para>Obwohl diese beiden Regeln funktionieren, werden sie
	  in der Praxis so spezifisch selten benötigt.  Ein lesbarer
	  Regelsatz ist oft ein sicherer Regelsatz.  Der Rest dieses
	  Abschnitts zeigt, wie Sie die Regeln so einfach und lesbar
	  wie möglich halten.  Zum Beispiel könnten die beiden Regeln
	  zu einer Regel zusammengefasst werden:</para>

	<programlisting>pass from xl1:network to any port $ports keep state</programlisting>

	<para>Die Notation <literal>interface:network</literal> kann
	  durch ein Makro ersetzt werden, um den Regelsatz besser
	  lesbar zu machen.  Zum Beispiel könnte für das Netzwerk an
	  der internen Schnittstelle (<literal>xl0:network</literal>)
	  ein Makro namens <literal>$localnet</literal> definiert
	  werden.  Alternativ könnte für die Definition von
	  <literal>$localnet</literal> auch eine
	  <emphasis>IP-Adresse/Netzmaske</emphasis> Notation verwendet
	  werden, um ein Netzwerk zu bezeichnen, beispielsweise
	  <literal>192.168.100.1/24</literal> für ein privates
	  Subnetz.</para>

	<para>Bei Bedarf kann für <literal>$localnet</literal> auch
	  eine Liste von Netzwerken definiert werden.  Abhängig von
	  den Bedürfnissen kann <literal>$localnet</literal> auch für
	  eine typische Regel wie folgt verwendet werden:</para>

	<programlisting>pass from $localnet to any port $ports keep state</programlisting>

	<para>Der folgende Regelsatz erlaubt sämtlichen Verkehr, der
	  von den Rechnern im internen Netzwerk initiiert wird.
	  Zunächst werden zwei Makros definiert, die die externen und
	  internen 3COM-Schnittstellen repräsentieren.</para>

	<note>
	  <para>Bei Einwählverbindungen wird <filename>tun0</filename>
	    für die externe Schnittstelle verwendet.  Bei
	    <acronym>ADSL</acronym>-Verbindungen, insbesondere denen
	    die <acronym>PPP</acronym> over Ethernet
	    (<acronym>PPPoE</acronym>) verwenden, ist die richtige
	    externe Schnittstelle <filename>tun0</filename> und nicht
	    die physische Ethernet-Schnittstelle.</para>
	</note>

	<programlisting>ext_if = "xl0"	# macro for external interface - use tun0 for PPPoE
int_if = "xl1"	# macro for internal interface
localnet = $int_if:network
# ext_if IP address could be dynamic, hence ($ext_if)
nat on $ext_if from $localnet to any -&gt; ($ext_if)
block all
pass from { lo0, $localnet } to any keep state</programlisting>

	<para>Dieser Regelsatz führt die <acronym>NAT</acronym>-Regel
	  ein, die verwendet wird, um die Übersetzung der
	  Netzwerkadressen von den nicht-routebaren Adressen im
	  internen Netzwerk auf die <acronym>IP</acronym>-Adresse der
	  externen Schnittstelle zu handhaben.  Die Klammern im
	  letzten Teil der <acronym>NAT</acronym>-Regel
	  <literal>($ext_if)</literal> werden angegeben, wenn die
	  <acronym>IP</acronym>-Adresse der externen Schnittstelle
	  dynamisch zugewiesen wird.  Damit wird sichergestellt, dass
	  der Netzwerkverkehr ohne schwerwiegende Unterbrechungen
	  weiterläuft, auch wenn sich die externe
	  <acronym>IP</acronym>-Adresse ändert.</para>

	<para>Beachten Sie, dass dieser Regelsatz wahrscheinlich mehr
	  Verkehr aus dem Netzwerk zulässt, als eigentlich nötig ist.
	  Bei einem angemessenen Aufbau könnte folgendes Makro
	  erstellt werden:</para>

	<programlisting>client_out = "{ ftp-data, ftp, ssh, domain, pop3, auth, nntp, http, \
    https, cvspserver, 2628, 5999, 8000, 8080 }"</programlisting>

	<para>Dieses Makro wird dann in der Filterregel
	  benutzt:</para>

	<programlisting>pass inet proto tcp from $localnet to any port $client_out \
    flags S/SA keep state</programlisting>

	<para>Weitere <literal>pass</literal> Regeln werden
	  vielleicht noch benötigt.  Diese Regel aktiviert
	  <acronym>SSH</acronym> auf der externen
	  Schnittstelle:</para>

	<programlisting>pass in inet proto tcp to $ext_if port ssh</programlisting>

	<para>Dieses Makrodefinition und Regel erlaubt
	  <acronym>DNS</acronym> und <acronym>NTP</acronym> für
	  interne Clients:</para>

	<programlisting>udp_services = "{ domain, ntp }"
pass quick inet proto { tcp, udp } to any port $udp_services keep state</programlisting>

	<para>Beachten Sie das Schlüsselwort <literal>quick</literal>
	  in dieser Regel.  Da der Regelsatz aus mehreren Regeln
	  besteht, ist es wichtig, die Beziehungen zwischen den
	  einzelnen Regeln zu verstehen.  Die Regeln werden von oben
	  nach unten ausgewertet, in der Reihenfolge wie sie
	  geschrieben sind.  Für jedes Paket oder jede Verbindung, das
	  <application>PF</application> ausgewertet, wird die letzte
	  übereinstimmende Regel im Regelsatz angewendet.  Wenn jedoch
	  ein Paket auf eine Regel passt, welche das Schlüsselwort
	  <literal>quick</literal> enthält, wird das Paket
	  entsprechend dieser Regel behandelt und die
	  Regelverarbeitung wird gestoppt.  Diese Vorgehensweise ist
	  sehr nützlich, wenn eine Ausnahme von den allgemeinen Regeln
	  erforderlich ist.</para>
      </sect3>

      <sect3 xml:id="pftut-ftp">
	<title>Einen <acronym>FTP</acronym>-Proxy einrichten</title>

	<para>Die Konfiguration einer funktionierenden Regel für
	  <acronym>FTP</acronym> kann aufgrund der Beschaffenheit des
	  <acronym>FTP</acronym>-Protokolls problematisch sein.
	  <acronym>FTP</acronym> ist sehr viel älter als Firewalls
	  und schon vom Design her unsicher.  Die häufigsten Argumente
	  gegen eine Verwendung von <acronym>FTP</acronym>
	  sind:</para>

	<itemizedlist>
	  <listitem>
	    <para>Passwörter werden im Klartext übertragen.</para>
	  </listitem>

	  <listitem>
	    <para>Das Protokoll erfordert die Verwendung von
	      mindestens zwei <acronym>TCP</acronym>-Verbindungen
	      (Steuerung und Daten) auf separaten Ports.</para>
	  </listitem>

	  <listitem>
	    <para>Wenn eine Sitzung aufgebaut wird, werden die Daten
	      auf zufällig ausgewählten Ports übermittelt.</para>
	  </listitem>
	</itemizedlist>

	<para>All diese Punkte stellen Herausforderungen dar, noch
	  bevor die Client- oder Server-Software auf potenzielle
	  Sicherheitslücken überprüft wurde.  Es existieren aber auch
	  sichere Alternativen für die Dateiübertragung, wie
	  &man.sftp.1; oder &man.scp.1;, wo die Authentifizierung und
	  die Datenübertragung über eine verschlüsselte Verbindung
	  erfolgt.</para>

	<para>Für Situationen, in denen <acronym>FTP</acronym>
	  erforderlich ist, kann <application>PF</application> den
	  <acronym>FTP</acronym>-Datenverkehr an ein kleines
	  Proxy-Programm namens &man.ftp-proxy.8; weiterleiten.
	  Dieses Programm ist im Basissystem von &os; enthalten.  Die
	  Aufgabe des Proxies ist das dynamische Einfügen und
	  Entfernen von Regeln im Regelsatz.  Dies wird durch den
	  Einsatz von Ankern erreicht, damit der
	  <acronym>FTP</acronym>-Verkehr korrekt verarbeitet werden
	  kann.</para>

	<para>Fügen Sie folgende Zeilen in
	  <filename>/etc/rc.conf</filename> ein, um den Proxy zu
	  aktivieren:</para>

	<programlisting>ftpproxy_enable="YES"</programlisting>

	<para>Danach kann der Proxy mit <command>service ftp-proxy
	    start</command> gestartet werden.</para>

	<para>Für die Grundkonfiguration müssen drei weitere Einträge
	  in <filename>/etc/pf.conf</filename> hinzugefügt werden.
	  Zunächst werden die Anker hinzugefügt, die der Proxy für die
	  <acronym>FTP</acronym>-Sitzungen verwendet:</para>

	<programlisting>nat-anchor "ftp-proxy/*"
rdr-anchor "ftp-proxy/*"</programlisting>

	<para>Dann wird eine <literal>pass</literal>-Regel benötigt,
	  damit der <acronym>FTP</acronym>-Datenverkehr durch den
	  Proxy geleitet werden kann.</para>

	<para>Die Regeln für Umleitung und <acronym>NAT</acronym>
	  müssen vor den eigentlichen Filterregeln definiert werden.
	  Fügen Sie diese <literal>rdr</literal>-Regel unmittelbar
	  nach der <acronym>NAT</acronym>-Regel ein:</para>

	<programlisting>rdr pass on $int_if proto tcp from any to any port ftp -&gt; 127.0.0.1 port 8021</programlisting>

	<para>Zum Schluss muss der umgeleitete Verkehr die Firewall
	  passieren dürfen:</para>

	<programlisting>pass out proto tcp from $proxy to any port ftp</programlisting>

	<para><literal>$poxy</literal> enthält die Adresse, an dem der
	  Proxy-Daemon gebunden ist.</para>

	<para>Speichern Sie <filename>/etc/pf.conf</filename> und
	  laden Sie die Regeln neu.  Prüfen Sie von einem Client, ob
	  die <acronym>FTP</acronym>-Verbindungen
	  funktionieren:</para>

	<screen>&prompt.root; <userinput>pfctl -f /etc/pf.conf</userinput></screen>

	<para>Dieses Beispiel umfasst eine Grundkonfiguration, in der
	  die Rechner im lokalen Netzwerk Zugriff auf entfernte
	  <acronym>FTP</acronym>-Server benötigen.  Diese
	  Konfiguration sollte mit den meisten
	  <acronym>FTP</acronym>-Clients und -Servern gut
	  funktionieren.  Das Verhalten von &man.ftp-proxy.8; kann
	  durch diverse Optionen in <literal>ftpproxy_flags</literal>
	  beeinflusst werden.  Einige Clients und Server haben
	  bestimmte Marotten, die bei der Konfiguration berücksichtigt
	  werden müssen.  Es kann zum Beispiel notwendig sein, den
	  <acronym>FTP</acronym>-Datenverkehr für den Proxy einer
	  bestimmten Warteschlange zuzuweisen.</para>

	<para>Es besteht auch die Möglichkeit einen
	  <acronym>FTP</acronym>-Server mit
	  <application>PF</application> und &man.ftp-proxy.8; zu
	  schützen.  Konfigurieren Sie einen separaten
	  <command>ftp-proxy</command> mit <option>-R</option> für den
	  Reverse-Modus auf einem separaten Port und einer eigenen
	  Umleitungsregel.</para>
      </sect3>

      <sect3 xml:id="pftut-icmp">
	<title><acronym>ICMP</acronym> verwalten</title>

	<para>Viele Werkzeuge zur Fehlerbehebung in
	  <acronym>TCP/IP</acronym>-Netzwerken verlassen sich auf das
	  <foreignphrase>Internet Control Message
	    Protocol</foreignphrase> (<acronym>ICMP</acronym>), das
	  speziell für diese Zwecke entwickelt wurde.</para>

	<para>Das <acronym>ICMP</acronym>-Protokoll sendet und
	  empfängt Kontrollnachrichten zwischen Rechnern und Gateways,
	  hauptsächlich um ungewöhnliche Bedingungen auf dem Weg zum
	  Zielrechner zu berichten.  Router verwenden
	  <acronym>ICMP</acronym> um Paketgrößen und andere
	  Übertragungsparameter zu ermitteln.  Dieser Prozess ist auch
	  als <emphasis>Path <acronym>MTU</acronym>
	    Discovery</emphasis> bekannt.</para>

	<para>Aus der Sicht einer Firewall sind einige
	  <acronym>ICMP</acronym>-Kontrollnachrichten anfällig für
	  bekannte Angriffsmethoden.  Zwar ist die Fehlerbehebung
	  einfacher, wenn alle <acronym>ICMP</acronym>-Pakete
	  bedingungslos durch gelassen werden, aber dass macht es auch
	  für Angreifer leichter, Informationen über das Netzwerk zu
	  extrahieren.  Aus diesen Gründen ist die folgende Regel nicht
	  optimal:</para>

	<programlisting>pass inet proto icmp from any to any</programlisting>

	<para>Eine Lösung besteht darin, nur den
	  <acronym>ICMP</acronym>-Verkehr aus dem lokalen Netz zu
	  akzeptieren, während <acronym>ICMP</acronym>-Pakete von
	  außerhalb des Netzwerks verworfen werden:</para>

	<programlisting>pass inet proto icmp from $localnet to any keep state
pass inet proto icmp from any to $ext_if keep state</programlisting>

	<para>Es stehen noch weitere Optionen zur Verfügung, die die
	  Flexibilität von <application>PF</application>
	  demonstrieren.  Anstatt beispielsweise alle
	  <acronym>ICMP</acronym>-Nachrichten zu erlauben, kann man
	  die Nachrichten angeben, die von &man.ping.8; und
	  &man.traceroute.8; verwendet werden.  Beginnen Sie damit,
	  ein Makro für diese Art von Nachrichten zu
	  definieren:</para>

	<programlisting>icmp_types = "echoreq"</programlisting>

	<para>Erstellen Sie dann eine Regel, die das eben erstellte
	  Makro benutzt:</para>

	<programlisting>pass inet proto icmp all icmp-type $icmp_types keep state</programlisting>

	<para>Wenn weitere Arten von
	  <acronym>ICMP</acronym>-Nachrichten benötigt werden, kann
	  die Liste <literal>icmp_types</literal> einfach erweitert
	  werden.  Geben Sie <command>more
	    /usr/src/contrib/pf/pfctl/pfctl_parser.c</command> ein, um
	  eine Liste der von <application>PF</application>
	  unterstützten <acronym>ICMP</acronym>-Nachrichten zu sehen.
	  Die Webseite <link
	    xlink:href="http://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml">
	    http://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml</link>
	  enthält eine Erklärung für jeden Nachrichtentyp.</para>

	<para>Da &unix; <command>traceroute</command> in der
	  Voreinstellung <acronym>UDP</acronym> verwendet, wird eine
	  weitere Regel benötigt:</para>

	<programlisting># allow out the default range for traceroute(8):
pass out on $ext_if inet proto udp from any to any port 33433 &gt;&lt; 33626 keep state</programlisting>

	<para>Da <command>TRACERT.EXE</command> unter
	  &microsoft.windows;-Systemen <acronym>ICMP</acronym> Echo
	  Request Meldungen verwendet, ist nur die erste Regel
	  notwendig um Traces für solche Systeme zu ermöglichen.
	  &unix; <command>traceroute</command> kann aber auch andere
	  Protokolle verwenden, zum Beispiel <acronym>ICMP</acronym>
	  Echo Request, wenn der Schalter <option>-I</option> benutzt
	  wird.  Details finden Sie in &man.traceroute.8;.</para>

	<sect4 xml:id="pftut-pathmtudisc">
	  <title>Path <acronym>MTU</acronym> Discovery</title>

	  <para>Internet-Protokolle sind so ausgelegt, dass sie
	    geräteunabhängig sind.  Eine Folge davon ist, dass die
	    optimale Paketgröße nicht immer zuverlässig vorhergesagt
	    werden kann.  Das größte Hindernis ist hier die
	    <emphasis>Maximum Transmission Unit</emphasis>
	    (<literal>MTU</literal>), welche die Obergrenze für die
	    Paketgröße festlegt.  Die <acronym>MTU</acronym> für die
	    Schnittstelle des Systems können Sie sich mit
	    <command>ifconfig</command> anzeigen lassen.</para>

	  <para><acronym>TCP/IP</acronym> benutzt ein Verfahren, das
	    als <foreignphrase>path MTU discovery</foreignphrase>
	    bekannt ist, um die korrekte Paketgröße für eine
	    Verbindung zu bestimmen.  Dieses Verfahren sendet Pakete
	    unterschiedlicher Größe mit dem Flag <quote>do not
	      fragment</quote> und erwartet ein
	    <acronym>ICMP</acronym>-Antwortpaket vom Typ
	    <quote>type 3, code 4</quote>, wenn die Obergrenze
	    erreicht worden ist.  Typ 3 bedeutet <quote>Ziel nicht
	      erreichbar</quote> und Code 4 ist die Abkürzung für
	    <quote>Fragmentierung nötig, aber Do-not-Fragment Flag ist
	      gesetzt</quote>.  Um <foreignphrase>path MTU
	      discovery</foreignphrase> zu erlauben und damit
	    Verbindungen zu anderen <acronym>MTU</acronym>s zu
	    unterstützen, fügen Sie dem Makro
	    <literal>icmp_types</literal> den Typ <literal>destination
	      unreachable</literal> hinzu:</para>

	  <programlisting>icmp_types = "{ echoreq, unreach }"</programlisting>

	  <para>Da die <literal>pass</literal>-Regel bereits das Makro
	    verwendet, braucht es nicht geändert werden um den neuen
	    <acronym>ICMP</acronym>-Typ zu unterstützen:</para>

	  <programlisting>pass inet proto icmp all icmp-type $icmp_types keep state</programlisting>

	  <para><application>PF</application> kann alle Variationen
	    von <acronym>ICMP</acronym>-Typen und Codes filtern.  Eine
	    Liste der verfügbaren Typen und Codes ist in &man.icmp.4;
	    und &man.icmp6.4; dokumentiert.</para>
	</sect4>
      </sect3>

      <sect3 xml:id="pftut-tables">
	<title>Tabellen benutzen</title>

	<para>Manchmal sind bestimmte Daten für die Filterung und
	  Weiterleitung interessant, jedoch wäre eine Definition einer
	  solchen Filterregel für einen Regelsatz viel zu lang.
	  <application>PF</application> unterstützt die Verwendung von
	  Tabellen.  Dies sind definierte Listen, die verändert werden
	  können, ohne den gesamten Regelsatz neu laden zu müssen.
	  Zudem können diese Listen sehr schnell durchsucht werden.
	  Tabellennamen sind immer in <literal>&lt; &gt;</literal>
	  eingeschlossen und sehen wie folgt aus:</para>

	<programlisting>table &lt;clients&gt; { 192.168.2.0/24, !192.168.2.5 }</programlisting>

	<para>In diesem Beispiel ist das Netzwerk
	  <literal>192.168.2.0/24</literal> Teil der Tabelle.
	  <literal>192.168.2.5</literal> wurde im dem Operator
	  <literal>!</literal> ausgeschlossen und ist somit nicht Teil
	  der Tabelle.  Es ist auch möglich Tabellen aus Dateien zu
	  laden, wo jeder Eintrag in einer separaten Zeile steht.
	  Dieses Beispiel verwendet dazu die Datei
	  <filename>/etc/clients</filename>:</para>

	<programlisting>192.168.2.0/24
!192.168.2.5</programlisting>

	<para>Um sich auf diese Datei zu beziehen, definieren Sie die
	  Tabelle wie folgt:</para>

	<programlisting>table &lt;clients&gt; persist file "/etc/clients"</programlisting>

	<para>Sobald die Tabelle definiert ist, kann eine Filterregel
	  Bezug darauf nehmen:</para>

	<programlisting>pass inet proto tcp from &lt;clients&gt; to any port $client_out flags S/SA keep state</programlisting>

	<para>Die Inhalte einer Tabelle können mit
	  <command>pfctl</command> direkt verändert werden.  Dieses
	  Beispiel fügt ein weiteres Netzwerk zur Tabelle
	  hinzu:</para>

	<screen>&prompt.root; <userinput>pfctl -t clients -T add 192.168.1.0/16</userinput></screen>

	<para>Beachten Sie, dass auf diese Weise vorgenommene
	  Änderungen direkt übernommen werden, jedoch bei einem
	  Neustart des Systems oder bei einem Stromausfall verloren
	  gehen.  Um die Änderungen dauerhaft zu speichern, müssen sie
	  in der Definition der Tabelle oder in der Datei, auf die
	  sich die Tabelle bezieht, bearbeitet werden.  Mit einem
	  &man.cron.8; Job und einem Befehl wie
	  <command>pfctl -t clients -T show &gt;/etc/clients</command>
	  können Sie auch eine Kopie der Tabelle auf Platte speichern
	  und dann in regelmäßigen Abständen aktualisieren.
	  Alternativ kann <filename>/etc/clients</filename> auch mit
	  den Tabelleneinträgen, die sich aktuell im Speicher
	  befinden, aktualisiert werden.</para>

	<screen>&prompt.root; <userinput>pfctl -t clients -T replace -f /etc/clients</userinput></screen>
      </sect3>

      <sect3 xml:id="pftut-overload">
	<title>Verwendung von Tabellen zum Schutz von
	  <acronym>SSH</acronym></title>

	<para>Benutzer, die <acronym>SSH</acronym> auf einer externen
	  Schnittstelle ausführen, haben wahrscheinlich schon einmal
	  ähnliche Meldungen in den Protokolldateien gesehen:</para>

	<programlisting>Sep 26 03:12:34 skapet sshd[25771]: Failed password for root from 200.72.41.31 port 40992 ssh2
Sep 26 03:12:34 skapet sshd[5279]: Failed password for root from 200.72.41.31 port 40992 ssh2
Sep 26 03:12:35 skapet sshd[5279]: Received disconnect from 200.72.41.31: 11: Bye Bye
Sep 26 03:12:44 skapet sshd[29635]: Invalid user admin from 200.72.41.31
Sep 26 03:12:44 skapet sshd[24703]: input_userauth_request: invalid user admin
Sep 26 03:12:44 skapet sshd[24703]: Failed password for invalid user admin from 200.72.41.31 port 41484 ssh2</programlisting>

	<para>Diese Meldungen deuten auf einen Brute-Force-Angriff
	  hin, bei dem ein Angreifer oder ein Programm versucht,
	  den Benutzernamen und das Passwort zu erraten, um Zugriff
	  auf das System zu bekommen.</para>

	<para>Wenn der Zugriff über <acronym>SSH</acronym> für
	  berechtigte Benutzer erforderlich ist, kann eine Änderung
	  des Standard-Ports für <acronym>SSH</acronym> einen gewissen
	  Schutz bieten.  Allerdings bietet
	  <application>PF</application> eine elegantere Lösung für
	  dieses Problem.  <literal>pass</literal>-Regeln können
	  Einschränkungen für Dinge enthalten, die ein verbindender
	  Rechner tun kann.  Bei einem Verstoß gegen diese
	  Einschränkungen kann dann dem betroffenen Rechner der
	  Zugriff teilweise oder ganz entzogen werden.  Es ist sogar
	  möglich, alle bestehenden Verbindungen zu trennen, falls die
	  Grenze überschritten wird.</para>

	<para>Um dies zu konfigurieren, erstellen Sie folgende Tabelle
	  im Regelsatz:</para>

	<programlisting>table &lt;bruteforce&gt; persist</programlisting>

	<para>Fügen Sie dann ziemlich am Anfang der Filterregeln
	  folgende Regeln hinzu, um die Brute-Force-Angriffe zu
	  blocken und gleichzeitig berechtigte Verbindungen zu
	  erlauben:</para>

	<programlisting>block quick from &lt;bruteforce&gt;
pass inet proto tcp from any to $localnet port $tcp_services \
    flags S/SA keep state \
    (max-src-conn <replaceable>100</replaceable>, max-src-conn-rate <replaceable>15/5</replaceable>, \
    overload &lt;bruteforce&gt; flush global)</programlisting>

	<para>Der Teil in Klammern definiert die Grenzwerte.  Die
	  Zahlen sollten an die lokalen Anforderungen angepasst
	  werden.  Die Zeilen können wie folgt interpretiert
	  werden:</para>

	<para><literal>max-src-conn</literal> definiert die maximal
	  erlaubte Anzahl gleichzeitiger Verbindungen von einem
	  Rechner.</para>

	<para><literal>max-src-conn-rate</literal> definiert die
	  maximal erlaubte Anzahl neuer Verbindungen eines einzelnen
	  Rechners (<replaceable>15</replaceable>) pro Anzahl von
	  Sekunden (<replaceable>5</replaceable>).</para>

	<para><literal>overload &lt;bruteforce&gt;</literal> bedeutet,
	  dass jeder Rechner, der diesen Grenzwert überschreitet, zur
	  Tabelle <literal>bruteforce</literal> hinzugefügt wird.
	  Diese Filterregel blockiert jeglichen Datenverkehr von
	  Adressen aus der Tabelle
	  <literal>bruteforce</literal>.</para>

	<para><literal>flush global</literal> besagt, dass alle
	  (<literal>global</literal>) Verbindungen dieses Rechners
	  getrennt (<literal>flush</literal>) werden, wenn der
	  Grenzwert erreicht wird.</para>

	<note>
	  <para>Diese Filterregeln helfen nicht bei langsamen
	    Brute-Force-Angriffen, wie sie in <link
	      xlink:href="http://home.nuug.no/~peter/hailmary2013/">
	      http://home.nuug.no/~peter/hailmary2013/</link>
	    beschrieben sind.</para>
	</note>

	<para>Dieser Beispielregelsatz dient lediglich als
	  Illustration.  Wenn Sie allgemein eine große Anzahl an
	  Verbindungen erlauben wollen, aber gleichzeitig
	  bei <acronym>SSH</acronym> etwas restriktiver vorgehen
	  möchten, können Sie die obige Regel ergänzen:</para>

	<programlisting>pass quick proto { tcp, udp } from any to any port ssh \
    flags S/SA keep state \
    (max-src-conn 15, max-src-conn-rate 5/3, \
    overload &lt;bruteforce&gt; flush global)</programlisting>

	<note>
	  <!-- XXX Overloaders == agressive Rechner -->
	  <title>Es ist möglicherweise nicht notwendig, alle
	    aggressiven Rechner zu blockieren</title>

	  <para>Es ist zu erwähnen, dass der
	    <literal>overlaod</literal>-Mechanismus eine allgemeine
	    Technik darstellt, die nicht auf <acronym>SSH</acronym>
	    beschränkt ist.  Außerdem ist es nicht immer optimal,
	    Datenverkehr von aggressiven Rechnern zu
	    blockieren.</para>

	  <para>Eine <literal>overload</literal>-Regel kann
	    beispielsweise benutzt werden, um einen Mail- oder
	    Webserver zu schützen.  Die
	    <literal>overload</literal>-Tabelle könnte dann in einer
	    Regel verwendet werden, um aggressive Rechner einer
	    Warteschlange mit geringerer Bandbreite zuzuweisen, oder
	    den Rechner auf eine bestimtme Webseite umzuleiten.</para>
	</note>

	<para>Im Laufe der Zeit werden die Tabellen durch die
	  <literal>overload</literal>-Regeln immer größer und belegen
	  immer mehr Speicher.  Manchmal wird eine geblockte
	  <acronym>IP</acronym>-Adresse einem Rechner dynamisch
	  zugewiesen, der eigentlich berechtigt ist, mit den Rechnern
	  im lokalen Netzwerk zu kommunizieren.</para>

	<para>Für solche Situationen bietet <command>pfctl</command>
	  die Möglichkeit, Tabelleneinträge auslaufen zu lassen.
	  Dieses Kommando würde beispielsweise Einträge aus der
	  Tabelle <literal>&lt;bruteforce&gt;</literal> löschen,
	  die seit <literal>86400</literal> Sekunden nicht mehr
	  referenziert wurden:</para>

	<screen>&prompt.root; <userinput>pfctl -t bruteforce -T expire 86400</userinput></screen>

	<para>Eine ähnliche Funktionalität bietet
	  <package>security/expiretable</package>, welches Einträge
	  entfernt, die für einen bestimmten Zeitraum nicht
	  referenziert wurden.</para>

	<para>Nach der Installation kann
	  <application>expiretable</application> benutzt werden, um
	  Einträge aus der Tabelle
	  <literal>&lt;bruteforce&gt;</literal> nach einer bestimmten
	  Zeit zu entfernen.  Dieses Beispiel entfernt alle Einträge,
	  die älter sind als 24 Stunden:</para>

	<programlisting>/usr/local/sbin/expiretable -v -d -t 24h bruteforce</programlisting>
      </sect3>

      <sect3 xml:id="pftut-spamd">
	<title>Schutzt vor <acronym>SPAM</acronym></title>

	<para>Im Gegensatz zum <application>spamd</application>-Daemon
	  von <application>spamassassin</application>, kann
	  <package>mail/spamd</package> zusammen mit
	  <application>PF</application> den <acronym>SPAM</acronym>
	  direkt an der Firewall abwehren.  Dieser
	  <application>spamd</application> wird in
	  <application>PF</application> über einen Satz von
	  Umleitungen konfiguriert.</para>

	<para>Spammer neigen dazu, eine große Anzahl von Nachrichten
	  zu versenden.  Dabei nutzten Sie
	  <acronym>SPAM</acronym>-freundliche Netzwerke und gekaperte
	  Rechner, welche dann ziemlich schnell bei sogenannten
	  <foreignphrase>Blacklists</foreignphrase> gemeldet
	  werden.</para>

	<para>Wenn eine <acronym>SMTP</acronym>-Verbindung von einer
	  Adresse in der Blacklist empfangen wird, präsentiert
	  <application>spamd</application> einen Banner und schaltet
	  sofort in einen Modus, in dem die Antworten auf den
	  <acronym>SMTP</acronym>-Verkehr jeweils ein Byte groß sind.
	  Diese Technik, die möglichst viel Zeit des Spammers
	  verschwenden soll, wird
	  <foreignphrase>Tarpitting</foreignphrase> genannt.  Die
	  spezifische Implementierung, welche ein Byte
	  <acronym>SMTP</acronym>-Antworten verwendet, wird als
	  <foreignphrase>Stuttering</foreignphrase> bezeichnet.</para>

	<para>Dieses Beispiel zeigt das grundlegende Verfahren zur
	  Konfiguration von <application>spamd</application> mit
	  automatisch aktualisierten Blacklists.  Für weitere
	  Informationen lesen die Manualpages, die zusammen mit
	  <package>mail/spamd</package> installiert werden.</para>

	<procedure>
	  <title>Konfiguration von
	    <application>spamd</application></title>

	  <step>
	    <para>Installieren Sie das Paket oder den Port
	      <package>mail/spamd</package>.  Um
	      <application>spamd</application>'s Greylisting-Funktion
	      zu nutzen, muss &man.fdescfs.5; in
	      <filename>/dev/fd</filename> eingehängt werden.  Fügen
	      Sie folgende Zeile in <filename>/etc/fstab</filename>
	      ein:</para>

	    <programlisting>fdescfs /dev/fd fdescfs rw 0 0</programlisting>

	    <para>Danach hängen Sie das Dateisystem ein:</para>

	    <screen>&prompt.root; <userinput>mount fdescfs</userinput></screen>
	  </step>

	  <step>
	    <para>Fügen Sie folgende Zeilen in den
	      <application>PF</application>-Regelsatz ein:</para>

	    <programlisting>table &lt;spamd&gt; persist
table &lt;spamd-white&gt; persist
rdr pass on $ext_if inet proto tcp from &lt;spamd&gt; to \
    { $ext_if, $localnet } port smtp -&gt; 127.0.0.1 port 8025
rdr pass on $ext_if inet proto tcp from !&lt;spamd-white&gt; to \
    { $ext_if, $localnet } port smtp -&gt; 127.0.0.1 port 8025</programlisting>

	    <para>Die beiden Tabellen <literal>&lt;spamd&gt;</literal>
	      und <literal>&lt;spam-white&gt;</literal> sind von
	      großer Bedeutung.  <acronym>SMTP</acronym>-Verkehr von
	      einer Adresse, die in <literal>&lt;spamd&gt;</literal>
	      aber nicht in <literal>&lt;spamd-white&gt;</literal>
	      ist, wird an den <application>spamd</application>-Daemon
	      auf Port 8025 umgeleitet.</para>
	  </step>

	  <step>
	    <para>Im nächsten Schritt wird
	      <application>spamd</application> in
	      <filename>/usr/local/etc/spamd.conf</filename>
	      konfiguriert und einige Parameter werden in
	      <filename>/etc/rc.conf</filename> hinzugefügt.</para>

	    <para>Die Installation von <package>mail/spamd</package>
	      enthält eine Beispielkonfiguration
	      (<filename>/usr/local/etc/spamd.conf.sample</filename>)
	      und eine Manualpage für <filename>spamd.conf</filename>.
	      Beziehen Sie sich für zusätzliche Konfigurationsoptionen
	      auf diese Dokumentation.</para>

	    <para>Die Konfigurationsdatei enthält einen Block, in dem
	      die <literal>all</literal>-Liste definiert ist, die
	      wiederum weitere Listen spezifiziert:</para>

	    <programlisting>all:\
    :traplist:whitelist:</programlisting>

	    <para>Dieser Eintrag fügt die gewünschten Blacklists,
	      getrennt durch einen Doppelpunkt (<literal>:</literal>),
	      hinzu.  Um auch eine Whitelist zu verwenden, fügen Sie
	      den Namen unmittelbar hinter dem Namen der Blacklist
	      ein.  Zum Beispiel:
	      <literal>:Blacklist:Whitelist:</literal>.</para>

	    <para>Danach folgt die Definition der verwendeten
	      Blacklist:</para>

	    <programlisting>traplist:\
    :black:\
    :msg="SPAM. Your address %A has sent spam within the last 24 hours":\
    :method=http:\
    :file=www.openbsd.org/spamd/traplist.gz</programlisting>

	    <para>In der ersten Zeile steht der Name der Blacklist und
	      die zweite Zeile gibt den Typ an.  Das Feld
	      <literal>msg</literal> enthält die Nachricht, die dem
	      Absender während des <acronym>SMTP</acronym>-Dialogs
	      angezeigt wird.  Das Feld <literal>mehtod</literal> legt
	      fest, wie <application>spamd-setup</application> die
	      Listen bezieht; unterstützte Methoden sind
	      <literal>http</literal>, <literal>ftp</literal>,
	      <literal>file</literal> und ein externes Programm via
	      <literal>exec</literal>.  Im letzten Feld gibt
	      <literal>file</literal> den Namen der Datei an, die
	      <application>spamd</application> erwartet.</para>

	    <para>Die Definition der Whitelist ist ähnlich.  Das Feld
	      <literal>msg</literal> wird jedoch nicht definiert, da
	      eine Meldung hier nicht erforderlich ist:</para>

	    <programlisting>whitelist:\
    :white:\
    :method=file:\
    :file=/var/mail/whitelist.txt</programlisting>

	    <tip>
	      <title>Wählen Sie die Datenquellen mit Sorgfalt:</title>

	      <para>Bei der Verwendung von sämtlichen Blacklists aus
		der Beispieldatei <filename>spamd.conf</filename>
		würden große Teile des Internets geblockt.  Der
		Administrator muss diese Datei bearbeiten, um eine
		optimale Konfiguration zu erzielen.  Dazu gehört auch
		die Auswahl von geeigneten Blacklists und, wenn nötig,
		die Erstellung von benutzerdefinierten Listen.</para>
	    </tip>

	    <para>Als nächstes fügen Sie folgenden Eintrag in
	      <filename>/etc/rc.conf</filename> hinzu.  Zusätzliche
	      Optionen sind in der Manualpage beschrieben:</para>

	    <programlisting>spamd_flags="-v" # use "" and see spamd-setup(8) for flags</programlisting>

	    <para>Wenn Sie fertig sind, starten Sie
	      <application>spamd</application> durch die Eingabe von
	      <command>service obspamd start</command>.  Führen Sie
	      die weitere Konfiguration mit
	      <command>spamd-setup</command> durch.  Erstellen Sie zum
	      Schluss einen &man.cron.8;-Job, der
	      <command>spamd-setup</command> in regelmäßigen Abständen
	      aufruft, um die Listen zu aktualisieren.</para>
	  </step>
	</procedure>

	<para>Auf einem typischen Gateway vor dem Mailserver, werden
	  Rechner innerhalb von wenigen Minuten geblockt.</para>

	<para><application>PF</application> unterstützt auch
	  <firstterm>Greylisting</firstterm>, das Nachrichten von
	  unbekannten Rechnern vorübergehend mit
	  <replaceable>45n</replaceable>-Codes ablehnt.  Nachrichten
	  von diesen Rechnern werden bei einem erneuten Versuch nach
	  einer angemessenen Zeit durchgelassen.  Nachrichten von
	  Rechnern, die nach RFC 1123 und RFC 2821 konfiguriert sind,
	  werden sofort durchgelassen.</para>

	<para>Weitere Informationen über Greylisting finden Sie unter
	  <link xlink:href="http://www.greylisting.org/">
	  greylisting.org</link>.  Das Erstaunlichste an Greylisting
	  ist, neben der einfachen Benutzung, dass es immer noch
	  funktioniert.  Spammer und Malware-Autoren gelingt es
	  bislang nur schwer, diese Technik zu umgehen.</para>

	<para>Die grundsätzliche Vorgehensweise zur Konfiguration von
	  Greylisting ist wie folgt:</para>

	<procedure>
	  <title>Konfiguration von Greylisting</title>

	  <step>
	    <para>Stellen Sie sicher, dass &man.fdescfs.5; eingehängt
	      ist.  Dies wird in Schritt 1 der vorherigen Prozedur
	      beschrieben.</para>
	  </step>

	  <step>
	    <para>Um <application>spamd</application> im
	      Greylisting-Modus auszuführen, fügen Sie folgende Zeilen
	      in <filename>/etc/rc.conf</filename> ein:</para>

	    <programlisting>spamd_grey="YES"  # use spamd greylisting if YES</programlisting>

	    <para>Lesen Sie die Manualpage von
	      <application>spamd</application> für Beschreibungen von
	      zusätzlichen Parametern.</para>
	  </step>

	  <step>
	    <para>Starten Sie die Dienste, um die Konfiguration von
	      Greylisting abzuschließen:</para>

	    <screen>&prompt.root; <userinput>service obspamd restart</userinput>
&prompt.root; <userinput>service spamlogd start</userinput></screen>
	  </step>
	</procedure>

	<para>Hinter den Kulissen führen die
	  <application>spamdb</application>-Datenbank und
	  <application>spamlogd</application> wesentliche Aufgaben der
	  Greylisting-Funktion aus.  <application>spamdb</application>
	  ist die Schnittstelle für den Administrator, der über den
	  Inhalt der Datenbank <filename>/var/db/spamdb</filename>
	  Blaklists, Whitelists und Greylists verwaltet.</para>
      </sect3>

      <sect3 xml:id="pftut-hygiene">
	<title>Netzwerk-Hygiene</title>

	<para>Dieser Abschnitt beschreibt die Verwendung von
	  <literal>block-policy</literal>, <literal>scrub</literal>
	  und <literal>antispoof</literal>, mit denen das Verhalten
	  des Regelsatzes weiter optimiert werden kann.</para>

	<para>Die Option <literal>block-policy</literal> kann im
	  Teil <literal>options</literal> des Regelwerks konfiguriert
	  werden, vor den Umleitungen und den eigentlichen
	  Filterregeln.  Diese Option legt fest, welche Rückmeldung
	  <application>PF</application> an einen geblockten Rechner
	  sendet.  Es existieren zwei mögliche Werte:
	  <literal>drop</literal> verwirft das Paket ohne Rückmeldung
	  und <literal>return</literal> gibt eine Statusmeldung, wie
	  etwa <computeroutput>Connection refused</computeroutput>
	  zurück.</para>

	<para>Die Voreinstellung ist <literal>drop</literal>.  Geben
	  Sie den gewünschten Wert ein, um die
	  <literal>block-policy</literal>-Richtlinie zu ändern:</para>

	<programlisting>set block-policy return</programlisting>

	<para><literal>scrub</literal> ist ein Schlüsselwort in
	  <application>PF</application>, das die Paket-Normalisierung
	  aktiviert.  Dieser Prozess fügt fragmentierte Pakete wieder
	  zusammen und blockt <acronym>TCP</acronym>-Pakete mit
	  ungültigen Flag-Kombinationen.  Ein aktiviertes
	  <literal>scrub</literal> bietet einen gewissen Schutz gegen
	  Angriffe, die auf die falsche Handhabung von fragmentierten
	  Paketen aufbauen.  Es stehen viele Optionen zur Verfügung,
	  jedoch sollte die einfachste Form für die meisten
	  Konfigurationen ausreichend sein:</para>

	<programlisting>scrub in all</programlisting>

	<para>Einige Dienste, wie beispielsweise
	  <acronym>NFS</acronym>, erfordern eine bestimmte Handhabung
	  von fragmentierten Paketen.  Weitere Informationen finden
	  Sie unter <link
	    xlink:href="https://home.nuug.no/~peter/pf/en/scrub.html">https://home.nuug.no/~peter/pf/en/scrub.html</link>.</para>

	<para>Dieses Beispiel fügt fragmentierte Pakete wieder
	  zusammen, löscht das <quote>do not fragment</quote>-Bit und
	  setzt die maximale Segmentgröße auf 1440 Bytes:</para>

	<programlisting>scrub in all fragment reassemble no-df max-mss 1440</programlisting>

	<para>Der <literal>antispoof</literal>-Mechanismus bietet
	  einen Schutz gegen gefälschte
	  <acronym>IP</acronym>-Adressen.  Dabei werden hauptsächlich
	  Pakete verworfen, die auf der falschen Schnittstellen
	  ankommen.</para>

	<para>Folgende Regeln verwerfen gefälschte Adressen, wenn sie
	  aus dem Internet oder dem lokalen Netzwerk stammen:</para>

	<programlisting>antispoof for $ext_if
antispoof for $int_if</programlisting>
      </sect3>

      <sect3 xml:id="pftut-unrouteables">
	<title>Handhabung von nicht-routebaren Adressen</title>

	<para>Sogar bei einem richtig konfigurierten
	  <acronym>NAT</acronym>-Gateway müssen Sie vielleicht die
	  Fehlkonfiguration anderer Personen ausgleichen.  Ein
	  typischer Fehler besteht darin, nicht-routebare Adressen ins
	  Internet zu lassen.  Da der Verkehr von nicht-routebaren
	  Adressen Teil eines <acronym>DoS</acronym>-Angriffs sein
	  kann, sollten Sie in Betracht ziehen, diesen Verkehr
	  explizit an der externen Schnittstelle des Netzwerks zu
	  blockieren.</para>

	<para>In diesem Beispiel wird ein Makro erstellt, das die
	  nicht-routebaren Adressen enthält.  Datenverkehr von und zu
	  diesen Adressen wird dann an der externen Schnittstelle des
	  Gateways verworfen.</para>

	<programlisting>martians = "{ 127.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12, \
	      10.0.0.0/8, 169.254.0.0/16, 192.0.2.0/24, \
	      0.0.0.0/8, 240.0.0.0/4 }"

block drop in quick on $ext_if from $martians to any
block drop out quick on $ext_if from any to $martians</programlisting>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="firewalls-ipfw">
    <title>IPFW</title>

    <indexterm>
      <primary>Firewall</primary>
      <secondary>IPFW</secondary>
    </indexterm>

    <para><application>IPFW</application> ist eine
      <foreignphrase>Stateful-Firewall</foreignphrase>
      für &os;, die sowohl <acronym>IPv4</acronym> als auch
      <acronym>IPv6</acronym> unterstützt.  Die Firewall setzt sich
      aus mehreren Komponenten zusammen: dem Kernel Firewall
      Filter-Prozessor mit integriertem Paket-Accounting,
      Protokollfunktionen, <acronym>NAT</acronym>, dem
      &man.dummynet.4; <foreignphrase>Traffic-Shaper</foreignphrase>,
      sowie Weiterleitungs-, Bridge- und ipstealth-Funktionen.</para>

    <para>&os; enthält mit <filename>/etc/rc.firewall</filename> ein
      Beispielregelwerk, welches mehrere Firewall-Typen für
      gebräuchliche Szenarien definiert und unerfahrene Anwender
      dabei unterstützen soll, ein geeignetes Regelwerk zu erstellen.
      <application>IPFW</application> besitzt eine leistungsstarke
      Syntax, mit der erfahrene Benutzer ihre eigenen Regeln
      anfertigen können, um den Sicherheitsanforderungen der
      jeweiligen Umgebung gerecht zu werden.</para>

    <para>Diser Abschnitt beschreibt, wie
      <application>IPFW</application> aktiviert wird und bietet einen
      Überblick über die Regelsyntax.  Zudem werden mehrere Regelsätze
      für gebräuchliche Konfigurationsszenarien vorgestellt.</para>

    <sect2 xml:id="firewalls-ipfw-enable">
      <title><application>IPFW</application> aktivieren</title>

      <indexterm>
	<primary><application>IPFW</application></primary>
	<secondary>aktivieren</secondary>
      </indexterm>

      <para>Das &os; Basissystem enthält für
	<application>IPFW</application> ein ladbares Kernelmodul, was
	bedeutet, dass kein angepasster Kernel benötigt wird, um
	<application>IPFW</application> zu benutzen.</para>

      <indexterm>
	<primary>Kerneloptionen</primary>
	<secondary>IPFIREWALL</secondary>
      </indexterm>

      <indexterm>
	<primary>Kerneloptionen</primary>
	<secondary>IPFIREWALL_VERBOSE</secondary>
      </indexterm>

      <indexterm>
	<primary>Kerneloptionen</primary>
	<secondary>IPFIREWALL_VERBOSE_LIMIT</secondary>
      </indexterm>

      <indexterm>
	<primary><application>IPFW</application></primary>
	<secondary>Kerneloptionen</secondary>
      </indexterm>

      <para>Wenn Sie eine statische Unterstützung für
	<application>IPFW</application> in den Kernel kompilieren
	wollen, lesen Sie <xref linkend="kernelconfig"/>.  Folgende
	Optionen können in der Kernelkonfigurationsdatei verwendet
	werden:</para>

      <programlisting>options    IPFIREWALL			# enables IPFW
options    IPFIREWALL_VERBOSE		# enables logging for rules with log keyword
options    IPFIREWALL_VERBOSE_LIMIT=5	# limits number of logged packets per-entry
options    IPFIREWALL_DEFAULT_TO_ACCEPT	# sets default policy to pass what is not explicitly denied
options    IPDIVERT			# enables NAT</programlisting>

      <para>Um <application>IPFW</application> beim Systemstart zu
	aktivieren, fügen Sie folgende Zeile in
	<filename>/etc/rc.conf</filename> ein:</para>

      <programlisting>firewall_enable="YES"</programlisting>

      <para>Wenn Sie einen der von &os; zur Verfügung gestellten
	Firewall-Profile benutzen möchten, fügen Sie eine weitere
	Zeile hinzu, in der Sie das Profil bestimmen:</para>

      <programlisting>firewall_type="open"</programlisting>

      <para>Folgende Profile stehen zur Verfügung:</para>

      <itemizedlist>
	<listitem>
	  <para><literal>open</literal>: gestattet jeglichen
	    Datenverkehr.</para>
	</listitem>

	<listitem>
	  <para><literal>client</literal>: schützt lediglich diesen
	    Rechner.</para>
	</listitem>

	<listitem>
	  <para><literal>simple</literal>: schützt das gesamte
	    Netzwerk.</para>
	</listitem>

	<listitem>
	  <para><literal>closed</literal>: blockiert den gesamten
	    <acronym>IP</acronym>-Datenverkehr, mit Ausnahme des
	    Verkehrs über die Loopback-Schnittstelle.</para>
	</listitem>

	<listitem>
	  <para><literal>workstation</literal>: schützt lediglich
	    diesen Rechner und verwendet zustandsorientierte
	    Regeln.</para>
	</listitem>

	<listitem>
	  <para><literal>UNKNOWN</literal>: deaktiviert das Laden von
	    Firewallregeln.</para>
	</listitem>

	<listitem>
	  <para><filename><replaceable>filename</replaceable></filename>:
	    absoluter Pfad zu einer Datei, in der die Firewallregeln
	    definiert sind.</para>
	</listitem>
      </itemizedlist>

      <para>Wenn Sie <literal>firewall_type</literal> auf
	<literal>client</literal> oder <literal>simple</literal>
	setzen, müssen Sie die voreingestellten Regeln in
	<filename>/etc/rc.firewall</filename> anpassen, damit sie
	der Konfiguration des Systems entsprechen.</para>

      <para>Beachten Sie, dass das Profil <literal>filename</literal>
	verwendet wird, um ein benutzerdefiniertes Regelwerk zu
	laden.</para>

      <para>Eine alternative Möglichkeit, um ein benutzerdefiniertes
	Regelwerk zu laden, bietet die Variable
	<literal>firewall_script</literal>.  Setzen Sie die Variable
	auf den absoluten Pfad eines
	<emphasis>ausführbaren Skripts</emphasis>, welches die Befehle
	für <application>IPFW</application> enthält.  Die Beispiele in
	diesem Abschnitt gehen davon aus, dass
	<literal>firewall_script</literal> auf
	<filename>/etc/ipfw.rules</filename> gesetzt ist.</para>

      <programlisting>firewall_script="/etc/ipfw.rules"</programlisting>

      <para>Die Protokollierung wird mit diesem Eintrag
	aktiviert:</para>

      <programlisting>firewall_logging="YES"</programlisting>

      <para>Es existiert keine Variable für
	<filename>/etc/rc.conf</filename>, um die Protokollierung zu
	begrenzen.  Um die Anzahl der Protokoll-Nachrichten pro
	Verbindungsversuch zu begrenzen, legen Sie die Anzahl der
	Einträge in <filename>/etc/sysctl.conf</filename> fest:</para>

      <programlisting>net.inet.ip.fw.verbose_limit=5</programlisting>

      <para>Nachdem Sie die Änderungen gespeichert haben, können Sie
	die Firewall starten.  Um auch die Anzahl der
	Protokoll-Nachrichten zu konfigurieren, setzen Sie mit
	<command>sysctl</command> den gewünschten Wert:</para>

      <screen>&prompt.root; <userinput>service firewall start</userinput>
&prompt.root; <userinput>sysctl net.inet.ip.fw.verbose_limit=<replaceable>5</replaceable></userinput></screen>
    </sect2>

    <sect2 xml:id="firewalls-ipfw-rules">
      <title><application>IPFW</application> Regel-Syntax</title>

      <para>Wenn ein Paket die Firewall <quote>betritt</quote>, also
	von der Firewall geprüft und verarbeitet wird, wird die
	erste Regel des Regelwerkes auf das Paket angewandt.  Auf
	diese Weise wird in aufsteigender Reihenfolge der Regelnummer
	mit allen weiteren Regeln verfahren.  Falls die
	Selektionsparameter einer Regel auf ein Paket zutreffen, wird
	das Aktionsfeld der Regel ausgeführt und die Prüfung
	des Pakets beendet, nachfolgende Regeln werden also nicht
	mehr geprüft.  Diese Suchmethode wird als <quote>erster
	  Treffer gewinnt</quote> bezeichnet.  Falls keine Regel auf
	das betreffende Paket zutrifft, wird die obligatorische
	<application>IPFW</application>-Rückfallregel mit der Nummer
	65535 angewendet und das Paket wird ohne Rückantwort
	verworfen.  Wenn das Paket jedoch einer Regel mit dem
	Schlüsselwort <literal>count</literal>,
	<literal>skipto</literal> oder <literal>tee</literal>
	entspricht, wird die Prüfung des Pakets weiter
	fortgeführt.  Weitere Details darüber, wie diese
	Schlüsselwörter die Regelverarbeitung beeinflussen, finden Sie
	in &man.ipfw.8;.</para>

      <indexterm>
	<primary><application>IPFW</application></primary>
	<secondary>Regel-Syntax</secondary>
      </indexterm>

      <para>Bei der Erstellung der
	<application>IPFW</application>-Regeln müssen die
	Schlüsselwörter in der folgenden Reihenfolge geschrieben
	werden.  Einige Schlüsselwörter müssen zwingend angegeben
	werden, während andere optional sind.  Die Wörter in
	Großbuchstaben repräsentieren Variablen und die Wörter in
	Kleinbuchstaben müssen den Variablen vorangestellt werden.
	Das Zeichen <literal>#</literal> wird benutzt, um einen
	Kommentar einzuleiten und kann am Ende einer Regel oder in
	einer eigenen Zeile stehen.  Leerzeilen werden
	ignoriert.</para>

      <para><replaceable>CMD RULE_NUMBER set SET_NUMBER ACTION log
	  LOG_AMOUNT PROTO from SRC SRC_PORT to DST DST_PORT
	  OPTIONS</replaceable></para>

      <para>Dieser Abschnitt bietet einen Überblick über diese
	Schlüsselwörter und deren Optionen.  Es ist keine vollständige
	Liste aller verfügbaren Optionen.  Eine vollständige
	Beschreibung der Regel-Syntax, die Sie verwenden können um
	<application>IPFW</application>-Regeln zu erstellen, finden
	Sie in &man.ipfw.8;.</para>

      <variablelist>
	<varlistentry>
	  <term>CMD</term>
	  <listitem>
	    <para>Jede Regel muss mit <parameter>ipfw add</parameter>
	      beginnen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>RULE_NUMBER</term>
	  <listitem>
	    <para>Jede Regel gehört zu einer Nummer zwischen
	      <literal>1</literal> und <literal>65534</literal>.  Die
	      Nummer wird verwendet, um die Reihenfolge der
	      Regelverarbeitung zu kennzeichnen.  Es ist möglich, dass
	      mehrere Regeln dieselbe Nummer haben.  In diesem Fall
	      werden sie entsprechend der Reihenfolge angewendet, in
	      der sie aufgenommen wurden.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>SET_NUMBER</term>
	  <listitem>
	    <para>Jede Regel ist einer <emphasis>Set</emphasis>-Nummer
	      zwischen <literal>0</literal> und <literal>31</literal>
	      zugeordnet.  Sets können einzeln aktiviert oder
	      deaktiviert werden.  Dies macht es möglich, eine Reihe
	      von Regeln schnell hinzuzufügen oder zu löschen.  Wenn
	      <literal>SET_NUMBER</literal> nicht angegeben ist, wird
	      die Regel zu Set <literal>0</literal>
	      hinzugefügt.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>ACTION</term>
	  <listitem>
	    <para>Eine Regel kann mit einer der folgenden Aktionen
	      verknüpft werden.  Die festgelegte Aktion wird
	      ausgeführt, wenn das Paket den Selektionskriterien der
	      Regel entspricht.</para>

	    <para><parameter>allow | accept | pass |
		permit</parameter>: All diese Aktionen sind
	      gleichbedeutend und erlauben Pakete, die mit der Regel
	      übereinstimmen.</para>

	    <para><parameter>check-state</parameter>: Diese Aktion
	      überprüft die Regel in der dynamischen Zustandstabelle.
	      Bei einer Übereinstimmung wird die mit der dynamischen
	      Regel verknüpfte Aktion ausgeführt, andernfalls wird mit
	      der Prüfung gegen die nächste Regel fortgefahren.  Die
	      Regel <literal>check-state</literal> hat selbst kein
	      Selektionskriterium.  Sollte keine
	      <literal>check-state</literal>-Regel im Regelwerk
	      vorhanden sein, wird die dynamische Zustandstabelle beim
	      ersten Vorkommen einer <literal>keep-state</literal>-
	      oder <literal>limit</literal>-Regel überprüft.</para>

	    <para><parameter>count</parameter>: Aktualisiert die
	      Zähler für alle Pakete, die mit dieser Regel
	      übereinstimmen.  Die Prüfung wird mit der nächsten Regel
	      fortgesetzt.</para>

	    <para><parameter>deny | drop</parameter>: Diese Aktionen
	      sind gleichbedeutend und verwerfen Pakete, die mit
	      dieser Regel übereinstimmen.</para>

	    <para>Es stehen noch weitere Aktionen zur Verfügung.
	      Einzelheiten finden Sie in &man.ipfw.8;.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>LOG_AMOUNT</term>
	  <listitem>
	    <para>Erfüllt ein Paket die Selektionskriterien mit dem
	      Schlüsselwort <literal>log</literal>, wird dies von
	      &man.syslogd.8; mit der Annotation
	      <literal>SECURITY</literal> protokolliert.  Dies erfolgt
	      allerdings nur, wenn die Anzahl der protokollierten
	      Pakete der betreffenden Regel die definierte
	      <literal>LOG_AMOUNT</literal>-Grenze nicht übersteigt.
	      Wenn <literal>LOG_AMOUNT</literal> nicht definiert ist,
	      wird die Grenze aus dem Wert von
	      <varname>net.inet.ip.fw.verbose_limit</varname>
	      benutzt.  Ein Wert von <literal>0</literal> bedeutet
	      eine unbegrenzte Protokollierung.  Wird eine definierte
	      Grenze erreicht, wird die Protokollierung für diese
	      Regel deaktiviert.  Um die Protokollierung zu
	      reaktivieren, können Sie den Protokoll- oder Paketzähler
	      mit <command>ipfw resetlog</command>
	      zurücksetzen.</para>

	    <note>
	      <para>Die Protokollierung findet statt, nachdem alle
		Selektionskriterien geprüft und bevor die endgültige
		Aktion auf das Paket angewendet wird.  Der
		Administrator entscheidet, welche Regel protokolliert
		werden soll.</para>
	    </note>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>PROTO</term>
	  <listitem>
	    <para>Dieser optionale Wert wird verwendet, um einen
	      beliebigen Protokollnamen oder -nummer aus
	      <filename>/etc/protocols</filename> gegen das Paket zu
	      prüfen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>SRC</term>
	  <listitem>
	    <para>Nach dem Schlüsslwort<literal>from</literal> muss
	      die Quelladresse stehen, oder ein Schlüsselwort, das die
	      Quelladresse darstellt.  Eine Adresse wird dargestellt
	      duch <literal>any</literal>, <literal>me</literal> (jede
	      Adresse dieses Systems), <literal>me6</literal> (jede
	      <acronym>IPv6</acronym>-Adresse dieses Systems), oder
	      <literal>table</literal> gefolgt von der Nummer der
	      Tabelle, welche die Adressen enthält.
	      <acronym>IP</acronym>-Adressen können in
	      <acronym>CIDR</acronym>-Notation geschrieben werden.
	      Beispielsweise <literal>1.2.3.4/25</literal> oder
	      <literal>1.2.3.4:255.255.255.128</literal>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>SRC_PORT</term>
	  <listitem>
	    <para>Optional kann ein Quellport über eine Nummer oder
	      einen Namen aus <filename>/etc/services</filename>
	      spezifiziert werden.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>DST</term>
	  <listitem>
	    <para>Nach dem Schlüsselwort <literal>to</literal> muss
	      die Zieladresse stehen, oder ein Schlüsselwort, das die
	      Zieladresse darstellt.  Es können die gleichen
	      Schlüsselwörter und Adressen benutzt werden, die bereits
	      im SRC-Abschnitt beschrieben wurden.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>DST_PORT</term>
	  <listitem>
	    <para>Optional kann ein Zielport über eine Nummer oder
	      einen Namen aus <filename>/etc/services</filename>
	      spezifiziert werden.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>OPTIONS</term>
	  <listitem>
	    <para>Nach der Quell- und Zieladresse können noch weitere
	      Optionen angegeben werden.  Wie der Name bereits sagt,
	      sind <literal>OPTIONS</literal> optional.  Häufig
	      verwendete Optionen sind <literal>in</literal> oder
	      <literal>out</literal>, mit denen die Richtug des
	      Pakets bestimmt wird, <literal>icmptypes</literal>
	      gefolgt vom Typ der <acronym>ICMP</acronym>-Nachricht,
	      sowie <literal>keep-state</literal>.</para>

	    <para>Wenn ein Paket auf eine
	      <parameter>keep-state</parameter>-Regel zutrifft, wird
	      die Firewall eine dynamische Regel erstellen, die dem
	      bidirektionalen Datenverkehr zwischen den gleichen
	      Quell- und Zieladressen mit dem gleichen Protokoll
	      entspricht.</para>

	    <para>Dynamische Regeln sind für einen sogenannten
	      <foreignphrase>SYN-flood</foreignphrase>-Angriff
	      anfällig, bei dem eine riesige Anzahl an dynamischen
	      Regeln erzeugt wird.  Verwenden Sie die Option
	      <literal>limit</literal>, um einen solchen Angriff
	      entgegenzuwirken.  Diese Option begrenzt die Anzahl
	      der gleichzeitig möglichen Sitzungen.  Es handelt sich
	      dabei um einen Zähler, der die Anzahl von dynamischen
	      Regeln in Kombination mit der Quelladresse verfolgt.
	      Übersteigt der Zähler den durch <literal>limit</literal>
	      definierten Wert, wird das Paket verworfen.</para>

	    <para>Es stehen noch viele weitere Optionen zur Verfügung.
	      &man.ipfw.8; enthält eine Beschreibung der einzelnen
	      Optionen.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2>
      <title>Beispiel für einen Regelsatz</title>

      <para>Dieser Abschnitt die Erstellung eines Firewall-Skripts
	namens <filename>/etc/ipfw.rules</filename> mit
	zustandsorientierten (<foreignphrase>stateful</foreignphrase>
	Regeln.  Alle Regeln in diesem Beispiel verwenden die Optionen
	<literal>in</literal> und <literal>out</literal>, um die
	Richtung des Pakets zu verdeutlichen.  Zusätzlich wird
	<literal>via</literal>
	<replaceable>interface-name</replaceable> benutzt, um die
	Schnittstelle für das Paket zu prüfen.</para>

      <note>
	<para>Bei den anfänglichen Tests mit dem Firewall-Regelsatz
	  sollten Sie vielleicht folgende Einstellung
	  vornehmen:</para>

	<programlisting>net.inet.ip.fw.default_to_accept="1"</programlisting>

	<para>Dies legt die Standardregel von &man.ipfw.8; etwas
	  großzügiger fest, als das voreingestellte
	  <literal>default deny ip from any to any</literal>.  Dadurch
	  sinkt die Gefahr, sich nach einem Neustart des Systems
	  auszusperren.</para>
      </note>

      <para>Das Firewall-Skript beginnt mit einem Hinweis, dass es
	sich um ein Bourne Shell-Skript handelt.  Danach werden alle
	vorhandenen Filterregeln gelöscht.  Anschließend wird die
	Variable <literal>cmd</literal> erstellt, sodass
	<literal>ipfw add</literal> nicht jedes mal von Hand
	eingegeben werden muss.  Die Variable <literal>pif</literal>
	repräsentiert die mit dem Internet verbundene
	Schnittstelle.</para>

      <programlisting>#!/bin/sh
# Flush out the list before we begin.
ipfw -q -f flush

# Set rules command prefix
cmd="ipfw -q add"
pif="dc0"     # interface name of NIC attached to Internet</programlisting>

      <para>Jetzt folgen die eigentlichen Filterregeln.  Diese ersten
	beiden Regeln erlauben den Datenverkehr aus dem internen
	Netzwerk und über die Loopback-Schnittstelle:</para>

      <programlisting># Change xl0 to LAN NIC interface name
&dollar;cmd 00005 allow all from any to any via xl0

# No restrictions on Loopback Interface
&dollar;cmd 00010 allow all from any to any via lo0</programlisting>

      <para>Die nächste Regel erlaubt Pakete, für die ein Eintrag
	in der dynamischen Zustandstabelle existiert:</para>

      <programlisting>&dollar;cmd 00101 check-state</programlisting>

      <para>Die nächsten Regeln definieren, welche internen Rechner
	Verbindungen zu anderen Rechnern im Internet aufbauen dürfen.
	Hier werden wieder zustandsorientierte Regeln
	verwendet:</para>

      <programlisting># Allow access to public DNS
# Replace x.x.x.x with the IP address of a public DNS server
# and repeat for each DNS server in /etc/resolv.conf
&dollar;cmd 00110 allow tcp from any to x.x.x.x 53 out via &dollar;pif setup keep-state
&dollar;cmd 00111 allow udp from any to x.x.x.x 53 out via &dollar;pif keep-state

# Allow access to ISP's DHCP server for cable/DSL configurations.
# Use the first rule and check log for IP address.
# Then, uncomment the second rule, input the IP address, and delete the first rule
&dollar;cmd 00120 allow log udp from any to any 67 out via &dollar;pif keep-state
#&dollar;cmd 00120 allow udp from any to x.x.x.x 67 out via &dollar;pif keep-state

# Allow outbound HTTP and HTTPS connections
&dollar;cmd 00200 allow tcp from any to any 80 out via &dollar;pif setup keep-state
&dollar;cmd 00220 allow tcp from any to any 443 out via &dollar;pif setup keep-state

# Allow outbound email connections
&dollar;cmd 00230 allow tcp from any to any 25 out via &dollar;pif setup keep-state
&dollar;cmd 00231 allow tcp from any to any 110 out via &dollar;pif setup keep-state

# Allow outbound ping
&dollar;cmd 00250 allow icmp from any to any out via &dollar;pif keep-state

# Allow outbound NTP
&dollar;cmd 00260 allow udp from any to any 123 out via &dollar;pif keep-state

# Allow outbound SSH
&dollar;cmd 00280 allow tcp from any to any 22 out via &dollar;pif setup keep-state

# deny and log all other outbound connections
&dollar;cmd 00299 deny log all from any to any out via &dollar;pif</programlisting>

      <para>Die folgenden Regeln steuern die Verbindungen von
	Rechern aus dem Internet ins interne Netzwerk.  Zuerst werden
	Pakete verworfen, die typischerweise im Zusammenhang mit
	Angriffen stehen.  Danach werden bestimmte Arten von
	Verbindungen erlaubt.  Alle Dienste aus dem öffentlichen
	Internet beinhalten die Option <literal>limit</literal>, um
	<foreignphrase>Flooding</foreignphrase> zu unterbinden.</para>

      <programlisting># Deny all inbound traffic from non-routable reserved address spaces
&dollar;cmd 00300 deny all from 192.168.0.0/16 to any in via &dollar;pif     #RFC 1918 private IP
&dollar;cmd 00301 deny all from 172.16.0.0/12 to any in via &dollar;pif      #RFC 1918 private IP
&dollar;cmd 00302 deny all from 10.0.0.0/8 to any in via &dollar;pif         #RFC 1918 private IP
&dollar;cmd 00303 deny all from 127.0.0.0/8 to any in via &dollar;pif        #loopback
&dollar;cmd 00304 deny all from 0.0.0.0/8 to any in via &dollar;pif          #loopback
&dollar;cmd 00305 deny all from 169.254.0.0/16 to any in via &dollar;pif     #DHCP auto-config
&dollar;cmd 00306 deny all from 192.0.2.0/24 to any in via &dollar;pif       #reserved for docs
&dollar;cmd 00307 deny all from 204.152.64.0/23 to any in via &dollar;pif    #Sun cluster interconnect
&dollar;cmd 00308 deny all from 224.0.0.0/3 to any in via &dollar;pif        #Class D &amp; E multicast

# Deny public pings$
&dollar;cmd 00310 deny icmp from any to any in via &dollar;pif$
$
# Deny ident$
&dollar;cmd 00315 deny tcp from any to any 113 in via &dollar;pif$
$
# Deny all Netbios services.$
&dollar;cmd 00320 deny tcp from any to any 137 in via &dollar;pif$
&dollar;cmd 00321 deny tcp from any to any 138 in via &dollar;pif$
&dollar;cmd 00322 deny tcp from any to any 139 in via &dollar;pif$
&dollar;cmd 00323 deny tcp from any to any 81 in via &dollar;pif$

# Deny fragments
&dollar;cmd 00330 deny all from any to any frag in via &dollar;pif

# Deny ACK packets that did not match the dynamic rule table
&dollar;cmd 00332 deny tcp from any to any established in via &dollar;pif

# Allow traffic from ISP's DHCP server.
# Replace x.x.x.x with the same IP address used in rule 00120.
#&dollar;cmd 00360 allow udp from any to x.x.x.x 67 in via &dollar;pif keep-state

# Allow HTTP connections to internal web server
&dollar;cmd 00400 allow tcp from any to me 80 in via &dollar;pif setup limit src-addr 2

# Allow inbound SSH connections
&dollar;cmd 00410 allow tcp from any to me 22 in via &dollar;pif setup limit src-addr 2

# Reject and log all other incoming connections
&dollar;cmd 00499 deny log all from any to any in via &dollar;pif</programlisting>

      <para>Die letzte Regel protokolliert alle Pakete, die mit
	keiner Regel im Regelsatz übereinstimmen:</para>

      <programlisting># Everything else is denied and logged
&dollar;cmd 00999 deny log all from any to any</programlisting>
    </sect2>

    <sect2 xml:id="network-natd">
      <info>
	<title><acronym>NAT</acronym> Konfiguration</title>

	<authorgroup>
	  <author>
	    <personname>
	      <firstname>Chern</firstname>
	      <surname>Lee</surname>
	    </personname>
	    <contrib>Beigetragen von </contrib>
	  </author>
	</authorgroup>
      </info>

      <indexterm>
	<primary>NAT</primary>
	<secondary>und <application>IPFW</application></secondary>
      </indexterm>

      <para>&os;s integrierter <acronym>NAT</acronym>-Daemon,
	&man.natd.8;, arbeitet in Verbindung mit
	<application>IPFW</application>, um
	<foreignphrase>Network Address Translation</foreignphrase>
	bereitzustellen.  <acronym>NAT</acronym> wird verwendet, um
	mehreren internen Rechnern, über eine einzige
	<acronym>IP</acronym>-Adresse, eine gemeinsame Verbindung zum
	Internet zu ermöglichen.</para>

      <para>Um dies zu tun, muss der mit dem Internet verbundene
	&os;-Rechner als Gateway eingerichtet sein.  Das System muss
	über zwei Netzwerkschnittstellen verfügen, wobei eine
	Schnittstelle mit dem Internet verbunden ist und die andere
	mit dem internen Netzwerk.  Jeder Rechner im internen Netzwerk
	sollte eine <link
	  xlink:href="ftp://ftp.isi.edu./in-notes/rfc1918.txt">RFC
	  1918</link> konforme Adresse zugewiesen bekommen.  Zudem
	muss das Standard-Gateway der Rechner auf die interne
	<acronym>IP</acronym>-Adresse des &man.natd.8;-Systems
	gesetzt werden.</para>

      <para>Es ist noch ein wenig Konfiguration nötig, um die
	<acronym>NAT</acronym>-Funktion von
	<application>IPFW</application> zu aktivieren.  Wenn das
	System einen angepassten Kernel hat, muss die
	Kernelkonfigurationsdatei die Zeile
	<literal>option IPDIVERT</literal> sowie weitere
	<literal>IPFIREWALL</literal>-Optionen, die in <xref
	  linkend="firewalls-ipfw-enable"/> beschrieben sind,
	enthalten.</para>

      <para>Um die <acronym>NAT</acronym>-Unterstützung beim Booten
	zu aktivieren, müssen folgende Einträge in
	<filename>/etc/rc.conf</filename> vorhanden sein:</para>

      <programlisting>gateway_enable="YES"		# enables the gateway
natd_enable="YES"		# enables <acronym>NAT</acronym>
natd_interface="rl0"		# specify interface name of NIC attached to Internet
natd_flags="-dynamic -m"	# -m = preserve port numbers; additional options are listed in &man.natd.8;</programlisting>

      <note>
	<para>Es ist auch möglich eine Konfigurationsdatei zu
	  verwenden, welche die Optionen enthält, die an
	  &man.natd.8; übergeben werden:</para>

	<programlisting>natd_flags="-f /etc/natd.conf"</programlisting>

	<para>Die angegebene Datei muss die Konfigurationsoptionen
	  enthalten, eine Option pro Zeile.  Zum Beispiel:</para>

	<programlisting>redirect_port tcp 192.168.0.2:6667 6667
redirect_port tcp 192.168.0.3:80 80</programlisting>

	<para>Weitere Informationen zu dieser Konfigurationsdatei
	  finden Sie in &man.natd.8;.</para>
      </note>

      <para>Als nächstes werden die <acronym>NAT</acronym>-Regeln
	hinzugefügt.  Wenn die Regeln zustandsorientiert sind, ist die
	Platzierung der <acronym>NAT</acronym>-Regeln sehr wichtig und
	die <literal>skipto</literal>-Aktion wird verwendet.  Dies
	erfordert, dass jede Regel über eine eindeutige Nummer
	verfügt, um eindeutige Sprungziele zu erhalten.</para>

      <para>Das folgende Beispiel baut auf dem im vorherigen Abschnitt
	gezeigten Firewall-Relgelsatz auf.  Es werden einige neue
	Einträge hinzugefügt und bestehende Regeln modifiziert, um
	<acronym>NAT</acronym> zu konfigurieren.  Zunächst werden
	einige Variablen hinzugefügt, darunter Regelnummern, die
	<literal>keep-state</literal>-Option und eine Liste mit
	<acronym>TCP</acronym>-Ports um die Anzahl der Regeln zu
	reduzieren:</para>

      <programlisting>#!/bin/sh
ipfw -q -f flush
cmd="ipfw -q add"
skip="skipto 500"
pif=dc0
ks="keep-state"
good_tcpo="22,25,37,53,80,443,110"</programlisting>

      <para>Die <acronym>NAT</acronym>-Regel für eingehende Pakete
	wird <emphasis>nach</emphasis> den beiden Regeln, die das
	interne Netzwerk und die Loopback-Schnittstelle erlauben und
	<emphasis>vor</emphasis> der
	<literal>check-state</literal>-Regel eingefügt.  Es ist
	wichtig, dass die Nummer der <acronym>NAT</acronym>-Regel
	(in diesem Beispiel <literal>100</literal>) höher ist, als
	die beiden vorherigen Regeln und niedriger, als die
	<literal>check-state</literal>-Regel:</para>

      <programlisting>&dollar;cmd 005 allow all from any to any via xl0  # exclude LAN traffic
&dollar;cmd 010 allow all from any to any via lo0  # exclude loopback traffic
&dollar;cmd 100 divert natd ip from any to any in via &dollar;pif # NAT any inbound packets
# Allow the packet through if it has an existing entry in the dynamic rules table
&dollar;cmd 101 check-state</programlisting>

      <para>Die Regeln für den ausgehenden Verkehr werden ebenfalls
	modifiziert, um Aktionen mit der
	<literal>&dollar;skipto</literal>-Variable zu erlauben und
	anzuzeigen, dass die Prüfung mit der Regel
	<literal>500</literal> fortgesetzt wird.  Die sieben Regeln
	für <acronym>TCP</acronym> wurden durch die Regel
	<literal>125</literal> ersetzt, da die sieben erlaubten
	ausgehenden Ports in der Variable
	<literal>&dollar;good_tcp0</literal> enthalten sind.</para>

      <programlisting># Authorized outbound packets
&dollar;cmd 120 &dollar;skip udp from any to x.x.x.x 53 out via &dollar;pif &dollar;ks
&dollar;cmd 121 &dollar;skip udp from any to x.x.x.x 67 out via &dollar;pif &dollar;ks
&dollar;cmd 125 &dollar;skip tcp from any to any &dollar;good_tcpo out via &dollar;pif setup &dollar;ks
&dollar;cmd 130 &dollar;skip icmp from any to any out via &dollar;pif &dollar;ks</programlisting>

      <para>Die eingehenden Regeln bleiben unverändert, mit Ausnahme
	der letzten Regel, in der das
	<literal>via &dollar;pif</literal> entfert wird, um ein- und
	ausgehende Pakete prüfen zu können.  Nach der letzten Regel
	für ausgehende Pakete muss die <acronym>NAT</acronym>-Regel
	folgen.  Die Regel muss eine höhere Nummer als die letzte
	Regel haben und die Nummer muss über die
	<literal>skipto</literal>-Aktion referenziert werden.  In
	diesem Regelsatz leitet die Regel mit der Nummer
	<literal>500</literal> alle ausgehenden Pakete zur
	Weiterverarbeitung an &man.natd.8; weiter.  Die darauf
	folgende Regel lässt alle von <acronym>NAT</acronym>
	verarbeiteten Pakete passieren.</para>

      <programlisting>&dollar;cmd 499 deny log all from any to any
&dollar;cmd 500 divert natd ip from any to any out via &dollar;pif # skipto location for outbound stateful rules
&dollar;cmd 510 allow ip from any to any</programlisting>

      <para>In diesem Beispiel steuern die Regeln
	<literal>100</literal>, <literal>101</literal>,
	<literal>125</literal>, <literal>500</literal> und
	<literal>510</literal> die Adressübersetzung der ein- und
	ausgehende Pakete, so dass immer die private
	<acronym>LAN</acronym> <acronym>IP</acronym>-Adresse in der
	dynamische Zustandstabelle registriert werden.</para>

      <para>Nehmen wir beispielsweise einen Web-Browser, der neue
	<acronym>HTTP</acronym>-Sitzungen über Port 80 aufbaut.  Wenn
	nun das erste ausgehende Paket von der Firewall geprüft wird,
	trifft es nicht auf Regel <literal>100</literal> zu, da das
	Paket nach außen geleitet wird und nicht nach innen.  Das
	Paket trifft auch nicht auf Regel <literal>101</literal> zu,
	da es das erste ist und somit noch nicht in der dynamischen
	Zustandstabelle enthalten ist.  Das Paket entspricht
	schließlich Regel <literal>125</literal>, da es ausgehend auf
	einem erlaubten Port gesendet wird und von einer
	<acronym>IP</acronym>-Adresse aus dem internen
	<acronym>LAN</acronym> stammt.  Für Pakete, die auf diese
	Regel zutreffen, werden zwei Aktionen ausgeführt.  Zuerst
	wird durch die Aktion <literal>keep-state</literal> ein
	dynamischer Eintrag in der Statustabelle erstellt und die
	angegebene Aktion <literal>skipto 500</literal> ausgeführt.
	Als nächstes durchläuft das Paket <acronym>NAT</acronym> und
	wird dann an das Internet gesendet.  Nachdem dieses Paket am
	Webserver angekommen ist, wird dort eine Antwort erzeugt und
	zurückgeschickt.  Dieses Paket wird wieder von oben nach unten
	durch das Regelwerk geprüft.  Dieses Mal trifft Regel
	<literal>100</literal> auf das Paket zu und die Zieladresse
	wird auf die zugehörige (lokale)
	<acronym>LAN</acronym>-Adresse abgebildet.  Danach wird das
	Paket von der Regel <literal>check-state</literal>
	verarbeitet.  Die Zustandstabelle erkennt, dass eine
	zugehörige aktive Sitzung vorliegt und das Paket wird
	freigegeben und in das <acronym>LAN</acronym> geleitet.</para>

      <para>Für den eingehenden Datenverkehr muss der Regelsatz
	unerwünschte Pakete blockieren und Pakete für autorisierte
	Dienste durchlassen.  Ein Paket, das mit einer Regel für den
	eingehenden Datenverkehr übereinstimmt, wird in der
	dynamischen Zustandstabelle eingetragen und dann an das
	<acronym>LAN</acronym> freigegeben.  Das Antwortpaket wird
	von der Regel <literal>check-state</literal> als Paket einer
	aktiven Sitzung erkannt.  Das Paket wird dann von Regel
	<literal>500</literal> per <acronym>NAT</acronym>
	verarbeitet, bevor es über die externe Schnittstelle versendet
	wird.</para>

      <sect3>
	<title>Weiterleitung von Ports</title>

	<para>Der Nachteil von &man.natd.8; ist, dass die Rechner im
	  <acronym>LAN</acronym> nicht aus dem Internet zugänglich
	  sind.  Diese Rechner können zwar ausgehende Verbindungen
	  zur Außenwelt aufbauen, jedoch keine eingehenden
	  Verbindungen empfangen.  Dies stellt ein Problem dar, wenn
	  Sie auf einem Rechner im <acronym>LAN</acronym> Dienste
	  anbieten möchten, die aus dem Internet erreichbar sein
	  sollen.  In diesem Fall können Sie die Ports, welche über
	  das Internet erreichbar sein sollen, über die
	  &man.natd.8;-Maschine an den Rechner im
	  <acronym>LAN</acronym> weiterleiten.</para>

	<para>Angenommen es gibt einen <acronym>IRC</acronym>-Server
	  auf Rechner <systemitem>A</systemitem> und einen Webserver
	  auf Rechner <systemitem>B</systemitem>.  Damit dies
	  funktioniert, müssen die Verbindungen auf den Ports 6667
	  (<acronym>IRC</acronym>) und 80 (<acronym>HTTP</acronym>)
	  an die jeweiligen Rechner weitergeleitet werden.</para>

	<para>Die Syntax für <option>-redirect_port</option>
	  lautet:</para>

	<programlisting>-redirect_port proto targetIP:targetPORT[-targetPORT]
                 [aliasIP:]aliasPORT[-aliasPORT]
                 [remoteIP[:remotePORT[-remotePORT]]]</programlisting>

	<para>Für das obige Beispiel sollten die Argumente wie folgt
	  aussehen:</para>

	<programlisting>-redirect_port tcp 192.168.0.2:6667 6667
-redirect_port tcp 192.168.0.3:80 80</programlisting>

	<para>Damit werden die entsprechenden
	  <acronym>TCP</acronym>-Ports an die Rechner im
	  <acronym>LAN</acronym> weitergeleitet.</para>

	<para>Portbereiche können über <option>-redirect_port</option>
	  festgelegt werden.  Zum Beispiel würde
	  <replaceable>tcp 192.168.0.2:2000-3000
	    2000-3000</replaceable> alle Verbindungen auf die Ports
	  2000 bis 3000 an die Ports 2000 bis 3000 an
	  Rechner <systemitem>A</systemitem> weiterleiten.</para>

	<para>Diese Optionen können über
	  <literal>natd_flags=""</literal> in
	  <filename>/etc/rc.conf</filename> direkt beim Start an
	  &man.natd.8; übergeben werden.  Alternativ können die
	  Optionen in eine Konfigurationsdatei eingetragen
	  werden.</para>

	<para>Weitere Konfigurationsmöglichkeiten sind in
	  &man.natd.8; beschrieben.</para>
      </sect3>

      <sect3>
	<title>Weiterleiten von Adressen</title>

	<para>Das Weiterleiten von Adressen ist nützlich, wenn
	  mehr als eine <acronym>IP</acronym>-Adresse zur Verfügung
	  steht.  Jeder Rechner im <acronym>LAN</acronym> kann über
	  &man.natd.8; seine eigene externe
	  <acronym>IP</acronym>-Adresse zugewiesen bekommen.
	  &man.natd.8; wird dann den ausgehenden Datenverkehr der
	  Rechner aus dem <acronym>LAN</acronym> mit der
	  entsprechenden externen <acronym>IP</acronym>-Adresse
	  umschreiben.  Auch der eingehenden Datenverkehr über die
	  externe <acronym>IP</acronym>-Adresse wird an die
	  entsprechenden Rechner im <acronym>LAN</acronym>
	  weitergeleitet.  Diese Methode ist auch als
	  statisches <acronym>NAT</acronym> bekannt.  Wenn Ihnen
	  beispielsweise die <acronym>IP</acronym>-Adressen
	  <systemitem class="ipaddress">128.1.1.1</systemitem>,
	  <systemitem class="ipaddress">128.1.1.2</systemitem> und
	  <systemitem class="ipaddress">128.1.1.3</systemitem> zur
	  Verfügung stehen, kann <systemitem
	    class="ipaddress">128.1.1.1</systemitem> als externe
	  Adresse der &man.natd.8;-Maschine verwendet werden, während
	  <systemitem class="ipaddress">128.1.1.2</systemitem> und
	  <systemitem class="ipaddress">128.1.1.3</systemitem> an
	  Rechner <systemitem>A</systemitem> und
	  Rechner <systemitem>B</systemitem> im <acronym>LAN</acronym>
	  weitergeleitet werden.</para>

	<para>Die Syntax für <option>-redirect_address</option>
	  lautet:</para>

	<programlisting>-redirect_address localIP publicIP</programlisting>

	<informaltable frame="none" pgwide="1">
	  <tgroup cols="2">
	    <tbody>
	      <row>
		<entry>localIP</entry>
		<entry>Die interne <acronym>IP</acronym>-Adresse des
		  Rechners im <acronym>LAN</acronym>.</entry>
	      </row>

	      <row>
		<entry>publicIP</entry>
		<entry>Die externe <acronym>IP</acronym>-Adresse für
		  den entsprechenden Rechner im
		  <acronym>LAN</acronym>.</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

	<para>Für das obige Beispiel sollten die Argumente wie
	  folgt aussehen:</para>

	<programlisting>-redirect_address 192.168.0.2 128.1.1.2
-redirect_address 192.168.0.3 128.1.1.3</programlisting>

	<para>Genau wie bei <option>-redirect_port</option>, werden
	  diese Argumente innerhalb der
	  <filename>/etc/rc.conf</filename>-Option
	  <literal>natd_flags=""</literal> angegeben, oder alternativ
	  über eine Konfigurationsdatei.  Allerdings müssen beim
	  Weiterleiten von Adressen keine Ports umgeleitet werden, da
	  der gesamte eingehende Datenverkehr einer bestimmte
	  <acronym>IP</acronym>-Adresse weitergeleitet wird.</para>

	<para>Die externe <acronym>IP</acronym>-Adresse der
	  &man.natd.8;-Maschine muss auf der externen Schnittstelle
	  aktiv und mit einem Alias versehen sein.  Weitere
	  Einzelheiten sind in &man.natd.8; beschrieben.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="firewalls-ipfw-cmd">
      <title>Das <application>IPFW</application> Kommando</title>

      <indexterm>
	<primary><command>ipfw</command></primary>
      </indexterm>

      <para><command>ipfw</command> kann benutzt werden, um einzelne
	Regeln im laufenden Betrieb hinzuzufügen oder zu entfernen.
	Problematisch ist jedoch, dass diese Änderungen bei einem
	Neustart des Systems verloren gehen.  Daher ist es
	empfehlenswert, eigene Regeln in einer Datei zu definieren
	und diese zu laden, um die Regeln der Firewall im laufenden
	Betrieb anzupassen.</para>

      <para><command>ipfw</command> ist auch hilfreich, um die
	geladenen Regeln der auf der Konsole auszugeben.
	<application>IPFW</application> erzeugt dynamisch einen
	Zähler, der jedes Paket, auf das eine Regel zutrifft, zählt.
	Dadurch ist es möglich, die Funktion einer Regel zu
	überprüfen.</para>

      <para>Eine Auflistung aller geladenen Regeln erhalten Sie
	mit:</para>

      <screen>&prompt.root; <userinput>ipfw list</userinput></screen>

      <para>Eine Auflistung aller Regeln inklusive des letzten
	Treffers erhalten Sie mit:</para>

      <screen>&prompt.root; <userinput>ipfw -t list</userinput></screen>

      <para>Das nächste Beispiel zeigt Informationen über die Anzahl
	der Pakete, die von einer Regel gefiltert wurden sowie die
	Regel selbst.  Der erste Spalte zeigt die Nummer der
	Regel, gefolgt von der Anzahl der gefilterten Pakete
	und der Anzahl der Pakete in Bytes.  Zum Schluss steht die
	Regel selbst:</para>

      <screen>&prompt.root; <userinput>ipfw -a list</userinput></screen>

      <para>Das folgende Kommando zeigt zusätzlich alle dynamischen
	Regeln an:</para>

      <screen>&prompt.root; <userinput>ipfw -d list</userinput></screen>

      <para>Um diese Auflistung um die <quote>abgelaufenen</quote>
	Regeln zu erweitern, geben Sie folgendes Kommando ein:</para>

      <screen>&prompt.root; <userinput>ipfw -d -e list</userinput></screen>

      <para>Hiermit werden alle Zähler auf Null zurückgesetzt:</para>

      <screen>&prompt.root; <userinput>ipfw zero</userinput></screen>

      <para>Es ist auch möglich, einen spezifischen Zähler
	zurückzusetzen:</para>

      <screen>&prompt.root; <userinput>ipfw zero NUM</userinput></screen>

      <sect3>
	<title>Protokollierung von Firewall-Nachrichten</title>

	<para>Auch bei aktivierter Protokollierung wird
	  <application>IPFW</application> von selbst keine Regeln
	  protokollieren.  Der Administrator muss entscheiden, welche
	  Regeln aus dem Regelwerk protokolliert werden sollen.  In
	  diesen Regeln muss dann das Schlüsselwort
	  <literal>log</literal> hinzugefügt werden.  Normalerweise
	  werden nur geblockte Pakete protokolliert.  Es ist üblich,
	  die <quote>ipfw default deny everything</quote>-Regel am
	  Ende des Regelwerks mit dem Schlüsselwort
	  <literal>log</literal> zu duplizieren.  Dadurch ist es
	  möglich, alle Pakete zu sehen, auf die keine Regel
	  zutraf.</para>

	<para>Protokollierung ist allerdings ein zweischneidiges
	  Schwert.  Bei mangelnder Vorsicht oder einem DoS-Angriff
	  wird die Festplatte mit einer enormen Flut von
	  Protokolldaten belastet.  Protokoll-Nachrichten werden nicht
	  nur an &man.syslogd.8; geschickt, sondern auch auf der
	  Konsole angezeigt, was dann schnell lästig werden
	  kann.</para>

	<para>Die Kerneloption
	  <literal>IPFIREWALL_VERBOSE_LIMIT=5</literal> begrenzt die
	  Anzahl identischer Nachrichten an &man.syslogd.8; für eine
	  gegebene Regel auf fünf Nachrichten.  Ist diese Option im
	  Kernel aktiviert, wird nach Erreichen den festgelegten
	  Anzahl die Protokollierung von aufeinanderfolgenden
	  Nachrichten auf den festgelegten Wert begrenzt, da
	  beispielsweise die Speicherung von 200 gleichen
	  Protokoll-Nachrichten sinnlos ist.  Daher werden durch
	  diese Option nur fünf gleichartige Nachrichten
	  protokolliert.  Alle weiteren Nachrichten werden nur gezählt
	  und deren Gesamtzahl wird schließlich von &man.syslogd.8;
	  wie folgt ausgegeben:</para>

	<programlisting>Last message repeated 45 times</programlisting>

	<para>Alle protokollierten Pakete werden in der Voreinstellung
	  in <filename>/var/log/security</filename> gespeichert.  Dies
	  wird in <filename>/etc/syslog.conf</filename>
	  definiert.</para>
      </sect3>

      <sect3 xml:id="firewalls-ipfw-rules-script">
	<title>Ein Firewall-Regelwerk erstellen</title>

	<para>Die meisten fortgeschrittenen
	  <application>IPFW</application>-Benutzer erzeugen eine
	  Datei, welche die Regeln für die Firewall enthält, um diese
	  als Skript ausführen zu können.  Der Vorteil einer
	  derartigen Konfiguration besteht darin, dass dadurch mehrere
	  Regeln gleichzeitig geändert und aktiviert werden können,
	  ohne dass dazu das System neu gestartet werden muss.  Dies
	  ist zudem beim Testen von Regeländerungen sehr hilfreich.
	  Weil es sich bei der Datei um ein Skript handelt, ist es
	  auch möglich, häufig verwendete Befehle durch Aliase zu
	  ersetzen und diese dann in mehreren Regeln zu nutzen.</para>

	<para>Die Syntax des folgenden Skripts entspricht der Syntax
	  von &man.sh.1;, &man.csh.1; sowie &man.tcsh.1;.  Felder, die
	  symbolisch substituiert werden, haben das Präfix &dollar;
	  (Dollarzeichen).  Symbolische Felder haben das
	  &dollar;-Präfix nicht.  Der Wert, mit dem das symbolische
	  Feld belegt wird, muss in doppelten Anführungszeichen
	  ("") stehen.</para>

	<para>Die Datei mit den Regeln könnte wie folgt aufgebaut
	  sein:</para>

	<programlisting>############### start of example ipfw rules script #############
#
ipfw -q -f flush       # Delete all rules
# Set defaults
oif="tun0"             # out interface
odns="192.0.2.11"      # ISP's DNS server IP address
cmd="ipfw -q add "     # build rule prefix
ks="keep-state"        # just too lazy to key this each time
&dollar;cmd 00500 check-state
&dollar;cmd 00502 deny all from any to any frag
&dollar;cmd 00501 deny tcp from any to any established
&dollar;cmd 00600 allow tcp from any to any 80 out via &dollar;oif setup &dollar;ks
&dollar;cmd 00610 allow tcp from any to &dollar;odns 53 out via &dollar;oif setup &dollar;ks
&dollar;cmd 00611 allow udp from any to &dollar;odns 53 out via &dollar;oif &dollar;ks
################### End of example ipfw rules script ############</programlisting>

	<para>Die Regeln in diesem Beispiel sind nicht wichtig.
	  Wichtig ist es, zu zeigen, wie die symbolische Substitution
	  innerhalb der Regeln verwendet wird.</para>

	<para>Wenn dieses Beispiel in
	  <filename>etc/ipfw.rules</filename> gespeichert wurde, so
	  könnten alle Regeln durch die Ausführung des folgenden
	  Kommandos neu geladen werden:</para>

	<screen>&prompt.root; <userinput>sh /etc/ipfw.rules</userinput></screen>

	<para>Anstelle von <filename>/etc/ipfw.rules</filename> kann
	  ein beliebig anderer Name oder Speicherort verwendet
	  werden.</para>

	<para>Alternativ können die einzelnen Befehle dieses Skripts
	  auch von Hand eingegeben werden:</para>

	<screen>&prompt.root; <userinput>ipfw -q -f flush</userinput>
&prompt.root; <userinput>ipfw -q add check-state</userinput>
&prompt.root; <userinput>ipfw -q add deny all from any to any frag</userinput>
&prompt.root; <userinput>ipfw -q add deny tcp from any to any established</userinput>
&prompt.root; <userinput>ipfw -q add allow tcp from any to any 80 out via tun0 setup keep-state</userinput>
&prompt.root; <userinput>ipfw -q add allow tcp from any to 192.0.2.11 53 out via tun0 setup keep-state</userinput>
&prompt.root; <userinput>ipfw -q add 00611 allow udp from any to 192.0.2.11 53 out via tun0 keep-state</userinput></screen>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="firewalls-ipf">
    <title>IPFILTER (IPF)</title>

    <indexterm>
      <primary>Firewall</primary>
      <secondary><application>IPFILTER</application></secondary>
    </indexterm>

    <para><application>IPFILTER</application>, auch als
      <application>IPF</application> bekannt, ist eine
      plattformübergreifende Open Source Firewall, die auf
      mehrere Betriebssysteme portiert wurde, einschließlich
      &os;, NetBSD, OpenBSD und &solaris;.</para>

    <para><application>IPFILTER</application> basiert auf einer
      kernelseitigen Firewall und einem
      <acronym>NAT</acronym>-Mechanismus, der durch Anwenderprogramme
      gesteuert und überwacht werden kann.  Firewallregeln werden mit
      <application>ipf</application> gesetzt oder gelöscht.  Für die
      Manipulation der <acronym>NAT</acronym>-Regeln wird
      <application>ipnat</application> benutzt.  Mit
      <application>ipfstat</application> werden Laufzeitstatistiken
      der kernelseitigen Anteile von
      <application>IPFILTER</application> aufgelistet.  Mit
      <application>ipmon</application> können die Aktionen von
      <application>IPFILTER</application> in Protokolldateien
      gespeichert werden.</para>

    <para><application>IPF</application> wurde ursprünglich mit der
      Verarbeitungslogik <quote>die letzte passende Regel
	gewinnt</quote> geschrieben und verwendete ausschließlich
      Regeln ohne feste Zustände.  Inzwischen wurde
      <application>IPF</application> modernisiert und unterstützt nun
      auch die Optionen <literal>quick</literal> und
      <literal>keep state</literal>.</para>

    <para>Antworten auf häufige Fragen finden Sie unter <uri
	xlink:href="http://www.phildev.net/ipf/index.html">
	http://www.phildev.net/ipf/index.html</uri>.  Ein Archiv
      der <application>IPFILTER</application> Mailingliste steht unter
      <uri xlink:href="http://marc.info/?l=ipfilter">
	http://marc.info/?l=ipfilter</uri> zur Verfügung.</para>

    <para>Dieser Abschnitt des Handbuchs konzentriert sich auf
      <application>IPF</application> unter &os;.  Es werden auch
      Firewallregeln mit den Optionen <literal>quick</literal> und
      <literal>keep state</literal> vorgestellt.</para>

    <sect2>
      <title><application>IPF</application> aktivieren</title>

      <indexterm>
	<primary><application>IPFILTER</application></primary>
	<secondary>aktivieren</secondary>
      </indexterm>

      <para><application>IPF</application> ist in &os; als ladbares
	Kernelmodul enthalten.  Das bedeutet, dass Sie keinen
	angepassten Kernel erzeugen müssen um
	<application>IPF</application> zu aktivieren.</para>

      <indexterm>
	<primary>Kerneloptionen</primary>
	<secondary><application>IPFILTER</application></secondary>
      </indexterm>

      <indexterm>
	<primary>Kerneloptionen</primary>
	<secondary>IPFILTER_LOG</secondary>
      </indexterm>

      <indexterm>
	<primary>Kerneloptionen</primary>
	<secondary>IPFILTER_DEFAULT_BLOCK</secondary>
      </indexterm>

      <indexterm>
	<primary><application>IPFILTER</application></primary>
	<secondary>Kerneloptionen</secondary>
      </indexterm>

      <para>Benutzer, die <application>IPF</application> lieber
	statisch in den Kernel kompilieren, sollten den Anweisungen in
	<xref linkend="kernelconfig"/> folgen.  Die folgenden
	Kerneloptionen stehen zur Verfügung:</para>

      <programlisting>options IPFILTER
options IPFILTER_LOG
options IPFILTER_LOOKUP
options IPFILTER_DEFAULT_BLOCK</programlisting>

      <para><literal>options IPFILTER</literal> aktiviert die
	Unterstützung für <application>IPFILTER</application>.
	<literal>options IPFILTER_LOG</literal> aktiviert die
	Protokollierung über die Pseudo-Schnittstelle
	<filename>ipl</filename> für Firewallrelgen, die das
	Schlüsselwort <literal>log</literal> enthalten.
	<literal>IPFILTER_LOOKUP</literal> aktiviert
	<acronym>IP</acronym>-Pools, um die Suche nach
	<acronym>IP</acronym>-Adressen zu beschleunigen.
	<literal>IPFILTER_DEFAULT_BLOCK</literal> ändert das
	Verhalten der Firewall dahingehend, dass jedes Paket, das
	nicht explizit von einer <literal>pass</literal>-Regel
	Zugang erhält, geblockt wird.</para>

      <para>Um <application>IPF</application> während des Bootens zu
	aktivieren, müssen folgende Einträge in
	<filename>/etc/rc.conf</filename> hinzugefügt werden.  Diese
	Einträge aktivieren ebenfalls die Protokollierung und die
	Regel <literal>default pass all</literal>.  Um diese
	Voreinstellung zu ändern, ohne einen neuen Kernel zu
	übersetzen, müssen Sie am Ende der Firewallregeln eine
	<literal>block all</literal> Regel hinzufügen.</para>

      <programlisting>ipfilter_enable="YES"             # Start ipf firewall
ipfilter_rules="/etc/ipf.rules"   # loads rules definition text file
ipmon_enable="YES"                # Start IP monitor log
ipmon_flags="-Ds"                 # D = start as daemon
                                  # s = log to syslog
                                  # v = log tcp window, ack, seq
                                  # n = map IP &amp; port to names</programlisting>

      <para>Wenn die <acronym>NAT</acronym>-Funktionalität benötigt
	wird, müssen auch diese Zeilen hinzugefügt werden:</para>

      <programlisting>gateway_enable="YES"              # Enable as LAN gateway
ipnat_enable="YES"                # Start ipnat function
ipnat_rules="/etc/ipnat.rules"    # rules definition file for ipnat</programlisting>

      <para>Jetzt können Sie <application>IPF</application>
	starten:</para>

      <screen>&prompt.root; <userinput>service ipfilter start</userinput></screen>

      <para>Um die Firewallregeln zu laden, übergeben Sie den Namen
	des Regelwerks an <command>ipf</command>.  Mit dem folgenden
	Kommando ersetzen Sie alle aktuell geladenen Regeln:</para>

      <screen>&prompt.root; <userinput>ipf -Fa -f /etc/ipf.rules</userinput></screen>

      <para><literal>-Fa</literal> löscht zunächst alle internen
	Regeln und mit <literal>-f</literal> wird die Datei angegeben,
	welche die zu ladenen Regeln enthält.</para>

      <para>Damit haben Sie die Möglichkeit, Änderungen an der
	laufenden Firewall zu machen, ohne dass das System neu
	gestartet werden muss.  Da dieser Vorgang beliebig oft
	wiederholt werden kann, ist es ein sehr bequemer Weg neue
	Regeln zu testen.</para>

      <para>Diese und weitere Optionen sind in &man.ipf.8;
	beschrieben.</para>
    </sect2>

    <sect2>
      <title><application>IPF</application> Regel-Syntax</title>

      <indexterm>
	<primary><application>IPFILTER</application></primary>
	<secondary>Regel-Syntax</secondary>
      </indexterm>

      <para>Mit der hier beschriebenen Regel-Syntax können
	zustandsorientierte Regeln erstellt werden.  Beim Erstellen
	von Regeln ist zu beachten, dass Regeln ohne das Schlüsselwort
	<literal>quick</literal> der Reihe nach geprüft werden und
	<quote>die letzte zutreffende Regel</quote> angewendet wird.
	Das bedeutet, dass selbst dann, wenn die erste zutreffende
	Regel eine <literal>pass</literal>-Regel ist, das Paket
	dennoch geblockt wird, falls später eine
	<literal>block</literal>-Regel zutrifft.  Beispielregelsätze
	finden Sie in
	<filename>/usr/share/examples/ipfilter</filename>.</para>

      <para>Beim Erstellen von Regeln wird das Zeichen
	<literal>#</literal> verwendet, um einen Kommentar bis zum
	Ende der Zeile einzuleiten.  Leere Zeilen werden
	ignoriert.</para>

      <para>Die Schlüsselwörter, die in den Regeln verwendet werden,
	müssen in einer bestimmten Reihenfolge geschrieben werden,
	von links nach rechts.  Einige Schlüsselwörter sind
	verbindlich, andere sind optional.  Einige Schlüsselwörter
	haben Unteroptionen, die wiederum selbst Schlüsselwörter sind
	und ebenfalls weitere Unteroptionen einschließen können.  Die
	Reihenfolge der Schlüsselwörter ist wie folgt, wobei die
	Wörter in Großbuchstaben eine Variable darstellen und die
	Wörter in Kleinbuchstaben der Variable vorangestellt werden
	müssen:</para>

      <para><replaceable>ACTION DIRECTION OPTIONS proto PROTO_TYPE
	  from SRC_ADDR SRC_PORT to DST_ADDR DST_PORT
	  TCP_FLAG|ICMP_TYPE keep state STATE</replaceable></para>

      <para>Dieser Abschnitt beschreibt jedes dieser Schlüsselwörter
	und ihre Optionen.  Es ist jedoch keine vollständige Liste
	aller möglichen Optionen.  &man.ipf.5; enthält eine
	vollständige Beschreibung der Syntax und einige
	Beispiele zur Erstellung von
	<application>IPF</application>-Regeln.</para>

      <variablelist>
	<varlistentry>
	  <term>ACTION</term>

	  <listitem>
	    <para>Dieses Schlüsselwort bestimmt, was mit dem Paket zu
	      tun ist, wenn es auf eine Regel zutrifft.  Jede Regel
	      <emphasis>muss</emphasis> dieses Schlüsselwort
	      enthalten.  Die folgenden Aktionen werden
	      erkannt:</para>

	    <para><literal>block</literal>: Das Paket wird
	      verworfen.</para>

	    <para><literal>pass</literal>: Das Paket wird
	      durchgelassen.</para>

	    <para><literal>log</literal>: Das Paket wird
	      protokolliert.</para>

	    <para><literal>count</literal>: Zählt die Anzahl der
	      Pakete und die Bytes.  Die kann einen Hinweis darauf
	      geben, wie oft Pakete auf diese Regel zutreffen.</para>

	    <para><literal>auth</literal>: Das Paket geht in eine
	      Warteschlange zur Weiterverarbeitung durch ein anderes
	      Programm.</para>

	    <para><literal>call</literal>: Ermöglicht den Zugriff auf
	      eingebaute <application>IPF</application>-Funktionen,
	      die komplexere Aktionen ermöglichen.</para>

	    <para><literal>decapsulate</literal>: Entfernt alle
	      Header, um den Inhalt des Pakets zu verarbeiten.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>DIRECTION</term>

	  <listitem>
	    <para>Als nächstes muss für jede Regel explizit die
	      Richtung mit einem der folgenden Schlüsselwörter
	      angegeben werden:</para>

	    <para><literal>in</literal>: Die Regel wird auf ein
	      eingehendes Paket angewendet.</para>

	    <para><literal>out</literal>: Die Regel wird auf ein
	      ausgehendes Paket angewendet.</para>

	    <para><literal>all</literal>: Die Regel gilt für beide
	      Richtungen.</para>

	    <para>Wenn das System mehrere Schnittstellen ausweist,
	      kann die Schnittstelle zusammen mit der Richtung
	      angegeben werden.  Ein Beispiel wäre
	      <literal>in on fxp0</literal>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>OPTIONS</term>

	  <listitem>
	    <para>Optionen müssen nicht zwingend angegeben werden.
	      Falls jedoch mehrere Optionen angegeben werden, müssen
	      sie in der hier gezeigten Reihenfolge verwendet
	      werden.</para>

	    <para><literal>log</literal>: Wenn die Firewall die
	      angegebene Aktion durchführt, werden die Kopfdaten des
	      Pakets auf der Pseudo-Schnittstelle &man.ipl.4;
	      protokolliert.</para>

	    <para><literal>quick</literal>: Wenn ein Paket mit dieser
	      Regel übereinstimmt, wird die Aktion für diese Regel
	      ausgeführt und die Regelprüfung stoppt an dieser
	      Stelle.</para>

	    <para><literal>on</literal>: Auf dieses Schlüsselwort muss
	      der Name der Schnittstelle folgen.  Die Regel trifft nur
	      dann zu, wenn das Paket auf der angegebenen
	      Schnittstelle in die angegebene Richtung geht.</para>

	    <para>Wenn das Schlüsselwort <literal>log</literal>
	      verwendet wird, können die folgenden Ausdrücke in
	      dieser Reihenfolge benutzt werden:</para>

	    <para><literal>body</literal>: die ersten 128 Bytes des
	      Paketinhaltes werden zusätzlich zu den Kopfdaten
	      protokolliert.</para>

	    <para><literal>first</literal>: trifft nur zu, wenn das
	      Schlüsselwort <literal>log</literal> zusammen mit
	      <literal>keep-state</literal> verwendet wird.  Es
	      bestimmt, dass nur das auslösende Paket protokolliert
	      wird und nicht jedes weitere Paket, dass von der
	      gespeicherten Status-Regel betroffen ist.</para>

	    <para>Es stehen noch weitere Optionen zur Rückmeldung
	      von Fehlern verfügbar.  Ausführliche Details finden Sie
	      in &man.ipf.5;.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>PROTO_TYPE</term>

	  <listitem>
	    <para>Der Protokolltyp ist optional.  Er ist jedoch
	      zwingend erforderlich, falls die Regel einen
	      SRC_PORT oder DST_PORT angeben muss da es den Typ des
	      Protokolls bestimmt.  Wenn Sie das Protokoll angeben,
	      verwenden Sie das Schlüsselwort
	      <literal>proto</literal>, gefolgt von der
	      Protokollnummer oder dem Namen aus
	      <filename>/etc/protocols</filename>.  Zum Beispiel
	      <literal>tcp</literal>, <literal>udp</literal>, oder
	      <literal>icmp</literal>.  Wenn PROTO_TYPE angegeben
	      wird und SCR_PORT oder DST_PORT ausgelassen werden,
	      stimmen alle Portnummern für dieses Protokoll mit dieser
	      Regel überein.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>SRC_ADDR</term>

	  <listitem>
	    <para>Das Schlüsselwort <literal>from</literal> ist
	      verpflichtend und darauf folgt das Schlüsselwort, das
	      die Quelle des Pakets darstellt.  Die Quelle kann ein
	      Rechnername, eine <acronym>IP</acronym>-Adresse gefolgt
	      von der <acronym>CIDR</acronym>-Maske, ein Adresspool
	      oder das Schlüsselwort <literal>all</literal> sein.
	      &man.ipf.5; enthält einige Beispiele.</para>

	    <para><acronym>IP</acronym>-Bereiche können nur in der
	      <acronym>CIDR</acronym>-Notation angegeben werden.  Der
	      Port oder das Paket <package>net-mgmt/ipcalc</package>
	      hilft bei der Berechnung der richtigen
	      <acronym>CIDR</acronym>-Maske.  Weiterführende
	      Informationen finden Sie auf der Webseite <uri
		xlink:href="http://jodies.de/ipcalc">
		http://jodies.de/ipcalc</uri>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>SCR_PORT</term>

	  <listitem>
	    <para>Die Portnummer der Quelle ist optional.  Wenn sie
	      jedoch verwendet wird, muss in der Regel zuerst
	      PROTO_TYPE angegeben werden.  Die Portnummer muss auch
	      auf das Schlüsselwort <literal>proto</literal>
	      folgen.</para>

	    <para>Es werden verschiedene Vergleichsoperatoren
	      unterstützt: <literal>=</literal> (gleich),
	      <literal>!=</literal> (nicht gleich),
	      <literal>&lt;</literal> (kleiner als),
	      <literal>&gt;</literal> (größer als),
	      <literal>&lt;=</literal> (kleiner als oder gleich)
	      <literal>&gt;=</literal> (größer als oder
	      gleich).</para>

	    <para>Um Portbereiche anzugeben, schreiben Sie zwei
	      Portnummern zwischen <literal>&lt;&gt;</literal>
	      (kleiner als und größer als),
	      <literal>&gt;&lt;</literal> (größer als und kleiner
	      als), oder <literal>:</literal> (größer als oder gleich
	      und kleiner als oder gleich).</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>DST_ADDR</term>

	  <listitem>
	    <para>Das Schlüsselwort <literal>to</literal> ist
	      verpflichtend und darauf folgt das Schlüsselwort,
	      welches das Ziel des Pakets darstellt.  Dieses Ziel kann
	      ein Rechnername, eine <acronym>IP</acronym>-Adresse
	      gefolgt von der <acronym>CIDR</acronym>-Maske, ein
	      Adresspool oder das Schlüsselwort <literal>all</literal>
	      sein.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>DST_PORT</term>

	  <listitem>
	    <para>Die Portnummer des Ziels ist optional.  Wenn sie
	      jedoch verwendet wird, muss in der Regel zuerst
	      PROTO_TYPE angegeben werden.  Die Portnummer muss auch
	      auf das Schlüsselwort <literal>proto</literal>
	      folgen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>TCP_FLAG|ICMP_TYPE</term>

	  <listitem>
	    <para>Wenn <literal>tcp</literal> als PROTO_TYPE verwendet
	      wird, können bestimmte <acronym>TCP</acronym>-Flags
	      angegeben werden, die den Zustand einer Verbindung
	      bestimmen.  Mögliche Flags sind:
	      <literal>S</literal> (SYN),
	      <literal>A</literal> (ACK),
	      <literal>P</literal> (PSH),
	      <literal>F</literal> (FIN),
	      <literal>U</literal> (URG),
	      <literal>R</literal> (RST),
	      <literal>C</literal> (CWN) und
	      <literal>E</literal> (ECN).</para>

	    <para>Wenn <literal>icmp</literal> als PROTO_TYPE
	      verwendet wird, kann der <acronym>ICMP</acronym>-Typ mit
	      angegeben werden.  &man.ipf.5; enthält eine Auflistung
	      der zulässigen Typen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>STATE</term>

	  <listitem>
	    <para>Wenn eine <literal>pass</literal>-Regel das
	      Schlüsselwort <literal>keep state</literal> enthält,
	      wird <application>IPF</application> einen Eintrag in
	      der dynamischen Zustandstabelle hinzufügen, damit
	      nachfolgende Pakete dieser Verbindung ebenfalls
	      durchgelassen werden.  <application>IPF</application>
	      kann den Zustand für <acronym>TCP</acronym>,
	      <acronym>UDP</acronym> und
	      <acronym>ICMP</acronym>-Sitzungen verfolgen.
	      <application>IPF</application> wird jedes Paket, das
	      zu einer aktiven Sitzung gehört, durchlassen, auch
	      wenn ein anderes Protokoll verwendet wird.</para>

	    <para>Pakete, die über die Schnittstelle zum öffentlichen
	      Internet raus gehen, werden von
	      <application>IPF</application> zuerst gegen die
	      dynamische Zustandstabelle geprüft.  Wenn das nächste
	      Paket dieser aktiven Sitzung mit dem vorherigen Paket
	      übereinstimmt, verlässt dieses Paket die Firewall und
	      der Status wird in der dynamischen Zustandstabelle
	      aktualisiert.  Pakete, die nicht zu einer aktiven
	      Sitzung gehören, werden gegen ausgehende Regeln geprüft.
	      Eingehende Pakete von der Schnittstelle zum öffentlichen
	      Internet werden gegen die dynamische Zustandstabelle
	      geprüft.  Wenn das nächste Paket mit der aktiven Sitzung
	      übereinstimmt, verlässt dieses Paket die Firewall und
	      der Status wird in der dynamischen Zustandstabelle
	      aktualisiert.  Pakete, die nicht zu einer aktiven
	      Sitzung gehören, werden gegen eingehende Regeln
	      geprüft.</para>

	    <para>Mehrere Schlüsselwörter können an
	      <literal>keep state</literal> angefügt werden.  Bei der
	      Verwendung dieser Schlüsselwörter werden verschiedene
	      Optionen gesetzt, um die zustandsorientierte Filterung
	      zu steuern.  &man.ipf.5; enthält eine Liste der
	      verfügbaren Optionen und deren Beschreibungen.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2>
      <title>Beispielregelsatz</title>

      <para>Dieser Abschnitt beschreibt die Erstellung eines
	Regelsatzes, welcher nur entsprechende Dienste erlaubt und
	alle anderen Verbindungen blockiert.</para>

      <para>&os; verwendet die Loopback-Schnittstelle
	(<filename>lo0</filename>) und die
	<acronym>IP</acronym>-Adresse <systemitem
	  class="ipaddress">127.0.0.1</systemitem> zur internen
	Kommunikation.  Der Regelsatz muss Regeln enthalten, die
	Pakete für diesen internen Verkehr ermöglichen:</para>

      <programlisting># no restrictions on the loopback interface
pass in quick on lo0 all
pass out quick on lo0 all</programlisting>

      <para>Die mit dem Internet verbundene Schnittstelle wird für die
	Autorisierung und den Zugriff aller ein- und ausgehenden
	Verbindungen verwendet.  Wenn eine oder mehrere Schnittstellen
	mit privaten Netzwerken verbunden sind, müssen Regeln
	existieren, die den Datenverkehr aus dem
	<acronym>LAN</acronym> zwischen den internen Netzwerken oder
	ins Internet erlauben.  Der Regelsatz sollte in drei Bereiche
	unterteilt werden: vertrauenswürdige interne Schnittstellen,
	ausgehende Verbindungen über die öffentlichen Schnittstellen
	und eingehende Verbindungen über die öffentliche
	Schnittstelle.</para>

      <para>Diese beiden Regeln erlauben den gesamten Datenverkehr
	über eine vertrauenswürdige
	<acronym>LAN</acronym>-Schnittstelle namens
	<filename>xl0</filename>:</para>

      <programlisting># no restrictions on inside LAN interface for private network
pass out quick on xl0 all
pass in quick on xl0 all</programlisting>

      <para>Die Regeln für den ein- und ausgehenden Verkehr der
	öffentlichen Schnittstelle sollten in einer bestimmten
	Reihenfolge geschrieben werden.  Zuerst Regeln, die häufiger
	übereinstimmen, danach Regeln, die seltener übereinstimmen.
	Die letzte Regel blockiert und protokolliert alle Pakete auf
	der Schnittstelle.</para>

      <para>Der folgende Regelsatz definiert die ausgehenden Regeln
	der öffentlichen Schnittstelle <filename>dc0</filename>.
	Die Regeln prüfen den Zustand und identifizieren bestimmte
	Dienste, auf die die internen Systeme zugreifen dürfen.  Alle
	Regeln verwenden das Schlüsselwort <literal>quick</literal>
	und geben die passenden Portnummern und ggf. auch die
	Zieladressen an.</para>

      <programlisting># interface facing Internet (outbound)
# Matches session start requests originating from or behind the
# firewall, destined for the Internet.

# Allow outbound access to public DNS servers.
# Replace x.x.x. with address listed in /etc/resolv.conf.
# Repeat for each DNS server.
pass out quick on dc0 proto tcp from any to x.x.x. port = 53 flags S keep state
pass out quick on dc0 proto udp from any to xxx port = 53 keep state

# Allow access to ISP's specified DHCP server for cable or DSL networks.
# Use the first rule, then check log for the IP address of DHCP server.
# Then, uncomment the second rule, replace z.z.z.z with the IP address,
# and comment out the first rule
pass out log quick on dc0 proto udp from any to any port = 67 keep state
#pass out quick on dc0 proto udp from any to z.z.z.z port = 67 keep state

# Allow HTTP and HTTPS
pass out quick on dc0 proto tcp from any to any port = 80 flags S keep state
pass out quick on dc0 proto tcp from any to any port = 443 flags S keep state

# Allow email
pass out quick on dc0 proto tcp from any to any port = 110 flags S keep state
pass out quick on dc0 proto tcp from any to any port = 25 flags S keep state

# Allow NTP
pass out quick on dc0 proto tcp from any to any port = 37 flags S keep state

# Allow FTP
pass out quick on dc0 proto tcp from any to any port = 21 flags S keep state

# Allow SSH
pass out quick on dc0 proto tcp from any to any port = 22 flags S keep state

# Allow ping
pass out quick on dc0 proto icmp from any to any icmp-type 8 keep state

# Block and log everything else
block out log first quick on dc0 all</programlisting>

      <para>Die folgenden Beispielregeln für den eingehenden Verkehr
	auf der öffentlichen Schnittstelle blockieren zuerst alle
	unerwünschten Pakete.  Dies reduziert die Anzahl der Pakete,
	die durch die letzte Regel protokolliert werden.</para>

      <programlisting># interface facing Internet (inbound)
# Block all inbound traffic from non-routable or reserved address spaces
block in quick on dc0 from 192.168.0.0/16 to any    #RFC 1918 private IP
block in quick on dc0 from 172.16.0.0/12 to any     #RFC 1918 private IP
block in quick on dc0 from 10.0.0.0/8 to any        #RFC 1918 private IP
block in quick on dc0 from 127.0.0.0/8 to any       #loopback
block in quick on dc0 from 0.0.0.0/8 to any         #loopback
block in quick on dc0 from 169.254.0.0/16 to any    #DHCP auto-config
block in quick on dc0 from 192.0.2.0/24 to any      #reserved for docs
block in quick on dc0 from 204.152.64.0/23 to any   #Sun cluster interconnect
block in quick on dc0 from 224.0.0.0/3 to any       #Class D &amp; E multicast

# Block fragments and too short tcp packets
block in quick on dc0 all with frags
block in quick on dc0 proto tcp all with short

# block source routed packets
block in quick on dc0 all with opt lsrr
block in quick on dc0 all with opt ssrr

# Block OS fingerprint attempts and log first occurrence
block in log first quick on dc0 proto tcp from any to any flags FUP

# Block anything with special options
block in quick on dc0 all with ipopts

# Block public pings and ident
block in quick on dc0 proto icmp all icmp-type 8
block in quick on dc0 proto tcp from any to any port = 113

# Block incoming Netbios services
block in log first quick on dc0 proto tcp/udp from any to any port = 137
block in log first quick on dc0 proto tcp/udp from any to any port = 138
block in log first quick on dc0 proto tcp/udp from any to any port = 139
block in log first quick on dc0 proto tcp/udp from any to any port = 81</programlisting>

      <para>Wenn eine Regel mit der Option
	<literal>log first</literal> protokolliert wird, können Sie
	mit <command>ipfstat -hio</command> prüfen, wie viele
	Übereinstimmungen es für diese Regel gibt.  Eine große Anzahl
	von Übereinstimmungen kann darauf hindeuten, dass das System
	angegriffen wird.</para>

      <para>Die restlichen Regeln definieren, welche Verbindungen aus
	dem Internet kommend hergestellt werden dürfen.  Die letzte
	Regel blockiert alle Verbindungen, die nicht ausdrücklich von
	vorhergehenden Regeln erlaubt wurden.</para>

      <programlisting># Allow traffic in from ISP's DHCP server. Replace z.z.z.z with
# the same IP address used in the outbound section.
pass in quick on dc0 proto udp from z.z.z.z to any port = 68 keep state

# Allow public connections to specified internal web server
pass in quick on dc0 proto tcp from any to x.x.x.x port = 80 flags S keep state

# Block and log only first occurrence of all remaining traffic.
block in log first quick on dc0 all</programlisting>
    </sect2>

    <sect2>
      <title><acronym>NAT</acronym> Konfiguration</title>

      <para>Um <acronym>NAT</acronym> zu aktivieren, fügen Sie
	folgende Zeilen in <filename>/etc/rc.conf</filename> hinzu.
	Geben Sie den Namen der Datei an, welche die
	<acronym>NAT</acronym>-Regeln enthält:</para>

      <programlisting>gateway_enable="YES"
ipnat_enable="YES"
ipnat_rules="/etc/ipnat.rules"</programlisting>

      <para><acronym>NAT</acronym>-Regeln sind sehr flexibel, um den
	Bedürfnissen von kommerziellen Anwendern und Heimanwendern
	gerecht zu werden.  Die hier vorgestellte Regelsyntax wurde
	vereinfacht, um die gemeinsame Nutzung zu demonstrieren.
	Eine vollständige Beschreibung der Syntax finden Sie in
	&man.ipnat.5;.</para>

      <para>Die grundlegende Syntax für eine
	<acronym>NAT</acronym>-Regel ist wie folgt.
	<literal>map</literal> leitet die Regel ein und
	<literal>IF</literal> sollte durch den Namen der externen
	Schnittstelle ersetzt werden:</para>

      <programlisting>map <replaceable>IF</replaceable> <replaceable>LAN_IP_RANGE</replaceable> -&gt; <replaceable>PUBLIC_ADDRESS</replaceable></programlisting>

      <para><replaceable>LAN_IP_RANGE</replaceable> ist ein Bereich
	von <acronym>IP</acronym>-Adressen, der von den internen
	Rechnern verwendet wird.  In der Regel ist dies ein privater
	Bereich, beispielsweise <systemitem
	  class="ipaddress">192.168.1.0/24</systemitem>.
	<replaceable>PUBLIC_ADDRESS</replaceable> kann entweder eine
	statische externe <acronym>IP</acronym>-Adresse sein, oder das
	Schlüsselwort <literal>0/32</literal>, welches der
	zugewiesenen <acronym>IP</acronym>-Adresse für
	<replaceable>IF</replaceable> entspricht.</para>

      <para>Wenn ein Paket aus dem <acronym>LAN</acronym> mit einem
	öffentlichen Ziel an der <application>IPF</application>
	Firewall ankommt, werden zunächst die Regeln für den
	ausgehenden Verkehr geprüft.  Danach wird das Paket an das
	<acronym>NAT</acronym>-Regelwerk geleitet, wo es von oben nach
	unten gelesen und geprüft wird, wobei die erste
	übereinstimmende Regel gewinnt.
	<application>IPF</application> testet jede
	<acronym>NAT</acronym>-Regel gegen die Schnittstelle und die
	Quell-<acronym>IP</acronym>-Adresse des Pakets.  Wenn der
	Schnittstellenname des Pakets mit einer
	<acronym>NAT</acronym>-Regel übereinstimmt, wird geprüft, ob
	die Quell-<acronym>IP</acronym>-Adresse des Pakets auf den
	Bereich in <replaceable>LAN_IP_RANGE</replaceable> passt.
	Wenn dies der Fall ist, wird die
	Quell-<acronym>IP</acronym>-Adresse des Pakets mit der Adresse
	aus <replaceable>PUBLIC_ADDRESS</replaceable>
	überschrieben.  <application>IPF</application> speichert die
	Einträge in seiner internen <acronym>NAT</acronym>-Tabelle, so
	dass wenn das Paket aus dem Internet zurückkehrt, es der
	ursprünglichen privaten <acronym>IP</acronym>-Adresse
	zugeordnet werden kann, bevor es von den weiteren
	Firewallregeln geprüft wird.</para>

      <para>Bei Netzwerken mit einer großen Anzahl von Systemen oder
	mehreren Subnetzen, steigert sich der Ressourcenverbrauch
	für das Umschreiben der <acronym>IP</acronym>-Adressen.  Es
	existieren zwei Methoden, um dieses Problem zu umgehen.</para>

      <para>Bei der ersten Methode wird ein Portbereich definiert, der
	für die Quell-Ports verwendet wird.  Durch das Hinzufügen des
	Schlüsselworts <literal>portmap</literal> kann
	<acronym>NAT</acronym> angewiesen werden, nur Quell-Ports aus
	dem angegebenen Bereich zu benutzen:</para>

      <programlisting>map dc0 192.168.1.0/24 -&gt; 0/32 portmap tcp/udp 20000:60000</programlisting>

      <para>Alternativ kann das Schlüsselwort <literal>auto</literal>
	verwendet werden.  Dadurch ermittelt <acronym>NAT</acronym>
	selbstständig die zur Verfügung stehenden Ports:</para>

      <programlisting>map dc0 192.168.1.0/24 -&gt; 0/32 portmap tcp/udp auto</programlisting>

      <para>Mit der zweiten Methode wird ein Pool von öffentlichen
	Adressen verwendet.  Dies ist nützlich, wenn es viele Systeme
	im Netzwerk gibt und ein Block öffentlicher
	<acronym>IP</acronym>-Adressen verfügbar ist.  Aus diesem Pool
	kann <acronym>NAT</acronym> dann
	<acronym>IP</acronym>-Adressen für die ausgehenden Pakete
	auswählen.</para>

      <para>Der Bereich der öffentlichen
	<acronym>IP</acronym>-Adressen kann mit einer Netzmaske oder
	der <acronym>CIDR</acronym>-Notation festgelegt werden.  Die
	folgenden Regeln sind identisch:</para>

      <programlisting>map dc0 192.168.1.0/24 -&gt; 204.134.75.0/255.255.255.0
map dc0 192.168.1.0/24 -&gt; 204.134.75.0/24</programlisting>

      <para>Es ist gängige Praxis, öffentlich zugängliche Web- oder
	Mail-Server getrennt von den internen Netzwerksegmenten zu
	betreiben.  Der Verkehr von diesen Servern muss dennoch von
	<acronym>NAT</acronym> bearbeitet werden und die Portumleitung
	ist erforderlich, um den eingehenden Datenverkehr an den
	richtigen Server zu leiten.  Verwenden Sie beispielsweise
	folgende Regel, um den eingehenden Verkehr auf der
	öffentlichen <acronym>IP</acronym>-Adresse <systemitem
	  class="ipaddress">20.20.20.5</systemitem> dem internen
	Server mit der Adresse <systemitem
	class="ipaddress">10.0.10.25</systemitem> zuzuordnen:</para>

      <programlisting>rdr dc0 20.20.20.5/32 port 80 -&gt; 10.0.10.25 port 80</programlisting>

      <para>Wenn dies der einzige Webserver im Netz ist, würde auch
	folgende Regel funktionieren, die alle
	<acronym>HTTP</acronym>-Anfragen an <systemitem
	  class="ipaddress">10.0.10.25</systemitem> umleitet:</para>

      <programlisting>rdr dc0 0.0.0.0/0 port 80 -&gt; 10.0.10.25 port 80</programlisting>

      <para><application>IPF</application> enthält einen
	<acronym>FTP</acronym>-Proxy, der zusammen mit
	<acronym>NAT</acronym> benutzt werden kann.  Dieser Proxy
	überwacht den ausgehenden Datenverkehr für aktive und passive
	Verbindungsanfragen und erstellt dynamische Filterregeln,
	welche die Portnummern des jeweiligen
	<acronym>FTP</acronym>-Datenkanal enthalten.  Dadurch entfällt
	die Notwendigkeit, viele Ports für
	<acronym>FTP</acronym>-Verbindungen zu öffnen.</para>

      <para>In diesem Beispiel verwendet die erste Regel den Proxy
	für ausgehende <acronym>FTP</acronym>-Verbindungen aus dem
	internen <acronym>LAN</acronym>.  Die zweite Regel übergibt
	den <acronym>FTP</acronym>-Datenverkehr von der Firewall an
	das Internet und die dritte Regel handhabt den restlichen
	Datenverkehr aus dem internen <acronym>LAN</acronym>:</para>

      <programlisting>map dc0 10.0.10.0/29 -&gt; 0/32 proxy port 21 ftp/tcp
map dc0 0.0.0.0/0 -&gt; 0/32 proxy port 21 ftp/tcp
map dc0 10.0.10.0/29 -&gt; 0/32</programlisting>

      <para><acronym>FTP</acronym> <literal>map</literal>-Regeln
	stehen vor den <acronym>NAT</acronym>-Regeln.  Wenn ein Paket
	mit der <acronym>FTP</acronym>-Regel übereinstimmt, erstellt
	der <acronym>FTP</acronym>-Proxy eine temporäre Filterregel,
	damit die Pakete durchgelassen und von <acronym>NAT</acronym>
	verarbeitet werden können.  Alle Pakte aus dem
	<acronym>LAN</acronym>, die nicht für <acronym>FTP</acronym>
	bestimmt sind, werden von <acronym>NAT</acronym> verarbeitet,
	wenn sie mit der dritten Regel übereinstimmen.</para>

      <para>Ohne den <acronym>FTP</acronym>-Proxy würden stattdessen
	folgende Regeln benötigt.  Beachten Sie, dass ohne den Proxy
	alle Ports oberhalb von <literal>1024</literal> freigegeben
	werden müssen:</para>

      <programlisting># Allow out LAN PC client FTP to public Internet
# Active and passive modes
pass out quick on rl0 proto tcp from any to any port = 21 flags S keep state

# Allow out passive mode data channel high order port numbers
pass out quick on rl0 proto tcp from any to any port &gt; 1024 flags S keep state$
# Active mode let data channel in from FTP server
pass in quick on rl0 proto tcp from any to any port = 20 flags S keep state</programlisting>

      <para>Nachdem die Datei mit den <acronym>NAT</acronym>-Regeln
	bearbeitet wurde, führen Sie <command>ipnat</command> mit
	<option>-CF</option> aus, um die aktuellen
	<acronym>NAT</acronym>-Regeln und den Inhalt der dynamischen
	Zuordnungstabelle zu löschen.  Geben Sie
	<option>-f</option> zusammen mit dem
	<acronym>NAT</acronym>-Regelsatz an:</para>

      <screen>&prompt.root; <userinput>ipnat -CF -f /etc/ipnat.rules</userinput></screen>

      <para>Statistiken zu <acronym>NAT</acronym> lassen sich wie
	folgt anzeigen:</para>

      <screen>&prompt.root; <userinput>ipnat -s</userinput></screen>

      <para>Die aktuellen Zuordnungen der
	<acronym>NAT</acronym>-Tabelle geben Sie mit diesem Kommando
	aus:</para>

      <screen>&prompt.root; <userinput>ipnat -l</userinput></screen>

      <para>Ausführliche Informationen erhalten Sie mit:</para>

      <screen>&prompt.root; <userinput>ipnat -v</userinput></screen>
    </sect2>

    <sect2>
      <title><application>IPF</application> Statistiken</title>

      <indexterm><primary>ipfstat</primary></indexterm>
      <indexterm>
	<primary>IPFILTER</primary>
	<secondary>Statistiken</secondary>
      </indexterm>

      <para><application>IPF</application> enthält mit &man.ipfstat.8;
	ein Werkzeug, mit dem Statistiken abgerufen und angezeigt
	werden können.  Die Zahlen beziehen sich auf den Zeitpunkt, an
	dem die Firewall zuletzt gestartet wurde, beziehungsweise die
	Statistik mit <command>ipf -Z</command> zurückgesetzt
	wurde.</para>

      <para>Die Ausgabe von <command>ifstat</command> sieht in etwa
	wie folgt aus:</para>

      <screen>input packets: blocked 99286 passed 1255609 nomatch 14686 counted 0
output packets: blocked 4200 passed 1284345 nomatch 14687 counted 0
input packets logged: blocked 99286 passed 0
output packets logged: blocked 0 passed 0
packets logged: input 0 output 0
log failures: input 3898 output 0
fragment state(in): kept 0 lost 0
fragment state(out): kept 0 lost 0
packet state(in): kept 169364 lost 0
packet state(out): kept 431395 lost 0
ICMP replies: 0 TCP RSTs sent: 0
Result cache hits(in): 1215208 (out): 1098963
IN Pullups succeeded: 2 failed: 0
OUT Pullups succeeded: 0 failed: 0
Fastroute successes: 0 failures: 0
TCP cksum fails(in): 0 (out): 0
Packet log flags set: (0)</screen>

      <para>Es stehen viele Optionen zur Verfügung.  Wird entweder
	<option>-i</option> (eingehend) oder <option>-o</option>
	(ausgehend) angegeben, wird der Befehl die entsprechende
	Liste mit den derzeit vom Kernel benutzten Filterregeln
	anzeigen.  Um auch die Regelnummern zu sehen, muss
	<option>-n</option> angegeben werden.  Zum Beispiel zeigt
	<command>ipfstat -on</command> die Tabelle für ausgehende
	Regeln und die Regelnummer an:</para>

      <screen>@1 pass out on xl0 from any to any
@2 block out on dc0 from any to any
@3 pass out quick on dc0 proto tcp/udp from any to any keep state</screen>

      <para>Wenn Sie der Regel ein <option>-h</option> voranstellen,
	wird der Zähler für die jeweilige Regel ausgegeben.  Zum
	Beispiel gibt <command>ipfstat -oh</command> die ausgehenden
	Regeln inklusive der Zähler aus:</para>

      <screen>2451423 pass out on xl0 from any to any
354727 block out on dc0 from any to any
430918 pass out quick on dc0 proto tcp/udp from any to any keep state</screen>

      <para>Benutzen Sie <command>ipfstat -t</command> um die
	Zustandstabelle in einem &man.top.1; ähnlichen Format
	anzuzeigen.  Unterliegt die Firewall einem Angriff, bietet
	diese Option die Möglichkeit, die entsprechenden Pakete zu
	identifizieren.  Mit den optionalen Flags können
	<acronym>IP</acronym>-Adressen, Ports oder Protokolle in
	Echtzeit überwacht werden.  Lesen Sie &man.ipfstat.8; für
	weitere Informationen.</para>
    </sect2>

    <sect2>
      <title><application>IPF</application> Protokollierung</title>

      <indexterm>
	<primary><command>ipmon</command></primary>
      </indexterm>

      <indexterm>
	<primary><application>IPFILTER</application></primary>
	<secondary>Protokollierung</secondary>
      </indexterm>

      <para><application>IPF</application> enthält mit
	<command>ipmon</command> ein Werkzeug, mit dem die
	Protokolle der Firewall in menschenlesbarer Form gespeichert
	werden können.  Dies erfordert jedoch, dass
	<literal>options IPFILTER_LOG</literal> in die
	Kernelkonfigurationsdatei hinzugefügt wird.  Folgen Sie dazu
	den Anweisungen in <xref linkend="kernelconfig"/>.</para>

      <para>Um eine kontinuierliche Protokolldatei bereitzustellen,
	läuft dieses Kommando normalerweise im Daemon-Modus, damit
	auch ältere Ereignisse nachverfolgt werden können.  Da &os;
	mit &man.syslogd.8; ein Werkzeug besitzt, das automatisch
	Protokolldateien rotiert, wird in der Voreinstellung für
	<literal>ipmon_flags</literal> <literal>-Ds</literal> in
	<filename>rc.conf</filename> verwendet:</para>

      <programlisting>ipmon_flags="-Ds" # D = start as daemon
                  # s = log to syslog
                  # v = log tcp window, ack, seq
                  # n = map IP &amp; port to names</programlisting>

      <para>Protokollierung bietet die im Nachhinein die Möglichkeit
	festzustellen, welche Pakete verworfen wurden, von welchen
	Adressen diese Pakete kamen und wohin sie gehen sollten.
	Diese Informationen sind hilfreich beim Aufspüren von
	Angreifern.</para>

      <para>Nachdem die Protokollierung in
	<filename>/etc/rc.conf</filename> aktiviert und mit
	<command>service ipmon start</command> gestartet wurde, wird
	<application>IPF</application> Regeln aufzeichnen, welche das
	Schlüsselwort <literal>log</literal> enthalten.  Der
	Firewalladministrator entscheidet, welche Regeln protokolliert
	werden.  In der Regel werden nur geblockte Pakete
	protokolliert.  Es ist üblich, das Schlüsselwort
	<literal>log</literal> in der letzten Regel des Regelsatzes
	mit aufzunehmen.  Dies macht es möglich, alle Pakete zu sehen,
	die mit keiner Regel des Regelsatzes übereinstimmten.</para>

      <para>In der Voreinstellung verwendet
	<command>ipmon -Ds</command> <literal>local0</literal> als
	Protokoll-Facility.  Die folgenden Level können verwendet
	werden, um die erfassten Daten weiter aufzuspalten:</para>

      <screen>LOG_INFO - packets logged using the "log" keyword as the action rather than pass or block.
LOG_NOTICE - packets logged which are also passed
LOG_WARNING - packets logged which are also blocked
LOG_ERR - packets which have been logged and which can be considered short due to an incomplete header</screen>

      <para>Damit <application>IPF</application> alle Daten
	protokolliert, legen Sie zunächst eine neue Datei
	<filename>/var/log/ipfilter.log</filename> an:</para>

      <screen>&prompt.root; <userinput>touch /var/log/ipfilter.log</userinput></screen>

      <para>Um alle Nachrichten in der angegebenen Datei zu
	protokollieren, fügen Sie den folgenden Eintrag in
	<filename>/etc/syslog.conf</filename> ein:</para>

      <programlisting>local0.* /var/log/ipfilter.log</programlisting>

      <para>Führen Sie <command>service syslogd reload</command> aus,
	damit &man.syslogd.8; <filename>/etc/syslog.conf</filename>
	neu einliest, um die Änderungen zu aktivieren.</para>

      <para>Denken Sie daran, auch
	<filename>/etc/newsyslog.conf</filename> anzupassen, damit das
	neue Protokoll rotiert wird.</para>

      <para>Die von <command>ipmon</command> generierten Nachrichten
	bestehen aus Daten, welche durch Leerzeichen getrennt sind.
	Alle Nachrichten enthalten die folgenden Felder:</para>

      <orderedlist>
	<listitem>
	  <para>Das Datum, an dem das Paket empfangen wurde.</para>
	</listitem>

	<listitem>
	  <para>Die Uhrzeit, wann das Paket empfangen wurde.  Das
	    Format ist HH:MM:SS.F (Stunden, Minuten, Sekunden und
	    Sekundenbruchteile).</para>
	</listitem>

	<listitem>
	  <para>Der Name der Schnittstelle, die das Paket
	    verarbeitet hat.</para>
	</listitem>

	<listitem>
	  <para>Die Gruppen- und Regelnummer im Format
	    <literal>@0:17</literal>.</para>
	</listitem>

	<listitem>
	  <para>Die Aktion: <literal>p</literal> für durchgelassene
	    Pakete, <literal>b</literal> für blockierte Pakete,
	    <literal>S</literal> für kurze Pakete,
	    <literal>n</literal> für Pakete auf die keine Regel zutraf
	    und <literal>L</literal> für Pakete die protokolliert
	    wurden.</para>
	</listitem>

	<listitem>
	  <para>Die Adressen werden in drei Felder unterteilt: die
	    Quelladresse und der Port getrennt durch Komma, das
	    Zeichen -&gt;, sowie die Zieladresse und Port.  Zum
	    Beispiel <literal>209.53.17.22,80 -&gt;
	      198.72.220.17,1722</literal>.</para>
	</listitem>

	<listitem>
	  <para><literal>PR</literal>, gefolgt vom Namen oder Nummer
	    des Protokolls.  Zum Beispiel
	    <literal>PR tcp</literal>.</para>
	</listitem>

	<listitem>
	  <para><literal>len</literal>, gefolgt von der Größe des
	    Headers und der Gesamtgröße des Pakets.  Zum Beispiel
	    <literal>len 20 40</literal>.</para>
	</listitem>
      </orderedlist>

      <para>Wenn es sich beim dem Paket um ein
	<acronym>TCP</acronym>-Paket handelt, gibt es ein zusätzliches
	Feld, das mit einem Bindestrich beginnt und die Buchstaben der
	entsprechenden Flags enthält.  Eine Liste der Flags und deren
	Buchstaben finden Sie in &man.ipf.5;.</para>

      <para>Wenn es sich beim dem Paket um ein
	<acronym>ICMP</acronym>-Paket handelt, gibt es zwei
	zusätzliche Felder: das erste Feld ist immer
	<quote>icmp</quote> und das zweite Feld enthält die
	<acronym>ICMP</acronym>-Nachricht und den Nachrichten-Code,
	getrennt durch einen Schrägstrich.  Beispielswiese
	<literal>icmp 3/3</literal> für die Nachricht
	<foreignphrase>Port unreachable</foreignphrase>.</para>
    </sect2>
  </sect1>
</chapter>
