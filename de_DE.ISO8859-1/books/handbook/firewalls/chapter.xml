<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde: de-docproj/books/handbook/firewalls/chapter.xml,v 1.53 2012/04/30 16:15:52 bcr Exp $
     basiert auf: r54389
-->
<chapter xmlns="http://docbook.org/ns/docbook"
  xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0"
  xml:id="firewalls">
  <info>
    <title>Firewalls</title>

    <authorgroup>
      <author>
	<personname>
	  <firstname>Joseph J.</firstname>
	  <surname>Barbish</surname>
	</personname>
	<contrib>Beigetragen von </contrib>
      </author>
    </authorgroup>

    <authorgroup>
      <author>
	<personname>
	  <firstname>Brad</firstname>
	  <surname>Davis</surname>
	</personname>
	<contrib>Nach SGML konvertiert und aktualisiert von </contrib>
      </author>
    </authorgroup>

    <authorgroup>
      <author>
	<personname>
	  <firstname>Michael</firstname>
	  <surname>Bunzel</surname>
	</personname>
	<contrib>Übersetzt von </contrib>
      </author>
      <author>
	<personname>
	  <firstname>Johann</firstname>
	  <surname>Kois</surname>
	</personname>
      </author>
      <author>
	<personname>
	  <firstname>Benjamin</firstname>
	  <surname>Lukas</surname>
	</personname>
      </author>
      <author>
	<personname>
	  <firstname>Björn</firstname>
	  <surname>Heidotting</surname>
	</personname>
      </author>
    </authorgroup>
  </info>

  <indexterm><primary>firewall</primary></indexterm>

  <indexterm>
    <primary>security</primary>
    <secondary>firewalls</secondary>
  </indexterm>

  <sect1 xml:id="firewalls-intro">
    <title>Einführung</title>

    <para>Firewalls ermöglichen es, den ein- und ausgehenden
      Netzwerkverkehr eines Systems zu filtern.  Dazu verwendet eine
      Firewall eine oder mehrere Gruppen von <quote>Regeln</quote>,
      um ankommende Netzwerkpakete zu untersuchen und entweder
      durchzulassen oder zu blockieren.  Die Regeln einer
      Firewall untersuchen charakteristische Eigenschaften von
      Datenpaketen, darunter den Protokolltyp, die Quell- und
      Zieladresse sowie den Quell- und Zielport.</para>

    <para>Firewalls können die Sicherheit eines Rechners oder
      eines Netzwerks erhöhen, indem sie folgende Aufgaben
      übernehmen:</para>

    <itemizedlist>
      <listitem>
	<para>Den Schutz der Anwendungen, Dienste und Rechner eines
	  internen Netzwerks vor unerwünschtem Datenverkehr
	  aus dem Internet.</para>
      </listitem>

      <listitem>
	<para>Die Beschränkung des Zugriffs von Rechnern des internen
	  Netzwerks auf Rechner oder Dienste des öffentlichen
	  Internets.</para>
      </listitem>

      <listitem>
	<para>Den Einsatz von Network Address Translation
	  (<acronym>NAT</acronym>), welches es durch die Verwendung
	  von privaten <acronym>IP</acronym>-Adressen ermöglicht,
	  eine einzige gemeinsame Internetverbindung für mehrere
	  Rechner zu nutzen.  Dies geschieht entweder über eine
	  einzige <acronym>IP</acronym>-Adresse oder über eine Gruppe
	  von jeweils automatisch zugewiesenen öffentlichen
	  Adressen.</para>
      </listitem>
    </itemizedlist>

    <para>Das Basissystem von &os; enthält drei Firewalls:
      <application>PF</application>, <application>IPFW</application>
      und <application>IPFILTER</application> (auch als
      <application>IPF</application> bekannt).  &os; enthält ebenfalls
      zwei <foreignphrase>Traffic-Shaper</foreignphrase> zur Kontrolle
      der Bandbreite: &man.altq.4; und &man.dummynet.4;.
      <application>ALTQ</application> ist traditionell eng an
      <application>PF</application> gebunden, während
      <application>dummynet</application> zusammen mit
      <application>IPFW</application> verwendet wird.
      Gemeinsam ist allen Firewalls, dass sie Regeln einsetzen, um den
      Transfer von ein- und ausgehenden Datenpaketen des Systems
      zu steuern.  Unterschiedlich ist aber die Art und Weise, wie
      dies realisiert wird.  Auch die für diese Regeln verwendete
      Syntax ist unterschiedlich.</para>

    <para>&os; besitzt mehrere Firewalls, um den unterschiedlichen
      Anforderungen und Vorlieben von Benutzern gerecht zu werden.
      Jeder Benutzer sollte selbst beurteilen, welche Firewall seinen
      Bedürfnissen am besten entspricht.</para>

    <para>Nachdem Sie dieses Kapitel gelesen haben, werden Sie
      wissen:</para>

    <itemizedlist>
      <listitem>
	<para>Wie man Paketfilterregeln erstellt.</para>
      </listitem>

      <listitem>
	<para>Was die Unterschiede zwischen den in &os; eingebauten
	  Firewalls sind.</para>
      </listitem>

      <listitem>
	<para>Wie die <application>PF</application>-Firewall
	  konfiguriert und einsetzt wird.</para>
      </listitem>

      <listitem>
	<para>Wie die <application>IPFW</application>-Firewall
	  konfiguriert und einsetzt wird.</para>
      </listitem>

      <listitem>
	<para>Wie die <application>IPFILTER</application>-Firewall
	  konfiguriert und einsetzt wird.</para>
      </listitem>
    </itemizedlist>

    <para>Bevor Sie dieses Kapitel lesen, sollten Sie:</para>

    <itemizedlist>
      <listitem>
	<para>Die grundlegenden Konzepte von &os; und dem Internet
	  verstehen.</para>
      </listitem>
    </itemizedlist>

    <note>
      <para>Da alle Firewalls auf der Inspektion ausgewählter
	Kontrollfelder in Datenpaketen basieren, muss für die
	Erstellung von Firewallregeln ein grundlegendes Verständnis
	von <acronym>TCP/IP</acronym> vorhanden sein.  Eine gute
	Einführung finden Sie in <link
	  xlink:href="http://www.ipprimer.com">
	  Daryl's TCP/IP Primer</link>.</para>
    </note>
  </sect1>

  <sect1 xml:id="firewalls-concepts">
    <title>Firewallkonzepte</title>

    <indexterm>
      <primary>firewall</primary>
      <secondary>Regelsatz</secondary>
    </indexterm>

    <para>Ein Regelsatz besteht aus einer Gruppe von Regeln, die
      Pakete basierend auf ihren Inhalt entweder blockieren oder
      durchlassen.  Der bidirektionale Austausch von Paketen zwischen
      zwei Rechnern wird als Sitzung
      (<foreignphrase>Session</foreignphrase>) bezeichnet.  Der
      Regelsatz verarbeitet sowohl ankommende Pakete aus dem
      Internet, als auch die vom System erzeugten Antwortpakete.
      Jeder <acronym>TCP/IP</acronym>-Dienst hat ein festgelegtes
      Protokoll und einen vorgegebenen Port.  Pakete für einen
      bestimmten Dienst stammen von einer Quelladresse und einem
      unprivilegierten Port und gehen an einen spezifischen Port
      auf der Zieladresse.  Alle oben genannten Parameter können als
      Selektionskriterien verwendet werden, um einen Regelsatz zu
      erstellen, der den Zugriff auf bestimmte Dienste gewährt oder
      blockiert.</para>

    <para>Unbekannte Portnummern können Sie in
      <filename>/etc/services</filename> nachschlagen.
      Alternativ finden Sie die Portnummern und deren Verwendungszweck
      auf <link
	xlink:href="http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers">
	http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers</link>.</para>

    <para>Unter diesem Link finden Sie <link
	xlink:href="http://web.archive.org/web/20150803024617/http://www.sans.org/security-resources/idfaq/oddports.php">
	Portnummern, die auch von Trojanern benutzt werden</link>.</para>

    <para><acronym>FTP</acronym> hat zwei Modi:  Aktiv und Passiv.
      Unterschied liegt in der Bestimmung des Datenkanals.  Der
      Passiv-Modus ist sicherer, da der Datenkanal vom Client
      bestimmt wird.  Eine ausführliche Erklärung von
      <acronym>FTP</acronym> und den verschiedenen Modi finden Sie
      unter <link
	xlink:href="http://www.slacksite.com/other/ftp.html">
	http://www.slacksite.com/other.ftp.html</link>.</para>

    <para>Ein Firewall-Regelsatz kann entweder
      <quote>einschließend</quote> (<foreignphrase>inclusive
	firewall</foreignphrase>) oder <quote>ausschließend</quote>
      (<foreignphrase>exclusive Firewall</foreignphrase>) sein.  Eine
      ausschließende Firewall lässt jeden Datenverkehr durch, der
      nicht durch eine Regel ausgeschlossen wurde.  Eine
      einschließende Firewall macht das genaue Gegenteil.  Sie lässt
      Datenverkehr nur dann passieren, wenn dieser einer der
      definierten Regeln entspricht.</para>

    <para>Eine einschließende Firewall bietet eine wesentlich bessere
      Kontrolle des ausgehenden Verkehrs, was sie zur besseren Wahl
      für Systeme macht, welche Dienste für das Internet anbieten.
      Sie kontrolliert auch den Verkehr aus dem öffentlichen Internet
      zum privaten Netzwerk.  Jeder Verkehr, der keiner Regel
      entspricht wird geblockt und protokolliert.  Einschließende
      Firewalls sind generell sicherer als ausschließende Firewalls,
      da sie das Risiko, dass unerwünschter Verkehr hindurch geht,
      drastisch reduzieren.</para>

    <note>
      <para>Wenn nicht anders vermerkt, verwenden alle Konfigurationen
	und Regelsätze in diesem Kapitel einschließende
	Firewalls.</para>
    </note>

    <para>Die Sicherheit kann durch den Einsatz einer
      <quote>zustandsorientierten Firewall</quote>
      (<foreignphrase>stateful firewall</foreignphrase>) weiter
      erhöht werden.  Dieser Typ Firewall überwacht alle offenen
      Verbindungen und erlaubt nur Datenverkehr von bereits
      bestehenden Verbindungen oder wenn eine neue Verbindung
      aufgebaut wird.</para>

    <para>Eine zustandsorientierte Firewall behandelt den Verkehr
      als einen bidirektionalen Austausch von Paketen während einer
      Session.  Wenn ein Zustand für eine passende Regel angegeben
      wird, erstellt die Firewall dynamisch interne Regeln für jedes
      Paket, das während dieser Session ausgetauscht wird.  Die
      Firewall hat ausreichend Möglichkeiten, um zu bestimmen, ob ein
      Paket zu einer Session gehört.  Alle Pakete, die nicht zu dieser
      Session passen, werden automatisch abgelehnt.</para>

    <para>Sobald die Session beendet ist, wird sie aus der
      dynamischen Zustandstabelle entfernt.</para>

    <para>Eine zustandsorientierte Filterung erlaubt es, sich auf die
      Sperrung bzw. Freigabe von neuen Sessions zu konzentrieren.
      Wenn eine neue Session genehmigt wird, werden alle nachfolgenden
      Pakete dieser Session automatisch erlaubt und betrügerische
      Pakete werden automatisch abgelehnt.  Wenn eine neue Session
      nicht genehmigt wird, werden alle nachfolgenden Pakete dieser
      Session abgelehnt.  Die zustandsorientierte Filterung bietet
      fortgeschrittene Fähigkeiten zur Abwehr von verschiedensten
      Angriffsmethoden, die von Angreifern eingesetzt werden.</para>

    <para><acronym>NAT</acronym> steht für <emphasis>Network Address
	Translation</emphasis>.  Die <acronym>NAT</acronym>-Funktion
      ermöglicht es einem privaten <acronym>LAN</acronym> hinter einer
      Firewall, sich eine einzelne vom <acronym>ISP</acronym>
      zugewiesene <acronym>IP</acronym>-Adresse zu teilen, auch wenn
      die Adresse dynamisch zugewiesen wird.  <acronym>NAT</acronym>
      ermöglicht den Internetzugriff für jeden Rechner im
      <acronym>LAN</acronym>, ohne dass der <acronym>ISP</acronym> für
      mehrere Internet-Konten bezahlt wird.</para>

    <para><acronym>NAT</acronym> übersetzt automatisch die private
      <acronym>IP</acronym>-Adresse auf die öffentliche
      <acronym>IP</acronym>-Adresse, sobald ein Paket für das
      öffentliche Internet die Firewall passiert.  Zusätzlich führt es
      auch die Übersetzung der Anwortpakete durch.</para>

    <para>Gemäß RFC 1918 sind die folgenden
      <acronym>IP</acronym>-Adressbereiche für private Netzwerke
      reserviert und werden nie ins öffentliche Internet
      weitergeleitet.  Daher sind diese Bereiche für den Einsatz
      mit <acronym>NAT</acronym> geeignet:</para>

    <itemizedlist>
      <listitem>
	<para><literal>10.0.0.0/8</literal></para>
      </listitem>

      <listitem>
	<para><literal>172.16.0.0/12</literal></para>
      </listitem>

      <listitem>
	<para><literal>192.168.0.0/16</literal></para>
      </listitem>
    </itemizedlist>

    <warning>
      <para>Seien Sie <emphasis>äußerst vorsichtig</emphasis> wenn Sie
	mit Firewallregeln arbeiten.  Durch eine falsche Konfiguration
	kann der Administrator den Zugriff auf den Server verlieren.
	Um auf der sicheren Seite zu sein, sollten Sie die anfängliche
	Konfiguration der Firewall von der lokalen Konsole
	durchführen, anstatt dass Sie dies aus der Ferne über
	<application>ssh</application> tun.</para>
    </warning>
  </sect1>

  <sect1 xml:id="firewalls-pf">
    <info>
      <title>PF</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>John</firstname>
	    <surname>Ferrell</surname>
	  </personname>
	  <contrib>Überarbeitet und aktualisiert von </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>firewall</primary>
      <secondary>PF</secondary>
    </indexterm>

    <para>In &os;&nbsp;5.3 wurde <application>PF</application> von
      OpenBSD in das Basissystem integriert.  Bei
      <application>PF</application> handelt es sich um eine komplette,
      voll ausgestattete Firewall, die optional auch
      <application>ALTQ</application> (Alternatives Queuing)
      unterstützt.  <application>ALTQ</application> stellt
      <foreignphrase>Quality of Service</foreignphrase>
      (<acronym>QoS</acronym>) zur Verfügung.</para>

    <para>Das OpenBSD-Projekt pflegt die maßgebliche Referenz von
      <application>PF</application> in der <link
	xlink:href="http://www.openbsd.org/faq/pf">PF FAQ</link>.
      Peter Hansteen betreut ein sehr ausführliches
      <application>PF</application>-Tutorial unter <link
	xlink:href="http://home.nuug.no/~peter/pf/">
	http://home.nuug.no/~peter/pf/</link>.</para>

    <warning>
      <para>Bedenken Sie beim Studium der <link
	  xlink:href="http://www.openbsd.org/faq/pf/">PF FAQ</link>,
	dass die <application>PF</application>-Version von &os;
	im Laufe der Jahre erheblich von der Version in OpenBSD
	abgewichen ist.  Nicht alle Eigenschaften funktionieren
	unter &os; genauso wie unter OpenBSD und umgekehrt.</para>
    </warning>

    <para>Die &a.pf; ist ein guter Anlaufpunkt für Fragen zur
      Konfiguration und dem Einsatz der
      <application>PF</application>-Firewall.  Überprüfen Sie
      aber zunächst die Archive der Mailingliste, bevor Sie eine
      Frage stellen.  Vielleicht wurde die Frage dort schon
      beantwortet.</para>

    <para>Dieser Abschnitt konzentriert sich auf
      <application>PF</application> in &os;.  Es wird beschrieben, wie
      <application>PF</application> und
      <application>ALTQ</application> aktiviert werden.  Zusätzlich
      wird demonstriert, wie Regelsätze auf einem &os;-System erstellt
      werden.</para>

    <sect2>
      <title><application>PF</application> aktivieren</title>

      <para>Um <application>PF</application> zu benutzen,
	muss zunächst das Kernelmodul geladen werden.  Dieser
	Abschnitt beschreibt die Einträge für
	<filename>/etc/rc.conf</filename>, die verwendet werden können
	um <application>PF</application> zu aktivieren.</para>

      <para>Beginnen Sie damit <literal>pf_enable=yes</literal> in
	<filename>/etc/rc.conf</filename> hinzuzufügen:</para>

      <screen>&prompt.root; <userinput>sysrc pf_enable=yes</userinput></screen>

      <para>&man.pfctl.8; beschreibt zusätzliche Optionen, die beim
	Start an <application>PF</application> übergeben werden
	können.  Fügen Sie diesen Eintrag in
	<filename>/etc/rc.conf</filename> hinzu und schreiben Sie die
	benötigten Optionen zwischen die Anführungszeichen:</para>

      <programlisting>pf_flags=""                     # additional flags for pfctl startup</programlisting>

      <para><application>PF</application> kann nicht gestartet werden,
	wenn es seine Konfigurationsdatei nicht findet.  In der
	Voreinstellung existiert unter &os; kein Regelsatz namens
	<filename>/etc/pf.conf</filename>.  Beispiel-Regelsätze finden
	Sie in <filename>/usr/share/examples/pf/</filename>.  Wenn bereits ein Regelsatz
	an anderer Stelle gespeichert wurde, fügen Sie in
	<filename>/etc/rc.conf</filename> einen Eintrag mit dem
	vollständigen Pfad zur Datei ein:</para>

      <programlisting>pf_rules="<replaceable>/path/to/pf.conf</replaceable>"</programlisting>

      <para>Protokollierungsfunktionen für
	<application>PF</application> werden von &man.pflog.4; zur
	Verfügung gestellt.  Fügen Sie
	<literal>pflog_enable=yes</literal> in
	<filename>/etc/rc.conf</filename> ein, um diese Funktion zu
	aktivieren:</para>

      <screen>&prompt.root; <userinput>sysrc pflog_enable=yes</userinput></screen>

      <para>Die folgenden Zeilen können zusätzlich hinzugefügt
	werden, um den Speicherort der Protokolldatei zu bestimmen und
	weitere Optionen beim Start an &man.pflog.4; zu
	übergeben:</para>

      <programlisting>pflog_logfile="/var/log/pflog"  # where pflogd should store the logfile
pflog_flags=""                  # additional flags for pflogd startup</programlisting>

      <para>Falls ein <acronym>LAN</acronym> hinter der Firewall
	existiert und die Pakete an die Rechner im
	<acronym>LAN</acronym> weitergeleitet werden müssen, oder
	wenn <acronym>NAT</acronym> benötigt wird, aktivieren Sie die
	folgende Option:</para>

      <programlisting>gateway_enable="YES"            # Enable as LAN gateway</programlisting>

      <para>Nachdem die Änderungen gespeichert wurden, kann
	<application>PF</application> mit Unterstützung für
	Protokollierung gestartet werden:</para>

      <screen>&prompt.root; <userinput>service pf start</userinput>
&prompt.root; <userinput>service pflog start</userinput></screen>

<!--
This is no longer true as of 9.x. It also references the CARP section
which doesn't explain how to use it...At some point it should.
      <indexterm>$
	<primary>kernel options</primary>
	<secondary>device pf</secondary>
      </indexterm>

      <indexterm>
	<primary>kernel options</primary>
	<secondary>device pflog</secondary>
      </indexterm>

      <indexterm>
	<primary>kernel options</primary>
	<secondary>device pfsync</secondary>
      </indexterm>

      <note>
	<para>While it is not necessary to compile
	  <application>PF</application> support into the &os; kernel,
	  some advanced features are not included, namely &man.pfsync.4;, which is a
	  pseudo-device that exposes certain changes to the state table
	  used by <application>PF</application>.  It can be paired with
	  &man.carp.4; to create failover firewalls using
	  <application>PF</application>.  More information on
	  <acronym>CARP</acronym> can be found in <xref linkend="carp"/>.</para>

	<para>The following <application>PF</application> kernel options
	  are available:</para>

	<programlisting>device pf
device pflog
device pfsync</programlisting>

	<para>where:</para>

	<para><literal>device pf</literal> enables PF support.</para>

	<para><literal>device pflog</literal> enables the optional
	  &man.pflog.4; pseudo network device which can be used to log
>>>>>>>>  traffic to a &man.bpf.4; descriptor.  The &man.pflogd.8;
>>>>>>>>  daemon can then be used to store the logging information to
>>>>>>>>  disk.</para>

	<para><literal>device pfsync</literal> enables the optional
	  &man.pfsync.4; pseudo-network device that is used to monitor
	  <quote>state changes</quote>.</para>
      </note>
-->

      <para>In der Voreinstellung liest <application>PF</application>
	seine Konfiguration aus <filename>/etc/pf.conf</filename> und
	modifiziert, verwirft oder akzeptiert Pakete anhand der
	Definitionen in dieser Datei.  &os; enthält mehrere
	Beispieldateien unter
	<filename>/usr/share/examples/pf/</filename>.  Auch die
	<link xlink:href="http://www.openbsd.org/faq/pf/">PF
	  FAQ</link> enthält sehr ausführliche Beispiele für
	<application>PF</application>-Regeln.</para>

      <para>Zur Steuerung von <application>PF</application> wird
	<command>pfctl</command> verwendet.  <xref linkend="pfctl"/>
	fasst einige nützliche Optionen für diesen Befehl zusammen.
	Eine Beschreibung aller verfügbaren Optionen finden Sie in
	&man.pfctl.8;.</para>

      <table xml:id="pfctl" frame="none" pgwide="1">
	<title>Nützliche <command>pfctl</command> Optionen</title>

	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Kommando</entry>
	      <entry>Aufgabe</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><command>pfctl -e</command></entry>
	      <entry><application>PF</application> aktivieren</entry>
	    </row>

	    <row>
	      <entry><command>pfctl -d</command></entry>
	      <entry><application>PF</application>
		deaktivieren</entry>
	    </row>

	    <row>
	      <entry><command>pfctl -F all -f
		  /etc/pf.conf</command></entry>
	      <entry>Alle Filterregeln zurücksetzen
		(<acronym>NAT</acronym>, Filter, Zustandstabelle) und
		<filename>/etc/pf.conf</filename> erneut
		einlesen.</entry>
	    </row>

	    <row>
	      <entry><command>pfctl -s [ rules | nat |
		  states ]</command></entry>
	      <entry>Zusammenfassung der Filterregeln,
		<application>NAT</application>-Regeln, oder der
		Zustandstabelle.</entry>
	    </row>

	    <row>
	      <entry><command>pfctl -vnf
		  /etc/pf.conf</command></entry>
	      <entry>Überprüft <filename>/etc/pf.conf</filename> auf
		Fehler, lädt aber die Filterregeln nicht neu.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <tip>
	<para><package>security/sudo</package> ist nützlich um
	  Kommandos mit erhöhten Berechtigungen auszuführen, wie
	  beispielsweise <command>pfctl</command>.  Das Programm kann
	  aus der Ports-Sammlung installiert werden.</para>
      </tip>

      <para>Um den ein- und ausgehenden Verkehr im Auge zu behalten,
	können Sie ein Werkzeug wie <package>sysutils/pftop</package>
	benutzen.  Sobald das Programm installiert ist, können Sie
	<application>pftop</application> ausführen, um einen Snapshot
	des Datenverkehrs zu sehen.  Das Format der Ausgabe ist der
	von &man.top.1; sehr ähnlich.</para>
    </sect2>

    <sect2 xml:id="pf-tutorial">
      <info>
	<title><application>PF</application> Regelsätze</title>

	<authorgroup>
	  <author>
	    <personname>
	      <firstname>Peter</firstname>
	      <surname>Hansteen</surname>
	      <othername>N. M.</othername>
	    </personname>
	    <contrib>Beigetragen von </contrib>
	  </author>
	</authorgroup>
      </info>

      <para>Dieser Abschnitt beschreibt die Erstellung von angepassten
	Regelsätzen.  Es wird mit dem einfachsten Regelsatz begonnen
	auf dem dann weitere aufgebaut werden, um die
	Konzepte und Funktionen von <application>PF</application> an
	einigen konkreten Beispielen zu verdeutlichen.</para>

      <para>Der einfachste Regelsatz gilt für einen Rechner, der
	keine Dienste anbietet und Zugriff auf das Internet haben
	soll.  Für diesen minimalen Regelsatz wird
	<filename>/etc/pf.conf</filename> wie folgt
	konfiguriert:</para>

      <programlisting>block in all
pass out all keep state</programlisting>

      <para>Die erste Regel blockiert jeglichen eingehenden
	Datenverkehr.  Die zweite Regel erlaubt ausgehende
	Verbindungen von diesem Rechner, während die
	Zustandsinformationen dieser Verbindungen gespeichert werden.
	Diese Zustandsinformationen machen es möglich, den
	Antwortverkehr für diese Verbindungen zu erlauben.  Der
	Regelsatz wird mit dem folgenden Befehl geladen:</para>

      <screen>&prompt.root; <userinput>pfctl -e ; pfctl -f /etc/pf.conf</userinput></screen>

      <para>Neben den Zustandsinformationen verfügt
	<application>PF</application> über
	<firstterm>Listen</firstterm> und
	<firstterm>Makros</firstterm>.  Diese können bei der
	Erstellung der Regeln definiert werden.  Makros können Listen
	enthalten und sie müssen vor ihrer ersten Benutzung definiert
	sein.  Fügen Sie beispielsweise folgende Zeilen an den Anfang
	des Regelsatzes:</para>

      <programlisting>tcp_services = "{ ssh, smtp, domain, www, pop3, auth, pop3s }"
udp_services = "{ domain }"</programlisting>

      <para><application>PF</application> versteht sowohl Portnamen
	als auch Portnummern, solange die Namen in
	<filename>/etc/services</filename> aufgeführt sind.  Dieses
	Beispiel erstellt zwei Makros.  Das erste ist eine Liste mit
	sieben <acronym>TCP</acronym>-Portnamen, die zweite Liste
	enthält einen <acronym>UDP</acronym>-Portnamen.  Sobald ein
	Makro definiert ist, kann es in den Regeln verwendet werden.
	In diesem Beispiel wird der gesamte Datenverkehr geblockt, mit
	Ausnahme der Verbindungen die von diesem Rechner initiiert
	wurden und sich auf einen der angegebenen
	<acronym>TCP</acronym>-Dienste oder den
	<acronym>UDP</acronym>-Dienst beziehen:</para>

      <programlisting>tcp_services = "{ ssh, smtp, domain, www, pop3, auth, pop3s }"
udp_services = "{ domain }"
block all
pass out proto tcp to any port $tcp_services keep state
pass proto udp to any port $udp_services keep state</programlisting>

      <para>Obwohl <acronym>UDP</acronym> als zustandsloses Protokoll
	betrachtet wird, ist <application>PF</application> in der Lage
	einige Zustandsinformationen zu verfolgen.  Wenn
	beispielsweise eine <acronym>UDP</acronym>-Abfrage für einen
	Nameserver das System verlässt, wird
	<application>PF</application> nach der Antwort Ausschau halten
	und das Antwortpaket durch lassen.</para>

      <para>Nachdem der Regelsatz verändert wurde, muss er neu geladen
	werden:</para>

      <screen>&prompt.root; <userinput>pfctl -f /etc/pf.conf</userinput></screen>

      <para>Wenn keine Syntaxfehler festgestellt werden, wird
	<command>pfctl</command> keine Ausgabe erzeugen.  Die Syntax
	kann auch getestet werden, bevor der Regelsatz geladen
	wird:</para>

      <screen>&prompt.root; <userinput>pfctl -nf /etc/pf.conf</userinput></screen>

      <para>Die Option <option>-n</option> bewirkt, dass die Regeln
	nur interpretiert, jedoch nicht geladen werden.  Dies bietet
	die Möglichkeit, alle Fehler zu korrigieren.  Es wird immer
	der letzte gültige Regelsatz geladen, bis
	<application>PF</application> entweder deaktiviert, oder ein
	neuer Regelsatz geladen wird.</para>

      <tip>
	<para>Wenn Sie beim Laden oder Prüfen des Regelsatzes noch die
	  Option <option>-v</option> hinzufügen, wird
	  <command>pfctl</command> den komplett interpretierten
	  Regelsatz anzeigen.  Dies ist äußerst nützlich, wenn Sie
	  versuchen Fehler im Regelsatz zu finden.</para>
      </tip>

      <sect3 xml:id="pftut-gateway">
	<title>Einfaches Gateway mit <acronym>NAT</acronym></title>

	<para>Dieser Abschnitt zeigt wie ein &os;-System mit
	  <application>PF</application> als Gateway konfiguriert wird.
	  Das Gateway muss über mindestens zwei Netzwerkkarten
	  verfügen, die jeweils mit einem separaten Netzwerk verbunden
	  sind.  In diesem Beispiel ist <filename>xl0</filename> mit
	  dem Internet verbunden und <filename>xl1</filename> ist mit
	  dem internen Netzwerk verbunden.</para>

	<para>Aktivieren Sie zunächst das Gateway, damit der Rechner
	  den Netzwerkverkehr von einer Schnittstelle zur nächsten
	  weiterleiten kann.  Diese
	  <application>sysctl</application>-Einstellung sorgt dafür,
	  dass <acronym>IPv4</acronym>-Pakete weitergeleitet
	  werden:</para>

	<screen>&prompt.root; <userinput>sysctl net.inet.ip.forwarding=1</userinput></screen>

	<para>So leiten Sie <acronym>IPv6</acronym>-Datenverkehr
	  weiter:</para>

	<screen>&prompt.root; <userinput>sysctl net.inet6.ip6.forwarding=1</userinput></screen>

	<para>Um diese Einstellungen beim Systemstart zu aktivieren,
	  fügen Sie sie mit Hilfe von &man.sysrc.8; in
	  <filename>/etc/rc.conf</filename> ein:</para>
	
	<screen>&prompt.root; <userinput>sysrc gateway_enable=yes</userinput>
&prompt.root; <userinput>sysrc ipv6_gateway_enable=yes</userinput></screen>

	<para>Prüfen Sie mit <command>ifconfig</command>, dass beide
	  Schnittstellen vorhanden und aktiv sind.</para>

	<para>Als nächstes erstellen Sie die nötigen
	  <application>PF</application>-Regeln, damit das Gateway den
	  Datenverkehr weiterleiten kann.  Die folgende Regel erlaubt
	  den zustandsorientierten Verkehr aus dem Internet zu den
	  Rechnern im Netzwerk:</para>

	<programlisting>pass in on xl1 from xl1:network to xl0:network port $ports keep state</programlisting>

	<para>Diese Regel erlaubt lediglich den Datenverkehr über das
	  Gateway auf der internen Schnittstelle.  Damit die Pakete
	  noch weiter gehen, wird eine passende Regel benötigt:</para>

	<programlisting>pass out on xl0 from xl1:network to xl0:network port $ports keep state</programlisting>

	<para>Obwohl diese beiden Regeln funktionieren, werden sie
	  in der Praxis so spezifisch selten benötigt.  Ein lesbarer
	  Regelsatz ist oft ein sicherer Regelsatz.  Der Rest dieses
	  Abschnitts zeigt, wie Sie die Regeln so einfach und lesbar
	  wie möglich halten.  Zum Beispiel könnten die beiden Regeln
	  zu einer Regel zusammengefasst werden:</para>

	<programlisting>pass from xl1:network to any port $ports keep state</programlisting>

	<para>Die Notation <literal>interface:network</literal> kann
	  durch ein Makro ersetzt werden, um den Regelsatz besser
	  lesbar zu machen.  Zum Beispiel könnte für das Netzwerk an
	  der internen Schnittstelle (<literal>xl0:network</literal>)
	  ein Makro namens <literal>$localnet</literal> definiert
	  werden.  Alternativ könnte für die Definition von
	  <literal>$localnet</literal> auch eine
	  <emphasis>IP-Adresse/Netzmaske</emphasis> Notation verwendet
	  werden, um ein Netzwerk zu bezeichnen, beispielsweise
	  <literal>192.168.100.1/24</literal> für ein privates
	  Subnetz.</para>

	<para>Bei Bedarf kann für <literal>$localnet</literal> auch
	  eine Liste von Netzwerken definiert werden.  Abhängig von
	  den Bedürfnissen kann <literal>$localnet</literal> auch für
	  eine typische Regel wie folgt verwendet werden:</para>

	<programlisting>pass from $localnet to any port $ports keep state</programlisting>

	<para>Der folgende Regelsatz erlaubt sämtlichen Verkehr, der
	  von den Rechnern im internen Netzwerk initiiert wird.
	  Zunächst werden zwei Makros definiert, die die externen und
	  internen 3COM-Schnittstellen repräsentieren.</para>

	<note>
	  <para>Bei Einwählverbindungen wird <filename>tun0</filename>
	    für die externe Schnittstelle verwendet.  Bei
	    <acronym>ADSL</acronym>-Verbindungen, insbesondere denen
	    die <acronym>PPP</acronym> over Ethernet
	    (<acronym>PPPoE</acronym>) verwenden, ist die richtige
	    externe Schnittstelle <filename>tun0</filename> und nicht
	    die physische Ethernet-Schnittstelle.</para>
	</note>

	<programlisting>ext_if = "xl0"	# macro for external interface - use tun0 for PPPoE
int_if = "xl1"	# macro for internal interface
localnet = $int_if:network
# ext_if IP address could be dynamic, hence ($ext_if)
nat on $ext_if from $localnet to any -&gt; ($ext_if)
block all
pass from { lo0, $localnet } to any keep state</programlisting>

	<para>Dieser Regelsatz führt die <acronym>NAT</acronym>-Regel
	  ein, die verwendet wird, um die Übersetzung der
	  Netzwerkadressen von den nicht-routebaren Adressen im
	  internen Netzwerk auf die <acronym>IP</acronym>-Adresse der
	  externen Schnittstelle zu handhaben.  Die Klammern im
	  letzten Teil der <acronym>NAT</acronym>-Regel
	  <literal>($ext_if)</literal> werden angegeben, wenn die
	  <acronym>IP</acronym>-Adresse der externen Schnittstelle
	  dynamisch zugewiesen wird.  Damit wird sichergestellt, dass
	  der Netzwerkverkehr ohne schwerwiegende Unterbrechungen
	  weiterläuft, auch wenn sich die externe
	  <acronym>IP</acronym>-Adresse ändert.</para>

	<para>Beachten Sie, dass dieser Regelsatz wahrscheinlich mehr
	  Verkehr aus dem Netzwerk zulässt, als eigentlich nötig ist.
	  Bei einem angemessenen Aufbau könnte folgendes Makro
	  erstellt werden:</para>

	<programlisting>client_out = "{ ftp-data, ftp, ssh, domain, pop3, auth, nntp, http, \
    https, cvspserver, 2628, 5999, 8000, 8080 }"</programlisting>

	<para>Dieses Makro wird dann in der Filterregel
	  benutzt:</para>

	<programlisting>pass inet proto tcp from $localnet to any port $client_out \
    flags S/SA keep state</programlisting>

	<para>Weitere <literal>pass</literal> Regeln werden
	  vielleicht noch benötigt.  Diese Regel aktiviert
	  <acronym>SSH</acronym> auf der externen
	  Schnittstelle:</para>

	<programlisting>pass in inet proto tcp to $ext_if port ssh</programlisting>

	<para>Dieses Makrodefinition und Regel erlaubt
	  <acronym>DNS</acronym> und <acronym>NTP</acronym> für
	  interne Clients:</para>

	<programlisting>udp_services = "{ domain, ntp }"
pass quick inet proto { tcp, udp } to any port $udp_services keep state</programlisting>

	<para>Beachten Sie das Schlüsselwort <literal>quick</literal>
	  in dieser Regel.  Da der Regelsatz aus mehreren Regeln
	  besteht, ist es wichtig, die Beziehungen zwischen den
	  einzelnen Regeln zu verstehen.  Die Regeln werden von oben
	  nach unten ausgewertet, in der Reihenfolge wie sie
	  geschrieben sind.  Für jedes Paket oder jede Verbindung, das
	  <application>PF</application> ausgewertet, wird die letzte
	  übereinstimmende Regel im Regelsatz angewendet.  Wenn jedoch
	  ein Paket auf eine Regel passt, welche das Schlüsselwort
	  <literal>quick</literal> enthält, wird das Paket
	  entsprechend dieser Regel behandelt und die
	  Regelverarbeitung wird gestoppt.  Diese Vorgehensweise ist
	  sehr nützlich, wenn eine Ausnahme von den allgemeinen Regeln
	  erforderlich ist.</para>
      </sect3>

      <sect3 xml:id="pftut-ftp">
	<title>Einen <acronym>FTP</acronym>-Proxy einrichten</title>

	<para>Die Konfiguration einer funktionierenden Regel für
	  <acronym>FTP</acronym> kann aufgrund der Beschaffenheit des
	  <acronym>FTP</acronym>-Protokolls problematisch sein.
	  <acronym>FTP</acronym> ist sehr viel älter als Firewalls
	  und schon vom Design her unsicher.  Die häufigsten Argumente
	  gegen eine Verwendung von <acronym>FTP</acronym>
	  sind:</para>

	<itemizedlist>
	  <listitem>
	    <para>Passwörter werden im Klartext übertragen.</para>
	  </listitem>

	  <listitem>
	    <para>Das Protokoll erfordert die Verwendung von
	      mindestens zwei <acronym>TCP</acronym>-Verbindungen
	      (Steuerung und Daten) auf separaten Ports.</para>
	  </listitem>

	  <listitem>
	    <para>Wenn eine Sitzung aufgebaut wird, werden die Daten
	      auf zufällig ausgewählten Ports übermittelt.</para>
	  </listitem>
	</itemizedlist>

	<para>All diese Punkte stellen Herausforderungen dar, noch
	  bevor die Client- oder Server-Software auf potenzielle
	  Sicherheitslücken überprüft wurde.  Es existieren aber auch
	  sichere Alternativen für die Dateiübertragung, wie
	  &man.sftp.1; oder &man.scp.1;, wo die Authentifizierung und
	  die Datenübertragung über eine verschlüsselte Verbindung
	  erfolgt.</para>

	<para>Für Situationen, in denen <acronym>FTP</acronym>
	  erforderlich ist, kann <application>PF</application> den
	  <acronym>FTP</acronym>-Datenverkehr an ein kleines
	  Proxy-Programm namens &man.ftp-proxy.8; weiterleiten.
	  Dieses Programm ist im Basissystem von &os; enthalten.  Die
	  Aufgabe des Proxies ist das dynamische Einfügen und
	  Entfernen von Regeln im Regelsatz.  Dies wird durch den
	  Einsatz von Ankern erreicht, damit der
	  <acronym>FTP</acronym>-Verkehr korrekt verarbeitet werden
	  kann.</para>

	<para>Fügen Sie folgende Zeilen in
	  <filename>/etc/rc.conf</filename> ein, um den Proxy zu
	  aktivieren:</para>

	<programlisting>ftpproxy_enable="YES"</programlisting>

	<para>Danach kann der Proxy mit <command>service ftp-proxy
	    start</command> gestartet werden.</para>

	<para>Für die Grundkonfiguration müssen drei weitere Einträge
	  in <filename>/etc/pf.conf</filename> hinzugefügt werden.
	  Zunächst werden die Anker hinzugefügt, die der Proxy für die
	  <acronym>FTP</acronym>-Sitzungen verwendet:</para>

	<programlisting>nat-anchor "ftp-proxy/*"
rdr-anchor "ftp-proxy/*"</programlisting>

	<para>Dann wird eine <literal>pass</literal>-Regel benötigt,
	  damit der <acronym>FTP</acronym>-Datenverkehr durch den
	  Proxy geleitet werden kann.</para>

	<para>Die Regeln für Umleitung und <acronym>NAT</acronym>
	  müssen vor den eigentlichen Filterregeln definiert werden.
	  Fügen Sie diese <literal>rdr</literal>-Regel unmittelbar
	  nach der <acronym>NAT</acronym>-Regel ein:</para>

	<programlisting>rdr pass on $int_if proto tcp from any to any port ftp -&gt; 127.0.0.1 port 8021</programlisting>

	<para>Zum Schluss muss der umgeleitete Verkehr die Firewall
	  passieren dürfen:</para>

	<programlisting>pass out proto tcp from $proxy to any port ftp</programlisting>

	<para><literal>$poxy</literal> enthält die Adresse, an dem der
	  Proxy-Daemon gebunden ist.</para>

	<para>Speichern Sie <filename>/etc/pf.conf</filename> und
	  laden Sie die Regeln neu.  Prüfen Sie von einem Client, ob
	  die <acronym>FTP</acronym>-Verbindungen
	  funktionieren:</para>

	<screen>&prompt.root; <userinput>pfctl -f /etc/pf.conf</userinput></screen>

	<para>Dieses Beispiel umfasst eine Grundkonfiguration, in der
	  die Rechner im lokalen Netzwerk Zugriff auf entfernte
	  <acronym>FTP</acronym>-Server benötigen.  Diese
	  Konfiguration sollte mit den meisten
	  <acronym>FTP</acronym>-Clients und -Servern gut
	  funktionieren.  Das Verhalten von &man.ftp-proxy.8; kann
	  durch diverse Optionen in <literal>ftpproxy_flags</literal>
	  beeinflusst werden.  Einige Clients und Server haben
	  bestimmte Marotten, die bei der Konfiguration berücksichtigt
	  werden müssen.  Es kann zum Beispiel notwendig sein, den
	  <acronym>FTP</acronym>-Datenverkehr für den Proxy einer
	  bestimmten Warteschlange zuzuweisen.</para>

	<para>Es besteht auch die Möglichkeit einen
	  <acronym>FTP</acronym>-Server mit
	  <application>PF</application> und &man.ftp-proxy.8; zu
	  schützen.  Konfigurieren Sie einen separaten
	  <command>ftp-proxy</command> mit <option>-R</option> für den
	  Reverse-Modus auf einem separaten Port und einer eigenen
	  Umleitungsregel.</para>
      </sect3>

      <sect3 xml:id="pftut-icmp">
	<title><acronym>ICMP</acronym> verwalten</title>

	<para>Viele Werkzeuge zur Fehlerbehebung in
	  <acronym>TCP/IP</acronym>-Netzwerken verlassen sich auf das
	  <foreignphrase>Internet Control Message
	    Protocol</foreignphrase> (<acronym>ICMP</acronym>), das
	  speziell für diese Zwecke entwickelt wurde.</para>

	<para>Das <acronym>ICMP</acronym>-Protokoll sendet und
	  empfängt Kontrollnachrichten zwischen Rechnern und Gateways,
	  hauptsächlich um ungewöhnliche Bedingungen auf dem Weg zum
	  Zielrechner zu berichten.  Router verwenden
	  <acronym>ICMP</acronym> um Paketgrößen und andere
	  Übertragungsparameter zu ermitteln.  Dieser Prozess ist auch
	  als <emphasis>Path <acronym>MTU</acronym>
	    Discovery</emphasis> bekannt.</para>

	<para>Aus der Sicht einer Firewall sind einige
	  <acronym>ICMP</acronym>-Kontrollnachrichten anfällig für
	  bekannte Angriffsmethoden.  Zwar ist die Fehlerbehebung
	  einfacher, wenn alle <acronym>ICMP</acronym>-Pakete
	  bedingungslos durch gelassen werden, aber dass macht es auch
	  für Angreifer leichter, Informationen über das Netzwerk zu
	  extrahieren.  Aus diesen Gründen ist die folgende Regel nicht
	  optimal:</para>

	<programlisting>pass inet proto icmp from any to any</programlisting>

	<para>Eine Lösung besteht darin, nur den
	  <acronym>ICMP</acronym>-Verkehr aus dem lokalen Netz zu
	  akzeptieren, während <acronym>ICMP</acronym>-Pakete von
	  außerhalb des Netzwerks verworfen werden:</para>

	<programlisting>pass inet proto icmp from $localnet to any keep state
pass inet proto icmp from any to $ext_if keep state</programlisting>

	<para>Es stehen noch weitere Optionen zur Verfügung, die die
	  Flexibilität von <application>PF</application>
	  demonstrieren.  Anstatt beispielsweise alle
	  <acronym>ICMP</acronym>-Nachrichten zu erlauben, kann man
	  die Nachrichten angeben, die von &man.ping.8; und
	  &man.traceroute.8; verwendet werden.  Beginnen Sie damit,
	  ein Makro für diese Art von Nachrichten zu
	  definieren:</para>

	<programlisting>icmp_types = "echoreq"</programlisting>

	<para>Erstellen Sie dann eine Regel, die das eben erstellte
	  Makro benutzt:</para>

	<programlisting>pass inet proto icmp all icmp-type $icmp_types keep state</programlisting>

	<para>Wenn weitere Arten von
	  <acronym>ICMP</acronym>-Nachrichten benötigt werden, kann
	  die Liste <literal>icmp_types</literal> einfach erweitert
	  werden.  Geben Sie <command>more
	    /usr/src/sbin/pfctl/pfctl_parser.c</command> ein, um
	  eine Liste der von <application>PF</application>
	  unterstützten <acronym>ICMP</acronym>-Nachrichten zu sehen.
	  Die Webseite <link
	    xlink:href="http://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml">
	    http://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml</link>
	  enthält eine Erklärung für jeden Nachrichtentyp.</para>

	<para>Da &unix; <command>traceroute</command> in der
	  Voreinstellung <acronym>UDP</acronym> verwendet, wird eine
	  weitere Regel benötigt:</para>

	<programlisting># allow out the default range for traceroute(8):
pass out on $ext_if inet proto udp from any to any port 33433 &gt;&lt; 33626 keep state</programlisting>

	<para>Da <command>TRACERT.EXE</command> unter
	  &microsoft.windows;-Systemen <acronym>ICMP</acronym> Echo
	  Request Meldungen verwendet, ist nur die erste Regel
	  notwendig um Traces für solche Systeme zu ermöglichen.
	  &unix; <command>traceroute</command> kann aber auch andere
	  Protokolle verwenden, zum Beispiel <acronym>ICMP</acronym>
	  Echo Request, wenn der Schalter <option>-I</option> benutzt
	  wird.  Details finden Sie in &man.traceroute.8;.</para>

	<sect4 xml:id="pftut-pathmtudisc">
	  <title>Path <acronym>MTU</acronym> Discovery</title>

	  <para>Internet-Protokolle sind so ausgelegt, dass sie
	    geräteunabhängig sind.  Eine Folge davon ist, dass die
	    optimale Paketgröße nicht immer zuverlässig vorhergesagt
	    werden kann.  Das größte Hindernis ist hier die
	    <emphasis>Maximum Transmission Unit</emphasis>
	    (<literal>MTU</literal>), welche die Obergrenze für die
	    Paketgröße festlegt.  Die <acronym>MTU</acronym> für die
	    Schnittstelle des Systems können Sie sich mit
	    <command>ifconfig</command> anzeigen lassen.</para>

	  <para><acronym>TCP/IP</acronym> benutzt ein Verfahren, das
	    als <foreignphrase>path MTU discovery</foreignphrase>
	    bekannt ist, um die korrekte Paketgröße für eine
	    Verbindung zu bestimmen.  Dieses Verfahren sendet Pakete
	    unterschiedlicher Größe mit dem Flag <quote>do not
	      fragment</quote> und erwartet ein
	    <acronym>ICMP</acronym>-Antwortpaket vom Typ
	    <quote>type 3, code 4</quote>, wenn die Obergrenze
	    erreicht worden ist.  Typ 3 bedeutet <quote>Ziel nicht
	      erreichbar</quote> und Code 4 ist die Abkürzung für
	    <quote>Fragmentierung nötig, aber Do-not-Fragment Flag ist
	      gesetzt</quote>.  Um <foreignphrase>path MTU
	      discovery</foreignphrase> zu erlauben und damit
	    Verbindungen zu anderen <acronym>MTU</acronym>s zu
	    unterstützen, fügen Sie dem Makro
	    <literal>icmp_types</literal> den Typ <literal>destination
	      unreachable</literal> hinzu:</para>

	  <programlisting>icmp_types = "{ echoreq, unreach }"</programlisting>

	  <para>Da die <literal>pass</literal>-Regel bereits das Makro
	    verwendet, braucht es nicht geändert werden um den neuen
	    <acronym>ICMP</acronym>-Typ zu unterstützen:</para>

	  <programlisting>pass inet proto icmp all icmp-type $icmp_types keep state</programlisting>

	  <para><application>PF</application> kann alle Variationen
	    von <acronym>ICMP</acronym>-Typen und Codes filtern.  Eine
	    Liste der verfügbaren Typen und Codes ist in &man.icmp.4;
	    und &man.icmp6.4; dokumentiert.</para>
	</sect4>
      </sect3>

      <sect3 xml:id="pftut-tables">
	<title>Tabellen benutzen</title>

	<para>Manchmal sind bestimmte Daten für die Filterung und
	  Weiterleitung interessant, jedoch wäre eine Definition einer
	  solchen Filterregel für einen Regelsatz viel zu lang.
	  <application>PF</application> unterstützt die Verwendung von
	  Tabellen.  Dies sind definierte Listen, die verändert werden
	  können, ohne den gesamten Regelsatz neu laden zu müssen.
	  Zudem können diese Listen sehr schnell durchsucht werden.
	  Tabellennamen sind immer in <literal>&lt; &gt;</literal>
	  eingeschlossen und sehen wie folgt aus:</para>

	<programlisting>table &lt;clients&gt; { 192.168.2.0/24, !192.168.2.5 }</programlisting>

	<para>In diesem Beispiel ist das Netzwerk
	  <literal>192.168.2.0/24</literal> Teil der Tabelle.
	  <literal>192.168.2.5</literal> wurde im dem Operator
	  <literal>!</literal> ausgeschlossen und ist somit nicht Teil
	  der Tabelle.  Es ist auch möglich Tabellen aus Dateien zu
	  laden, wo jeder Eintrag in einer separaten Zeile steht.
	  Dieses Beispiel verwendet dazu die Datei
	  <filename>/etc/clients</filename>:</para>

	<programlisting>192.168.2.0/24
!192.168.2.5</programlisting>

	<para>Um sich auf diese Datei zu beziehen, definieren Sie die
	  Tabelle wie folgt:</para>

	<programlisting>table &lt;clients&gt; persist file "/etc/clients"</programlisting>

	<para>Sobald die Tabelle definiert ist, kann eine Filterregel
	  Bezug darauf nehmen:</para>

	<programlisting>pass inet proto tcp from &lt;clients&gt; to any port $client_out flags S/SA keep state</programlisting>

	<para>Die Inhalte einer Tabelle können mit
	  <command>pfctl</command> direkt verändert werden.  Dieses
	  Beispiel fügt ein weiteres Netzwerk zur Tabelle
	  hinzu:</para>

	<screen>&prompt.root; <userinput>pfctl -t clients -T add 192.168.1.0/16</userinput></screen>

	<para>Beachten Sie, dass auf diese Weise vorgenommene
	  Änderungen direkt übernommen werden, jedoch bei einem
	  Neustart des Systems oder bei einem Stromausfall verloren
	  gehen.  Um die Änderungen dauerhaft zu speichern, müssen sie
	  in der Definition der Tabelle oder in der Datei, auf die
	  sich die Tabelle bezieht, bearbeitet werden.  Mit einem
	  &man.cron.8; Job und einem Befehl wie
	  <command>pfctl -t clients -T show &gt;/etc/clients</command>
	  können Sie auch eine Kopie der Tabelle auf Platte speichern
	  und dann in regelmäßigen Abständen aktualisieren.
	  Alternativ kann <filename>/etc/clients</filename> auch mit
	  den Tabelleneinträgen, die sich aktuell im Speicher
	  befinden, aktualisiert werden.</para>

	<screen>&prompt.root; <userinput>pfctl -t clients -T replace -f /etc/clients</userinput></screen>
      </sect3>

      <sect3 xml:id="pftut-overload">
	<title>Verwendung von Tabellen zum Schutz von
	  <acronym>SSH</acronym></title>

	<para>Benutzer, die <acronym>SSH</acronym> auf einer externen
	  Schnittstelle ausführen, haben wahrscheinlich schon einmal
	  ähnliche Meldungen in den Protokolldateien gesehen:</para>

	<programlisting>Sep 26 03:12:34 skapet sshd[25771]: Failed password for root from 200.72.41.31 port 40992 ssh2
Sep 26 03:12:34 skapet sshd[5279]: Failed password for root from 200.72.41.31 port 40992 ssh2
Sep 26 03:12:35 skapet sshd[5279]: Received disconnect from 200.72.41.31: 11: Bye Bye
Sep 26 03:12:44 skapet sshd[29635]: Invalid user admin from 200.72.41.31
Sep 26 03:12:44 skapet sshd[24703]: input_userauth_request: invalid user admin
Sep 26 03:12:44 skapet sshd[24703]: Failed password for invalid user admin from 200.72.41.31 port 41484 ssh2</programlisting>

	<para>Diese Meldungen deuten auf einen Brute-Force-Angriff
	  hin, bei dem ein Angreifer oder ein Programm versucht,
	  den Benutzernamen und das Passwort zu erraten, um Zugriff
	  auf das System zu bekommen.</para>

	<para>Wenn der Zugriff über <acronym>SSH</acronym> für
	  berechtigte Benutzer erforderlich ist, kann eine Änderung
	  des Standard-Ports für <acronym>SSH</acronym> einen gewissen
	  Schutz bieten.  Allerdings bietet
	  <application>PF</application> eine elegantere Lösung für
	  dieses Problem.  <literal>pass</literal>-Regeln können
	  Einschränkungen für Dinge enthalten, die ein verbindender
	  Rechner tun kann.  Bei einem Verstoß gegen diese
	  Einschränkungen kann dann dem betroffenen Rechner der
	  Zugriff teilweise oder ganz entzogen werden.  Es ist sogar
	  möglich, alle bestehenden Verbindungen zu trennen, falls die
	  Grenze überschritten wird.</para>

	<para>Um dies zu konfigurieren, erstellen Sie folgende Tabelle
	  im Regelsatz:</para>

	<programlisting>table &lt;bruteforce&gt; persist</programlisting>

	<para>Fügen Sie dann ziemlich am Anfang der Filterregeln
	  folgende Regeln hinzu, um die Brute-Force-Angriffe zu
	  blocken und gleichzeitig berechtigte Verbindungen zu
	  erlauben:</para>

	<programlisting>block quick from &lt;bruteforce&gt;
pass inet proto tcp from any to $localnet port $tcp_services \
    flags S/SA keep state \
    (max-src-conn <replaceable>100</replaceable>, max-src-conn-rate <replaceable>15/5</replaceable>, \
    overload &lt;bruteforce&gt; flush global)</programlisting>

	<para>Der Teil in Klammern definiert die Grenzwerte.  Die
	  Zahlen sollten an die lokalen Anforderungen angepasst
	  werden.  Die Zeilen können wie folgt interpretiert
	  werden:</para>

	<para><literal>max-src-conn</literal> definiert die maximal
	  erlaubte Anzahl gleichzeitiger Verbindungen von einem
	  Rechner.</para>

	<para><literal>max-src-conn-rate</literal> definiert die
	  maximal erlaubte Anzahl neuer Verbindungen eines einzelnen
	  Rechners (<replaceable>15</replaceable>) pro Anzahl von
	  Sekunden (<replaceable>5</replaceable>).</para>

	<para><literal>overload &lt;bruteforce&gt;</literal> bedeutet,
	  dass jeder Rechner, der diesen Grenzwert überschreitet, zur
	  Tabelle <literal>bruteforce</literal> hinzugefügt wird.
	  Diese Filterregel blockiert jeglichen Datenverkehr von
	  Adressen aus der Tabelle
	  <literal>bruteforce</literal>.</para>

	<para><literal>flush global</literal> besagt, dass alle
	  (<literal>global</literal>) Verbindungen dieses Rechners
	  getrennt (<literal>flush</literal>) werden, wenn der
	  Grenzwert erreicht wird.</para>

	<note>
	  <para>Diese Filterregeln helfen nicht bei langsamen
	    Brute-Force-Angriffen, wie sie in <link
	      xlink:href="http://home.nuug.no/~peter/hailmary2013/">
	      http://home.nuug.no/~peter/hailmary2013/</link>
	    beschrieben sind.</para>
	</note>

	<para>Dieser Beispielregelsatz dient lediglich als
	  Illustration.  Wenn Sie allgemein eine große Anzahl an
	  Verbindungen erlauben wollen, aber gleichzeitig
	  bei <acronym>SSH</acronym> etwas restriktiver vorgehen
	  möchten, können Sie die obige Regel ergänzen:</para>

	<programlisting>pass quick proto { tcp, udp } from any to any port ssh \
    flags S/SA keep state \
    (max-src-conn 15, max-src-conn-rate 5/3, \
    overload &lt;bruteforce&gt; flush global)</programlisting>

	<note>
	  <!-- XXX Overloaders == agressive Rechner -->
	  <title>Es ist möglicherweise nicht notwendig, alle
	    aggressiven Rechner zu blockieren</title>

	  <para>Es ist zu erwähnen, dass der
	    <literal>overlaod</literal>-Mechanismus eine allgemeine
	    Technik darstellt, die nicht auf <acronym>SSH</acronym>
	    beschränkt ist.  Außerdem ist es nicht immer optimal,
	    Datenverkehr von aggressiven Rechnern zu
	    blockieren.</para>

	  <para>Eine <literal>overload</literal>-Regel kann
	    beispielsweise benutzt werden, um einen Mail- oder
	    Webserver zu schützen.  Die
	    <literal>overload</literal>-Tabelle könnte dann in einer
	    Regel verwendet werden, um aggressive Rechner einer
	    Warteschlange mit geringerer Bandbreite zuzuweisen, oder
	    den Rechner auf eine bestimtme Webseite umzuleiten.</para>
	</note>

	<para>Im Laufe der Zeit werden die Tabellen durch die
	  <literal>overload</literal>-Regeln immer größer und belegen
	  immer mehr Speicher.  Manchmal wird eine geblockte
	  <acronym>IP</acronym>-Adresse einem Rechner dynamisch
	  zugewiesen, der eigentlich berechtigt ist, mit den Rechnern
	  im lokalen Netzwerk zu kommunizieren.</para>

	<para>Für solche Situationen bietet <command>pfctl</command>
	  die Möglichkeit, Tabelleneinträge auslaufen zu lassen.
	  Dieses Kommando würde beispielsweise Einträge aus der
	  Tabelle <literal>&lt;bruteforce&gt;</literal> löschen,
	  die seit <literal>86400</literal> Sekunden nicht mehr
	  referenziert wurden:</para>

	<screen>&prompt.root; <userinput>pfctl -t bruteforce -T expire 86400</userinput></screen>

	<para>Eine ähnliche Funktionalität bietet
	  <package>security/expiretable</package>, welches Einträge
	  entfernt, die für einen bestimmten Zeitraum nicht
	  referenziert wurden.</para>

	<para>Nach der Installation kann
	  <application>expiretable</application> benutzt werden, um
	  Einträge aus der Tabelle
	  <literal>&lt;bruteforce&gt;</literal> nach einer bestimmten
	  Zeit zu entfernen.  Dieses Beispiel entfernt alle Einträge,
	  die älter sind als 24 Stunden:</para>

	<programlisting>/usr/local/sbin/expiretable -v -d -t 24h bruteforce</programlisting>
      </sect3>

      <sect3 xml:id="pftut-spamd">
	<title>Schutz vor <acronym>SPAM</acronym></title>

	<para>Im Gegensatz zum <application>spamd</application>-Daemon
	  von <application>spamassassin</application>, kann
	  <package>mail/spamd</package> zusammen mit
	  <application>PF</application> den <acronym>SPAM</acronym>
	  direkt an der Firewall abwehren.  Dieser
	  <application>spamd</application> wird in
	  <application>PF</application> über einen Satz von
	  Umleitungen konfiguriert.</para>

	<para>Spammer neigen dazu, eine große Anzahl von Nachrichten
	  zu versenden.  Dabei nutzten Sie
	  <acronym>SPAM</acronym>-freundliche Netzwerke und gekaperte
	  Rechner, welche dann ziemlich schnell bei sogenannten
	  <foreignphrase>Blacklists</foreignphrase> gemeldet
	  werden.</para>

	<para>Wenn eine <acronym>SMTP</acronym>-Verbindung von einer
	  Adresse in der Blacklist empfangen wird, präsentiert
	  <application>spamd</application> einen Banner und schaltet
	  sofort in einen Modus, in dem die Antworten auf den
	  <acronym>SMTP</acronym>-Verkehr jeweils ein Byte groß sind.
	  Diese Technik, die möglichst viel Zeit des Spammers
	  verschwenden soll, wird
	  <foreignphrase>Tarpitting</foreignphrase> genannt.  Die
	  spezifische Implementierung, welche ein Byte
	  <acronym>SMTP</acronym>-Antworten verwendet, wird als
	  <foreignphrase>Stuttering</foreignphrase> bezeichnet.</para>

	<para>Dieses Beispiel zeigt das grundlegende Verfahren zur
	  Konfiguration von <application>spamd</application> mit
	  automatisch aktualisierten Blacklists.  Für weitere
	  Informationen lesen die Manualpages, die zusammen mit
	  <package>mail/spamd</package> installiert werden.</para>

	<procedure>
	  <title>Konfiguration von
	    <application>spamd</application></title>

	  <step>
	    <para>Installieren Sie das Paket oder den Port
	      <package>mail/spamd</package>.  Um
	      <application>spamd</application>'s Greylisting-Funktion
	      zu nutzen, muss &man.fdescfs.5; in
	      <filename>/dev/fd</filename> eingehängt werden.  Fügen
	      Sie folgende Zeile in <filename>/etc/fstab</filename>
	      ein:</para>

	    <programlisting>fdescfs /dev/fd fdescfs rw 0 0</programlisting>

	    <para>Danach hängen Sie das Dateisystem ein:</para>

	    <screen>&prompt.root; <userinput>mount fdescfs</userinput></screen>
	  </step>

	  <step>
	    <para>Fügen Sie folgende Zeilen in den
	      <application>PF</application>-Regelsatz ein:</para>

	    <programlisting>table &lt;spamd&gt; persist
table &lt;spamd-white&gt; persist
rdr pass on $ext_if inet proto tcp from &lt;spamd&gt; to \
    { $ext_if, $localnet } port smtp -&gt; 127.0.0.1 port 8025
rdr pass on $ext_if inet proto tcp from !&lt;spamd-white&gt; to \
    { $ext_if, $localnet } port smtp -&gt; 127.0.0.1 port 8025</programlisting>

	    <para>Die beiden Tabellen <literal>&lt;spamd&gt;</literal>
	      und <literal>&lt;spam-white&gt;</literal> sind von
	      großer Bedeutung.  <acronym>SMTP</acronym>-Verkehr von
	      einer Adresse, die in <literal>&lt;spamd&gt;</literal>
	      aber nicht in <literal>&lt;spamd-white&gt;</literal>
	      ist, wird an den <application>spamd</application>-Daemon
	      auf Port 8025 umgeleitet.</para>
	  </step>

	  <step>
	    <para>Im nächsten Schritt wird
	      <application>spamd</application> in
	      <filename>/usr/local/etc/spamd.conf</filename>
	      konfiguriert und einige Parameter werden in
	      <filename>/etc/rc.conf</filename> hinzugefügt.</para>

	    <para>Die Installation von <package>mail/spamd</package>
	      enthält eine Beispielkonfiguration
	      (<filename>/usr/local/etc/spamd.conf.sample</filename>)
	      und eine Manualpage für <filename>spamd.conf</filename>.
	      Beziehen Sie sich für zusätzliche Konfigurationsoptionen
	      auf diese Dokumentation.</para>

	    <para>Die Konfigurationsdatei enthält einen Block, in dem
	      die <literal>all</literal>-Liste definiert ist, die
	      wiederum weitere Listen spezifiziert:</para>

	    <programlisting>all:\
    :traplist:whitelist:</programlisting>

	    <para>Dieser Eintrag fügt die gewünschten Blacklists,
	      getrennt durch einen Doppelpunkt (<literal>:</literal>),
	      hinzu.  Um auch eine Whitelist zu verwenden, fügen Sie
	      den Namen unmittelbar hinter dem Namen der Blacklist
	      ein.  Zum Beispiel:
	      <literal>:Blacklist:Whitelist:</literal>.</para>

	    <para>Danach folgt die Definition der verwendeten
	      Blacklist:</para>

	    <programlisting>traplist:\
    :black:\
    :msg="SPAM. Your address %A has sent spam within the last 24 hours":\
    :method=http:\
    :file=www.openbsd.org/spamd/traplist.gz</programlisting>

	    <para>In der ersten Zeile steht der Name der Blacklist und
	      die zweite Zeile gibt den Typ an.  Das Feld
	      <literal>msg</literal> enthält die Nachricht, die dem
	      Absender während des <acronym>SMTP</acronym>-Dialogs
	      angezeigt wird.  Das Feld <literal>mehtod</literal> legt
	      fest, wie <application>spamd-setup</application> die
	      Listen bezieht; unterstützte Methoden sind
	      <literal>http</literal>, <literal>ftp</literal>,
	      <literal>file</literal> und ein externes Programm via
	      <literal>exec</literal>.  Im letzten Feld gibt
	      <literal>file</literal> den Namen der Datei an, die
	      <application>spamd</application> erwartet.</para>

	    <para>Die Definition der Whitelist ist ähnlich.  Das Feld
	      <literal>msg</literal> wird jedoch nicht definiert, da
	      eine Meldung hier nicht erforderlich ist:</para>

	    <programlisting>whitelist:\
    :white:\
    :method=file:\
    :file=/var/mail/whitelist.txt</programlisting>

	    <tip>
	      <title>Wählen Sie die Datenquellen mit Sorgfalt:</title>

	      <para>Bei der Verwendung von sämtlichen Blacklists aus
		der Beispieldatei <filename>spamd.conf</filename>
		würden große Teile des Internets geblockt.  Der
		Administrator muss diese Datei bearbeiten, um eine
		optimale Konfiguration zu erzielen.  Dazu gehört auch
		die Auswahl von geeigneten Blacklists und, wenn nötig,
		die Erstellung von benutzerdefinierten Listen.</para>
	    </tip>

	    <para>Als nächstes fügen Sie folgenden Eintrag in
	      <filename>/etc/rc.conf</filename> hinzu.  Zusätzliche
	      Optionen sind in der Manualpage beschrieben:</para>

	    <programlisting>spamd_flags="-v" # use "" and see spamd-setup(8) for flags</programlisting>

	    <para>Wenn Sie fertig sind, starten Sie
	      <application>spamd</application> durch die Eingabe von
	      <command>service obspamd start</command>.  Führen Sie
	      die weitere Konfiguration mit
	      <command>spamd-setup</command> durch.  Erstellen Sie zum
	      Schluss einen &man.cron.8;-Job, der
	      <command>spamd-setup</command> in regelmäßigen Abständen
	      aufruft, um die Listen zu aktualisieren.</para>
	  </step>
	</procedure>

	<para>Auf einem typischen Gateway vor dem Mailserver, werden
	  Rechner innerhalb von wenigen Minuten geblockt.</para>

	<para><application>PF</application> unterstützt auch
	  <firstterm>Greylisting</firstterm>, das Nachrichten von
	  unbekannten Rechnern vorübergehend mit
	  <replaceable>45n</replaceable>-Codes ablehnt.  Nachrichten
	  von diesen Rechnern werden bei einem erneuten Versuch nach
	  einer angemessenen Zeit durchgelassen.  Nachrichten von
	  Rechnern, die nach RFC 1123 und RFC 2821 konfiguriert sind,
	  werden sofort durchgelassen.</para>

	<para>Weitere Informationen über Greylisting finden Sie unter
	  <link xlink:href="http://www.greylisting.org/">
	  greylisting.org</link>.  Das Erstaunlichste an Greylisting
	  ist, neben der einfachen Benutzung, dass es immer noch
	  funktioniert.  Spammer und Malware-Autoren gelingt es
	  bislang nur schwer, diese Technik zu umgehen.</para>

	<para>Die grundsätzliche Vorgehensweise zur Konfiguration von
	  Greylisting ist wie folgt:</para>

	<procedure>
	  <title>Konfiguration von Greylisting</title>

	  <step>
	    <para>Stellen Sie sicher, dass &man.fdescfs.5; eingehängt
	      ist.  Dies wird in Schritt 1 der vorherigen Prozedur
	      beschrieben.</para>
	  </step>

	  <step>
	    <para>Um <application>spamd</application> im
	      Greylisting-Modus auszuführen, fügen Sie folgende Zeilen
	      in <filename>/etc/rc.conf</filename> ein:</para>

	    <programlisting>spamd_grey="YES"  # use spamd greylisting if YES</programlisting>

	    <para>Lesen Sie die Manualpage von
	      <application>spamd</application> für Beschreibungen von
	      zusätzlichen Parametern.</para>
	  </step>

	  <step>
	    <para>Starten Sie die Dienste, um die Konfiguration von
	      Greylisting abzuschließen:</para>

	    <screen>&prompt.root; <userinput>service obspamd restart</userinput>
&prompt.root; <userinput>service spamlogd start</userinput></screen>
	  </step>
	</procedure>

	<para>Hinter den Kulissen führen die
	  <application>spamdb</application>-Datenbank und
	  <application>spamlogd</application> wesentliche Aufgaben der
	  Greylisting-Funktion aus.  <application>spamdb</application>
	  ist die Schnittstelle für den Administrator, der über den
	  Inhalt der Datenbank <filename>/var/db/spamdb</filename>
	  Blaklists, Whitelists und Greylists verwaltet.</para>
      </sect3>

      <sect3 xml:id="pftut-hygiene">
	<title>Netzwerk-Hygiene</title>

	<para>Dieser Abschnitt beschreibt die Verwendung von
	  <literal>block-policy</literal>, <literal>scrub</literal>
	  und <literal>antispoof</literal>, mit denen das Verhalten
	  des Regelsatzes weiter optimiert werden kann.</para>

	<para>Die Option <literal>block-policy</literal> kann im
	  Teil <literal>options</literal> des Regelwerks konfiguriert
	  werden, vor den Umleitungen und den eigentlichen
	  Filterregeln.  Diese Option legt fest, welche Rückmeldung
	  <application>PF</application> an einen geblockten Rechner
	  sendet.  Es existieren zwei mögliche Werte:
	  <literal>drop</literal> verwirft das Paket ohne Rückmeldung
	  und <literal>return</literal> gibt eine Statusmeldung, wie
	  etwa <computeroutput>Connection refused</computeroutput>
	  zurück.</para>

	<para>Die Voreinstellung ist <literal>drop</literal>.  Geben
	  Sie den gewünschten Wert ein, um die
	  <literal>block-policy</literal>-Richtlinie zu ändern:</para>

	<programlisting>set block-policy return</programlisting>

	<para><literal>scrub</literal> ist ein Schlüsselwort in
	  <application>PF</application>, das die Paket-Normalisierung
	  aktiviert.  Dieser Prozess fügt fragmentierte Pakete wieder
	  zusammen und blockt <acronym>TCP</acronym>-Pakete mit
	  ungültigen Flag-Kombinationen.  Ein aktiviertes
	  <literal>scrub</literal> bietet einen gewissen Schutz gegen
	  Angriffe, die auf die falsche Handhabung von fragmentierten
	  Paketen aufbauen.  Es stehen viele Optionen zur Verfügung,
	  jedoch sollte die einfachste Form für die meisten
	  Konfigurationen ausreichend sein:</para>

	<programlisting>scrub in all</programlisting>

	<para>Einige Dienste, wie beispielsweise
	  <acronym>NFS</acronym>, erfordern eine bestimmte Handhabung
	  von fragmentierten Paketen.  Weitere Informationen finden
	  Sie unter <link
	    xlink:href="https://home.nuug.no/~peter/pf/en/scrub.html">https://home.nuug.no/~peter/pf/en/scrub.html</link>.</para>

	<para>Dieses Beispiel fügt fragmentierte Pakete wieder
	  zusammen, löscht das <quote>do not fragment</quote>-Bit und
	  setzt die maximale Segmentgröße auf 1440 Bytes:</para>

	<programlisting>scrub in all fragment reassemble no-df max-mss 1440</programlisting>

	<para>Der <literal>antispoof</literal>-Mechanismus bietet
	  einen Schutz gegen gefälschte
	  <acronym>IP</acronym>-Adressen.  Dabei werden hauptsächlich
	  Pakete verworfen, die auf der falschen Schnittstellen
	  ankommen.</para>

	<para>Folgende Regeln verwerfen gefälschte Adressen, wenn sie
	  aus dem Internet oder dem lokalen Netzwerk stammen:</para>

	<programlisting>antispoof for $ext_if
antispoof for $int_if</programlisting>
      </sect3>

      <sect3 xml:id="pftut-unrouteables">
	<title>Handhabung von nicht-routebaren Adressen</title>

	<para>Sogar bei einem richtig konfigurierten
	  <acronym>NAT</acronym>-Gateway müssen Sie vielleicht die
	  Fehlkonfiguration anderer Personen ausgleichen.  Ein
	  typischer Fehler besteht darin, nicht-routebare Adressen ins
	  Internet zu lassen.  Da der Verkehr von nicht-routebaren
	  Adressen Teil eines <acronym>DoS</acronym>-Angriffs sein
	  kann, sollten Sie in Betracht ziehen, diesen Verkehr
	  explizit an der externen Schnittstelle des Netzwerks zu
	  blockieren.</para>

	<para>In diesem Beispiel wird ein Makro erstellt, das die
	  nicht-routebaren Adressen enthält.  Datenverkehr von und zu
	  diesen Adressen wird dann an der externen Schnittstelle des
	  Gateways verworfen.</para>

	<programlisting>martians = "{ 127.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12, \
	      10.0.0.0/8, 169.254.0.0/16, 192.0.2.0/24, \
	      0.0.0.0/8, 240.0.0.0/4 }"

block drop in quick on $ext_if from $martians to any
block drop out quick on $ext_if from any to $martians</programlisting>
      </sect3>
    </sect2>

    <sect2>
      <title><application>ALTQ</application> aktivieren</title>

      <para>Unter &os; kann <application>ALTQ</application> zusammen
	mit <application>PF</application> benutzt werden, um Quality
	of Service (<acronym>QoS</acronym>) bereitzustellen.  Sobald
	<application>ALTQ</application> aktiviert ist, können
	Warteschlangen definiert werden, mit denen Sie die Priorität
	für ausgehende Pakete festlegen können.</para>

      <para>Bevor Sie <application>ALTQ</application> aktivieren,
	sollten Sie &man.altq.4; lesen und sicherstellen, das der
	Treiber der Netzwerkkarte diese Funktion unterstützt.</para>

      <para><application>ALTQ</application> steht nicht als ladbares
	Kernelmodul zur Verfügung.  Wenn die Netzwerkkarte des Systems
	<application>ALTQ</application> unterstützt, erstellen Sie
	nach den Anweisungen in <xref linkend="kernelconfig"/> einen
	angepassten Kernel.  Als erstes muss
	<application>ALTQ</application> aktiviert werden.  Zudem ist
	mindestens eine weitere Option nötig, um den Algorithmus für
	die Warteschlange zu bestimmen:</para>

      <programlisting>options         ALTQ
options         ALTQ_CBQ        # Class Based Queuing (CBQ)
options         ALTQ_RED        # Random Early Detection (RED)
options         ALTQ_RIO        # RED In/Out
options         ALTQ_HFSC       # Hierarchical Packet Schedule (HFSC)
options         ALTQ_PRIQ       # Priority Queuing (PRIQ)</programlisting>

      <para>Die folgenden Algorithmen stehen zur Verfügung:</para>

      <variablelist>
	<varlistentry>
	  <term>CBQ</term>
	  <listitem>
	    <para>Class Based Queuing (<acronym>CBQ</acronym>) erlaubt
	      es, die Bandbreite einer Verbindung in verschiedene
	      Klassen oder Warteschlangen zu unterteilen, um die
	      Priorität von Datenpaketen basierend auf Filterregeln zu
	      beeinflussen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>RED</term>
	  <listitem>
	    <para>Random Early Detection (<acronym>RED</acronym>) wird
	      eingesetzt, um eine Überlastung des Netzwerks zu
	      vermeiden.  Dazu ermittelt <acronym>RED</acronym> die
	      Größe der Warteschlange und vergleicht diesen Wert mit
	      den minimalen und maximalen Grenzwerten der
	      Warteschlange.  Ist die Warteschlange größer als das
	      erlaubte Maximum, werden alle neuen Pakete nach dem
	      Zufallsprinzip verworfen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>RIO</term>
	  <listitem>
	    <para>Random Early Detection In and Out
	      (<acronym>RIO</acronym>).  Dieser Modus verwaltet
	      mehrere Warteschlangen durchschnittlicher Größe mit
	      mehreren Schwellwerten, eine für jedes
	      <acronym>QoS</acronym>-Level.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>HFSC</term>
	  <listitem>
	    <para>Hierachical Fair Service Curve Packet Scheduler
	      (<acronym>HFSC</acronym>) wird in <link
		xlink:href="http://www-2.cs.cmu.edu/~hzhang/HFSC/main.html">
		http://www-2.cs.cmu.edu/~hzhang/HFSC/main.html</link>
	      beschrieben.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>PRIQ</term>
	  <listitem>
	    <para>Priority Queuing (<acronym>PRIQ</acronym>) lässt den
	      Verkehr einer Warteschlange mit höherer Priorität zuerst
	      durch.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>Weitere Informationen über diese Algorithmen und Beispiele
	für Regelsätze finden Sie in den <uri
	  xlink:href="https://web.archive.org/web/20151109213426/http://www.openbsd.org/faq/pf/queueing.html">
	  OpenBSD Archiven</uri>.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="firewalls-ipfw">
    <title>IPFW</title>

    <indexterm>
      <primary>Firewall</primary>
      <secondary>IPFW</secondary>
    </indexterm>

    <para><application>IPFW</application> ist eine
      <foreignphrase>Stateful-Firewall</foreignphrase>
      für &os;, die sowohl <acronym>IPv4</acronym> als auch
      <acronym>IPv6</acronym> unterstützt.  Die Firewall setzt sich
      aus mehreren Komponenten zusammen: dem Kernel Firewall
      Filter-Prozessor mit integriertem Paket-Accounting,
      Protokollfunktionen, <acronym>NAT</acronym>, dem
      &man.dummynet.4; <foreignphrase>Traffic-Shaper</foreignphrase>,
      sowie Weiterleitungs-, Bridge- und ipstealth-Funktionen.</para>

    <para>&os; enthält mit <filename>/etc/rc.firewall</filename> ein
      Beispielregelwerk, welches mehrere Firewall-Typen für
      gebräuchliche Szenarien definiert und unerfahrene Anwender
      dabei unterstützen soll, ein geeignetes Regelwerk zu erstellen.
      <application>IPFW</application> besitzt eine leistungsstarke
      Syntax, mit der erfahrene Benutzer ihre eigenen Regeln
      anfertigen können, um den Sicherheitsanforderungen der
      jeweiligen Umgebung gerecht zu werden.</para>

    <para>Diser Abschnitt beschreibt, wie
      <application>IPFW</application> aktiviert wird und bietet einen
      Überblick über die Regelsyntax.  Zudem werden mehrere Regelsätze
      für gebräuchliche Konfigurationsszenarien vorgestellt.</para>

    <sect2 xml:id="firewalls-ipfw-enable">
      <title><application>IPFW</application> aktivieren</title>

      <indexterm>
	<primary><application>IPFW</application></primary>
	<secondary>aktivieren</secondary>
      </indexterm>

      <para>Das &os; Basissystem enthält für
	<application>IPFW</application> ein ladbares Kernelmodul, was
	bedeutet, dass kein angepasster Kernel benötigt wird, um
	<application>IPFW</application> zu benutzen.</para>

      <para>Wenn Sie eine statische Unterstützung für
	<application>IPFW</application> in den Kernel kompilieren
	wollen, lesen Sie <xref linkend="firewalls-ipfw-kernelconfig"/>.</para>

      <para>Um <application>IPFW</application> beim Systemstart zu
	aktivieren, fügen Sie <literal>firewall_enable="YES"</literal>
	in <filename>/etc/rc.conf</filename> ein:</para>

      <screen>&prompt.root; <userinput>sysrc firewall_enable="YES"</userinput></screen>

      <para>Wenn Sie einen der von &os; zur Verfügung gestellten
	Firewall-Profile benutzen möchten, fügen Sie eine weitere
	Zeile hinzu, in der Sie das Profil bestimmen:</para>

      <screen>&prompt.root; <userinput>sysrc firewall_type="open"</userinput></screen>

      <para>Folgende Profile stehen zur Verfügung:</para>

      <itemizedlist>
	<listitem>
	  <para><literal>open</literal>: gestattet jeglichen
	    Datenverkehr.</para>
	</listitem>

	<listitem>
	  <para><literal>client</literal>: schützt lediglich diesen
	    Rechner.</para>
	</listitem>

	<listitem>
	  <para><literal>simple</literal>: schützt das gesamte
	    Netzwerk.</para>
	</listitem>

	<listitem>
	  <para><literal>closed</literal>: blockiert den gesamten
	    <acronym>IP</acronym>-Datenverkehr, mit Ausnahme des
	    Verkehrs über die Loopback-Schnittstelle.</para>
	</listitem>

	<listitem>
	  <para><literal>workstation</literal>: schützt lediglich
	    diesen Rechner und verwendet zustandsorientierte
	    Regeln.</para>
	</listitem>

	<listitem>
	  <para><literal>UNKNOWN</literal>: deaktiviert das Laden von
	    Firewallregeln.</para>
	</listitem>

	<listitem>
	  <para><filename><replaceable>filename</replaceable></filename>:
	    absoluter Pfad zu einer Datei, in der die Firewallregeln
	    definiert sind.</para>
	</listitem>
      </itemizedlist>

      <para>Wenn Sie <literal>firewall_type</literal> auf
	<literal>client</literal> oder <literal>simple</literal>
	setzen, müssen Sie die voreingestellten Regeln in
	<filename>/etc/rc.firewall</filename> anpassen, damit sie
	der Konfiguration des Systems entsprechen.</para>

      <para>Beachten Sie, dass das Profil <literal>filename</literal>
	verwendet wird, um ein benutzerdefiniertes Regelwerk zu
	laden.</para>

      <para>Eine alternative Möglichkeit, um ein benutzerdefiniertes
	Regelwerk zu laden, bietet die Variable
	<literal>firewall_script</literal>.  Setzen Sie die Variable
	auf den absoluten Pfad eines
	<emphasis>ausführbaren Skripts</emphasis>, welches die Befehle
	für <application>IPFW</application> enthält.  Die Beispiele in
	diesem Abschnitt gehen davon aus, dass
	<literal>firewall_script</literal> auf
	<filename>/etc/ipfw.rules</filename> gesetzt ist.</para>

      <screen>&prompt.root; <userinput>sysrc firewall_script="/etc/ipfw.rules"</userinput></screen>

      <para>Die Protokollierung wird mit diesem Befehl
	aktiviert:</para>

      <screen>&prompt.root; <userinput>sysrc firewall_logging="YES"</userinput></screen>

      <warning>
	<para>Es werden nur Firewallregeln mit der Option
	  <option>log</option> protokolliert.  Die voreingestellten
	  Regeln enthalten diese Option nicht und müssen manuell
	  hinzugefügt werden.  Daher ist es ratsam, diese Regeln zu
	  bearbeiten.  Außerdemkann eine Rotation der Protokolle
	  erwünscht sein, wenn die Protokolle in einer separaten Datei
	  gespeichert werden.</para>
      </warning>

      <para>Es existiert keine Variable für
	<filename>/etc/rc.conf</filename>, um die Protokollierung zu
	begrenzen.  Um die Anzahl der Protokoll-Nachrichten pro
	Verbindungsversuch zu begrenzen, legen Sie die Anzahl der
	Einträge in <filename>/etc/sysctl.conf</filename> fest:</para>

      <screen>&prompt.root; <userinput>echo "net.inet.ip.fw.verbose_limit=<replaceable>5</replaceable>" >> /etc/sysctl.conf</userinput></screen>

      <para>Um die Protokollierung über die spezielle Schnittstelle
	<literal>ipfw0</literal> zu aktivieren, fügen Sie stattdessen
	folgende Zeile in <filename>/etc/rc.conf</filename>
	hinzu:</para>

      <screen>&prompt.root; <userinput>sysrc firewall_logif="YES"</userinput></screen>

      <para>Benutzen Sie dann <application>tcpdump</application>, um
	zu sehen, was protokolliert wird:</para>

      <screen>&prompt.root; <userinput>tcpdump -t -n -i ipfw0</userinput></screen>

      <tip>
	<para>Durch die Protokollierung entsteht kein Aufwand, es sei
	  denn, <application>tcpdump</application> wird an die
	  Schnittstelle angebunden.</para>
      </tip>

      <para>Nachdem Sie die Änderungen vorgenommen haben, können Sie
	die Firewall starten.  Um auch die Anzahl der
	Protokoll-Nachrichten zu konfigurieren, setzen Sie mit
	<command>sysctl</command> den gewünschten Wert:</para>

      <screen>&prompt.root; <userinput>service firewall start</userinput>
&prompt.root; <userinput>sysctl net.inet.ip.fw.verbose_limit=<replaceable>5</replaceable></userinput></screen>
    </sect2>

    <sect2 xml:id="firewalls-ipfw-rules">
      <title><application>IPFW</application> Regel-Syntax</title>

      <para>Wenn ein Paket die Firewall <quote>betritt</quote>, also
	von der Firewall geprüft und verarbeitet wird, wird die
	erste Regel des Regelwerkes auf das Paket angewandt.  Auf
	diese Weise wird in aufsteigender Reihenfolge der Regelnummer
	mit allen weiteren Regeln verfahren.  Falls die
	Selektionsparameter einer Regel auf ein Paket zutreffen, wird
	das Aktionsfeld der Regel ausgeführt und die Prüfung
	des Pakets beendet, nachfolgende Regeln werden also nicht
	mehr geprüft.  Diese Suchmethode wird als <quote>erster
	  Treffer gewinnt</quote> bezeichnet.  Falls keine Regel auf
	das betreffende Paket zutrifft, wird die obligatorische
	<application>IPFW</application>-Rückfallregel mit der Nummer
	65535 angewendet und das Paket wird ohne Rückantwort
	verworfen.  Wenn das Paket jedoch einer Regel mit dem
	Schlüsselwort <literal>count</literal>,
	<literal>skipto</literal> oder <literal>tee</literal>
	entspricht, wird die Prüfung des Pakets weiter
	fortgeführt.  Weitere Details darüber, wie diese
	Schlüsselwörter die Regelverarbeitung beeinflussen, finden Sie
	in &man.ipfw.8;.</para>

      <indexterm>
	<primary><application>IPFW</application></primary>
	<secondary>Regel-Syntax</secondary>
      </indexterm>

      <para>Bei der Erstellung der
	<application>IPFW</application>-Regeln müssen die
	Schlüsselwörter in der folgenden Reihenfolge geschrieben
	werden.  Einige Schlüsselwörter müssen zwingend angegeben
	werden, während andere optional sind.  Die Wörter in
	Großbuchstaben repräsentieren Variablen und die Wörter in
	Kleinbuchstaben müssen den Variablen vorangestellt werden.
	Das Zeichen <literal>#</literal> wird benutzt, um einen
	Kommentar einzuleiten und kann am Ende einer Regel oder in
	einer eigenen Zeile stehen.  Leerzeilen werden
	ignoriert.</para>

      <para><replaceable>CMD RULE_NUMBER set SET_NUMBER ACTION log
	  LOG_AMOUNT PROTO from SRC SRC_PORT to DST DST_PORT
	  OPTIONS</replaceable></para>

      <para>Dieser Abschnitt bietet einen Überblick über diese
	Schlüsselwörter und deren Optionen.  Es ist keine vollständige
	Liste aller verfügbaren Optionen.  Eine vollständige
	Beschreibung der Regel-Syntax, die Sie verwenden können um
	<application>IPFW</application>-Regeln zu erstellen, finden
	Sie in &man.ipfw.8;.</para>

      <variablelist>
	<varlistentry>
	  <term>CMD</term>
	  <listitem>
	    <para>Jede Regel muss mit <parameter>ipfw add</parameter>
	      beginnen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>RULE_NUMBER</term>
	  <listitem>
	    <para>Jede Regel gehört zu einer Nummer zwischen
	      <literal>1</literal> und <literal>65534</literal>.  Die
	      Nummer wird verwendet, um die Reihenfolge der
	      Regelverarbeitung zu kennzeichnen.  Es ist möglich, dass
	      mehrere Regeln dieselbe Nummer haben.  In diesem Fall
	      werden sie entsprechend der Reihenfolge angewendet, in
	      der sie aufgenommen wurden.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>SET_NUMBER</term>
	  <listitem>
	    <para>Jede Regel ist einer <emphasis>Set</emphasis>-Nummer
	      zwischen <literal>0</literal> und <literal>31</literal>
	      zugeordnet.  Sets können einzeln aktiviert oder
	      deaktiviert werden.  Dies macht es möglich, eine Reihe
	      von Regeln schnell hinzuzufügen oder zu löschen.  Wenn
	      <literal>SET_NUMBER</literal> nicht angegeben ist, wird
	      die Regel zu Set <literal>0</literal>
	      hinzugefügt.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>ACTION</term>
	  <listitem>
	    <para>Eine Regel kann mit einer der folgenden Aktionen
	      verknüpft werden.  Die festgelegte Aktion wird
	      ausgeführt, wenn das Paket den Selektionskriterien der
	      Regel entspricht.</para>

	    <para><parameter>allow | accept | pass |
		permit</parameter>: All diese Aktionen sind
	      gleichbedeutend und erlauben Pakete, die mit der Regel
	      übereinstimmen.</para>

	    <para><parameter>check-state</parameter>: Diese Aktion
	      überprüft die Regel in der dynamischen Zustandstabelle.
	      Bei einer Übereinstimmung wird die mit der dynamischen
	      Regel verknüpfte Aktion ausgeführt, andernfalls wird mit
	      der Prüfung gegen die nächste Regel fortgefahren.  Die
	      Regel <literal>check-state</literal> hat selbst kein
	      Selektionskriterium.  Sollte keine
	      <literal>check-state</literal>-Regel im Regelwerk
	      vorhanden sein, wird die dynamische Zustandstabelle beim
	      ersten Vorkommen einer <literal>keep-state</literal>-
	      oder <literal>limit</literal>-Regel überprüft.</para>

	    <para><parameter>count</parameter>: Aktualisiert die
	      Zähler für alle Pakete, die mit dieser Regel
	      übereinstimmen.  Die Prüfung wird mit der nächsten Regel
	      fortgesetzt.</para>

	    <para><parameter>deny | drop</parameter>: Diese Aktionen
	      sind gleichbedeutend und verwerfen Pakete, die mit
	      dieser Regel übereinstimmen.</para>

	    <para>Es stehen noch weitere Aktionen zur Verfügung.
	      Einzelheiten finden Sie in &man.ipfw.8;.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>LOG_AMOUNT</term>
	  <listitem>
	    <para>Erfüllt ein Paket die Selektionskriterien mit dem
	      Schlüsselwort <literal>log</literal>, wird dies von
	      &man.syslogd.8; mit der Annotation
	      <literal>SECURITY</literal> protokolliert.  Dies erfolgt
	      allerdings nur, wenn die Anzahl der protokollierten
	      Pakete der betreffenden Regel die definierte
	      <literal>LOG_AMOUNT</literal>-Grenze nicht übersteigt.
	      Wenn <literal>LOG_AMOUNT</literal> nicht definiert ist,
	      wird die Grenze aus dem Wert von
	      <varname>net.inet.ip.fw.verbose_limit</varname>
	      benutzt.  Ein Wert von <literal>0</literal> bedeutet
	      eine unbegrenzte Protokollierung.  Wird eine definierte
	      Grenze erreicht, wird die Protokollierung für diese
	      Regel deaktiviert.  Um die Protokollierung zu
	      reaktivieren, können Sie den Protokoll- oder Paketzähler
	      mit <command>ipfw resetlog</command>
	      zurücksetzen.</para>

	    <note>
	      <para>Die Protokollierung findet statt, nachdem alle
		Selektionskriterien geprüft und bevor die endgültige
		Aktion auf das Paket angewendet wird.  Der
		Administrator entscheidet, welche Regel protokolliert
		werden soll.</para>
	    </note>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>PROTO</term>
	  <listitem>
	    <para>Dieser optionale Wert wird verwendet, um einen
	      beliebigen Protokollnamen oder -nummer aus
	      <filename>/etc/protocols</filename> gegen das Paket zu
	      prüfen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>SRC</term>
	  <listitem>
	    <para>Nach dem Schlüsslwort<literal>from</literal> muss
	      die Quelladresse stehen, oder ein Schlüsselwort, das die
	      Quelladresse darstellt.  Eine Adresse wird dargestellt
	      duch <literal>any</literal>, <literal>me</literal> (jede
	      Adresse dieses Systems), <literal>me6</literal> (jede
	      <acronym>IPv6</acronym>-Adresse dieses Systems), oder
	      <literal>table</literal> gefolgt von der Nummer der
	      Tabelle, welche die Adressen enthält.
	      <acronym>IP</acronym>-Adressen können in
	      <acronym>CIDR</acronym>-Notation geschrieben werden.
	      Beispielsweise <literal>1.2.3.4/25</literal> oder
	      <literal>1.2.3.4:255.255.255.128</literal>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>SRC_PORT</term>
	  <listitem>
	    <para>Optional kann ein Quellport über eine Nummer oder
	      einen Namen aus <filename>/etc/services</filename>
	      spezifiziert werden.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>DST</term>
	  <listitem>
	    <para>Nach dem Schlüsselwort <literal>to</literal> muss
	      die Zieladresse stehen, oder ein Schlüsselwort, das die
	      Zieladresse darstellt.  Es können die gleichen
	      Schlüsselwörter und Adressen benutzt werden, die bereits
	      im SRC-Abschnitt beschrieben wurden.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>DST_PORT</term>
	  <listitem>
	    <para>Optional kann ein Zielport über eine Nummer oder
	      einen Namen aus <filename>/etc/services</filename>
	      spezifiziert werden.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>OPTIONS</term>
	  <listitem>
	    <para>Nach der Quell- und Zieladresse können noch weitere
	      Optionen angegeben werden.  Wie der Name bereits sagt,
	      sind <literal>OPTIONS</literal> optional.  Häufig
	      verwendete Optionen sind <literal>in</literal> oder
	      <literal>out</literal>, mit denen die Richtug des
	      Pakets bestimmt wird, <literal>icmptypes</literal>
	      gefolgt vom Typ der <acronym>ICMP</acronym>-Nachricht,
	      sowie <literal>keep-state</literal>.</para>

	    <para>Wenn ein Paket auf eine
	      <parameter>keep-state</parameter>-Regel zutrifft, wird
	      die Firewall eine dynamische Regel erstellen, die dem
	      bidirektionalen Datenverkehr zwischen den gleichen
	      Quell- und Zieladressen mit dem gleichen Protokoll
	      entspricht.</para>

	    <para>Dynamische Regeln sind für einen sogenannten
	      <foreignphrase>SYN-flood</foreignphrase>-Angriff
	      anfällig, bei dem eine riesige Anzahl an dynamischen
	      Regeln erzeugt wird.  Verwenden Sie die Option
	      <literal>limit</literal>, um einen solchen Angriff
	      entgegenzuwirken.  Diese Option begrenzt die Anzahl
	      der gleichzeitig möglichen Sitzungen.  Es handelt sich
	      dabei um einen Zähler, der die Anzahl von dynamischen
	      Regeln in Kombination mit der Quelladresse verfolgt.
	      Übersteigt der Zähler den durch <literal>limit</literal>
	      definierten Wert, wird das Paket verworfen.</para>

	    <para>Es stehen noch viele weitere Optionen zur Verfügung.
	      &man.ipfw.8; enthält eine Beschreibung der einzelnen
	      Optionen.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2>
      <title>Beispiel für einen Regelsatz</title>

      <para>Dieser Abschnitt die Erstellung eines Firewall-Skripts
	namens <filename>/etc/ipfw.rules</filename> mit
	zustandsorientierten (<foreignphrase>stateful</foreignphrase>
	Regeln.  Alle Regeln in diesem Beispiel verwenden die Optionen
	<literal>in</literal> und <literal>out</literal>, um die
	Richtung des Pakets zu verdeutlichen.  Zusätzlich wird
	<literal>via</literal>
	<replaceable>interface-name</replaceable> benutzt, um die
	Schnittstelle für das Paket zu prüfen.</para>

      <note>
	<para>Bei den anfänglichen Tests mit dem Firewall-Regelsatz
	  sollten Sie vielleicht folgende Einstellung
	  vornehmen:</para>

	<programlisting>net.inet.ip.fw.default_to_accept="1"</programlisting>

	<para>Dies legt die Standardregel von &man.ipfw.8; etwas
	  großzügiger fest, als das voreingestellte
	  <literal>default deny ip from any to any</literal>.  Dadurch
	  sinkt die Gefahr, sich nach einem Neustart des Systems
	  auszusperren.</para>
      </note>

      <para>Das Firewall-Skript beginnt mit einem Hinweis, dass es
	sich um ein Bourne Shell-Skript handelt.  Danach werden alle
	vorhandenen Filterregeln gelöscht.  Anschließend wird die
	Variable <literal>cmd</literal> erstellt, sodass
	<literal>ipfw add</literal> nicht jedes mal von Hand
	eingegeben werden muss.  Die Variable <literal>pif</literal>
	repräsentiert die mit dem Internet verbundene
	Schnittstelle.</para>

      <programlisting>#!/bin/sh
# Flush out the list before we begin.
ipfw -q -f flush

# Set rules command prefix
cmd="ipfw -q add"
pif="dc0"     # interface name of NIC attached to Internet</programlisting>

      <para>Jetzt folgen die eigentlichen Filterregeln.  Diese ersten
	beiden Regeln erlauben den Datenverkehr aus dem internen
	Netzwerk und über die Loopback-Schnittstelle:</para>

      <programlisting># Change xl0 to LAN NIC interface name
&dollar;cmd 00005 allow all from any to any via xl0

# No restrictions on Loopback Interface
&dollar;cmd 00010 allow all from any to any via lo0</programlisting>

      <para>Die nächste Regel erlaubt Pakete, für die ein Eintrag
	in der dynamischen Zustandstabelle existiert:</para>

      <programlisting>&dollar;cmd 00101 check-state</programlisting>

      <para>Die nächsten Regeln definieren, welche internen Rechner
	Verbindungen zu anderen Rechnern im Internet aufbauen dürfen.
	Hier werden wieder zustandsorientierte Regeln
	verwendet:</para>

      <programlisting># Allow access to public DNS
# Replace x.x.x.x with the IP address of a public DNS server
# and repeat for each DNS server in /etc/resolv.conf
&dollar;cmd 00110 allow tcp from any to x.x.x.x 53 out via &dollar;pif setup keep-state
&dollar;cmd 00111 allow udp from any to x.x.x.x 53 out via &dollar;pif keep-state

# Allow access to ISP's DHCP server for cable/DSL configurations.
# Use the first rule and check log for IP address.
# Then, uncomment the second rule, input the IP address, and delete the first rule
&dollar;cmd 00120 allow log udp from any to any 67 out via &dollar;pif keep-state
#&dollar;cmd 00120 allow udp from any to x.x.x.x 67 out via &dollar;pif keep-state

# Allow outbound HTTP and HTTPS connections
&dollar;cmd 00200 allow tcp from any to any 80 out via &dollar;pif setup keep-state
&dollar;cmd 00220 allow tcp from any to any 443 out via &dollar;pif setup keep-state

# Allow outbound email connections
&dollar;cmd 00230 allow tcp from any to any 25 out via &dollar;pif setup keep-state
&dollar;cmd 00231 allow tcp from any to any 110 out via &dollar;pif setup keep-state

# Allow outbound ping
&dollar;cmd 00250 allow icmp from any to any out via &dollar;pif keep-state

# Allow outbound NTP
&dollar;cmd 00260 allow udp from any to any 123 out via &dollar;pif keep-state

# Allow outbound SSH
&dollar;cmd 00280 allow tcp from any to any 22 out via &dollar;pif setup keep-state

# deny and log all other outbound connections
&dollar;cmd 00299 deny log all from any to any out via &dollar;pif</programlisting>

      <para>Die folgenden Regeln steuern die Verbindungen von
	Rechern aus dem Internet ins interne Netzwerk.  Zuerst werden
	Pakete verworfen, die typischerweise im Zusammenhang mit
	Angriffen stehen.  Danach werden bestimmte Arten von
	Verbindungen erlaubt.  Alle Dienste aus dem öffentlichen
	Internet beinhalten die Option <literal>limit</literal>, um
	<foreignphrase>Flooding</foreignphrase> zu unterbinden.</para>

      <programlisting># Deny all inbound traffic from non-routable reserved address spaces
&dollar;cmd 00300 deny all from 192.168.0.0/16 to any in via &dollar;pif     #RFC 1918 private IP
&dollar;cmd 00301 deny all from 172.16.0.0/12 to any in via &dollar;pif      #RFC 1918 private IP
&dollar;cmd 00302 deny all from 10.0.0.0/8 to any in via &dollar;pif         #RFC 1918 private IP
&dollar;cmd 00303 deny all from 127.0.0.0/8 to any in via &dollar;pif        #loopback
&dollar;cmd 00304 deny all from 0.0.0.0/8 to any in via &dollar;pif          #loopback
&dollar;cmd 00305 deny all from 169.254.0.0/16 to any in via &dollar;pif     #DHCP auto-config
&dollar;cmd 00306 deny all from 192.0.2.0/24 to any in via &dollar;pif       #reserved for docs
&dollar;cmd 00307 deny all from 204.152.64.0/23 to any in via &dollar;pif    #Sun cluster interconnect
&dollar;cmd 00308 deny all from 224.0.0.0/3 to any in via &dollar;pif        #Class D &amp; E multicast

# Deny public pings$
&dollar;cmd 00310 deny icmp from any to any in via &dollar;pif$
$
# Deny ident$
&dollar;cmd 00315 deny tcp from any to any 113 in via &dollar;pif$
$
# Deny all Netbios services.$
&dollar;cmd 00320 deny tcp from any to any 137 in via &dollar;pif$
&dollar;cmd 00321 deny tcp from any to any 138 in via &dollar;pif$
&dollar;cmd 00322 deny tcp from any to any 139 in via &dollar;pif$
&dollar;cmd 00323 deny tcp from any to any 81 in via &dollar;pif$

# Deny fragments
&dollar;cmd 00330 deny all from any to any frag in via &dollar;pif

# Deny ACK packets that did not match the dynamic rule table
&dollar;cmd 00332 deny tcp from any to any established in via &dollar;pif

# Allow traffic from ISP's DHCP server.
# Replace x.x.x.x with the same IP address used in rule 00120.
#&dollar;cmd 00360 allow udp from any to x.x.x.x 67 in via &dollar;pif keep-state

# Allow HTTP connections to internal web server
&dollar;cmd 00400 allow tcp from any to me 80 in via &dollar;pif setup limit src-addr 2

# Allow inbound SSH connections
&dollar;cmd 00410 allow tcp from any to me 22 in via &dollar;pif setup limit src-addr 2

# Reject and log all other incoming connections
&dollar;cmd 00499 deny log all from any to any in via &dollar;pif</programlisting>

      <para>Die letzte Regel protokolliert alle Pakete, die mit
	keiner Regel im Regelsatz übereinstimmen:</para>

      <programlisting># Everything else is denied and logged
&dollar;cmd 00999 deny log all from any to any</programlisting>
    </sect2>

    <sect2 xml:id="in-kernel-nat">
      <info>
	<title>In-Kernel <acronym>NAT</acronym></title>

	<authorgroup>
	  <author>
	    <personname>
	      <firstname>Chern</firstname>
	      <surname>Lee</surname>
	    </personname>
	    <contrib>Beigetragen von </contrib>
	  </author>
	</authorgroup>

	<authorgroup>
	  <author>
	    <personname>
	      <firstname>Dries</firstname>
	      <surname>Michiels</surname>
	    </personname>
	    <contrib>Aktualisiert von </contrib>
	  </author>
	</authorgroup>
      </info>

      <indexterm>
	<primary>NAT</primary>
	<secondary>und <application>IPFW</application></secondary>
      </indexterm>

      <para>Die <application>IPFW</application>-Firewall von &os; hat
	zwei <acronym>NAT</acronym>-Implementierungen: die
	Userland-Implementierung &man.natd.8; und die neuere,
	kernelinterne <acronym>NAT</acronym>-Implementierung.  Beide
	arbeiten in Verbindung mit <application>IPFW</application>, um
	die Übersetzung von Netzwerkadressen zu ermöglichen.  Damit
	kann eine Lösung zur gemeinsamen Nutzung der
	Internetverbindung bereitgestellt werden, so dass mehrere
	interne Rechner unter Verwendung einer einzigen öffentlichen
	<acronym>IP</acronym>-Adresse eine Verbindung zum Internet
	herstellen können.</para>

      <para>Um dies zu tun, muss der mit dem Internet verbundene
	&os;-Rechner als Gateway eingerichtet sein.  Das System muss
	über zwei Netzwerkschnittstellen verfügen, wobei eine
	Schnittstelle mit dem Internet verbunden ist und die andere
	mit dem internen Netzwerk.  Jeder Rechner im internen Netzwerk
	sollte eine <link
	  xlink:href="https://www.ietf.org/rfc/rfc1918.txt">RFC
	  1918</link> konforme Adresse zugewiesen bekommen.</para>

      <para>Es ist noch ein wenig Konfiguration nötig, um die
	In-Kernel <acronym>NAT</acronym>-Funktion von
	<application>IPFW</application> zu aktivieren.  Um die
	In-Kernel <acronym>NAT</acronym>-Unterstützung beim Booten zu
	aktivieren, müssen folgende Einträge in
	<filename>/etc/rc.conf</filename> vorhanden sein:</para>

      <programlisting>gateway_enable="YES"
firewall_enable="YES"
firewall_nat_enable="YES"</programlisting>

      <note>
	<para>Wenn <literal>firewall_nat_enable</literal> gesetzt ist,
	  <literal>firewall_enable</literal> jedoch nicht,
	  hat dies keine Auswirkung, da die
	  <acronym>NAT</acronym>-Implementierung im Kernel nur mit
	  <application>IPFW</application> kompatibel ist.</para>
      </note>

      <para>Wenn der Regelsatz zustandsorientierte Regeln enthält, ist
	die Position der <acronym>NAT</acronym>-Regel kritisch und die
	<literal>skipto</literal>-Aktion wird benutzt.  Die Aktion
	<literal>skipto</literal> benötigt eine Regelnummer, damit
	<application>IPFW</application> weiß, zu welcher Regel es
	springen muss.  Das folgende Beispiel baut auf den im
	vorherigen Abschnitt gezeigten Firewall-Relgelsatz auf.  Es
	werden einige neue Einträge hinzugefügt und bestehende Regeln
	modifiziert, um In-Kernel <acronym>NAT</acronym> zu
	konfigurieren.  Zunächst werden einige Variablen hinzugefügt,
	darunter Regelnummern, die
	<literal>keep-state</literal>-Option und eine Liste mit
	<acronym>TCP</acronym>-Ports um die Anzahl der Regeln zu
	reduzieren:</para>

      <programlisting>#!/bin/sh
ipfw -q -f flush
cmd="ipfw -q add"
skip="skipto 1000"
pif=dc0
ks="keep-state"
good_tcpo="22,25,37,53,80,443,110"</programlisting>

      <para>Bei In-Kernel <acronym>NAT</acronym> muss aufgrund der
	Architektur von &man.libalias.3;, einer Bibliothek, die als
	Kernel-Modul implementiert ist, um die In-Kernel
	<acronym>NAT</acronym>-Funktion für
	<application>IPFW</application> bereitzustellen,
	<foreignphrase>TCP segment offloading</foreignphrase>
	(<acronym>TSO</acronym>) deaktiviert werden.
	<acronym>TSO</acronym> kann pro Netzwerkschnittstelle mit
	&man.ifconfig.8;, oder systemweit mit &man.sysctl.8;
	deaktiviert werden.  Um <acronym>TSO</acronym> systemweit zu
	deaktivieren, muss folgende Zeile in
	<filename>/etc/sysctl.conf</filename> enthalten sein:</para>

      <programlisting>net.inet.tcp.tso="0"</programlisting>

      <para>Danach wird eine <acronym>NAT</acronym>-Instanz
	konfiguriert.  Mit In-Kernel <acronym>NAT</acronym> ist es
	möglich, mehrere <acronym>NAT</acronym>-Instanzen mit jeweils
	eigener Konfiguration zu betreiben.  In diesem Beispiel wird
	jedoch nur eine <acronym>NAT</acronym>-Instanz mit der Nummer
	1 benötigt.  Die Konfiguration kann ein paar Optionen
	enthalten, zum Beispiel: <option>if</option>, dass die
	öffentliche Netzwerkschnittstelle angibt,
	<option>same_ports</option>, das dafür sorgt, dass Alias-Ports
	und lokale Portnummern identisch zugeordnet werden,
	<option>unreg_only</option> führt dazu, dass nur
	unregistrierte (private) Adressräume von der
	<acronym>NAT</acronym>-Instanz verarbeitet werden, und
	<option>reset</option>, was dazu beiträgt, dass eine
	<acronym>NAT</acronym>-Instanz auch dann erhalten bleibt,
	wenn sich die öffentliche <acronym>IP</acronym>-Adresse des
	Rechners ändert.  Weitere mögliche Optionen, die an einzelne
	<acronym>NAT</acronym>-Instanzen übergeben werden können,
	finden Sie in &man.ipfw.8;.  Wenn eine zustandsorientierte
	<acronym>NAT</acronym>-Firewall konfiguriert wird, ist es
	notwendig, dass übersetzte Pakete zur weiteren Verarbeitung in
	die Firewall eingespielt werden können, was durch die
	Deaktivierung des <option>one_pass</option>-Verhaltens beim
	Start des Firewall-Skripts erreicht werden kann.</para>

      <programlisting>ipfw disable one_pass
ipfw -q nat 1 config if &dollar;pif same_ports unreg_only reset</programlisting>

      <para>Die <acronym>NAT</acronym>-Regel für eingehende Pakete
	wird <emphasis>nach</emphasis> den beiden Regeln, die das
	interne Netzwerk und die Loopback-Schnittstelle erlauben, und
	nach der Reassamble-Regel, aber <emphasis>vor</emphasis> der
	<literal>check-state</literal>-Regel eingefügt.  Es ist
	wichtig, dass die Nummer der <acronym>NAT</acronym>-Regel
	(in diesem Beispiel <literal>100</literal>) höher ist, als
	die drei vorherigen Regeln und niedriger, als die
	<literal>check-state</literal>-Regel.  Darüber hinaus wird
	aufgrund des Verhaltens von In-Kernel <acronym>NAT</acronym>
	empfohlen, eine Reassamble-Regel kurz vor der ersten
	<acronym>NAT</acronym>-Regel, aber hinter den Regeln zu
	platzieren, die den Datenverkehr auf einer vertrauenswürdigen
	Schnittstelle erlauben.  In der Regel sollte es nicht zu einer
	Fragmentierung kommen, aber bei getunnelten
	<acronym>IPSEC/ESP/GRE</acronym>-Verkehr kann es vorkommen,
	und das Zusammensetzen von Fragmenten ist notwendig, bevor das
	komplette Paket an das In-Kernel <acronym>NAT</acronym>
	übergeben werden kann.</para>

    <note>
	<para>Die Reassamble-Regel wird beim Userland &man.natd.8;
	  nicht benötigt, da die Aktion <literal>divert</literal> von
	  <application>IPFW</application> dies bereits automatisch
	  übernimmt, bevor das Paket an den Socket ausgeliefert wird.
	  Dies ist auch in &man.ipfw.8; dokumentiert.</para>
	
	<para>Beachten Sie, dass die aktuelle
	  <acronym>NAT</acronym>-Instanznummer und
	  <acronym>NAT</acronym>-Regelnummer in diesem Beispiel
	  nicht mit der voreingestellten
	  <acronym>NAT</acronym>-Instanznummer und Regelnummer
	  übereinstimmt, wenn sie mit dem
	  <filename>rc.firewall</filename>-Skript von &os; erstellt
	  wurde.</para>
      </note>

      <programlisting>&dollar;cmd 005 allow all from any to any via xl0  # exclude LAN traffic
&dollar;cmd 010 allow all from any to any via lo0  # exclude loopback traffic
&dollar;cmd 099 reass all from any to any in       # reassemble inbound packets
&dollar;cmd 100 nat 1 ip from any to any in via &dollar;pif # NAT any inbound packets
# Allow the packet through if it has an existing entry in the dynamic rules table
&dollar;cmd 101 check-state</programlisting>

      <para>Die Regeln für den ausgehenden Verkehr werden ebenfalls
	modifiziert, um Aktionen mit der
	<literal>&dollar;skipto</literal>-Variable zu erlauben und
	anzuzeigen, dass die Prüfung mit der Regel
	<literal>1000</literal> fortgesetzt wird.  Die sieben Regeln
	für <acronym>TCP</acronym> wurden durch die Regel
	<literal>125</literal> ersetzt, da die sieben erlaubten
	ausgehenden Ports in der Variable
	<literal>&dollar;good_tcp0</literal> enthalten sind.</para>

      <note>
	<para>Beachten Sie, dass die Leistung von
	  <application>IPFW</application> weitgehend von der Anzahl
	  der im Regelsatz vorhandenen Regeln bestimmt wird.</para>
      </note>

      <programlisting># Authorized outbound packets
&dollar;cmd 120 &dollar;skip udp from any to x.x.x.x 53 out via &dollar;pif &dollar;ks
&dollar;cmd 121 &dollar;skip udp from any to x.x.x.x 67 out via &dollar;pif &dollar;ks
&dollar;cmd 125 &dollar;skip tcp from any to any &dollar;good_tcpo out via &dollar;pif setup &dollar;ks
&dollar;cmd 130 &dollar;skip icmp from any to any out via &dollar;pif &dollar;ks</programlisting>

      <para>Die eingehenden Regeln bleiben unverändert, mit Ausnahme
	der letzten Regel, in der das
	<literal>via $pif</literal> entfernt wird, um ein- und
	ausgehende Pakete prüfen zu können.  Nach der letzten Regel
	für ausgehende Pakete muss die <acronym>NAT</acronym>-Regel
	folgen.  Die Regel muss eine höhere Nummer als die letzte
	Regel haben und die Nummer muss über die
	<literal>skipto</literal>-Aktion referenziert werden.  In
	diesem Regelsatz leitet die Regel mit der Nummer
	<literal>1000</literal> alle ausgehenden Pakete zur
	konfigurierten <acronym>NAT</acronym>-Instanz weiter.  Die darauf
	folgende Regel lässt alle von <acronym>NAT</acronym>
	verarbeiteten Pakete passieren.</para>

      <programlisting>&dollar;cmd 999 deny log all from any to any
&dollar;cmd 1000 nat 1 ip from any to any out via &dollar;pif # skipto location for outbound stateful rules
&dollar;cmd 1001 allow ip from any to any</programlisting>

      <para>In diesem Beispiel steuern die Regeln
	<literal>100</literal>, <literal>101</literal>,
	<literal>125</literal>, <literal>1000</literal> und
	<literal>1001</literal> die Adressübersetzung der ein- und
	ausgehende Pakete, so dass immer die private
	<acronym>LAN</acronym> <acronym>IP</acronym>-Adresse in der
	dynamische Zustandstabelle registriert werden.</para>

      <para>Nehmen wir beispielsweise einen Web-Browser, der neue
	<acronym>HTTP</acronym>-Sitzungen über Port 80 aufbaut.  Wenn
	nun das erste ausgehende Paket von der Firewall geprüft wird,
	trifft es nicht auf Regel <literal>100</literal> zu, da das
	Paket nach außen geleitet wird und nicht nach innen.  Das
	Paket trifft auch nicht auf Regel <literal>101</literal> zu,
	da es das erste ist und somit noch nicht in der dynamischen
	Zustandstabelle enthalten ist.  Das Paket entspricht
	schließlich Regel <literal>125</literal>, da es ausgehend auf
	einem erlaubten Port gesendet wird und von einer
	<acronym>IP</acronym>-Adresse aus dem internen
	<acronym>LAN</acronym> stammt.  Für Pakete, die auf diese
	Regel zutreffen, werden zwei Aktionen ausgeführt.  Zuerst
	wird durch die Aktion <literal>keep-state</literal> ein
	dynamischer Eintrag in der Statustabelle erstellt und die
	angegebene Aktion <literal>skipto 1000</literal> ausgeführt.
	Als nächstes durchläuft das Paket <acronym>NAT</acronym> und
	wird dann an das Internet gesendet.  Nachdem dieses Paket am
	Webserver angekommen ist, wird dort eine Antwort erzeugt und
	zurückgeschickt.  Dieses Paket wird wieder von oben nach unten
	durch das Regelwerk geprüft.  Dieses Mal trifft Regel
	<literal>100</literal> auf das Paket zu und die Zieladresse
	wird auf die zugehörige (lokale)
	<acronym>LAN</acronym>-Adresse abgebildet.  Danach wird das
	Paket von der Regel <literal>check-state</literal>
	verarbeitet.  Die Zustandstabelle erkennt, dass eine
	zugehörige aktive Sitzung vorliegt und das Paket wird
	freigegeben und in das <acronym>LAN</acronym> geleitet.</para>

      <para>Für den eingehenden Datenverkehr muss der Regelsatz
	unerwünschte Pakete blockieren und Pakete für autorisierte
	Dienste durchlassen.  Ein Paket, das mit einer Regel für den
	eingehenden Datenverkehr übereinstimmt, wird in der
	dynamischen Zustandstabelle eingetragen und dann an das
	<acronym>LAN</acronym> freigegeben.  Das Antwortpaket wird
	von der Regel <literal>check-state</literal> als Paket einer
	aktiven Sitzung erkannt.  Das Paket wird dann von Regel
	<literal>1000</literal> per <acronym>NAT</acronym>
	verarbeitet, bevor es über die externe Schnittstelle
	verschickt wird.</para>

      <note>
	<para>Der Wechsel vom Userland &man.natd.8; zu In-Kernel
	  <acronym>NAT</acronym> mag zunächst nahtlos erscheinen, aber
	  es gibt einen kleinen Haken.  Bei Verwendung des
	  <filename>GENERIC</filename>-Kernels wird
	  <application>IPFW</application> das Kernelmodul
	  <filename>libalias.ko</filename> laden, wenn
	  <literal>firewall_nat_enable</literal> in
	  <filename>rc.conf</filename> aktiviert ist.  Das
	  Kernelmodul <filename>libalias.ko</filename> stellt nur
	  grundlegende <acronym>NAT</acronym>-Funktionalität bereit,
	  während die Userland-Implementierung &man.natd.8; alle
	  Funktionalitäten ohne zusätzliche Konfiguration zur
	  Verfügung stellt.  Die gesamte Funktionalität bezieht sich
	  auf die folgenden Kernelmodule, die bei Bedarf zusätzlich
	  zu <filename>libalias.ko</filename> geladen werden können:
	  <filename>alias_cuseeme.ko</filename>,
	  <filename>alias_ftp.ko</filename>,
	  <filename>alias_bbt.ko</filename>,
	  <filename>skinny.ko</filename>, <filename>irc.ko</filename>,
	  <filename>alias_pptp.ko</filename> und
	  <filename>alias_smedia.ko</filename> unter Verwendung der
	  <literal>kld_list</literal> Direktive in
	  <filename>rc.conf</filename>.  Wenn ein
	  angepasster Kernel benutzt wird, kann die volle
	  Funktionalität der Userland-Bibliothek im Kernel mit
	  <option>options LIBALIAS</option> gebaut werden.</para>
      </note>

      <sect3>
	<title>Weiterleitung von Ports</title>

	<para>Der Nachteil von <acronym>NAT</acronym> ist, dass die Rechner im
	  <acronym>LAN</acronym> nicht aus dem Internet zugänglich
	  sind.  Diese Rechner können zwar ausgehende Verbindungen
	  zur Außenwelt aufbauen, jedoch keine eingehenden
	  Verbindungen empfangen.  Dies stellt ein Problem dar, wenn
	  Sie auf einem Rechner im <acronym>LAN</acronym> Dienste
	  anbieten möchten, die aus dem Internet erreichbar sein
	  sollen.  In diesem Fall können Sie die Ports, welche über
	  das Internet erreichbar sein sollen, über die
	  <acronym>NAT</acronym>-Maschine an den Rechner im
	  <acronym>LAN</acronym> weiterleiten.</para>

	<para>Angenommen es gibt einen <acronym>IRC</acronym>-Server
	  auf Rechner <systemitem>A</systemitem> und einen Webserver
	  auf Rechner <systemitem>B</systemitem>.  Damit dies
	  funktioniert, müssen die Verbindungen auf den Ports 6667
	  (<acronym>IRC</acronym>) und 80 (<acronym>HTTP</acronym>)
	  an die jeweiligen Rechner weitergeleitet werden.</para>

	<para>Bei In-Kernel <acronym>NAT</acronym> wird die gesamte
	  Konfiguration in der <acronym>NAT</acronym>-Instanz selbst
	  vorgenommen.  Alle Optionen, die in einer
	  <acronym>NAT</acronym>-Instanz benutzt werden können, sind
	  in &man.ipfw.8; dokumentiert.  Die Syntax für
	  <application>IPFW</application> folgt dabei der von
	  <application>natd</application>.  Die Syntax für
	  <option>-redirect_port</option> lautet:</para>

	<programlisting>redirect_port proto targetIP:targetPORT[-targetPORT]
  [aliasIP:]aliasPORT[-aliasPORT]
  [remoteIP[:remotePORT[-remotePORT]]]</programlisting>

	<para>Für das obige Beispiel sollten die Argumente wie folgt
	  aussehen:</para>

	<programlisting>redirect_port tcp 192.168.0.2:6667 6667
redirect_port tcp 192.168.0.3:80 80</programlisting>

	<para>Nachdem diese Argumente der Konfiguration der
	  <acronym>NAT</acronym>-Instanz 1 im obigen Regelsatz
	  hinzugefügt wurden, werden die <acronym>TCP</acronym>-Ports
	  an die Rechner im <acronym>LAN</acronym> weitergeleitet, auf
	  denen <acronym>IRC</acronym>- und
	  <acronym>HTTP</acronym>-Dienste laufen.</para>

	<programlisting>ipfw -q nat 1 config if &dollar;pif same_ports unreg_only reset \
  redirect_port tcp 192.168.0.2:6667 6667 \
  redirect_port tcp 192.168.0.3:80 80</programlisting>

	<para>Portbereiche können über <option>redirect_port</option>
	  festgelegt werden.  Zum Beispiel würde
	  <replaceable>tcp 192.168.0.2:2000-3000
	    2000-3000</replaceable> alle Verbindungen auf die Ports
	  2000 bis 3000 an die Ports 2000 bis 3000 an
	  Rechner <systemitem>A</systemitem> weiterleiten.</para>
      </sect3>

      <sect3>
	<title>Weiterleiten von Adressen</title>

	<para>Das Weiterleiten von Adressen ist nützlich, wenn
	  mehr als eine <acronym>IP</acronym>-Adresse zur Verfügung
	  steht.  Jeder Rechner im <acronym>LAN</acronym> kann über
	  &man.ipfw.8; seine eigene externe
	  <acronym>IP</acronym>-Adresse zugewiesen bekommen.
	  <application>IPFW</application> wird dann den ausgehenden Datenverkehr der
	  Rechner aus dem <acronym>LAN</acronym> mit der
	  entsprechenden externen <acronym>IP</acronym>-Adresse
	  umschreiben.  Auch der eingehenden Datenverkehr über die
	  externe <acronym>IP</acronym>-Adresse wird an die
	  entsprechenden Rechner im <acronym>LAN</acronym>
	  weitergeleitet.  Diese Methode ist auch als
	  statisches <acronym>NAT</acronym> bekannt.  Wenn Ihnen
	  beispielsweise die <acronym>IP</acronym>-Adressen
	  <systemitem class="ipaddress">128.1.1.1</systemitem>,
	  <systemitem class="ipaddress">128.1.1.2</systemitem> und
	  <systemitem class="ipaddress">128.1.1.3</systemitem> zur
	  Verfügung stehen, kann <systemitem
	    class="ipaddress">128.1.1.1</systemitem> als externe
	  Adresse der &man.ipfw.8;-Maschine verwendet werden, während
	  <systemitem class="ipaddress">128.1.1.2</systemitem> und
	  <systemitem class="ipaddress">128.1.1.3</systemitem> an
	  Rechner <systemitem>A</systemitem> und
	  Rechner <systemitem>B</systemitem> im <acronym>LAN</acronym>
	  weitergeleitet werden.</para>

	<para>Die Syntax für <option>redirect_address</option>
	  lautet wie im Folgenden, wobei <literal>localIP</literal>
	  die interne <acronym>IP</acronym>-Adresse des Rechners im
	  <acronym>LAN</acronym>, und <literal>publicIP</literal> die
	  externe <acronym>IP</acronym>-Adresse ist, die dem Rechner
	  im <acronym>LAN</acronym> entspricht.</para>

	<programlisting>redirect_address localIP publicIP</programlisting>

	<para>Auf das Beispiel bezogen, würden die Argumente so
	  lauten:</para>

	<programlisting>redirect_address 192.168.0.2 128.1.1.2
redirect_address 192.168.0.3 128.1.1.3</programlisting>

	<para>Genau wie bei <option>redirect_port</option>, werden
	  diese Argumente in der Konfiguration der
	  <acronym>NAT</acronym>-Instanz gesetzt.  Bei der
	  Weiterleitung von Adressen ist keine Portumleitung
	  notwendig, da alle Daten, die auf einer bestimmten
	  <acronym>IP</acronym>-Adresse empfangen werden,
	  weitergeleitet werden.</para>

	<para>Die externe <acronym>IP</acronym>-Adresse der
	  &man.ipfw.8;-Maschine muss auf der externen Schnittstelle
	  aktiv und mit einem Alias versehen sein.  Weitere
	  Einzelheiten sind in &man.rc.conf.5;; beschrieben.</para>
      </sect3>

      <sect3>
	<title>Userland <acronym>NAT</acronym></title>

	<para>Zunächst sei gesagt, dass &man.natd.8;, die
	  Userland-Implementierung aufwändiger ist als In-Kernel
	  <acronym>NAT</acronym>.  Damit &man.natd.8; Pakete
	  übersetzen kann, müssen die Pakete vom Kernel ins
	  Userland und zurück kopiert werden, was zusätzlichen Aufwand
	  mit sich bringt.  Dieser Aufwand entfällt bei In-Kernel
	  <acronym>NAT</acronym>.</para>

	<para>Um den Userland <acronym>NAT</acronym>-Daemon
	  &man.natd.8; beim Systemstart zu aktivieren, ist etwas
	  Konfiguration in <filename>/etc/rc.conf</filename> nötig.
	  <option>natd_interface</option> wird auf den Namen der mit
	  dem Internet verbundenen Schnittstelle gesetzt.  Das
	  &man.rc.8;-Skript von &man.natd.8; wird selbstständig
	  prüfen, ob eine dynamische <acronym>IP</acronym>-Adresse
	  benutzt wird und sich selbst so konfigurieren, dass es damit
	  umgehen kann.</para>

	<programlisting>gateway_enable="YES"
natd_enable="YES"
natd_interface="rl0"</programlisting>

	<para>Generell kann der obige Regelsatz, wie er für In-Kernel
	  <acronym>NAT</acronym> erklärt wurde, auch zusammen mit
	  &man.natd.8; benutzt werden.  Die Ausnahmen sind die
	  Konfiguration der In-Kernel <acronym>NAT</acronym>-Instanz
	  <literal>(ipfw -q nat 1 config ...)</literal>, die nicht
	  zusammen mit der Regel 99 benötigt wird, da die
	  <option>divert</option>-Aktion sich um die Fragmentierung
	  kümmert.  Die Regeln 100 und 1000 müssen leicht modifiziert
	  werden, wie unten gezeigt.</para>

	<programlisting>&dollar;cmd 100 divert natd ip from any to any in via &dollar;pif
&dollar;cmd 1000 divert natd ip from any to any out via &dollar;pif</programlisting>

	<para>Um eine Port- oder Adressumleitung zu konfigurieren,
	  wird eine ähnliche Syntax wie bei In-Kernel
	  <acronym>NAT</acronym> verwendet.  Anstatt die Konfiguration
	  in unserem Regelsatz-Skript wie bei In-Kernel
	  <acronym>NAT</acronym> anzugeben, wird die Konfiguration von
	  &man.natd.8; am besten in einer Konfigurationsdatei
	  vorgenommen.  Dazu muss eine zusätzliche Option in
	  <filename>/etc/rc.conf</filename> übergeben werden, welche
	  den Pfad zur Konfigurationsdatei angibt.</para>

	<programlisting>natd_flags="-f /etc/natd.conf"</programlisting>

	<note>
	  <para>Die Konfigurationsdatei muss eine Liste von Optionen
	    enthalten, eine pro Zeile.  Weitere Informationen über die
	    Konfigurationsdatei und mögliche Variablen finden Sie in
	    &man.natd.8;.  Hier zwei Beispieleinträge, einer pro
	    Zeile:</para>

	  <programlisting>redirect_port tcp 192.168.0.2:6667 6667
redirect_address 192.168.0.3 128.1.1.3</programlisting>
	</note>
      </sect3>
    </sect2>

    <sect2 xml:id="firewalls-ipfw-cmd">
      <title>Das <application>IPFW</application> Kommando</title>

      <indexterm>
	<primary><command>ipfw</command></primary>
      </indexterm>

      <para><command>ipfw</command> kann benutzt werden, um einzelne
	Regeln im laufenden Betrieb hinzuzufügen oder zu entfernen.
	Problematisch ist jedoch, dass diese Änderungen bei einem
	Neustart des Systems verloren gehen.  Daher ist es
	empfehlenswert, eigene Regeln in einer Datei zu definieren
	und diese zu laden, um die Regeln der Firewall im laufenden
	Betrieb anzupassen.</para>

      <para><command>ipfw</command> ist auch hilfreich, um die
	geladenen Regeln der auf der Konsole auszugeben.
	<application>IPFW</application> erzeugt dynamisch einen
	Zähler, der jedes Paket, auf das eine Regel zutrifft, zählt.
	Dadurch ist es möglich, die Funktion einer Regel zu
	überprüfen.</para>

      <para>Eine Auflistung aller geladenen Regeln erhalten Sie
	mit:</para>

      <screen>&prompt.root; <userinput>ipfw list</userinput></screen>

      <para>Eine Auflistung aller Regeln inklusive des letzten
	Treffers erhalten Sie mit:</para>

      <screen>&prompt.root; <userinput>ipfw -t list</userinput></screen>

      <para>Das nächste Beispiel zeigt Informationen über die Anzahl
	der Pakete, die von einer Regel gefiltert wurden sowie die
	Regel selbst.  Der erste Spalte zeigt die Nummer der
	Regel, gefolgt von der Anzahl der gefilterten Pakete
	und der Anzahl der Pakete in Bytes.  Zum Schluss steht die
	Regel selbst:</para>

      <screen>&prompt.root; <userinput>ipfw -a list</userinput></screen>

      <para>Das folgende Kommando zeigt zusätzlich alle dynamischen
	Regeln an:</para>

      <screen>&prompt.root; <userinput>ipfw -d list</userinput></screen>

      <para>Um diese Auflistung um die <quote>abgelaufenen</quote>
	Regeln zu erweitern, geben Sie folgendes Kommando ein:</para>

      <screen>&prompt.root; <userinput>ipfw -d -e list</userinput></screen>

      <para>Hiermit werden alle Zähler auf Null zurückgesetzt:</para>

      <screen>&prompt.root; <userinput>ipfw zero</userinput></screen>

      <para>Es ist auch möglich, einen spezifischen Zähler
	zurückzusetzen:</para>

      <screen>&prompt.root; <userinput>ipfw zero NUM</userinput></screen>

      <sect3>
	<title>Protokollierung von Firewall-Nachrichten</title>

	<para>Auch bei aktivierter Protokollierung wird
	  <application>IPFW</application> von selbst keine Regeln
	  protokollieren.  Der Administrator muss entscheiden, welche
	  Regeln aus dem Regelwerk protokolliert werden sollen.  In
	  diesen Regeln muss dann das Schlüsselwort
	  <literal>log</literal> hinzugefügt werden.  Normalerweise
	  werden nur geblockte Pakete protokolliert.  Es ist üblich,
	  die <quote>ipfw default deny everything</quote>-Regel am
	  Ende des Regelwerks mit dem Schlüsselwort
	  <literal>log</literal> zu duplizieren.  Dadurch ist es
	  möglich, alle Pakete zu sehen, auf die keine Regel
	  zutraf.</para>

	<para>Protokollierung ist allerdings ein zweischneidiges
	  Schwert.  Bei mangelnder Vorsicht oder einem DoS-Angriff
	  wird die Festplatte mit einer enormen Flut von
	  Protokolldaten belastet.  Protokoll-Nachrichten werden nicht
	  nur an &man.syslogd.8; geschickt, sondern auch auf der
	  Konsole angezeigt, was dann schnell lästig werden
	  kann.</para>

	<para>Die Kerneloption
	  <literal>IPFIREWALL_VERBOSE_LIMIT=5</literal> begrenzt die
	  Anzahl identischer Nachrichten an &man.syslogd.8; für eine
	  gegebene Regel auf fünf Nachrichten.  Ist diese Option im
	  Kernel aktiviert, wird nach Erreichen den festgelegten
	  Anzahl die Protokollierung von aufeinanderfolgenden
	  Nachrichten auf den festgelegten Wert begrenzt, da
	  beispielsweise die Speicherung von 200 gleichen
	  Protokoll-Nachrichten sinnlos ist.  Daher werden durch
	  diese Option nur fünf gleichartige Nachrichten
	  protokolliert.  Alle weiteren Nachrichten werden nur gezählt
	  und deren Gesamtzahl wird schließlich von &man.syslogd.8;
	  wie folgt ausgegeben:</para>

	<programlisting>Last message repeated 45 times</programlisting>

	<para>Alle protokollierten Pakete werden in der Voreinstellung
	  in <filename>/var/log/security</filename> gespeichert.  Dies
	  wird in <filename>/etc/syslog.conf</filename>
	  definiert.</para>
      </sect3>

      <sect3 xml:id="firewalls-ipfw-rules-script">
	<title>Ein Firewall-Regelwerk erstellen</title>

	<para>Die meisten fortgeschrittenen
	  <application>IPFW</application>-Benutzer erzeugen eine
	  Datei, welche die Regeln für die Firewall enthält, um diese
	  als Skript ausführen zu können.  Der Vorteil einer
	  derartigen Konfiguration besteht darin, dass dadurch mehrere
	  Regeln gleichzeitig geändert und aktiviert werden können,
	  ohne dass dazu das System neu gestartet werden muss.  Dies
	  ist zudem beim Testen von Regeländerungen sehr hilfreich.
	  Weil es sich bei der Datei um ein Skript handelt, ist es
	  auch möglich, häufig verwendete Befehle durch Aliase zu
	  ersetzen und diese dann in mehreren Regeln zu nutzen.</para>

	<para>Die Syntax des folgenden Skripts entspricht der Syntax
	  von &man.sh.1;, &man.csh.1; sowie &man.tcsh.1;.  Felder, die
	  symbolisch substituiert werden, haben das Präfix &dollar;
	  (Dollarzeichen).  Symbolische Felder haben das
	  &dollar;-Präfix nicht.  Der Wert, mit dem das symbolische
	  Feld belegt wird, muss in doppelten Anführungszeichen
	  ("") stehen.</para>

	<para>Die Datei mit den Regeln könnte wie folgt aufgebaut
	  sein:</para>

	<programlisting>############### start of example ipfw rules script #############
#
ipfw -q -f flush       # Delete all rules
# Set defaults
oif="tun0"             # out interface
odns="192.0.2.11"      # ISP's DNS server IP address
cmd="ipfw -q add "     # build rule prefix
ks="keep-state"        # just too lazy to key this each time
&dollar;cmd 00500 check-state
&dollar;cmd 00502 deny all from any to any frag
&dollar;cmd 00501 deny tcp from any to any established
&dollar;cmd 00600 allow tcp from any to any 80 out via &dollar;oif setup &dollar;ks
&dollar;cmd 00610 allow tcp from any to &dollar;odns 53 out via &dollar;oif setup &dollar;ks
&dollar;cmd 00611 allow udp from any to &dollar;odns 53 out via &dollar;oif &dollar;ks
################### End of example ipfw rules script ############</programlisting>

	<para>Die Regeln in diesem Beispiel sind nicht wichtig.
	  Wichtig ist es, zu zeigen, wie die symbolische Substitution
	  innerhalb der Regeln verwendet wird.</para>

	<para>Wenn dieses Beispiel in
	  <filename>etc/ipfw.rules</filename> gespeichert wurde, so
	  könnten alle Regeln durch die Ausführung des folgenden
	  Kommandos neu geladen werden:</para>

	<screen>&prompt.root; <userinput>sh /etc/ipfw.rules</userinput></screen>

	<para>Anstelle von <filename>/etc/ipfw.rules</filename> kann
	  ein beliebig anderer Name oder Speicherort verwendet
	  werden.</para>

	<para>Alternativ können die einzelnen Befehle dieses Skripts
	  auch von Hand eingegeben werden:</para>

	<screen>&prompt.root; <userinput>ipfw -q -f flush</userinput>
&prompt.root; <userinput>ipfw -q add check-state</userinput>
&prompt.root; <userinput>ipfw -q add deny all from any to any frag</userinput>
&prompt.root; <userinput>ipfw -q add deny tcp from any to any established</userinput>
&prompt.root; <userinput>ipfw -q add allow tcp from any to any 80 out via tun0 setup keep-state</userinput>
&prompt.root; <userinput>ipfw -q add allow tcp from any to 192.0.2.11 53 out via tun0 setup keep-state</userinput>
&prompt.root; <userinput>ipfw -q add 00611 allow udp from any to 192.0.2.11 53 out via tun0 keep-state</userinput></screen>
      </sect3>
    </sect2>

    <sect2 xml:id="firewalls-ipfw-kernelconfig">
      <title><application>IPFW</application> Kerneloptionen</title>

      <indexterm>
	<primary>Kerneloptionen</primary>
	<secondary>IPFIREWALL</secondary>
      </indexterm>

      <indexterm>
	<primary>Kerneloptionen</primary>
	<secondary>IPFIREWALL_VERBOSE</secondary>
      </indexterm>

      <indexterm>
	<primary>Kerneloptionen</primary>
	<secondary>IPFIREWALL_VERBOSE_LIMIT</secondary>
      </indexterm>

      <indexterm>
	<primary><application>IPFW</application></primary>
	<secondary>Kerneloptionen</secondary>
      </indexterm>

      <para>Um die Unterstützung für <application>IPFW</application>
	statisch in den Kernel zu kompilieren, lesen Sie die
	Anweisungen in <xref linkend="kernelconfig"/>.  Die folgenden
	Optionen können in der Kernelkonfigurationsdatei verwendet
	werden:</para>

      <programlisting>options    IPFIREWALL			# enables IPFW
options    IPFIREWALL_VERBOSE		# enables logging for rules with log keyword to syslogd(8)
options    IPFIREWALL_VERBOSE_LIMIT=5	# limits number of logged packets per-entry
options    IPFIREWALL_DEFAULT_TO_ACCEPT	# sets default policy to pass what is not explicitly denied
options    IPFIREWALL_NAT		# enables basic in-kernel NAT support
options    LIBALIAS			# enables full in-kernel NAT support
options    IPFIREWALL_NAT64		# enables in-kernel NAT64 support
options    IPFIREWALL_NPTV6		# enables in-kernel IPv6 NPT support
options    IPFIREWALL_PMOD		# enables protocols modification module support
options    IPDIVERT			# enables NAT through natd(8)</programlisting>

      <note>
	<para><application>IPFW</application> kann auch als
	  Kernelmodul geladen werden: Die oben genannten Optionen
	  werden standardmäßig als Module erstellt, oder können zur
	  Laufzeit über Parameter festgelegt werden.</para>
      </note>
    </sect2>
  </sect1>

  <sect1 xml:id="firewalls-ipf">
    <title>IPFILTER (IPF)</title>

    <indexterm>
      <primary>Firewall</primary>
      <secondary><application>IPFILTER</application></secondary>
    </indexterm>

    <para><application>IPFILTER</application>, auch als
      <application>IPF</application> bekannt, ist eine
      plattformübergreifende Open Source Firewall, die auf
      mehrere Betriebssysteme portiert wurde, einschließlich
      &os;, NetBSD, OpenBSD und &solaris;.</para>

    <para><application>IPFILTER</application> basiert auf einer
      kernelseitigen Firewall und einem
      <acronym>NAT</acronym>-Mechanismus, der durch Anwenderprogramme
      gesteuert und überwacht werden kann.  Firewallregeln werden mit
      <application>ipf</application> gesetzt oder gelöscht.  Für die
      Manipulation der <acronym>NAT</acronym>-Regeln wird
      <application>ipnat</application> benutzt.  Mit
      <application>ipfstat</application> werden Laufzeitstatistiken
      der kernelseitigen Anteile von
      <application>IPFILTER</application> aufgelistet.  Mit
      <application>ipmon</application> können die Aktionen von
      <application>IPFILTER</application> in Protokolldateien
      gespeichert werden.</para>

    <para><application>IPF</application> wurde ursprünglich mit der
      Verarbeitungslogik <quote>die letzte passende Regel
	gewinnt</quote> geschrieben und verwendete ausschließlich
      Regeln ohne feste Zustände.  Inzwischen wurde
      <application>IPF</application> modernisiert und unterstützt nun
      auch die Optionen <literal>quick</literal> und
      <literal>keep state</literal>.</para>

    <para>Antworten auf häufige Fragen finden Sie unter <uri
	xlink:href="http://www.phildev.net/ipf/index.html">
	http://www.phildev.net/ipf/index.html</uri>.  Ein Archiv
      der <application>IPFILTER</application> Mailingliste steht unter
      <uri xlink:href="http://marc.info/?l=ipfilter">
	http://marc.info/?l=ipfilter</uri> zur Verfügung.</para>

    <para>Dieser Abschnitt des Handbuchs konzentriert sich auf
      <application>IPF</application> unter &os;.  Es werden auch
      Firewallregeln mit den Optionen <literal>quick</literal> und
      <literal>keep state</literal> vorgestellt.</para>

    <sect2>
      <title><application>IPF</application> aktivieren</title>

      <indexterm>
	<primary><application>IPFILTER</application></primary>
	<secondary>aktivieren</secondary>
      </indexterm>

      <para><application>IPF</application> ist in &os; als ladbares
	Kernelmodul enthalten.  Das bedeutet, dass Sie keinen
	angepassten Kernel erzeugen müssen um
	<application>IPF</application> zu aktivieren.</para>

      <indexterm>
	<primary>Kerneloptionen</primary>
	<secondary><application>IPFILTER</application></secondary>
      </indexterm>

      <indexterm>
	<primary>Kerneloptionen</primary>
	<secondary>IPFILTER_LOG</secondary>
      </indexterm>

      <indexterm>
	<primary>Kerneloptionen</primary>
	<secondary>IPFILTER_DEFAULT_BLOCK</secondary>
      </indexterm>

      <indexterm>
	<primary><application>IPFILTER</application></primary>
	<secondary>Kerneloptionen</secondary>
      </indexterm>

      <para>Benutzer, die <application>IPF</application> lieber
	statisch in den Kernel kompilieren, sollten den Anweisungen in
	<xref linkend="kernelconfig"/> folgen.  Die folgenden
	Kerneloptionen stehen zur Verfügung:</para>

      <programlisting>options IPFILTER
options IPFILTER_LOG
options IPFILTER_LOOKUP
options IPFILTER_DEFAULT_BLOCK</programlisting>

      <para><literal>options IPFILTER</literal> aktiviert die
	Unterstützung für <application>IPFILTER</application>.
	<literal>options IPFILTER_LOG</literal> aktiviert die
	Protokollierung über die Pseudo-Schnittstelle
	<filename>ipl</filename> für Firewallrelgen, die das
	Schlüsselwort <literal>log</literal> enthalten.
	<literal>IPFILTER_LOOKUP</literal> aktiviert
	<acronym>IP</acronym>-Pools, um die Suche nach
	<acronym>IP</acronym>-Adressen zu beschleunigen.
	<literal>IPFILTER_DEFAULT_BLOCK</literal> ändert das
	Verhalten der Firewall dahingehend, dass jedes Paket, das
	nicht explizit von einer <literal>pass</literal>-Regel
	Zugang erhält, geblockt wird.</para>

      <para>Um <application>IPF</application> während des Bootens zu
	aktivieren, müssen folgende Einträge in
	<filename>/etc/rc.conf</filename> hinzugefügt werden.  Diese
	Einträge aktivieren ebenfalls die Protokollierung und die
	Regel <literal>default pass all</literal>.  Um diese
	Voreinstellung zu ändern, ohne einen neuen Kernel zu
	übersetzen, müssen Sie am Ende der Firewallregeln eine
	<literal>block all</literal> Regel hinzufügen.</para>

      <programlisting>ipfilter_enable="YES"             # Start ipf firewall
ipfilter_rules="/etc/ipf.rules"   # loads rules definition text file
ipv6_ipfilter_rules="/etc/ipf6.rules" # loads rules definition text file for IPv6
ipmon_enable="YES"                # Start IP monitor log
ipmon_flags="-Ds"                 # D = start as daemon
                                  # s = log to syslog
                                  # v = log tcp window, ack, seq
                                  # n = map IP &amp; port to names</programlisting>

      <para>Wenn die <acronym>NAT</acronym>-Funktionalität benötigt
	wird, müssen auch diese Zeilen hinzugefügt werden:</para>

      <programlisting>gateway_enable="YES"              # Enable as LAN gateway
ipnat_enable="YES"                # Start ipnat function
ipnat_rules="/etc/ipnat.rules"    # rules definition file for ipnat</programlisting>

      <para>Jetzt können Sie <application>IPF</application>
	starten:</para>

      <screen>&prompt.root; <userinput>service ipfilter start</userinput></screen>

      <para>Um die Firewallregeln zu laden, übergeben Sie den Namen
	des Regelwerks an <command>ipf</command>.  Mit dem folgenden
	Kommando ersetzen Sie alle aktuell geladenen Regeln:</para>

      <screen>&prompt.root; <userinput>ipf -Fa -f /etc/ipf.rules</userinput></screen>

      <para><literal>-Fa</literal> löscht zunächst alle internen
	Regeln und mit <literal>-f</literal> wird die Datei angegeben,
	welche die zu ladenen Regeln enthält.</para>

      <para>Damit haben Sie die Möglichkeit, Änderungen an der
	laufenden Firewall zu machen, ohne dass das System neu
	gestartet werden muss.  Da dieser Vorgang beliebig oft
	wiederholt werden kann, ist es ein sehr bequemer Weg neue
	Regeln zu testen.</para>

      <para>Diese und weitere Optionen sind in &man.ipf.8;
	beschrieben.</para>
    </sect2>

    <sect2>
      <title><application>IPF</application> Regel-Syntax</title>

      <indexterm>
	<primary><application>IPFILTER</application></primary>
	<secondary>Regel-Syntax</secondary>
      </indexterm>

      <para>Mit der hier beschriebenen Regel-Syntax können
	zustandsorientierte Regeln erstellt werden.  Beim Erstellen
	von Regeln ist zu beachten, dass Regeln ohne das Schlüsselwort
	<literal>quick</literal> der Reihe nach geprüft werden und
	<quote>die letzte zutreffende Regel</quote> angewendet wird.
	Das bedeutet, dass selbst dann, wenn die erste zutreffende
	Regel eine <literal>pass</literal>-Regel ist, das Paket
	dennoch geblockt wird, falls später eine
	<literal>block</literal>-Regel zutrifft.  Beispielregelsätze
	finden Sie in
	<filename>/usr/share/examples/ipfilter</filename>.</para>

      <para>Beim Erstellen von Regeln wird das Zeichen
	<literal>#</literal> verwendet, um einen Kommentar bis zum
	Ende der Zeile einzuleiten.  Leere Zeilen werden
	ignoriert.</para>

      <para>Die Schlüsselwörter, die in den Regeln verwendet werden,
	müssen in einer bestimmten Reihenfolge geschrieben werden,
	von links nach rechts.  Einige Schlüsselwörter sind
	verbindlich, andere sind optional.  Einige Schlüsselwörter
	haben Unteroptionen, die wiederum selbst Schlüsselwörter sind
	und ebenfalls weitere Unteroptionen einschließen können.  Die
	Reihenfolge der Schlüsselwörter ist wie folgt, wobei die
	Wörter in Großbuchstaben eine Variable darstellen und die
	Wörter in Kleinbuchstaben der Variable vorangestellt werden
	müssen:</para>

      <para><replaceable>ACTION DIRECTION OPTIONS proto PROTO_TYPE
	  from SRC_ADDR SRC_PORT to DST_ADDR DST_PORT
	  TCP_FLAG|ICMP_TYPE keep state STATE</replaceable></para>

      <para>Dieser Abschnitt beschreibt jedes dieser Schlüsselwörter
	und ihre Optionen.  Es ist jedoch keine vollständige Liste
	aller möglichen Optionen.  &man.ipf.5; enthält eine
	vollständige Beschreibung der Syntax und einige
	Beispiele zur Erstellung von
	<application>IPF</application>-Regeln.</para>

      <variablelist>
	<varlistentry>
	  <term>ACTION</term>

	  <listitem>
	    <para>Dieses Schlüsselwort bestimmt, was mit dem Paket zu
	      tun ist, wenn es auf eine Regel zutrifft.  Jede Regel
	      <emphasis>muss</emphasis> dieses Schlüsselwort
	      enthalten.  Die folgenden Aktionen werden
	      erkannt:</para>

	    <para><literal>block</literal>: Das Paket wird
	      verworfen.</para>

	    <para><literal>pass</literal>: Das Paket wird
	      durchgelassen.</para>

	    <para><literal>log</literal>: Das Paket wird
	      protokolliert.</para>

	    <para><literal>count</literal>: Zählt die Anzahl der
	      Pakete und die Bytes.  Die kann einen Hinweis darauf
	      geben, wie oft Pakete auf diese Regel zutreffen.</para>

	    <para><literal>auth</literal>: Das Paket geht in eine
	      Warteschlange zur Weiterverarbeitung durch ein anderes
	      Programm.</para>

	    <para><literal>call</literal>: Ermöglicht den Zugriff auf
	      eingebaute <application>IPF</application>-Funktionen,
	      die komplexere Aktionen ermöglichen.</para>

	    <para><literal>decapsulate</literal>: Entfernt alle
	      Header, um den Inhalt des Pakets zu verarbeiten.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>DIRECTION</term>

	  <listitem>
	    <para>Als nächstes muss für jede Regel explizit die
	      Richtung mit einem der folgenden Schlüsselwörter
	      angegeben werden:</para>

	    <para><literal>in</literal>: Die Regel wird auf ein
	      eingehendes Paket angewendet.</para>

	    <para><literal>out</literal>: Die Regel wird auf ein
	      ausgehendes Paket angewendet.</para>

	    <para><literal>all</literal>: Die Regel gilt für beide
	      Richtungen.</para>

	    <para>Wenn das System mehrere Schnittstellen ausweist,
	      kann die Schnittstelle zusammen mit der Richtung
	      angegeben werden.  Ein Beispiel wäre
	      <literal>in on fxp0</literal>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>OPTIONS</term>

	  <listitem>
	    <para>Optionen müssen nicht zwingend angegeben werden.
	      Falls jedoch mehrere Optionen angegeben werden, müssen
	      sie in der hier gezeigten Reihenfolge verwendet
	      werden.</para>

	    <para><literal>log</literal>: Wenn die Firewall die
	      angegebene Aktion durchführt, werden die Kopfdaten des
	      Pakets auf der Pseudo-Schnittstelle &man.ipl.4;
	      protokolliert.</para>

	    <para><literal>quick</literal>: Wenn ein Paket mit dieser
	      Regel übereinstimmt, wird die Aktion für diese Regel
	      ausgeführt und die Regelprüfung stoppt an dieser
	      Stelle.</para>

	    <para><literal>on</literal>: Auf dieses Schlüsselwort muss
	      der Name der Schnittstelle folgen.  Die Regel trifft nur
	      dann zu, wenn das Paket auf der angegebenen
	      Schnittstelle in die angegebene Richtung geht.</para>

	    <para>Wenn das Schlüsselwort <literal>log</literal>
	      verwendet wird, können die folgenden Ausdrücke in
	      dieser Reihenfolge benutzt werden:</para>

	    <para><literal>body</literal>: die ersten 128 Bytes des
	      Paketinhaltes werden zusätzlich zu den Kopfdaten
	      protokolliert.</para>

	    <para><literal>first</literal>: trifft nur zu, wenn das
	      Schlüsselwort <literal>log</literal> zusammen mit
	      <literal>keep-state</literal> verwendet wird.  Es
	      bestimmt, dass nur das auslösende Paket protokolliert
	      wird und nicht jedes weitere Paket, dass von der
	      gespeicherten Status-Regel betroffen ist.</para>

	    <para>Es stehen noch weitere Optionen zur Rückmeldung
	      von Fehlern verfügbar.  Ausführliche Details finden Sie
	      in &man.ipf.5;.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>PROTO_TYPE</term>

	  <listitem>
	    <para>Der Protokolltyp ist optional.  Er ist jedoch
	      zwingend erforderlich, falls die Regel einen
	      SRC_PORT oder DST_PORT angeben muss da es den Typ des
	      Protokolls bestimmt.  Wenn Sie das Protokoll angeben,
	      verwenden Sie das Schlüsselwort
	      <literal>proto</literal>, gefolgt von der
	      Protokollnummer oder dem Namen aus
	      <filename>/etc/protocols</filename>.  Zum Beispiel
	      <literal>tcp</literal>, <literal>udp</literal>, oder
	      <literal>icmp</literal>.  Wenn PROTO_TYPE angegeben
	      wird und SCR_PORT oder DST_PORT ausgelassen werden,
	      stimmen alle Portnummern für dieses Protokoll mit dieser
	      Regel überein.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>SRC_ADDR</term>

	  <listitem>
	    <para>Das Schlüsselwort <literal>from</literal> ist
	      verpflichtend und darauf folgt das Schlüsselwort, das
	      die Quelle des Pakets darstellt.  Die Quelle kann ein
	      Rechnername, eine <acronym>IP</acronym>-Adresse gefolgt
	      von der <acronym>CIDR</acronym>-Maske, ein Adresspool
	      oder das Schlüsselwort <literal>all</literal> sein.
	      &man.ipf.5; enthält einige Beispiele.</para>

	    <para><acronym>IP</acronym>-Bereiche können nur in der
	      <acronym>CIDR</acronym>-Notation angegeben werden.  Der
	      Port oder das Paket <package>net-mgmt/ipcalc</package>
	      hilft bei der Berechnung der richtigen
	      <acronym>CIDR</acronym>-Maske.  Weiterführende
	      Informationen finden Sie auf der Webseite <uri
		xlink:href="http://jodies.de/ipcalc">
		http://jodies.de/ipcalc</uri>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>SCR_PORT</term>

	  <listitem>
	    <para>Die Portnummer der Quelle ist optional.  Wenn sie
	      jedoch verwendet wird, muss in der Regel zuerst
	      PROTO_TYPE angegeben werden.  Die Portnummer muss auch
	      auf das Schlüsselwort <literal>proto</literal>
	      folgen.</para>

	    <para>Es werden verschiedene Vergleichsoperatoren
	      unterstützt: <literal>=</literal> (gleich),
	      <literal>!=</literal> (nicht gleich),
	      <literal>&lt;</literal> (kleiner als),
	      <literal>&gt;</literal> (größer als),
	      <literal>&lt;=</literal> (kleiner als oder gleich)
	      <literal>&gt;=</literal> (größer als oder
	      gleich).</para>

	    <para>Um Portbereiche anzugeben, schreiben Sie zwei
	      Portnummern zwischen <literal>&lt;&gt;</literal>
	      (kleiner als und größer als),
	      <literal>&gt;&lt;</literal> (größer als und kleiner
	      als), oder <literal>:</literal> (größer als oder gleich
	      und kleiner als oder gleich).</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>DST_ADDR</term>

	  <listitem>
	    <para>Das Schlüsselwort <literal>to</literal> ist
	      verpflichtend und darauf folgt das Schlüsselwort,
	      welches das Ziel des Pakets darstellt.  Dieses Ziel kann
	      ein Rechnername, eine <acronym>IP</acronym>-Adresse
	      gefolgt von der <acronym>CIDR</acronym>-Maske, ein
	      Adresspool oder das Schlüsselwort <literal>all</literal>
	      sein.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>DST_PORT</term>

	  <listitem>
	    <para>Die Portnummer des Ziels ist optional.  Wenn sie
	      jedoch verwendet wird, muss in der Regel zuerst
	      PROTO_TYPE angegeben werden.  Die Portnummer muss auch
	      auf das Schlüsselwort <literal>proto</literal>
	      folgen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>TCP_FLAG|ICMP_TYPE</term>

	  <listitem>
	    <para>Wenn <literal>tcp</literal> als PROTO_TYPE verwendet
	      wird, können bestimmte <acronym>TCP</acronym>-Flags
	      angegeben werden, die den Zustand einer Verbindung
	      bestimmen.  Mögliche Flags sind:
	      <literal>S</literal> (SYN),
	      <literal>A</literal> (ACK),
	      <literal>P</literal> (PSH),
	      <literal>F</literal> (FIN),
	      <literal>U</literal> (URG),
	      <literal>R</literal> (RST),
	      <literal>C</literal> (CWN) und
	      <literal>E</literal> (ECN).</para>

	    <para>Wenn <literal>icmp</literal> als PROTO_TYPE
	      verwendet wird, kann der <acronym>ICMP</acronym>-Typ mit
	      angegeben werden.  &man.ipf.5; enthält eine Auflistung
	      der zulässigen Typen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>STATE</term>

	  <listitem>
	    <para>Wenn eine <literal>pass</literal>-Regel das
	      Schlüsselwort <literal>keep state</literal> enthält,
	      wird <application>IPF</application> einen Eintrag in
	      der dynamischen Zustandstabelle hinzufügen, damit
	      nachfolgende Pakete dieser Verbindung ebenfalls
	      durchgelassen werden.  <application>IPF</application>
	      kann den Zustand für <acronym>TCP</acronym>,
	      <acronym>UDP</acronym> und
	      <acronym>ICMP</acronym>-Sitzungen verfolgen.
	      <application>IPF</application> wird jedes Paket, das
	      zu einer aktiven Sitzung gehört, durchlassen, auch
	      wenn ein anderes Protokoll verwendet wird.</para>

	    <para>Pakete, die über die Schnittstelle zum öffentlichen
	      Internet raus gehen, werden von
	      <application>IPF</application> zuerst gegen die
	      dynamische Zustandstabelle geprüft.  Wenn das nächste
	      Paket dieser aktiven Sitzung mit dem vorherigen Paket
	      übereinstimmt, verlässt dieses Paket die Firewall und
	      der Status wird in der dynamischen Zustandstabelle
	      aktualisiert.  Pakete, die nicht zu einer aktiven
	      Sitzung gehören, werden gegen ausgehende Regeln geprüft.
	      Eingehende Pakete von der Schnittstelle zum öffentlichen
	      Internet werden gegen die dynamische Zustandstabelle
	      geprüft.  Wenn das nächste Paket mit der aktiven Sitzung
	      übereinstimmt, verlässt dieses Paket die Firewall und
	      der Status wird in der dynamischen Zustandstabelle
	      aktualisiert.  Pakete, die nicht zu einer aktiven
	      Sitzung gehören, werden gegen eingehende Regeln
	      geprüft.</para>

	    <para>Mehrere Schlüsselwörter können an
	      <literal>keep state</literal> angefügt werden.  Bei der
	      Verwendung dieser Schlüsselwörter werden verschiedene
	      Optionen gesetzt, um die zustandsorientierte Filterung
	      zu steuern.  &man.ipf.5; enthält eine Liste der
	      verfügbaren Optionen und deren Beschreibungen.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2>
      <title>Beispielregelsatz</title>

      <para>Dieser Abschnitt beschreibt die Erstellung eines
	Regelsatzes, welcher nur entsprechende Dienste erlaubt und
	alle anderen Verbindungen blockiert.</para>

      <para>&os; verwendet die Loopback-Schnittstelle
	(<filename>lo0</filename>) und die
	<acronym>IP</acronym>-Adresse <systemitem
	  class="ipaddress">127.0.0.1</systemitem> zur internen
	Kommunikation.  Der Regelsatz muss Regeln enthalten, die
	Pakete für diesen internen Verkehr ermöglichen:</para>

      <programlisting># no restrictions on the loopback interface
pass in quick on lo0 all
pass out quick on lo0 all</programlisting>

      <para>Die mit dem Internet verbundene Schnittstelle wird für die
	Autorisierung und den Zugriff aller ein- und ausgehenden
	Verbindungen verwendet.  Wenn eine oder mehrere Schnittstellen
	mit privaten Netzwerken verbunden sind, müssen Regeln
	existieren, die den Datenverkehr aus dem
	<acronym>LAN</acronym> zwischen den internen Netzwerken oder
	ins Internet erlauben.  Der Regelsatz sollte in drei Bereiche
	unterteilt werden: vertrauenswürdige interne Schnittstellen,
	ausgehende Verbindungen über die öffentlichen Schnittstellen
	und eingehende Verbindungen über die öffentliche
	Schnittstelle.</para>

      <para>Diese beiden Regeln erlauben den gesamten Datenverkehr
	über eine vertrauenswürdige
	<acronym>LAN</acronym>-Schnittstelle namens
	<filename>xl0</filename>:</para>

      <programlisting># no restrictions on inside LAN interface for private network
pass out quick on xl0 all
pass in quick on xl0 all</programlisting>

      <para>Die Regeln für den ein- und ausgehenden Verkehr der
	öffentlichen Schnittstelle sollten in einer bestimmten
	Reihenfolge geschrieben werden.  Zuerst Regeln, die häufiger
	übereinstimmen, danach Regeln, die seltener übereinstimmen.
	Die letzte Regel blockiert und protokolliert alle Pakete auf
	der Schnittstelle.</para>

      <para>Der folgende Regelsatz definiert die ausgehenden Regeln
	der öffentlichen Schnittstelle <filename>dc0</filename>.
	Die Regeln prüfen den Zustand und identifizieren bestimmte
	Dienste, auf die die internen Systeme zugreifen dürfen.  Alle
	Regeln verwenden das Schlüsselwort <literal>quick</literal>
	und geben die passenden Portnummern und ggf. auch die
	Zieladressen an.</para>

      <programlisting># interface facing Internet (outbound)
# Matches session start requests originating from or behind the
# firewall, destined for the Internet.

# Allow outbound access to public DNS servers.
# Replace x.x.x. with address listed in /etc/resolv.conf.
# Repeat for each DNS server.
pass out quick on dc0 proto tcp from any to x.x.x. port = 53 flags S keep state
pass out quick on dc0 proto udp from any to xxx port = 53 keep state

# Allow access to ISP's specified DHCP server for cable or DSL networks.
# Use the first rule, then check log for the IP address of DHCP server.
# Then, uncomment the second rule, replace z.z.z.z with the IP address,
# and comment out the first rule
pass out log quick on dc0 proto udp from any to any port = 67 keep state
#pass out quick on dc0 proto udp from any to z.z.z.z port = 67 keep state

# Allow HTTP and HTTPS
pass out quick on dc0 proto tcp from any to any port = 80 flags S keep state
pass out quick on dc0 proto tcp from any to any port = 443 flags S keep state

# Allow email
pass out quick on dc0 proto tcp from any to any port = 110 flags S keep state
pass out quick on dc0 proto tcp from any to any port = 25 flags S keep state

# Allow NTP
pass out quick on dc0 proto tcp from any to any port = 37 flags S keep state

# Allow FTP
pass out quick on dc0 proto tcp from any to any port = 21 flags S keep state

# Allow SSH
pass out quick on dc0 proto tcp from any to any port = 22 flags S keep state

# Allow ping
pass out quick on dc0 proto icmp from any to any icmp-type 8 keep state

# Block and log everything else
block out log first quick on dc0 all</programlisting>

      <para>Die folgenden Beispielregeln für den eingehenden Verkehr
	auf der öffentlichen Schnittstelle blockieren zuerst alle
	unerwünschten Pakete.  Dies reduziert die Anzahl der Pakete,
	die durch die letzte Regel protokolliert werden.</para>

      <programlisting># interface facing Internet (inbound)
# Block all inbound traffic from non-routable or reserved address spaces
block in quick on dc0 from 192.168.0.0/16 to any    #RFC 1918 private IP
block in quick on dc0 from 172.16.0.0/12 to any     #RFC 1918 private IP
block in quick on dc0 from 10.0.0.0/8 to any        #RFC 1918 private IP
block in quick on dc0 from 127.0.0.0/8 to any       #loopback
block in quick on dc0 from 0.0.0.0/8 to any         #loopback
block in quick on dc0 from 169.254.0.0/16 to any    #DHCP auto-config
block in quick on dc0 from 192.0.2.0/24 to any      #reserved for docs
block in quick on dc0 from 204.152.64.0/23 to any   #Sun cluster interconnect
block in quick on dc0 from 224.0.0.0/3 to any       #Class D &amp; E multicast

# Block fragments and too short tcp packets
block in quick on dc0 all with frags
block in quick on dc0 proto tcp all with short

# block source routed packets
block in quick on dc0 all with opt lsrr
block in quick on dc0 all with opt ssrr

# Block OS fingerprint attempts and log first occurrence
block in log first quick on dc0 proto tcp from any to any flags FUP

# Block anything with special options
block in quick on dc0 all with ipopts

# Block public pings and ident
block in quick on dc0 proto icmp all icmp-type 8
block in quick on dc0 proto tcp from any to any port = 113

# Block incoming Netbios services
block in log first quick on dc0 proto tcp/udp from any to any port = 137
block in log first quick on dc0 proto tcp/udp from any to any port = 138
block in log first quick on dc0 proto tcp/udp from any to any port = 139
block in log first quick on dc0 proto tcp/udp from any to any port = 81</programlisting>

      <para>Wenn eine Regel mit der Option
	<literal>log first</literal> protokolliert wird, können Sie
	mit <command>ipfstat -hio</command> prüfen, wie viele
	Übereinstimmungen es für diese Regel gibt.  Eine große Anzahl
	von Übereinstimmungen kann darauf hindeuten, dass das System
	angegriffen wird.</para>

      <para>Die restlichen Regeln definieren, welche Verbindungen aus
	dem Internet kommend hergestellt werden dürfen.  Die letzte
	Regel blockiert alle Verbindungen, die nicht ausdrücklich von
	vorhergehenden Regeln erlaubt wurden.</para>

      <programlisting># Allow traffic in from ISP's DHCP server. Replace z.z.z.z with
# the same IP address used in the outbound section.
pass in quick on dc0 proto udp from z.z.z.z to any port = 68 keep state

# Allow public connections to specified internal web server
pass in quick on dc0 proto tcp from any to x.x.x.x port = 80 flags S keep state

# Block and log only first occurrence of all remaining traffic.
block in log first quick on dc0 all</programlisting>
    </sect2>

    <sect2>
      <title><acronym>NAT</acronym> Konfiguration</title>

      <para>Um <acronym>NAT</acronym> zu aktivieren, fügen Sie
	folgende Zeilen in <filename>/etc/rc.conf</filename> hinzu.
	Geben Sie den Namen der Datei an, welche die
	<acronym>NAT</acronym>-Regeln enthält:</para>

      <programlisting>gateway_enable="YES"
ipnat_enable="YES"
ipnat_rules="/etc/ipnat.rules"</programlisting>

      <para><acronym>NAT</acronym>-Regeln sind sehr flexibel, um den
	Bedürfnissen von kommerziellen Anwendern und Heimanwendern
	gerecht zu werden.  Die hier vorgestellte Regelsyntax wurde
	vereinfacht, um die gemeinsame Nutzung zu demonstrieren.
	Eine vollständige Beschreibung der Syntax finden Sie in
	&man.ipnat.5;.</para>

      <para>Die grundlegende Syntax für eine
	<acronym>NAT</acronym>-Regel ist wie folgt.
	<literal>map</literal> leitet die Regel ein und
	<literal>IF</literal> sollte durch den Namen der externen
	Schnittstelle ersetzt werden:</para>

      <programlisting>map <replaceable>IF</replaceable> <replaceable>LAN_IP_RANGE</replaceable> -&gt; <replaceable>PUBLIC_ADDRESS</replaceable></programlisting>

      <para><replaceable>LAN_IP_RANGE</replaceable> ist ein Bereich
	von <acronym>IP</acronym>-Adressen, der von den internen
	Rechnern verwendet wird.  In der Regel ist dies ein privater
	Bereich, beispielsweise <systemitem
	  class="ipaddress">192.168.1.0/24</systemitem>.
	<replaceable>PUBLIC_ADDRESS</replaceable> kann entweder eine
	statische externe <acronym>IP</acronym>-Adresse sein, oder das
	Schlüsselwort <literal>0/32</literal>, welches der
	zugewiesenen <acronym>IP</acronym>-Adresse für
	<replaceable>IF</replaceable> entspricht.</para>

      <para>Wenn ein Paket aus dem <acronym>LAN</acronym> mit einem
	öffentlichen Ziel an der <application>IPF</application>
	Firewall ankommt, werden zunächst die Regeln für den
	ausgehenden Verkehr geprüft.  Danach wird das Paket an das
	<acronym>NAT</acronym>-Regelwerk geleitet, wo es von oben nach
	unten gelesen und geprüft wird, wobei die erste
	übereinstimmende Regel gewinnt.
	<application>IPF</application> testet jede
	<acronym>NAT</acronym>-Regel gegen die Schnittstelle und die
	Quell-<acronym>IP</acronym>-Adresse des Pakets.  Wenn der
	Schnittstellenname des Pakets mit einer
	<acronym>NAT</acronym>-Regel übereinstimmt, wird geprüft, ob
	die Quell-<acronym>IP</acronym>-Adresse des Pakets auf den
	Bereich in <replaceable>LAN_IP_RANGE</replaceable> passt.
	Wenn dies der Fall ist, wird die
	Quell-<acronym>IP</acronym>-Adresse des Pakets mit der Adresse
	aus <replaceable>PUBLIC_ADDRESS</replaceable>
	überschrieben.  <application>IPF</application> speichert die
	Einträge in seiner internen <acronym>NAT</acronym>-Tabelle, so
	dass wenn das Paket aus dem Internet zurückkehrt, es der
	ursprünglichen privaten <acronym>IP</acronym>-Adresse
	zugeordnet werden kann, bevor es von den weiteren
	Firewallregeln geprüft wird.</para>

      <para>Bei Netzwerken mit einer großen Anzahl von Systemen oder
	mehreren Subnetzen, steigert sich der Ressourcenverbrauch
	für das Umschreiben der <acronym>IP</acronym>-Adressen.  Es
	existieren zwei Methoden, um dieses Problem zu umgehen.</para>

      <para>Bei der ersten Methode wird ein Portbereich definiert, der
	für die Quell-Ports verwendet wird.  Durch das Hinzufügen des
	Schlüsselworts <literal>portmap</literal> kann
	<acronym>NAT</acronym> angewiesen werden, nur Quell-Ports aus
	dem angegebenen Bereich zu benutzen:</para>

      <programlisting>map dc0 192.168.1.0/24 -&gt; 0/32 portmap tcp/udp 20000:60000</programlisting>

      <para>Alternativ kann das Schlüsselwort <literal>auto</literal>
	verwendet werden.  Dadurch ermittelt <acronym>NAT</acronym>
	selbstständig die zur Verfügung stehenden Ports:</para>

      <programlisting>map dc0 192.168.1.0/24 -&gt; 0/32 portmap tcp/udp auto</programlisting>

      <para>Mit der zweiten Methode wird ein Pool von öffentlichen
	Adressen verwendet.  Dies ist nützlich, wenn es viele Systeme
	im Netzwerk gibt und ein Block öffentlicher
	<acronym>IP</acronym>-Adressen verfügbar ist.  Aus diesem Pool
	kann <acronym>NAT</acronym> dann
	<acronym>IP</acronym>-Adressen für die ausgehenden Pakete
	auswählen.</para>

      <para>Der Bereich der öffentlichen
	<acronym>IP</acronym>-Adressen kann mit einer Netzmaske oder
	der <acronym>CIDR</acronym>-Notation festgelegt werden.  Die
	folgenden Regeln sind identisch:</para>

      <programlisting>map dc0 192.168.1.0/24 -&gt; 204.134.75.0/255.255.255.0
map dc0 192.168.1.0/24 -&gt; 204.134.75.0/24</programlisting>

      <para>Es ist gängige Praxis, öffentlich zugängliche Web- oder
	Mail-Server getrennt von den internen Netzwerksegmenten zu
	betreiben.  Der Verkehr von diesen Servern muss dennoch von
	<acronym>NAT</acronym> bearbeitet werden und die Portumleitung
	ist erforderlich, um den eingehenden Datenverkehr an den
	richtigen Server zu leiten.  Verwenden Sie beispielsweise
	folgende Regel, um den eingehenden Verkehr auf der
	öffentlichen <acronym>IP</acronym>-Adresse <systemitem
	  class="ipaddress">20.20.20.5</systemitem> dem internen
	Server mit der Adresse <systemitem
	class="ipaddress">10.0.10.25</systemitem> zuzuordnen:</para>

      <programlisting>rdr dc0 20.20.20.5/32 port 80 -&gt; 10.0.10.25 port 80</programlisting>

      <para>Wenn dies der einzige Webserver im Netz ist, würde auch
	folgende Regel funktionieren, die alle
	<acronym>HTTP</acronym>-Anfragen an <systemitem
	  class="ipaddress">10.0.10.25</systemitem> umleitet:</para>

      <programlisting>rdr dc0 0.0.0.0/0 port 80 -&gt; 10.0.10.25 port 80</programlisting>

      <para><application>IPF</application> enthält einen
	<acronym>FTP</acronym>-Proxy, der zusammen mit
	<acronym>NAT</acronym> benutzt werden kann.  Dieser Proxy
	überwacht den ausgehenden Datenverkehr für aktive und passive
	Verbindungsanfragen und erstellt dynamische Filterregeln,
	welche die Portnummern des jeweiligen
	<acronym>FTP</acronym>-Datenkanal enthalten.  Dadurch entfällt
	die Notwendigkeit, viele Ports für
	<acronym>FTP</acronym>-Verbindungen zu öffnen.</para>

      <para>In diesem Beispiel verwendet die erste Regel den Proxy
	für ausgehende <acronym>FTP</acronym>-Verbindungen aus dem
	internen <acronym>LAN</acronym>.  Die zweite Regel übergibt
	den <acronym>FTP</acronym>-Datenverkehr von der Firewall an
	das Internet und die dritte Regel handhabt den restlichen
	Datenverkehr aus dem internen <acronym>LAN</acronym>:</para>

      <programlisting>map dc0 10.0.10.0/29 -&gt; 0/32 proxy port 21 ftp/tcp
map dc0 0.0.0.0/0 -&gt; 0/32 proxy port 21 ftp/tcp
map dc0 10.0.10.0/29 -&gt; 0/32</programlisting>

      <para><acronym>FTP</acronym> <literal>map</literal>-Regeln
	stehen vor den <acronym>NAT</acronym>-Regeln.  Wenn ein Paket
	mit der <acronym>FTP</acronym>-Regel übereinstimmt, erstellt
	der <acronym>FTP</acronym>-Proxy eine temporäre Filterregel,
	damit die Pakete durchgelassen und von <acronym>NAT</acronym>
	verarbeitet werden können.  Alle Pakte aus dem
	<acronym>LAN</acronym>, die nicht für <acronym>FTP</acronym>
	bestimmt sind, werden von <acronym>NAT</acronym> verarbeitet,
	wenn sie mit der dritten Regel übereinstimmen.</para>

      <para>Ohne den <acronym>FTP</acronym>-Proxy würden stattdessen
	folgende Regeln benötigt.  Beachten Sie, dass ohne den Proxy
	alle Ports oberhalb von <literal>1024</literal> freigegeben
	werden müssen:</para>

      <programlisting># Allow out LAN PC client FTP to public Internet
# Active and passive modes
pass out quick on rl0 proto tcp from any to any port = 21 flags S keep state

# Allow out passive mode data channel high order port numbers
pass out quick on rl0 proto tcp from any to any port &gt; 1024 flags S keep state$
# Active mode let data channel in from FTP server
pass in quick on rl0 proto tcp from any to any port = 20 flags S keep state</programlisting>

      <para>Nachdem die Datei mit den <acronym>NAT</acronym>-Regeln
	bearbeitet wurde, führen Sie <command>ipnat</command> mit
	<option>-CF</option> aus, um die aktuellen
	<acronym>NAT</acronym>-Regeln und den Inhalt der dynamischen
	Zuordnungstabelle zu löschen.  Geben Sie
	<option>-f</option> zusammen mit dem
	<acronym>NAT</acronym>-Regelsatz an:</para>

      <screen>&prompt.root; <userinput>ipnat -CF -f /etc/ipnat.rules</userinput></screen>

      <para>Statistiken zu <acronym>NAT</acronym> lassen sich wie
	folgt anzeigen:</para>

      <screen>&prompt.root; <userinput>ipnat -s</userinput></screen>

      <para>Die aktuellen Zuordnungen der
	<acronym>NAT</acronym>-Tabelle geben Sie mit diesem Kommando
	aus:</para>

      <screen>&prompt.root; <userinput>ipnat -l</userinput></screen>

      <para>Ausführliche Informationen erhalten Sie mit:</para>

      <screen>&prompt.root; <userinput>ipnat -v</userinput></screen>
    </sect2>

    <sect2>
      <title><application>IPF</application> Statistiken</title>

      <indexterm><primary>ipfstat</primary></indexterm>
      <indexterm>
	<primary>IPFILTER</primary>
	<secondary>Statistiken</secondary>
      </indexterm>

      <para><application>IPF</application> enthält mit &man.ipfstat.8;
	ein Werkzeug, mit dem Statistiken abgerufen und angezeigt
	werden können.  Die Zahlen beziehen sich auf den Zeitpunkt, an
	dem die Firewall zuletzt gestartet wurde, beziehungsweise die
	Statistik mit <command>ipf -Z</command> zurückgesetzt
	wurde.</para>

      <para>Die Ausgabe von <command>ifstat</command> sieht in etwa
	wie folgt aus:</para>

      <screen>input packets: blocked 99286 passed 1255609 nomatch 14686 counted 0
output packets: blocked 4200 passed 1284345 nomatch 14687 counted 0
input packets logged: blocked 99286 passed 0
output packets logged: blocked 0 passed 0
packets logged: input 0 output 0
log failures: input 3898 output 0
fragment state(in): kept 0 lost 0
fragment state(out): kept 0 lost 0
packet state(in): kept 169364 lost 0
packet state(out): kept 431395 lost 0
ICMP replies: 0 TCP RSTs sent: 0
Result cache hits(in): 1215208 (out): 1098963
IN Pullups succeeded: 2 failed: 0
OUT Pullups succeeded: 0 failed: 0
Fastroute successes: 0 failures: 0
TCP cksum fails(in): 0 (out): 0
Packet log flags set: (0)</screen>

      <para>Es stehen viele Optionen zur Verfügung.  Wird entweder
	<option>-i</option> (eingehend) oder <option>-o</option>
	(ausgehend) angegeben, wird der Befehl die entsprechende
	Liste mit den derzeit vom Kernel benutzten Filterregeln
	anzeigen.  Um auch die Regelnummern zu sehen, muss
	<option>-n</option> angegeben werden.  Zum Beispiel zeigt
	<command>ipfstat -on</command> die Tabelle für ausgehende
	Regeln und die Regelnummer an:</para>

      <screen>@1 pass out on xl0 from any to any
@2 block out on dc0 from any to any
@3 pass out quick on dc0 proto tcp/udp from any to any keep state</screen>

      <para>Wenn Sie der Regel ein <option>-h</option> voranstellen,
	wird der Zähler für die jeweilige Regel ausgegeben.  Zum
	Beispiel gibt <command>ipfstat -oh</command> die ausgehenden
	Regeln inklusive der Zähler aus:</para>

      <screen>2451423 pass out on xl0 from any to any
354727 block out on dc0 from any to any
430918 pass out quick on dc0 proto tcp/udp from any to any keep state</screen>

      <para>Benutzen Sie <command>ipfstat -t</command> um die
	Zustandstabelle in einem &man.top.1; ähnlichen Format
	anzuzeigen.  Unterliegt die Firewall einem Angriff, bietet
	diese Option die Möglichkeit, die entsprechenden Pakete zu
	identifizieren.  Mit den optionalen Flags können
	<acronym>IP</acronym>-Adressen, Ports oder Protokolle in
	Echtzeit überwacht werden.  Lesen Sie &man.ipfstat.8; für
	weitere Informationen.</para>
    </sect2>

    <sect2>
      <title><application>IPF</application> Protokollierung</title>

      <indexterm>
	<primary><command>ipmon</command></primary>
      </indexterm>

      <indexterm>
	<primary><application>IPFILTER</application></primary>
	<secondary>Protokollierung</secondary>
      </indexterm>

      <para><application>IPF</application> enthält mit
	<command>ipmon</command> ein Werkzeug, mit dem die
	Protokolle der Firewall in menschenlesbarer Form gespeichert
	werden können.  Dies erfordert jedoch, dass
	<literal>options IPFILTER_LOG</literal> in die
	Kernelkonfigurationsdatei hinzugefügt wird.  Folgen Sie dazu
	den Anweisungen in <xref linkend="kernelconfig"/>.</para>

      <para>Um eine kontinuierliche Protokolldatei bereitzustellen,
	läuft dieses Kommando normalerweise im Daemon-Modus, damit
	auch ältere Ereignisse nachverfolgt werden können.  Da &os;
	mit &man.syslogd.8; ein Werkzeug besitzt, das automatisch
	Protokolldateien rotiert, wird in der Voreinstellung für
	<literal>ipmon_flags</literal> <literal>-Ds</literal> in
	<filename>rc.conf</filename> verwendet:</para>

      <programlisting>ipmon_flags="-Ds" # D = start as daemon
                  # s = log to syslog
                  # v = log tcp window, ack, seq
                  # n = map IP &amp; port to names</programlisting>

      <para>Protokollierung bietet die im Nachhinein die Möglichkeit
	festzustellen, welche Pakete verworfen wurden, von welchen
	Adressen diese Pakete kamen und wohin sie gehen sollten.
	Diese Informationen sind hilfreich beim Aufspüren von
	Angreifern.</para>

      <para>Nachdem die Protokollierung in
	<filename>/etc/rc.conf</filename> aktiviert und mit
	<command>service ipmon start</command> gestartet wurde, wird
	<application>IPF</application> Regeln aufzeichnen, welche das
	Schlüsselwort <literal>log</literal> enthalten.  Der
	Firewalladministrator entscheidet, welche Regeln protokolliert
	werden.  In der Regel werden nur geblockte Pakete
	protokolliert.  Es ist üblich, das Schlüsselwort
	<literal>log</literal> in der letzten Regel des Regelsatzes
	mit aufzunehmen.  Dies macht es möglich, alle Pakete zu sehen,
	die mit keiner Regel des Regelsatzes übereinstimmten.</para>

      <para>In der Voreinstellung verwendet
	<command>ipmon -Ds</command> <literal>local0</literal> als
	Protokoll-Facility.  Die folgenden Level können verwendet
	werden, um die erfassten Daten weiter aufzuspalten:</para>

      <screen>LOG_INFO - packets logged using the "log" keyword as the action rather than pass or block.
LOG_NOTICE - packets logged which are also passed
LOG_WARNING - packets logged which are also blocked
LOG_ERR - packets which have been logged and which can be considered short due to an incomplete header</screen>

      <para>Damit <application>IPF</application> alle Daten
	protokolliert, legen Sie zunächst eine neue Datei
	<filename>/var/log/ipfilter.log</filename> an:</para>

      <screen>&prompt.root; <userinput>touch /var/log/ipfilter.log</userinput></screen>

      <para>Um alle Nachrichten in der angegebenen Datei zu
	protokollieren, fügen Sie den folgenden Eintrag in
	<filename>/etc/syslog.conf</filename> ein:</para>

      <programlisting>local0.* /var/log/ipfilter.log</programlisting>

      <para>Führen Sie <command>service syslogd reload</command> aus,
	damit &man.syslogd.8; <filename>/etc/syslog.conf</filename>
	neu einliest, um die Änderungen zu aktivieren.</para>

      <para>Denken Sie daran, auch
	<filename>/etc/newsyslog.conf</filename> anzupassen, damit das
	neue Protokoll rotiert wird.</para>

      <para>Die von <command>ipmon</command> generierten Nachrichten
	bestehen aus Daten, welche durch Leerzeichen getrennt sind.
	Alle Nachrichten enthalten die folgenden Felder:</para>

      <orderedlist>
	<listitem>
	  <para>Das Datum, an dem das Paket empfangen wurde.</para>
	</listitem>

	<listitem>
	  <para>Die Uhrzeit, wann das Paket empfangen wurde.  Das
	    Format ist HH:MM:SS.F (Stunden, Minuten, Sekunden und
	    Sekundenbruchteile).</para>
	</listitem>

	<listitem>
	  <para>Der Name der Schnittstelle, die das Paket
	    verarbeitet hat.</para>
	</listitem>

	<listitem>
	  <para>Die Gruppen- und Regelnummer im Format
	    <literal>@0:17</literal>.</para>
	</listitem>

	<listitem>
	  <para>Die Aktion: <literal>p</literal> für durchgelassene
	    Pakete, <literal>b</literal> für blockierte Pakete,
	    <literal>S</literal> für kurze Pakete,
	    <literal>n</literal> für Pakete auf die keine Regel zutraf
	    und <literal>L</literal> für Pakete die protokolliert
	    wurden.</para>
	</listitem>

	<listitem>
	  <para>Die Adressen werden in drei Felder unterteilt: die
	    Quelladresse und der Port getrennt durch Komma, das
	    Zeichen -&gt;, sowie die Zieladresse und Port.  Zum
	    Beispiel <literal>209.53.17.22,80 -&gt;
	      198.72.220.17,1722</literal>.</para>
	</listitem>

	<listitem>
	  <para><literal>PR</literal>, gefolgt vom Namen oder Nummer
	    des Protokolls.  Zum Beispiel
	    <literal>PR tcp</literal>.</para>
	</listitem>

	<listitem>
	  <para><literal>len</literal>, gefolgt von der Größe des
	    Headers und der Gesamtgröße des Pakets.  Zum Beispiel
	    <literal>len 20 40</literal>.</para>
	</listitem>
      </orderedlist>

      <para>Wenn es sich beim dem Paket um ein
	<acronym>TCP</acronym>-Paket handelt, gibt es ein zusätzliches
	Feld, das mit einem Bindestrich beginnt und die Buchstaben der
	entsprechenden Flags enthält.  Eine Liste der Flags und deren
	Buchstaben finden Sie in &man.ipf.5;.</para>

      <para>Wenn es sich beim dem Paket um ein
	<acronym>ICMP</acronym>-Paket handelt, gibt es zwei
	zusätzliche Felder: das erste Feld ist immer
	<quote>icmp</quote> und das zweite Feld enthält die
	<acronym>ICMP</acronym>-Nachricht und den Nachrichten-Code,
	getrennt durch einen Schrägstrich.  Beispielswiese
	<literal>icmp 3/3</literal> für die Nachricht
	<foreignphrase>Port unreachable</foreignphrase>.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="firewalls-blacklistd">
    <title>Blacklistd</title>

    <para>Blacklistd ist ein Daemon der auf Sockets lauscht, um
      Benachrichtigungen von anderen Daemons über fehlgeschlagene
      oder erfolgreiche Verbindungsversuche zu erhalten.  Dieser
      Daemon wird häufig verwendet, um zu viele Verbindungsversuche
      auf offenen Ports zu blockieren.  Ein Beispiel ist
      <application>SSH</application>, das viele Anfragen von Bots oder
      Skripten erhält, die versuchen, Passwörter zu erraten und
      Zugriff zu erhalten.  Mit Hilfe von
      <application>blacklistd</application> kann der Daemon
      die Firewall benachrichtigen, eine Filterregel zu erstellen, um
      übermäßige Verbindungsversuche einer einzigen Quelle nach einer
      Reihe von Versuchen zu blockieren.  Blacklistd wurde
      ursprünglich auf NetBSD entwickelt und erschien dort in der
      Version 7.  &os;&nbsp;11 hat blacklistd von NetBSD
      importiert.</para>

    <para>In diesem Kapitel wird die Einrichtung und Konfiguration
      von blacklistd besprochen.  Sie finden aber auch Beispiele für
      die Verwendung von blacklistd.  Sie sollten allerdings mit
      grundlegenden Firewall-Konzepten wie Filterregeln vertraut sein.
      Weitere Informationen finden Sie im Kapitel Firewalls.  In
      diesen Beispielen wird PF benutzt, aber auch andere unter &os;
      verfügbare Firewalls sollten in der Lage sein mit blacklistd
      zusammen zu arbeiten.</para>

    <sect2>
      <title>Blacklistd aktivieren</title>

      <para>Die Konfiguration für blacklistd wird in
	&man.blacklistd.conf.5; gespeichert.  Um das Laufzeitverhalten
	von blacklistd zu beeinflussen, sind verschiedene
	Kommandozeilenoptionen verfügbar.  Die permanente
	Konfiguration über Neustarts hinweg sollte in
	<filename>/etc/blacklistd.conf</filename> gespeichert
	werden.  Um den Daemon während des Systemstarts zu aktivieren,
	fügen Sie eine Zeile <literal>blacklistd_enable</literal> in
	<filename>/etc/rc.conf</filename> hinzu:</para>

      <screen>&prompt.root; <userinput>sysrc blacklistd_enable=yes</userinput></screen>

      <para>Sie können den Daemon auch manuell starten:</para>

      <screen>&prompt.root; <userinput>service blacklistd start</userinput></screen>
    </sect2>

    <sect2>
      <title>Erstellen von Blacklistd-Regeln</title>

      <para>Die Regeln für blacklistd werden in
	&man.blacklistd.conf.5; mit einem Eintrag pro Zeile
	konfiguriert.  Jede Regel enthält ein Tupel, das durch
	Leerzeichen oder Tabulator getrennt ist.  Eine Regel gilt
	entweder für einen lokalen oder einen
	entfernten Rechner.</para>

      <sect3>
	<title>Lokale Regeln</title>

	<para>Ein typischer Eintrag für eine lokale Regel in
	  <filename>/etc/blacklistd.conf</filename> sieht wie
	  folgt aus:</para>

	<programlisting>[local]
ssh             stream  *       *               *       3       24h</programlisting>

	<para>Alle Regeln, die dem Abschnitt
	  <literal>[local]</literal> folgen, werden als lokale Regeln
	  behandelt, die für den lokalen Rechner gelten.  In einem
	  <literal>[remote]</literal>-Abschnitt gelten alle Regeln für
	  entfernte Maschinen.</para>

	<para>Die sieben Felder einer Regel werden entweder durch
	  Tabulator oder Leerzeichen getrennt.  Die ersten vier Felder
	  identifizieren den Netzwerkverkehr, welcher geblockt werden
	  soll.  Die drei folgenden Felder definieren das Verhalten
	  von blacklistd.  Wildcards werden mit einem Sternchen
	  (<literal>*</literal>) gekennzeichnet und stimmen mit allen
	  anderen in diesem Feld überein.  Das erste Feld definiert
	  den Standort.  In den lokalen Regeln sind dies die Ports.
	  Die Syntax ist wie folgt:</para>

	<programlisting>[<replaceable>address</replaceable>|<replaceable>interface</replaceable>][/<replaceable>mask</replaceable>][:<replaceable>port</replaceable>]</programlisting>

	<para>Adressen können als IPv4 im numerischen Format oder IPv6
	  in eckigen Klammern angegeben werden.  Ebenfalls kann der
	  Name der Schnittstelle wie
	  <literal><replaceable>em0</replaceable></literal> verwendet
	  werden.</para>

	<para>Im zweiten Feld wird der Socket-Typ definiert.
	  TCP-Sockets sind vom Typ <literal>stream</literal>,
	  wohingegen UDP als <literal>dgram</literal> bezeichnet wird.
	  Das obige Beispiel verwendet TCP, weil SSH dieses Protokoll
	  benutzt.</para>

	<para>Im dritten Feld kann ein Protokoll definiert werden.
	  Die folgenden Protokolle können verwendet werden:
	  <literal>tcp</literal>, <literal>udp</literal>,
	  <literal>tcp6</literal>, <literal>udp6</literal> oder
	  numerisch.  Eine Wildcard, wie im Beispiel, wird
	  typischerweise verwendet, um alle Protokolle abzubilden, es
	  sei denn, es gibt einen Grund, den Verkehr nach einem
	  bestimmten Protokoll zu differenzieren.</para>

	<para>Im vierten Feld wird der effektive Benutzer oder
	  Eigentümer des Daemon-Prozesses definiert, welcher das
	  Ereignis meldet.  Hier kann der Benutzer oder die
	  <acronym>UID</acronym> sowie eine Wildcard verwendet
	  werden (siehe Beispiel oben).</para>

	<para>Der Name der Firewallregel wird im fünften Feld
	  definiert.  In der Voreinstellung setzt blacklistd
	  alle geblockten Pakete unter einen pf-Anker namens
	  <literal>blacklistd</literal> in
	  <filename>pf.conf</filename> wie folgt:</para>

	<programlisting>anchor "blacklistd/*" in on $ext_if
block in
pass out</programlisting>

	<para>Für separate Blacklists kann in diesem Feld ein
	  Ankername benutzt werden.  In anderen Fällen genügt eine
	  Wildcard.  Ein Name mit vorangestelltem  Bindestrich
	  (<literal>-</literal>) bedeutet, das ein Anker mit dem
	  voreingestellten Regelnamen verwendet werden sollte.  Ein
	  modifiziertes Beispiel von oben mit dem Bindestrich würde
	  so aussehen:</para>

	<programlisting>ssh             stream  *       *               -ssh       3       24h</programlisting>

	<para>Mit einer solchen Regel werden alle neuen
	  Blacklistregeln zu einem Anker namens
	  <literal>blacklistd-ssh</literal> hinzugefügt.</para>

	<para>Um ganze Subnetze für eine einzelne Regelverletzung zu
	  blockieren, kann ein <literal>/</literal> im Regelnamen
	  benutzt werden.  Dadurch wird der verbleibende Teil des
	  Namens als Maske interpretiert, die auf die in der Regel
	  angegebene Adresse angewendet wird.  Diese Regel würde
	  beispielsweise jede Adresse blockieren, die an
	  <literal>/24</literal> angrenzt:</para>

	<programlisting>22              stream  tcp       *               */24    3       24h</programlisting>

	<note>
	  <para>Es ist wichtig, hier das richtige Protokoll anzugeben.
	    IPv4 und IPv6 behandeln <literal>/24</literal>
	    unterschiedlich, deshalb kann <literal>*</literal> im
	    dritten Feld für diese Regel nicht benutzt werden.</para>
	</note>

	<para>Diese Regel bewirkt, dass, wenn ein Rechner in
	  diesem Netzwerk wegen seines Verhaltens blockiert wird,
	  auch alle anderen Rechner aus diesem Netzwerk blockiert
	  werden.</para>

	<para>Das sechste Feld, genannt <literal>nfail</literal>, legt
	  die Anzahl der Anmeldeversuche fest, die erforderlich sind,
	  um die betreffende IP auf die Blacklist zu setzen.  Eine
	  Wildcard an dieser Stelle bedeutet, dass niemals geblockt
	  wird.  Im obigen Beispiel ist eine Anzahl von 3 definiert,
	  was bedeutet, dass die IP nach drei fehlgeschlagenen
	  Anmeldeversuchen über <application>SSH</application>
	  gesperrt wird.</para>

	<para>Das letzte Feld in der Regel gibt an, wie lange ein
	  Rechner auf der Blacklist steht.  Die Standardeinheit ist
	  Sekunden, aber Suffixe wie <literal>m</literal> (Minuten),
	  <literal>h</literal> (Stunden) und <literal>d</literal>
	  (Tage) können auch angegeben werden.</para>

	<para>Die Regel im Beispiel besagt, dass nach dreimaliger
	  Authentifizierung über <application>SSH</application> eine
	  neue PF-Regel für diesen Rechner angelegt wird.  Beim
	  Überprüfen der Regeln werden zuerst lokale Regeln, von sehr
	  spezifisch bis am wenigsten spezifisch, geprüft.  Wenn eine
	  Übereinstimmung auftritt, werden die
	  <literal>remote</literal>-Regeln angewendet und die Felder
	  <literal>name</literal>, <literal>nfail</literal> und
	  <literal>disable</literal> werden durch die entsprechende
	  <literal>remote</literal>-Regel geändert.</para>

      </sect3>

      <sect3>
	<title>Remote-Regeln</title>

	<para>Mit Remote-Regeln wird das Verhalten von blacklistd, in
	  Abhängigkeit vom aktuell ausgewerteten Remote-Rechner,
	  festgelegt.  Die einzelnen Felder einer Remote-Regel sind
	  identisch mit den Feldern einer lokalen Regel.  Der einzige
	  Unterschied besteht darin, wie blacklistd sie verwendet.
	  Zur besseren Verständlichkeit wird folgende Regel
	  benutzt:</para>

	<programlisting>[remote]
203.0.113.128/25 *      *       *               =/25    =       48h</programlisting>

	<para>Das Adressfeld kann eine IP-Adresse (entweder v4 oder
	  v6), einen Port oder beides beinhalten.  Dies ermöglicht es,
	  wie in diesem Beispiel, spezielle Regeln für einen
	  bestimmten entfernten Adressbereich festzulegen.  Die Felder
	  für den Socket-Typ, Protokoll und Besitzer werden genauso
	  wie in den lokalen Regeln interpretiert.</para>

	<para>Die Felder für den Namen sind jedoch unterschiedlich.
	  Das Gleichheitszeichen (<literal>=</literal>) in einer
	  Remote-Regel weist blacklistd an, den Wert aus der
	  entsprechenden lokalen Regel zu verwenden.  Das bedeutet,
	  dass der Eintrag der Firewall-Regel übernommen und das
	  Präfix <systemitem class="netmask">/25</systemitem> (eine
	  Netzmaske von <systemitem
	    class="netmask">255.255.255.128</systemitem>) hinzugefügt
	  wird.  Wenn eine Verbindung aus diesem Adressbereich
	  geblockt wird, ist das gesamte Subnetz betroffen.  Ein
	  PF-Ankername kann auch hier verwendet werden.  In diesem
	  Fall fügt blacklistd Regeln für diesen Adressbereich dem
	  Namen des Ankers hinzu.  Die Standardtabelle wird verwendet,
	  wenn eine Wildcard angegeben wird.</para>
	
	<para>Für eine Adresse kann im Feld <literal>nfail</literal>
	  die Anzahl von Fehlversuchen definiert werden.  Dies ist
	  nützlich für Ausnahmen, um weniger strenge Anwendungen zu
	  ermöglichen, oder um Anmeldeversuche ein wenig nachsichtiger
	  zu gestalten.  Die Sperrung wird aufgehoben, wenn im
	  sechsten Feld eine Wildcard benutzt wird.</para>

	<para>Remote-Regeln ermöglichen eine strengere Durchsetzung
	  der Beschränkungen bei Anmeldeversuchen im Vergleich zu
	  Anmeldeversuchen die aus dem lokalen Netzwerk kommen.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Blacklistd Client Konfiguration</title>

      <para>Es gibt einige Softwarepakete in &os;, die die
	Funktionalität von blacklistd nutzen können.  Die beiden
	bekanntesten sind &man.ftpd.8; und &man.sshd.8;.  Beide
	Programme nutzen blacklistd, um übermäßige Verbindungsversuche
	zu unterbinden.  Um blacklistd im SSH-Daemon zu aktivieren,
	muss folgend Zeile in
	<filename>/etc/ssh/sshd_config</filename> hinzugefügt
	werden:</para>

      <programlisting>UseBlacklist yes</programlisting>

      <para>Damit die Änderungen wirksam werden, muss sshd im
	Anschluss neu gestartet werden.</para>

      <para>Für &man.ftpd.8; wird blacklistd mit dem Schalter
	<literal>-B</literal> aktiviert.  Entweder in
	<filename>/etc/inetd.conf</filename> oder in
	<filename>/etc/rc.conf</filename>:</para>

      <programlisting>ftpd_flags="-B"</programlisting>

      <para>Das ist alles, was benötigt wird, damit diese Programme
	mit blacklist kommunizieren.</para>
    </sect2>

    <sect2>
      <title>Blacklistd Verwaltung</title>

      <para>Blacklistd stellt dem Benutzer das Verwaltungswerkzeug
	&man.blacklistctl.8; zur Verfügung.  Es zeigt blockierte
	Adressen und Netzwerke an, die nach den in
	&man.blacklistd.conf.5; definierten Regeln auf der Blacklist
	stehen.  Um die Liste der aktuell blockierten Rechner
	anzuzeigen, benutzen Sie <command>dump</command> zusammen mit
	der Option <option>-b</option>:</para>

      <screen>&prompt.root; <userinput>blacklistctl dump -b</userinput>
      address/ma:port id      nfail   last access
213.0.123.128/25:22   OK      6/3     2019/06/08 14:30:19</screen>

      <para>Dieses Beispiel zeigt, dass es sechs von drei erlaubten
	Anmeldeversuchen auf Port 22 aus dem Adressbereich <systemitem
	  class="netmask">213.0.123.128/25</systemitem> gab.  Es sind
	mehr Versuche aufgelistet, als erlaubt sind, da SSH es einem
	Client erlaubt, mehrere Anmeldungen über eine einzige
	TCP-Verbindung zu tätigen.  Eine derzeit laufende Verbindung
	wird nicht von blacklistd unterbunden.  Der letzte
	Verbindungsversuch ist in der letzten Spalte der Ausgabe
	aufgeführt.</para>

      <para>Um die verbleibende Zeit zu sehen, die sich dieser Rechner
	auf der Blacklist befindet, fügen Sie <option>-r</option> zum
	vorherigen Befehl hinzu:</para>

      <screen>&prompt.root; <userinput>blacklistctl dump -br</userinput>
      address/ma:port id      nfail   remaining time
213.0.123.128/25:22   OK      6/3     36s</screen>

      <para>In diesem Beispiel bleiben noch 36 Sekunden, bis dieser
	Rechner nicht mehr blockiert wird.</para>
    </sect2>

    <sect2>
      <title>Rechner aus der Blocklist entfernen</title>

      <para>Manchmal ist es notwendig, einen Rechner aus der Blocklist
	zu entfernen, bevor die verbleibende Zeit abgelaufen ist.
	Leider bietet blacklistd keine Möglichkeit dies zu tun.  Es
	ist jedoch möglich, die Adresse mit <command>pfctl</command>
	aus der PF-Tabelle zu entfernen.  Für den blockierten Port
	gibt es einen untergeordneten Anker innerhalb des definierten
	blacklistd-Ankers in <filename>/etc/pf.conf</filename>.  Wenn
	es beispielsweise einen untergeordneten Anker zum Blockieren
	von Port 22 gibt, wird dieser als
	<literal>blacklistd/22</literal> bezeichnet.  In diesem
	untergeordneten Anker befindet sich eine Tabelle, die die
	blockierten Adressen enthält.  Diese Tabelle wird Port
	genannt, gefolgt von der Portnummer.  In diesem Beispiel würde
	es <literal>port22</literal> heißen.  Mit diesen Informationen
	und &man.pfctl.8; ist es nun möglich, alle geblockten Adressen
	anzuzeigen:</para>

      <screen>&prompt.root; <userinput>pfctl -a <replaceable>blacklistd/22</replaceable> -t <replaceable>port22</replaceable> -T show</userinput>
...
213.0.123.128/25
...</screen>

      <para>Nachdem Sie die entsprechende Adresse ermittelt wurde,
	kann sie mit folgendem Befehl aus der Liste entfernt
	werden:</para>

      <screen>&prompt.root; <userinput>pfctl -a <replaceable>blacklistd/22</replaceable> -t <replaceable>port22</replaceable> -T delete <replaceable>213.0.123.128/25</replaceable></userinput></screen>

      <para>Die Adresse ist nun aus PF entfernt, erscheint aber immer
	noch in der Liste von <command>blacklistctl</command>, da
	dieser keine Kenntnis von Änderungen an PF hat.  Der Eintrag
	in blacklist's Datenbank wird irgendwann ablaufen und dann aus
	der Ausgabe entfernt werden.  Der Eintrag wird wieder
	hinzugefügt, falls der Rechner erneut gegen eine der Regeln
	von blacklistd verstößt.</para>
    </sect2>
  </sect1>
</chapter>
