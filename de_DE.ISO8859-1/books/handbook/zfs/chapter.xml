<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     basiert auf: r54327
-->

<chapter xmlns="http://docbook.org/ns/docbook"
  xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0"
  xml:id="zfs">

  <info>
    <title>Das Z-Dateisystem (<acronym>ZFS</acronym>)</title>

    <authorgroup>
      <author>
	<personname>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	</personname>
	<contrib>Geschrieben von </contrib>
      </author>
      <author>
	<personname>
	  <firstname>Allan</firstname>
	  <surname>Jude</surname>
	</personname>
	<contrib>Geschrieben von </contrib>
      </author>
      <author>
	<personname>
	  <firstname>Benedict</firstname>
	  <surname>Reuschling</surname>
	</personname>
	<contrib>Geschrieben von </contrib>
      </author>
      <author>
	<personname>
	  <firstname>Warren</firstname>
	  <surname>Block</surname>
	</personname>
	<contrib>Geschrieben von </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	<personname>
	  <firstname>Benedict</firstname>
	  <surname>Reuschling</surname>
	</personname>
	<contrib>Übersetzt von </contrib>
      </author>
    </authorgroup>
  </info>

  <para>Das <emphasis>Z-Dateisystem</emphasis>, oder kurz
    <acronym>ZFS</acronym>, ist ein fortgeschrittenes Dateisystem, das
    entwickelt wurde, um viele der großen Probleme in vorherigen
    Entwicklungen zu überwinden.</para>

  <para>Ursprünglich von &sun; entworfen, wird die weitere Entwicklung
    von <acronym>ZFS</acronym> heutzutage als Open Source vom <link
    xlink:href="http://open-zfs.org">OpenZFS Projekt</link>
    vorangetrieben.</para>

  <para><acronym>ZFS</acronym> hat drei große Entwurfsziele:</para>

  <itemizedlist>
    <listitem>
      <para>Datenintegrität: Alle Daten enthalten eine Prüfsumme
	(<link linkend="zfs-term-checksum">checksum</link>) der Daten.
	Wenn Daten geschrieben werden, wird die Prüfsumme berechnet
	und zusammen mit den Daten gespeichert.  Wenn diese Daten
	später wieder eingelesen werden, wird diese Prüfsumme erneut
	berechnet.  Falls die Prüfsummen nicht übereinstimmen, wurde
	ein Datenfehler festgestellt.  <acronym>ZFS</acronym> wird
	versuchen, diesen Fehler automatisch zu korrigieren, falls
	genug Datenredundanz vorhanden ist.</para>
    </listitem>

    <listitem>
      <para>Gepoolter Speicher: physikalische Speichermedien werden zu
	einem Pool zusammengefasst und der Speicherplatz wird von
	diesem gemeinsam genutzten Pool allokiert.  Der Speicherplatz
	steht allen Dateisystemen zur Verfügung und kann durch das
	Hinzufügen von neuen Speichermedien vergrößert werden.</para>
    </listitem>

    <listitem>
      <para>Geschwindigkeit: mehrere Zwischenspeichermechanismen
	sorgen für erhöhte Geschwindigkeit.  Der <link
	linkend="zfs-term-arc">ARC</link> ist ein weiterentwickelter,
	hauptspeicherbasierter Zwischenspeicher für Leseanfragen.  Auf
	einer zweiten Stufe kann ein plattenbasierter <link
	linkend="zfs-term-l2arc">L2ARC</link>-Lesezwischenspeicher
	hinzugefügt werden.  Zusätzlich ist auch noch ein
	plattenbasierter, synchroner Schreibzwischenspeicher
	verfügbar, der sog. <link
	linkend="zfs-term-zil">ZIL</link>.</para>
    </listitem>
  </itemizedlist>

  <para>Eine vollständige Liste aller Eigenschaften und der
    dazugehörigen Terminologie ist in <xref linkend="zfs-term"/> zu
    sehen.</para>

  <sect1 xml:id="zfs-differences">
    <title>Was <acronym>ZFS</acronym> anders macht</title>

    <para><acronym>ZFS</acronym> ist signifikant unterschiedlich zu
      allen bisherigen Dateisystemen, weil es mehr als nur ein
      Dateisystem ist.  Durch die Kombination von traditionell
      getrennten Rollen von Volumenmanager und Dateisystem ist
      <acronym>ZFS</acronym> mit einzigartigen Vorteilen ausgestattet.
      Das Dateisystem besitzt jetzt Kenntnis von der zugrundeliegenden
      Struktur der Speichermedien.  Traditionelle Dateisysteme konnten
      nur auf einer einzigen Platte gleichzeitig angelegt werden.
      Falls es zwei Festplatten gab, mussten auch zwei getrennte
      Dateisysteme erstellt werden.  In einer traditionellen
      Hardware-<acronym>RAID</acronym>-Konfiguration wurde dieses
      Problem umgangen, indem dem Betriebssystem nur eine einzige
      logische Platte angezeigt wurde, die sich aus dem Speicherplatz
      von der Anzahl an physischen Platten zusammensetzte, auf dem
      dann das Betriebssystem ein Dateisystem erstellte.  Sogar im
      Fall von Software-<acronym>RAID</acronym>-Lösungen, wie die, die
      von <acronym>GEOM</acronym> bereitgestellt werden, war das
      <acronym>UFS</acronym>-Dateisystem der Ansicht, dass es auf nur
      einem einzigen Gerät angelegt wurde.  <acronym>ZFS</acronym>'s
      Kombination eines Volumenmanagers und eines Dateisystems löst
      dies und erlaubt das Erstellen von vielen Dateisystemen, die
      sich alle den darunterliegenden Pool aus verfügbarem Speicher
      teilen.  Einer der größten Vorteile von <acronym>ZFS</acronym>'s
      Kenntnis des physikalischen Layouts der Platten ist, dass
      existierende Dateisysteme automatisch wachsen können, wenn
      zusätzliche Platten zum Pool hinzugefügt werden.  Dieser neue
      Speicherplatz wird dann allen Dateisystemen zur Verfügung
      gestellt.  <acronym>ZFS</acronym> besitzt ebenfalls eine Menge
      an unterschiedlichen Eigenschaften, die für jedes Dateisystem
      angepasst werden können, was viele Vorteile bringt, wenn man
      unterschiedliche Dateisysteme und Datasets anlegt, anstatt ein
      einziges, monolithisches Dateisystem zu erzeugen.</para>
  </sect1>

  <sect1 xml:id="zfs-quickstart">
    <title>Schnellstartanleitung</title>

    <para>Es existiert ein Startmechanismus, der es &os; erlaubt,
      <acronym>ZFS</acronym>-Pools während der Systeminitialisierung
      einzubinden.  Um diesen zu aktivieren, fügen Sie diese Zeile
      in <filename>/etc/rc.conf</filename> ein:</para>

    <programlisting>zfs_enable="YES"</programlisting>

    <para>Starten Sie dann den Dienst:</para>

    <screen>&prompt.root; <userinput>service zfs start</userinput></screen>

    <para>Die Beispiele in diesem Abschnitt gehen von drei
      <acronym>SCSI</acronym>-Platten mit den Gerätenamen
      <filename><replaceable>da0</replaceable></filename>,
      <filename><replaceable>da1</replaceable></filename> und
      <filename><replaceable>da2</replaceable></filename> aus.  Nutzer
      von <acronym>SATA</acronym>-Hardware sollten stattdessen die
      Bezeichnung <filename><replaceable>ada</replaceable></filename>
      als Gerätenamen verwenden.</para>

    <sect2 xml:id="zfs-quickstart-single-disk-pool">
      <title>Pools mit einer Platte</title>

      <para>Um einen einfachen, nicht-redundanten Pool mit einem
	einzigen Gerät anzulegen, geben Sie folgendes ein:</para>

      <screen>&prompt.root; <userinput>zpool create <replaceable>example</replaceable> <replaceable>/dev/da0</replaceable></userinput></screen>

      <para>Um den neuen Pool anzuzeigen, prüfen Sie die Ausgabe von
	<command>df</command>:</para>

      <screen>&prompt.root; <userinput>df</userinput>
Filesystem  1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a   2026030  235230  1628718    13%    /
devfs               1       1        0   100%    /dev
/dev/ad0s1d  54098308 1032846 48737598     2%    /usr
example      17547136       0 17547136     0%    /example</screen>

      <para>Diese Ausgabe zeigt, dass der
	<literal>example</literal>-Pool erstellt und eingehängt wurde.
	Er ist nun als Dateisystem verfügbar.  Dateien können darauf
	angelegt werden und Anwender können sich den Inhalt
	ansehen:</para>

      <screen>&prompt.root; <userinput>cd /example</userinput>
&prompt.root; <userinput>ls</userinput>
&prompt.root; <userinput>touch testfile</userinput>
&prompt.root; <userinput>ls -al</userinput>
total 4
drwxr-xr-x   2 root  wheel    3 Aug 29 23:15 .
drwxr-xr-x  21 root  wheel  512 Aug 29 23:12 ..
-rw-r--r--   1 root  wheel    0 Aug 29 23:15 testfile</screen>

      <para>Allerdings nutzt dieser Pool noch keine der Vorteile von
	<acronym>ZFS</acronym>.  Um ein Dataset auf diesem Pool mit
	aktivierter Komprimierung zu erzeugen, geben Sie ein:</para>

      <screen>&prompt.root; <userinput>zfs create example/compressed</userinput>
&prompt.root; <userinput>zfs set compression=gzip example/compressed</userinput></screen>

      <para>Das <literal>example/compressed</literal>-Dataset ist nun
	ein komprimiertes <acronym>ZFS</acronym>-Dateisystem.
	Versuchen Sie, ein paar große Dateien auf
	<filename>/example/compressed</filename> zu kopieren.</para>

      <para>Deaktivieren lässt sich die Komprimierung durch:</para>

      <screen>&prompt.root; <userinput>zfs set compression=off example/compressed</userinput></screen>

      <para>Um ein Dateisystem abzuhängen, verwenden Sie
	<command>zfs umount</command> und überprüfen Sie dies
	anschließend mit <command>df</command>:</para>

      <screen>&prompt.root; <userinput>zfs umount example/compressed</userinput>
&prompt.root; <userinput>df</userinput>
Filesystem  1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a   2026030  235232  1628716    13%    /
devfs               1       1        0   100%    /dev
/dev/ad0s1d  54098308 1032864 48737580     2%    /usr
example      17547008       0 17547008     0%    /example</screen>

      <para>Um das Dateisystem wieder einzubinden und erneut verfügbar
	zu machen, verwenden Sie <command>zfs mount</command> und
	prüfen Sie erneut mit <command>df</command>:</para>

      <screen>&prompt.root; <userinput>zfs mount example/compressed</userinput>
&prompt.root; <userinput>df</userinput>
Filesystem         1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a          2026030  235234  1628714    13%    /
devfs                      1       1        0   100%    /dev
/dev/ad0s1d         54098308 1032864 48737580     2%    /usr
example             17547008       0 17547008     0%    /example
example/compressed  17547008       0 17547008     0%    /example/compressed</screen>

      <para>Den Pool und die Dateisysteme können Sie auch über die
	Ausgabe von <command>mount</command> prüfen:</para>

      <screen>&prompt.root; <userinput>mount</userinput>
/dev/ad0s1a on / (ufs, local)
devfs on /dev (devfs, local)
/dev/ad0s1d on /usr (ufs, local, soft-updates)
example on /example (zfs, local)
example/compressed on /example/compressed (zfs, local)</screen>

      <para>Nach der Erstellung können <acronym>ZFS</acronym>-Datasets
	wie jedes andere Dateisystem verwendet werden.  Jedoch sind
	jede Menge andere Besonderheiten verfügbar, die individuell
	auf Dataset-Basis eingestellt sein können.  Im Beispiel unten
	wird ein neues Dateisystem namens <literal>data</literal>
	angelegt.  Wichtige Dateien werden dort abgespeichert, deshalb
	wird es so konfiguriert, dass zwei Kopien jedes Datenblocks
	vorgehalten werden.</para>

      <screen>&prompt.root; <userinput>zfs create example/data</userinput>
&prompt.root; <userinput>zfs set copies=2 example/data</userinput></screen>

      <para>Es ist jetzt möglich, den Speicherplatzverbrauch der Daten
	durch die Eingabe von <command>df</command> zu sehen:</para>

      <screen>&prompt.root; <userinput>df</userinput>
Filesystem         1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a          2026030  235234  1628714    13%    /
devfs                      1       1        0   100%    /dev
/dev/ad0s1d         54098308 1032864 48737580     2%    /usr
example             17547008       0 17547008     0%    /example
example/compressed  17547008       0 17547008     0%    /example/compressed
example/data        17547008       0 17547008     0%    /example/data</screen>

      <para>Sie haben vermutlich bemerkt, dass jedes Dateisystem auf
	dem Pool die gleiche Menge an verfügbarem Speicherplatz
	besitzt.  Das ist der Grund dafür, dass in diesen Beispielen
	<command>df</command> verwendet wird, um zu zeigen, dass die
	Dateisysteme nur die Menge an Speicher verbrauchen, den sie
	benötigen und alle den gleichen Pool verwenden.
	<acronym>ZFS</acronym> eliminiert Konzepte wie Volumen und
	Partitionen und erlaubt es mehreren Dateisystemen den gleichen
	Pool zu belegen.</para>

      <para>Um das Dateisystem und anschließend den Pool zu
	zerstören, wenn dieser nicht mehr benötigt wird, geben Sie
	ein:</para>

      <screen>&prompt.root; <userinput>zfs destroy example/compressed</userinput>
&prompt.root; <userinput>zfs destroy example/data</userinput>
&prompt.root; <userinput>zpool destroy example</userinput></screen>
    </sect2>

    <sect2 xml:id="zfs-quickstart-raid-z">
      <title>RAID-Z</title>

      <para>Platten fallen aus.  Eine Methode, um Datenverlust durch
	Festplattenausfall zu vermeiden, ist die Verwendung von
	<acronym>RAID</acronym>.  <acronym>ZFS</acronym> unterstützt
	dies in seiner Poolgestaltung.  Pools mit
	<acronym>RAID-Z</acronym> benötigen drei oder mehr Platten,
	bieten aber auch mehr nutzbaren Speicher als gespiegelte
	Pools.</para>

      <para>Dieses Beispiel erstellt einen
	<acronym>RAID-Z</acronym>-Pool, indem es die Platten angibt,
	die dem Pool hinzugefügt werden sollen:</para>

      <screen>&prompt.root; <userinput>zpool create storage raidz da0 da1 da2</userinput></screen>

      <note>
	<para>&sun; empfiehlt, dass die Anzahl der Geräte in einer
	  <acronym>RAID</acronym>-Z Konfiguration zwischen drei und
	  neun beträgt.  Für Umgebungen, die einen einzelnen Pool
	  benötigen, der aus 10 oder mehr Platten besteht, sollten Sie
	  in Erwägung ziehen, diesen in kleinere
	  <acronym>RAID-Z</acronym>-Gruppen aufzuteilen.  Falls nur
	  zwei Platten verfügbar sind und Redundanz benötigt wird,
	  ziehen Sie die Verwendung eines
	  <acronym>ZFS</acronym>-Spiegels (mirror) in Betracht.  Lesen
	  Sie dazu &man.zpool.8;, um weitere Details zu
	  erhalten.</para>
      </note>

      <para>Das vorherige Beispiel erstellte einen ZPool namens
	<literal>storage</literal>.  Dieses Beispiel erzeugt ein neues
	Dateisystem, genannt <literal>home</literal>, in diesem
	Pool:</para>

      <screen>&prompt.root; <userinput>zfs create storage/home</userinput></screen>

      <para>Komprimierung und das Vorhalten von mehreren Kopien von
	Dateien und Verzeichnissen kann aktiviert werden:</para>

      <screen>&prompt.root; <userinput>zfs set copies=2 storage/home</userinput>
&prompt.root; <userinput>zfs set compression=gzip storage/home</userinput></screen>

      <para>Um dies als das neue Heimatverzeichnis für Anwender zu
	setzen, kopieren Sie die Benutzerdaten in dieses Verzeichnis
	und erstellen passende symbolische Verknüpfungen:</para>

      <screen>&prompt.root; <userinput>cp -rp /home/* /storage/home</userinput>
&prompt.root; <userinput>rm -rf /home /usr/home</userinput>
&prompt.root; <userinput>ln -s /storage/home /home</userinput>
&prompt.root; <userinput>ln -s /storage/home /usr/home</userinput></screen>

      <para>Daten von Anwendern werden nun auf dem frisch erstellten
	<filename>/storage/home</filename> abgelegt.  Überprüfen Sie
	dies durch das Anlegen eines neuen Benutzers und das
	anschließende Anmelden als dieser Benutzer.</para>

      <para>Versuchen Sie, einen Dateisystemschnappschuss anzulegen,
	den Sie später wieder zurückrollen können:</para>

      <screen>&prompt.root; <userinput>zfs snapshot storage/home@08-30-08</userinput></screen>

      <para>Schnappschüsse können nur auf einem Dateisystem angelegt
	werden, nicht auf einem einzelnen Verzeichnis oder einer
	Datei.</para>

      <para>Das Zeichen <literal>@</literal> ist der Trenner zwischen
	dem Dateisystem- oder dem Volumennamen.  Wenn ein wichtiges
	Verzeichnis aus Versehen gelöscht wurde, kann das Dateisystem
	gesichert und dann zu einem früheren Schnappschuss
	zurückgerollt werden, in welchem das Verzeichnis noch
	existiert:</para>

      <screen>&prompt.root; <userinput>zfs rollback storage/home@08-30-08</userinput></screen>

      <para>Um all verfügbaren Schnappschüsse aufzulisten, geben Sie
	<command>ls</command> im Verzeichnis
	<filename>.zfs/snapshot</filename> dieses Dateisystems ein.
	Beispielsweise lässt sich der zuvor angelegte Schnappschuss
	wie folgt anzeigen:</para>

      <screen>&prompt.root; <userinput>ls /storage/home/.zfs/snapshot</userinput></screen>

      <para>Es ist möglich, ein Skript zu schreiben, um regelmäßig
	Schnappschüsse von Benutzerdaten anzufertigen.  Allerdings
	verbrauchen Schnappschüsse über lange Zeit eine große Menge
	an Speicherplatz.  Der zuvor angelegte Schnappschuss kann
	durch folgendes Kommando wieder entfernt werden:</para>

      <screen>&prompt.root; <userinput>zfs destroy storage/home@08-30-08</userinput></screen>

      <para>Nach erfolgreichen Tests kann
	<filename>/storage/home</filename> zum echten
	<filename>/home</filename>-Verzeichnis werden, mittels:</para>

      <screen>&prompt.root; <userinput>zfs set mountpoint=/home storage/home</userinput></screen>

      <para>Prüfen Sie mit <command>df</command> und
	<command>mount</command>, um zu bestätigen, dass das System
	das Dateisystem nun als <filename>/home</filename>
	verwendet:</para>

      <screen>&prompt.root; <userinput>mount</userinput>
/dev/ad0s1a on / (ufs, local)
devfs on /dev (devfs, local)
/dev/ad0s1d on /usr (ufs, local, soft-updates)
storage on /storage (zfs, local)
storage/home on /home (zfs, local)
&prompt.root; <userinput>df</userinput>
Filesystem   1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a    2026030  235240  1628708    13%    /
devfs                1       1        0   100%    /dev
/dev/ad0s1d   54098308 1032826 48737618     2%    /usr
storage       26320512       0 26320512     0%    /storage
storage/home  26320512       0 26320512     0%    /home</screen>

      <para>Damit ist die <acronym>RAID-Z</acronym> Konfiguration
	abgeschlossen.  Tägliche Informationen über den Status der
	erstellten Dateisysteme können als Teil des nächtlichen
	&man.periodic.8;-Berichts generiert werden.  Fügen Sie dazu
	die folgende Zeile in <filename>/etc/periodic.conf</filename>
	ein:</para>

      <programlisting>daily_status_zfs_enable="YES"</programlisting>
    </sect2>

    <sect2 xml:id="zfs-quickstart-recovering-raid-z">
      <title><acronym>RAID-Z</acronym> wiederherstellen</title>

      <para>Jedes Software-<acronym>RAID</acronym> besitzt eine
	Methode, um den Zustand (<literal>state</literal>) zu
	überprüfen.  Der Status von <acronym>RAID-Z</acronym> Geräten
	wird mit diesem Befehl angezeigt:</para>

      <screen>&prompt.root; <userinput>zpool status -x</userinput></screen>

      <para>Wenn alle Pools
	<link linkend="zfs-term-online">Online</link> sind und alles
	normal ist, zeigt die Meldung folgendes an:</para>

      <screen>all pools are healthy</screen>

      <para>Wenn es ein Problem gibt, womöglich ist eine Platte
	im Zustand <link linkend="zfs-term-offline">Offline</link>,
	dann wird der Poolzustand ähnlich wie dieser aussehen:</para>

      <screen>  pool: storage
 state: DEGRADED
status: One or more devices has been taken offline by the administrator.
	Sufficient replicas exist for the pool to continue functioning in a
	degraded state.
action: Online the device using 'zpool online' or replace the device with
	'zpool replace'.
 scrub: none requested
config:

	NAME        STATE     READ WRITE CKSUM
	storage     DEGRADED     0     0     0
	  raidz1    DEGRADED     0     0     0
	    da0     ONLINE       0     0     0
	    da1     OFFLINE      0     0     0
	    da2     ONLINE       0     0     0

errors: No known data errors</screen>

      <para>Dies zeigt an, dass das Gerät zuvor vom Administrator mit
	diesem Befehl abgeschaltet wurde:</para>

      <screen>&prompt.root; <userinput>zpool offline storage da1</userinput></screen>

      <para>Jetzt kann das System heruntergefahren werden, um
	<filename>da1</filename> zu ersetzen.  Wenn das System wieder
	eingeschaltet wird, kann die fehlerhafte Platte im Pool
	ersetzt werden:</para>

      <screen>&prompt.root; <userinput>zpool replace storage da1</userinput></screen>

      <para>Von diesem Punkt an kann der Status erneut geprüft werden.
	Dieses Mal ohne die Option <option>-x</option>, damit alle
	Pools angezeigt werden:</para>

      <screen>&prompt.root; <userinput>zpool status storage</userinput>
 pool: storage
 state: ONLINE
 scrub: resilver completed with 0 errors on Sat Aug 30 19:44:11 2008
config:

	NAME        STATE     READ WRITE CKSUM
	storage     ONLINE       0     0     0
	  raidz1    ONLINE       0     0     0
	    da0     ONLINE       0     0     0
	    da1     ONLINE       0     0     0
	    da2     ONLINE       0     0     0

errors: No known data errors</screen>

      <para>In diesem Beispiel ist alles normal.</para>
    </sect2>

    <sect2 xml:id="zfs-quickstart-data-verification">
      <title>Daten verifizieren</title>

      <para><acronym>ZFS</acronym> verwendet Prüfsummen, um die
	Integrität der gespeicherten Daten zu gewährleisten.  Dies
	wird automatisch beim Erstellen von Dateisystemen
	aktiviert.</para>

      <warning>
	<para>Prüfsummen können deaktiviert werden, dies wird jedoch
	  <emphasis>nicht</emphasis> empfohlen!  Prüfsummen
	  verbrauchen nur sehr wenig Speicherplatz und sichern die
	  Integrität der Daten.  Viele Eigenschaften vom
	  <acronym>ZFS</acronym>  werden nicht richtig funktionieren,
	  wenn Prüfsummen deaktiviert sind.  Es gibt keinen merklichen
	  Geschwindigkeitsunterschied durch das Deaktivieren dieser
	  Prüfsummen.</para>
      </warning>

      <para>Prüfsummenverifikation ist unter der Bezeichnung
	<emphasis>scrubbing</emphasis> bekannt.  Verifizieren Sie die
	Integrität der Daten des <literal>storage</literal>-Pools mit
	diesem Befehl:</para>

      <screen>&prompt.root; <userinput>zpool scrub storage</userinput></screen>

      <para>Die Laufzeit einer Überprüfung hängt ab von der Menge an
	Daten, die gespeichert sind.  Größere Mengen an Daten
	benötigen proportional mehr Zeit zum überprüfen.  Diese
	Überprüfungen sind sehr <acronym>I/O</acronym>-intensiv und
	es kann auch nur eine Überprüfung zur gleichen Zeit
	durchgeführt werden.  Nachdem eine Prüfung beendet ist, kann
	der Status mit dem Unterkommando <command>status</command>
	angezeigt werden:</para>

      <screen>&prompt.root; <userinput>zpool status storage</userinput>
 pool: storage
 state: ONLINE
 scrub: scrub completed with 0 errors on Sat Jan 26 19:57:37 2013
config:

	NAME        STATE     READ WRITE CKSUM
	storage     ONLINE       0     0     0
	  raidz1    ONLINE       0     0     0
	    da0     ONLINE       0     0     0
	    da1     ONLINE       0     0     0
	    da2     ONLINE       0     0     0

errors: No known data errors</screen>

      <para>Das Datum der letzten Prüfoperation wird angezeigt, um zu
	verfolgen, wann die nächste Prüfung benötigt wird.
	Routinemässige Überprüfungen helfen dabei, Daten vor stiller
	Korrumpierung zu schützen und die Integrität des Pools sicher
	zu stellen.</para>

      <para>Lesen Sie &man.zfs.8; und &man.zpool.8;, um über
	weitere <acronym>ZFS</acronym>-Optionen zu erfahren.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="zfs-zpool">
    <title><command>zpool</command> Administration</title>

    <para>Administration von <acronym>ZFS</acronym> ist unterteilt
      zwischen zwei Hauptkommandos.  Das
      <command>zpool</command>-Werkzeug steuert die Operationen des
      Pools und kümmert sich um das Hinzufügen, entfernen, ersetzen
      und verwalten von Platten.  Mit dem <link
      linkend="zfs-zfs"><command>zfs</command></link>-Befehl können
      Datasets erstellt, zerstört und verwaltet werden, sowohl
      <link linkend="zfs-term-filesystem">Dateisysteme</link> als
      auch <link linkend="zfs-term-volume">Volumes</link>.</para>

    <sect2 xml:id="zfs-zpool-create">
      <title>Pools anlegen und zerstören</title>

      <para>Einen <acronym>ZFS</acronym>-Pool
	(<emphasis>zpool</emphasis>) anzulegen beinhaltet das Treffen
	von einer Reihe von Entscheidungen, die relativ dauerhaft
	sind, weil die Struktur des Pools nachdem er angelegt wurde,
	nicht mehr geändert werden kann.  Die wichtigste Entscheidung
	ist, welche Arten von vdevs als physische Platten
	zusammengefasst werden soll.  Sehen Sie sich dazu die Liste
	von <link linkend="zfs-term-vdev">vdev-Arten</link> an, um
	Details zu möglichen Optionen zu bekommen.  Nachdem der Pool
	angelegt wurde, erlauben die meisten vdev-Arten es nicht mehr,
	weitere Geräte zu diesem vdev hinzuzufügen.  Die Ausnahme sind
	Spiegel, die das Hinzufügen von weiteren Platten zum vdev
	gestatten, sowie stripes, die zu Spiegeln umgewandelt werden
	können, indem man zusätzliche Platten zum vdev anhängt.
	Obwohl weitere vdevs eingefügt werden können, um einen Pool zu
	vergrößern, kann das Layout des Pools nach dem Anlegen nicht
	mehr verändert werden.  Stattdessen müssen die Daten
	gesichert, der Pool zerstört und danach neu erstellt
	werden.</para>

      <para>Erstellen eines einfachen gespiegelten Pools:</para>

      <screen>&prompt.root; <userinput>zpool create <replaceable>mypool</replaceable> mirror <replaceable>/dev/ada1</replaceable> <replaceable>/dev/ada2</replaceable></userinput>
&prompt.root; <userinput>zpool status</userinput>
  pool: mypool
 state: ONLINE
  scan: none requested
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada1    ONLINE       0     0     0
            ada2    ONLINE       0     0     0

errors: No known data errors</screen>

      <para>Mehrere vdevs können gleichzeitig angelegt werden.  Geben
	Sie zusätzliche Gruppen von Platten, getrennt durch das
	vdev-Typ Schlüsselwort, in diesem Beispiel
	<literal>mirror</literal>, an:</para>

      <screen>&prompt.root; <userinput>zpool create <replaceable>mypool</replaceable> mirror <replaceable>/dev/ada1</replaceable> <replaceable>/dev/ada2</replaceable> mirror <replaceable>/dev/ada3</replaceable> <replaceable>/dev/ada4</replaceable></userinput>
  pool: mypool
 state: ONLINE
  scan: none requested
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada1    ONLINE       0     0     0
            ada2    ONLINE       0     0     0
          mirror-1  ONLINE       0     0     0
            ada3    ONLINE       0     0     0
            ada4    ONLINE       0     0     0

errors: No known data errors</screen>

      <para>Pools lassen sich auch durch die Angabe von Partitionen
	anstatt von ganzen Platten erzeugen.  Durch die Verwendung von
	<acronym>ZFS</acronym> in einer separaten Partition ist es
	möglich, dass die gleiche Platte andere Partitionen für andere
	Zwecke besitzen kann.  Dies ist besonders von Interesse, wenn
	Partitionen mit Bootcode und Dateisysteme, die zum starten
	benötigt werden, hinzugefügt werden können.  Das erlaubt es,
	von Platten zu booten, die auch Teil eines Pools sind.  Es
	gibt keinen Geschwindigkeitsnachteil unter &os; wenn eine
	Partition anstatt einer ganzen Platte verwendet wird.  Durch
	den Einsatz von Partitionen kann der Administrator die Platten
	<emphasis>unter provisionieren</emphasis>, indem weniger als
	die volle Kapazität Verwendung findet.  Wenn in Zukunft eine
	Ersatzfestplatte mit der gleichen Größe als die
	Originalplatte eine kleinere Kapazität aufweist, passt die
	kleinere Partition immer noch und die Ersatzplatte kann immer
	noch verwendet werden.</para>

      <para>Erstellen eines <link
	linkend="zfs-term-vdev-raidz">RAID-Z2</link>-Pools mit
	Partitionen:</para>

      <screen>&prompt.root; <userinput>zpool create <replaceable>mypool</replaceable> raidz2 <replaceable>/dev/ada0p3</replaceable> <replaceable>/dev/ada1p3</replaceable> <replaceable>/dev/ada2p3</replaceable> <replaceable>/dev/ada3p3</replaceable> <replaceable>/dev/ada4p3</replaceable> <replaceable>/dev/ada5p3</replaceable></userinput>
&prompt.root; <userinput>zpool status</userinput>
  pool: mypool
 state: ONLINE
  scan: none requested
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          raidz2-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0
            ada2p3  ONLINE       0     0     0
            ada3p3  ONLINE       0     0     0
            ada4p3  ONLINE       0     0     0
            ada5p3  ONLINE       0     0     0

errors: No known data errors</screen>

      <para>Ein Pool, der nicht länger benötigt wird, kann zerstört
	werden, so dass die Platten für einen anderen Einsatzzweck
	Verwendung finden können.  Um einen Pool zu zerstören, müssen
	zuerst alle Datasets in diesem Pool abgehängt werden.  Wenn
	die Datasets verwendet werden, wird das Abhängen fehlschlagen
	und der Pool nicht zerstört.  Die Zerstörung des Pools kann
	erzwungen werden durch die Angabe der Option
	<option>-f</option>, jedoch kann dies undefiniertes Verhalten
	in den Anwendungen auslösen, die noch offene Dateien auf
	diesen Datasets hatten.</para>
    </sect2>

    <sect2 xml:id="zfs-zpool-attach">
      <title>Hinzufügen und Löschen von Geräten</title>

      <para>Es gibt zwei Fälle für das Hinzufügen von Platten zu einem
	Pool: einhängen einer Platte zu einem existierenden vdev mit
	<command>zpool attach</command> oder einbinden von vdevs zum
	Pool mit <command>zpool add</command>.  Nur manche <link
	linkend="zfs-term-vdev">vdev-Arten</link> gestatten es,
	Platten zum vdev hinzuzufügen, nachdem diese angelegt
	wurden.</para>

      <para>Ein Pool mit nur einer einzigen Platte besitzt keine
	Redundanz.  Datenverfälschung kann erkannt, aber nicht
	repariert werden, weil es keine weiteren Kopien der Daten
	gibt.  Die Eigenschaft <link
	linkend="zfs-term-copies">copies</link> kann genutzt werden,
	um einen geringen Fehler wie einen beschädigtem Sektor
	auszumerzen, enthält aber nicht die gleiche Art von Schutz,
	die Spiegelung oder <acronym>RAID-Z</acronym> bieten.  Wenn
	man mit einem Pool startet, der nur aus einer einzigen
	vdev-Platte besteht, kann mit dem Kommando
	<command>zpool attach</command> eine zustätzliche Platte dem
	vdev hinzugefügt werden, um einen Spiegel zu erzeugen.  Mit
	<command>zpool attach</command> können auch zusätzliche
	Platten zu einer Spiegelgruppe eingefügt werden, was die
	Redundanz und Lesegeschwindigkeit steigert.  Wenn die Platten,
	aus denen der Pool besteht, partitioniert sind,
	replizieren Sie das Layout der ersten Platte auf die Zweite.
	Verwenden Sie dazu <command>gpart backup</command> und
	<command>gpart restore</command>, um diesen Vorgang
	einfacher zu gestalten.</para>

      <para>Umwandeln eines (stripe) vdevs namens
	<replaceable>ada0p3</replaceable> mit einer einzelnen Platte
	zu einem Spiegel durch das Einhängen von
	<replaceable>ada1p3</replaceable>:</para>

      <screen>&prompt.root; <userinput>zpool status</userinput>
  pool: mypool
 state: ONLINE
  scan: none requested
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          ada0p3    ONLINE       0     0     0

errors: No known data errors
&prompt.root; <userinput>zpool attach <replaceable>mypool</replaceable> <replaceable>ada0p3</replaceable> <replaceable>ada1p3</replaceable></userinput>
Make sure to wait until resilver is done before rebooting.

If you boot from pool 'mypool', you may need to update
boot code on newly attached disk 'ada1p3'.

Assuming you use GPT partitioning und 'da0' is your new boot disk
you may use the following command:

        gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 da0
&prompt.root; <userinput>gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 <replaceable>ada1</replaceable></userinput>
bootcode written to ada1
&prompt.root; <userinput>zpool status</userinput>
  pool: mypool
 state: ONLINE
status: One or more devices is currently being resilvered.  The pool will
        continue to function, possibly in a degraded state.
action: Wait for the resilver to complete.
  scan: resilver in progress since Fri May 30 08:19:19 2014
        527M scanned out of 781M at 47.9M/s, 0h0m to go
        527M resilvered, 67.53% done
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0  (resilvering)

errors: No known data errors
&prompt.root; <userinput>zpool status</userinput>
  pool: mypool
 state: ONLINE
  scan: resilvered 781M in 0h0m with 0 errors on Fri May 30 08:15:58 2014
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0

errors: No known data errors</screen>

      <para>Wenn das Hinzufügen von Platten zu einem vdev keine Option
	wie für <acronym>RAID-Z</acronym> ist, gibt es eine
	Alternative, nämlich einen anderen vdev zum Pool hinzuzufügen.
	Zusätzliche vdevs bieten höhere Geschwindigkeit, indem
	Schreibvorgänge über die vdevs verteilt werden.  Jedes vdev
	ist dafür verantwortlich, seine eigene Redundanz
	sicherzustellen.  Es ist möglich, aber nicht empfehlenswert,
	vdev-Arten zu mischen, wie zum Beispiel
	<literal>mirror</literal> und <literal>RAID-Z</literal>.
	Durch das Einfügen eines nicht-redundanten vdev zu einem
	gespiegelten Pool oder einem <acronym>RAID-Z</acronym> vdev
	riskiert man die Daten des gesamten Pools.  Schreibvorgänge
	werden verteilt, deshalb ist der Ausfall einer
	nicht-redundanten Platte mit dem Verlust eines Teils von jedem
	Block verbunden, der auf den Pool geschrieben wird.</para>

      <para>Daten werden über jedes vdev gestriped.  Beispielsweise
	sind zwei Spiegel-vdevs effektiv ein <acronym>RAID</acronym>
	10, dass über zwei Sets von Spiegeln die Daten schreibt.
	Speicherplatz wird so allokiert, dass jedes vdev zur gleichen
	Zeit vollgeschrieben wird.  Es gibt einen
	Geschwindigkeitsnachteil wenn die vdevs unterschiedliche Menge
	von freiem Speicher aufweisen, wenn eine
	unproportionale Menge an Daten auf das weniger volle vdev
	geschrieben wird.</para>

      <para>Wenn zusätzliche Geräte zu einem Pool, von dem gebootet
	wird, hinzugefügt werden, muss der Bootcode aktualisiert
	werden.</para>

      <para>Einbinden einer zweiten Spiegelgruppe
	(<filename>ada2p3</filename> und <filename>ada3p3</filename>)
	zu einem bestehenden Spiegel:</para>

      <screen>&prompt.root; <userinput>zpool status</userinput>
  pool: mypool
 state: ONLINE
  scan: resilvered 781M in 0h0m with 0 errors on Fri May 30 08:19:35 2014
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0

errors: No known data errors
&prompt.root; <userinput>zpool add <replaceable>mypool</replaceable> mirror <replaceable>ada2p3</replaceable> <replaceable>ada3p3</replaceable></userinput>
&prompt.root; <userinput>gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 <replaceable>ada2</replaceable></userinput>
bootcode written to ada2
&prompt.root; <userinput>gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 <replaceable>ada3</replaceable></userinput>
bootcode written to ada3
&prompt.root; <userinput>zpool status</userinput>
  pool: mypool
 state: ONLINE
  scan: scrub repaired 0 in 0h0m with 0 errors on Fri May 30 08:29:51 2014
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0
          mirror-1  ONLINE       0     0     0
            ada2p3  ONLINE       0     0     0
            ada3p3  ONLINE       0     0     0

errors: No known data errors</screen>

      <para>Momentan können vdevs nicht von einem Pool entfernt und
	Platten nur von einem Spiegel ausgehängt werden, wenn genug
	Redundanz übrig bleibt.  Wenn auch nur eine Platte in einer
	Spiegelgruppe bestehen bleibt, hört der Spiegel auf zu
	existieren und wird zu einem stripe, was den gesamten Pool
	riskiert, falls diese letzte Platte ausfällt.</para>

      <para>Entfernen einer Platte aus einem Spiegel mit drei
	Platten:</para>

      <screen>&prompt.root; <userinput>zpool status</userinput>
  pool: mypool
 state: ONLINE
  scan: scrub repaired 0 in 0h0m with 0 errors on Fri May 30 08:29:51 2014
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0
            ada2p3  ONLINE       0     0     0

errors: No known data errors
&prompt.root; <userinput>zpool detach <replaceable>mypool</replaceable> <replaceable>ada2p3</replaceable></userinput>
&prompt.root; <userinput>zpool status</userinput>
  pool: mypool
 state: ONLINE
  scan: scrub repaired 0 in 0h0m with 0 errors on Fri May 30 08:29:51 2014
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0

errors: No known data errors</screen>
    </sect2>

    <sect2 xml:id="zfs-zpool-status">
      <title>Den Status eines Pools überprüfen</title>

      <para>Der Status eines Pools ist wichtig.  Wenn ein Gerät sich
	abschaltet oder ein Lese-, Schreib- oder Prüfsummenfehler
	festgestellt wird, wird der dazugehörige Fehlerzähler erhöht.
	Die <command>status</command>-Ausgabe zeigt die Konfiguration
	und den Status von jedem Gerät im Pool und den Gesamtstatus
	des Pools.  Aktionen, die durchgeführt werden sollten und
	Details zum letzten <link
	  linkend="zfs-zpool-scrub"><command>scrub</command></link>
	werden ebenfalls angezeigt.</para>

      <screen>&prompt.root; <userinput>zpool status</userinput>
  pool: mypool
 state: ONLINE
  scan: scrub repaired 0 in 2h25m with 0 errors on Sat Sep 14 04:25:50 2013
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          raidz2-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0
            ada2p3  ONLINE       0     0     0
            ada3p3  ONLINE       0     0     0
            ada4p3  ONLINE       0     0     0
            ada5p3  ONLINE       0     0     0

errors: No known data errors</screen>
    </sect2>

    <sect2 xml:id="zfs-zpool-clear">
      <title>Fehler beseitigen</title>

      <para>Wenn ein Fehler erkannt wurde, werden die Lese-, Schreib-
	oder Prüfsummenzähler erhöht.  Die Fehlermeldung kann
	beseitigt und der Zähler mit
	<command>zpool clear
	  <replaceable>mypool</replaceable></command> zurückgesetzt
	werden.  Den Fehlerzustand zurückzusetzen kann wichtig sein,
	wenn automatisierte Skripte ablaufen, die den Administrator
	informieren, sobald der Pool Fehler anzeigt.  Weitere Fehler
	werden nicht gemeldet, wenn der alte Fehlerbericht nicht
	entfernt wurde.</para>
    </sect2>

    <sect2 xml:id="zfs-zpool-replace">
      <title>Ein funktionierendes Gerät ersetzen</title>

      <para>Es gibt eine Reihe von Situationen, in denen es nötig
	ist, eine Platte mit einer anderen auszutauschen.
	Wenn eine funktionierende Platte ersetzt wird, hält der
	Prozess die alte Platte während des Ersetzungsvorganges noch
	aktiv.  Der Pool wird nie den Zustand <link
	  linkend="zfs-term-degraded">degraded</link> erhalten, was
	das Risiko eines Datenverlustes minimiert.  Alle Daten der
	alten Platte werden durch das Kommando
	<command>zpool replace</command> auf die Neue übertragen.
	Nachdem die Operation abgeschlossen ist, wird die alte Platte
	vom vdev getrennt.  Falls die neue Platte grösser ist als die
	alte Platte , ist es möglich den Pool zu vergrößern, um den
	neuen Platz zu nutzen.  Lesen Sie dazu <link
	  linkend="zfs-zpool-online">Einen Pool vergrößern</link>.</para>

      <para>Ersetzen eines funktionierenden Geräts in einem
	Pool:</para>

      <screen>&prompt.root; <userinput>zpool status</userinput>
  pool: mypool
 state: ONLINE
  scan: none requested
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0

errors: No known data errors
&prompt.root; <userinput>zpool replace <replaceable>mypool</replaceable> <replaceable>ada1p3</replaceable> <replaceable>ada2p3</replaceable></userinput>
Make sure to wait until resilver is done before rebooting.

If you boot from pool 'zroot', you may need to update
boot code on newly attached disk 'ada2p3'.

Assuming you use GPT partitioning und 'da0' is your new boot disk
you may use the following command:

        gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 da0
&prompt.root; <userinput>gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 <replaceable>ada2</replaceable></userinput>
&prompt.root; <userinput>zpool status</userinput>
  pool: mypool
 state: ONLINE
status: One or more devices is currently being resilvered.  The pool will
        continue to function, possibly in a degraded state.
action: Wait for the resilver to complete.
  scan: resilver in progress since Mon Jun  2 14:21:35 2014
        604M scanned out of 781M at 46.5M/s, 0h0m to go
        604M resilvered, 77.39% done
config:

        NAME             STATE     READ WRITE CKSUM
        mypool           ONLINE       0     0     0
          mirror-0       ONLINE       0     0     0
            ada0p3       ONLINE       0     0     0
            replacing-1  ONLINE       0     0     0
              ada1p3     ONLINE       0     0     0
              ada2p3     ONLINE       0     0     0  (resilvering)

errors: No known data errors
&prompt.root; <userinput>zpool status</userinput>
  pool: mypool
 state: ONLINE
  scan: resilvered 781M in 0h0m with 0 errors on Mon Jun  2 14:21:52 2014
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada2p3  ONLINE       0     0     0

errors: No known data errors</screen>
    </sect2>

    <sect2 xml:id="zfs-zpool-resilver">
      <title>Behandlung von fehlerhaften Geräten</title>

      <para>Wenn eine Platte in einem Pool ausfällt, wird das vdev zu
	dem diese Platte gehört, den Zustand <link
	  linkend="zfs-term-degraded">degraded</link> erhalten.  Alle
	Daten sind immer noch verfügbar, jedoch wird die
	Geschwindigkeit möglicherweise reduziert, weil die fehlenden
	Daten aus der verfügbaren Redundanz heraus berechnet werden
	müssen.  Um das vdev in einen funktionierenden Zustand zurück
	zu versetzen, muss das physikalische Gerät ersetzt werden.
	<acronym>ZFS</acronym> wird dann angewiesen, den <link
	  linkend="zfs-term-resilver">resilver</link>-Vorgang zu
	beginnen.  Daten, die sich auf dem defekten Gerät befanden,
	werden neu aus der vorhandenen Prüfsumme berechnet und auf das
	Ersatzgerät geschrieben.  Nach Beendigung dieses Prozesses
	kehrt das vdev zum Status <link
	linkend="zfs-term-online">online</link> zurück.</para>

      <para>Falls das vdev keine Redundanz besitzt oder wenn mehrere
	Geräte ausgefallen sind und es nicht genug Redundanz gibt, um
	dies zu kompensieren, geht der Pool in den Zustand <link
	linkend="zfs-term-faulted">faulted</link> über.  Wenn keine
	ausreichende Anzahl von Geräten wieder an den Pool
	angeschlossen wird, fällt der Pool aus und die Daten
	müssen von Sicherungen wieder eingespielt werden.</para>

      <para>Wenn eine defekte Platte ausgewechselt wird, wird der Name
	dieser defekten Platte mit der <acronym>GUID</acronym> des
	Geräts ersetzt.  Ein neuer Gerätename als Parameter für
	<command>zpool replace</command> wird nicht benötigt, falls
	das Ersatzgerät den gleichen Gerätenamen besitzt.</para>

      <para>Ersetzen einer defekten Platte durch
	<command>zpool replace</command>:</para>

      <screen>&prompt.root; <userinput>zpool status</userinput>
  pool: mypool
 state: DEGRADED
status: One or more devices could not be opened.  Sufficient replicas exist for
        the pool to continue functioning in a degraded state.
action: Attach the missing device und online it using 'zpool online'.
   see: http://illumos.org/msg/ZFS-8000-2Q
  scan: none requested
config:

        NAME                    STATE     READ WRITE CKSUM
        mypool                  DEGRADED     0     0     0
          mirror-0              DEGRADED     0     0     0
            ada0p3              ONLINE       0     0     0
            316502962686821739  UNAVAIL      0     0     0  was /dev/ada1p3

errors: No known data errors
&prompt.root; <userinput>zpool replace <replaceable>mypool</replaceable> <replaceable>316502962686821739</replaceable> <replaceable>ada2p3</replaceable></userinput>
&prompt.root; <userinput>zpool status</userinput>
  pool: mypool
 state: DEGRADED
status: One or more devices is currently being resilvered.  The pool will
        continue to function, possibly in a degraded state.
action: Wait for the resilver to complete.
  scan: resilver in progress since Mon Jun  2 14:52:21 2014
        641M scanned out of 781M at 49.3M/s, 0h0m to go
        640M resilvered, 82.04% done
config:

        NAME                        STATE     READ WRITE CKSUM
        mypool                      DEGRADED     0     0     0
          mirror-0                  DEGRADED     0     0     0
            ada0p3                  ONLINE       0     0     0
            replacing-1             UNAVAIL      0     0     0
              15732067398082357289  UNAVAIL      0     0     0  was /dev/ada1p3/old
              ada2p3                ONLINE       0     0     0  (resilvering)

errors: No known data errors
&prompt.root; <userinput>zpool status</userinput>
  pool: mypool
 state: ONLINE
  scan: resilvered 781M in 0h0m with 0 errors on Mon Jun  2 14:52:38 2014
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada2p3  ONLINE       0     0     0

errors: No known data errors</screen>
    </sect2>

    <sect2 xml:id="zfs-zpool-scrub">
      <title>Einen Pool überprüfen</title>

      <para>Es wird empfohlen, dass Pools regelmäßig geprüft (<link
	  linkend="zfs-term-scrub">scrubbed</link>) werden,
	idealerweise mindestens einmal pro Monat.  Der
	<command>scrub</command>-Vorgang ist beansprucht die Platte
	sehr und reduziert die Geschwindigkeit während er läuft.
	Vermeiden Sie Zeiten, in denen großer Bedarf besteht, wenn
	Sie <command>scrub</command> starten oder benutzen Sie <link
	  linkend="zfs-advanced-tuning-scrub_delay"><varname>vfs.zfs.scrub_delay</varname></link>,
	um die relative Priorität vom <command>scrub</command>
	einzustellen, um zu verhindern, dass es mit anderen Aufgaben
	kollidiert.</para>

      <screen>&prompt.root; <userinput>zpool scrub <replaceable>mypool</replaceable></userinput>
&prompt.root; <userinput>zpool status</userinput>
  pool: mypool
 state: ONLINE
  scan: scrub in progress since Wed Feb 19 20:52:54 2014
        116G scanned out of 8.60T at 649M/s, 3h48m to go
        0 repaired, 1.32% done
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          raidz2-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0
            ada2p3  ONLINE       0     0     0
            ada3p3  ONLINE       0     0     0
            ada4p3  ONLINE       0     0     0
            ada5p3  ONLINE       0     0     0

errors: No known data errors</screen>

      <para>Falls eine Überrpüfaktion abgebrochen werden muss, geben
	Sie <command>zpool scrub -s
	  <replaceable>mypool</replaceable></command> ein.</para>
    </sect2>

    <sect2 xml:id="zfs-zpool-selfheal">
      <title>Selbstheilung</title>

      <para>Die Prüfsummen, welche zusammen mit den Datenblöcken
	gespeichert werden, ermöglichen dem Dateisystem, sich
	<emphasis>selbst zu heilen</emphasis>.  Diese Eigenschaft wird
	automatisch Daten korrigieren, deren Prüfsumme nicht mit der
	Gespeicherten übereinstimmt, die auf einem anderen Gerät, das
	Teil des Pools ist, vorhanden ist.  Beispielsweise bei
	einem Spiegel aus zwei Platten, von denen eine anfängt, Fehler
	zu produzieren und nicht mehr länger Daten speichern kann.
	Dieser Fall ist sogar noch schlimmer, wenn auf die Daten seit
	einiger Zeit nicht mehr zugegriffen wurde, zum Beispiel bei
	einem Langzeit-Archivspeicher.  Traditionelle Dateisysteme
	müssen dann Algorithmen wie &man.fsck.8; ablaufen lassen,
	welche die Daten überprüfen und reparieren.  Diese Kommandos
	benötigen einige Zeit und in gravierenden Fällen muss ein
	Administrator manuelle Entscheidungen treffen, welche
	Reparaturoperation vorgenommen werden soll.  Wenn
	<acronym>ZFS</acronym> einen defekten Datenblock mit einer
	Prüfsumme erkennt, die nicht übereinstimmt, versucht es die
	Daten von der gespiegelten Platte zu lesen.  Wenn diese Platte
	die korrekten Daten liefern kann, wird nicht nur dieser
	Datenblock an die anfordernde Applikation geschickt, sondern
	auch die falschen Daten auf der Disk reparieren, welche die
	falsche Prüfsumme erzeugt hat.  Dies passiert während des
	normalen Betriebs des Pools, ohne dass eine
	Interaktion vom Systemadministrator notwendig wäre.</para>

      <para>Das nächste Beispiel demonstriert dieses Verhalten zur
	Selbstheilung.  Ein gespiegelter Pool mit den beiden Platten
	<filename>/dev/ada0</filename> und
	<filename>/dev/ada1</filename> wird angelegt.</para>

      <screen>&prompt.root; <userinput>zpool create <replaceable>healer</replaceable> mirror <replaceable>/dev/ada0</replaceable> <replaceable>/dev/ada1</replaceable></userinput>
&prompt.root; <userinput>zpool status <replaceable>healer</replaceable></userinput>
  pool: healer
 state: ONLINE
  scan: none requested
config:

    NAME        STATE     READ WRITE CKSUM
    healer      ONLINE       0     0     0
      mirror-0  ONLINE       0     0     0
       ada0     ONLINE       0     0     0
       ada1     ONLINE       0     0     0

errors: No known data errors
&prompt.root; <userinput>zpool list</userinput>
NAME     SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG   CAP  DEDUP  HEALTH  ALTROOT
healer   960M  92.5K   960M         -         -     0%    0%  1.00x  ONLINE  -</screen>

      <para>Ein paar wichtige Daten, die es vor Datenfehlern mittels
	der Selbstheilungsfunktion zu schützen gilt, werden auf den
	Pool kopiert.  Eine Prüfsumme wird zum späteren Vergleich
	berechnet.</para>

      <screen>&prompt.root; <userinput>cp /some/important/data /healer</userinput>
&prompt.root; <userinput>zfs list</userinput>
NAME     SIZE  ALLOC   FREE    CAP  DEDUP  HEALTH  ALTROOT
healer   960M  67.7M   892M     7%  1.00x  ONLINE  -
&prompt.root; <userinput>sha1 /healer > checksum.txt</userinput>
&prompt.root; <userinput>cat checksum.txt</userinput>
SHA1 (/healer) = 2753eff56d77d9a536ece6694bf0a82740344d1f</screen>

      <para>Datenfehler werden durch das Schreiben von zufälligen
	Daten an den Anfang einer Platte des Spiegels simuliert.  Um
	<acronym>ZFS</acronym> daran zu hindern, die Daten so schnell
	zu reparieren, wie es diese entdeckt, wird der Pool vor der
	Veränderung exportiert und anschließend wieder
	importiert.</para>

      <warning>
	<para>Dies ist eine gefährliche Operation, die wichtige Daten
	  zerstören kann.  Es wird hier nur zu Demonstrationszwecken
	  gezeigt und sollte nicht während des normalen Betriebs des
	  Pools versucht werden.  Dieses vorsätzliche
	  Korrumpierungsbeispiel sollte auf gar keinen Fall auf einer
	  Platte mit einem anderen Dateisystem durchgeführt werden.
	  Verwenden Sie keine anderen Gerätenamen als diejenigen, die
	  hier gezeigt werden, die Teil des Pools sind.  Stellen Sie
	  sicher, dass die passende Sicherungen angefertigt haben,
	  bevor Sie dieses Kommando ausführen!</para>
      </warning>

      <screen>&prompt.root; <userinput>zpool export <replaceable>healer</replaceable></userinput>
&prompt.root; <userinput>dd if=/dev/random of=/dev/ada1 bs=1m count=200</userinput>
200+0 records in
200+0 records out
209715200 bytes transferred in 62.992162 secs (3329227 bytes/sec)
&prompt.root; <userinput>zpool import healer</userinput></screen>

      <para>Der Status des Pools zeigt an, dass bei einem Gerät ein
	Fehler aufgetreten ist.  Wichtig zu wissen ist, dass
	Anwendungen, die Daten vom Pool lesen keine ungültigen Daten
	erhalten haben.  <acronym>ZFS</acronym> lieferte Daten vom
	<filename>ada0</filename>-Gerät mit der korrekten Prüfsumme
	aus.  Das Gerät mit der fehlerhaften Prüfsumme kann sehr
	einfach gefunden werden, da die Spalte
	<literal>CKSUM</literal> einen Wert ungleich Null
	enthält.</para>

      <screen>&prompt.root; <userinput>zpool status <replaceable>healer</replaceable></userinput>
    pool: healer
   state: ONLINE
  status: One or more devices has experienced an unrecoverable error.  An
          attempt was made to correct the error.  Applications are unaffected.
  action: Determine if the device needs to be replaced, und clear the errors
          using 'zpool clear' or replace the device with 'zpool replace'.
     see: http://illumos.org/msg/ZFS-8000-4J
    scan: none requested
  config:

      NAME        STATE     READ WRITE CKSUM
      healer      ONLINE       0     0     0
        mirror-0  ONLINE       0     0     0
         ada0     ONLINE       0     0     0
         ada1     ONLINE       0     0     1

errors: No known data errors</screen>

      <para>Der Fehler wurde erkannt und korrigiert durch die
	vorhandene Redundanz, welche aus der nicht betroffenen Platte
	<filename>ada0</filename> des Spiegels gewonnen wurde.
	Ein Vergleich der Prüfsumme mit dem Original wird zeigen, ob
	sich der Pool wieder in einem konsistenten Zustand
	befindet.</para>

      <screen>&prompt.root; <userinput>sha1 /healer >> checksum.txt</userinput>
&prompt.root; <userinput>cat checksum.txt</userinput>
SHA1 (/healer) = 2753eff56d77d9a536ece6694bf0a82740344d1f
SHA1 (/healer) = 2753eff56d77d9a536ece6694bf0a82740344d1f</screen>

      <para>Die beiden Prüfsummen, die vor und nach der vorsätzlichen
	Korrumpierung der Daten des Pools angelegt wurden, stimmen
	immer noch überein.  Dies zeigt wie <acronym>ZFS</acronym> in
	der Lage ist, Fehler automatisch zu erkennen und zu
	korrigieren, wenn die Prüfsummen nicht übereinstimmen.
	Beachten Sie, dass dies nur möglich ist, wenn genug Redundanz
	im Pool vorhanden ist.  Ein Pool, der nur aus einer einzigen
	Platte besteht besitzt keine Selbstheilungsfunktion.  Dies ist
	auch der Grund warum Prüfsummen bei <acronym>ZFS</acronym> so
	wichtig sind und deshalb aus keinem Grund deaktiviert werden
	sollten.  Kein &man.fsck.8; ist nötig, um diese Fehler zu
	erkennen und zu korrigieren und der Pool war während der
	gesamten Zeit, in der das Problem bestand, verfügbar.  Eine
	scrub-Aktion ist nun nötig, um die fehlerhaften Daten auf
	<filename>ada1</filename> zu beheben.</para>

      <screen>&prompt.root; <userinput>zpool scrub <replaceable>healer</replaceable></userinput>
&prompt.root; <userinput>zpool status <replaceable>healer</replaceable></userinput>
  pool: healer
 state: ONLINE
status: One or more devices has experienced an unrecoverable error.  An
            attempt was made to correct the error.  Applications are unaffected.
action: Determine if the device needs to be replaced, und clear the errors
            using 'zpool clear' or replace the device with 'zpool replace'.
   see: http://illumos.org/msg/ZFS-8000-4J
  scan: scrub in progress since Mon Dec 10 12:23:30 2012
        10.4M scanned out of 67.0M at 267K/s, 0h3m to go
        9.63M repaired, 15.56% done
config:

    NAME        STATE     READ WRITE CKSUM
    healer      ONLINE       0     0     0
      mirror-0  ONLINE       0     0     0
       ada0     ONLINE       0     0     0
       ada1     ONLINE       0     0   627  (repairing)

errors: No known data errors</screen>

      <para>Durch das scrub werden die Daten von
	<filename>ada0</filename> gelesen und alle Daten mit einer
	falschen durch diejenigen mit der richtigen Prüfsumme auf
	<filename>ada1</filename> ersetzt.  Dies wird durch die
	Ausgabe <literal>(repairing)</literal> des Kommandos
	<command>zpool status</command> angezeigt.  Nachdem die
	Operation abgeschlossen ist, ändert sich der Poolstatus
	zu:</para>

      <screen>&prompt.root; <userinput>zpool status <replaceable>healer</replaceable></userinput>
  pool: healer
 state: ONLINE
status: One or more devices has experienced an unrecoverable error.  An
        attempt was made to correct the error.  Applications are unaffected.
action: Determine if the device needs to be replaced, und clear the errors
             using 'zpool clear' or replace the device with 'zpool replace'.
   see: http://illumos.org/msg/ZFS-8000-4J
  scan: scrub repaired 66.5M in 0h2m with 0 errors on Mon Dec 10 12:26:25 2012
config:

    NAME        STATE     READ WRITE CKSUM
    healer      ONLINE       0     0     0
      mirror-0  ONLINE       0     0     0
       ada0     ONLINE       0     0     0
       ada1     ONLINE       0     0 2.72K

errors: No known data errors</screen>

      <para>Nach der scrub-Operation und der anschliessenden
	Synchronisation der Daten von <filename>ada0</filename> nach
	<filename>ada1</filename>, kann die Fehlermeldung vom
	Poolstatus durch die Eingabe von
	<command>zpool clear</command>
	<link linkend="zfs-zpool-clear">bereinigt</link> werden.</para>

      <screen>&prompt.root; <userinput>zpool clear <replaceable>healer</replaceable></userinput>
&prompt.root; <userinput>zpool status <replaceable>healer</replaceable></userinput>
  pool: healer
 state: ONLINE
  scan: scrub repaired 66.5M in 0h2m with 0 errors on Mon Dec 10 12:26:25 2012
config:

    NAME        STATE     READ WRITE CKSUM
    healer      ONLINE       0     0     0
      mirror-0  ONLINE       0     0     0
       ada0     ONLINE       0     0     0
       ada1     ONLINE       0     0     0

errors: No known data errors</screen>

      <para>Der Pool ist jetzt wieder in einem voll funktionsfähigen
	Zustand versetzt worden und alle Fehler wurden
	beseitigt.</para>
    </sect2>

    <sect2 xml:id="zfs-zpool-online">
      <title>Einen Pool vergrössern</title>

      <para>Die verwendbare Größe eines redundant ausgelegten Pools
	ist durch die Kapazität des kleinsten Geräts in jedem vdev
	begrenzt.  Das kleinste Gerät kann durch ein größeres Gerät
	ersetzt werden.  Nachdem eine <link
	  linkend="zfs-zpool-replace">replace</link> oder <link
	  linkend="zfs-term-resilver">resilver</link>-Operation
	abgeschlossen wurde, kann der Pool anwachsen, um die Kapazität
	des neuen Geräts zu nutzen.  Nehmen wir als Beispiel einen
	Spiegel mit einer 1&nbsp;TB und einer 2&nbsp;TB Platte.  Der
	verwendbare Plattenplatz beträgt 1&nbsp;TB.  Wenn die
	1&nbsp;TB Platte mit einer anderen 2&nbsp;TB Platte ersetzt
	wird, kopiert der resilver-Prozess die existierenden Daten auf
	die neue Platte.  Da beide Geräte nun 2&nbsp;TB Kapazität
	besitzen, kann auch der verfügbare Plattenplatz auf die Größe
	von 2&nbsp;TB anwachsen.</para>

      <para>Die Erweiterung wird durch das Kommando
	<command>zpool online -e</command> auf jedem Gerät ausgelöst.
	Nachdem alle Geräte expandiert wurden, wird der Speicher im
	Pool zur Verfügung gestellt.</para>
    </sect2>

    <sect2 xml:id="zfs-zpool-import">
      <title>Importieren und Exportieren von Pools</title>

      <para>Pools werden <emphasis>exportiert</emphasis> bevor diese
	an ein anderes System angeschlossen werden.  Alle Datasets
	werden abgehängt und jedes Gerät wird als exportiert markiert,
	ist jedoch immer noch gesperrt, so dass es nicht von anderen
	Festplattensubsystemen verwendet werden kann.  Dadurch können
	Pools auf anderen Maschinen <emphasis>importiert</emphasis>
	werden, die <acronym>ZFS</acronym> und sogar andere
	Hardwarearchitekturen (bis auf ein paar Ausnahmen, siehe
	&man.zpool.8;) unterstützen.  Besitzt ein Dataset offene
	Dateien, kann <command>zpool export -f</command> den Export
	des Pools erzwingen.  Verwenden Sie dies mit Vorsicht.  Die
	Datasets werden dadurch gewaltsam abgehängt, was bei
	Anwendungen, die noch offene Dateien auf diesem Dataset
	hatten, möglicherweise zu unerwartetem Verhalten führen
	kann.</para>

      <para>Einen nichtverwendeten Pool exportieren:</para>

      <screen>&prompt.root; <userinput>zpool export mypool</userinput></screen>

      <para>Beim Importieren eines Pool werden auch automatisch alle
	Datasets eingehängt.  Dies ist möglicherweise nicht das
	bevorzugte Verhalten und wird durch
	<command>zpool import -N</command> verhindert.  Durch
	<command>zpool import -o</command> temporäre Eigenschaften nur
	für diesen Import gesetzt.  Mit dem Befehl
	<command>zpool import altroot=</command> ist es möglich, einen
	Pool mit einem anderen Basiseinhängepunkt anstatt der Wurzel
	des Dateisystems einzubinden.  Wenn der Pool zuletzt auf einem
	anderen System verwendet und nicht korrekt exportiert
	wurde, muss unter Umständen ein Import erzwungen werden durch
	<command>zpool import -f</command>.  Alle Pools, die momentan
	nicht durch ein anderes System verwendet werden, lassen sich
	mit <command>zpool import -a</command> importieren.</para>

      <para>Alle zum Import verfügbaren Pools auflisten:</para>

      <screen>&prompt.root; <userinput>zpool import</userinput>
   pool: mypool
     id: 9930174748043525076
  state: ONLINE
 action: The pool can be imported using its name or numeric identifier.
 config:

        mypool      ONLINE
          ada2p3    ONLINE</screen>

      <para>Den Pool mit einem anderen Wurzelverzeichnis
	importieren:</para>

      <screen>&prompt.root; <userinput>zpool import -o altroot=<replaceable>/mnt</replaceable> <replaceable>mypool</replaceable></userinput>
&prompt.root; <userinput>zfs list</userinput>
zfs list
NAME                 USED  AVAIL  REFER  MOUNTPOINT
mypool               110K  47.0G    31K  /mnt/mypool</screen>
    </sect2>

    <sect2 xml:id="zfs-zpool-upgrade">
      <title>Einen Pool aktualisieren</title>

      <para>Nachdem &os; aktualisiert wurde oder wenn der Pool von
	einem anderen System, das eine ältere Version von
	<acronym>ZFS</acronym> einsetzt, lässt sich der Pool manuell
	auf den aktuellen Stand von <acronym>ZFS</acronym> bringen, um
	die neuesten Eigenschaften zu unterstützen.  Bedenken Sie, ob
	der Pool jemals wieder von einem älteren System eingebunden
	werden muss, bevor Sie die Aktualisierung durchführen.  Das
	aktualisieren eines Pools ist ein nicht umkehrbarer Prozess.
	ältere Pools lassen sich aktualisieren, jedoch lassen sich
	Pools mit neueren Eigenschaften nicht wieder auf eine ältere
	Version bringen.</para>

      <para>Aktualisierung eines v28-Pools, um
	<literal>Feature Flags</literal> zu unterstützen:</para>

      <screen>&prompt.root; <userinput>zpool status</userinput>
  pool: mypool
 state: ONLINE
status: The pool is formatted using a legacy on-disk format.  The pool can
        still be used, but some features are unavailable.
action: Upgrade the pool using 'zpool upgrade'.  Once this is done, the
        pool will no longer be accessible on software that does not support feat
        flags.
  scan: none requested
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
	    ada0    ONLINE       0     0     0
	    ada1    ONLINE       0     0     0

errors: No known data errors
&prompt.root; <userinput>zpool upgrade</userinput>
This system supports ZFS pool feature flags.

The following pools are formatted with legacy version numbers und can
be upgraded to use feature flags.  After being upgraded, these pools
will no longer be accessible by software that does not support feature
flags.

VER  POOL
---  ------------
28   mypool

Use 'zpool upgrade -v' for a list of available legacy versions.
Every feature flags pool has all supported features enabled.
&prompt.root; <userinput>zpool upgrade mypool</userinput>
This system supports ZFS pool feature flags.

Successfully upgraded 'mypool' from version 28 to feature flags.
Enabled the following features on 'mypool':
  async_destroy
  empty_bpobj
  lz4_compress
  multi_vdev_crash_dump</screen>

      <para>Die neueren Eigenschaften von <acronym>ZFS</acronym>
	werden nicht verfügbar sein, bis
	<command>zpool upgrade</command> abgeschlossen ist.
	<command>zpool upgrade -v</command> kann verwendet werden, um
	zu sehen, welche neuen Eigenschaften durch die Aktualisierung
	bereitgestellt werden, genauso wie diejenigen, die momentan
	schon verfügbar sind.</para>

      <para>Einen Pool um zusätzliche Feature Flags erweitern:</para>

      <screen>&prompt.root; <userinput>zpool status</userinput>
  pool: mypool
 state: ONLINE
status: Some supported features are not enabled on the pool. The pool can
        still be used, but some features are unavailable.
action: Enable all features using 'zpool upgrade'. Once this is done,
        the pool may no longer be accessible by software that does not support
        the features. See zpool-features(7) for details.
  scan: none requested
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
	    ada0    ONLINE       0     0     0
	    ada1    ONLINE       0     0     0

errors: No known data errors
&prompt.root; <userinput>zpool upgrade</userinput>
This system supports ZFS pool feature flags.

All pools are formatted using feature flags.


Some supported features are not enabled on the following pools. Once a
feature is enabled the pool may become incompatible with software
that does not support the feature. See zpool-features(7) for details.

POOL  FEATURE
---------------
zstore
      multi_vdev_crash_dump
      spacemap_histogram
      enabled_txg
      hole_birth
      extensible_dataset
      bookmarks
      filesystem_limits
&prompt.root; <userinput>zpool upgrade mypool</userinput>
This system supports ZFS pool feature flags.

Enabled the following features on 'mypool':
  spacemap_histogram
  enabled_txg
  hole_birth
  extensible_dataset
  bookmarks
  filesystem_limits</screen>

      <warning>
	<para>Der Bootcode muss auf Systemen, die von dem Pool
	  starten, aktualisiert werden, um diese neue Version zu
	  unterstützen.  Verwenden Sie
	 <command>gpart bootcode</command> auf der Partition, die den
	  Bootcode enthält.  Es gibt zwei Arten von Bootcode, je
	  nachdem, wie das System bootet: <acronym>GPT</acronym> (die
	  häufigste Option) und <acronym>EFI</acronym> (für moderne
	  Systeme).</para>
	
	<para>Benutzen Sie für <acronym>GPT</acronym> den folgenden
	  Befehl:</para>

	<screen>&prompt.root; <userinput>gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i <replaceable>1</replaceable> <replaceable>ada1</replaceable></userinput></screen>

	<para>Für Systeme, die <acronym>EFI</acronym> zum Booten
	  benutzen, führen Sie folgenden Befehl aus:</para>

	<screen>&prompt.root; <userinput>gpart bootcode -p /boot/boot1.efifat -i <replaceable>1</replaceable> <replaceable>ada1</replaceable></userinput></screen>

	<para>Installieren Sie den Bootcode auf allen bootfähigen
	  Platten im Pool.  Lesen Sie &man.gpart.8; für weitere
	  Informationen.</para>
      </warning>
    </sect2>

    <sect2 xml:id="zfs-zpool-history">
      <title>Aufgezeichnete Historie des Pools anzeigen</title>

      <para>Befehle, die den Pool in irgendeiner Form verändern,
	werden aufgezeichnet.  Diese Befehle beinhalten das Erstellen
	von Datasets, verändern von Eigenschaften oder das Ersetzen
	einer Platte.  Diese Historie ist nützlich um
	nachzuvollziehen, wie ein Pool aufgebaut ist und welcher
	Benutzer eine bestimmte Aktion wann und wie getätigt hat.  Die
	aufgezeichnete Historie wird nicht in einer Logdatei
	festgehalten, sondern ist Teil des Pools selbst.  Das Kommando
	zum darstellen dieser Historie lautet passenderweise
	<command>zpool history</command>:</para>

      <screen>&prompt.root; <userinput>zpool history</userinput>
History for 'tank':
2013-02-26.23:02:35 zpool create tank mirror /dev/ada0 /dev/ada1
2013-02-27.18:50:58 zfs set atime=off tank
2013-02-27.18:51:09 zfs set checksum=fletcher4 tank
2013-02-27.18:51:18 zfs create tank/backup</screen>

      <para>Die Ausgabe zeigt <command>zpool</command> und
	<command>zfs</command>-Befehle, die ausgeführt wurden zusammen
	mit einem Zeitstempel.  Nur Befehle, die den Pool verändern
	werden aufgezeichnet.  Befehle wie
	<command>zfs list</command> sind dabei nicht enthalten.  Wenn
	kein Name angegeben wird, erscheint die gesamte Historie aller
	Pools.</para>

      <para>Der Befehl <command>zpool history</command> kann sogar
	noch mehr Informationen ausgeben, wenn die Optionen
	<option>-i</option> oder <option>-l</option> angegeben
	werden.  Durch <option>-i</option> zeigt
	<acronym>ZFS</acronym> vom Benutzer eingegebene, als auch
	interne Ereignisse an.</para>

      <screen>&prompt.root; <userinput>zpool history -i</userinput>
History for 'tank':
2013-02-26.23:02:35 [internal pool create txg:5] pool spa 28; zfs spa 28; zpl 5;uts  9.1-RELEASE 901000 amd64
2013-02-27.18:50:53 [internal property set txg:50] atime=0 dataset = 21
2013-02-27.18:50:58 zfs set atime=off tank
2013-02-27.18:51:04 [internal property set txg:53] checksum=7 dataset = 21
2013-02-27.18:51:09 zfs set checksum=fletcher4 tank
2013-02-27.18:51:13 [internal create txg:55] dataset = 39
2013-02-27.18:51:18 zfs create tank/backup</screen>

      <para>Weitere Details lassen sich durch die Angabe von
	<option>-l</option> entlocken.  Historische Einträge werden in
	einem langen Format ausgegeben, einschließlich Informationen
	wie der Name des Benutzers, welcher das Kommando eingegeben
	hat und der Hostname, auf dem die Änderung erfolgte.</para>

      <screen>&prompt.root; <userinput>zpool history -l</userinput>
History for 'tank':
2013-02-26.23:02:35 zpool create tank mirror /dev/ada0 /dev/ada1 [user 0 (root) on :global]
2013-02-27.18:50:58 zfs set atime=off tank [user 0 (root) on myzfsbox:global]
2013-02-27.18:51:09 zfs set checksum=fletcher4 tank [user 0 (root) on myzfsbox:global]
2013-02-27.18:51:18 zfs create tank/backup [user 0 (root) on myzfsbox:global]</screen>

      <para>Die Ausgabe zeigt, dass der Benutzer <systemitem
	class="username">root</systemitem> den gespiegelten Pool mit
	den beiden Platten
	<filename>/dev/ada0</filename> und
	<filename>/dev/ada1</filename> angelegt hat.  Der Hostname
	<systemitem class="systemname">myzfsbox</systemitem> wird
	ebenfalls in den Kommandos angezeigt, nachdem der Pool erzeugt
	wurde.  Die Anzeige des Hostnamens wird wichtig, sobald der
	Pool von einem System exportiert und auf einem anderen
	importiert wird.  Die Befehle, welche auf dem anderen System
	verwendet werden, können klar durch den Hostnamen, der bei
	jedem Kommando mit verzeichnet wird, unterschieden
	werden.</para>

      <para>Beide Optionen für <command>zpool history</command> lassen
	sich auch kombinieren, um die meisten Details zur Historie
	eines Pools auszugeben.  Die Pool Historie liefert wertvolle
	Informationen, wenn Aktionen nachverfolgt werden müssen oder
	zur Fehlerbeseitigung mehr Informationen gebraucht
	werden.</para>
    </sect2>

    <sect2 xml:id="zfs-zpool-iostat">
      <title>Geschwindigkeitsüberwachung</title>

      <para>Ein eingebautes Überwachungssystem kann
	<acronym>I/O</acronym>-Statistiken in Echtzeit liefern.  Es
	zeigt die Menge von freiem und belegtem Speicherplatz auf dem
	Pool an, wieviele Lese- und Schreiboperationen pro Sekunde
	durchgeführt werden und die aktuell verwendete
	<acronym>I/O</acronym>-Bandbreite.  Standardmäßig werden alle
	Pools in einem System überwacht und angezeigt.  Ein Poolname
	kann angegeben werden, um die Anzeige auf diesen Pool zu
	beschränken.  Ein einfaches Beispiel:</para>

      <screen>&prompt.root; <userinput>zpool iostat</userinput>
               capacity     operations    bundwidth
pool        alloc   free   read  write   read  write
----------  -----  -----  -----  -----  -----  -----
data         288G  1.53T      2     11  11.3K  57.1K</screen>

      <para>Um kontinuierlich die <acronym>I/O</acronym>-Aktivität zu
	überprüfen, kann eine Zahl als letzter Parameter angegeben
	werden, die ein Intervall in Sekunden angibt, die zwischen den
	Aktualisierungen vergehen soll.  Die nächste Zeile mit
	Statistikinformationen wird dann nach jedem Intervall
	ausgegeben.  Drücken Sie
	<keycombo action="simul">
	  <keycap>Ctrl</keycap>
	  <keycap>C</keycap>
	</keycombo>, um diese kontinuierliche Überwachung zu stoppen.
	Alternativ lässt sich auch eine zweite Zahl nach dem
	Intervall auf der Kommandozeile angeben, welche die Obergrenze
	von Statistikausgaben darstellt, die angezeigt werden
	sollen.</para>

      <para>Noch mehr Informationen zu
	<acronym>I/O</acronym>-Statistiken können durch Angabe der
	Option <option>-v</option> angezeigt werden.  Jedes Gerät im
	Pool wird dann mit einer eigenen Statistikzeile aufgeführt.
	Dies ist hilfreich um zu sehen, wieviele Lese- und
	Schreiboperationen von jedem Gerät durchgeführt werden und
	kann bei der Diagnose eines langsamen Geräts, das den Pool
	ausbremst, hilfreich sein.  Dieses Beispiel zeigt einen
	gespiegelten Pool mit zwei Geräten:</para>

      <screen>&prompt.root; <userinput>zpool iostat -v </userinput>
                            capacity     operations    bundwidth
pool                     alloc   free   read  write   read  write
-----------------------  -----  -----  -----  -----  -----  -----
data                      288G  1.53T      2     12  9.23K  61.5K
  mirror                  288G  1.53T      2     12  9.23K  61.5K
    ada1                     -      -      0      4  5.61K  61.7K
    ada2                     -      -      1      4  5.04K  61.7K
-----------------------  -----  -----  -----  -----  -----  -----</screen>
    </sect2>

    <sect2 xml:id="zfs-zpool-split">
      <title>Einen Pool aufteilen</title>

      <para>Ein Pool, der aus einem oder mehreren gespiegelten vdevs
	besteht, kann in zwei Pools aufgespalten werden.  Falls nicht
	anders angegeben, wird das letzte Mitglied eines Spiegels
	abgehängt und dazu verwendet, einen neuen Pool mit den
	gleichen Daten zu erstellen.  Die Operation sollte zuerst mit
	der Option <option>-n</option> versucht werden.  Die Details
	der vorgeschlagenen Option werden dargestellt, ohne die Aktion
	in Wirklichkeit durchzuführen.  Das hilft dabei zu bestätigen,
	ob die Aktion das tut, was der Benutzer damit vor
	hatte.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="zfs-zfs">
    <title><command>zfs</command> Administration</title>

    <para>Das <command>zfs</command>-Werkzeug ist dafür
      verantwortlich, alle <acronym>ZFS</acronym> Datasets innerhalb
      eines Pools zu erstellen, zerstören und zu verwalten.  Der Pool
      selbst wird durch <link
	linkend="zfs-zpool"><command>zpool</command></link>
      verwaltet.</para>

    <sect2 xml:id="zfs-zfs-create">
      <title>Datasets erstellen und zerstören</title>

      <para>Anders als in traditionellen Festplatten- und
	Volumenmanagern wird der Plattenplatz in
	<acronym>ZFS</acronym> <emphasis>nicht</emphasis>
	vorher allokiert.  Bei traditionellen Dateisystemen gibt es,
	nachdem der Plattenplatz partitioniert und
	zugeteilt wurde, keine Möglichkeit, ein zusätzliches
	Dateisystem hinzuzufügen, ohne eine neue Platte
	anzuschließen.  Mit
	<acronym>ZFS</acronym> lassen sich neue Dateisysteme zu jeder
	Zeit anlegen.  Jedes <link
	  linkend="zfs-term-dataset"><emphasis>Dataset</emphasis></link>
	besitzt Eigenschaften wie Komprimierung, Deduplizierung,
	Zwischenspeicher (caching), Quotas, genauso wie andere
	nützliche Einstellungen wie Schreibschutz, Unterscheidung
	zwischen Groß- und Kleinschreibung, Netzwerkfreigaben und
	einen Einhängepunkt.  Datasets können ineinander verschachtelt
	werden und Kind-Datasets erben die Eigenschaften ihrer Eltern.
	Jedes Dataset kann als eine Einheit verwaltet,
	<link linkend="zfs-zfs-allow">delegiert</link>,
	<link linkend="zfs-zfs-send">repliziert</link>,
	<link linkend="zfs-zfs-snapshot">mit Schnappschüssen
	versehen</link>, <link linkend="zfs-zfs-jail">in Jails
	gesteckt</link> und zerstört werden.  Es gibt viele Vorteile,
	ein separates Dataset für jede Art von Dateien anzulegen.  Der
	einzige Nachteil einer großen Menge an Datasets ist, dass
	manche Befehle wie <command>zfs list</command> langsamer sind
	und dass das Einhängen von hunderten oder hunderttausenden von
	Datasets den &os;-Bootvorgang verzögert.</para>

      <para>Erstellen eines neuen Datasets und aktivieren von <link
	  linkend="zfs-term-compression-lz4">LZ4
	Komprimierung</link>:</para>

      <screen>&prompt.root; <userinput>zfs list</userinput>
NAME                  USED  AVAIL  REFER  MOUNTPOINT
mypool                781M  93.2G   144K  none
mypool/ROOT           777M  93.2G   144K  none
mypool/ROOT/default   777M  93.2G   777M  /
mypool/tmp            176K  93.2G   176K  /tmp
mypool/usr            616K  93.2G   144K  /usr
mypool/usr/home       184K  93.2G   184K  /usr/home
mypool/usr/ports      144K  93.2G   144K  /usr/ports
mypool/usr/src        144K  93.2G   144K  /usr/src
mypool/var           1.20M  93.2G   608K  /var
mypool/var/crash      148K  93.2G   148K  /var/crash
mypool/var/log        178K  93.2G   178K  /var/log
mypool/var/mail       144K  93.2G   144K  /var/mail
mypool/var/tmp        152K  93.2G   152K  /var/tmp
&prompt.root; <userinput>zfs create -o compress=lz4 <replaceable>mypool/usr/mydataset</replaceable></userinput>
&prompt.root; <userinput>zfs list</userinput>
NAME                   USED  AVAIL  REFER  MOUNTPOINT
mypool                 781M  93.2G   144K  none
mypool/ROOT            777M  93.2G   144K  none
mypool/ROOT/default    777M  93.2G   777M  /
mypool/tmp             176K  93.2G   176K  /tmp
mypool/usr             704K  93.2G   144K  /usr
mypool/usr/home        184K  93.2G   184K  /usr/home
mypool/usr/mydataset  87.5K  93.2G  87.5K  /usr/mydataset
mypool/usr/ports       144K  93.2G   144K  /usr/ports
mypool/usr/src         144K  93.2G   144K  /usr/src
mypool/var            1.20M  93.2G   610K  /var
mypool/var/crash       148K  93.2G   148K  /var/crash
mypool/var/log         178K  93.2G   178K  /var/log
mypool/var/mail        144K  93.2G   144K  /var/mail
mypool/var/tmp         152K  93.2G   152K  /var/tmp</screen>

      <para>Ein Dataset zu zerstören ist viel schneller, als alle
	Dateien zu löschen, die sich in dem Dataset befindet, da es
	keinen Scan aller Dateien und aktualisieren der dazugehörigen
	Metadaten erfordert.</para>

      <para>Zerstören des zuvor angelegten Datasets:</para>

      <screen>&prompt.root; <userinput>zfs list</userinput>
NAME                   USED  AVAIL  REFER  MOUNTPOINT
mypool                 880M  93.1G   144K  none
mypool/ROOT            777M  93.1G   144K  none
mypool/ROOT/default    777M  93.1G   777M  /
mypool/tmp             176K  93.1G   176K  /tmp
mypool/usr             101M  93.1G   144K  /usr
mypool/usr/home        184K  93.1G   184K  /usr/home
mypool/usr/mydataset   100M  93.1G   100M  /usr/mydataset
mypool/usr/ports       144K  93.1G   144K  /usr/ports
mypool/usr/src         144K  93.1G   144K  /usr/src
mypool/var            1.20M  93.1G   610K  /var
mypool/var/crash       148K  93.1G   148K  /var/crash
mypool/var/log         178K  93.1G   178K  /var/log
mypool/var/mail        144K  93.1G   144K  /var/mail
mypool/var/tmp         152K  93.1G   152K  /var/tmp
&prompt.root; <userinput>zfs destroy <replaceable>mypool/usr/mydataset</replaceable></userinput>
&prompt.root; <userinput>zfs list</userinput>
NAME                  USED  AVAIL  REFER  MOUNTPOINT
mypool                781M  93.2G   144K  none
mypool/ROOT           777M  93.2G   144K  none
mypool/ROOT/default   777M  93.2G   777M  /
mypool/tmp            176K  93.2G   176K  /tmp
mypool/usr            616K  93.2G   144K  /usr
mypool/usr/home       184K  93.2G   184K  /usr/home
mypool/usr/ports      144K  93.2G   144K  /usr/ports
mypool/usr/src        144K  93.2G   144K  /usr/src
mypool/var           1.21M  93.2G   612K  /var
mypool/var/crash      148K  93.2G   148K  /var/crash
mypool/var/log        178K  93.2G   178K  /var/log
mypool/var/mail       144K  93.2G   144K  /var/mail
mypool/var/tmp        152K  93.2G   152K  /var/tmp</screen>

      <para>In modernen Versionen von <acronym>ZFS</acronym> ist
	<command>zfs destroy</command> asynchron und der freie
	Speicherplatz kann erst nach ein paar Minuten im Pool
	auftauchen.  Verwenden Sie <command>zpool get freeing
	  <replaceable>poolname</replaceable></command>, um die
	Eigenschaft <literal>freeing</literal> aufzulisten, die
	angibt, bei wievielen Datasets die Blöcke im Hintergrund
	freigegeben werden.  Sollte es Kind-Datasets geben,
	<link linkend="zfs-term-snapshot">Schnappschüsse</link> oder
	andere Datasets, dann lässt sich der Elternknoten nicht
	zerstören.  Um ein Dataset und all seine Kinder zu zerstören,
	verwenden Sie die Option <option>-r</option>, um das Dataset
	und all seine Kinder rekursiv zu entfernen.  Benutzen Sie die
	Option <option>-n</option> und <option>-v</option>, um
	Datasets und Snapshots anzuzeigen, die durch diese Aktion
	zerstört werden würden, dies jedoch nur zu simulieren und
	nicht wirklich durchzuführen.  Speicherplatz, der dadurch
	freigegeben würde, wird ebenfalls angezeigt.</para>
    </sect2>

    <sect2 xml:id="zfs-zfs-volume">
      <title>Volumes erstellen und zerstören</title>

      <para>Ein Volume ist ein spezieller Typ von Dataset.  Anstatt
	dass es als Dateisystem eingehängt wird, stellt es ein
	Block-Gerät unter
	<filename>/dev/zvol/<replaceable>poolname</replaceable>/<replaceable>dataset</replaceable></filename>
	dar.  Dies erlaubt es, das Volume für andere Dateisysteme zu
	verwenden, die Festplatten einer virtuellen Maschine
	bereitzustellen oder über Protokolle wie
	<acronym>iSCSI</acronym> oder <acronym>HAST</acronym>
	exportiert zu werden.</para>

      <para>Ein Volume kann mit einem beliebigen Dateisystem
	formatiert werden oder auch ohne ein Dateisystem als reiner
	Datenspeicher fungieren.  Für den Benutzer erscheint ein
	Volume als eine gewöhnliche Platte.  Indem gewöhnliche
	Dateisysteme auf diesen <emphasis>zvols</emphasis> angelegt
	werden, ist es möglich, diese mit Eigenschaften auszustatten,
	welche diese normalerweise nicht besitzen.  Beispielsweise
	wird durch Verwendung der Komprimierungseigenschaft auf einem
	250&nbsp;MB Volume das Erstellen eines komprimierten
	<acronym>FAT</acronym> Dateisystems möglich.</para>

      <screen>&prompt.root; <userinput>zfs create -V 250m -o compression=on tank/fat32</userinput>
&prompt.root; <userinput>zfs list tank</userinput>
NAME USED AVAIL REFER MOUNTPOINT
tank 258M  670M   31K /tank
&prompt.root; <userinput>newfs_msdos -F32 /dev/zvol/tank/fat32</userinput>
&prompt.root; <userinput>mount -t msdosfs /dev/zvol/tank/fat32 /mnt</userinput>
&prompt.root; <userinput>df -h /mnt | grep fat32</userinput>
Filesystem           Size Used Avail Capacity Mounted on
/dev/zvol/tank/fat32 249M  24k  249M     0%   /mnt
&prompt.root; <userinput>mount | grep fat32</userinput>
/dev/zvol/tank/fat32 on /mnt (msdosfs, local)</screen>

      <para>Ein Volume zu zerstören ist sehr ähnlich wie ein
	herkömmliches Dataset zu entfernen.  Die Operation wird
	beinahe sofort durchgeführt, jedoch kann es mehrere Minuten
	dauern, bis der freie Speicherplatz im Hintergrund wieder
	freigegeben ist.</para>
    </sect2>

    <sect2 xml:id="zfs-zfs-rename">
      <title>Umbenennen eines Datasets</title>

      <para>Der Name eines Datasets lässt sich durch
	<command>zfs rename</command> ändern.  Das Eltern-Dataset kann
	ebenfalls mit diesem Kommando umbenannt werden.  Ein Dataset
	unter einem anderen Elternteil umzubenennen wird den Wert
	dieser Eigenschaft verändern, die vom Elternteil vererbt
	wurden.  Wird ein Dataset umbenannt, wird es abgehängt und
	dann erneut unter der neuen Stelle eingehängt (welche vom
	neuen Elternteil geerbt wird).  Dieses Verhalten kann durch
	die Option <option>-u</option> verhindert werden.</para>

      <para>Ein Dataset umbenennen und unter einem anderen
	Elterndataset verschieben:</para>

      <screen>&prompt.root; <userinput>zfs list</userinput>
NAME                   USED  AVAIL  REFER  MOUNTPOINT
mypool                 780M  93.2G   144K  none
mypool/ROOT            777M  93.2G   144K  none
mypool/ROOT/default    777M  93.2G   777M  /
mypool/tmp             176K  93.2G   176K  /tmp
mypool/usr             704K  93.2G   144K  /usr
mypool/usr/home        184K  93.2G   184K  /usr/home
mypool/usr/mydataset  87.5K  93.2G  87.5K  /usr/mydataset
mypool/usr/ports       144K  93.2G   144K  /usr/ports
mypool/usr/src         144K  93.2G   144K  /usr/src
mypool/var            1.21M  93.2G   614K  /var
mypool/var/crash       148K  93.2G   148K  /var/crash
mypool/var/log         178K  93.2G   178K  /var/log
mypool/var/mail        144K  93.2G   144K  /var/mail
mypool/var/tmp         152K  93.2G   152K  /var/tmp
&prompt.root; <userinput>zfs rename <replaceable>mypool/usr/mydataset</replaceable> <replaceable>mypool/var/newname</replaceable></userinput>
&prompt.root; <userinput>zfs list</userinput>
NAME                  USED  AVAIL  REFER  MOUNTPOINT
mypool                780M  93.2G   144K  none
mypool/ROOT           777M  93.2G   144K  none
mypool/ROOT/default   777M  93.2G   777M  /
mypool/tmp            176K  93.2G   176K  /tmp
mypool/usr            616K  93.2G   144K  /usr
mypool/usr/home       184K  93.2G   184K  /usr/home
mypool/usr/ports      144K  93.2G   144K  /usr/ports
mypool/usr/src        144K  93.2G   144K  /usr/src
mypool/var           1.29M  93.2G   614K  /var
mypool/var/crash      148K  93.2G   148K  /var/crash
mypool/var/log        178K  93.2G   178K  /var/log
mypool/var/mail       144K  93.2G   144K  /var/mail
mypool/var/newname   87.5K  93.2G  87.5K  /var/newname
mypool/var/tmp        152K  93.2G   152K  /var/tmp</screen>

      <para>Schnappschüsse können auf diese Weise ebenfalls umbenannt
	werden.  Aufgrund der Art von Schnappschüssen können diese
	nicht unter einem anderen Elterndataset eingehängt werden.  Um
	einen rekursiven Schnappschuss umzubenennen, geben Sie die
	Option <option>-r</option> an, um alle Schnappschüsse mit dem
	gleichen Namen im Kind-Dataset ebenfalls umzubenennen.</para>

      <screen>&prompt.root; <userinput>zfs list -t snapshot</userinput>
NAME                                USED  AVAIL  REFER  MOUNTPOINT
mypool/var/newname@first_snapshot      0      -  87.5K  -
&prompt.root; <userinput>zfs rename <replaceable>mypool/var/newname@first_snapshot</replaceable> <replaceable>new_snapshot_name</replaceable></userinput>
&prompt.root; <userinput>zfs list -t snapshot</userinput>
NAME                                   USED  AVAIL  REFER  MOUNTPOINT
mypool/var/newname@new_snapshot_name      0      -  87.5K  -</screen>
    </sect2>

    <sect2 xml:id="zfs-zfs-set">
      <title>Festlegen von Dataset-Eigenschaften</title>

      <para>Jedes <acronym>ZFS</acronym>-Dataset besitzt eine Menge
	von Eigenschaften, die sein Verhalten beeinflussen.  Die
	meisten Eigenschaften werden automatisch vom Eltern-Dataset
	vererbt, können jedoch lokal überschrieben werden.  Sie legen
	eine Eigenschaft durch <command>zfs set
	  <replaceable>property</replaceable>=<replaceable>value</replaceable>
	  <replaceable>dataset</replaceable></command> fest.  Die
	meisten Eigenschaften haben eine begrenzte Menge von gültigen
	Werten.  <command>zfs get</command> stellt diese dar und zeigt
	jede mögliche Eigenschaft und gültige Werte an.  Die meisten
	Eigenschaften können über <command>zfs inherit</command>
	wieder auf ihren Ausgangswert zurückgesetzt werden.</para>

      <para>Benutzerdefinierte Eigenschaften lassen sich ebenfalls
	setzen.  Diese werden Teil der Konfiguration des Datasets und
	können dazu verwendet werden, zusätzliche Informationen über
	das Dataset oder seine Bestandteile zu speichern.  Um diese
	benutzerdefinierten Eigenschaften von den
	<acronym>ZFS</acronym>-eigenen zu unterscheiden, wird ein
	Doppelpunkt (<literal>:</literal>) verwendet, um einen eigenen
	Namensraum für diese Eigenschaft zu erstellen.</para>

      <screen>&prompt.root; <userinput>zfs set <replaceable>custom</replaceable>:<replaceable>costcenter</replaceable>=<replaceable>1234</replaceable> <replaceable>tank</replaceable></userinput>
&prompt.root; <userinput>zfs get <replaceable>custom</replaceable>:<replaceable>costcenter</replaceable> <replaceable>tank</replaceable></userinput>
NAME PROPERTY           VALUE SOURCE
tank custom:costcenter  1234  local</screen>

      <para>Um eine selbstdefinierte Eigenschaft umzubenennen,
	verwenden Sie <command>zfs inherit</command> mit der Option
	<option>-r</option>.  Wenn die benutzerdefinierte Eigenschaft
	nicht in einem der Eltern-Datasets definiert ist, wird diese
	komplett entfernt (obwohl diese Änderungen natürlich in der
	Historie des Pools noch aufgezeichnet sind).</para>

      <screen>&prompt.root; <userinput>zfs inherit -r <replaceable>custom</replaceable>:<replaceable>costcenter</replaceable> <replaceable>tank</replaceable></userinput>
&prompt.root; <userinput>zfs get <replaceable>custom</replaceable>:<replaceable>costcenter</replaceable> <replaceable>tank</replaceable></userinput>
NAME    PROPERTY           VALUE              SOURCE
tank    custom:costcenter  -                  -
&prompt.root; <userinput>zfs get all <replaceable>tank</replaceable> | grep <replaceable>custom</replaceable>:<replaceable>costcenter</replaceable></userinput>
&prompt.root;</screen>

      <sect3 xml:id="zfs-zfs-set-share">
	<title>Festlegen und Abfragen von
	  Eigenschaften für Freigaben</title>

	<para>Zwei häufig verwendete und nützliche
	  Dataset-Eigenschaften sind die Freigabeoptionen von
	  <acronym>NFS</acronym> und <acronym>SMB</acronym>.  Diese
	  Optionen legen fest, ob und wie
	  <acronym>ZFS</acronym>-Datasets im Netzwerk freigegeben
	  werden.  Derzeit unterstützt &os; nur Freigaben von Datasets
	  über <acronym>NFS</acronym>.  Um den Status einer Freigabe
	  zu erhalten, geben Sie folgendes ein:</para>

	<screen>&prompt.root; <userinput>zfs get sharenfs <replaceable>mypool/usr/home</replaceable></userinput>
NAME              PROPERTY   VALUE   SOURCE
mypool/usr/home   sharenfs   on      local
&prompt.root; <userinput>zfs get sharesmb <replaceable>mypool/usr/home</replaceable></userinput>
NAME              PROPERTY   VALUE   SOURCE
mypool/usr/home   sharesmb   off     local</screen>

	<para>Um ein Dataset freizugeben, geben Sie ein:</para>

	<screen>&prompt.root; <userinput>zfs set sharenfs=on <replaceable>mypool/usr/home</replaceable></userinput></screen>

	<para>Es ist auch möglich, weitere Optionen für die
	  Verwendung von Datasets über <acronym>NFS</acronym>
	  zu definieren, wie etwa <option>-alldirs</option>,
	  <option>-maproot</option> und <option>-network</option>.
	  Um zusätzliche Optionen auf ein durch
	  <acronym>NFS</acronym> freigegebenes Dataset festzulegen,
	  geben Sie ein:</para>

	<screen>&prompt.root; <userinput>zfs set sharenfs="-alldirs,maproot=<replaceable>root</replaceable>,-network=<replaceable>192.168.1.0/24</replaceable>" <replaceable>mypool/usr/home</replaceable></userinput></screen>
      </sect3>
    </sect2>

    <sect2 xml:id="zfs-zfs-snapshot">
      <title>Verwalten von Schnappschüssen</title>

      <para><link linkend="zfs-term-snapshot">Schnappschüsse</link>
	sind eine der mächtigen Eigenschaften von
	<acronym>ZFS</acronym>.  Ein Schnappschuss bietet einen
	nur-Lese Zustand eines Datasets zu einem bestimmten Zeitpunkt.
	Mit Kopieren-beim-Schreiben (Copy-On-Write
	<acronym>COW</acronym>), können Schnappschüsse schnell
	erstellt werden durch das Aufheben der älteren Version der
	Daten auf der Platte.  Falls kein Snapshot existiert, wird der
	Speicherplatz wieder für zukünftige Verwendung freigegeben
	wenn Daten geschrieben oder gelöscht werden.  Schnappschüsse
	sparen Speicherplatz, indem diese nur die Unterschiede
	zwischen dem momentanen Dataset und der vorherigen Version
	aufzeichnen.  Schnappschüsse sind nur auf ganzen Datasets
	erlaubt, nicht auf individuellen Dateien oder Verzeichnissen.
	Wenn ein Schnappschuss eines Datasets erstellt wird, wird
	alles was darin enthalten ist, dupliziert.  Das beinhaltet
	Dateisystemeigenschaften, Dateien, Verzeichnisse, Rechte und
	so weiter.  Schnappschüsse benötigen keinen zusätzlichen
	Speicherplatz wenn diese erstmals angelegt werden, nur wenn
	Blöcke, die diese referenzieren, geändert werden.  Rekursive
	Schnappschüsse, die mit der Option <option>-r</option>
	erstellt, erzeugen einen mit dem gleichen Namen des Datasets
	und all seinen Kindern, was eine konsistente Momentaufnahme
	aller Dateisysteme darstellt.  Dies kann wichtig sein, wenn
	eine Anwendung Dateien auf mehreren Datasets ablegt, die
	miteinander in Verbindung stehen oder voneinander abhängig
	sind.  Ohne Schnappschüsse würde ein Backup Kopien dieser
	Dateien zu unterschiedlichen Zeitpunkten enthalten.</para>

      <para>Schnappschüsse in <acronym>ZFS</acronym> bieten eine
	Vielzahl von Eigenschaften, die selbst in anderen
	Dateisystemen mit Schnappschussfunktion nicht vorhanden sind.
	Ein typisches Beispiel zur Verwendung von Schnappschüssen ist,
	den momentanen Stand des Dateisystems zu sichern,
	wenn eine riskante Aktion wie das Installieren von Software
	oder eine Systemaktualisierung durchgeführt wird.  Wenn diese
	Aktion fehlschlägt, so kann der Schnappschuss zurückgerollt
	werden und das System befindet sich wieder in dem gleichen
	Zustand, wie zu dem, als der Schnappschuss erstellt wurde.
	Wenn die Aktualisierung jedoch erfolgreich war, kann der
	Schnappschuss gelöscht werden, um Speicherplatz frei zu geben.
	Ohne Schnappschüsse, wird durch ein fehlgeschlagenes Update
	eine Wiederherstellung der Sicherung fällig, was oft mühsam
	und zeitaufwändig ist, außerdem ist währenddessen das System
	nicht verwendbar.  Schnappschüsse lassen sich schnell
	und mit wenig bis gar keiner Ausfallzeit zurückrollen, selbst
	wenn das System im normalen Betrieb läuft.  Die Zeitersparnis
	ist enorm, wenn mehrere Terabyte große Speichersysteme
	eingesetzt werden und viel Zeit für das Kopieren der Daten vom
	Sicherungssystem benötigt wird.  Schnappschüsse sind jedoch
	keine Ersatz für eine Vollsicherung des Pools, können jedoch
	als eine schnelle und einfache Sicherungsmethode verwendet
	werden, um eine Kopie eines Datasets zu einem bestimmten
	Zeitpunkt zu sichern.</para>

      <sect3 xml:id="zfs-zfs-snapshot-creation">
	<title>Schnappschüsse erstellen</title>

	<para>Schnappschüsse werden durch das Kommando
	  <command>zfs snapshot
	    <replaceable>dataset</replaceable>@<replaceable>snapshotname</replaceable></command>
	  angelegt.  Durch Angabe der Option <option>-r</option>
	  werden Schnappschüsse rekursive angelegt, mit dem gleichen
	  Namen auf allen Datasets.</para>

	<para>Einen rekursiven Schnappschuss des gesamten Pools
	  erzeugen:</para>

	<screen>&prompt.root; <userinput>zfs list -t all</userinput>
NAME                                   USED  AVAIL  REFER  MOUNTPOINT
mypool                                 780M  93.2G   144K  none
mypool/ROOT                            777M  93.2G   144K  none
mypool/ROOT/default                    777M  93.2G   777M  /
mypool/tmp                             176K  93.2G   176K  /tmp
mypool/usr                             616K  93.2G   144K  /usr
mypool/usr/home                        184K  93.2G   184K  /usr/home
mypool/usr/ports                       144K  93.2G   144K  /usr/ports
mypool/usr/src                         144K  93.2G   144K  /usr/src
mypool/var                            1.29M  93.2G   616K  /var
mypool/var/crash                       148K  93.2G   148K  /var/crash
mypool/var/log                         178K  93.2G   178K  /var/log
mypool/var/mail                        144K  93.2G   144K  /var/mail
mypool/var/newname                    87.5K  93.2G  87.5K  /var/newname
mypool/var/newname@new_snapshot_name      0      -  87.5K  -
mypool/var/tmp                         152K  93.2G   152K  /var/tmp
&prompt.root; <userinput>zfs snapshot -r <replaceable>mypool@my_recursive_snapshot</replaceable></userinput>
&prompt.root; <userinput>zfs list -t snapshot</userinput>
NAME                                        USED  AVAIL  REFER  MOUNTPOINT
mypool@my_recursive_snapshot                   0      -   144K  -
mypool/ROOT@my_recursive_snapshot              0      -   144K  -
mypool/ROOT/default@my_recursive_snapshot      0      -   777M  -
mypool/tmp@my_recursive_snapshot               0      -   176K  -
mypool/usr@my_recursive_snapshot               0      -   144K  -
mypool/usr/home@my_recursive_snapshot          0      -   184K  -
mypool/usr/ports@my_recursive_snapshot         0      -   144K  -
mypool/usr/src@my_recursive_snapshot           0      -   144K  -
mypool/var@my_recursive_snapshot               0      -   616K  -
mypool/var/crash@my_recursive_snapshot         0      -   148K  -
mypool/var/log@my_recursive_snapshot           0      -   178K  -
mypool/var/mail@my_recursive_snapshot          0      -   144K  -
mypool/var/newname@new_snapshot_name           0      -  87.5K  -
mypool/var/newname@my_recursive_snapshot       0      -  87.5K  -
mypool/var/tmp@my_recursive_snapshot           0      -   152K  -</screen>

	<para>Schnappschüsse werden nicht durch einen
	  <command>zfs list</command>-Befehl angezeigt.  Um
	  Schnappschüsse mit aufzulisten, muss
	  <option>-t snapshot</option> an das Kommando
	  <command>zfs list</command> angehängt werden.  Durch
	  <option>-t all</option> werden sowohl Dateisysteme als auch
	  Schnappschüsse nebeneinander angezeigt.</para>

	<para>Schnappschüsse werden nicht direkt eingehängt, deshalb
	  wird auch kein Pfad in der Spalte
	  <literal>MOUNTPOINT</literal> angezeigt.  Ebenso wird kein
	  freier Speicherplatz in der Spalte <literal>AVAIL</literal>
	  aufgelistet, da Schnappschüsse nicht mehr geschrieben werden
	  können, nachdem diese angelegt wurden.  Vergleichen Sie den
	  Schnappschuss mit dem ursprünglichen Dataset von dem es
	  abstammt:</para>

	<screen>&prompt.root; <userinput>zfs list -rt all <replaceable>mypool/usr/home</replaceable></userinput>
NAME                                    USED  AVAIL  REFER  MOUNTPOINT
mypool/usr/home                         184K  93.2G   184K  /usr/home
mypool/usr/home@my_recursive_snapshot      0      -   184K  -</screen>

	<para>Durch das Darstellen des Datasets und des
	  Schnappschusses nebeneinander zeigt deutlich, wie
	  Schnappschüsse in <link linkend="zfs-term-cow">COW</link>
	  Manier funktionieren.  Sie zeichnen nur die Änderungen
	  (<emphasis>delta</emphasis>) auf, die währenddessen
	  entstanden sind und nicht noch einmal den gesamten Inhalt
	  des Dateisystems.  Das bedeutet, dass Schnappschüsse nur
	  wenig Speicherplatz benötigen, wenn nur kleine Änderungen
	  vorgenommen werden.  Der Speicherverbrauch kann sogar noch
	  deutlicher gemacht werden, wenn eine Datei auf das Dataset
	  kopiert wird und anschließend ein zweiter Schnappschuss
	  angelegt wird:</para>

	<screen>&prompt.root; <userinput>cp <replaceable>/etc/passwd</replaceable> <replaceable>/var/tmp</replaceable></userinput>
&prompt.root; <userinput>zfs snapshot <replaceable>mypool/var/tmp</replaceable>@<replaceable>after_cp</replaceable></userinput>
&prompt.root; <userinput>zfs list -rt all <replaceable>mypool/var/tmp</replaceable></userinput>
NAME                                   USED  AVAIL  REFER  MOUNTPOINT
mypool/var/tmp                         206K  93.2G   118K  /var/tmp
mypool/var/tmp@my_recursive_snapshot    88K      -   152K  -
mypool/var/tmp@after_cp                   0      -   118K  -</screen>

	<para>Der zweite Schnappschuss enthält nur die Änderungen am
	  Dataset, die nach der Kopieraktion gemacht wurden.  Dies
	  bedeutet enorme Einsparungen von Speicherplatz.  Beachten
	  Sie, dass sich die Größe des Schnappschusses
	  <replaceable>mypool/var/tmp@my_recursive_snapshot</replaceable>
	  in der Spalte <literal>USED</literal> ebenfalls
	  geändert hat, um die Änderungen von sich selbst und dem
	  Schnappschuss, der im Anschluss angelegt wurde,
	  anzuzeigen.</para>
      </sect3>

      <sect3 xml:id="zfs-zfs-snapshot-diff">
	<title>Schnappschüsse vergleichen</title>

	<para>ZFS enthält ein eingebautes Kommando, um die
	  Unterschiede zwischen zwei Schnappschüssen miteinander zu
	  vergleichen.  Das ist hilfreich, wenn viele Schnappschüsse
	  über längere Zeit angelegt wurden und der Benutzer sehen
	  will, wie sich das Dateisystem über diesen Zeitraum
	  verändert hat.  Beispielsweise kann
	  <command>zfs diff</command> den letzten Schnappschuss
	  finden, der noch eine Datei enthält, die aus Versehen
	  gelöscht wurde.  Wenn dies für die letzten beiden
	  Schnappschüsse aus dem vorherigen Abschnitt durchgeführt
	  wird, ergibt sich folgende Ausgabe:</para>

	<screen>&prompt.root; <userinput>zfs list -rt all <replaceable>mypool/var/tmp</replaceable></userinput>
NAME                                   USED  AVAIL  REFER  MOUNTPOINT
mypool/var/tmp                         206K  93.2G   118K  /var/tmp
mypool/var/tmp@my_recursive_snapshot    88K      -   152K  -
mypool/var/tmp@after_cp                   0      -   118K  -
&prompt.root; <userinput>zfs diff <replaceable>mypool/var/tmp@my_recursive_snapshot</replaceable></userinput>
M       /var/tmp/
+       /var/tmp/passwd</screen>

	<para>Das Kommando zeigt alle Änderungen zwischen dem
	  angegebenen Schnappschuss (in diesem Fall
	  <literal><replaceable>mypool/var/tmp@my_recursive_snapshot</replaceable></literal>)
	  und dem momentan aktuellen Dateisystem.  Die erste Spalte
	  zeigt die Art der Änderung an:</para>

	<informaltable pgwide="1">
	  <tgroup cols="2">
	    <tbody valign="top">
	      <row>
		<entry>+</entry>
		<entry>Das Verzeichnis oder die Datei wurde
		  hinzugefügt.</entry>
	      </row>

	      <row>
		<entry>-</entry>
		<entry>Das Verzeichnis oder die Datei wurde
		  gelöscht.</entry>
	      </row>

	      <row>
		<entry>M</entry>
		<entry>Das Verzeichnis oder die Datei wurde
		  geändert.</entry>
	      </row>

	      <row>
		<entry>R</entry>
		<entry>Das Verzeichnis oder die Datei wurde
		  umbenannt.</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

	<para>Vergleicht man die Ausgabe mit der Tabelle, wird klar,
	  dass <filename><replaceable>passwd</replaceable></filename>
	  hinzugefügt wurde, nachdem der Schnappschuss
	  <literal><replaceable>mypool/var/tmp@my_recursive_snapshot</replaceable></literal>
	  erstellt wurde.  Das resultierte ebenfalls in einer Änderung
	  am darüberliegenden Verzeichnis, das unter
	  <literal><replaceable>/var/tmp</replaceable></literal>
	  eingehängt ist.</para>

	<para>Zwei Schnappschüsse zu vergleichen ist hilfreich, wenn
	  die Replikationseigenschaft von <acronym>ZFS</acronym>
	  verwendet wird, um ein Dataset auf einen anderen Host zu
	  Sicherungszwecken übertragen.</para>

	<para>Zwei Schnappschüsse durch die Angabe des kompletten
	  Namens des Datasets und dem Namen des Schnappschusses beider
	  Datasets vergleichen:</para>

	<screen>&prompt.root; <userinput>cp /var/tmp/passwd /var/tmp/passwd.copy</userinput>
&prompt.root; <userinput>zfs snapshot <replaceable>mypool/var/tmp@diff_snapshot</replaceable></userinput>
&prompt.root; <userinput>zfs diff <replaceable>mypool/var/tmp@my_recursive_snapshot</replaceable> <replaceable>mypool/var/tmp@diff_snapshot</replaceable></userinput>
M       /var/tmp/
+       /var/tmp/passwd
+       /var/tmp/passwd.copy
&prompt.root; <userinput>zfs diff <replaceable>mypool/var/tmp@my_recursive_snapshot</replaceable> <replaceable>mypool/var/tmp@after_cp</replaceable></userinput>
M       /var/tmp/
+       /var/tmp/passwd</screen>

	<para>Ein Administrator, der für die Sicherung zuständig ist,
	  kann zwei Schnappschüsse miteinander vergleichen, die vom
	  sendenden Host empfangen wurden, um festzustellen, welche
	  Änderungen am Dataset vorgenommen wurden.  Lesen Sie dazu
	  den Abschnitt <link
	  linkend="zfs-zfs-send">Replication</link> um weitere
	  Informationen zu erhalten.</para>
      </sect3>

      <sect3 xml:id="zfs-zfs-snapshot-rollback">
	<title>Schnappschüsse zurückrollen</title>

	<para>Wenn zumindest ein Schnappschuss vorhanden ist, kann
	  dieser zu einem beliebigen Zeitpunkt zurückgerollt werden.
	  In den meisten Fällen passiert dies, wenn der aktuelle
	  Zustand des Datasets nicht mehr benötigt wird und eine
	  ältere Version bevorzugt wird.  Szenarien wie lokale
	  Entwicklungstests, die fehlgeschlagen sind, defekte
	  Systemaktualisierungen, welche die Funktionalität des
	  Gesamtsystems einschränken oder die Anforderung,
	  versehentlich gelöschte Dateien oder Verzeichnisse
	  wiederherzustellen, sind allgegenwärtig.  Glücklicherweise
	  ist das zurückrollen eines Schnappschusses so leicht wie die
	  Eingabe von
	  <command>zfs rollback
	    <replaceable>snapshotname</replaceable></command>.
	  Abhängig davon, wie viele Änderungen betroffen sind, wird
	  diese Operation innerhalb einer gewissen Zeit abgeschlossen
	  sein.  Während dieser Zeit bleibt das Dataset in einem
	  konsistenten Zustand, sehr ähnlich den ACID-Prinzipien, die
	  eine Datenbank beim Zurückrollen entspricht.  Während all
	  dies passiert, ist das Dataset immer noch aktiv und
	  erreichbar ohne dass eine Ausfallzeit nötig wäre.  Sobald
	  der Schnappschuss zurückgerollt wurde, besitzt das Dataset
	  den gleichen Zustand, den es besaß, als der Schnappschuss
	  angelegt wurde.  Alle anderen Daten in diesem Dataset, die
	  nicht Teil des Schnappschusses sind, werden verworfen.
	  Einen Schnappschuss des aktuellen Zustandes des Datasets vor
	  dem Zurückrollen anzulegen ist eine gute Idee, wenn
	  hinterher noch Daten benötigt werden.  Auf diese Weise kann
	  der Benutzer vor und zurück zwischen den Schnappschüssen
	  springen, ohne wertvolle Daten zu verlieren.</para>

	<para>Im ersten Beispiel wird ein Schnappschuss aufgrund eines
	  unvorsichtigen <command>rm</command>-Befehls zurückgerollt,
	  der mehr Daten gelöscht hat, als vorgesehen.</para>

	<screen>&prompt.root; <userinput>zfs list -rt all <replaceable>mypool/var/tmp</replaceable></userinput>
NAME                                   USED  AVAIL  REFER  MOUNTPOINT
mypool/var/tmp                         262K  93.2G   120K  /var/tmp
mypool/var/tmp@my_recursive_snapshot    88K      -   152K  -
mypool/var/tmp@after_cp               53.5K      -   118K  -
mypool/var/tmp@diff_snapshot              0      -   120K  -
&prompt.root; <userinput>ls /var/tmp</userinput>
passwd          passwd.copy     vi.recover
&prompt.root; <userinput>rm /var/tmp/passwd*</userinput>
&prompt.root; <userinput>ls /var/tmp</userinput>
vi.recover
&prompt.root;</screen>

	<para>Zu diesem Zeitpunkt bemerkt der Benutzer, dass zuviele
	  Dateien gelöscht wurden und möchte diese zurück haben.
	  <acronym>ZFS</acronym> bietet eine einfache Möglichkeit,
	  diese durch zurückrollen zurück zu bekommen, allerdings nur,
	  wenn Schnappschüsse von wichtigen Daten regelmäßig angelegt
	  werden.  Um die Dateien zurückzuerhalten und vom letzten
	  Schnappschuss wieder zu beginnen, geben Sie ein:</para>

	<screen>&prompt.root; <userinput>zfs rollback <replaceable>mypool/var/tmp@diff_snapshot</replaceable></userinput>
&prompt.root; <userinput>ls /var/tmp</userinput>
passwd          passwd.copy     vi.recover</screen>

	<para>Die Operation zum Zurückrollen versetzt das Dataset in
	  den Zustand des letzten Schnappschusses zurück.  Es ist
	  ebenfalls möglich, zu einem Schnappschuss zurückzurollen,
	  der viel früher angelegt wurde und es noch Schnappschüsse
	  nach diesem gibt.  Wenn Sie dies versuchen, gibt
	  <acronym>ZFS</acronym> die folgende Warnung aus:</para>

	<screen>&prompt.root; <userinput>zfs list -rt snapshot <replaceable>mypool/var/tmp</replaceable></userinput>
AME                                   USED  AVAIL  REFER  MOUNTPOINT
mypool/var/tmp@my_recursive_snapshot    88K      -   152K  -
mypool/var/tmp@after_cp               53.5K      -   118K  -
mypool/var/tmp@diff_snapshot              0      -   120K  -
&prompt.root; <userinput>zfs rollback <replaceable>mypool/var/tmp@my_recursive_snapshot</replaceable></userinput>
cannot rollback to 'mypool/var/tmp@my_recursive_snapshot': more recent snapshots exist
use '-r' to force deletion of the following snapshots:
mypool/var/tmp@after_cp
mypool/var/tmp@diff_snapshot</screen>

	<para>Diese Warnung bedeutet, dass noch Schnappschüsse
	  zwischen dem momentanen Stand des Datasets und dem
	  Schnappschuss, zu dem der Benutzer zurückrollen möchte,
	  existieren.  Um das Zurückrollen durchzuführen, müssen die
	  Schnappschüsse gelöscht werden.  <acronym>ZFS</acronym> kann
	  nicht alle Änderungen zwischen verschiedenen Zuständen
	  eines Datasets verfolgen, da Schnappschüsse nur gelesen
	  werden können.  <acronym>ZFS</acronym> wird nicht die
	  betroffenen Schnappschüsse löschen, es sei denn, der
	  Benutzer verwendet die Option <option>-r</option>, um
	  anzugeben, dass dies die gewünschte Aktion ist.  Falls dies
	  der Fall ist und die Konsequenzen alle dazwischenliegenden
	  Schnappschüsse zu verlieren verstanden wurden, kann der
	  Befehl abgesetzt werden:</para>

	<screen>&prompt.root; <userinput>zfs rollback -r <replaceable>mypool/var/tmp@my_recursive_snapshot</replaceable></userinput>
&prompt.root; <userinput>zfs list -rt snapshot <replaceable>mypool/var/tmp</replaceable></userinput>
NAME                                   USED  AVAIL  REFER  MOUNTPOINT
mypool/var/tmp@my_recursive_snapshot     8K      -   152K  -
&prompt.root; <userinput>ls /var/tmp</userinput>
vi.recover</screen>

	<para>Die Ausgabe von <command>zfs list -t snapshot</command>
	  bestätigt, dass die dazwischenliegenden Schnappschüsse als
	  Ergebnis von <command>zfs rollback -r</command> entfernt
	  wurden.</para>
      </sect3>

      <sect3 xml:id="zfs-zfs-snapshot-snapdir">
	<title>Individuelle Dateien aus Schnappschüssen
	  wiederherstellen</title>

	<para>Schnappschüsse sind unter einem versteckten Verzeichnis
	  unter dem Eltern-Dataset eingehängt:
	  <filename>.zfs/snapshots/<replaceable>snapshotname</replaceable></filename>.
	  Standardmäßig werden diese Verzeichnisse nicht von einem
	  gewöhnlichen <command>ls -a</command> angezeigt.  Obwohl
	  diese Verzeichnisse nicht angezeigt werden, sind diese
	  trotzdem vorhanden und der Zugriff darauf erfolgt wie auf
	  jedes andere Verzeichnis.  Die Eigenschaft
	  <literal>snapdir</literal> steuert, ob diese Verzeichnisse
	  beim Auflisten eines Verzeichnisses angezeigt werden oder
	  nicht.  Das Einstellen der Eigenschaft auf den Wert
	  <literal>visible</literal> erlaubt es, diese in der Ausgabe
	  von <command>ls</command> und anderen Kommandos, die
	  mit Verzeichnisinhalten umgehen können, anzuzeigen.</para>

	<screen>&prompt.root; <userinput>zfs get snapdir <replaceable>mypool/var/tmp</replaceable></userinput>
NAME            PROPERTY  VALUE    SOURCE
mypool/var/tmp  snapdir   hidden   default
&prompt.root; <userinput>ls -a /var/tmp</userinput>
.               ..              passwd          vi.recover
&prompt.root; <userinput>zfs set snapdir=visible <replaceable>mypool/var/tmp</replaceable></userinput>
&prompt.root; <userinput>ls -a /var/tmp</userinput>
.               ..              .zfs            passwd          vi.recover</screen>

	<para>Einzelne Dateien lassen sich einfach auf einen
	  vorherigen Stand wiederherstellen, indem diese aus dem
	  Schnappschuss zurück in das Eltern-Dataset kopiert werden.
	  Die Verzeichnisstruktur unterhalb von
	  <filename>.zfs/snapshot</filename> enthält ein Verzeichnis,
	  das exakt wie der Schnappschuss benannt ist, der zuvor
	  angelegt wurde, um es einfacher zu machen, diese zu
	  identifizieren.  Im nächsten Beispiel wird angenommen, dass
	  eine Datei aus dem versteckten
	  <filename>.zfs</filename> Verzeichnis durch kopieren aus dem
	  Schnappschuss, der die letzte Version dieser Datei enthielt,
	  wiederhergestellt wird:</para>

	<screen>&prompt.root; <userinput>rm /var/tmp/passwd</userinput>
&prompt.root; <userinput>ls -a /var/tmp</userinput>
.               ..              .zfs            vi.recover
&prompt.root; <userinput>ls /var/tmp/.zfs/snapshot</userinput>
after_cp                my_recursive_snapshot
&prompt.root; <userinput>ls /var/tmp/.zfs/snapshot/<replaceable>after_cp</replaceable></userinput>
passwd          vi.recover
&prompt.root; <userinput>cp /var/tmp/.zfs/snapshot/<replaceable>after_cp/passwd</replaceable> <replaceable>/var/tmp</replaceable></userinput></screen>

	<para>Als <command>ls .zfs/snapshot</command> ausgeführt
	  wurde, war die <literal>snapdir</literal>-Eigenschaft
	  möglicherweise nicht auf hidden gesetzt, trotzdem ist es
	  immer noch möglich, den Inhalt dieses Verzeichnisses
	  aufzulisten.  Es liegt am Administrator zu entscheiden, ob
	  diese Verzeichnisse angezeigt werden soll.  Es ist möglich,
	  diese für bestimmte Datasets anzuzeigen und für andere zu
	  verstecken.  Das Kopieren von Dateien oder Verzeichnissen
	  aus diesem versteckten <filename>.zfs/snapshot</filename>
	  Verzeichnis ist einfach genug.  Jedoch führt der umgekehrte
	  Weg zu einem Fehler:</para>

	<screen>&prompt.root; <userinput>cp <replaceable>/etc/rc.conf</replaceable> /var/tmp/.zfs/snapshot/<replaceable>after_cp/</replaceable></userinput>
cp: /var/tmp/.zfs/snapshot/after_cp/rc.conf: Read-only file system</screen>

	<para>Der Fehler erinnert den Benutzer daran, dass
	  Schnappschüsse nur gelesen aber nicht mehr geändert werden
	  können, nachdem diese angelegt wurden.  Es können keine
	  Dateien in diese Schnappschuss-Verzeichnisse kopiert oder
	  daraus gelöscht werden, da dies sonst den Zustand des
	  Datasets verändern würde, den sie repräsentieren.</para>

	<para>Schnappschüsse verbrauchen Speicherplatz basierend auf
	  der Menge an Änderungen, die am Eltern-Dataset durchgeführt
	  wurden, seit der Zeit als der Schnappschuss erstellt wurde.
	  Die Eigenschaft <literal>written</literal> eines
	  Schnappschusses verfolgt, wieviel Speicherplatz vom
	  Schnappschuss belegt wird.</para>

	<para>Schnappschüsse werden zerstört und der belegte Platz
	  wieder freigegeben durch den Befehl
	  <command>zfs destroy
	    <replaceable>dataset</replaceable>@<replaceable>snapshot</replaceable></command>.
	  Durch hinzufügen von <option>-r</option> werden alle
	  Schnappschüsse rekursiv gelöscht, die den gleichen Namen wie
	  das Eltern-Dataset besitzen.  Mit der Option
	  <option>-n -v</option> wird eine Liste von Schnappschüssen,
	  die gelöscht werden würden, zusammen mit einer geschätzten
	  Menge an zurückgewonnenem Speicherplatz angezeigt, ohne die
	  eigentliche Zerstöroperation wirklich durchzuführen.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="zfs-zfs-clones">
      <title>Klone verwalten</title>

      <para>Ein Klon ist eine Kopie eines Schnappschusses, der mehr
	wie ein reguläres Dataset behandelt wird.  Im Gegensatz zu
	Schnappschüssen kann man von einem Klon nicht nur lesen, er
	ist eingehängt und kann seine eigenen Eigenschaften haben.
	Sobald ein Klon mittels <command>zfs clone</command> erstellt
	wurde, lässt sich der zugrundeliegende Schnappschuss nicht
	mehr zerstören.  Die Eltern-/Kindbeziehung zwischen dem Klon
	und dem Schnappschuss kann über
	<command>zfs promote</command> aufgelöst werden.  Nachdem ein
	Klon auf diese Weise befördert wurde, wird der Schnappschuss
	zum Kind des Klons, anstatt des ursprünglichen Datasets.  Dies
	wird die Art und Weise, wie der Speicherplatz berechnet wird,
	verändern, jedoch nicht den bereits belegten Speicher
	anpassen.  Der Klon kann an einem beliebigen Punkt innerhalb
	der <acronym>ZFS</acronym>-Dateisystemhierarchie eingehängt
	werden, nur nicht unterhalb der ursprünglichen Stelle des
	Schnappschusses.</para>

      <para>Um diese Klon-Funktionalität zu demonstrieren, wird dieses
	Beispiel-Dataset verwendet:</para>

      <screen>&prompt.root; <userinput>zfs list -rt all <replaceable>camino/home/joe</replaceable></userinput>
NAME                    USED  AVAIL  REFER  MOUNTPOINT
camino/home/joe         108K   1.3G    87K  /usr/home/joe
camino/home/joe@plans    21K      -  85.5K  -
camino/home/joe@backup    0K      -    87K  -</screen>

      <para>Ein typischer Einsatzzweck für Klone ist das
	experimentieren mit einem bestimmten Dataset, während der
	Schnappschuss beibehalten wird für den Fall, dass etwas
	schiefgeht.  Da Schnappschüsse nicht verändert werden können,
	wird ein Lese-/Schreibklon des Schnappschusses angelegt.
	Nachdem das gewünschte Ergebnis im Klon erreicht wurde, kann
	der Klon zu einem Dataset ernannt und das alte Dateisystem
	entfernt werden.  Streng genommen ist das nicht nötig, da der
	Klon und das Dataset ohne Probleme miteinander koexistieren
	können.</para>

      <screen>&prompt.root; <userinput>zfs clone <replaceable>camino/home/joe</replaceable>@<replaceable>backup</replaceable> <replaceable>camino/home/joenew</replaceable></userinput>
&prompt.root; <userinput>ls /usr/home/joe*</userinput>
/usr/home/joe:
backup.txz     plans.txt

/usr/home/joenew:
backup.txz     plans.txt
&prompt.root; <userinput>df -h /usr/home</userinput>
Filesystem          Size    Used   Avail Capacity  Mounted on
usr/home/joe        1.3G     31k    1.3G     0%    /usr/home/joe
usr/home/joenew     1.3G     31k    1.3G     0%    /usr/home/joenew</screen>

      <para>Nachdem ein Klon erstellt wurde, stellt er eine exakte
	Kopie des Datasets zu dem Zeitpunkt dar, als der Schnappschuss
	angelegt wurde.  Der Klon kann nun unabhängig vom
	ursprünglichen Dataset geändert werden.  Die einzige
	Verbindung zwischen den beiden ist der Schnappschuss.
	<acronym>ZFS</acronym> zeichnet diese Verbindung in der
	Eigenschaft namens <literal>origin</literal> auf.  Sobald die
	Abhängigkeit zwischen dem Schnappschuss und dem Klon durch das
	Befördern des Klons mittels <command>zfs promote</command>
	entfernt wurde, wird auch die
	<literal>origin</literal>-Eigenschaft des Klons entfernt, da
	es sich nun um ein eigenständiges Dataset handelt.  Dieses
	Beispiel demonstriert dies:</para>

      <screen>&prompt.root; <userinput>zfs get origin <replaceable>camino/home/joenew</replaceable></userinput>
NAME                  PROPERTY  VALUE                     SOURCE
camino/home/joenew    origin    camino/home/joe@backup    -
&prompt.root; <userinput>zfs promote <replaceable>camino/home/joenew</replaceable></userinput>
&prompt.root; <userinput>zfs get origin <replaceable>camino/home/joenew</replaceable></userinput>
NAME                  PROPERTY  VALUE   SOURCE
camino/home/joenew    origin    -       -</screen>

      <para>Nachdem ein paar Änderungen, wie beispielsweise das
	Kopieren von <filename>loader.conf</filename> auf den
	beförderten Klon vorgenommen wurden, wird das alte Verzeichnis
	in diesem Fall überflüssig.  Stattdessen kann der beförderte
	Klon diesen ersetzen.  Dies kann durch zwei
	aufeinanderfolgende Befehl geschehen: <command>zfs
	  destroy</command> auf dem alten Dataset und <command>zfs
	  rename</command> auf dem Klon, um diesen genauso wie das
	alte Dataset zu benennen (es kann auch einen ganz anderen
	Namen erhalten).</para>

      <screen>&prompt.root; <userinput>cp <replaceable>/boot/defaults/loader.conf</replaceable> <replaceable>/usr/home/joenew</replaceable></userinput>
&prompt.root; <userinput>zfs destroy -f <replaceable>camino/home/joe</replaceable></userinput>
&prompt.root; <userinput>zfs rename <replaceable>camino/home/joenew</replaceable> <replaceable>camino/home/joe</replaceable></userinput>
&prompt.root; <userinput>ls /usr/home/joe</userinput>
backup.txz     loader.conf     plans.txt
&prompt.root; <userinput>df -h <replaceable>/usr/home</replaceable></userinput>
Filesystem          Size    Used   Avail Capacity  Mounted on
usr/home/joe        1.3G    128k    1.3G     0%    /usr/home/joe</screen>

      <para>Der geklonte Schnappschuss wird jetzt wie ein
	gewöhnliches Dataset behandelt.  Es enthält alle Daten aus dem
	ursprünglichen Schnappschuss inklusive der Dateien, die
	anschließend hinzugefügt wurden, wie
	<filename>loader.conf</filename>.  Klone können in
	unterschiedlichen Szenarien eingesetzt werden, um nützliche
	Eigenschaften für ZFS-Anwender zur Verfügung zu stellen.
	Zum Beispiel können Jails als Schnappschüsse bereitgestellt
	werden, die verschiedene Arten von installierten Anwendungen
	anbieten.  Anwender können diese Schnappschüsse klonen und
	ihre eigenen Anwendungen nach Belieben hinzufügen.  Sobald
	sie mit den Änderungen zufrieden sind, können die Klone zu
	vollständigen Datasets ernannt werden und dem Anwender zur
	Verfügung gestellt werden, als würde es sich um echte
	Datasets handeln.  Das spart Zeit und Administrationsaufwand,
	wenn diese Jails auf diese Weise zur Verfügung gestellt
	werden.</para>
    </sect2>

    <sect2 xml:id="zfs-zfs-send">
      <title>Replikation</title>

      <para>Daten auf einem einzigen Pool an einem Platz
	aufzubewahren, setzt diese dem Risiko aus, gestohlen oder
	Opfer von Naturgewalten zu werden, sowie menschlichem
	Versagen auszusetzen.   Regelmäßige Sicherungen des gesamten
	Pools ist daher unerlässlich.  <acronym>ZFS</acronym> bietet
	eine Reihe von eingebauten Serialisierungsfunktionen an, die
	in der Lage ist, eine Repräsentation der Daten als Datenstrom
	auf die Standardausgabe zu schreiben.  Mit dieser Methode ist
	es nicht nur möglich, die Daten auf einen anderen Pool zu
	schicken, der an das lokale System angeschlossen ist, sondern
	ihn auch über ein Netzwerk an ein anderes System zu senden.
	Schnappschüsse stellen dafür die Replikationsbasis bereit
	(lesen Sie dazu den Abschnitt zu <link
	linkend="zfs-zfs-snapshot"><acronym>ZFS</acronym>
	  snapshots</link>).  Die Befehle, die für die Replikation
	verwendet werden, sind <command>zfs send</command> und
	<command>zfs receive</command>.</para>

      <para>Diese Beispiele demonstrieren die Replikation von
	<acronym>ZFS</acronym> anhand dieser beiden Pools:</para>

      <screen>&prompt.root; <userinput>zpool list</userinput>
NAME    SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG   CAP  DEDUP  HEALTH  ALTROOT
backup  960M    77K   896M         -         -     0%    0%  1.00x  ONLINE  -
mypool  984M  43.7M   940M         -         -     0%    4%  1.00x  ONLINE  -</screen>

      <para>Der Pool namens <replaceable>mypool</replaceable> ist der
	primäre Pool, auf den regelmäßig Daten geschrieben und auch
	wieder gelesen werden.  Ein zweiter Pool, genannt
	<replaceable>backup</replaceable> wird verwendet, um als
	Reserve zu dienen im Falle, dass der primäre Pool nicht zur
	Verfügung steht.  Beachten Sie, dass diese Ausfallsicherung
	nicht automatisch von <acronym>ZFS</acronym> durchgeführt
	wird, sondern manuell von einem Systemadministrator bei Bedarf
	eingerichtet werden muss.  Ein Schnappschuss wird verwendet,
	um einen konsistenten Zustand des Dateisystems, das repliziert
	werden soll, zu erzeugen.  Sobald ein Schnappschuss von
	<replaceable>mypool</replaceable> angelegt wurde, kann er auf
	den <replaceable>backup</replaceable>-Pool abgelegt werden.
	Nur Schnappschüsse lassen sich auf diese Weise replizieren.
	Änderungen, die seit dem letzten Schnappschuss entstanden
	sind, werden nicht mit repliziert.</para>

      <screen>&prompt.root; <userinput>zfs snapshot <replaceable>mypool</replaceable>@<replaceable>backup1</replaceable></userinput>
&prompt.root; <userinput>zfs list -t snapshot</userinput>
NAME                    USED  AVAIL  REFER  MOUNTPOINT
mypool@backup1             0      -  43.6M  -</screen>

      <para>Da nun ein Schnappschuss existiert, kann mit
	<command>zfs send</command> ein Datenstrom, der den Inhalt des
	Schnappschusses repräsentiert, erstellt werden.  Dieser
	Datenstrom kann als Datei gespeichert oder von einem
	anderen Pool empfangen werden.  Der Datenstrom wird auf die
	Standardausgabe geschrieben, muss jedoch in eine Datei oder
	in eine Pipe umgeleitet werden, sonst wird ein Fehler
	produziert:</para>

      <screen>&prompt.root; <userinput>zfs send <replaceable>mypool</replaceable>@<replaceable>backup1</replaceable></userinput>
Error: Stream can not be written to a terminal.
You must redirect standard output.</screen>

      <para>Um ein Dataset mit <command>zfs send</command> zu
	replizieren, leiten Sie dieses in eine Datei auf dem
	eingehängten Backup-Pool um.  Stellen Sie sicher, dass der
	Pool genug freien Speicherplatz besitzt, um die Größe des
	gesendeten Schnappschusses aufzunehmen.  Das beinhaltet alle
	Daten im Schnappschuss, nicht nur die Änderungen zum
	vorherigen Schnappschuss.</para>

      <screen>&prompt.root; <userinput>zfs send <replaceable>mypool</replaceable>@<replaceable>backup1</replaceable> > <replaceable>/backup/backup1</replaceable></userinput>
&prompt.root; <userinput>zpool list</userinput>
NAME    SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG    CAP  DEDUP  HEALTH  ALTROOT
backup  960M  63.7M   896M         -         -     0%     6%  1.00x  ONLINE  -
mypool  984M  43.7M   940M         -         -     0%     4%  1.00x  ONLINE  -</screen>

      <para>Das Kommando <command>zfs send</command> transferierte
	alle Daten im <replaceable>backup1</replaceable>-Schnappschuss
	auf den Pool namens <replaceable>backup</replaceable>.
	Erstellen und senden eines Schnappschusses kann automatisch
	von &man.cron.8; durchgeführt werden.</para>

      <para>Anstatt die Sicherungen als Archivdateien zu speichern,
	kann <acronym>ZFS</acronym> diese auch als aktives Dateisystem
	empfangen, was es erlaubt, direkt auf die gesicherten Daten
	zuzugreifen.  Um an die eigentlichen Daten in diesem Strom zu
	gelangen, wird <command>zfs receive</command> benutzt, um den
	Strom wieder in Dateien und Verzeichnisse umzuwandeln.  Das
	Beispiel unten kombiniert <command>zfs send</command> und
	<command>zfs receive</command> durch eine Pipe, um die Daten
	von einem Pool auf den anderen zu kopieren.  Die Daten können
	direkt auf dem empfangenden Pool verwendet werden, nachdem der
	Transfer abgeschlossen ist.  Ein Dataset kann nur auf ein
	leeres Dataset repliziert werden.</para>

      <screen>&prompt.root; <userinput>zfs snapshot <replaceable>mypool</replaceable>@<replaceable>replica1</replaceable></userinput>
&prompt.root; <userinput>zfs send -v <replaceable>mypool</replaceable>@<replaceable>replica1</replaceable> | zfs receive <replaceable>backup/mypool</replaceable></userinput>
send from @ to mypool@replica1 estimated size is 50.1M
total estimated size is 50.1M
TIME        SENT   SNAPSHOT

&prompt.root; <userinput>zpool list</userinput>
NAME    SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG    CAP  DEDUP  HEALTH  ALTROOT
backup  960M  63.7M   896M         -         -     0%     6%  1.00x  ONLINE  -
mypool  984M  43.7M   940M         -         -     0%     4%  1.00x  ONLINE  -</screen>

      <sect3 xml:id="zfs-send-incremental">
	<title>Inkrementelle Sicherungen</title>

	<para>Die Unterschiede zwischen zwei Schnappschüssen kann
	  <command>zfs send</command> ebenfalls erkennen und nur diese
	  übertragen.  Dies spart Speicherplatz und Übertragungszeit.
	  Beispielsweise:</para>

	<screen>&prompt.root; <userinput>zfs snapshot <replaceable>mypool</replaceable>@<replaceable>replica2</replaceable></userinput>
&prompt.root; <userinput>zfs list -t snapshot</userinput>
NAME                    USED  AVAIL  REFER  MOUNTPOINT
mypool@replica1         5.72M      -  43.6M  -
mypool@replica2             0      -  44.1M  -
&prompt.root; <userinput>zpool list</userinput>
NAME    SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG   CAP  DEDUP  HEALTH  ALTROOT
backup  960M  61.7M   898M         -         -     0%    6%  1.00x  ONLINE  -
mypool  960M  50.2M   910M         -         -     0%    5%  1.00x  ONLINE  -</screen>

	<para>Ein zweiter Schnappschuss genannt
	  <replaceable>replica2</replaceable> wurde angelegt.  Dieser
	  zweite Schnappschuss enthält nur die Änderungen, die
	  zwischen dem jetzigen Stand des Dateisystems und dem
	  vorherigen Schnappschuss,
	  <replaceable>replica1</replaceable>, vorgenommen wurden.
	  Durch <command>zfs send -i</command> und die Angabe des
	  Schnappschusspaares wird ein inkrementeller
	  Replikationsstrom erzeugt, welcher nur die Daten enthält,
	  die sich geändert haben.  Das kann nur erfolgreich sein,
	  wenn der initiale Schnappschuss bereits auf der
	  Empfängerseite vorhanden ist.</para>

	<screen>&prompt.root; <userinput>zfs send -v -i <replaceable>mypool</replaceable>@<replaceable>replica1</replaceable> <replaceable>mypool</replaceable>@<replaceable>replica2</replaceable> | zfs receive <replaceable>/backup/mypool</replaceable></userinput>
send from @replica1 to mypool@replica2 estimated size is 5.02M
total estimated size is 5.02M
TIME        SENT   SNAPSHOT

&prompt.root; <userinput>zpool list</userinput>
NAME    SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG    CAP  DEDUP  HEALTH  ALTROOT
backup  960M  80.8M   879M         -         -     0%     8%  1.00x  ONLINE  -
mypool  960M  50.2M   910M         -         -     0%     5%  1.00x  ONLINE  -

&prompt.root; <userinput>zfs list</userinput>
NAME                         USED  AVAIL  REFER  MOUNTPOINT
backup                      55.4M   240G   152K  /backup
backup/mypool               55.3M   240G  55.2M  /backup/mypool
mypool                      55.6M  11.6G  55.0M  /mypool

&prompt.root; <userinput>zfs list -t snapshot</userinput>
NAME                                         USED  AVAIL  REFER  MOUNTPOINT
backup/mypool@replica1                       104K      -  50.2M  -
backup/mypool@replica2                          0      -  55.2M  -
mypool@replica1                             29.9K      -  50.0M  -
mypool@replica2                                 0      -  55.0M  -</screen>

	<para>Der inkrementelle Datenstrom wurde erfolgreich
	  übertragen.  Nur die Daten, die verändert wurden, sind
	  übertragen worden, anstatt das komplette
	  <replaceable>replica1</replaceable>.  Nur die Unterschiede
	  wurden gesendet, was weniger Zeit und Speicherplatz in
	  Anspruch genommen hat, statt jedesmal den gesamten Pool zu
	  kopieren.  Das ist hilfreich wenn langsame Netzwerke oder
	  Kosten für die übertragene Menge Bytes in Erwägung gezogen
	  werden müssen.</para>

	<para>Ein neues Dateisystem,
	  <replaceable>backup/mypool</replaceable>, ist mit allen
	  Dateien und Daten vom Pool
	  <replaceable>mypool</replaceable> verfügbar.  Wenn die
	  Option <option>-P</option> angegeben wird, werden die
	  Eigenschaften des Datasets kopiert, einschließlich der
	  Komprimierungseinstellungen, Quotas und Einhängepunkte.
	  Wird die Option <option>-R</option> verwendet, so werden
	  alle Kind-Datasets des angegebenen Datasets kopiert,
	  zusammen mit ihren Eigenschaften.  Senden und Empfangen kann
	  automatisiert werden, so dass regelmäßig Sicherungen auf
	  dem zweiten Pool angelegt werden.</para>
      </sect3>

      <sect3 xml:id="zfs-send-ssh">
	<title>Sicherungen verschlüsselt über
	  <application>SSH</application> senden</title>

	<para>Datenströme über das Netzwerk zu schicken ist eine gute
	  Methode, um Sicherungen außerhalb des Systems anzulegen.
	  Jedoch ist dies auch mit einem Nachteil verbunden.  Daten,
	  die über die Leitung verschickt werden, sind nicht
	  verschlüsselt, was es jedem erlaubt, die Daten abzufangen
	  und die Ströme wieder zurück in Daten umzuwandeln, ohne dass
	  der sendende Benutzer davon etwas merkt.  Dies ist eine
	  unerwünschte Situation, besonders wenn die Datenströme über
	  das Internet auf ein entferntes System gesendet werden.
	  <application>SSH</application> kann benutzt werden, um
	  durch Verschlüsselung geschützte Daten über eine
	  Netzwerkverbindung zu übertragen.  Da <acronym>ZFS</acronym>
	  nur die Anforderung hat, dass der Strom von der
	  Standardausgabe umgeleitet wird, ist es relativ einfach,
	  diesen durch <application>SSH</application> zu leiten.  Um
	  den Inhalt des Dateisystems während der Übertragung und auf
	  dem entfernten System weiterhin verschlüsselt zu lassen,
	  denken Sie über den Einsatz von <link
	    xlink:href="https://wiki.freebsd.org/PEFS">PEFS</link>
	  nach.</para>

	<para>Ein paar Einstellungen und Sicherheitsvorkehrungen
	  müssen zuvor abgeschlossen sein.  Es werden hier nur die
	  nötigen Schritte für die <command>zfs send</command>-Aktion
	  gezeigt.  Weiterführende Informationen zu
	  <application>SSH</application>, gibt es im Kapitel
	  <xref linkend="openssh"/>.</para>

	<para>Die folgende Konfiguration wird benötigt:</para>

	<itemizedlist>
	  <listitem>
	    <para>Passwortloser <application>SSH</application>-Zugang
	      zwischen dem sendenden und dem empfangenden Host durch
	      den Einsatz von
	      <application>SSH</application>-Schlüsseln.</para>
	  </listitem>

	  <listitem>
	    <para>Normalerweise werden die Privilegien des <systemitem
		class="username">root</systemitem>-Benutzers
	      gebraucht, um Strom zu senden und zu empfangen.  Das
	      beinhaltet das Anmelden auf dem empfangenden System als
	      <systemitem class="username">root</systemitem>.
	      Allerdings ist das Anmelden als <systemitem
	      class="username">root</systemitem> aus
	      Sicherheitsgründen standardmäßig deaktiviert.  Mit
	      <link linkend="zfs-zfs-allow">ZFS Delegation</link>
	      lassen sich nicht-<systemitem
	      class="username">root</systemitem>-Benutzer auf jedem
	      System einrichten, welche die nötigen Rechte besitzen,
	      um die Sende- und Empfangsoperation
	      durchzuführen.</para>
	  </listitem>

	  <listitem>
	    <para>Auf dem sendenden System:</para>

	    <screen>&prompt.root; <userinput>zfs allow -u someuser send,snapshot <replaceable>mypool</replaceable></userinput></screen>
	  </listitem>

	  <listitem>
	    <para>Um den Pool einzuhängen, muss der unprivilegierte
	      Benutzer das Verzeichnis besitzen und gewöhnliche
	      Benutzern muss die Erlaubnis gegeben werden, das
	      Dateisystem einzuhängen.  Auf dem empfangenden System
	      nehmen Sie dazu die folgenden Einstellungen vor:</para>

	    <screen>&prompt.root; <userinput>sysctl vfs.usermount=1</userinput>
vfs.usermount: 0 -> 1
&prompt.root; <userinput>echo vfs.usermount=1 >> /etc/sysctl.conf</userinput>
&prompt.root; <userinput>zfs create <replaceable>recvpool/backup</replaceable></userinput>
&prompt.root; <userinput>zfs allow -u <replaceable>someuser</replaceable> create,mount,receive <replaceable>recvpool/backup</replaceable></userinput>
&prompt.root; <userinput>chown <replaceable>someuser</replaceable> <replaceable>/recvpool/backup</replaceable></userinput></screen>
	  </listitem>
	</itemizedlist>

	<para>Der unprivilegierte Benutzer hat jetzt die Fähigkeit,
	  Datasets zu empfangen und einzuhängen und das
	  <replaceable>home</replaceable>-Dataset auf das entfernte
	  System zu replizieren:</para>

	<screen>&prompt.user; <userinput>zfs snapshot -r <replaceable>mypool/home</replaceable>@<replaceable>monday</replaceable></userinput>
&prompt.user; <userinput>zfs send -R <replaceable>mypool/home</replaceable>@<replaceable>monday</replaceable> | ssh <replaceable>someuser@backuphost</replaceable> zfs recv -dvu <replaceable>recvpool/backup</replaceable></userinput></screen>

	<para>Ein rekursiver Schnappschuss namens
	  <replaceable>monday</replaceable> wird aus dem Dataset
	  <replaceable>home</replaceable> erstellt, dass auf dem Pool
	  <replaceable>mypool</replaceable> liegt.  Es wird dann mit
	  <command>zfs send -R</command> gesendet, um das Dataset,
	  alle seine Kinder, Schnappschüsse, Klone und Einstellungen
	  in den Strom mit aufzunehmen.  Die Ausgabe wird an das
	  wartende System <replaceable>backuphost</replaceable>
	  mittels <command>zfs receive</command> durch
	  <application>SSH</application> umgeleitet.  Die Verwendung
	  des Fully Qulified Domänennamens oder der IP-Adresse wird
	  empfohlen.  Die empfangende Maschine schreibt die Daten auf
	  das <replaceable>backup</replaceable>-Dataset im
	  <replaceable>recvpool</replaceable>-Pool.  Hinzufügen der
	  Option <option>-d</option> zu <command>zfs recv</command>
	  überschreibt den Namen des Pools auf der empfangenden Seite
	  mit dem Namen des Schnappschusses.  Durch Angabe von
	  <option>-u</option> wird das Dateisystem nicht auf der
	  Empfängerseite eingehängt.  Wenn <option>-v</option>
	  enthalten ist, werden mehr Details zum Transfer angezeigt
	  werden, einschließlich der vergangenen Zeit und der Menge
	  an übertragenen Daten.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="zfs-zfs-quota">
      <title>Dataset-, Benutzer- und Gruppenquotas</title>

      <para><link linkend="zfs-term-quota">Dataset-Quotas</link>
	werden eingesetzt, um den Speicherplatz einzuschränken, den
	ein bestimmtes Dataset verbrauchen kann.  <link
	  linkend="zfs-term-refquota">Referenz-Quotas</link>
	funktionieren auf eine ähnliche Weise, jedoch wird dabei der
	Speicherplatz des Datasets selbst gezählt, wobei
	Schnappschüsse und Kind-Datasets dabei ausgenommen sind.
	Ähnlich dazu werden <link
	  linkend="zfs-term-userquota">Benutzer</link>- und <link
	  linkend="zfs-term-groupquota">Gruppen</link>-Quotas
	dazu verwendet, um Benutzer oder Gruppen daran zu hindern, den
	gesamten Speicherplatz im Pool oder auf dem Dataset zu
	verbrauchen.</para>

      <para>Die folgenden Beispiele gehen davon aus, dass die Benutzer
	bereits im System vorhanden sind.  Bevor Sie einen Benutzer
	hinzufügen, stellen Sie sicher, dass Sie zuerst ein Dataset
	für das Heimatverzeichnis anlegen und den
	<option>mountpoint</option> auf
	<literal>/home/<replaceable>bob</replaceable></literal>
	festlegen.  Legen Sie dann den Benutzer an und stellen Sie
	sicher, dass das Heimatverzeichnis auf den auf den
	<option>mountpoint</option> des Datasets verweist.  Auf diese
	Weise werden die Eigentümer- und Gruppenberechtigungen richtig
	gesetzt, ohne dass bereits vorhandene Heimatverzeichnisse
	verschleiert werden.</para>

      <para>Um ein 10&nbsp;GB großes Quota auf dem Dataset
	<filename>storage/home/bob</filename> zu erzwingen, verwenden
	Sie folgenden Befehl:</para>

      <screen>&prompt.root; <userinput>zfs set quota=10G storage/home/bob</userinput></screen>

      <para>Um ein Referenzquota von 10&nbsp;GB für
	<filename>storage/home/bob</filename> festzulegen, geben Sie
	ein:</para>

      <screen>&prompt.root; <userinput>zfs set refquota=10G storage/home/bob</userinput></screen>

      <para>Um das Quota für <filename>storage/home/bob</filename>
	wieder zu entfernen:</para>

      <screen>&prompt.root; <userinput>zfs set quota=none storage/home/bob</userinput></screen>

      <para>Das generelle Format ist
	<literal>userquota@<replaceable>user</replaceable>=<replaceable>size</replaceable></literal>
	und der Name des Benutzers muss in einem der folgenden Formate
	vorliegen:</para>

      <itemizedlist>
	<listitem>
	  <para><acronym>POSIX</acronym>-kompatibler Name wie
	    <replaceable>joe</replaceable>.</para>
	</listitem>

	<listitem>
	  <para><acronym>POSIX</acronym>-numerische ID wie
	    <replaceable>789</replaceable>.</para>
	</listitem>

	<listitem>
	  <para><acronym>SID</acronym>-Name wie
	    <replaceable>joe.bloggs@example.com</replaceable>.</para>
	</listitem>

	<listitem>
	  <para><acronym>SID</acronym>-numerische ID wie
	    <replaceable>S-1-123-456-789</replaceable>.</para>
	</listitem>
      </itemizedlist>

      <para>Um beispielsweise ein Benutzerquota von 50&nbsp;GB für
	den Benutzer names <replaceable>joe</replaceable> zu
	erzwingen:</para>

      <screen>&prompt.root; <userinput>zfs set userquota@joe=50G</userinput></screen>

      <para>Um jegliche Quotas zu entfernen:</para>

      <screen>&prompt.root; <userinput>zfs set userquota@joe=none</userinput></screen>

      <note>
	<para>Benutzerquota-Eigenschaften werden nicht von
	  <command>zfs get all</command> dargestellt.
	  Nicht-<systemitem
	  class="username">root</systemitem>-Benutzer können nur ihre
	  eigenen Quotas sehen, ausser ihnen wurde das
	  <literal>userquota</literal>-Privileg zugeteilt.  Benutzer
	  mit diesem Privileg sind in der Lage, jedermanns Quota zu
	  sehen und zu verändern.</para>
      </note>

      <para>Das generelle Format zum Festlegen einer Gruppenquota
	lautet:
	<literal>groupquota@<replaceable>group</replaceable>=<replaceable>size</replaceable></literal>.</para>

      <para>Um ein Quota für die Gruppe
	<replaceable>firstgroup</replaceable> von 50&nbsp;GB zu
	setzen, geben Sie ein:</para>

      <screen>&prompt.root; <userinput>zfs set groupquota@firstgroup=50G</userinput></screen>

      <para>Um eine Quota für die Gruppe
	<replaceable>firstgroup</replaceable>zu setzen oder
	sicherzustellen, dass diese nicht gesetzt ist, verwenden Sie
	stattdessen:</para>

      <screen>&prompt.root; <userinput>zfs set groupquota@firstgroup=none</userinput></screen>

      <para>Genau wie mit der Gruppenquota-Eigenschaft, werden
	nicht-<systemitem class="username">root</systemitem>-Benutzer
	nur die Quotas sehen, die den Gruppen zugeordnet ist, in denen
	Sie Mitglied sind.  Allerdings ist <systemitem
	class="username">root</systemitem> oder ein Benutzer mit dem
	<literal>groupquota</literal>-Privileg in der Lage, die Quotas
	aller Gruppen zu sehen und festzusetzen.</para>

      <para>Um die Menge an Speicherplatz zusammen mit der Quota
	anzuzeigen, die von jedem Benutzer auf dem Dateisystem oder
	Schnappschuss verbraucht wird, verwenden Sie
	<command>zfs userspace</command>.  Für Gruppeninformationen,
	nutzen Sie <command>zfs groupspace</command>.  Für weitere
	Informationen zu unterstützten Optionen oder wie sich nur
	bestimmte Optionen anzeigen lassen, lesen Sie
	&man.zfs.1;.</para>

      <para>Benutzer mit ausreichenden Rechten sowie <systemitem
	  class="username">root</systemitem> können das Quota für
	<filename>storage/home/bob</filename> anzeigen lassen:</para>

      <screen>&prompt.root; <userinput>zfs get quota storage/home/bob</userinput></screen>
    </sect2>

    <sect2 xml:id="zfs-zfs-reservation">
      <title>Reservierungen</title>

      <para><link linkend="zfs-term-reservation">Reservierungen</link>
	garantieren ein Minimum an Speicherplatz, der immer auf dem
	Dataset verfügbar sein wird.  Der reservierte Platz wird nicht
	für andere Datasets zur Verfügung stehen.  Diese Eigenschaft
	kann besonders nützlich sein, um zu gewährleisten, dass freier
	Speicherplatz für ein wichtiges Dataset oder für Logdateien
	bereit steht.</para>

      <para>Das generelle Format der
	<literal>reservation</literal>-Eigenschaft ist
	<literal>reservation=<replaceable>size</replaceable></literal>.
	Um also eine Reservierung von 10&nbsp;GB auf
	<filename>storage/home/bob</filename> festzulegen, geben Sie
	Folgendes ein:</para>

      <screen>&prompt.root; <userinput>zfs set reservation=10G storage/home/bob</userinput></screen>

      <para>Um die Reservierung zu beseitigen:</para>

      <screen>&prompt.root; <userinput>zfs set reservation=none storage/home/bob</userinput></screen>

      <para>Das gleiche Prinzip kann auf die
	<literal>refreservation</literal>-Eigenschaft angewendet
	werden, um eine <link
	linkend="zfs-term-refreservation">Referenzreservierung</link>
	mit dem generellen Format
	<literal>refreservation=<replaceable>size</replaceable></literal>
	festzulegen.</para>

      <para>Dieser Befehl zeigt die Reservierungen oder
	Referenzreservierungen an, die auf
	<filename>storage/home/bob</filename> existieren:</para>

      <screen>&prompt.root; <userinput>zfs get reservation storage/home/bob</userinput>
&prompt.root; <userinput>zfs get refreservation storage/home/bob</userinput></screen>
    </sect2>

    <sect2 xml:id="zfs-zfs-compression">
      <title>Komprimierung</title>

      <para><acronym>ZFS</acronym> bietet transparente Komprimierung.
	Datenkomprimierung auf Blockebene während diese gerade
	geschrieben werden, spart nicht nur Plattenplatz ein, sondern
	kann auch den Durchsatz der Platte steigern.  Falls Daten zu
	25% komprimiert sind, jedoch die komprimierten Daten im
	gleichen Tempo wie ihre unkomprimierte Version, resultiert das
	in einer effektiven Schreibgeschwindigkeit von 125%.
	Komprimierung kann auch eine Alternative zu <link
	linkend="zfs-zfs-deduplication">Deduplizierung</link>
	darstellen, da es viel weniger zusätzlichen Hauptspeicher
	benötigt.</para>

      <para><acronym>ZFS</acronym> bietet mehrere verschiedene
	Kompressionsalgorithmen an, jede mit unterschiedlichen
	Kompromissen.  Mit der Einführung von
	<acronym>LZ4</acronym>-Komprimierung in <acronym>ZFS</acronym>
	v5000, ist es möglich, Komprimierung für den gesamten Pool zu
	aktivieren, ohne die großen Geschwindigkeitseinbußen der
	anderen Algorithmen.  Der größte Vorteil von
	<acronym>LZ4</acronym> ist die Eigenschaft <emphasis>früher
	Abbruch</emphasis>.  Wenn <acronym>LZ4</acronym> nicht
	mindestens 12,5% Komprimierung im ersten Teil der Daten
	erreicht, wird der Block unkomprimiert geschrieben, um die
	Verschwendung von CPU-Zyklen zu vermeiden, weil die Daten
	entweder bereits komprimiert sind oder sich nicht komprimieren
	lassen.  Für Details zu den verschiedenen verfügbaren
	Komprimierungsalgorithmen in <acronym>ZFS</acronym>, lesen Sie
	den Eintrag <link
	linkend="zfs-term-compression">Komprimierung</link> im
	Abschnitt Terminologie</para>

      <para>Der Administrator kann die Effektivität der Komprimierung
	über eine Reihe von Dataset-Eigenschaften überwachen.</para>

      <screen>&prompt.root; <userinput>zfs get used,compressratio,compression,logicalused <replaceable>mypool/compressed_dataset</replaceable></userinput>
NAME        PROPERTY          VALUE     SOURCE
mypool/compressed_dataset  used              449G      -
mypool/compressed_dataset  compressratio     1.11x     -
mypool/compressed_dataset  compression       lz4       local
mypool/compressed_dataset  logicalused       496G      -</screen>

      <para>Dieses Dataset verwendet gerade 449&nbsp;GB Plattenplatz
	(used-Eigenschaft.  Ohne Komprimierung würde es stattdessen
	496&nbsp;GB Plattenplatz belegen
	(<literal>logicalused</literal>).  Das ergibt eine
	Kompressionsrate von 1,11:1.</para>

      <para>Komprimierung kann einen unerwarteten Nebeneffekt haben,
	wenn diese mit <link
	  linkend="zfs-term-userquota">Benutzerquotas</link>
	kombiniert wird.  Benutzerquotas beschränken, wieviel
	Speicherplatz ein Benutzer auf einem Dataset verbrauchen kann.
	Jedoch basieren die Berechnungen darauf, wieviel Speicherplatz
	<emphasis>nach der Komprimierung</emphasis> belegt ist.  Wenn
	also ein Benutzer eine Quota von10&nbsp;GB besitzt und
	10&nbsp;GB von komprimierbaren Daten schreibt, wird dieser
	immer noch in der Lage sein, zusätzliche Daten zu speichern.
	Wenn später eine Datei aktualisiert wird, beispielsweise eine
	Datenbank, mit mehr oder weniger komprimierbaren Daten, wird
	sich die Menge an verfügbarem Speicherplatz ändern.  Das
	kann in einer merkwürdigen Situation resultieren, in welcher
	der Benutzer nicht die eigentliche Menge an Daten (die
	Eigenschaft <literal>logicalused</literal>) überschreitet,
	jedoch die Änderung in der Komprimierung dazu führt, dass das
	Quota-Limit erreicht ist.</para>

      <para>Kompression kann ebenso unerwartet mit Sicherungen
	interagieren.  Quotas werden oft verwendet, um einzuschränken,
	wieviele Daten gespeichert werden können um sicherzustellen,
	dass ausreichend Speicherplatz für die Sicherung vorhanden
	ist.  Wenn jedoch Quotas Komprimierung nicht berücksichtigen,
	werden womöglich mehr Daten geschrieben als in der
	unkomprimierten Sicherung Platz ist.</para>
    </sect2>

    <sect2 xml:id="zfs-zfs-deduplication">
      <title>Deduplizierung</title>

      <para>Wenn aktiviert, verwendet <link
	linkend="zfs-term-deduplication">Deduplizierung</link> die
	Prüfsumme jedes Blocks, um Duplikate dieses Blocks zu
	ermitteln.  Sollte ein neuer Block ein Duplikat eines
	existierenden Blocks sein, dann schreibt
	<acronym>ZFS</acronym> eine zusätzliche Referenz auf die
	existierenden Daten anstatt des kompletten duplizierten
	Blocks.  Gewaltige Speicherplatzeinsparungen sind möglich wenn
	die Daten viele Duplikate von Dateien oder wiederholte
	Informationen enthalten.  Seien Sie gewarnt: Deduplizierung
	benötigt eine extrem große Menge an Hauptspeicher und die
	meistens Einsparungen können stattdessen durch das Aktivieren
	von Komprimierung erreicht werden.</para>

      <para>Um Deduplizierung zu aktivieren, setzen Sie die
	<literal>dedup</literal>-Eigenschaft auf dem Zielpool:</para>

      <screen>&prompt.root; <userinput>zfs set dedup=on <replaceable>pool</replaceable></userinput></screen>

      <para>Nur neu auf den Pool geschriebene Daten werden
	dedupliziert.  Daten, die bereits auf den Pool geschrieben
	wurden, werden nicht durch das Aktivieren dieser Option
	dedupliziert.  Ein Pool mit einer gerade aktivierten
	Deduplizierung wird wie in diesem Beispiel aussehen:</para>

      <screen>&prompt.root; <userinput>zpool list</userinput>
NAME  SIZE ALLOC  FREE   CKPOINT  EXPANDSZ   FRAG   CAP DEDUP HEALTH ALTROOT
pool 2.84G 2.19M 2.83G         -         -     0%    0% 1.00x ONLINE -</screen>

      <para>Die Spalte <literal>DEDUP</literal> zeigt das aktuelle
	Verhältnis der Deduplizierung für diesen Pool an.  Ein Wert
	von <literal>1.00x</literal> zeigt an, dass die Daten noch
	nicht dedupliziert wurden.  Im nächsten Beispiel wird die
	Ports-Sammlung dreimal in verschiedene Verzeichnisse auf dem
	deduplizierten Pool kopiert.</para>

      <screen>&prompt.root; <userinput>for d in dir1 dir2 dir3; do</userinput>
> <userinput>mkdir $d &amp;&amp; cp -R /usr/ports $d &amp;</userinput>
> <userinput>done</userinput></screen>

      <para>Redundante Daten werden erkannt und dedupliziert:</para>

      <screen>&prompt.root; <userinput>zpool list</userinput>
NAME SIZE  ALLOC FREE CAP DEDUP HEALTH ALTROOT
pool 2.84G 20.9M 2.82G 0% 3.00x ONLINE -</screen>

      <para>Die <literal>DEDUP</literal>-Spalte zeigt einen Faktor von
	<literal>3.00x</literal>.  Mehrere Kopien der Ports-Sammlung
	wurden erkannt und dedupliziert, was nur ein Drittel des
	Speicherplatzes benötigt.  Das Potential für Einsparungen beim
	Speicherplatz ist enorm, wird jedoch damit erkauft, dass
	genügend Speicher zur Verfügung stehen muss, um die
	deduplizierten Blöcke zu verwalten.</para>

      <para>Deduplizierung ist nicht immer gewinnbringend, besonders
	wenn die Daten auf dem Pool nicht redundant sind.
	<acronym>ZFS</acronym> kann potentielle
	Speicherplatzeinsparungen durch Deduplizierung auf einem Pool
	simulieren:</para>

      <screen>&prompt.root; <userinput>zdb -S <replaceable>pool</replaceable></userinput>
Simulated DDT histogram:

bucket              allocated                       referenced
______   ______________________________   ______________________________
refcnt   blocks   LSIZE   PSIZE   DSIZE   blocks   LSIZE   PSIZE   DSIZE
------   ------   -----   -----   -----   ------   -----   -----   -----
     1    2.58M    289G    264G    264G    2.58M    289G    264G    264G
     2     206K   12.6G   10.4G   10.4G     430K   26.4G   21.6G   21.6G
     4    37.6K    692M    276M    276M     170K   3.04G   1.26G   1.26G
     8    2.18K   45.2M   19.4M   19.4M    20.0K    425M    176M    176M
    16      174   2.83M   1.20M   1.20M    3.33K   48.4M   20.4M   20.4M
    32       40   2.17M    222K    222K    1.70K   97.2M   9.91M   9.91M
    64        9     56K   10.5K   10.5K      865   4.96M    948K    948K
   128        2   9.50K      2K      2K      419   2.11M    438K    438K
   256        5   61.5K     12K     12K    1.90K   23.0M   4.47M   4.47M
    1K        2      1K      1K      1K    2.98K   1.49M   1.49M   1.49M
 Total    2.82M    303G    275G    275G    3.20M    319G    287G    287G

dedup = 1.05, compress = 1.11, copies = 1.00, dedup * compress / copies = 1.16</screen>

      <para>Nachdem <command>zdb -S</command> die Analyse des Pool
	abgeschlossen hat, zeigt es die Speicherplatzeinsparungen, die
	durch aktivierte Deduplizierung erreichbar sind, an.  In
	diesem Fall ist <literal>1.16</literal> ein sehr schlechter
	Faktor, der größtenteils von Einsparungen durch Komprimierung
	beeinflusst wird.  Aktivierung von Deduplizierung auf diesem
	Pool würde also keine signifikante Menge an Speicherplatz
	einsparen und ist daher nicht die Menge an Speicher wert, die
	nötig sind, um zu deduplizieren.  Über die Formel
	<emphasis>ratio = dedup * compress / copies</emphasis> kann
	ein Systemadministrator die Speicherplatzbelegung planen und
	entscheiden, ob es sich lohnt, den zusätzlichen Hauptspeicher
	für die Deduplizierung anhand des späteren Workloads
	aufzuwenden.  Wenn sich die Daten verhältnismäßig gut
	komprimieren lassen, sind die Speicherplatzeinsparungen sehr
	gut.  Es wird empfohlen, in dieser Situation zuerst die
	Komprimierung zu aktivieren, da diese auch erhöhte
	Geschwindigkeit mit sich bringt.  Aktivieren Sie
	Deduplizierung nur in solchen Fällen, bei denen die
	Einsparungen beträchtlich sind und genug Hauptspeicher zur
	Verfügung steht, um die <link
	  linkend="zfs-term-deduplication"><acronym>DDT</acronym></link>
	aufzunehmen.</para>
    </sect2>

    <sect2 xml:id="zfs-zfs-jail">
      <title><acronym>ZFS</acronym> und Jails</title>

      <para>Um ein <acronym>ZFS</acronym>-Dataset einem
	<link linkend="jails">Jail</link> zuzuweisen, wird der Befehl
	<command>zfs jail</command> und die dazugehörige Eigenschaft
	<literal>jailed</literal> verwendet.  Durch Angabe von
	<command>zfs jail <replaceable>jailid</replaceable></command>
	wird ein Dataset dem spezifizierten Jail zugewiesen und kann
	mit <command>zfs unjail</command> wieder abgehängt werden.
	Damit das Dataset innerhalb der Jail kontrolliert werden kann,
	muss die Eigenschaft <literal>jailed</literal> gesetzt sein.
	Sobald ein Dataset sich im Jail befindet, kann es nicht mehr
	länger auf dem Hostsystem eingehängt werden, da es
	Einhängepunkte aufweisen könnte, welche die Sicherheit des
	Systems gefährden.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="zfs-zfs-allow">
    <title>Delegierbare Administration</title>

    <para>Ein umfassendes System zur Berechtigungsübertragung erlaubt
	unprivilegierten Benutzern,
      <acronym>ZFS</acronym>-Administrationsaufgaben durchzuführen.
      Beispielsweise, wenn jedes Heimatverzeichnis eines Benutzers ein
      Dataset ist, können Benutzer das Recht darin erhalten,
      Schnappschüsse zu erstellen und zu zerstören.  Einem Benutzer
      für die Sicherung kann die Erlaubnis eingeräumt werden, die
      Replikationseigenschaft zu verwenden.  Einem Skript zum Sammeln
      von Speicherplatzverbrauch kann die Berechtigung gegeben werden,
      nur auf die Verbrauchsdaten aller Benutzer zuzugreifen.  Es ist
      sogar möglich, die Möglichkeit zum Delegieren zu delegieren.
      Die Berechtigung zur Delegation ist für jedes Unterkommando und
      die meisten Eigenschaften möglich.</para>

    <sect2 xml:id="zfs-zfs-allow-create">
      <title>Delegieren, ein Dataset zu erstellen</title>

      <para><command>zfs allow
	  <replaceable>someuser</replaceable> create
	  <replaceable>mydataset</replaceable></command> gibt dem
	angegebenen Benutzer die Berechtigung, Kind-Datasets unter dem
	ausgewählten Elterndataset anzulegen.  Es gibt einen Haken:
	ein neues Dataset anzulegen beinhaltet, dass es eingehängt
	wird.  Dies bedeutet, dass &os;s
	<literal>vfs.usermount</literal> &man.sysctl.8; auf
	<literal>1</literal> gesetzt wird, um nicht-root Benutzern zu
	erlauben, Dateisysteme einzubinden.  Es gibt eine weitere
	Einschränkung um Missbrauch zu verhindern:
	nicht-<systemitem class="username">root</systemitem>
	Benutzer müssen Besitzer des Einhängepunktes sein, an dem das
	Dateisystem eingebunden werden soll.</para>
    </sect2>

    <sect2 xml:id="zfs-zfs-allow-allow">
      <title>Delegationsberechtigung delegieren</title>

      <para><command>zfs allow
	  <replaceable>someuser</replaceable> allow
	  <replaceable>mydataset</replaceable></command> gibt dem
	angegebenen Benutzer die Fähigkeit, jede Berechtigung, die er
	selbst auf dem Dataset oder dessen Kindern besitzt, an andere
	Benutzer weiterzugeben.  Wenn ein Benutzer die
	<literal>snapshot</literal>- und die
	<literal>allow</literal>-Berechtigung besitzt, kann dieser
	dann die <literal>snapshot</literal>-Berechtigung an andere
	Benutzer delegieren.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="zfs-advanced">
    <title>Themen für Fortgeschrittene</title>

    <sect2 xml:id="zfs-advanced-tuning">
      <title>Anpassungen</title>

      <para>Eine Reihe von Anpassungen können vorgenommen werden, um
	<acronym>ZFS</acronym> unter verschiedenen Belastungen während
	des Betriebs bestmöglich einzustellen.</para>

      <itemizedlist>
	<listitem>
	  <para
	      xml:id="zfs-advanced-tuning-arc_max"><emphasis><varname>vfs.zfs.arc_max</varname></emphasis>
	    - Maximale Größe des <link
	      linkend="zfs-term-arc"><acronym>ARC</acronym></link>.
	    Die Voreinstellung ist der gesamte <acronym>RAM</acronym>
	    weniger 1&nbsp;GB oder 5/8 vom
	    <acronym>RAM</acronym>, je nachdem, was mehr ist.
	    Allerdings sollte ein niedriger Wert verwendet werden,
	    wenn das System weitere Dienste oder Prozesse laufen
	    lässt, welche Hauptspeicher benötigen.  Dieser Wert kann
	    zur Laufzeit mit &man.sysctl.8; eingestellt und in
	    <filename>/boot/loader.conf</filename> permanent
	    gespeichert werden.</para>
	</listitem>

	<listitem>
	  <para
	      xml:id="zfs-advanced-tuning-arc_meta_limit"><emphasis><varname>vfs.zfs.arc_meta_limit</varname></emphasis>
	    - Schränkt die Menge des <link
	      linkend="zfs-term-arc"><acronym>ARC</acronym></link>
	    ein, welche für die Speicherung von Metadaten verwendet
	    wird.  Die Voreinstellung ist ein Viertel von
	    <varname>vfs.zfs.arc_max</varname>.  Diesen Wert zu
	    erhöhen steigert die Geschwindigkeit, wenn die Arbeitslast
	    Operationen auf einer großen Menge an Dateien und
	    Verzeichnissen oder häufigen Metadatenoperationen
	    beinhaltet.  Jedoch bedeutet dies auch weniger Dateidaten,
	    die in den <link
	      linkend="zfs-term-arc"><acronym>ARC</acronym></link>
	    passen.  Dieser Wert kann zur Laufzeit mit
	    &man.sysctl.8; eingestellt und in
	    <filename>/boot/loader.conf</filename> oder
	    <filename>/etc/sysctl.conf</filename> dauerhaft
	    gespeichert werden.</para>
	</listitem>

	<listitem>
	  <para
	      xml:id="zfs-advanced-tuning-arc_min"><emphasis><varname>vfs.zfs.arc_min</varname></emphasis>
	    - Minimale Größe des <link
	      linkend="zfs-term-arc"><acronym>ARC</acronym></link>.
	    Der Standard beträgt die Hälfte von
	    <varname>vfs.zfs.arc_meta_limit</varname>.  Passen Sie
	    diesen Wert an, um zu verhindern, dass andere Anwendungen
	    den gesamten <link
	      linkend="zfs-term-arc"><acronym>ARC</acronym></link>
	    verdrängen.  Dieser Wert kann zur Laufzeit mit
	    &man.sysctl.8; geändert und in
	    <filename>/boot/loader.conf</filename> oder
	    <filename>/etc/sysctl.conf</filename> dauerhaft
	    gespeichert werden.</para>
	</listitem>

	<listitem>
	  <para
	      xml:id="zfs-advanced-tuning-vdev-cache-size"><emphasis><varname>vfs.zfs.vdev.cache.size</varname></emphasis>
	    - Eine vorallokierte Menge von Speicher, die als Cache für
	    jedes Gerät im Pool reserviert wird.  Die Gesamtgröße von
	    verwendetem Speicher ist dieser Wert multipliziert mit der
	    Anzahl an Geräten.  Nur zur Bootzeit kann dieser Wert
	    angepasst werden und wird in
	    <filename>/boot/loader.conf</filename> eingestellt.</para>
	</listitem>

	<listitem>
	  <para
	      xml:id="zfs-advanced-tuning-min-auto-ashift"><emphasis><varname>vfs.zfs.min_auto_ashift</varname></emphasis>
	    - Minimaler <varname>ashift</varname>-Wert (Sektorgröße),
	    welche zur Erstellungszeit des Pools automatisch verwendet
	    wird.  Der Wert ist ein Vielfaches zur Basis Zwei.  Der
	    Standardwert von <literal>9</literal> repräsentiert
	    <literal>2^9 = 512</literal>, eine Sektorgröße von 512
	    Bytes.  Um <emphasis>write amplification</emphasis> zu
	    vermeiden und die bestmögliche Geschwindigkeit zu
	    erhalten, setzen Sie diesen Wert auf die größte
	    Sektorgröße, die bei einem Gerät im Pool vorhanden
	    ist.</para>

	  <para>Viele Geräte besitzen 4&nbsp;KB große Sektoren.  Die
	    Verwendung der Voreinstellung <literal>9</literal> bei
	    <varname>ashift</varname> mit diesen Geräten resultiert in
	    einer write amplification auf diesen Geräten.  Daten,
	    welche in einem einzelnen 4&nbsp;KB Schreibvorgang Platz
	    finden würden, müssen stattdessen in acht 512-byte
	    Schreibvorgänge aufgeteilt werden.  <acronym>ZFS</acronym>
	    versucht, die allen Geräten zugrundeliegende Sektorgröße
	    während der Poolerstellung zu lesen, jedoch melden viele
	    Geräte mit 4&nbsp;KB Sektoren, dass ihre Sektoren aus
	    Kompatibilitätsgründen 512 Bytes betragen.  Durch das
	    Setzen von <varname>vfs.zfs.min_auto_ashift</varname> auf
	    <literal>12</literal> (<literal>2^12 = 4096</literal>)
	    bevor der Pool erstellt wird, zwingt
	    <acronym>ZFS</acronym> dazu, für diese Geräte 4&nbsp;KB
	    Blöcke für bessere Geschwindigkeit zu nutzen.</para>

	  <para>Erzwingen von 4&nbsp;KB Blöcken ist ebenfalls
	    hilfreich auf Pools bei denen Plattenaufrüstungen geplant
	    sind.  Zukünftige Platten werden wahrscheinlich
	    4&nbsp;KB große Sektoren und der Wert von
	    <varname>ashift</varname> lässt sich nach dem Erstellen
	    des Pools nicht mehr ändern.</para>

	  <para>In besonderen Fällen ist die kleinere Blockgröße von
	    512-Byte vorzuziehen.  Weniger Daten werden bei kleinen,
	    zufälligen Leseoperationen übertragen, was besonders bei
	    512-Byte großen Platten für Datenbanken oder Plattenplatz
	    für virtuelle Maschinen der Fall ist.  Dies kann bessere
	    Geschwindigkeit bringen, ganz besonders wenn eine kleinere
	    <acronym>ZFS</acronym> record size verwendet wird.</para>
	</listitem>

	<listitem>
	  <para
	      xml:id="zfs-advanced-tuning-prefetch_disable"><emphasis><varname>vfs.zfs.prefetch_disable</varname></emphasis>
	    - Prefetch deaktivieren.  Ein Wert von <literal>0</literal>
	    bedeutet aktiviert und <literal>1</literal> heißt
	    deaktiviert.  Die Voreinstellung ist <literal>0</literal>,
	    außer, das System besitzt weniger als
	    4&nbsp;GB <acronym>RAM</acronym>.  Prefetch funktioniert
	    durch das Lesen von grösseren Blöcken in den <link
	    linkend="zfs-term-arc"><acronym>ARC</acronym></link> als
	    angefordert wurden, in der Hoffnung, dass diese Daten
	    ebenfalls bald benötigt werden.  Wenn die I/O-Last viele
	    große Mengen von zufälligen Leseoperationen beinhaltet,
	    ist das Deaktivieren von prefetch eine
	    Geschwindigkeitssteigerung durch die Reduzierung von
	    unnötigen Leseoperationen.  Dieser Wert kann zu jeder Zeit
	    über &man.sysctl.8; angepasst werden.</para>
	</listitem>

	<listitem>
	  <para
	      xml:id="zfs-advanced-tuning-vdev-trim_on_init"><emphasis><varname>vfs.zfs.vdev.trim_on_init</varname></emphasis>
	    - Steuert, ob neue Geräte, die dem Pool hinzugefügt
	    werden, das <literal>TRIM</literal>-Kommando ausführen
	    sollen.  Das beinhaltet die beste Geschwindigkeit und
	    Langlebigkeit für <acronym>SSD</acronym>s, benötigt jedoch
	    zusätzliche Zeit.  Wenn das Gerät bereits sicher gelöscht
	    wurde, kann durch deaktivieren dieser Option das
	    Hinzufügen neuer Geräte schneller geschehen.  Über
	    &man.sysctl.8; lässt sich dieser Wert jederzeit
	    einstellen.</para>
	</listitem>

	<listitem>
	  <para
	      xml:id="zfs-advanced-tuning-vdev-max_pending"><emphasis><varname>vfs.zfs.vdev.max_pending</varname></emphasis>
	    - Begrenzt die Menge von ausstehenden I/O-Anfragen pro
	    Gerät.  Ein größerer Wert wird die Gerätewarteschlange
	    für Befehle gefüllt lassen und möglicherweise besseren
	    Durchsatz erzeugen.  Ein niedrigerer Wert reduziert die
	    Latenz.  Jederzeit kann dieser Wert über &man.sysctl.8;
	    angepasst werden.</para>
	</listitem>

	<listitem>
	  <para
	      xml:id="zfs-advanced-tuning-top_maxinflight"><emphasis><varname>vfs.zfs.top_maxinflight</varname></emphasis>
	    - Maximale Anzahl von ausstehenden I/Os pro
	    darüberliegendem <link
	      linkend="zfs-term-vdev">vdev</link>.  Begrenzt die Tiefe
	    Kommandowarteschlange, um hohe Latenzen zu vermeiden.  Das
	    Limit ist pro darüberliegendem vdev, was bedeutet, dass
	    das Limit für jeden <link
	    linkend="zfs-term-vdev-mirror">mirror</link>, <link
	    linkend="zfs-term-vdev-raidz">RAID-Z</link>, oder anderes
	    vdev unabhängig gilt.  Mit &man.sysctl.8; kann dieser Wert
	    jederzeit angepasst werden.</para>
	</listitem>

	<listitem>
	  <para
	      xml:id="zfs-advanced-tuning-l2arc_write_max"><emphasis><varname>vfs.zfs.l2arc_write_max</varname></emphasis>
	    - Begrenzt die Menge an Daten, die pro Sekunde in den <link
	      linkend="zfs-term-l2arc"><acronym>L2ARC</acronym></link>
	    geschrieben wird.  Durch diese Einstellung lässt sich die
	    Lebensdauer von <acronym>SSD</acronym>s erhöhen, indem die
	    Menge an Daten beschränkt wird, die auf das Gerät
	    geschrieben wird.  Dieser Wert ist über &man.sysctl.8; zu
	    einem beliebigen Zeitpunkt änderbar.</para>
	</listitem>

	<listitem>
	  <para
	      xml:id="zfs-advanced-tuning-l2arc_write_boost"><emphasis><varname>vfs.zfs.l2arc_write_boost</varname></emphasis>
	    - Der Wert dieser Einstellung wird zu <link
	      linkend="zfs-advanced-tuning-l2arc_write_max"><varname>vfs.zfs.l2arc_write_max</varname></link>
	    addiert und erhöht die Schreibgeschwindigkeit auf die
	    <acronym>SSD</acronym> bis der erste Block aus dem <link
	      linkend="zfs-term-l2arc"><acronym>L2ARC</acronym></link>
	    verdrängt wurde.  Diese <quote>Turbo Warmup Phase</quote>
	    wurde entwickelt, um den Geschwindigkeitsverlust eines
	    leeren <link
	      linkend="zfs-term-l2arc"><acronym>L2ARC</acronym></link>
	    nach einem Neustart zu reduzieren.  Jederzeit kann dieser
	    Wert mit &man.sysctl.8; geändert werden.</para>
	</listitem>

	<listitem>
	  <para
	      xml:id="zfs-advanced-tuning-scrub_delay"><emphasis><varname>vfs.zfs.scrub_delay</varname></emphasis>
	    - Anzahl von Ticks an Verzögerung zwischen jedem I/O
	    während eines <link
	      linkend="zfs-term-scrub"><command>scrub</command></link>.
	    Um zu gewährleisten, dass ein <command>scrub</command>
	    nicht mit die normalen Vorgänge eines Pools
	    beeinträchtigt.  Wenn währenddessen andere
	    <acronym>I/O</acronym>s durchgeführt werden, wird der
	    <command>scrub</command> zwischen jedem Befehl verzögert.
	    Dieser Wert regelt die Gesamtmenge von
	    <acronym>IOPS</acronym> (I/Os Per Second), die von
	    <command>scrub</command> generiert werden.  Die
	    Granularität der Einstellung ist bestimmt durch den Wert
	    von <varname>kern.hz</varname>, welcher standardmäßig auf
	    auf 1000 Ticks pro Sekunde eingestellt ist.  Diese
	    Einstellung kann geändert werden, was in einer
	    unterschiedlich effektiven Limitierung der
	    <acronym>IOPS</acronym> resultiert.  Der Standardwert ist
	    <literal>4</literal>, was ein Limit von
	    1000&nbsp;ticks/sec / 4 =
	    250&nbsp;<acronym>IOPS</acronym> ergibt.  Ein Wert von
	    <replaceable>20</replaceable> würde ein Limit von
	    1000&nbsp;ticks/sec / 20 =
	    50&nbsp;<acronym>IOPS</acronym> ergeben.  Die
	    <command>scrub</command>-Geschwindigkeit ist nur begrenzt,
	    wenn es kürzlich Aktivität auf dem Pool gab, wie der Wert
	    von <link
	      linkend="zfs-advanced-tuning-scan_idle"><varname>vfs.zfs.scan_idle</varname></link>
	    verrät.  Zu einem beliebigen Zeitpunkt kann über
	    &man.sysctl.8; eine Änderung an diesem Wert
	    erfolgen.</para>
	</listitem>

	<listitem>
	  <para
	      xml:id="zfs-advanced-tuning-resilver_delay"><emphasis><varname>vfs.zfs.resilver_delay</varname></emphasis>
	    - Anzahl an Millisekunden Verzögerung, die zwischen jedem
	    I/O während eines <link
	    linkend="zfs-term-resilver">resilver</link> eingefügt
	    wird.  Um zu versichern, dass ein resilver nicht die
	    normalen Vorgänge auf dem Pool stört, wird dieser zwischen
	    jedem Kommando verzögert, wenn andere I/Os auf dem Pool
	    passieren.  Dieser Wert steuert das Limit der
	    Gesamt-<acronym>IOPS</acronym> (I/Os Pro Sekunde), die vom
	    resilver erzeugt werden.  Die Granularität der Einstellung
	    wird durch den Wert von <varname>kern.hz</varname>
	    bestimmt, welcher standardmäßig 1000 Ticks pro Sekunde
	    beträgt.  Diese Einstellung lässt sich ändern, was in
	    einem unterschiedlich effizienten
	    <acronym>IOPS</acronym>-Limit resultiert.  Die
	    Voreinstellung ist 2, was ein Limit von
	    1000&nbsp;ticks/sec / 2 =
	    500&nbsp;<acronym>IOPS</acronym> beträgt.  Einen Pool
	    wieder in den Zustand <link
	    linkend="zfs-term-online">Online</link> zu versetzen ist
	    möglicherweise wichtiger wenn eine andere Platte den Pool
	    in den <link
	    linkend="zfs-term-faulted">Fault</link>-Zustand versetzt,
	    was Datenverlust zur Folge hat.  Ein Wert von 0 wird der
	    resilver-Operation die gleiche Priorität wie anderen
	    Operationen geben, was den Heilungsprozess beschleunigt.
	    Die Geschwindigkeit des resilver wird nur begrenzt, wenn
	    es kürzlich andere Aktivitäten auf dem Pool gab, wie von
	    <link
	      linkend="zfs-advanced-tuning-scan_idle"><varname>vfs.zfs.scan_idle</varname></link>
	    festgestellt wird.  Dieser Wert kann zu jeder Zeit über.
	    &man.sysctl.8; eingestellt werden.</para>
	</listitem>

	<listitem>
	  <para
	      xml:id="zfs-advanced-tuning-scan_idle"><emphasis><varname>vfs.zfs.scan_idle</varname></emphasis>
	    - Anzahl an Millisekunden seit der letzten Operation bevor
	    der Pool als im Leerlauf befindlich deklariert wird.  Wenn
	    sich der Pool im Leerlauf befindet, wird die Begrenzung
	    für <link
	      linkend="zfs-term-scrub"><command>scrub</command></link>
	    und
	    <link linkend="zfs-term-resilver">resilver</link>
	    deaktiviert.  Dieser Wert kann mittels &man.sysctl.8;
	    jederzeit angepasst werden.</para>
	</listitem>

	<listitem>
	  <para
	      xml:id="zfs-advanced-tuning-txg-timeout"><emphasis><varname>vfs.zfs.txg.timeout</varname></emphasis>
	    - Maximale Anzahl von Sekunden zwischen
	    <link linkend="zfs-term-txg">Transaktionsgruppen</link>
	    (transaction group).  Die momentane Transaktionsgruppe
	    wird auf den Pool geschrieben und eine frische
	    Transaktionsgruppe begonnen, wenn diese Menge an Zeit seit
	    der vorherigen Transaktionsgruppe abgelaufen ist.  Eine
	    Transaktionsgruppe kann verfrüht ausgelöst werden, wenn
	    genug Daten geschrieben werden.  Der Standardwert beträgt
	    5 Sekunden.  Ein größerer Wert kann die
	    Lesegeschwindigkeit durch verzögern von asynchronen
	    Schreibvorgängen verbessern, allerdings kann dies
	    ungleiche Geschwindigkeiten hervorrufen, wenn eine
	    Transaktionsgruppe geschrieben wird.  Dieser Wert kann zu
	    einem beliebigen Zeitpunkt mit &man.sysctl.8; geändert
	    werden.</para>
	</listitem>
      </itemizedlist>
    </sect2>

<!-- These sections will be added in the future
    <sect2 xml:id="zfs-advanced-booting">
      <title>Booting Root on <acronym>ZFS</acronym></title>

      <para></para>
    </sect2>

    <sect2 xml:id="zfs-advanced-beadm">
      <title><acronym>ZFS</acronym> Boot Environments</title>

      <para></para>
    </sect2>

    <sect2 xml:id="zfs-advanced-troubleshoot">
      <title>Troubleshooting</title>

      <para></para>
    </sect2>
-->

    <sect2 xml:id="zfs-advanced-i386">
      <title><acronym>ZFS</acronym> auf i386</title>

      <para>Manche der Eigenschaften, die von <acronym>ZFS</acronym>
	bereitgestellt werden, sind speicherintensiv und benötigen
	Anpassungen für die maximale Effizienz auf Systemen mit
	begrenztem <acronym>RAM</acronym>.</para>

      <sect3>
	<title>Hauptspeicher</title>

	<para>Als absolutes Minimum sollte der gesamte verfügbare
	  Hauptspeicher mindestens ein Gigabyte betragen.  Die
	  vorgeschlagene Menge an <acronym>RAM</acronym> ist bedingt
	  durch die Poolgröße und welche Eigenschaften von
	  <acronym>ZFS</acronym> verwendet werden.  Eine Faustregel
	  besagt, dass 1&nbsp;GB RAM für jedes 1&nbsp;TB Storage
	  vorgesehen werden sollte.  Wenn Deduplizierung zum Einsatz
	  kommt, besagt die Regel, dass 5&nbsp;GB RAM pro TB an
	  Speicher, der dedupliziert werden soll, bereitgestellt sein
	  muss.  Obwohl manche Anwender <acronym>ZFS</acronym> mit
	  weniger <acronym>RAM</acronym> einsetzen, stürzen Systeme
	  häufiger wegen unzureichendem Hauptspeicher ab.  Weitere
	  Anpassungen sind unter Umständen nötig für Systeme mit
	  weniger als die vorgeschlagene Menge an RAM.</para>
      </sect3>

      <sect3>
	<title>Kernel-Konfiguration</title>

	<para>Wegen des begrenzten Addressraumes der &i386;-Plattform
	  müssen <acronym>ZFS</acronym>-Anwendern auf der
	  &i386;-Architektur diese Option der
	  Kernelkonfigurationsdatei hinzufügen, den Kernel erneut
	  bauen und das System neu starten:</para>

	<programlisting>options        KVA_PAGES=512</programlisting>

	<para>Dies erweitert den Addressraum des Kernels, was es
	  erlaubt, die Einstellung <varname>vm.kvm_size</varname>
	  hinter die momentan vorgegebene Grenze von 1&nbsp;GB
	  oder das Limit von 2&nbsp;GB für
	  <acronym>PAE</acronym> zu bringen.  Um den passenden Wert
	  für diese Option zu finden, teilen Sie den gewünschten
	  Addressraum in Megabyte durch vier.  In diesem Beispiel
	  beträgt sie <literal>512</literal> für 2&nbsp;GB.</para>
      </sect3>

      <sect3>
	<title>Loader-Anpassungen</title>

	<para>Der <filename>kmem</filename>-Addressraum kann auf allen
	  &os;-Architekturen erhöht werden.  Auf einem Testsystem mit
	  1&nbsp;GB physischen Speichers wurden mit diesen Optionen in
	  <filename>/boot/loader.conf</filename> und einem
	  anschließenden Systemneustart Erfolge erzielt:</para>

	<programlisting>vm.kmem_size="330M"
vm.kmem_size_max="330M"
vfs.zfs.arc_max="40M"
vfs.zfs.vdev.cache.size="5M"</programlisting>

	<para>Für eine detailliertere Liste an Empfehlungen für
	  <acronym>ZFS</acronym>-bezogene Einstellungen, lesen Sie <link
	    xlink:href="https://wiki.freebsd.org/ZFSTuningGuide"></link>.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="zfs-links">
    <title>Zusätzliche Informationen</title>

    <itemizedlist>
      <listitem>
	<para><link
	    xlink:href="http://open-zfs.org">OpenZFS</link></para>
      </listitem>

      <listitem>
	<para><link
	    xlink:href="https://wiki.freebsd.org/ZFSTuningGuide">FreeBSD
	    Wiki - <acronym>ZFS</acronym> Tuning</link></para>
      </listitem>

      <listitem>
	<para><link
	    xlink:href="http://docs.oracle.com/cd/E19253-01/819-5461/index.html">Oracle
	    Solaris <acronym>ZFS</acronym> Administration
	    Guide</link></para>
      </listitem>

      <listitem>
	<para><link
	    xlink:href="https://calomel.org/zfs_raid_speed_capacity.html">Calomel
	    Blog - <acronym>ZFS</acronym> Raidz Performance, Capacity
	    und Integrity</link></para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 xml:id="zfs-term">
    <title><acronym>ZFS</acronym>-Eigenschaften und
      Terminologie</title>

    <para><acronym>ZFS</acronym> ist ein fundamental anderes
      Dateisystem aufgrund der Tatsache, dass es mehr als ein
      Dateisystem ist.  <acronym>ZFS</acronym> kombiniert die Rolle
      eines Dateisystems mit dem Volumemanager, was es ermöglicht,
      zusätzliche Speichermedien zu einem laufenden System
      hinzuzufügen und diesen neuen Speicher sofort auf allen auf dem
      Pool existierenden Dateisystemen zur Verfügung zu haben.  Durch
      die Kombination von traditionell getrennten Rollen ist
      <acronym>ZFS</acronym> in der Lage, Einschränkungen, die zuvor
      <acronym>RAID</acronym>-Gruppen daran gehindert hatten, zu
      wachsen.  Jedes Gerät auf höchster Ebene in einem Pool wird ein
      <emphasis>vdev</emphasis> genannt, was eine einfache Platte oder
      eine <acronym>RAID</acronym>-Transformation wie ein Spiegel oder
      <acronym>RAID-Z</acronym>-Verbund sein kann.
      <acronym>ZFS</acronym>-Dateisysteme
      (<emphasis>datasets</emphasis> genannt), haben jeweils Zugriff
      auf den gesamten freien Speicherplatz des gesamten Pools.  Wenn
      Blöcke aus diesem Pool allokiert werden, verringert sich auch
      der freie Speicherplatz für jedes Dateisystem.  Dieser Ansatz
      verhindert die allgegenwärtige Falle von umfangreichen
      Partitionen, bei denen freier Speicherplatz über alle
      Partitionen hinweg fragmentiert wird.</para>

    <informaltable pgwide="1">
      <tgroup cols="2">
	<tbody valign="top">
	  <row>
	    <entry xml:id="zfs-term-pool">zpool</entry>

	    <entry>Ein Speicher-<emphasis>Pool</emphasis> ist der
	      grundlegendste Baustein von <acronym>ZFS</acronym>.  Ein
	      Pool besteht aus einem oder mehreren vdevs, was die
	      zugrundeliegenden Geräte repräsentiert, welche die Daten
	      speichern.  Ein Pool wird dann verwendet, um ein oder
	      mehrere Dateisysteme (Datasets) oder Blockgeräte
	      (Volumes) zu erstellen.  Diese Datasets und Volumes
	      teilen sich den im Pool verfügbaren Speicherplatz.
	      Jeder Pool wird eindeutig durch einen Namen und eine
	      <acronym>GUID</acronym> identifiziert.  Die verfügbaren
	      Eigenschaften werden durch die
	      <acronym>ZFS</acronym>-Versionsnummer des Pools
	      bestimmt.</entry>
	  </row>

	  <row>
	    <entry xml:id="zfs-term-vdev">vdev&nbsp;Arten</entry>

	    <entry>Ein Pool besteht aus einem oder mehreren vdevs, die
	      selbst eine einfache Platte oder im Fall von
	      <acronym>RAID</acronym> eine Gruppe von Platten
	      darstellt.  Wenn mehrere vdevs eingesetzt werden,
	      verteilt <acronym>ZFS</acronym> die Daten über die
	      vdevs, um die Geschwindigkeit zu steigern und den
	      verfügbaren Platz zu maximieren.

	      <itemizedlist>
		<listitem>
		  <para
		      xml:id="zfs-term-vdev-disk"><emphasis>Festplatte</emphasis>
		    - Der einfachste Typ von vdev ist ein
		    Standard-Blockgerät.  Dies kann die komplette
		    Platte (wie
		    <filename><replaceable>/dev/ada0</replaceable></filename>
		    oder
		    <filename><replaceable>/dev/da0</replaceable></filename>)
		    oder auch eine Partition
		    (<filename><replaceable>/dev/ada0p3</replaceable></filename>)
		    sein.
		    Auf &os; gibt es keine Geschwindigkeitseinbußen
		    bei der Verwendung einer Partition anstatt einer
		    kompletten Platte.  Dies unterscheidet sich von
		    den Empfehlungen, welche in der Solaris
		    Dokumentation gegeben werden.</para>

		  <caution>
		    <para>Es wird dringend davon abgeraten, eine ganze
		      Platte für einen bootbaren Pool zu benutzen, da
		      dies dazu führen kann, dass der Pool nicht mehr
		      bootet.  Ebenso sollten Sie nicht eine ganze
		      Platte als Teil eines Spiegels oder
		      <acronym>RAID-Z</acronym> vdev verwenden, weil
		      es dann nicht mehr möglich ist, die Größe einer
		      nicht partitionierten Platte beim Booten
		      zuverlässig zu bestimmen.  Zudem gibt es dann
		      keinen Platz mehr, um Boot-Code
		      einzufügen.</para>
		  </caution>
		</listitem>

		<listitem>
		  <para
		      xml:id="zfs-term-vdev-file"><emphasis>File</emphasis>
		    - Zusätzlich zu Festplatten können
		    <acronym>ZFS</acronym>-Pools aus regulären Dateien
		    aufgebaut sein, was besonders hilfreich ist, um zu
		    testen und zu experimentieren.  Verwenden Sie den
		    kompletten Pfad zu der Datei als Gerätepfad im
		    Befehl <command>zpool create</command>.  Alle
		    vdevs müssen mindestens 128&nbsp;MB groß
		    sein.</para>
		</listitem>

		<listitem>
		  <para
		      xml:id="zfs-term-vdev-mirror"><emphasis>Mirror</emphasis>
		    - Wenn ein Spiegel erstellt wird, verwenden Sie
		    das Schlüsselwort <literal>mirror</literal>,
		    gefolgt von der Liste an Mitgliedsgeräten für den
		    Spiegel.  Ein Spiegel besteht aus zwei oder mehr
		    Geräten und sämtliche Daten werden auf alle
		    Geräte, die Mitglied des Spiegels sind,
		    geschrieben.  Ein Spiegel-vdev wird nur soviele
		    Daten speichern, wie das kleinste Gerät im Verbund aufnehmen
		    kann.  Ein Spiegel-vdev kann den Verlust von allen
		    Mitgliedsgeräten bis auf eines verkraften, ohne
		    irgendwelche Daten zu verlieren.</para>

		  <note>
		    <para>Ein reguläre einzelne vdev-Platte kann
		      jederzeit zu einem Spiegel-vdev über das
		      Kommando <command>zpool <link
			linkend="zfs-zpool-attach">attach</link></command>
		      aktualisiert werden.</para>
		  </note>
		</listitem>

		<listitem>
		  <para
		      xml:id="zfs-term-vdev-raidz"><emphasis><acronym>RAID-Z</acronym></emphasis>
		    - <acronym>ZFS</acronym> implementiert
		    <acronym>RAID-Z</acronym>, eine Varianten des
		    <acronym>RAID-5</acronym>-Standards, der bessere
		    Verteilung der Parität bietet und das
		    <quote><acronym>RAID-5</acronym> write
		    hole</quote> eliminiert, bei dem die Daten und
		    Parität nach einem unerwarteten Neustart
		    inkonsistent werden können.
		    <acronym>ZFS</acronym> unterstützt drei Stufen von
		    <acronym>RAID-Z</acronym>, die unterschiedliche
		    Arten von Redundanz im Austausch gegen niedrigere
		    Stufen von verwendbarem Speicher.
		    Diese Typen werden <acronym>RAID-Z1</acronym>
		    bis <acronym>RAID-Z3</acronym> genannt, basierend
		    auf der Anzahl der Paritätsgeräte im Verbund und
		    der Anzahl an Platten, die ausfallen können,
		    während der Pool immer noch normal
		    funktioniert.</para>

		  <para>In einer
		    <acronym>RAID-Z1</acronym>-Konfiguration mit
		    vier Platten, bei der jede 1&nbsp;TB besitzt,
		    beträgt der verwendbare Plattenplatz 3&nbsp;TB und
		    der Pool wird immer noch im Modus degraded
		    weiterlaufen, wenn eine Platte davon ausfällt.
		    Wenn eine zusätzliche Platte ausfällt, bevor die
		    defekte Platte ersetzt wird, können alle Daten im
		    Pool verloren gehen.</para>

		  <para>Eine Konfiguration von acht Platten zu je
		    1&nbsp;TB als <acronym>RAID-Z3</acronym> wird
		    5&nbsp;TB verwendbaren Speicher bieten und in der
		    Lage sein, weiterhin zu funktionieren, wenn drei
		    Platten ausgefallen sind.  &sun; empfiehlt nicht
		    mehr als neun Platten in einem einzelnen vdev.
		    Wenn die Konfiguration mehr Platten aufweist, wird
		    empfohlen, diese in getrennten vdevs aufzuteilen,
		    so dass die Daten des Pools zwischen diesen
		    aufgeteilt werden.</para>

		  <para>Eine Konfiguration von zwei
		    <acronym>RAID-Z2</acronym>-vdevs, bestehend aus
		    jeweils 8 Platten würde etwa einem
		    <acronym>RAID-60</acronym>-Verbund entsprechen.
		    Der Speicherplatz einer
		    <acronym>RAID-Z</acronym>-Gruppe ist ungefähr die
		    Größe der kleinsten Platte multipliziert mit der
		    Anzahl von nicht-Paritätsplatten.  Vier 1&nbsp;TB
		    Platten in einem <acronym>RAID-Z1</acronym>
		    besitzt eine effektive Größe von ungefähr
		    3&nbsp;TB und ein Verbund von acht
		    1&nbsp;TB-Platten als <acronym>RAID-Z3</acronym>
		    enthält 5&nbsp;TB verfügbarer Plattenplatz.</para>
		</listitem>

		<listitem>
		  <para
		      xml:id="zfs-term-vdev-spare"><emphasis>Spare</emphasis>
		    - <acronym>ZFS</acronym> besitzt einen speziellen
		    Pseudo-vdev Typ, um einen Überblick über die
		    verfügbaren hot spares zu behalten.  Beachten Sie,
		    dass hot spares nicht automatisch eingesetzt
		    werden.  Diese müssen manuell konfiguriert werden,
		    um ein ausgefallenes Gerät über <command>zfs
		      replace</command> zu ersetzen.</para>
		</listitem>

		<listitem>
		  <para
		      xml:id="zfs-term-vdev-log"><emphasis>Log</emphasis>
		    - <acronym>ZFS</acronym> Log-Geräte, auch
		    bezeichnet als ein <acronym>ZFS</acronym> Intent
		    Log (<link
		      linkend="zfs-term-zil"><acronym>ZIL</acronym></link>)
		    verschieben das Intent Log von den regulären
		    Geräten im Pool auf ein dediziertes Gerät,
		    typischerweise eine <acronym>SSD</acronym>.  Ein
		    dediziertes Log-Gerät zu besitzen kann die
		    Geschwindigkeit von Anwendungen mit einer großen
		    Anzahl von synchronen Schreibvorgängen, besonders
		    Datenbanken, signifikant steigern.  Log-Geräte
		    können gespiegelt werden, jedoch wird
		    <acronym>RAID-Z</acronym> nicht unterstützt.
		    Werden mehrere Log-Geräte verwendet, so werden
		    Schreibvorgänge gleichmäßig unter diesen
		    aufgeteilt.</para>
		</listitem>

		<listitem>
		  <para
		      xml:id="zfs-term-vdev-cache"><emphasis>Cache</emphasis>
		    - Ein Cache-vdev einem Pool hinzuzufügen, erhöht
		    den Speicher des <link
		      linkend="zfs-term-l2arc"><acronym>L2ARC</acronym></link>
		    Caches.  Cache-Geräte lassen sich nicht spiegeln.
		    Da ein Cache-Gerät nur zusätzliche Kopien von
		    existierenden Daten speichert, gibt es kein
		    Risiko, Daten zu verlieren.</para>
		</listitem>
	      </itemizedlist></entry>
	  </row>

	  <row>
	    <entry xml:id="zfs-term-txg">Transaktionsgruppe
	      (Transaction Group, <acronym>TXG</acronym>)</entry>

	    <entry>Transaktionsgruppen sind die Art und Weise, wie
	      geänderte Blöcke zusammen gruppiert und letztendlich auf
	      den Pool geschrieben werden.  Transaktionsgruppen sind
	      die atomare Einheit, welche <acronym>ZFS</acronym>
	      verwendet, um Konsistenz zu gewährleisten.  Jeder
	      Transaktionsgruppe wird eine einzigartige, fortlaufende
	      64-Bit Identifikationsnummer zugewiesen.  Es kann bis zu
	      drei aktive Transaktionsgruppen gleichzeitig geben,
	      wobei sich jede davon in einem der folgenden drei
	      Zustände befinden kann:

	      <itemizedlist>
		<listitem>
		  <para><emphasis>Open (Offen)</emphasis> - Wenn eine neue
		    Transaktionsgruppe erstellt wird, befindet diese
		    sich im Zustand offen und akzeptiert neue
		    Schreibvorgänge.  Es ist immer eine
		    Transaktionsgruppe in diesem Zustand, jedoch kann
		    die Transaktionsgruppe neue Schreibvorgänge
		    ablehnen, wenn diese ein Limit erreicht hat.
		    Sobald eine offene Transaktionsgruppe an das Limit
		    stößt oder das <link
		      linkend="zfs-advanced-tuning-txg-timeout"><varname>vfs.zfs.txg.timeout</varname></link>
		    wurde erreicht, geht die Transaktionsgruppe in den
		    nächsten Zustand über.</para>
		</listitem>

		<listitem>
		  <para><emphasis>Quiescing (Stilllegen)</emphasis> -
		    Ein kurzer Zustand, der es noch ausstehenden
		    Operationen erlaubt, zum Abschluss zu kommen,
		    währenddessen das Erstellen einer neuen
		    Transaktionsgruppe jedoch nicht blockiert wird.
		    Sobald alle Transaktionen in der Gruppe
		    abgeschlossen sind, geht die Transaktionsgruppen
		    in den letzten Zustand über.</para>
		</listitem>

		<listitem>
		  <para><emphasis>Syncing (Sychronisieren)</emphasis>
		    - Alle Daten in der Transaktionsgruppe werden auf
		    das Speichermedium geschrieben.  Dieser Prozess
		    wird wiederum andere Daten wie Metadaten und space
		    maps verändern, die ebenfalls auf das
		    Speichermedium geschrieben werden müssen.  Der
		    Prozess des Synchronisierens beinhaltet mehrere
		    Durchläufe.  Der erste Prozess, welches der
		    größte, gefolgt von den Metadaten, ist,
		    beinhaltet alle geänderten Datenblöcke und kann
		    mehrere Durchläufe benötigen, um zum Ende zu
		    gelangen.  Da das Allokieren von Speicher für die
		    Datenblöcke neue Metadaten generiert, kann der
		    Synchronisationsprozess nicht beendet werden, bis
		    ein Durchlauf fertig ist, der keinen zusätzlichen
		    Speicher allokiert.  Der Synchronisierungszustand
		    ist der Zustand, in dem auch
		    <emphasis>synctasks</emphasis> abgeschlossen
		    werden.  Synctasks sind administrative
		    Operationen, wie das Erstellen oder zerstören von
		    Schnappschüssen und Datasets, welche den Überblock
		    verändern, wenn sie abgeschlossen sind.  Sobald
		    der Synchronisationszustand abgeschlossen ist,
		    geht die Transaktionsgruppe aus dem
		    Stilllegungszustand über in den
		    Synchronisationszustand.</para>
		</listitem>
	      </itemizedlist>

	      Alle administrativen Funktionen, wie <link
		linkend="zfs-term-snapshot"><command>Schnappschüsse</command></link>
	      werden als Teil einer Transaktionsgruppe geschrieben.
	      Wenn ein synctask erstellt ist, wird dieser der momentan
	      geöffneten Transaktionsgruppe hinzugefügt und diese
	      Gruppe wird so schnell wie möglich in den
	      Synchronisationszustand versetzt, um die Latenz von
	      administrativen Befehlen zu reduzieren.</entry>
	  </row>

	  <row>
	    <entry xml:id="zfs-term-arc">Adaptive Replacement
	      Cache (<acronym>ARC</acronym>)</entry>

	    <entry><acronym>ZFS</acronym> verwendet einen Adaptive
	      Replacement Cache (<acronym>ARC</acronym>), anstatt
	      eines traditionellen Least Recently Used
	      (<acronym>LRU</acronym>) Caches.  Ein
	      <acronym>LRU</acronym>-Cache ist eine einfache Liste von
	      Elementen im Cache, sortiert nach der letzten Verwendung
	      jedes Elements in der Liste.  Neue Elemente werden an
	      den Anfang der Liste eingefügt.  Wenn der Cache voll
	      ist, werden Elemente vom Ende der Liste verdrängt, um
	      Platz für aktivere Objekte zu schaffen.  Ein
	      <acronym>ARC</acronym> besteht aus vier Listen:
	      derjenigen der Most Recently Used
	      (<acronym>MRU</acronym>) und Most Frequently Used
	      (<acronym>MFU</acronym>) Objekte, plus einer sogenannten
	      ghost list für jede von beiden.  Diese Ghost Lists
	      verfolgen die kürzlich verdrängten Objekte, um zu
	      verhindern, dass diese erneut in den Cache aufgenommen
	      werden.  Dies erhöht die Trefferrate (hit ratio) des
	      Caches, indem verhindert wird, dass Elemente, die in der
	      Vergangenheit nur ab und zu benutzt wurden, wieder im
	      Cache landen.  Ein weiterer Vorteil der Verwendung
	      sowohl einer <acronym>MRU</acronym> und einer
	      <acronym>MFU</acronym> ist, dass das Scannen eines
	      gesamten Dateisystems normalerweise alle Daten aus einem
	      <acronym>MRU</acronym>- oder
	      <acronym>LRU</acronym>-Cache verdrängt, um dem gerade
	      frisch zugegriffenem Inhalt den Vorzug zu geben.  Mit
	      <acronym>ZFS</acronym> gibt es also eine
	      <acronym>MFU</acronym>, die nur die am häufigsten
	      verwendeten Elemente beinhaltet und der Cache von am
	      meisten zugegriffenen Blöcken bleibt erhalten.</entry>
	  </row>

	  <row>
	    <entry
	      xml:id="zfs-term-l2arc"><acronym>L2ARC</acronym></entry>

	    <entry><acronym>L2ARC</acronym> ist die zweite Stufe des
	      Caching-Systems von <acronym>ZFS</acronym>.  Der
	      Haupt-<acronym>ARC</acronym> wird im
	      <acronym>RAM</acronym> abgelegt.  Da die Menge an
	      verfügbarem <acronym>RAM</acronym> meist begrenzt ist,
	      kann <acronym>ZFS</acronym> auch <link
	      linkend="zfs-term-vdev-cache">cache vdevs</link>
	      verwenden.  Solid State Disks (<acronym>SSD</acronym>s)
	      werden oft als diese Cache-Geräte eingesetzt, aufgrund
	      ihrer höheren Geschwindigkeit und niedrigeren Latenz im
	      Vergleich zu traditionellen drehenden Speichermedien wie
	      Festplatten.  Der Einsatz des <acronym>L2ARC</acronym>
	      ist optional, jedoch wird durch die Verwendung eine
	      signifikante Geschwindigkeitssteigerung bei
	      Lesevorgängen bei Dateien erzielt, welche auf der
	      <acronym>SSD</acronym> zwischengespeichert sind, anstatt
	      von der regulären Platte gelesen werden zu müssen.
	      <acronym>L2ARC</acronym> kann ebenfalls die <link
	      linkend="zfs-term-deduplication">Deduplizierung</link>
	      beschleunigen, da eine <acronym>DDT</acronym>, welche
	      nicht in den <acronym>RAM</acronym> passt, jedoch in den
	      <acronym>L2ARC</acronym> wesentlich schneller sein wird
	      als eine <acronym>DDT</acronym>, die von der Platte
	      gelesen werden muss.  Die Häufigkeit, in der Daten zum
	      Cache-Gerät hinzugefügt werden, ist begrenzt, um  zu
	      verhindern, dass eine <acronym>SSD</acronym> frühzeitig
	      durch zu viele Schreibvorgänge aufgebraucht ist.  Bis
	      der Cache voll ist (also der erste Block verdrängt
	      wurde, um Platz zu schaffen), wird das Schreiben auf den
	      <acronym>L2ARC</acronym> begrenzt auf die Summe der
	      Schreibbegrenzung und das Bootlimit, sowie hinterher auf
	      das Schreiblimit.  Ein paar &man.sysctl.8;-Werte steuert
	      diese Limits.  <link
		linkend="zfs-advanced-tuning-l2arc_write_max"><varname>vfs.zfs.l2arc_write_max</varname></link>
	      steuert, wie viele Bytes in den Cache pro Sekunde
	      geschrieben werden, während <link
		linkend="zfs-advanced-tuning-l2arc_write_boost"><varname>vfs.zfs.l2arc_write_boost</varname></link>
	      zu diesem Limit während der <quote>Turbo Warmup
	      Phase</quote> hinzuaddiert wird (Write Boost).</entry>
	  </row>

	  <row>
	    <entry
	      xml:id="zfs-term-zil"><acronym>ZIL</acronym></entry>

	    <entry><acronym>ZIL</acronym> beschleunigt synchrone
	      Transaktionen durch die Verwendung von Speichermedien
	      wie <acronym>SSD</acronym>s, welche schneller sind als
	      diejenigen, welche Teil des Speicherpools sind.  Wenn
	      eine Anwendung einen synchronen Schreibvorgang anfordert
	      (eine Garantie, dass die Daten sicher auf den Platten
	      gespeichert wurden anstatt nur zwischengespeichert zu
	      sein, um später geschrieben zu werden), werden die Daten
	      auf den schnelleren <acronym>ZIL</acronym>-Speicher
	      geschrieben und dann später auf die regulären
	      Festplatten.  Dies reduziert die Latenz sehr und
	      verbessert die Geschwindigkeit.  Nur synchrone Vorgänge
	      wie die von Datenbanken werden durch den Einsatz eines
	      <acronym>ZIL</acronym> profitieren.  Reguläre,
	      asynchrone Schreibvorgänge wie das Kopieren von Dateien
	      wird den <acronym>ZIL</acronym> überhaupt nicht
	      verwenden.</entry>
	  </row>

	  <row>
	    <entry xml:id="zfs-term-cow">Copy-On-Write</entry>

	    <entry>Im Gegensatz zu traditionellen Dateisystemen werden
	      beim Überschreiben von Daten bei <acronym>ZFS</acronym>
	      die neuen Daten an einen anderen Block geschrieben,
	      anstatt die alten Daten an der gleichen Stelle zu
	      überschreiben.  Nur wenn dieser Schreibvorgang beendet
	      wurde, werden die Metadaten aktualisiert, um auf die
	      neue Position zu verweisen.  Im Falle eines kurzen
	      Schreibvorgangs (ein Systemabsturz oder Spannungsverlust
	      während eine Datei geschrieben wird) sind die gesamten
	      Inhalte der Originaldatei noch vorhanden und der
	      unvollständige Schreibvorgang wird verworfen.  Das
	      bedeutet auch, dass <acronym>ZFS</acronym> nach einem
	      unvorhergesehenen Ausfall keinen &man.fsck.8;
	      benötigt.</entry>
	  </row>

	  <row>
	    <entry xml:id="zfs-term-dataset">Dataset</entry>

	    <entry><emphasis>Dataset</emphasis> ist der generische
	      Begriff für ein <acronym>ZFS</acronym>-Dateisystem,
	      Volume, Schnappschüsse oder Klone.  Jedes Dataset
	      besitzt einen eindeutigen Namen in der Form
	      <replaceable>poolname/path@snapshot</replaceable>  Die
	      Wurzel des Pools ist technisch gesehen auch ein Dataset.
	      Kind-Datasets werden hierarchisch wie Verzeichnisse
	      benannt.  Beispielsweise ist
	      <replaceable>mypool/home</replaceable> das
	      Heimatdataset, ein Kind von
	      <replaceable>mypool</replaceable> und erbt die
	      Eigenschaften von diesem.  Dies kann sogar noch
	      erweitert werden durch das Erstellen von
	      <replaceable>mypool/home/user</replaceable>.  Dieses
	      Enkelkind-Dataset wird alle Eigenschaften von den Eltern
	      und Großeltern erben.  Eigenschaften auf einem Kind
	      können die geerbten Standardwerte der Eltern und
	      Großeltern ändern und überschreiben.  Die Verwaltung
	      von Datasets und dessen Kindern lässt sich
	      <link linkend="zfs-zfs-allow">delegieren</link>.</entry>
	  </row>

	  <row>
	    <entry xml:id="zfs-term-filesystem">Dateisystem</entry>

	    <entry>Ein <acronym>ZFS</acronym>-Dataset wird meistens
	      als ein Dateisystem verwendet.  Wie jedes andere
	      Dateisystem kann auch ein
	      <acronym>ZFS</acronym>-Dateisystem irgendwo in der
	      Verzeichnishierarchie eingehängt werden und enthält
	      seine eigenen Dateien und Verzeichnisse mit
	      Berechtigungen, Flags und anderen Metadaten.</entry>
	  </row>

	  <row>
	    <entry xml:id="zfs-term-volume">Volume</entry>

	    <entry>Zusätzlich zu regulären Dateisystem-Datasets, kann
	      <acronym>ZFS</acronym> auch Volumes erstellen, die
	      Blockgeräte sind.  Volumes besitzen viele der gleichen
	      Eigenschaften, inklusive copy-on-write, Schnappschüsse,
	      Klone und Prüfsummen.  Volumes sind nützlich, um andere
	      Dateisystemformate auf <acronym>ZFS</acronym>
	      aufzusetzen, so wie <acronym>UFS</acronym>
	      Virtualisierung, oder das Exportieren von
	      <acronym>iSCSI</acronym>-Abschnitten.</entry>
	  </row>

	  <row>
	    <entry xml:id="zfs-term-snapshot">Snapshot
	      (Schnappschuss)</entry>

	    <entry>Das <link
	      linkend="zfs-term-cow">copy-on-write</link>
	      (<acronym>COW</acronym>)-Entwicklung von
	      <acronym>ZFS</acronym> erlaubt das Erstellen von beinahe
	      sofortigen, konsistenten Schnappschüssen mit beliebigen
	      Namen.  Nachdem ein Schnappschuss von einem Dataset
	      angelegt oder ein rekursiver Schnappschuss eines
	      Elterndatasets, welcher alle Kinddatasets enthält,
	      erstellt wurde, werden neue Daten auf neue Blöcke
	      geschrieben, jedoch die alten Blöcke nicht wieder als
	      freier Speicher zurückgewonnen.  Der Schnappschuss
	      enthält die Originalversion des Dateisystems und das
	      aktive Dateisystem besitzt alle Änderungen, die seit dem
	      Schnappschuss erstellt wurden.  Kein zusätzlicher Platz
	      wird benötigt.  Werden neue Daten auf das aktive
	      Dateisystem geschrieben, werden neue Blöcke allokiert,
	      um diese Daten zu speichern.  Die scheinbare Größe des
	      Schnappschusses wird wachsen, da die Blöcke nicht mehr
	      länger im aktiven Dateisystem, sondern nur noch im
	      Schnappschuss Verwendung finden.  Diese Schnappschüsse
	      können nur lesend eingehängt werden, um vorherige
	      Versionen von Dateien wiederherzustellen.  Ein <link
		linkend="zfs-zfs-snapshot">rollback</link> eines
	      aktiven Dateisystems auf einen bestimmten Schnappschuss
	      ist ebenfalls möglich, was alle Änderungen, die seit dem
	      Anlegen des Schnappschusses vorgenommen wurden, wieder
	      Rückgängig macht.  Jeder Block im Pool besitzt einen
	      Referenzzähler, der verfolgt, wieviele Schnappschüsse,
	      Klone, Datasets oder Volumes diesen Block nutzen.  Wenn
	      Dateien und Schnappschüsse gelöscht werden, verringert
	      dies auch den Referenzzähler.  Wenn ein Block nicht mehr
	      länger referenziert wird, kann er als freier Speicher
	      wieder genutzt werden.  Schnappschüsse können auch mit
	      <link linkend="zfs-zfs-snapshot">hold</link> markiert
	      werden.  Wenn versucht wird, einen solchen Schnappschuss
	      zu zerstören, wird stattdessen ein
	      <literal>EBUSY</literal>-Fehler ausgegeben.  Jeder
	      Schnappschuss kann mehrere holds besitzen, jeder mit
	      einem eindeutigen Namen.  Das Kommando <link
		linkend="zfs-zfs-snapshot">release</link> entfernt
	      diese, damit der Schnappschuss gelöscht werden kann.
	      Schnappschüsse lassen sich auf Volumes ebenfalls
	      anlegen, allerdings können diese nur geklont oder
	      zurückgerollt werden, nicht jedoch unabhängig
	      eingehängt.</entry>
	  </row>

	  <row>
	    <entry xml:id="zfs-term-clone">Clone (Klone)</entry>

	    <entry>Schnappschüsse können auch geklont werden.  Ein
	      Klon stellt eine veränderbare Version eines
	      Schnappschusses dar, was es ermöglicht, das Dateisystem
	      als neues Dataset aufzuspalten.  Genau wie bei einem
	      Schnappschuss verbraucht ein Klon keinen zusätzlichen
	      Platz.  Wenn neue Daten auf einen Klon geschrieben und
	      neue Blöcke allokiert werden, wächst auch die Größe des
	      Klons.  Wenn Blöcke im geklonten Dateisystem oder Volume
	      überschrieben werden, verringert sich auch der
	      Referenzzähler im vorherigen Block.  Der Schnappschuss,
	      auf dem der Klon basiert kann nicht gelöscht werden,
	      weil der Klon darauf eine Abhängigkeit besitzt.  Der
	      Schnappschuss stellt den Elternteil dar und der Klon das
	      Kind.  Klone lassen sich <emphasis>promoted</emphasis>
	      (befördern), was die Abhängigkeit auflöst und den Klon
	      zum Elternteil macht und den vorherigen Elternteil das
	      Kind.  Diese Operation benötigt keinen zusätzlichen
	      Plattenplatz.  Da die Menge an verwendetem Speicher vom
	      Elternteil und dem Kind vertauscht wird, betrifft dies
	      eventuell vorhandene Quotas und Reservierungen.</entry>
	  </row>

	  <row>
	    <entry xml:id="zfs-term-checksum">Checksum (Prüfsumme)</entry>

	    <entry>Jeder Block, der allokiert wird erhält auch eine
	      Prüfsumme.  Der verwendete Prüfsummenalgorithmus ist
	      eine Eigenschaft jedes Datasets, siehe dazu <link
		linkend="zfs-zfs-set"><command>set</command></link>.
	      Die Prüfsumme jedes Blocks wird transparent validiert
	      wenn er gelesen wird, was es <acronym>ZFS</acronym>
	      ermöglicht, stille Verfälschung zu entdecken.  Wenn die
	      gelesenen Daten nicht mit der erwarteten Prüfsumme
	      übereinstimmen, wird <acronym>ZFS</acronym> versuchen,
	      die Daten aus jeglicher verfügbarer Redundanz (wie
	      Spiegel oder <acronym>RAID-Z</acronym>) zu
	      rekonstruieren.  Eine Überprüfung aller Prüfsummen kann
	      durch das Kommando <link
		linkend="zfs-term-scrub"><command>scrub</command></link>
	      ausgelöst werden.
	      Prüfsummenalgorithmen sind:

	      <itemizedlist>
		<listitem>
		  <para><literal>fletcher2</literal></para>
		</listitem>

		<listitem>
		  <para><literal>fletcher4</literal></para>
		</listitem>

		<listitem>
		  <para><literal>sha256</literal></para>
		</listitem>
	      </itemizedlist>

	      Die <literal>fletcher</literal>-Algorithmen sind
	      schneller, aber dafür ist <literal>sha256</literal> ein
	      starker kryptographischer Hash und besitzt eine viel
	      niedrigere Chance auf Kollisionen zu stoßen mit dem
	      Nachteil geringerer Geschwindigkeit.  Prüfsummen können
	      deaktiviert werden, dies wird aber nicht
	      empfohlen.</entry>
	  </row>

	  <row>
	    <entry xml:id="zfs-term-compression">Compression</entry>

	    <entry>Jedes Dataset besitzt eine compression-Eigenschaft,
	      die standardmäßig ausgeschaltet ist.  Diese Eigenschaft
	      kann auf eine Reihe von Kompressionsalgorithmen
	      eingestellt werden.  Dadurch werden alle neuen Daten,
	      die auf das Dataset geschrieben werden, komprimiert.
	      Neben einer Reduzierung von verbrauchtem Speicher wird
	      oft der Lese- und Schreibdurchsatz erhöht, weil weniger
	      Blöcke gelesen oder geschrieben werden müssen.

	      <itemizedlist>
		<listitem xml:id="zfs-term-compression-lz4">
		  <para><emphasis><acronym>LZ4</acronym></emphasis> -
		    Wurde in der <acronym>ZFS</acronym> Poolversion
		    5000 (feature flags) hinzugefügt und
		    <acronym>LZ4</acronym> ist jetzt der empfohlene
		    Kompressionsalgorithmus.  <acronym>LZ4</acronym>
		    komprimiert ungefähr 50% schneller als
		    <acronym>LZJB</acronym>, wenn er auf
		    komprimierbaren Daten angewendet wird und ist über
		    dreimal schneller, wenn unkomprimierbare Daten
		    vorliegen.  <acronym>LZ4</acronym> entkomprimiert
		    auch ungefähr 80% schneller als
		    <acronym>LZJB</acronym>.  Auf modernen
		    <acronym>CPU</acronym>s, kann
		    <acronym>LZ4</acronym> oft über 500&nbsp;MB/s
		    komprimieren und entkomprimiert (pro einzelnem
		    CPU-Kern) bei über 1.5&nbsp;GB/s.</para>
		</listitem>

		<listitem xml:id="zfs-term-compression-lzjb">
		  <para><emphasis><acronym>LZJB</acronym></emphasis> -
		    Der Standardkompressionsalgorithmus wurde von
		    Jeff Bonwick, einem der ursprünglichen Entwickler
		    von <acronym>ZFS</acronym>, entworfen.
		    <acronym>LZJB</acronym> bietet gute Komprimierung
		    mit weniger <acronym>CPU</acronym>-Überhang im
		    Vergleich zu <acronym>GZIP</acronym>.  In der
		    Zukunft wird der Standardkompressionsalgorithmus
		    wahrscheinlich auf <acronym>LZ4</acronym>
		    gewechselt.</para>
		</listitem>

		<listitem xml:id="zfs-term-compression-gzip">
		  <para><emphasis><acronym>GZIP</acronym></emphasis> -
		    Ein populärer Stromkompressionsalgorithmus ist
		    auch in <acronym>ZFS</acronym> verfügbar.  Einer
		    der Hauptvorteile von der Verwendung von
		    <acronym>GZIP</acronym> ist seine konfigurierbare
		    Komprimierungsstufe.  Wenn die Eigenschaft
		    <literal>compress</literal> gesetzt wird, kann der
		    Administrator die Stufe der Komprimierung wählen,
		    die von <literal>gzip1</literal>, der kleinsten
		    Komprimierungsstufe, bis zu
		    <literal>gzip9</literal>, der höchsten
		    Komprimierungsstufe, reicht.  Dies erlaubt es dem
		    Administrator zu steuern, wieviel
		    <acronym>CPU</acronym>-Zeit für eingesparten
		    Plattenplatz eingetauscht werde soll.</para>
		</listitem>

		<listitem xml:id="zfs-term-compression-zle">
		  <para><emphasis><acronym>ZLE</acronym></emphasis> -
		    Zero Length Encoding ist ein besonderer
		    Kompressionsalgorithmus, welcher nur fortlaufende
		    Aneinanderreihungen von Nullen komprimiert.
		    Dieser Komprimierungsalgorithmus ist nur sinnvoll,
		    wenn das Dataset viele große Blöcke von Nullen
		    aufweist.</para>
		</listitem>
	      </itemizedlist></entry>
	  </row>

	  <row>
	    <entry
	      xml:id="zfs-term-copies">Copies</entry>

	    <entry>Wenn die Eigenschaft <literal>copies</literal> auf
	      einen Wert grösser als 1 gesetzt wird, weist das
	      <acronym>ZFS</acronym> an, mehrere Kopien eines Blocks
	      im <link linkend="zfs-term-filesystem">Dateisystem</link>
	      oder
	      <link linkend="zfs-term-volume">Volume</link> anzulegen.
	      Diese Eigenschaft auf einem wichtigen Dataset
	      einzustellen sorgt für zusätzliche Redundanz, aus der
	      ein Block wiederhergestellt werden kann, der nicht mehr
	      mit seiner Prüfsumme übereinstimmt.  In Pools ohne
	      Redundanz ist die copies-Eigenschaft die einzige Form
	      von Redundanz.  Die Eigenschaft kann einen einzelnen
	      schlechten Sektor oder andere Formen von kleineren
	      Verfälschungen wiederherstellen, schützt jedoch nicht
	      den Pool vom Verlust einer gesamten Platte.</entry>
	  </row>

	  <row>
	    <entry
	      xml:id="zfs-term-deduplication">Deduplizierung</entry>

	    <entry>Prüfsummen ermöglichen es, Duplikate von Blöcken zu
	      erkennen, wenn diese geschrieben werden.  Mit
	      Deduplizierung erhöht sich der Referenzzähler eines
	      existierenden, identischen Blocks, was Speicherplatz
	      einspart.  Um Blockduplikate zu erkennen, wird im
	      Speicher eine Deduplizierungstabelle
	      (<acronym>DDT</acronym>) geführt.  Die Tabelle enthält
	      eine Liste von eindeutigen Prüfsummen, die Position
	      dieser Blöcke und einen Referenzzähler.  Werden neue
	      Daten geschrieben, wird die Prüfsumme berechnet und mit
	      der Liste verglichen.  Wird eine Übereinstimmung
	      gefunden, wird der existierende Block verwendet.  Der
	      <acronym>SHA256</acronym>-Prüfsummenalgorithmus wird mit
	      Deduplizierung benutzt, um einen sicheren
	      kryptographischen Hash zu bieten.  Deduplizierung lässt
	      sich konfigurieren.  Wenn <literal>dedup</literal> auf
	      <literal>on</literal> steht, wird angenommen, dass eine
	      übereinstimmende Prüfsumme bedeutet, dass die Daten
	      identisch sind.  Steht <literal>dedup</literal> auf
	      <literal>verify</literal>, werden die Daten in den
	      beiden Blöcken Byte für Byte geprüft, um
	      sicherzustellen, dass diese wirklich identisch sind.
	      Wenn die Daten nicht identisch sind, wird die Kollision
	      im Hash vermerkt und die beiden Blöcke separat
	      gespeichert.  Da die <acronym>DDT</acronym> den Hash
	      jedes einzigartigen Blocks speichern muss, benötigt sie
	      eine große Menge an Speicher.  Eine generelle
	      Faustregel besagt, dass 5-6&nbsp;GB RAM pro 1&nbsp;TB
	      deduplizierter Daten benötigt werden.  In Situationen,
	      in denen es nicht praktikabel ist, genug
	      <acronym>RAM</acronym> vorzuhalten, um die gesamte
	      <acronym>DDT</acronym> im Speicher zu belassen, wird die
	      Geschwindigkeit stark darunter leiden, da die
	      <acronym>DDT</acronym> von der Platte gelesen werden
	      muss, bevor jeder neue Block geschrieben wird.
	      Deduplizierung kann den <acronym>L2ARC</acronym> nutzen,
	      um die <acronym>DDT</acronym> zu speichern, was einen
	      guten Mittelweg zwischen schnellem Systemspeicher und
	      langsameren Platten darstellt.  Bedenken Sie, dass durch
	      die Verwendung von Komprimierung meistens genauso große
	      Platzersparnis möglich ist, ohne den zusätzlichen
	      Hauptspeicherplatzbedarf.</entry>
	  </row>

	  <row>
	    <entry xml:id="zfs-term-scrub">Scrub (Bereinigung)</entry>

	    <entry>Anstatt einer Konsistenzprüfung wie &man.fsck.8;
	      verwendet <acronym>ZFS</acronym>
	      <command>scrub</command>.  <command>scrub</command>
	      liest alle Datenblöcke, die auf dem Pool gespeichert
	      sind und prüft deren Prüfsumme gegen die als richtig
	      in den Metadaten gespeicherte Prüfsumme.  Eine
	      periodische Prüfung aller im Pool gespeicherten Daten
	      versichert, dass verfälschte Blöcke rekonstruiert werden
	      können, bevor dies nötig ist.  Ein Scrub wird nicht nach
	      einem unsauberen Herunterfahren benötigt, wird jedoch
	      einmal alle drei Monate angeraten.  Die Prüfsumme von
	      jedem Block wird verifiziert, wenn Blöcke während des
	      normalen Betriebs gelesen werden, jedoch stellt ein
	      Scrub sicher, dass sogar weniger häufig verwendete
	      Blöcke auf stille Verfälschungen hin untersucht werden.
	      Datenintegrität wird dadurch erhöht, besonders wenn es
	      sich um Archivspeichersituationen handelt.  Die relative
	      Priorität des <command>scrub</command> lässt sich mit
	      <link
		linkend="zfs-advanced-tuning-scrub_delay"><varname>vfs.zfs.scrub_delay</varname></link>
	      anpassen, um zu verhindern, dass der scrub die
	      Geschwindigkeit von anderen Anfragen auf dem Pool
	      beeinträchtigt.</entry>
	  </row>

	  <row>
	    <entry xml:id="zfs-term-quota">Dataset Quotas</entry>

	    <entry><acronym>ZFS</acronym> bietet sehr schnelle und
	      akkurate Dataset-, Benutzer- und
	      Gruppenspeicherplatzbuchhaltung, zusätzlich zu Quotas
	      und Speicherplatzreservierungen.  Dies gibt dem
	      Administrator feingranulare Kontrolle darüber, wie
	      Speicherplatz allokiert und die Reservierung für
	      kritische Dateisysteme vorgenommen wird

	      <para><acronym>ZFS</acronym> unterstützt verschiedene
		Arten von Quotas: die Dataset-Quota, die <link
		linkend="zfs-term-refquota">Referenzquota
		(<acronym>refquota</acronym>)</link>, die <link
		linkend="zfs-term-userquota">Benutzerquota</link> und
		die <link
		linkend="zfs-term-groupquota">Gruppenquota</link>
		sind verfügbar.</para>

	      <para>Quotas beschränken die Menge an Speicherplatz,
		welche ein Dataset, seine Kinder, einschließlich
		Schnappschüsse des Datasets, deren Kinder und die
		Schnappschüsse von diesen Datasets, verbrauchen
		können.</para>

	      <note>
		<para>Quotas können nicht auf Volumes gesetzt werden,
		  da die Eigenschaft <literal>volsize</literal> als
		  eine implizite Quota agiert.</para>
	      </note></entry>
	  </row>

	  <row>
	    <entry xml:id="zfs-term-refquota">Referenzquota</entry>

	    <entry>Ein Referenzquota beschränkt die Menge an
	      Speicherplatz, die ein Dataset verbrauchen kann durch
	      das Erzwingen einer harten Grenze.  Jedoch beinhaltet
	      diese harte Grenze nur Speicherplatz, die das Dataset
	      referenziert und beinhaltet nicht den Speicher, der von
	      Kindern, wie Dateisystemen oder Schnappschüssen,
	      verbraucht wird.</entry>
	  </row>

	  <row>
	    <entry xml:id="zfs-term-userquota">Benutzerquota</entry>

	    <entry>Benutzerquotas sind hilfreich, um die Menge an
	      Speicherplatz, die ein bestimmter Benutzer verbrauchen
	      kann, einzuschränken.</entry>
	  </row>

	  <row>
	    <entry xml:id="zfs-term-groupquota">Gruppenquota</entry>

	    <entry>Die Gruppenquota beschränkt die Menge an
	      Speicherplatz, die eine bestimmte Gruppe verbrauchen
	      darf.</entry>
	  </row>

	  <row>
	    <entry
	    xml:id="zfs-term-reservation">Dataset-Reservierung</entry>

	    <entry>Die Eigenschaft <literal>reservation</literal>
	      ermöglicht es, ein Minimum an Speicherplatz für ein
	      bestimmtes Dataset und dessen Kinder zu garantieren.
	      Wenn eine Reservierung von 10&nbsp;GB auf
	      <filename>storage/home/bob</filename> gesetzt ist und
	      ein anderes Dataset versucht, allen freien Speicherplatz
	      zu verwenden, bleiben zumindest noch 10&nbsp;GB an
	      Speicher reserviert.  Wenn von
	      <filename>storage/home/bob</filename> ein Schnappschuss
	      angelegt wird, wird dieser von der Reservierung
	      abgezogen und zählt damit dagegen.
	      Die Eigenschaft <link
		linkend="zfs-term-refreservation"><literal>refreservation</literal></link>
	      funktioniert auf ähnliche Weise, jedoch
	      <emphasis>exkludiert</emphasis> diese Kinder wie
	      Schnappschüsse.

	      <para>Reservierungen jeder Art sind in vielen
		Situationen nützlich, so wie bei der Planung und dem
		Testen der richtigen Speicherplatzallokation in einem
		neuen System oder durch die Zusicherung, dass genug
		Speicherplatz auf Dateisystemen für Audio-Logs oder
		Systemwiederherstellungsprozeduren und Dateien
		verfügbar ist.</para>
	    </entry>
	  </row>

	  <row>
	    <entry
	    xml:id="zfs-term-refreservation">Referenzreservierung</entry>

	    <entry>Die Eigenschaft <literal>refreservation</literal>
	      ermöglicht es, ein Minimum an Speicherplatz für die
	      Verwendung eines bestimmten Datasets zu garantieren,
	      <emphasis>exklusiv</emphasis> dessen Kinder.  Das
	      bedeutet, dass wenn eine 10&nbsp;GB-Reservierung auf
	      <filename>storage/home/bob</filename> vorhanden ist und
	      ein anderes Dataset versucht, alle freien Speicherplatz
	      aufzubrauchen, sind zumindest noch
	      10&nbsp;GB Speicher reserviert.  Im Gegensatz zu einer
	      regulären <link
	      linkend="zfs-term-reservation">Reservierung</link> wird
	      der Speicher von Schnappschüssen und Kinddataset nicht
	      gegen die Reservierung gezählt.  Beispielsweise, wenn
	      ein Schnappschuss von
	      <filename>storage/home/bob</filename> angelegt wird,
	      muss genug Plattenplatz außerhalb der Menge an
	      <literal>refreservation</literal> vorhanden sein, damit
	      die Operation erfolgreich durchgeführt wird.  Kinder des
	      Hauptdatasets werden nicht in die Menge an
	      <literal>refreservation</literal> gezählt und dringen
	      auf diese Weise auch nicht in den gesetzten Speicher
	      ein.</entry>
	  </row>

	  <row>
	    <entry xml:id="zfs-term-resilver">Resilver</entry>

	    <entry>Wenn eine Platte ausfällt und ersetzt wird, muss
	      die neue Platte mit den Daten gefüllt werden, die
	      verloren gegangen sind.  Der Prozess der Verwendung der
	      Paritätsinformationen, welche über die übrigen Platten
	      verteilt sind, um die fehlenden Daten zu berechnen und
	      auf die neue Platte zu übertragen, wird
	      <emphasis>resilvering</emphasis> genannt.</entry>
	  </row>

	  <row>
	    <entry xml:id="zfs-term-online">Online</entry>

	    <entry>Ein Pool oder vdev im Zustand
	      <literal>Online</literal> besitzt alle verbundenen
	      Mitgliedsgeräte und ist voll funktionsfähig.
	      Individuelle Geräte im Zustand
	      <literal>Online</literal> funktionieren normal.</entry>
	  </row>

	  <row>
	    <entry xml:id="zfs-term-offline">Offline</entry>

	    <entry>Individuelle Geräte lassen sich vom Administrator
	      in den Zustand <literal>Offline</literal> versetzen,
	      wenn es ausreichend Redundanz gibt, um zu verhindern,
	      dass der Pool oder das vdev in den Zustand
	      <link linkend="zfs-term-faulted">Faulted</link> versetzt
	      wird.  Ein Administrator kann eine Platte vor einem
	      Austausch offline nehmen oder um es leichter zu machen,
	      diese zu identifizieren.</entry>
	  </row>

	  <row>
	    <entry xml:id="zfs-term-degraded">Degraded</entry>

	    <entry>Ein Pool oder vdev im Zustand
	      <literal>Degraded</literal> hat eine oder mehrere
	      Platten, welche getrennt wurden oder ausgefallen sind.
	      Der Pool kann immer noch verwendet werden, doch wenn
	      noch weitere Geräte ausfallen, kann der Pool nicht
	      wiederhergestellt werden.  Die fehlenden Geräte
	      anzuschließen oder die defekten Platten zu ersetzen
	      wird den Pool wieder in den Zustand
	      <link linkend="zfs-term-online">Online</link> versetzen,
	      nachdem die angeschlossenen oder neuen Geräte den
	      <link
	      linkend="zfs-term-resilver">Resilver</link>-Prozess
	      abgeschlossen haben.</entry>
	  </row>

	  <row>
	    <entry xml:id="zfs-term-faulted">Faulted</entry>

	    <entry>Ein Pool oder vdev im Zustand
	      <literal>Faulted</literal> funktioniert nicht länger.
	      Die Daten darauf sind nicht mehr länger verfügbar.  Ein
	      Pool oder vdev geht in den Zustand
	      <literal>Faulted</literal> über, wenn die Anzahl der
	      fehlenden oder defekten Geräte die Redundanzstufe im
	      vdev überschreiten.  Wenn fehlende Geräte angeschlossen
	      werden, geht der Pool wieder in den Zustand <link
	      linkend="zfs-term-online">Online</link>.  Wenn es nicht
	      genügend Redundanz gibt, um die Anzahl an defekten
	      Platten zu kompensieren, sind die Inhalte des Pools
	      verloren und müssen von der Sicherung wiederhergestellt
	      werden.</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>
  </sect1>
</chapter>
