<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde: de-docproj/books/handbook/config/chapter.xml,v 1.151 2011/12/19 14:55:31 bcr Exp $
     basiert auf: r51390
-->
<chapter xmlns="http://docbook.org/ns/docbook"
  xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0"
  xml:id="config-tuning">

  <info>
    <title>Konfiguration und Tuning</title>

    <authorgroup>
      <author>
	<personname>
	  <firstname>Chern</firstname>
	  <surname>Lee</surname>
	</personname>
	<contrib>Geschrieben von </contrib>
      </author>
    </authorgroup>

    <authorgroup>
      <author>
	<personname>
	  <firstname>Mike</firstname>
	  <surname>Smith</surname>
	</personname>
	<contrib>Nach einem Tutorium von </contrib>
      </author>
    </authorgroup>

    <authorgroup>
      <author>
	<personname>
	  <firstname>Matt</firstname>
	  <surname>Dillon</surname>
	</personname>
	<contrib>Basiert ebenfalls auf tuning(7) von </contrib>
      </author>
    </authorgroup>

    <authorgroup>
      <author>
	<personname>
	  <firstname>Martin</firstname>
	  <surname>Heinen</surname>
	</personname>
	<contrib>Übersetzt von </contrib>
      </author>
    </authorgroup>
  </info>


  <sect1 xml:id="config-synopsis">
    <title>Übersicht</title>

    <indexterm><primary>System-Konfiguration</primary></indexterm>
    <indexterm><primary>System-Optimierung</primary></indexterm>

    <para>Die richtige Systemkonfiguration ist einer der wichtigsten
      Aspekte unter &os;.  Dieses Kapitel beschreibt die
      Konfiguration von &os; sowie Maßnahmen zur Leistungssteigerung
      von &os;-Systemen.</para>

    <para>Nachdem Sie dieses Kapitel durchgearbeitet haben,
      werden Sie Folgendes wissen:</para>

    <itemizedlist>
      <listitem>
	<para>Die Grundlagen der Konfiguration von
	  <filename>rc.conf</filename> und die Skripte zum Starten
	  von Anwendungen in
	  <filename>/usr/local/etc/rc.d</filename>.</para>
      </listitem>

      <listitem>
	<para>Wie Sie Netzwerkkarten konfigurieren und testen.</para>
      </listitem>

      <listitem>
	<para>Wie Sie virtuelle Hosts und Netzwerkgeräte
	  konfigurieren.</para>
      </listitem>

      <listitem>
	<para>Wie Sie die verschiedenen Konfigurationsdateien
	  in <filename>/etc</filename> benutzen.</para>
      </listitem>

      <listitem>
	<para>Wie Sie mit &os; mit &man.sysctl.8;-Variablen
	  einstellen können.</para>
      </listitem>

      <listitem>
	<para>Wie Sie die Platten-Performance einstellen und
	  Kernel-Parameter modifizieren können.</para>
      </listitem>
    </itemizedlist>

    <para>Bevor Sie dieses Kapitel lesen, sollten Sie</para>
    <itemizedlist>
      <listitem>
	<para>die Grundlagen von &unix; und
	  &os; (<xref linkend="basics"/>) verstehen.</para>
      </listitem>

      <listitem>
	<para>Damit vertraut sein, wie Sie einen Kernel konfigurieren
	  und kompilieren (<xref linkend="kernelconfig"/>).</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 xml:id="configtuning-starting-services">
    <info>
      <title>Start von Diensten</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	  </personname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>Dienste</primary>
    </indexterm>

    <para>Viele Benutzer installieren Software Dritter auf &os;
      mithilfe der Ports-Sammlung.  Häufig soll die
      Software bei einem Systemstart mitgestartet werden.
      Beispielsweise sollen die Dienste
      <package>mail/postfix</package> oder
      <package>www/apache22</package> nach
      einem Systemstart laufen.  Dieser Abschnitt stellt
      die Startprozeduren für Software Dritter vor.</para>

    <para>Unter &os; werden die meisten der im System enthaltenen
      Dienste wie &man.cron.8; mithilfe von Systemskripten
      gestartet.</para>

    <sect2>
      <title>Dienste über das <filename>rc.d</filename>-System
	starten</title>

      <para>Mit <filename>rc.d</filename> lässt sich der Start
	von Anwendungen besser steuern und es sind mehr Funktionen
	verfügbar.  Mit den in <xref linkend="configtuning-rcd"/>
	besprochenen Schlüsselwörtern können
	Anwendungen in einer bestimmten Reihenfolge gestartet werden
	und Optionen können in <filename>rc.conf</filename> statt fest
	im Startskript der Anwendung festgelegt werden.  Ein einfaches
	Startskript sieht wie folgt aus:</para>

      <programlisting>#!/bin/sh
#
# PROVIDE: utility
# REQUIRE: DAEMON
# KEYWORD: shutdown

. /etc/rc.subr

name=utility
rcvar=utility_enable

command="/usr/local/sbin/utility"

load_rc_config $name

#
# DO NOT CHANGE THESE DEFAULT VALUES HERE
# SET THEM IN THE /etc/rc.conf FILE
#
utility_enable=${utility_enable-"NO"}
pidfile=${utility_pidfile-"/var/run/utility.pid"}

run_rc_command "$1"</programlisting>

      <para>Dieses Skript stellt sicher, dass
	<literal>utility</literal> nach den
	<literal>DAEMON</literal>-Pseudodiensten gestartet wird.
	Es stellt auch eine Methode bereit, die
	Prozess-<acronym>ID</acronym> (<acronym>PID</acronym>)
	der Anwendung in einer Datei zu speichern.</para>

      <para>In <filename>/etc/rc.conf</filename> könnte für diese
	Anwendung die folgende Zeile stehen:</para>

      <programlisting>utility_enable="YES"</programlisting>

      <para>Die Methode erleichtert den Umgang mit
	Kommandozeilenargumenten, bindet Funktionen aus
	<filename>/etc/rc.subr</filename> ein, ist kompatibel
	zu &man.rcorder.8; und lässt sich über
	<filename>rc.conf</filename> leichter konfigurieren.</para>
    </sect2>

    <sect2>
      <title>Andere Arten, um Dienste zu starten</title>

      <para>Andere Dienste können über &man.inetd.8; gestartet werden.
	Die Konfiguration von &man.inetd.8; wird in <xref
	  linkend="network-inetd"/> ausführlich beschrieben.</para>

      <para>Systemdienste können auch mit &man.cron.8; gestartet
	werden.  Dieser Ansatz hat einige Vorteile; nicht zuletzt,
	weil &man.cron.8; die Prozesse unter dem Eigentümer der
	<filename>crontab</filename> startet, ist es möglich, dass
	Dienste von normalen Benutzern gestartet und gepflegt werden
	können.</para>

      <para>Für die Zeitangabe in &man.cron.8; kann
	<literal>@reboot</literal> eingesetzt werden.  Damit wird das
	Kommando gestartet, wenn &man.cron.8; kurz nach dem Systemboot
	gestartet wird.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="configtuning-cron">
    <info>
      <title>&man.cron.8; konfigurieren</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	  </personname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary><command>cron</command></primary>
      <secondary>konfigurieren</secondary>
    </indexterm>

    <para>Ein sehr nützliches Werkzeug von &os; ist
      <application>cron</application>.  Dieses Programm läuft im
      Hintergrund und überprüft fortlaufend
      <filename>/etc/crontab</filename> und
      <filename>/var/cron/tabs</filename>.  In diesen Dateien wird
      festgelegt, welche Programme zu welchem Zeitpunkt von
      <application>cron</application> ausgeführt werden sollen.
      Jede Zeile in diesen Dateien definiert eine auszuführende
      Aufgabe, die auch als <firstterm>Cronjob</firstterm> bezeichnet
      wird.</para>

    <para>Das Werkzeug verwendet zwei verschiedene
      Konfigurationsdateien: die System-crontab, welche nicht
      verändert werden sollte und die Benutzer-crontabs, die nach
      Bedarf erstellt und geändert werden können.  Das Format, dass
      von diesen beiden Dateien verwendet wird, ist in &man.crontab.5;
      dokumentiert.  Das Format der System-crontab in
      <filename>/etc/crontab</filename> enthält das Feld
      <literal>who</literal>, das in der Benutzer-crontab nicht
      existiert.  Dieses Feld gibt den Benutzer an, mit dem die
      Aufgabe ausgeführt wird.  Die Aufgaben in den Benutzer-crontabs
      laufen unter dem Benutzer, der die crontab erstellt hat.</para>

    <para>Benutzer-crontabs erlauben es den Benutzern, ihre eigenen
      Aufgaben zu planen.  Der Benutzer <systemitem
	class="username">root</systemitem> kann auch seine eigene
      Benutzer-crontab haben, um Aufgaben zu planen, die nicht in der
      System-crontab existieren.</para>

    <para>Hier ist ein Beispieleintrag aus der
      System-crontab, <filename>/etc/crontab</filename>:</para>

    <programlisting># /etc/crontab - root's crontab for FreeBSD
#
# <phrase its:translate="no">&dollar;FreeBSD&dollar;</phrase>
# <co xml:id="co-comments"/>
SHELL=/bin/sh
PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin <co xml:id="co-env"/>
#
#
#minute	hour	mday	month	wday	who	command <co xml:id="co-field-descr"/>
#
*/5	*	*	*	*	root	/usr/libexec/atrun <co xml:id="co-main"/></programlisting>

    <calloutlist>
      <callout arearefs="co-comments">
	<para>Das Zeichen <literal>#</literal> am Zeilenanfang leitet
	  einen Kommentar
	  ein.  Benutzen Sie Kommentare, um die Funktion eines
	  Eintrags zu erläutern.  Kommentare müssen in einer extra
	  Zeile stehen.  Sie können nicht in derselben Zeile wie ein
	  Kommando stehen, da sie sonst Teil des Kommandos wären.
	  Leerzeilen in dieser Datei werden ignoriert.</para>
      </callout>

      <callout arearefs="co-env">
	<para>Umgebungsvariablen werden mit dem Gleichheits-Zeichen
	  (<literal>=</literal>) festgelegt.  Im Beispiel werden
	  die Variablen <envar>SHELL</envar>, <envar>PATH</envar>
	  und <envar>HOME</envar> definiert.  Wenn die Variable
	  <envar>SHELL</envar> nicht definiert wird, benutzt
	  <application>cron</application> die Bourne Shell.
	  Wird die Variable <envar>PATH</envar> nicht gesetzt,
	  müssen alle Pfadangaben absolut sein, da es keinen
	  Vorgabewert für <envar>PATH</envar> gibt.</para>
      </callout>

      <callout arearefs="co-field-descr">
	<para>In dieser Zeile werden sieben Felder der System-crontab
	  beschrieben: <literal>minute</literal>,
	  <literal>hour</literal>, <literal>mday</literal>,
	  <literal>month</literal>, <literal>wday</literal>,
	  <literal>who</literal> und <literal>command</literal>.  Das
	  Feld <literal>minute</literal> legt die Minute fest in der
	  die Aufgabe ausgeführt wird, das Feld
	  <literal>hour</literal> die Stunde, das Feld
	  <literal>mday</literal> den Tag des Monats.  Im Feld
	  <literal>month</literal> wird der Monat und im Feld
	  <literal>wday</literal> der Wochentag festgelegt.  Alle
	  Felder müssen numerische Werte enthalten und die Zeitangaben
	  sind im 24-Stunden-Format.  Das Zeichen <literal>*</literal>
	  repräsentiert dabei alle möglichen Werte für dieses Feld.
	  Das Feld <literal>who</literal> gibt es nur in der
	  System-crontab und gibt den Account an, unter dem das
	  Kommando laufen soll.  Im letzten Feld wird schließlich das
	  auszuführende Kommando angegeben.</para>
      </callout>

      <callout arearefs="co-main">
	<para>Diese Zeile definiert die Werte für den Cronjob.  Die
	  Zeichenfolge <literal>*/5</literal> gefolgt von mehreren
	  <literal>*</literal>-Zeichen bedeutet, dass
	  <command>/usr/libexec/atrun</command> von <systemitem
	    class="username">root</systemitem> alle fünf Minuten
	  aufgerufen wird.</para>

	<para>Bei den Kommandos können beliebig viele Optionen
	  angegeben werden.  Wenn das Kommando zu lang ist und
	  auf der nächsten Zeile fortgesetzt werden soll,
	  muss am Ende der Zeile das Fortsetzungszeichen
	  (<literal>\</literal>) angegeben werden.</para>
      </callout>
    </calloutlist>

    <sect2 xml:id="configtuning-installcrontab">
      <title>Eine Benutzer-crontab erstellen</title>

      <para>Rufen Sie <command>crontab</command> im Editor-Modus auf,
	um eine Benutzer-crontab zu erstellen:</para>

      <screen>&prompt.user; <userinput>crontab -e</userinput></screen>

      <para>Dies wird die crontab des Benutzers mit dem
	voreingestellten Editor öffnen.  Wenn der Benutzer diesen
	Befehl zum ersten Mal ausführt, wird eine leere Datei
	geöffnet.  Nachdem der Benutzer eine crontab erstellt hat,
	wird die Datei mit diesem Kommando zur Bearbeitung
	geöffnet.</para>

      <para>Es empfiehlt sich, die folgenden Zeilen an den Anfang der
	crontab-Datei hinzuzufügen, um die Umgebungsvariablen zu
	setzen und die einzelnen Felder zu beschreiben:</para>

      <programlisting>SHELL=/bin/sh
PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin
# Order of crontab fields
# minute	hour	mday	month	wday	command</programlisting>

      <para>Fügen Sie dann für jedes Kommando oder Skript eine Zeile
	hinzu, mit der Angabe wann das Kommando ausgeführt werden
	soll.  In diesem Beispiel wird ein Bourne Shell Skript täglich
	um 14:00&nbsp;Uhr ausgeführt.  Da der Pfad zum Skript nicht in
	<literal>PATH</literal> enthalten ist, wird der vollständige
	Pfad zum Skript angegeben:</para>

      <programlisting>0	14	*	*	*	/usr/home/dru/bin/mycustomscript.sh</programlisting>

      <tip>
	<para>Bevor Sie ein eigenes Skript verwenden, stellen Sie
	  sicher, dass es ausführbar ist und dass es mit den wenigen
	  Umgebungsvariablen von <application>cron</application>
	  funktioniert.  Um die Umgebung nachzubilden, die der obige
	  <application>cron</application>-Eintrag bei der Ausführung
	  verwenden würde, benutzen Sie dieses Kommando:</para>

	<screen>&prompt.user; <userinput>env -i SHELL=/bin/sh PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin HOME=/home/<replaceable>dru</replaceable> LOGNAME=<replaceable>dru</replaceable> <replaceable>/usr/home/dru/bin/mycustomscript.sh</replaceable></userinput></screen>

	<para>Die Umgebung von <application>cron</application> wird in
	  &man.crontab.5; beschrieben.  Es ist wichtig, dass
	  sichergestellt wird, dass die Skripte in der Umgebung von
	  <application>cron</application> korrekt arbeiten, besonders
	  wenn Befehle enthalten sind, welche Dateien mit Wildcards
	  löschen.</para>
      </tip>

      <para>Wenn Sie mit der Bearbeitung der crontab fertig sind,
	speichern Sie die Datei.  Sie wird automatisch installiert
	und <application>cron</application> wird die darin enthalten
	Cronjobs zu den angegebenen Zeiten ausführen.  Um die Cronjobs
	in einer crontab aufzulisten, verwenden Sie diesen
	Befehl:</para>

      <screen>&prompt.user; <userinput>crontab -l</userinput>
0	14	*	*	*	/usr/home/dru/bin/mycustomscript.sh</screen>

      <para>Um alle Cronjobs einer Benutzer-crontab zu löschen,
	verwenden Sie diesen Befehl:</para>

      <screen>&prompt.user; <userinput>crontab -r</userinput>
remove crontab for dru? <userinput>y</userinput></screen>
    </sect2>
  </sect1>

  <sect1 xml:id="configtuning-rcd">
    <info>
      <title>Dienste unter &os; verwalten</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	  </personname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
    </info>

    <para>&os; verwendet die vom &man.rc.8;-System bereit gestellten
      Startskripten beim Systemstart und für die Verwaltung von
      Diensten.  Die Skripte sind in <filename>/etc/rc.d</filename>
      abgelegt und bieten grundlegende Dienste an, die über die
      Optionen <option>start</option>, <option>stop</option> und
      <option>restart</option> des &man.service.8; Kommandos
      kontrolliert werden können.  Beispielsweise kann &man.sshd.8;
      mit dem nachstehenden Kommando neu gestartet werden:</para>

    <screen>&prompt.root; <userinput>service sshd restart</userinput></screen>

    <para>Analog können Sie andere Dienste starten und stoppen.
      Normalerweise werden die Dienste beim Systemstart über
      Einträge in der Datei &man.rc.conf.5; automatisch gestartet.
      &man.natd.8; wird zum Beispiel mit dem folgenden
      Eintrag in <filename>/etc/rc.conf</filename> aktiviert:</para>

    <programlisting>natd_enable="YES"</programlisting>

    <para>Wenn dort bereits die Zeile
      <option>natd_enable="NO"</option> existiert, ändern Sie
      <option>NO</option> in <option>YES</option>.  Die
      &man.rc.8;-Skripten starten, wie unten beschrieben, auch
      abhängige Dienste.</para>

    <para>Da das &man.rc.8;-System primär
      zum automatischen Starten und Stoppen von Systemdiensten
      dient, funktionieren die Optionen <option>start</option>,
      <option>stop</option> und <option>restart</option> nur,
      wenn die entsprechenden Variablen in
      <filename>/etc/rc.conf</filename> gesetzt sind.  Beispielsweise
      funktioniert <command>sshd restart</command> nur dann, wenn in
      <filename>/etc/rc.conf</filename> die Variable
      <varname>sshd_enable</varname> auf <option>YES</option> gesetzt
      wurde.  Wenn Sie die Optionen <option>start</option>,
      <option>stop</option> oder <option>restart</option>
      unabhängig von den Einstellungen in
      <filename>/etc/rc.conf</filename> benutzen wollen,
      müssen Sie den Optionen mit dem Präfix
      <quote>one</quote> verwenden.  Um beispielsweise
      <command>sshd</command> unabhängig von den
      Einstellungen in <filename>/etc/rc.conf</filename> neu
      zu starten, benutzen Sie das nachstehende Kommando:</para>

    <screen>&prompt.root; <userinput>service sshd onerestart</userinput></screen>

    <para>Ob ein Dienst in <filename>/etc/rc.conf</filename>
      aktiviert ist, können Sie herausfinden, indem
      Sie das entsprechende &man.rc.8;-Skript
      mit der Option <option>rcvar</option> aufrufen.  Dieses Beispiel
      prüft, ob der <command>sshd</command>-Dienst in
      <filename>/etc/rc.conf</filename> aktiviert ist:</para>

    <screen>&prompt.root; <userinput>service sshd rcvar</userinput>
# sshd
#
sshd_enable="YES"
#   (default: "")</screen>

    <note>
      <para>Die Zeile <literal># sshd</literal> wird von dem Kommando
	ausgegeben; sie kennzeichnet nicht die Eingabeaufforderung von
	<systemitem class="username">root</systemitem>.</para>
    </note>

    <para>Ob ein Dienst läuft, kann mit <option>status</option>
      abgefragt werden.  Das folgende
      Kommando überprüft, ob <command>sshd</command>
      auch wirklich gestartet wurde:</para>

    <screen>&prompt.root; <userinput>service sshd status</userinput>
sshd is running as pid 433.</screen>

    <para>Einige Dienste können über die Option
      <option>reload</option> neu initialisiert werden.  Dazu wird
      dem Dienst über ein Signal mitgeteilt,
      dass er seine Konfigurationsdateien neu einlesen soll.
      Oft wird dazu das Signal <literal>SIGHUP</literal>
      verwendet.  Beachten Sie aber, dass nicht alle Dienste diese
      Option unterstützen.</para>

    <para>Die meisten Systemdienste werden beim Systemstart vom
      &man.rc.8;-System gestartet.  Zum Beispiel aktiviert das Skript
      <filename>/etc/rc.d/bgfsck</filename> die Prüfung von
      Dateisystemen im Hintergrund.  Das Skript gibt die folgende
      Meldung aus, wenn es gestartet wird:</para>

    <screen>Starting background file system checks in 60 seconds.</screen>

    <para>Dieses Skript wird während des Systemstarts ausgeführt und
      führt eine Überprüfung der Dateisysteme im Hintergrund
      durch.</para>

    <para>Viele Systemdienste hängen von anderen Diensten
      ab.  &man.yp.8; und andere RPC-basierende Systeme hängen
      beispielsweise von dem <command>rpcbind</command>-Dienst
      ab.  Im Kopf der Startskripten befinden sich
      die Informationen über Abhängigkeiten von anderen
      Diensten und weitere Metadaten.  Mithilfe dieser Daten
      bestimmt das Programm &man.rcorder.8; beim Systemstart die
      Startreihenfolge der Dienste.</para>

    <para>Folgende Schlüsselwörter müssen im Kopf aller Startskripten
      verwendet werden, da sie von &man.rc.subr.8; zum
      <quote>Aktivieren</quote> des Startskripts benötigt
      werden:</para>

    <itemizedlist>
      <listitem>
	<para><literal>PROVIDE</literal>: Gibt die Namen der Dienste
	  an, die mit dieser Datei zur Verfügung gestellt
	  werden.</para>
      </listitem>
    </itemizedlist>

    <para>Die folgenden Schlüsselwörter können im Kopf
      des Startskripts angegeben werden.  Sie sind zwar nicht
      unbedingt notwendig, sind aber hilfreich beim Umgang mit
      &man.rcorder.8;:</para>

    <itemizedlist>
      <listitem>
	<para><literal>REQUIRE</literal>: Gibt die Namen der Dienste
	  an, von denen dieser Dienst abhängt.  Ein Skript, das dieses
	  Schlüsselwort enthält wird <emphasis>nach</emphasis> den
	  angegebenen Diensten ausgeführt.</para>
      </listitem>

      <listitem>
	<para><literal>BEFORE</literal>: Zählt Dienste auf,
	  die auf diesen Dienst angewiesen sind.  Ein Skript, dass
	  dieses Schlüsselwort enthält wird <emphasis>vor</emphasis>
	  den angegebenen Diensten ausgeführt.</para>
      </listitem>
    </itemizedlist>

    <para>Durch das Verwenden dieser Schlüsselwörter kann
      ein Administrator die Startreihenfolge von Systemdiensten
      feingranuliert steuern, ohne mit den
      Schwierigkeiten des <quote>runlevel</quote>-Systems
      anderer &unix; Systeme kämpfen zu müssen.</para>

    <para>Weitere Informationen über das
      &man.rc.8;-System finden Sie in &man.rc.8; und
      &man.rc.subr.8;.  Wenn Sie eigene
      <filename>rc.d</filename>-Skripte schreiben wollen, sollten Sie
      <link xlink:href="&url.articles.rc-scripting.en;">
	diesen Artikel</link> lesen.</para>

    <sect2 xml:id="configtuning-core-configuration">
      <title>Systemspezifische Konfiguration</title>

      <indexterm>
	<primary>rc-Dateien</primary>
	<secondary><filename>rc.conf</filename></secondary>
      </indexterm>

      <para>Informationen zur Systemkonfiguration sind hauptsächlich
	in <filename>/etc/rc.conf</filename>, die meist beim Start
	des Systems verwendet wird, abgelegt.  Sie enthält die
	Konfigurationen für die
	<filename>rc*</filename> Dateien.</para>

      <para>In <filename>rc.conf</filename> werden die Vorgabewerte
	aus <filename>/etc/defaults/rc.conf</filename> überschrieben.
	Die Vorgabedatei sollte nicht editiert werden.  Stattdessen
	sollten alle systemspezifischen Änderungen in
	<filename>rc.conf</filename> vorgenommen werden.</para>

      <para>Um den administrativen Aufwand gering zu halten,
	existieren in geclusterten Anwendungen mehrere Strategien,
	globale Konfigurationen von systemspezifischen Konfigurationen
	zu trennen.  Der empfohlene Weg hält die globale Konfiguration
	in einer separaten Datei z.B.
	<filename>/etc/rc.conf.local</filename>.  Zum Beispiel
	so:</para>

      <itemizedlist>
	<listitem>
	  <para><filename>/etc/rc.conf</filename>:</para>

	  <programlisting>sshd_enable="YES"
keyrate="fast"
defaultrouter="10.1.1.254"</programlisting>
	</listitem>

	<listitem>
	  <para><filename>/etc/rc.conf.local</filename>:</para>

	  <programlisting>hostname="node1.example.org"
ifconfig_fxp0="inet 10.1.1.1/8"</programlisting>
	</listitem>
      </itemizedlist>

      <para><filename>/etc/rc.conf</filename> kann dann auf jedes
	System mit <application>rsync</application> oder
	<application>puppet</application> verteilt werden,
	während <filename>/etc/rc.conf.local</filename> dabei
	systemspezifisch bleibt.</para>

      <para>Bei einem Upgrade des Systems wird
	<filename>/etc/rc.conf</filename> nicht überschrieben, so dass
	die Systemkonfiguration erhalten bleibt.</para>

      <tip>
	<para><filename>/etc/rc.conf</filename> und
	  <filename>/etc/rc.conf.local</filename> werden von
	  &man.sh.1; gelesen.  Dies erlaubt es dem
	  Systemadministrator, komplexe Konfigurationsszenarien zu
	  erstellen.  Lesen Sie &man.rc.conf.5;, um weitere
	  Informationen zu diesem Thema zu erhalten.</para>
      </tip>
    </sect2>
  </sect1>

  <sect1 xml:id="config-network-setup">
    <info>
      <title>Einrichten von Netzwerkkarten</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Marc</firstname>
	    <surname>Fonvieille</surname>
	  </personname><contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>Netzwerkkarten</primary>
      <secondary>einrichten</secondary>
    </indexterm>

    <para>Die Konfiguration einer Netzwerkkarte gehört zu
      den alltäglichen Aufgaben eines &os; Administrators.</para>

    <sect2>
      <title>Bestimmen des richtigen Treibers</title>

      <indexterm>
	<primary>Netzwerkkarten</primary>
	<secondary>Treiber</secondary>
      </indexterm>

      <para>Ermitteln Sie zunächst das Modell der Netzwerkkarte und
	den darin verwendeten Chip.  &os; unterstützt eine Vielzahl
	von Netzwerkkarten.  Prüfen Sie die
	Hardware-Kompatibilitätsliste für das &os; Release, um zu
	sehen ob die Karte unterstützt wird.</para>

      <para>Wenn die Karte unterstützt wird, müssen Sie den Treiber
	für die Karte bestimmen.
	<filename>/usr/src/sys/conf/NOTES</filename> und
	<filename>/usr/src/sys/<replaceable>arch</replaceable>/conf/NOTES</filename>
	enthalten eine Liste der verfügbaren Treiber mit Informationen
	zu den unterstützten Chipsätzen.  Wenn Sie sich nicht
	sicher sind, ob Sie den richtigen Treiber ausgewählt haben,
	lesen Sie die Hilfeseite des Treibers.  Sie enthält weitere
	Informationen über die unterstützten Geräte und bekannte
	Einschränkungen des Treibers.</para>

      <para>Die Treiber für gebräuchliche Netzwerkkarten sind schon im
	<filename>GENERIC</filename>-Kernel enthalten, so dass die
	Karte während des Systemstarts erkannt werden sollte.  Die
	Systemmeldungen können Sie sich mit
	<command>more /var/run/dmesg.boot</command> ansehen.  Mit der
	Leertaste können Sie durch den Text blättern.  In diesem
	Beispiel findet das System zwei Karten, die den
	&man.dc.4;-Treiber benutzen:</para>

      <screen>dc0: &lt;82c169 PNIC 10/100BaseTX&gt; port 0xa000-0xa0ff mem 0xd3800000-0xd38
000ff irq 15 at device 11.0 on pci0
miibus0: &lt;MII bus&gt; on dc0
bmtphy0: &lt;BCM5201 10/100baseTX PHY&gt; PHY 1 on miibus0
bmtphy0:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
dc0: Ethernet address: 00:a0:cc:da:da:da
dc0: [ITHREAD]
dc1: &lt;82c169 PNIC 10/100BaseTX&gt; port 0x9800-0x98ff mem 0xd3000000-0xd30
000ff irq 11 at device 12.0 on pci0
miibus1: &lt;MII bus&gt; on dc1
bmtphy1: &lt;BCM5201 10/100baseTX PHY&gt; PHY 1 on miibus1
bmtphy1:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
dc1: Ethernet address: 00:a0:cc:da:da:db
dc1: [ITHREAD]</screen>

      <para>Ist der Treiber für die Netzwerkkarte nicht
	in <filename>GENERIC</filename> enthalten, muss zunächst
	ein Treiber geladen werden, um die Karte konfigurieren und
	benutzen zu können.  Dafür gibt es zwei Methoden:</para>

      <itemizedlist>
	<listitem>
	  <para>Am einfachsten ist es, das Kernelmodul für
	    die Karte mit &man.kldload.8; zu laden.  Um den Treiber
	    automatisch beim Systemstart zu laden, fügen Sie die
	    entsprechende Zeile in
	    <filename>/boot/loader.conf</filename> ein.  Es gibt nicht
	    für alle Karten Kernelmodule.</para>
	</listitem>

	<listitem>
	  <para>Alternativ kann der Treiber für die Karte fest in den
	    Kernel eingebunden werden.  Lesen Sie dazu
	    <filename>/usr/src/sys/conf/NOTES</filename>,
	    <filename>/usr/src/sys/<replaceable>arch</replaceable>/conf/NOTES</filename>
	    und die Hilfeseite des Treibers, den Sie in den Kernel
	    einbinden möchten, an.  Die Übersetzung des Kernels
	    wird in <xref linkend="kernelconfig"/> beschrieben.  Wenn
	    die Karte während des Systemstarts vom Kernel erkannt
	    wurde, muss der Kernel nicht neu übersetzt werden.</para>
	</listitem>
      </itemizedlist>

      <sect3 xml:id="config-network-ndis">
	<title>&windows;-<acronym>NDIS</acronym>-Treiber
	  einsetzen</title>

	<indexterm>
	  <primary><acronym>NDIS</acronym></primary>
	</indexterm>
	<indexterm><primary>NDISulator</primary></indexterm>
	<indexterm><primary>&windows;-Treiber</primary></indexterm>
	<indexterm>
	  <primary>&microsoft.windows;</primary>
	  <secondary>Gerätetreiber</secondary>
	</indexterm>
	<indexterm>
	  <primary><acronym>KLD</acronym>
	    (kernel loadable object)</primary>
	</indexterm>

        <!-- Hm.  Soll man den letzten Indexterm abwandeln, d.h. die
	  Langversion weglassen?  Keine Ahnung.  Wenn ja, dann muss
	  das auch in handbook/linuxemu/chapter.xml passieren! -->

	<para>Leider stellen nach wie vor viele Unternehmen die
	  Spezifikationen ihrer Treiber der Open Source Gemeinde
	  nicht zur Verfügung, weil sie diese Informationen
	  als Geschäftsgeheimnisse betrachten.  Daher haben die
	  Entwickler von &os; und anderen Betriebssystemen nur
	  zwei Möglichkeiten.  Entweder versuchen sie in einem
	  aufwändigen Prozess den Treiber durch
	  <foreignphrase>Reverse Engineering</foreignphrase>
	  nachzubauen, oder sie versuchen, die vorhandenen
	  Binärtreiber der &microsoft.windows;-Plattform zu
	  verwenden.</para>

	<para>&os; bietet <quote>native</quote> Unterstützung für die
	  <foreignphrase>Network Driver Interface
	    Specification</foreignphrase> (<acronym>NDIS</acronym>).
	  &man.ndisgen.8; wird benutzt, um einen &windowsxp;-Treiber
	  in ein Format zu konvertieren, das von &os; verwendet werden
	  kann.  Da der &man.ndis.4;-Treiber einen
	  &windowsxp;-Binärtreiber nutzt, kann er nur auf &i386;- und
	  amd64-Systemen verwendet werden.  Unterstützt werden
	  <acronym>PCI</acronym>, CardBus, <acronym>PCMCIA</acronym>
	  und <acronym>USB</acronym>-Geräte.</para>

	<para>Um den NDISulator zu verwenden, benötigen Sie drei
	  Dinge:</para>

	<orderedlist>
	  <listitem>
	    <para>Die &os; Kernelquellen</para>
	  </listitem>

	  <listitem>
	    <para>Den &windowsxp;-Binärtreiber mit der Erweiterung
	      <filename>.SYS</filename></para>
	  </listitem>

	  <listitem>
	    <para>Die Konfigurationsdatei des &windowsxp;-Treibers
	      mit der Erweiterung <filename>.INF</filename></para>
	  </listitem>
	</orderedlist>

	<para>Laden Sie die <filename>.SYS</filename>- und
	  <filename>.INF</filename>-Dateien für die Karte.  Diese
	  befinden sich meistens auf einer beigelegten CD-ROM, oder
	  können von der Internetseite des Herstellers
	  heruntergeladen werden.  In den folgenden Beispielen werden
	  die Dateien <filename>W32DRIVER.SYS</filename> und
	  <filename>W32DRIVER.INF</filename> verwendet.</para>

	<para>Die Architektur des Treibers muss zur jeweiligen
	  Version von &os; passen.  Benutzen Sie einen &windows;
	  32-bit Treiber für &os;/i386.  Für &os;/amd64 wird ein
	  &windows; 64-bit Treiber benötigt.</para>

	<para>Als Nächstes kompilieren Sie den binären Treiber, um ein
	  Kernelmodul zu erzeugen.  Dazu rufen Sie als
	  <systemitem class="username">root</systemitem>
	  &man.ndisgen.8; auf:</para>

	<screen>&prompt.root; <userinput>ndisgen <replaceable>/path/to/W32DRIVER.INF</replaceable> <replaceable>/path/to/W32DRIVER.SYS</replaceable></userinput></screen>

	<para>Dieses Kommando arbeitet interaktiv, benötigt es weitere
	  Informationen, so fragt es Sie danach.  Das Ergebnis ist ein
	  neu erzeugtes Kernelmodul im aktuellen Verzeichnis.
	  Benutzen Sie &man.kldload.8; um das neue Modul zu
	  laden:</para>

	<screen>&prompt.root; <userinput>kldload <replaceable>./W32DRIVER.ko</replaceable></userinput></screen>

	<para>Neben dem erzeugten Kernelmodul müssen auch die
	  Kernelmodule <filename>ndis.ko</filename> und
	  <filename>if_ndis.ko</filename> geladen werden.  Dies
	  passiert automatisch, wenn Sie ein von &man.ndis.4;
	  abhängiges Modul laden.  Andernfalls können die Module mit
	  den folgenden Kommandos manuell geladen werden:</para>

	<screen>&prompt.root; <userinput>kldload ndis</userinput>
&prompt.root; <userinput>kldload if_ndis</userinput></screen>

	<para>Der erste Befehl lädt den &man.ndis.4;-Miniport-Treiber,
	  der zweite das tatsächliche Netzwerkgerät.</para>

	<para>Überprüfen Sie die Ausgabe von &man.dmesg.8;
	  auf eventuelle Fehler während des Ladevorgangs.  Gab es
	  dabei keine Probleme, sollte die Ausgabe wie folgt
	  aussehen:</para>

	<screen>ndis0: &lt;Wireless-G PCI Adapter&gt; mem 0xf4100000-0xf4101fff irq 3 at device 8.0 on pci1
ndis0: NDIS API version: 5.0
ndis0: Ethernet address: 0a:b1:2c:d3:4e:f5
ndis0: 11b rates: 1Mbps 2Mbps 5.5Mbps 11Mbps
ndis0: 11g rates: 6Mbps 9Mbps 12Mbps 18Mbps 36Mbps 48Mbps 54Mbps</screen>

	<para>Ab jetzt kann das Gerät <filename>ndis0</filename> wie
	  jede andere Netzwerkkarte konfiguriert werden.</para>

	<para>Um die &man.ndis.4;-Module automatisch beim Systemstart
	  zu laden, kopieren Sie das erzeugte Modul
	  <filename>W32DRIVER_SYS.ko</filename> nach
	  <filename>/boot/modules</filename>.  Danach fügen Sie die
	  folgende Zeile in <filename>/boot/loader.conf</filename>
	  ein:</para>

	<programlisting>W32DRIVER_SYS_load="YES"</programlisting>
      </sect3>
    </sect2>

    <sect2>
      <title>Konfiguration von Netzwerkkarten</title>

      <indexterm>
	<primary>Netzwerkkarten</primary>
	<secondary>einrichten</secondary>
      </indexterm>

      <para>Nachdem der richtige Treiber für die Karte geladen ist,
	muss die Karte konfiguriert werden.  Unter Umständen ist
	die Karte schon während der Installation mit
	&man.bsdinstall.8; konfiguriert worden.</para>

      <para>Das nachstehende Kommando zeigt die Konfiguration der
	Netzwerkkarten an:</para>

      <screen>&prompt.user; <userinput>ifconfig</userinput>
dc0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        options=80008&lt;VLAN_MTU,LINKSTATE&gt;
        ether 00:a0:cc:da:da:da
        inet 192.168.1.3 netmask 0xffffff00 broadcast 192.168.1.255
        media: Ethernet autoselect (100baseTX &lt;full-duplex&gt;)
        status: active
dc1: flags=8802&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        options=80008&lt;VLAN_MTU,LINKSTATE&gt;
        ether 00:a0:cc:da:da:db
        inet 10.0.0.1 netmask 0xffffff00 broadcast 10.0.0.255
        media: Ethernet 10baseT/UTP
        status: no carrier
lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; metric 0 mtu 16384
        options=3&lt;RXCSUM,TXCSUM&gt;
        inet6 fe80::1%lo0 prefixlen 64 scopeid 0x4
        inet6 ::1 prefixlen 128
        inet 127.0.0.1 netmask 0xff000000
        nd6 options=3&lt;PERFORMNUD,ACCEPT_RTADV&gt;</screen>

      <para>Im Beispiel werden Informationen zu den folgenden Geräten
	angezeigt:</para>

      <itemizedlist>
	<listitem>
	  <para><filename>dc0</filename>: Der erste
	    Ethernet-Adapter.</para>
	</listitem>

	<listitem>
	  <para><filename>dc1</filename>: Der zweite
	    Ethernet-Adapter.</para>
	</listitem>

	<listitem>
	  <para><filename>lo0</filename>: Das Loopback-Gerät.</para>
	</listitem>
      </itemizedlist>

      <para>Der Name der Netzwerkkarte wird aus dem Namen des Treibers
	und einer Zahl zusammengesetzt.  Die Zahl gibt die Reihenfolge
	an, in der die Geräte beim Systemstart erkannt wurden.  Die
	dritte Karte, die den &man.sis.4; Treiber benutzt, würde
	beispielsweise <filename>sis2</filename> heißen.</para>

      <para>Der Adapter <filename>dc0</filename> aus dem Beispiel ist
	aktiv.  Sie erkennen das an den folgenden Hinweisen:</para>

      <orderedlist>
	<listitem>
	  <para><literal>UP</literal> bedeutet, dass die Karte
	    konfiguriert und aktiv ist.</para>
	</listitem>

	<listitem>
	  <para>Der Karte wurde die Internet-Adresse
	    (<literal>inet</literal>)
	    <systemitem class="ipaddress">192.168.1.3</systemitem>
	    zugewiesen.</para>
	</listitem>

	<listitem>
	  <para>Die Subnetzmaske ist richtig
	    (<systemitem class="netmask">0xffffff00</systemitem>
	    entspricht <systemitem
	      class="netmask">255.255.255.0</systemitem>).</para>
	</listitem>

	<listitem>
	  <para>Die Broadcast-Adresse
	    <systemitem class="ipaddress">192.168.1.255</systemitem>
	    ist richtig.</para>
	</listitem>

	<listitem>
	  <para>Die MAC-Adresse der Karte (<literal>ether</literal>)
	    lautet <systemitem class="etheraddress">
	      00:a0:cc:da:da:da</systemitem>.</para>
	</listitem>

	<listitem>
	  <para>Die automatische Medienerkennung ist aktiviert
	    (<literal>media: Ethernet autoselect (100baseTX
	      &lt;full-duplex&gt;)</literal>).  Der Adapter
	    <filename>dc1</filename> benutzt das Medium
	    <literal>10baseT/UTP</literal>.  Weitere Informationen
	    über die einstellbaren Medien entnehmen
	    Sie der Hilfeseite des Treibers.</para>
	</listitem>

	<listitem>
	  <para>Der Verbindungsstatus (<literal>status</literal>) ist
	    <literal>active</literal>, das heißt es wurde ein
	    Trägersignal entdeckt.  Für <filename>dc1</filename> wird
	    <literal>status: no carrier</literal> angezeigt.  Das ist
	    normal, wenn kein Kabel an der Karte angeschlossen
	    ist.</para>
	</listitem>
      </orderedlist>

      <para>Wäre die Karte nicht konfiguriert, würde die Ausgabe
	von &man.ifconfig.8; so aussehen:</para>

      <screen>dc0: flags=8843&lt;BROADCAST,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        options=80008&lt;VLAN_MTU,LINKSTATE&gt;
        ether 00:a0:cc:da:da:da
        media: Ethernet autoselect (100baseTX &lt;full-duplex&gt;)
        status: active</screen>

      <para>Die Karte muss als Benutzer <systemitem
	  class="username">root</systemitem> konfiguriert werden.  Die
	Konfiguration kann auf der Kommandozeile mit &man.ifconfig.8;
	erfolgen.  Allerdings gehen diese Informationen bei einem
	Neustart verloren.  Tragen Sie stattdessen die Konfiguration
	in <filename>/etc/rc.conf</filename> ein.  Wenn es im
	<acronym>LAN</acronym> einen <acronym>DHCP</acronym>-Server
	gibt, fügen Sie einfach folgende Zeile hinzu:</para>

      <programlisting>ifconfig_dc0="DHCP"</programlisting>

      <para>Ersetzen Sie <replaceable>>dc0</replaceable> durch die
	richtigen Werte für das System.</para>

      <para>Nachdem Sie die Zeile hinzugefügt haben, folgen Sie den
	Anweisungen in <xref
	  linkend="config-network-testing"/>.</para>

      <note>
	<para>Wenn das Netzwerk während der Installation konfiguriert
	  wurde, existieren vielleicht schon Einträge für die
	  Netzwerkkarte(n).  Überprüfen Sie
	  <filename>/etc/rc.conf</filename> bevor Sie weitere Zeilen
	  hinzufügen.</para>
      </note>

      <para>Falls kein <acronym>DHCP</acronym>-Server zur Verfügung
	steht, müssen die Netzwerkkarten manuell konfiguriert werden.
	Fügen Sie für jede Karte im System eine Zeile hinzu, wie in
	diesem Beispiel zu sehen:</para>

      <programlisting>ifconfig_dc0="inet 192.168.1.3 netmask 255.255.255.0"
ifconfig_dc1="inet 10.0.0.1 netmask 255.255.255.0 media 10baseT/UTP"</programlisting>

      <para>Ersetzen Sie <filename>dc0</filename> und
	<filename>dc1</filename> und die
	<acronym>IP</acronym>-Adressen durch die richtigen Werte für
	das System.  Die Manualpages des Treibers, &man.ifconfig.8;
	und &man.rc.conf.5; enthalten weitere Einzelheiten über
	verfügbare Optionen und die Syntax von
	<filename>/etc/rc.conf</filename>.</para>

      <para>Wenn das Netzwerk kein <acronym>DNS</acronym> benutzt,
	können Sie in <filename>/etc/hosts</filename> die Namen und
	<acronym>IP</acronym>-Adressen der Rechner des
	<acronym>LAN</acronym>s eintragen.  Weitere Informationen
	entnehmen Sie &man.hosts.5; und
	<filename>/usr/share/examples/etc/hosts</filename>.</para>

      <note>
	<para>Falls kein <acronym>DHCP</acronym>-Server zur Verfügung
	  steht, Sie aber Zugang zum Internet benötigen, müssen Sie
	  das Standard-Gateway und die Nameserver manuell
	  konfigurieren:</para>

	<screen>&prompt.root; <userinput>echo 'defaultrouter="<replaceable>Ihr_Default_Gateway</replaceable>"' &gt;&gt; /etc/rc.conf</userinput>
&prompt.root; <userinput>echo 'nameserver <replaceable>Ihr_DNS_Server</replaceable>' &gt;&gt; /etc/resolv.conf</userinput></screen>
      </note>
    </sect2>

    <sect2 xml:id="config-network-testing">
      <title>Test und Fehlersuche</title>

      <para>Nachdem die notwendigen Änderungen in
	<filename>/etc/rc.conf</filename> gespeichert wurden, kann das
	System neu gestartet werden, um die Konfiguration zu testen
	und zu überprüfen, ob das System ohne Fehler neu gestartet
	wurde.  Alternativ können Sie mit folgenden Befehl die
	Netzwerkeinstellungen neu initialisieren:</para>

      <screen>&prompt.root; <userinput>service netif restart</userinput></screen>

      <note>
	<para>Falls in <filename>/etc/rc.conf</filename> ein
	  Default-Gateway definiert wurde, müssen Sie auch den
	  folgenden Befehl ausführen:</para>

	<screen>&prompt.root; <userinput>service routing restart</userinput></screen>
      </note>

      <para>Wenn das System gestartet ist, sollten Sie die
	Netzwerkkarten testen.</para>

      <sect3>
	<title>Test der Ethernet-Karte</title>

	<indexterm>
	  <primary>Netzwerkkarten</primary>
	  <secondary>testen</secondary>
	</indexterm>

	<para>Um zu prüfen, ob die Ethernet-Karte richtig konfiguriert
	  ist, testen Sie zunächst mit &man.ping.8; den Adapter selbst
	  und sprechen Sie dann eine andere Maschine im
	  <acronym>LAN</acronym> an.</para>

	<para>Zuerst, der Test des Adapters:</para>

	<screen>&prompt.user; <userinput>ping -c5 192.168.1.3</userinput>
PING 192.168.1.3 (192.168.1.3): 56 data bytes
64 bytes from 192.168.1.3: icmp_seq=0 ttl=64 time=0.082 ms
64 bytes from 192.168.1.3: icmp_seq=1 ttl=64 time=0.074 ms
64 bytes from 192.168.1.3: icmp_seq=2 ttl=64 time=0.076 ms
64 bytes from 192.168.1.3: icmp_seq=3 ttl=64 time=0.108 ms
64 bytes from 192.168.1.3: icmp_seq=4 ttl=64 time=0.076 ms

--- 192.168.1.3 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.074/0.083/0.108/0.013 ms</screen>

<screen>&prompt.user; <userinput>ping -c5 192.168.1.2</userinput>
PING 192.168.1.2 (192.168.1.2): 56 data bytes
64 bytes from 192.168.1.2: icmp_seq=0 ttl=64 time=0.726 ms
64 bytes from 192.168.1.2: icmp_seq=1 ttl=64 time=0.766 ms
64 bytes from 192.168.1.2: icmp_seq=2 ttl=64 time=0.700 ms
64 bytes from 192.168.1.2: icmp_seq=3 ttl=64 time=0.747 ms
64 bytes from 192.168.1.2: icmp_seq=4 ttl=64 time=0.704 ms

--- 192.168.1.2 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.700/0.729/0.766/0.025 ms</screen>

	<para>Um die Namensauflösung zu testen, verwenden Sie den
	  Namen der Maschine anstelle der
	  <acronym>IP</acronym>-Adresse.  Wenn kein
	  <acronym>DNS</acronym>-Server im Netzwerk vorhanden ist,
	  muss <filename>/etc/hosts</filename> entsprechend
	  eingerichtet sein.  Fügen Sie dazu die Namen und
	  <acronym>IP</acronym>-Adressen der Rechner im
	  <acronym>LAN</acronym> in <filename>/etc/hosts</filename>
	  hinzu, falls sie nicht bereits vorhanden sind.  Weitere
	  Informationen finden Sie in &man.hosts.5; und
	  <filename>/usr/share/examples/etc/hosts</filename>.</para>
      </sect3>

      <sect3>
	<title>Fehlersuche</title>

	<indexterm>
	  <primary>Netzwerkkarten</primary>
	  <secondary>Fehlersuche</secondary>
	</indexterm>

	<para>Fehler zu beheben, ist immer sehr mühsam.
	  Indem Sie die einfachen Sachen zuerst prüfen,
	  erleichtern Sie sich die Aufgabe.  Steckt das Netzwerkkabel?
	  Sind die Netzwerkdienste richtig konfiguriert?  Funktioniert
	  die Firewall?  Wird die Netzwerkkarte von &os;
	  unterstützt?  Lesen Sie immer die Hardware-Informationen
	  des Releases, bevor Sie einen Fehlerbericht einsenden.
	  Aktualisieren Sie die &os;-Version auf die neueste -STABLE
	  Version.  Suchen Sie in den Archiven der Mailinglisten
	  und im Internet nach bekannten Lösungen.</para>

	<para>Wenn die Karte funktioniert, die Verbindungen aber
	  zu langsam sind, sollten Sie &man.tuning.7; lesen.  Prüfen
	  Sie auch die Netzwerkkonfiguration, da falsche Einstellungen
	  die Ursache für langsame Verbindungen sein können.</para>

	<para>Wenn Sie viele <errorname>device timeout</errorname>
	  Meldungen in den Systemprotokollen finden, prüfen
	  Sie, dass es keinen Konflikt zwischen der Netzwerkkarte
	  und anderen Geräten des Systems gibt.
	  Überprüfen Sie nochmals die Verkabelung.
	  Unter Umständen benötigen Sie eine andere
	  Netzwerkkarte.</para>

	<para>Bei <errorname>watchdog timeout</errorname>
	  Fehlermeldungen, kontrollieren Sie zuerst die Verkabelung.
	  Überprüfen Sie dann, ob der
	  <acronym>PCI</acronym>-Steckplatz der
	  Karte Bus Mastering unterstützt.  Auf einigen
	  älteren Motherboards ist das nur für einen
	  Steckplatz (meistens Steckplatz 0) der Fall.  Lesen Sie
	  in der Dokumentation der Karte und des Motherboards
	  nach, ob das vielleicht die Ursache des Problems sein
	  könnte.</para>

	<para>Die Meldung <errorname>No route to host</errorname>
	  erscheint, wenn das System ein Paket nicht zustellen
	  kann.  Das kann vorkommen weil beispielsweise keine
	  Default-Route gesetzt wurde oder das Netzwerkkabel
	  nicht richtig steckt.  Schauen Sie in der Ausgabe
	  von <command>netstat -rn</command> nach, ob eine
	  gültige Route zu dem Zielsystem existiert.  Wenn nicht,
	  lesen Sie <xref linkend="network-routing"/>.</para>

	<para>Die Meldung <errorname>ping: sendto: Permission
	    denied</errorname> wird oft von einer falsch
	  konfigurierten Firewall verursacht.  Wenn keine Regeln
	  definiert wurden, blockiert eine aktivierte Firewall alle
	  Pakete, selbst einfache &man.ping.8;-Pakete.
	  Weitere Informationen erhalten Sie
	  in <xref linkend="firewalls"/>.</para>

	<para>Falls die Leistung der Karte schlecht ist, setzen
	  Sie die Medienerkennung von <literal>autoselect</literal>
	  (automatisch) auf das richtige Medium.  In vielen Fällen
	  löst diese Maßnahme Leistungsprobleme.  Wenn
	  nicht, prüfen Sie nochmal die Netzwerkeinstellungen
	  und lesen Sie &man.tuning.7;.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="configtuning-virtual-hosts">
    <title>Virtual Hosts</title>

    <indexterm><primary>virtual hosts</primary></indexterm>
    <indexterm>
      <primary><acronym>IP</acronym>-Aliase</primary>
    </indexterm>

    <para>Ein gebräuchlicher Zweck von &os; ist das
      virtuelle Hosting, bei dem ein Server im Netzwerk wie
      mehrere Server aussieht.  Dies wird dadurch erreicht,
      dass einem Netzwerkinterface mehrere Netzwerk-Adressen
      zugewiesen werden.</para>

    <para>Ein Netzwerkinterface hat eine <quote>echte</quote>
      Adresse und kann beliebig viele <quote>alias</quote> Adressen
      haben.  Die Aliase werden durch entsprechende alias Einträge
      in <filename>/etc/rc.conf</filename> festgelegt, wie in diesem
      Beispiel zu sehen ist:</para>

    <programlisting>ifconfig_fxp0_alias0="inet xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx"</programlisting>

    <para>Beachten Sie, dass die Alias-Einträge mit
      <literal>alias<replaceable>0</replaceable></literal> anfangen
      müssen und weiter hochgezählt werden, das heißt
      <literal>alias1</literal>, <literal>alias2</literal>, und so
      weiter.  Die Konfiguration der Aliase hört bei der ersten
      fehlenden Zahl auf.</para>

    <para>Die Berechnung der Alias-Netzwerkmasken ist wichtig.  Für
      jedes Interface muss es eine Adresse geben, die die
      Netzwerkmaske des Netzwerkes richtig beschreibt.  Alle anderen
      Adressen in diesem Netzwerk haben dann eine Netzwerkmaske, die
      mit <literal>1</literal> gefüllt ist, also <systemitem
	class="netmask">255.255.255.255</systemitem> oder hexadezimal
      <systemitem class="netmask">0xffffffff</systemitem>.</para>

    <para>Als Beispiel betrachten wir den Fall, in dem
      <filename>fxp0</filename> mit zwei Netzwerken verbunden
      ist: dem Netzwerk
      <systemitem class="ipaddress">10.1.1.0</systemitem> mit der
      Netzwerkmaske
      <systemitem class="netmask">255.255.255.0</systemitem> und dem
      Netzwerk <systemitem class="ipaddress">202.0.75.16</systemitem>
      mit der Netzwerkmaske
      <systemitem class="netmask">255.255.255.240</systemitem>.  Das
      System soll die Adressen
      <systemitem class="ipaddress">10.1.1.1</systemitem> bis
      <systemitem class="ipaddress">10.1.1.5</systemitem> und
      <systemitem class="ipaddress">202.0.75.17</systemitem> bis
      <systemitem class="ipaddress">202.0.75.20</systemitem> belegen.
      Nur die erste Adresse in einem Netzwerk sollte die richtige
      Netzwerkmaske haben.  Alle anderen Adressen
      (<systemitem class="ipaddress">10.1.1.2</systemitem> bis
      <systemitem class="ipaddress">10.1.1.5</systemitem> und
      <systemitem class="ipaddress">202.0.75.18</systemitem> bis
      <systemitem class="ipaddress">202.0.75.20</systemitem>) müssen
      die Maske <systemitem class="netmask">
	255.255.255.255</systemitem> erhalten.</para>

    <para>Die folgenden Einträge in
      <filename>/etc/rc.conf</filename> konfigurieren den Adapter
      entsprechend dem Beispiel:</para>

    <programlisting>ifconfig_fxp0="inet 10.1.1.1 netmask 255.255.255.0"
ifconfig_fxp0_alias0="inet 10.1.1.2 netmask 255.255.255.255"
ifconfig_fxp0_alias1="inet 10.1.1.3 netmask 255.255.255.255"
ifconfig_fxp0_alias2="inet 10.1.1.4 netmask 255.255.255.255"
ifconfig_fxp0_alias3="inet 10.1.1.5 netmask 255.255.255.255"
ifconfig_fxp0_alias4="inet 202.0.75.17 netmask 255.255.255.240"
ifconfig_fxp0_alias5="inet 202.0.75.18 netmask 255.255.255.255"
ifconfig_fxp0_alias6="inet 202.0.75.19 netmask 255.255.255.255"
ifconfig_fxp0_alias7="inet 202.0.75.20 netmask 255.255.255.255"</programlisting>

    <para>Dies kann mit einer durch Leerzeichen getrennten Liste
      von <acronym>IP</acronym>-Adressbereichen auch einfacher
      ausgedrückt werden.  Die erste Adresse hat wieder die angegebene
      Netzwerkmaske und die zusätzlichen Adressen haben die
      Netzwerkmaske <literal>255.255.255.255</literal>.</para>

    <programlisting>ifconfig_fxp0_aliases="inet 10.1.1.1-5/24 inet 202.0.75.17-20/28"</programlisting>
  </sect1>

  <sect1 xml:id="configtuning-syslog">
    <info>
      <title>Konfiguration der Systemprotokollierung</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Niclas</firstname>
	    <surname>Zeising</surname>
	  </personname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm><primary>system logging</primary></indexterm>
    <indexterm><primary>syslog</primary></indexterm>
    <indexterm><primary>&man.syslogd.8;</primary></indexterm>

    <para>Die Aufzeichnung und Kontrolle von Log-Meldungen ist ein
      wichtiger Aspekt der Systemadministration.  Die Informationen
      werden nicht nur verwendet um Hard- und Softwarefehler ausfindig
      zu machen, auch zur Überwachung der Sicherheit und der Reaktion
      bei einem Zwischenfall spielen diese Aufzeichnungen eine
      wichtige Rolle.  Die meisten Systemdienste und Anwendungen
      erzeugen Log-Meldungen.</para>

    <para>&os; stellt mit <application>syslogd</application> ein
      Werkzeug zur Verwaltung von Protokollen bereit.  In der
      Voreinstellung wird <application>syslogd</application> beim
      Booten automatisch gestartet.  Dieses Verhalten wird über die
      Variable <literal>syslogd_enable</literal> in
      <filename>/etc/rc.conf</filename> gesteuert.  Dazu gibt es noch
      zahlreiche Argumente, die in der Variable
      <literal>syslogd_flags</literal> in
      <filename>/etc/rc.conf</filename> gesetzt werden können.  Lesen
      Sie &man.syslogd.8; für weitere Informationen über die
      verfügbaren Argumente.</para>

    <para>Dieser Abschnitt beschreibt die Konfiguration und Verwendung
      des &os; Protokollservers, und diskutiert auch die Log-Rotation
      und das Management von Logdateien.</para>

    <sect2>
      <title>Konfiguration der lokalen Protokollierung</title>

      <indexterm><primary>syslog.conf</primary></indexterm>

      <para>Die Konfigurationsdatei
	<filename>/etc/syslog.conf</filename> steuert, was
	<application>syslogd</application> mit Log-Meldungen macht,
	sobald sie empfangen werden.  Es gibt verschiedene Parameter,
	die das Verhalten bei eingehenden Ereignissen kontrollieren.
	<foreignphrase>facility</foreignphrase> beschreibt das
	Subsystem, welches das Ereignis generiert hat.  Beispielsweise
	der Kernel, oder ein Daemon.
	<foreignphrase>level</foreignphrase> hingegen beschreibt den
	Schweregrad des aufgetretenen Ereignisses.  Dies macht es
	möglich, Meldungen in verschiedenen Logdateien zu
	protokollieren, oder Meldungen zu verwerfen, je nach
	Konfiguration von <foreignphrase>facility</foreignphrase> und
	<foreignphrase>level</foreignphrase>.  Ebenfalls besteht die
	Möglichkeit auf Meldungen zu reagieren, die von einer
	bestimmten Anwendung stammen, oder von einem
	spezifischen Host erzeugt wurden.</para>

      <para>Die Konfigurationsdatei von &man.syslogd.8; enthält für
	jede Aktion eine Zeile.  Die Syntax besteht aus einem
	Auswahlfeld, gefolgt von einem Aktionsfeld.  Die Syntax für
	das Auswahlfeld ist <replaceable>facility.level</replaceable>.
	Dies entspricht Log-Meldungen von
	<replaceable>facility</replaceable> mit einem Level von
	<replaceable>level</replaceable> oder höher.  Um noch präziser
	festzulegen was protokolliert wird, kann dem Level optional
	ein Vergleichsflag vorangestellt werden.  Mehrere Auswahlen
	können, durch Semikolon (<literal>;</literal>) getrennt, für
	die gleiche Aktion verwendet werden.  <literal>*</literal>
	wählt dabei alles aus.  Das Aktionsfeld definiert, wohin die
	Log-Meldungen gesendet werden, beispielsweise in eine Datei
	oder zu einem entfernten Log-Server.  Als Beispiel dient hier
	<filename>/etc/syslog.conf</filename> aus &os;:</para>

      <programlisting># <phrase its:translate="no">&dollar;&os;&dollar;</phrase>
#
#       Spaces ARE valid field separators in this file. However,
#       other *nix-like systems still insist on using tabs as field
#       separators. If you are sharing this file between systems, you$
#       may want to use only tabs as field separators here.
#       Consult the syslog.conf(5) manpage.
*.err;kern.warning;auth.notice;mail.crit                /dev/console
*.notice;authpriv.none;kern.debug;lpr.info;mail.crit;news.err   /var/log/messages
security.*                                      /var/log/security
auth.info;authpriv.info                         /var/log/auth.log
mail.info                                       /var/log/maillog
lpr.info                                        /var/log/lpd-errs
ftp.info                                        /var/log/xferlog
cron.*                                          /var/log/cron
!-devd
*.=debug                                        /var/log/debug.log
*.emerg                                         *
# uncomment this to log all writes to /dev/console to /var/log/console.log
#console.info                                   /var/log/console.log
# uncomment this to enable logging of all log messages to /var/log/all.log
# touch /var/log/all.log and chmod it to mode 600 before it will work
#*.*                                            /var/log/all.log
# uncomment this to enable logging to a remote loghost named loghost
#*.*                                            @loghost
# uncomment these if you're running inn
# news.crit                                     /var/log/news/news.crit
# news.err                                      /var/log/news/news.err
# news.notice                                   /var/log/news/news.notice
# Uncomment this if you wish to see messages produced by devd
# !devd
# *.>=info
!ppp
*.*                                             /var/log/ppp.log
!*</programlisting>

      <para>In diesem Beispiel:</para>

      <itemizedlist>
	<listitem>
	  <para>Zeile 8 selektiert alle Meldungen vom Level
	    <literal>err</literal>, sowie
	    <literal>kern.warning</literal>,
	    <literal>auth.notice</literal> und
	    <literal>mail.crit</literal> und schickt diese zur Konsole
	    (<filename>/dev/console</filename>).</para>
	</listitem>

	<listitem>
	  <para>Zeile 12 selektiert alle Meldungen von
	    <literal>mail</literal> ab dem Level
	    <literal>info</literal> oder höher und schreibt diese in
	    <filename>/var/log/maillog</filename>.</para>
	</listitem>

	<listitem>
	  <para>Zeile 17 benutzt ein Vergleichsflag
	    (<literal>=</literal>), um nur Meldungen vom Level
	    <literal>debug</literal> zu selektieren und schreibt
	    diese in <filename>/var/log/debug.log</filename>.</para>
	</listitem>

	<listitem>
	  <para>Zeile 33 zeigt ein Beispiel für die Nutzung einer
	    Programmspezifikation.  Die
	    nachfolgenden Regeln sind dann nur für Programme gültig,
	    welche der Programmspezifikation stehen.  In diesem Fall
	    werden alle Meldungen von <application>ppp</application>
	    (und keinem anderen Programm) in
	    <filename>/var/log/ppp.log</filename> geschrieben.</para>
	</listitem>
      </itemizedlist>

      <para>Die verfügbaren <foreignphrase>level</foreignphrase>,
	beginnend mit den höchst kritischen, hin zu den weniger
	kritischen, sind:
	<literal>emerg</literal>, <literal>alert</literal>,
	<literal>crit</literal>, <literal>err</literal>,
	<literal>warning</literal>, <literal>notice</literal>,
	<literal>info</literal> und
	<literal>debug</literal>.</para>

      <para>Die <foreignphrase>facilities</foreignphrase>, in
	beliebiger Reihenfolge, sind: <literal>auth</literal>,
	<literal>authpriv</literal>, <literal>console</literal>,
	<literal>cron</literal>, <literal>daemon</literal>,
	<literal>ftp</literal>, <literal>kern</literal>,
	<literal>lpr</literal>, <literal>mail</literal>,
	<literal>mark</literal>, <literal>news</literal>,
	<literal>security</literal>, <literal>syslog</literal>,
	<literal>user</literal>, <literal>uucp</literal>, sowie
	<literal>local0</literal> bis <literal>local7</literal>.
	Beachten Sie, dass andere Betriebssysteme hiervon abweichende
	<foreignphrase>facilities</foreignphrase> haben
	können.</para>

      <para>Um alle Meldungen vom Level <literal>notice</literal> und
	höher in <filename>/var/log/daemon.log</filename> zu
	protokollieren, fügen Sie folgenden Eintrag hinzu:</para>

      <programlisting>daemon.notice                                        /var/log/daemon.log</programlisting>

      <para>Für weitere Informationen zu verschiedenen Level und
	<foreignphrase>faclilities</foreignphrase>, lesen Sie
	&man.syslog.3; und &man.syslogd.8;.  Weitere Informationen
	zu <filename>/etc/syslog.conf</filename>, dessen Syntax und
	erweiterten Anwendungsbeispielen, finden Sie in
	&man.syslog.conf.5;.</para>
    </sect2>

    <sect2>
      <title>Management und Rotation von Logdateien</title>

      <indexterm><primary>newsyslog</primary></indexterm>
      <indexterm><primary>newsyslog.conf</primary></indexterm>
      <indexterm><primary>log rotation</primary></indexterm>
      <indexterm><primary>log management</primary></indexterm>

      <para>Logdateien können schnell wachsen und viel Speicherplatz
	belegen, was es schwieriger macht, nützliche Informationen
	zu finden.  Log-Management versucht,
	diesen Effekt zu mildern.  &os; verwendet
	<application>newsyslog</application> für die Verwaltung von
	Logdateien.  Dieses in &os; integrierte Programm
	rotiert und komprimiert in regelmäßigen Abständen Logdateien.
	Optional kann es auch fehlende Logdateien erstellen und
	Programme benachrichtigen, wenn Logdateien verschoben wurden.
	Die Logdateien können von <application>syslogd</application>
	oder einem anderen Programm generiert werden.  Obwohl
	<application>newsyslog</application> normalerweise von
	&man.cron.8; aufgerufen wird, ist es kein Systemdämon.  In der
	Standardkonfiguration wird dieser Job jede Stunde
	ausgeführt.</para>

      <para>Um zu wissen, welche Maßnahmen zu ergreifen sind, liest
	<application>newsyslog</application> seine Konfigurationsdatei
	<filename>/etc/newsyslog.conf</filename>.  Diese
	Konfigurationsdatei enthält eine Zeile für jede Datei, die von
	<application>newsyslog</application> verwaltet wird.  Jede
	Zeile enthält Informationen über den Besitzer der Datei, die
	Dateiberechtigungen, wann die Datei rotiert wird, optionale
	<foreignphrase>Flags</foreignphrase>, welche die Log-Rotation
	beeinflussen (bspw. Komprimierung) und Programme, denen ein
	Signal geschickt wird, wenn Logdateien rotiert werden.  Hier
	folgt die Standardkonfiguration in &os;:</para>

      <programlisting># configuration file for newsyslog
# <phrase its:translate="no">&dollar;FreeBSD&dollar;</phrase>
#
# Entries which do not specify the '/pid_file' field will cause the
# syslogd process to be signalled when that log file is rotated.  This
# action is only appropriate for log files which are written to by the
# syslogd process (ie, files listed in /etc/syslog.conf).  If there
# is no process which needs to be signalled when a given log file is
# rotated, then the entry for that file should include the 'N' flag.
#
# The 'flags' field is one or more of the letters: BCDGJNUXZ or a '-'.
#
# Note: some sites will want to select more restrictive protections than the
# defaults.  In particular, it may be desirable to switch many of the 644
# entries to 640 or 600.  For example, some sites will consider the
# contents of maillog, messages, and lpd-errs to be confidential.  In the
# future, these defaults may change to more conservative ones.
#
# logfilename          [owner:group]    mode count size when  flags [/pid_file] [sig_num]
/var/log/all.log                        600  7     *    @T00  J
/var/log/amd.log                        644  7     100  *     J
/var/log/auth.log                       600  7     100  @0101T JC
/var/log/console.log                    600  5     100  *     J
/var/log/cron                           600  3     100  *     JC
/var/log/daily.log                      640  7     *    @T00  JN
/var/log/debug.log                      600  7     100  *     JC
/var/log/kerberos.log                   600  7     100  *     J
/var/log/lpd-errs                       644  7     100  *     JC
/var/log/maillog                        640  7     *    @T00  JC
/var/log/messages                       644  5     100  @0101T JC
/var/log/monthly.log                    640  12    *    $M1D0 JN
/var/log/pflog                          600  3     100  *     JB    /var/run/pflogd.pid
/var/log/ppp.log        root:network    640  3     100  *     JC
/var/log/devd.log                       644  3     100  *     JC
/var/log/security                       600  10    100  *     JC
/var/log/sendmail.st                    640  10    *    168   B
/var/log/utx.log                        644  3     *    @01T05 B
/var/log/weekly.log                     640  5     1    $W6D0 JN
/var/log/xferlog                        600  7     100  *     JC</programlisting>

      <para>Jede Zeile beginnt mit dem Namen der Protokolldatei, die
	rotiert werden soll, optional gefolgt von Besitzer und Gruppe
	für rotierende, als auch für neu erstellte Dateien.  Das Feld
	<literal>mode</literal> definiert die Zugriffsrechte der
	Datei.  <literal>count</literal> gibt an, wie viele rotierte
	Dateien aufbewahrt werden sollen.  Anhand der
	<literal>size</literal>- und
	<literal>when</literal>-<foreignphrase>Flags</foreignphrase>
	erkennt <application>newsyslog</application>, wann die Datei
	rotiert werden muss.  Eine Logdatei wird rotiert, wenn ihre
	Größe den Wert von <literal>size</literal> überschreitet, oder
	wenn die Zeit im <literal>when</literal>-Feld abgelaufen ist.
	Ein <literal>*</literal> bedeutet, dass dieses Feld ignoriert
	wird.  Das <replaceable>flags</replaceable>-Feld gibt
	<application>newsyslog</application> weitere Instruktionen,
	zum Beispiel wie eine Datei zu rotieren ist, oder eine Datei
	zu erstellen falls diese nicht existiert.  Die letzten beiden
	Felder sind optional und bestimmen die
	<acronym>PID</acronym>-Datei und wann die Datei rotiert
	wird.</para>

      <para>Weitere Informationen zu allen Feldern, gültigen
	<foreignphrase>Flags</foreignphrase> und wie Sie die
	Rotationszeit angeben können, finden Sie in
	&man.newsyslog.conf.5;.  Denken Sie daran, dass
	<application>newsyslog</application> von &man.cron.8;
	aufgerufen wird und somit Dateien auch nur dann rotiert, wenn
	es von &man.cron.8; aufgerufen wird, und nicht
	häufiger.</para>
    </sect2>

    <sect2 xml:id="network-syslogd">
      <info>
	<title>Protokollierung von anderen Hosts</title>

	<authorgroup>
	  <author>
	    <personname>
	      <firstname>Tom</firstname>
	      <surname>Rhodes</surname>
	    </personname>
	    <contrib>Beigetragen von </contrib>
	  </author>
	</authorgroup>
	<authorgroup>
	  <author>
	    <personname>
	      <firstname>Benedict</firstname>
	      <surname>Reuschling</surname>
	    </personname>
	    <contrib>Übersetzt von </contrib>
	  </author>
	</authorgroup>
      </info>

      <para>Die Überwachung der Protokolldateien kann bei steigender
	Anzahl von Rechnern sehr unhandlich werden.  Eine zentrale
	Protokollierung kann manche administrativen Belastungen bei
	der Verwaltung von Protokolldateien reduzieren.</para>

      <para>Die Aggregation, Zusammenführung und Rotation von
	Protokolldateien kann in &os; mit
	<application>syslogd</application> und
	<application>newsyslog</application> konfiguriert werden.  In
	der folgenden Beispielkonfiguration sammelt Host
	<systemitem>A</systemitem>, genannt <systemitem
	  class="fqdomainname">logserv.example.com</systemitem>,
	Protokollinformationen für das lokale Netzwerk.  Host
	<systemitem>B</systemitem>, genannt <systemitem
	  class="fqdomainname">logclient.example.com</systemitem> wird
	seine Protokollinformationen an den Server
	weiterleiten.</para>

      <sect3>
	<title>Konfiguration des Protokollservers</title>

	<para>Ein Protokollserver ist ein System, welches
	  Protokollinformationen von anderen Hosts akzeptiert.  Bevor
	  Sie diesen Server konfigurieren, prüfen Sie
	  folgendes:</para>

	<itemizedlist>
	  <listitem>
	    <para>Falls eine Firewall zwischen dem
	      Protokollserver und den -Clients steht, muss das
	      Regelwerk der Firewall <acronym>UDP</acronym> auf Port
	      514 sowohl auf Client- als auch auf Serverseite
	      freigegeben werden.</para>
	  </listitem>

	  <listitem>
	    <para>Der <command>syslogd</command>-Server und alle
	      Clientrechner müssen gültige Einträge für sowohl
	      Vorwärts- als auch Umkehr-<acronym>DNS</acronym>
	      besitzen.  Falls im Netzwerk kein
	      <acronym>DNS</acronym>-Server vorhanden ist, muss auf
	      jedem System die Datei <filename>/etc/hosts</filename>
	      mit den richtigen Einträgen gepflegt werden.  Eine
	      funktionierende Namensauflösung ist zwingend
	      erforderlich, ansonsten würde der Server die
	      Protokollnachrichten ablehnen.</para>
	  </listitem>
	</itemizedlist>

	<para>Bearbeiten Sie <filename>/etc/syslog.conf</filename> auf
	  dem Server.  Tragen Sie den Namen des Clients ein, den
	  Verbindungsweg und den Namen der Protokolldatei.  Dieses
	  Beispiel verwendet den Rechnernamen
	  <systemitem>B</systemitem>, alle Verbindungswege, und die
	  Protokolle werden in
	  <filename>/var/log/logclient.log</filename>
	  gespeichert.</para>

	<example>
	  <title>Einfache Server Konfiguration</title>

	  <programlisting>+logclient.example.com
*.*     /var/log/logclient.log</programlisting>
	</example>

	<para>Fügen Sie für jeden Client zwei Zeilen hinzu, falls Sie
	  mehrere Clients in diese Datei aufnehmen.  Weitere
	  Informationen über die verfügbaren Verbindungswege finden
	  Sie in &man.syslog.conf.5;.</para>

	<para>Konfigurieren Sie als nächstes
	  <filename>/etc/rc.conf</filename>:</para>

	<programlisting>syslogd_enable="YES"
syslogd_flags="-a logclient.example.com -v -v"</programlisting>

	<para>Der erste Eintrag startet <command>syslogd</command>
	  während des Bootens.  Der zweite Eintrag erlaubt es, Daten
	  von dem spezifizierten Client auf diesem Server zu
	  akzeptieren.  Die Verwendung von <option>-v -v</option>
	  erhöht die Anzahl von Protokollnachrichten.  Dies ist
	  hilfreich für die Feineinstellung der Verbindungswege, da
	  Administratoren auf diese Weise erkennen, welche Arten von
	  Nachrichten von welchen Verbindungswegen protokolliert
	  werden.</para>

	<para>Mehrere <option>-a</option>-Optionen können angegeben
	  werden, um die Protokollierung von mehreren Clients zu
	  erlauben.  <acronym>IP</acronym>-Adressen und ganze
	  Netzblöcke können ebenfalls spezifiziert werden.  Eine
	  vollständige Liste der Optionen finden Sie in
	  &man.syslogd.8;.</para>

	<para>Zum Schluss muss die Protokolldatei erstellt
	  werden:</para>

	<screen>&prompt.root; <userinput><command>touch</command> /var/log/logclient.log</userinput></screen>

	<para>Zu diesem Zeitpunkt sollte <command>syslogd</command>
	  neu gestartet und überprüft werden:</para>

	<screen>&prompt.root; <userinput>service <command>syslogd</command> restart</userinput>
&prompt.root; <userinput><command>pgrep</command> syslog</userinput></screen>

	<para>Wenn eine <acronym>PID</acronym> zurückgegeben wird,
	  wurde der Server erfolgreich neu gestartet und die
	  Clientkonfiguration kann beginnen.  Wenn der Server nicht
	  neu gestartet wurde, suchen Sie in
	  <filename>/var/log/messages</filename> nach dem
	  Fehler.</para>
      </sect3>

      <sect3>
	<title>Konfiguration des Protokollclients</title>

	<para>Ein Protokollclient sendet Protokollinformationen
	  an einen Protokollserver.  Zusätzlich behält er eine
	  lokale Kopie seiner eigenen Protokolle.</para>

	<para>Sobald der Server konfiguriert ist, bearbeiten Sie
	  <filename>/etc/rc.conf</filename> auf dem Client:</para>

	<programlisting>syslogd_enable="YES"
syslogd_flags="-s -v -v"</programlisting>

	<para>Der erste Eintrag aktiviert den
	  <command>syslogd</command>-Dienst während des Systemstarts.
	  Der zweite Eintrag erhöht die Anzahl der
	  Protokollnachrichten.  Die Option <option>-s</option>
	  verhindert, dass dieser Client Protokolle von anderen
	  Hosts akzeptiert.</para>

	<para>Als nächstes muss der Protokollserver in der
	  <filename>/etc/syslog.conf</filename> des Clients
	  eingetragen werden.  In diesem Beispiel wird das
	  <literal>@</literal>-Symbol benutzt, um sämtliche
	  Protokolldaten an einen bestimmten Server zu senden:</para>

	<programlisting>*.*               @logserv.example.com</programlisting>

	<para>Nachdem die Änderungs gespeichert wurden, muss
	  <command>syslogd</command> neu gestartet werden, damit die
	  Änderungen wirksam werden:</para>

	<screen>&prompt.root; <userinput>service syslogd restart</userinput></screen>

	<para>Um zu testen, ob Protokollnachrichten über das Netzwerk
	  gesendet werden, kann &man.logger.1; auf dem Client benutzt
	  werden, um eine Nachricht an
	  <application>syslogd</application> zu schicken:</para>

	<screen>&prompt.root; <userinput><command>logger</command> "<replaceable>Test message from logclient</replaceable>"</userinput></screen>

	<para>Diese Nachricht sollte jetzt sowohl in
	  <filename>/var/log/messages</filename> auf dem Client, als
	  auch in <filename>/var/log/logclient.log</filename> auf dem
	  Server vorhanden sein.</para>
      </sect3>

      <sect3>
	<title>Fehlerbehebung beim Protokollserver</title>

	<para>Wenn der Server keine Nachrichten empfängt, ist die
	  Ursache wahrscheinlich ein Netzwerkproblem, ein Problem bei
	  der Namensauflösung oder ein Tippfehler in einer
	  Konfigurationsdatei.  Um die Ursache zu isolieren, müssen
	  Sie sicherstellen, dass sich Server und Client über den in
	  <filename>/etc/rc.conf</filename> konfigurierten Hostnamen
	  mit <command>ping</command> erreichen lässt.  Falls dies
	  nicht gelingt sollten Sie die Netzwerkverkabelung
	  überprüfen, außerdem Firewallregeln sowie die Einträge für
	  Hosts im <acronym>DNS</acronym> und
	  <filename>/etc/hosts</filename>.  Überprüfen Sie diese Dinge
	  auf dem Server und dem Client, bis der
	  <command>ping</command> von beiden Hosts erfolgreich
	  ist.</para>

	<para>Wenn sich die Hosts gegenseitig mit
	  <command>ping</command> erreichen können, der Server aber
	  immer noch keine Nachrichten empfängt, können Sie
	  vorübergehend die Ausführlichkeit der Protokollierung
	  erhöhen, um die Ursache für das Problem weiter einzugrenzen.
	  In dem folgenden Beispiel ist auf dem Server die Datei
	  <filename>/var/log/logclient.log</filename> leer und in der
	  Datei <filename>/var/log/messages</filename> auf dem Client
	  ist keine Ursache für das Problem erkennbar.  Um nun die
	  Ausführlichkeit der Protokollierung zu erhöhen, passen Sie
	  auf dem Server den Eintrag <literal>syslogd_flags</literal>
	  an.  Anschließend starten Sie den Dienst neu:</para>

	<programlisting>syslogd_flags="-d -a logclient.example.com -v -v"</programlisting>

	<screen>&prompt.root; <userinput>service syslogd restart</userinput></screen>

	<para>Informationen wie diese werden sofort nach dem Neustart
	  auf der Konsole erscheinen:</para>

	<screen>logmsg: pri 56, flags 4, from logserv.example.com, msg syslogd: restart
syslogd: restarted
logmsg: pri 6, flags 4, from logserv.example.com, msg syslogd: kernel boot file is /boot/kernel/kernel
Logging to FILE /var/log/messages
syslogd: kernel boot file is /boot/kernel/kernel
cvthname(192.168.1.10)
validate: dgram from IP 192.168.1.10, port 514, name logclient.example.com;
rejected in rule 0 due to name mismatch.</screen>

	<para>In diesem Beispiel werden die Nachrichten aufgrund eines
	  fehlerhaften Namens abgewiesen.  Der Hostname sollte
	  <literal>logclient</literal> und nicht
	  <literal>logclien</literal> sein.  Beheben Sie den
	  Tippfehler, starten Sie den Dienst neu und überprüfen Sie
	  das Ergebnis:</para>

	<screen>&prompt.root; <userinput>service syslogd restart</userinput>
logmsg: pri 56, flags 4, from logserv.example.com, msg syslogd: restart
syslogd: restarted
logmsg: pri 6, flags 4, from logserv.example.com, msg syslogd: kernel boot file is /boot/kernel/kernel
syslogd: kernel boot file is /boot/kernel/kernel
logmsg: pri 166, flags 17, from logserv.example.com,
msg Dec 10 20:55:02 &lt;syslog.err&gt; logserv.example.com syslogd: exiting on signal 2
cvthname(192.168.1.10)
validate: dgram from IP 192.168.1.10, port 514, name logclient.example.com;
accepted in rule 0.
logmsg: pri 15, flags 0, from logclient.example.com, msg Dec 11 02:01:28 trhodes: Test message 2
Logging to FILE /var/log/logclient.log
Logging to FILE /var/log/messages</screen>

	<para>Zu diesem Zeitpunkt werden die Nachrichten korrekt
	  empfangen und in die richtige Datei geschrieben.</para>
      </sect3>

      <sect3>
	<title>Sicherheitsbedenken</title>

	<para>Wie mit jedem Netzwerkdienst, müssen
	  Sicherheitsanforderungen in Betracht gezogen werden, bevor
	  ein Protokollserver eingesetzt wird.  Manchmal enthalten
	  Protokolldateien sensitive Daten über aktivierte Dienste auf
	  dem lokalen Rechner, Benutzerkonten und Konfigurationsdaten.
	  Daten, die vom Client an den Server geschickt werden, sind
	  weder verschlüsselt noch mit einem Passwort geschützt.  Wenn
	  ein Bedarf für Verschlüsselung besteht, ist es möglich
	  <package>security/stunnel</package> zu verwenden, welches
	  die Protokolldateien über einen verschlüsselten Tunnel
	  versendet.</para>

	<para>Lokale Sicherheit ist ebenfalls ein Thema.
	  Protokolldateien sind während der Verwendung oder nach ihrer
	  Rotation nicht verschlüsselt.  Lokale Benutzer versuchen
	  vielleicht, auf diese Dateien zuzugreifen, um zusätzliche
	  Einsichten in die Systemkonfiguration zu erlangen.  Es ist
	  absolut notwendig, die richtigen Berechtigungen auf diesen
	  Dateien zu setzen.  Das Werkzeug
	  <application>newsyslog</application> unterstützt
	  das Setzen von Berechtigungen auf gerade erstellte oder
	  rotierte Protokolldateien.  Protokolldateien mit
	  Zugriffsmodus <literal>600</literal> sollten verhindern,
	  dass lokale Benutzer darin herumschnüffeln.  Zusätzliche
	  Informationen finden Sie in &man.newsyslog.conf.5;.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="configtuning-configfiles">
    <title>Konfigurationsdateien</title>

    <sect2>
      <title><filename>/etc</filename> Layout</title>

      <para>Konfigurationsdateien finden sich in einigen
	Verzeichnissen unter anderem in:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <colspec colwidth="1*"/>
	  <colspec colwidth="2*"/>

	  <tbody>
	    <row>
	      <entry><filename>/etc</filename></entry>
	      <entry>Enthält generelle systemspezifische
		Konfigurationsinformationen.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/defaults</filename></entry>
	      <entry>Default Versionen der
		Konfigurationsdateien.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/mail</filename></entry>
	      <entry>Enthält die &man.sendmail.8; Konfiguration
		und weitere <acronym>MTA</acronym>
		Konfigurationsdateien.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/ppp</filename></entry>
	      <entry>Hier findet sich die Konfiguration für
		die User- und Kernel-ppp Programme.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/local/etc</filename></entry>
	      <entry>Installierte Anwendungen legen hier ihre
		Konfigurationsdateien ab.  Dieses Verzeichnis kann
		Unterverzeichnisse für bestimmte Anwendungen
		enthalten.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/local/etc/rc.d</filename></entry>
	      <entry>&man.rc.8;-Skripten installierter
		Anwendungen.</entry>
	    </row>

	    <row>
	      <entry><filename>/var/db</filename></entry>
	      <entry>Automatisch generierte systemspezifische
		Datenbanken, wie die Paket-Datenbank oder die
		&man.locate.1;-Datenbank.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </sect2>

    <sect2>
      <title>Hostnamen</title>

      <indexterm><primary>hostname</primary></indexterm>
      <indexterm><primary>DNS</primary></indexterm>

      <sect3>
	<title><filename>/etc/resolv.conf</filename></title>

	<indexterm><primary><filename>resolv.conf</filename></primary></indexterm>

	<para>Wie ein &os;-System auf das
	  <foreignphrase>Internet Domain Name System</foreignphrase>
	  (<acronym>DNS</acronym>) zugreift, wird in
	  <filename>/etc/resolv.conf</filename> festgelegt.</para>

	<para>Die gebräuchlichsten Einträge in
	  <filename>/etc/resolv.conf</filename> sind:</para>

	<informaltable frame="none" pgwide="1">
	  <tgroup cols="2">
	    <colspec colwidth="1*"/>
	    <colspec colwidth="2*"/>

	    <tbody>
	      <row>
		<entry><literal>nameserver</literal></entry>
		<entry>Die IP-Adresse eines Nameservers, den
		  der Resolver abfragen soll.  Bis zu drei Server
		  werden in der Reihenfolge, in der sie aufgezählt
		  sind, abgefragt.</entry>
	      </row>

	      <row>
		<entry><literal>search</literal></entry>
		<entry>Suchliste mit Domain-Namen zum Auflösen von
		  Hostnamen.  Die Liste wird normalerweise durch den
		  Domain-Teil des lokalen Hostnamens
		  festgelegt.</entry>
	      </row>

	      <row>
		<entry><literal>domain</literal></entry>
		<entry>Der lokale Domain-Name.</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

	<para>Beispiel für eine typische
	  <filename>/etc/resolv.conf</filename>:</para>

	<programlisting>search example.com
nameserver 147.11.1.11
nameserver 147.11.100.30</programlisting>

	<note>
	  <para>Nur eine der Anweisungen <literal>search</literal>
	    oder <literal>domain</literal> sollte benutzt
	    werden.</para>
	</note>

	<para>Wenn Sie <acronym>DHCP</acronym> benutzen, überschreibt
	  &man.dhclient.8; für gewöhnlich
	  <filename>/etc/resolv.conf</filename> mit den Informationen
	  vom <acronym>DHCP</acronym>-Server.</para>
      </sect3>

      <sect3>
	<title><filename>/etc/hosts</filename></title>

	<indexterm><primary>hosts</primary></indexterm>

	<para><filename>/etc/hosts</filename> ist eine einfache
	  textbasierte Datenbank.  Zusammen mit <acronym>DNS</acronym>
	  und <acronym>NIS</acronym> stellt sie eine Abbildung
	  zwischen Namen und <acronym>IP</acronym>-Adressen zur
	  Verfügung.  Anstatt &man.named.8; zu konfigurieren, können
	  hier lokale Rechner, die über ein <acronym>LAN</acronym>
	  verbunden sind, eingetragen werden.  Lokale Einträge für
	  gebräuchliche Internet-Adressen in
	  <filename>/etc/hosts</filename> verhindern die Abfrage eines
	  externen Servers und beschleunigen die
	  Namensauflösung.</para>

	<programlisting># <phrase its:translate="no">&dollar;&os;&dollar;</phrase>
#
#
# Host Database
#
# This file should contain the addresses and aliases for local hosts that
# share this file.  Replace 'my.domain' below with the domainname of your
# machine.
#
# In the presence of the domain name service or NIS, this file may
# not be consulted at all; see /etc/nsswitch.conf for the resolution order.
#
#
::1         localhost localhost.my.domain
127.0.0.1       localhost localhost.my.domain
#
# Imaginary network.
#10.0.0.2       myname.my.domain myname
#10.0.0.3       myfriend.my.domain myfriend
#
# According to RFC 1918, you can use the following IP networks for
# private nets which will never be connected to the Internet:
#
#   10.0.0.0    -   10.255.255.255
#   172.16.0.0  -   172.31.255.255
#   192.168.0.0 -   192.168.255.255
#
# In case you want to be able to connect to the Internet, you need
# real official assigned numbers.  Do not try to invent your own network
# numbers but instead get one from your network provider (if any) or
# from your regional registry (ARIN, APNIC, LACNIC, RIPE NCC, or AfriNIC.)
#</programlisting>

	<para><filename>/etc/hosts</filename> hat das folgende
	  Format:</para>

	<programlisting>[Internet Adresse] [Offizieller Hostname] [Alias1] [Alias2] ...</programlisting>

	<para>Zum Beispiel:</para>

	<programlisting>10.0.0.1 myRealHostname.example.com myRealHostname foobar1 foobar2</programlisting>

	<para>Weitere Informationen entnehmen Sie bitte
	  &man.hosts.5;.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="configtuning-sysctl">
    <title>Einstellungen mit &man.sysctl.8;</title>

    <indexterm><primary>sysctl</primary></indexterm>
    <indexterm>
      <primary>Einstellungen</primary>
      <secondary>mit sysctl</secondary>
    </indexterm>

    <para>Mit &man.sysctl.8; können Sie Änderungen an
      einem laufenden &os;-System vornehmen.  Unter anderem
      können Optionen des <acronym>TCP/IP</acronym>-Stacks oder des
      virtuellen Speichermanagements verändert werden.  Unter
      der Hand eines erfahrenen Systemadministrators kann dies
      die Systemperformance erheblich verbessern.  Über 500
      Variablen können mit &man.sysctl.8; gelesen und gesetzt
      werden.</para>

    <para>Der Hauptzweck von &man.sysctl.8; besteht darin,
      Systemeinstellungen zu lesen und zu verändern.</para>

    <para>Alle auslesbaren Variablen werden wie folgt
      angezeigt:</para>

    <screen>&prompt.user; <userinput>sysctl -a</userinput></screen>

    <para>Um eine spezielle Variable zu lesen, geben Sie den Namen
      an:</para>

    <screen>&prompt.user; <userinput>sysctl kern.maxproc</userinput>
kern.maxproc: 1044</screen>

    <para>Um eine Variable zu setzen, benutzen Sie die Syntax
      <replaceable>Variable</replaceable>=
      <replaceable>Wert</replaceable>:</para>

    <screen>&prompt.root; <userinput>sysctl kern.maxfiles=5000</userinput>
kern.maxfiles: 2088 -&gt; 5000</screen>

    <para>Mit sysctl können Strings, Zahlen oder Boolean-Werte gesetzt
      werden.  Bei Boolean-Werten steht <literal>1</literal>
      für wahr und <literal>0</literal> für falsch.</para>

    <para>Um die Variablen automatisch während des Systemstarts zu
      setzen, fügen Sie sie in <filename>/etc/sysctl.conf</filename>
      ein.  Weitere Informationen finden Sie in der Hilfeseite
      &man.sysctl.conf.5; und in <xref
	linkend="configtuning-sysctlconf"/>.</para>

    <sect2 xml:id="configtuning-sysctlconf">
      <title><filename>sysctl.conf</filename></title>

      <indexterm><primary>sysctl.conf</primary></indexterm>
      <indexterm><primary>sysctl</primary></indexterm>

      <para><filename>/etc/sysctl.conf</filename> sieht ähnlich
	wie <filename>/etc/rc.conf</filename> aus.  Werte werden
	in der Form <literal>Variable=Wert</literal> gesetzt.
	Die angegebenen Werte werden gesetzt, nachdem sich das
	System bereits im Mehrbenutzermodus befindet.  Allerdings
	lassen sich im Mehrbenutzermodus nicht alle Werte
	setzen.</para>

      <para>Um das Protokollieren von fatalen Signalen abzustellen
	und Benutzer daran zu hindern, von anderen Benutzern
	gestartete Prozesse zu sehen, können Sie in
	<filename>/etc/sysctl.conf</filename> die folgenden
	Variablen setzen:</para>

      <programlisting># Do not log fatal signal exits (e.g. sig 11)
kern.logsigexit=0

# Prevent users from seeing information about processes that
# are being run under another UID.
security.bsd.see_other_uids=0</programlisting>

    </sect2>

    <sect2 xml:id="sysctl-readonly">
      <info>
	<title>Schreibgeschützte Variablen</title>

	<authorgroup>
	  <author>
	    <personname>
	      <firstname>Tom</firstname>
	      <surname>Rhodes</surname>
	    </personname>
	    <contrib>Contributed by </contrib>
	  </author>
	</authorgroup>
      </info>

      <para>Wenn schreibgeschützte &man.sysctl.8;-Variablen verändert
	werden, ist ein Neustart des Systems erforderlich.</para>

      <para>Beispielsweise hat &man.cardbus.4; auf einigen Laptops
	Schwierigkeiten, Speicherbereiche zu erkennen.  Es treten
	dann Fehlermeldungen wie die folgende auf:</para>

      <screen>cbb0: Could not map register memory
device_probe_and_attach: cbb0 attach returned 12</screen>

      <para>Um dieses Problem zu lösen, muss eine
	schreibgeschützte &man.sysctl.8;-Variable verändert werden.
	Fügen Sie <option>hw.pci.allow_unsupported_io_range=1</option>
	in <filename>/boot/loader.conf</filename> hinzu und starten
	Sie das System neu.  Danach sollte &man.cardbus.4; fehlerfrei
	funktionieren.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="configtuning-disk">
    <title>Tuning von Laufwerken</title>

    <para>Der folgende Abschnitt beschreibt die verschiedenen
      Methoden zur Feinabstimmung der Laufwerke.  Oft sind mechanische
      Teile in Laufwerken, wie <acronym>SCSI</acronym>-Laufwerke,
      verbaut.  Diese können einen Flaschenhals bei der Gesamtleistung
      des Systems darstellen.  Sie können zwar auch ein Laufwerk ohne
      mechanische Teile einbauen, wie z.B. ein
      <foreignphrase>Solid-State-Drive</foreignphrase>, aber Laufwerke
      mit mechanischen Teilen werden auch in naher Zukunft nicht vom
      Markt verschwinden.  Bei der Feinabstimmung ist es ratsam, die
      Funktionen von &man.iostat.8; zu verwenden, um verschiedene
      Änderungen zu testen und um nützliche
      <acronym>IO</acronym>-Informationen des Systems zu
      erhalten.</para>

    <sect2>
      <title>Sysctl Variablen</title>

      <sect3>
	<title><varname>vfs.vmiodirenable</varname></title>

	<indexterm>
	  <primary><varname>vfs.vmiodirenable</varname></primary>
	</indexterm>

	<para>Die &man.sysctl.8;-Variable
	  <varname>vfs.vmiodirenable</varname> besitzt in der
	  Voreinstellung den Wert <literal>1</literal>.  Die Variable
	  kann auf den Wert <literal>0</literal> (deaktiviert) oder
	  <literal>1</literal> (aktiviert) gesetzt werden.  Sie
	  steuert, wie Verzeichnisse vom System zwischengespeichert
	  werden.  Die meisten Verzeichnisse sind klein und benutzen
	  nur ein einzelnes Fragment, typischerweise 1&nbsp;kB, im
	  Dateisystem und 512&nbsp;Bytes im Buffer-Cache.  Ist
	  die Variable deaktiviert, wird der Buffer-Cache nur
	  eine limitierte Anzahl Verzeichnisse zwischenspeichern, auch
	  wenn das System über sehr viel Speicher verfügt.
	  Ist die Variable aktiviert, kann der Buffer-Cache
	  den <acronym>VM</acronym>-Page-Cache benutzen, um
	  Verzeichnisse zwischenzuspeichern.  Der ganze Speicher steht
	  damit zum Zwischenspeichern von Verzeichnissen zur
	  Verfügung.  Der Nachteil bei dieser Vorgehensweise ist, dass
	  zum Zwischenspeichern eines Verzeichnisses mindestens eine
	  physikalische Seite im Speicher, die normalerweise 4&nbsp;kB
	  groß ist, anstelle von 512&nbsp;Bytes gebraucht wird.  Es
	  wird empfohlen, diese Option aktiviert zu lassen, wenn Sie
	  Dienste zur Verfügung stellen, die viele Dateien
	  manipulieren.  Beispiele für solche Dienste sind Web-Caches,
	  große Mail-Systeme oder Netnews.  Die aktivierte
	  Variable vermindert, trotz des verschwendeten Speichers,
	  in aller Regel nicht die Leistung des Systems, obwohl Sie
	  das nachprüfen sollten.</para>
      </sect3>

      <sect3>
	<title><varname>vfs.write_behind</varname></title>

	<indexterm>
	  <primary><varname>vfs.write_behind</varname></primary>
	</indexterm>

	<para>In der Voreinstellung besitzt die
	  &man.sysctl.8;-Variable <varname>vfs.write_behind</varname>
	  den Wert <literal>1</literal> (aktiviert).  Mit dieser
	  Einstellung schreibt das Dateisystem anfallende vollständige
	  Cluster, die besonders beim sequentiellen Schreiben großer
	  Dateien auftreten, direkt auf das Medium aus.  Dies
	  verhindert, dass sich im Buffer-Cache veränderte Puffer
	  (<foreignphrase>dirty buffers</foreignphrase>) ansammeln,
	  die die I/O-Verarbeitung nicht mehr beschleunigen würden.
	  Unter bestimmten Umständen blockiert diese Funktion
	  allerdings Prozesse.  Setzen Sie in diesem Fall die Variable
	  <varname>vfs.write_behind</varname> auf den Wert
	  <literal>0</literal>.</para>
      </sect3>

      <sect3>
	<title><varname>vfs.hirunningspace</varname></title>

	<indexterm>
	  <primary><varname>vfs.hirunningspace</varname></primary>
	</indexterm>

	<para>Die &man.sysctl.8;-Variable
	  <varname>vfs.hirunningspace</varname> bestimmt systemweit
	  die Menge ausstehender Schreiboperationen, die dem
	  Platten-Controller zu jedem beliebigen Zeitpunkt übergeben
	  werden können.  Normalerweise können Sie den Vorgabewert
	  verwenden.  Auf Systemen mit vielen Platten kann der Wert
	  aber auf 4 bis 5&nbsp;<emphasis>Megabyte</emphasis> erhöht
	  werden.  Ein zu hoher Wert (größer als der
	  Schreib-Schwellwert des Buffer-Caches) kann zu
	  Leistungsverlusten führen.  Setzen Sie den Wert daher nicht
	  zu hoch!  Hohe Werte können auch Leseoperationen verzögern,
	  die gleichzeitig mit Schreiboperationen ausgeführt
	  werden.</para>

	<para>Es gibt weitere &man.sysctl.8;-Variablen, mit denen Sie
	  den Buffer-Cache und den <acronym>VM</acronym>-Page-Cache
	  beeinflussen können.  Es wird nicht empfohlen, diese
	  Variablen zu verändern, da das <acronym>VM</acronym>-System
	  den virtuellen Speicher selbst sehr gut verwaltet.</para>
      </sect3>

      <sect3>
	<title><varname>vm.swap_idle_enabled</varname></title>

	<indexterm>
	  <primary><varname>vm.swap_idle_enabled</varname></primary>
	</indexterm>

	<para>Die &man.sysctl.8;-Variable
	  <varname>vm.swap_idle_enabled</varname> ist für große
	  Mehrbenutzer-Systeme gedacht, auf denen sich viele Benutzer
	  an- und abmelden und auf denen es viele Prozesse im Leerlauf
	  (<foreignphrase>idle</foreignphrase>) gibt.  Solche Systeme
	  fragen kontinuierlich freien Speicher an.  Wenn Sie die
	  Variable <varname>vm.swap_idle_enabled</varname> aktivieren,
	  können Sie die Auslagerungs-Hysterese von Seiten mit
	  den Variablen <varname>vm.swap_idle_threshold1</varname> und
	  <varname>vm.swap_idle_threshold2</varname> einstellen.  Die
	  Schwellwerte beider Variablen geben die Zeit in Sekunden an,
	  in denen sich ein Prozess im Leerlauf befinden muss.  Wenn
	  die Werte so eingestellt sind, dass Seiten früher als nach
	  dem normalen Algorithmus ausgelagert werden, verschafft das
	  dem Auslagerungs-Prozess mehr Luft.  Aktivieren Sie diese
	  Funktion nur, wenn Sie sie wirklich benötigen:  Die
	  Speicherseiten werden eher früher als später ausgelagert.
	  Der Platz im Swap-Bereich wird dadurch schneller verbraucht
	  und die Plattenaktivitäten steigen an.  Auf kleinen
	  Systemen hat diese Funktion spürbare Auswirkungen.  Auf
	  großen Systemen, die sowieso schon Seiten auslagern müssen,
	  können ganze Prozesse leichter in den Speicher geladen oder
	  ausgelagert werden.</para>
      </sect3>

      <sect3>
	<title><varname>hw.ata.wc</varname></title>

	<indexterm>
	  <primary><varname>hw.ata.wc</varname></primary>
	</indexterm>

	<para>Obwohl das Abstellen des
	  <acronym>IDE</acronym>-Schreib-Zwischenspeichers die
	  Bandbreite zum Schreiben auf die
	  <acronym>IDE</acronym>-Festplatte verringert, kann es aus
	  Gründen der Datenkonsistenz als notwendig angesehen werden.
	  Das Problem ist, dass <acronym>IDE</acronym>-Platten keine
	  zuverlässige Aussage über das Ende eines Schreibvorgangs
	  treffen.  Wenn der Schreib-Zwischenspeicher aktiviert ist,
	  werden die Daten nicht in der Reihenfolge ihres Eintreffens
	  geschrieben.  Es kann sogar passieren, dass das Schreiben
	  mancher Blöcke im Fall von starker Plattenaktivität auf
	  unbefristete Zeit verzögert wird.  Ein Absturz oder
	  Stromausfall zu dieser Zeit kann die Dateisysteme erheblich
	  beschädigen.  Sie sollten den Wert der
	  &man.sysctl.8;-Variable <varname>hw.ata.wc</varname> auf dem
	  System überprüfen.  Wenn der Schreib-Zwischenspeicher
	  abgestellt ist, können Sie ihn beim Systemstart aktivieren,
	  indem Sie die Variable in
	  <filename>/boot/loader.conf</filename> auf den Wert
	  <literal>1</literal> setzen.</para>

	<para>Weitere Informationen finden Sie in &man.ata.4;.</para>
      </sect3>

      <sect3>
	<title><literal>SCSI_DELAY</literal>
	  (<varname>kern.cam.scsi_delay</varname>)</title>

	<indexterm>
	  <primary><varname>kern.cam.scsi_delay</varname></primary>
	</indexterm>

	<indexterm>
	  <primary>Kerneloptionen</primary>
	  <secondary><literal>SCSI DELAY</literal></secondary>
	</indexterm>

	<para>Mit der Kerneloption <literal>SCSI_DELAY</literal> kann
	  die Dauer des Systemstarts verringert werden.  Der
	  Vorgabewert ist recht hoch und er verzögert den Systemstart
	  um <literal>15</literal> oder mehr Sekunden.  Normalerweise
	  kann dieser Wert, insbesondere mit modernen Laufwerken, mit
	  der &man.sysctl.8;-Variable
	  <varname>kern.cam.scsi_delay</varname> auf
	  <literal>5</literal> Sekunden heruntergesetzt werden.  Die
	  Variable sowie die Kerneloption verwenden für die Zeitangabe
	  Millisekunden und <emphasis>nicht</emphasis>
	  Sekunden.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="soft-updates">
      <title>Soft Updates</title>

      <indexterm><primary>Soft Updates</primary></indexterm>
      <indexterm><primary>&man.tunefs.8;</primary></indexterm>

      <para>Mit &man.tunefs.8; lassen sich Feineinstellungen an
	Dateisystemen vornehmen.  Das Programm hat verschiedene
	Optionen.  Soft Updates werden wie folgt ein- und
	ausgeschaltet:</para>

      <screen>&prompt.root; <userinput>tunefs -n enable /filesystem</userinput>
&prompt.root; <userinput>tunefs -n disable /filesystem</userinput></screen>

      <para>Ein eingehängtes Dateisystem kann nicht mit &man.tunefs.8;
	modifiziert werden.  Soft Updates werden am besten im
	Single-User Modus aktiviert, bevor Partitionen eingehangen
	sind.</para>

      <para>Durch Einsatz eines Zwischenspeichers wird die Performance
	im Bereich der Metadaten, vorwiegend beim Anlegen und Löschen
	von Dateien, gesteigert.  Es wird empfohlen, Soft Updates auf
	allen <acronym>UFS</acronym>-Dateisystemen zu aktivieren.
	Allerdings sollten Sie sich über die zwei Nachteile von Soft
	Updates bewusst sein: Erstens garantieren Soft Updates zwar
	die Konsistenz der Daten im Fall eines Absturzes, aber es kann
	passieren, dass das Dateisystem über mehrere Sekunden oder gar
	eine Minute nicht synchronisiert wurde.  Nicht geschriebene
	Daten gehen dann vielleicht verloren.  Zweitens verzögern Soft
	Updates die Freigabe von Datenblöcken.  Eine größere
	Aktualisierung eines fast vollen Dateisystems, wie dem
	Root-Dateisystem, z.B. während eines
	<command>make installworld</command>, kann das Dateisystem
	vollaufen lassen.  Dadurch würde die Aktualisierung
	fehlschlagen.</para>

      <sect3>
	<title>Details über Soft Updates</title>

	<indexterm>
	  <primary>Soft Updates</primary>
	  <secondary>Details</secondary>
	</indexterm>

	<para>Bei einem Metadaten-Update werden die Inodes und
	  Verzeichniseinträge aktualisiert auf die Platte
	  zurückgeschrieben.  Es gibt zwei klassische Ansätze, um die
	  Metadaten des Dateisystems auf die Platte zu
	  schreiben.</para>

	<para>Das historisch übliche Verfahren waren synchrone
	  Updates der Metadaten, d. h. wenn eine Änderung an
	  einem Verzeichnis nötig war, wurde anschließend
	  gewartet, bis diese Änderung tatsächlich auf die
	  Platte zurückgeschrieben worden war.  Der
	  <emphasis>Inhalt</emphasis> der Dateien wurde im
	  <quote>Buffer Cache</quote> zwischengespeichert und
	  später asynchron auf die Platte geschrieben.
	  Der Vorteil dieser Implementierung ist, dass sie
	  sicher funktioniert.  Wenn während eines Updates ein
	  Ausfall erfolgt, haben die Metadaten immer einen
	  konsistenten Zustand.  Eine Datei ist entweder komplett
	  angelegt oder gar nicht.  Wenn die Datenblöcke einer
	  Datei im Fall eines Absturzes noch nicht den Weg aus dem
	  <quote>Buffer Cache</quote> auf die Platte gefunden haben,
	  kann &man.fsck.8; das Dateisystem reparieren, indem es die
	  Dateilänge einfach auf <literal>0</literal> setzt.  Außerdem
	  ist die Implementierung einfach und überschaubar.  Der
	  Nachteil ist, dass Änderungen der Metadaten sehr
	  langsam vor sich gehen.  Ein <command>rm -r</command>
	  beispielsweise fasst alle Dateien eines Verzeichnisses
	  der Reihe nach an, aber jede dieser Änderungen am
	  Verzeichnis (Löschen einer Datei) wird einzeln synchron
	  auf die Platte geschrieben.  Gleiches beim Auspacken
	  großer Hierarchien mit <command>tar -x</command>.</para>

	<para>Der zweite Ansatz sind asynchrone Metadaten-Updates.
	  Das ist der Standard, wenn
	  <acronym>UFS</acronym>-Dateisysteme mit
	  <command>mount -o async</command> eingehängt werden.  Man
	  schickt die Updates der Metadaten einfach auch noch
	  über den <quote>Buffer Cache</quote>, sie werden also
	  zwischen die Updates der normalen Daten eingeschoben.
	  Vorteil ist, dass man nun nicht mehr auf jeden Update
	  warten muss, Operationen, die zahlreiche Metadaten
	  ändern, werden also viel schneller.  Auch
	  hier ist die Implementierung sehr einfach und wenig
	  anfällig für Fehler.  Nachteil ist, dass
	  keinerlei Konsistenz des Dateisystems mehr gesichert ist.
	  Wenn mitten in einer Operation, die viele Metadaten
	  ändert, ein Ausfall erfolgt (Stromausfall, drücken
	  des Reset-Schalters), dann ist das Dateisystem
	  anschließend in einem unbestimmten Zustand.  Niemand
	  kann genau sagen, was noch geschrieben worden ist und was
	  nicht mehr; die Datenblöcke einer Datei können
	  schon auf der Platte stehen, während die inode Tabelle
	  oder das zugehörige Verzeichnis nicht mehr aktualisiert
	  worden ist.  Man kann praktisch kein &man.fsck.8;
	  mehr implementieren, das diesen Zustand
	  wieder reparieren kann, da die dazu nötigen
	  Informationen einfach auf der Platte fehlen.  Wenn ein
	  Dateisystem irreparabel beschädigt wurde, hat man nur noch
	  die Möglichkeit es neu zu erzeugen und die Daten vom Backup
	  zurückspielen.</para>

	<para>Der Ausweg aus diesem Dilemma ist ein
	  <emphasis>dirty region logging</emphasis>, was auch als
	  <emphasis>Journalling</emphasis> bezeichnet wird.  Man
	  schreibt die Metadaten-Updates zwar synchron, aber nur in
	  einen kleinen Plattenbereich, die
	  <emphasis>logging area</emphasis>.  Von da aus werden sie
	  dann asynchron auf ihre eigentlichen Bereiche verteilt.  Da
	  die <emphasis>logging area</emphasis> ein kleines
	  zusammenhängendes Stückchen ist, haben die
	  Schreibköpfe der Platte bei massiven Operationen auf
	  Metadaten keine allzu großen Wege zurückzulegen,
	  so dass alles ein ganzes Stück schneller geht als
	  bei klassischen synchronen Updates.  Die Komplexität
	  der Implementierung hält sich ebenfalls in Grenzen,
	  somit auch die Anfälligkeit für Fehler.  Als
	  Nachteil ergibt sich, dass Metadaten zweimal auf die
	  Platte geschrieben werden müssen (einmal in die
	  <emphasis>logging area</emphasis>, einmal an die richtige
	  Stelle), so dass das im Falle regulärer
	  Arbeit (also keine gehäuften Metadatenoperationen) eine
	  <quote>Pessimisierung</quote> des Falls der synchronen
	  Updates eintritt, es wird alles langsamer.  Dafür hat man
	  als Vorteil, dass im Falle eines Absturzes der
	  konsistente Zustand dadurch erzielbar ist, dass die
	  angefangenen Operationen aus dem <emphasis>dirty region
	    log</emphasis> entweder zu Ende ausgeführt oder
	  komplett verworfen werden, wodurch das Dateisystem schnell
	  wieder zur Verfügung steht.</para>

	<para>Die Lösung von Kirk McKusick, dem Schöpfer von
	  Berkeley <acronym>FFS</acronym>, waren
	  <emphasis>Soft Updates</emphasis>: die
	  notwendigen Updates der Metadaten werden im Speicher
	  gehalten und dann sortiert auf die Platte geschrieben
	  (<quote>ordered metadata updates</quote>).  Dadurch hat man
	  den Effekt, dass im Falle massiver
	  Metadaten-Änderungen spätere Operationen die
	  vorhergehenden, noch nicht auf die Platte geschriebenen
	  Updates desselben Elements im Speicher
	  <quote>einholen</quote>.  Alle Operationen, auf ein
	  Verzeichnis beispielsweise, werden also in der Regel noch im
	  Speicher abgewickelt, bevor der Update überhaupt auf
	  die Platte geschrieben wird (die dazugehörigen
	  Datenblöcke werden natürlich auch so sortiert,
	  dass sie nicht vor ihren Metadaten auf der Platte
	  sind).  Im Fall eines Absturzes hat man ein implizites
	  <quote>log rewind</quote>: alle Operationen, die noch nicht
	  den Weg auf die Platte gefunden haben, sehen danach so aus,
	  als hätten sie nie stattgefunden.  Man hat so also den
	  konsistenten Zustand von ca. 30 bis 60&nbsp;Sekunden früher
	  sichergestellt.  Der verwendete Algorithmus garantiert
	  dabei, dass alle tatsächlich benutzten Ressourcen
	  auch in den entsprechenden Bitmaps (Block- und inode
	  Tabellen) als belegt markiert sind.  Der einzige Fehler, der
	  auftreten kann, ist, dass Ressourcen noch als
	  <quote>belegt</quote> markiert sind, die tatsächlich
	  <quote>frei</quote> sind.  &man.fsck.8; erkennt dies und
	  korrigiert diese nicht mehr belegten Ressourcen.  Die
	  Notwendigkeit eines Dateisystem-Checks darf aus diesem
	  Grunde auch ignoriert und das Dateisystem mittels
	  <command>mount -f</command> zwangsweise eingebunden werden.
	  Um noch allozierte Ressourcen freizugeben muss
	  später ein &man.fsck.8; nachgeholt werden.  Das ist
	  dann auch die Idee des <emphasis>background fsck</emphasis>:
	  beim Starten des Systems wird lediglich ein
	  <emphasis>Schnappschuss</emphasis> des Dateisystems
	  gemacht, mit dem &man.fsck.8; dann später arbeiten
	  kann.  Alle Dateisysteme dürfen <quote>unsauber</quote>
	  eingebunden werden und das System kann sofort in den
	  Multiuser-Modus gehen.  Danach wird ein
	  Hintergrund-&man.fsck.8; für die Dateisysteme gestartet, die
	  dies benötigen, um möglicherweise irrtümlich belegte
	  Ressourcen freizugeben.  Dateisysteme ohne
	  <emphasis>Soft Updates</emphasis> benötigen natürlich immer
	  noch den üblichen Vordergrund-&man.fsck.8;, bevor sie
	  eingebunden werden können.</para>

	<para>Der Vorteil ist, dass die Metadaten-Operationen
	  beinahe so schnell ablaufen wie im asynchronen Fall, also
	  auch schneller als beim <emphasis>logging</emphasis>, das
	  die Metadaten immer zweimal schreiben muss.  Als Nachteil
	  stehen dem die Komplexität des Codes, ein erhöhter
	  Speicherverbrauch und einige spezielle Eigenheiten entgegen.
	  Nach einem Absturz ist ein etwas <quote>älterer</quote>
	  Stand auf der Platte &ndash; statt einer leeren, aber
	  bereits angelegten Datei, wie nach einem herkömmlichen
	  &man.fsck.8; Lauf, ist auf einem Dateisystem mit
	  <emphasis>Soft Updates</emphasis> keine Spur der
	  entsprechenden Datei mehr zu sehen, da weder die Metadaten
	  noch der Dateiinhalt je auf die Platte geschrieben wurden.
	  Weiterhin kann der Platz nach einem &man.rm.1;
	  nicht sofort wieder als verfügbar markiert werden,
	  sondern erst dann, wenn der Update auch auf die Platte
	  vermittelt worden ist.  Dies kann besonders dann Probleme
	  bereiten, wenn große Datenmengen in einem Dateisystem
	  installiert werden, das nicht genügend Platz hat, um alle
	  Dateien zweimal unterzubringen.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="configtuning-kernel-limits">
    <title>Einstellungen von Kernel Limits</title>

    <indexterm>
      <primary>Einstellungen</primary>
      <secondary>von Kernel Limits</secondary>
    </indexterm>

    <sect2 xml:id="file-process-limits">
      <title>Datei und Prozeß Limits</title>

      <sect3 xml:id="kern-maxfiles">
	<title><varname>kern.maxfiles</varname></title>

	<indexterm>
	  <primary><varname>kern.maxfiles</varname></primary>
	</indexterm>

	<para>Abhängig von den Anforderungen an das System kann die
	  &man.sysctl.8;-Variable <varname>kern.maxfiles</varname>
	  erhöht oder gesenkt werden.  Die Variable legt die maximale
	  Anzahl von Dateideskriptoren auf dem System fest.  Wenn die
	  Dateideskriptoren aufgebraucht sind, werden Sie die Meldung
	  <errorname>file: table is full</errorname> wiederholt im
	  Puffer für Systemmeldungen sehen.  Den Inhalt des Puffers
	  können Sie sich mit &man.dmesg.8; anzeigen lassen.</para>

	<para>Jede offene Datei, jedes Socket und jede FIFO verbraucht
	  einen Dateideskriptor.  Auf <quote>dicken</quote>
	  Produktionsservern können leicht Tausende Dateideskriptoren
	  benötigt werden, abhängig von der Art und Anzahl der
	  gleichzeitig laufenden Dienste.</para>

	<para>In älteren &os;-Versionen wurde die Voreinstellung
	  von <varname>kern.maxfile</varname> aus der
	  Kernelkonfigurationsoption <literal>maxusers</literal>
	  bestimmt.  <varname>kern.maxfiles</varname> wächst
	  proportional mit dem Wert von <literal>maxusers</literal>.
	  Wenn Sie einen angepassten Kernel kompilieren, empfiehlt es
	  sich diese Option entsprechend der maximalen Benutzerzahl
	  des Systems einzustellen.  Obwohl auf einer
	  Produktionsmaschine vielleicht nicht 256 Benutzer
	  gleichzeitig angemeldet sind, können die benötigten
	  Ressourcen ähnlich hoch wie bei einem großen Webserver
	  sein.</para>

	<para>Die nur lesbare &man.sysctl.8;-Variable
	  <varname>kern.maxusers</varname> wird beim Systemstart
	  automatisch aus dem zur Verfügung stehenden Hauptspeicher
	  bestimmt.  Im laufenden Betrieb kann dieser Wert aus
	  <varname>kern.maxusers</varname> ermittelt werden.  Einige
	  Systeme benötigen für diese Variable einen anderen Wert,
	  wobei <literal>64</literal>, <literal>128</literal> und
	  <literal>256</literal> gewöhnliche Werte darstellen.
	  Es wird nicht empfohlen, die Anzahl der Dateideskriptoren
	  auf einen Wert größer <literal>256</literal> zu setzen, es
	  sei denn, Sie benötigen wirklich eine riesige Anzahl von
	  ihnen.  Viele der von <varname>kern.maxusers</varname> auf
	  einen Standardwert gesetzten Parameter können beim
	  Systemstart oder im laufenden Betrieb in
	  <filename>/boot/loader.conf</filename> angepasst werden.
	  In &man.loader.conf.5; und
	  <filename>/boot/defaults/loader.conf</filename> finden Sie
	  weitere Details und Hinweise.</para>

	<para>Ältere &os;-Versionen setzen diesen Wert selbst, wenn
	  Sie in der Konfigurationsdatei den Wert <literal>0</literal>
	  <footnote><para>Der verwendete Algorithmus setzt
	      <literal>maxusers</literal> auf die Speichergröße des
	      Systems.  Der minimale Wert beträgt dabei
	      <literal>32</literal>, das Maximum ist
	      <literal>384</literal>.</para></footnote>
	  angeben.  Wenn Sie den Wert selbst bestimmen wollen,
	  sollten Sie <literal>maxusers</literal> mindestens auf
	  <literal>4</literal> setzen.  Dies gilt insbesondere dann,
	  wenn Sie beabsichtigen, <application>&xorg;</application> zu
	  benutzen oder Software zu kompilieren.  Der wichtigste Wert,
	  der durch <literal>maxusers</literal> bestimmt wird, die
	  maximale Anzahl an Prozessen ist, die auf
	  <literal>20 + 16 * maxusers</literal> gesetzt wird.  Wird
	  <literal>maxusers</literal> auf <literal>1</literal> setzen,
	  können gleichzeitig nur <literal>36</literal> Prozesse
	  laufen, von denen ungefähr <literal>18</literal> schon beim
	  Booten des Systems gestartet werden.  Dazu kommen nochmals
	  etwa <literal>15</literal> Prozesse beim Start von
	  <application>&xorg;</application>.  Selbst eine einfache
	  Aufgabe wie das Lesen einer Manualpage benötigt neun
	  Prozesse zum Filtern, Dekomprimieren und Betrachten der
	  Datei.  Für die meisten Benutzer sollte es ausreichen,
	  <literal>maxusers</literal> auf <literal>64</literal> zu
	  setzen, womit <literal>1044</literal> gleichzeitige Prozesse
	  zur Verfügung stehen.  Wenn Sie allerdings den Fehler
	  <errortype>proc table full</errortype> beim Start eines
	  Programms oder auf einem Server mit einer großen
	  Benutzerzahl sehen, dann sollten Sie den Wert nochmals
	  erhöhen und den Kernel neu bauen.</para>

	<note>
	  <para>Die Anzahl der Benutzer, die sich auf einem
	    Rechner anmelden kann, wird durch
	    <literal>maxusers</literal> <emphasis>nicht</emphasis>
	    begrenzt.  Der Wert dieser Variablen legt neben der
	    möglichen Anzahl der Prozesse eines Benutzers weitere
	    sinnvolle Größen für bestimmte Systemtabellen fest.</para>
	</note>
      </sect3>

      <sect3>
	<title><varname>kern.ipc.soacceptqueue</varname></title>

	<indexterm>
	  <primary><varname>kern.ipc.soacceptqueue</varname></primary>
	</indexterm>

	<para>Die &man.sysctl.8;-Variable
	  <varname>kern.ipc.soacceptqueue</varname> beschränkt die
	  Größe der Warteschlange
	  (<foreignphrase>Listen-Queue</foreignphrase>) für neue
	  <acronym>TCP</acronym>-Verbindungen.  Der Vorgabewert von
	  <literal>128</literal> ist normalerweise zu klein, um neue
	  Verbindungen auf einem stark ausgelasteten Webserver
	  zuverlässig zu handhaben.  Auf solchen Servern sollte
	  der Wert auf <literal>1024</literal> oder höher gesetzt
	  werden.  Dienste wie &man.sendmail.8; oder
	  <application>Apache</application> können die Größe
	  der Queue selbst einschränken.  Oft gibt es die
	  Möglichkeit, die Größe der Listen-Queue in
	  einer Konfigurationsdatei einzustellen.  Eine große
	  Listen-Queue übersteht vielleicht auch einen
	  Denial of Service Angriff (<abbrev>DoS</abbrev>).</para>
      </sect3>
    </sect2>

    <sect2 xml:id="nmbclusters">
      <title>Netzwerk Limits</title>

      <para>Die Kerneloption <literal>NMBCLUSTERS</literal> schreibt
	die Anzahl der Netzwerkpuffer (Mbufs) fest, die das System
	besitzt.  Eine zu geringe Anzahl Mbufs auf einem Server mit
	viel Netzwerkverkehr verringert die Leistung von &os;.  Jeder
	Mbuf-Cluster nimmt ungefähr 2&nbsp;kB Speicher in Anspruch, so
	dass ein Wert von <literal>1024</literal> insgesamt
	2&nbsp;Megabyte Speicher für Netzwerkpuffer im System
	reserviert.  Wie viele Cluster benötigt werden, lässt sich
	durch eine einfache Berechnung herausfinden.  Ein Webserver,
	der maximal <literal>1000</literal> gleichzeitige Verbindungen
	servieren soll, wobei jede der Verbindungen einen 6&nbsp;kB
	großen Sendepuffer und einen 16&nbsp;kB großen Empfangspuffer
	benötigt, braucht ungefähr 32&nbsp;MB Speicher für
	Netzwerkpuffer.  Als Daumenregel verdoppeln Sie diese Zahl, so
	dass sich für <varname>NMBCLUSTERS</varname> der Wert
	2x32&nbsp;MB&nbsp;/&nbsp;2&nbsp;kB=
	64&nbsp;MB&nbsp;/&nbsp;2&nbsp;kB=
	<literal>32768</literal> ergibt.  Für Maschinen mit viel
	Speicher werden Werte zwischen <literal>4096</literal> und
	<literal>32768</literal> empfohlen.  Unter keinen Umständen
	sollten Sie diesen Wert willkürlich erhöhen, da dies zu einem
	Absturz beim Systemstart führen kann.  Verwenden Sie
	&man.netstat.1; mit <option>-m</option> um den Gebrauch der
	Netzwerkpuffer zu kontrollieren.</para>

      <para>Die Netzwerkpuffer können beim Systemstart mit der
	Loader-Variablen <varname>kern.ipc.nmbclusters</varname>
	eingestellt werden.  Nur auf älteren &os;-Systemen
	müssen Sie die Kerneloption <literal>NMBCLUSTERS</literal>
	verwenden.</para>

      <para>Die Anzahl der &man.sendfile.2; Puffer muss auf
	ausgelasteten Servern, die den Systemaufruf &man.sendfile.2;
	oft verwenden, vielleicht erhöht werden.  Dazu können Sie die
	Kerneloption <literal>NSFBUFS</literal> verwenden oder die
	Anzahl der Puffer in <filename>/boot/loader.conf</filename>
	(siehe &man.loader.8;) setzen.  Die Puffer sollten erhöht
	werden, wenn Sie Prozesse im Zustand <literal>sfbufa</literal>
	sehen.  Die schreibgeschützte &man.sysctl.8;-Variable
	<varname>kern.ipc.nsfbufs</varname> zeigt die Anzahl
	eingerichteten Puffer im Kernel.  Der Wert dieser Variablen
	wird normalerweise von <varname>kern.maxusers</varname>
	bestimmt.  Manchmal muss die Pufferanzahl jedoch manuell
	eingestellt werden.</para>

      <important>
	<para>Auch wenn ein Socket nicht blockierend angelegt wurde,
	  kann der Aufruf von &man.sendfile.2; blockieren, um auf
	  freie <literal>struct sf_buf</literal> Puffer zu
	  warten.</para>
      </important>

      <sect3>
	<title><varname>net.inet.ip.portrange.*</varname></title>

	<indexterm>
	  <primary>net.inet.ip.portrange.*</primary>
	</indexterm>

	<para>Die &man.sysctl.8;-Variable
	  <varname>net.inet.ip.portrange.*</varname> legt die
	  Portnummern für <acronym>TCP</acronym>- und
	  <acronym>UDP</acronym>-Sockets fest.  Es gibt drei
	  Bereiche: den niedrigen Bereich, den normalen Bereich und
	  den hohen Bereich.  Die meisten Netzprogramme benutzen den
	  normalen Bereich.  Dieser Bereich umfasst in der
	  Voreinstellung die Portnummern <literal>1024</literal> bis
	  <literal>5000</literal> und wird durch die Variablen
	  <varname>net.inet.ip.portrange.first</varname> und
	  <varname>net.inet.ip.portrange.last</varname>
	  festgelegt.  Die festgelegten Bereiche für Portnummern
	  werden von ausgehenden Verbindungen benutzt.  Unter
	  bestimmten Umständen, beispielsweise auf stark ausgelasteten
	  Proxy-Servern, sind alle Portnummern für ausgehende
	  Verbindungen belegt.  Bereiche
	  für Portnummern spielen auf Servern keine Rolle, die
	  hauptsächlich eingehende Verbindungen verarbeiten (wie ein
	  normaler Webserver) oder nur eine begrenzte Anzahl
	  ausgehender Verbindungen öffnen (beispielsweise ein
	  Mail-Relay).  Wenn keine freien Portnummern mehr vorhanden
	  sind, sollte die Variable
	  <varname>net.inet.ip.portrange.last</varname> langsam
	  erhöht werden.  Ein Wert von <literal>10000</literal>,
	  <literal>20000</literal> oder <literal>30000</literal> ist
	  angemessen.  Beachten Sie auch eine vorhandene Firewall,
	  wenn Sie die Bereiche für Portnummern ändern.  Einige
	  Firewalls sperren große Bereiche (normalerweise aus den
	  kleinen Portnummern) und erwarten, dass hohe Portnummern für
	  ausgehende Verbindungen verwendet werden.  Daher kann es
	  erforderlich sein, den Wert von
	  <varname>net.inet.ip.portrange.first</varname> zu
	  erhöhen.</para>
      </sect3>

      <sect3>
	<title><literal>TCP</literal> Bandwidth Delay Product
	  Begrenzung</title>

	<indexterm>
	  <primary><literal>TCP</literal> Bandwidth Delay Product
	    Begrenzung</primary>
	  <secondary>
	    <varname>net.inet.tcp.inflight.enable</varname>
	  </secondary>
	</indexterm>

	<para>Die <literal>TCP</literal> Bandwidth Delay Product
	  Begrenzung wird aktiviert, indem die &man.sysctl.8;-Variable
	  <varname>net.inet.tcp.inflight.enable</varname> auf den
	  Wert <literal>1</literal> gesetzt wird.  Das System wird
	  dadurch angewiesen, für jede Verbindung, das Produkt aus der
	  Übertragungsrate und der Verzögerungszeit zu bestimmen.
	  Dieses Produkt begrenzt die Datenmenge, die für einen
	  optimalen Durchsatz zwischengespeichert werden muss.</para>

	<para>Diese Begrenzung ist nützlich, wenn Sie Daten
	  über Verbindungen mit einem hohen Produkt aus
	  Übertragungsrate und Verzögerungszeit wie Modems,
	  Gigabit-Ethernet oder schnellen <acronym>WAN</acronym>s, zur
	  Verfügung stellen.  Insbesondere wirkt sich die Begrenzung
	  aus, wenn die Verbindung die Option
	  <foreignphrase>Window-scaling</foreignphrase> verwendet oder
	  große Sende-Fenster
	  (<foreignphrase>send window</foreignphrase>) benutzt.
	  Schalten Sie die Debug-Meldungen aus, wenn Sie die
	  Begrenzung aktiviert haben.  Dazu setzen Sie die Variable
	  <varname>net.inet.tcp.inflight.debug</varname> auf
	  <literal>0</literal>.  Auf Produktions-Systemen sollten Sie
	  zudem die Variable
	  <varname>net.inet.tcp.inflight.min</varname> mindestens auf
	  den Wert <literal>6144</literal> setzen.  Allerdings kann
	  ein zu hoher Wert, abhängig von der Verbindung, die
	  Begrenzungsfunktion unwirksam machen.  Die Begrenzung
	  reduziert die Datenmenge in den Queues von Routern und
	  Switches, sowie die Datenmenge in der Queue der lokalen
	  Netzwerkkarte.  Die Verzögerungszeit
	  (<foreignphrase>Round Trip Time</foreignphrase>) für
	  interaktive Anwendungen sinkt, da weniger Pakete
	  zwischengespeichert werden.  Dies gilt besonders für
	  Verbindungen über langsame Modems.  Die Begrenzung
	  wirkt sich allerdings nur auf das Versenden von Daten aus
	  (Uploads, Server).  Auf den Empfang von Daten (Downloads)
	  hat die Begrenzung keine Auswirkungen.</para>

	<para>Die Variable
	  <varname>net.inet.tcp.inflight.stab</varname> sollte
	  <emphasis>nicht</emphasis> angepasst werden.  Der
	  Vorgabewert der Variablen beträgt <literal>20</literal>,
	  das heißt es werden maximal zwei Pakete zu dem Produkt
	  aus Übertragungsrate und Verzögerungszeit addiert.
	  Dies stabilisiert den Algorithmus und verbessert die
	  Reaktionszeit auf Veränderungen.  Bei langsamen
	  Verbindungen können sich aber die Laufzeiten der Pakete
	  erhöhen (ohne diesen Algorithmus wären sie allerdings noch
	  höher).  In solchen Fällen können Sie versuchen, den Wert
	  der Variablen auf <literal>15</literal>,
	  <literal>10</literal> oder <literal>5</literal>
	  herabzusetzen.  Gleichzeitig müssen Sie vielleicht auch
	  <varname>net.inet.tcp.inflight.min</varname> auf einen
	  kleineren Wert (beispielsweise <literal>3500</literal>)
	  setzen.  Ändern Sie diese Variablen nur ab, wenn Sie
	  keine anderen Möglichkeiten mehr haben.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Virtueller Speicher (<foreignphrase>Virtual
	Memory</foreignphrase>)</title>

      <sect3>
	<title><varname>kern.maxvnodes</varname></title>

	<para>Ein vnode ist die interne Darstellung einer Datei oder
	  eines Verzeichnisses.  Die Erhöhung der Anzahl der für das
	  Betriebssystem verfügbaren vnodes verringert also die
	  Schreib- und Lesezugriffe auf der Festplatte.  vnodes
	  werden im Normalfall vom Betriebssystem automatisch vergeben
	  und müssen nicht manuell angepasst werden.  In einigen
	  Fällen stellt der Zugriff auf eine Platte allerdings einen
	  Flaschenhals dar, daher sollten Sie in diesem Fall die
	  Anzahl der möglichen vnodes erhöhen, um dieses Problem zu
	  beheben.  Beachten Sie dabei aber die Größe des inaktiven
	  und freien Hauptspeichers.</para>

	<para>Um die Anzahl der derzeit verwendeten vnodes zu sehen,
	  geben Sie Folgendes ein:</para>

	<screen>&prompt.root; <userinput>sysctl vfs.numvnodes</userinput>
vfs.numvnodes: 91349</screen>

	<para>Die maximal mögliche Anzahl der vnodes erhalten Sie
	  durch die Eingabe von:</para>

	<screen>&prompt.root; <userinput>sysctl kern.maxvnodes</userinput>
kern.maxvnodes: 100000</screen>

	<para>Wenn sich die Anzahl der genutzten vnodes dem maximal
	  möglichen Wert nähert, sollten Sie den Wert
	  <varname>kern.maxvnodes</varname> zuerst um etwa
	  <literal>1000</literal> erhöhen.  Beobachten Sie danach die
	  Anzahl der vom System genutzten
	  <varname>vfs.numvnodes</varname>.  Nähert sich der Wert
	  wiederum dem definierten Maximum, müssen Sie
	  <varname>kern.maxvnodes</varname> nochmals erhöhen.  Sie
	  sollten nun eine Änderung des Speicherverbrauches über
	  &man.top.1; registrieren können und über mehr aktiven
	  Speicher verfügen.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="adding-swap-space">
    <title>Hinzufügen von Swap-Bereichen</title>

    <para>Manchmal benötigt ein System mehr Swap-Bereiche.  Dieser
      Abschnitt beschreibt zwei Methoden, um Swap-Bereiche
      hinzuzufügen:  auf einer bestehenden Partition oder auf einem
      neuen Laufwerk, und das Hinzufügen einer Swap-Datei auf einer
      existierenden Partition.</para>

    <para>Für Informationen zur Verschlüsselung von
      Swap-Partitionen, zu den dabei möglichen Optionen sowie
      zu den Gründen für eine Verschlüsselung des
      Auslagerungsspeichers lesen Sie
      <xref linkend="swap-encrypting"/>.</para>

    <sect2 xml:id="new-drive-swap">
      <title>Swap auf einer neuen Festplatte oder einer existierenden
	Partition</title>

      <para>Das Hinzufügen einer neuen Festplatte für den Swap-Bereich
	bietet eine bessere Leistung, als die Verwendung
	einer Partition auf einem vorhandenem Laufwerk.  Die
	Einrichtung von Partitionen und Laufwerken wird in
	<xref linkend="disks-adding"/> beschrieben.
	<xref linkend="configtuning-initial"/> diskutiert Aspekte über
	die Anordnung und Größe von Swap-Bereichen.</para>

      <para>Benutzen Sie <command>swapon</command> um eine
	Swap-Partition zum System hinzuzufügen.  Zum Beispiel:</para>

      <screen>&prompt.root; <userinput>swapon <replaceable>/dev/ada1s1b</replaceable></userinput></screen>

      <warning>
	<para>Sie können jede Partition verwenden, sofern sie nicht
	  schon eingehangen ist.  Das gilt auch dann, wenn die
	  Partition bereits Daten enthält.  Wird
	  <command>swapon</command> auf
	  einer Partition ausgeführt die Daten enthält, werden
	  die vorhandenen Daten überschrieben und sind unweigerlich
	  verloren.  Stellen Sie sicher, dass die Partition, die Sie
	  als Swap-Bereich hinzufügen möchten, wirklich die gewünschte
	  Partition ist, bevor Sie <command>swapon</command>
	  ausführen.</para>
      </warning>

      <para>Um diese Swap-Partition automatisch beim Systemstart
	hinzuzufügen, fügen Sie einen Eintrag in
	<filename>/etc/fstab</filename> hinzu:</para>

      <programlisting><replaceable>/dev/ada1s1b</replaceable>	none	swap	sw	0	0</programlisting>

      <para>Die einzelnen Einträge von <filename>/etc/fstab</filename>
	werden in &man.fstab.5; erläutert.  Weitere Informationen zu
	<command>swapon</command> finden Sie in &man.swapon.8;.</para>
    </sect2>

    <sect2 xml:id="create-swapfile">
      <title>Swap-Dateien erstellen</title>

      <para>Anstatt eine Partition zu verwenden, erstellen diese
	Beispiele eine 64&nbsp;MB große Swap-Datei mit dem Namen
	<filename>/usr/swap0</filename>.</para>

      <para>Die Verwendung von Swap-Dateien macht es erforderlich,
	dass das Modul &man.md.4; entweder im Kernel vorhanden oder
	geladen wird, bevor Swap aktiviert ist.  <xref
	  linkend="kernelconfig"/> enthält Informationen zum Bau eines
	angepassten Kernels.</para>

      <example xml:id="swapfile-10-and-later">
	<title>Erstellen einer Swap-Datei unter
	  &os;&nbsp;10.<replaceable>X</replaceable> und neuer</title>

	<procedure>
	  <step>
	    <para>Erstellen Sie die Swap-Datei:</para>

	    <screen>&prompt.root; <userinput>dd if=/dev/zero of=<replaceable>/usr/swap0</replaceable> bs=1024k count=<replaceable>64</replaceable></userinput></screen>
	  </step>

	  <step>
	    <para>Setzen Sie die richtigen Berechtigungen für die neue
	      Datei:</para>

	    <screen>&prompt.root; <userinput>chmod 0600 <replaceable>/usr/swap0</replaceable></userinput></screen>
	  </step>

	  <step>
	    <para>Fügen Sie einen Eintrag in
	      <filename>/etc/fstab</filename> hinzu:</para>

	      <programlisting>md99	none	swap	sw,file=/usr/swap0,late	0	0</programlisting>

	    <para>Das &man.md.4; Gerät <filename>md99</filename> wird
	      verwendet, damit die niedrigeren Gerätenummer für die
	      interaktive Benutzung frei bleiben.</para>
	  </step>

	  <step>
	    <para>Der Swap-Speicher wird nun automatisch beim
	      Systemstart hinzugefügt.  Benutzen Sie &man.swapon.8; um
	      den Swap-Speicher direkt zu aktivieren:</para>

	    <screen>&prompt.root; <userinput>swapon -aL</userinput></screen>
	  </step>
	</procedure>
      </example>

      <example xml:id="swapfile-9-and-earlier">
	<title>Erstellen einer Swap-Datei unter
	  &os;&nbsp;9.<replaceable>X</replaceable> und älter</title>

	<procedure>
	  <step>
	    <para>Erstellen Sie die Swap-Datei
	      <filename>/usr/swap0</filename>:</para>

	    <screen>&prompt.root; <userinput>dd if=/dev/zero of=<replaceable>/usr/swap0</replaceable> bs=1024k count=<replaceable>64</replaceable></userinput></screen>
	  </step>

	  <step>
	    <para>Setzen Sie die richtigen Berechtigungen für die neue
	      Datei:</para>

	    <screen>&prompt.root; <userinput>chmod 0600 <replaceable>/usr/swap0</replaceable></userinput></screen>
	  </step>

	  <step>
	    <para>Aktivieren Sie die Swap-Datei in
	      <filename>/etc/rc.conf</filename>:</para>

	    <programlisting>swapfile="/usr/swap0"	# Set to name of swap file</programlisting>
	  </step>

	  <step>
	    <para>Um die Swap-Datei sofort zu aktivieren,
	      spezifizieren Sie ein speicherbasiertes Laufwerk.
	      <xref linkend="disks-virtual"/> enthält weitere
	      Informationen.</para>

	    <screen>&prompt.root; <userinput>mdconfig -a -t vnode -f <replaceable>/usr/swap0</replaceable> -u 0 &amp;&amp; swapon <replaceable>/dev/md0</replaceable></userinput></screen>
	  </step>
	</procedure>
      </example>
    </sect2>
  </sect1>

  <sect1 xml:id="acpi-overview">
    <info>
      <title>Energie- und Ressourcenverwaltung</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Hiten</firstname>
	    <surname>Pandya</surname>
	  </personname>
	  <contrib>Verfasst von </contrib>
	</author>
	<author>
	  <personname>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	  </personname>
	</author>
      </authorgroup>
    </info>

    <para>Es ist wichtig, Hardware effizient einzusetzen.  Energie-
      und Ressourcenverwaltung ermöglicht es dem System auf
      verschiedene Ereignisse, beispielsweise einen unerwarteten
      Temperaturanstieg, reagieren zu können.  Eine frühe
      Spezifikation für die Energieverwaltung war das
      <foreignphrase>Advanced Power Management</foreignphrase>
      (<acronym>APM</acronym>).  <acronym>APM</acronym> steuert den
      Energieverbrauch eines Systems auf Basis der Systemaktivität.
      Ursprünglich konnten Stromverbrauch und Wärmeabgabe eines
      Systems nur schlecht von Betriebssystemen gesteuert werden.
      Die Hardware wurde vom <acronym>BIOS</acronym> gesteuert, was
      die Kontrolle der Energieverwaltung für den Anwender erschwerte.
      Das <acronym>APM</acronym>-<acronym>BIOS</acronym> wird von dem
      Hersteller des Systems zur Verfügung gestellt und ist auf die
      spezielle Hardware angepasst.  Der
      <acronym>APM</acronym>-Treiber des Betriebssystems greift auf
      das
      <emphasis><acronym>APM</acronym> Software Interface</emphasis>
      zu, das den Energieverbrauch regelt.</para>

    <para><acronym>APM</acronym> hat hauptsächlich vier Probleme.
      Erstens läuft die Energieverwaltung unabhängig vom
      Betriebssystem in einem herstellerspezifischen
      <acronym>BIOS</acronym>.  Beispielsweise kann das
      <acronym>APM</acronym>-<acronym>BIOS</acronym> die Festplatten
      nach einer konfigurierbaren Zeit ohne die Zustimmung des
      Betriebssystems herunterfahren.  Zweitens befindet sich die
      ganze <acronym>APM</acronym>-Logik im <acronym>BIOS</acronym>;
      das Betriebssystem hat gar keine
      <acronym>APM</acronym>-Komponenten.  Bei Problemen mit dem
      <acronym>APM</acronym>-<acronym>BIOS</acronym> muss das
      Flash-ROM aktualisiert werden.  Diese Prozedur ist gefährlich,
      da sie im Fehlerfall das System unbrauchbar machen kann.  Zum
      Dritten ist <acronym>APM</acronym> eine Technik, die
      herstellerspezifisch ist und nicht koordiniert wird.  Fehler im
      <acronym>BIOS</acronym> eines Herstellers werden nicht unbedingt
      im <acronym>BIOS</acronym> anderer Hersteller korrigiert.  Das
      letzte Problem ist, dass im
      <acronym>APM</acronym>-<acronym>BIOS</acronym> nicht genügend
      Platz vorhanden ist, um eine durchdachte oder eine auf den Zweck
      der Maschine zugeschnittene Energieverwaltung zu
      implementieren.</para>

    <para>Das <emphasis>Plug and Play <acronym>BIOS</acronym>
	(<acronym>PNPBIOS</acronym>)</emphasis> war in vielen
      Situationen ebenfalls unzureichend.  Das
      <acronym>PNPBIOS</acronym> verwendet eine 16-Bit-Technik.  Damit
      das Betriebssystem das <acronym>PNPBIOS</acronym> ansprechen
      kann, muss es in einer 16-Bit-Emulation laufen.  &os; stellt
      einen <acronym>APM</acronym>-Treiber zur Verfügung, welcher für
      Systeme benutzt werden sollte, die vor dem Jahr 2000 hergestellt
      wurden.  Der Treiber wird in &man.apm.4; beschrieben.</para>

    <indexterm><primary>ACPI</primary></indexterm>
    <indexterm><primary>APM</primary></indexterm>

    <para>Der Nachfolger von <acronym>APM</acronym> ist das
      <emphasis>Advanced Configuration and Power Interface</emphasis>
      (<acronym>ACPI</acronym>).  <acronym>ACPI</acronym> ist ein
      Standard verschiedener Hersteller, welcher die Verwaltung von
      Hardware und Energiesparfunktionen festlegt.  Die
      <acronym>ACPI</acronym>-Funktionen, die mehr Kontrolle und
      Flexibilität bieten, können vom Betriebssystem gesteuert
      werden.</para>

    <para>Dieser Abschnitt zeigt die Konfiguration von
      <acronym>ACPI</acronym> unter &os;.  Zudem werden einige Tipps
      zur Fehlersuche vorgestellt und wie Sie Problemberichte
      einreichen können, sodass Entwickler
      <acronym>ACPI</acronym>-Probleme erfassen und beheben
      können.</para>

    <sect2 xml:id="acpi-config">
      <title>Konfiguration des <acronym>ACPI</acronym></title>

      <para>Der &man.acpi.4;-Treiber wird standardmäßig beim
	Systemstart vom &man.loader.8; geladen und sollte daher
	<emphasis>nicht</emphasis> fest in den Kernel eingebunden
	werden.  Der Treiber kann im laufenden Betrieb nicht entfernt
	werden, da er zur Kommunikation mit der Hardware verwendet
	wird.  Falls jedoch Probleme auftreten, kann
	<acronym>ACPI</acronym> auch komplett deaktiviert werden.
	Dazu muss <literal>hint.acpi.0.disabled="1"</literal> in
	<filename>/boot/loader.conf</filename> gesetzt und
	anschließend das System neu gestartet werden.  Alternativ
	können Sie diese Variable auch am &man.loader.8;-Prompt
	eingeben, wie in <xref linkend="boot-loader"/>
	beschrieben.</para>

      <note>
	<para><acronym>ACPI</acronym> und <acronym>APM</acronym>
	  können nicht zusammen verwendet werden.  Das zuletzt
	  geladene Modul beendet sich, sobald es bemerkt, dass das
	  andere Modul geladen ist.</para>
      </note>

      <para>Mit <command>acpiconf</command> können Sie das System in
	einen Ruhemodus (<foreignphrase>sleep mode</foreignphrase>)
	versetzen.  Es gibt verschiedene Modi
	(von <literal>1</literal> bis <literal>5</literal>), die Sie
	auf der Kommandozeile mit <option>-s</option> angeben können.
	Für die meisten Anwender sind die Modi <literal>1</literal>
	und <literal>3</literal> völlig ausreichend.  Der Modus
	<literal>5</literal> schaltet das System
	aus (<foreignphrase>Soft-off</foreignphrase>) und entspricht
	dem Befehl <command>halt -p</command>.</para>

      <para>Verschiedene Optionen können mit <command>sysctl</command>
	gesetzt werden.  Lesen Sie dazu &man.acpi.4; sowie
	&man.acpiconf.8;.</para>
    </sect2>

    <sect2 xml:id="ACPI-comprob">
      <title>Häufige Probleme</title>

      <indexterm>
	<primary><acronym>ACPI</acronym></primary>
      </indexterm>

      <para><acronym>ACPI</acronym> gibt es in allen modernen Rechnern
	der ia32- (x86), ia64- (Itanium) und amd64-
	(<acronym>AMD</acronym>) Architektur.
	Der vollständige Standard bietet Funktionen zur Steuerung und
	Verwaltung der <acronym>CPU</acronym>-Leistung, der
	Stromversorgung, von Wärmebereichen, Batterien, eingebetteten
	Controllern und Bussen.  Auf den meisten Systemen wird nicht
	der vollständige Standard implementiert.  Arbeitsplatzrechner
	besitzen meist nur Funktionen zur Verwaltung der Busse,
	während Notebooks Funktionen zur Temperaturkontrolle und
	Ruhezustände besitzen.</para>

      <para>Ein <acronym>ACPI</acronym> konformes System besitzt
	verschiedene Komponenten.  Die <acronym>BIOS</acronym>- und
	Chipsatz-Hersteller stellen mehrere statische Tabellen bereit,
	zum Beispiel die
	Fixed-<acronym>ACPI</acronym>-Description-Table
	(<acronym>FADT</acronym>).  Die Tabellen enthalten
	beispielsweise die mit <acronym>SMP</acronym>-Systemen
	benutzte <acronym>APIC</acronym>-Map, Konfigurationsregister
	und einfache Konfigurationen.  Zusätzlich gibt es die
	<emphasis>Differentiated-System-Description-Table</emphasis>
	(<acronym>DSDT</acronym>), die Bytecode enthält.  Die Tabelle
	ordnet Geräte und Methoden in einem baumartigen Namensraum
	an.</para>

      <para>Ein <acronym>ACPI</acronym>-Treiber muss die statischen
	Tabellen einlesen, einen Interpreter für den Bytecode
	bereitstellen und die Gerätetreiber im Kernel so
	modifizieren, dass sie mit dem
	<acronym>ACPI</acronym>-Subsystem kommunizieren.  Für &os;,
	&linux; und NetBSD hat &intel; den Interpreter
	<acronym>ACPI-CA</acronym>, zur Verfügung gestellt.  Der
	Quelltext zu <acronym>ACPI-CA</acronym> befindet sich im
	Verzeichnis <filename>src/sys/contrib/dev/acpica</filename>.
	Die Schnittstelle von <acronym>ACPI-CA</acronym> zu &os;
	befindet sich unter
	<filename>src/sys/dev/acpica/Osd</filename>.  Treiber, die
	verschiedene <acronym>ACPI</acronym>-Geräte implementieren,
	befinden sich im Verzeichnis
	<filename>src/sys/dev/acpica</filename>.</para>

      <indexterm>
	<primary>ACPI</primary>
	<secondary>Probleme mit</secondary>
      </indexterm>

      <para>Damit <acronym>ACPI</acronym> richtig funktioniert,
	müssen alle Teile funktionieren.  Im Folgenden
	finden Sie eine Liste mit Problemen und möglichen
	Abhilfen oder Korrekturen.  Die Liste ist nach
	der Häufigkeit, mit der die Probleme auftreten,
	sortiert.  Wenn eine Korrektur das Problem nicht
	behebt, finden Sie in <xref linkend="ACPI-submitdebug"/>
	Anweisungen, wie Sie einen Problembericht einreichen
	können.</para>

      <sect3>
	<title>Mausprobleme</title>

	<para>Es kann vorkommen, dass die Maus nicht mehr
	  funktioniert, wenn Sie nach einem Suspend weiterarbeiten
	  wollen.  Ist dies bei Ihnen der Fall, reicht es meistens
	  aus, den Eintrag
	  <literal>hint.psm.0.flags="0x3000"</literal> in
	  <filename>/boot/loader.conf</filename> aufzunehmen.</para>
      </sect3>

      <sect3>
	<title>Suspend/Resume</title>

	<para><acronym>ACPI</acronym> kennt drei
	  Suspend-to-<acronym>RAM</acronym>-Zustände
	  (<acronym>STR</acronym>),
	  <literal>S1</literal>-<literal>S3</literal> sowie einen
	  Suspend-to-Disk-Zustand (<acronym>STD</acronym>)
	  <literal>S4</literal>.  <acronym>STD</acronym> kann auf zwei
	  Arten implementiert werden:
	  <literal>S4</literal><acronym>BIOS</acronym> und
	  <literal>S4</literal><acronym>OS</acronym>.  Im ersten Fall
	  wird der Suspend-to-Disk-Zustand durch das
	  <acronym>BIOS</acronym> hergestellt im zweiten Fall alleine
	  durch das Betriebssystem.  Der Zustand <literal>S5</literal>
	  wird <quote>Soft off</quote> genannt.  In diesem Zustand
	  befindet sich ein Rechner, wenn die Stromversorgung
	  angeschlossen ist, der Rechner aber nicht hochgefahren
	  ist.</para>

	<para>Benutzen Sie <command>sysctl hw.acpi</command> um die
	  Suspend-Zustände zu ermitteln.  Diese Beispielausgabe stammt
	  von einem Thinkpad:</para>

	<screen>hw.acpi.supported_sleep_state: S3 S4 S5
hw.acpi.s4bios: 0</screen>

	<para>Diese Ausgabe besagt, dass mit dem Befehl
	  <command>acpiconf -s</command> die Zustände
	  <literal>S3</literal>, <literal>S4</literal>
	  und <literal>S5</literal> eingestellt werden können.
	  Hätte <option>s4bios</option> den Wert
	  <literal>1</literal>, gäbe es den Zustand
	  <literal>S4</literal><acronym>BIOS</acronym> anstelle
	  von <literal>S4</literal>.</para>

	<para>Wenn Sie die Suspend- und Resume-Funktionen
	  testen, fangen Sie mit dem <literal>S1</literal>-Zustand
	  an, wenn er angeboten wird.  Dieser Zustand wird
	  am ehesten funktionieren, da der Zustand wenig
	  Treiber-Unterstützung benötigt.  Der Zustand
	  <literal>S2</literal> ist ähnlich wie
	  <literal>S1</literal>, allerdings hat ihn noch niemand
	  implementiert.  Als nächstes sollten Sie den
	  Zustand <literal>S3</literal> ausprobieren.  Dies
	  ist der tiefste <acronym>STR</acronym>-Schlafzustand.
	  Dieser Zustand ist auf massive Treiber-Unterstützung
	  angewiesen, um die Geräte wieder richtig zu
	  initialisieren.</para>

	<para>Ein häufiges Problem mit Suspend/Resume ist,
	  dass viele Gerätetreiber ihre Firmware, Register
	  und Gerätespeicher nicht korrekt speichern,
	  wiederherstellen und/oder reinitialisieren.  Um dieses
	  Problem zu lösen, sollten Sie zuerst die
	  folgenden Befehle ausführen:</para>

	<screen>&prompt.root; <userinput>sysctl debug.bootverbose=1</userinput>
&prompt.root; <userinput>sysctl debug.acpi.suspend_bounce=1</userinput>
&prompt.root; <userinput>acpiconf -s 3</userinput></screen>

	<para>Dieser Test emuliert einen Suspend/Resume-Zyklus für
	  alle Geräte (ohne dass diese dabei wirklich in den Status
	  <literal>S3</literal> wechseln).  In vielen Fällen
	  reicht dies bereits aus, um Probleme (beispielsweise
	  verlorener Firmware-Status, Timeouts, hängende Geräte)
	  zu entdecken.  Beachten Sie dabei, dass das Gerät bei
	  diesem Test nicht wirklich in den Status
	  <literal>S3</literal> wechseln.  Es kann also vorkommen,
	  dass manche Geräte weiterhin mit Strom versorgt werden (dies
	  wäre bei einem wirklichen Wechsel in den Status
	  <literal>S3</literal> NICHT möglich.
	  Andere Geräte werden normal weiterarbeiten, weil sie
	  über keine Suspend/Resume-Funktionen verfügen.</para>

	<para>Schwierigere Fälle können den Einsatz
	  zusätzlicher Hardware (beispielsweise serielle
	  Ports/Kabel für die Verbindung über eine
	  serielle Konsole oder Firewire-Ports/Kabel für
	  &man.dcons.4;) sowie Kenntnisse im Bereich
	  Kerneldebugging erforderlich machen.</para>

	<para>Um das Problem einzugrenzen, entladen Sie soviele
	  Treiber wie möglich.  Wenn das funktioniert, laden Sie einen
	  Treiber nach dem anderen, bis der Fehler wieder auftritt.
	  Typischerweise verursachen binäre Treiber wie
	  <filename>nvidia.ko</filename>, Grafiktreiber und
	  <acronym>USB</acronym>-Treiber die meisten Fehler,
	  hingegen laufen Ethernet-Treiber für gewöhnlich
	  sehr zuverlässig.  Wenn ein Treiber
	  zuverlässig geladen und entfernt werden kann,
	  können Sie den Vorgang automatisieren, indem
	  Sie die entsprechenden Kommandos in
	  <filename>/etc/rc.suspend</filename> und
	  <filename>/etc/rc.resume</filename> einfügen.
	  In den Dateien finden Sie ein deaktiviertes Beispiel,
	  das einen Treiber lädt und wieder entfernt.
	  Ist die Bildschirmanzeige bei der Wiederaufnahme
	  des Betriebs gestört, setzen Sie die
	  Variable <option>hw.acpi.reset_video</option> auf
	  <literal>1</literal>.  Versuchen Sie auch, die Variable
	  <option>hw.acpi.sleep_delay</option> auf kürzere
	  Zeitspannen zu setzen.</para>

	<para>Die Suspend- und Resume-Funktionen können
	  Sie auch auf einer neuen &linux;-Distribution
	  mit <acronym>ACPI</acronym> testen.  Wenn es mit
	  &linux; funktioniert, liegt das Problem wahrscheinlich
	  bei einem &os;-Treiber.  Es hilft uns, das Problem
	  zu lösen, wenn Sie feststellen können, welcher
	  Treiber das Problem verursacht.  Beachten Sie bitte,
	  dass die <acronym>ACPI</acronym>-Entwickler normalerweise
	  keine anderen Treiber pflegen (beispielsweise Sound- oder
	  <acronym>ATA</acronym>-Treiber).  Es ist wohl das beste,
	  die Ergebnisse der Fehlersuche an die Mailingliste
	  &a.current.name; und den Entwickler des Treibers
	  zu schicken.  Erfahrene Benutzer können versuchen, den
	  Fehler in der Resume-Funktion zu finden, indem
	  sie einige &man.printf.3;-Anweisungen in den Code
	  des fehlerhaften Treibers einfügen.</para>

	<para>Schließlich können Sie <acronym>ACPI</acronym>
	  noch abschalten und stattdessen <acronym>APM</acronym>
	  verwenden.  Wenn die Suspend- und Resume-Funktionen mit
	  <acronym>APM</acronym> funktionieren, sollten Sie
	  besser <acronym>APM</acronym> verwenden
	  (insbesondere mit alter Hardware von vor dem Jahr 2000).
	  Die Hersteller benötigten einige Zeit, um
	  <acronym>ACPI</acronym> korrekt zu implementieren, daher
	  gibt es mit älterer Hardware oft
	  <acronym>ACPI</acronym>-Probleme.</para>
      </sect3>

      <sect3>
	<title>Systemhänger</title>

	<para>Die meisten Systemhänger entstehen durch verlorene
	  Interrupts oder einen Interrupt-Sturm.
	  Probleme werden verursacht durch die Art, in der das
	  <acronym>BIOS</acronym> Interrupts vor dem Systemstart
	  konfiguriert, durch eine fehlerhafte
	  <acronym>APIC</acronym>-Tabelle und durch die
	  Zustellung des System-Control-Interrupts
	  (<acronym>SCI</acronym>).</para>

	<indexterm>
	  <primary>Interrupt-Sturm</primary>
	</indexterm>

	<para>Anhand der Ausgabe des Befehls
	  <command>vmstat -i</command> können Sie verlorene
	  Interrupts von einem Interrupt-Sturm unterscheiden.
	  Untersuchen Sie die Ausgabezeile, die
	  <literal>acpi0</literal> enthält.  Ein Interrupt-Sturm liegt
	  vor, wenn der Zähler öfter als ein paar Mal pro Sekunde
	  hochgezählt wird.  Wenn sich das System aufgehangen hat,
	  versuchen Sie mit der Tastenkombination
	  <keycombo action="simul">
	    <keycap>Ctrl</keycap>
	    <keycap>Alt</keycap>
	    <keycap>Esc</keycap>
	  </keycombo> in den Debugger <acronym>DDB</acronym>
	  zu gelangen.  Geben Sie dort den Befehl
	  <literal>show interrupts</literal> ein.</para>

	<indexterm>
	  <primary>APIC</primary>
	  <secondary>deaktivieren</secondary>
	</indexterm>

	<para>Wenn Sie Interrupt-Probleme haben, ist es vorerst
	  wohl am besten, <acronym>APIC</acronym> zu deaktivieren.
	  Tragen Sie dazu die Zeile
	  <literal>hint.apic.0.disabled="1"</literal> in
	  <filename>/boot/loader.conf</filename> ein.</para>
      </sect3>

      <sect3>
	<title>Abstürze (Panics)</title>

	<para><foreignphrase>Panics</foreignphrase> werden so
	  schnell wie möglich behoben;  mit <acronym>ACPI</acronym>
	  kommt es aber selten dazu.  Zuerst sollten Sie
	  die Panic reproduzieren und dann versuchen einen
	  <foreignphrase>backtrace</foreignphrase> (eine
	  Rückverfolgung der Funktionsaufrufe) zu erstellen.
	  Richten Sie dazu den <acronym>DDB</acronym> über
	  die serielle Schnittstelle (siehe
	  <xref linkend="serialconsole-ddb"/>) oder eine gesonderte
	  &man.dump.8;-Partition ein.  In <acronym>DDB</acronym>
	  können Sie den <foreignphrase>backtrace</foreignphrase>
	  mit dem Kommando <literal>tr</literal> erstellen.
	  Falls Sie den <foreignphrase>backtrace</foreignphrase>
	  vom Bildschirm abschreiben müssen, schreiben
	  Sie bitte mindestens die fünf ersten und die
	  fünf letzten Zeile der Ausgabe auf.</para>

	<para>Versuchen Sie anschließend, das Problem
	  durch einen Neustart ohne <acronym>ACPI</acronym>
	  zu beseitigen.  Wenn das funktioniert hat, können
	  Sie versuchen, das verantwortliche
	  <acronym>ACPI</acronym>-Subsystem durch Setzen der
	  Variablen <option>debug.acpi.disable</option>
	  herauszufinden.  Die Hilfeseite &man.acpi.4; enthält
	  dazu einige Beispiele.</para>
      </sect3>

      <sect3>
	<title>Nach einem Suspend oder einem Stopp startet
	  das System wieder</title>

	<para>Setzen Sie zuerst
	  <option>hw.acpi.disable_on_poweroff="0"</option> in
	  <filename>/boot/loader.conf</filename>.  Damit wird
	  verhindert, dass <acronym>ACPI</acronym> während des
	  Systemabschlusses die Bearbeitung verschiedener Ereignisse
	  deaktiviert.  Auf manchen Systemen muss die Variable den
	  Wert <literal>1</literal> besitzen (die Voreinstellung).
	  Normalerweise wird der unerwünschte Neustart des Systems
	  durch Setzen dieser Variablen behoben.</para>
      </sect3>

      <sect3 xml:id="ACPI-aslanddump">
	<title>BIOS mit fehlerhaftem Bytecode</title>

	<indexterm>
	  <primary><acronym>ACPI</acronym></primary>
	  <secondary><acronym>ASL</acronym></secondary>
	</indexterm>

	<para>Einige <acronym>BIOS</acronym>-Hersteller liefern einen
	  fehlerhaften Bytecode aus.  Dies erkennen Sie an
	  Kernelmeldungen wie diesen:</para>

	<screen>ACPI-1287: *** Error: Method execution failed [\\_SB_.PCI0.LPC0.FIGD._STA] \\
(Node 0xc3f6d160), AE_NOT_FOUND</screen>

	<para>Oft können Sie das Problem dadurch lösen, dass Sie eine
	  aktuelle <acronym>BIOS</acronym>-Version einspielen.  Die
	  meisten Meldungen auf der Konsole sind harmlos,  wenn aber
	  beispielsweise der Batteriestatus falsch angezeigt wird,
	  können Sie in den Meldungen nach Problemen suchen.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Die voreingestellte <acronym>ASL</acronym>
	überschreiben</title>

      <para>Der <acronym>BIOS</acronym>-Bytecode, bekannt als
	<acronym>ACPI</acronym> Maschine Language
	(<acronym>AML</acronym>) wird aus der Sprache namens
	<acronym>ACPI</acronym> Source Language
	(<acronym>ASL</acronym>) übersetzt.  Die
	<acronym>AML</acronym> ist in einer Tabelle, bekannt als
	Differentiated System Description Table
	(<acronym>DSDT</acronym>), abgelegt.</para>

      <indexterm>
	<primary><acronym>ACPI</acronym></primary>
	<secondary><acronym>ASL</acronym></secondary>
      </indexterm>

      <para>Es ist das Ziel von &os;, dass
	<acronym>ACPI</acronym> ohne Eingriffe des Benutzers
	läuft.  Zurzeit werden allerdings noch Abhilfen für Fehler
	der <acronym>BIOS</acronym>-Hersteller entwickelt.
	Der &microsoft;-Interpreter (<filename>acpi.sys</filename>
	und <filename>acpiec.sys</filename>) prüft die
	<acronym>ASL</acronym> nicht streng gegen den Standard.
	Daher reparieren <acronym>BIOS</acronym>-Hersteller,
	die <acronym>ACPI</acronym> nur unter &windows; testen,
	ihre <acronym>ASL</acronym> nicht.  Die &os; Entwickler
	hoffen, dass sie das vom Standard abweichende Verhalten des
	&microsoft;-Interpreters dokumentieren und in &os; replizieren
	können.  Dadurch müssen Benutzer ihre
	<acronym>ASL</acronym> nicht selbst reparieren.</para>

      <para>Um bei der Fehlersuche zu helfen und das Problem
	möglicherweise zu beheben, kann eine Kopie der
	<acronym>ASL</acronym> gemacht werden.  Dazu nutzen Sie
	<command>acpidump</command> zusammen mit <option>-t</option>,
	um den Inhalt der Tabelle anzuzeigen und <option>-d</option>,
	um die <acronym>AML</acronym> zu zerlegen:</para>

      <screen>&prompt.root; <userinput>acpidump -td > <replaceable>my.asl</replaceable></userinput></screen>

      <para>Einige <acronym>AML</acronym>s gehen davon aus, dass
	der Anwender eine &windows;-Versionen benutzt.  Versuchen
	Sie das Betriebssystem, das Sie in der <acronym>ASL</acronym>
	finden, in <filename>/boot/loader.conf</filename> anzugeben:
	<literal>hw.acpi.osname=<replaceable>"Windows 2009"</replaceable></literal>.</para>

      <para>Manche Abhilfen erfordern eine Anpassung von
	<filename>my.asl</filename>.  Wenn diese Datei bearbeitet
	wird, erstellen Sie die neue <acronym>ASL</acronym> mit dem
	folgenden Befehl.  Warnung können meistens ignoriert werden,
	aber Fehler verhindern die ordnungsgemäße Funktion von
	<acronym>ACPI</acronym>.</para>

      <screen>&prompt.root; <userinput>iasl -f <replaceable>my.asl</replaceable></userinput></screen>

      <para>Die Option <option>-f</option> erzwingt das Erstellen der
	<acronym>AML</acronym> auch dann, wenn während der Übersetzung
	Fehler auftreten.  Einige Fehler, wie fehlende
	Return-Anweisungen, werden automatisch vom &os; Interpreter
	umgangen.</para>

      <para>Die voreingestellte Ausgabedatei von
	<command>iasl</command> ist <filename>DSDT.aml</filename>.
	Wenn Sie diese Datei anstelle der fehlerhaften Kopie des
	<acronym>BIOS</acronym> laden wollen, editieren Sie
	<filename>/boot/loader.conf</filename> wie folgt:</para>

      <programlisting>acpi_dsdt_load="YES"
acpi_dsdt_name="/boot/DSDT.aml"</programlisting>

      <para>Stellen Sie bitte sicher, dass sich
	<filename>DSDT.aml</filename> in
	<filename>/boot</filename> befindet und starten Sie das
	System neu.  Wenn dadurch das Problem behoben wird, schicken
	Sie einen &man.diff.1; der alten und der neuen
	<acronym>ASL</acronym> an &a.acpi.name;, damit die
	Entwickler das Problem in <filename>acpica</filename>
	umgehen können.</para>
    </sect2>

    <sect2 xml:id="ACPI-submitdebug">
      <info>
	<title>Abrufen und Einreichen von Informationen zur
	  Fehlersuche</title>

	<authorgroup>
	  <author>
	    <personname>
	      <firstname>Nate</firstname>
	      <surname>Lawson</surname>
	    </personname>
	    <contrib>Geschrieben von </contrib>
	  </author>
	</authorgroup>

	<authorgroup>
	  <author>
	    <personname>
	      <firstname>Peter</firstname>
	      <surname>Schultz</surname>
	    </personname>
	    <contrib>Mit Beiträgen von </contrib>
	  </author>

	  <author>
	    <personname>
	      <firstname>Tom</firstname>
	      <surname>Rhodes</surname>
	    </personname>
	  </author>
	</authorgroup>
      </info>

      <indexterm>
	<primary>ACPI</primary>
	<secondary>Probleme mit</secondary>
      </indexterm>

      <indexterm>
	<primary>ACPI</primary>
	<secondary>Fehlersuche</secondary>
      </indexterm>

      <para>Der <acronym>ACPI</acronym>-Treiber besitzt
	flexible Möglichkeiten zur Fehlersuche.  Sie
	können sowohl die zu untersuchenden Subsysteme
	als auch die zu erzeugenden Ausgaben festlegen.  Die zu
	untersuchenden Subsysteme werden als <quote>layer</quote>
	angegeben und in Komponenten
	(<literal>ACPI_ALL_COMPONENTS</literal>) und
	<acronym>ACPI</acronym>-Hardware
	(<literal>ACPI_ALL_DRIVERS</literal>) aufgeteilt.
	Welche Meldungen ausgegeben werden, wird über
	<quote>level</quote> gesteuert.  Die Level reichen von von
	<literal>ACPI_LV_ERROR</literal> (es werden nur Fehler
	ausgegeben) bis zu <literal>ACPI_LV_VERBOSE</literal> (alles
	wird ausgegeben).  Das Level ist eine Bitmaske, sodass
	verschiedene Stufen auf einmal (durch Leerzeichen getrennt)
	angegeben werden können.  Die erzeugte Ausgabemenge passt
	vielleicht nicht in den Konsolenpuffer.  In diesem Fall sollte
	die Ausgabe mithilfe einer seriellen Konsole gesichert werden.
	Die möglichen Werte für <quote>layers</quote> und
	<quote>level</quote> werden in &man.acpi.4;
	beschrieben.</para>

      <para>Die Ausgaben zur Fehlersuche sind in der Voreinstellung
	nicht aktiviert.  Wenn <acronym>ACPI</acronym> im Kernel
	enthalten ist, fügen Sie <literal>options ACPI_DEBUG</literal>
	zur Kernelkonfigurationsdatei hinzu.  Sie können die
	Ausgaben zur Fehlersuche global aktivieren, indem Sie in der
	Datei <filename>/etc/make.conf</filename> die Zeile
	<literal>ACPI_DEBUG=1</literal> einfügen.  Das Modul
	<filename>acpi.ko</filename> können Sie wie folgt
	neu übersetzen:</para>

      <screen>&prompt.root; <userinput>cd /sys/modules/acpi/acpi &amp;&amp; make clean &amp;&amp; make ACPI_DEBUG=1</userinput></screen>

      <para>Kopieren Sie anschließend
	<filename>acpi.ko</filename> ins Verzeichnis
	<filename>/boot/kernel</filename>.
	In <filename>/boot/loader.conf</filename> stellen Sie
	<quote>level</quote> und <quote>layer</quote> ein.  Das
	folgende Beispiel aktiviert die Ausgabe von Fehlern für
	alle <acronym>ACPI</acronym>-Komponenten und alle
	Hardwaretreiber:</para>

      <programlisting>debug.acpi.layer="ACPI_ALL_COMPONENTS ACPI_ALL_DRIVERS"
debug.acpi.level="ACPI_LV_ERROR"</programlisting>

      <para>Wenn ein Problem durch ein bestimmtes Ereignis,
	beispielsweise den Start nach einem Ruhezustand, hervorgerufen
	wird, können Sie die Einstellungen für
	<quote>level</quote> und <quote>layer</quote> auch mit dem
	Kommando <command>sysctl</command> vornehmen.  In diesem
	Fall müssen Sie <filename>/boot/loader.conf</filename>
	nicht editieren.  Auf der Kommandozeile geben Sie über
	<command>sysctl</command> dieselben Variablennamen wie in
	<filename>/boot/loader.conf</filename> an.</para>

      <indexterm>
	<primary>ACPI</primary>
	<secondary>Probleme mit</secondary>
      </indexterm>

      <para>Sobald Sie die Fehlerinformationen gesammelt haben,
	schicken Sie diese an &a.acpi.name;, sodass die Betreuer des
	&os;-<acronym>ACPI</acronym>-Subsystems diese Informationen
	zur Analyse und für die Entwicklung einer Lösung verwenden
	können.</para>

      <note>
	<para>Bevor Sie einen Fehlerbericht an diese Mailingliste
	  einreichen, stellen Sie bitte sicher, dass das
	  <acronym>BIOS</acronym> und die Firmware des Controllers
	  aktuell sind.</para>
      </note>

      <para>Wenn Sie einen Fehlerbericht einsenden, fügen Sie bitte
	die folgenden Informationen ein:</para>

      <itemizedlist>
	<listitem>
	  <para>Beschreiben Sie den Fehler und alle Umstände,
	    unter denen der Fehler auftritt.  Geben Sie
	    ebenfalls den Typ und das Modell Ihres Systems
	    an.  Wenn Sie einen neuen Fehler entdeckt haben,
	    versuchen Sie möglichst genau zu beschreiben,
	    wann der Fehler das erste Mal aufgetreten ist.</para>
	</listitem>

	<listitem>
	  <para>Die Ausgabe von <command>dmesg</command> nach der
	    Eingabe von <command>boot -v</command>.
	    Geben Sie auch alle Fehlermeldungen an, die erscheinen,
	    wenn Sie den Fehler provozieren.</para>
	</listitem>

	<listitem>
	  <para>Die Ausgabe von <command>dmesg</command> nach der
	    Eingabe von <command>boot -v</command> und mit
	    deaktiviertem <acronym>ACPI</acronym>, wenn das Problem
	    ohne <acronym>ACPI</acronym> nicht auftritt.</para>
	</listitem>

	<listitem>
	  <para>Die Ausgabe von <command>sysctl hw.acpi</command>.
	    Dieses Kommando zeigt die vom System unterstützten
	    <acronym>ACPI</acronym>-Funktionen an.</para>
	</listitem>

	<listitem>
	  <para>Die <acronym>URL</acronym>, unter der die
	    <acronym>ASL</acronym> liegt.  Schicken Sie
	    bitte <emphasis>nicht</emphasis> die
	    <acronym>ASL</acronym> an die Mailingliste, da die
	    <acronym>ASL</acronym> sehr groß sein kann.  Eine Kopie
	    der <acronym>ASL</acronym> erstellen Sie mit dem
	    nachstehenden Befehl:</para>

	  <screen>&prompt.root; <userinput>acpidump -td &gt; <replaceable>name</replaceable>-<replaceable>system</replaceable>.asl</userinput></screen>

	  <para>Setzen Sie für <replaceable>name</replaceable>
	    den Namen des Kontos und für
	    <replaceable>system</replaceable> den Hersteller und
	    das Modell des Systems ein.  Zum Beispiel:
	    <filename>njl-FooCo6000.asl</filename>.</para>
	</listitem>
      </itemizedlist>

      <para>Obwohl die meisten Entwickler die Mailingliste
	&a.current.name; lesen, sollten Sie Fehlerberichte an
	die Liste &a.acpi.name; schicken.  Seien Sie bitte
	geduldig;  wir haben alle Arbeit außerhalb des Projekts.
	Wenn der Fehler nicht offensichtlich ist, bitten
	wir Sie vielleicht, einen offiziellen Fehlerbericht
	(<acronym>PR</acronym>) mit &man.send-pr.1; einzusenden.
	Geben Sie im Fehlerbericht bitte dieselben Informationen
	wie oben an.  Mithilfe der <acronym>PR</acronym>s
	verfolgen und lösen wir Probleme.  Senden Sie
	bitte keinen <acronym>PR</acronym> ein, ohne vorher
	den Fehlerbericht an die Liste &a.acpi.name; zu senden.
	Es kann sein, dass der Fehler schon von
	jemand anderem gemeldet wurde.</para>
    </sect2>

    <sect2 xml:id="ACPI-References">
      <title>Referenzen</title>

      <para>Weitere Informationen über <acronym>ACPI</acronym> finden
	Sie hier:</para>

      <itemizedlist>
	<listitem>
	  <para>Die &os; <acronym>ACPI</acronym> Mailingliste
	    (<uri
	      xlink:href="https://lists.freebsd.org/pipermail/freebsd-acpi/">https://lists.freebsd.org/pipermail/freebsd-acpi/</uri>)</para>
	</listitem>

	<listitem>
	  <para>Die <acronym>ACPI</acronym> 2.0 Spezifikation (<uri
	      xlink:href="http://acpi.info/spec.htm">http://acpi.info/spec.htm</uri>)</para>
	</listitem>

	<listitem>
	  <para>&man.acpi.4;, &man.acpi.thermal.4;, &man.acpidump.8;,
	    &man.iasl.8; und &man.acpidb.8;</para>
	</listitem>
      </itemizedlist>
    </sect2>
  </sect1>
</chapter>
