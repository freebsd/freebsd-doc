<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde: de-docproj/books/handbook/config/chapter.xml,v 1.151 2011/12/19 14:55:31 bcr Exp $
     basiert auf: r40959
-->
<chapter xmlns="http://docbook.org/ns/docbook"
  xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0"
  xml:id="config-tuning">

  <info>
    <title>Konfiguration und Tuning</title>

    <authorgroup>
      <author>
	<personname>
	  <firstname>Chern</firstname>
	  <surname>Lee</surname>
	</personname>
	<contrib>Geschrieben von </contrib>
      </author>
    </authorgroup>

    <authorgroup>
      <author>
	<personname>
	  <firstname>Mike</firstname>
	  <surname>Smith</surname>
	</personname>
	<contrib>Nach einem Tutorium von </contrib>
      </author>
    </authorgroup>

    <authorgroup>
      <author>
	<personname>
	  <firstname>Matt</firstname>
	  <surname>Dillon</surname>
	</personname>
	<contrib>Basiert ebenfalls auf tuning(7) von </contrib>
      </author>
    </authorgroup>

    <authorgroup>
      <author>
	<personname>
	  <firstname>Martin</firstname>
	  <surname>Heinen</surname>
	</personname>
	<contrib>Übersetzt von </contrib>
      </author>
    </authorgroup>
  </info>


  <sect1 xml:id="config-synopsis">
    <title>Übersicht</title>

    <indexterm><primary>System-Konfiguration</primary></indexterm>
    <indexterm><primary>System-Optimierung</primary></indexterm>

    <para>Die richtige Systemkonfiguration ist einer der wichtigsten
      Aspekte unter &os;.  Dieses Kapitel beschreibt die
      Konfiguration von &os; sowie Maßnahmen zur Leistungssteigerung
      von &os;-Systemen.</para>

    <para>Nachdem Sie dieses Kapitel durchgearbeitet haben,
      werden Sie Folgendes wissen:</para>

    <itemizedlist>
      <listitem>
	<para>Wie Sie effizient Dateisysteme und
	  Swap-Partitionen einrichten.</para>
      </listitem>

      <listitem>
	<para>Die Grundlagen der Konfiguration von
	  <filename>rc.conf</filename> und die Skripte zum Starten
	  von Anwendungen in
	  <filename>/usr/local/etc/rc.d</filename>.</para>
      </listitem>

      <listitem>
	<para>Wie Sie Netzwerkkarten konfigurieren und testen.</para>
      </listitem>

      <listitem>
	<para>Wie Sie virtuelle Hosts und Netzwerkgeräte
	  konfigurieren.</para>
      </listitem>

      <listitem>
	<para>Wie Sie die verschiedenen Konfigurationsdateien
	  in <filename>/etc</filename> benutzen.</para>
      </listitem>

      <listitem>
	<para>Wie Sie mit <command>sysctl</command>-Variablen &os;
	  einstellen können.</para>
      </listitem>

      <listitem>
	<para>Wie Sie die Platten-Performance einstellen und
	  Kernel-Parameter modifizieren können.</para>
      </listitem>
    </itemizedlist>

    <para>Bevor Sie dieses Kapitel lesen, sollten Sie</para>
    <itemizedlist>
      <listitem>
	<para>die Grundlagen von &unix; und
	  &os; (<xref linkend="basics"/>) verstehen.</para>
      </listitem>

      <listitem>
	<para>Damit vertraut sein, wie Sie einen Kernel konfigurieren
	  und kompilieren (<xref linkend="kernelconfig"/>).</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 xml:id="configtuning-initial">
    <title>Vorbereitende Konfiguration</title>

    <sect2>
      <title>Layout von Partitionen</title>

      <indexterm><primary>Layout von Partitionen</primary></indexterm>
      <indexterm><primary><filename>/etc</filename></primary></indexterm>
      <indexterm><primary><filename>/var</filename></primary></indexterm>
      <indexterm><primary><filename>/usr</filename></primary></indexterm>

      <sect3>
	<title>Partitionen</title>

	<para>Wenn Sie Dateisysteme mit &man.bsdlabel.8; oder
	  &man.sysinstall.8; anlegen, sollten Sie beachten, dass
	  Festplatten auf Daten in den äußeren Spuren
	  schneller zugreifen können als auf Daten in den
	  inneren Spuren.  Daher sollten die kleineren oft benutzten
	  Dateisysteme, wie das Root-Dateisystem oder die
	  Swap-Partition, an den äußeren Rand der Platte gelegt
	  werden.  Die größeren Partitionen wie
	  <filename>/usr</filename> sollten in die inneren Bereiche
	  gelegt werden.  Es empfiehlt sich, die Partitionen in einer
	  ähnlichen Reihenfolge wie Root-Partition, Swap,
	  <filename>/var</filename> und <filename>/usr</filename>
	  anzulegen.</para>

	<para>Die Größe der <filename>/var</filename>-Partition ist
	  abhängig vom Zweck der Maschine.  Die Partition
	  <filename>/var</filename> enthält hauptsächlich
	  Postfächer, den Spoolbereich zum Drucken und Logdateien.
	  Abhängig von der Anzahl der Systembenutzer und der
	  Aufbewahrungszeit für Logdateien, können gerade die
	  Postfächer und Logdateien zu ungeahnten Größen wachsen.
	  Die meisten Benutzer werden selten mehr als etwa ein
	  Gigabyte in <filename>/var</filename> benötigen.</para>

	<note>
	  <para>Ein paar Mal wird es vorkommen, dass viel
	    Festplattenspeicher in <filename>/var/tmp</filename>
	    gebraucht wird.  Wenn neue Software mit &man.pkg.add.1;
	    installiert wird, extrahieren die Paketwerkzeuge eine
	    vorübergehende Kopie der Pakete unter
	    <filename>/var/tmp</filename>.  Die Installation grosser
	    Softwarepakete wie <application>Firefox</application>,
	    <application>Openoffice</application> oder
	    <application>LibreOffice</application> kann sich wegen zu
	    wenig Speicherplatz in <filename>/var/tmp</filename> als
	    trickreich herausstellen.</para>
	</note>

	<para>Die <filename>/usr</filename>-Partition enthält viele
	  der Hauptbestandteile des Systems, dazu gehören die
	  &man.ports.7;-Sammlung und die Quellen.  Für diese Partition
	  sollten mindestens zwei&nbsp;Gigabyte vorgesehen
	  werden.</para>

	<para>Wenn Sie die Größe der Partitionen festlegen,
	  beachten Sie bitte das Wachstum Ihres Systems.  Wenn Sie den
	  Platz auf einer Partition vollständig aufgebraucht haben,
	  eine andere Partition aber kaum benutzen, kann die
	  Handhabung des Systems schwierig werden.</para>

	<note>
	  <para>Die automatische Partitionierung von
	    &man.sysinstall.8; mit <literal>Auto-defaults</literal>
	    legt manchmal zu kleine <filename>/</filename> und
	    <filename>/var</filename>-Partition an.  Partitionieren
	    Sie weise und großzügig.</para>
	</note>
      </sect3>

      <sect3 xml:id="swap-design">
	<title>Swap Partition</title>

	<indexterm>
	  <primary>Swap-Partition</primary>
	  <secondary>Größe</secondary>
	</indexterm>
	<indexterm><primary>Swap-Partition</primary></indexterm>

	<para>Als Daumenregel sollten Sie doppelt soviel Speicher
	  für die Swap-Partition vorsehen, als Sie Hauptspeicher
	  haben, da die VM-Paging-Algorithmen im Kernel so
	  eingestellt sind, dass Sie am besten laufen, wenn
	  die Swap-Partition mindestens doppelt so groß wie der
	  Hauptspeicher ist.  Zu wenig Swap kann zu einer
	  Leistungsverminderung im
	  <foreignphrase>VM page scanning</foreignphrase> Code führen,
	  sowie Probleme verursachen, wenn später mehr Speicher in
	  die Maschine eingebaut wird.</para>

	<para>Auf größeren Systemen mit mehreren SCSI-Laufwerken, oder
	  mehreren IDE-Laufwerken an unterschiedlichen Controllern,
	  wird empfohlen, Swap-Bereiche auf bis zu vier Laufwerken
	  einzurichten.  Diese Swap-Partitionen
	  sollten ungefähr dieselbe Größe haben.  Der Kernel kann zwar
	  mit beliebigen Größen umgehen, aber die internen
	  Datenstrukturen skalieren bis zur vierfachen Größe der
	  größten Partition.  Ungefähr gleich große Swap-Partitionen
	  erlauben es dem Kernel, den Swap-Bereich optimal über die
	  Laufwerke zu verteilen.  Große Swap-Bereiche, auch wenn sie
	  nicht oft gebraucht werden, sind nützlich, da sich ein
	  speicherfressendes Programm unter Umständen auch ohne einen
	  Neustart des Systems beenden lässt.</para>
      </sect3>

      <sect3>
	<title>Warum partitionieren?</title>

	<para>Gegen eine einzelne Partition sprechen mehrere Gründe.
	  Jede Partition hat im Betrieb unterschiedliche Eigenschaften
	  und die Trennung der Partitionen erlaubt es, die
	  Dateisysteme an diese Eigenschaften anzupassen.  Die
	  Root- und <filename>/usr</filename>-Partitionen weisen meist
	  nur lesende Zugriffe auf, während <filename>/var</filename>
	  und <filename>/var/tmp</filename> hauptsächlich beschrieben
	  werden.</para>

	<para>Indem Sie ein System richtig partitionieren, verhindern
	  Sie, dass eine Fragmentierung in den häufig beschriebenen
	  Partitionen auf die meist nur gelesenen Partitionen
	  übergreift.  Wenn Sie die häufig beschriebenen
	  Partitionen an den Rand der Platte, legen, dann wird die
	  I/O-Leistung diesen Partitionen steigen.
	  Die I/O-Leistung ist natürlich auch für große
	  Partitionen wichtig, doch erzielen Sie eine größere
	  Leistungssteigerung, wenn Sie <filename>/var</filename> an
	  den Rand der Platte legen.  Schließlich sollten Sie noch die
	  Stabilität des Systems beachten.  Eine kleine
	  Root-Partition, auf die meist nur lesend zugegriffen wird,
	  überlebt einen schlimmen Absturz wahrscheinlich eher als
	  eine große Partition.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="configtuning-core-configuration">
    <title>Basiskonfiguration</title>

    <indexterm>
      <primary>rc-Dateien</primary>
      <secondary><filename>rc.conf</filename></secondary>
    </indexterm>

    <para>Informationen zur Systemkonfiguration sind hauptsächlich
      in <filename>/etc/rc.conf</filename>, die meist beim Start
      des Systems verwendet wird, abgelegt.  Sie enthält die
      Konfigurationen für die <filename>rc*</filename> Dateien.</para>

    <para>In <filename>rc.conf</filename> werden die Vorgabewerte aus
      <filename>/etc/defaults/rc.conf</filename> überschrieben.
      Die Vorgabedatei sollte nicht editiert werden.  Stattdessen
      sollten alle systemspezifischen Änderungen in
      <filename>rc.conf</filename> vorgenommen werden.</para>

    <para>Um den administrativen Aufwand gering zu halten, existieren
      in geclusterten Anwendungen mehrere Strategien,
      globale Konfigurationen von systemspezifischen Konfigurationen
      zu trennen.  Der empfohlene Weg hält die globale Konfiguration
      in einer separaten Datei z.B.
      <filename>/etc/rc.conf.local</filename>.  Zum Beispiel
      so:</para>

    <itemizedlist>
      <listitem><para><filename>/etc/rc.conf</filename>:</para>

      <programlisting>sshd_enable="YES"
keyrate="fast"
defaultrouter="10.1.1.254"</programlisting></listitem>

      <listitem><para><filename>/etc/rc.conf.local</filename>:</para>

      <programlisting>hostname="node1.example.org"
ifconfig_fxp0="inet 10.1.1.1/8"</programlisting></listitem>
    </itemizedlist>

    <para>Die <filename>rc.conf</filename> Datei kann dann auf jedes
      System mit <command>rsync</command> oder einem ähnlichen
      Programm verteilt werden, während die
      <filename>rc.conf.local</filename> Datei dabei systemspezifisch
      bleibt.</para>

    <para>Bei einem Upgrade des Systems mit &man.sysinstall.8; oder
      <command>make world</command> wird <filename>rc.conf</filename>
      nicht überschrieben, so dass die Systemkonfiguration
      erhalten bleibt.</para>

    <tip>
      <para>Die Konfigurationsdatei <filename>/etc/rc.conf</filename>
	wird von &man.sh.1; gelesen.  Dies erlaubt es dem
	Systemadministrator, eine bestimmte Menge an Logik dieser
	Datei hinzuzufügen, was dabei helfen kann, komplexe
	Konfigurationsszenarien zu erstellen.  Lesen Sie dazu
	&man.rc.conf.5;, um weitere Informationen zu diesem Thema zu
	erhalten.</para>
    </tip>
  </sect1>

  <sect1 xml:id="configtuning-appconfig">
    <title>Konfiguration von Anwendungen</title>

    <para>Installierte Anwendungen haben typischerweise
      eigene Konfigurationsdateien mit einer eigenen Syntax.  Damit
      diese Dateien leicht von der Paketverwaltung gefunden und
      verwaltet werden können, ist es wichtig, sie vom Basissystem zu
      trennen.</para>

    <indexterm><primary>/usr/local/etc</primary></indexterm>

    <para>Für gewöhnlich werden diese Dateien in
      <filename>/usr/local/etc</filename> installiert.  Besitzt
      eine Anwendung viele Konfigurationsdateien, werden diese in
      einem separaten Unterverzeichnis abgelegt.</para>

    <para>Wenn ein Port oder ein Paket installiert wird, werden
      normalerweise auch Beispiele für die Konfigurationsdateien
      installiert.  Diese erkennt man gewöhnlich an dem Suffix
      <filename>.default</filename>.  Wenn keine Konfigurationsdateien
      für eine Anwendung existieren, werden sie durch Kopieren der
      <filename>.default</filename> Dateien erstellt.</para>

    <para>Als Beispiel sei
      <filename>/usr/local/etc/apache</filename> gezeigt:</para>

    <literallayout class="monospaced">-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf
-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf.default
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf.default
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic.default
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types.default
-rw-r--r--  1 root  wheel   7980 May 20  1998 srm.conf
-rw-r--r--  1 root  wheel   7933 May 20  1998 srm.conf.default</literallayout>

    <para>Anhand der Dateigröße erkennen Sie, dass sich nur
      <filename>srm.conf</filename> geändert hat.  Eine spätere
      Aktualisierung des <application>Apache</application>-Ports
      überschreibt diese Datei nicht.</para>
  </sect1>

  <sect1 xml:id="configtuning-starting-services">
    <info>
      <title>Start von Diensten</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	  </personname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>Dienste</primary>
    </indexterm>

    <para>Viele Benutzer installieren Software Dritter auf &os;
      mithilfe der Ports-Sammlung.  Häufig soll die
      Software bei einem Systemstart mitgestartet werden.
      Beispielsweise sollen die Dienste
      <package>mail/postfix</package> oder
      <package>www/apache22</package> nach
      einem Systemstart laufen.  Dieser Abschnitt stellt
      die Startprozeduren für Software Dritter vor.</para>

    <para>Unter &os; werden die meisten der im System enthaltenen
      Dienste wie &man.cron.8; mithilfe von Systemskripten
      gestartet.</para>

    <sect2>
      <title>Dienste über das <filename>rc.d</filename>-System
	starten</title>

      <para>Mit <filename>rc.d</filename> lässt sich der Start
	von Anwendungen besser steuern und es sind mehr Funktionen
	verfügbar.  Mit den im Abschnitt
	<link linkend="configtuning-rcd">rc.d</link>
	besprochenen Schlüsselwörtern können
	Anwendungen in einer bestimmten Reihenfolge gestartet werden
	und Optionen können in <filename>rc.conf</filename> statt fest
	im Startskript der Anwendung festgelegt werden.  Ein einfaches
	Startskript sieht wie folgt aus:</para>

      <programlisting>#!/bin/sh
#
# PROVIDE: utility
# REQUIRE: DAEMON
# KEYWORD: shutdown

. /etc/rc.subr

name=utility
rcvar=utility_enable

command="/usr/local/sbin/utility"

load_rc_config $name

#
# DO NOT CHANGE THESE DEFAULT VALUES HERE
# SET THEM IN THE /etc/rc.conf FILE
#
utility_enable=${utility_enable-"NO"}
pidfile=${utility_pidfile-"/var/run/utility.pid"}

run_rc_command "$1"</programlisting>

      <para>Dieses Skript stellt sicher, dass
	<application>utility</application> nach den
	<literal>DAEMON</literal>-Pseudodiensten gestartet wird.
	Es stellt auch eine Methode bereit, die
	Prozess-<acronym>ID</acronym> (<acronym>PID</acronym>)
	der Anwendung in einer Datei zu speichern.</para>

      <para>In <filename>/etc/rc.conf</filename> könnte für diese
	Anwendung die folgende Zeile stehen:</para>

      <programlisting>utility_enable="YES"</programlisting>

      <para>Die Methode erleichtert den Umgang mit
	Kommandozeilenargumenten, bindet Funktionen aus
	<filename>/etc/rc.subr</filename> ein, ist kompatibel
	zum Werkzeug &man.rcorder.8; und lässt sich
	über <filename>rc.conf</filename> leichter
	konfigurieren.</para>
    </sect2>

    <sect2>
      <title>Andere Arten, um Dienste zu starten</title>

      <para>Dienste wie <acronym>POP</acronym>3 oder
	<acronym>IMAP</acronym> können über
	&man.inetd.8; gestartet werden.  Nach der Installation
	der Anwendung aus der Ports-Sammlung muss eine
	Konfigurationszeile in <filename>/etc/inetd.conf</filename>
	hinzugefügt oder in der aktuellen Konfiguration durch
	Entfernen der Kommentare aktiviert werden.  Der Abschnitt
	<xref linkend="network-inetd"/> beschreibt den
	<application>inetd</application> und dessen
	Konfiguration.</para>

      <para>Systemdienste können auch mit &man.cron.8; gestartet
	werden.  Dieser Ansatz hat einige Vorteile; nicht zuletzt,
	weil &man.cron.8; die Prozesse unter dem Eigentümer der
	<filename>crontab</filename> startet, ist es möglich, dass
	Dienste von
	nicht-<systemitem class="username">root</systemitem> Benutzern
	gestartet und gepflegt werden können.</para>

      <para>Dies nutzt eine Eigenschaft von &man.cron.8;:
	Für die Zeitangabe kann <literal>@reboot</literal>
	eingesetzt werden.  Damit wird das Kommando gestartet, wenn
	&man.cron.8; kurz nach dem Systemboot gestartet wird.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="configtuning-cron">
    <info>
      <title>Programme mit <command>cron</command> starten</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	  </personname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary><command>cron</command></primary>
      <secondary>konfigurieren</secondary>
    </indexterm>

    <para>Ein sehr nützliches Werkzeug von &os; ist &man.cron.8;.
      Dieses Programm läuft im Hintergrund und überprüft fortlaufend
      <filename>/etc/crontab</filename> und
      <filename>/var/cron/tabs</filename>.  In diesen Dateien wird
      festgelegt, welche Programme zu welchem Zeitpunkt laufen
      sollen.</para>

    <para>Das Werkzeug <command>cron</command> verwendet zwei
      verschiedene Konfigurationsdateien: die
      System-<filename>crontab</filename> und die
      Benutzer-<filename>crontab</filename>s.  Der einzige Unterschied
      zwischen beiden Formaten ist das sechste Feld.  In der
      System-<filename>crontab</filename> gibt das
      sechste Feld den Benutzer an, mit dem <command>cron</command>
      das Kommando ausführen wird.  In einer
      Benutzer-<filename>crontab</filename> werden alle Kommandos
      unter dem Benutzer ausgeführt, welcher die
      <filename>crontab</filename> erstellt hat.  Hier ist das sechste
      Feld das letzte Feld.  Dies ist ein wichtiges
      Sicherheitsmerkmal.  Das letzte Feld bezeichnet immer das
      Kommando, das ausgeführt werden soll.</para>

    <note>
      <para>Benutzer können mit Benutzer-<filename>crontabs</filename>
	ohne <systemitem class="username">root</systemitem>-Rechte
	Befehle terminieren.  Die Kommandos in
	Benutzer-<filename>crontabs</filename> laufen unter dem
	Benutzer, der die <filename>crontab</filename> erstellt
	hat.</para>

      <para>Der Benutzer
	<systemitem class="username">root</systemitem> kann, wie jeder
	andere Benutzer, eine Benutzer-<filename>crontab</filename>
	besitzen.  Die Benutzer-<filename>crontab</filename> von
	<systemitem class="username">root</systemitem> ist nicht mit
	<filename>/etc/crontab</filename>, der
	System-<filename>crontab</filename>, zu verwechseln.  Da die
	System-<filename>crontab</filename> die angegebenen Kommandos
	effektiv als
	<systemitem class="username">root</systemitem>-Benutzer
	aufruft, besteht normalerweise keine Notwendigkeit eine eigene
	Benutzer-<filename>crontab</filename> für
	<systemitem class="username">root</systemitem> zu
	erstellen.</para>
    </note>

    <para>Der folgende Auszug aus der
      System-<filename>crontab</filename>
      <filename>/etc/crontab</filename> zeigt den Aufbau
      einer <filename>crontab</filename>-Datei:</para>

    <programlisting># /etc/crontab - root's crontab for FreeBSD
#
# &dollar;FreeBSD: src/etc/crontab,v 1.32 2002/11/22 16:13:39 tom Exp &dollar;
# <co xml:id="co-comments"/>
#
SHELL=/bin/sh
PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin <co xml:id="co-env"/>
HOME=/var/log
#
#
#minute	hour	mday	month	wday	who	command <co xml:id="co-field-descr"/>
#
#
*/5	*	*	*	*	root	/usr/libexec/atrun <co xml:id="co-main"/></programlisting>

    <calloutlist>
      <callout arearefs="co-comments">
	<para>Das Zeichen <literal>#</literal> am Zeilenanfang leitet,
	  wie in den meisten Konfigurationsdateien, einen Kommentar
	  ein.  Benutzen Sie Kommentare, um die Funktion eines
	  Eintrags zu erläutern.  Kommentare müssen in einer extra
	  Zeile stehen.  Sie können nicht in derselben Zeile wie ein
	  Kommando stehen, da sie sonst Teil des Kommandos wären.
	  Leerzeilen in dieser Datei werden ignoriert.</para>
      </callout>

      <callout arearefs="co-env">
	<para>Umgebungsvariablen werden mit dem Gleichheits-Zeichen
	  (<literal>=</literal>) festgelegt.  Im Beispiel werden
	  die Variablen <envar>SHELL</envar>, <envar>PATH</envar>
	  und <envar>HOME</envar> definiert.  Wenn die Variable
	  <envar>SHELL</envar> nicht definiert wird, benutzt
	  <command>cron</command> die Shell <command>sh</command>.
	  Wird die Variable <envar>PATH</envar> nicht gesetzt,
	  müssen alle Pfadangaben absolut sein, da es keinen
	  Vorgabewert für <envar>PATH</envar> gibt.  Der
	  Vorgabewert für <envar>HOME</envar> ist das
	  Heimatverzeichnis des Accounts, dem die
	  <filename>crontab</filename> gehört.</para>
      </callout>

      <callout arearefs="co-field-descr">
	<para>In dieser Zeile werden sieben Felder beschrieben:
	  <literal>minute</literal>, <literal>hour</literal>,
	  <literal>mday</literal>, <literal>month</literal>,
	  <literal>wday</literal>, <literal>who</literal>
	  und <literal>command</literal>.  Die ersten Felder
	  legen den Zeitpunkt fest, an dem ein Kommando laufen
	  soll.  Das Feld <literal>minute</literal> legt die
	  Minute fest, das Feld <literal>hour</literal> die
	  Stunde, das Feld <literal>mday</literal> den Tag
	  des Monats.  Im Feld <literal>month</literal>
	  wird der Monat und im Feld <literal>wday</literal>
	  der Wochentag festgelegt.  Alle Felder müssen
	  numerische Werte enthalten und die Zeitangaben sind
	  im 24-Stunden-Format.  Das Feld <literal>who</literal>
	  gibt es nur in der Datei <filename>/etc/crontab</filename>
	  und gibt den Account an, unter dem das Kommando laufen
	  soll.  Im letzten Feld wird schließlich das auszuführende
	  Kommando angegeben.</para>
      </callout>

      <callout arearefs="co-main">
	<para>Diese Zeile definiert die Zeitpunkte an denen
	  <command>atrun</command> laufen soll.  Dieses Beispiel
	  verwendet die Zeichenfolge <literal>*/5</literal> gefolgt
	  von mehreren <literal>*</literal>-Zeichen.  Das Zeichen
	  <literal>*</literal> ist ein Platzhalter und steht
	  für <emphasis>jede</emphasis> mögliche Zeit.
	  Diese Zeile führt <command>atrun</command> unter dem
	  <systemitem class="username">root</systemitem>-Account alle
	  fünf Minuten aus.  Mehr über <command>atrun</command>
	  erfahren Sie in der Manualpage &man.atrun.8;.</para>

	<para>Bei den Kommandos können beliebige Optionen
	  angegeben werden.  Wenn das Kommando zu lang ist und
	  auf der nächsten Zeile fortgesetzt werden soll,
	  muss am Ende der Zeile das Fortsetzungszeichen
	  (<literal>\</literal>) angegeben werden.</para>
      </callout>
    </calloutlist>

    <para>Bis auf das sechste Feld, das den Account angibt, sieht
      jede <filename>crontab</filename> so wie das Beispiel
      aus.  Das sechste Feld existiert nur in der Systemdatei
      <filename>crontab</filename>.  In den restlichen
      <filename>crontab</filename>-Dateien fehlt dieses Feld.</para>

    <sect2 xml:id="configtuning-installcrontab">
      <title><filename>crontab</filename> installieren</title>

      <important>
	<para>Die nachstehende Prozedur gilt nur für
	  Benutzer-<filename>crontabs</filename>.  Die
	  System-<filename>crontab</filename> kann mit einem
	  Editor bearbeitet werden.  <command>cron</command> bemerkt,
	  dass sich die Datei geändert hat und wird die neue
	  Version benutzen.  Lesen Sie bitte auch die FAQ
	  zur Meldung <link
	    xlink:href="&url.books.faq;/admin.html#ROOT-NOT-FOUND-CRON-ERRORS">
	    root: not found</link>.</para>
      </important>

      <para>Eine Benutzer-<filename>crontab</filename>, beispielsweise
	die Datei <filename>crontab-datei</filename>, können Sie mit
	jedem Editor erstellen.  Die
	Benutzer-<filename>crontab</filename> installieren Sie mit dem
	nachstehenden Befehl:</para>

      <screen>&prompt.root; <userinput>crontab crontab-datei</userinput></screen>

      <para>Das Argument zum Befehl <command>crontab</command>
	ist die vorher erstellte
	<filename>crontab-datei</filename>.</para>

      <para>Der Befehl <command>crontab -l</command> zeigt
	die installierte <filename>crontab</filename>-Datei an.</para>

      <para>Benutzer, die eine eigene
	<filename>crontab</filename>-Datei ohne Vorlage erstellen
	wollen, können den Befehl <command>crontab -e</command>
	verwenden.  Dieser Befehl ruft einen Editor auf und
	installiert beim Verlassen des Editors die
	<filename>crontab</filename>-Datei.</para>

      <para>Wollen Sie die installierte
	Benutzer-<filename>crontab</filename> entfernen, rufen Sie den
	<command>crontab -r</command>.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="configtuning-rcd">
    <info>
      <title>Das rc-System für Systemdienste</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	  </personname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
    </info>

    <para>2002 wurde das <application>rc.d</application>-System von
      NetBSD zum Start von Systemdiensten in &os; integriert.
      Die zu diesem System gehörenden Dateien sind im
      Verzeichnis <filename>/etc/rc.d</filename> abgelegt.
      Die Skripten in diesem Verzeichnis akzeptieren die
      Optionen <option>start</option>, <option>stop</option>
      und <option>restart</option>.  Beispielsweise kann
      &man.sshd.8; mit dem nachstehenden Kommando neu gestartet
      werden:</para>

    <screen>&prompt.root; <userinput>service sshd restart</userinput></screen>

    <para>Analog können Sie andere Dienste starten und stoppen.
      Normalerweise werden die Dienste beim Systemstart über
      Einträge in der Datei &man.rc.conf.5; automatisch gestartet.
      Der Network Address
      Translation D&aelig;mon wird zum Beispiel mit dem folgenden
      Eintrag in <filename>/etc/rc.conf</filename> aktiviert:</para>

    <programlisting>natd_enable="YES"</programlisting>

    <para>Wenn dort bereits die Zeile
      <option>natd_enable="NO"</option> existiert, ändern Sie einfach
      <option>NO</option> in <option>YES</option>.  Die rc-Skripten
      starten, wie unten beschrieben, auch abhängige Dienste.</para>

    <para>Da das <application>rcNG</application>-System primär
      zum automatischen Starten und Stoppen von Systemdiensten
      dient, funktionieren die Optionen <option>start</option>,
      <option>stop</option> und <option>restart</option> nur,
      wenn die entsprechenden Variablen in
      <filename>/etc/rc.conf</filename> gesetzt sind.  Beispielsweise
      funktioniert <command>sshd restart</command> nur dann, wenn in
      <filename>/etc/rc.conf</filename> die Variable
      <varname>sshd_enable</varname> auf <option>YES</option> gesetzt
      wurde.  Wenn Sie die Optionen <option>start</option>,
      <option>stop</option> oder <option>restart</option>
      unabhängig von den Einstellungen in
      <filename>/etc/rc.conf</filename> benutzen wollen,
      müssen Sie den Optionen mit dem Präfix
      <quote>one</quote> verwenden.  Um beispielsweise
      <command>sshd</command> unabhängig von den
      Einstellungen in <filename>/etc/rc.conf</filename> neu
      zu starten, benutzen Sie das nachstehende Kommando:</para>

    <screen>&prompt.root; <userinput>service sshd onerestart</userinput></screen>

    <para>Ob ein Dienst in <filename>/etc/rc.conf</filename>
      aktiviert ist, können Sie leicht herausfinden, indem
      Sie das entsprechende <filename>rc.d</filename>-Skript
      mit der Option <option>rcvar</option> aufrufen.  Ein
      Administrator kann beispielsweise wie folgt prüfen, ob
      der <command>sshd</command>-Dienst in
      <filename>/etc/rc.conf</filename> aktiviert ist:</para>

    <screen>&prompt.root; <userinput>service sshd rcvar</userinput>
# sshd
$sshd_enable=YES</screen>

    <note>
      <para>Die zweite Zeile (<literal># sshd</literal>) wird
	von <command>sshd</command> ausgegeben; sie
	kennzeichnet nicht die Eingabeaufforderung von
	<systemitem class="username">root</systemitem>.</para>
    </note>

    <para>Ob ein Dienst läuft, kann mit <option>status</option>
      abgefragt werden.  Das folgende
      Kommando überprüft, ob <command>sshd</command>
      auch wirklich gestartet wurde:</para>

    <screen>&prompt.root; <userinput>service sshd status</userinput>
sshd is running as pid 433.</screen>

    <para>Einige Dienste können über die Option
      <option>reload</option> neu initialisiert werden.  Dazu wird
      dem Dienst über ein Signal mitgeteilt,
      dass er seine Konfigurationsdateien neu einlesen soll.
      Oft wird dazu das Signal <literal>SIGHUP</literal>
      verwendet.  Beachten Sie aber, dass nicht alle Dienste diese
      Option unterstützen.</para>

    <para>Die meisten Systemdienste werden beim Systemstart vom
      <application>rc.d</application>-System gestartet.  Zum Beispiel
      aktiviert das Skript <filename>bgfsck</filename> die Prüfung
      von Dateisystemen im Hintergrund.  Das Skript gibt die folgende
      Meldung aus, wenn es gestartet wird:</para>

    <screen>Starting background file system checks in 60 seconds.</screen>

    <para>Viele Systemdienste hängen von anderen Diensten
      ab.  NIS und andere RPC-basierende Systeme hängen
      beispielsweise von dem <command>rpcbind</command>-Dienst
      (portmapper) ab.  Im Kopf der Startskripten befinden sich
      die Informationen über Abhängigkeiten von anderen
      Diensten und weitere Metadaten.Mithilfe dieser Daten
      bestimmt das Programm &man.rcorder.8; beim Systemstart die
      Startreihenfolge der Dienste.</para>

    <para>Folgende Schlüsselwörter müssen im Kopf aller
      Startskripten verwendet werden (da sie von &man.rc.subr.8; zum
      <quote>Aktivieren</quote> des Startskripts benötigt
      werden:</para>

    <itemizedlist>
      <listitem>
	<para><literal>PROVIDE</literal>: Gibt die Namen der Dienste
	  an, die mit dieser Datei zur Verfügung gestellt
	  werden.</para>
      </listitem>
    </itemizedlist>

    <para>Die folgenden Schlüsselwörter können im Kopf
      des Startskripts angegeben werden.  Sie sind zwar nicht
      unbedingt notwendig, sind aber hilfreich beim Umgang mit
      &man.rcorder.8;:</para>

    <itemizedlist>
      <listitem>
	<para><literal>REQUIRE</literal>: Gibt die Namen der Dienste
	  an, von denen dieser Dienst abhängt.  Diese Datei wird
	  <emphasis>nach</emphasis> den angegebenen Diensten
	  ausgeführt.</para>
      </listitem>

      <listitem>
	<para><literal>BEFORE</literal>: Zählt Dienste auf,
	  die auf diesen Dienst angewiesen sind.  Diese Datei wird
	  <emphasis>vor</emphasis> den angegebenen Diensten
	  ausgeführt.</para>
      </listitem>
    </itemizedlist>

    <para>Durch das Verwenden dieser Schlüsselwörter kann
      ein Administrator die Startreihenfolge von Systemdiensten
      feingranuliert steuern, ohne mit den
      Schwierigkeiten des <quote>runlevel</quote>-Systems
      anderer &unix; Systeme kämpfen zu müssen.</para>

    <para>Weitere Informationen über das
      <filename>rc.d</filename>-System finden Sie in &man.rc.8; und
      &man.rc.subr.8;.  Wenn Sie
      Ihre eigenen <filename>rc.d</filename>-Skripte schreiben
      wollen, sollten Sie den Artikel
      <link xlink:href="&url.articles.rc-scripting.en;">Practical rc.d
      scripting in BSD</link> lesen.</para>
  </sect1>

  <sect1 xml:id="config-network-setup">
    <info>
      <title>Einrichten von Netzwerkkarten</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Marc</firstname>
	    <surname>Fonvieille</surname>
	  </personname><contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>Netzwerkkarten</primary>
      <secondary>einrichten</secondary>
    </indexterm>

    <para>Die Konfiguration einer Netzwerkkarte gehört zu
      den alltäglichen Aufgaben eines &os; Administrators.</para>

    <sect2>
      <title>Bestimmen des richtigen Treibers</title>

      <indexterm>
	<primary>Netzwerkkarten</primary>
	<secondary>Treiber</secondary>
      </indexterm>

      <para>Ermitteln Sie zunächst das Modell der Netzwerkkarte und
	den darin verwendeten Chip.  Prüfen Sie die
	Hardware-Kompatibilitätsliste für das &os; Release, um zu
	sehen ob die Karte unterstützt wird.</para>

      <para>Wenn die Karte unterstützt wird, müssen Sie den Treiber
	für die Karte bestimmen.
	<filename>/usr/src/sys/conf/NOTES</filename> und
	<filename>/usr/src/sys/arch/conf/NOTES</filename>
	enthalten eine Liste der verfügbaren Treiber mit Informationen
	zu den unterstützten Chipsätzen.  Wenn Sie sich nicht
	sicher sind, ob Sie den richtigen Treiber ausgewählt haben,
	lesen Sie die Hilfeseite des Treibers.  Sie enthält weitere
	Informationen über die unterstützten Geräte und bekannte
	Einschränkungen des Treibers.</para>

      <para>Die Treiber für gebräuchliche Netzwerkkarten sind schon im
	<filename>GENERIC</filename>-Kernel enthalten, so dass die
	Karte, wie in diesem Beispiel, während des Systemstarts
	erkannt werden sollte:</para>

<screen>dc0: &lt;82c169 PNIC 10/100BaseTX&gt; port 0xa000-0xa0ff mem 0xd3800000-0xd38
000ff irq 15 at device 11.0 on pci0
miibus0: &lt;MII bus&gt; on dc0
bmtphy0: &lt;BCM5201 10/100baseTX PHY&gt; PHY 1 on miibus0
bmtphy0:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
dc0: Ethernet address: 00:a0:cc:da:da:da
dc0: [ITHREAD]
dc1: &lt;82c169 PNIC 10/100BaseTX&gt; port 0x9800-0x98ff mem 0xd3000000-0xd30
000ff irq 11 at device 12.0 on pci0
miibus1: &lt;MII bus&gt; on dc1
bmtphy1: &lt;BCM5201 10/100baseTX PHY&gt; PHY 1 on miibus1
bmtphy1:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
dc1: Ethernet address: 00:a0:cc:da:da:db
dc1: [ITHREAD]</screen>

      <para>Im Beispiel erkennt das System zwei Karten, die den
	&man.dc.4; Treiber benutzen.</para>

      <para>Ist der Treiber für die Netzwerkkarte nicht
	in <filename>GENERIC</filename> enthalten, muss zunächst
	ein Treiber geladen werden, um die Karte konfigurieren und
	benutzen zu können.  Dafür gibt es zwei Methoden:</para>

      <itemizedlist>
	<listitem>
	  <para>Am einfachsten ist es, das Kernelmodul für
	    die Karte mit &man.kldload.8; zu laden.  Um den Treiber
	    automatisch beim Systemstart zu laden, fügen Sie die
	    entsprechende Zeile in
	    <filename>/boot/loader.conf</filename> ein.  Es gibt nicht
	    für alle Karten Kernelmodule; zum Beispiel gibt es keine
	    Kernelmodule für ISA-Karten.</para>
	</listitem>

	<listitem>
	  <para>Alternativ kann der Treiber für die Karte fest in den
	    Kernel eingebunden werden.  Lesen Sie dazu
	    <filename>/usr/src/sys/conf/NOTES</filename>,
	    <filename>/usr/src/sys/arch/conf/NOTES</filename>
	    und die Hilfeseite des Treibers, den Sie in den Kernel
	    einbinden möchten, an.  Die Übersetzung des Kernels
	    wird in <xref linkend="kernelconfig"/> beschrieben.  Wenn
	    die Karte während des Systemstarts vom Kernel erkannt
	    wurde, muss der Kernel nicht neu übersetzt werden.</para>
	</listitem>
      </itemizedlist>

      <sect3 xml:id="config-network-ndis">
	<title>&windows;-NDIS-Treiber einsetzen</title>

	<indexterm><primary>NDIS</primary></indexterm>
	<indexterm><primary>NDISulator</primary></indexterm>
	<indexterm><primary>&windows;-Treiber</primary></indexterm>
	<indexterm><primary>Microsoft Windows</primary></indexterm>
	<indexterm>
	  <primary>Microsoft Windows</primary>
	  <secondary>Gerätetreiber</secondary></indexterm>
	<indexterm><primary>KLD (kernel loadable object)</primary></indexterm>

        <!-- Hm.  Soll man den letzten Indexterm abwandeln, d.h. die
	  Langversion weglassen?  Keine Ahnung.  Wenn ja, dann muss
	  das auch in handbook/linuxemu/chapter.xml passieren! -->

	<para>Leider stellen nach wie vor viele Unternehmen die
	  Spezifikationen ihrer Treiber der Open Source Gemeinde
	  nicht zur Verfügung, weil sie diese Informationen
	  als Geschäftsgeheimnisse betrachten.  Daher haben die
	  Entwickler von &os; und anderen Betriebssystemen nur
	  zwei Möglichkeiten.  Entweder versuchen sie in einem
	  aufwändigen Prozess den Treiber durch
	  <foreignphrase>Reverse Engineering</foreignphrase>
	  nachzubauen, oder sie versuchen, die vorhandenen
	  Binärtreiber der &microsoft.windows;-Plattform zu
	  verwenden.  Die meisten Entwickler, darunter auch die an
	  &os; beteiligten, haben sich für den zweiten Ansatz
	  entschieden.</para>

	<para>Bill Paul (wpaul) ist es zu verdanken, dass es seit eine
	  <quote>native</quote> Unterstützung der
	  <foreignphrase>Network Driver Interface Specification</foreignphrase>
	  (NDIS) gibt.  Der &os; NDISulator (auch als Project Evil
	  bekannt) nutzt den binären &windows;-Treiber, indem er
	  diesem vorgibt, unter &windows; zu laufen.  Da der
	  &man.ndis.4;-Treiber eine &windows;-Binärdatei nutzt, kann
	  er nur auf &i386;- und amd64-Systemen verwendet werden.
	  Unterstützt werden PCI, CardBus, PCMCIA (PC-Card) und
	  USB-Geräte.</para>

	<para>Um den NDISulator zu verwenden, benötigen Sie drei
	  Dinge:</para>

	<orderedlist>
	  <listitem>
	    <para>Die Kernelquellen</para>
	  </listitem>

	  <listitem>
	    <para>Den &windowsxp;-Binärtreiber
	      (mit der Erweiterung <filename>.SYS</filename>)</para>
	  </listitem>

	<listitem>
	  <para>Die Konfigurationsdatei des &windowsxp;-Treibers
	    (mit der Erweiterung <filename>.INF</filename>)</para>
	</listitem>
	</orderedlist>

	<para>Suchen Sie die Dateien für die Karte.  Diese
	  befinden sich meistens auf einer beigelegten CD-ROM, oder
	  können von der Internetseite des Herstellers
	  heruntergeladen werden.  In den folgenden Beispielen werden
	  die Dateien <filename>W32DRIVER.SYS</filename> und
	  <filename>W32DRIVER.INF</filename> verwendet.</para>

	<para>Die Architektur des Treibers muss zur jeweiligen
	  Version von &os; passen.  Benutzen Sie einen &windows;
	  32-bit Treiber für &os;/i386.  Für &os;/amd64 wird ein
	  &windows; 64-bit Treiber benötigt.</para>

	<para>Als Nächstes kompilieren Sie den binären Treiber, um ein
	  Kernelmodul zu erzeugen.  Dazu rufen Sie als
	  <systemitem class="username">root</systemitem>
	  &man.ndisgen.8; auf:</para>

	<screen>&prompt.root; <userinput>ndisgen /path/to/W32DRIVER.INF /path/to/W32DRIVER.SYS</userinput></screen>

	<para>&man.ndisgen.8; arbeitet interaktiv, benötigt es weitere
	  Informationen, so fragt es Sie danach.  Als Ergebnis
	  erhalten Sie ein Kernelmodul im aktuellen
	  Arbeitsverzeichnis.  Benutzen Sie &man.kldload.8; um das
	  neue Modul zu laden:</para>

	<screen>&prompt.root; <userinput>kldload ./W32DRIVER.ko</userinput></screen>

	<para>Neben dem erzeugten Kernelmodul müssen auch die
	  Kernelmodule <filename>ndis.ko</filename> und
	  <filename>if_ndis.ko</filename> geladen werden.  Dies
	  passiert automatisch, wenn Sie ein von &man.ndis.4;
	  abhängiges Modul laden.  Andernfalls können die Module mit
	  den folgenden Kommandos manuell geladen werden:</para>

	<screen>&prompt.root; <userinput>kldload ndis</userinput>
&prompt.root; <userinput>kldload if_ndis</userinput></screen>

	<para>Der erste Befehl lädt dabei den NDIS-Miniport-Treiber,
	  der zweite das tatsächliche Netzwerkgerät.</para>

	<para>Überprüfen Sie nun die Ausgabe von &man.dmesg.8;
	  auf eventuelle Fehler während des Ladevorgangs.  Gab es
	  dabei keine Probleme, sollte die Ausgabe wie folgt
	  aussehen:</para>

	<screen>ndis0: &lt;Wireless-G PCI Adapter&gt; mem 0xf4100000-0xf4101fff irq 3 at device 8.0 on pci1
ndis0: NDIS API version: 5.0
ndis0: Ethernet address: 0a:b1:2c:d3:4e:f5
ndis0: 11b rates: 1Mbps 2Mbps 5.5Mbps 11Mbps
ndis0: 11g rates: 6Mbps 9Mbps 12Mbps 18Mbps 36Mbps 48Mbps 54Mbps</screen>

	<para>Ab jetzt können Sie mit dem Gerät
	  <filename>ndis0</filename> wie mit jeder anderen
	  Gerätedatei (etwa <filename>dc0</filename>)
	  arbeiten.</para>

	<para>Um die NDIS-Module automatisch beim Systemstart zu
	  laden, kopieren Sie das erzeugte Modul
	  <filename>W32DRIVER_SYS.ko</filename> in das Verzeichnis
	  <filename>/boot/modules</filename>.  Danach fügen Sie die
	  folgende Zeile in <filename>/boot/loader.conf</filename>
	  ein:</para>

	<programlisting>W32DRIVER_SYS_load="YES"</programlisting>
      </sect3>
    </sect2>

    <sect2>
      <title>Konfiguration von Netzwerkkarten</title>

      <indexterm>
	<primary>Netzwerkkarten</primary>
	<secondary>einrichten</secondary>
      </indexterm>

      <para>Nachdem der richtige Treiber für die Karte geladen ist,
	muss die Karte konfiguriert werden.  Unter Umständen ist
	die Karte schon während der Installation mit
	<application>sysinstall</application> konfiguriert
	worden.</para>

      <para>Das nachstehende Kommando zeigt die Konfiguration der
	Netzwerkkarten an:</para>

<screen>&prompt.user; <userinput>ifconfig</userinput>
dc0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        options=80008&lt;VLAN_MTU,LINKSTATE&gt;
        ether 00:a0:cc:da:da:da
        inet 192.168.1.3 netmask 0xffffff00 broadcast 192.168.1.255
        media: Ethernet autoselect (100baseTX &lt;full-duplex&gt;)
        status: active
dc1: flags=8802&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        options=80008&lt;VLAN_MTU,LINKSTATE&gt;
        ether 00:a0:cc:da:da:db
        inet 10.0.0.1 netmask 0xffffff00 broadcast 10.0.0.255
        media: Ethernet 10baseT/UTP
        status: no carrier
lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; metric 0 mtu 16384
        options=3&lt;RXCSUM,TXCSUM&gt;
        inet6 fe80::1%lo0 prefixlen 64 scopeid 0x4
        inet6 ::1 prefixlen 128
        inet 127.0.0.1 netmask 0xff000000
        nd6 options=3&lt;PERFORMNUD,ACCEPT_RTADV&gt;</screen>

      <para>Im Beispiel werden Informationen zu den folgenden Geräten
	angezeigt:</para>

      <itemizedlist>
	<listitem>
	  <para><filename>dc0</filename>: Der erste
	    Ethernet-Adapter</para>
	</listitem>

	<listitem>
	  <para><filename>dc1</filename>: Der zweite
	    Ethernet-Adapter</para>
	</listitem>

	<listitem>
	  <para><filename>lo0</filename>: Das Loopback-Gerät</para>
	</listitem>
      </itemizedlist>

      <para>Der Name der Netzwerkkarte wird aus dem Namen des Treibers
	und einer Zahl zusammengesetzt.  Die Zahl gibt die Reihenfolge
	an, in der die Geräte beim Systemstart erkannt wurden.  Die
	dritte Karte, die den &man.sis.4; Treiber benutzt, würde
	beispielsweise <filename>sis2</filename> heißen.</para>

      <para>Der Adapter <filename>dc0</filename> aus dem Beispiel ist
	aktiv.  Sie erkennen das an den folgenden Hinweisen:</para>

      <orderedlist>
	<listitem>
	  <para><literal>UP</literal> bedeutet, dass die Karte
	    konfiguriert und aktiv ist.</para>
	</listitem>

	<listitem>
	  <para>Der Karte wurde die Internet-Adresse
	    (<literal>inet</literal>)
	    <systemitem class="ipaddress">192.168.1.3</systemitem>
	    zugewiesen.</para>
	</listitem>

	<listitem>
	  <para>Die Subnetzmaske ist richtig
	    (<systemitem class="netmask">0xffffff00</systemitem>
	    entspricht
	    <systemitem class="netmask">255.255.255.0</systemitem>).</para>
	</listitem>

	<listitem>
	  <para>Die Broadcast-Adresse
	    <systemitem class="ipaddress">192.168.1.255</systemitem>
	    ist richtig.</para>
	</listitem>

	<listitem>
	  <para>Die MAC-Adresse der Karte (<literal>ether</literal>)
	    lautet <systemitem class="etheraddress">00:a0:cc:da:da:da</systemitem>.</para>
	</listitem>

	<listitem>
	  <para>Die automatische Medienerkennung ist aktiviert
	    (<literal>media: Ethernet autoselect (100baseTX
	      &lt;full-duplex&gt;)</literal>).  Der Adapter
	    <filename>dc1</filename> benutzt das Medium
	    <literal>10baseT/UTP</literal>.  Weitere Informationen
	    über die einstellbaren Medien entnehmen
	    Sie der Hilfeseite des Treibers.</para>
	</listitem>

	<listitem>
	  <para>Der Verbindungsstatus (<literal>status</literal>) ist
	    <literal>active</literal>, das heißt es wurde ein
	    Trägersignal entdeckt.  Für <filename>dc1</filename> wird
	    <literal>status: no carrier</literal> angezeigt.  Das ist
	    normal, wenn kein Kabel an der Karte angeschlossen
	    ist.</para>
	</listitem>
      </orderedlist>

      <para>Wäre die Karte nicht konfiguriert, würde die Ausgabe
	von &man.ifconfig.8; so aussehen:</para>

<screen>dc0: flags=8843&lt;BROADCAST,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        options=80008&lt;VLAN_MTU,LINKSTATE&gt;
        ether 00:a0:cc:da:da:da
        media: Ethernet autoselect (100baseTX &lt;full-duplex&gt;)
        status: active</screen>

      <para>Sie brauchen die Berechtigungen von
	<systemitem class="username">root</systemitem>, um die Karte
	zu konfigurieren.  Die Konfiguration kann auf der
	Kommandozeile mit &man.ifconfig.8; erfolgen.  Allerdings
	gehen diese Informationen bei einem Neustart verloren, falls
	sie nicht auch in <filename>/etc/rc.conf</filename>
	konfiguriert wurden.  Fügen Sie für jede Karte im System
	eine Zeile hinzu, wie in diesem Beispiel zu sehen:</para>

      <programlisting>ifconfig_dc0="inet 192.168.1.3 netmask 255.255.255.0"
ifconfig_dc1="inet 10.0.0.1 netmask 255.255.255.0 media 10baseT/UTP"</programlisting>

      <para>Ersetzen Sie <filename>dc0</filename> und
	<filename>dc1</filename> und die IP-Adressen durch die
	richtigen Werte für das System.  Die Manualpages des Treibers
	und &man.ifconfig.8; enthalten weitere Einzelheiten über
	verfügbare Optionen.  Die Syntax von
	<filename>/etc/rc.conf</filename> wird in &man.rc.conf.5;
	beschrieben.</para>

      <para>Wenn das Netz während der Installation konfiguriert wurde,
	existieren vielleicht schon Einträge für die Netzwerkkarte(n).
	Überprüfen Sie <filename>/etc/rc.conf</filename> bevor Sie weitere Zeilen
	hinzufügen.</para>

      <para>Wenn das Netzwerk kein DNS benutzt, können Sie in
	<filename>/etc/hosts</filename> die Namen und IP-Adressen der
	Rechner des LANs eintragen.  Weitere
	Informationen entnehmen Sie &man.hosts.5; und
	<filename>/usr/share/examples/etc/hosts</filename>.</para>

      <note>
	<para>Falls kein DHCP-Server zur Verfügung steht, Sie aber
	  Zugang zum Internet benötigen, müsssen Sie das
	  Standard-Gateway und die Nameserver manuell
	  konfigurieren:</para>

	<screen>&prompt.root; <userinput>echo 'defaultrouter="Ihr_Default_Gateway"' &gt;&gt; /etc/rc.conf</userinput>
&prompt.root; <userinput>echo 'nameserver Ihr_DNS_Server' &gt;&gt; /etc/resolv.conf</userinput></screen>
      </note>
    </sect2>

    <sect2>
      <title>Test und Fehlersuche</title>

      <para>Nachdem die notwendigen Änderungen in
	<filename>/etc/rc.conf</filename> gespeichert wurden, kann das
	System neu gestartet werden, um die Konfiguration zu testen
	und zu überprüfen, ob das System ohne Fehler neu gestartet
	wurde.  Alternativ können Sie mit folgenden Befehl die
	Netzwerkeinstellungen neu initialisieren:</para>

      <screen>&prompt.root; <userinput>service netif restart</userinput></screen>

      <note>
	<para>Haben Sie ein Default-Gateway definiert (in der Datei
	  <filename>/etc/rc.conf</filename>), müssen Sie
	  auch den folgenden Befehl ausführen:</para>

	<screen>&prompt.root; <userinput>service routing restart</userinput></screen>
      </note>

      <para>Wenn das System gestartet ist, sollten Sie die
	Netzwerkkarten testen.</para>

      <sect3>
	<title>Test der Ethernet-Karte</title>

	<indexterm>
	  <primary>Netzwerkkarten</primary>
	  <secondary>testen</secondary>
	</indexterm>

	<para>Um zu prüfen, ob die Ethernet-Karte richtig konfiguriert
	  ist, testen Sie zunächst mit <command>ping</command> den
	  Adapter selbst und sprechen Sie dann eine andere Maschine im
	  LAN an.</para>

	<para>Zuerst, der Test des Adapters:</para>

<screen>&prompt.user; <userinput>ping -c5 192.168.1.3</userinput>
PING 192.168.1.3 (192.168.1.3): 56 data bytes
64 bytes from 192.168.1.3: icmp_seq=0 ttl=64 time=0.082 ms
64 bytes from 192.168.1.3: icmp_seq=1 ttl=64 time=0.074 ms
64 bytes from 192.168.1.3: icmp_seq=2 ttl=64 time=0.076 ms
64 bytes from 192.168.1.3: icmp_seq=3 ttl=64 time=0.108 ms
64 bytes from 192.168.1.3: icmp_seq=4 ttl=64 time=0.076 ms

--- 192.168.1.3 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.074/0.083/0.108/0.013 ms</screen>

<screen>&prompt.user; <userinput>ping -c5 192.168.1.2</userinput>
PING 192.168.1.2 (192.168.1.2): 56 data bytes
64 bytes from 192.168.1.2: icmp_seq=0 ttl=64 time=0.726 ms
64 bytes from 192.168.1.2: icmp_seq=1 ttl=64 time=0.766 ms
64 bytes from 192.168.1.2: icmp_seq=2 ttl=64 time=0.700 ms
64 bytes from 192.168.1.2: icmp_seq=3 ttl=64 time=0.747 ms
64 bytes from 192.168.1.2: icmp_seq=4 ttl=64 time=0.704 ms

--- 192.168.1.2 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.700/0.729/0.766/0.025 ms</screen>

	<para>Um die Namensauflösung zu testen, verwenden Sie den
	  Namen der Maschine anstelle von
	  <systemitem class="ipaddress">192.168.1.2</systemitem>.
	  Wenn kein DNS-Server im Netzwerk vorhanden ist, muss
	  <filename>/etc/hosts</filename> entsprechend eingerichtet
	  sein.</para>
      </sect3>

      <sect3>
	<title>Fehlersuche</title>

	<indexterm>
	  <primary>Netzwerkkarten</primary>
	  <secondary>Fehlersuche</secondary>
	</indexterm>

	<para>Fehler zu beheben, ist immer sehr mühsam.
	  Indem Sie die einfachen Sachen zuerst prüfen,
	  erleichtern Sie sich die Aufgabe.  Steckt das Netwerkkabel?
	  Sind die Netzwerkdienste richtig konfiguriert?  Funktioniert
	  die Firewall?  Wird die Netwerkkarte von &os;
	  unterstützt?  Lesen Sie immer die Hardware-Informationen
	  des Releases, bevor Sie einen Fehlerbericht einsenden.
	  Aktualisieren Sie die &os;-Version auf die neueste -STABLE
	  Version.  Suchen Sie in den Archiven der Mailinglisten
	  und im Internet nach bekannten Lösungen.</para>

	<para>Wenn die Karte funktioniert, die Verbindungen aber
	  zu langsam sind, lesen Sie bitte die Hilfeseite
	  &man.tuning.7;.  Prüfen Sie auch die
	  Netzwerkkonfiguration, da falsche Einstellungen die
	  Ursache für langsame Verbindungen sein können.</para>

	<para>Wenn Sie viele <errorname>device timeout</errorname>
	  Meldungen in den Systemprotokollen finden, prüfen
	  Sie, dass es keinen Konflikt zwischen der Netzwerkkarte
	  und anderen Geräten des Systems gibt.
	  Überprüfen Sie nochmals die Verkabelung.
	  Unter Umständen benötigen Sie eine andere
	  Netzwerkkarte.</para>

	<para>Wenn Sie in den Systemprotokollen
	  <errorname>watchdog timeout</errorname> Fehlermeldungen
	  finden, kontrollieren Sie zuerst die Verkabelung.
	  Überprüfen Sie dann, ob der PCI-Steckplatz der
	  Karte Bus Mastering unterstützt.  Auf einigen
	  älteren Motherboards ist das nur für einen
	  Steckplatz (meistens Steckplatz 0) der Fall.  Lesen Sie
	  in der Dokumentation Ihrer Karte und Ihres Motherboards
	  nach, ob das vielleicht die Ursache des Problems sein
	  könnte.</para>

	<para>Die Meldung <errorname>No route to host</errorname>
	  erscheint, wenn Ihr System ein Paket nicht zustellen
	  kann.  Das kann vorkommen weil beispielsweise keine
	  Default-Route gesetzt wurde oder das Netzwerkkabel
	  nicht richtig steckt.  Schauen Sie in der Ausgabe
	  von <command>netstat -rn</command> nach, ob eine
	  gültige Route zu dem Zielsystem existiert.  Wenn nicht, lesen
	  Sie bitte das <xref linkend="advanced-networking"/>.</para>

	<para>Die Meldung <errorname>ping: sendto: Permission
	    denied</errorname> wird oft von einer falsch
	  konfigurierten Firewall verursacht.  Wenn keine Regeln
	  definiert wurden, blockiert eine aktivierte Firewall alle
	  Pakete, selbst einfache <command>ping</command>-Pakete.
	  Weitere Informationen erhalten Sie
	  in <xref linkend="firewalls"/>.</para>

	<para>Falls die Leistung der Karte schlecht ist, setzen
	  Sie die Medienerkennung von <literal>autoselect</literal>
	  (automatisch) auf das richtige Medium.  In vielen Fällen
	  löst diese Maßnahme Leistungsprobleme.  Wenn
	  nicht, prüfen Sie nochmal die Netzwerkeinstellungen
	  und lesen Sie die Hilfeseite &man.tuning.7;.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="configtuning-virtual-hosts">
    <title>Virtual Hosts</title>

    <indexterm><primary>virtual hosts</primary></indexterm>
    <indexterm><primary>IP-Aliase</primary></indexterm>

    <para>Ein gebräuchlicher Zweck von &os; ist das
      virtuelle Hosting, bei dem ein Server im Netzwerk wie
      mehrere Server aussieht.  Dies wird dadurch erreicht,
      dass einem Netzwerkinterface mehrere Netzwerk-Adressen
      zugewiesen werden.</para>

    <para>Ein Netzwerkinterface hat eine <quote>echte</quote>
      Adresse und kann beliebig viele <quote>alias</quote> Adressen
      haben.  Die Aliase werden durch entsprechende alias Einträge
      in <filename>/etc/rc.conf</filename> festgelegt.</para>

    <para>Ein alias Eintrag für das Interface
      <filename>fxp0</filename> sieht wie folgt aus:</para>

<programlisting>ifconfig_fxp0_alias0="inet xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx"</programlisting>

    <para>Beachten Sie, dass die Alias-Einträge mit
      <literal>alias0</literal> anfangen müssen und
      weiter hochgezählt werden, das heißt
      <literal>_alias1</literal>, <literal>_alias2</literal>,
      und so weiter.  Die Konfiguration der Aliase hört
      bei der ersten fehlenden Zahl auf.</para>

    <para>Die Berechnung der Alias-Netzwerkmasken ist wichtig, doch
      zum Glück einfach.  Für jedes Interface muss es
      eine Adresse geben, die die Netzwerkmaske des Netzwerkes richtig
      beschreibt.  Alle anderen Adressen in diesem Netzwerk haben dann
      eine Netzwerkmaske, die mit <literal>1</literal> gefüllt
      ist
      (also <systemitem class="netmask">255.255.255.255</systemitem>
      oder hexadezimal
      <systemitem class="netmask">0xffffffff</systemitem>).</para>

    <para>Als Beispiel betrachten wir den Fall, in dem
      <filename>fxp0</filename> mit zwei Netzwerken verbunden
      ist: dem Netzwerk
      <systemitem class="ipaddress">10.1.1.0</systemitem> mit der
      Netzwerkmaske
      <systemitem class="netmask">255.255.255.0</systemitem> und dem
      Netzwerk <systemitem class="ipaddress">202.0.75.16</systemitem>
      mit der Netzwerkmaske
      <systemitem class="netmask">255.255.255.240</systemitem>.  Das
      System soll die Adressen
      <systemitem class="ipaddress">10.1.1.1</systemitem> bis
      <systemitem class="ipaddress">10.1.1.5</systemitem> und
      <systemitem class="ipaddress">202.0.75.17</systemitem> bis
      <systemitem class="ipaddress">202.0.75.20</systemitem> belegen.
      Nur die erste Adresse in einem
      Netzwerk (hier
      <systemitem class="ipaddress">10.0.1.1</systemitem>
      und <systemitem class="ipaddress">202.0.75.17</systemitem>)
      sollte die richtige Netzwerkmaske haben.  Alle anderen Adressen
      (<systemitem class="ipaddress">10.1.1.2</systemitem> bis
      <systemitem class="ipaddress">10.1.1.5</systemitem> und
      <systemitem class="ipaddress">202.0.75.18</systemitem> bis
      <systemitem class="ipaddress">202.0.75.20</systemitem>) erhalten
      die Maske
      <systemitem class="netmask">255.255.255.255</systemitem>.</para>

    <para>Die folgenden Einträge in
      <filename>/etc/rc.conf</filename> konfigurieren den Adapter
      entsprechend dem Beispiel:</para>

<programlisting>ifconfig_fxp0="inet 10.1.1.1 netmask 255.255.255.0"
ifconfig_fxp0_alias0="inet 10.1.1.2 netmask 255.255.255.255"
ifconfig_fxp0_alias1="inet 10.1.1.3 netmask 255.255.255.255"
ifconfig_fxp0_alias2="inet 10.1.1.4 netmask 255.255.255.255"
ifconfig_fxp0_alias3="inet 10.1.1.5 netmask 255.255.255.255"
ifconfig_fxp0_alias4="inet 202.0.75.17 netmask 255.255.255.240"
ifconfig_fxp0_alias5="inet 202.0.75.18 netmask 255.255.255.255"
ifconfig_fxp0_alias6="inet 202.0.75.19 netmask 255.255.255.255"
ifconfig_fxp0_alias7="inet 202.0.75.20 netmask 255.255.255.255"</programlisting>

  </sect1>

  <sect1 xml:id="configtuning-syslog">
    <info>
      <title>Konfiguration des <application>syslogd</application>
	Servers</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Niclas</firstname>
	    <surname>Zeising</surname>
	  </personname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm><primary>system logging</primary></indexterm>
    <indexterm><primary>syslog</primary></indexterm>
    <indexterm><primary>syslogd</primary></indexterm>

    <para>Das Aufzeichnen von Log-Meldungen ist ein wichtiger Aspekt
      der Systemadministration.  Es wird nicht nur verwendet um
      Hard- und Softwarefehler ausfindig zu machen, auch zur
      Überwachung der Sicherheit und der Reaktion bei einem
      Zwischenfall spielen diese Aufzeichnungen eine wichtige Rolle.
      Systemdienste ohne kontrollierendes Terminal senden
      Meldungen in der Regel an einen Log-Server, oder schreiben sie
      in eine Logdatei.</para>

    <para>Dieser Abschnitt beschreibt die Konfiguration und Verwendung
      des &os; &man.syslogd.8; Servers, und diskutiert auch die
      Log-Rotation und das Management von Logdateien mit
      &man.newsyslog.8;.  Der Fokus wird hierbei auf die Einrichtung
      und Benutzung eines <command>syslogd</command> auf dem lokalen
      Rechner gelegt.  Für erweiterte Einstellungen und die Verwendung
      eines separaten Log-Servers lesen Sie bitte
      <xref linkend="network-syslogd"/>.</para>

    <sect2>
      <title>Verwendung von <application>syslogd</application></title>

      <para>In der Standardkonfiguration von &os; wird &man.syslogd.8;
	beim Booten automatisch gestartet.  Dieses Verhalten wird über
	die Variable <literal>syslogd_enable</literal> in
	<filename>/etc/rc.conf</filename> gesteuert.  Dazu gibt es
	noch zahlreiche Argumente, die das Verhalten von
	&man.syslogd.8; beeinflussen.  Benutzen Sie zum verändern
	dieser Argumente <literal>syslogd_flags</literal> in
	<filename>/etc/rc.conf</filename>.  Lesen Sie &man.syslogd.8;
	für weitere Informationen über die Argumente, und
	&man.rc.conf.5;,
	<xref linkend="configtuning-core-configuration"/> und
	<xref linkend="configtuning-rcd"/> wenn Sie mehr über
	<filename>/etc/rc.conf</filename> und das &man.rc.8;-Subsystem
	wissen möchten.</para>
    </sect2>

    <sect2>
      <title>Konfiguration von
	<application>syslogd</application></title>

      <indexterm><primary>syslog.conf</primary></indexterm>

      <para>Die Konfigurationsdatei
	<filename>/etc/syslog.conf</filename> steuert, was
	&man.syslogd.8; mit Log-Meldungen macht, sobald sie empfangen
	werden.  Es gibt verschiedene Parameter, die das Verhalten bei
	eingehenden Ereignissen kontrollieren.  Zu den grundlegenden
	gehören <foreignphrase>facility</foreignphrase> und
	<foreignphrase>level</foreignphrase>.
	<foreignphrase>facility</foreignphrase> beschreibt das
	Subsystem, welches das Ereignis generiert hat.  Beispielsweise
	der Kernel, oder ein Daemon.
	<foreignphrase>level</foreignphrase> hingegen beschreibt den
	Schweregrad des aufgetretenen Ereignisses.  Dies macht es
	möglich, Meldungen in verschiedenen Logdateien zu
	protokollieren, oder Meldungen zu verwerfen, je nach
	Konfiguration von <foreignphrase>facility</foreignphrase> und
	<foreignphrase>level</foreignphrase>.  Ebenfalls besteht die
	Möglichkeit auf Meldungen zu reagieren, die von einer
	bestimmten Anwendung stammen, oder von einem
	spezifischen Host erzeugt wurden.</para>

      <para>Die Konfiguration von &man.syslogd.8; ist recht einfach.
	In der Konfigurationsdatei wird pro Zeile eine Aktion
	definiert und die Syntax besteht aus einem Auswahlfeld,
	gefolgt von einem Aktionsfeld.  Die Syntax für das
	Auswahlfeld ist <replaceable>facility.level</replaceable>.
	Dies entspricht Log-Meldungen von
	<replaceable>facility</replaceable> mit einem Level von
	<replaceable>level</replaceable> oder höher.  Um noch präziser
	festzulegen was protokolliert wird, kann dem Level optional
	ein Vergleichsflag vorangestellt werden.  Mehrere Auswahlen
	können, durch Semikolon (<literal>;</literal>) getrennt, für
	die gleiche Aktion verwendet werden.  <literal>*</literal>
	wählt dabei alles aus.  Das Aktionsfeld definiert, wohin die
	Log-Meldungen gesendet werden, beispielsweise in eine Datei
	oder zu einem entfernten Log-Server.  Als Beispiel dient hier
	<filename>/etc/syslog.conf</filename> aus &os;:</para>

      <programlisting># &dollar;&os;&dollar;
#
#       Spaces ARE valid field separators in this file. However,
#       other *nix-like systems still insist on using tabs as field
#       separators. If you are sharing this file between systems, you$
#       may want to use only tabs as field separators here.
#       Consult the syslog.conf(5) manpage.
*.err;kern.warning;auth.notice;mail.crit                /dev/console <co xml:id="co-syslog-many-match"/>
*.notice;authpriv.none;kern.debug;lpr.info;mail.crit;news.err   /var/log/messages
security.*                                      /var/log/security
auth.info;authpriv.info                         /var/log/auth.log
mail.info                                       /var/log/maillog <co xml:id="co-syslog-one-match"/>
lpr.info                                        /var/log/lpd-errs
ftp.info                                        /var/log/xferlog
cron.*                                          /var/log/cron
!-devd
*.=debug                                        /var/log/debug.log <co xml:id="co-syslog-comparison"/>
*.emerg                                         *
# uncomment this to log all writes to /dev/console to /var/log/console.log
#console.info                                   /var/log/console.log
# uncomment this to enable logging of all log messages to /var/log/all.log
# touch /var/log/all.log and chmod it to mode 600 before it will work
#*.*                                            /var/log/all.log
# uncomment this to enable logging to a remote loghost named loghost
#*.*                                            @loghost
# uncomment these if you're running inn
# news.crit                                     /var/log/news/news.crit
# news.err                                      /var/log/news/news.err
# news.notice                                   /var/log/news/news.notice
# Uncomment this if you wish to see messages produced by devd
# !devd
# *.>=info
!ppp <co xml:id="co-syslog-prog-spec"/>
*.*                                             /var/log/ppp.log
!*</programlisting>

      <calloutlist>
	<callout arearefs="co-syslog-many-match">
	  <para>Selektiert alle Meldungen vom Level
	    <literal>err</literal>, sowie
	    <literal>kern.warning</literal>,
	    <literal>auth.notice</literal> und
	    <literal>mail.crit</literal> und schickt diese zur Konsole
	    (<filename>/dev/console</filename>).</para>
	</callout>

	<callout arearefs="co-syslog-one-match">
	  <para>Selektiert alle Meldungen von <literal>mail</literal>
	    ab dem Level <literal>info</literal> oder höher und
	    schreibt diese in
	    <filename>/var/log/maillog</filename>.</para>
	</callout>

	<callout arearefs="co-syslog-comparison">
	  <para>Diese Zeile benutzt das Vergleichsflag
	    <literal>=</literal>, um nur Meldungen vom Level
	    <literal>debug</literal> zu selektieren und schreibt
	    diese in <filename>/var/log/debug.log</filename>.</para>
	</callout>

	<callout arearefs="co-syslog-prog-spec">
	  <para>Hier ist ein Beispiel für die Nutzung einer
	    <emphasis>Programmspezifikation</emphasis>.  Die
	    nachfolgenden Regeln sind dann nur für Programme gültig,
	    welche der Programmspezifikation stehen.  In diesem Fall
	    landen alle Meldungen von <command>ppp</command> (und
	    keinem anderen Programm) in
	    <filename>/var/log/ppp.log</filename>.</para>
	</callout>
      </calloutlist>

      <para>Dieses Beispiel zeigt, dass es jede Menge Level und
	Subsysteme gibt.  Die Level, beginnend mit den höchst
	kritischen, hin zu den weniger kritischen, sind:
	<literal>emerg</literal>, <literal>alert</literal>,
	<literal>crit</literal>, <literal>err</literal>,
	<literal>warning</literal>, <literal>notice</literal>,
	<literal>info</literal> und
	<literal>debug</literal>.</para>

      <para>Die <foreignphrase>facilities</foreignphrase>, in
	beliebiger Reihenfolge, sind: <literal>auth</literal>,
	<literal>authpriv</literal>, <literal>console</literal>,
	<literal>cron</literal>, <literal>daemon</literal>,
	<literal>ftp</literal>, <literal>kern</literal>,
	<literal>lpr</literal>, <literal>mail</literal>,
	<literal>mark</literal>, <literal>news</literal>,
	<literal>security</literal>, <literal>syslog</literal>,
	<literal>user</literal>, <literal>uucp</literal>, sowie
	<literal>local0</literal> bis <literal>local7</literal>.
	Beachten Sie, dass andere Betriebssysteme hiervon abweichende
	<foreignphrase>facilities</foreignphrase> haben
	können.</para>

      <para>Mit diesem Wissen ist es nun einfach, eine weitere Zeile
	in <filename>/etc/syslog.conf</filename> hinzuzufügen, welche
	alle Meldungen von den unterschiedlichsten Dämonen mit einem
	Level von <literal>notice</literal> und höher in
	<filename>/var/log/daemon.log</filename>.  Fügen Sie einfach
	folgendes hinzu:</para>

      <programlisting>daemon.notice                                        /var/log/daemon.log</programlisting>

      <para>Für weitere Informationen zu verschiedenen Level und
	<foreignphrase>faclilities</foreignphrase>, lesen Sie
	&man.syslog.3; und &man.syslogd.8;.  Weitere Informationen
	zu <filename>syslog.conf</filename>, dessen Syntax und
	erweiterten Anwendungsbeispielen, finden Sie in
	&man.syslog.conf.5; und
	<xref linkend="network-syslogd"/>.</para>
    </sect2>

    <sect2>
      <title>Log-Management und Rotation mit
	<application>newsyslog</application></title>

      <indexterm><primary>newsyslog</primary></indexterm>
      <indexterm><primary>newsyslog.conf</primary></indexterm>
      <indexterm><primary>log rotation</primary></indexterm>
      <indexterm><primary>log management</primary></indexterm>

      <para>Log-Dateien können schnell wachsen, was viel Speicherplatz
	verbrauchen kann.  Zudem wird es schwieriger, nützliche
	Informationen schnell zu finden.  Log-Management versucht,
	diesen Effekt zu mildern.  &os; verwendet &man.newsyslog.8;
	für die Verwaltung von Log-Dateien.  Dieses Programm
	rotiert und komprimiert in regelmäßigen Abständen Log-Dateien.
	Optional kann es auch fehlende Log-Dateien erstellen und
	Programme benachrichtigen, wenn Log-Dateien verschoben wurden.
	Dabei müssen die Log-Dateien nicht unbedingt von syslog
	stammen, &man.newsyslog.8; ist auch in der Lage, Nachrichten
	von anderen Programmen zu verarbeiten.  Obwohl
	&man.newsyslog.8; normalerweise von &man.cron.8;
	aufgerufen wird, ist es kein Systemdämon.  In der
	Standardkonfiguration wird dieser Job jede Stunde
	ausgeführt.</para>

      <sect3>
	<title>Konfiguration von
	  <application>newsyslog</application></title>

	<para>Um zu wissen, welche Maßnahmen zu ergreifen sind, liest
	  &man.newsyslog.8; seine Konfigurationsdatei, standardmäßig
	  <filename>/etc/newsyslog.conf</filename>.  Diese
	  Konfigurationsdatei enthält eine Zeile für jede Datei, die
	  von &man.newsyslog.8; verwaltet wird.  Jede Zeile enthält
	  Informationen über den Besitzer der Datei, die
	  Dateiberechtigungen, wann die Datei rotiert wird, optionale
	  <foreignphrase>Flags</foreignphrase>, welche
	  die Log-Rotation beeinflussen (bspw. Komprimierung) und
	  Programme, denen ein Signal geschickt wird, wenn Log-Dateien
	  rotiert werden.  Hier folgt die Standardkonfiguration in
	  &os;:</para>

	<programlisting># configuration file for newsyslog
# &dollar;&os;&dollar;
#
# Entries which do not specify the '/pid_file' field will cause the
# syslogd process to be signalled when that log file is rotated.  This
# action is only appropriate for log files which are written to by the
# syslogd process (ie, files listed in /etc/syslog.conf).  If there
# is no process which needs to be signalled when a given log file is
# rotated, then the entry for that file should include the 'N' flag.
#
# The 'flags' field is one or more of the letters: BCDGJNUXZ or a '-'.
#
# Note: some sites will want to select more restrictive protections than the
# defaults.  In particular, it may be desirable to switch many of the 644
# entries to 640 or 600.  For example, some sites will consider the
# contents of maillog, messages, and lpd-errs to be confidential.  In the
# future, these defaults may change to more conservative ones.
#
# logfilename          [owner:group]    mode count size when  flags [/pid_file] [sig_num]
/var/log/all.log                        600  7     *    @T00  J
/var/log/amd.log                        644  7     100  *     J
/var/log/auth.log                       600  7     100  @0101T JC
/var/log/console.log                    600  5     100  *     J
/var/log/cron                           600  3     100  *     JC
/var/log/daily.log                      640  7     *    @T00  JN
/var/log/debug.log                      600  7     100  *     JC
/var/log/kerberos.log                   600  7     100  *     J
/var/log/lpd-errs                       644  7     100  *     JC
/var/log/maillog                        640  7     *    @T00  JC
/var/log/messages                       644  5     100  @0101T JC
/var/log/monthly.log                    640  12    *    $M1D0 JN
/var/log/pflog                          600  3     100  *     JB    /var/run/pflogd.pid
/var/log/ppp.log        root:network    640  3     100  *     JC
/var/log/devd.log                       644  3     100  *     JC
/var/log/security                       600  10    100  *     JC
/var/log/sendmail.st                    640  10    *    168   B
/var/log/utx.log                        644  3     *    @01T05 B
/var/log/weekly.log                     640  5     1    $W6D0 JN
/var/log/xferlog                        600  7     100  *     JC</programlisting>

	<para>Jede Zeile beginnt mit dem Namen der Datei, die rotiert
	  werden soll, optional gefolgt von Besitzer und Gruppe für
	  rotierende, als auch für neu erstellte Dateien.  Das nächste
	  Feld, <literal>mode</literal>, definiert die Zugriffsrechte
	  der Datei.  <literal>count</literal> gibt an, wie viele
	  rotierte Dateien aufbewahrt werden sollen.  Anhand der
	  <literal>size</literal>- und
	  <literal>when</literal>-<foreignphrase>Flags</foreignphrase>
	  erkennt <command>newsyslog</command>, wann die Datei rotiert
	  werden muss.  Eine Log-Datei wird rotiert, wenn ihre Größe
	  den Wert von <literal>size</literal> überschreitet, oder
	  wenn die Zeit im <literal>when</literal>-Feld abgelaufen
	  ist.  Ein <literal>*</literal> bedeutet, dass dieses Feld
	  ignoriert wird.  Das <replaceable>flags</replaceable>-Feld
	  gibt &man.newsyslog.8; weitere Instruktionen, zum Beispiel
	  wie eine Datei zu rotieren ist, oder eine Datei zu erstellen
	  falls diese nicht existiert.  Die letzten beiden Felder sind
	  optional und bestimmen die
	  <acronym role="Process Identifier">PID</acronym>-Datei sowie
	  eine Signalnummer, die zu diesem Prozess geschickt wird,
	  wenn die Datei rotiert wird.  Weitere Informationen zu
	  allen Feldern, gültigen <foreignphrase>flags</foreignphrase>
	  und wie Sie die Rotationszeit angeben können, finden Sie in
	  &man.syslog.conf.5;.  Denken Sie daran, dass
	  <command>newsyslog</command> von <command>cron</command>
	  aufgerufen wird und somit Dateien auch nur dann rotiert,
	  wenn es von &man.cron.8; aufgerufen wird, und nicht
	  häufiger.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="configtuning-configfiles">
    <title>Konfigurationsdateien</title>

    <sect2>
      <title><filename>/etc</filename> Layout</title>

      <para>Konfigurationsdateien finden sich in einigen
	Verzeichnissen unter anderem in:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <colspec colwidth="1*"/>
	  <colspec colwidth="2*"/>

	  <tbody>
	    <row>
	      <entry><filename>/etc</filename></entry>
	      <entry>Enthält generelle Konfigurationsinformationen,
		die Daten hier sind systemspezifisch.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/defaults</filename></entry>
	      <entry>Default Versionen der Konfigurationsdateien.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/mail</filename></entry>
	      <entry>Enthält die &man.sendmail.8; Konfiguration
		und weitere MTA Konfigurationsdateien.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/ppp</filename></entry>
	      <entry>Hier findet sich die Konfiguration für
		die User- und Kernel-ppp Programme.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/namedb</filename></entry>
	      <entry>Das Vorgabeverzeichnis, in dem Daten von
		&man.named.8; gehalten werden.  Normalerweise
		werden hier <filename>named.conf</filename> und
		Zonendaten abgelegt.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/local/etc</filename></entry>
	      <entry>Installierte Anwendungen legen hier ihre
		Konfigurationsdateien ab.  Dieses Verzeichnis kann
		Unterverzeichnisse für bestimmte Anwendungen
		enthalten.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/local/etc/rc.d</filename></entry>
	      <entry>Ort für Start- und Stopskripten installierter
		Anwendungen.</entry>
	    </row>

	    <row>
	      <entry><filename>/var/db</filename></entry>
	      <entry>Automatisch generierte systemspezifische
		Datenbanken, wie die Paket-Datenbank oder die
		<command>locate</command>-Datenbank.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </sect2>

    <sect2>
      <title>Hostnamen</title>

      <indexterm><primary>hostname</primary></indexterm>
      <indexterm><primary>DNS</primary></indexterm>

      <sect3>
	<title><filename>/etc/resolv.conf</filename></title>

	<indexterm><primary><filename>resolv.conf</filename></primary></indexterm>

	<para>Wie der &os;-Resolver auf das Internet Domain Name
	  System (DNS) zugreift, wird in
	  <filename>/etc/resolv.conf</filename> festgelegt.</para>

	<para>Die gebräuchlichsten Einträge in
	  <filename>/etc/resolv.conf</filename> sind:</para>

	<informaltable frame="none" pgwide="1">
	  <tgroup cols="2">
	    <colspec colwidth="1*"/>
	    <colspec colwidth="2*"/>

	    <tbody>
	      <row>
		<entry><literal>nameserver</literal></entry>
		<entry>Die IP-Adresse eines Nameservers, den
		  der Resolver abfragen soll.  Bis zu drei Server
		  werden in der Reihenfolge, in der sie aufgezählt
		  sind, abgefragt.</entry>
	      </row>
	      <row>
		<entry><literal>search</literal></entry>
		<entry>Suchliste mit Domain-Namen zum Auflösen von
		  Hostnamen.  Die Liste wird normalerweise durch den
		  Domain-Teil des lokalen Hostnamens
		  festgelegt.</entry>
	      </row>
	      <row>
		<entry><literal>domain</literal></entry>
		<entry>Der lokale Domain-Name.</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

	<para>Beispiel für eine typische
	  <filename>resolv.conf</filename>:</para>

	<programlisting>search example.com
nameserver 147.11.1.11
nameserver 147.11.100.30</programlisting>

	<note>
	  <para>Nur eine der Anweisungen <literal>search</literal>
	    oder <literal>domain</literal> sollte benutzt
	    werden.</para>
	</note>

	<para>Wenn Sie DHCP benutzen, überschreibt &man.dhclient.8;
	  für gewöhnlich <filename>resolv.conf</filename>
	  mit den Informationen vom DHCP-Server.</para>
      </sect3>

      <sect3>
	<title><filename>/etc/hosts</filename></title>

	<indexterm><primary>hosts</primary></indexterm>

	<para><filename>/etc/hosts</filename> ist eine einfache
	  textbasierte Datenbank, die aus alten Internetzeiten
	  stammt.  Zusammen mit DNS und NIS stellt sie eine Abbildung
	  zwischen Namen und IP-Adressen zur Verfügung.  Anstatt
	  &man.named.8; zu konfigurieren, können hier lokale Rechner,
	  die über ein LAN verbunden sind, eingetragen werden.  Lokale
	  Einträge für gebräuchliche Internet-Adressen in
	  <filename>/etc/hosts</filename> verhindern die Abfrage eines
	  externen Servers und beschleunigen die
	  Namensauflösung.</para>

	<programlisting># &dollar;FreeBSD&dollar;
#
#
# Host Database
#
# This file should contain the addresses and aliases for local hosts that
# share this file.  Replace 'my.domain' below with the domainname of your
# machine.
#
# In the presence of the domain name service or NIS, this file may
# not be consulted at all; see /etc/nsswitch.conf for the resolution order.
#
#
::1         localhost localhost.my.domain
127.0.0.1       localhost localhost.my.domain
#
# Imaginary network.
#10.0.0.2       myname.my.domain myname
#10.0.0.3       myfriend.my.domain myfriend
#
# According to RFC 1918, you can use the following IP networks for
# private nets which will never be connected to the Internet:
#
#   10.0.0.0    -   10.255.255.255
#   172.16.0.0  -   172.31.255.255
#   192.168.0.0 -   192.168.255.255
#
# In case you want to be able to connect to the Internet, you need
# real official assigned numbers.  Do not try to invent your own network
# numbers but instead get one from your network provider (if any) or
# from your regional registry (ARIN, APNIC, LACNIC, RIPE NCC, or AfriNIC.)
#</programlisting>

	<para><filename>/etc/hosts</filename> hat ein einfaches
	  Format:</para>

	<programlisting>[Internet Adresse] [Offizieller Hostname] [Alias1] [Alias2] ...</programlisting>

	<para>Zum Beispiel:</para>

	<programlisting>10.0.0.1 myRealHostname.example.com myRealHostname foobar1 foobar2</programlisting>

	<para>Weitere Informationen entnehmen Sie bitte
	  &man.hosts.5;.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="configtuning-sysctlconf">
      <title><filename>sysctl.conf</filename></title>

      <indexterm><primary>sysctl.conf</primary></indexterm>
      <indexterm><primary>sysctl</primary></indexterm>

      <para><filename>sysctl.conf</filename> sieht ähnlich
	wie <filename>rc.conf</filename> aus.  Werte werden in der
	Form <literal>Variable=Wert</literal> gesetzt.
	Die angegebenen Werte werden gesetzt, nachdem sich das
	System bereits im Mehrbenutzermodus befindet.  Allerdings
	lassen sich im Mehrbenutzermodus nicht alle Werte
	setzen.</para>

      <para>Um das Protokollieren von fatalen Signalen abzustellen
	und Benutzer daran zu hindern, von anderen Benutzern
	gestartete Prozesse zu sehen, können Sie in der
	Datei <filename>sysctl.conf</filename> die folgenden
	Variablen setzen:</para>

      <programlisting># Do not log fatal signal exits (e.g. sig 11)
kern.logsigexit=0

# Prevent users from seeing information about processes that
# are being run under another UID.
security.bsd.see_other_uids=0</programlisting>

    </sect2>
  </sect1>

  <sect1 xml:id="configtuning-sysctl">
    <title>Einstellungen mit &man.sysctl.8;</title>

    <indexterm><primary>sysctl</primary></indexterm>
    <indexterm>
      <primary>Einstellungen</primary>
      <secondary>mit sysctl</secondary>
    </indexterm>

    <para>Mit &man.sysctl.8; können Sie Änderungen an
      einem laufenden &os;-System vornehmen.  Unter anderem
      können Optionen des TCP/IP-Stacks oder des
      virtuellen Speichermanagements verändert werden.  Unter
      der Hand eines erfahrenen Systemadministrators kann dies
      die Systemperformance erheblich verbessern.  Über 500
      Variablen können mit &man.sysctl.8; gelesen und gesetzt
      werden.</para>

    <para>Der Hauptzweck von &man.sysctl.8; besteht darin,
      Systemeinstellungen zu lesen und zu verändern.</para>

    <para>Alle auslesbaren Variablen werden wie folgt
      angezeigt:</para>

    <screen>&prompt.user; <userinput>sysctl -a</userinput></screen>

    <para>Sie können auch eine spezielle Variable, z.B.
      <varname>kern.maxproc</varname> lesen:</para>

    <screen>&prompt.user; <userinput>sysctl kern.maxproc</userinput>
kern.maxproc: 1044</screen>

    <para>Um eine Variable zu setzen, benutzen Sie die Syntax
      <replaceable>Variable</replaceable>=
      <replaceable>Wert</replaceable>:</para>

    <screen>&prompt.root; <userinput>sysctl kern.maxfiles=5000</userinput>
kern.maxfiles: 2088 -&gt; 5000</screen>

    <para>Mit sysctl können Sie Strings, Zahlen oder Boolean-Werte
      setzen.  Bei Boolean-Werten setzen sie <literal>1</literal>
      für wahr und <literal>0</literal> für falsch.</para>

    <para>Um die Variablen automatisch während des Systemstarts zu
      setzen, fügen Sie sie in <filename>/etc/sysctl.conf</filename>
      ein.  Weitere Informationen finden Sie in der Hilfeseite
      &man.sysctl.conf.5; und in <xref
	linkend="configtuning-sysctlconf"/>.</para>

    <sect2 xml:id="sysctl-readonly">
      <info>
	<title>Schreibgeschützte Variablen</title>

	<authorgroup>
	  <author>
	    <personname>
	      <firstname>Tom</firstname>
	      <surname>Rhodes</surname>
	    </personname>
	    <contrib>Contributed by </contrib>
	  </author>
	</authorgroup>
      </info>

      <para>Schreibgeschützte sysctl-Variablen können nur
	während des Systemstarts verändert werden.</para>

      <para>Beispielsweise hat &man.cardbus.4; auf einigen Laptops
	Schwierigkeiten, Speicherbereiche zu erkennen.  Es treten
	dann Fehlermeldungen wie die folgende auf:</para>

      <screen>cbb0: Could not map register memory
device_probe_and_attach: cbb0 attach returned 12</screen>

      <para>Um dieses Problem zu lösen, muss eine
	schreibgeschützte sysctl-Variable verändert werden.  Eine
	<acronym>OID</acronym> kann in
	<filename>/boot/loader.conf</filename> überschrieben werden.
	<filename>/boot/defaults/loader.conf</filename>
	enthält Vorgabewwerte für sysctl-Variablen.</para>

      <para>Das oben erwähnte Problem wird durch die Angabe von
	<option>hw.pci.allow_unsupported_io_range=1</option> in
	<filename>/boot/loader.conf</filename> gelöst.
	Danach sollte &man.cardbus.4; fehlerfrei funktionieren.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="configtuning-disk">
    <title>Tuning von Laufwerken</title>

    <sect2>
      <title>Sysctl Variablen</title>

      <sect3>
	<title><varname>vfs.vmiodirenable</varname></title>

	<indexterm>
	  <primary><varname>vfs.vmiodirenable</varname></primary>
	</indexterm>

	<para>Die Variable <varname>vfs.vmiodirenable</varname>
	  besitzt in der Voreinstellung den Wert 1.  Die Variable kann
	  auf den Wert 0 (ausgeschaltet) oder 1 (angeschaltet) gesetzt
	  werden.  Sie steuert, wie Verzeichnisse vom System
	  zwischengespeichert werden.  Die meisten Verzeichnisse sind
	  klein und benutzen nur ein einzelnes Fragment,
	  typischerweise 1&nbsp;kB, im Dateisystem.  Im Buffer-Cache
	  verbrauchen sie mit 512&nbsp;Bytes noch weniger Platz.  Ist
	  die Variable ausgeschaltet (auf 0) wird der Buffer-Cache nur
	  eine limitierte Anzahl Verzeichnisse zwischenspeichern, auch
	  wenn das System über sehr viel Speicher verfügt.
	  Ist die Variable aktiviert (auf 1), kann der Buffer-Cache
	  den VM-Page-Cache benutzen, um Verzeichnisse
	  zwischenzuspeichern.  Der ganze Speicher steht damit zum
	  Zwischenspeichern von Verzeichnissen zur Verfügung.  Der
	  Nachteil bei dieser Vorgehensweise ist, dass zum
	  Zwischenspeichern eines Verzeichnisses mindestens eine
	  physikalische Seite im Speicher, die normalerweise 4&nbsp;kB
	  groß ist, anstelle von 512&nbsp;Bytes gebraucht wird.  Es
	  wird empfohlen, diese Option aktiviert zu lassen, wenn Sie
	  Dienste zur Verfügung stellen, die viele Dateien
	  manipulieren.  Beispiele für solche Dienste sind Web-Caches,
	  große Mail-Systeme oder Netnews.  Die aktivierte
	  Variable vermindert, trotz des verschwendeten Speichers,
	  in aller Regel nicht die Leistung des Systems, obwohl Sie
	  das nachprüfen sollten.</para>
      </sect3>

      <sect3>
	<title><varname>vfs.write_behind</varname></title>

	<indexterm>
	  <primary><varname>vfs.write_behind</varname></primary>
	</indexterm>

	<para>In der Voreinstellung besitzt die Variable
	  <varname>vfs.write_behind</varname> den Wert
	  <literal>1</literal> (aktiviert).  Mit dieser Einstellung
	  schreibt das Dateisystem anfallende vollständige Cluster,
	  die besonders beim sequentiellen Schreiben großer Dateien
	  auftreten, direkt auf das Medium aus.  Dies verhindert,
	  dass sich im Buffer-Cache veränderte Puffer
	  (<foreignphrase>dirty buffers</foreignphrase>) ansammeln,
	  die die I/O-Verarbeitung nicht mehr beschleunigen
	  würden.  Unter bestimmten Umständen blockiert
	  diese Funktion allerdings Prozesse.  Setzen Sie in diesem
	  Fall die Variable <varname>vfs.write_behind</varname> auf
	  den Wert <literal>0</literal>.</para>
      </sect3>

      <sect3>
	<title><varname>vfs.hirunningspace</varname></title>

	<indexterm>
	  <primary><varname>vfs.hirunningspace</varname></primary>
	</indexterm>

	<para>Die Variable <varname>vfs.hirunningspace</varname>
	  bestimmt systemweit die Menge ausstehender
	  Schreiboperationen, die dem Platten-Controller zu jedem
	  beliebigen Zeitpunkt übergeben werden können.  Normalerweise
	  können Sie den Vorgabewert verwenden.  Auf Systemen mit
	  vielen Platten kann der Wert aber auf 4 bis
	  5&nbsp;<emphasis>Megabyte</emphasis> erhöht werden.
	  Beachten Sie, dass ein zu hoher Wert (größer
	  als der Schreib-Schwellwert des Buffer-Caches) zu
	  Leistungverlusten führen kann.  Setzen Sie den Wert daher
	  nicht zu hoch!  Hohe Werte können auch Leseoperationen
	  verzögern, die gleichzeitig mit Schreiboperationen
	  ausgeführt werden.</para>

	<para>Es gibt weitere Variablen, mit denen Sie den
	  Buffer-Cache und den VM-Page-Cache beeinflussen können.
	  Es wird nicht empfohlen, diese Variablen zu
	  verändern, da das VM-System den virtuellen Speicher selbst
	  sehr gut verwaltet.</para>
      </sect3>

      <sect3>
	<title><varname>vm.swap_idle_enabled</varname></title>

	<indexterm>
	  <primary><varname>vm.swap_idle_enabled</varname></primary>
	</indexterm>

	<para>Die Variable <varname>vm.swap_idle_enabled</varname>
	  ist für große Mehrbenutzer-Systeme gedacht, auf
	  denen sich viele Benutzer an- und abmelden und auf denen
	  es viele Prozesse im Leerlauf
	  (<foreignphrase>idle</foreignphrase>) gibt.  Solche Systeme
	  fragen kontinuierlich freien Speicher an.  Wenn Sie die
	  Variable <varname>vm.swap_idle_enabled</varname> aktivieren,
	  können Sie die Auslagerungs-Hysterese von Seiten mit
	  den Variablen <varname>vm.swap_idle_threshold1</varname> und
	  <varname>vm.swap_idle_threshold2</varname> einstellen.  Die
	  Schwellwerte beider Variablen geben die Zeit in Sekunden an,
	  in denen sich ein Prozess im Leerlauf befinden muss.  Wenn
	  die Werte so eingestellt sind, dass Seiten früher als nach
	  dem normalen Algorithmus ausgelagert werden, verschafft das
	  dem Auslagerungs-Prozess mehr Luft.  Aktivieren Sie diese
	  Funktion nur, wenn Sie sie wirklich benötigen:  Die
	  Speicherseiten werden eher früher als später ausgelagert.
	  Der Platz im Swap-Bereich wird dadurch schneller verbraucht
	  und die Plattenaktivitäten steigen an.  Auf kleinen
	  Systemen hat diese Funktion spürbare Auswirkungen.  Auf
	  großen Systemen, die sowieso schon Seiten auslagern müssen,
	  können ganze Prozesse leichter in den Speicher geladen oder
	  ausgelagert werden.</para>
      </sect3>

      <sect3>
	<title><varname>hw.ata.wc</varname></title>

	<indexterm>
	  <primary><varname>hw.ata.wc</varname></primary>
	</indexterm>

	<para>In &os;&nbsp;4.3 wurde versucht, den
	  IDE-Schreib-Zwischenspeicher abzustellen.  Obwohl dies die
	  Bandbreite zum Schreiben auf IDE-Platten verringerte, wurde
	  es aus Gründen der Datenkonsistenz als notwenig angesehen.
	  Der Kern des Problems ist, dass IDE-Platten keine
	  zuverlässige Aussage über das Ende eines Schreibvorgangs
	  treffen.  Wenn der Schreib-Zwischenspeicher aktiviert ist,
	  werden die Daten nicht in der Reihenfolge ihres Eintreffens
	  geschrieben.  Es kann sogar passieren, dass das Schreiben
	  mancher Blöcke im Fall von starker Plattenaktivität auf
	  unbefristete Zeit verzögert wird.  Ein Absturz oder
	  Stromausfall zu dieser Zeit kann die Dateisysteme erheblich
	  beschädigen.  Wir entschieden uns daher für die sichere
	  Variante und stellten den Schreib-Zwischenspeicher ab.
	  Leider war damit auch ein großer Leistungsverlust verbunden,
	  so dass wir die Variable nach dem Release wieder aktiviert
	  haben.  Sie sollten den Wert der Variable
	  <varname>hw.ata.wc</varname> auf dem System überprüfen.
	  Wenn der Schreib-Zwischenspeicher abgestellt ist, können Sie
	  ihn aktivieren, indem Sie die Variable auf den Wert 1
	  setzen.  Dies muss zum Zeitpunkt des Systemstarts im
	  Boot-Loader geschehen.  Eine Änderung der Variable, nachdem
	  der Kernel gestartet ist, hat keine Auswirkungen.</para>

	<para>Weitere Informationen finden Sie in &man.ata.4;.</para>
      </sect3>

      <sect3>
	<title><literal>SCSI_DELAY</literal>
	  (<varname>kern.cam.scsi_delay</varname>)</title>

	<indexterm>
	  <primary><varname>kern.cam.scsi_delay</varname></primary>
	</indexterm>

	<indexterm>
	  <primary>Kerneloptionen</primary>
	  <secondary><literal>SCSI_DELAY</literal></secondary>
	</indexterm>

	<para>Mit der Kerneloption <literal>SCSI_DELAY</literal> kann
	  die Dauer des Systemstarts verringert werden.  Der
	  Vorgabewert ist recht hoch und er verzögert den Systemstart
	  um 15 oder mehr Sekunden.  Normalerweise kann dieser Wert,
	  insbesondere mit modernen Laufwerken, auf 5&nbsp;Sekunden
	  heruntergesetzt werden (durch Setzen der
	  <command>sysctl</command>-Variable
	  <varname>kern.cam.scsi_delay</varname>).  Die Variable sowie
	  die Kerneloption verwenden für die Zeitangabe Millisekunden
	  und <emphasis>nicht</emphasis> Sekunden.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="soft-updates">
      <title>Soft Updates</title>

      <indexterm><primary>Soft Updates</primary></indexterm>
      <indexterm><primary>tunefs</primary></indexterm>

      <para>Mit &man.tunefs.8; lassen sich Feineinstellungen an
	Dateisystemen vornehmen.  Das Programm hat verschiedene
	Optionen, von denen hier nur Soft Updates betrachtet werden.
	Soft Updates werden wie folgt ein- und ausgeschaltet:</para>

      <screen>&prompt.root; <userinput>tunefs -n enable /filesystem</userinput>
&prompt.root; <userinput>tunefs -n disable /filesystem</userinput></screen>

      <para>Ein eingehängtes Dateisystem kann nicht mit &man.tunefs.8;
	modifiziert werden.  Soft Updates werden am besten im
	Single-User Modus aktiviert, bevor Partitionen eingehangen
	sind.</para>

      <para>Durch Einsatz eines Zwischenspeichers wird die Performance
	im Bereich der Metadaten, vorwiegend beim Anlegen und Löschen
	von Dateien, gesteigert.  Wir empfehlen, Soft Updates auf
	allen Dateisystemen zu aktivieren.  Allerdings sollten Sie
	sich über die zwei Nachteile von Soft Updates bewusst sein:
	Erstens garantieren Soft Updates zwar die Konsistenz der Daten
	im Fall eines Absturzes, aber es kann leicht passieren, dass
	das Dateisystem über mehrere Sekunden oder gar eine Minute
	nicht synchronisiert wurde.  Im Fall eines Absturzes verlieren
	Sie mit Soft Updates unter Umständen mehr Daten als ohne.
	Zweitens verzögern Soft Updates die Freigabe von
	Datenblöcken.  Eine größere Aktualisierung
	eines fast vollen Dateisystems, wie dem Root-Dateisystem,
	z.B. während eines <command>make installworld</command>,
	kann das Dateisystem vollaufen lassen.  Dadurch würde
	die Aktualisierung fehlschlagen.</para>

      <sect3>
	<title>Details über Soft Updates</title>

	<indexterm>
	  <primary>Soft Updates</primary>
	  <secondary>Details</secondary>
	</indexterm>

	<para>Es gibt zwei klassische Herangehensweisen, wie
	  man die Metadaten des Dateisystems (also Daten
	  über Dateien, wie inode Bereiche oder Verzeichniseinträge)
	  aktualisiert auf die Platte zurückschreibt:</para>

	<para>Das historisch übliche Verfahren waren synchrone
	  Updates der Metadaten, d. h. wenn eine Änderung an
	  einem Verzeichnis nötig war, wurde anschließend
	  gewartet, bis diese Änderung tatsächlich auf die
	  Platte zurückgeschrieben worden war.  Der
	  <emphasis>Inhalt</emphasis> der Dateien wurde im
	  <quote>Buffer Cache</quote> zwischengespeichert und
	  asynchron irgendwann später auf die Platte geschrieben.
	  Der Vorteil dieser Implementierung ist, dass sie
	  sicher funktioniert.  Wenn während eines Updates ein
	  Ausfall erfolgt, haben die Metadaten immer einen
	  konsistenten Zustand.  Eine Datei ist entweder komplett
	  angelegt oder gar nicht.  Wenn die Datenblöcke einer
	  Datei im Fall eines Absturzes noch nicht den Weg aus dem
	  <quote>Buffer Cache</quote> auf die Platte gefunden haben,
	  kann &man.fsck.8; das Dateisystem reparieren, indem es die
	  Dateilänge einfach auf 0 setzt.  Außerdem
	  ist die Implementierung einfach und überschaubar.  Der
	  Nachteil ist, dass Änderungen der Metadaten sehr
	  langsam vor sich gehen.  Ein <command>rm -r</command>
	  beispielsweise fasst alle Dateien eines Verzeichnisses
	  der Reihe nach an, aber jede dieser Änderungen am
	  Verzeichnis (Löschen einer Datei) wird einzeln synchron
	  auf die Platte geschrieben.  Gleiches beim Auspacken
	  großer Hierarchien (<command>tar -x</command>).</para>

	<para>Der zweite Fall sind asynchrone Metadaten-Updates.  Das
	  ist z. B. der Standard bei Linux/ext2fs oder die Variante
	  <command>mount -o async</command> für *BSD UFS.  Man
	  schickt die Updates der Metadaten einfach auch noch
	  über den <quote>Buffer Cache</quote>, sie werden also
	  zwischen die Updates der normalen Daten eingeschoben.
	  Vorteil ist, dass man nun nicht mehr auf jeden Update
	  warten muss, Operationen, die zahlreiche Metadaten
	  ändern, werden also viel schneller.  Auch
	  hier ist die Implementierung sehr einfach und wenig
	  anfällig für Fehler.  Nachteil ist, dass
	  keinerlei Konsistenz des Dateisystems mehr gesichert ist.
	  Wenn mitten in einer Operation, die viele Metadaten
	  ändert, ein Ausfall erfolgt (Stromausfall, drücken
	  des Reset-Tasters), dann ist das Dateisystem
	  anschließend in einem unbestimmten Zustand.  Niemand
	  kann genau sagen, was noch geschrieben worden ist und was
	  nicht mehr; die Datenblöcke einer Datei können
	  schon auf der Platte stehen, während die inode Tabelle
	  oder das zugehörige Verzeichnis nicht mehr aktualisiert
	  worden ist.  Man kann praktisch kein <command>fsck</command>
	  mehr implementieren, das diesen Zustand
	  wieder reparieren kann, da die dazu nötigen
	  Informationen einfach auf der Platte fehlen.  Wenn ein
	  Dateisystem derart beschädigt worden ist, kann man es
	  nur neu erzeugen (&man.newfs.8;) und die Daten
	  vom Backup zurückspielen.
	  </para>

	<para>Der historische Ausweg aus diesem Dilemma war ein
	  <emphasis>dirty region logging</emphasis> (auch als
	  <emphasis>Journalling</emphasis> bezeichnet, wenngleich
	  dieser Begriff nicht immer gleich benutzt und manchmal auch
	  für andere Formen von Transaktionsprotokollen gebraucht
	  wird).  Man schreibt die Metadaten-Updates zwar synchron,
	  aber nur in einen kleinen Plattenbereich, die
	  <emphasis>logging area</emphasis>.  Von da aus werden sie
	  dann asynchron auf ihre eigentlichen Bereiche verteilt.  Da
	  die <emphasis>logging area</emphasis> ein kleines
	  zusammenhängendes Stückchen ist, haben die
	  Schreibköpfe der Platte bei massiven Operationen auf
	  Metadaten keine allzu großen Wege zurückzulegen,
	  so dass alles ein ganzes Stück schneller geht als
	  bei klassischen synchronen Updates.  Die Komplexität
	  der Implementierung hält sich ebenfalls in Grenzen,
	  somit auch die Anfälligkeit für Fehler.  Als
	  Nachteil ergibt sich, dass Metadaten zweimal auf die
	  Platte geschrieben werden müssen (einmal in die
	  <emphasis>logging area</emphasis>, einmal an die richtige
	  Stelle), so dass das im Falle regulärer
	  Arbeit (also keine gehäuften Metadatenoperationen) eine
	  <quote>Pessimisierung</quote> des Falls der synchronen
	  Updates eintritt, es wird alles langsamer.  Dafür hat man
	  als Vorteil, dass im Falle eines Crashes der
	  konsistente Zustand dadurch erzielbar ist, dass die
	  angefangenen Operationen aus dem <emphasis>dirty region
	  log</emphasis> entweder zu Ende ausgeführt oder
	  komplett verworfen werden, wodurch das Dateisystem schnell
	  wieder zur Verfügung steht.</para>

	<para>Die Lösung von Kirk McKusick, dem Schöpfer von
	  Berkeley FFS, waren <emphasis>Soft Updates</emphasis>: die
	  notwendigen Updates der Metadaten werden im Speicher
	  gehalten und dann sortiert auf die Platte geschrieben
	  (<quote>ordered metadata updates</quote>).  Dadurch hat man
	  den Effekt, dass im Falle massiver
	  Metadaten-Änderungen spätere Operationen die
	  vorhergehenden, noch nicht auf die Platte geschriebenen
	  Updates desselben Elements im Speicher
	  <quote>einholen</quote>.  Alle Operationen, auf ein
	  Verzeichnis beispielsweise, werden also in der Regel noch im
	  Speicher abgewickelt, bevor der Update überhaupt auf
	  die Platte geschrieben wird (die dazugehörigen
	  Datenblöcke werden natürlich auch so sortiert,
	  dass sie nicht vor ihren Metadaten auf der Platte
	  sind).  Im Fall eines Absturzes hat man ein implizites
	  <quote>log rewind</quote>: alle Operationen, die noch nicht
	  den Weg auf die Platte gefunden haben, sehen danach so aus,
	  als hätten sie nie stattgefunden.  Man hat so also den
	  konsistenten Zustand von ca. 30 bis 60&nbsp;Sekunden früher
	  sichergestellt.  Der verwendete Algorithmus garantiert
	  dabei, dass alle tatsächlich benutzten Ressourcen
	  auch in den entsprechenden Bitmaps (Block- und inode
	  Tabellen) als belegt markiert sind.  Der einzige Fehler, der
	  auftreten kann, ist, dass Ressourcen noch als
	  <quote>belegt</quote> markiert sind, die tatsächlich
	  <quote>frei</quote> sind.  &man.fsck.8; erkennt dies und
	  korrigiert diese nicht mehr belegten Ressourcen.  Die
	  Notwendigkeit eines Dateisystem-Checks darf aus diesem
	  Grunde auch ignoriert und das Dateisystem mittels
	  <command>mount -f</command> zwangsweise eingebunden werden.
	  Um noch allozierte Ressourcen freizugeben muss
	  später ein &man.fsck.8; nachgeholt werden.  Das ist
	  dann auch die Idee des <emphasis>background fsck</emphasis>:
	  beim Starten des Systems wird lediglich ein
	  <emphasis>Schnappschuss</emphasis> des Filesystems
	  gemacht, mit dem &man.fsck.8; dann später arbeiten
	  kann.  Alle Dateisysteme dürfen <quote>unsauber</quote>
	  eingebunden werden und das System kann sofort in den
	  Multiuser-Modus gehen.  Danach wird ein
	  Hintergrund-<command>fsck</command> für die
	  Dateisysteme gestartet, die dies benötigen, um
	  möglicherweise irrtümlich belegte Ressourcen
	  freizugeben.  (Dateisysteme ohne <emphasis>Soft
	  Updates</emphasis> benötigen natürlich immer noch
	  den üblichen (Vordergrund-)<command>fsck</command>,
	  bevor sie eingebunden werden können.)</para>

	<para>Der Vorteil ist, dass die Metadaten-Operationen
	  beinahe so schnell ablaufen wie im asynchronen Fall, also
	  auch schneller als beim <emphasis>logging</emphasis>, das
	  die Metadaten immer zweimal schreiben muss.  Als
	  Nachteil stehen dem die Komplexität des Codes (mit
	  einer erhöhten Fehlerwahrscheinlichkeit in einem
	  bezüglich Datenverlust hoch sensiblen Bereich) und ein
	  erhöhter Speicherverbrauch entgegen.  Außerdem
	  muss man sich an einige Eigenheiten gewöhnen: Nach einem
	  Absturz ist ein etwas älterer Stand auf der
	  Platte &ndash; statt einer leeren, aber bereits angelegten
	  Datei (wie nach einem herkömmlichen
	  <command>fsck</command> Lauf) ist auf einem Dateisystem mit
	  <emphasis>Soft Updates</emphasis> keine Spur der
	  entsprechenden Datei mehr zu sehen, da weder die Metadaten
	  noch der Dateiinhalt je auf die Platte geschrieben wurden.
	  Weiterhin kann der Platz nach einem <command>rm -r</command>
	  nicht sofort wieder als verfügbar markiert werden,
	  sondern erst dann, wenn der Update auch auf die Platte
	  vermittelt worden ist.  Dies kann besonders dann Probleme
	  bereiten, wenn große Datenmengen in einem Dateisystem
	  ersetzt werden, das nicht genügend Platz hat, um alle
	  Dateien zweimal unterzubringen.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="configtuning-kernel-limits">
    <title>Einstellungen von Kernel Limits</title>

    <indexterm>
      <primary>Einstellungen</primary>
      <secondary>von Kernel Limits</secondary>
    </indexterm>

    <sect2 xml:id="file-process-limits">
      <title>Datei und Prozeß Limits</title>

      <sect3 xml:id="kern-maxfiles">
	<title><varname>kern.maxfiles</varname></title>

	<indexterm>
	  <primary><varname>kern.maxfiles</varname></primary>
	</indexterm>

	<para>Abhängig von den Anforderungen an das System
	  kann <varname>kern.maxfiles</varname> erhöht oder
	  gesenkt werden.  Die Variable legt die maximale
	  Anzahl von Dateideskriptoren auf dem System fest.  Wenn
	  die Dateideskriptoren aufgebraucht sind, werden Sie
	  die Meldung <errorname>file: table is full</errorname>
	  wiederholt im Puffer für Systemmeldungen sehen.  Den
	  Inhalt des Puffers können Sie sich mit
	  <command>dmesg</command> anzeigen lassen.</para>

	<para>Jede offene Datei, jedes Socket und jede FIFO verbraucht
	  einen Dateideskriptor.  Auf <quote>dicken</quote>
	  Produktionsservern können leicht Tausende Dateideskriptoren
	  benötigt werden, abhängig von der Art und Anzahl der
	  gleichzeitig laufenden Dienste.</para>

	<para>In älteren &os;-Versionen wurde die Voreinstellung
	  von <varname>kern.maxfile</varname> aus der
	  Kernelkonfigurationsoption <literal>maxusers</literal>
	  bestimmt.  <varname>kern.maxfiles</varname> wächst
	  proportional mit dem Wert von <literal>maxusers</literal>.
	  Wenn Sie einen angepassten Kernel kompilieren, empfiehlt es
	  sich diese Option entsprechend der maximalen Benutzerzahl
	  des Systems einzustellen.  Obwohl auf einer
	  Produktionsmaschine vielleicht nicht 256 Benutzer
	  gleichzeitig angemeldet sind, können die benötigten
	  Ressourcen ähnlich hoch wie bei einem großen Webserver
	  sein.</para>

	<para>Die Variable <varname>kern.maxusers</varname> wird beim
	  Systemstart automatisch aus dem zur Verfügung stehenden
	  Hauptspeicher bestimmt.  Im laufenden Betrieb kann dieser
	  Wert aus der (nur lesbaren) sysctl-Variable
	  <varname>kern.maxusers</varname> ermittelt werden.  Falls
	  ein System für diese Variable einen anderen Wert benötigt,
	  kann der Wert über den Loader angepasst werden.
	  Häufig verwendete Werte sind dabei 64, 128, sowie 256.
	  Es wird nicht empfohlen, die Anzahl der Dateideskriptoren
	  auf einen Wert größer 256 zu setzen, es sei denn,
	  Sie benötigen wirklich eine riesige Anzahl von ihnen.
	  Viele der von <varname>kern.maxusers</varname> auf einen
	  Standardwert gesetzten Parameter können beim Systemstart
	  oder im laufenden Betrieb in
	  <filename>/boot/loader.conf</filename> angepasst werden.
	  In &man.loader.conf.5; und
	  <filename>/boot/defaults/loader.conf</filename>finden Sie
	  weitere Details und Hinweise.</para>

	<para>Ältere &os;-Versionen setzen diesen Wert selbst,
	  wenn Sie in der Konfigurationsdatei den Wert <literal>0</literal>
	  <footnote><para>Der verwendete Algorithmus setzt
	    <literal>maxusers</literal> auf die Speichergröße
	    des Systems.  Der minimale Wert beträgt dabei
	    <literal>32</literal>, das Maximum ist
	    <literal>384</literal>.</para></footnote>
	  angeben.  Wenn Sie den Wert selbst bestimmen wollen,
	  sollten Sie <literal>maxusers</literal> mindestens auf
	  <literal>4</literal> setzen.  Dies gilt insbesondere dann,
	  wenn Sie beabsichtigen, <application>&xorg;</application> zu
	  benutzen oder Software zu kompilieren.  Der wichtigste Wert,
	  der durch <literal>maxusers</literal> bestimmt wird, die
	  maximale Anzahl an Prozessen ist, die auf
	  <literal>20 + 16 * maxusers</literal> gesetzt wird.  Wird
	  <literal>maxusers</literal> auf 1 setzen, können
	  gleichzeitig nur 36 Prozesse laufen, von denen ungefähr
	  18 schon beim Booten des Systems gestartet werden.  Dazu
	  kommen nochmals etwa 15 Prozesse beim Start von
	  <application>&xorg;</application>.  Selbst eine einfache
	  Aufgabe wie das Lesen einer Manualpage benötigt neun
	  Prozesse zum Filtern, Dekomprimieren und Betrachten der
	  Datei.  Für die meisten
	  Benutzer sollte es ausreichen, <literal>maxusers</literal>
	  auf 64 zu setzen, womit 1044 gleichzeitige Prozesse zur
	  Verfügung stehen.  Wenn Sie allerdings den
	  gefürchteten Fehler <errortype>proc table full</errortype>
	  beim Start eines Programms oder auf einem Server mit einer
	  großen Benutzerzahl (wie
	  <systemitem class="fqdomainname">ftp.FreeBSD.org</systemitem>)
	  sehen, dann sollten Sie den Wert nochmals erhöhen und den
	  Kernel neu bauen.</para>

	<note>
	  <para>Die Anzahl der Benutzer, die sich auf einem
	    Rechner anmelden kann, wird durch
	    <literal>maxusers</literal> <emphasis>nicht</emphasis>
	    begrenzt.  Der Wert dieser Variablen legt neben der
	    möglichen Anzahl der Prozesse eines Benutzers weitere
	    sinnvolle Größen für bestimmte Systemtabellen fest.</para>
	</note>
      </sect3>

      <sect3>
	<title><varname>kern.ipc.somaxconn</varname></title>

	<indexterm>
	  <primary><varname>kern.ipc.somaxconn</varname></primary>
	</indexterm>

	<para>Die Variable <varname>kern.ipc.somaxconn</varname>
	  beschränkt die Größe der Warteschlange
	  (<foreignphrase>Listen-Queue</foreignphrase>) für
	  neue TCP-Verbindungen.  Der Vorgabewert von
	  <literal>128</literal> ist normalerweise zu klein, um neue
	  Verbindungen auf einem stark ausgelasteten Webserver
	  zuverlässig zu handhaben.  Auf solchen Servern sollte
	  der Wert auf <literal>1024</literal> oder höher gesetzt
	  werden.  Ein Dienst (z.B. &man.sendmail.8;, oder
	  <application>Apache</application>) kann die Größe
	  der Queue selbst einschränken.  Oft gibt es die
	  Möglichkeit, die Größe der Listen-Queue in
	  einer Konfigurationsdatei einzustellen.  Eine große
	  Listen-Queue übersteht vielleicht auch einen
	  Denial of Service Angriff (<abbrev>DoS</abbrev>).</para>
      </sect3>
    </sect2>
    <sect2 xml:id="nmbclusters">
      <title>Netzwerk Limits</title>

      <para>Die Kerneloption <literal>NMBCLUSTERS</literal> schreibt
	die Anzahl der Netzwerkpuffer (Mbufs) fest, die das System
	besitzt.  Eine zu geringe Anzahl Mbufs auf einem Server mit
	viel Netzwerkverkehr verringert die Leistung von &os;.  Jeder
	Mbuf-Cluster nimmt ungefähr 2&nbsp;kB Speicher in Anspruch, so
	dass ein Wert von 1024 insgesamt 2&nbsp;Megabyte Speicher für
	Netzwerkpuffer im System reserviert.  Wie viele Cluster
	benötigt werden, lässt sich durch eine einfache Berechnung
	herausfinden.  Ein Webserver, der maximal 1000 gleichzeitige
	Verbindungen servieren soll, wobei jede der Verbindungen einen
	6&nbsp;kB großen Sendepuffer und einen 16&nbsp;kB großen
	Empfangspuffer benötigt, braucht ungefähr 32&nbsp;MB Speicher
	für Netzwerkpuffer.  Als Daumenregel verdoppeln Sie diese
	Zahl, so dass sich für <varname>NMBCLUSTERS</varname> der Wert
	2x32&nbsp;MB&nbsp;/&nbsp;2&nbsp;kB&nbsp;= 32768 ergibt.
	Für Maschinen mit viel Speicher werden Werte zwischen
	4096 und 32768 empfohlen.  Unter keinen Umständen sollten Sie
	diesen Wert willkürlich erhöhen, da dies zu einem Absturz beim
	Systemstart führen kann.  Verwenden Sie &man.netstat.1; mit
	<option>-m</option> um den Gebrauch der Netzwerkpuffer zu
	kontrollieren.</para>

      <para>Die Netzwerkpuffer können beim Systemstart mit der
	Loader-Variablen <varname>kern.ipc.nmbclusters</varname>
	eingestellt werden.  Nur auf älteren &os;-Systemen
	müssen Sie die Kerneloption <literal>NMBCLUSTERS</literal>
	verwenden.</para>

      <para>Die Anzahl der &man.sendfile.2; Puffer muss auf
	ausgelasteten Servern, die den Systemaufruf &man.sendfile.2;
	oft verwenden, vielleicht erhöht werden.  Dazu können Sie die
	Kerneloption <literal>NSFBUFS</literal> verwenden oder die
	Anzahl der Puffer in <filename>/boot/loader.conf</filename>
	(siehe &man.loader.8;) setzen.  Die Puffer sollten erhöht
	werden, wenn Sie Prozesse im Zustand <literal>sfbufa</literal>
	sehen.  Die schreibgeschützte sysctl-Variable
	<varname>kern.ipc.nsfbufs</varname> zeigt die Anzahl
	eingerichteten Puffer im Kernel.  Der Wert dieser Variablen
	wird normalerweise von <varname>kern.maxusers</varname>
	bestimmt.  Manchmal muss die Pufferanzahl jedoch manuell
	eingestellt werden.</para>

      <important>
	<para>Auch wenn ein Socket nicht blockierend angelegt wurde,
	  kann der Aufruf von &man.sendfile.2; blockieren, um auf
	  freie <literal>struct sf_buf</literal> Puffer zu
	  warten.</para>
      </important>

      <sect3>
	<title><varname>net.inet.ip.portrange.*</varname></title>

	<indexterm>
	  <primary>net.inet.ip.portrange.*</primary>
	</indexterm>

	<para>Die sysctl-Variable
	  <varname>net.inet.ip.portrange.*</varname> legt die
	  Portnummern für TCP- und UDP-Sockets fest.  Es gibt drei
	  Bereiche: den niedrigen Bereich, den normalen Bereich und
	  den hohen Bereich.  Die meisten Netzprogramme benutzen den
	  normalen Bereich.  Dieser Bereich umfasst in der
	  Voreinstellung die Portnummern 500 bis 5000 und wird durch
	  die Variablen <varname>net.inet.ip.portrange.first</varname>
	  und <varname>net.inet.ip.portrange.last</varname>
	  festgelegt.  Die festgelegten Bereiche für Portnummern
	  werden von ausgehenden Verbindungen benutzt.  Unter
	  bestimmten Umständen, beispielsweise auf stark ausgelasteten
	  Proxy-Servern, sind alle Portnummern für ausgehende
	  Verbindungen belegt.  Bereiche
	  für Portnummern spielen auf Servern keine Rolle, die
	  hauptsächlich eingehende Verbindungen verarbeiten (wie ein
	  normaler Webserver) oder nur eine begrenzte Anzahl
	  ausgehender Verbindungen öffnen (beispielsweise ein
	  Mail-Relay).  Wenn keine freien Portnummern mehr vorhanden
	  sind, sollte die Variable
	  <varname>net.inet.ip.portrange.last</varname> langsam
	  erhöht werden.  Ein Wert von <literal>10000</literal>,
	  <literal>20000</literal> oder <literal>30000</literal> ist
	  angemessen.  Beachten Sie auch eine vorhandene Firewall,
	  wenn Sie die Bereiche für Portnummern ändern.  Einige
	  Firewalls sperren große Bereiche (normalerweise aus den
	  kleinen Portnummern) und erwarten, dass hohe Portnummern für
	  ausgehende Verbindungen verwendet werden.  Daher kann es
	  erforderlich sein, den Wert von
	  <varname>net.inet.ip.portrange.first</varname> zu
	  erhöhen.</para>
      </sect3>

      <sect3>
	<title>TCP Bandwidth Delay Product Begrenzung</title>

	<indexterm>
	  <primary>TCP Bandwidth Delay Product Begrenzung</primary>
	  <secondary>
	    <varname>net.inet.tcp.inflight.enable</varname>
	  </secondary>
	</indexterm>

	<para>Die TCP Bandwidth Delay Product Begrenzung gleicht
	  TCP/Vegas von NetBSD.  Die
	  Begrenzung wird aktiviert, indem Sie die sysctl-Variable
	  <varname>net.inet.tcp.inflight.enable</varname> auf den
	  Wert <literal>1</literal> setzen.  Das System wird dann
	  versuchen, für jede Verbindung, das Produkt aus der
	  Übertragungsrate und der Verzögerungszeit zu
	  bestimmen.  Dieses Produkt begrenzt die Datenmenge, die
	  für einen optimales Durchsatz zwischengespeichert
	  werden muss.</para>

	<para>Diese Begrenzung ist nützlich, wenn Sie Daten
	  über Verbindungen mit einem hohen Produkt aus
	  Übertragungsrate und Verzögerungszeit wie Modems,
	  Gigabit-Ethernet oder schnellen WANs, zur Verfügung
	  stellen.  Insbesondere wirkt sich die Begrenzung aus, wenn
	  die Verbindung die TCP-Option
	  <foreignphrase>Window-scaling</foreignphrase> verwendet oder
	  große Sende-Fenster
	  (<foreignphrase>send window</foreignphrase>) benutzt.
	  Schalten Sie die Debug-Meldungen aus, wenn Sie die
	  Begrenzung aktiviert haben.  Dazu setzen Sie die Variable
	  <varname>net.inet.tcp.inflight.debug</varname> auf
	  <literal>0</literal>.  Auf Produktions-Systemen sollten Sie
	  zudem die Variable
	  <varname>net.inet.tcp.inflight.min</varname> mindestens auf
	  den Wert <literal>6144</literal> setzen.  Allerdings kann
	  ein zu hoher Wert, abhängig von der Verbindung, die
	  Begrenzungsfunktion unwirksam machen.  Die Begrenzung
	  reduziert die Datenmenge in den Queues von Routern und
	  Switches, sowie die Datenmenge in der Queue der lokalen
	  Netzwerkkarte.  Die Verzögerungszeit
	  (<foreignphrase>Round Trip Time</foreignphrase>) für
	  interaktive Anwendungen sinkt, da weniger Pakete
	  zwischengespeichert werden.  Dies gilt besonders für
	  Verbindungen über langsame Modems.  Die Begrenzung
	  wirkt sich allerdings nur auf das Versenden von Daten aus
	  (Uploads, Server).  Auf den Empfang von Daten (Downloads)
	  hat die Begrenzung keine Auswirkungen.</para>

	<para>Die Variable
	  <varname>net.inet.tcp.inflight.stab</varname> sollte
	  <emphasis>nicht</emphasis> angepasst werden.  Der
	  Vorgabewert der Variablen beträgt <literal>20</literal>,
	  das heißt es werden maximal zwei Pakete zu dem Produkt
	  aus Übertragungsrate und Verzögerungszeit addiert.
	  Dies stabilisiert den Algorithmus und verbessert die
	  Reaktionszeit auf Veränderungen.  Bei langsamen
	  Verbindungen können sich aber die Laufzeiten der Pakete
	  erhöhen (ohne diesen Algorithmus wären sie allerdings noch
	  höher).  In solchen Fällen können Sie versuchen, den Wert
	  der Variablen auf <literal>15</literal>,
	  <literal>10</literal> oder <literal>5</literal>
	  herabzusetzten.  Gleichzeitig müssen Sie vielleicht auch
	  <varname>net.inet.tcp.inflight.min</varname> auf einen
	  kleineren Wert (beispielsweise <literal>3500</literal>)
	  setzen.  Ändern Sie diese Variablen nur ab, wenn Sie
	  keine anderen Möglichkeiten mehr haben.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Virtueller Speicher (<foreignphrase>Virtual
	Memory</foreignphrase>)</title>

      <sect3>
	<title><varname>kern.maxvnodes</varname></title>

	<para>Ein vnode ist die interne Darstellung einer Datei oder
	  eines Verzeichnisses.  Die Erhöhung der Anzahl der für das
	  Betriebssystem verfügbaren vnodes verringert also die
	  Schreib- und Lesezugriffe auf Ihre Festplatte.  vnodes
	  werden im Normalfall vom Betriebssystem automatisch vergeben
	  und müssen nicht von Ihnen angepasst werden.  In einigen
	  Fällen stellt der Zugriff auf eine Platte allerdings einen
	  Flaschenhals dar, daher sollten Sie in diesem Fall die
	  Anzahl der möglichen vnodes erhöhen, um dieses Problem zu
	  beheben.  Beachten Sie dabei aber die Größe des inaktiven
	  und freien Hauptspeichers.</para>

	<para>Um die Anzahl der derzeit verwendeten vnodes zu sehen,
	  geben Sie Folgendes ein:</para>

	<screen>&prompt.root; <userinput>sysctl vfs.numvnodes</userinput>
vfs.numvnodes: 91349</screen>

	<para>Die maximal mögliche Anzahl der vnodes erhalten
	   Sie durch die Eingabe von:</para>

	<screen>&prompt.root; <userinput>sysctl kern.maxvnodes</userinput>
kern.maxvnodes: 100000</screen>

	<para>Wenn sich die Anzahl der genutzten vnodes dem maximal
	  möglichen Wert nähert, sollten Sie den Wert
	  <varname>kern.maxvnodes</varname> zuerst um etwa 1.000
	  erhöhen.  Beobachten Sie danach die Anzahl der vom
	  System genutzten <varname>vfs.numvnodes</varname>.
	  Nähert sich der Wert wiederum dem definierten
	  Maximum, müssen Sie <varname>kern.maxvnodes</varname>
	  nochmals erhöhen.  Sie sollten nun eine Änderung
	  Ihres Speicherverbrauches (etwa über &man.top.1;)
	  registrieren können und über mehr aktiven
	  Speicher verfügen.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="adding-swap-space">
    <title>Hinzufügen von Swap-Bereichen</title>

    <para>Egal wie vorausschauend Sie planen, manchmal entspricht ein
      System einfach nicht den Erwartungen.  Es ist leicht, mehr
      Swap-Bereiche hinzuzufügen.  Dazu stehen drei Wege
      offen:  Sie können eine neue Platte einbauen, den Swap-Bereich
      über NFS ansprechen oder eine Swap-Datei auf einer existierenden
      Partition einrichten.</para>

    <para>Für Informationen zur Verschlüsselung von
      Swap-Partitionen, zu den dabei möglichen Optionen sowie
      zu den Gründen für eine Verschlüsselung des
      Auslagerungsspeichers lesen Sie
      <xref linkend="swap-encrypting"/> des Handbuchs.</para>

    <sect2 xml:id="new-drive-swap">
      <title>Swap auf einer neuen oder existierenden
	Festplatte</title>

      <para>Das Hinzufügen einer neuen Festplatte für Swap-Bereich
	bietet eine bessere Leistung, als das Hinzufügen
	einer Partition auf einem vorhandenem Laufwerk.  Die
	Einrichtung von Partitionen und Laufwerken wird in
	<xref linkend="disks-adding"/> beschrieben.
	<xref linkend="configtuning-initial"/> diskutiert Aspekte über
	die Anordnung und Größe von Swap-Bereichen.</para>

      <para>Benutzen Sie &man.swapon.8; um eine Swap-Partition zum
	System hinzuzufügen.  Zum Beispiel:</para>

      <screen>&prompt.root; <userinput>swapon<replaceable>
/dev/ada1s1b</replaceable></userinput></screen>

      <warning>
	<para>Sie können jede Partition verwenden, sofern sie nicht
	  schon eingehangen ist.  Das gilt auch dann, wenn die
	  Partition bereits Daten enthält.  Wird &man.swapon.8; auf
	  einer Partition ausgeführt die noch Daten enthält, werden
	  die vorhandenen Daten überschrieben und sind unweigerlich
	  verloren.  Stellen Sie sicher, das die Partition, die Sie
	  als Swap-Bereich hinzufügen möchten, wirklich die gewünschte
	  Partition ist, bevor sie &man.swapon.8; ausführen.</para>
      </warning>

      <para>Um diese Swap-Partition automatisch beim Systemstart
	hinzuzufügen, fügen Sie einen Eintrag für die Partition in
	<filename>/etc/fstab</filename> hinzu:</para>

      <programlisting><replaceable>/dev/ada1s1b</replaceable>	none	swap	sw	0	0</programlisting>

      <para>Die einzelnen Einträge von <filename>/etc/fstab</filename>
	werden in &man.fstab.5; erläutert.</para>
    </sect2>

    <sect2 xml:id="nfs-swap">
      <title>Swap-Bereiche über NFS</title>

      <para>Swap-Bereiche über NFS sollten Sie nur dann einsetzen,
	wenn Sie über keine lokale Platte verfügen, da es durch
	die zur Verfügung stehende Bandbreite limitiert wird und
	außerdem den NFS-Server zusätzlich belastet.</para>
    </sect2>

    <sect2 xml:id="create-swapfile">
      <title>Swap-Dateien</title>

      <para>Sie können eine Datei festgelegter Größe als Swap-Bereich
	nutzen.  Im folgenden Beispiel wird eine 64&nbsp;MB große
	Datei mit dem Namen <filename>/usr/swap0</filename>
	benutzt.</para>

      <example>
	<title>Erstellen einer Swap-Datei</title>

	<orderedlist>
	  <listitem>
	    <para>Der <filename>GENERIC</filename>-Kernel unterstützt
	      bereits RAM-Disks (&man.md.4;), welche für diese Aktion
	      benötigt werden.  Wenn Sie einen eigenen Kernel
	      erstellen, vergewissern Sie sich, dass die folgende
	      Zeile in der Kernelkonfigurationsdatei enthalten
	      ist:</para>

	    <programlisting>device   md</programlisting>

	    <para>Informationen, wie man einen eigenen Kernel
	      erstellen kann, erhalten Sie in
	      <xref linkend="kernelconfig"/>.</para>
	  </listitem>

	  <listitem>
	    <para>Legen Sie die Swap-Datei
	      <filename>/usr/swap0</filename> an:</para>

	    <screen>&prompt.root; <userinput>dd if=/dev/zero of=/usr/swap0 bs=1024k count=64</userinput></screen>
	  </listitem>

	  <listitem>
	    <para>Setzen Sie die richtigen Berechtigungen für
	      <filename>/usr/swap0</filename>:</para>

	    <screen>&prompt.root; <userinput>chmod 0600 /usr/swap0</userinput></screen>
	  </listitem>

	  <listitem>
	    <para>Aktivieren Sie die Swap-Datei
	      <filename>/etc/rc.conf</filename>:</para>

	    <programlisting>swapfile="/usr/swap0"   # Set to name of swapfile if aux swapfile desired.</programlisting>
	  </listitem>

	  <listitem>
	    <para>Um die Swap-Datei zu aktivieren, führen Sie entweder
	      einen Neustart durch oder geben das folgende Kommando
	      ein:</para>

	    <screen>&prompt.root; <userinput>mdconfig -a -t vnode -f /usr/swap0 -u 0 &amp;&amp; swapon /dev/md0</userinput></screen>
	  </listitem>
	</orderedlist>
      </example>
    </sect2>
  </sect1>

  <sect1 xml:id="acpi-overview">
    <info>
      <title>Energie- und Ressourcenverwaltung</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Hiten</firstname>
	    <surname>Pandya</surname>
	  </personname>
	  <contrib>Verfasst von </contrib>
	</author>
	<author>
	  <personname>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	  </personname>
	</author>
      </authorgroup>
    </info>

    <para>Es ist wichtig, Hardware effizient einzusetzen.  Vor der
      Einführung des <firstterm>Advanced Configuration and Power
      Interface</firstterm> (<acronym>ACPI</acronym>) konnten
      Stromverbrauch und Wärmeabgabe eines Systems nur
      schlecht von Betriebssystemen gesteuert werden.  Die Hardware
      wurde vom <acronym>BIOS</acronym> gesteuert, was die Kontrolle
      der Energieverwaltung für den Anwender erschwerte.  Das
      <emphasis>Advanced Power Management (APM)</emphasis> erlaubte
      es lediglich, einige wenige Funktionen zu steuern, obwohl die
      Überwachung von Energie- und Ressourcenverbrauch zu den
      wichtigsten Aufgaben eines Betriebssystems gehört, um auf
      verschiedene Ereignisse, beispielsweise einen unerwarteten
      Temperaturanstieg, reagieren können.</para>

    <para>Dieser Abschnitt erklärt das Advanced Configuration and
      Power Interface (<acronym>ACPI</acronym>).</para>

    <sect2 xml:id="acpi-intro">
      <title>Was ist ACPI?</title>

      <indexterm>
	<primary>ACPI</primary>
      </indexterm>

      <indexterm>
	<primary>APM</primary>
      </indexterm>

      <para>Advanced Configuration and Power Interface
	(<acronym>ACPI</acronym>) ist ein Standard verschiedener
	Hersteller, der die Verwaltung von Hardware und
	Energiesparfunktionen festlegt.  Die
	<acronym>ACPI</acronym>-Funktionen können von einem
	Betriebssystem gesteuert werden.  Der Vorgänger des
	<acronym>ACPI</acronym>, <acronym>APM</acronym>, erwies sich
	in modernen Systemen als unzureichend.</para>
    </sect2>

    <sect2 xml:id="acpi-old-spec">
      <title>Mängel des Advanced Power Managements (APM)</title>

      <para>Das <emphasis><acronym>APM</acronym></emphasis>
	steuert den Energieverbrauch eines Systems auf Basis
	der Systemaktivität.  Das APM-BIOS wird von dem
	Hersteller des Systems zur Verfügung gestellt
	und ist auf die spezielle Hardware angepasst.  Der
	APM-Treiber des Betriebssystems greift auf das
	<emphasis>APM Software Interface</emphasis> zu, das den
	Energieverbrauch regelt.  APM findet sich in der Regel
	nur noch in Systemen, die vor 2001 produziert
	wurden.</para>

      <para>Das <acronym>APM</acronym> hat hauptsächlich
	vier Probleme.  Erstens läuft die Energieverwaltung
	unabhängig vom Betriebssystem in einem
	(herstellerspezifischen) BIOS.  Beispielsweise kann
	das APM-BIOS die Festplatten nach einer konfigurierbaren
	Zeit ohne die Zustimmung des Betriebssystems herunterfahren.
	Zweitens befindet sich die ganze APM-Logik im BIOS;  das
	Betriebssystem hat gar keine APM-Komponenten.  Bei Problemen
	mit dem APM-BIOS muss das Flash-ROM aktualisiert werden.
	Diese Prozedur ist gefährlich, da sie im Fehlerfall
	das System unbrauchbar machen kann.  Zum Dritten ist APM
	eine Technik, die herstellerspezifisch ist und nicht
	koordiniert wird.  Fehler im BIOS eines Herstellers werden
	nicht unbedingt im BIOS anderer Hersteller korrigiert.
	Das letzte Problem ist, dass im APM-BIOS nicht genügend
	Platz vorhanden ist, um eine durchdachte oder eine auf den
	Zweck der Maschine zugeschnittene Energieverwaltung
	zu implementieren.</para>

      <para>Das <emphasis>Plug and Play BIOS (PNPBIOS)</emphasis>
	war ebenfalls unzureichend.  Das PNPBIOS verwendet eine
	16-Bit-Technik.  Damit das Betriebssystem das PNPBIOS
	ansprechen kann, muss es in einer 16-Bit-Emulation
	laufen.</para>

      <para>Der <acronym>APM</acronym>-Treiber von &os; ist in
	der Hilfeseite &man.apm.4; beschrieben.</para>
    </sect2>

    <sect2 xml:id="acpi-config">
      <title>Konfiguration des <acronym>ACPI</acronym></title>

      <para>Das Modul <filename>acpi.ko</filename> wird
	standardmäßig beim Systemstart vom &man.loader.8;
	geladen und sollte daher <emphasis>nicht</emphasis>
	fest in den Kernel eingebunden werden.  Dadurch kann
	<filename>acpi.ko</filename> ohne einen Neubau des Kernels
	ersetzt werden und das Modul ist leichter zu testen.  Wenn Sie
	in der Ausgabe von &man.dmesg.8; das Wort
	<acronym>ACPI</acronym> sehen, ist das Modul geladen worden.
	Das ACPI-Modul im laufenden Betrieb zu laden, führt oft nicht
	zum gewünschten Ergebnis.  Treten bei Ihrem System Probleme
	auf, kann <acronym>ACPI</acronym> auch komplett
	deaktiviert werden.  Dazu definieren Sie die Variable
	<literal>hint.acpi.0.disabled="1"</literal> in der Datei
	<filename>/boot/loader.conf</filename>.  Alternativ können
	Sie die Variable auch am &man.loader.8;-Prompt eingeben.
	Das Modul kann im laufenden Betrieb nicht entfernt werden,
	da es zur Kommunikation mit der Hardware verwendet
	wird.</para>

      <note>
	<para><acronym>ACPI</acronym> und <acronym>APM</acronym>
	  können nicht zusammen verwendet werden.  Das zuletzt
	  geladene Modul beendet sich, sobald es bemerkt, dass das
	  andere Modul geladen ist.</para>
      </note>

      <para>Mit &man.acpiconf.8; können Sie das System in einen
	Ruhemodus (<foreignphrase>sleep mode</foreignphrase>)
	versetzen.  Es gibt verschiedene Modi
	(von <literal>1</literal> bis <literal>5</literal>), die Sie
	auf der Kommandozeile mit <option>-s</option> angeben können.
	Für die meisten Anwender sind die Modi <literal>1</literal>
	und <literal>3</literal> völlig ausreichend.  Der Modus
	<literal>5</literal> schaltet das System
	aus (<foreignphrase>Soft-off</foreignphrase>) und entspricht
	dem folgenden Befehl:</para>

      <screen>&prompt.root; <userinput>halt -p</userinput></screen>

      <para>Verschiedene Optionen können als
	&man.sysctl.8;-Variablen gesetzt werden.  Lesen Sie dazu
	die Manualpages zu &man.acpi.4; sowie &man.acpiconf.8;.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="ACPI-debug">
    <info>
      <title><acronym>ACPI</acronym>-Fehlersuche</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Nate</firstname>
	    <surname>Lawson</surname>
	  </personname>
	  <contrib>Verfasst von </contrib>
	</author>
      </authorgroup>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Peter</firstname>
	    <surname>Schultz</surname>
	  </personname>
	  <contrib>Mit Beiträgen von </contrib>
	</author>
	<author>
	  <personname>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	  </personname>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>ACPI</primary>
      <secondary>Probleme mit</secondary>
    </indexterm>

    <para><acronym>ACPI</acronym> ist ein gänzlich neuer
      Weg, um Geräte aufzufinden und deren Stromverbrauch
      zu regulieren.  Weiterhin bietet <acronym>ACPI</acronym>
      einen einheitlichen Zugriff auf Geräte, die vorher
      vom <acronym>BIOS</acronym> verwaltet wurden.  Es werden
      zwar Fortschritte gemacht, dass <acronym>ACPI</acronym>
      auf allen Systemen läuft, doch tauchen immer wieder
      Fehler auf:  fehlerhafter Bytecode der
      <acronym>ACPI</acronym>-Machine-Language
      (<acronym>AML</acronym>) einiger Systemplatinen,
      ein unvollständiges &os;-Kernel-Subsystem oder
      Fehler im <acronym>ACPI-CA</acronym>-Interpreter
      von &intel;.</para>

    <para>Dieser Abschnitt hilft Benutzern, zusammen mit den Betreuern
      des &os;-<acronym>ACPI</acronym>-Subsystems, Fehlerquellen
      zu finden und Fehler zu beseitigen.</para>

    <sect2 xml:id="ACPI-submitdebug">
      <title>Fehlerberichte einreichen</title>

      <note>
	<para>Bevor Sie einen Fehlerbericht einreichen, stellen
	  Sie bitte sicher, dass Ihr <acronym>BIOS</acronym>
	  und die Firmware Ihres Controllers aktuell sind.</para>
      </note>

      <para>Wenn Sie einen Fehlerbericht einsenden wollen,
	schicken Sie bitte die folgenden Informationen an
	die Mailingliste <link xlink:href="mailto:freebsd-acpi@FreeBSD.org">freebsd-acpi</link>:</para>

      <itemizedlist>
	<listitem>
	  <para>Beschreiben Sie den Fehler und alle Umstände,
	    unter denen der Fehler auftritt.  Geben Sie
	    ebenfalls den Typ und das Modell Ihres Systems
	    an.  Wenn Sie einen neuen Fehler entdeckt haben,
	    versuchen Sie möglichst genau zu beschreiben,
	    wann der Fehler das erste Mal aufgetreten ist.</para>
	</listitem>

	<listitem>
	  <para>Die Ausgabe von &man.dmesg.8; nach der Eingabe
	    von <command>boot -v</command>.
	    Geben Sie auch alle Fehlermeldungen an, die erscheinen,
	    wenn Sie den Fehler provozieren.</para>
	</listitem>

	<listitem>
	  <para>Die Ausgabe von &man.dmesg.8; nach der Eingabe
	    von <command>boot -v</command> und mit deaktiviertem
	    <acronym>ACPI</acronym>, wenn das Problem ohne
	    <acronym>ACPI</acronym> nicht auftritt.</para>
	</listitem>

	<listitem>
	  <para>Die Ausgabe von <command>sysctl hw.acpi</command>.
	    Dieses Kommando zeigt die vom System unterstützten
	    <acronym>ACPI</acronym>-Funktionen an.</para>
	</listitem>

	<listitem>
	  <para>Die <acronym>URL</acronym>, unter der die
	    <acronym>ACPI</acronym>-Source-Language
	    (<acronym>ASL</acronym>) liegt.  Schicken Sie
	    bitte <emphasis>nicht</emphasis> die
	    <acronym>ASL</acronym> an die Mailingliste, da die
	    <acronym>ASL</acronym> sehr groß sein kann.  Eine Kopie
	    der <acronym>ASL</acronym> erstellen Sie mit dem
	    nachstehenden Befehl:</para>

	  <screen>&prompt.root; <userinput>acpidump -td &gt; name-system.asl</userinput></screen>

	  <para>Setzen Sie bitte für <replaceable>name</replaceable>
	    den Namen Ihres Kontos und für
	    <replaceable>system</replaceable> den Hersteller und
	    das Modell Ihres Systems ein.  Zum Beispiel:
	    <filename>njl-FooCo6000.asl</filename>.</para>
	</listitem>
      </itemizedlist>

      <para>Obwohl die meisten Entwickler die Mailingliste
	&a.current.name; lesen, sollten Sie Fehlerberichte an
	die Liste &a.acpi.name; schicken.  Seien Sie bitte
	geduldig;  wir haben alle Arbeit außerhalb des Projekts.
	Wenn der Fehler nicht offensichtlich ist, bitten
	wir Sie vielleicht, einen offiziellen Fehlerbericht
	(<acronym>PR</acronym>) mit &man.send-pr.1; einzusenden.
	Geben Sie im Fehlerbericht bitte dieselben Informationen
	wie oben an.  Mithilfe der <acronym>PR</acronym>s
	verfolgen und lösen wir Probleme.  Senden Sie
	bitte keinen <acronym>PR</acronym> ein, ohne vorher
	den Fehlerbericht an die Liste &a.acpi.name; zu senden.
	Es kann sein, dass der Fehler schon von
	jemand anderem gemeldet wurde.</para>
    </sect2>

    <sect2 xml:id="ACPI-background">
      <title><acronym>ACPI</acronym>-Grundlagen</title>

      <indexterm>
	<primary>ACPI</primary>
      </indexterm>

      <para><acronym>ACPI</acronym> gibt es in allen modernen Rechnern
	der ia32- (x86), ia64- (Itanium) und amd64- (AMD) Architektur.
	Der vollständige Standard bietet Funktionen zur Steuerung und
	Verwaltung der <acronym>CPU</acronym>-Leistung, der
	Stromversorgung, von Wärmebereichen, Batterien, eingebetteten
	Controllern und Bussen.  Auf den meisten Systemen wird nicht
	der vollständige Standard implementiert.  Arbeitsplatzrechner
	besitzen meist nur Funktionen zur Verwaltung der Busse,
	während Notebooks Funktionen zur Temperaturkontrolle und
	Ruhezustände besitzen.</para>

      <para>Ein <acronym>ACPI</acronym> konformes System besitzt
	verschiedene Komponenten.  Die <acronym>BIOS</acronym>- und
	Chipsatz-Hersteller stellen mehrere statische Tabellen bereit
	(zum Beispiel die
	Fixed-<acronym>ACPI</acronym>-Description-Table,
	<acronym>FADT</acronym>).  Die Tabellen enthalten
	beispielsweise die mit <acronym>SMP</acronym>-Systemen
	benutzte <acronym>APIC</acronym>-Map, Konfigurationsregister
	und einfache Konfigurationen.  Zusätzlich gibt es die
	Differentiated-System-Description-Table
	(<acronym>DSDT</acronym>), die Bytecode enthält.  Die Tabelle
	ordnet Geräte und Methoden in einem baumartigen Namensraum
	an.</para>

      <para>Ein <acronym>ACPI</acronym>-Treiber muss die statischen
	Tabellen einlesen, einen Interpreter für den Bytecode
	bereitstellen und die Gerätetreiber im Kernel so
	modifizieren, dass sie mit dem
	<acronym>ACPI</acronym>-Subsystem kommunizieren.  Für &os;,
	Linux und NetBSD hat &intel; den Interpreter
	<acronym>ACPI-CA</acronym>, zur Verfügung gestellt.  Der
	Quelltext zu <acronym>ACPI-CA</acronym> befindet sich im
	Verzeichnis <filename>src/sys/contrib/dev/acpica</filename>.
	Die Schnittstelle von <acronym>ACPI-CA</acronym> zu &os;
	befindet sich unter
	<filename>src/sys/dev/acpica/Osd</filename>.  Treiber, die
	verschiedene <acronym>ACPI</acronym>-Geräte implementieren,
	befinden sich im Verzeichnis
	<filename>src/sys/dev/acpica</filename>.</para>
    </sect2>

    <sect2 xml:id="ACPI-comprob">
      <title>Häufige Probleme</title>

      <indexterm>
	<primary>ACPI</primary>
	<secondary>Probleme mit</secondary>
      </indexterm>

      <para>Damit <acronym>ACPI</acronym> richtig funktioniert,
	müssen alle Teile funktionieren.  Im Folgenden
	finden Sie eine Liste mit Problemen und möglichen
	Umgehungen oder Fehlerbehebungen.  Die Liste ist nach
	der Häufigkeit, mit der die Probleme auftreten,
	sortiert.</para>

      <sect3>
	<title>Mausprobleme</title>

	<para>Es kann vorkommen, dass die Maus nicht mehr
	  funktioniert, wenn Sie nach einem Suspend weiterarbeiten
	  wollen.  Ist dies bei Ihnen der Fall, reicht es meistens
	  aus, den Eintrag
	  <literal>hint.psm.0.flags="0x3000"</literal> in
	  <filename>/boot/loader.conf</filename> aufzunehmen.  Besteht
	  das Problem weiterhin, sollten Sie einen Fehlerbericht
	  senden.</para>
      </sect3>

      <sect3>
	<title>Suspend/Resume</title>

	<para><acronym>ACPI</acronym> kennt drei
	  Suspend-to-<acronym>RAM</acronym>-Zustände
	  (<acronym>STR</acronym>):
	  <literal>S1</literal>-<literal>S3</literal>.
	  Es gibt einen Suspend-to-Disk-Zustand (<acronym>STD</acronym>):
	  <literal>S4</literal>.  Der Zustand <literal>S5</literal>
	  wird Soft-Off genannt.  In diesem Zustand befindet
	  sich ein Rechner, wenn die Stromversorgung angeschlossen
	  ist, der Rechner aber nicht hochgefahren ist.  Der
	  Zustand <literal>S4</literal> kann auf zwei Arten
	  implementiert werden:
	  <literal>S4</literal><acronym>BIOS</acronym> und
	  <literal>S4</literal><acronym>OS</acronym>.
	  Im ersten Fall wird der Suspend-to-Disk-Zustand durch
	  das <acronym>BIOS</acronym> hergestellt im zweiten
	  Fall alleine durch das Betriebssystem.</para>

	<note>
	  <para>Die Suspend-Zustände sind Ruhezustände,
	    in denen der Rechner weniger Energie als im
	    Normalbetrieb benötigt.  Resume bezeichnet
	    die Rückkehr zum Normalbetrieb.</para>
	</note>

	<para>Die Suspend-Zustände können Sie mit
	  dem Kommando <command>sysctl hw.acpi</command>
	  ermitteln.  Das Folgende könnte beispielsweise
	  ausgegeben werden:</para>

	<screen>hw.acpi.supported_sleep_state: S3 S4 S5
hw.acpi.s4bios: 0</screen>

	<para>Diese Ausgabe besagt, dass mit dem Befehl
	  <command>acpiconf -s</command> die Zustände
	  <literal>S3</literal>, <literal>S4</literal><acronym>OS</acronym>
	  und <literal>S5</literal> eingestellt werden können.
	  Hätte <option>s4bios</option> den Wert
	  <literal>1</literal>, gäbe es den Zustand
	  <literal>S4</literal><acronym>BIOS</acronym> anstelle
	  von <literal>S4</literal><acronym>OS</acronym>.</para>

	<para>Wenn Sie die Suspend- und Resume-Funktionen
	  testen, fangen Sie mit dem <literal>S1</literal>-Zustand
	  an, wenn er angeboten wird.  Dieser Zustand wird
	  am ehesten funktionieren, da der Zustand wenig
	  Treiber-Unterstützung benötigt.  Der Zustand
	  <literal>S2</literal> ist ähnlich wie
	  <literal>S1</literal>, allerdings hat ihn noch niemand
	  implementiert.  Als nächstes sollten Sie den
	  Zustand <literal>S3</literal> ausprobieren.  Dies
	  ist der tiefste <acronym>STR</acronym>-Schlafzustand.
	  Dieser Zustand ist auf massive Treiber-Unterstützung
	  angewiesen, um die Geräte wieder richtig zu
	  initialisieren.  Wenn Sie Probleme mit diesem Zustand
	  haben, können Sie die Mailingliste
	  &a.acpi.name; anschreiben.  Erwarten Sie allerdings
	  nicht zu viel:  Es gibt viele Treiber und Geräte,
	  an denen noch gearbeitet und getestet wird.</para>

	<para>Ein häufiges Problem mit Suspend/Resume ist,
	  dass viele Gerätetreiber ihre Firmware, Register
	  und Gerätespeicher nicht korrekt speichern,
	  wiederherstellen und/oder reinitialisieren.  Um dieses
	  Problem zu lösen, sollten Sie zuerst die
	  folgenden Befehle ausführen:</para>

	<screen>&prompt.root; <userinput>sysctl debug.bootverbose=1</userinput>
&prompt.root; <userinput>sysctl debug.acpi.suspend_bounce=1</userinput>
&prompt.root; <userinput>acpiconf -s 3</userinput></screen>

	<para>Dieser Test emuliert einen Suspend/Resume-Zyklus für
	  alle Geräte (ohne dass diese dabei wirklich in den Status
	  <literal>S3</literal> wechseln).  In vielen Fällen
	  reicht dies bereits aus, um Probleme (beispielsweise
	  verlorener Firmware-Status, Timeouts, hängende Geräte)
	  zu entdecken.  Beachten Sie dabei, dass das Gerät bei
	  diesem Test nicht wirklich in den Status
	  <literal>S3</literal> wechseln.  Es kann also vorkommen,
	  dass manche Geräte weiterhin mit Strom versorgt werden (dies
	  wäre bei einem wirklichen Wechsel in den Status
	  <literal>S3</literal> NICHT möglich.
	  Andere Geräte werden normal weiterarbeiten, weil sie
	  über keine Suspend/Resume-Funktionen verfügen.</para>

	<para>Schwierigere Fälle können den Einsatz
	  zusätzlicher Hardware (beispielsweise serielle
	  Ports/Kabel für die Verbindung über eine
	  serielle Konsole oder Firewire-Ports/Kabel für
	  &man.dcons.4;) sowie Kenntnisse im Bereich
	  Kerneldebugging erforderlich machen.</para>

	<para>Um das Problem einzugrenzen, entfernen Sie soviele
	  Treiber wie möglich aus dem Kernel.  Sie können
	  das Problem isolieren, indem Sie einen Treiber nach
	  dem anderen laden, bis der Fehler wieder auftritt.
	  Typischerweise verursachen binäre Treiber wie
	  <filename>nvidia.ko</filename>, Grafiktreiber und
	  <acronym>USB</acronym>-Treiber die meisten Fehler,
	  hingegen laufen Ethernet-Treiber für gewöhnlich
	  sehr zuverlässig.  Wenn ein Treiber
	  zuverlässig geladen und entfernt werden kann,
	  können Sie den Vorgang automatisieren, indem
	  Sie die entsprechenden Kommandos in
	  <filename>/etc/rc.suspend</filename> und
	  <filename>/etc/rc.resume</filename> einfügen.
	  In den Dateien finden Sie ein deaktiviertes Beispiel,
	  das einen Treiber lädt und wieder entfernt.
	  Ist die Bildschirmanzeige bei der Wiederaufnahme
	  des Betriebs gestört, setzen Sie die
	  Variable <option>hw.acpi.reset_video</option> auf
	  <literal>0</literal>.  Versuchen Sie auch, die Variable
	  <option>hw.acpi.sleep_delay</option> auf kürzere
	  Zeitspannen zu setzen.</para>

	<para>Die Suspend- und Resume-Funktionen können
	  Sie auch auf einer neuen Linux-Distribution
	  mit <acronym>ACPI</acronym> testen.  Wenn es mit
	  Linux funktioniert, liegt das Problem wahrscheinlich
	  bei einem &os;-Treiber.  Es hilft uns, das Problem
	  zu lösen, wenn Sie feststellen können, welcher
	  Treiber das Problem verursacht.  Beachten Sie bitte,
	  dass die <acronym>ACPI</acronym>-Entwickler normalerweise
	  keine anderen Treiber pflegen (beispielsweise Sound- oder
	  <acronym>ATA</acronym>-Treiber).  Es ist wohl das beste,
	  die Ergebnisse der Fehlersuche an die Mailingliste
	  &a.current.name; und den Entwickler des Treibers
	  zu schicken.  Erfahrene Benutzer können versuchen, den
	  Fehler in der Resume-Funktion zu finden, indem
	  sie einige &man.printf.3;-Anweisungen in den Code
	  des fehlerhaften Treibers einfügen.</para>

	<para>Schließlich können Sie <acronym>ACPI</acronym>
	  noch abschalten und stattdessen <acronym>APM</acronym>
	  verwenden.  Wenn die Suspend- und Resume-Funktionen mit
	  <acronym>APM</acronym> funktionieren, sollten Sie
	  vielleicht besser <acronym>APM</acronym> verwenden
	  (insbesondere mit alter Hardware von vor dem Jahr 2000).
	  Die Hersteller benötigten einige Zeit, um
	  <acronym>ACPI</acronym> korrekt zu implementieren, daher
	  gibt es mit älterer Hardware oft
	  <acronym>ACPI</acronym>-Probleme.</para>
      </sect3>

      <sect3>
	<title>Temporäre oder permanente Systemhänger</title>

	<para>Die meisten Systemhänger entstehen durch verlorene
	  Interrupts oder einen Interrupt-Sturm.
	  Probleme werden verursacht durch die Art, in der das
	  <acronym>BIOS</acronym> Interrupts vor dem Systemstart
	  konfiguriert, durch eine fehlerhafte
	  <acronym>APIC</acronym>-Tabelle und durch die
	  Zustellung des System-Control-Interrupts
	  (<acronym>SCI</acronym>).</para>

	<indexterm>
	  <primary>Interrupt-Sturm</primary>
	</indexterm>

	<para>Anhand der Ausgabe des Befehls
	  <command>vmstat -i</command> können Sie verlorene
	  Interrupts von einem Interrupt-Sturm unterscheiden.
	  Untersuchen Sie die Ausgabezeile, die
	  <literal>acpi0</literal> enthält.  Ein Interrupt-Sturm liegt
	  vor, wenn der Zähler öfter als ein paar Mal pro Sekunde
	  hochgezählt wird.  Wenn sich das System aufgehangen hat,
	  versuchen Sie mit der Tastenkombination
	  <keycombo action="simul">
	    <keycap>Ctrl</keycap>
	    <keycap>Alt</keycap>
	    <keycap>Esc</keycap>
	  </keycombo> in den Debugger <acronym>DDB</acronym>
	  zu gelangen.  Geben Sie dort den Befehl
	  <literal>show interrupts</literal> ein.</para>

	<indexterm>
	  <primary>APIC</primary>
	  <secondary>deaktivieren</secondary>
	</indexterm>

	<para>Wenn Sie Interrupt-Probleme haben, ist es vorerst
	  wohl am besten, <acronym>APIC</acronym> zu deaktivieren.
	  Tragen Sie dazu die Zeile
	  <literal>hint.apic.0.disabled="1"</literal> in
	  <filename>loader.conf</filename> ein.</para>
      </sect3>

      <sect3>
	<title>Abstürze (Panics)</title>

	<para><foreignphrase>Panics</foreignphrase> werden so
	  schnell wie möglich behoben;  mit <acronym>ACPI</acronym>
	  kommt es aber selten dazu.  Zuerst sollten Sie
	  die Panic reproduzieren und dann versuchen einen
	  <foreignphrase>backtrace</foreignphrase> (eine
	  Rückverfolgung der Funktionsaufrufe) zu erstellen.
	  Richten Sie dazu den <acronym>DDB</acronym> über
	  die serielle Schnittstelle (siehe
	  <xref linkend="serialconsole-ddb"/>) oder eine gesonderte
	  &man.dump.8;-Partition ein.  In <acronym>DDB</acronym>
	  können Sie den <foreignphrase>backtrace</foreignphrase>
	  mit dem Kommando <literal>tr</literal> erstellen.
	  Falls Sie den <foreignphrase>backtrace</foreignphrase>
	  vom Bildschirm abschreiben müssen, schreiben
	  Sie bitte mindestens die fünf ersten und die
	  fünf letzten Zeile der Ausgabe auf.</para>

	<para>Versuchen Sie anschließend, das Problem
	  durch einen Neustart ohne <acronym>ACPI</acronym>
	  zu beseitigen.  Wenn das funktioniert hat, können
	  Sie versuchen, das verantwortliche
	  <acronym>ACPI</acronym>-Subsystem durch Setzen der
	  Variablen <option>debug.acpi.disable</option>
	  herauszufinden.  Die Hilfeseite &man.acpi.4; enthält
	  dazu einige Beispiele.</para>
      </sect3>

      <sect3>
	<title>Nach einem Suspend oder einem Stopp startet
	  das System wieder</title>

	<para>Setzen Sie zuerst in &man.loader.conf.5; die Variable
	  <option>hw.acpi.disable_on_poweroff</option> auf
	  <literal>0</literal>.  Damit wird verhindert, dass
	  <acronym>ACPI</acronym> während des Systemabschlusses
	  die Bearbeitung verschiedener Ereignisse deaktiviert.
	  Auf manchen Systemen muss die Variable den Wert
	  <literal>1</literal> besitzen (die Voreinstellung).
	  Normalerweise wird der unerwünschte Neustart
	  des Systems durch Setzen dieser Variablen behoben.</para>
      </sect3>

      <sect3>
	<title>Andere Probleme</title>

	<para>Wenn Sie weitere Probleme mit <acronym>ACPI</acronym>
	  haben (Umgang mit einer Docking-Station, nicht erkannte
	  Geräte), schicken Sie bitte eine Beschreibung an die
	  Mailingliste.  Allerdings kann es sein, dass einige
	  Probleme von noch unvollständigen Teilen des
	  <acronym>ACPI</acronym>-Subsystems abhängen und
	  es etwas dauern kann bis diese Teile fertig sind.
	  Seien Sie geduldig und rechnen Sie damit,
	  Fehlerbehebungen zu testen.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="ACPI-aslanddump">
      <title><acronym>ASL</acronym>, <command>acpidump</command> und
	<acronym>IASL</acronym></title>

      <indexterm>
	<primary>ACPI</primary>
	<secondary>ASL</secondary>
      </indexterm>

      <para>Ein häufiges Problem ist fehlerhafter Bytecode
	des <acronym>BIOS</acronym>-Herstellers.  Dies erkennen
	Sie an Kernelmeldungen auf der Konsole wie die
	folgende:</para>

      <screen>ACPI-1287: *** Error: Method execution failed [\\_SB_.PCI0.LPC0.FIGD._STA] \\
(Node 0xc3f6d160), AE_NOT_FOUND</screen>

      <para>Oft können Sie das Problem dadurch lösen,
	dass Sie eine aktuelle <acronym>BIOS</acronym>-Version
	einspielen.  Die meisten Meldungen auf der Konsole sind
	harmlos,  wenn aber beispielsweise der Batteriestatus
	falsch angezeigt wird, können Sie in den
	Meldungen nach Problemen mit der
	<acronym>AML</acronym>-Machine-Language
	(<acronym>AML</acronym>) suchen.  Der Bytecode der
	<acronym>AML</acronym> wird aus der
	<acronym>ACPI</acronym>-Source-Language
	(<acronym>ASL</acronym>) übersetzt und in einer Tabelle, der
	<acronym>DSDT</acronym>, abgelegt.  Eine Kopie der
	<acronym>ASL</acronym> können Sie mit dem Befehl
	&man.acpidump.8; erstellen.  Verwenden Sie mit diesem Befehl
	sowohl die Option <option>-t</option> (die Inhalte der
	statischen Tabellen anzeigen) als auch die Option
	<option>-d</option> (die <acronym>AML</acronym> in
	<acronym>ASL</acronym> zurückübersetzen).  Ein Beispiel für
	die Syntax finden Sie im Abschnitt
	<link linkend="ACPI-submitdebug">Fehlerberichte einreichen</link>.</para>

      <para>Sie können einfach prüfen, ob sich die
	<acronym>ASL</acronym> übersetzen lässt.
	Für gewöhnlich können Sie Warnungen
	während des Übersetzens ignorieren.
	Fehlermeldungen führen normal dazu, dass
	<acronym>ACPI</acronym> fehlerhaft arbeitet.
	<acronym>ASL</acronym> übersetzen Sie mit dem
	nachstehenden Kommando:</para>

      <screen>&prompt.root; <userinput>iasl ihre.asl</userinput></screen>
    </sect2>

    <sect2 xml:id="ACPI-fixasl">
      <title>Die <acronym>ASL</acronym> reparieren</title>

      <indexterm>
	<primary>ACPI</primary>
	<secondary>ASL</secondary>
      </indexterm>

      <para>Auf lange Sicht ist es das Ziel von &os;, dass
	<acronym>ACPI</acronym> ohne Eingriffe des Benutzers
	läuft.  Zurzeit werden allerdings noch Umgehungen für Fehler
	der <acronym>BIOS</acronym>-Hersteller entwickelt.
	Der &microsoft;-Interpreter (<filename>acpi.sys</filename>
	und <filename>acpiec.sys</filename>) prüft die
	<acronym>ASL</acronym> nicht streng gegen den Standard.
	Daher reparieren <acronym>BIOS</acronym>-Hersteller,
	die <acronym>ACPI</acronym> nur unter &windows; testen,
	ihre <acronym>ASL</acronym> nicht.  Die &os; Entwickler
	hoffen, dass sie das vom Standard abweichende Verhalten des
	&microsoft;-Interpreters dokumentieren und in &os; replizieren
	können.  Dadurch müssen Benutzer ihre
	<acronym>ASL</acronym> nicht selbst reparieren.
	Sie können Ihre <acronym>ASL</acronym> selbst reparieren,
	wenn Sie ein Problem umgehen und uns helfen möchten.
	Senden Sie bitte die mit &man.diff.1; erstellte Differenz
	zwischen alter und neuer <acronym>ASL</acronym>.  Die
	Entwickler werden versuchen, den Interpreter
	<acronym>ACPI-CA</acronym> zu korrigieren, damit die
	Fehlerbehebung nicht mehr erforderlich ist.</para>

      <indexterm>
	<primary>ACPI</primary>
	<secondary>Fehlermeldungen</secondary>
      </indexterm>

      <para>Die nachfolgende Liste enthält häufige
	Fehlermeldungen, deren Ursache und eine Beschreibung,
	wie die Fehler korrigiert werden:</para>

      <sect3>
	<title>Abhängigkeiten vom Betriebssystem</title>

	<para>Einige <acronym>AML</acronym>s gehen davon aus, dass
	  die Welt ausschließlich aus verschiedenen
	  &windows;-Versionen besteht.  &os; kann vorgeben, irgendein
	  Betriebssystem zu sein.  Versuchen Sie das Betriebssystem,
	  das Sie in der <acronym>ASL</acronym> finden, in der
	  Datei <filename>/boot/loader.conf</filename> anzugeben:
	  <literal>hw.acpi.osname="Windows 2001"</literal>.</para>
      </sect3>

      <sect3>
	<title>Fehlende Return-Anweisungen</title>

	<para>Einige Methoden verzichten auf die vom Standard
	  vorgeschriebene Rückgabe eines Wertes.  Obwohl
	  der Interpreter <acronym>ACPI-CA</acronym> dies nicht
	  beheben kann, besitzt &os; die Möglichkeit, den
	  Rückgabewert implizit zu setzen.  Wenn Sie
	  wissen, welcher Wert zurückgegeben werden muss,
	  können Sie die fehlenden Return-Anweisungen
	  selbst einsetzen.  Die Option <option>-f</option>
	  zwingt <command>iasl</command>, die <acronym>ASL</acronym>
	  zu übersetzen.</para>
      </sect3>

      <sect3>
	<title>Überschreiben der vorgegebenen
	  <acronym>AML</acronym></title>

	<para>Nachdem Sie Ihre <acronym>ASL</acronym> in der
	  Datei <filename>ihre.asl</filename> angepasst haben,
	  übersetzen Sie die <acronym>ASL</acronym> wie folgt:</para>

	<screen>&prompt.root; <userinput>iasl ihre.asl</userinput></screen>

	<para>Mit der Option <option>-f</option> erzwingen Sie das
	  Erstellen der <acronym>AML</acronym> auch wenn während
	  der Übersetzung Fehler auftreten.  Einige Fehler, wie
	  fehlende Return-Anweisungen, werden automatisch vom
	  Interpreter umgangen.</para>

	<para>In der Voreinstellung erstellt der Befehl
	  <command>iasl</command> die Ausgabedatei
	  <filename>DSDT.aml</filename>.  Wenn Sie diese Datei
	  anstelle der fehlerhaften Kopie des <acronym>BIOS</acronym>
	  laden wollen, editieren Sie
	  <filename>/boot/loader.conf</filename> wie folgt:</para>

	<programlisting>acpi_dsdt_load="YES"
acpi_dsdt_name="/boot/DSDT.aml"</programlisting>

	<para>Stellen Sie bitte sicher, dass sich
	  <filename>DSDT.aml</filename> in
	  <filename>/boot</filename> befindet.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="ACPI-debugoutput">
      <title><acronym>ACPI</acronym>-Meldungen zur
	Fehlersuche erzeugen</title>

      <indexterm>
	<primary>ACPI</primary>
	<secondary>Probleme mit</secondary>
      </indexterm>

      <indexterm>
	<primary>ACPI</primary>
	<secondary>Fehlersuche</secondary>
      </indexterm>

      <para>Der <acronym>ACPI</acronym>-Treiber besitzt
	flexible Möglichkeiten zur Fehlersuche.  Sie
	können sowohl die zu untersuchenden Subsysteme
	als auch die zu erzeugenden Ausgaben festlegen.  Die zu
	untersuchenden Subsysteme werden als so genannte
	<quote>layers</quote> angegeben.  Die Subsysteme sind in
	<acronym>ACPI-CA</acronym>-Komponenten
	(<literal>ACPI_ALL_COMPONENTS</literal>) und
	<acronym>ACPI</acronym>-Hardware
	(<literal>ACPI_ALL_DRIVERS</literal>) aufgeteilt.  Welche
	Meldungen ausgegeben werden, wird über
	<quote>level</quote> gesteuert.  <quote>level</quote> reicht
	von <literal>ACPI_LV_ERROR</literal> (es werden nur Fehler
	ausgegeben) bis zu <literal>ACPI_LV_VERBOSE</literal> (alles
	wird ausgegeben).  <quote>level</quote> ist eine Bitmaske,
	sodass verschiedene Stufen auf einmal (durch Leerzeichen
	getrennt) angegeben werden können.  Die erzeugte
	Ausgabemenge passt vielleicht nicht in den Konsolenpuffer.
	In diesem Fall sollte die Ausgabe mithilfe einer
	seriellen Konsole gesichert werden.  Die möglichen Werte
	für <quote>layers</quote> und <quote>level</quote>
	werden in &man.acpi.4; beschrieben.</para>

      <para>Die Ausgaben zur Fehlersuche sind in der Voreinstellung
	nicht aktiviert.  Wenn <acronym>ACPI</acronym> im Kernel
	enthalten ist, fügen Sie <literal>options ACPI_DEBUG</literal>
	zur Kernelkonfigurationsdatei hinzu.  Sie können die
	Ausgaben zur Fehlersuche global aktivieren, indem Sie in der
	Datei <filename>/etc/make.conf</filename> die Zeile
	<literal>ACPI_DEBUG=1</literal> einfügen.  Das Modul
	<filename>acpi.ko</filename> können Sie wie folgt
	neu übersetzen:</para>

      <screen>&prompt.root; <userinput>cd /sys/modules/acpi/acpi
&amp;&amp; make clean &amp;&amp;
make ACPI_DEBUG=1</userinput></screen>

      <para>Installieren Sie anschließend
	<filename>acpi.ko</filename> im Verzeichnis
	<filename>/boot/kernel</filename>.
	In der Datei <filename>loader.conf</filename> stellen Sie
	<quote>level</quote> und <quote>layer</quote> ein.  Das
	folgende Beispiel aktiviert die Ausgabe von Fehlern für
	alle <acronym>ACPI-CA</acronym>-Komponenten und alle
	<acronym>ACPI</acronym>-Hardwaretreiber (wie
	<acronym>CPU</acronym>, <acronym>LID</acronym>):</para>

      <programlisting>debug.acpi.layer="ACPI_ALL_COMPONENTS ACPI_ALL_DRIVERS"
debug.acpi.level="ACPI_LV_ERROR"</programlisting>

      <para>Wenn ein Problem durch ein bestimmtes Ereignis,
	beispielsweise den Start nach einem Ruhezustand, hervorgerufen
	wird, können Sie die Einstellungen für
	<quote>level</quote> und <quote>layer</quote> auch mit dem
	Kommando <command>sysctl</command> vornehmen.  In diesem
	Fall müssen Sie <filename>loader.conf</filename>
	nicht editieren.  Auf der
	<command>sysctl</command>-Kommandozeile geben Sie dieselben
	Variablennamen wie in <filename>loader.conf</filename>
	an.</para>
    </sect2>

    <sect2 xml:id="ACPI-References">
      <title>ACPI-Informationsquellen</title>

      <para>Weitere Informationen zu <acronym>ACPI</acronym>
	erhalten Sie an den folgenden Stellen:</para>

      <itemizedlist>
	<listitem>
	  <para>die &a.acpi; Mailingliste,</para>
	</listitem>

	<listitem>
	  <para>die Archive der <acronym>ACPI</acronym>-Mailingliste:
	    <uri xlink:href="http://lists.FreeBSD.org/pipermail/freebsd-acpi/">http://lists.FreeBSD.org/pipermail/freebsd-acpi/</uri>,</para>
	</listitem>

	<listitem>
	  <para>die alten Archive der <acronym>ACPI</acronym>-Mailingliste:
	    <uri xlink:href="http://home.jp.FreeBSD.org/mail-list/acpi-jp/">http://home.jp.FreeBSD.org/mail-list/acpi-jp/</uri>,</para>
	</listitem>

	<listitem>
	  <para>die <acronym>ACPI</acronym>-Spezifikation (Version 2.0):
	    <uri xlink:href="http://acpi.info/spec.htm">http://acpi.info/spec.htm</uri>,</para>
	</listitem>

	<listitem>
	  <para>in den nachstehenden &os;-Hilfeseiten:
	     &man.acpi.4;, &man.acpi.thermal.4;, &man.acpidump.8;,
	    &man.iasl.8; und &man.acpidb.8;,</para>
	</listitem>

	<listitem>
	  <para><link xlink:href="http://www.cpqlinux.com/acpi-howto.html#fix_broken_dsdt">
	    <acronym>DSDT</acronym> debugging resource</link>
	    (als Beispiel wird Compaq erläutert, die
	    Ressource ist aber dennoch nützlich).</para>
	</listitem>
      </itemizedlist>
    </sect2>
  </sect1>
</chapter>
