<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde: de-docproj/books/handbook/config/chapter.sgml,v 1.75 2004/01/10 23:38:00 mheinen Exp $
     basiert auf: 1.130
-->

<chapter id="config-tuning">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Chern</firstname>
	<surname>Lee</surname>
	<contrib>Geschrieben von </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Mike</firstname>
	<surname>Smith</surname>
	<contrib>Nach einem Tutorium von </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Matt</firstname>
	<surname>Dillon</surname>
	<contrib>Basiert ebenfalls auf tuning(7) von </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Martin</firstname>
	<surname>Heinen</surname>
	<contrib>&Uuml;bersetzt von </contrib>
      </author>
    </authorgroup>
  </chapterinfo>

  <title>Konfiguration und Tuning</title>

  <sect1 id="config-synopsis">
    <title>&Uuml;bersicht</title>

    <indexterm><primary>System-Konfiguration</primary></indexterm>
    <indexterm><primary>System-Optimierung</primary></indexterm>

    <para>Ein korrekt konfiguriertes System kann die Arbeit,
      die bei der zuk&uuml;nftigen Pflege und bei Migrationen des Systems
      entsteht, erheblich reduzieren.  Dieses Kapitel beschreibt die
      Konfiguration von &os; sowie Ma&szlig;nahmen zur Leistungssteigerung
      von &os;-Systemen.</para>

    <para>Nachdem Sie dieses Kapitel durchgearbeitet haben,
      werden Sie Folgendes wissen:</para>

    <itemizedlist>
      <listitem>
	<para>Wie Sie effizient Dateisysteme und
	  Swap-Partitionen auf Ihrer Festplatte einrichten.</para>
      </listitem>
      <listitem>
	<para>Die Grundlagen der Konfiguration mit
	  <filename>rc.conf</filename> und des Systems zum Starten
	  von Anwendungen in <filename>/usr/local/etc/rc.d</filename>.</para>
      </listitem>
      <listitem>
	<para>Wie Sie Netzwerkkarten konfigurieren und testen.</para>
      </listitem>
      <listitem>
	<para>Wie Sie virtuelle Hosts und Netzwerkger&auml;te
	  konfigurieren.</para>
      </listitem>
      <listitem>
	<para>Wie Sie die verschiedenen Konfigurationsdateien
	  in <filename>/etc</filename> benutzen.</para>
      </listitem>
      <listitem>
	<para>Wie Sie mit <command>sysctl</command>-Variablen &os;
	  einstellen k&ouml;nnen.</para>
      </listitem>
      <listitem>
	<para>Wie Sie die Platten-Performance einstellen und Kernel-Parameter
	  modifizieren k&ouml;nnen.</para>
      </listitem>
    </itemizedlist>

    <para>Bevor Sie dieses Kapitel lesen, sollten Sie</para>
    <itemizedlist>
      <listitem>
	<para>die Grundlagen von &unix; und &os; (<xref linkend="basics">)
	  verstehen.</para>
      </listitem>
      <listitem>
	<para>Damit vertraut sein, wie Sie die &os;-Quellen aktuell
	  halten (<xref linkend="cutting-edge">) und wissen, wie Sie einen
	  Kernel konfigurieren und kompilieren
	  (<xref linkend="kernelconfig">).</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="configtuning-initial">
    <title>Vorbereitende Konfiguration</title>

    <sect2>
      <title>Layout von Partitionen</title>

      <indexterm><primary>Layout von Partitionen</primary></indexterm>
      <indexterm><primary><filename>/etc</filename></primary></indexterm>
      <indexterm><primary><filename>/var</filename></primary></indexterm>
      <indexterm><primary><filename>/usr</filename></primary></indexterm>

      <sect3>
	<title>Partitionen</title>

	<para>Wenn Sie Dateisysteme mit &man.disklabel.8; oder
	  &man.sysinstall.8; anlegen, sollten Sie beachten, dass
	  Festplatten auf Daten in den &auml;u&szlig;eren Spuren
	  schneller zugreifen k&ouml;nnen als auf Daten in den
	  inneren Spuren.  Daher sollten die kleineren oft benutzten
	  Dateisysteme, wie das Root-Dateisystem oder die Swap-Partition,
	  an den &auml;u&szlig;eren Rand der Platte gelegt werden.
	  Die gr&ouml;&szlig;eren Partitionen wie <filename>/usr</filename>
	  sollten in die inneren Bereiche gelegt werden.
	  Es empfiehlt sich, die Partitionen in einer &auml;hnlichen
	  Reihenfolge wie Root-Partition, Swap, <filename>/var</filename>
	  und <filename>/usr</filename> anzulegen.</para>

	<para>Die Gr&ouml;&szlig;e von <filename>/var</filename>
	  ist abh&auml;ngig vom Zweck der Maschine.
	  <filename>/var</filename> enth&auml;lt haupts&auml;chlich
	  Postf&auml;cher, den Spoolbereich zum Drucken und Logdateien.
	  Abh&auml;ngig von der Anzahl der Systembenutzer und der
	  Aufbewahrungszeit f&uuml;r Logdateien, k&ouml;nnen gerade
	  die Postf&auml;cher und Logdateien zu ungeahnten Gr&ouml;&szlig;en
	  wachsen.  Oft werden Sie mit weniger als einem Gigabyte
	  auskommen, doch beachten Sie, dass
	  <filename>/var/tmp</filename> f&uuml;r Pakete ausreichend
	  dimensioniert ist.</para>

	<para>Die <filename>/usr</filename>-Partition enth&auml;lt den
	  Hauptteil des Systems, die Ports-Sammlung (empfohlen) und die
	  Quellen (optional).  Im Laufe der Installation haben Sie die
	  M&ouml;glichkeit, die Quellen und die Ports-Sammlung gleich mit
	  zu installieren.  F&uuml;r die
	  <filename>/usr</filename>-Partition sollten Sie mindestens
	  zwei&nbsp;Gigabyte vorsehen.</para>

	<para>Wenn Sie die Gr&ouml;&szlig;e der Partitionen festlegen,
	  beachten Sie bitte das Wachstum Ihres Systems.  Wenn Sie den
	  Platz auf einer Partition vollst&auml;ndig aufgebraucht haben,
	  eine andere Partition aber kaum benutzen, kann die Handhabung des
	  Systems schwierig werden.</para>

	<note><para>Die automatische Partitionierung von &man.sysinstall.8;
	  mit <literal>Auto-defaults</literal> legt manchmal zu kleine
	  <filename>/</filename> und <filename>/var</filename>-Partition an.
	  Partitionieren Sie weise und gro&szlig;z&uuml;gig.</para></note>

      </sect3>

      <sect3 id="swap-design">
	<title>Swap Partition</title>

	<indexterm>
	  <primary>Swap-Partition</primary>
	  <secondary>Gr&ouml;&szlig;e</secondary>
	</indexterm>
	<indexterm><primary>Swap-Partition</primary></indexterm>

	<para>Als Daumenregel sollten Sie doppelt soviel Speicher
	  f&uuml;r die Swap-Partition vorsehen, als Sie Hauptspeicher
	  haben.  Verf&uuml;gt die Maschine beispielsweise &uuml;ber
	  128&nbsp;Megabyte Hauptspeicher, sollten Sie 256&nbsp;Megabyte
	  f&uuml;r den Swap-Bereich vorsehen.  Systeme mit weniger Speicher
	  werden wahrscheinlich mit viel mehr Swap mehr leisten.  Es
	  wird nicht empfohlen, weniger als 256&nbsp;Megabyte Swap einzurichten.
	  Au&szlig;erdem sollten Sie k&uuml;nftige Speichererweiterungen
	  beachten, wenn Sie die Swap-Partition einrichten.  Die
	  VM-Paging-Algorithmen im Kernel sind so eingestellt, dass
	  Sie am besten laufen, wenn die Swap-Partition mindestens
	  doppelt so gro&szlig; wie der Hauptspeicher ist.  Zu wenig
	  Swap kann zu einer Leistungsverminderung im
	  <foreignphrase>VM page scanning</foreignphrase>
	  Code f&uuml;hren, sowie Probleme verursachen, wenn Sie sp&auml;ter
	  mehr Speicher in Ihre Maschine bauen.<para>

	<para>Auf gr&ouml;&szlig;eren Systemen mit mehreren SCSI-Laufwerken
	  (oder mehreren IDE-Laufwerken an unterschiedlichen Controllern)
	  empfehlen wir Ihnen, Swap-Bereiche auf bis zu
	  vier Laufwerken einzurichten.  Diese Swap-Partitionen sollten
	  ungef&auml;hr dieselbe Gr&ouml;&szlig;e haben.  Der Kernel
	  kann zwar mit beliebigen Gr&ouml;&szlig;en umgehen, aber
	  die internen Datenstrukturen skalieren bis zur vierfachen
	  Gr&ouml;&szlig;e der gr&ouml;&szlig;ten Partition.  Ungef&auml;hr
	  gleich gro&szlig;e Swap-Partitionen erlauben es dem Kernel,
	  den Swap-Bereich optimal &uuml;ber die Laufwerke zu verteilen.
	  Gro&szlig;e Swap-Bereiche, auch wenn sie nicht oft gebraucht
	  werden, sind n&uuml;tzlich, da sich ein speicherfressendes
	  Programm unter Umst&auml;nden auch ohne einen Neustart des Systems
	  beenden l&auml;sst.</para>
      </sect3>

      <sect3>
	<title>Warum partitionieren?</title>

	<para>Gegen eine einzelne Partition sprechen mehrere Gr&uuml;nde.
	  Jede Partition hat im Betrieb unterschiedliche Eigenschaften
	  und die Trennung der Partitionen erlaubt es, die Dateisysteme
	  an diese Eigenschaften anzupassen.  Die Root- und
	  <filename>/usr</filename>-Partitionen weisen meist nur
	  lesende Zugriffe auf, w&auml;hrend <filename>/var</filename>
	  und <filename>/var/tmp</filename> haupts&auml;chlich
	  beschrieben werden.</para>

	<para>Indem Sie ein System richtig partitionieren, verhindern
	  Sie, dass eine Fragmentierung in den h&auml;ufig beschriebenen
	  Partitionen auf die meist nur gelesenen Partitionen
	  &uuml;bergreift.  Wenn Sie die h&auml;ufig beschriebenen
	  Partitionen an den Rand der Platte, legen, dann wird die
	  I/O-Leistung diesen Partitionen steigen.
	  Die I/O-Leistung ist nat&uuml;rlich auch f&uuml;r gro&szlig;e
	  Partitionen wichtig, doch erzielen Sie eine gr&ouml;&szlig;ere
	  Leistungssteigerung, wenn Sie <filename>/var</filename> an den
	  Rand der Platte legen.  Schlie&szlig;lich sollten Sie
	  noch die Stabilit&auml;t des Systems beachten.
	  Eine kleine Root-Partition, auf die meist nur lesend
	  zugegriffen wird, &uuml;berlebt einen schlimmen Absturz
	  wahrscheinlich eher als eine gro&szlig;e Partition.</para>
      </sect3>
    </sect2>

  </sect1>

  <sect1 id="configtuning-core-configuration">
    <title>Basiskonfiguration</title>

    <indexterm>
      <primary>rc-Dateien</primary>
      <secondary><filename>rc.conf</filename></secondary>
    </indexterm>

    <para>Informationen zur Systemkonfiguration sind haupts&auml;chlich
      in <filename>/etc/rc.conf</filename>, die meist beim Start
      des Systems verwendet wird, abgelegt.  Der Name der Datei zeigt
      ihren Zweck an: Sie enth&auml;lt die Konfigurationen f&uuml;r
      die <filename>rc*</filename> Dateien.</para>

    <para>In <filename>rc.conf</filename> werden die Vorgabewerte aus
      <filename>/etc/defaults/rc.conf</filename> &uuml;berschrieben.
      Die Vorgabedatei sollte nicht nach <filename>/etc</filename>
      kopiert werden, da sie die Vorgabewerte und keine Beispiele
      enth&auml;lt.  Jede systemspezifische &Auml;nderung wird
      in <filename>rc.conf</filename> vorgenommen.</para>

    <para>Um den administrativen Aufwand gering zu halten, existieren
      in geclusterten Anwendungen mehrere Strategien,
      globale Konfigurationen von systemspezifischen Konfigurationen
      zu trennen.  Der empfohlene Weg h&auml;lt die globale Konfiguration
      in einer separaten Datei z.B. <filename>rc.conf.site</filename>.
      Diese Datei wird dann in <filename>/etc/rc.conf</filename>,
      die nur systemspezifische Informationen enth&auml;lt, eingebunden.</para>

    <para>Da <filename>rc.conf</filename> von &man.sh.1; gelesen
      wird, ist das einfach zu erreichen:</para>

    <itemizedlist>
      <listitem><para>rc.conf:</para>
<programlisting>	. rc.conf.site
	hostname="node15.example.com"
	network_interfaces="fxp0 lo0"
	ifconfig_fxp0="inet 10.1.1.1"</programlisting></listitem>
      <listitem><para>rc.conf.site:</para>
<programlisting>	defaultrouter="10.1.1.254"
	saver="daemon"
	blanktime="100"</programlisting></listitem>
    </itemizedlist>

    <para><filename>rc.conf.site</filename> kann dann auf jedes
      System mit <command>rsync</command> verteilt werden,
      <filename>rc.conf</filename> bleibt dabei systemspezifisch.</para>

    <para>Bei einem Upgrade des Systems mit &man.sysinstall.8; oder
      <command>make world</command> wird <filename>rc.conf</filename>
      nicht &uuml;berschrieben, so dass die Systemkonfiguration
      erhalten bleibt.</para>

  </sect1>

  <sect1 id="configtuning-appconfig">
    <title>Konfiguration von Anwendungen</title>

    <para>Installierte Anwendungen haben typischerweise
      eigene Konfigurationsdateien, die eine eigene Syntax
      verwenden.  Damit diese Dateien leicht von der
      Paketverwaltung gefunden und verwaltet werden k&ouml;nnen,
      ist es wichtig, sie vom Basissystem zu trennen.</para>

    <indexterm><primary>/usr/local/etc</primary></indexterm>

    <para>F&uuml;r gew&ouml;hnlich werden diese Dateien in
      <filename>/usr/local/etc</filename> installiert.  Besitzt
      eine Anwendung viele Konfigurationsdateien, werden
      diese in einem separaten Unterverzeichnis abgelegt.</para>

    <para>Wenn ein Port oder ein Paket installiert wird, werden
      normalerweise auch Beispiele f&uuml;r die Konfigurationsdateien
      installiert.  Diese erkennt man gew&ouml;hnlich an dem
      Suffix <filename>.default</filename>.  Wenn keine Konfigurationsdateien
      f&uuml;r eine Anwendung existieren, werden sie durch
      Kopieren der <filename>.default</filename> Dateien erstellt.</para>

    <para>Als Beispiel sei <filename>/usr/local/etc/apache</filename>
      gezeigt:</para>

<literallayout class="monospaced">-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf
-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf.default
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf.default
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic.default
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types.default
-rw-r--r--  1 root  wheel   7980 May 20  1998 srm.conf
-rw-r--r--  1 root  wheel   7933 May 20  1998 srm.conf.default</literallayout>

    <para>Anhand der Dateigr&ouml;&szlig;e erkennen Sie, dass sich
      nur <filename>srm.conf</filename> ge&auml;ndert hat.  Eine
      sp&auml;tere Aktualisierung des <application>Apache</application>-Ports
      &uuml;berschreibt diese Datei nicht.</para>

  </sect1>

  <sect1 id="configtuning-starting-services">
    <title>Start von Diensten</title>

    <indexterm><primary>Dienste</primary></indexterm>

    <para>Es ist &uuml;blich, dass ein System mehrere Dienste
      zur Verf&uuml;gung stellt.  Diese k&ouml;nnen auf verschiedene
      Weisen, die jeweils andere Vorteile haben, gestartet werden.</para>

    <indexterm><primary>/usr/local/etc/rc.d</primary></indexterm>

    <para>Software, die von einem Port oder einem Paket installiert
      wurde, wird oft ein Skript in <filename>/usr/local/etc/rc.d</filename>
      stellen.  Dieses wird beim Hochfahren des Systems mit dem
      Argument <option>start</option> und beim Herunterfahren mit
      dem Argument <option>stop</option> aufgerufen.  Das ist der empfohlene
      Weg, systemweite Dienste, die unter <username>root</username> laufen
      oder unter <username>root</username> gestartet werden, zu starten.
      Die Skripten werden bei der Installation des Paketes registriert
      und entfernt, wenn das Paket entfernt wird.</para>

    <para>Ein typisches Skript in <filename>/usr/local/etc/rc.d</filename>
      sieht wie folgt aus:</para>

    <programlisting>#!/bin/sh
echo -n ' FooBar'

case "$1" in
start)
        /usr/local/bin/foobar
        ;;
stop)
        kill -9 `cat /var/run/foobar.pid`
        ;;
*)
        echo "Usage: `basename $0` {start|stop}" >&2
        exit 64
        ;;
esac

exit 0
    </programlisting>

    <para>Die Startskripten von &os; suchen in
      <filename>/usr/local/etc/rc.d</filename> nach Dateien mit dem Suffix
      <literal>.sh</literal>, die von <username>root</username>
      ausgef&uuml;hrt werden k&ouml;nnen.  Die gefundenen Skripten werden
      beim Hochfahren des Systems mit der Option <option>start</option> und
      beim Herunterfahren mit der Option <option>stop</option> aufgerufen,
      damit sie die passenden Aktionen ausf&uuml;hren k&ouml;nnen.  Wenn
      Sie das vorige Beispiel beim Systemstart verwenden wollen, sollten
      Sie es also als <filename>FooBar.sh</filename> in
      <filename>/usr/local/etc/rc.d</filename> speichern und sicherstellen,
      das das Skript ausf&uuml;hrbar ist.  Benutzen Sie &man.chmod.1;, um
      das Skript ausf&uuml;hrbar zu machen:</para>

    <screen>&prompt.root; <userinput>chmod 755 <replaceable>FooBar.sh</replaceable></userinput></screen>

    <para>Manche Dienste werden von &man.inetd.8; aufgerufen, wenn
      eine Verbindung auf dem passenden Port aufgebaut wird.  &Uuml;blich
      ist das f&uuml;r Server von Mail-Clients (POP, IMAP, usw.).  Diese
      Dienste werden durch das Editieren von
      <filename>/etc/inetd.conf</filename> aktiviert.  Details dazu
      finden sich in &man.inetd.8;.</para>

    <para>Weitere Systemdienste werden vielleicht nicht von
      <filename>/etc/rc.conf</filename> abgedeckt.  Diese werden
      traditionell durch Kommandos in <filename>/etc/rc.local</filename>
      aktiviert.  Seit &os;&nbsp;3.1 existiert keine Vorgabe f&uuml;r
      <filename>/etc/rc.local</filename> mehr.  Wenn die Datei allerdings
      von einem Administrator angelegt wird, so wird sie auch
      ausgef&uuml;hrt.  Beachten Sie bitte, dass
      <filename>/etc/rc.local</filename> als der letzte Weg, einen
      Dienst zu starten, angesehen wird.  Wenn es eine andere
      M&ouml;glichkeit gibt, den Dienst zu starten, nehmen Sie diese
      bitte wahr.</para>

    <note><para>F&uuml;gen Sie bitte <emphasis>keine</emphasis> Kommandos
      in <filename>/etc/rc.conf</filename> ein.  Starten Sie stattdessen
      D&aelig;mons oder Kommandos beim Hochfahren mit Skripten in
      <filename>/usr/local/etc/rc.d</filename>.</para></note>

    <para>Systemdienste k&ouml;nnen auch mit &man.cron.8; gestartet
      werden.  Dieser Ansatz hat einige Vorteile; nicht zuletzt, weil
      &man.cron.8; die Prozesse unter dem Eigent&uuml;mer der
      <command>crontab</command> startet, ist es m&ouml;glich, dass
      Dienste von nicht-<username>root</username> Benutzern gestartet
      und gepflegt werden k&ouml;nnen.</para>

    <para>Dies nutzt eine Eigenschaft von &man.cron.8;:
      F&uuml;r die Zeitangabe kann <literal>@reboot</literal>
      eingesetzt werden.  Damit wird das Kommando gestartet, wenn
      &man.cron.8; kurz nach dem Systemboot gestartet wird.</para>
  </sect1>

  <sect1 id="configtuning-cron">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Beigetragen von </contrib>
	  <!-- 20 May 2003 -->
	</author>
      </authorgroup>
    </sect1info>
    <title>Programme mit <command>cron</command> starten</title>

    <indexterm>
      <primary><command>cron</command></primary>
    </indexterm>

    <para>Ein sehr n&uuml;tzliches Werkzeug von &os; ist &man.cron.8;.
      <command>cron</command> l&auml;uft im Hintergrund und
      &uuml;berpr&uuml;ft fortlaufend die Datei
      <filename>/etc/crontab</filename>.  Beim Start sucht
      <command>cron</command> neue <filename>crontab</filename>-Dateien
      im Verzeichnis <filename>/var/cron/tabs</filename>.  In den
      <filename>crontab</filename>-Dateien wird festgelegt, welche
      Programme zu welchem Zeitpunkt laufen sollen.</para>

    <para>Der folgende Auszug aus <filename>/etc/crontab</filename>
      zeigt den Aufbau einer <filename>crontab</filename>-Datei:</para>

    <programlisting># /etc/crontab - root's crontab for FreeBSD
#
# &dollar;FreeBSD: src/etc/crontab,v 1.32 2002/11/22 16:13:39 tom Exp &dollar;
# <co id="co-comments">
#
SHELL=/bin/sh
PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin <co id="co-env">
HOME=/var/log
#
#
#minute	hour	mday	month	wday	who	command <co id="co-field-descr">
#
#
*/5	*	*	*	*	root	/usr/libexec/atrun <co id="co-main"></programlisting>

    <calloutlist>
      <callout arearefs="co-comments">
	<para>Das Zeichen <literal>#</literal> leitet, wie in
	  den meisten Konfigurationsdateien, einen Kommentar ein.
	  Benutzen Sie Kommentare, um die Funktion eines Eintrags
	  zu erl&auml;utern.  Kommentare m&uuml;ssen in einer
	  extra Zeile stehen.  Sie k&ouml;nnen nicht in derselben
	  Zeile wie ein Kommando stehen, da sie sonst Teil des
	  Kommandos w&auml;ren.  Leerzeilen in dieser Datei
	  werden ignoriert.</para>
      </callout>

      <callout arearefs="co-env">
	<para>Umgebungsvariablen werden mit dem Gleichheits-Zeichen
	  (<literal>=</literal>) festgelegt.  Im Beispiel werden
	  die Variablen <envar>SHELL</envar>, <envar>PATH</envar>
	  und <envar>HOME</envar> definiert.  Wenn die Variable
	  <envar>SHELL</envar> nicht definiert wird, benutzt
	  <command>cron</command> die Shell <command>sh</command>.
	  Wird die Variable <envar>PATH</envar> nicht gesetzt,
	  m&uuml;ssen alle Pfadangaben absolut sein, da es keinen
	  Vorgabewert f&uuml;r <envar>PATH</envar> gibt.  Der
	  Vorgabewert f&uuml;r <envar>HOME</envar> ist das
	  Heimatverzeichnis des Accounts, dem die
	  <filename>crontab</filename> geh&ouml;rt.</para>
      </callout>

      <callout arearefs="co-field-descr">
	<para>In dieser Zeile werden sieben Felder beschrieben:
	  <literal>minute</literal>, <literal>hour</literal>,
	  <literal>mday</literal>, <literal>month</literal>,
	  <literal>wday</literal>, <literal>who</literal>
	  und <literal>command</literal>.  Die ersten Felder
	  legen den Zeitpunkt fest, an dem ein Kommando laufen
	  soll.  Das Feld <literal>minute</literal> legt die
	  Minute fest, das Feld <literal>hour</literal> die
	  Stunde, das Feld <literal>mday</literal> den Tag
	  des Monats.  Im Feld <literal>month</literal>
	  wird der Monat und im Feld <literal>wday</literal>
	  der Wochentag festgelegt.  Alle Felder m&uuml;ssen
	  numerische Werte enthalten und die Zeitangaben sind
	  im 24-Stunden-Format.  Das Feld <literal>who</literal>
	  gibt es nur in der Datei <filename>/etc/crontab</filename>
	  und gibt den Account an, unter dem das Kommando laufen
	  soll.  In den <filename>crontab</filename>-Dateien
	  einzelner Accounts existiert dieses Feld nicht.  Im
	  letzten Feld wird schlie&szlig;lich das auszuf&uuml;hrende
	  Kommando angegeben.</para>
      </callout>

      <callout arearefs="co-main">
	<para>Diese Zeile definiert die Zeitpunkte an denen das
	  Kommando <command>atrun</command> laufen soll.  Beachten
	  Sie die Zeichenfolge <literal>*/5</literal> gefolgt von
	  mehreren <literal>*</literal>-Zeichen.  Das Zeichen
	  <literal>*</literal> ist ein Platzhalter und steht
	  f&uuml;r <emphasis>jede</emphasis> m&ouml;gliche Zeit.
	  Diese Zeile f&uuml;hrt das Kommando <command>atrun</command>
	  unter dem <username>root</username>-Account alle f&uuml;nf
	  Minuten aus.  Weitere Informationen zu <command>atrun</command>
	  erhalten Sie in der Hilfeseite &man.atrun.8;.</para>

	<para>Bei den Kommandos k&ouml;nnen beliebige Optionen
	  angegeben werden.  Wenn das Kommando zu lang ist und
	  auf der n&auml;chsten Zeile fortgesetzt werden soll,
	  muss am Ende der Zeile das Fortsetzungszeichen
	  (<literal>\</literal>) angegeben werden.</para>
      </callout>
    </calloutlist>

    <para>Bis auf das sechste Feld, das den Account angibt, sieht
      jede <filename>crontab</filename>-Datei so wie das Beispiel
      aus.  Das sechste Feld existiert nur in der Systemdatei
      <filename>/etc/crontab</filename>.  In den restlichen
      <filename>crontab</filename>-Dateien fehlt dieses Feld.</para>

    <sect2 id="configtuning-installcrontab">
      <title><filename>crontab</filename> installieren</title>

      <para>Eine erstellte <filename>crontab</filename>-Datei
	installieren Sie mit dem nachstehenden Befehl:</para>

      <screen>&prompt.root; <userinput>crontab crontab</userinput></screen>

      <para>Der Befehl <command>crontab -l</command> zeigt
	die installierte <filename>crontab</filename>-Datei an.</para>

      <para>Benutzer, die eine eigene <filename>crontab</filename>-Datei
	ohne Vorlage erstellen wollen, k&ouml;nnen den Befehl
	<command>crontab -e</command> verwenden.  Dieser Befehl
	ruft einen Editor auf und installiert beim Verlassen des
	Editors die <filename>crontab</filename>-Datei.</para>
    </sect2>
  </sect1>

  <sect1 id="configtuning-rcNG">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Beigetragen von </contrib>
	  <!-- 16 May 2003 -->
	</author>
      </authorgroup>
    </sect1info>
    <title>Das rc-System f&uuml;r Systemdienste</title>

    <indexterm><primary>rcNG</primary></indexterm>

    <para>Das <application>rcNG</application>-System von NetBSD zum
      Start von Systemdiensten wurde in &os; integriert.
      Die zu diesem System geh&ouml;renden Dateien sind im
      Verzeichnis <filename>/etc/rc.d</filename> abgelegt.
      Die Skripten in diesem Verzeichnis akzeptieren die
      Optionen <option>start</option>, <option>stop</option>
      und <option>restart</option>.  Beispielsweise kann
      &man.sshd.8; mit dem nachstehenden Kommando neu gestartet
      werden:</para>

    <screen>&prompt.root; <userinput>/etc/rc.d/sshd restart</userinput></screen>

    <para>Analog k&ouml;nnen Sie andere Dienste starten und stoppen.
      Normalerweise werden die Dienste &uuml;ber Eintr&auml;ge in
      der Datei &man.rc.conf.5; gestartet.  Der Network Address
      Translation D&aelig;mon wird zum Beispiel mit dem folgenden
      Eintrag in <filename>/etc/rc.conf</filename> aktiviert:</para>

    <programlisting>natd_enable="YES"</programlisting>

    <para>Wenn dort bereits die Zeile <option>natd_enable="NO"</option>
      existiert, &auml;ndern Sie einfach <option>NO</option> in
      <option>YES</option>.  Die rc-Skripten starten, wie unten
      beschrieben, auch abh&auml;ngige Dienste.</para>

    <para>Da das <application>rcNG</application>-System prim&auml;r
      zum automatischen Starten und Stoppen von Systemdiensten
      dient, funktionieren die Optionen <option>start</option>,
      <option>stop</option> und <option>restart</option> nur,
      wenn die entsprechenden Variablen in
      <filename>/etc/rc.conf</filename> gesetzt sind.  Beispielsweise
      funktioniert das Kommando <command>sshd restart</command>
      nur dann, wenn in <filename>/etc/rc.conf</filename> die
      Variable <varname>sshd_enable</varname> auf <option>YES</option>
      gesetzt wurde.  Wenn Sie die Optionen <option>start</option>,
      <option>stop</option> oder <option>restart</option>
      unabh&auml;ngig von den Einstellungen in
      <filename>/etc/rc.conf</filename> benutzen wollen,
      m&uuml;ssen Sie den Optionen mit dem Pr&auml;fix
      <quote>force</quote> verwenden.  Um beispielsweise
      <command>sshd</command> unabh&auml;ngig von den
      Einstellungen in <filename>/etc/rc.conf</filename> neu
      zu starten, benutzen Sie das nachstehende Kommando:</para>

    <screen>&prompt.root; <userinput>/etc/rc.d/sshd forcerestart</userinput></screen>

    <para>Ob ein Dienst in <filename>/etc/rc.conf</filename>
      aktiviert ist, k&ouml;nnen Sie leicht herausfinden, indem
      Sie das entsprechende <filename>rc.d</filename>-Skript
      mit der Option <option>rcvar</option> aufrufen.  Ein
      Administrator kann beispielsweise wie folgt pr&uuml;fen, ob
      der <command>sshd</command>-Dienst in
      <filename>/etc/rc.conf</filename> aktiviert ist:</para>

    <screen>&prompt.root; <userinput>/etc/rc.d/sshd rcvar</userinput>
# sshd
$sshd_enable=YES</screen>

    <note>
      <para>Die zweite Zeile (<literal># sshd</literal>) wird
	vom Kommando <command>sshd</command> ausgegeben; sie
	kennzeichnet nicht die Eingabeaufforderung von
	<username>root</username>.</para>
    </note>

    <para>Ob ein Dienst l&auml;uft, kann mit der Option
      <option>status</option> abgefragt werden.  Das folgende
      Kommando &uuml;berpr&uuml;ft, ob der <command>sshd</command>
      auch wirklich gestartet wurde:</para>

    <screen>&prompt.root; <userinput>/etc/rc.d/sshd status</userinput>
sshd is running as pid 433.</screen>

    <para>Die Option <option>reload</option> initialisiert einen
      Dienst neu.  Dem Dienst wird &uuml;ber ein Signal mitgeteilt,
      dass er seine Konfigurationsdateien neu einlesen soll.
      Oft wird dazu das Signal <literal>SIGHUP</literal>
      verwendet.</para>

    <para>Die meisten Systemdienste werden beim Systemstart vom
      <application>rcNG</application>-System gestartet.  Zum Beispiel
      aktiviert das Skript <filename>bgfsck</filename> die Pr&uuml;fung
      von Dateisystemen im Hintergrund.  Das Skript gibt die folgende
      Meldung aus, wenn es gestartet wird:</para>

    <screen>Starting background file system checks in 60 seconds.</screen>

    <para>Viele Systemdienste h&auml;ngen von anderen Diensten
      ab.  NIS und andere RPC-basierende Systeme h&auml;ngen
      beispielsweise von dem <command>rpcbind</command>-Dienst
      (portmapper) ab.  Im Kopf der Startskripten befinden sich
      die Informationen &uuml;ber Abh&auml;ngigkeiten von anderen
      Diensten und weitere Metadaten.  Mithilfe dieser Daten
      bestimmt das Programm &man.rcorder.8; beim Systemstart die
      Startreihenfolge der Dienste.  Folgende Schl&uuml;sselw&ouml;rter
      werden im Kopf der Startskripten verwendet:</para>

    <itemizedlist>
      <listitem>
	<para>PROVIDE: Gibt die Namen der Dienste an, die
	  mit dieser Datei zur Verf&uuml;gung gestellt werden.</para>
      </listitem>

      <listitem>
	<para>REQUIRE: Gibt die Namen der Dienste an, von denen dieser
	  Dienst abh&auml;ngt.  Diese Datei wird <emphasis>nach</emphasis>
	  den angegebenen Diensten ausgef&uuml;hrt.</para>
      </listitem>

      <listitem>
	<para>BEFORE: Z&auml;hlt Dienste auf, die auf diesen Dienst
	  angewiesen sind.  Diese Datei wird <emphasis>vor</emphasis>
	  den angegebenen Diensten ausgef&uuml;hrt.</para>
      </listitem>

      <listitem>
	<para>KEYWORD: <literal>FreeBSD</literal> oder
	  <literal>NetBSD</literal>.  Unterscheidet Funktionen,
	  die von der BSD-Variante abh&auml;ngen.</para>
      </listitem>
    </itemizedlist>

    <para>Mit diesem System kann ein Administrator den Start
      von Systemdiensten einfach steuern, ohne mit den
      Schwierigkeiten des <quote>runlevel</quote>-Systems
      anderer &unix; Systeme k&auml;mpfen zu m&uuml;ssen.</para>
  </sect1>

  <sect1 id="config-network-setup">
    <sect1info>
      <authorgroup>
        <author>
	 <firstname>Marc</firstname>
	 <surname>Fonvieille</surname>
	 <contrib>Beigetragen von </contrib>
	 <!-- 6 October 2002 -->
        </author>
      </authorgroup>
    </sect1info>

    <title>Einrichten von Netzwerkkarten</title>

    <indexterm><primary>Netzwerkkarten</primary></indexterm>

    <para>Ein Rechner ohne Netzanschluss ist heute nicht mehr
      vorstellbar.  Die Konfiguration einer Netzwerkkarte geh&ouml;rt zu
      den allt&auml;glichen Aufgaben eines &os; Administrators.</para>

    <sect2>
      <title>Bestimmen des richtigen Treibers</title>

      <indexterm>
        <primary>Netzwerkkarten</primary>
        <secondary>Treiber</secondary>
      </indexterm>

      <para>Bevor Sie anfangen, sollten Sie das Modell Ihrer Karte kennen,
        wissen welchen Chip die Karte benutzt und bestimmen, ob es sich
	um eine PCI- oder ISA-Karte handelt.  Eine Aufz&auml;hlung der
	unterst&uuml;tzten PCI- und ISA-Karten finden Sie in der
	Liste der unterst&uuml;tzen Ger&auml;te.  Schauen Sie nach, ob Ihre
	Karte dort aufgef&uuml;hrt ist.</para>

      <para>Wenn Sie wissen, dass Ihre Karte unterst&uuml;tzt wird,
        m&uuml;ssen Sie den Treiber f&uuml;r Ihre Karte bestimmen.
	<filename>/usr/src/sys/i386/conf/LINT</filename> enth&auml;lt eine
	Liste der verf&uuml;gbaren Treiber mit Informationen zu den
	unterst&uuml;tzten Chips&auml;tzen und Karten.  Wenn Sie sich nicht
	sicher sind, ob Sie den richtigen Treiber ausgew&auml;hlt haben,
	lesen Sie die Hilfeseite des Treibers.  Die Hilfeseite enth&auml;lt
	weitere Informationen &uuml;ber die unterst&uuml;tzten Ger&auml;te
	und macht auch auf m&ouml;gliche Probleme aufmerksam.</para>

      <para>Wenn Sie eine gebr&auml;uchliche Karte besitzen, brauchen Sie
        meistens nicht lange nach dem passenden Treiber zu suchen.  Die
	Treiber zu diesen Karten sind schon im
	<filename>GENERIC</filename>-Kernel enthalten und die Karte sollte
	w&auml;hrend des Systemstarts erkannt werden:</para>

<screen>dc0: &lt;82c169 PNIC 10/100BaseTX&gt; port 0xa000-0xa0ff mem 0xd3800000-0xd38
000ff irq 15 at device 11.0 on pci0
dc0: Ethernet address: 00:a0:cc:da:da:da
miibus0: &lt;MII bus&gt; on dc0
ukphy0: &lt;Generic IEEE 802.3u media interface&gt; on miibus0
ukphy0:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
dc1: &lt;82c169 PNIC 10/100BaseTX&gt; port 0x9800-0x98ff mem 0xd3000000-0xd30
000ff irq 11 at device 12.0 on pci0
dc1: Ethernet address: 00:a0:cc:da:da:db
miibus1: &lt;MII bus&gt; on dc1
ukphy1: &lt;Generic IEEE 802.3u media interface&gt; on miibus1
ukphy1:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto</screen>

      <para>Im Beispiel erkennt das System zwei Karten, die den
        &man.dc.4; Treiber benutzen.</para>

      <para>Der richtige Treiber muss geladen sein, damit eine
        Netzwerkkarte benutzt werden kann.  Der Treiber kann auf zwei Arten
	geladen werden:  Am einfachsten laden Sie das Kernelmodul f&uuml;r
	Ihre Karte mit &man.kldload.8;.  F&uuml;r manche Netzwerkkarten
	gibt es kein Kernelmodul (beispielsweise f&uuml;r ISA-Karten, die
	den &man.ed.4; Treiber benutzen).  Die zweite M&ouml;glichkeit ist,
	die Unterst&uuml;tzung f&uuml;r Ihre Karte fest in den Kernel
	einzubinden.  Schauen Sie sich dazu
	<filename>/usr/src/sys/i386/conf/LINT</filename> und die Hilfeseite
	des Treibers, den Sie in den Kernel einbinden m&ouml;chten, an.
	Die &Uuml;bersetzung des Kernels wird in
	<xref linkend="kernelconfig"> beschrieben.  Wenn Ihre Karte
	w&auml;hrend des Systemstarts vom Kernel
	(<filename>GENERIC</filename>) erkannt wurde, m&uuml;ssen Sie den
	Kernel nicht neu &uuml;bersetzen.</para>
    </sect2>

    <sect2>
      <title>Konfiguration von Netzwerkkarten</title>

      <indexterm>
        <primary>Netzwerkkarten</primary>
        <secondary>konfigurieren</secondary>
      </indexterm>

      <para>Nachdem der richtige Treiber f&uuml;r die Karte geladen ist,
        muss die Karte konfiguriert werden.  Unter Umst&auml;nden ist
	die Karte schon w&auml;hrend der Installation mit
	<application>sysinstall</application> konfiguriert worden.</para>

      <para>Das nachstehende Kommando zeigt die Konfiguration der Karten
        eines Systems an:</para>

<screen>&prompt.user; <userinput>ifconfig</userinput>
dc0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet 192.168.1.3 netmask 0xffffff00 broadcast 192.168.1.255
        ether 00:a0:cc:da:da:da
        media: Ethernet autoselect (100baseTX &lt;full-duplex&gt;)
        status: active
dc1: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet 10.0.0.1 netmask 0xffffff00 broadcast 10.0.0.255
        ether 00:a0:cc:da:da:db
        media: Ethernet 10baseT/UTP
        status: no carrier
lp0: flags=8810&lt;POINTOPOINT,SIMPLEX,MULTICAST&gt; mtu 1500
lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 16384
        inet 127.0.0.1 netmask 0xff000000
tun0: flags=8010&lt;POINTOPOINT,MULTICAST&gt; mtu 1500</screen>

      <note>
	<para>In alten Versionen von &os; m&uuml;ssen Sie vielleicht
	  noch <option>-a</option> auf der Kommandozeile von &man.ifconfig.8;
	  angeben.  Hinweise zum Gebrauch von &man.ifconfig.8; entnehmen
	  Sie bitte der Hilfeseite.  Beachten Sie, dass in diesem
	  Beispiel die IPv6-Ausgaben (<literal>inet6</literal> etc.)
	  ausgelassen wurden.</para>
      </note>

      <para>Im Beispiel werden Informationen zu den folgenden Ger&auml;ten
        angezeigt:</para>

      <itemizedlist>
	<listitem>
	  <para><devicename>dc0</devicename>: Der erste
	    Ethernet-Adapter</para>
	</listitem>

	<listitem>
	  <para><devicename>dc1</devicename>: Der zweite
	    Ethernet-Adapter</para>
	</listitem>

	<listitem>
	  <para><devicename>lp0</devicename>: Die parallele
	    Schnittstelle</para>
	</listitem>

	<listitem>
	  <para><devicename>lo0</devicename>: Das Loopback-Ger&auml;t</para>
	</listitem>

	<listitem>
	  <para><devicename>tun0</devicename>: Das von
	    <application>ppp</application> benutzte Tunnel-Ger&auml;t</para>
	</listitem>
      </itemizedlist>

      <para>Der Name der Netzwerkkarte wird aus dem Namen des Treibers und
        einer Zahl zusammengesetzt.  Die Zahl gibt die Reihenfolge an, in
	der die Ger&auml;te beim Systemstart erkannt wurden.  Die dritte
	Karte, die den &man.sis.4; Treiber benutzt, w&uuml;rde
	beispielsweise <devicename>sis2</devicename> hei&szlig;en.</para>

      <para>Der Adapter <devicename>dc0</devicename> aus dem Beispiel ist
        aktiv.  Sie erkennen das an den folgenden Hinweisen:</para>

      <orderedlist>
	<listitem>
	  <para><literal>UP</literal> bedeutet, dass die Karte
	    konfiguriert und aktiv ist.</para>
	</listitem>

	<listitem>
	  <para>Der Karte wurde die Internet-Adresse (<literal>inet</literal>)
	    <hostid role="ipaddr">192.168.1.3</hostid> zugewiesen.</para>
	</listitem>

	<listitem>
	  <para>Die Subnetzmaske ist richtig
	    (<hostid role="netmask">0xffffff00</hostid> entspricht
	    <hostid role="netmask">255.255.255.0</hostid>).</para>
	</listitem>

	<listitem>
	  <para>Die Broadcast-Adresse <hostid
	    role="ipaddr">192.168.1.255</hostid> ist richtig.</para>
	</listitem>

	<listitem>
	  <para>Die MAC-Adresse der Karte (<literal>ether</literal>)
	    lautet <hostid role="mac">00:a0:cc:da:da:da</hostid>.</para>
	</listitem>

	<listitem>
	  <para>Die automatische Medienerkennung ist aktiviert
	    (<literal>media: Ethernet autoselect (100baseTX
	      &lt;full-duplex&gt;)</literal>).  Der Adapter
	    <devicename>dc1</devicename> benutzt das Medium
	    <literal>10baseT/UTP</literal>.  Weitere Informationen
	    &uuml;ber die einstellbaren Medien entnehmen
	    Sie bitte der Hilfeseite des Treibers.</para>
	</listitem>

	<listitem>
	  <para>Der Verbindungsstatus (<literal>status</literal>) ist
	    <literal>active</literal>, das hei&szlig;t es wurde ein
	    Tr&auml;gersignal entdeckt.  F&uuml;r
	    <devicename>dc1</devicename> wird <literal>status: no
	      carrier</literal> angezeigt.  Das ist normal, wenn kein Kabel
	    an der Karte angeschlossen ist.</para>
	</listitem>
      </orderedlist>

      <para>W&auml;re die Karte nicht konfiguriert, w&uuml;rde die Ausgabe
        von &man.ifconfig.8; so aussehen:</para>

<screen>dc0: flags=8843&lt;BROADCAST,SIMPLEX,MULTICAST&gt; mtu 1500
	        ether 00:a0:cc:da:da:da</screen>

      <para>Sie brauchen die Berechtigungen von <username>root</username>, um
        Ihre Karte zu konfigurieren.  Die Konfiguration kann auf der
	Kommandozeile mit &man.ifconfig.8; erfolgen, allerdings
	m&uuml;sste sie dann nach jedem Neustart wiederholt werden.
	Dauerhaft wird die Karte in <filename>/etc/rc.conf</filename>
	konfiguriert.</para>

      <para>&Ouml;ffnen Sie <filename>/etc/rc.conf</filename> mit Ihrem
        Lieblingseditor und f&uuml;gen Sie f&uuml;r jede Karte Ihres
	Systems eine Zeile hinzu.  In dem hier diskutierten Fall wurden
	die nachstehenden Zeilen eingef&uuml;gt:</para>

<programlisting>ifconfig_dc0="inet 192.168.1.3 netmask 255.255.255.0"
ifconfig_dc1="inet 10.0.0.1 netmask 255.255.255.0 media 10baseT/UTP"</programlisting>

      <para>Ersetzen Sie <devicename>dc0</devicename>,
        <devicename>dc1</devicename> usw. durch die Ger&auml;tenamen Ihrer
	Karten und setzen Sie die richtigen IP-Adressen ein.  Die
	Hilfeseiten des Treibers und &man.ifconfig.8; enthalten weitere
	Einzelheiten &uuml;ber verf&uuml;gbare Optionen.  Die Syntax von
	<filename>/etc/rc.conf</filename> wird in &man.rc.conf.5;
	erkl&auml;rt.</para>

      <para>Wenn Sie das Netz w&auml;hrend der Installation
        konfiguriert haben, existieren vielleicht schon Eintr&auml;ge
	f&uuml;r Ihre Karten.  &Uuml;berpr&uuml;fen Sie
	<filename>/etc/rc.conf</filename> bevor Sie weitere Zeilen
	hinzuf&uuml;gen.</para>

      <para>In <filename>/etc/hosts</filename> k&ouml;nnen Sie die Namen
        und IP-Adressen der Rechner Ihres LANs eintragen.  Weitere
	Informationen entnehmen Sie bitte &man.hosts.5; und
	<filename>/usr/share/examples/etc/hosts</filename>.</para>
    </sect2>

    <sect2>
      <title>Test und Fehlersuche</title>

      <para>Nachdem Sie die notwendigen &Auml;nderungen in
        <filename>/etc/rc.conf</filename> vorgenommen haben, f&uuml;hren
	Sie einen Neustart Ihres Systems durch.  Dadurch werden die Adapter
	konfiguriert und Sie stellen sicher, dass der Start ohne
	Konfigurationsfehler erfolgt.</para>

      <para>Wenn das System gestartet ist, sollten Sie die Netzwerkkarten
	testen.</para>

      <sect3>
	<title>Test der Ethernet-Karte</title>

        <indexterm>
          <primary>Netzwerkkarten</primary>
          <secondary>Test</secondary>
        </indexterm>

	<para>Mit zwei Tests k&ouml;nnen Sie pr&uuml;fen, ob die
	  Ethernet-Karte richtig konfiguriert ist.  Testen Sie zuerst mit
	  <command>ping</command> den Adapter selbst und sprechen Sie dann
	  eine andere Maschine im LAN an.</para>

	<para>Zuerst, der Test des Adapters:</para>

<screen>&prompt.user; <userinput>ping -c5 192.168.1.3</userinput>
PING 192.168.1.3 (192.168.1.3): 56 data bytes
64 bytes from 192.168.1.3: icmp_seq=0 ttl=64 time=0.082 ms
64 bytes from 192.168.1.3: icmp_seq=1 ttl=64 time=0.074 ms
64 bytes from 192.168.1.3: icmp_seq=2 ttl=64 time=0.076 ms
64 bytes from 192.168.1.3: icmp_seq=3 ttl=64 time=0.108 ms
64 bytes from 192.168.1.3: icmp_seq=4 ttl=64 time=0.076 ms

--- 192.168.1.3 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.074/0.083/0.108/0.013 ms</screen>

	<para>Jetzt versuchen wir, eine andere Maschine im LAN zu
	  erreichen:</para>

<screen>&prompt.user; <userinput>ping -c5 192.168.1.2</userinput>
PING 192.168.1.2 (192.168.1.2): 56 data bytes
64 bytes from 192.168.1.2: icmp_seq=0 ttl=64 time=0.726 ms
64 bytes from 192.168.1.2: icmp_seq=1 ttl=64 time=0.766 ms
64 bytes from 192.168.1.2: icmp_seq=2 ttl=64 time=0.700 ms
64 bytes from 192.168.1.2: icmp_seq=3 ttl=64 time=0.747 ms
64 bytes from 192.168.1.2: icmp_seq=4 ttl=64 time=0.704 ms

--- 192.168.1.2 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.700/0.729/0.766/0.025 ms</screen>

	<para>Sie k&ouml;nnen auch den Namen der Maschine anstelle von
	  <hostid role="ipaddr">192.168.1.2</hostid> benutzen, wenn Sie
	  <filename>/etc/hosts</filename> entsprechend eingerichtet
	  haben.</para>
      </sect3>

      <sect3>
	<title>Fehlersuche</title>

        <indexterm>
          <primary>Netzwerkkarten</primary>
          <secondary>Fehlersuche</secondary>
        </indexterm>

	<para>Fehler zu beheben, ist immer sehr m&uuml;hsam.
	  Indem Sie die einfachen Sachen zuerst pr&uuml;fen,
	  erleichtern Sie sich die Aufgabe.  Steckt das Netwerkkabel?
	  Sind die Netzwerkdienste richtig konfiguriert?  Funktioniert
	  die Firewall?  Wird die Netwerkkarte von &os;
	  unterst&uuml;tzt?  Bevor Sie einen Fehlerbericht einsenden,
	  sollten Sie sich immer die Hardware-Informationen des
	  Releases durchlesen.  Aktualisieren Sie Ihre &os;-Version
	  auf -STABLE.  Suchen Sie in den Archiven der Mailinglisten
	  oder auf dem Internet nach bekannten L&ouml;sungen.</para>

	<para>Wenn die Karte funktioniert, die Verbindungen aber
	  zu langsam sind, lesen Sie bitte die Hilfeseite
	  &man.tuning.7;.  Pr&uuml;fen Sie auch die
	  Netzwerkkonfiguration, da falsche Einstellungen die
	  Ursache f&uuml;r langsame Verbindungen sein k&ouml;nnen.</para>

	<para>Wenn Sie viele <errorname>device timeout</errorname>
	  Meldungen in den Systemprotokollen finden, pr&uuml;fen
	  Sie, dass es keinen Konflikt zwischen der Netzwerkkarte
	  und anderen Ger&auml;ten Ihres Systems gibt.
	  &Uuml;berpr&uuml;fen Sie nochmals die Verkabelung.
	  Unter Umst&auml;nden ben&ouml;tigen Sie eine neue
	  Netzwerkkarte.</para>

	<para>Wenn Sie in den Systemprotokollen
	  <errorname>watchdog timeout</errorname> Fehlermeldungen
	  finden, kontrollieren Sie zuerst die Verkabelung.
	  &Uuml;berpr&uuml;fen Sie dann, ob der PCI-Steckplatz der
	  Karte Bus Mastering unterst&uuml;tzt.  Auf einigen
	  &auml;lteren Motherboards ist das nur f&uuml;r einen
	  Steckplatz (meistens Steckplatz 0) der Fall.  Lesen Sie
	  in der Dokumentation Ihrer Karte und Ihres Motherboards
	  nach, ob das vielleicht die Ursache des Problems sein
	  k&ouml;nnte.</para>

	<para>Die Meldung <errorname>No route to host</errorname>
	  erscheint, wenn Ihr System ein Paket nicht zustellen
	  kann.  Das kann vorkommen weil beispielsweise keine
	  Default-Route gesetzt wurde oder das Netzwerkkabel
	  nicht richtig steckt.  Schauen Sie in der Ausgabe
	  von <command>netstat -rn</command> nach, ob eine
	  Route zu dem Zielsystem existiert.  Wenn nicht, lesen
	  Sie bitte das <xref linkend="advanced-networking">.</para>

	<para>Die Meldung <errorname>ping: sendto: Permission
	    denied</errorname> wird oft von einer falsch konfigurierten
	  Firewall verursacht.  Wenn keine Regeln definiert wurden,
	  blockiert eine aktivierte Firewall alle Pakete, selbst
	  einfache <command>ping</command>-Pakete.  Weitere
	  Informationen erhalten Sie in <xref linkend="firewalls">.</para>

	<para>Falls die Leistung der Karte schlecht ist, setzen
	  Sie die Medienerkennung von <literal>autoselect</literal>
	  (automatisch) auf das richtige Medium.  In vielen F&auml;llen
	  l&ouml;st diese Ma&szlig;nahme Leistungsprobleme.  Wenn
	  nicht, pr&uuml;fen Sie nochmal die Netzwerkeinstellungen
	  und lesen Sie die Hilfeseite &man.tuning.7;.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="configtuning-virtual-hosts">
    <title>Virtual Hosts</title>

    <indexterm><primary>virtual hosts</primary></indexterm>
    <indexterm><primary>IP-Aliase</primary></indexterm>

    <para>Ein gebr&auml;uchlicher Zweck von &os; ist das
      virtuelle Hosting, bei dem ein Server im Netzwerk wie
      mehrere Server aussieht.  Dies wird dadurch erreicht,
      dass einem Netzwerkinterface mehrere Netzwerk-Adressen
      zugewiesen werden.</para>

    <para>Ein Netzwerkinterface hat eine <quote>echte</quote>
      Adresse und kann beliebig viele <quote>alias</quote> Adressen
      haben.  Die Aliase werden durch entsprechende alias Eintr&auml;ge
      in <filename>/etc/rc.conf</filename> festgelegt.</para>

    <para>Ein alias Eintrag f&uuml;r das Interface
      <devicename>fxp0</devicename> sieht wie folgt aus:</para>

<programlisting>ifconfig_fxp0_alias0="inet xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx"</programlisting>

    <para>Beachten Sie, dass die alias Eintr&auml;ge mit alias0
      anfangen m&uuml;ssen und dann weiter hochgez&auml;hlt werden,
      das hei&szlig;t _alias1, _alias2, usw.
      Die Konfiguration der Aliase h&ouml;rt bei der ersten
      fehlenden Zahl auf.</para>

    <para>Die Berechnung der Alias-Netzwerkmasken ist wichtig, doch
      zum Gl&uuml;ck einfach.  F&uuml;r jedes Interface muss es
      eine Adresse geben, die die Netzwerkmaske des Netzwerkes richtig
      beschreibt.  Alle anderen Adressen in diesem Netzwerk haben dann
      eine Netzwerkmaske, die mit <literal>1</literal> gef&uuml;llt
      ist.</para>

    <para>Als Beispiel betrachten wir den Fall, in dem
      <devicename>fxp0</devicename> mit zwei Netzwerken verbunden
      ist: dem Netzwerk <hostid role="ipaddr">10.1.1.0</hostid> mit der
      Netzwerkmaske <hostid role="netmask">255.255.255.0</hostid>
      und dem Netzwerk <hostid role="ipaddr">202.0.75.16</hostid> mit der
      Netzwerkmaske <hostid role="netmask">255.255.255.240</hostid>.
      Das System soll die Adressen <hostid role="ipaddr">10.1.1.1</hostid>
      bis <hostid role="ipaddr">10.1.1.5</hostid> und
      <hostid role="ipaddr">202.0.75.17</hostid> bis
      <hostid role="ipaddr">202.0.75.20</hostid> belegen.</para>

    <para>Die folgenden Eintr&auml;ge konfigurieren den Adapter
      entsprechend dem Beispiel:</para>

<programlisting> ifconfig_fxp0="inet 10.1.1.1 netmask 255.255.255.0"
 ifconfig_fxp0_alias0="inet 10.1.1.2 netmask 255.255.255.255"
 ifconfig_fxp0_alias1="inet 10.1.1.3 netmask 255.255.255.255"
 ifconfig_fxp0_alias2="inet 10.1.1.4 netmask 255.255.255.255"
 ifconfig_fxp0_alias3="inet 10.1.1.5 netmask 255.255.255.255"
 ifconfig_fxp0_alias4="inet 202.0.75.17 netmask 255.255.255.240"
 ifconfig_fxp0_alias5="inet 202.0.75.18 netmask 255.255.255.255"
 ifconfig_fxp0_alias6="inet 202.0.75.19 netmask 255.255.255.255"
 ifconfig_fxp0_alias7="inet 202.0.75.20 netmask 255.255.255.255"</programlisting>

  </sect1>

  <sect1 id="configtuning-configfiles">
    <title>Konfigurationsdateien</title>

    <sect2>
      <title><filename>/etc</filename> Layout</title>
      <para>Konfigurationsdateien finden sich in einigen Verzeichnissen
	unter anderem in:</para>

      <informaltable frame="none">
	<tgroup cols="2">
	  <tbody>
	    <row>
	      <entry><filename>/etc</filename></entry>
	      <entry>Enth&auml;lt generelle Konfigurationsinformationen,
		die Daten hier sind systemspezifisch.</entry>
	    </row>
	    <row>
	      <entry><filename>/etc/defaults</filename></entry>
	      <entry>Default Versionen der Konfigurationsdateien.</entry>
	    </row>
	    <row>
	      <entry><filename>/etc/mail</filename></entry>
	      <entry>Enth&auml;lt die &man.sendmail.8; Konfiguration
		und weitere MTA Konfigurationsdateien.</entry>
	    </row>
	    <row>
	      <entry><filename>/etc/ppp</filename></entry>
	      <entry>Hier findet sich die Konfiguration f&uuml;r
		die User- und Kernel-ppp Programme.</entry>
	    </row>
	    <row>
	      <entry><filename>/etc/namedb</filename></entry>
	      <entry>Das Vorgabeverzeichnis, in dem Daten von
		&man.named.8; gehalten werden.  Normalerweise
		werden hier <filename>named.conf</filename> und Zonendaten
		abgelegt.</entry>
	    </row>
	    <row>
	      <entry><filename>/usr/local/etc</filename></entry>
	      <entry>Installierte Anwendungen legen hier ihre
		Konfigurationsdateien ab.  Dieses Verzeichnis kann
		Unterverzeichnisse f&uuml;r bestimmte Anwendungen
		enthalten.</entry>
	    </row>
	    <row>
	      <entry><filename>/usr/local/etc/rc.d</filename></entry>
	      <entry>Ort f&uuml;r Start- und Stopskripten installierter
		Anwendungen.</entry>
	    </row>
	    <row>
	      <entry><filename>/var/db</filename></entry>
	      <entry>Automatisch generierte systemspezifische Datenbanken,
	        wie die Paket-Datenbank oder die
		<command>locate</command>-Datenbank.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </sect2>

    <sect2>
      <title>Hostnamen</title>

      <indexterm><primary>hostname</primary></indexterm>
      <indexterm><primary>DNS</primary></indexterm>

      <sect3>
	<title><filename>/etc/resolv.conf</filename></title>

	<indexterm><primary><filename>resolv.conf</filename></primary></indexterm>

	<para>Wie der &os;-Resolver auf das Internet Domain Name
	  System (DNS) zugreift, wird in <filename>/etc/resolv.conf</filename>
	  festgelegt.</para>

	<para>Die gebr&auml;uchlichsten Eintr&auml;ge in
	  <filename>/etc/resolv.conf</filename> sind:</para>

	<informaltable frame="none">
	  <tgroup cols="2">
	    <tbody>
	      <row>
		<entry><literal>nameserver</literal></entry>
		<entry>Die IP-Adresse eines Nameservers, den
		  der Resolver abfragen soll.  Bis zu drei Server werden
		  in der Reihenfolge, in der sie aufgez&auml;hlt
		  sind, abgefragt.
	      </row>
	      <row>
		<entry><literal>search</literal></entry>
		<entry>Suchliste mit Domain-Namen zum Aufl&ouml;sen von
		  Hostnamen.  Die Liste wird normalerweise durch den
		  Domain-Teil des lokalen Hostnamens festgelegt.
	      </row>
	      <row>
		<entry><literal>domain</literal></entry>
		<entry>Der lokale Domain-Name.</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

	<para>Beispiel f&uuml;r eine typische
	  <filename>resolv.conf</filename>:</para>

	<programlisting>search example.com
nameserver 147.11.1.11
nameserver 147.11.100.30</programlisting>

	<note><para>Nur eine der Anweisungen <literal>search</literal>
	  oder <literal>domain</literal> sollte benutzt werden.</para></note>

	<para>Wenn Sie DHCP benutzen, &uuml;berschreibt &man.dhclient.8;
	  f&uuml;r gew&ouml;hnlich <filename>resolv.conf</filename>
	  mit den Informationen vom DHCP-Server.</para>
      </sect3>

      <sect3>
	<title><filename>/etc/hosts</filename></title>

	<indexterm><primary>hosts</primary></indexterm>

	<para><filename>/etc/hosts</filename> ist eine einfache textbasierte
	  Datenbank, die aus alten Internetzeiten stammt.  Zusammen
	  mit DNS und NIS stellt sie eine Abbildung zwischen Namen und
	  IP-Adressen zur Verf&uuml;gung.  Anstatt &man.named.8;
	  zu konfigurieren, k&ouml;nnen hier lokale Rechner, die &uuml;ber
	  ein LAN verbunden sind, eingetragen werden.  Lokale Eintr&auml;ge
	  f&uuml;r gebr&auml;uchliche Internet-Adressen in
	  <filename>/etc/hosts</filename> verhindern die Abfrage eines
	  externen Servers und beschleunigen die Namensaufl&ouml;sung.</para>

	<programlisting># &dollar;FreeBSD&dollar;
#
# Host Database
# This file should contain the addresses and aliases
# for local hosts that share this file.
# In the presence of the domain name service or NIS, this file may
# not be consulted at all; see /etc/nsswitch.conf for the resolution order.
#
#
::1                     localhost localhost.my.domain myname.my.domain
127.0.0.1               localhost localhost.my.domain myname.my.domain

#
# Imaginary network.
#10.0.0.2               myname.my.domain myname
#10.0.0.3               myfriend.my.domain myfriend
#
# According to RFC 1918, you can use the following IP networks for
# private nets which will never be connected to the Internet:
#
#       10.0.0.0        -   10.255.255.255
#       172.16.0.0      -   172.31.255.255
#       192.168.0.0     -   192.168.255.255
#
# In case you want to be able to connect to the Internet, you need
# real official assigned numbers.  PLEASE PLEASE PLEASE do not try
# to invent your own network numbers but instead get one from your
# network provider (if any) or from the Internet Registry (ftp to
# rs.internic.net, directory `/templates').
#</programlisting>

	<para><filename>/etc/hosts</filename> hat ein einfaches Format:</para>
	<programlisting>[Internet Adresse] [Offizieller Hostname] [Alias1] [Alias2] ...</programlisting>

	<para>Zum Beispiel:</para>

	<programlisting>10.0.0.1 myRealHostname.example.com myRealHostname foobar1 foobar2</programlisting>

	<para>Weitere Informationen entnehmen Sie bitte &man.hosts.5;.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Konfiguration von Logdateien</title>

      <indexterm><primary>Logdateien</primary></indexterm>

      <sect3>
	<title><filename>syslog.conf</filename></title>

	<indexterm><primary>syslog.conf</primary></indexterm>

	<para><filename>syslog.conf</filename> ist die Konfigurationsdatei
	  von &man.syslogd.8;.  Sie legt fest, welche
	  <application>syslog</application> Meldungen in welche
	  Logdateien geschrieben werden.</para>

	<programlisting># &dollar;FreeBSD&dollar;
#
#       Spaces ARE valid field separators in this file. However,
#       other *nix-like systems still insist on using tabs as field
#       separators. If you are sharing this file between systems, you
#       may want to use only tabs as field separators here.
#       Consult the syslog.conf(5) manpage.
*.err;kern.debug;auth.notice;mail.crit          /dev/console
*.notice;kern.debug;lpr.info;mail.crit;news.err /var/log/messages
security.*                                      /var/log/security
mail.info                                       /var/log/maillog
lpr.info                                        /var/log/lpd-errs
cron.*                                          /var/log/cron
*.err                                           root
*.notice;news.err                               root
*.alert                                         root
*.emerg                                         *
# uncomment this to log all writes to /dev/console to /var/log/console.log
#console.info                                   /var/log/console.log
# uncomment this to enable logging of all log messages to /var/log/all.log
#*.*                                            /var/log/all.log
# uncomment this to enable logging to a remote log host named loghost
#*.*                                            @loghost
# uncomment these if you're running inn
# news.crit                                     /var/log/news/news.crit
# news.err                                      /var/log/news/news.err
# news.notice                                   /var/log/news/news.notice
!startslip
*.*                                             /var/log/slip.log
!ppp
*.*                                             /var/log/ppp.log</programlisting>

	<para>Weitere Informationen enth&auml;lt &man.syslog.conf.5;.</para>
      </sect3>

      <sect3>
	<title><filename>newsyslog.conf</filename></title>

	<indexterm><primary>newsyslog.conf</primary></indexterm>

	<para>Die Konfigurationsdatei f&uuml;r &man.newsyslog.8;, das
	  normalerweise von &man.cron.8; aufgerufen wird, ist
	  <filename>newsyslog.conf</filename>.  &man.newsyslog.8;
	  stellt fest, ob Logdateien archiviert oder verschoben
	  werden m&uuml;ssen.  So wird <filename>logfile</filename>
	  nach <filename>logfile.0</filename> geschoben und
	  <filename>logfile.0</filename> nach <filename>logfile.1</filename>
	  usw.  Zudem k&ouml;nnen Logdateien mit &man.gzip.1;
	  komprimiert werden.  Die Namen der Logdateien sind dann
	  <filename>logfile.0.gz</filename>, <filename>logfile.1.gz</filename>
	  usw.</para>

	<para><filename>newsyslog.conf</filename> legt fest, welche
	  Logdateien wann bearbeitet und wie viele Dateien behalten werden.
	  Logdateien k&ouml;nnen auf Basis ihrer Gr&ouml;&szlig;e oder zu
	  einem gewissen Zeitpunkt archiviert bzw. umbenannt werden.</para>

	<programlisting># configuration file for newsyslog
# &dollar;FreeBSD&dollar;
#
# filename          [owner:group]    mode count size when [ZB] [/pid_file] [sig_num]
/var/log/cron                           600  3     100  *     Z
/var/log/amd.log                        644  7     100  *     Z
/var/log/kerberos.log                   644  7     100  *     Z
/var/log/lpd-errs                       644  7     100  *     Z
/var/log/maillog                        644  7     *    @T00  Z
/var/log/sendmail.st                    644  10    *    168   B
/var/log/messages                       644  5     100  *     Z
/var/log/all.log                        600  7     *    @T00  Z
/var/log/slip.log                       600  3     100  *     Z
/var/log/ppp.log                        600  3     100  *     Z
/var/log/security                       600  10    100  *     Z
/var/log/wtmp                           644  3     *    @01T05 B
/var/log/daily.log                      640  7     *    @T00  Z
/var/log/weekly.log                     640  5     1    $W6D0 Z
/var/log/monthly.log                    640  12    *    $M1D0 Z
/var/log/console.log                    640  5     100  *     Z</programlisting>

	<para>Um mehr zu erfahren, lesen Sie bitte &man.newsyslog.8;.</para>
      </sect3>
    </sect2>

    <sect2>
      <title><filename>sysctl.conf</filename></title>

      <indexterm><primary>sysctl.conf</primary></indexterm>
      <indexterm><primary>sysctl</primary></indexterm>

      <para><filename>sysctl.conf</filename> sieht &auml;hnlich
	wie <filename>rc.conf</filename> aus.  Werte werden in der
	Form <literal>Variable=Wert</literal> gesetzt.
	Die angegebenen Werte werden
	gesetzt, nachdem sich das System im Mehrbenutzer Modus befindet,
	das hei&szlig;t nicht alle Werte k&ouml;nnen in
	diesem Modus gesetzt werden.</para>

      <para>In der folgenden <filename>sysctl.conf</filename>  wird das
	Loggen von fatalen Signalen abgestellt und Linux Programmen
	wird klar gemacht, dass sie in Wirklichkeit unter
	&os; laufen:</para>

      <programlisting>kern.logsigexit=0       # Do not log fatal signal exits (e.g. sig 11)
compat.linux.osname=FreeBSD
compat.linux.osrelease=4.3-STABLE</programlisting>

    </sect2>
  </sect1>

  <sect1 id="configtuning-sysctl">
    <title>Einstellungen mit sysctl</title>

    <indexterm><primary>sysctl</primary></indexterm>
    <indexterm>
      <primary>Einstellungen</primary>
      <secondary>mit sysctl</secondary>
    </indexterm>

    <para>Mit &man.sysctl.8; k&ouml;nnen Sie &Auml;nderungen an
      einem laufenden &os; System vornehmen.  Unter anderem
      k&ouml;nnen Optionen des TCP/IP-Stacks oder des
      virtuellen Speichermanagements ver&auml;ndert werden.  Unter
      der Hand eines erfahrenen Systemadministrators kann dies
      die Systemperformance erheblich verbessern.  &Uuml;ber 500
      Variablen k&ouml;nnen mit &man.sysctl.8; gelesen und gesetzt
      werden.</para>

    <para>Der Hauptzweck von &man.sysctl.8; besteht darin, Systemeinstellungen
      zu lesen und zu ver&auml;ndern.</para>

    <para>Alle auslesbaren Variablen werden wie folgt angezeigt:</para>

    <screen>&prompt.user; <userinput>sysctl -a</userinput></screen>

    <para>Sie k&ouml;nnen auch eine spezielle Variable, z.B.
      <varname>kern.maxproc</varname> lesen:</para>

    <screen>&prompt.user; <userinput>sysctl kern.maxproc</userinput>
kern.maxproc: 1044</screen>

    <para>Um eine Variable zu setzen, benutzen Sie die Syntax
      <replaceable>Variable</replaceable>=
      <replaceable>Wert</replaceable>:</para>

    <screen>&prompt.root; <userinput>sysctl kern.maxfiles=5000</userinput>
kern.maxfiles: 2088 -> 5000</screen>

    <para>Mit sysctl k&ouml;nnen Sie Strings, Zahlen oder
      Boolean-Werte setzen.  Bei Boolean-Werten setzen sie <literal>1</literal>
      f&uuml;r wahr und <literal>0</literal> f&uuml;r falsch.</para>

    <sect2 id="sysctl-readonly">
      <sect2info>
        <authorgroup>
          <author>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	    <contrib>Contributed by </contrib>
	    <!-- 31 January 2003 -->
          </author>
        </authorgroup>
      </sect2info>
      <title>Schreibgesch&uuml;tzte Variablen</title>

      <para>Manchmal ist es notwendig, obwohl es nicht
	empfohlen ist, schreibgesch&uuml;tzte
	sysctl-Variablen zu ver&auml;ndern.</para>

      <para>Beispielsweise hat &man.cardbus.4; auf einigen Laptops
	Schwierigkeiten, Speicherbereiche zu erkennen.  Es treten
	dann Fehlermeldungen wie die folgende auf:</para>

      <screen>cbb0: Could not map register memory
device_probe_and_attach: cbb0 attach returned 12</screen>

      <para>Um dieses Problem zu l&ouml;sen, muss eine
        schreibgesch&uuml;tzte sysctl-Variable ver&auml;ndert
	werden.  Eine <acronym>OID</acronym> kann in der Datei
	<filename>/boot/loader.conf.local</filename> &uuml;berschrieben
	werden.  Die Datei <filename>/boot/defaults/loader.conf</filename>
	enth&auml;lt Vorgabewwerte f&uuml;r sysctl-Variablen.</para>

      <para>Das oben erw&auml;hnte Problem wird durch die Angabe von
	<option>hw.pci.allow_unsupported_io_range=1</option> in
	<filename>/boot/loader.conf.local</filename> gel&ouml;st.
	Danach sollte &man.cardbus.4; fehlerfrei funktionieren.</para>
    </sect2>
  </sect1>

  <sect1 id="configtuning-disk">
    <title>Tuning von Laufwerken</title>

    <sect2>
      <title>Sysctl Variablen</title>

      <sect3>
	<title><varname>vfs.vmiodirenable</varname></title>

	<indexterm>
	  <primary><varname>vfs.vmiodirenable</varname></primary>
	</indexterm>

	<para>Die Variable <varname>vfs.vmiodirenable</varname> besitzt
	  in der Voreinstellung den Wert 1.  Die Variable kann auf den Wert
	  0 (ausgeschaltet) oder 1 (angeschaltet) gesetzt werden.  Sie
	  steuert, wie Verzeichnisse vom System zwischengespeichert
	  werden.  Die meisten Verzeichnisse sind klein und benutzen
	  nur ein einzelnes Fragment, typischerweise 1&nbsp;kB, im Dateisystem.
	  Im Buffer-Cache verbrauchen sie mit 512&nbsp;Bytes noch weniger
	  Platz.  In der Voreinstellung wird der Buffer-Cache nur
	  eine limitierte Anzahl Verzeichnisse zwischenspeichern, auch
	  wenn das System &uuml;ber sehr viel Speicher verf&uuml;gt.
	  Wenn Sie diese Variable aktivieren, kann der Buffer-Cache den
	  VM-Page-Cache benutzen, um Verzeichnisse zwischenzuspeichern.
	  Der ganze Speicher steht damit zum Zwischenspeichern von
	  Verzeichnissen zur Verf&uuml;gung.  Der Nachteil bei dieser
	  Vorgehensweise ist, dass zum Zwischenspeichern eines
	  Verzeichnisses mindestens eine physikalische Seite im Speicher,
	  die normalerweise 4&nbsp;kB gro&szlig; ist, anstelle von 512&nbsp;Bytes
	  gebraucht wird.  Wir empfehlen diese Option zu aktivieren,
	  wenn Sie Dienste zur Verf&uuml;gung stellen, die viele
	  Dateien manipulieren.  Beispiele f&uuml;r
	  solche Dienste sind Web-Caches, gro&szlig;e Mail-Systeme oder
	  Netnews.  Trotz des verschwendeten Speichers vermindert
	  das Aktivieren dieser Variable in aller Regel nicht die
	  Leistung des Systems, obwohl Sie das nachpr&uuml;fen sollten.</para>
      </sect3>

      <sect3>
	<title><varname>vfs.write_behind</varname></title>

	<indexterm>
	  <primary><varname>vfs.write_behind</varname></primary>
	</indexterm>

	<para>In der Voreinstellung besitzt die Variable
	  <varname>vfs.write_behind</varname> den Wert
	  <literal>1</literal> (aktiviert).  Mit dieser Einstellung
	  schreibt das Dateisystem anfallende vollst&auml;ndige Cluster,
	  die besonders beim sequentiellen Schreiben gro&szlig;er Dateien
	  auftreten, direkt auf das Medium aus.  Dies verhindert,
	  dass sich im Buffer-Cache ver&auml;nderte Puffer
	  (<foreignphrase>dirty buffers</foreignphrase>) ansammeln,
	  die die I/O-Verarbeitung nicht mehr beschleunigen
	  w&uuml;rden.  Unter bestimmten Umst&auml;nden blockiert
	  diese Funktion allerdings Prozesse.  Setzen Sie in diesem
	  Fall die Variable <varname>vfs.write_behind</varname> auf
	  den Wert <literal>0</literal>.</para>
      </sect3>

      <sect3>
	<title><varname>vfs.hirunningspace</varname></title>

	<indexterm>
	  <primary><varname>vfs.hirunningspace</varname></primary>
	</indexterm>

	<para>Die Variable <varname>vfs.hirunningspace</varname>
	  bestimmt systemweit die Menge ausstehender Schreiboperationen,
	  die dem Platten-Controller zu jedem beliebigen Zeitpunkt
	  &uuml;bergeben werden k&ouml;nnen.  Normalerweise k&ouml;nnen
	  Sie den Vorgabewert verwenden.  Auf Systemen mit
	  vielen Platten kann der Wert aber auf 4 bis
	  5&nbsp;<emphasis>Megabyte</emphasis> erh&ouml;ht werden.
	  Beachten Sie, dass ein zu hoher Wert (gr&ouml;&szlig;er
	  als der Schreib-Schwellwert des Buffer-Caches) zu
	  Leistungverlusten f&uuml;hren kann.  Setzen Sie den Wert daher
	  nicht zu hoch!  Hohe Werte k&ouml;nnen auch Leseoperationen
	  verz&ouml;gern, die gleichzeitig mit Schreiboperationen
	  ausgef&uuml;hrt werden.</para>

	<para>Es gibt weitere Variablen, mit denen Sie den Buffer-Cache
	  und den VM-Page-Cache beeinflussen k&ouml;nnen.  Wir raten
	  Ihnen allerdings davon ab, diese Variablen zu ver&auml;ndern:
	  Seit &os;&nbsp;4.3 stellt sich die Verwaltung des virtuellen
	  Speichers sehr gut selbst ein.</para>
      </sect3>

      <sect3>
	<title><varname>vm.swap_idle_enabled</varname></title>

	<indexterm>
	  <primary><varname>vm.swap_idle_enabled</varname></primary>
	</indexterm>

	<para>Die Variable <varname>vm.swap_idle_enabled</varname>
	  ist f&uuml;r gro&szlig;e Mehrbenutzer-Systeme gedacht, auf
	  denen sich viele Benutzer an- und abmelden und auf denen
	  es viele Prozesse im Leerlauf
	  (<foreignphrase>idle</foreignphrase>) gibt.  Solche Systeme
	  fragen kontinuierlich freien Speicher an.  Wenn Sie die
	  Variable <varname>vm.swap_idle_enabled</varname> aktivieren,
	  k&ouml;nnen Sie die Auslagerungs-Hysterese von Seiten mit
	  den Variablen <varname>vm.swap_idle_threshold1</varname> und
	  <varname>vm.swap_idle_threshold2</varname> einstellen.  Die
	  Schwellwerte beider Variablen geben die Zeit in Sekunden an,
	  in denen sich ein Prozess im Leerlauf befinden muss.  Wenn die
	  Werte so eingestellt sind, dass Seiten fr&uuml;her als nach dem
	  normalen Algorithmus ausgelagert werden, verschafft das dem
	  Auslagerungs-Prozess mehr Luft.  Aktivieren Sie diese Funktion
	  nur, wenn Sie sie wirklich ben&ouml;tigen:  Die Speicherseiten
	  werden eher fr&uuml;her als sp&auml;ter ausgelagert.  Der
	  Platz im Swap-Bereich wird dadurch schneller verbraucht und
	  die Plattenaktivit&auml;ten steigen an.  Auf kleine Systeme
	  hat diese Funktion sp&uuml;rbare Auswirkungen.  Auf gro&szlig;en
	  Systemen, die sowieso schon Seiten auslagern m&uuml;ssen,
	  k&ouml;nnen ganze Prozesse leichter in den Speicher geladen
	  oder ausgelagert werden.</para>
      </sect3>

      <sect3>
	<title><varname>hw.ata.wc</varname></title>

	<indexterm>
	  <primary><varname>hw.ata.wc</varname></primary>
	</indexterm>

	<para>In &os;&nbsp;4.3 wurde versucht, den IDE-Schreib-Zwischenspeicher
	  abzustellen.  Obwohl dies die Bandbreite zum Schreiben auf
	  IDE-Platten verringerte, wurde es aus Gr&uuml;nden der
	  Datenkonsistenz als notwenig angesehen.  Der Kern des
	  Problems ist, dass IDE-Platten keine zuverl&auml;ssige
	  Aussage &uuml;ber das Ende eines Schreibvorgangs treffen.
	  Wenn der Schreib-Zwischenspeicher aktiviert ist, werden die Daten
	  nicht in der Reihenfolge ihres Eintreffens geschrieben.  Es kann
	  sogar passieren, dass das Schreiben mancher Bl&ouml;cke
	  im Fall von starker Plattenaktivit&auml;t auf unbefristete
	  Zeit verz&ouml;gert wird.  Ein Absturz oder Stromausfall
	  zu dieser Zeit kann die Dateisysteme erheblich besch&auml;digen.
	  Wir entschieden uns daher f&uuml;r die sichere Variante
	  und stellten den Schreib-Zwischenspeicher ab.  Leider war
	  damit auch ein gro&szlig;er Leistungsverlust verbunden, so
	  dass wir die Variable
	  nach dem Release wieder aktiviert haben.  Sie sollten den
	  Wert der Variable <varname>hw.ata.wc</varname> auf Ihrem
	  System &uuml;berpr&uuml;fen.  Wenn der Schreib-Zwischenspeicher
	  abgestellt ist, k&ouml;nnen Sie ihn aktivieren, indem Sie die
	  Variable auf den Wert 1 setzen.  Dies muss zum Zeitpunkt
	  des Systemstarts im Boot-Loader geschehen.  Eine &Auml;nderung
	  der Variable, nachdem der Kernel gestartet ist, hat keine
	  Auswirkungen.</para>

	<para>Weitere Informationen finden Sie in &man.ata.4;.</para>
      </sect3>

      <sect3>
	<title><option>SCSI_DELAY</option>
	  (<varname>kern.cam.scsi_delay</varname>)</title>

	<indexterm>
	  <primary><option>SCSI_DELAY</option></primary>
	  <secondary><varname>kern.cam.scsi_delay</varname></secondary>
	</indexterm>

	<para>Mit der Kerneloption <option>SCSI_DELAY</option> kann
	  die Dauer des Systemstarts verringert werden.  Der Vorgabewert
	  ist recht hoch und er verz&ouml;gert den Systemstart um 15 oder
	  mehr Sekunden.  Normalerweise kann dieser Wert, insbesondere
	  mit modernen Laufwerken, auf 5&nbsp;Sekunden heruntergesetzt
	  werden.  Ab &os;&nbsp;5.0 wird dazu die
	  <command>sysctl</command>-Variable
	  <varname>kern.cam.scsi_delay</varname> benutzt.  Die Variable
	  sowie die Kerneloption verwenden f&uuml;r die Zeitangabe
	  Millisekunden und <emphasis>nicht</emphasis> Sekunden.</para>
      </sect3>
    </sect2>

    <sect2 id="soft-updates">
      <title>Soft Updates</title>

      <indexterm><primary>Soft Updates</primary></indexterm>
      <indexterm><primary>tunefs</primary></indexterm>

      <para>Mit &man.tunefs.8; lassen sich Feineinstellungen an
	Dateisystemen vornehmen.  Das Programm hat verschiedene Optionen,
	von denen hier nur Soft Updates betrachtet werden.  Soft Updates
	werden wie folgt ein- und ausgeschaltet:</para>

      <screen>&prompt.root; <userinput>tunefs -n enable /filesystem</userinput>
&prompt.root; <userinput>tunefs -n disable /filesystem</userinput></screen>

      <para>Ein eingeh&auml;ngtes Dateisystem kann nicht mit &man.tunefs.8;
	modifiziert werden.  Soft Updates werden am besten im Single-User
	Modus aktiviert, bevor Partitionen eingehangen sind.</para>

      <note><para>Ab &os;&nbsp;4.5 k&ouml;nnen Sie Soft Updates mit der
        Option <literal>-U</literal> von &man.newfs.8; beim Anlegen der
	Dateisysteme aktivieren.</para></note>

      <para>Durch Einsatz eines Zwischenspeichers wird die Performance
	im Bereich der Metadaten, vorwiegend beim Anlegen und L&ouml;schen
	von Dateien, gesteigert.  Wir empfehlen, Soft Updates auf allen
	Dateisystemen zu aktivieren.  Allerdings sollten Sie sich &uuml;ber
	die zwei Nachteile von Soft Updates bewusst sein:
	Erstens garantieren Soft Updates zwar die Konsistenz der Daten
	im Fall eines Absturzes, aber es kann leicht passieren, dass
	das Dateisystem &uuml;ber mehrere Sekunden oder gar eine Minute
	nicht synchronisiert wurde.  Im Fall eines Absturzes verlieren
	Sie mit Soft Updates unter Umst&auml;nden mehr Daten als ohne.
	Zweitens verz&ouml;gern Soft Updates die Freigabe von
	Datenbl&ouml;cken.  Eine gr&ouml;&szlig;ere Aktualisierung
	eines fast vollen Dateisystems, wie dem Root-Dateisystem,
	z.B. w&auml;hrend eines <command>make installworld</command>,
	kann das Dateisystem vollaufen lassen.  Dadurch w&uuml;rde
	die Aktualisierung fehlschlagen.</para>

      <sect3>
	<title>Details &uuml;ber Soft Updates</title>

	<indexterm>
	  <primary>Soft Updates</primary>
	  <secondary>Details</secondary>
	</indexterm>

	<para>Es gibt zwei klassische Herangehensweisen, wie
	  man die Metadaten des Dateisystems (also Daten
	  &uuml;ber Dateien, wie inode Bereiche oder Verzeichniseintr&auml;ge)
	  aktualisiert auf die Platte zur&uuml;ckschreibt:</para>

	<para>Das historisch &uuml;bliche Verfahren waren synchrone
	  Updates der Metadaten, d. h. wenn eine &Auml;nderung an
	  einem Verzeichnis n&ouml;tig war, wurde anschlie&szlig;end
	  gewartet, bis diese &Auml;nderung tats&auml;chlich auf die
	  Platte zur&uuml;ckgeschrieben worden war.  Der
	  <emphasis>Inhalt</emphasis> der Dateien wurde im
	  <quote>Buffer Cache</quote> zwischengespeichert und
	  asynchron irgendwann sp&auml;ter auf die Platte geschrieben.
	  Der Vorteil dieser Implementierung ist, dass sie
	  sicher funktioniert.  Wenn w&auml;hrend eines Updates ein
	  Ausfall erfolgt, haben die Metadaten immer einen
	  konsistenten Zustand.  Eine Datei ist entweder komplett
	  angelegt oder gar nicht.  Wenn die Datenbl&ouml;cke einer
	  Datei im Fall eines Absturzes noch nicht den Weg aus dem
	  <quote>Buffer Cache</quote> auf die Platte gefunden haben,
	  kann &man.fsck.8; das Dateisystem reparieren, indem es die
	  Dateil&auml;nge einfach auf 0 setzt.  Au&szlig;erdem
	  ist die Implementierung einfach und &uuml;berschaubar.  Der
	  Nachteil ist, dass &Auml;nderungen der Metadaten sehr
	  langsam vor sich gehen.  Ein <command>rm -r</command>
	  beispielsweise fasst alle Dateien eines Verzeichnisses
	  der Reihe nach an, aber jede dieser &Auml;nderungen am
	  Verzeichnis (L&ouml;schen einer Datei) wird einzeln synchron
	  auf die Platte geschrieben.  Gleiches beim Auspacken
	  gro&szlig;er Hierarchien (<command>tar -x</command>).</para>

	<para>Der zweite Fall sind asynchrone Metadaten-Updates.  Das
	  ist z. B. der Standard bei Linux/ext2fs oder die Variante
	  <command>mount -o async</command> f&uuml;r *BSD UFS.  Man
	  schickt die Updates der Metadaten einfach auch noch
	  &uuml;ber den <quote>Buffer Cache</quote>, sie werden also
	  zwischen die Updates der normalen Daten eingeschoben.
	  Vorteil ist, dass man nun nicht mehr auf jeden Update
	  warten muss, Operationen, die zahlreiche Metadaten
	  &auml;ndern, werden also viel schneller.  Auch
	  hier ist die Implementierung sehr einfach und wenig
	  anf&auml;llig f&uuml;r Fehler.  Nachteil ist, dass
	  keinerlei Konsistenz des Dateisystems mehr gesichert ist.
	  Wenn mitten in einer Operation, die viele Metadaten
	  &auml;ndert, ein Ausfall erfolgt (Stromausfall, dr&uuml;cken
	  des Reset-Tasters), dann ist das Dateisystem
	  anschlie&szlig;end in einem unbestimmten Zustand.  Niemand
	  kann genau sagen, was noch geschrieben worden ist und was
	  nicht mehr; die Datenbl&ouml;cke einer Datei k&ouml;nnen
	  schon auf der Platte stehen, w&auml;hrend die inode Tabelle
	  oder das zugeh&ouml;rige Verzeichnis nicht mehr aktualisiert
	  worden ist.  Man kann praktisch kein <command>fsck</command>
	  mehr implementieren, das diesen Zustand
	  wieder reparieren kann, da die dazu n&ouml;tigen
	  Informationen einfach auf der Platte fehlen.  Wenn ein
	  Dateisystem derart besch&auml;digt worden ist, kann man es
	  nur neu erzeugen (&man.newfs.8;) und die Daten
	  vom Backup zur&uuml;ckspielen.
	  </para>

	<para>Der historische Ausweg aus diesem Dilemma war ein
	  <emphasis>dirty region logging</emphasis> (auch als
	  <emphasis>Journalling</emphasis> bezeichnet, wenngleich
	  dieser Begriff nicht immer gleich benutzt und manchmal auch
	  f&uuml;r andere Formen von Transaktionsprotokollen gebraucht
	  wird).  Man schreibt die Metadaten-Updates zwar synchron,
	  aber nur in einen kleinen Plattenbereich, die
	  <emphasis>logging area</emphasis>.  Von da aus werden sie
	  dann asynchron auf ihre eigentlichen Bereiche verteilt.  Da
	  die <emphasis>logging area</emphasis> ein kleines
	  zusammenh&auml;ngendes St&uuml;ckchen ist, haben die
	  Schreibk&ouml;pfe der Platte bei massiven Operationen auf
	  Metadaten keine allzu gro&szlig;en Wege zur&uuml;ckzulegen,
	  so dass alles ein ganzes St&uuml;ck schneller geht als
	  bei klassischen synchronen Updates.  Die Komplexit&auml;t
	  der Implementierung h&auml;lt sich ebenfalls in Grenzen,
	  somit auch die Anf&auml;lligkeit f&uuml;r Fehler.  Als
	  Nachteil ergibt sich, dass Metadaten zweimal auf die
	  Platte geschrieben werden m&uuml;ssen (einmal in die
	  <emphasis>logging area</emphasis>, einmal an die richtige
	  Stelle), so dass das im Falle regul&auml;rer
	  Arbeit (also keine geh&auml;uften Metadatenoperationen) eine
	  <quote>Pessimisierung</quote> des Falls der synchronen
	  Updates eintritt, es wird alles langsamer.  Daf&uuml;r hat man
	  als Vorteil, dass im Falle eines Crashes der
	  konsistente Zustand dadurch erzielbar ist, dass die
	  angefangenen Operationen aus dem <emphasis>dirty region
	  log</emphasis> entweder zu Ende ausgef&uuml;hrt oder
	  komplett verworfen werden, wodurch das Dateisystem schnell
	  wieder zur Verf&uuml;gung steht.</para>

	<para>Die L&ouml;sung von Kirk McKusick, dem Sch&ouml;pfer von
	  Berkeley FFS, waren <emphasis>Soft Updates</emphasis>: die
	  notwendigen Updates der Metadaten werden im Speicher
	  gehalten und dann sortiert auf die Platte geschrieben
	  (<quote>ordered metadata updates</quote>).  Dadurch hat man
	  den Effekt, dass im Falle massiver
	  Metadaten-&Auml;nderungen sp&auml;tere Operationen die
	  vorhergehenden, noch nicht auf die Platte geschriebenen
	  Updates desselben Elements im Speicher
	  <quote>einholen</quote>.  Alle Operationen, auf ein
	  Verzeichnis beispielsweise, werden also in der Regel noch im
	  Speicher abgewickelt, bevor der Update &uuml;berhaupt auf
	  die Platte geschrieben wird (die dazugeh&ouml;rigen
	  Datenbl&ouml;cke werden nat&uuml;rlich auch so sortiert,
	  dass sie nicht vor ihren Metadaten auf der Platte
	  sind).  Im Fall eines Absturzes hat man ein implizites <quote>log
	    rewind</quote>: alle Operationen, die noch nicht den Weg auf
	  die Platte gefunden haben, sehen danach so aus, als
	  h&auml;tten sie nie stattgefunden.  Man hat so also den
	  konsistenten Zustand von ca. 30 bis 60&nbsp;Sekunden fr&uuml;her
	  sichergestellt.  Der verwendete Algorithmus garantiert
	  dabei, dass alle tats&auml;chlich benutzten Ressourcen
	  auch in den entsprechenden Bitmaps (Block- und inode
	  Tabellen) als belegt markiert sind.  Der einzige Fehler, der
	  auftreten kann, ist, dass Ressourcen noch als
	  <quote>belegt</quote> markiert sind, die tats&auml;chlich
	  <quote>frei</quote> sind.  &man.fsck.8; erkennt dies und
	  korrigiert diese nicht mehr belegten Ressourcen.  Die
	  Notwendigkeit eines Dateisystem-Checks darf aus diesem
	  Grunde auch ignoriert und das Dateisystem mittels
	  <command>mount -f</command> zwangsweise eingebunden werden.
	  Um noch allozierte Ressourcen freizugeben muss
	  sp&auml;ter ein &man.fsck.8; nachgeholt werden.  Das ist
	  dann auch die Idee des <emphasis>background fsck</emphasis>:
	  beim Starten des Systems wird lediglich ein
	  <emphasis>Schnappschuss</emphasis> des Filesystems
	  gemacht, mit dem &man.fsck.8; dann sp&auml;ter arbeiten
	  kann.  Alle Dateisysteme d&uuml;rfen <quote>unsauber</quote>
	  eingebunden werden und das System kann sofort in den
	  Multiuser-Modus gehen.  Danach wird ein
	  Hintergrund-<command>fsck</command> f&uuml;r die
	  Dateisysteme gestartet, die dies ben&ouml;tigen, um
	  m&ouml;glicherweise irrt&uuml;mlich belegte Ressourcen
	  freizugeben.  (Dateisysteme ohne <emphasis>Soft
	  Updates</emphasis> ben&ouml;tigen nat&uuml;rlich immer noch
	  den &uuml;blichen (Vordergrund-)<command>fsck</command>,
	  bevor sie eingebunden werden k&ouml;nnen.)</para>

	<para>Der Vorteil ist, dass die Metadaten-Operationen
	  beinahe so schnell ablaufen wie im asynchronen Fall (also
	  durchaus auch schneller als beim <quote>logging</quote>, das
	  ja die Metadaten immer zweimal schreiben muss).  Als
	  Nachteil stehen dem die Komplexit&auml;t des Codes (mit
	  einer erh&ouml;hten Fehlerwahrscheinlichkeit in einem
	  bez&uuml;glich Datenverlust hoch sensiblen Bereich) und ein
	  erh&ouml;hter Speicherverbrauch entgegen.  Au&szlig;erdem
	  muss man sich an einige Eigenheiten
	  gew&ouml;hnen: Nach einem Absturz ist ein etwas &auml;lterer
	  Stand auf der Platte &ndash; statt einer leeren, aber bereits
	  angelegten Datei (wie nach einem herk&ouml;mmlichen
	  <command>fsck</command> Lauf) ist auf einem Dateisystem mit
	  <emphasis>Soft Updates</emphasis> keine Spur der
	  entsprechenden Datei mehr zu sehen, da weder die Metadaten
	  noch der Dateiinhalt je auf die Platte geschrieben wurden.
	  Weiterhin kann der Platz nach einem <command>rm -r</command>
	  nicht sofort wieder als verf&uuml;gbar markiert werden,
	  sondern erst dann, wenn der Update auch auf die Platte
	  vermittelt worden ist.  Dies kann besonders dann Probleme
	  bereiten, wenn gro&szlig;e Datenmengen in einem Dateisystem
	  ersetzt werden, das nicht gen&uuml;gend Platz hat, um alle
	  Dateien zweimal unterzubringen.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="configtuning-kernel-limits">
    <title>Einstellungen von Kernel Limits</title>

    <indexterm>
      <primary>Einstellungen</primary>
      <secondary>von Kernel Limits</secondary>
    </indexterm>

    <sect2 id="file-process-limits">
      <title>Datei und Proze&szlig; Limits</title>

      <sect3 id="kern-maxfiles">
	<title><varname>kern.maxfiles</varname></title>

	<indexterm>
	  <primary><varname>kern.maxfiles</varname></primary>
	</indexterm>

	<para>Abh&auml;ngig von den Anforderungen Ihres Systems
	  kann <varname>kern.maxfiles</varname> erh&ouml;ht oder
	  erniedrigt werden.  Die Variable legt die maximale
	  Anzahl von Dateideskriptoren auf Ihrem System fest.  Wenn
	  die Dateideskriptoren aufgebraucht sind, werden Sie
	  die Meldung <errorname>file: table is full</errorname>
	  wiederholt im Puffer f&uuml;r Systemmeldungen sehen.  Den
	  Inhalt des Puffers k&ouml;nnen Sie sich mit <command>dmesg</command>
	  anzeigen lassen.</para>

	<para>Jede offene Datei, jedes Socket und jede FIFO verbraucht
	  einen Dateideskriptor.  Auf <quote>dicken</quote> Produktionsservern
	  k&ouml;nnen leicht Tausende Dateideskriptoren ben&ouml;tigt
	  werden, abh&auml;ngig von der Art und Anzahl der gleichzeitig
	  laufenden Dienste.</para>

	<para>Die Voreinstellung von <varname>kern.maxfile</varname>
	  wird von <option>MAXUSERS</option> aus Ihrer Kernelkonfiguration
	  bestimmt.  <varname>kern.maxfiles</varname> w&auml;chst
	  proportional mit dem Wert von <option>MAXUSERS</option>.
	  Wenn Sie einen angepassten Kernel kompilieren, empfiehlt es sich
	  diese Option entsprechend der maximalen Benutzerzahl Ihres
	  Systems einzustellen.  Obwohl auf einer Produktionsmaschine
	  vielleicht nicht 256 Benutzer gleichzeitig angemeldet sind,
	  k&ouml;nnen die ben&ouml;tigten Ressourcen &auml;hnlich denen
	  eines gro&szlig;en Webservers sein.</para>

	<note><para>Ab &os;&nbsp;4.5 k&ouml;nnen Sie <option>MAXUSERS</option>
	  in der Kernelkonfiguration auf <literal>0</literal> setzen.  Das
	  System setzt dann automatisch einen passenden Wert, der von der
	  Gr&ouml;&szlig;e Ihres Hauptspeichers abh&auml;ngt,
	  ein.</para></note>
      </sect3>

      <sect3>
	<title><varname>kern.ipc.somaxconn</varname></title>

	<indexterm>
	  <primary><varname>kern.ipc.somaxconn</varname></primary>
	</indexterm>

	<para>Die Variable <varname>kern.ipc.somaxconn</varname>
	  beschr&auml;nkt die Gr&ouml;&szlig;e der Warteschlange
	  (<foreignphrase>Listen-Queue</foreignphrase>) f&uuml;r
	  neue TCP-Verbindungen.  Der Vorgabewert von
	  <literal>128</literal> ist normalerweise zu klein, um neue
	  Verbindungen auf einem stark ausgelasteten Webserver
	  zuverl&auml;ssig zu handhaben.  Auf solchen Servern sollte
	  der Wert auf <literal>1024</literal> oder h&ouml;her gesetzt
	  werden.  Ein Dienst (z.B. &man.sendmail.8;, oder
	  <application>Apache</application>) kann die Gr&ouml;&szlig;e
	  der Queue selbst einschr&auml;nken.  Oft gibt es die
	  M&ouml;glichkeit, die Gr&ouml;&szlig;e der Listen-Queue in
	  einer Konfigurationsdatei einzustellen.  Eine gro&szlig;e
	  Listen-Queue &uuml;bersteht vielleicht auch einen
	  Denial of Service Angriff (<abbrev>DoS</abbrev>).</para>
      </sect3>
    </sect2>
    <sect2>
      <title>Netzwerk Limits</title>

      <para>Die Kerneloption <option>NMBCLUSTERS</option> schreibt
	die Anzahl der Netzwerkpuffer (Mbufs) fest, die das System besitzt.
	Eine zu geringe Anzahl Mbufs auf einem Server mit viel Netzwerkverkehr
	verringert die Leistung von &os;.  Jeder Mbuf-Cluster nimmt
	ungef&auml;hr 2&nbsp;kB Speicher in Anspruch, so dass ein Wert
	von 1024 insgesamt 2&nbsp;Megabyte Speicher f&uuml;r Netzwerkpuffer
	im System reserviert.  Wie viele Cluster ben&ouml;tigt werden,
	l&auml;sst sich durch eine einfache Berechnung herausfinden.
	Wenn Sie einen Webserver besitzen, der maximal 1000 gleichzeitige
	Verbindungen servieren soll und jede der Verbindungen je einen
	16&nbsp;kB gro&szlig;en Puffer zum Senden und Empfangen braucht,
	brauchen Sie ungef&auml;hr 32&nbsp;MB Speicher f&uuml;r
	Netzwerkpuffer.  Als Daumenregel verdoppeln Sie diese Zahl,
	so dass sich f&uuml;r <varname>NMBCLUSTERS</varname> der Wert
	2x32&nbsp;MB&nbsp;/&nbsp;2&nbsp;kB&nbsp;= 32768 ergibt.
	F&uuml;r Maschinen mit viel Speicher sollten Werte zwischen
	4096 und 32768 genommen werden.  Sie k&ouml;nnen diesen Wert
	nicht willk&uuml;rlich erh&ouml;hen, da dies bereits zu einem
	Absturz beim Systemstart f&uuml;hren kann.  Mit der Option
	<option>-m</option> von &man.netstat.1; k&ouml;nnen Sie den
	Gebrauch der Netzwerkpuffer kontrollieren.</para>

      <para>Die Netzwerkpuffer k&ouml;nnen beim Systemstart mit der
	Loader-Variablen <varname>kern.ipc.nmbclusters</varname>
	eingestellt werden.  Nur auf &auml;lteren &os;-Systemen
	m&uuml;ssen Sie die Kerneloption <option>NMBCLUSTERS</option>
	verwenden.</para>

      <para>Die Anzahl der &man.sendfile.2; Puffer muss auf ausgelasteten
	Servern, die den Systemaufruf &man.sendfile.2; oft verwenden,
	vielleicht erh&ouml;ht werden.  Dazu k&ouml;nnen Sie die
	Kerneloption <option>NSFBUFS</option> verwenden oder die
	Anzahl der Puffer in <filename>/boot/loader.conf</filename>
	(siehe &man.loader.8;) setzen.  Die Puffer sollten erh&ouml;ht
	werden, wenn Sie Prozesse im Zustand <errorname>sfbufa</errorname>
	sehen.  Die schreibgesch&uuml;tzte sysctl-Variable
	<varname>kern.ipc.nsfbufs</varname> zeigt die Anzahl
	eingerichteten Puffer im Kernel.  Der Wert dieser Variablen
	wird normalerweise von <varname>kern.maxusers</varname> bestimmt.
	Manchmal muss die Pufferanzahl jedoch manuell eingestellt
	werden.</para>

      <important>
	<para>Auch wenn ein Socket nicht blockierend angelegt wurde,
	  kann der Aufruf von &man.sendfile.2; blockieren, um auf
	  freie <literal>struct sf_buf</literal> Puffer zu warten.</para>
      </important>

      <sect3>
	<title><varname>net.inet.ip.portrange.*</varname></title>

	<indexterm>
	  <primary>net.inet.ip.portrange.*</primary>
	</indexterm>

	<para>Die sysctl-Variable <varname>net.inet.ip.portrange.*</varname>
	  legt die Portnummern f&uuml;r TCP- und UDP-Sockets fest.
	  Es gibt drei Bereiche: den niedrigen Bereich, den
	  normalen Bereich und den hohen Bereich.  Die meisten
	  Netzprogramme benutzen den normalen Bereich.  Dieser Bereich
	  umfasst in der Voreinstellung die Portnummern 500 bis 5000
	  und wird durch die Variablen
	  <varname>net.inet.ip.portrange.first</varname> und
	  <varname>net.inet.ip.portrange.last</varname> festgelegt.
	  Die festgelegten Bereiche f&uuml;r Portnummern werden von
	  ausgehenden Verbindungen benutzt.  Unter bestimmten
	  Umst&auml;nden, beispielsweise auf stark ausgelasteten
	  Proxy-Servern, sind alle Portnummern f&uuml;r ausgehende
	  Verbindungen belegt.  Bereiche
	  f&uuml;r Portnummern spielen auf Servern keine Rolle, die
	  haupts&auml;chlich eingehende Verbindungen verarbeiten (wie ein
	  normaler Webserver) oder nur eine begrenzte Anzahl ausgehender
	  Verbindungen &ouml;ffnen (beispielsweise ein Mail-Relay).
	  Wenn Sie keine freien Portnummern mehr haben, sollten Sie
	  die Variable <varname>net.inet.ip.portrange.last</varname>
	  langsam erh&ouml;hen.  Ein Wert von <literal>10000</literal>,
	  <literal>20000</literal> oder <literal>30000</literal> ist
	  angemessen.  Beachten Sie auch eine vorhandene
	  Firewall, wenn Sie die Bereiche f&uuml;r Portnummern
	  &auml;ndern.  Einige Firewalls sperren gro&szlig;e Bereiche
	  (normalerweise aus den kleinen Portnummern) und erwarten,
	  dass hohe Portnummern f&uuml;r ausgehende Verbindungen
	  verwendet werden.  Daher kann es erforderlich sein, den
	  Wert von <varname>net.inet.ip.portrange.first</varname>
	  zu erh&ouml;hen.</para>
      </sect3>

      <sect3>
	<title>TCP Bandwidth Delay Product Begrenzung</title>

	<indexterm>
	  <primary>TCP Bandwidth Delay Product Begrenzung</primary>
	  <secondary>
	    <varname>net.inet.tcp.inflight_enable</varname>
	  </secondary>
	</indexterm>

	<para>Die TCP Bandwidth Delay Product Begrenzung gleicht
	  TCP/Vegas von <application>NetBSD</application>.  Die
	  Begrenzung wird aktiviert, indem Sie die sysctl-Variable
	  <varname>net.inet.tcp.inflight_enable</varname> auf den
	  Wert <literal>1</literal> setzen.  Das System wird dann
	  versuchen, f&uuml;r jede Verbindung, das Produkt aus der
	  &Uuml;bertragungsrate und der Verz&ouml;gerungszeit zu
	  bestimmen.  Dieses Produkt begrenzt die Datenmenge, die
	  f&uuml;r einen optimales Durchsatz zwischengespeichert
	  werden muss.</para>

	<para>Diese Begrenzung ist n&uuml;tzlich, wenn Sie Daten
	  &uuml;ber Verbindungen mit einem hohen Produkt aus
	  &Uuml;bertragungsrate und Verz&ouml;gerungszeit wie Modems,
	  Gigabit-Ethernet oder schnellen WANs, zur Verf&uuml;gung
	  stellen.  Insbesondere wirkt sich die Begrenzung aus, wenn
	  die Verbindung die TCP-Option
	  <foreignphrase>Window-scaling</foreignphrase> verwendet oder
	  gro&szlig;e Sende-Fenster
	  (<foreignphrase>send window</foreignphrase>) benutzt.
	  Schalten Sie die Debug-Meldungen aus, wenn Sie die Begrenzung
	  aktiviert haben.  Dazu setzen Sie die Variable
	  <varname>net.inet.tcp.inflight_debug</varname> auf
	  <literal>0</literal>.  Auf Produktions-Systemen sollten Sie
	  zudem die Variable <varname>net.inet.tcp.inflight_min</varname>
	  mindestens auf den Wert <literal>6144</literal> setzen.
	  Allerdings kann ein zu hoher Wert, abh&auml;ngig von der
	  Verbindung, die Begrenzungsfunktion unwirksam machen.
	  Die Begrenzung reduziert die Datenmenge in den Queues von Routern
	  und Switches, sowie die Datenmenge in der Queue der lokalen
	  Netzwerkkarte.  Die Verz&ouml;gerungszeit
	  (<foreignphrase>Round Trip Time</foreignphrase>) f&uuml;r
	  interaktive Anwendungen sinkt, da weniger Pakete
	  zwischengespeichert werden.  Dies gilt besonders f&uuml;r
	  Verbindungen &uuml;ber langsame Modems.  Die Begrenzung
	  wirkt sich allerdings nur auf das Versenden von Daten aus
	  (Uploads, Server).  Auf den Empfang von Daten (Downloads)
	  hat die Begrenzung keine Auswirkungen.</para>

	<para>Die Variable <varname>net.inet.tcp.inflight_stab</varname>
	  sollte <emphasis>nicht</emphasis> angepasst werden.  Der
	  Vorgabewert der Variablen betr&auml;gt <literal>20</literal>,
	  das hei&szlig;t es werden maximal zwei Pakete zu dem Produkt
	  aus &Uuml;bertragungsrate und Verz&ouml;gerungszeit addiert.
	  Dies stabilisiert den Algorithmus und verbessert die
	  Reaktionszeit auf Ver&auml;nderungen.  Bei langsamen
	  Verbindungen k&ouml;nnen sich aber die Laufzeiten der Pakete
	  erh&ouml;hen (ohne diesen Algorithmus w&auml;ren sie
	  allerdings noch h&ouml;her).  In solchen F&auml;llen
	  k&ouml;nnen Sie versuchen, den Wert der Variablen auf
	  <literal>15</literal>, <literal>10</literal> oder
	  <literal>5</literal> zu erniedrigen.  Gleichzeitig m&uuml;ssen
	  Sie vielleicht auch <varname>net.inet.tcp.inflight_min</varname>
	  auf einen kleineren Wert (beispielsweise <literal>3500</literal>)
	  setzen.  &Auml;ndern Sie diese Variablen nur ab, wenn Sie
	  keine anderen M&ouml;glichkeiten mehr haben.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="adding-swap-space">
    <title>Hinzuf&uuml;gen von Swap-Bereichen</title>

    <para>Egal wie vorausschauend Sie planen, manchmal entspricht ein System
      einfach nicht Ihren Erwartungen.  Es ist leicht, mehr Swap-Bereiche
      hinzuzuf&uuml;gen.  Dazu stehen Ihnen drei Wege offen:  Sie
      k&ouml;nnen eine neue Platte einbauen, den Swap-Bereich &uuml;ber NFS
      ansprechen oder eine Swap-Datei auf einer existierenden Partition
      einrichten.</para>

    <sect2 id="new-drive-swap">
      <title>Swap auf einer neuen Festplatte</title>

      <para>Der einfachste Weg, zus&auml;tzlich einen Swap-Bereich
        einzurichten, ist der Einbau einer neuen Platte, da Sie ja immer
	eine neue Platte einbauen k&ouml;nnen.  Nachdem Sie das getan
	haben, lesen Sie bitte noch einmal den Abschnitt
	<ulink url="configtuning-initial.html#SWAP-DESIGN">Swap
	Partition</ulink> aus dem Kapitel <ulink
	  url="configtuning-initial.html">Vorbereitende Konfiguration</ulink>
	des Handbuchs.  Dort finden Sie Vorschl&auml;ge, wie Sie den
	Swap-Bereich am besten einrichten.</para>
    </sect2>

    <sect2 id="nfs-swap">
      <title>Swap-Bereiche &uuml;ber NFS</title>

      <para>Swap-Bereiche &uuml;ber NFS sollten Sie nur dann einsetzen, wenn
        Sie &uuml;ber keine lokale Platte verf&uuml;gen.  In &os;
	Versionen vor 4.X ist dies zudem sehr langsam und nicht effizient.
	Ab &os;&nbsp;4.0 ist das Nutzen von Swap &uuml;ber NFS gen&uuml;gend
	schnell und effizient, doch wird es durch die zur Verf&uuml;gung
	stehende Bandbreite limitiert und belastet zus&auml;tzlich den
	NFS-Server.</para>
    </sect2>

    <sect2 id="create-swapfile">
      <title>Swap-Dateien</title>

      <para>Sie k&ouml;nnen eine Datei festgelegter Gr&ouml;&szlig;e als
        Swap-Bereich nutzen.  Im folgenden Beispiel werden wir eine 64&nbsp;MB
	gro&szlig;e Datei mit dem Namen <filename>/usr/swap0</filename>
	benutzen, Sie k&ouml;nnen nat&uuml;rlich einen beliebigen Namen
	f&uuml;r den Swap-Bereich benutzen.</para>

      <example>
	<title>Erstellen einer Swap-Datei mit &os; 4.X</title>

        <orderedlist>
	  <listitem>
            <para>Zuerst stellen Sie bitte sicher, dass Ihr Kernel den
              vnode-Treiber enth&auml;lt.  In neueren Versionen von
	      <filename>GENERIC</filename> ist dieser
	      <emphasis>nicht</emphasis> enthalten.</para>

            <programlisting>pseudo-device   vn 1   #Vnode driver (turns a file into a device)</programlisting>
	  </listitem>

	  <listitem>
	    <para>Erstellen Sie das vn-Ger&auml;t:</para>
	    <screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>sh MAKEDEV vn0</userinput></screen>
	  </listitem>

	  <listitem>
	    <para>Legen Sie die Swap-Datei <filename>/usr/swap0</filename>
	      an:</para>

	    <screen>&prompt.root; <userinput>dd if=/dev/zero of=/usr/swap0 bs=1024k count=64</userinput></screen>
	  </listitem>

	  <listitem>
	    <para>Setzen Sie die richtigen Berechtigungen f&uuml;r
	      <filename>/usr/swap0</filename>:</para>

	    <screen>&prompt.root; <userinput>chmod 0600 /usr/swap0</userinput></screen>
	  </listitem>

	  <listitem>
	    <para>Aktivieren Sie die Swap-Datei in
	      <filename>/etc/rc.conf</filename>:</para>

	    <programlisting>swapfile="/usr/swap0"   # Set to name of swapfile if aux swapfile desired.</programlisting>
	  </listitem>

	  <listitem>
	    <para>Um die Swap-Datei zu aktivieren, f&uuml;hren Sie
	      entweder einen Neustart durch oder geben das folgende Kommando
	      ein:</para>

            <screen>&prompt.root; <userinput>vnconfig -e /dev/vn0b /usr/swap0 swap</userinput></screen>
	  </listitem>
        </orderedlist>
      </example>

      <example>
	<title>Erstellen einer Swap-Datei mit &os; 5.X</title>

        <orderedlist>
	  <listitem>
	    <para>Stellen Sie sicher, dass der Kernel RAM-Disks
	      (&man.md.4;) unterst&uuml;tzt.  Dies ist in der
	      <filename>GENERIC</filename>-Konfiguration
	      voreingestellt.</para>

	    <programlisting>device   md   # Memory "disks"</programlisting>
	  </listitem>

	  <listitem>
	    <para>Legen Sie die Swap-Datei
	      <filename>/usr/swap0</filename> an:</para>

	    <screen>&prompt.root; <userinput>dd if=/dev/zero of=/usr/swap0 bs=1024k count=64</userinput></screen>
	  </listitem>

	  <listitem>
	    <para>Setzen Sie die richtigen Berechtigungen f&uuml;r
	      <filename>/usr/swap0</filename>:</para>

	    <screen>&prompt.root; <userinput>chmod 0600 /usr/swap0</userinput></screen>
	  </listitem>

	  <listitem>
	    <para>Aktivieren Sie die Swap-Datei
	      <filename>/etc/rc.conf</filename>:</para>

	    <programlisting>swapfile="/usr/swap0"   # Set to name of swapfile if aux swapfile desired.</programlisting>
	  </listitem>

	  <listitem>
	    <para>Um die Swap-Datei zu aktivieren, f&uuml;hren Sie
	      entweder einen Neustart durch oder geben das folgende Kommando
	      ein:</para>

	    <screen>&prompt.root; <userinput>mdconfig -a -t vnode -f /usr/swap0 -u 0 && swapon /dev/md0</userinput></screen>
          </listitem>
        </orderedlist>
      </example>
    </sect2>
  </sect1>

  <sect1 id="acpi-overview">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Hiten</firstname>
	  <surname>Pandya</surname>
	  <contrib>Verfasst von </contrib>
	</author>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	</author>
      </authorgroup>
    </sect1info>

    <title>Energie- und Ressourcenverwaltung</title>

    <para>Es ist sehr wichtig, Hardware effizient einzusetzen.  Vor der
      Einf&uuml;hrung des <firstterm>Advanced Configuration and Power
        Interface</firstterm> (<acronym>ACPI</acronym>) konnten der
      Stromverbrauch und die W&auml;rmeabgabe eines Systems nur sehr
      schlecht von Betriebssystemen gesteuert werden.  Die Hardware wurde
      mit BIOS-Funktionen, wie <emphasis>Plug and Play BIOS
        (PNPBIOS)</emphasis> oder <emphasis>Advanced Power Management
        (APM)</emphasis>, gesteuert.  Das Betriebssystem soll aber das System
      &uuml;berwachen k&ouml;nnen und auf Ereignisse, beispielsweise einen
      unerwarteten Temperaturanstieg, reagieren k&ouml;nnen.</para>

    <para>Dieser Abschnitt erkl&auml;rt das Advanced Configuration and
      Power Interface (<acronym>ACPI</acronym>).  Beachten Sie, dass Sie
      das <acronym>ACPI</acronym> erst ab &os;&nbsp;5.X als Kernelmodul
      zur Verf&uuml;gung steht.  In &os;&nbsp;4.9 k&ouml;nnen Sie
      <acronym>ACPI</acronym> aktivieren, indem Sie die nachstehende
      Zeile in die Kernelkonfigurationsdatei aufnehmen und den Kernel
      neu &uuml;bersetzen:</para>

    <programlisting>device          acpi</programlisting>

    <sect2 id="acpi-intro">
      <title>Was ist ACPI?</title>

      <para>Advanced Configuration and Power Interface
        (<acronym>ACPI</acronym>) ist ein Standard verschiedener
	Hersteller, der die Verwaltung von Hardware und
	Energiesparfunktionen festlegt.  Die
	<acronym>ACPI</acronym>-Funktionen k&ouml;nnen von einem
	Betriebssystem gesteuert werden.  Der Vorg&auml;nger des
	<acronym>ACPI</acronym>, <quote>Advanced Power Management</quote>
	(<acronym>APM</acronym>), der auch in &os;&nbsp;4.X verwendet
	wird, erwies sich in modernen Systemen als unzureichend.</para>
    </sect2>

    <sect2 id="acpi-old-spec">
      <title>M&auml;ngel des Advanced Power Managements (APM)</title>

      <para>Das <emphasis>Advanced Power Management (APM)</emphasis>
	steuert den Energieverbrauch eines Systems auf Basis
	der Systemaktivit&auml;t.  Das APM-BIOS wird von dem
	Hersteller des Systems zur Verf&uuml;gung gestellt
	und ist auf die spezielle Hardware angepasst.  Der
	APM-Treiber des Betriebssystems greift auf das
	<emphasis>APM Software Interface</emphasis> zu, das den
	Energieverbrauch regelt.</para>

      <para>Das <acronym>APM</acronym> hat haupts&auml;chlich
	vier Probleme.  Erstens l&auml;uft die Energieverwaltung
	unabh&auml;ngig vom Betriebssystem in einem
	(herstellerspezifischen) BIOS.  Beispielsweise kann
	das APM-BIOS die Festplatten nach einer konfigurierbaren
	Zeit ohne die Zustimmung des Betriebssystems herunterfahren.
	Zweitens befindet sich die ganze APM-Logik im BIOS;  das
	Betriebssystem hat gar keine APM-Komponenten.  Bei Problemen
	mit dem APM-BIOS muss das Flash-ROM aktualisiert werden.
	Diese Prozedur ist gef&auml;hrlich, da sie im Fehlerfall
	das System unbrauchbar machen kann.  Zum Dritten ist APM
	eine Technik, die herstellerspezifisch ist und nicht
	koordiniert wird.  Fehler im BIOS eines Herstellers werden
	nicht unbedingt im BIOS anderer Hersteller korrigiert.
	Das letzte Problem ist, dass im APM-BIOS nicht gen&uuml;gend
	Platz vorhanden ist, um eine durchdachte oder eine auf den
	Zweck der Maschine zugeschnittene Energieverwaltung
	zu implementieren.</para>

      <para>Das <emphasis>Plug and Play BIOS (PNPBIOS)</emphasis>
	war ebenfalls unzureichend.  Das PNPBIOS verwendet eine
	16-Bit-Technik.  Damit das Betriebssystem das PNPBIOS
	ansprechen kann, muss es in einer 16-Bit-Emulation laufen.</para>

      <para>Der <acronym>APM</acronym>-Treiber von &os; ist in
	der Hilfeseite &man.apm.4; beschrieben.</para>
    </sect2>

    <sect2 id="acpi-config">
      <title>Konfiguration des <acronym>ACPI</acronym></title>

      <para>Das Modul <filename>acpi.ko</filename> wird
	standardm&auml;&szlig; beim Systemstart vom &man.loader.8;
	geladen und sollte daher <emphasis>nicht</emphasis>
	fest in den Kernel eingebunden werden.  Dadurch kann
	<filename>acpi.ko</filename> ohne einen Neubau des Kernels ersetzt
	werden und das Modul ist leichter zu testen.  Wenn Sie in der
	Ausgabe von &man.dmesg.8; das Wort <acronym>ACPI</acronym> sehen,
	ist das Modul geladen worden.  Es ist nicht sinnvoll, das Modul
	im laufenden Betrieb zu laden, dies kann sogar manchmal fatale
	Folgen haben.
	<!-- Wo denn? -> Hinweis auf device.hints?
	Im Zweifelsfall deaktivieren Sie <acronym>ACPI</acronym>.
	-->
	Das Modul kann im laufenden Betrieb nicht entfernt werden,
	da es zur Kommunikation mit der Hardware verwendet wird.
	Mit &man.acpiconf.8; k&ouml;nnen Sie das <acronym>ACPI</acronym>
	konfigurieren (unter anderem k&ouml;nnen Sie damit auch die
	Energieverwaltung deaktivieren).</para>

      <note>
	<para><acronym>ACPI</acronym> und <acronym>APM</acronym>
	  k&ouml;nnen nicht zusammen verwendet werden.  Das zuletzt
	  geladene Modul beendet sich, sobald es bemerkt, dass das andere
	  Modul geladen ist.</para>
      </note>

      <para>Mit &man.acpiconf.8; k&ouml;nnen Sie das System in einen
        Ruhemodus (<foreignphrase>sleep mode</foreignphrase>) versetzen.
	Es gibt verschiedene Modi (von <literal>1</literal> bis
	<literal>5</literal>), die Sie auf der Kommandozeile mit
	<option>-s</option> angeben k&ouml;nnen.  F&uuml;r die meisten
	Anwender ist der Modus <literal>1</literal> v&ouml;llig
	ausreichend.  Der Modus <literal>5</literal> schaltet das System
	aus (<foreignphrase>Soft-off</foreignphrase>) und entspricht dem
	Ausf&uuml;hren des folgenden Befehls:</para>

      <screen>&prompt.root; <userinput>halt -p</userinput></screen>

      <para>Weitere Informationen entnehmen Sie bitte der Hilfeseite
        &man.acpiconf.8;.</para>
    </sect2>

    <sect2 id="acpi-debug">
      <title>Fehlersuche und <acronym>ACPI</acronym> ausschalten</title>

      <para>Meist werden Sie erst etwas von <acronym>ACPI</acronym>
	merken, wenn etwas nicht funktioniert.  Der  &man.acpi.4;-Treiber
	besitzt viele Optionen zur Fehlersuche.  Es ist sogar
	m&ouml;glich, einzelne Teile des <acronym>ACPI</acronym>-Systems
	auszuschalten.  Weitere Informationen zur Fehlersuche
	erhalten Sie in der Hilfeseite &man.acpi.4;.</para>

      <para>Manchmal muss das <filename>acpi.ko</filename>-Modul
	entfernt werden.  Dies ist nur mit dem &man.loader.8;
	w&auml;hrend des Systemstarts m&ouml;glich.  An der
	Eingabeaufforderung von &man.loader.8; k&ouml;nnen Sie
	das Modul mit dem Befehl <command>unset acpi_load</command>
	entfernen.  Wenn Sie den Befehl nicht bei jedem Start
	absetzen wollen, k&ouml;nnen Sie verhindern, dass der
	&man.acpi.4;-Treiber &uuml;berhaupt geladen wird.  Dazu
	f&uuml;gen Sie die folgende Zeile in
	<filename>/boot/loader.conf</filename> ein:</para>

      <programlisting>exec="unset acpi_load"</programlisting>

      <para>Ab &os;&nbsp;5.1-RELEASE gibt es ein Boot-Men&uuml;, das
	den Bootvorgang von &os; steuert.  Darin kann
	<acronym>ACPI</acronym> abgestellt werden:  W&auml;hlen
	Sie dazu einfach die Option
	<guimenuitem>2. Boot &os; with ACPI disabled</guimenuitem>
	aus.</para>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
