<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde: de-docproj/books/handbook/config/chapter.sgml,v 1.147 2010/11/20 15:32:56 jkois Exp $
     basiert auf: 1.244
-->

<chapter id="config-tuning">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Chern</firstname>
	<surname>Lee</surname>
	<contrib>Geschrieben von </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Mike</firstname>
	<surname>Smith</surname>
	<contrib>Nach einem Tutorium von </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Matt</firstname>
	<surname>Dillon</surname>
	<contrib>Basiert ebenfalls auf tuning(7) von </contrib>
      </author>
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Martin</firstname>
	<surname>Heinen</surname>
	<contrib>&Uuml;bersetzt von </contrib>
      </author>
    </authorgroup>
  </chapterinfo>

  <title>Konfiguration und Tuning</title>

  <sect1 id="config-synopsis">
    <title>&Uuml;bersicht</title>

    <indexterm><primary>System-Konfiguration</primary></indexterm>
    <indexterm><primary>System-Optimierung</primary></indexterm>

    <para>Ein korrekt konfiguriertes System kann die Arbeit,
      die bei der zuk&uuml;nftigen Pflege und bei Migrationen des Systems
      entsteht, erheblich reduzieren.  Dieses Kapitel beschreibt die
      Konfiguration von &os; sowie Ma&szlig;nahmen zur Leistungssteigerung
      von &os;-Systemen.</para>

    <para>Nachdem Sie dieses Kapitel durchgearbeitet haben,
      werden Sie Folgendes wissen:</para>

    <itemizedlist>
      <listitem>
	<para>Wie Sie effizient Dateisysteme und
	  Swap-Partitionen auf Ihrer Festplatte einrichten.</para>
      </listitem>
      <listitem>
	<para>Die Grundlagen der Konfiguration mit
	  <filename>rc.conf</filename> und des Systems zum Starten
	  von Anwendungen in <filename
	  class="directory">/usr/local/etc/rc.d</filename>.</para>
      </listitem>
      <listitem>
	<para>Wie Sie Netzwerkkarten konfigurieren und testen.</para>
      </listitem>
      <listitem>
	<para>Wie Sie virtuelle Hosts und Netzwerkger&auml;te
	  konfigurieren.</para>
      </listitem>
      <listitem>
	<para>Wie Sie die verschiedenen Konfigurationsdateien
	  in <filename class="directory">/etc</filename> benutzen.</para>
      </listitem>
      <listitem>
	<para>Wie Sie mit <command>sysctl</command>-Variablen &os;
	  einstellen k&ouml;nnen.</para>
      </listitem>
      <listitem>
	<para>Wie Sie die Platten-Performance einstellen und Kernel-Parameter
	  modifizieren k&ouml;nnen.</para>
      </listitem>
    </itemizedlist>

    <para>Bevor Sie dieses Kapitel lesen, sollten Sie</para>
    <itemizedlist>
      <listitem>
	<para>die Grundlagen von &unix; und &os; (<xref linkend="basics">)
	  verstehen.</para>
      </listitem>
      <listitem>
	<para>Damit vertraut sein, wie Sie einen Kernel konfigurieren
	  und kompilieren (<xref linkend="kernelconfig">).</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="configtuning-initial">
    <title>Vorbereitende Konfiguration</title>

    <sect2>
      <title>Layout von Partitionen</title>

      <indexterm><primary>Layout von Partitionen</primary></indexterm>
      <indexterm><primary><filename
      class="directory">/etc</filename></primary></indexterm>
      <indexterm><primary><filename
      class="directory">/var</filename></primary></indexterm>
      <indexterm><primary><filename
      class="directory">/usr</filename></primary></indexterm>

      <sect3>
	<title>Partitionen</title>

	<para>Wenn Sie Dateisysteme mit &man.bsdlabel.8; oder
	  &man.sysinstall.8; anlegen, sollten Sie beachten, dass
	  Festplatten auf Daten in den &auml;u&szlig;eren Spuren
	  schneller zugreifen k&ouml;nnen als auf Daten in den
	  inneren Spuren.  Daher sollten die kleineren oft benutzten
	  Dateisysteme, wie das Root-Dateisystem oder die Swap-Partition,
	  an den &auml;u&szlig;eren Rand der Platte gelegt werden.
	  Die gr&ouml;&szlig;eren Partitionen wie <filename
	  class="directory">/usr</filename> sollten in die inneren Bereiche
	  gelegt werden.  Es empfiehlt sich, die Partitionen in einer
	  &auml;hnlichen Reihenfolge wie Root-Partition, Swap, <filename
	  class="directory">/var</filename> und <filename
	  class="directory">/usr</filename> anzulegen.</para>

	<para>Die Gr&ouml;&szlig;e der <filename
	  class="directory">/var</filename>-Partition ist abh&auml;ngig vom
	  Zweck der Maschine.  Das <filename
	  class="directory">/var</filename>-Dateisystem enth&auml;lt
	  haupts&auml;chlich Postf&auml;cher, den Spoolbereich zum Drucken und
	  Logdateien.  Abh&auml;ngig von der Anzahl der Systembenutzer und der
	  Aufbewahrungszeit f&uuml;r Logdateien, k&ouml;nnen gerade
	  die Postf&auml;cher und Logdateien zu ungeahnten Gr&ouml;&szlig;en
	  wachsen.  Die meisten Benutzer werden selten mehr als etwa ein
	  Gigabyte in <filename class="directory">/var</filename>
	  ben&ouml;tigen.</para>

        <note>
          <para>Ein paar Mal wird es vorkommen, dass viel Festplattenspeicher
            in <filename class="directory">/var/tmp</filename> gebraucht
            wird.  Wenn neue Software mit &man.pkg.add.1; installiert wird,
            extrahieren die Paketwerkzeuge eine vor&uuml;bergehende Kopie der
            Pakete unter <filename class="directory">/var/tmp</filename>.  Die
            Installation grosser Softwarepakete wie
            <application>Firefox</application> oder
            <application>Openoffice</application> kann sich wegen zu wenig
            Speicherplatz in <filename class="directory">/var/tmp</filename>
            als trickreich herausstellen.</para>
        </note>

        <para>Die <filename class="directory">/usr</filename>-Partition
          enth&auml;lt viele der Hauptbestandteile des Systems, dazu
          geh&ouml;hren die &man.ports.7;-Sammlung (empfohlen) und die Quellen
          (optional).  Sowohl die Ports als auch die Quellen des Basissystems
          sind zum Zeitpunkt der Installation optional, trotzdem sollten Sie
          mindestens zwei&nbsp;Gigabyte f&uuml;r diese Partition
          vorsehen.</para>

	<para>Wenn Sie die Gr&ouml;&szlig;e der Partitionen festlegen,
	  beachten Sie bitte das Wachstum Ihres Systems.  Wenn Sie den
	  Platz auf einer Partition vollst&auml;ndig aufgebraucht haben,
	  eine andere Partition aber kaum benutzen, kann die Handhabung des
	  Systems schwierig werden.</para>

	<note><para>Die automatische Partitionierung von &man.sysinstall.8;
	  mit <literal>Auto-defaults</literal> legt manchmal zu kleine
	  <filename class="directory">/</filename> und <filename
	  class="directory">/var</filename>-Partition an.  Partitionieren Sie
	  weise und gro&szlig;z&uuml;gig.</para></note>
      </sect3>

      <sect3 id="swap-design">
	<title>Swap Partition</title>

	<indexterm>
	  <primary>Swap-Partition</primary>
	  <secondary>Gr&ouml;&szlig;e</secondary>
	</indexterm>
	<indexterm><primary>Swap-Partition</primary></indexterm>

	<para>Als Daumenregel sollten Sie doppelt soviel Speicher
	  f&uuml;r die Swap-Partition vorsehen, als Sie Hauptspeicher
	  haben.  Verf&uuml;gt die Maschine beispielsweise &uuml;ber
	  128&nbsp;Megabyte Hauptspeicher, sollten Sie 256&nbsp;Megabyte
	  f&uuml;r den Swap-Bereich vorsehen.  Systeme mit weniger Speicher
	  werden wahrscheinlich mit viel mehr Swap mehr leisten.  Es
	  wird nicht empfohlen, weniger als 256&nbsp;Megabyte Swap einzurichten.
	  Au&szlig;erdem sollten Sie k&uuml;nftige Speichererweiterungen
	  beachten, wenn Sie die Swap-Partition einrichten.  Die
	  VM-Paging-Algorithmen im Kernel sind so eingestellt, dass
	  Sie am besten laufen, wenn die Swap-Partition mindestens
	  doppelt so gro&szlig; wie der Hauptspeicher ist.  Zu wenig
	  Swap kann zu einer Leistungsverminderung im
	  <foreignphrase>VM page scanning</foreignphrase>
	  Code f&uuml;hren, sowie Probleme verursachen, wenn Sie sp&auml;ter
	  mehr Speicher in Ihre Maschine bauen.</para>

	<para>Auf gr&ouml;&szlig;eren Systemen mit mehreren SCSI-Laufwerken
	  (oder mehreren IDE-Laufwerken an unterschiedlichen Controllern)
	  empfehlen wir Ihnen, Swap-Bereiche auf bis zu
	  vier Laufwerken einzurichten.  Diese Swap-Partitionen sollten
	  ungef&auml;hr dieselbe Gr&ouml;&szlig;e haben.  Der Kernel
	  kann zwar mit beliebigen Gr&ouml;&szlig;en umgehen, aber
	  die internen Datenstrukturen skalieren bis zur vierfachen
	  Gr&ouml;&szlig;e der gr&ouml;&szlig;ten Partition.  Ungef&auml;hr
	  gleich gro&szlig;e Swap-Partitionen erlauben es dem Kernel,
	  den Swap-Bereich optimal &uuml;ber die Laufwerke zu verteilen.
	  Gro&szlig;e Swap-Bereiche, auch wenn sie nicht oft gebraucht
	  werden, sind n&uuml;tzlich, da sich ein speicherfressendes
	  Programm unter Umst&auml;nden auch ohne einen Neustart des Systems
	  beenden l&auml;sst.</para>
      </sect3>

      <sect3>
	<title>Warum partitionieren?</title>

	<para>Gegen eine einzelne Partition sprechen mehrere Gr&uuml;nde.
	  Jede Partition hat im Betrieb unterschiedliche Eigenschaften
	  und die Trennung der Partitionen erlaubt es, die Dateisysteme
	  an diese Eigenschaften anzupassen.  Die Root- und <filename
	  class="directory">/usr</filename>-Partitionen weisen meist nur
	  lesende Zugriffe auf, w&auml;hrend <filename
	  class="directory">/var</filename> und <filename
	  class="directory">/var/tmp</filename> haupts&auml;chlich
	  beschrieben werden.</para>

	<para>Indem Sie ein System richtig partitionieren, verhindern
	  Sie, dass eine Fragmentierung in den h&auml;ufig beschriebenen
	  Partitionen auf die meist nur gelesenen Partitionen
	  &uuml;bergreift.  Wenn Sie die h&auml;ufig beschriebenen
	  Partitionen an den Rand der Platte, legen, dann wird die
	  I/O-Leistung diesen Partitionen steigen.
	  Die I/O-Leistung ist nat&uuml;rlich auch f&uuml;r gro&szlig;e
	  Partitionen wichtig, doch erzielen Sie eine gr&ouml;&szlig;ere
	  Leistungssteigerung, wenn Sie <filename
	  class="directory">/var</filename> an den Rand der Platte legen.
	  Schlie&szlig;lich sollten Sie noch die Stabilit&auml;t des Systems
	  beachten.  Eine kleine Root-Partition, auf die meist nur lesend
	  zugegriffen wird, &uuml;berlebt einen schlimmen Absturz
	  wahrscheinlich eher als eine gro&szlig;e Partition.</para>
      </sect3>
    </sect2>

  </sect1>

  <sect1 id="configtuning-core-configuration">
    <title>Basiskonfiguration</title>

    <indexterm>
      <primary>rc-Dateien</primary>
      <secondary><filename>rc.conf</filename></secondary>
    </indexterm>

    <para>Informationen zur Systemkonfiguration sind haupts&auml;chlich
      in <filename>/etc/rc.conf</filename>, die meist beim Start
      des Systems verwendet wird, abgelegt.  Der Name der Datei zeigt
      ihren Zweck an: Sie enth&auml;lt die Konfigurationen f&uuml;r
      die <filename>rc*</filename> Dateien.</para>

    <para>In <filename>rc.conf</filename> werden die Vorgabewerte aus
      <filename>/etc/defaults/rc.conf</filename> &uuml;berschrieben.
      Die Vorgabedatei sollte nicht nach <filename
      class="directory">/etc</filename> kopiert werden, da sie die
      Vorgabewerte und keine Beispiele enth&auml;lt.  Jede systemspezifische
      &Auml;nderung wird in <filename>rc.conf</filename> vorgenommen.</para>

    <para>Um den administrativen Aufwand gering zu halten, existieren
      in geclusterten Anwendungen mehrere Strategien,
      globale Konfigurationen von systemspezifischen Konfigurationen
      zu trennen.  Der empfohlene Weg h&auml;lt die globale Konfiguration
      in einer separaten Datei z.B. <filename>rc.conf.site</filename>.
      Diese Datei wird dann in <filename>/etc/rc.conf</filename>,
      die nur systemspezifische Informationen enth&auml;lt, eingebunden.</para>

    <para>Da <filename>rc.conf</filename> von &man.sh.1; gelesen
      wird, ist das einfach zu erreichen:</para>

    <itemizedlist>
      <listitem><para>rc.conf:</para>
<programlisting>	. /etc/rc.conf.site
	hostname="node15.example.com"
	network_interfaces="fxp0 lo0"
	ifconfig_fxp0="inet 10.1.1.1"</programlisting></listitem>
      <listitem><para>rc.conf.site:</para>
<programlisting>	defaultrouter="10.1.1.254"
	saver="daemon"
	blanktime="100"</programlisting></listitem>
    </itemizedlist>

    <para><filename>rc.conf.site</filename> kann dann auf jedes
      System mit <command>rsync</command> verteilt werden,
      <filename>rc.conf</filename> bleibt dabei systemspezifisch.</para>

    <para>Bei einem Upgrade des Systems mit &man.sysinstall.8; oder
      <command>make world</command> wird <filename>rc.conf</filename>
      nicht &uuml;berschrieben, so dass die Systemkonfiguration
      erhalten bleibt.</para>

  </sect1>

  <sect1 id="configtuning-appconfig">
    <title>Konfiguration von Anwendungen</title>

    <para>Installierte Anwendungen haben typischerweise
      eigene Konfigurationsdateien, die eine eigene Syntax
      verwenden.  Damit diese Dateien leicht von der
      Paketverwaltung gefunden und verwaltet werden k&ouml;nnen,
      ist es wichtig, sie vom Basissystem zu trennen.</para>

    <indexterm><primary>/usr/local/etc</primary></indexterm>

    <para>F&uuml;r gew&ouml;hnlich werden diese Dateien in <filename
      class="directory">/usr/local/etc</filename> installiert.  Besitzt
      eine Anwendung viele Konfigurationsdateien, werden
      diese in einem separaten Unterverzeichnis abgelegt.</para>

    <para>Wenn ein Port oder ein Paket installiert wird, werden
      normalerweise auch Beispiele f&uuml;r die Konfigurationsdateien
      installiert.  Diese erkennt man gew&ouml;hnlich an dem
      Suffix <filename>.default</filename>.  Wenn keine Konfigurationsdateien
      f&uuml;r eine Anwendung existieren, werden sie durch
      Kopieren der <filename>.default</filename> Dateien erstellt.</para>

    <para>Als Beispiel sei <filename
      class="directory">/usr/local/etc/apache</filename> gezeigt:</para>

    <literallayout class="monospaced">-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf
-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf.default
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf.default
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic.default
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types.default
-rw-r--r--  1 root  wheel   7980 May 20  1998 srm.conf
-rw-r--r--  1 root  wheel   7933 May 20  1998 srm.conf.default</literallayout>

    <para>Anhand der Dateigr&ouml;&szlig;e erkennen Sie, dass sich
      nur <filename>srm.conf</filename> ge&auml;ndert hat.  Eine
      sp&auml;tere Aktualisierung des <application>Apache</application>-Ports
      &uuml;berschreibt diese Datei nicht.</para>

  </sect1>

  <sect1 id="configtuning-starting-services">
    <sect1info>
      <authorgroup>
	 <author>
	   <firstname>Tom</firstname>
	   <surname>Rhodes</surname>
	   <contrib>Beigetragen von </contrib>
	 </author>
      </authorgroup>
    </sect1info>
    <title>Start von Diensten</title>

    <indexterm>
      <primary>Dienste</primary>
    </indexterm>

    <para>Viele Benutzer installieren Software Dritter auf &os;
      mithilfe der Ports-Sammlung.  H&auml;ufig soll die
      Software bei einem Systemstart mitgestartet werden.
      Beispielsweise sollen die Dienste
      <filename role="package">mail/postfix</filename> oder
      <filename role="package">www/apache13</filename> nach
      einem Systemstart laufen.  Dieser Abschnitt stellt
      die Startprozeduren f&uuml;r Software Dritter vor.</para>

    <para>Unter &os; werden die meisten der im System enthaltenen
      Dienste wie &man.cron.8; mithilfe von Systemskripten gestartet.
      Diese Skripten sind abh&auml;ngig von der &os;- oder
      Hersteller-Version.  Allerdings kann ein Dienst mit
      einfachen Skripten gestartet werden.</para>

    <sect2>
      <title>Dienste &uuml;ber das
        <filename>rc.d</filename>-System starten</title>

      <para>Mit <filename>rc.d</filename> l&auml;sst sich der Start
	von Anwendungen besser steuern als mit den vorher besprochenen
	Startskripten.  Mit den im Abschnitt
	<link linkend="configtuning-rcd">rc.d</link>
	besprochenen Schl&uuml;sselw&ouml;rtern k&ouml;nnen
	Anwendungen in einer bestimmten Reihenfolge (zum Beispiel
	nach <acronym>DNS</acronym>) gestartet werden und
	Optionen k&ouml;nnen in <filename>rc.conf</filename>
	statt fest im Startskript der Anwendung festgelegt werden.
	Ein einfaches Startskript sieht wie folgt aus:</para>

      <programlisting>#!/bin/sh
#
# PROVIDE: utility
# REQUIRE: DAEMON
# KEYWORD: shutdown


./etc/rc.subr

name="utility"
rcvar=`set_rcvar`
command="/usr/local/sbin/utility"

load_rc_config $name

#
# DO NOT CHANGE THESE DEFAULT VALUES HERE
# SET THEM IN THE /etc/rc.conf FILE
#
utility_enable=${utility_enable-"NO"}
utility_pidfile=${utility_pidfile-"/var/run/utility.pid"}

pidfile="${utility_pidfile}"

run_rc_command "$1"</programlisting>

      <para>Dieses Skript stellt sicher, dass
	<application>utility</application> nach den
	<literal>DAEMON</literal>-Pseudodiensten gestartet wird.
	Es stellt auch eine Methode bereit, die
	Prozess-<acronym>ID</acronym> (<acronym>PID</acronym>)
	der Anwendung in einer Datei zu speichern.</para>

      <para>In <filename>/etc/rc.conf</filename> k&ouml;nnte
        f&uuml;r diese Anwendung die folgende Zeile stehen:</para>

      <programlisting>utility_enable="YES"</programlisting>

      <para>Die Methode erleichtert den Umgang mit
	Kommandozeilenargumenten, bindet Funktionen aus
	<filename>/etc/rc.subr</filename> ein, ist kompatibel
	zum Werkzeug &man.rcorder.8; und l&auml;sst sich
	&uuml;ber <filename>rc.conf</filename> leichter
	konfigurieren.</para>
    </sect2>

    <sect2>
      <title>Andere Arten, um Dienste zu starten</title>

      <para>Dienste wie <acronym>POP</acronym>3 oder
	<acronym>IMAP</acronym> k&ouml;nnen &uuml;ber
	&man.inetd.8; gestartet werden.  Nach der Installation
	der Anwendung aus der Ports-Sammlung muss eine
	Konfigurationszeile in der Datei
	<filename>/etc/inetd.conf</filename> hinzugef&uuml;gt oder
	in der aktuellen Konfiguration durch Entfernen der Kommentare
	aktiviert werden.  Der Abschnitt <xref
	linkend="network-inetd"> beschreibt den
	<application>inetd</application> und dessen Konfiguration.</para>

      <para>Systemdienste k&ouml;nnen auch mit &man.cron.8; gestartet
	werden.  Dieser Ansatz hat einige Vorteile; nicht zuletzt, weil
	&man.cron.8; die Prozesse unter dem Eigent&uuml;mer der
	<filename>crontab</filename> startet, ist es m&ouml;glich, dass
	Dienste von nicht-<username>root</username> Benutzern gestartet
	und gepflegt werden k&ouml;nnen.</para>

      <para>Dies nutzt eine Eigenschaft von &man.cron.8;:
	F&uuml;r die Zeitangabe kann <literal>@reboot</literal>
	eingesetzt werden.  Damit wird das Kommando gestartet, wenn
	&man.cron.8; kurz nach dem Systemboot gestartet wird.</para>
    </sect2>
  </sect1>

  <sect1 id="configtuning-cron">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Beigetragen von </contrib>
	  <!-- 20 May 2003 -->
	</author>
      </authorgroup>
    </sect1info>
    <title>Programme mit <command>cron</command> starten</title>

    <indexterm>
      <primary><command>cron</command></primary>
    </indexterm>

    <para>Ein sehr n&uuml;tzliches Werkzeug von &os; ist &man.cron.8;.
      <command>cron</command> l&auml;uft im Hintergrund und
      &uuml;berpr&uuml;ft fortlaufend die Datei
      <filename>/etc/crontab</filename>.  Beim Start sucht
      <command>cron</command> neue <filename>crontab</filename>-Dateien
      im Verzeichnis <filename class="directory">/var/cron/tabs</filename>.
      In den <filename class="directory">crontab</filename>-Dateien wird
      festgelegt, welche Programme zu welchem Zeitpunkt laufen sollen.</para>

    <para>Das Werkzeug <command>cron</command> verwendet
      zwei verschiedene Konfigurationsdateien: Die
      System-<filename>crontab</filename> und die
      Benutzer-<filename>crontab</filename>.  Der einzige Unterschied
      zwischen beiden Formaten ist das sechste Feld.  In der
      System-<filename>crontab</filename> gibt das sechste Feld das
      Konto an, unter dem ein Kommando l&auml;uft.  Aus der
      System-<filename>crontab</filename> k&ouml;nnen daher
      Kommandos unter beliebigen Konten gestartet werden.
      In der Benutzer-<filename>crontab</filename> gibt das
      sechste Feld das auszuf&uuml;hrende Kommando an.  Alle
      Kommandos laufen unter dem Konto, unter dem die
      <filename>crontab</filename> erstellt wurde (ein
      wichtiges Sicherheitsmerkmal).</para>

    <note>
      <para>Benutzer k&ouml;nnen mit Benutzer-<filename>crontabs</filename>
	ohne <username>root</username>-Rechte Befehle terminieren.
	Die Kommandos in Benutzer-<filename>crontabs</filename> laufen
	unter dem Benutzer, der die <filename>crontab</filename>
	erstellt hat.</para>

      <para>Der Benutzer <username>root</username> kann, wie
	jeder andere Benutzer, eine Benutzer-<filename>crontab</filename>
	besitzen.  Die Benutzer-<filename>crontab</filename> von
	<username>root</username> ist nicht mit der Datei
	<filename>/etc/crontab</filename>, der
	System-<filename>crontab</filename>, zu verwechseln.
	Normalerweise besitzt <username>root</username>, wegen
	der Existenz der System-<filename>crontab</filename>, keine
	eigene Benutzer-<filename>crontab</filename>.</para>
    </note>

    <para>Der folgende Auszug aus der System-<filename>crontab</filename>
      <filename>/etc/crontab</filename> zeigt den Aufbau
      einer <filename>crontab</filename>-Datei:</para>

    <programlisting># /etc/crontab - root's crontab for FreeBSD
#
# &dollar;FreeBSD: src/etc/crontab,v 1.32 2002/11/22 16:13:39 tom Exp &dollar;
# <co id="co-comments">
#
SHELL=/bin/sh
PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin <co id="co-env">
HOME=/var/log
#
#
#minute	hour	mday	month	wday	who	command <co id="co-field-descr">
#
#
*/5	*	*	*	*	root	/usr/libexec/atrun <co id="co-main"></programlisting>

    <calloutlist>
      <callout arearefs="co-comments">
	<para>Das Zeichen <literal>#</literal> leitet, wie in
	  den meisten Konfigurationsdateien, einen Kommentar ein.
	  Benutzen Sie Kommentare, um die Funktion eines Eintrags
	  zu erl&auml;utern.  Kommentare m&uuml;ssen in einer
	  extra Zeile stehen.  Sie k&ouml;nnen nicht in derselben
	  Zeile wie ein Kommando stehen, da sie sonst Teil des
	  Kommandos w&auml;ren.  Leerzeilen in dieser Datei
	  werden ignoriert.</para>
      </callout>

      <callout arearefs="co-env">
	<para>Umgebungsvariablen werden mit dem Gleichheits-Zeichen
	  (<literal>=</literal>) festgelegt.  Im Beispiel werden
	  die Variablen <envar>SHELL</envar>, <envar>PATH</envar>
	  und <envar>HOME</envar> definiert.  Wenn die Variable
	  <envar>SHELL</envar> nicht definiert wird, benutzt
	  <command>cron</command> die Shell <command>sh</command>.
	  Wird die Variable <envar>PATH</envar> nicht gesetzt,
	  m&uuml;ssen alle Pfadangaben absolut sein, da es keinen
	  Vorgabewert f&uuml;r <envar>PATH</envar> gibt.  Der
	  Vorgabewert f&uuml;r <envar>HOME</envar> ist das
	  Heimatverzeichnis des Accounts, dem die
	  <filename>crontab</filename> geh&ouml;rt.</para>
      </callout>

      <callout arearefs="co-field-descr">
	<para>In dieser Zeile werden sieben Felder beschrieben:
	  <literal>minute</literal>, <literal>hour</literal>,
	  <literal>mday</literal>, <literal>month</literal>,
	  <literal>wday</literal>, <literal>who</literal>
	  und <literal>command</literal>.  Die ersten Felder
	  legen den Zeitpunkt fest, an dem ein Kommando laufen
	  soll.  Das Feld <literal>minute</literal> legt die
	  Minute fest, das Feld <literal>hour</literal> die
	  Stunde, das Feld <literal>mday</literal> den Tag
	  des Monats.  Im Feld <literal>month</literal>
	  wird der Monat und im Feld <literal>wday</literal>
	  der Wochentag festgelegt.  Alle Felder m&uuml;ssen
	  numerische Werte enthalten und die Zeitangaben sind
	  im 24-Stunden-Format.  Das Feld <literal>who</literal>
	  gibt es nur in der Datei <filename>/etc/crontab</filename>
	  und gibt den Account an, unter dem das Kommando laufen
	  soll.  In den <filename>crontab</filename>-Dateien
	  einzelner Accounts existiert dieses Feld nicht.  Im
	  letzten Feld wird schlie&szlig;lich das auszuf&uuml;hrende
	  Kommando angegeben.</para>
      </callout>

      <callout arearefs="co-main">
	<para>Diese Zeile definiert die Zeitpunkte an denen das
	  Kommando <command>atrun</command> laufen soll.  Beachten
	  Sie die Zeichenfolge <literal>*/5</literal> gefolgt von
	  mehreren <literal>*</literal>-Zeichen.  Das Zeichen
	  <literal>*</literal> ist ein Platzhalter und steht
	  f&uuml;r <emphasis>jede</emphasis> m&ouml;gliche Zeit.
	  Diese Zeile f&uuml;hrt das Kommando <command>atrun</command>
	  unter dem <username>root</username>-Account alle f&uuml;nf
	  Minuten aus.  Mehr &uuml;ber das Kommando
	  <command>atrun</command> erfahren Sie in der
	  Hilfeseite &man.atrun.8;.</para>

	<para>Bei den Kommandos k&ouml;nnen beliebige Optionen
	  angegeben werden.  Wenn das Kommando zu lang ist und
	  auf der n&auml;chsten Zeile fortgesetzt werden soll,
	  muss am Ende der Zeile das Fortsetzungszeichen
	  (<literal>\</literal>) angegeben werden.</para>
      </callout>
    </calloutlist>

    <para>Bis auf das sechste Feld, das den Account angibt, sieht
      jede <filename>crontab</filename>-Datei so wie das Beispiel
      aus.  Das sechste Feld existiert nur in der Systemdatei
      <filename>/etc/crontab</filename>.  In den restlichen
      <filename>crontab</filename>-Dateien fehlt dieses Feld.</para>

    <sect2 id="configtuning-installcrontab">
      <title><filename>crontab</filename> installieren</title>

      <important>
	<para>Die nachstehende Prozedur gilt nur f&uuml;r
	  Benutzer-<filename>crontabs</filename>.  Die
	  System-<filename>crontab</filename> k&ouml;nnen
	  Sie einfach mit Ihrem Lieblingseditor editieren.
	  Das Werkzeug <command>cron</command> bemerkt, dass
	  sich die Datei ge&auml;ndert hat und wird die neue
	  Version benutzen.  Lesen Sie bitte auch die FAQ
	  zur Meldung <ulink
	  url="&url.books.faq;/admin.html#ROOT-NOT-FOUND-CRON-ERRORS">root: not found</ulink>.</para>
      </important>

      <para>Eine Benutzer-<filename>crontab</filename>, beispielsweise
	die Datei <filename>crontab</filename>, k&ouml;nnen Sie mit
	jedem Editor erstellen.  Die Benutzer-<filename>crontab</filename>
	installieren Sie mit dem nachstehenden Befehl:</para>

      <screen>&prompt.root; <userinput>crontab crontab</userinput></screen>

      <para>Das Argument zum Befehl <command>crontab</command>
	ist die vorher erstellte Datei <filename>crontab</filename>.</para>

      <para>Der Befehl <command>crontab -l</command> zeigt
	die installierte <filename>crontab</filename>-Datei an.</para>

      <para>Benutzer, die eine eigene <filename>crontab</filename>-Datei
	ohne Vorlage erstellen wollen, k&ouml;nnen den Befehl
	<command>crontab -e</command> verwenden.  Dieser Befehl
	ruft einen Editor auf und installiert beim Verlassen des
	Editors die <filename>crontab</filename>-Datei.</para>

      <para>Wollen Sie die installierte
        Benutzer-<filename>crontab</filename> entfernen, rufen Sie den
        Befehl <command>crontab</command> mit der Option
        <option>-r</option> auf.</para>
    </sect2>
  </sect1>

  <sect1 id="configtuning-rcd">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	  <contrib>Beigetragen von </contrib>
	  <!-- 16 May 2003 -->
	</author>
      </authorgroup>
    </sect1info>
    <title>Das rc-System f&uuml;r Systemdienste</title>

    <para>2002 wurde das <application>rc.d</application>-System von
      NetBSD zum Start von Systemdiensten in &os; integriert.
      Die zu diesem System geh&ouml;renden Dateien sind im
      Verzeichnis <filename class="directory">/etc/rc.d</filename> abgelegt.
      Die Skripten in diesem Verzeichnis akzeptieren die
      Optionen <option>start</option>, <option>stop</option>
      und <option>restart</option>.  Beispielsweise kann
      &man.sshd.8; mit dem nachstehenden Kommando neu gestartet
      werden:</para>

    <screen>&prompt.root; <userinput>/etc/rc.d/sshd restart</userinput></screen>

    <para>Analog k&ouml;nnen Sie andere Dienste starten und stoppen.
      Normalerweise werden die Dienste beim Systemstart &uuml;ber
      Eintr&auml;ge in der Datei &man.rc.conf.5; automatisch gestartet.
      Der Network Address
      Translation D&aelig;mon wird zum Beispiel mit dem folgenden
      Eintrag in <filename>/etc/rc.conf</filename> aktiviert:</para>

    <programlisting>natd_enable="YES"</programlisting>

    <para>Wenn dort bereits die Zeile <option>natd_enable="NO"</option>
      existiert, &auml;ndern Sie einfach <option>NO</option> in
      <option>YES</option>.  Die rc-Skripten starten, wie unten
      beschrieben, auch abh&auml;ngige Dienste.</para>

    <para>Da das <application>rcNG</application>-System prim&auml;r
      zum automatischen Starten und Stoppen von Systemdiensten
      dient, funktionieren die Optionen <option>start</option>,
      <option>stop</option> und <option>restart</option> nur,
      wenn die entsprechenden Variablen in
      <filename>/etc/rc.conf</filename> gesetzt sind.  Beispielsweise
      funktioniert das Kommando <command>sshd restart</command>
      nur dann, wenn in <filename>/etc/rc.conf</filename> die
      Variable <varname>sshd_enable</varname> auf <option>YES</option>
      gesetzt wurde.  Wenn Sie die Optionen <option>start</option>,
      <option>stop</option> oder <option>restart</option>
      unabh&auml;ngig von den Einstellungen in
      <filename>/etc/rc.conf</filename> benutzen wollen,
      m&uuml;ssen Sie den Optionen mit dem Pr&auml;fix
      <quote>one</quote> verwenden.  Um beispielsweise
      <command>sshd</command> unabh&auml;ngig von den
      Einstellungen in <filename>/etc/rc.conf</filename> neu
      zu starten, benutzen Sie das nachstehende Kommando:</para>

    <screen>&prompt.root; <userinput>/etc/rc.d/sshd onerestart</userinput></screen>

    <para>Ob ein Dienst in <filename>/etc/rc.conf</filename>
      aktiviert ist, k&ouml;nnen Sie leicht herausfinden, indem
      Sie das entsprechende <filename>rc.d</filename>-Skript
      mit der Option <option>rcvar</option> aufrufen.  Ein
      Administrator kann beispielsweise wie folgt pr&uuml;fen, ob
      der <command>sshd</command>-Dienst in
      <filename>/etc/rc.conf</filename> aktiviert ist:</para>

    <screen>&prompt.root; <userinput>/etc/rc.d/sshd rcvar</userinput>
# sshd
$sshd_enable=YES</screen>

    <note>
      <para>Die zweite Zeile (<literal># sshd</literal>) wird
	vom Kommando <command>sshd</command> ausgegeben; sie
	kennzeichnet nicht die Eingabeaufforderung von
	<username>root</username>.</para>
    </note>

    <para>Ob ein Dienst l&auml;uft, kann mit der Option
      <option>status</option> abgefragt werden.  Das folgende
      Kommando &uuml;berpr&uuml;ft, ob der <command>sshd</command>
      auch wirklich gestartet wurde:</para>

    <screen>&prompt.root; <userinput>/etc/rc.d/sshd status</userinput>
sshd is running as pid 433.</screen>

    <para>Einige Dienste k&ouml;nnen &uuml;ber die Option
      <option>reload</option> neu initialisiert werden.  Dazu wird
      dem Dienst &uuml;ber ein Signal mitgeteilt,
      dass er seine Konfigurationsdateien neu einlesen soll.
      Oft wird dazu das Signal <literal>SIGHUP</literal>
      verwendet.  Beachten Sie aber, dass nicht alle Dienste diese
      Option unterst&uuml;tzen.</para>

    <para>Die meisten Systemdienste werden beim Systemstart vom
      <application>rc.d</application>-System gestartet.  Zum Beispiel
      aktiviert das Skript <filename>bgfsck</filename> die Pr&uuml;fung
      von Dateisystemen im Hintergrund.  Das Skript gibt die folgende
      Meldung aus, wenn es gestartet wird:</para>

    <screen>Starting background file system checks in 60 seconds.</screen>

    <para>Viele Systemdienste h&auml;ngen von anderen Diensten
      ab.  NIS und andere RPC-basierende Systeme h&auml;ngen
      beispielsweise von dem <command>rpcbind</command>-Dienst
      (portmapper) ab.  Im Kopf der Startskripten befinden sich
      die Informationen &uuml;ber Abh&auml;ngigkeiten von anderen
      Diensten und weitere Metadaten.Mithilfe dieser Daten
      bestimmt das Programm &man.rcorder.8; beim Systemstart die
      Startreihenfolge der Dienste.</para>

    <para>Folgende Schl&uuml;sselw&ouml;rter m&uuml;ssen im Kopf aller
      Startskripten verwendet werden (da sie von &man.rc.subr.8; zum
      <quote>Aktivieren</quote> des Startskripts ben&ouml;tigt
      werden:</para>

    <itemizedlist>
      <listitem>
	<para><literal>PROVIDE</literal>: Gibt die Namen der Dienste an,
	  die mit dieser Datei zur Verf&uuml;gung gestellt werden.</para>
      </listitem>
    </itemizedlist>

    <para>Die folgenden Schl&uuml;sselw&ouml;rter k&ouml;nnen im Kopf
      des Startskripts angegeben werden.  Sie sind zwar nicht unbedingt
      notwendig, sind aber hilfreich beim Umgang mit
      &man.rcorder.8;:</para>

    <itemizedlist>
      <listitem>
	<para><literal>REQUIRE</literal>: Gibt die Namen der Dienste an,
	  von denen dieser Dienst abh&auml;ngt.  Diese Datei wird
	  <emphasis>nach</emphasis> den angegebenen Diensten
	  ausgef&uuml;hrt.</para>
      </listitem>

      <listitem>
	<para><literal>BEFORE</literal>: Z&auml;hlt Dienste auf,
	  die auf diesen Dienst angewiesen sind.  Diese Datei wird
	  <emphasis>vor</emphasis> den angegebenen Diensten
	  ausgef&uuml;hrt.</para>
      </listitem>
    </itemizedlist>

    <para>Durch das Verwenden dieser Schl&uuml;sselw&ouml;rter kann
      ein Administrator die Startreihenfolge von Systemdiensten
      feingranuliert steuern, ohne mit den
      Schwierigkeiten des <quote>runlevel</quote>-Systems
      anderer &unix; Systeme k&auml;mpfen zu m&uuml;ssen.</para>

    <para>Weitere Informationen &uuml;ber das
      <filename>rc.d</filename>-System finden sich in den
      Manualpages zu &man.rc.8; sowie &man.rc.subr.8;.  Wenn Sie
      Ihre eigenen <filename>rc.d</filename>-Skripte schreiben
      wollen, sollten Sie den Artikel
      <ulink url="&url.articles.rc-scripting.en">Practical rc.d
      scripting in BSD</ulink> lesen.</para>
  </sect1>

  <sect1 id="config-network-setup">
    <sect1info>
      <authorgroup>
        <author>
	 <firstname>Marc</firstname>
	 <surname>Fonvieille</surname>
	 <contrib>Beigetragen von </contrib>
	 <!-- 6 October 2002 -->
        </author>
      </authorgroup>
    </sect1info>

    <title>Einrichten von Netzwerkkarten</title>

    <indexterm>
      <primary>Netzwerkkarten</primary>
      <secondary>einrichten</secondary>
    </indexterm>

    <para>Ein Rechner ohne Netzanschluss ist heute nicht mehr
      vorstellbar.  Die Konfiguration einer Netzwerkkarte geh&ouml;rt zu
      den allt&auml;glichen Aufgaben eines &os; Administrators.</para>

    <sect2>
      <title>Bestimmen des richtigen Treibers</title>

      <indexterm>
        <primary>Netzwerkkarten</primary>
        <secondary>Treiber</secondary>
      </indexterm>

      <para>Bevor Sie anfangen, sollten Sie das Modell Ihrer Karte kennen,
        wissen welchen Chip die Karte benutzt und bestimmen, ob es sich
	um eine PCI- oder ISA-Karte handelt.  Eine Aufz&auml;hlung der
	unterst&uuml;tzten PCI- und ISA-Karten finden Sie in der
	Liste der unterst&uuml;tzen Ger&auml;te.  Schauen Sie nach, ob Ihre
	Karte dort aufgef&uuml;hrt ist.</para>

      <para>Wenn Sie wissen, dass Ihre Karte unterst&uuml;tzt wird,
        m&uuml;ssen Sie den Treiber f&uuml;r Ihre Karte bestimmen.
	<filename>/usr/src/sys/conf/NOTES</filename> und
	<filename>/usr/src/sys/<replaceable>arch</replaceable>/conf/NOTES</filename>
	enthalten eine
	Liste der verf&uuml;gbaren Treiber mit Informationen zu den
	unterst&uuml;tzten Chips&auml;tzen und Karten.  Wenn Sie sich nicht
	sicher sind, ob Sie den richtigen Treiber ausgew&auml;hlt haben,
	lesen Sie die Hilfeseite des Treibers.  Die Hilfeseite enth&auml;lt
	weitere Informationen &uuml;ber die unterst&uuml;tzten Ger&auml;te
	und macht auch auf m&ouml;gliche Probleme aufmerksam.</para>

      <para>Wenn Sie eine gebr&auml;uchliche Karte besitzen, brauchen Sie
        meistens nicht lange nach dem passenden Treiber zu suchen.  Die
	Treiber zu diesen Karten sind schon im
	<filename>GENERIC</filename>-Kernel enthalten und die Karte sollte
	w&auml;hrend des Systemstarts erkannt werden:</para>

<screen>dc0: &lt;82c169 PNIC 10/100BaseTX&gt; port 0xa000-0xa0ff mem 0xd3800000-0xd38
000ff irq 15 at device 11.0 on pci0
miibus0: &lt;MII bus&gt; on dc0
bmtphy0: &lt;BCM5201 10/100baseTX PHY&gt; PHY 1 on miibus0
bmtphy0:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
dc0: Ethernet address: 00:a0:cc:da:da:da
dc0: [ITHREAD]
dc1: &lt;82c169 PNIC 10/100BaseTX&gt; port 0x9800-0x98ff mem 0xd3000000-0xd30
000ff irq 11 at device 12.0 on pci0
miibus1: &lt;MII bus&gt; on dc1
bmtphy1: &lt;BCM5201 10/100baseTX PHY&gt; PHY 1 on miibus1
bmtphy1:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
dc1: Ethernet address: 00:a0:cc:da:da:db
dc1: [ITHREAD]</screen>

      <para>Im Beispiel erkennt das System zwei Karten, die den
        &man.dc.4; Treiber benutzen.</para>

      <para>Ist der Treiber f&uuml;r Ihre Netzwerkkarte nicht
	in <filename>GENERIC</filename> enthalten, m&uuml;ssen
	Sie den Treiber laden, um die Karte zu benutzen.
	Sie k&ouml;nnen den Treiber auf zwei Arten laden:</para>

      <itemizedlist>
	<listitem>
	  <para>Am einfachsten ist es, das Kernelmodul f&uuml;r
	    Ihre Karte mit &man.kldload.8; zu laden.  Allerdings
	    gibt es nicht f&uuml;r alle Karten Kernelmodule;
	    zum Beispiel gibt es keine Kernelmodule f&uuml;r
	    ISA-Karten.</para>
	</listitem>

	<listitem>
	  <para>Alternativ k&ouml;nnen Sie den Treiber f&uuml;r die
	    Karte fest in den Kernel einbinden.  Schauen Sie sich dazu
	    <filename>/usr/src/sys/conf/NOTES</filename>,
	    <filename>/usr/src/sys/<replaceable>arch</replaceable>/conf/NOTES</filename>
	    und die Hilfeseite des Treibers, den Sie in den Kernel
	    einbinden m&ouml;chten, an.  Die &Uuml;bersetzung des Kernels
	    wird in <xref linkend="kernelconfig"> beschrieben.  Wenn
	    Ihre Karte w&auml;hrend des Systemstarts vom Kernel
	    (<filename>GENERIC</filename>) erkannt wurde, m&uuml;ssen
	    Sie den Kernel nicht neu &uuml;bersetzen.</para>
	</listitem>
      </itemizedlist>

      <sect3 id="config-network-ndis">
	<title>&windows;-NDIS-Treiber einsetzen</title>

        <indexterm><primary>NDIS</primary></indexterm>
        <indexterm><primary>NDISulator</primary></indexterm>
        <indexterm><primary>&windows;-Treiber</primary></indexterm>
        <indexterm><primary>Microsoft Windows</primary></indexterm>
        <indexterm>
          <primary>Microsoft Windows</primary>
          <secondary>Ger&auml;tetreiber</secondary></indexterm>
        <indexterm><primary>KLD (kernel loadable object)</primary></indexterm>

        <!-- Hm.  Soll man den letzten Indexterm abwandeln, d.h. die
          Langversion weglassen?  Keine Ahnung.  Wenn ja, dann muss das
          auch in handbook/linuxemu/chapter.sgml passieren! -->

        <para>Leider stellen nach wie vor viele Unternehmen die
          Spezifikationen ihrer Treiber der Open Source Gemeinde
          nicht zur Verf&uuml;gung, weil sie diese Informationen
          als Gesch&auml;ftsgeheimnisse betrachten.  Daher haben die
          Entwickler von FreeBSD und anderen Betriebssystemen nur
          zwei M&ouml;glichkeiten.  Entweder versuchen sie in einem
          aufw&auml;ndigen Prozess den Treiber durch
          <foreignphrase>Reverse Engineering</foreignphrase>
          nachzubauen, oder sie versuchen, die vorhandenen
          Bin&auml;rtreiber der &microsoft.windows;-Plattform zu
          verwenden.  Die meisten Entwickler, darunter auch die an
          FreeBSD beteiligten, haben sich f&uuml;r den zweiten Ansatz
          entschieden.</para>

        <para>Bill Paul (wpaul) ist es zu verdanken, dass es seit
          FreeBSD&nbsp;5.3-RELEASE eine
          <quote>native</quote> Unterst&uuml;tzung der
          <foreignphrase>Network Driver Interface
          Specification</foreignphrase> (NDIS) gibt.  Der
          FreeBSD NDISulator (auch als Project Evil bekannt) nutzt
          den bin&auml;ren &windows;-Treiber, indem er diesem vorgibt,
          unter &windows; zu laufen.  Da der &man.ndis.4;-Treiber
          eine &windows;-Bin&auml;rdatei nutzt, kann er nur auf
          &i386;- und amd64-Systemen verwendet werden.</para>

        <note>
          <para>Der &man.ndis.4;-Treiber unterst&uuml;tzt prim&auml;r
            PCI-, CardBus- sowie PCMCIA-Ger&auml;te, USB-Ger&auml;te
            werden hingegen noch nicht unterst&uuml;tzt.</para>
        </note>

        <para>Um den NDISulator zu verwenden, ben&ouml;tigen Sie drei
          Dinge:</para>

        <orderedlist>
          <listitem>
            <para>Die Kernelquellen</para>
          </listitem>

          <listitem>
            <para>Den &windowsxp;-Bin&auml;rtreiber
             (mit der Erweiterung <filename>.SYS</filename>)</para>
          </listitem>

          <listitem>
            <para>Die Konfigurationsdatei des &windowsxp;-Treibers
            (mit der Erweiterung <filename>.INF</filename>)</para>
          </listitem>
        </orderedlist>

        <para>Suchen Sie die Dateien f&uuml;r Ihre Karte.  Diese
          befinden sich meistens auf einer beigelegten CD-ROM, oder
          k&ouml;nnen von der Internetseite des Herstellers
          heruntergeladen werden.  In den folgenden Beispielen werden
          die Dateien <filename>W32DRIVER.SYS</filename> und
          <filename>W32DRIVER.INF</filename> verwendet.</para>

        <note>
          <para>Sie k&ouml;nnen einen &windows;/i386-Treiber nicht
            unter &os;/amd64 einsetzen, vielmehr ben&ouml;tigen Sie
            daf&uuml;r einen &windows;/amd64-Treiber.</para>
        </note>

        <para>Als N&auml;chstes kompilieren Sie den bin&auml;ren
          Treiber, um ein Kernelmodul zu erzeugen.  Dazu rufen Sie als
          <username>root</username> &man.ndisgen.8; auf:</para>

        <screen>&prompt.root; <userinput>ndisgen <replaceable>/path/to/W32DRIVER.INF</replaceable> <replaceable>/path/to/W32DRIVER.SYS</replaceable></userinput></screen>

        <para>&man.ndisgen.8; arbeitet interaktiv, ben&ouml;tigt es
          weitere Informationen, so fragt es Sie danach.  Als Ergebnis
          erhalten Sie ein Kernelmodul im Arbeitsverzeichnis, das Sie
          wie folgt laden k&ouml;nnen:</para>

        <screen>&prompt.root; <userinput>kldload <replaceable>./W32DRIVER.ko</replaceable></userinput></screen>

        <para>Neben dem vorhin erzeugten Kernelmodul m&uuml;ssen Sie
          auch die Kernelmodule <filename>ndis.ko</filename> und
          <filename>if_ndis.ko</filename> laden.  Diese Module sollten
          automatisch geladen werden, wenn Sie ein von &man.ndis.4;
          abh&auml;ngiges Modul laden.  Wollen Sie die Module hingegen
          manuell laden, geben Sie die folgenden Befehle ein:</para>

        <screen>&prompt.root; <userinput>kldload ndis</userinput>
&prompt.root; <userinput>kldload if_ndis</userinput></screen>

        <para>Der erste Befehl l&auml;dt dabei den NDIS-Miniport-Treiber,
          der zweite das tats&auml;chliche Netzwerkger&auml;t.</para>

        <para>&Uuml;berpr&uuml;fen Sie nun die Ausgabe von &man.dmesg.8;
          auf eventuelle Fehler w&auml;hrend des Ladevorgangs.  Gab es
          dabei keine Probleme, sollten Sie eine Ausgabe &auml;hnlich
          der folgenden erhalten:</para>

        <screen>ndis0: &lt;Wireless-G PCI Adapter&gt; mem 0xf4100000-0xf4101fff irq 3 at device 8.0 on pci1
ndis0: NDIS API version: 5.0
ndis0: Ethernet address: 0a:b1:2c:d3:4e:f5
ndis0: 11b rates: 1Mbps 2Mbps 5.5Mbps 11Mbps
ndis0: 11g rates: 6Mbps 9Mbps 12Mbps 18Mbps 36Mbps 48Mbps 54Mbps</screen>

        <para>Ab jetzt k&ouml;nnen Sie mit dem Ger&auml;t
          <devicename>ndis0</devicename> wie mit jeder anderen
          Ger&auml;tedatei (etwa <devicename>dc0</devicename>)
          arbeiten.</para>

        <para>Wie jedes Kernelmodul k&ouml;nnen auch die NDIS-Module
          beim Systemstart automatisch geladen werden.  Dazu kopieren
          Sie das erzeugte Modul (<filename>W32DRIVER_SYS.ko</filename>)
          in das Verzeichnis <filename
          class="directory">/boot/modules</filename>.  Danach
          f&uuml;gen Sie die folgende Zeile in
          <filename>/boot/loader.conf</filename> ein:</para>

        <programlisting>W32DRIVER_SYS_load="YES"</programlisting>
      </sect3>
    </sect2>

    <sect2>
      <title>Konfiguration von Netzwerkkarten</title>

      <indexterm>
        <primary>Netzwerkkarten</primary>
        <secondary>einrichten</secondary>
      </indexterm>

      <para>Nachdem der richtige Treiber f&uuml;r die Karte geladen ist,
        muss die Karte konfiguriert werden.  Unter Umst&auml;nden ist
	die Karte schon w&auml;hrend der Installation mit
	<application>sysinstall</application> konfiguriert worden.</para>

      <para>Das nachstehende Kommando zeigt die Konfiguration der Karten
        eines Systems an:</para>

<screen>&prompt.user; <userinput>ifconfig</userinput>
dc0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        options=80008&lt;VLAN_MTU,LINKSTATE&gt;
        ether 00:a0:cc:da:da:da
        inet 192.168.1.3 netmask 0xffffff00 broadcast 192.168.1.255
        media: Ethernet autoselect (100baseTX &lt;full-duplex&gt;)
        status: active
dc1: flags=8802&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        options=80008&lt;VLAN_MTU,LINKSTATE&gt;
        ether 00:a0:cc:da:da:db
        inet 10.0.0.1 netmask 0xffffff00 broadcast 10.0.0.255
        media: Ethernet 10baseT/UTP
        status: no carrier
plip0: flags=8810&lt;POINTOPOINT,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; metric 0 mtu 16384
        options=3&lt;RXCSUM,TXCSUM&gt;
        inet6 fe80::1%lo0 prefixlen 64 scopeid 0x4
        inet6 ::1 prefixlen 128
        inet 127.0.0.1 netmask 0xff000000
        nd6 options=3&lt;PERFORMNUD,ACCEPT_RTADV&gt;</screen>

      <para>Im Beispiel werden Informationen zu den folgenden Ger&auml;ten
        angezeigt:</para>

      <itemizedlist>
	<listitem>
	  <para><devicename>dc0</devicename>: Der erste
	    Ethernet-Adapter</para>
	</listitem>

	<listitem>
	  <para><devicename>dc1</devicename>: Der zweite
	    Ethernet-Adapter</para>
	</listitem>

	<listitem>
	  <para><devicename>plip0</devicename>: Die parallele
	    Schnittstelle (falls Ihr System &uuml;ber eine
	    derartige Schnittstelle verf&uuml;gt)</para>
	</listitem>

	<listitem>
	  <para><devicename>lo0</devicename>: Das Loopback-Ger&auml;t</para>
	</listitem>
      </itemizedlist>

      <para>Der Name der Netzwerkkarte wird aus dem Namen des Treibers und
        einer Zahl zusammengesetzt.  Die Zahl gibt die Reihenfolge an, in
	der die Ger&auml;te beim Systemstart erkannt wurden.  Die dritte
	Karte, die den &man.sis.4; Treiber benutzt, w&uuml;rde
	beispielsweise <devicename>sis2</devicename> hei&szlig;en.</para>

      <para>Der Adapter <devicename>dc0</devicename> aus dem Beispiel ist
        aktiv.  Sie erkennen das an den folgenden Hinweisen:</para>

      <orderedlist>
	<listitem>
	  <para><literal>UP</literal> bedeutet, dass die Karte
	    konfiguriert und aktiv ist.</para>
	</listitem>

	<listitem>
	  <para>Der Karte wurde die Internet-Adresse (<literal>inet</literal>)
	    <hostid role="ipaddr">192.168.1.3</hostid> zugewiesen.</para>
	</listitem>

	<listitem>
	  <para>Die Subnetzmaske ist richtig
	    (<hostid role="netmask">0xffffff00</hostid> entspricht
	    <hostid role="netmask">255.255.255.0</hostid>).</para>
	</listitem>

	<listitem>
	  <para>Die Broadcast-Adresse <hostid
	    role="ipaddr">192.168.1.255</hostid> ist richtig.</para>
	</listitem>

	<listitem>
	  <para>Die MAC-Adresse der Karte (<literal>ether</literal>)
	    lautet <hostid role="mac">00:a0:cc:da:da:da</hostid>.</para>
	</listitem>

	<listitem>
	  <para>Die automatische Medienerkennung ist aktiviert
	    (<literal>media: Ethernet autoselect (100baseTX
	      &lt;full-duplex&gt;)</literal>).  Der Adapter
	    <devicename>dc1</devicename> benutzt das Medium
	    <literal>10baseT/UTP</literal>.  Weitere Informationen
	    &uuml;ber die einstellbaren Medien entnehmen
	    Sie bitte der Hilfeseite des Treibers.</para>
	</listitem>

	<listitem>
	  <para>Der Verbindungsstatus (<literal>status</literal>) ist
	    <literal>active</literal>, das hei&szlig;t es wurde ein
	    Tr&auml;gersignal entdeckt.  F&uuml;r
	    <devicename>dc1</devicename> wird <literal>status: no
	      carrier</literal> angezeigt.  Das ist normal, wenn kein Kabel
	    an der Karte angeschlossen ist.</para>
	</listitem>
      </orderedlist>

      <para>W&auml;re die Karte nicht konfiguriert, w&uuml;rde die Ausgabe
        von &man.ifconfig.8; so aussehen:</para>

<screen>dc0: flags=8843&lt;BROADCAST,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        options=80008&lt;VLAN_MTU,LINKSTATE&gt;
        ether 00:a0:cc:da:da:da
        media: Ethernet autoselect (100baseTX &lt;full-duplex&gt;)
        status: active</screen>

      <para>Sie brauchen die Berechtigungen von <username>root</username>, um
        Ihre Karte zu konfigurieren.  Die Konfiguration kann auf der
	Kommandozeile mit &man.ifconfig.8; erfolgen, allerdings
	m&uuml;sste sie dann nach jedem Neustart wiederholt werden.
	Dauerhaft wird die Karte in <filename>/etc/rc.conf</filename>
	konfiguriert.</para>

      <para>&Ouml;ffnen Sie <filename>/etc/rc.conf</filename> mit Ihrem
        Lieblingseditor und f&uuml;gen Sie f&uuml;r jede Karte Ihres
	Systems eine Zeile hinzu.  In dem hier diskutierten Fall wurden
	die nachstehenden Zeilen eingef&uuml;gt:</para>

<programlisting>ifconfig_dc0="inet 192.168.1.3 netmask 255.255.255.0"
ifconfig_dc1="inet 10.0.0.1 netmask 255.255.255.0 media 10baseT/UTP"</programlisting>

      <para>Ersetzen Sie <devicename>dc0</devicename>,
        <devicename>dc1</devicename> usw. durch die Ger&auml;tenamen Ihrer
	Karten und setzen Sie die richtigen IP-Adressen ein.  Die
	Hilfeseiten des Treibers und &man.ifconfig.8; enthalten weitere
	Einzelheiten &uuml;ber verf&uuml;gbare Optionen.  Die Syntax von
	<filename>/etc/rc.conf</filename> wird in &man.rc.conf.5;
	erkl&auml;rt.</para>

      <para>Wenn Sie das Netz w&auml;hrend der Installation
        konfiguriert haben, existieren vielleicht schon Eintr&auml;ge
	f&uuml;r Ihre Karten.  &Uuml;berpr&uuml;fen Sie
	<filename>/etc/rc.conf</filename> bevor Sie weitere Zeilen
	hinzuf&uuml;gen.</para>

      <para>In <filename>/etc/hosts</filename> k&ouml;nnen Sie die Namen
        und IP-Adressen der Rechner Ihres LANs eintragen.  Weitere
	Informationen entnehmen Sie bitte &man.hosts.5; und
	<filename>/usr/share/examples/etc/hosts</filename>.</para>

      <note>
	<para>Soll Ihr System sich auch mit dem Internet verbinden
	  k&ouml;nnen, m&uuml;ssen Sie Default-Gateway und
	  Nameserver manuell konfigurieren:</para>

	<screen>&prompt.root; <userinput>echo 'defaultrouter="<replaceable>Ihr_Default_Gateway</replaceable>"' &gt;&gt; /etc/rc.conf</userinput>
&prompt.root; <userinput>echo 'nameserver <replaceable>Ihr_DNS_Server</replaceable>' &gt;&gt; /etc/resolv.conf</userinput></screen>
      </note>
    </sect2>

    <sect2>
      <title>Test und Fehlersuche</title>

      <para>Nachdem Sie die notwendigen &Auml;nderungen in
        <filename>/etc/rc.conf</filename> vorgenommen haben, f&uuml;hren
	Sie einen Neustart Ihres Systems durch.  Dadurch werden die Adapter
	konfiguriert und Sie stellen sicher, dass der Start ohne
	Konfigurationsfehler erfolgt.  Alternativ k&ouml;nnen Sie
	auch lediglich die Netzwerkeinstellungen neu initialisieren:</para>

      <screen>&prompt.root; <userinput>/etc/rc.d/netif restart</userinput></screen>

      <note>
	<para>Haben Sie ein Default-Gateway definiert (in der Datei
	  <filename>/etc/rc.conf</filename>), m&uuml;ssen Sie
	  auch den folgenden Befehl ausf&uuml;hren:</para>

	<screen>&prompt.root; <userinput>/etc/rc.d/routing restart</userinput></screen>
      </note>

      <para>Wenn das System gestartet ist, sollten Sie die Netzwerkkarten
	testen.</para>

      <sect3>
	<title>Test der Ethernet-Karte</title>

        <indexterm>
          <primary>Netzwerkkarten</primary>
          <secondary>testen</secondary>
        </indexterm>

	<para>Mit zwei Tests k&ouml;nnen Sie pr&uuml;fen, ob die
	  Ethernet-Karte richtig konfiguriert ist.  Testen Sie zuerst mit
	  <command>ping</command> den Adapter selbst und sprechen Sie dann
	  eine andere Maschine im LAN an.</para>

	<para>Zuerst, der Test des Adapters:</para>

<screen>&prompt.user; <userinput>ping -c5 192.168.1.3</userinput>
PING 192.168.1.3 (192.168.1.3): 56 data bytes
64 bytes from 192.168.1.3: icmp_seq=0 ttl=64 time=0.082 ms
64 bytes from 192.168.1.3: icmp_seq=1 ttl=64 time=0.074 ms
64 bytes from 192.168.1.3: icmp_seq=2 ttl=64 time=0.076 ms
64 bytes from 192.168.1.3: icmp_seq=3 ttl=64 time=0.108 ms
64 bytes from 192.168.1.3: icmp_seq=4 ttl=64 time=0.076 ms

--- 192.168.1.3 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.074/0.083/0.108/0.013 ms</screen>

	<para>Jetzt versuchen wir, eine andere Maschine im LAN zu
	  erreichen:</para>

<screen>&prompt.user; <userinput>ping -c5 192.168.1.2</userinput>
PING 192.168.1.2 (192.168.1.2): 56 data bytes
64 bytes from 192.168.1.2: icmp_seq=0 ttl=64 time=0.726 ms
64 bytes from 192.168.1.2: icmp_seq=1 ttl=64 time=0.766 ms
64 bytes from 192.168.1.2: icmp_seq=2 ttl=64 time=0.700 ms
64 bytes from 192.168.1.2: icmp_seq=3 ttl=64 time=0.747 ms
64 bytes from 192.168.1.2: icmp_seq=4 ttl=64 time=0.704 ms

--- 192.168.1.2 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.700/0.729/0.766/0.025 ms</screen>

	<para>Sie k&ouml;nnen auch den Namen der Maschine anstelle von
	  <hostid role="ipaddr">192.168.1.2</hostid> benutzen, wenn Sie
	  <filename>/etc/hosts</filename> entsprechend eingerichtet
	  haben.</para>
      </sect3>

      <sect3>
	<title>Fehlersuche</title>

        <indexterm>
          <primary>Netzwerkkarten</primary>
          <secondary>Fehlersuche</secondary>
        </indexterm>

	<para>Fehler zu beheben, ist immer sehr m&uuml;hsam.
	  Indem Sie die einfachen Sachen zuerst pr&uuml;fen,
	  erleichtern Sie sich die Aufgabe.  Steckt das Netwerkkabel?
	  Sind die Netzwerkdienste richtig konfiguriert?  Funktioniert
	  die Firewall?  Wird die Netwerkkarte von &os;
	  unterst&uuml;tzt?  Lesen Sie immer die Hardware-Informationen
	  des Releases, bevor Sie einen Fehlerbericht einsenden.
	  Aktualisieren Sie Ihre &os;-Version
	  auf -STABLE.  Suchen Sie in den Archiven der Mailinglisten
	  oder auf dem Internet nach bekannten L&ouml;sungen.</para>

	<para>Wenn die Karte funktioniert, die Verbindungen aber
	  zu langsam sind, lesen Sie bitte die Hilfeseite
	  &man.tuning.7;.  Pr&uuml;fen Sie auch die
	  Netzwerkkonfiguration, da falsche Einstellungen die
	  Ursache f&uuml;r langsame Verbindungen sein k&ouml;nnen.</para>

	<para>Wenn Sie viele <errorname>device timeout</errorname>
	  Meldungen in den Systemprotokollen finden, pr&uuml;fen
	  Sie, dass es keinen Konflikt zwischen der Netzwerkkarte
	  und anderen Ger&auml;ten Ihres Systems gibt.
	  &Uuml;berpr&uuml;fen Sie nochmals die Verkabelung.
	  Unter Umst&auml;nden ben&ouml;tigen Sie eine neue
	  Netzwerkkarte.</para>

	<para>Wenn Sie in den Systemprotokollen
	  <errorname>watchdog timeout</errorname> Fehlermeldungen
	  finden, kontrollieren Sie zuerst die Verkabelung.
	  &Uuml;berpr&uuml;fen Sie dann, ob der PCI-Steckplatz der
	  Karte Bus Mastering unterst&uuml;tzt.  Auf einigen
	  &auml;lteren Motherboards ist das nur f&uuml;r einen
	  Steckplatz (meistens Steckplatz 0) der Fall.  Lesen Sie
	  in der Dokumentation Ihrer Karte und Ihres Motherboards
	  nach, ob das vielleicht die Ursache des Problems sein
	  k&ouml;nnte.</para>

	<para>Die Meldung <errorname>No route to host</errorname>
	  erscheint, wenn Ihr System ein Paket nicht zustellen
	  kann.  Das kann vorkommen weil beispielsweise keine
	  Default-Route gesetzt wurde oder das Netzwerkkabel
	  nicht richtig steckt.  Schauen Sie in der Ausgabe
	  von <command>netstat -rn</command> nach, ob eine
	  Route zu dem Zielsystem existiert.  Wenn nicht, lesen
	  Sie bitte das <xref linkend="advanced-networking">.</para>

	<para>Die Meldung <errorname>ping: sendto: Permission
	    denied</errorname> wird oft von einer falsch konfigurierten
	  Firewall verursacht.  Wenn keine Regeln definiert wurden,
	  blockiert eine aktivierte Firewall alle Pakete, selbst
	  einfache <command>ping</command>-Pakete.  Weitere
	  Informationen erhalten Sie in <xref linkend="firewalls">.</para>

	<para>Falls die Leistung der Karte schlecht ist, setzen
	  Sie die Medienerkennung von <literal>autoselect</literal>
	  (automatisch) auf das richtige Medium.  In vielen F&auml;llen
	  l&ouml;st diese Ma&szlig;nahme Leistungsprobleme.  Wenn
	  nicht, pr&uuml;fen Sie nochmal die Netzwerkeinstellungen
	  und lesen Sie die Hilfeseite &man.tuning.7;.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="configtuning-virtual-hosts">
    <title>Virtual Hosts</title>

    <indexterm><primary>virtual hosts</primary></indexterm>
    <indexterm><primary>IP-Aliase</primary></indexterm>

    <para>Ein gebr&auml;uchlicher Zweck von &os; ist das
      virtuelle Hosting, bei dem ein Server im Netzwerk wie
      mehrere Server aussieht.  Dies wird dadurch erreicht,
      dass einem Netzwerkinterface mehrere Netzwerk-Adressen
      zugewiesen werden.</para>

    <para>Ein Netzwerkinterface hat eine <quote>echte</quote>
      Adresse und kann beliebig viele <quote>alias</quote> Adressen
      haben.  Die Aliase werden durch entsprechende alias Eintr&auml;ge
      in <filename>/etc/rc.conf</filename> festgelegt.</para>

    <para>Ein alias Eintrag f&uuml;r das Interface
      <devicename>fxp0</devicename> sieht wie folgt aus:</para>

<programlisting>ifconfig_fxp0_alias0="inet xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx"</programlisting>

    <para>Beachten Sie, dass die Alias-Eintr&auml;ge mit
      <literal>alias0</literal> anfangen m&uuml;ssen und
      weiter hochgez&auml;hlt werden, das hei&szlig;t
      <literal>_alias1</literal>, <literal>_alias2</literal>,
      und so weiter.  Die Konfiguration der Aliase h&ouml;rt
      bei der ersten fehlenden Zahl auf.</para>

    <para>Die Berechnung der Alias-Netzwerkmasken ist wichtig, doch
      zum Gl&uuml;ck einfach.  F&uuml;r jedes Interface muss es
      eine Adresse geben, die die Netzwerkmaske des Netzwerkes richtig
      beschreibt.  Alle anderen Adressen in diesem Netzwerk haben dann
      eine Netzwerkmaske, die mit <literal>1</literal> gef&uuml;llt
      ist (also <hostid role="netmask">255.255.255.255</hostid>
      oder hexadezimal
      <hostid role="netmask">0xffffffff</hostid>).</para>

    <para>Als Beispiel betrachten wir den Fall, in dem
      <devicename>fxp0</devicename> mit zwei Netzwerken verbunden
      ist: dem Netzwerk <hostid role="ipaddr">10.1.1.0</hostid> mit der
      Netzwerkmaske <hostid role="netmask">255.255.255.0</hostid>
      und dem Netzwerk <hostid role="ipaddr">202.0.75.16</hostid> mit der
      Netzwerkmaske <hostid role="netmask">255.255.255.240</hostid>.
      Das System soll die Adressen <hostid role="ipaddr">10.1.1.1</hostid>
      bis <hostid role="ipaddr">10.1.1.5</hostid> und
      <hostid role="ipaddr">202.0.75.17</hostid> bis
      <hostid role="ipaddr">202.0.75.20</hostid> belegen.
      Wie eben beschrieben, hat nur die erste Adresse in einem
      Netzwerk (hier <hostid role="ipaddr">10.0.1.1</hostid>
      und <hostid role="ipaddr">202.0.75.17</hostid>) die
      richtige Netzwerkmaske.  Alle anderen Adressen
      (<hostid role="ipaddr">10.1.1.2</hostid> bis <hostid
      role="ipaddr">10.1.1.5</hostid> und <hostid
      role="ipaddr">202.0.75.18</hostid> bis <hostid
      role="ipaddr">202.0.75.20</hostid>) erhalten die Maske
      <hostid role="netmask">255.255.255.255</hostid>.</para>

    <para>Die folgenden Eintr&auml;ge in
      <filename>/etc/rc.conf</filename> konfigurieren den Adapter
      entsprechend dem Beispiel:</para>

<programlisting>ifconfig_fxp0="inet 10.1.1.1 netmask 255.255.255.0"
ifconfig_fxp0_alias0="inet 10.1.1.2 netmask 255.255.255.255"
ifconfig_fxp0_alias1="inet 10.1.1.3 netmask 255.255.255.255"
ifconfig_fxp0_alias2="inet 10.1.1.4 netmask 255.255.255.255"
ifconfig_fxp0_alias3="inet 10.1.1.5 netmask 255.255.255.255"
ifconfig_fxp0_alias4="inet 202.0.75.17 netmask 255.255.255.240"
ifconfig_fxp0_alias5="inet 202.0.75.18 netmask 255.255.255.255"
ifconfig_fxp0_alias6="inet 202.0.75.19 netmask 255.255.255.255"
ifconfig_fxp0_alias7="inet 202.0.75.20 netmask 255.255.255.255"</programlisting>

  </sect1>

  <sect1 id="configtuning-configfiles">
    <title>Konfigurationsdateien</title>

    <sect2>
      <title><filename class="directory">/etc</filename> Layout</title>
      <para>Konfigurationsdateien finden sich in einigen Verzeichnissen
	unter anderem in:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <colspec colwidth="1*">
	  <colspec colwidth="2*">

	  <tbody>
	    <row>
	      <entry><filename class="directory">/etc</filename></entry>
	      <entry>Enth&auml;lt generelle Konfigurationsinformationen,
		die Daten hier sind systemspezifisch.</entry>
	    </row>
	    <row>
	      <entry><filename
	        class="directory">/etc/defaults</filename></entry>
	      <entry>Default Versionen der Konfigurationsdateien.</entry>
	    </row>
	    <row>
	      <entry><filename class="directory">/etc/mail</filename></entry>
	      <entry>Enth&auml;lt die &man.sendmail.8; Konfiguration
		und weitere MTA Konfigurationsdateien.</entry>
	    </row>
	    <row>
	      <entry><filename class="directory">/etc/ppp</filename></entry>
	      <entry>Hier findet sich die Konfiguration f&uuml;r
		die User- und Kernel-ppp Programme.</entry>
	    </row>
	    <row>
	      <entry><filename class="directory">/etc/namedb</filename></entry>
	      <entry>Das Vorgabeverzeichnis, in dem Daten von
		&man.named.8; gehalten werden.  Normalerweise
		werden hier <filename>named.conf</filename> und Zonendaten
		abgelegt.</entry>
	    </row>
	    <row>
	      <entry><filename
	        class="directory">/usr/local/etc</filename></entry>
	      <entry>Installierte Anwendungen legen hier ihre
		Konfigurationsdateien ab.  Dieses Verzeichnis kann
		Unterverzeichnisse f&uuml;r bestimmte Anwendungen
		enthalten.</entry>
	    </row>
	    <row>
	      <entry><filename
	        class="directory">/usr/local/etc/rc.d</filename></entry>
	      <entry>Ort f&uuml;r Start- und Stopskripten installierter
		Anwendungen.</entry>
	    </row>
	    <row>
	      <entry><filename class="directory">/var/db</filename></entry>
	      <entry>Automatisch generierte systemspezifische Datenbanken,
	        wie die Paket-Datenbank oder die
		<command>locate</command>-Datenbank.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </sect2>

    <sect2>
      <title>Hostnamen</title>

      <indexterm><primary>hostname</primary></indexterm>
      <indexterm><primary>DNS</primary></indexterm>

      <sect3>
	<title><filename>/etc/resolv.conf</filename></title>

	<indexterm><primary><filename>resolv.conf</filename></primary></indexterm>

	<para>Wie der &os;-Resolver auf das Internet Domain Name
	  System (DNS) zugreift, wird in <filename>/etc/resolv.conf</filename>
	  festgelegt.</para>

	<para>Die gebr&auml;uchlichsten Eintr&auml;ge in
	  <filename>/etc/resolv.conf</filename> sind:</para>

	<informaltable frame="none" pgwide="1">
	  <tgroup cols="2">
	    <colspec colwidth="1*">
	    <colspec colwidth="2*">

	    <tbody>
	      <row>
		<entry><literal>nameserver</literal></entry>
		<entry>Die IP-Adresse eines Nameservers, den
		  der Resolver abfragen soll.  Bis zu drei Server werden
		  in der Reihenfolge, in der sie aufgez&auml;hlt
		  sind, abgefragt.</entry>
	      </row>
	      <row>
		<entry><literal>search</literal></entry>
		<entry>Suchliste mit Domain-Namen zum Aufl&ouml;sen von
		  Hostnamen.  Die Liste wird normalerweise durch den
		  Domain-Teil des lokalen Hostnamens festgelegt.</entry>
	      </row>
	      <row>
		<entry><literal>domain</literal></entry>
		<entry>Der lokale Domain-Name.</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

	<para>Beispiel f&uuml;r eine typische
	  <filename>resolv.conf</filename>:</para>

	<programlisting>search example.com
nameserver 147.11.1.11
nameserver 147.11.100.30</programlisting>

	<note><para>Nur eine der Anweisungen <literal>search</literal>
	  oder <literal>domain</literal> sollte benutzt werden.</para></note>

	<para>Wenn Sie DHCP benutzen, &uuml;berschreibt &man.dhclient.8;
	  f&uuml;r gew&ouml;hnlich <filename>resolv.conf</filename>
	  mit den Informationen vom DHCP-Server.</para>
      </sect3>

      <sect3>
	<title><filename>/etc/hosts</filename></title>

	<indexterm><primary>hosts</primary></indexterm>

	<para><filename>/etc/hosts</filename> ist eine einfache textbasierte
	  Datenbank, die aus alten Internetzeiten stammt.  Zusammen
	  mit DNS und NIS stellt sie eine Abbildung zwischen Namen und
	  IP-Adressen zur Verf&uuml;gung.  Anstatt &man.named.8;
	  zu konfigurieren, k&ouml;nnen hier lokale Rechner, die &uuml;ber
	  ein LAN verbunden sind, eingetragen werden.  Lokale Eintr&auml;ge
	  f&uuml;r gebr&auml;uchliche Internet-Adressen in
	  <filename>/etc/hosts</filename> verhindern die Abfrage eines
	  externen Servers und beschleunigen die Namensaufl&ouml;sung.</para>

	<programlisting># &dollar;FreeBSD&dollar;
#
#
# Host Database
#
# This file should contain the addresses and aliases for local hosts that
# share this file.  Replace 'my.domain' below with the domainname of your
# machine.
#
# In the presence of the domain name service or NIS, this file may
# not be consulted at all; see /etc/nsswitch.conf for the resolution order.
#
#
::1         localhost localhost.my.domain
127.0.0.1       localhost localhost.my.domain
#
# Imaginary network.
#10.0.0.2       myname.my.domain myname
#10.0.0.3       myfriend.my.domain myfriend
#
# According to RFC 1918, you can use the following IP networks for
# private nets which will never be connected to the Internet:
#
#   10.0.0.0    -   10.255.255.255
#   172.16.0.0  -   172.31.255.255
#   192.168.0.0 -   192.168.255.255
#
# In case you want to be able to connect to the Internet, you need
# real official assigned numbers.  Do not try to invent your own network
# numbers but instead get one from your network provider (if any) or
# from your regional registry (ARIN, APNIC, LACNIC, RIPE NCC, or AfriNIC.)
#</programlisting>

	<para><filename>/etc/hosts</filename> hat ein einfaches Format:</para>
	<programlisting>[Internet Adresse] [Offizieller Hostname] [Alias1] [Alias2] ...</programlisting>

	<para>Zum Beispiel:</para>

	<programlisting>10.0.0.1 myRealHostname.example.com myRealHostname foobar1 foobar2</programlisting>

	<para>Weitere Informationen entnehmen Sie bitte &man.hosts.5;.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Konfiguration von Logdateien</title>

      <indexterm><primary>Logdateien</primary></indexterm>

      <sect3>
	<title><filename>syslog.conf</filename></title>

	<indexterm><primary>syslog.conf</primary></indexterm>

	<para><filename>syslog.conf</filename> ist die Konfigurationsdatei
	  von &man.syslogd.8;.  Sie legt fest, welche
	  <application>syslog</application> Meldungen in welche
	  Logdateien geschrieben werden.</para>

	<programlisting># &dollar;FreeBSD&dollar;
#
#       Spaces ARE valid field separators in this file. However,
#       other *nix-like systems still insist on using tabs as field
#       separators. If you are sharing this file between systems, you
#       may want to use only tabs as field separators here.
#       Consult the syslog.conf(5) manpage.
*.err;kern.debug;auth.notice;mail.crit          /dev/console
*.notice;kern.debug;lpr.info;mail.crit;news.err /var/log/messages
security.*                                      /var/log/security
mail.info                                       /var/log/maillog
lpr.info                                        /var/log/lpd-errs
cron.*                                          /var/log/cron
*.err                                           root
*.notice;news.err                               root
*.alert                                         root
*.emerg                                         *
# uncomment this to log all writes to /dev/console to /var/log/console.log
#console.info                                   /var/log/console.log
# uncomment this to enable logging of all log messages to /var/log/all.log
#*.*                                            /var/log/all.log
# uncomment this to enable logging to a remote log host named loghost
#*.*                                            @loghost
# uncomment these if you're running inn
# news.crit                                     /var/log/news/news.crit
# news.err                                      /var/log/news/news.err
# news.notice                                   /var/log/news/news.notice
!startslip
*.*                                             /var/log/slip.log
!ppp
*.*                                             /var/log/ppp.log</programlisting>

	<para>Weitere Informationen enth&auml;lt &man.syslog.conf.5;.</para>
      </sect3>

      <sect3>
	<title><filename>newsyslog.conf</filename></title>

	<indexterm><primary>newsyslog.conf</primary></indexterm>

	<para>Die Konfigurationsdatei f&uuml;r &man.newsyslog.8;, das
	  normalerweise von &man.cron.8; aufgerufen wird, ist
	  <filename>newsyslog.conf</filename>.  &man.newsyslog.8;
	  stellt fest, ob Logdateien archiviert oder verschoben
	  werden m&uuml;ssen.  So wird <filename>logfile</filename>
	  nach <filename>logfile.0</filename> geschoben und
	  <filename>logfile.0</filename> nach <filename>logfile.1</filename>
	  usw.  Zudem k&ouml;nnen Logdateien mit &man.gzip.1;
	  komprimiert werden.  Die Namen der Logdateien sind dann
	  <filename>logfile.0.gz</filename>, <filename>logfile.1.gz</filename>
	  usw.</para>

	<para><filename>newsyslog.conf</filename> legt fest, welche
	  Logdateien wann bearbeitet und wie viele Dateien behalten werden.
	  Logdateien k&ouml;nnen auf Basis ihrer Gr&ouml;&szlig;e oder zu
	  einem gewissen Zeitpunkt archiviert bzw. umbenannt werden.</para>

	<programlisting># configuration file for newsyslog
# &dollar;FreeBSD&dollar;
#
# filename          [owner:group]    mode count size when [ZB] [/pid_file] [sig_num]
/var/log/cron                           600  3     100  *     Z
/var/log/amd.log                        644  7     100  *     Z
/var/log/kerberos.log                   644  7     100  *     Z
/var/log/lpd-errs                       644  7     100  *     Z
/var/log/maillog                        644  7     *    @T00  Z
/var/log/sendmail.st                    644  10    *    168   B
/var/log/messages                       644  5     100  *     Z
/var/log/all.log                        600  7     *    @T00  Z
/var/log/slip.log                       600  3     100  *     Z
/var/log/ppp.log                        600  3     100  *     Z
/var/log/security                       600  10    100  *     Z
/var/log/wtmp                           644  3     *    @01T05 B
/var/log/daily.log                      640  7     *    @T00  Z
/var/log/weekly.log                     640  5     1    $W6D0 Z
/var/log/monthly.log                    640  12    *    $M1D0 Z
/var/log/console.log                    640  5     100  *     Z</programlisting>

	<para>Um mehr zu erfahren, lesen Sie bitte &man.newsyslog.8;.</para>
      </sect3>
    </sect2>

    <sect2 id="configtuning-sysctlconf">
      <title><filename>sysctl.conf</filename></title>

      <indexterm><primary>sysctl.conf</primary></indexterm>
      <indexterm><primary>sysctl</primary></indexterm>

      <para><filename>sysctl.conf</filename> sieht &auml;hnlich
	wie <filename>rc.conf</filename> aus.  Werte werden in der
	Form <literal>Variable=Wert</literal> gesetzt.
	Die angegebenen Werte werden gesetzt, nachdem sich das
	System bereits im Mehrbenutzermodus befindet.  Allerdings
	lassen sich im Mehrbenutzermodus nicht alle Werte
	setzen.</para>

      <para>Um das Protokollieren von fatalen Signalen abzustellen
	und Benutzer daran zu hindern, von anderen Benutzern
	gestartete Prozesse zu sehen, k&ouml;nnen Sie in der
	Datei <filename>sysctl.conf</filename> die folgenden
	Variablen setzen:</para>

      <programlisting># Do not log fatal signal exits (e.g. sig 11)
kern.logsigexit=0

# Prevent users from seeing information about processes that
# are being run under another UID.
security.bsd.see_other_uids=0</programlisting>

    </sect2>
  </sect1>

  <sect1 id="configtuning-sysctl">
    <title>Einstellungen mit sysctl</title>

    <indexterm><primary>sysctl</primary></indexterm>
    <indexterm>
      <primary>Einstellungen</primary>
      <secondary>mit sysctl</secondary>
    </indexterm>

    <para>Mit &man.sysctl.8; k&ouml;nnen Sie &Auml;nderungen an
      einem laufenden &os;-System vornehmen.  Unter anderem
      k&ouml;nnen Optionen des TCP/IP-Stacks oder des
      virtuellen Speichermanagements ver&auml;ndert werden.  Unter
      der Hand eines erfahrenen Systemadministrators kann dies
      die Systemperformance erheblich verbessern.  &Uuml;ber 500
      Variablen k&ouml;nnen mit &man.sysctl.8; gelesen und gesetzt
      werden.</para>

    <para>Der Hauptzweck von &man.sysctl.8; besteht darin, Systemeinstellungen
      zu lesen und zu ver&auml;ndern.</para>

    <para>Alle auslesbaren Variablen werden wie folgt angezeigt:</para>

    <screen>&prompt.user; <userinput>sysctl -a</userinput></screen>

    <para>Sie k&ouml;nnen auch eine spezielle Variable, z.B.
      <varname>kern.maxproc</varname> lesen:</para>

    <screen>&prompt.user; <userinput>sysctl kern.maxproc</userinput>
kern.maxproc: 1044</screen>

    <para>Um eine Variable zu setzen, benutzen Sie die Syntax
      <replaceable>Variable</replaceable>=
      <replaceable>Wert</replaceable>:</para>

    <screen>&prompt.root; <userinput>sysctl kern.maxfiles=5000</userinput>
kern.maxfiles: 2088 -&gt; 5000</screen>

    <para>Mit sysctl k&ouml;nnen Sie Strings, Zahlen oder
      Boolean-Werte setzen.  Bei Boolean-Werten setzen sie <literal>1</literal>
      f&uuml;r wahr und <literal>0</literal> f&uuml;r falsch.</para>

    <para>Wenn Sie Variablen automatisch w&auml;hrend des Systemstarts
      setzen wollen, f&uuml;gen Sie die Variablen in die Datei
      <filename>/etc/sysctl.conf</filename> ein.  Weiteres
      entnehmen Sie bitte der Hilfeseite &man.sysctl.conf.5;
      und dem <xref linkend="configtuning-sysctlconf">.</para>

    <sect2 id="sysctl-readonly">
      <sect2info>
        <authorgroup>
          <author>
	    <firstname>Tom</firstname>
	    <surname>Rhodes</surname>
	    <contrib>Contributed by </contrib>
          </author>
        </authorgroup>
      </sect2info>
      <title>Schreibgesch&uuml;tzte Variablen</title>

      <para>Schreibgesch&uuml;tzte sysctl-Variablen k&ouml;nnen nur
        w&auml;hrend des Systemstarts ver&auml;ndert werden.</para>

      <para>Beispielsweise hat &man.cardbus.4; auf einigen Laptops
	Schwierigkeiten, Speicherbereiche zu erkennen.  Es treten
	dann Fehlermeldungen wie die folgende auf:</para>

      <screen>cbb0: Could not map register memory
device_probe_and_attach: cbb0 attach returned 12</screen>

      <para>Um dieses Problem zu l&ouml;sen, muss eine
        schreibgesch&uuml;tzte sysctl-Variable ver&auml;ndert
	werden.  Eine <acronym>OID</acronym> kann in der Datei
	<filename>/boot/loader.conf</filename> &uuml;berschrieben
	werden.  Die Datei <filename>/boot/defaults/loader.conf</filename>
	enth&auml;lt Vorgabewwerte f&uuml;r sysctl-Variablen.</para>

      <para>Das oben erw&auml;hnte Problem wird durch die Angabe von
	<option>hw.pci.allow_unsupported_io_range=1</option> in
	<filename>/boot/loader.conf</filename> gel&ouml;st.
	Danach sollte &man.cardbus.4; fehlerfrei funktionieren.</para>
    </sect2>
  </sect1>

  <sect1 id="configtuning-disk">
    <title>Tuning von Laufwerken</title>

    <sect2>
      <title>Sysctl Variablen</title>

      <sect3>
	<title><varname>vfs.vmiodirenable</varname></title>

	<indexterm>
	  <primary><varname>vfs.vmiodirenable</varname></primary>
	</indexterm>

	<para>Die Variable <varname>vfs.vmiodirenable</varname> besitzt
	  in der Voreinstellung den Wert 1.  Die Variable kann auf den Wert
	  0 (ausgeschaltet) oder 1 (angeschaltet) gesetzt werden.  Sie
	  steuert, wie Verzeichnisse vom System zwischengespeichert
	  werden.  Die meisten Verzeichnisse sind klein und benutzen
	  nur ein einzelnes Fragment, typischerweise 1&nbsp;kB,
	  im Dateisystem.  Im Buffer-Cache verbrauchen sie mit
	  512&nbsp;Bytes noch weniger Platz.  Ist die Variable
	  ausgeschaltet (auf 0) wird der Buffer-Cache nur
	  eine limitierte Anzahl Verzeichnisse zwischenspeichern, auch
	  wenn das System &uuml;ber sehr viel Speicher verf&uuml;gt.
	  Ist die Variable aktiviert (auf 1), kann der Buffer-Cache den
	  VM-Page-Cache benutzen, um Verzeichnisse zwischenzuspeichern.
	  Der ganze Speicher steht damit zum Zwischenspeichern von
	  Verzeichnissen zur Verf&uuml;gung.  Der Nachteil bei dieser
	  Vorgehensweise ist, dass zum Zwischenspeichern eines
	  Verzeichnisses mindestens eine physikalische Seite im
	  Speicher, die normalerweise 4&nbsp;kB gro&szlig; ist,
	  anstelle von 512&nbsp;Bytes gebraucht wird.  Wir empfehlen,
	  diese Option aktiviert zu lassen, wenn Sie Dienste zur
	  Verf&uuml;gung stellen, die viele Dateien manipulieren.
	  Beispiele f&uuml;r solche Dienste sind Web-Caches,
	  gro&szlig;e Mail-Systeme oder Netnews.  Die aktivierte
	  Variable vermindert, trotz des verschwendeten Speichers,
	  in aller Regel nicht die Leistung des Systems, obwohl Sie
	  das nachpr&uuml;fen sollten.</para>
      </sect3>

      <sect3>
	<title><varname>vfs.write_behind</varname></title>

	<indexterm>
	  <primary><varname>vfs.write_behind</varname></primary>
	</indexterm>

	<para>In der Voreinstellung besitzt die Variable
	  <varname>vfs.write_behind</varname> den Wert
	  <literal>1</literal> (aktiviert).  Mit dieser Einstellung
	  schreibt das Dateisystem anfallende vollst&auml;ndige Cluster,
	  die besonders beim sequentiellen Schreiben gro&szlig;er Dateien
	  auftreten, direkt auf das Medium aus.  Dies verhindert,
	  dass sich im Buffer-Cache ver&auml;nderte Puffer
	  (<foreignphrase>dirty buffers</foreignphrase>) ansammeln,
	  die die I/O-Verarbeitung nicht mehr beschleunigen
	  w&uuml;rden.  Unter bestimmten Umst&auml;nden blockiert
	  diese Funktion allerdings Prozesse.  Setzen Sie in diesem
	  Fall die Variable <varname>vfs.write_behind</varname> auf
	  den Wert <literal>0</literal>.</para>
      </sect3>

      <sect3>
	<title><varname>vfs.hirunningspace</varname></title>

	<indexterm>
	  <primary><varname>vfs.hirunningspace</varname></primary>
	</indexterm>

	<para>Die Variable <varname>vfs.hirunningspace</varname>
	  bestimmt systemweit die Menge ausstehender Schreiboperationen,
	  die dem Platten-Controller zu jedem beliebigen Zeitpunkt
	  &uuml;bergeben werden k&ouml;nnen.  Normalerweise k&ouml;nnen
	  Sie den Vorgabewert verwenden.  Auf Systemen mit
	  vielen Platten kann der Wert aber auf 4 bis
	  5&nbsp;<emphasis>Megabyte</emphasis> erh&ouml;ht werden.
	  Beachten Sie, dass ein zu hoher Wert (gr&ouml;&szlig;er
	  als der Schreib-Schwellwert des Buffer-Caches) zu
	  Leistungverlusten f&uuml;hren kann.  Setzen Sie den Wert daher
	  nicht zu hoch!  Hohe Werte k&ouml;nnen auch Leseoperationen
	  verz&ouml;gern, die gleichzeitig mit Schreiboperationen
	  ausgef&uuml;hrt werden.</para>

	<para>Es gibt weitere Variablen, mit denen Sie den Buffer-Cache
	  und den VM-Page-Cache beeinflussen k&ouml;nnen.  Wir raten
	  Ihnen allerdings davon ab, diese Variablen zu ver&auml;ndern,
	  da das VM-System den virtuellen Speicher selbst sehr gut
	  verwaltet.</para>
      </sect3>

      <sect3>
	<title><varname>vm.swap_idle_enabled</varname></title>

	<indexterm>
	  <primary><varname>vm.swap_idle_enabled</varname></primary>
	</indexterm>

	<para>Die Variable <varname>vm.swap_idle_enabled</varname>
	  ist f&uuml;r gro&szlig;e Mehrbenutzer-Systeme gedacht, auf
	  denen sich viele Benutzer an- und abmelden und auf denen
	  es viele Prozesse im Leerlauf
	  (<foreignphrase>idle</foreignphrase>) gibt.  Solche Systeme
	  fragen kontinuierlich freien Speicher an.  Wenn Sie die
	  Variable <varname>vm.swap_idle_enabled</varname> aktivieren,
	  k&ouml;nnen Sie die Auslagerungs-Hysterese von Seiten mit
	  den Variablen <varname>vm.swap_idle_threshold1</varname> und
	  <varname>vm.swap_idle_threshold2</varname> einstellen.  Die
	  Schwellwerte beider Variablen geben die Zeit in Sekunden an,
	  in denen sich ein Prozess im Leerlauf befinden muss.  Wenn die
	  Werte so eingestellt sind, dass Seiten fr&uuml;her als nach dem
	  normalen Algorithmus ausgelagert werden, verschafft das dem
	  Auslagerungs-Prozess mehr Luft.  Aktivieren Sie diese Funktion
	  nur, wenn Sie sie wirklich ben&ouml;tigen:  Die Speicherseiten
	  werden eher fr&uuml;her als sp&auml;ter ausgelagert.  Der
	  Platz im Swap-Bereich wird dadurch schneller verbraucht und
	  die Plattenaktivit&auml;ten steigen an.  Auf kleine Systeme
	  hat diese Funktion sp&uuml;rbare Auswirkungen.  Auf gro&szlig;en
	  Systemen, die sowieso schon Seiten auslagern m&uuml;ssen,
	  k&ouml;nnen ganze Prozesse leichter in den Speicher geladen
	  oder ausgelagert werden.</para>
      </sect3>

      <sect3>
	<title><varname>hw.ata.wc</varname></title>

	<indexterm>
	  <primary><varname>hw.ata.wc</varname></primary>
	</indexterm>

	<para>In &os;&nbsp;4.3 wurde versucht, den IDE-Schreib-Zwischenspeicher
	  abzustellen.  Obwohl dies die Bandbreite zum Schreiben auf
	  IDE-Platten verringerte, wurde es aus Gr&uuml;nden der
	  Datenkonsistenz als notwenig angesehen.  Der Kern des
	  Problems ist, dass IDE-Platten keine zuverl&auml;ssige
	  Aussage &uuml;ber das Ende eines Schreibvorgangs treffen.
	  Wenn der Schreib-Zwischenspeicher aktiviert ist, werden die Daten
	  nicht in der Reihenfolge ihres Eintreffens geschrieben.  Es kann
	  sogar passieren, dass das Schreiben mancher Bl&ouml;cke
	  im Fall von starker Plattenaktivit&auml;t auf unbefristete
	  Zeit verz&ouml;gert wird.  Ein Absturz oder Stromausfall
	  zu dieser Zeit kann die Dateisysteme erheblich besch&auml;digen.
	  Wir entschieden uns daher f&uuml;r die sichere Variante
	  und stellten den Schreib-Zwischenspeicher ab.  Leider war
	  damit auch ein gro&szlig;er Leistungsverlust verbunden, so
	  dass wir die Variable
	  nach dem Release wieder aktiviert haben.  Sie sollten den
	  Wert der Variable <varname>hw.ata.wc</varname> auf Ihrem
	  System &uuml;berpr&uuml;fen.  Wenn der Schreib-Zwischenspeicher
	  abgestellt ist, k&ouml;nnen Sie ihn aktivieren, indem Sie die
	  Variable auf den Wert 1 setzen.  Dies muss zum Zeitpunkt
	  des Systemstarts im Boot-Loader geschehen.  Eine &Auml;nderung
	  der Variable, nachdem der Kernel gestartet ist, hat keine
	  Auswirkungen.</para>

	<para>Weitere Informationen finden Sie in &man.ata.4;.</para>
      </sect3>

      <sect3>
	<title><literal>SCSI_DELAY</literal>
	  (<varname>kern.cam.scsi_delay</varname>)</title>

	<indexterm>
	  <primary><varname>kern.cam.scsi_delay</varname></primary>
	</indexterm>

	<indexterm>
	  <primary>Kerneloptionen</primary>
	  <secondary><literal>SCSI_DELAY</literal></secondary>
	</indexterm>

	<para>Mit der Kerneloption <literal>SCSI_DELAY</literal> kann
	  die Dauer des Systemstarts verringert werden.  Der Vorgabewert
	  ist recht hoch und er verz&ouml;gert den Systemstart um 15 oder
	  mehr Sekunden.  Normalerweise kann dieser Wert, insbesondere
	  mit modernen Laufwerken, auf 5&nbsp;Sekunden heruntergesetzt
	  werden.  Ab &os;&nbsp;5.0 wird dazu die
	  <command>sysctl</command>-Variable
	  <varname>kern.cam.scsi_delay</varname> benutzt.  Die Variable
	  sowie die Kerneloption verwenden f&uuml;r die Zeitangabe
	  Millisekunden und <emphasis>nicht</emphasis> Sekunden.</para>
      </sect3>
    </sect2>

    <sect2 id="soft-updates">
      <title>Soft Updates</title>

      <indexterm><primary>Soft Updates</primary></indexterm>
      <indexterm><primary>tunefs</primary></indexterm>

      <para>Mit &man.tunefs.8; lassen sich Feineinstellungen an
	Dateisystemen vornehmen.  Das Programm hat verschiedene Optionen,
	von denen hier nur Soft Updates betrachtet werden.  Soft Updates
	werden wie folgt ein- und ausgeschaltet:</para>

      <screen>&prompt.root; <userinput>tunefs -n enable /filesystem</userinput>
&prompt.root; <userinput>tunefs -n disable /filesystem</userinput></screen>

      <para>Ein eingeh&auml;ngtes Dateisystem kann nicht mit &man.tunefs.8;
	modifiziert werden.  Soft Updates werden am besten im Single-User
	Modus aktiviert, bevor Partitionen eingehangen sind.</para>

      <para>Durch Einsatz eines Zwischenspeichers wird die Performance
	im Bereich der Metadaten, vorwiegend beim Anlegen und L&ouml;schen
	von Dateien, gesteigert.  Wir empfehlen, Soft Updates auf allen
	Dateisystemen zu aktivieren.  Allerdings sollten Sie sich &uuml;ber
	die zwei Nachteile von Soft Updates bewusst sein:
	Erstens garantieren Soft Updates zwar die Konsistenz der Daten
	im Fall eines Absturzes, aber es kann leicht passieren, dass
	das Dateisystem &uuml;ber mehrere Sekunden oder gar eine Minute
	nicht synchronisiert wurde.  Im Fall eines Absturzes verlieren
	Sie mit Soft Updates unter Umst&auml;nden mehr Daten als ohne.
	Zweitens verz&ouml;gern Soft Updates die Freigabe von
	Datenbl&ouml;cken.  Eine gr&ouml;&szlig;ere Aktualisierung
	eines fast vollen Dateisystems, wie dem Root-Dateisystem,
	z.B. w&auml;hrend eines <command>make installworld</command>,
	kann das Dateisystem vollaufen lassen.  Dadurch w&uuml;rde
	die Aktualisierung fehlschlagen.</para>

      <sect3>
	<title>Details &uuml;ber Soft Updates</title>

	<indexterm>
	  <primary>Soft Updates</primary>
	  <secondary>Details</secondary>
	</indexterm>

	<para>Es gibt zwei klassische Herangehensweisen, wie
	  man die Metadaten des Dateisystems (also Daten
	  &uuml;ber Dateien, wie inode Bereiche oder Verzeichniseintr&auml;ge)
	  aktualisiert auf die Platte zur&uuml;ckschreibt:</para>

	<para>Das historisch &uuml;bliche Verfahren waren synchrone
	  Updates der Metadaten, d. h. wenn eine &Auml;nderung an
	  einem Verzeichnis n&ouml;tig war, wurde anschlie&szlig;end
	  gewartet, bis diese &Auml;nderung tats&auml;chlich auf die
	  Platte zur&uuml;ckgeschrieben worden war.  Der
	  <emphasis>Inhalt</emphasis> der Dateien wurde im
	  <quote>Buffer Cache</quote> zwischengespeichert und
	  asynchron irgendwann sp&auml;ter auf die Platte geschrieben.
	  Der Vorteil dieser Implementierung ist, dass sie
	  sicher funktioniert.  Wenn w&auml;hrend eines Updates ein
	  Ausfall erfolgt, haben die Metadaten immer einen
	  konsistenten Zustand.  Eine Datei ist entweder komplett
	  angelegt oder gar nicht.  Wenn die Datenbl&ouml;cke einer
	  Datei im Fall eines Absturzes noch nicht den Weg aus dem
	  <quote>Buffer Cache</quote> auf die Platte gefunden haben,
	  kann &man.fsck.8; das Dateisystem reparieren, indem es die
	  Dateil&auml;nge einfach auf 0 setzt.  Au&szlig;erdem
	  ist die Implementierung einfach und &uuml;berschaubar.  Der
	  Nachteil ist, dass &Auml;nderungen der Metadaten sehr
	  langsam vor sich gehen.  Ein <command>rm -r</command>
	  beispielsweise fasst alle Dateien eines Verzeichnisses
	  der Reihe nach an, aber jede dieser &Auml;nderungen am
	  Verzeichnis (L&ouml;schen einer Datei) wird einzeln synchron
	  auf die Platte geschrieben.  Gleiches beim Auspacken
	  gro&szlig;er Hierarchien (<command>tar -x</command>).</para>

	<para>Der zweite Fall sind asynchrone Metadaten-Updates.  Das
	  ist z. B. der Standard bei Linux/ext2fs oder die Variante
	  <command>mount -o async</command> f&uuml;r *BSD UFS.  Man
	  schickt die Updates der Metadaten einfach auch noch
	  &uuml;ber den <quote>Buffer Cache</quote>, sie werden also
	  zwischen die Updates der normalen Daten eingeschoben.
	  Vorteil ist, dass man nun nicht mehr auf jeden Update
	  warten muss, Operationen, die zahlreiche Metadaten
	  &auml;ndern, werden also viel schneller.  Auch
	  hier ist die Implementierung sehr einfach und wenig
	  anf&auml;llig f&uuml;r Fehler.  Nachteil ist, dass
	  keinerlei Konsistenz des Dateisystems mehr gesichert ist.
	  Wenn mitten in einer Operation, die viele Metadaten
	  &auml;ndert, ein Ausfall erfolgt (Stromausfall, dr&uuml;cken
	  des Reset-Tasters), dann ist das Dateisystem
	  anschlie&szlig;end in einem unbestimmten Zustand.  Niemand
	  kann genau sagen, was noch geschrieben worden ist und was
	  nicht mehr; die Datenbl&ouml;cke einer Datei k&ouml;nnen
	  schon auf der Platte stehen, w&auml;hrend die inode Tabelle
	  oder das zugeh&ouml;rige Verzeichnis nicht mehr aktualisiert
	  worden ist.  Man kann praktisch kein <command>fsck</command>
	  mehr implementieren, das diesen Zustand
	  wieder reparieren kann, da die dazu n&ouml;tigen
	  Informationen einfach auf der Platte fehlen.  Wenn ein
	  Dateisystem derart besch&auml;digt worden ist, kann man es
	  nur neu erzeugen (&man.newfs.8;) und die Daten
	  vom Backup zur&uuml;ckspielen.
	  </para>

	<para>Der historische Ausweg aus diesem Dilemma war ein
	  <emphasis>dirty region logging</emphasis> (auch als
	  <emphasis>Journalling</emphasis> bezeichnet, wenngleich
	  dieser Begriff nicht immer gleich benutzt und manchmal auch
	  f&uuml;r andere Formen von Transaktionsprotokollen gebraucht
	  wird).  Man schreibt die Metadaten-Updates zwar synchron,
	  aber nur in einen kleinen Plattenbereich, die
	  <emphasis>logging area</emphasis>.  Von da aus werden sie
	  dann asynchron auf ihre eigentlichen Bereiche verteilt.  Da
	  die <emphasis>logging area</emphasis> ein kleines
	  zusammenh&auml;ngendes St&uuml;ckchen ist, haben die
	  Schreibk&ouml;pfe der Platte bei massiven Operationen auf
	  Metadaten keine allzu gro&szlig;en Wege zur&uuml;ckzulegen,
	  so dass alles ein ganzes St&uuml;ck schneller geht als
	  bei klassischen synchronen Updates.  Die Komplexit&auml;t
	  der Implementierung h&auml;lt sich ebenfalls in Grenzen,
	  somit auch die Anf&auml;lligkeit f&uuml;r Fehler.  Als
	  Nachteil ergibt sich, dass Metadaten zweimal auf die
	  Platte geschrieben werden m&uuml;ssen (einmal in die
	  <emphasis>logging area</emphasis>, einmal an die richtige
	  Stelle), so dass das im Falle regul&auml;rer
	  Arbeit (also keine geh&auml;uften Metadatenoperationen) eine
	  <quote>Pessimisierung</quote> des Falls der synchronen
	  Updates eintritt, es wird alles langsamer.  Daf&uuml;r hat man
	  als Vorteil, dass im Falle eines Crashes der
	  konsistente Zustand dadurch erzielbar ist, dass die
	  angefangenen Operationen aus dem <emphasis>dirty region
	  log</emphasis> entweder zu Ende ausgef&uuml;hrt oder
	  komplett verworfen werden, wodurch das Dateisystem schnell
	  wieder zur Verf&uuml;gung steht.</para>

	<para>Die L&ouml;sung von Kirk McKusick, dem Sch&ouml;pfer von
	  Berkeley FFS, waren <emphasis>Soft Updates</emphasis>: die
	  notwendigen Updates der Metadaten werden im Speicher
	  gehalten und dann sortiert auf die Platte geschrieben
	  (<quote>ordered metadata updates</quote>).  Dadurch hat man
	  den Effekt, dass im Falle massiver
	  Metadaten-&Auml;nderungen sp&auml;tere Operationen die
	  vorhergehenden, noch nicht auf die Platte geschriebenen
	  Updates desselben Elements im Speicher
	  <quote>einholen</quote>.  Alle Operationen, auf ein
	  Verzeichnis beispielsweise, werden also in der Regel noch im
	  Speicher abgewickelt, bevor der Update &uuml;berhaupt auf
	  die Platte geschrieben wird (die dazugeh&ouml;rigen
	  Datenbl&ouml;cke werden nat&uuml;rlich auch so sortiert,
	  dass sie nicht vor ihren Metadaten auf der Platte
	  sind).  Im Fall eines Absturzes hat man ein implizites <quote>log
	    rewind</quote>: alle Operationen, die noch nicht den Weg auf
	  die Platte gefunden haben, sehen danach so aus, als
	  h&auml;tten sie nie stattgefunden.  Man hat so also den
	  konsistenten Zustand von ca. 30 bis 60&nbsp;Sekunden fr&uuml;her
	  sichergestellt.  Der verwendete Algorithmus garantiert
	  dabei, dass alle tats&auml;chlich benutzten Ressourcen
	  auch in den entsprechenden Bitmaps (Block- und inode
	  Tabellen) als belegt markiert sind.  Der einzige Fehler, der
	  auftreten kann, ist, dass Ressourcen noch als
	  <quote>belegt</quote> markiert sind, die tats&auml;chlich
	  <quote>frei</quote> sind.  &man.fsck.8; erkennt dies und
	  korrigiert diese nicht mehr belegten Ressourcen.  Die
	  Notwendigkeit eines Dateisystem-Checks darf aus diesem
	  Grunde auch ignoriert und das Dateisystem mittels
	  <command>mount -f</command> zwangsweise eingebunden werden.
	  Um noch allozierte Ressourcen freizugeben muss
	  sp&auml;ter ein &man.fsck.8; nachgeholt werden.  Das ist
	  dann auch die Idee des <emphasis>background fsck</emphasis>:
	  beim Starten des Systems wird lediglich ein
	  <emphasis>Schnappschuss</emphasis> des Filesystems
	  gemacht, mit dem &man.fsck.8; dann sp&auml;ter arbeiten
	  kann.  Alle Dateisysteme d&uuml;rfen <quote>unsauber</quote>
	  eingebunden werden und das System kann sofort in den
	  Multiuser-Modus gehen.  Danach wird ein
	  Hintergrund-<command>fsck</command> f&uuml;r die
	  Dateisysteme gestartet, die dies ben&ouml;tigen, um
	  m&ouml;glicherweise irrt&uuml;mlich belegte Ressourcen
	  freizugeben.  (Dateisysteme ohne <emphasis>Soft
	  Updates</emphasis> ben&ouml;tigen nat&uuml;rlich immer noch
	  den &uuml;blichen (Vordergrund-)<command>fsck</command>,
	  bevor sie eingebunden werden k&ouml;nnen.)</para>

	<para>Der Vorteil ist, dass die Metadaten-Operationen
	  beinahe so schnell ablaufen wie im asynchronen Fall (also
	  durchaus auch schneller als beim <quote>logging</quote>, das
	  ja die Metadaten immer zweimal schreiben muss).  Als
	  Nachteil stehen dem die Komplexit&auml;t des Codes (mit
	  einer erh&ouml;hten Fehlerwahrscheinlichkeit in einem
	  bez&uuml;glich Datenverlust hoch sensiblen Bereich) und ein
	  erh&ouml;hter Speicherverbrauch entgegen.  Au&szlig;erdem
	  muss man sich an einige Eigenheiten
	  gew&ouml;hnen: Nach einem Absturz ist ein etwas &auml;lterer
	  Stand auf der Platte &ndash; statt einer leeren, aber bereits
	  angelegten Datei (wie nach einem herk&ouml;mmlichen
	  <command>fsck</command> Lauf) ist auf einem Dateisystem mit
	  <emphasis>Soft Updates</emphasis> keine Spur der
	  entsprechenden Datei mehr zu sehen, da weder die Metadaten
	  noch der Dateiinhalt je auf die Platte geschrieben wurden.
	  Weiterhin kann der Platz nach einem <command>rm -r</command>
	  nicht sofort wieder als verf&uuml;gbar markiert werden,
	  sondern erst dann, wenn der Update auch auf die Platte
	  vermittelt worden ist.  Dies kann besonders dann Probleme
	  bereiten, wenn gro&szlig;e Datenmengen in einem Dateisystem
	  ersetzt werden, das nicht gen&uuml;gend Platz hat, um alle
	  Dateien zweimal unterzubringen.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="configtuning-kernel-limits">
    <title>Einstellungen von Kernel Limits</title>

    <indexterm>
      <primary>Einstellungen</primary>
      <secondary>von Kernel Limits</secondary>
    </indexterm>

    <sect2 id="file-process-limits">
      <title>Datei und Proze&szlig; Limits</title>

      <sect3 id="kern-maxfiles">
	<title><varname>kern.maxfiles</varname></title>

	<indexterm>
	  <primary><varname>kern.maxfiles</varname></primary>
	</indexterm>

	<para>Abh&auml;ngig von den Anforderungen Ihres Systems
	  kann <varname>kern.maxfiles</varname> erh&ouml;ht oder
	  erniedrigt werden.  Die Variable legt die maximale
	  Anzahl von Dateideskriptoren auf Ihrem System fest.  Wenn
	  die Dateideskriptoren aufgebraucht sind, werden Sie
	  die Meldung <errorname>file: table is full</errorname>
	  wiederholt im Puffer f&uuml;r Systemmeldungen sehen.  Den
	  Inhalt des Puffers k&ouml;nnen Sie sich mit <command>dmesg</command>
	  anzeigen lassen.</para>

	<para>Jede offene Datei, jedes Socket und jede FIFO verbraucht
	  einen Dateideskriptor.  Auf <quote>dicken</quote> Produktionsservern
	  k&ouml;nnen leicht Tausende Dateideskriptoren ben&ouml;tigt
	  werden, abh&auml;ngig von der Art und Anzahl der gleichzeitig
	  laufenden Dienste.</para>

	<para>In &auml;lteren &os;-Versionen wurde die Voreinstellung
	  von <varname>kern.maxfile</varname> aus der
	  Kernelkonfigurationsoption <literal>maxusers</literal>
	  bestimmt.  <varname>kern.maxfiles</varname> w&auml;chst
	  proportional mit dem Wert von <literal>maxusers</literal>.
	  Wenn Sie einen angepassten Kernel kompilieren, empfiehlt es sich
	  diese Option entsprechend der maximalen Benutzerzahl Ihres
	  Systems einzustellen.  Obwohl auf einer Produktionsmaschine
	  vielleicht nicht 256 Benutzer gleichzeitig angemeldet sind,
	  k&ouml;nnen die ben&ouml;tigten Ressourcen &auml;hnlich denen
	  eines gro&szlig;en Webservers sein.</para>

	<para>Die Variable <varname>kern.maxusers</varname> wird beim
	  Systemstart automatisch aus dem zur Verf&uuml;gung stehenden
	  Hauptspeicher bestimmt.  Im laufenden Betrieb kann dieser Wert
	  aus der (nur lesbaren) sysctl-Variable
	  <varname>kern.maxusers</varname> ermittelt werden.  Falls ein
	  System f&uuml;r diese Variable einen anderen Wert ben&ouml;tigt,
	  kann der Wert &uuml;ber den Loader angepasst werden.
	  H&auml;ufig verwendete Werte sind dabei 64, 128, sowie 256.
	  Es ist empfehlenswert, die Anzahl der Dateideskriptoren nicht
	  auf einen Wert gr&ouml;&szlig;er 256 zu setzen, es sei denn,
	  Sie ben&ouml;tigen wirklich eine riesige Anzahl von ihnen.
	  Viele der von <varname>kern.maxusers</varname> auf einen
	  Standardwert gesetzten Parameter k&ouml;nnen beim Systemstart
	  oder im laufenden Betrieb in der Datei
	  <filename>/boot/loader.conf</filename> (sehen Sie sich dazu
	  auch &man.loader.conf.5; sowie die Datei
	  <filename>/boot/defaults/loader.conf</filename> an) an Ihre
	  Bed&uuml;rfnisse angepasst werden, so wie es bereits an anderer
	  Stelle dieses Dokuments beschrieben ist.</para>

	<para>&Auml;ltere &os;-Versionen setzen diesen Wert selbst,
	  wenn Sie in der Konfigurationsdatei den Wert <literal>0</literal>
	  <footnote><para>Der verwendete Algorithmus setzt
	    <literal>maxusers</literal> auf die Speichergr&ouml;&szlig;e
	    des Systems.  Der minimale Wert betr&auml;gt dabei
	    <literal>32</literal>, das Maximum ist
	    <literal>384</literal>.</para></footnote>
	  angeben.  Wenn Sie den Wert selbst bestimmen wollen,
	  sollten Sie <literal>maxusers</literal> mindestens auf
	  <literal>4</literal> setzen.  Dies gilt insbesondere dann,
	  wenn Sie beabsichtigen, das X&nbsp;Window-System zu benutzen
	  oder Software zu kompilieren.  Der Grund daf&uuml;r ist, dass
	  der wichtigste Wert, der durch <literal>maxusers</literal>
	  bestimmt wird, die maximale Anzahl an Prozessen ist, die auf
	  <literal>20 + 16 * maxusers</literal> gesetzt wird.  Wenn Sie
	  also <literal>maxusers</literal> auf 1 setzen, k&ouml;nnen
	  gleichzeitig nur 36 Prozesse laufen, von denen ungef&auml;hr
	  18 schon beim Booten des Systems gestartet werden.  Dazu
	  kommen nochmals etwa 15 Prozesse beim Start des
	  X&nbsp;Window-Systems.  Selbst eine einfache Aufgabe wie das
	  Lesen einer Manualpage ben&ouml;tigt neun Prozesse zum Filtern,
	  Dekomprimieren und Betrachten der Datei.  F&uuml;r die meisten
	  Benutzer sollte es ausreichen, <literal>maxusers</literal> auf
	  64 zu setzen, womit 1044 gleichzeitige Prozesse zur
	  Verf&uuml;gung stehen.  Wenn Sie allerdings den
	  gef&uuml;rchteten Fehler <errortype>proc table full</errortype>
	  beim Start eines Programms oder auf einem Server mit einer
	  gro&szlig;en Benutzerzahl (wie
	  <hostid role="fqdn">ftp.FreeBSD.org</hostid>) sehen, dann
	  sollten Sie den Wert nochmals erh&ouml;hen und den Kernel
	  neu bauen.</para>

	<note><para>Die Anzahl der Benutzer, die sich auf einem Rechner
	  anmelden kann, wird durch <literal>maxusers</literal>
	  <emphasis>nicht</emphasis> begrenzt.  Der Wert dieser
	  Variablen legt neben der m&ouml;glichen Anzahl der Prozesse
	  eines Benutzers weitere sinnvolle Gr&ouml;&szlig;en f&uuml;r
	  bestimmte Systemtabellen fest.</para>
	</note>
      </sect3>

      <sect3>
	<title><varname>kern.ipc.somaxconn</varname></title>

	<indexterm>
	  <primary><varname>kern.ipc.somaxconn</varname></primary>
	</indexterm>

	<para>Die Variable <varname>kern.ipc.somaxconn</varname>
	  beschr&auml;nkt die Gr&ouml;&szlig;e der Warteschlange
	  (<foreignphrase>Listen-Queue</foreignphrase>) f&uuml;r
	  neue TCP-Verbindungen.  Der Vorgabewert von
	  <literal>128</literal> ist normalerweise zu klein, um neue
	  Verbindungen auf einem stark ausgelasteten Webserver
	  zuverl&auml;ssig zu handhaben.  Auf solchen Servern sollte
	  der Wert auf <literal>1024</literal> oder h&ouml;her gesetzt
	  werden.  Ein Dienst (z.B. &man.sendmail.8;, oder
	  <application>Apache</application>) kann die Gr&ouml;&szlig;e
	  der Queue selbst einschr&auml;nken.  Oft gibt es die
	  M&ouml;glichkeit, die Gr&ouml;&szlig;e der Listen-Queue in
	  einer Konfigurationsdatei einzustellen.  Eine gro&szlig;e
	  Listen-Queue &uuml;bersteht vielleicht auch einen
	  Denial of Service Angriff (<abbrev>DoS</abbrev>).</para>
      </sect3>
    </sect2>
    <sect2 id="nmbclusters">
      <title>Netzwerk Limits</title>

      <para>Die Kerneloption <literal>NMBCLUSTERS</literal> schreibt
	die Anzahl der Netzwerkpuffer (Mbufs) fest, die das System besitzt.
	Eine zu geringe Anzahl Mbufs auf einem Server mit viel Netzwerkverkehr
	verringert die Leistung von &os;.  Jeder Mbuf-Cluster nimmt
	ungef&auml;hr 2&nbsp;kB Speicher in Anspruch, so dass ein Wert
	von 1024 insgesamt 2&nbsp;Megabyte Speicher f&uuml;r Netzwerkpuffer
	im System reserviert.  Wie viele Cluster ben&ouml;tigt werden,
	l&auml;sst sich durch eine einfache Berechnung herausfinden.
	Wenn Sie einen Webserver besitzen, der maximal 1000 gleichzeitige
	Verbindungen servieren soll und jede der Verbindungen je einen
	16&nbsp;kB gro&szlig;en Puffer zum Senden und Empfangen braucht,
	brauchen Sie ungef&auml;hr 32&nbsp;MB Speicher f&uuml;r
	Netzwerkpuffer.  Als Daumenregel verdoppeln Sie diese Zahl,
	so dass sich f&uuml;r <varname>NMBCLUSTERS</varname> der Wert
	2x32&nbsp;MB&nbsp;/&nbsp;2&nbsp;kB&nbsp;= 32768 ergibt.
	F&uuml;r Maschinen mit viel Speicher sollten Werte zwischen
	4096 und 32768 genommen werden.  Sie k&ouml;nnen diesen Wert
	nicht willk&uuml;rlich erh&ouml;hen, da dies bereits zu einem
	Absturz beim Systemstart f&uuml;hren kann.  Mit der Option
	<option>-m</option> von &man.netstat.1; k&ouml;nnen Sie den
	Gebrauch der Netzwerkpuffer kontrollieren.</para>

      <para>Die Netzwerkpuffer k&ouml;nnen beim Systemstart mit der
	Loader-Variablen <varname>kern.ipc.nmbclusters</varname>
	eingestellt werden.  Nur auf &auml;lteren &os;-Systemen
	m&uuml;ssen Sie die Kerneloption <literal>NMBCLUSTERS</literal>
	verwenden.</para>

      <para>Die Anzahl der &man.sendfile.2; Puffer muss auf ausgelasteten
	Servern, die den Systemaufruf &man.sendfile.2; oft verwenden,
	vielleicht erh&ouml;ht werden.  Dazu k&ouml;nnen Sie die
	Kerneloption <literal>NSFBUFS</literal> verwenden oder die
	Anzahl der Puffer in <filename>/boot/loader.conf</filename>
	(siehe &man.loader.8;) setzen.  Die Puffer sollten erh&ouml;ht
	werden, wenn Sie Prozesse im Zustand <literal>sfbufa</literal>
	sehen.  Die schreibgesch&uuml;tzte sysctl-Variable
	<varname>kern.ipc.nsfbufs</varname> zeigt die Anzahl
	eingerichteten Puffer im Kernel.  Der Wert dieser Variablen
	wird normalerweise von <varname>kern.maxusers</varname> bestimmt.
	Manchmal muss die Pufferanzahl jedoch manuell eingestellt
	werden.</para>

      <important>
	<para>Auch wenn ein Socket nicht blockierend angelegt wurde,
	  kann der Aufruf von &man.sendfile.2; blockieren, um auf
	  freie <literal>struct sf_buf</literal> Puffer zu warten.</para>
      </important>

      <sect3>
	<title><varname>net.inet.ip.portrange.*</varname></title>

	<indexterm>
	  <primary>net.inet.ip.portrange.*</primary>
	</indexterm>

	<para>Die sysctl-Variable <varname>net.inet.ip.portrange.*</varname>
	  legt die Portnummern f&uuml;r TCP- und UDP-Sockets fest.
	  Es gibt drei Bereiche: den niedrigen Bereich, den
	  normalen Bereich und den hohen Bereich.  Die meisten
	  Netzprogramme benutzen den normalen Bereich.  Dieser Bereich
	  umfasst in der Voreinstellung die Portnummern 500 bis 5000
	  und wird durch die Variablen
	  <varname>net.inet.ip.portrange.first</varname> und
	  <varname>net.inet.ip.portrange.last</varname> festgelegt.
	  Die festgelegten Bereiche f&uuml;r Portnummern werden von
	  ausgehenden Verbindungen benutzt.  Unter bestimmten
	  Umst&auml;nden, beispielsweise auf stark ausgelasteten
	  Proxy-Servern, sind alle Portnummern f&uuml;r ausgehende
	  Verbindungen belegt.  Bereiche
	  f&uuml;r Portnummern spielen auf Servern keine Rolle, die
	  haupts&auml;chlich eingehende Verbindungen verarbeiten (wie ein
	  normaler Webserver) oder nur eine begrenzte Anzahl ausgehender
	  Verbindungen &ouml;ffnen (beispielsweise ein Mail-Relay).
	  Wenn Sie keine freien Portnummern mehr haben, sollten Sie
	  die Variable <varname>net.inet.ip.portrange.last</varname>
	  langsam erh&ouml;hen.  Ein Wert von <literal>10000</literal>,
	  <literal>20000</literal> oder <literal>30000</literal> ist
	  angemessen.  Beachten Sie auch eine vorhandene
	  Firewall, wenn Sie die Bereiche f&uuml;r Portnummern
	  &auml;ndern.  Einige Firewalls sperren gro&szlig;e Bereiche
	  (normalerweise aus den kleinen Portnummern) und erwarten,
	  dass hohe Portnummern f&uuml;r ausgehende Verbindungen
	  verwendet werden.  Daher kann es erforderlich sein, den
	  Wert von <varname>net.inet.ip.portrange.first</varname>
	  zu erh&ouml;hen.</para>
      </sect3>

      <sect3>
	<title>TCP Bandwidth Delay Product Begrenzung</title>

	<indexterm>
	  <primary>TCP Bandwidth Delay Product Begrenzung</primary>
	  <secondary>
	    <varname>net.inet.tcp.inflight.enable</varname>
	  </secondary>
	</indexterm>

	<para>Die TCP Bandwidth Delay Product Begrenzung gleicht
	  TCP/Vegas von NetBSD.  Die
	  Begrenzung wird aktiviert, indem Sie die sysctl-Variable
	  <varname>net.inet.tcp.inflight.enable</varname> auf den
	  Wert <literal>1</literal> setzen.  Das System wird dann
	  versuchen, f&uuml;r jede Verbindung, das Produkt aus der
	  &Uuml;bertragungsrate und der Verz&ouml;gerungszeit zu
	  bestimmen.  Dieses Produkt begrenzt die Datenmenge, die
	  f&uuml;r einen optimales Durchsatz zwischengespeichert
	  werden muss.</para>

	<para>Diese Begrenzung ist n&uuml;tzlich, wenn Sie Daten
	  &uuml;ber Verbindungen mit einem hohen Produkt aus
	  &Uuml;bertragungsrate und Verz&ouml;gerungszeit wie Modems,
	  Gigabit-Ethernet oder schnellen WANs, zur Verf&uuml;gung
	  stellen.  Insbesondere wirkt sich die Begrenzung aus, wenn
	  die Verbindung die TCP-Option
	  <foreignphrase>Window-scaling</foreignphrase> verwendet oder
	  gro&szlig;e Sende-Fenster
	  (<foreignphrase>send window</foreignphrase>) benutzt.
	  Schalten Sie die Debug-Meldungen aus, wenn Sie die Begrenzung
	  aktiviert haben.  Dazu setzen Sie die Variable
	  <varname>net.inet.tcp.inflight.debug</varname> auf
	  <literal>0</literal>.  Auf Produktions-Systemen sollten Sie
	  zudem die Variable <varname>net.inet.tcp.inflight.min</varname>
	  mindestens auf den Wert <literal>6144</literal> setzen.
	  Allerdings kann ein zu hoher Wert, abh&auml;ngig von der
	  Verbindung, die Begrenzungsfunktion unwirksam machen.
	  Die Begrenzung reduziert die Datenmenge in den Queues von Routern
	  und Switches, sowie die Datenmenge in der Queue der lokalen
	  Netzwerkkarte.  Die Verz&ouml;gerungszeit
	  (<foreignphrase>Round Trip Time</foreignphrase>) f&uuml;r
	  interaktive Anwendungen sinkt, da weniger Pakete
	  zwischengespeichert werden.  Dies gilt besonders f&uuml;r
	  Verbindungen &uuml;ber langsame Modems.  Die Begrenzung
	  wirkt sich allerdings nur auf das Versenden von Daten aus
	  (Uploads, Server).  Auf den Empfang von Daten (Downloads)
	  hat die Begrenzung keine Auswirkungen.</para>

	<para>Die Variable <varname>net.inet.tcp.inflight.stab</varname>
	  sollte <emphasis>nicht</emphasis> angepasst werden.  Der
	  Vorgabewert der Variablen betr&auml;gt <literal>20</literal>,
	  das hei&szlig;t es werden maximal zwei Pakete zu dem Produkt
	  aus &Uuml;bertragungsrate und Verz&ouml;gerungszeit addiert.
	  Dies stabilisiert den Algorithmus und verbessert die
	  Reaktionszeit auf Ver&auml;nderungen.  Bei langsamen
	  Verbindungen k&ouml;nnen sich aber die Laufzeiten der Pakete
	  erh&ouml;hen (ohne diesen Algorithmus w&auml;ren sie
	  allerdings noch h&ouml;her).  In solchen F&auml;llen
	  k&ouml;nnen Sie versuchen, den Wert der Variablen auf
	  <literal>15</literal>, <literal>10</literal> oder
	  <literal>5</literal> zu erniedrigen.  Gleichzeitig m&uuml;ssen
	  Sie vielleicht auch <varname>net.inet.tcp.inflight.min</varname>
	  auf einen kleineren Wert (beispielsweise <literal>3500</literal>)
	  setzen.  &Auml;ndern Sie diese Variablen nur ab, wenn Sie
	  keine anderen M&ouml;glichkeiten mehr haben.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Virtueller Speicher (<foreignphrase>Virtual
	Memory</foreignphrase>)</title>

      <sect3>
	<title><varname>kern.maxvnodes</varname></title>

	<para>Ein vnode ist die interne Darstellung einer Datei oder
	  eines Verzeichnisses.  Die Erh&ouml;hung der Anzahl der
	  f&uuml;r das Betriebssystem verf&uuml;gbaren vnodes
	  verringert also die Schreib- und Lesezugriffe auf
	  Ihre Festplatte.  vnodes werden im Normalfall vom
	  Betriebssystem automatisch vergeben und m&uuml;ssen
	  nicht von Ihnen angepasst werden.  In einigen F&auml;llen
	  stellt der Zugriff auf eine Platte allerdings einen
	  Flaschenhals dar, daher sollten Sie in diesem Fall die Anzahl
	  der m&ouml;glichen vnodes erh&ouml;hen, um dieses Problem zu
	  beheben.  Beachten Sie dabei aber die Gr&ouml;&szlig;e
	  des inaktiven und freien Hauptspeichers.</para>

	<para>Um die Anzahl der derzeit verwendeten vnodes zu sehen,
	  geben Sie Folgendes ein:</para>

        <screen>&prompt.root; <userinput>sysctl vfs.numvnodes</userinput>
vfs.numvnodes: 91349</screen>

	<para>Die maximal m&ouml;gliche Anzahl der vnodes erhalten
	   Sie durch die Eingabe von:</para>

        <screen>&prompt.root; <userinput>sysctl kern.maxvnodes</userinput>
kern.maxvnodes: 100000</screen>

	<para>Wenn sich die Anzahl der genutzten vnodes dem maximal
	  m&ouml;glichen Wert n&auml;hert, sollten Sie den Wert
	  <varname>kern.maxvnodes</varname> zuerst um etwa 1.000
	  erh&ouml;hen.  Beobachten Sie danach die Anzahl der vom
	  System genutzten <varname>vfs.numvnodes</varname>.
	  N&auml;hert sich der Wert wiederum dem definierten
	  Maximum, m&uuml;ssen Sie <varname>kern.maxvnodes</varname>
	  nochmals erh&ouml;hen.  Sie sollten nun eine &Auml;nderung
	  Ihres Speicherverbrauches (etwa &uuml;ber &man.top.1;)
	  registrieren k&ouml;nnen und &uuml;ber mehr aktiven
	  Speicher verf&uuml;gen.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="adding-swap-space">
    <title>Hinzuf&uuml;gen von Swap-Bereichen</title>

    <para>Egal wie vorausschauend Sie planen, manchmal entspricht ein System
      einfach nicht Ihren Erwartungen.  Es ist leicht, mehr Swap-Bereiche
      hinzuzuf&uuml;gen.  Dazu stehen Ihnen drei Wege offen:  Sie
      k&ouml;nnen eine neue Platte einbauen, den Swap-Bereich &uuml;ber NFS
      ansprechen oder eine Swap-Datei auf einer existierenden Partition
      einrichten.</para>

    <para>F&uuml;r Informationen zur Verschl&uuml;sselung von
      Swap-Partitionen, zu den dabei m&ouml;glichen Optionen sowie
      zu den Gr&uuml;nden f&uuml;r eine Verschl&uuml;sselung des
      Auslagerungsspeichers lesen Sie bitte
      <xref linkend="swap-encrypting"> des Handbuchs.</para>

    <sect2 id="new-drive-swap">
      <title>Swap auf einer neuen Festplatte</title>

      <para>Der einfachste Weg, zus&auml;tzlich einen Swap-Bereich
        einzurichten, ist der Einbau einer neuen Platte, die Sie
	sowieso gebrauchen k&ouml;nnen.  Die Anordnung von
	Swap-Bereichen wird in <xref linkend="configtuning-initial">
	des Handbuchs besprochen.</para>
    </sect2>

    <sect2 id="nfs-swap">
      <title>Swap-Bereiche &uuml;ber NFS</title>

      <para>Swap-Bereiche &uuml;ber NFS sollten Sie nur dann einsetzen,
	wenn Sie &uuml;ber keine lokale Platte verf&uuml;gen, da es durch
	die zur Verf&uuml;gung stehende Bandbreite limitiert wird und
	au&szlig;erdem den NFS-Server zus&auml;tzlich belastet.</para>
    </sect2>

    <sect2 id="create-swapfile">
      <title>Swap-Dateien</title>

      <para>Sie k&ouml;nnen eine Datei festgelegter Gr&ouml;&szlig;e als
        Swap-Bereich nutzen.  Im folgenden Beispiel werden wir eine 64&nbsp;MB
	gro&szlig;e Datei mit Namen <filename>/usr/swap0</filename>
	benutzen, Sie k&ouml;nnen nat&uuml;rlich einen beliebigen Namen
	f&uuml;r den Swap-Bereich benutzen.</para>

      <example>
	<title>Erstellen einer Swap-Datei</title>

        <orderedlist>
	  <listitem>
	    <para>Stellen Sie sicher, dass der Kernel RAM-Disks
	      (&man.md.4;) unterst&uuml;tzt.  Dies ist in der
	      <filename>GENERIC</filename>-Konfiguration
	      voreingestellt.</para>

	    <programlisting>device   md   # Memory "disks"</programlisting>
	  </listitem>

	  <listitem>
	    <para>Legen Sie die Swap-Datei
	      <filename>/usr/swap0</filename> an:</para>

	    <screen>&prompt.root; <userinput>dd if=/dev/zero of=/usr/swap0 bs=1024k count=64</userinput></screen>
	  </listitem>

	  <listitem>
	    <para>Setzen Sie die richtigen Berechtigungen f&uuml;r
	      <filename>/usr/swap0</filename>:</para>

	    <screen>&prompt.root; <userinput>chmod 0600 /usr/swap0</userinput></screen>
	  </listitem>

	  <listitem>
	    <para>Aktivieren Sie die Swap-Datei
	      <filename>/etc/rc.conf</filename>:</para>

	    <programlisting>swapfile="/usr/swap0"   # Set to name of swapfile if aux swapfile desired.</programlisting>
	  </listitem>

	  <listitem>
	    <para>Um die Swap-Datei zu aktivieren, f&uuml;hren Sie
	      entweder einen Neustart durch oder geben das folgende Kommando
	      ein:</para>

	    <screen>&prompt.root; <userinput>mdconfig -a -t vnode -f /usr/swap0 -u 0 &amp;&amp; swapon /dev/md0</userinput></screen>
          </listitem>
        </orderedlist>
      </example>
    </sect2>
  </sect1>

  <sect1 id="acpi-overview">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Hiten</firstname>
	  <surname>Pandya</surname>
	  <contrib>Verfasst von </contrib>
	</author>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	</author>
      </authorgroup>
    </sect1info>

    <title>Energie- und Ressourcenverwaltung</title>

    <para>Es ist wichtig, Hardware effizient einzusetzen.  Vor der
      Einf&uuml;hrung des <firstterm>Advanced Configuration and Power
        Interface</firstterm> (<acronym>ACPI</acronym>) konnten
      Stromverbrauch und W&auml;rmeabgabe eines Systems nur
      schlecht von Betriebssystemen gesteuert werden.  Die Hardware
      wurde vom <acronym>BIOS</acronym> gesteuert, was die Kontrolle
      der Energieverwaltung f&uuml;r den Anwender erschwerte.  Das
      <emphasis>Advanced Power Management (APM)</emphasis> erlaubte
      es lediglich, einige wenige Funktionen zu steuern, obwohl die
      &Uuml;berwachung von Energie- und Ressourcenverbrauch zu den
      wichtigsten Aufgaben eines Betriebssystems geh&ouml;rt, um auf
      verschiedene Ereignisse, beispielsweise einen unerwarteten
      Temperaturanstieg, reagieren k&ouml;nnen.</para>

    <para>Dieser Abschnitt erkl&auml;rt das Advanced Configuration and
      Power Interface (<acronym>ACPI</acronym>).</para>

    <sect2 id="acpi-intro">
      <title>Was ist ACPI?</title>

      <indexterm>
	<primary>ACPI</primary>
      </indexterm>

      <indexterm>
	<primary>APM</primary>
      </indexterm>

      <para>Advanced Configuration and Power Interface
        (<acronym>ACPI</acronym>) ist ein Standard verschiedener
	Hersteller, der die Verwaltung von Hardware und
	Energiesparfunktionen festlegt.  Die
	<acronym>ACPI</acronym>-Funktionen k&ouml;nnen von einem
	Betriebssystem gesteuert werden.  Der Vorg&auml;nger des
	<acronym>ACPI</acronym>, <quote>Advanced Power Management</quote>
	(<acronym>APM</acronym>), erwies sich in modernen Systemen
	als unzureichend.</para>
    </sect2>

    <sect2 id="acpi-old-spec">
      <title>M&auml;ngel des Advanced Power Managements (APM)</title>

      <para>Das <emphasis>Advanced Power Management (APM)</emphasis>
	steuert den Energieverbrauch eines Systems auf Basis
	der Systemaktivit&auml;t.  Das APM-BIOS wird von dem
	Hersteller des Systems zur Verf&uuml;gung gestellt
	und ist auf die spezielle Hardware angepasst.  Der
	APM-Treiber des Betriebssystems greift auf das
	<emphasis>APM Software Interface</emphasis> zu, das den
	Energieverbrauch regelt.  APM findet sich in der Regel
	nur noch in Systemen, die vor 2001 produziert
	wurden.</para>

      <para>Das <acronym>APM</acronym> hat haupts&auml;chlich
	vier Probleme.  Erstens l&auml;uft die Energieverwaltung
	unabh&auml;ngig vom Betriebssystem in einem
	(herstellerspezifischen) BIOS.  Beispielsweise kann
	das APM-BIOS die Festplatten nach einer konfigurierbaren
	Zeit ohne die Zustimmung des Betriebssystems herunterfahren.
	Zweitens befindet sich die ganze APM-Logik im BIOS;  das
	Betriebssystem hat gar keine APM-Komponenten.  Bei Problemen
	mit dem APM-BIOS muss das Flash-ROM aktualisiert werden.
	Diese Prozedur ist gef&auml;hrlich, da sie im Fehlerfall
	das System unbrauchbar machen kann.  Zum Dritten ist APM
	eine Technik, die herstellerspezifisch ist und nicht
	koordiniert wird.  Fehler im BIOS eines Herstellers werden
	nicht unbedingt im BIOS anderer Hersteller korrigiert.
	Das letzte Problem ist, dass im APM-BIOS nicht gen&uuml;gend
	Platz vorhanden ist, um eine durchdachte oder eine auf den
	Zweck der Maschine zugeschnittene Energieverwaltung
	zu implementieren.</para>

      <para>Das <emphasis>Plug and Play BIOS (PNPBIOS)</emphasis>
	war ebenfalls unzureichend.  Das PNPBIOS verwendet eine
	16-Bit-Technik.  Damit das Betriebssystem das PNPBIOS
	ansprechen kann, muss es in einer 16-Bit-Emulation laufen.</para>

      <para>Der <acronym>APM</acronym>-Treiber von &os; ist in
	der Hilfeseite &man.apm.4; beschrieben.</para>
    </sect2>

    <sect2 id="acpi-config">
      <title>Konfiguration des <acronym>ACPI</acronym></title>

      <para>Das Modul <filename>acpi.ko</filename> wird
	standardm&auml;&szlig;ig beim Systemstart vom &man.loader.8;
	geladen und sollte daher <emphasis>nicht</emphasis>
	fest in den Kernel eingebunden werden.  Dadurch kann
	<filename>acpi.ko</filename> ohne einen Neubau des Kernels ersetzt
	werden und das Modul ist leichter zu testen.  Wenn Sie in der
	Ausgabe von &man.dmesg.8; das Wort <acronym>ACPI</acronym> sehen,
	ist das Modul geladen worden.  Das ACPI-Modul im laufenden
	Betrieb zu laden, f&uuml;hrt oft nicht zum gew&uuml;nschten
	Ergebnis.  Treten bei Ihrem System Probleme auf, k&ouml;nnen
	Sie <acronym>ACPI</acronym> auch komplett deaktivieren.
	Dazu definieren Sie die Variable
	<literal>hint.acpi.0.disabled="1"</literal> in der Datei
	<filename>/boot/loader.conf</filename>.  Alternativ k&ouml;nnen
	Sie die Variable auch am &man.loader.8;-Prompt eingeben.
	Das Modul kann im laufenden Betrieb nicht entfernt werden,
	da es zur Kommunikation mit der Hardware verwendet wird.</para>

      <note>
	<para><acronym>ACPI</acronym> und <acronym>APM</acronym>
	  k&ouml;nnen nicht zusammen verwendet werden.  Das zuletzt
	  geladene Modul beendet sich, sobald es bemerkt, dass das andere
	  Modul geladen ist.</para>
      </note>

      <para>Mit &man.acpiconf.8; k&ouml;nnen Sie das System in einen
        Ruhemodus (<foreignphrase>sleep mode</foreignphrase>) versetzen.
	Es gibt verschiedene Modi (von <literal>1</literal> bis
	<literal>5</literal>), die Sie auf der Kommandozeile mit
	<option>-s</option> angeben k&ouml;nnen.  F&uuml;r die meisten
	Anwender sind die Modi <literal>1</literal> und
	<literal>3</literal> v&ouml;llig ausreichend.  Der Modus
	<literal>5</literal> schaltet das System
	aus (<foreignphrase>Soft-off</foreignphrase>) und entspricht
	dem folgenden Befehl:</para>

      <screen>&prompt.root; <userinput>halt -p</userinput></screen>

      <para>Verschiedene Optionen k&ouml;nnen als
	&man.sysctl.8;-Variablen gesetzt werden.  Lesen Sie dazu
	die Manualpages zu &man.acpi.4; sowie &man.acpiconf.8;.</para>
    </sect2>
  </sect1>

  <sect1 id="ACPI-debug">
    <sect1info>
      <authorgroup>
	<author>
	  <firstname>Nate</firstname>
	  <surname>Lawson</surname>
	  <contrib>Verfasst von </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <firstname>Peter</firstname>
	  <surname>Schultz</surname>
	  <contrib>Mit Beitr&auml;gen von </contrib>
	</author>
	<author>
	  <firstname>Tom</firstname>
	  <surname>Rhodes</surname>
	</author>
      </authorgroup>
    </sect1info>

    <title><acronym>ACPI</acronym>-Fehlersuche</title>

    <indexterm>
      <primary>ACPI</primary>
      <secondary>Probleme mit</secondary>
    </indexterm>

    <para><acronym>ACPI</acronym> ist ein g&auml;nzlich neuer
      Weg, um Ger&auml;te aufzufinden und deren Stromverbrauch
      zu regulieren.  Weiterhin bietet <acronym>ACPI</acronym>
      einen einheitlichen Zugriff auf Ger&auml;te, die vorher
      vom <acronym>BIOS</acronym> verwaltet wurden.  Es werden
      zwar Fortschritte gemacht, dass <acronym>ACPI</acronym>
      auf allen Systemen l&auml;uft, doch tauchen immer wieder
      Fehler auf:  fehlerhafter Bytecode der
      <acronym>ACPI</acronym>-Machine-Language
      (<acronym>AML</acronym>) einiger Systemplatinen,
      ein unvollst&auml;ndiges &os;-Kernel-Subsystem oder
      Fehler im <acronym>ACPI-CA</acronym>-Interpreter von &intel;.</para>

    <para>Dieser Abschnitt hilft Ihnen, zusammen mit den Betreuern
      des &os;-<acronym>ACPI</acronym>-Subsystems, Fehlerquellen
      zu finden und Fehler zu beseitigen.  Danke, dass Sie diesen
      Abschnitt lesen; hoffentlich hilft er, Ihre Systemprobleme
      zu l&ouml;sen.</para>

    <sect2 id="ACPI-submitdebug">
      <title>Fehlerberichte einreichen</title>

      <note>
	<para>Bevor Sie einen Fehlerbericht einreichen, stellen
	  Sie bitte sicher, dass Ihr <acronym>BIOS</acronym>
	  und die Firmware Ihres Controllers aktuell sind.</para>
      </note>

      <para>Wenn Sie sofort einen Fehlerbericht einsenden wollen,
	schicken Sie bitte die folgenden Informationen an
	die Mailingliste <ulink
	url="mailto:freebsd-acpi@FreeBSD.org">freebsd-acpi</ulink>:</para>

      <itemizedlist>
	<listitem>
	  <para>Beschreiben Sie den Fehler und alle Umst&auml;nde,
	    unter denen der Fehler auftritt.  Geben Sie
	    ebenfalls den Typ und das Modell Ihres Systems
	    an.  Wenn Sie einen neuen Fehler entdeckt haben,
	    versuchen Sie m&ouml;glichst genau zu beschreiben,
	    wann der Fehler das erste Mal aufgetreten ist.</para>
	</listitem>

	<listitem>
	  <para>Die Ausgabe von &man.dmesg.8; nach der Eingabe
	    von <command>boot -v</command>.
	    Geben Sie auch alle Fehlermeldungen an, die erscheinen,
	    wenn Sie den Fehler provozieren.</para>
	</listitem>

	<listitem>
	  <para>Die Ausgabe von &man.dmesg.8; nach der Eingabe
	    von <command>boot -v</command> und mit deaktiviertem
	    <acronym>ACPI</acronym>, wenn das Problem ohne
	    <acronym>ACPI</acronym> nicht auftritt.</para>
	</listitem>

	<listitem>
	  <para>Die Ausgabe von <command>sysctl hw.acpi</command>.
	    Dieses Kommando zeigt die vom System unterst&uuml;tzten
	    <acronym>ACPI</acronym>-Funktionen an.</para>
	</listitem>

	<listitem>
	  <para>Die <acronym>URL</acronym>, unter der die
	    <acronym>ACPI</acronym>-Source-Language
	    (<acronym>ASL</acronym>) liegt.  Schicken Sie
	    bitte <emphasis>nicht</emphasis> die <acronym>ASL</acronym>
	    an die Mailingliste, da die <acronym>ASL</acronym>
	    sehr gro&szlig; sein kann.  Eine Kopie der
	    <acronym>ASL</acronym> erstellen Sie mit dem
	    nachstehenden Befehl:</para>

	  <screen>&prompt.root; <userinput>acpidump -td &gt; <replaceable>name</replaceable>-<replaceable>system</replaceable>.asl</userinput></screen>

	  <para>Setzen Sie bitte f&uuml;r <replaceable>name</replaceable>
	    den Namen Ihres Kontos und f&uuml;r
	    <replaceable>system</replaceable> den Hersteller und
	    das Modell Ihres Systems ein.  Zum Beispiel:
	    <filename>njl-FooCo6000.asl</filename>.</para>
	</listitem>
      </itemizedlist>

      <para>Obwohl die meisten Entwickler die Mailingliste
	&a.current.name; lesen, sollten Sie Fehlerberichte an
	die Liste &a.acpi.name; schicken.  Seien Sie bitte
	geduldig;  wir haben alle Arbeit au&szlig;erhalb des Projekts.
	Wenn der Fehler nicht offensichtlich ist, bitten
	wir Sie vielleicht, einen offiziellen Fehlerbericht
	(<acronym>PR</acronym>) mit &man.send-pr.1; einzusenden.
	Geben Sie im Fehlerbericht bitte dieselben Informationen
	wie oben an.  Mithilfe der <acronym>PR</acronym>s
	verfolgen und l&ouml;sen wir Probleme.  Senden Sie
	bitte keinen <acronym>PR</acronym> ein, ohne vorher
	den Fehlerbericht an die Liste &a.acpi.name; zu senden.
	Wir benutzen die <acronym>PR</acronym>s als Erinnerung
	an bestehende Probleme und nicht zum Sammeln aller
	Probleme.  Es kann sein, dass der Fehler schon von
	jemand anderem gemeldet wurde.</para>
    </sect2>

    <sect2 id="ACPI-background">
      <title><acronym>ACPI</acronym>-Grundlagen</title>

      <indexterm>
	<primary>ACPI</primary>
      </indexterm>

      <para><acronym>ACPI</acronym> gibt es in allen modernen Rechnern
	der ia32- (x86), ia64- (Itanium) und amd64- (AMD) Architektur.
	Der vollst&auml;ndige Standard bietet Funktionen
	zur Steuerung und Verwaltung der <acronym>CPU</acronym>-Leistung,
	der Stromversorgung, von W&auml;rmebereichen, Batterien,
	eingebetteten Controllern und Bussen.  Auf den meisten
	Systemen wird nicht der vollst&auml;ndige Standard implementiert.
	Arbeitsplatzrechner besitzen meist nur Funktionen zur
	Verwaltung der Busse, w&auml;hrend Notebooks Funktionen
	zur Temperaturkontrolle und Ruhezust&auml;nde besitzen.</para>

      <para>Ein <acronym>ACPI</acronym> konformes System
	besitzt verschiedene Komponenten.  Die <acronym>BIOS</acronym>-
	und Chipsatz-Hersteller stellen mehrere statische
	Tabellen bereit (zum Beispiel die
	Fixed-<acronym>ACPI</acronym>-Description-Table,
	<acronym>FADT</acronym>).  Die Tabellen enthalten beispielsweise
	die mit <acronym>SMP</acronym>-Systemen benutzte
	<acronym>APIC</acronym>-Map, Konfigurationsregister und
	einfache Konfigurationen.  Zus&auml;tzlich gibt es die
	Differentiated-System-Description-Table (<acronym>DSDT</acronym>),
	die Bytecode enth&auml;lt.  Die Tabelle ordnet Ger&auml;te
	und Methoden in einem baumartigen Namensraum an.</para>

      <para>Ein <acronym>ACPI</acronym>-Treiber muss die statischen
	Tabellen einlesen, einen Interpreter f&uuml;r den Bytecode
	bereitstellen und die Ger&auml;tetreiber im Kernel so
	modifizieren, dass sie mit dem <acronym>ACPI</acronym>-Subsystem
	kommunizieren.  F&uuml;r &os;, Linux und NetBSD hat &intel;
	den Interpreter <acronym>ACPI-CA</acronym>, zur Verf&uuml;gung
	gestellt.  Der Quelltext zu <acronym>ACPI-CA</acronym>
	befindet sich im Verzeichnis
	<filename class="directory">src/sys/contrib/dev/acpica</filename>.
	Die Schnittstelle von <acronym>ACPI-CA</acronym> zu &os;
	befindet sich unter <filename
	class="directory">src/sys/dev/acpica/Osd</filename>.
	Treiber, die verschiedene <acronym>ACPI</acronym>-Ger&auml;te
	implementieren, befinden sich im Verzeichnis
	<filename class="directory">src/sys/dev/acpica</filename>.</para>
    </sect2>

    <sect2 id="ACPI-comprob">
      <title>H&auml;ufige Probleme</title>

      <indexterm>
	<primary>ACPI</primary>
	<secondary>Probleme mit</secondary>
      </indexterm>

      <para>Damit <acronym>ACPI</acronym> richtig funktioniert,
	m&uuml;ssen alle Teile funktionieren.  Im Folgenden
	finden Sie eine Liste mit Problemen und m&ouml;glichen
	Umgehungen oder Fehlerbehebungen.  Die Liste ist nach
	der H&auml;ufigkeit, mit der die Probleme auftreten,
	sortiert.</para>

      <sect3>
        <title>Mausprobleme</title>

        <para>Es kann vorkommen, dass die Maus nicht mehr funktioniert,
	  wenn Sie nach einem Suspend weiterarbeiten wollen.  Ist dies
	  bei Ihnen der Fall, reicht es meistens aus, den Eintrag
	  <literal>hint.psm.0.flags="0x3000"</literal> in Ihre
	  <filename>/boot/loader.conf</filename> aufzunehmen.  Besteht
	  das Problem weiterhin, sollten Sie einen Fehlerbericht
	  an das FreeBSD Project senden.</para>
      </sect3>

      <sect3>
	<title>Suspend/Resume</title>

	<para><acronym>ACPI</acronym> kennt drei
	  Suspend-to-<acronym>RAM</acronym>-Zust&auml;nde
	  (<acronym>STR</acronym>):
	  <literal>S1</literal>-<literal>S3</literal>.
	  Es gibt einen Suspend-to-Disk-Zustand:
	  <literal>S4</literal>.  Der Zustand <literal>S5</literal>
	  wird Soft-Off genannt.  In diesem Zustand befindet
	  sich ein Rechner, wenn die Stromversorgung angeschlossen
	  ist, der Rechner aber nicht hochgefahren ist.  Der
	  Zustand <literal>S4</literal> kann auf zwei Arten
	  implementiert werden:
	  <literal>S4</literal><acronym>BIOS</acronym> und
	  <literal>S4</literal><acronym>OS</acronym>.
	  Im ersten Fall wird der Suspend-to-Disk-Zustand durch
	  das <acronym>BIOS</acronym> hergestellt im zweiten
	  Fall alleine durch das Betriebssystem.</para>

	<note>
	  <para>Die Suspend-Zust&auml;nde sind Ruhezust&auml;nde,
	    in denen der Rechner weniger Energie als im
	    Normalbetrieb ben&ouml;tigt.  Resume bezeichnet
	    die R&uuml;ckkehr zum Normalbetrieb.</para>
	</note>

	<para>Die Suspend-Zust&auml;nde k&ouml;nnen Sie mit
	  dem Kommando <command>sysctl hw.acpi</command>
	  ermitteln.  Das Folgende k&ouml;nnte beispielsweise
	  ausgegeben werden:</para>

	<screen>hw.acpi.supported_sleep_state: S3 S4 S5
hw.acpi.s4bios: 0</screen>

	<para>Diese Ausgabe besagt, dass mit dem Befehl
	  <command>acpiconf -s</command> die Zust&auml;nde
	  <literal>S3</literal>, <literal>S4</literal><acronym>OS</acronym>
	  und <literal>S5</literal> eingestellt werden k&ouml;nnen.
	  H&auml;tte <option>s4bios</option> den Wert
	  <literal>1</literal>, g&auml;be es den Zustand
	  <literal>S4</literal><acronym>BIOS</acronym> anstelle
	  von <literal>S4</literal><acronym>OS</acronym>.</para>

	<para>Wenn Sie die Suspend- und Resume-Funktionen
	  testen, fangen Sie mit dem <literal>S1</literal>-Zustand
	  an, wenn er angeboten wird.  Dieser Zustand wird
	  am ehesten funktionieren, da der Zustand wenig
	  Treiber-Unterst&uuml;tzung ben&ouml;tigt.  Der Zustand
	  <literal>S2</literal> ist &auml;hnlich wie
	  <literal>S1</literal>, allerdings hat ihn noch niemand
	  implementiert.  Als n&auml;chstes sollten Sie den
	  Zustand <literal>S3</literal> ausprobieren.  Dies
	  ist der tiefste <acronym>STR</acronym>-Schlafzustand.
	  Dieser Zustand ist auf massive Treiber-Unterst&uuml;tzung
	  angewiesen, um die Ger&auml;te wieder richtig zu
	  initialisieren.  Wenn Sie Probleme mit diesem Zustand
	  haben, k&ouml;nnen Sie die Mailingliste
	  &a.acpi.name; anschreiben.  Erwarten Sie allerdings
	  nicht zu viel:  Es gibt viele Treiber und Ger&auml;te,
	  an denen noch gearbeitet und getestet wird.</para>
<!--  -->
	<para>Ein h&auml;ufiges Problem mit Suspend/Resume ist,
	  dass viele Ger&auml;tetreiber ihre Firmware, Register
	  und Ger&auml;tespeicher nicht korrekt speichern,
	  wiederherstellen und/oder reinitialisieren.  Um dieses
	  Problem zu l&ouml;sen, sollten Sie zuerst die
	  folgenden Befehle ausf&uuml;hren:</para>

	<screen>&prompt.root; <userinput>sysctl debug.bootverbose=1</userinput>
&prompt.root; <userinput>sysctl debug.acpi.suspend_bounce=1</userinput>
&prompt.root; <userinput>acpiconf -s 3</userinput></screen>

	<para>Dieser Test emuliert einen Suspend/Resume-Zyklus f&uuml;r
	  alle Ger&auml;te (ohne dass diese dabei wirklich in den Status
	  <literal>S3</literal> wechseln).  In vielen F&auml;llen
	  reicht dies bereits aus, um Probleme (beispielsweise
	  verlorener Firmware-Status, Timeouts, h&auml;ngende Ger&auml;te)
	  zu entdecken.  Beachten Sie dabei, dass das Ger&auml;t bei
	  diesem Test nicht wirklich in den Status
	  <literal>S3</literal> wechseln.  Es kann also vorkommen, dass
	  manche Ger&auml;te weiterhin mit Strom versorgt werden (dies
	  w&auml;re bei einem wirklichen Wechsel in den Status
	  <literal>S3</literal> NICHT m&ouml;glich.
	  Andere Ger&auml;te werden normal weiterarbeiten, weil sie
	  &uuml;ber keine Suspend/Resume-Funktionen verf&uuml;gen.</para>

	<para>Schwierigere F&auml;lle k&ouml;nnen den Einsatz
	  zus&auml;tzlicher Hardware (beispielsweise serielle
	  Ports/Kabel f&uuml;r die Verbindung &uuml;ber eine
	  serielle Konsole oder Firewire-Ports/Kabel f&uuml;r
	  &man.dcons.4;) sowie Kenntnisse im Bereich
	  Kerneldebugging erforderlich machen.</para>

	<para>Um das Problem einzugrenzen, entfernen Sie soviele
	  Treiber wie m&ouml;glich aus dem Kernel.  Sie k&ouml;nnen
	  das Problem isolieren, indem Sie einen Treiber nach
	  dem anderen laden, bis der Fehler wieder auftritt.
	  Typischerweise verursachen bin&auml;re Treiber wie
	  <filename>nvidia.ko</filename>,  X11-Grafiktreiber und
	  <acronym>USB</acronym>-Treiber die meisten Fehler,
	  hingegen laufen Ethernet-Treiber f&uuml;r gew&ouml;hnlich
	  sehr zuverl&auml;ssig.  Wenn ein Treiber
	  zuverl&auml;ssig geladen und entfernt werden kann,
	  k&ouml;nnen Sie den Vorgang automatisieren, indem
	  Sie die entsprechenden Kommandos in die Dateien
	  <filename>/etc/rc.suspend</filename> und
	  <filename>/etc/rc.resume</filename> einf&uuml;gen.
	  In den Dateien finden Sie ein deaktiviertes Beispiel,
	  das einen Treiber l&auml;dt und wieder entfernt.
	  Ist die Bildschirmanzeige bei der Wiederaufnahme
	  des Betriebs gest&ouml;rt, setzen Sie bitte die
	  Variable <option>hw.acpi.reset_video</option> auf
	  <literal>0</literal>.  Versuchen Sie auch, die Variable
	  <option>hw.acpi.sleep_delay</option> auf k&uuml;rzere
	  Zeitspannen zu setzen.</para>

	<para>Die Suspend- und Resume-Funktionen k&ouml;nnen
	  Sie auch auf einer neuen Linux-Distribution
	  mit <acronym>ACPI</acronym> testen.  Wenn es mit
	  Linux funktioniert, liegt das Problem wahrscheinlich
	  bei einem &os;-Treiber.  Es hilft uns, das Problem
	  zu l&ouml;sen, wenn Sie feststellen k&ouml;nnen, welcher
	  Treiber das Problem verursacht.  Beachten Sie bitte,
	  dass die <acronym>ACPI</acronym>-Entwickler normalerweise
	  keine anderen Treiber pflegen (beispielsweise Sound- oder
	  <acronym>ATA</acronym>-Treiber).  Es ist wohl das beste,
	  die Ergebnisse der Fehlersuche an die Mailingliste
	  &a.current.name; und den Entwickler des Treibers
	  zu schicken.  Wenn Ihnen danach ist, versuchen Sie,
	  den Fehler in der Resume-Funktion zu finden, indem
	  Sie einige &man.printf.3;-Anweisungen in den Code
	  des fehlerhaften Treibers einf&uuml;gen.</para>

	<para>Schlie&szlig;lich k&ouml;nnen Sie <acronym>ACPI</acronym>
	  noch abschalten und stattdessen <acronym>APM</acronym>
	  verwenden.  Wenn die Suspend- und Resume-Funktionen mit
	  <acronym>APM</acronym> funktionieren, sollten Sie
	  vielleicht besser <acronym>APM</acronym> verwenden
	  (insbesondere mit alter Hardware von vor dem Jahr 2000).
	  Die Hersteller ben&ouml;tigten einige Zeit, um
	  <acronym>ACPI</acronym> korrekt zu implementieren, daher
	  gibt es mit &auml;lterer Hardware oft
	  <acronym>ACPI</acronym>-Probleme.</para>
      </sect3>

      <sect3>
	<title>Tempor&auml;re oder permanente Systemh&auml;nger</title>

	<para>Die meisten Systemh&auml;nger entstehen durch verlorene
	  Interrupts oder einen Interrupt-Sturm.
	  Probleme werden verursacht durch die Art, in der das
	  <acronym>BIOS</acronym> Interrupts vor dem Systemstart
	  konfiguriert, durch eine fehlerhafte
	  <acronym>APIC</acronym>-Tabelle und durch die
	  Zustellung des System-Control-Interrupts
	  (<acronym>SCI</acronym>).</para>

	<indexterm>
	  <primary>Interrupt-Sturm</primary>
	</indexterm>

	<para>Anhand der Ausgabe des Befehls
	  <command>vmstat -i</command> k&ouml;nnen Sie verlorene
	  Interrupts von einem Interrupt-Sturm unterscheiden.
	  Untersuchen Sie die Ausgabezeile, die <literal>acpi0</literal>
	  enth&auml;lt.  Ein Interrupt-Sturm liegt vor, wenn
	  der Z&auml;hler &ouml;fter als ein paar Mal pro
	  Sekunde hochgez&auml;hlt wird.  Wenn sich das System
	  aufgehangen hat, versuchen Sie mit der Tastenkombination
	  <keycombo action="simul">
	    <keycap>Ctrl</keycap>
	    <keycap>Alt</keycap>
	    <keycap>Esc</keycap>
	  </keycombo> in den Debugger <acronym>DDB</acronym>
	  zu gelangen.  Geben Sie dort den Befehl
	  <literal>show interrupts</literal> ein.</para>

	<indexterm>
	  <primary>APIC</primary>
	  <secondary>deaktivieren</secondary>
	</indexterm>

	<para>Wenn Sie Interrupt-Probleme haben, ist es vorerst
	  wohl am besten, <acronym>APIC</acronym> zu deaktivieren.
	  Tragen Sie dazu die Zeile
	  <literal>hint.apic.0.disabled="1"</literal> in
	  <filename>loader.conf</filename> ein.</para>
      </sect3>

      <sect3>
	<title>Abst&uuml;rze (Panics)</title>

	<para><foreignphrase>Panics</foreignphrase> werden so
	  schnell wie m&ouml;glich behoben;  mit <acronym>ACPI</acronym>
	  kommt es aber selten dazu.  Zuerst sollten Sie
	  die Panic reproduzieren und dann versuchen einen
	  <foreignphrase>backtrace</foreignphrase> (eine
	  R&uuml;ckverfolgung der Funktionsaufrufe) zu erstellen.
	  Richten Sie dazu den <acronym>DDB</acronym> &uuml;ber
	  die serielle Schnittstelle (siehe
	  <xref linkend="serialconsole-ddb">) oder eine gesonderte
	  &man.dump.8;-Partition ein.  In <acronym>DDB</acronym>
	  k&ouml;nnen Sie den <foreignphrase>backtrace</foreignphrase>
	  mit dem Kommando <literal>tr</literal> erstellen.
	  Falls Sie den <foreignphrase>backtrace</foreignphrase>
	  vom Bildschirm abschreiben m&uuml;ssen, schreiben
	  Sie bitte mindestens die f&uuml;nf ersten und die
	  f&uuml;nf letzten Zeile der Ausgabe auf.</para>

	<para>Versuchen Sie anschlie&szlig;end, das Problem
	  durch einen Neustart ohne <acronym>ACPI</acronym>
	  zu beseitigen.  Wenn das funktioniert hat, k&ouml;nnen
	  Sie versuchen, das verantwortliche
	  <acronym>ACPI</acronym>-Subsystem durch Setzen der
	  Variablen <option>debug.acpi.disable</option>
	  herauszufinden.  Die Hilfeseite &man.acpi.4; enth&auml;lt
	  dazu einige Beispiele.</para>
      </sect3>

      <sect3>
	<title>Nach einem Suspend oder einem Stopp startet
	  das System wieder</title>

	<para>Setzen Sie zuerst in &man.loader.conf.5; die Variable
	  <option>hw.acpi.disable_on_poweroff</option> auf
	  <literal>0</literal>.  Damit wird verhindert, dass
	  <acronym>ACPI</acronym> w&auml;hrend des Systemabschlusses
	  die Bearbeitung verschiedener Ereignisse deaktiviert.
	  Auf manchen Systemen muss die Variable den Wert
	  <literal>1</literal> besitzen (die Voreinstellung).
	  Normalerweise wird der unerw&uuml;nschte Neustart
	  des Systems durch Setzen dieser Variablen behoben.</para>
      </sect3>

      <sect3>
	<title>Andere Probleme</title>

	<para>Wenn Sie weitere Probleme mit <acronym>ACPI</acronym>
	  haben (Umgang mit einer Docking-Station, nicht erkannte
	  Ger&auml;te), schicken Sie bitte eine Beschreibung an die
	  Mailingliste.  Allerdings kann es sein, dass einige
	  Probleme von noch unvollst&auml;ndigen Teilen des
	  <acronym>ACPI</acronym>-Subsystems abh&auml;ngen und
	  es etwas dauern kann bis diese Teile fertig sind.
	  Seien Sie geduldig und rechnen Sie damit, dass wir
	  Ihnen Fehlerbehebungen zum Testen senden.</para>
      </sect3>
    </sect2>

    <sect2 id="ACPI-aslanddump">
      <title><acronym>ASL</acronym>, <command>acpidump</command> und
	<acronym>IASL</acronym></title>

      <indexterm>
	<primary>ACPI</primary>
	<secondary>ASL</secondary>
      </indexterm>

      <para>Ein h&auml;ufiges Problem ist fehlerhafter Bytecode
	des <acronym>BIOS</acronym>-Herstellers.  Dies erkennen
	Sie an Kernelmeldungen auf der Konsole wie die folgende:</para>

      <screen>ACPI-1287: *** Error: Method execution failed [\\_SB_.PCI0.LPC0.FIGD._STA] \\
(Node 0xc3f6d160), AE_NOT_FOUND</screen>

      <para>Oft k&ouml;nnen Sie das Problem dadurch l&ouml;sen,
	dass Sie eine aktuelle <acronym>BIOS</acronym>-Version
	einspielen.  Die meisten Meldungen auf der Konsole sind
	harmlos,  wenn aber beispielsweise der Batteriestatus
	falsch angezeigt wird, k&ouml;nnen Sie in den
	Meldungen nach Problemen mit der
	<acronym>AML</acronym>-Machine-Language
	(<acronym>AML</acronym>) suchen.  Der Bytecode der
	<acronym>AML</acronym> wird aus der
	<acronym>ACPI</acronym>-Source-Language (<acronym>ASL</acronym>)
	&uuml;bersetzt und in einer Tabelle, der <acronym>DSDT</acronym>,
	abgelegt.  Eine Kopie der <acronym>ASL</acronym>
	k&ouml;nnen Sie mit dem Befehl &man.acpidump.8; erstellen.
	Verwenden Sie mit diesem Befehl sowohl die Option
	<option>-t</option> (die Inhalte der statischen
	Tabellen anzeigen) als auch die Option <option>-d</option>
	(die <acronym>AML</acronym> in <acronym>ASL</acronym>
	zur&uuml;ck&uuml;bersetzen).  Ein Beispiel f&uuml;r
	die Syntax finden Sie im Abschnitt <link
	linkend="ACPI-submitdebug">Fehlerberichte einreichen</link>.</para>

      <para>Sie k&ouml;nnen einfach pr&uuml;fen, ob sich die
	<acronym>ASL</acronym> &uuml;bersetzen l&auml;sst.
	F&uuml;r gew&ouml;hnlich k&ouml;nnen Sie Warnungen
	w&auml;hrend des &Uuml;bersetzens ignorieren.
	Fehlermeldungen f&uuml;hren normal dazu, dass
	<acronym>ACPI</acronym> fehlerhaft arbeitet.  Ihre
	<acronym>ASL</acronym> &uuml;bersetzen Sie mit dem
	nachstehenden Kommando:</para>

      <screen>&prompt.root; <userinput>iasl ihre.asl</userinput></screen>
    </sect2>

    <sect2 id="ACPI-fixasl">
      <title>Die <acronym>ASL</acronym> reparieren</title>

      <indexterm>
	<primary>ACPI</primary>
	<secondary>ASL</secondary>
      </indexterm>

      <para>Auf lange Sicht ist es unser Ziel, dass
	<acronym>ACPI</acronym> ohne Eingriffe des Benutzers
	l&auml;uft.  Zurzeit entwickeln wir allerdings noch
	Umgehungen f&uuml;r Fehler der <acronym>BIOS</acronym>-Hersteller.
	Der &microsoft;-Interpreter (<filename>acpi.sys</filename>
	und <filename>acpiec.sys</filename>) pr&uuml;ft die
	<acronym>ASL</acronym> nicht streng gegen den Standard.
	Daher reparieren <acronym>BIOS</acronym>-Hersteller,
	die <acronym>ACPI</acronym> nur unter &windows; testen,
	ihre <acronym>ASL</acronym> nicht.  Wir hoffen, dass
	wir das vom Standard abweichende Verhalten des
	&microsoft;-Interpreters dokumentieren und in &os; replizieren
	k&ouml;nnen.  Dadurch m&uuml;ssen Benutzer ihre
	<acronym>ASL</acronym> nicht selbst reparieren.
	Sie k&ouml;nnen Ihre <acronym>ASL</acronym> selbst reparieren,
	wenn Sie ein Problem umgehen und uns helfen m&ouml;chten.
	Senden Sie uns bitte die mit &man.diff.1; erstellte Differenz
	zwischen alter und neuer <acronym>ASL</acronym>.  Wir
	werden versuchen, den Interpreter <acronym>ACPI-CA</acronym>
	zu korrigieren, damit die Fehlerbehebung nicht mehr
	erforderlich ist.</para>

      <indexterm>
	<primary>ACPI</primary>
	<secondary>Fehlermeldungen</secondary>
      </indexterm>

      <para>Die nachfolgende Liste enth&auml;lt h&auml;ufige
	Fehlermeldungen, deren Ursache und eine Beschreibung,
	wie die Fehler korrigiert werden:</para>

      <sect3>
	<title>Abh&auml;ngigkeiten vom Betriebssystem</title>

	<para>Einige <acronym>AML</acronym>s gehen davon aus, dass
	  die Welt ausschlie&szlig;lich aus verschiedenen
	  &windows;-Versionen besteht.  &os; kann vorgeben, irgendein
	  Betriebssystem zu sein.  Versuchen Sie das Betriebssystem,
	  das Sie in der <acronym>ASL</acronym> finden, in der
	  Datei <filename>/boot/loader.conf</filename> anzugeben:
	  <literal>hw.acpi.osname="Windows 2001"</literal>.</para>
      </sect3>

      <sect3>
	<title>Fehlende Return-Anweisungen</title>

	<para>Einige Methoden verzichten auf die vom Standard
	  vorgeschriebene R&uuml;ckgabe eines Wertes.  Obwohl
	  der Interpreter <acronym>ACPI-CA</acronym> dies nicht
	  beheben kann, besitzt &os; die M&ouml;glichkeit, den
	  R&uuml;ckgabewert implizit zu setzen.  Wenn Sie
	  wissen, welcher Wert zur&uuml;ckgegeben werden muss,
	  k&ouml;nnen Sie die fehlenden Return-Anweisungen
	  selbst einsetzen.  Die Option <option>-f</option>
	  zwingt <command>iasl</command>, die <acronym>ASL</acronym>
	  zu &uuml;bersetzen.</para>
      </sect3>

      <sect3>
	<title>&Uuml;berschreiben der vorgegebenen
	  <acronym>AML</acronym></title>

	<para>Nachdem Sie Ihre <acronym>ASL</acronym> in der
	  Datei <filename>ihre.asl</filename> angepasst haben,
	  &uuml;bersetzen Sie die <acronym>ASL</acronym> wie folgt:</para>

	<screen>&prompt.root; <userinput>iasl ihre.asl</userinput></screen>

	<para>Mit der Option <option>-f</option> erzwingen Sie das
	  Erstellen der <acronym>AML</acronym> auch wenn w&auml;hrend
	  der &Uuml;bersetzung Fehler auftreten.  Beachten Sie,
	  dass einige Fehler, wie fehlende Return-Anweisungen,
	  automatisch vom Interpreter umgangen werden.</para>

	<para>In der Voreinstellung erstellt der Befehl
	  <command>iasl</command> die Ausgabedatei
	  <filename>DSDT.aml</filename>.  Wenn Sie diese Datei
	  anstelle der fehlerhaften Kopie des <acronym>BIOS</acronym>
	  laden wollen, editieren Sie <filename>/boot/loader.conf</filename>
	  wie folgt:</para>

	<programlisting>acpi_dsdt_load="YES"
acpi_dsdt_name="/boot/DSDT.aml"</programlisting>

	<para>Stellen Sie bitte sicher, dass sich die Datei
	  <filename>DSDT.aml</filename> im Verzeichnis
	  <filename class="directory">/boot</filename> befindet.</para>
      </sect3>
    </sect2>

    <sect2 id="ACPI-debugoutput">
      <title><acronym>ACPI</acronym>-Meldungen zur
	Fehlersuche erzeugen</title>

      <indexterm>
	<primary>ACPI</primary>
	<secondary>Probleme mit</secondary>
      </indexterm>

      <indexterm>
	<primary>ACPI</primary>
	<secondary>Fehlersuche</secondary>
      </indexterm>

      <para>Der <acronym>ACPI</acronym>-Treiber besitzt
	flexible M&ouml;glichkeiten zur Fehlersuche.  Sie
	k&ouml;nnen sowohl die zu untersuchenden Subsysteme
	als auch die zu erzeugenden Ausgaben festlegen.  Die zu
	untersuchenden Subsysteme werden als so genannte
	<quote>layers</quote> angegeben.  Die Subsysteme sind in
	<acronym>ACPI-CA</acronym>-Komponenten
	(<literal>ACPI_ALL_COMPONENTS</literal>) und
	<acronym>ACPI</acronym>-Hardware (<literal>ACPI_ALL_DRIVERS</literal>)
	aufgeteilt.  Welche Meldungen ausgegeben werden, wird &uuml;ber
	<quote>level</quote> gesteuert.  <quote>level</quote> reicht
	von <literal>ACPI_LV_ERROR</literal> (es werden nur Fehler
	ausgegeben) bis zu <literal>ACPI_LV_VERBOSE</literal> (alles
	wird ausgegeben).  <quote>level</quote> ist eine Bitmaske,
	sodass verschiedene Stufen auf einmal (durch Leerzeichen
	getrennt) angegeben werden k&ouml;nnen.  Die erzeugte
	Ausgabemenge passt vielleicht nicht in den Konsolenpuffer.
	In diesem Fall sollten Sie die Ausgaben mithilfe einer
	seriellen Konsole sichern.  Die m&ouml;glichen Werte
	f&uuml;r <quote>layers</quote> und <quote>level</quote>
	werden in der Hilfeseite &man.acpi.4; beschrieben.</para>

      <para>Die Ausgaben zur Fehlersuche sind in der Voreinstellung
	nicht aktiviert.  Wenn <acronym>ACPI</acronym> im Kernel
	enthalten ist, f&uuml;gen Sie <literal>options ACPI_DEBUG</literal>
	zur Kernelkonfigurationsdatei hinzu.  Sie k&ouml;nnen die
	Ausgaben zur Fehlersuche global aktivieren, indem Sie in der
	Datei <filename>/etc/make.conf</filename> die Zeile
	<literal>ACPI_DEBUG=1</literal> einf&uuml;gen.  Das Modul
	<filename>acpi.ko</filename> k&ouml;nnen Sie wie folgt
	neu &uuml;bersetzen:</para>

      <screen>&prompt.root; <userinput>cd /sys/modules/acpi/acpi
&amp;&amp; make clean &amp;&amp;
make ACPI_DEBUG=1</userinput></screen>

      <para>Installieren Sie anschlie&szlig;end
        <filename>acpi.ko</filename> im Verzeichnis
	<filename class="directory">/boot/kernel</filename>.
	In der Datei <filename>loader.conf</filename> stellen Sie
	<quote>level</quote> und <quote>layer</quote> ein.  Das
	folgende Beispiel aktiviert die Ausgabe von Fehlern f&uuml;r
	alle <acronym>ACPI-CA</acronym>-Komponenten und alle
	<acronym>ACPI</acronym>-Hardwaretreiber (wie
	<acronym>CPU</acronym>, <acronym>LID</acronym>):</para>

      <programlisting>debug.acpi.layer="ACPI_ALL_COMPONENTS ACPI_ALL_DRIVERS"
debug.acpi.level="ACPI_LV_ERROR"</programlisting>

      <para>Wenn ein Problem durch ein bestimmtes Ereignis,
	beispielsweise den Start nach einem Ruhezustand, hervorgerufen
	wird, k&ouml;nnen Sie die Einstellungen f&uuml;r
	<quote>level</quote> und <quote>layer</quote> auch mit dem
	Kommando <command>sysctl</command> vornehmen.  In diesem
	Fall m&uuml;ssen Sie die Datei <filename>loader.conf</filename>
	nicht editieren.  Auf der <command>sysctl</command>-Kommandozeile
	geben Sie dieselben Variablennamen wie in
	<filename>loader.conf</filename> an.</para>
    </sect2>

    <sect2 id="ACPI-References">
      <title>ACPI-Informationsquellen</title>

      <para>Weitere Informationen zu <acronym>ACPI</acronym>
	erhalten Sie an den folgenden Stellen:</para>

      <itemizedlist>
	<listitem>
	  <para>die &a.acpi; Mailingliste,</para>
	</listitem>

	<listitem>
	  <para>die Archive der <acronym>ACPI</acronym>-Mailingliste:
	    <ulink url="http://lists.FreeBSD.org/pipermail/freebsd-acpi/"></ulink>,</para>
	</listitem>

	<listitem>
	  <para>die alten Archive der <acronym>ACPI</acronym>-Mailingliste:
	    <ulink url="http://home.jp.FreeBSD.org/mail-list/acpi-jp/"></ulink>,</para>
	</listitem>

	<listitem>
	  <para>die <acronym>ACPI</acronym>-Spezifikation (Version 2.0):
	    <ulink url="http://acpi.info/spec.htm"></ulink>,</para>
	</listitem>

	<listitem>
	  <para>in den nachstehenden &os;-Hilfeseiten:
	     &man.acpi.4;, &man.acpi.thermal.4;, &man.acpidump.8;,
	    &man.iasl.8; und &man.acpidb.8;,</para>
	</listitem>

	<listitem>
	  <para><ulink
	    url="http://www.cpqlinux.com/acpi-howto.html#fix_broken_dsdt">
	    <acronym>DSDT</acronym> debugging resource</ulink>
	    (als Beispiel wird Compaq erl&auml;utert, die
	    Ressource ist aber dennoch n&uuml;tzlich).</para>
	</listitem>
      </itemizedlist>
    </sect2>
  </sect1>
</chapter>

<!--
     Local Variables:
     mode: sgml
     sgml-declaration: "../chapter.decl"
     sgml-indent-data: t
     sgml-omittag: nil
     sgml-always-quote-attributes: t
     sgml-parent-document: ("../book.sgml" "part" "chapter")
     End:
-->
