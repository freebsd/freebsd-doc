<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde: de-docproj/books/developers-handbook/dma/chapter.sgml,v 1.11 2009/02/15 14:17:12 jkois Exp $
     basiert auf: 1.6
-->

<chapter id="dma">
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Daniel</firstname>
	<surname>Seuffert</surname>
	<contrib>&Uuml;bersetzt von </contrib>
      </author>
    </authorgroup>
  </chapterinfo>

  <title>DMA</title>

  <sect1 id="dma-basics">
    <title>DMA: Was es ist und wie es funktioniert</title>

    <para><emphasis>Copyright &copy; 1995,1997 &a.uhclem;, Alle Rechte
      vorbehalten. 10. Dezember 1996. Letztes Update Oktober
      1997.</emphasis></para>

    <para>Direct Memory Access (DMA) ist eine Methode, die es erlaubt,
      Daten von einem Ort in einem Rechner an einen anderen ohne
      Eingriff des Prozessors (CPU) zu &uuml;bertragen.</para>

    <para>Die Art und Weise, in der die DMA-Funktion implementiert
      ist, variiert zwischen den Rechnerarchitekturen. Daher
      beschr&auml;nken wir uns im Folgenden ausschlie&szlig;lich auf die
      Methoden und Implementierungen auf IBM Personal Computer (PC),
      dem IBM PC/AT und all seinen Nachfolgern und Nachbauten.</para>

    <para>Das DMA-Subsystem basiert auf dem &intel; 8237
      DMA-Controller. Der 8237 enth&auml;lt vier DMA-Kan&auml;le,
      welche unabh&auml;ngig voneinander programmiert werden
      k&ouml;nnen, und jeder dieser Kan&auml;le kann zu einem
      beliebigen Zeitpunkt aktiv sein. Diese Kan&auml;le sind mit 0,
      1, 2 und 3 nummeriert. Beginnend mit dem PC/AT f&uuml;gte IBM
      einen zweiten 8237-Chip hinzu und nummerierte dessen Kan&auml;le
      mit 4, 5, 6 und 7.</para>

    <para>Der originale DMA-Controller (0, 1, 2 and 3) bewegt ein Byte
      bei jedem Transfer. Der zweite DMA-Controller (4, 5, 6, and 7)
      bewegt 16-Bits aus zwei benachbarten Speicherpl&auml;tzen bei
      jedem Transfer, wobei das erste Byte immer von einer
      geradzahligen Adresse stammt. Die zwei Controller sind
      identische Komponenten und der Unterschied in der
      Transfergr&ouml;&szlig;e wird durch die Art und Weise
      verursacht, wie der zweite Controller im System beschaltet
      ist.</para>

    <para>Der 8237 hat zwei elektrische Signale f&uuml;r jeden
      Kanal: DRQ und -DACK. Zus&auml;tzlich gibt es weitere Signale
      mit den Namen HRQ (Hold Request), HLDA (Hold Acknowledge), -EOP
      (End of Process) sowie die Kontrollsignale f&uuml;r den Bus:
      -MEMR (Memory Read), -MEMW (Memory Write), -IOR (I/O Read) und
      -IOW (I/O Write).</para>

    <para>Der 8237 DMA-Controller ist ein sogenannter
      <quote>fly-by</quote>-DMA-Controller. Das bedeutet, dass
      die von einem zu einem anderen Bereich bewegten Daten weder den
      DMA-Chip durchlaufen noch darin gespeichert werden. Daraus
      folgt, dass der DMA-Controller nur zwischen einem I/O-Port und
      einer Speicheradresse Daten bewegen kann, nicht zwischen zwei
      I/O-Ports oder zwei Speicherbereichen.</para>

    <note>
      <para>Der 8237 erlaubt es, dass zwei Kan&auml;le verbunden
	werden, um DMA-Operationen zwischen zwei Speicherbereichen in
	einem nicht-<quote>fly-by</quote>-Modus durchzuf&uuml;hren.
	Aber niemand in der PC-Industrie benutzt diese begrenzte
	Resource, da es schneller ist die Daten mittels der CPU
	zwischen Speicherbereichen zu bewegen.</para> </note>

    <para>In der PC-Architekur wird jeder DMA-Kanal normalerweise
      nur dann aktiviert, wenn die Hardware, welche einen gegebenen
      DMA-Kanal benutzt, einen Transfer durch Setzen der DRQ-Linie
      verlangt.</para>

    <sect2>
      <title>Beispiel eines DMA-Transfers</title>

      <para>Hier ist ein Beispiel f&uuml;r die notwendigen Schritte,
	welche einen DMA-Transfer veranlassen und durchf&uuml;hren.
	In diesem Beispiel hat der Diskettencontroller (floppy disk
	controller, FDC) nur ein Byte zu lesen und verlangt vom
	DMA-Controller dieses Byte im Speicher unter der Adresse
	0x00123456 abzulegen. Der Prozess beginnt damit, dass der
	FDC das DRQ2-Signal (die DRQ-Linie f&uuml;r DMA-Kanal 2)
	setzt, um den DMA-Controller zu alarmieren.</para>

      <para>Der DMA-Controller registriert, dass das DRQ2-Signal
	gesetzt ist. Der DMA-Controller stellt sicher, dass der
	DMA-Kanal 2 programmiert und unmaskiert (freigegeben) ist. Der
	DMA-Controller stellt gleichzeitig sicher, dass keiner
	der anderen DMA-Kan&auml;le aktiv ist oder aktiv sein
	m&ouml;chte und eine h&ouml;here Priorit&auml;ti hat. Sobald
	all diese &Uuml;berpr&uuml;fungen durchlaufen sind, fordert
	der DMA-Controller die CPU auf, den Bus freizugeben, damit der
	DMA-Controller ihn nutzen kann.  Diese Anforderung erfolgt
	durch Setzen des HRQ-Signals, welches zur CPU geht.</para>

      <para>Die CPU erkennt das HRQ-Signal und f&uuml;hrt den
	aktuellen Befehl komplett aus. Sobald die CPU den Bus
	freigeben kann, wird sie dies tun. Nun sind alle normalerweise
	von der CPU erzeugten Signale (-MEMR, -MEMW, -IOR, -IOW und
	ein paar andere) in einem Status mit einem dritten Zustand
	(weder hoch noch niedrig) und die CPU teilt dem DMA-Controller
	mittels des HLDA-Signals mit, dass er nun die Kontrolle
	&uuml;ber den Bus hat.</para>

      <para>Abh&auml;ngig vom Prozessor kann die CPU noch einige
	zus&auml;tzliche Befehle ausf&uuml;hren ohne die Kontrolle des
	Bus, aber letztendlich muss sie warten, wenn sie Befehle
	verarbeiten will, welche etwas aus dem Speicher lesen
	m&uuml;ssen, was nicht im internen Prozessor-Cache oder der
	Pipeline ist.</para>

      <para>Da der DMA-Controller nun <quote>verantwortlich
	ist</quote>, aktiviert er seine -MEMR, -MEMW, -IOR, -IOW
	Output-Signale und der Output des DMA-Controllers wird auf
	0x3456 gesetzt, damit das zu &uuml;bertragende Byte zu einem
	bestimmten Speicherbereich gelangt.</para>

      <para>Der DMA-Controller verst&auml;ndigt nun das Ger&auml;t,
	welches die Anforderung veranlasst hat, dass der Transfer
	beginnt. Dies geschieht durch Setzen des Signals -DACK oder im
	Fall des Diskettencontrollers durch -DACK2.</para>

      <para>Der Floppy-Controller ist nun daf&uuml;r verantwortlich
	das zu &uuml;bertragende Byte auf den Datenbahnen des Bus zu
	platziren. Sofern der Floppy-Controller nicht mehr Zeit
	braucht, um das Daten-Byte auf den Bus zu bringen (falls dies
	erforderlich ist benachrichtigt das Peripherieger&auml;t
	mittels READY-Signal den DMA-Controller), dann wird der
	DMA-Controller ein Zeitsignal warten und die Signale -MEMW und
	-IOR widerrufen, damit der Speicher das Byte auf dem Bus
	sperrt und speichert und der FDC wei&szlig;, dass das
	Byte &uuml;bertragen wurde.</para>

      <para>Da der DMA-Zyklus nur ein einzelnes Byte auf einmal
	&uuml;bertr&auml;gt, wird der FDC nun das Signal DRQ2
	deaktivieren und der DMA-Controller wei&szlig;, dass er
	nicht l&auml;nger ben&ouml;tigt wird. Der DMA-Controller setzt
	das -DACK2-Signal wieder und der FDC registriert, dass
	er aufh&ouml;ren muss Daten an den Bus zu senden.</para>

      <para>Der DMA-Controller wird nun &uuml;berpr&uuml;fen, ob
	andere DMA-Kan&auml;le irgendwelche Arbeiten bereithalten.
	Falls keiner der Kan&auml;le DRQ-Signale gesetzt hat,
	wei&szlig; der Controller, dass er seine Arbeit beendet
	hat und setzt -MEMR, -MEMW, -IOR, -IOW und die Adress-Signale
	auf den dritten Zustand.</para>

      <para>Abschliessend setzt der DMA-Controller wieder das
	HRQ-Signal. Die CPU registriert dies und entfernt das
	HOLDA-Signal wieder. Die CPU aktiviert nun ihre -MEMR, -MEMW,
	-IOR, -IOW und Adress-Ausg&auml;nge und f&auml;hrt mit der
	Verarbeitung von Befehlen und dem Zugriff auf Hauptspeicher
	und Peripherie fort.</para>

      <para>F&uuml;r einen typischen Sektor einer Diskette wird der
	obige Prozess 512 Mal wiederholt, einmal f&uuml;r jedes  Byte.
	Nach dem Transfer eines Byte wird jeweils das Adressregister
	im DMA-Controller erh&ouml;ht und der Z&auml;hler vermindert,
	welcher anzeigt, wieviel Bytes noch zu &uuml;bertragen
	sind.</para>

      <para>Sobald der Z&auml;hler Null erreicht hat, setzt der
	DMA-Controller das EOP-Signal, welches anzeigt, dass der
	Z&auml;hler Null erreicht hat und keine weiteren Daten zu
	&uuml;bertragen sind, bis der DMA-Controller wieder durch die
	CPU programmiert wird. Dieses Ereignis bezeichnet man als
	Terminal Count (TC). Es gibt nur ein EOP-Signal und da nur
	jeweils ein DMA-Kanal gleichzeitig aktiv sein kann, muss
	der aktive DMA-Kanal auch derjenige sein, welcher soeben seine
	Aufgabe beendet hat.</para>

      <para>Falls ein Peripherieger&auml;t einen Interrupt erzeugen
	will, wenn der Transfer eines Pufferspeichers beendet ist,
	dann kann es &uuml;berpr&uuml;fen, ob sein -DACK-Signal und
	EOP-Signal gleichzeitig anliegen. Falls dies zutrifft wird der
	DMA-Controller keine weiteren Informationen ohne Eingriff der
	CPU f&uuml;r dieses Peripherieger&auml;t &uuml;bertragen. Das
	Peripherieger&auml;t kann nun eines der Interrupt-Signale
	einf&uuml;gen, um die Aufmerksamkeit der CPU zu erlangen. In
	der PC-Architektur ist der DMA-Controller selbst nicht in der
	Lage Interrupts zu erzeugen. Das Peripherieger&auml;t und
	seine beigeordnete Hardware sind f&uuml;r die Erzeugung jedes
	Interrupts verantwortlich, welcher auftritt. In der Folge gibt
	es Peripherieger&auml;te, welche DMA nutzen aber keine
	Interrupts erzeugen.</para>

      <para>Es ist wichtig zu verstehen, dass obwohl die CPU
	jedesmal den Bus an den DMA-Controller freigibt, wenn dieser
	ihn anfordert, dieser Vorgang sowohl f&uuml;r das
	Betriebssystem als auch die Applikation unsichtbar ist - au&szlig;er
	bei kleinen &Auml;nderungen im Zeitbedarf des Prozessors beim
	Ausf&uuml;hren von Befehlen, wenn der DMA-Controller aktiv
	ist. Folglich muss der Prozessor die
	Peripherieger&auml;te und die Register im DMA-Chip
	st&auml;ndig abfragen oder einen Interrupt von einem
	Peripherieger&auml;t empfangen, um sicher zu sein, dass
	ein bestimmter DMA-Transfer beendet wurde.</para>
    </sect2>

    <sect2>
      <title>DMA-Seitenregister und 16
	Megabyte-Adressraumbeschr&auml;nkungen</title>

      <para>Sie haben vielleicht vorhin bemerkt, dass der
	DMA-Controller die Adress-Linien nicht auf 0x00123456 gesetzt
	hat, wie wir angaben, sondern auf 0x3456. Der Grund
	hierf&uuml;r erfordert ein wenig Erkl&auml;rung.</para>

      <para>Als der originale IBM PC entworfen wurde hat IBM
	entschieden sowohl DMA als auch Interrupt-Controller
	einzusetzen, welche f&uuml;r den 8085 entwickelt worden waren,
	einen 8 Bit-Prozessor mit einem Adressraum von 16 Bit (64K).
	Da der IBM PC mehr als 64K unterst&uuml;tzte, musste etwas
	geschehen, damit der DMA-Controller Adressbereiche oberhalb
	der 64K-Grenze auslesen und beschreiben konnte. IBM
	f&uuml;hrte einen zus&auml;tzlichen, externen Signalspeicher
	f&uuml;r jeden DMA-Kanal ein, welcher die oberen Bits einer
	Adresse enth&auml;lt, welche ausgelesen oder beschrieben
	werden soll. Immer wenn ein DMA-Controller aktiv ist, wird der
	Inhalt dieses Signalspeichers cwauf denzum Adress-Bus
	geschrieben und dort gehalten, bis die DMA-Operation f&uuml;r
	diesen Kanal beendet ist. IBM nannte diese zus&auml;tzlichen
	Signalspeicher <quote>Seitenregister</quote> (Page
	Register).</para>

      <para>F&uuml;r das obige Beispiel w&uuml;rde der DMA-Controller also den
	0x3456-Teil der Adresse auf den Bus setzen und das Seitenregister
	f&uuml;r den DMA-Kanal 2 w&uuml;rde dem Bus 0x0012xxxx hinzuf&uuml;gen.
	Zusammen bilden beide Werte die komplette Speicheradresse, auf die
	zugegriffen werden soll.</para>

      <para>Da das Seitenregister unabh&auml;ngig vom DMA-Chip ist,
	darf der zu lesende oder zu schreibende Speicherbereich die
	64K-Grenze nicht &uuml;berschreiten. Wenn der DMA-Controller
	beispielsweise auf die Speicheradresse 0xffff zugreift, dann
	wird der Controller nach dem Transfer das Adress-Register
	erh&ouml;hen und auf das n&auml;chste Byte an der Adresse
	0x0000, nicht 0x10000, zugreifen. Dieses Zuzulassen ist
	wahrscheinlich nicht beabsichtigt.</para>

      <note>
	<para><quote>Physikalische</quote> 64K-Grenzen sollten nicht
	  mit 8086-Modus 64K-<quote>Segmenten</quote> verwechselt
	  werden, welche durch mathematisches Addieren eines
	  Segment-Registers an ein Offset-Register erzeugt werden.
	  Seitenregister haben keinen Adress&uuml;berhang und werden
	  imathematisch durch ein OR zusammengef&uuml;gt.</para>
      </note>

      <para>Um die Angelegenheit noch komplizierter zu machen, weisen
	die externen DMA-Signalspeicher auf dem PC/AT nur 8 Bytes auf,
	also 8+16 = 24 Bits. Dies bedeutet, dass der
	DMA-Controller nur auf Speicherbereiche zwischen 0 und 16
	Megabyte zeigen kann. F&uuml;r neuere Rechner, die mehr als 16
	Megabyte an Speicher aufweisen, kann der Standard
	PC-kompatible DMA-Controller keine Speicherbereiche oberhalb
	von 16 Megabyte adressieren.</para>

      <para>Um diese Beschr&auml;nkung zu umgehen reservieren
	Betriebssysteme einen RAM-Puffer in einem Bereich unterhalb
	von 16 Megabyte, der au&szlig;erdem einen physisch begrenzten
	Bereich von 64K nicht &uuml;berschreitet. Dann wird der
	DMA-Controller so programmiert, dass er Daten vom
	Peripherieger&auml;t in diesen Puffer &uuml;bertr&auml;gt.
	Sobald der DMA-Controller die Daten in den Puffer
	&uuml;bertragen hat, wird das Betriebssystem sie in den
	Bereich &uuml;bertragen, an dem sie wirklich gespeichert
	werden sollen.</para>

      <para>Beim Schreiben von Daten von Adressen oberhalb von 16
	Megabyte an ein DMA-basiertes Peripherieger&auml;t m&uuml;ssen
	die Daten zuerst von dort, wo sie liegen, in einen Puffer
	unterhalb von 16 Megabyte geschrieben werden und dann kann der
	DMA-Controller die Daten vom Puffer auf die Peripherie
	kopieren. In FreeBSD werden diese reservierten Puffer
	<quote>Bounce Buffers</quote> genannt. In der &ms-dos;-Welt
	werden sie manchmal als <quote>Smart Buffers</quote>
	bezeichnet.</para>

      <note>
	<para>Eine neuere Ausf&uuml;hrung des 8237, 82374 genannt,
	  weist 16 Bit-Seitenregister auf und erlaubt Zugriff auf den
	  gesamten 32 Bit Adressraum ohne Zuhilfenahme von Bounce
	  Buffers.</para>
      </note>
    </sect2>

    <sect2>
      <title>DMA-Operationsmodi und Einstellungen</title>

      <para>Der 8237 DMA-Controller kann in verschiedenen Modi
	betrieben werden. Die Wichtigsten sind:</para>

      <variablelist>
	<varlistentry>
	  <term>Single</term>

	  <listitem>
	    <para>Ein einziges Byte (oder Wort) wird &uuml;bertragen.
	      Der DMA-Controller muss f&uuml;r jedes
	      zus&auml;tzliche Byte den Bus freigeben und neu
	      anfordern. Dieser Modus wird normalerweise von
	      Ger&auml;ten benutzt, welche nicht einen gesamten Block
	      von Daten auf einmal &uuml;bertragen k&ouml;nnen. Das
	      Peripherieger&auml;t wird den DMA-Controller jedesmal
	      anfordern, wenn es f&uuml;r einen weiteren Transfer
	      bereit ist.</para>

	    <para>Der Standard PC-kompatible Floppy-Controller (NEC
	      765) hat nur einen Puffer mit einem Byte, daher nutzt er
	      diesen Modus.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>Block/Demand</term>

	  <listitem>
	    <para>Sobald der DMA-Controller den Bus &uuml;bernommen
	      hat, wird ein ganzer Block von Daten &uuml;bertragen bis
	      zu einem Maximum von 64K. Wenn das Peripherieger&auml;t
	      zus&auml;tzliche Zeit ben&ouml;tigt, kann es das
	      READY-Signal setzen, um den Transfer kurzfristig zu
	      unterbrechen. READY sollte nicht exzessiv benutzt werden
	      und f&uuml;r langsame Peripherieger&auml;te sollte
	      stattdessen der Single Transfer-Modus genutzt
	      werden.</para>

	    <para>Der Unterschied zwischen Block und Demand ist,
	      dass sobald ein Block-Transfer gestartet ist,
	      dieser solange l&auml;uft, bis der Transfer-Z&auml;hler
	      Null erreicht. DRQ muss nur gesetzt werden, bis
	      -DACK gesetzt wird. Der Demand-Modus &uuml;bertr&auml;gt
	      ein weiteres Byte, bis DRQ gel&ouml;scht wird. An diesem
	      Punkt unterbricht der DMA-Controller die
	      &Uuml;bertragung und gibt den Bus wieder an die CPU
	      zur&uuml;ck. Wenn DRQ wieder eingesetzt wird geht der
	      Transfer an der Stelle weiter, an welcher er
	      unterbrochen wurde.</para>

	    <para>&Auml;ltere Festplattencontroller benutzten den
	      Demand-Modus bis die CPU-Geschwindigkeiten stiegen,
	      sodass der Transfer mittels CPU schneller war,
	      insbesondere wenn die benutzten Speicherbereiche
	      jenseits der 16 Megabyte-Marke lagen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>Cascade</term>

	  <listitem>
	    <para>Dieser Mechanismus erlaubt einem DMA-Kanal den Bus
	      anzufordern, wobei dann aber das zugeh&ouml;rige
	      Peripherieger&auml;t daf&uuml;r verantwortlich ist die
	      Adressinformationen an den Bus zu senden anstatt des
	      DMA-Controllers. Dies wird auch dazu genutzt, um eine
	      Technik zu implementieren, die man als <quote>Bus
	      Mastering</quote> bezeichnet.</para>

	    <para>Wenn ein DMA-Kanal im Cascade-Modus Kontrolle
	      &uuml;ber den Bus erlangt, dann stellt der Controller
	      nicht die Adressen und I/O-Kontrollsignale auf den Bus,
	      wie es normalerweise der Fall ist. Stattdessen setzt der
	      Controller nur das -DACK-Signal f&uuml;r den aktiven
	      DMA-Kanal.</para>

	    <para>Nun ist es Aufgabe Peripherieger&auml;tes, welches
	      mit diesem DMA-Kanal verbunden ist, die Adressen und
	      Bus-Kontrollsignale zu liefern. Das Peripherieger&auml;t
	      hat vollst&auml;ndige Kontrolle &uuml;ber den Bus und
	      kann Lese- oder Schreibvorg&auml;nge an jeder Adresse
	      unterhalb von 16 Megabyte ausf&uuml;hren. Wenn es fertig
	      ist, setzt es das DRQ-Signal und der DMA-Controller kann
	      die Kontrolle an die CPU oder einen anderen DMA-Kanal
	      &uuml;bergeben.</para>

	    <para>Der Cascade-Modus kann verwendet werden, um mehrere
	      DMA-Controller in Reihe zu schalten und genau daf&uuml;r
	      wird der DMA-Kanal 4 in der PC-Architektur genutzt. Wenn
	      ein Peripherieger&auml;t den Bus auf den
	      DMA-Kan&auml;len 0, 1, 2 oder 3 verlangt, dann setzt der
	      abh&auml;ngige DMA-Controller (slave DMA) HLDREQ, aber
	      dieses Signal ist in Wirklichkeit verbunden mit DRQ4 auf
	      dem prim&auml;ren DMA-Controller anstatt mit der CPU.
	      Der prim&auml;re DMA-Controller nimmt an, er habe Arbeit
	      zu leisten auf Kanal 4, und fordert den Bus an von der
	      CPU mit dem HLDREQ-Signal. Sobald die CPU die Kontrolle
	      des Bus an den prim&auml;ren DMA-Controller
	      &uuml;bergeben hat, wird -DACK4 gesetzt und dieser Kanal
	      ist in Wirklichkeit mit dem abh&auml;ngigen
	      DMA-Controller &uuml;ber das HDLA-Signal verbunden. Der
	      abh&auml;ngige Controller &uuml;bertr&auml;gt dann die
	      Daten f&uuml;r den DMA-Kanal, der die Anforderung
	      gestellt hat (0, 1, 2 oder 3) oder der Controller
	      &uuml;bergibt den Bus an ein Peripherieger&auml;t,
	      welches selbst ein eigenes Bus-Mastering
	      durchf&uuml;hren will, z.B. einen
	      SCSI-Controller.</para>

	    <para>Wegen dieser Schaltungsanordnung k&ouml;nnen auf
	      PC/AT-Systemen nur die DMA-Kan&auml;le 0, 1, 2, 3, 5, 6
	      und 7 mit Peripherieger&auml;ten genutzt werden.</para>

	    <note>
	      <para>Der DMA-Kanal 0 war auf fr&uuml;hen IBM PCs
		f&uuml;r Auffrischungs-Operationen reserviert, aber
		auf modernen Rechnern ist er allgemein f&uuml;r
		Peripherieger&auml;te verf&uuml;gbar.</para>
	    </note>

	    <para>Wenn ein Peripherieger&auml;t Bus Mastering
	      durchf&uuml;hrt, ist es wichtig, dass es konstant
	      Daten vom oder zum Speicher &uuml;bertr&auml;gt, solange
	      es die Kontrolle &uuml;ber den Bus h&auml;lt. Falls das
	      Peripherieger&auml;t dies nicht kann, muss es den
	      Bus h&auml;ufig freigeben, damit das System
	      Auffrischungsoperationen am Hauptspeicher vornehmen
	      kann.</para>

	    <para>Das dynamische RAM als Hauptspeicher in allen PCs
	      muss regelm&auml;&szlig;ig aufgefrischt werden, damit
	      die gespeicherten Bits <quote>geladen</quote> gehalten
	      werden. Dynamisches Ram besteht aus Millionen von
	      Transistoren, die jedes ein Bit Daten enthalten. Die
	      Transistoren sind geladen, um <literal>1</literal>
	      darzustellen, oder entladen, um <literal>0</literal> zu
	      repr&auml;sentieren. Da alle Transistoren Ladung
	      abgeben, muss in regelm&auml;&szlig;igen Abst&auml;nden
	      der Ladungsinhalt aufgefrischt werden durch
	      Wiederbeschreibung, um den Wert <literal>1</literal> zu
	      erhalten. Die RAM-Chips &uuml;bernehmen diese Aufgabe
	      selbst, aber sie m&uuml;ssen dazu vom Rest des Rechners
	      angewiesen werden, damit die
	      Auffrischungsaktivit&auml;ten nicht mit den normalen
	      Zugriffen auf das RAM kollidieren. Falls der Rechner
	      das RAM nicht auffrischen kann wird der Inhalt des
	      Speichers binnen weniger Millisekunden
	      besch&auml;digt.</para>

	    <para>Da Lese- und Schreibzyklen als Auffrischungszyklen
	      <quote>z&auml;hlen</quote> (ein Auffrischungszyklus
	      eines dynamischen RAM ist in Wirklichkeit ein
	      unvollst&auml;ndiger Lesezyklus), wird diese Aktion den
	      gesamten Speicher auffrischen, solange der
	      abh&auml;ngige Controller fortf&auml;hrt Daten an
	      aufeinander folgenden Speicherbereiche zu lesen oder
	      dorthin zu schreiben.</para>

	    <para>Bus-Mastering findet man in einigen SCSI-Controllern
	      und anderen hochwertigen Peripherie-Controllern.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>Autoinitialize</term>

	  <listitem>
	    <para>Dieser Modus veranlasst den DMA-Controller dazu
	      Byte-, Block- oder Demand-Transfers auszuf&uuml;hren.
	      Aber wenn der DMA-&Uuml;bertragungsz&auml;hler Null
	      erreicht hat, dann werden die Z&auml;hler und Adressen
	      wieder auf den Wert zur&uuml;ckgesetzt, den sie
	      aufwiesen, als der DMA-Kanal urspr&uuml;nglich
	      programmiert wurde. Das bedeutet, dass
	      Transfers zugelassen werden, solange das
	      Peripherieger&auml;t sie anfordert. Es ist Aufgabe der
	      CPU neue Daten rechtzeitig in den Puffer zu schicken,
	      damit das Peripherieger&auml;t sie schreiben kann bzw.
	      die neuen Daten aus dem Puffer zu lesen, wenn der
	      DMA-Controller bei Eingabeoperationen Daten
	      schreibt.</para>

	    <para>Diese Technik wird h&auml;ufig bei Audioger&auml;ten
	      genutzt, die kleine oder gar keine
	      <quote>Sample</quote>-Puffer in Hardware aufweisen.
	      Dadurch entsteht zus&auml;tzlicher CPU-Overhead bei der
	      Verwaltung dieses <quote>zirkul&auml;ren</quote>
	      Puffers, aber in manchen F&auml;llen ist es der einzige
	      Weg, um die Latenz zu beseitigen, die auftritt, wenn der
	      DMA-Z&auml;hler Null erreicht und der DMA-Controller mit
	      den Transfers anh&auml;lt, bis er neu programmiert
	      ist.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2>
      <title>Das Programmieren des DMA-Controllers</title>

      <para>Der zu programmierende DMA-Kanal sollte immer
	<quote>maskiert</quote> werden, bevor irgendwelche
	Einstellungen geladen werden. Dies soll deswegen geschehen,
	weil die Hardware unerwarteterweise DRQ f&uuml;r diesen Kanal
	setzen k&ouml;nnte und der Controller k&ouml;nnte antworten,
	obwohl noch nicht alle Parameter geladen oder aktualisiert
	wurden.</para>

      <para>Nach der Maskierung muss der Host die Richtung des
	Transfers festlegen (Speicher-zu-I/O oder I/O-zu-Speicher),
	welcher DMA-Modus f&uuml;r den Transfer genutzt wird (Single,
	Block, Demand, Cascade, etc.) und schlie&szlig;lich werden die
	Adresse und die L&auml;nge des Transfers geladen. Die
	L&auml;nge ist um 1 kleiner als die durch den DMA-Controller
	zu &uuml;bertragende. Das LSB und das MSB der Adresse und der
	L&auml;nge werden auf den gleichen 8 Bit I/O-Port geschrieben,
	also muss zun&auml;chst ein anderer Port geschrieben
	werden, um zu gew&auml;hrleisten, dass der DMA-Controller
	das erste Byte als LSB und das zweite Byte als MSB der
	L&auml;nge und der Adresse akzeptiert.</para>

      <para>Stellen Sie dann sicher, dass Sie das Seitenregister
	aktualisiert haben, welches extern zum DMA-Controller ist und
	durch ein anderes Set von I/O-Ports angesprochen wird.</para>

      <para>Sobald alle Einstellungen fertig sind, kann der DMA-Kanal
	demaskiert werden. Dieser Kanal wird nun als
	<quote>gesch&uuml;tzt</quote> betrachtet und wird antworten,
	wenn die DRQ-Linie f&uuml;r diesen Kanal gesetzt wird.</para>

      <para>Schlagen Sie im Hardware Handbuch f&uuml;r
	ausf&uuml;hrliche Programmierdetails zum 8237 nach. Sie werden
	auch auf die I/O-Port&uuml;bersicht f&uuml;r den PC
	zur&uuml;ckgreifen m&uuml;, welches beschreibt, wo die
	DMA-Register und Seitenregister sich befinden. Eine
	vollst&auml;ndige Tabelle der Ports finden Sie unten.</para>
    </sect2>

    <sect2>
      <title>DMA Port-&Uuml;bersicht</title>

      <para>Alle Systeme, die auf dem IBM-PC und PC/AT basieren, weisen
	die gleiche DMA-Hardware an identischen I/O-Ports auf. Die
	vollst&auml;ndige Liste ist unten aufgef&uuml;hrt. Dem
	DMA-Controller #2 zugewiesene Ports sind auf
	nicht-AT-Systemeni undefiniert.</para>

      <sect3>
	<title>0x00&ndash;0x1f DMA-Controller #1 (Kan&auml;le 0, 1, 2
	  und 3)</title>

	<para>DMA-Adressregister und -Z&auml;hlregister</para>

	<informaltable frame="none" pgwide="1">
	  <tgroup cols="3">
	    <tbody>
	      <row>
		<entry>0x00</entry>
		<entry>write</entry>
		<entry>Kanal 0 Startadresse</entry>
	      </row>

	      <row>
		<entry>0x00</entry>
		<entry>read</entry>
		<entry>Kanal 0 gegenw&auml;rtige Adresse</entry>
	      </row>

	      <row>
		<entry>0x01</entry>
		<entry>write</entry>
		<entry>Kanal 0 Anfangs-Wortnummer</entry>
	      </row>

	      <row>
		<entry>0x01</entry>
		<entry>read</entry>
		<entry>Kanal 0 verbleibende Wortzahl</entry>
	      </row>

	      <row>
		<entry>0x02</entry>
		<entry>write</entry>
		<entry>Kanal 1 Startadresse</entry>
	      </row>

	      <row>
		<entry>0x02</entry>
		<entry>read</entry>
		<entry>Kanal 1 gegenw&auml;rtige Adresse</entry>
	      </row>

	      <row>
		<entry>0x03</entry>
		<entry>write</entry>
		<entry>Kanal 1 Anfangs-Wortnummer</entry>
	      </row>

	      <row>
		<entry>0x03</entry>
		<entry>read</entry>
		<entry>Kanal 1 verbleibende Wortzahl</entry>
	      </row>

	      <row>
		<entry>0x04</entry>
		<entry>write</entry>
		<entry>Kanal 2 Startadresse</entry>
	      </row>

	      <row>
		<entry>0x04</entry>
		<entry>read</entry>
		<entry>Kanal 2 gegenw&auml;rtige Adresse</entry>
	      </row>

	      <row>
		<entry>0x05</entry>
		<entry>write</entry>
		<entry>Kanal 2 Anfangs-Wortnummer</entry>
	      </row>

	      <row>
		<entry>0x05</entry>
		<entry>read</entry>
		<entry>Kanal 2 verbleibende Wortzahl</entry>
	      </row>

	      <row>
		<entry>0x06</entry>
		<entry>write</entry>
		<entry>Kanal 3 Startadresse</entry>
	      </row>

	      <row>
		<entry>0x06</entry>
		<entry>read</entry>
		<entry>Kanal 3 gegenw&auml;rtige Adresse</entry>
	      </row>

	      <row>
		<entry>0x07</entry>
		<entry>write</entry>
		<entry>Kanal 3 Anfangs-Wortnummer</entry>
	      </row>

	      <row>
		<entry>0x07</entry>
		<entry>read</entry>
		<entry>Kanal 3 verbleibende Wortzahl</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

	<para>DMA-Befehlsregister</para>

	<informaltable frame="none" pgwide="1">
	  <tgroup cols="3">
	    <tbody>
	      <row>
		<entry>0x08</entry>
		<entry>write</entry>
		<entry>Befehlsregister</entry>
	      </row>

	      <row>
		<entry>0x08</entry>
		<entry>read</entry>
		<entry>Status-Register</entry>
	      </row>

	      <row>
		<entry>0x09</entry>
		<entry>write</entry>
		<entry>Anforderungsregister</entry>
	      </row>

	      <row>
		<entry>0x09</entry>
		<entry>read</entry>
		<entry>-</entry>
	      </row>

	      <row>
		<entry>0x0a</entry>
		<entry>write</entry>
		<entry>Single Mask Register Bit</entry>
	      </row>

	      <row>
		<entry>0x0a</entry>
		<entry>read</entry>
		<entry>-</entry>
	      </row>

	      <row>
		<entry>0x0b</entry>
		<entry>write</entry>
		<entry>Modusregister</entry>
	      </row>

	      <row>
		<entry>0x0b</entry>
		<entry>read</entry>
		<entry>-</entry>
	      </row>

	      <row>
		<entry>0x0c</entry>
		<entry>write</entry>
		<entry>Flip-Flop zm L&ouml;schen des LSB/MSB</entry>
	      </row>

	      <row>
		<entry>0x0c</entry>
		<entry>read</entry>
		<entry>-</entry>
	      </row>

	      <row>
		<entry>0x0d</entry>
		<entry>write</entry>
		<entry>Master Clear/Reset</entry>
	      </row>

	      <row>
		<entry>0x0d</entry>
		<entry>read</entry>
		<entry>Tempor&auml;res Register (in neueren Versionen
		  nicht verf&uuml;gbar).</entry>
	      </row>

	      <row>
		<entry>0x0e</entry>
		<entry>write</entry>
		<entry>L&auml;sche Mask-Register</entry>
	      </row>

	      <row>
		<entry>0x0e</entry>
		<entry>read</entry>
		<entry>-</entry>
	      </row>

	      <row>
		<entry>0x0f</entry>
		<entry>write</entry>
		<entry>Schreibe alle Mask-Register-Bits</entry>
	      </row>

	      <row>
		<entry>0x0f</entry>
		<entry>read</entry>
		<entry>Lese alle Mask-Register-Bits (nur auf &intel;
	      82374)</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </sect3>

      <sect3>
	<title>0xc0&ndash;0xdf DMA-Controller #2 (Kan&auml;le 4, 5, 6 und
	  7)</title>

	<para>DMA-Adressregister und -Z&auml;hlregister</para>

	<informaltable frame="none" pgwide="1">
	  <tgroup cols="3">
	    <tbody>
	      <row>
		<entry>0xc0</entry>
		<entry>write</entry>
		<entry>Kanal 4 Startadresse</entry>
	      </row>

	      <row>
		<entry>0xc0</entry>
		<entry>read</entry>
		<entry>Kanal 4 gegenw&auml;rtige Adresse</entry>
	      </row>

	      <row>
		<entry>0xc2</entry>
		<entry>write</entry>
		<entry>Kanal 4 Anfangs-Wortnummer</entry>
	      </row>

	      <row>
		<entry>0xc2</entry>
		<entry>read</entry>
		<entry>Kanal 4 verbleibende Wortzahl</entry>
	      </row>

	      <row>
		<entry>0xc4</entry>
		<entry>write</entry>
		<entry>Kanal 5 Startadresse</entry>
	      </row>

	      <row>
		<entry>0xc4</entry>
		<entry>read</entry>
		<entry>Kanal 5 gegenw&auml;rtige Adresse</entry>
	      </row>

	      <row>
		<entry>0xc6</entry>
		<entry>write</entry>
		<entry>Kanal 5 Anfangs-Wortnummer</entry>
	      </row>

	      <row>
		<entry>0xc6</entry>
		<entry>read</entry>
		<entry>Kanal 5 verbleibende Wortzahl</entry>
	      </row>

	      <row>
		<entry>0xc8</entry>
		<entry>write</entry>
		<entry>Kanal 6 Startadresse</entry>
	      </row>

	      <row>
		<entry>0xc8</entry>
		<entry>read</entry>
		<entry>Kanal 6 gegenw&auml;rtige Adresse</entry>
	      </row>

	      <row>
		<entry>0xca</entry>
		<entry>write</entry>
		<entry>Kanal 6 Anfangs-Wortnummer</entry>
	      </row>

	      <row>
		<entry>0xca</entry>
		<entry>read</entry>
		<entry>Kanal 6 verbleibende Wortzahl</entry>
	      </row>

	      <row>
		<entry>0xcc</entry>
		<entry>write</entry>
		<entry>Kanal 7 Startadresse</entry>
	      </row>

	      <row>
		<entry>0xcc</entry>
		<entry>read</entry>
		<entry>Kanal 7 gegenw&auml;rtige Adresse</entry>
	      </row>

	      <row>
		<entry>0xce</entry>
		<entry>write</entry>
		<entry>Kanal 7 Anfangs-Wortnummer</entry>
	      </row>

	      <row>
		<entry>0xce</entry>
		<entry>read</entry>
		<entry>Kanal 7 verbleibende Wortzahl</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>

	<para>DMA-Befehlsregister</para>

	<informaltable frame="none" pgwide="1">
	  <tgroup cols="3">
	    <tbody>
	      <row>
		<entry>0xd0</entry>
		<entry>write</entry>
		<entry>Befehlsregister</entry>
	      </row>

	      <row>
		<entry>0xd0</entry>
		<entry>read</entry>
		<entry>Status-Register</entry>
	      </row>

	      <row>
		<entry>0xd2</entry>
		<entry>write</entry>
		<entry>Anforderungsregister</entry>
	      </row>

	      <row>
		<entry>0xd2</entry>
		<entry>read</entry>
		<entry>-</entry>
	      </row>

	      <row>
		<entry>0xd4</entry>
		<entry>write</entry>
		<entry>Single Mask Register Bit</entry>
	      </row>

	      <row>
		<entry>0xd4</entry>
		<entry>read</entry>
		<entry>-</entry>
	      </row>

	      <row>
		<entry>0xd6</entry>
		<entry>write</entry>
		<entry>Modusregister</entry>
	      </row>

	      <row>
		<entry>0xd6</entry>
		<entry>read</entry>
		<entry>-</entry>
	      </row>

	      <row>
		<entry>0xd8</entry>
		<entry>write</entry>
		<entry>Flip-Flop zum L&ouml;schen des LSB/MSB</entry>
	      </row>

	      <row>
		<entry>0xd8</entry>
		<entry>read</entry>
		<entry>-</entry>
	      </row>

	      <row>
		<entry>0xda</entry>
		<entry>write</entry>
		<entry>Master Clear/Reset</entry>
	      </row>

	      <row>
		<entry>0xda</entry>
		<entry>read</entry>
		<entry>tempor&auml;res Register (nicht verf&uuml;gbar
		  auf &intel; 82374)</entry>
	      </row>

	      <row>
		<entry>0xdc</entry>
		<entry>write</entry>
		<entry>L&ouml;sche Mask-Register</entry>
	      </row>

	      <row>
		<entry>0xdc</entry>
		<entry>read</entry>
		<entry>-</entry>
	      </row>

	      <row>
		<entry>0xde</entry>
		<entry>write</entry>
		<entry>Schreibe alle Mask-Register-Bits</entry>
	      </row>

	      <row>
		<entry>0xdf</entry>
		<entry>read</entry>
		<entry>Lese alle Mask-Register-Bits (nur auf &intel;
		  82374)</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </sect3>

      <sect3>
	<title>0x80&ndash;0x9f DMA-Seitenregister</title>

	<informaltable frame="none" pgwide="1">
	  <tgroup cols="3">
	    <tbody>
	      <row>
		<entry>0x87</entry>
		<entry>r/w</entry>
		<entry>Kanal 0 niederes Byte (23-16)
		  Seitenregister</entry>
	      </row>

	      <row>
		<entry>0x83</entry>
		<entry>r/w</entry>
		<entry>Kanal 1 niederes Byte (23-16)
		  Seitenregister</entry>
	      </row>

	      <row>
		<entry>0x81</entry>
		<entry>r/w</entry>
		<entry>Kanal 2 niederes Byte (23-16)
		  Seitenregister</entry>
	      </row>

	      <row>
		<entry>0x82</entry>
		<entry>r/w</entry>
		<entry>Kanal 3 niederes Byte (23-16)
		  Seitenregister</entry>
	      </row>

	      <row>
		<entry>0x8b</entry>
		<entry>r/w</entry>
		<entry>Kanal 5 niederes Byte (23-16)
		  Seitenregister</entry>
	      </row>

	      <row>
		<entry>0x89</entry>
		<entry>r/w</entry>
		<entry>Kanal 6 niederes Byte (23-16)
		  Seitenregister</entry>
	      </row>

	      <row>
		<entry>0x8a</entry>
		<entry>r/w</entry>
		<entry>Kanal 7 niederes Byte (23-16)
		  Seitenregister</entry>
	      </row>

	      <row>
		<entry>0x8f</entry>
		<entry>r/w</entry>
		<entry>niederes Byte Seitenauffrischung</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </sect3>

      <sect3>
	<title>0x400&ndash;0x4ff 82374 Erweiterte DMA-Register</title>

	<para>Die &intel; 82374 EISA-System-Komponente (EISA System
	  Component ESC) wurde Anfang 1996 eingef&uuml;hrt und
	  beinhaltet einen DMA-Controller, der die Funktionen des 8237
	  und zus&auml;tzlich andere PC-kompatible
	  Kern-Peripheriekomponenten in einer einzigen Komponente
	  vereint. Dieser Chip wurde f&uuml;r EISA und PCI-Plattformen
	  entworfen und stellt moderne DMA-Funktionen wie
	  Scatter-Gather, Ring-Puffer und direkten Zugriff des
	  DMA-Controllers auf alle 32 Bit des Adressraumes zur
	  Verf&uuml;gung.</para>

	<para>Werden diese Leistungsmerkmale genutzt, dann sollte Code
	  hinzugef&uuml;gt werden, der die gleiche Funktionalit&auml;t
	  f&uuml;r Ger&auml;te aus den 16 Jahren PC-kompatibler
	  Ger&auml;te vor diesem Chip zur Verf&uuml;gung stellt. Aus
	  Kompatibilit&auml;tsgr&uuml;nden m&uuml;ssen einige der
	  Register des 82374 programmiert werden
	  <emphasis>nachdem</emphasis> die traditionellen Register des
	  8237 f&uuml;r jeden Transfer programmiert wurden. Das
	  Schreiben in eines der traditionellen 8237-Register
	  f&uuml;hrt dazu, dass einige der erweiterten Register
	  des 82374 aus Kompatibilit&auml;tsgr&uuml;nden auf Null
	  gesetzt werden.</para>

	<informaltable frame="none" pgwide="1">
	  <tgroup cols="3">
	    <tbody>
	      <row>
		<entry>0x401</entry>
		<entry>r/w</entry>
		<entry>Kanal 0 hohes Byte (Bits 23-16)
		  Word-Z&auml;hler</entry>
	      </row>

	      <row>
		<entry>0x403</entry>
		<entry>r/w</entry>
		<entry>Kanal 1 hohes Byte (Bits 23-16)
		  Word-Z&auml;hler</entry>
	      </row>

	      <row>
		<entry>0x405</entry>
		<entry>r/w</entry>
		<entry>Kanal 2 hohes Byte (Bits 23-16)
		  Word-Z&auml;hler</entry>
	      </row>

	      <row>
		<entry>0x407</entry>
		<entry>r/w</entry>
		<entry>Kanal 3 hohes Byte (Bits 23-16)
		  Word-Z&auml;hler</entry>
	      </row>

	      <row>
		<entry>0x4c6</entry>
		<entry>r/w</entry>
		<entry>Kanal 5 hohes Byte (Bits 23-16)
		  Word-Z&auml;hler</entry>
	      </row>

	      <row>
		<entry>0x4ca</entry>
		<entry>r/w</entry>
		<entry>Kanal 6 hohes Byte (Bits 23-16)
		  Word-Z&auml;hler</entry>
	      </row>

	      <row>
		<entry>0x4ce</entry>
		<entry>r/w</entry>
		<entry>Kanal 7 hohes Byte (Bits 23-16)
		  Word-Z&auml;hler</entry>
	      </row>

	      <row>
		<entry>0x487</entry>
		<entry>r/w</entry>
		<entry>Kanal 0 hohes Byte (Bits 31-24)
		  Seitenregister</entry>
	      </row>

	      <row>
		<entry>0x483</entry>
		<entry>r/w</entry>
		<entry>Kanal 1 hohes Byte (Bits 31-24)
		  Seitenregister</entry>
	      </row>

	      <row>
		<entry>0x481</entry>
		<entry>r/w</entry>
		<entry>Kanal 2 hohes Byte (Bits 31-24)
		  Seitenregister</entry>
	      </row>

	      <row>
		<entry>0x482</entry>
		<entry>r/w</entry>
		<entry>Kanal 3 hohes Byte (Bits 31-24)
		  Seitenregister</entry>
	      </row>

	      <row>
		<entry>0x48b</entry>
		<entry>r/w</entry>
		<entry>Kanal 5 hohes Byte (Bits 31-24)
		  Seitenregister</entry>
	      </row>

	      <row>
		<entry>0x489</entry>
		<entry>r/w</entry>
		<entry>Kanal 6 hohes Byte (Bits 31-24)
		  Seitenregister</entry>
	      </row>

	      <row>
		<entry>0x48a</entry>
		<entry>r/w</entry>
		<entry>Kanal 6 hohes Byte (Bits 31-24)
		  Seitenregister</entry>
	      </row>

	      <row>
		<entry>0x48f</entry>
		<entry>r/w</entry>
		<entry>hohes Byte Seitenauffrischung</entry>
	      </row>

	      <row>
		<entry>0x4e0</entry>
		<entry>r/w</entry>
		<entry>Kanal 0 Halteregister (Bits 7-2)</entry>
	      </row>

	      <row>
		<entry>0x4e1</entry>
		<entry>r/w</entry>
		<entry>Kanal 0 Halteregister (Bits 15-8)</entry>
	      </row>

	      <row>
		<entry>0x4e2</entry>
		<entry>r/w</entry>
		<entry>Kanal 0 Halteregister (Bits 23-16)</entry>
	      </row>

	      <row>
		<entry>0x4e4</entry>
		<entry>r/w</entry>
		<entry>Kanal 1 Halteregister (Bits 7-2)</entry>
	      </row>

	      <row>
		<entry>0x4e5</entry>
		<entry>r/w</entry>
		<entry>Kanal 1 Halteregister (Bits 15-8)</entry>
	      </row>

	      <row>
		<entry>0x4e6</entry>
		<entry>r/w</entry>
		<entry>Kanal 1 Halteregister (Bits 23-16)</entry>
	      </row>

	      <row>
		<entry>0x4e8</entry>
		<entry>r/w</entry>
		<entry>Kanal 2 Halteregister (Bits 7-2)</entry>
	      </row>

	      <row>
		<entry>0x4e9</entry>
		<entry>r/w</entry>
		<entry>Kanal 2 Halteregister (Bits 15-8)</entry>
	      </row>

	      <row>
		<entry>0x4ea</entry>
		<entry>r/w</entry>
		<entry>Kanal 2 Halteregister (Bits 23-16)</entry>
	      </row>

	      <row>
		<entry>0x4ec</entry>
		<entry>r/w</entry>
		<entry>Kanal 3 Halteregister (Bits 7-2)</entry>
	      </row>

	      <row>
		<entry>0x4ed</entry>
		<entry>r/w</entry>
		<entry>Kanal 3 Halteregister (Bits 15-8)</entry>
	      </row>

	      <row>
		<entry>0x4ee</entry>
		<entry>r/w</entry>
		<entry>Kanal 3 Halteregister (Bits 23-16)</entry>
	      </row>

	      <row>
		<entry>0x4f4</entry>
		<entry>r/w</entry>
		<entry>Kanal 5 Halteregister (Bits 7-2)</entry>
	      </row>

	      <row>
		<entry>0x4f5</entry>
		<entry>r/w</entry>
		<entry>Kanal 5 Halteregister (Bits 15-8)</entry>
	      </row>

	      <row>
		<entry>0x4f6</entry>
		<entry>r/w</entry>
		<entry>Kanal 5 Halteregister (Bits 23-16)</entry>
	      </row>

	      <row>
		<entry>0x4f8</entry>
		<entry>r/w</entry>
		<entry>Kanal 6 Halteregister (Bits 7-2)</entry>
	      </row>

	      <row>
		<entry>0x4f9</entry>
		<entry>r/w</entry>
		<entry>Kanal 6 Halteregister (Bits 15-8)</entry>
	      </row>

	      <row>
		<entry>0x4fa</entry>
		<entry>r/w</entry>
		<entry>Kanal 6 Halteregister (Bits 23-16)</entry>
	      </row>

	      <row>
		<entry>0x4fc</entry>
		<entry>r/w</entry>
		<entry>Kanal 7 Halteregister (Bits 7-2)</entry>
	      </row>

	      <row>
		<entry>0x4fd</entry>
		<entry>r/w</entry>
		<entry>Kanal 7 Halteregister (Bits 15-8)</entry>
	      </row>

	      <row>
		<entry>0x4fe</entry>
		<entry>r/w</entry>
		<entry>Kanal 7 Halteregister (Bits 23-16)</entry>
	      </row>

	      <row>
		<entry>0x40a</entry>
		<entry>write</entry>
		<entry>Kanal 0-3 Chaining-Modusregister</entry>
	      </row>

	      <row>
		<entry>0x40a</entry>
		<entry>read</entry>
		<entry>Kanal Interrupt Status-Register</entry>
	      </row>

	      <row>
		<entry>0x4d4</entry>
		<entry>write</entry>
		<entry>Kanal 4-7 Chaining-Modusregister</entry>
	      </row>

	      <row>
		<entry>0x4d4</entry>
		<entry>read</entry>
		<entry>Chaining Mode Status</entry>
	      </row>

	      <row>
		<entry>0x40c</entry>
		<entry>read</entry>
		<entry>Chain Buffer Expiration
		  Kontrollregister</entry>
	      </row>

	      <row>
		<entry>0x410</entry>
		<entry>write</entry>
		<entry>Kanal 0 Scatter-Gather Befehlsregister</entry>
	      </row>

	      <row>
		<entry>0x411</entry>
		<entry>write</entry>
		<entry>Kanal 1 Scatter-Gather Befehlsregister</entry>
	      </row>

	      <row>
		<entry>0x412</entry>
		<entry>write</entry>
		<entry>Kanal 2 Scatter-Gather Befehlsregister</entry>
	      </row>

	      <row>
		<entry>0x413</entry>
		<entry>write</entry>
		<entry>Kanal 3 Scatter-Gather Befehlsregister</entry>
	      </row>

	      <row>
		<entry>0x415</entry>
		<entry>write</entry>
		<entry>Kanal 5 Scatter-Gather Befehlsregister</entry>
	      </row>

	      <row>
		<entry>0x416</entry>
		<entry>write</entry>
		<entry>Kanal 6 Scatter-Gather Befehlsregister</entry>
	      </row>

	      <row>
		<entry>0x417</entry>
		<entry>write</entry>
		<entry>Kanal 7 Scatter-Gather Befehlsregister</entry>
	      </row>

	      <row>
		<entry>0x418</entry>
		<entry>read</entry>
		<entry>Kanal 0 Scatter-Gather Statusregister</entry>
	      </row>

	      <row>
		<entry>0x419</entry>
		<entry>read</entry>
		<entry>Kanal 1 Scatter-Gather Statusregister</entry>
	      </row>

	      <row>
		<entry>0x41a</entry>
		<entry>read</entry>
		<entry>Kanal 2 Scatter-Gather Statusregister</entry>
	      </row>

	      <row>
		<entry>0x41b</entry>
		<entry>read</entry>
		<entry>Kanal 3 Scatter-Gather Statusregister</entry>
	      </row>

	      <row>
		<entry>0x41d</entry>
		<entry>read</entry>
		<entry>Kanal 5 Scatter-Gather Statusregister</entry>
	      </row>

	      <row>
		<entry>0x41e</entry>
		<entry>read</entry>
		<entry>Kanal 5 Scatter-Gather Statusregister</entry>
	      </row>

	      <row>
		<entry>0x41f</entry>
		<entry>read</entry>
		<entry>Kanal 7 Scatter-Gather Statusregister</entry>
	      </row>

	      <row>
		<entry>0x420-0x423</entry>
		<entry>r/w</entry>
		<entry>Kanal 0 Scatter-Gather Descriptor Table Pointer
		  Register</entry>
	      </row>

	      <row>
		<entry>0x424-0x427</entry>
		<entry>r/w</entry>
		<entry>Kanal 1 Scatter-Gather Descriptor Table Pointer
		  Register</entry>
	      </row>

	      <row>
		<entry>0x428-0x42b</entry>
		<entry>r/w</entry>
		<entry>Kanal 2 Scatter-Gather Descriptor Table Pointer
		  Register</entry>
	      </row>

	      <row>
		<entry>0x42c-0x42f</entry>
		<entry>r/w</entry>
		<entry>Kanal 3 Scatter-Gather Descriptor Table Pointer
		  Register</entry>
	      </row>

	      <row>
		<entry>0x434-0x437</entry>
		<entry>r/w</entry>
		<entry>Kanal 5 Scatter-Gather Descriptor Table Pointer
		  Register</entry>
	      </row>

	      <row>
		<entry>0x438-0x43b</entry>
		<entry>r/w</entry>
		<entry>Kanal 6 Scatter-Gather Descriptor Table Pointer
		  Register</entry>
	      </row>

	      <row>
		<entry>0x43c-0x43f</entry>
		<entry>r/w</entry>
		<entry>Kanal 7 Scatter-Gather Descriptor Table Pointer
		  Register</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </sect3>
    </sect2>
  </sect1>
</chapter>
